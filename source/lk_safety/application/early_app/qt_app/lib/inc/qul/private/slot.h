/******************************************************************************
**
** Copyright (C) 2020 The Qt Company Ltd.
** Contact: https://www.qt.io/licensing/
**
** This file is part of the Qt Quick Ultralite module.
**
** $QT_BEGIN_LICENSE:COMM$
**
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see http://www.qt.io/terms-conditions. For further
** information use the contact form at http://www.qt.io/contact-us.
**
** $QT_END_LICENSE$
**
******************************************************************************/
#pragma once

// WARNING: This file is auto-generated by the generator in util/signalsslotgenerator

#include <qul/signal.h>

namespace Qul {
namespace Private {
template<typename QtObject, typename T>
struct Slot;
template<typename QtObject>
struct Slot<QtObject, void()> : SlotBase<void()>
{
    typedef void (*Function)(QtObject *);

    Slot(QtObject *obj, Function f, Signal<void()> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void()>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void()> *self) { (*static_cast<Slot *>(self))(); }

    void connect(Signal<void()> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()() const { function(obj); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1>
struct Slot<QtObject, void(T1)> : SlotBase<void(T1)>
{
    typedef void (*Function)(QtObject *, T1);

    Slot(QtObject *obj, Function f, Signal<void(T1)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1)> *self, T1 arg1) { (*static_cast<Slot *>(self))(arg1); }

    void connect(Signal<void(T1)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1) const { function(obj, arg1); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2>
struct Slot<QtObject, void(T1, T2)> : SlotBase<void(T1, T2)>
{
    typedef void (*Function)(QtObject *, T1, T2);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2)> *self, T1 arg1, T2 arg2)
    {
        (*static_cast<Slot *>(self))(arg1, arg2);
    }

    void connect(Signal<void(T1, T2)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2) const { function(obj, arg1, arg2); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3>
struct Slot<QtObject, void(T1, T2, T3)> : SlotBase<void(T1, T2, T3)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2, T3)> *self, T1 arg1, T2 arg2, T3 arg3)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3);
    }

    void connect(Signal<void(T1, T2, T3)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3) const { function(obj, arg1, arg2, arg3); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3, typename T4>
struct Slot<QtObject, void(T1, T2, T3, T4)> : SlotBase<void(T1, T2, T3, T4)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2, T3, T4)> *self, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4);
    }

    void connect(Signal<void(T1, T2, T3, T4)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4) const { function(obj, arg1, arg2, arg3, arg4); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3, typename T4, typename T5>
struct Slot<QtObject, void(T1, T2, T3, T4, T5)> : SlotBase<void(T1, T2, T3, T4, T5)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4, T5);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4, T5)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4, T5)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2, T3, T4, T5)> *self, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4, arg5);
    }

    void connect(Signal<void(T1, T2, T3, T4, T5)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) const { function(obj, arg1, arg2, arg3, arg4, arg5); }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6>
struct Slot<QtObject, void(T1, T2, T3, T4, T5, T6)> : SlotBase<void(T1, T2, T3, T4, T5, T6)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4, T5, T6);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4, T5, T6)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4, T5, T6)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(
        SlotBase<void(T1, T2, T3, T4, T5, T6)> *self, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4, arg5, arg6);
    }

    void connect(Signal<void(T1, T2, T3, T4, T5, T6)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) const
    {
        function(obj, arg1, arg2, arg3, arg4, arg5, arg6);
    }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7>
struct Slot<QtObject, void(T1, T2, T3, T4, T5, T6, T7)> : SlotBase<void(T1, T2, T3, T4, T5, T6, T7)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4, T5, T6, T7);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4, T5, T6, T7)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4, T5, T6, T7)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(
        SlotBase<void(T1, T2, T3, T4, T5, T6, T7)> *self, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }

    void connect(Signal<void(T1, T2, T3, T4, T5, T6, T7)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) const
    {
        function(obj, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8>
struct Slot<QtObject, void(T1, T2, T3, T4, T5, T6, T7, T8)> : SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4, T5, T6, T7, T8);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4, T5, T6, T7, T8)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8)> *self,
                            T1 arg1,
                            T2 arg2,
                            T3 arg3,
                            T4 arg4,
                            T5 arg5,
                            T6 arg6,
                            T7 arg7,
                            T8 arg8)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }

    void connect(Signal<void(T1, T2, T3, T4, T5, T6, T7, T8)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) const
    {
        function(obj, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }

private:
    QtObject *obj;
    Function function;
};
template<typename QtObject,
         typename T1,
         typename T2,
         typename T3,
         typename T4,
         typename T5,
         typename T6,
         typename T7,
         typename T8,
         typename T9>
struct Slot<QtObject, void(T1, T2, T3, T4, T5, T6, T7, T8, T9)> : SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
    typedef void (*Function)(QtObject *, T1, T2, T3, T4, T5, T6, T7, T8, T9);

    Slot(QtObject *obj, Function f, Signal<void(T1, T2, T3, T4, T5, T6, T7, T8, T9)> *signal = NULL)
        : obj(obj)
        , function(f)
    {
        SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8, T9)>::call = call;
        if (signal) {
            signal->connect(this);
        }
    }

    static inline void call(SlotBase<void(T1, T2, T3, T4, T5, T6, T7, T8, T9)> *self,
                            T1 arg1,
                            T2 arg2,
                            T3 arg3,
                            T4 arg4,
                            T5 arg5,
                            T6 arg6,
                            T7 arg7,
                            T8 arg8,
                            T9 arg9)
    {
        (*static_cast<Slot *>(self))(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
    }

    void connect(Signal<void(T1, T2, T3, T4, T5, T6, T7, T8, T9)> *signal)
    {
        this->remove();
        signal->connect(this);
    }

    void operator()(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) const
    {
        function(obj, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
    }

private:
    QtObject *obj;
    Function function;
};
} // namespace Private
} // namespace Qul
