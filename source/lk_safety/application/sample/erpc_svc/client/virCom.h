/*
 * Generated by erpcgen 1.7.0 on Sun Feb  2 16:49:53 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#if !defined(_virCom_h_)
#define _virCom_h_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "erpc_version.h"

#if 10700 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

#if !defined(ERPC_TYPE_DEFINITIONS)
#define ERPC_TYPE_DEFINITIONS

// Aliases data types declarations
typedef struct virbaud_rate_t virbaud_rate_t;
typedef struct virflexcan_fd_config_t virflexcan_fd_config_t;
typedef struct virflexcan_config_t virflexcan_config_t;
typedef struct virflexcan_timing_config_t virflexcan_timing_config_t;
typedef struct virflexcan_rx_fifo_config_t virflexcan_rx_fifo_config_t;
typedef struct virCan_ControllerConfig virCan_ControllerConfig;
typedef struct virCan_RxMBConfig virCan_RxMBConfig;
typedef struct virCan_TxMBConfig virCan_TxMBConfig;
typedef struct virCan_RxFIFOConfig virCan_RxFIFOConfig;
typedef struct virCan_BaudRateConfig virCan_BaudRateConfig;
typedef struct virCan_ConfigType virCan_ConfigType;
typedef struct virCan_PduType virCan_PduType;
typedef struct virLin_PduType virLin_PduType;
typedef struct virLin_VersionInfoType virLin_VersionInfoType;

// Structures/unions data types declarations
/******************* CAN data structure *********************/
struct virbaud_rate_t
{
    uint32_t arbitrBaudRate;
    uint32_t dataBaudRate;
};

struct virflexcan_fd_config_t
{
    bool enableBRS;
    bool enableTDC;
    uint8_t TDCOffset;
    uint8_t r0_mb_data_size;
    uint8_t r1_mb_data_size;
    uint8_t r2_mb_data_size;
    uint8_t r3_mb_data_size;
};

struct virflexcan_config_t
{
    virbaud_rate_t baudRate;
    uint8_t clkSrc;
    uint8_t maxMbNum;
    bool enableLoopBack;
    bool enableSelfWakeup;
    bool enableIndividMask;
    bool enableDoze;
    bool enableCANFD;
    virflexcan_fd_config_t can_fd_cfg;
};

struct virflexcan_timing_config_t
{
    uint16_t arbitrPreDivider;
    uint16_t dataPreDivider;
    uint8_t arbitrRJumpwidth;
    uint8_t arbitrPhaseSeg1;
    uint8_t arbitrPhaseSeg2;
    uint8_t arbitrPropSeg;
    uint8_t dataRJumpwidth;
    uint8_t dataPhaseSeg1;
    uint8_t dataPhaseSeg2;
    uint8_t dataPropSeg;
};

struct virflexcan_rx_fifo_config_t
{
    uint32_t * idFilterTable;
    uint8_t idFilterNum;
    uint8_t idFilterType;
    uint8_t priority;
};

struct virCan_ControllerConfig
{
    uint8_t controllerId;
    uint32_t baseAddr;
    uint32_t clkFreq;
    virflexcan_config_t flexcanCfg;
};

struct virCan_RxMBConfig
{
    uint32_t hwObjId;
    uint8_t controllerId;
    uint8_t mbId;
    uint32_t frameId;
    uint32_t rxIDFilterMask;
    uint8_t frameType;
    uint8_t frameFormat;
};

struct virCan_TxMBConfig
{
    uint32_t hwObjId;
    uint8_t controllerId;
    uint8_t mbId;
    uint8_t paddingVal;
    uint8_t isMBIdle;
    uint32_t txLock;
};

struct virCan_RxFIFOConfig
{
    uint32_t hwObjId;
    uint8_t controllerId;
    virflexcan_rx_fifo_config_t flexcanRxFIFOCfg;
    uint32_t rxFifoIdFilterMask;
};

struct virCan_BaudRateConfig
{
    virflexcan_timing_config_t bitTimingCfg;
};

struct virCan_ConfigType
{
    uint8_t controllerCount;
    uint8_t rxFifoCount;
    uint8_t baudRateCfgCount;
    uint16_t rxCount;
    uint16_t txCount;
    virCan_ControllerConfig * ctrllerCfg;
    virCan_RxMBConfig * rxMBCfg;
    virCan_TxMBConfig * txMBCfg;
    virCan_RxFIFOConfig * rxFIFOCfg;
    virCan_BaudRateConfig * baudRateCfg;
};

struct virCan_PduType
{
    uint16_t swPduHandle;
    uint8_t length;
    uint32_t id;
    uint8_t * sdu;
};

/******************* LIN data structure *********************/
struct virLin_PduType
{
    uint8_t Pid;
    uint8_t Cs;
    uint8_t Drc;
    uint8_t Dl;
    uint8_t * Sdu;
};

struct virLin_VersionInfoType
{
    uint16_t vendorID;               /**< @brief vendor ID */
    uint16_t moduleID;               /**< @brief BSW module ID */
    uint8_t sw_major_version;       /**< @brief BSW module software major version */
    uint8_t sw_minor_version;       /**< @brief BSW module software minor version */
    uint8_t sw_patch_version;       /**< @brief BSW module software patch version */
};


#endif // ERPC_TYPE_DEFINITIONS

/*! @brief virCom identifiers */
enum _virCom_ids
{
    kvirCom_service_id = 1,
    kvirCom_virCan_Init_id = 1,
    kvirCom_virCan_DeInit_id = 2,
    kvirCom_virCan_SetBaudrate_id = 3,
    kvirCom_virCan_SetControllerMode_id = 4,
    kvirCom_virCan_DisableControllerInterrupts_id = 5,
    kvirCom_virCan_EnableControllerInterrupts_id = 6,
    kvirCom_virCan_CheckWakeup_id = 7,
    kvirCom_virCan_GetControllerErrorState_id = 8,
    kvirCom_virCan_GetControllerMode_id = 9,
    kvirCom_virCan_Write_id = 10,
    kvirCom_virLin_Init_id = 11,
    kvirCom_virLin_SendFrame_id = 12,
    kvirCom_virLin_CheckWakeup_id = 13,
    kvirCom_virLin_GetVersionInfo_id = 14,
    kvirCom_virLin_GoToSleep_id = 15,
    kvirCom_virLin_GoToSleepInternal_id = 16,
    kvirCom_virLin_Wakeup_id = 17,
    kvirCom_virLin_WakeupInternal_id = 18,
    kvirCom_virLin_GetStatus_id = 19,
};

#if defined(__cplusplus)
extern "C" {
#endif

//! @name virCom
//@{
/******************* CAN function interface *********************/
void virCan_Init(const virCan_ConfigType * Config);

void virCan_DeInit(void);

uint8_t virCan_SetBaudrate(uint8_t Controller, uint16_t BaudRateConfigID);

uint8_t virCan_SetControllerMode(uint8_t Controller, uint8_t Transition);

void virCan_DisableControllerInterrupts(uint8_t Controller);

void virCan_EnableControllerInterrupts(uint8_t Controller);

void virCan_CheckWakeup(uint8_t Controller);

uint8_t virCan_GetControllerErrorState(uint8_t Controller, uint8_t * ErrorStatePtr);

uint8_t virCan_GetControllerMode(uint8_t Controller, uint8_t * ControllerModePtr);

uint8_t virCan_Write(uint16_t Hth, const virCan_PduType * virPduInfo);

/******************* LIN function interface *********************/
void virLin_Init(void);

uint8_t virLin_SendFrame(uint8_t Channel, const virLin_PduType * PduInfoPtr);

uint8_t virLin_CheckWakeup(uint8_t Channel);

void virLin_GetVersionInfo(virLin_VersionInfoType * versioninfo);

uint8_t virLin_GoToSleep(uint8_t Channel);

uint8_t virLin_GoToSleepInternal(uint8_t Channel);

uint8_t virLin_Wakeup(uint8_t Channel);

uint8_t virLin_WakeupInternal(uint8_t Channel);

uint8_t virLin_GetStatus(uint8_t Channel, uint8_t * Lin_Sdu);
//@} 

#if defined(__cplusplus)
}
#endif

#endif // _virCom_h_
