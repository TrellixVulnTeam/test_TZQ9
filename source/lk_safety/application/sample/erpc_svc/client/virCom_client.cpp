/*
 * Generated by erpcgen 1.7.0 on Sun Feb  2 16:49:53 2020.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#include "erpc_port.h"
#include "erpc_codec.h"
extern "C"
{
#include "virCom.h"
}

#if 10700 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct virbaud_rate_t
static void write_virbaud_rate_t_struct(erpc::Codec * codec, const virbaud_rate_t * data);

//! @brief Function to write struct virflexcan_fd_config_t
static void write_virflexcan_fd_config_t_struct(erpc::Codec * codec, const virflexcan_fd_config_t * data);

//! @brief Function to write struct virflexcan_config_t
static void write_virflexcan_config_t_struct(erpc::Codec * codec, const virflexcan_config_t * data);

//! @brief Function to write struct virflexcan_timing_config_t
static void write_virflexcan_timing_config_t_struct(erpc::Codec * codec, const virflexcan_timing_config_t * data);

//! @brief Function to write struct virflexcan_rx_fifo_config_t
static void write_virflexcan_rx_fifo_config_t_struct(erpc::Codec * codec, const virflexcan_rx_fifo_config_t * data);

//! @brief Function to write struct virCan_ControllerConfig
static void write_virCan_ControllerConfig_struct(erpc::Codec * codec, const virCan_ControllerConfig * data);

//! @brief Function to write struct virCan_RxMBConfig
static void write_virCan_RxMBConfig_struct(erpc::Codec * codec, const virCan_RxMBConfig * data);

//! @brief Function to write struct virCan_TxMBConfig
static void write_virCan_TxMBConfig_struct(erpc::Codec * codec, const virCan_TxMBConfig * data);

//! @brief Function to write struct virCan_RxFIFOConfig
static void write_virCan_RxFIFOConfig_struct(erpc::Codec * codec, const virCan_RxFIFOConfig * data);

//! @brief Function to write struct virCan_BaudRateConfig
static void write_virCan_BaudRateConfig_struct(erpc::Codec * codec, const virCan_BaudRateConfig * data);

//! @brief Function to write struct virCan_ConfigType
static void write_virCan_ConfigType_struct(erpc::Codec * codec, const virCan_ConfigType * data);

//! @brief Function to write struct virCan_PduType
static void write_virCan_PduType_struct(erpc::Codec * codec, const virCan_PduType * data);

//! @brief Function to write struct virLin_PduType
static void write_virLin_PduType_struct(erpc::Codec * codec, const virLin_PduType * data);


// Write struct virbaud_rate_t function implementation
static void write_virbaud_rate_t_struct(erpc::Codec * codec, const virbaud_rate_t * data)
{
    codec->write(data->arbitrBaudRate);

    codec->write(data->dataBaudRate);
}

// Write struct virflexcan_fd_config_t function implementation
static void write_virflexcan_fd_config_t_struct(erpc::Codec * codec, const virflexcan_fd_config_t * data)
{
    codec->write(data->enableBRS);

    codec->write(data->enableTDC);

    codec->write(data->TDCOffset);

    codec->write(data->r0_mb_data_size);

    codec->write(data->r1_mb_data_size);

    codec->write(data->r2_mb_data_size);

    codec->write(data->r3_mb_data_size);
}

// Write struct virflexcan_config_t function implementation
static void write_virflexcan_config_t_struct(erpc::Codec * codec, const virflexcan_config_t * data)
{
    write_virbaud_rate_t_struct(codec, &(data->baudRate));

    codec->write(data->clkSrc);

    codec->write(data->maxMbNum);

    codec->write(data->enableLoopBack);

    codec->write(data->enableSelfWakeup);

    codec->write(data->enableIndividMask);

    codec->write(data->enableDoze);

    codec->write(data->enableCANFD);

    write_virflexcan_fd_config_t_struct(codec, &(data->can_fd_cfg));
}

// Write struct virflexcan_timing_config_t function implementation
static void write_virflexcan_timing_config_t_struct(erpc::Codec * codec, const virflexcan_timing_config_t * data)
{
    codec->write(data->arbitrPreDivider);

    codec->write(data->dataPreDivider);

    codec->write(data->arbitrRJumpwidth);

    codec->write(data->arbitrPhaseSeg1);

    codec->write(data->arbitrPhaseSeg2);

    codec->write(data->arbitrPropSeg);

    codec->write(data->dataRJumpwidth);

    codec->write(data->dataPhaseSeg1);

    codec->write(data->dataPhaseSeg2);

    codec->write(data->dataPropSeg);
}

// Write struct virflexcan_rx_fifo_config_t function implementation
static void write_virflexcan_rx_fifo_config_t_struct(erpc::Codec * codec, const virflexcan_rx_fifo_config_t * data)
{
    codec->startWriteList(data->idFilterNum);
    for (uint32_t listCount0 = 0; listCount0 < data->idFilterNum; ++listCount0)
    {
        codec->write(data->idFilterTable[listCount0]);
    }

    codec->write(data->idFilterType);

    codec->write(data->priority);
}

// Write struct virCan_ControllerConfig function implementation
static void write_virCan_ControllerConfig_struct(erpc::Codec * codec, const virCan_ControllerConfig * data)
{
    codec->write(data->controllerId);

    codec->write(data->baseAddr);

    codec->write(data->clkFreq);

    write_virflexcan_config_t_struct(codec, &(data->flexcanCfg));
}

// Write struct virCan_RxMBConfig function implementation
static void write_virCan_RxMBConfig_struct(erpc::Codec * codec, const virCan_RxMBConfig * data)
{
    codec->write(data->hwObjId);

    codec->write(data->controllerId);

    codec->write(data->mbId);

    codec->write(data->frameId);

    codec->write(data->rxIDFilterMask);

    codec->write(data->frameType);

    codec->write(data->frameFormat);
}

// Write struct virCan_TxMBConfig function implementation
static void write_virCan_TxMBConfig_struct(erpc::Codec * codec, const virCan_TxMBConfig * data)
{
    codec->write(data->hwObjId);

    codec->write(data->controllerId);

    codec->write(data->mbId);

    codec->write(data->paddingVal);

    codec->write(data->isMBIdle);

    codec->write(data->txLock);
}

// Write struct virCan_RxFIFOConfig function implementation
static void write_virCan_RxFIFOConfig_struct(erpc::Codec * codec, const virCan_RxFIFOConfig * data)
{
    codec->write(data->hwObjId);

    codec->write(data->controllerId);

    write_virflexcan_rx_fifo_config_t_struct(codec, &(data->flexcanRxFIFOCfg));

    codec->write(data->rxFifoIdFilterMask);
}

// Write struct virCan_BaudRateConfig function implementation
static void write_virCan_BaudRateConfig_struct(erpc::Codec * codec, const virCan_BaudRateConfig * data)
{
    write_virflexcan_timing_config_t_struct(codec, &(data->bitTimingCfg));
}

// Write struct virCan_ConfigType function implementation
static void write_virCan_ConfigType_struct(erpc::Codec * codec, const virCan_ConfigType * data)
{
    codec->startWriteList(data->controllerCount);
    for (uint32_t listCount0 = 0; listCount0 < data->controllerCount; ++listCount0)
    {
        write_virCan_ControllerConfig_struct(codec, &(data->ctrllerCfg[listCount0]));
    }

    codec->startWriteList(data->rxCount);
    for (uint32_t listCount1 = 0; listCount1 < data->rxCount; ++listCount1)
    {
        write_virCan_RxMBConfig_struct(codec, &(data->rxMBCfg[listCount1]));
    }

    codec->startWriteList(data->txCount);
    for (uint32_t listCount2 = 0; listCount2 < data->txCount; ++listCount2)
    {
        write_virCan_TxMBConfig_struct(codec, &(data->txMBCfg[listCount2]));
    }

    codec->startWriteList(data->rxFifoCount);
    for (uint32_t listCount3 = 0; listCount3 < data->rxFifoCount; ++listCount3)
    {
        write_virCan_RxFIFOConfig_struct(codec, &(data->rxFIFOCfg[listCount3]));
    }

    codec->startWriteList(data->baudRateCfgCount);
    for (uint32_t listCount4 = 0; listCount4 < data->baudRateCfgCount; ++listCount4)
    {
        write_virCan_BaudRateConfig_struct(codec, &(data->baudRateCfg[listCount4]));
    }
}

// Write struct virCan_PduType function implementation
static void write_virCan_PduType_struct(erpc::Codec * codec, const virCan_PduType * data)
{
    codec->write(data->swPduHandle);

    codec->write(data->id);

    codec->startWriteList(data->length);
    for (uint32_t listCount0 = 0; listCount0 < data->length; ++listCount0)
    {
        codec->write(data->sdu[listCount0]);
    }
}

// Write struct virLin_PduType function implementation
static void write_virLin_PduType_struct(erpc::Codec * codec, const virLin_PduType * data)
{
    codec->write(data->Pid);

    codec->write(data->Cs);

    codec->write(data->Drc);

    codec->startWriteList(data->Dl);
    for (uint32_t listCount0 = 0; listCount0 < data->Dl; ++listCount0)
    {
        codec->write(data->Sdu[listCount0]);
    }
}


//! @brief Function to read struct virLin_VersionInfoType
static void read_virLin_VersionInfoType_struct(erpc::Codec * codec, virLin_VersionInfoType * data);


// Read struct virLin_VersionInfoType function implementation
static void read_virLin_VersionInfoType_struct(erpc::Codec * codec, virLin_VersionInfoType * data)
{
    codec->read(&data->vendorID);

    codec->read(&data->moduleID);

    codec->read(&data->sw_major_version);

    codec->read(&data->sw_minor_version);

    codec->read(&data->sw_patch_version);
}



// virCom interface virCan_Init function client shim.
void virCan_Init(const virCan_ConfigType * Config)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_Init_id, request.getSequence());

        write_virCan_ConfigType_struct(codec, Config);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_Init_id);

    return;
}

// virCom interface virCan_DeInit function client shim.
void virCan_DeInit(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_DeInit_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_DeInit_id);

    return;
}

// virCom interface virCan_SetBaudrate function client shim.
uint8_t virCan_SetBaudrate(uint8_t Controller, uint16_t BaudRateConfigID)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_SetBaudrate_id, request.getSequence());

        codec->write(Controller);

        codec->write(BaudRateConfigID);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_SetBaudrate_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virCan_SetControllerMode function client shim.
uint8_t virCan_SetControllerMode(uint8_t Controller, uint8_t Transition)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_SetControllerMode_id, request.getSequence());

        codec->write(Controller);

        codec->write(Transition);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_SetControllerMode_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virCan_DisableControllerInterrupts function client shim.
void virCan_DisableControllerInterrupts(uint8_t Controller)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_DisableControllerInterrupts_id, request.getSequence());

        codec->write(Controller);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_DisableControllerInterrupts_id);

    return;
}

// virCom interface virCan_EnableControllerInterrupts function client shim.
void virCan_EnableControllerInterrupts(uint8_t Controller)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_EnableControllerInterrupts_id, request.getSequence());

        codec->write(Controller);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_EnableControllerInterrupts_id);

    return;
}

// virCom interface virCan_CheckWakeup function client shim.
void virCan_CheckWakeup(uint8_t Controller)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_CheckWakeup_id, request.getSequence());

        codec->write(Controller);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_CheckWakeup_id);

    return;
}

// virCom interface virCan_GetControllerErrorState function client shim.
uint8_t virCan_GetControllerErrorState(uint8_t Controller, uint8_t * ErrorStatePtr)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_GetControllerErrorState_id, request.getSequence());

        codec->write(Controller);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(ErrorStatePtr);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_GetControllerErrorState_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virCan_GetControllerMode function client shim.
uint8_t virCan_GetControllerMode(uint8_t Controller, uint8_t * ControllerModePtr)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_GetControllerMode_id, request.getSequence());

        codec->write(Controller);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(ControllerModePtr);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_GetControllerMode_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virCan_Write function client shim.
uint8_t virCan_Write(uint16_t Hth, const virCan_PduType * virPduInfo)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virCan_Write_id, request.getSequence());

        codec->write(Hth);

        write_virCan_PduType_struct(codec, virPduInfo);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virCan_Write_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_Init function client shim.
void virLin_Init(void)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_Init_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_Init_id);

    return;
}

// virCom interface virLin_SendFrame function client shim.
uint8_t virLin_SendFrame(uint8_t Channel, const virLin_PduType * PduInfoPtr)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_SendFrame_id, request.getSequence());

        codec->write(Channel);

        write_virLin_PduType_struct(codec, PduInfoPtr);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_SendFrame_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_CheckWakeup function client shim.
uint8_t virLin_CheckWakeup(uint8_t Channel)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_CheckWakeup_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_CheckWakeup_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_GetVersionInfo function client shim.
void virLin_GetVersionInfo(virLin_VersionInfoType * versioninfo)
{
    erpc_status_t err = kErpcStatus_Success;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_GetVersionInfo_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_virLin_VersionInfoType_struct(codec, versioninfo);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_GetVersionInfo_id);

    return;
}

// virCom interface virLin_GoToSleep function client shim.
uint8_t virLin_GoToSleep(uint8_t Channel)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_GoToSleep_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_GoToSleep_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_GoToSleepInternal function client shim.
uint8_t virLin_GoToSleepInternal(uint8_t Channel)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_GoToSleepInternal_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_GoToSleepInternal_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_Wakeup function client shim.
uint8_t virLin_Wakeup(uint8_t Channel)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_Wakeup_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_Wakeup_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_WakeupInternal function client shim.
uint8_t virLin_WakeupInternal(uint8_t Channel)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_WakeupInternal_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_WakeupInternal_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}

// virCom interface virLin_GetStatus function client shim.
uint8_t virLin_GetStatus(uint8_t Channel, uint8_t * Lin_Sdu)
{
    erpc_status_t err = kErpcStatus_Success;

    uint8_t result;

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kvirCom_service_id, kvirCom_virLin_GetStatus_id, request.getSequence());

        codec->write(Channel);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        uint32_t lengthTemp_0;
        codec->startReadList(&lengthTemp_0);
        for (uint32_t listCount0 = 0; listCount0 < lengthTemp_0; ++listCount0)
        {
            codec->read(&Lin_Sdu[listCount0]);
        }

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kvirCom_virLin_GetStatus_id);

    if (err)
    {
        return 0xFFU;
    }

    return result;
}
