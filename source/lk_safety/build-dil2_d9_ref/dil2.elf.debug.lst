
build-dil2_d9_ref/dil2.elf:     file format elf32-littlearm


Disassembly of section .text:

00100000 <_start>:
.globl _start

.section ".text.boot"

_start:
    b         platform_reset
  100000:	ea00000e 	b	100040 <arm_reset>
    ldr pc,   arm_undefined_const
  100004:	e59ff018 	ldr	r15, [pc, #24]	; 100024 <arm_undefined_const>
    ldr pc,	  FreeRTOS_SWI_Handler_const	/* arm_syscall */
  100008:	e59ff018 	ldr	r15, [pc, #24]	; 100028 <FreeRTOS_SWI_Handler_const>
    ldr pc,   arm_prefetch_abort_const
  10000c:	e59ff018 	ldr	r15, [pc, #24]	; 10002c <arm_prefetch_abort_const>
    ldr pc,   arm_data_abort_const
  100010:	e59ff018 	ldr	r15, [pc, #24]	; 100030 <arm_data_abort_const>
    ldr pc,   arm_reserved_const
  100014:	e59ff018 	ldr	r15, [pc, #24]	; 100034 <arm_reserved_const>
    ldr pc,	  FreeRTOS_IRQ_Handler_const	/* arm_irq */
  100018:	e59ff018 	ldr	r15, [pc, #24]	; 100038 <FreeRTOS_IRQ_Handler_const>
    ldr pc,   arm_fiq_const
  10001c:	e59ff018 	ldr	r15, [pc, #24]	; 10003c <arm_fiq_const>

00100020 <platform_reset_const>:
  100020:	00100040 	.word	0x00100040

00100024 <arm_undefined_const>:
  100024:	00100c58 	.word	0x00100c58

00100028 <FreeRTOS_SWI_Handler_const>:
  100028:	00110be0 	.word	0x00110be0

0010002c <arm_prefetch_abort_const>:
  10002c:	00100d08 	.word	0x00100d08

00100030 <arm_data_abort_const>:
  100030:	00100d64 	.word	0x00100d64

00100034 <arm_reserved_const>:
  100034:	00100dc0 	.word	0x00100dc0

00100038 <FreeRTOS_IRQ_Handler_const>:
  100038:	00110ce0 	.word	0x00110ce0

0010003c <arm_fiq_const>:
  10003c:	00100e44 	.word	0x00100e44

00100040 <arm_reset>:
    /* Fall through for the weak symbol */

.globl arm_reset
arm_reset:
#ifdef LOCKSTEP_SCR_ADDR
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  100040:	e59f0118 	ldr	r0, [pc, #280]	; 100160 <arm_reset+0x120>
    ldr     r1, [r0, #0]
  100044:	e5901000 	ldr	r1, [r0]
    bic     r1, #(0x3<<LOCKSTEP_SCR_BIT)
  100048:	e3c11003 	bic	r1, r1, #3
    str     r1, [r0, #0]
  10004c:	e5801000 	str	r1, [r0]
#endif

    /* do some early cpu setup */
    mrc     p15, 0, r12, c1, c0, 0
  100050:	ee11cf10 	mrc	15, 0, r12, cr1, cr0, {0}
    /* i/d cache disable, mmu disabled */
    bic     r12, #(1<<12)
  100054:	e3ccca01 	bic	r12, r12, #4096	; 0x1000
    bic     r12, #(1<<2 | 1<<0)
  100058:	e3ccc005 	bic	r12, r12, #5
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    orr     r12, r12, #(1<<12)
    orr     r12, r12, #(1<<2)
#endif // WITH_KERNEL_VM
    mcr     p15, 0, r12, c1, c0, 0
  10005c:	ee01cf10 	mcr	15, 0, r12, cr1, cr0, {0}

    /* calculate the physical offset from our eventual virtual location */
.Lphys_offset:
    ldr     r4, =.Lphys_offset
  100060:	e59f40fc 	ldr	r4, [pc, #252]	; 100164 <arm_reset+0x124>
    adr     r11, .Lphys_offset
  100064:	e24fb00c 	sub	r11, r15, #12
    sub     r11, r11, r4
  100068:	e04bb004 	sub	r11, r11, r4

#if WITH_NO_PHYS_RELOCATION
    /* assume that image is properly loaded in physical memory */
#else
    /* see if we need to relocate to our proper location in physical memory */
    adr     r4, _start                           /* this emits sub r4, pc, #constant */
  10006c:	e24f4074 	sub	r4, r15, #116	; 0x74
    ldr     r5, =(MEMBASE + KERNEL_LOAD_OFFSET)  /* calculate the binary's physical load address */
  100070:	e3a05601 	mov	r5, #1048576	; 0x100000
    subs    r12, r4, r5                          /* calculate the delta between where we're loaded and the proper spot */
  100074:	e054c005 	subs	r12, r4, r5
    beq     .Lrelocate_done
  100078:	0a00000a 	beq	1000a8 <arm_reset+0x68>

    /* we need to relocate ourselves to the proper spot */
    ldr     r6, =__data_end
  10007c:	e59f60e4 	ldr	r6, [pc, #228]	; 100168 <arm_reset+0x128>
    ldr     r7, =(KERNEL_BASE - MEMBASE)
  100080:	e3a07000 	mov	r7, #0
    sub     r6, r7
  100084:	e0466007 	sub	r6, r6, r7
    add     r6, r12
  100088:	e086600c 	add	r6, r6, r12

.Lrelocate_loop:
    ldr     r7, [r4], #4
  10008c:	e4947004 	ldr	r7, [r4], #4
    str     r7, [r5], #4
  100090:	e4857004 	str	r7, [r5], #4
    cmp     r4, r6
  100094:	e1540006 	cmp	r4, r6
    bne     .Lrelocate_loop
  100098:	1afffffb 	bne	10008c <arm_reset+0x4c>

    /* we're relocated, jump to the right address */
    sub     pc, r12
  10009c:	e04ff00c 	sub	r15, r15, r12
    nop     /* skipped in the add to pc */
  1000a0:	e320f000 	nop	{0}

    /* recalculate the physical offset */
    sub     r11, r11, r12
  1000a4:	e04bb00c 	sub	r11, r11, r12
#endif // WITH_KERNEL_VM

    /* at this point we're running at our final location in virtual memory (if enabled) */
.Lstack_setup:
    /* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */
	mov 	r12, #0
  1000a8:	e3a0c000 	mov	r12, #0

    /* Setup normal interrupt stack */
    cpsid 	i, 	#MODE_IRQ
  1000ac:	f10e0092 	cpsid	i,#18
    ldr 	r12, =irq_stack
  1000b0:	e59fc0b4 	ldr	r12, [pc, #180]	; 10016c <arm_reset+0x12c>
    add 	r12, #ARCH_IRQ_STACK_SIZE
  1000b4:	e28ccc02 	add	r12, r12, #512	; 0x200
    mov 	sp, r12
  1000b8:	e1a0d00c 	mov	r13, r12

    /* Setup fast interrupt stack */
    cpsid 	i, 	#MODE_FIQ
  1000bc:	f10e0091 	cpsid	i,#17
    ldr 	r12, =fiq_stack
  1000c0:	e59fc0a8 	ldr	r12, [pc, #168]	; 100170 <arm_reset+0x130>
    add 	r12, #ARCH_FIQ_STACK_SIZE
  1000c4:	e28ccc01 	add	r12, r12, #256	; 0x100
    mov 	sp, r12
  1000c8:	e1a0d00c 	mov	r13, r12

    /* Setup data abort stack */
    cpsid 	i, 	#MODE_ABT
  1000cc:	f10e0097 	cpsid	i,#23
    ldr 	r12, =abt_stack
  1000d0:	e59fc09c 	ldr	r12, [pc, #156]	; 100174 <arm_reset+0x134>
    add 	r12, #ARCH_ABT_STACK_SIZE
  1000d4:	e28cc080 	add	r12, r12, #128	; 0x80
    mov 	sp, r12
  1000d8:	e1a0d00c 	mov	r13, r12

	/* Setup undefined instruction stack */
    cpsid 	i, 	#MODE_UND
  1000dc:	f10e009b 	cpsid	i,#27
    ldr 	r12, =und_stack
  1000e0:	e59fc090 	ldr	r12, [pc, #144]	; 100178 <arm_reset+0x138>
    add 	r12, #ARCH_UND_STACK_SIZE
  1000e4:	e28cc080 	add	r12, r12, #128	; 0x80
    mov 	sp, r12
  1000e8:	e1a0d00c 	mov	r13, r12

    /* Setup system/user stack */
    cpsid 	i, 	#MODE_SYS
  1000ec:	f10e009f 	cpsid	i,#31
    ldr 	r12, =sys_stack
  1000f0:	e59fc084 	ldr	r12, [pc, #132]	; 10017c <arm_reset+0x13c>
    add 	r12, #ARCH_SYS_STACK_SIZE
  1000f4:	e28ccb02 	add	r12, r12, #2048	; 0x800
    mov 	sp, r12
  1000f8:	e1a0d00c 	mov	r13, r12

    /* Setup supervisor stack */
    cpsid 	i, 	#MODE_SVC
  1000fc:	f10e0093 	cpsid	i,#19
    ldr 	r12, =svc_stack
  100100:	e59fc078 	ldr	r12, [pc, #120]	; 100180 <arm_reset+0x140>
    add 	r12, #ARCH_SVC_STACK_SIZE
  100104:	e28ccb02 	add	r12, r12, #2048	; 0x800
    mov 	sp, r12
  100108:	e1a0d00c 	mov	r13, r12

    /* stay in supervisor mode from now on out */
    mov r0,#3
  10010c:	e3a00003 	mov	r0, #3
    bl arch_enable_cache
  100110:	eb00020f 	bl	100954 <arch_enable_cache>

    /* copy the initialized data segment out of rom if necessary */
    ldr     r4, =__data_start_rom
  100114:	e59f4068 	ldr	r4, [pc, #104]	; 100184 <arm_reset+0x144>
    ldr     r5, =__data_start
  100118:	e59f5068 	ldr	r5, [pc, #104]	; 100188 <arm_reset+0x148>
    ldr     r6, =__data_end
  10011c:	e59f6044 	ldr	r6, [pc, #68]	; 100168 <arm_reset+0x128>

    cmp     r4, r5
  100120:	e1540005 	cmp	r4, r5
    beq     .L__do_bss
  100124:	0a000003 	beq	100138 <arm_reset+0xf8>

.L__copy_loop:
    cmp     r5, r6
  100128:	e1550006 	cmp	r5, r6
    ldrlt   r7, [r4], #4
  10012c:	b4947004 	ldrlt	r7, [r4], #4
    strlt   r7, [r5], #4
  100130:	b4857004 	strlt	r7, [r5], #4
    blt     .L__copy_loop
  100134:	bafffffb 	blt	100128 <arm_reset+0xe8>

.L__do_bss:
    /* clear out the bss */
    ldr     r4, =__bss_start
  100138:	e59f404c 	ldr	r4, [pc, #76]	; 10018c <arm_reset+0x14c>
    ldr     r5, =_end
  10013c:	e59f504c 	ldr	r5, [pc, #76]	; 100190 <arm_reset+0x150>
    mov     r6, #0
  100140:	e3a06000 	mov	r6, #0
.L__bss_loop:
    cmp     r4, r5
  100144:	e1540005 	cmp	r4, r5
    strlt   r6, [r4], #4
  100148:	b4846004 	strlt	r6, [r4], #4
    blt     .L__bss_loop
  10014c:	bafffffc 	blt	100144 <arm_reset+0x104>

#endif

.L__STARTUP:
    /* change to system mode */
    cpsid 	i, 	#MODE_SYS
  100150:	f10e009f 	cpsid	i,#31

    ldr     r0, =lk_main
  100154:	e59f0038 	ldr	r0, [pc, #56]	; 100194 <arm_reset+0x154>
    blx     r0
  100158:	e12fff30 	blx	r0
    b       .
  10015c:	eafffffe 	b	10015c <arm_reset+0x11c>
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  100160:	fc297000 	.word	0xfc297000
    ldr     r4, =.Lphys_offset
  100164:	00100060 	.word	0x00100060
    ldr     r6, =__data_end
  100168:	0012cb68 	.word	0x0012cb68
    ldr 	r12, =irq_stack
  10016c:	0012cd40 	.word	0x0012cd40
    ldr 	r12, =fiq_stack
  100170:	0012cc40 	.word	0x0012cc40
    ldr 	r12, =abt_stack
  100174:	0012cbc0 	.word	0x0012cbc0
    ldr 	r12, =und_stack
  100178:	0012df40 	.word	0x0012df40
    ldr 	r12, =sys_stack
  10017c:	0012d740 	.word	0x0012d740
    ldr 	r12, =svc_stack
  100180:	0012cf40 	.word	0x0012cf40
    ldr     r4, =__data_start_rom
  100184:	0011f5c8 	.word	0x0011f5c8
    ldr     r5, =__data_start
  100188:	0011f5c8 	.word	0x0011f5c8
    ldr     r4, =__bss_start
  10018c:	0012cb80 	.word	0x0012cb80
    ldr     r5, =_end
  100190:	0013330c 	.word	0x0013330c
    ldr     r0, =lk_main
  100194:	0010199d 	.word	0x0010199d

00100198 <target_early_init>:
void sdm_display_init(void);

void target_early_init(void)
{

}
  100198:	4770      	bx	r14
  10019a:	bf00      	nop

0010019c <target_init>:
#if ENABLE_SD_DISP
#if CONFIG_USE_SYS_PROPERTY
    system_property_wait_condition(DMP_ID_PLL_CLK_STATUS, 1);
#endif

    sdm_display_init();
  10019c:	f00a b916 	b.w	10a3cc <sdm_display_init>

001001a0 <uart_port_init>:
};



void uart_port_init(void)
{
  1001a0:	b500      	push	{r14}
    void *port_init_handle = NULL;
  1001a2:	2300      	movs	r3, #0
{
  1001a4:	b083      	sub	sp, #12
    hal_port_creat_handle(&port_init_handle,
  1001a6:	f44f 61a0 	mov.w	r1, #1280	; 0x500
    void *port_init_handle = NULL;
  1001aa:	a802      	add	r0, sp, #8
    hal_port_creat_handle(&port_init_handle,
  1001ac:	f2c8 2194 	movt	r1, #33428	; 0x8294
    void *port_init_handle = NULL;
  1001b0:	f840 3d04 	str.w	r3, [r0, #-4]!
    hal_port_creat_handle(&port_init_handle,
  1001b4:	f00f fef0 	bl	10ff98 <hal_port_creat_handle>
                          RES_PAD_CONTROL_SAF_JTAG_TMS);//safety iomuxc res

    if (port_init_handle) {
  1001b8:	9801      	ldr	r0, [sp, #4]
  1001ba:	b1b0      	cbz	r0, 1001ea <uart_port_init+0x4a>
        hal_port_set_pin_mode(port_init_handle, UART_TX_PIN, UART_TX_PIN_MODE);
  1001bc:	f647 33d8 	movw	r3, #31704	; 0x7bd8
  1001c0:	2120      	movs	r1, #32
  1001c2:	f2c0 0311 	movt	r3, #17
  1001c6:	cb0c      	ldmia	r3, {r2, r3}
  1001c8:	f00f ffba 	bl	110140 <hal_port_set_pin_mode>
        hal_port_set_pin_mode(port_init_handle, UART_RX_PIN, UART_RX_PIN_MODE);
  1001cc:	f647 33d0 	movw	r3, #31696	; 0x7bd0
  1001d0:	2121      	movs	r1, #33	; 0x21
  1001d2:	f2c0 0311 	movt	r3, #17
  1001d6:	9801      	ldr	r0, [sp, #4]
  1001d8:	cb0c      	ldmia	r3, {r2, r3}
  1001da:	f00f ffb1 	bl	110140 <hal_port_set_pin_mode>
        hal_port_release_handle(port_init_handle);
  1001de:	9801      	ldr	r0, [sp, #4]
  1001e0:	f00f ff44 	bl	11006c <hal_port_release_handle>
    }
    else {
        dprintf(ALWAYS, "port get handle failed!\n");
    }
}
  1001e4:	b003      	add	sp, #12
  1001e6:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(ALWAYS, "port get handle failed!\n");
  1001ea:	f647 30e0 	movw	r0, #31712	; 0x7be0
  1001ee:	f2c0 0011 	movt	r0, #17
  1001f2:	f014 faef 	bl	1147d4 <puts>
}
  1001f6:	b003      	add	sp, #12
  1001f8:	f85d fb04 	ldr.w	r15, [r13], #4

001001fc <tcm_init>:
#include <asm.h>
/*void tcm_init(uint32_t tcmA_base,uint32_t tcmB_base,uint32_t tcmA_size,uint32_t tcmB_size) */
FUNCTION(tcm_init)
    push {r4,r5,r6,r7}
  1001fc:	e92d00f0 	push	{r4, r5, r6, r7}
    mov r6,r0
  100200:	e1a06000 	mov	r6, r0
    mov r7,r1
  100204:	e1a07001 	mov	r7, r1
    @ mrc p15, 0, r0, c9, c1, 1   // Read ATCM Region Register
    @ // r0 now contains ATCM size in bits[6:2]
    @ mrc p15, 0, r0, c9, c1, 0   // Read BTCM Region Register
    @ // r0 now contains BTCM size in bits[6:2]
    @ // Write to TCMTR.size will be ignored
    orr r0, r0, #1  // Enable ATCM
  100208:	e3800001 	orr	r0, r0, #1
    mcr p15, 0, r0, c9, c1, 1
  10020c:	ee090f31 	mcr	15, 0, r0, cr9, cr1, {1}
    orr r1, r1, #1  // Enable BTCM
  100210:	e3811001 	orr	r1, r1, #1
    mcr p15, 0, r1, c9, c1, 0
  100214:	ee091f11 	mcr	15, 0, r1, cr9, cr1, {0}

    @ r2 = tcmA_base + tcmA_size = tcmA_end
    add r2,r6,r2
  100218:	e0862002 	add	r2, r6, r2
    @ r3 = tcmB_base + tcmB_size = tcmB_end
    add r3,r7,r3
  10021c:	e0873003 	add	r3, r7, r3
    @combine to 64 bit
    mov r4,#0
  100220:	e3a04000 	mov	r4, #0
    mov r5,#0
  100224:	e3a05000 	mov	r5, #0
.Ltcm_clrA:
    cmp r6,r2
  100228:	e1560002 	cmp	r6, r2
    bhs .Ltcm_clrB
  10022c:	2a000001 	bcs	100238 <tcm_init+0x3c>
    stmia r6!, {r4-r5}
  100230:	e8a60030 	stmia	r6!, {r4, r5}
    b .Ltcm_clrA
  100234:	eafffffb 	b	100228 <tcm_init+0x2c>

.Ltcm_clrB:
    cmp r7,r3
  100238:	e1570003 	cmp	r7, r3
    bhs .Ltcm_clr_done
  10023c:	2a000001 	bcs	100248 <tcm_init+0x4c>
    stmia r7!, {r4-r5}
  100240:	e8a70030 	stmia	r7!, {r4, r5}
    b .Ltcm_clrB
  100244:	eafffffb 	b	100238 <tcm_init+0x3c>

.Ltcm_clr_done:

    pop {r4,r5,r6,r7}
  100248:	e8bd00f0 	pop	{r4, r5, r6, r7}
    bx lr
  10024c:	e12fff1e 	bx	r14

00100250 <vector_remap>:
}

static void vector_remap(addr_t vector_base)
{
    /* base address must be 4 KB aligned */
    ASSERT((vector_base & 0xFFF) == 0);
  100250:	f3c0 030b 	ubfx	r3, r0, #0, #12
{
  100254:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  100258:	46f0      	mov	r8, r14
  10025a:	b082      	sub	sp, #8
    ASSERT((vector_base & 0xFFF) == 0);
  10025c:	bbb3      	cbnz	r3, 1002cc <vector_remap+0x7c>
    dprintf(INFO, "Remapping ARM vector to 0x%lx!\n", vector_base);
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  10025e:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  100262:	f644 5250 	movw	r2, #19792	; 0x4d50
  100266:	f6cf 4341 	movt	r3, #64577	; 0xfc41
  10026a:	4604      	mov	r4, r0
  10026c:	f2c5 2245 	movt	r2, #21061	; 0x5245
    /* Enable R5 remapping to vector base. The remap config doesn't
     * take effect until REMAP module detects R5 core reset.
     */
    scr_handle_t handle;
    handle = hal_scr_create_handle(
  100270:	2014      	movs	r0, #20
  100272:	2103      	movs	r1, #3
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  100274:	601a      	str	r2, [r3, #0]
    handle = hal_scr_create_handle(
  100276:	f2c0 4000 	movt	r0, #1024	; 0x400
  10027a:	f010 fa35 	bl	1106e8 <hal_scr_create_handle>
  10027e:	4606      	mov	r6, r0
  100280:	460f      	mov	r7, r1
                 SCR_SAFETY__L31__remap_cr5_saf_ar_addr_offset_19_0);
    ASSERT(handle);
  100282:	ea56 0307 	orrs.w	r3, r6, r7
  100286:	d032      	beq.n	1002ee <vector_remap+0x9e>
    hal_scr_set(handle, vector_base >> 12);
  100288:	0b22      	lsrs	r2, r4, #12
  10028a:	f010 fa5f 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  10028e:	4630      	mov	r0, r6
  100290:	4639      	mov	r1, r7
  100292:	f010 fa2b 	bl	1106ec <hal_scr_delete_handle>
    handle = hal_scr_create_handle(
  100296:	a128      	add	r1, pc, #160	; (adr r1, 100338 <vector_remap+0xe8>)
  100298:	e9d1 0100 	ldrd	r0, r1, [r1]
  10029c:	f010 fa24 	bl	1106e8 <hal_scr_create_handle>
  1002a0:	4604      	mov	r4, r0
  1002a2:	460d      	mov	r5, r1
                 SCR_SAFETY__L31__remap_cr5_saf_ar_remap_ovrd_en);
    ASSERT(handle);
  1002a4:	ea54 0305 	orrs.w	r3, r4, r5
  1002a8:	d032      	beq.n	100310 <vector_remap+0xc0>
    hal_scr_set(handle, 1);
  1002aa:	2201      	movs	r2, #1
  1002ac:	f010 fa4e 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  1002b0:	4620      	mov	r0, r4
  1002b2:	4629      	mov	r1, r5
  1002b4:	f010 fa1a 	bl	1106ec <hal_scr_delete_handle>
    /* ROMC Stick Reg
     *
     * [0]: ROMC_STICKY_REMAP_EN. This bit is AND'ed with
     *      SCR remap_en bit, to enable remapping.
     */
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
  1002b8:	2334      	movs	r3, #52	; 0x34
  1002ba:	f2cf 0320 	movt	r3, #61472	; 0xf020
  1002be:	681a      	ldr	r2, [r3, #0]
  1002c0:	f042 0201 	orr.w	r2, r2, #1
  1002c4:	601a      	str	r2, [r3, #0]
}
  1002c6:	b002      	add	sp, #8
  1002c8:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    ASSERT((vector_base & 0xFFF) == 0);
  1002cc:	f647 4354 	movw	r3, #31828	; 0x7c54
  1002d0:	f647 4210 	movw	r2, #31760	; 0x7c10
  1002d4:	f647 4134 	movw	r1, #31796	; 0x7c34
  1002d8:	f2c0 0311 	movt	r3, #17
  1002dc:	4670      	mov	r0, r14
  1002de:	f2c0 0211 	movt	r2, #17
  1002e2:	9300      	str	r3, [sp, #0]
  1002e4:	f2c0 0111 	movt	r1, #17
  1002e8:	2371      	movs	r3, #113	; 0x71
  1002ea:	f013 fa57 	bl	11379c <_panic>
    ASSERT(handle);
  1002ee:	f647 4370 	movw	r3, #31856	; 0x7c70
  1002f2:	f647 4210 	movw	r2, #31760	; 0x7c10
  1002f6:	f647 4134 	movw	r1, #31796	; 0x7c34
  1002fa:	f2c0 0311 	movt	r3, #17
  1002fe:	4640      	mov	r0, r8
  100300:	f2c0 0211 	movt	r2, #17
  100304:	9300      	str	r3, [sp, #0]
  100306:	f2c0 0111 	movt	r1, #17
  10030a:	237a      	movs	r3, #122	; 0x7a
  10030c:	f013 fa46 	bl	11379c <_panic>
    ASSERT(handle);
  100310:	f647 4370 	movw	r3, #31856	; 0x7c70
  100314:	f647 4210 	movw	r2, #31760	; 0x7c10
  100318:	f647 4134 	movw	r1, #31796	; 0x7c34
  10031c:	f2c0 0311 	movt	r3, #17
  100320:	4640      	mov	r0, r8
  100322:	f2c0 0211 	movt	r2, #17
  100326:	9300      	str	r3, [sp, #0]
  100328:	f2c0 0111 	movt	r1, #17
  10032c:	237f      	movs	r3, #127	; 0x7f
  10032e:	f013 fa35 	bl	11379c <_panic>
  100332:	bf00      	nop
  100334:	f3af 8000 	nop.w
  100338:	04001401 	.word	0x04001401
  10033c:	00000003 	.word	0x00000003

00100340 <platform_core_reset>:
{
  100340:	b510      	push	{r4, r14}
    addr_t phy_addr = 0;
  100342:	2300      	movs	r3, #0
{
  100344:	b084      	sub	sp, #16
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  100346:	f240 4002 	movw	r0, #1026	; 0x402
    int32_t idx = 0;
  10034a:	aa04      	add	r2, sp, #16
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10034c:	a902      	add	r1, sp, #8
    int32_t idx = 0;
  10034e:	f842 3d04 	str.w	r3, [r2, #-4]!
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  100352:	f2c8 2096 	movt	r0, #33430	; 0x8296
    addr_t phy_addr = 0;
  100356:	9302      	str	r3, [sp, #8]
  100358:	4674      	mov	r4, r14
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10035a:	f00f ffeb 	bl	110334 <res_get_info_by_id>
    ASSERT(!ret);
  10035e:	b960      	cbnz	r0, 10037a <platform_core_reset+0x3a>
    rstgen_core_reset(phy_addr, idx);
  100360:	9802      	ldr	r0, [sp, #8]
    writel(readl(LOCKSTEP_SCR_ADDR) | (0x3 << LOCKSTEP_SCR_BIT),
  100362:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
  100366:	f6cf 4329 	movt	r3, #64553	; 0xfc29
  10036a:	681a      	ldr	r2, [r3, #0]
  10036c:	f042 0203 	orr.w	r2, r2, #3
  100370:	601a      	str	r2, [r3, #0]
    rstgen_core_reset(phy_addr, idx);
  100372:	9903      	ldr	r1, [sp, #12]
  100374:	f009 f854 	bl	109420 <rstgen_core_reset>
  100378:	e7fe      	b.n	100378 <platform_core_reset+0x38>
    ASSERT(!ret);
  10037a:	f647 33f8 	movw	r3, #31736	; 0x7bf8
  10037e:	f647 4210 	movw	r2, #31760	; 0x7c10
  100382:	f647 4134 	movw	r1, #31796	; 0x7c34
  100386:	f2c0 0311 	movt	r3, #17
  10038a:	4620      	mov	r0, r4
  10038c:	f2c0 0211 	movt	r2, #17
  100390:	9300      	str	r3, [sp, #0]
  100392:	f2c0 0111 	movt	r1, #17
  100396:	2359      	movs	r3, #89	; 0x59
  100398:	f013 fa00 	bl	11379c <_panic>

0010039c <platform_early_init>:

static void platform_remap(void)
{
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  10039c:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
  1003a0:	f644 5350 	movw	r3, #19792	; 0x4d50
  1003a4:	f6cf 4041 	movt	r0, #64577	; 0xfc41
  1003a8:	f2c5 2345 	movt	r3, #21061	; 0x5245
        mpu_enable(true);
    }
}

void platform_early_init(void)
{
  1003ac:	b5f0      	push	{r4, r5, r6, r7, r14}
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  1003ae:	6802      	ldr	r2, [r0, #0]
{
  1003b0:	b085      	sub	sp, #20
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  1003b2:	429a      	cmp	r2, r3
  1003b4:	d17c      	bne.n	1004b0 <platform_early_init+0x114>
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1003b6:	2400      	movs	r4, #0
    platform_remap();
    tcm_init(TCMA_BASE, TCMB_BASE, TCMA_SIZE, TCMB_SIZE);
  1003b8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  1003bc:	461a      	mov	r2, r3
  1003be:	f44f 0196 	mov.w	r1, #4915200	; 0x4b0000
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1003c2:	6004      	str	r4, [r0, #0]
    tcm_init(TCMA_BASE, TCMB_BASE, TCMA_SIZE, TCMB_SIZE);
  1003c4:	f44f 0098 	mov.w	r0, #4980736	; 0x4c0000
  1003c8:	4676      	mov	r6, r14
  1003ca:	f7ff ef18 	blx	1001fc <tcm_init>
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003ce:	f44f 6088 	mov.w	r0, #1088	; 0x440
    int32_t idx = 0;
  1003d2:	aa04      	add	r2, sp, #16
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003d4:	a902      	add	r1, sp, #8
    int32_t idx = 0;
  1003d6:	f842 4d04 	str.w	r4, [r2, #-4]!
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003da:	f2c8 2096 	movt	r0, #33430	; 0x8296
    addr_t phy_addr = 0;
  1003de:	9402      	str	r4, [sp, #8]
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003e0:	f00f ffa8 	bl	110334 <res_get_info_by_id>
    ASSERT(!ret);
  1003e4:	4604      	mov	r4, r0
  1003e6:	2800      	cmp	r0, #0
  1003e8:	d140      	bne.n	10046c <platform_early_init+0xd0>
    rstgen_module_ctl(phy_addr, idx, false);
  1003ea:	4602      	mov	r2, r0
  1003ec:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
  1003f0:	f009 f866 	bl	1094c0 <rstgen_module_ctl>
    rstgen_module_ctl(phy_addr, idx, true);
  1003f4:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
  1003f8:	2201      	movs	r2, #1
  1003fa:	f009 f861 	bl	1094c0 <rstgen_module_ctl>
    //enable gic IP
    platform_gic_reset();
    uart_port_init();
  1003fe:	f7ff fecf 	bl	1001a0 <uart_port_init>

    uart_init_early();
  100402:	f000 f8c1 	bl	100588 <uart_init_early>
    sdrpc_notify_msg(NULL, 0xff, NULL);
#ifndef WITH_APPLICATION_EARLY_APP
    sdrpc_notify_msg(NULL, COM_DC_STATUS, NULL);
#endif
#endif
    arm_gic_init_early();
  100406:	f000 fa09 	bl	10081c <arm_gic_init_early>
    timer_init_early();
  10040a:	f000 f92f 	bl	10066c <timer_init_early>
    dcf_early_init();
  10040e:	f00a f80f 	bl	10a430 <dcf_early_init>
    arm_fpu_set_enable(true);
  100412:	2001      	movs	r0, #1
  100414:	f001 f91c 	bl	101650 <arm_fpu_set_enable>
    __asm__ volatile("VMRS %0, FPSID" : "=r"(fpsid));
  100418:	eef0 3a10 	vmrs	r3, fpsid
    mpu_add_region(region++, 0x0, REMAP_SZ, MPU_REGION_NO_ACCESS);
  10041c:	2705      	movs	r7, #5
    mpu_enable(false);
  10041e:	4620      	mov	r0, r4
    __asm__ volatile("VMRS %0, FPSID" : "=r"(fpsid));
  100420:	9303      	str	r3, [sp, #12]
    mpu_add_region(region++, 0, 0x40, MPU_REGION_NORMAL_RO);
  100422:	2504      	movs	r5, #4
    mpu_enable(false);
  100424:	f001 f9f6 	bl	101814 <mpu_enable>
    mpu_add_region(region++, 0x0, REMAP_SZ, MPU_REGION_NO_ACCESS);
  100428:	4621      	mov	r1, r4
  10042a:	4620      	mov	r0, r4
  10042c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  100430:	9700      	str	r7, [sp, #0]
  100432:	2300      	movs	r3, #0
  100434:	f001 f954 	bl	1016e0 <mpu_add_region>
    mpu_add_region(region++, 0, 0x40, MPU_REGION_NORMAL_RO);
  100438:	4621      	mov	r1, r4
  10043a:	2001      	movs	r0, #1
  10043c:	2240      	movs	r2, #64	; 0x40
  10043e:	9500      	str	r5, [sp, #0]
  100440:	2300      	movs	r3, #0
  100442:	f001 f94d 	bl	1016e0 <mpu_add_region>
    mpu_add_region(region++, MEMBASE, 0x40, MPU_REGION_NORMAL_RO);
  100446:	2240      	movs	r2, #64	; 0x40
  100448:	2300      	movs	r3, #0
  10044a:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  10044e:	9500      	str	r5, [sp, #0]
  100450:	2002      	movs	r0, #2
  100452:	f001 f945 	bl	1016e0 <mpu_add_region>
    region = platform_mpu_r5_common(region);
  100456:	2003      	movs	r0, #3
  100458:	f014 fa84 	bl	114964 <platform_mpu_r5_common>
    ASSERT(region <= 16);
  10045c:	2810      	cmp	r0, #16
  10045e:	dc16      	bgt.n	10048e <platform_early_init+0xf2>
    if (region != 0) {
  100460:	b110      	cbz	r0, 100468 <platform_early_init+0xcc>
        mpu_enable(true);
  100462:	2001      	movs	r0, #1
  100464:	f001 f9d6 	bl	101814 <mpu_enable>
    dprintf(INFO, "------------------------------\n\n");
    dprintf(INFO, "Welcome to Semidrive Safety\n\n");
    dprintf(INFO, "Build on: %s - %s\n\n", __DATE__, __TIME__);
    dprintf(INFO, "------------------------------\n\n");
    dprintf(INFO, "platform_early_init done\n");
}
  100468:	b005      	add	sp, #20
  10046a:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT(!ret);
  10046c:	f647 33f8 	movw	r3, #31736	; 0x7bf8
  100470:	f647 4210 	movw	r2, #31760	; 0x7c10
  100474:	f647 4134 	movw	r1, #31796	; 0x7c34
  100478:	f2c0 0311 	movt	r3, #17
  10047c:	4630      	mov	r0, r6
  10047e:	f2c0 0211 	movt	r2, #17
  100482:	9300      	str	r3, [sp, #0]
  100484:	f2c0 0111 	movt	r1, #17
  100488:	2369      	movs	r3, #105	; 0x69
  10048a:	f013 f987 	bl	11379c <_panic>
    ASSERT(region <= 16);
  10048e:	f647 4300 	movw	r3, #31744	; 0x7c00
  100492:	f647 4210 	movw	r2, #31760	; 0x7c10
  100496:	f647 4134 	movw	r1, #31796	; 0x7c34
  10049a:	f2c0 0311 	movt	r3, #17
  10049e:	4630      	mov	r0, r6
  1004a0:	f2c0 0211 	movt	r2, #17
  1004a4:	9300      	str	r3, [sp, #0]
  1004a6:	f2c0 0111 	movt	r1, #17
  1004aa:	23cf      	movs	r3, #207	; 0xcf
  1004ac:	f013 f976 	bl	11379c <_panic>
        vector_remap(MEMBASE);
  1004b0:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  1004b4:	f7ff fecc 	bl	100250 <vector_remap>
        platform_core_reset();
  1004b8:	f7ff ff42 	bl	100340 <platform_core_reset>

001004bc <platform_init>:
{
#if SUPPORT_BOARDINFO
    init_hwid();
#endif

    uart_init();
  1004bc:	f000 b84a 	b.w	100554 <uart_init>

001004c0 <_dputc>:
#ifdef SUPPORT_VIRT_UART
#include <dev/vuart.h>
#endif

void _dputc(char c)
{
  1004c0:	b538      	push	{r3, r4, r5, r14}
  1004c2:	4604      	mov	r4, r0
    int port = uart_get_current_port();
  1004c4:	f000 f8b4 	bl	100630 <uart_get_current_port>
        vuart_putc(c);
    }

#endif

    if (c == '\n') {
  1004c8:	2c0a      	cmp	r4, #10
    int port = uart_get_current_port();
  1004ca:	4605      	mov	r5, r0
    if (c == '\n') {
  1004cc:	d005      	beq.n	1004da <_dputc+0x1a>
        uart_putc(port, '\r');
    }

    uart_putc(port, c);
  1004ce:	4621      	mov	r1, r4
  1004d0:	4628      	mov	r0, r5
}
  1004d2:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  1004d6:	f000 b883 	b.w	1005e0 <uart_putc>
        uart_putc(port, '\r');
  1004da:	210d      	movs	r1, #13
  1004dc:	f000 f880 	bl	1005e0 <uart_putc>
    uart_putc(port, c);
  1004e0:	4621      	mov	r1, r4
  1004e2:	4628      	mov	r0, r5
}
  1004e4:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  1004e8:	f000 b87a 	b.w	1005e0 <uart_putc>

001004ec <dgetc>:

int dgetc(char *c, bool wait)
{
  1004ec:	b538      	push	{r3, r4, r5, r14}
  1004ee:	460c      	mov	r4, r1
  1004f0:	4605      	mov	r5, r0
    int _c;
    int port = uart_get_current_port();
  1004f2:	f000 f89d 	bl	100630 <uart_get_current_port>
        return -1;
    }

#else

    if ((_c = uart_getc(port, wait)) < 0) {
  1004f6:	4621      	mov	r1, r4
  1004f8:	f000 f87c 	bl	1005f4 <uart_getc>
  1004fc:	2800      	cmp	r0, #0
        return -1;
  1004fe:	bfb2      	itee	lt
  100500:	f04f 30ff 	movlt.w	r0, #4294967295	; 0xffffffff
    }

#endif
    *c = _c;
  100504:	7028      	strbge	r0, [r5, #0]
    return 0;
  100506:	2000      	movge	r0, #0
}
  100508:	bd38      	pop	{r3, r4, r5, r15}
  10050a:	bf00      	nop

0010050c <platform_halt>:
    __asm__ volatile("cpsie i");
}

static inline void arch_disable_ints(void)
{
    __asm__ volatile("cpsid i");
  10050c:	b672      	cpsid	i
    CF;
  10050e:	e7fe      	b.n	10050e <platform_halt+0x2>

00100510 <platform_dputc>:
    PANIC_UNIMPLEMENTED;
}

void platform_dputc(char c)
{
    _dputc(c);
  100510:	f7ff bfd6 	b.w	1004c0 <_dputc>

00100514 <platform_dgetc>:
}

int platform_dgetc(char *c, bool wait)
{
    return dgetc(c, wait);
  100514:	f7ff bfea 	b.w	1004ec <dgetc>

00100518 <save_char>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
static int save_char(uint8_t data)
{
  100518:	b538      	push	{r3, r4, r5, r14}
  10051a:	4605      	mov	r5, r0
#if CONSOLE_HAS_INPUT_BUFFER
    cbuf_write_char(&console_input_cbuf, c, false);
#else

    if (cbuf_space_avail(&uart_rx_buf) == 0) {  //uart_rx_buf no space
  10051c:	f64c 3084 	movw	r0, #52100	; 0xcb84
  100520:	f2c0 0012 	movt	r0, #18
  100524:	f016 f9c2 	bl	1168ac <cbuf_space_avail>
  100528:	b148      	cbz	r0, 10053e <save_char+0x26>
        hal_uart_int_src_disable(safety_log_handle,
                                 UART_HAL_RX_CHAR_INT_SRC); //disable the receive data interrupt
        return 0;
    }

    cbuf_write_char(&uart_rx_buf, data, false);
  10052a:	f64c 3084 	movw	r0, #52100	; 0xcb84
  10052e:	4629      	mov	r1, r5
  100530:	2200      	movs	r2, #0
  100532:	f2c0 0012 	movt	r0, #18
  100536:	f016 f9cb 	bl	1168d0 <cbuf_write_char>
    //dprintf(PLATFORM_UART_DEBUG_LEVEL, "%c", data);
#endif
    return 1;
  10053a:	2001      	movs	r0, #1
}
  10053c:	bd38      	pop	{r3, r4, r5, r15}
        hal_uart_int_src_disable(safety_log_handle,
  10053e:	f64c 3380 	movw	r3, #52096	; 0xcb80
  100542:	4604      	mov	r4, r0
  100544:	4601      	mov	r1, r0
  100546:	f2c0 0312 	movt	r3, #18
  10054a:	6818      	ldr	r0, [r3, #0]
  10054c:	f010 fb44 	bl	110bd8 <hal_uart_int_src_disable>
  100550:	4620      	mov	r0, r4
}
  100552:	bd38      	pop	{r3, r4, r5, r15}

00100554 <uart_init>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init(void)
{
  100554:	b510      	push	{r4, r14}

    if (safety_log_handle != NULL) {
  100556:	f64c 3480 	movw	r4, #52096	; 0xcb80
  10055a:	f2c0 0412 	movt	r4, #18
  10055e:	6823      	ldr	r3, [r4, #0]
  100560:	b183      	cbz	r3, 100584 <uart_init+0x30>
        cbuf_initialize(&uart_rx_buf,
  100562:	f64c 3084 	movw	r0, #52100	; 0xcb84
  100566:	2110      	movs	r1, #16
  100568:	f2c0 0012 	movt	r0, #18
  10056c:	f016 f968 	bl	116840 <cbuf_initialize>
                        RXBUF_SIZE);   // create circular buffer to hold received data

        hal_uart_int_cbk_register(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC,
  100570:	f240 5219 	movw	r2, #1305	; 0x519
  100574:	6820      	ldr	r0, [r4, #0]
  100576:	f2c0 0210 	movt	r2, #16
  10057a:	2100      	movs	r1, #0
                                  save_char);
    }

    dprintf(PLATFORM_UART_DEBUG_LEVEL, "Platform UART inited!\r\n");

}
  10057c:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        hal_uart_int_cbk_register(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC,
  100580:	f010 bb0e 	b.w	110ba0 <hal_uart_int_cbk_register>
}
  100584:	bd10      	pop	{r4, r15}
  100586:	bf00      	nop

00100588 <uart_init_early>:
 ** \param [in]
 ** \param [out]
 *****************************************************************************/

void uart_init_early(void)
{
  100588:	b570      	push	{r4, r5, r6, r14}
    hal_uart_cfg_t  hal_cfg;
    uart_instance_t *instance;

    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));

    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  10058a:	f64c 3480 	movw	r4, #52096	; 0xcb80
{
  10058e:	b08a      	sub	sp, #40	; 0x28
    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));
  100590:	2224      	movs	r2, #36	; 0x24
  100592:	2100      	movs	r1, #0
    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  100594:	f2c0 0412 	movt	r4, #18
    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));
  100598:	a801      	add	r0, sp, #4
  10059a:	f013 ea08 	blx	1139ac <memset>
    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  10059e:	f243 0111 	movw	r1, #12305	; 0x3011
  1005a2:	4620      	mov	r0, r4
  1005a4:	f2c4 0142 	movt	r1, #16450	; 0x4042
  1005a8:	f010 fa46 	bl	110a38 <hal_uart_creat_handle>

    if (safety_log_handle != NULL) {
  1005ac:	6820      	ldr	r0, [r4, #0]
  1005ae:	b1a8      	cbz	r0, 1005dc <uart_init_early+0x54>
        instance = (uart_instance_t *)safety_log_handle;
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005b0:	f44f 4234 	mov.w	r2, #46080	; 0xb400
        hal_cfg.port_cfg.baud = UART_BAUD;
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  1005b4:	2300      	movs	r3, #0
        hal_cfg.port_cfg.baud = UART_BAUD;
  1005b6:	f44f 36e1 	mov.w	r6, #115200	; 0x1c200
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005ba:	f2c0 42c4 	movt	r2, #1220	; 0x4c4
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
  1005be:	2503      	movs	r5, #3
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  1005c0:	2402      	movs	r4, #2
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005c2:	9201      	str	r2, [sp, #4]
        hal_cfg.fifo_cfg.fifo_enable = true;
  1005c4:	2201      	movs	r2, #1
        hal_cfg.port_cfg.baud = UART_BAUD;
  1005c6:	9602      	str	r6, [sp, #8]
        hal_cfg.nine_bits_cfg.nine_bits_enable = false;
#endif
#ifdef UART_DRV_SUPPORT_DMA
        hal_cfg.dma_cfg.dma_enable = false;
#endif
        hal_uart_init(safety_log_handle, &hal_cfg);
  1005c8:	a901      	add	r1, sp, #4
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  1005ca:	e9cd 5303 	strd	r5, r3, [r13, #12]
        hal_cfg.fifo_cfg.tx_trigger = UART_HAL_TX_FIFO_EMPTY;
  1005ce:	e9cd 3308 	strd	r3, r3, [r13, #32]
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  1005d2:	9405      	str	r4, [sp, #20]
        hal_cfg.fifo_cfg.fifo_enable = true;
  1005d4:	f88d 201c 	strb.w	r2, [r13, #28]
        hal_uart_init(safety_log_handle, &hal_cfg);
  1005d8:	f010 fab8 	bl	110b4c <hal_uart_init>
        uart_platform_cfg_printf(instance, &hal_cfg);
    }

}
  1005dc:	b00a      	add	sp, #40	; 0x28
  1005de:	bd70      	pop	{r4, r5, r6, r15}

001005e0 <uart_putc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_putc(int port, char data)
{
  1005e0:	b508      	push	{r3, r14}
    hal_uart_putc(safety_log_handle, data);
  1005e2:	f64c 3380 	movw	r3, #52096	; 0xcb80
  1005e6:	f2c0 0312 	movt	r3, #18
  1005ea:	6818      	ldr	r0, [r3, #0]
  1005ec:	f010 fad0 	bl	110b90 <hal_uart_putc>
    return 1;
}
  1005f0:	2001      	movs	r0, #1
  1005f2:	bd08      	pop	{r3, r15}

001005f4 <uart_getc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_getc(int port, bool wait)
{
  1005f4:	b510      	push	{r4, r14}
    cbuf_t *rxbuf = &uart_rx_buf;
    char c;

    if (!safety_log_handle)
  1005f6:	f64c 3480 	movw	r4, #52096	; 0xcb80
{
  1005fa:	b082      	sub	sp, #8
    if (!safety_log_handle)
  1005fc:	f2c0 0412 	movt	r4, #18
  100600:	6823      	ldr	r3, [r4, #0]
  100602:	b193      	cbz	r3, 10062a <uart_getc+0x36>
        return -1;

    if (cbuf_read_char(rxbuf, &c, wait) == 1) {
  100604:	f64c 3084 	movw	r0, #52100	; 0xcb84
  100608:	460a      	mov	r2, r1
  10060a:	f2c0 0012 	movt	r0, #18
  10060e:	f10d 0107 	add.w	r1, r13, #7
  100612:	f016 f999 	bl	116948 <cbuf_read_char>
  100616:	2801      	cmp	r0, #1
  100618:	d107      	bne.n	10062a <uart_getc+0x36>
        hal_uart_int_src_enable(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC);
  10061a:	6820      	ldr	r0, [r4, #0]
  10061c:	2100      	movs	r1, #0
  10061e:	f010 fad7 	bl	110bd0 <hal_uart_int_src_enable>
        return c;
  100622:	f89d 0007 	ldrb.w	r0, [r13, #7]
    }

    return -1;
}
  100626:	b002      	add	sp, #8
  100628:	bd10      	pop	{r4, r15}
        return -1;
  10062a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10062e:	e7fa      	b.n	100626 <uart_getc+0x32>

00100630 <uart_get_current_port>:
}

int uart_get_current_port(void)
{
    return 0;
}
  100630:	2000      	movs	r0, #0
  100632:	4770      	bx	r14

00100634 <current_time_hires>:
    return hal_timer_glb_cntr_get(kernel_tick);
}

lk_bigtime_t current_time_hires(void)
{
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  100634:	f64c 33a0 	movw	r3, #52128	; 0xcba0
  100638:	f2c0 0312 	movt	r3, #18
{
  10063c:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  10063e:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(kernel_tick);
  100640:	4620      	mov	r0, r4
  100642:	f010 f9c9 	bl	1109d8 <hal_timer_glb_cntr_get>
    lk_bigtime_t us = timer_current_stamp() / instance->cnt_per_us;
  100646:	2300      	movs	r3, #0
  100648:	6922      	ldr	r2, [r4, #16]
  10064a:	f017 f9ef 	bl	117a2c <__aeabi_uldivmod>
    // dprintf(TIMER_DEBUG_LEVEL, "current_time_hires:%d", (uint32_t)us);
    return (lk_bigtime_t)us;
}
  10064e:	bd10      	pop	{r4, r15}

00100650 <current_time>:

lk_time_t current_time(void)
{
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  100650:	f64c 33a0 	movw	r3, #52128	; 0xcba0
  100654:	f2c0 0312 	movt	r3, #18
{
  100658:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  10065a:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(kernel_tick);
  10065c:	4620      	mov	r0, r4
  10065e:	f010 f9bb 	bl	1109d8 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
  100662:	2300      	movs	r3, #0
  100664:	68e2      	ldr	r2, [r4, #12]
  100666:	f017 f9e1 	bl	117a2c <__aeabi_uldivmod>
    // dprintf(TIMER_DEBUG_LEVEL, "current_time:%d", (uint32_t)ms);
    return (lk_time_t)ms;
}
  10066a:	bd10      	pop	{r4, r15}

0010066c <timer_init_early>:

void timer_init_early(void)
{
  10066c:	b5f0      	push	{r4, r5, r6, r7, r14}
    hal_timer_glb_cfg_t glb_cfg;
    hal_timer_ovf_cfg_t ovf_cfg;
    timer_instance_t *instance;

    hal_timer_creat_handle(&kernel_tick, RES_KERNEL_TIMER);
  10066e:	f64c 34a0 	movw	r4, #52128	; 0xcba0
  100672:	f242 0119 	movw	r1, #8217	; 0x2019
  100676:	f2c0 0412 	movt	r4, #18
  10067a:	4620      	mov	r0, r4
{
  10067c:	b089      	sub	sp, #36	; 0x24
    hal_timer_creat_handle(&kernel_tick, RES_KERNEL_TIMER);
  10067e:	f2c4 013e 	movt	r1, #16446	; 0x403e
  100682:	f010 f88b 	bl	11079c <hal_timer_creat_handle>

    if (kernel_tick != NULL) {
  100686:	6820      	ldr	r0, [r4, #0]
  100688:	b1f8      	cbz	r0, 1006ca <timer_init_early+0x5e>
        instance = (timer_instance_t *)kernel_tick;
        glb_cfg.cascade = true;
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
        glb_cfg.clk_frq = TIMER_FREQ;
  10068a:	f44f 5358 	mov.w	r3, #13824	; 0x3600
        glb_cfg.cascade = true;
  10068e:	2501      	movs	r5, #1
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  100690:	2202      	movs	r2, #2
        glb_cfg.clk_frq = TIMER_FREQ;
  100692:	f2c0 136e 	movt	r3, #366	; 0x16e
        glb_cfg.clk_div = 1;
        hal_timer_global_init(kernel_tick, &glb_cfg);
        ovf_cfg.cnt_val = 0;
        ovf_cfg.ovf_val = 0xFFFFFFFF;
        ovf_cfg.periodic = true;
  100696:	ae08      	add	r6, sp, #32
        glb_cfg.clk_frq = TIMER_FREQ;
  100698:	9305      	str	r3, [sp, #20]
        hal_timer_global_init(kernel_tick, &glb_cfg);
  10069a:	a904      	add	r1, sp, #16
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  10069c:	9204      	str	r2, [sp, #16]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  10069e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        glb_cfg.cascade = true;
  1006a2:	f88d 501c 	strb.w	r5, [r13, #28]
        glb_cfg.clk_div = 1;
  1006a6:	9506      	str	r5, [sp, #24]
        hal_timer_global_init(kernel_tick, &glb_cfg);
  1006a8:	f010 f906 	bl	1108b8 <hal_timer_global_init>
        ovf_cfg.periodic = true;
  1006ac:	f806 5d1c 	strb.w	r5, [r6, #-28]!
        ovf_cfg.cnt_val = 0;
  1006b0:	2300      	movs	r3, #0
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G0, &ovf_cfg);
  1006b2:	4632      	mov	r2, r6
  1006b4:	4619      	mov	r1, r3
  1006b6:	6820      	ldr	r0, [r4, #0]
        ovf_cfg.cnt_val = 0;
  1006b8:	9302      	str	r3, [sp, #8]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  1006ba:	9703      	str	r7, [sp, #12]
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G0, &ovf_cfg);
  1006bc:	f010 f920 	bl	110900 <hal_timer_ovf_init>
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G1, &ovf_cfg);
  1006c0:	4632      	mov	r2, r6
  1006c2:	4629      	mov	r1, r5
  1006c4:	6820      	ldr	r0, [r4, #0]
  1006c6:	f010 f91b 	bl	110900 <hal_timer_ovf_init>
        dprintf(TIMER_DEBUG_LEVEL,
                "Platform timer init finished, cnt per ms:%d, cnt per us:%d\n",
                instance->cnt_per_ms,
                instance->cnt_per_us);
    }
}
  1006ca:	b009      	add	sp, #36	; 0x24
  1006cc:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1006ce:	bf00      	nop

001006d0 <vPortTickTimerEnable>:
/******************************* vPortTickTimerEnable implementation *******************************/

void vPortTickTimerEnable( void (*Tick_Handler)( void ) )
{
  1006d0:	b570      	push	{r4, r5, r6, r14}
    //timer_instance_t *instance;

    ovf_cfg.cnt_val = 0;
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
    ovf_cfg.periodic = true;
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1006d2:	f64c 34a0 	movw	r4, #52128	; 0xcba0
{
  1006d6:	b084      	sub	sp, #16
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1006d8:	f2c0 0412 	movt	r4, #18
    ovf_cfg.periodic = true;
  1006dc:	2601      	movs	r6, #1
  1006de:	aa04      	add	r2, sp, #16
    ovf_cfg.cnt_val = 0;
  1006e0:	2100      	movs	r1, #0
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
  1006e2:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    ovf_cfg.periodic = true;
  1006e6:	f802 6d0c 	strb.w	r6, [r2, #-12]!
{
  1006ea:	4605      	mov	r5, r0
    ovf_cfg.cnt_val = 0;
  1006ec:	9102      	str	r1, [sp, #8]
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1006ee:	2102      	movs	r1, #2
  1006f0:	6820      	ldr	r0, [r4, #0]
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
  1006f2:	9303      	str	r3, [sp, #12]
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1006f4:	f010 f904 	bl	110900 <hal_timer_ovf_init>

    hal_timer_int_cbk_register(kernel_tick, HAL_TIMER_CNT_LA_OVF_INT_SRC, (hal_timer_int_cbk)Tick_Handler);
  1006f8:	462a      	mov	r2, r5
  1006fa:	210a      	movs	r1, #10
  1006fc:	6820      	ldr	r0, [r4, #0]
  1006fe:	f010 f91f 	bl	110940 <hal_timer_int_cbk_register>
    hal_timer_int_src_enable(kernel_tick, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  100702:	6820      	ldr	r0, [r4, #0]
  100704:	210a      	movs	r1, #10
  100706:	f010 f90d 	bl	110924 <hal_timer_int_src_enable>
}
  10070a:	b004      	add	sp, #16
  10070c:	bd70      	pop	{r4, r5, r6, r15}
  10070e:	bf00      	nop

00100710 <register_int_handler>:

#endif


void register_int_handler(unsigned int vector, int_handler handler, void *arg)
{
  100710:	b570      	push	{r4, r5, r6, r14}
    void* gic_handle = NULL;
  100712:	2500      	movs	r5, #0
{
  100714:	b084      	sub	sp, #16
  100716:	460e      	mov	r6, r1
    void* gic_handle = NULL;
  100718:	ab04      	add	r3, sp, #16
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  10071a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
{
  10071e:	4604      	mov	r4, r0
    void* gic_handle = NULL;
  100720:	f843 5d04 	str.w	r5, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100724:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  100728:	4618      	mov	r0, r3
{
  10072a:	4615      	mov	r5, r2
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  10072c:	f00c fa3e 	bl	10cbac <hal_arm_gic_create_handle>
  100730:	b1b8      	cbz	r0, 100762 <register_int_handler+0x52>
    {
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else if(vector > MAX_INT)
  100732:	f5b4 7f89 	cmp.w	r4, #274	; 0x112
  100736:	d80b      	bhi.n	100750 <register_int_handler+0x40>
        vSetInterruptControlBlock(ICB,handler,arg,vector);
        spin_unlock_irqrestore(&ICB_lock,states);

        hal_arm_gic_register_interrupt(gic_handle, ICB->usMeta.ulVector, ICB->usMeta.ucPriority, uInterruptTopHalf, ICB);
#else
        hal_arm_gic_register_interrupt(gic_handle, vector, DEFAULT_INTERRUPT_PRIORITY, handler, arg);
  100738:	4633      	mov	r3, r6
  10073a:	4621      	mov	r1, r4
  10073c:	9803      	ldr	r0, [sp, #12]
  10073e:	221e      	movs	r2, #30
  100740:	9500      	str	r5, [sp, #0]
  100742:	f00c fa67 	bl	10cc14 <hal_arm_gic_register_interrupt>
#endif
        hal_arm_gic_release_handle(gic_handle);
  100746:	9803      	ldr	r0, [sp, #12]
  100748:	f00c fa32 	bl	10cbb0 <hal_arm_gic_release_handle>
    }

    return;
}
  10074c:	b004      	add	sp, #16
  10074e:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  100750:	f647 40a0 	movw	r0, #31904	; 0x7ca0
  100754:	4621      	mov	r1, r4
  100756:	f2c0 0011 	movt	r0, #17
  10075a:	f014 f853 	bl	114804 <printf>
}
  10075e:	b004      	add	sp, #16
  100760:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  100762:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  100766:	f647 4078 	movw	r0, #31864	; 0x7c78
  10076a:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  10076e:	f2c0 0011 	movt	r0, #17
  100772:	f014 f847 	bl	114804 <printf>
}
  100776:	b004      	add	sp, #16
  100778:	bd70      	pop	{r4, r5, r6, r15}
  10077a:	bf00      	nop

0010077c <mask_interrupt>:

status_t mask_interrupt(unsigned int vector)
{
  10077c:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
  10077e:	2200      	movs	r2, #0
{
  100780:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100782:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  100786:	ab02      	add	r3, sp, #8
{
  100788:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  10078a:	f2cc 010a 	movt	r1, #49162	; 0xc00a
    void* gic_handle = NULL;
  10078e:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100792:	4618      	mov	r0, r3
  100794:	f00c fa0a 	bl	10cbac <hal_arm_gic_create_handle>
  100798:	b150      	cbz	r0, 1007b0 <mask_interrupt+0x34>
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_disable_interrupt(gic_handle, vector);
  10079a:	9801      	ldr	r0, [sp, #4]
  10079c:	4621      	mov	r1, r4
  10079e:	f00c fa31 	bl	10cc04 <hal_arm_gic_disable_interrupt>
  1007a2:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
  1007a4:	9801      	ldr	r0, [sp, #4]
  1007a6:	f00c fa03 	bl	10cbb0 <hal_arm_gic_release_handle>
    }

    return ret;
}
  1007aa:	4620      	mov	r0, r4
  1007ac:	b002      	add	sp, #8
  1007ae:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  1007b0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  1007b4:	f647 4078 	movw	r0, #31864	; 0x7c78
  1007b8:	f2cc 010a 	movt	r1, #49162	; 0xc00a
        ret = -1;
  1007bc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_ERROR_LEVEL,
  1007c0:	f2c0 0011 	movt	r0, #17
  1007c4:	f014 f81e 	bl	114804 <printf>
  1007c8:	e7ef      	b.n	1007aa <mask_interrupt+0x2e>
  1007ca:	bf00      	nop

001007cc <unmask_interrupt>:
status_t unmask_interrupt(unsigned int vector)
{
  1007cc:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
  1007ce:	2200      	movs	r2, #0
{
  1007d0:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007d2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  1007d6:	ab02      	add	r3, sp, #8
{
  1007d8:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007da:	f2cc 010a 	movt	r1, #49162	; 0xc00a
    void* gic_handle = NULL;
  1007de:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007e2:	4618      	mov	r0, r3
  1007e4:	f00c f9e2 	bl	10cbac <hal_arm_gic_create_handle>
  1007e8:	b150      	cbz	r0, 100800 <unmask_interrupt+0x34>
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_enable_interrupt(gic_handle, vector);
  1007ea:	9801      	ldr	r0, [sp, #4]
  1007ec:	4621      	mov	r1, r4
  1007ee:	f00c fa01 	bl	10cbf4 <hal_arm_gic_enable_interrupt>
  1007f2:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
  1007f4:	9801      	ldr	r0, [sp, #4]
  1007f6:	f00c f9db 	bl	10cbb0 <hal_arm_gic_release_handle>
    }

    return ret;
}
  1007fa:	4620      	mov	r0, r4
  1007fc:	b002      	add	sp, #8
  1007fe:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  100800:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  100804:	f647 4078 	movw	r0, #31864	; 0x7c78
  100808:	f2cc 010a 	movt	r1, #49162	; 0xc00a
        ret = -1;
  10080c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_ERROR_LEVEL,
  100810:	f2c0 0011 	movt	r0, #17
  100814:	f013 fff6 	bl	114804 <printf>
  100818:	e7ef      	b.n	1007fa <unmask_interrupt+0x2e>
  10081a:	bf00      	nop

0010081c <arm_gic_init_early>:

void arm_gic_init_early(void)
{
  10081c:	b500      	push	{r14}
    void* gic_handle = NULL;
  10081e:	2300      	movs	r3, #0
{
  100820:	b083      	sub	sp, #12

    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100822:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  100826:	a802      	add	r0, sp, #8
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100828:	f2cc 010a 	movt	r1, #49162	; 0xc00a
    void* gic_handle = NULL;
  10082c:	f840 3d04 	str.w	r3, [r0, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100830:	f00c f9bc 	bl	10cbac <hal_arm_gic_create_handle>
  100834:	b140      	cbz	r0, 100848 <arm_gic_init_early+0x2c>
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_init(gic_handle);
  100836:	9801      	ldr	r0, [sp, #4]
  100838:	f00c f9bc 	bl	10cbb4 <hal_arm_gic_init>
        hal_arm_gic_release_handle(gic_handle);
  10083c:	9801      	ldr	r0, [sp, #4]
  10083e:	f00c f9b7 	bl	10cbb0 <hal_arm_gic_release_handle>
    }

    return;
}
  100842:	b003      	add	sp, #12
  100844:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(INTERRUPT_ERROR_LEVEL,
  100848:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  10084c:	f647 4078 	movw	r0, #31864	; 0x7c78
  100850:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  100854:	f2c0 0011 	movt	r0, #17
  100858:	f013 ffd4 	bl	114804 <printf>
}
  10085c:	b003      	add	sp, #12
  10085e:	f85d fb04 	ldr.w	r15, [r13], #4
  100862:	bf00      	nop

00100864 <vApplicationIRQHandler>:

/* FreeRTOS IRQ implementation. */
void vApplicationIRQHandler(uint32_t ulICCIAR)
{
    arm_gic_platform_irq_spotless(ulICCIAR);
  100864:	f007 babc 	b.w	107de0 <arm_gic_platform_irq_spotless>

00100868 <is_str_resume>:
  100868:	2000      	movs	r0, #0
  10086a:	4770      	bx	r14

0010086c <arm_context_switch>:
     */
/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */
FUNCTION(arm_context_switch)
    /* save non callee trashed supervisor registers */
    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */
    push    { r4-r11, lr }
  10086c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    /* save old sp */
    str     sp, [r0]
  100870:	e580d000 	str	r13, [r0]

    /* clear any exlusive locks that the old thread holds */
#if ARM_ARCH_LEVEL >= 7
    /* can clear it directly */
    clrex
  100874:	f57ff01f 	clrex
    ldr     r0, =strex_spot
    strex   r3, r2, [r0]
#endif

    /* load new regs */
    mov     sp, r1
  100878:	e1a0d001 	mov	r13, r1
    pop     { r4-r11, lr }
  10087c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
    bx      lr
  100880:	e12fff1e 	bx	r14

00100884 <arm_save_mode_regs>:
#endif

.text

FUNCTION(arm_save_mode_regs)
    mrs     r1, cpsr
  100884:	e10f1000 	mrs	r1, CPSR

    stmia   r0, { r13, r14 }^ /* usr */
  100888:	e8c06000 	stmia	r0, {r13, r14}^
    add     r0, #8
  10088c:	e2800008 	add	r0, r0, #8

    cps     #0x11   /* fiq */
  100890:	f1020011 	cps	#17
    str     r13, [r0], #4
  100894:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  100898:	e480e004 	str	r14, [r0], #4

    cps     #0x12   /* irq */
  10089c:	f1020012 	cps	#18
    str     r13, [r0], #4
  1008a0:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008a4:	e480e004 	str	r14, [r0], #4

    cps     #0x13   /* svc */
  1008a8:	f1020013 	cps	#19
    str     r13, [r0], #4
  1008ac:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008b0:	e480e004 	str	r14, [r0], #4

    cps     #0x17   /* abt */
  1008b4:	f1020017 	cps	#23
    str     r13, [r0], #4
  1008b8:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008bc:	e480e004 	str	r14, [r0], #4

    cps     #0x1b   /* und */
  1008c0:	f102001b 	cps	#27
    str     r13, [r0], #4
  1008c4:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008c8:	e480e004 	str	r14, [r0], #4

    cps     #0x1f   /* sys */
  1008cc:	f102001f 	cps	#31
    str     r13, [r0], #4
  1008d0:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008d4:	e480e004 	str	r14, [r0], #4

    msr     cpsr_c, r1
  1008d8:	e121f001 	msr	CPSR_c, r1

    bx      lr
  1008dc:	e12fff1e 	bx	r14

001008e0 <arm_chain_load>:

/* void arm_chain_load(paddr_t entry, ulong arg0, ulong arg1, ulong arg2, ulong arg3) __NO_RETURN; */
/* shut down the system, branching into the secondary system */
FUNCTION(arm_chain_load)
    /* shuffle the args around */
    mov     r4, r0      /* r4 = entry point */
  1008e0:	e1a04000 	mov	r4, r0
    mov     r0, r1
  1008e4:	e1a00001 	mov	r0, r1
    mov     r1, r2
  1008e8:	e1a01002 	mov	r1, r2
    mov     r2, r3
  1008ec:	e1a02003 	mov	r2, r3
    ldr     r3, [sp]
  1008f0:	e59d3000 	ldr	r3, [r13]
    isb

#endif // WITH_KERNEL_VM

    /* call the entry point */
    bx      r4
  1008f4:	e12fff14 	bx	r4

001008f8 <arch_disable_cache>:

#elif ARM_ISA_ARMV7

/* void arch_disable_cache(uint flags) */
FUNCTION(arch_disable_cache)
    stmfd   sp!, {r4-r11, lr}
  1008f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    mov     r7, r0                      // save flags
  1008fc:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  100900:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  100904:	f10c01c0 	cpsid	aif

.Ldcache_disable:
    tst     r7, #DCACHE
  100908:	e3170002 	tst	r7, #2
    beq     .Licache_disable
  10090c:	0a000007 	beq	100930 <arch_disable_cache+0x38>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100910:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already disabled?
  100914:	e3100004 	tst	r0, #4
    beq     .Ldcache_already_disabled
  100918:	0a000003 	beq	10092c <arch_disable_cache+0x34>

    bic     r0, #(1<<2)
  10091c:	e3c00004 	bic	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // disable dcache
  100920:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    // flush and invalidate the dcache
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
    bl      flush_invalidate_cache_v7
  100924:	eb000021 	bl	1009b0 <flush_invalidate_cache_v7>

    b       .Ldcache_disable_L2
  100928:	ea000000 	b	100930 <arch_disable_cache+0x38>

.Ldcache_already_disabled:
    // make sure all of the caches are invalidated
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  10092c:	eb000044 	bl	100a44 <invalidate_cache_v7>
    bic     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // disable L2 dcache
#endif

.Licache_disable:
    tst     r7, #ICACHE
  100930:	e3170001 	tst	r7, #1
    beq     .Ldone_disable
  100934:	0a000002 	beq	100944 <arch_disable_cache+0x4c>

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100938:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, #(1<<12)
  10093c:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // disable icache
  100940:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_disable:
    // make sure the icache is always invalidated
    mov     r0, #0
  100944:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  100948:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    msr     cpsr, r8
  10094c:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r11, pc}
  100950:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

00100954 <arch_enable_cache>:

/* void arch_enable_cache(uint flags) */
FUNCTION(arch_enable_cache)
    stmfd   sp!, {r4-r12, lr}
  100954:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}

    mov     r7, r0                      // save flags
  100958:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  10095c:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  100960:	f10c01c0 	cpsid	aif

.Ldcache_enable:
    tst     r7, #DCACHE
  100964:	e3170002 	tst	r7, #2
    beq     .Licache_enable
  100968:	0a000006 	beq	100988 <arch_enable_cache+0x34>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  10096c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already enabled?
  100970:	e3100004 	tst	r0, #4
    bne     .Licache_enable
  100974:	1a000003 	bne	100988 <arch_enable_cache+0x34>

    // invalidate L1 and L2
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  100978:	eb000031 	bl	100a44 <invalidate_cache_v7>
    mrc     p15, 0, r0, c1, c0, 1       // aux cr1
    orr     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // enable L2 dcache
#endif

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  10097c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<2)
  100980:	e3800004 	orr	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // enable dcache
  100984:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Licache_enable:
    tst     r7, #ICACHE
  100988:	e3170001 	tst	r7, #1
    beq     .Ldone_enable
  10098c:	0a000004 	beq	1009a4 <arch_enable_cache+0x50>

    mov     r0, #0
  100990:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  100994:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100998:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<12)
  10099c:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // enable icache
  1009a0:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_enable:
    isb
  1009a4:	f57ff06f 	isb	sy
    msr     cpsr, r8
  1009a8:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r12, pc}
  1009ac:	e8bd9ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r15}

001009b0 <flush_invalidate_cache_v7>:

// flush & invalidate cache routine, trashes r0-r6, r9-r11
flush_invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  1009b0:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  1009b4:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  1009b8:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  1009bc:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished
  1009c0:	0a00001a 	beq	100a30 <flush_invalidate_cache_v7+0x80>
    MOV     R10, #0
  1009c4:	e3a0a000 	mov	r10, #0
.Loop1:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  1009c8:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  1009cc:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  1009d0:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  1009d4:	e3510002 	cmp	r1, #2
    BLT     .Lskip                      // no cache or only instruction cache at this level
  1009d8:	ba000011 	blt	100a24 <flush_invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  1009dc:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  1009e0:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  1009e4:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  1009e8:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  1009ec:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  1009f0:	e59f4160 	ldr	r4, [pc, #352]	; 100b58 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  1009f4:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  1009f8:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  1009fc:	e59f6158 	ldr	r6, [pc, #344]	; 100b5c <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  100a00:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  100a04:	e1a09004 	mov	r9, r4
.Loop3:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  100a08:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  100a0c:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c14, 2     // clean & invalidate by set/way
  100a10:	ee07bf5e 	mcr	15, 0, r11, cr7, cr14, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  100a14:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3
  100a18:	aafffffa 	bge	100a08 <flush_invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  100a1c:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2
  100a20:	aafffff7 	bge	100a04 <flush_invalidate_cache_v7+0x54>
.Lskip:
    ADD     R10, R10, #2                    // increment the cache number
  100a24:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  100a28:	e153000a 	cmp	r3, r10
    BGT     .Loop1
  100a2c:	caffffe5 	bgt	1009c8 <flush_invalidate_cache_v7+0x18>

.Lfinished:
    mov     r10, #0
  100a30:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  100a34:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    dsb
  100a38:	f57ff04f 	dsb	sy
    isb
  100a3c:	f57ff06f 	isb	sy

    bx      lr
  100a40:	e12fff1e 	bx	r14

00100a44 <invalidate_cache_v7>:

// invalidate cache routine, trashes r0-r6, r9-r11
invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  100a44:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  100a48:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  100a4c:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  100a50:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished_invalidate
  100a54:	0a00001a 	beq	100ac4 <invalidate_cache_v7+0x80>
    MOV     R10, #0
  100a58:	e3a0a000 	mov	r10, #0
.Loop1_invalidate:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  100a5c:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  100a60:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  100a64:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  100a68:	e3510002 	cmp	r1, #2
    BLT     .Lskip_invalidate           // no cache or only instruction cache at this level
  100a6c:	ba000011 	blt	100ab8 <invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  100a70:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  100a74:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  100a78:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  100a7c:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  100a80:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  100a84:	e59f40cc 	ldr	r4, [pc, #204]	; 100b58 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  100a88:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  100a8c:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  100a90:	e59f60c4 	ldr	r6, [pc, #196]	; 100b5c <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  100a94:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2_invalidate:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  100a98:	e1a09004 	mov	r9, r4
.Loop3_invalidate:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  100a9c:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  100aa0:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c6, 2      // invalidate by set/way
  100aa4:	ee07bf56 	mcr	15, 0, r11, cr7, cr6, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  100aa8:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3_invalidate
  100aac:	aafffffa 	bge	100a9c <invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  100ab0:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2_invalidate
  100ab4:	aafffff7 	bge	100a98 <invalidate_cache_v7+0x54>
.Lskip_invalidate:
    ADD     R10, R10, #2                // increment the cache number
  100ab8:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  100abc:	e153000a 	cmp	r3, r10
    BGT     .Loop1_invalidate
  100ac0:	caffffe5 	bgt	100a5c <invalidate_cache_v7+0x18>

.Lfinished_invalidate:
    dsb
  100ac4:	f57ff04f 	dsb	sy
    mov     r10, #0
  100ac8:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  100acc:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb
  100ad0:	f57ff06f 	isb	sy

    bx      lr
  100ad4:	e12fff1e 	bx	r14

00100ad8 <arch_clean_cache_range_asm>:
/* shared cache flush routines */

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100ad8:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100adc:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100ae0:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c10, 1      // clean cache to PoC by MVA
  100ae4:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
    add     r0, #CACHE_LINE
  100ae8:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100aec:	e1500002 	cmp	r0, r2
    blo     0b
  100af0:	3afffffb 	bcc	100ae4 <arch_clean_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100af4:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_range
#else
    bx      lr
  100af8:	e12fff1e 	bx	r14

00100afc <arch_clean_invalidate_cache_range_asm>:
#endif

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100afc:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100b00:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100b04:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c14, 1      // clean & invalidate dcache to PoC by MVA
  100b08:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
    add     r0, r0, #CACHE_LINE
  100b0c:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100b10:	e1500002 	cmp	r0, r2
    blo     0b
  100b14:	3afffffb 	bcc	100b08 <arch_clean_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100b18:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_invalidate_range
#else
    bx      lr
  100b1c:	e12fff1e 	bx	r14

00100b20 <arch_invalidate_cache_range_asm>:
#endif

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100b20:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100b24:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100b28:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c6, 1       // invalidate dcache to PoC by MVA
  100b2c:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
    add     r0, r0, #CACHE_LINE
  100b30:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100b34:	e1500002 	cmp	r0, r2
    blo     0b
  100b38:	3afffffb 	bcc	100b2c <arch_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100b3c:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_invalidate_range
#else
    bx      lr
  100b40:	e12fff1e 	bx	r14

00100b44 <arch_sync_cache_range_asm>:
#endif

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range_asm)
    push    { r14 }
  100b44:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
    bl      arch_clean_cache_range_asm
  100b48:	ebffffe2 	bl	100ad8 <arch_clean_cache_range_asm>

    mov     r0, #0
  100b4c:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  100b50:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    pop     { pc }
  100b54:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
    LDR     R4, =0x3FF
  100b58:	000003ff 	.word	0x000003ff
    LDR     R6, =0x00007FFF
  100b5c:	00007fff 	.word	0x00007fff

00100b60 <_arch_enable_ints>:

.text

/* void _arch_enable_ints(void); */
FUNCTION(_arch_enable_ints)
    mrs     r0, cpsr
  100b60:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #(1<<7)     /* clear the I bit */
  100b64:	e3c00080 	bic	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  100b68:	e121f000 	msr	CPSR_c, r0
    bx      lr
  100b6c:	e12fff1e 	bx	r14

00100b70 <_arch_disable_ints>:

/* void _arch_disable_ints(void); */
FUNCTION(_arch_disable_ints)
    mrs     r0, cpsr
  100b70:	e10f0000 	mrs	r0, CPSR
    orr     r0, r0, #(1<<7)
  100b74:	e3800080 	orr	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  100b78:	e121f000 	msr	CPSR_c, r0
    bx      lr
  100b7c:	e12fff1e 	bx	r14

00100b80 <_atomic_swap>:

/* int _atomic_swap(int *ptr, int val); */
FUNCTION(_atomic_swap)
.L_loop_swap:
    ldrex   r12, [r0]
  100b80:	e190cf9f 	ldrex	r12, [r0]
    strex   r2, r1, [r0]
  100b84:	e1802f91 	strex	r2, r1, [r0]
    cmp     r2, #0
  100b88:	e3520000 	cmp	r2, #0
    bne     .L_loop_swap
  100b8c:	1afffffb 	bne	100b80 <_atomic_swap>

    /* save old value */
    mov     r0, r12
  100b90:	e1a0000c 	mov	r0, r12
    bx      lr
  100b94:	e12fff1e 	bx	r14

00100b98 <_atomic_add>:

/* int _atomic_add(int *ptr, int val); */
FUNCTION(_atomic_add)
    /* use load/store exclusive */
.L_loop_add:
    ldrex   r12, [r0]
  100b98:	e190cf9f 	ldrex	r12, [r0]
    add     r2, r12, r1
  100b9c:	e08c2001 	add	r2, r12, r1
    strex   r3, r2, [r0]
  100ba0:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100ba4:	e3530000 	cmp	r3, #0
    bne     .L_loop_add
  100ba8:	1afffffa 	bne	100b98 <_atomic_add>

    /* save old value */
    mov     r0, r12
  100bac:	e1a0000c 	mov	r0, r12
    bx      lr
  100bb0:	e12fff1e 	bx	r14

00100bb4 <_atomic_and>:

/* int _atomic_and(int *ptr, int val); */
FUNCTION(_atomic_and)
    /* use load/store exclusive */
.L_loop_and:
    ldrex   r12, [r0]
  100bb4:	e190cf9f 	ldrex	r12, [r0]
    and     r2, r12, r1
  100bb8:	e00c2001 	and	r2, r12, r1
    strex   r3, r2, [r0]
  100bbc:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100bc0:	e3530000 	cmp	r3, #0
    bne     .L_loop_and
  100bc4:	1afffffa 	bne	100bb4 <_atomic_and>

    /* save old value */
    mov     r0, r12
  100bc8:	e1a0000c 	mov	r0, r12
    bx      lr
  100bcc:	e12fff1e 	bx	r14

00100bd0 <_atomic_or>:

/* int _atomic_or(int *ptr, int val); */
FUNCTION(_atomic_or)
    /* use load/store exclusive */
.L_loop_or:
    ldrex   r12, [r0]
  100bd0:	e190cf9f 	ldrex	r12, [r0]
    orr     r2, r12, r1
  100bd4:	e18c2001 	orr	r2, r12, r1
    strex   r3, r2, [r0]
  100bd8:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100bdc:	e3530000 	cmp	r3, #0
    bne     .L_loop_or
  100be0:	1afffffa 	bne	100bd0 <_atomic_or>

    /* save old value */
    mov     r0, r12
  100be4:	e1a0000c 	mov	r0, r12
    bx      lr
  100be8:	e12fff1e 	bx	r14

00100bec <arch_spin_trylock>:

FUNCTION(arch_spin_trylock)
    mov     r2, r0
  100bec:	e1a02000 	mov	r2, r0
    mov     r1, #1
  100bf0:	e3a01001 	mov	r1, #1
    ldrex   r0, [r2]
  100bf4:	e1920f9f 	ldrex	r0, [r2]
    cmp     r0, #0
  100bf8:	e3500000 	cmp	r0, #0
    strexeq r0, r1, [r2]
  100bfc:	01820f91 	strexeq	r0, r1, [r2]
    dmb
  100c00:	f57ff05f 	dmb	sy
    bx      lr
  100c04:	e12fff1e 	bx	r14

00100c08 <arch_spin_lock>:

FUNCTION(arch_spin_lock)
    mov     r1, #1
  100c08:	e3a01001 	mov	r1, #1
1:
    ldrex   r2, [r0]
  100c0c:	e1902f9f 	ldrex	r2, [r0]
    cmp     r2, #0
  100c10:	e3520000 	cmp	r2, #0
    wfene
  100c14:	1320f002 	wfene
    strexeq r2, r1, [r0]
  100c18:	01802f91 	strexeq	r2, r1, [r0]
    cmpeq   r2, #0
  100c1c:	03520000 	cmpeq	r2, #0
    bne     1b
  100c20:	1afffff9 	bne	100c0c <arch_spin_lock+0x4>
    dmb
  100c24:	f57ff05f 	dmb	sy
    bx      lr
  100c28:	e12fff1e 	bx	r14

00100c2c <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
    mov     r1, #0
  100c2c:	e3a01000 	mov	r1, #0
    dmb
  100c30:	f57ff05f 	dmb	sy
    str     r1, [r0]
  100c34:	e5801000 	str	r1, [r0]
    dsb
  100c38:	f57ff04f 	dsb	sy
    sev
  100c3c:	e320f004 	sev
    bx      lr
  100c40:	e12fff1e 	bx	r14

00100c44 <arch_idle>:

/* void arch_idle(); */
FUNCTION(arch_idle)
#if ARM_ARCH_LEVEL >= 7
    wfi
  100c44:	e320f003 	wfi
    mov     r0, #0
    mcr     p15, 0, r0, c7, c0, #4
#else
#error unknown cpu
#endif
    bx      lr
  100c48:	e12fff1e 	bx	r14

00100c4c <arm_invalidate_tlb>:

/* void arm_invalidate_tlb(void) */
FUNCTION(arm_invalidate_tlb)
    mov     r0, #0
  100c4c:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c8, c7, 0
  100c50:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    bx      lr
  100c54:	e12fff1e 	bx	r14

00100c58 <arm_undefined>:
    /* return to whence we came from */
    rfeia   sp!
.endm

FUNCTION(arm_undefined)
    save
  100c58:	f96d0513 	srsdb	r13!, #19
  100c5c:	f10e0093 	cpsid	i,#19
  100c60:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100c64:	e24dd008 	sub	r13, r13, #8
  100c68:	e8cd6000 	stmia	r13, {r13, r14}^
  100c6c:	eef80a10 	vmrs	r0, fpexc
  100c70:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100c74:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100c78:	eee80a10 	vmsr	fpexc, r0
  100c7c:	e1a0000d 	mov	r0, r13
  100c80:	e31d0004 	tst	r13, #4
  100c84:	024dd004 	subeq	r13, r13, #4
  100c88:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_undefined_handler
  100c8c:	fa00018a 	blx	1012bc <arm_undefined_handler>

    restore
  100c90:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100c94:	e1a0d000 	mov	r13, r0
  100c98:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100c9c:	eee80a10 	vmsr	fpexc, r0
  100ca0:	e8dd6000 	ldm	r13, {r13, r14}^
  100ca4:	e28dd008 	add	r13, r13, #8
  100ca8:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100cac:	f8bd0a00 	rfeia	r13!

00100cb0 <arm_syscall>:

#ifndef WITH_LIB_SYSCALL
FUNCTION(arm_syscall)
    saveall
  100cb0:	f96d0513 	srsdb	r13!, #19
  100cb4:	f10e0093 	cpsid	i,#19
  100cb8:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100cbc:	e24dd008 	sub	r13, r13, #8
  100cc0:	e8cd6000 	stmia	r13, {r13, r14}^
  100cc4:	eef80a10 	vmrs	r0, fpexc
  100cc8:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100ccc:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100cd0:	eee80a10 	vmsr	fpexc, r0
  100cd4:	e1a0000d 	mov	r0, r13
  100cd8:	e31d0004 	tst	r13, #4
  100cdc:	024dd004 	subeq	r13, r13, #4
  100ce0:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_syscall_handler
  100ce4:	fa000170 	blx	1012ac <arm_syscall_handler>

    restoreall
  100ce8:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100cec:	e1a0d000 	mov	r13, r0
  100cf0:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100cf4:	eee80a10 	vmsr	fpexc, r0
  100cf8:	e8dd6000 	ldm	r13, {r13, r14}^
  100cfc:	e28dd008 	add	r13, r13, #8
  100d00:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d04:	f8bd0a00 	rfeia	r13!

00100d08 <arm_prefetch_abort>:
#endif

FUNCTION(arm_prefetch_abort)
    saveall_offset #4
  100d08:	e24ee004 	sub	r14, r14, #4
  100d0c:	f96d0513 	srsdb	r13!, #19
  100d10:	f10e0093 	cpsid	i,#19
  100d14:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d18:	e24dd008 	sub	r13, r13, #8
  100d1c:	e8cd6000 	stmia	r13, {r13, r14}^
  100d20:	eef80a10 	vmrs	r0, fpexc
  100d24:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100d28:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100d2c:	eee80a10 	vmsr	fpexc, r0
  100d30:	e1a0000d 	mov	r0, r13
  100d34:	e31d0004 	tst	r13, #4
  100d38:	024dd004 	subeq	r13, r13, #4
  100d3c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_prefetch_abort_handler
  100d40:	fa000206 	blx	101560 <arm_prefetch_abort_handler>

    restoreall
  100d44:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d48:	e1a0d000 	mov	r13, r0
  100d4c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d50:	eee80a10 	vmsr	fpexc, r0
  100d54:	e8dd6000 	ldm	r13, {r13, r14}^
  100d58:	e28dd008 	add	r13, r13, #8
  100d5c:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d60:	f8bd0a00 	rfeia	r13!

00100d64 <arm_data_abort>:

FUNCTION(arm_data_abort)
    saveall_offset #8
  100d64:	e24ee008 	sub	r14, r14, #8
  100d68:	f96d0513 	srsdb	r13!, #19
  100d6c:	f10e0093 	cpsid	i,#19
  100d70:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d74:	e24dd008 	sub	r13, r13, #8
  100d78:	e8cd6000 	stmia	r13, {r13, r14}^
  100d7c:	eef80a10 	vmrs	r0, fpexc
  100d80:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100d84:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100d88:	eee80a10 	vmsr	fpexc, r0
  100d8c:	e1a0000d 	mov	r0, r13
  100d90:	e31d0004 	tst	r13, #4
  100d94:	024dd004 	subeq	r13, r13, #4
  100d98:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_data_abort_handler
  100d9c:	fa000180 	blx	1013a4 <arm_data_abort_handler>

    restoreall
  100da0:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100da4:	e1a0d000 	mov	r13, r0
  100da8:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100dac:	eee80a10 	vmsr	fpexc, r0
  100db0:	e8dd6000 	ldm	r13, {r13, r14}^
  100db4:	e28dd008 	add	r13, r13, #8
  100db8:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100dbc:	f8bd0a00 	rfeia	r13!

00100dc0 <arm_reserved>:

FUNCTION(arm_reserved)
    b   .
  100dc0:	eafffffe 	b	100dc0 <arm_reserved>

00100dc4 <arm_irq>:
    /* read the cycle count */
    mrc     p15, 0, sp, c9, c13, 0
    str     sp, [pc, #__irq_cycle_count - . - 8]
#endif

    save_offset    #4
  100dc4:	e24ee004 	sub	r14, r14, #4
  100dc8:	f96d0513 	srsdb	r13!, #19
  100dcc:	f10e0093 	cpsid	i,#19
  100dd0:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100dd4:	e24dd008 	sub	r13, r13, #8
  100dd8:	e8cd6000 	stmia	r13, {r13, r14}^
  100ddc:	eef80a10 	vmrs	r0, fpexc
  100de0:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100de4:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100de8:	eee80a10 	vmsr	fpexc, r0
  100dec:	e1a0000d 	mov	r0, r13
  100df0:	e31d0004 	tst	r13, #4
  100df4:	024dd004 	subeq	r13, r13, #4
  100df8:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)

    /* r0 now holds pointer to iframe */

    /* track that we're inside an irq handler */
    LOADCONST(r2, __arm_in_handler)
  100dfc:	e30f25c8 	movw	r2, #62920	; 0xf5c8
  100e00:	e3402011 	movt	r2, #17
    mov     r1, #1
  100e04:	e3a01001 	mov	r1, #1
    str     r1, [r2]
  100e08:	e5821000 	str	r1, [r2]

    /* call into higher level code */
    bl  platform_irq
  100e0c:	fa001bdb 	blx	107d80 <platform_irq>

    /* clear the irq handler status */
    LOADCONST(r1, __arm_in_handler)
  100e10:	e30f15c8 	movw	r1, #62920	; 0xf5c8
  100e14:	e3401011 	movt	r1, #17
    mov     r2, #0
  100e18:	e3a02000 	mov	r2, #0
    str     r2, [r1]
  100e1c:	e5812000 	str	r2, [r1]

    /* reschedule if the handler returns nonzero */
    cmp     r0, #0
  100e20:	e3500000 	cmp	r0, #0
    /* blne    thread_preempt */

    restore
  100e24:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e28:	e1a0d000 	mov	r13, r0
  100e2c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e30:	eee80a10 	vmsr	fpexc, r0
  100e34:	e8dd6000 	ldm	r13, {r13, r14}^
  100e38:	e28dd008 	add	r13, r13, #8
  100e3c:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100e40:	f8bd0a00 	rfeia	r13!

00100e44 <arm_fiq>:

FUNCTION(arm_fiq)
    save_offset #4
  100e44:	e24ee004 	sub	r14, r14, #4
  100e48:	f96d0513 	srsdb	r13!, #19
  100e4c:	f10e0093 	cpsid	i,#19
  100e50:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100e54:	e24dd008 	sub	r13, r13, #8
  100e58:	e8cd6000 	stmia	r13, {r13, r14}^
  100e5c:	eef80a10 	vmrs	r0, fpexc
  100e60:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100e64:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100e68:	eee80a10 	vmsr	fpexc, r0
  100e6c:	e1a0000d 	mov	r0, r13
  100e70:	e31d0004 	tst	r13, #4
  100e74:	024dd004 	subeq	r13, r13, #4
  100e78:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl  platform_fiq
  100e7c:	fa001be6 	blx	107e1c <platform_fiq>

    restore
  100e80:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e84:	e1a0d000 	mov	r13, r0
  100e88:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e8c:	eee80a10 	vmsr	fpexc, r0
  100e90:	e8dd6000 	ldm	r13, {r13, r14}^
  100e94:	e28dd008 	add	r13, r13, #8
  100e98:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100e9c:	f8bd0a00 	rfeia	r13!

00100ea0 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cmp	r2, #0
  100ea0:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_done
  100ea4:	0a000003 	beq	100eb8 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	r3, [r1], #1
  100ea8:	e4d13001 	ldrb	r3, [r1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	strbt	r3, [r0], #1
  100eac:	e4e03001 	strbt	r3, [r0], #1

	subs	r2, r2, #1
  100eb0:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_to_user_loop
  100eb4:	8afffffb 	bhi	100ea8 <arch_copy_to_user+0x8>
.Larch_copy_to_user_done:
	mov	r0, #0
  100eb8:	e3a00000 	mov	r0, #0
	bx	lr
  100ebc:	e12fff1e 	bx	r14

00100ec0 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cmp	r2, #0
  100ec0:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_from_user_done
  100ec4:	0a000003 	beq	100ed8 <arch_copy_from_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldrbt	r3, [r1], #1
  100ec8:	e4f13001 	ldrbt	r3, [r1], #1

	strb	r3, [r0], #1
  100ecc:	e4c03001 	strb	r3, [r0], #1
	subs	r2, r2, #1
  100ed0:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_loop
  100ed4:	8afffffb 	bhi	100ec8 <arch_copy_from_user+0x8>
.Larch_copy_from_user_done:
	mov	r0, #0
  100ed8:	e3a00000 	mov	r0, #0
	bx	lr
  100edc:	e12fff1e 	bx	r14

00100ee0 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	ip, r1
  100ee0:	e1a0c001 	mov	r12, r1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldrbt	r3, [r1]
  100ee4:	e4f13000 	ldrbt	r3, [r1], #0

	cmp	r3, #0
  100ee8:	e3530000 	cmp	r3, #0
	addne	r1, r1, #1
  100eec:	12811001 	addne	r1, r1, #1

	cmp	r2, #0
  100ef0:	e3520000 	cmp	r2, #0
	beq	.Larch_strlcpy_from_user_dst_full
  100ef4:	0a000002 	beq	100f04 <arch_strlcpy_from_user+0x24>
	subs	r2, r2, #1
  100ef8:	e2522001 	subs	r2, r2, #1
	streqb	r2, [r0], #1
  100efc:	04c02001 	strbeq	r2, [r0], #1
	strneb	r3, [r0], #1
  100f00:	14c03001 	strbne	r3, [r0], #1
.Larch_strlcpy_from_user_dst_full:
	cmp	r3, #0
  100f04:	e3530000 	cmp	r3, #0
	bne	.Larch_strlcpy_from_user_loop
  100f08:	1afffff5 	bne	100ee4 <arch_strlcpy_from_user+0x4>

	sub	r0, r1, ip
  100f0c:	e041000c 	sub	r0, r1, r12
	bx	lr
  100f10:	e12fff1e 	bx	r14

.Larch_strlcpy_from_user_fault:
	cmp	r2, #0
  100f14:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_fault
  100f18:	0a000003 	beq	100f2c <arch_strlcpy_from_user+0x4c>
.Larch_copy_from_user_fault:
	mov	r1, #0
  100f1c:	e3a01000 	mov	r1, #0
	strb	r1, [r0], #1
  100f20:	e4c01001 	strb	r1, [r0], #1
	subs	r2, r2, #1
  100f24:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_fault
  100f28:	8afffffb 	bhi	100f1c <arch_strlcpy_from_user+0x3c>
.Larch_copy_to_user_fault:
	mov	r0, #ERR_FAULT
  100f2c:	e3e00027 	mvn	r0, #39	; 0x27
	bx	lr
  100f30:	e12fff1e 	bx	r14

00100f34 <dump_mode_regs>:

extern struct fault_handler_table_entry __fault_handler_table_start[];
extern struct fault_handler_table_entry __fault_handler_table_end[];

static void dump_mode_regs(uint32_t spsr, uint32_t svc_r13, uint32_t svc_r14)
{
  100f34:	b570      	push	{r4, r5, r6, r14}
  100f36:	4604      	mov	r4, r0
  100f38:	b090      	sub	sp, #64	; 0x40
    struct arm_mode_regs regs;
    arm_save_mode_regs(&regs);
  100f3a:	a802      	add	r0, sp, #8
{
  100f3c:	4615      	mov	r5, r2

    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  100f3e:	f004 041f 	and.w	r4, r4, #31
{
  100f42:	460e      	mov	r6, r1
    arm_save_mode_regs(&regs);
  100f44:	f7ff ec9e 	blx	100884 <arm_save_mode_regs>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  100f48:	9b03      	ldr	r3, [sp, #12]
  100f4a:	2c10      	cmp	r4, #16
  100f4c:	f647 7240 	movw	r2, #32576	; 0x7f40
  100f50:	f647 7044 	movw	r0, #32580	; 0x7f44
  100f54:	9300      	str	r3, [sp, #0]
  100f56:	f2c0 0211 	movt	r2, #17
  100f5a:	9b02      	ldr	r3, [sp, #8]
  100f5c:	f2c0 0011 	movt	r0, #17
  100f60:	f000 80d8 	beq.w	101114 <dump_mode_regs+0x1e0>
  100f64:	2120      	movs	r1, #32
  100f66:	f013 fc4d 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  100f6a:	9b05      	ldr	r3, [sp, #20]
  100f6c:	f647 7260 	movw	r2, #32608	; 0x7f60
  100f70:	2c11      	cmp	r4, #17
  100f72:	f647 7044 	movw	r0, #32580	; 0x7f44
  100f76:	f2c0 0211 	movt	r2, #17
  100f7a:	9300      	str	r3, [sp, #0]
  100f7c:	f2c0 0011 	movt	r0, #17
  100f80:	9b04      	ldr	r3, [sp, #16]
  100f82:	d158      	bne.n	101036 <dump_mode_regs+0x102>
  100f84:	212a      	movs	r1, #42	; 0x2a
  100f86:	f013 fc3d 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  100f8a:	9b07      	ldr	r3, [sp, #28]
  100f8c:	f647 7264 	movw	r2, #32612	; 0x7f64
  100f90:	f647 7044 	movw	r0, #32580	; 0x7f44
  100f94:	9300      	str	r3, [sp, #0]
  100f96:	f2c0 0211 	movt	r2, #17
  100f9a:	9b06      	ldr	r3, [sp, #24]
  100f9c:	2120      	movs	r1, #32
  100f9e:	f2c0 0011 	movt	r0, #17
  100fa2:	f013 fc2f 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  100fa6:	9b09      	ldr	r3, [sp, #36]	; 0x24
  100fa8:	f647 7268 	movw	r2, #32616	; 0x7f68
  100fac:	f647 7044 	movw	r0, #32580	; 0x7f44
  100fb0:	9300      	str	r3, [sp, #0]
  100fb2:	f2c0 0211 	movt	r2, #17
  100fb6:	9b08      	ldr	r3, [sp, #32]
  100fb8:	2161      	movs	r1, #97	; 0x61
  100fba:	f2c0 0011 	movt	r0, #17
  100fbe:	f013 fc21 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  100fc2:	f647 7268 	movw	r2, #32616	; 0x7f68
  100fc6:	f647 7044 	movw	r0, #32580	; 0x7f44
  100fca:	f2c0 0211 	movt	r2, #17
  100fce:	9500      	str	r5, [sp, #0]
  100fd0:	f2c0 0011 	movt	r0, #17
  100fd4:	4633      	mov	r3, r6
  100fd6:	2120      	movs	r1, #32
  100fd8:	f013 fc14 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  100fdc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  100fde:	f647 726c 	movw	r2, #32620	; 0x7f6c
  100fe2:	f647 7044 	movw	r0, #32580	; 0x7f44
  100fe6:	f2c0 0211 	movt	r2, #17
  100fea:	9300      	str	r3, [sp, #0]
  100fec:	f2c0 0011 	movt	r0, #17
  100ff0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  100ff2:	2120      	movs	r1, #32
  100ff4:	f013 fc06 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  100ff8:	2c1f      	cmp	r4, #31
  100ffa:	d159      	bne.n	1010b0 <dump_mode_regs+0x17c>
  100ffc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  100ffe:	f647 7270 	movw	r2, #32624	; 0x7f70
  101002:	f647 7044 	movw	r0, #32580	; 0x7f44
  101006:	f2c0 0211 	movt	r2, #17
  10100a:	9300      	str	r3, [sp, #0]
  10100c:	f2c0 0011 	movt	r0, #17
  101010:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  101012:	212a      	movs	r1, #42	; 0x2a
  101014:	f013 fbf6 	bl	114804 <printf>
            break;
        case CPSR_MODE_UND:
            stack = regs.und_r13;
            break;
        case CPSR_MODE_SYS:
            stack = regs.sys_r13;
  101018:	9e0e      	ldr	r6, [sp, #56]	; 0x38
            break;
        default:
            stack = 0;
    }

    if (stack != 0) {
  10101a:	b156      	cbz	r6, 101032 <dump_mode_regs+0xfe>
        dprintf(CRITICAL, "bottom of stack at 0x%08x:\n", (unsigned int)stack);
  10101c:	f647 7074 	movw	r0, #32628	; 0x7f74
  101020:	4631      	mov	r1, r6
  101022:	f2c0 0011 	movt	r0, #17
  101026:	f013 fbed 	bl	114804 <printf>
        hexdump((void *)stack, 128);
  10102a:	4630      	mov	r0, r6
  10102c:	2180      	movs	r1, #128	; 0x80
  10102e:	f012 fbcb 	bl	1137c8 <hexdump>
    }
}
  101032:	b010      	add	sp, #64	; 0x40
  101034:	bd70      	pop	{r4, r5, r6, r15}
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  101036:	2120      	movs	r1, #32
  101038:	f013 fbe4 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  10103c:	9b07      	ldr	r3, [sp, #28]
  10103e:	f647 7264 	movw	r2, #32612	; 0x7f64
  101042:	2c12      	cmp	r4, #18
  101044:	f647 7044 	movw	r0, #32580	; 0x7f44
  101048:	f2c0 0211 	movt	r2, #17
  10104c:	9300      	str	r3, [sp, #0]
  10104e:	f2c0 0011 	movt	r0, #17
  101052:	9b06      	ldr	r3, [sp, #24]
  101054:	f040 8096 	bne.w	101184 <dump_mode_regs+0x250>
  101058:	212a      	movs	r1, #42	; 0x2a
  10105a:	f013 fbd3 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  10105e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  101060:	f647 7268 	movw	r2, #32616	; 0x7f68
  101064:	f647 7044 	movw	r0, #32580	; 0x7f44
  101068:	9300      	str	r3, [sp, #0]
  10106a:	f2c0 0211 	movt	r2, #17
  10106e:	9b08      	ldr	r3, [sp, #32]
  101070:	2161      	movs	r1, #97	; 0x61
  101072:	f2c0 0011 	movt	r0, #17
  101076:	f013 fbc5 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  10107a:	f647 7268 	movw	r2, #32616	; 0x7f68
  10107e:	f647 7044 	movw	r0, #32580	; 0x7f44
  101082:	f2c0 0211 	movt	r2, #17
  101086:	4633      	mov	r3, r6
  101088:	2120      	movs	r1, #32
  10108a:	9500      	str	r5, [sp, #0]
  10108c:	f2c0 0011 	movt	r0, #17
  101090:	f013 fbb8 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  101094:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  101096:	f647 726c 	movw	r2, #32620	; 0x7f6c
  10109a:	f647 7044 	movw	r0, #32580	; 0x7f44
  10109e:	9300      	str	r3, [sp, #0]
  1010a0:	f2c0 0211 	movt	r2, #17
  1010a4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1010a6:	f2c0 0011 	movt	r0, #17
  1010aa:	2120      	movs	r1, #32
  1010ac:	f013 fbaa 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1010b0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  1010b2:	f647 7270 	movw	r2, #32624	; 0x7f70
  1010b6:	f647 7044 	movw	r0, #32580	; 0x7f44
    switch (spsr & CPSR_MODE_MASK) {
  1010ba:	3c11      	subs	r4, #17
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1010bc:	9300      	str	r3, [sp, #0]
  1010be:	f2c0 0211 	movt	r2, #17
  1010c2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  1010c4:	f2c0 0011 	movt	r0, #17
  1010c8:	2120      	movs	r1, #32
  1010ca:	f013 fb9b 	bl	114804 <printf>
    switch (spsr & CPSR_MODE_MASK) {
  1010ce:	2c0e      	cmp	r4, #14
  1010d0:	d8af      	bhi.n	101032 <dump_mode_regs+0xfe>
  1010d2:	a301      	add	r3, pc, #4	; (adr r3, 1010d8 <dump_mode_regs+0x1a4>)
  1010d4:	f853 f024 	ldr.w	r15, [r3, r4, lsl #2]
  1010d8:	00101181 	.word	0x00101181
  1010dc:	0010117d 	.word	0x0010117d
  1010e0:	0010101b 	.word	0x0010101b
  1010e4:	00101033 	.word	0x00101033
  1010e8:	00101033 	.word	0x00101033
  1010ec:	00101033 	.word	0x00101033
  1010f0:	00101033 	.word	0x00101033
  1010f4:	00101033 	.word	0x00101033
  1010f8:	00101033 	.word	0x00101033
  1010fc:	00101033 	.word	0x00101033
  101100:	00101179 	.word	0x00101179
  101104:	00101033 	.word	0x00101033
  101108:	00101033 	.word	0x00101033
  10110c:	00101033 	.word	0x00101033
  101110:	00101019 	.word	0x00101019
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  101114:	212a      	movs	r1, #42	; 0x2a
  101116:	f013 fb75 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  10111a:	9b05      	ldr	r3, [sp, #20]
  10111c:	f647 7260 	movw	r2, #32608	; 0x7f60
  101120:	f647 7044 	movw	r0, #32580	; 0x7f44
  101124:	9300      	str	r3, [sp, #0]
  101126:	f2c0 0211 	movt	r2, #17
  10112a:	9b04      	ldr	r3, [sp, #16]
  10112c:	f2c0 0011 	movt	r0, #17
  101130:	2120      	movs	r1, #32
  101132:	e728      	b.n	100f86 <dump_mode_regs+0x52>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  101134:	2120      	movs	r1, #32
  101136:	f013 fb65 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  10113a:	2c1b      	cmp	r4, #27
  10113c:	f47f af4e 	bne.w	100fdc <dump_mode_regs+0xa8>
  101140:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  101142:	f647 726c 	movw	r2, #32620	; 0x7f6c
  101146:	f647 7044 	movw	r0, #32580	; 0x7f44
  10114a:	f2c0 0211 	movt	r2, #17
  10114e:	9300      	str	r3, [sp, #0]
  101150:	212a      	movs	r1, #42	; 0x2a
  101152:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  101154:	f2c0 0011 	movt	r0, #17
  101158:	f013 fb54 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  10115c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  10115e:	f647 7270 	movw	r2, #32624	; 0x7f70
  101162:	f647 7044 	movw	r0, #32580	; 0x7f44
  101166:	9300      	str	r3, [sp, #0]
  101168:	f2c0 0211 	movt	r2, #17
  10116c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  10116e:	f2c0 0011 	movt	r0, #17
  101172:	2120      	movs	r1, #32
  101174:	f013 fb46 	bl	114804 <printf>
            stack = regs.und_r13;
  101178:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            break;
  10117a:	e74e      	b.n	10101a <dump_mode_regs+0xe6>
            stack = regs.irq_r13;
  10117c:	9e06      	ldr	r6, [sp, #24]
            break;
  10117e:	e74c      	b.n	10101a <dump_mode_regs+0xe6>
            stack = regs.fiq_r13;
  101180:	9e04      	ldr	r6, [sp, #16]
            break;
  101182:	e74a      	b.n	10101a <dump_mode_regs+0xe6>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  101184:	2120      	movs	r1, #32
  101186:	f013 fb3d 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  10118a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  10118c:	f647 7268 	movw	r2, #32616	; 0x7f68
  101190:	f647 7044 	movw	r0, #32580	; 0x7f44
  101194:	9300      	str	r3, [sp, #0]
  101196:	f2c0 0211 	movt	r2, #17
  10119a:	9b08      	ldr	r3, [sp, #32]
  10119c:	f2c0 0011 	movt	r0, #17
  1011a0:	2161      	movs	r1, #97	; 0x61
  1011a2:	f013 fb2f 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  1011a6:	f647 7268 	movw	r2, #32616	; 0x7f68
  1011aa:	f647 7044 	movw	r0, #32580	; 0x7f44
  1011ae:	2c13      	cmp	r4, #19
  1011b0:	9500      	str	r5, [sp, #0]
  1011b2:	f2c0 0211 	movt	r2, #17
  1011b6:	4633      	mov	r3, r6
  1011b8:	f2c0 0011 	movt	r0, #17
  1011bc:	d1ba      	bne.n	101134 <dump_mode_regs+0x200>
  1011be:	212a      	movs	r1, #42	; 0x2a
  1011c0:	f013 fb20 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  1011c4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1011c6:	f647 726c 	movw	r2, #32620	; 0x7f6c
  1011ca:	f647 7044 	movw	r0, #32580	; 0x7f44
  1011ce:	9300      	str	r3, [sp, #0]
  1011d0:	f2c0 0211 	movt	r2, #17
  1011d4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1011d6:	2120      	movs	r1, #32
  1011d8:	f2c0 0011 	movt	r0, #17
  1011dc:	f013 fb12 	bl	114804 <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1011e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  1011e2:	f647 7270 	movw	r2, #32624	; 0x7f70
  1011e6:	f647 7044 	movw	r0, #32580	; 0x7f44
  1011ea:	9300      	str	r3, [sp, #0]
  1011ec:	f2c0 0211 	movt	r2, #17
  1011f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  1011f2:	2120      	movs	r1, #32
  1011f4:	f2c0 0011 	movt	r0, #17
  1011f8:	f013 fb04 	bl	114804 <printf>
  1011fc:	e70d      	b.n	10101a <dump_mode_regs+0xe6>
  1011fe:	bf00      	nop

00101200 <exception_die>:

    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
}

static void exception_die(struct arm_fault_frame *frame, const char *msg)
{
  101200:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  101202:	f647 7090 	movw	r0, #32656	; 0x7f90
{
  101206:	b500      	push	{r14}
    dprintf(CRITICAL, "%s", msg);
  101208:	f2c0 0011 	movt	r0, #17
{
  10120c:	b083      	sub	sp, #12
    dprintf(CRITICAL, "%s", msg);
  10120e:	f013 faf9 	bl	114804 <printf>

GEN_CP15_REG_FUNCS(fcseidr, 0, c13, c0, 0);
GEN_CP15_REG_FUNCS(contextidr, 0, c13, c0, 1);
GEN_CP15_REG_FUNCS(tpidrurw, 0, c13, c0, 2);
GEN_CP15_REG_FUNCS(tpidruro, 0, c13, c0, 3);
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  101212:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    dprintf(CRITICAL, "current_thread %p, name %s\n",
  101216:	f501 72b2 	add.w	r2, r1, #356	; 0x164
  10121a:	b919      	cbnz	r1, 101224 <exception_die+0x24>
  10121c:	f64e 52a8 	movw	r2, #60840	; 0xeda8
  101220:	f2c0 0211 	movt	r2, #17
  101224:	f647 7094 	movw	r0, #32660	; 0x7f94
  101228:	f2c0 0011 	movt	r0, #17
  10122c:	f013 faea 	bl	114804 <printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
  101230:	69a5      	ldr	r5, [r4, #24]
  101232:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  101236:	f647 70b0 	movw	r0, #32688	; 0x7fb0
  10123a:	68e1      	ldr	r1, [r4, #12]
  10123c:	f2c0 0011 	movt	r0, #17
  101240:	9500      	str	r5, [sp, #0]
  101242:	f013 fadf 	bl	114804 <printf>
    dprintf(CRITICAL, "r4  0x%08x r5  0x%08x r6  0x%08x r7  0x%08x\n", frame->r[4], frame->r[5], frame->r[6], frame->r[7]);
  101246:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  101248:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  10124c:	f647 70e0 	movw	r0, #32736	; 0x7fe0
  101250:	69e1      	ldr	r1, [r4, #28]
  101252:	f2c0 0011 	movt	r0, #17
  101256:	9500      	str	r5, [sp, #0]
  101258:	f013 fad4 	bl	114804 <printf>
    dprintf(CRITICAL, "r8  0x%08x r9  0x%08x r10 0x%08x r11 0x%08x\n", frame->r[8], frame->r[9], frame->r[10], frame->r[11]);
  10125c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  10125e:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
  101262:	f248 0010 	movw	r0, #32784	; 0x8010
  101266:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  101268:	f2c0 0011 	movt	r0, #17
  10126c:	9500      	str	r5, [sp, #0]
  10126e:	f013 fac9 	bl	114804 <printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r[12], frame->usp, frame->ulr, frame->pc);
  101272:	6c65      	ldr	r5, [r4, #68]	; 0x44
  101274:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  101278:	f248 0040 	movw	r0, #32832	; 0x8040
  10127c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  10127e:	f2c0 0011 	movt	r0, #17
  101282:	9500      	str	r5, [sp, #0]
  101284:	f013 fabe 	bl	114804 <printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  101288:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  10128a:	f248 0070 	movw	r0, #32880	; 0x8070
  10128e:	f2c0 0011 	movt	r0, #17
  101292:	f013 fab7 	bl	114804 <printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  101296:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  101298:	6c22      	ldr	r2, [r4, #64]	; 0x40
  10129a:	f104 014c 	add.w	r1, r4, #76	; 0x4c
  10129e:	f7ff fe49 	bl	100f34 <dump_mode_regs>
    dump_fault_frame(frame);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  1012a2:	2109      	movs	r1, #9
  1012a4:	2000      	movs	r0, #0
  1012a6:	f7ff f931 	bl	10050c <platform_halt>
  1012aa:	bf00      	nop

001012ac <arm_syscall_handler>:
    for (;;);
}

__WEAK void arm_syscall_handler(struct arm_fault_frame *frame)
{
    exception_die(frame, "unhandled syscall, halting\n");
  1012ac:	f647 7108 	movw	r1, #32520	; 0x7f08
{
  1012b0:	b508      	push	{r3, r14}
    exception_die(frame, "unhandled syscall, halting\n");
  1012b2:	f2c0 0111 	movt	r1, #17
  1012b6:	f7ff ffa3 	bl	101200 <exception_die>
  1012ba:	bf00      	nop

001012bc <arm_undefined_handler>:
}

void arm_undefined_handler(struct arm_iframe *frame)
{
  1012bc:	e9d0 3209 	ldrd	r3, r2, [r0, #36]	; 0x24
  1012c0:	b510      	push	{r4, r14}
    /* look at the undefined instruction, figure out if it's something we can handle */
    bool in_thumb = frame->spsr & (1<<5);
    if (in_thumb) {
  1012c2:	0692      	lsls	r2, r2, #26
{
  1012c4:	b082      	sub	sp, #8
    if (in_thumb) {
  1012c6:	d524      	bpl.n	101312 <arm_undefined_handler+0x56>
        if (opcode & 0x0000e800) {
            /* swap the 16bit words */
            opcode = (opcode >> 16) | (opcode << 16);
        }

        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012c8:	f44f 6120 	mov.w	r1, #2560	; 0xa00
        frame->pc -= 2;
  1012cc:	1e9a      	subs	r2, r3, #2
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012ce:	f6ce 4100 	movt	r1, #60416	; 0xec00
        frame->pc -= 2;
  1012d2:	6242      	str	r2, [r0, #36]	; 0x24
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012d4:	f44f 6260 	mov.w	r2, #3584	; 0xe00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  1012d8:	f853 3c02 	ldr.w	r3, [r3, #-2]
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012dc:	f6ce 4200 	movt	r2, #60416	; 0xec00
        if (opcode & 0x0000e800) {
  1012e0:	f413 4f68 	tst.w	r3, #59392	; 0xe800
            opcode = (opcode >> 16) | (opcode << 16);
  1012e4:	bf18      	it	ne
  1012e6:	ea4f 4333 	movne.w	r3, r3, ror #16
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012ea:	401a      	ands	r2, r3
  1012ec:	428a      	cmp	r2, r1
  1012ee:	d00b      	beq.n	101308 <arm_undefined_handler+0x4c>
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  1012f0:	f003 426f 	and.w	r2, r3, #4009754624	; 0xef000000
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012f4:	f1b2 4f6f 	cmp.w	r2, #4009754624	; 0xef000000
  1012f8:	d006      	beq.n	101308 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf9000000)) { // VLD
  1012fa:	2200      	movs	r2, #0
  1012fc:	f6cf 7210 	movt	r2, #65296	; 0xff10
  101300:	401a      	ands	r2, r3
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  101302:	f1b2 4f79 	cmp.w	r2, #4177526784	; 0xf9000000
  101306:	d11f      	bne.n	101348 <arm_undefined_handler+0x8c>

#if ARM_WITH_VFP
fpu:
    arm_fpu_undefined_instruction(frame);
#endif
}
  101308:	b002      	add	sp, #8
  10130a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    arm_fpu_undefined_instruction(frame);
  10130e:	f000 b9a7 	b.w	101660 <arm_fpu_undefined_instruction>
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101312:	f44f 6260 	mov.w	r2, #3584	; 0xe00
        frame->pc -= 4;
  101316:	1f1c      	subs	r4, r3, #4
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101318:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  10131c:	f6c0 4200 	movt	r2, #3072	; 0xc00
        frame->pc -= 4;
  101320:	6244      	str	r4, [r0, #36]	; 0x24
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101322:	f6c0 4100 	movt	r1, #3072	; 0xc00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  101326:	f853 3c04 	ldr.w	r3, [r3, #-4]
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  10132a:	401a      	ands	r2, r3
  10132c:	428a      	cmp	r2, r1
  10132e:	d0eb      	beq.n	101308 <arm_undefined_handler+0x4c>
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  101330:	f003 427e 	and.w	r2, r3, #4261412864	; 0xfe000000
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101334:	f1b2 4f72 	cmp.w	r2, #4060086272	; 0xf2000000
  101338:	d0e6      	beq.n	101308 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf4000000)) { // VLD
  10133a:	2200      	movs	r2, #0
  10133c:	f6cf 7210 	movt	r2, #65296	; 0xff10
  101340:	401a      	ands	r2, r3
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  101342:	f1b2 4f74 	cmp.w	r2, #4093640704	; 0xf4000000
  101346:	d0df      	beq.n	101308 <arm_undefined_handler+0x4c>
  101348:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  10134a:	f647 7024 	movw	r0, #32548	; 0x7f24
  10134e:	f2c0 0011 	movt	r0, #17
  101352:	f013 fa3f 	bl	1147d4 <puts>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r0, frame->r1, frame->r2, frame->r3);
  101356:	f647 70b0 	movw	r0, #32688	; 0x7fb0
  10135a:	69a3      	ldr	r3, [r4, #24]
  10135c:	f2c0 0011 	movt	r0, #17
  101360:	9300      	str	r3, [sp, #0]
  101362:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  101366:	68e1      	ldr	r1, [r4, #12]
  101368:	f013 fa4c 	bl	114804 <printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r12, frame->usp, frame->ulr, frame->pc);
  10136c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  10136e:	9300      	str	r3, [sp, #0]
  101370:	f248 0040 	movw	r0, #32832	; 0x8040
  101374:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  101378:	f2c0 0011 	movt	r0, #17
  10137c:	69e1      	ldr	r1, [r4, #28]
  10137e:	f013 fa41 	bl	114804 <printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  101382:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  101384:	f248 0070 	movw	r0, #32880	; 0x8070
  101388:	f2c0 0011 	movt	r0, #17
  10138c:	f013 fa3a 	bl	114804 <printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  101390:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  101392:	6a22      	ldr	r2, [r4, #32]
  101394:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  101398:	f7ff fdcc 	bl	100f34 <dump_mode_regs>
    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  10139c:	2109      	movs	r1, #9
  10139e:	2000      	movs	r0, #0
  1013a0:	f7ff f8b4 	bl	10050c <platform_halt>

001013a4 <arm_data_abort_handler>:

void arm_data_abort_handler(struct arm_fault_frame *frame)
{
  1013a4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
GEN_CP15_REG_FUNCS(dfsr, 0, c5, c0, 0);
  1013a6:	ee15 5f10 	mrc	15, 0, r5, cr5, cr0, {0}
GEN_CP15_REG_FUNCS(dfar, 0, c6, c0, 0);
  1013aa:	ee16 6f10 	mrc	15, 0, r6, cr6, cr0, {0}
    uint32_t fsr = arm_read_dfsr();
    uint32_t far = arm_read_dfar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1013ae:	f647 33b8 	movw	r3, #31672	; 0x7bb8
  1013b2:	f647 32d0 	movw	r2, #31696	; 0x7bd0
  1013b6:	f2c0 0311 	movt	r3, #17
  1013ba:	f2c0 0211 	movt	r2, #17
  1013be:	4293      	cmp	r3, r2
  1013c0:	d216      	bcs.n	1013f0 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1013c2:	6c47      	ldr	r7, [r0, #68]	; 0x44
  1013c4:	6819      	ldr	r1, [r3, #0]
  1013c6:	42b9      	cmp	r1, r7
  1013c8:	bf1f      	itttt	ne
  1013ca:	43dc      	mvnne	r4, r3
  1013cc:	18a4      	addne	r4, r4, r2
  1013ce:	f024 0407 	bicne.w	r4, r4, #7
  1013d2:	18e4      	addne	r4, r4, r3
  1013d4:	d00a      	beq.n	1013ec <arm_data_abort_handler+0x48>
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1013d6:	42a3      	cmp	r3, r4
  1013d8:	f103 0208 	add.w	r2, r3, #8
  1013dc:	d008      	beq.n	1013f0 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1013de:	6811      	ldr	r1, [r2, #0]
  1013e0:	4613      	mov	r3, r2
  1013e2:	42b9      	cmp	r1, r7
  1013e4:	d1f7      	bne.n	1013d6 <arm_data_abort_handler+0x32>
            frame->pc = fault_handler->fault_handler;
  1013e6:	6853      	ldr	r3, [r2, #4]
  1013e8:	6443      	str	r3, [r0, #68]	; 0x44

    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);

    exception_die(frame, "halting\n");
}
  1013ea:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1013ec:	461a      	mov	r2, r3
  1013ee:	e7fa      	b.n	1013e6 <arm_data_abort_handler+0x42>
  1013f0:	4604      	mov	r4, r0
    dprintf(CRITICAL, "\n\ncpu %u data abort, ", arch_curr_cpu_num());
  1013f2:	f647 40dc 	movw	r0, #31964	; 0x7cdc
  1013f6:	2100      	movs	r1, #0
  1013f8:	f2c0 0011 	movt	r0, #17
  1013fc:	f013 fa02 	bl	114804 <printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  101400:	09ab      	lsrs	r3, r5, #6
  101402:	f005 020f 	and.w	r2, r5, #15
  101406:	f003 0310 	and.w	r3, r3, #16
  10140a:	4313      	orrs	r3, r2
    switch (fault_status) {
  10140c:	3b01      	subs	r3, #1
    bool write = !!BIT(fsr, 11);
  10140e:	f405 6200 	and.w	r2, r5, #2048	; 0x800
    switch (fault_status) {
  101412:	2b15      	cmp	r3, #21
  101414:	d80c      	bhi.n	101430 <arm_data_abort_handler+0x8c>
  101416:	e8df f003 	tbb	[r15, r3]
  10141a:	8990      	.short	0x8990
  10141c:	77650b77 	.word	0x77650b77
  101420:	0b4a5365 	.word	0x0b4a5365
  101424:	0b380b4a 	.word	0x0b380b4a
  101428:	0b0b0b38 	.word	0x0b0b0b38
  10142c:	260b0b0b 	.word	0x260b0b0b
            dprintf(CRITICAL, "unhandled fault\n");
  101430:	f647 50cc 	movw	r0, #32204	; 0x7dcc
  101434:	f2c0 0011 	movt	r0, #17
  101438:	f013 f9cc 	bl	1147d4 <puts>
    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
  10143c:	f647 50dc 	movw	r0, #32220	; 0x7ddc
  101440:	4631      	mov	r1, r6
  101442:	f2c0 0011 	movt	r0, #17
  101446:	f013 f9dd 	bl	114804 <printf>
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);
  10144a:	f647 50f8 	movw	r0, #32248	; 0x7df8
  10144e:	4629      	mov	r1, r5
  101450:	f2c0 0011 	movt	r0, #17
  101454:	f013 f9d6 	bl	114804 <printf>
    exception_die(frame, "halting\n");
  101458:	f647 611c 	movw	r1, #32284	; 0x7e1c
  10145c:	4620      	mov	r0, r4
  10145e:	f2c0 0111 	movt	r1, #17
  101462:	f7ff fecd 	bl	101200 <exception_die>
            dprintf(CRITICAL, "asynchronous external abort on %s\n", write ? "write" : "read");
  101466:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  10146a:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  10146e:	f2c0 0311 	movt	r3, #17
  101472:	f647 50a8 	movw	r0, #32168	; 0x7da8
  101476:	f2c0 0111 	movt	r1, #17
  10147a:	f2c0 0011 	movt	r0, #17
  10147e:	2a00      	cmp	r2, #0
  101480:	bf08      	it	eq
  101482:	4619      	moveq	r1, r3
  101484:	f013 f9be 	bl	114804 <printf>
            break;
  101488:	e7d8      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "permission fault on %s\n", write ? "write" : "read");
  10148a:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  10148e:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  101492:	f2c0 0311 	movt	r3, #17
  101496:	f647 5060 	movw	r0, #32096	; 0x7d60
  10149a:	f2c0 0111 	movt	r1, #17
  10149e:	f2c0 0011 	movt	r0, #17
  1014a2:	2a00      	cmp	r2, #0
  1014a4:	bf08      	it	eq
  1014a6:	4619      	moveq	r1, r3
  1014a8:	f013 f9ac 	bl	114804 <printf>
            break;
  1014ac:	e7c6      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  1014ae:	f647 5044 	movw	r0, #32068	; 0x7d44
  1014b2:	f3c5 1103 	ubfx	r1, r5, #4, #4
  1014b6:	f2c0 0011 	movt	r0, #17
  1014ba:	f013 f9a3 	bl	114804 <printf>
            break;
  1014be:	e7bd      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "synchronous external abort on %s\n", write ? "write" : "read");
  1014c0:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  1014c4:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  1014c8:	f2c0 0311 	movt	r3, #17
  1014cc:	f647 5084 	movw	r0, #32132	; 0x7d84
  1014d0:	f2c0 0111 	movt	r1, #17
  1014d4:	f2c0 0011 	movt	r0, #17
  1014d8:	2a00      	cmp	r2, #0
  1014da:	bf08      	it	eq
  1014dc:	4619      	moveq	r1, r3
  1014de:	f013 f991 	bl	114804 <printf>
            break;
  1014e2:	e7ab      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "translation fault on %s\n", write ? "write" : "read");
  1014e4:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  1014e8:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  1014ec:	f2c0 0311 	movt	r3, #17
  1014f0:	f647 500c 	movw	r0, #32012	; 0x7d0c
  1014f4:	f2c0 0111 	movt	r1, #17
  1014f8:	f2c0 0011 	movt	r0, #17
  1014fc:	2a00      	cmp	r2, #0
  1014fe:	bf08      	it	eq
  101500:	4619      	moveq	r1, r3
  101502:	f013 f97f 	bl	114804 <printf>
            break;
  101506:	e799      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "access flag fault on %s\n", write ? "write" : "read");
  101508:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  10150c:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  101510:	f2c0 0311 	movt	r3, #17
  101514:	f647 5028 	movw	r0, #32040	; 0x7d28
  101518:	f2c0 0111 	movt	r1, #17
  10151c:	f2c0 0011 	movt	r0, #17
  101520:	2a00      	cmp	r2, #0
  101522:	bf08      	it	eq
  101524:	4619      	moveq	r1, r3
  101526:	f013 f96d 	bl	114804 <printf>
            break;
  10152a:	e787      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "debug event\n");
  10152c:	f647 5078 	movw	r0, #32120	; 0x7d78
  101530:	f2c0 0011 	movt	r0, #17
  101534:	f013 f94e 	bl	1147d4 <puts>
            break;
  101538:	e780      	b.n	10143c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "alignment fault on %s\n", write ? "write" : "read");
  10153a:	f647 41cc 	movw	r1, #31948	; 0x7ccc
  10153e:	f647 43d4 	movw	r3, #31956	; 0x7cd4
  101542:	f2c0 0311 	movt	r3, #17
  101546:	f647 40f4 	movw	r0, #31988	; 0x7cf4
  10154a:	f2c0 0111 	movt	r1, #17
  10154e:	f2c0 0011 	movt	r0, #17
  101552:	2a00      	cmp	r2, #0
  101554:	bf08      	it	eq
  101556:	4619      	moveq	r1, r3
  101558:	f013 f954 	bl	114804 <printf>
            break;
  10155c:	e76e      	b.n	10143c <arm_data_abort_handler+0x98>
  10155e:	bf00      	nop

00101560 <arm_prefetch_abort_handler>:

void arm_prefetch_abort_handler(struct arm_fault_frame *frame)
{
  101560:	b570      	push	{r4, r5, r6, r14}
  101562:	4605      	mov	r5, r0
GEN_CP15_REG_FUNCS(ifsr, 0, c5, c0, 1);
  101564:	ee15 4f30 	mrc	15, 0, r4, cr5, cr0, {1}
GEN_CP15_REG_FUNCS(ifar, 0, c6, c0, 2);
  101568:	ee16 6f50 	mrc	15, 0, r6, cr6, cr0, {2}
    uint32_t fsr = arm_read_ifsr();
    uint32_t far = arm_read_ifar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
  10156c:	f647 6028 	movw	r0, #32296	; 0x7e28
  101570:	2100      	movs	r1, #0
  101572:	f2c0 0011 	movt	r0, #17
  101576:	f013 f945 	bl	114804 <printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  10157a:	09a3      	lsrs	r3, r4, #6
  10157c:	f003 0310 	and.w	r3, r3, #16
  101580:	f004 020f 	and.w	r2, r4, #15
  101584:	4313      	orrs	r3, r2

    /* decode the fault status (from table B3-23) */
    switch (fault_status) {
  101586:	3b01      	subs	r3, #1
  101588:	2b15      	cmp	r3, #21
  10158a:	d85a      	bhi.n	101642 <arm_prefetch_abort_handler+0xe2>
  10158c:	e8df f003 	tbb	[r15, r3]
  101590:	59342d26 	.word	0x59342d26
  101594:	423b343b 	.word	0x423b343b
  101598:	59495949 	.word	0x59495949
  10159c:	59525952 	.word	0x59525952
  1015a0:	59595959 	.word	0x59595959
  1015a4:	0b59      	.short	0x0b59
            break;
        case 0x08: // synchronous external abort
            dprintf(CRITICAL, "synchronous external abort\n");
            break;
        case 0x16: // asynchronous external abort
            dprintf(CRITICAL, "asynchronous external abort\n");
  1015a6:	f647 60ac 	movw	r0, #32428	; 0x7eac
  1015aa:	f2c0 0011 	movt	r0, #17
  1015ae:	f013 f911 	bl	1147d4 <puts>
        default:
            dprintf(CRITICAL, "unhandled fault\n");
            ;
    }

    dprintf(CRITICAL, "IFAR 0x%x (fault address)\n", far);
  1015b2:	f647 60c8 	movw	r0, #32456	; 0x7ec8
  1015b6:	4631      	mov	r1, r6
  1015b8:	f2c0 0011 	movt	r0, #17
  1015bc:	f013 f922 	bl	114804 <printf>
    dprintf(CRITICAL, "IFSR 0x%x (fault status register)\n", fsr);
  1015c0:	f647 60e4 	movw	r0, #32484	; 0x7ee4
  1015c4:	4621      	mov	r1, r4
  1015c6:	f2c0 0011 	movt	r0, #17
  1015ca:	f013 f91b 	bl	114804 <printf>

    exception_die(frame, "halting\n");
  1015ce:	f647 611c 	movw	r1, #32284	; 0x7e1c
  1015d2:	4628      	mov	r0, r5
  1015d4:	f2c0 0111 	movt	r1, #17
  1015d8:	f7ff fe12 	bl	101200 <exception_die>
            dprintf(CRITICAL, "alignment fault\n");
  1015dc:	f647 6044 	movw	r0, #32324	; 0x7e44
  1015e0:	f2c0 0011 	movt	r0, #17
  1015e4:	f013 f8f6 	bl	1147d4 <puts>
            break;
  1015e8:	e7e3      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "debug event\n");
  1015ea:	f647 5078 	movw	r0, #32120	; 0x7d78
  1015ee:	f2c0 0011 	movt	r0, #17
  1015f2:	f013 f8ef 	bl	1147d4 <puts>
            break;
  1015f6:	e7dc      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "access flag fault\n");
  1015f8:	f647 6068 	movw	r0, #32360	; 0x7e68
  1015fc:	f2c0 0011 	movt	r0, #17
  101600:	f013 f8e8 	bl	1147d4 <puts>
            break;
  101604:	e7d5      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "translation fault\n");
  101606:	f647 6054 	movw	r0, #32340	; 0x7e54
  10160a:	f2c0 0011 	movt	r0, #17
  10160e:	f013 f8e1 	bl	1147d4 <puts>
            break;
  101612:	e7ce      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "synchronous external abort\n");
  101614:	f647 6090 	movw	r0, #32400	; 0x7e90
  101618:	f2c0 0011 	movt	r0, #17
  10161c:	f013 f8da 	bl	1147d4 <puts>
            break;
  101620:	e7c7      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  101622:	f647 5044 	movw	r0, #32068	; 0x7d44
  101626:	f3c4 1103 	ubfx	r1, r4, #4, #4
  10162a:	f2c0 0011 	movt	r0, #17
  10162e:	f013 f8e9 	bl	114804 <printf>
            break;
  101632:	e7be      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "permission fault\n");
  101634:	f647 607c 	movw	r0, #32380	; 0x7e7c
  101638:	f2c0 0011 	movt	r0, #17
  10163c:	f013 f8ca 	bl	1147d4 <puts>
            break;
  101640:	e7b7      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "unhandled fault\n");
  101642:	f647 50cc 	movw	r0, #32204	; 0x7dcc
  101646:	f2c0 0011 	movt	r0, #17
  10164a:	f013 f8c3 	bl	1147d4 <puts>
  10164e:	e7b0      	b.n	1015b2 <arm_prefetch_abort_handler+0x52>

00101650 <arm_fpu_set_enable>:
}

void arm_fpu_set_enable(bool enable)
{
    /* set enable bit in fpexc */
    write_fpexc(enable ? (1<<30) : 0);
  101650:	2800      	cmp	r0, #0
  101652:	bf14      	ite	ne
  101654:	f04f 4380 	movne.w	r3, #1073741824	; 0x40000000
  101658:	2300      	moveq	r3, #0
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  10165a:	eee8 3a10 	vmsr	fpexc, r3
}
  10165e:	4770      	bx	r14

00101660 <arm_fpu_undefined_instruction>:

#if ARM_WITH_VFP
void arm_fpu_undefined_instruction(struct arm_iframe *frame)
{
  101660:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  101662:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  101664:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    return (ipsr & IPSR_ISR_Msk);
#else
    /* set by the interrupt glue to track that the cpu is inside a handler */
    extern bool __arm_in_handler;

    return __arm_in_handler;
  101668:	f24f 54c8 	movw	r4, #62920	; 0xf5c8
  10166c:	f2c0 0411 	movt	r4, #17
    thread_t *t = get_current_thread();

    if (unlikely(arch_in_int_handler())) {
  101670:	7823      	ldrb	r3, [r4, #0]
  101672:	b9b3      	cbnz	r3, 1016a2 <arm_fpu_undefined_instruction+0x42>
    }
false_alarm:

    LTRACEF("enabling fpu on thread %p\n", t);

    t->arch.fpused = true;
  101674:	2301      	movs	r3, #1
  101676:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

            arm_fpu_set_enable(false);
        }
    }

    if (newthread) {
  10167a:	b16d      	cbz	r5, 101698 <arm_fpu_undefined_instruction+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  10167c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  101680:	eee8 3a10 	vmsr	fpexc, r3
        if (newthread->arch.fpused) {
            // load the new state
            arm_fpu_set_enable(true);
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
  101684:	6bab      	ldr	r3, [r5, #56]	; 0x38
  101686:	eee1 3a10 	vmsr	fpscr, r3

            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
  10168a:	f105 0340 	add.w	r3, r5, #64	; 0x40
  10168e:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  101692:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  101694:	eee8 3a10 	vmsr	fpexc, r3
    frame->fpexc |= (1<<30);
  101698:	6833      	ldr	r3, [r6, #0]
  10169a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  10169e:	6033      	str	r3, [r6, #0]
}
  1016a0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "floating point code while some cpu is in irq context. pc 0x%x\n", frame->pc);
  1016a2:	f248 0080 	movw	r0, #32896	; 0x8080
  1016a6:	4677      	mov	r7, r14
  1016a8:	6a71      	ldr	r1, [r6, #36]	; 0x24
  1016aa:	f2c0 0011 	movt	r0, #17
  1016ae:	f013 f8a9 	bl	114804 <printf>
        for (i = 0; i < 1000; i++) {
  1016b2:	2100      	movs	r1, #0
  1016b4:	7823      	ldrb	r3, [r4, #0]
            if (!arch_in_int_handler()) {
  1016b6:	b15b      	cbz	r3, 1016d0 <arm_fpu_undefined_instruction+0x70>
        for (i = 0; i < 1000; i++) {
  1016b8:	3101      	adds	r1, #1
  1016ba:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
  1016be:	d1fa      	bne.n	1016b6 <arm_fpu_undefined_instruction+0x56>
        panic("floating point code in irq context. pc 0x%x\n", frame->pc);
  1016c0:	f248 01f4 	movw	r1, #33012	; 0x80f4
  1016c4:	4638      	mov	r0, r7
  1016c6:	6a72      	ldr	r2, [r6, #36]	; 0x24
  1016c8:	f2c0 0111 	movt	r1, #17
  1016cc:	f012 f866 	bl	11379c <_panic>
                dprintf(CRITICAL, "arch_in_int_handler status cleared after %d reads\n", i);
  1016d0:	f248 00c0 	movw	r0, #32960	; 0x80c0
  1016d4:	f2c0 0011 	movt	r0, #17
  1016d8:	f013 f894 	bl	114804 <printf>
                goto false_alarm;
  1016dc:	e7ca      	b.n	101674 <arm_fpu_undefined_instruction+0x14>
  1016de:	bf00      	nop

001016e0 <mpu_add_region>:
    return false;
}
#endif
void mpu_add_region(int region, uint32_t base, uint64_t size,
                    mpu_region_type_e type)
{
  1016e0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1016e4:	b083      	sub	sp, #12
  1016e6:	46f3      	mov	r11, r14
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016e8:	f1b0 0a00 	subs.w	r10, r0, #0
{
  1016ec:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016ee:	db4d      	blt.n	10178c <mpu_add_region+0xac>
  1016f0:	460f      	mov	r7, r1

GEN_CP15_REG_FUNCS(l2ctlr, 1, c9, c0, 2);
GEN_CP15_REG_FUNCS(l2ectlr, 1, c9, c0, 3);

/* mpu registers (using unified memory regions) */
GEN_CP15_REG_FUNCS(mpuir, 0, c0, c0, 4);
  1016f2:	ee10 1f90 	mrc	15, 0, r1, cr0, cr0, {4}
    return (int)BITS_SHIFT(val, 15, 8);   /* 0, 12 or 16 */
  1016f6:	f3c1 2107 	ubfx	r1, r1, #8, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016fa:	458a      	cmp	r10, r1
  1016fc:	da46      	bge.n	10178c <mpu_add_region+0xac>
  1016fe:	4614      	mov	r4, r2
    ASSERT((size & (size - 1)) == 0 &&
  101700:	f112 38ff 	adds.w	r8, r2, #4294967295	; 0xffffffff
  101704:	f143 39ff 	adc.w	r9, r3, #4294967295	; 0xffffffff
  101708:	ea08 0002 	and.w	r0, r8, r2
  10170c:	461d      	mov	r5, r3
  10170e:	ea09 0103 	and.w	r1, r9, r3
  101712:	4301      	orrs	r1, r0
  101714:	d14b      	bne.n	1017ae <mpu_add_region+0xce>
  101716:	f04f 0900 	mov.w	r9, #0
  10171a:	f1b2 0020 	subs.w	r0, r2, #32
  10171e:	f143 31ff 	adc.w	r1, r3, #4294967295	; 0xffffffff
  101722:	f06f 081f 	mvn.w	r8, #31
  101726:	4589      	cmp	r9, r1
  101728:	bf08      	it	eq
  10172a:	4580      	cmpeq	r8, r0
  10172c:	d33f      	bcc.n	1017ae <mpu_add_region+0xce>
           size >= 32ull &&
           size <= 4ull * 1024 * 1024 * 1024);
    ASSERT(base % size == 0);
  10172e:	4638      	mov	r0, r7
  101730:	2100      	movs	r1, #0
  101732:	f016 f97b 	bl	117a2c <__aeabi_uldivmod>
  101736:	4313      	orrs	r3, r2
  101738:	d14a      	bne.n	1017d0 <mpu_add_region+0xf0>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  10173a:	2e05      	cmp	r6, #5
  10173c:	d859      	bhi.n	1017f2 <mpu_add_region+0x112>
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
  10173e:	fab5 f385 	clz	r3, r5
  101742:	b1fd      	cbz	r5, 101784 <mpu_add_region+0xa4>
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
GEN_CP15_REG_FUNCS(rgnr, 0, c6, c2, 0);
  101744:	ee06 af12 	mcr	15, 0, r10, cr6, cr2, {0}
  101748:	f3bf 8f6f 	isb	sy
    /* Calculate size field of RSR register.
     *  pow(2, sz + 1) = size
     */
    uint32_t sz = (uint32_t)log2ull(size) - 1;
    arm_write_rgnr(region);
    arm_write_rbar(base & MPU_RBAR_MASK);
  10174c:	f027 071f 	bic.w	r7, r7, #31
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
  101750:	ee06 7f11 	mcr	15, 0, r7, cr6, cr1, {0}
  101754:	f3bf 8f6f 	isb	sy
    arm_write_racr(g_racr_config[type]);
  101758:	f248 1224 	movw	r2, #33060	; 0x8124
  10175c:	f2c0 0211 	movt	r2, #17
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
  101760:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
  101764:	ee06 2f91 	mcr	15, 0, r2, cr6, cr1, {4}
  101768:	f3bf 8f6f 	isb	sy
    uint32_t sz = (uint32_t)log2ull(size) - 1;
  10176c:	f1c3 033e 	rsb	r3, r3, #62	; 0x3e
    /* TODO - support sub regions? */
    arm_write_rsr((sz << RSR_SIZE_SHIFT) | RSR_EN);
  101770:	005b      	lsls	r3, r3, #1
  101772:	f043 0301 	orr.w	r3, r3, #1
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
  101776:	ee06 3f51 	mcr	15, 0, r3, cr6, cr1, {2}
  10177a:	f3bf 8f6f 	isb	sy
    if (type != MPU_REGION_NORMAL) {
        add_region(base, size);
    }

#endif
}
  10177e:	b003      	add	sp, #12
  101780:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
  101784:	fab4 f384 	clz	r3, r4
  101788:	3320      	adds	r3, #32
  10178a:	e7db      	b.n	101744 <mpu_add_region+0x64>
    ASSERT(region >= 0 && region < mpu_region_nr());
  10178c:	f248 1350 	movw	r3, #33104	; 0x8150
  101790:	f248 123c 	movw	r2, #33084	; 0x813c
  101794:	f647 4134 	movw	r1, #31796	; 0x7c34
  101798:	f2c0 0311 	movt	r3, #17
  10179c:	4658      	mov	r0, r11
  10179e:	f2c0 0211 	movt	r2, #17
  1017a2:	9300      	str	r3, [sp, #0]
  1017a4:	f2c0 0111 	movt	r1, #17
  1017a8:	239c      	movs	r3, #156	; 0x9c
  1017aa:	f011 fff7 	bl	11379c <_panic>
    ASSERT((size & (size - 1)) == 0 &&
  1017ae:	f248 1378 	movw	r3, #33144	; 0x8178
  1017b2:	f248 123c 	movw	r2, #33084	; 0x813c
  1017b6:	f647 4134 	movw	r1, #31796	; 0x7c34
  1017ba:	f2c0 0311 	movt	r3, #17
  1017be:	4658      	mov	r0, r11
  1017c0:	f2c0 0211 	movt	r2, #17
  1017c4:	9300      	str	r3, [sp, #0]
  1017c6:	f2c0 0111 	movt	r1, #17
  1017ca:	239f      	movs	r3, #159	; 0x9f
  1017cc:	f011 ffe6 	bl	11379c <_panic>
    ASSERT(base % size == 0);
  1017d0:	f248 13c8 	movw	r3, #33224	; 0x81c8
  1017d4:	f248 123c 	movw	r2, #33084	; 0x813c
  1017d8:	f647 4134 	movw	r1, #31796	; 0x7c34
  1017dc:	f2c0 0311 	movt	r3, #17
  1017e0:	4658      	mov	r0, r11
  1017e2:	f2c0 0211 	movt	r2, #17
  1017e6:	9300      	str	r3, [sp, #0]
  1017e8:	f2c0 0111 	movt	r1, #17
  1017ec:	23a0      	movs	r3, #160	; 0xa0
  1017ee:	f011 ffd5 	bl	11379c <_panic>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  1017f2:	f248 13dc 	movw	r3, #33244	; 0x81dc
  1017f6:	f248 123c 	movw	r2, #33084	; 0x813c
  1017fa:	f647 4134 	movw	r1, #31796	; 0x7c34
  1017fe:	f2c0 0311 	movt	r3, #17
  101802:	4658      	mov	r0, r11
  101804:	f2c0 0211 	movt	r2, #17
  101808:	9300      	str	r3, [sp, #0]
  10180a:	f2c0 0111 	movt	r1, #17
  10180e:	23a1      	movs	r3, #161	; 0xa1
  101810:	f011 ffc4 	bl	11379c <_panic>

00101814 <mpu_enable>:
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
  101814:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
 */
void mpu_enable(bool enable)
{
    uint32_t val = arm_read_sctlr();

    if (enable)
  101818:	b930      	cbnz	r0, 101828 <mpu_enable+0x14>
         */
    {
        val |= SCTLR_BR | SCTLR_M;
    }
    else {
        val &= ~SCTLR_M;
  10181a:	f023 0301 	bic.w	r3, r3, #1
  10181e:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  101822:	f3bf 8f6f 	isb	sy
    }

    arm_write_sctlr(val);
}
  101826:	4770      	bx	r14
        val |= SCTLR_BR | SCTLR_M;
  101828:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  10182c:	f043 0301 	orr.w	r3, r3, #1
  101830:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  101834:	f3bf 8f6f 	isb	sy
}
  101838:	4770      	bx	r14
  10183a:	bf00      	nop

0010183c <arch_clean_cache_range>:
        if(!aligncheck(start, len)) \
            panic("ASSERT FAILED at aligncheck in %s (%p:%d, caller %p)\n", __func__, (void*)start, len, __GET_CALLER());   \
        _f##_asm(start, len);   \
    }

CACHE_OPS(arch_clean_cache_range)
  10183c:	eafffca5 	b	100ad8 <arch_clean_cache_range_asm>

00101840 <arch_clean_invalidate_cache_range>:
CACHE_OPS(arch_clean_invalidate_cache_range)
  101840:	eafffcad 	b	100afc <arch_clean_invalidate_cache_range_asm>

00101844 <arch_invalidate_cache_range>:
CACHE_OPS(arch_invalidate_cache_range)
  101844:	eafffcb5 	b	100b20 <arch_invalidate_cache_range_asm>

00101848 <arch_early_init>:
CACHE_OPS(arch_sync_cache_range)

void arch_early_init(void)
{
  101848:	e92d4010 	push	{r4, r14}
    /* turn off the cache */
    arch_disable_cache(UCACHE);
  10184c:	e3a00003 	mov	r0, #3
  101850:	ebfffc28 	bl	1008f8 <arch_disable_cache>
  101854:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
    sctlr |= (1 << 11); /* enable program flow prediction */
    sctlr &= ~(1 << 14); /* random cache/tlb replacement */
    sctlr &= ~(1 << 25); /* E bit set to 0 on exception */
    sctlr &= ~(1 << 30); /* no thumb exceptions */
    sctlr |= (1 << 22); /* enable unaligned access */
    sctlr &= ~(1 << 1); /* disable alignment abort */
  101858:	e30b3bfd 	movw	r3, #48125	; 0xbbfd
  10185c:	e34b3dff 	movt	r3, #48639	; 0xbdff
  101860:	e0033002 	and	r3, r3, r2
  101864:	e3833501 	orr	r3, r3, #4194304	; 0x400000
  101868:	e3833b02 	orr	r3, r3, #2048	; 0x800
  10186c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
  101870:	f57ff06f 	isb	sy
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  101874:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
  101878:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
  10187c:	f57ff06f 	isb	sy
#endif // ARM_CPU_CORTEX_A7
    arm_write_actlr(actlr);
#if ENABLE_CYCLE_COUNTER && ARM_ISA_ARMV7
    /* enable the cycle count register */
    uint32_t en;
    __asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r"(en));
  101880:	ee193f1c 	mrc	15, 0, r3, cr9, cr12, {0}
    en &= ~(1 << 3); /* cycle count every cycle */
  101884:	e3c33008 	bic	r3, r3, #8
    en |= 1; /* enable all performance counters */
  101888:	e3833001 	orr	r3, r3, #1
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r"(en));
  10188c:	ee093f1c 	mcr	15, 0, r3, cr9, cr12, {0}
    /* enable cycle counter */
    en = (1 << 31);
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r"(en));
  101890:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  101894:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
GEN_CP15_REG_FUNCS(cpacr, 0, c1, c0, 2);
  101898:	ee113f50 	mrc	15, 0, r3, cr1, cr0, {2}
#endif
#if ARM_WITH_VFP
    /* enable cp10 and cp11 */
    uint32_t val = arm_read_cpacr();
    val |= (3 << 22) | (3 << 20);
  10189c:	e383360f 	orr	r3, r3, #15728640	; 0xf00000
  1018a0:	ee013f50 	mcr	15, 0, r3, cr1, cr0, {2}
  1018a4:	f57ff06f 	isb	sy
    arm_write_cpacr(val);
    /* set enable bit in fpexc */
    __asm__ volatile("mrc  p10, 7, %0, c8, c0, 0" : "=r"(val));
  1018a8:	eef83a10 	vmrs	r3, fpexc
    val |= (1 << 30);
  1018ac:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r"(val));
  1018b0:	eee83a10 	vmsr	fpexc, r3
    /* make sure the fpu starts off disabled */
    arm_fpu_set_enable(false);
  1018b4:	e3a00000 	mov	r0, #0
  1018b8:	faffff64 	blx	101650 <arm_fpu_set_enable>
    arch_enable_cache(UCACHE);
  1018bc:	e3a00003 	mov	r0, #3
}
  1018c0:	e8bd4010 	pop	{r4, r14}
    arch_enable_cache(UCACHE);
  1018c4:	eafffc22 	b	100954 <arch_enable_cache>

001018c8 <arch_init>:
}
  1018c8:	e12fff1e 	bx	r14

001018cc <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
  1018cc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1018d0:	b083      	sub	sp, #12
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
  1018d2:	2900      	cmp	r1, #0
  1018d4:	d051      	beq.n	10197a <lk_init_level+0xae>
  1018d6:	f24f 5858 	movw	r8, #62808	; 0xf558
  1018da:	f24f 56b8 	movw	r6, #62904	; 0xf5b8
  1018de:	f2c0 0811 	movt	r8, #17
  1018e2:	4691      	mov	r9, r2
  1018e4:	f2c0 0611 	movt	r6, #17
  1018e8:	4683      	mov	r11, r0
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  1018ea:	45b0      	cmp	r8, r6
  1018ec:	468a      	mov	r10, r1
    uint last_called_level = start_level - 1;
  1018ee:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    const struct lk_init_struct *last = NULL;
  1018f2:	f04f 0500 	mov.w	r5, #0
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  1018f6:	d03b      	beq.n	101970 <lk_init_level+0xa4>
  1018f8:	f24f 5358 	movw	r3, #62808	; 0xf558
        bool seen_last = false;
  1018fc:	2400      	movs	r4, #0
        const struct lk_init_struct *found = NULL;
  1018fe:	4621      	mov	r1, r4
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  101900:	f2c0 0311 	movt	r3, #17
  101904:	e002      	b.n	10190c <lk_init_level+0x40>
  101906:	3310      	adds	r3, #16
  101908:	42b3      	cmp	r3, r6
  10190a:	d029      	beq.n	101960 <lk_init_level+0x94>

            if (ptr == last)
                seen_last = true;

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
  10190c:	6858      	ldr	r0, [r3, #4]
                seen_last = true;
  10190e:	429d      	cmp	r5, r3
  101910:	bf08      	it	eq
  101912:	2401      	moveq	r4, #1
            if (!(ptr->flags & required_flag))
  101914:	ea1b 0f00 	tst.w	r11, r0
  101918:	d0f5      	beq.n	101906 <lk_init_level+0x3a>
                continue;
            if (ptr->level > stop_level)
  10191a:	6818      	ldr	r0, [r3, #0]
                continue;
            if (ptr->level < last_called_level)
  10191c:	4548      	cmp	r0, r9
  10191e:	bf98      	it	ls
  101920:	4282      	cmpls	r2, r0
  101922:	d8f0      	bhi.n	101906 <lk_init_level+0x3a>
                continue;
            if (found && found->level <= ptr->level)
  101924:	b111      	cbz	r1, 10192c <lk_init_level+0x60>
  101926:	680f      	ldr	r7, [r1, #0]
  101928:	42b8      	cmp	r0, r7
  10192a:	d2ec      	bcs.n	101906 <lk_init_level+0x3a>
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
  10192c:	4282      	cmp	r2, r0
  10192e:	bf34      	ite	cc
  101930:	f04f 0c01 	movcc.w	r12, #1
  101934:	f04f 0c00 	movcs.w	r12, #0
  101938:	4550      	cmp	r0, r10
  10193a:	bf38      	it	cc
  10193c:	f04f 0c00 	movcc.w	r12, #0
  101940:	f1bc 0f00 	cmp.w	r12, #0
  101944:	d117      	bne.n	101976 <lk_init_level+0xaa>

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
  101946:	4282      	cmp	r2, r0
  101948:	d1dd      	bne.n	101906 <lk_init_level+0x3a>
  10194a:	429d      	cmp	r5, r3
  10194c:	bf0c      	ite	eq
  10194e:	f04f 0c00 	moveq.w	r12, #0
  101952:	f004 0c01 	andne.w	r12, r4, #1
  101956:	f1bc 0f00 	cmp.w	r12, #0
  10195a:	d0d4      	beq.n	101906 <lk_init_level+0x3a>
  10195c:	461d      	mov	r5, r3
  10195e:	e002      	b.n	101966 <lk_init_level+0x9a>
                found = ptr;
                break;
            }
        }

        if (!found)
  101960:	b131      	cbz	r1, 101970 <lk_init_level+0xa4>
  101962:	6808      	ldr	r0, [r1, #0]
  101964:	460d      	mov	r5, r1
        if (found->level >= EARLIEST_TRACE_LEVEL && (required_flag & TRACE_INIT_FLAGS)) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
  101966:	68ab      	ldr	r3, [r5, #8]
  101968:	4798      	blx	r3
        last_called_level = found->level;
  10196a:	682a      	ldr	r2, [r5, #0]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  10196c:	45b0      	cmp	r8, r6
  10196e:	d1c3      	bne.n	1018f8 <lk_init_level+0x2c>
        last = found;
    }
}
  101970:	b003      	add	sp, #12
  101972:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  101976:	4619      	mov	r1, r3
  101978:	e7c5      	b.n	101906 <lk_init_level+0x3a>
    ASSERT(start_level > 0);
  10197a:	f248 2324 	movw	r3, #33316	; 0x8224
  10197e:	f248 2218 	movw	r2, #33304	; 0x8218
  101982:	f647 4134 	movw	r1, #31796	; 0x7c34
  101986:	f2c0 0311 	movt	r3, #17
  10198a:	4670      	mov	r0, r14
  10198c:	f2c0 0211 	movt	r2, #17
  101990:	9300      	str	r3, [sp, #0]
  101992:	f2c0 0111 	movt	r1, #17
  101996:	2334      	movs	r3, #52	; 0x34
  101998:	f011 ff00 	bl	11379c <_panic>

0010199c <lk_main>:

/* called from arch code */
void lk_main(ulong arg0, ulong arg1, ulong arg2, ulong arg3)
{
    // save the boot args
    lk_boot_args[0] = arg0;
  10199c:	f64d 74c0 	movw	r4, #57280	; 0xdfc0
  1019a0:	f2c0 0412 	movt	r4, #18
{
  1019a4:	b500      	push	{r14}
    lk_boot_args[1] = arg1;
  1019a6:	6061      	str	r1, [r4, #4]

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level)
{
    lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
  1019a8:	2101      	movs	r1, #1
    lk_boot_args[0] = arg0;
  1019aa:	6020      	str	r0, [r4, #0]
{
  1019ac:	b083      	sub	sp, #12
    lk_boot_args[2] = arg2;
  1019ae:	60a2      	str	r2, [r4, #8]
  1019b0:	4608      	mov	r0, r1
    lk_boot_args[3] = arg3;
  1019b2:	60e3      	str	r3, [r4, #12]
  1019b4:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019b8:	f7ff ff88 	bl	1018cc <lk_init_level>

    // early arch stuff
    lk_primary_cpu_init_level(LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_ARCH_EARLY - 1);
    arch_early_init();
  1019bc:	f7ff ef44 	blx	101848 <arch_early_init>
  1019c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019c4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  1019c8:	2001      	movs	r0, #1
  1019ca:	f2c0 0201 	movt	r2, #1
  1019ce:	f7ff ff7d 	bl	1018cc <lk_init_level>

    // do any super early platform initialization
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH_EARLY, LK_INIT_LEVEL_PLATFORM_EARLY - 1);
    platform_early_init();
  1019d2:	f7fe fce3 	bl	10039c <platform_early_init>
  1019d6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019da:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  1019de:	2001      	movs	r0, #1
  1019e0:	f2c0 0202 	movt	r2, #2
  1019e4:	f7ff ff72 	bl	1018cc <lk_init_level>

    // do any super early target initialization
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_LEVEL_TARGET_EARLY - 1);
    target_early_init();
  1019e8:	f7fe fbd6 	bl	100198 <target_early_init>
  1019ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019f0:	f44f 3140 	mov.w	r1, #196608	; 0x30000
  1019f4:	2001      	movs	r0, #1
  1019f6:	f2c0 0203 	movt	r2, #3
  1019fa:	f7ff ff67 	bl	1018cc <lk_init_level>
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  1019fe:	f64c 3268 	movw	r2, #52072	; 0xcb68
  101a02:	f64c 3368 	movw	r3, #52072	; 0xcb68
  101a06:	f2c0 0212 	movt	r2, #18
  101a0a:	f2c0 0312 	movt	r3, #18
  101a0e:	429a      	cmp	r2, r3
  101a10:	d00b      	beq.n	101a2a <lk_main+0x8e>
  101a12:	4615      	mov	r5, r2
  101a14:	1d14      	adds	r4, r2, #4
  101a16:	1b1c      	subs	r4, r3, r4
  101a18:	f024 0403 	bic.w	r4, r4, #3
  101a1c:	3404      	adds	r4, #4
  101a1e:	4414      	add	r4, r2
        (*ctor)();
  101a20:	f855 3b04 	ldr.w	r3, [r5], #4
  101a24:	4798      	blx	r3
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  101a26:	42a5      	cmp	r5, r4
  101a28:	d1fa      	bne.n	101a20 <lk_main+0x84>
  101a2a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a2e:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  101a32:	2001      	movs	r0, #1
  101a34:	f2c0 0205 	movt	r2, #5
  101a38:	f7ff ff48 	bl	1018cc <lk_init_level>
  101a3c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a40:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
  101a44:	f2c0 0206 	movt	r2, #6
  101a48:	2001      	movs	r0, #1
  101a4a:	f7ff ff3f 	bl	1018cc <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_KERNEL, LK_INIT_LEVEL_THREADING - 1);

    // create a thread to complete system initialization
    dprintf(SPEW, "creating bootstrap completion thread\n");
    thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
  101a4e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  101a52:	f641 2181 	movw	r1, #6785	; 0x1a81
  101a56:	f248 2034 	movw	r0, #33332	; 0x8234
  101a5a:	2200      	movs	r2, #0
  101a5c:	f2c0 0110 	movt	r1, #16
  101a60:	9300      	str	r3, [sp, #0]
  101a62:	f2c0 0011 	movt	r0, #17
  101a66:	2310      	movs	r3, #16
  101a68:	f014 fdfc 	bl	116664 <thread_create>
  101a6c:	4604      	mov	r4, r0
    thread_set_pinned_cpu(t, 0);
    thread_detach(t);
  101a6e:	f014 feb3 	bl	1167d8 <thread_detach>
    thread_resume(t);
  101a72:	4620      	mov	r0, r4
  101a74:	f014 fe86 	bl	116784 <thread_resume>
    vTaskStartScheduler();
  101a78:	f010 ffdc 	bl	112a34 <vTaskStartScheduler>
  101a7c:	e7fe      	b.n	101a7c <lk_main+0xe0>
  101a7e:	bf00      	nop

00101a80 <bootstrap2>:
  101a80:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a84:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
    // become the idle thread and enable interrupts to start the scheduler
    thread_become_idle();
}

static int bootstrap2(void *arg)
{
  101a88:	b508      	push	{r3, r14}
  101a8a:	2001      	movs	r0, #1
  101a8c:	f2c0 0207 	movt	r2, #7
  101a90:	f7ff ff1c 	bl	1018cc <lk_init_level>
    dprintf(SPEW, "top of bootstrap2()\n");

    lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
    arch_init();
  101a94:	f7ff ef18 	blx	1018c8 <arch_init>
  101a98:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a9c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  101aa0:	2001      	movs	r0, #1
  101aa2:	f2c0 0208 	movt	r2, #8
  101aa6:	f7ff ff11 	bl	1018cc <lk_init_level>

    // initialize the rest of the platform
    dprintf(SPEW, "initializing platform\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
    platform_init();
  101aaa:	f7fe fd07 	bl	1004bc <platform_init>
  101aae:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101ab2:	f44f 2110 	mov.w	r1, #589824	; 0x90000
  101ab6:	2001      	movs	r0, #1
  101ab8:	f2c0 0209 	movt	r2, #9
  101abc:	f7ff ff06 	bl	1018cc <lk_init_level>

    // initialize the target
    dprintf(SPEW, "initializing target\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
    target_init();
  101ac0:	f7fe fb6c 	bl	10019c <target_init>
  101ac4:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101ac8:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
  101acc:	2001      	movs	r0, #1
  101ace:	f2c0 020a 	movt	r2, #10
  101ad2:	f7ff fefb 	bl	1018cc <lk_init_level>

    dprintf(SPEW, "calling apps_init()\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
    apps_init();
  101ad6:	f011 fdff 	bl	1136d8 <apps_init>
  101ada:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  101ade:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
  101ae2:	2001      	movs	r0, #1
  101ae4:	f7ff fef2 	bl	1018cc <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

    return 0;
}
  101ae8:	2000      	movs	r0, #0
  101aea:	bd08      	pop	{r3, r15}

00101aec <setup_pll>:
    sdrpc_notify_msg(NULL, COM_HANDOVER_STATUS, NULL);
#endif
}

static void setup_pll(uint32_t resid)
{
  101aec:	b538      	push	{r3, r4, r5, r14}
  101aee:	4605      	mov	r5, r0
    pll_handle_t pll;
    pll =  hal_pll_create_handle(resid);
  101af0:	f00d ffea 	bl	10fac8 <hal_pll_create_handle>

    //ASSERT(pll);
    if (pll == (pll_handle_t)0) {
  101af4:	b140      	cbz	r0, 101b08 <setup_pll+0x1c>
  101af6:	4604      	mov	r4, r0
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
        return;
    }

    hal_pll_config(pll, NULL);
  101af8:	2100      	movs	r1, #0
  101afa:	f00e f807 	bl	10fb0c <hal_pll_config>
    hal_pll_delete_handle(pll);
  101afe:	4620      	mov	r0, r4
}
  101b00:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    hal_pll_delete_handle(pll);
  101b04:	f00e b800 	b.w	10fb08 <hal_pll_delete_handle>
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
  101b08:	f248 30a4 	movw	r0, #33700	; 0x83a4
  101b0c:	4629      	mov	r1, r5
  101b0e:	f2c0 0011 	movt	r0, #17
}
  101b12:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
  101b16:	f012 be75 	b.w	114804 <printf>
  101b1a:	bf00      	nop

00101b1c <setup_pll>:

    hal_clock_release_handle(g_sec_handle);
}

static void setup_pll(uint32_t resid)
{
  101b1c:	b510      	push	{r4, r14}
    pll_handle_t pll;
    pll =  hal_pll_create_handle(resid);
  101b1e:	f00d ffd3 	bl	10fac8 <hal_pll_create_handle>

    if (pll == (pll_handle_t)0) {
  101b22:	b900      	cbnz	r0, 101b26 <setup_pll+0xa>
        return;
    }

    hal_pll_config(pll, NULL);
    hal_pll_delete_handle(pll);
}
  101b24:	bd10      	pop	{r4, r15}
  101b26:	4604      	mov	r4, r0
    hal_pll_config(pll, NULL);
  101b28:	2100      	movs	r1, #0
  101b2a:	f00d ffef 	bl	10fb0c <hal_pll_config>
    hal_pll_delete_handle(pll);
  101b2e:	4620      	mov	r0, r4
}
  101b30:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_pll_delete_handle(pll);
  101b34:	f00d bfe8 	b.w	10fb08 <hal_pll_delete_handle>

00101b38 <safety_init>:
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101b38:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    spi_nor_reset_slave(ospic_reg);
}
#endif

static void safety_init(uint32_t level)
{
  101b3c:	b5f0      	push	{r4, r5, r6, r7, r14}
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101b3e:	f6cf 4224 	movt	r2, #64548	; 0xfc24
{
  101b42:	b083      	sub	sp, #12
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101b44:	6813      	ldr	r3, [r2, #0]
  101b46:	011b      	lsls	r3, r3, #4
  101b48:	d5fc      	bpl.n	101b44 <safety_init+0xc>
    setup_pll(RES_PLL_PLL2);
  101b4a:	f242 0026 	movw	r0, #8230	; 0x2026
  101b4e:	f2c4 002e 	movt	r0, #16430	; 0x402e
  101b52:	f7ff ffcb 	bl	101aec <setup_pll>
    hal_saf_clock_set_default();
  101b56:	f008 fdb3 	bl	10a6c0 <hal_saf_clock_set_default>
    setup_pll(RES_PLL_PLL1);
  101b5a:	f241 0025 	movw	r0, #4133	; 0x1025
  101b5e:	f2c4 002e 	movt	r0, #16430	; 0x402e
  101b62:	f7ff ffc3 	bl	101aec <setup_pll>
    ret = hal_clock_creat_handle(&handle);
  101b66:	a801      	add	r0, sp, #4
  101b68:	f008 fce2 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  101b6c:	2800      	cmp	r0, #0
  101b6e:	d07d      	beq.n	101c6c <safety_init+0x134>
  101b70:	4c42      	ldr	r4, [pc, #264]	; (101c7c <safety_init+0x144>)
  101b72:	f44f 759c 	mov.w	r5, #312	; 0x138
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101b76:	f248 3778 	movw	r7, #33656	; 0x8378
    if (!ret) {
  101b7a:	f2c8 259a 	movt	r5, #33434	; 0x829a
  101b7e:	f104 0638 	add.w	r6, r4, #56	; 0x38
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101b82:	f2c0 0711 	movt	r7, #17
  101b86:	e003      	b.n	101b90 <safety_init+0x58>
    for (uint32_t i = 0;
  101b88:	42b4      	cmp	r4, r6
  101b8a:	d00d      	beq.n	101ba8 <safety_init+0x70>
  101b8c:	f854 5b04 	ldr.w	r5, [r4], #4
        ret = hal_clock_enable(handle, default_clk_gating_enabled_table[i]);
  101b90:	9801      	ldr	r0, [sp, #4]
  101b92:	4629      	mov	r1, r5
  101b94:	f008 ff68 	bl	10aa68 <hal_clock_enable>
        if (!ret) {
  101b98:	2800      	cmp	r0, #0
  101b9a:	d1f5      	bne.n	101b88 <safety_init+0x50>
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101b9c:	4629      	mov	r1, r5
  101b9e:	4638      	mov	r0, r7
  101ba0:	f012 fe30 	bl	114804 <printf>
    for (uint32_t i = 0;
  101ba4:	42b4      	cmp	r4, r6
  101ba6:	d1f1      	bne.n	101b8c <safety_init+0x54>
    hal_clock_release_handle(handle);
  101ba8:	9801      	ldr	r0, [sp, #4]
  101baa:	f008 fcdd 	bl	10a568 <hal_clock_release_handle>
    RMWREG32(_ioaddr(APB_SCR_SAF_BASE + (0x610 << 10)), 3, 3, 1);
  101bae:	f44f 4180 	mov.w	r1, #16384	; 0x4000
#endif
    /* before this line should not invoke
     * ANY OS API.
    */
    /* enable tsgen */
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101bb2:	2200      	movs	r2, #0
    RMWREG32(_ioaddr(APB_SCR_SAF_BASE + (0x610 << 10)), 3, 3, 1);
  101bb4:	f6cf 4138 	movt	r1, #64568	; 0xfc38
  101bb8:	f248 247c 	movw	r4, #33404	; 0x827c
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101bbc:	f2cf 1241 	movt	r2, #61761	; 0xf141
    int32_t idx = 0;
  101bc0:	f240 404a 	movw	r0, #1098	; 0x44a
  101bc4:	f2c0 0411 	movt	r4, #17
    RMWREG32(_ioaddr(APB_SCR_SAF_BASE + (0x610 << 10)), 3, 3, 1);
  101bc8:	680b      	ldr	r3, [r1, #0]
    int32_t idx = 0;
  101bca:	f2c8 2096 	movt	r0, #33430	; 0x8296
  101bce:	f104 0524 	add.w	r5, r4, #36	; 0x24
    RMWREG32(_ioaddr(APB_SCR_SAF_BASE + (0x610 << 10)), 3, 3, 1);
  101bd2:	f023 0338 	bic.w	r3, r3, #56	; 0x38
  101bd6:	f043 0308 	orr.w	r3, r3, #8
  101bda:	600b      	str	r3, [r1, #0]
    addr_t module_phy_addr = 0;
  101bdc:	2100      	movs	r1, #0
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101bde:	6813      	ldr	r3, [r2, #0]
  101be0:	f043 0301 	orr.w	r3, r3, #1
  101be4:	6013      	str	r3, [r2, #0]
    int32_t idx = 0;
  101be6:	e9cd 1100 	strd	r1, r1, [r13]
  101bea:	e003      	b.n	101bf4 <safety_init+0xbc>
    for (uint32_t i = 0;
  101bec:	42ac      	cmp	r4, r5
  101bee:	d013      	beq.n	101c18 <safety_init+0xe0>
  101bf0:	f854 0f04 	ldr.w	r0, [r4, #4]!
        ret = res_get_info_by_id(default_rst_ip_module[i], &module_phy_addr, &idx);
  101bf4:	4669      	mov	r1, r13
  101bf6:	aa01      	add	r2, sp, #4
  101bf8:	f00e fb9c 	bl	110334 <res_get_info_by_id>
        if (0 == ret) {
  101bfc:	2800      	cmp	r0, #0
  101bfe:	d1f5      	bne.n	101bec <safety_init+0xb4>
            rstgen_module_ctl(module_phy_addr, idx, false);
  101c00:	4602      	mov	r2, r0
  101c02:	e9dd 0100 	ldrd	r0, r1, [r13]
  101c06:	f007 fc5b 	bl	1094c0 <rstgen_module_ctl>
            rstgen_module_ctl(module_phy_addr, idx, true);
  101c0a:	e9dd 0100 	ldrd	r0, r1, [r13]
  101c0e:	2201      	movs	r2, #1
  101c10:	f007 fc56 	bl	1094c0 <rstgen_module_ctl>
    for (uint32_t i = 0;
  101c14:	42ac      	cmp	r4, r5
  101c16:	d1eb      	bne.n	101bf0 <safety_init+0xb8>
    rtc_init(APB_RTC1_BASE);
  101c18:	2000      	movs	r0, #0
        RMWREG32(handover_list.handover_info[i].op_addr,
  101c1a:	2401      	movs	r4, #1
    rtc_init(APB_RTC1_BASE);
  101c1c:	f2cf 1080 	movt	r0, #61824	; 0xf180
  101c20:	f007 fd86 	bl	109730 <rtc_init>
    rtc_enable(APB_RTC1_BASE);
  101c24:	2000      	movs	r0, #0
  101c26:	f2cf 1080 	movt	r0, #61824	; 0xf180
  101c2a:	f007 fc7b 	bl	109524 <rtc_enable>
    rtc_init(APB_RTC2_BASE);
  101c2e:	2000      	movs	r0, #0
  101c30:	f2cf 1081 	movt	r0, #61825	; 0xf181
  101c34:	f007 fd7c 	bl	109730 <rtc_init>
    rtc_enable(APB_RTC2_BASE);
  101c38:	2000      	movs	r0, #0
  101c3a:	f2cf 1081 	movt	r0, #61825	; 0xf181
  101c3e:	f007 fc71 	bl	109524 <rtc_enable>
  101c42:	f248 21a4 	movw	r1, #33444	; 0x82a4
  101c46:	f2c0 0111 	movt	r1, #17
  101c4a:	f101 05b4 	add.w	r5, r1, #180	; 0xb4
        RMWREG32(handover_list.handover_info[i].op_addr,
  101c4e:	6888      	ldr	r0, [r1, #8]
  101c50:	f811 3f0c 	ldrb.w	r3, [r1, #12]!
  101c54:	fa04 f203 	lsl.w	r2, r4, r3
    for (i = 0; i < handover_list.handover_num; i++) {
  101c58:	428d      	cmp	r5, r1
        RMWREG32(handover_list.handover_info[i].op_addr,
  101c5a:	6803      	ldr	r3, [r0, #0]
  101c5c:	ea23 0302 	bic.w	r3, r3, r2
  101c60:	ea43 0302 	orr.w	r3, r3, r2
  101c64:	6003      	str	r3, [r0, #0]
    for (i = 0; i < handover_list.handover_num; i++) {
  101c66:	d1f2      	bne.n	101c4e <safety_init+0x116>
#ifdef ENABLE_RTC
    /* should call it before handover */
    platform_rtc_init();
#endif
    platform_handover();
}
  101c68:	b003      	add	sp, #12
  101c6a:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(ALWAYS, "clock handle create fail\n");
  101c6c:	f248 305c 	movw	r0, #33628	; 0x835c
  101c70:	f2c0 0011 	movt	r0, #17
  101c74:	f012 fdae 	bl	1147d4 <puts>
  101c78:	e799      	b.n	101bae <safety_init+0x76>
  101c7a:	bf00      	nop
  101c7c:	00118244 	.word	0x00118244

00101c80 <safety_os_entry>:
#if SUPPORT_NEXT_OS
#include "reboot_service.h"
static void reboot_saf(uint32_t level)
{
    rb_arg arg = {0};
    arg.entry = SAF_MEMBASE;
  101c80:	2200      	movs	r2, #0
  101c82:	2300      	movs	r3, #0
    arg.sz = SAF_MEMSIZE;
    reboot_module(RB_SAF_M, RB_RB_OPC, &arg);
}

static void safety_os_entry(const struct app_descriptor *app, void *args)
{
  101c84:	b530      	push	{r4, r5, r14}
    arg.entry = SAF_MEMBASE;
  101c86:	f2c3 7220 	movt	r2, #14112	; 0x3720
    rb_arg arg = {0};
  101c8a:	2100      	movs	r1, #0
{
  101c8c:	b087      	sub	sp, #28
    arg.sz = SAF_MEMSIZE;
  101c8e:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
  101c92:	2500      	movs	r5, #0
    arg.entry = SAF_MEMBASE;
  101c94:	e9cd 2300 	strd	r2, r3, [r13]
    reboot_module(RB_SAF_M, RB_RB_OPC, &arg);
  101c98:	4608      	mov	r0, r1
    rb_arg arg = {0};
  101c9a:	e9cd 1104 	strd	r1, r1, [r13, #16]
    reboot_module(RB_SAF_M, RB_RB_OPC, &arg);
  101c9e:	466a      	mov	r2, r13
    arg.sz = SAF_MEMSIZE;
  101ca0:	e9cd 4502 	strd	r4, r5, [r13, #8]
    reboot_module(RB_SAF_M, RB_RB_OPC, &arg);
  101ca4:	f015 f932 	bl	116f0c <reboot_module>
    reboot_saf(0);
}
  101ca8:	b007      	add	sp, #28
  101caa:	bd30      	pop	{r4, r5, r15}

00101cac <set_pmu_ctrl_ap_domain>:
{
  101cac:	b510      	push	{r4, r14}
    ret = hal_pmu_creat_handle(&handle, RES_PMU_PMU);
  101cae:	f241 0105 	movw	r1, #4101	; 0x1005
{
  101cb2:	b082      	sub	sp, #8
  101cb4:	4604      	mov	r4, r0
    ret = hal_pmu_creat_handle(&handle, RES_PMU_PMU);
  101cb6:	f2c4 617e 	movt	r1, #18046	; 0x467e
  101cba:	a801      	add	r0, sp, #4
  101cbc:	f00e f86c 	bl	10fd98 <hal_pmu_creat_handle>
    if (ret != 0) {
  101cc0:	bb30      	cbnz	r0, 101d10 <set_pmu_ctrl_ap_domain+0x64>
    ret = hal_pmu_init(handle);
  101cc2:	9801      	ldr	r0, [sp, #4]
  101cc4:	f00e f8ae 	bl	10fe24 <hal_pmu_init>
    if (ret != 0) {
  101cc8:	b9c8      	cbnz	r0, 101cfe <set_pmu_ctrl_ap_domain+0x52>
	ret = hal_pmu_set_powerctrl_io_mode(handle, PWR_CTRL_2, 0);
  101cca:	4602      	mov	r2, r0
  101ccc:	2102      	movs	r1, #2
  101cce:	9801      	ldr	r0, [sp, #4]
  101cd0:	f00e f8f0 	bl	10feb4 <hal_pmu_set_powerctrl_io_mode>
	if (ret != 0) {
  101cd4:	bb28      	cbnz	r0, 101d22 <set_pmu_ctrl_ap_domain+0x76>
	ret = hal_pmu_set_powerctrl_out_mode(handle, PWR_CTRL_2, 1);
  101cd6:	2201      	movs	r2, #1
  101cd8:	2102      	movs	r1, #2
  101cda:	9801      	ldr	r0, [sp, #4]
  101cdc:	f00e f910 	bl	10ff00 <hal_pmu_set_powerctrl_out_mode>
	if (ret != 0) {
  101ce0:	bb40      	cbnz	r0, 101d34 <set_pmu_ctrl_ap_domain+0x88>
	ret = hal_pmu_set_powerctrl_out_ctrl(handle, PWR_CTRL_2, state);
  101ce2:	4622      	mov	r2, r4
  101ce4:	2102      	movs	r1, #2
  101ce6:	9801      	ldr	r0, [sp, #4]
  101ce8:	f00e f930 	bl	10ff4c <hal_pmu_set_powerctrl_out_ctrl>
	if (ret != 0) {
  101cec:	bb50      	cbnz	r0, 101d44 <set_pmu_ctrl_ap_domain+0x98>
    ret = hal_pmu_exit(handle);
  101cee:	9801      	ldr	r0, [sp, #4]
  101cf0:	f00e f8bc 	bl	10fe6c <hal_pmu_exit>
    if (ret != 0) {
  101cf4:	bb70      	cbnz	r0, 101d54 <set_pmu_ctrl_ap_domain+0xa8>
    return hal_pmu_release_handle(handle);
  101cf6:	9801      	ldr	r0, [sp, #4]
  101cf8:	f00e f892 	bl	10fe20 <hal_pmu_release_handle>
  101cfc:	e006      	b.n	101d0c <set_pmu_ctrl_ap_domain+0x60>
        printf("pmu init fail\n");
  101cfe:	f248 5048 	movw	r0, #34120	; 0x8548
  101d02:	f2c0 0011 	movt	r0, #17
  101d06:	f012 fd65 	bl	1147d4 <puts>
        return 1;
  101d0a:	2001      	movs	r0, #1
}
  101d0c:	b002      	add	sp, #8
  101d0e:	bd10      	pop	{r4, r15}
        printf("get handle fail\n");
  101d10:	f248 5038 	movw	r0, #34104	; 0x8538
  101d14:	f2c0 0011 	movt	r0, #17
  101d18:	f012 fd5c 	bl	1147d4 <puts>
        return 1;
  101d1c:	2001      	movs	r0, #1
}
  101d1e:	b002      	add	sp, #8
  101d20:	bd10      	pop	{r4, r15}
		printf("pmu set power ctrl PWR_CTRL_2 to out mode fail\n");
  101d22:	f248 5058 	movw	r0, #34136	; 0x8558
  101d26:	f2c0 0011 	movt	r0, #17
  101d2a:	f012 fd53 	bl	1147d4 <puts>
		return 1;
  101d2e:	2001      	movs	r0, #1
}
  101d30:	b002      	add	sp, #8
  101d32:	bd10      	pop	{r4, r15}
		printf("pmu set power ctrl PWR_CTRL_2 to soft mode fail\n");
  101d34:	f248 5088 	movw	r0, #34184	; 0x8588
  101d38:	f2c0 0011 	movt	r0, #17
  101d3c:	f012 fd4a 	bl	1147d4 <puts>
		return 1;
  101d40:	2001      	movs	r0, #1
  101d42:	e7e3      	b.n	101d0c <set_pmu_ctrl_ap_domain+0x60>
		printf("pmu set power ctrl PWR_CTRL_2 to low level fail\n");
  101d44:	f248 50b8 	movw	r0, #34232	; 0x85b8
  101d48:	f2c0 0011 	movt	r0, #17
  101d4c:	f012 fd42 	bl	1147d4 <puts>
		return 1;
  101d50:	2001      	movs	r0, #1
  101d52:	e7db      	b.n	101d0c <set_pmu_ctrl_ap_domain+0x60>
        printf("pmu exit fail\n");
  101d54:	f248 50e8 	movw	r0, #34280	; 0x85e8
  101d58:	f2c0 0011 	movt	r0, #17
  101d5c:	f012 fd3a 	bl	1147d4 <puts>
        return 1;
  101d60:	2001      	movs	r0, #1
  101d62:	e7d3      	b.n	101d0c <set_pmu_ctrl_ap_domain+0x60>

00101d64 <module_iso_disable>:

void module_iso_disable(uint32_t res_id)
{
  101d64:	b510      	push	{r4, r14}
    void *handle = NULL;
  101d66:	2200      	movs	r2, #0
{
  101d68:	b082      	sub	sp, #8
  101d6a:	4604      	mov	r4, r0
    void *handle = NULL;
  101d6c:	ab02      	add	r3, sp, #8
    bool ret = false;
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101d6e:	4601      	mov	r1, r0
    void *handle = NULL;
  101d70:	f843 2d04 	str.w	r2, [r3, #-4]!
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101d74:	4618      	mov	r0, r3
  101d76:	f00e fb49 	bl	11040c <hal_rstgen_creat_handle>

    if (!ret) {
  101d7a:	b1e8      	cbz	r0, 101db8 <module_iso_disable+0x54>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
        return;
    }

    ret = hal_rstgen_init(handle);
  101d7c:	9801      	ldr	r0, [sp, #4]
  101d7e:	f00e fbc1 	bl	110504 <hal_rstgen_init>

    if (!ret) {
  101d82:	b958      	cbnz	r0, 101d9c <module_iso_disable+0x38>
        dprintf(CRITICAL, "hal_rstgen_init res_id 0x%x fail.\n", res_id);
  101d84:	f248 409c 	movw	r0, #33948	; 0x849c
  101d88:	4621      	mov	r1, r4
  101d8a:	f2c0 0011 	movt	r0, #17
  101d8e:	f012 fd39 	bl	114804 <printf>
    if (!ret) {
        dprintf(CRITICAL, "hal_rstgen_iso_disable res_id 0x%x fail.\n", res_id);
    }

fail:
    hal_rstgen_release_handle(handle);
  101d92:	9801      	ldr	r0, [sp, #4]
  101d94:	f00e fbaa 	bl	1104ec <hal_rstgen_release_handle>
}
  101d98:	b002      	add	sp, #8
  101d9a:	bd10      	pop	{r4, r15}
    ret = hal_rstgen_iso_disable(handle, res_id);
  101d9c:	9801      	ldr	r0, [sp, #4]
  101d9e:	4621      	mov	r1, r4
  101da0:	f00e fbce 	bl	110540 <hal_rstgen_iso_disable>
    if (!ret) {
  101da4:	2800      	cmp	r0, #0
  101da6:	d1f4      	bne.n	101d92 <module_iso_disable+0x2e>
        dprintf(CRITICAL, "hal_rstgen_iso_disable res_id 0x%x fail.\n", res_id);
  101da8:	f248 40c0 	movw	r0, #33984	; 0x84c0
  101dac:	4621      	mov	r1, r4
  101dae:	f2c0 0011 	movt	r0, #17
  101db2:	f012 fd27 	bl	114804 <printf>
  101db6:	e7ec      	b.n	101d92 <module_iso_disable+0x2e>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
  101db8:	f248 4070 	movw	r0, #33904	; 0x8470
  101dbc:	4621      	mov	r1, r4
  101dbe:	f2c0 0011 	movt	r0, #17
  101dc2:	f012 fd1f 	bl	114804 <printf>
}
  101dc6:	b002      	add	sp, #8
  101dc8:	bd10      	pop	{r4, r15}
  101dca:	bf00      	nop

00101dcc <module_rst>:

void module_rst(uint32_t res_id)
{
  101dcc:	b510      	push	{r4, r14}
    void *handle = NULL;
  101dce:	2200      	movs	r2, #0
{
  101dd0:	b082      	sub	sp, #8
  101dd2:	4604      	mov	r4, r0
    void *handle = NULL;
  101dd4:	ab02      	add	r3, sp, #8
    bool ret = false;
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101dd6:	4601      	mov	r1, r0
    void *handle = NULL;
  101dd8:	f843 2d04 	str.w	r2, [r3, #-4]!
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101ddc:	4618      	mov	r0, r3
  101dde:	f00e fb15 	bl	11040c <hal_rstgen_creat_handle>

    if (!ret) {
  101de2:	b1e8      	cbz	r0, 101e20 <module_rst+0x54>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
        return;
    }

    ret = hal_rstgen_init(handle);
  101de4:	9801      	ldr	r0, [sp, #4]
  101de6:	f00e fb8d 	bl	110504 <hal_rstgen_init>

    if (!ret) {
  101dea:	b958      	cbnz	r0, 101e04 <module_rst+0x38>
        dprintf(CRITICAL, "hal_rstgen_init res_id 0x%x fail.\n", res_id);
  101dec:	f248 409c 	movw	r0, #33948	; 0x849c
  101df0:	4621      	mov	r1, r4
  101df2:	f2c0 0011 	movt	r0, #17
  101df6:	f012 fd05 	bl	114804 <printf>
    if (!ret) {
        dprintf(CRITICAL, "hal_rstgen_module_reset res_id 0x%x fail.\n", res_id);
    }

fail:
    hal_rstgen_release_handle(handle);
  101dfa:	9801      	ldr	r0, [sp, #4]
  101dfc:	f00e fb76 	bl	1104ec <hal_rstgen_release_handle>
}
  101e00:	b002      	add	sp, #8
  101e02:	bd10      	pop	{r4, r15}
    ret = hal_rstgen_module_reset(handle, res_id);
  101e04:	9801      	ldr	r0, [sp, #4]
  101e06:	4621      	mov	r1, r4
  101e08:	f00e fc04 	bl	110614 <hal_rstgen_module_reset>
    if (!ret) {
  101e0c:	2800      	cmp	r0, #0
  101e0e:	d1f4      	bne.n	101dfa <module_rst+0x2e>
        dprintf(CRITICAL, "hal_rstgen_module_reset res_id 0x%x fail.\n", res_id);
  101e10:	f248 40ec 	movw	r0, #34028	; 0x84ec
  101e14:	4621      	mov	r1, r4
  101e16:	f2c0 0011 	movt	r0, #17
  101e1a:	f012 fcf3 	bl	114804 <printf>
  101e1e:	e7ec      	b.n	101dfa <module_rst+0x2e>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
  101e20:	f248 4070 	movw	r0, #33904	; 0x8470
  101e24:	4621      	mov	r1, r4
  101e26:	f2c0 0011 	movt	r0, #17
  101e2a:	f012 fceb 	bl	114804 <printf>
}
  101e2e:	b002      	add	sp, #8
  101e30:	bd10      	pop	{r4, r15}
  101e32:	bf00      	nop

00101e34 <init_gpu1_ss>:

void init_gpu1_ss(void)
{
  101e34:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
    bool ret = false;
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101e36:	f240 4027 	movw	r0, #1063	; 0x427
{
  101e3a:	b087      	sub	sp, #28
    void *handle = NULL;
  101e3c:	2400      	movs	r4, #0
  101e3e:	ad06      	add	r5, sp, #24
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101e40:	f2c8 1096 	movt	r0, #33174	; 0x8196
    void *handle = NULL;
  101e44:	f845 4d18 	str.w	r4, [r5, #-24]!
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101e48:	f7ff ff8c 	bl	101d64 <module_iso_disable>
    module_rst(RES_MODULE_RST_SEC_GPU1_SS);
  101e4c:	f240 4091 	movw	r0, #1169	; 0x491
  101e50:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101e54:	f7ff ffba 	bl	101dcc <module_rst>
    module_rst(RES_MODULE_RST_SEC_GPU1_CORE);
  101e58:	f44f 6092 	mov.w	r0, #1168	; 0x490
  101e5c:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101e60:	f7ff ffb4 	bl	101dcc <module_rst>

    ret = hal_clock_creat_handle(&handle);
  101e64:	4628      	mov	r0, r5
  101e66:	f008 fb63 	bl	10a530 <hal_clock_creat_handle>

    if (!ret) {
  101e6a:	2800      	cmp	r0, #0
  101e6c:	d039      	beq.n	101ee2 <init_gpu1_ss+0xae>
    corecfg.clk_src_select_a_num = 0;
    /* default--24MHz */
    corecfg.clk_src_select_b_num = 0;
    corecfg.clk_a_b_select = 0;
    corecfg.post_div = 0;
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU1, &corecfg);
  101e6e:	21c3      	movs	r1, #195	; 0xc3
  101e70:	aa01      	add	r2, sp, #4
  101e72:	9800      	ldr	r0, [sp, #0]
  101e74:	f2c8 019a 	movt	r1, #32922	; 0x809a
    corecfg.clk_src_select_a_num = 0;
  101e78:	f8ad 4004 	strh.w	r4, [r13, #4]
    corecfg.clk_src_select_b_num = 0;
  101e7c:	f88d 4006 	strb.w	r4, [r13, #6]
    corecfg.post_div = 0;
  101e80:	9402      	str	r4, [sp, #8]
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU1, &corecfg);
  101e82:	f008 ffb7 	bl	10adf4 <hal_clock_coreclk_set>

    if (!ret) {
  101e86:	b968      	cbnz	r0, 101ea4 <init_gpu1_ss+0x70>
        dprintf(CRITICAL, "clock_coreclk resid 0x%x fail\n",
  101e88:	21c3      	movs	r1, #195	; 0xc3
  101e8a:	f248 400c 	movw	r0, #33804	; 0x840c
  101e8e:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101e92:	f2c0 0011 	movt	r0, #17
  101e96:	f012 fcb5 	bl	114804 <printf>
    }

    /* config pll_gpu1 */
    setup_pll(RES_PLL_PLL_GPU1);
fail:
    hal_clock_release_handle(handle);
  101e9a:	9800      	ldr	r0, [sp, #0]
  101e9c:	f008 fb64 	bl	10a568 <hal_clock_release_handle>
}
  101ea0:	b007      	add	sp, #28
  101ea2:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU1, &uuu_clk);
  101ea4:	f240 1183 	movw	r1, #387	; 0x183
  101ea8:	aa03      	add	r2, sp, #12
  101eaa:	9800      	ldr	r0, [sp, #0]
  101eac:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  101eb0:	e9cd 4403 	strd	r4, r4, [r13, #12]
  101eb4:	9405      	str	r4, [sp, #20]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU1, &uuu_clk);
  101eb6:	f009 f88b 	bl	10afd0 <hal_clock_uuuclk_set>
    if (!ret) {
  101eba:	b1d0      	cbz	r0, 101ef2 <init_gpu1_ss+0xbe>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_GPU1_2);
  101ebc:	9800      	ldr	r0, [sp, #0]
  101ebe:	f240 111f 	movw	r1, #287	; 0x11f
  101ec2:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101ec6:	f008 fdcf 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  101eca:	b9e8      	cbnz	r0, 101f08 <init_gpu1_ss+0xd4>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  101ecc:	f240 111f 	movw	r1, #287	; 0x11f
  101ed0:	f248 404c 	movw	r0, #33868	; 0x844c
  101ed4:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101ed8:	f2c0 0011 	movt	r0, #17
  101edc:	f012 fc92 	bl	114804 <printf>
        goto fail;
  101ee0:	e7db      	b.n	101e9a <init_gpu1_ss+0x66>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  101ee2:	f248 30f0 	movw	r0, #33776	; 0x83f0
  101ee6:	f2c0 0011 	movt	r0, #17
  101eea:	f012 fc73 	bl	1147d4 <puts>
}
  101eee:	b007      	add	sp, #28
  101ef0:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_GPU1);
  101ef2:	f240 1183 	movw	r1, #387	; 0x183
  101ef6:	f248 402c 	movw	r0, #33836	; 0x842c
  101efa:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101efe:	f2c0 0011 	movt	r0, #17
  101f02:	f012 fc7f 	bl	114804 <printf>
        goto fail;
  101f06:	e7c8      	b.n	101e9a <init_gpu1_ss+0x66>
    setup_pll(RES_PLL_PLL_GPU1);
  101f08:	f241 0008 	movw	r0, #4104	; 0x1008
  101f0c:	f2c4 502e 	movt	r0, #17710	; 0x452e
  101f10:	f7ff fe04 	bl	101b1c <setup_pll>
  101f14:	e7c1      	b.n	101e9a <init_gpu1_ss+0x66>
  101f16:	bf00      	nop

00101f18 <init_gpu2_ss>:

void init_gpu2_ss(void)
{
  101f18:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
    bool ret = false;
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101f1a:	f240 4093 	movw	r0, #1171	; 0x493
{
  101f1e:	b087      	sub	sp, #28
    void *handle = NULL;
  101f20:	2400      	movs	r4, #0
  101f22:	ad06      	add	r5, sp, #24
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101f24:	f2c8 1096 	movt	r0, #33174	; 0x8196
    void *handle = NULL;
  101f28:	f845 4d18 	str.w	r4, [r5, #-24]!
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101f2c:	f7ff ff4e 	bl	101dcc <module_rst>
    module_rst(RES_MODULE_RST_SEC_GPU2_CORE);
  101f30:	f240 4092 	movw	r0, #1170	; 0x492
  101f34:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101f38:	f7ff ff48 	bl	101dcc <module_rst>
    ret = hal_clock_creat_handle(&handle);
  101f3c:	4628      	mov	r0, r5
  101f3e:	f008 faf7 	bl	10a530 <hal_clock_creat_handle>

    if (!ret) {
  101f42:	2800      	cmp	r0, #0
  101f44:	d039      	beq.n	101fba <init_gpu2_ss+0xa2>
    corecfg.clk_src_select_a_num = 0;
    /* default--24MHz */
    corecfg.clk_src_select_b_num = 0;
    corecfg.clk_a_b_select = 0;
    corecfg.post_div = 0;
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU2, &corecfg);
  101f46:	21c4      	movs	r1, #196	; 0xc4
  101f48:	aa01      	add	r2, sp, #4
  101f4a:	9800      	ldr	r0, [sp, #0]
  101f4c:	f2c8 019a 	movt	r1, #32922	; 0x809a
    corecfg.clk_src_select_a_num = 0;
  101f50:	f8ad 4004 	strh.w	r4, [r13, #4]
    corecfg.clk_src_select_b_num = 0;
  101f54:	f88d 4006 	strb.w	r4, [r13, #6]
    corecfg.post_div = 0;
  101f58:	9402      	str	r4, [sp, #8]
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU2, &corecfg);
  101f5a:	f008 ff4b 	bl	10adf4 <hal_clock_coreclk_set>

    if (!ret) {
  101f5e:	b968      	cbnz	r0, 101f7c <init_gpu2_ss+0x64>
        dprintf(CRITICAL, "clock_coreclk resid 0x%x fail\n",
  101f60:	21c4      	movs	r1, #196	; 0xc4
  101f62:	f248 400c 	movw	r0, #33804	; 0x840c
  101f66:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f6a:	f2c0 0011 	movt	r0, #17
  101f6e:	f012 fc49 	bl	114804 <printf>
    }

    /* config pll_gpu2 */
    setup_pll(RES_PLL_PLL_GPU2);
fail:
    hal_clock_release_handle(handle);
  101f72:	9800      	ldr	r0, [sp, #0]
  101f74:	f008 faf8 	bl	10a568 <hal_clock_release_handle>
}
  101f78:	b007      	add	sp, #28
  101f7a:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU2, &uuu_clk);
  101f7c:	f44f 71c2 	mov.w	r1, #388	; 0x184
  101f80:	aa03      	add	r2, sp, #12
  101f82:	9800      	ldr	r0, [sp, #0]
  101f84:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  101f88:	e9cd 4403 	strd	r4, r4, [r13, #12]
  101f8c:	9405      	str	r4, [sp, #20]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU2, &uuu_clk);
  101f8e:	f009 f81f 	bl	10afd0 <hal_clock_uuuclk_set>
    if (!ret) {
  101f92:	b1d0      	cbz	r0, 101fca <init_gpu2_ss+0xb2>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_GPU2_2);
  101f94:	9800      	ldr	r0, [sp, #0]
  101f96:	f240 1121 	movw	r1, #289	; 0x121
  101f9a:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f9e:	f008 fd63 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  101fa2:	b9e8      	cbnz	r0, 101fe0 <init_gpu2_ss+0xc8>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  101fa4:	f240 1121 	movw	r1, #289	; 0x121
  101fa8:	f248 404c 	movw	r0, #33868	; 0x844c
  101fac:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101fb0:	f2c0 0011 	movt	r0, #17
  101fb4:	f012 fc26 	bl	114804 <printf>
        goto fail;
  101fb8:	e7db      	b.n	101f72 <init_gpu2_ss+0x5a>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  101fba:	f248 30f0 	movw	r0, #33776	; 0x83f0
  101fbe:	f2c0 0011 	movt	r0, #17
  101fc2:	f012 fc07 	bl	1147d4 <puts>
}
  101fc6:	b007      	add	sp, #28
  101fc8:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_GPU2);
  101fca:	f44f 71c2 	mov.w	r1, #388	; 0x184
  101fce:	f248 402c 	movw	r0, #33836	; 0x842c
  101fd2:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101fd6:	f2c0 0011 	movt	r0, #17
  101fda:	f012 fc13 	bl	114804 <printf>
        goto fail;
  101fde:	e7c8      	b.n	101f72 <init_gpu2_ss+0x5a>
    setup_pll(RES_PLL_PLL_GPU2);
  101fe0:	f242 0009 	movw	r0, #8201	; 0x2009
  101fe4:	f2c4 502e 	movt	r0, #17710	; 0x452e
  101fe8:	f7ff fd98 	bl	101b1c <setup_pll>
  101fec:	e7c1      	b.n	101f72 <init_gpu2_ss+0x5a>
  101fee:	bf00      	nop

00101ff0 <init_display_ss>:
/* temp for bringup, improve later */
void init_display_ss(void)
{
#if WITH_HAL_MODULE_HELPER_HAL
#if MODULE_HELPER_PER_DISP
    module_set_state(PER_ID_DISP, DISP_INIT);
  101ff0:	2103      	movs	r1, #3
  101ff2:	2000      	movs	r0, #0
{
  101ff4:	b508      	push	{r3, r14}
    module_set_state(PER_ID_DISP, DISP_INIT);
  101ff6:	f00a fe41 	bl	10cc7c <module_set_state>
#endif
#endif
    /* init lvds_clk_wrappers, they are in IP inner */
    uint32_t rval;
    const uint32_t lvds_clock_offset = 0x10000;
    addr_t addr = APB_LVDS_COMMON_BASE + lvds_clock_offset + 0x4;
  101ffa:	2204      	movs	r2, #4

    for (int i = 0; i < 4; i++) {
  101ffc:	4611      	mov	r1, r2
    addr_t addr = APB_LVDS_COMMON_BASE + lvds_clock_offset + 0x4;
  101ffe:	f2cf 02c5 	movt	r2, #61637	; 0xf0c5
    for (int i = 0; i < 4; i++) {
  102002:	f2cf 01c9 	movt	r1, #61641	; 0xf0c9
        rval = readl(addr);
  102006:	6813      	ldr	r3, [r2, #0]
        writel((rval & (~(0x3F))) | 0x26, addr);
  102008:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  10200c:	f043 0326 	orr.w	r3, r3, #38	; 0x26
  102010:	6013      	str	r3, [r2, #0]
        addr += lvds_clock_offset;
  102012:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
    for (int i = 0; i < 4; i++) {
  102016:	428a      	cmp	r2, r1
  102018:	d1f5      	bne.n	102006 <init_display_ss+0x16>
    }
}
  10201a:	bd08      	pop	{r3, r15}

0010201c <init_vpu_ss>:

void init_vpu_ss(void)
{
  10201c:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
  10201e:	2400      	movs	r4, #0
{
  102020:	b085      	sub	sp, #20
    void *handle = NULL;
  102022:	a804      	add	r0, sp, #16
  102024:	f840 4d10 	str.w	r4, [r0, #-16]!
    bool ret = false;
    ret = hal_clock_creat_handle(&handle);
  102028:	f008 fa82 	bl	10a530 <hal_clock_creat_handle>

    if (!ret) {
  10202c:	2800      	cmp	r0, #0
  10202e:	f000 808b 	beq.w	102148 <init_vpu_ss+0x12c>
        return;
    }

    /* config uuu for vpu_bus */
    clkgen_app_uuu_cfg_t uuu_clk = {0};
    uuu_clk.uuu_input_clk_sel = 3;
  102032:	2503      	movs	r5, #3
    uuu_clk.low_power_mode_en = 0;
    uuu_clk.m_div = 0;
    uuu_clk.n_div = 3;
    uuu_clk.p_div = 0;
    uuu_clk.q_div = 0;
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU_BUS, &uuu_clk);
  102034:	f240 1187 	movw	r1, #391	; 0x187
  102038:	aa01      	add	r2, sp, #4
  10203a:	9800      	ldr	r0, [sp, #0]
  10203c:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  102040:	e9cd 4402 	strd	r4, r4, [r13, #8]
    uuu_clk.uuu_input_clk_sel = 3;
  102044:	9501      	str	r5, [sp, #4]
    uuu_clk.n_div = 3;
  102046:	f88d 500a 	strb.w	r5, [r13, #10]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU_BUS, &uuu_clk);
  10204a:	f008 ffc1 	bl	10afd0 <hal_clock_uuuclk_set>

    if (!ret) {
  10204e:	b970      	cbnz	r0, 10206e <init_vpu_ss+0x52>
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n",
  102050:	f240 1187 	movw	r1, #391	; 0x187
  102054:	f248 402c 	movw	r0, #33836	; 0x842c
  102058:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10205c:	f2c0 0011 	movt	r0, #17
  102060:	f012 fbd0 	bl	114804 <printf>
                RES_GATING_EN_SOC_GPU1_2);
        goto fail;
    }

fail:
    hal_clock_release_handle(handle);
  102064:	9800      	ldr	r0, [sp, #0]
  102066:	f008 fa7f 	bl	10a568 <hal_clock_release_handle>
}
  10206a:	b005      	add	sp, #20
  10206c:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU1, &uuu_clk);
  10206e:	f240 1185 	movw	r1, #389	; 0x185
  102072:	aa01      	add	r2, sp, #4
  102074:	9800      	ldr	r0, [sp, #0]
  102076:	f2c8 019a 	movt	r1, #32922	; 0x809a
    uuu_clk.uuu_input_clk_sel = 3;
  10207a:	9501      	str	r5, [sp, #4]
    uuu_clk.low_power_mode_en = 0;
  10207c:	f88d 4008 	strb.w	r4, [r13, #8]
    uuu_clk.m_div = 0;
  102080:	f88d 4009 	strb.w	r4, [r13, #9]
    uuu_clk.n_div = 0;
  102084:	f88d 400a 	strb.w	r4, [r13, #10]
    uuu_clk.p_div = 0;
  102088:	f88d 400b 	strb.w	r4, [r13, #11]
    uuu_clk.q_div = 0;
  10208c:	f88d 400c 	strb.w	r4, [r13, #12]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU1, &uuu_clk);
  102090:	f008 ff9e 	bl	10afd0 <hal_clock_uuuclk_set>
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_MJPEG, &uuu_clk);
  102094:	f44f 71c3 	mov.w	r1, #390	; 0x186
  102098:	aa01      	add	r2, sp, #4
  10209a:	9800      	ldr	r0, [sp, #0]
  10209c:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020a0:	f008 ff96 	bl	10afd0 <hal_clock_uuuclk_set>
    if (!ret) {
  1020a4:	2800      	cmp	r0, #0
  1020a6:	d057      	beq.n	102158 <init_vpu_ss+0x13c>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_VPU2_PCLK);
  1020a8:	9800      	ldr	r0, [sp, #0]
  1020aa:	f240 1123 	movw	r1, #291	; 0x123
  1020ae:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020b2:	f008 fcd9 	bl	10aa68 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_VPU1_PCLK);
  1020b6:	9800      	ldr	r0, [sp, #0]
  1020b8:	f44f 7191 	mov.w	r1, #290	; 0x122
  1020bc:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020c0:	f008 fcd2 	bl	10aa68 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_MJPEG_PCLK);
  1020c4:	9800      	ldr	r0, [sp, #0]
  1020c6:	f44f 7192 	mov.w	r1, #292	; 0x124
  1020ca:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020ce:	f008 fccb 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  1020d2:	2800      	cmp	r0, #0
  1020d4:	d04b      	beq.n	10216e <init_vpu_ss+0x152>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_VPU2_ACLK);
  1020d6:	9800      	ldr	r0, [sp, #0]
  1020d8:	f240 1123 	movw	r1, #291	; 0x123
  1020dc:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020e0:	f008 fcc2 	bl	10aa68 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_VPU1_ACLK);
  1020e4:	9800      	ldr	r0, [sp, #0]
  1020e6:	f44f 7191 	mov.w	r1, #290	; 0x122
  1020ea:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020ee:	f008 fcbb 	bl	10aa68 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_MJPEG_ACLK);
  1020f2:	9800      	ldr	r0, [sp, #0]
  1020f4:	f44f 7192 	mov.w	r1, #292	; 0x124
  1020f8:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020fc:	f008 fcb4 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  102100:	b3a8      	cbz	r0, 10216e <init_vpu_ss+0x152>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU1);
  102102:	9800      	ldr	r0, [sp, #0]
  102104:	f44f 7191 	mov.w	r1, #290	; 0x122
  102108:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10210c:	f008 fcac 	bl	10aa68 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_MJPEG);
  102110:	9800      	ldr	r0, [sp, #0]
  102112:	f44f 7192 	mov.w	r1, #292	; 0x124
  102116:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10211a:	f008 fca5 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  10211e:	b140      	cbz	r0, 102132 <init_vpu_ss+0x116>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_PLL_VPU);
  102120:	9800      	ldr	r0, [sp, #0]
  102122:	f240 1125 	movw	r1, #293	; 0x125
  102126:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10212a:	f008 fc9d 	bl	10aa68 <hal_clock_enable>
    if (!ret) {
  10212e:	2800      	cmp	r0, #0
  102130:	d198      	bne.n	102064 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  102132:	f240 111f 	movw	r1, #287	; 0x11f
  102136:	f248 404c 	movw	r0, #33868	; 0x844c
  10213a:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10213e:	f2c0 0011 	movt	r0, #17
  102142:	f012 fb5f 	bl	114804 <printf>
        goto fail;
  102146:	e78d      	b.n	102064 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  102148:	f248 30f0 	movw	r0, #33776	; 0x83f0
  10214c:	f2c0 0011 	movt	r0, #17
  102150:	f012 fb40 	bl	1147d4 <puts>
}
  102154:	b005      	add	sp, #20
  102156:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_VPU1);
  102158:	f240 1185 	movw	r1, #389	; 0x185
  10215c:	f248 402c 	movw	r0, #33836	; 0x842c
  102160:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102164:	f2c0 0011 	movt	r0, #17
  102168:	f012 fb4c 	bl	114804 <printf>
        goto fail;
  10216c:	e77a      	b.n	102064 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  10216e:	f44f 7191 	mov.w	r1, #290	; 0x122
  102172:	f248 404c 	movw	r0, #33868	; 0x844c
  102176:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10217a:	f2c0 0011 	movt	r0, #17
  10217e:	f012 fb41 	bl	114804 <printf>
        goto fail;
  102182:	e76f      	b.n	102064 <init_vpu_ss+0x48>

00102184 <rstgen_sec_module_rst>:
{
    unsigned int rval;
    uint32_t count = 100;
    const uint32_t module_rst_offset = 0x100 << 10;
    addr_t addr = APB_RSTGEN_SEC_BASE + module_rst_offset + ((
                      0x4 * idx) << 10);
  102184:	0300      	lsls	r0, r0, #12
    addr_t addr = APB_RSTGEN_SEC_BASE + module_rst_offset + ((
  102186:	f100 4078 	add.w	r0, r0, #4160749568	; 0xf8000000
  10218a:	f500 0088 	add.w	r0, r0, #4456448	; 0x440000
{
  10218e:	b410      	push	{r4}
    rval = readl(addr);
  102190:	6802      	ldr	r2, [r0, #0]
    writel(((rval & (~(0x1 << 1))) | (0x1 << 1)), addr);
  102192:	2364      	movs	r3, #100	; 0x64
  102194:	f042 0202 	orr.w	r2, r2, #2
  102198:	6002      	str	r2, [r0, #0]
  10219a:	e001      	b.n	1021a0 <rstgen_sec_module_rst+0x1c>

    /* Wait module reset enable done. */
    while ((count--) && (!((readl(addr) & (0x1 << 1)) == (0x1 << 1))));
  10219c:	3b01      	subs	r3, #1
  10219e:	d002      	beq.n	1021a6 <rstgen_sec_module_rst+0x22>
  1021a0:	6802      	ldr	r2, [r0, #0]
  1021a2:	0792      	lsls	r2, r2, #30
  1021a4:	d5fa      	bpl.n	10219c <rstgen_sec_module_rst+0x18>

    rval = readl(addr);
  1021a6:	6803      	ldr	r3, [r0, #0]
    writel(((rval & (~(0x1 << 0))) | rst_b), addr);
    /* Wait module reset done. */
    count = 100;

    while ((count--) && ((readl(addr) & (0x1 << 30)) != rst_b << 30));
  1021a8:	078c      	lsls	r4, r1, #30
  1021aa:	2264      	movs	r2, #100	; 0x64
    writel(((rval & (~(0x1 << 0))) | rst_b), addr);
  1021ac:	f023 0301 	bic.w	r3, r3, #1
  1021b0:	4319      	orrs	r1, r3
  1021b2:	6001      	str	r1, [r0, #0]
  1021b4:	e001      	b.n	1021ba <rstgen_sec_module_rst+0x36>
    while ((count--) && ((readl(addr) & (0x1 << 30)) != rst_b << 30));
  1021b6:	3a01      	subs	r2, #1
  1021b8:	d004      	beq.n	1021c4 <rstgen_sec_module_rst+0x40>
  1021ba:	6803      	ldr	r3, [r0, #0]
  1021bc:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  1021c0:	42a3      	cmp	r3, r4
  1021c2:	d1f8      	bne.n	1021b6 <rstgen_sec_module_rst+0x32>
}
  1021c4:	f85d 4b04 	ldr.w	r4, [r13], #4
  1021c8:	4770      	bx	r14
  1021ca:	bf00      	nop

001021cc <release_rst_all>:

void release_rst_all(void)
{
  1021cc:	b510      	push	{r4, r14}
    for (unsigned int i = 0; i < 104; i++) {
  1021ce:	2400      	movs	r4, #0
        /* skip vdsp dreset */
        if (i == 38) {
            continue;
        }

        rstgen_sec_module_rst(i, 0x1);
  1021d0:	2101      	movs	r1, #1
        if (i >= 21 && i <= 26) {
  1021d2:	f1a4 0315 	sub.w	r3, r4, #21
        rstgen_sec_module_rst(i, 0x1);
  1021d6:	4620      	mov	r0, r4
        if (i == 38) {
  1021d8:	2c26      	cmp	r4, #38	; 0x26
  1021da:	bf18      	it	ne
  1021dc:	2b05      	cmpne	r3, #5
    for (unsigned int i = 0; i < 104; i++) {
  1021de:	440c      	add	r4, r1
        if (i == 38) {
  1021e0:	d901      	bls.n	1021e6 <release_rst_all+0x1a>
        rstgen_sec_module_rst(i, 0x1);
  1021e2:	f7ff ffcf 	bl	102184 <rstgen_sec_module_rst>
    for (unsigned int i = 0; i < 104; i++) {
  1021e6:	2c68      	cmp	r4, #104	; 0x68
  1021e8:	d1f2      	bne.n	1021d0 <release_rst_all+0x4>
    }
}
  1021ea:	bd10      	pop	{r4, r15}

001021ec <enable_gating_all>:
    uint32_t rval = readl(addr);
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
}

void enable_gating_all(void)
{
  1021ec:	2300      	movs	r3, #0
    uint32_t i;
    const uint32_t gating_max_num = 128;

    for (i = 0; i < gating_max_num; i++) {
  1021ee:	4619      	mov	r1, r3
{
  1021f0:	f2cf 6310 	movt	r3, #62992	; 0xf610
    for (i = 0; i < gating_max_num; i++) {
  1021f4:	f2cf 6118 	movt	r1, #63000	; 0xf618
    uint32_t rval = readl(addr);
  1021f8:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  1021fa:	f022 0202 	bic.w	r2, r2, #2
  1021fe:	601a      	str	r2, [r3, #0]
  102200:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    for (i = 0; i < gating_max_num; i++) {
  102204:	428b      	cmp	r3, r1
  102206:	d1f7      	bne.n	1021f8 <enable_gating_all+0xc>
  102208:	2300      	movs	r3, #0
  10220a:	f6cf 0310 	movt	r3, #63504	; 0xf810
    uint32_t rval = readl(addr);
  10220e:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  102210:	f022 0202 	bic.w	r2, r2, #2
  102214:	601a      	str	r2, [r3, #0]
  102216:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
        ckgen_lp_gating_disable(APB_CKGEN_SOC_BASE, i, 0x0);
    }

    for (i = 0; i < gating_max_num; i++) {
  10221a:	f113 6ffd 	cmn.w	r3, #132644864	; 0x7e80000
  10221e:	d1f6      	bne.n	10220e <enable_gating_all+0x22>
  102220:	2300      	movs	r3, #0
        ckgen_lp_gating_disable(APB_CKGEN_SEC_BASE, i, 0x0);
    }

    for (i = 0; i < gating_max_num; i++) {
  102222:	4619      	mov	r1, r3
  102224:	f2cf 6330 	movt	r3, #63024	; 0xf630
  102228:	f2cf 6138 	movt	r1, #63032	; 0xf638
    uint32_t rval = readl(addr);
  10222c:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  10222e:	f022 0202 	bic.w	r2, r2, #2
  102232:	601a      	str	r2, [r3, #0]
  102234:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    for (i = 0; i < gating_max_num; i++) {
  102238:	428b      	cmp	r3, r1
  10223a:	d1f7      	bne.n	10222c <enable_gating_all+0x40>
        ckgen_lp_gating_disable(APB_CKGEN_DISP_BASE, i, 0x0);
    }
}
  10223c:	4770      	bx	r14
  10223e:	bf00      	nop

00102240 <module_config_init>:

/* init module config */
int module_config_init(void)
{
    //init pll
    setup_pll(RES_PLL_PLL6);
  102240:	f246 0003 	movw	r0, #24579	; 0x6003
{
  102244:	b508      	push	{r3, r14}
    setup_pll(RES_PLL_PLL6);
  102246:	f2c4 202e 	movt	r0, #16942	; 0x422e
  10224a:	f7ff fc67 	bl	101b1c <setup_pll>
    setup_pll(RES_PLL_PLL7);
  10224e:	f247 0004 	movw	r0, #28676	; 0x7004
  102252:	f2c4 202e 	movt	r0, #16942	; 0x422e
  102256:	f7ff fc61 	bl	101b1c <setup_pll>
#if !DISABLE_VPU
    setup_pll(RES_PLL_PLL_VPU);
  10225a:	f241 0005 	movw	r0, #4101	; 0x1005
  10225e:	f2c4 502e 	movt	r0, #17710	; 0x452e
  102262:	f7ff fc5b 	bl	101b1c <setup_pll>
#endif
    setup_pll(RES_PLL_PLL_HIS);
  102266:	f241 0015 	movw	r0, #4117	; 0x1015
  10226a:	f2c4 402e 	movt	r0, #17454	; 0x442e
  10226e:	f7ff fc55 	bl	101b1c <setup_pll>
    module_iso_disable(RES_ISO_EN_SEC_USB);
  102272:	f240 4025 	movw	r0, #1061	; 0x425
  102276:	f2c8 1096 	movt	r0, #33174	; 0x8196
  10227a:	f7ff fd73 	bl	101d64 <module_iso_disable>
    module_iso_disable(RES_ISO_EN_SEC_PCIE);
  10227e:	f240 4024 	movw	r0, #1060	; 0x424
  102282:	f2c8 1096 	movt	r0, #33174	; 0x8196
  102286:	f7ff fd6d 	bl	101d64 <module_iso_disable>
    init_pcie_ss();
    //debug
#if !defined(PLATFORM_G9X) && !defined(PLATFORM_G9Q)
    /* init GPU */
#if !DISABLE_GPU
    init_gpu1_ss();
  10228a:	f7ff fdd3 	bl	101e34 <init_gpu1_ss>
    init_gpu2_ss();
  10228e:	f7ff fe43 	bl	101f18 <init_gpu2_ss>
#endif
    /* init disp */
    init_display_ss();
  102292:	f7ff fead 	bl	101ff0 <init_display_ss>
    /* init vpu */
#if !DISABLE_VPU
    init_vpu_ss();
  102296:	f7ff fec1 	bl	10201c <init_vpu_ss>
#endif

#ifdef VDSP_ENABLE
    init_vsn_ss();
#endif
    hpi_qos_init();
  10229a:	f000 f851 	bl	102340 <hpi_qos_init>
    hal_sec_clock_set_default();
  10229e:	f008 fa59 	bl	10a754 <hal_sec_clock_set_default>
    hal_soc_clock_set_default();
  1022a2:	f008 fb5f 	bl	10a964 <hal_soc_clock_set_default>
#if SUPPORT_DISP_SDDRV
    hal_disp_clock_set_default();
  1022a6:	f008 faa9 	bl	10a7fc <hal_disp_clock_set_default>
#endif
    /* enable all gating_en of sec/disp/soc */
    enable_gating_all();
  1022aa:	f7ff ff9f 	bl	1021ec <enable_gating_all>
    /* release all module_rst of sec */
    release_rst_all();
  1022ae:	f7ff ff8d 	bl	1021cc <release_rst_all>
    return 0;
}
  1022b2:	2000      	movs	r0, #0
  1022b4:	bd08      	pop	{r3, r15}
  1022b6:	bf00      	nop

001022b8 <soc_init>:

    hal_port_release_handle(port_init_handle);
}

void soc_init(uint level)
{
  1022b8:	b530      	push	{r4, r5, r14}
  1022ba:	b083      	sub	sp, #12
    ret = hal_clock_creat_handle(&g_sec_handle);
  1022bc:	a801      	add	r0, sp, #4
  1022be:	f008 f937 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  1022c2:	b398      	cbz	r0, 10232c <soc_init+0x74>
  1022c4:	4c1d      	ldr	r4, [pc, #116]	; (10233c <soc_init+0x84>)
  1022c6:	f44f 7128 	mov.w	r1, #672	; 0x2a0
  1022ca:	f2c8 1198 	movt	r1, #33176	; 0x8198
  1022ce:	f104 051c 	add.w	r5, r4, #28
  1022d2:	e001      	b.n	1022d8 <soc_init+0x20>
  1022d4:	f854 1b04 	ldr.w	r1, [r4], #4
        ret = hal_clock_osc_init(g_sec_handle, refclk_ResIdx[i], xtal_saf_24M,
  1022d8:	2301      	movs	r3, #1
  1022da:	2200      	movs	r2, #0
  1022dc:	9801      	ldr	r0, [sp, #4]
  1022de:	f008 f94b 	bl	10a578 <hal_clock_osc_init>
    for (uint8_t i = 0; i < glb_res_idx_size; i++) {
  1022e2:	42ac      	cmp	r4, r5
  1022e4:	d1f6      	bne.n	1022d4 <soc_init+0x1c>
    hal_clock_release_handle(g_sec_handle);
  1022e6:	9801      	ldr	r0, [sp, #4]
  1022e8:	f008 f93e 	bl	10a568 <hal_clock_release_handle>
    refclk_config();
    scr_init();
  1022ec:	f000 fdba 	bl	102e64 <scr_init>

    module_config_init();
  1022f0:	f7ff ffa6 	bl	102240 <module_config_init>
    void *port_init_handle = NULL;
  1022f4:	2300      	movs	r3, #0
    hal_port_creat_handle(&port_init_handle, RES_PAD_CONTROL_SAF_JTAG_TMS);
  1022f6:	f44f 61a0 	mov.w	r1, #1280	; 0x500
  1022fa:	a801      	add	r0, sp, #4
    void *port_init_handle = NULL;
  1022fc:	9301      	str	r3, [sp, #4]
    hal_port_creat_handle(&port_init_handle, RES_PAD_CONTROL_SAF_JTAG_TMS);
  1022fe:	f2c8 2194 	movt	r1, #33428	; 0x8294
  102302:	f00d fe49 	bl	10ff98 <hal_port_creat_handle>
    if (port_init_handle) {
  102306:	9801      	ldr	r0, [sp, #4]
  102308:	b148      	cbz	r0, 10231e <soc_init+0x66>
        hal_port_init(port_init_handle);
  10230a:	f00d fee7 	bl	1100dc <hal_port_init>
    hal_port_release_handle(port_init_handle);
  10230e:	9801      	ldr	r0, [sp, #4]
  102310:	f00d feac 	bl	11006c <hal_port_release_handle>
    platform_port_init();
	set_pmu_ctrl_ap_domain(1);
  102314:	2001      	movs	r0, #1
  102316:	f7ff fcc9 	bl	101cac <set_pmu_ctrl_ap_domain>
}
  10231a:	b003      	add	sp, #12
  10231c:	bd30      	pop	{r4, r5, r15}
        dprintf(ALWAYS, "port get handle failed!\n");
  10231e:	f647 30e0 	movw	r0, #31712	; 0x7be0
  102322:	f2c0 0011 	movt	r0, #17
  102326:	f012 fa55 	bl	1147d4 <puts>
  10232a:	e7f0      	b.n	10230e <soc_init+0x56>
        printf("clkgen creat handle failed\n");
  10232c:	f248 50f8 	movw	r0, #34296	; 0x85f8
  102330:	f2c0 0011 	movt	r0, #17
  102334:	f012 fa4e 	bl	1147d4 <puts>
  102338:	e7d8      	b.n	1022ec <soc_init+0x34>
  10233a:	bf00      	nop
  10233c:	0011851c 	.word	0x0011851c

00102340 <hpi_qos_init>:
void init_qos_by_module(addr_t iobase, int offset,
                        uint32_t pri, uint32_t mode,
                        uint32_t bw, uint32_t satur, uint32_t ext)
{
    /* priority */
    writel(pri, iobase + offset + 0x8);
  102340:	f240 5103 	movw	r1, #1283	; 0x503
  102344:	f44f 72c4 	mov.w	r2, #392	; 0x188
  102348:	f2c8 0100 	movt	r1, #32768	; 0x8000
    /* ext */
    writel(ext, iobase + offset + 0x18);
}

void hpi_qos_init(void)
{
  10234c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    writel(pri, iobase + offset + 0x8);
  102350:	460e      	mov	r6, r1
{
  102352:	b083      	sub	sp, #12
    writel(mode, iobase + offset + 0xc);
  102354:	f44f 7bc6 	mov.w	r11, #396	; 0x18c
    writel(pri, iobase + offset + 0x8);
  102358:	f2cf 02cf 	movt	r2, #61647	; 0xf0cf
  10235c:	9601      	str	r6, [sp, #4]
    writel(mode, iobase + offset + 0xc);
  10235e:	f2cf 0bcf 	movt	r11, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102362:	6016      	str	r6, [r2, #0]
    writel(mode, iobase + offset + 0xc);
  102364:	2203      	movs	r2, #3
    writel(bw, iobase + offset + 0x10);
  102366:	f44f 70c8 	mov.w	r0, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  10236a:	f44f 73ca 	mov.w	r3, #404	; 0x194
    writel(mode, iobase + offset + 0xc);
  10236e:	f8cb 2000 	str.w	r2, [r11]
    writel(bw, iobase + offset + 0x10);
  102372:	f2cf 00cf 	movt	r0, #61647	; 0xf0cf
  102376:	f44f 7bb6 	mov.w	r11, #364	; 0x16c
    writel(satur, iobase + offset + 0x14);
  10237a:	f2cf 03cf 	movt	r3, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  10237e:	f44f 7acc 	mov.w	r10, #408	; 0x198
    writel(pri, iobase + offset + 0x8);
  102382:	f44f 7802 	mov.w	r8, #520	; 0x208
    writel(bw, iobase + offset + 0x10);
  102386:	f8c0 b000 	str.w	r11, [r0]
    writel(satur, iobase + offset + 0x14);
  10238a:	2080      	movs	r0, #128	; 0x80
    writel(pri, iobase + offset + 0x8);
  10238c:	f240 6906 	movw	r9, #1542	; 0x606
    writel(mode, iobase + offset + 0xc);
  102390:	f44f 7e03 	mov.w	r14, #524	; 0x20c
    writel(bw, iobase + offset + 0x10);
  102394:	f44f 7c04 	mov.w	r12, #528	; 0x210
    writel(satur, iobase + offset + 0x14);
  102398:	f44f 7505 	mov.w	r5, #532	; 0x214
  10239c:	6018      	str	r0, [r3, #0]
    writel(ext, iobase + offset + 0x18);
  10239e:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
  1023a2:	2300      	movs	r3, #0
    writel(pri, iobase + offset + 0x8);
  1023a4:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
  1023a8:	f2c8 0900 	movt	r9, #32768	; 0x8000
    writel(mode, iobase + offset + 0xc);
  1023ac:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1023b0:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1023b4:	f44f 7706 	mov.w	r7, #536	; 0x218
    writel(satur, iobase + offset + 0x14);
  1023b8:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1023bc:	2408      	movs	r4, #8
    writel(mode, iobase + offset + 0xc);
  1023be:	210c      	movs	r1, #12
    writel(ext, iobase + offset + 0x18);
  1023c0:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1023c4:	f2cf 04cf 	movt	r4, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1023c8:	f8ca 3000 	str.w	r3, [r10]
    writel(mode, iobase + offset + 0xc);
  1023cc:	f2cf 01cf 	movt	r1, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1023d0:	f8c8 9000 	str.w	r9, [r8]
    writel(bw, iobase + offset + 0x10);
  1023d4:	2610      	movs	r6, #16
    writel(mode, iobase + offset + 0xc);
  1023d6:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  1023da:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  1023de:	f8cc b000 	str.w	r11, [r12]
    writel(satur, iobase + offset + 0x14);
  1023e2:	f04f 0814 	mov.w	r8, #20
  1023e6:	6028      	str	r0, [r5, #0]
    writel(ext, iobase + offset + 0x18);
  1023e8:	f04f 0e18 	mov.w	r14, #24
    writel(pri, iobase + offset + 0x8);
  1023ec:	9d01      	ldr	r5, [sp, #4]
    writel(satur, iobase + offset + 0x14);
  1023ee:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1023f2:	603b      	str	r3, [r7, #0]
  1023f4:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1023f8:	6025      	str	r5, [r4, #0]
  1023fa:	f04f 0c88 	mov.w	r12, #136	; 0x88
    writel(mode, iobase + offset + 0xc);
  1023fe:	600a      	str	r2, [r1, #0]
    writel(bw, iobase + offset + 0x10);
  102400:	f240 1111 	movw	r1, #273	; 0x111
    writel(mode, iobase + offset + 0xc);
  102404:	f04f 0a8c 	mov.w	r10, #140	; 0x8c
    writel(pri, iobase + offset + 0x8);
  102408:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10240c:	6031      	str	r1, [r6, #0]
  10240e:	2790      	movs	r7, #144	; 0x90
    writel(satur, iobase + offset + 0x14);
  102410:	2494      	movs	r4, #148	; 0x94
    writel(ext, iobase + offset + 0x18);
  102412:	f04f 0998 	mov.w	r9, #152	; 0x98
    writel(pri, iobase + offset + 0x8);
  102416:	f44f 7684 	mov.w	r6, #264	; 0x108
    writel(mode, iobase + offset + 0xc);
  10241a:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10241e:	f8c8 0000 	str.w	r0, [r8]
    writel(bw, iobase + offset + 0x10);
  102422:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102426:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  10242a:	f2cf 04cf 	movt	r4, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  10242e:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102432:	f44f 7886 	mov.w	r8, #268	; 0x10c
    writel(pri, iobase + offset + 0x8);
  102436:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10243a:	f44f 7e88 	mov.w	r14, #272	; 0x110
    writel(mode, iobase + offset + 0xc);
  10243e:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102442:	f8cc 5000 	str.w	r5, [r12]
    writel(bw, iobase + offset + 0x10);
  102446:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  10244a:	f8ca 2000 	str.w	r2, [r10]
    writel(satur, iobase + offset + 0x14);
  10244e:	f44f 7c8a 	mov.w	r12, #276	; 0x114
    writel(bw, iobase + offset + 0x10);
  102452:	6039      	str	r1, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102454:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
  102458:	6020      	str	r0, [r4, #0]
    writel(ext, iobase + offset + 0x18);
  10245a:	f44f 7a8c 	mov.w	r10, #280	; 0x118
  10245e:	f8c9 3000 	str.w	r3, [r9]
    writel(pri, iobase + offset + 0x8);
  102462:	f44f 7722 	mov.w	r7, #648	; 0x288
  102466:	9501      	str	r5, [sp, #4]
  102468:	f240 7404 	movw	r4, #1796	; 0x704
  10246c:	6035      	str	r5, [r6, #0]
    writel(mode, iobase + offset + 0xc);
  10246e:	f44f 7923 	mov.w	r9, #652	; 0x28c
    writel(bw, iobase + offset + 0x10);
  102472:	f44f 7624 	mov.w	r6, #656	; 0x290
    writel(pri, iobase + offset + 0x8);
  102476:	f2c8 0400 	movt	r4, #32768	; 0x8000
    writel(mode, iobase + offset + 0xc);
  10247a:	f8c8 2000 	str.w	r2, [r8]
    writel(ext, iobase + offset + 0x18);
  10247e:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102482:	f8ce 1000 	str.w	r1, [r14]
    writel(pri, iobase + offset + 0x8);
  102486:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10248a:	f240 21d9 	movw	r1, #729	; 0x2d9
    writel(mode, iobase + offset + 0xc);
  10248e:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102492:	f8cc 0000 	str.w	r0, [r12]
    writel(bw, iobase + offset + 0x10);
  102496:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10249a:	f44f 7825 	mov.w	r8, #660	; 0x294
    writel(ext, iobase + offset + 0x18);
  10249e:	f44f 7e26 	mov.w	r14, #664	; 0x298
    writel(pri, iobase + offset + 0x8);
  1024a2:	f44f 7c42 	mov.w	r12, #776	; 0x308
    writel(mode, iobase + offset + 0xc);
  1024a6:	f44f 7543 	mov.w	r5, #780	; 0x30c
    writel(ext, iobase + offset + 0x18);
  1024aa:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  1024ae:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1024b2:	603c      	str	r4, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  1024b4:	f44f 7a00 	mov.w	r10, #512	; 0x200
    writel(mode, iobase + offset + 0xc);
  1024b8:	f8c9 2000 	str.w	r2, [r9]
    writel(ext, iobase + offset + 0x18);
  1024bc:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1024c0:	6031      	str	r1, [r6, #0]
    writel(pri, iobase + offset + 0x8);
  1024c2:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1024c6:	f44f 7744 	mov.w	r7, #784	; 0x310
    writel(mode, iobase + offset + 0xc);
  1024ca:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1024ce:	f44f 7945 	mov.w	r9, #788	; 0x314
    writel(ext, iobase + offset + 0x18);
  1024d2:	f44f 7646 	mov.w	r6, #792	; 0x318
    writel(bw, iobase + offset + 0x10);
  1024d6:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1024da:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  1024de:	f8c8 a000 	str.w	r10, [r8]
    writel(ext, iobase + offset + 0x18);
  1024e2:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  1024e6:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  1024ea:	f44f 7862 	mov.w	r8, #904	; 0x388
  1024ee:	f8cc 4000 	str.w	r4, [r12]
    writel(mode, iobase + offset + 0xc);
  1024f2:	f44f 7e63 	mov.w	r14, #908	; 0x38c
  1024f6:	602a      	str	r2, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1024f8:	f44f 7c64 	mov.w	r12, #912	; 0x390
    writel(satur, iobase + offset + 0x14);
  1024fc:	f44f 7565 	mov.w	r5, #916	; 0x394
    writel(pri, iobase + offset + 0x8);
  102500:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102504:	6039      	str	r1, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  102506:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10250a:	f8c9 0000 	str.w	r0, [r9]
    writel(bw, iobase + offset + 0x10);
  10250e:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102512:	6033      	str	r3, [r6, #0]
    writel(satur, iobase + offset + 0x14);
  102514:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102518:	f44f 7766 	mov.w	r7, #920	; 0x398
    writel(pri, iobase + offset + 0x8);
  10251c:	f44f 6981 	mov.w	r9, #1032	; 0x408
    writel(mode, iobase + offset + 0xc);
  102520:	f240 460c 	movw	r6, #1036	; 0x40c
    writel(ext, iobase + offset + 0x18);
  102524:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102528:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  10252c:	f8c8 4000 	str.w	r4, [r8]
    writel(mode, iobase + offset + 0xc);
  102530:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  102534:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  102538:	f44f 6882 	mov.w	r8, #1040	; 0x410
  10253c:	f8cc 1000 	str.w	r1, [r12]
    writel(satur, iobase + offset + 0x14);
  102540:	f240 4e14 	movw	r14, #1044	; 0x414
  102544:	f8c5 a000 	str.w	r10, [r5]
    writel(ext, iobase + offset + 0x18);
  102548:	f44f 6c83 	mov.w	r12, #1048	; 0x418
    writel(pri, iobase + offset + 0x8);
  10254c:	f44f 6591 	mov.w	r5, #1160	; 0x488
    writel(bw, iobase + offset + 0x10);
  102550:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102554:	603b      	str	r3, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102556:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  10255a:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  10255e:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102562:	6032      	str	r2, [r6, #0]
    writel(pri, iobase + offset + 0x8);
  102564:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102568:	f240 478c 	movw	r7, #1164	; 0x48c
    writel(bw, iobase + offset + 0x10);
  10256c:	f44f 6992 	mov.w	r9, #1168	; 0x490
    writel(satur, iobase + offset + 0x14);
  102570:	f240 4694 	movw	r6, #1172	; 0x494
    writel(mode, iobase + offset + 0xc);
  102574:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102578:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  10257c:	f8c8 1000 	str.w	r1, [r8]
    writel(satur, iobase + offset + 0x14);
  102580:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  102584:	f8ce 0000 	str.w	r0, [r14]
    writel(ext, iobase + offset + 0x18);
  102588:	f44f 6893 	mov.w	r8, #1176	; 0x498
  10258c:	f8cc 3000 	str.w	r3, [r12]
    writel(pri, iobase + offset + 0x8);
  102590:	f44f 6ea1 	mov.w	r14, #1288	; 0x508
  102594:	602c      	str	r4, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  102596:	f240 5c0c 	movw	r12, #1292	; 0x50c
    writel(bw, iobase + offset + 0x10);
  10259a:	f44f 65a2 	mov.w	r5, #1296	; 0x510
    writel(ext, iobase + offset + 0x18);
  10259e:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1025a2:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  1025a4:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1025a8:	f8c9 1000 	str.w	r1, [r9]
    writel(mode, iobase + offset + 0xc);
  1025ac:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1025b0:	f8c6 a000 	str.w	r10, [r6]
    writel(bw, iobase + offset + 0x10);
  1025b4:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1025b8:	f240 5714 	movw	r7, #1300	; 0x514
    writel(ext, iobase + offset + 0x18);
  1025bc:	f44f 66a3 	mov.w	r6, #1304	; 0x518
    writel(satur, iobase + offset + 0x14);
  1025c0:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1025c4:	f8c8 3000 	str.w	r3, [r8]
  1025c8:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1025cc:	f8ce 4000 	str.w	r4, [r14]
  1025d0:	f44f 69b1 	mov.w	r9, #1416	; 0x588
    writel(mode, iobase + offset + 0xc);
  1025d4:	f8cc 2000 	str.w	r2, [r12]
  1025d8:	f240 588c 	movw	r8, #1420	; 0x58c
    writel(bw, iobase + offset + 0x10);
  1025dc:	6029      	str	r1, [r5, #0]
  1025de:	f44f 6cb2 	mov.w	r12, #1424	; 0x590
    writel(satur, iobase + offset + 0x14);
  1025e2:	f240 5194 	movw	r1, #1428	; 0x594
    writel(ext, iobase + offset + 0x18);
  1025e6:	f44f 65b3 	mov.w	r5, #1432	; 0x598
    writel(pri, iobase + offset + 0x8);
  1025ea:	f44f 6ec1 	mov.w	r14, #1544	; 0x608
  1025ee:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1025f2:	6038      	str	r0, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  1025f4:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1025f8:	6033      	str	r3, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  1025fa:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1025fe:	f2cf 01cf 	movt	r1, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102602:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102606:	f240 670c 	movw	r7, #1548	; 0x60c
    writel(pri, iobase + offset + 0x8);
  10260a:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10260e:	f44f 66c2 	mov.w	r6, #1552	; 0x610
    writel(satur, iobase + offset + 0x14);
  102612:	f240 6a14 	movw	r10, #1556	; 0x614
    writel(mode, iobase + offset + 0xc);
  102616:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10261a:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  10261e:	f8c9 4000 	str.w	r4, [r9]
    writel(satur, iobase + offset + 0x14);
  102622:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102626:	f8c8 2000 	str.w	r2, [r8]
    writel(ext, iobase + offset + 0x18);
  10262a:	f44f 68c3 	mov.w	r8, #1560	; 0x618
    writel(bw, iobase + offset + 0x10);
  10262e:	f8cc b000 	str.w	r11, [r12]
    writel(pri, iobase + offset + 0x8);
  102632:	f04f 0c08 	mov.w	r12, #8
    writel(satur, iobase + offset + 0x14);
  102636:	6008      	str	r0, [r1, #0]
    writel(pri, iobase + offset + 0x8);
  102638:	f240 3101 	movw	r1, #769	; 0x301
    writel(ext, iobase + offset + 0x18);
  10263c:	602b      	str	r3, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  10263e:	250c      	movs	r5, #12
    writel(pri, iobase + offset + 0x8);
  102640:	f8ce 4000 	str.w	r4, [r14]
    writel(bw, iobase + offset + 0x10);
  102644:	2410      	movs	r4, #16
    writel(mode, iobase + offset + 0xc);
  102646:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102648:	f2c8 0100 	movt	r1, #32768	; 0x8000
    writel(bw, iobase + offset + 0x10);
  10264c:	f8c6 b000 	str.w	r11, [r6]
    writel(ext, iobase + offset + 0x18);
  102650:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102654:	f8ca 0000 	str.w	r0, [r10]
    writel(pri, iobase + offset + 0x8);
  102658:	f2cf 1c30 	movt	r12, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  10265c:	f240 2a0a 	movw	r10, #522	; 0x20a
    writel(mode, iobase + offset + 0xc);
  102660:	f2cf 1530 	movt	r5, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  102664:	f04f 0914 	mov.w	r9, #20
    writel(bw, iobase + offset + 0x10);
  102668:	f2cf 1430 	movt	r4, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  10266c:	f04f 0e18 	mov.w	r14, #24
    writel(pri, iobase + offset + 0x8);
  102670:	2788      	movs	r7, #136	; 0x88
  102672:	f240 4602 	movw	r6, #1026	; 0x402
    writel(satur, iobase + offset + 0x14);
  102676:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  10267a:	f8c8 3000 	str.w	r3, [r8]
    writel(pri, iobase + offset + 0x8);
  10267e:	f2c8 0600 	movt	r6, #32768	; 0x8000
  102682:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102686:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  10268a:	602a      	str	r2, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  10268c:	f2cf 1730 	movt	r7, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  102690:	f8c4 a000 	str.w	r10, [r4]
    writel(mode, iobase + offset + 0xc);
  102694:	f04f 0b8c 	mov.w	r11, #140	; 0x8c
    writel(satur, iobase + offset + 0x14);
  102698:	2440      	movs	r4, #64	; 0x40
    writel(bw, iobase + offset + 0x10);
  10269a:	f04f 0890 	mov.w	r8, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  10269e:	f2cf 1b30 	movt	r11, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  1026a2:	f04f 0c94 	mov.w	r12, #148	; 0x94
    writel(bw, iobase + offset + 0x10);
  1026a6:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1026aa:	2598      	movs	r5, #152	; 0x98
    writel(satur, iobase + offset + 0x14);
  1026ac:	f2cf 1c30 	movt	r12, #61744	; 0xf130
  1026b0:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  1026b4:	f2cf 1530 	movt	r5, #61744	; 0xf130
  1026b8:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  1026bc:	f44f 7984 	mov.w	r9, #264	; 0x108
  1026c0:	603e      	str	r6, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  1026c2:	f44f 7e86 	mov.w	r14, #268	; 0x10c
    writel(bw, iobase + offset + 0x10);
  1026c6:	f44f 7788 	mov.w	r7, #272	; 0x110
    writel(pri, iobase + offset + 0x8);
  1026ca:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  1026ce:	f8cb 2000 	str.w	r2, [r11]
  1026d2:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  1026d6:	f8c8 a000 	str.w	r10, [r8]
  1026da:	f2cf 1730 	movt	r7, #61744	; 0xf130
  1026de:	f240 1aeb 	movw	r10, #491	; 0x1eb
    writel(satur, iobase + offset + 0x14);
  1026e2:	f44f 788a 	mov.w	r8, #276	; 0x114
  1026e6:	f8cc 4000 	str.w	r4, [r12]
  1026ea:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1026ee:	602b      	str	r3, [r5, #0]
  1026f0:	f44f 7c8c 	mov.w	r12, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  1026f4:	f44f 75c4 	mov.w	r5, #392	; 0x188
    writel(ext, iobase + offset + 0x18);
  1026f8:	f2cf 1c30 	movt	r12, #61744	; 0xf130
    writel(pri, iobase + offset + 0x8);
  1026fc:	f8c9 6000 	str.w	r6, [r9]
  102700:	f2cf 1530 	movt	r5, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  102704:	f8ce 2000 	str.w	r2, [r14]
  102708:	f44f 79c6 	mov.w	r9, #396	; 0x18c
    writel(bw, iobase + offset + 0x10);
  10270c:	f8c7 a000 	str.w	r10, [r7]
  102710:	f44f 7ec8 	mov.w	r14, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  102714:	f44f 77ca 	mov.w	r7, #404	; 0x194
    writel(mode, iobase + offset + 0xc);
  102718:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  10271c:	f8c8 4000 	str.w	r4, [r8]
    writel(bw, iobase + offset + 0x10);
  102720:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  102724:	f44f 78cc 	mov.w	r8, #408	; 0x198
    writel(satur, iobase + offset + 0x14);
  102728:	f2cf 1730 	movt	r7, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  10272c:	f8cc 3000 	str.w	r3, [r12]
  102730:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(pri, iobase + offset + 0x8);
  102734:	602e      	str	r6, [r5, #0]
  102736:	f04f 0c08 	mov.w	r12, #8
    writel(mode, iobase + offset + 0xc);
  10273a:	250c      	movs	r5, #12
    writel(pri, iobase + offset + 0x8);
  10273c:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  102740:	f8c9 2000 	str.w	r2, [r9]
  102744:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102748:	f8ce a000 	str.w	r10, [r14]
  10274c:	f04f 0910 	mov.w	r9, #16
    writel(satur, iobase + offset + 0x14);
  102750:	603c      	str	r4, [r7, #0]
  102752:	f04f 0e14 	mov.w	r14, #20
    writel(ext, iobase + offset + 0x18);
  102756:	2718      	movs	r7, #24
    writel(pri, iobase + offset + 0x8);
  102758:	f04f 0a88 	mov.w	r10, #136	; 0x88
    writel(ext, iobase + offset + 0x18);
  10275c:	f8c8 3000 	str.w	r3, [r8]
    writel(bw, iobase + offset + 0x10);
  102760:	f2cf 1947 	movt	r9, #61767	; 0xf147
  102764:	f44f 7890 	mov.w	r8, #288	; 0x120
    writel(satur, iobase + offset + 0x14);
  102768:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  10276c:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102770:	f8cc 1000 	str.w	r1, [r12]
  102774:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  102778:	602a      	str	r2, [r5, #0]
  10277a:	f04f 0c8c 	mov.w	r12, #140	; 0x8c
    writel(bw, iobase + offset + 0x10);
  10277e:	2590      	movs	r5, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  102780:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102784:	f8c9 8000 	str.w	r8, [r9]
  102788:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  10278c:	f8ce 4000 	str.w	r4, [r14]
  102790:	f04f 0994 	mov.w	r9, #148	; 0x94
    writel(ext, iobase + offset + 0x18);
  102794:	603b      	str	r3, [r7, #0]
  102796:	f04f 0e98 	mov.w	r14, #152	; 0x98
    writel(pri, iobase + offset + 0x8);
  10279a:	f8ca 1000 	str.w	r1, [r10]
  10279e:	f44f 7784 	mov.w	r7, #264	; 0x108
    writel(mode, iobase + offset + 0xc);
  1027a2:	f44f 7a86 	mov.w	r10, #268	; 0x10c
    writel(satur, iobase + offset + 0x14);
  1027a6:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1027aa:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1027ae:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  1027b2:	f8cc 2000 	str.w	r2, [r12]
  1027b6:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1027ba:	602b      	str	r3, [r5, #0]
  1027bc:	f44f 7c88 	mov.w	r12, #272	; 0x110
    writel(satur, iobase + offset + 0x14);
  1027c0:	f44f 758a 	mov.w	r5, #276	; 0x114
    writel(bw, iobase + offset + 0x10);
  1027c4:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1027c8:	f8c9 4000 	str.w	r4, [r9]
  1027cc:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1027d0:	f8ce 3000 	str.w	r3, [r14]
  1027d4:	f44f 798c 	mov.w	r9, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  1027d8:	6039      	str	r1, [r7, #0]
  1027da:	f44f 7ec4 	mov.w	r14, #392	; 0x188
    writel(mode, iobase + offset + 0xc);
  1027de:	f8ca 2000 	str.w	r2, [r10]
  1027e2:	f44f 77c6 	mov.w	r7, #396	; 0x18c
    writel(bw, iobase + offset + 0x10);
  1027e6:	f04f 0a30 	mov.w	r10, #48	; 0x30
    writel(ext, iobase + offset + 0x18);
  1027ea:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1027ee:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1027f2:	f8cc a000 	str.w	r10, [r12]
    writel(mode, iobase + offset + 0xc);
  1027f6:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1027fa:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1027fc:	f44f 7cc8 	mov.w	r12, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  102800:	f44f 75ca 	mov.w	r5, #404	; 0x194
    writel(bw, iobase + offset + 0x10);
  102804:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  102808:	f8c9 3000 	str.w	r3, [r9]
    writel(satur, iobase + offset + 0x14);
  10280c:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102810:	f8ce 1000 	str.w	r1, [r14]
    writel(ext, iobase + offset + 0x18);
  102814:	f44f 7acc 	mov.w	r10, #408	; 0x198
    writel(mode, iobase + offset + 0xc);
  102818:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  10281a:	f44f 7902 	mov.w	r9, #520	; 0x208
    writel(bw, iobase + offset + 0x10);
  10281e:	2790      	movs	r7, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  102820:	f44f 7e03 	mov.w	r14, #524	; 0x20c
    writel(ext, iobase + offset + 0x18);
  102824:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102828:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  10282c:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  102830:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  102834:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  102836:	f44f 7c04 	mov.w	r12, #528	; 0x210
    writel(satur, iobase + offset + 0x14);
  10283a:	f44f 7505 	mov.w	r5, #532	; 0x214
    writel(bw, iobase + offset + 0x10);
  10283e:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  102842:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  102846:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  10284a:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  10284e:	f44f 7a06 	mov.w	r10, #536	; 0x218
    writel(mode, iobase + offset + 0xc);
  102852:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  102856:	f44f 7922 	mov.w	r9, #648	; 0x288
    writel(mode, iobase + offset + 0xc);
  10285a:	f44f 7e23 	mov.w	r14, #652	; 0x28c
    writel(ext, iobase + offset + 0x18);
  10285e:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102862:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102866:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  10286a:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  10286e:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  102870:	f44f 7c24 	mov.w	r12, #656	; 0x290
    writel(satur, iobase + offset + 0x14);
  102874:	f44f 7525 	mov.w	r5, #660	; 0x294
    writel(bw, iobase + offset + 0x10);
  102878:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  10287c:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  102880:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102884:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  102888:	f44f 7a26 	mov.w	r10, #664	; 0x298
    writel(mode, iobase + offset + 0xc);
  10288c:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  102890:	f44f 7942 	mov.w	r9, #776	; 0x308
    writel(mode, iobase + offset + 0xc);
  102894:	f44f 7e43 	mov.w	r14, #780	; 0x30c
    writel(ext, iobase + offset + 0x18);
  102898:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  10289c:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1028a0:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  1028a4:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1028a8:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1028aa:	f44f 7c44 	mov.w	r12, #784	; 0x310
    writel(satur, iobase + offset + 0x14);
  1028ae:	f44f 7545 	mov.w	r5, #788	; 0x314
    writel(bw, iobase + offset + 0x10);
  1028b2:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1028b6:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  1028ba:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028be:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  1028c2:	f44f 7a46 	mov.w	r10, #792	; 0x318
    writel(mode, iobase + offset + 0xc);
  1028c6:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  1028ca:	f44f 7962 	mov.w	r9, #904	; 0x388
    writel(mode, iobase + offset + 0xc);
  1028ce:	f44f 7e63 	mov.w	r14, #908	; 0x38c
    writel(ext, iobase + offset + 0x18);
  1028d2:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028d6:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1028da:	f8cc 3000 	str.w	r3, [r12]
    writel(mode, iobase + offset + 0xc);
  1028de:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1028e2:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1028e4:	f44f 7c64 	mov.w	r12, #912	; 0x390
    writel(satur, iobase + offset + 0x14);
  1028e8:	f44f 7565 	mov.w	r5, #916	; 0x394
    writel(bw, iobase + offset + 0x10);
  1028ec:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1028f0:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  1028f4:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028f8:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  1028fc:	f44f 7a66 	mov.w	r10, #920	; 0x398
    writel(mode, iobase + offset + 0xc);
  102900:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  102904:	f04f 0ed8 	mov.w	r14, #216	; 0xd8
    writel(pri, iobase + offset + 0x8);
  102908:	f242 1908 	movw	r9, #8456	; 0x2108
    writel(ext, iobase + offset + 0x18);
  10290c:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102910:	f8cc e000 	str.w	r14, [r12]
    writel(pri, iobase + offset + 0x8);
  102914:	f240 4c03 	movw	r12, #1027	; 0x403
    writel(satur, iobase + offset + 0x14);
  102918:	602c      	str	r4, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  10291a:	f242 150c 	movw	r5, #8460	; 0x210c
    writel(pri, iobase + offset + 0x8);
  10291e:	f2c8 0c00 	movt	r12, #32768	; 0x8000
  102922:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102926:	f242 1410 	movw	r4, #8464	; 0x2110
    writel(mode, iobase + offset + 0xc);
  10292a:	f2cf 154c 	movt	r5, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  10292e:	f8ca 3000 	str.w	r3, [r10]
    writel(bw, iobase + offset + 0x10);
  102932:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102936:	f242 1e14 	movw	r14, #8468	; 0x2114
    writel(ext, iobase + offset + 0x18);
  10293a:	f242 1b18 	movw	r11, #8472	; 0x2118
    writel(pri, iobase + offset + 0x8);
  10293e:	f242 1a88 	movw	r10, #8584	; 0x2188
    writel(satur, iobase + offset + 0x14);
  102942:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102946:	f8c9 c000 	str.w	r12, [r9]
    writel(ext, iobase + offset + 0x18);
  10294a:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  10294e:	602a      	str	r2, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  102950:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102954:	2510      	movs	r5, #16
    writel(mode, iobase + offset + 0xc);
  102956:	f242 198c 	movw	r9, #8588	; 0x218c
    writel(bw, iobase + offset + 0x10);
  10295a:	6023      	str	r3, [r4, #0]
  10295c:	f242 1490 	movw	r4, #8592	; 0x2190
    writel(satur, iobase + offset + 0x14);
  102960:	f8ce 5000 	str.w	r5, [r14]
    writel(mode, iobase + offset + 0xc);
  102964:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102968:	f8cb 3000 	str.w	r3, [r11]
    writel(bw, iobase + offset + 0x10);
  10296c:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102970:	f8ca c000 	str.w	r12, [r10]
    writel(satur, iobase + offset + 0x14);
  102974:	f242 1e94 	movw	r14, #8596	; 0x2194
    writel(ext, iobase + offset + 0x18);
  102978:	f242 1b98 	movw	r11, #8600	; 0x2198
    writel(pri, iobase + offset + 0x8);
  10297c:	f242 2a08 	movw	r10, #8712	; 0x2208
    writel(satur, iobase + offset + 0x14);
  102980:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102984:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102988:	f8c9 2000 	str.w	r2, [r9]
    writel(pri, iobase + offset + 0x8);
  10298c:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102990:	6023      	str	r3, [r4, #0]
    writel(mode, iobase + offset + 0xc);
  102992:	f242 290c 	movw	r9, #8716	; 0x220c
    writel(bw, iobase + offset + 0x10);
  102996:	f242 2410 	movw	r4, #8720	; 0x2210
    writel(mode, iobase + offset + 0xc);
  10299a:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  10299e:	f8ce 5000 	str.w	r5, [r14]
    writel(bw, iobase + offset + 0x10);
  1029a2:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029a6:	f8cb 3000 	str.w	r3, [r11]
    writel(satur, iobase + offset + 0x14);
  1029aa:	f242 2e14 	movw	r14, #8724	; 0x2214
    writel(pri, iobase + offset + 0x8);
  1029ae:	f8ca c000 	str.w	r12, [r10]
    writel(ext, iobase + offset + 0x18);
  1029b2:	f242 2b18 	movw	r11, #8728	; 0x2218
    writel(pri, iobase + offset + 0x8);
  1029b6:	f242 2a88 	movw	r10, #8840	; 0x2288
    writel(satur, iobase + offset + 0x14);
  1029ba:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029be:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  1029c2:	f8c9 2000 	str.w	r2, [r9]
    writel(pri, iobase + offset + 0x8);
  1029c6:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  1029ca:	6027      	str	r7, [r4, #0]
    writel(mode, iobase + offset + 0xc);
  1029cc:	f242 298c 	movw	r9, #8844	; 0x228c
    writel(bw, iobase + offset + 0x10);
  1029d0:	f242 2490 	movw	r4, #8848	; 0x2290
    writel(mode, iobase + offset + 0xc);
  1029d4:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  1029d8:	f8ce 5000 	str.w	r5, [r14]
    writel(bw, iobase + offset + 0x10);
  1029dc:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029e0:	f8cb 3000 	str.w	r3, [r11]
    writel(satur, iobase + offset + 0x14);
  1029e4:	f242 2e94 	movw	r14, #8852	; 0x2294
    writel(pri, iobase + offset + 0x8);
  1029e8:	f8ca c000 	str.w	r12, [r10]
  1029ec:	f242 3b08 	movw	r11, #8968	; 0x2308
    writel(ext, iobase + offset + 0x18);
  1029f0:	f242 2c98 	movw	r12, #8856	; 0x2298
    writel(mode, iobase + offset + 0xc);
  1029f4:	f242 3a0c 	movw	r10, #8972	; 0x230c
    writel(satur, iobase + offset + 0x14);
  1029f8:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029fc:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102a00:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a04:	f8c9 2000 	str.w	r2, [r9]
  102a08:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102a0c:	6027      	str	r7, [r4, #0]
  102a0e:	f242 3410 	movw	r4, #8976	; 0x2310
    writel(pri, iobase + offset + 0x8);
  102a12:	9f01      	ldr	r7, [sp, #4]
    writel(bw, iobase + offset + 0x10);
  102a14:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a18:	f8ce 5000 	str.w	r5, [r14]
  102a1c:	f242 3914 	movw	r9, #8980	; 0x2314
    writel(ext, iobase + offset + 0x18);
  102a20:	f8cc 3000 	str.w	r3, [r12]
    writel(satur, iobase + offset + 0x14);
  102a24:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102a28:	f8cb 7000 	str.w	r7, [r11]
    writel(ext, iobase + offset + 0x18);
  102a2c:	f242 3e18 	movw	r14, #8984	; 0x2318
    writel(mode, iobase + offset + 0xc);
  102a30:	f8ca 2000 	str.w	r2, [r10]
    writel(bw, iobase + offset + 0x10);
  102a34:	f04f 0a1c 	mov.w	r10, #28
    writel(pri, iobase + offset + 0x8);
  102a38:	f242 4c88 	movw	r12, #9352	; 0x2488
    writel(mode, iobase + offset + 0xc);
  102a3c:	f242 478c 	movw	r7, #9356	; 0x248c
    writel(bw, iobase + offset + 0x10);
  102a40:	f8c4 a000 	str.w	r10, [r4]
    writel(satur, iobase + offset + 0x14);
  102a44:	2408      	movs	r4, #8
    writel(bw, iobase + offset + 0x10);
  102a46:	f242 4a90 	movw	r10, #9360	; 0x2490
    writel(ext, iobase + offset + 0x18);
  102a4a:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a4e:	f8c9 4000 	str.w	r4, [r9]
    writel(pri, iobase + offset + 0x8);
  102a52:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a56:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a5a:	f242 4994 	movw	r9, #9364	; 0x2494
    writel(bw, iobase + offset + 0x10);
  102a5e:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a62:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102a66:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102a6a:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102a6e:	f242 4e98 	movw	r14, #9368	; 0x2498
    writel(mode, iobase + offset + 0xc);
  102a72:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102a74:	f242 5c08 	movw	r12, #9480	; 0x2508
    writel(bw, iobase + offset + 0x10);
  102a78:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102a7c:	f242 570c 	movw	r7, #9484	; 0x250c
    writel(bw, iobase + offset + 0x10);
  102a80:	f242 5a10 	movw	r10, #9488	; 0x2510
    writel(ext, iobase + offset + 0x18);
  102a84:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a88:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102a8c:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a90:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a94:	f242 5914 	movw	r9, #9492	; 0x2514
    writel(bw, iobase + offset + 0x10);
  102a98:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a9c:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102aa0:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102aa4:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102aa8:	f242 5e18 	movw	r14, #9496	; 0x2518
    writel(mode, iobase + offset + 0xc);
  102aac:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102aae:	f242 5c88 	movw	r12, #9608	; 0x2588
    writel(bw, iobase + offset + 0x10);
  102ab2:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102ab6:	f242 578c 	movw	r7, #9612	; 0x258c
    writel(bw, iobase + offset + 0x10);
  102aba:	f242 5a90 	movw	r10, #9616	; 0x2590
    writel(ext, iobase + offset + 0x18);
  102abe:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102ac2:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102ac6:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102aca:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102ace:	f242 5994 	movw	r9, #9620	; 0x2594
    writel(bw, iobase + offset + 0x10);
  102ad2:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102ad6:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102ada:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102ade:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102ae2:	f242 5e98 	movw	r14, #9624	; 0x2598
    writel(mode, iobase + offset + 0xc);
  102ae6:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102ae8:	f44f 6c91 	mov.w	r12, #1160	; 0x488
    writel(bw, iobase + offset + 0x10);
  102aec:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102af0:	f240 478c 	movw	r7, #1164	; 0x48c
    writel(bw, iobase + offset + 0x10);
  102af4:	f44f 6a92 	mov.w	r10, #1168	; 0x490
    writel(ext, iobase + offset + 0x18);
  102af8:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102afc:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102b00:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102b04:	20f5      	movs	r0, #245	; 0xf5
    writel(mode, iobase + offset + 0xc);
  102b06:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102b0a:	f240 4b94 	movw	r11, #1172	; 0x494
    writel(bw, iobase + offset + 0x10);
  102b0e:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102b12:	f44f 6993 	mov.w	r9, #1176	; 0x498
    writel(pri, iobase + offset + 0x8);
  102b16:	f44f 68a1 	mov.w	r8, #1288	; 0x508
    writel(ext, iobase + offset + 0x18);
  102b1a:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102b1e:	f2cf 0b6c 	movt	r11, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102b22:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102b26:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102b2a:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102b2c:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102b30:	f8ca 0000 	str.w	r0, [r10]
    writel(mode, iobase + offset + 0xc);
  102b34:	f240 5e0c 	movw	r14, #1292	; 0x50c
    writel(satur, iobase + offset + 0x14);
  102b38:	f04f 0a20 	mov.w	r10, #32
    writel(mode, iobase + offset + 0xc);
  102b3c:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102b40:	f44f 6ca2 	mov.w	r12, #1296	; 0x510
    writel(satur, iobase + offset + 0x14);
  102b44:	f240 5714 	movw	r7, #1300	; 0x514
  102b48:	f8cb a000 	str.w	r10, [r11]
    writel(bw, iobase + offset + 0x10);
  102b4c:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102b50:	f8c9 3000 	str.w	r3, [r9]
    writel(satur, iobase + offset + 0x14);
  102b54:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102b58:	f8c8 6000 	str.w	r6, [r8]
    writel(bw, iobase + offset + 0x10);
  102b5c:	f04f 084c 	mov.w	r8, #76	; 0x4c
    writel(mode, iobase + offset + 0xc);
  102b60:	f8ce 2000 	str.w	r2, [r14]
    writel(ext, iobase + offset + 0x18);
  102b64:	f44f 6ba3 	mov.w	r11, #1304	; 0x518
    writel(pri, iobase + offset + 0x8);
  102b68:	f44f 66b1 	mov.w	r6, #1416	; 0x588
    writel(mode, iobase + offset + 0xc);
  102b6c:	f240 5e8c 	movw	r14, #1420	; 0x58c
    writel(bw, iobase + offset + 0x10);
  102b70:	f8cc 8000 	str.w	r8, [r12]
    writel(ext, iobase + offset + 0x18);
  102b74:	f2cf 0b6c 	movt	r11, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102b78:	603d      	str	r5, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102b7a:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102b7e:	f44f 6cb2 	mov.w	r12, #1424	; 0x590
    writel(mode, iobase + offset + 0xc);
  102b82:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102b86:	f240 5894 	movw	r8, #1428	; 0x594
    writel(ext, iobase + offset + 0x18);
  102b8a:	f44f 67b3 	mov.w	r7, #1432	; 0x598
    writel(pri, iobase + offset + 0x8);
  102b8e:	f44f 65c1 	mov.w	r5, #1544	; 0x608
    writel(mode, iobase + offset + 0xc);
  102b92:	f240 690c 	movw	r9, #1548	; 0x60c
    writel(bw, iobase + offset + 0x10);
  102b96:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102b9a:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102b9e:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102ba2:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102ba6:	f8cb 3000 	str.w	r3, [r11]
    writel(mode, iobase + offset + 0xc);
  102baa:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102bae:	6031      	str	r1, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  102bb0:	f44f 66c2 	mov.w	r6, #1552	; 0x610
    writel(mode, iobase + offset + 0xc);
  102bb4:	f8ce 2000 	str.w	r2, [r14]
    writel(satur, iobase + offset + 0x14);
  102bb8:	f240 6e14 	movw	r14, #1556	; 0x614
    writel(bw, iobase + offset + 0x10);
  102bbc:	f8cc 0000 	str.w	r0, [r12]
  102bc0:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102bc4:	f8c8 a000 	str.w	r10, [r8]
  102bc8:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102bcc:	603b      	str	r3, [r7, #0]
  102bce:	f44f 6cc3 	mov.w	r12, #1560	; 0x618
    writel(pri, iobase + offset + 0x8);
  102bd2:	6029      	str	r1, [r5, #0]
    writel(ext, iobase + offset + 0x18);
  102bd4:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102bd8:	f8c9 2000 	str.w	r2, [r9]
    writel(bw, iobase + offset + 0x10);
  102bdc:	f04f 097a 	mov.w	r9, #122	; 0x7a
    writel(pri, iobase + offset + 0x8);
  102be0:	f44f 68d1 	mov.w	r8, #1672	; 0x688
    writel(mode, iobase + offset + 0xc);
  102be4:	f240 678c 	movw	r7, #1676	; 0x68c
    writel(bw, iobase + offset + 0x10);
  102be8:	f8c6 9000 	str.w	r9, [r6]
    writel(pri, iobase + offset + 0x8);
  102bec:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102bf0:	f8ce a000 	str.w	r10, [r14]
    writel(mode, iobase + offset + 0xc);
  102bf4:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102bf8:	f44f 65d2 	mov.w	r5, #1680	; 0x690
    writel(satur, iobase + offset + 0x14);
  102bfc:	f240 6094 	movw	r0, #1684	; 0x694
    writel(ext, iobase + offset + 0x18);
  102c00:	f44f 66d3 	mov.w	r6, #1688	; 0x698
    writel(pri, iobase + offset + 0x8);
  102c04:	f44f 6ee1 	mov.w	r14, #1800	; 0x708
    writel(ext, iobase + offset + 0x18);
  102c08:	f8cc 3000 	str.w	r3, [r12]
    writel(bw, iobase + offset + 0x10);
  102c0c:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c10:	f2cf 006c 	movt	r0, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102c14:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102c18:	f240 7c0c 	movw	r12, #1804	; 0x70c
    writel(pri, iobase + offset + 0x8);
  102c1c:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102c20:	f8c8 1000 	str.w	r1, [r8]
    writel(mode, iobase + offset + 0xc);
  102c24:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102c28:	603a      	str	r2, [r7, #0]
    writel(bw, iobase + offset + 0x10);
  102c2a:	f44f 68e2 	mov.w	r8, #1808	; 0x710
    writel(satur, iobase + offset + 0x14);
  102c2e:	f240 7714 	movw	r7, #1812	; 0x714
    writel(bw, iobase + offset + 0x10);
  102c32:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102c36:	f8c5 9000 	str.w	r9, [r5]
    writel(satur, iobase + offset + 0x14);
  102c3a:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102c3e:	f8c0 a000 	str.w	r10, [r0]
    writel(ext, iobase + offset + 0x18);
  102c42:	f44f 65e3 	mov.w	r5, #1816	; 0x718
    writel(bw, iobase + offset + 0x10);
  102c46:	203d      	movs	r0, #61	; 0x3d
    writel(pri, iobase + offset + 0x8);
  102c48:	f44f 69f1 	mov.w	r9, #1928	; 0x788
    writel(ext, iobase + offset + 0x18);
  102c4c:	6033      	str	r3, [r6, #0]
    writel(mode, iobase + offset + 0xc);
  102c4e:	f240 768c 	movw	r6, #1932	; 0x78c
    writel(pri, iobase + offset + 0x8);
  102c52:	f8ce 1000 	str.w	r1, [r14]
    writel(bw, iobase + offset + 0x10);
  102c56:	f44f 6ef2 	mov.w	r14, #1936	; 0x790
    writel(mode, iobase + offset + 0xc);
  102c5a:	f8cc 2000 	str.w	r2, [r12]
    writel(ext, iobase + offset + 0x18);
  102c5e:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102c62:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102c66:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c6a:	f240 7c94 	movw	r12, #1940	; 0x794
    writel(bw, iobase + offset + 0x10);
  102c6e:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102c72:	f8c8 0000 	str.w	r0, [r8]
    writel(satur, iobase + offset + 0x14);
  102c76:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102c7a:	f8c7 a000 	str.w	r10, [r7]
    writel(ext, iobase + offset + 0x18);
  102c7e:	f44f 68f3 	mov.w	r8, #1944	; 0x798
    writel(pri, iobase + offset + 0x8);
  102c82:	f640 0708 	movw	r7, #2056	; 0x808
    writel(ext, iobase + offset + 0x18);
  102c86:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102c8a:	602b      	str	r3, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  102c8c:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102c90:	f8c9 1000 	str.w	r1, [r9]
    writel(mode, iobase + offset + 0xc);
  102c94:	f640 0a0c 	movw	r10, #2060	; 0x80c
  102c98:	6032      	str	r2, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  102c9a:	f44f 6501 	mov.w	r5, #2064	; 0x810
  102c9e:	f8ce 0000 	str.w	r0, [r14]
    writel(satur, iobase + offset + 0x14);
  102ca2:	f640 0914 	movw	r9, #2068	; 0x814
    writel(ext, iobase + offset + 0x18);
  102ca6:	f640 0e18 	movw	r14, #2072	; 0x818
    writel(mode, iobase + offset + 0xc);
  102caa:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102cae:	f8cc 4000 	str.w	r4, [r12]
    writel(bw, iobase + offset + 0x10);
  102cb2:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102cb6:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102cba:	f640 0c88 	movw	r12, #2184	; 0x888
    writel(ext, iobase + offset + 0x18);
  102cbe:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102cc2:	f8c8 3000 	str.w	r3, [r8]
    writel(pri, iobase + offset + 0x8);
  102cc6:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102cca:	6039      	str	r1, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  102ccc:	f640 088c 	movw	r8, #2188	; 0x88c
    writel(bw, iobase + offset + 0x10);
  102cd0:	f44f 6709 	mov.w	r7, #2192	; 0x890
    writel(mode, iobase + offset + 0xc);
  102cd4:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102cd8:	f8ca 2000 	str.w	r2, [r10]
    writel(bw, iobase + offset + 0x10);
  102cdc:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102ce0:	6028      	str	r0, [r5, #0]
    writel(satur, iobase + offset + 0x14);
  102ce2:	f640 0694 	movw	r6, #2196	; 0x894
  102ce6:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  102cea:	f640 0a98 	movw	r10, #2200	; 0x898
  102cee:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  102cf2:	f640 1908 	movw	r9, #2312	; 0x908
    writel(mode, iobase + offset + 0xc);
  102cf6:	f640 1e0c 	movw	r14, #2316	; 0x90c
    writel(satur, iobase + offset + 0x14);
  102cfa:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102cfe:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102d02:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d06:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102d0a:	f44f 6c11 	mov.w	r12, #2320	; 0x910
    writel(mode, iobase + offset + 0xc);
  102d0e:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102d12:	f8c8 2000 	str.w	r2, [r8]
    writel(bw, iobase + offset + 0x10);
  102d16:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102d1a:	6038      	str	r0, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102d1c:	f640 1814 	movw	r8, #2324	; 0x914
    writel(ext, iobase + offset + 0x18);
  102d20:	f640 1518 	movw	r5, #2328	; 0x918
    writel(pri, iobase + offset + 0x8);
  102d24:	f640 1788 	movw	r7, #2440	; 0x988
    writel(satur, iobase + offset + 0x14);
  102d28:	6034      	str	r4, [r6, #0]
  102d2a:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102d2e:	f8ca 3000 	str.w	r3, [r10]
  102d32:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d36:	f8c9 1000 	str.w	r1, [r9]
  102d3a:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102d3e:	f8ce 2000 	str.w	r2, [r14]
  102d42:	f640 1a8c 	movw	r10, #2444	; 0x98c
    writel(bw, iobase + offset + 0x10);
  102d46:	f44f 6919 	mov.w	r9, #2448	; 0x990
    writel(satur, iobase + offset + 0x14);
  102d4a:	f640 1e94 	movw	r14, #2452	; 0x994
    writel(bw, iobase + offset + 0x10);
  102d4e:	f8cc 0000 	str.w	r0, [r12]
    writel(mode, iobase + offset + 0xc);
  102d52:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102d56:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102d5a:	f640 1c98 	movw	r12, #2456	; 0x998
    writel(satur, iobase + offset + 0x14);
  102d5e:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d62:	f640 2608 	movw	r6, #2568	; 0xa08
    writel(ext, iobase + offset + 0x18);
  102d66:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102d6a:	f8c8 4000 	str.w	r4, [r8]
    writel(pri, iobase + offset + 0x8);
  102d6e:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102d72:	602b      	str	r3, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  102d74:	f640 280c 	movw	r8, #2572	; 0xa0c
    writel(pri, iobase + offset + 0x8);
  102d78:	6039      	str	r1, [r7, #0]
    writel(bw, iobase + offset + 0x10);
  102d7a:	f44f 6721 	mov.w	r7, #2576	; 0xa10
    writel(mode, iobase + offset + 0xc);
  102d7e:	f8ca 2000 	str.w	r2, [r10]
  102d82:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102d86:	f8c9 0000 	str.w	r0, [r9]
  102d8a:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102d8e:	f8ce 4000 	str.w	r4, [r14]
  102d92:	f640 2a14 	movw	r10, #2580	; 0xa14
    writel(ext, iobase + offset + 0x18);
  102d96:	f640 2918 	movw	r9, #2584	; 0xa18
    writel(pri, iobase + offset + 0x8);
  102d9a:	f640 2e88 	movw	r14, #2696	; 0xa88
    writel(ext, iobase + offset + 0x18);
  102d9e:	f8cc 3000 	str.w	r3, [r12]
    writel(satur, iobase + offset + 0x14);
  102da2:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102da6:	6031      	str	r1, [r6, #0]
    writel(ext, iobase + offset + 0x18);
  102da8:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102dac:	f640 258c 	movw	r5, #2700	; 0xa8c
    writel(pri, iobase + offset + 0x8);
  102db0:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102db4:	f44f 6629 	mov.w	r6, #2704	; 0xa90
    writel(mode, iobase + offset + 0xc);
  102db8:	f2cf 056c 	movt	r5, #61548	; 0xf06c
  102dbc:	f8c8 2000 	str.w	r2, [r8]
    writel(bw, iobase + offset + 0x10);
  102dc0:	f2cf 066c 	movt	r6, #61548	; 0xf06c
  102dc4:	6038      	str	r0, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102dc6:	f640 2c94 	movw	r12, #2708	; 0xa94
    writel(ext, iobase + offset + 0x18);
  102dca:	f640 2798 	movw	r7, #2712	; 0xa98
    writel(satur, iobase + offset + 0x14);
  102dce:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102dd2:	f8ca 4000 	str.w	r4, [r10]
    writel(ext, iobase + offset + 0x18);
  102dd6:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102dda:	f8c9 3000 	str.w	r3, [r9]
    writel(pri, iobase + offset + 0x8);
  102dde:	f44f 7884 	mov.w	r8, #264	; 0x108
  102de2:	f8ce 1000 	str.w	r1, [r14]
    writel(mode, iobase + offset + 0xc);
  102de6:	f44f 7986 	mov.w	r9, #268	; 0x10c
    writel(bw, iobase + offset + 0x10);
  102dea:	f44f 7a88 	mov.w	r10, #272	; 0x110
    writel(satur, iobase + offset + 0x14);
  102dee:	f44f 7e8a 	mov.w	r14, #276	; 0x114
    writel(ext, iobase + offset + 0x18);
  102df2:	f44f 718c 	mov.w	r1, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  102df6:	f2cf 086e 	movt	r8, #61550	; 0xf06e
    writel(mode, iobase + offset + 0xc);
  102dfa:	602a      	str	r2, [r5, #0]
  102dfc:	f2cf 096e 	movt	r9, #61550	; 0xf06e
    writel(bw, iobase + offset + 0x10);
  102e00:	6030      	str	r0, [r6, #0]
  102e02:	f2cf 0a6e 	movt	r10, #61550	; 0xf06e
    writel(satur, iobase + offset + 0x14);
  102e06:	f2cf 0e6e 	movt	r14, #61550	; 0xf06e
    writel(bw, iobase + offset + 0x10);
  102e0a:	2099      	movs	r0, #153	; 0x99
    writel(ext, iobase + offset + 0x18);
  102e0c:	f2cf 016e 	movt	r1, #61550	; 0xf06e
    writel(satur, iobase + offset + 0x14);
  102e10:	f8cc 4000 	str.w	r4, [r12]
    writel(ext, iobase + offset + 0x18);
  102e14:	603b      	str	r3, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102e16:	9f01      	ldr	r7, [sp, #4]
  102e18:	f8c8 7000 	str.w	r7, [r8]
    writel(mode, iobase + offset + 0xc);
  102e1c:	f8c9 2000 	str.w	r2, [r9]
    writel(bw, iobase + offset + 0x10);
  102e20:	f8ca 0000 	str.w	r0, [r10]
    writel(satur, iobase + offset + 0x14);
  102e24:	f8ce 4000 	str.w	r4, [r14]
    writel(ext, iobase + offset + 0x18);
  102e28:	600b      	str	r3, [r1, #0]
                       0x00000008, 0x0);
    /* enet1 */
    init_qos_by_module(iobase, 0x300, 0x80000402, 0x00000003, 0x0000004c,
                       0x00000010, 0x0);
#endif
}
  102e2a:	b003      	add	sp, #12
  102e2c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

00102e30 <ce_key_ctrl>:
                (uint32_t)(phy_addr + (offset_index << 12)), data);
    }
}

int ce_key_ctrl(void)
{
  102e30:	b500      	push	{r14}

    int ret = 0;
    paddr_t phy_addr = 0;
  102e32:	2300      	movs	r3, #0
{
  102e34:	b083      	sub	sp, #12
    int32_t resid = 0;
    int32_t offset_index = 0;

    resid = RES_SCR_L16_SAF_CE1_KEY_PERCTRL_SCR_KEY_ENABLE;
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102e36:	f44f 7021 	mov.w	r0, #644	; 0x284
    int32_t offset_index = 0;
  102e3a:	aa02      	add	r2, sp, #8
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102e3c:	4669      	mov	r1, r13
  102e3e:	f2c8 2098 	movt	r0, #33432	; 0x8298
    int32_t offset_index = 0;
  102e42:	f842 3d04 	str.w	r3, [r2, #-4]!
    paddr_t phy_addr = 0;
  102e46:	9300      	str	r3, [sp, #0]
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102e48:	f00d fa74 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  102e4c:	1c43      	adds	r3, r0, #1
    writel(data, phy_addr + (offset_index << 12));
  102e4e:	bf1f      	itttt	ne
  102e50:	210d      	movne	r1, #13
  102e52:	9b01      	ldrne	r3, [sp, #4]
  102e54:	9a00      	ldrne	r2, [sp, #0]
  102e56:	031b      	lslne	r3, r3, #12
  102e58:	bf18      	it	ne
  102e5a:	5099      	strne	r1, [r3, r2]
    else {
        L16_ce1key_enable_init(phy_addr, offset_index);
    }

    return ret;
}
  102e5c:	b003      	add	sp, #12
  102e5e:	f85d fb04 	ldr.w	r15, [r13], #4
  102e62:	bf00      	nop

00102e64 <scr_init>:
    writel(rval, SCR_SEC_BASE + (0xC << 10));
}
/* hardcode scr init end */

int scr_init(void)
{
  102e64:	b510      	push	{r4, r14}
    int ret = 0;

    /* ce key setting */
    ret = ce_key_ctrl();
  102e66:	f7ff ffe3 	bl	102e30 <ce_key_ctrl>

    if (ret) {
  102e6a:	4604      	mov	r4, r0
  102e6c:	b998      	cbnz	r0, 102e96 <scr_init+0x32>
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102e6e:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102e72:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102e76:	f6cf 0138 	movt	r1, #63544	; 0xf838

    /* other setting */
    src_init_hc();

    return ret;
}
  102e7a:	4620      	mov	r0, r4
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102e7c:	f6cf 0220 	movt	r2, #63520	; 0xf820
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102e80:	680b      	ldr	r3, [r1, #0]
    rval = (rval & (~0x38)) | 0x8;
  102e82:	f023 0338 	bic.w	r3, r3, #56	; 0x38
  102e86:	f043 0308 	orr.w	r3, r3, #8
    writel(rval, SCR_SEC_BASE + (0x614 << 10));
  102e8a:	600b      	str	r3, [r1, #0]
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102e8c:	6813      	ldr	r3, [r2, #0]
    rval =  rval  | 0x3D;
  102e8e:	f043 033d 	orr.w	r3, r3, #61	; 0x3d
    writel(rval, SCR_SEC_BASE + (0xC << 10));
  102e92:	6013      	str	r3, [r2, #0]
}
  102e94:	bd10      	pop	{r4, r15}
        dprintf(CRITICAL, "ce_key_ctrl fail.\n");
  102e96:	f248 6014 	movw	r0, #34324	; 0x8614
  102e9a:	f2c0 0011 	movt	r0, #17
  102e9e:	f011 fc99 	bl	1147d4 <puts>
}
  102ea2:	4620      	mov	r0, r4
  102ea4:	bd10      	pop	{r4, r15}
  102ea6:	bf00      	nop

00102ea8 <clkgen_get_default_config>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_get_default_config(clkgen_default_cfg_t *def_cfg)
{
  102ea8:	4603      	mov	r3, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_get_default_config start...............\n");
    def_cfg->src_sel_mask = 2;
    def_cfg->safety_mode = true;
  102eaa:	2201      	movs	r2, #1
    def_cfg->src_sel_mask = 2;
  102eac:	2102      	movs	r1, #2
  102eae:	7001      	strb	r1, [r0, #0]
    return true;
}
  102eb0:	4610      	mov	r0, r2
    def_cfg->safety_mode = true;
  102eb2:	705a      	strb	r2, [r3, #1]
}
  102eb4:	4770      	bx	r14
  102eb6:	bf00      	nop

00102eb8 <clkgen_fsrefclk_sel>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_fsrefclk_sel(vaddr_t base, uint32_t scr_idx,
                         uint32_t src_sel_mask, bool safety_mode)
{
  102eb8:	b410      	push	{r4}
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if ((base != SCR_SAF_BASE)
            && (base != SCR_SEC_BASE)) {
  102eba:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
    if ((base != SCR_SAF_BASE)
  102ebe:	f114 6ffc 	cmn.w	r4, #132120576	; 0x7e00000
        LTRACEF("base paramenter error \n");
        return false;
  102ec2:	bf18      	it	ne
  102ec4:	2200      	movne	r2, #0
    if ((base != SCR_SAF_BASE)
  102ec6:	d110      	bne.n	102eea <clkgen_fsrefclk_sel+0x32>
    }

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_fsrefclk_sel scr_idx:0x%x,src_sel_mask:0x%x,safety_mode:0x%x\n",
                  scr_idx, src_sel_mask, safety_mode);
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  102ec8:	3180      	adds	r1, #128	; 0x80
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
                              CLKGEN_FSREFCLK_FS_XTAL_EN(1)));
    writel(reg_write, scr_base_addr);
    //select clk src:xtal_saf = 0x0U,xtal_ap = 0x1U,rc_24m = 0x2U,
    reg_read = readl(scr_base_addr);
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  102eca:	f002 0203 	and.w	r2, r2, #3
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  102ece:	0309      	lsls	r1, r1, #12
    reg_read = readl(scr_base_addr);
  102ed0:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
  102ed2:	f024 0418 	bic.w	r4, r4, #24
    writel(reg_write, scr_base_addr);
  102ed6:	500c      	str	r4, [r1, r0]
    reg_read = readl(scr_base_addr);
  102ed8:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  102eda:	4322      	orrs	r2, r4
    writel(reg_write, scr_base_addr);
  102edc:	500a      	str	r2, [r1, r0]

    //enable safety mode
    if (safety_mode) {
  102ede:	b943      	cbnz	r3, 102ef2 <clkgen_fsrefclk_sel+0x3a>
                                CLKGEN_FSREFCLK_FS_XTAL_EN(1));
        writel(reg_write, scr_base_addr);
    }

    //enable xtal cg gate
    reg_read = readl(scr_base_addr);
  102ee0:	580b      	ldr	r3, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
    writel(reg_write, scr_base_addr);
    return true;
  102ee2:	2201      	movs	r2, #1
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
  102ee4:	f043 0304 	orr.w	r3, r3, #4
    writel(reg_write, scr_base_addr);
  102ee8:	500b      	str	r3, [r1, r0]
}
  102eea:	f85d 4b04 	ldr.w	r4, [r13], #4
  102eee:	4610      	mov	r0, r2
  102ef0:	4770      	bx	r14
        reg_read = readl(scr_base_addr);
  102ef2:	580b      	ldr	r3, [r1, r0]
        reg_write = reg_read | (CLKGEN_FSREFCLK_FS_RC_EN(1) |
  102ef4:	f043 0318 	orr.w	r3, r3, #24
        writel(reg_write, scr_base_addr);
  102ef8:	500b      	str	r3, [r1, r0]
  102efa:	e7f1      	b.n	102ee0 <clkgen_fsrefclk_sel+0x28>

00102efc <clkgen_gating_enable>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_gating_enable(vaddr_t base, uint16_t gating_idx, bool enable)
{
  102efc:	4603      	mov	r3, r0
    vaddr_t gating_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  102efe:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  102f02:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  102f06:	d004      	beq.n	102f12 <clkgen_gating_enable+0x16>
  102f08:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  102f0c:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  102f10:	d117      	bne.n	102f42 <clkgen_gating_enable+0x46>
    gating_base_addr = base + CLKGEN_LP_GATING_EN_OFF(gating_idx);
  102f12:	0309      	lsls	r1, r1, #12
  102f14:	f501 1180 	add.w	r1, r1, #1048576	; 0x100000
{
  102f18:	b410      	push	{r4}
    //unlock gating register
    reg_read = readl(gating_base_addr);
  102f1a:	58c8      	ldr	r0, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_GATING_LOCK_MASK));
  102f1c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    writel(reg_write, gating_base_addr);
  102f20:	50c8      	str	r0, [r1, r3]
    //set sw disable
    reg_read = readl(gating_base_addr);
  102f22:	58cc      	ldr	r4, [r1, r3]

    if (enable) {
  102f24:	b932      	cbnz	r2, 102f34 <clkgen_gating_enable+0x38>
    else {
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
        writel(reg_write, gating_base_addr);
    }

    return true;
  102f26:	2001      	movs	r0, #1
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
  102f28:	f044 0202 	orr.w	r2, r4, #2
}
  102f2c:	f85d 4b04 	ldr.w	r4, [r13], #4
        writel(reg_write, gating_base_addr);
  102f30:	50ca      	str	r2, [r1, r3]
}
  102f32:	4770      	bx	r14
    return true;
  102f34:	4610      	mov	r0, r2
        reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK));
  102f36:	f024 0402 	bic.w	r4, r4, #2
        writel(reg_write, gating_base_addr);
  102f3a:	50cc      	str	r4, [r1, r3]
}
  102f3c:	f85d 4b04 	ldr.w	r4, [r13], #4
  102f40:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  102f42:	2000      	movs	r0, #0
}
  102f44:	4770      	bx	r14
  102f46:	bf00      	nop

00102f48 <clkgen_ip_slice_set>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_ip_slice_set(vaddr_t base, uint8_t ip_slice_idx,
                         uint8_t clk_src_sel, uint16_t pre_div, uint16_t post_div)
{
  102f48:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  102f4c:	f8bd 7018 	ldrh.w	r7, [r13, #24]
    bool ret = false;
    vaddr_t ip_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  102f50:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  102f54:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  102f58:	d004      	beq.n	102f64 <clkgen_ip_slice_set+0x1c>
  102f5a:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  102f5e:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  102f62:	d152      	bne.n	10300a <clkgen_ip_slice_set+0xc2>
    ip_slice_base_addr = base + CLKGEN_IP_SLICE_CTL_OFF(ip_slice_idx);
  102f64:	030e      	lsls	r6, r1, #12
  102f66:	1834      	adds	r4, r6, r0
    //clear pre_en
    reg_read = readl(ip_slice_base_addr);
  102f68:	5831      	ldr	r1, [r6, r0]

    if ((reg_read & CLKGEN_IP_SLICE_CTL_CG_EN_MASK) != 0) {
  102f6a:	07cd      	lsls	r5, r1, #31
  102f6c:	d50d      	bpl.n	102f8a <clkgen_ip_slice_set+0x42>
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
        writel(reg_write, ip_slice_base_addr);
  102f6e:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
  102f70:	f021 0101 	bic.w	r1, r1, #1
        writel(reg_write, ip_slice_base_addr);
  102f74:	5031      	str	r1, [r6, r0]
  102f76:	e001      	b.n	102f7c <clkgen_ip_slice_set+0x34>
    } while (--retrycount);
  102f78:	3d01      	subs	r5, #1
  102f7a:	d006      	beq.n	102f8a <clkgen_ip_slice_set+0x42>
        v = readl(reg);
  102f7c:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  102f7e:	00c9      	lsls	r1, r1, #3
  102f80:	d5fa      	bpl.n	102f78 <clkgen_ip_slice_set+0x30>
    RMWREG32(reg, start, width, setvalue);
  102f82:	5831      	ldr	r1, [r6, r0]
  102f84:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  102f88:	5031      	str	r1, [r6, r0]
        reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                       1, 1, 0, 100);
    }

    //select clk src
    reg_read = readl(ip_slice_base_addr);
  102f8a:	5835      	ldr	r5, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
                CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL(clk_src_sel);
  102f8c:	0051      	lsls	r1, r2, #1
  102f8e:	f001 010e 	and.w	r1, r1, #14
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
  102f92:	f025 020e 	bic.w	r2, r5, #14
  102f96:	4311      	orrs	r1, r2
    writel(reg_write, ip_slice_base_addr);
    //set pre_en
    reg_read = readl(ip_slice_base_addr);
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
    writel(reg_write, ip_slice_base_addr);
  102f98:	2264      	movs	r2, #100	; 0x64
    writel(reg_write, ip_slice_base_addr);
  102f9a:	5031      	str	r1, [r6, r0]
    reg_read = readl(ip_slice_base_addr);
  102f9c:	5831      	ldr	r1, [r6, r0]
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
  102f9e:	f041 0101 	orr.w	r1, r1, #1
    writel(reg_write, ip_slice_base_addr);
  102fa2:	5031      	str	r1, [r6, r0]
  102fa4:	e001      	b.n	102faa <clkgen_ip_slice_set+0x62>
    } while (--retrycount);
  102fa6:	3a01      	subs	r2, #1
  102fa8:	d006      	beq.n	102fb8 <clkgen_ip_slice_set+0x70>
        v = readl(reg);
  102faa:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  102fac:	00e9      	lsls	r1, r5, #3
  102fae:	d5fa      	bpl.n	102fa6 <clkgen_ip_slice_set+0x5e>
    RMWREG32(reg, start, width, setvalue);
  102fb0:	5832      	ldr	r2, [r6, r0]
  102fb2:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  102fb6:	5032      	str	r2, [r6, r0]
    reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                   1, 1, 0, 100);
    //set pre_div
    reg_read = readl(ip_slice_base_addr);
  102fb8:	5832      	ldr	r2, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM(pre_div);
  102fba:	011b      	lsls	r3, r3, #4
  102fbc:	4680      	mov	r8, r0
  102fbe:	f003 0370 	and.w	r3, r3, #112	; 0x70
    writel(reg_write, ip_slice_base_addr);
  102fc2:	2564      	movs	r5, #100	; 0x64
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
  102fc4:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  102fc8:	4313      	orrs	r3, r2
    writel(reg_write, ip_slice_base_addr);
  102fca:	5033      	str	r3, [r6, r0]
  102fcc:	e003      	b.n	102fd6 <clkgen_ip_slice_set+0x8e>
        spin(1);
  102fce:	f010 fbd3 	bl	113778 <spin>
    } while (--retrycount);
  102fd2:	3d01      	subs	r5, #1
  102fd4:	d003      	beq.n	102fde <clkgen_ip_slice_set+0x96>
        v = readl(reg);
  102fd6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  102fd8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  102fda:	005b      	lsls	r3, r3, #1
  102fdc:	d4f7      	bmi.n	102fce <clkgen_ip_slice_set+0x86>
    //wait pre_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
    //set post_div
    reg_read = readl(ip_slice_base_addr);
  102fde:	f856 3008 	ldr.w	r3, [r6, r8]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  102fe2:	02bf      	lsls	r7, r7, #10
    writel(reg_write, ip_slice_base_addr);
  102fe4:	2564      	movs	r5, #100	; 0x64
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  102fe6:	b2bf      	uxth	r7, r7
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
  102fe8:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
  102fec:	431f      	orrs	r7, r3
    writel(reg_write, ip_slice_base_addr);
  102fee:	f846 7008 	str.w	r7, [r6, r8]
  102ff2:	e003      	b.n	102ffc <clkgen_ip_slice_set+0xb4>
        spin(1);
  102ff4:	f010 fbc0 	bl	113778 <spin>
    } while (--retrycount);
  102ff8:	3d01      	subs	r5, #1
  102ffa:	d006      	beq.n	10300a <clkgen_ip_slice_set+0xc2>
        v = readl(reg);
  102ffc:	6823      	ldr	r3, [r4, #0]
        spin(1);
  102ffe:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103000:	2b00      	cmp	r3, #0
  103002:	dbf7      	blt.n	102ff4 <clkgen_ip_slice_set+0xac>
            return true;
  103004:	2001      	movs	r0, #1
    //wait post_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    return ret;
}
  103006:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    CLKGEN_ASSERT_PARAMETER(base);
  10300a:	2000      	movs	r0, #0
}
  10300c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00103010 <clkgen_ip_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

    // Check the arguments.
    if (ctl) {
  103010:	b112      	cbz	r2, 103018 <clkgen_ip_ctl_get+0x8>
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  103012:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  103014:	580b      	ldr	r3, [r1, r0]
  103016:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  103018:	2001      	movs	r0, #1
  10301a:	4770      	bx	r14

0010301c <clkgen_ip_ctl_set>:
{
    bool ret = true;
    vaddr_t slice_addr;
    clkgen_ip_ctl v;

    if (ctl) {
  10301c:	2a00      	cmp	r2, #0
  10301e:	d051      	beq.n	1030c4 <clkgen_ip_ctl_set+0xa8>
{
  103020:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  103024:	030e      	lsls	r6, r1, #12
  103026:	1834      	adds	r4, r6, r0
        //clear pre_en
        v.val = readl(slice_addr);
  103028:	5837      	ldr	r7, [r6, r0]

        if (v.cg_en != 0) {
  10302a:	07fb      	lsls	r3, r7, #31
  10302c:	d50d      	bpl.n	10304a <clkgen_ip_ctl_set+0x2e>
            v.cg_en = 0;
            writel(v.val, slice_addr);
  10302e:	2364      	movs	r3, #100	; 0x64
            v.cg_en = 0;
  103030:	f36f 0700 	bfc	r7, #0, #1
            writel(v.val, slice_addr);
  103034:	5037      	str	r7, [r6, r0]
  103036:	e001      	b.n	10303c <clkgen_ip_ctl_set+0x20>
    } while (--retrycount);
  103038:	3b01      	subs	r3, #1
  10303a:	d006      	beq.n	10304a <clkgen_ip_ctl_set+0x2e>
        v = readl(reg);
  10303c:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10303e:	00cd      	lsls	r5, r1, #3
  103040:	d5fa      	bpl.n	103038 <clkgen_ip_ctl_set+0x1c>
    RMWREG32(reg, start, width, setvalue);
  103042:	5833      	ldr	r3, [r6, r0]
  103044:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  103048:	5033      	str	r3, [r6, r0]
            ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                                  1, 1, 0, 100);
        }

        //select clk src
        v.src_sel = ctl->src_sel;
  10304a:	7813      	ldrb	r3, [r2, #0]
  10304c:	f3c3 0342 	ubfx	r3, r3, #1, #3
  103050:	f363 0743 	bfi	r7, r3, #1, #3
        writel(v.val, slice_addr);
        //set pre_en
        v.cg_en = ctl->cg_en;
        writel(v.val, slice_addr);
  103054:	2364      	movs	r3, #100	; 0x64
        writel(v.val, slice_addr);
  103056:	5037      	str	r7, [r6, r0]
        v.cg_en = ctl->cg_en;
  103058:	7811      	ldrb	r1, [r2, #0]
  10305a:	f3c1 0100 	ubfx	r1, r1, #0, #1
  10305e:	f361 0700 	bfi	r7, r1, #0, #1
        writel(v.val, slice_addr);
  103062:	5037      	str	r7, [r6, r0]
  103064:	e001      	b.n	10306a <clkgen_ip_ctl_set+0x4e>
    } while (--retrycount);
  103066:	3b01      	subs	r3, #1
  103068:	d006      	beq.n	103078 <clkgen_ip_ctl_set+0x5c>
        v = readl(reg);
  10306a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10306c:	00e9      	lsls	r1, r5, #3
  10306e:	d5fa      	bpl.n	103066 <clkgen_ip_ctl_set+0x4a>
    RMWREG32(reg, start, width, setvalue);
  103070:	5833      	ldr	r3, [r6, r0]
  103072:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  103076:	5033      	str	r3, [r6, r0]
        ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                              1, 1, 0, 100);
        //set pre_div
        v.pre_div_num = ctl->pre_div_num;
  103078:	7813      	ldrb	r3, [r2, #0]
  10307a:	4691      	mov	r9, r2
  10307c:	4680      	mov	r8, r0
  10307e:	f3c3 1302 	ubfx	r3, r3, #4, #3
        writel(v.val, slice_addr);
  103082:	2564      	movs	r5, #100	; 0x64
        v.pre_div_num = ctl->pre_div_num;
  103084:	f363 1706 	bfi	r7, r3, #4, #3
        writel(v.val, slice_addr);
  103088:	5037      	str	r7, [r6, r0]
  10308a:	e003      	b.n	103094 <clkgen_ip_ctl_set+0x78>
        spin(1);
  10308c:	f010 fb74 	bl	113778 <spin>
    } while (--retrycount);
  103090:	3d01      	subs	r5, #1
  103092:	d003      	beq.n	10309c <clkgen_ip_ctl_set+0x80>
        v = readl(reg);
  103094:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103096:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103098:	005b      	lsls	r3, r3, #1
  10309a:	d4f7      	bmi.n	10308c <clkgen_ip_ctl_set+0x70>
        //wait pre_upd_ack is 0
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
        //set post_div
        v.post_div_num = ctl->post_div_num;
  10309c:	f899 3001 	ldrb.w	r3, [r9, #1]
        writel(v.val, slice_addr);
  1030a0:	2564      	movs	r5, #100	; 0x64
        v.post_div_num = ctl->post_div_num;
  1030a2:	089b      	lsrs	r3, r3, #2
  1030a4:	f363 278f 	bfi	r7, r3, #10, #6
        writel(v.val, slice_addr);
  1030a8:	f846 7008 	str.w	r7, [r6, r8]
  1030ac:	e003      	b.n	1030b6 <clkgen_ip_ctl_set+0x9a>
        spin(1);
  1030ae:	f010 fb63 	bl	113778 <spin>
    } while (--retrycount);
  1030b2:	3d01      	subs	r5, #1
  1030b4:	d008      	beq.n	1030c8 <clkgen_ip_ctl_set+0xac>
        v = readl(reg);
  1030b6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1030b8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1030ba:	2b00      	cmp	r3, #0
  1030bc:	dbf7      	blt.n	1030ae <clkgen_ip_ctl_set+0x92>
    bool ret = true;
  1030be:	2001      	movs	r0, #1
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  1030c0:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    bool ret = true;
  1030c4:	2001      	movs	r0, #1
}
  1030c6:	4770      	bx	r14
    return false;
  1030c8:	4628      	mov	r0, r5
  1030ca:	e7f9      	b.n	1030c0 <clkgen_ip_ctl_set+0xa4>

001030cc <clkgen_bus_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_bus_slice_switch(vaddr_t base,
                             clkgen_bus_slice_drv_t *bus_clk_cfg)
{
  1030cc:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    vaddr_t bus_gasket_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1030d0:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  1030d4:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  1030d8:	d007      	beq.n	1030ea <clkgen_bus_slice_switch+0x1e>
  1030da:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  1030de:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  1030e2:	bf18      	it	ne
  1030e4:	2000      	movne	r0, #0
  1030e6:	f040 808a 	bne.w	1031fe <clkgen_bus_slice_switch+0x132>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  1030ea:	680b      	ldr	r3, [r1, #0]
  1030ec:	4688      	mov	r8, r1
  1030ee:	4606      	mov	r6, r0
  1030f0:	3340      	adds	r3, #64	; 0x40
  1030f2:	035f      	lsls	r7, r3, #13
                              bus_clk_cfg->bus_slice_idx);
    bus_gasket_slice_base_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(
  1030f4:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
  1030f8:	eb03 0900 	add.w	r9, r3, r0
                                     bus_clk_cfg->bus_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(bus_slice_base_addr);
  1030fc:	583a      	ldr	r2, [r7, r0]
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  1030fe:	183c      	adds	r4, r7, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
        (a_b_sel == bus_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(bus_slice_base_addr);
  103100:	5839      	ldr	r1, [r7, r0]
    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
  103102:	0595      	lsls	r5, r2, #22
  103104:	d47d      	bmi.n	103202 <clkgen_bus_slice_switch+0x136>

        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK) != 0) {
  103106:	03c8      	lsls	r0, r1, #15
  103108:	d50d      	bpl.n	103126 <clkgen_bus_slice_switch+0x5a>
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, bus_slice_base_addr);
  10310a:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
  10310c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
            writel(reg_write, bus_slice_base_addr);
  103110:	51b9      	str	r1, [r7, r6]
  103112:	e001      	b.n	103118 <clkgen_bus_slice_switch+0x4c>
    } while (--retrycount);
  103114:	3a01      	subs	r2, #1
  103116:	d006      	beq.n	103126 <clkgen_bus_slice_switch+0x5a>
        v = readl(reg);
  103118:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10311a:	0109      	lsls	r1, r1, #4
  10311c:	d5fa      	bpl.n	103114 <clkgen_bus_slice_switch+0x48>
    RMWREG32(reg, start, width, setvalue);
  10311e:	59ba      	ldr	r2, [r7, r6]
  103120:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  103124:	51ba      	str	r2, [r7, r6]
                    & (~(CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM_MASK));
        reg_write = reg_write
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  103126:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  10312a:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  10312e:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  103130:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  103134:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  103136:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  10313a:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  10313e:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  103142:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  103144:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  103148:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  10314a:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  10314c:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  10314e:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  103150:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  103154:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  103158:	4302      	orrs	r2, r0
        reg_write = reg_read
  10315a:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  10315e:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  103160:	519a      	str	r2, [r3, r6]
  103162:	e003      	b.n	10316c <clkgen_bus_slice_switch+0xa0>
        spin(1);
  103164:	f010 fb08 	bl	113778 <spin>
    } while (--retrycount);
  103168:	3d01      	subs	r5, #1
  10316a:	d004      	beq.n	103176 <clkgen_bus_slice_switch+0xaa>
        v = readl(reg);
  10316c:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  103170:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103172:	0f1b      	lsrs	r3, r3, #28
  103174:	d1f6      	bne.n	103164 <clkgen_bus_slice_switch+0x98>
        ret = reg_poll_value(bus_gasket_slice_base_addr,
                             CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  103176:	f898 2006 	ldrb.w	r2, [r8, #6]
        reg_read = readl(bus_slice_base_addr);
  10317a:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  10317c:	0452      	lsls	r2, r2, #17
  10317e:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  103182:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  103186:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  10318a:	431a      	orrs	r2, r3
                    | CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, bus_slice_base_addr);
  10318c:	2364      	movs	r3, #100	; 0x64
  10318e:	51ba      	str	r2, [r7, r6]
  103190:	e001      	b.n	103196 <clkgen_bus_slice_switch+0xca>
    } while (--retrycount);
  103192:	3b01      	subs	r3, #1
  103194:	d006      	beq.n	1031a4 <clkgen_bus_slice_switch+0xd8>
        v = readl(reg);
  103196:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103198:	0112      	lsls	r2, r2, #4
  10319a:	d5fa      	bpl.n	103192 <clkgen_bus_slice_switch+0xc6>
    RMWREG32(reg, start, width, setvalue);
  10319c:	59bb      	ldr	r3, [r7, r6]
  10319e:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  1031a2:	51bb      	str	r3, [r7, r6]
        reg_poll_clear(bus_slice_base_addr,
                       CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
  1031a4:	59ba      	ldr	r2, [r7, r6]
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  1031a6:	f898 3008 	ldrb.w	r3, [r8, #8]
        writel(reg_write, bus_slice_base_addr);
  1031aa:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  1031ac:	051b      	lsls	r3, r3, #20
  1031ae:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
  1031b2:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
  1031b6:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1031b8:	51bb      	str	r3, [r7, r6]
  1031ba:	e003      	b.n	1031c4 <clkgen_bus_slice_switch+0xf8>
        spin(1);
  1031bc:	f010 fadc 	bl	113778 <spin>
    } while (--retrycount);
  1031c0:	3d01      	subs	r5, #1
  1031c2:	d003      	beq.n	1031cc <clkgen_bus_slice_switch+0x100>
        v = readl(reg);
  1031c4:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1031c6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1031c8:	009b      	lsls	r3, r3, #2
  1031ca:	d4f7      	bmi.n	1031bc <clkgen_bus_slice_switch+0xf0>
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1031cc:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  1031d0:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  1031d2:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1031d4:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1031d6:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1031da:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1031dc:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1031de:	51bb      	str	r3, [r7, r6]
  1031e0:	e004      	b.n	1031ec <clkgen_bus_slice_switch+0x120>
        spin(1);
  1031e2:	f010 fac9 	bl	113778 <spin>
    } while (--retrycount);
  1031e6:	3d01      	subs	r5, #1
  1031e8:	f000 808a 	beq.w	103300 <clkgen_bus_slice_switch+0x234>
        v = readl(reg);
  1031ec:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1031ee:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1031f0:	2b00      	cmp	r3, #0
  1031f2:	dbf6      	blt.n	1031e2 <clkgen_bus_slice_switch+0x116>
            return true;
  1031f4:	2001      	movs	r0, #1
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(bus_slice_base_addr);
  1031f6:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read | CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK;
  1031f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  1031fc:	51bb      	str	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
        writel(reg_write, bus_slice_base_addr);
    }

    return ret;
}
  1031fe:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK) != 0) {
  103202:	07c8      	lsls	r0, r1, #31
  103204:	d50d      	bpl.n	103222 <clkgen_bus_slice_switch+0x156>
            writel(reg_write, bus_slice_base_addr);
  103206:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK);
  103208:	f021 0101 	bic.w	r1, r1, #1
            writel(reg_write, bus_slice_base_addr);
  10320c:	51b9      	str	r1, [r7, r6]
  10320e:	e001      	b.n	103214 <clkgen_bus_slice_switch+0x148>
    } while (--retrycount);
  103210:	3a01      	subs	r2, #1
  103212:	d006      	beq.n	103222 <clkgen_bus_slice_switch+0x156>
        v = readl(reg);
  103214:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103216:	00c9      	lsls	r1, r1, #3
  103218:	d5fa      	bpl.n	103210 <clkgen_bus_slice_switch+0x144>
    RMWREG32(reg, start, width, setvalue);
  10321a:	59ba      	ldr	r2, [r7, r6]
  10321c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  103220:	51ba      	str	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  103222:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  103226:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  10322a:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  10322c:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  103230:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  103232:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  103236:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  10323a:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  10323e:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  103240:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  103244:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  103246:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  103248:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  10324a:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  10324c:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  103250:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  103254:	4302      	orrs	r2, r0
        reg_write = reg_read
  103256:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  10325a:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  10325c:	519a      	str	r2, [r3, r6]
  10325e:	e003      	b.n	103268 <clkgen_bus_slice_switch+0x19c>
        spin(1);
  103260:	f010 fa8a 	bl	113778 <spin>
    } while (--retrycount);
  103264:	3d01      	subs	r5, #1
  103266:	d004      	beq.n	103272 <clkgen_bus_slice_switch+0x1a6>
        v = readl(reg);
  103268:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  10326c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10326e:	0f1b      	lsrs	r3, r3, #28
  103270:	d1f6      	bne.n	103260 <clkgen_bus_slice_switch+0x194>
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  103272:	f898 2005 	ldrb.w	r2, [r8, #5]
        reg_read = readl(bus_slice_base_addr);
  103276:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  103278:	0052      	lsls	r2, r2, #1
  10327a:	f002 020e 	and.w	r2, r2, #14
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  10327e:	f023 030e 	bic.w	r3, r3, #14
  103282:	f042 0201 	orr.w	r2, r2, #1
  103286:	431a      	orrs	r2, r3
        writel(reg_write, bus_slice_base_addr);
  103288:	2364      	movs	r3, #100	; 0x64
  10328a:	51ba      	str	r2, [r7, r6]
  10328c:	e001      	b.n	103292 <clkgen_bus_slice_switch+0x1c6>
    } while (--retrycount);
  10328e:	3b01      	subs	r3, #1
  103290:	d006      	beq.n	1032a0 <clkgen_bus_slice_switch+0x1d4>
        v = readl(reg);
  103292:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103294:	00d2      	lsls	r2, r2, #3
  103296:	d5fa      	bpl.n	10328e <clkgen_bus_slice_switch+0x1c2>
    RMWREG32(reg, start, width, setvalue);
  103298:	59bb      	ldr	r3, [r7, r6]
  10329a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  10329e:	51bb      	str	r3, [r7, r6]
        reg_read = readl(bus_slice_base_addr);
  1032a0:	59ba      	ldr	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  1032a2:	f898 3007 	ldrb.w	r3, [r8, #7]
        writel(reg_write, bus_slice_base_addr);
  1032a6:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  1032a8:	011b      	lsls	r3, r3, #4
  1032aa:	f003 0370 	and.w	r3, r3, #112	; 0x70
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A_MASK))
  1032ae:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  1032b2:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1032b4:	51bb      	str	r3, [r7, r6]
  1032b6:	e003      	b.n	1032c0 <clkgen_bus_slice_switch+0x1f4>
        spin(1);
  1032b8:	f010 fa5e 	bl	113778 <spin>
    } while (--retrycount);
  1032bc:	3d01      	subs	r5, #1
  1032be:	d003      	beq.n	1032c8 <clkgen_bus_slice_switch+0x1fc>
        v = readl(reg);
  1032c0:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1032c2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1032c4:	005b      	lsls	r3, r3, #1
  1032c6:	d4f7      	bmi.n	1032b8 <clkgen_bus_slice_switch+0x1ec>
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1032c8:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  1032cc:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  1032ce:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1032d0:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1032d2:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1032d6:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1032d8:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1032da:	51bb      	str	r3, [r7, r6]
  1032dc:	e003      	b.n	1032e6 <clkgen_bus_slice_switch+0x21a>
        spin(1);
  1032de:	f010 fa4b 	bl	113778 <spin>
    } while (--retrycount);
  1032e2:	3d01      	subs	r5, #1
  1032e4:	d00a      	beq.n	1032fc <clkgen_bus_slice_switch+0x230>
        v = readl(reg);
  1032e6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1032e8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1032ea:	2b00      	cmp	r3, #0
  1032ec:	dbf7      	blt.n	1032de <clkgen_bus_slice_switch+0x212>
            return true;
  1032ee:	2001      	movs	r0, #1
        reg_read = readl(bus_slice_base_addr);
  1032f0:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
  1032f2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  1032f6:	51bb      	str	r3, [r7, r6]
}
  1032f8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    return false;
  1032fc:	4628      	mov	r0, r5
  1032fe:	e7f7      	b.n	1032f0 <clkgen_bus_slice_switch+0x224>
  103300:	4628      	mov	r0, r5
  103302:	e778      	b.n	1031f6 <clkgen_bus_slice_switch+0x12a>

00103304 <clkgen_bus_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  103304:	b17a      	cbz	r2, 103326 <clkgen_bus_ctl_get+0x22>
{
  103306:	b410      	push	{r4}
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  103308:	f101 0440 	add.w	r4, r1, #64	; 0x40
  10330c:	0364      	lsls	r4, r4, #13
        ctl->val = readl(slice_addr);
  10330e:	5824      	ldr	r4, [r4, r0]
  103310:	6014      	str	r4, [r2, #0]
    }

    if (gasket) {
  103312:	b123      	cbz	r3, 10331e <clkgen_bus_ctl_get+0x1a>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103314:	0349      	lsls	r1, r1, #13
  103316:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  10331a:	580a      	ldr	r2, [r1, r0]
  10331c:	601a      	str	r2, [r3, #0]
    }

    return ret;
}
  10331e:	f85d 4b04 	ldr.w	r4, [r13], #4
  103322:	2001      	movs	r0, #1
  103324:	4770      	bx	r14
    if (gasket) {
  103326:	b123      	cbz	r3, 103332 <clkgen_bus_ctl_get+0x2e>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103328:	0349      	lsls	r1, r1, #13
  10332a:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  10332e:	580a      	ldr	r2, [r1, r0]
  103330:	601a      	str	r2, [r3, #0]
}
  103332:	2001      	movs	r0, #1
  103334:	4770      	bx	r14
  103336:	bf00      	nop

00103338 <clkgen_bus_ctl_set>:
                        const clkgen_bus_gasket *gasket)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  103338:	2a00      	cmp	r2, #0
  10333a:	f000 80ec 	beq.w	103516 <clkgen_bus_ctl_set+0x1de>
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  10333e:	3140      	adds	r1, #64	; 0x40
{
  103340:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  103344:	4691      	mov	r9, r2
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  103346:	ea4f 3841 	mov.w	r8, r1, lsl #13
  10334a:	4607      	mov	r7, r0
  10334c:	00c9      	lsls	r1, r1, #3
  10334e:	eb08 0500 	add.w	r5, r8, r0
        clkgen_bus_ctl v;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        v.val = readl(slice_addr);
  103352:	f858 6000 	ldr.w	r6, [r8, r0]

        if (v.a_b_sel == 0) {
  103356:	f3c6 2207 	ubfx	r2, r6, #8, #8
  10335a:	f012 0202 	ands.w	r2, r2, #2
  10335e:	d16e      	bne.n	10343e <clkgen_bus_ctl_set+0x106>
            //set pre_en_b to 0x0,disable the clock
            if (v.cg_en_b != 0) {
  103360:	03f4      	lsls	r4, r6, #15
  103362:	f100 80ec 	bmi.w	10353e <clkgen_bus_ctl_set+0x206>
                reg_poll_clear(slice_addr, CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1,
                               0, 100);
            }

            //set m/n/p/q div
            if (gasket) {
  103366:	b31b      	cbz	r3, 1033b0 <clkgen_bus_ctl_set+0x78>
                vaddr_t g_addr;
                clkgen_bus_gasket g;
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103368:	3104      	adds	r1, #4
                g.val = readl(g_addr);
                g.m_div_num = gasket->m_div_num;
                g.n_div_num = gasket->n_div_num;
                g.p_div_num = gasket->p_div_num;
  10336a:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  10336c:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  10336e:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103370:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  103372:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  103376:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  10337a:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  10337c:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  103380:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  103384:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  103388:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  10338c:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  103390:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  103394:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103396:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  10339a:	51cb      	str	r3, [r1, r7]
  10339c:	e003      	b.n	1033a6 <clkgen_bus_ctl_set+0x6e>
        spin(1);
  10339e:	f010 f9eb 	bl	113778 <spin>
    } while (--retrycount);
  1033a2:	3c01      	subs	r4, #1
  1033a4:	d004      	beq.n	1033b0 <clkgen_bus_ctl_set+0x78>
        v = readl(reg);
  1033a6:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  1033aa:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1033ac:	0f1b      	lsrs	r3, r3, #28
  1033ae:	d1f6      	bne.n	10339e <clkgen_bus_ctl_set+0x66>
                ret = reg_poll_value(g_addr,
                                     CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            v.src_sel_b = ctl->src_sel_a;
  1033b0:	f899 3000 	ldrb.w	r3, [r9]
  1033b4:	f3c3 0242 	ubfx	r2, r3, #1, #3
  1033b8:	f362 4653 	bfi	r6, r2, #17, #3
            v.cg_en_b = ctl->cg_en_a;
  1033bc:	f3c3 0200 	ubfx	r2, r3, #0, #1
  1033c0:	f362 4610 	bfi	r6, r2, #16, #1

            if (v.cg_en_b != 0) {
  1033c4:	03f1      	lsls	r1, r6, #15
  1033c6:	d511      	bpl.n	1033ec <clkgen_bus_ctl_set+0xb4>
                writel(v.val, slice_addr);
  1033c8:	f848 6007 	str.w	r6, [r8, r7]
  1033cc:	2364      	movs	r3, #100	; 0x64
  1033ce:	e002      	b.n	1033d6 <clkgen_bus_ctl_set+0x9e>
    } while (--retrycount);
  1033d0:	3b01      	subs	r3, #1
  1033d2:	f000 80cb 	beq.w	10356c <clkgen_bus_ctl_set+0x234>
        v = readl(reg);
  1033d6:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1033d8:	0112      	lsls	r2, r2, #4
  1033da:	d5f9      	bpl.n	1033d0 <clkgen_bus_ctl_set+0x98>
    RMWREG32(reg, start, width, setvalue);
  1033dc:	f858 3007 	ldr.w	r3, [r8, r7]
  1033e0:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  1033e4:	f848 3007 	str.w	r3, [r8, r7]
  1033e8:	f899 3000 	ldrb.w	r3, [r9]
                               0, 100);
            }

            //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
            v.pre_div_num_b = ctl->pre_div_num_a;
            writel(v.val, slice_addr);
  1033ec:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_b = ctl->pre_div_num_a;
  1033ee:	f3c3 1302 	ubfx	r3, r3, #4, #3
  1033f2:	f363 5616 	bfi	r6, r3, #20, #3
            writel(v.val, slice_addr);
  1033f6:	f848 6007 	str.w	r6, [r8, r7]
  1033fa:	e003      	b.n	103404 <clkgen_bus_ctl_set+0xcc>
        spin(1);
  1033fc:	f010 f9bc 	bl	113778 <spin>
    } while (--retrycount);
  103400:	3c01      	subs	r4, #1
  103402:	d003      	beq.n	10340c <clkgen_bus_ctl_set+0xd4>
        v = readl(reg);
  103404:	682b      	ldr	r3, [r5, #0]
        spin(1);
  103406:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103408:	009b      	lsls	r3, r3, #2
  10340a:	d4f7      	bmi.n	1033fc <clkgen_bus_ctl_set+0xc4>
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            v.post_div_num = ctl->post_div_num;
  10340c:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  103410:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  103412:	089b      	lsrs	r3, r3, #2
  103414:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  103418:	f848 6007 	str.w	r6, [r8, r7]
  10341c:	e004      	b.n	103428 <clkgen_bus_ctl_set+0xf0>
        spin(1);
  10341e:	f010 f9ab 	bl	113778 <spin>
    } while (--retrycount);
  103422:	3c01      	subs	r4, #1
  103424:	f000 809e 	beq.w	103564 <clkgen_bus_ctl_set+0x22c>
        v = readl(reg);
  103428:	682b      	ldr	r3, [r5, #0]
        spin(1);
  10342a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10342c:	2b00      	cmp	r3, #0
  10342e:	dbf6      	blt.n	10341e <clkgen_bus_ctl_set+0xe6>
            return true;
  103430:	2001      	movs	r0, #1
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
            //invert pre_a_b_sel
            v.a_b_sel = 1;
  103432:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(v.val, slice_addr);
  103436:	f848 6007 	str.w	r6, [r8, r7]
            writel(v.val, slice_addr);
        }
    }

    return ret;
}
  10343a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            if (v.cg_en_a != 0) {
  10343e:	07f4      	lsls	r4, r6, #31
  103440:	d46b      	bmi.n	10351a <clkgen_bus_ctl_set+0x1e2>
            if (gasket) {
  103442:	b31b      	cbz	r3, 10348c <clkgen_bus_ctl_set+0x154>
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103444:	3104      	adds	r1, #4
                g.p_div_num = gasket->p_div_num;
  103446:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  103448:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  10344a:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  10344c:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  10344e:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  103452:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  103456:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  103458:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  10345c:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  103460:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  103464:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  103468:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  10346c:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  103470:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103472:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  103476:	51cb      	str	r3, [r1, r7]
  103478:	e003      	b.n	103482 <clkgen_bus_ctl_set+0x14a>
        spin(1);
  10347a:	f010 f97d 	bl	113778 <spin>
    } while (--retrycount);
  10347e:	3c01      	subs	r4, #1
  103480:	d004      	beq.n	10348c <clkgen_bus_ctl_set+0x154>
        v = readl(reg);
  103482:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  103486:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103488:	0f1b      	lsrs	r3, r3, #28
  10348a:	d1f6      	bne.n	10347a <clkgen_bus_ctl_set+0x142>
            v.src_sel_a = ctl->src_sel_a;
  10348c:	f899 3000 	ldrb.w	r3, [r9]
  103490:	f3c3 0242 	ubfx	r2, r3, #1, #3
  103494:	f362 0643 	bfi	r6, r2, #1, #3
            v.cg_en_a = ctl->cg_en_a;
  103498:	f3c3 0200 	ubfx	r2, r3, #0, #1
  10349c:	f362 0600 	bfi	r6, r2, #0, #1
            if (v.cg_en_a != 0) {
  1034a0:	07f1      	lsls	r1, r6, #31
  1034a2:	d510      	bpl.n	1034c6 <clkgen_bus_ctl_set+0x18e>
                writel(v.val, slice_addr);
  1034a4:	f848 6007 	str.w	r6, [r8, r7]
  1034a8:	2364      	movs	r3, #100	; 0x64
  1034aa:	e001      	b.n	1034b0 <clkgen_bus_ctl_set+0x178>
    } while (--retrycount);
  1034ac:	3b01      	subs	r3, #1
  1034ae:	d060      	beq.n	103572 <clkgen_bus_ctl_set+0x23a>
        v = readl(reg);
  1034b0:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1034b2:	00d2      	lsls	r2, r2, #3
  1034b4:	d5fa      	bpl.n	1034ac <clkgen_bus_ctl_set+0x174>
    RMWREG32(reg, start, width, setvalue);
  1034b6:	f858 3007 	ldr.w	r3, [r8, r7]
  1034ba:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  1034be:	f848 3007 	str.w	r3, [r8, r7]
  1034c2:	f899 3000 	ldrb.w	r3, [r9]
            writel(v.val, slice_addr);
  1034c6:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_a = ctl->pre_div_num_a;
  1034c8:	f3c3 1302 	ubfx	r3, r3, #4, #3
  1034cc:	f363 1606 	bfi	r6, r3, #4, #3
            writel(v.val, slice_addr);
  1034d0:	f848 6007 	str.w	r6, [r8, r7]
  1034d4:	e003      	b.n	1034de <clkgen_bus_ctl_set+0x1a6>
        spin(1);
  1034d6:	f010 f94f 	bl	113778 <spin>
    } while (--retrycount);
  1034da:	3c01      	subs	r4, #1
  1034dc:	d003      	beq.n	1034e6 <clkgen_bus_ctl_set+0x1ae>
        v = readl(reg);
  1034de:	682b      	ldr	r3, [r5, #0]
        spin(1);
  1034e0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1034e2:	005b      	lsls	r3, r3, #1
  1034e4:	d4f7      	bmi.n	1034d6 <clkgen_bus_ctl_set+0x19e>
            v.post_div_num = ctl->post_div_num;
  1034e6:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  1034ea:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  1034ec:	089b      	lsrs	r3, r3, #2
  1034ee:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  1034f2:	f848 6007 	str.w	r6, [r8, r7]
  1034f6:	e003      	b.n	103500 <clkgen_bus_ctl_set+0x1c8>
        spin(1);
  1034f8:	f010 f93e 	bl	113778 <spin>
    } while (--retrycount);
  1034fc:	3c01      	subs	r4, #1
  1034fe:	d033      	beq.n	103568 <clkgen_bus_ctl_set+0x230>
        v = readl(reg);
  103500:	682b      	ldr	r3, [r5, #0]
        spin(1);
  103502:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103504:	2b00      	cmp	r3, #0
  103506:	dbf7      	blt.n	1034f8 <clkgen_bus_ctl_set+0x1c0>
            return true;
  103508:	2001      	movs	r0, #1
            v.a_b_sel = 0;
  10350a:	f36f 2649 	bfc	r6, #9, #1
            writel(v.val, slice_addr);
  10350e:	f848 6007 	str.w	r6, [r8, r7]
}
  103512:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    bool ret = true;
  103516:	2001      	movs	r0, #1
}
  103518:	4770      	bx	r14
                writel(v.val, slice_addr);
  10351a:	2264      	movs	r2, #100	; 0x64
                v.cg_en_a = 0;
  10351c:	f36f 0600 	bfc	r6, #0, #1
                writel(v.val, slice_addr);
  103520:	f848 6000 	str.w	r6, [r8, r0]
  103524:	e001      	b.n	10352a <clkgen_bus_ctl_set+0x1f2>
    } while (--retrycount);
  103526:	3a01      	subs	r2, #1
  103528:	d08b      	beq.n	103442 <clkgen_bus_ctl_set+0x10a>
        v = readl(reg);
  10352a:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10352c:	00c0      	lsls	r0, r0, #3
  10352e:	d5fa      	bpl.n	103526 <clkgen_bus_ctl_set+0x1ee>
    RMWREG32(reg, start, width, setvalue);
  103530:	f858 2007 	ldr.w	r2, [r8, r7]
  103534:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  103538:	f848 2007 	str.w	r2, [r8, r7]
  10353c:	e781      	b.n	103442 <clkgen_bus_ctl_set+0x10a>
                v.cg_en_b = 0;
  10353e:	f362 4610 	bfi	r6, r2, #16, #1
                writel(v.val, slice_addr);
  103542:	2264      	movs	r2, #100	; 0x64
  103544:	f848 6000 	str.w	r6, [r8, r0]
  103548:	e002      	b.n	103550 <clkgen_bus_ctl_set+0x218>
    } while (--retrycount);
  10354a:	3a01      	subs	r2, #1
  10354c:	f43f af0b 	beq.w	103366 <clkgen_bus_ctl_set+0x2e>
        v = readl(reg);
  103550:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103552:	0100      	lsls	r0, r0, #4
  103554:	d5f9      	bpl.n	10354a <clkgen_bus_ctl_set+0x212>
    RMWREG32(reg, start, width, setvalue);
  103556:	f858 2007 	ldr.w	r2, [r8, r7]
  10355a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  10355e:	f848 2007 	str.w	r2, [r8, r7]
  103562:	e700      	b.n	103366 <clkgen_bus_ctl_set+0x2e>
    return false;
  103564:	4620      	mov	r0, r4
  103566:	e764      	b.n	103432 <clkgen_bus_ctl_set+0xfa>
  103568:	4620      	mov	r0, r4
  10356a:	e7ce      	b.n	10350a <clkgen_bus_ctl_set+0x1d2>
  10356c:	f899 3000 	ldrb.w	r3, [r9]
  103570:	e73c      	b.n	1033ec <clkgen_bus_ctl_set+0xb4>
  103572:	f899 3000 	ldrb.w	r3, [r9]
  103576:	e7a6      	b.n	1034c6 <clkgen_bus_ctl_set+0x18e>

00103578 <clkgen_core_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_core_slice_switch(vaddr_t base,
                              clkgen_core_slice_drv_t *core_clk_cfg)
{
  103578:	b538      	push	{r3, r4, r5, r14}
    vaddr_t core_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  10357a:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  10357e:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103582:	d005      	beq.n	103590 <clkgen_core_slice_switch+0x18>
  103584:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103588:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  10358c:	f040 8084 	bne.w	103698 <clkgen_core_slice_switch+0x120>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    core_slice_base_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(
  103590:	680b      	ldr	r3, [r1, #0]
  103592:	33c0      	adds	r3, #192	; 0xc0
  103594:	031b      	lsls	r3, r3, #12
  103596:	181c      	adds	r4, r3, r0
                               core_clk_cfg->core_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(core_slice_base_addr);
  103598:	581a      	ldr	r2, [r3, r0]
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
        (a_b_sel == core_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(core_slice_base_addr);
  10359a:	581d      	ldr	r5, [r3, r0]
    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
  10359c:	0592      	lsls	r2, r2, #22
  10359e:	d43d      	bmi.n	10361c <clkgen_core_slice_switch+0xa4>

        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK) != 0) {
  1035a0:	03ea      	lsls	r2, r5, #15
  1035a2:	d50d      	bpl.n	1035c0 <clkgen_core_slice_switch+0x48>
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, core_slice_base_addr);
  1035a4:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
  1035a6:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
            writel(reg_write, core_slice_base_addr);
  1035aa:	501d      	str	r5, [r3, r0]
  1035ac:	e001      	b.n	1035b2 <clkgen_core_slice_switch+0x3a>
    } while (--retrycount);
  1035ae:	3a01      	subs	r2, #1
  1035b0:	d006      	beq.n	1035c0 <clkgen_core_slice_switch+0x48>
        v = readl(reg);
  1035b2:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1035b4:	012d      	lsls	r5, r5, #4
  1035b6:	d5fa      	bpl.n	1035ae <clkgen_core_slice_switch+0x36>
    RMWREG32(reg, start, width, setvalue);
  1035b8:	581a      	ldr	r2, [r3, r0]
  1035ba:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  1035be:	501a      	str	r2, [r3, r0]
        }

        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  1035c0:	798d      	ldrb	r5, [r1, #6]
        reg_read = readl(core_slice_base_addr);
  1035c2:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  1035c4:	046d      	lsls	r5, r5, #17
  1035c6:	f405 2560 	and.w	r5, r5, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  1035ca:	f422 2260 	bic.w	r2, r2, #917504	; 0xe0000
  1035ce:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
  1035d2:	4315      	orrs	r5, r2
                    | CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, core_slice_base_addr);
  1035d4:	2264      	movs	r2, #100	; 0x64
  1035d6:	501d      	str	r5, [r3, r0]
  1035d8:	e001      	b.n	1035de <clkgen_core_slice_switch+0x66>
    } while (--retrycount);
  1035da:	3a01      	subs	r2, #1
  1035dc:	d006      	beq.n	1035ec <clkgen_core_slice_switch+0x74>
        v = readl(reg);
  1035de:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1035e0:	012d      	lsls	r5, r5, #4
  1035e2:	d5fa      	bpl.n	1035da <clkgen_core_slice_switch+0x62>
    RMWREG32(reg, start, width, setvalue);
  1035e4:	581a      	ldr	r2, [r3, r0]
  1035e6:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  1035ea:	501a      	str	r2, [r3, r0]
        reg_poll_clear(core_slice_base_addr,
                       CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(core_slice_base_addr);
  1035ec:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
        writel(reg_write, core_slice_base_addr);
  1035ee:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read | CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK;
  1035f0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  1035f4:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  1035f6:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  1035f8:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  1035fa:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  1035fc:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  103600:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  103602:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  103604:	501a      	str	r2, [r3, r0]
  103606:	e003      	b.n	103610 <clkgen_core_slice_switch+0x98>
        spin(1);
  103608:	f010 f8b6 	bl	113778 <spin>
    } while (--retrycount);
  10360c:	3d01      	subs	r5, #1
  10360e:	d043      	beq.n	103698 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  103610:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103612:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103614:	2b00      	cmp	r3, #0
  103616:	dbf7      	blt.n	103608 <clkgen_core_slice_switch+0x90>
            return true;
  103618:	2001      	movs	r0, #1
        ret = reg_poll_value(core_slice_base_addr,
                             CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  10361a:	bd38      	pop	{r3, r4, r5, r15}
        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK) != 0) {
  10361c:	07ea      	lsls	r2, r5, #31
  10361e:	d50d      	bpl.n	10363c <clkgen_core_slice_switch+0xc4>
            writel(reg_write, core_slice_base_addr);
  103620:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK);
  103622:	f025 0501 	bic.w	r5, r5, #1
            writel(reg_write, core_slice_base_addr);
  103626:	501d      	str	r5, [r3, r0]
  103628:	e001      	b.n	10362e <clkgen_core_slice_switch+0xb6>
    } while (--retrycount);
  10362a:	3a01      	subs	r2, #1
  10362c:	d006      	beq.n	10363c <clkgen_core_slice_switch+0xc4>
        v = readl(reg);
  10362e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103630:	00ed      	lsls	r5, r5, #3
  103632:	d5fa      	bpl.n	10362a <clkgen_core_slice_switch+0xb2>
    RMWREG32(reg, start, width, setvalue);
  103634:	581a      	ldr	r2, [r3, r0]
  103636:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  10363a:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  10363c:	794d      	ldrb	r5, [r1, #5]
        reg_read = readl(core_slice_base_addr);
  10363e:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  103640:	006d      	lsls	r5, r5, #1
  103642:	f005 050e 	and.w	r5, r5, #14
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  103646:	f022 020e 	bic.w	r2, r2, #14
  10364a:	f045 0501 	orr.w	r5, r5, #1
  10364e:	4315      	orrs	r5, r2
        writel(reg_write, core_slice_base_addr);
  103650:	2264      	movs	r2, #100	; 0x64
  103652:	501d      	str	r5, [r3, r0]
  103654:	e001      	b.n	10365a <clkgen_core_slice_switch+0xe2>
    } while (--retrycount);
  103656:	3a01      	subs	r2, #1
  103658:	d006      	beq.n	103668 <clkgen_core_slice_switch+0xf0>
        v = readl(reg);
  10365a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10365c:	00ed      	lsls	r5, r5, #3
  10365e:	d5fa      	bpl.n	103656 <clkgen_core_slice_switch+0xde>
    RMWREG32(reg, start, width, setvalue);
  103660:	581a      	ldr	r2, [r3, r0]
  103662:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  103666:	501a      	str	r2, [r3, r0]
        reg_read = readl(core_slice_base_addr);
  103668:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
  10366a:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK);
  10366c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  103670:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  103672:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  103674:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  103676:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  103678:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  10367c:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  10367e:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  103680:	501a      	str	r2, [r3, r0]
  103682:	e003      	b.n	10368c <clkgen_core_slice_switch+0x114>
        spin(1);
  103684:	f010 f878 	bl	113778 <spin>
    } while (--retrycount);
  103688:	3d01      	subs	r5, #1
  10368a:	d005      	beq.n	103698 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  10368c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10368e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103690:	2b00      	cmp	r3, #0
  103692:	dbf7      	blt.n	103684 <clkgen_core_slice_switch+0x10c>
            return true;
  103694:	2001      	movs	r0, #1
  103696:	e7c0      	b.n	10361a <clkgen_core_slice_switch+0xa2>
    CLKGEN_ASSERT_PARAMETER(base);
  103698:	2000      	movs	r0, #0
}
  10369a:	bd38      	pop	{r3, r4, r5, r15}

0010369c <clkgen_core_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  10369c:	b11a      	cbz	r2, 1036a6 <clkgen_core_ctl_get+0xa>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  10369e:	31c0      	adds	r1, #192	; 0xc0
  1036a0:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  1036a2:	580b      	ldr	r3, [r1, r0]
  1036a4:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  1036a6:	2001      	movs	r0, #1
  1036a8:	4770      	bx	r14
  1036aa:	bf00      	nop

001036ac <clkgen_core_ctl_set>:
                         const clkgen_core_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  1036ac:	2a00      	cmp	r2, #0
  1036ae:	f000 8081 	beq.w	1037b4 <clkgen_core_ctl_set+0x108>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  1036b2:	f101 03c0 	add.w	r3, r1, #192	; 0xc0
{
  1036b6:	b570      	push	{r4, r5, r6, r14}
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  1036b8:	031b      	lsls	r3, r3, #12
  1036ba:	181c      	adds	r4, r3, r0
        clkgen_core_ctl c;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        c.val = readl(slice_addr);
  1036bc:	581e      	ldr	r6, [r3, r0]

        if (c.a_b_sel == 0) {
  1036be:	f3c6 2107 	ubfx	r1, r6, #8, #8
  1036c2:	f011 0102 	ands.w	r1, r1, #2
  1036c6:	d13a      	bne.n	10373e <clkgen_core_ctl_set+0x92>
            //set pre_en_b to 0x0,disable the clock
            if (c.cg_en_b != 0) {
  1036c8:	03f5      	lsls	r5, r6, #15
  1036ca:	d50d      	bpl.n	1036e8 <clkgen_core_ctl_set+0x3c>
                c.cg_en_b = 0;
  1036cc:	f361 4610 	bfi	r6, r1, #16, #1
                writel(c.val, slice_addr);
  1036d0:	2164      	movs	r1, #100	; 0x64
  1036d2:	501e      	str	r6, [r3, r0]
  1036d4:	e001      	b.n	1036da <clkgen_core_ctl_set+0x2e>
    } while (--retrycount);
  1036d6:	3901      	subs	r1, #1
  1036d8:	d006      	beq.n	1036e8 <clkgen_core_ctl_set+0x3c>
        v = readl(reg);
  1036da:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1036dc:	012d      	lsls	r5, r5, #4
  1036de:	d5fa      	bpl.n	1036d6 <clkgen_core_ctl_set+0x2a>
    RMWREG32(reg, start, width, setvalue);
  1036e0:	5819      	ldr	r1, [r3, r0]
  1036e2:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  1036e6:	5019      	str	r1, [r3, r0]
                reg_poll_clear(slice_addr, CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1,
                               1, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            c.src_sel_b = ctl->src_sel_a;
  1036e8:	7811      	ldrb	r1, [r2, #0]
  1036ea:	f3c1 0542 	ubfx	r5, r1, #1, #3
  1036ee:	f365 4653 	bfi	r6, r5, #17, #3
            c.cg_en_b = ctl->cg_en_a;
  1036f2:	f3c1 0100 	ubfx	r1, r1, #0, #1
  1036f6:	f361 4610 	bfi	r6, r1, #16, #1
            writel(c.val, slice_addr);

            if (c.cg_en_b)
  1036fa:	03f1      	lsls	r1, r6, #15
            writel(c.val, slice_addr);
  1036fc:	501e      	str	r6, [r3, r0]
            if (c.cg_en_b)
  1036fe:	d50a      	bpl.n	103716 <clkgen_core_ctl_set+0x6a>
  103700:	2164      	movs	r1, #100	; 0x64
  103702:	e001      	b.n	103708 <clkgen_core_ctl_set+0x5c>
    } while (--retrycount);
  103704:	3901      	subs	r1, #1
  103706:	d006      	beq.n	103716 <clkgen_core_ctl_set+0x6a>
        v = readl(reg);
  103708:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10370a:	012d      	lsls	r5, r5, #4
  10370c:	d5fa      	bpl.n	103704 <clkgen_core_ctl_set+0x58>
    RMWREG32(reg, start, width, setvalue);
  10370e:	5819      	ldr	r1, [r3, r0]
  103710:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  103714:	5019      	str	r1, [r3, r0]
            //invert pre_a_b_sel
            c.a_b_sel = 1;
            writel(c.val, slice_addr);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            c.post_div_num = ctl->post_div_num;
            writel(c.val, slice_addr);
  103716:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 1;
  103718:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(c.val, slice_addr);
  10371c:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  10371e:	7852      	ldrb	r2, [r2, #1]
  103720:	0892      	lsrs	r2, r2, #2
  103722:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  103726:	501e      	str	r6, [r3, r0]
  103728:	e003      	b.n	103732 <clkgen_core_ctl_set+0x86>
        spin(1);
  10372a:	f010 f825 	bl	113778 <spin>
    } while (--retrycount);
  10372e:	3d01      	subs	r5, #1
  103730:	d042      	beq.n	1037b8 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  103732:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103734:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103736:	2b00      	cmp	r3, #0
  103738:	dbf7      	blt.n	10372a <clkgen_core_ctl_set+0x7e>
            return true;
  10373a:	2001      	movs	r0, #1
                                 CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        }
    }

    return ret;
}
  10373c:	bd70      	pop	{r4, r5, r6, r15}
            if (c.cg_en_a != 0) {
  10373e:	07f1      	lsls	r1, r6, #31
  103740:	d50d      	bpl.n	10375e <clkgen_core_ctl_set+0xb2>
                writel(c.val, slice_addr);
  103742:	2164      	movs	r1, #100	; 0x64
                c.cg_en_a = 0;
  103744:	f36f 0600 	bfc	r6, #0, #1
                writel(c.val, slice_addr);
  103748:	501e      	str	r6, [r3, r0]
  10374a:	e001      	b.n	103750 <clkgen_core_ctl_set+0xa4>
    } while (--retrycount);
  10374c:	3901      	subs	r1, #1
  10374e:	d006      	beq.n	10375e <clkgen_core_ctl_set+0xb2>
        v = readl(reg);
  103750:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103752:	00ed      	lsls	r5, r5, #3
  103754:	d5fa      	bpl.n	10374c <clkgen_core_ctl_set+0xa0>
    RMWREG32(reg, start, width, setvalue);
  103756:	5819      	ldr	r1, [r3, r0]
  103758:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  10375c:	5019      	str	r1, [r3, r0]
            c.src_sel_a = ctl->src_sel_a;
  10375e:	7811      	ldrb	r1, [r2, #0]
  103760:	f3c1 0542 	ubfx	r5, r1, #1, #3
  103764:	f365 0643 	bfi	r6, r5, #1, #3
            c.cg_en_a = ctl->cg_en_a;
  103768:	f3c1 0100 	ubfx	r1, r1, #0, #1
  10376c:	f361 0600 	bfi	r6, r1, #0, #1
            if (c.cg_en_a)
  103770:	07f1      	lsls	r1, r6, #31
            writel(c.val, slice_addr);
  103772:	501e      	str	r6, [r3, r0]
            if (c.cg_en_a)
  103774:	d50a      	bpl.n	10378c <clkgen_core_ctl_set+0xe0>
  103776:	2164      	movs	r1, #100	; 0x64
  103778:	e001      	b.n	10377e <clkgen_core_ctl_set+0xd2>
    } while (--retrycount);
  10377a:	3901      	subs	r1, #1
  10377c:	d006      	beq.n	10378c <clkgen_core_ctl_set+0xe0>
        v = readl(reg);
  10377e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103780:	00ed      	lsls	r5, r5, #3
  103782:	d5fa      	bpl.n	10377a <clkgen_core_ctl_set+0xce>
    RMWREG32(reg, start, width, setvalue);
  103784:	5819      	ldr	r1, [r3, r0]
  103786:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  10378a:	5019      	str	r1, [r3, r0]
            writel(c.val, slice_addr);
  10378c:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 0;
  10378e:	f36f 2649 	bfc	r6, #9, #1
            writel(c.val, slice_addr);
  103792:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  103794:	7852      	ldrb	r2, [r2, #1]
  103796:	0892      	lsrs	r2, r2, #2
  103798:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  10379c:	501e      	str	r6, [r3, r0]
  10379e:	e003      	b.n	1037a8 <clkgen_core_ctl_set+0xfc>
        spin(1);
  1037a0:	f00f ffea 	bl	113778 <spin>
    } while (--retrycount);
  1037a4:	3d01      	subs	r5, #1
  1037a6:	d007      	beq.n	1037b8 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  1037a8:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1037aa:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1037ac:	2b00      	cmp	r3, #0
  1037ae:	dbf7      	blt.n	1037a0 <clkgen_core_ctl_set+0xf4>
            return true;
  1037b0:	2001      	movs	r0, #1
  1037b2:	e7c3      	b.n	10373c <clkgen_core_ctl_set+0x90>
    bool ret = true;
  1037b4:	2001      	movs	r0, #1
}
  1037b6:	4770      	bx	r14
    return false;
  1037b8:	2000      	movs	r0, #0
}
  1037ba:	bd70      	pop	{r4, r5, r6, r15}

001037bc <clkgen_mon_ip_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_ip_slice(vaddr_t base, uint16_t ip_slice_idx,
                             clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                             clkgen_slice_mon_ret_type ret_type)
{
  1037bc:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1037c0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1037c2:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  1037c6:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  1037ca:	d006      	beq.n	1037da <clkgen_mon_ip_slice+0x1e>
  1037cc:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  1037d0:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  1037d4:	bf18      	it	ne
  1037d6:	2000      	movne	r0, #0
  1037d8:	d162      	bne.n	1038a0 <clkgen_mon_ip_slice+0xe4>
  1037da:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  1037dc:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  1037e0:	4692      	mov	r10, r2
  1037e2:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  1037e6:	4689      	mov	r9, r1
  1037e8:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  1037ea:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    ip_slice_mon_base_addr = base + CLKGEN_IP_SLICE_MON_CTL_OFF;
  1037ee:	f500 1be4 	add.w	r11, r0, #1867776	; 0x1c8000
    reg_read = readl(mon_ctl_base_addr);
  1037f2:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  1037f4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1037f8:	6023      	str	r3, [r4, #0]
  1037fa:	e003      	b.n	103804 <clkgen_mon_ip_slice+0x48>
        spin(1);
  1037fc:	f00f ffbc 	bl	113778 <spin>
    } while (--retrycount);
  103800:	3d01      	subs	r5, #1
  103802:	d003      	beq.n	10380c <clkgen_mon_ip_slice+0x50>
        v = readl(reg);
  103804:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103806:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103808:	015b      	lsls	r3, r3, #5
  10380a:	d5f7      	bpl.n	1037fc <clkgen_mon_ip_slice+0x40>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(ip_slice_mon_base_addr);
  10380c:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read & (~CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL_MASK);
  103810:	0c09      	lsrs	r1, r1, #16
  103812:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL(
  103814:	ea49 0101 	orr.w	r1, r9, r1
                    ip_slice_idx);
    writel(reg_write, ip_slice_mon_base_addr);
  103818:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  10381c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  10381e:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
                    slice_mon_ip_clk); //ip slice
    writel(reg_write, mon_ctl_base_addr);
  103822:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  103824:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  103826:	f1ba 0f00 	cmp.w	r10, #0
  10382a:	d03b      	beq.n	1038a4 <clkgen_mon_ip_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  10382c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103830:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  103832:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  103834:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  103838:	0c1b      	lsrs	r3, r3, #16
  10383a:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  10383c:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  103840:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  103842:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  103844:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103848:	6023      	str	r3, [r4, #0]
  10384a:	e003      	b.n	103854 <clkgen_mon_ip_slice+0x98>
        spin(1);
  10384c:	f00f ff94 	bl	113778 <spin>
    } while (--retrycount);
  103850:	3d01      	subs	r5, #1
  103852:	d003      	beq.n	10385c <clkgen_mon_ip_slice+0xa0>
        v = readl(reg);
  103854:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103856:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103858:	0159      	lsls	r1, r3, #5
  10385a:	d4f7      	bmi.n	10384c <clkgen_mon_ip_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  10385c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  103860:	e003      	b.n	10386a <clkgen_mon_ip_slice+0xae>
        spin(1);
  103862:	f00f ff89 	bl	113778 <spin>
    } while (--retrycount);
  103866:	3d01      	subs	r5, #1
  103868:	d003      	beq.n	103872 <clkgen_mon_ip_slice+0xb6>
        v = readl(reg);
  10386a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10386c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10386e:	011a      	lsls	r2, r3, #4
  103870:	d5f7      	bpl.n	103862 <clkgen_mon_ip_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103872:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103874:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  103878:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  10387c:	6023      	str	r3, [r4, #0]
  10387e:	e003      	b.n	103888 <clkgen_mon_ip_slice+0xcc>
        spin(1);
  103880:	f00f ff7a 	bl	113778 <spin>
    } while (--retrycount);
  103884:	3d01      	subs	r5, #1
  103886:	d003      	beq.n	103890 <clkgen_mon_ip_slice+0xd4>
        v = readl(reg);
  103888:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10388a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10388c:	00db      	lsls	r3, r3, #3
  10388e:	d4f7      	bmi.n	103880 <clkgen_mon_ip_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  103890:	b967      	cbnz	r7, 1038ac <clkgen_mon_ip_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  103892:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  103896:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103898:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  10389a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  10389e:	6023      	str	r3, [r4, #0]
    return ret;
}
  1038a0:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  1038a4:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  1038a8:	6023      	str	r3, [r4, #0]
  1038aa:	e7c2      	b.n	103832 <clkgen_mon_ip_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  1038ac:	2f01      	cmp	r7, #1
  1038ae:	d00e      	beq.n	1038ce <clkgen_mon_ip_slice+0x112>
    else if (mon_min_freq == ret_type) {
  1038b0:	2f02      	cmp	r7, #2
  1038b2:	d008      	beq.n	1038c6 <clkgen_mon_ip_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  1038b4:	2f03      	cmp	r7, #3
  1038b6:	d010      	beq.n	1038da <clkgen_mon_ip_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  1038b8:	2f04      	cmp	r7, #4
        ret = 0;
  1038ba:	bf12      	itee	ne
  1038bc:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  1038be:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  1038c2:	6830      	ldreq	r0, [r6, #0]
  1038c4:	e7e8      	b.n	103898 <clkgen_mon_ip_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  1038c6:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  1038ca:	6830      	ldr	r0, [r6, #0]
  1038cc:	e7e4      	b.n	103898 <clkgen_mon_ip_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  1038ce:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  1038d2:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  1038d6:	6830      	ldr	r0, [r6, #0]
  1038d8:	e7de      	b.n	103898 <clkgen_mon_ip_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  1038da:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  1038de:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  1038e2:	6830      	ldr	r0, [r6, #0]
  1038e4:	e7d8      	b.n	103898 <clkgen_mon_ip_slice+0xdc>
  1038e6:	bf00      	nop

001038e8 <clkgen_mon_bus_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_bus_slice(vaddr_t base, uint16_t bus_slice_idx,
                              clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                              clkgen_slice_mon_ret_type ret_type)
{
  1038e8:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1038ec:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1038ee:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  1038f2:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  1038f6:	d006      	beq.n	103906 <clkgen_mon_bus_slice+0x1e>
  1038f8:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  1038fc:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  103900:	bf18      	it	ne
  103902:	2000      	movne	r0, #0
  103904:	d165      	bne.n	1039d2 <clkgen_mon_bus_slice+0xea>
  103906:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  103908:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  10390c:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  103910:	4693      	mov	r11, r2
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  103912:	f500 1ae4 	add.w	r10, r0, #1867776	; 0x1c8000
  103916:	4689      	mov	r9, r1
  103918:	4606      	mov	r6, r0
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
  10391a:	6823      	ldr	r3, [r4, #0]
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  10391c:	f50a 5a80 	add.w	r10, r10, #4096	; 0x1000
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103920:	2564      	movs	r5, #100	; 0x64
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103922:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103926:	6023      	str	r3, [r4, #0]
  103928:	e003      	b.n	103932 <clkgen_mon_bus_slice+0x4a>
        spin(1);
  10392a:	f00f ff25 	bl	113778 <spin>
    } while (--retrycount);
  10392e:	3d01      	subs	r5, #1
  103930:	d003      	beq.n	10393a <clkgen_mon_bus_slice+0x52>
        v = readl(reg);
  103932:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103934:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103936:	015b      	lsls	r3, r3, #5
  103938:	d5f7      	bpl.n	10392a <clkgen_mon_bus_slice+0x42>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 100);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(bus_slice_mon_base_addr);
  10393a:	f8da 1000 	ldr.w	r1, [r10]
    reg_write = reg_read & (~CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL_MASK);
  10393e:	0c09      	lsrs	r1, r1, #16
  103940:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL(
  103942:	ea49 0101 	orr.w	r1, r9, r1
                    bus_slice_idx);
    writel(reg_write, bus_slice_mon_base_addr);
  103946:	f8ca 1000 	str.w	r1, [r10]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  10394a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  10394c:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  103950:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
                    slice_mon_bus_clk); //bus slice
    writel(reg_write, mon_ctl_base_addr);
  103954:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  103956:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  103958:	f1bb 0f00 	cmp.w	r11, #0
  10395c:	d03b      	beq.n	1039d6 <clkgen_mon_bus_slice+0xee>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  10395e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103962:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  103964:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  103966:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  10396a:	0c1b      	lsrs	r3, r3, #16
  10396c:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  10396e:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  103972:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  103974:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  103976:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  10397a:	6023      	str	r3, [r4, #0]
  10397c:	e003      	b.n	103986 <clkgen_mon_bus_slice+0x9e>
        spin(1);
  10397e:	f00f fefb 	bl	113778 <spin>
    } while (--retrycount);
  103982:	3d01      	subs	r5, #1
  103984:	d003      	beq.n	10398e <clkgen_mon_bus_slice+0xa6>
        v = readl(reg);
  103986:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103988:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10398a:	0159      	lsls	r1, r3, #5
  10398c:	d4f7      	bmi.n	10397e <clkgen_mon_bus_slice+0x96>
    writel(reg_write, mon_ctl_base_addr);
  10398e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  103992:	e003      	b.n	10399c <clkgen_mon_bus_slice+0xb4>
        spin(1);
  103994:	f00f fef0 	bl	113778 <spin>
    } while (--retrycount);
  103998:	3d01      	subs	r5, #1
  10399a:	d003      	beq.n	1039a4 <clkgen_mon_bus_slice+0xbc>
        v = readl(reg);
  10399c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10399e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1039a0:	011a      	lsls	r2, r3, #4
  1039a2:	d5f7      	bpl.n	103994 <clkgen_mon_bus_slice+0xac>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  1039a4:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  1039a6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  1039aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  1039ae:	6023      	str	r3, [r4, #0]
  1039b0:	e003      	b.n	1039ba <clkgen_mon_bus_slice+0xd2>
        spin(1);
  1039b2:	f00f fee1 	bl	113778 <spin>
    } while (--retrycount);
  1039b6:	3d01      	subs	r5, #1
  1039b8:	d003      	beq.n	1039c2 <clkgen_mon_bus_slice+0xda>
        v = readl(reg);
  1039ba:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1039bc:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1039be:	00db      	lsls	r3, r3, #3
  1039c0:	d4f7      	bmi.n	1039b2 <clkgen_mon_bus_slice+0xca>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  1039c2:	b967      	cbnz	r7, 1039de <clkgen_mon_bus_slice+0xf6>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  1039c4:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  1039c8:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  1039ca:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  1039cc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1039d0:	6023      	str	r3, [r4, #0]
    return ret;
}
  1039d2:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  1039d6:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  1039da:	6023      	str	r3, [r4, #0]
  1039dc:	e7c2      	b.n	103964 <clkgen_mon_bus_slice+0x7c>
    else if (mon_avg_freq == ret_type) {
  1039de:	2f01      	cmp	r7, #1
  1039e0:	d00e      	beq.n	103a00 <clkgen_mon_bus_slice+0x118>
    else if (mon_min_freq == ret_type) {
  1039e2:	2f02      	cmp	r7, #2
  1039e4:	d008      	beq.n	1039f8 <clkgen_mon_bus_slice+0x110>
    else if (mon_max_duty == ret_type) {
  1039e6:	2f03      	cmp	r7, #3
  1039e8:	d010      	beq.n	103a0c <clkgen_mon_bus_slice+0x124>
    else if (mon_min_duty == ret_type) {
  1039ea:	2f04      	cmp	r7, #4
        ret = 0;
  1039ec:	bf12      	itee	ne
  1039ee:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  1039f0:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  1039f4:	6830      	ldreq	r0, [r6, #0]
  1039f6:	e7e8      	b.n	1039ca <clkgen_mon_bus_slice+0xe2>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  1039f8:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  1039fc:	6830      	ldr	r0, [r6, #0]
  1039fe:	e7e4      	b.n	1039ca <clkgen_mon_bus_slice+0xe2>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  103a00:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  103a04:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  103a08:	6830      	ldr	r0, [r6, #0]
  103a0a:	e7de      	b.n	1039ca <clkgen_mon_bus_slice+0xe2>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  103a0c:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  103a10:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  103a14:	6830      	ldr	r0, [r6, #0]
  103a16:	e7d8      	b.n	1039ca <clkgen_mon_bus_slice+0xe2>

00103a18 <clkgen_mon_core_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_core_slice(vaddr_t base, uint16_t core_slice_idx,
                               clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                               clkgen_slice_mon_ret_type ret_type)
{
  103a18:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  103a1c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103a1e:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  103a22:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  103a26:	d006      	beq.n	103a36 <clkgen_mon_core_slice+0x1e>
  103a28:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  103a2c:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  103a30:	bf18      	it	ne
  103a32:	2000      	movne	r0, #0
  103a34:	d162      	bne.n	103afc <clkgen_mon_core_slice+0xe4>
  103a36:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
    core_slice_mon_base_addr = base + CLKGEN_CORE_SLICE_MON_CTL_OFF;
  103a38:	f500 1be5 	add.w	r11, r0, #1875968	; 0x1ca000
  103a3c:	4692      	mov	r10, r2
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  103a3e:	f50b 5480 	add.w	r4, r11, #4096	; 0x1000
  103a42:	4689      	mov	r9, r1
  103a44:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103a46:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_read = readl(mon_ctl_base_addr);
  103a4a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103a4c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103a50:	6023      	str	r3, [r4, #0]
  103a52:	e003      	b.n	103a5c <clkgen_mon_core_slice+0x44>
        spin(1);
  103a54:	f00f fe90 	bl	113778 <spin>
    } while (--retrycount);
  103a58:	3d01      	subs	r5, #1
  103a5a:	d003      	beq.n	103a64 <clkgen_mon_core_slice+0x4c>
        v = readl(reg);
  103a5c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103a5e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103a60:	015b      	lsls	r3, r3, #5
  103a62:	d5f7      	bpl.n	103a54 <clkgen_mon_core_slice+0x3c>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(core_slice_mon_base_addr);
  103a64:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read &
  103a68:	0c09      	lsrs	r1, r1, #16
  103a6a:	0409      	lsls	r1, r1, #16
                (~CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL_MASK);
    reg_write = reg_write | CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL(
  103a6c:	ea49 0101 	orr.w	r1, r9, r1
                    core_slice_idx);
    writel(reg_write, core_slice_mon_base_addr);
  103a70:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  103a74:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  103a76:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  103a7a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
                    slice_mon_core_clk); //core slice
    writel(reg_write, mon_ctl_base_addr);
  103a7e:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  103a80:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  103a82:	f1ba 0f00 	cmp.w	r10, #0
  103a86:	d03b      	beq.n	103b00 <clkgen_mon_core_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  103a88:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103a8c:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  103a8e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  103a90:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  103a94:	0c1b      	lsrs	r3, r3, #16
  103a96:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  103a98:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  103a9c:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  103a9e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  103aa0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103aa4:	6023      	str	r3, [r4, #0]
  103aa6:	e003      	b.n	103ab0 <clkgen_mon_core_slice+0x98>
        spin(1);
  103aa8:	f00f fe66 	bl	113778 <spin>
    } while (--retrycount);
  103aac:	3d01      	subs	r5, #1
  103aae:	d003      	beq.n	103ab8 <clkgen_mon_core_slice+0xa0>
        v = readl(reg);
  103ab0:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103ab2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103ab4:	0159      	lsls	r1, r3, #5
  103ab6:	d4f7      	bmi.n	103aa8 <clkgen_mon_core_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  103ab8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  103abc:	e003      	b.n	103ac6 <clkgen_mon_core_slice+0xae>
        spin(1);
  103abe:	f00f fe5b 	bl	113778 <spin>
    } while (--retrycount);
  103ac2:	3d01      	subs	r5, #1
  103ac4:	d003      	beq.n	103ace <clkgen_mon_core_slice+0xb6>
        v = readl(reg);
  103ac6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103ac8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103aca:	011a      	lsls	r2, r3, #4
  103acc:	d5f7      	bpl.n	103abe <clkgen_mon_core_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103ace:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103ad0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  103ad4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  103ad8:	6023      	str	r3, [r4, #0]
  103ada:	e003      	b.n	103ae4 <clkgen_mon_core_slice+0xcc>
        spin(1);
  103adc:	f00f fe4c 	bl	113778 <spin>
    } while (--retrycount);
  103ae0:	3d01      	subs	r5, #1
  103ae2:	d003      	beq.n	103aec <clkgen_mon_core_slice+0xd4>
        v = readl(reg);
  103ae4:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103ae6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103ae8:	00db      	lsls	r3, r3, #3
  103aea:	d4f7      	bmi.n	103adc <clkgen_mon_core_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  103aec:	b967      	cbnz	r7, 103b08 <clkgen_mon_core_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  103aee:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  103af2:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103af4:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103af6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103afa:	6023      	str	r3, [r4, #0]
    return ret;
}
  103afc:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  103b00:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103b04:	6023      	str	r3, [r4, #0]
  103b06:	e7c2      	b.n	103a8e <clkgen_mon_core_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  103b08:	2f01      	cmp	r7, #1
  103b0a:	d00e      	beq.n	103b2a <clkgen_mon_core_slice+0x112>
    else if (mon_min_freq == ret_type) {
  103b0c:	2f02      	cmp	r7, #2
  103b0e:	d008      	beq.n	103b22 <clkgen_mon_core_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  103b10:	2f03      	cmp	r7, #3
  103b12:	d010      	beq.n	103b36 <clkgen_mon_core_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  103b14:	2f04      	cmp	r7, #4
        ret = 0;
  103b16:	bf12      	itee	ne
  103b18:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  103b1a:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  103b1e:	6830      	ldreq	r0, [r6, #0]
  103b20:	e7e8      	b.n	103af4 <clkgen_mon_core_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  103b22:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  103b26:	6830      	ldr	r0, [r6, #0]
  103b28:	e7e4      	b.n	103af4 <clkgen_mon_core_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  103b2a:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  103b2e:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  103b32:	6830      	ldr	r0, [r6, #0]
  103b34:	e7de      	b.n	103af4 <clkgen_mon_core_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  103b36:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  103b3a:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  103b3e:	6830      	ldr	r0, [r6, #0]
  103b40:	e7d8      	b.n	103af4 <clkgen_mon_core_slice+0xdc>
  103b42:	bf00      	nop

00103b44 <clkgen_uuu_clock_wrapper>:
    vaddr_t uuu_wrapper_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if (base != CKGEN_SOC_BASE) {
  103b44:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
{
  103b48:	b4f0      	push	{r4, r5, r6, r7}
  103b4a:	f89d 5010 	ldrb.w	r5, [r13, #16]
        LTRACEF("base paramenter error \n");
        return 0;
  103b4e:	bf18      	it	ne
  103b50:	2000      	movne	r0, #0
    if (base != CKGEN_SOC_BASE) {
  103b52:	d001      	beq.n	103b58 <clkgen_uuu_clock_wrapper+0x14>
#endif
    }

    ret = true;
    return ret;
}
  103b54:	bcf0      	pop	{r4, r5, r6, r7}
  103b56:	4770      	bx	r14
  103b58:	7814      	ldrb	r4, [r2, #0]
  103b5a:	0324      	lsls	r4, r4, #12
  103b5c:	7856      	ldrb	r6, [r2, #1]
  103b5e:	0236      	lsls	r6, r6, #8
  103b60:	b2a4      	uxth	r4, r4
  103b62:	7890      	ldrb	r0, [r2, #2]
  103b64:	f406 6670 	and.w	r6, r6, #3840	; 0xf00
  103b68:	78d7      	ldrb	r7, [r2, #3]
  103b6a:	0100      	lsls	r0, r0, #4
  103b6c:	ea44 0206 	orr.w	r2, r4, r6
    uuu_wrapper_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(
  103b70:	0309      	lsls	r1, r1, #12
  103b72:	f007 040f 	and.w	r4, r7, #15
  103b76:	f101 4176 	add.w	r1, r1, #4127195136	; 0xf6000000
  103b7a:	042d      	lsls	r5, r5, #16
  103b7c:	4322      	orrs	r2, r4
  103b7e:	b2c0      	uxtb	r0, r0
  103b80:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
  103b84:	f405 2570 	and.w	r5, r5, #983040	; 0xf0000
  103b88:	4302      	orrs	r2, r0
    if (low_power_mode) {
  103b8a:	b963      	cbnz	r3, 103ba6 <clkgen_uuu_clock_wrapper+0x62>
        reg_read = readl(uuu_wrapper_base_addr);
  103b8c:	680b      	ldr	r3, [r1, #0]
    return ret;
  103b8e:	2001      	movs	r0, #1
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(
  103b90:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type << 0);
  103b94:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103b96:	600d      	str	r5, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  103b98:	680b      	ldr	r3, [r1, #0]
}
  103b9a:	bcf0      	pop	{r4, r5, r6, r7}
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  103b9c:	0c1b      	lsrs	r3, r3, #16
  103b9e:	041b      	lsls	r3, r3, #16
        reg_write |= CLKGEN_UUU_SLICE_M_DIV_NUM(gasket_div->m_div_num)
  103ba0:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103ba2:	600a      	str	r2, [r1, #0]
}
  103ba4:	4770      	bx	r14
        reg_read = readl(uuu_wrapper_base_addr);
  103ba6:	680c      	ldr	r4, [r1, #0]
    return ret;
  103ba8:	4618      	mov	r0, r3
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  103baa:	0c23      	lsrs	r3, r4, #16
  103bac:	041b      	lsls	r3, r3, #16
        reg_write |=
  103bae:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103bb0:	600a      	str	r2, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  103bb2:	680b      	ldr	r3, [r1, #0]
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(0x3)));
  103bb4:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type);
  103bb8:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103bba:	600d      	str	r5, [r1, #0]
}
  103bbc:	bcf0      	pop	{r4, r5, r6, r7}
  103bbe:	4770      	bx	r14

00103bc0 <clkgen_uuu_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  103bc0:	b122      	cbz	r2, 103bcc <clkgen_uuu_ctl_get+0xc>
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103bc2:	f501 71c0 	add.w	r1, r1, #384	; 0x180
  103bc6:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  103bc8:	580b      	ldr	r3, [r1, r0]
  103bca:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  103bcc:	2001      	movs	r0, #1
  103bce:	4770      	bx	r14

00103bd0 <clkgen_uuu_ctl_set>:
                        const clkgen_uuu_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  103bd0:	b33a      	cbz	r2, 103c22 <clkgen_uuu_ctl_set+0x52>
        clkgen_uuu_ctl c;
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103bd2:	f501 71c0 	add.w	r1, r1, #384	; 0x180
{
  103bd6:	b470      	push	{r4, r5, r6}
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103bd8:	0309      	lsls	r1, r1, #12
        // 1.Program CKGEN_SOC corresponding slice to get proper clk_ckgen frequency. hal process
        //wait#######################
        // 2.Release SS reset(some ss don't have separate SS reset). set reset to 1 release reset,hal process
        //wait#######################
        // 3.Set clk_sel[0] and clk_sel[1]both to 0x0(default of both of them are 0x0)
        c.val = readl(slice_addr);
  103bda:	580b      	ldr	r3, [r1, r0]
        c.uuu_sel0 = 0;
  103bdc:	f36f 4310 	bfc	r3, #16, #1
        c.uuu_sel1 = 0;
  103be0:	f36f 4351 	bfc	r3, #17, #1
        writel(c.val, slice_addr);
  103be4:	500b      	str	r3, [r1, r0]
        // 4.Program PLL_x to enable PLL and get the proper frequency.(see PLL programming guide).
        // call pll func enable pll clock,
        //wait#######################
        // 5.Set Div_m/n/p/q to the proper value before change the clock source from ckgen to PLL.(Div_m/n/p/q can be changed on-the-fly.)
        c.m_div = ctl->m_div;
  103be6:	7855      	ldrb	r5, [r2, #1]
  103be8:	092e      	lsrs	r6, r5, #4
        c.n_div = ctl->n_div;
        c.p_div = ctl->p_div;
  103bea:	7814      	ldrb	r4, [r2, #0]
        c.m_div = ctl->m_div;
  103bec:	f366 330f 	bfi	r3, r6, #12, #4
        c.n_div = ctl->n_div;
  103bf0:	f3c5 0503 	ubfx	r5, r5, #0, #4
  103bf4:	f365 230b 	bfi	r3, r5, #8, #4
        c.p_div = ctl->p_div;
  103bf8:	0925      	lsrs	r5, r4, #4
  103bfa:	f365 1307 	bfi	r3, r5, #4, #4
        c.q_div = ctl->q_div;
  103bfe:	f3c4 0403 	ubfx	r4, r4, #0, #4
  103c02:	f364 0303 	bfi	r3, r4, #0, #4
        writel(c.val, slice_addr);
  103c06:	500b      	str	r3, [r1, r0]
        // 6.Set clk_sel[0] to 0x1 to set clk_out_1/2/3 source from PLL_x.
        // 7.Set clk_sel[1] to 0x1 to set clk_out_0 source from PLL_x.
        c.uuu_sel0 = ctl->uuu_sel0;
  103c08:	7892      	ldrb	r2, [r2, #2]
  103c0a:	f3c2 0400 	ubfx	r4, r2, #0, #1
  103c0e:	f364 4310 	bfi	r3, r4, #16, #1
        c.uuu_sel1 = ctl->uuu_sel1;
  103c12:	f3c2 0240 	ubfx	r2, r2, #1, #1
  103c16:	f362 4351 	bfi	r3, r2, #17, #1
        writel(c.val, slice_addr);
    }

    return ret;
}
  103c1a:	bc70      	pop	{r4, r5, r6}
        writel(c.val, slice_addr);
  103c1c:	500b      	str	r3, [r1, r0]
}
  103c1e:	2001      	movs	r0, #1
  103c20:	4770      	bx	r14
  103c22:	2001      	movs	r0, #1
  103c24:	4770      	bx	r14
  103c26:	bf00      	nop

00103c28 <clkgen_ipslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_ip_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103c28:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103c2c:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103c30:	d004      	beq.n	103c3c <clkgen_ipslice_debug_enable+0x14>
  103c32:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103c36:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103c3a:	d111      	bne.n	103c60 <clkgen_ipslice_debug_enable+0x38>
{
  103c3c:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_ip_base_addr = base + CLKGEN_IP_SLICE_DBG_CTL_OFF;
  103c3e:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103c42:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  103c46:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_ip_base_addr);
  103c4a:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_ip_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103c4c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103c50:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103c52:	4329      	orrs	r1, r5
    writel(reg_write, debug_ip_base_addr);
  103c54:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  103c56:	6819      	ldr	r1, [r3, #0]
}
  103c58:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103c5a:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  103c5c:	601a      	str	r2, [r3, #0]
}
  103c5e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103c60:	2000      	movs	r0, #0
}
  103c62:	4770      	bx	r14

00103c64 <clkgen_ipslice_debug_disable>:
{
    vaddr_t debug_crtl_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103c64:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103c68:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103c6c:	d004      	beq.n	103c78 <clkgen_ipslice_debug_disable+0x14>
  103c6e:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103c72:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103c76:	d109      	bne.n	103c8c <clkgen_ipslice_debug_disable+0x28>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103c78:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103c7c:	2001      	movs	r0, #1
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103c7e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_crtl_base_addr);
  103c82:	681a      	ldr	r2, [r3, #0]
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103c84:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_crtl_base_addr);
  103c88:	601a      	str	r2, [r3, #0]
    return true;
  103c8a:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103c8c:	2000      	movs	r0, #0
}
  103c8e:	4770      	bx	r14

00103c90 <clkgen_busslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_bus_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103c90:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103c94:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103c98:	d004      	beq.n	103ca4 <clkgen_busslice_debug_enable+0x14>
  103c9a:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103c9e:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103ca2:	d113      	bne.n	103ccc <clkgen_busslice_debug_enable+0x3c>
{
  103ca4:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_bus_base_addr = base + CLKGEN_BUS_SLICE_DBG_CTL_OFF;
  103ca6:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
  103caa:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103cae:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  103cb2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_bus_base_addr);
  103cb6:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_bus_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103cb8:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103cbc:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103cbe:	4329      	orrs	r1, r5
    writel(reg_write, debug_bus_base_addr);
  103cc0:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  103cc2:	6819      	ldr	r1, [r3, #0]
}
  103cc4:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103cc6:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  103cc8:	601a      	str	r2, [r3, #0]
}
  103cca:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103ccc:	2000      	movs	r0, #0
}
  103cce:	4770      	bx	r14

00103cd0 <clkgen_busslice_debug_disable>:
  103cd0:	f7ff bfc8 	b.w	103c64 <clkgen_ipslice_debug_disable>

00103cd4 <clkgen_coreslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_core_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103cd4:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103cd8:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103cdc:	d004      	beq.n	103ce8 <clkgen_coreslice_debug_enable+0x14>
  103cde:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103ce2:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103ce6:	d10f      	bne.n	103d08 <clkgen_coreslice_debug_enable+0x34>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_core_base_addr = base + CLKGEN_CORE_SLICE_DBG_CTL_OFF;
  103ce8:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
{
  103cec:	b430      	push	{r4, r5}
    reg_read = readl(debug_core_base_addr);
  103cee:	681d      	ldr	r5, [r3, #0]
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103cf0:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103cf4:	2001      	movs	r0, #1
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103cf6:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103cfa:	4329      	orrs	r1, r5
    writel(reg_write, debug_core_base_addr);
  103cfc:	6019      	str	r1, [r3, #0]
    reg_read = readl(debug_crtl_base_addr);
  103cfe:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103d00:	431a      	orrs	r2, r3
    writel(reg_write, debug_crtl_base_addr);
  103d02:	6022      	str	r2, [r4, #0]
}
  103d04:	bc30      	pop	{r4, r5}
  103d06:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d08:	2000      	movs	r0, #0
}
  103d0a:	4770      	bx	r14

00103d0c <clkgen_coreslice_debug_disable>:
  103d0c:	f7ff bfaa 	b.w	103c64 <clkgen_ipslice_debug_disable>

00103d10 <clkgen_uuuslice_debug_enable>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_enable(vaddr_t base, uint16_t slice_idx,
                                  uint8_t dbg_div)
{
  103d10:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103d12:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  103d16:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  103d1a:	d004      	beq.n	103d26 <clkgen_uuuslice_debug_enable+0x16>
  103d1c:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  103d20:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  103d24:	d111      	bne.n	103d4a <clkgen_uuuslice_debug_enable+0x3a>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103d26:	0309      	lsls	r1, r1, #12
  103d28:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
{
  103d2c:	b410      	push	{r4}
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
  103d2e:	58cc      	ldr	r4, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1);
    reg_write = reg_write & (~(CLKGEN_UUU_SLICE_DBG_DIV_NUM(0xF)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  103d30:	06d2      	lsls	r2, r2, #27
    writel(reg_write, debug_uuu_base_addr);
    return true;
  103d32:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  103d34:	f002 42f0 	and.w	r2, r2, #2013265920	; 0x78000000
  103d38:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
  103d3c:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  103d40:	4322      	orrs	r2, r4
}
  103d42:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(reg_write, debug_uuu_base_addr);
  103d46:	50ca      	str	r2, [r1, r3]
}
  103d48:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d4a:	2000      	movs	r0, #0
}
  103d4c:	4770      	bx	r14
  103d4e:	bf00      	nop

00103d50 <clkgen_uuuslice_debug_disable>:
//! \return true/false
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_disable(vaddr_t base, uint16_t slice_idx)
{
  103d50:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103d52:	f020 6280 	bic.w	r2, r0, #67108864	; 0x4000000
  103d56:	f1b2 4f78 	cmp.w	r2, #4160749568	; 0xf8000000
  103d5a:	d004      	beq.n	103d66 <clkgen_uuuslice_debug_disable+0x16>
  103d5c:	f420 1200 	bic.w	r2, r0, #2097152	; 0x200000
  103d60:	f1b2 4f76 	cmp.w	r2, #4127195136	; 0xf6000000
  103d64:	d108      	bne.n	103d78 <clkgen_uuuslice_debug_disable+0x28>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    writel(reg_write, debug_uuu_base_addr);
    return true;
  103d66:	2001      	movs	r0, #1
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103d68:	0309      	lsls	r1, r1, #12
  103d6a:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
    reg_read = readl(debug_uuu_base_addr);
  103d6e:	58ca      	ldr	r2, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
  103d70:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_uuu_base_addr);
  103d74:	50ca      	str	r2, [r1, r3]
    return true;
  103d76:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d78:	2000      	movs	r0, #0
}
  103d7a:	4770      	bx	r14

00103d7c <sram_config>:
#include <sram_conf.h>
#include <ce_reg.h>
#include <ce.h>

void sram_config(void)
{
  103d7c:	b430      	push	{r4, r5}

    value = reg_value(CE4_SRAM_SIZE, 0, CE4_RAM_SIZE_SHIFT, CE4_RAM_SIZE_MASK);
    value = reg_value(CE5_SRAM_SIZE, value, CE5_RAM_SIZE_SHIFT, CE5_RAM_SIZE_MASK);
    value = reg_value(CE6_SRAM_SIZE, value, CE6_RAM_SIZE_SHIFT, CE6_RAM_SIZE_MASK);
    value = reg_value(CE7_SRAM_SIZE, value, CE7_RAM_SIZE_SHIFT, CE7_RAM_SIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103d7e:	f248 0008 	movw	r0, #32776	; 0x8008
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103d82:	f248 0504 	movw	r5, #32772	; 0x8004

    value = reg_value(CE0_SEC_SRAM_SIZE, 0, CE0_RAM_SASIZE_SHIFT, CE0_RAM_SASIZE_MASK);
    value = reg_value(CE1_SEC_SRAM_SIZE, value, CE1_RAM_SASIZE_SHIFT, CE1_RAM_SASIZE_MASK);
    value = reg_value(CE2_SEC_SRAM_SIZE, value, CE2_RAM_SASIZE_SHIFT, CE2_RAM_SASIZE_MASK);
    value = reg_value(CE3_SEC_SRAM_SIZE, value, CE3_RAM_SASIZE_SHIFT, CE3_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103d86:	f248 010c 	movw	r1, #32780	; 0x800c

    value = reg_value(CE4_SEC_SRAM_SIZE, 0, CE4_RAM_SASIZE_SHIFT, CE4_RAM_SASIZE_MASK);
    value = reg_value(CE5_SEC_SRAM_SIZE, value, CE5_RAM_SASIZE_SHIFT, CE5_RAM_SASIZE_MASK);
    value = reg_value(CE6_SEC_SRAM_SIZE, value, CE6_RAM_SASIZE_SHIFT, CE6_RAM_SASIZE_MASK);
    value = reg_value(CE7_SEC_SRAM_SIZE, value, CE7_RAM_SASIZE_SHIFT, CE7_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103d8a:	f248 0310 	movw	r3, #32784	; 0x8010
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103d8e:	f04f 3408 	mov.w	r4, #134744072	; 0x8080808
  103d92:	f2cf 0534 	movt	r5, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103d96:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103d9a:	f2cf 0034 	movt	r0, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103d9e:	f2cf 0134 	movt	r1, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103da2:	602c      	str	r4, [r5, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103da4:	f2cf 0334 	movt	r3, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103da8:	6004      	str	r4, [r0, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103daa:	600a      	str	r2, [r1, #0]
}
  103dac:	bc30      	pop	{r4, r5}
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103dae:	601a      	str	r2, [r3, #0]
}
  103db0:	4770      	bx	r14
  103db2:	bf00      	nop

00103db4 <trng_irq_handle>:
    return 0;
}

enum handler_return trng_irq_handle(void* arg)
{
    event_signal(&g_trng_signal, false);
  103db4:	f24e 10e4 	movw	r0, #57828	; 0xe1e4
  103db8:	2100      	movs	r1, #0
{
  103dba:	b508      	push	{r3, r14}
    event_signal(&g_trng_signal, false);
  103dbc:	f2c0 0012 	movt	r0, #18
  103dc0:	f012 fb5a 	bl	116478 <event_signal>

    LTRACEF("trng_irq_handle\n");

    return 0;
}
  103dc4:	2000      	movs	r0, #0
  103dc6:	bd08      	pop	{r3, r15}

00103dc8 <ce_globle_init>:

    return 0;
}

int32_t ce_globle_init(void)
{
  103dc8:	b538      	push	{r3, r4, r5, r14}

    if (g_ce_inited) {
  103dca:	f24e 14e0 	movw	r4, #57824	; 0xe1e0
  103dce:	f2c0 0412 	movt	r4, #18
  103dd2:	7825      	ldrb	r5, [r4, #0]
  103dd4:	b9fd      	cbnz	r5, 103e16 <ce_globle_init+0x4e>
typedef unsigned long spin_lock_saved_state_t;
typedef unsigned long spin_lock_save_flags_t;

static inline void arch_spin_lock_init(spin_lock_t *lock)
{
    *lock = SPIN_LOCK_INITIAL_VALUE;
  103dd6:	f24f 53cc 	movw	r3, #62924	; 0xf5cc
    }

    LTRACEF("ce_globle_init enter\n");
    spin_lock_init(&(inheap.lock));

    event_init(&g_trng_signal, false, 0);
  103dda:	f24e 10e4 	movw	r0, #57828	; 0xe1e4
  103dde:	f2c0 0311 	movt	r3, #17
  103de2:	462a      	mov	r2, r5
  103de4:	f2c0 0012 	movt	r0, #18
  103de8:	60dd      	str	r5, [r3, #12]
  103dea:	4629      	mov	r1, r5
  103dec:	f012 fadc 	bl	1163a8 <event_init>
    register_int_handler(ZONE_TRNG_INT, &trng_irq_handle, (void*)0);
  103df0:	f643 51b5 	movw	r1, #15797	; 0x3db5
  103df4:	462a      	mov	r2, r5
  103df6:	f2c0 0110 	movt	r1, #16
  103dfa:	20cd      	movs	r0, #205	; 0xcd
  103dfc:	f7fc fc88 	bl	100710 <register_int_handler>

    sram_config();
  103e00:	f7ff ffbc 	bl	103d7c <sram_config>
    writel(0xffff, _ioaddr((src_saf_base + (0x210 << 10))));
  103e04:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  103e08:	f64f 71ff 	movw	r1, #65535	; 0xffff
    init_vce_key_interface();

    g_ce_inited = true;
  103e0c:	2201      	movs	r2, #1
    writel(0xffff, _ioaddr((src_saf_base + (0x210 << 10))));
  103e0e:	f6cf 4328 	movt	r3, #64552	; 0xfc28
  103e12:	6019      	str	r1, [r3, #0]
    g_ce_inited = true;
  103e14:	7022      	strb	r2, [r4, #0]

    return 0;
}
  103e16:	2000      	movs	r0, #0
  103e18:	bd38      	pop	{r3, r4, r5, r15}
  103e1a:	bf00      	nop

00103e1c <Dio_WriteChannel>:
    return RetVal;
}/* Dio_ReadChannel */

void Dio_WriteChannel(const Dio_ChannelType ChannelId,
                      const Dio_LevelType Level)
{
  103e1c:	f64e 1360 	movw	r3, #59744	; 0xe960

    if (Level & 0x01) {
  103e20:	07ca      	lsls	r2, r1, #31
  103e22:	f2c0 0312 	movt	r3, #18
  103e26:	681b      	ldr	r3, [r3, #0]
  103e28:	d50f      	bpl.n	103e4a <Dio_WriteChannel+0x2e>
        // output 1
        gpio_write((0x01 << GPIO_CTRL_DATA_OUT_BIT),
                   GPIO_BASE_ADDR + GPIO_SET_PIN_X(ChannelId));
  103e2a:	282f      	cmp	r0, #47	; 0x2f
  103e2c:	bf84      	itt	hi
  103e2e:	0100      	lslhi	r0, r0, #4
  103e30:	3004      	addhi	r0, #4
  103e32:	d807      	bhi.n	103e44 <Dio_WriteChannel+0x28>
  103e34:	2817      	cmp	r0, #23
  103e36:	ea4f 1000 	mov.w	r0, r0, lsl #4
  103e3a:	bf8c      	ite	hi
  103e3c:	f5a0 70be 	subhi.w	r0, r0, #380	; 0x17c
  103e40:	f500 70c2 	addls.w	r0, r0, #388	; 0x184
    vaddr_t        vaddr = (vaddr_t)paddr_to_kvaddr(paddr);
#else
    vaddr_t        vaddr = (vaddr_t)paddr;
#endif
    dprintf(INFO, "gpio_write:  value[0x%x], vaddr[0x%lx]\n", value, vaddr);
    writel(value, vaddr);
  103e44:	2204      	movs	r2, #4
  103e46:	50c2      	str	r2, [r0, r3]
}/* Dio_WriteChannel */
  103e48:	4770      	bx	r14
                   GPIO_BASE_ADDR + GPIO_CLEAR_PIN_X(ChannelId));
  103e4a:	282f      	cmp	r0, #47	; 0x2f
  103e4c:	bf84      	itt	hi
  103e4e:	0100      	lslhi	r0, r0, #4
  103e50:	3008      	addhi	r0, #8
  103e52:	d8f7      	bhi.n	103e44 <Dio_WriteChannel+0x28>
    writel(value, vaddr);
  103e54:	2204      	movs	r2, #4
                   GPIO_BASE_ADDR + GPIO_CLEAR_PIN_X(ChannelId));
  103e56:	2817      	cmp	r0, #23
  103e58:	ea4f 1000 	mov.w	r0, r0, lsl #4
  103e5c:	bf8c      	ite	hi
  103e5e:	f5a0 70bc 	subhi.w	r0, r0, #376	; 0x178
  103e62:	f500 70c4 	addls.w	r0, r0, #392	; 0x188
    writel(value, vaddr);
  103e66:	50c2      	str	r2, [r0, r3]
}/* Dio_WriteChannel */
  103e68:	4770      	bx	r14
  103e6a:	bf00      	nop

00103e6c <Dio_SetHandle>:
    if (handle != NULL) {
  103e6c:	b138      	cbz	r0, 103e7e <Dio_SetHandle+0x12>
        g_dio_handle.real_idx = p_handle->real_idx;
  103e6e:	e9d0 1200 	ldrd	r1, r2, [r0]
        g_dio_handle.phy_addr = p_handle->phy_addr;
  103e72:	f64e 1360 	movw	r3, #59744	; 0xe960
  103e76:	f2c0 0312 	movt	r3, #18
        g_dio_handle.real_idx = p_handle->real_idx;
  103e7a:	e9c3 1200 	strd	r1, r2, [r3]
}
  103e7e:	4770      	bx	r14

00103e80 <dsi_check_version>:
    return (src & ~mask) | ((val << shift) & mask);
}

static inline unsigned int disp_read(unsigned long base, unsigned int reg)
{
    return readl(base + reg);
  103e80:	6802      	ldr	r2, [r0, #0]
static bool dsi_check_version(struct dsi_context *ctx)
{
    addr_t base = ctx->base;

    /* DWC_mipi_dsi_host_1.140 */
    if (disp_read(base, MIPI_DSI_VERSION) == DSI_VESION_1_40A)
  103e82:	f243 032a 	movw	r3, #12330	; 0x302a
  103e86:	f2c3 1334 	movt	r3, #12596	; 0x3134
    return readl(base + reg);
  103e8a:	6810      	ldr	r0, [r2, #0]
        return true;

    return false;
}
  103e8c:	1ac0      	subs	r0, r0, r3
  103e8e:	fab0 f080 	clz	r0, r0
  103e92:	0940      	lsrs	r0, r0, #5
  103e94:	4770      	bx	r14
  103e96:	bf00      	nop

00103e98 <dsi_power_enable>:
    writel(value, base + reg);
  103e98:	6803      	ldr	r3, [r0, #0]
  103e9a:	6059      	str	r1, [r3, #4]
static void dsi_power_enable(struct dsi_context *ctx, int enable)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_PWR_UP, enable);
}
  103e9c:	4770      	bx	r14
  103e9e:	bf00      	nop

00103ea0 <dsi_get_power_status>:
    return readl(base + reg);
  103ea0:	6803      	ldr	r3, [r0, #0]
  103ea2:	6858      	ldr	r0, [r3, #4]
    val = (disp_read(base, MIPI_DSI_PWR_UP)
        & PWR_UP_SHUTDOWNZ_MASK)
        >> PWR_UP_SHUTDOWNZ_SHIFT;

    return val;
}
  103ea4:	f000 0001 	and.w	r0, r0, #1
  103ea8:	4770      	bx	r14
  103eaa:	bf00      	nop

00103eac <dsi_timeout_clock_division>:
    return readl(base + reg);
  103eac:	6803      	ldr	r3, [r0, #0]
  103eae:	689a      	ldr	r2, [r3, #8]
    return (src & ~mask) | ((val << shift) & mask);
  103eb0:	ea82 2101 	eor.w	r1, r2, r1, lsl #8
  103eb4:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
  103eb8:	4051      	eors	r1, r2
    writel(value, base + reg);
  103eba:	6099      	str	r1, [r3, #8]

    val = disp_read(base, MIPI_DSI_CLKMSG_CFG);
    val = reg_value(div, val, TO_CLK_DIVISION_SHIFT, TO_CLK_DIVISION_MASK);

    disp_write(base, MIPI_DSI_CLKMSG_CFG, val);
}
  103ebc:	4770      	bx	r14
  103ebe:	bf00      	nop

00103ec0 <dsi_tx_escape_division>:
    return readl(base + reg);
  103ec0:	6802      	ldr	r2, [r0, #0]
  103ec2:	6893      	ldr	r3, [r2, #8]
    return (src & ~mask) | ((val << shift) & mask);
  103ec4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  103ec8:	4319      	orrs	r1, r3
    writel(value, base + reg);
  103eca:	6091      	str	r1, [r2, #8]
    val = reg_value(division, val,
        TX_ESC_CLK_DIVISION_SHIFT,
        TX_ESC_CLK_DIVISION_MASK);

    disp_write(base, MIPI_DSI_CLKMSG_CFG, val);
}
  103ecc:	4770      	bx	r14
  103ece:	bf00      	nop

00103ed0 <dsi_video_vcid>:
    writel(value, base + reg);
  103ed0:	6803      	ldr	r3, [r0, #0]
  103ed2:	60d9      	str	r1, [r3, #12]
static void dsi_video_vcid(struct dsi_context *ctx, uint8_t vc)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_DPI_VCID, vc);
}
  103ed4:	4770      	bx	r14
  103ed6:	bf00      	nop

00103ed8 <dsi_get_video_vcid>:
    return readl(base + reg);
  103ed8:	6803      	ldr	r3, [r0, #0]
  103eda:	68d8      	ldr	r0, [r3, #12]
    val = (disp_read(base, MIPI_DSI_DPI_VCID)
        & DPI_VCID_MASK)
        >> DPI_VCID_SHIFT;

    return val;
}
  103edc:	f000 0002 	and.w	r0, r0, #2
  103ee0:	4770      	bx	r14
  103ee2:	bf00      	nop

00103ee4 <dsi_dpi_color_coding>:
    return readl(base + reg);
  103ee4:	6803      	ldr	r3, [r0, #0]
  103ee6:	691a      	ldr	r2, [r3, #16]
    return (src & ~mask) | ((val << shift) & mask);
  103ee8:	4051      	eors	r1, r2
  103eea:	f001 010f 	and.w	r1, r1, #15
  103eee:	4051      	eors	r1, r2
    writel(value, base + reg);
  103ef0:	6119      	str	r1, [r3, #16]

    val = disp_read(base, MIPI_DSI_DPI_COLOR_CODING);
    val = reg_value(coding, val, DPI_COLOR_CODING_SHIFT, DPI_COLOR_CODING_MASK);

    disp_write(base, MIPI_DSI_DPI_COLOR_CODING, val);
}
  103ef2:	4770      	bx	r14

00103ef4 <dsi_dpi_get_color_coding>:
    return readl(base + reg);
  103ef4:	6803      	ldr	r3, [r0, #0]
  103ef6:	6918      	ldr	r0, [r3, #16]
    val = (disp_read(base, MIPI_DSI_DPI_COLOR_CODING)
        & DPI_COLOR_CODING_MASK)
        >> DPI_COLOR_CODING_SHIFT;

    return val;
}
  103ef8:	f000 000f 	and.w	r0, r0, #15
  103efc:	4770      	bx	r14
  103efe:	bf00      	nop

00103f00 <dsi_dpi_get_color_depth>:
    return readl(base + reg);
  103f00:	6803      	ldr	r3, [r0, #0]
  103f02:	691b      	ldr	r3, [r3, #16]
    val = (disp_read(base, MIPI_DSI_DPI_COLOR_CODING)
  103f04:	f003 030f 	and.w	r3, r3, #15
  103f08:	2b0b      	cmp	r3, #11
  103f0a:	bfdd      	ittte	le
  103f0c:	f648 0220 	movwle	r2, #34848	; 0x8820
  103f10:	f2c0 0211 	movtle	r2, #17
  103f14:	5cd0      	ldrble	r0, [r2, r3]
  103f16:	2000      	movgt	r0, #0
			break;
		default:
			break;
	}
	return color_depth;
}
  103f18:	4770      	bx	r14
  103f1a:	bf00      	nop

00103f1c <dsi_dpi_get_color_config>:
    return readl(base + reg);
  103f1c:	6803      	ldr	r3, [r0, #0]
  103f1e:	691b      	ldr	r3, [r3, #16]
    val = (disp_read(base, MIPI_DSI_DPI_COLOR_CODING)
  103f20:	f003 030f 	and.w	r3, r3, #15
  103f24:	2b04      	cmp	r3, #4
  103f26:	bfdd      	ittte	le
  103f28:	f648 022c 	movwle	r2, #34860	; 0x882c
  103f2c:	f2c0 0211 	movtle	r2, #17
  103f30:	5cd0      	ldrble	r0, [r2, r3]
  103f32:	2000      	movgt	r0, #0
		default:
			color_config = 0;
			break;
	}
	return color_config;
}
  103f34:	4770      	bx	r14
  103f36:	bf00      	nop

00103f38 <dsi_dpi_18_loosely_packet_en>:
    return readl(base + reg);
  103f38:	6803      	ldr	r3, [r0, #0]
  103f3a:	691a      	ldr	r2, [r3, #16]
    return (src & ~mask) | ((val << shift) & mask);
  103f3c:	ea82 2101 	eor.w	r1, r2, r1, lsl #8
  103f40:	f401 7180 	and.w	r1, r1, #256	; 0x100
  103f44:	4051      	eors	r1, r2
    writel(value, base + reg);
  103f46:	6119      	str	r1, [r3, #16]

    val = disp_read(base, MIPI_DSI_DPI_COLOR_CODING);
    val = reg_value(enable, val, LOOSELY18_EN_SHIFT, LOOSELY18_EN_MASK);

    disp_write(base, MIPI_DSI_DPI_COLOR_CODING, val);
}
  103f48:	4770      	bx	r14
  103f4a:	bf00      	nop

00103f4c <dsi_dpi_color_mode_pol>:
    return readl(base + reg);
  103f4c:	6803      	ldr	r3, [r0, #0]
  103f4e:	695a      	ldr	r2, [r3, #20]
    return (src & ~mask) | ((val << shift) & mask);
  103f50:	ea82 1101 	eor.w	r1, r2, r1, lsl #4
  103f54:	f001 0110 	and.w	r1, r1, #16
  103f58:	4051      	eors	r1, r2
    writel(value, base + reg);
  103f5a:	6159      	str	r1, [r3, #20]
    val = reg_value(active_low, val,
        COLORM_ACTIVE_LOW_SHIFT,
        COLORM_ACTIVE_LOW_MASK);

    disp_write(base, MIPI_DSI_DPI_CFG_POL, val);
}
  103f5c:	4770      	bx	r14
  103f5e:	bf00      	nop

00103f60 <dsi_dpi_shut_down_pol>:
    return readl(base + reg);
  103f60:	6803      	ldr	r3, [r0, #0]
  103f62:	695a      	ldr	r2, [r3, #20]
    return (src & ~mask) | ((val << shift) & mask);
  103f64:	ea82 01c1 	eor.w	r1, r2, r1, lsl #3
  103f68:	f001 0108 	and.w	r1, r1, #8
  103f6c:	4051      	eors	r1, r2
    writel(value, base + reg);
  103f6e:	6159      	str	r1, [r3, #20]
    val = reg_value(active_low, val,
        SHUTD_ACTIVE_LOW_SHIFT,
        SHUTD_ACTIVE_LOW_MASK);

    disp_write(base, MIPI_DSI_DPI_CFG_POL, val);
}
  103f70:	4770      	bx	r14
  103f72:	bf00      	nop

00103f74 <dsi_dpi_hsync_pol>:
    return readl(base + reg);
  103f74:	6803      	ldr	r3, [r0, #0]
  103f76:	695a      	ldr	r2, [r3, #20]
    return (src & ~mask) | ((val << shift) & mask);
  103f78:	ea82 0181 	eor.w	r1, r2, r1, lsl #2
  103f7c:	f001 0104 	and.w	r1, r1, #4
  103f80:	4051      	eors	r1, r2
    writel(value, base + reg);
  103f82:	6159      	str	r1, [r3, #20]
    val = reg_value(active_low, val,
        HSYNC_ACTIVE_LOW_SHIFT,
        HSYNC_ACTIVE_LOW_MASK);

    disp_write(base, MIPI_DSI_DPI_CFG_POL, val);
}
  103f84:	4770      	bx	r14
  103f86:	bf00      	nop

00103f88 <dsi_dpi_vsync_pol>:
    return readl(base + reg);
  103f88:	6803      	ldr	r3, [r0, #0]
  103f8a:	695a      	ldr	r2, [r3, #20]
    return (src & ~mask) | ((val << shift) & mask);
  103f8c:	ea82 0141 	eor.w	r1, r2, r1, lsl #1
  103f90:	f001 0102 	and.w	r1, r1, #2
  103f94:	4051      	eors	r1, r2
    writel(value, base + reg);
  103f96:	6159      	str	r1, [r3, #20]
    val = reg_value(active_low, val,
        VSYNC_ACTIVE_LOW_SHIFT,
        VSYNC_ACTIVE_LOW_MASK);

    disp_write(base, MIPI_DSI_DPI_CFG_POL, val);
}
  103f98:	4770      	bx	r14
  103f9a:	bf00      	nop

00103f9c <dsi_dpi_data_en_pol>:
    return readl(base + reg);
  103f9c:	6803      	ldr	r3, [r0, #0]
  103f9e:	695a      	ldr	r2, [r3, #20]
    return (src & ~mask) | ((val << shift) & mask);
  103fa0:	4051      	eors	r1, r2
  103fa2:	f001 0101 	and.w	r1, r1, #1
  103fa6:	4051      	eors	r1, r2
    writel(value, base + reg);
  103fa8:	6159      	str	r1, [r3, #20]
    val = reg_value(active_low, val,
        DATAEN_ACTIVE_LOW_SHIFT,
        DATAEN_ACTIVE_LOW_MASK);

    disp_write(base, MIPI_DSI_DPI_CFG_POL, val);
}
  103faa:	4770      	bx	r14

00103fac <dsi_eotp_rx_en>:
    return readl(base + reg);
  103fac:	6803      	ldr	r3, [r0, #0]
  103fae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  103fb0:	ea82 0141 	eor.w	r1, r2, r1, lsl #1
  103fb4:	f001 0102 	and.w	r1, r1, #2
  103fb8:	4051      	eors	r1, r2
    writel(value, base + reg);
  103fba:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, EOTP_RX_EN_SHIFT, EOTP_RX_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  103fbc:	4770      	bx	r14
  103fbe:	bf00      	nop

00103fc0 <dsi_eotp_tx_en>:
    return readl(base + reg);
  103fc0:	6803      	ldr	r3, [r0, #0]
  103fc2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  103fc4:	4051      	eors	r1, r2
  103fc6:	f001 0101 	and.w	r1, r1, #1
  103fca:	4051      	eors	r1, r2
    writel(value, base + reg);
  103fcc:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, EOTP_TX_EN_SHIFT, EOTP_TX_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  103fce:	4770      	bx	r14

00103fd0 <dsi_bta_en>:
    return readl(base + reg);
  103fd0:	6803      	ldr	r3, [r0, #0]
  103fd2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  103fd4:	ea82 0181 	eor.w	r1, r2, r1, lsl #2
  103fd8:	f001 0104 	and.w	r1, r1, #4
  103fdc:	4051      	eors	r1, r2
    writel(value, base + reg);
  103fde:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, BTA_EN_SHIFT, BTA_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  103fe0:	4770      	bx	r14
  103fe2:	bf00      	nop

00103fe4 <dsi_ecc_rx_en>:
    return readl(base + reg);
  103fe4:	6803      	ldr	r3, [r0, #0]
  103fe6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  103fe8:	ea82 01c1 	eor.w	r1, r2, r1, lsl #3
  103fec:	f001 0108 	and.w	r1, r1, #8
  103ff0:	4051      	eors	r1, r2
    writel(value, base + reg);
  103ff2:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, ECC_RX_EN_SHIFT, ECC_RX_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  103ff4:	4770      	bx	r14
  103ff6:	bf00      	nop

00103ff8 <dsi_crc_rx_en>:
    return readl(base + reg);
  103ff8:	6803      	ldr	r3, [r0, #0]
  103ffa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  103ffc:	ea82 1101 	eor.w	r1, r2, r1, lsl #4
  104000:	f001 0110 	and.w	r1, r1, #16
  104004:	4051      	eors	r1, r2
    writel(value, base + reg);
  104006:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, CRC_RX_EN_SHIFT, CRC_RX_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  104008:	4770      	bx	r14
  10400a:	bf00      	nop

0010400c <dsi_eotp_tx_lp_en>:
    return readl(base + reg);
  10400c:	6803      	ldr	r3, [r0, #0]
  10400e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    return (src & ~mask) | ((val << shift) & mask);
  104010:	ea82 1141 	eor.w	r1, r2, r1, lsl #5
  104014:	f001 0120 	and.w	r1, r1, #32
  104018:	4051      	eors	r1, r2
    writel(value, base + reg);
  10401a:	62d9      	str	r1, [r3, #44]	; 0x2c

    val = disp_read(base, MIPI_DSI_PCKHDL_CFG);
    val = reg_value(enable, val, EOTP_TX_LP_EN_SHIFT, EOTP_TX_LP_EN_MASK);

    disp_write(base, MIPI_DSI_PCKHDL_CFG, val);
}
  10401c:	4770      	bx	r14
  10401e:	bf00      	nop

00104020 <dsi_rx_vcid>:
    return readl(base + reg);
  104020:	6803      	ldr	r3, [r0, #0]
  104022:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    return (src & ~mask) | ((val << shift) & mask);
  104024:	4051      	eors	r1, r2
  104026:	f001 0102 	and.w	r1, r1, #2
  10402a:	4051      	eors	r1, r2
    writel(value, base + reg);
  10402c:	6319      	str	r1, [r3, #48]	; 0x30

    val = disp_read(base, MIPI_DSI_GEN_VCID);
    val = reg_value(vc, val, GEN_VCID_RX_SHIFT, GEN_VCID_RX_MASK);

    disp_write(base, MIPI_DSI_GEN_VCID, val);
}
  10402e:	4770      	bx	r14

00104030 <dsi_video_mode>:
    writel(value, base + reg);
  104030:	6803      	ldr	r3, [r0, #0]
  104032:	2200      	movs	r2, #0
  104034:	635a      	str	r2, [r3, #52]	; 0x34
static void dsi_video_mode(struct dsi_context *ctx)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_MODE_CFG, 0);
}
  104036:	4770      	bx	r14

00104038 <dsi_cmd_mode>:
    writel(value, base + reg);
  104038:	6803      	ldr	r3, [r0, #0]
  10403a:	2201      	movs	r2, #1
  10403c:	635a      	str	r2, [r3, #52]	; 0x34
static void dsi_cmd_mode(struct dsi_context *ctx)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_MODE_CFG, 1);
}
  10403e:	4770      	bx	r14

00104040 <dsi_is_cmd_mode>:
    return readl(base + reg);
  104040:	6803      	ldr	r3, [r0, #0]
  104042:	6b58      	ldr	r0, [r3, #52]	; 0x34
    val = (disp_read(base, MIPI_DSI_MODE_CFG)
        & CMD_VIDEO_MODE_MASK)
        >> CMD_VIDEO_MODE_SHIFT;

    return val;
}
  104044:	f000 0001 	and.w	r0, r0, #1
  104048:	4770      	bx	r14
  10404a:	bf00      	nop

0010404c <dsi_video_mode_lp_cmd_en>:
    return readl(base + reg);
  10404c:	6803      	ldr	r3, [r0, #0]
  10404e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104050:	ea82 31c1 	eor.w	r1, r2, r1, lsl #15
  104054:	f401 4100 	and.w	r1, r1, #32768	; 0x8000
  104058:	4051      	eors	r1, r2
    writel(value, base + reg);
  10405a:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_CMD_EN_SHIFT, LP_CMD_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  10405c:	4770      	bx	r14
  10405e:	bf00      	nop

00104060 <dsi_video_mode_frame_ack_en>:
    return readl(base + reg);
  104060:	6803      	ldr	r3, [r0, #0]
  104062:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104064:	ea82 3181 	eor.w	r1, r2, r1, lsl #14
  104068:	f401 4180 	and.w	r1, r1, #16384	; 0x4000
  10406c:	4051      	eors	r1, r2
    writel(value, base + reg);
  10406e:	6399      	str	r1, [r3, #56]	; 0x38
    val = reg_value(enable, val,
        FRAME_BTA_ACK_EN_SHIFT,
        FRAME_BTA_ACK_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  104070:	4770      	bx	r14
  104072:	bf00      	nop

00104074 <dsi_video_mode_lp_hfp_en>:
    return readl(base + reg);
  104074:	6802      	ldr	r2, [r0, #0]
  104076:	6b93      	ldr	r3, [r2, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104078:	f023 030d 	bic.w	r3, r3, #13
    writel(value, base + reg);
  10407c:	6393      	str	r3, [r2, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_HFP_EN_SHIFT, LP_HFP_EN_SHIFT);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  10407e:	4770      	bx	r14

00104080 <dsi_video_mode_lp_hbp_en>:
    return readl(base + reg);
  104080:	6803      	ldr	r3, [r0, #0]
  104082:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104084:	ea82 3101 	eor.w	r1, r2, r1, lsl #12
  104088:	f401 5180 	and.w	r1, r1, #4096	; 0x1000
  10408c:	4051      	eors	r1, r2
    writel(value, base + reg);
  10408e:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_HBP_EN_SHIFT, LP_HBP_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  104090:	4770      	bx	r14
  104092:	bf00      	nop

00104094 <dsi_video_mode_lp_vact_en>:
    return readl(base + reg);
  104094:	6803      	ldr	r3, [r0, #0]
  104096:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104098:	ea82 21c1 	eor.w	r1, r2, r1, lsl #11
  10409c:	f401 6100 	and.w	r1, r1, #2048	; 0x800
  1040a0:	4051      	eors	r1, r2
    writel(value, base + reg);
  1040a2:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_VACT_EN_SHIFT, LP_VACT_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  1040a4:	4770      	bx	r14
  1040a6:	bf00      	nop

001040a8 <dsi_video_mode_lp_vfp_en>:
    return readl(base + reg);
  1040a8:	6803      	ldr	r3, [r0, #0]
  1040aa:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  1040ac:	ea82 2181 	eor.w	r1, r2, r1, lsl #10
  1040b0:	f401 6180 	and.w	r1, r1, #1024	; 0x400
  1040b4:	4051      	eors	r1, r2
    writel(value, base + reg);
  1040b6:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_VFP_EN_SHIFT, LP_VFP_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  1040b8:	4770      	bx	r14
  1040ba:	bf00      	nop

001040bc <dsi_video_mode_lp_vbp_en>:
    return readl(base + reg);
  1040bc:	6803      	ldr	r3, [r0, #0]
  1040be:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  1040c0:	ea82 2141 	eor.w	r1, r2, r1, lsl #9
  1040c4:	f401 7100 	and.w	r1, r1, #512	; 0x200
  1040c8:	4051      	eors	r1, r2
    writel(value, base + reg);
  1040ca:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_VBP_EN_SHIFT, LP_VBP_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  1040cc:	4770      	bx	r14
  1040ce:	bf00      	nop

001040d0 <dsi_video_mode_lp_vsa_en>:
    return readl(base + reg);
  1040d0:	6803      	ldr	r3, [r0, #0]
  1040d2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  1040d4:	ea82 2101 	eor.w	r1, r2, r1, lsl #8
  1040d8:	f401 7180 	and.w	r1, r1, #256	; 0x100
  1040dc:	4051      	eors	r1, r2
    writel(value, base + reg);
  1040de:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_VSA_EN_SHIFT, LP_VSA_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  1040e0:	4770      	bx	r14
  1040e2:	bf00      	nop

001040e4 <dsi_dpi_hporch_lp_en>:
    return readl(base + reg);
  1040e4:	6802      	ldr	r2, [r0, #0]
  1040e6:	6b90      	ldr	r0, [r2, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  1040e8:	ea80 3341 	eor.w	r3, r0, r1, lsl #13
  1040ec:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  1040f0:	4043      	eors	r3, r0
  1040f2:	ea83 3101 	eor.w	r1, r3, r1, lsl #12
  1040f6:	f401 5180 	and.w	r1, r1, #4096	; 0x1000
  1040fa:	4059      	eors	r1, r3
    writel(value, base + reg);
  1040fc:	6391      	str	r1, [r2, #56]	; 0x38
    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, LP_HFP_EN_SHIFT, LP_HFP_EN_MASK);
    val = reg_value(enable, val, LP_HBP_EN_SHIFT, LP_HBP_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  1040fe:	4770      	bx	r14

00104100 <dsi_dpi_vporch_lp_en>:
    return readl(base + reg);
  104100:	6800      	ldr	r0, [r0, #0]
  104102:	6b83      	ldr	r3, [r0, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104104:	ea83 22c1 	eor.w	r2, r3, r1, lsl #11
  104108:	f402 6200 	and.w	r2, r2, #2048	; 0x800
  10410c:	405a      	eors	r2, r3
  10410e:	ea82 2381 	eor.w	r3, r2, r1, lsl #10
  104112:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  104116:	405a      	eors	r2, r3
  104118:	ea82 2341 	eor.w	r3, r2, r1, lsl #9
  10411c:	f403 7300 	and.w	r3, r3, #512	; 0x200
  104120:	4053      	eors	r3, r2
  104122:	ea83 2101 	eor.w	r1, r3, r1, lsl #8
  104126:	f401 7180 	and.w	r1, r1, #256	; 0x100
  10412a:	4059      	eors	r1, r3
    writel(value, base + reg);
  10412c:	6381      	str	r1, [r0, #56]	; 0x38
    val = reg_value(enable, val, LP_VFP_EN_SHIFT, LP_VFP_EN_MASK);
    val = reg_value(enable, val, LP_VBP_EN_SHIFT, LP_VBP_EN_MASK);
    val = reg_value(enable, val, LP_VSA_EN_SHIFT, LP_VSA_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  10412e:	4770      	bx	r14

00104130 <dsi_video_mode_mode_type>:
    return readl(base + reg);
  104130:	6803      	ldr	r3, [r0, #0]
  104132:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104134:	4051      	eors	r1, r2
  104136:	f001 0103 	and.w	r1, r1, #3
  10413a:	4051      	eors	r1, r2
    writel(value, base + reg);
  10413c:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(mode, val, VID_MODE_TYPE_SHIFT, VID_MODE_TYPE_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  10413e:	4770      	bx	r14

00104140 <dsi_vpg_orientation_act>:
    return readl(base + reg);
  104140:	6803      	ldr	r3, [r0, #0]
  104142:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104144:	ea82 6101 	eor.w	r1, r2, r1, lsl #24
  104148:	f001 7180 	and.w	r1, r1, #16777216	; 0x1000000
  10414c:	4051      	eors	r1, r2
    writel(value, base + reg);
  10414e:	6399      	str	r1, [r3, #56]	; 0x38
    val = reg_value(orientation, val,
        VPG_ORIENTATION_SHIFT,
        VPG_ORIENTATION_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  104150:	4770      	bx	r14
  104152:	bf00      	nop

00104154 <dsi_vpg_mode_act>:
    return readl(base + reg);
  104154:	6803      	ldr	r3, [r0, #0]
  104156:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  104158:	ea82 5101 	eor.w	r1, r2, r1, lsl #20
  10415c:	f401 1180 	and.w	r1, r1, #1048576	; 0x100000
  104160:	4051      	eors	r1, r2
    writel(value, base + reg);
  104162:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(mode, val, VPG_MODE_SHIFT, VPG_MODE_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  104164:	4770      	bx	r14
  104166:	bf00      	nop

00104168 <dsi_enable_vpg_act>:
    return readl(base + reg);
  104168:	6803      	ldr	r3, [r0, #0]
  10416a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    return (src & ~mask) | ((val << shift) & mask);
  10416c:	ea82 4101 	eor.w	r1, r2, r1, lsl #16
  104170:	f401 3180 	and.w	r1, r1, #65536	; 0x10000
  104174:	4051      	eors	r1, r2
    writel(value, base + reg);
  104176:	6399      	str	r1, [r3, #56]	; 0x38

    val = disp_read(base, MIPI_DSI_VID_MODE_CFG);
    val = reg_value(enable, val, VPG_EN_SHIFT, VPG_EN_MASK);

    disp_write(base, MIPI_DSI_VID_MODE_CFG, val);
}
  104178:	4770      	bx	r14
  10417a:	bf00      	nop

0010417c <dsi_dpi_video_packet_size>:
    writel(value, base + reg);
  10417c:	6803      	ldr	r3, [r0, #0]
  10417e:	63d9      	str	r1, [r3, #60]	; 0x3c
    uint16_t size)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_PKT_SIZE, size);
}
  104180:	4770      	bx	r14
  104182:	bf00      	nop

00104184 <dsi_dpi_chunk_num>:
    writel(value, base + reg);
  104184:	6803      	ldr	r3, [r0, #0]
  104186:	6419      	str	r1, [r3, #64]	; 0x40
static void dsi_dpi_chunk_num(struct dsi_context *ctx, uint16_t num)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_NUM_CHUNKS, num);
}
  104188:	4770      	bx	r14
  10418a:	bf00      	nop

0010418c <dsi_dpi_null_packet_size>:
    writel(value, base + reg);
  10418c:	6803      	ldr	r3, [r0, #0]
  10418e:	6459      	str	r1, [r3, #68]	; 0x44
    uint16_t size)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_NULL_SIZE, size);
}
  104190:	4770      	bx	r14
  104192:	bf00      	nop

00104194 <dsi_dpi_hsync_time>:
    writel(value, base + reg);
  104194:	6803      	ldr	r3, [r0, #0]
  104196:	6499      	str	r1, [r3, #72]	; 0x48
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_HSA_TIME, byte_cycle);
}
  104198:	4770      	bx	r14
  10419a:	bf00      	nop

0010419c <dsi_dpi_hbp_time>:
    writel(value, base + reg);
  10419c:	6803      	ldr	r3, [r0, #0]
  10419e:	64d9      	str	r1, [r3, #76]	; 0x4c
static void dsi_dpi_hbp_time(struct dsi_context *ctx, uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_HBP_TIME, byte_cycle);
}
  1041a0:	4770      	bx	r14
  1041a2:	bf00      	nop

001041a4 <dsi_dpi_hline_time>:
    writel(value, base + reg);
  1041a4:	6803      	ldr	r3, [r0, #0]
  1041a6:	6519      	str	r1, [r3, #80]	; 0x50
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_HLINE_TIME, byte_cycle);
}
  1041a8:	4770      	bx	r14
  1041aa:	bf00      	nop

001041ac <dsi_dpi_vsync>:
    writel(value, base + reg);
  1041ac:	6803      	ldr	r3, [r0, #0]
  1041ae:	6559      	str	r1, [r3, #84]	; 0x54
static void dsi_dpi_vsync(struct dsi_context *ctx, uint16_t lines)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_VSA_LINES, lines);
}
  1041b0:	4770      	bx	r14
  1041b2:	bf00      	nop

001041b4 <dsi_dpi_vbp>:
    writel(value, base + reg);
  1041b4:	6803      	ldr	r3, [r0, #0]
  1041b6:	6599      	str	r1, [r3, #88]	; 0x58
static void dsi_dpi_vbp(struct dsi_context *ctx, uint16_t lines)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_VBP_LINES, lines);
}
  1041b8:	4770      	bx	r14
  1041ba:	bf00      	nop

001041bc <dsi_dpi_vfp>:
    writel(value, base + reg);
  1041bc:	6803      	ldr	r3, [r0, #0]
  1041be:	65d9      	str	r1, [r3, #92]	; 0x5c
static void dsi_dpi_vfp(struct dsi_context *ctx, uint16_t lines)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_VFP_LINES, lines);
}
  1041c0:	4770      	bx	r14
  1041c2:	bf00      	nop

001041c4 <dsi_dpi_vact>:
    writel(value, base + reg);
  1041c4:	6803      	ldr	r3, [r0, #0]
  1041c6:	6619      	str	r1, [r3, #96]	; 0x60
static void dsi_dpi_vact(struct dsi_context *ctx, uint16_t lines)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_VID_VACTIVE_LINES, lines);
}
  1041c8:	4770      	bx	r14
  1041ca:	bf00      	nop

001041cc <dsi_tear_effect_ack_en>:
    return readl(base + reg);
  1041cc:	6803      	ldr	r3, [r0, #0]
  1041ce:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    return (src & ~mask) | ((val << shift) & mask);
  1041d0:	4051      	eors	r1, r2
  1041d2:	f001 0101 	and.w	r1, r1, #1
  1041d6:	4051      	eors	r1, r2
    writel(value, base + reg);
  1041d8:	6699      	str	r1, [r3, #104]	; 0x68

    val = disp_read(base, MIPI_DSI_CMD_MODE_CFG);
    val = reg_value(enable, val, TEAR_FX_EN_SHIFT, TEAR_FX_EN_MASK);

    disp_write(base, MIPI_DSI_CMD_MODE_CFG, val);
}
  1041da:	4770      	bx	r14

001041dc <dsi_cmd_ack_request_en>:
    return readl(base + reg);
  1041dc:	6803      	ldr	r3, [r0, #0]
  1041de:	6e9a      	ldr	r2, [r3, #104]	; 0x68
    return (src & ~mask) | ((val << shift) & mask);
  1041e0:	ea82 0141 	eor.w	r1, r2, r1, lsl #1
  1041e4:	f001 0102 	and.w	r1, r1, #2
  1041e8:	4051      	eors	r1, r2
    writel(value, base + reg);
  1041ea:	6699      	str	r1, [r3, #104]	; 0x68

    val = disp_read(base, MIPI_DSI_CMD_MODE_CFG);
    val = reg_value(enable, val, ACK_RQST_EN_SHIFT, ACK_RQST_EN_MASK);

    disp_write(base, MIPI_DSI_CMD_MODE_CFG, val);
}
  1041ec:	4770      	bx	r14
  1041ee:	bf00      	nop

001041f0 <dsi_cmd_mode_lp_cmd_en>:
    return readl(base + reg);
  1041f0:	6800      	ldr	r0, [r0, #0]
  1041f2:	6e83      	ldr	r3, [r0, #104]	; 0x68
    return (src & ~mask) | ((val << shift) & mask);
  1041f4:	ea83 2201 	eor.w	r2, r3, r1, lsl #8
  1041f8:	f402 7280 	and.w	r2, r2, #256	; 0x100
  1041fc:	405a      	eors	r2, r3
  1041fe:	ea82 2341 	eor.w	r3, r2, r1, lsl #9
  104202:	f403 7300 	and.w	r3, r3, #512	; 0x200
  104206:	405a      	eors	r2, r3
  104208:	ea82 2381 	eor.w	r3, r2, r1, lsl #10
  10420c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  104210:	4053      	eors	r3, r2
  104212:	ea83 3281 	eor.w	r2, r3, r1, lsl #14
  104216:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
  10421a:	4053      	eors	r3, r2
  10421c:	ea83 4201 	eor.w	r2, r3, r1, lsl #16
  104220:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
  104224:	405a      	eors	r2, r3
  104226:	ea82 4341 	eor.w	r3, r2, r1, lsl #17
  10422a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  10422e:	405a      	eors	r2, r3
  104230:	ea82 43c1 	eor.w	r3, r2, r1, lsl #19
  104234:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  104238:	4053      	eors	r3, r2
  10423a:	ea83 6201 	eor.w	r2, r3, r1, lsl #24
  10423e:	f002 7280 	and.w	r2, r2, #16777216	; 0x1000000
  104242:	4053      	eors	r3, r2
  104244:	ea83 22c1 	eor.w	r2, r3, r1, lsl #11
  104248:	f402 6200 	and.w	r2, r2, #2048	; 0x800
  10424c:	405a      	eors	r2, r3
  10424e:	ea82 3301 	eor.w	r3, r2, r1, lsl #12
  104252:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  104256:	405a      	eors	r2, r3
  104258:	ea82 3341 	eor.w	r3, r2, r1, lsl #13
  10425c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  104260:	4053      	eors	r3, r2
  104262:	ea83 4181 	eor.w	r1, r3, r1, lsl #18
  104266:	f401 2180 	and.w	r1, r1, #262144	; 0x40000
  10426a:	4059      	eors	r1, r3
    writel(value, base + reg);
  10426c:	6681      	str	r1, [r0, #104]	; 0x68
    val = reg_value(enable, val, GEN_SR_1P_TX_SHIFT, GEN_SR_1P_TX_MASK);
    val = reg_value(enable, val, GEN_SR_2P_TX_SHIFT, GEN_SR_2P_TX_MASK);
    val = reg_value(enable, val, DCS_SR_0P_TX_SHIFT, DCS_SR_0P_TX_MASK);

    disp_write(base, MIPI_DSI_CMD_MODE_CFG, val);
}
  10426e:	4770      	bx	r14

00104270 <dsi_set_packet_header>:
static void dsi_set_packet_header(struct dsi_context *ctx,
    uint8_t vc,
    uint8_t type,
    uint8_t wc_lsb,
    uint8_t wc_msb)
{
  104270:	b430      	push	{r4, r5}
    return readl(base + reg);
  104272:	6804      	ldr	r4, [r0, #0]
{
  104274:	f89d 0008 	ldrb.w	r0, [r13, #8]
    return readl(base + reg);
  104278:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    return (src & ~mask) | ((val << shift) & mask);
  10427a:	406a      	eors	r2, r5
  10427c:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  104280:	406a      	eors	r2, r5
  104282:	ea82 1181 	eor.w	r1, r2, r1, lsl #6
  104286:	f001 0180 	and.w	r1, r1, #128	; 0x80
  10428a:	4051      	eors	r1, r2
  10428c:	ea81 2303 	eor.w	r3, r1, r3, lsl #8
  104290:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  104294:	404b      	eors	r3, r1
  104296:	ea83 4000 	eor.w	r0, r3, r0, lsl #16
  10429a:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
  10429e:	4058      	eors	r0, r3
    writel(value, base + reg);
  1042a0:	66e0      	str	r0, [r4, #108]	; 0x6c
    val = reg_value(vc, val, GEN_VC_SHIFT, GEN_VC_MASK);
    val = reg_value(wc_lsb, val, GEN_WC_LSBYTE_SHIFT, GEN_WC_LSBYTE_MASK);
    val = reg_value(wc_msb, val, GEN_WC_MSBYTE_SHIFT, GEN_WC_MSBYTE_MASK);

    disp_write(base, MIPI_DSI_GEN_HDR, val);
}
  1042a2:	bc30      	pop	{r4, r5}
  1042a4:	4770      	bx	r14
  1042a6:	bf00      	nop

001042a8 <dsi_set_packet_payload>:
    writel(value, base + reg);
  1042a8:	6803      	ldr	r3, [r0, #0]
  1042aa:	6719      	str	r1, [r3, #112]	; 0x70
    uint32_t payload)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_GEN_PLD_DATA, payload);
}
  1042ac:	4770      	bx	r14
  1042ae:	bf00      	nop

001042b0 <dsi_get_rx_payload>:
    return readl(base + reg);
  1042b0:	6803      	ldr	r3, [r0, #0]
  1042b2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
static void dsi_get_rx_payload(struct dsi_context *ctx,
    uint32_t *payload)
{
    addr_t base = ctx->base;

    *payload = disp_read(base, MIPI_DSI_GEN_PLD_DATA);
  1042b4:	600b      	str	r3, [r1, #0]
}
  1042b6:	4770      	bx	r14

001042b8 <dsi_is_bta_returned>:
    return readl(base + reg);
  1042b8:	6803      	ldr	r3, [r0, #0]
  1042ba:	6f58      	ldr	r0, [r3, #116]	; 0x74

    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_RD_CMD_BUSY_MASK)
        >> GEN_RD_CMD_BUSY_SHIFT;

    return !val;
  1042bc:	ea6f 1090 	mvn.w	r0, r0, lsr #6
}
  1042c0:	f000 0001 	and.w	r0, r0, #1
  1042c4:	4770      	bx	r14
  1042c6:	bf00      	nop

001042c8 <dsi_is_rx_payload_fifo_full>:
    return readl(base + reg);
  1042c8:	6803      	ldr	r3, [r0, #0]
  1042ca:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_PLD_R_FULL_MASK)
        >> GEN_PLD_R_FULL_SHIFT;

    return val;
}
  1042cc:	f3c0 1040 	ubfx	r0, r0, #5, #1
  1042d0:	4770      	bx	r14
  1042d2:	bf00      	nop

001042d4 <dsi_is_rx_payload_fifo_empty>:
    return readl(base + reg);
  1042d4:	6803      	ldr	r3, [r0, #0]
  1042d6:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_PLD_R_EMPTY_MASK)
        >> GEN_PLD_R_EMPTY_SHIFT;

    return val;
}
  1042d8:	f3c0 1000 	ubfx	r0, r0, #4, #1
  1042dc:	4770      	bx	r14
  1042de:	bf00      	nop

001042e0 <dsi_is_tx_payload_fifo_full>:
    return readl(base + reg);
  1042e0:	6803      	ldr	r3, [r0, #0]
  1042e2:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_PLD_W_FULL_MASK)
        >> GEN_PLD_W_FULL_SHIFT;

    return val;
}
  1042e4:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  1042e8:	4770      	bx	r14
  1042ea:	bf00      	nop

001042ec <dsi_is_tx_payload_fifo_empty>:
    return readl(base + reg);
  1042ec:	6803      	ldr	r3, [r0, #0]
  1042ee:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_PLD_W_EMPTY_MASK)
        >> GEN_PLD_W_EMPTY_SHIFT;

    return val;
}
  1042f0:	f3c0 0080 	ubfx	r0, r0, #2, #1
  1042f4:	4770      	bx	r14
  1042f6:	bf00      	nop

001042f8 <dsi_is_tx_cmd_fifo_full>:
    return readl(base + reg);
  1042f8:	6803      	ldr	r3, [r0, #0]
  1042fa:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_CMD_FULL_MASK)
        >> GEN_CMD_FULL_SHIFT;

    return val;
}
  1042fc:	f3c0 0040 	ubfx	r0, r0, #1, #1
  104300:	4770      	bx	r14
  104302:	bf00      	nop

00104304 <dsi_is_tx_cmd_fifo_empty>:
    return readl(base + reg);
  104304:	6803      	ldr	r3, [r0, #0]
  104306:	6f58      	ldr	r0, [r3, #116]	; 0x74
    val = (disp_read(base, MIPI_DSI_CMD_PKT_STATUS)
        & GEN_CMD_EMPTY_MASK)
        >> GEN_CMD_EMPTY_SHIFT;

    return val;
}
  104308:	f000 0001 	and.w	r0, r0, #1
  10430c:	4770      	bx	r14
  10430e:	bf00      	nop

00104310 <dsi_lp_rx_timeout>:
    return readl(base + reg);
  104310:	6802      	ldr	r2, [r0, #0]
  104312:	6f93      	ldr	r3, [r2, #120]	; 0x78
    return (src & ~mask) | ((val << shift) & mask);
  104314:	0c1b      	lsrs	r3, r3, #16
  104316:	041b      	lsls	r3, r3, #16
  104318:	4319      	orrs	r1, r3
    writel(value, base + reg);
  10431a:	6791      	str	r1, [r2, #120]	; 0x78

    val = disp_read(base, MIPI_DSI_TO_CNT_CFG);
    val = reg_value(byte_cycle, val, LPRX_TO_CNT_SHIFT, LPRX_TO_CNT_MASK);

    disp_write(base, MIPI_DSI_TO_CNT_CFG, val);
}
  10431c:	4770      	bx	r14
  10431e:	bf00      	nop

00104320 <dsi_hs_tx_timeout>:
    return readl(base + reg);
  104320:	6802      	ldr	r2, [r0, #0]
  104322:	6f93      	ldr	r3, [r2, #120]	; 0x78
    return (src & ~mask) | ((val << shift) & mask);
  104324:	b29b      	uxth	r3, r3
  104326:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
    writel(value, base + reg);
  10432a:	6791      	str	r1, [r2, #120]	; 0x78

    val = disp_read(base, MIPI_DSI_TO_CNT_CFG);
    val = reg_value(byte_cycle, val, HSTX_TO_CNT_SHIFT, HSTX_TO_CNT_MASK);

    disp_write(base, MIPI_DSI_TO_CNT_CFG, val);
}
  10432c:	4770      	bx	r14
  10432e:	bf00      	nop

00104330 <dsi_hs_read_presp_timeout>:
    writel(value, base + reg);
  104330:	6803      	ldr	r3, [r0, #0]
  104332:	67d9      	str	r1, [r3, #124]	; 0x7c
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_HS_RD_TO_CNT, byte_cycle);
}
  104334:	4770      	bx	r14
  104336:	bf00      	nop

00104338 <dsi_lp_read_presp_timeout>:
    writel(value, base + reg);
  104338:	6803      	ldr	r3, [r0, #0]
  10433a:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_LP_RD_TO_CNT, byte_cycle);
}
  10433e:	4770      	bx	r14

00104340 <dsi_hs_write_presp_timeout>:
    return readl(base + reg);
  104340:	6802      	ldr	r2, [r0, #0]
  104342:	f8d2 3084 	ldr.w	r3, [r2, #132]	; 0x84
    return (src & ~mask) | ((val << shift) & mask);
  104346:	0c1b      	lsrs	r3, r3, #16
  104348:	041b      	lsls	r3, r3, #16
  10434a:	4319      	orrs	r1, r3
    writel(value, base + reg);
  10434c:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84

    val = disp_read(base, MIPI_DSI_HS_WR_TO_CNT);
    val = reg_value(byte_cycle, val, HS_WR_TO_CNT_SHIFT, HS_WR_TO_CNT_MASK);

    disp_write(base, MIPI_DSI_HS_WR_TO_CNT, val);
}
  104350:	4770      	bx	r14
  104352:	bf00      	nop

00104354 <dsi_bta_presp_timeout>:
    writel(value, base + reg);
  104354:	6803      	ldr	r3, [r0, #0]
  104356:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_BTA_TO_CNT, byte_cycle);
}
  10435a:	4770      	bx	r14

0010435c <dsi_nc_clk_en>:
    return readl(base + reg);
  10435c:	6803      	ldr	r3, [r0, #0]
  10435e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    return (src & ~mask) | ((val << shift) & mask);
  104362:	ea82 0141 	eor.w	r1, r2, r1, lsl #1
  104366:	f001 0102 	and.w	r1, r1, #2
  10436a:	4051      	eors	r1, r2
    writel(value, base + reg);
  10436c:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
    val = reg_value(enable, val,
        AUTO_CLKLANE_CTRL_SHIFT,
        AUTO_CLKLANE_CTRL_MASK);

    disp_write(base, MIPI_DSI_LPCLK_CTRL, val);
}
  104370:	4770      	bx	r14
  104372:	bf00      	nop

00104374 <dsi_nc_clk_status>:
    return readl(base + reg);
  104374:	6803      	ldr	r3, [r0, #0]
  104376:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
    val = (disp_read(base, MIPI_DSI_LPCLK_CTRL)
        & AUTO_CLKLANE_CTRL_MASK)
        >> AUTO_CLKLANE_CTRL_SHIFT;

    return val;
}
  10437a:	f3c0 0040 	ubfx	r0, r0, #1, #1
  10437e:	4770      	bx	r14

00104380 <dsi_int0_status>:
    return readl(base + reg);
  104380:	6803      	ldr	r3, [r0, #0]

    if (val & ACK_WITH_ERR_15_MASK)
        DISPERR("ack_err: DSI protocol violation\n");

    return 0;
}
  104382:	2000      	movs	r0, #0
    return readl(base + reg);
  104384:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
}
  104388:	4770      	bx	r14
  10438a:	bf00      	nop

0010438c <dsi_int1_status>:
    return readl(base + reg);
  10438c:	6803      	ldr	r3, [r0, #0]
  10438e:	f8d3 00c0 	ldr.w	r0, [r3, #192]	; 0xc0

    if (val & GEN_PLD_RECEV_ERR_MASK)
        DISPERR("cmd read-payload-fifo is full\n");

    return status;
}
  104392:	f3c0 10c0 	ubfx	r0, r0, #7, #1
  104396:	4770      	bx	r14

00104398 <dsi_int0_mask>:
    writel(value, base + reg);
  104398:	6803      	ldr	r3, [r0, #0]
  10439a:	f8c3 10c4 	str.w	r1, [r3, #196]	; 0xc4
static void dsi_int0_mask(struct dsi_context *ctx, uint32_t mask)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_INT_MSK0, mask);
}
  10439e:	4770      	bx	r14

001043a0 <dsi_int_get_mask_0>:
    return readl(base + reg);
  1043a0:	6803      	ldr	r3, [r0, #0]
  1043a2:	f8d3 00c4 	ldr.w	r0, [r3, #196]	; 0xc4
static uint32_t dsi_int_get_mask_0(struct dsi_context *ctx, uint32_t mask)
{
    addr_t base = ctx->base;

    return disp_read(base, MIPI_DSI_INT_MSK0);
}
  1043a6:	4770      	bx	r14

001043a8 <dsi_int1_mask>:
    writel(value, base + reg);
  1043a8:	6803      	ldr	r3, [r0, #0]
  1043aa:	f8c3 10c8 	str.w	r1, [r3, #200]	; 0xc8
static void dsi_int1_mask(struct dsi_context *ctx, uint32_t mask)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_INT_MSK1, mask);
}
  1043ae:	4770      	bx	r14

001043b0 <dsi_int_get_mask_1>:
    return readl(base + reg);
  1043b0:	6803      	ldr	r3, [r0, #0]
  1043b2:	f8d3 00c8 	ldr.w	r0, [r3, #200]	; 0xc8
static uint32_t dsi_int_get_mask_1(struct dsi_context *ctx, uint32_t mask)
{
    addr_t base = ctx->base;

    return disp_read(base, MIPI_DSI_INT_MSK1);
}
  1043b6:	4770      	bx	r14

001043b8 <dsi_force_int_0>:
    writel(value, base + reg);
  1043b8:	6803      	ldr	r3, [r0, #0]
  1043ba:	f8c3 10d8 	str.w	r1, [r3, #216]	; 0xd8
static void dsi_force_int_0(struct dsi_context *ctx, uint32_t force)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_INT_FORCE0, force);
}
  1043be:	4770      	bx	r14

001043c0 <dsi_force_int_1>:
    writel(value, base + reg);
  1043c0:	6803      	ldr	r3, [r0, #0]
  1043c2:	f8c3 10dc 	str.w	r1, [r3, #220]	; 0xdc
static void dsi_force_int_1(struct dsi_context *ctx, uint32_t force)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_INT_FORCE1, force);
}
  1043c6:	4770      	bx	r14

001043c8 <dsi_max_read_time>:
    writel(value, base + reg);
  1043c8:	6803      	ldr	r3, [r0, #0]
  1043ca:	f8c3 10f4 	str.w	r1, [r3, #244]	; 0xf4
    uint16_t byte_cycle)
{
    addr_t base = ctx->base;

    disp_write(base, MIPI_DSI_PHY_TMR_RD_CFG, byte_cycle);
}
  1043ce:	4770      	bx	r14

001043d0 <dsi_activate_shadow_registers>:
    return readl(base + reg);
  1043d0:	6803      	ldr	r3, [r0, #0]
  1043d2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    return (src & ~mask) | ((val << shift) & mask);
  1043d6:	4051      	eors	r1, r2
  1043d8:	f001 0101 	and.w	r1, r1, #1
  1043dc:	4051      	eors	r1, r2
    writel(value, base + reg);
  1043de:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100

    val = disp_read(base, MIPI_DSI_VID_SHADOW_CTRL);
    val = reg_value(activate, val, VID_SHADOW_EN_SHIFT, VID_SHADOW_EN_MASK);

    disp_write(base, MIPI_DSI_VID_SHADOW_CTRL, val);
}
  1043e2:	4770      	bx	r14

001043e4 <dsi_read_state_shadow_registers>:
    return readl(base + reg);
  1043e4:	6803      	ldr	r3, [r0, #0]
  1043e6:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
    val = (disp_read(base, MIPI_DSI_VID_SHADOW_CTRL)
        & VID_SHADOW_EN_MASK)
        >> VID_SHADOW_EN_SHIFT;

    return val;
}
  1043ea:	f000 0001 	and.w	r0, r0, #1
  1043ee:	4770      	bx	r14

001043f0 <dsi_request_registers_change>:
    return readl(base + reg);
  1043f0:	6802      	ldr	r2, [r0, #0]
  1043f2:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
    return (src & ~mask) | ((val << shift) & mask);
  1043f6:	43cb      	mvns	r3, r1
  1043f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
  1043fc:	404b      	eors	r3, r1
    writel(value, base + reg);
  1043fe:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    val = disp_read(base, MIPI_DSI_VID_SHADOW_CTRL);
    val = reg_value(0x1, val, VID_SHADOW_REQ_SHIFT, VID_SHADOW_REQ_MASK);

    disp_write(base, MIPI_DSI_VID_SHADOW_CTRL, val);
}
  104402:	4770      	bx	r14

00104404 <dsi_external_pin_registers_change>:
    return readl(base + reg);
  104404:	6803      	ldr	r3, [r0, #0]
  104406:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    return (src & ~mask) | ((val << shift) & mask);
  10440a:	ea82 4101 	eor.w	r1, r2, r1, lsl #16
  10440e:	f401 3180 	and.w	r1, r1, #65536	; 0x10000
  104412:	4051      	eors	r1, r2
    writel(value, base + reg);
  104414:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    val = reg_value(external, val,
        VID_SHADOW_PIN_REQ_SHIFT,
        VID_SHADOW_PIN_REQ_MASK);

    disp_write(base, MIPI_DSI_VID_SHADOW_CTRL, val);
}
  104418:	4770      	bx	r14
  10441a:	bf00      	nop

0010441c <dsi_get_dpi_video_vc_act>:
    return readl(base + reg);
  10441c:	6803      	ldr	r3, [r0, #0]
  10441e:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
    val = (disp_read(base, MIPI_DSI_DPI_VCID_ACT)
        & DPI_VCID_MASK)
        >> DPI_VCID_SHIFT;

    return val;
}
  104422:	f000 0002 	and.w	r0, r0, #2
  104426:	4770      	bx	r14

00104428 <dsi_get_loosely18_en_act>:
    return readl(base + reg);
  104428:	6803      	ldr	r3, [r0, #0]
  10442a:	6918      	ldr	r0, [r3, #16]
    val = (disp_read(base, MIPI_DSI_DPI_COLOR_CODING)
        & LOOSELY18_EN_MASK)
        >> LOOSELY18_EN_SHIFT;

    return val;
}
  10442c:	f3c0 2000 	ubfx	r0, r0, #8, #1
  104430:	4770      	bx	r14
  104432:	bf00      	nop

00104434 <dsi_get_dpi_color_coding_act>:
  104434:	f7ff bd5e 	b.w	103ef4 <dsi_dpi_get_color_coding>

00104438 <dsi_get_lp_cmd_en_act>:
    return readl(base + reg);
  104438:	6803      	ldr	r3, [r0, #0]
  10443a:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_CMD_EN_MASK)
        >> ACT_LP_CMD_EN_SHIFT;

    return val;
}
  10443e:	f3c0 2040 	ubfx	r0, r0, #9, #1
  104442:	4770      	bx	r14

00104444 <dsi_get_frame_bta_ack_en_act>:
    return readl(base + reg);
  104444:	6803      	ldr	r3, [r0, #0]
  104446:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_FRAME_BTA_ACK_EN_MASK)
        >> ACT_FRAME_BTA_ACK_EN_SHIFT;

    return val;
}
  10444a:	f3c0 2000 	ubfx	r0, r0, #8, #1
  10444e:	4770      	bx	r14

00104450 <dsi_get_lp_hfp_en_act>:
    return readl(base + reg);
  104450:	6803      	ldr	r3, [r0, #0]
  104452:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_HFP_EN_MASK)
        >> ACT_LP_HFP_EN_SHIFT;

    return val;
}
  104456:	f3c0 10c0 	ubfx	r0, r0, #7, #1
  10445a:	4770      	bx	r14

0010445c <dsi_get_lp_hbp_en_act>:
    return readl(base + reg);
  10445c:	6803      	ldr	r3, [r0, #0]
  10445e:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_HBP_EN_MASK)
        >> ACT_LP_HBP_EN_SHIFT;

    return val;
}
  104462:	f3c0 1080 	ubfx	r0, r0, #6, #1
  104466:	4770      	bx	r14

00104468 <dsi_get_lp_vact_en_act>:
    return readl(base + reg);
  104468:	6803      	ldr	r3, [r0, #0]
  10446a:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_VACT_EN_MASK)
        >> ACT_LP_VACT_EN_SHIFT;

    return val;
}
  10446e:	f3c0 1040 	ubfx	r0, r0, #5, #1
  104472:	4770      	bx	r14

00104474 <dsi_get_lp_vfp_en_act>:
    return readl(base + reg);
  104474:	6803      	ldr	r3, [r0, #0]
  104476:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_VFP_EN_MASK)
        >> ACT_LP_VFP_EN_SHIFT;

    return val;
}
  10447a:	f3c0 1000 	ubfx	r0, r0, #4, #1
  10447e:	4770      	bx	r14

00104480 <dsi_get_lp_vbp_en_act>:
    return readl(base + reg);
  104480:	6803      	ldr	r3, [r0, #0]
  104482:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_VBP_EN_MASK)
        >> ACT_LP_VBP_EN_SHIFT;

    return val;
}
  104486:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  10448a:	4770      	bx	r14

0010448c <dsi_get_lp_vsa_en_act>:
    return readl(base + reg);
  10448c:	6803      	ldr	r3, [r0, #0]
  10448e:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_LP_VSA_EN_MASK)
        >> ACT_LP_VSA_EN_SHIFT;

    return val;
}
  104492:	f3c0 0080 	ubfx	r0, r0, #2, #1
  104496:	4770      	bx	r14

00104498 <dsi_get_vid_mode_type_act>:
    return readl(base + reg);
  104498:	6803      	ldr	r3, [r0, #0]
  10449a:	f8d3 0138 	ldr.w	r0, [r3, #312]	; 0x138
    val = (disp_read(base, MIPI_DSI_VID_MODE_CFG_ACT)
        & ACT_VID_MODE_TYPE_MASK)
        >> ACT_VID_MODE_TYPE_SHIFT;

    return val;
}
  10449e:	f000 0002 	and.w	r0, r0, #2
  1044a2:	4770      	bx	r14

001044a4 <dsi_get_vid_pkt_size_act>:
    return readl(base + reg);
  1044a4:	6803      	ldr	r3, [r0, #0]
  1044a6:	f8d3 013c 	ldr.w	r0, [r3, #316]	; 0x13c
    val = (disp_read(base, MIPI_DSI_VID_PKT_SIZE_ACT)
        & VID_PKT_SIZE_MASK)
        >> VID_PKT_SIZE_SHIFT;

    return val;
}
  1044aa:	f3c0 000d 	ubfx	r0, r0, #0, #14
  1044ae:	4770      	bx	r14

001044b0 <dsi_get_vid_num_chunks_act>:
    return readl(base + reg);
  1044b0:	6803      	ldr	r3, [r0, #0]
  1044b2:	f8d3 0140 	ldr.w	r0, [r3, #320]	; 0x140
    val = (disp_read(base, MIPI_DSI_VID_NUM_CHUNKS_ACT)
        & VID_NUM_CHUNKS_MASK)
        >> VID_NUM_CHUNKS_SHIFT;

    return val;
}
  1044b6:	f3c0 000c 	ubfx	r0, r0, #0, #13
  1044ba:	4770      	bx	r14

001044bc <dsi_get_vid_null_size_act>:
    return readl(base + reg);
  1044bc:	6803      	ldr	r3, [r0, #0]
  1044be:	f8d3 0144 	ldr.w	r0, [r3, #324]	; 0x144
    val = (disp_read(base, MIPI_DSI_VID_NULL_SIZE_ACT)
        & VID_NULL_SIZE_MASK)
        >> VID_NULL_SIZE_SHIFT;

    return val;
}
  1044c2:	f3c0 000c 	ubfx	r0, r0, #0, #13
  1044c6:	4770      	bx	r14

001044c8 <dsi_get_vid_hsa_time_act>:
    return readl(base + reg);
  1044c8:	6803      	ldr	r3, [r0, #0]
  1044ca:	f8d3 0148 	ldr.w	r0, [r3, #328]	; 0x148
    val = (disp_read(base, MIPI_DSI_VID_HSA_TIME_ACT)
        & VID_HSA_TIME_MASK)
        >> VID_HSA_TIME_SHIFT;

    return val;
}
  1044ce:	f3c0 000b 	ubfx	r0, r0, #0, #12
  1044d2:	4770      	bx	r14

001044d4 <dsi_get_vid_hbp_time_act>:
    return readl(base + reg);
  1044d4:	6803      	ldr	r3, [r0, #0]
  1044d6:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
    val = (disp_read(base, MIPI_DSI_VID_HBP_TIME_ACT)
        & VID_HBP_TIME_MASK)
        >> VID_HBP_TIME_SHIFT;

    return val;
}
  1044da:	f3c0 000b 	ubfx	r0, r0, #0, #12
  1044de:	4770      	bx	r14

001044e0 <dsi_get_vid_hline_time_act>:
    return readl(base + reg);
  1044e0:	6803      	ldr	r3, [r0, #0]
  1044e2:	f8d3 0150 	ldr.w	r0, [r3, #336]	; 0x150
    val = (disp_read(base, MIPI_DSI_VID_HLINE_TIME_ACT)
        & VID_HLINE_TIME_MASK)
        >> VID_HLINE_TIME_SHIFT;

    return val;
}
  1044e6:	f3c0 000e 	ubfx	r0, r0, #0, #15
  1044ea:	4770      	bx	r14

001044ec <dsi_get_vsa_lines_act>:
    return readl(base + reg);
  1044ec:	6803      	ldr	r3, [r0, #0]
  1044ee:	f8d3 0154 	ldr.w	r0, [r3, #340]	; 0x154
    val = (disp_read(base, MIPI_DSI_VID_VSA_LINES_ACT)
        & VSA_LINES_MASK)
        >> VSA_LINES_SHIFT;

    return val;
}
  1044f2:	f3c0 0009 	ubfx	r0, r0, #0, #10
  1044f6:	4770      	bx	r14

001044f8 <dsi_get_vbp_lines_act>:
    return readl(base + reg);
  1044f8:	6803      	ldr	r3, [r0, #0]
  1044fa:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
    val = (disp_read(base, MIPI_DSI_VID_VBP_LINES_ACT)
        & VBP_LINES_MASK)
        >> VBP_LINES_SHIFT;

    return val;
}
  1044fe:	f3c0 0009 	ubfx	r0, r0, #0, #10
  104502:	4770      	bx	r14

00104504 <dsi_get_vfp_lines_act>:
    return readl(base + reg);
  104504:	6803      	ldr	r3, [r0, #0]
  104506:	f8d3 015c 	ldr.w	r0, [r3, #348]	; 0x15c
    val = (disp_read(base, MIPI_DSI_VID_VFP_LINES_ACT)
        & VFP_LINES_MASK)
        >> VFP_LINES_SHIFT;

    return val;
}
  10450a:	f3c0 0009 	ubfx	r0, r0, #0, #10
  10450e:	4770      	bx	r14

00104510 <dsi_get_v_active_lines_act>:
    return readl(base + reg);
  104510:	6803      	ldr	r3, [r0, #0]
  104512:	f8d3 0160 	ldr.w	r0, [r3, #352]	; 0x160
    val = (disp_read(base, MIPI_DSI_VID_VACTIVE_LINES_ACT)
        & V_ACTIVE_LINES_MASK)
        >> V_ACTIVE_LINES_SHIFT;

    return val;
}
  104516:	f3c0 000d 	ubfx	r0, r0, #0, #14
  10451a:	4770      	bx	r14

0010451c <dsi_get_send_3d_cfg_act>:
    return readl(base + reg);
  10451c:	6803      	ldr	r3, [r0, #0]
  10451e:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
    val = (disp_read(base, MIPI_DSI_SDF_3D_ACT)
        & SEND_3D_CFG_MASK)
        >> SEND_3D_CFG_SHIFT;

    return val;
}
  104522:	f3c0 4000 	ubfx	r0, r0, #16, #1
  104526:	4770      	bx	r14

00104528 <dsi_get_right_left_act>:
    return readl(base + reg);
  104528:	6803      	ldr	r3, [r0, #0]
  10452a:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
    val = (disp_read(base, MIPI_DSI_SDF_3D_ACT)
        & RIGHT_FIRST_MASK)
        >> RIGHT_FIRST_SHIFT;

    return val;
}
  10452e:	f3c0 1040 	ubfx	r0, r0, #5, #1
  104532:	4770      	bx	r14

00104534 <dsi_get_second_vsync_act>:
    return readl(base + reg);
  104534:	6803      	ldr	r3, [r0, #0]
  104536:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
    val = (disp_read(base, MIPI_DSI_SDF_3D_ACT)
        & SECOND_VSYNC_MASK)
        >> SECOND_VSYNC_SHIFT;

    return val;
}
  10453a:	f3c0 1000 	ubfx	r0, r0, #4, #1
  10453e:	4770      	bx	r14

00104540 <dsi_get_format_3d_act>:
    return readl(base + reg);
  104540:	6803      	ldr	r3, [r0, #0]
  104542:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
    int val;
    addr_t base = ctx->base;

    val = (disp_read(base, MIPI_DSI_SDF_3D_ACT)
        & FORMAT_3D_MASK)
        >> FORMAT_3D_SHIFT;
  104546:	0880      	lsrs	r0, r0, #2

    return val;
}
  104548:	f000 0002 	and.w	r0, r0, #2
  10454c:	4770      	bx	r14
  10454e:	bf00      	nop

00104550 <dsi_get_mode_3d_act>:
    return readl(base + reg);
  104550:	6803      	ldr	r3, [r0, #0]
  104552:	f8d3 0190 	ldr.w	r0, [r3, #400]	; 0x190
    val = (disp_read(base, MIPI_DSI_SDF_3D_ACT)
        & MODE_3D_MASK)
        >> MODE_3D_SHIFT;

    return val;
}
  104556:	f000 0002 	and.w	r0, r0, #2
  10455a:	4770      	bx	r14

0010455c <dsi_dphy_clklane_hs2lp_config>:
    return readl(base + reg);
  10455c:	6802      	ldr	r2, [r0, #0]
    return (src & ~mask) | ((val << shift) & mask);
  10455e:	2300      	movs	r3, #0
  104560:	f2c0 33ff 	movt	r3, #1023	; 0x3ff
    return readl(base + reg);
  104564:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    return (src & ~mask) | ((val << shift) & mask);
  104568:	ea80 4101 	eor.w	r1, r0, r1, lsl #16
  10456c:	400b      	ands	r3, r1
  10456e:	4043      	eors	r3, r0
    writel(value, base + reg);
  104570:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    val = reg_value(byte_cycle, val,
        PHY_CLKHS2LP_TIME_SHIFT,
        PHY_CLKHS2LP_TIME_MASK);

    disp_write(base, MIPI_DSI_PHY_TMR_LPCLK_CFG, val);
}
  104574:	4770      	bx	r14
  104576:	bf00      	nop

00104578 <dsi_dphy_clklane_lp2hs_config>:
    return readl(base + reg);
  104578:	6803      	ldr	r3, [r0, #0]
  10457a:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
    return (src & ~mask) | ((val << shift) & mask);
  10457e:	4051      	eors	r1, r2
  104580:	f3c1 0109 	ubfx	r1, r1, #0, #10
  104584:	4051      	eors	r1, r2
    writel(value, base + reg);
  104586:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
    val = reg_value(byte_cycle, val,
        PHY_CLKLP2HS_TIME_SHIFT,
        PHY_CLKLP2HS_TIME_MASK);

    disp_write(base, MIPI_DSI_PHY_TMR_LPCLK_CFG, val);
}
  10458a:	4770      	bx	r14

0010458c <dsi_dphy_datalane_hs2lp_config>:
    return readl(base + reg);
  10458c:	6802      	ldr	r2, [r0, #0]
    return (src & ~mask) | ((val << shift) & mask);
  10458e:	2300      	movs	r3, #0
  104590:	f2c0 33ff 	movt	r3, #1023	; 0x3ff
    return readl(base + reg);
  104594:	f8d2 009c 	ldr.w	r0, [r2, #156]	; 0x9c
    return (src & ~mask) | ((val << shift) & mask);
  104598:	ea80 4101 	eor.w	r1, r0, r1, lsl #16
  10459c:	400b      	ands	r3, r1
  10459e:	4043      	eors	r3, r0
    writel(value, base + reg);
  1045a0:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    val = reg_value(byte_cycle, val,
        PHY_HS2LP_TIME_SHIFT,
        PHY_HS2LP_TIME_MASK);

    disp_write(base, MIPI_DSI_PHY_TMR_CFG, val);
}
  1045a4:	4770      	bx	r14
  1045a6:	bf00      	nop

001045a8 <dsi_dphy_datalane_lp2hs_config>:
    return readl(base + reg);
  1045a8:	6803      	ldr	r3, [r0, #0]
  1045aa:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
    return (src & ~mask) | ((val << shift) & mask);
  1045ae:	4051      	eors	r1, r2
  1045b0:	f3c1 0109 	ubfx	r1, r1, #0, #10
  1045b4:	4051      	eors	r1, r2
    writel(value, base + reg);
  1045b6:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
    val = reg_value(byte_cycle, val,
        PHY_LP2HS_TIME_SHIFT,
        PHY_LP2HS_TIME_MASK);

    disp_write(base, MIPI_DSI_PHY_TMR_CFG, val);
}
  1045ba:	4770      	bx	r14

001045bc <dsi_dphy_enableclk>:
    return readl(base + reg);
  1045bc:	6803      	ldr	r3, [r0, #0]
  1045be:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    return (src & ~mask) | ((val << shift) & mask);
  1045c2:	ea82 0181 	eor.w	r1, r2, r1, lsl #2
  1045c6:	f001 0104 	and.w	r1, r1, #4
  1045ca:	4051      	eors	r1, r2
    writel(value, base + reg);
  1045cc:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0

    val = disp_read(base, MIPI_DSI_PHY_RSTZ);
    val = reg_value(enable, val, PHY_ENABLECLK_SHIFT, PHY_ENABLECLK_MASK);

    disp_write(base, MIPI_DSI_PHY_RSTZ, val);
}
  1045d0:	4770      	bx	r14
  1045d2:	bf00      	nop

001045d4 <dsi_dphy_reset>:
    return readl(base + reg);
  1045d4:	6803      	ldr	r3, [r0, #0]
  1045d6:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    return (src & ~mask) | ((val << shift) & mask);
  1045da:	ea82 0141 	eor.w	r1, r2, r1, lsl #1
  1045de:	f001 0102 	and.w	r1, r1, #2
  1045e2:	4051      	eors	r1, r2
    writel(value, base + reg);
  1045e4:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0

    val = disp_read(base, MIPI_DSI_PHY_RSTZ);
    val = reg_value(reset, val, PHY_RSTZ_SHIFT, PHY_RSTZ_MASK);

    disp_write(base, MIPI_DSI_PHY_RSTZ, val);
}
  1045e8:	4770      	bx	r14
  1045ea:	bf00      	nop

001045ec <dsi_dphy_shutdown>:
    return readl(base + reg);
  1045ec:	6803      	ldr	r3, [r0, #0]
  1045ee:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    return (src & ~mask) | ((val << shift) & mask);
  1045f2:	4051      	eors	r1, r2
  1045f4:	f001 0101 	and.w	r1, r1, #1
  1045f8:	4051      	eors	r1, r2
    writel(value, base + reg);
  1045fa:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0

    val = disp_read(base, MIPI_DSI_PHY_RSTZ);
    val = reg_value(powerup, val, PHY_SHUTDOWNZ_SHIFT, PHY_SHUTDOWNZ_MASK);

    disp_write(base, MIPI_DSI_PHY_RSTZ, val);
}
  1045fe:	4770      	bx	r14

00104600 <dsi_dphy_force_pll>:
    return readl(base + reg);
  104600:	6803      	ldr	r3, [r0, #0]
  104602:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
    return (src & ~mask) | ((val << shift) & mask);
  104606:	ea82 01c1 	eor.w	r1, r2, r1, lsl #3
  10460a:	f001 0108 	and.w	r1, r1, #8
  10460e:	4051      	eors	r1, r2
    writel(value, base + reg);
  104610:	f8c3 10a0 	str.w	r1, [r3, #160]	; 0xa0

    val = disp_read(base, MIPI_DSI_PHY_RSTZ);
    val = reg_value(force, val, PHY_FORCEPLL_SHIFT, PHY_FORCEPLL_MASK);

    disp_write(base, MIPI_DSI_PHY_RSTZ, val);
}
  104614:	4770      	bx	r14
  104616:	bf00      	nop

00104618 <dsi_dphy_get_force_pll>:
    return readl(base + reg);
  104618:	6803      	ldr	r3, [r0, #0]
  10461a:	f8d3 00a0 	ldr.w	r0, [r3, #160]	; 0xa0
    val = (disp_read(base, MIPI_DSI_PHY_RSTZ)
        & PHY_FORCEPLL_MASK)
        >> PHY_FORCEPLL_SHIFT;

    return val;
}
  10461e:	f3c0 00c0 	ubfx	r0, r0, #3, #1
  104622:	4770      	bx	r14

00104624 <dsi_dphy_stop_wait_time>:
    return readl(base + reg);
  104624:	6803      	ldr	r3, [r0, #0]
  104626:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    return (src & ~mask) | ((val << shift) & mask);
  10462a:	ea82 2101 	eor.w	r1, r2, r1, lsl #8
  10462e:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
  104632:	4051      	eors	r1, r2
    writel(value, base + reg);
  104634:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4
    val = disp_read(base, MIPI_DSI_PHY_IF_CFG);
    val = reg_value(no_of_byte_cycles, val,
        PHY_STOP_WAIT_TIME_SHIFT, PHY_STOP_WAIT_TIME_MASK);

    disp_write(base, MIPI_DSI_PHY_IF_CFG, val);
}
  104638:	4770      	bx	r14
  10463a:	bf00      	nop

0010463c <dsi_dphy_n_lanes>:
    return readl(base + reg);
  10463c:	6803      	ldr	r3, [r0, #0]
{
    int val;
    addr_t base = ctx->base;

    val = disp_read(base, MIPI_DSI_PHY_IF_CFG);
    val = reg_value(n_lanes - 1, val, N_LANES_SHIFT, N_LANES_MASK);
  10463e:	3901      	subs	r1, #1
    return readl(base + reg);
  104640:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
    return (src & ~mask) | ((val << shift) & mask);
  104644:	4051      	eors	r1, r2
  104646:	f001 0103 	and.w	r1, r1, #3
  10464a:	4051      	eors	r1, r2
    writel(value, base + reg);
  10464c:	f8c3 10a4 	str.w	r1, [r3, #164]	; 0xa4

    disp_write(base, MIPI_DSI_PHY_IF_CFG, val);
}
  104650:	4770      	bx	r14
  104652:	bf00      	nop

00104654 <dsi_dphy_get_n_lanes>:
    return readl(base + reg);
  104654:	6803      	ldr	r3, [r0, #0]
  104656:	f8d3 00a4 	ldr.w	r0, [r3, #164]	; 0xa4
static uint8_t dsi_dphy_get_n_lanes(struct dsi_context *ctx)
{
    int val;
    addr_t base = ctx->base;

    val = (disp_read(base, MIPI_DSI_PHY_IF_CFG)
  10465a:	f000 0003 	and.w	r0, r0, #3
        & N_LANES_MASK)
        >> N_LANES_SHIFT;

    return (val + 1);
}
  10465e:	3001      	adds	r0, #1
  104660:	4770      	bx	r14
  104662:	bf00      	nop

00104664 <dsi_dphy_enable_hs_clk>:
    return readl(base + reg);
  104664:	6803      	ldr	r3, [r0, #0]
  104666:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
    return (src & ~mask) | ((val << shift) & mask);
  10466a:	4051      	eors	r1, r2
  10466c:	f001 0101 	and.w	r1, r1, #1
  104670:	4051      	eors	r1, r2
    writel(value, base + reg);
  104672:	f8c3 1094 	str.w	r1, [r3, #148]	; 0x94
    val = reg_value(enable, val,
        PHY_TXREQUESTCLKHS_SHIFT,
        PHY_TXREQUESTCLKHS_MASK);

    disp_write(base, MIPI_DSI_LPCLK_CTRL, val);
}
  104676:	4770      	bx	r14

00104678 <dsi_dphy_get_status>:
    return readl(base + reg);
  104678:	6803      	ldr	r3, [r0, #0]
  10467a:	f8d3 00b0 	ldr.w	r0, [r3, #176]	; 0xb0
    uint16_t mask)
{
    addr_t base = ctx->base;

    return disp_read(base, MIPI_DSI_PHY_STATUS) & mask;
}
  10467e:	4008      	ands	r0, r1
  104680:	4770      	bx	r14
  104682:	bf00      	nop

00104684 <dsi_dphy_test_clear>:
    return readl(base + reg);
  104684:	6803      	ldr	r3, [r0, #0]
  104686:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
    return (src & ~mask) | ((val << shift) & mask);
  10468a:	4051      	eors	r1, r2
  10468c:	f001 0101 	and.w	r1, r1, #1
  104690:	4051      	eors	r1, r2
    writel(value, base + reg);
  104692:	f8c3 10b4 	str.w	r1, [r3, #180]	; 0xb4

    val = disp_read(base, MIPI_DSI_PHY_TST_CTRL0);
    val = reg_value(value, val, PHY_TESTCLR_SHIFT, PHY_TESTCLR_MASK);

    disp_write(base, MIPI_DSI_PHY_TST_CTRL0, val);
}
  104696:	4770      	bx	r14

00104698 <dsi_dphy_write>:
    uint8_t *data, uint8_t data_length)
{
    unsigned i = 0;

    DISPDBG("TEST CODE: ADDR %X DATA %X\n", address, data[0]);
    if (data != 0) {
  104698:	2a00      	cmp	r2, #0
  10469a:	d043      	beq.n	104724 <dsi_dphy_write+0x8c>
{
  10469c:	b4f0      	push	{r4, r5, r6, r7}
        /* set the TESTCLK input high in preparation
         * to latch in the desired test mode */
        dsi_dphy_testclk(ctx, 1);
  10469e:	6804      	ldr	r4, [r0, #0]
    return readl(base + reg);
  1046a0:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
  1046a4:	f8d4 70b4 	ldr.w	r7, [r4, #180]	; 0xb4
  1046a8:	f104 05b8 	add.w	r5, r4, #184	; 0xb8
    return (src & ~mask) | ((val << shift) & mask);
  1046ac:	43fe      	mvns	r6, r7
  1046ae:	f006 0602 	and.w	r6, r6, #2
  1046b2:	407e      	eors	r6, r7
    writel(value, base + reg);
  1046b4:	f8c4 60b4 	str.w	r6, [r4, #180]	; 0xb4
    return readl(base + reg);
  1046b8:	f8d4 60b8 	ldr.w	r6, [r4, #184]	; 0xb8
    return (src & ~mask) | ((val << shift) & mask);
  1046bc:	4071      	eors	r1, r6
  1046be:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  1046c2:	4071      	eors	r1, r6
    writel(value, base + reg);
  1046c4:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
    return readl(base + reg);
  1046c8:	f8d4 60b8 	ldr.w	r6, [r4, #184]	; 0xb8
    return (src & ~mask) | ((val << shift) & mask);
  1046cc:	43f1      	mvns	r1, r6
  1046ce:	f401 3180 	and.w	r1, r1, #65536	; 0x10000
  1046d2:	4071      	eors	r1, r6
    writel(value, base + reg);
  1046d4:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
    return readl(base + reg);
  1046d8:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
    return (src & ~mask) | ((val << shift) & mask);
  1046dc:	f021 0102 	bic.w	r1, r1, #2
    writel(value, base + reg);
  1046e0:	f8c4 10b4 	str.w	r1, [r4, #180]	; 0xb4
    return readl(base + reg);
  1046e4:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
    return (src & ~mask) | ((val << shift) & mask);
  1046e8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    writel(value, base + reg);
  1046ec:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
        dsi_dphy_testclk(ctx, 0);
        /* set TESTEN input low to disable further test mode
         * code latching  */
        dsi_dphy_testen(ctx, 0);
        /* start writing MSB first */
        for (i = data_length; i > 0; i--) {
  1046f0:	b1b3      	cbz	r3, 104720 <dsi_dphy_write+0x88>
  1046f2:	4413      	add	r3, r2
    return readl(base + reg);
  1046f4:	6829      	ldr	r1, [r5, #0]
    val = reg_value(test_data, val, PHY_TESTDIN_SHIFT, PHY_TESTDIN_MASK);
  1046f6:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
        for (i = data_length; i > 0; i--) {
  1046fa:	429a      	cmp	r2, r3
    return (src & ~mask) | ((val << shift) & mask);
  1046fc:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  104700:	ea41 0104 	orr.w	r1, r1, r4
    writel(value, base + reg);
  104704:	6029      	str	r1, [r5, #0]
    return readl(base + reg);
  104706:	6804      	ldr	r4, [r0, #0]
    return (src & ~mask) | ((val << shift) & mask);
  104708:	ea6f 0104 	mvn.w	r1, r4
  10470c:	f001 0102 	and.w	r1, r1, #2
  104710:	ea81 0104 	eor.w	r1, r1, r4
    writel(value, base + reg);
  104714:	6001      	str	r1, [r0, #0]
    return readl(base + reg);
  104716:	6801      	ldr	r1, [r0, #0]
    return (src & ~mask) | ((val << shift) & mask);
  104718:	f021 0102 	bic.w	r1, r1, #2
    writel(value, base + reg);
  10471c:	6001      	str	r1, [r0, #0]
        for (i = data_length; i > 0; i--) {
  10471e:	d1e9      	bne.n	1046f4 <dsi_dphy_write+0x5c>
             * as necessary */
            dsi_dphy_testclk(ctx, 1);
            dsi_dphy_testclk(ctx, 0);
        }
    }
}
  104720:	bcf0      	pop	{r4, r5, r6, r7}
  104722:	4770      	bx	r14
  104724:	4770      	bx	r14
  104726:	bf00      	nop

00104728 <mipi_dsih_dphy_configure>:
}


int mipi_dsih_dphy_configure(struct dsi_context *ctx,
    uint8_t num_of_lanes, uint32_t output_data_rate)
{
  104728:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10472c:	4605      	mov	r5, r0
  10472e:	f5ad 7d05 	sub.w	r13, r13, #532	; 0x214
    struct
    {
        uint32_t data_rate; /* upper margin of frequency range */
        uint8_t hs_freq;	/* hsfreqrange */
        uint8_t vco_range;  /* vcorange */
    } ranges[] =
  104732:	f10d 0818 	add.w	r8, r13, #24
{
  104736:	9101      	str	r1, [sp, #4]
    } ranges[] =
  104738:	f248 6128 	movw	r1, #34344	; 0x8628
{
  10473c:	4614      	mov	r4, r2
    unsigned long output_freq = output_data_rate / 2;
  10473e:	0857      	lsrs	r7, r2, #1
    } ranges[] =
  104740:	4640      	mov	r0, r8
  104742:	f2c0 0111 	movt	r1, #17
    struct dsi_core_ops *dsi_ops = ctx->ops;
  104746:	6fee      	ldr	r6, [r5, #124]	; 0x7c
    } ranges[] =
  104748:	f44f 72fc 	mov.w	r2, #504	; 0x1f8
  10474c:	f00f e8a8 	blx	1138a0 <memcpy>
            {2500, 0x49, 0x01}};

    if (ctx == NULL)
        return -1;

    if (output_freq < MIN_OUTPUT_FREQ)
  104750:	2f4f      	cmp	r7, #79	; 0x4f
  104752:	f240 8151 	bls.w	1049f8 <mipi_dsih_dphy_configure+0x2d0>
        return -1;

    for (i = 0; i < ARRAYSIZE(ranges); i++) {
        if ((output_data_rate / 1000) <= ranges[i].data_rate) {
  104756:	f644 51d3 	movw	r1, #19923	; 0x4dd3
  10475a:	2300      	movs	r3, #0
  10475c:	f2c1 0162 	movt	r1, #4194	; 0x1062
  104760:	fba1 2104 	umull	r2, r1, r1, r4
  104764:	0989      	lsrs	r1, r1, #6
  104766:	e002      	b.n	10476e <mipi_dsih_dphy_configure+0x46>
    for (i = 0; i < ARRAYSIZE(ranges); i++) {
  104768:	2b3f      	cmp	r3, #63	; 0x3f
  10476a:	f000 8141 	beq.w	1049f0 <mipi_dsih_dphy_configure+0x2c8>
        if ((output_data_rate / 1000) <= ranges[i].data_rate) {
  10476e:	f858 0033 	ldr.w	r0, [r8, r3, lsl #3]
  104772:	461a      	mov	r2, r3
  104774:	3301      	adds	r3, #1
  104776:	4281      	cmp	r1, r0
  104778:	d8f6      	bhi.n	104768 <mipi_dsih_dphy_configure+0x40>
  10477a:	4682      	mov	r10, r0
        DISPERR("Your input output_data_rate=%d is out of our ranges",
            output_data_rate);
        return -1;
    }

    switch (ranges[range_index].vco_range >> 4) {
  10477c:	00d3      	lsls	r3, r2, #3
  10477e:	9303      	str	r3, [sp, #12]
  104780:	4443      	add	r3, r8
  104782:	795b      	ldrb	r3, [r3, #5]
  104784:	9302      	str	r3, [sp, #8]
  104786:	091b      	lsrs	r3, r3, #4
            vco_divider = 8;
            break;
        case 2:
            vco_divider = 4;
        default:
            vco_divider = 2;
  104788:	2b03      	cmp	r3, #3
  10478a:	bf0c      	ite	eq
  10478c:	2308      	moveq	r3, #8
  10478e:	2302      	movne	r3, #2
    }

    if (ranges[range_index].data_rate > 640)
  104790:	f5ba 7f20 	cmp.w	r10, #640	; 0x280
  104794:	f240 8129 	bls.w	1049ea <mipi_dsih_dphy_configure+0x2c2>
        vco_divider = 1;

    output_freq = output_freq * vco_divider;

    loop_divider = (output_freq * (reference_freq / DPHY_DIV_LOWER_LIMIT)) / reference_freq;
  104798:	f641 13f1 	movw	r3, #6641	; 0x19f1
  10479c:	eb07 0147 	add.w	r1, r7, r7, lsl #1

    /*Here delta will account for the rounding*/
    delta = (loop_divider * reference_freq) / (reference_freq / DPHY_DIV_LOWER_LIMIT) - output_freq;
  1047a0:	f645 52c0 	movw	r2, #24000	; 0x5dc0
    loop_divider = (output_freq * (reference_freq / DPHY_DIV_LOWER_LIMIT)) / reference_freq;
  1047a4:	f2c0 5376 	movt	r3, #1398	; 0x576

    for (input_divider = 1 + reference_freq / DPHY_DIV_UPPER_LIMIT;
        ((reference_freq / input_divider) >= DPHY_DIV_LOWER_LIMIT) && (!flag);
        input_divider++) {
        tmp_loop_divider = (output_freq * input_divider) / reference_freq;
  1047a8:	469e      	mov	r14, r3
    loop_divider = (output_freq * (reference_freq / DPHY_DIV_LOWER_LIMIT)) / reference_freq;
  1047aa:	0089      	lsls	r1, r1, #2
        ((reference_freq / input_divider) >= DPHY_DIV_LOWER_LIMIT) && (!flag);
  1047ac:	4694      	mov	r12, r2
    delta = (loop_divider * reference_freq) / (reference_freq / DPHY_DIV_LOWER_LIMIT) - output_freq;
  1047ae:	f64a 20ab 	movw	r0, #43691	; 0xaaab
    loop_divider = (output_freq * (reference_freq / DPHY_DIV_LOWER_LIMIT)) / reference_freq;
  1047b2:	fba3 3101 	umull	r3, r1, r3, r1
    unsigned int step = 0;
  1047b6:	f04f 0900 	mov.w	r9, #0
    delta = (loop_divider * reference_freq) / (reference_freq / DPHY_DIV_LOWER_LIMIT) - output_freq;
  1047ba:	f6ca 20aa 	movt	r0, #43690	; 0xaaaa
    for (input_divider = 1 + reference_freq / DPHY_DIV_UPPER_LIMIT;
  1047be:	f04f 0b04 	mov.w	r11, #4
        ((reference_freq / input_divider) >= DPHY_DIV_LOWER_LIMIT) && (!flag);
  1047c2:	f241 7370 	movw	r3, #6000	; 0x1770
    loop_divider = (output_freq * (reference_freq / DPHY_DIV_LOWER_LIMIT)) / reference_freq;
  1047c6:	0a49      	lsrs	r1, r1, #9
    delta = (loop_divider * reference_freq) / (reference_freq / DPHY_DIV_LOWER_LIMIT) - output_freq;
  1047c8:	fb02 f201 	mul.w	r2, r2, r1
  1047cc:	fba0 0202 	umull	r0, r2, r0, r2
  1047d0:	ebc7 02d2 	rsb	r2, r7, r2, lsr #3
        tmp_loop_divider = (output_freq * input_divider) / reference_freq;
  1047d4:	fb0b f407 	mul.w	r4, r11, r7
  1047d8:	fbae 0404 	umull	r0, r4, r14, r4
  1047dc:	0a64      	lsrs	r4, r4, #9
        if ((tmp_loop_divider % 2) == 0) {
  1047de:	07e0      	lsls	r0, r4, #31
  1047e0:	d415      	bmi.n	10480e <mipi_dsih_dphy_configure+0xe6>
            /*if even*/
            if (output_freq == tmp_loop_divider * (reference_freq / input_divider)) {
  1047e2:	fb03 f304 	mul.w	r3, r3, r4
  1047e6:	42bb      	cmp	r3, r7
  1047e8:	d033      	beq.n	104852 <mipi_dsih_dphy_configure+0x12a>

                /*variable was incremented before exiting the loop*/
                input_divider--;
            }

            if ((output_freq - tmp_loop_divider * (reference_freq / input_divider)) < delta) {
  1047ea:	fbbc f0fb 	udiv	r0, r12, r11
  1047ee:	fb04 7010 	mls	r0, r4, r0, r7
  1047f2:	4290      	cmp	r0, r2
  1047f4:	d21b      	bcs.n	10482e <mipi_dsih_dphy_configure+0x106>
        input_divider++) {
  1047f6:	f10b 0b01 	add.w	r11, r11, #1
        ((reference_freq / input_divider) >= DPHY_DIV_LOWER_LIMIT) && (!flag);
  1047fa:	fbbc f3fb 	udiv	r3, r12, r11
    for (input_divider = 1 + reference_freq / DPHY_DIV_UPPER_LIMIT;
  1047fe:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  104802:	d31d      	bcc.n	104840 <mipi_dsih_dphy_configure+0x118>
  104804:	4602      	mov	r2, r0
  104806:	4621      	mov	r1, r4
                /* values found with smaller delta */
                loop_divider = tmp_loop_divider;

                delta =
                output_freq - (tmp_loop_divider * (reference_freq / input_divider));
                step = 1;
  104808:	f04f 0901 	mov.w	r9, #1
  10480c:	e7e2      	b.n	1047d4 <mipi_dsih_dphy_configure+0xac>
            }
        } else {
            tmp_loop_divider += 1;
  10480e:	3401      	adds	r4, #1

            if (output_freq == tmp_loop_divider * (reference_freq / input_divider)) {
  104810:	fb03 f304 	mul.w	r3, r3, r4
  104814:	42bb      	cmp	r3, r7
  104816:	d01c      	beq.n	104852 <mipi_dsih_dphy_configure+0x12a>

                /*variable was incremented before exiting the loop*/
                input_divider--;
            }

            if ((tmp_loop_divider * (reference_freq / input_divider) - output_freq) < delta) {
  104818:	fbbc f3fb 	udiv	r3, r12, r11
  10481c:	fb04 f303 	mul.w	r3, r4, r3
  104820:	1bdb      	subs	r3, r3, r7
  104822:	4293      	cmp	r3, r2
  104824:	bf3e      	ittt	cc
  104826:	461a      	movcc	r2, r3
            tmp_loop_divider += 1;
  104828:	4621      	movcc	r1, r4
                /* values found with smaller delta */
                loop_divider = tmp_loop_divider;
                delta = tmp_loop_divider * (reference_freq / input_divider) - output_freq;
                step = 0;
  10482a:	f04f 0900 	movcc.w	r9, #0
        input_divider++) {
  10482e:	f10b 0b01 	add.w	r11, r11, #1
        ((reference_freq / input_divider) >= DPHY_DIV_LOWER_LIMIT) && (!flag);
  104832:	fbbc f3fb 	udiv	r3, r12, r11
    for (input_divider = 1 + reference_freq / DPHY_DIV_UPPER_LIMIT;
  104836:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
  10483a:	d2cb      	bcs.n	1047d4 <mipi_dsih_dphy_configure+0xac>
  10483c:	460c      	mov	r4, r1
  10483e:	e001      	b.n	104844 <mipi_dsih_dphy_configure+0x11c>
                step = 1;
  104840:	f04f 0901 	mov.w	r9, #1
            }
        }
    }

    if (!flag)
        input_divider = step + (loop_divider * reference_freq) / output_freq;
  104844:	f645 5bc0 	movw	r11, #24000	; 0x5dc0
  104848:	fb0b fb04 	mul.w	r11, r11, r4
  10484c:	fbbb fbf7 	udiv	r11, r11, r7
  104850:	44cb      	add	r11, r9
    /*
     * Get the PHY in power down mode
     * (shutdownz = 0) and reset it (rstz = 0) to avoid transient
     * periods in PHY operation during re-configuration procedures
     */
    dsi_ops->dphy_reset(ctx, 0);
  104852:	f8d6 31d8 	ldr.w	r3, [r6, #472]	; 0x1d8
  104856:	2100      	movs	r1, #0
  104858:	4628      	mov	r0, r5
    dsi_ops->dphy_test_clear(ctx, 1);
    dsi_ops->dphy_test_clear(ctx, 0);

    #if 1  // this is is_g118
    /* PLL Analog Programmability Control */
    data[0] = 0x01;
  10485a:	f04f 0901 	mov.w	r9, #1
    dsi_ops->dphy_reset(ctx, 0);
  10485e:	4798      	blx	r3
    dsi_ops->dphy_enableclk(ctx, 0);
  104860:	f8d6 31d4 	ldr.w	r3, [r6, #468]	; 0x1d4
  104864:	2100      	movs	r1, #0
  104866:	4628      	mov	r0, r5
  104868:	4798      	blx	r3
    dsi_ops->dphy_shutdown(ctx, 0);
  10486a:	f8d6 31dc 	ldr.w	r3, [r6, #476]	; 0x1dc
  10486e:	2100      	movs	r1, #0
  104870:	4628      	mov	r0, r5
  104872:	4798      	blx	r3
    dsi_ops->dphy_test_clear(ctx, 1);
  104874:	4649      	mov	r1, r9
  104876:	f8d6 31fc 	ldr.w	r3, [r6, #508]	; 0x1fc
  10487a:	4628      	mov	r0, r5
  10487c:	4798      	blx	r3
    dsi_ops->dphy_test_clear(ctx, 0);
  10487e:	f8d6 31fc 	ldr.w	r3, [r6, #508]	; 0x1fc
  104882:	2100      	movs	r1, #0
  104884:	4628      	mov	r0, r5
  104886:	4798      	blx	r3
    dsi_ops->dphy_write(ctx, 0x1F, data, 1);
  104888:	464b      	mov	r3, r9
    data[0] = 0x01;
  10488a:	f88d 9014 	strb.w	r9, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x1F, data, 1);
  10488e:	aa05      	add	r2, sp, #20
  104890:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  104894:	211f      	movs	r1, #31
  104896:	4628      	mov	r0, r5
    if (ranges[range_index].data_rate > 1250)
        data[0] = 0x00;
    dsi_ops->dphy_write(ctx, 0x19, data, 1);

    /* PLL input divider ratio [7:0] */
    data[0] = input_divider - 1;
  104898:	f10b 3bff 	add.w	r11, r11, #4294967295	; 0xffffffff
    dsi_ops->dphy_write(ctx, 0x1F, data, 1);
  10489c:	47b8      	blx	r7
    data[0] = (1 << 7) | ranges[range_index].hs_freq;
  10489e:	9b03      	ldr	r3, [sp, #12]
    dsi_ops->dphy_write(ctx, 0x44, data, 1);
  1048a0:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  1048a4:	aa05      	add	r2, sp, #20
  1048a6:	4628      	mov	r0, r5
    data[0] = (1 << 7) | ranges[range_index].hs_freq;
  1048a8:	4498      	add	r8, r3
  1048aa:	f898 1004 	ldrb.w	r1, [r8, #4]
    dsi_ops->dphy_write(ctx, 0x44, data, 1);
  1048ae:	464b      	mov	r3, r9
    data[0] = 0x0;
  1048b0:	f04f 0800 	mov.w	r8, #0
    data[0] = (1 << 7) | ranges[range_index].hs_freq;
  1048b4:	f061 017f 	orn	r1, r1, #127	; 0x7f
    data[0] = 0x10;
  1048b8:	f04f 0910 	mov.w	r9, #16
     * takes only 2 bytes (10 bits in data) */
    no_of_bytes = 2;
    /* 7 is dependent on no_of_bytes make sure 5 bits
     * only of value are written at a time */
    for (i = 0; i < no_of_bytes; i++)
        data[i] = (uint8_t)((((loop_divider - 2) >> (5 * i)) & 0x1F) | (i << 7));
  1048bc:	3c02      	subs	r4, #2
    data[0] = (1 << 7) | ranges[range_index].hs_freq;
  1048be:	f88d 1014 	strb.w	r1, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x44, data, 1);
  1048c2:	2144      	movs	r1, #68	; 0x44
  1048c4:	47b8      	blx	r7
    if (ranges[range_index].data_rate >= 1150)
  1048c6:	f240 437d 	movw	r3, #1149	; 0x47d
    dsi_ops->dphy_write(ctx, 0x0e, data, 1);
  1048ca:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
    if (ranges[range_index].data_rate >= 1150)
  1048ce:	459a      	cmp	r10, r3
        data[0] = 0x0E;
  1048d0:	bf8c      	ite	hi
  1048d2:	230e      	movhi	r3, #14
        data[0] = 0x0D;
  1048d4:	230d      	movls	r3, #13
    dsi_ops->dphy_write(ctx, 0x0e, data, 1);
  1048d6:	210e      	movs	r1, #14
  1048d8:	aa05      	add	r2, sp, #20
        data[0] = 0x0D;
  1048da:	f88d 3014 	strb.w	r3, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x0e, data, 1);
  1048de:	4628      	mov	r0, r5
  1048e0:	2301      	movs	r3, #1
  1048e2:	47b8      	blx	r7
    data[0] = 0x0;
  1048e4:	f88d 8014 	strb.w	r8, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x0f, data, 1);
  1048e8:	2301      	movs	r3, #1
  1048ea:	aa05      	add	r2, sp, #20
  1048ec:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  1048f0:	210f      	movs	r1, #15
  1048f2:	4628      	mov	r0, r5
  1048f4:	47b8      	blx	r7
    dsi_ops->dphy_write(ctx, 0x1c, data, 1);
  1048f6:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  1048fa:	2301      	movs	r3, #1
  1048fc:	aa05      	add	r2, sp, #20
  1048fe:	211c      	movs	r1, #28
  104900:	4628      	mov	r0, r5
    data[0] = 0x10;
  104902:	f88d 9014 	strb.w	r9, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x1c, data, 1);
  104906:	47b8      	blx	r7
    dsi_ops->dphy_write(ctx, 0x13, data, 1);
  104908:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  10490c:	2301      	movs	r3, #1
  10490e:	aa05      	add	r2, sp, #20
  104910:	2113      	movs	r1, #19
  104912:	4628      	mov	r0, r5
    data[0] = 0x10;
  104914:	f88d 9014 	strb.w	r9, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x13, data, 1);
  104918:	47b8      	blx	r7
    data[0] = (1 << 6) | (ranges[range_index].vco_range);
  10491a:	9b02      	ldr	r3, [sp, #8]
    dsi_ops->dphy_write(ctx, 0x12, data, 1);
  10491c:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  104920:	2112      	movs	r1, #18
  104922:	4628      	mov	r0, r5
    data[0] = (1 << 6) | (ranges[range_index].vco_range);
  104924:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    dsi_ops->dphy_write(ctx, 0x12, data, 1);
  104928:	2301      	movs	r3, #1
    data[0] = (1 << 6) | (ranges[range_index].vco_range);
  10492a:	f88d 2014 	strb.w	r2, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x12, data, 1);
  10492e:	aa05      	add	r2, sp, #20
  104930:	47b8      	blx	r7
    if (ranges[range_index].data_rate > 1250)
  104932:	f240 43e2 	movw	r3, #1250	; 0x4e2
    dsi_ops->dphy_write(ctx, 0x19, data, 1);
  104936:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
    if (ranges[range_index].data_rate > 1250)
  10493a:	459a      	cmp	r10, r3
    data[0] = (0x00 << 6) | (0x01 << 5) | (0x01 << 4);
  10493c:	bf98      	it	ls
  10493e:	2330      	movls	r3, #48	; 0x30
    dsi_ops->dphy_write(ctx, 0x19, data, 1);
  104940:	aa05      	add	r2, sp, #20
        data[0] = 0x00;
  104942:	bf88      	it	hi
  104944:	f88d 8014 	strbhi.w	r8, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x19, data, 1);
  104948:	f04f 0119 	mov.w	r1, #25
    data[0] = (0x00 << 6) | (0x01 << 5) | (0x01 << 4);
  10494c:	bf98      	it	ls
  10494e:	f88d 3014 	strbls.w	r3, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x19, data, 1);
  104952:	4628      	mov	r0, r5
  104954:	2301      	movs	r3, #1
    struct dsi_core_ops *dsi_ops = ctx->ops;
  104956:	f241 3889 	movw	r8, #5001	; 0x1389
    dsi_ops->dphy_write(ctx, 0x19, data, 1);
  10495a:	47b8      	blx	r7
    dsi_ops->dphy_write(ctx, 0x17, data, 1);
  10495c:	2301      	movs	r3, #1
  10495e:	2117      	movs	r1, #23
  104960:	aa05      	add	r2, sp, #20
  104962:	f8d6 7200 	ldr.w	r7, [r6, #512]	; 0x200
  104966:	4628      	mov	r0, r5
    data[0] = input_divider - 1;
  104968:	f88d b014 	strb.w	r11, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x17, data, 1);
  10496c:	47b8      	blx	r7
        data[i] = (uint8_t)((((loop_divider - 2) >> (5 * i)) & 0x1F) | (i << 7));
  10496e:	f3c4 1344 	ubfx	r3, r4, #5, #5
  104972:	f063 037f 	orn	r3, r3, #127	; 0x7f
  104976:	f004 041f 	and.w	r4, r4, #31
  10497a:	f88d 3015 	strb.w	r3, [r13, #21]

    /* PLL loop divider ratio -
     * SET no|reserved|feedback divider [7]|[6:5]|[4:0] */
    dsi_ops->dphy_write(ctx, 0x18, data, no_of_bytes);
  10497e:	aa05      	add	r2, sp, #20
        data[i] = (uint8_t)((((loop_divider - 2) >> (5 * i)) & 0x1F) | (i << 7));
  104980:	f88d 4014 	strb.w	r4, [r13, #20]
    dsi_ops->dphy_write(ctx, 0x18, data, no_of_bytes);
  104984:	2302      	movs	r3, #2
  104986:	f8d6 4200 	ldr.w	r4, [r6, #512]	; 0x200
  10498a:	2118      	movs	r1, #24
  10498c:	4628      	mov	r0, r5
  10498e:	47a0      	blx	r4

    data[0] = 0x18;
    dsi_ops->dphy_write(ctx, 0x1d, data, 1);*/
    #endif

    dsi_ops->dphy_n_lanes(ctx, num_of_lanes);
  104990:	9901      	ldr	r1, [sp, #4]
  104992:	f8d6 31ec 	ldr.w	r3, [r6, #492]	; 0x1ec
  104996:	4628      	mov	r0, r5
  104998:	4798      	blx	r3
    dsi_ops->dphy_stop_wait_time(ctx, 0x1C);
  10499a:	f8d6 31e8 	ldr.w	r3, [r6, #488]	; 0x1e8
  10499e:	211c      	movs	r1, #28
  1049a0:	4628      	mov	r0, r5
  1049a2:	4798      	blx	r3

    dsi_ops->dphy_enableclk(ctx, 1);
  1049a4:	f8d6 31d4 	ldr.w	r3, [r6, #468]	; 0x1d4
  1049a8:	2101      	movs	r1, #1
  1049aa:	4628      	mov	r0, r5
  1049ac:	4798      	blx	r3
    dsi_ops->dphy_shutdown(ctx, 1);
  1049ae:	f8d6 31dc 	ldr.w	r3, [r6, #476]	; 0x1dc
  1049b2:	2101      	movs	r1, #1
  1049b4:	4628      	mov	r0, r5
  1049b6:	4798      	blx	r3
    dsi_ops->dphy_reset(ctx, 1);
  1049b8:	f8d6 31d8 	ldr.w	r3, [r6, #472]	; 0x1d8
  1049bc:	2101      	movs	r1, #1
  1049be:	4628      	mov	r0, r5
  1049c0:	4798      	blx	r3
    struct dsi_core_ops *dsi_ops = ctx->ops;
  1049c2:	6fec      	ldr	r4, [r5, #124]	; 0x7c
  1049c4:	e005      	b.n	1049d2 <mipi_dsih_dphy_configure+0x2aa>
        udelay(1);
  1049c6:	2001      	movs	r0, #1
  1049c8:	f00e fed6 	bl	113778 <spin>
        if (count > 5000) {
  1049cc:	f1b8 0801 	subs.w	r8, r8, #1
  1049d0:	d012      	beq.n	1049f8 <mipi_dsih_dphy_configure+0x2d0>
    while (!dsi_ops->dphy_get_status(ctx, 0x5))  {
  1049d2:	f8d4 31f8 	ldr.w	r3, [r4, #504]	; 0x1f8
  1049d6:	2105      	movs	r1, #5
  1049d8:	4628      	mov	r0, r5
  1049da:	4798      	blx	r3
  1049dc:	2800      	cmp	r0, #0
  1049de:	d0f2      	beq.n	1049c6 <mipi_dsih_dphy_configure+0x29e>
    ret = wait_dphy_ready(ctx);
    if (ret < 0) {
        DISPERR("dphy not ready\n");
        return ret;
    }
    return 0;
  1049e0:	2000      	movs	r0, #0
}
  1049e2:	f50d 7d05 	add.w	r13, r13, #532	; 0x214
  1049e6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  1049ea:	fb03 f707 	mul.w	r7, r3, r7
  1049ee:	e6d3      	b.n	104798 <mipi_dsih_dphy_configure+0x70>
  1049f0:	f8d8 a000 	ldr.w	r10, [r8]
    for (i = 0; i < ARRAYSIZE(ranges); i++) {
  1049f4:	2200      	movs	r2, #0
  1049f6:	e6c1      	b.n	10477c <mipi_dsih_dphy_configure+0x54>
        return -1;
  1049f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1049fc:	f50d 7d05 	add.w	r13, r13, #532	; 0x214
  104a00:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

00104a04 <mipi_dsih_open>:

int mipi_dsih_open(struct dsi_context *ctx)
{
  104a04:	b538      	push	{r3, r4, r5, r14}
    //int ret;
    struct dsi_core_ops *dsi_ops = ctx->ops;
  104a06:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
  104a08:	4604      	mov	r4, r0

    mipi_dsih_dphy_open(ctx);

    if (!dsi_ops->check_version(ctx)) {
  104a0a:	682b      	ldr	r3, [r5, #0]
  104a0c:	4798      	blx	r3
  104a0e:	2800      	cmp	r0, #0
  104a10:	d054      	beq.n	104abc <mipi_dsih_open+0xb8>
        DISPERR("dsi version error!\n");
        return -1;
    }

    dsi_ops->power_enable(ctx, 0);
  104a12:	686b      	ldr	r3, [r5, #4]
  104a14:	4620      	mov	r0, r4
  104a16:	2100      	movs	r1, #0
  104a18:	4798      	blx	r3
    ctx->max_lanes = 4;
    ctx->max_bta_cycles = 4095;
  104a1a:	f640 72ff 	movw	r2, #4095	; 0xfff
    ctx->max_lanes = 4;
  104a1e:	2304      	movs	r3, #4

    dsi_ops->dpi_color_mode_pol(ctx, 0);
  104a20:	4620      	mov	r0, r4
  104a22:	2100      	movs	r1, #0
    ctx->max_lanes = 4;
  104a24:	74a3      	strb	r3, [r4, #18]
    dsi_ops->dpi_color_mode_pol(ctx, 0);
  104a26:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    ctx->max_bta_cycles = 4095;
  104a28:	82a2      	strh	r2, [r4, #20]
    dsi_ops->dpi_color_mode_pol(ctx, 0);
  104a2a:	4798      	blx	r3
    dsi_ops->dpi_shut_down_pol(ctx, 0);
  104a2c:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  104a2e:	4620      	mov	r0, r4
  104a30:	2100      	movs	r1, #0
  104a32:	4798      	blx	r3

    dsi_ops->int0_mask(ctx, 0x0);
  104a34:	f8d5 312c 	ldr.w	r3, [r5, #300]	; 0x12c
  104a38:	4620      	mov	r0, r4
  104a3a:	2100      	movs	r1, #0
  104a3c:	4798      	blx	r3
    dsi_ops->int1_mask(ctx, 0x0);
  104a3e:	f8d5 3134 	ldr.w	r3, [r5, #308]	; 0x134
  104a42:	4620      	mov	r0, r4
  104a44:	2100      	movs	r1, #0
  104a46:	4798      	blx	r3
    dsi_ops->max_read_time(ctx, ctx->max_bta_cycles);
  104a48:	f8d5 3144 	ldr.w	r3, [r5, #324]	; 0x144
  104a4c:	8aa1      	ldrh	r1, [r4, #20]
  104a4e:	4620      	mov	r0, r4
  104a50:	4798      	blx	r3

    /*
     * By default, return to LP during ALL
     * unless otherwise specified
     */
    dsi_ops->dpi_hporch_lp_en(ctx, 1);
  104a52:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  104a56:	4620      	mov	r0, r4
  104a58:	2101      	movs	r1, #1
  104a5a:	4798      	blx	r3
    dsi_ops->dpi_vporch_lp_en(ctx, 1);
  104a5c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
  104a60:	4620      	mov	r0, r4
  104a62:	2101      	movs	r1, #1
  104a64:	4798      	blx	r3
    /* by default, all commands are sent in LP */
    dsi_ops->cmd_mode_lp_cmd_en(ctx, 1);
  104a66:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
  104a6a:	4620      	mov	r0, r4
  104a6c:	2101      	movs	r1, #1
  104a6e:	4798      	blx	r3
    /* by default, RX_VC = 0, NO EOTp, EOTn, BTA, ECC rx and CRC rx */
    dsi_ops->rx_vcid(ctx, 0);
  104a70:	6deb      	ldr	r3, [r5, #92]	; 0x5c
  104a72:	4620      	mov	r0, r4
  104a74:	2100      	movs	r1, #0
  104a76:	4798      	blx	r3
    dsi_ops->eotp_rx_en(ctx, 0);
  104a78:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  104a7a:	4620      	mov	r0, r4
  104a7c:	2100      	movs	r1, #0
  104a7e:	4798      	blx	r3
    dsi_ops->eotp_tx_en(ctx, 0);
  104a80:	6cab      	ldr	r3, [r5, #72]	; 0x48
  104a82:	4620      	mov	r0, r4
  104a84:	2100      	movs	r1, #0
  104a86:	4798      	blx	r3
    dsi_ops->bta_en(ctx, 0);
  104a88:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  104a8a:	4620      	mov	r0, r4
  104a8c:	2100      	movs	r1, #0
  104a8e:	4798      	blx	r3
    dsi_ops->ecc_rx_en(ctx, 0);
  104a90:	6d2b      	ldr	r3, [r5, #80]	; 0x50
  104a92:	4620      	mov	r0, r4
  104a94:	2100      	movs	r1, #0
  104a96:	4798      	blx	r3
    dsi_ops->crc_rx_en(ctx, 0);
  104a98:	6d6b      	ldr	r3, [r5, #84]	; 0x54
  104a9a:	4620      	mov	r0, r4
  104a9c:	2100      	movs	r1, #0
  104a9e:	4798      	blx	r3

    dsi_ops->video_mode_lp_cmd_en(ctx, 1);
  104aa0:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  104aa2:	4620      	mov	r0, r4
  104aa4:	2101      	movs	r1, #1
  104aa6:	4798      	blx	r3
    dsi_ops->power_enable(ctx, 1);
  104aa8:	686b      	ldr	r3, [r5, #4]
  104aaa:	4620      	mov	r0, r4
  104aac:	2101      	movs	r1, #1
  104aae:	4798      	blx	r3
    /* dividing by 6 is aimed for max PHY frequency, 1GHz */
    dsi_ops->tx_escape_division(ctx, 6); /*need change to calc -- billy*/
  104ab0:	4620      	mov	r0, r4
  104ab2:	692b      	ldr	r3, [r5, #16]
  104ab4:	2106      	movs	r1, #6
  104ab6:	4798      	blx	r3

    //wait_dphy_lock(1);
    wait_dphy_ready(ctx);
#endif

    return 0;
  104ab8:	2000      	movs	r0, #0
}
  104aba:	bd38      	pop	{r3, r4, r5, r15}
        return -1;
  104abc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104ac0:	bd38      	pop	{r3, r4, r5, r15}
  104ac2:	bf00      	nop

00104ac4 <mipi_dsih_dpi_video>:

int mipi_dsih_dpi_video(struct dsi_context *ctx)
{
  104ac4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint16_t bytes_per_pixel_x100 = 0; /* bpp x 100 because it can be 2.25 */
    uint32_t hsync_time = 0;
    struct dsi_core_ops *dsi_ops = ctx->ops;
    struct dsih_dpi_video_t *dpi_video = &ctx->dpi_video;

    dsi_ops->dphy_datalane_hs2lp_config(ctx, dpi_video->data_hs2lp);
  104ac8:	8b81      	ldrh	r1, [r0, #28]
    struct dsi_core_ops *dsi_ops = ctx->ops;
  104aca:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
  104acc:	4604      	mov	r4, r0
  104ace:	b083      	sub	sp, #12
    dsi_ops->dphy_datalane_hs2lp_config(ctx, dpi_video->data_hs2lp);
  104ad0:	f8d5 31cc 	ldr.w	r3, [r5, #460]	; 0x1cc
  104ad4:	4798      	blx	r3
    dsi_ops->dphy_datalane_lp2hs_config(ctx, dpi_video->data_lp2hs);
  104ad6:	f8d5 31d0 	ldr.w	r3, [r5, #464]	; 0x1d0
  104ada:	8be1      	ldrh	r1, [r4, #30]
  104adc:	4620      	mov	r0, r4
  104ade:	4798      	blx	r3
    dsi_ops->dphy_clklane_hs2lp_config(ctx, dpi_video->clk_hs2lp);
  104ae0:	f8d5 31c4 	ldr.w	r3, [r5, #452]	; 0x1c4
  104ae4:	8c21      	ldrh	r1, [r4, #32]
  104ae6:	4620      	mov	r0, r4
  104ae8:	4798      	blx	r3
    dsi_ops->dphy_clklane_lp2hs_config(ctx, dpi_video->clk_lp2hs);
  104aea:	f8d5 31c8 	ldr.w	r3, [r5, #456]	; 0x1c8
  104aee:	8c61      	ldrh	r1, [r4, #34]	; 0x22
  104af0:	4620      	mov	r0, r4
  104af2:	4798      	blx	r3
    dsi_ops->nc_clk_en(ctx, dpi_video->nc_clk_en);
  104af4:	f8d5 311c 	ldr.w	r3, [r5, #284]	; 0x11c
  104af8:	6a61      	ldr	r1, [r4, #36]	; 0x24
  104afa:	4620      	mov	r0, r4
  104afc:	4798      	blx	r3

    mipi_dsih_dphy_configure(ctx, dpi_video->n_lanes, dpi_video->phy_freq);
  104afe:	6b62      	ldr	r2, [r4, #52]	; 0x34
  104b00:	7e61      	ldrb	r1, [r4, #25]
  104b02:	4620      	mov	r0, r4
  104b04:	f7ff fe10 	bl	104728 <mipi_dsih_dphy_configure>

	ratio_clock_xPF =
  104b08:	e9d4 370b 	ldrd	r3, r7, [r4, #44]	; 0x2c
		(dpi_video->byte_clock * PRECISION_FACTOR) / (dpi_video->pixel_clock);
    video_size = dpi_video->h_active_pixels;

    dsi_ops->video_mode_frame_ack_en(ctx, dpi_video->frame_ack_en);
  104b0c:	6f2a      	ldr	r2, [r5, #112]	; 0x70
  104b0e:	4620      	mov	r0, r4
  104b10:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		(dpi_video->byte_clock * PRECISION_FACTOR) / (dpi_video->pixel_clock);
  104b12:	ebc3 1943 	rsb	r9, r3, r3, lsl #5
    video_size = dpi_video->h_active_pixels;
  104b16:	f8b4 6048 	ldrh.w	r6, [r4, #72]	; 0x48
		(dpi_video->byte_clock * PRECISION_FACTOR) / (dpi_video->pixel_clock);
  104b1a:	eb03 0989 	add.w	r9, r3, r9, lsl #2
    dsi_ops->video_mode_frame_ack_en(ctx, dpi_video->frame_ack_en);
  104b1e:	4790      	blx	r2
    if (dpi_video->frame_ack_en) {
  104b20:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		(dpi_video->byte_clock * PRECISION_FACTOR) / (dpi_video->pixel_clock);
  104b22:	ea4f 09c9 	mov.w	r9, r9, lsl #3
	ratio_clock_xPF =
  104b26:	fbb9 f9f7 	udiv	r9, r9, r7
    if (dpi_video->frame_ack_en) {
  104b2a:	b11b      	cbz	r3, 104b34 <mipi_dsih_dpi_video+0x70>
        /*
         * if ACK is requested, enable BTA
         * otherwise leave as is
         */
        dsi_ops->bta_en(ctx, 1);
  104b2c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  104b2e:	2101      	movs	r1, #1
  104b30:	4620      	mov	r0, r4
  104b32:	4798      	blx	r3
    }
    dsi_ops->video_mode(ctx);
  104b34:	6e2b      	ldr	r3, [r5, #96]	; 0x60
  104b36:	4620      	mov	r0, r4
  104b38:	4798      	blx	r3

    /*
     * get bytes per pixel and video size
     * step (depending if loosely or not
     */
    switch (dpi_video->color_coding) {
  104b3a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  104b3c:	290c      	cmp	r1, #12
  104b3e:	f200 81e9 	bhi.w	104f14 <mipi_dsih_dpi_video+0x450>
  104b42:	e8df f011 	tbh	[r15, r1, lsl #1]
  104b46:	00d1      	.short	0x00d1
  104b48:	00d100d1 	.word	0x00d100d1
  104b4c:	01110111 	.word	0x01110111
  104b50:	00d7000d 	.word	0x00d7000d
  104b54:	00ee00e2 	.word	0x00ee00e2
  104b58:	010000f9 	.word	0x010000f9
  104b5c:	000d0107 	.word	0x000d0107
        }
        break;
    case COLOR_CODE_DSC24:
        bytes_per_pixel_x100 = 300;
        video_size_step = 1;
        break;
  104b60:	f04f 0a06 	mov.w	r10, #6
  104b64:	f44f 7796 	mov.w	r7, #300	; 0x12c
        video_size_step = 1;
  104b68:	f04f 0801 	mov.w	r8, #1
    default:
        DISPERR("invalid color coding\n");
        return -1;
    }

    dsi_ops->dpi_color_coding(ctx, dpi_video->color_coding);
  104b6c:	69eb      	ldr	r3, [r5, #28]
  104b6e:	4620      	mov	r0, r4
  104b70:	4798      	blx	r3
    dsi_ops->eotp_rx_en(ctx, dpi_video->eotp_rx_en);
  104b72:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  104b74:	6e21      	ldr	r1, [r4, #96]	; 0x60
  104b76:	4620      	mov	r0, r4
  104b78:	4798      	blx	r3
    dsi_ops->eotp_tx_en(ctx, dpi_video->eotp_tx_en);
  104b7a:	6cab      	ldr	r3, [r5, #72]	; 0x48
  104b7c:	6e61      	ldr	r1, [r4, #100]	; 0x64
  104b7e:	4620      	mov	r0, r4
  104b80:	4798      	blx	r3
    dsi_ops->video_mode_lp_cmd_en(ctx, dpi_video->dpi_lp_cmd_en);
  104b82:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  104b84:	6f21      	ldr	r1, [r4, #112]	; 0x70
  104b86:	4620      	mov	r0, r4
  104b88:	4798      	blx	r3
    dsi_ops->video_mode_mode_type(ctx, dpi_video->burst_mode);
  104b8a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
  104b8e:	7ea1      	ldrb	r1, [r4, #26]
  104b90:	4620      	mov	r0, r4
  104b92:	4798      	blx	r3

    hsync_time = dpi_video->h_sync_pixels * ratio_clock_xPF / PRECISION_FACTOR;
  104b94:	f8b4 104a 	ldrh.w	r1, [r4, #74]	; 0x4a
  104b98:	fb09 f101 	mul.w	r1, r9, r1
    if (dpi_video->burst_mode != VIDEO_BURST_WITH_SYNC_PULSES)
  104b9c:	7ea3      	ldrb	r3, [r4, #26]
    hsync_time = dpi_video->h_sync_pixels * ratio_clock_xPF / PRECISION_FACTOR;
  104b9e:	f644 50d3 	movw	r0, #19923	; 0x4dd3
    if (dpi_video->burst_mode != VIDEO_BURST_WITH_SYNC_PULSES)
  104ba2:	2b02      	cmp	r3, #2
    hsync_time = dpi_video->h_sync_pixels * ratio_clock_xPF / PRECISION_FACTOR;
  104ba4:	f2c1 0062 	movt	r0, #4194	; 0x1062
  104ba8:	fba0 2101 	umull	r2, r1, r0, r1
  104bac:	ea4f 1191 	mov.w	r1, r1, lsr #6
    if (dpi_video->burst_mode != VIDEO_BURST_WITH_SYNC_PULSES)
  104bb0:	d00f      	beq.n	104bd2 <mipi_dsih_dpi_video+0x10e>
        hsync_time += (ratio_clock_xPF -  3 * PRECISION_FACTOR / dpi_video->n_lanes) * dpi_video->h_active_pixels / PRECISION_FACTOR;
  104bb2:	f640 32b8 	movw	r2, #3000	; 0xbb8
  104bb6:	f894 c019 	ldrb.w	r12, [r4, #25]
  104bba:	f8b4 3048 	ldrh.w	r3, [r4, #72]	; 0x48
  104bbe:	fb92 f2fc 	sdiv	r2, r2, r12
  104bc2:	eba9 0202 	sub.w	r2, r9, r2
  104bc6:	fb03 f302 	mul.w	r3, r3, r2
  104bca:	fba0 2303 	umull	r2, r3, r0, r3
  104bce:	eb01 1193 	add.w	r1, r1, r3, lsr #6
    dsi_ops->dpi_hsync_time(ctx, hsync_time); //hsync
  104bd2:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
  104bd6:	b289      	uxth	r1, r1
  104bd8:	4620      	mov	r0, r4
    dsi_ops->dpi_hbp_time(ctx, dpi_video->h_back_porch_pixels * ratio_clock_xPF / PRECISION_FACTOR);//hbp
  104bda:	f644 5bd3 	movw	r11, #19923	; 0x4dd3
    dsi_ops->dpi_hsync_time(ctx, hsync_time); //hsync
  104bde:	4798      	blx	r3
    dsi_ops->dpi_hbp_time(ctx, dpi_video->h_back_porch_pixels * ratio_clock_xPF / PRECISION_FACTOR);//hbp
  104be0:	f8b4 104c 	ldrh.w	r1, [r4, #76]	; 0x4c
  104be4:	fb09 f101 	mul.w	r1, r9, r1
  104be8:	4620      	mov	r0, r4
  104bea:	f2c1 0b62 	movt	r11, #4194	; 0x1062
  104bee:	f8d5 30b4 	ldr.w	r3, [r5, #180]	; 0xb4
  104bf2:	fbab 2101 	umull	r2, r1, r11, r1
  104bf6:	f3c1 118f 	ubfx	r1, r1, #6, #16
  104bfa:	4798      	blx	r3
    dsi_ops->dpi_hline_time(ctx, dpi_video->h_total_pixels * ratio_clock_xPF / PRECISION_FACTOR); //hsync+hbp_hact+hfp
  104bfc:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
  104c00:	fb09 f101 	mul.w	r1, r9, r1
  104c04:	f8d5 30b0 	ldr.w	r3, [r5, #176]	; 0xb0
  104c08:	4620      	mov	r0, r4
  104c0a:	fbab 2101 	umull	r2, r1, r11, r1
  104c0e:	f3c1 118f 	ubfx	r1, r1, #6, #16
  104c12:	4798      	blx	r3

    dsi_ops->dpi_vsync(ctx, dpi_video->v_sync_lines);//vsync
  104c14:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
  104c18:	f8b4 1056 	ldrh.w	r1, [r4, #86]	; 0x56
  104c1c:	4620      	mov	r0, r4
  104c1e:	4798      	blx	r3
    dsi_ops->dpi_vbp(ctx, dpi_video->v_back_porch_lines);//vbp
  104c20:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
  104c24:	f8b4 1058 	ldrh.w	r1, [r4, #88]	; 0x58
  104c28:	4620      	mov	r0, r4
  104c2a:	4798      	blx	r3
    dsi_ops->dpi_vfp(ctx, dpi_video->v_front_porch_lines);//vfp
  104c2c:	f8d5 30c4 	ldr.w	r3, [r5, #196]	; 0xc4
  104c30:	f8b4 105a 	ldrh.w	r1, [r4, #90]	; 0x5a
  104c34:	4620      	mov	r0, r4
  104c36:	4798      	blx	r3
    dsi_ops->dpi_vact(ctx, dpi_video->v_active_lines);//vact
  104c38:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
  104c3c:	f8b4 1054 	ldrh.w	r1, [r4, #84]	; 0x54
  104c40:	4620      	mov	r0, r4
  104c42:	4798      	blx	r3

    dsi_ops->dpi_hsync_pol(ctx, dpi_video->h_polarity);
  104c44:	6bab      	ldr	r3, [r5, #56]	; 0x38
  104c46:	6c61      	ldr	r1, [r4, #68]	; 0x44
  104c48:	4620      	mov	r0, r4
  104c4a:	4798      	blx	r3
    dsi_ops->dpi_vsync_pol(ctx, dpi_video->v_polarity);
  104c4c:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  104c4e:	6d21      	ldr	r1, [r4, #80]	; 0x50
  104c50:	4620      	mov	r0, r4
  104c52:	4798      	blx	r3
    dsi_ops->dpi_data_en_pol(ctx, dpi_video->data_en_polarity);
  104c54:	6c2b      	ldr	r3, [r5, #64]	; 0x40
  104c56:	6c21      	ldr	r1, [r4, #64]	; 0x40
  104c58:	4620      	mov	r0, r4
  104c5a:	4798      	blx	r3

    hs_timeout = (dpi_video->h_total_pixels * dpi_video->v_active_lines) +
  104c5c:	f8b4 204e 	ldrh.w	r2, [r4, #78]	; 0x4e
  104c60:	f8b4 3054 	ldrh.w	r3, [r4, #84]	; 0x54
  104c64:	fb03 a202 	mla	r2, r3, r2, r10
        (DSIH_PIXEL_TOLERANCE * bytes_per_pixel_x100) / 100;
    for (counter = 0x80; (counter < hs_timeout) && (counter > 2); counter--) {
  104c68:	2a80      	cmp	r2, #128	; 0x80
  104c6a:	dd0e      	ble.n	104c8a <mipi_dsih_dpi_video+0x1c6>
        if (hs_timeout % counter == 0) {
  104c6c:	0653      	lsls	r3, r2, #25
  104c6e:	f000 80d5 	beq.w	104e1c <mipi_dsih_dpi_video+0x358>
    for (counter = 0x80; (counter < hs_timeout) && (counter > 2); counter--) {
  104c72:	2380      	movs	r3, #128	; 0x80
  104c74:	e006      	b.n	104c84 <mipi_dsih_dpi_video+0x1c0>
        if (hs_timeout % counter == 0) {
  104c76:	fbb2 f0f3 	udiv	r0, r2, r3
  104c7a:	fb03 2110 	mls	r1, r3, r0, r2
  104c7e:	2900      	cmp	r1, #0
  104c80:	f000 8086 	beq.w	104d90 <mipi_dsih_dpi_video+0x2cc>
    for (counter = 0x80; (counter < hs_timeout) && (counter > 2); counter--) {
  104c84:	3b01      	subs	r3, #1
  104c86:	2b02      	cmp	r3, #2
  104c88:	d8f5      	bhi.n	104c76 <mipi_dsih_dpi_video+0x1b2>
            dsi_ops->lp_rx_timeout(ctx, (uint16_t)(hs_timeout / counter));
            dsi_ops->hs_tx_timeout(ctx, (uint16_t)(hs_timeout / counter));
            break;
        }
    }
    dsi_ops->tx_escape_division(ctx, 6);
  104c8a:	692b      	ldr	r3, [r5, #16]
  104c8c:	2106      	movs	r1, #6
  104c8e:	4620      	mov	r0, r4
  104c90:	4798      	blx	r3

    /*video packetisation*/
    if (dpi_video->burst_mode == VIDEO_BURST_WITH_SYNC_PULSES) {
  104c92:	7ea3      	ldrb	r3, [r4, #26]
  104c94:	2b02      	cmp	r3, #2
  104c96:	f040 808d 	bne.w	104db4 <mipi_dsih_dpi_video+0x2f0>
        /*BURST*/
        DISPMSG("INFO: burst video\n");
        dsi_ops->dpi_null_packet_size(ctx, 0);
  104c9a:	2100      	movs	r1, #0
  104c9c:	4620      	mov	r0, r4
  104c9e:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
    int error = 0;
  104ca2:	460f      	mov	r7, r1
        dsi_ops->dpi_null_packet_size(ctx, 0);
  104ca4:	4798      	blx	r3
        dsi_ops->dpi_chunk_num(ctx, 1);
  104ca6:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
  104caa:	2101      	movs	r1, #1
  104cac:	4620      	mov	r0, r4
  104cae:	4798      	blx	r3
        dsi_ops->dpi_video_packet_size(ctx, video_size);
  104cb0:	4631      	mov	r1, r6
  104cb2:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
  104cb6:	4620      	mov	r0, r4
  104cb8:	4798      	blx	r3

        /*
         * BURST by default returns to LP during
         * ALL empty periods - energy saving
         */
        dsi_ops->dpi_hporch_lp_en(ctx, 1);
  104cba:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  104cbe:	2101      	movs	r1, #1
  104cc0:	4620      	mov	r0, r4
  104cc2:	4798      	blx	r3
        dsi_ops->dpi_vporch_lp_en(ctx, 1);
  104cc4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
  104cc8:	2101      	movs	r1, #1
  104cca:	4620      	mov	r0, r4
  104ccc:	4798      	blx	r3
            DISPERR("resolution cannot be sent to display through current settings\n");
            error = -1;
        }
    }

    dsi_ops->video_vcid(ctx, dpi_video->virtual_channel);
  104cce:	696b      	ldr	r3, [r5, #20]
  104cd0:	7e21      	ldrb	r1, [r4, #24]
  104cd2:	4620      	mov	r0, r4
  104cd4:	4798      	blx	r3
    dsi_ops->dphy_n_lanes(ctx, dpi_video->n_lanes);
  104cd6:	f8d5 31ec 	ldr.w	r3, [r5, #492]	; 0x1ec
  104cda:	7e61      	ldrb	r1, [r4, #25]
  104cdc:	4620      	mov	r0, r4
  104cde:	4798      	blx	r3

    /*enable high speed clock*/
    //dsi_ops->dphy_enable_hs_clk(ctx, 1);//panel not init yet, could not set to hs

    return error;
}
  104ce0:	4638      	mov	r0, r7
  104ce2:	b003      	add	sp, #12
  104ce4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    switch (dpi_video->color_coding) {
  104ce8:	f04f 0a04 	mov.w	r10, #4
  104cec:	27c8      	movs	r7, #200	; 0xc8
    uint8_t video_size_step = 0;
  104cee:	f04f 0800 	mov.w	r8, #0
  104cf2:	e73b      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        if ((video_size % 2) != 0) {
  104cf4:	07f3      	lsls	r3, r6, #31
  104cf6:	f140 80ad 	bpl.w	104e54 <mipi_dsih_dpi_video+0x390>
            video_size += 1;
  104cfa:	f04f 0a05 	mov.w	r10, #5
  104cfe:	3601      	adds	r6, #1
  104d00:	27fa      	movs	r7, #250	; 0xfa
        video_size_step = 2;
  104d02:	f04f 0802 	mov.w	r8, #2
            video_size += 1;
  104d06:	b2b6      	uxth	r6, r6
  104d08:	e730      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        if ((video_size % 2) != 0) {
  104d0a:	07f7      	lsls	r7, r6, #31
  104d0c:	f140 809b 	bpl.w	104e46 <mipi_dsih_dpi_video+0x382>
            video_size += 1;
  104d10:	f04f 0a06 	mov.w	r10, #6
  104d14:	3601      	adds	r6, #1
  104d16:	f44f 7796 	mov.w	r7, #300	; 0x12c
        video_size_step = 2;
  104d1a:	f04f 0802 	mov.w	r8, #2
            video_size += 1;
  104d1e:	b2b6      	uxth	r6, r6
  104d20:	e724      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        if ((video_size % 2) != 0) {
  104d22:	07f0      	lsls	r0, r6, #31
  104d24:	f140 8089 	bpl.w	104e3a <mipi_dsih_dpi_video+0x376>
            video_size += 1;
  104d28:	f04f 0a04 	mov.w	r10, #4
  104d2c:	3601      	adds	r6, #1
  104d2e:	27c8      	movs	r7, #200	; 0xc8
        video_size_step = 2;
  104d30:	f04f 0802 	mov.w	r8, #2
            video_size += 1;
  104d34:	b2b6      	uxth	r6, r6
  104d36:	e719      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
    switch (dpi_video->color_coding) {
  104d38:	f04f 0a07 	mov.w	r10, #7
  104d3c:	f240 1777 	movw	r7, #375	; 0x177
        video_size_step = 2;
  104d40:	f04f 0802 	mov.w	r8, #2
  104d44:	e712      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        break;
  104d46:	f04f 0a09 	mov.w	r10, #9
  104d4a:	f44f 77e1 	mov.w	r7, #450	; 0x1c2
        video_size_step = 2;
  104d4e:	f04f 0802 	mov.w	r8, #2
        break;
  104d52:	e70b      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        if ((video_size % 2) != 0) {
  104d54:	07f2      	lsls	r2, r6, #31
  104d56:	d56a      	bpl.n	104e2e <mipi_dsih_dpi_video+0x36a>
            video_size += 1;
  104d58:	f04f 0a03 	mov.w	r10, #3
  104d5c:	3601      	adds	r6, #1
  104d5e:	2796      	movs	r7, #150	; 0x96
        video_size_step = 2;
  104d60:	f04f 0802 	mov.w	r8, #2
            video_size += 1;
  104d64:	b2b6      	uxth	r6, r6
  104d66:	e701      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
        dsi_ops->dpi_18_loosely_packet_en(ctx, dpi_video->is_18_loosely);
  104d68:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  104d6a:	4620      	mov	r0, r4
  104d6c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  104d6e:	4798      	blx	r3
  104d70:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
        if (!dpi_video->is_18_loosely) {
  104d74:	2b00      	cmp	r3, #0
  104d76:	d154      	bne.n	104e22 <mipi_dsih_dpi_video+0x35e>
            for (; (video_size % 4) != 0; video_size++) {
  104d78:	f016 0803 	ands.w	r8, r6, #3
  104d7c:	d004      	beq.n	104d88 <mipi_dsih_dpi_video+0x2c4>
  104d7e:	3601      	adds	r6, #1
  104d80:	b2b6      	uxth	r6, r6
  104d82:	f016 0803 	ands.w	r8, r6, #3
  104d86:	d1fa      	bne.n	104d7e <mipi_dsih_dpi_video+0x2ba>
  104d88:	f04f 0a04 	mov.w	r10, #4
  104d8c:	27e1      	movs	r7, #225	; 0xe1
  104d8e:	e6ed      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
  104d90:	3301      	adds	r3, #1
  104d92:	b2d9      	uxtb	r1, r3
            dsi_ops->timeout_clock_division(ctx, counter + 1);
  104d94:	68eb      	ldr	r3, [r5, #12]
            dsi_ops->lp_rx_timeout(ctx, (uint16_t)(hs_timeout / counter));
  104d96:	fa1f f980 	uxth.w	r9, r0
            dsi_ops->timeout_clock_division(ctx, counter + 1);
  104d9a:	4620      	mov	r0, r4
  104d9c:	4798      	blx	r3
            dsi_ops->lp_rx_timeout(ctx, (uint16_t)(hs_timeout / counter));
  104d9e:	4649      	mov	r1, r9
  104da0:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
  104da4:	4620      	mov	r0, r4
  104da6:	4798      	blx	r3
            dsi_ops->hs_tx_timeout(ctx, (uint16_t)(hs_timeout / counter));
  104da8:	4649      	mov	r1, r9
  104daa:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
  104dae:	4620      	mov	r0, r4
  104db0:	4798      	blx	r3
            break;
  104db2:	e76a      	b.n	104c8a <mipi_dsih_dpi_video+0x1c6>
        total_bytes = bytes_per_pixel_x100 * dpi_video->n_lanes *
  104db4:	7e61      	ldrb	r1, [r4, #25]
  104db6:	fb07 f201 	mul.w	r2, r7, r1
        bytes_per_chunk = bytes_per_pixel_x100 * dpi_video->h_active_pixels / 100
  104dba:	f8b4 c048 	ldrh.w	r12, [r4, #72]	; 0x48
            dpi_video->h_total_pixels / 100;
  104dbe:	f8b4 104e 	ldrh.w	r1, [r4, #78]	; 0x4e
        bytes_per_chunk = bytes_per_pixel_x100 * dpi_video->h_active_pixels / 100
  104dc2:	fb07 f30c 	mul.w	r3, r7, r12
        total_bytes = bytes_per_pixel_x100 * dpi_video->n_lanes *
  104dc6:	fb01 f102 	mul.w	r1, r1, r2
        bytes_per_chunk = bytes_per_pixel_x100 * dpi_video->h_active_pixels / 100
  104dca:	f248 521f 	movw	r2, #34079	; 0x851f
  104dce:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
  104dd2:	fba2 0303 	umull	r0, r3, r2, r3
            dpi_video->h_total_pixels / 100;
  104dd6:	fba2 0101 	umull	r0, r1, r2, r1
        bytes_per_chunk = bytes_per_pixel_x100 * dpi_video->h_active_pixels / 100
  104dda:	095b      	lsrs	r3, r3, #5
            + VIDEO_PACKET_OVERHEAD + NULL_PACKET_OVERHEAD;
  104ddc:	330c      	adds	r3, #12
            dpi_video->h_total_pixels / 100;
  104dde:	0949      	lsrs	r1, r1, #5
        if (total_bytes >= bytes_per_chunk) {
  104de0:	428b      	cmp	r3, r1
            error = -1;
  104de2:	bf88      	it	hi
  104de4:	f04f 37ff 	movhi.w	r7, #4294967295	; 0xffffffff
        if (total_bytes >= bytes_per_chunk) {
  104de8:	f63f af71 	bhi.w	104cce <mipi_dsih_dpi_video+0x20a>
            chunk_overhead = total_bytes - bytes_per_chunk -
  104dec:	f1a1 000c 	sub.w	r0, r1, #12
  104df0:	1ac3      	subs	r3, r0, r3
            if (!(chunk_overhead > 1)) {
  104df2:	2b01      	cmp	r3, #1
        null_packet_size = 0;
  104df4:	bf84      	itt	hi
  104df6:	2100      	movhi	r1, #0
    uint16_t no_of_chunks = 0;
  104df8:	4689      	movhi	r9, r1
            if (!(chunk_overhead > 1)) {
  104dfa:	d931      	bls.n	104e60 <mipi_dsih_dpi_video+0x39c>
            dsi_ops->dpi_null_packet_size(ctx, null_packet_size);
  104dfc:	4620      	mov	r0, r4
    int error = 0;
  104dfe:	2700      	movs	r7, #0
            dsi_ops->dpi_null_packet_size(ctx, null_packet_size);
  104e00:	f8d5 30ac 	ldr.w	r3, [r5, #172]	; 0xac
  104e04:	4798      	blx	r3
            dsi_ops->dpi_chunk_num(ctx, no_of_chunks);
  104e06:	4649      	mov	r1, r9
  104e08:	f8d5 30a8 	ldr.w	r3, [r5, #168]	; 0xa8
  104e0c:	4620      	mov	r0, r4
  104e0e:	4798      	blx	r3
            dsi_ops->dpi_video_packet_size(ctx, video_size);
  104e10:	4631      	mov	r1, r6
  104e12:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
  104e16:	4620      	mov	r0, r4
  104e18:	4798      	blx	r3
  104e1a:	e758      	b.n	104cce <mipi_dsih_dpi_video+0x20a>
        if (hs_timeout % counter == 0) {
  104e1c:	2181      	movs	r1, #129	; 0x81
  104e1e:	09d0      	lsrs	r0, r2, #7
  104e20:	e7b8      	b.n	104d94 <mipi_dsih_dpi_video+0x2d0>
        if (!dpi_video->is_18_loosely) {
  104e22:	f04f 0a04 	mov.w	r10, #4
  104e26:	27e1      	movs	r7, #225	; 0xe1
            video_size_step = 1;
  104e28:	f04f 0801 	mov.w	r8, #1
  104e2c:	e69e      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
  104e2e:	f04f 0a03 	mov.w	r10, #3
  104e32:	2796      	movs	r7, #150	; 0x96
        video_size_step = 2;
  104e34:	f04f 0802 	mov.w	r8, #2
  104e38:	e698      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
  104e3a:	f04f 0a04 	mov.w	r10, #4
  104e3e:	27c8      	movs	r7, #200	; 0xc8
        video_size_step = 2;
  104e40:	f04f 0802 	mov.w	r8, #2
  104e44:	e692      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
  104e46:	f04f 0a06 	mov.w	r10, #6
  104e4a:	f44f 7796 	mov.w	r7, #300	; 0x12c
        video_size_step = 2;
  104e4e:	f04f 0802 	mov.w	r8, #2
  104e52:	e68b      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
  104e54:	f04f 0a05 	mov.w	r10, #5
  104e58:	27fa      	movs	r7, #250	; 0xfa
        video_size_step = 2;
  104e5a:	f04f 0802 	mov.w	r8, #2
  104e5e:	e685      	b.n	104b6c <mipi_dsih_dpi_video+0xa8>
                for (video_size = video_size_step;
  104e60:	fa1f fa88 	uxth.w	r10, r8
  104e64:	45d4      	cmp	r12, r10
  104e66:	d92e      	bls.n	104ec6 <mipi_dsih_dpi_video+0x402>
                        video_size) % PRECISION_FACTOR;
  104e68:	f644 5bd3 	movw	r11, #19923	; 0x4dd3
                    remain = (dpi_video->h_active_pixels * PRECISION_FACTOR /
  104e6c:	ebcc 134c 	rsb	r3, r12, r12, lsl #5
  104e70:	4656      	mov	r6, r10
                        video_size) % PRECISION_FACTOR;
  104e72:	f2c1 0b62 	movt	r11, #4194	; 0x1062
                            video_size / 100 + VIDEO_PACKET_OVERHEAD;
  104e76:	9200      	str	r2, [sp, #0]
                    remain = (dpi_video->h_active_pixels * PRECISION_FACTOR /
  104e78:	eb0c 0383 	add.w	r3, r12, r3, lsl #2
  104e7c:	f8cd 8004 	str.w	r8, [r13, #4]
  104e80:	00db      	lsls	r3, r3, #3
  104e82:	4699      	mov	r9, r3
  104e84:	fb99 f0f6 	sdiv	r0, r9, r6
                        bytes_per_chunk =  bytes_per_pixel_x100 *
  104e88:	fb07 f306 	mul.w	r3, r7, r6
                            video_size / 100 + VIDEO_PACKET_OVERHEAD;
  104e8c:	9a00      	ldr	r2, [sp, #0]
                    video_size += video_size_step) {
  104e8e:	eb0a 0806 	add.w	r8, r10, r6
                            video_size / 100 + VIDEO_PACKET_OVERHEAD;
  104e92:	fba2 2303 	umull	r2, r3, r2, r3
                        video_size) % PRECISION_FACTOR;
  104e96:	fbab e200 	umull	r14, r2, r11, r0
                            video_size / 100 + VIDEO_PACKET_OVERHEAD;
  104e9a:	095b      	lsrs	r3, r3, #5
  104e9c:	3306      	adds	r3, #6
                        video_size) % PRECISION_FACTOR;
  104e9e:	0992      	lsrs	r2, r2, #6
  104ea0:	ebc2 1e42 	rsb	r14, r2, r2, lsl #5
  104ea4:	eb02 028e 	add.w	r2, r2, r14, lsl #2
                    if (remain == 0) {
  104ea8:	ebb0 0fc2 	cmp.w	r0, r2, lsl #3
  104eac:	d105      	bne.n	104eba <mipi_dsih_dpi_video+0x3f6>
                        no_of_chunks = dpi_video->h_active_pixels / video_size;
  104eae:	fbbc f2f6 	udiv	r2, r12, r6
                        if (total_bytes >= (bytes_per_chunk * no_of_chunks)) {
  104eb2:	fb02 f303 	mul.w	r3, r2, r3
  104eb6:	428b      	cmp	r3, r1
  104eb8:	d918      	bls.n	104eec <mipi_dsih_dpi_video+0x428>
                    video_size += video_size_step) {
  104eba:	fa1f f688 	uxth.w	r6, r8
                for (video_size = video_size_step;
  104ebe:	45b4      	cmp	r12, r6
  104ec0:	d8e0      	bhi.n	104e84 <mipi_dsih_dpi_video+0x3c0>
  104ec2:	f8dd 8004 	ldr.w	r8, [r13, #4]
                         (video_size % video_size_step) != 0;
  104ec6:	fb9c f1f8 	sdiv	r1, r12, r8
  104eca:	fb08 c111 	mls	r1, r8, r1, r12
                    for (video_size = dpi_video->h_active_pixels;
  104ece:	b149      	cbz	r1, 104ee4 <mipi_dsih_dpi_video+0x420>
                         video_size++)
  104ed0:	f10c 0c01 	add.w	r12, r12, #1
  104ed4:	fa1f fc8c 	uxth.w	r12, r12
                         (video_size % video_size_step) != 0;
  104ed8:	fb9c f1f8 	sdiv	r1, r12, r8
  104edc:	fb08 c111 	mls	r1, r8, r1, r12
                    for (video_size = dpi_video->h_active_pixels;
  104ee0:	2900      	cmp	r1, #0
  104ee2:	d1f5      	bne.n	104ed0 <mipi_dsih_dpi_video+0x40c>
        bytes_per_chunk = bytes_per_pixel_x100 * dpi_video->h_active_pixels / 100
  104ee4:	4666      	mov	r6, r12
                    no_of_chunks = 1;
  104ee6:	f04f 0901 	mov.w	r9, #1
  104eea:	e787      	b.n	104dfc <mipi_dsih_dpi_video+0x338>
  104eec:	4618      	mov	r0, r3
                if (bytes_left > (NULL_PACKET_OVERHEAD * no_of_chunks)) {
  104eee:	eb02 0342 	add.w	r3, r2, r2, lsl #1
  104ef2:	4691      	mov	r9, r2
                            bytes_left = total_bytes -
  104ef4:	1a09      	subs	r1, r1, r0
  104ef6:	f8dd 8004 	ldr.w	r8, [r13, #4]
                if (bytes_left > (NULL_PACKET_OVERHEAD * no_of_chunks)) {
  104efa:	005b      	lsls	r3, r3, #1
  104efc:	428b      	cmp	r3, r1
  104efe:	d2e2      	bcs.n	104ec6 <mipi_dsih_dpi_video+0x402>
                    null_packet_size = (bytes_left -
  104f00:	1ac9      	subs	r1, r1, r3
  104f02:	f240 33ff 	movw	r3, #1023	; 0x3ff
                        (NULL_PACKET_OVERHEAD * no_of_chunks)) / no_of_chunks;
  104f06:	fbb1 f1f2 	udiv	r1, r1, r2
  104f0a:	b289      	uxth	r1, r1
  104f0c:	4299      	cmp	r1, r3
  104f0e:	bf28      	it	cs
  104f10:	4619      	movcs	r1, r3
  104f12:	e773      	b.n	104dfc <mipi_dsih_dpi_video+0x338>
        return -1;
  104f14:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
  104f18:	e6e2      	b.n	104ce0 <mipi_dsih_dpi_video+0x21c>
  104f1a:	bf00      	nop

00104f1c <dsi_init>:
}

static int dsi_init(struct intf_device *dev)
{
    return 0;
}
  104f1c:	2000      	movs	r0, #0
  104f1e:	4770      	bx	r14

00104f20 <dsi_config>:
    switch (if_res) {
  104f20:	6843      	ldr	r3, [r0, #4]
{
    return 0;
}

static void dsi_config(struct intf_device *dev, struct sdm_panel *panel)
{
  104f22:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    switch (if_res) {
  104f26:	2b01      	cmp	r3, #1
{
  104f28:	b087      	sub	sp, #28
    switch (if_res) {
  104f2a:	f000 80d8 	beq.w	1050de <dsi_config+0x1be>
  104f2e:	2b02      	cmp	r3, #2
  104f30:	f040 80c8 	bne.w	1050c4 <dsi_config+0x1a4>
  104f34:	f8df 91dc 	ldr.w	r9, [r15, #476]	; 105114 <dsi_config+0x1f4>
  104f38:	2401      	movs	r4, #1
        return 1;
  104f3a:	4627      	mov	r7, r4
  104f3c:	f1a9 0580 	sub.w	r5, r9, #128	; 0x80
    id = dsi_get_index(dev->intf_res);
    if (id < 0) {
        return;
    }

    dev->dsi_index = id;
  104f40:	6147      	str	r7, [r0, #20]
  104f42:	468b      	mov	r11, r1
  104f44:	9002      	str	r0, [sp, #8]
    ctx = &dsi_ctx[id];
    dpi_video = &ctx->dpi_video;
    memset(ctx, 0, sizeof(struct dsi_context));
    ctx->id = id;
  104f46:	01ff      	lsls	r7, r7, #7
    memset(ctx, 0, sizeof(struct dsi_context));
  104f48:	2280      	movs	r2, #128	; 0x80
  104f4a:	2100      	movs	r1, #0
  104f4c:	4648      	mov	r0, r9
  104f4e:	f00e ed2e 	blx	1139ac <memset>
    ctx->id = id;
  104f52:	19eb      	adds	r3, r5, r7
  104f54:	741c      	strb	r4, [r3, #16]
    if (ctx->base) {
  104f56:	f8d9 3000 	ldr.w	r3, [r9]
  104f5a:	2b00      	cmp	r3, #0
  104f5c:	f040 80b5 	bne.w	1050ca <dsi_config+0x1aa>
    switch (ctx->id) {
  104f60:	f899 3010 	ldrb.w	r3, [r9, #16]
  104f64:	2b00      	cmp	r3, #0
  104f66:	f000 80c2 	beq.w	1050ee <dsi_config+0x1ce>
  104f6a:	2b01      	cmp	r3, #1
  104f6c:	f000 80c8 	beq.w	105100 <dsi_config+0x1e0>
    /*dsi ctx set base address*/
    dsi_get_reg_base(ctx);
    /*dsi ctx set irq number*/
    dsi_get_irq_num(ctx);

    ctx->ops = &dwc_mipi_dsi_host_ops;
  104f70:	f24f 6324 	movw	r3, #63012	; 0xf624
  104f74:	19ec      	adds	r4, r5, r7

    ret = mipi_dsih_open(ctx);
  104f76:	4648      	mov	r0, r9
    ctx->ops = &dwc_mipi_dsi_host_ops;
  104f78:	f2c0 0311 	movt	r3, #17
  104f7c:	67e3      	str	r3, [r4, #124]	; 0x7c
    ret = mipi_dsih_open(ctx);
  104f7e:	f7ff fd41 	bl	104a04 <mipi_dsih_open>
    if (ret < 0) {
  104f82:	2800      	cmp	r0, #0
  104f84:	f2c0 809e 	blt.w	1050c4 <dsi_config+0x1a4>
        DISPERR("mipi dsih open failed\n");
        return;
    }

    /*init dpi video params*/
    dpi_video->n_lanes = panel->mipi->lane_number;
  104f88:	f8db a024 	ldr.w	r10, [r11, #36]	; 0x24
  104f8c:	f107 0220 	add.w	r2, r7, #32

    dpi_video->pixel_clock = dev->tcon_clk / 1000;
    //dpi_video->pixel_clock = panel->display_timing->tcon_clk / 1000;
    dpi_video->byte_clock = dpi_video->phy_freq / 8;

    ret = mipi_dsih_dpi_video(ctx);
  104f90:	4648      	mov	r0, r9
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104f92:	f64d 6883 	movw	r8, #56963	; 0xde83
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  104f96:	f8db 3020 	ldr.w	r3, [r11, #32]
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104f9a:	f2c4 381b 	movt	r8, #17179	; 0x431b
    dpi_video->phy_freq = panel->mipi->phy_freq;
  104f9e:	f8da 7008 	ldr.w	r7, [r10, #8]
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  104fa2:	8899      	ldrh	r1, [r3, #4]
  104fa4:	9101      	str	r1, [sp, #4]
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fa6:	f640 0bff 	movw	r11, #2303	; 0x8ff
  104faa:	9204      	str	r2, [sp, #16]
  104fac:	f2c0 0b3d 	movt	r11, #61	; 0x3d
    lp2hs = MAX_TIME_LP2HS * panel->mipi->phy_freq / 8000000;
  104fb0:	ebc7 1947 	rsb	r9, r7, r7, lsl #5
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104fb4:	ebc7 1c07 	rsb	r12, r7, r7, lsl #4
    lp2hs = MAX_TIME_LP2HS * panel->mipi->phy_freq / 8000000;
  104fb8:	eb07 0989 	add.w	r9, r7, r9, lsl #2
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104fbc:	ea4f 0ccc 	mov.w	r12, r12, lsl #3
    lp2hs = MAX_TIME_LP2HS * panel->mipi->phy_freq / 8000000;
  104fc0:	ea4f 0989 	mov.w	r9, r9, lsl #2
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104fc4:	fba8 610c 	umull	r6, r1, r8, r12
    lp2hs = MAX_TIME_LP2HS * panel->mipi->phy_freq / 8000000;
  104fc8:	fba8 6e09 	umull	r6, r14, r8, r9
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  104fcc:	899e      	ldrh	r6, [r3, #12]
  104fce:	9603      	str	r6, [sp, #12]
    hs2lp = MAX_TIME_HS2LP * panel->mipi->phy_freq / 8000000;
  104fd0:	0d49      	lsrs	r1, r1, #21
    lp2hs = MAX_TIME_LP2HS * panel->mipi->phy_freq / 8000000;
  104fd2:	ea4f 5e5e 	mov.w	r14, r14, lsr #21
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fd6:	ebc1 1841 	rsb	r8, r1, r1, lsl #5
    lp2hs += (MAX_TIME_LP2HS * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fda:	ebce 124e 	rsb	r2, r14, r14, lsl #5
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fde:	ebc8 1888 	rsb	r8, r8, r8, lsl #6
    lp2hs += (MAX_TIME_LP2HS * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fe2:	ebc2 1282 	rsb	r2, r2, r2, lsl #6
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fe6:	eb01 08c8 	add.w	r8, r1, r8, lsl #3
    lp2hs += (MAX_TIME_LP2HS * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fea:	eb0e 02c2 	add.w	r2, r14, r2, lsl #3
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104fee:	ebac 2848 	sub.w	r8, r12, r8, lsl #9
    lp2hs += (MAX_TIME_LP2HS * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104ff2:	eba9 2242 	sub.w	r2, r9, r2, lsl #9
    dpi_video->v_total_lines = panel->display_timing->vactive +
  104ff6:	f8b3 9014 	ldrh.w	r9, [r3, #20]
    hs2lp += (MAX_TIME_HS2LP * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  104ffa:	45d8      	cmp	r8, r11
  104ffc:	bf88      	it	hi
  104ffe:	3101      	addhi	r1, #1
    lp2hs += (MAX_TIME_LP2HS * panel->mipi->phy_freq % 8000000) < 4000000 ? 0 : 1;
  105000:	455a      	cmp	r2, r11
  105002:	bf88      	it	hi
  105004:	f10e 0e01 	addhi.w	r14, r14, #1
    dpi_video->v_total_lines = panel->display_timing->vactive +
  105008:	f8b3 b01c 	ldrh.w	r11, [r3, #28]
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  10500c:	9a01      	ldr	r2, [sp, #4]
    dpi_video->v_total_lines = panel->display_timing->vactive +
  10500e:	eb09 0c0b 	add.w	r12, r9, r11
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  105012:	eb02 0806 	add.w	r8, r2, r6
    dpi_video->n_lanes = panel->mipi->lane_number;
  105016:	f8da 2004 	ldr.w	r2, [r10, #4]
    dpi_video->burst_mode = panel->mipi->burst_mode;
  10501a:	f8ba a000 	ldrh.w	r10, [r10]
    dpi_video->n_lanes = panel->mipi->lane_number;
  10501e:	7662      	strb	r2, [r4, #25]
    dpi_video->byte_clock = dpi_video->phy_freq / 8;
  105020:	08fa      	lsrs	r2, r7, #3
    dpi_video->data_lp2hs = lp2hs;
  105022:	f8a4 e01e 	strh.w	r14, [r4, #30]
    dpi_video->clk_hs2lp = 4;
  105026:	f04f 0e04 	mov.w	r14, #4
    dpi_video->byte_clock = dpi_video->phy_freq / 8;
  10502a:	9205      	str	r2, [sp, #20]
    dpi_video->clk_hs2lp = 4;
  10502c:	f2c0 0e0f 	movt	r14, #15
        panel->display_timing->hback_porch + panel->display_timing->hsync_len +
  105030:	689a      	ldr	r2, [r3, #8]
    dpi_video->burst_mode = panel->mipi->burst_mode;
  105032:	f884 a01a 	strb.w	r10, [r4, #26]
        panel->display_timing->hback_porch + panel->display_timing->hsync_len +
  105036:	f8b3 a010 	ldrh.w	r10, [r3, #16]
    dpi_video->data_hs2lp = hs2lp;
  10503a:	83a1      	strh	r1, [r4, #28]
        panel->display_timing->hback_porch + panel->display_timing->hsync_len +
  10503c:	44d0      	add	r8, r10
    dpi_video->color_coding = COLOR_CODE_24BIT;
  10503e:	2105      	movs	r1, #5
        panel->display_timing->hback_porch + panel->display_timing->hsync_len +
  105040:	4490      	add	r8, r2
    dpi_video->clk_hs2lp = 4;
  105042:	9a04      	ldr	r2, [sp, #16]
    dpi_video->phy_freq = panel->mipi->phy_freq;
  105044:	6367      	str	r7, [r4, #52]	; 0x34
    dpi_video->color_coding = COLOR_CODE_24BIT;
  105046:	63a1      	str	r1, [r4, #56]	; 0x38
        panel->display_timing->vback_porch + panel->display_timing->vsync_len +
  105048:	8c19      	ldrh	r1, [r3, #32]
    dpi_video->clk_hs2lp = 4;
  10504a:	f845 e002 	str.w	r14, [r5, r2]
  10504e:	4415      	add	r5, r2
    dpi_video->clk_lp2hs = 15;
  105050:	2200      	movs	r2, #0
        panel->display_timing->vback_porch + panel->display_timing->vsync_len +
  105052:	f8b3 e018 	ldrh.w	r14, [r3, #24]
  105056:	448c      	add	r12, r1
    dpi_video->clk_lp2hs = 15;
  105058:	606a      	str	r2, [r5, #4]
        panel->display_timing->vback_porch + panel->display_timing->vsync_len +
  10505a:	44f4      	add	r12, r14
    dpi_video->frame_ack_en = 0;
  10505c:	62a2      	str	r2, [r4, #40]	; 0x28
    dpi_video->is_18_loosely = 0;
  10505e:	63e2      	str	r2, [r4, #60]	; 0x3c
    dpi_video->eotp_rx_en = 0;
  105060:	6622      	str	r2, [r4, #96]	; 0x60
    dpi_video->dpi_lp_cmd_en = 0;
  105062:	6722      	str	r2, [r4, #112]	; 0x70
    dpi_video->virtual_channel= 0;
  105064:	7622      	strb	r2, [r4, #24]
    dpi_video->eotp_tx_en = 1;
  105066:	2201      	movs	r2, #1
    dpi_video->h_active_pixels = panel->display_timing->hactive;
  105068:	9d01      	ldr	r5, [sp, #4]
    dpi_video->h_back_porch_pixels = panel->display_timing->hback_porch;
  10506a:	f8a4 604c 	strh.w	r6, [r4, #76]	; 0x4c
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  10506e:	9e02      	ldr	r6, [sp, #8]
    dpi_video->h_active_pixels = panel->display_timing->hactive;
  105070:	f8a4 5048 	strh.w	r5, [r4, #72]	; 0x48
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  105074:	f644 55d3 	movw	r5, #19923	; 0x4dd3
    dpi_video->eotp_tx_en = 1;
  105078:	6662      	str	r2, [r4, #100]	; 0x64
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  10507a:	f2c1 0562 	movt	r5, #4194	; 0x1062
  10507e:	69b2      	ldr	r2, [r6, #24]
    dpi_video->v_total_lines = panel->display_timing->vactive +
  105080:	f8a4 c05c 	strh.w	r12, [r4, #92]	; 0x5c
    dpi_video->data_en_polarity = panel->display_timing->de_pol;
  105084:	6a9e      	ldr	r6, [r3, #40]	; 0x28
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  105086:	fb85 7502 	smull	r7, r5, r5, r2
    dpi_video->data_en_polarity = panel->display_timing->de_pol;
  10508a:	6426      	str	r6, [r4, #64]	; 0x40
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  10508c:	ea4f 7ce2 	mov.w	r12, r2, asr #31
    dpi_video->h_polarity = panel->display_timing->hsync_pol;
  105090:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    dpi_video->byte_clock = dpi_video->phy_freq / 8;
  105092:	9a05      	ldr	r2, [sp, #20]
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  105094:	ebcc 15a5 	rsb	r5, r12, r5, asr #6
    dpi_video->v_polarity = panel->display_timing->vsync_pol;
  105098:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    dpi_video->h_total_pixels = panel->display_timing->hactive +
  10509a:	f8a4 804e 	strh.w	r8, [r4, #78]	; 0x4e
    dpi_video->h_sync_pixels = panel->display_timing->hsync_len;
  10509e:	f8a4 a04a 	strh.w	r10, [r4, #74]	; 0x4a
    dpi_video->v_active_lines = panel->display_timing->vactive;
  1050a2:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    dpi_video->v_sync_lines = panel->display_timing->vsync_len;
  1050a6:	f8a4 1056 	strh.w	r1, [r4, #86]	; 0x56
    dpi_video->v_back_porch_lines = panel->display_timing->vback_porch;
  1050aa:	f8a4 b058 	strh.w	r11, [r4, #88]	; 0x58
    dpi_video->v_front_porch_lines = panel->display_timing->vfront_porch;
  1050ae:	f8a4 e05a 	strh.w	r14, [r4, #90]	; 0x5a
    dpi_video->byte_clock = dpi_video->phy_freq / 8;
  1050b2:	62e2      	str	r2, [r4, #44]	; 0x2c
    dpi_video->h_polarity = panel->display_timing->hsync_pol;
  1050b4:	6466      	str	r6, [r4, #68]	; 0x44
    dpi_video->v_polarity = panel->display_timing->vsync_pol;
  1050b6:	6523      	str	r3, [r4, #80]	; 0x50
    dpi_video->pixel_clock = dev->tcon_clk / 1000;
  1050b8:	6325      	str	r5, [r4, #48]	; 0x30
    if (ret < 0) {
        DISPERR("dsi: mipi_dsih_dpi_video failed\n");
    }
}
  1050ba:	b007      	add	sp, #28
  1050bc:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    ret = mipi_dsih_dpi_video(ctx);
  1050c0:	f7ff bd00 	b.w	104ac4 <mipi_dsih_dpi_video>
}
  1050c4:	b007      	add	sp, #28
  1050c6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    switch (ctx->id) {
  1050ca:	f899 3010 	ldrb.w	r3, [r9, #16]
  1050ce:	b19b      	cbz	r3, 1050f8 <dsi_config+0x1d8>
  1050d0:	2b01      	cmp	r3, #1
  1050d2:	f47f af4d 	bne.w	104f70 <dsi_config+0x50>
        ctx->irq = MIPI_DSI2_INTERRUPT_NUM;
  1050d6:	23ac      	movs	r3, #172	; 0xac
  1050d8:	f8c9 3004 	str.w	r3, [r9, #4]
  1050dc:	e748      	b.n	104f70 <dsi_config+0x50>
    switch (if_res) {
  1050de:	f64e 1568 	movw	r5, #59752	; 0xe968
  1050e2:	2400      	movs	r4, #0
        return 0;
  1050e4:	4627      	mov	r7, r4
    switch (if_res) {
  1050e6:	f2c0 0512 	movt	r5, #18
  1050ea:	46a9      	mov	r9, r5
  1050ec:	e728      	b.n	104f40 <dsi_config+0x20>
        ctx->base = (addr_t) _ioaddr(DSI1_BASE);
  1050ee:	2300      	movs	r3, #0
  1050f0:	f2cf 03d6 	movt	r3, #61654	; 0xf0d6
  1050f4:	f8c9 3000 	str.w	r3, [r9]
        ctx->irq = MIPI_DSI1_INTERRUPT_NUM;
  1050f8:	23ab      	movs	r3, #171	; 0xab
  1050fa:	f8c9 3004 	str.w	r3, [r9, #4]
  1050fe:	e737      	b.n	104f70 <dsi_config+0x50>
        ctx->base = (addr_t) _ioaddr(DSI2_BASE);
  105100:	2300      	movs	r3, #0
  105102:	f2cf 03d7 	movt	r3, #61655	; 0xf0d7
  105106:	f8c9 3000 	str.w	r3, [r9]
        ctx->irq = MIPI_DSI2_INTERRUPT_NUM;
  10510a:	23ac      	movs	r3, #172	; 0xac
  10510c:	f8c9 3004 	str.w	r3, [r9, #4]
  105110:	e72e      	b.n	104f70 <dsi_config+0x50>
  105112:	bf00      	nop
  105114:	0012e9e8 	.word	0x0012e9e8

00105118 <dsi_deinit>:
  105118:	2000      	movs	r0, #0
  10511a:	4770      	bx	r14

0010511c <disp_vsync_callback>:

    return &intf_dev[dc_id];
}

/**********/
int disp_vsync_callback(int display_id) {
  10511c:	b510      	push	{r4, r14}
  10511e:	4604      	mov	r4, r0
    display_handle *handle = hal_get_display_handle(display_id);
  105120:	f006 fe78 	bl	10be14 <hal_get_display_handle>

    if (handle->vsync)
  105124:	6c81      	ldr	r1, [r0, #72]	; 0x48
  105126:	b129      	cbz	r1, 105134 <disp_vsync_callback+0x18>
        return handle->vsync(display_id, 0);
  105128:	4620      	mov	r0, r4
  10512a:	2200      	movs	r2, #0
  10512c:	2300      	movs	r3, #0
    return 0;
}
  10512e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        return handle->vsync(display_id, 0);
  105132:	4708      	bx	r1
}
  105134:	4608      	mov	r0, r1
  105136:	bd10      	pop	{r4, r15}

00105138 <disp_init>:

int disp_init(display_handle *handle)
{
  105138:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
    const double pix_clk = 415800000;//415.8MHz

#ifdef DISP_VERSION
    DISPMSG("sd_disp build safety version: %s\n", DISP_VERSION);
#endif
    if (handle->dm->num_dc > 0) {
  10513c:	68c3      	ldr	r3, [r0, #12]
{
  10513e:	ed2d 8b04 	vpush	{d8-d9}
    if (handle->dm->num_dc > 0) {
  105142:	689c      	ldr	r4, [r3, #8]
  105144:	2c00      	cmp	r4, #0
  105146:	dd53      	ble.n	1051f0 <disp_init+0xb8>
        dc_res = &handle->dm->dc[0];
  105148:	f8d3 e00c 	ldr.w	r14, [r3, #12]
    switch (res_info->res_id) {
  10514c:	f243 021d 	movw	r2, #12317	; 0x301d
  105150:	f2c4 3256 	movt	r2, #17238	; 0x4356
        dc_id = get_dc_index(dc_res);
  105154:	f8de 3000 	ldr.w	r3, [r14]
    switch (res_info->res_id) {
  105158:	4293      	cmp	r3, r2
  10515a:	f000 8184 	beq.w	105466 <disp_init+0x32e>
  10515e:	d84c      	bhi.n	1051fa <disp_init+0xc2>
  105160:	f241 021b 	movw	r2, #4123	; 0x101b
  105164:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105168:	4293      	cmp	r3, r2
  10516a:	f000 8118 	beq.w	10539e <disp_init+0x266>
  10516e:	f242 021c 	movw	r2, #8220	; 0x201c
  105172:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105176:	4293      	cmp	r3, r2
  105178:	f040 815f 	bne.w	10543a <disp_init+0x302>
  10517c:	4eca      	ldr	r6, [pc, #808]	; (1054a8 <disp_init+0x370>)
  10517e:	f04f 0a94 	mov.w	r10, #148	; 0x94
  105182:	f04f 09a1 	mov.w	r9, #161	; 0xa1
        return 1;
  105186:	2301      	movs	r3, #1
  105188:	f1a6 0558 	sub.w	r5, r6, #88	; 0x58
        tcon_irq = get_tcon_irq(dc_res);
        panel = handle->panels[0];
        mlc_select = get_mlc_select(handle->dm->num_dc, dc_id, handle->res->dp_res);
  10518c:	6882      	ldr	r2, [r0, #8]
        panel = handle->panels[0];
  10518e:	f8d0 8014 	ldr.w	r8, [r0, #20]
        mlc_select = get_mlc_select(handle->dm->num_dc, dc_id, handle->res->dp_res);
  105192:	f8d2 c084 	ldr.w	r12, [r2, #132]	; 0x84
    switch (dp) {
  105196:	f1bc 0f03 	cmp.w	r12, #3
  10519a:	f200 8125 	bhi.w	1053e8 <disp_init+0x2b0>
  10519e:	e8df f01c 	tbh	[r15, r12, lsl #1]
  1051a2:	00d9      	.short	0x00d9
  1051a4:	00d90043 	.word	0x00d90043
  1051a8:	00eb      	.short	0x00eb
            return 0x2;
  1051aa:	f04f 0e02 	mov.w	r14, #2

        dev->display_id = handle->display_id;
        dev->dc_idx = dc_id;
        dev->ms_info.ms_en = 1;
        dev->ms_info.ms_mode = SLAVE_MODE;
        dev->ms_info.start = panel->display_timing->hactive / 2;
  1051ae:	f8d8 1020 	ldr.w	r1, [r8, #32]
        dev->display_id = handle->display_id;
  1051b2:	eb06 0286 	add.w	r2, r6, r6, lsl #2
  1051b6:	f8d4 9000 	ldr.w	r9, [r4]
        dev->base = (unsigned long)_ioaddr(dc_res->base);
        dev->mlc_select = mlc_select;
        dev->dsp_clk = dsp_clk;
        dev->ratio = ratio;

        dc_ops.init(dev, panel);
  1051ba:	683f      	ldr	r7, [r7, #0]
        dev->display_id = handle->display_id;
  1051bc:	eb06 0242 	add.w	r2, r6, r2, lsl #1
        dev->ms_info.start = panel->display_timing->hactive / 2;
  1051c0:	684c      	ldr	r4, [r1, #4]
        dc_ops.init(dev, panel);
  1051c2:	4641      	mov	r1, r8
        dev->base = (unsigned long)_ioaddr(dc_res->base);
  1051c4:	f8d3 8020 	ldr.w	r8, [r3, #32]
        dev->display_id = handle->display_id;
  1051c8:	00d2      	lsls	r2, r2, #3
  1051ca:	18ab      	adds	r3, r5, r2
  1051cc:	f845 9002 	str.w	r9, [r5, r2]
        dev->ms_info.start = panel->display_timing->hactive / 2;
  1051d0:	0865      	lsrs	r5, r4, #1
        dev->dc_idx = dc_id;
  1051d2:	605e      	str	r6, [r3, #4]
        dev->ms_info.ms_en = 1;
  1051d4:	2201      	movs	r2, #1
        dev->ms_info.start = panel->display_timing->hactive / 2;
  1051d6:	e9c3 5404 	strd	r5, r4, [r3, #16]
        dev->base = (unsigned long)_ioaddr(dc_res->base);
  1051da:	e9c3 c807 	strd	r12, r8, [r3, #28]
        dev->mlc_select = mlc_select;
  1051de:	f8c3 e018 	str.w	r14, [r3, #24]
        dev->dsp_clk = dsp_clk;
  1051e2:	ed83 8b0a 	vstr	d8, [r3, #40]	; 0x28
        dev->ratio = ratio;
  1051e6:	ed83 9b0c 	vstr	d9, [r3, #48]	; 0x30
        dev->ms_info.ms_mode = SLAVE_MODE;
  1051ea:	e9c3 2202 	strd	r2, r2, [r3, #8]
        dc_ops.init(dev, panel);
  1051ee:	47b8      	blx	r7
    }

    return 0;
}
  1051f0:	ecbd 8b04 	vpop	{d8-d9}
  1051f4:	2000      	movs	r0, #0
  1051f6:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
    switch (res_info->res_id) {
  1051fa:	f244 021e 	movw	r2, #16414	; 0x401e
  1051fe:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105202:	4293      	cmp	r3, r2
  105204:	f000 80c2 	beq.w	10538c <disp_init+0x254>
  105208:	f245 021f 	movw	r2, #20511	; 0x501f
  10520c:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105210:	4293      	cmp	r3, r2
  105212:	f040 8112 	bne.w	10543a <disp_init+0x302>
  105216:	4ea5      	ldr	r6, [pc, #660]	; (1054ac <disp_init+0x374>)
  105218:	f44f 7ace 	mov.w	r10, #412	; 0x19c
  10521c:	f04f 09a7 	mov.w	r9, #167	; 0xa7
        return 4;
  105220:	2304      	movs	r3, #4
  105222:	f5a6 75b0 	sub.w	r5, r6, #352	; 0x160
  105226:	e7b1      	b.n	10518c <disp_init+0x54>
            return 0x2;
  105228:	f04f 0c02 	mov.w	r12, #2
  10522c:	ed92 7a27 	vldr	s14, [r2, #156]	; 0x9c
    if (lvds_mode == LVDS_MODE_DUAL)
  105230:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
  105234:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  105238:	2a02      	cmp	r2, #2
  10523a:	f000 8096 	beq.w	10536a <disp_init+0x232>
    return clk / 7.0;
  10523e:	eeb1 6b0c 	vmov.f64	d6, #28	; 0x40e00000  7.0
  105242:	ee87 8b06 	vdiv.f64	d8, d7, d6
  105246:	eebd 8bc8 	vcvt.s32.f64	s16, d8
        ratio = pix_clk / dsp_clk;
  10524a:	ed9f 7b95 	vldr	d7, [r15, #596]	; 1054a0 <disp_init+0x368>
        dsp_clk = get_dsp_clk(handle->res->clk, handle->res->lvds_mode);
  10524e:	eeb8 8bc8 	vcvt.f64.s32	d8, s16
        dev->display_id = handle->display_id;
  105252:	009f      	lsls	r7, r3, #2
  105254:	18fa      	adds	r2, r7, r3
  105256:	6801      	ldr	r1, [r0, #0]
        if (handle->dm->num_dc == 1) {
  105258:	2c01      	cmp	r4, #1
        dev->display_id = handle->display_id;
  10525a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
  10525e:	4604      	mov	r4, r0
        dev->ms_info.ms_mode = MASTER_MODE;
  105260:	441f      	add	r7, r3
        ratio = pix_clk / dsp_clk;
  105262:	ee87 9b08 	vdiv.f64	d9, d7, d8
        dev->display_id = handle->display_id;
  105266:	ea4f 02c2 	mov.w	r2, r2, lsl #3
  10526a:	eb05 0b02 	add.w	r11, r5, r2
  10526e:	50a9      	str	r1, [r5, r2]
            dev->ms_info.ms_en = 1;
  105270:	bf1b      	ittet	ne
  105272:	2101      	movne	r1, #1
            dev->ms_info.end = panel->display_timing->hactive / 2;
  105274:	f8d8 2020 	ldrne.w	r2, [r8, #32]
            dev->ms_info.ms_en = 0;
  105278:	2200      	moveq	r2, #0
            dev->ms_info.ms_en = 1;
  10527a:	f8cb 1008 	strne.w	r1, [r11, #8]
            dev->ms_info.start = 0;
  10527e:	bf18      	it	ne
  105280:	2100      	movne	r1, #0
        dev->dc_idx = dc_id;
  105282:	f8cb 3004 	str.w	r3, [r11, #4]
        dev->ms_info.ms_mode = MASTER_MODE;
  105286:	eb03 0347 	add.w	r3, r3, r7, lsl #1
            dev->ms_info.end = panel->display_timing->hactive / 2;
  10528a:	bf18      	it	ne
  10528c:	6852      	ldrne	r2, [r2, #4]
        dc_ops.init(dev, panel);
  10528e:	f648 07f8 	movw	r7, #35064	; 0x88f8
            dev->ms_info.start = 0;
  105292:	bf18      	it	ne
  105294:	f8cb 1010 	strne.w	r1, [r11, #16]
        dev->ms_info.ms_mode = MASTER_MODE;
  105298:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
  10529c:	f04f 0100 	mov.w	r1, #0
        dc_ops.init(dev, panel);
  1052a0:	f2c0 0711 	movt	r7, #17
            dev->ms_info.ms_en = 0;
  1052a4:	bf0c      	ite	eq
  1052a6:	f8cb 2008 	streq.w	r2, [r11, #8]
            dev->ms_info.end = panel->display_timing->hactive / 2;
  1052aa:	0852      	lsrne	r2, r2, #1
        mutex_init(&dev->mutex_refresh);
  1052ac:	eb05 000a 	add.w	r0, r5, r10
            dev->ms_info.end = panel->display_timing->hactive / 2;
  1052b0:	bf18      	it	ne
  1052b2:	f8cb 2014 	strne.w	r2, [r11, #20]
        dev->base = (unsigned long)_ioaddr(dc_res->base);
  1052b6:	f8de 2004 	ldr.w	r2, [r14, #4]
  1052ba:	e9c3 9207 	strd	r9, r2, [r3, #28]
        dev->mlc_select = mlc_select;
  1052be:	f8c3 c018 	str.w	r12, [r3, #24]
        dev->ms_info.ms_mode = MASTER_MODE;
  1052c2:	60d9      	str	r1, [r3, #12]
        dev->vsync_wait = 0;
  1052c4:	6559      	str	r1, [r3, #84]	; 0x54
        dev->dsp_clk = dsp_clk;
  1052c6:	ed83 8b0a 	vstr	d8, [r3, #40]	; 0x28
        dev->ratio = ratio;
  1052ca:	ed83 9b0c 	vstr	d9, [r3, #48]	; 0x30
        mutex_init(&dev->mutex_refresh);
  1052ce:	f011 f92d 	bl	11652c <mutex_init>
        dc_ops.init(dev, panel);
  1052d2:	683b      	ldr	r3, [r7, #0]
  1052d4:	4641      	mov	r1, r8
  1052d6:	4630      	mov	r0, r6
  1052d8:	4798      	blx	r3
        if (handle->is_need_register_irq) {
  1052da:	f894 3052 	ldrb.w	r3, [r4, #82]	; 0x52
  1052de:	2b00      	cmp	r3, #0
  1052e0:	d179      	bne.n	1053d6 <disp_init+0x29e>
  1052e2:	68e3      	ldr	r3, [r4, #12]
  1052e4:	689a      	ldr	r2, [r3, #8]
    if (handle->dm->num_dc > 1) {
  1052e6:	2a01      	cmp	r2, #1
  1052e8:	dd82      	ble.n	1051f0 <disp_init+0xb8>
        dc_res = &handle->dm->dc[1];
  1052ea:	68db      	ldr	r3, [r3, #12]
    switch (res_info->res_id) {
  1052ec:	f243 011d 	movw	r1, #12317	; 0x301d
  1052f0:	f2c4 3156 	movt	r1, #17238	; 0x4356
        dc_id = get_dc_index(dc_res);
  1052f4:	69da      	ldr	r2, [r3, #28]
    switch (res_info->res_id) {
  1052f6:	428a      	cmp	r2, r1
  1052f8:	f000 8086 	beq.w	105408 <disp_init+0x2d0>
  1052fc:	d85a      	bhi.n	1053b4 <disp_init+0x27c>
  1052fe:	f241 011b 	movw	r1, #4123	; 0x101b
  105302:	f2c4 3156 	movt	r1, #17238	; 0x4356
  105306:	428a      	cmp	r2, r1
  105308:	d076      	beq.n	1053f8 <disp_init+0x2c0>
  10530a:	f242 011c 	movw	r1, #8220	; 0x201c
  10530e:	f2c4 3156 	movt	r1, #17238	; 0x4356
  105312:	428a      	cmp	r2, r1
  105314:	d17d      	bne.n	105412 <disp_init+0x2da>
  105316:	4864      	ldr	r0, [pc, #400]	; (1054a8 <disp_init+0x370>)
  105318:	f04f 0ca1 	mov.w	r12, #161	; 0xa1
        return 1;
  10531c:	2601      	movs	r6, #1
        mlc_select = get_mlc_select(handle->dm->num_dc, dc_id, handle->res->dp_res);
  10531e:	68a2      	ldr	r2, [r4, #8]
    switch (dp) {
  105320:	f8d2 2084 	ldr.w	r2, [r2, #132]	; 0x84
  105324:	2a03      	cmp	r2, #3
  105326:	d85c      	bhi.n	1053e2 <disp_init+0x2aa>
  105328:	a101      	add	r1, pc, #4	; (adr r1, 105330 <disp_init+0x1f8>)
  10532a:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
  10532e:	bf00      	nop
  105330:	00105341 	.word	0x00105341
  105334:	001051ab 	.word	0x001051ab
  105338:	00105341 	.word	0x00105341
  10533c:	00105347 	.word	0x00105347
            return 0x1;
  105340:	f04f 0e01 	mov.w	r14, #1
  105344:	e733      	b.n	1051ae <disp_init+0x76>
                return 0x2;
  105346:	2e00      	cmp	r6, #0
  105348:	bf0c      	ite	eq
  10534a:	f04f 0e01 	moveq.w	r14, #1
  10534e:	f04f 0e02 	movne.w	r14, #2
  105352:	e72c      	b.n	1051ae <disp_init+0x76>
  105354:	ed92 7a27 	vldr	s14, [r2, #156]	; 0x9c
            return 0x1;
  105358:	f04f 0c01 	mov.w	r12, #1
    if (lvds_mode == LVDS_MODE_DUAL)
  10535c:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
  105360:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  105364:	2a02      	cmp	r2, #2
  105366:	f47f af6a 	bne.w	10523e <disp_init+0x106>
        return clk / 3.5;
  10536a:	eeb0 6b0c 	vmov.f64	d6, #12	; 0x40600000  3.5
  10536e:	ee87 8b06 	vdiv.f64	d8, d7, d6
  105372:	eebd 8bc8 	vcvt.s32.f64	s16, d8
  105376:	e768      	b.n	10524a <disp_init+0x112>
            if (dc_num == 1)
  105378:	2c01      	cmp	r4, #1
  10537a:	f43f af57 	beq.w	10522c <disp_init+0xf4>
                return 0x2;
  10537e:	2b00      	cmp	r3, #0
  105380:	bf0c      	ite	eq
  105382:	f04f 0c01 	moveq.w	r12, #1
  105386:	f04f 0c02 	movne.w	r12, #2
  10538a:	e74f      	b.n	10522c <disp_init+0xf4>
    switch (res_info->res_id) {
  10538c:	4e48      	ldr	r6, [pc, #288]	; (1054b0 <disp_init+0x378>)
  10538e:	f44f 7aa2 	mov.w	r10, #324	; 0x144
  105392:	f04f 09a5 	mov.w	r9, #165	; 0xa5
        return 3;
  105396:	2303      	movs	r3, #3
  105398:	f5a6 7584 	sub.w	r5, r6, #264	; 0x108
  10539c:	e6f6      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  10539e:	f64e 2568 	movw	r5, #60008	; 0xea68
  1053a2:	f04f 0a3c 	mov.w	r10, #60	; 0x3c
  1053a6:	f04f 099f 	mov.w	r9, #159	; 0x9f
  1053aa:	f2c0 0512 	movt	r5, #18
  1053ae:	462e      	mov	r6, r5
        return 0;
  1053b0:	2300      	movs	r3, #0
  1053b2:	e6eb      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  1053b4:	f244 011e 	movw	r1, #16414	; 0x401e
  1053b8:	f2c4 3156 	movt	r1, #17238	; 0x4356
  1053bc:	428a      	cmp	r2, r1
  1053be:	d016      	beq.n	1053ee <disp_init+0x2b6>
  1053c0:	f245 011f 	movw	r1, #20511	; 0x501f
  1053c4:	f2c4 3156 	movt	r1, #17238	; 0x4356
  1053c8:	428a      	cmp	r2, r1
  1053ca:	d122      	bne.n	105412 <disp_init+0x2da>
  1053cc:	4837      	ldr	r0, [pc, #220]	; (1054ac <disp_init+0x374>)
  1053ce:	f04f 0ca7 	mov.w	r12, #167	; 0xa7
        return 4;
  1053d2:	2604      	movs	r6, #4
  1053d4:	e7a3      	b.n	10531e <disp_init+0x1e6>
            register_int_handler(tcon_irq, dc_ops.irq_handler, dev);
  1053d6:	4632      	mov	r2, r6
  1053d8:	4648      	mov	r0, r9
  1053da:	6a39      	ldr	r1, [r7, #32]
  1053dc:	f7fb f998 	bl	100710 <register_int_handler>
  1053e0:	e77f      	b.n	1052e2 <disp_init+0x1aa>
            return 0;
  1053e2:	f04f 0e00 	mov.w	r14, #0
  1053e6:	e6e2      	b.n	1051ae <disp_init+0x76>
  1053e8:	f04f 0c00 	mov.w	r12, #0
  1053ec:	e71e      	b.n	10522c <disp_init+0xf4>
    switch (res_info->res_id) {
  1053ee:	4830      	ldr	r0, [pc, #192]	; (1054b0 <disp_init+0x378>)
  1053f0:	f04f 0ca5 	mov.w	r12, #165	; 0xa5
        return 3;
  1053f4:	2603      	movs	r6, #3
  1053f6:	e792      	b.n	10531e <disp_init+0x1e6>
    switch (res_info->res_id) {
  1053f8:	f64e 2068 	movw	r0, #60008	; 0xea68
  1053fc:	f04f 0c9f 	mov.w	r12, #159	; 0x9f
        return 0;
  105400:	2600      	movs	r6, #0
    switch (res_info->res_id) {
  105402:	f2c0 0012 	movt	r0, #18
  105406:	e78a      	b.n	10531e <disp_init+0x1e6>
  105408:	482a      	ldr	r0, [pc, #168]	; (1054b4 <disp_init+0x37c>)
  10540a:	f04f 0ca3 	mov.w	r12, #163	; 0xa3
        return 2;
  10540e:	2602      	movs	r6, #2
  105410:	e785      	b.n	10531e <disp_init+0x1e6>
    switch (res_info->res_id) {
  105412:	f242 011c 	movw	r1, #8220	; 0x201c
  105416:	f2c4 3156 	movt	r1, #17238	; 0x4356
  10541a:	428a      	cmp	r2, r1
  10541c:	f000 808e 	beq.w	10553c <disp_init+0x404>
  105420:	d82a      	bhi.n	105478 <disp_init+0x340>
  105422:	f241 011b 	movw	r1, #4123	; 0x101b
  105426:	f2c4 3156 	movt	r1, #17238	; 0x4356
  10542a:	428a      	cmp	r2, r1
  10542c:	f000 8080 	beq.w	105530 <disp_init+0x3f8>
  105430:	4821      	ldr	r0, [pc, #132]	; (1054b8 <disp_init+0x380>)
  105432:	f04f 3cff 	mov.w	r12, #4294967295	; 0xffffffff
        return -1;
  105436:	4666      	mov	r6, r12
  105438:	e771      	b.n	10531e <disp_init+0x1e6>
    switch (res_info->res_id) {
  10543a:	f243 021d 	movw	r2, #12317	; 0x301d
  10543e:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105442:	4293      	cmp	r3, r2
  105444:	d064      	beq.n	105510 <disp_init+0x3d8>
  105446:	d839      	bhi.n	1054bc <disp_init+0x384>
  105448:	f241 021b 	movw	r2, #4123	; 0x101b
  10544c:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105450:	4293      	cmp	r3, r2
  105452:	d053      	beq.n	1054fc <disp_init+0x3c4>
  105454:	4e18      	ldr	r6, [pc, #96]	; (1054b8 <disp_init+0x380>)
  105456:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
        return -1;
  10545a:	464b      	mov	r3, r9
    switch (res_info->res_id) {
  10545c:	f06f 0a1b 	mvn.w	r10, #27
  105460:	f106 0558 	add.w	r5, r6, #88	; 0x58
  105464:	e692      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  105466:	4e13      	ldr	r6, [pc, #76]	; (1054b4 <disp_init+0x37c>)
  105468:	f04f 0aec 	mov.w	r10, #236	; 0xec
  10546c:	f04f 09a3 	mov.w	r9, #163	; 0xa3
        return 2;
  105470:	2302      	movs	r3, #2
  105472:	f1a6 05b0 	sub.w	r5, r6, #176	; 0xb0
  105476:	e689      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  105478:	f244 011e 	movw	r1, #16414	; 0x401e
  10547c:	f2c4 3156 	movt	r1, #17238	; 0x4356
  105480:	428a      	cmp	r2, r1
  105482:	d04f      	beq.n	105524 <disp_init+0x3ec>
  105484:	f245 011f 	movw	r1, #20511	; 0x501f
  105488:	f2c4 3156 	movt	r1, #17238	; 0x4356
  10548c:	428a      	cmp	r2, r1
  10548e:	d1cf      	bne.n	105430 <disp_init+0x2f8>
  105490:	4809      	ldr	r0, [pc, #36]	; (1054b8 <disp_init+0x380>)
  105492:	f04f 0ca7 	mov.w	r12, #167	; 0xa7
        return -1;
  105496:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  10549a:	e740      	b.n	10531e <disp_init+0x1e6>
  10549c:	f3af 8000 	nop.w
  1054a0:	c0000000 	.word	0xc0000000
  1054a4:	41b8c89a 	.word	0x41b8c89a
  1054a8:	0012eac0 	.word	0x0012eac0
  1054ac:	0012ebc8 	.word	0x0012ebc8
  1054b0:	0012eb70 	.word	0x0012eb70
  1054b4:	0012eb18 	.word	0x0012eb18
  1054b8:	0012ea10 	.word	0x0012ea10
    switch (res_info->res_id) {
  1054bc:	f244 021e 	movw	r2, #16414	; 0x401e
  1054c0:	f2c4 3256 	movt	r2, #17238	; 0x4356
  1054c4:	4293      	cmp	r3, r2
  1054c6:	d00f      	beq.n	1054e8 <disp_init+0x3b0>
  1054c8:	f245 021f 	movw	r2, #20511	; 0x501f
  1054cc:	f2c4 3256 	movt	r2, #17238	; 0x4356
  1054d0:	4293      	cmp	r3, r2
  1054d2:	d1bf      	bne.n	105454 <disp_init+0x31c>
  1054d4:	4e1c      	ldr	r6, [pc, #112]	; (105548 <disp_init+0x410>)
  1054d6:	f06f 0a1b 	mvn.w	r10, #27
  1054da:	f04f 09a7 	mov.w	r9, #167	; 0xa7
        return -1;
  1054de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  1054e2:	f106 0558 	add.w	r5, r6, #88	; 0x58
  1054e6:	e651      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  1054e8:	4e17      	ldr	r6, [pc, #92]	; (105548 <disp_init+0x410>)
  1054ea:	f06f 0a1b 	mvn.w	r10, #27
  1054ee:	f04f 09a5 	mov.w	r9, #165	; 0xa5
        return -1;
  1054f2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  1054f6:	f106 0558 	add.w	r5, r6, #88	; 0x58
  1054fa:	e647      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  1054fc:	4e12      	ldr	r6, [pc, #72]	; (105548 <disp_init+0x410>)
  1054fe:	f06f 0a1b 	mvn.w	r10, #27
  105502:	f04f 099f 	mov.w	r9, #159	; 0x9f
        return -1;
  105506:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10550a:	f106 0558 	add.w	r5, r6, #88	; 0x58
  10550e:	e63d      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  105510:	4e0d      	ldr	r6, [pc, #52]	; (105548 <disp_init+0x410>)
  105512:	f06f 0a1b 	mvn.w	r10, #27
  105516:	f04f 09a3 	mov.w	r9, #163	; 0xa3
        return -1;
  10551a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10551e:	f106 0558 	add.w	r5, r6, #88	; 0x58
  105522:	e633      	b.n	10518c <disp_init+0x54>
    switch (res_info->res_id) {
  105524:	4808      	ldr	r0, [pc, #32]	; (105548 <disp_init+0x410>)
  105526:	f04f 0ca5 	mov.w	r12, #165	; 0xa5
        return -1;
  10552a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  10552e:	e6f6      	b.n	10531e <disp_init+0x1e6>
    switch (res_info->res_id) {
  105530:	4805      	ldr	r0, [pc, #20]	; (105548 <disp_init+0x410>)
  105532:	f04f 0c9f 	mov.w	r12, #159	; 0x9f
        return -1;
  105536:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  10553a:	e6f0      	b.n	10531e <disp_init+0x1e6>
    switch (res_info->res_id) {
  10553c:	4802      	ldr	r0, [pc, #8]	; (105548 <disp_init+0x410>)
  10553e:	f04f 0ca1 	mov.w	r12, #161	; 0xa1
        return -1;
  105542:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  105546:	e6ea      	b.n	10531e <disp_init+0x1e6>
  105548:	0012ea10 	.word	0x0012ea10

0010554c <disp_post_config>:

    return 0;
}

int disp_post_config(display_handle *handle, struct sdm_post_config *post)
{
  10554c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  105550:	4606      	mov	r6, r0
  105552:	b083      	sub	sp, #12
  105554:	460f      	mov	r7, r1
    int res;
    mod_res_t *dc_res;
    struct dc_device *dev = NULL;


    lk_time_t post_time = current_time();
  105556:	f7fb f87b 	bl	100650 <current_time>
    if (handle->dm->num_dc > 1) {
  10555a:	68f2      	ldr	r2, [r6, #12]
  10555c:	6893      	ldr	r3, [r2, #8]
  10555e:	2b01      	cmp	r3, #1
    struct dc_device *dev = NULL;
  105560:	bfd8      	it	le
  105562:	2400      	movle	r4, #0
    lk_time_t post_time = current_time();
  105564:	4605      	mov	r5, r0
    if (handle->dm->num_dc > 1) {
  105566:	dd46      	ble.n	1055f6 <disp_post_config+0xaa>
        dc_res = &handle->dm->dc[1];
        dc_id = get_dc_index(dc_res);
  105568:	68d3      	ldr	r3, [r2, #12]
    switch (res_info->res_id) {
  10556a:	f243 021d 	movw	r2, #12317	; 0x301d
  10556e:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105572:	69db      	ldr	r3, [r3, #28]
  105574:	4293      	cmp	r3, r2
  105576:	f000 8119 	beq.w	1057ac <disp_post_config+0x260>
  10557a:	f200 80c8 	bhi.w	10570e <disp_post_config+0x1c2>
  10557e:	f241 021b 	movw	r2, #4123	; 0x101b
  105582:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105586:	4293      	cmp	r3, r2
  105588:	f000 80d5 	beq.w	105736 <disp_post_config+0x1ea>
  10558c:	f242 021c 	movw	r2, #8220	; 0x201c
  105590:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105594:	4293      	cmp	r3, r2
  105596:	f040 80f9 	bne.w	10578c <disp_post_config+0x240>
  10559a:	4c8c      	ldr	r4, [pc, #560]	; (1057cc <disp_post_config+0x280>)
  10559c:	2394      	movs	r3, #148	; 0x94
        return 1;
  10559e:	f04f 0a01 	mov.w	r10, #1
  1055a2:	f1a4 0858 	sub.w	r8, r4, #88	; 0x58
        dev = &dc_dev[dc_id];

        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  1055a6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  1055aa:	4498      	add	r8, r3
  1055ac:	4640      	mov	r0, r8
        // event_t *vsync = &dc_dev[get_dc_index(&handle->dm->dc[0])].vsync_kick;
        // while(dc_ops.check_triggle_status(dev)){
        //     event_wait(vsync);
        // }

        dc_ops.update(dev, post);
  1055ae:	f648 0bf8 	movw	r11, #35064	; 0x88f8
        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  1055b2:	f010 ffcb 	bl	11654c <mutex_acquire_timeout>
        dc_ops.update(dev, post);
  1055b6:	4639      	mov	r1, r7

        dc_ops.triggle(dev);

        if (!run_status[dc_id]) {
  1055b8:	f64e 49ac 	movw	r9, #60588	; 0xecac
        dc_ops.update(dev, post);
  1055bc:	f2c0 0b11 	movt	r11, #17
        if (!run_status[dc_id]) {
  1055c0:	f2c0 0912 	movt	r9, #18
        dc_ops.update(dev, post);
  1055c4:	f8db 3008 	ldr.w	r3, [r11, #8]
        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  1055c8:	9001      	str	r0, [sp, #4]
        dc_ops.update(dev, post);
  1055ca:	4620      	mov	r0, r4
  1055cc:	4798      	blx	r3
        dc_ops.triggle(dev);
  1055ce:	f8db 3010 	ldr.w	r3, [r11, #16]
  1055d2:	4620      	mov	r0, r4
  1055d4:	4798      	blx	r3
        if (!run_status[dc_id]) {
  1055d6:	f819 300a 	ldrb.w	r3, [r9, r10]
  1055da:	b933      	cbnz	r3, 1055ea <disp_post_config+0x9e>
            dc_ops.enable(dev);
  1055dc:	f8db 301c 	ldr.w	r3, [r11, #28]
  1055e0:	4620      	mov	r0, r4
  1055e2:	4798      	blx	r3
            run_status[dc_id] = true;
  1055e4:	2301      	movs	r3, #1
  1055e6:	f809 300a 	strb.w	r3, [r9, r10]
        }
        if (!res)
  1055ea:	9b01      	ldr	r3, [sp, #4]
  1055ec:	2b00      	cmp	r3, #0
  1055ee:	f000 80c9 	beq.w	105784 <disp_post_config+0x238>
  1055f2:	68f2      	ldr	r2, [r6, #12]
  1055f4:	6893      	ldr	r3, [r2, #8]
            mutex_release(&dev->mutex_refresh);
    }

    if (handle->dm->num_dc > 0) {
  1055f6:	2b00      	cmp	r3, #0
  1055f8:	dd5a      	ble.n	1056b0 <disp_post_config+0x164>
        dc_res = &handle->dm->dc[0];
        dc_id = get_dc_index(dc_res);
  1055fa:	68d3      	ldr	r3, [r2, #12]
    switch (res_info->res_id) {
  1055fc:	f243 021d 	movw	r2, #12317	; 0x301d
  105600:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105604:	681b      	ldr	r3, [r3, #0]
  105606:	4293      	cmp	r3, r2
  105608:	f000 80d7 	beq.w	1057ba <disp_post_config+0x26e>
  10560c:	d86b      	bhi.n	1056e6 <disp_post_config+0x19a>
  10560e:	f241 021b 	movw	r2, #4123	; 0x101b
  105612:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105616:	4293      	cmp	r3, r2
  105618:	f000 80a6 	beq.w	105768 <disp_post_config+0x21c>
  10561c:	f242 021c 	movw	r2, #8220	; 0x201c
  105620:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105624:	4293      	cmp	r3, r2
  105626:	f040 80b9 	bne.w	10579c <disp_post_config+0x250>
  10562a:	4c68      	ldr	r4, [pc, #416]	; (1057cc <disp_post_config+0x280>)
  10562c:	f04f 0994 	mov.w	r9, #148	; 0x94
        return 1;
  105630:	f04f 0a01 	mov.w	r10, #1
  105634:	f1a4 0858 	sub.w	r8, r4, #88	; 0x58
        dev = &dc_dev[dc_id];

        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  105638:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  10563c:	44c1      	add	r9, r8
  10563e:	4648      	mov	r0, r9
        if (res) {
            DISPMSG("display[%d] got mutex timeout: %d\n", handle->display_id, res);
        }
        dc_ops.update(dev, post);
  105640:	f648 0bf8 	movw	r11, #35064	; 0x88f8
        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  105644:	f010 ff82 	bl	11654c <mutex_acquire_timeout>
        dc_ops.update(dev, post);
  105648:	4639      	mov	r1, r7

        if (!run_status[dc_id]) {
  10564a:	f64e 47ac 	movw	r7, #60588	; 0xecac
        dc_ops.update(dev, post);
  10564e:	f2c0 0b11 	movt	r11, #17
        if (!run_status[dc_id]) {
  105652:	f2c0 0712 	movt	r7, #18
        dc_ops.update(dev, post);
  105656:	f8db 3008 	ldr.w	r3, [r11, #8]
        res = mutex_acquire_timeout(&dev->mutex_refresh, 1000);
  10565a:	9001      	str	r0, [sp, #4]
        dc_ops.update(dev, post);
  10565c:	4620      	mov	r0, r4
  10565e:	4798      	blx	r3
        if (!run_status[dc_id]) {
  105660:	f817 300a 	ldrb.w	r3, [r7, r10]
  105664:	b923      	cbnz	r3, 105670 <disp_post_config+0x124>
            dc_ops.vsync_enable(dev, true);
  105666:	f8db 3018 	ldr.w	r3, [r11, #24]
  10566a:	2101      	movs	r1, #1
  10566c:	4620      	mov	r0, r4
  10566e:	4798      	blx	r3
        }

        dc_ops.triggle(dev);
  105670:	f8db 3010 	ldr.w	r3, [r11, #16]
  105674:	4620      	mov	r0, r4
  105676:	4798      	blx	r3

        if (!run_status[dc_id]) {
  105678:	f817 300a 	ldrb.w	r3, [r7, r10]
  10567c:	b99b      	cbnz	r3, 1056a6 <disp_post_config+0x15a>
            if (handle->is_need_register_irq) {
  10567e:	f896 3052 	ldrb.w	r3, [r6, #82]	; 0x52
  105682:	b14b      	cbz	r3, 105698 <disp_post_config+0x14c>
                unmask_interrupt(dev->irq);
  105684:	eb0a 038a 	add.w	r3, r10, r10, lsl #2
  105688:	eb0a 0343 	add.w	r3, r10, r3, lsl #1
  10568c:	eb08 08c3 	add.w	r8, r8, r3, lsl #3
  105690:	f8d8 001c 	ldr.w	r0, [r8, #28]
  105694:	f7fb f89a 	bl	1007cc <unmask_interrupt>
            }
            dc_ops.enable(dev);
  105698:	f8db 301c 	ldr.w	r3, [r11, #28]
  10569c:	4620      	mov	r0, r4
  10569e:	4798      	blx	r3
            run_status[dc_id] = true;
  1056a0:	2301      	movs	r3, #1
  1056a2:	f807 300a 	strb.w	r3, [r7, r10]
        }

        if (!res)
  1056a6:	9b01      	ldr	r3, [sp, #4]
  1056a8:	2b00      	cmp	r3, #0
  1056aa:	d067      	beq.n	10577c <disp_post_config+0x230>
  1056ac:	68f3      	ldr	r3, [r6, #12]
  1056ae:	689b      	ldr	r3, [r3, #8]
            mutex_release(&dev->mutex_refresh);
    }

    while((handle->dm->num_dc <= 1) && dc_ops.check_triggle_status(dev)){
  1056b0:	f648 07f8 	movw	r7, #35064	; 0x88f8
  1056b4:	2b01      	cmp	r3, #1
  1056b6:	f2c0 0711 	movt	r7, #17
  1056ba:	dc10      	bgt.n	1056de <disp_post_config+0x192>
  1056bc:	697b      	ldr	r3, [r7, #20]
  1056be:	4620      	mov	r0, r4
  1056c0:	4798      	blx	r3
  1056c2:	b160      	cbz	r0, 1056de <disp_post_config+0x192>
        while(post_time > (lk_time_t)dev->vsync_wait) {
  1056c4:	6d63      	ldr	r3, [r4, #84]	; 0x54
  1056c6:	429d      	cmp	r5, r3
  1056c8:	d905      	bls.n	1056d6 <disp_post_config+0x18a>
            thread_sleep(1);
  1056ca:	2001      	movs	r0, #1
  1056cc:	f011 f826 	bl	11671c <thread_sleep>
        while(post_time > (lk_time_t)dev->vsync_wait) {
  1056d0:	6d63      	ldr	r3, [r4, #84]	; 0x54
  1056d2:	42ab      	cmp	r3, r5
  1056d4:	d3f9      	bcc.n	1056ca <disp_post_config+0x17e>
  1056d6:	68f3      	ldr	r3, [r6, #12]
  1056d8:	689b      	ldr	r3, [r3, #8]
    while((handle->dm->num_dc <= 1) && dc_ops.check_triggle_status(dev)){
  1056da:	2b01      	cmp	r3, #1
  1056dc:	ddee      	ble.n	1056bc <disp_post_config+0x170>
        }
    }

    return 0;
}
  1056de:	2000      	movs	r0, #0
  1056e0:	b003      	add	sp, #12
  1056e2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    switch (res_info->res_id) {
  1056e6:	f244 021e 	movw	r2, #16414	; 0x401e
  1056ea:	f2c4 3256 	movt	r2, #17238	; 0x4356
  1056ee:	4293      	cmp	r3, r2
  1056f0:	d02a      	beq.n	105748 <disp_post_config+0x1fc>
  1056f2:	f245 021f 	movw	r2, #20511	; 0x501f
  1056f6:	f2c4 3256 	movt	r2, #17238	; 0x4356
  1056fa:	4293      	cmp	r3, r2
  1056fc:	d14e      	bne.n	10579c <disp_post_config+0x250>
    case RES_DC_DC5:
  1056fe:	4c34      	ldr	r4, [pc, #208]	; (1057d0 <disp_post_config+0x284>)
  105700:	f44f 79ce 	mov.w	r9, #412	; 0x19c
        return 4;
  105704:	f04f 0a04 	mov.w	r10, #4
  105708:	f5a4 78b0 	sub.w	r8, r4, #352	; 0x160
  10570c:	e794      	b.n	105638 <disp_post_config+0xec>
    switch (res_info->res_id) {
  10570e:	f244 021e 	movw	r2, #16414	; 0x401e
  105712:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105716:	4293      	cmp	r3, r2
  105718:	d01e      	beq.n	105758 <disp_post_config+0x20c>
  10571a:	f245 021f 	movw	r2, #20511	; 0x501f
  10571e:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105722:	4293      	cmp	r3, r2
  105724:	d132      	bne.n	10578c <disp_post_config+0x240>
    case RES_DC_DC5:
  105726:	4c2a      	ldr	r4, [pc, #168]	; (1057d0 <disp_post_config+0x284>)
  105728:	f44f 73ce 	mov.w	r3, #412	; 0x19c
        return 4;
  10572c:	f04f 0a04 	mov.w	r10, #4
  105730:	f5a4 78b0 	sub.w	r8, r4, #352	; 0x160
  105734:	e737      	b.n	1055a6 <disp_post_config+0x5a>
    switch (res_info->res_id) {
  105736:	f64e 2868 	movw	r8, #60008	; 0xea68
  10573a:	233c      	movs	r3, #60	; 0x3c
        return 0;
  10573c:	f04f 0a00 	mov.w	r10, #0
    switch (res_info->res_id) {
  105740:	f2c0 0812 	movt	r8, #18
  105744:	4644      	mov	r4, r8
  105746:	e72e      	b.n	1055a6 <disp_post_config+0x5a>
    case RES_DC_DC4:
  105748:	4c22      	ldr	r4, [pc, #136]	; (1057d4 <disp_post_config+0x288>)
  10574a:	f44f 79a2 	mov.w	r9, #324	; 0x144
        return 3;
  10574e:	f04f 0a03 	mov.w	r10, #3
  105752:	f5a4 7884 	sub.w	r8, r4, #264	; 0x108
  105756:	e76f      	b.n	105638 <disp_post_config+0xec>
    case RES_DC_DC4:
  105758:	4c1e      	ldr	r4, [pc, #120]	; (1057d4 <disp_post_config+0x288>)
  10575a:	f44f 73a2 	mov.w	r3, #324	; 0x144
        return 3;
  10575e:	f04f 0a03 	mov.w	r10, #3
  105762:	f5a4 7884 	sub.w	r8, r4, #264	; 0x108
  105766:	e71e      	b.n	1055a6 <disp_post_config+0x5a>
    switch (res_info->res_id) {
  105768:	f64e 2468 	movw	r4, #60008	; 0xea68
  10576c:	f04f 093c 	mov.w	r9, #60	; 0x3c
        return 0;
  105770:	f04f 0a00 	mov.w	r10, #0
    switch (res_info->res_id) {
  105774:	f2c0 0412 	movt	r4, #18
  105778:	46a0      	mov	r8, r4
  10577a:	e75d      	b.n	105638 <disp_post_config+0xec>
            mutex_release(&dev->mutex_refresh);
  10577c:	4648      	mov	r0, r9
  10577e:	f010 ff29 	bl	1165d4 <mutex_release>
  105782:	e793      	b.n	1056ac <disp_post_config+0x160>
            mutex_release(&dev->mutex_refresh);
  105784:	4640      	mov	r0, r8
  105786:	f010 ff25 	bl	1165d4 <mutex_release>
  10578a:	e732      	b.n	1055f2 <disp_post_config+0xa6>
    switch (res_info->res_id) {
  10578c:	4c12      	ldr	r4, [pc, #72]	; (1057d8 <disp_post_config+0x28c>)
  10578e:	f06f 031b 	mvn.w	r3, #27
        return -1;
  105792:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
  105796:	f104 0858 	add.w	r8, r4, #88	; 0x58
  10579a:	e704      	b.n	1055a6 <disp_post_config+0x5a>
    switch (res_info->res_id) {
  10579c:	4c0e      	ldr	r4, [pc, #56]	; (1057d8 <disp_post_config+0x28c>)
  10579e:	f06f 091b 	mvn.w	r9, #27
        return -1;
  1057a2:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
  1057a6:	f104 0858 	add.w	r8, r4, #88	; 0x58
  1057aa:	e745      	b.n	105638 <disp_post_config+0xec>
    case RES_DC_DC3:
  1057ac:	4c0b      	ldr	r4, [pc, #44]	; (1057dc <disp_post_config+0x290>)
  1057ae:	23ec      	movs	r3, #236	; 0xec
        return 2;
  1057b0:	f04f 0a02 	mov.w	r10, #2
  1057b4:	f1a4 08b0 	sub.w	r8, r4, #176	; 0xb0
  1057b8:	e6f5      	b.n	1055a6 <disp_post_config+0x5a>
    case RES_DC_DC3:
  1057ba:	4c08      	ldr	r4, [pc, #32]	; (1057dc <disp_post_config+0x290>)
  1057bc:	f04f 09ec 	mov.w	r9, #236	; 0xec
        return 2;
  1057c0:	f04f 0a02 	mov.w	r10, #2
  1057c4:	f1a4 08b0 	sub.w	r8, r4, #176	; 0xb0
  1057c8:	e736      	b.n	105638 <disp_post_config+0xec>
  1057ca:	bf00      	nop
  1057cc:	0012eac0 	.word	0x0012eac0
  1057d0:	0012ebc8 	.word	0x0012ebc8
  1057d4:	0012eb70 	.word	0x0012eb70
  1057d8:	0012ea10 	.word	0x0012ea10
  1057dc:	0012eb18 	.word	0x0012eb18

001057e0 <disp_panel_connect>:

bool disp_panel_connect(display_handle *handle, int sub_id,
         struct sdm_panel *panel)
{
  1057e0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  1057e2:	4607      	mov	r7, r0
    int ret;
    int if_type;
    struct intf_device *dev = NULL;

    dprintf(0, "[disp] We will check lcm: %s\n", panel->panel_name);
  1057e4:	f648 0078 	movw	r0, #34936	; 0x8878
  1057e8:	6811      	ldr	r1, [r2, #0]
  1057ea:	f2c0 0011 	movt	r0, #17
{
  1057ee:	4615      	mov	r5, r2
    dprintf(0, "[disp] We will check lcm: %s\n", panel->panel_name);
  1057f0:	f00f f808 	bl	114804 <printf>
    dc_res = &handle->dm->dc[0];
  1057f4:	68fb      	ldr	r3, [r7, #12]
    switch (res_info->res_id) {
  1057f6:	f243 021d 	movw	r2, #12317	; 0x301d
  1057fa:	f2c4 3256 	movt	r2, #17238	; 0x4356
    dc_id = get_dc_index(dc_res);
  1057fe:	68db      	ldr	r3, [r3, #12]
    switch (res_info->res_id) {
  105800:	681b      	ldr	r3, [r3, #0]
  105802:	4293      	cmp	r3, r2
  105804:	f000 8083 	beq.w	10590e <disp_panel_connect+0x12e>
  105808:	d845      	bhi.n	105896 <disp_panel_connect+0xb6>
  10580a:	f241 021b 	movw	r2, #4123	; 0x101b
  10580e:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105812:	4293      	cmp	r3, r2
  105814:	f000 8087 	beq.w	105926 <disp_panel_connect+0x146>
  105818:	f242 021c 	movw	r2, #8220	; 0x201c
  10581c:	f2c4 3256 	movt	r2, #17238	; 0x4356
  105820:	4293      	cmp	r3, r2
  105822:	d14a      	bne.n	1058ba <disp_panel_connect+0xda>
  105824:	4e4d      	ldr	r6, [pc, #308]	; (10595c <disp_panel_connect+0x17c>)
        return 1;
  105826:	f04f 0c01 	mov.w	r12, #1
  10582a:	f1a6 031c 	sub.w	r3, r6, #28
    intf_dev[dc_id].intf_res = handle->res->if_res;
  10582e:	68ba      	ldr	r2, [r7, #8]
    intf_dev[dc_id].display_id = handle->display_id;
  105830:	ea4f 01cc 	mov.w	r1, r12, lsl #3
  105834:	683f      	ldr	r7, [r7, #0]
  105836:	eba1 040c 	sub.w	r4, r1, r12
  10583a:	ed92 6a27 	vldr	s12, [r2, #156]	; 0x9c
  10583e:	00a4      	lsls	r4, r4, #2
  105840:	1918      	adds	r0, r3, r4
  105842:	511f      	str	r7, [r3, r4]
    intf_dev[dc_id].lvds_cmb = handle->res->lvds_cmb;
  105844:	e9d2 4724 	ldrd	r4, r7, [r2, #144]	; 0x90
  105848:	6084      	str	r4, [r0, #8]
    intf_dev[dc_id].pixel_bpp = handle->res->pixel_bpp;
  10584a:	f8d2 4098 	ldr.w	r4, [r2, #152]	; 0x98
    if (lvds_mode == LVDS_MODE_DUAL)
  10584e:	2f02      	cmp	r7, #2
    intf_dev[dc_id].intf_res = handle->res->if_res;
  105850:	f8d2 208c 	ldr.w	r2, [r2, #140]	; 0x8c
    intf_dev[dc_id].pixel_bpp = handle->res->pixel_bpp;
  105854:	6104      	str	r4, [r0, #16]
    intf_dev[dc_id].intf_res = handle->res->if_res;
  105856:	6042      	str	r2, [r0, #4]
    intf_dev[dc_id].lvds_mode = handle->res->lvds_mode;
  105858:	60c7      	str	r7, [r0, #12]
  10585a:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
    if (lvds_mode == LVDS_MODE_DUAL)
  10585e:	d032      	beq.n	1058c6 <disp_panel_connect+0xe6>
    return clk / 7.0;
  105860:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
  105864:	ee86 7b05 	vdiv.f64	d7, d6, d5
  105868:	eebd 7bc7 	vcvt.s32.f64	s14, d7
    intf_dev[dc_id].tcon_clk = get_dsp_clk(handle->res->clk, handle->res->lvds_mode);
  10586c:	eba1 010c 	sub.w	r1, r1, r12
  105870:	2a0a      	cmp	r2, #10
  105872:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  105876:	ed83 7a06 	vstr	s14, [r3, #24]
  10587a:	bf97      	itett	ls
  10587c:	f648 0334 	movwls	r3, #34868	; 0x8834
  105880:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
  105884:	f2c0 0311 	movtls	r3, #17
  105888:	f853 3022 	ldrls.w	r3, [r3, r2, lsl #2]
    if (dev->display_id == 2)
        dev->intf_res = IF_RES_PARALLEL;
#endif
    /*check if type*/
    if_type = get_if_type_by_res(dev->intf_res);
    if (panel->if_type != if_type) {
  10588c:	686a      	ldr	r2, [r5, #4]
  10588e:	429a      	cmp	r2, r3
  105890:	d020      	beq.n	1058d4 <disp_panel_connect+0xf4>
    }

    ret = panel_init(dev, panel);
    if (ret < 0) {
        DISPERR("panel init failed\n");
        return false;
  105892:	2000      	movs	r0, #0
    }

    return true;
}
  105894:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    switch (res_info->res_id) {
  105896:	f244 021e 	movw	r2, #16414	; 0x401e
  10589a:	f2c4 3256 	movt	r2, #17238	; 0x4356
  10589e:	4293      	cmp	r3, r2
  1058a0:	d03b      	beq.n	10591a <disp_panel_connect+0x13a>
  1058a2:	f245 021f 	movw	r2, #20511	; 0x501f
  1058a6:	f2c4 3256 	movt	r2, #17238	; 0x4356
  1058aa:	4293      	cmp	r3, r2
  1058ac:	d105      	bne.n	1058ba <disp_panel_connect+0xda>
    case RES_DC_DC5:
  1058ae:	4e2c      	ldr	r6, [pc, #176]	; (105960 <disp_panel_connect+0x180>)
        return 4;
  1058b0:	f04f 0c04 	mov.w	r12, #4
  1058b4:	f1a6 0370 	sub.w	r3, r6, #112	; 0x70
  1058b8:	e7b9      	b.n	10582e <disp_panel_connect+0x4e>
    switch (res_info->res_id) {
  1058ba:	4e2a      	ldr	r6, [pc, #168]	; (105964 <disp_panel_connect+0x184>)
        return -1;
  1058bc:	f04f 3cff 	mov.w	r12, #4294967295	; 0xffffffff
  1058c0:	f106 031c 	add.w	r3, r6, #28
  1058c4:	e7b3      	b.n	10582e <disp_panel_connect+0x4e>
        return clk / 3.5;
  1058c6:	eeb0 5b0c 	vmov.f64	d5, #12	; 0x40600000  3.5
  1058ca:	ee86 7b05 	vdiv.f64	d7, d6, d5
  1058ce:	eebd 7bc7 	vcvt.s32.f64	s14, d7
  1058d2:	e7cb      	b.n	10586c <disp_panel_connect+0x8c>
  1058d4:	3b01      	subs	r3, #1
  1058d6:	2b05      	cmp	r3, #5
  1058d8:	d833      	bhi.n	105942 <disp_panel_connect+0x162>
  1058da:	f648 0260 	movw	r2, #34912	; 0x8860
    disp_interface_init(if_module, dev);
  1058de:	4631      	mov	r1, r6
  1058e0:	f2c0 0211 	movt	r2, #17
  1058e4:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
  1058e8:	4620      	mov	r0, r4
  1058ea:	f000 f841 	bl	105970 <disp_interface_init>
    disp_interface_config(if_module, dev, panel);
  1058ee:	462a      	mov	r2, r5
  1058f0:	4631      	mov	r1, r6
  1058f2:	4620      	mov	r0, r4
  1058f4:	f000 f84e 	bl	105994 <disp_interface_config>
    if (ret < 0) {
  1058f8:	2c00      	cmp	r4, #0
  1058fa:	dbca      	blt.n	105892 <disp_panel_connect+0xb2>
    switch (panel->if_type) {
  1058fc:	686c      	ldr	r4, [r5, #4]
  1058fe:	2c01      	cmp	r4, #1
  105900:	d019      	beq.n	105936 <disp_panel_connect+0x156>
  105902:	dbc6      	blt.n	105892 <disp_panel_connect+0xb2>
  105904:	2c06      	cmp	r4, #6
    return true;
  105906:	bfd8      	it	le
  105908:	2001      	movle	r0, #1
    switch (panel->if_type) {
  10590a:	dcc2      	bgt.n	105892 <disp_panel_connect+0xb2>
}
  10590c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    case RES_DC_DC3:
  10590e:	4e16      	ldr	r6, [pc, #88]	; (105968 <disp_panel_connect+0x188>)
        return 2;
  105910:	f04f 0c02 	mov.w	r12, #2
  105914:	f1a6 0338 	sub.w	r3, r6, #56	; 0x38
  105918:	e789      	b.n	10582e <disp_panel_connect+0x4e>
    case RES_DC_DC4:
  10591a:	4e14      	ldr	r6, [pc, #80]	; (10596c <disp_panel_connect+0x18c>)
        return 3;
  10591c:	f04f 0c03 	mov.w	r12, #3
  105920:	f1a6 0354 	sub.w	r3, r6, #84	; 0x54
  105924:	e783      	b.n	10582e <disp_panel_connect+0x4e>
    switch (res_info->res_id) {
  105926:	f64e 4320 	movw	r3, #60448	; 0xec20
        return 0;
  10592a:	f04f 0c00 	mov.w	r12, #0
    switch (res_info->res_id) {
  10592e:	f2c0 0312 	movt	r3, #18
  105932:	461e      	mov	r6, r3
  105934:	e77b      	b.n	10582e <disp_panel_connect+0x4e>
        mipi_lcm_init(dev->dsi_index, panel);
  105936:	6970      	ldr	r0, [r6, #20]
  105938:	4629      	mov	r1, r5
  10593a:	f000 f83f 	bl	1059bc <mipi_lcm_init>
    return true;
  10593e:	4620      	mov	r0, r4
}
  105940:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    disp_interface_init(if_module, dev);
  105942:	4631      	mov	r1, r6
  105944:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  105948:	f000 f812 	bl	105970 <disp_interface_init>
    disp_interface_config(if_module, dev, panel);
  10594c:	462a      	mov	r2, r5
  10594e:	4631      	mov	r1, r6
  105950:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  105954:	f000 f81e 	bl	105994 <disp_interface_config>
        return false;
  105958:	2000      	movs	r0, #0
}
  10595a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  10595c:	0012ec3c 	.word	0x0012ec3c
  105960:	0012ec90 	.word	0x0012ec90
  105964:	0012ec04 	.word	0x0012ec04
  105968:	0012ec58 	.word	0x0012ec58
  10596c:	0012ec74 	.word	0x0012ec74

00105970 <disp_interface_init>:
}

int disp_interface_init(DISP_IF_MODULE_ENUM module,
        struct intf_device *dev)
{
    if (module == DISP_IF_MODULE_UNKNOWN) {
  105970:	1c42      	adds	r2, r0, #1
  105972:	d00e      	beq.n	105992 <disp_interface_init+0x22>
{
  105974:	b508      	push	{r3, r14}
        DISPERR("init module is unknown\n");
        return -1;
    }

    if (if_module_driver[module]->init != 0) {
  105976:	f648 0398 	movw	r3, #34968	; 0x8898
  10597a:	f2c0 0311 	movt	r3, #17
  10597e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  105982:	685b      	ldr	r3, [r3, #4]
  105984:	b11b      	cbz	r3, 10598e <disp_interface_init+0x1e>
  105986:	4608      	mov	r0, r1
        DISPMSG("init module %s\n", disp_get_module_name(module));
        if_module_driver[module]->init(dev);
  105988:	4798      	blx	r3
    }

    return 0;
  10598a:	2000      	movs	r0, #0
}
  10598c:	bd08      	pop	{r3, r15}
    return 0;
  10598e:	4618      	mov	r0, r3
}
  105990:	bd08      	pop	{r3, r15}
  105992:	4770      	bx	r14

00105994 <disp_interface_config>:
}

int disp_interface_config(DISP_IF_MODULE_ENUM module,
        struct intf_device *dev, struct sdm_panel *panel)
{
    if (module == DISP_IF_MODULE_UNKNOWN) {
  105994:	1c43      	adds	r3, r0, #1
  105996:	d00e      	beq.n	1059b6 <disp_interface_config+0x22>
        DISPERR("config module is unknown\n");
        return -1;
    }

    if (if_module_driver[module]->config != 0) {
  105998:	f648 0398 	movw	r3, #34968	; 0x8898
  10599c:	f2c0 0311 	movt	r3, #17
  1059a0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  1059a4:	68db      	ldr	r3, [r3, #12]
  1059a6:	b13b      	cbz	r3, 1059b8 <disp_interface_config+0x24>
{
  1059a8:	b510      	push	{r4, r14}
  1059aa:	460c      	mov	r4, r1
  1059ac:	4611      	mov	r1, r2
  1059ae:	4620      	mov	r0, r4
        DISPMSG("config module %s\n", disp_get_module_name(module));
        if_module_driver[module]->config(dev, panel);
  1059b0:	4798      	blx	r3
    }

    return 0;
  1059b2:	2000      	movs	r0, #0
}
  1059b4:	bd10      	pop	{r4, r15}
  1059b6:	4770      	bx	r14
    return 0;
  1059b8:	4618      	mov	r0, r3
  1059ba:	4770      	bx	r14

001059bc <mipi_lcm_init>:
{
    return 0
}*/

int mipi_lcm_init(int dsi_index, struct sdm_panel *panel)
{
  1059bc:	b538      	push	{r3, r4, r5, r14}
    struct dsi_cmd_desc *cmds = panel->mipi->init_data;
  1059be:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    struct dsi_context *ctx = &dsi_ctx[dsi_index];
  1059c0:	f64e 1468 	movw	r4, #59752	; 0xe968
  1059c4:	f2c0 0412 	movt	r4, #18
  1059c8:	eb04 14c0 	add.w	r4, r4, r0, lsl #7
    uint32_t i;

    if (ctx == NULL)
        return -1;

    if (cmds == NULL)
  1059cc:	691b      	ldr	r3, [r3, #16]
    struct dsi_core_ops *dsi_ops = ctx->ops;
  1059ce:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
    if (cmds == NULL)
  1059d0:	b113      	cbz	r3, 1059d8 <mipi_lcm_init+0x1c>
        goto skip_send_cmd;

    dsi_ops->cmd_mode(ctx);
  1059d2:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  1059d4:	4620      	mov	r0, r4
  1059d6:	4798      	blx	r3

        cmds++;
    }

skip_send_cmd:
    dsi_ops->dphy_enable_hs_clk(ctx, 1);
  1059d8:	f8d5 31f4 	ldr.w	r3, [r5, #500]	; 0x1f4
  1059dc:	4620      	mov	r0, r4
  1059de:	2101      	movs	r1, #1
  1059e0:	4798      	blx	r3

    dsi_ops->power_enable(ctx, 0);
  1059e2:	686b      	ldr	r3, [r5, #4]
  1059e4:	2100      	movs	r1, #0
  1059e6:	4620      	mov	r0, r4
  1059e8:	4798      	blx	r3
    udelay(100);
  1059ea:	2064      	movs	r0, #100	; 0x64
  1059ec:	f00d fec4 	bl	113778 <spin>
    dsi_ops->power_enable(ctx, 1);
  1059f0:	686b      	ldr	r3, [r5, #4]
  1059f2:	2101      	movs	r1, #1
  1059f4:	4620      	mov	r0, r4
  1059f6:	4798      	blx	r3
    udelay(10*1000);
  1059f8:	f242 7010 	movw	r0, #10000	; 0x2710
  1059fc:	f00d febc 	bl	113778 <spin>

    dsi_ops->video_mode(ctx);
  105a00:	6e2b      	ldr	r3, [r5, #96]	; 0x60
  105a02:	4620      	mov	r0, r4
  105a04:	4798      	blx	r3
    //dsi_ops->int0_status(ctx);
    //dsi_ops->int1_status(ctx);

    return 0;
}
  105a06:	2000      	movs	r0, #0
  105a08:	bd38      	pop	{r3, r4, r5, r15}
  105a0a:	bf00      	nop

00105a0c <dc_triggle>:
  105a0c:	f64e 41b4 	movw	r1, #60596	; 0xecb4
  105a10:	b4f0      	push	{r4, r5, r6, r7}
  105a12:	6845      	ldr	r5, [r0, #4]
  105a14:	f2c0 0112 	movt	r1, #18
  105a18:	6a04      	ldr	r4, [r0, #32]
  105a1a:	f851 2025 	ldr.w	r2, [r1, r5, lsl #2]
  105a1e:	0793      	lsls	r3, r2, #30
  105a20:	bf42      	ittt	mi
  105a22:	2601      	movmi	r6, #1
  105a24:	f504 43be 	addmi.w	r3, r4, #24320	; 0x5f00
  105a28:	601e      	strmi	r6, [r3, #0]
  105a2a:	07d7      	lsls	r7, r2, #31
  105a2c:	bf42      	ittt	mi
  105a2e:	2601      	movmi	r6, #1
  105a30:	f504 533c 	addmi.w	r3, r4, #12032	; 0x2f00
  105a34:	601e      	strmi	r6, [r3, #0]
  105a36:	f012 03f0 	ands.w	r3, r2, #240	; 0xf0
  105a3a:	bf18      	it	ne
  105a3c:	2302      	movne	r3, #2
  105a3e:	0516      	lsls	r6, r2, #20
  105a40:	f04f 0600 	mov.w	r6, #0
  105a44:	bf48      	it	mi
  105a46:	f083 0308 	eormi.w	r3, r3, #8
  105a4a:	0712      	lsls	r2, r2, #28
  105a4c:	f64e 42c8 	movw	r2, #60616	; 0xecc8
  105a50:	bf48      	it	mi
  105a52:	f083 0304 	eormi.w	r3, r3, #4
  105a56:	f083 0701 	eor.w	r7, r3, #1
  105a5a:	6063      	str	r3, [r4, #4]
  105a5c:	f2c0 0212 	movt	r2, #18
  105a60:	6067      	str	r7, [r4, #4]
  105a62:	f841 6025 	str.w	r6, [r1, r5, lsl #2]
  105a66:	6843      	ldr	r3, [r0, #4]
  105a68:	5cd1      	ldrb	r1, [r2, r3]
  105a6a:	b911      	cbnz	r1, 105a72 <dc_triggle+0x66>
  105a6c:	2101      	movs	r1, #1
  105a6e:	54d1      	strb	r1, [r2, r3]
  105a70:	60a1      	str	r1, [r4, #8]
  105a72:	bcf0      	pop	{r4, r5, r6, r7}
  105a74:	4770      	bx	r14
  105a76:	bf00      	nop

00105a78 <dc_check_triggle_status>:
  105a78:	6a03      	ldr	r3, [r0, #32]
  105a7a:	6858      	ldr	r0, [r3, #4]
  105a7c:	f000 0001 	and.w	r0, r0, #1
  105a80:	4770      	bx	r14
  105a82:	bf00      	nop

00105a84 <set_tcon_ctrl_en>:
  105a84:	6a02      	ldr	r2, [r0, #32]
  105a86:	f249 0110 	movw	r1, #36880	; 0x9010
  105a8a:	5888      	ldr	r0, [r1, r2]
  105a8c:	43c3      	mvns	r3, r0
  105a8e:	f003 0301 	and.w	r3, r3, #1
  105a92:	4043      	eors	r3, r0
  105a94:	508b      	str	r3, [r1, r2]
  105a96:	4770      	bx	r14

00105a98 <dc_reset>:
  105a98:	6a02      	ldr	r2, [r0, #32]
  105a9a:	2000      	movs	r0, #0
  105a9c:	6811      	ldr	r1, [r2, #0]
  105a9e:	43cb      	mvns	r3, r1
  105aa0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
  105aa4:	404b      	eors	r3, r1
  105aa6:	6013      	str	r3, [r2, #0]
  105aa8:	4770      	bx	r14
  105aaa:	bf00      	nop

00105aac <dc_clear_layers>:
  105aac:	b4f0      	push	{r4, r5, r6, r7}
  105aae:	6984      	ldr	r4, [r0, #24]
  105ab0:	6a03      	ldr	r3, [r0, #32]
  105ab2:	07a4      	lsls	r4, r4, #30
  105ab4:	bf4c      	ite	mi
  105ab6:	3203      	addmi	r2, #3
  105ab8:	3202      	addpl	r2, #2
  105aba:	2902      	cmp	r1, #2
  105abc:	b2d2      	uxtb	r2, r2
  105abe:	d062      	beq.n	105b86 <dc_clear_layers+0xda>
  105ac0:	2903      	cmp	r1, #3
  105ac2:	d028      	beq.n	105b16 <dc_clear_layers+0x6a>
  105ac4:	2901      	cmp	r1, #1
  105ac6:	d001      	beq.n	105acc <dc_clear_layers+0x20>
  105ac8:	bcf0      	pop	{r4, r5, r6, r7}
  105aca:	4770      	bx	r14
  105acc:	f247 2604 	movw	r6, #29188	; 0x7204
  105ad0:	f503 47e0 	add.w	r7, r3, #28672	; 0x7000
  105ad4:	f64e 41b4 	movw	r1, #60596	; 0xecb4
  105ad8:	f502 55e4 	add.w	r5, r2, #7296	; 0x1c80
  105adc:	f2c0 0112 	movt	r1, #18
  105ae0:	683c      	ldr	r4, [r7, #0]
  105ae2:	f024 0401 	bic.w	r4, r4, #1
  105ae6:	603c      	str	r4, [r7, #0]
  105ae8:	599c      	ldr	r4, [r3, r6]
  105aea:	4062      	eors	r2, r4
  105aec:	f002 020f 	and.w	r2, r2, #15
  105af0:	4062      	eors	r2, r4
  105af2:	519a      	str	r2, [r3, r6]
  105af4:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
  105af8:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  105afc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  105b00:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  105b04:	6842      	ldr	r2, [r0, #4]
  105b06:	bcf0      	pop	{r4, r5, r6, r7}
  105b08:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  105b0c:	f043 0312 	orr.w	r3, r3, #18
  105b10:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  105b14:	4770      	bx	r14
  105b16:	f247 0730 	movw	r7, #28720	; 0x7030
  105b1a:	f503 42e0 	add.w	r2, r3, #28672	; 0x7000
  105b1e:	f247 240c 	movw	r4, #29196	; 0x720c
  105b22:	f247 2508 	movw	r5, #29192	; 0x7208
  105b26:	f247 2604 	movw	r6, #29188	; 0x7204
  105b2a:	6811      	ldr	r1, [r2, #0]
  105b2c:	f021 0101 	bic.w	r1, r1, #1
  105b30:	6011      	str	r1, [r2, #0]
  105b32:	59da      	ldr	r2, [r3, r7]
  105b34:	f022 0201 	bic.w	r2, r2, #1
  105b38:	51da      	str	r2, [r3, r7]
  105b3a:	6982      	ldr	r2, [r0, #24]
  105b3c:	0792      	lsls	r2, r2, #30
  105b3e:	d447      	bmi.n	105bd0 <dc_clear_layers+0x124>
  105b40:	5999      	ldr	r1, [r3, r6]
  105b42:	43ca      	mvns	r2, r1
  105b44:	f002 020f 	and.w	r2, r2, #15
  105b48:	404a      	eors	r2, r1
  105b4a:	519a      	str	r2, [r3, r6]
  105b4c:	5959      	ldr	r1, [r3, r5]
  105b4e:	43ca      	mvns	r2, r1
  105b50:	f002 020f 	and.w	r2, r2, #15
  105b54:	404a      	eors	r2, r1
  105b56:	43d1      	mvns	r1, r2
  105b58:	f401 2170 	and.w	r1, r1, #983040	; 0xf0000
  105b5c:	404a      	eors	r2, r1
  105b5e:	515a      	str	r2, [r3, r5]
  105b60:	5919      	ldr	r1, [r3, r4]
  105b62:	43ca      	mvns	r2, r1
  105b64:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  105b68:	404a      	eors	r2, r1
  105b6a:	511a      	str	r2, [r3, r4]
  105b6c:	6841      	ldr	r1, [r0, #4]
  105b6e:	f64e 43b4 	movw	r3, #60596	; 0xecb4
  105b72:	f2c0 0312 	movt	r3, #18
  105b76:	bcf0      	pop	{r4, r5, r6, r7}
  105b78:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
  105b7c:	f042 0213 	orr.w	r2, r2, #19
  105b80:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
  105b84:	4770      	bx	r14
  105b86:	f247 0730 	movw	r7, #28720	; 0x7030
  105b8a:	f247 2608 	movw	r6, #29192	; 0x7208
  105b8e:	f64e 41b4 	movw	r1, #60596	; 0xecb4
  105b92:	f502 55e4 	add.w	r5, r2, #7296	; 0x1c80
  105b96:	f2c0 0112 	movt	r1, #18
  105b9a:	59dc      	ldr	r4, [r3, r7]
  105b9c:	f024 0401 	bic.w	r4, r4, #1
  105ba0:	51dc      	str	r4, [r3, r7]
  105ba2:	599c      	ldr	r4, [r3, r6]
  105ba4:	4062      	eors	r2, r4
  105ba6:	f002 020f 	and.w	r2, r2, #15
  105baa:	4062      	eors	r2, r4
  105bac:	519a      	str	r2, [r3, r6]
  105bae:	f853 2025 	ldr.w	r2, [r3, r5, lsl #2]
  105bb2:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  105bb6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  105bba:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
  105bbe:	6842      	ldr	r2, [r0, #4]
  105bc0:	bcf0      	pop	{r4, r5, r6, r7}
  105bc2:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  105bc6:	f043 0311 	orr.w	r3, r3, #17
  105bca:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  105bce:	4770      	bx	r14
  105bd0:	599f      	ldr	r7, [r3, r6]
  105bd2:	f247 2110 	movw	r1, #29200	; 0x7210
  105bd6:	43fa      	mvns	r2, r7
  105bd8:	f002 020f 	and.w	r2, r2, #15
  105bdc:	407a      	eors	r2, r7
  105bde:	519a      	str	r2, [r3, r6]
  105be0:	595e      	ldr	r6, [r3, r5]
  105be2:	43f2      	mvns	r2, r6
  105be4:	f002 020f 	and.w	r2, r2, #15
  105be8:	4072      	eors	r2, r6
  105bea:	515a      	str	r2, [r3, r5]
  105bec:	591d      	ldr	r5, [r3, r4]
  105bee:	43ea      	mvns	r2, r5
  105bf0:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  105bf4:	406a      	eors	r2, r5
  105bf6:	511a      	str	r2, [r3, r4]
  105bf8:	585c      	ldr	r4, [r3, r1]
  105bfa:	43e2      	mvns	r2, r4
  105bfc:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  105c00:	4062      	eors	r2, r4
  105c02:	505a      	str	r2, [r3, r1]
  105c04:	e7b2      	b.n	105b6c <dc_clear_layers+0xc0>
  105c06:	bf00      	nop

00105c08 <dc_vsync_enable>:
  105c08:	6a03      	ldr	r3, [r0, #32]
  105c0a:	f081 0101 	eor.w	r1, r1, #1
  105c0e:	6a1a      	ldr	r2, [r3, #32]
  105c10:	ea82 01c1 	eor.w	r1, r2, r1, lsl #3
  105c14:	f001 0108 	and.w	r1, r1, #8
  105c18:	4051      	eors	r1, r2
  105c1a:	6219      	str	r1, [r3, #32]
  105c1c:	4770      	bx	r14
  105c1e:	bf00      	nop

00105c20 <dc_csc_set>:
  105c20:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  105c24:	ed2d 8b10 	vpush	{d8-d15}
  105c28:	4603      	mov	r3, r0
  105c2a:	460c      	mov	r4, r1
  105c2c:	2224      	movs	r2, #36	; 0x24
  105c2e:	2100      	movs	r1, #0
  105c30:	ed9f bacf 	vldr	s22, [r15, #828]	; 105f70 <dc_csc_set+0x350>
  105c34:	f648 09a4 	movw	r9, #34980	; 0x88a4
  105c38:	6a1b      	ldr	r3, [r3, #32]
  105c3a:	f2c0 0911 	movt	r9, #17
  105c3e:	ed9f cbb0 	vldr	d12, [r15, #704]	; 105f00 <dc_csc_set+0x2e0>
  105c42:	ed9f 9bb1 	vldr	d9, [r15, #708]	; 105f08 <dc_csc_set+0x2e8>
  105c46:	ed9f ebb2 	vldr	d14, [r15, #712]	; 105f10 <dc_csc_set+0x2f0>
  105c4a:	ed9f aaca 	vldr	s20, [r15, #808]	; 105f74 <dc_csc_set+0x354>
  105c4e:	b0a5      	sub	sp, #148	; 0x94
  105c50:	ed9f dbb1 	vldr	d13, [r15, #708]	; 105f18 <dc_csc_set+0x2f8>
  105c54:	9007      	str	r0, [sp, #28]
  105c56:	a81b      	add	r0, sp, #108	; 0x6c
  105c58:	9306      	str	r3, [sp, #24]
  105c5a:	f00d eea8 	blx	1139ac <memset>
  105c5e:	edd4 4a03 	vldr	s9, [r4, #12]
  105c62:	2300      	movs	r3, #0
  105c64:	eddf 7ac4 	vldr	s15, [r15, #784]	; 105f78 <dc_csc_set+0x358>
  105c68:	f10d 0a30 	add.w	r10, r13, #48	; 0x30
  105c6c:	ed9f 7ac3 	vldr	s14, [r15, #780]	; 105f7c <dc_csc_set+0x35c>
  105c70:	ee24 ba8b 	vmul.f32	s22, s9, s22
  105c74:	ee74 7aa7 	vadd.f32	s15, s9, s15
  105c78:	f10d 0b3c 	add.w	r11, r13, #60	; 0x3c
  105c7c:	eddf 6ac0 	vldr	s13, [r15, #768]	; 105f80 <dc_csc_set+0x360>
  105c80:	f10d 084c 	add.w	r8, r13, #76	; 0x4c
  105c84:	ed9f 3ba6 	vldr	d3, [r15, #664]	; 105f20 <dc_csc_set+0x300>
  105c88:	eef4 7ac7 	vcmpe.f32	s15, s14
  105c8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  105c90:	bfc8      	it	gt
  105c92:	ed9f 7abc 	vldrgt	s14, [r15, #752]	; 105f84 <dc_csc_set+0x364>
  105c96:	f04f 0700 	mov.w	r7, #0
  105c9a:	ed9f 0ba3 	vldr	d0, [r15, #652]	; 105f28 <dc_csc_set+0x308>
  105c9e:	ed94 6a02 	vldr	s12, [r4, #8]
  105ca2:	bfc8      	it	gt
  105ca4:	ee77 7ac7 	vsubgt.f32	s15, s15, s14
  105ca8:	ed9f 7ab1 	vldr	s14, [r15, #708]	; 105f70 <dc_csc_set+0x350>
  105cac:	ed9f 5b9a 	vldr	d5, [r15, #616]	; 105f18 <dc_csc_set+0x2f8>
  105cb0:	ee67 6aa6 	vmul.f32	s13, s15, s13
  105cb4:	ee27 7a87 	vmul.f32	s14, s15, s14
  105cb8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  105cbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  105cc0:	bf48      	it	mi
  105cc2:	eef1 7a67 	vnegmi.f32	s15, s15
  105cc6:	ed9f 2b9a 	vldr	d2, [r15, #616]	; 105f30 <dc_csc_set+0x310>
  105cca:	f8ca 3004 	str.w	r3, [r10, #4]
  105cce:	ee06 7aa7 	vmla.f32	s14, s13, s15
  105cd2:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
  105cd6:	930c      	str	r3, [sp, #48]	; 0x30
  105cd8:	f8ca 3008 	str.w	r3, [r10, #8]
  105cdc:	eeb0 4a47 	vmov.f32	s8, s14
  105ce0:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
  105ce4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  105ce8:	bf4c      	ite	mi
  105cea:	eef1 7a47 	vnegmi.f32	s15, s14
  105cee:	eef0 7a47 	vmovpl.f32	s15, s14
  105cf2:	eef5 4ac0 	vcmpe.f32	s9, #0.0
  105cf6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  105cfa:	930f      	str	r3, [sp, #60]	; 0x3c
  105cfc:	ee17 4a27 	vnmls.f32	s8, s14, s15
  105d00:	eddf 7a9c 	vldr	s15, [r15, #624]	; 105f74 <dc_csc_set+0x354>
  105d04:	e9cb 3301 	strd	r3, r3, [r11, #4]
  105d08:	ab1b      	add	r3, sp, #108	; 0x6c
  105d0a:	9305      	str	r3, [sp, #20]
  105d0c:	ee04 7a27 	vmla.f32	s14, s8, s15
  105d10:	ed9f 4a9b 	vldr	s8, [r15, #620]	; 105f80 <dc_csc_set+0x360>
  105d14:	ee24 4a84 	vmul.f32	s8, s9, s8
  105d18:	bf48      	it	mi
  105d1a:	eef1 4a64 	vnegmi.f32	s9, s9
  105d1e:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
  105d22:	ee04 ba24 	vmla.f32	s22, s8, s9
  105d26:	eeb0 4b4c 	vmov.f64	d4, d12
  105d2a:	eef0 aa4b 	vmov.f32	s21, s22
  105d2e:	eeb5 bac0 	vcmpe.f32	s22, #0.0
  105d32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  105d36:	bf4c      	ite	mi
  105d38:	eeb1 8a4b 	vnegmi.f32	s16, s22
  105d3c:	eeb0 8a4b 	vmovpl.f32	s16, s22
  105d40:	ee27 3b03 	vmul.f64	d3, d7, d3
  105d44:	ee5b aa08 	vnmls.f32	s21, s22, s16
  105d48:	ee27 1b09 	vmul.f64	d1, d7, d9
  105d4c:	ee27 8b0c 	vmul.f64	d8, d7, d12
  105d50:	ee27 0b00 	vmul.f64	d0, d7, d0
  105d54:	ee0a ba8a 	vmla.f32	s22, s21, s20
  105d58:	ee03 5b06 	vmla.f64	d5, d3, d6
  105d5c:	eeb7 bacb 	vcvt.f64.f32	d11, s22
  105d60:	ee27 ab0e 	vmul.f64	d10, d7, d14
  105d64:	ee08 4b46 	vmls.f64	d4, d8, d6
  105d68:	ee00 cb06 	vmla.f64	d12, d0, d6
  105d6c:	eeb0 0b4e 	vmov.f64	d0, d14
  105d70:	ee01 eb06 	vmla.f64	d14, d1, d6
  105d74:	ed9f 1b70 	vldr	d1, [r15, #448]	; 105f38 <dc_csc_set+0x318>
  105d78:	ed9f 3b71 	vldr	d3, [r15, #452]	; 105f40 <dc_csc_set+0x320>
  105d7c:	ee0a 0b46 	vmls.f64	d0, d10, d6
  105d80:	ee2b 1b01 	vmul.f64	d1, d11, d1
  105d84:	ee27 3b03 	vmul.f64	d3, d7, d3
  105d88:	eeb0 ab4d 	vmov.f64	d10, d13
  105d8c:	eeb0 8b44 	vmov.f64	d8, d4
  105d90:	ed9f 4b6d 	vldr	d4, [r15, #436]	; 105f48 <dc_csc_set+0x328>
  105d94:	ee27 7b0d 	vmul.f64	d7, d7, d13
  105d98:	ee01 5b06 	vmla.f64	d5, d1, d6
  105d9c:	ee03 ab46 	vmls.f64	d10, d3, d6
  105da0:	ed9f 3b6b 	vldr	d3, [r15, #428]	; 105f50 <dc_csc_set+0x330>
  105da4:	ee2b 4b04 	vmul.f64	d4, d11, d4
  105da8:	ee07 db46 	vmls.f64	d13, d7, d6
  105dac:	ee2b 3b03 	vmul.f64	d3, d11, d3
  105db0:	ee04 cb46 	vmls.f64	d12, d4, d6
  105db4:	eeb0 1b45 	vmov.f64	d1, d5
  105db8:	eeb0 fb48 	vmov.f64	d15, d8
  105dbc:	ed9f 4b66 	vldr	d4, [r15, #408]	; 105f58 <dc_csc_set+0x338>
  105dc0:	ee03 8b46 	vmls.f64	d8, d3, d6
  105dc4:	ed9f 7b56 	vldr	d7, [r15, #344]	; 105f20 <dc_csc_set+0x300>
  105dc8:	ed9f 5b65 	vldr	d5, [r15, #404]	; 105f60 <dc_csc_set+0x340>
  105dcc:	ed9f 3b66 	vldr	d3, [r15, #408]	; 105f68 <dc_csc_set+0x348>
  105dd0:	ee2b 2b02 	vmul.f64	d2, d11, d2
  105dd4:	ee2b 9b09 	vmul.f64	d9, d11, d9
  105dd8:	ee2b 7b07 	vmul.f64	d7, d11, d7
  105ddc:	ee2b 5b05 	vmul.f64	d5, d11, d5
  105de0:	ee2b 3b03 	vmul.f64	d3, d11, d3
  105de4:	ee2b bb04 	vmul.f64	d11, d11, d4
  105de8:	ee02 fb06 	vmla.f64	d15, d2, d6
  105dec:	eeb0 2b40 	vmov.f64	d2, d0
  105df0:	ee09 ab06 	vmla.f64	d10, d9, d6
  105df4:	ee07 2b46 	vmls.f64	d2, d7, d6
  105df8:	ee05 0b06 	vmla.f64	d0, d5, d6
  105dfc:	ee03 db46 	vmls.f64	d13, d3, d6
  105e00:	ee0b eb46 	vmls.f64	d14, d11, d6
  105e04:	ed94 6a00 	vldr	s12, [r4]
  105e08:	ed94 9a01 	vldr	s18, [r4, #4]
  105e0c:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
  105e10:	ed8d 9a09 	vstr	s18, [r13, #36]	; 0x24
  105e14:	ed8d 9a0a 	vstr	s18, [r13, #40]	; 0x28
  105e18:	ed8d 9a0b 	vstr	s18, [r13, #44]	; 0x2c
  105e1c:	ee22 7b06 	vmul.f64	d7, d2, d6
  105e20:	ee21 5b06 	vmul.f64	d5, d1, d6
  105e24:	ee2f fb06 	vmul.f64	d15, d15, d6
  105e28:	ee28 8b06 	vmul.f64	d8, d8, d6
  105e2c:	ee2c cb06 	vmul.f64	d12, d12, d6
  105e30:	ee20 0b06 	vmul.f64	d0, d0, d6
  105e34:	ee2a ab06 	vmul.f64	d10, d10, d6
  105e38:	ee2d 4b06 	vmul.f64	d4, d13, d6
  105e3c:	ee2e 2b06 	vmul.f64	d2, d14, d6
  105e40:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
  105e44:	eeb7 fbcf 	vcvt.f32.f64	s30, d15
  105e48:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
  105e4c:	eeb7 cbcc 	vcvt.f32.f64	s24, d12
  105e50:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
  105e54:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
  105e58:	eeb7 abca 	vcvt.f32.f64	s20, d10
  105e5c:	eeb7 4bc4 	vcvt.f32.f64	s8, d4
  105e60:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
  105e64:	ed8d 5a12 	vstr	s10, [r13, #72]	; 0x48
  105e68:	ed8d fa13 	vstr	s30, [r13, #76]	; 0x4c
  105e6c:	ed8d 8a19 	vstr	s16, [r13, #100]	; 0x64
  105e70:	ed8d ca16 	vstr	s24, [r13, #88]	; 0x58
  105e74:	ed8d 7a14 	vstr	s14, [r13, #80]	; 0x50
  105e78:	ed8d 0a17 	vstr	s0, [r13, #92]	; 0x5c
  105e7c:	ed8d aa18 	vstr	s20, [r13, #96]	; 0x60
  105e80:	ed8d 4a15 	vstr	s8, [r13, #84]	; 0x54
  105e84:	ed8d 2a1a 	vstr	s4, [r13, #104]	; 0x68
  105e88:	9d05      	ldr	r5, [sp, #20]
  105e8a:	4646      	mov	r6, r8
  105e8c:	2400      	movs	r4, #0
  105e8e:	eef0 7a45 	vmov.f32	s15, s10
  105e92:	4622      	mov	r2, r4
  105e94:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
  105e98:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
  105e9c:	4639      	mov	r1, r7
  105e9e:	3401      	adds	r4, #1
  105ea0:	4648      	mov	r0, r9
  105ea2:	ed8d 5b00 	vstr	d5, [r13]
  105ea6:	ee17 3a90 	vmov	r3, s15
  105eaa:	f3c3 030d 	ubfx	r3, r3, #0, #14
  105eae:	9302      	str	r3, [sp, #8]
  105eb0:	f845 3b04 	str.w	r3, [r5], #4
  105eb4:	f00e fcbc 	bl	114830 <_printf>
  105eb8:	2c03      	cmp	r4, #3
  105eba:	d002      	beq.n	105ec2 <dc_csc_set+0x2a2>
  105ebc:	ecb6 5a01 	vldmia	r6!, {s10}
  105ec0:	e7e5      	b.n	105e8e <dc_csc_set+0x26e>
  105ec2:	9b05      	ldr	r3, [sp, #20]
  105ec4:	3701      	adds	r7, #1
  105ec6:	2f03      	cmp	r7, #3
  105ec8:	f103 030c 	add.w	r3, r3, #12
  105ecc:	f108 080c 	add.w	r8, r8, #12
  105ed0:	9305      	str	r3, [sp, #20]
  105ed2:	d002      	beq.n	105eda <dc_csc_set+0x2ba>
  105ed4:	ed18 5a01 	vldr	s10, [r8, #-4]
  105ed8:	e7d6      	b.n	105e88 <dc_csc_set+0x268>
  105eda:	2300      	movs	r3, #0
  105edc:	a90a      	add	r1, sp, #40	; 0x28
  105ede:	4618      	mov	r0, r3
  105ee0:	eebe 9acf 	vcvt.s32.f32	s18, s18, #2
  105ee4:	f84b 0023 	str.w	r0, [r11, r3, lsl #2]
  105ee8:	ee19 2a10 	vmov	r2, s18
  105eec:	f3c2 020d 	ubfx	r2, r2, #0, #14
  105ef0:	f84a 2023 	str.w	r2, [r10, r3, lsl #2]
  105ef4:	3301      	adds	r3, #1
  105ef6:	2b03      	cmp	r3, #3
  105ef8:	d046      	beq.n	105f88 <dc_csc_set+0x368>
  105efa:	ecb1 9a01 	vldmia	r1!, {s18}
  105efe:	e7ef      	b.n	105ee0 <dc_csc_set+0x2c0>
  105f00:	39581062 	.word	0x39581062
  105f04:	3fe2c8b4 	.word	0x3fe2c8b4
  105f08:	851eb852 	.word	0x851eb852
  105f0c:	3fec51eb 	.word	0x3fec51eb
  105f10:	9fbe76c9 	.word	0x9fbe76c9
  105f14:	3fbd2f1a 	.word	0x3fbd2f1a
  105f18:	e5604189 	.word	0xe5604189
  105f1c:	3fd322d0 	.word	0x3fd322d0
  105f20:	8d4fdf3b 	.word	0x8d4fdf3b
  105f24:	3fe66e97 	.word	0x3fe66e97
  105f28:	8d4fdf3b 	.word	0x8d4fdf3b
  105f2c:	3fda6e97 	.word	0x3fda6e97
  105f30:	5c28f5c3 	.word	0x5c28f5c3
  105f34:	3fddc28f 	.word	0x3fddc28f
  105f38:	7ced9168 	.word	0x7ced9168
  105f3c:	3fce353f 	.word	0x3fce353f
  105f40:	978d4fdf 	.word	0x978d4fdf
  105f44:	3fd3126e 	.word	0x3fd3126e
  105f48:	16872b02 	.word	0x16872b02
  105f4c:	3fb7ced9 	.word	0x3fb7ced9
  105f50:	a1cac083 	.word	0xa1cac083
  105f54:	3fe7b645 	.word	0x3fe7b645
  105f58:	8d4fdf3b 	.word	0x8d4fdf3b
  105f5c:	3fc26e97 	.word	0x3fc26e97
  105f60:	0a3d70a4 	.word	0x0a3d70a4
  105f64:	3fd8a3d7 	.word	0x3fd8a3d7
  105f68:	c49ba5e3 	.word	0xc49ba5e3
  105f6c:	3fd2b020 	.word	0x3fd2b020
  105f70:	3fa2f983 	.word	0x3fa2f983
  105f74:	3e6ca00c 	.word	0x3e6ca00c
  105f78:	3fc90fdb 	.word	0x3fc90fdb
  105f7c:	40490fdb 	.word	0x40490fdb
  105f80:	becf817b 	.word	0xbecf817b
  105f84:	40c90fdb 	.word	0x40c90fdb
  105f88:	f648 05c0 	movw	r5, #35008	; 0x88c0
  105f8c:	2400      	movs	r4, #0
  105f8e:	f2c0 0511 	movt	r5, #17
  105f92:	f85b 1024 	ldr.w	r1, [r11, r4, lsl #2]
  105f96:	4623      	mov	r3, r4
  105f98:	f85a 2024 	ldr.w	r2, [r10, r4, lsl #2]
  105f9c:	4628      	mov	r0, r5
  105f9e:	9100      	str	r1, [sp, #0]
  105fa0:	4621      	mov	r1, r4
  105fa2:	3401      	adds	r4, #1
  105fa4:	f00e fc44 	bl	114830 <_printf>
  105fa8:	2c03      	cmp	r4, #3
  105faa:	d1f2      	bne.n	105f92 <dc_csc_set+0x372>
  105fac:	981c      	ldr	r0, [sp, #112]	; 0x70
  105fae:	2300      	movs	r3, #0
  105fb0:	991e      	ldr	r1, [sp, #120]	; 0x78
  105fb2:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
  105fb6:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  105fb8:	2500      	movs	r5, #0
  105fba:	9e20      	ldr	r6, [sp, #128]	; 0x80
  105fbc:	ea03 4000 	and.w	r0, r3, r0, lsl #16
  105fc0:	f3c2 020d 	ubfx	r2, r2, #0, #14
  105fc4:	ea03 4e01 	and.w	r14, r3, r1, lsl #16
  105fc8:	f24a 0104 	movw	r1, #40964	; 0xa004
  105fcc:	4302      	orrs	r2, r0
  105fce:	9c22      	ldr	r4, [sp, #136]	; 0x88
  105fd0:	ea03 4c06 	and.w	r12, r3, r6, lsl #16
  105fd4:	9e06      	ldr	r6, [sp, #24]
  105fd6:	f2c0 35ff 	movt	r5, #1023	; 0x3ff
  105fda:	5072      	str	r2, [r6, r1]
  105fdc:	991d      	ldr	r1, [sp, #116]	; 0x74
  105fde:	ea03 4704 	and.w	r7, r3, r4, lsl #16
  105fe2:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  105fe4:	f24a 0408 	movw	r4, #40968	; 0xa008
  105fe8:	980c      	ldr	r0, [sp, #48]	; 0x30
  105fea:	f3c1 010d 	ubfx	r1, r1, #0, #14
  105fee:	ea41 010e 	orr.w	r1, r1, r14
  105ff2:	5131      	str	r1, [r6, r4]
  105ff4:	f24a 010c 	movw	r1, #40972	; 0xa00c
  105ff8:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
  105ffa:	ea03 4000 	and.w	r0, r3, r0, lsl #16
  105ffe:	9c06      	ldr	r4, [sp, #24]
  106000:	ea03 4302 	and.w	r3, r3, r2, lsl #16
  106004:	9a10      	ldr	r2, [sp, #64]	; 0x40
  106006:	f3c6 060d 	ubfx	r6, r6, #0, #14
  10600a:	ea46 060c 	orr.w	r6, r6, r12
  10600e:	5066      	str	r6, [r4, r1]
  106010:	ea05 4502 	and.w	r5, r5, r2, lsl #16
  106014:	9c21      	ldr	r4, [sp, #132]	; 0x84
  106016:	f24a 0210 	movw	r2, #40976	; 0xa010
  10601a:	9923      	ldr	r1, [sp, #140]	; 0x8c
  10601c:	9e06      	ldr	r6, [sp, #24]
  10601e:	f3c4 040d 	ubfx	r4, r4, #0, #14
  106022:	433c      	orrs	r4, r7
  106024:	f3c1 010d 	ubfx	r1, r1, #0, #14
  106028:	50b4      	str	r4, [r6, r2]
  10602a:	4308      	orrs	r0, r1
  10602c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  10602e:	f24a 0414 	movw	r4, #40980	; 0xa014
  106032:	990d      	ldr	r1, [sp, #52]	; 0x34
  106034:	5130      	str	r0, [r6, r4]
  106036:	f3c2 0209 	ubfx	r2, r2, #0, #10
  10603a:	f3c1 010d 	ubfx	r1, r1, #0, #14
  10603e:	430b      	orrs	r3, r1
  106040:	f24a 0418 	movw	r4, #40984	; 0xa018
  106044:	432a      	orrs	r2, r5
  106046:	9911      	ldr	r1, [sp, #68]	; 0x44
  106048:	f24a 001c 	movw	r0, #40988	; 0xa01c
  10604c:	5133      	str	r3, [r6, r4]
  10604e:	f24a 0420 	movw	r4, #40992	; 0xa020
  106052:	5032      	str	r2, [r6, r0]
  106054:	f3c1 0109 	ubfx	r1, r1, #0, #10
  106058:	2000      	movs	r0, #0
  10605a:	f506 4220 	add.w	r2, r6, #40960	; 0xa000
  10605e:	5131      	str	r1, [r6, r4]
  106060:	f64e 43b4 	movw	r3, #60596	; 0xecb4
  106064:	6010      	str	r0, [r2, #0]
  106066:	f2c0 0312 	movt	r3, #18
  10606a:	9a07      	ldr	r2, [sp, #28]
  10606c:	6851      	ldr	r1, [r2, #4]
  10606e:	f853 2021 	ldr.w	r2, [r3, r1, lsl #2]
  106072:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  106076:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
  10607a:	b025      	add	sp, #148	; 0x94
  10607c:	ecbd 8b10 	vpop	{d8-d15}
  106080:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  106084:	0000      	movs	r0, r0
	...

00106088 <dc_init>:
  106088:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10608c:	b091      	sub	sp, #68	; 0x44
  10608e:	9100      	str	r1, [sp, #0]
  106090:	2900      	cmp	r1, #0
  106092:	f000 83b2 	beq.w	1067fa <dc_init+0x772>
  106096:	6a02      	ldr	r2, [r0, #32]
  106098:	f249 0310 	movw	r3, #36880	; 0x9010
  10609c:	4683      	mov	r11, r0
  10609e:	58d0      	ldr	r0, [r2, r3]
  1060a0:	f010 0001 	ands.w	r0, r0, #1
  1060a4:	f040 8379 	bne.w	10679a <dc_init+0x712>
  1060a8:	f8db 300c 	ldr.w	r3, [r11, #12]
  1060ac:	f44f 7782 	mov.w	r7, #260	; 0x104
  1060b0:	6811      	ldr	r1, [r2, #0]
  1060b2:	f04f 0980 	mov.w	r9, #128	; 0x80
  1060b6:	2510      	movs	r5, #16
  1060b8:	f2c0 4701 	movt	r7, #1025	; 0x401
  1060bc:	2604      	movs	r6, #4
  1060be:	ea81 0343 	eor.w	r3, r1, r3, lsl #1
  1060c2:	9707      	str	r7, [sp, #28]
  1060c4:	f003 0c02 	and.w	r12, r3, #2
  1060c8:	ea8c 0101 	eor.w	r1, r12, r1
  1060cc:	f06f 4c70 	mvn.w	r12, #4026531840	; 0xf0000000
  1060d0:	6011      	str	r1, [r2, #0]
  1060d2:	f502 5180 	add.w	r1, r2, #4096	; 0x1000
  1060d6:	f8c2 c020 	str.w	r12, [r2, #32]
  1060da:	f502 57a1 	add.w	r7, r2, #5152	; 0x1420
  1060de:	f8c2 c120 	str.w	r12, [r2, #288]	; 0x120
  1060e2:	f502 5ca0 	add.w	r12, r2, #5120	; 0x1400
  1060e6:	f8c1 9000 	str.w	r9, [r1]
  1060ea:	f502 5181 	add.w	r1, r2, #4128	; 0x1020
  1060ee:	f8cc 9000 	str.w	r9, [r12]
  1060f2:	f04f 0c40 	mov.w	r12, #64	; 0x40
  1060f6:	f241 4904 	movw	r9, #5124	; 0x1404
  1060fa:	f242 0830 	movw	r8, #8240	; 0x2030
  1060fe:	f8c1 c000 	str.w	r12, [r1]
  106102:	f502 5182 	add.w	r1, r2, #4160	; 0x1040
  106106:	f8c7 c000 	str.w	r12, [r7]
  10610a:	2720      	movs	r7, #32
  10610c:	f502 5ca2 	add.w	r12, r2, #5184	; 0x1440
  106110:	600f      	str	r7, [r1, #0]
  106112:	f502 5183 	add.w	r1, r2, #4192	; 0x1060
  106116:	f8cc 7000 	str.w	r7, [r12]
  10611a:	f502 5ca3 	add.w	r12, r2, #5216	; 0x1460
  10611e:	600f      	str	r7, [r1, #0]
  106120:	f241 0104 	movw	r1, #4100	; 0x1004
  106124:	f8cc 7000 	str.w	r7, [r12]
  106128:	f241 0724 	movw	r7, #4132	; 0x1024
  10612c:	5055      	str	r5, [r2, r1]
  10612e:	2108      	movs	r1, #8
  106130:	f842 5009 	str.w	r5, [r2, r9]
  106134:	46ac      	mov	r12, r5
  106136:	51d1      	str	r1, [r2, r7]
  106138:	f241 4524 	movw	r5, #5156	; 0x1424
  10613c:	f241 0744 	movw	r7, #4164	; 0x1044
  106140:	f2c3 0820 	movt	r8, #12320	; 0x3020
  106144:	5151      	str	r1, [r2, r5]
  106146:	f241 4544 	movw	r5, #5188	; 0x1444
  10614a:	51d6      	str	r6, [r2, r7]
  10614c:	f241 0764 	movw	r7, #4196	; 0x1064
  106150:	5156      	str	r6, [r2, r5]
  106152:	f241 4564 	movw	r5, #5220	; 0x1464
  106156:	51d6      	str	r6, [r2, r7]
  106158:	f241 0708 	movw	r7, #4104	; 0x1008
  10615c:	5156      	str	r6, [r2, r5]
  10615e:	f241 4928 	movw	r9, #5160	; 0x1428
  106162:	51d1      	str	r1, [r2, r7]
  106164:	f241 4508 	movw	r5, #5128	; 0x1408
  106168:	f241 0728 	movw	r7, #4136	; 0x1028
  10616c:	f44f 6301 	mov.w	r3, #2064	; 0x810
  106170:	5151      	str	r1, [r2, r5]
  106172:	f2c1 0308 	movt	r3, #4104	; 0x1008
  106176:	51d6      	str	r6, [r2, r7]
  106178:	f04f 3504 	mov.w	r5, #67372036	; 0x4040404
  10617c:	f04f 37a0 	mov.w	r7, #2694881440	; 0xa0a0a0a0
  106180:	4631      	mov	r1, r6
  106182:	f842 6009 	str.w	r6, [r2, r9]
  106186:	f04f 3601 	mov.w	r6, #16843009	; 0x1010101
  10618a:	f8cd 8020 	str.w	r8, [r13, #32]
  10618e:	f04f 3806 	mov.w	r8, #101058054	; 0x6060606
  106192:	9309      	str	r3, [sp, #36]	; 0x24
  106194:	f241 0348 	movw	r3, #4168	; 0x1048
  106198:	950a      	str	r5, [sp, #40]	; 0x28
  10619a:	2502      	movs	r5, #2
  10619c:	970b      	str	r7, [sp, #44]	; 0x2c
  10619e:	f241 4748 	movw	r7, #5192	; 0x1448
  1061a2:	960c      	str	r6, [sp, #48]	; 0x30
  1061a4:	f241 0668 	movw	r6, #4200	; 0x1068
  1061a8:	f8cd 8038 	str.w	r8, [r13, #56]	; 0x38
  1061ac:	f241 4868 	movw	r8, #5224	; 0x1468
  1061b0:	50d5      	str	r5, [r2, r3]
  1061b2:	f502 5480 	add.w	r4, r2, #4096	; 0x1000
  1061b6:	51d5      	str	r5, [r2, r7]
  1061b8:	340c      	adds	r4, #12
  1061ba:	5195      	str	r5, [r2, r6]
  1061bc:	2330      	movs	r3, #48	; 0x30
  1061be:	f842 5008 	str.w	r5, [r2, r8]
  1061c2:	af07      	add	r7, sp, #28
  1061c4:	ae08      	add	r6, sp, #32
  1061c6:	ad09      	add	r5, sp, #36	; 0x24
  1061c8:	0409      	lsls	r1, r1, #16
  1061ca:	f401 117c 	and.w	r1, r1, #4128768	; 0x3f0000
  1061ce:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  1061d2:	f403 537c 	and.w	r3, r3, #16128	; 0x3f00
  1061d6:	430b      	orrs	r3, r1
  1061d8:	f00c 0c3f 	and.w	r12, r12, #63	; 0x3f
  1061dc:	3001      	adds	r0, #1
  1061de:	ea8c 0303 	eor.w	r3, r12, r3
  1061e2:	2804      	cmp	r0, #4
  1061e4:	6023      	str	r3, [r4, #0]
  1061e6:	f104 0420 	add.w	r4, r4, #32
  1061ea:	f8c4 33e0 	str.w	r3, [r4, #992]	; 0x3e0
  1061ee:	d004      	beq.n	1061fa <dc_init+0x172>
  1061f0:	5dc1      	ldrb	r1, [r0, r7]
  1061f2:	5d83      	ldrb	r3, [r0, r6]
  1061f4:	f810 c005 	ldrb.w	r12, [r0, r5]
  1061f8:	e7e6      	b.n	1061c8 <dc_init+0x140>
  1061fa:	f502 5380 	add.w	r3, r2, #4096	; 0x1000
  1061fe:	f502 5484 	add.w	r4, r2, #4224	; 0x1080
  106202:	3310      	adds	r3, #16
  106204:	3410      	adds	r4, #16
  106206:	f10d 0129 	add.w	r1, r13, #41	; 0x29
  10620a:	f000 0007 	and.w	r0, r0, #7
  10620e:	3320      	adds	r3, #32
  106210:	f843 0c20 	str.w	r0, [r3, #-32]
  106214:	f8c3 03e0 	str.w	r0, [r3, #992]	; 0x3e0
  106218:	42a3      	cmp	r3, r4
  10621a:	d002      	beq.n	106222 <dc_init+0x19a>
  10621c:	f811 0b01 	ldrb.w	r0, [r1], #1
  106220:	e7f3      	b.n	10620a <dc_init+0x182>
  106222:	2306      	movs	r3, #6
  106224:	f502 5480 	add.w	r4, r2, #4096	; 0x1000
  106228:	2101      	movs	r1, #1
  10622a:	341c      	adds	r4, #28
  10622c:	f04f 0ca0 	mov.w	r12, #160	; 0xa0
  106230:	2000      	movs	r0, #0
  106232:	af0b      	add	r7, sp, #44	; 0x2c
  106234:	ae0c      	add	r6, sp, #48	; 0x30
  106236:	ad0e      	add	r5, sp, #56	; 0x38
  106238:	ea4f 4c0c 	mov.w	r12, r12, lsl #16
  10623c:	ea4c 1101 	orr.w	r1, r12, r1, lsl #4
  106240:	f001 0170 	and.w	r1, r1, #112	; 0x70
  106244:	ea81 010c 	eor.w	r1, r1, r12
  106248:	f003 0307 	and.w	r3, r3, #7
  10624c:	3001      	adds	r0, #1
  10624e:	4059      	eors	r1, r3
  106250:	2804      	cmp	r0, #4
  106252:	6021      	str	r1, [r4, #0]
  106254:	f104 0420 	add.w	r4, r4, #32
  106258:	f8c4 13e0 	str.w	r1, [r4, #992]	; 0x3e0
  10625c:	d004      	beq.n	106268 <dc_init+0x1e0>
  10625e:	f810 c007 	ldrb.w	r12, [r0, r7]
  106262:	5d81      	ldrb	r1, [r0, r6]
  106264:	5d43      	ldrb	r3, [r0, r5]
  106266:	e7e7      	b.n	106238 <dc_init+0x1b0>
  106268:	247f      	movs	r4, #127	; 0x7f
  10626a:	f502 5091 	add.w	r0, r2, #4640	; 0x1220
  10626e:	f502 53b1 	add.w	r3, r2, #5664	; 0x1620
  106272:	6004      	str	r4, [r0, #0]
  106274:	f502 5188 	add.w	r1, r2, #4352	; 0x1100
  106278:	601c      	str	r4, [r3, #0]
  10627a:	2003      	movs	r0, #3
  10627c:	f502 53a8 	add.w	r3, r2, #5376	; 0x1500
  106280:	6008      	str	r0, [r1, #0]
  106282:	6018      	str	r0, [r3, #0]
  106284:	9900      	ldr	r1, [sp, #0]
  106286:	f8db 3008 	ldr.w	r3, [r11, #8]
  10628a:	f8d1 8020 	ldr.w	r8, [r1, #32]
  10628e:	2b00      	cmp	r3, #0
  106290:	f000 80eb 	beq.w	10646a <dc_init+0x3e2>
  106294:	e9d8 1301 	ldrd	r1, r3, [r8, #4]
  106298:	e9d8 6403 	ldrd	r6, r4, [r8, #12]
  10629c:	f8d8 e014 	ldr.w	r14, [r8, #20]
  1062a0:	ea4f 0c51 	mov.w	r12, r1, lsr #1
  1062a4:	f8d8 501c 	ldr.w	r5, [r8, #28]
  1062a8:	eb0c 0053 	add.w	r0, r12, r3, lsr #1
  1062ac:	f8d8 3018 	ldr.w	r3, [r8, #24]
  1062b0:	0876      	lsrs	r6, r6, #1
  1062b2:	f8d8 7020 	ldr.w	r7, [r8, #32]
  1062b6:	4430      	add	r0, r6
  1062b8:	4473      	add	r3, r14
  1062ba:	0861      	lsrs	r1, r4, #1
  1062bc:	442b      	add	r3, r5
  1062be:	4408      	add	r0, r1
  1062c0:	440e      	add	r6, r1
  1062c2:	443b      	add	r3, r7
  1062c4:	9002      	str	r0, [sp, #8]
  1062c6:	443d      	add	r5, r7
  1062c8:	f8d8 0024 	ldr.w	r0, [r8, #36]	; 0x24
  1062cc:	3f01      	subs	r7, #1
  1062ce:	f8d8 4028 	ldr.w	r4, [r8, #40]	; 0x28
  1062d2:	3901      	subs	r1, #1
  1062d4:	9701      	str	r7, [sp, #4]
  1062d6:	3e01      	subs	r6, #1
  1062d8:	9f02      	ldr	r7, [sp, #8]
  1062da:	f10c 3cff 	add.w	r12, r12, #4294967295	; 0xffffffff
  1062de:	b289      	uxth	r1, r1
  1062e0:	f107 3aff 	add.w	r10, r7, #4294967295	; 0xffffffff
  1062e4:	0107      	lsls	r7, r0, #4
  1062e6:	f007 0710 	and.w	r7, r7, #16
  1062ea:	f087 0920 	eor.w	r9, r7, #32
  1062ee:	ea89 00c4 	eor.w	r0, r9, r4, lsl #3
  1062f2:	f8d8 402c 	ldr.w	r4, [r8, #44]	; 0x2c
  1062f6:	f000 0008 	and.w	r0, r0, #8
  1062fa:	ea80 0709 	eor.w	r7, r0, r9
  1062fe:	ea41 4106 	orr.w	r1, r1, r6, lsl #16
  106302:	ea87 0084 	eor.w	r0, r7, r4, lsl #2
  106306:	f8d8 4030 	ldr.w	r4, [r8, #48]	; 0x30
  10630a:	f000 0004 	and.w	r0, r0, #4
  10630e:	4078      	eors	r0, r7
  106310:	f8bd 7004 	ldrh.w	r7, [r13, #4]
  106314:	eba3 090e 	sub.w	r9, r3, r14
  106318:	ea80 0444 	eor.w	r4, r0, r4, lsl #1
  10631c:	fa1f f68a 	uxth.w	r6, r10
  106320:	ea46 4c0c 	orr.w	r12, r6, r12, lsl #16
  106324:	eba9 0905 	sub.w	r9, r9, r5
  106328:	f004 0402 	and.w	r4, r4, #2
  10632c:	f502 4610 	add.w	r6, r2, #36864	; 0x9000
  106330:	3d01      	subs	r5, #1
  106332:	f8c6 c000 	str.w	r12, [r6]
  106336:	4060      	eors	r0, r4
  106338:	1e5c      	subs	r4, r3, #1
  10633a:	f249 0604 	movw	r6, #36868	; 0x9004
  10633e:	ea47 4505 	orr.w	r5, r7, r5, lsl #16
  106342:	f10e 37ff 	add.w	r7, r14, #4294967295	; 0xffffffff
  106346:	ea4f 0959 	mov.w	r9, r9, lsr #1
  10634a:	5191      	str	r1, [r2, r6]
  10634c:	b2a4      	uxth	r4, r4
  10634e:	f249 010c 	movw	r1, #36876	; 0x900c
  106352:	ea44 4407 	orr.w	r4, r4, r7, lsl #16
  106356:	f249 0608 	movw	r6, #36872	; 0x9008
  10635a:	eb0e 0709 	add.w	r7, r14, r9
  10635e:	ed9b 5b0c 	vldr	d5, [r11, #48]	; 0x30
  106362:	9703      	str	r7, [sp, #12]
  106364:	444f      	add	r7, r9
  106366:	5194      	str	r4, [r2, r6]
  106368:	f1a3 0903 	sub.w	r9, r3, #3
  10636c:	5055      	str	r5, [r2, r1]
  10636e:	f249 0110 	movw	r1, #36880	; 0x9010
  106372:	9701      	str	r7, [sp, #4]
  106374:	454f      	cmp	r7, r9
  106376:	5050      	str	r0, [r2, r1]
  106378:	bf28      	it	cs
  10637a:	1f19      	subcs	r1, r3, #4
  10637c:	f8cd 8010 	str.w	r8, [r13, #16]
  106380:	f103 0301 	add.w	r3, r3, #1
  106384:	bf28      	it	cs
  106386:	9101      	strcs	r1, [sp, #4]
  106388:	f241 2e04 	movw	r14, #4612	; 0x1204
  10638c:	f8dd 800c 	ldr.w	r8, [r13, #12]
  106390:	f04f 0c01 	mov.w	r12, #1
  106394:	f8cd b00c 	str.w	r11, [r13, #12]
  106398:	f8dd b004 	ldr.w	r11, [r13, #4]
  10639c:	9305      	str	r3, [sp, #20]
  10639e:	2300      	movs	r3, #0
  1063a0:	2b06      	cmp	r3, #6
  1063a2:	d860      	bhi.n	106466 <dc_init+0x3de>
  1063a4:	e8df f003 	tbb	[r15, r3]
  1063a8:	5d5d5d04 	.word	0x5d5d5d04
  1063ac:	5f5f      	.short	0x5f5f
  1063ae:	5d          	.byte	0x5d
  1063af:	00          	.byte	0x00
  1063b0:	4641      	mov	r1, r8
  1063b2:	1c5e      	adds	r6, r3, #1
  1063b4:	eb03 070e 	add.w	r7, r3, r14
  1063b8:	eb06 0086 	add.w	r0, r6, r6, lsl #2
  1063bc:	00fc      	lsls	r4, r7, #3
  1063be:	0080      	lsls	r0, r0, #2
  1063c0:	4550      	cmp	r0, r10
  1063c2:	bf28      	it	cs
  1063c4:	4650      	movcs	r0, r10
  1063c6:	3404      	adds	r4, #4
  1063c8:	2b01      	cmp	r3, #1
  1063ca:	b285      	uxth	r5, r0
  1063cc:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
  1063d0:	f842 5037 	str.w	r5, [r2, r7, lsl #3]
  1063d4:	f844 c002 	str.w	r12, [r4, r2]
  1063d8:	f000 81f6 	beq.w	1067c8 <dc_init+0x740>
  1063dc:	4633      	mov	r3, r6
  1063de:	2e13      	cmp	r6, #19
  1063e0:	d1de      	bne.n	1063a0 <dc_init+0x318>
  1063e2:	e9dd b803 	ldrd	r11, r8, [r13, #12]
  1063e6:	f64e 45b4 	movw	r5, #60596	; 0xecb4
  1063ea:	f8d2 c004 	ldr.w	r12, [r2, #4]
  1063ee:	f2c0 0512 	movt	r5, #18
  1063f2:	f04f 3007 	mov.w	r0, #117901063	; 0x7070707
  1063f6:	f502 47e1 	add.w	r7, r2, #28800	; 0x7080
  1063fa:	f8db 6004 	ldr.w	r6, [r11, #4]
  1063fe:	ea6f 010c 	mvn.w	r1, r12
  106402:	f04f 3e0f 	mov.w	r14, #252645135	; 0xf0f0f0f
  106406:	f001 0104 	and.w	r1, r1, #4
  10640a:	240f      	movs	r4, #15
  10640c:	ea81 010c 	eor.w	r1, r1, r12
  106410:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
  106414:	3740      	adds	r7, #64	; 0x40
  106416:	6051      	str	r1, [r2, #4]
  106418:	f241 0c18 	movw	r12, #4120	; 0x1018
  10641c:	900b      	str	r0, [sp, #44]	; 0x2c
  10641e:	f043 0308 	orr.w	r3, r3, #8
  106422:	2107      	movs	r1, #7
  106424:	20ff      	movs	r0, #255	; 0xff
  106426:	f845 3026 	str.w	r3, [r5, r6, lsl #2]
  10642a:	f502 43e0 	add.w	r3, r2, #28672	; 0x7000
  10642e:	f8cd e030 	str.w	r14, [r13, #48]	; 0x30
  106432:	f10d 062d 	add.w	r6, r13, #45	; 0x2d
  106436:	f8cd e038 	str.w	r14, [r13, #56]	; 0x38
  10643a:	f88d 4034 	strb.w	r4, [r13, #52]	; 0x34
  10643e:	f88d 403c 	strb.w	r4, [r13, #60]	; 0x3c
  106442:	0209      	lsls	r1, r1, #8
  106444:	f401 517c 	and.w	r1, r1, #16128	; 0x3f00
  106448:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
  10644c:	6019      	str	r1, [r3, #0]
  10644e:	6021      	str	r1, [r4, #0]
  106450:	6198      	str	r0, [r3, #24]
  106452:	f843 000c 	str.w	r0, [r3, r12]
  106456:	3330      	adds	r3, #48	; 0x30
  106458:	429f      	cmp	r7, r3
  10645a:	d022      	beq.n	1064a2 <dc_init+0x41a>
  10645c:	f816 1b01 	ldrb.w	r1, [r6], #1
  106460:	e7ef      	b.n	106442 <dc_init+0x3ba>
  106462:	4649      	mov	r1, r9
  106464:	e7a5      	b.n	1063b2 <dc_init+0x32a>
  106466:	4659      	mov	r1, r11
  106468:	e7a3      	b.n	1063b2 <dc_init+0x32a>
  10646a:	e9d8 1e04 	ldrd	r1, r14, [r8, #16]
  10646e:	f8d8 c004 	ldr.w	r12, [r8, #4]
  106472:	f8d8 600c 	ldr.w	r6, [r8, #12]
  106476:	f8d8 0018 	ldr.w	r0, [r8, #24]
  10647a:	eb0c 0401 	add.w	r4, r12, r1
  10647e:	f8d8 7020 	ldr.w	r7, [r8, #32]
  106482:	4434      	add	r4, r6
  106484:	9001      	str	r0, [sp, #4]
  106486:	440e      	add	r6, r1
  106488:	f8d8 0008 	ldr.w	r0, [r8, #8]
  10648c:	eb0e 0307 	add.w	r3, r14, r7
  106490:	f8d8 501c 	ldr.w	r5, [r8, #28]
  106494:	4404      	add	r4, r0
  106496:	9801      	ldr	r0, [sp, #4]
  106498:	442b      	add	r3, r5
  10649a:	9402      	str	r4, [sp, #8]
  10649c:	443d      	add	r5, r7
  10649e:	4403      	add	r3, r0
  1064a0:	e712      	b.n	1062c8 <dc_init+0x240>
  1064a2:	210f      	movs	r1, #15
  1064a4:	f502 4ce4 	add.w	r12, r2, #29184	; 0x7200
  1064a8:	460b      	mov	r3, r1
  1064aa:	f10c 0c14 	add.w	r12, r12, #20
  1064ae:	f502 44e4 	add.w	r4, r2, #29184	; 0x7200
  1064b2:	f10d 0731 	add.w	r7, r13, #49	; 0x31
  1064b6:	f10d 0639 	add.w	r6, r13, #57	; 0x39
  1064ba:	041b      	lsls	r3, r3, #16
  1064bc:	f403 2070 	and.w	r0, r3, #983040	; 0xf0000
  1064c0:	f001 030f 	and.w	r3, r1, #15
  1064c4:	4303      	orrs	r3, r0
  1064c6:	f504 5180 	add.w	r1, r4, #4096	; 0x1000
  1064ca:	6023      	str	r3, [r4, #0]
  1064cc:	3404      	adds	r4, #4
  1064ce:	600b      	str	r3, [r1, #0]
  1064d0:	45a4      	cmp	r12, r4
  1064d2:	d004      	beq.n	1064de <dc_init+0x456>
  1064d4:	f817 3b01 	ldrb.w	r3, [r7], #1
  1064d8:	f816 1b01 	ldrb.w	r1, [r6], #1
  1064dc:	e7ed      	b.n	1064ba <dc_init+0x432>
  1064de:	ed9f 6bc8 	vldr	d6, [r15, #800]	; 106800 <dc_init+0x778>
  1064e2:	e9d8 0302 	ldrd	r0, r3, [r8, #8]
  1064e6:	f8db 1008 	ldr.w	r1, [r11, #8]
  1064ea:	4403      	add	r3, r0
  1064ec:	f8d8 0010 	ldr.w	r0, [r8, #16]
  1064f0:	4403      	add	r3, r0
  1064f2:	ee25 6b06 	vmul.f64	d6, d5, d6
  1064f6:	eebc 6bc6 	vcvt.u32.f64	s12, d6
  1064fa:	b101      	cbz	r1, 1064fe <dc_init+0x476>
  1064fc:	085b      	lsrs	r3, r3, #1
  1064fe:	f8db 1004 	ldr.w	r1, [r11, #4]
  106502:	f8db 0038 	ldr.w	r0, [r11, #56]	; 0x38
  106506:	2904      	cmp	r1, #4
  106508:	f000 8153 	beq.w	1067b2 <dc_init+0x72a>
  10650c:	ee07 3a90 	vmov	s15, r3
  106510:	f5a0 60a0 	sub.w	r0, r0, #1280	; 0x500
  106514:	f8db 3018 	ldr.w	r3, [r11, #24]
  106518:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  10651c:	ee27 7b05 	vmul.f64	d7, d7, d5
  106520:	eebc 7bc7 	vcvt.u32.f64	s14, d7
  106524:	ee17 1a10 	vmov	r1, s14
  106528:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  10652c:	07d9      	lsls	r1, r3, #31
  10652e:	d53c      	bpl.n	1065aa <dc_init+0x522>
  106530:	f247 0160 	movw	r1, #28768	; 0x7060
  106534:	f247 260c 	movw	r6, #29196	; 0x720c
  106538:	f247 048c 	movw	r4, #28812	; 0x708c
  10653c:	5857      	ldr	r7, [r2, r1]
  10653e:	43fb      	mvns	r3, r7
  106540:	f003 0310 	and.w	r3, r3, #16
  106544:	407b      	eors	r3, r7
  106546:	43df      	mvns	r7, r3
  106548:	f007 0701 	and.w	r7, r7, #1
  10654c:	407b      	eors	r3, r7
  10654e:	5053      	str	r3, [r2, r1]
  106550:	f247 2104 	movw	r1, #29188	; 0x7204
  106554:	5110      	str	r0, [r2, r4]
  106556:	f247 046c 	movw	r4, #28780	; 0x706c
  10655a:	5993      	ldr	r3, [r2, r6]
  10655c:	f023 030f 	bic.w	r3, r3, #15
  106560:	f043 0301 	orr.w	r3, r3, #1
  106564:	5193      	str	r3, [r2, r6]
  106566:	5853      	ldr	r3, [r2, r1]
  106568:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  10656c:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
  106570:	5053      	str	r3, [r2, r1]
  106572:	9900      	ldr	r1, [sp, #0]
  106574:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  106576:	2b00      	cmp	r3, #0
  106578:	f000 813a 	beq.w	1067f0 <dc_init+0x768>
  10657c:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  10657e:	f247 0764 	movw	r7, #28772	; 0x7064
  106582:	f247 0668 	movw	r6, #28776	; 0x7068
  106586:	680b      	ldr	r3, [r1, #0]
  106588:	51d3      	str	r3, [r2, r7]
  10658a:	684b      	ldr	r3, [r1, #4]
  10658c:	5193      	str	r3, [r2, r6]
  10658e:	e9d1 3102 	ldrd	r3, r1, [r1, #8]
  106592:	3b01      	subs	r3, #1
  106594:	3901      	subs	r1, #1
  106596:	b29b      	uxth	r3, r3
  106598:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  10659c:	5113      	str	r3, [r2, r4]
  10659e:	f8db 3004 	ldr.w	r3, [r11, #4]
  1065a2:	2b04      	cmp	r3, #4
  1065a4:	d044      	beq.n	106630 <dc_init+0x5a8>
  1065a6:	f8db 3018 	ldr.w	r3, [r11, #24]
  1065aa:	079b      	lsls	r3, r3, #30
  1065ac:	d540      	bpl.n	106630 <dc_init+0x5a8>
  1065ae:	f247 0190 	movw	r1, #28816	; 0x7090
  1065b2:	f247 2410 	movw	r4, #29200	; 0x7210
  1065b6:	f247 06bc 	movw	r6, #28860	; 0x70bc
  1065ba:	5857      	ldr	r7, [r2, r1]
  1065bc:	43fb      	mvns	r3, r7
  1065be:	f003 0310 	and.w	r3, r3, #16
  1065c2:	407b      	eors	r3, r7
  1065c4:	43df      	mvns	r7, r3
  1065c6:	f007 0701 	and.w	r7, r7, #1
  1065ca:	407b      	eors	r3, r7
  1065cc:	5053      	str	r3, [r2, r1]
  1065ce:	f247 2108 	movw	r1, #29192	; 0x7208
  1065d2:	5190      	str	r0, [r2, r6]
  1065d4:	f247 009c 	movw	r0, #28828	; 0x709c
  1065d8:	5913      	ldr	r3, [r2, r4]
  1065da:	f023 030f 	bic.w	r3, r3, #15
  1065de:	f043 0302 	orr.w	r3, r3, #2
  1065e2:	5113      	str	r3, [r2, r4]
  1065e4:	5853      	ldr	r3, [r2, r1]
  1065e6:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  1065ea:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  1065ee:	5053      	str	r3, [r2, r1]
  1065f0:	9900      	ldr	r1, [sp, #0]
  1065f2:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  1065f4:	b193      	cbz	r3, 10661c <dc_init+0x594>
  1065f6:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  1065f8:	f247 0694 	movw	r6, #28820	; 0x7094
  1065fc:	f8db 300c 	ldr.w	r3, [r11, #12]
  106600:	690c      	ldr	r4, [r1, #16]
  106602:	b11b      	cbz	r3, 10660c <dc_init+0x584>
  106604:	f8d8 3004 	ldr.w	r3, [r8, #4]
  106608:	eba4 0453 	sub.w	r4, r4, r3, lsr #1
  10660c:	5194      	str	r4, [r2, r6]
  10660e:	f247 0398 	movw	r3, #28824	; 0x7098
  106612:	694c      	ldr	r4, [r1, #20]
  106614:	50d4      	str	r4, [r2, r3]
  106616:	e9d1 3106 	ldrd	r3, r1, [r1, #24]
  10661a:	e003      	b.n	106624 <dc_init+0x59c>
  10661c:	f8d8 3004 	ldr.w	r3, [r8, #4]
  106620:	f8d8 1014 	ldr.w	r1, [r8, #20]
  106624:	3b01      	subs	r3, #1
  106626:	3901      	subs	r1, #1
  106628:	b29b      	uxth	r3, r3
  10662a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  10662e:	5013      	str	r3, [r2, r0]
  106630:	f502 41a4 	add.w	r1, r2, #20992	; 0x5200
  106634:	ee16 6a10 	vmov	r6, s12
  106638:	f247 2434 	movw	r4, #29236	; 0x7234
  10663c:	f248 2334 	movw	r3, #33332	; 0x8234
  106640:	f64f 70ff 	movw	r0, #65535	; 0xffff
  106644:	f245 2804 	movw	r8, #20996	; 0x5204
  106648:	5116      	str	r6, [r2, r4]
  10664a:	f245 2e08 	movw	r14, #21000	; 0x5208
  10664e:	50d0      	str	r0, [r2, r3]
  106650:	f245 200c 	movw	r0, #21004	; 0x520c
  106654:	680c      	ldr	r4, [r1, #0]
  106656:	f502 5908 	add.w	r9, r2, #8704	; 0x2200
  10665a:	f242 0a44 	movw	r10, #8260	; 0x2044
  10665e:	f640 4cc4 	movw	r12, #3268	; 0xcc4
  106662:	f643 47e0 	movw	r7, #15584	; 0x3ce0
  106666:	43e3      	mvns	r3, r4
  106668:	f640 164f 	movw	r6, #2383	; 0x94f
  10666c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  106670:	4063      	eors	r3, r4
  106672:	f6c0 1c4f 	movt	r12, #2383	; 0x94f
  106676:	600b      	str	r3, [r1, #0]
  106678:	f6c3 177f 	movt	r7, #14719	; 0x397f
  10667c:	f852 1008 	ldr.w	r1, [r2, r8]
  106680:	f2c1 0624 	movt	r6, #4132	; 0x1024
  106684:	2440      	movs	r4, #64	; 0x40
  106686:	43cb      	mvns	r3, r1
  106688:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  10668c:	404b      	eors	r3, r1
  10668e:	2101      	movs	r1, #1
  106690:	f2c0 2400 	movt	r4, #512	; 0x200
  106694:	f842 3008 	str.w	r3, [r2, r8]
  106698:	f852 800e 	ldr.w	r8, [r2, r14]
  10669c:	ea6f 0308 	mvn.w	r3, r8
  1066a0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  1066a4:	ea83 0308 	eor.w	r3, r3, r8
  1066a8:	f242 2804 	movw	r8, #8708	; 0x2204
  1066ac:	f842 300e 	str.w	r3, [r2, r14]
  1066b0:	f852 e000 	ldr.w	r14, [r2, r0]
  1066b4:	ea6f 030e 	mvn.w	r3, r14
  1066b8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  1066bc:	ea83 030e 	eor.w	r3, r3, r14
  1066c0:	f640 1e4f 	movw	r14, #2383	; 0x94f
  1066c4:	5013      	str	r3, [r2, r0]
  1066c6:	f242 2008 	movw	r0, #8712	; 0x2208
  1066ca:	f842 100a 	str.w	r1, [r2, r10]
  1066ce:	f242 230c 	movw	r3, #8716	; 0x220c
  1066d2:	f8c9 1000 	str.w	r1, [r9]
  1066d6:	f242 2910 	movw	r9, #8720	; 0x2210
  1066da:	f842 e008 	str.w	r14, [r2, r8]
  1066de:	f242 2814 	movw	r8, #8724	; 0x2214
  1066e2:	f842 c000 	str.w	r12, [r2, r0]
  1066e6:	2000      	movs	r0, #0
  1066e8:	50d7      	str	r7, [r2, r3]
  1066ea:	f242 2318 	movw	r3, #8728	; 0x2218
  1066ee:	f842 6009 	str.w	r6, [r2, r9]
  1066f2:	f242 291c 	movw	r9, #8732	; 0x221c
  1066f6:	f842 0008 	str.w	r0, [r2, r8]
  1066fa:	f242 2820 	movw	r8, #8736	; 0x2220
  1066fe:	50d0      	str	r0, [r2, r3]
  106700:	f44f 7300 	mov.w	r3, #512	; 0x200
  106704:	f842 4009 	str.w	r4, [r2, r9]
  106708:	f502 4920 	add.w	r9, r2, #40960	; 0xa000
  10670c:	f842 3008 	str.w	r3, [r2, r8]
  106710:	f24a 0a0c 	movw	r10, #40972	; 0xa00c
  106714:	f8c9 1000 	str.w	r1, [r9]
  106718:	f24a 0804 	movw	r8, #40964	; 0xa004
  10671c:	f24a 0908 	movw	r9, #40968	; 0xa008
  106720:	f842 e008 	str.w	r14, [r2, r8]
  106724:	f24a 0e14 	movw	r14, #40980	; 0xa014
  106728:	f842 c009 	str.w	r12, [r2, r9]
  10672c:	f24a 0810 	movw	r8, #40976	; 0xa010
  106730:	f842 700a 	str.w	r7, [r2, r10]
  106734:	f24a 0c18 	movw	r12, #40984	; 0xa018
  106738:	f24a 091c 	movw	r9, #40988	; 0xa01c
  10673c:	f24a 0720 	movw	r7, #40992	; 0xa020
  106740:	f842 6008 	str.w	r6, [r2, r8]
  106744:	f502 4640 	add.w	r6, r2, #49152	; 0xc000
  106748:	f842 000e 	str.w	r0, [r2, r14]
  10674c:	f24c 0e04 	movw	r14, #49156	; 0xc004
  106750:	f842 000c 	str.w	r0, [r2, r12]
  106754:	f04f 0c41 	mov.w	r12, #65	; 0x41
  106758:	f842 4009 	str.w	r4, [r2, r9]
  10675c:	51d3      	str	r3, [r2, r7]
  10675e:	f8db 4004 	ldr.w	r4, [r11, #4]
  106762:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
  106766:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  10676a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
  10676e:	6031      	str	r1, [r6, #0]
  106770:	f8db 1004 	ldr.w	r1, [r11, #4]
  106774:	f842 c00e 	str.w	r12, [r2, r14]
  106778:	f8db 2004 	ldr.w	r2, [r11, #4]
  10677c:	f855 3021 	ldr.w	r3, [r5, r1, lsl #2]
  106780:	f043 0320 	orr.w	r3, r3, #32
  106784:	f845 3021 	str.w	r3, [r5, r1, lsl #2]
  106788:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
  10678c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  106790:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
  106794:	b011      	add	sp, #68	; 0x44
  106796:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10679a:	f8db 1004 	ldr.w	r1, [r11, #4]
  10679e:	f648 00d8 	movw	r0, #35032	; 0x88d8
  1067a2:	f2c0 0011 	movt	r0, #17
  1067a6:	f00e f843 	bl	114830 <_printf>
  1067aa:	2000      	movs	r0, #0
  1067ac:	b011      	add	sp, #68	; 0x44
  1067ae:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  1067b2:	f247 0160 	movw	r1, #28768	; 0x7060
  1067b6:	f04f 1402 	mov.w	r4, #131074	; 0x20002
  1067ba:	5054      	str	r4, [r2, r1]
  1067bc:	f8db 1004 	ldr.w	r1, [r11, #4]
  1067c0:	2904      	cmp	r1, #4
  1067c2:	f43f af35 	beq.w	106630 <dc_init+0x5a8>
  1067c6:	e6a1      	b.n	10650c <dc_init+0x484>
  1067c8:	9b05      	ldr	r3, [sp, #20]
  1067ca:	9c02      	ldr	r4, [sp, #8]
  1067cc:	1a59      	subs	r1, r3, r1
  1067ce:	2302      	movs	r3, #2
  1067d0:	fb04 f101 	mul.w	r1, r4, r1
  1067d4:	1a09      	subs	r1, r1, r0
  1067d6:	9803      	ldr	r0, [sp, #12]
  1067d8:	ee07 1a10 	vmov	s14, r1
  1067dc:	4649      	mov	r1, r9
  1067de:	eeb8 7b47 	vcvt.f64.u32	d7, s14
  1067e2:	ee27 7b05 	vmul.f64	d7, d7, d5
  1067e6:	eebc 7bc7 	vcvt.u32.f64	s14, d7
  1067ea:	ed80 7a0e 	vstr	s14, [r0, #56]	; 0x38
  1067ee:	e5e0      	b.n	1063b2 <dc_init+0x32a>
  1067f0:	f8d8 3004 	ldr.w	r3, [r8, #4]
  1067f4:	f8d8 1014 	ldr.w	r1, [r8, #20]
  1067f8:	e6cb      	b.n	106592 <dc_init+0x50a>
  1067fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1067fe:	e7c9      	b.n	106794 <dc_init+0x70c>
  106800:	00000000 	.word	0x00000000
  106804:	40b00000 	.word	0x40b00000

00106808 <dc_update_layer>:
  106808:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10680c:	2201      	movs	r2, #1
  10680e:	4680      	mov	r8, r0
  106810:	68ce      	ldr	r6, [r1, #12]
  106812:	f2c9 0288 	movt	r2, #37000	; 0x9088
  106816:	460d      	mov	r5, r1
  106818:	b083      	sub	sp, #12
  10681a:	680b      	ldr	r3, [r1, #0]
  10681c:	f3c6 2003 	ubfx	r0, r6, #8, #4
  106820:	4296      	cmp	r6, r2
  106822:	bf0c      	ite	eq
  106824:	f44f 3280 	moveq.w	r2, #65536	; 0x10000
  106828:	2200      	movne	r2, #0
  10682a:	0ff1      	lsrs	r1, r6, #31
  10682c:	ea42 3000 	orr.w	r0, r2, r0, lsl #12
  106830:	ea40 11c1 	orr.w	r1, r0, r1, lsl #7
  106834:	f3c6 7280 	ubfx	r2, r6, #30, #1
  106838:	f001 0180 	and.w	r1, r1, #128	; 0x80
  10683c:	4041      	eors	r1, r0
  10683e:	ea41 1282 	orr.w	r2, r1, r2, lsl #6
  106842:	f3c6 3703 	ubfx	r7, r6, #12, #4
  106846:	f3c6 7001 	ubfx	r0, r6, #28, #2
  10684a:	f002 0240 	and.w	r2, r2, #64	; 0x40
  10684e:	404a      	eors	r2, r1
  106850:	08b4      	lsrs	r4, r6, #2
  106852:	f406 2170 	and.w	r1, r6, #983040	; 0xf0000
  106856:	f3c6 5c03 	ubfx	r12, r6, #20, #4
  10685a:	f004 040c 	and.w	r4, r4, #12
  10685e:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
  106862:	ea42 1200 	orr.w	r2, r2, r0, lsl #4
  106866:	4062      	eors	r2, r4
  106868:	f3c6 0781 	ubfx	r7, r6, #2, #2
  10686c:	f3c6 6403 	ubfx	r4, r6, #24, #4
  106870:	ea41 210c 	orr.w	r1, r1, r12, lsl #8
  106874:	4061      	eors	r1, r4
  106876:	407a      	eors	r2, r7
  106878:	f8d8 4020 	ldr.w	r4, [r8, #32]
  10687c:	f006 0603 	and.w	r6, r6, #3
  106880:	2b00      	cmp	r3, #0
  106882:	f000 80f4 	beq.w	106a6e <dc_update_layer+0x266>
  106886:	2b01      	cmp	r3, #1
  106888:	f040 81d0 	bne.w	106c2c <dc_update_layer+0x424>
  10688c:	f242 0004 	movw	r0, #8196	; 0x2004
  106890:	f504 5300 	add.w	r3, r4, #8192	; 0x2000
  106894:	6019      	str	r1, [r3, #0]
  106896:	5022      	str	r2, [r4, r0]
  106898:	68ea      	ldr	r2, [r5, #12]
  10689a:	682b      	ldr	r3, [r5, #0]
  10689c:	f3c2 7001 	ubfx	r0, r2, #28, #2
  1068a0:	f002 0c03 	and.w	r12, r2, #3
  1068a4:	6caa      	ldr	r2, [r5, #72]	; 0x48
  1068a6:	2e01      	cmp	r6, #1
  1068a8:	f04f 0e00 	mov.w	r14, #0
  1068ac:	bf08      	it	eq
  1068ae:	f8b5 9040 	ldrheq.w	r9, [r5, #64]	; 0x40
  1068b2:	f102 37ff 	add.w	r7, r2, #4294967295	; 0xffffffff
  1068b6:	bf08      	it	eq
  1068b8:	6c6a      	ldreq	r2, [r5, #68]	; 0x44
  1068ba:	f6cf 7eff 	movt	r14, #65535	; 0xffff
  1068be:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
  1068c0:	bf18      	it	ne
  1068c2:	f04f 0900 	movne.w	r9, #0
  1068c6:	b2bf      	uxth	r7, r7
  1068c8:	bf04      	itt	eq
  1068ca:	ea49 4202 	orreq.w	r2, r9, r2, lsl #16
  1068ce:	ea02 0e0e 	andeq.w	r14, r2, r14
  1068d2:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
  1068d6:	bf08      	it	eq
  1068d8:	ea4e 0909 	orreq.w	r9, r14, r9
  1068dc:	f1bc 0f01 	cmp.w	r12, #1
  1068e0:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
  1068e4:	d008      	beq.n	1068f8 <dc_update_layer+0xf0>
  1068e6:	2802      	cmp	r0, #2
  1068e8:	f000 8167 	beq.w	106bba <dc_update_layer+0x3b2>
  1068ec:	2803      	cmp	r0, #3
  1068ee:	f000 8127 	beq.w	106b40 <dc_update_layer+0x338>
  1068f2:	2801      	cmp	r0, #1
  1068f4:	f000 814a 	beq.w	106b8c <dc_update_layer+0x384>
  1068f8:	f8d8 0004 	ldr.w	r0, [r8, #4]
  1068fc:	eb08 0283 	add.w	r2, r8, r3, lsl #2
  106900:	6f29      	ldr	r1, [r5, #112]	; 0x70
  106902:	64d1      	str	r1, [r2, #76]	; 0x4c
  106904:	2804      	cmp	r0, #4
  106906:	bf08      	it	eq
  106908:	468a      	moveq	r10, r1
  10690a:	d007      	beq.n	10691c <dc_update_layer+0x114>
  10690c:	f8d8 2018 	ldr.w	r2, [r8, #24]
  106910:	0792      	lsls	r2, r2, #30
  106912:	bf4c      	ite	mi
  106914:	f101 0a03 	addmi.w	r10, r1, #3
  106918:	f101 0a02 	addpl.w	r10, r1, #2
  10691c:	2b00      	cmp	r3, #0
  10691e:	f000 80ab 	beq.w	106a78 <dc_update_layer+0x270>
  106922:	2b01      	cmp	r3, #1
  106924:	f040 817f 	bne.w	106c26 <dc_update_layer+0x41e>
  106928:	6a28      	ldr	r0, [r5, #32]
  10692a:	f04f 0b00 	mov.w	r11, #0
  10692e:	f009 fd25 	bl	11037c <p2ap>
  106932:	f242 0108 	movw	r1, #8200	; 0x2008
  106936:	f242 020c 	movw	r2, #8204	; 0x200c
  10693a:	f242 0310 	movw	r3, #8208	; 0x2010
  10693e:	5067      	str	r7, [r4, r1]
  106940:	2e01      	cmp	r6, #1
  106942:	f242 012c 	movw	r1, #8236	; 0x202c
  106946:	50a0      	str	r0, [r4, r2]
  106948:	f844 b003 	str.w	r11, [r4, r3]
  10694c:	f504 5301 	add.w	r3, r4, #8256	; 0x2040
  106950:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  106952:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
  106956:	5062      	str	r2, [r4, r1]
  106958:	f8c3 9000 	str.w	r9, [r3]
  10695c:	d865      	bhi.n	106a2a <dc_update_layer+0x222>
  10695e:	68eb      	ldr	r3, [r5, #12]
  106960:	f242 0144 	movw	r1, #8260	; 0x2044
  106964:	f247 0c34 	movw	r12, #28724	; 0x7034
  106968:	f504 5208 	add.w	r2, r4, #8704	; 0x2200
  10696c:	f247 0e38 	movw	r14, #28728	; 0x7038
  106970:	5860      	ldr	r0, [r4, r1]
  106972:	0fdb      	lsrs	r3, r3, #31
  106974:	f083 0601 	eor.w	r6, r3, #1
  106978:	ea80 73c3 	eor.w	r3, r0, r3, lsl #31
  10697c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
  106980:	4043      	eors	r3, r0
  106982:	f64e 40b4 	movw	r0, #60596	; 0xecb4
  106986:	f023 0301 	bic.w	r3, r3, #1
  10698a:	4333      	orrs	r3, r6
  10698c:	f2c0 0012 	movt	r0, #18
  106990:	5063      	str	r3, [r4, r1]
  106992:	6813      	ldr	r3, [r2, #0]
  106994:	f023 0301 	bic.w	r3, r3, #1
  106998:	431e      	orrs	r6, r3
  10699a:	6016      	str	r6, [r2, #0]
  10699c:	f247 063c 	movw	r6, #28732	; 0x703c
  1069a0:	f8d8 1004 	ldr.w	r1, [r8, #4]
  1069a4:	6d2b      	ldr	r3, [r5, #80]	; 0x50
  1069a6:	f844 300c 	str.w	r3, [r4, r12]
  1069aa:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
  1069ae:	6d6b      	ldr	r3, [r5, #84]	; 0x54
  1069b0:	f844 300e 	str.w	r3, [r4, r14]
  1069b4:	f042 0201 	orr.w	r2, r2, #1
  1069b8:	51a7      	str	r7, [r4, r6]
  1069ba:	6eab      	ldr	r3, [r5, #104]	; 0x68
  1069bc:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
  1069c0:	bb63      	cbnz	r3, 106a1c <dc_update_layer+0x214>
  1069c2:	f247 0630 	movw	r6, #28720	; 0x7030
  1069c6:	f247 2508 	movw	r5, #29192	; 0x7208
  1069ca:	f50a 51e4 	add.w	r1, r10, #7296	; 0x1c80
  1069ce:	59a2      	ldr	r2, [r4, r6]
  1069d0:	ea82 0383 	eor.w	r3, r2, r3, lsl #2
  1069d4:	f003 0304 	and.w	r3, r3, #4
  1069d8:	4053      	eors	r3, r2
  1069da:	43da      	mvns	r2, r3
  1069dc:	f002 0201 	and.w	r2, r2, #1
  1069e0:	4053      	eors	r3, r2
  1069e2:	51a3      	str	r3, [r4, r6]
  1069e4:	2300      	movs	r3, #0
  1069e6:	5966      	ldr	r6, [r4, r5]
  1069e8:	ea8a 0206 	eor.w	r2, r10, r6
  1069ec:	f002 020f 	and.w	r2, r2, #15
  1069f0:	4072      	eors	r2, r6
  1069f2:	5162      	str	r2, [r4, r5]
  1069f4:	f854 2021 	ldr.w	r2, [r4, r1, lsl #2]
  1069f8:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  1069fc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  106a00:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
  106a04:	f8d8 1004 	ldr.w	r1, [r8, #4]
  106a08:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
  106a0c:	f042 0210 	orr.w	r2, r2, #16
  106a10:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
  106a14:	4618      	mov	r0, r3
  106a16:	b003      	add	sp, #12
  106a18:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  106a1c:	f247 0348 	movw	r3, #28744	; 0x7048
  106a20:	f895 206c 	ldrb.w	r2, [r5, #108]	; 0x6c
  106a24:	50e2      	str	r2, [r4, r3]
  106a26:	6eab      	ldr	r3, [r5, #104]	; 0x68
  106a28:	e7cb      	b.n	1069c2 <dc_update_layer+0x1ba>
  106a2a:	6a68      	ldr	r0, [r5, #36]	; 0x24
  106a2c:	f009 fca6 	bl	11037c <p2ap>
  106a30:	f242 0214 	movw	r2, #8212	; 0x2014
  106a34:	f242 0318 	movw	r3, #8216	; 0x2018
  106a38:	2e03      	cmp	r6, #3
  106a3a:	50a0      	str	r0, [r4, r2]
  106a3c:	f242 0230 	movw	r2, #8240	; 0x2030
  106a40:	f844 b003 	str.w	r11, [r4, r3]
  106a44:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  106a46:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  106a4a:	50a3      	str	r3, [r4, r2]
  106a4c:	d187      	bne.n	10695e <dc_update_layer+0x156>
  106a4e:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  106a50:	f009 fc94 	bl	11037c <p2ap>
  106a54:	f242 021c 	movw	r2, #8220	; 0x201c
  106a58:	f242 0320 	movw	r3, #8224	; 0x2020
  106a5c:	50a0      	str	r0, [r4, r2]
  106a5e:	f242 0234 	movw	r2, #8244	; 0x2034
  106a62:	f844 b003 	str.w	r11, [r4, r3]
  106a66:	6bab      	ldr	r3, [r5, #56]	; 0x38
  106a68:	3b01      	subs	r3, #1
  106a6a:	50a3      	str	r3, [r4, r2]
  106a6c:	e777      	b.n	10695e <dc_update_layer+0x156>
  106a6e:	f245 0004 	movw	r0, #20484	; 0x5004
  106a72:	f504 43a0 	add.w	r3, r4, #20480	; 0x5000
  106a76:	e70d      	b.n	106894 <dc_update_layer+0x8c>
  106a78:	6a28      	ldr	r0, [r5, #32]
  106a7a:	f245 0608 	movw	r6, #20488	; 0x5008
  106a7e:	9301      	str	r3, [sp, #4]
  106a80:	f009 fc7c 	bl	11037c <p2ap>
  106a84:	f245 010c 	movw	r1, #20492	; 0x500c
  106a88:	f245 0210 	movw	r2, #20496	; 0x5010
  106a8c:	9b01      	ldr	r3, [sp, #4]
  106a8e:	f247 0e08 	movw	r14, #28680	; 0x7008
  106a92:	51a7      	str	r7, [r4, r6]
  106a94:	f245 0640 	movw	r6, #20544	; 0x5040
  106a98:	f247 0c0c 	movw	r12, #28684	; 0x700c
  106a9c:	5060      	str	r0, [r4, r1]
  106a9e:	f245 012c 	movw	r1, #20524	; 0x502c
  106aa2:	50a3      	str	r3, [r4, r2]
  106aa4:	f64e 40b4 	movw	r0, #60596	; 0xecb4
  106aa8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  106aaa:	f2c0 0012 	movt	r0, #18
  106aae:	3a01      	subs	r2, #1
  106ab0:	5062      	str	r2, [r4, r1]
  106ab2:	f247 0104 	movw	r1, #28676	; 0x7004
  106ab6:	f844 9006 	str.w	r9, [r4, r6]
  106aba:	f8d8 6004 	ldr.w	r6, [r8, #4]
  106abe:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  106ac0:	5062      	str	r2, [r4, r1]
  106ac2:	f850 2026 	ldr.w	r2, [r0, r6, lsl #2]
  106ac6:	6d69      	ldr	r1, [r5, #84]	; 0x54
  106ac8:	f844 100e 	str.w	r1, [r4, r14]
  106acc:	f042 0202 	orr.w	r2, r2, #2
  106ad0:	f844 700c 	str.w	r7, [r4, r12]
  106ad4:	6ea9      	ldr	r1, [r5, #104]	; 0x68
  106ad6:	f840 2026 	str.w	r2, [r0, r6, lsl #2]
  106ada:	b129      	cbz	r1, 106ae8 <dc_update_layer+0x2e0>
  106adc:	f247 0218 	movw	r2, #28696	; 0x7018
  106ae0:	f895 106c 	ldrb.w	r1, [r5, #108]	; 0x6c
  106ae4:	50a1      	str	r1, [r4, r2]
  106ae6:	6ea9      	ldr	r1, [r5, #104]	; 0x68
  106ae8:	f247 2604 	movw	r6, #29188	; 0x7204
  106aec:	f504 47e0 	add.w	r7, r4, #28672	; 0x7000
  106af0:	f50a 55e4 	add.w	r5, r10, #7296	; 0x1c80
  106af4:	683a      	ldr	r2, [r7, #0]
  106af6:	ea82 0181 	eor.w	r1, r2, r1, lsl #2
  106afa:	f001 0104 	and.w	r1, r1, #4
  106afe:	4051      	eors	r1, r2
  106b00:	43ca      	mvns	r2, r1
  106b02:	f002 0201 	and.w	r2, r2, #1
  106b06:	4051      	eors	r1, r2
  106b08:	6039      	str	r1, [r7, #0]
  106b0a:	59a1      	ldr	r1, [r4, r6]
  106b0c:	ea8a 0201 	eor.w	r2, r10, r1
  106b10:	f002 020f 	and.w	r2, r2, #15
  106b14:	404a      	eors	r2, r1
  106b16:	51a2      	str	r2, [r4, r6]
  106b18:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
  106b1c:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  106b20:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  106b24:	f844 2025 	str.w	r2, [r4, r5, lsl #2]
  106b28:	f8d8 1004 	ldr.w	r1, [r8, #4]
  106b2c:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
  106b30:	f042 0210 	orr.w	r2, r2, #16
  106b34:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
  106b38:	4618      	mov	r0, r3
  106b3a:	b003      	add	sp, #12
  106b3c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  106b40:	f1bc 0f02 	cmp.w	r12, #2
  106b44:	d04e      	beq.n	106be4 <dc_update_layer+0x3dc>
  106b46:	f1bc 0f03 	cmp.w	r12, #3
  106b4a:	f47f aed5 	bne.w	1068f8 <dc_update_layer+0xf0>
  106b4e:	e9d5 2110 	ldrd	r2, r1, [r5, #64]	; 0x40
  106b52:	6b68      	ldr	r0, [r5, #52]	; 0x34
  106b54:	9001      	str	r0, [sp, #4]
  106b56:	eb02 7cd2 	add.w	r12, r2, r2, lsr #31
  106b5a:	6b28      	ldr	r0, [r5, #48]	; 0x30
  106b5c:	eb01 7ed1 	add.w	r14, r1, r1, lsr #31
  106b60:	ea4f 0c6c 	mov.w	r12, r12, asr #1
  106b64:	ea4f 0e6e 	mov.w	r14, r14, asr #1
  106b68:	fb00 2101 	mla	r1, r0, r1, r2
  106b6c:	9801      	ldr	r0, [sp, #4]
  106b6e:	6baa      	ldr	r2, [r5, #56]	; 0x38
  106b70:	fb00 c00e 	mla	r0, r0, r14, r12
  106b74:	fb02 cc0e 	mla	r12, r2, r14, r12
  106b78:	6a2a      	ldr	r2, [r5, #32]
  106b7a:	4411      	add	r1, r2
  106b7c:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  106b7e:	6229      	str	r1, [r5, #32]
  106b80:	4410      	add	r0, r2
  106b82:	6aaa      	ldr	r2, [r5, #40]	; 0x28
  106b84:	4462      	add	r2, r12
  106b86:	e9c5 0209 	strd	r0, r2, [r5, #36]	; 0x24
  106b8a:	e6b5      	b.n	1068f8 <dc_update_layer+0xf0>
  106b8c:	f1bc 0f02 	cmp.w	r12, #2
  106b90:	d03a      	beq.n	106c08 <dc_update_layer+0x400>
  106b92:	f1bc 0f03 	cmp.w	r12, #3
  106b96:	f47f aeaf 	bne.w	1068f8 <dc_update_layer+0xf0>
  106b9a:	e9d5 1e10 	ldrd	r1, r14, [r5, #64]	; 0x40
  106b9e:	6b68      	ldr	r0, [r5, #52]	; 0x34
  106ba0:	eb01 72d1 	add.w	r2, r1, r1, lsr #31
  106ba4:	ea4f 0c62 	mov.w	r12, r2, asr #1
  106ba8:	6baa      	ldr	r2, [r5, #56]	; 0x38
  106baa:	9201      	str	r2, [sp, #4]
  106bac:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  106bae:	fb00 c00e 	mla	r0, r0, r14, r12
  106bb2:	fb02 110e 	mla	r1, r2, r14, r1
  106bb6:	9a01      	ldr	r2, [sp, #4]
  106bb8:	e7dc      	b.n	106b74 <dc_update_layer+0x36c>
  106bba:	f1bc 0f02 	cmp.w	r12, #2
  106bbe:	f47f ae9b 	bne.w	1068f8 <dc_update_layer+0xf0>
  106bc2:	e9d5 2010 	ldrd	r2, r0, [r5, #64]	; 0x40
  106bc6:	6b69      	ldr	r1, [r5, #52]	; 0x34
  106bc8:	ea4f 0c42 	mov.w	r12, r2, lsl #1
  106bcc:	fb01 cc00 	mla	r12, r1, r0, r12
  106bd0:	6b29      	ldr	r1, [r5, #48]	; 0x30
  106bd2:	fb01 2000 	mla	r0, r1, r0, r2
  106bd6:	e9d5 2108 	ldrd	r2, r1, [r5, #32]
  106bda:	4461      	add	r1, r12
  106bdc:	4402      	add	r2, r0
  106bde:	e9c5 2108 	strd	r2, r1, [r5, #32]
  106be2:	e689      	b.n	1068f8 <dc_update_layer+0xf0>
  106be4:	e9d5 e110 	ldrd	r14, r1, [r5, #64]	; 0x40
  106be8:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  106bea:	eb01 70d1 	add.w	r0, r1, r1, lsr #31
  106bee:	fb02 ec01 	mla	r12, r2, r1, r14
  106bf2:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  106bf4:	1040      	asrs	r0, r0, #1
  106bf6:	fb02 e000 	mla	r0, r2, r0, r14
  106bfa:	e9d5 2108 	ldrd	r2, r1, [r5, #32]
  106bfe:	4401      	add	r1, r0
  106c00:	4462      	add	r2, r12
  106c02:	e9c5 2108 	strd	r2, r1, [r5, #32]
  106c06:	e677      	b.n	1068f8 <dc_update_layer+0xf0>
  106c08:	e9d5 1010 	ldrd	r1, r0, [r5, #64]	; 0x40
  106c0c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
  106c0e:	fb02 1c00 	mla	r12, r2, r0, r1
  106c12:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  106c14:	fb02 1100 	mla	r1, r2, r0, r1
  106c18:	e9d5 2008 	ldrd	r2, r0, [r5, #32]
  106c1c:	4462      	add	r2, r12
  106c1e:	4408      	add	r0, r1
  106c20:	e9c5 2008 	strd	r2, r0, [r5, #32]
  106c24:	e668      	b.n	1068f8 <dc_update_layer+0xf0>
  106c26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  106c2a:	e6f3      	b.n	106a14 <dc_update_layer+0x20c>
  106c2c:	46b4      	mov	r12, r6
  106c2e:	e639      	b.n	1068a4 <dc_update_layer+0x9c>

00106c30 <dc_irq_handler>:
  106c30:	6a02      	ldr	r2, [r0, #32]
  106c32:	6a53      	ldr	r3, [r2, #36]	; 0x24
  106c34:	6253      	str	r3, [r2, #36]	; 0x24
  106c36:	071b      	lsls	r3, r3, #28
  106c38:	d401      	bmi.n	106c3e <dc_irq_handler+0xe>
  106c3a:	2001      	movs	r0, #1
  106c3c:	4770      	bx	r14
  106c3e:	b510      	push	{r4, r14}
  106c40:	4604      	mov	r4, r0
  106c42:	f7f9 fd05 	bl	100650 <current_time>
  106c46:	6560      	str	r0, [r4, #84]	; 0x54
  106c48:	6820      	ldr	r0, [r4, #0]
  106c4a:	f7fe fa67 	bl	10511c <disp_vsync_callback>
  106c4e:	2001      	movs	r0, #1
  106c50:	bd10      	pop	{r4, r15}
  106c52:	bf00      	nop

00106c54 <dc_update>:
  106c54:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  106c58:	f8d1 b000 	ldr.w	r11, [r1]
  106c5c:	b0a1      	sub	sp, #132	; 0x84
  106c5e:	f1bb 0f02 	cmp.w	r11, #2
  106c62:	f200 808d 	bhi.w	106d80 <dc_update+0x12c>
  106c66:	f1bb 0f00 	cmp.w	r11, #0
  106c6a:	f000 8099 	beq.w	106da0 <dc_update+0x14c>
  106c6e:	2600      	movs	r6, #0
  106c70:	4681      	mov	r9, r0
  106c72:	4688      	mov	r8, r1
  106c74:	4637      	mov	r7, r6
  106c76:	465c      	mov	r4, r11
  106c78:	e01c      	b.n	106cb4 <dc_update+0x60>
  106c7a:	2278      	movs	r2, #120	; 0x78
  106c7c:	a802      	add	r0, sp, #8
  106c7e:	f00c ee10 	blx	1138a0 <memcpy>
  106c82:	9b04      	ldr	r3, [sp, #16]
  106c84:	b953      	cbnz	r3, 106c9c <dc_update+0x48>
  106c86:	9b03      	ldr	r3, [sp, #12]
  106c88:	b173      	cbz	r3, 106ca8 <dc_update+0x54>
  106c8a:	9902      	ldr	r1, [sp, #8]
  106c8c:	4648      	mov	r0, r9
  106c8e:	eb09 0381 	add.w	r3, r9, r1, lsl #2
  106c92:	f893 204c 	ldrb.w	r2, [r3, #76]	; 0x4c
  106c96:	b2c9      	uxtb	r1, r1
  106c98:	f7fe ff08 	bl	105aac <dc_clear_layers>
  106c9c:	4648      	mov	r0, r9
  106c9e:	a902      	add	r1, sp, #8
  106ca0:	f7ff fdb2 	bl	106808 <dc_update_layer>
  106ca4:	2800      	cmp	r0, #0
  106ca6:	db6b      	blt.n	106d80 <dc_update+0x12c>
  106ca8:	f8d8 4000 	ldr.w	r4, [r8]
  106cac:	3701      	adds	r7, #1
  106cae:	3678      	adds	r6, #120	; 0x78
  106cb0:	42a7      	cmp	r7, r4
  106cb2:	d275      	bcs.n	106da0 <dc_update+0x14c>
  106cb4:	f8d9 3008 	ldr.w	r3, [r9, #8]
  106cb8:	f8d8 1004 	ldr.w	r1, [r8, #4]
  106cbc:	4431      	add	r1, r6
  106cbe:	2b00      	cmp	r3, #0
  106cc0:	d0db      	beq.n	106c7a <dc_update+0x26>
  106cc2:	688b      	ldr	r3, [r1, #8]
  106cc4:	2b00      	cmp	r3, #0
  106cc6:	d060      	beq.n	106d8a <dc_update+0x136>
  106cc8:	6d8a      	ldr	r2, [r1, #88]	; 0x58
  106cca:	f101 0320 	add.w	r3, r1, #32
  106cce:	6d0d      	ldr	r5, [r1, #80]	; 0x50
  106cd0:	4610      	mov	r0, r2
  106cd2:	f8d9 e010 	ldr.w	r14, [r9, #16]
  106cd6:	f101 0c30 	add.w	r12, r1, #48	; 0x30
  106cda:	f8d9 a014 	ldr.w	r10, [r9, #20]
  106cde:	eb05 0b00 	add.w	r11, r5, r0
  106ce2:	6808      	ldr	r0, [r1, #0]
  106ce4:	9002      	str	r0, [sp, #8]
  106ce6:	68c8      	ldr	r0, [r1, #12]
  106ce8:	9005      	str	r0, [sp, #20]
  106cea:	6908      	ldr	r0, [r1, #16]
  106cec:	9006      	str	r0, [sp, #24]
  106cee:	6948      	ldr	r0, [r1, #20]
  106cf0:	9201      	str	r2, [sp, #4]
  106cf2:	aa0a      	add	r2, sp, #40	; 0x28
  106cf4:	9007      	str	r0, [sp, #28]
  106cf6:	6988      	ldr	r0, [r1, #24]
  106cf8:	9008      	str	r0, [sp, #32]
  106cfa:	69c8      	ldr	r0, [r1, #28]
  106cfc:	9009      	str	r0, [sp, #36]	; 0x24
  106cfe:	f853 0b04 	ldr.w	r0, [r3], #4
  106d02:	f842 0b04 	str.w	r0, [r2], #4
  106d06:	459c      	cmp	r12, r3
  106d08:	68d8      	ldr	r0, [r3, #12]
  106d0a:	60d0      	str	r0, [r2, #12]
  106d0c:	d1f7      	bne.n	106cfe <dc_update+0xaa>
  106d0e:	6e0b      	ldr	r3, [r1, #96]	; 0x60
  106d10:	45de      	cmp	r14, r11
  106d12:	931a      	str	r3, [sp, #104]	; 0x68
  106d14:	bfb8      	it	lt
  106d16:	2200      	movlt	r2, #0
  106d18:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  106d1a:	bfa8      	it	ge
  106d1c:	2201      	movge	r2, #1
  106d1e:	931b      	str	r3, [sp, #108]	; 0x6c
  106d20:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  106d22:	931c      	str	r3, [sp, #112]	; 0x70
  106d24:	f891 306c 	ldrb.w	r3, [r1, #108]	; 0x6c
  106d28:	f88d 3074 	strb.w	r3, [r13, #116]	; 0x74
  106d2c:	6f0b      	ldr	r3, [r1, #112]	; 0x70
  106d2e:	931e      	str	r3, [sp, #120]	; 0x78
  106d30:	6f4b      	ldr	r3, [r1, #116]	; 0x74
  106d32:	931f      	str	r3, [sp, #124]	; 0x7c
  106d34:	6c4b      	ldr	r3, [r1, #68]	; 0x44
  106d36:	9313      	str	r3, [sp, #76]	; 0x4c
  106d38:	6ccb      	ldr	r3, [r1, #76]	; 0x4c
  106d3a:	9315      	str	r3, [sp, #84]	; 0x54
  106d3c:	45aa      	cmp	r10, r5
  106d3e:	bfd8      	it	le
  106d40:	f042 0201 	orrle.w	r2, r2, #1
  106d44:	6d4b      	ldr	r3, [r1, #84]	; 0x54
  106d46:	9317      	str	r3, [sp, #92]	; 0x5c
  106d48:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
  106d4a:	9319      	str	r3, [sp, #100]	; 0x64
  106d4c:	b9ea      	cbnz	r2, 106d8a <dc_update+0x136>
  106d4e:	6c08      	ldr	r0, [r1, #64]	; 0x40
  106d50:	45ae      	cmp	r14, r5
  106d52:	bfcc      	ite	gt
  106d54:	2200      	movgt	r2, #0
  106d56:	2201      	movle	r2, #1
  106d58:	45da      	cmp	r10, r11
  106d5a:	bfb8      	it	lt
  106d5c:	2200      	movlt	r2, #0
  106d5e:	bb1a      	cbnz	r2, 106da8 <dc_update+0x154>
  106d60:	2301      	movs	r3, #1
  106d62:	45ae      	cmp	r14, r5
  106d64:	9304      	str	r3, [sp, #16]
  106d66:	dc2a      	bgt.n	106dbe <dc_update+0x16a>
  106d68:	9012      	str	r0, [sp, #72]	; 0x48
  106d6a:	ebaa 0305 	sub.w	r3, r10, r5
  106d6e:	4648      	mov	r0, r9
  106d70:	a902      	add	r1, sp, #8
  106d72:	9314      	str	r3, [sp, #80]	; 0x50
  106d74:	9318      	str	r3, [sp, #96]	; 0x60
  106d76:	9516      	str	r5, [sp, #88]	; 0x58
  106d78:	f7ff fd46 	bl	106808 <dc_update_layer>
  106d7c:	2800      	cmp	r0, #0
  106d7e:	da93      	bge.n	106ca8 <dc_update+0x54>
  106d80:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  106d84:	b021      	add	sp, #132	; 0x84
  106d86:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  106d8a:	9b03      	ldr	r3, [sp, #12]
  106d8c:	2200      	movs	r2, #0
  106d8e:	9204      	str	r2, [sp, #16]
  106d90:	2b00      	cmp	r3, #0
  106d92:	f47f af7a 	bne.w	106c8a <dc_update+0x36>
  106d96:	3701      	adds	r7, #1
  106d98:	42a7      	cmp	r7, r4
  106d9a:	f106 0678 	add.w	r6, r6, #120	; 0x78
  106d9e:	d389      	bcc.n	106cb4 <dc_update+0x60>
  106da0:	2000      	movs	r0, #0
  106da2:	b021      	add	sp, #132	; 0x84
  106da4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  106da8:	6c8b      	ldr	r3, [r1, #72]	; 0x48
  106daa:	eba5 050e 	sub.w	r5, r5, r14
  106dae:	9314      	str	r3, [sp, #80]	; 0x50
  106db0:	2301      	movs	r3, #1
  106db2:	9516      	str	r5, [sp, #88]	; 0x58
  106db4:	9304      	str	r3, [sp, #16]
  106db6:	9b01      	ldr	r3, [sp, #4]
  106db8:	9012      	str	r0, [sp, #72]	; 0x48
  106dba:	9318      	str	r3, [sp, #96]	; 0x60
  106dbc:	e76e      	b.n	106c9c <dc_update+0x48>
  106dbe:	ebae 0505 	sub.w	r5, r14, r5
  106dc2:	ebab 030e 	sub.w	r3, r11, r14
  106dc6:	9216      	str	r2, [sp, #88]	; 0x58
  106dc8:	4428      	add	r0, r5
  106dca:	9314      	str	r3, [sp, #80]	; 0x50
  106dcc:	9012      	str	r0, [sp, #72]	; 0x48
  106dce:	9318      	str	r3, [sp, #96]	; 0x60
  106dd0:	e764      	b.n	106c9c <dc_update+0x48>
  106dd2:	bf00      	nop

00106dd4 <lvds_init>:
  106dd4:	2000      	movs	r0, #0
  106dd6:	4770      	bx	r14

00106dd8 <lvds_channel_config>:
  106dd8:	b4f0      	push	{r4, r5, r6, r7}
  106dda:	e9d1 3400 	ldrd	r3, r4, [r1]
  106dde:	688f      	ldr	r7, [r1, #8]
  106de0:	1c5e      	adds	r6, r3, #1
  106de2:	0436      	lsls	r6, r6, #16
  106de4:	5832      	ldr	r2, [r6, r0]
  106de6:	2c02      	cmp	r4, #2
  106de8:	bf14      	ite	ne
  106dea:	4615      	movne	r5, r2
  106dec:	f082 0501 	eoreq.w	r5, r2, #1
  106df0:	f005 0501 	and.w	r5, r5, #1
  106df4:	406a      	eors	r2, r5
  106df6:	ea82 0547 	eor.w	r5, r2, r7, lsl #1
  106dfa:	f005 0506 	and.w	r5, r5, #6
  106dfe:	4055      	eors	r5, r2
  106e00:	68ca      	ldr	r2, [r1, #12]
  106e02:	2f02      	cmp	r7, #2
  106e04:	ea85 02c2 	eor.w	r2, r5, r2, lsl #3
  106e08:	f002 0208 	and.w	r2, r2, #8
  106e0c:	ea85 0502 	eor.w	r5, r5, r2
  106e10:	690a      	ldr	r2, [r1, #16]
  106e12:	ea85 1202 	eor.w	r2, r5, r2, lsl #4
  106e16:	f002 0210 	and.w	r2, r2, #16
  106e1a:	ea82 0205 	eor.w	r2, r2, r5
  106e1e:	d008      	beq.n	106e32 <lvds_channel_config+0x5a>
  106e20:	2c02      	cmp	r4, #2
  106e22:	d010      	beq.n	106e46 <lvds_channel_config+0x6e>
  106e24:	bb6c      	cbnz	r4, 106e82 <lvds_channel_config+0xaa>
  106e26:	f033 0302 	bics.w	r3, r3, #2
  106e2a:	bf18      	it	ne
  106e2c:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
  106e30:	e00f      	b.n	106e52 <lvds_channel_config+0x7a>
  106e32:	2c02      	cmp	r4, #2
  106e34:	d107      	bne.n	106e46 <lvds_channel_config+0x6e>
  106e36:	2b01      	cmp	r3, #1
  106e38:	bf85      	ittet	hi
  106e3a:	43d4      	mvnhi	r4, r2
  106e3c:	f404 0480 	andhi.w	r4, r4, #4194304	; 0x400000
  106e40:	f422 0280 	bicls.w	r2, r2, #4194304	; 0x400000
  106e44:	4062      	eorhi	r2, r4
  106e46:	f033 0302 	bics.w	r3, r3, #2
  106e4a:	bf14      	ite	ne
  106e4c:	f44f 0300 	movne.w	r3, #8388608	; 0x800000
  106e50:	2300      	moveq	r3, #0
  106e52:	4053      	eors	r3, r2
  106e54:	f003 73c0 	and.w	r3, r3, #25165824	; 0x1800000
  106e58:	4053      	eors	r3, r2
  106e5a:	43da      	mvns	r2, r3
  106e5c:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
  106e60:	f500 3480 	add.w	r4, r0, #65536	; 0x10000
  106e64:	405a      	eors	r2, r3
  106e66:	f640 158f 	movw	r5, #2447	; 0x98f
  106e6a:	3410      	adds	r4, #16
  106e6c:	5032      	str	r2, [r6, r0]
  106e6e:	2300      	movs	r3, #0
  106e70:	680a      	ldr	r2, [r1, #0]
  106e72:	eb04 4202 	add.w	r2, r4, r2, lsl #16
  106e76:	50d5      	str	r5, [r2, r3]
  106e78:	3304      	adds	r3, #4
  106e7a:	2b14      	cmp	r3, #20
  106e7c:	d1f8      	bne.n	106e70 <lvds_channel_config+0x98>
  106e7e:	bcf0      	pop	{r4, r5, r6, r7}
  106e80:	4770      	bx	r14
  106e82:	2300      	movs	r3, #0
  106e84:	e7e5      	b.n	106e52 <lvds_channel_config+0x7a>
  106e86:	bf00      	nop

00106e88 <lvds_config>:
  106e88:	f64e 43d0 	movw	r3, #60624	; 0xecd0
  106e8c:	f2c0 0312 	movt	r3, #18
  106e90:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  106e94:	681d      	ldr	r5, [r3, #0]
  106e96:	4606      	mov	r6, r0
  106e98:	460f      	mov	r7, r1
  106e9a:	b925      	cbnz	r5, 106ea6 <lvds_config+0x1e>
  106e9c:	2200      	movs	r2, #0
  106e9e:	f2cf 02c4 	movt	r2, #61636	; 0xf0c4
  106ea2:	4615      	mov	r5, r2
  106ea4:	601a      	str	r2, [r3, #0]
  106ea6:	2101      	movs	r1, #1
  106ea8:	2014      	movs	r0, #20
  106eaa:	f00a fb57 	bl	11155c <calloc>
  106eae:	4604      	mov	r4, r0
  106eb0:	b350      	cbz	r0, 106f08 <lvds_config+0x80>
  106eb2:	6933      	ldr	r3, [r6, #16]
  106eb4:	2b03      	cmp	r3, #3
  106eb6:	bf93      	iteet	ls
  106eb8:	f648 1220 	movwls	r2, #35104	; 0x8920
  106ebc:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
  106ec0:	4698      	movhi	r8, r3
  106ec2:	f2c0 0211 	movtls	r2, #17
  106ec6:	bf98      	it	ls
  106ec8:	f852 8023 	ldrls.w	r8, [r2, r3, lsl #2]
  106ecc:	6a3a      	ldr	r2, [r7, #32]
  106ece:	bf98      	it	ls
  106ed0:	4643      	movls	r3, r8
  106ed2:	f1b8 0f02 	cmp.w	r8, #2
  106ed6:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  106ed8:	6b50      	ldr	r0, [r2, #52]	; 0x34
  106eda:	e9c4 0103 	strd	r0, r1, [r4, #12]
  106ede:	60a3      	str	r3, [r4, #8]
  106ee0:	68e9      	ldr	r1, [r5, #12]
  106ee2:	ea6f 0301 	mvn.w	r3, r1
  106ee6:	f003 0301 	and.w	r3, r3, #1
  106eea:	ea83 0301 	eor.w	r3, r3, r1
  106eee:	60eb      	str	r3, [r5, #12]
  106ef0:	d00c      	beq.n	106f0c <lvds_config+0x84>
  106ef2:	68f7      	ldr	r7, [r6, #12]
  106ef4:	b1ff      	cbz	r7, 106f36 <lvds_config+0xae>
  106ef6:	2f02      	cmp	r7, #2
  106ef8:	d035      	beq.n	106f66 <lvds_config+0xde>
  106efa:	2f01      	cmp	r7, #1
  106efc:	d072      	beq.n	106fe4 <lvds_config+0x15c>
  106efe:	4620      	mov	r0, r4
  106f00:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  106f04:	f00a bb3a 	b.w	11157c <free>
  106f08:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  106f0c:	68f3      	ldr	r3, [r6, #12]
  106f0e:	b9db      	cbnz	r3, 106f48 <lvds_config+0xc0>
  106f10:	6872      	ldr	r2, [r6, #4]
  106f12:	6063      	str	r3, [r4, #4]
  106f14:	2a07      	cmp	r2, #7
  106f16:	d070      	beq.n	106ffa <lvds_config+0x172>
  106f18:	2a08      	cmp	r2, #8
  106f1a:	d1f0      	bne.n	106efe <lvds_config+0x76>
  106f1c:	4621      	mov	r1, r4
  106f1e:	4628      	mov	r0, r5
  106f20:	f8c4 8000 	str.w	r8, [r4]
  106f24:	f7ff ff58 	bl	106dd8 <lvds_channel_config>
  106f28:	2303      	movs	r3, #3
  106f2a:	4628      	mov	r0, r5
  106f2c:	4621      	mov	r1, r4
  106f2e:	6023      	str	r3, [r4, #0]
  106f30:	f7ff ff52 	bl	106dd8 <lvds_channel_config>
  106f34:	e7e3      	b.n	106efe <lvds_config+0x76>
  106f36:	6873      	ldr	r3, [r6, #4]
  106f38:	6067      	str	r7, [r4, #4]
  106f3a:	3b03      	subs	r3, #3
  106f3c:	2b03      	cmp	r3, #3
  106f3e:	d8de      	bhi.n	106efe <lvds_config+0x76>
  106f40:	e8df f003 	tbb	[r15, r3]
  106f44:	26373134 	.word	0x26373134
  106f48:	2b02      	cmp	r3, #2
  106f4a:	d1d8      	bne.n	106efe <lvds_config+0x76>
  106f4c:	2300      	movs	r3, #0
  106f4e:	4621      	mov	r1, r4
  106f50:	f8c4 8004 	str.w	r8, [r4, #4]
  106f54:	4628      	mov	r0, r5
  106f56:	6023      	str	r3, [r4, #0]
  106f58:	f7ff ff3e 	bl	106dd8 <lvds_channel_config>
  106f5c:	2301      	movs	r3, #1
  106f5e:	6023      	str	r3, [r4, #0]
  106f60:	f7ff ff3a 	bl	106dd8 <lvds_channel_config>
  106f64:	e7da      	b.n	106f1c <lvds_config+0x94>
  106f66:	6873      	ldr	r3, [r6, #4]
  106f68:	6067      	str	r7, [r4, #4]
  106f6a:	2b08      	cmp	r3, #8
  106f6c:	d036      	beq.n	106fdc <lvds_config+0x154>
  106f6e:	2b0a      	cmp	r3, #10
  106f70:	d022      	beq.n	106fb8 <lvds_config+0x130>
  106f72:	2b07      	cmp	r3, #7
  106f74:	d1c3      	bne.n	106efe <lvds_config+0x76>
  106f76:	2300      	movs	r3, #0
  106f78:	4621      	mov	r1, r4
  106f7a:	4628      	mov	r0, r5
  106f7c:	6023      	str	r3, [r4, #0]
  106f7e:	f7ff ff2b 	bl	106dd8 <lvds_channel_config>
  106f82:	2301      	movs	r3, #1
  106f84:	4628      	mov	r0, r5
  106f86:	4621      	mov	r1, r4
  106f88:	6023      	str	r3, [r4, #0]
  106f8a:	f7ff ff25 	bl	106dd8 <lvds_channel_config>
  106f8e:	e7b6      	b.n	106efe <lvds_config+0x76>
  106f90:	2303      	movs	r3, #3
  106f92:	6023      	str	r3, [r4, #0]
  106f94:	4628      	mov	r0, r5
  106f96:	4621      	mov	r1, r4
  106f98:	f7ff ff1e 	bl	106dd8 <lvds_channel_config>
  106f9c:	4620      	mov	r0, r4
  106f9e:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  106fa2:	f00a baeb 	b.w	11157c <free>
  106fa6:	2301      	movs	r3, #1
  106fa8:	6023      	str	r3, [r4, #0]
  106faa:	e7f3      	b.n	106f94 <lvds_config+0x10c>
  106fac:	2300      	movs	r3, #0
  106fae:	6023      	str	r3, [r4, #0]
  106fb0:	e7f0      	b.n	106f94 <lvds_config+0x10c>
  106fb2:	2302      	movs	r3, #2
  106fb4:	6023      	str	r3, [r4, #0]
  106fb6:	e7ed      	b.n	106f94 <lvds_config+0x10c>
  106fb8:	6853      	ldr	r3, [r2, #4]
  106fba:	2600      	movs	r6, #0
  106fbc:	68aa      	ldr	r2, [r5, #8]
  106fbe:	4621      	mov	r1, r4
  106fc0:	4628      	mov	r0, r5
  106fc2:	085b      	lsrs	r3, r3, #1
  106fc4:	3b01      	subs	r3, #1
  106fc6:	4053      	eors	r3, r2
  106fc8:	b29b      	uxth	r3, r3
  106fca:	4053      	eors	r3, r2
  106fcc:	60ab      	str	r3, [r5, #8]
  106fce:	6026      	str	r6, [r4, #0]
  106fd0:	f7ff ff02 	bl	106dd8 <lvds_channel_config>
  106fd4:	2301      	movs	r3, #1
  106fd6:	6023      	str	r3, [r4, #0]
  106fd8:	f7ff fefe 	bl	106dd8 <lvds_channel_config>
  106fdc:	6027      	str	r7, [r4, #0]
  106fde:	4621      	mov	r1, r4
  106fe0:	4628      	mov	r0, r5
  106fe2:	e79f      	b.n	106f24 <lvds_config+0x9c>
  106fe4:	6873      	ldr	r3, [r6, #4]
  106fe6:	6067      	str	r7, [r4, #4]
  106fe8:	2b07      	cmp	r3, #7
  106fea:	d00a      	beq.n	107002 <lvds_config+0x17a>
  106fec:	2b08      	cmp	r3, #8
  106fee:	d186      	bne.n	106efe <lvds_config+0x76>
  106ff0:	2302      	movs	r3, #2
  106ff2:	4621      	mov	r1, r4
  106ff4:	4628      	mov	r0, r5
  106ff6:	6023      	str	r3, [r4, #0]
  106ff8:	e794      	b.n	106f24 <lvds_config+0x9c>
  106ffa:	6023      	str	r3, [r4, #0]
  106ffc:	4621      	mov	r1, r4
  106ffe:	4628      	mov	r0, r5
  107000:	e7bd      	b.n	106f7e <lvds_config+0xf6>
  107002:	2300      	movs	r3, #0
  107004:	4621      	mov	r1, r4
  107006:	4628      	mov	r0, r5
  107008:	6023      	str	r3, [r4, #0]
  10700a:	f7ff fee5 	bl	106dd8 <lvds_channel_config>
  10700e:	6027      	str	r7, [r4, #0]
  107010:	e7c0      	b.n	106f94 <lvds_config+0x10c>
  107012:	bf00      	nop

00107014 <lvds_deinit>:
  107014:	2000      	movs	r0, #0
  107016:	4770      	bx	r14

00107018 <parallel_init>:
  107018:	2000      	movs	r0, #0
  10701a:	4770      	bx	r14

0010701c <parallel_config>:
  10701c:	4770      	bx	r14
  10701e:	bf00      	nop

00107020 <parallel_deinit>:
  107020:	2000      	movs	r0, #0
  107022:	4770      	bx	r14

00107024 <dw_i2c_config>:
    i2c_reg->ic_tx_tl = p_i2c_con->tx_fifo_depth / 2;
    i2c_reg->ic_rx_tl = 0;
}

static bool dw_i2c_config(dw_i2c_context *p_i2c_con, uint32_t addr)
{
  107024:	4603      	mov	r3, r0
    dw_i2c_config_t *info = &p_i2c_con->info;
    addr_t io_base = info->io_base;
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)io_base;

    if (!p_i2c_con->is_added)
  107026:	f890 0021 	ldrb.w	r0, [r0, #33]	; 0x21
  10702a:	2800      	cmp	r0, #0
  10702c:	d04d      	beq.n	1070ca <dw_i2c_config+0xa6>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)io_base;
  10702e:	681a      	ldr	r2, [r3, #0]
{
  107030:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  107034:	7c1c      	ldrb	r4, [r3, #16]
        return false;

    dprintf(I2C_LOG, "dw_i2c_config(%d, 0x%x) io_base=0x%lx\n", p_i2c_con->bus,
            addr, io_base);
    /* configure */
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  107036:	6ed6      	ldr	r6, [r2, #108]	; 0x6c
    /* idle time */
    uint32_t val;
    val =
        0x20
        << IC_SMBUS_THIGH_MAX_IDLE_COUNT_SMBUS_THIGH_MAX_BUS_IDLE_CNT_FIELD_OFFSET;
    i2c_reg->ic_smbus_thigh_max_idle_count = val;
  107038:	f04f 0e20 	mov.w	r14, #32
    /* speed, addr mode, master mode, */
    /* speed */
    val = info->speed << IC_CON_SPEED_FIELD_OFFSET;
  10703c:	f8d3 c004 	ldr.w	r12, [r3, #4]
  107040:	0165      	lsls	r5, r4, #5

    /* addr bits */
    if (info->mode == SLAVE_MODE) {
  107042:	68df      	ldr	r7, [r3, #12]
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  107044:	f026 0601 	bic.w	r6, r6, #1
  107048:	f8d3 8008 	ldr.w	r8, [r3, #8]
  10704c:	66d6      	str	r6, [r2, #108]	; 0x6c
    val = info->speed << IC_CON_SPEED_FIELD_OFFSET;
  10704e:	ea4f 044c 	mov.w	r4, r12, lsl #1
    i2c_reg->ic_smbus_thigh_max_idle_count = val;
  107052:	f8c2 e0c4 	str.w	r14, [r2, #196]	; 0xc4
    if (info->mode == SLAVE_MODE) {
  107056:	bb0f      	cbnz	r7, 10709c <dw_i2c_config+0x78>
        val |= info->addr_bits << IC_CON_IC_10BITADDR_SLAVE_FIELD_OFFSET;
  107058:	ea44 04c8 	orr.w	r4, r4, r8, lsl #3

    /* master/slave mode */
    val |= info->mode << IC_CON_IC_SLAVE_DISABLE_FIELD_OFFSET;
    val |= info->mode << IC_CON_MASTER_MODE_FIELD_OFFSET;
    /* restart en */
    val |= info->restart << IC_CON_IC_RESTART_EN_FIELD_OFFSET;
  10705c:	432c      	orrs	r4, r5
    i2c_reg->ic_con = val;
  10705e:	6014      	str	r4, [r2, #0]
    }

    /* target addr */
    if (info->mode == SLAVE_MODE) {
        val = addr << IC_SAR_IC_SAR_FIELD_OFFSET;
        i2c_reg->ic_sar = val;
  107060:	6091      	str	r1, [r2, #8]
        val = 0 << IC_TAR_SPECIAL_FIELD_OFFSET;
        val |= addr << IC_TAR_IC_TAR_FIELD_OFFSET;
        i2c_reg->ic_tar = val;
    }

    p_i2c_con->tx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 16) & 0xff) + 1;
  107062:	f8d2 40f4 	ldr.w	r4, [r2, #244]	; 0xf4
    i2c_reg->ic_rx_tl = 0;
  107066:	2600      	movs	r6, #0
    p_i2c_con->rx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 8) & 0xff) + 1;
  107068:	f8d2 50f4 	ldr.w	r5, [r2, #244]	; 0xf4
    p_i2c_con->tx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 16) & 0xff) + 1;
  10706c:	f3c4 4407 	ubfx	r4, r4, #16, #8
    p_i2c_con->rx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 8) & 0xff) + 1;
  107070:	f3c5 2507 	ubfx	r5, r5, #8, #8
    p_i2c_con->tx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 16) & 0xff) + 1;
  107074:	3401      	adds	r4, #1
    p_i2c_con->rx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 8) & 0xff) + 1;
  107076:	3501      	adds	r5, #1
    i2c_reg->ic_tx_tl = p_i2c_con->tx_fifo_depth / 2;
  107078:	0867      	lsrs	r7, r4, #1
    p_i2c_con->rx_fifo_depth = ((i2c_reg->ic_comp_param_1 >> 8) & 0xff) + 1;
  10707a:	e9c3 451b 	strd	r4, r5, [r3, #108]	; 0x6c
            i2c_reg->ic_comp_param_1, p_i2c_con->tx_fifo_depth,
            p_i2c_con->rx_fifo_depth);
    dw_i2c_configure_fifo(p_i2c_con);

    /* enable */
    if (p_i2c_con->info.poll == 1)
  10707e:	69dc      	ldr	r4, [r3, #28]
    i2c_reg->ic_tx_tl = p_i2c_con->tx_fifo_depth / 2;
  107080:	63d7      	str	r7, [r2, #60]	; 0x3c
    i2c_reg->ic_rx_tl = 0;
  107082:	6396      	str	r6, [r2, #56]	; 0x38
    if (p_i2c_con->info.poll == 1)
  107084:	2c01      	cmp	r4, #1
        i2c_reg->ic_enable |= 0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET;
  107086:	bf02      	ittt	eq
  107088:	6ed4      	ldreq	r4, [r2, #108]	; 0x6c
  10708a:	f044 0401 	orreq.w	r4, r4, #1
  10708e:	66d4      	streq	r4, [r2, #108]	; 0x6c

    p_i2c_con->cur_addr = addr;
    p_i2c_con->is_configured = true;
  107090:	2201      	movs	r2, #1
    p_i2c_con->cur_addr = addr;
  107092:	6259      	str	r1, [r3, #36]	; 0x24
    p_i2c_con->is_configured = true;
  107094:	f883 2020 	strb.w	r2, [r3, #32]
    return true;
}
  107098:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10709c:	ea44 1408 	orr.w	r4, r4, r8, lsl #4
  1070a0:	433c      	orrs	r4, r7
    val |= info->mode << IC_CON_MASTER_MODE_FIELD_OFFSET;
  1070a2:	ea44 1487 	orr.w	r4, r4, r7, lsl #6
    val |= info->restart << IC_CON_IC_RESTART_EN_FIELD_OFFSET;
  1070a6:	432c      	orrs	r4, r5
    if (info->mode == MASTER_MODE) {
  1070a8:	2f01      	cmp	r7, #1
    i2c_reg->ic_con = val;
  1070aa:	6014      	str	r4, [r2, #0]
    if (info->mode == MASTER_MODE) {
  1070ac:	d10b      	bne.n	1070c6 <dw_i2c_config+0xa2>
        switch (info->speed) {
  1070ae:	f1bc 0f02 	cmp.w	r12, #2
  1070b2:	d00b      	beq.n	1070cc <dw_i2c_config+0xa8>
  1070b4:	f1bc 0f03 	cmp.w	r12, #3
  1070b8:	d110      	bne.n	1070dc <dw_i2c_config+0xb8>
                i2c_reg->ic_hs_scl_lcnt = val;
  1070ba:	2502      	movs	r5, #2
                i2c_reg->ic_sda_hold = val;
  1070bc:	f04f 1401 	mov.w	r4, #65537	; 0x10001
                i2c_reg->ic_hs_scl_lcnt = val;
  1070c0:	6295      	str	r5, [r2, #40]	; 0x28
                i2c_reg->ic_hs_scl_hcnt = val;
  1070c2:	6257      	str	r7, [r2, #36]	; 0x24
                i2c_reg->ic_sda_hold = val;
  1070c4:	67d4      	str	r4, [r2, #124]	; 0x7c
        i2c_reg->ic_tar = val;
  1070c6:	6051      	str	r1, [r2, #4]
  1070c8:	e7cb      	b.n	107062 <dw_i2c_config+0x3e>
}
  1070ca:	4770      	bx	r14
                i2c_reg->ic_fs_scl_lcnt = val;
  1070cc:	f8c2 e020 	str.w	r14, [r2, #32]
                i2c_reg->ic_sda_hold = val;
  1070d0:	f04f 1410 	mov.w	r4, #1048592	; 0x100010
                i2c_reg->ic_fs_scl_hcnt = val;
  1070d4:	f8c2 e01c 	str.w	r14, [r2, #28]
                i2c_reg->ic_sda_hold = val;
  1070d8:	67d4      	str	r4, [r2, #124]	; 0x7c
                break;
  1070da:	e7f4      	b.n	1070c6 <dw_i2c_config+0xa2>
                i2c_reg->ic_ss_scl_lcnt = val;
  1070dc:	2680      	movs	r6, #128	; 0x80
                i2c_reg->ic_ss_scl_hcnt = val;
  1070de:	2560      	movs	r5, #96	; 0x60
                i2c_reg->ic_sda_hold = val;
  1070e0:	f04f 1440 	mov.w	r4, #4194368	; 0x400040
                i2c_reg->ic_ss_scl_lcnt = val;
  1070e4:	6196      	str	r6, [r2, #24]
                i2c_reg->ic_ss_scl_hcnt = val;
  1070e6:	6155      	str	r5, [r2, #20]
                i2c_reg->ic_sda_hold = val;
  1070e8:	67d4      	str	r4, [r2, #124]	; 0x7c
                break;
  1070ea:	e7ec      	b.n	1070c6 <dw_i2c_config+0xa2>

001070ec <i2c_irq_handler>:
        intr_mask &= ~DW_IC_INTR_TX_EMPTY;

    i2c_reg->ic_intr_mask = intr_mask;
}
static enum handler_return i2c_irq_handler(void *data)
{
  1070ec:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    dw_i2c_context *p_i2c_con = (dw_i2c_context *)data;
    enum handler_return ret = INT_NO_RESCHEDULE;
    dw_i2c_config_t *info = &p_i2c_con->info;
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  1070f0:	6805      	ldr	r5, [r0, #0]
{
  1070f2:	b087      	sub	sp, #28
  1070f4:	4604      	mov	r4, r0
    u32 stat;
    mask_interrupt(info->irq);
  1070f6:	6980      	ldr	r0, [r0, #24]
  1070f8:	f7f9 fb40 	bl	10077c <mask_interrupt>

    if (!i2c_reg->ic_enable || !i2c_reg->ic_raw_intr_stat) {
  1070fc:	6eeb      	ldr	r3, [r5, #108]	; 0x6c
  1070fe:	b10b      	cbz	r3, 107104 <i2c_irq_handler+0x18>
  107100:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  107102:	b933      	cbnz	r3, 107112 <i2c_irq_handler+0x26>
    if ((stat & ((1 << IC_INTR_STAT_R_TX_ABRT_FIELD_OFFSET) |
                 (1 << IC_INTR_STAT_R_STOP_DET_FIELD_OFFSET)))) {
        event_signal(&p_i2c_con->completion, false);
    }

    unmask_interrupt(info->irq);
  107104:	69a0      	ldr	r0, [r4, #24]
  107106:	f7f9 fb61 	bl	1007cc <unmask_interrupt>
    return ret;
}
  10710a:	2000      	movs	r0, #0
  10710c:	b007      	add	sp, #28
  10710e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    stat = i2c_reg->ic_intr_stat;
  107112:	6aef      	ldr	r7, [r5, #44]	; 0x2c
    if (stat & DW_IC_INTR_RX_UNDER)
  107114:	07fb      	lsls	r3, r7, #31
        val += i2c_reg->ic_clr_rx_under;
  107116:	bf48      	it	mi
  107118:	6c6b      	ldrmi	r3, [r5, #68]	; 0x44
    if (stat & DW_IC_INTR_RX_OVER)
  10711a:	07be      	lsls	r6, r7, #30
        val += i2c_reg->ic_clr_rx_over;
  10711c:	bf48      	it	mi
  10711e:	6cab      	ldrmi	r3, [r5, #72]	; 0x48
    if (stat & DW_IC_INTR_TX_OVER)
  107120:	0738      	lsls	r0, r7, #28
        val += i2c_reg->ic_clr_tx_over;
  107122:	bf48      	it	mi
  107124:	6ceb      	ldrmi	r3, [r5, #76]	; 0x4c
    if (stat & DW_IC_INTR_RD_REQ)
  107126:	06b9      	lsls	r1, r7, #26
        val += i2c_reg->ic_clr_rd_req;
  107128:	bf48      	it	mi
  10712a:	6d2b      	ldrmi	r3, [r5, #80]	; 0x50
    if (stat & DW_IC_INTR_TX_ABRT)
  10712c:	f017 0340 	ands.w	r3, r7, #64	; 0x40
        val += i2c_reg->ic_clr_tx_abrt;
  107130:	bf18      	it	ne
  107132:	6d6a      	ldrne	r2, [r5, #84]	; 0x54
    if (stat & DW_IC_INTR_RX_DONE)
  107134:	063a      	lsls	r2, r7, #24
        val += i2c_reg->ic_clr_rx_done;
  107136:	bf48      	it	mi
  107138:	6daa      	ldrmi	r2, [r5, #88]	; 0x58
    if (stat & DW_IC_INTR_ACTIVITY)
  10713a:	05fe      	lsls	r6, r7, #23
        val += i2c_reg->ic_clr_activity;
  10713c:	bf48      	it	mi
  10713e:	6dea      	ldrmi	r2, [r5, #92]	; 0x5c
    if (stat & DW_IC_INTR_STOP_DET)
  107140:	05b8      	lsls	r0, r7, #22
        val += i2c_reg->ic_clr_stop_det;
  107142:	bf48      	it	mi
  107144:	6e2a      	ldrmi	r2, [r5, #96]	; 0x60
    if (stat & DW_IC_INTR_START_DET)
  107146:	0579      	lsls	r1, r7, #21
        val += i2c_reg->ic_clr_start_det;
  107148:	bf48      	it	mi
  10714a:	6e6a      	ldrmi	r2, [r5, #100]	; 0x64
    if (stat & DW_IC_INTR_GEN_CALL)
  10714c:	053a      	lsls	r2, r7, #20
        val += i2c_reg->ic_clr_gen_call;
  10714e:	bf48      	it	mi
  107150:	6eaa      	ldrmi	r2, [r5, #104]	; 0x68
    if (stat & (1 << IC_INTR_STAT_R_TX_ABRT_FIELD_OFFSET)) {
  107152:	b963      	cbnz	r3, 10716e <i2c_irq_handler+0x82>
    if (stat & (1 << IC_INTR_STAT_R_RX_FULL_FIELD_OFFSET))
  107154:	077b      	lsls	r3, r7, #29
  107156:	d410      	bmi.n	10717a <i2c_irq_handler+0x8e>
    if (stat & (1 << IC_INTR_STAT_R_TX_EMPTY_FIELD_OFFSET))
  107158:	06fa      	lsls	r2, r7, #27
  10715a:	d446      	bmi.n	1071ea <i2c_irq_handler+0xfe>
    if ((stat & ((1 << IC_INTR_STAT_R_TX_ABRT_FIELD_OFFSET) |
  10715c:	f417 7f10 	tst.w	r7, #576	; 0x240
  107160:	d0d0      	beq.n	107104 <i2c_irq_handler+0x18>
        event_signal(&p_i2c_con->completion, false);
  107162:	2100      	movs	r1, #0
  107164:	f104 0034 	add.w	r0, r4, #52	; 0x34
  107168:	f00f f986 	bl	116478 <event_signal>
  10716c:	e7ca      	b.n	107104 <i2c_irq_handler+0x18>
        p_i2c_con->abort = DW_IC_ERR_TX_ABRT;
  10716e:	2300      	movs	r3, #0
  107170:	2201      	movs	r2, #1
  107172:	e9c4 3218 	strd	r3, r2, [r4, #96]	; 0x60
        i2c_reg->ic_intr_mask = 0x0;
  107176:	632b      	str	r3, [r5, #48]	; 0x30
        goto tx_aborted;
  107178:	e7f0      	b.n	10715c <i2c_irq_handler+0x70>
    for (; p_i2c_con->msg_read_idx < p_i2c_con->msgs_num;
  10717a:	6d61      	ldr	r1, [r4, #84]	; 0x54
  10717c:	6c60      	ldr	r0, [r4, #68]	; 0x44
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  10717e:	6825      	ldr	r5, [r4, #0]
    for (; p_i2c_con->msg_read_idx < p_i2c_con->msgs_num;
  107180:	4281      	cmp	r1, r0
  107182:	dae9      	bge.n	107158 <i2c_irq_handler+0x6c>
        if (!(p_i2c_con->msgs[p_i2c_con->msg_read_idx].flags & I2C_M_RD))
  107184:	6c22      	ldr	r2, [r4, #64]	; 0x40
  107186:	eb01 0341 	add.w	r3, r1, r1, lsl #1
  10718a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  10718e:	885a      	ldrh	r2, [r3, #2]
  107190:	07d6      	lsls	r6, r2, #31
  107192:	d525      	bpl.n	1071e0 <i2c_irq_handler+0xf4>
        if (!(p_i2c_con->status & STATUS_READ_IN_PROGRESS)) {
  107194:	6e22      	ldr	r2, [r4, #96]	; 0x60
        rx_valid = i2c_reg->ic_rxflr;
  107196:	f8d5 c078 	ldr.w	r12, [r5, #120]	; 0x78
        if (!(p_i2c_con->status & STATUS_READ_IN_PROGRESS)) {
  10719a:	0791      	lsls	r1, r2, #30
            len = p_i2c_con->msgs[p_i2c_con->msg_read_idx].len;
  10719c:	bf56      	itet	pl
  10719e:	889e      	ldrhpl	r6, [r3, #4]
            buf = p_i2c_con->rx_buf;
  1071a0:	e9d4 6016 	ldrdmi	r6, r0, [r4, #88]	; 0x58
            buf = p_i2c_con->msgs[p_i2c_con->msg_read_idx].buf;
  1071a4:	6898      	ldrpl	r0, [r3, #8]
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071a6:	4633      	mov	r3, r6
  1071a8:	2e00      	cmp	r6, #0
  1071aa:	bf18      	it	ne
  1071ac:	f1bc 0f00 	cmpne.w	r12, #0
  1071b0:	dd0e      	ble.n	1071d0 <i2c_irq_handler+0xe4>
            *buf = i2c_reg->ic_data_cmd;
  1071b2:	692a      	ldr	r2, [r5, #16]
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071b4:	3b01      	subs	r3, #1
            *buf = i2c_reg->ic_data_cmd;
  1071b6:	f800 2b01 	strb.w	r2, [r0], #1
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071ba:	eb0c 0203 	add.w	r2, r12, r3
            p_i2c_con->rx_outstanding--;
  1071be:	6ea1      	ldr	r1, [r4, #104]	; 0x68
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071c0:	1b92      	subs	r2, r2, r6
            p_i2c_con->rx_outstanding--;
  1071c2:	3901      	subs	r1, #1
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071c4:	2b00      	cmp	r3, #0
  1071c6:	bf18      	it	ne
  1071c8:	2a00      	cmpne	r2, #0
            p_i2c_con->rx_outstanding--;
  1071ca:	66a1      	str	r1, [r4, #104]	; 0x68
        for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
  1071cc:	dcf1      	bgt.n	1071b2 <i2c_irq_handler+0xc6>
  1071ce:	6e22      	ldr	r2, [r4, #96]	; 0x60
        if (len > 0) {
  1071d0:	2b00      	cmp	r3, #0
  1071d2:	f040 809f 	bne.w	107314 <i2c_irq_handler+0x228>
  1071d6:	6d61      	ldr	r1, [r4, #84]	; 0x54
            p_i2c_con->status &= ~STATUS_READ_IN_PROGRESS;
  1071d8:	f022 0202 	bic.w	r2, r2, #2
  1071dc:	6c60      	ldr	r0, [r4, #68]	; 0x44
  1071de:	6622      	str	r2, [r4, #96]	; 0x60
            p_i2c_con->msg_read_idx++) {
  1071e0:	3101      	adds	r1, #1
    for (; p_i2c_con->msg_read_idx < p_i2c_con->msgs_num;
  1071e2:	4281      	cmp	r1, r0
            p_i2c_con->msg_read_idx++) {
  1071e4:	6561      	str	r1, [r4, #84]	; 0x54
    for (; p_i2c_con->msg_read_idx < p_i2c_con->msgs_num;
  1071e6:	dbcd      	blt.n	107184 <i2c_irq_handler+0x98>
  1071e8:	e7b6      	b.n	107158 <i2c_irq_handler+0x6c>
    for (; p_i2c_con->msg_write_idx < p_i2c_con->msgs_num;
  1071ea:	e9d4 5a11 	ldrd	r5, r10, [r4, #68]	; 0x44
  1071ee:	9502      	str	r5, [sp, #8]
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  1071f0:	f8d4 9000 	ldr.w	r9, [r4]
    for (; p_i2c_con->msg_write_idx < p_i2c_con->msgs_num;
  1071f4:	45aa      	cmp	r10, r5
    u32 buf_len = p_i2c_con->tx_buf_len;
  1071f6:	e9d4 2113 	ldrd	r2, r1, [r4, #76]	; 0x4c
    for (; p_i2c_con->msg_write_idx < p_i2c_con->msgs_num;
  1071fa:	da5d      	bge.n	1072b8 <i2c_irq_handler+0x1cc>
        tx_limit = p_i2c_con->tx_fifo_depth - i2c_reg->ic_txflr;
  1071fc:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
  1071fe:	eb0a 034a 	add.w	r3, r10, r10, lsl #1
        rx_limit = p_i2c_con->rx_fifo_depth - i2c_reg->ic_rxflr;
  107202:	6f26      	ldr	r6, [r4, #112]	; 0x70
        tx_limit = p_i2c_con->tx_fifo_depth - i2c_reg->ic_txflr;
  107204:	9003      	str	r0, [sp, #12]
  107206:	009b      	lsls	r3, r3, #2
    bool need_restart = false;
  107208:	2000      	movs	r0, #0
            if ((p_i2c_con->msg_write_idx == p_i2c_con->msgs_num - 1)
  10720a:	46b0      	mov	r8, r6
  10720c:	9300      	str	r3, [sp, #0]
  10720e:	6e23      	ldr	r3, [r4, #96]	; 0x60
  107210:	9301      	str	r3, [sp, #4]
  107212:	1e6b      	subs	r3, r5, #1
  107214:	e9cd 3704 	strd	r3, r7, [r13, #16]
        if (!(p_i2c_con->status & STATUS_WRITE_IN_PROGRESS)) {
  107218:	9b01      	ldr	r3, [sp, #4]
  10721a:	07db      	lsls	r3, r3, #31
  10721c:	d408      	bmi.n	107230 <i2c_irq_handler+0x144>
            buf = p_i2c_con->msgs[p_i2c_con->msg_write_idx].buf;
  10721e:	9a00      	ldr	r2, [sp, #0]
                need_restart = true;
  107220:	f1ba 0f00 	cmp.w	r10, #0
            buf = p_i2c_con->msgs[p_i2c_con->msg_write_idx].buf;
  107224:	6c23      	ldr	r3, [r4, #64]	; 0x40
                need_restart = true;
  107226:	bfc8      	it	gt
  107228:	2001      	movgt	r0, #1
            buf = p_i2c_con->msgs[p_i2c_con->msg_write_idx].buf;
  10722a:	4413      	add	r3, r2
            buf_len = p_i2c_con->msgs[p_i2c_con->msg_write_idx].len;
  10722c:	889a      	ldrh	r2, [r3, #4]
            buf = p_i2c_con->msgs[p_i2c_con->msg_write_idx].buf;
  10722e:	6899      	ldr	r1, [r3, #8]
        tx_limit = p_i2c_con->tx_fifo_depth - i2c_reg->ic_txflr;
  107230:	f8d9 7074 	ldr.w	r7, [r9, #116]	; 0x74
  107234:	9b03      	ldr	r3, [sp, #12]
        rx_limit = p_i2c_con->rx_fifo_depth - i2c_reg->ic_rxflr;
  107236:	f8d9 5078 	ldr.w	r5, [r9, #120]	; 0x78
        tx_limit = p_i2c_con->tx_fifo_depth - i2c_reg->ic_txflr;
  10723a:	1bdf      	subs	r7, r3, r7
        rx_limit = p_i2c_con->rx_fifo_depth - i2c_reg->ic_rxflr;
  10723c:	eba8 0505 	sub.w	r5, r8, r5
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  107240:	2a00      	cmp	r2, #0
  107242:	bf18      	it	ne
  107244:	2f00      	cmpne	r7, #0
  107246:	dd4f      	ble.n	1072e8 <i2c_irq_handler+0x1fc>
  107248:	2d00      	cmp	r5, #0
  10724a:	dd2e      	ble.n	1072aa <i2c_irq_handler+0x1be>
            if (p_i2c_con->msgs[p_i2c_con->msg_write_idx].flags & I2C_M_RD) {
  10724c:	9e00      	ldr	r6, [sp, #0]
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  10724e:	1abf      	subs	r7, r7, r2
            if (p_i2c_con->msgs[p_i2c_con->msg_write_idx].flags & I2C_M_RD) {
  107250:	6c23      	ldr	r3, [r4, #64]	; 0x40
  107252:	4433      	add	r3, r6
            if ((p_i2c_con->msg_write_idx == p_i2c_con->msgs_num - 1)
  107254:	9e04      	ldr	r6, [sp, #16]
  107256:	eba6 0b0a 	sub.w	r11, r6, r10
  10725a:	885e      	ldrh	r6, [r3, #2]
  10725c:	fabb fb8b 	clz	r11, r11
  107260:	f006 0601 	and.w	r6, r6, #1
  107264:	ea4f 1b5b 	mov.w	r11, r11, lsr #5
                    && (buf_len == 1))    //
  107268:	2a01      	cmp	r2, #1
  10726a:	bf14      	ite	ne
  10726c:	2300      	movne	r3, #0
  10726e:	f00b 0301 	andeq.w	r3, r11, #1
                i2c_reg->ic_data_cmd = cmd | *buf++;
  107272:	f101 0c01 	add.w	r12, r1, #1
            u32 cmd = 0;
  107276:	025b      	lsls	r3, r3, #9
            if (need_restart) {
  107278:	b108      	cbz	r0, 10727e <i2c_irq_handler+0x192>
                cmd |= 1 << IC_DATA_CMD_RESTART_FIELD_OFFSET;       //restart
  10727a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
                i2c_reg->ic_data_cmd = cmd | 0x100; //0x100: [8]    //0:write   1:read
  10727e:	f443 7e80 	orr.w	r14, r3, #256	; 0x100
            if (p_i2c_con->msgs[p_i2c_con->msg_write_idx].flags & I2C_M_RD) {
  107282:	b31e      	cbz	r6, 1072cc <i2c_irq_handler+0x1e0>
                if (p_i2c_con->rx_outstanding >= (int)p_i2c_con->rx_fifo_depth)
  107284:	6ea3      	ldr	r3, [r4, #104]	; 0x68
                rx_limit--;
  107286:	3d01      	subs	r5, #1
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  107288:	2000      	movs	r0, #0
                if (p_i2c_con->rx_outstanding >= (int)p_i2c_con->rx_fifo_depth)
  10728a:	4543      	cmp	r3, r8
                p_i2c_con->rx_outstanding++;
  10728c:	f103 0c01 	add.w	r12, r3, #1
                if (p_i2c_con->rx_outstanding >= (int)p_i2c_con->rx_fifo_depth)
  107290:	da0b      	bge.n	1072aa <i2c_irq_handler+0x1be>
                i2c_reg->ic_data_cmd = cmd | 0x100; //0x100: [8]    //0:write   1:read
  107292:	f8c9 e010 	str.w	r14, [r9, #16]
            buf_len--;
  107296:	3a01      	subs	r2, #1
                p_i2c_con->rx_outstanding++;
  107298:	f8c4 c068 	str.w	r12, [r4, #104]	; 0x68
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  10729c:	18bb      	adds	r3, r7, r2
  10729e:	4282      	cmp	r2, r0
  1072a0:	bf18      	it	ne
  1072a2:	4283      	cmpne	r3, r0
  1072a4:	dd34      	ble.n	107310 <i2c_irq_handler+0x224>
  1072a6:	2d00      	cmp	r5, #0
  1072a8:	d1de      	bne.n	107268 <i2c_irq_handler+0x17c>
  1072aa:	9f05      	ldr	r7, [sp, #20]
        p_i2c_con->tx_buf_len = buf_len;
  1072ac:	e9c4 2113 	strd	r2, r1, [r4, #76]	; 0x4c
            p_i2c_con->status |= STATUS_WRITE_IN_PROGRESS;
  1072b0:	9b01      	ldr	r3, [sp, #4]
  1072b2:	f043 0301 	orr.w	r3, r3, #1
  1072b6:	6623      	str	r3, [r4, #96]	; 0x60
    u32 intr_mask = DW_IC_INTR_MASTER_MASK;
  1072b8:	9b02      	ldr	r3, [sp, #8]
  1072ba:	459a      	cmp	r10, r3
  1072bc:	bf0c      	ite	eq
  1072be:	f44f 7311 	moveq.w	r3, #580	; 0x244
  1072c2:	f44f 7315 	movne.w	r3, #596	; 0x254
    i2c_reg->ic_intr_mask = intr_mask;
  1072c6:	f8c9 3030 	str.w	r3, [r9, #48]	; 0x30
  1072ca:	e747      	b.n	10715c <i2c_irq_handler+0x70>
            buf_len--;
  1072cc:	3a01      	subs	r2, #1
                i2c_reg->ic_data_cmd = cmd | *buf++;
  1072ce:	7809      	ldrb	r1, [r1, #0]
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  1072d0:	18b8      	adds	r0, r7, r2
                i2c_reg->ic_data_cmd = cmd | *buf++;
  1072d2:	430b      	orrs	r3, r1
  1072d4:	4661      	mov	r1, r12
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  1072d6:	2a00      	cmp	r2, #0
  1072d8:	bf18      	it	ne
  1072da:	2800      	cmpne	r0, #0
                i2c_reg->ic_data_cmd = cmd | *buf++;
  1072dc:	f8c9 3010 	str.w	r3, [r9, #16]
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  1072e0:	4630      	mov	r0, r6
  1072e2:	dcc1      	bgt.n	107268 <i2c_irq_handler+0x17c>
  1072e4:	4661      	mov	r1, r12
            buf_len--;
  1072e6:	2000      	movs	r0, #0
        p_i2c_con->tx_buf_len = buf_len;
  1072e8:	e9c4 2113 	strd	r2, r1, [r4, #76]	; 0x4c
        if (buf_len > 0) {
  1072ec:	b9c2      	cbnz	r2, 107320 <i2c_irq_handler+0x234>
            p_i2c_con->status &= ~STATUS_WRITE_IN_PROGRESS;
  1072ee:	9b01      	ldr	r3, [sp, #4]
  1072f0:	f10a 0a01 	add.w	r10, r10, #1
            p_i2c_con->msg_write_idx++) {
  1072f4:	f8c4 a048 	str.w	r10, [r4, #72]	; 0x48
            p_i2c_con->status &= ~STATUS_WRITE_IN_PROGRESS;
  1072f8:	f023 0301 	bic.w	r3, r3, #1
  1072fc:	9301      	str	r3, [sp, #4]
  1072fe:	6623      	str	r3, [r4, #96]	; 0x60
  107300:	9b00      	ldr	r3, [sp, #0]
  107302:	330c      	adds	r3, #12
  107304:	9300      	str	r3, [sp, #0]
    for (; p_i2c_con->msg_write_idx < p_i2c_con->msgs_num;
  107306:	9b02      	ldr	r3, [sp, #8]
  107308:	459a      	cmp	r10, r3
  10730a:	db85      	blt.n	107218 <i2c_irq_handler+0x12c>
  10730c:	9f05      	ldr	r7, [sp, #20]
  10730e:	e7d3      	b.n	1072b8 <i2c_irq_handler+0x1cc>
        while ((buf_len > 0) && (tx_limit > 0) && (rx_limit > 0)) {
  107310:	468c      	mov	r12, r1
  107312:	e7e7      	b.n	1072e4 <i2c_irq_handler+0x1f8>
            p_i2c_con->rx_buf_len = len;
  107314:	65a3      	str	r3, [r4, #88]	; 0x58
            p_i2c_con->status |= STATUS_READ_IN_PROGRESS;
  107316:	f042 0202 	orr.w	r2, r2, #2
            p_i2c_con->rx_buf = buf;
  10731a:	e9c4 0217 	strd	r0, r2, [r4, #92]	; 0x5c
  10731e:	e71b      	b.n	107158 <i2c_irq_handler+0x6c>
  107320:	9f05      	ldr	r7, [sp, #20]
  107322:	e7c5      	b.n	1072b0 <i2c_irq_handler+0x1c4>

00107324 <dw_i2c_wait_fifo_clear>:

    u32 abrt = i2c_reg->ic_clr_tx_abrt;
    return (abrt);
}
static status_t dw_i2c_wait_fifo_clear(dw_i2c_context *p_i2c_con)
{
  107324:	b538      	push	{r3, r4, r5, r14}
    dw_i2c_config_t *info = &p_i2c_con->info;
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  107326:	6805      	ldr	r5, [r0, #0]
  107328:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
  10732c:	e003      	b.n	107336 <dw_i2c_wait_fifo_clear+0x12>
        spin(100);
  10732e:	f00c fa23 	bl	113778 <spin>
    while (wait_cnt < 500) {
  107332:	3c01      	subs	r4, #1
  107334:	d003      	beq.n	10733e <dw_i2c_wait_fifo_clear+0x1a>
        status = i2c_reg->ic_status;
  107336:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        spin(100);
  107338:	2064      	movs	r0, #100	; 0x64
        if (status == 0x6) {
  10733a:	2b06      	cmp	r3, #6
  10733c:	d1f7      	bne.n	10732e <dw_i2c_wait_fifo_clear+0xa>
    u32 abrt = i2c_reg->ic_clr_tx_abrt;
  10733e:	6d6b      	ldr	r3, [r5, #84]	; 0x54
    // u32 stat = i2c_reg->ic_raw_intr_stat;
    // u32 res = i2c_reg->ic_clr_tx_abrt;
    wait_fifo_empty(i2c_reg);
    return (i2c_reg->ic_status);
  107340:	6f28      	ldr	r0, [r5, #112]	; 0x70
}
  107342:	bd38      	pop	{r3, r4, r5, r15}

00107344 <dw_i2c_wait_bus_not_busy>:
{
  107344:	b538      	push	{r3, r4, r5, r14}
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  107346:	6805      	ldr	r5, [r0, #0]
    while (i2c_reg->ic_status & (1 << IC_STATUS_ACTIVITY_FIELD_OFFSET)) {
  107348:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  10734a:	07da      	lsls	r2, r3, #31
  10734c:	bf48      	it	mi
  10734e:	2414      	movmi	r4, #20
  107350:	d402      	bmi.n	107358 <dw_i2c_wait_bus_not_busy+0x14>
  107352:	e007      	b.n	107364 <dw_i2c_wait_bus_not_busy+0x20>
        if (timeout <= 0) {
  107354:	3c01      	subs	r4, #1
  107356:	d007      	beq.n	107368 <dw_i2c_wait_bus_not_busy+0x24>
        thread_sleep(1);
  107358:	2001      	movs	r0, #1
  10735a:	f00f f9df 	bl	11671c <thread_sleep>
    while (i2c_reg->ic_status & (1 << IC_STATUS_ACTIVITY_FIELD_OFFSET)) {
  10735e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
  107360:	07db      	lsls	r3, r3, #31
  107362:	d4f7      	bmi.n	107354 <dw_i2c_wait_bus_not_busy+0x10>
    return 0;
  107364:	2000      	movs	r0, #0
}
  107366:	bd38      	pop	{r3, r4, r5, r15}
            dprintf(0, "timeout waiting for bus ready\n");
  107368:	f648 107c 	movw	r0, #35196	; 0x897c
  10736c:	f2c0 0011 	movt	r0, #17
  107370:	f00d fa30 	bl	1147d4 <puts>
            return ERR_TIMED_OUT;
  107374:	f06f 000c 	mvn.w	r0, #12
}
  107378:	bd38      	pop	{r3, r4, r5, r15}
  10737a:	bf00      	nop

0010737c <dw_i2c_set_busconfig>:
{
  10737c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if ((p_i2c_con->info.io_base == info->io_base) &&
  10737e:	6802      	ldr	r2, [r0, #0]
{
  107380:	4606      	mov	r6, r0
    if ((p_i2c_con->info.io_base == info->io_base) &&
  107382:	680b      	ldr	r3, [r1, #0]
{
  107384:	460f      	mov	r7, r1
    if ((p_i2c_con->info.io_base == info->io_base) &&
  107386:	429a      	cmp	r2, r3
  107388:	d01b      	beq.n	1073c2 <dw_i2c_set_busconfig+0x46>
    p_i2c_con->info = *info;
  10738a:	463d      	mov	r5, r7
  10738c:	4634      	mov	r4, r6
    p_i2c_con->is_configured = false;
  10738e:	f04f 0e00 	mov.w	r14, #0
    p_i2c_con->is_added = true;
  107392:	f04f 0c01 	mov.w	r12, #1
    p_i2c_con->info = *info;
  107396:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  107398:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  10739a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    if (info->mode == SLAVE_MODE) {
  10739e:	68fd      	ldr	r5, [r7, #12]
    p_i2c_con->info = *info;
  1073a0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    p_i2c_con->is_added = true;
  1073a4:	f886 c021 	strb.w	r12, [r6, #33]	; 0x21
    p_i2c_con->timeout = 1000;
  1073a8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    p_i2c_con->is_configured = false;
  1073ac:	f886 e020 	strb.w	r14, [r6, #32]
    p_i2c_con->isr = false;
  1073b0:	f886 e022 	strb.w	r14, [r6, #34]	; 0x22
    p_i2c_con->timeout = 1000;
  1073b4:	63f3      	str	r3, [r6, #60]	; 0x3c
    if (info->mode == SLAVE_MODE) {
  1073b6:	b32d      	cbz	r5, 107404 <dw_i2c_set_busconfig+0x88>
    else if (info->mode == MASTER_MODE) {
  1073b8:	2d01      	cmp	r5, #1
    return true;
  1073ba:	bf18      	it	ne
  1073bc:	4660      	movne	r0, r12
    else if (info->mode == MASTER_MODE) {
  1073be:	d027      	beq.n	107410 <dw_i2c_set_busconfig+0x94>
}
  1073c0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if ((p_i2c_con->info.io_base == info->io_base) &&
  1073c2:	6842      	ldr	r2, [r0, #4]
  1073c4:	684b      	ldr	r3, [r1, #4]
  1073c6:	429a      	cmp	r2, r3
  1073c8:	d1df      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
            (p_i2c_con->info.speed == info->speed) &&
  1073ca:	6882      	ldr	r2, [r0, #8]
  1073cc:	688b      	ldr	r3, [r1, #8]
  1073ce:	429a      	cmp	r2, r3
  1073d0:	d1db      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
            (p_i2c_con->info.addr_bits == info->addr_bits) &&
  1073d2:	68c2      	ldr	r2, [r0, #12]
  1073d4:	68cb      	ldr	r3, [r1, #12]
  1073d6:	429a      	cmp	r2, r3
  1073d8:	d1d7      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
            (p_i2c_con->info.mode == info->mode) &&
  1073da:	7c02      	ldrb	r2, [r0, #16]
  1073dc:	7c0b      	ldrb	r3, [r1, #16]
  1073de:	429a      	cmp	r2, r3
  1073e0:	d1d3      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
            (p_i2c_con->info.restart == info->restart) &&
  1073e2:	69c2      	ldr	r2, [r0, #28]
  1073e4:	69cb      	ldr	r3, [r1, #28]
  1073e6:	429a      	cmp	r2, r3
  1073e8:	d1cf      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
            (p_i2c_con->info.poll == info->poll) &&
  1073ea:	6942      	ldr	r2, [r0, #20]
  1073ec:	694b      	ldr	r3, [r1, #20]
  1073ee:	429a      	cmp	r2, r3
  1073f0:	d1cb      	bne.n	10738a <dw_i2c_set_busconfig+0xe>
        dprintf(0, "already configed bus %d.\n", p_i2c_con->bus);
  1073f2:	6ab1      	ldr	r1, [r6, #40]	; 0x28
  1073f4:	f648 1060 	movw	r0, #35168	; 0x8960
  1073f8:	f2c0 0011 	movt	r0, #17
  1073fc:	f00d fa02 	bl	114804 <printf>
        return false;
  107400:	2000      	movs	r0, #0
}
  107402:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        if (!dw_i2c_config(p_i2c_con, info->slave_addr))
  107404:	6979      	ldr	r1, [r7, #20]
  107406:	4630      	mov	r0, r6
}
  107408:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
        if (!dw_i2c_config(p_i2c_con, info->slave_addr))
  10740c:	f7ff be0a 	b.w	107024 <dw_i2c_config>
        if (!dw_i2c_config(p_i2c_con, DEF_TAR))
  107410:	4630      	mov	r0, r6
  107412:	2155      	movs	r1, #85	; 0x55
}
  107414:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
        if (!dw_i2c_config(p_i2c_con, DEF_TAR))
  107418:	f7ff be04 	b.w	107024 <dw_i2c_config>

0010741c <dw_i2c_init_after>:
    if (!event_initialized(&p_i2c_con->completion))
  10741c:	6b41      	ldr	r1, [r0, #52]	; 0x34
  10741e:	b101      	cbz	r1, 107422 <dw_i2c_init_after+0x6>
}
  107420:	4770      	bx	r14
        event_init(&p_i2c_con->completion, false, EVENT_FLAG_AUTOUNSIGNAL);
  107422:	2201      	movs	r2, #1
  107424:	3034      	adds	r0, #52	; 0x34
  107426:	f00e bfbf 	b.w	1163a8 <event_init>
  10742a:	bf00      	nop

0010742c <dw_i2c_transfer>:
    if ((p_i2c_con->info.poll == 0) && (p_i2c_con->isr == false)) {
  10742c:	69c3      	ldr	r3, [r0, #28]
{
  10742e:	b570      	push	{r4, r5, r6, r14}
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  107430:	6805      	ldr	r5, [r0, #0]
{
  107432:	4604      	mov	r4, r0
    if ((p_i2c_con->info.poll == 0) && (p_i2c_con->isr == false)) {
  107434:	b91b      	cbnz	r3, 10743e <dw_i2c_transfer+0x12>
  107436:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
  10743a:	2b00      	cmp	r3, #0
  10743c:	d03a      	beq.n	1074b4 <dw_i2c_transfer+0x88>
    if (p_i2c_con->cur_addr != addr) {
  10743e:	6a60      	ldr	r0, [r4, #36]	; 0x24
    if (!p_i2c_con->is_configured) {
  107440:	f894 2020 	ldrb.w	r2, [r4, #32]
    if (does_need_config(p_i2c_con, p_i2c_con->msgs[0].addr) &&
  107444:	6c23      	ldr	r3, [r4, #64]	; 0x40
  107446:	8819      	ldrh	r1, [r3, #0]
    p_i2c_con->msg_write_idx = 0;
  107448:	2300      	movs	r3, #0
    if (!p_i2c_con->is_configured) {
  10744a:	4288      	cmp	r0, r1
  10744c:	bf14      	ite	ne
  10744e:	2200      	movne	r2, #0
  107450:	f002 0201 	andeq.w	r2, r2, #1
    p_i2c_con->msg_write_idx = 0;
  107454:	64a3      	str	r3, [r4, #72]	; 0x48
    p_i2c_con->msg_read_idx = 0;
  107456:	6563      	str	r3, [r4, #84]	; 0x54
    p_i2c_con->abort = 0;
  107458:	e9c4 3318 	strd	r3, r3, [r4, #96]	; 0x60
    p_i2c_con->rx_outstanding = 0;
  10745c:	66a3      	str	r3, [r4, #104]	; 0x68
    if (!p_i2c_con->is_configured) {
  10745e:	b98a      	cbnz	r2, 107484 <dw_i2c_transfer+0x58>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)io_base;
  107460:	6823      	ldr	r3, [r4, #0]
    if (!p_i2c_con->is_added)
  107462:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
  107466:	2a00      	cmp	r2, #0
  107468:	d03a      	beq.n	1074e0 <dw_i2c_transfer+0xb4>
    if (p_i2c_con->info.poll == 1)
  10746a:	69e0      	ldr	r0, [r4, #28]
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  10746c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    if (p_i2c_con->info.poll == 1)
  10746e:	2801      	cmp	r0, #1
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  107470:	f022 0201 	bic.w	r2, r2, #1
  107474:	66da      	str	r2, [r3, #108]	; 0x6c
    i2c_reg->ic_tar = val;
  107476:	6059      	str	r1, [r3, #4]
        i2c_reg->ic_enable |= 0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET;
  107478:	bf02      	ittt	eq
  10747a:	6eda      	ldreq	r2, [r3, #108]	; 0x6c
  10747c:	f042 0201 	orreq.w	r2, r2, #1
  107480:	66da      	streq	r2, [r3, #108]	; 0x6c
    p_i2c_con->cur_addr = addr;
  107482:	6261      	str	r1, [r4, #36]	; 0x24
        i2c_reg->ic_enable = 0x0;
  107484:	2600      	movs	r6, #0
        i2c_reg->ic_enable = 0x1;
  107486:	2201      	movs	r2, #1
    i2c_reg->ic_intr_mask = DW_IC_INTR_MASTER_MASK;
  107488:	f44f 7315 	mov.w	r3, #596	; 0x254
    ret = event_wait_timeout(&p_i2c_con->completion, p_i2c_con->timeout);
  10748c:	f104 0034 	add.w	r0, r4, #52	; 0x34
        i2c_reg->ic_enable = 0x0;
  107490:	66ee      	str	r6, [r5, #108]	; 0x6c
    ret = event_wait_timeout(&p_i2c_con->completion, p_i2c_con->timeout);
  107492:	6be1      	ldr	r1, [r4, #60]	; 0x3c
    i2c_reg->ic_intr_mask = 0;
  107494:	632e      	str	r6, [r5, #48]	; 0x30
        i2c_reg->ic_enable = 0x1;
  107496:	66ea      	str	r2, [r5, #108]	; 0x6c
    val +=  i2c_reg->ic_clr_intr;
  107498:	6c2a      	ldr	r2, [r5, #64]	; 0x40
    i2c_reg->ic_intr_mask = DW_IC_INTR_MASTER_MASK;
  10749a:	632b      	str	r3, [r5, #48]	; 0x30
    ret = event_wait_timeout(&p_i2c_con->completion, p_i2c_con->timeout);
  10749c:	f00e ffb2 	bl	116404 <event_wait_timeout>
    if (ret) {
  1074a0:	b9b8      	cbnz	r0, 1074d2 <dw_i2c_transfer+0xa6>
    if (!p_i2c_con->abort && !p_i2c_con->status) {
  1074a2:	6e63      	ldr	r3, [r4, #100]	; 0x64
        i2c_reg->ic_enable = 0x0;
  1074a4:	66e8      	str	r0, [r5, #108]	; 0x6c
    if (!p_i2c_con->abort && !p_i2c_con->status) {
  1074a6:	b9c3      	cbnz	r3, 1074da <dw_i2c_transfer+0xae>
  1074a8:	6e23      	ldr	r3, [r4, #96]	; 0x60
  1074aa:	2b00      	cmp	r3, #0
    return ERR_IO;
  1074ac:	bf18      	it	ne
  1074ae:	f06f 0013 	mvnne.w	r0, #19
}
  1074b2:	bd70      	pop	{r4, r5, r6, r15}
        register_int_handler(info->irq, i2c_irq_handler, p_i2c_con);
  1074b4:	f247 01ed 	movw	r1, #28909	; 0x70ed
  1074b8:	4602      	mov	r2, r0
  1074ba:	6980      	ldr	r0, [r0, #24]
  1074bc:	f2c0 0110 	movt	r1, #16
  1074c0:	f7f9 f926 	bl	100710 <register_int_handler>
        unmask_interrupt(info->irq);
  1074c4:	69a0      	ldr	r0, [r4, #24]
  1074c6:	f7f9 f981 	bl	1007cc <unmask_interrupt>
        p_i2c_con->isr = true;
  1074ca:	2301      	movs	r3, #1
  1074cc:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  1074d0:	e7b5      	b.n	10743e <dw_i2c_transfer+0x12>
        i2c_reg->ic_enable = 0x0;
  1074d2:	66ee      	str	r6, [r5, #108]	; 0x6c
        return ERR_TIMED_OUT;
  1074d4:	f06f 000c 	mvn.w	r0, #12
}
  1074d8:	bd70      	pop	{r4, r5, r6, r15}
    return ERR_IO;
  1074da:	f06f 0013 	mvn.w	r0, #19
}
  1074de:	bd70      	pop	{r4, r5, r6, r15}
        return ERR_NOT_CONFIGURED;
  1074e0:	f06f 0025 	mvn.w	r0, #37	; 0x25
}
  1074e4:	bd70      	pop	{r4, r5, r6, r15}
  1074e6:	bf00      	nop

001074e8 <dw_i2c_transmit>:
{
  1074e8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (!p_i2c_con->is_configured) {
  1074ec:	f890 4020 	ldrb.w	r4, [r0, #32]
    if (p_i2c_con->cur_addr != addr) {
  1074f0:	6a45      	ldr	r5, [r0, #36]	; 0x24
{
  1074f2:	460e      	mov	r6, r1
  1074f4:	b083      	sub	sp, #12
  1074f6:	f89d 1034 	ldrb.w	r1, [r13, #52]	; 0x34
  1074fa:	f89d a030 	ldrb.w	r10, [r13, #48]	; 0x30
    if (!p_i2c_con->is_configured) {
  1074fe:	42b5      	cmp	r5, r6
  107500:	bf14      	ite	ne
  107502:	2400      	movne	r4, #0
  107504:	f004 0401 	andeq.w	r4, r4, #1
{
  107508:	9100      	str	r1, [sp, #0]
  10750a:	6801      	ldr	r1, [r0, #0]
  10750c:	468b      	mov	r11, r1
    if (!p_i2c_con->is_configured) {
  10750e:	b984      	cbnz	r4, 107532 <dw_i2c_transmit+0x4a>
    if (!p_i2c_con->is_added)
  107510:	f890 4021 	ldrb.w	r4, [r0, #33]	; 0x21
  107514:	2c00      	cmp	r4, #0
  107516:	d049      	beq.n	1075ac <dw_i2c_transmit+0xc4>
    if (p_i2c_con->info.poll == 1)
  107518:	69c5      	ldr	r5, [r0, #28]
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  10751a:	6ecc      	ldr	r4, [r1, #108]	; 0x6c
    if (p_i2c_con->info.poll == 1)
  10751c:	2d01      	cmp	r5, #1
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  10751e:	f024 0401 	bic.w	r4, r4, #1
  107522:	66cc      	str	r4, [r1, #108]	; 0x6c
    i2c_reg->ic_tar = val;
  107524:	604e      	str	r6, [r1, #4]
        i2c_reg->ic_enable |= 0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET;
  107526:	bf02      	ittt	eq
  107528:	6ecc      	ldreq	r4, [r1, #108]	; 0x6c
  10752a:	f044 0401 	orreq.w	r4, r4, #1
  10752e:	66cc      	streq	r4, [r1, #108]	; 0x6c
    p_i2c_con->cur_addr = addr;
  107530:	6246      	str	r6, [r0, #36]	; 0x24
    for (size_t i = 0; i < cnt; i++) {
  107532:	b32b      	cbz	r3, 107580 <dw_i2c_transmit+0x98>
  107534:	4699      	mov	r9, r3
  107536:	4605      	mov	r5, r0
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  107538:	3b01      	subs	r3, #1
    for (size_t i = 0; i < cnt; i++) {
  10753a:	2600      	movs	r6, #0
  10753c:	f102 38ff 	add.w	r8, r2, #4294967295	; 0xffffffff
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  107540:	9301      	str	r3, [sp, #4]
        if ((i == 0) && start) {
  107542:	2e00      	cmp	r6, #0
  107544:	bf14      	ite	ne
  107546:	2300      	movne	r3, #0
  107548:	f00a 0301 	andeq.w	r3, r10, #1
        val = p[i] | (WRITE_CMD << IC_DATA_CMD_CMD_FIELD_OFFSET);
  10754c:	f818 7f01 	ldrb.w	r7, [r8, #1]!
        if ((i == 0) && start) {
  107550:	b1d3      	cbz	r3, 107588 <dw_i2c_transmit+0xa0>
            val |= 1 << IC_DATA_CMD_RESTART_FIELD_OFFSET;
  107552:	f447 6780 	orr.w	r7, r7, #1024	; 0x400
    uint32_t val = i2c_reg->ic_status;
  107556:	6f0b      	ldr	r3, [r1, #112]	; 0x70
        while (is_txfifo_full(p_i2c_con) && --count)
  107558:	079b      	lsls	r3, r3, #30
  10755a:	bf58      	it	pl
  10755c:	f640 34b7 	movwpl	r4, #2999	; 0xbb7
  107560:	d502      	bpl.n	107568 <dw_i2c_transmit+0x80>
  107562:	e008      	b.n	107576 <dw_i2c_transmit+0x8e>
  107564:	3c01      	subs	r4, #1
  107566:	d01b      	beq.n	1075a0 <dw_i2c_transmit+0xb8>
            spin(SPIN_STEP);
  107568:	2001      	movs	r0, #1
  10756a:	f00c f905 	bl	113778 <spin>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  10756e:	6829      	ldr	r1, [r5, #0]
    uint32_t val = i2c_reg->ic_status;
  107570:	6f0b      	ldr	r3, [r1, #112]	; 0x70
        while (is_txfifo_full(p_i2c_con) && --count)
  107572:	079a      	lsls	r2, r3, #30
  107574:	d5f6      	bpl.n	107564 <dw_i2c_transmit+0x7c>
        i2c_reg->ic_data_cmd = val;
  107576:	f8cb 7010 	str.w	r7, [r11, #16]
    for (size_t i = 0; i < cnt; i++) {
  10757a:	3601      	adds	r6, #1
  10757c:	45b1      	cmp	r9, r6
  10757e:	d1e0      	bne.n	107542 <dw_i2c_transmit+0x5a>
    return NO_ERROR;
  107580:	2000      	movs	r0, #0
}
  107582:	b003      	add	sp, #12
  107584:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  107588:	e9dd 3200 	ldrd	r3, r2, [r13]
  10758c:	42b2      	cmp	r2, r6
  10758e:	bf14      	ite	ne
  107590:	2300      	movne	r3, #0
  107592:	f003 0301 	andeq.w	r3, r3, #1
  107596:	2b00      	cmp	r3, #0
  107598:	d0dd      	beq.n	107556 <dw_i2c_transmit+0x6e>
            val |= 1 << IC_DATA_CMD_STOP_FIELD_OFFSET;
  10759a:	f447 7700 	orr.w	r7, r7, #512	; 0x200
  10759e:	e7da      	b.n	107556 <dw_i2c_transmit+0x6e>
            p_i2c_con->cur_addr = 0;
  1075a0:	626c      	str	r4, [r5, #36]	; 0x24
            return ERR_TIMED_OUT;
  1075a2:	f06f 000c 	mvn.w	r0, #12
}
  1075a6:	b003      	add	sp, #12
  1075a8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return ERR_NOT_CONFIGURED;
  1075ac:	f06f 0025 	mvn.w	r0, #37	; 0x25
  1075b0:	e7e7      	b.n	107582 <dw_i2c_transmit+0x9a>
  1075b2:	bf00      	nop

001075b4 <dw_i2c_receive>:
{
  1075b4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (!p_i2c_con->is_configured) {
  1075b8:	f890 5020 	ldrb.w	r5, [r0, #32]
    if (p_i2c_con->cur_addr != addr) {
  1075bc:	6a46      	ldr	r6, [r0, #36]	; 0x24
{
  1075be:	b083      	sub	sp, #12
  1075c0:	6804      	ldr	r4, [r0, #0]
  1075c2:	f89d 9030 	ldrb.w	r9, [r13, #48]	; 0x30
  1075c6:	f89d a034 	ldrb.w	r10, [r13, #52]	; 0x34
  1075ca:	4627      	mov	r7, r4
    if (!p_i2c_con->is_configured) {
  1075cc:	428e      	cmp	r6, r1
  1075ce:	bf14      	ite	ne
  1075d0:	2500      	movne	r5, #0
  1075d2:	f005 0501 	andeq.w	r5, r5, #1
  1075d6:	b985      	cbnz	r5, 1075fa <dw_i2c_receive+0x46>
    if (!p_i2c_con->is_added)
  1075d8:	f890 5021 	ldrb.w	r5, [r0, #33]	; 0x21
  1075dc:	2d00      	cmp	r5, #0
  1075de:	d054      	beq.n	10768a <dw_i2c_receive+0xd6>
    if (p_i2c_con->info.poll == 1)
  1075e0:	69c6      	ldr	r6, [r0, #28]
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  1075e2:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
    if (p_i2c_con->info.poll == 1)
  1075e4:	2e01      	cmp	r6, #1
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  1075e6:	f025 0501 	bic.w	r5, r5, #1
  1075ea:	66e5      	str	r5, [r4, #108]	; 0x6c
    i2c_reg->ic_tar = val;
  1075ec:	6061      	str	r1, [r4, #4]
        i2c_reg->ic_enable |= 0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET;
  1075ee:	bf02      	ittt	eq
  1075f0:	6ee5      	ldreq	r5, [r4, #108]	; 0x6c
  1075f2:	f045 0501 	orreq.w	r5, r5, #1
  1075f6:	66e5      	streq	r5, [r4, #108]	; 0x6c
    p_i2c_con->cur_addr = addr;
  1075f8:	6241      	str	r1, [r0, #36]	; 0x24
    for (size_t i = 0; i < cnt; i++) {
  1075fa:	2b00      	cmp	r3, #0
  1075fc:	d041      	beq.n	107682 <dw_i2c_receive+0xce>
  1075fe:	4698      	mov	r8, r3
  107600:	2500      	movs	r5, #0
  107602:	4683      	mov	r11, r0
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  107604:	3b01      	subs	r3, #1
  107606:	1e56      	subs	r6, r2, #1
  107608:	9301      	str	r3, [sp, #4]
        if ((i == 0) && start) {
  10760a:	2d00      	cmp	r5, #0
  10760c:	bf14      	ite	ne
  10760e:	2300      	movne	r3, #0
  107610:	f009 0301 	andeq.w	r3, r9, #1
  107614:	bb5b      	cbnz	r3, 10766e <dw_i2c_receive+0xba>
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  107616:	9b01      	ldr	r3, [sp, #4]
  107618:	42ab      	cmp	r3, r5
  10761a:	bf14      	ite	ne
  10761c:	2300      	movne	r3, #0
  10761e:	f00a 0301 	andeq.w	r3, r10, #1
        val = READ_CMD << IC_DATA_CMD_CMD_FIELD_OFFSET;
  107622:	2b00      	cmp	r3, #0
  107624:	bf14      	ite	ne
  107626:	f44f 7340 	movne.w	r3, #768	; 0x300
  10762a:	f44f 7380 	moveq.w	r3, #256	; 0x100
        i2c_reg->ic_data_cmd = val;
  10762e:	613b      	str	r3, [r7, #16]
    uint32_t val = i2c_reg->ic_status;
  107630:	6f23      	ldr	r3, [r4, #112]	; 0x70
        while (is_rxfifo_empty(p_i2c_con) && --count)
  107632:	071a      	lsls	r2, r3, #28
  107634:	d40c      	bmi.n	107650 <dw_i2c_receive+0x9c>
  107636:	f640 34b7 	movw	r4, #2999	; 0xbb7
  10763a:	e001      	b.n	107640 <dw_i2c_receive+0x8c>
  10763c:	3c01      	subs	r4, #1
  10763e:	d019      	beq.n	107674 <dw_i2c_receive+0xc0>
            spin(SPIN_STEP);
  107640:	2001      	movs	r0, #1
  107642:	f00c f899 	bl	113778 <spin>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  107646:	f8db 3000 	ldr.w	r3, [r11]
    uint32_t val = i2c_reg->ic_status;
  10764a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        while (is_rxfifo_empty(p_i2c_con) && --count)
  10764c:	071b      	lsls	r3, r3, #28
  10764e:	d5f5      	bpl.n	10763c <dw_i2c_receive+0x88>
        val = i2c_reg->ic_data_cmd;
  107650:	693b      	ldr	r3, [r7, #16]
    for (size_t i = 0; i < cnt; i++) {
  107652:	3501      	adds	r5, #1
        p[i] = val & 0xff;
  107654:	f806 3f01 	strb.w	r3, [r6, #1]!
    for (size_t i = 0; i < cnt; i++) {
  107658:	45a8      	cmp	r8, r5
  10765a:	d012      	beq.n	107682 <dw_i2c_receive+0xce>
        if ((i == 0) && start) {
  10765c:	2d00      	cmp	r5, #0
  10765e:	bf14      	ite	ne
  107660:	2300      	movne	r3, #0
  107662:	f009 0301 	andeq.w	r3, r9, #1
  107666:	f8db 4000 	ldr.w	r4, [r11]
  10766a:	2b00      	cmp	r3, #0
  10766c:	d0d3      	beq.n	107616 <dw_i2c_receive+0x62>
            val |= 1 << IC_DATA_CMD_RESTART_FIELD_OFFSET;
  10766e:	f44f 63a0 	mov.w	r3, #1280	; 0x500
  107672:	e7dc      	b.n	10762e <dw_i2c_receive+0x7a>
            p_i2c_con->cur_addr = 0;
  107674:	f8cb 4024 	str.w	r4, [r11, #36]	; 0x24
            return ERR_TIMED_OUT;
  107678:	f06f 000c 	mvn.w	r0, #12
}
  10767c:	b003      	add	sp, #12
  10767e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    return NO_ERROR;
  107682:	2000      	movs	r0, #0
}
  107684:	b003      	add	sp, #12
  107686:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return ERR_NOT_CONFIGURED;
  10768a:	f06f 0025 	mvn.w	r0, #37	; 0x25
  10768e:	e7f5      	b.n	10767c <dw_i2c_receive+0xc8>

00107690 <dw_i2c_slave_receive>:
{
  107690:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  107694:	7d06      	ldrb	r6, [r0, #20]
    if (!p_i2c_con->is_configured) {
  107696:	f890 4020 	ldrb.w	r4, [r0, #32]
{
  10769a:	469a      	mov	r10, r3
  10769c:	b083      	sub	sp, #12
    if (p_i2c_con->cur_addr != addr) {
  10769e:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
  1076a0:	4605      	mov	r5, r0
  1076a2:	460f      	mov	r7, r1
  1076a4:	4691      	mov	r9, r2
  1076a6:	f89d b030 	ldrb.w	r11, [r13, #48]	; 0x30
    if (!p_i2c_con->is_configured) {
  1076aa:	42b3      	cmp	r3, r6
  1076ac:	bf14      	ite	ne
  1076ae:	2400      	movne	r4, #0
  1076b0:	f004 0401 	andeq.w	r4, r4, #1
  1076b4:	b924      	cbnz	r4, 1076c0 <dw_i2c_slave_receive+0x30>
            !dw_i2c_config(p_i2c_con, address))
  1076b6:	4631      	mov	r1, r6
  1076b8:	f7ff fcb4 	bl	107024 <dw_i2c_config>
    if (does_need_config(p_i2c_con, address) &&
  1076bc:	2800      	cmp	r0, #0
  1076be:	d047      	beq.n	107750 <dw_i2c_slave_receive+0xc0>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  1076c0:	682b      	ldr	r3, [r5, #0]
  1076c2:	4698      	mov	r8, r3
    for (size_t i = 0; i < cnt; i++) {
  1076c4:	f1b9 0f00 	cmp.w	r9, #0
  1076c8:	d03e      	beq.n	107748 <dw_i2c_slave_receive+0xb8>
  1076ca:	2600      	movs	r6, #0
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  1076cc:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
  1076d0:	3f01      	subs	r7, #1
  1076d2:	9201      	str	r2, [sp, #4]
        if ((i == 0) && start) {
  1076d4:	2e00      	cmp	r6, #0
  1076d6:	bf14      	ite	ne
  1076d8:	2200      	movne	r2, #0
  1076da:	f00a 0201 	andeq.w	r2, r10, #1
  1076de:	bb5a      	cbnz	r2, 107738 <dw_i2c_slave_receive+0xa8>
        else if ((i == cnt - 1) && stop) {   /* send a stop at last one */
  1076e0:	9a01      	ldr	r2, [sp, #4]
  1076e2:	42b2      	cmp	r2, r6
  1076e4:	bf14      	ite	ne
  1076e6:	2200      	movne	r2, #0
  1076e8:	f00b 0201 	andeq.w	r2, r11, #1
        val = READ_CMD << IC_DATA_CMD_CMD_FIELD_OFFSET;
  1076ec:	2a00      	cmp	r2, #0
  1076ee:	bf14      	ite	ne
  1076f0:	f44f 7240 	movne.w	r2, #768	; 0x300
  1076f4:	f44f 7280 	moveq.w	r2, #256	; 0x100
        i2c_reg->ic_data_cmd = val;
  1076f8:	f8c8 2010 	str.w	r2, [r8, #16]
    uint32_t val = i2c_reg->ic_status;
  1076fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        while (is_rxfifo_empty(p_i2c_con) && --count)
  1076fe:	071a      	lsls	r2, r3, #28
  107700:	d40b      	bmi.n	10771a <dw_i2c_slave_receive+0x8a>
  107702:	f640 34b7 	movw	r4, #2999	; 0xbb7
  107706:	e001      	b.n	10770c <dw_i2c_slave_receive+0x7c>
  107708:	3c01      	subs	r4, #1
  10770a:	d018      	beq.n	10773e <dw_i2c_slave_receive+0xae>
            spin(SPIN_STEP);
  10770c:	2001      	movs	r0, #1
  10770e:	f00c f833 	bl	113778 <spin>
    i2c_reg_type_t *i2c_reg = (i2c_reg_type_t *)info->io_base;
  107712:	682b      	ldr	r3, [r5, #0]
    uint32_t val = i2c_reg->ic_status;
  107714:	6f1b      	ldr	r3, [r3, #112]	; 0x70
        while (is_rxfifo_empty(p_i2c_con) && --count)
  107716:	071b      	lsls	r3, r3, #28
  107718:	d5f6      	bpl.n	107708 <dw_i2c_slave_receive+0x78>
        val = i2c_reg->ic_data_cmd;
  10771a:	f8d8 3010 	ldr.w	r3, [r8, #16]
    for (size_t i = 0; i < cnt; i++) {
  10771e:	3601      	adds	r6, #1
        p[i] = val & 0xff;
  107720:	f807 3f01 	strb.w	r3, [r7, #1]!
    for (size_t i = 0; i < cnt; i++) {
  107724:	45b1      	cmp	r9, r6
  107726:	d00f      	beq.n	107748 <dw_i2c_slave_receive+0xb8>
        if ((i == 0) && start) {
  107728:	2e00      	cmp	r6, #0
  10772a:	bf14      	ite	ne
  10772c:	2200      	movne	r2, #0
  10772e:	f00a 0201 	andeq.w	r2, r10, #1
  107732:	682b      	ldr	r3, [r5, #0]
  107734:	2a00      	cmp	r2, #0
  107736:	d0d3      	beq.n	1076e0 <dw_i2c_slave_receive+0x50>
            val |= 1 << IC_DATA_CMD_RESTART_FIELD_OFFSET;
  107738:	f44f 62a0 	mov.w	r2, #1280	; 0x500
  10773c:	e7dc      	b.n	1076f8 <dw_i2c_slave_receive+0x68>
            return ERR_TIMED_OUT;
  10773e:	f06f 000c 	mvn.w	r0, #12
}
  107742:	b003      	add	sp, #12
  107744:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    return NO_ERROR;
  107748:	2000      	movs	r0, #0
}
  10774a:	b003      	add	sp, #12
  10774c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return ERR_NOT_CONFIGURED;
  107750:	f06f 0025 	mvn.w	r0, #37	; 0x25
  107754:	e7f5      	b.n	107742 <dw_i2c_slave_receive+0xb2>
  107756:	bf00      	nop

00107758 <dw_i2c_scan>:
{
  107758:	b430      	push	{r4, r5}
  10775a:	4603      	mov	r3, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10775c:	f3ef 8200 	mrs	r2, CPSR

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107760:	0612      	lsls	r2, r2, #24
    spin_lock_saved_state_t state = 0;
  107762:	bf48      	it	mi
  107764:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107766:	d401      	bmi.n	10776c <dw_i2c_scan+0x14>
    __asm__ volatile("cpsid i");
  107768:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10776a:	2401      	movs	r4, #1
    if (p_i2c_con->cur_addr != addr) {
  10776c:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    *lock = 1;
  10776e:	2201      	movs	r2, #1
    if (!p_i2c_con->is_configured) {
  107770:	f893 0020 	ldrb.w	r0, [r3, #32]
  107774:	631a      	str	r2, [r3, #48]	; 0x30
  107776:	428d      	cmp	r5, r1
  107778:	bf14      	ite	ne
  10777a:	2000      	movne	r0, #0
  10777c:	f000 0001 	andeq.w	r0, r0, #1
  107780:	681a      	ldr	r2, [r3, #0]
  107782:	b978      	cbnz	r0, 1077a4 <dw_i2c_scan+0x4c>
    if (!p_i2c_con->is_added)
  107784:	f893 0021 	ldrb.w	r0, [r3, #33]	; 0x21
  107788:	b1b0      	cbz	r0, 1077b8 <dw_i2c_scan+0x60>
    if (p_i2c_con->info.poll == 1)
  10778a:	69dd      	ldr	r5, [r3, #28]
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  10778c:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    if (p_i2c_con->info.poll == 1)
  10778e:	2d01      	cmp	r5, #1
    i2c_reg->ic_enable &= ~(0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET);
  107790:	f020 0001 	bic.w	r0, r0, #1
  107794:	66d0      	str	r0, [r2, #108]	; 0x6c
    i2c_reg->ic_tar = val;
  107796:	6051      	str	r1, [r2, #4]
        i2c_reg->ic_enable |= 0x1 << IC_ENABLE_ENABLE_FIELD_OFFSET;
  107798:	bf02      	ittt	eq
  10779a:	6ed0      	ldreq	r0, [r2, #108]	; 0x6c
  10779c:	f040 0001 	orreq.w	r0, r0, #1
  1077a0:	66d0      	streq	r0, [r2, #108]	; 0x6c
    p_i2c_con->cur_addr = addr;
  1077a2:	6259      	str	r1, [r3, #36]	; 0x24
    i2c_reg->ic_data_cmd = val;
  1077a4:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    return NO_ERROR;
  1077a8:	2000      	movs	r0, #0
    i2c_reg->ic_data_cmd = val;
  1077aa:	6111      	str	r1, [r2, #16]
    *lock = 0;
  1077ac:	2200      	movs	r2, #0
  1077ae:	631a      	str	r2, [r3, #48]	; 0x30
static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1077b0:	b104      	cbz	r4, 1077b4 <dw_i2c_scan+0x5c>
    __asm__ volatile("cpsie i");
  1077b2:	b662      	cpsie	i
}
  1077b4:	bc30      	pop	{r4, r5}
  1077b6:	4770      	bx	r14
        return ERR_NOT_CONFIGURED;
  1077b8:	f06f 0025 	mvn.w	r0, #37	; 0x25
  1077bc:	e7f6      	b.n	1077ac <dw_i2c_scan+0x54>
  1077be:	bf00      	nop

001077c0 <dw_i2c_write_reg_data>:
}
#else
status_t dw_i2c_write_reg_data(dw_i2c_context *p_i2c_con, uint8_t address,
                               void *reg, size_t cnt_reg, void *data,
                               size_t cnt)
{
  1077c0:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    status_t ret;

    if (p_i2c_con->info.poll == 1) {
  1077c4:	69c6      	ldr	r6, [r0, #28]
{
  1077c6:	b086      	sub	sp, #24
  1077c8:	4604      	mov	r4, r0
  1077ca:	4688      	mov	r8, r1
    if (p_i2c_con->info.poll == 1) {
  1077cc:	2e01      	cmp	r6, #1
  1077ce:	d12c      	bne.n	10782a <dw_i2c_write_reg_data+0x6a>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1077d0:	f3ef 8500 	mrs	r5, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1077d4:	f015 0780 	ands.w	r7, r5, #128	; 0x80
  1077d8:	d00d      	beq.n	1077f6 <dw_i2c_write_reg_data+0x36>
    *lock = 1;
  1077da:	6306      	str	r6, [r0, #48]	; 0x30
        spin_lock_saved_state_t states;
        spin_lock_irqsave(&p_i2c_con->bus_lock, states);
        ret = dw_i2c_transmit(p_i2c_con, address, reg, cnt_reg, true, false);
  1077dc:	2700      	movs	r7, #0
  1077de:	e9cd 6700 	strd	r6, r7, [r13]
  1077e2:	f7ff fe81 	bl	1074e8 <dw_i2c_transmit>

        if (ret != NO_ERROR)
  1077e6:	4605      	mov	r5, r0
  1077e8:	2800      	cmp	r0, #0
  1077ea:	d057      	beq.n	10789c <dw_i2c_write_reg_data+0xdc>
    *lock = 0;
  1077ec:	6327      	str	r7, [r4, #48]	; 0x30
            (u32)cnt);
    ret = dw_i2c_transfer(p_i2c_con);
    free(addr_buf);
    mutex_release(&p_i2c_con->bus_mutex);
    return ret;
}
  1077ee:	4628      	mov	r0, r5
  1077f0:	b006      	add	sp, #24
  1077f2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    __asm__ volatile("cpsid i");
  1077f6:	b672      	cpsid	i
    *lock = 1;
  1077f8:	6306      	str	r6, [r0, #48]	; 0x30
        ret = dw_i2c_transmit(p_i2c_con, address, reg, cnt_reg, true, false);
  1077fa:	e9cd 6700 	strd	r6, r7, [r13]
  1077fe:	f7ff fe73 	bl	1074e8 <dw_i2c_transmit>
        if (ret != NO_ERROR)
  107802:	4605      	mov	r5, r0
  107804:	b958      	cbnz	r0, 10781e <dw_i2c_write_reg_data+0x5e>
        ret = dw_i2c_transmit(p_i2c_con, address, data, cnt, false, true);
  107806:	9000      	str	r0, [sp, #0]
  107808:	4641      	mov	r1, r8
  10780a:	9601      	str	r6, [sp, #4]
  10780c:	4620      	mov	r0, r4
  10780e:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
  107812:	f7ff fe69 	bl	1074e8 <dw_i2c_transmit>
  107816:	4605      	mov	r5, r0
        dw_i2c_wait_fifo_clear(p_i2c_con);
  107818:	4620      	mov	r0, r4
  10781a:	f7ff fd83 	bl	107324 <dw_i2c_wait_fifo_clear>
    *lock = 0;
  10781e:	6327      	str	r7, [r4, #48]	; 0x30
    __asm__ volatile("cpsie i");
  107820:	b662      	cpsie	i
}
  107822:	4628      	mov	r0, r5
  107824:	b006      	add	sp, #24
  107826:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
*   para: mutex handle
*   return: NO_ERROR if acquire succ or blocked forever.
*/
static inline status_t mutex_acquire(mutex_t *m)
{
    return mutex_acquire_timeout(m, INFINITE_TIME);
  10782a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    mutex_acquire(&p_i2c_con->bus_mutex);
  10782e:	f100 062c 	add.w	r6, r0, #44	; 0x2c
  107832:	4630      	mov	r0, r6
  107834:	4691      	mov	r9, r2
  107836:	461f      	mov	r7, r3
  107838:	f00e fe88 	bl	11654c <mutex_acquire_timeout>
    ret = dw_i2c_wait_bus_not_busy(p_i2c_con);
  10783c:	4620      	mov	r0, r4
  10783e:	f7ff fd81 	bl	107344 <dw_i2c_wait_bus_not_busy>
    if (ret < 0) {
  107842:	1e05      	subs	r5, r0, #0
  107844:	db23      	blt.n	10788e <dw_i2c_write_reg_data+0xce>
    addr_buf = (u8 *)malloc(cnt_reg + cnt);
  107846:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  107848:	18fd      	adds	r5, r7, r3
  10784a:	4628      	mov	r0, r5
  10784c:	f009 fe80 	bl	111550 <malloc>
    memcpy(addr_buf, reg, cnt_reg);
  107850:	463a      	mov	r2, r7
  107852:	4649      	mov	r1, r9
    addr_buf = (u8 *)malloc(cnt_reg + cnt);
  107854:	4682      	mov	r10, r0
    memcpy(addr_buf, reg, cnt_reg);
  107856:	f00c e824 	blx	1138a0 <memcpy>
    memcpy(addr_buf + cnt_reg, data, cnt);
  10785a:	e9dd 120e 	ldrd	r1, r2, [r13, #56]	; 0x38
  10785e:	eb0a 0007 	add.w	r0, r10, r7
  107862:	f00c e81e 	blx	1138a0 <memcpy>
    p_i2c_con->msgs_num = 1;
  107866:	2201      	movs	r2, #1
    msg.flags = I2C_M_WR;
  107868:	2300      	movs	r3, #0
    p_i2c_con->msgs = &msg;
  10786a:	a903      	add	r1, sp, #12
    p_i2c_con->msgs_num = 1;
  10786c:	6462      	str	r2, [r4, #68]	; 0x44
    ret = dw_i2c_transfer(p_i2c_con);
  10786e:	4620      	mov	r0, r4
    p_i2c_con->msgs = &msg;
  107870:	6421      	str	r1, [r4, #64]	; 0x40
    msg.len   = cnt_reg + cnt;
  107872:	f8ad 5010 	strh.w	r5, [r13, #16]
    msg.buf   = (u8 *)addr_buf;
  107876:	f8cd a014 	str.w	r10, [r13, #20]
    msg.addr  = address;
  10787a:	f8ad 800c 	strh.w	r8, [r13, #12]
    msg.flags = I2C_M_WR;
  10787e:	f8ad 300e 	strh.w	r3, [r13, #14]
    ret = dw_i2c_transfer(p_i2c_con);
  107882:	f7ff fdd3 	bl	10742c <dw_i2c_transfer>
  107886:	4605      	mov	r5, r0
    free(addr_buf);
  107888:	4650      	mov	r0, r10
  10788a:	f009 fe77 	bl	11157c <free>
    mutex_release(&p_i2c_con->bus_mutex);
  10788e:	4630      	mov	r0, r6
  107890:	f00e fea0 	bl	1165d4 <mutex_release>
}
  107894:	4628      	mov	r0, r5
  107896:	b006      	add	sp, #24
  107898:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        ret = dw_i2c_transmit(p_i2c_con, address, data, cnt, false, true);
  10789c:	9000      	str	r0, [sp, #0]
  10789e:	4641      	mov	r1, r8
  1078a0:	9601      	str	r6, [sp, #4]
  1078a2:	4620      	mov	r0, r4
  1078a4:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
  1078a8:	f7ff fe1e 	bl	1074e8 <dw_i2c_transmit>
  1078ac:	4605      	mov	r5, r0
        dw_i2c_wait_fifo_clear(p_i2c_con);
  1078ae:	4620      	mov	r0, r4
  1078b0:	f7ff fd38 	bl	107324 <dw_i2c_wait_fifo_clear>
  1078b4:	e79a      	b.n	1077ec <dw_i2c_write_reg_data+0x2c>
  1078b6:	bf00      	nop

001078b8 <dw_i2c_read_reg_data>:

status_t dw_i2c_read_reg_data(dw_i2c_context *p_i2c_con, uint8_t address,
                              void *reg, size_t cnt_reg, void *data, size_t cnt)
{
  1078b8:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    status_t ret;

    if (p_i2c_con->info.poll == 1) {
  1078bc:	69c6      	ldr	r6, [r0, #28]
{
  1078be:	b089      	sub	sp, #36	; 0x24
  1078c0:	4604      	mov	r4, r0
  1078c2:	4688      	mov	r8, r1
    if (p_i2c_con->info.poll == 1) {
  1078c4:	2e01      	cmp	r6, #1
  1078c6:	d12c      	bne.n	107922 <dw_i2c_read_reg_data+0x6a>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1078c8:	f3ef 8500 	mrs	r5, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1078cc:	f015 0780 	ands.w	r7, r5, #128	; 0x80
  1078d0:	d00d      	beq.n	1078ee <dw_i2c_read_reg_data+0x36>
    *lock = 1;
  1078d2:	6306      	str	r6, [r0, #48]	; 0x30
        spin_lock_saved_state_t states;
        spin_lock_irqsave(&p_i2c_con->bus_lock, states);
        ret = dw_i2c_transmit(p_i2c_con, address, reg, cnt_reg, true, false);
  1078d4:	2700      	movs	r7, #0
  1078d6:	e9cd 6700 	strd	r6, r7, [r13]
  1078da:	f7ff fe05 	bl	1074e8 <dw_i2c_transmit>

        if (ret != NO_ERROR)
  1078de:	4605      	mov	r5, r0
  1078e0:	2800      	cmp	r0, #0
  1078e2:	d04f      	beq.n	107984 <dw_i2c_read_reg_data+0xcc>
    *lock = 0;
  1078e4:	6327      	str	r7, [r4, #48]	; 0x30
    dprintf(I2C_LOG, "\n%s: addr=0x%x, reg[0]=0x%x, cnt_reg=%d, cnt=%d\n",
            __func__, address, ((u8 *)reg)[0], (u32)cnt_reg, (u32)cnt);
    ret = dw_i2c_transfer(p_i2c_con);
    mutex_release(&p_i2c_con->bus_mutex);
    return ret;
}
  1078e6:	4628      	mov	r0, r5
  1078e8:	b009      	add	sp, #36	; 0x24
  1078ea:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    __asm__ volatile("cpsid i");
  1078ee:	b672      	cpsid	i
    *lock = 1;
  1078f0:	6306      	str	r6, [r0, #48]	; 0x30
        ret = dw_i2c_transmit(p_i2c_con, address, reg, cnt_reg, true, false);
  1078f2:	e9cd 6700 	strd	r6, r7, [r13]
  1078f6:	f7ff fdf7 	bl	1074e8 <dw_i2c_transmit>
        if (ret != NO_ERROR)
  1078fa:	4605      	mov	r5, r0
  1078fc:	b958      	cbnz	r0, 107916 <dw_i2c_read_reg_data+0x5e>
        ret = dw_i2c_receive(p_i2c_con, address, data, cnt, false, true);
  1078fe:	9000      	str	r0, [sp, #0]
  107900:	4641      	mov	r1, r8
  107902:	9601      	str	r6, [sp, #4]
  107904:	4620      	mov	r0, r4
  107906:	e9dd 2310 	ldrd	r2, r3, [r13, #64]	; 0x40
  10790a:	f7ff fe53 	bl	1075b4 <dw_i2c_receive>
  10790e:	4605      	mov	r5, r0
        dw_i2c_wait_fifo_clear(p_i2c_con);
  107910:	4620      	mov	r0, r4
  107912:	f7ff fd07 	bl	107324 <dw_i2c_wait_fifo_clear>
    *lock = 0;
  107916:	6327      	str	r7, [r4, #48]	; 0x30
    __asm__ volatile("cpsie i");
  107918:	b662      	cpsie	i
}
  10791a:	4628      	mov	r0, r5
  10791c:	b009      	add	sp, #36	; 0x24
  10791e:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
  107922:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    mutex_acquire(&p_i2c_con->bus_mutex);
  107926:	f100 062c 	add.w	r6, r0, #44	; 0x2c
  10792a:	4630      	mov	r0, r6
  10792c:	4617      	mov	r7, r2
  10792e:	4699      	mov	r9, r3
  107930:	f00e fe0c 	bl	11654c <mutex_acquire_timeout>
    ret = dw_i2c_wait_bus_not_busy(p_i2c_con);
  107934:	4620      	mov	r0, r4
  107936:	f7ff fd05 	bl	107344 <dw_i2c_wait_bus_not_busy>
    if (ret < 0) {
  10793a:	1e05      	subs	r5, r0, #0
  10793c:	db1b      	blt.n	107976 <dw_i2c_read_reg_data+0xbe>
    msgs[1].len   = cnt;
  10793e:	9911      	ldr	r1, [sp, #68]	; 0x44
    p_i2c_con->msgs = msgs;
  107940:	ab02      	add	r3, sp, #8
    msgs[0].flags = I2C_M_WR;
  107942:	2200      	movs	r2, #0
    msgs[0].addr  = address;
  107944:	fa1f f888 	uxth.w	r8, r8
    p_i2c_con->msgs = msgs;
  107948:	6423      	str	r3, [r4, #64]	; 0x40
    p_i2c_con->msgs_num = 2;
  10794a:	2302      	movs	r3, #2
    msgs[1].len   = cnt;
  10794c:	f8ad 1018 	strh.w	r1, [r13, #24]
    ret = dw_i2c_transfer(p_i2c_con);
  107950:	4620      	mov	r0, r4
    p_i2c_con->msgs_num = 2;
  107952:	6463      	str	r3, [r4, #68]	; 0x44
    msgs[1].flags = I2C_M_RD;
  107954:	2301      	movs	r3, #1
    msgs[1].buf   = (u8 *)data;
  107956:	9910      	ldr	r1, [sp, #64]	; 0x40
    msgs[0].addr  = address;
  107958:	f8ad 8008 	strh.w	r8, [r13, #8]
    msgs[1].addr  = address;
  10795c:	f8ad 8014 	strh.w	r8, [r13, #20]
    msgs[0].len   = cnt_reg;
  107960:	f8ad 900c 	strh.w	r9, [r13, #12]
    msgs[0].buf   = (u8 *)reg;
  107964:	9704      	str	r7, [sp, #16]
    msgs[1].buf   = (u8 *)data;
  107966:	9107      	str	r1, [sp, #28]
    msgs[0].flags = I2C_M_WR;
  107968:	f8ad 200a 	strh.w	r2, [r13, #10]
    msgs[1].flags = I2C_M_RD;
  10796c:	f8ad 3016 	strh.w	r3, [r13, #22]
    ret = dw_i2c_transfer(p_i2c_con);
  107970:	f7ff fd5c 	bl	10742c <dw_i2c_transfer>
  107974:	4605      	mov	r5, r0
    mutex_release(&p_i2c_con->bus_mutex);
  107976:	4630      	mov	r0, r6
  107978:	f00e fe2c 	bl	1165d4 <mutex_release>
}
  10797c:	4628      	mov	r0, r5
  10797e:	b009      	add	sp, #36	; 0x24
  107980:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        ret = dw_i2c_receive(p_i2c_con, address, data, cnt, false, true);
  107984:	9000      	str	r0, [sp, #0]
  107986:	4641      	mov	r1, r8
  107988:	9601      	str	r6, [sp, #4]
  10798a:	4620      	mov	r0, r4
  10798c:	e9dd 2310 	ldrd	r2, r3, [r13, #64]	; 0x40
  107990:	f7ff fe10 	bl	1075b4 <dw_i2c_receive>
  107994:	4605      	mov	r5, r0
        dw_i2c_wait_fifo_clear(p_i2c_con);
  107996:	4620      	mov	r0, r4
  107998:	f7ff fcc4 	bl	107324 <dw_i2c_wait_fifo_clear>
  10799c:	e7a2      	b.n	1078e4 <dw_i2c_read_reg_data+0x2c>
  10799e:	bf00      	nop

001079a0 <dw_i2c_common_xfer>:

status_t dw_i2c_common_xfer(dw_i2c_context *p_i2c_con,
                            struct i2c_msg *msgs, int num)
{
  1079a0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    status_t ret;
    spin_lock_saved_state_t states;

    if (num <= 0) {
  1079a4:	1e17      	subs	r7, r2, #0
{
  1079a6:	b085      	sub	sp, #20
    if (num <= 0) {
  1079a8:	f340 809e 	ble.w	107ae8 <dw_i2c_common_xfer+0x148>
        dprintf(0, "%s: i2c msg num invalid\n", __func__);
        return -1;
    }

    if (p_i2c_con->info.poll == 1) {
  1079ac:	69c3      	ldr	r3, [r0, #28]
  1079ae:	4606      	mov	r6, r0
  1079b0:	460c      	mov	r4, r1
  1079b2:	2b01      	cmp	r3, #1
  1079b4:	d156      	bne.n	107a64 <dw_i2c_common_xfer+0xc4>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1079b6:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1079ba:	0612      	lsls	r2, r2, #24
    spin_lock_saved_state_t state = 0;
  1079bc:	bf44      	itt	mi
  1079be:	2300      	movmi	r3, #0
  1079c0:	9303      	strmi	r3, [sp, #12]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1079c2:	d401      	bmi.n	1079c8 <dw_i2c_common_xfer+0x28>
    __asm__ volatile("cpsid i");
  1079c4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1079c6:	9303      	str	r3, [sp, #12]
  1079c8:	8860      	ldrh	r0, [r4, #2]
  1079ca:	8821      	ldrh	r1, [r4, #0]
  1079cc:	68a2      	ldr	r2, [r4, #8]
    *lock = 1;
  1079ce:	f04f 0a01 	mov.w	r10, #1
        spin_lock_irqsave(&p_i2c_con->bus_lock, states);

        if (num == 1) {
  1079d2:	4557      	cmp	r7, r10
  1079d4:	88a3      	ldrh	r3, [r4, #4]
  1079d6:	f8c6 a030 	str.w	r10, [r6, #48]	; 0x30
  1079da:	d05d      	beq.n	107a98 <dw_i2c_common_xfer+0xf8>
            }

            dw_i2c_wait_fifo_clear(p_i2c_con);
        }
        else {
            for (int i = 0; i < num; i++) {
  1079dc:	2500      	movs	r5, #0
  1079de:	340c      	adds	r4, #12
                                             true, false);
                    else if (i == num - 1)
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
                                             false, true);
                    else
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  1079e0:	46ab      	mov	r11, r5
                }
                else {
                    if (i == 0)
                        ret = dw_i2c_transmit(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
                                              true, false);
                    else if (i == num - 1)
  1079e2:	f107 39ff 	add.w	r9, r7, #4294967295	; 0xffffffff
  1079e6:	e01e      	b.n	107a26 <dw_i2c_common_xfer+0x86>
                    if (i == 0)
  1079e8:	2d00      	cmp	r5, #0
  1079ea:	d076      	beq.n	107ada <dw_i2c_common_xfer+0x13a>
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  1079ec:	4630      	mov	r0, r6
                    else if (i == num - 1)
  1079ee:	45a9      	cmp	r9, r5
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  1079f0:	bf0c      	ite	eq
  1079f2:	e9cd ba00 	strdeq	r11, r10, [r13]
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  1079f6:	e9cd bb00 	strdne	r11, r11, [r13]
  1079fa:	f7ff fddb 	bl	1075b4 <dw_i2c_receive>
  1079fe:	4680      	mov	r8, r0
                    else
                        ret = dw_i2c_transmit(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
                                              false, false);
                }

                dw_i2c_wait_fifo_clear(p_i2c_con);
  107a00:	4630      	mov	r0, r6
  107a02:	f7ff fc8f 	bl	107324 <dw_i2c_wait_fifo_clear>

                if (ret != NO_ERROR)
  107a06:	f1b8 0f00 	cmp.w	r8, #0
  107a0a:	d122      	bne.n	107a52 <dw_i2c_common_xfer+0xb2>
            for (int i = 0; i < num; i++) {
  107a0c:	3501      	adds	r5, #1
  107a0e:	42af      	cmp	r7, r5
  107a10:	f104 040c 	add.w	r4, r4, #12
  107a14:	d01d      	beq.n	107a52 <dw_i2c_common_xfer+0xb2>
  107a16:	f854 2c04 	ldr.w	r2, [r4, #-4]
  107a1a:	f834 0c0a 	ldrh.w	r0, [r4, #-10]
  107a1e:	f834 1c0c 	ldrh.w	r1, [r4, #-12]
  107a22:	f834 3c08 	ldrh.w	r3, [r4, #-8]
                if (msgs[i].flags & I2C_M_RD) {
  107a26:	f010 0001 	ands.w	r0, r0, #1
  107a2a:	b2c9      	uxtb	r1, r1
  107a2c:	d1dc      	bne.n	1079e8 <dw_i2c_common_xfer+0x48>
                    if (i == 0)
  107a2e:	2d00      	cmp	r5, #0
  107a30:	d044      	beq.n	107abc <dw_i2c_common_xfer+0x11c>
                    else if (i == num - 1)
  107a32:	45a9      	cmp	r9, r5
                        ret = dw_i2c_transmit(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  107a34:	bf0c      	ite	eq
  107a36:	e9cd 0a00 	strdeq	r0, r10, [r13]
                        ret = dw_i2c_transmit(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  107a3a:	e9cd 0000 	strdne	r0, r0, [r13]
  107a3e:	4630      	mov	r0, r6
  107a40:	f7ff fd52 	bl	1074e8 <dw_i2c_transmit>
  107a44:	4680      	mov	r8, r0
                dw_i2c_wait_fifo_clear(p_i2c_con);
  107a46:	4630      	mov	r0, r6
  107a48:	f7ff fc6c 	bl	107324 <dw_i2c_wait_fifo_clear>
                if (ret != NO_ERROR)
  107a4c:	f1b8 0f00 	cmp.w	r8, #0
  107a50:	d0dc      	beq.n	107a0c <dw_i2c_common_xfer+0x6c>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  107a52:	9b03      	ldr	r3, [sp, #12]
    *lock = 0;
  107a54:	2200      	movs	r2, #0
  107a56:	6332      	str	r2, [r6, #48]	; 0x30
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  107a58:	b103      	cbz	r3, 107a5c <dw_i2c_common_xfer+0xbc>
    __asm__ volatile("cpsie i");
  107a5a:	b662      	cpsie	i
        ret = dw_i2c_transfer(p_i2c_con);
        mutex_release(&p_i2c_con->bus_mutex);
    }

    return ret;
}
  107a5c:	4640      	mov	r0, r8
  107a5e:	b005      	add	sp, #20
  107a60:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  107a64:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        mutex_acquire(&p_i2c_con->bus_mutex);
  107a68:	f100 052c 	add.w	r5, r0, #44	; 0x2c
  107a6c:	4628      	mov	r0, r5
  107a6e:	f00e fd6d 	bl	11654c <mutex_acquire_timeout>
        ret = dw_i2c_wait_bus_not_busy(p_i2c_con);
  107a72:	4630      	mov	r0, r6
  107a74:	f7ff fc66 	bl	107344 <dw_i2c_wait_bus_not_busy>
        if (ret < 0) {
  107a78:	f1b0 0800 	subs.w	r8, r0, #0
  107a7c:	db05      	blt.n	107a8a <dw_i2c_common_xfer+0xea>
        p_i2c_con->msgs = msgs;
  107a7e:	6434      	str	r4, [r6, #64]	; 0x40
        ret = dw_i2c_transfer(p_i2c_con);
  107a80:	4630      	mov	r0, r6
        p_i2c_con->msgs_num = num;
  107a82:	6477      	str	r7, [r6, #68]	; 0x44
        ret = dw_i2c_transfer(p_i2c_con);
  107a84:	f7ff fcd2 	bl	10742c <dw_i2c_transfer>
  107a88:	4680      	mov	r8, r0
        mutex_release(&p_i2c_con->bus_mutex);
  107a8a:	4628      	mov	r0, r5
  107a8c:	f00e fda2 	bl	1165d4 <mutex_release>
}
  107a90:	4640      	mov	r0, r8
  107a92:	b005      	add	sp, #20
  107a94:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (msgs[0].flags & I2C_M_RD) {
  107a98:	f010 0f01 	tst.w	r0, #1
                ret = dw_i2c_receive(p_i2c_con, msgs[0].addr, msgs[0].buf, msgs[0].len,
  107a9c:	e9cd 7700 	strd	r7, r7, [r13]
  107aa0:	b2c9      	uxtb	r1, r1
  107aa2:	4630      	mov	r0, r6
            if (msgs[0].flags & I2C_M_RD) {
  107aa4:	d006      	beq.n	107ab4 <dw_i2c_common_xfer+0x114>
                ret = dw_i2c_receive(p_i2c_con, msgs[0].addr, msgs[0].buf, msgs[0].len,
  107aa6:	f7ff fd85 	bl	1075b4 <dw_i2c_receive>
  107aaa:	4680      	mov	r8, r0
            dw_i2c_wait_fifo_clear(p_i2c_con);
  107aac:	4630      	mov	r0, r6
  107aae:	f7ff fc39 	bl	107324 <dw_i2c_wait_fifo_clear>
  107ab2:	e7ce      	b.n	107a52 <dw_i2c_common_xfer+0xb2>
                ret = dw_i2c_transmit(p_i2c_con, msgs[0].addr, msgs[0].buf, msgs[0].len,
  107ab4:	f7ff fd18 	bl	1074e8 <dw_i2c_transmit>
  107ab8:	4680      	mov	r8, r0
  107aba:	e7f7      	b.n	107aac <dw_i2c_common_xfer+0x10c>
                        ret = dw_i2c_transmit(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  107abc:	e9cd a500 	strd	r10, r5, [r13]
  107ac0:	4630      	mov	r0, r6
  107ac2:	f7ff fd11 	bl	1074e8 <dw_i2c_transmit>
  107ac6:	4680      	mov	r8, r0
                dw_i2c_wait_fifo_clear(p_i2c_con);
  107ac8:	4630      	mov	r0, r6
  107aca:	f7ff fc2b 	bl	107324 <dw_i2c_wait_fifo_clear>
                if (ret != NO_ERROR)
  107ace:	f1b8 0f00 	cmp.w	r8, #0
  107ad2:	d1be      	bne.n	107a52 <dw_i2c_common_xfer+0xb2>
            for (int i = 0; i < num; i++) {
  107ad4:	2501      	movs	r5, #1
  107ad6:	340c      	adds	r4, #12
  107ad8:	e79d      	b.n	107a16 <dw_i2c_common_xfer+0x76>
                        ret = dw_i2c_receive(p_i2c_con, msgs[i].addr, msgs[i].buf, msgs[i].len,
  107ada:	e9cd a500 	strd	r10, r5, [r13]
  107ade:	4630      	mov	r0, r6
  107ae0:	f7ff fd68 	bl	1075b4 <dw_i2c_receive>
  107ae4:	4680      	mov	r8, r0
  107ae6:	e7ef      	b.n	107ac8 <dw_i2c_common_xfer+0x128>
        dprintf(0, "%s: i2c msg num invalid\n", __func__);
  107ae8:	f648 1130 	movw	r1, #35120	; 0x8930
  107aec:	f648 1044 	movw	r0, #35140	; 0x8944
  107af0:	f2c0 0111 	movt	r1, #17
        return -1;
  107af4:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
        dprintf(0, "%s: i2c msg num invalid\n", __func__);
  107af8:	f2c0 0011 	movt	r0, #17
  107afc:	f00c fe82 	bl	114804 <printf>
        return -1;
  107b00:	e7ac      	b.n	107a5c <dw_i2c_common_xfer+0xbc>
  107b02:	bf00      	nop

00107b04 <arm_gic_init_percpu>:
{
#if WITH_LIB_SM
    GICREG(GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
    GICREG(GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
#else
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107b04:	f44f 5200 	mov.w	r2, #8192	; 0x2000
#endif
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107b08:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107b0c:	2001      	movs	r0, #1
  107b0e:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107b12:	21ff      	movs	r1, #255	; 0xff
  107b14:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107b18:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107b1a:	6019      	str	r1, [r3, #0]
}
  107b1c:	4770      	bx	r14
  107b1e:	bf00      	nop

00107b20 <arm_gic_suspend_cpu>:
                   LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_FLAG_SECONDARY_CPUS);

static void arm_gic_suspend_cpu(uint level)
{
    suspend_resume_fiq(false, false);
}
  107b20:	4770      	bx	r14
  107b22:	bf00      	nop

00107b24 <__arm_gic_get_priority_shift>:

static uint8_t __arm_gic_get_priority_shift(uint irq)
{
    u_int reg = irq / 4;
    u_int shift = 8 * (irq % 4);
    uint32_t origin_reg = GICREG(GICD_IPRIORITYR(reg));
  107b24:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
  107b28:	f020 0303 	bic.w	r3, r0, #3
  107b2c:	f2cf 5140 	movt	r1, #62784	; 0xf540
  107b30:	4419      	add	r1, r3
    u_int shift = 8 * (irq % 4);
  107b32:	f000 0303 	and.w	r3, r0, #3
{
  107b36:	b4f0      	push	{r4, r5, r6, r7}

    gic_set_enable(irq, false);
    //write a mask to check implemented bits.
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  107b38:	25ff      	movs	r5, #255	; 0xff
    int reg = vector / 32;
  107b3a:	0942      	lsrs	r2, r0, #5
    uint32_t origin_reg = GICREG(GICD_IPRIORITYR(reg));
  107b3c:	680f      	ldr	r7, [r1, #0]
    u_int shift = 8 * (irq % 4);
  107b3e:	00dc      	lsls	r4, r3, #3
        GICREG(GICD_ICENABLER(reg)) = mask;
  107b40:	f502 628c 	add.w	r2, r2, #1120	; 0x460
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  107b44:	fa05 f304 	lsl.w	r3, r5, r4
    uint32_t mask = 1ULL << (vector % 32);
  107b48:	2501      	movs	r5, #1
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  107b4a:	ea27 0603 	bic.w	r6, r7, r3
        GICREG(GICD_ICENABLER(reg)) = mask;
  107b4e:	0092      	lsls	r2, r2, #2
    uint32_t mask = 1ULL << (vector % 32);
  107b50:	f000 001f 	and.w	r0, r0, #31
  107b54:	fa05 f000 	lsl.w	r0, r5, r0
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  107b58:	431e      	orrs	r6, r3
        GICREG(GICD_ICENABLER(reg)) = mask;
  107b5a:	f1a2 652c 	sub.w	r5, r2, #180355072	; 0xac00000
        GICREG(GICD_ISENABLER(reg)) = mask;
  107b5e:	462a      	mov	r2, r5
        GICREG(GICD_ICENABLER(reg)) = mask;
  107b60:	6028      	str	r0, [r5, #0]
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  107b62:	600e      	str	r6, [r1, #0]

    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  107b64:	680d      	ldr	r5, [r1, #0]

    uint8_t pri_bit_shift = sanity ? 3 : 4;

    GICREG(GICD_IPRIORITYR(reg)) = origin_reg;
  107b66:	600f      	str	r7, [r1, #0]
        GICREG(GICD_ISENABLER(reg)) = mask;
  107b68:	f842 0c80 	str.w	r0, [r2, #-128]
    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  107b6c:	402b      	ands	r3, r5
  107b6e:	40e3      	lsrs	r3, r4

    gic_set_enable(irq, true);


    return pri_bit_shift;
}
  107b70:	bcf0      	pop	{r4, r5, r6, r7}
    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  107b72:	011b      	lsls	r3, r3, #4
    uint8_t pri_bit_shift = sanity ? 3 : 4;
  107b74:	f013 0ff0 	tst.w	r3, #240	; 0xf0
}
  107b78:	bf14      	ite	ne
  107b7a:	2003      	movne	r0, #3
  107b7c:	2004      	moveq	r0, #4
  107b7e:	4770      	bx	r14

00107b80 <arm_gic_register_int_handler>:
    if (vector >= MAX_INT)
  107b80:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
{
  107b84:	b510      	push	{r4, r14}
    if (vector >= MAX_INT)
  107b86:	d21e      	bcs.n	107bc6 <arm_gic_register_int_handler+0x46>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107b88:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107b8c:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  107b8e:	bf48      	it	mi
  107b90:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107b92:	d515      	bpl.n	107bc0 <arm_gic_register_int_handler+0x40>
    if (vector < GIC_MAX_PER_CPU_INT)
  107b94:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
  107b96:	bf93      	iteet	ls
  107b98:	f64e 43d4 	movwls	r3, #60628	; 0xecd4
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107b9c:	f1a0 0320 	subhi.w	r3, r0, #32
  107ba0:	f64e 50d4 	movwhi	r0, #60884	; 0xedd4
        return &int_handler_table_per_cpu[vector][cpu];
  107ba4:	f2c0 0312 	movtls	r3, #18
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107ba8:	bf8a      	itet	hi
  107baa:	f2c0 0012 	movthi	r0, #18
        return &int_handler_table_per_cpu[vector][cpu];
  107bae:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107bb2:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
        h->arg = arg;
  107bb6:	e9c0 1200 	strd	r1, r2, [r0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  107bba:	b104      	cbz	r4, 107bbe <arm_gic_register_int_handler+0x3e>
    __asm__ volatile("cpsie i");
  107bbc:	b662      	cpsie	i
}
  107bbe:	bd10      	pop	{r4, r15}
    __asm__ volatile("cpsid i");
  107bc0:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  107bc2:	2401      	movs	r4, #1
  107bc4:	e7e6      	b.n	107b94 <arm_gic_register_int_handler+0x14>
        panic("register_int_handler: vector out of range %d\n", vector);
  107bc6:	f648 11ac 	movw	r1, #35244	; 0x89ac
  107bca:	4602      	mov	r2, r0
  107bcc:	4670      	mov	r0, r14
  107bce:	f2c0 0111 	movt	r1, #17
  107bd2:	f00b fde3 	bl	11379c <_panic>
  107bd6:	bf00      	nop

00107bd8 <arm_gic_init>:
    for (i = 0; i < MAX_INT; i+= 32) {
  107bd8:	2200      	movs	r2, #0
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  107bda:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
  107bde:	b410      	push	{r4}
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  107be0:	1153      	asrs	r3, r2, #5
  107be2:	f503 638c 	add.w	r3, r3, #1120	; 0x460
    for (i = 0; i < MAX_INT; i+= 32) {
  107be6:	3220      	adds	r2, #32
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  107be8:	009b      	lsls	r3, r3, #2
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  107bea:	f503 7180 	add.w	r1, r3, #256	; 0x100
  107bee:	f1a1 612c 	sub.w	r1, r1, #180355072	; 0xac00000
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  107bf2:	f1a3 632c 	sub.w	r3, r3, #180355072	; 0xac00000
    for (i = 0; i < MAX_INT; i+= 32) {
  107bf6:	f5b2 7f90 	cmp.w	r2, #288	; 0x120
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  107bfa:	6018      	str	r0, [r3, #0]
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  107bfc:	6008      	str	r0, [r1, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
  107bfe:	d1ef      	bne.n	107be0 <arm_gic_init+0x8>
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
  107c00:	f241 0304 	movw	r3, #4100	; 0x1004
  107c04:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107c08:	681b      	ldr	r3, [r3, #0]
    if (arm_gic_max_cpu() > 0) {
  107c0a:	f013 0fe0 	tst.w	r3, #224	; 0xe0
  107c0e:	d016      	beq.n	107c3e <arm_gic_init+0x66>
  107c10:	f648 14dc 	movw	r4, #35292	; 0x89dc
  107c14:	f04f 3101 	mov.w	r1, #16843009	; 0x1010101
        for (i = 32; i < MAX_INT; i += 4) {
  107c18:	2220      	movs	r2, #32
  107c1a:	f2c0 0411 	movt	r4, #17
  107c1e:	2308      	movs	r3, #8
  107c20:	e001      	b.n	107c26 <arm_gic_init+0x4e>
  107c22:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  107c26:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
        for (i = 32; i < MAX_INT; i += 4) {
  107c2a:	3204      	adds	r2, #4
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  107c2c:	009b      	lsls	r3, r3, #2
  107c2e:	f1a3 602c 	sub.w	r0, r3, #180355072	; 0xac00000
        for (i = 32; i < MAX_INT; i += 4) {
  107c32:	f5b2 7f8a 	cmp.w	r2, #276	; 0x114
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  107c36:	6001      	str	r1, [r0, #0]
  107c38:	ea4f 03a2 	mov.w	r3, r2, asr #2
        for (i = 32; i < MAX_INT; i += 4) {
  107c3c:	d1f1      	bne.n	107c22 <arm_gic_init+0x4a>
    GICREG(GICD_CTLR) = 1; // enable GIC0
  107c3e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c42:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c46:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICD_CTLR) = 1; // enable GIC0
  107c4a:	2101      	movs	r1, #1
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c4c:	24ff      	movs	r4, #255	; 0xff
    GICREG(GICD_CTLR) = 1; // enable GIC0
  107c4e:	f2cf 5040 	movt	r0, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c52:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICD_CTLR) = 1; // enable GIC0
  107c56:	6001      	str	r1, [r0, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c58:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c5c:	6011      	str	r1, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c5e:	601c      	str	r4, [r3, #0]
}
  107c60:	f85d 4b04 	ldr.w	r4, [r13], #4
  107c64:	4770      	bx	r14
  107c66:	bf00      	nop

00107c68 <arm_gic_resume_cpu>:
{
  107c68:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107c6a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107c6e:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
  107c70:	bf48      	it	mi
  107c72:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107c74:	d401      	bmi.n	107c7a <arm_gic_resume_cpu+0x12>
    __asm__ volatile("cpsid i");
  107c76:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  107c78:	2401      	movs	r4, #1
    if (!(GICREG(GICD_CTLR) & 1)) {
  107c7a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  107c7e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107c82:	681b      	ldr	r3, [r3, #0]
  107c84:	07db      	lsls	r3, r3, #31
  107c86:	d50e      	bpl.n	107ca6 <arm_gic_resume_cpu+0x3e>
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c88:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c8c:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c90:	2001      	movs	r0, #1
  107c92:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c96:	21ff      	movs	r1, #255	; 0xff
  107c98:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  107c9c:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  107c9e:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  107ca0:	b104      	cbz	r4, 107ca4 <arm_gic_resume_cpu+0x3c>
    __asm__ volatile("cpsie i");
  107ca2:	b662      	cpsie	i
}
  107ca4:	bd10      	pop	{r4, r15}
        arm_gic_init();
  107ca6:	f7ff ff97 	bl	107bd8 <arm_gic_init>
  107caa:	e7f9      	b.n	107ca0 <arm_gic_resume_cpu+0x38>

00107cac <arm_gic_set_priority>:
    return ret;
}


status_t arm_gic_set_priority(u_int irq, uint8_t priority)
{
  107cac:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  107cb0:	460c      	mov	r4, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107cb2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107cb6:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  107cb8:	bf48      	it	mi
  107cba:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107cbe:	d402      	bmi.n	107cc6 <arm_gic_set_priority+0x1a>
    __asm__ volatile("cpsid i");
  107cc0:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  107cc2:	f04f 0801 	mov.w	r8, #1
    regval = GICREG(GICD_IPRIORITYR(reg));
  107cc6:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
  107cca:	f020 0303 	bic.w	r3, r0, #3
  107cce:	f2cf 5540 	movt	r5, #62784	; 0xf540
  107cd2:	441d      	add	r5, r3
    u_int shift = 8 * (irq % 4);
  107cd4:	f000 0603 	and.w	r6, r0, #3
    regval = GICREG(GICD_IPRIORITYR(reg));
  107cd8:	682f      	ldr	r7, [r5, #0]
    priority = priority << (__arm_gic_get_priority_shift(irq));
  107cda:	f7ff ff23 	bl	107b24 <__arm_gic_get_priority_shift>
    u_int mask = 0xff << shift;
  107cde:	23ff      	movs	r3, #255	; 0xff
    u_int shift = 8 * (irq % 4);
  107ce0:	00f6      	lsls	r6, r6, #3
    u_int mask = 0xff << shift;
  107ce2:	40b3      	lsls	r3, r6
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
  107ce4:	ea27 0703 	bic.w	r7, r7, r3
    priority = priority << (__arm_gic_get_priority_shift(irq));
  107ce8:	fa04 f000 	lsl.w	r0, r4, r0
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
  107cec:	b2c0      	uxtb	r0, r0
  107cee:	40b0      	lsls	r0, r6
  107cf0:	4338      	orrs	r0, r7
    GICREG(GICD_IPRIORITYR(reg)) = regval;
  107cf2:	6028      	str	r0, [r5, #0]
    spin_lock_saved_state_t state;

    spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
    __arm_gic_set_priority_locked(irq, priority);
    DSB;
  107cf4:	f3bf 8f4f 	dsb	sy
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  107cf8:	f1b8 0f00 	cmp.w	r8, #0
  107cfc:	d000      	beq.n	107d00 <arm_gic_set_priority+0x54>
    __asm__ volatile("cpsie i");
  107cfe:	b662      	cpsie	i
    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return 0;
}
  107d00:	2000      	movs	r0, #0
  107d02:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  107d06:	bf00      	nop

00107d08 <arm_gic_mask_interrupt>:
    return NO_ERROR;
}

status_t arm_gic_mask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
  107d08:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
  107d0c:	d216      	bcs.n	107d3c <arm_gic_mask_interrupt+0x34>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107d0e:	f3ef 8200 	mrs	r2, CPSR
  107d12:	2101      	movs	r1, #1
  107d14:	0943      	lsrs	r3, r0, #5
  107d16:	f503 638c 	add.w	r3, r3, #1120	; 0x460
  107d1a:	f000 001f 	and.w	r0, r0, #31
  107d1e:	4081      	lsls	r1, r0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107d20:	f012 0080 	ands.w	r0, r2, #128	; 0x80
  107d24:	ea4f 0383 	mov.w	r3, r3, lsl #2
  107d28:	f1a3 632c 	sub.w	r3, r3, #180355072	; 0xac00000
  107d2c:	d103      	bne.n	107d36 <arm_gic_mask_interrupt+0x2e>
    __asm__ volatile("cpsid i");
  107d2e:	b672      	cpsid	i
        GICREG(GICD_ICENABLER(reg)) = mask;
  107d30:	6019      	str	r1, [r3, #0]
    __asm__ volatile("cpsie i");
  107d32:	b662      	cpsie	i
  107d34:	4770      	bx	r14
  107d36:	6019      	str	r1, [r3, #0]
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, false);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
  107d38:	2000      	movs	r0, #0
  107d3a:	4770      	bx	r14
        return ERR_INVALID_ARGS;
  107d3c:	f06f 0007 	mvn.w	r0, #7
}
  107d40:	4770      	bx	r14
  107d42:	bf00      	nop

00107d44 <arm_gic_unmask_interrupt>:

status_t arm_gic_unmask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
  107d44:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
  107d48:	d216      	bcs.n	107d78 <arm_gic_unmask_interrupt+0x34>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107d4a:	f3ef 8200 	mrs	r2, CPSR
  107d4e:	2101      	movs	r1, #1
  107d50:	0943      	lsrs	r3, r0, #5
  107d52:	f503 6388 	add.w	r3, r3, #1088	; 0x440
  107d56:	f000 001f 	and.w	r0, r0, #31
  107d5a:	4081      	lsls	r1, r0
  107d5c:	f012 0080 	ands.w	r0, r2, #128	; 0x80
  107d60:	ea4f 0383 	mov.w	r3, r3, lsl #2
  107d64:	f1a3 632c 	sub.w	r3, r3, #180355072	; 0xac00000
  107d68:	d103      	bne.n	107d72 <arm_gic_unmask_interrupt+0x2e>
    __asm__ volatile("cpsid i");
  107d6a:	b672      	cpsid	i
        GICREG(GICD_ISENABLER(reg)) = mask;
  107d6c:	6019      	str	r1, [r3, #0]
    __asm__ volatile("cpsie i");
  107d6e:	b662      	cpsie	i
  107d70:	4770      	bx	r14
  107d72:	6019      	str	r1, [r3, #0]
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, true);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
  107d74:	2000      	movs	r0, #0
  107d76:	4770      	bx	r14
        return ERR_INVALID_ARGS;
  107d78:	f06f 0007 	mvn.w	r0, #7
}
  107d7c:	4770      	bx	r14
  107d7e:	bf00      	nop

00107d80 <platform_irq>:

static
enum handler_return __platform_irq(struct iframe *frame)
{
    // get the current vector
    uint32_t iar = GICREG(GICC_IAR);
  107d80:	f242 030c 	movw	r3, #8204	; 0x200c
    unsigned int vector = iar & 0x3ff;

    if (vector >= 0x3fe) {
  107d84:	f240 31fd 	movw	r1, #1021	; 0x3fd
    uint32_t iar = GICREG(GICC_IAR);
  107d88:	f2cf 5340 	movt	r3, #62784	; 0xf540

    return ret;
}

enum handler_return platform_irq(struct iframe *frame)
{
  107d8c:	b510      	push	{r4, r14}
    uint32_t iar = GICREG(GICC_IAR);
  107d8e:	681c      	ldr	r4, [r3, #0]
    unsigned int vector = iar & 0x3ff;
  107d90:	f3c4 0209 	ubfx	r2, r4, #0, #10
    if (vector >= 0x3fe) {
  107d94:	428a      	cmp	r2, r1
  107d96:	d81d      	bhi.n	107dd4 <platform_irq+0x54>
    if (vector < GIC_MAX_PER_CPU_INT)
  107d98:	2a1f      	cmp	r2, #31
        return &int_handler_table_per_cpu[vector][cpu];
  107d9a:	bf93      	iteet	ls
  107d9c:	f64e 43d4 	movwls	r3, #60628	; 0xecd4
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107da0:	3a20      	subhi	r2, #32
  107da2:	f64e 53d4 	movwhi	r3, #60884	; 0xedd4
        return &int_handler_table_per_cpu[vector][cpu];
  107da6:	f2c0 0312 	movtls	r3, #18
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107daa:	bf88      	it	hi
  107dac:	f2c0 0312 	movthi	r3, #18
  107db0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    if (handler->handler)
  107db4:	681a      	ldr	r2, [r3, #0]
  107db6:	b142      	cbz	r2, 107dca <platform_irq+0x4a>
        ret = handler->handler(handler->arg);
  107db8:	6858      	ldr	r0, [r3, #4]
  107dba:	4790      	blx	r2
    GICREG(GICC_EOIR) = iar;
  107dbc:	f242 0310 	movw	r3, #8208	; 0x2010
  107dc0:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107dc4:	601c      	str	r4, [r3, #0]
    else
        ret = sm_handle_irq();
#else
    ret = __platform_irq(frame);
#endif
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  107dc6:	b128      	cbz	r0, 107dd4 <platform_irq+0x54>
        ret = INT_RESCHEDULE;

	}
    return ret;
}
  107dc8:	bd10      	pop	{r4, r15}
    GICREG(GICC_EOIR) = iar;
  107dca:	f242 0310 	movw	r3, #8208	; 0x2010
  107dce:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107dd2:	601c      	str	r4, [r3, #0]
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  107dd4:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  107dd8:	6a18      	ldr	r0, [r3, #32]
  107dda:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
  107dde:	bd10      	pop	{r4, r15}

00107de0 <arm_gic_platform_irq_spotless>:
    if (vector >= 0x3fe) {
  107de0:	f240 33fd 	movw	r3, #1021	; 0x3fd
    unsigned int vector = ack & 0x3ff;
  107de4:	f3c0 0009 	ubfx	r0, r0, #0, #10
    if (vector >= 0x3fe) {
  107de8:	4298      	cmp	r0, r3
  107dea:	d814      	bhi.n	107e16 <arm_gic_platform_irq_spotless+0x36>
    if (vector < GIC_MAX_PER_CPU_INT)
  107dec:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
  107dee:	bf93      	iteet	ls
  107df0:	f64e 43d4 	movwls	r3, #60628	; 0xecd4
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107df4:	f1a0 0320 	subhi.w	r3, r0, #32
  107df8:	f64e 50d4 	movwhi	r0, #60884	; 0xedd4
        return &int_handler_table_per_cpu[vector][cpu];
  107dfc:	f2c0 0312 	movtls	r3, #18
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107e00:	bf8a      	itet	hi
  107e02:	f2c0 0012 	movthi	r0, #18
        return &int_handler_table_per_cpu[vector][cpu];
  107e06:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  107e0a:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
    if (handler->handler)
  107e0e:	6803      	ldr	r3, [r0, #0]
  107e10:	b10b      	cbz	r3, 107e16 <arm_gic_platform_irq_spotless+0x36>
        ret = handler->handler(handler->arg);
  107e12:	6840      	ldr	r0, [r0, #4]
  107e14:	4718      	bx	r3

enum handler_return arm_gic_platform_irq_spotless(unsigned int ack)
{
    return __platform_irq_spotless(ack);
}
  107e16:	2000      	movs	r0, #0
  107e18:	4770      	bx	r14
  107e1a:	bf00      	nop

00107e1c <platform_fiq>:
void platform_fiq(struct iframe *frame)
{
#if WITH_LIB_SM
    sm_handle_fiq();
#else
    PANIC_UNIMPLEMENTED;
  107e1c:	f648 129c 	movw	r2, #35228	; 0x899c
  107e20:	f648 21f0 	movw	r1, #35568	; 0x8af0
{
  107e24:	b508      	push	{r3, r14}
    PANIC_UNIMPLEMENTED;
  107e26:	4670      	mov	r0, r14
  107e28:	f2c0 0211 	movt	r2, #17
  107e2c:	f2c0 0111 	movt	r1, #17
  107e30:	f00b fcb4 	bl	11379c <_panic>

00107e34 <pll_config>:
#define PFPLL_FRAC_MIN                  0
#define PFPLL_FRAC_MAX                  (int)BIT_MASK(24)

static void validate_pll_cfg(const pll_config_t *config)
{
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  107e34:	68cb      	ldr	r3, [r1, #12]
        ASSERT(config->spread >= 1 && config->spread <= 31);
    }
}

void pll_config(paddr_t pll_base, const pll_config_t *config)
{
  107e36:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  107e3a:	3b01      	subs	r3, #1
  107e3c:	2b3e      	cmp	r3, #62	; 0x3e
{
  107e3e:	b095      	sub	sp, #84	; 0x54
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  107e40:	f200 8110 	bhi.w	108064 <pll_config+0x230>
    ASSERT(config->postdiv[0] >= config->postdiv[1]);
  107e44:	e9d1 3205 	ldrd	r3, r2, [r1, #20]
  107e48:	460e      	mov	r6, r1
  107e4a:	4293      	cmp	r3, r2
  107e4c:	f0c0 811b 	bcc.w	108086 <pll_config+0x252>
        ASSERT(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  107e50:	3b01      	subs	r3, #1
  107e52:	2b06      	cmp	r3, #6
  107e54:	f200 80f5 	bhi.w	108042 <pll_config+0x20e>
  107e58:	3a01      	subs	r2, #1
  107e5a:	2a06      	cmp	r2, #6
  107e5c:	f200 80f1 	bhi.w	108042 <pll_config+0x20e>
  107e60:	4604      	mov	r4, r0
    if (config->integer) {
  107e62:	790a      	ldrb	r2, [r1, #4]
  107e64:	2a00      	cmp	r2, #0
  107e66:	f040 80a4 	bne.w	107fb2 <pll_config+0x17e>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_FRAC_MIN &&
  107e6a:	690b      	ldr	r3, [r1, #16]
  107e6c:	f1a3 0114 	sub.w	r1, r3, #20
  107e70:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
  107e74:	f200 8118 	bhi.w	1080a8 <pll_config+0x274>
        ASSERT(config->frac >= PFPLL_FRAC_MIN &&
  107e78:	69f1      	ldr	r1, [r6, #28]
  107e7a:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
  107e7e:	f080 8135 	bcs.w	1080ec <pll_config+0x2b8>
    if (config->spread_spectrum) {
  107e82:	f896 a005 	ldrb.w	r10, [r6, #5]
  107e86:	f1ba 0f00 	cmp.w	r10, #0
  107e8a:	d004      	beq.n	107e96 <pll_config+0x62>
        ASSERT(config->spread >= 1 && config->spread <= 31);
  107e8c:	68b1      	ldr	r1, [r6, #8]
  107e8e:	3901      	subs	r1, #1
  107e90:	291e      	cmp	r1, #30
  107e92:	f200 813c 	bhi.w	10810e <pll_config+0x2da>
    LTRACEF("outdiv 0x%x 0x%x 0x%x 0x%x\n",
            config->out_div[0], config->out_div[1],
            config->out_div[2], config->out_div[3]);
    validate_pll_cfg(config);
    /* Configure refdiv, fbdiv and postdiv. */
    writel(config->fbdiv, base + PLL_FBDIV);
  107e96:	60a3      	str	r3, [r4, #8]
    writel((config->refdiv << PLL_DIV_REFDIV) +
  107e98:	e9d6 0305 	ldrd	r0, r3, [r6, #20]
  107e9c:	68f1      	ldr	r1, [r6, #12]
  107e9e:	025b      	lsls	r3, r3, #9
  107ea0:	eb03 1380 	add.w	r3, r3, r0, lsl #6
  107ea4:	440b      	add	r3, r1
  107ea6:	6063      	str	r3, [r4, #4]
           (config->postdiv[0] << PLL_DIV_POSTDIV1) +
           (config->postdiv[1] << PLL_DIV_POSTDIV2),
           base + PLL_DIV);

    if (config->integer) {
  107ea8:	2a00      	cmp	r2, #0
  107eaa:	f000 80a0 	beq.w	107fee <pll_config+0x1ba>
        /* Integer mode. */
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 1);
  107eae:	6823      	ldr	r3, [r4, #0]
  107eb0:	f043 0302 	orr.w	r3, r3, #2
  107eb4:	6023      	str	r3, [r4, #0]
        writel(config->frac, base + PLL_FRAC);
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 0);
    }

    /* Enable PLL. */
    RMWREG32(base + PLL_CTRL, PLL_CTRL_PLLEN, 1, 1);
  107eb6:	6823      	ldr	r3, [r4, #0]
  107eb8:	f043 0301 	orr.w	r3, r3, #1
  107ebc:	6023      	str	r3, [r4, #0]

    /* Wait until PLL is locked. */
    while (!(readl(base + PLL_CTRL) & (1 << PLL_CTRL_LOCK)));
  107ebe:	6823      	ldr	r3, [r4, #0]
  107ec0:	2b00      	cmp	r3, #0
  107ec2:	dafc      	bge.n	107ebe <pll_config+0x8a>
  107ec4:	f10d 0910 	add.w	r9, r13, #16
  107ec8:	4649      	mov	r1, r9
  107eca:	f106 0220 	add.w	r2, r6, #32
  107ece:	f106 0030 	add.w	r0, r6, #48	; 0x30
     * XXX_CG_EN=1 means turning on the clock.
     */
    int out_div_en[PLL_OUT_DIV_MAX];

    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
        out_div_en[i] = (config->out_div[i] > 0);
  107ed2:	f852 3b04 	ldr.w	r3, [r2], #4
  107ed6:	3300      	adds	r3, #0
  107ed8:	bf18      	it	ne
  107eda:	2301      	movne	r3, #1
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  107edc:	4282      	cmp	r2, r0
        out_div_en[i] = (config->out_div[i] > 0);
  107ede:	f841 3b04 	str.w	r3, [r1], #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  107ee2:	d1f6      	bne.n	107ed2 <pll_config+0x9e>
    writel(val, base + PLL_CTRL);
    struct pll_out_div_cfg {
        uint32_t reg;
        uint32_t num_bit;
        uint32_t busy_bit;
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107ee4:	f648 3340 	movw	r3, #35648	; 0x8b40
  107ee8:	f10d 0c20 	add.w	r12, r13, #32
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  107eec:	f8dd 8010 	ldr.w	r8, [r13, #16]
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107ef0:	f2c0 0311 	movt	r3, #17
  107ef4:	461f      	mov	r7, r3
  107ef6:	2500      	movs	r5, #0
    val = readl(base + PLL_CTRL);
  107ef8:	f8d4 b000 	ldr.w	r11, [r4]
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  107efc:	ea4f 4e88 	mov.w	r14, r8, lsl #18
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107f00:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  107f02:	f50e 3e80 	add.w	r14, r14, #65536	; 0x10000
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107f06:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
           + (out_div_en[PLL_OUT_DIV_B] << PLL_CTRL_PLL_DIVB_CG_EN)
  107f0a:	e9dd 3205 	ldrd	r3, r2, [r13, #20]
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  107f0e:	f10e 0e10 	add.w	r14, r14, #16
           + (out_div_en[PLL_OUT_DIV_B] << PLL_CTRL_PLL_DIVB_CG_EN)
  107f12:	eb0e 4ec3 	add.w	r14, r14, r3, lsl #19
           + (out_div_en[PLL_OUT_DIV_D] << PLL_CTRL_PLL_DIVD_CG_EN);
  107f16:	9b07      	ldr	r3, [sp, #28]
           + (out_div_en[PLL_OUT_DIV_C] << PLL_CTRL_PLL_DIVC_CG_EN)
  107f18:	eb0e 5e02 	add.w	r14, r14, r2, lsl #20
           + (out_div_en[PLL_OUT_DIV_D] << PLL_CTRL_PLL_DIVD_CG_EN);
  107f1c:	eb0e 5e43 	add.w	r14, r14, r3, lsl #21
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107f20:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  107f22:	9703      	str	r7, [sp, #12]
    val |= (1 << PLL_CTRL_FOUTPOSTDIVEN)
  107f24:	ea4e 070b 	orr.w	r7, r14, r11
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107f28:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
  107f2c:	9b03      	ldr	r3, [sp, #12]

    /* Configure outside divider clocks. */
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
        if (out_div_en[i]) {
            /* Configure outside division number. */
            RMWREG32(base + out_div_cfg[i].reg,
  107f2e:	f04f 0b0f 	mov.w	r11, #15
    writel(val, base + PLL_CTRL);
  107f32:	6027      	str	r7, [r4, #0]
                     4,
                     config->out_div[i] - 1);

            /* Wait div busy bit. */
            while (readl(base + out_div_cfg[i].reg) &
                    (1 << out_div_cfg[i].busy_bit));
  107f34:	f04f 0e01 	mov.w	r14, #1
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  107f38:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  107f3a:	e88c 000f 	stmia.w	r12, {r0, r1, r2, r3}
        if (out_div_en[i]) {
  107f3e:	f1b8 0f00 	cmp.w	r8, #0
  107f42:	d107      	bne.n	107f54 <pll_config+0x120>
  107f44:	3504      	adds	r5, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  107f46:	2d10      	cmp	r5, #16
  107f48:	d021      	beq.n	107f8e <pll_config+0x15a>
  107f4a:	f859 8005 	ldr.w	r8, [r9, r5]
        if (out_div_en[i]) {
  107f4e:	f1b8 0f00 	cmp.w	r8, #0
  107f52:	d0f7      	beq.n	107f44 <pll_config+0x110>
  107f54:	eb05 0345 	add.w	r3, r5, r5, lsl #1
  107f58:	a908      	add	r1, sp, #32
            RMWREG32(base + out_div_cfg[i].reg,
  107f5a:	1972      	adds	r2, r6, r5
  107f5c:	18cf      	adds	r7, r1, r3
  107f5e:	58c8      	ldr	r0, [r1, r3]
  107f60:	6a13      	ldr	r3, [r2, #32]
  107f62:	f8d7 c004 	ldr.w	r12, [r7, #4]
  107f66:	5821      	ldr	r1, [r4, r0]
  107f68:	3b01      	subs	r3, #1
                    (1 << out_div_cfg[i].busy_bit));
  107f6a:	68ba      	ldr	r2, [r7, #8]
            RMWREG32(base + out_div_cfg[i].reg,
  107f6c:	fa0b f70c 	lsl.w	r7, r11, r12
  107f70:	ea21 0107 	bic.w	r1, r1, r7
  107f74:	fa03 f30c 	lsl.w	r3, r3, r12
  107f78:	430b      	orrs	r3, r1
                    (1 << out_div_cfg[i].busy_bit));
  107f7a:	fa0e f202 	lsl.w	r2, r14, r2
            RMWREG32(base + out_div_cfg[i].reg,
  107f7e:	5023      	str	r3, [r4, r0]
  107f80:	1821      	adds	r1, r4, r0
            while (readl(base + out_div_cfg[i].reg) &
  107f82:	680b      	ldr	r3, [r1, #0]
  107f84:	4213      	tst	r3, r2
  107f86:	d1fc      	bne.n	107f82 <pll_config+0x14e>
  107f88:	3504      	adds	r5, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  107f8a:	2d10      	cmp	r5, #16
  107f8c:	d1dd      	bne.n	107f4a <pll_config+0x116>
        }
    }

    /* Enable SS modulator if necessary. */
    /* Modulators may be required for display modules to reduce EMI. */
    if (config->spread_spectrum) {
  107f8e:	f1ba 0f00 	cmp.w	r10, #0
  107f92:	d133      	bne.n	107ffc <pll_config+0x1c8>
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DIVVAL, 5, 15);
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 0);
        /* TODO - add modulation parameters. */
    }
    else {
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 1);
  107f94:	69a3      	ldr	r3, [r4, #24]
  107f96:	f043 0302 	orr.w	r3, r3, #2
  107f9a:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_RESETPTR, 1, 1);
  107f9c:	69a3      	ldr	r3, [r4, #24]
  107f9e:	f043 0304 	orr.w	r3, r3, #4
  107fa2:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 1);
  107fa4:	69a3      	ldr	r3, [r4, #24]
  107fa6:	f043 0301 	orr.w	r3, r3, #1
  107faa:	61a3      	str	r3, [r4, #24]
    }
}
  107fac:	b015      	add	sp, #84	; 0x54
  107fae:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ASSERT(!config->spread_spectrum);
  107fb2:	f891 a005 	ldrb.w	r10, [r1, #5]
  107fb6:	f1ba 0f00 	cmp.w	r10, #0
  107fba:	f040 8086 	bne.w	1080ca <pll_config+0x296>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_INTEGER_MIN &&
  107fbe:	690b      	ldr	r3, [r1, #16]
  107fc0:	f1a3 0110 	sub.w	r1, r3, #16
  107fc4:	f5b1 7f1c 	cmp.w	r1, #624	; 0x270
  107fc8:	f67f af65 	bls.w	107e96 <pll_config+0x62>
  107fcc:	f648 43a0 	movw	r3, #36000	; 0x8ca0
  107fd0:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  107fd4:	f647 4134 	movw	r1, #31796	; 0x7c34
  107fd8:	f2c0 0311 	movt	r3, #17
  107fdc:	4670      	mov	r0, r14
  107fde:	f2c0 0211 	movt	r2, #17
  107fe2:	9300      	str	r3, [sp, #0]
  107fe4:	f2c0 0111 	movt	r1, #17
  107fe8:	2376      	movs	r3, #118	; 0x76
  107fea:	f00b fbd7 	bl	11379c <_panic>
        writel(config->frac, base + PLL_FRAC);
  107fee:	69f3      	ldr	r3, [r6, #28]
  107ff0:	60e3      	str	r3, [r4, #12]
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 0);
  107ff2:	6823      	ldr	r3, [r4, #0]
  107ff4:	f023 0302 	bic.w	r3, r3, #2
  107ff8:	6023      	str	r3, [r4, #0]
  107ffa:	e75c      	b.n	107eb6 <pll_config+0x82>
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 0);
  107ffc:	69a2      	ldr	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DOWNSPREAD, 1, config->downspread);
  107ffe:	79b1      	ldrb	r1, [r6, #6]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 0);
  108000:	f022 0202 	bic.w	r2, r2, #2
  108004:	61a2      	str	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_RESETPTR, 1, 0);
  108006:	69a2      	ldr	r2, [r4, #24]
  108008:	f022 0204 	bic.w	r2, r2, #4
  10800c:	61a2      	str	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DOWNSPREAD, 1, config->downspread);
  10800e:	69a3      	ldr	r3, [r4, #24]
  108010:	f023 0308 	bic.w	r3, r3, #8
  108014:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  108018:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_SPREAD, 5, config->spread);
  10801a:	69a3      	ldr	r3, [r4, #24]
  10801c:	68b2      	ldr	r2, [r6, #8]
  10801e:	f423 73f8 	bic.w	r3, r3, #496	; 0x1f0
  108022:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  108026:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DIVVAL, 5, 15);
  108028:	69a3      	ldr	r3, [r4, #24]
  10802a:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
  10802e:	f443 53f0 	orr.w	r3, r3, #7680	; 0x1e00
  108032:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 0);
  108034:	69a3      	ldr	r3, [r4, #24]
  108036:	f023 0301 	bic.w	r3, r3, #1
  10803a:	61a3      	str	r3, [r4, #24]
}
  10803c:	b015      	add	sp, #84	; 0x54
  10803e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ASSERT(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  108042:	f648 4330 	movw	r3, #35888	; 0x8c30
  108046:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  10804a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10804e:	f2c0 0311 	movt	r3, #17
  108052:	4670      	mov	r0, r14
  108054:	f2c0 0211 	movt	r2, #17
  108058:	9300      	str	r3, [sp, #0]
  10805a:	f2c0 0111 	movt	r1, #17
  10805e:	2370      	movs	r3, #112	; 0x70
  108060:	f00b fb9c 	bl	11379c <_panic>
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  108064:	f648 33b8 	movw	r3, #35768	; 0x8bb8
  108068:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  10806c:	f647 4134 	movw	r1, #31796	; 0x7c34
  108070:	f2c0 0311 	movt	r3, #17
  108074:	4670      	mov	r0, r14
  108076:	f2c0 0211 	movt	r2, #17
  10807a:	9300      	str	r3, [sp, #0]
  10807c:	f2c0 0111 	movt	r1, #17
  108080:	236b      	movs	r3, #107	; 0x6b
  108082:	f00b fb8b 	bl	11379c <_panic>
    ASSERT(config->postdiv[0] >= config->postdiv[1]);
  108086:	f648 4304 	movw	r3, #35844	; 0x8c04
  10808a:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  10808e:	f647 4134 	movw	r1, #31796	; 0x7c34
  108092:	f2c0 0311 	movt	r3, #17
  108096:	4670      	mov	r0, r14
  108098:	f2c0 0211 	movt	r2, #17
  10809c:	9300      	str	r3, [sp, #0]
  10809e:	f2c0 0111 	movt	r1, #17
  1080a2:	236c      	movs	r3, #108	; 0x6c
  1080a4:	f00b fb7a 	bl	11379c <_panic>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_FRAC_MIN &&
  1080a8:	f648 43f8 	movw	r3, #36088	; 0x8cf8
  1080ac:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  1080b0:	f647 4134 	movw	r1, #31796	; 0x7c34
  1080b4:	f2c0 0311 	movt	r3, #17
  1080b8:	4670      	mov	r0, r14
  1080ba:	f2c0 0211 	movt	r2, #17
  1080be:	9300      	str	r3, [sp, #0]
  1080c0:	f2c0 0111 	movt	r1, #17
  1080c4:	237a      	movs	r3, #122	; 0x7a
  1080c6:	f00b fb69 	bl	11379c <_panic>
        ASSERT(!config->spread_spectrum);
  1080ca:	f648 4384 	movw	r3, #35972	; 0x8c84
  1080ce:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  1080d2:	f647 4134 	movw	r1, #31796	; 0x7c34
  1080d6:	f2c0 0311 	movt	r3, #17
  1080da:	4670      	mov	r0, r14
  1080dc:	f2c0 0211 	movt	r2, #17
  1080e0:	9300      	str	r3, [sp, #0]
  1080e2:	f2c0 0111 	movt	r1, #17
  1080e6:	2374      	movs	r3, #116	; 0x74
  1080e8:	f00b fb58 	bl	11379c <_panic>
        ASSERT(config->frac >= PFPLL_FRAC_MIN &&
  1080ec:	f648 5348 	movw	r3, #36168	; 0x8d48
  1080f0:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  1080f4:	f647 4134 	movw	r1, #31796	; 0x7c34
  1080f8:	f2c0 0311 	movt	r3, #17
  1080fc:	4670      	mov	r0, r14
  1080fe:	f2c0 0211 	movt	r2, #17
  108102:	9300      	str	r3, [sp, #0]
  108104:	f2c0 0111 	movt	r1, #17
  108108:	237c      	movs	r3, #124	; 0x7c
  10810a:	f00b fb47 	bl	11379c <_panic>
        ASSERT(config->spread >= 1 && config->spread <= 31);
  10810e:	f648 538c 	movw	r3, #36236	; 0x8d8c
  108112:	f648 32a0 	movw	r2, #35744	; 0x8ba0
  108116:	f647 4134 	movw	r1, #31796	; 0x7c34
  10811a:	f2c0 0311 	movt	r3, #17
  10811e:	4670      	mov	r0, r14
  108120:	f2c0 0211 	movt	r2, #17
  108124:	9300      	str	r3, [sp, #0]
  108126:	f2c0 0111 	movt	r1, #17
  10812a:	2380      	movs	r3, #128	; 0x80
  10812c:	f00b fb36 	bl	11379c <_panic>

00108130 <pll_config_get>:
void pll_config_get(paddr_t pll_base, pll_config_t *config)
{
    addr_t base = _ioaddr(pll_base);
    uint32_t val;
    /* get refdiv, fbdiv and postdiv. */
    config->fbdiv = readl(base + PLL_FBDIV);
  108130:	6883      	ldr	r3, [r0, #8]
{
  108132:	4684      	mov	r12, r0
  108134:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    config->fbdiv = readl(base + PLL_FBDIV);
  108138:	610b      	str	r3, [r1, #16]
{
  10813a:	460f      	mov	r7, r1
    val = readl(base + PLL_DIV);
  10813c:	6843      	ldr	r3, [r0, #4]
{
  10813e:	b090      	sub	sp, #64	; 0x40
    config->refdiv = (val >> PLL_DIV_REFDIV) & ((1 << 6) - 1);
    config->postdiv[0] = (val >> PLL_DIV_POSTDIV1) & ((1 << 3) - 1);
  108140:	f3c3 1282 	ubfx	r2, r3, #6, #3
    config->refdiv = (val >> PLL_DIV_REFDIV) & ((1 << 6) - 1);
  108144:	f003 013f 	and.w	r1, r3, #63	; 0x3f
    config->postdiv[1] = (val >> PLL_DIV_POSTDIV2) & ((1 << 3) - 1);
  108148:	f3c3 2342 	ubfx	r3, r3, #9, #3
    config->refdiv = (val >> PLL_DIV_REFDIV) & ((1 << 6) - 1);
  10814c:	60f9      	str	r1, [r7, #12]
    config->postdiv[1] = (val >> PLL_DIV_POSTDIV2) & ((1 << 3) - 1);
  10814e:	e9c7 2305 	strd	r2, r3, [r7, #20]
    val = readl(base + PLL_CTRL);
  108152:	6803      	ldr	r3, [r0, #0]
    config->integer = (val >> PLL_CTRL_INT_MODE) & 1;
  108154:	085b      	lsrs	r3, r3, #1
  108156:	f003 0201 	and.w	r2, r3, #1
  10815a:	713a      	strb	r2, [r7, #4]

    if (!config->integer) {
  10815c:	07da      	lsls	r2, r3, #31
  10815e:	d408      	bmi.n	108172 <pll_config_get+0x42>
        /* Fractional mode. get fbdiv fractional part. */
        config->frac = readl(base + PLL_FRAC);
  108160:	68c3      	ldr	r3, [r0, #12]
  108162:	61fb      	str	r3, [r7, #28]
        config->spread_spectrum = (((readl(base + PLL_SSMOD) >>
  108164:	6982      	ldr	r2, [r0, #24]
                                     PLL_SSMOD_MOD_RESET) & 1) == 0);
  108166:	43d3      	mvns	r3, r2
  108168:	f003 0301 	and.w	r3, r3, #1
  10816c:	717b      	strb	r3, [r7, #5]

        if (config->spread_spectrum) {
  10816e:	07d3      	lsls	r3, r2, #31
  108170:	d539      	bpl.n	1081e6 <pll_config_get+0xb6>
    out_div_en[PLL_OUT_DIV_D] = val >> PLL_CTRL_PLL_DIVD_CG_EN & 1;
    struct pll_out_div_cfg {
        uint32_t reg;
        uint32_t num_bit;
        uint32_t busy_bit;
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  108172:	4e21      	ldr	r6, [pc, #132]	; (1081f8 <pll_config_get+0xc8>)
  108174:	f10d 0e10 	add.w	r14, r13, #16
  108178:	4675      	mov	r5, r14
  10817a:	2400      	movs	r4, #0
    val = readl(base + PLL_CTRL);
  10817c:	f8dc 8000 	ldr.w	r8, [r12]
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  108180:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  108182:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  108184:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  108186:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  108188:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
  10818c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    out_div_en[PLL_OUT_DIV_D] = val >> PLL_CTRL_PLL_DIVD_CG_EN & 1;
  108190:	f3c8 5240 	ubfx	r2, r8, #21, #1
    out_div_en[PLL_OUT_DIV_A] = val >> PLL_CTRL_PLL_DIVA_CG_EN & 1;
  108194:	f3c8 4380 	ubfx	r3, r8, #18, #1
    out_div_en[PLL_OUT_DIV_B] = val >> PLL_CTRL_PLL_DIVB_CG_EN & 1;
  108198:	f3c8 40c0 	ubfx	r0, r8, #19, #1
    out_div_en[PLL_OUT_DIV_C] = val >> PLL_CTRL_PLL_DIVC_CG_EN & 1;
  10819c:	f3c8 5100 	ubfx	r1, r8, #20, #1
    out_div_en[PLL_OUT_DIV_B] = val >> PLL_CTRL_PLL_DIVB_CG_EN & 1;
  1081a0:	e9cd 3000 	strd	r3, r0, [r13]
    out_div_en[PLL_OUT_DIV_D] = val >> PLL_CTRL_PLL_DIVD_CG_EN & 1;
  1081a4:	e9cd 1202 	strd	r1, r2, [r13, #8]
  1081a8:	eb04 0244 	add.w	r2, r4, r4, lsl #1
        },
    };

    /* get outside divider clocks. */
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
        if (out_div_en[i]) {
  1081ac:	b163      	cbz	r3, 1081c8 <pll_config_get+0x98>
            val = readl(base + out_div_cfg[i].reg);
  1081ae:	f85e 3002 	ldr.w	r3, [r14, r2]
            config->out_div[i] = ((val >> out_div_cfg[i].num_bit) & 0xf) + 1;
  1081b2:	eb0e 0002 	add.w	r0, r14, r2
  1081b6:	1939      	adds	r1, r7, r4
            val = readl(base + out_div_cfg[i].reg);
  1081b8:	f85c 3003 	ldr.w	r3, [r12, r3]
            config->out_div[i] = ((val >> out_div_cfg[i].num_bit) & 0xf) + 1;
  1081bc:	6842      	ldr	r2, [r0, #4]
  1081be:	40d3      	lsrs	r3, r2
  1081c0:	f003 030f 	and.w	r3, r3, #15
  1081c4:	3301      	adds	r3, #1
  1081c6:	620b      	str	r3, [r1, #32]
  1081c8:	3404      	adds	r4, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  1081ca:	2c10      	cmp	r4, #16
  1081cc:	d008      	beq.n	1081e0 <pll_config_get+0xb0>
  1081ce:	f85d 3004 	ldr.w	r3, [r13, r4]
  1081d2:	eb04 0244 	add.w	r2, r4, r4, lsl #1
        if (out_div_en[i]) {
  1081d6:	2b00      	cmp	r3, #0
  1081d8:	d1e9      	bne.n	1081ae <pll_config_get+0x7e>
  1081da:	3404      	adds	r4, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  1081dc:	2c10      	cmp	r4, #16
  1081de:	d1f6      	bne.n	1081ce <pll_config_get+0x9e>
        }
    }
}
  1081e0:	b010      	add	sp, #64	; 0x40
  1081e2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            config->downspread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_DOWNSPREAD) &
  1081e6:	6982      	ldr	r2, [r0, #24]
            config->spread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_SPREAD) & 0x1f);
  1081e8:	6983      	ldr	r3, [r0, #24]
            config->downspread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_DOWNSPREAD) &
  1081ea:	f3c2 02c0 	ubfx	r2, r2, #3, #1
            config->spread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_SPREAD) & 0x1f);
  1081ee:	f3c3 1304 	ubfx	r3, r3, #4, #5
            config->downspread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_DOWNSPREAD) &
  1081f2:	71ba      	strb	r2, [r7, #6]
            config->spread = ((readl(base + PLL_SSMOD) >> PLL_SSMOD_SPREAD) & 0x1f);
  1081f4:	60bb      	str	r3, [r7, #8]
  1081f6:	e7bc      	b.n	108172 <pll_config_get+0x42>
  1081f8:	00118b70 	.word	0x00118b70

001081fc <stuff_valid_value>:
void stuff_valid_value(pll_config_t *config)
{
    if (!(config->refdiv >= PFPLL_REFDIV_MIN &&
  1081fc:	68c3      	ldr	r3, [r0, #12]
            config->refdiv <= PFPLL_REFDIV_MAX)) {
        config->refdiv = PFPLL_REFDIV_MIN;
    }

    for (int i = 0; i < 2; i++) {
        if (!(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  1081fe:	6942      	ldr	r2, [r0, #20]
    if (!(config->refdiv >= PFPLL_REFDIV_MIN &&
  108200:	3b01      	subs	r3, #1
  108202:	2b3e      	cmp	r3, #62	; 0x3e
        config->refdiv = PFPLL_REFDIV_MIN;
  108204:	bf84      	itt	hi
  108206:	2301      	movhi	r3, #1
  108208:	60c3      	strhi	r3, [r0, #12]
        if (!(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  10820a:	1e53      	subs	r3, r2, #1
  10820c:	2b06      	cmp	r3, #6
                config->postdiv[i] <= PFPLL_POSTDIV_MAX)) {
            config->postdiv[i] = PFPLL_POSTDIV_MIN;
  10820e:	bf82      	ittt	hi
  108210:	2301      	movhi	r3, #1
  108212:	461a      	movhi	r2, r3
  108214:	6143      	strhi	r3, [r0, #20]
        if (!(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  108216:	6983      	ldr	r3, [r0, #24]
  108218:	1e59      	subs	r1, r3, #1
  10821a:	2906      	cmp	r1, #6
            config->postdiv[i] = PFPLL_POSTDIV_MIN;
  10821c:	bf84      	itt	hi
  10821e:	2301      	movhi	r3, #1
  108220:	6183      	strhi	r3, [r0, #24]
        if (!(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  108222:	d802      	bhi.n	10822a <stuff_valid_value+0x2e>
        }
    }

    if (!(config->postdiv[0] >= config->postdiv[1])) {
  108224:	429a      	cmp	r2, r3
        config->postdiv[0] = config->postdiv[1];
  108226:	bf38      	it	cc
  108228:	6143      	strcc	r3, [r0, #20]
  10822a:	6903      	ldr	r3, [r0, #16]
    }

    if (config->integer) {
  10822c:	7902      	ldrb	r2, [r0, #4]
  10822e:	b152      	cbz	r2, 108246 <stuff_valid_value+0x4a>
        if (config->spread_spectrum) {
  108230:	7942      	ldrb	r2, [r0, #5]
  108232:	b10a      	cbz	r2, 108238 <stuff_valid_value+0x3c>
            config->spread_spectrum = 0;
  108234:	2200      	movs	r2, #0
  108236:	7142      	strb	r2, [r0, #5]
        }

        if (!(config->fbdiv >= PFPLL_FBDIV_INTEGER_MIN &&
  108238:	3b10      	subs	r3, #16
  10823a:	f5b3 7f1c 	cmp.w	r3, #624	; 0x270
  10823e:	d90e      	bls.n	10825e <stuff_valid_value+0x62>
                config->fbdiv <= PFPLL_FBDIV_INTEGER_MAX)) {
            config->fbdiv = PFPLL_FBDIV_INTEGER_MIN;
  108240:	2310      	movs	r3, #16
  108242:	6103      	str	r3, [r0, #16]
  108244:	4770      	bx	r14
        }
    }
    else {
        if (!(config->fbdiv >= PFPLL_FBDIV_FRAC_MIN &&
  108246:	3b14      	subs	r3, #20
  108248:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
                config->fbdiv <= PFPLL_FBDIV_FRAC_MAX)) {
            config->fbdiv = PFPLL_FBDIV_FRAC_MIN;
  10824c:	bf84      	itt	hi
  10824e:	2314      	movhi	r3, #20
  108250:	6103      	strhi	r3, [r0, #16]
        }

        if (!(config->frac >= PFPLL_FRAC_MIN &&
  108252:	69c3      	ldr	r3, [r0, #28]
  108254:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
                config->frac <= PFPLL_FRAC_MAX)) {
            config->frac = PFPLL_FRAC_MIN;
  108258:	bf24      	itt	cs
  10825a:	2300      	movcs	r3, #0
  10825c:	61c3      	strcs	r3, [r0, #28]
        }
    }
}
  10825e:	4770      	bx	r14

00108260 <pmu_check.part.0>:
}

static int32_t pmu_check(pmudev_t *dev)
{
	if (dev->name == NULL || dev->base_paddr == NULL
	        || dev->base_vaddr == NULL || dev->init_flag == 0)
  108260:	6903      	ldr	r3, [r0, #16]
  108262:	b123      	cbz	r3, 10826e <pmu_check.part.0+0xe>
  108264:	6880      	ldr	r0, [r0, #8]
  108266:	fab0 f080 	clz	r0, r0
  10826a:	0940      	lsrs	r0, r0, #5
  10826c:	4770      	bx	r14
		return 1;
  10826e:	2001      	movs	r0, #1
	return 0;
}
  108270:	4770      	bx	r14
  108272:	bf00      	nop

00108274 <pmu_init>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108274:	6803      	ldr	r3, [r0, #0]
{
  108276:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108278:	b19b      	cbz	r3, 1082a2 <pmu_init+0x2e>
  10827a:	68c1      	ldr	r1, [r0, #12]
  10827c:	4602      	mov	r2, r0
  10827e:	b181      	cbz	r1, 1082a2 <pmu_init+0x2e>
	        || dev->base_vaddr == NULL) {
  108280:	6901      	ldr	r1, [r0, #16]
  108282:	b171      	cbz	r1, 1082a2 <pmu_init+0x2e>
	dev->init_flag = 1;
  108284:	2401      	movs	r4, #1
	pmu_dbg("%s init okay\n", dev->name);
  108286:	f648 51b8 	movw	r1, #36280	; 0x8db8
  10828a:	f249 2030 	movw	r0, #37424	; 0x9230
  10828e:	f2c0 0111 	movt	r1, #17
	dev->init_flag = 1;
  108292:	6094      	str	r4, [r2, #8]
	pmu_dbg("%s init okay\n", dev->name);
  108294:	f2c0 0011 	movt	r0, #17
  108298:	2217      	movs	r2, #23
  10829a:	f00c fab3 	bl	114804 <printf>
	return 0;
  10829e:	2000      	movs	r0, #0
}
  1082a0:	bd10      	pop	{r4, r15}
		pmu_err("init failure\n");
  1082a2:	f648 51b8 	movw	r1, #36280	; 0x8db8
  1082a6:	f249 2018 	movw	r0, #37400	; 0x9218
  1082aa:	2212      	movs	r2, #18
  1082ac:	f2c0 0111 	movt	r1, #17
  1082b0:	f2c0 0011 	movt	r0, #17
  1082b4:	f00c faa6 	bl	114804 <printf>
		return -1;
  1082b8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1082bc:	bd10      	pop	{r4, r15}
  1082be:	bf00      	nop

001082c0 <pmu_exit>:
	if (dev->init_flag != 1) {
  1082c0:	6882      	ldr	r2, [r0, #8]
{
  1082c2:	b510      	push	{r4, r14}
	if (dev->init_flag != 1) {
  1082c4:	2a01      	cmp	r2, #1
  1082c6:	d110      	bne.n	1082ea <pmu_exit+0x2a>
  1082c8:	4603      	mov	r3, r0
	dev->init_flag = 0;
  1082ca:	2400      	movs	r4, #0
	pmu_dbg("%s exit okay\n", dev->name);
  1082cc:	f648 51c4 	movw	r1, #36292	; 0x8dc4
  1082d0:	f249 10c4 	movw	r0, #37316	; 0x91c4
	dev->init_flag = 0;
  1082d4:	609c      	str	r4, [r3, #8]
	pmu_dbg("%s exit okay\n", dev->name);
  1082d6:	f2c0 0111 	movt	r1, #17
  1082da:	681b      	ldr	r3, [r3, #0]
  1082dc:	2223      	movs	r2, #35	; 0x23
  1082de:	f2c0 0011 	movt	r0, #17
  1082e2:	f00c fa8f 	bl	114804 <printf>
	return 0;
  1082e6:	4620      	mov	r0, r4
}
  1082e8:	bd10      	pop	{r4, r15}
		pmu_err("exit failure\n");
  1082ea:	f648 51c4 	movw	r1, #36292	; 0x8dc4
  1082ee:	f249 10ac 	movw	r0, #37292	; 0x91ac
  1082f2:	221e      	movs	r2, #30
  1082f4:	f2c0 0111 	movt	r1, #17
  1082f8:	f2c0 0011 	movt	r0, #17
  1082fc:	f00c fa82 	bl	114804 <printf>
		return -1;
  108300:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108304:	bd10      	pop	{r4, r15}
  108306:	bf00      	nop

00108308 <pmu_get_status>:
 *              0x08 - PWRDOWN
 *              0x10 - OFF
 *              < 0  - ERROR
 ************************************************/
int32_t pmu_get_status(pmudev_t *dev, int *status)
{
  108308:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10830a:	6803      	ldr	r3, [r0, #0]
  10830c:	b393      	cbz	r3, 108374 <pmu_get_status+0x6c>
  10830e:	68c3      	ldr	r3, [r0, #12]
  108310:	4602      	mov	r2, r0
  108312:	b37b      	cbz	r3, 108374 <pmu_get_status+0x6c>
  108314:	f7ff ffa4 	bl	108260 <pmu_check.part.0>
	uint32_t v = 0;

	if (pmu_check(dev) || status == NULL) {
  108318:	fab1 f381 	clz	r3, r1
  10831c:	095b      	lsrs	r3, r3, #5
  10831e:	2800      	cmp	r0, #0
  108320:	bf0c      	ite	eq
  108322:	4618      	moveq	r0, r3
  108324:	2001      	movne	r0, #1
  108326:	bb28      	cbnz	r0, 108374 <pmu_get_status+0x6c>
		pmu_err("check failure\n");
		return -1;
	}

	v = readl(dev->base_vaddr + PMU_RST_CTRL);
  108328:	6913      	ldr	r3, [r2, #16]
  10832a:	68db      	ldr	r3, [r3, #12]
	v = (v & (0x1f << 24)) >> 24;
  10832c:	f3c3 6304 	ubfx	r3, r3, #24, #5
	if (v != 0x01 && v != 0x02 && v != 0x04 && v != 0x08 && v != 0x10) {
  108330:	1f1a      	subs	r2, r3, #4
  108332:	f032 0204 	bics.w	r2, r2, #4
  108336:	bf18      	it	ne
  108338:	2201      	movne	r2, #1
  10833a:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
  10833e:	bf08      	it	eq
  108340:	2200      	moveq	r2, #0
  108342:	2801      	cmp	r0, #1
  108344:	bf94      	ite	ls
  108346:	2200      	movls	r2, #0
  108348:	f002 0201 	andhi.w	r2, r2, #1
  10834c:	b10a      	cbz	r2, 108352 <pmu_get_status+0x4a>
  10834e:	2b10      	cmp	r3, #16
  108350:	d102      	bne.n	108358 <pmu_get_status+0x50>
		pmu_err("get status fail v = %02x\n", v);
		return -1;
	}
	*status = v;
  108352:	600b      	str	r3, [r1, #0]
	return 0;
  108354:	2000      	movs	r0, #0
}
  108356:	bd08      	pop	{r3, r15}
		pmu_err("get status fail v = %02x\n", v);
  108358:	f648 51d0 	movw	r1, #36304	; 0x8dd0
  10835c:	f249 10f4 	movw	r0, #37364	; 0x91f4
  108360:	224a      	movs	r2, #74	; 0x4a
  108362:	f2c0 0111 	movt	r1, #17
  108366:	f2c0 0011 	movt	r0, #17
  10836a:	f00c fa4b 	bl	114804 <printf>
		return -1;
  10836e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108372:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108374:	f648 51d0 	movw	r1, #36304	; 0x8dd0
  108378:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10837c:	2243      	movs	r2, #67	; 0x43
  10837e:	f2c0 0111 	movt	r1, #17
  108382:	f2c0 0011 	movt	r0, #17
  108386:	f00c fa3d 	bl	114804 <printf>
		return -1;
  10838a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10838e:	bd08      	pop	{r3, r15}

00108390 <pmu_get_event_source>:

int32_t pmu_get_event_source(pmudev_t *dev, uint32_t *event)
{
  108390:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108392:	6803      	ldr	r3, [r0, #0]
  108394:	b18b      	cbz	r3, 1083ba <pmu_get_event_source+0x2a>
  108396:	68c3      	ldr	r3, [r0, #12]
  108398:	4602      	mov	r2, r0
  10839a:	b173      	cbz	r3, 1083ba <pmu_get_event_source+0x2a>
  10839c:	f7ff ff60 	bl	108260 <pmu_check.part.0>
	uint32_t v;

	if (pmu_check(dev) || event == NULL) {
  1083a0:	fab1 f381 	clz	r3, r1
  1083a4:	095b      	lsrs	r3, r3, #5
  1083a6:	2800      	cmp	r0, #0
  1083a8:	bf0c      	ite	eq
  1083aa:	4618      	moveq	r0, r3
  1083ac:	2001      	movne	r0, #1
  1083ae:	b920      	cbnz	r0, 1083ba <pmu_get_event_source+0x2a>
		pmu_err("check failure\n");
		return -1;
	}

	v = readl(dev->base_vaddr + PMU_INTR);
  1083b0:	6913      	ldr	r3, [r2, #16]
  1083b2:	6a1b      	ldr	r3, [r3, #32]
	*event = v & 0xff;
  1083b4:	b2db      	uxtb	r3, r3
  1083b6:	600b      	str	r3, [r1, #0]
	return 0;
}
  1083b8:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1083ba:	f648 51e0 	movw	r1, #36320	; 0x8de0
  1083be:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1083c2:	2256      	movs	r2, #86	; 0x56
  1083c4:	f2c0 0111 	movt	r1, #17
  1083c8:	f2c0 0011 	movt	r0, #17
  1083cc:	f00c fa1a 	bl	114804 <printf>
		return -1;
  1083d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1083d4:	bd08      	pop	{r3, r15}
  1083d6:	bf00      	nop

001083d8 <pmu_clean_single_event_source>:

int32_t pmu_clean_single_event_source(pmudev_t *dev, int event_id)
{
  1083d8:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1083da:	6803      	ldr	r3, [r0, #0]
  1083dc:	b16b      	cbz	r3, 1083fa <pmu_clean_single_event_source+0x22>
  1083de:	68c3      	ldr	r3, [r0, #12]
  1083e0:	4602      	mov	r2, r0
  1083e2:	b153      	cbz	r3, 1083fa <pmu_clean_single_event_source+0x22>
  1083e4:	f7ff ff3c 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || event_id < 0 || event_id > 7) {
  1083e8:	b938      	cbnz	r0, 1083fa <pmu_clean_single_event_source+0x22>
  1083ea:	2907      	cmp	r1, #7
  1083ec:	d805      	bhi.n	1083fa <pmu_clean_single_event_source+0x22>
		pmu_err("check failure\n");
		return -1;
	}

	writel(1 << event_id, dev->base_vaddr + PMU_INTR);
  1083ee:	6912      	ldr	r2, [r2, #16]
  1083f0:	2301      	movs	r3, #1
  1083f2:	fa03 f101 	lsl.w	r1, r3, r1
  1083f6:	6211      	str	r1, [r2, #32]
	return 0;
}
  1083f8:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1083fa:	f648 51f8 	movw	r1, #36344	; 0x8df8
  1083fe:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108402:	2262      	movs	r2, #98	; 0x62
  108404:	f2c0 0111 	movt	r1, #17
  108408:	f2c0 0011 	movt	r0, #17
  10840c:	f00c f9fa 	bl	114804 <printf>
		return -1;
  108410:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108414:	bd08      	pop	{r3, r15}
  108416:	bf00      	nop

00108418 <pmu_clean_all_event_source>:

int32_t pmu_clean_all_event_source(pmudev_t *dev)
{
  108418:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10841a:	6803      	ldr	r3, [r0, #0]
  10841c:	b14b      	cbz	r3, 108432 <pmu_clean_all_event_source+0x1a>
  10841e:	68c3      	ldr	r3, [r0, #12]
  108420:	4602      	mov	r2, r0
  108422:	b133      	cbz	r3, 108432 <pmu_clean_all_event_source+0x1a>
  108424:	f7ff ff1c 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev)) {
  108428:	b918      	cbnz	r0, 108432 <pmu_clean_all_event_source+0x1a>
		pmu_err("check failure\n");
		return -1;
	}

	writel(0xff, dev->base_vaddr + PMU_INTR);
  10842a:	6913      	ldr	r3, [r2, #16]
  10842c:	21ff      	movs	r1, #255	; 0xff
  10842e:	6219      	str	r1, [r3, #32]
	return 0;
}
  108430:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108432:	f648 6118 	movw	r1, #36376	; 0x8e18
  108436:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10843a:	226d      	movs	r2, #109	; 0x6d
  10843c:	f2c0 0111 	movt	r1, #17
  108440:	f2c0 0011 	movt	r0, #17
  108444:	f00c f9de 	bl	114804 <printf>
		return -1;
  108448:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10844c:	bd08      	pop	{r3, r15}
  10844e:	bf00      	nop

00108450 <pmu_powerdown>:

int32_t pmu_powerdown(pmudev_t *dev, int enable)
{
  108450:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108452:	6803      	ldr	r3, [r0, #0]
  108454:	b1b3      	cbz	r3, 108484 <pmu_powerdown+0x34>
  108456:	68c3      	ldr	r3, [r0, #12]
  108458:	4604      	mov	r4, r0
  10845a:	b19b      	cbz	r3, 108484 <pmu_powerdown+0x34>
  10845c:	f7ff ff00 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev)) {
  108460:	4605      	mov	r5, r0
  108462:	b978      	cbnz	r0, 108484 <pmu_powerdown+0x34>
		pmu_err("check failure\n");
		return -1;
	}
	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 8, 1, 0x0);
  108464:	6922      	ldr	r2, [r4, #16]
	spin(1000);
  108466:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	RMWREG32(addr, startbit, width, val);
  10846a:	6913      	ldr	r3, [r2, #16]
  10846c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  108470:	6113      	str	r3, [r2, #16]
	spin(1000);
  108472:	f00b f981 	bl	113778 <spin>
	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 8, 1, 0x1);
  108476:	6922      	ldr	r2, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108478:	6913      	ldr	r3, [r2, #16]
  10847a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  10847e:	6113      	str	r3, [r2, #16]
	return 0;
}
  108480:	4628      	mov	r0, r5
  108482:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108484:	f648 6134 	movw	r1, #36404	; 0x8e34
  108488:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10848c:	2278      	movs	r2, #120	; 0x78
  10848e:	f2c0 0111 	movt	r1, #17
		return -1;
  108492:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		pmu_err("check failure\n");
  108496:	f2c0 0011 	movt	r0, #17
  10849a:	f00c f9b3 	bl	114804 <printf>
		return -1;
  10849e:	e7ef      	b.n	108480 <pmu_powerdown+0x30>

001084a0 <pmu_set_powerdown_delay>:
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerdown_delay(pmudev_t *dev, int id, int delay)
{
  1084a0:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1084a2:	6803      	ldr	r3, [r0, #0]
  1084a4:	b17b      	cbz	r3, 1084c6 <pmu_set_powerdown_delay+0x26>
  1084a6:	68c3      	ldr	r3, [r0, #12]
  1084a8:	4601      	mov	r1, r0
  1084aa:	b163      	cbz	r3, 1084c6 <pmu_set_powerdown_delay+0x26>
  1084ac:	f7ff fed8 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0x0 || delay > 0xf) {
  1084b0:	b948      	cbnz	r0, 1084c6 <pmu_set_powerdown_delay+0x26>
  1084b2:	2a0f      	cmp	r2, #15
  1084b4:	d807      	bhi.n	1084c6 <pmu_set_powerdown_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 4, 4, delay);
  1084b6:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  1084b8:	690b      	ldr	r3, [r1, #16]
  1084ba:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  1084be:	ea43 1202 	orr.w	r2, r3, r2, lsl #4
  1084c2:	610a      	str	r2, [r1, #16]
	return 0;
}
  1084c4:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1084c6:	f648 6144 	movw	r1, #36420	; 0x8e44
  1084ca:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1084ce:	2299      	movs	r2, #153	; 0x99
  1084d0:	f2c0 0111 	movt	r1, #17
  1084d4:	f2c0 0011 	movt	r0, #17
  1084d8:	f00c f994 	bl	114804 <printf>
		return -1;
  1084dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1084e0:	bd08      	pop	{r3, r15}
  1084e2:	bf00      	nop

001084e4 <pmu_set_powerup_delay>:
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerup_delay(pmudev_t *dev, int id, int delay)
{
  1084e4:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1084e6:	6803      	ldr	r3, [r0, #0]
  1084e8:	b173      	cbz	r3, 108508 <pmu_set_powerup_delay+0x24>
  1084ea:	68c3      	ldr	r3, [r0, #12]
  1084ec:	4601      	mov	r1, r0
  1084ee:	b15b      	cbz	r3, 108508 <pmu_set_powerup_delay+0x24>
  1084f0:	f7ff feb6 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0x0 || delay > 0xf) {
  1084f4:	b940      	cbnz	r0, 108508 <pmu_set_powerup_delay+0x24>
  1084f6:	2a0f      	cmp	r2, #15
  1084f8:	d806      	bhi.n	108508 <pmu_set_powerup_delay+0x24>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 0, 4, delay);
  1084fa:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  1084fc:	690b      	ldr	r3, [r1, #16]
  1084fe:	f023 030f 	bic.w	r3, r3, #15
  108502:	431a      	orrs	r2, r3
  108504:	610a      	str	r2, [r1, #16]
	return 0;
}
  108506:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108508:	f648 615c 	movw	r1, #36444	; 0x8e5c
  10850c:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108510:	22b9      	movs	r2, #185	; 0xb9
  108512:	f2c0 0111 	movt	r1, #17
  108516:	f2c0 0011 	movt	r0, #17
  10851a:	f00c f973 	bl	114804 <printf>
		return -1;
  10851e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108522:	bd08      	pop	{r3, r15}

00108524 <pmu_set_powerctrl_powerdown_delay>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108524:	6803      	ldr	r3, [r0, #0]
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerctrl_powerdown_delay(pmudev_t *dev, int ctrl_id, int delay)
{
  108526:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108528:	b343      	cbz	r3, 10857c <pmu_set_powerctrl_powerdown_delay+0x58>
  10852a:	68c3      	ldr	r3, [r0, #12]
  10852c:	4604      	mov	r4, r0
  10852e:	b32b      	cbz	r3, 10857c <pmu_set_powerctrl_powerdown_delay+0x58>
  108530:	f7ff fe96 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || delay < 0x0 || delay > 0xf || ctrl_id < 0 || ctrl_id > 3) {
  108534:	bb10      	cbnz	r0, 10857c <pmu_set_powerctrl_powerdown_delay+0x58>
  108536:	2903      	cmp	r1, #3
  108538:	bf98      	it	ls
  10853a:	2a0f      	cmpls	r2, #15
  10853c:	d81e      	bhi.n	10857c <pmu_set_powerctrl_powerdown_delay+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  10853e:	2902      	cmp	r1, #2
  108540:	d017      	beq.n	108572 <pmu_set_powerctrl_powerdown_delay+0x4e>
  108542:	2903      	cmp	r1, #3
  108544:	d010      	beq.n	108568 <pmu_set_powerctrl_powerdown_delay+0x44>
  108546:	2514      	movs	r5, #20
  108548:	2901      	cmp	r1, #1
  10854a:	bf07      	ittee	eq
  10854c:	f46f 26f0 	mvneq.w	r6, #491520	; 0x78000
  108550:	230f      	moveq	r3, #15
  108552:	f06f 06f0 	mvnne.w	r6, #240	; 0xf0
  108556:	2304      	movne	r3, #4
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 15;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 4, delay);
  108558:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  10855a:	fa02 f303 	lsl.w	r3, r2, r3
  10855e:	594a      	ldr	r2, [r1, r5]
  108560:	4032      	ands	r2, r6
  108562:	431a      	orrs	r2, r3
  108564:	514a      	str	r2, [r1, r5]
	return 0;
}
  108566:	bd70      	pop	{r4, r5, r6, r15}
			break;
  108568:	2518      	movs	r5, #24
  10856a:	f46f 26f0 	mvn.w	r6, #491520	; 0x78000
			reg_start_bit = 15;
  10856e:	230f      	movs	r3, #15
			break;
  108570:	e7f2      	b.n	108558 <pmu_set_powerctrl_powerdown_delay+0x34>
			break;
  108572:	2518      	movs	r5, #24
  108574:	f06f 06f0 	mvn.w	r6, #240	; 0xf0
			reg_start_bit = 4;
  108578:	2304      	movs	r3, #4
			break;
  10857a:	e7ed      	b.n	108558 <pmu_set_powerctrl_powerdown_delay+0x34>
		pmu_err("check failure\n");
  10857c:	f648 6174 	movw	r1, #36468	; 0x8e74
  108580:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108584:	22db      	movs	r2, #219	; 0xdb
  108586:	f2c0 0111 	movt	r1, #17
  10858a:	f2c0 0011 	movt	r0, #17
  10858e:	f00c f939 	bl	114804 <printf>
		return -1;
  108592:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108596:	bd70      	pop	{r4, r5, r6, r15}

00108598 <pmu_set_powerctrl_powerup_delay>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108598:	6803      	ldr	r3, [r0, #0]
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerctrl_powerup_delay(pmudev_t *dev, int ctrl_id, int delay)
{
  10859a:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10859c:	b323      	cbz	r3, 1085e8 <pmu_set_powerctrl_powerup_delay+0x50>
  10859e:	68c3      	ldr	r3, [r0, #12]
  1085a0:	4604      	mov	r4, r0
  1085a2:	b30b      	cbz	r3, 1085e8 <pmu_set_powerctrl_powerup_delay+0x50>
  1085a4:	f7ff fe5c 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || delay < 0x0 || delay > 0xf || ctrl_id < 0 || ctrl_id > 3) {
  1085a8:	b9f0      	cbnz	r0, 1085e8 <pmu_set_powerctrl_powerup_delay+0x50>
  1085aa:	2903      	cmp	r1, #3
  1085ac:	bf98      	it	ls
  1085ae:	2a0f      	cmpls	r2, #15
  1085b0:	d81a      	bhi.n	1085e8 <pmu_set_powerctrl_powerup_delay+0x50>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  1085b2:	2902      	cmp	r1, #2
  1085b4:	d014      	beq.n	1085e0 <pmu_set_powerctrl_powerup_delay+0x48>
  1085b6:	2903      	cmp	r1, #3
  1085b8:	d00d      	beq.n	1085d6 <pmu_set_powerctrl_powerup_delay+0x3e>
			reg_start_bit = 0;
			break;
		case PWR_CTRL_1:
			reg_offset = PMU_CTRL_1;
			reg_start_bit = 11;
			break;
  1085ba:	2514      	movs	r5, #20
	switch (ctrl_id) {
  1085bc:	2901      	cmp	r1, #1
  1085be:	bf12      	itee	ne
  1085c0:	f06f 060f 	mvnne.w	r6, #15
  1085c4:	02d2      	lsleq	r2, r2, #11
			break;
  1085c6:	f46f 46f0 	mvneq.w	r6, #30720	; 0x7800
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 11;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 4, delay);
  1085ca:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  1085cc:	594b      	ldr	r3, [r1, r5]
  1085ce:	4033      	ands	r3, r6
  1085d0:	431a      	orrs	r2, r3
  1085d2:	514a      	str	r2, [r1, r5]
	return 0;
}
  1085d4:	bd70      	pop	{r4, r5, r6, r15}
  1085d6:	02d2      	lsls	r2, r2, #11
			break;
  1085d8:	2518      	movs	r5, #24
  1085da:	f46f 46f0 	mvn.w	r6, #30720	; 0x7800
  1085de:	e7f4      	b.n	1085ca <pmu_set_powerctrl_powerup_delay+0x32>
	switch (ctrl_id) {
  1085e0:	2518      	movs	r5, #24
  1085e2:	f06f 060f 	mvn.w	r6, #15
  1085e6:	e7f0      	b.n	1085ca <pmu_set_powerctrl_powerup_delay+0x32>
		pmu_err("check failure\n");
  1085e8:	f648 6198 	movw	r1, #36504	; 0x8e98
  1085ec:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1085f0:	f44f 7288 	mov.w	r2, #272	; 0x110
  1085f4:	f2c0 0111 	movt	r1, #17
  1085f8:	f2c0 0011 	movt	r0, #17
  1085fc:	f00c f902 	bl	114804 <printf>
		return -1;
  108600:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108604:	bd70      	pop	{r4, r5, r6, r15}
  108606:	bf00      	nop

00108608 <pmu_set_powerctrl_io_mode>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108608:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_powerctrl_io_mode(pmudev_t *dev, int ctrl_id, int mode)
{
  10860a:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10860c:	b343      	cbz	r3, 108660 <pmu_set_powerctrl_io_mode+0x58>
  10860e:	68c3      	ldr	r3, [r0, #12]
  108610:	4604      	mov	r4, r0
  108612:	b32b      	cbz	r3, 108660 <pmu_set_powerctrl_io_mode+0x58>
  108614:	f7ff fe24 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (mode != PWR_CTRL_INPUT && mode != PWR_CTRL_OUTPUT )
  108618:	bb10      	cbnz	r0, 108660 <pmu_set_powerctrl_io_mode+0x58>
	        || ctrl_id < 0 || ctrl_id > 3) {
  10861a:	2903      	cmp	r1, #3
  10861c:	bf98      	it	ls
  10861e:	2a01      	cmpls	r2, #1
  108620:	d81e      	bhi.n	108660 <pmu_set_powerctrl_io_mode+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  108622:	2902      	cmp	r1, #2
  108624:	d017      	beq.n	108656 <pmu_set_powerctrl_io_mode+0x4e>
  108626:	2903      	cmp	r1, #3
  108628:	d010      	beq.n	10864c <pmu_set_powerctrl_io_mode+0x44>
  10862a:	2514      	movs	r5, #20
  10862c:	2901      	cmp	r1, #1
  10862e:	bf07      	ittee	eq
  108630:	f46f 2600 	mvneq.w	r6, #524288	; 0x80000
  108634:	2313      	moveq	r3, #19
  108636:	f46f 7680 	mvnne.w	r6, #256	; 0x100
  10863a:	2308      	movne	r3, #8
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 19;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, mode);
  10863c:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  10863e:	fa02 f303 	lsl.w	r3, r2, r3
  108642:	594a      	ldr	r2, [r1, r5]
  108644:	4032      	ands	r2, r6
  108646:	431a      	orrs	r2, r3
  108648:	514a      	str	r2, [r1, r5]
	return 0;
}
  10864a:	bd70      	pop	{r4, r5, r6, r15}
			break;
  10864c:	2518      	movs	r5, #24
  10864e:	f46f 2600 	mvn.w	r6, #524288	; 0x80000
			reg_start_bit = 19;
  108652:	2313      	movs	r3, #19
			break;
  108654:	e7f2      	b.n	10863c <pmu_set_powerctrl_io_mode+0x34>
			break;
  108656:	2518      	movs	r5, #24
  108658:	f46f 7680 	mvn.w	r6, #256	; 0x100
			reg_start_bit = 8;
  10865c:	2308      	movs	r3, #8
			break;
  10865e:	e7ed      	b.n	10863c <pmu_set_powerctrl_io_mode+0x34>
		pmu_err("check failure\n");
  108660:	f648 61b8 	movw	r1, #36536	; 0x8eb8
  108664:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108668:	f240 1231 	movw	r2, #305	; 0x131
  10866c:	f2c0 0111 	movt	r1, #17
  108670:	f2c0 0011 	movt	r0, #17
  108674:	f00c f8c6 	bl	114804 <printf>
		return -1;
  108678:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10867c:	bd70      	pop	{r4, r5, r6, r15}
  10867e:	bf00      	nop

00108680 <pmu_set_powerctrl_out_mode>:

int32_t pmu_set_powerctrl_out_mode(pmudev_t *dev, int ctrl_id, int mode)
{
  108680:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108682:	6803      	ldr	r3, [r0, #0]
  108684:	b353      	cbz	r3, 1086dc <pmu_set_powerctrl_out_mode+0x5c>
  108686:	68c3      	ldr	r3, [r0, #12]
  108688:	4604      	mov	r4, r0
  10868a:	b33b      	cbz	r3, 1086dc <pmu_set_powerctrl_out_mode+0x5c>
  10868c:	f7ff fde8 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (mode != PWR_CTRL_OUTPUT_MANUAL && mode != PWR_CTRL_OUTPUT_AUTO )
  108690:	bb20      	cbnz	r0, 1086dc <pmu_set_powerctrl_out_mode+0x5c>
	        || ctrl_id < 0 || ctrl_id > 3) {
  108692:	2903      	cmp	r1, #3
  108694:	bf98      	it	ls
  108696:	2a01      	cmpls	r2, #1
  108698:	d820      	bhi.n	1086dc <pmu_set_powerctrl_out_mode+0x5c>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  10869a:	2902      	cmp	r1, #2
  10869c:	d019      	beq.n	1086d2 <pmu_set_powerctrl_out_mode+0x52>
  10869e:	2903      	cmp	r1, #3
  1086a0:	d00d      	beq.n	1086be <pmu_set_powerctrl_out_mode+0x3e>
  1086a2:	2901      	cmp	r1, #1
  1086a4:	d010      	beq.n	1086c8 <pmu_set_powerctrl_out_mode+0x48>
  1086a6:	2114      	movs	r1, #20
  1086a8:	f46f 7500 	mvn.w	r5, #512	; 0x200
		case PWR_CTRL_0:
			reg_offset = PMU_CTRL_1;
			reg_start_bit = 9;
  1086ac:	2309      	movs	r3, #9
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 20;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, mode);
  1086ae:	6924      	ldr	r4, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  1086b0:	fa02 f303 	lsl.w	r3, r2, r3
  1086b4:	5862      	ldr	r2, [r4, r1]
  1086b6:	402a      	ands	r2, r5
  1086b8:	431a      	orrs	r2, r3
  1086ba:	5062      	str	r2, [r4, r1]
	return 0;
}
  1086bc:	bd38      	pop	{r3, r4, r5, r15}
			break;
  1086be:	2118      	movs	r1, #24
  1086c0:	f46f 1580 	mvn.w	r5, #1048576	; 0x100000
			reg_start_bit = 20;
  1086c4:	2314      	movs	r3, #20
			break;
  1086c6:	e7f2      	b.n	1086ae <pmu_set_powerctrl_out_mode+0x2e>
	switch (ctrl_id) {
  1086c8:	2114      	movs	r1, #20
  1086ca:	f46f 1580 	mvn.w	r5, #1048576	; 0x100000
			reg_start_bit = 20;
  1086ce:	460b      	mov	r3, r1
  1086d0:	e7ed      	b.n	1086ae <pmu_set_powerctrl_out_mode+0x2e>
			break;
  1086d2:	2118      	movs	r1, #24
  1086d4:	f46f 7500 	mvn.w	r5, #512	; 0x200
			reg_start_bit = 9;
  1086d8:	2309      	movs	r3, #9
			break;
  1086da:	e7e8      	b.n	1086ae <pmu_set_powerctrl_out_mode+0x2e>
		pmu_err("check failure\n");
  1086dc:	f648 61d4 	movw	r1, #36564	; 0x8ed4
  1086e0:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1086e4:	f44f 72a9 	mov.w	r2, #338	; 0x152
  1086e8:	f2c0 0111 	movt	r1, #17
  1086ec:	f2c0 0011 	movt	r0, #17
  1086f0:	f00c f888 	bl	114804 <printf>
		return -1;
  1086f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1086f8:	bd38      	pop	{r3, r4, r5, r15}
  1086fa:	bf00      	nop

001086fc <pmu_set_powerctrl_out_ctrl>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1086fc:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_powerctrl_out_ctrl(pmudev_t *dev, int ctrl_id, int out)
{
  1086fe:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108700:	b343      	cbz	r3, 108754 <pmu_set_powerctrl_out_ctrl+0x58>
  108702:	68c3      	ldr	r3, [r0, #12]
  108704:	4604      	mov	r4, r0
  108706:	b32b      	cbz	r3, 108754 <pmu_set_powerctrl_out_ctrl+0x58>
  108708:	f7ff fdaa 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (out != PWR_CTRL_OUTPUT_LOW && out != PWR_CTRL_OUTPUT_HIGH)
  10870c:	bb10      	cbnz	r0, 108754 <pmu_set_powerctrl_out_ctrl+0x58>
	        || ctrl_id < 0 || ctrl_id > 3) {
  10870e:	2903      	cmp	r1, #3
  108710:	bf98      	it	ls
  108712:	2a01      	cmpls	r2, #1
  108714:	d81e      	bhi.n	108754 <pmu_set_powerctrl_out_ctrl+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  108716:	2902      	cmp	r1, #2
  108718:	d017      	beq.n	10874a <pmu_set_powerctrl_out_ctrl+0x4e>
  10871a:	2903      	cmp	r1, #3
  10871c:	d010      	beq.n	108740 <pmu_set_powerctrl_out_ctrl+0x44>
  10871e:	2514      	movs	r5, #20
  108720:	2901      	cmp	r1, #1
  108722:	bf07      	ittee	eq
  108724:	f46f 1600 	mvneq.w	r6, #2097152	; 0x200000
  108728:	2315      	moveq	r3, #21
  10872a:	f46f 6680 	mvnne.w	r6, #1024	; 0x400
  10872e:	230a      	movne	r3, #10
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 21;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, out);
  108730:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108732:	fa02 f303 	lsl.w	r3, r2, r3
  108736:	594a      	ldr	r2, [r1, r5]
  108738:	4032      	ands	r2, r6
  10873a:	431a      	orrs	r2, r3
  10873c:	514a      	str	r2, [r1, r5]
	return 0;
}
  10873e:	bd70      	pop	{r4, r5, r6, r15}
			break;
  108740:	2518      	movs	r5, #24
  108742:	f46f 1600 	mvn.w	r6, #2097152	; 0x200000
			reg_start_bit = 21;
  108746:	2315      	movs	r3, #21
			break;
  108748:	e7f2      	b.n	108730 <pmu_set_powerctrl_out_ctrl+0x34>
			break;
  10874a:	2518      	movs	r5, #24
  10874c:	f46f 6680 	mvn.w	r6, #1024	; 0x400
			reg_start_bit = 10;
  108750:	230a      	movs	r3, #10
			break;
  108752:	e7ed      	b.n	108730 <pmu_set_powerctrl_out_ctrl+0x34>
		pmu_err("check failure\n");
  108754:	f648 61f0 	movw	r1, #36592	; 0x8ef0
  108758:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10875c:	f240 1273 	movw	r2, #371	; 0x173
  108760:	f2c0 0111 	movt	r1, #17
  108764:	f2c0 0011 	movt	r0, #17
  108768:	f00c f84c 	bl	114804 <printf>
		return -1;
  10876c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108770:	bd70      	pop	{r4, r5, r6, r15}
  108772:	bf00      	nop

00108774 <pmu_get_powerctrl_input_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108774:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_powerctrl_input_status(pmudev_t *dev, int ctrl_id, int *status)
{
  108776:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108778:	b363      	cbz	r3, 1087d4 <pmu_get_powerctrl_input_status+0x60>
  10877a:	68c3      	ldr	r3, [r0, #12]
  10877c:	4604      	mov	r4, r0
  10877e:	b34b      	cbz	r3, 1087d4 <pmu_get_powerctrl_input_status+0x60>
  108780:	f7ff fd6e 	bl	108260 <pmu_check.part.0>
	int reg_offset, reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || ctrl_id < 0 || ctrl_id > 3) {
  108784:	bb30      	cbnz	r0, 1087d4 <pmu_get_powerctrl_input_status+0x60>
  108786:	2903      	cmp	r1, #3
  108788:	bf94      	ite	ls
  10878a:	2300      	movls	r3, #0
  10878c:	2301      	movhi	r3, #1
  10878e:	2a00      	cmp	r2, #0
  108790:	bf08      	it	eq
  108792:	2301      	moveq	r3, #1
  108794:	b9f3      	cbnz	r3, 1087d4 <pmu_get_powerctrl_input_status+0x60>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  108796:	2902      	cmp	r1, #2
  108798:	d017      	beq.n	1087ca <pmu_get_powerctrl_input_status+0x56>
  10879a:	2903      	cmp	r1, #3
  10879c:	d010      	beq.n	1087c0 <pmu_get_powerctrl_input_status+0x4c>
  10879e:	2314      	movs	r3, #20
  1087a0:	2901      	cmp	r1, #1
  1087a2:	bf0b      	itete	eq
  1087a4:	f04f 4600 	moveq.w	r6, #2147483648	; 0x80000000
  1087a8:	f04f 4680 	movne.w	r6, #1073741824	; 0x40000000
  1087ac:	251f      	moveq	r5, #31
  1087ae:	251e      	movne	r5, #30
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 31;
			break;
	}

	v = readl(dev->base_vaddr + reg_offset);
  1087b0:	6921      	ldr	r1, [r4, #16]
  1087b2:	58cb      	ldr	r3, [r1, r3]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  1087b4:	4033      	ands	r3, r6
  1087b6:	40eb      	lsrs	r3, r5
  1087b8:	f003 0301 	and.w	r3, r3, #1
  1087bc:	6013      	str	r3, [r2, #0]
	return 0;
}
  1087be:	bd70      	pop	{r4, r5, r6, r15}
			break;
  1087c0:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
  1087c4:	2318      	movs	r3, #24
			reg_start_bit = 31;
  1087c6:	251f      	movs	r5, #31
			break;
  1087c8:	e7f2      	b.n	1087b0 <pmu_get_powerctrl_input_status+0x3c>
			break;
  1087ca:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  1087ce:	2318      	movs	r3, #24
			reg_start_bit = 30;
  1087d0:	251e      	movs	r5, #30
			break;
  1087d2:	e7ed      	b.n	1087b0 <pmu_get_powerctrl_input_status+0x3c>
		pmu_err("check failure\n");
  1087d4:	f648 710c 	movw	r1, #36620	; 0x8f0c
  1087d8:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1087dc:	f44f 72ca 	mov.w	r2, #404	; 0x194
  1087e0:	f2c0 0111 	movt	r1, #17
  1087e4:	f2c0 0011 	movt	r0, #17
  1087e8:	f00c f80c 	bl	114804 <printf>
		return -1;
  1087ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1087f0:	bd70      	pop	{r4, r5, r6, r15}
  1087f2:	bf00      	nop

001087f4 <pmu_set_internal_powerdown_enable>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1087f4:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_internal_powerdown_enable(pmudev_t *dev, int id, int enable)
{
  1087f6:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1087f8:	b1b3      	cbz	r3, 108828 <pmu_set_internal_powerdown_enable+0x34>
  1087fa:	68c3      	ldr	r3, [r0, #12]
  1087fc:	4604      	mov	r4, r0
  1087fe:	b19b      	cbz	r3, 108828 <pmu_set_internal_powerdown_enable+0x34>
  108800:	f7ff fd2e 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108804:	b980      	cbnz	r0, 108828 <pmu_set_internal_powerdown_enable+0x34>
	        || id < 0 || id > 1) {
  108806:	2901      	cmp	r1, #1
  108808:	bf98      	it	ls
  10880a:	2a01      	cmpls	r2, #1
  10880c:	d80c      	bhi.n	108828 <pmu_set_internal_powerdown_enable+0x34>
  10880e:	f06f 0301 	mvn.w	r3, #1
		pmu_err("check failure\n");
		return -1;
	}

	if (id == 0)
  108812:	b929      	cbnz	r1, 108820 <pmu_set_internal_powerdown_enable+0x2c>
		reg_start_bit = 0;
	else
		reg_start_bit = 2;

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_3, reg_start_bit, 1, enable);
  108814:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108816:	69cc      	ldr	r4, [r1, #28]
  108818:	4023      	ands	r3, r4
  10881a:	431a      	orrs	r2, r3
  10881c:	61ca      	str	r2, [r1, #28]
	return 0;
}
  10881e:	bd10      	pop	{r4, r15}
  108820:	0092      	lsls	r2, r2, #2
	if (id == 0)
  108822:	f06f 0304 	mvn.w	r3, #4
  108826:	e7f5      	b.n	108814 <pmu_set_internal_powerdown_enable+0x20>
		pmu_err("check failure\n");
  108828:	f648 712c 	movw	r1, #36652	; 0x8f2c
  10882c:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108830:	f44f 72db 	mov.w	r2, #438	; 0x1b6
  108834:	f2c0 0111 	movt	r1, #17
  108838:	f2c0 0011 	movt	r0, #17
  10883c:	f00b ffe2 	bl	114804 <printf>
		return -1;
  108840:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108844:	bd10      	pop	{r4, r15}
  108846:	bf00      	nop

00108848 <pmu_set_internal_powerdown_polarity>:

int32_t pmu_set_internal_powerdown_polarity(pmudev_t *dev, int id, int polarity)
{
  108848:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10884a:	6803      	ldr	r3, [r0, #0]
  10884c:	b1cb      	cbz	r3, 108882 <pmu_set_internal_powerdown_polarity+0x3a>
  10884e:	68c3      	ldr	r3, [r0, #12]
  108850:	4604      	mov	r4, r0
  108852:	b1b3      	cbz	r3, 108882 <pmu_set_internal_powerdown_polarity+0x3a>
  108854:	f7ff fd04 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  108858:	b998      	cbnz	r0, 108882 <pmu_set_internal_powerdown_polarity+0x3a>
	        || id < 0 || id > 1) {
  10885a:	2901      	cmp	r1, #1
  10885c:	bf98      	it	ls
  10885e:	2a01      	cmpls	r2, #1
  108860:	d80f      	bhi.n	108882 <pmu_set_internal_powerdown_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 1;
	else
		reg_start_bit = 3;

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_3, reg_start_bit, 1, polarity);
  108862:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108864:	2900      	cmp	r1, #0
  108866:	bf1a      	itte	ne
  108868:	f06f 0308 	mvnne.w	r3, #8
  10886c:	2103      	movne	r1, #3
  10886e:	f06f 0302 	mvneq.w	r3, #2
	RMWREG32(addr, startbit, width, val);
  108872:	69e5      	ldr	r5, [r4, #28]
	if (id == 0)
  108874:	bf08      	it	eq
  108876:	2101      	moveq	r1, #1
	RMWREG32(addr, startbit, width, val);
  108878:	408a      	lsls	r2, r1
  10887a:	402b      	ands	r3, r5
  10887c:	431a      	orrs	r2, r3
  10887e:	61e2      	str	r2, [r4, #28]
	return 0;
}
  108880:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108882:	f648 7150 	movw	r1, #36688	; 0x8f50
  108886:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10888a:	f240 12c9 	movw	r2, #457	; 0x1c9
  10888e:	f2c0 0111 	movt	r1, #17
  108892:	f2c0 0011 	movt	r0, #17
  108896:	f00b ffb5 	bl	114804 <printf>
		return -1;
  10889a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10889e:	bd38      	pop	{r3, r4, r5, r15}

001088a0 <pmu_get_internal_powerdown_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1088a0:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_internal_powerdown_status(pmudev_t *dev, int id, int *status)
{
  1088a2:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1088a4:	b1eb      	cbz	r3, 1088e2 <pmu_get_internal_powerdown_status+0x42>
  1088a6:	68c3      	ldr	r3, [r0, #12]
  1088a8:	4604      	mov	r4, r0
  1088aa:	b1d3      	cbz	r3, 1088e2 <pmu_get_internal_powerdown_status+0x42>
  1088ac:	f7ff fcd8 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  1088b0:	b9b8      	cbnz	r0, 1088e2 <pmu_get_internal_powerdown_status+0x42>
  1088b2:	2901      	cmp	r1, #1
  1088b4:	bf94      	ite	ls
  1088b6:	2300      	movls	r3, #0
  1088b8:	2301      	movhi	r3, #1
  1088ba:	2a00      	cmp	r2, #0
  1088bc:	bf08      	it	eq
  1088be:	2301      	moveq	r3, #1
  1088c0:	b97b      	cbnz	r3, 1088e2 <pmu_get_internal_powerdown_status+0x42>
	if (id == 0)
		reg_start_bit = 8;
	else
		reg_start_bit = 9;

	v = readl(dev->base_vaddr + PMU_CTRL_3);
  1088c2:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  1088c4:	2900      	cmp	r1, #0
  1088c6:	bf15      	itete	ne
  1088c8:	f44f 7300 	movne.w	r3, #512	; 0x200
  1088cc:	f44f 7380 	moveq.w	r3, #256	; 0x100
  1088d0:	2109      	movne	r1, #9
  1088d2:	2108      	moveq	r1, #8
	v = readl(dev->base_vaddr + PMU_CTRL_3);
  1088d4:	69e4      	ldr	r4, [r4, #28]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  1088d6:	4023      	ands	r3, r4
  1088d8:	40cb      	lsrs	r3, r1
  1088da:	f003 0301 	and.w	r3, r3, #1
  1088de:	6013      	str	r3, [r2, #0]
	return 0;
}
  1088e0:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  1088e2:	f648 7174 	movw	r1, #36724	; 0x8f74
  1088e6:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1088ea:	f44f 72ee 	mov.w	r2, #476	; 0x1dc
  1088ee:	f2c0 0111 	movt	r1, #17
  1088f2:	f2c0 0011 	movt	r0, #17
  1088f6:	f00b ff85 	bl	114804 <printf>
		return -1;
  1088fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1088fe:	bd10      	pop	{r4, r15}

00108900 <pmu_set_external_reset_enable>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108900:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_external_reset_enable(pmudev_t *dev, int id, int enable)
{
  108902:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108904:	b1b3      	cbz	r3, 108934 <pmu_set_external_reset_enable+0x34>
  108906:	68c3      	ldr	r3, [r0, #12]
  108908:	4604      	mov	r4, r0
  10890a:	b19b      	cbz	r3, 108934 <pmu_set_external_reset_enable+0x34>
  10890c:	f7ff fca8 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108910:	b980      	cbnz	r0, 108934 <pmu_set_external_reset_enable+0x34>
	        || id < 0 || id > 1) {
  108912:	2901      	cmp	r1, #1
  108914:	bf98      	it	ls
  108916:	2a01      	cmpls	r2, #1
  108918:	d80c      	bhi.n	108934 <pmu_set_external_reset_enable+0x34>
  10891a:	f06f 0301 	mvn.w	r3, #1
		pmu_err("check failure\n");
		return -1;
	}

	if (id == 0)
  10891e:	b929      	cbnz	r1, 10892c <pmu_set_external_reset_enable+0x2c>
		reg_start_bit = 0;
	else
		reg_start_bit = 7;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  108920:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108922:	680c      	ldr	r4, [r1, #0]
  108924:	4023      	ands	r3, r4
  108926:	431a      	orrs	r2, r3
  108928:	600a      	str	r2, [r1, #0]
	return 0;
}
  10892a:	bd10      	pop	{r4, r15}
  10892c:	01d2      	lsls	r2, r2, #7
	if (id == 0)
  10892e:	f06f 0380 	mvn.w	r3, #128	; 0x80
  108932:	e7f5      	b.n	108920 <pmu_set_external_reset_enable+0x20>
		pmu_err("check failure\n");
  108934:	f648 7198 	movw	r1, #36760	; 0x8f98
  108938:	f249 10dc 	movw	r0, #37340	; 0x91dc
  10893c:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
  108940:	f2c0 0111 	movt	r1, #17
  108944:	f2c0 0011 	movt	r0, #17
  108948:	f00b ff5c 	bl	114804 <printf>
		return -1;
  10894c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108950:	bd10      	pop	{r4, r15}
  108952:	bf00      	nop

00108954 <pmu_set_external_reset_polarity>:

int32_t pmu_set_external_reset_polarity(pmudev_t *dev, int id, int polarity)
{
  108954:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108956:	6803      	ldr	r3, [r0, #0]
  108958:	b1cb      	cbz	r3, 10898e <pmu_set_external_reset_polarity+0x3a>
  10895a:	68c3      	ldr	r3, [r0, #12]
  10895c:	4604      	mov	r4, r0
  10895e:	b1b3      	cbz	r3, 10898e <pmu_set_external_reset_polarity+0x3a>
  108960:	f7ff fc7e 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  108964:	b998      	cbnz	r0, 10898e <pmu_set_external_reset_polarity+0x3a>
	        || id < 0 || id > 1) {
  108966:	2901      	cmp	r1, #1
  108968:	bf98      	it	ls
  10896a:	2a01      	cmpls	r2, #1
  10896c:	d80f      	bhi.n	10898e <pmu_set_external_reset_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 1;
	else
		reg_start_bit = 8;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, polarity);
  10896e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108970:	2900      	cmp	r1, #0
  108972:	bf1a      	itte	ne
  108974:	f46f 7380 	mvnne.w	r3, #256	; 0x100
  108978:	2108      	movne	r1, #8
  10897a:	f06f 0302 	mvneq.w	r3, #2
	RMWREG32(addr, startbit, width, val);
  10897e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108980:	bf08      	it	eq
  108982:	2101      	moveq	r1, #1
	RMWREG32(addr, startbit, width, val);
  108984:	408a      	lsls	r2, r1
  108986:	402b      	ands	r3, r5
  108988:	431a      	orrs	r2, r3
  10898a:	6022      	str	r2, [r4, #0]
	return 0;
}
  10898c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  10898e:	f648 71b8 	movw	r1, #36792	; 0x8fb8
  108992:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108996:	f240 2203 	movw	r2, #515	; 0x203
  10899a:	f2c0 0111 	movt	r1, #17
  10899e:	f2c0 0011 	movt	r0, #17
  1089a2:	f00b ff2f 	bl	114804 <printf>
		return -1;
  1089a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1089aa:	bd38      	pop	{r3, r4, r5, r15}

001089ac <pmu_set_external_reset_debounce_enable>:

int32_t pmu_set_external_reset_debounce_enable(pmudev_t *dev, int id, int enable)
{
  1089ac:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1089ae:	6803      	ldr	r3, [r0, #0]
  1089b0:	b1cb      	cbz	r3, 1089e6 <pmu_set_external_reset_debounce_enable+0x3a>
  1089b2:	68c3      	ldr	r3, [r0, #12]
  1089b4:	4604      	mov	r4, r0
  1089b6:	b1b3      	cbz	r3, 1089e6 <pmu_set_external_reset_debounce_enable+0x3a>
  1089b8:	f7ff fc52 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  1089bc:	b998      	cbnz	r0, 1089e6 <pmu_set_external_reset_debounce_enable+0x3a>
	        || id < 0 || id > 1) {
  1089be:	2901      	cmp	r1, #1
  1089c0:	bf98      	it	ls
  1089c2:	2a01      	cmpls	r2, #1
  1089c4:	d80f      	bhi.n	1089e6 <pmu_set_external_reset_debounce_enable+0x3a>
	if (id == 0)
		reg_start_bit = 2;
	else
		reg_start_bit = 9;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  1089c6:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  1089c8:	2900      	cmp	r1, #0
  1089ca:	bf1a      	itte	ne
  1089cc:	f46f 7300 	mvnne.w	r3, #512	; 0x200
  1089d0:	2109      	movne	r1, #9
  1089d2:	f06f 0304 	mvneq.w	r3, #4
	RMWREG32(addr, startbit, width, val);
  1089d6:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  1089d8:	bf08      	it	eq
  1089da:	2102      	moveq	r1, #2
	RMWREG32(addr, startbit, width, val);
  1089dc:	408a      	lsls	r2, r1
  1089de:	402b      	ands	r3, r5
  1089e0:	431a      	orrs	r2, r3
  1089e2:	6022      	str	r2, [r4, #0]
	return 0;
}
  1089e4:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  1089e6:	f648 71d8 	movw	r1, #36824	; 0x8fd8
  1089ea:	f249 10dc 	movw	r0, #37340	; 0x91dc
  1089ee:	f240 2216 	movw	r2, #534	; 0x216
  1089f2:	f2c0 0111 	movt	r1, #17
  1089f6:	f2c0 0011 	movt	r0, #17
  1089fa:	f00b ff03 	bl	114804 <printf>
		return -1;
  1089fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108a02:	bd38      	pop	{r3, r4, r5, r15}

00108a04 <pmu_set_external_reset_debounce_delay>:

int32_t pmu_set_external_reset_debounce_delay(pmudev_t *dev, int id, int delay)
{
  108a04:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108a06:	6803      	ldr	r3, [r0, #0]
  108a08:	b1cb      	cbz	r3, 108a3e <pmu_set_external_reset_debounce_delay+0x3a>
  108a0a:	68c3      	ldr	r3, [r0, #12]
  108a0c:	4604      	mov	r4, r0
  108a0e:	b1b3      	cbz	r3, 108a3e <pmu_set_external_reset_debounce_delay+0x3a>
  108a10:	f7ff fc26 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || delay < 0 || delay > 0xf || id < 0 || id > 1) {
  108a14:	b998      	cbnz	r0, 108a3e <pmu_set_external_reset_debounce_delay+0x3a>
  108a16:	2901      	cmp	r1, #1
  108a18:	bf98      	it	ls
  108a1a:	2a0f      	cmpls	r2, #15
  108a1c:	d80f      	bhi.n	108a3e <pmu_set_external_reset_debounce_delay+0x3a>
	if (id == 0)
		reg_start_bit = 3;
	else
		reg_start_bit = 10;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 4, delay);
  108a1e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108a20:	2900      	cmp	r1, #0
  108a22:	bf1a      	itte	ne
  108a24:	f46f 5370 	mvnne.w	r3, #15360	; 0x3c00
  108a28:	210a      	movne	r1, #10
  108a2a:	f06f 0378 	mvneq.w	r3, #120	; 0x78
	RMWREG32(addr, startbit, width, val);
  108a2e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108a30:	bf08      	it	eq
  108a32:	2103      	moveq	r1, #3
	RMWREG32(addr, startbit, width, val);
  108a34:	408a      	lsls	r2, r1
  108a36:	402b      	ands	r3, r5
  108a38:	431a      	orrs	r2, r3
  108a3a:	6022      	str	r2, [r4, #0]
	return 0;
}
  108a3c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108a3e:	f249 0100 	movw	r1, #36864	; 0x9000
  108a42:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108a46:	f44f 720a 	mov.w	r2, #552	; 0x228
  108a4a:	f2c0 0111 	movt	r1, #17
  108a4e:	f2c0 0011 	movt	r0, #17
  108a52:	f00b fed7 	bl	114804 <printf>
		return -1;
  108a56:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108a5a:	bd38      	pop	{r3, r4, r5, r15}

00108a5c <pmu_get_external_reset_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108a5c:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_external_reset_status(pmudev_t *dev, int id, int *status)
{
  108a5e:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108a60:	b1eb      	cbz	r3, 108a9e <pmu_get_external_reset_status+0x42>
  108a62:	68c3      	ldr	r3, [r0, #12]
  108a64:	4604      	mov	r4, r0
  108a66:	b1d3      	cbz	r3, 108a9e <pmu_get_external_reset_status+0x42>
  108a68:	f7ff fbfa 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  108a6c:	b9b8      	cbnz	r0, 108a9e <pmu_get_external_reset_status+0x42>
  108a6e:	2901      	cmp	r1, #1
  108a70:	bf94      	ite	ls
  108a72:	2300      	movls	r3, #0
  108a74:	2301      	movhi	r3, #1
  108a76:	2a00      	cmp	r2, #0
  108a78:	bf08      	it	eq
  108a7a:	2301      	moveq	r3, #1
  108a7c:	b97b      	cbnz	r3, 108a9e <pmu_get_external_reset_status+0x42>
	if (id == 0)
		reg_start_bit = 28;
	else
		reg_start_bit = 29;

	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  108a7e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108a80:	2900      	cmp	r1, #0
  108a82:	bf15      	itete	ne
  108a84:	f04f 5300 	movne.w	r3, #536870912	; 0x20000000
  108a88:	f04f 5380 	moveq.w	r3, #268435456	; 0x10000000
  108a8c:	211d      	movne	r1, #29
  108a8e:	211c      	moveq	r1, #28
	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  108a90:	6824      	ldr	r4, [r4, #0]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  108a92:	4023      	ands	r3, r4
  108a94:	40cb      	lsrs	r3, r1
  108a96:	f003 0301 	and.w	r3, r3, #1
  108a9a:	6013      	str	r3, [r2, #0]
	return 0;
}
  108a9c:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  108a9e:	f249 0128 	movw	r1, #36904	; 0x9028
  108aa2:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108aa6:	f240 223b 	movw	r2, #571	; 0x23b
  108aaa:	f2c0 0111 	movt	r1, #17
  108aae:	f2c0 0011 	movt	r0, #17
  108ab2:	f00b fea7 	bl	114804 <printf>
		return -1;
  108ab6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108aba:	bd10      	pop	{r4, r15}

00108abc <pmu_set_internal_wakeup_enable>:

int32_t pmu_set_internal_wakeup_enable(pmudev_t *dev, int id, int enable)
{
  108abc:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108abe:	6803      	ldr	r3, [r0, #0]
  108ac0:	b1ab      	cbz	r3, 108aee <pmu_set_internal_wakeup_enable+0x32>
  108ac2:	68c3      	ldr	r3, [r0, #12]
  108ac4:	4604      	mov	r4, r0
  108ac6:	b193      	cbz	r3, 108aee <pmu_set_internal_wakeup_enable+0x32>
  108ac8:	f7ff fbca 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108acc:	b978      	cbnz	r0, 108aee <pmu_set_internal_wakeup_enable+0x32>
	        || id < 0 || id > 1) {
  108ace:	2901      	cmp	r1, #1
  108ad0:	bf98      	it	ls
  108ad2:	2a01      	cmpls	r2, #1
  108ad4:	d80b      	bhi.n	108aee <pmu_set_internal_wakeup_enable+0x32>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RTC_CTRL, id, 1, enable);
  108ad6:	6925      	ldr	r5, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108ad8:	2401      	movs	r4, #1
  108ada:	fa02 f301 	lsl.w	r3, r2, r1
  108ade:	fa04 f101 	lsl.w	r1, r4, r1
  108ae2:	686a      	ldr	r2, [r5, #4]
  108ae4:	ea22 0201 	bic.w	r2, r2, r1
  108ae8:	431a      	orrs	r2, r3
  108aea:	606a      	str	r2, [r5, #4]
	return 0;
}
  108aec:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108aee:	f249 0148 	movw	r1, #36936	; 0x9048
  108af2:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108af6:	f240 224d 	movw	r2, #589	; 0x24d
  108afa:	f2c0 0111 	movt	r1, #17
  108afe:	f2c0 0011 	movt	r0, #17
  108b02:	f00b fe7f 	bl	114804 <printf>
		return -1;
  108b06:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108b0a:	bd38      	pop	{r3, r4, r5, r15}

00108b0c <pmu_set_external_wakeup_enable>:

int32_t pmu_set_external_wakeup_enable(pmudev_t *dev, int id, int enable)
{
  108b0c:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108b0e:	6803      	ldr	r3, [r0, #0]
  108b10:	b1cb      	cbz	r3, 108b46 <pmu_set_external_wakeup_enable+0x3a>
  108b12:	68c3      	ldr	r3, [r0, #12]
  108b14:	4604      	mov	r4, r0
  108b16:	b1b3      	cbz	r3, 108b46 <pmu_set_external_wakeup_enable+0x3a>
  108b18:	f7ff fba2 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108b1c:	b998      	cbnz	r0, 108b46 <pmu_set_external_wakeup_enable+0x3a>
	        || id < 0 || id > 1) {
  108b1e:	2901      	cmp	r1, #1
  108b20:	bf98      	it	ls
  108b22:	2a01      	cmpls	r2, #1
  108b24:	d80f      	bhi.n	108b46 <pmu_set_external_wakeup_enable+0x3a>
	if (id == 0)
		reg_start_bit = 14;
	else
		reg_start_bit = 21;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  108b26:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108b28:	2900      	cmp	r1, #0
  108b2a:	bf1a      	itte	ne
  108b2c:	f46f 1300 	mvnne.w	r3, #2097152	; 0x200000
  108b30:	2115      	movne	r1, #21
  108b32:	f46f 4380 	mvneq.w	r3, #16384	; 0x4000
	RMWREG32(addr, startbit, width, val);
  108b36:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108b38:	bf08      	it	eq
  108b3a:	210e      	moveq	r1, #14
	RMWREG32(addr, startbit, width, val);
  108b3c:	408a      	lsls	r2, r1
  108b3e:	402b      	ands	r3, r5
  108b40:	431a      	orrs	r2, r3
  108b42:	6022      	str	r2, [r4, #0]
	return 0;
}
  108b44:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108b46:	f249 0168 	movw	r1, #36968	; 0x9068
  108b4a:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108b4e:	f240 225b 	movw	r2, #603	; 0x25b
  108b52:	f2c0 0111 	movt	r1, #17
  108b56:	f2c0 0011 	movt	r0, #17
  108b5a:	f00b fe53 	bl	114804 <printf>
		return -1;
  108b5e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108b62:	bd38      	pop	{r3, r4, r5, r15}

00108b64 <pmu_set_external_wakeup_polarity>:

int32_t pmu_set_external_wakeup_polarity(pmudev_t *dev, int id, int polarity)
{
  108b64:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108b66:	6803      	ldr	r3, [r0, #0]
  108b68:	b1cb      	cbz	r3, 108b9e <pmu_set_external_wakeup_polarity+0x3a>
  108b6a:	68c3      	ldr	r3, [r0, #12]
  108b6c:	4604      	mov	r4, r0
  108b6e:	b1b3      	cbz	r3, 108b9e <pmu_set_external_wakeup_polarity+0x3a>
  108b70:	f7ff fb76 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  108b74:	b998      	cbnz	r0, 108b9e <pmu_set_external_wakeup_polarity+0x3a>
	        || id < 0 || id > 1) {
  108b76:	2901      	cmp	r1, #1
  108b78:	bf98      	it	ls
  108b7a:	2a01      	cmpls	r2, #1
  108b7c:	d80f      	bhi.n	108b9e <pmu_set_external_wakeup_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 15;
	else
		reg_start_bit = 22;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, polarity);
  108b7e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108b80:	2900      	cmp	r1, #0
  108b82:	bf1a      	itte	ne
  108b84:	f46f 0380 	mvnne.w	r3, #4194304	; 0x400000
  108b88:	2116      	movne	r1, #22
  108b8a:	f46f 4300 	mvneq.w	r3, #32768	; 0x8000
	RMWREG32(addr, startbit, width, val);
  108b8e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108b90:	bf08      	it	eq
  108b92:	210f      	moveq	r1, #15
	RMWREG32(addr, startbit, width, val);
  108b94:	408a      	lsls	r2, r1
  108b96:	402b      	ands	r3, r5
  108b98:	431a      	orrs	r2, r3
  108b9a:	6022      	str	r2, [r4, #0]
	return 0;
}
  108b9c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108b9e:	f249 0188 	movw	r1, #37000	; 0x9088
  108ba2:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108ba6:	f240 226e 	movw	r2, #622	; 0x26e
  108baa:	f2c0 0111 	movt	r1, #17
  108bae:	f2c0 0011 	movt	r0, #17
  108bb2:	f00b fe27 	bl	114804 <printf>
		return -1;
  108bb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108bba:	bd38      	pop	{r3, r4, r5, r15}

00108bbc <pmu_set_external_wakeup_debounce_enable>:

int32_t pmu_set_external_wakeup_debounce_enable(pmudev_t *dev, int id, int enable)
{
  108bbc:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108bbe:	6803      	ldr	r3, [r0, #0]
  108bc0:	b1cb      	cbz	r3, 108bf6 <pmu_set_external_wakeup_debounce_enable+0x3a>
  108bc2:	68c3      	ldr	r3, [r0, #12]
  108bc4:	4604      	mov	r4, r0
  108bc6:	b1b3      	cbz	r3, 108bf6 <pmu_set_external_wakeup_debounce_enable+0x3a>
  108bc8:	f7ff fb4a 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108bcc:	b998      	cbnz	r0, 108bf6 <pmu_set_external_wakeup_debounce_enable+0x3a>
	        || id < 0 || id > 1) {
  108bce:	2901      	cmp	r1, #1
  108bd0:	bf98      	it	ls
  108bd2:	2a01      	cmpls	r2, #1
  108bd4:	d80f      	bhi.n	108bf6 <pmu_set_external_wakeup_debounce_enable+0x3a>
	if (id == 0)
		reg_start_bit = 16;
	else
		reg_start_bit = 23;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  108bd6:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108bd8:	2900      	cmp	r1, #0
  108bda:	bf1a      	itte	ne
  108bdc:	f46f 0300 	mvnne.w	r3, #8388608	; 0x800000
  108be0:	2117      	movne	r1, #23
  108be2:	f46f 3380 	mvneq.w	r3, #65536	; 0x10000
	RMWREG32(addr, startbit, width, val);
  108be6:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108be8:	bf08      	it	eq
  108bea:	2110      	moveq	r1, #16
	RMWREG32(addr, startbit, width, val);
  108bec:	408a      	lsls	r2, r1
  108bee:	402b      	ands	r3, r5
  108bf0:	431a      	orrs	r2, r3
  108bf2:	6022      	str	r2, [r4, #0]
	return 0;
}
  108bf4:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108bf6:	f249 01ac 	movw	r1, #37036	; 0x90ac
  108bfa:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108bfe:	f240 2281 	movw	r2, #641	; 0x281
  108c02:	f2c0 0111 	movt	r1, #17
  108c06:	f2c0 0011 	movt	r0, #17
  108c0a:	f00b fdfb 	bl	114804 <printf>
		return -1;
  108c0e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108c12:	bd38      	pop	{r3, r4, r5, r15}

00108c14 <pmu_set_external_wakeup_debounce_delay>:

int32_t pmu_set_external_wakeup_debounce_delay(pmudev_t *dev, int id, int delay)
{
  108c14:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108c16:	6803      	ldr	r3, [r0, #0]
  108c18:	b1cb      	cbz	r3, 108c4e <pmu_set_external_wakeup_debounce_delay+0x3a>
  108c1a:	68c3      	ldr	r3, [r0, #12]
  108c1c:	4604      	mov	r4, r0
  108c1e:	b1b3      	cbz	r3, 108c4e <pmu_set_external_wakeup_debounce_delay+0x3a>
  108c20:	f7ff fb1e 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || delay < 0 || delay > 0xf || id < 0 || id > 1) {
  108c24:	b998      	cbnz	r0, 108c4e <pmu_set_external_wakeup_debounce_delay+0x3a>
  108c26:	2901      	cmp	r1, #1
  108c28:	bf98      	it	ls
  108c2a:	2a0f      	cmpls	r2, #15
  108c2c:	d80f      	bhi.n	108c4e <pmu_set_external_wakeup_debounce_delay+0x3a>
	if (id == 0)
		reg_start_bit = 17;
	else
		reg_start_bit = 24;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 4, delay);
  108c2e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108c30:	2900      	cmp	r1, #0
  108c32:	bf1a      	itte	ne
  108c34:	f06f 6370 	mvnne.w	r3, #251658240	; 0xf000000
  108c38:	2118      	movne	r1, #24
  108c3a:	f46f 13f0 	mvneq.w	r3, #1966080	; 0x1e0000
	RMWREG32(addr, startbit, width, val);
  108c3e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  108c40:	bf08      	it	eq
  108c42:	2111      	moveq	r1, #17
	RMWREG32(addr, startbit, width, val);
  108c44:	408a      	lsls	r2, r1
  108c46:	402b      	ands	r3, r5
  108c48:	431a      	orrs	r2, r3
  108c4a:	6022      	str	r2, [r4, #0]
	return 0;
}
  108c4c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108c4e:	f249 01d4 	movw	r1, #37076	; 0x90d4
  108c52:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108c56:	f240 2293 	movw	r2, #659	; 0x293
  108c5a:	f2c0 0111 	movt	r1, #17
  108c5e:	f2c0 0011 	movt	r0, #17
  108c62:	f00b fdcf 	bl	114804 <printf>
		return -1;
  108c66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108c6a:	bd38      	pop	{r3, r4, r5, r15}

00108c6c <pmu_get_external_wakeup_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  108c6c:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_external_wakeup_status(pmudev_t *dev, int id, int *status)
{
  108c6e:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108c70:	b1eb      	cbz	r3, 108cae <pmu_get_external_wakeup_status+0x42>
  108c72:	68c3      	ldr	r3, [r0, #12]
  108c74:	4604      	mov	r4, r0
  108c76:	b1d3      	cbz	r3, 108cae <pmu_get_external_wakeup_status+0x42>
  108c78:	f7ff faf2 	bl	108260 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  108c7c:	b9b8      	cbnz	r0, 108cae <pmu_get_external_wakeup_status+0x42>
  108c7e:	2901      	cmp	r1, #1
  108c80:	bf94      	ite	ls
  108c82:	2300      	movls	r3, #0
  108c84:	2301      	movhi	r3, #1
  108c86:	2a00      	cmp	r2, #0
  108c88:	bf08      	it	eq
  108c8a:	2301      	moveq	r3, #1
  108c8c:	b97b      	cbnz	r3, 108cae <pmu_get_external_wakeup_status+0x42>
	if (id == 0)
		reg_start_bit = 30;
	else
		reg_start_bit = 31;

	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  108c8e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  108c90:	2900      	cmp	r1, #0
  108c92:	bf15      	itete	ne
  108c94:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
  108c98:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
  108c9c:	211f      	movne	r1, #31
  108c9e:	211e      	moveq	r1, #30
	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  108ca0:	6824      	ldr	r4, [r4, #0]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  108ca2:	4023      	ands	r3, r4
  108ca4:	40cb      	lsrs	r3, r1
  108ca6:	f003 0301 	and.w	r3, r3, #1
  108caa:	6013      	str	r3, [r2, #0]
	return 0;
}
  108cac:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  108cae:	f249 01fc 	movw	r1, #37116	; 0x90fc
  108cb2:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108cb6:	f240 22a6 	movw	r2, #678	; 0x2a6
  108cba:	f2c0 0111 	movt	r1, #17
  108cbe:	f2c0 0011 	movt	r0, #17
  108cc2:	f00b fd9f 	bl	114804 <printf>
		return -1;
  108cc6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108cca:	bd10      	pop	{r4, r15}

00108ccc <pmu_set_glitch_filter_delay>:

int32_t pmu_set_glitch_filter_delay(pmudev_t *dev, int id, int delay)
{
  108ccc:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108cce:	6803      	ldr	r3, [r0, #0]
  108cd0:	b17b      	cbz	r3, 108cf2 <pmu_set_glitch_filter_delay+0x26>
  108cd2:	68c3      	ldr	r3, [r0, #12]
  108cd4:	4601      	mov	r1, r0
  108cd6:	b163      	cbz	r3, 108cf2 <pmu_set_glitch_filter_delay+0x26>
  108cd8:	f7ff fac2 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0 || delay > 0x7) {
  108cdc:	b948      	cbnz	r0, 108cf2 <pmu_set_glitch_filter_delay+0x26>
  108cde:	2a07      	cmp	r2, #7
  108ce0:	d807      	bhi.n	108cf2 <pmu_set_glitch_filter_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_GF_CTRL, 11, 3, delay);
  108ce2:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  108ce4:	688b      	ldr	r3, [r1, #8]
  108ce6:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  108cea:	ea43 22c2 	orr.w	r2, r3, r2, lsl #11
  108cee:	608a      	str	r2, [r1, #8]
	return 0;
}
  108cf0:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108cf2:	f249 111c 	movw	r1, #37148	; 0x911c
  108cf6:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108cfa:	f240 22b7 	movw	r2, #695	; 0x2b7
  108cfe:	f2c0 0111 	movt	r1, #17
  108d02:	f2c0 0011 	movt	r0, #17
  108d06:	f00b fd7d 	bl	114804 <printf>
		return -1;
  108d0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108d0e:	bd08      	pop	{r3, r15}

00108d10 <pmu_set_glitch_filter_enable>:

int32_t pmu_set_glitch_filter_enable(pmudev_t *dev, int id, int enable)
{
  108d10:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108d12:	6803      	ldr	r3, [r0, #0]
  108d14:	b1ab      	cbz	r3, 108d42 <pmu_set_glitch_filter_enable+0x32>
  108d16:	68c3      	ldr	r3, [r0, #12]
  108d18:	4604      	mov	r4, r0
  108d1a:	b193      	cbz	r3, 108d42 <pmu_set_glitch_filter_enable+0x32>
  108d1c:	f7ff faa0 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  108d20:	b978      	cbnz	r0, 108d42 <pmu_set_glitch_filter_enable+0x32>
	        || id < 0 || id > 10) {
  108d22:	290a      	cmp	r1, #10
  108d24:	bf98      	it	ls
  108d26:	2a01      	cmpls	r2, #1
  108d28:	d80b      	bhi.n	108d42 <pmu_set_glitch_filter_enable+0x32>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_GF_CTRL, id, 1, enable);
  108d2a:	6925      	ldr	r5, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  108d2c:	2401      	movs	r4, #1
  108d2e:	fa02 f301 	lsl.w	r3, r2, r1
  108d32:	fa04 f101 	lsl.w	r1, r4, r1
  108d36:	68aa      	ldr	r2, [r5, #8]
  108d38:	ea22 0201 	bic.w	r2, r2, r1
  108d3c:	431a      	orrs	r2, r3
  108d3e:	60aa      	str	r2, [r5, #8]
	return 0;
}
  108d40:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  108d42:	f249 1138 	movw	r1, #37176	; 0x9138
  108d46:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108d4a:	f240 22c3 	movw	r2, #707	; 0x2c3
  108d4e:	f2c0 0111 	movt	r1, #17
  108d52:	f2c0 0011 	movt	r0, #17
  108d56:	f00b fd55 	bl	114804 <printf>
		return -1;
  108d5a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108d5e:	bd38      	pop	{r3, r4, r5, r15}

00108d60 <pmu_set_por_powerdown_delay>:

int32_t pmu_set_por_powerdown_delay(pmudev_t *dev, int id, int delay)
{
  108d60:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108d62:	6803      	ldr	r3, [r0, #0]
  108d64:	b17b      	cbz	r3, 108d86 <pmu_set_por_powerdown_delay+0x26>
  108d66:	68c3      	ldr	r3, [r0, #12]
  108d68:	4601      	mov	r1, r0
  108d6a:	b163      	cbz	r3, 108d86 <pmu_set_por_powerdown_delay+0x26>
  108d6c:	f7ff fa78 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0 || delay > 0x7) {
  108d70:	b948      	cbnz	r0, 108d86 <pmu_set_por_powerdown_delay+0x26>
  108d72:	2a07      	cmp	r2, #7
  108d74:	d807      	bhi.n	108d86 <pmu_set_por_powerdown_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 11, 3, delay);
  108d76:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  108d78:	68cb      	ldr	r3, [r1, #12]
  108d7a:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  108d7e:	ea43 22c2 	orr.w	r2, r3, r2, lsl #11
  108d82:	60ca      	str	r2, [r1, #12]
	return 0;
}
  108d84:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108d86:	f249 1158 	movw	r1, #37208	; 0x9158
  108d8a:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108d8e:	f240 22ce 	movw	r2, #718	; 0x2ce
  108d92:	f2c0 0111 	movt	r1, #17
  108d96:	f2c0 0011 	movt	r0, #17
  108d9a:	f00b fd33 	bl	114804 <printf>
		return -1;
  108d9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108da2:	bd08      	pop	{r3, r15}

00108da4 <pmu_set_por_auto_powerdown>:

int32_t pmu_set_por_auto_powerdown(pmudev_t *dev, int enable)
{
  108da4:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108da6:	6803      	ldr	r3, [r0, #0]
  108da8:	b17b      	cbz	r3, 108dca <pmu_set_por_auto_powerdown+0x26>
  108daa:	68c3      	ldr	r3, [r0, #12]
  108dac:	4602      	mov	r2, r0
  108dae:	b163      	cbz	r3, 108dca <pmu_set_por_auto_powerdown+0x26>
  108db0:	f7ff fa56 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)) {
  108db4:	b948      	cbnz	r0, 108dca <pmu_set_por_auto_powerdown+0x26>
  108db6:	2901      	cmp	r1, #1
  108db8:	d807      	bhi.n	108dca <pmu_set_por_auto_powerdown+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 10, 1, enable);
  108dba:	6912      	ldr	r2, [r2, #16]
	RMWREG32(addr, startbit, width, val);
  108dbc:	68d3      	ldr	r3, [r2, #12]
  108dbe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  108dc2:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
  108dc6:	60d1      	str	r1, [r2, #12]
	return 0;
}
  108dc8:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108dca:	f249 1174 	movw	r1, #37236	; 0x9174
  108dce:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108dd2:	f240 22d9 	movw	r2, #729	; 0x2d9
  108dd6:	f2c0 0111 	movt	r1, #17
  108dda:	f2c0 0011 	movt	r0, #17
  108dde:	f00b fd11 	bl	114804 <printf>
		return -1;
  108de2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108de6:	bd08      	pop	{r3, r15}

00108de8 <pmu_set_por_force_powerdown>:

int32_t pmu_set_por_force_powerdown(pmudev_t *dev, int enable)
{
  108de8:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  108dea:	6803      	ldr	r3, [r0, #0]
  108dec:	b17b      	cbz	r3, 108e0e <pmu_set_por_force_powerdown+0x26>
  108dee:	68c3      	ldr	r3, [r0, #12]
  108df0:	4602      	mov	r2, r0
  108df2:	b163      	cbz	r3, 108e0e <pmu_set_por_force_powerdown+0x26>
  108df4:	f7ff fa34 	bl	108260 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)) {
  108df8:	b948      	cbnz	r0, 108e0e <pmu_set_por_force_powerdown+0x26>
  108dfa:	2901      	cmp	r1, #1
  108dfc:	d807      	bhi.n	108e0e <pmu_set_por_force_powerdown+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 9, 1, enable);
  108dfe:	6912      	ldr	r2, [r2, #16]
	RMWREG32(addr, startbit, width, val);
  108e00:	68d3      	ldr	r3, [r2, #12]
  108e02:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  108e06:	ea43 2141 	orr.w	r1, r3, r1, lsl #9
  108e0a:	60d1      	str	r1, [r2, #12]
	return 0;
}
  108e0c:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  108e0e:	f249 1190 	movw	r1, #37264	; 0x9190
  108e12:	f249 10dc 	movw	r0, #37340	; 0x91dc
  108e16:	f44f 7239 	mov.w	r2, #740	; 0x2e4
  108e1a:	f2c0 0111 	movt	r1, #17
  108e1e:	f2c0 0011 	movt	r0, #17
  108e22:	f00b fcef 	bl	114804 <printf>
		return -1;
  108e26:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  108e2a:	bd08      	pop	{r3, r15}

00108e2c <scr_write_signal.isra.4>:
        DBG("Can not get handle for %s\n", signal->name);
        return false;
    }
}

static bool scr_write_signal(const struct scr_signal *signal, uint32_t val)
  108e2c:	b570      	push	{r4, r5, r6, r14}
  108e2e:	4616      	mov	r6, r2
{
    scr_handle_t handle;

    handle = hal_scr_create_handle(signal->signal);
  108e30:	f007 fc5a 	bl	1106e8 <hal_scr_create_handle>
  108e34:	4604      	mov	r4, r0
  108e36:	460d      	mov	r5, r1

    if (handle) {
  108e38:	ea54 0305 	orrs.w	r3, r4, r5
        hal_scr_delete_handle(handle);
        return ret;
    }
    else {
        DBG("Can not get handle for %s\n", signal->name);
        return false;
  108e3c:	bf08      	it	eq
  108e3e:	2600      	moveq	r6, #0
    if (handle) {
  108e40:	d007      	beq.n	108e52 <scr_write_signal.isra.4+0x26>
        bool ret = hal_scr_set(handle, val);
  108e42:	4632      	mov	r2, r6
  108e44:	f007 fc82 	bl	11074c <hal_scr_set>
        hal_scr_delete_handle(handle);
  108e48:	4629      	mov	r1, r5
        bool ret = hal_scr_set(handle, val);
  108e4a:	4606      	mov	r6, r0
        hal_scr_delete_handle(handle);
  108e4c:	4620      	mov	r0, r4
  108e4e:	f007 fc4d 	bl	1106ec <hal_scr_delete_handle>
    }
}
  108e52:	4630      	mov	r0, r6
  108e54:	bd70      	pop	{r4, r5, r6, r15}
  108e56:	bf00      	nop

00108e58 <scr_read_signal.isra.5>:
static bool scr_read_signal(const struct scr_signal *signal, uint32_t *val)
  108e58:	b570      	push	{r4, r5, r6, r14}
  108e5a:	4616      	mov	r6, r2
    handle = hal_scr_create_handle(signal->signal);
  108e5c:	f007 fc44 	bl	1106e8 <hal_scr_create_handle>
  108e60:	4604      	mov	r4, r0
  108e62:	460d      	mov	r5, r1
    if (handle) {
  108e64:	ea54 0305 	orrs.w	r3, r4, r5
        return false;
  108e68:	bf08      	it	eq
  108e6a:	2000      	moveq	r0, #0
    if (handle) {
  108e6c:	d100      	bne.n	108e70 <scr_read_signal.isra.5+0x18>
}
  108e6e:	bd70      	pop	{r4, r5, r6, r15}
        *val = hal_scr_get(handle);
  108e70:	f007 fc54 	bl	11071c <hal_scr_get>
        hal_scr_delete_handle(handle);
  108e74:	4629      	mov	r1, r5
        *val = hal_scr_get(handle);
  108e76:	6030      	str	r0, [r6, #0]
        hal_scr_delete_handle(handle);
  108e78:	4620      	mov	r0, r4
  108e7a:	f007 fc37 	bl	1106ec <hal_scr_delete_handle>
        return true;
  108e7e:	2001      	movs	r0, #1
}
  108e80:	bd70      	pop	{r4, r5, r6, r15}
  108e82:	bf00      	nop

00108e84 <Port_SetGPIOSCR>:
    uint32_t pin_num_internal = 0;
    DBG("Port_SetGPIOSCR: gpio_id[%d], pin_num[%d]\n", gpio_id, pin_num);

    /* safety GPIO CTRL base address index NOT follow PinList */
    pin_num_internal =  (((pin_num) <= 47) ? ((pin_num) >= 24 ? ((
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  108e84:	292f      	cmp	r1, #47	; 0x2f
{
  108e86:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  108e8a:	4605      	mov	r5, r0
  108e8c:	b084      	sub	sp, #16
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  108e8e:	d84e      	bhi.n	108f2e <Port_SetGPIOSCR+0xaa>
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  108e90:	f249 3698 	movw	r6, #37784	; 0x9398
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  108e94:	2917      	cmp	r1, #23
  108e96:	bf8c      	ite	hi
  108e98:	f1a1 0418 	subhi.w	r4, r1, #24
  108e9c:	f101 0418 	addls.w	r4, r1, #24
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  108ea0:	f2c0 0611 	movt	r6, #17
    uint32_t sigReg_id_mux1 = pin_num / 16;
  108ea4:	0923      	lsrs	r3, r4, #4
  108ea6:	2701      	movs	r7, #1
    scr_read_signal(signal_mux1, &val1_mux1);
  108ea8:	aa02      	add	r2, sp, #8
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  108eaa:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  108eae:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
    scr_read_signal(signal_mux1, &val1_mux1);
  108eb2:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  108eb6:	f7ff ffcf 	bl	108e58 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
  108eba:	2d01      	cmp	r5, #1
  108ebc:	f004 020f 	and.w	r2, r4, #15
  108ec0:	fa07 f702 	lsl.w	r7, r7, r2
  108ec4:	d053      	beq.n	108f6e <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
  108ec6:	f249 38e0 	movw	r8, #37856	; 0x93e0
    uint32_t sigReg_id = pin_num / 8;
  108eca:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
  108ecc:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
  108ece:	f2c0 0811 	movt	r8, #17
  108ed2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  108ed6:	eb08 08c3 	add.w	r8, r8, r3, lsl #3
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  108eda:	3d02      	subs	r5, #2
        scr_read_signal(signal, &val1);
  108edc:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
  108ee0:	f7ff ffba 	bl	108e58 <scr_read_signal.isra.5>
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
  108ee4:	2003      	movs	r0, #3
  108ee6:	9b00      	ldr	r3, [sp, #0]
  108ee8:	f004 0107 	and.w	r1, r4, #7
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  108eec:	9a02      	ldr	r2, [sp, #8]
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
  108eee:	0049      	lsls	r1, r1, #1
  108ef0:	4088      	lsls	r0, r1
  108ef2:	ea23 0300 	bic.w	r3, r3, r0
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  108ef6:	408d      	lsls	r5, r1
  108ef8:	431d      	orrs	r5, r3
        scr_write_signal(signal, val1);
  108efa:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  108efe:	4317      	orrs	r7, r2
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  108f00:	9500      	str	r5, [sp, #0]
        scr_write_signal(signal, val1);
  108f02:	462a      	mov	r2, r5
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  108f04:	9702      	str	r7, [sp, #8]
        scr_write_signal(signal, val1);
  108f06:	f7ff ff91 	bl	108e2c <scr_write_signal.isra.4>
        scr_read_signal(signal, &val2);
  108f0a:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
  108f0e:	aa01      	add	r2, sp, #4
  108f10:	f7ff ffa2 	bl	108e58 <scr_read_signal.isra.5>
  108f14:	9a02      	ldr	r2, [sp, #8]
    scr_write_signal(signal_mux1, val1_mux1);
  108f16:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  108f1a:	f7ff ff87 	bl	108e2c <scr_write_signal.isra.4>
    scr_read_signal(signal_mux1, &val2_mux1);
  108f1e:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  108f22:	aa03      	add	r2, sp, #12
  108f24:	f7ff ff98 	bl	108e58 <scr_read_signal.isra.5>
        Port_SetSecureGPIOSCR(gpio_id, pin_num_internal);
    }
    else {
        Port_SetSafetyGPIOSCR(gpio_id, pin_num_internal);
    }
}
  108f28:	b004      	add	sp, #16
  108f2a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    uint32_t tmpPinNum = pin_num - 48;
  108f2e:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
  108f32:	f249 4170 	movw	r1, #38000	; 0x9470
    scr_read_signal(signal_mux2, &val1_mux2);
  108f36:	aa02      	add	r2, sp, #8
    sigReg_id_mux2 = tmpPinNum / 16;
  108f38:	0923      	lsrs	r3, r4, #4
  108f3a:	2701      	movs	r7, #1
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
  108f3c:	f2c0 0111 	movt	r1, #17
  108f40:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  108f44:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
    scr_read_signal(signal_mux2, &val1_mux2);
  108f48:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  108f4c:	f7ff ff84 	bl	108e58 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
  108f50:	2d01      	cmp	r5, #1
  108f52:	f004 020f 	and.w	r2, r4, #15
  108f56:	fa07 f702 	lsl.w	r7, r7, r2
  108f5a:	d008      	beq.n	108f6e <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
  108f5c:	f249 5818 	movw	r8, #38168	; 0x9518
    sigReg_id = tmpPinNum / 8;
  108f60:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
  108f62:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
  108f64:	f2c0 0811 	movt	r8, #17
  108f68:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  108f6c:	e7b3      	b.n	108ed6 <Port_SetGPIOSCR+0x52>
        val1_mux1 &= (~ (uint32_t)(0x1 << (pin_num % 16))); /* set to 0 */
  108f6e:	9a02      	ldr	r2, [sp, #8]
  108f70:	ea22 0207 	bic.w	r2, r2, r7
  108f74:	9202      	str	r2, [sp, #8]
  108f76:	e7ce      	b.n	108f16 <Port_SetGPIOSCR+0x92>

00108f78 <Port_Init>:
    Port_kConfigPtr = ConfigPtr;
  108f78:	f24f 5364 	movw	r3, #62820	; 0xf564
  108f7c:	f240 1201 	movw	r2, #257	; 0x101
  108f80:	f2c0 0312 	movt	r3, #18
{
  108f84:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    Port_kConfigPtr = ConfigPtr;
  108f88:	4619      	mov	r1, r3
{
  108f8a:	b08b      	sub	sp, #44	; 0x2c
  108f8c:	f249 2460 	movw	r4, #37472	; 0x9260
    Port_kConfigPtr = ConfigPtr;
  108f90:	f2c0 0214 	movt	r2, #20
  108f94:	9307      	str	r3, [sp, #28]
  108f96:	f2c0 0411 	movt	r4, #17
  108f9a:	f44f 7380 	mov.w	r3, #256	; 0x100
  108f9e:	f504 759c 	add.w	r5, r4, #312	; 0x138
  108fa2:	6008      	str	r0, [r1, #0]
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
        const struct scr_signal *signal = &scr_mshc2_canfd_signals[i];

        if (scr_read_signal(signal, &val1)) {
            scr_write_signal(signal,
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  108fa4:	2601      	movs	r6, #1
  108fa6:	e004      	b.n	108fb2 <Port_Init+0x3a>
  108fa8:	3418      	adds	r4, #24
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
  108faa:	42a5      	cmp	r5, r4
  108fac:	d01a      	beq.n	108fe4 <Port_Init+0x6c>
  108fae:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
        if (scr_read_signal(signal, &val1)) {
  108fb2:	4610      	mov	r0, r2
  108fb4:	4619      	mov	r1, r3
  108fb6:	aa08      	add	r2, sp, #32
  108fb8:	f7ff ff4e 	bl	108e58 <scr_read_signal.isra.5>
  108fbc:	2800      	cmp	r0, #0
  108fbe:	d0f3      	beq.n	108fa8 <Port_Init+0x30>
    return (uint32_t)(scr_signal >> 8) & 0xff;
}

static inline uint32_t _scr_width(scr_signal_t scr_signal)
{
    return (uint32_t)scr_signal & 0xff;
  108fc0:	7a23      	ldrb	r3, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  108fc2:	6922      	ldr	r2, [r4, #16]
  108fc4:	fa06 f303 	lsl.w	r3, r6, r3
            scr_write_signal(signal,
  108fc8:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  108fcc:	3b01      	subs	r3, #1
            scr_write_signal(signal,
  108fce:	401a      	ands	r2, r3
  108fd0:	f7ff ff2c 	bl	108e2c <scr_write_signal.isra.4>
            scr_read_signal(signal, &val2);
  108fd4:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
  108fd8:	aa09      	add	r2, sp, #36	; 0x24
  108fda:	3418      	adds	r4, #24
  108fdc:	f7ff ff3c 	bl	108e58 <scr_read_signal.isra.5>
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
  108fe0:	42a5      	cmp	r5, r4
  108fe2:	d1e4      	bne.n	108fae <Port_Init+0x36>
  108fe4:	f64f 0398 	movw	r3, #63640	; 0xf898
  108fe8:	f24f 5a68 	movw	r10, #62824	; 0xf568
  108fec:	2200      	movs	r2, #0
  108fee:	f2c0 0311 	movt	r3, #17
  108ff2:	f64f 0994 	movw	r9, #63636	; 0xf894
  108ff6:	f2c0 0a12 	movt	r10, #18
  108ffa:	f249 2b48 	movw	r11, #37448	; 0x9248
  108ffe:	f2c0 0911 	movt	r9, #17
  109002:	9304      	str	r3, [sp, #16]
    writel(value, vaddr);
  109004:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
  109008:	9303      	str	r3, [sp, #12]
  10900a:	4653      	mov	r3, r10
  10900c:	9202      	str	r2, [sp, #8]
  10900e:	f6cf 4153 	movt	r1, #64595	; 0xfc53
  109012:	46ca      	mov	r10, r9
  109014:	f2c0 0b11 	movt	r11, #17
  109018:	9106      	str	r1, [sp, #24]
  10901a:	4691      	mov	r9, r2
  10901c:	461a      	mov	r2, r3
            PortNumber++) {

        DBG("Port[%d]\n", PortNumber);

        if (Port_lIsPortAvailable(PortNumber) != (uint32_t)0U) {
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
  10901e:	9b07      	ldr	r3, [sp, #28]
  109020:	ea4f 1809 	mov.w	r8, r9, lsl #4
  109024:	9902      	ldr	r1, [sp, #8]
  109026:	464c      	mov	r4, r9
  109028:	f8cd 9004 	str.w	r9, [r13, #4]

            /* Address of each port configuration */
            DataPtr = (const uint32_t *)(const void *)(ConfigDataPtr);

            /* for each pin in one port */
            for (PinNumber = (uint32_t)0U;
  10902c:	2600      	movs	r6, #0
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
  10902e:	681b      	ldr	r3, [r3, #0]
  109030:	4691      	mov	r9, r2
  109032:	9f03      	ldr	r7, [sp, #12]
  109034:	681b      	ldr	r3, [r3, #0]
  109036:	440b      	add	r3, r1
  109038:	461d      	mov	r5, r3
  10903a:	9305      	str	r3, [sp, #20]
  10903c:	e05e      	b.n	1090fc <Port_Init+0x184>
  10903e:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
  109040:	2ca0      	cmp	r4, #160	; 0xa0
  109042:	d065      	beq.n	109110 <Port_Init+0x198>
    if (pin >= PORT_PIN_CNT)
  109044:	2c9b      	cmp	r4, #155	; 0x9b
    writel(value, vaddr);
  109046:	bf84      	itt	hi
  109048:	2300      	movhi	r3, #0
  10904a:	6018      	strhi	r0, [r3, #0]
    if (pin >= PORT_PIN_CNT)
  10904c:	d811      	bhi.n	109072 <Port_Init+0xfa>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10904e:	2c2f      	cmp	r4, #47	; 0x2f
  109050:	8839      	ldrh	r1, [r7, #0]
  109052:	887b      	ldrh	r3, [r7, #2]
  109054:	ea4f 2181 	mov.w	r1, r1, lsl #10
  109058:	ea4f 2383 	mov.w	r3, r3, lsl #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  10905c:	bf96      	itet	ls
  10905e:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  109062:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  109066:	f1a3 736c 	subls.w	r3, r3, #61865984	; 0x3b00000
    writel(value, vaddr);
  10906a:	6008      	str	r0, [r1, #0]
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  10906c:	bf88      	it	hi
  10906e:	f1a3 63f6 	subhi.w	r3, r3, #128974848	; 0x7b00000
                IOPadAddr = getIOPadAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + PinNumber)), IOPadAddr);

                /* setup PIN_MUX_CONFIG, and INPUT_SOURCE_SELECT if needed */
                PinMuxAddr  = getPinMuxAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + 32 + PinNumber)), PinMuxAddr);
  109072:	f8d5 1080 	ldr.w	r1, [r5, #128]	; 0x80
    writel(value, vaddr);
  109076:	6019      	str	r1, [r3, #0]

                /* get MUX_MODE */
                RegVal = (uint32_t)(*(DataPtr + 32 + PinNumber)) & 0x7;
  109078:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80

                if (RegVal == PORT_PIN_MODE_GPIO) {
  10907c:	f013 0307 	ands.w	r3, r3, #7
  109080:	d12e      	bne.n	1090e0 <Port_Init+0x168>
                    /* Non-EMMC pins GPIO Setup */
                    /* GPIO/DIO mode, do DIO Init */

                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
  109082:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
  109086:	e9d9 0302 	ldrd	r0, r3, [r9, #8]
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
  10908a:	0c0a      	lsrs	r2, r1, #16
                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
  10908c:	fa1f fc81 	uxth.w	r12, r1
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
  109090:	d15f      	bne.n	109152 <Port_Init+0x1da>

LOCAL_INLINE vaddr_t getGPIOAddr(uint32_t gpio_index)
{
    vaddr_t gpio_addr;

    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  109092:	459c      	cmp	r12, r3
  109094:	d00d      	beq.n	1090b2 <Port_Init+0x13a>
        return getGPIOBaseAddr();
    }

    if (PORT_GPIO_1 == gpio_index) {
  109096:	f1bc 0f01 	cmp.w	r12, #1
  10909a:	f000 80b6 	beq.w	10920a <Port_Init+0x292>
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  10909e:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
                + (gpio_index - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else {
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1090a0:	bf13      	iteet	ne
  1090a2:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  1090a6:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  1090aa:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1090ae:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  1090b2:	9b01      	ldr	r3, [sp, #4]
  1090b4:	18f3      	adds	r3, r6, r3
                        iomux_write(0x00, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  1090b6:	2b2f      	cmp	r3, #47	; 0x2f
  1090b8:	bf88      	it	hi
  1090ba:	4643      	movhi	r3, r8
  1090bc:	d805      	bhi.n	1090ca <Port_Init+0x152>
  1090be:	2b17      	cmp	r3, #23
  1090c0:	bf8c      	ite	hi
  1090c2:	f5a8 73c0 	subhi.w	r3, r8, #384	; 0x180
  1090c6:	f508 73c0 	addls.w	r3, r8, #384	; 0x180
    writel(value, vaddr);
  1090ca:	2200      	movs	r2, #0
  1090cc:	501a      	str	r2, [r3, r0]
                    Port_SetGPIOSCR((uint32_t)(*(DataPtr + 64 + PinNumber)) & 0xffff,
  1090ce:	4621      	mov	r1, r4
  1090d0:	f8b5 0100 	ldrh.w	r0, [r5, #256]	; 0x100
  1090d4:	f7ff fed6 	bl	108e84 <Port_SetGPIOSCR>
  1090d8:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
  1090dc:	f003 0307 	and.w	r3, r3, #7
    if (pin >= PORT_PIN_CNT)
  1090e0:	2c9b      	cmp	r4, #155	; 0x9b
  1090e2:	d919      	bls.n	109118 <Port_Init+0x1a0>
            for (PinNumber = (uint32_t)0U;
  1090e4:	f8db 3000 	ldr.w	r3, [r11]
                    PinNumber <= (uint32_t)PIN_MAX_NUMBER[PortNumber]; PinNumber++) {
  1090e8:	3601      	adds	r6, #1
  1090ea:	3401      	adds	r4, #1
            for (PinNumber = (uint32_t)0U;
  1090ec:	429e      	cmp	r6, r3
  1090ee:	f105 0504 	add.w	r5, r5, #4
  1090f2:	f108 0810 	add.w	r8, r8, #16
  1090f6:	f107 0744 	add.w	r7, r7, #68	; 0x44
  1090fa:	d852      	bhi.n	1091a2 <Port_Init+0x22a>
                if (((run_in_domain == PORT_RUN_IN_SECURE) || (run_in_domain == PORT_RUN_IN_AP)) && (PortNumber * 32 + PinNumber) <= 47)
  1090fc:	f8da 3000 	ldr.w	r3, [r10]
  109100:	3b01      	subs	r3, #1
  109102:	2b01      	cmp	r3, #1
  109104:	d89b      	bhi.n	10903e <Port_Init+0xc6>
  109106:	2c2f      	cmp	r4, #47	; 0x2f
  109108:	d9ec      	bls.n	1090e4 <Port_Init+0x16c>
  10910a:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
  10910c:	2ca0      	cmp	r4, #160	; 0xa0
  10910e:	d199      	bne.n	109044 <Port_Init+0xcc>
    writel(value, vaddr);
  109110:	9b06      	ldr	r3, [sp, #24]
  109112:	6018      	str	r0, [r3, #0]
  109114:	2300      	movs	r3, #0
  109116:	e7ac      	b.n	109072 <Port_Init+0xfa>
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  109118:	0120      	lsls	r0, r4, #4
  10911a:	1901      	adds	r1, r0, r4
  10911c:	9a04      	ldr	r2, [sp, #16]
  10911e:	00db      	lsls	r3, r3, #3
  109120:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  109124:	4411      	add	r1, r2
  109126:	88c9      	ldrh	r1, [r1, #6]
  109128:	2900      	cmp	r1, #0
  10912a:	d0db      	beq.n	1090e4 <Port_Init+0x16c>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10912c:	9a01      	ldr	r2, [sp, #4]
  10912e:	0289      	lsls	r1, r1, #10
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  109130:	4420      	add	r0, r4
    if (pin < IOMUXC_SAF_PIN_NUM)
  109132:	eb06 0c02 	add.w	r12, r6, r2
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  109136:	9a04      	ldr	r2, [sp, #16]
    if (pin < IOMUXC_SAF_PIN_NUM)
  109138:	f1bc 0f2f 	cmp.w	r12, #47	; 0x2f
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
  10913c:	bf94      	ite	ls
  10913e:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
  109142:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  109146:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  10914a:	4413      	add	r3, r2
  10914c:	895b      	ldrh	r3, [r3, #10]
    writel(value, vaddr);
  10914e:	600b      	str	r3, [r1, #0]
  109150:	e7c8      	b.n	1090e4 <Port_Init+0x16c>
                        if ((uint32_t)(*(DataPtr + 96)) & (0x01 << PinNumber)) {
  109152:	9a05      	ldr	r2, [sp, #20]
  109154:	f04f 0e01 	mov.w	r14, #1
  109158:	fa0e fe06 	lsl.w	r14, r14, r6
  10915c:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
  109160:	ea1e 0f01 	tst.w	r14, r1
  109164:	d033      	beq.n	1091ce <Port_Init+0x256>
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  109166:	459c      	cmp	r12, r3
  109168:	d00c      	beq.n	109184 <Port_Init+0x20c>
    if (PORT_GPIO_1 == gpio_index) {
  10916a:	f1bc 0f01 	cmp.w	r12, #1
  10916e:	d05c      	beq.n	10922a <Port_Init+0x2b2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  109170:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  109172:	bf13      	iteet	ne
  109174:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  109178:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  10917c:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  109180:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  109184:	9b01      	ldr	r3, [sp, #4]
  109186:	18f3      	adds	r3, r6, r3
                            iomux_write(0x05, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  109188:	2b2f      	cmp	r3, #47	; 0x2f
  10918a:	bf88      	it	hi
  10918c:	4641      	movhi	r1, r8
  10918e:	d805      	bhi.n	10919c <Port_Init+0x224>
  109190:	2b17      	cmp	r3, #23
  109192:	bf8c      	ite	hi
  109194:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
  109198:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
  10919c:	2305      	movs	r3, #5
  10919e:	500b      	str	r3, [r1, r0]
  1091a0:	e795      	b.n	1090ce <Port_Init+0x156>
  1091a2:	9b02      	ldr	r3, [sp, #8]
  1091a4:	464a      	mov	r2, r9
  1091a6:	f8dd 9004 	ldr.w	r9, [r13, #4]
  1091aa:	f10b 0b04 	add.w	r11, r11, #4
  1091ae:	f503 73c4 	add.w	r3, r3, #392	; 0x188
  1091b2:	f109 0920 	add.w	r9, r9, #32
  1091b6:	9302      	str	r3, [sp, #8]
    for (PortNumber = (uint32_t)0U; PortNumber <= (uint32_t)PORT_MAX_NUMBER;
  1091b8:	f1b9 0fa0 	cmp.w	r9, #160	; 0xa0
  1091bc:	9b03      	ldr	r3, [sp, #12]
  1091be:	f503 6308 	add.w	r3, r3, #2176	; 0x880
  1091c2:	9303      	str	r3, [sp, #12]
  1091c4:	f47f af2b 	bne.w	10901e <Port_Init+0xa6>
}/* Port_Init */
  1091c8:	b00b      	add	sp, #44	; 0x2c
  1091ca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  1091ce:	459c      	cmp	r12, r3
  1091d0:	d00c      	beq.n	1091ec <Port_Init+0x274>
    if (PORT_GPIO_1 == gpio_index) {
  1091d2:	f1bc 0f01 	cmp.w	r12, #1
  1091d6:	d020      	beq.n	10921a <Port_Init+0x2a2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  1091d8:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1091da:	bf13      	iteet	ne
  1091dc:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  1091e0:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  1091e4:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1091e8:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  1091ec:	9b01      	ldr	r3, [sp, #4]
  1091ee:	18f3      	adds	r3, r6, r3
                            iomux_write(0x01, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  1091f0:	2b2f      	cmp	r3, #47	; 0x2f
  1091f2:	bf88      	it	hi
  1091f4:	4641      	movhi	r1, r8
  1091f6:	d805      	bhi.n	109204 <Port_Init+0x28c>
  1091f8:	2b17      	cmp	r3, #23
  1091fa:	bf8c      	ite	hi
  1091fc:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
  109200:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
  109204:	2301      	movs	r3, #1
  109206:	500b      	str	r3, [r1, r0]
  109208:	e761      	b.n	1090ce <Port_Init+0x156>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10920a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10920e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  109210:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  109214:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  109218:	e74b      	b.n	1090b2 <Port_Init+0x13a>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10921a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10921e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  109220:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  109224:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  109228:	e7e0      	b.n	1091ec <Port_Init+0x274>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10922a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10922e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  109230:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  109234:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  109238:	e7a4      	b.n	109184 <Port_Init+0x20c>
  10923a:	bf00      	nop

0010923c <Port_SetPinMode>:
{
  10923c:	b4f0      	push	{r4, r5, r6, r7}
  10923e:	b082      	sub	sp, #8
  109240:	ab02      	add	r3, sp, #8
    if (PortConf_PIN_GPIO_SAF == pin)
  109242:	28a0      	cmp	r0, #160	; 0xa0
{
  109244:	e903 0006 	stmdb	r3, {r1, r2}
  109248:	9d01      	ldr	r5, [sp, #4]
    if (PortConf_PIN_GPIO_SAF == pin)
  10924a:	d029      	beq.n	1092a0 <Port_SetPinMode+0x64>
    if (pin >= PORT_PIN_CNT)
  10924c:	289b      	cmp	r0, #155	; 0x9b
  10924e:	d902      	bls.n	109256 <Port_SetPinMode+0x1a>
}/* Port_SetPinMode */
  109250:	b002      	add	sp, #8
  109252:	bcf0      	pop	{r4, r5, r6, r7}
  109254:	4770      	bx	r14
  109256:	f64f 0198 	movw	r1, #63640	; 0xf898
  10925a:	0104      	lsls	r4, r0, #4
  10925c:	1823      	adds	r3, r4, r0
    if (pin < IOMUXC_SAF_PIN_NUM)
  10925e:	282f      	cmp	r0, #47	; 0x2f
  109260:	ea4f 0383 	mov.w	r3, r3, lsl #2
  109264:	f2c0 0111 	movt	r1, #17
  109268:	5ace      	ldrh	r6, [r1, r3]
  10926a:	eb01 0203 	add.w	r2, r1, r3
  10926e:	ea4f 2686 	mov.w	r6, r6, lsl #10
  109272:	d91e      	bls.n	1092b2 <Port_SetPinMode+0x76>
    AltNum = (uint32_t)Mode.pin_mux_config & 0x00000007;
  109274:	f005 0707 	and.w	r7, r5, #7
  109278:	8852      	ldrh	r2, [r2, #2]
  10927a:	0292      	lsls	r2, r2, #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  10927c:	f1a6 6cf6 	sub.w	r12, r6, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  109280:	f1a2 62f6 	sub.w	r2, r2, #128974848	; 0x7b00000
        iomux_write(Mode.io_pad_config, IOPadAddr);
  109284:	9e00      	ldr	r6, [sp, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  109286:	00ff      	lsls	r7, r7, #3
    writel(value, vaddr);
  109288:	f8cc 6000 	str.w	r6, [r12]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  10928c:	443b      	add	r3, r7
    writel(value, vaddr);
  10928e:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  109290:	440b      	add	r3, r1
  109292:	88db      	ldrh	r3, [r3, #6]
  109294:	2b00      	cmp	r3, #0
  109296:	d0db      	beq.n	109250 <Port_SetPinMode+0x14>
  109298:	029b      	lsls	r3, r3, #10
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
  10929a:	f1a3 63f6 	sub.w	r3, r3, #128974848	; 0x7b00000
  10929e:	e024      	b.n	1092ea <Port_SetPinMode+0xae>
        iomux_write(Mode.io_pad_config, IOPadAddr);
  1092a0:	9a00      	ldr	r2, [sp, #0]
    writel(value, vaddr);
  1092a2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
  1092a6:	f6cf 4353 	movt	r3, #64595	; 0xfc53
  1092aa:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  1092ac:	b002      	add	sp, #8
  1092ae:	bcf0      	pop	{r4, r5, r6, r7}
  1092b0:	4770      	bx	r14
    if (IOPadAddr)
  1092b2:	f1b6 766c 	subs.w	r6, r6, #61865984	; 0x3b00000
  1092b6:	bf0f      	iteee	eq
  1092b8:	8852      	ldrheq	r2, [r2, #2]
  1092ba:	2344      	movne	r3, #68	; 0x44
        iomux_write(Mode.io_pad_config, IOPadAddr);
  1092bc:	9f00      	ldrne	r7, [sp, #0]
  1092be:	fb03 1300 	mlane	r3, r3, r0, r1
  1092c2:	bf1c      	itt	ne
  1092c4:	885a      	ldrhne	r2, [r3, #2]
    writel(value, vaddr);
  1092c6:	6037      	strne	r7, [r6, #0]
  1092c8:	f005 0707 	and.w	r7, r5, #7
  1092cc:	0292      	lsls	r2, r2, #10
  1092ce:	1823      	adds	r3, r4, r0
  1092d0:	00ff      	lsls	r7, r7, #3
    if (PinMuxAddr)
  1092d2:	f1b2 726c 	subs.w	r2, r2, #61865984	; 0x3b00000
  1092d6:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  1092da:	440b      	add	r3, r1
  1092dc:	88db      	ldrh	r3, [r3, #6]
  1092de:	d10d      	bne.n	1092fc <Port_SetPinMode+0xc0>
  1092e0:	029a      	lsls	r2, r3, #10
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  1092e2:	2b00      	cmp	r3, #0
  1092e4:	d0b4      	beq.n	109250 <Port_SetPinMode+0x14>
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
  1092e6:	f1a2 736c 	sub.w	r3, r2, #61865984	; 0x3b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  1092ea:	4420      	add	r0, r4
  1092ec:	eb07 0780 	add.w	r7, r7, r0, lsl #2
  1092f0:	4439      	add	r1, r7
  1092f2:	894a      	ldrh	r2, [r1, #10]
    writel(value, vaddr);
  1092f4:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  1092f6:	b002      	add	sp, #8
  1092f8:	bcf0      	pop	{r4, r5, r6, r7}
  1092fa:	4770      	bx	r14
    writel(value, vaddr);
  1092fc:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  1092fe:	2344      	movs	r3, #68	; 0x44
  109300:	fb03 7300 	mla	r3, r3, r0, r7
  109304:	440b      	add	r3, r1
  109306:	88db      	ldrh	r3, [r3, #6]
  109308:	2b00      	cmp	r3, #0
  10930a:	d0a1      	beq.n	109250 <Port_SetPinMode+0x14>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10930c:	282f      	cmp	r0, #47	; 0x2f
  10930e:	ea4f 2283 	mov.w	r2, r3, lsl #10
  109312:	4613      	mov	r3, r2
  109314:	d8c1      	bhi.n	10929a <Port_SetPinMode+0x5e>
  109316:	e7e6      	b.n	1092e6 <Port_SetPinMode+0xaa>

00109318 <Port_SetHandle>:
    if (handle != NULL) {
  109318:	b1a0      	cbz	r0, 109344 <Port_SetHandle+0x2c>
        g_port_handle.phy_addr = p_handle->phy_addr;
  10931a:	f24f 5368 	movw	r3, #62824	; 0xf568
        run_in_domain = PORT_RUN_IN_SAFETY;
  10931e:	f64f 0294 	movw	r2, #63636	; 0xf894
        g_port_handle.phy_addr = p_handle->phy_addr;
  109322:	f2c0 0312 	movt	r3, #18
{
  109326:	b430      	push	{r4, r5}
        run_in_domain = PORT_RUN_IN_SAFETY;
  109328:	2100      	movs	r1, #0
  10932a:	f2c0 0211 	movt	r2, #17
        g_port_handle.real_idx = p_handle->real_idx;
  10932e:	e9d0 4500 	ldrd	r4, r5, [r0]
        g_port_handle.phy_addr = p_handle->phy_addr;
  109332:	601c      	str	r4, [r3, #0]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  109334:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
        g_port_handle.dio_phy_addr = p_handle->dio_phy_addr;
  109338:	e9c3 5401 	strd	r5, r4, [r3, #4]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  10933c:	60d8      	str	r0, [r3, #12]
        run_in_domain = PORT_RUN_IN_SAFETY;
  10933e:	6011      	str	r1, [r2, #0]
}
  109340:	bc30      	pop	{r4, r5}
  109342:	4770      	bx	r14
  109344:	4770      	bx	r14
  109346:	bf00      	nop

00109348 <rstgen_get_default_config>:
//! \return
//
//*****************************************************************************
void rstgen_get_default_config(uint32_t *global_rst_maks)
{
    if (!global_rst_maks) {
  109348:	b108      	cbz	r0, 10934e <rstgen_get_default_config+0x6>
        LTRACEF("config paramenter error !!\n");
        return;
    }

    *global_rst_maks = RSTGEN_GLB_RST_SELF_RST_EN(1)
  10934a:	2307      	movs	r3, #7
  10934c:	6003      	str	r3, [r0, #0]
                       | RSTGEN_GLB_RST_SEM_RST_EN(1)
                       | RSTGEN_GLB_RST_DBG_RST_EN(1);

    LTRACEF("rstgen_get_default_config global_rst_maks:0x%x\n", *global_rst_maks);
}
  10934e:	4770      	bx	r14

00109350 <rstgen_init>:
//! \return Returns \b true if the wdg timer is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool rstgen_init(vaddr_t base, const uint32_t global_rst_maks)
{
  109350:	b470      	push	{r4, r5, r6}
  109352:	4604      	mov	r4, r0
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);

    //clear all global register
    reg_write = 0x00000000;
    writel(reg_write, base);
  109354:	2300      	movs	r3, #0
    reg_read = readl(base);
    reg_write = reg_read | rstgen_global_cfg;
    writel(reg_write, base);

    return true;
}
  109356:	2001      	movs	r0, #1
    writel(reg_write, base);
  109358:	6023      	str	r3, [r4, #0]
    uint32_t rstgen_global_cfg = RSTGEN_GLB_RST_SELF_RST_EN(global_rst_maks)
  10935a:	ea01 0200 	and.w	r2, r1, r0
    reg_read = readl(base);
  10935e:	6825      	ldr	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  109360:	fa01 f300 	lsl.w	r3, r1, r0
    reg_write = reg_read & (~RSTGEN_GLB_RST_LOCK_MASK);
  109364:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  109368:	f003 0302 	and.w	r3, r3, #2
    writel(reg_write, base);
  10936c:	6025      	str	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  10936e:	008d      	lsls	r5, r1, #2
    reg_read = readl(base);
  109370:	6826      	ldr	r6, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  109372:	f005 0504 	and.w	r5, r5, #4
    reg_write = reg_read | rstgen_global_cfg;
  109376:	4332      	orrs	r2, r6
  109378:	4313      	orrs	r3, r2
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  10937a:	00ca      	lsls	r2, r1, #3
    reg_write = reg_read | rstgen_global_cfg;
  10937c:	ea43 0105 	orr.w	r1, r3, r5
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  109380:	f002 0308 	and.w	r3, r2, #8
    reg_write = reg_read | rstgen_global_cfg;
  109384:	4319      	orrs	r1, r3
    writel(reg_write, base);
  109386:	6021      	str	r1, [r4, #0]
}
  109388:	bc70      	pop	{r4, r5, r6}
  10938a:	4770      	bx	r14

0010938c <rstgen_global_rst_enable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_enable(vaddr_t base, uint32_t mask)
{
  10938c:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val |= mask;
    writel(val, global_rst_en);

    return true;
}
  10938e:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  109390:	681a      	ldr	r2, [r3, #0]
  109392:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  109396:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  109398:	681a      	ldr	r2, [r3, #0]
    val |= mask;
  10939a:	4311      	orrs	r1, r2
    writel(val, global_rst_en);
  10939c:	6019      	str	r1, [r3, #0]
}
  10939e:	4770      	bx	r14

001093a0 <rstgen_global_rst_disable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_disable(vaddr_t base, uint32_t mask)
{
  1093a0:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val &= ~mask;
    writel(val, global_rst_en);

    return true;
}
  1093a2:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  1093a4:	681a      	ldr	r2, [r3, #0]
  1093a6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  1093aa:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  1093ac:	681a      	ldr	r2, [r3, #0]
    val &= ~mask;
  1093ae:	ea22 0101 	bic.w	r1, r2, r1
    writel(val, global_rst_en);
  1093b2:	6019      	str	r1, [r3, #0]
}
  1093b4:	4770      	bx	r14
  1093b6:	bf00      	nop

001093b8 <rstgen_sw_self_rst>:
// RSTGEN_SEC: ap.self_rst_trig reset the AP domain (sec & ap)
//
//*****************************************************************************
bool rstgen_sw_self_rst(vaddr_t base, bool release)
{
    vaddr_t sw_self_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_SELF_RST_OFF);
  1093b8:	f500 3288 	add.w	r2, r0, #69632	; 0x11000

    /* Configure rst bit. */
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  1093bc:	2001      	movs	r0, #1
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  1093be:	6813      	ldr	r3, [r2, #0]
  1093c0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  1093c4:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  1093c6:	6813      	ldr	r3, [r2, #0]
  1093c8:	f023 0301 	bic.w	r3, r3, #1
  1093cc:	4319      	orrs	r1, r3
  1093ce:	6011      	str	r1, [r2, #0]
}
  1093d0:	4770      	bx	r14
  1093d2:	bf00      	nop

001093d4 <rstgen_sw_oth_rst>:
// RSTGEN_RTC and RSTGEN_SEC: oth reset has no effect
//
//*****************************************************************************
bool rstgen_sw_oth_rst(vaddr_t base, bool release)
{
    vaddr_t sw_oth_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_OTH_RST_OFF);
  1093d4:	f500 3290 	add.w	r2, r0, #73728	; 0x12000

    /* Configure rst bit. */
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  1093d8:	2001      	movs	r0, #1
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  1093da:	6813      	ldr	r3, [r2, #0]
  1093dc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  1093e0:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  1093e2:	6813      	ldr	r3, [r2, #0]
  1093e4:	f023 0301 	bic.w	r3, r3, #1
  1093e8:	4319      	orrs	r1, r3
  1093ea:	6011      	str	r1, [r2, #0]
}
  1093ec:	4770      	bx	r14
  1093ee:	bf00      	nop

001093f0 <rstgen_get_rst_sta>:
uint32_t rstgen_get_rst_sta(vaddr_t base)
{
    vaddr_t rst_sta_addr;
    uint32_t rstgen_rst_sta = 0;

    rst_sta_addr = base + SOC_RSTGEN_REG_MAP(RSTGEN_RST_STA_OFF);
  1093f0:	f500 3098 	add.w	r0, r0, #77824	; 0x13000

    rstgen_rst_sta = readl(rst_sta_addr);
  1093f4:	6800      	ldr	r0, [r0, #0]
    LTRACEF("rstgen_get_rst_sta rst_sta:0x%x\n", rstgen_rst_sta);
    return rstgen_rst_sta;
}
  1093f6:	4770      	bx	r14

001093f8 <rstgen_iso_enable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_enable(vaddr_t base, uint32_t iso_idx)
{
  1093f8:	4603      	mov	r3, r0
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  1093fa:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_enable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);

    return true;
}
  1093fc:	2001      	movs	r0, #1
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);
  1093fe:	f06f 0201 	mvn.w	r2, #1
  109402:	50ca      	str	r2, [r1, r3]
}
  109404:	4770      	bx	r14
  109406:	bf00      	nop

00109408 <rstgen_iso_status>:
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  109408:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_status is ok iso_slice_idx:%d\n", iso_slice_idx);
    return readl(iso_addr) & RSTGEN_ISO_EN_B_MASK;
  10940a:	5808      	ldr	r0, [r1, r0]
}
  10940c:	f000 0001 	and.w	r0, r0, #1
  109410:	4770      	bx	r14
  109412:	bf00      	nop

00109414 <rstgen_iso_disable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_disable(vaddr_t base, uint32_t iso_idx)
{
  109414:	4602      	mov	r2, r0

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
    LTRACEF("rstgen_iso_disable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  109416:	2301      	movs	r3, #1

    return true;
}
  109418:	4618      	mov	r0, r3
    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  10941a:	0309      	lsls	r1, r1, #12
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  10941c:	508b      	str	r3, [r1, r2]
}
  10941e:	4770      	bx	r14

00109420 <rstgen_core_reset>:
// sure there's no active bus transaction on the core.
//
//*****************************************************************************
bool rstgen_core_reset(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  109420:	0849      	lsrs	r1, r1, #1
{
  109422:	b430      	push	{r4, r5}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  109424:	034c      	lsls	r4, r1, #13
  109426:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000
  10942a:	1825      	adds	r5, r4, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  10942c:	5823      	ldr	r3, [r4, r0]
  10942e:	2b00      	cmp	r3, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  109430:	bfb8      	it	lt
  109432:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  109434:	db17      	blt.n	109466 <rstgen_core_reset+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  109436:	0349      	lsls	r1, r1, #13
  109438:	180b      	adds	r3, r1, r0
    }

    /* Release STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, 1);
  10943a:	580a      	ldr	r2, [r1, r0]
  10943c:	f042 0201 	orr.w	r2, r2, #1
  109440:	500a      	str	r2, [r1, r0]
    while (!(readl(core_sw_rst) &
  109442:	681a      	ldr	r2, [r3, #0]
  109444:	0092      	lsls	r2, r2, #2
  109446:	d5fc      	bpl.n	109442 <rstgen_core_reset+0x22>
                 RSTGEN_CORE_SW_RST_STATIC_RST_B_STA_MASK));

    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  109448:	5822      	ldr	r2, [r4, r0]
  10944a:	f042 0201 	orr.w	r2, r2, #1
  10944e:	5022      	str	r2, [r4, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  109450:	682a      	ldr	r2, [r5, #0]
  109452:	0054      	lsls	r4, r2, #1
  109454:	d5fc      	bpl.n	109450 <rstgen_core_reset+0x30>
    /* Trigger auto-clear reset. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_AUTO_CLR_SHIFT, 1, 1);
  109456:	580a      	ldr	r2, [r1, r0]
  109458:	f042 0202 	orr.w	r2, r2, #2
  10945c:	500a      	str	r2, [r1, r0]

    /* Polling reset status */
    while (!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK));
  10945e:	681a      	ldr	r2, [r3, #0]
  109460:	0052      	lsls	r2, r2, #1
  109462:	d5fc      	bpl.n	10945e <rstgen_core_reset+0x3e>

    return true;
  109464:	2001      	movs	r0, #1
}
  109466:	bc30      	pop	{r4, r5}
  109468:	4770      	bx	r14
  10946a:	bf00      	nop

0010946c <rstgen_core_ctl>:
//
//*****************************************************************************
bool rstgen_core_ctl(vaddr_t base, uint32_t core_idx,
                               bool release)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  10946c:	0849      	lsrs	r1, r1, #1
{
  10946e:	b470      	push	{r4, r5, r6}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  109470:	034b      	lsls	r3, r1, #13
  109472:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
  109476:	181c      	adds	r4, r3, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  109478:	581d      	ldr	r5, [r3, r0]
  10947a:	2d00      	cmp	r5, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  10947c:	bfb8      	it	lt
  10947e:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  109480:	db17      	blt.n	1094b2 <rstgen_core_ctl+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  109482:	0349      	lsls	r1, r1, #13
  109484:	180d      	adds	r5, r1, r0
    }
    /* Check core SW reset status */
    if (release && (readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  109486:	580e      	ldr	r6, [r1, r0]
  109488:	b1aa      	cbz	r2, 1094b6 <rstgen_core_ctl+0x4a>
  10948a:	0076      	lsls	r6, r6, #1
  10948c:	d410      	bmi.n	1094b0 <rstgen_core_ctl+0x44>
        return true;
    }

    uint32_t sw_rst = release?1:0;
    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  10948e:	581e      	ldr	r6, [r3, r0]
  109490:	f046 0601 	orr.w	r6, r6, #1
  109494:	501e      	str	r6, [r3, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  109496:	6823      	ldr	r3, [r4, #0]
  109498:	005b      	lsls	r3, r3, #1
  10949a:	d5fc      	bpl.n	109496 <rstgen_core_ctl+0x2a>

    /* STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, sw_rst);
  10949c:	580b      	ldr	r3, [r1, r0]
  10949e:	f023 0301 	bic.w	r3, r3, #1
  1094a2:	4313      	orrs	r3, r2
  1094a4:	500b      	str	r3, [r1, r0]

    /* Wait reset done. */
    while (sw_rst != (readl(core_sw_rst)
  1094a6:	682b      	ldr	r3, [r5, #0]
                            & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK)>>RSTGEN_CORE_SW_RST_CORE_RST_STA_SHIFT);
  1094a8:	f3c3 7380 	ubfx	r3, r3, #30, #1
    while (sw_rst != (readl(core_sw_rst)
  1094ac:	4293      	cmp	r3, r2
  1094ae:	d1fa      	bne.n	1094a6 <rstgen_core_ctl+0x3a>
        return true;
  1094b0:	2001      	movs	r0, #1
    return true;
}
  1094b2:	bc70      	pop	{r4, r5, r6}
  1094b4:	4770      	bx	r14
    if (!release && !(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  1094b6:	0076      	lsls	r6, r6, #1
  1094b8:	d4e9      	bmi.n	10948e <rstgen_core_ctl+0x22>
        return true;
  1094ba:	2001      	movs	r0, #1
  1094bc:	e7f9      	b.n	1094b2 <rstgen_core_ctl+0x46>
  1094be:	bf00      	nop

001094c0 <rstgen_module_ctl>:
//*****************************************************************************
bool rstgen_module_ctl(vaddr_t base, uint32_t module_idx,
                         bool release)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  1094c0:	0309      	lsls	r1, r1, #12
{
  1094c2:	b410      	push	{r4}
                             RSTGEN_MODULE_RST_OFF(module_slice));

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d release:%d\n",
            (uint64_t)base, module_slice, release);

    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1094c4:	580b      	ldr	r3, [r1, r0]
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  1094c6:	180c      	adds	r4, r1, r0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1094c8:	2b00      	cmp	r3, #0
    {
        LTRACEF("module_slice:%d has been locked.\n", module_slice);
        return false;
  1094ca:	bfb8      	it	lt
  1094cc:	2000      	movlt	r0, #0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1094ce:	db15      	blt.n	1094fc <rstgen_module_ctl+0x3c>
    }

    if (release && (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  1094d0:	580b      	ldr	r3, [r1, r0]
  1094d2:	b1b2      	cbz	r2, 109502 <rstgen_module_ctl+0x42>
  1094d4:	005b      	lsls	r3, r3, #1
  1094d6:	d410      	bmi.n	1094fa <rstgen_module_ctl+0x3a>
        LTRACEF("module_slice:%d already in assert status\n", module_slice);
        return true;
    }

    /* Enable module reset. */
    RMWREG32(module_rst, RSTGEN_MODULE_RST_EN_SHIFT, 1, 1);
  1094d8:	580b      	ldr	r3, [r1, r0]
  1094da:	f043 0302 	orr.w	r3, r3, #2
  1094de:	500b      	str	r3, [r1, r0]

    while (!(readl(module_rst) & RSTGEN_MODULE_RST_EN_MASK));
  1094e0:	6823      	ldr	r3, [r4, #0]
  1094e2:	079b      	lsls	r3, r3, #30
  1094e4:	d5fc      	bpl.n	1094e0 <rstgen_module_ctl+0x20>

    /* Write RST_N bit. 0 = reset, 1 = release. */
    uint32_t rst_n = release?1:0;
    RMWREG32(module_rst, RSTGEN_MODULE_RST_N_SHIFT, 1, rst_n);
  1094e6:	580b      	ldr	r3, [r1, r0]
  1094e8:	f023 0301 	bic.w	r3, r3, #1
  1094ec:	4313      	orrs	r3, r2
  1094ee:	500b      	str	r3, [r1, r0]

    /* Wait module reset done. */
    while (rst_n != (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK)>>RSTGEN_MODULE_RST_STA_SHIFT);
  1094f0:	6823      	ldr	r3, [r4, #0]
  1094f2:	f3c3 7380 	ubfx	r3, r3, #30, #1
  1094f6:	4293      	cmp	r3, r2
  1094f8:	d1fa      	bne.n	1094f0 <rstgen_module_ctl+0x30>
        return true;
  1094fa:	2001      	movs	r0, #1

    return true;
}
  1094fc:	f85d 4b04 	ldr.w	r4, [r13], #4
  109500:	4770      	bx	r14
    if (!release && !(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  109502:	005b      	lsls	r3, r3, #1
  109504:	d4e8      	bmi.n	1094d8 <rstgen_module_ctl+0x18>
        return true;
  109506:	2001      	movs	r0, #1
  109508:	e7f8      	b.n	1094fc <rstgen_module_ctl+0x3c>
  10950a:	bf00      	nop

0010950c <rstgen_module_status>:
// return 0, the module reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_module_status(vaddr_t base, uint32_t module_idx)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  10950c:	0309      	lsls	r1, r1, #12

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d \n",
            (uint64_t)base, module_slice);

    /* RSTGEN_MODULE_RST_STA, 0 = reset, 1 = release. */
    return !!(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK);
  10950e:	5808      	ldr	r0, [r1, r0]
}
  109510:	f3c0 7080 	ubfx	r0, r0, #30, #1
  109514:	4770      	bx	r14
  109516:	bf00      	nop

00109518 <rstgen_core_status>:
// return 1, the core reset has be released.
// return 0, the core reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_core_status(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  109518:	0849      	lsrs	r1, r1, #1
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  10951a:	0349      	lsls	r1, r1, #13
                RSTGEN_CORE_SW_RST_OFF(core_slice));
    return !!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK);
  10951c:	5808      	ldr	r0, [r1, r0]
}
  10951e:	f3c0 7080 	ubfx	r0, r0, #30, #1
  109522:	4770      	bx	r14

00109524 <rtc_enable>:
        return false;
    }
}

void rtc_enable(addr_t base)
{
  109524:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  109528:	4601      	mov	r1, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10952a:	f3ef 8300 	mrs	r3, CPSR
  10952e:	0618      	lsls	r0, r3, #24
  109530:	d409      	bmi.n	109546 <rtc_enable+0x22>
    __asm__ volatile("cpsid i");
  109532:	b672      	cpsid	i
    RTC_LOCK(base);

    uint32_t var = readl(base + RTCROFF(RTC_CTRL));
  109534:	680b      	ldr	r3, [r1, #0]
    if (var & (1ul << RTCBS(RTC_CTRL, EN))) {
  109536:	07da      	lsls	r2, r3, #31
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  109538:	bf58      	it	pl
  10953a:	f04f 0e01 	movpl.w	r14, #1
  10953e:	d506      	bpl.n	10954e <rtc_enable+0x2a>
    __asm__ volatile("cpsie i");
  109540:	b662      	cpsie	i
    var |= (1ul << RTCBS(RTC_CTRL, EN));
    writel(var, base + RTCROFF(RTC_CTRL));
    rtc_clk_sync(base, CLK_SYNC);

    RTC_UNLOCK(base);
}
  109542:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    uint32_t var = readl(base + RTCROFF(RTC_CTRL));
  109546:	680b      	ldr	r3, [r1, #0]
    if (var & (1ul << RTCBS(RTC_CTRL, EN))) {
  109548:	f013 0e01 	ands.w	r14, r3, #1
  10954c:	d1f9      	bne.n	109542 <rtc_enable+0x1e>
    if (var & (1ul << RTCBS(RTC_CTRL, LOCK))) {
  10954e:	2b00      	cmp	r3, #0
  109550:	db1f      	blt.n	109592 <rtc_enable+0x6e>
    writel(0, base + RTCROFF(RTC_L));
  109552:	2200      	movs	r2, #0
    var |= (1ul << RTCBS(RTC_CTRL, EN));
  109554:	f043 0301 	orr.w	r3, r3, #1
    writel(0, base + RTCROFF(RTC_L));
  109558:	f101 0c08 	add.w	r12, r1, #8
  10955c:	608a      	str	r2, [r1, #8]
    writel(0, base + RTCROFF(RTC_H));
  10955e:	1d0f      	adds	r7, r1, #4
  109560:	604a      	str	r2, [r1, #4]
    writel(var, base + RTCROFF(RTC_CTRL));
  109562:	600b      	str	r3, [r1, #0]
    return ret;
}

uint64_t rtc_get_tick(addr_t base)
{
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109564:	688b      	ldr	r3, [r1, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109566:	6848      	ldr	r0, [r1, #4]

    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109568:	ea42 0403 	orr.w	r4, r2, r3
     return 0;
}

static void rtc_clk_sync(addr_t base, uint32_t rtc_clk)
{
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  10956c:	f114 0807 	adds.w	r8, r4, #7
  109570:	f140 0900 	adc.w	r9, r0, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109574:	f8dc 0000 	ldr.w	r0, [r12]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109578:	2400      	movs	r4, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  10957a:	683e      	ldr	r6, [r7, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  10957c:	ea44 0200 	orr.w	r2, r4, r0

    while(rtc_get_tick(base) <= rtc_sync_point);
  109580:	45b1      	cmp	r9, r6
  109582:	bf08      	it	eq
  109584:	4590      	cmpeq	r8, r2
  109586:	d2f5      	bcs.n	109574 <rtc_enable+0x50>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  109588:	f1be 0f00 	cmp.w	r14, #0
  10958c:	d1d8      	bne.n	109540 <rtc_enable+0x1c>
}
  10958e:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        printf("Error: rtc 0x%lx was locked beforehand!\n", base);
  109592:	f649 6038 	movw	r0, #40504	; 0x9e38
  109596:	f2c0 0011 	movt	r0, #17
}
  10959a:	e8bd 43f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r14}
        printf("Error: rtc 0x%lx was locked beforehand!\n", base);
  10959e:	f00b b931 	b.w	114804 <printf>
  1095a2:	bf00      	nop

001095a4 <rtc_wakeup_enable>:
    RTC_UNLOCK(base);
}


void rtc_wakeup_enable(addr_t base, bool en, bool irq_en, bool req_en)
{
  1095a4:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    uint32_t var = readl(base + RTCROFF(WAKEUP_CTRL));
  1095a8:	6984      	ldr	r4, [r0, #24]
{
  1095aa:	b082      	sub	sp, #8
    uint32_t tmp = 0;

    var &= ~( (1ul << RTCBS(WAKEUP_CTRL, REQ_EN)) |
  1095ac:	f024 0c1f 	bic.w	r12, r4, #31
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1095b0:	f3ef 8400 	mrs	r4, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1095b4:	0624      	lsls	r4, r4, #24
    spin_lock_saved_state_t state = 0;
  1095b6:	bf48      	it	mi
  1095b8:	f04f 0a00 	movmi.w	r10, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1095bc:	d402      	bmi.n	1095c4 <rtc_wakeup_enable+0x20>
    __asm__ volatile("cpsid i");
  1095be:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1095c0:	f04f 0a01 	mov.w	r10, #1
  1095c4:	f100 0508 	add.w	r5, r0, #8
  1095c8:	1d04      	adds	r4, r0, #4
              (1ul << RTCBS(WAKEUP_CTRL, STATUS)) |
              (1ul << RTCBS(WAKEUP_CTRL, CLEAR)) );

    RTC_LOCK(base);

    if(!en)
  1095ca:	2900      	cmp	r1, #0
  1095cc:	d160      	bne.n	109690 <rtc_wakeup_enable+0xec>
    {
        tmp = var;
        tmp |= (1ul << RTCBS(WAKEUP_CTRL, CLEAR));
  1095ce:	f04c 0e10 	orr.w	r14, r12, #16

        writel(tmp, base + RTCROFF(WAKEUP_CTRL));
  1095d2:	f8c0 e018 	str.w	r14, [r0, #24]
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  1095d6:	6883      	ldr	r3, [r0, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  1095d8:	6842      	ldr	r2, [r0, #4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1095da:	4617      	mov	r7, r2
  1095dc:	ea41 0803 	orr.w	r8, r1, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  1095e0:	f118 0207 	adds.w	r2, r8, #7
  1095e4:	f147 0300 	adc.w	r3, r7, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  1095e8:	6829      	ldr	r1, [r5, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1095ea:	f04f 0800 	mov.w	r8, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  1095ee:	6826      	ldr	r6, [r4, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1095f0:	46b1      	mov	r9, r6
  1095f2:	ea48 0601 	orr.w	r6, r8, r1
    while(rtc_get_tick(base) <= rtc_sync_point);
  1095f6:	454b      	cmp	r3, r9
  1095f8:	bf08      	it	eq
  1095fa:	42b2      	cmpeq	r2, r6
  1095fc:	d2f4      	bcs.n	1095e8 <rtc_wakeup_enable+0x44>
        rtc_clk_sync(base, CLK_SYNC);
        writel(var, base + RTCROFF(WAKEUP_CTRL));
  1095fe:	f8c0 c018 	str.w	r12, [r0, #24]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109602:	4646      	mov	r6, r8
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109604:	6883      	ldr	r3, [r0, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109606:	6841      	ldr	r1, [r0, #4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109608:	460f      	mov	r7, r1
  10960a:	ea46 0603 	orr.w	r6, r6, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  10960e:	1df2      	adds	r2, r6, #7
  109610:	f147 0300 	adc.w	r3, r7, #0
  109614:	e9cd 2300 	strd	r2, r3, [r13]
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109618:	6829      	ldr	r1, [r5, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  10961a:	2600      	movs	r6, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  10961c:	f8d4 8000 	ldr.w	r8, [r4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109620:	ea46 0201 	orr.w	r2, r6, r1
    while(rtc_get_tick(base) <= rtc_sync_point);
  109624:	e9dd 6700 	ldrd	r6, r7, [r13]
  109628:	4547      	cmp	r7, r8
  10962a:	bf08      	it	eq
  10962c:	4296      	cmpeq	r6, r2
  10962e:	d2f3      	bcs.n	109618 <rtc_wakeup_enable+0x74>
                 ( (req_en == true ? 1ul : 0ul) << RTCBS(WAKEUP_CTRL, REQ_EN)) );
        tmp = var;
        tmp |= (1ul << RTCBS(WAKEUP_CTRL, CLEAR));
    }

    writel(tmp, base + RTCROFF(WAKEUP_CTRL));
  109630:	f8c0 e018 	str.w	r14, [r0, #24]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109634:	f04f 0800 	mov.w	r8, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109638:	6883      	ldr	r3, [r0, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  10963a:	6842      	ldr	r2, [r0, #4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  10963c:	4691      	mov	r9, r2
  10963e:	ea48 0603 	orr.w	r6, r8, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  109642:	1df2      	adds	r2, r6, #7
  109644:	f149 0300 	adc.w	r3, r9, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109648:	6829      	ldr	r1, [r5, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  10964a:	2600      	movs	r6, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  10964c:	f8d4 e000 	ldr.w	r14, [r4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109650:	ea46 0801 	orr.w	r8, r6, r1
    while(rtc_get_tick(base) <= rtc_sync_point);
  109654:	4573      	cmp	r3, r14
  109656:	bf08      	it	eq
  109658:	4542      	cmpeq	r2, r8
  10965a:	d2f5      	bcs.n	109648 <rtc_wakeup_enable+0xa4>
    rtc_clk_sync(base, CLK_SYNC);
    writel(var, base + RTCROFF(WAKEUP_CTRL));
  10965c:	f8c0 c018 	str.w	r12, [r0, #24]
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109660:	6883      	ldr	r3, [r0, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109662:	6841      	ldr	r1, [r0, #4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109664:	431e      	orrs	r6, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  109666:	f116 0807 	adds.w	r8, r6, #7
  10966a:	f141 0900 	adc.w	r9, r1, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  10966e:	6829      	ldr	r1, [r5, #0]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109670:	2600      	movs	r6, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109672:	f8d4 c000 	ldr.w	r12, [r4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109676:	ea46 0201 	orr.w	r2, r6, r1
    while(rtc_get_tick(base) <= rtc_sync_point);
  10967a:	45e1      	cmp	r9, r12
  10967c:	bf08      	it	eq
  10967e:	4590      	cmpeq	r8, r2
  109680:	d2f5      	bcs.n	10966e <rtc_wakeup_enable+0xca>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  109682:	f1ba 0f00 	cmp.w	r10, #0
  109686:	d000      	beq.n	10968a <rtc_wakeup_enable+0xe6>
    __asm__ volatile("cpsie i");
  109688:	b662      	cpsie	i
    rtc_clk_sync(base, CLK_SYNC);

    RTC_UNLOCK(base);
}
  10968a:	b002      	add	sp, #8
  10968c:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        var |= ( (1ul << RTCBS(WAKEUP_CTRL, EN)) |
  109690:	2a00      	cmp	r2, #0
  109692:	ea43 030c 	orr.w	r3, r3, r12
  109696:	bf0c      	ite	eq
  109698:	f04f 0c04 	moveq.w	r12, #4
  10969c:	f04f 0c06 	movne.w	r12, #6
  1096a0:	ea4c 0c03 	orr.w	r12, r12, r3
        tmp |= (1ul << RTCBS(WAKEUP_CTRL, CLEAR));
  1096a4:	f04c 0e10 	orr.w	r14, r12, #16
  1096a8:	e7c2      	b.n	109630 <rtc_wakeup_enable+0x8c>
  1096aa:	bf00      	nop

001096ac <rtc_clr_wakeup_status>:
        return false;
    }
}

void rtc_clr_wakeup_status(addr_t base)
{
  1096ac:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    uint32_t var = readl(base + RTCROFF(WAKEUP_CTRL));
  1096b0:	f8d0 a018 	ldr.w	r10, [r0, #24]

    var |= (1ul << RTCBS(WAKEUP_CTRL,CLEAR));
  1096b4:	f04a 0310 	orr.w	r3, r10, #16
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1096b8:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1096bc:	0612      	lsls	r2, r2, #24
    spin_lock_saved_state_t state = 0;
  1096be:	bf48      	it	mi
  1096c0:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1096c2:	d401      	bmi.n	1096c8 <rtc_clr_wakeup_status+0x1c>
    __asm__ volatile("cpsid i");
  1096c4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1096c6:	2501      	movs	r5, #1

    RTC_LOCK(base);

    writel(var, base + RTCROFF(WAKEUP_CTRL));
  1096c8:	6183      	str	r3, [r0, #24]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1096ca:	f04f 0800 	mov.w	r8, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  1096ce:	6883      	ldr	r3, [r0, #8]
  1096d0:	f100 0108 	add.w	r1, r0, #8
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  1096d4:	6842      	ldr	r2, [r0, #4]
  1096d6:	1d04      	adds	r4, r0, #4
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1096d8:	4691      	mov	r9, r2
  1096da:	ea48 0603 	orr.w	r6, r8, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  1096de:	1df2      	adds	r2, r6, #7
  1096e0:	f149 0300 	adc.w	r3, r9, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  1096e4:	f8d1 c000 	ldr.w	r12, [r1]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1096e8:	2600      	movs	r6, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  1096ea:	f8d4 e000 	ldr.w	r14, [r4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  1096ee:	ea46 080c 	orr.w	r8, r6, r12
    while(rtc_get_tick(base) <= rtc_sync_point);
  1096f2:	4573      	cmp	r3, r14
  1096f4:	bf08      	it	eq
  1096f6:	4542      	cmpeq	r2, r8
  1096f8:	d2f4      	bcs.n	1096e4 <rtc_clr_wakeup_status+0x38>
  1096fa:	f02a 0318 	bic.w	r3, r10, #24
    rtc_clk_sync(base,CLK_SYNC);

    var &= ~( (1ul << RTCBS(WAKEUP_CTRL,CLEAR)) | (1ul << RTCBS(WAKEUP_CTRL,STATUS)) );

    writel(var, base + RTCROFF(WAKEUP_CTRL));
  1096fe:	6183      	str	r3, [r0, #24]
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109700:	6883      	ldr	r3, [r0, #8]
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109702:	f8d0 c004 	ldr.w	r12, [r0, #4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109706:	431e      	orrs	r6, r3
    uint64_t rtc_sync_point = rtc_get_tick(base) + rtc_clk;
  109708:	f116 0807 	adds.w	r8, r6, #7
  10970c:	f14c 0900 	adc.w	r9, r12, #0
    uint32_t tickl = readl(base + RTCROFF(RTC_L));
  109710:	f8d1 c000 	ldr.w	r12, [r1]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  109714:	2600      	movs	r6, #0
    uint32_t tickh = readl(base + RTCROFF(RTC_H));
  109716:	f8d4 e000 	ldr.w	r14, [r4]
    uint64_t tick = ((uint64_t)tickh << 32) | (uint64_t)tickl;
  10971a:	ea46 020c 	orr.w	r2, r6, r12
    while(rtc_get_tick(base) <= rtc_sync_point);
  10971e:	45f1      	cmp	r9, r14
  109720:	bf08      	it	eq
  109722:	4590      	cmpeq	r8, r2
  109724:	d2f4      	bcs.n	109710 <rtc_clr_wakeup_status+0x64>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  109726:	b105      	cbz	r5, 10972a <rtc_clr_wakeup_status+0x7e>
    __asm__ volatile("cpsie i");
  109728:	b662      	cpsie	i
    rtc_clk_sync(base,CLK_SYNC);

    RTC_UNLOCK(base);
}
  10972a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  10972e:	bf00      	nop

00109730 <rtc_init>:
        if (((readl(APB_XTAL_RTC_BASE)) & 0x80000003) == 0x80000002)
  109730:	2300      	movs	r3, #0
  109732:	2103      	movs	r1, #3
  109734:	f2cf 1383 	movt	r3, #61827	; 0xf183
  109738:	2202      	movs	r2, #2
  10973a:	f2c8 0100 	movt	r1, #32768	; 0x8000
  10973e:	f2c8 0200 	movt	r2, #32768	; 0x8000
  109742:	681b      	ldr	r3, [r3, #0]
  109744:	400b      	ands	r3, r1
  109746:	4293      	cmp	r3, r2
  109748:	d00d      	beq.n	109766 <rtc_init+0x36>
    uint32_t var = readl(base + RTCROFF(WAKEUP_CTRL));
  10974a:	6983      	ldr	r3, [r0, #24]
    if(var & (1ul << RTCBS(WAKEUP_CTRL,STATUS)))
  10974c:	071b      	lsls	r3, r3, #28
  10974e:	d400      	bmi.n	109752 <rtc_init+0x22>
  109750:	4770      	bx	r14
{
  109752:	b510      	push	{r4, r14}
        rtc_clr_wakeup_status(base);
  109754:	f7ff ffaa 	bl	1096ac <rtc_clr_wakeup_status>
        rtc_wakeup_enable(base, false, false, false);
  109758:	2300      	movs	r3, #0
  10975a:	461a      	mov	r2, r3
  10975c:	4619      	mov	r1, r3
}
  10975e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        rtc_wakeup_enable(base, false, false, false);
  109762:	f7ff bf1f 	b.w	1095a4 <rtc_wakeup_enable>
            if (!(readl(APB_RC_RTC_BASE + 4) & 1ul))
  109766:	2304      	movs	r3, #4
  109768:	f2cf 1382 	movt	r3, #61826	; 0xf182
  10976c:	681a      	ldr	r2, [r3, #0]
  10976e:	07d2      	lsls	r2, r2, #31
                writel(1ul, APB_RC_RTC_BASE + 4);
  109770:	bf5c      	itt	pl
  109772:	2201      	movpl	r2, #1
  109774:	601a      	strpl	r2, [r3, #0]
  109776:	e7e8      	b.n	10974a <rtc_init+0x1a>

00109778 <scr_get>:

/*
 * Get SCR signal value.
 */
uint32_t scr_get(scr_signal_t scr_signal)
{
  109778:	b4f0      	push	{r4, r5, r6, r7}
  10977a:	4604      	mov	r4, r0
  10977c:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  10977e:	f3c1 2107 	ubfx	r1, r1, #8, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  109782:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  109786:	061b      	lsls	r3, r3, #24
  109788:	ea4f 4610 	mov.w	r6, r0, lsr #16
  10978c:	d428      	bmi.n	1097e0 <scr_get+0x68>
    __asm__ volatile("cpsid i");
  10978e:	b672      	cpsid	i
}

static inline uint32_t _scr_reg(scr_signal_t scr_signal)
{
    const int scr_shift[] = {
  109790:	f649 6264 	movw	r2, #40548	; 0x9e64
        [SCR_SEC]    = 10,
        [SCR_HPI]    = 0,
    };

    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
    return reg << scr_shift[_scr_id(scr_signal)];
  109794:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  109796:	f2c0 0211 	movt	r2, #17
    return reg << scr_shift[_scr_id(scr_signal)];
  10979a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  -----------------------------------------------------*/

/* Get physical address of SCR register. */
static inline uint32_t _scr_reg_paddr(enum scr_id scr_id, uint32_t reg)
{
    const addr_t scr_base[] = {
  10979e:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  1097a2:	ad01      	add	r5, sp, #4
  1097a4:	ca07      	ldmia	r2, {r0, r1, r2}
  1097a6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  1097aa:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1097ae:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  1097b2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1097b6:	40be      	lsls	r6, r7
        [SCR_SAFETY] = APB_SCR_SAF_BASE,
        [SCR_SEC]    = APB_SCR_SEC_BASE,
        [SCR_HPI]    = APB_SCR_HPI_BASE,
    };

    return scr_base[scr_id] + reg;
  1097b8:	f853 3c0c 	ldr.w	r3, [r3, #-12]
};

static inline uint32_t _scr_read_reg(enum scr_id scr_id, uint32_t reg)
{
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  1097bc:	58f0      	ldr	r0, [r6, r3]
    __asm__ volatile("cpsie i");
  1097be:	b662      	cpsie	i
    return (uint32_t)(scr_signal >> 8) & 0xff;
  1097c0:	f3c4 2307 	ubfx	r3, r4, #8, #8
    return (uint32_t)scr_signal & 0xff;
  1097c4:	b2e4      	uxtb	r4, r4
    spin_lock_irqsave(&g_scr_lock, state);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));
    spin_unlock_irqrestore(&g_scr_lock, state);

    return (val >> _scr_start_bit(scr_signal)) &
            BIT_MASK(_scr_width(scr_signal));
  1097c6:	2c1f      	cmp	r4, #31
    return (val >> _scr_start_bit(scr_signal)) &
  1097c8:	fa20 f003 	lsr.w	r0, r0, r3
            BIT_MASK(_scr_width(scr_signal));
  1097cc:	d805      	bhi.n	1097da <scr_get+0x62>
  1097ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  1097d2:	fa03 f404 	lsl.w	r4, r3, r4
  1097d6:	ea20 0004 	bic.w	r0, r0, r4
}
  1097da:	b004      	add	sp, #16
  1097dc:	bcf0      	pop	{r4, r5, r6, r7}
  1097de:	4770      	bx	r14
    const int scr_shift[] = {
  1097e0:	f649 6264 	movw	r2, #40548	; 0x9e64
    return reg << scr_shift[_scr_id(scr_signal)];
  1097e4:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  1097e6:	f2c0 0211 	movt	r2, #17
    return reg << scr_shift[_scr_id(scr_signal)];
  1097ea:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    const addr_t scr_base[] = {
  1097ee:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  1097f2:	ad01      	add	r5, sp, #4
  1097f4:	ca07      	ldmia	r2, {r0, r1, r2}
  1097f6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  1097fa:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1097fe:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  109802:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  109806:	40be      	lsls	r6, r7
    return scr_base[scr_id] + reg;
  109808:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  10980c:	58f0      	ldr	r0, [r6, r3]
  10980e:	e7d7      	b.n	1097c0 <scr_get+0x48>

00109810 <scr_is_locked>:
    const int scr_shift[] = {
  109810:	f649 6264 	movw	r2, #40548	; 0x9e64
/*
 * Check whether the SCR signal is locked - read only or manually
 * locked by SW.
 */
bool scr_is_locked(scr_signal_t scr_signal)
{
  109814:	460b      	mov	r3, r1
  109816:	b4f0      	push	{r4, r5, r6, r7}
  109818:	f2c0 0211 	movt	r2, #17
  10981c:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  10981e:	f3c1 2607 	ubfx	r6, r1, #8, #8
    return reg << scr_shift[_scr_id(scr_signal)];
  109822:	a904      	add	r1, sp, #16
    const addr_t scr_base[] = {
  109824:	f102 070c 	add.w	r7, r2, #12
  109828:	4605      	mov	r5, r0
    return reg << scr_shift[_scr_id(scr_signal)];
  10982a:	eb01 0686 	add.w	r6, r1, r6, lsl #2
    const int scr_shift[] = {
  10982e:	ac01      	add	r4, sp, #4
  109830:	ca07      	ldmia	r2, {r0, r1, r2}
  109832:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  109836:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  10983a:	f856 cc0c 	ldr.w	r12, [r6, #-12]
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  10983e:	0c2f      	lsrs	r7, r5, #16
    const addr_t scr_base[] = {
  109840:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    uint32_t val = (uint32_t)(scr_signal >> 32) & 0xff;
  109844:	b2db      	uxtb	r3, r3
    return reg << scr_shift[_scr_id(scr_signal)];
  109846:	fa07 f70c 	lsl.w	r7, r7, r12
    return scr_base[scr_id] + reg;
  10984a:	f856 2c0c 	ldr.w	r2, [r6, #-12]
    uint32_t start_bit = _scr_start_bit(scr_signal);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));

    bool locked;

    switch (_scr_type(scr_signal)) {
  10984e:	3b01      	subs	r3, #1
    return (uint32_t)(scr_signal >> 8) & 0xff;
  109850:	f3c5 2507 	ubfx	r5, r5, #8, #8
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  109854:	58b8      	ldr	r0, [r7, r2]
  109856:	2b03      	cmp	r3, #3
  109858:	d81f      	bhi.n	10989a <scr_is_locked+0x8a>
  10985a:	e8df f003 	tbb	[r15, r3]
  10985e:	1102      	.short	0x1102
  109860:	060d      	.short	0x060d
        case R16W16:
            locked = start_bit >= 16;
            break;

        case RO:
            locked = true;
  109862:	2001      	movs	r0, #1
            locked = false;
            break;
    }

    return locked;
}
  109864:	b004      	add	sp, #16
  109866:	bcf0      	pop	{r4, r5, r6, r7}
  109868:	4770      	bx	r14
            locked = start_bit >= 16;
  10986a:	2d0f      	cmp	r5, #15
  10986c:	bf94      	ite	ls
  10986e:	2000      	movls	r0, #0
  109870:	2001      	movhi	r0, #1
}
  109872:	b004      	add	sp, #16
  109874:	bcf0      	pop	{r4, r5, r6, r7}
  109876:	4770      	bx	r14
            locked = val & (1ul << 31);
  109878:	0fc0      	lsrs	r0, r0, #31
}
  10987a:	b004      	add	sp, #16
  10987c:	bcf0      	pop	{r4, r5, r6, r7}
  10987e:	4770      	bx	r14
                locked = val & (1ul << (start_bit + 16));
  109880:	2301      	movs	r3, #1
            if (start_bit < 16)
  109882:	2d0f      	cmp	r5, #15
                locked = val & (1ul << (start_bit + 16));
  109884:	bf98      	it	ls
  109886:	3510      	addls	r5, #16
                locked = val & (1ul << start_bit);
  109888:	fa03 f505 	lsl.w	r5, r3, r5
  10988c:	4205      	tst	r5, r0
  10988e:	bf14      	ite	ne
  109890:	4618      	movne	r0, r3
  109892:	2000      	moveq	r0, #0
}
  109894:	b004      	add	sp, #16
  109896:	bcf0      	pop	{r4, r5, r6, r7}
  109898:	4770      	bx	r14
            locked = false;
  10989a:	2000      	movs	r0, #0
}
  10989c:	b004      	add	sp, #16
  10989e:	bcf0      	pop	{r4, r5, r6, r7}
  1098a0:	4770      	bx	r14
  1098a2:	bf00      	nop

001098a4 <scr_set>:
{
  1098a4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1098a8:	468a      	mov	r10, r1
    const int scr_shift[] = {
  1098aa:	f649 6164 	movw	r1, #40548	; 0x9e64
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  1098ae:	f3ca 2607 	ubfx	r6, r10, #8, #8
  1098b2:	b085      	sub	sp, #20
    const int scr_shift[] = {
  1098b4:	f2c0 0111 	movt	r1, #17
    return reg << scr_shift[_scr_id(scr_signal)];
  1098b8:	00b6      	lsls	r6, r6, #2
  1098ba:	ab04      	add	r3, sp, #16
  1098bc:	4433      	add	r3, r6
  1098be:	4605      	mov	r5, r0
    const addr_t scr_base[] = {
  1098c0:	f101 070c 	add.w	r7, r1, #12
  1098c4:	4691      	mov	r9, r2
    const int scr_shift[] = {
  1098c6:	ac01      	add	r4, sp, #4
  1098c8:	c907      	ldmia	r1, {r0, r1, r2}
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  1098ca:	ea4f 4815 	mov.w	r8, r5, lsr #16
    const int scr_shift[] = {
  1098ce:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  1098d2:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1098d6:	f853 cc0c 	ldr.w	r12, [r3, #-12]
    const addr_t scr_base[] = {
  1098da:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1098de:	fa08 f80c 	lsl.w	r8, r8, r12
    return scr_base[scr_id] + reg;
  1098e2:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  1098e6:	f858 b003 	ldr.w	r11, [r8, r3]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1098ea:	f3ef 8300 	mrs	r3, CPSR
  1098ee:	061b      	lsls	r3, r3, #24
  1098f0:	d529      	bpl.n	109946 <scr_set+0xa2>
    if (!scr_is_locked(scr_signal)) {
  1098f2:	4628      	mov	r0, r5
  1098f4:	4651      	mov	r1, r10
  1098f6:	f7ff ff8b 	bl	109810 <scr_is_locked>
    spin_lock_saved_state_t state = 0;
  1098fa:	4684      	mov	r12, r0
  1098fc:	bb50      	cbnz	r0, 109954 <scr_set+0xb0>
    return (uint32_t)scr_signal & 0xff;
  1098fe:	b2ea      	uxtb	r2, r5
        val &= ~(BIT_MASK(_scr_width(scr_signal)) << start_bit);
  109900:	2a1f      	cmp	r2, #31
  109902:	bf94      	ite	ls
  109904:	2301      	movls	r3, #1
  109906:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
    return (uint32_t)(scr_signal >> 8) & 0xff;
  10990a:	f3c5 2507 	ubfx	r5, r5, #8, #8
  10990e:	bf9c      	itt	ls
  109910:	4093      	lslls	r3, r2
  109912:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
    return scr_base[scr_id] + reg;
  109916:	aa04      	add	r2, sp, #16
  109918:	40ab      	lsls	r3, r5
  10991a:	4416      	add	r6, r2
  10991c:	ea2b 0b03 	bic.w	r11, r11, r3
    const addr_t scr_base[] = {
  109920:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
        val |= value << start_bit;
  109924:	fa09 f905 	lsl.w	r9, r9, r5
  109928:	ea49 050b 	orr.w	r5, r9, r11
  10992c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return scr_base[scr_id] + reg;
  109930:	f856 3c0c 	ldr.w	r3, [r6, #-12]
        ret = true;
  109934:	2001      	movs	r0, #1
}

static inline void
_scr_write_reg(enum scr_id scr_id, uint32_t reg, uint32_t val)
{
    writel(val, _ioaddr(_scr_reg_paddr(scr_id, reg)));
  109936:	f848 5003 	str.w	r5, [r8, r3]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10993a:	f1bc 0f00 	cmp.w	r12, #0
  10993e:	d118      	bne.n	109972 <scr_set+0xce>
}
  109940:	b005      	add	sp, #20
  109942:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    __asm__ volatile("cpsid i");
  109946:	b672      	cpsid	i
    if (!scr_is_locked(scr_signal)) {
  109948:	4628      	mov	r0, r5
  10994a:	4651      	mov	r1, r10
  10994c:	f7ff ff60 	bl	109810 <scr_is_locked>
  109950:	b160      	cbz	r0, 10996c <scr_set+0xc8>
    __asm__ volatile("cpsie i");
  109952:	b662      	cpsie	i
        dprintf(CRITICAL, "Cannot set SCR signal %llx\n", scr_signal);
  109954:	f649 607c 	movw	r0, #40572	; 0x9e7c
  109958:	462a      	mov	r2, r5
  10995a:	4653      	mov	r3, r10
  10995c:	f2c0 0011 	movt	r0, #17
  109960:	f00a ff50 	bl	114804 <printf>
  109964:	2000      	movs	r0, #0
}
  109966:	b005      	add	sp, #20
  109968:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10996c:	f04f 0c01 	mov.w	r12, #1
  109970:	e7c5      	b.n	1098fe <scr_set+0x5a>
  109972:	b662      	cpsie	i
        ret = true;
  109974:	2001      	movs	r0, #1
  109976:	e7e3      	b.n	109940 <scr_set+0x9c>

00109978 <timer_drv_cntr_set>:
 ** \param [in] val        Set value for sub counter.
 *****************************************************************************/
void timer_drv_cntr_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                        uint32_t val)
{
    if (val == 0) {
  109978:	b94a      	cbnz	r2, 10998e <timer_drv_cntr_set+0x16>
    timer->cnt_config |= (1 << sub_timer);
  10997a:	6a42      	ldr	r2, [r0, #36]	; 0x24
  10997c:	2301      	movs	r3, #1
  10997e:	fa03 f101 	lsl.w	r1, r3, r1
  109982:	430a      	orrs	r2, r1
  109984:	6242      	str	r2, [r0, #36]	; 0x24
        while (timer->cnt_config & (1 << sub_timer));
  109986:	6a43      	ldr	r3, [r0, #36]	; 0x24
  109988:	4219      	tst	r1, r3
  10998a:	d1fc      	bne.n	109986 <timer_drv_cntr_set+0xe>
  10998c:	4770      	bx	r14
        timer_drv_cntr_reset(timer, sub_timer, true);
    }
    else {
        if (sub_timer == TIMER_DRV_G0) {
  10998e:	b161      	cbz	r1, 1099aa <timer_drv_cntr_set+0x32>
            timer->cnt_g0_init = val;
        }
        else if (sub_timer == TIMER_DRV_G1) {
  109990:	2901      	cmp	r1, #1
  109992:	d00d      	beq.n	1099b0 <timer_drv_cntr_set+0x38>
            timer->cnt_g1_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_A) {
  109994:	2902      	cmp	r1, #2
  109996:	d00e      	beq.n	1099b6 <timer_drv_cntr_set+0x3e>
            timer->cnt_local_a_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_B) {
  109998:	2903      	cmp	r1, #3
  10999a:	d00f      	beq.n	1099bc <timer_drv_cntr_set+0x44>
            timer->cnt_local_b_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_C) {
  10999c:	2904      	cmp	r1, #4
  10999e:	d010      	beq.n	1099c2 <timer_drv_cntr_set+0x4a>
            timer->cnt_local_c_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_D) {
  1099a0:	2905      	cmp	r1, #5
            timer->cnt_local_d_init = val;
  1099a2:	bf08      	it	eq
  1099a4:	f8c0 20c4 	streq.w	r2, [r0, #196]	; 0xc4
        }
    }
}
  1099a8:	4770      	bx	r14
            timer->cnt_g0_init = val;
  1099aa:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
  1099ae:	4770      	bx	r14
            timer->cnt_g1_init = val;
  1099b0:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
  1099b4:	4770      	bx	r14
            timer->cnt_local_a_init = val;
  1099b6:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
  1099ba:	4770      	bx	r14
            timer->cnt_local_b_init = val;
  1099bc:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
  1099c0:	4770      	bx	r14
            timer->cnt_local_c_init = val;
  1099c2:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  1099c6:	4770      	bx	r14

001099c8 <timer_drv_cntr_get>:
 *****************************************************************************/
uint32_t timer_drv_cntr_get(sdrv_timer_t *timer, timer_drv_sub_t sub_timer)
{
    uint32_t val = 0;

    if (sub_timer == TIMER_DRV_G0) {
  1099c8:	b161      	cbz	r1, 1099e4 <timer_drv_cntr_get+0x1c>
        val = timer->cnt_g0;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  1099ca:	2901      	cmp	r1, #1
  1099cc:	d00c      	beq.n	1099e8 <timer_drv_cntr_get+0x20>
        val = timer->cnt_g1;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  1099ce:	2902      	cmp	r1, #2
  1099d0:	d00e      	beq.n	1099f0 <timer_drv_cntr_get+0x28>
        val = timer->cnt_local_a;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  1099d2:	2903      	cmp	r1, #3
  1099d4:	d00a      	beq.n	1099ec <timer_drv_cntr_get+0x24>
        val = timer->cnt_local_b;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  1099d6:	2904      	cmp	r1, #4
  1099d8:	d00c      	beq.n	1099f4 <timer_drv_cntr_get+0x2c>
        val = timer->cnt_local_c;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  1099da:	2905      	cmp	r1, #5
        val = timer->cnt_local_d;
  1099dc:	bf0c      	ite	eq
  1099de:	6d40      	ldreq	r0, [r0, #84]	; 0x54
    uint32_t val = 0;
  1099e0:	2000      	movne	r0, #0
    }

    return val;
}
  1099e2:	4770      	bx	r14
        val = timer->cnt_g0;
  1099e4:	6c00      	ldr	r0, [r0, #64]	; 0x40
  1099e6:	4770      	bx	r14
        val = timer->cnt_g1;
  1099e8:	6c40      	ldr	r0, [r0, #68]	; 0x44
  1099ea:	4770      	bx	r14
        val = timer->cnt_local_b;
  1099ec:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  1099ee:	4770      	bx	r14
        val = timer->cnt_local_a;
  1099f0:	6c80      	ldr	r0, [r0, #72]	; 0x48
  1099f2:	4770      	bx	r14
        val = timer->cnt_local_c;
  1099f4:	6d00      	ldr	r0, [r0, #80]	; 0x50
  1099f6:	4770      	bx	r14

001099f8 <timer_drv_ovf_set>:
 ** \param [in] val        Set sub counter overflow value.
 *****************************************************************************/
void timer_drv_ovf_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                       uint32_t val)
{
    if (sub_timer == TIMER_DRV_G0) {
  1099f8:	b159      	cbz	r1, 109a12 <timer_drv_ovf_set+0x1a>
        timer->cnt_g0_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  1099fa:	2901      	cmp	r1, #1
  1099fc:	d00b      	beq.n	109a16 <timer_drv_ovf_set+0x1e>
        timer->cnt_g1_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  1099fe:	2902      	cmp	r1, #2
  109a00:	d00d      	beq.n	109a1e <timer_drv_ovf_set+0x26>
        timer->cnt_local_a_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  109a02:	2903      	cmp	r1, #3
  109a04:	d009      	beq.n	109a1a <timer_drv_ovf_set+0x22>
        timer->cnt_local_b_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  109a06:	2904      	cmp	r1, #4
  109a08:	d00b      	beq.n	109a22 <timer_drv_ovf_set+0x2a>
        timer->cnt_local_c_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  109a0a:	2905      	cmp	r1, #5
        timer->cnt_local_d_ovf = val;
  109a0c:	bf08      	it	eq
  109a0e:	63c2      	streq	r2, [r0, #60]	; 0x3c
    }
}
  109a10:	4770      	bx	r14
        timer->cnt_g0_ovf = val;
  109a12:	6282      	str	r2, [r0, #40]	; 0x28
  109a14:	4770      	bx	r14
        timer->cnt_g1_ovf = val;
  109a16:	62c2      	str	r2, [r0, #44]	; 0x2c
  109a18:	4770      	bx	r14
        timer->cnt_local_b_ovf = val;
  109a1a:	6342      	str	r2, [r0, #52]	; 0x34
  109a1c:	4770      	bx	r14
        timer->cnt_local_a_ovf = val;
  109a1e:	6302      	str	r2, [r0, #48]	; 0x30
  109a20:	4770      	bx	r14
        timer->cnt_local_c_ovf = val;
  109a22:	6382      	str	r2, [r0, #56]	; 0x38
  109a24:	4770      	bx	r14
  109a26:	bf00      	nop

00109a28 <timer_drv_cascade_set>:
 ** \param [in] cascade    G1 cascaded G0 or not.
 *****************************************************************************/
void timer_drv_cascade_set(sdrv_timer_t *timer, bool cascade)
{
    if (cascade) {
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  109a28:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if (cascade) {
  109a2a:	b919      	cbnz	r1, 109a34 <timer_drv_cascade_set+0xc>
    }
    else {
        timer->cnt_config &= (~BM_CNT_CONFIG_CASCADE_MODE);
  109a2c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  109a30:	6243      	str	r3, [r0, #36]	; 0x24
    }
}
  109a32:	4770      	bx	r14
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  109a34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  109a38:	6243      	str	r3, [r0, #36]	; 0x24
  109a3a:	4770      	bx	r14

00109a3c <timer_drv_clk_init>:
 **                                     11 - Low power clock, typically from low speed on chip RCOSC
 *****************************************************************************/
void timer_drv_clk_init(sdrv_timer_t *timer, uint32_t clk_sel,
                        uint32_t clk_div)
{
    u32 value = timer->tim_clk_config;
  109a3c:	6a03      	ldr	r3, [r0, #32]

    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  109a3e:	0409      	lsls	r1, r1, #16
              FV_TIM_CLK_CONFIG_DIV_NUM(clk_div));
  109a40:	b292      	uxth	r2, r2
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  109a42:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
  109a46:	4311      	orrs	r1, r2
    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
  109a48:	0c9a      	lsrs	r2, r3, #18
  109a4a:	0492      	lsls	r2, r2, #18
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  109a4c:	4311      	orrs	r1, r2

    timer->tim_clk_config = value;
  109a4e:	6201      	str	r1, [r0, #32]
}
  109a50:	4770      	bx	r14
  109a52:	bf00      	nop

00109a54 <timer_drv_int_sta_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sta_en |= (1 << offset);
  109a54:	2301      	movs	r3, #1
  109a56:	fa03 f101 	lsl.w	r1, r3, r1
  109a5a:	6843      	ldr	r3, [r0, #4]
  109a5c:	4319      	orrs	r1, r3
  109a5e:	6041      	str	r1, [r0, #4]
}
  109a60:	4770      	bx	r14
  109a62:	bf00      	nop

00109a64 <timer_drv_int_sig_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sig_en |= (1 << offset);
  109a64:	2301      	movs	r3, #1
  109a66:	fa03 f101 	lsl.w	r1, r3, r1
  109a6a:	6883      	ldr	r3, [r0, #8]
  109a6c:	4319      	orrs	r1, r3
  109a6e:	6081      	str	r1, [r0, #8]
}
  109a70:	4770      	bx	r14
  109a72:	bf00      	nop

00109a74 <timer_drv_ovf_irq_handle>:
 ** \param [in] drv_context
 *****************************************************************************/
enum handler_return timer_drv_ovf_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  109a74:	6803      	ldr	r3, [r0, #0]
  109a76:	f413 7f80 	tst.w	r3, #256	; 0x100
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  109a7a:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  109a7c:	d006      	beq.n	109a8c <timer_drv_ovf_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  109a7e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  109a82:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  109a84:	b171      	cbz	r1, 109aa4 <timer_drv_ovf_irq_handle+0x30>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  109a86:	688b      	ldr	r3, [r1, #8]
  109a88:	b153      	cbz	r3, 109aa0 <timer_drv_ovf_irq_handle+0x2c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
            return drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1]();
  109a8a:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CNT_G1_OVF) {
  109a8c:	059b      	lsls	r3, r3, #22
  109a8e:	d507      	bpl.n	109aa0 <timer_drv_ovf_irq_handle+0x2c>
        timer->int_sta |= BM_INT_STA_CNT_G1_OVF;
  109a90:	6803      	ldr	r3, [r0, #0]
  109a92:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  109a96:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  109a98:	b181      	cbz	r1, 109abc <timer_drv_ovf_irq_handle+0x48>
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
  109a9a:	68cb      	ldr	r3, [r1, #12]
  109a9c:	2b00      	cmp	r3, #0
  109a9e:	d1f4      	bne.n	109a8a <timer_drv_ovf_irq_handle+0x16>
        }
    }

    return INT_RESCHEDULE;
}
  109aa0:	2001      	movs	r0, #1
  109aa2:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  109aa4:	6843      	ldr	r3, [r0, #4]
  109aa6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  109aaa:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109aac:	6883      	ldr	r3, [r0, #8]
  109aae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  109ab2:	6083      	str	r3, [r0, #8]
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  109ab4:	688b      	ldr	r3, [r1, #8]
  109ab6:	2b00      	cmp	r3, #0
  109ab8:	d1e7      	bne.n	109a8a <timer_drv_ovf_irq_handle+0x16>
  109aba:	e7f1      	b.n	109aa0 <timer_drv_ovf_irq_handle+0x2c>
    timer->int_sta_en &= ~(1 << offset);
  109abc:	6843      	ldr	r3, [r0, #4]
  109abe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  109ac2:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109ac4:	6883      	ldr	r3, [r0, #8]
  109ac6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  109aca:	6083      	str	r3, [r0, #8]
  109acc:	e7e5      	b.n	109a9a <timer_drv_ovf_irq_handle+0x26>
  109ace:	bf00      	nop

00109ad0 <timer_drv_func_irq_handle>:
 *****************************************************************************/
enum handler_return timer_drv_func_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    //Func A
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  109ad0:	6803      	ldr	r3, [r0, #0]
  109ad2:	f413 6f80 	tst.w	r3, #1024	; 0x400
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  109ad6:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  109ad8:	d006      	beq.n	109ae8 <timer_drv_func_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  109ada:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  109ade:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  109ae0:	b1e1      	cbz	r1, 109b1c <timer_drv_func_irq_handle+0x4c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109ae2:	690b      	ldr	r3, [r1, #16]
  109ae4:	b1c3      	cbz	r3, 109b18 <timer_drv_func_irq_handle+0x48>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D]();
  109ae6:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  109ae8:	f013 0f10 	tst.w	r3, #16
        timer->int_sta |= BM_INT_STA_CMP_A;
  109aec:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  109aee:	d005      	beq.n	109afc <timer_drv_func_irq_handle+0x2c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109af0:	6a0a      	ldr	r2, [r1, #32]
        timer->int_sta |= BM_INT_STA_CMP_A;
  109af2:	f043 0310 	orr.w	r3, r3, #16
  109af6:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109af8:	b172      	cbz	r2, 109b18 <timer_drv_func_irq_handle+0x48>
    }
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;

        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  109afa:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  109afc:	f013 0f01 	tst.w	r3, #1
        timer->int_sta |= BM_INT_STA_CPT_A;
  109b00:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  109b02:	d117      	bne.n	109b34 <timer_drv_func_irq_handle+0x64>
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  109b04:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  109b08:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  109b0a:	d01a      	beq.n	109b42 <timer_drv_func_irq_handle+0x72>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b0c:	6c0a      	ldr	r2, [r1, #64]	; 0x40
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  109b0e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  109b12:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b14:	2a00      	cmp	r2, #0
  109b16:	d1f0      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
        }
    }

    return INT_NO_RESCHEDULE;
}
  109b18:	2000      	movs	r0, #0
  109b1a:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  109b1c:	6843      	ldr	r3, [r0, #4]
  109b1e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  109b22:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109b24:	6883      	ldr	r3, [r0, #8]
  109b26:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  109b2a:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b2c:	690b      	ldr	r3, [r1, #16]
  109b2e:	2b00      	cmp	r3, #0
  109b30:	d1d9      	bne.n	109ae6 <timer_drv_func_irq_handle+0x16>
  109b32:	e7f1      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b34:	6b0a      	ldr	r2, [r1, #48]	; 0x30
        timer->int_sta |= BM_INT_STA_CPT_A;
  109b36:	f043 0301 	orr.w	r3, r3, #1
  109b3a:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b3c:	2a00      	cmp	r2, #0
  109b3e:	d0eb      	beq.n	109b18 <timer_drv_func_irq_handle+0x48>
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  109b40:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  109b42:	f413 3f80 	tst.w	r3, #65536	; 0x10000
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  109b46:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  109b48:	d10b      	bne.n	109b62 <timer_drv_func_irq_handle+0x92>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  109b4a:	f413 6f00 	tst.w	r3, #2048	; 0x800
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  109b4e:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  109b50:	d00e      	beq.n	109b70 <timer_drv_func_irq_handle+0xa0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  109b52:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  109b56:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  109b58:	b301      	cbz	r1, 109b9c <timer_drv_func_irq_handle+0xcc>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109b5a:	694b      	ldr	r3, [r1, #20]
  109b5c:	2b00      	cmp	r3, #0
  109b5e:	d1c2      	bne.n	109ae6 <timer_drv_func_irq_handle+0x16>
  109b60:	e7da      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b62:	6d0a      	ldr	r2, [r1, #80]	; 0x50
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  109b64:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  109b68:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  109b6a:	2a00      	cmp	r2, #0
  109b6c:	d1c5      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
  109b6e:	e7d3      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  109b70:	f013 0f20 	tst.w	r3, #32
        timer->int_sta |= BM_INT_STA_CMP_B;
  109b74:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  109b76:	d006      	beq.n	109b86 <timer_drv_func_irq_handle+0xb6>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109b78:	6a4a      	ldr	r2, [r1, #36]	; 0x24
        timer->int_sta |= BM_INT_STA_CMP_B;
  109b7a:	f043 0320 	orr.w	r3, r3, #32
  109b7e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109b80:	2a00      	cmp	r2, #0
  109b82:	d1ba      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
  109b84:	e7c8      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  109b86:	f013 0f02 	tst.w	r3, #2
        timer->int_sta |= BM_INT_STA_CPT_B;
  109b8a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  109b8c:	d00f      	beq.n	109bae <timer_drv_func_irq_handle+0xde>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109b8e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
        timer->int_sta |= BM_INT_STA_CPT_B;
  109b90:	f043 0302 	orr.w	r3, r3, #2
  109b94:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109b96:	2a00      	cmp	r2, #0
  109b98:	d1af      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
  109b9a:	e7bd      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  109b9c:	6843      	ldr	r3, [r0, #4]
  109b9e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  109ba2:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109ba4:	6883      	ldr	r3, [r0, #8]
  109ba6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  109baa:	6083      	str	r3, [r0, #8]
  109bac:	e7d5      	b.n	109b5a <timer_drv_func_irq_handle+0x8a>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  109bae:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  109bb2:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  109bb4:	d006      	beq.n	109bc4 <timer_drv_func_irq_handle+0xf4>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109bb6:	6c4a      	ldr	r2, [r1, #68]	; 0x44
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  109bb8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  109bbc:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109bbe:	2a00      	cmp	r2, #0
  109bc0:	d19b      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
  109bc2:	e7a9      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  109bc4:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  109bc8:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  109bca:	d006      	beq.n	109bda <timer_drv_func_irq_handle+0x10a>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109bcc:	6d4a      	ldr	r2, [r1, #84]	; 0x54
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  109bce:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  109bd2:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  109bd4:	2a00      	cmp	r2, #0
  109bd6:	d190      	bne.n	109afa <timer_drv_func_irq_handle+0x2a>
  109bd8:	e79e      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  109bda:	f413 5f80 	tst.w	r3, #4096	; 0x1000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  109bde:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  109be0:	d008      	beq.n	109bf4 <timer_drv_func_irq_handle+0x124>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  109be2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  109be6:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  109be8:	b1e1      	cbz	r1, 109c24 <timer_drv_func_irq_handle+0x154>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109bea:	698b      	ldr	r3, [r1, #24]
  109bec:	2b00      	cmp	r3, #0
  109bee:	f47f af7a 	bne.w	109ae6 <timer_drv_func_irq_handle+0x16>
  109bf2:	e791      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  109bf4:	f013 0f40 	tst.w	r3, #64	; 0x40
        timer->int_sta |= BM_INT_STA_CMP_C;
  109bf8:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  109bfa:	d007      	beq.n	109c0c <timer_drv_func_irq_handle+0x13c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109bfc:	6a8a      	ldr	r2, [r1, #40]	; 0x28
        timer->int_sta |= BM_INT_STA_CMP_C;
  109bfe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  109c02:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c04:	2a00      	cmp	r2, #0
  109c06:	f47f af78 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109c0a:	e785      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  109c0c:	f013 0f04 	tst.w	r3, #4
        timer->int_sta |= BM_INT_STA_CPT_C;
  109c10:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  109c12:	d010      	beq.n	109c36 <timer_drv_func_irq_handle+0x166>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c14:	6b8a      	ldr	r2, [r1, #56]	; 0x38
        timer->int_sta |= BM_INT_STA_CPT_C;
  109c16:	f043 0304 	orr.w	r3, r3, #4
  109c1a:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c1c:	2a00      	cmp	r2, #0
  109c1e:	f47f af6c 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109c22:	e779      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  109c24:	6843      	ldr	r3, [r0, #4]
  109c26:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  109c2a:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109c2c:	6883      	ldr	r3, [r0, #8]
  109c2e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  109c32:	6083      	str	r3, [r0, #8]
  109c34:	e7d9      	b.n	109bea <timer_drv_func_irq_handle+0x11a>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  109c36:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  109c3a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  109c3c:	d007      	beq.n	109c4e <timer_drv_func_irq_handle+0x17e>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c3e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  109c40:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  109c44:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c46:	2a00      	cmp	r2, #0
  109c48:	f47f af57 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109c4c:	e764      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  109c4e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  109c52:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  109c54:	d007      	beq.n	109c66 <timer_drv_func_irq_handle+0x196>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c56:	6d8a      	ldr	r2, [r1, #88]	; 0x58
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  109c58:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  109c5c:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  109c5e:	2a00      	cmp	r2, #0
  109c60:	f47f af4b 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109c64:	e758      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  109c66:	f413 5f00 	tst.w	r3, #8192	; 0x2000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  109c6a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  109c6c:	d010      	beq.n	109c90 <timer_drv_func_irq_handle+0x1c0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  109c6e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  109c72:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  109c74:	b939      	cbnz	r1, 109c86 <timer_drv_func_irq_handle+0x1b6>
    timer->int_sta_en &= ~(1 << offset);
  109c76:	6843      	ldr	r3, [r0, #4]
  109c78:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  109c7c:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  109c7e:	6883      	ldr	r3, [r0, #8]
  109c80:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  109c84:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109c86:	69cb      	ldr	r3, [r1, #28]
  109c88:	2b00      	cmp	r3, #0
  109c8a:	f47f af2c 	bne.w	109ae6 <timer_drv_func_irq_handle+0x16>
  109c8e:	e743      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  109c90:	f013 0f80 	tst.w	r3, #128	; 0x80
        timer->int_sta |= BM_INT_STA_CMP_D;
  109c94:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  109c96:	d007      	beq.n	109ca8 <timer_drv_func_irq_handle+0x1d8>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109c98:	6aca      	ldr	r2, [r1, #44]	; 0x2c
        timer->int_sta |= BM_INT_STA_CMP_D;
  109c9a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  109c9e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109ca0:	2a00      	cmp	r2, #0
  109ca2:	f47f af2a 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109ca6:	e737      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  109ca8:	f013 0f08 	tst.w	r3, #8
        timer->int_sta |= BM_INT_STA_CPT_D;
  109cac:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  109cae:	d007      	beq.n	109cc0 <timer_drv_func_irq_handle+0x1f0>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109cb0:	6bca      	ldr	r2, [r1, #60]	; 0x3c
        timer->int_sta |= BM_INT_STA_CPT_D;
  109cb2:	f043 0308 	orr.w	r3, r3, #8
  109cb6:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109cb8:	2a00      	cmp	r2, #0
  109cba:	f47f af1e 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109cbe:	e72b      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  109cc0:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  109cc4:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  109cc6:	d007      	beq.n	109cd8 <timer_drv_func_irq_handle+0x208>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109cc8:	6cca      	ldr	r2, [r1, #76]	; 0x4c
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  109cca:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  109cce:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109cd0:	2a00      	cmp	r2, #0
  109cd2:	f47f af12 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109cd6:	e71f      	b.n	109b18 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
  109cd8:	031b      	lsls	r3, r3, #12
  109cda:	f57f af1d 	bpl.w	109b18 <timer_drv_func_irq_handle+0x48>
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  109cde:	6803      	ldr	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109ce0:	6dca      	ldr	r2, [r1, #92]	; 0x5c
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  109ce2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  109ce6:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  109ce8:	2a00      	cmp	r2, #0
  109cea:	f47f af06 	bne.w	109afa <timer_drv_func_irq_handle+0x2a>
  109cee:	e713      	b.n	109b18 <timer_drv_func_irq_handle+0x48>

00109cf0 <uart_drv_init>:
 **
 ** \param [in] dev         Pointer to device information descriptor
 *****************************************************************************/
void uart_drv_init(DW_APB_UART_uart_TypeDef *dev,
                   uart_drv_context_t *context, uart_drv_cfg_t *cfg)
{
  109cf0:	b5f0      	push	{r4, r5, r6, r7, r14}
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  109cf2:	e9d2 3400 	ldrd	r3, r4, [r2]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109cf6:	f644 55d3 	movw	r5, #19923	; 0x4dd3
    dev->LCR.DLAB = 1;  //divisor latch access bit
  109cfa:	68c7      	ldr	r7, [r0, #12]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109cfc:	f2c1 0562 	movt	r5, #4194	; 0x1062
{
  109d00:	b083      	sub	sp, #12
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  109d02:	0124      	lsls	r4, r4, #4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  109d04:	f047 0780 	orr.w	r7, r7, #128	; 0x80
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  109d08:	fbb3 f6f4 	udiv	r6, r3, r4
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109d0c:	fba5 c404 	umull	r12, r4, r5, r4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  109d10:	60c7      	str	r7, [r0, #12]
    dev->DLL.DLL = divisor & 0xff;
  109d12:	6807      	ldr	r7, [r0, #0]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109d14:	09a4      	lsrs	r4, r4, #6
  109d16:	fbb3 f3f4 	udiv	r3, r3, r4
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  109d1a:	b2b4      	uxth	r4, r6
    dev->DLL.DLL = divisor & 0xff;
  109d1c:	b2f6      	uxtb	r6, r6
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109d1e:	ebc4 1c44 	rsb	r12, r4, r4, lsl #5
    dev->DLL.DLL = divisor & 0xff;
  109d22:	f366 0707 	bfi	r7, r6, #0, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109d26:	eb04 068c 	add.w	r6, r4, r12, lsl #2
    dev->DLL.DLL = divisor & 0xff;
  109d2a:	6007      	str	r7, [r0, #0]
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  109d2c:	0a24      	lsrs	r4, r4, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  109d2e:	eba3 03c6 	sub.w	r3, r3, r6, lsl #3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  109d32:	6846      	ldr	r6, [r0, #4]
    frac = frac *16/1000;
  109d34:	b29b      	uxth	r3, r3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  109d36:	f364 0607 	bfi	r6, r4, #0, #8
    frac = frac *16/1000;
  109d3a:	011b      	lsls	r3, r3, #4
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  109d3c:	6046      	str	r6, [r0, #4]
    frac = frac *16/1000;
  109d3e:	fba5 4303 	umull	r4, r3, r5, r3
    dev->DLF.DLF = frac;
  109d42:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
  109d46:	f3c3 1383 	ubfx	r3, r3, #6, #4
  109d4a:	f363 0403 	bfi	r4, r3, #0, #4
  109d4e:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
    dev->LCR.DLAB = 0;
  109d52:	68c3      	ldr	r3, [r0, #12]
  109d54:	f36f 13c7 	bfc	r3, #7, #1
  109d58:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.data_bits) {
  109d5a:	6893      	ldr	r3, [r2, #8]
  109d5c:	2b03      	cmp	r3, #3
  109d5e:	f200 8091 	bhi.w	109e84 <uart_drv_init+0x194>
            dev->LCR.DLS = cfg->port_cfg.data_bits;
  109d62:	68c4      	ldr	r4, [r0, #12]
  109d64:	f363 0401 	bfi	r4, r3, #0, #2
  109d68:	60c4      	str	r4, [r0, #12]
    switch (cfg->port_cfg.stop_bits) {
  109d6a:	68d3      	ldr	r3, [r2, #12]
  109d6c:	2b01      	cmp	r3, #1
  109d6e:	d06c      	beq.n	109e4a <uart_drv_init+0x15a>
  109d70:	d343      	bcc.n	109dfa <uart_drv_init+0x10a>
  109d72:	2b02      	cmp	r3, #2
  109d74:	f040 8097 	bne.w	109ea6 <uart_drv_init+0x1b6>
            if (dev->LCR.DLS == 0)
  109d78:	68c3      	ldr	r3, [r0, #12]
  109d7a:	079b      	lsls	r3, r3, #30
  109d7c:	f000 80b5 	beq.w	109eea <uart_drv_init+0x1fa>
            dev->LCR.STOP = 1;
  109d80:	68c3      	ldr	r3, [r0, #12]
  109d82:	f043 0304 	orr.w	r3, r3, #4
  109d86:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  109d88:	6913      	ldr	r3, [r2, #16]
  109d8a:	2b01      	cmp	r3, #1
  109d8c:	d03c      	beq.n	109e08 <uart_drv_init+0x118>
  109d8e:	d370      	bcc.n	109e72 <uart_drv_init+0x182>
  109d90:	2b02      	cmp	r3, #2
  109d92:	f040 8099 	bne.w	109ec8 <uart_drv_init+0x1d8>
            dev->LCR.PEN = 0;
  109d96:	68c3      	ldr	r3, [r0, #12]
  109d98:	f36f 03c3 	bfc	r3, #3, #1
  109d9c:	60c3      	str	r3, [r0, #12]
    if (cfg->port_cfg.loopback_enable) {
  109d9e:	7d13      	ldrb	r3, [r2, #20]
  109da0:	b11b      	cbz	r3, 109daa <uart_drv_init+0xba>
 ** \param [out]
 *****************************************************************************/
void uart_drv_loopback(DW_APB_UART_uart_TypeDef *dev, bool enable)
{
    if (enable) {
        dev->MCR.LOOPBACK = 1;
  109da2:	6903      	ldr	r3, [r0, #16]
  109da4:	f043 0310 	orr.w	r3, r3, #16
  109da8:	6103      	str	r3, [r0, #16]
    if (cfg->fifo_cfg.fifo_enable) {
  109daa:	7e13      	ldrb	r3, [r2, #24]
  109dac:	2b00      	cmp	r3, #0
  109dae:	d134      	bne.n	109e1a <uart_drv_init+0x12a>
        context->fcr_shadow.FIFOE = 0;
  109db0:	790a      	ldrb	r2, [r1, #4]
  109db2:	f363 0200 	bfi	r2, r3, #0, #1
  109db6:	710a      	strb	r2, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  109db8:	684a      	ldr	r2, [r1, #4]
  109dba:	6082      	str	r2, [r0, #8]
        context->fifo_enable = false;
  109dbc:	700b      	strb	r3, [r1, #0]
    context->tx_str_cbk = NULL;
  109dbe:	2300      	movs	r3, #0
  109dc0:	610b      	str	r3, [r1, #16]
    context->rx_str_cbk = NULL;
  109dc2:	e9c1 3302 	strd	r3, r3, [r1, #8]
    context->tx_shadow.len_rest = 0;
  109dc6:	e9c1 3305 	strd	r3, r3, [r1, #20]
    context->rx_shadow.len_rest = 0;
  109dca:	e9c1 3307 	strd	r3, r3, [r1, #28]
    dev->IER.ERBFI = 1;   //received data available interrupt
  109dce:	6842      	ldr	r2, [r0, #4]
  109dd0:	f042 0201 	orr.w	r2, r2, #1
  109dd4:	6042      	str	r2, [r0, #4]
        dev->IER.ETBEI = 0;
  109dd6:	6842      	ldr	r2, [r0, #4]
  109dd8:	f363 0241 	bfi	r2, r3, #1, #1
  109ddc:	6042      	str	r2, [r0, #4]
    dev->IER.ELSI = 1;      //receiver line status interrupt
  109dde:	6842      	ldr	r2, [r0, #4]
  109de0:	f042 0204 	orr.w	r2, r2, #4
  109de4:	6042      	str	r2, [r0, #4]
    dev->IER.EDSSI = 0;     //modem status interrupt
  109de6:	6842      	ldr	r2, [r0, #4]
  109de8:	f363 02c3 	bfi	r2, r3, #3, #1
  109dec:	6042      	str	r2, [r0, #4]
    dev->IER.PTIME = 0;     //programmable THRE interrupt mode
  109dee:	6842      	ldr	r2, [r0, #4]
  109df0:	f363 12c7 	bfi	r2, r3, #7, #1
  109df4:	6042      	str	r2, [r0, #4]
}
  109df6:	b003      	add	sp, #12
  109df8:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dev->LCR.STOP = 0;
  109dfa:	68c3      	ldr	r3, [r0, #12]
  109dfc:	f36f 0382 	bfc	r3, #2, #1
  109e00:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  109e02:	6913      	ldr	r3, [r2, #16]
  109e04:	2b01      	cmp	r3, #1
  109e06:	d1c2      	bne.n	109d8e <uart_drv_init+0x9e>
            dev->LCR.EPS = 1;
  109e08:	68c3      	ldr	r3, [r0, #12]
  109e0a:	f043 0310 	orr.w	r3, r3, #16
  109e0e:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  109e10:	68c3      	ldr	r3, [r0, #12]
  109e12:	f043 0308 	orr.w	r3, r3, #8
  109e16:	60c3      	str	r3, [r0, #12]
  109e18:	e7c1      	b.n	109d9e <uart_drv_init+0xae>
        context->fcr_shadow.RFIFOR = 1; //reset fifo
  109e1a:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  109e1c:	69d5      	ldr	r5, [r2, #28]
        context->fcr_shadow.TET =
  109e1e:	6a12      	ldr	r2, [r2, #32]
        context->fcr_shadow.XFIFOR = 1;
  109e20:	f043 0306 	orr.w	r3, r3, #6
        context->fifo_enable = true;
  109e24:	2401      	movs	r4, #1
        context->fcr_shadow.XFIFOR = 1;
  109e26:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  109e28:	684b      	ldr	r3, [r1, #4]
  109e2a:	6083      	str	r3, [r0, #8]
        context->fcr_shadow.RFIFOR = 0;
  109e2c:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  109e2e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
  109e32:	f365 1387 	bfi	r3, r5, #6, #2
        context->fcr_shadow.TET =
  109e36:	f362 1305 	bfi	r3, r2, #4, #2
        context->fcr_shadow.FIFOE = 1;
  109e3a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  109e3e:	4323      	orrs	r3, r4
  109e40:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  109e42:	684b      	ldr	r3, [r1, #4]
  109e44:	6083      	str	r3, [r0, #8]
        context->fifo_enable = true;
  109e46:	700c      	strb	r4, [r1, #0]
  109e48:	e7b9      	b.n	109dbe <uart_drv_init+0xce>
            if (dev->LCR.DLS != 0)
  109e4a:	68c3      	ldr	r3, [r0, #12]
  109e4c:	079c      	lsls	r4, r3, #30
  109e4e:	d097      	beq.n	109d80 <uart_drv_init+0x90>
                ASSERT(0);
  109e50:	f649 0384 	movw	r3, #39044	; 0x9884
  109e54:	f649 6298 	movw	r2, #40600	; 0x9e98
  109e58:	f647 4134 	movw	r1, #31796	; 0x7c34
  109e5c:	f2c0 0311 	movt	r3, #17
  109e60:	4670      	mov	r0, r14
  109e62:	f2c0 0211 	movt	r2, #17
  109e66:	9300      	str	r3, [sp, #0]
  109e68:	f2c0 0111 	movt	r1, #17
  109e6c:	2352      	movs	r3, #82	; 0x52
  109e6e:	f009 fc95 	bl	11379c <_panic>
            dev->LCR.EPS = 0;
  109e72:	68c3      	ldr	r3, [r0, #12]
  109e74:	f36f 1304 	bfc	r3, #4, #1
  109e78:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  109e7a:	68c3      	ldr	r3, [r0, #12]
  109e7c:	f043 0308 	orr.w	r3, r3, #8
  109e80:	60c3      	str	r3, [r0, #12]
  109e82:	e78c      	b.n	109d9e <uart_drv_init+0xae>
            ASSERT(0); /* no other bits*/
  109e84:	f649 0384 	movw	r3, #39044	; 0x9884
  109e88:	f649 6298 	movw	r2, #40600	; 0x9e98
  109e8c:	f647 4134 	movw	r1, #31796	; 0x7c34
  109e90:	f2c0 0311 	movt	r3, #17
  109e94:	4670      	mov	r0, r14
  109e96:	f2c0 0211 	movt	r2, #17
  109e9a:	9300      	str	r3, [sp, #0]
  109e9c:	f2c0 0111 	movt	r1, #17
  109ea0:	2346      	movs	r3, #70	; 0x46
  109ea2:	f009 fc7b 	bl	11379c <_panic>
            ASSERT(0);
  109ea6:	f649 0384 	movw	r3, #39044	; 0x9884
  109eaa:	f649 6298 	movw	r2, #40600	; 0x9e98
  109eae:	f647 4134 	movw	r1, #31796	; 0x7c34
  109eb2:	f2c0 0311 	movt	r3, #17
  109eb6:	4670      	mov	r0, r14
  109eb8:	f2c0 0211 	movt	r2, #17
  109ebc:	9300      	str	r3, [sp, #0]
  109ebe:	f2c0 0111 	movt	r1, #17
  109ec2:	235f      	movs	r3, #95	; 0x5f
  109ec4:	f009 fc6a 	bl	11379c <_panic>
            ASSERT(0);
  109ec8:	f649 0384 	movw	r3, #39044	; 0x9884
  109ecc:	f649 6298 	movw	r2, #40600	; 0x9e98
  109ed0:	f647 4134 	movw	r1, #31796	; 0x7c34
  109ed4:	f2c0 0311 	movt	r3, #17
  109ed8:	4670      	mov	r0, r14
  109eda:	f2c0 0211 	movt	r2, #17
  109ede:	9300      	str	r3, [sp, #0]
  109ee0:	f2c0 0111 	movt	r1, #17
  109ee4:	2374      	movs	r3, #116	; 0x74
  109ee6:	f009 fc59 	bl	11379c <_panic>
                ASSERT(0);
  109eea:	f649 0384 	movw	r3, #39044	; 0x9884
  109eee:	f649 6298 	movw	r2, #40600	; 0x9e98
  109ef2:	f647 4134 	movw	r1, #31796	; 0x7c34
  109ef6:	f2c0 0311 	movt	r3, #17
  109efa:	4670      	mov	r0, r14
  109efc:	f2c0 0211 	movt	r2, #17
  109f00:	9300      	str	r3, [sp, #0]
  109f02:	f2c0 0111 	movt	r1, #17
  109f06:	2359      	movs	r3, #89	; 0x59
  109f08:	f009 fc48 	bl	11379c <_panic>

00109f0c <uart_drv_putc>:
        if (context->fifo_enable) {
  109f0c:	780b      	ldrb	r3, [r1, #0]
  109f0e:	b123      	cbz	r3, 109f1a <uart_drv_putc+0xe>
            while (dev->USR.TFNF != 1); //wait transmit fifo is not full
  109f10:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  109f12:	0799      	lsls	r1, r3, #30
  109f14:	d5fc      	bpl.n	109f10 <uart_drv_putc+0x4>
        writeb(data, &dev->THR);
  109f16:	7002      	strb	r2, [r0, #0]
}
  109f18:	4770      	bx	r14
            while (dev->LSR.THRE != 1); //wait transmit holding register empty
  109f1a:	6943      	ldr	r3, [r0, #20]
  109f1c:	069b      	lsls	r3, r3, #26
  109f1e:	d4fa      	bmi.n	109f16 <uart_drv_putc+0xa>
  109f20:	6943      	ldr	r3, [r0, #20]
  109f22:	069b      	lsls	r3, r3, #26
  109f24:	d5f9      	bpl.n	109f1a <uart_drv_putc+0xe>
  109f26:	e7f6      	b.n	109f16 <uart_drv_putc+0xa>

00109f28 <uart_drv_int_cbk_register>:
void uart_drv_int_cbk_register(uart_drv_context_t *context,
                               uart_drv_int_src_t int_src,
                               uart_drv_int_callback cbk)

{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  109f28:	b129      	cbz	r1, 109f36 <uart_drv_int_cbk_register+0xe>
        context->rx_char_cbk = cbk;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  109f2a:	2901      	cmp	r1, #1
  109f2c:	d005      	beq.n	109f3a <uart_drv_int_cbk_register+0x12>
        context->rx_str_cbk = cbk;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  109f2e:	2902      	cmp	r1, #2
        context->tx_str_cbk = cbk;
  109f30:	bf08      	it	eq
  109f32:	6102      	streq	r2, [r0, #16]
    }
}
  109f34:	4770      	bx	r14
        context->rx_char_cbk = cbk;
  109f36:	6082      	str	r2, [r0, #8]
  109f38:	4770      	bx	r14
        context->rx_str_cbk = cbk;
  109f3a:	60c2      	str	r2, [r0, #12]
  109f3c:	4770      	bx	r14
  109f3e:	bf00      	nop

00109f40 <uart_drv_int_src_enable>:

void uart_drv_int_src_enable(DW_APB_UART_uart_TypeDef *dev,
                             uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  109f40:	b141      	cbz	r1, 109f54 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  109f42:	2901      	cmp	r1, #1
  109f44:	d006      	beq.n	109f54 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  109f46:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 1;
  109f48:	bf02      	ittt	eq
  109f4a:	6843      	ldreq	r3, [r0, #4]
  109f4c:	f043 0302 	orreq.w	r3, r3, #2
  109f50:	6043      	streq	r3, [r0, #4]
    }
}
  109f52:	4770      	bx	r14
        dev->IER.ERBFI = 1;
  109f54:	6843      	ldr	r3, [r0, #4]
  109f56:	f043 0301 	orr.w	r3, r3, #1
  109f5a:	6043      	str	r3, [r0, #4]
  109f5c:	4770      	bx	r14
  109f5e:	bf00      	nop

00109f60 <uart_drv_int_src_disable>:

void uart_drv_int_src_disable(DW_APB_UART_uart_TypeDef *dev,
                              uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  109f60:	b141      	cbz	r1, 109f74 <uart_drv_int_src_disable+0x14>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  109f62:	2901      	cmp	r1, #1
  109f64:	d00b      	beq.n	109f7e <uart_drv_int_src_disable+0x1e>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  109f66:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 0;
  109f68:	bf02      	ittt	eq
  109f6a:	6843      	ldreq	r3, [r0, #4]
  109f6c:	f36f 0341 	bfceq	r3, #1, #1
  109f70:	6043      	streq	r3, [r0, #4]
    }
}
  109f72:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  109f74:	6843      	ldr	r3, [r0, #4]
  109f76:	f361 0300 	bfi	r3, r1, #0, #1
  109f7a:	6043      	str	r3, [r0, #4]
  109f7c:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  109f7e:	6843      	ldr	r3, [r0, #4]
  109f80:	f36f 0300 	bfc	r3, #0, #1
  109f84:	6043      	str	r3, [r0, #4]
  109f86:	4770      	bx	r14

00109f88 <uart_drv_irq_handle>:
enum handler_return uart_drv_irq_handle(DW_APB_UART_uart_TypeDef *dev,
                                        uart_drv_context_t *context)
{
    bool resched = true;
    char data = 0;
    IIR_Type IIR = dev->IIR;        //interrupt identification register
  109f88:	6883      	ldr	r3, [r0, #8]
{
  109f8a:	b570      	push	{r4, r5, r6, r14}
  109f8c:	460c      	mov	r4, r1
    LSR_Type LSR = dev->LSR;        //line status register

    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  109f8e:	b2db      	uxtb	r3, r3
{
  109f90:	4605      	mov	r5, r0
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  109f92:	f003 020d 	and.w	r2, r3, #13
    LSR_Type LSR = dev->LSR;        //line status register
  109f96:	6941      	ldr	r1, [r0, #20]
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  109f98:	2a04      	cmp	r2, #4
  109f9a:	d13a      	bne.n	10a012 <uart_drv_irq_handle+0x8a>
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
        //rx irq
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
                || LSR.ADDR_RCVD == UART_DRV_LSR_RX_ADDR_IND) {
  109f9c:	f240 1301 	movw	r3, #257	; 0x101
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
  109fa0:	420b      	tst	r3, r1
  109fa2:	d034      	beq.n	10a00e <uart_drv_irq_handle+0x86>
            if (context->fifo_enable) {
  109fa4:	7826      	ldrb	r6, [r4, #0]
  109fa6:	68e2      	ldr	r2, [r4, #12]
  109fa8:	2e00      	cmp	r6, #0
  109faa:	d163      	bne.n	10a074 <uart_drv_irq_handle+0xec>
                    }
                }
                else
#endif
                {
                    data = dev->RBR.RBR8;
  109fac:	6800      	ldr	r0, [r0, #0]
  109fae:	b2c0      	uxtb	r0, r0
                }

                //asynchronous receive
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  109fb0:	2a00      	cmp	r2, #0
  109fb2:	d079      	beq.n	10a0a8 <uart_drv_irq_handle+0x120>
  109fb4:	6a23      	ldr	r3, [r4, #32]
  109fb6:	2b00      	cmp	r3, #0
  109fb8:	d076      	beq.n	10a0a8 <uart_drv_irq_handle+0x120>
    *context->rx_shadow.rx_ptr = data;
  109fba:	69e3      	ldr	r3, [r4, #28]
  109fbc:	7018      	strb	r0, [r3, #0]
    context->rx_shadow.len_rest -= 1;
  109fbe:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  109fc2:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  109fc4:	3b01      	subs	r3, #1
  109fc6:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  109fca:	b96b      	cbnz	r3, 109fe8 <uart_drv_irq_handle+0x60>
        dev->IER.ERBFI = 0;
  109fcc:	686a      	ldr	r2, [r5, #4]
  109fce:	f363 0200 	bfi	r2, r3, #0, #1
  109fd2:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  109fd4:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  109fd6:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  109fd8:	f363 1205 	bfi	r2, r3, #4, #2
  109fdc:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  109fde:	6862      	ldr	r2, [r4, #4]
  109fe0:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  109fe2:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  109fe4:	4788      	blx	r1
  109fe6:	6a23      	ldr	r3, [r4, #32]
                    uart_drv_async_rx_char(dev, context, data);

                    if (context->rx_shadow.len_rest) {
  109fe8:	fab3 f083 	clz	r0, r3
  109fec:	0940      	lsrs	r0, r0, #5
            }
        }
    }

    return resched ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
}
  109fee:	bd70      	pop	{r4, r5, r6, r15}
            if (context->tx_shadow.len_rest && dev->LSR.THRE) {
  109ff0:	2b00      	cmp	r3, #0
  109ff2:	d065      	beq.n	10a0c0 <uart_drv_irq_handle+0x138>
  109ff4:	6943      	ldr	r3, [r0, #20]
  109ff6:	069b      	lsls	r3, r3, #26
  109ff8:	d509      	bpl.n	10a00e <uart_drv_irq_handle+0x86>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  109ffa:	6963      	ldr	r3, [r4, #20]
  109ffc:	1c5a      	adds	r2, r3, #1
  109ffe:	6162      	str	r2, [r4, #20]
  10a000:	781b      	ldrb	r3, [r3, #0]
  10a002:	7003      	strb	r3, [r0, #0]
                context->tx_shadow.len_rest -= 1;
  10a004:	69a3      	ldr	r3, [r4, #24]
  10a006:	3b01      	subs	r3, #1
  10a008:	61a3      	str	r3, [r4, #24]
        if (context->tx_shadow.len_rest == 0) {
  10a00a:	2b00      	cmp	r3, #0
  10a00c:	d058      	beq.n	10a0c0 <uart_drv_irq_handle+0x138>
  10a00e:	2001      	movs	r0, #1
}
  10a010:	bd70      	pop	{r4, r5, r6, r15}
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
  10a012:	f003 030f 	and.w	r3, r3, #15
    else if (IIR.IID == UART_DRV_IID_RX_CHAR_TIMEOUT) {
  10a016:	2b0c      	cmp	r3, #12
  10a018:	d043      	beq.n	10a0a2 <uart_drv_irq_handle+0x11a>
    else if (IIR.IID == UART_DRV_IID_THR_EMPTY) {
  10a01a:	2b02      	cmp	r3, #2
  10a01c:	d1f7      	bne.n	10a00e <uart_drv_irq_handle+0x86>
  10a01e:	69a3      	ldr	r3, [r4, #24]
        if (context->fifo_enable) {
  10a020:	7822      	ldrb	r2, [r4, #0]
  10a022:	2a00      	cmp	r2, #0
  10a024:	d0e4      	beq.n	109ff0 <uart_drv_irq_handle+0x68>
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  10a026:	b953      	cbnz	r3, 10a03e <uart_drv_irq_handle+0xb6>
  10a028:	e04a      	b.n	10a0c0 <uart_drv_irq_handle+0x138>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  10a02a:	6963      	ldr	r3, [r4, #20]
  10a02c:	1c5a      	adds	r2, r3, #1
  10a02e:	6162      	str	r2, [r4, #20]
  10a030:	781b      	ldrb	r3, [r3, #0]
  10a032:	702b      	strb	r3, [r5, #0]
                context->tx_shadow.len_rest -= 1;
  10a034:	69a3      	ldr	r3, [r4, #24]
  10a036:	3b01      	subs	r3, #1
  10a038:	61a3      	str	r3, [r4, #24]
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  10a03a:	2b00      	cmp	r3, #0
  10a03c:	d040      	beq.n	10a0c0 <uart_drv_irq_handle+0x138>
  10a03e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  10a040:	079a      	lsls	r2, r3, #30
  10a042:	d5e4      	bpl.n	10a00e <uart_drv_irq_handle+0x86>
  10a044:	e7f1      	b.n	10a02a <uart_drv_irq_handle+0xa2>
    *context->rx_shadow.rx_ptr = data;
  10a046:	69e2      	ldr	r2, [r4, #28]
  10a048:	7013      	strb	r3, [r2, #0]
    context->rx_shadow.len_rest -= 1;
  10a04a:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  10a04e:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  10a050:	3b01      	subs	r3, #1
  10a052:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  10a056:	b963      	cbnz	r3, 10a072 <uart_drv_irq_handle+0xea>
        dev->IER.ERBFI = 0;
  10a058:	686a      	ldr	r2, [r5, #4]
  10a05a:	f363 0200 	bfi	r2, r3, #0, #1
  10a05e:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  10a060:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  10a062:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  10a064:	f363 1205 	bfi	r2, r3, #4, #2
  10a068:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  10a06a:	6862      	ldr	r2, [r4, #4]
  10a06c:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  10a06e:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  10a070:	4788      	blx	r1
  10a072:	68e2      	ldr	r2, [r4, #12]
                while (dev->USR.RFNE) {
  10a074:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  10a076:	0719      	lsls	r1, r3, #28
  10a078:	d50e      	bpl.n	10a098 <uart_drv_irq_handle+0x110>
                        data = dev->RBR.RBR8;
  10a07a:	682b      	ldr	r3, [r5, #0]
  10a07c:	b2db      	uxtb	r3, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  10a07e:	b11a      	cbz	r2, 10a088 <uart_drv_irq_handle+0x100>
  10a080:	6a21      	ldr	r1, [r4, #32]
        context->rx_str_cbk(data);
  10a082:	4618      	mov	r0, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  10a084:	2900      	cmp	r1, #0
  10a086:	d1de      	bne.n	10a046 <uart_drv_irq_handle+0xbe>
                             || (context->rx_char_cbk(data) != 1)) {
  10a088:	4618      	mov	r0, r3
                    else if ((context->rx_char_cbk == NULL)
  10a08a:	68a3      	ldr	r3, [r4, #8]
  10a08c:	b31b      	cbz	r3, 10a0d6 <uart_drv_irq_handle+0x14e>
                             || (context->rx_char_cbk(data) != 1)) {
  10a08e:	4798      	blx	r3
  10a090:	2801      	cmp	r0, #1
  10a092:	d0ee      	beq.n	10a072 <uart_drv_irq_handle+0xea>
  10a094:	68e2      	ldr	r2, [r4, #12]
                        resched = false;
  10a096:	2600      	movs	r6, #0
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  10a098:	b182      	cbz	r2, 10a0bc <uart_drv_irq_handle+0x134>
  10a09a:	6a23      	ldr	r3, [r4, #32]
  10a09c:	b173      	cbz	r3, 10a0bc <uart_drv_irq_handle+0x134>
  10a09e:	2000      	movs	r0, #0
}
  10a0a0:	bd70      	pop	{r4, r5, r6, r15}
        data = dev->RBR.RBR8;
  10a0a2:	6803      	ldr	r3, [r0, #0]
  10a0a4:	2001      	movs	r0, #1
}
  10a0a6:	bd70      	pop	{r4, r5, r6, r15}
                else if ((context->rx_char_cbk == NULL)
  10a0a8:	68a3      	ldr	r3, [r4, #8]
  10a0aa:	2b00      	cmp	r3, #0
  10a0ac:	d0f7      	beq.n	10a09e <uart_drv_irq_handle+0x116>
                         || (context->rx_char_cbk(data) != 1)) {
  10a0ae:	4798      	blx	r3
  10a0b0:	f1a0 0001 	sub.w	r0, r0, #1
  10a0b4:	fab0 f080 	clz	r0, r0
  10a0b8:	0940      	lsrs	r0, r0, #5
}
  10a0ba:	bd70      	pop	{r4, r5, r6, r15}
  10a0bc:	4630      	mov	r0, r6
  10a0be:	bd70      	pop	{r4, r5, r6, r15}
        dev->IER.ETBEI = 0;
  10a0c0:	686b      	ldr	r3, [r5, #4]
  10a0c2:	f36f 0341 	bfc	r3, #1, #1
  10a0c6:	606b      	str	r3, [r5, #4]
            if (context->tx_str_cbk) {
  10a0c8:	6923      	ldr	r3, [r4, #16]
  10a0ca:	2b00      	cmp	r3, #0
  10a0cc:	d09f      	beq.n	10a00e <uart_drv_irq_handle+0x86>
                context->tx_str_cbk(true);
  10a0ce:	2001      	movs	r0, #1
  10a0d0:	4798      	blx	r3
  10a0d2:	2001      	movs	r0, #1
}
  10a0d4:	bd70      	pop	{r4, r5, r6, r15}
                        resched = false;
  10a0d6:	461e      	mov	r6, r3
  10a0d8:	e7de      	b.n	10a098 <uart_drv_irq_handle+0x110>
  10a0da:	bf00      	nop
  10a0dc:	0000      	movs	r0, r0
	...

0010a0e0 <sdm_display_change_clk>:
{
    uint32_t h_total = 0;
    uint32_t v_total = 0;
    uint8_t  dual_mode = 0;

    struct sdm_panel *panel = handle->panels[handle->found_panel];
  10a0e0:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
  10a0e2:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}

    dual_mode = (handle->res->lvds_mode == LVDS_MODE_DUAL) ? 2 : 1;
  10a0e6:	f8d0 a008 	ldr.w	r10, [r0, #8]
    struct sdm_panel *panel = handle->panels[handle->found_panel];
  10a0ea:	eb00 0383 	add.w	r3, r0, r3, lsl #2
{
  10a0ee:	4605      	mov	r5, r0
    struct sdm_panel *panel = handle->panels[handle->found_panel];
  10a0f0:	695e      	ldr	r6, [r3, #20]
    dual_mode = (handle->res->lvds_mode == LVDS_MODE_DUAL) ? 2 : 1;
  10a0f2:	f8da 4094 	ldr.w	r4, [r10, #148]	; 0x94

    h_total = panel->display_timing->hactive + panel->display_timing->hback_porch +
  10a0f6:	6a37      	ldr	r7, [r6, #32]
    dual_mode = (handle->res->lvds_mode == LVDS_MODE_DUAL) ? 2 : 1;
  10a0f8:	2c02      	cmp	r4, #2
  10a0fa:	bf14      	ite	ne
  10a0fc:	f04f 0c01 	movne.w	r12, #1
  10a100:	f04f 0c02 	moveq.w	r12, #2
    h_total = panel->display_timing->hactive + panel->display_timing->hback_porch +
  10a104:	68fb      	ldr	r3, [r7, #12]
  10a106:	687c      	ldr	r4, [r7, #4]
              panel->display_timing->hfront_porch + panel->display_timing->hsync_len;
    v_total = panel->display_timing->vactive + panel->display_timing->vback_porch +
  10a108:	697a      	ldr	r2, [r7, #20]
    h_total = panel->display_timing->hactive + panel->display_timing->hback_porch +
  10a10a:	f8d7 9010 	ldr.w	r9, [r7, #16]
  10a10e:	441c      	add	r4, r3
  10a110:	68bb      	ldr	r3, [r7, #8]
    v_total = panel->display_timing->vactive + panel->display_timing->vback_porch +
  10a112:	f8d7 8018 	ldr.w	r8, [r7, #24]
    h_total = panel->display_timing->hactive + panel->display_timing->hback_porch +
  10a116:	441c      	add	r4, r3
    v_total = panel->display_timing->vactive + panel->display_timing->vback_porch +
  10a118:	69fb      	ldr	r3, [r7, #28]
    h_total = panel->display_timing->hactive + panel->display_timing->hback_porch +
  10a11a:	eb04 0e09 	add.w	r14, r4, r9
    v_total = panel->display_timing->vactive + panel->display_timing->vback_porch +
  10a11e:	6a3f      	ldr	r7, [r7, #32]
  10a120:	441a      	add	r2, r3
  10a122:	eb02 0408 	add.w	r4, r2, r8
  10a126:	443c      	add	r4, r7
              panel->display_timing->vfront_porch + panel->display_timing->vsync_len;
    handle->res->clk = h_total * v_total * fps * 7 / dual_mode;
  10a128:	fb04 f40e 	mul.w	r4, r4, r14
  10a12c:	fb01 f404 	mul.w	r4, r1, r4
  10a130:	ebc4 01c4 	rsb	r1, r4, r4, lsl #3
  10a134:	fbb1 f1fc 	udiv	r1, r1, r12
  10a138:	f8ca 109c 	str.w	r1, [r10, #156]	; 0x9c

    hal_sdm_set_pll_clk(handle, handle->res->clk);
  10a13c:	f001 fdee 	bl	10bd1c <hal_sdm_set_pll_clk>

    if (panel->if_type == IF_TYPE_DSI) {
  10a140:	6873      	ldr	r3, [r6, #4]
  10a142:	2b01      	cmp	r3, #1
  10a144:	d00a      	beq.n	10a15c <sdm_display_change_clk+0x7c>
                                (panel->mipi->lane_number * 1000);

        dprintf(0, "clk:%d phy_freq:%d\n", handle->res->clk, panel->mipi->phy_freq);
    }
    else
        dprintf(0, "clk:%d\n", handle->res->clk);
  10a146:	68ab      	ldr	r3, [r5, #8]
  10a148:	f649 60e8 	movw	r0, #40680	; 0x9ee8
  10a14c:	f2c0 0011 	movt	r0, #17
}
  10a150:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        dprintf(0, "clk:%d\n", handle->res->clk);
  10a154:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
  10a158:	f00a bb54 	b.w	114804 <printf>
        panel->mipi->phy_freq = h_total * v_total * fps * panel->mipi->video_bus_width * 1.1 /
  10a15c:	6a76      	ldr	r6, [r6, #36]	; 0x24
  10a15e:	8873      	ldrh	r3, [r6, #2]
  10a160:	fb04 f303 	mul.w	r3, r4, r3
  10a164:	ed9f 6b12 	vldr	d6, [r15, #72]	; 10a1b0 <sdm_display_change_clk+0xd0>
        dprintf(0, "clk:%d phy_freq:%d\n", handle->res->clk, panel->mipi->phy_freq);
  10a168:	68aa      	ldr	r2, [r5, #8]
  10a16a:	f649 60d4 	movw	r0, #40660	; 0x9ed4
        panel->mipi->phy_freq = h_total * v_total * fps * panel->mipi->video_bus_width * 1.1 /
  10a16e:	ee07 3a10 	vmov	s14, r3
        dprintf(0, "clk:%d phy_freq:%d\n", handle->res->clk, panel->mipi->phy_freq);
  10a172:	f2c0 0011 	movt	r0, #17
                                (panel->mipi->lane_number * 1000);
  10a176:	6873      	ldr	r3, [r6, #4]
        panel->mipi->phy_freq = h_total * v_total * fps * panel->mipi->video_bus_width * 1.1 /
  10a178:	eeb8 7b47 	vcvt.f64.u32	d7, s14
                                (panel->mipi->lane_number * 1000);
  10a17c:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
  10a180:	eb03 0381 	add.w	r3, r3, r1, lsl #2
        dprintf(0, "clk:%d phy_freq:%d\n", handle->res->clk, panel->mipi->phy_freq);
  10a184:	f8d2 109c 	ldr.w	r1, [r2, #156]	; 0x9c
                                (panel->mipi->lane_number * 1000);
  10a188:	00db      	lsls	r3, r3, #3
        panel->mipi->phy_freq = h_total * v_total * fps * panel->mipi->video_bus_width * 1.1 /
  10a18a:	ee27 7b06 	vmul.f64	d7, d7, d6
  10a18e:	ee06 3a90 	vmov	s13, r3
  10a192:	eeb8 6b66 	vcvt.f64.u32	d6, s13
  10a196:	ee87 5b06 	vdiv.f64	d5, d7, d6
  10a19a:	eefc 7bc5 	vcvt.u32.f64	s15, d5
  10a19e:	edc6 7a02 	vstr	s15, [r6, #8]
  10a1a2:	ee17 2a90 	vmov	r2, s15
}
  10a1a6:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        dprintf(0, "clk:%d phy_freq:%d\n", handle->res->clk, panel->mipi->phy_freq);
  10a1aa:	f00a bb2b 	b.w	114804 <printf>
  10a1ae:	bf00      	nop
  10a1b0:	9999999a 	.word	0x9999999a
  10a1b4:	3ff19999 	.word	0x3ff19999

0010a1b8 <sdm_display_handle_init>:

int sdm_display_handle_init(enum DISPLAY_TYPE display, struct sdm_panel *panels[], int n_panels) {
  10a1b8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10a1bc:	4682      	mov	r10, r0
  10a1be:	b083      	sub	sp, #12
  10a1c0:	460d      	mov	r5, r1
    int found_panel = -1;
    int num_panel = 0;
    int i;

    display_handle *handle;
    hal_display_create_handle(&handle, display);
  10a1c2:	a801      	add	r0, sp, #4
  10a1c4:	4651      	mov	r1, r10
int sdm_display_handle_init(enum DISPLAY_TYPE display, struct sdm_panel *panels[], int n_panels) {
  10a1c6:	4616      	mov	r6, r2
    hal_display_create_handle(&handle, display);
  10a1c8:	f001 feda 	bl	10bf80 <hal_display_create_handle>
    if (!handle) {
  10a1cc:	9801      	ldr	r0, [sp, #4]
  10a1ce:	2800      	cmp	r0, #0
  10a1d0:	f000 80a4 	beq.w	10a31c <sdm_display_handle_init+0x164>
    hal_display_release_handle(handle);
    return ret;
}

int sdm_check_display_panel_num(display_handle *handle) {
    return handle->res->lvds_mode == LVDS_MODE_DUPLICATE? 2: 1;
  10a1d4:	6883      	ldr	r3, [r0, #8]
    for (i = 0; i < num_panel; i++) {
  10a1d6:	2400      	movs	r4, #0
        handle->info.format = 0;
  10a1d8:	46a1      	mov	r9, r4
        handle->info.vrefresh = 60;
  10a1da:	f04f 083c 	mov.w	r8, #60	; 0x3c
    return handle->res->lvds_mode == LVDS_MODE_DUPLICATE? 2: 1;
  10a1de:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
  10a1e2:	2b01      	cmp	r3, #1
  10a1e4:	bf14      	ite	ne
  10a1e6:	2701      	movne	r7, #1
  10a1e8:	2702      	moveq	r7, #2
  10a1ea:	e00d      	b.n	10a208 <sdm_display_handle_init+0x50>
            handle->info.rtos_screen.width = handle->panels[i]->rtos_screen->width;
  10a1ec:	e9d0 2102 	ldrd	r2, r1, [r0, #8]
    for (i = 0; i < num_panel; i++) {
  10a1f0:	3401      	adds	r4, #1
            handle->info.rtos_screen.pos_y = handle->panels[i]->rtos_screen->pos_y;
  10a1f2:	e9d0 3000 	ldrd	r3, r0, [r0]
    for (i = 0; i < num_panel; i++) {
  10a1f6:	42bc      	cmp	r4, r7
            handle->info.rtos_screen.pos_y = handle->panels[i]->rtos_screen->pos_y;
  10a1f8:	f8cc 003c 	str.w	r0, [r12, #60]	; 0x3c
  10a1fc:	4660      	mov	r0, r12
            handle->info.rtos_screen.width = handle->panels[i]->rtos_screen->width;
  10a1fe:	e9cc 2110 	strd	r2, r1, [r12, #64]	; 0x40
            handle->info.rtos_screen.pos_x = handle->panels[i]->rtos_screen->pos_x;
  10a202:	f8cc 3038 	str.w	r3, [r12, #56]	; 0x38
    for (i = 0; i < num_panel; i++) {
  10a206:	d024      	beq.n	10a252 <sdm_display_handle_init+0x9a>
        found_panel = sdm_panel_probe(handle, i, panels, n_panels);
  10a208:	4633      	mov	r3, r6
  10a20a:	462a      	mov	r2, r5
  10a20c:	4621      	mov	r1, r4
  10a20e:	f00a fbeb 	bl	1149e8 <sdm_panel_probe>
        if (found_panel < 0) {
  10a212:	1e03      	subs	r3, r0, #0
  10a214:	db45      	blt.n	10a2a2 <sdm_display_handle_init+0xea>
        handle->panels[i] = panels[found_panel];
  10a216:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
  10a21a:	eb05 0b83 	add.w	r11, r5, r3, lsl #2
  10a21e:	f8dd c004 	ldr.w	r12, [r13, #4]
        handle->info.width = handle->panels[i]->display_timing->hactive;
  10a222:	6a11      	ldr	r1, [r2, #32]
        handle->panels[i] = panels[found_panel];
  10a224:	eb0c 0e84 	add.w	r14, r12, r4, lsl #2
        if (handle->panels[i]->rtos_screen) {
  10a228:	6b10      	ldr	r0, [r2, #48]	; 0x30
        handle->panels[i] = panels[found_panel];
  10a22a:	f8ce 2014 	str.w	r2, [r14, #20]
        handle->info.width = handle->panels[i]->display_timing->hactive;
  10a22e:	684a      	ldr	r2, [r1, #4]
        handle->info.height = handle->panels[i]->display_timing->vactive;
  10a230:	6949      	ldr	r1, [r1, #20]
        handle->info.format = 0;
  10a232:	e9cc 190b 	strd	r1, r9, [r12, #44]	; 0x2c
        handle->info.width = handle->panels[i]->display_timing->hactive;
  10a236:	e9cc 3209 	strd	r3, r2, [r12, #36]	; 0x24
        handle->info.vrefresh = 60;
  10a23a:	f8cc 8034 	str.w	r8, [r12, #52]	; 0x34
        if (handle->panels[i]->rtos_screen) {
  10a23e:	2800      	cmp	r0, #0
  10a240:	d1d4      	bne.n	10a1ec <sdm_display_handle_init+0x34>
            handle->info.rtos_screen.pos_y =  0;
  10a242:	e9cc 000e 	strd	r0, r0, [r12, #56]	; 0x38
    for (i = 0; i < num_panel; i++) {
  10a246:	3401      	adds	r4, #1
            handle->info.rtos_screen.width =  handle->info.width;
  10a248:	e9cc 2110 	strd	r2, r1, [r12, #64]	; 0x40
    for (i = 0; i < num_panel; i++) {
  10a24c:	42bc      	cmp	r4, r7
  10a24e:	4660      	mov	r0, r12
  10a250:	d1da      	bne.n	10a208 <sdm_display_handle_init+0x50>
    if (panels[found_panel]->panel_post_begin)
  10a252:	f8db 3000 	ldr.w	r3, [r11]
  10a256:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  10a258:	b122      	cbz	r2, 10a264 <sdm_display_handle_init+0xac>
         panels[found_panel]->panel_post_begin();
  10a25a:	4790      	blx	r2
  10a25c:	f8db 3000 	ldr.w	r3, [r11]
  10a260:	f8dd c004 	ldr.w	r12, [r13, #4]
    sdm_display_change_clk(handle, panels[found_panel]->fps);
  10a264:	6959      	ldr	r1, [r3, #20]
  10a266:	4660      	mov	r0, r12
  10a268:	f7ff ff3a 	bl	10a0e0 <sdm_display_change_clk>
    ret = hal_sdm_panel_connect(handle, i ,panels[found_panel]);
  10a26c:	f8db 2000 	ldr.w	r2, [r11]
  10a270:	9801      	ldr	r0, [sp, #4]
  10a272:	4621      	mov	r1, r4
  10a274:	f001 fdc0 	bl	10bdf8 <hal_sdm_panel_connect>
    if (ret < 0) {
  10a278:	1e04      	subs	r4, r0, #0
  10a27a:	db2f      	blt.n	10a2dc <sdm_display_handle_init+0x124>
    handle->is_need_register_irq = false;
  10a27c:	9801      	ldr	r0, [sp, #4]
  10a27e:	2300      	movs	r3, #0
  10a280:	f880 3052 	strb.w	r3, [r0, #82]	; 0x52
    if (hal_sdm_init(handle)) {
  10a284:	f001 feb2 	bl	10bfec <hal_sdm_init>
  10a288:	4603      	mov	r3, r0
  10a28a:	b390      	cbz	r0, 10a2f2 <sdm_display_handle_init+0x13a>
        LOGE("hal_sdm_init failed\n");
  10a28c:	f649 61bc 	movw	r1, #40636	; 0x9ebc
  10a290:	f649 707c 	movw	r0, #40828	; 0x9f7c
  10a294:	f2c0 0111 	movt	r1, #17
  10a298:	f2c0 0011 	movt	r0, #17
  10a29c:	f00a fab2 	bl	114804 <printf>
        goto PANEL_FAIL;
  10a2a0:	e00b      	b.n	10a2ba <sdm_display_handle_init+0x102>
            LOGE("get panel failed\n");
  10a2a2:	f649 61bc 	movw	r1, #40636	; 0x9ebc
  10a2a6:	f649 7020 	movw	r0, #40736	; 0x9f20
  10a2aa:	f2c0 0111 	movt	r1, #17
  10a2ae:	f2c0 0011 	movt	r0, #17
  10a2b2:	f00a faa7 	bl	114804 <printf>
            ret = -2;
  10a2b6:	f06f 0401 	mvn.w	r4, #1
    LOGE("TODO: we need uninit panel here\n");
  10a2ba:	f649 61bc 	movw	r1, #40636	; 0x9ebc
  10a2be:	f649 70a8 	movw	r0, #40872	; 0x9fa8
  10a2c2:	f2c0 0111 	movt	r1, #17
  10a2c6:	f2c0 0011 	movt	r0, #17
  10a2ca:	f00a fa9b 	bl	114804 <printf>
    hal_display_release_handle(handle);
  10a2ce:	9801      	ldr	r0, [sp, #4]
  10a2d0:	f001 fe8a 	bl	10bfe8 <hal_display_release_handle>
}
  10a2d4:	4620      	mov	r0, r4
  10a2d6:	b003      	add	sp, #12
  10a2d8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        LOGE("hal_sdm_panel_connect failed\n");
  10a2dc:	f649 61bc 	movw	r1, #40636	; 0x9ebc
  10a2e0:	f649 7048 	movw	r0, #40776	; 0x9f48
  10a2e4:	f2c0 0111 	movt	r1, #17
  10a2e8:	f2c0 0011 	movt	r0, #17
  10a2ec:	f00a fa8a 	bl	114804 <printf>
        goto PANEL_FAIL;
  10a2f0:	e7e3      	b.n	10a2ba <sdm_display_handle_init+0x102>
    sdm_display_t *d = (sdm_display_t *)malloc(sizeof(sdm_display_t));
  10a2f2:	2010      	movs	r0, #16
    return 0;
  10a2f4:	461c      	mov	r4, r3
    sdm_display_t *d = (sdm_display_t *)malloc(sizeof(sdm_display_t));
  10a2f6:	f007 f92b 	bl	111550 <malloc>
    d->handle = handle;
  10a2fa:	9901      	ldr	r1, [sp, #4]

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
    item->prev = list->prev;
  10a2fc:	f24f 5378 	movw	r3, #62840	; 0xf578
  10a300:	f2c0 0312 	movt	r3, #18
  10a304:	681a      	ldr	r2, [r3, #0]
    d->id = display;
  10a306:	f8c0 a008 	str.w	r10, [r0, #8]
    d->handle = handle;
  10a30a:	60c1      	str	r1, [r0, #12]
  10a30c:	e9c0 2300 	strd	r2, r3, [r0]
    item->next = list;
    list->prev->next = item;
    list->prev = item;
  10a310:	6018      	str	r0, [r3, #0]
    list->prev->next = item;
  10a312:	6050      	str	r0, [r2, #4]
}
  10a314:	4620      	mov	r0, r4
  10a316:	b003      	add	sp, #12
  10a318:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        LOGE("create %d handle failed\n", display);
  10a31c:	f649 61bc 	movw	r1, #40636	; 0x9ebc
  10a320:	f649 60f0 	movw	r0, #40688	; 0x9ef0
  10a324:	4652      	mov	r2, r10
  10a326:	f2c0 0111 	movt	r1, #17
        return -1;
  10a32a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        LOGE("create %d handle failed\n", display);
  10a32e:	f2c0 0011 	movt	r0, #17
  10a332:	f00a fa67 	bl	114804 <printf>
        return -1;
  10a336:	e7cd      	b.n	10a2d4 <sdm_display_handle_init+0x11c>

0010a338 <sdm_screen_clear>:

    return 0;
}

void sdm_screen_clear(display_handle *handle)
{
  10a338:	b5f0      	push	{r4, r5, r6, r7, r14}
  10a33a:	4605      	mov	r5, r0
  10a33c:	b0c1      	sub	sp, #260	; 0x104
    struct sdm_post_config p;
    struct sdm_buffer bufs[2] = {0};
  10a33e:	2100      	movs	r1, #0
  10a340:	af04      	add	r7, sp, #16
  10a342:	4638      	mov	r0, r7
  10a344:	22f0      	movs	r2, #240	; 0xf0
    width = handle->info.width;
    height = handle->info.height;

    p.bufs = bufs;
    p.n_bufs = 2;
    for (i = 0; i < 2;i++) {
  10a346:	460c      	mov	r4, r1
    struct sdm_buffer bufs[2] = {0};
  10a348:	f009 eb30 	blx	1139ac <memset>
    width = handle->info.width;
  10a34c:	6aa9      	ldr	r1, [r5, #40]	; 0x28
        bufs[i].layer = i;
        bufs[i].layer_en = 0;
        bufs[i].fmt = COLOR_RGB565;
  10a34e:	f245 0601 	movw	r6, #20481	; 0x5001
    height = handle->info.height;
  10a352:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    p.n_bufs = 2;
  10a354:	f04f 0e02 	mov.w	r14, #2
  10a358:	463b      	mov	r3, r7
        bufs[i].layer_en = 0;
  10a35a:	4622      	mov	r2, r4
    p.bufs = bufs;
  10a35c:	9701      	str	r7, [sp, #4]
        bufs[i].start.x = 0;
        bufs[i].start.y = 0;
        bufs[i].start.w = width;
        bufs[i].start.h = height;
        bufs[i].addr[0] = (unsigned long)logo;
        bufs[i].src_stride[0] = width * 2;
  10a35e:	ea4f 0c41 	mov.w	r12, r1, lsl #1
        bufs[i].alpha_en = 1;
  10a362:	2701      	movs	r7, #1
        bufs[i].fmt = COLOR_RGB565;
  10a364:	f2c0 0656 	movt	r6, #86	; 0x56
    p.n_bufs = 2;
  10a368:	f8cd e000 	str.w	r14, [r13]
        bufs[i].layer = i;
  10a36c:	601c      	str	r4, [r3, #0]
        bufs[i].fmt = COLOR_RGB565;
  10a36e:	e9c3 2602 	strd	r2, r6, [r3, #8]
        bufs[i].alpha_en = 1;
  10a372:	669f      	str	r7, [r3, #104]	; 0x68
        bufs[i].alpha = 0x0;
  10a374:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
        bufs[i].ckey_en = 0;
  10a378:	e9c3 2218 	strd	r2, r2, [r3, #96]	; 0x60
        bufs[i].src.y = 0;
  10a37c:	e9c3 2204 	strd	r2, r2, [r3, #16]
        bufs[i].src.h = height;
  10a380:	e9c3 1006 	strd	r1, r0, [r3, #24]
        bufs[i].start.y = 0;
  10a384:	e9c3 2210 	strd	r2, r2, [r3, #64]	; 0x40
        bufs[i].start.h = height;
  10a388:	e9c3 1012 	strd	r1, r0, [r3, #72]	; 0x48
        bufs[i].addr[0] = (unsigned long)logo;
  10a38c:	621a      	str	r2, [r3, #32]
        bufs[i].src_stride[0] = width * 2;
  10a38e:	f8c3 c030 	str.w	r12, [r3, #48]	; 0x30

        bufs[i].dst.x = 0;
        bufs[i].dst.y = 0;
  10a392:	e9c3 2214 	strd	r2, r2, [r3, #80]	; 0x50
        bufs[i].dst.w = width;
        bufs[i].dst.h = height;
  10a396:	e9c3 1016 	strd	r1, r0, [r3, #88]	; 0x58
  10a39a:	3378      	adds	r3, #120	; 0x78
        bufs[i].z_order = i;
  10a39c:	f843 4c08 	str.w	r4, [r3, #-8]
    for (i = 0; i < 2;i++) {
  10a3a0:	b18c      	cbz	r4, 10a3c6 <sdm_screen_clear+0x8e>
}

static inline int sdm_post(display_handle *handle, struct sdm_post_config *post)
{
    int ret;
    ret = hal_sdm_post_config(handle, post);
  10a3a2:	4669      	mov	r1, r13
  10a3a4:	4628      	mov	r0, r5
  10a3a6:	f001 fe23 	bl	10bff0 <hal_sdm_post_config>

    if (handle->panels[handle->found_panel]->panel_post_end) {
  10a3aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  10a3ac:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  10a3b0:	695b      	ldr	r3, [r3, #20]
  10a3b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  10a3b4:	b12b      	cbz	r3, 10a3c2 <sdm_screen_clear+0x8a>
        if (!handle->panel_post_end_done) {
  10a3b6:	f895 2051 	ldrb.w	r2, [r5, #81]	; 0x51
  10a3ba:	b912      	cbnz	r2, 10a3c2 <sdm_screen_clear+0x8a>
            handle->panels[handle->found_panel]->panel_post_end();
  10a3bc:	4798      	blx	r3
            handle->panel_post_end_done = true;
  10a3be:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
    }
    sdm_post(handle, &p);
}
  10a3c2:	b041      	add	sp, #260	; 0x104
  10a3c4:	bdf0      	pop	{r4, r5, r6, r7, r15}
  10a3c6:	2401      	movs	r4, #1
  10a3c8:	e7d0      	b.n	10a36c <sdm_screen_clear+0x34>
  10a3ca:	bf00      	nop

0010a3cc <sdm_display_init>:
{
    return is_inited;
}

void sdm_display_init(void)
{
  10a3cc:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    int i;
    int num_display;

    // connect all display
    hal_display_connect_all();
  10a3ce:	f001 fd89 	bl	10bee4 <hal_display_connect_all>
    num_display = hal_display_num();
  10a3d2:	f001 fd19 	bl	10be08 <hal_display_num>
    list->prev = list->next = list;
  10a3d6:	f24f 5378 	movw	r3, #62840	; 0xf578
  10a3da:	f2c0 0312 	movt	r3, #18
  10a3de:	e9c3 3300 	strd	r3, r3, [r3]

    sdm_init();

    LOGD("display num is %d\n", num_display);
    for(i = 0;i< num_display;i++) {
  10a3e2:	1e06      	subs	r6, r0, #0
  10a3e4:	dd1d      	ble.n	10a422 <sdm_display_init+0x56>
            continue;
        }
        if (handle->dm && handle->dm->dc) {
            //LOGD("init panel for display [%d]-- index [%d]\n", handle->display_id, i);
            int n_panels = ARRAY_SIZE(registered_panels[handle->display_id]);
            sdm_display_handle_init(handle->display_id, registered_panels[handle->display_id], n_panels);
  10a3e6:	f64c 07a8 	movw	r7, #51368	; 0xc8a8
    for(i = 0;i< num_display;i++) {
  10a3ea:	2400      	movs	r4, #0
            sdm_display_handle_init(handle->display_id, registered_panels[handle->display_id], n_panels);
  10a3ec:	f2c0 0712 	movt	r7, #18
        display_handle *handle = hal_get_display_handle_by_index(i);
  10a3f0:	4620      	mov	r0, r4
    for(i = 0;i< num_display;i++) {
  10a3f2:	3401      	adds	r4, #1
        display_handle *handle = hal_get_display_handle_by_index(i);
  10a3f4:	f001 fd2a 	bl	10be4c <hal_get_display_handle_by_index>
        if (handle->res->gui_enable == PANEL_NOT_NEED_INIT) {
  10a3f8:	6883      	ldr	r3, [r0, #8]
        display_handle *handle = hal_get_display_handle_by_index(i);
  10a3fa:	4605      	mov	r5, r0
        if (handle->res->gui_enable == PANEL_NOT_NEED_INIT) {
  10a3fc:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  10a400:	b16b      	cbz	r3, 10a41e <sdm_display_init+0x52>
        if (handle->dm && handle->dm->dc) {
  10a402:	68c3      	ldr	r3, [r0, #12]
  10a404:	b15b      	cbz	r3, 10a41e <sdm_display_init+0x52>
  10a406:	68db      	ldr	r3, [r3, #12]
            sdm_display_handle_init(handle->display_id, registered_panels[handle->display_id], n_panels);
  10a408:	2201      	movs	r2, #1
        if (handle->dm && handle->dm->dc) {
  10a40a:	b143      	cbz	r3, 10a41e <sdm_display_init+0x52>
            sdm_display_handle_init(handle->display_id, registered_panels[handle->display_id], n_panels);
  10a40c:	6803      	ldr	r3, [r0, #0]
  10a40e:	4618      	mov	r0, r3
  10a410:	f857 1023 	ldr.w	r1, [r7, r3, lsl #2]
  10a414:	f7ff fed0 	bl	10a1b8 <sdm_display_handle_init>
            sdm_screen_clear(handle);
  10a418:	4628      	mov	r0, r5
  10a41a:	f7ff ff8d 	bl	10a338 <sdm_screen_clear>
    for(i = 0;i< num_display;i++) {
  10a41e:	42a6      	cmp	r6, r4
  10a420:	d1e6      	bne.n	10a3f0 <sdm_display_init+0x24>
    LOGD("found %u displays connected\n", list_length(sdm_get_display_list()));

#ifdef SUPPORT_LVGL_GUI
    lvgl_init();
#endif
    is_inited = true;
  10a422:	f24f 5380 	movw	r3, #62848	; 0xf580
  10a426:	2201      	movs	r2, #1
  10a428:	f2c0 0312 	movt	r3, #18
  10a42c:	601a      	str	r2, [r3, #0]
}
  10a42e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010a430 <dcf_early_init>:
}

void dcf_early_init(void)
{
    return;
}
  10a430:	4770      	bx	r14
  10a432:	bf00      	nop

0010a434 <hal_clock_get_instance>:
//!
//! \return clkgen hanle
//
//*****************************************************************************
static clkgen_instance_t *hal_clock_get_instance(void)
{
  10a434:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10a436:	f3ef 8000 	mrs	r0, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10a43a:	f010 0080 	ands.w	r0, r0, #128	; 0x80
  10a43e:	d124      	bne.n	10a48a <hal_clock_get_instance+0x56>
    __asm__ volatile("cpsid i");
  10a440:	b672      	cpsid	i
    *statep = state;
  10a442:	f24f 5194 	movw	r1, #62868	; 0xf594
  10a446:	2401      	movs	r4, #1
    *lock = 1;
  10a448:	f24f 5284 	movw	r2, #62852	; 0xf584
    *statep = state;
  10a44c:	f2c0 0112 	movt	r1, #18
    //spin_lock_saved_state_t states;
    spin_lock_irqsave(&clkgen_spin_lock, spin_lock_states);

    if (g_ClkgenInstance.occupied != 1) {
  10a450:	f24f 5388 	movw	r3, #62856	; 0xf588
    *lock = 1;
  10a454:	f2c0 0212 	movt	r2, #18
    *statep = state;
  10a458:	600c      	str	r4, [r1, #0]
  10a45a:	f2c0 0312 	movt	r3, #18
  10a45e:	7919      	ldrb	r1, [r3, #4]
    *lock = 1;
  10a460:	6014      	str	r4, [r2, #0]
  10a462:	42a1      	cmp	r1, r4
  10a464:	d027      	beq.n	10a4b6 <hal_clock_get_instance+0x82>
    *controllerTable = &s_ClkgenDrvInterface;
  10a466:	f64b 0264 	movw	r2, #47204	; 0xb864
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
  10a46a:	2100      	movs	r1, #0
        /* get clkgen driver API table */
        hal_clock_get_controller_interface(&(g_ClkgenInstance.controllerTable));

        if (g_ClkgenInstance.controllerTable) {
            g_ClkgenInstance.occupied = 1;
  10a46c:	2401      	movs	r4, #1
    *controllerTable = &s_ClkgenDrvInterface;
  10a46e:	f2c0 0211 	movt	r2, #17
            //sec clkgen
            g_ClkgenInstance.controllerTable->get_default_config(&
  10a472:	4812      	ldr	r0, [pc, #72]	; (10a4bc <hal_clock_get_instance+0x88>)
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
  10a474:	e9c3 1201 	strd	r1, r2, [r3, #4]
  10a478:	6019      	str	r1, [r3, #0]
            g_ClkgenInstance.occupied = 1;
  10a47a:	711c      	strb	r4, [r3, #4]
            g_ClkgenInstance.controllerTable->get_default_config(&
  10a47c:	f7f8 fd14 	bl	102ea8 <clkgen_get_default_config>
                    (g_ClkgenInstance.def_cfg));
        }

        //spin_unlock_irqrestore(&clkgen_spin_lock, states);
        LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "hal_clock_get_instance is ok \n");
        return &g_ClkgenInstance;
  10a480:	f24f 5088 	movw	r0, #62856	; 0xf588
  10a484:	f2c0 0012 	movt	r0, #18

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_get_instance is failed \n");
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
    return NULL;
}
  10a488:	bd10      	pop	{r4, r15}
    *statep = state;
  10a48a:	f24f 5194 	movw	r1, #62868	; 0xf594
  10a48e:	2000      	movs	r0, #0
    *lock = 1;
  10a490:	2401      	movs	r4, #1
    *statep = state;
  10a492:	f2c0 0112 	movt	r1, #18
    *lock = 1;
  10a496:	f24f 5284 	movw	r2, #62852	; 0xf584
    if (g_ClkgenInstance.occupied != 1) {
  10a49a:	f24f 5388 	movw	r3, #62856	; 0xf588
    *statep = state;
  10a49e:	6008      	str	r0, [r1, #0]
    *lock = 1;
  10a4a0:	f2c0 0212 	movt	r2, #18
  10a4a4:	f2c0 0312 	movt	r3, #18
  10a4a8:	7919      	ldrb	r1, [r3, #4]
  10a4aa:	6014      	str	r4, [r2, #0]
  10a4ac:	42a1      	cmp	r1, r4
    *lock = 0;
  10a4ae:	bf08      	it	eq
  10a4b0:	6010      	streq	r0, [r2, #0]
  10a4b2:	d1d8      	bne.n	10a466 <hal_clock_get_instance+0x32>
  10a4b4:	e7e8      	b.n	10a488 <hal_clock_get_instance+0x54>
  10a4b6:	6010      	str	r0, [r2, #0]
    __asm__ volatile("cpsie i");
  10a4b8:	b662      	cpsie	i
}
  10a4ba:	bd10      	pop	{r4, r15}
  10a4bc:	0012f58d 	.word	0x0012f58d

0010a4c0 <hal_clock_release_handle.part.2>:
//
//*****************************************************************************
bool hal_clock_release_handle(void *handle)
{
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((handle != NULL));
  10a4c0:	f24a 5370 	movw	r3, #42352	; 0xa570
  10a4c4:	f24a 5240 	movw	r2, #42304	; 0xa540
bool hal_clock_release_handle(void *handle)
  10a4c8:	b500      	push	{r14}
    ASSERT((handle != NULL));
  10a4ca:	f2c0 0311 	movt	r3, #17
  10a4ce:	f647 4134 	movw	r1, #31796	; 0x7c34
bool hal_clock_release_handle(void *handle)
  10a4d2:	b083      	sub	sp, #12
    ASSERT((handle != NULL));
  10a4d4:	4670      	mov	r0, r14
  10a4d6:	f2c0 0211 	movt	r2, #17
  10a4da:	9300      	str	r3, [sp, #0]
  10a4dc:	f2c0 0111 	movt	r1, #17
  10a4e0:	23b9      	movs	r3, #185	; 0xb9
  10a4e2:	f009 f95b 	bl	11379c <_panic>
  10a4e6:	bf00      	nop

0010a4e8 <hal_clock_release_instance>:
    ASSERT((clkgenInstance != NULL));
  10a4e8:	b178      	cbz	r0, 10a50a <hal_clock_release_instance+0x22>
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  10a4ea:	f24f 5294 	movw	r2, #62868	; 0xf594
  10a4ee:	f24f 5384 	movw	r3, #62852	; 0xf584
  10a4f2:	f2c0 0212 	movt	r2, #18
    clkgenInstance->occupied = 0;
  10a4f6:	2100      	movs	r1, #0
  10a4f8:	f2c0 0312 	movt	r3, #18
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  10a4fc:	6812      	ldr	r2, [r2, #0]
  10a4fe:	6019      	str	r1, [r3, #0]
    clkgenInstance->occupied = 0;
  10a500:	7101      	strb	r1, [r0, #4]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10a502:	07d3      	lsls	r3, r2, #31
  10a504:	d500      	bpl.n	10a508 <hal_clock_release_instance+0x20>
  10a506:	b662      	cpsie	i
  10a508:	4770      	bx	r14
    ASSERT((clkgenInstance != NULL));
  10a50a:	f24a 5384 	movw	r3, #42372	; 0xa584
  10a50e:	f24a 5240 	movw	r2, #42304	; 0xa540
{
  10a512:	b500      	push	{r14}
    ASSERT((clkgenInstance != NULL));
  10a514:	f2c0 0311 	movt	r3, #17
  10a518:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  10a51c:	b083      	sub	sp, #12
  10a51e:	4670      	mov	r0, r14
    ASSERT((clkgenInstance != NULL));
  10a520:	f2c0 0211 	movt	r2, #17
  10a524:	9300      	str	r3, [sp, #0]
  10a526:	f2c0 0111 	movt	r1, #17
  10a52a:	2387      	movs	r3, #135	; 0x87
  10a52c:	f009 f936 	bl	11379c <_panic>

0010a530 <hal_clock_creat_handle>:
{
  10a530:	b510      	push	{r4, r14}
  10a532:	b082      	sub	sp, #8
    ASSERT((handle != NULL));
  10a534:	b138      	cbz	r0, 10a546 <hal_clock_creat_handle+0x16>
  10a536:	4604      	mov	r4, r0
    clkgenInstance = hal_clock_get_instance();
  10a538:	f7ff ff7c 	bl	10a434 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  10a53c:	b108      	cbz	r0, 10a542 <hal_clock_creat_handle+0x12>
    *handle = clkgenInstance;
  10a53e:	6020      	str	r0, [r4, #0]
    return true;
  10a540:	2001      	movs	r0, #1
}
  10a542:	b002      	add	sp, #8
  10a544:	bd10      	pop	{r4, r15}
    ASSERT((handle != NULL));
  10a546:	f24a 5370 	movw	r3, #42352	; 0xa570
  10a54a:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a54e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a552:	f2c0 0311 	movt	r3, #17
  10a556:	4670      	mov	r0, r14
  10a558:	f2c0 0211 	movt	r2, #17
  10a55c:	9300      	str	r3, [sp, #0]
  10a55e:	f2c0 0111 	movt	r1, #17
  10a562:	239b      	movs	r3, #155	; 0x9b
  10a564:	f009 f91a 	bl	11379c <_panic>

0010a568 <hal_clock_release_handle>:
{
  10a568:	b508      	push	{r3, r14}
    ASSERT((handle != NULL));
  10a56a:	b118      	cbz	r0, 10a574 <hal_clock_release_handle+0xc>
    l_clkgenInstance = (clkgen_instance_t *)handle;
    hal_clock_release_instance(l_clkgenInstance);
  10a56c:	f7ff ffbc 	bl	10a4e8 <hal_clock_release_instance>
    // mutex_destroy(&l_clkgenInstance->clkgenMutex);
    return true;
}
  10a570:	2001      	movs	r0, #1
  10a572:	bd08      	pop	{r3, r15}
  10a574:	f7ff ffa4 	bl	10a4c0 <hal_clock_release_handle.part.2>

0010a578 <hal_clock_osc_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_osc_init(void *g_handle, uint32_t res_glb_idx,
                        clkgen_app_fsrefclk_sel_type src_sel_mask, bool en_safety_mode)
{
  10a578:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = -1;
    vaddr_t clkgen_base_addr = 0x0;
    paddr_t phy_addr;
    int32_t scr_idx = -1;
  10a57a:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
{
  10a57e:	b085      	sub	sp, #20
    int32_t scr_idx = -1;
  10a580:	9503      	str	r5, [sp, #12]
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10a582:	b1c8      	cbz	r0, 10a5b8 <hal_clock_osc_init+0x40>
  10a584:	4616      	mov	r6, r2
  10a586:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &scr_idx);
  10a588:	4608      	mov	r0, r1
  10a58a:	aa03      	add	r2, sp, #12
  10a58c:	461f      	mov	r7, r3
  10a58e:	a902      	add	r1, sp, #8
  10a590:	f005 fed0 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10a594:	3001      	adds	r0, #1
  10a596:	d00c      	beq.n	10a5b2 <hal_clock_osc_init+0x3a>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_osc_init res_glb_idx:0x%x,src_sel_mask:0x%x,en_safety_mode:%d\n",
                  res_glb_idx, src_sel_mask, en_safety_mode);

    if ((scr_idx >= DEFAULT_FSREFCLK_IDX_START)
  10a598:	9903      	ldr	r1, [sp, #12]
  10a59a:	297f      	cmp	r1, #127	; 0x7f
  10a59c:	dd09      	ble.n	10a5b2 <hal_clock_osc_init+0x3a>
            && l_clkgenInstance->controllerTable->fsrefclk_sel) {
  10a59e:	68a3      	ldr	r3, [r4, #8]
  10a5a0:	685c      	ldr	r4, [r3, #4]
  10a5a2:	b1dc      	cbz	r4, 10a5dc <hal_clock_osc_init+0x64>
        /*init fsrefclk*/
        if (l_clkgenInstance->controllerTable->fsrefclk_sel(clkgen_base_addr,
  10a5a4:	463b      	mov	r3, r7
  10a5a6:	4632      	mov	r2, r6
  10a5a8:	9802      	ldr	r0, [sp, #8]
  10a5aa:	3980      	subs	r1, #128	; 0x80
  10a5ac:	47a0      	blx	r4

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_osc_init failed scr_idx:%d,res_glb_idx:0x%x \n", scr_idx,
                  res_glb_idx);
    return false;
}
  10a5ae:	b005      	add	sp, #20
  10a5b0:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return false;
  10a5b2:	2000      	movs	r0, #0
}
  10a5b4:	b005      	add	sp, #20
  10a5b6:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10a5b8:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10a5bc:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a5c0:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a5c4:	f2c0 0311 	movt	r3, #17
  10a5c8:	4670      	mov	r0, r14
  10a5ca:	f2c0 0211 	movt	r2, #17
  10a5ce:	9300      	str	r3, [sp, #0]
  10a5d0:	f2c0 0111 	movt	r1, #17
  10a5d4:	f240 13a3 	movw	r3, #419	; 0x1a3
  10a5d8:	f009 f8e0 	bl	11379c <_panic>
        return false;
  10a5dc:	4620      	mov	r0, r4
  10a5de:	e7e9      	b.n	10a5b4 <hal_clock_osc_init+0x3c>

0010a5e0 <hal_clock_ip_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_ip_init(void *g_handle, paddr_t phy_addr,
                       const clkgen_ip_slice_t *ip_slice_default)
{
  10a5e0:	b530      	push	{r4, r5, r14}
  10a5e2:	460b      	mov	r3, r1
  10a5e4:	b083      	sub	sp, #12
    vaddr_t clkgen_base_addr = 0x0;
    //paddr_t phy_addr;
    clkgen_instance_t *l_clkgenInstance = NULL;
    uint8_t ip_slice_idx = ip_slice_default->slice_index;
  10a5e6:	7811      	ldrb	r1, [r2, #0]
    ASSERT((g_handle != NULL));
  10a5e8:	b160      	cbz	r0, 10a604 <hal_clock_ip_init+0x24>
  10a5ea:	4614      	mov	r4, r2
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->ip_slice_set) {
  10a5ec:	6882      	ldr	r2, [r0, #8]
  10a5ee:	68d5      	ldr	r5, [r2, #12]
  10a5f0:	b1d5      	cbz	r5, 10a628 <hal_clock_ip_init+0x48>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->ip_slice_set(clkgen_base_addr,
  10a5f2:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
  10a5f6:	4618      	mov	r0, r3
  10a5f8:	8d23      	ldrh	r3, [r4, #40]	; 0x28
  10a5fa:	8da4      	ldrh	r4, [r4, #44]	; 0x2c
  10a5fc:	9400      	str	r4, [sp, #0]
  10a5fe:	47a8      	blx	r5
        }
    }

    LTRACEF("hal_clock_ip_init fail %d\n", ip_slice_idx);
    return false;
}
  10a600:	b003      	add	sp, #12
  10a602:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10a604:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10a608:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a60c:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a610:	f2c0 0311 	movt	r3, #17
  10a614:	4670      	mov	r0, r14
  10a616:	f2c0 0211 	movt	r2, #17
  10a61a:	9300      	str	r3, [sp, #0]
  10a61c:	f2c0 0111 	movt	r1, #17
  10a620:	f44f 73e9 	mov.w	r3, #466	; 0x1d2
  10a624:	f009 f8ba 	bl	11379c <_panic>
    return false;
  10a628:	4628      	mov	r0, r5
  10a62a:	e7e9      	b.n	10a600 <hal_clock_ip_init+0x20>

0010a62c <hal_clock_bus_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_bus_init(void *g_handle, paddr_t phy_addr,
                        const clkgen_bus_slice_t *bus_slice_default)
{
  10a62c:	b570      	push	{r4, r5, r6, r14}
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_bus_slice_drv_t bus_clock_drv_cfg;
    uint8_t bus_slice_idx = bus_slice_default->slice_index;
  10a62e:	6814      	ldr	r4, [r2, #0]
{
  10a630:	b086      	sub	sp, #24
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10a632:	b388      	cbz	r0, 10a698 <hal_clock_bus_init+0x6c>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->bus_slice_switch) {
  10a634:	6883      	ldr	r3, [r0, #8]
  10a636:	699b      	ldr	r3, [r3, #24]
  10a638:	2b00      	cmp	r3, #0
  10a63a:	d03f      	beq.n	10a6bc <hal_clock_bus_init+0x90>
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
        bus_clock_drv_cfg.clk_a_b_switch =
            bus_slice_default->clk_a_b_select;
        bus_clock_drv_cfg.clk_src_sel_a =
            bus_slice_default->clk_src_select_a_num;
        bus_clock_drv_cfg.clk_src_sel_b =
  10a63c:	6c95      	ldr	r5, [r2, #72]	; 0x48
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
  10a63e:	b2e4      	uxtb	r4, r4
        bus_clock_drv_cfg.clk_a_b_switch =
  10a640:	f892 604c 	ldrb.w	r6, [r2, #76]	; 0x4c
        bus_clock_drv_cfg.clk_src_sel_b =
  10a644:	f88d 500e 	strb.w	r5, [r13, #14]
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
  10a648:	9402      	str	r4, [sp, #8]
            bus_slice_default->clk_src_select_b_num;
        bus_clock_drv_cfg.pre_div_a = bus_slice_default->pre_div_a;
  10a64a:	f892 504d 	ldrb.w	r5, [r2, #77]	; 0x4d
        bus_clock_drv_cfg.clk_src_sel_a =
  10a64e:	f892 4024 	ldrb.w	r4, [r2, #36]	; 0x24
        bus_clock_drv_cfg.pre_div_a = bus_slice_default->pre_div_a;
  10a652:	f88d 500f 	strb.w	r5, [r13, #15]
        bus_clock_drv_cfg.clk_src_sel_a =
  10a656:	f88d 400d 	strb.w	r4, [r13, #13]
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
        bus_clock_drv_cfg.gasket_cfg.m_div_num =
  10a65a:	f892 5050 	ldrb.w	r5, [r2, #80]	; 0x50
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
  10a65e:	f892 404f 	ldrb.w	r4, [r2, #79]	; 0x4f
        bus_clock_drv_cfg.clk_a_b_switch =
  10a662:	f88d 600c 	strb.w	r6, [r13, #12]
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
  10a666:	f88d 4011 	strb.w	r4, [r13, #17]
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
            bus_slice_default->p_div;
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
            bus_slice_default->q_div;

        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  10a66a:	4608      	mov	r0, r1
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
  10a66c:	f892 4052 	ldrb.w	r4, [r2, #82]	; 0x52
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
  10a670:	f892 104e 	ldrb.w	r1, [r2, #78]	; 0x4e
        bus_clock_drv_cfg.gasket_cfg.m_div_num =
  10a674:	f88d 5012 	strb.w	r5, [r13, #18]
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
  10a678:	f88d 1010 	strb.w	r1, [r13, #16]
        bus_clock_drv_cfg.gasket_cfg.n_div_num =
  10a67c:	f892 1051 	ldrb.w	r1, [r2, #81]	; 0x51
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
  10a680:	f88d 4014 	strb.w	r4, [r13, #20]
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
  10a684:	f892 2053 	ldrb.w	r2, [r2, #83]	; 0x53
        bus_clock_drv_cfg.gasket_cfg.n_div_num =
  10a688:	f88d 1013 	strb.w	r1, [r13, #19]
        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  10a68c:	a902      	add	r1, sp, #8
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
  10a68e:	f88d 2015 	strb.w	r2, [r13, #21]
        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  10a692:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_bus_init slice_idx:%d fail\n", bus_slice_idx);
    return false;
}
  10a694:	b006      	add	sp, #24
  10a696:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  10a698:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10a69c:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a6a0:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a6a4:	f2c0 0311 	movt	r3, #17
  10a6a8:	4670      	mov	r0, r14
  10a6aa:	f2c0 0211 	movt	r2, #17
  10a6ae:	9300      	str	r3, [sp, #0]
  10a6b0:	f2c0 0111 	movt	r1, #17
  10a6b4:	f240 2303 	movw	r3, #515	; 0x203
  10a6b8:	f009 f870 	bl	11379c <_panic>
    return false;
  10a6bc:	4618      	mov	r0, r3
  10a6be:	e7e9      	b.n	10a694 <hal_clock_bus_init+0x68>

0010a6c0 <hal_saf_clock_set_default>:
{
  10a6c0:	b5f0      	push	{r4, r5, r6, r7, r14}
  10a6c2:	4677      	mov	r7, r14
  10a6c4:	b083      	sub	sp, #12
    clkgenInstance = hal_clock_get_instance();
  10a6c6:	f7ff feb5 	bl	10a434 <hal_clock_get_instance>
  10a6ca:	f24a 6484 	movw	r4, #42628	; 0xa684
  10a6ce:	f2c0 0411 	movt	r4, #17
  10a6d2:	f504 765d 	add.w	r6, r4, #884	; 0x374
    if (clkgenInstance == NULL) {
  10a6d6:	4605      	mov	r5, r0
  10a6d8:	b918      	cbnz	r0, 10a6e2 <hal_saf_clock_set_default+0x22>
  10a6da:	e030      	b.n	10a73e <hal_saf_clock_set_default+0x7e>
  10a6dc:	3434      	adds	r4, #52	; 0x34
    for (uint8_t i = 0; i < ARRAYSIZE(ip); i++) {
  10a6de:	42a6      	cmp	r6, r4
  10a6e0:	d01b      	beq.n	10a71a <hal_saf_clock_set_default+0x5a>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SAF_BASE, &ip[i]);
  10a6e2:	4622      	mov	r2, r4
  10a6e4:	f04f 417c 	mov.w	r1, #4227858432	; 0xfc000000
  10a6e8:	4628      	mov	r0, r5
  10a6ea:	f7ff ff79 	bl	10a5e0 <hal_clock_ip_init>
        if (!ret) goto fail;
  10a6ee:	2800      	cmp	r0, #0
  10a6f0:	d1f4      	bne.n	10a6dc <hal_saf_clock_set_default+0x1c>
    hal_clock_release_instance(l_clkgenInstance);
  10a6f2:	4628      	mov	r0, r5
  10a6f4:	f7ff fef8 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10a6f8:	f24a 6310 	movw	r3, #42512	; 0xa610
  10a6fc:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a700:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a704:	f2c0 0311 	movt	r3, #17
  10a708:	4638      	mov	r0, r7
  10a70a:	f2c0 0211 	movt	r2, #17
  10a70e:	9300      	str	r3, [sp, #0]
  10a710:	f2c0 0111 	movt	r1, #17
  10a714:	23ea      	movs	r3, #234	; 0xea
  10a716:	f009 f841 	bl	11379c <_panic>
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SAF_BASE, &bus[i]);
  10a71a:	f24a 0238 	movw	r2, #41016	; 0xa038
  10a71e:	f04f 417c 	mov.w	r1, #4227858432	; 0xfc000000
  10a722:	4628      	mov	r0, r5
  10a724:	f2c0 0211 	movt	r2, #17
  10a728:	f7ff ff80 	bl	10a62c <hal_clock_bus_init>
  10a72c:	4604      	mov	r4, r0
    hal_clock_release_instance(l_clkgenInstance);
  10a72e:	4628      	mov	r0, r5
  10a730:	f7ff feda 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10a734:	2c00      	cmp	r4, #0
  10a736:	d0df      	beq.n	10a6f8 <hal_saf_clock_set_default+0x38>
}
  10a738:	4620      	mov	r0, r4
  10a73a:	b003      	add	sp, #12
  10a73c:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_saf_clock_set_default clkgen creat handle failed\n");
  10a73e:	f24a 50d8 	movw	r0, #42456	; 0xa5d8
        return ret;
  10a742:	462c      	mov	r4, r5
        printf("hal_saf_clock_set_default clkgen creat handle failed\n");
  10a744:	f2c0 0011 	movt	r0, #17
  10a748:	f00a f844 	bl	1147d4 <puts>
}
  10a74c:	4620      	mov	r0, r4
  10a74e:	b003      	add	sp, #12
  10a750:	bdf0      	pop	{r4, r5, r6, r7, r15}
  10a752:	bf00      	nop

0010a754 <hal_sec_clock_set_default>:
{
  10a754:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10a758:	4677      	mov	r7, r14
  10a75a:	b082      	sub	sp, #8
    clkgenInstance = hal_clock_get_instance();
  10a75c:	f7ff fe6a 	bl	10a434 <hal_clock_get_instance>
  10a760:	f64a 14f8 	movw	r4, #43512	; 0xa9f8
  10a764:	f2c0 0411 	movt	r4, #17
  10a768:	f504 6629 	add.w	r6, r4, #2704	; 0xa90
    if (clkgenInstance == NULL) {
  10a76c:	4605      	mov	r5, r0
  10a76e:	b918      	cbnz	r0, 10a778 <hal_sec_clock_set_default+0x24>
  10a770:	e01f      	b.n	10a7b2 <hal_sec_clock_set_default+0x5e>
  10a772:	3434      	adds	r4, #52	; 0x34
    for (uint8_t i = 0; i < ARRAYSIZE(ip); i++) {
  10a774:	42a6      	cmp	r6, r4
  10a776:	d027      	beq.n	10a7c8 <hal_sec_clock_set_default+0x74>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SEC_BASE, &ip[i]);
  10a778:	4622      	mov	r2, r4
  10a77a:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  10a77e:	4628      	mov	r0, r5
  10a780:	f7ff ff2e 	bl	10a5e0 <hal_clock_ip_init>
        if (!ret) goto fail;
  10a784:	2800      	cmp	r0, #0
  10a786:	d1f4      	bne.n	10a772 <hal_sec_clock_set_default+0x1e>
    hal_clock_release_instance(l_clkgenInstance);
  10a788:	4628      	mov	r0, r5
  10a78a:	f7ff fead 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10a78e:	f24a 6310 	movw	r3, #42512	; 0xa610
  10a792:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a796:	f2c0 0311 	movt	r3, #17
  10a79a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a79e:	4638      	mov	r0, r7
  10a7a0:	9300      	str	r3, [sp, #0]
  10a7a2:	f2c0 0211 	movt	r2, #17
  10a7a6:	f240 131f 	movw	r3, #287	; 0x11f
  10a7aa:	f2c0 0111 	movt	r1, #17
  10a7ae:	f008 fff5 	bl	11379c <_panic>
        printf("hal_sec_clock_set_default clkgen creat handle failed\n");
  10a7b2:	f24a 6014 	movw	r0, #42516	; 0xa614
        return ret;
  10a7b6:	462c      	mov	r4, r5
        printf("hal_sec_clock_set_default clkgen creat handle failed\n");
  10a7b8:	f2c0 0011 	movt	r0, #17
  10a7bc:	f00a f80a 	bl	1147d4 <puts>
}
  10a7c0:	4620      	mov	r0, r4
  10a7c2:	b002      	add	sp, #8
  10a7c4:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10a7c8:	f24a 0694 	movw	r6, #41108	; 0xa094
  10a7cc:	f2c0 0611 	movt	r6, #17
  10a7d0:	f506 788a 	add.w	r8, r6, #276	; 0x114
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SEC_BASE, &bus[i]);
  10a7d4:	4632      	mov	r2, r6
  10a7d6:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  10a7da:	4628      	mov	r0, r5
  10a7dc:	f7ff ff26 	bl	10a62c <hal_clock_bus_init>
        if (!ret) goto fail;
  10a7e0:	4604      	mov	r4, r0
  10a7e2:	2800      	cmp	r0, #0
  10a7e4:	d0d0      	beq.n	10a788 <hal_sec_clock_set_default+0x34>
  10a7e6:	365c      	adds	r6, #92	; 0x5c
    for (uint8_t i = 0; i < ARRAYSIZE(bus); i++) {
  10a7e8:	4546      	cmp	r6, r8
  10a7ea:	d1f3      	bne.n	10a7d4 <hal_sec_clock_set_default+0x80>
    hal_clock_release_instance(l_clkgenInstance);
  10a7ec:	4628      	mov	r0, r5
  10a7ee:	f7ff fe7b 	bl	10a4e8 <hal_clock_release_instance>
}
  10a7f2:	4620      	mov	r0, r4
  10a7f4:	b002      	add	sp, #8
  10a7f6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10a7fa:	bf00      	nop

0010a7fc <hal_disp_clock_set_default>:
{
  10a7fc:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10a800:	46f0      	mov	r8, r14
  10a802:	b082      	sub	sp, #8
    clkgenInstance = hal_clock_get_instance();
  10a804:	f7ff fe16 	bl	10a434 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  10a808:	4605      	mov	r5, r0
  10a80a:	2800      	cmp	r0, #0
  10a80c:	d03c      	beq.n	10a888 <hal_disp_clock_set_default+0x8c>
  10a80e:	f24b 44f0 	movw	r4, #46320	; 0xb4f0
        ret = hal_clock_ip_init(handle, CFG_CKGEN_DISP_BASE, &ip[i]);
  10a812:	2600      	movs	r6, #0
  10a814:	f2c0 0411 	movt	r4, #17
  10a818:	f504 775d 	add.w	r7, r4, #884	; 0x374
  10a81c:	f2cf 6620 	movt	r6, #63008	; 0xf620
  10a820:	e002      	b.n	10a828 <hal_disp_clock_set_default+0x2c>
  10a822:	3434      	adds	r4, #52	; 0x34
    for (uint8_t i = 0; i < ARRAYSIZE(ip); i++) {
  10a824:	42a7      	cmp	r7, r4
  10a826:	d01b      	beq.n	10a860 <hal_disp_clock_set_default+0x64>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_DISP_BASE, &ip[i]);
  10a828:	4622      	mov	r2, r4
  10a82a:	4631      	mov	r1, r6
  10a82c:	4628      	mov	r0, r5
  10a82e:	f7ff fed7 	bl	10a5e0 <hal_clock_ip_init>
        if (!ret) goto fail;
  10a832:	2800      	cmp	r0, #0
  10a834:	d1f5      	bne.n	10a822 <hal_disp_clock_set_default+0x26>
    hal_clock_release_instance(l_clkgenInstance);
  10a836:	4628      	mov	r0, r5
  10a838:	f7ff fe56 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10a83c:	f24a 6310 	movw	r3, #42512	; 0xa610
  10a840:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a844:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a848:	f2c0 0311 	movt	r3, #17
  10a84c:	4640      	mov	r0, r8
  10a84e:	f2c0 0211 	movt	r2, #17
  10a852:	9300      	str	r3, [sp, #0]
  10a854:	f2c0 0111 	movt	r1, #17
  10a858:	f240 138b 	movw	r3, #395	; 0x18b
  10a85c:	f008 ff9e 	bl	11379c <_panic>
        ret = hal_clock_bus_init(handle, CFG_CKGEN_DISP_BASE, &bus[i]);
  10a860:	f24a 3218 	movw	r2, #41752	; 0xa318
  10a864:	2100      	movs	r1, #0
  10a866:	f2c0 0211 	movt	r2, #17
  10a86a:	4628      	mov	r0, r5
  10a86c:	f2cf 6120 	movt	r1, #63008	; 0xf620
  10a870:	f7ff fedc 	bl	10a62c <hal_clock_bus_init>
  10a874:	4604      	mov	r4, r0
    hal_clock_release_instance(l_clkgenInstance);
  10a876:	4628      	mov	r0, r5
  10a878:	f7ff fe36 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10a87c:	2c00      	cmp	r4, #0
  10a87e:	d0dd      	beq.n	10a83c <hal_disp_clock_set_default+0x40>
}
  10a880:	4620      	mov	r0, r4
  10a882:	b002      	add	sp, #8
  10a884:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        printf("hal_disp_clock_set_default clkgen creat handle failed\n");
  10a888:	f24a 50a0 	movw	r0, #42400	; 0xa5a0
        return ret;
  10a88c:	462c      	mov	r4, r5
        printf("hal_disp_clock_set_default clkgen creat handle failed\n");
  10a88e:	f2c0 0011 	movt	r0, #17
  10a892:	f009 ff9f 	bl	1147d4 <puts>
}
  10a896:	4620      	mov	r0, r4
  10a898:	b002      	add	sp, #8
  10a89a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10a89e:	bf00      	nop

0010a8a0 <hal_clock_core_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_core_init(void *g_handle, paddr_t phy_addr,
                         const clkgen_core_slice_t *core_slice_default)
{
  10a8a0:	b570      	push	{r4, r5, r6, r14}
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_core_slice_drv_t core_clock_drv_cfg;
    clkgen_instance_t *l_clkgenInstance = NULL;
    uint8_t core_slice_idx = core_slice_default->slice_index;
  10a8a2:	6814      	ldr	r4, [r2, #0]
{
  10a8a4:	b084      	sub	sp, #16
    ASSERT((g_handle != NULL));
  10a8a6:	b1c0      	cbz	r0, 10a8da <hal_clock_core_init+0x3a>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->core_slice_switch) {
  10a8a8:	6883      	ldr	r3, [r0, #8]
  10a8aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  10a8ac:	b33b      	cbz	r3, 10a8fe <hal_clock_core_init+0x5e>
            core_slice_default->clk_a_b_select;
        core_clock_drv_cfg.clk_src_sel_a =
            core_slice_default->clk_src_select_a_num;
        core_clock_drv_cfg.clk_src_sel_b =
            core_slice_default->clk_src_select_b_num;
        core_clock_drv_cfg.post_div = core_slice_default->post_div;
  10a8ae:	6cd6      	ldr	r6, [r2, #76]	; 0x4c
        core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  10a8b0:	b2e4      	uxtb	r4, r4
        core_clock_drv_cfg.clk_a_b_switch =
  10a8b2:	f892 5049 	ldrb.w	r5, [r2, #73]	; 0x49
        core_clock_drv_cfg.post_div = core_slice_default->post_div;
  10a8b6:	f88d 600f 	strb.w	r6, [r13, #15]
        core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  10a8ba:	9402      	str	r4, [sp, #8]

        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  10a8bc:	4608      	mov	r0, r1
        core_clock_drv_cfg.clk_src_sel_a =
  10a8be:	f892 4024 	ldrb.w	r4, [r2, #36]	; 0x24
        core_clock_drv_cfg.clk_a_b_switch =
  10a8c2:	f88d 500c 	strb.w	r5, [r13, #12]
        core_clock_drv_cfg.clk_src_sel_b =
  10a8c6:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
        core_clock_drv_cfg.clk_src_sel_a =
  10a8ca:	f88d 400d 	strb.w	r4, [r13, #13]
        core_clock_drv_cfg.clk_src_sel_b =
  10a8ce:	f88d 200e 	strb.w	r2, [r13, #14]
        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  10a8d2:	a902      	add	r1, sp, #8
  10a8d4:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_core_init not find slice_idx:%d  \n", core_slice_idx);
    return false;
}
  10a8d6:	b004      	add	sp, #16
  10a8d8:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  10a8da:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10a8de:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a8e2:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a8e6:	f2c0 0311 	movt	r3, #17
  10a8ea:	4670      	mov	r0, r14
  10a8ec:	f2c0 0211 	movt	r2, #17
  10a8f0:	9300      	str	r3, [sp, #0]
  10a8f2:	f2c0 0111 	movt	r1, #17
  10a8f6:	f240 2347 	movw	r3, #583	; 0x247
  10a8fa:	f008 ff4f 	bl	11379c <_panic>
    return false;
  10a8fe:	4618      	mov	r0, r3
  10a900:	e7e9      	b.n	10a8d6 <hal_clock_core_init+0x36>
  10a902:	bf00      	nop

0010a904 <hal_clock_uuu_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuu_init(void *g_handle, paddr_t phy_addr,
                        const clkgen_uuu_cfg_t *uuu_default)
{
  10a904:	b510      	push	{r4, r14}
  10a906:	460b      	mov	r3, r1
  10a908:	b084      	sub	sp, #16
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_gasket_type_t l_gasket_div;
    uint8_t uuu_slice_idx = uuu_default->slice_index;
  10a90a:	7811      	ldrb	r1, [r2, #0]
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10a90c:	b1b0      	cbz	r0, 10a93c <hal_clock_uuu_init+0x38>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->uuu_clock_wrapper) {
  10a90e:	6880      	ldr	r0, [r0, #8]
  10a910:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
  10a912:	b32c      	cbz	r4, 10a960 <hal_clock_uuu_init+0x5c>
        l_gasket_div.m_div_num = uuu_default->m_div;
        l_gasket_div.n_div_num = uuu_default->n_div;
        l_gasket_div.p_div_num = uuu_default->p_div;
        l_gasket_div.q_div_num = uuu_default->q_div;

        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10a914:	4618      	mov	r0, r3
        l_gasket_div.m_div_num = uuu_default->m_div;
  10a916:	7953      	ldrb	r3, [r2, #5]
  10a918:	f88d 300c 	strb.w	r3, [r13, #12]
        l_gasket_div.n_div_num = uuu_default->n_div;
  10a91c:	7993      	ldrb	r3, [r2, #6]
  10a91e:	f88d 300d 	strb.w	r3, [r13, #13]
        l_gasket_div.p_div_num = uuu_default->p_div;
  10a922:	79d3      	ldrb	r3, [r2, #7]
  10a924:	f88d 300e 	strb.w	r3, [r13, #14]
        l_gasket_div.q_div_num = uuu_default->q_div;
  10a928:	7a13      	ldrb	r3, [r2, #8]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10a92a:	7912      	ldrb	r2, [r2, #4]
        l_gasket_div.q_div_num = uuu_default->q_div;
  10a92c:	f88d 300f 	strb.w	r3, [r13, #15]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10a930:	9200      	str	r2, [sp, #0]
  10a932:	2300      	movs	r3, #0
  10a934:	aa03      	add	r2, sp, #12
  10a936:	47a0      	blx	r4
        }
    }

    LTRACEF("hal_clock_uuu_init not find slice_idx:%d  \n", uuu_slice_idx);
    return false;
}
  10a938:	b004      	add	sp, #16
  10a93a:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  10a93c:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10a940:	f24a 5240 	movw	r2, #42304	; 0xa540
  10a944:	f647 4134 	movw	r1, #31796	; 0x7c34
  10a948:	f2c0 0311 	movt	r3, #17
  10a94c:	4670      	mov	r0, r14
  10a94e:	f2c0 0211 	movt	r2, #17
  10a952:	9300      	str	r3, [sp, #0]
  10a954:	f2c0 0111 	movt	r1, #17
  10a958:	f240 2381 	movw	r3, #641	; 0x281
  10a95c:	f008 ff1e 	bl	11379c <_panic>
    return false;
  10a960:	4620      	mov	r0, r4
  10a962:	e7e9      	b.n	10a938 <hal_clock_uuu_init+0x34>

0010a964 <hal_soc_clock_set_default>:
{
  10a964:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10a968:	4677      	mov	r7, r14
  10a96a:	b082      	sub	sp, #8
    clkgenInstance = hal_clock_get_instance();
  10a96c:	f7ff fd62 	bl	10a434 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  10a970:	4605      	mov	r5, r0
  10a972:	2800      	cmp	r0, #0
  10a974:	d06b      	beq.n	10aa4e <hal_soc_clock_set_default+0xea>
  10a976:	f64b 04cc 	movw	r4, #47308	; 0xb8cc
  10a97a:	2300      	movs	r3, #0
  10a97c:	f2c0 0411 	movt	r4, #17
  10a980:	f104 0690 	add.w	r6, r4, #144	; 0x90
  10a984:	e001      	b.n	10a98a <hal_soc_clock_set_default+0x26>
  10a986:	f854 3f10 	ldr.w	r3, [r4, #16]!
        if (uuu[i].slice_index == uuu_clock_wrapper_ddr) continue;
  10a98a:	2b09      	cmp	r3, #9
  10a98c:	d007      	beq.n	10a99e <hal_soc_clock_set_default+0x3a>
        ret = hal_clock_uuu_init(handle, CFG_CKGEN_SOC_BASE, &uuu[i]);
  10a98e:	4622      	mov	r2, r4
  10a990:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10a994:	4628      	mov	r0, r5
  10a996:	f7ff ffb5 	bl	10a904 <hal_clock_uuu_init>
        if (!ret) goto fail;
  10a99a:	2800      	cmp	r0, #0
  10a99c:	d042      	beq.n	10aa24 <hal_soc_clock_set_default+0xc0>
    for (uint8_t i = 0; i < ARRAYSIZE(uuu); i++) {
  10a99e:	42a6      	cmp	r6, r4
  10a9a0:	d1f1      	bne.n	10a986 <hal_soc_clock_set_default+0x22>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SOC_BASE, &ip[i]);
  10a9a2:	f24b 4288 	movw	r2, #46216	; 0xb488
  10a9a6:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10a9aa:	4628      	mov	r0, r5
  10a9ac:	f2c0 0211 	movt	r2, #17
  10a9b0:	f7ff fe16 	bl	10a5e0 <hal_clock_ip_init>
        if (!ret) goto fail;
  10a9b4:	b3b0      	cbz	r0, 10aa24 <hal_soc_clock_set_default+0xc0>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SOC_BASE, &ip[i]);
  10a9b6:	4a2b      	ldr	r2, [pc, #172]	; (10aa64 <hal_soc_clock_set_default+0x100>)
  10a9b8:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10a9bc:	4628      	mov	r0, r5
  10a9be:	f7ff fe0f 	bl	10a5e0 <hal_clock_ip_init>
        if (!ret) goto fail;
  10a9c2:	b378      	cbz	r0, 10aa24 <hal_soc_clock_set_default+0xc0>
  10a9c4:	f24a 14a8 	movw	r4, #41384	; 0xa1a8
  10a9c8:	f2c0 0411 	movt	r4, #17
  10a9cc:	f504 78b8 	add.w	r8, r4, #368	; 0x170
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SOC_BASE, &bus[i]);
  10a9d0:	4622      	mov	r2, r4
  10a9d2:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10a9d6:	4628      	mov	r0, r5
  10a9d8:	f7ff fe28 	bl	10a62c <hal_clock_bus_init>
        if (!ret) goto fail;
  10a9dc:	4606      	mov	r6, r0
  10a9de:	b308      	cbz	r0, 10aa24 <hal_soc_clock_set_default+0xc0>
  10a9e0:	345c      	adds	r4, #92	; 0x5c
    for (uint8_t i = 0; i < ARRAYSIZE(bus); i++) {
  10a9e2:	4544      	cmp	r4, r8
  10a9e4:	d1f4      	bne.n	10a9d0 <hal_soc_clock_set_default+0x6c>
  10a9e6:	2300      	movs	r3, #0
  10a9e8:	f24a 3474 	movw	r4, #41844	; 0xa374
        if (core[i].slice_index == soc_core_slice_ddr) continue;
  10a9ec:	2b05      	cmp	r3, #5
  10a9ee:	f2c0 0411 	movt	r4, #17
  10a9f2:	f504 78b0 	add.w	r8, r4, #352	; 0x160
  10a9f6:	d006      	beq.n	10aa06 <hal_soc_clock_set_default+0xa2>
        ret = hal_clock_core_init(handle, CFG_CKGEN_SOC_BASE, &core[i]);
  10a9f8:	4622      	mov	r2, r4
  10a9fa:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10a9fe:	4628      	mov	r0, r5
  10aa00:	f7ff ff4e 	bl	10a8a0 <hal_clock_core_init>
        if (!ret) goto fail;
  10aa04:	b170      	cbz	r0, 10aa24 <hal_soc_clock_set_default+0xc0>
    for (uint8_t i = 0; i < ARRAYSIZE(core); i++) {
  10aa06:	4544      	cmp	r4, r8
  10aa08:	d005      	beq.n	10aa16 <hal_soc_clock_set_default+0xb2>
  10aa0a:	f854 3f58 	ldr.w	r3, [r4, #88]!
        if (core[i].slice_index == soc_core_slice_ddr) continue;
  10aa0e:	2b05      	cmp	r3, #5
  10aa10:	d1f2      	bne.n	10a9f8 <hal_soc_clock_set_default+0x94>
    for (uint8_t i = 0; i < ARRAYSIZE(core); i++) {
  10aa12:	4544      	cmp	r4, r8
  10aa14:	d1f9      	bne.n	10aa0a <hal_soc_clock_set_default+0xa6>
    hal_clock_release_instance(l_clkgenInstance);
  10aa16:	4628      	mov	r0, r5
  10aa18:	f7ff fd66 	bl	10a4e8 <hal_clock_release_instance>
}
  10aa1c:	4630      	mov	r0, r6
  10aa1e:	b002      	add	sp, #8
  10aa20:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    hal_clock_release_instance(l_clkgenInstance);
  10aa24:	4628      	mov	r0, r5
  10aa26:	f7ff fd5f 	bl	10a4e8 <hal_clock_release_instance>
    ASSERT(ret);
  10aa2a:	f24a 6310 	movw	r3, #42512	; 0xa610
  10aa2e:	f24a 5240 	movw	r2, #42304	; 0xa540
  10aa32:	f2c0 0311 	movt	r3, #17
  10aa36:	f647 4134 	movw	r1, #31796	; 0x7c34
  10aa3a:	4638      	mov	r0, r7
  10aa3c:	9300      	str	r3, [sp, #0]
  10aa3e:	f2c0 0211 	movt	r2, #17
  10aa42:	f44f 73b1 	mov.w	r3, #354	; 0x162
  10aa46:	f2c0 0111 	movt	r1, #17
  10aa4a:	f008 fea7 	bl	11379c <_panic>
        printf("hal_soc_clock_set_default clkgen creat handle failed\n");
  10aa4e:	f24a 604c 	movw	r0, #42572	; 0xa64c
        return ret;
  10aa52:	462e      	mov	r6, r5
        printf("hal_soc_clock_set_default clkgen creat handle failed\n");
  10aa54:	f2c0 0011 	movt	r0, #17
  10aa58:	f009 febc 	bl	1147d4 <puts>
}
  10aa5c:	4630      	mov	r0, r6
  10aa5e:	b002      	add	sp, #8
  10aa60:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10aa64:	0011b4bc 	.word	0x0011b4bc

0010aa68 <hal_clock_enable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_clock_enable(void *g_handle, uint32_t res_glb_idx)
{
  10aa68:	b510      	push	{r4, r14}
    int ret = -1;
    int32_t gating_idx = -1;
  10aa6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10aa6e:	b084      	sub	sp, #16
    int32_t gating_idx = -1;
  10aa70:	9302      	str	r3, [sp, #8]
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10aa72:	b1c0      	cbz	r0, 10aaa6 <hal_clock_enable+0x3e>
  10aa74:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &gating_idx);
  10aa76:	aa02      	add	r2, sp, #8
  10aa78:	4608      	mov	r0, r1
  10aa7a:	a903      	add	r1, sp, #12
  10aa7c:	f005 fc5a 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10aa80:	3001      	adds	r0, #1
  10aa82:	d00d      	beq.n	10aaa0 <hal_clock_enable+0x38>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    //enable clk gating
    if ((gating_idx >= DEFAULT_LPGATING_IDX_START) && (gating_idx != -1)
  10aa84:	9902      	ldr	r1, [sp, #8]
  10aa86:	29ff      	cmp	r1, #255	; 0xff
  10aa88:	dd0a      	ble.n	10aaa0 <hal_clock_enable+0x38>
            && l_clkgenInstance->controllerTable->gating_enable) {
  10aa8a:	68a3      	ldr	r3, [r4, #8]
  10aa8c:	689b      	ldr	r3, [r3, #8]
  10aa8e:	b1e3      	cbz	r3, 10aaca <hal_clock_enable+0x62>
        if (l_clkgenInstance->controllerTable->gating_enable(clkgen_base_addr,
  10aa90:	2201      	movs	r2, #1
  10aa92:	f5a1 7180 	sub.w	r1, r1, #256	; 0x100
  10aa96:	9803      	ldr	r0, [sp, #12]
  10aa98:	b289      	uxth	r1, r1
  10aa9a:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_enable res_glb_idx:0x%x enable failed\n", res_glb_idx);
    return false;
}
  10aa9c:	b004      	add	sp, #16
  10aa9e:	bd10      	pop	{r4, r15}
        return false;
  10aaa0:	2000      	movs	r0, #0
}
  10aaa2:	b004      	add	sp, #16
  10aaa4:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  10aaa6:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10aaaa:	f24a 5240 	movw	r2, #42304	; 0xa540
  10aaae:	f647 4134 	movw	r1, #31796	; 0x7c34
  10aab2:	f2c0 0311 	movt	r3, #17
  10aab6:	4670      	mov	r0, r14
  10aab8:	f2c0 0211 	movt	r2, #17
  10aabc:	9300      	str	r3, [sp, #0]
  10aabe:	f2c0 0111 	movt	r1, #17
  10aac2:	f44f 732e 	mov.w	r3, #696	; 0x2b8
  10aac6:	f008 fe69 	bl	11379c <_panic>
        return false;
  10aaca:	4618      	mov	r0, r3
  10aacc:	e7e9      	b.n	10aaa2 <hal_clock_enable+0x3a>
  10aace:	bf00      	nop

0010aad0 <hal_clock_disable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_clock_disable(void *g_handle, uint32_t res_glb_idx)
{
  10aad0:	b510      	push	{r4, r14}
    int ret = -1;
    int32_t gating_idx = -1;
  10aad2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10aad6:	b084      	sub	sp, #16
    int32_t gating_idx = -1;
  10aad8:	9302      	str	r3, [sp, #8]
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10aada:	b1c0      	cbz	r0, 10ab0e <hal_clock_disable+0x3e>
  10aadc:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &gating_idx);
  10aade:	aa02      	add	r2, sp, #8
  10aae0:	4608      	mov	r0, r1
  10aae2:	a903      	add	r1, sp, #12
  10aae4:	f005 fc26 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10aae8:	3001      	adds	r0, #1
  10aaea:	d00d      	beq.n	10ab08 <hal_clock_disable+0x38>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    //enable clk gating
    if ((gating_idx != -1) && (gating_idx >= DEFAULT_LPGATING_IDX_START)
  10aaec:	9902      	ldr	r1, [sp, #8]
  10aaee:	29ff      	cmp	r1, #255	; 0xff
  10aaf0:	dd0a      	ble.n	10ab08 <hal_clock_disable+0x38>
            && l_clkgenInstance->controllerTable->gating_enable) {
  10aaf2:	68a3      	ldr	r3, [r4, #8]
  10aaf4:	689b      	ldr	r3, [r3, #8]
  10aaf6:	b1e3      	cbz	r3, 10ab32 <hal_clock_disable+0x62>
        if (l_clkgenInstance->controllerTable->gating_enable(clkgen_base_addr,
  10aaf8:	2200      	movs	r2, #0
  10aafa:	f5a1 7180 	sub.w	r1, r1, #256	; 0x100
  10aafe:	9803      	ldr	r0, [sp, #12]
  10ab00:	b289      	uxth	r1, r1
  10ab02:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_disable res_glb_idx:0x%x enable failed\n", res_glb_idx);
    return false;
}
  10ab04:	b004      	add	sp, #16
  10ab06:	bd10      	pop	{r4, r15}
        return false;
  10ab08:	2000      	movs	r0, #0
}
  10ab0a:	b004      	add	sp, #16
  10ab0c:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  10ab0e:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ab12:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ab16:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ab1a:	f2c0 0311 	movt	r3, #17
  10ab1e:	4670      	mov	r0, r14
  10ab20:	f2c0 0211 	movt	r2, #17
  10ab24:	9300      	str	r3, [sp, #0]
  10ab26:	f2c0 0111 	movt	r1, #17
  10ab2a:	f240 23e5 	movw	r3, #741	; 0x2e5
  10ab2e:	f008 fe35 	bl	11379c <_panic>
        return false;
  10ab32:	4618      	mov	r0, r3
  10ab34:	e7e9      	b.n	10ab0a <hal_clock_disable+0x3a>
  10ab36:	bf00      	nop

0010ab38 <hal_clock_ipclk_get>:
//! \return clock value = (reg_value*ref_clk_type)*(ref_clk_div + 1)
//
//*****************************************************************************
uint32_t hal_clock_ipclk_get(void *g_handle, uint32_t res_glb_idx,
                             clkgen_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div)
{
  10ab38:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    clkgen_slice_mon_ret_type ret_type = mon_avg_freq;
    int32_t ip_slice_idx = -1;
  10ab3a:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
{
  10ab3e:	b085      	sub	sp, #20
    int32_t ip_slice_idx = -1;
  10ab40:	9603      	str	r6, [sp, #12]
    uint32_t clk_reg_vaule = 0;
    uint32_t clk_vaule = 0;
    ASSERT((g_handle != NULL));
  10ab42:	b378      	cbz	r0, 10aba4 <hal_clock_ipclk_get+0x6c>
  10ab44:	4617      	mov	r7, r2
  10ab46:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &ip_slice_idx);
  10ab48:	4608      	mov	r0, r1
  10ab4a:	aa03      	add	r2, sp, #12
  10ab4c:	461c      	mov	r4, r3
  10ab4e:	a902      	add	r1, sp, #8
  10ab50:	f005 fbf0 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ab54:	3001      	adds	r0, #1
        LTRACEF("hal_clock_ipclk_get res_glb_idx:0x%x is not find\n", res_glb_idx);
        return false;
  10ab56:	bf08      	it	eq
  10ab58:	2000      	moveq	r0, #0
    if (ret == -1) {
  10ab5a:	d017      	beq.n	10ab8c <hal_clock_ipclk_get+0x54>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10ab5c:	9903      	ldr	r1, [sp, #12]
  10ab5e:	2900      	cmp	r1, #0
    uint32_t clk_reg_vaule = 0;
  10ab60:	bfb8      	it	lt
  10ab62:	2000      	movlt	r0, #0
    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10ab64:	db09      	blt.n	10ab7a <hal_clock_ipclk_get+0x42>
            && l_clkgenInstance->controllerTable->mon_ip_slice) {
  10ab66:	68ab      	ldr	r3, [r5, #8]
  10ab68:	6b1d      	ldr	r5, [r3, #48]	; 0x30
  10ab6a:	b36d      	cbz	r5, 10abc8 <hal_clock_ipclk_get+0x90>
        //get clk
        clk_reg_vaule = l_clkgenInstance->controllerTable->mon_ip_slice(
  10ab6c:	2201      	movs	r2, #1
  10ab6e:	b289      	uxth	r1, r1
  10ab70:	9802      	ldr	r0, [sp, #8]
  10ab72:	4623      	mov	r3, r4
  10ab74:	9200      	str	r2, [sp, #0]
  10ab76:	463a      	mov	r2, r7
  10ab78:	47a8      	blx	r5
  10ab7a:	3401      	adds	r4, #1
                            clkgen_base_addr, ip_slice_idx - DEFAULT_IPSLICE_IDX_START, ref_clk_type,
                            ref_clk_div, ret_type);
    }

    if (mon_ref_clk_24M == ref_clk_type) {
  10ab7c:	b147      	cbz	r7, 10ab90 <hal_clock_ipclk_get+0x58>
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
    }
    else {
        clk_vaule = (clk_reg_vaule * 32 * 1000) * (ref_clk_div + 1);
  10ab7e:	ebc4 1344 	rsb	r3, r4, r4, lsl #5
  10ab82:	eb04 0483 	add.w	r4, r4, r3, lsl #2
  10ab86:	0224      	lsls	r4, r4, #8
  10ab88:	fb00 f004 	mul.w	r0, r0, r4

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_ipclk_get clk_reg_vaule:%d,ref_clk_type:%d, ret:%d\n",
                  clk_reg_vaule, ref_clk_type, clk_vaule);
    return clk_vaule;
}
  10ab8c:	b005      	add	sp, #20
  10ab8e:	bdf0      	pop	{r4, r5, r6, r7, r15}
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
  10ab90:	f44f 5358 	mov.w	r3, #13824	; 0x3600
  10ab94:	f2c0 136e 	movt	r3, #366	; 0x16e
  10ab98:	fb03 f404 	mul.w	r4, r3, r4
  10ab9c:	fb00 f004 	mul.w	r0, r0, r4
}
  10aba0:	b005      	add	sp, #20
  10aba2:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10aba4:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10aba8:	f24a 5240 	movw	r2, #42304	; 0xa540
  10abac:	f647 4134 	movw	r1, #31796	; 0x7c34
  10abb0:	f2c0 0311 	movt	r3, #17
  10abb4:	4670      	mov	r0, r14
  10abb6:	f2c0 0211 	movt	r2, #17
  10abba:	9300      	str	r3, [sp, #0]
  10abbc:	f2c0 0111 	movt	r1, #17
  10abc0:	f240 3349 	movw	r3, #841	; 0x349
  10abc4:	f008 fdea 	bl	11379c <_panic>
    uint32_t clk_reg_vaule = 0;
  10abc8:	4628      	mov	r0, r5
  10abca:	e7d6      	b.n	10ab7a <hal_clock_ipclk_get+0x42>

0010abcc <hal_clock_ipctl_get>:
bool hal_clock_ipctl_get(void *g_handle, uint32_t res_glb_idx,
                         clkgen_ip_ctl *ctl)
{
  10abcc:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10abce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10abd2:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10abd4:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10abd6:	b1b0      	cbz	r0, 10ac06 <hal_clock_ipctl_get+0x3a>
  10abd8:	4615      	mov	r5, r2
  10abda:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10abdc:	4608      	mov	r0, r1
  10abde:	aa03      	add	r2, sp, #12
  10abe0:	a902      	add	r1, sp, #8
  10abe2:	f005 fba7 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10abe6:	3001      	adds	r0, #1
  10abe8:	d00a      	beq.n	10ac00 <hal_clock_ipctl_get+0x34>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10abea:	9903      	ldr	r1, [sp, #12]
  10abec:	2900      	cmp	r1, #0
  10abee:	db07      	blt.n	10ac00 <hal_clock_ipctl_get+0x34>
            && l_clkgenInstance->controllerTable->ip_ctl_get) {
  10abf0:	68a3      	ldr	r3, [r4, #8]
  10abf2:	691b      	ldr	r3, [r3, #16]
  10abf4:	b123      	cbz	r3, 10ac00 <hal_clock_ipctl_get+0x34>
        slice_idx -= DEFAULT_IPSLICE_IDX_START;
        ret = l_clkgenInstance->controllerTable->ip_ctl_get(
  10abf6:	9802      	ldr	r0, [sp, #8]
  10abf8:	462a      	mov	r2, r5
  10abfa:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10abfc:	b005      	add	sp, #20
  10abfe:	bd30      	pop	{r4, r5, r15}
        return false;
  10ac00:	2000      	movs	r0, #0
}
  10ac02:	b005      	add	sp, #20
  10ac04:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10ac06:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ac0a:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ac0e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ac12:	f2c0 0311 	movt	r3, #17
  10ac16:	4670      	mov	r0, r14
  10ac18:	f2c0 0211 	movt	r2, #17
  10ac1c:	9300      	str	r3, [sp, #0]
  10ac1e:	f2c0 0111 	movt	r1, #17
  10ac22:	f44f 735c 	mov.w	r3, #880	; 0x370
  10ac26:	f008 fdb9 	bl	11379c <_panic>
  10ac2a:	bf00      	nop

0010ac2c <hal_clock_ipctl_set>:

bool hal_clock_ipctl_set(void *g_handle, uint32_t res_glb_idx,
                         const clkgen_ip_ctl *ctl)
{
  10ac2c:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10ac2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10ac32:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10ac34:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10ac36:	b1b0      	cbz	r0, 10ac66 <hal_clock_ipctl_set+0x3a>
  10ac38:	4615      	mov	r5, r2
  10ac3a:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10ac3c:	4608      	mov	r0, r1
  10ac3e:	aa03      	add	r2, sp, #12
  10ac40:	a902      	add	r1, sp, #8
  10ac42:	f005 fb77 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ac46:	3001      	adds	r0, #1
  10ac48:	d00a      	beq.n	10ac60 <hal_clock_ipctl_set+0x34>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10ac4a:	9903      	ldr	r1, [sp, #12]
  10ac4c:	2900      	cmp	r1, #0
  10ac4e:	db07      	blt.n	10ac60 <hal_clock_ipctl_set+0x34>
            && l_clkgenInstance->controllerTable->ip_ctl_set) {
  10ac50:	68a3      	ldr	r3, [r4, #8]
  10ac52:	695b      	ldr	r3, [r3, #20]
  10ac54:	b123      	cbz	r3, 10ac60 <hal_clock_ipctl_set+0x34>
        slice_idx -= DEFAULT_IPSLICE_IDX_START;
        ret = l_clkgenInstance->controllerTable->ip_ctl_set(
  10ac56:	9802      	ldr	r0, [sp, #8]
  10ac58:	462a      	mov	r2, r5
  10ac5a:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10ac5c:	b005      	add	sp, #20
  10ac5e:	bd30      	pop	{r4, r5, r15}
        return false;
  10ac60:	2000      	movs	r0, #0
}
  10ac62:	b005      	add	sp, #20
  10ac64:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10ac66:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ac6a:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ac6e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ac72:	f2c0 0311 	movt	r3, #17
  10ac76:	4670      	mov	r0, r14
  10ac78:	f2c0 0211 	movt	r2, #17
  10ac7c:	9300      	str	r3, [sp, #0]
  10ac7e:	f2c0 0111 	movt	r1, #17
  10ac82:	f240 338f 	movw	r3, #911	; 0x38f
  10ac86:	f008 fd89 	bl	11379c <_panic>
  10ac8a:	bf00      	nop

0010ac8c <hal_clock_busclk_get>:
//! \return clock value = (reg_value*ref_clk_type)*(ref_clk_div + 1)
//
//*****************************************************************************
uint32_t hal_clock_busclk_get(void *g_handle, uint32_t res_glb_idx,
                              clkgen_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div)
{
  10ac8c:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    clkgen_slice_mon_ret_type ret_type = mon_avg_freq;
    int32_t bus_slice_idx = -1;
  10ac8e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
  10ac92:	b085      	sub	sp, #20
    int32_t bus_slice_idx = -1;
  10ac94:	9703      	str	r7, [sp, #12]
    uint32_t clk_reg_vaule = 0;
    uint32_t clk_vaule = 0;
    ASSERT((g_handle != NULL));
  10ac96:	b388      	cbz	r0, 10acfc <hal_clock_busclk_get+0x70>
  10ac98:	4616      	mov	r6, r2
  10ac9a:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &bus_slice_idx);
  10ac9c:	4608      	mov	r0, r1
  10ac9e:	aa03      	add	r2, sp, #12
  10aca0:	461c      	mov	r4, r3
  10aca2:	a902      	add	r1, sp, #8
  10aca4:	f005 fb46 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10aca8:	3001      	adds	r0, #1
        LTRACEF("hal_clock_busclk_get res_glb_idx:0x%x is not find\n",
                res_glb_idx);
        return false;
  10acaa:	bf08      	it	eq
  10acac:	2000      	moveq	r0, #0
    if (ret == -1) {
  10acae:	d019      	beq.n	10ace4 <hal_clock_busclk_get+0x58>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((bus_slice_idx != -1) && (bus_slice_idx >= DEFAULT_BUSSLICE_IDX_START)
  10acb0:	9903      	ldr	r1, [sp, #12]
  10acb2:	297f      	cmp	r1, #127	; 0x7f
    uint32_t clk_reg_vaule = 0;
  10acb4:	bfd8      	it	le
  10acb6:	2000      	movle	r0, #0
    if ((bus_slice_idx != -1) && (bus_slice_idx >= DEFAULT_BUSSLICE_IDX_START)
  10acb8:	dd0b      	ble.n	10acd2 <hal_clock_busclk_get+0x46>
            && l_clkgenInstance->controllerTable->mon_bus_slice) {
  10acba:	68ab      	ldr	r3, [r5, #8]
  10acbc:	6b5d      	ldr	r5, [r3, #52]	; 0x34
  10acbe:	b37d      	cbz	r5, 10ad20 <hal_clock_busclk_get+0x94>
        //get clk
        clk_reg_vaule = l_clkgenInstance->controllerTable->mon_bus_slice(
  10acc0:	2301      	movs	r3, #1
                            clkgen_base_addr, (bus_slice_idx - DEFAULT_BUSSLICE_IDX_START) / 2,
  10acc2:	3980      	subs	r1, #128	; 0x80
        clk_reg_vaule = l_clkgenInstance->controllerTable->mon_bus_slice(
  10acc4:	9802      	ldr	r0, [sp, #8]
  10acc6:	f3c1 014f 	ubfx	r1, r1, #1, #16
  10acca:	9300      	str	r3, [sp, #0]
  10accc:	4632      	mov	r2, r6
  10acce:	4623      	mov	r3, r4
  10acd0:	47a8      	blx	r5
  10acd2:	1c63      	adds	r3, r4, #1
                            ref_clk_type, ref_clk_div, ret_type);
    }

    if (mon_ref_clk_24M == ref_clk_type) {
  10acd4:	b146      	cbz	r6, 10ace8 <hal_clock_busclk_get+0x5c>
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
    }
    else {
        clk_vaule = (clk_reg_vaule * 32 * 1000) * (ref_clk_div + 1);
  10acd6:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
  10acda:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  10acde:	021b      	lsls	r3, r3, #8
  10ace0:	fb00 f003 	mul.w	r0, r0, r3

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_busclk_get clk_reg_vaule:%d,ref_clk_type:%d, ret:%d\n",
                  clk_reg_vaule, ref_clk_type, clk_vaule);
    return clk_vaule;
}
  10ace4:	b005      	add	sp, #20
  10ace6:	bdf0      	pop	{r4, r5, r6, r7, r15}
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
  10ace8:	f44f 5258 	mov.w	r2, #13824	; 0x3600
  10acec:	f2c0 126e 	movt	r2, #366	; 0x16e
  10acf0:	fb02 f303 	mul.w	r3, r2, r3
  10acf4:	fb00 f003 	mul.w	r0, r0, r3
}
  10acf8:	b005      	add	sp, #20
  10acfa:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10acfc:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ad00:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ad04:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ad08:	f2c0 0311 	movt	r3, #17
  10ad0c:	4670      	mov	r0, r14
  10ad0e:	f2c0 0211 	movt	r2, #17
  10ad12:	9300      	str	r3, [sp, #0]
  10ad14:	f2c0 0111 	movt	r1, #17
  10ad18:	f240 4306 	movw	r3, #1030	; 0x406
  10ad1c:	f008 fd3e 	bl	11379c <_panic>
    uint32_t clk_reg_vaule = 0;
  10ad20:	4628      	mov	r0, r5
  10ad22:	e7d6      	b.n	10acd2 <hal_clock_busclk_get+0x46>

0010ad24 <hal_clock_busctl_get>:

bool hal_clock_busctl_get(void *g_handle, uint32_t res_glb_idx,
                          clkgen_bus_ctl *ctl, clkgen_bus_gasket *gasket)
{
  10ad24:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10ad26:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
{
  10ad2a:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10ad2c:	9503      	str	r5, [sp, #12]
    ASSERT((g_handle != NULL));
  10ad2e:	b1d8      	cbz	r0, 10ad68 <hal_clock_busctl_get+0x44>
  10ad30:	4616      	mov	r6, r2
  10ad32:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10ad34:	4608      	mov	r0, r1
  10ad36:	aa03      	add	r2, sp, #12
  10ad38:	461f      	mov	r7, r3
  10ad3a:	a902      	add	r1, sp, #8
  10ad3c:	f005 fafa 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ad40:	3001      	adds	r0, #1
  10ad42:	d00e      	beq.n	10ad62 <hal_clock_busctl_get+0x3e>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_BUSSLICE_IDX_START)
  10ad44:	9903      	ldr	r1, [sp, #12]
  10ad46:	297f      	cmp	r1, #127	; 0x7f
  10ad48:	dd0b      	ble.n	10ad62 <hal_clock_busctl_get+0x3e>
            && l_clkgenInstance->controllerTable->bus_ctl_get) {
  10ad4a:	68a3      	ldr	r3, [r4, #8]
  10ad4c:	69dc      	ldr	r4, [r3, #28]
  10ad4e:	b144      	cbz	r4, 10ad62 <hal_clock_busctl_get+0x3e>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10ad50:	9802      	ldr	r0, [sp, #8]
        slice_idx = (slice_idx - DEFAULT_BUSSLICE_IDX_START) / 2;
  10ad52:	3980      	subs	r1, #128	; 0x80
        ret = l_clkgenInstance->controllerTable->bus_ctl_get(
  10ad54:	463b      	mov	r3, r7
  10ad56:	4632      	mov	r2, r6
        slice_idx = (slice_idx - DEFAULT_BUSSLICE_IDX_START) / 2;
  10ad58:	1049      	asrs	r1, r1, #1
  10ad5a:	9103      	str	r1, [sp, #12]
        ret = l_clkgenInstance->controllerTable->bus_ctl_get(
  10ad5c:	47a0      	blx	r4
                  clkgen_base_addr, slice_idx, ctl, gasket);
    }

    return ret;
}
  10ad5e:	b005      	add	sp, #20
  10ad60:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return false;
  10ad62:	2000      	movs	r0, #0
}
  10ad64:	b005      	add	sp, #20
  10ad66:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10ad68:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ad6c:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ad70:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ad74:	f2c0 0311 	movt	r3, #17
  10ad78:	4670      	mov	r0, r14
  10ad7a:	f2c0 0211 	movt	r2, #17
  10ad7e:	9300      	str	r3, [sp, #0]
  10ad80:	f2c0 0111 	movt	r1, #17
  10ad84:	f240 432f 	movw	r3, #1071	; 0x42f
  10ad88:	f008 fd08 	bl	11379c <_panic>

0010ad8c <hal_clock_busctl_set>:

bool hal_clock_busctl_set(void *g_handle, uint32_t res_glb_idx,
                          const clkgen_bus_ctl *ctl, const clkgen_bus_gasket *gasket)
{
  10ad8c:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10ad8e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
{
  10ad92:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10ad94:	9503      	str	r5, [sp, #12]
    ASSERT((g_handle != NULL));
  10ad96:	b1d8      	cbz	r0, 10add0 <hal_clock_busctl_set+0x44>
  10ad98:	4616      	mov	r6, r2
  10ad9a:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10ad9c:	4608      	mov	r0, r1
  10ad9e:	aa03      	add	r2, sp, #12
  10ada0:	461f      	mov	r7, r3
  10ada2:	a902      	add	r1, sp, #8
  10ada4:	f005 fac6 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ada8:	3001      	adds	r0, #1
  10adaa:	d00e      	beq.n	10adca <hal_clock_busctl_set+0x3e>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_BUSSLICE_IDX_START)
  10adac:	9903      	ldr	r1, [sp, #12]
  10adae:	297f      	cmp	r1, #127	; 0x7f
  10adb0:	dd0b      	ble.n	10adca <hal_clock_busctl_set+0x3e>
            && l_clkgenInstance->controllerTable->bus_ctl_set) {
  10adb2:	68a3      	ldr	r3, [r4, #8]
  10adb4:	6a1c      	ldr	r4, [r3, #32]
  10adb6:	b144      	cbz	r4, 10adca <hal_clock_busctl_set+0x3e>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10adb8:	9802      	ldr	r0, [sp, #8]
        slice_idx = (slice_idx - DEFAULT_BUSSLICE_IDX_START) / 2;
  10adba:	3980      	subs	r1, #128	; 0x80
        ret = l_clkgenInstance->controllerTable->bus_ctl_set(
  10adbc:	463b      	mov	r3, r7
  10adbe:	4632      	mov	r2, r6
        slice_idx = (slice_idx - DEFAULT_BUSSLICE_IDX_START) / 2;
  10adc0:	1049      	asrs	r1, r1, #1
  10adc2:	9103      	str	r1, [sp, #12]
        ret = l_clkgenInstance->controllerTable->bus_ctl_set(
  10adc4:	47a0      	blx	r4
                  clkgen_base_addr, slice_idx, ctl, gasket);
    }

    return ret;
}
  10adc6:	b005      	add	sp, #20
  10adc8:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return false;
  10adca:	2000      	movs	r0, #0
}
  10adcc:	b005      	add	sp, #20
  10adce:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10add0:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10add4:	f24a 5240 	movw	r2, #42304	; 0xa540
  10add8:	f647 4134 	movw	r1, #31796	; 0x7c34
  10addc:	f2c0 0311 	movt	r3, #17
  10ade0:	4670      	mov	r0, r14
  10ade2:	f2c0 0211 	movt	r2, #17
  10ade6:	9300      	str	r3, [sp, #0]
  10ade8:	f2c0 0111 	movt	r1, #17
  10adec:	f240 434e 	movw	r3, #1102	; 0x44e
  10adf0:	f008 fcd4 	bl	11379c <_panic>

0010adf4 <hal_clock_coreclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_coreclk_set(void *g_handle, uint32_t res_glb_idx,
                           clkgen_app_core_cfg_t *core_app_cfg)
{
  10adf4:	b570      	push	{r4, r5, r6, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t core_slice_idx = -1;
  10adf6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10adfa:	b086      	sub	sp, #24
    int32_t core_slice_idx = -1;
  10adfc:	9303      	str	r3, [sp, #12]
    clkgen_core_slice_drv_t core_clock_drv_cfg;
    ASSERT((g_handle != NULL));
  10adfe:	b328      	cbz	r0, 10ae4c <hal_clock_coreclk_set+0x58>
  10ae00:	4614      	mov	r4, r2
  10ae02:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &core_slice_idx);
  10ae04:	4608      	mov	r0, r1
  10ae06:	aa03      	add	r2, sp, #12
  10ae08:	a902      	add	r1, sp, #8
  10ae0a:	f005 fa93 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ae0e:	3001      	adds	r0, #1
  10ae10:	d019      	beq.n	10ae46 <hal_clock_coreclk_set+0x52>
        return false;
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    //user config
    core_slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10ae12:	9b03      	ldr	r3, [sp, #12]
    core_clock_drv_cfg.core_slice_idx = core_slice_idx;
    core_clock_drv_cfg.clk_a_b_switch = core_app_cfg->clk_a_b_select;
  10ae14:	78a0      	ldrb	r0, [r4, #2]
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
    core_clock_drv_cfg.post_div = core_app_cfg->post_div;
  10ae16:	6866      	ldr	r6, [r4, #4]
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
  10ae18:	7821      	ldrb	r1, [r4, #0]
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
  10ae1a:	7862      	ldrb	r2, [r4, #1]
    core_clock_drv_cfg.clk_a_b_switch = core_app_cfg->clk_a_b_select;
  10ae1c:	f88d 0014 	strb.w	r0, [r13, #20]
    core_clock_drv_cfg.post_div = core_app_cfg->post_div;
  10ae20:	f88d 6017 	strb.w	r6, [r13, #23]
    core_slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10ae24:	3bc0      	subs	r3, #192	; 0xc0
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
  10ae26:	f88d 1015 	strb.w	r1, [r13, #21]

    if ((core_slice_idx != -1) && (core_slice_idx >= 0)
  10ae2a:	2b00      	cmp	r3, #0
    core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  10ae2c:	e9cd 3303 	strd	r3, r3, [r13, #12]
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
  10ae30:	f88d 2016 	strb.w	r2, [r13, #22]
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10ae34:	9802      	ldr	r0, [sp, #8]
    if ((core_slice_idx != -1) && (core_slice_idx >= 0)
  10ae36:	db06      	blt.n	10ae46 <hal_clock_coreclk_set+0x52>
            && l_clkgenInstance->controllerTable->core_slice_switch) {
  10ae38:	68ab      	ldr	r3, [r5, #8]
  10ae3a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  10ae3c:	b11b      	cbz	r3, 10ae46 <hal_clock_coreclk_set+0x52>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  10ae3e:	a904      	add	r1, sp, #16
  10ae40:	4798      	blx	r3
    }

    LTRACEF("hal_clock_coreclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, core_slice_idx);
    return false;
}
  10ae42:	b006      	add	sp, #24
  10ae44:	bd70      	pop	{r4, r5, r6, r15}
        return false;
  10ae46:	2000      	movs	r0, #0
}
  10ae48:	b006      	add	sp, #24
  10ae4a:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  10ae4c:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10ae50:	f24a 5240 	movw	r2, #42304	; 0xa540
  10ae54:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ae58:	f2c0 0311 	movt	r3, #17
  10ae5c:	4670      	mov	r0, r14
  10ae5e:	f2c0 0211 	movt	r2, #17
  10ae62:	9300      	str	r3, [sp, #0]
  10ae64:	f2c0 0111 	movt	r1, #17
  10ae68:	f240 437f 	movw	r3, #1151	; 0x47f
  10ae6c:	f008 fc96 	bl	11379c <_panic>

0010ae70 <hal_clock_coreclk_get>:
//! \return clock value = (reg_value*ref_clk_type) * (ref_clk_div + 1)
//
//*****************************************************************************
uint32_t hal_clock_coreclk_get(void *g_handle, uint32_t res_glb_idx,
                               clkgen_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div)
{
  10ae70:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    clkgen_slice_mon_ret_type ret_type = mon_avg_freq;
    int32_t core_slice_idx = -1;
  10ae72:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
{
  10ae76:	b085      	sub	sp, #20
    int32_t core_slice_idx = -1;
  10ae78:	9703      	str	r7, [sp, #12]
    uint32_t clk_reg_vaule = 0;
    uint32_t clk_vaule = 0;
    ASSERT((g_handle != NULL));
  10ae7a:	b380      	cbz	r0, 10aede <hal_clock_coreclk_get+0x6e>
  10ae7c:	4616      	mov	r6, r2
  10ae7e:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &core_slice_idx);
  10ae80:	4608      	mov	r0, r1
  10ae82:	aa03      	add	r2, sp, #12
  10ae84:	461c      	mov	r4, r3
  10ae86:	a902      	add	r1, sp, #8
  10ae88:	f005 fa54 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10ae8c:	3001      	adds	r0, #1
        LTRACEF("hal_clock_coreclk_get res_glb_idx:0x%x is not find\n",
                res_glb_idx);
        return false;
  10ae8e:	bf08      	it	eq
  10ae90:	2000      	moveq	r0, #0
    if (ret == -1) {
  10ae92:	d018      	beq.n	10aec6 <hal_clock_coreclk_get+0x56>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((core_slice_idx != -1)
            && (core_slice_idx >= DEFAULT_CORESLICE_IDX_START)
  10ae94:	9903      	ldr	r1, [sp, #12]
    if ((core_slice_idx != -1)
  10ae96:	29bf      	cmp	r1, #191	; 0xbf
    uint32_t clk_reg_vaule = 0;
  10ae98:	bfd8      	it	le
  10ae9a:	2000      	movle	r0, #0
    if ((core_slice_idx != -1)
  10ae9c:	dd0a      	ble.n	10aeb4 <hal_clock_coreclk_get+0x44>
            && l_clkgenInstance->controllerTable->mon_core_slice) {
  10ae9e:	68ab      	ldr	r3, [r5, #8]
  10aea0:	6b9d      	ldr	r5, [r3, #56]	; 0x38
  10aea2:	b375      	cbz	r5, 10af02 <hal_clock_coreclk_get+0x92>
        //get clk
        clk_reg_vaule = l_clkgenInstance->controllerTable->mon_core_slice(
  10aea4:	2201      	movs	r2, #1
  10aea6:	39c0      	subs	r1, #192	; 0xc0
  10aea8:	9802      	ldr	r0, [sp, #8]
  10aeaa:	4623      	mov	r3, r4
  10aeac:	9200      	str	r2, [sp, #0]
  10aeae:	b289      	uxth	r1, r1
  10aeb0:	4632      	mov	r2, r6
  10aeb2:	47a8      	blx	r5
  10aeb4:	1c63      	adds	r3, r4, #1
                            clkgen_base_addr, core_slice_idx - DEFAULT_CORESLICE_IDX_START,
                            ref_clk_type, ref_clk_div, ret_type);
    }

    if (mon_ref_clk_24M == ref_clk_type) {
  10aeb6:	b146      	cbz	r6, 10aeca <hal_clock_coreclk_get+0x5a>
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
    }
    else {
        clk_vaule = (clk_reg_vaule * 32 * 1000) * (ref_clk_div + 1);
  10aeb8:	ebc3 1243 	rsb	r2, r3, r3, lsl #5
  10aebc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  10aec0:	021b      	lsls	r3, r3, #8
  10aec2:	fb00 f003 	mul.w	r0, r0, r3

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_coreclk_get clk_reg_vaule:%d,ref_clk_type:%d, ret:%d\n",
                  clk_reg_vaule, ref_clk_type, clk_vaule);
    return clk_vaule;
}
  10aec6:	b005      	add	sp, #20
  10aec8:	bdf0      	pop	{r4, r5, r6, r7, r15}
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
  10aeca:	f44f 5258 	mov.w	r2, #13824	; 0x3600
  10aece:	f2c0 126e 	movt	r2, #366	; 0x16e
  10aed2:	fb02 f303 	mul.w	r3, r2, r3
  10aed6:	fb00 f003 	mul.w	r0, r0, r3
}
  10aeda:	b005      	add	sp, #20
  10aedc:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  10aede:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10aee2:	f24a 5240 	movw	r2, #42304	; 0xa540
  10aee6:	f647 4134 	movw	r1, #31796	; 0x7c34
  10aeea:	f2c0 0311 	movt	r3, #17
  10aeee:	4670      	mov	r0, r14
  10aef0:	f2c0 0211 	movt	r2, #17
  10aef4:	9300      	str	r3, [sp, #0]
  10aef6:	f2c0 0111 	movt	r1, #17
  10aefa:	f240 43bb 	movw	r3, #1211	; 0x4bb
  10aefe:	f008 fc4d 	bl	11379c <_panic>
    uint32_t clk_reg_vaule = 0;
  10af02:	4628      	mov	r0, r5
  10af04:	e7d6      	b.n	10aeb4 <hal_clock_coreclk_get+0x44>
  10af06:	bf00      	nop

0010af08 <hal_clock_corectl_get>:
bool hal_clock_corectl_get(void *g_handle, uint32_t res_glb_idx,
                           clkgen_core_ctl *ctl)
{
  10af08:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10af0a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10af0e:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10af10:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10af12:	b1c8      	cbz	r0, 10af48 <hal_clock_corectl_get+0x40>
  10af14:	4615      	mov	r5, r2
  10af16:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10af18:	4608      	mov	r0, r1
  10af1a:	aa03      	add	r2, sp, #12
  10af1c:	a902      	add	r1, sp, #8
  10af1e:	f005 fa09 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10af22:	3001      	adds	r0, #1
  10af24:	d00d      	beq.n	10af42 <hal_clock_corectl_get+0x3a>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_CORESLICE_IDX_START)
  10af26:	9a03      	ldr	r2, [sp, #12]
  10af28:	2abf      	cmp	r2, #191	; 0xbf
  10af2a:	dd0a      	ble.n	10af42 <hal_clock_corectl_get+0x3a>
            && l_clkgenInstance->controllerTable->core_ctl_get) {
  10af2c:	68a3      	ldr	r3, [r4, #8]
  10af2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  10af30:	b13b      	cbz	r3, 10af42 <hal_clock_corectl_get+0x3a>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10af32:	9802      	ldr	r0, [sp, #8]
        slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10af34:	3ac0      	subs	r2, #192	; 0xc0
        ret = l_clkgenInstance->controllerTable->core_ctl_get(
  10af36:	4611      	mov	r1, r2
        slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10af38:	9203      	str	r2, [sp, #12]
        ret = l_clkgenInstance->controllerTable->core_ctl_get(
  10af3a:	462a      	mov	r2, r5
  10af3c:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10af3e:	b005      	add	sp, #20
  10af40:	bd30      	pop	{r4, r5, r15}
        return false;
  10af42:	2000      	movs	r0, #0
}
  10af44:	b005      	add	sp, #20
  10af46:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10af48:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10af4c:	f24a 5240 	movw	r2, #42304	; 0xa540
  10af50:	f647 4134 	movw	r1, #31796	; 0x7c34
  10af54:	f2c0 0311 	movt	r3, #17
  10af58:	4670      	mov	r0, r14
  10af5a:	f2c0 0211 	movt	r2, #17
  10af5e:	9300      	str	r3, [sp, #0]
  10af60:	f2c0 0111 	movt	r1, #17
  10af64:	f240 43e4 	movw	r3, #1252	; 0x4e4
  10af68:	f008 fc18 	bl	11379c <_panic>

0010af6c <hal_clock_corectl_set>:

bool hal_clock_corectl_set(void *g_handle, uint32_t res_glb_idx,
                           const clkgen_core_ctl *ctl)
{
  10af6c:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10af6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10af72:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10af74:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10af76:	b1c8      	cbz	r0, 10afac <hal_clock_corectl_set+0x40>
  10af78:	4615      	mov	r5, r2
  10af7a:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10af7c:	4608      	mov	r0, r1
  10af7e:	aa03      	add	r2, sp, #12
  10af80:	a902      	add	r1, sp, #8
  10af82:	f005 f9d7 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10af86:	3001      	adds	r0, #1
  10af88:	d00d      	beq.n	10afa6 <hal_clock_corectl_set+0x3a>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_CORESLICE_IDX_START)
  10af8a:	9a03      	ldr	r2, [sp, #12]
  10af8c:	2abf      	cmp	r2, #191	; 0xbf
  10af8e:	dd0a      	ble.n	10afa6 <hal_clock_corectl_set+0x3a>
            && l_clkgenInstance->controllerTable->core_ctl_set) {
  10af90:	68a3      	ldr	r3, [r4, #8]
  10af92:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  10af94:	b13b      	cbz	r3, 10afa6 <hal_clock_corectl_set+0x3a>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10af96:	9802      	ldr	r0, [sp, #8]
        slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10af98:	3ac0      	subs	r2, #192	; 0xc0
        ret = l_clkgenInstance->controllerTable->core_ctl_set(
  10af9a:	4611      	mov	r1, r2
        slice_idx -= DEFAULT_CORESLICE_IDX_START;
  10af9c:	9203      	str	r2, [sp, #12]
        ret = l_clkgenInstance->controllerTable->core_ctl_set(
  10af9e:	462a      	mov	r2, r5
  10afa0:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10afa2:	b005      	add	sp, #20
  10afa4:	bd30      	pop	{r4, r5, r15}
        return false;
  10afa6:	2000      	movs	r0, #0
}
  10afa8:	b005      	add	sp, #20
  10afaa:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10afac:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10afb0:	f24a 5240 	movw	r2, #42304	; 0xa540
  10afb4:	f647 4134 	movw	r1, #31796	; 0x7c34
  10afb8:	f2c0 0311 	movt	r3, #17
  10afbc:	4670      	mov	r0, r14
  10afbe:	f2c0 0211 	movt	r2, #17
  10afc2:	9300      	str	r3, [sp, #0]
  10afc4:	f2c0 0111 	movt	r1, #17
  10afc8:	f240 5303 	movw	r3, #1283	; 0x503
  10afcc:	f008 fbe6 	bl	11379c <_panic>

0010afd0 <hal_clock_uuuclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuuclk_set(void *g_handle, uint32_t res_glb_idx,
                          clkgen_app_uuu_cfg_t *uuu_app_cfg)
{
  10afd0:	b530      	push	{r4, r5, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t uuu_slice_idx = -1;
  10afd2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10afd6:	b087      	sub	sp, #28
    int32_t uuu_slice_idx = -1;
  10afd8:	9304      	str	r3, [sp, #16]
    clkgen_gasket_type_t l_gasket_div;
    ASSERT((g_handle != NULL));
  10afda:	b350      	cbz	r0, 10b032 <hal_clock_uuuclk_set+0x62>
  10afdc:	4614      	mov	r4, r2
  10afde:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &uuu_slice_idx);
  10afe0:	4608      	mov	r0, r1
  10afe2:	aa04      	add	r2, sp, #16
  10afe4:	a903      	add	r1, sp, #12
  10afe6:	f005 f9a5 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10afea:	3001      	adds	r0, #1
  10afec:	d01e      	beq.n	10b02c <hal_clock_uuuclk_set+0x5c>
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;

    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10afee:	9904      	ldr	r1, [sp, #16]
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
  10aff0:	7962      	ldrb	r2, [r4, #5]
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
  10aff2:	79a3      	ldrb	r3, [r4, #6]
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
  10aff4:	f88d 2014 	strb.w	r2, [r13, #20]
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
  10aff8:	f88d 3015 	strb.w	r3, [r13, #21]
    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10affc:	f5b1 7fc0 	cmp.w	r1, #384	; 0x180
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
  10b000:	79e2      	ldrb	r2, [r4, #7]
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;
  10b002:	7a23      	ldrb	r3, [r4, #8]
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
  10b004:	f88d 2016 	strb.w	r2, [r13, #22]
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;
  10b008:	f88d 3017 	strb.w	r3, [r13, #23]
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10b00c:	9803      	ldr	r0, [sp, #12]
    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10b00e:	db0d      	blt.n	10b02c <hal_clock_uuuclk_set+0x5c>
            && l_clkgenInstance->controllerTable->uuu_clock_wrapper) {
  10b010:	68ab      	ldr	r3, [r5, #8]
  10b012:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
  10b014:	b155      	cbz	r5, 10b02c <hal_clock_uuuclk_set+0x5c>
        //set clk src and div
        uuu_slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b016:	f5a1 71c0 	sub.w	r1, r1, #384	; 0x180

        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10b01a:	7822      	ldrb	r2, [r4, #0]
  10b01c:	7923      	ldrb	r3, [r4, #4]
  10b01e:	9200      	str	r2, [sp, #0]
        uuu_slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b020:	9104      	str	r1, [sp, #16]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10b022:	aa05      	add	r2, sp, #20
  10b024:	b289      	uxth	r1, r1
  10b026:	47a8      	blx	r5
    }

    LTRACEF("hal_clock_uuuclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, uuu_slice_idx);
    return false;
}
  10b028:	b007      	add	sp, #28
  10b02a:	bd30      	pop	{r4, r5, r15}
        return false;
  10b02c:	2000      	movs	r0, #0
}
  10b02e:	b007      	add	sp, #28
  10b030:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10b032:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b036:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b03a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b03e:	f2c0 0311 	movt	r3, #17
  10b042:	4670      	mov	r0, r14
  10b044:	f2c0 0211 	movt	r2, #17
  10b048:	9300      	str	r3, [sp, #0]
  10b04a:	f2c0 0111 	movt	r1, #17
  10b04e:	f240 5334 	movw	r3, #1332	; 0x534
  10b052:	f008 fba3 	bl	11379c <_panic>
  10b056:	bf00      	nop

0010b058 <hal_clock_uuuctl_get>:
bool hal_clock_uuuctl_get(void *g_handle, uint32_t res_glb_idx,
                          clkgen_uuu_ctl *ctl)
{
  10b058:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10b05a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10b05e:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10b060:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10b062:	b1d8      	cbz	r0, 10b09c <hal_clock_uuuctl_get+0x44>
  10b064:	4615      	mov	r5, r2
  10b066:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10b068:	4608      	mov	r0, r1
  10b06a:	aa03      	add	r2, sp, #12
  10b06c:	a902      	add	r1, sp, #8
  10b06e:	f005 f961 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10b072:	3001      	adds	r0, #1
  10b074:	d00f      	beq.n	10b096 <hal_clock_uuuctl_get+0x3e>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10b076:	9a03      	ldr	r2, [sp, #12]
  10b078:	f5b2 7fc0 	cmp.w	r2, #384	; 0x180
  10b07c:	db0b      	blt.n	10b096 <hal_clock_uuuctl_get+0x3e>
            && l_clkgenInstance->controllerTable->uuu_ctl_get) {
  10b07e:	68a3      	ldr	r3, [r4, #8]
  10b080:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  10b082:	b143      	cbz	r3, 10b096 <hal_clock_uuuctl_get+0x3e>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10b084:	9802      	ldr	r0, [sp, #8]
        slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b086:	f5a2 72c0 	sub.w	r2, r2, #384	; 0x180
        ret = l_clkgenInstance->controllerTable->uuu_ctl_get(
  10b08a:	4611      	mov	r1, r2
        slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b08c:	9203      	str	r2, [sp, #12]
        ret = l_clkgenInstance->controllerTable->uuu_ctl_get(
  10b08e:	462a      	mov	r2, r5
  10b090:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10b092:	b005      	add	sp, #20
  10b094:	bd30      	pop	{r4, r5, r15}
        return false;
  10b096:	2000      	movs	r0, #0
}
  10b098:	b005      	add	sp, #20
  10b09a:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10b09c:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b0a0:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b0a4:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b0a8:	f2c0 0311 	movt	r3, #17
  10b0ac:	4670      	mov	r0, r14
  10b0ae:	f2c0 0211 	movt	r2, #17
  10b0b2:	9300      	str	r3, [sp, #0]
  10b0b4:	f2c0 0111 	movt	r1, #17
  10b0b8:	f44f 63ac 	mov.w	r3, #1376	; 0x560
  10b0bc:	f008 fb6e 	bl	11379c <_panic>

0010b0c0 <hal_clock_uuuctl_set>:

bool hal_clock_uuuctl_set(void *g_handle, uint32_t res_glb_idx,
                          const clkgen_uuu_ctl *ctl)
{
  10b0c0:	b530      	push	{r4, r5, r14}
    int ret = 0;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t slice_idx = -1;
  10b0c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10b0c6:	b085      	sub	sp, #20
    int32_t slice_idx = -1;
  10b0c8:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10b0ca:	b1d8      	cbz	r0, 10b104 <hal_clock_uuuctl_set+0x44>
  10b0cc:	4615      	mov	r5, r2
  10b0ce:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &slice_idx);
  10b0d0:	4608      	mov	r0, r1
  10b0d2:	aa03      	add	r2, sp, #12
  10b0d4:	a902      	add	r1, sp, #8
  10b0d6:	f005 f92d 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10b0da:	3001      	adds	r0, #1
  10b0dc:	d00f      	beq.n	10b0fe <hal_clock_uuuctl_set+0x3e>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    ret = false;

    if ((slice_idx != -1) && (slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10b0de:	9a03      	ldr	r2, [sp, #12]
  10b0e0:	f5b2 7fc0 	cmp.w	r2, #384	; 0x180
  10b0e4:	db0b      	blt.n	10b0fe <hal_clock_uuuctl_set+0x3e>
            && l_clkgenInstance->controllerTable->uuu_ctl_set) {
  10b0e6:	68a3      	ldr	r3, [r4, #8]
  10b0e8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  10b0ea:	b143      	cbz	r3, 10b0fe <hal_clock_uuuctl_set+0x3e>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10b0ec:	9802      	ldr	r0, [sp, #8]
        slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b0ee:	f5a2 72c0 	sub.w	r2, r2, #384	; 0x180
        ret = l_clkgenInstance->controllerTable->uuu_ctl_set(
  10b0f2:	4611      	mov	r1, r2
        slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  10b0f4:	9203      	str	r2, [sp, #12]
        ret = l_clkgenInstance->controllerTable->uuu_ctl_set(
  10b0f6:	462a      	mov	r2, r5
  10b0f8:	4798      	blx	r3
                  clkgen_base_addr, slice_idx, ctl);
    }

    return ret;
}
  10b0fa:	b005      	add	sp, #20
  10b0fc:	bd30      	pop	{r4, r5, r15}
        return false;
  10b0fe:	2000      	movs	r0, #0
}
  10b100:	b005      	add	sp, #20
  10b102:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10b104:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b108:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b10c:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b110:	f2c0 0311 	movt	r3, #17
  10b114:	4670      	mov	r0, r14
  10b116:	f2c0 0211 	movt	r2, #17
  10b11a:	9300      	str	r3, [sp, #0]
  10b11c:	f2c0 0111 	movt	r1, #17
  10b120:	f240 537f 	movw	r3, #1407	; 0x57f
  10b124:	f008 fb3a 	bl	11379c <_panic>

0010b128 <hal_clock_uuuslice_debug_enable>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuuslice_debug_enable(void *g_handle, uint32_t res_glb_idx,
                                     uint8_t dbg_div)
{
  10b128:	b530      	push	{r4, r5, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_dbg_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t uuu_slice_idx = -1;
  10b12a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10b12e:	b085      	sub	sp, #20
    int32_t uuu_slice_idx = -1;
  10b130:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10b132:	b1d0      	cbz	r0, 10b16a <hal_clock_uuuslice_debug_enable+0x42>
  10b134:	4615      	mov	r5, r2
  10b136:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &uuu_slice_idx);
  10b138:	4608      	mov	r0, r1
  10b13a:	aa03      	add	r2, sp, #12
  10b13c:	a902      	add	r1, sp, #8
  10b13e:	f005 f8f9 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10b142:	3001      	adds	r0, #1
  10b144:	d00e      	beq.n	10b164 <hal_clock_uuuslice_debug_enable+0x3c>
    }

    clkgen_dbg_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((uuu_slice_idx != -1)
            && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10b146:	9903      	ldr	r1, [sp, #12]
    if ((uuu_slice_idx != -1)
  10b148:	f5b1 7fc0 	cmp.w	r1, #384	; 0x180
  10b14c:	db0a      	blt.n	10b164 <hal_clock_uuuslice_debug_enable+0x3c>
            && l_clkgenInstance->controllerTable->uuuslice_debug_enable) {
  10b14e:	68a3      	ldr	r3, [r4, #8]
  10b150:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  10b152:	b1e3      	cbz	r3, 10b18e <hal_clock_uuuslice_debug_enable+0x66>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->uuuslice_debug_enable(
  10b154:	462a      	mov	r2, r5
  10b156:	f5a1 71c0 	sub.w	r1, r1, #384	; 0x180
  10b15a:	9802      	ldr	r0, [sp, #8]
  10b15c:	b289      	uxth	r1, r1
  10b15e:	4798      	blx	r3
    }

    LTRACEF("hal_clock_uuuslice_debug_enable not find res_glb_idx:0x%x slice_idx:%d\n",
            res_glb_idx, uuu_slice_idx);
    return false;
}
  10b160:	b005      	add	sp, #20
  10b162:	bd30      	pop	{r4, r5, r15}
        return false;
  10b164:	2000      	movs	r0, #0
}
  10b166:	b005      	add	sp, #20
  10b168:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  10b16a:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b16e:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b172:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b176:	f2c0 0311 	movt	r3, #17
  10b17a:	4670      	mov	r0, r14
  10b17c:	f2c0 0211 	movt	r2, #17
  10b180:	9300      	str	r3, [sp, #0]
  10b182:	f2c0 0111 	movt	r1, #17
  10b186:	f44f 63da 	mov.w	r3, #1744	; 0x6d0
  10b18a:	f008 fb07 	bl	11379c <_panic>
        return false;
  10b18e:	4618      	mov	r0, r3
  10b190:	e7e9      	b.n	10b166 <hal_clock_uuuslice_debug_enable+0x3e>
  10b192:	bf00      	nop

0010b194 <hal_clock_uuuslice_debug_disable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuuslice_debug_disable(void *g_handle, uint32_t res_glb_idx)
{
  10b194:	b510      	push	{r4, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_dbg_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t uuu_slice_idx = -1;
  10b196:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  10b19a:	b084      	sub	sp, #16
    int32_t uuu_slice_idx = -1;
  10b19c:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  10b19e:	b1c8      	cbz	r0, 10b1d4 <hal_clock_uuuslice_debug_disable+0x40>
  10b1a0:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &uuu_slice_idx);
  10b1a2:	aa03      	add	r2, sp, #12
  10b1a4:	4608      	mov	r0, r1
  10b1a6:	a902      	add	r1, sp, #8
  10b1a8:	f005 f8c4 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10b1ac:	3001      	adds	r0, #1
  10b1ae:	d00e      	beq.n	10b1ce <hal_clock_uuuslice_debug_disable+0x3a>
    }

    clkgen_dbg_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((uuu_slice_idx != -1)
            && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  10b1b0:	9903      	ldr	r1, [sp, #12]
    if ((uuu_slice_idx != -1)
  10b1b2:	f5b1 7fc0 	cmp.w	r1, #384	; 0x180
  10b1b6:	db0a      	blt.n	10b1ce <hal_clock_uuuslice_debug_disable+0x3a>
            && l_clkgenInstance->controllerTable->uuuslice_debug_enable) {
  10b1b8:	68a3      	ldr	r3, [r4, #8]
  10b1ba:	6e18      	ldr	r0, [r3, #96]	; 0x60
  10b1bc:	b140      	cbz	r0, 10b1d0 <hal_clock_uuuslice_debug_disable+0x3c>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->uuuslice_debug_disable(
  10b1be:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  10b1c0:	f5a1 71c0 	sub.w	r1, r1, #384	; 0x180
  10b1c4:	9802      	ldr	r0, [sp, #8]
  10b1c6:	b289      	uxth	r1, r1
  10b1c8:	4798      	blx	r3
    }

    LTRACEF("hal_clock_uuuslice_debug_disable not find res_glb_idx:0x%x slice_idx:%d\n",
            res_glb_idx, uuu_slice_idx);
    return false;
}
  10b1ca:	b004      	add	sp, #16
  10b1cc:	bd10      	pop	{r4, r15}
        return false;
  10b1ce:	2000      	movs	r0, #0
}
  10b1d0:	b004      	add	sp, #16
  10b1d2:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  10b1d4:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b1d8:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b1dc:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b1e0:	f2c0 0311 	movt	r3, #17
  10b1e4:	4670      	mov	r0, r14
  10b1e6:	f2c0 0211 	movt	r2, #17
  10b1ea:	9300      	str	r3, [sp, #0]
  10b1ec:	f2c0 0111 	movt	r1, #17
  10b1f0:	f240 7302 	movw	r3, #1794	; 0x702
  10b1f4:	f008 fad2 	bl	11379c <_panic>

0010b1f8 <hal_clock_uuuclk_get>:
//! \return clock value = (reg_value*ref_clk_type) * ref_clk_div
//
//*****************************************************************************
uint32_t hal_clock_uuuclk_get(void *g_handle, uint32_t res_glb_idx,
                              clkgen_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div)
{
  10b1f8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  10b1fc:	4606      	mov	r6, r0
  10b1fe:	b09a      	sub	sp, #104	; 0x68
  10b200:	460c      	mov	r4, r1
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    clkgen_slice_mon_ret_type ret_type = mon_avg_freq;
    int32_t ip_slice_idx = -1;
  10b202:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
    uint32_t clk_reg_vaule = 0;
    uint32_t clk_vaule = 0;
    int uuu_map_count = 0;
    clkgen_uuu_monitor_t uuu_map[] = {
  10b206:	f649 71e0 	movw	r1, #40928	; 0x9fe0
  10b20a:	f10d 0910 	add.w	r9, r13, #16
{
  10b20e:	4617      	mov	r7, r2
    clkgen_uuu_monitor_t uuu_map[] = {
  10b210:	4648      	mov	r0, r9
  10b212:	2258      	movs	r2, #88	; 0x58
  10b214:	f2c0 0111 	movt	r1, #17
  10b218:	46f0      	mov	r8, r14
{
  10b21a:	461d      	mov	r5, r3
    int32_t ip_slice_idx = -1;
  10b21c:	f8cd a00c 	str.w	r10, [r13, #12]
    clkgen_uuu_monitor_t uuu_map[] = {
  10b220:	f008 eb3e 	blx	1138a0 <memcpy>
        {RES_UUU_WRAP_SOC_CPU1A, 3}, {RES_UUU_WRAP_SOC_CPU1B, 4}, {RES_UUU_WRAP_SOC_CPU2, 5}, {RES_UUU_WRAP_SOC_GPU1, 6},
        {RES_UUU_WRAP_SOC_GPU2, 7}, {RES_UUU_WRAP_SOC_VPU1, 8}, {RES_UUU_WRAP_SOC_MJPEG, 9}, {RES_UUU_WRAP_SOC_VPU_BUS, 10},
        {RES_UUU_WRAP_SOC_VSN, 11}, {RES_UUU_WRAP_SOC_DDR, 12}, {RES_UUU_WRAP_SOC_HIS_BUS, 13}
    };
    ASSERT((g_handle != NULL));
  10b224:	2e00      	cmp	r6, #0
  10b226:	d04c      	beq.n	10b2c2 <hal_clock_uuuclk_get+0xca>
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &ip_slice_idx);
  10b228:	aa03      	add	r2, sp, #12
  10b22a:	4620      	mov	r0, r4
  10b22c:	a902      	add	r1, sp, #8
  10b22e:	f005 f881 	bl	110334 <res_get_info_by_id>

    if (ret == -1) {
  10b232:	3001      	adds	r0, #1
        LTRACEF("hal_clock_ipclk_get res_glb_idx:0x%x is not find\n", res_glb_idx);
        return false;
  10b234:	bf08      	it	eq
  10b236:	2500      	moveq	r5, #0
    if (ret == -1) {
  10b238:	d02f      	beq.n	10b29a <hal_clock_uuuclk_get+0xa2>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  10b23a:	f8dd 8008 	ldr.w	r8, [r13, #8]
    uuu_map_count = sizeof(uuu_map) / sizeof(uuu_map[0]);
    ip_slice_idx = -1;

    for (int i = 0; i < uuu_map_count; i++) {
  10b23e:	2300      	movs	r3, #0
    ip_slice_idx = -1;
  10b240:	f8cd a00c 	str.w	r10, [r13, #12]
        if (res_glb_idx == uuu_map[i].res_id) {
  10b244:	f859 2033 	ldr.w	r2, [r9, r3, lsl #3]
  10b248:	42a2      	cmp	r2, r4
  10b24a:	d033      	beq.n	10b2b4 <hal_clock_uuuclk_get+0xbc>
    for (int i = 0; i < uuu_map_count; i++) {
  10b24c:	3301      	adds	r3, #1
  10b24e:	2b0b      	cmp	r3, #11
  10b250:	d1f8      	bne.n	10b244 <hal_clock_uuuclk_get+0x4c>
            break;
        }
    }

    //enable uuu monitor
    hal_clock_uuuslice_debug_enable(g_handle, res_glb_idx, ref_clk_div);
  10b252:	4621      	mov	r1, r4
  10b254:	462a      	mov	r2, r5
  10b256:	4630      	mov	r0, r6
  10b258:	f7ff ff66 	bl	10b128 <hal_clock_uuuslice_debug_enable>

    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10b25c:	9903      	ldr	r1, [sp, #12]
  10b25e:	2900      	cmp	r1, #0
    uint32_t clk_reg_vaule = 0;
  10b260:	bfb8      	it	lt
  10b262:	2000      	movlt	r0, #0
    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
  10b264:	db0c      	blt.n	10b280 <hal_clock_uuuclk_get+0x88>
            && l_clkgenInstance->controllerTable->mon_ip_slice) {
  10b266:	68b3      	ldr	r3, [r6, #8]
  10b268:	f8d3 9030 	ldr.w	r9, [r3, #48]	; 0x30
  10b26c:	f1b9 0f00 	cmp.w	r9, #0
  10b270:	d039      	beq.n	10b2e6 <hal_clock_uuuclk_get+0xee>
        //get clk
        clk_reg_vaule = l_clkgenInstance->controllerTable->mon_ip_slice(
  10b272:	2201      	movs	r2, #1
  10b274:	b289      	uxth	r1, r1
  10b276:	4640      	mov	r0, r8
  10b278:	2300      	movs	r3, #0
  10b27a:	9200      	str	r2, [sp, #0]
  10b27c:	463a      	mov	r2, r7
  10b27e:	47c8      	blx	r9
  10b280:	3501      	adds	r5, #1
                            clkgen_base_addr, ip_slice_idx - DEFAULT_IPSLICE_IDX_START, ref_clk_type,
                            0, ret_type);
    }

    if (mon_ref_clk_24M == ref_clk_type) {
  10b282:	b177      	cbz	r7, 10b2a2 <hal_clock_uuuclk_get+0xaa>
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
    }
    else {
        clk_vaule = (clk_reg_vaule * 32 * 1000) * (ref_clk_div + 1);
  10b284:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
  10b288:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  10b28c:	022d      	lsls	r5, r5, #8
  10b28e:	fb00 f505 	mul.w	r5, r0, r5
    }

    hal_clock_uuuslice_debug_disable(g_handle, res_glb_idx);
  10b292:	4621      	mov	r1, r4
  10b294:	4630      	mov	r0, r6
  10b296:	f7ff ff7d 	bl	10b194 <hal_clock_uuuslice_debug_disable>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_uuuclk_get clk_reg_vaule:%d,ref_clk_type:%d, ret:%d\n",
                  clk_reg_vaule, ref_clk_type, clk_vaule);
    return clk_vaule;
}
  10b29a:	4628      	mov	r0, r5
  10b29c:	b01a      	add	sp, #104	; 0x68
  10b29e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        clk_vaule = (clk_reg_vaule * 24 * 1000 * 1000) * (ref_clk_div + 1);
  10b2a2:	f44f 5358 	mov.w	r3, #13824	; 0x3600
  10b2a6:	f2c0 136e 	movt	r3, #366	; 0x16e
  10b2aa:	fb03 f505 	mul.w	r5, r3, r5
  10b2ae:	fb00 f505 	mul.w	r5, r0, r5
  10b2b2:	e7ee      	b.n	10b292 <hal_clock_uuuclk_get+0x9a>
            ip_slice_idx = uuu_map[i].ip_idx;
  10b2b4:	aa1a      	add	r2, sp, #104	; 0x68
  10b2b6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  10b2ba:	f853 3c54 	ldr.w	r3, [r3, #-84]
  10b2be:	9303      	str	r3, [sp, #12]
            break;
  10b2c0:	e7c7      	b.n	10b252 <hal_clock_uuuclk_get+0x5a>
    ASSERT((g_handle != NULL));
  10b2c2:	f24a 532c 	movw	r3, #42284	; 0xa52c
  10b2c6:	f24a 5240 	movw	r2, #42304	; 0xa540
  10b2ca:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b2ce:	f2c0 0311 	movt	r3, #17
  10b2d2:	4640      	mov	r0, r8
  10b2d4:	f2c0 0211 	movt	r2, #17
  10b2d8:	9300      	str	r3, [sp, #0]
  10b2da:	f2c0 0111 	movt	r1, #17
  10b2de:	f240 733e 	movw	r3, #1854	; 0x73e
  10b2e2:	f008 fa5b 	bl	11379c <_panic>
    uint32_t clk_reg_vaule = 0;
  10b2e6:	4648      	mov	r0, r9
  10b2e8:	e7ca      	b.n	10b280 <hal_clock_uuuclk_get+0x88>
  10b2ea:	bf00      	nop

0010b2ec <hal_cpu_create_handle>:
static bool boot_saf(uint32_t addr);

bool hal_cpu_create_handle(void **handle_p)
{
    return true;
}
  10b2ec:	2001      	movs	r0, #1
  10b2ee:	4770      	bx	r14

0010b2f0 <hal_cpu_release_handle>:
  10b2f0:	2001      	movs	r0, #1
  10b2f2:	4770      	bx	r14
  10b2f4:	0000      	movs	r0, r0
	...

0010b2f8 <hal_cpu_boot>:
{
    return true;
}

bool hal_cpu_boot(void *handle, sd_cpu_id cpu_id, uint64_t entry)
{
  10b2f8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10b2fc:	460d      	mov	r5, r1
    if (cpu_id >= CPU_ID_MAX || cpu_id <= CPU_ID_MIN) {
  10b2fe:	3901      	subs	r1, #1
  10b300:	2904      	cmp	r1, #4
{
  10b302:	b087      	sub	sp, #28
    if (cpu_id >= CPU_ID_MAX || cpu_id <= CPU_ID_MIN) {
  10b304:	f200 80a8 	bhi.w	10b458 <hal_cpu_boot+0x160>
  10b308:	46f3      	mov	r11, r14
        dprintf(CRITICAL, "%s cpu id:%d error\n", __func__, cpu_id);
        return false;
    }

    if (cpu_id >= CPU_ID_AP1 && cpu_id <= CPU_ID_MP) {
  10b30a:	2902      	cmp	r1, #2
  10b30c:	d84b      	bhi.n	10b3a6 <hal_cpu_boot+0xae>

static bool __boot_ss(sd_cpu_id cpu_id, uint32_t h, uint32_t l)
{
    struct ss_boot_cfg *cfg;

    cfg = get_ss_cfg(cpu_id);
  10b30e:	4628      	mov	r0, r5
static bool boot_ss_by_id(sd_cpu_id cpu_id, uint64_t addr)
{
    uint32_t h = (uint32_t)(addr >> 30);
    uint32_t l = ((uint32_t)addr & BIT_MASK(30)) >> 2;

    if (cpu_id == CPU_ID_MP) {
  10b310:	2d03      	cmp	r5, #3
    uint32_t h = (uint32_t)(addr >> 30);
  10b312:	bf1d      	ittte	ne
  10b314:	0f96      	lsrne	r6, r2, #30
  10b316:	ea46 0683 	orrne.w	r6, r6, r3, lsl #2
    uint32_t l = ((uint32_t)addr & BIT_MASK(30)) >> 2;
  10b31a:	f3c2 079b 	ubfxne	r7, r2, #2, #28
        h = 0x1;
  10b31e:	2601      	moveq	r6, #1
        l = ((uint32_t)addr) >> 12;
  10b320:	bf08      	it	eq
  10b322:	0b17      	lsreq	r7, r2, #12
    cfg = get_ss_cfg(cpu_id);
  10b324:	f000 fb50 	bl	10b9c8 <get_ss_cfg>
    if (!cfg) {
  10b328:	4604      	mov	r4, r0
  10b32a:	2800      	cmp	r0, #0
  10b32c:	f000 80a5 	beq.w	10b47a <hal_cpu_boot+0x182>

static bool boot_ss(struct ss_boot_cfg *cfg)
{
    bool ret = true;
    uint32_t i = 0;
    void *clk_handle = NULL;
  10b330:	2500      	movs	r5, #0
    void *rst_handle = NULL;
  10b332:	a806      	add	r0, sp, #24
    cfg->ss_entry_l = l;
  10b334:	6667      	str	r7, [r4, #100]	; 0x64
    scr_handle_t entry_high;
    scr_handle_t entry_low;

    ASSERT(cfg != NULL);

    ret = hal_rstgen_creat_handle(&rst_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10b336:	f44f 6180 	mov.w	r1, #1024	; 0x400
    cfg->ss_entry_h = h;
  10b33a:	6626      	str	r6, [r4, #96]	; 0x60
    ret = hal_rstgen_creat_handle(&rst_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10b33c:	f2c8 1196 	movt	r1, #33174	; 0x8196
    void *rst_handle = NULL;
  10b340:	f840 5d04 	str.w	r5, [r0, #-4]!
    void *clk_handle = NULL;
  10b344:	9504      	str	r5, [sp, #16]
    ret = hal_rstgen_creat_handle(&rst_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10b346:	f005 f861 	bl	11040c <hal_rstgen_creat_handle>
    ASSERT(ret);
  10b34a:	2800      	cmp	r0, #0
  10b34c:	f000 8180 	beq.w	10b650 <hal_cpu_boot+0x358>

    ret = hal_clock_creat_handle(&clk_handle);
  10b350:	a804      	add	r0, sp, #16
  10b352:	f7ff f8ed 	bl	10a530 <hal_clock_creat_handle>
    ASSERT(ret);
  10b356:	4682      	mov	r10, r0
  10b358:	2800      	cmp	r0, #0
  10b35a:	f000 8111 	beq.w	10b580 <hal_cpu_boot+0x288>

    hal_rstgen_init(rst_handle);
  10b35e:	9805      	ldr	r0, [sp, #20]
  10b360:	f005 f8d0 	bl	110504 <hal_rstgen_init>

    /* disable iso */
    for (i = 0; i < cfg->ss_iso_rst.num; i++) {
  10b364:	6863      	ldr	r3, [r4, #4]
  10b366:	b92b      	cbnz	r3, 10b374 <hal_cpu_boot+0x7c>
  10b368:	e094      	b.n	10b494 <hal_cpu_boot+0x19c>
  10b36a:	6863      	ldr	r3, [r4, #4]
  10b36c:	3501      	adds	r5, #1
  10b36e:	429d      	cmp	r5, r3
  10b370:	f080 8090 	bcs.w	10b494 <hal_cpu_boot+0x19c>
        dprintf(INFO, "%s %d  iso:0x%0x\n", __func__, __LINE__,
                cfg->ss_iso_rst.res_id[i]);
        ret = hal_rstgen_iso_disable(rst_handle, cfg->ss_iso_rst.res_id[i]);
  10b374:	6823      	ldr	r3, [r4, #0]
  10b376:	9805      	ldr	r0, [sp, #20]
  10b378:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b37c:	f005 f8e0 	bl	110540 <hal_rstgen_iso_disable>
        ASSERT(ret);
  10b380:	2800      	cmp	r0, #0
  10b382:	d1f2      	bne.n	10b36a <hal_cpu_boot+0x72>
  10b384:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b388:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b38c:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b390:	f2c0 0311 	movt	r3, #17
  10b394:	4658      	mov	r0, r11
  10b396:	f2c0 0211 	movt	r2, #17
  10b39a:	9300      	str	r3, [sp, #0]
  10b39c:	f2c0 0111 	movt	r1, #17
  10b3a0:	23d4      	movs	r3, #212	; 0xd4
  10b3a2:	f008 f9fb 	bl	11379c <_panic>
    else if (cpu_id == CPU_ID_SEC) {
  10b3a6:	2d04      	cmp	r5, #4
  10b3a8:	f3c2 040b 	ubfx	r4, r2, #0, #12
  10b3ac:	f000 8096 	beq.w	10b4dc <hal_cpu_boot+0x1e4>
    ASSERT((img_base & 0xFFF) == 0);
  10b3b0:	2c00      	cmp	r4, #0
  10b3b2:	f040 80f6 	bne.w	10b5a2 <hal_cpu_boot+0x2aa>
    writel(REMAP_DONE, _ioaddr(RSTGEN_SAF_REMAP_STATUS_REG));
  10b3b6:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  10b3ba:	f644 5550 	movw	r5, #19792	; 0x4d50
  10b3be:	f6cf 4341 	movt	r3, #64577	; 0xfc41
    ASSERT(handle = hal_scr_create_handle(
  10b3c2:	2014      	movs	r0, #20
    writel(REMAP_DONE, _ioaddr(RSTGEN_SAF_REMAP_STATUS_REG));
  10b3c4:	f2c5 2545 	movt	r5, #21061	; 0x5245
  10b3c8:	9203      	str	r2, [sp, #12]
    ASSERT(handle = hal_scr_create_handle(
  10b3ca:	f2c0 4000 	movt	r0, #1024	; 0x400
    writel(REMAP_DONE, _ioaddr(RSTGEN_SAF_REMAP_STATUS_REG));
  10b3ce:	601d      	str	r5, [r3, #0]
    ASSERT(handle = hal_scr_create_handle(
  10b3d0:	2103      	movs	r1, #3
  10b3d2:	f005 f989 	bl	1106e8 <hal_scr_create_handle>
  10b3d6:	9a03      	ldr	r2, [sp, #12]
  10b3d8:	4606      	mov	r6, r0
  10b3da:	460f      	mov	r7, r1
  10b3dc:	ea56 0307 	orrs.w	r3, r6, r7
  10b3e0:	f000 819d 	beq.w	10b71e <hal_cpu_boot+0x426>
    hal_scr_set(handle, img_base >> 12);
  10b3e4:	0b12      	lsrs	r2, r2, #12
  10b3e6:	f005 f9b1 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  10b3ea:	4630      	mov	r0, r6
  10b3ec:	4639      	mov	r1, r7
  10b3ee:	f005 f97d 	bl	1106ec <hal_scr_delete_handle>
    ASSERT(handle = hal_scr_create_handle(
  10b3f2:	f20f 51c4 	addw	r1, r15, #1476	; 0x5c4
  10b3f6:	e9d1 0100 	ldrd	r0, r1, [r1]
  10b3fa:	f005 f975 	bl	1106e8 <hal_scr_create_handle>
  10b3fe:	4606      	mov	r6, r0
  10b400:	460f      	mov	r7, r1
  10b402:	ea56 0307 	orrs.w	r3, r6, r7
  10b406:	f000 80dd 	beq.w	10b5c4 <hal_cpu_boot+0x2cc>
    hal_scr_set(handle, 1);
  10b40a:	2201      	movs	r2, #1
  10b40c:	f005 f99e 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  10b410:	4630      	mov	r0, r6
  10b412:	4639      	mov	r1, r7
  10b414:	f005 f96a 	bl	1106ec <hal_scr_delete_handle>
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10b418:	f240 4002 	movw	r0, #1026	; 0x402
  10b41c:	f2c8 2096 	movt	r0, #33430	; 0x8296
  10b420:	aa04      	add	r2, sp, #16
    addr_t phy_addr = 0;
  10b422:	e9cd 4404 	strd	r4, r4, [r13, #16]
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10b426:	a905      	add	r1, sp, #20
  10b428:	f004 ff84 	bl	110334 <res_get_info_by_id>
    ASSERT(!ret);
  10b42c:	2800      	cmp	r0, #0
  10b42e:	f040 8198 	bne.w	10b762 <hal_cpu_boot+0x46a>
    __asm__ volatile("cpsid i");
  10b432:	b672      	cpsid	i
    arch_disable_cache(UCACHE);
  10b434:	2003      	movs	r0, #3
        return boot_saf(entry);
  10b436:	f04f 0a01 	mov.w	r10, #1
    arch_disable_cache(UCACHE);
  10b43a:	f7f5 ea5e 	blx	1008f8 <arch_disable_cache>
    rstgen_core_reset(phy_addr, idx);
  10b43e:	9805      	ldr	r0, [sp, #20]
    writel(readl(SAF_LOCKSTEP_SCR_ADDR) | (0x3 << SAF_LOCKSTEP_SCR_BIT),
  10b440:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
  10b444:	f6cf 4329 	movt	r3, #64553	; 0xfc29
  10b448:	681a      	ldr	r2, [r3, #0]
  10b44a:	f042 0203 	orr.w	r2, r2, #3
  10b44e:	601a      	str	r2, [r3, #0]
    rstgen_core_reset(phy_addr, idx);
  10b450:	9904      	ldr	r1, [sp, #16]
  10b452:	f7fd ffe5 	bl	109420 <rstgen_core_reset>
        return boot_saf(entry);
  10b456:	e00c      	b.n	10b472 <hal_cpu_boot+0x17a>
        dprintf(CRITICAL, "%s cpu id:%d error\n", __func__, cpu_id);
  10b458:	f64b 1184 	movw	r1, #47492	; 0xb984
  10b45c:	f64b 10a0 	movw	r0, #47520	; 0xb9a0
  10b460:	462a      	mov	r2, r5
  10b462:	f2c0 0111 	movt	r1, #17
        return false;
  10b466:	f04f 0a00 	mov.w	r10, #0
        dprintf(CRITICAL, "%s cpu id:%d error\n", __func__, cpu_id);
  10b46a:	f2c0 0011 	movt	r0, #17
  10b46e:	f009 f9c9 	bl	114804 <printf>
}
  10b472:	4650      	mov	r0, r10
  10b474:	b007      	add	sp, #28
  10b476:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "%s failed to get cpu id:%d cfg\n", __func__, cpu_id);
  10b47a:	f64b 1194 	movw	r1, #47508	; 0xb994
  10b47e:	f64b 10b4 	movw	r0, #47540	; 0xb9b4
  10b482:	462a      	mov	r2, r5
  10b484:	f2c0 0111 	movt	r1, #17
        return false;
  10b488:	46a2      	mov	r10, r4
        dprintf(CRITICAL, "%s failed to get cpu id:%d cfg\n", __func__, cpu_id);
  10b48a:	f2c0 0011 	movt	r0, #17
  10b48e:	f009 f9b9 	bl	114804 <printf>
  10b492:	e7ee      	b.n	10b472 <hal_cpu_boot+0x17a>
    }

    /* ss module reset */
    for (i = 0; i < cfg->ss_pre_module_rst.num; i++) {
  10b494:	68e3      	ldr	r3, [r4, #12]
  10b496:	2b00      	cmp	r3, #0
  10b498:	f000 80b6 	beq.w	10b608 <hal_cpu_boot+0x310>
  10b49c:	2500      	movs	r5, #0
  10b49e:	e004      	b.n	10b4aa <hal_cpu_boot+0x1b2>
  10b4a0:	68e3      	ldr	r3, [r4, #12]
  10b4a2:	3501      	adds	r5, #1
  10b4a4:	429d      	cmp	r5, r3
  10b4a6:	f080 80af 	bcs.w	10b608 <hal_cpu_boot+0x310>
        dprintf(INFO, "%s %d  pre rst:0x%0x\n", __func__, __LINE__,
                cfg->ss_pre_module_rst.res_id[i]);
        ret = hal_rstgen_module_reset(rst_handle, cfg->ss_pre_module_rst.res_id[i]);
  10b4aa:	68a3      	ldr	r3, [r4, #8]
  10b4ac:	9805      	ldr	r0, [sp, #20]
  10b4ae:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b4b2:	f005 f8af 	bl	110614 <hal_rstgen_module_reset>
        ASSERT(ret);
  10b4b6:	2800      	cmp	r0, #0
  10b4b8:	d1f2      	bne.n	10b4a0 <hal_cpu_boot+0x1a8>
  10b4ba:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b4be:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b4c2:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b4c6:	f2c0 0311 	movt	r3, #17
  10b4ca:	4658      	mov	r0, r11
  10b4cc:	f2c0 0211 	movt	r2, #17
  10b4d0:	9300      	str	r3, [sp, #0]
  10b4d2:	f2c0 0111 	movt	r1, #17
  10b4d6:	23dc      	movs	r3, #220	; 0xdc
  10b4d8:	f008 f960 	bl	11379c <_panic>
    ASSERT((img_base & 0xFFF) == 0);
  10b4dc:	2c00      	cmp	r4, #0
  10b4de:	f040 810d 	bne.w	10b6fc <hal_cpu_boot+0x404>
    writel(REMAP_DONE, _ioaddr(RSTGEN_SEC_REMAP_STATUS_REG));
  10b4e2:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  10b4e6:	f644 5450 	movw	r4, #19792	; 0x4d50
  10b4ea:	f6cf 0341 	movt	r3, #63553	; 0xf841
    handle = hal_scr_create_handle(
  10b4ee:	2014      	movs	r0, #20
    writel(REMAP_DONE, _ioaddr(RSTGEN_SEC_REMAP_STATUS_REG));
  10b4f0:	f2c5 2445 	movt	r4, #21061	; 0x5245
  10b4f4:	9203      	str	r2, [sp, #12]
    handle = hal_scr_create_handle(
  10b4f6:	f2c0 4030 	movt	r0, #1072	; 0x430
    writel(REMAP_DONE, _ioaddr(RSTGEN_SEC_REMAP_STATUS_REG));
  10b4fa:	601c      	str	r4, [r3, #0]
    handle = hal_scr_create_handle(
  10b4fc:	f240 1103 	movw	r1, #259	; 0x103
  10b500:	f005 f8f2 	bl	1106e8 <hal_scr_create_handle>
    ASSERT(handle);
  10b504:	9a03      	ldr	r2, [sp, #12]
    handle = hal_scr_create_handle(
  10b506:	4604      	mov	r4, r0
  10b508:	460d      	mov	r5, r1
    ASSERT(handle);
  10b50a:	ea54 0305 	orrs.w	r3, r4, r5
  10b50e:	f000 8117 	beq.w	10b740 <hal_cpu_boot+0x448>
    hal_scr_set(handle, img_base >> 12);
  10b512:	0b12      	lsrs	r2, r2, #12
  10b514:	f005 f91a 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  10b518:	4620      	mov	r0, r4
  10b51a:	4629      	mov	r1, r5
  10b51c:	f005 f8e6 	bl	1106ec <hal_scr_delete_handle>
    handle = hal_scr_create_handle(
  10b520:	f20f 419c 	addw	r1, r15, #1180	; 0x49c
  10b524:	e9d1 0100 	ldrd	r0, r1, [r1]
  10b528:	f005 f8de 	bl	1106e8 <hal_scr_create_handle>
  10b52c:	4604      	mov	r4, r0
  10b52e:	460d      	mov	r5, r1
    ASSERT(handle);
  10b530:	ea54 0305 	orrs.w	r3, r4, r5
  10b534:	d057      	beq.n	10b5e6 <hal_cpu_boot+0x2ee>
    hal_scr_set(handle, 1);
  10b536:	2201      	movs	r2, #1
  10b538:	f005 f908 	bl	11074c <hal_scr_set>
    hal_scr_delete_handle(handle);
  10b53c:	4620      	mov	r0, r4
  10b53e:	4629      	mov	r1, r5
  10b540:	f005 f8d4 	bl	1106ec <hal_scr_delete_handle>
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  10b544:	f44f 6180 	mov.w	r1, #1024	; 0x400
  10b548:	f2c8 1196 	movt	r1, #33174	; 0x8196
  10b54c:	a805      	add	r0, sp, #20
  10b54e:	f004 ff5d 	bl	11040c <hal_rstgen_creat_handle>
    ASSERT(ret);
  10b552:	4682      	mov	r10, r0
  10b554:	2800      	cmp	r0, #0
  10b556:	f000 8115 	beq.w	10b784 <hal_cpu_boot+0x48c>
    writel(readl(SEC_LOCKSTEP_SCR_ADDR) | (0x3 << SEC_LOCKSTEP_SCR_BIT),
  10b55a:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  10b55e:	f240 4104 	movw	r1, #1028	; 0x404
  10b562:	9805      	ldr	r0, [sp, #20]
    writel(readl(SEC_LOCKSTEP_SCR_ADDR) | (0x3 << SEC_LOCKSTEP_SCR_BIT),
  10b564:	f6cf 032a 	movt	r3, #63530	; 0xf82a
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  10b568:	f2c8 1196 	movt	r1, #33174	; 0x8196
    writel(readl(SEC_LOCKSTEP_SCR_ADDR) | (0x3 << SEC_LOCKSTEP_SCR_BIT),
  10b56c:	681a      	ldr	r2, [r3, #0]
  10b56e:	f042 0203 	orr.w	r2, r2, #3
  10b572:	601a      	str	r2, [r3, #0]
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  10b574:	f005 f81c 	bl	1105b0 <hal_rstgen_core_reset>
    hal_rstgen_release_handle(handle);
  10b578:	9805      	ldr	r0, [sp, #20]
  10b57a:	f004 ffb7 	bl	1104ec <hal_rstgen_release_handle>
        return boot_sec(entry);
  10b57e:	e778      	b.n	10b472 <hal_cpu_boot+0x17a>
    ASSERT(ret);
  10b580:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b584:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b588:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b58c:	f2c0 0311 	movt	r3, #17
  10b590:	4658      	mov	r0, r11
  10b592:	f2c0 0211 	movt	r2, #17
  10b596:	9300      	str	r3, [sp, #0]
  10b598:	f2c0 0111 	movt	r1, #17
  10b59c:	23cb      	movs	r3, #203	; 0xcb
  10b59e:	f008 f8fd 	bl	11379c <_panic>
    ASSERT((img_base & 0xFFF) == 0);
  10b5a2:	f64b 2314 	movw	r3, #47636	; 0xba14
  10b5a6:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b5aa:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b5ae:	f2c0 0311 	movt	r3, #17
  10b5b2:	4670      	mov	r0, r14
  10b5b4:	f2c0 0211 	movt	r2, #17
  10b5b8:	9300      	str	r3, [sp, #0]
  10b5ba:	f2c0 0111 	movt	r1, #17
  10b5be:	2381      	movs	r3, #129	; 0x81
  10b5c0:	f008 f8ec 	bl	11379c <_panic>
    ASSERT(handle = hal_scr_create_handle(
  10b5c4:	f64b 2380 	movw	r3, #47744	; 0xba80
  10b5c8:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b5cc:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b5d0:	f2c0 0311 	movt	r3, #17
  10b5d4:	4658      	mov	r0, r11
  10b5d6:	f2c0 0211 	movt	r2, #17
  10b5da:	9300      	str	r3, [sp, #0]
  10b5dc:	f2c0 0111 	movt	r1, #17
  10b5e0:	238c      	movs	r3, #140	; 0x8c
  10b5e2:	f008 f8db 	bl	11379c <_panic>
    ASSERT(handle);
  10b5e6:	f647 4370 	movw	r3, #31856	; 0x7c70
  10b5ea:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b5ee:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b5f2:	f2c0 0311 	movt	r3, #17
  10b5f6:	4658      	mov	r0, r11
  10b5f8:	f2c0 0211 	movt	r2, #17
  10b5fc:	9300      	str	r3, [sp, #0]
  10b5fe:	f2c0 0111 	movt	r1, #17
  10b602:	2366      	movs	r3, #102	; 0x66
  10b604:	f008 f8ca 	bl	11379c <_panic>
    }

    /* some subsystem needs core clock pre set  */
    for (i = 0; i < cfg->ss_pre_core_clk.num; i++) {
  10b608:	6a63      	ldr	r3, [r4, #36]	; 0x24
  10b60a:	b393      	cbz	r3, 10b672 <hal_cpu_boot+0x37a>
  10b60c:	2500      	movs	r5, #0
  10b60e:	462e      	mov	r6, r5
  10b610:	e004      	b.n	10b61c <hal_cpu_boot+0x324>
  10b612:	6a63      	ldr	r3, [r4, #36]	; 0x24
  10b614:	3601      	adds	r6, #1
  10b616:	350c      	adds	r5, #12
  10b618:	429e      	cmp	r6, r3
  10b61a:	d22a      	bcs.n	10b672 <hal_cpu_boot+0x37a>
        dprintf(INFO, "%s %d  pre core clock:0x%0x\n", __func__, __LINE__,
                cfg->ss_pre_core_clk.clk[i].res_id);
        ret = hal_clock_coreclk_set(clk_handle, cfg->ss_pre_core_clk.clk[i].res_id,
  10b61c:	6a23      	ldr	r3, [r4, #32]
  10b61e:	9804      	ldr	r0, [sp, #16]
  10b620:	195a      	adds	r2, r3, r5
  10b622:	5959      	ldr	r1, [r3, r5]
  10b624:	3204      	adds	r2, #4
  10b626:	f7ff fbe5 	bl	10adf4 <hal_clock_coreclk_set>
                                    &(cfg->ss_pre_core_clk.clk[i].clk));
        ASSERT(ret);
  10b62a:	2800      	cmp	r0, #0
  10b62c:	d1f1      	bne.n	10b612 <hal_cpu_boot+0x31a>
  10b62e:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b632:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b636:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b63a:	f2c0 0311 	movt	r3, #17
  10b63e:	4658      	mov	r0, r11
  10b640:	f2c0 0211 	movt	r2, #17
  10b644:	9300      	str	r3, [sp, #0]
  10b646:	f2c0 0111 	movt	r1, #17
  10b64a:	23e5      	movs	r3, #229	; 0xe5
  10b64c:	f008 f8a6 	bl	11379c <_panic>
    ASSERT(ret);
  10b650:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b654:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b658:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b65c:	f2c0 0311 	movt	r3, #17
  10b660:	4658      	mov	r0, r11
  10b662:	f2c0 0211 	movt	r2, #17
  10b666:	9300      	str	r3, [sp, #0]
  10b668:	f2c0 0111 	movt	r1, #17
  10b66c:	23c8      	movs	r3, #200	; 0xc8
  10b66e:	f008 f895 	bl	11379c <_panic>
    }

    /* some subsystem needs uuu pre set  */
    for (i = 0; i < cfg->ss_pre_uuu_clk.num; i++) {
  10b672:	69e3      	ldr	r3, [r4, #28]
  10b674:	b303      	cbz	r3, 10b6b8 <hal_cpu_boot+0x3c0>
  10b676:	2500      	movs	r5, #0
  10b678:	e003      	b.n	10b682 <hal_cpu_boot+0x38a>
  10b67a:	69e3      	ldr	r3, [r4, #28]
  10b67c:	3501      	adds	r5, #1
  10b67e:	429d      	cmp	r5, r3
  10b680:	d21a      	bcs.n	10b6b8 <hal_cpu_boot+0x3c0>
        dprintf(INFO, "%s %d  pre uuu :0x%0x\n", __func__, __LINE__,
                cfg->ss_pre_uuu_clk.clk[i].res_id);
        ret = hal_clock_uuuclk_set(clk_handle, cfg->ss_pre_uuu_clk.clk[i].res_id,
  10b682:	69a1      	ldr	r1, [r4, #24]
  10b684:	012b      	lsls	r3, r5, #4
  10b686:	9804      	ldr	r0, [sp, #16]
  10b688:	18ca      	adds	r2, r1, r3
  10b68a:	58c9      	ldr	r1, [r1, r3]
  10b68c:	3204      	adds	r2, #4
  10b68e:	f7ff fc9f 	bl	10afd0 <hal_clock_uuuclk_set>
                                   &(cfg->ss_pre_uuu_clk.clk[i].clk));
        ASSERT(ret);
  10b692:	2800      	cmp	r0, #0
  10b694:	d1f1      	bne.n	10b67a <hal_cpu_boot+0x382>
  10b696:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b69a:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b69e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b6a2:	f2c0 0311 	movt	r3, #17
  10b6a6:	4658      	mov	r0, r11
  10b6a8:	f2c0 0211 	movt	r2, #17
  10b6ac:	9300      	str	r3, [sp, #0]
  10b6ae:	f2c0 0111 	movt	r1, #17
  10b6b2:	23ee      	movs	r3, #238	; 0xee
  10b6b4:	f008 f872 	bl	11379c <_panic>
    }

    /* clock gating disable */
    for (i = 0; i < cfg->ss_pre_gating.num; i++) {
  10b6b8:	6963      	ldr	r3, [r4, #20]
  10b6ba:	2b00      	cmp	r3, #0
  10b6bc:	d073      	beq.n	10b7a6 <hal_cpu_boot+0x4ae>
  10b6be:	2500      	movs	r5, #0
  10b6c0:	e003      	b.n	10b6ca <hal_cpu_boot+0x3d2>
  10b6c2:	6963      	ldr	r3, [r4, #20]
  10b6c4:	3501      	adds	r5, #1
  10b6c6:	429d      	cmp	r5, r3
  10b6c8:	d26d      	bcs.n	10b7a6 <hal_cpu_boot+0x4ae>
        dprintf(INFO, "%s %d  clock enable :0x%0x\n", __func__, __LINE__,
                cfg->ss_pre_gating.res_id[i]);
        ret = hal_clock_enable(clk_handle, cfg->ss_pre_gating.res_id[i]);
  10b6ca:	6923      	ldr	r3, [r4, #16]
  10b6cc:	9804      	ldr	r0, [sp, #16]
  10b6ce:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b6d2:	f7ff f9c9 	bl	10aa68 <hal_clock_enable>
        ASSERT(ret);
  10b6d6:	2800      	cmp	r0, #0
  10b6d8:	d1f3      	bne.n	10b6c2 <hal_cpu_boot+0x3ca>
  10b6da:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b6de:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b6e2:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b6e6:	f2c0 0311 	movt	r3, #17
  10b6ea:	4658      	mov	r0, r11
  10b6ec:	f2c0 0211 	movt	r2, #17
  10b6f0:	9300      	str	r3, [sp, #0]
  10b6f2:	f2c0 0111 	movt	r1, #17
  10b6f6:	23f6      	movs	r3, #246	; 0xf6
  10b6f8:	f008 f850 	bl	11379c <_panic>
    ASSERT((img_base & 0xFFF) == 0);
  10b6fc:	f64b 2314 	movw	r3, #47636	; 0xba14
  10b700:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b704:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b708:	f2c0 0311 	movt	r3, #17
  10b70c:	4670      	mov	r0, r14
  10b70e:	f2c0 0211 	movt	r2, #17
  10b712:	9300      	str	r3, [sp, #0]
  10b714:	f2c0 0111 	movt	r1, #17
  10b718:	2359      	movs	r3, #89	; 0x59
  10b71a:	f008 f83f 	bl	11379c <_panic>
    ASSERT(handle = hal_scr_create_handle(
  10b71e:	f64b 232c 	movw	r3, #47660	; 0xba2c
  10b722:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b726:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b72a:	f2c0 0311 	movt	r3, #17
  10b72e:	4658      	mov	r0, r11
  10b730:	f2c0 0211 	movt	r2, #17
  10b734:	9300      	str	r3, [sp, #0]
  10b736:	f2c0 0111 	movt	r1, #17
  10b73a:	2388      	movs	r3, #136	; 0x88
  10b73c:	f008 f82e 	bl	11379c <_panic>
    ASSERT(handle);
  10b740:	f647 4370 	movw	r3, #31856	; 0x7c70
  10b744:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b748:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b74c:	f2c0 0311 	movt	r3, #17
  10b750:	4658      	mov	r0, r11
  10b752:	f2c0 0211 	movt	r2, #17
  10b756:	9300      	str	r3, [sp, #0]
  10b758:	f2c0 0111 	movt	r1, #17
  10b75c:	2361      	movs	r3, #97	; 0x61
  10b75e:	f008 f81d 	bl	11379c <_panic>
    ASSERT(!ret);
  10b762:	f647 33f8 	movw	r3, #31736	; 0x7bf8
  10b766:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b76a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b76e:	f2c0 0311 	movt	r3, #17
  10b772:	4658      	mov	r0, r11
  10b774:	f2c0 0211 	movt	r2, #17
  10b778:	9300      	str	r3, [sp, #0]
  10b77a:	f2c0 0111 	movt	r1, #17
  10b77e:	2375      	movs	r3, #117	; 0x75
  10b780:	f008 f80c 	bl	11379c <_panic>
    ASSERT(ret);
  10b784:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b788:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b78c:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b790:	f2c0 0311 	movt	r3, #17
  10b794:	4658      	mov	r0, r11
  10b796:	f2c0 0211 	movt	r2, #17
  10b79a:	9300      	str	r3, [sp, #0]
  10b79c:	f2c0 0111 	movt	r1, #17
  10b7a0:	234e      	movs	r3, #78	; 0x4e
  10b7a2:	f007 fffb 	bl	11379c <_panic>
    }

    /* setup pll config */
    for (i = 0; i < cfg->ss_pll.num; i++) {
  10b7a6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  10b7a8:	b18b      	cbz	r3, 10b7ce <hal_cpu_boot+0x4d6>
  10b7aa:	2500      	movs	r5, #0
        dprintf(INFO, "%s %d  pll:0x%0x\n", __func__, __LINE__,
                cfg->ss_pll.res_id[i]);
        setup_pll(cfg->ss_pll.res_id[i]);
  10b7ac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    pll =  hal_pll_create_handle(resid);
  10b7ae:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
  10b7b2:	f004 f989 	bl	10fac8 <hal_pll_create_handle>
    ASSERT(pll != (pll_handle_t)0);
  10b7b6:	4606      	mov	r6, r0
  10b7b8:	b368      	cbz	r0, 10b816 <hal_cpu_boot+0x51e>
    hal_pll_config(pll, NULL);
  10b7ba:	2100      	movs	r1, #0
    for (i = 0; i < cfg->ss_pll.num; i++) {
  10b7bc:	3501      	adds	r5, #1
    hal_pll_config(pll, NULL);
  10b7be:	f004 f9a5 	bl	10fb0c <hal_pll_config>
    hal_pll_delete_handle(pll);
  10b7c2:	4630      	mov	r0, r6
  10b7c4:	f004 f9a0 	bl	10fb08 <hal_pll_delete_handle>
    for (i = 0; i < cfg->ss_pll.num; i++) {
  10b7c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  10b7ca:	429d      	cmp	r5, r3
  10b7cc:	d3ee      	bcc.n	10b7ac <hal_cpu_boot+0x4b4>
    }

    /* set uuu clock for higher freq
     * which may be from pll
     * */
    for (i = 0; i < cfg->ss_post_uuu_clk.num; i++) {
  10b7ce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  10b7d0:	b393      	cbz	r3, 10b838 <hal_cpu_boot+0x540>
  10b7d2:	2500      	movs	r5, #0
  10b7d4:	e003      	b.n	10b7de <hal_cpu_boot+0x4e6>
  10b7d6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  10b7d8:	3501      	adds	r5, #1
  10b7da:	429d      	cmp	r5, r3
  10b7dc:	d22c      	bcs.n	10b838 <hal_cpu_boot+0x540>
        dprintf(INFO, "%s %d  uuu:0x%0x\n", __func__, __LINE__,
                cfg->ss_post_uuu_clk.clk[i].res_id);
        ret = hal_clock_uuuclk_set(clk_handle, cfg->ss_post_uuu_clk.clk[i].res_id,
  10b7de:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  10b7e0:	012b      	lsls	r3, r5, #4
  10b7e2:	9804      	ldr	r0, [sp, #16]
  10b7e4:	18ca      	adds	r2, r1, r3
  10b7e6:	58c9      	ldr	r1, [r1, r3]
  10b7e8:	3204      	adds	r2, #4
  10b7ea:	f7ff fbf1 	bl	10afd0 <hal_clock_uuuclk_set>
                                   &(cfg->ss_post_uuu_clk.clk[i].clk));
        ASSERT(ret);
  10b7ee:	2800      	cmp	r0, #0
  10b7f0:	d1f1      	bne.n	10b7d6 <hal_cpu_boot+0x4de>
  10b7f2:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b7f6:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b7fa:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b7fe:	f2c0 0311 	movt	r3, #17
  10b802:	4658      	mov	r0, r11
  10b804:	f2c0 0211 	movt	r2, #17
  10b808:	9300      	str	r3, [sp, #0]
  10b80a:	f2c0 0111 	movt	r1, #17
  10b80e:	f44f 7384 	mov.w	r3, #264	; 0x108
  10b812:	f007 ffc3 	bl	11379c <_panic>
    ASSERT(pll != (pll_handle_t)0);
  10b816:	f64b 13fc 	movw	r3, #47612	; 0xb9fc
  10b81a:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b81e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b822:	f2c0 0311 	movt	r3, #17
  10b826:	4658      	mov	r0, r11
  10b828:	f2c0 0211 	movt	r2, #17
  10b82c:	9300      	str	r3, [sp, #0]
  10b82e:	f2c0 0111 	movt	r1, #17
  10b832:	23b6      	movs	r3, #182	; 0xb6
  10b834:	f007 ffb2 	bl	11379c <_panic>
    }

    /* disable each core clock gate for smp */
    for (i = 0; i < cfg->ss_post_core_clk_gating.num; i++) {
  10b838:	6b63      	ldr	r3, [r4, #52]	; 0x34
  10b83a:	b1fb      	cbz	r3, 10b87c <hal_cpu_boot+0x584>
  10b83c:	2500      	movs	r5, #0
  10b83e:	e003      	b.n	10b848 <hal_cpu_boot+0x550>
  10b840:	6b63      	ldr	r3, [r4, #52]	; 0x34
  10b842:	3501      	adds	r5, #1
  10b844:	429d      	cmp	r5, r3
  10b846:	d219      	bcs.n	10b87c <hal_cpu_boot+0x584>
        dprintf(INFO, "%s %d  core clock enable:0x%0x\n", __func__, __LINE__,
                cfg->ss_post_core_clk_gating.res_id[i]);
        ret = hal_clock_enable(clk_handle, cfg->ss_post_core_clk_gating.res_id[i]);
  10b848:	6b23      	ldr	r3, [r4, #48]	; 0x30
  10b84a:	9804      	ldr	r0, [sp, #16]
  10b84c:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b850:	f7ff f90a 	bl	10aa68 <hal_clock_enable>
        ASSERT(ret);
  10b854:	2800      	cmp	r0, #0
  10b856:	d1f3      	bne.n	10b840 <hal_cpu_boot+0x548>
  10b858:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b85c:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b860:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b864:	f2c0 0311 	movt	r3, #17
  10b868:	4658      	mov	r0, r11
  10b86a:	f2c0 0211 	movt	r2, #17
  10b86e:	9300      	str	r3, [sp, #0]
  10b870:	f2c0 0111 	movt	r1, #17
  10b874:	f44f 7388 	mov.w	r3, #272	; 0x110
  10b878:	f007 ff90 	bl	11379c <_panic>
    }

    entry_low  = hal_scr_create_handle(cfg->ss_entry_signal_low);
  10b87c:	e9d4 0114 	ldrd	r0, r1, [r4, #80]	; 0x50
  10b880:	f004 ff32 	bl	1106e8 <hal_scr_create_handle>
  10b884:	4680      	mov	r8, r0
  10b886:	4689      	mov	r9, r1
    entry_high = hal_scr_create_handle(cfg->ss_entry_signal_high);
  10b888:	e9d4 0116 	ldrd	r0, r1, [r4, #88]	; 0x58
  10b88c:	f004 ff2c 	bl	1106e8 <hal_scr_create_handle>

    if (entry_low != (scr_handle_t)0) {
  10b890:	ea58 0309 	orrs.w	r3, r8, r9
    entry_high = hal_scr_create_handle(cfg->ss_entry_signal_high);
  10b894:	4606      	mov	r6, r0
  10b896:	460f      	mov	r7, r1
    if (entry_low != (scr_handle_t)0) {
  10b898:	d15a      	bne.n	10b950 <hal_cpu_boot+0x658>
        ret = hal_scr_set(entry_low, cfg->ss_entry_l);
        ASSERT(ret);
        hal_scr_delete_handle(entry_low);
    }

    if (entry_high != (scr_handle_t)0) {
  10b89a:	ea56 0307 	orrs.w	r3, r6, r7
  10b89e:	d148      	bne.n	10b932 <hal_cpu_boot+0x63a>
        ret = hal_scr_set(entry_high, cfg->ss_entry_h);
        ASSERT(ret);
        hal_scr_delete_handle(entry_high);
    }

    for (i = 0; i < cfg->ss_post_module_rst.num; i++) {
  10b8a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  10b8a2:	b1fb      	cbz	r3, 10b8e4 <hal_cpu_boot+0x5ec>
  10b8a4:	2500      	movs	r5, #0
  10b8a6:	e003      	b.n	10b8b0 <hal_cpu_boot+0x5b8>
  10b8a8:	6c63      	ldr	r3, [r4, #68]	; 0x44
  10b8aa:	3501      	adds	r5, #1
  10b8ac:	429d      	cmp	r5, r3
  10b8ae:	d219      	bcs.n	10b8e4 <hal_cpu_boot+0x5ec>
        dprintf(INFO, "%s %d  rst:0x%0x\n", __func__, __LINE__,
                cfg->ss_post_module_rst.res_id[i]);
        ret = hal_rstgen_module_reset(rst_handle, cfg->ss_post_module_rst.res_id[i]);
  10b8b0:	6c23      	ldr	r3, [r4, #64]	; 0x40
  10b8b2:	9805      	ldr	r0, [sp, #20]
  10b8b4:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b8b8:	f004 feac 	bl	110614 <hal_rstgen_module_reset>
        ASSERT(ret);
  10b8bc:	2800      	cmp	r0, #0
  10b8be:	d1f3      	bne.n	10b8a8 <hal_cpu_boot+0x5b0>
  10b8c0:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b8c4:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b8c8:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b8cc:	f2c0 0311 	movt	r3, #17
  10b8d0:	4658      	mov	r0, r11
  10b8d2:	f2c0 0211 	movt	r2, #17
  10b8d6:	9300      	str	r3, [sp, #0]
  10b8d8:	f2c0 0111 	movt	r1, #17
  10b8dc:	f44f 7394 	mov.w	r3, #296	; 0x128
  10b8e0:	f007 ff5c 	bl	11379c <_panic>
    }

    for (i = 0; i < cfg->ss_post_core_rst.num; i++) {
  10b8e4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  10b8e6:	b15b      	cbz	r3, 10b900 <hal_cpu_boot+0x608>
  10b8e8:	2500      	movs	r5, #0
        dprintf(INFO, "%s %d  core rst:0x%0x\n", __func__, __LINE__,
                cfg->ss_post_core_rst.res_id[i]);
        ret = hal_rstgen_core_reset(rst_handle, cfg->ss_post_core_rst.res_id[i]);
  10b8ea:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  10b8ec:	9805      	ldr	r0, [sp, #20]
  10b8ee:	f853 1025 	ldr.w	r1, [r3, r5, lsl #2]
  10b8f2:	f004 fe5d 	bl	1105b0 <hal_rstgen_core_reset>
        ASSERT(ret);
  10b8f6:	b150      	cbz	r0, 10b90e <hal_cpu_boot+0x616>
    for (i = 0; i < cfg->ss_post_core_rst.num; i++) {
  10b8f8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  10b8fa:	3501      	adds	r5, #1
  10b8fc:	429d      	cmp	r5, r3
  10b8fe:	d3f4      	bcc.n	10b8ea <hal_cpu_boot+0x5f2>
    }

    hal_clock_release_handle(clk_handle);
  10b900:	9804      	ldr	r0, [sp, #16]
  10b902:	f7fe fe31 	bl	10a568 <hal_clock_release_handle>
    hal_rstgen_release_handle(rst_handle);
  10b906:	9805      	ldr	r0, [sp, #20]
  10b908:	f004 fdf0 	bl	1104ec <hal_rstgen_release_handle>
  10b90c:	e5b1      	b.n	10b472 <hal_cpu_boot+0x17a>
        ASSERT(ret);
  10b90e:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b912:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b916:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b91a:	f2c0 0311 	movt	r3, #17
  10b91e:	4658      	mov	r0, r11
  10b920:	f2c0 0211 	movt	r2, #17
  10b924:	9300      	str	r3, [sp, #0]
  10b926:	f2c0 0111 	movt	r1, #17
  10b92a:	f240 132f 	movw	r3, #303	; 0x12f
  10b92e:	f007 ff35 	bl	11379c <_panic>
        hal_scr_get(entry_high);
  10b932:	4639      	mov	r1, r7
  10b934:	4630      	mov	r0, r6
  10b936:	f004 fef1 	bl	11071c <hal_scr_get>
        ret = hal_scr_set(entry_high, cfg->ss_entry_h);
  10b93a:	6e22      	ldr	r2, [r4, #96]	; 0x60
  10b93c:	4630      	mov	r0, r6
  10b93e:	4639      	mov	r1, r7
  10b940:	f004 ff04 	bl	11074c <hal_scr_set>
        ASSERT(ret);
  10b944:	b198      	cbz	r0, 10b96e <hal_cpu_boot+0x676>
        hal_scr_delete_handle(entry_high);
  10b946:	4630      	mov	r0, r6
  10b948:	4639      	mov	r1, r7
  10b94a:	f004 fecf 	bl	1106ec <hal_scr_delete_handle>
  10b94e:	e7a7      	b.n	10b8a0 <hal_cpu_boot+0x5a8>
        hal_scr_get(entry_low);
  10b950:	4649      	mov	r1, r9
  10b952:	4640      	mov	r0, r8
  10b954:	f004 fee2 	bl	11071c <hal_scr_get>
        ret = hal_scr_set(entry_low, cfg->ss_entry_l);
  10b958:	6e62      	ldr	r2, [r4, #100]	; 0x64
  10b95a:	4640      	mov	r0, r8
  10b95c:	4649      	mov	r1, r9
  10b95e:	f004 fef5 	bl	11074c <hal_scr_set>
        ASSERT(ret);
  10b962:	b1b0      	cbz	r0, 10b992 <hal_cpu_boot+0x69a>
        hal_scr_delete_handle(entry_low);
  10b964:	4640      	mov	r0, r8
  10b966:	4649      	mov	r1, r9
  10b968:	f004 fec0 	bl	1106ec <hal_scr_delete_handle>
  10b96c:	e795      	b.n	10b89a <hal_cpu_boot+0x5a2>
        ASSERT(ret);
  10b96e:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b972:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b976:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b97a:	f2c0 0311 	movt	r3, #17
  10b97e:	4658      	mov	r0, r11
  10b980:	f2c0 0211 	movt	r2, #17
  10b984:	9300      	str	r3, [sp, #0]
  10b986:	f2c0 0111 	movt	r1, #17
  10b98a:	f44f 7390 	mov.w	r3, #288	; 0x120
  10b98e:	f007 ff05 	bl	11379c <_panic>
        ASSERT(ret);
  10b992:	f24a 6310 	movw	r3, #42512	; 0xa610
  10b996:	f64b 12d4 	movw	r2, #47572	; 0xb9d4
  10b99a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10b99e:	f2c0 0311 	movt	r3, #17
  10b9a2:	4658      	mov	r0, r11
  10b9a4:	f2c0 0211 	movt	r2, #17
  10b9a8:	9300      	str	r3, [sp, #0]
  10b9aa:	f2c0 0111 	movt	r1, #17
  10b9ae:	f240 1319 	movw	r3, #281	; 0x119
  10b9b2:	f007 fef3 	bl	11379c <_panic>
  10b9b6:	bf00      	nop
  10b9b8:	04001401 	.word	0x04001401
  10b9bc:	00000003 	.word	0x00000003
  10b9c0:	04301401 	.word	0x04301401
  10b9c4:	00000103 	.word	0x00000103

0010b9c8 <get_ss_cfg>:
    .ss_remap_en_signal      = SCR_SEC__L31__remap_cr5_mp_ar_remap_en,
};
/* mp config data end */

struct ss_boot_cfg *get_ss_cfg(sd_cpu_id cpu_id)
{
  10b9c8:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct ss_boot_cfg *cfg[CPU_ID_MAX] = {
  10b9ca:	f64b 146c 	movw	r4, #47468	; 0xb96c
        &mp_cfg,
        NULL,
        NULL,
    };

    if (cpu_id >= CPU_ID_MAX || cpu_id <= CPU_ID_MIN) {
  10b9ce:	1e47      	subs	r7, r0, #1
{
  10b9d0:	4606      	mov	r6, r0
    struct ss_boot_cfg *cfg[CPU_ID_MAX] = {
  10b9d2:	f2c0 0411 	movt	r4, #17
{
  10b9d6:	b087      	sub	sp, #28
    struct ss_boot_cfg *cfg[CPU_ID_MAX] = {
  10b9d8:	466d      	mov	r5, r13
    if (cpu_id >= CPU_ID_MAX || cpu_id <= CPU_ID_MIN) {
  10b9da:	2f04      	cmp	r7, #4
    struct ss_boot_cfg *cfg[CPU_ID_MAX] = {
  10b9dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  10b9de:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  10b9e0:	e894 0003 	ldmia.w	r4, {r0, r1}
  10b9e4:	e885 0003 	stmia.w	r5, {r0, r1}
    if (cpu_id >= CPU_ID_MAX || cpu_id <= CPU_ID_MIN) {
  10b9e8:	d806      	bhi.n	10b9f8 <get_ss_cfg+0x30>
        dprintf(CRITICAL, "%s cpu id:%d error\n", __func__, cpu_id);
        return NULL;
    }

    return cfg[cpu_id];
  10b9ea:	ab06      	add	r3, sp, #24
  10b9ec:	eb03 0686 	add.w	r6, r3, r6, lsl #2
  10b9f0:	f856 0c18 	ldr.w	r0, [r6, #-24]
}
  10b9f4:	b007      	add	sp, #28
  10b9f6:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "%s cpu id:%d error\n", __func__, cpu_id);
  10b9f8:	f64b 21d4 	movw	r1, #47828	; 0xbad4
  10b9fc:	f64b 10a0 	movw	r0, #47520	; 0xb9a0
  10ba00:	4632      	mov	r2, r6
  10ba02:	f2c0 0111 	movt	r1, #17
  10ba06:	f2c0 0011 	movt	r0, #17
  10ba0a:	f008 fefb 	bl	114804 <printf>
        return NULL;
  10ba0e:	2000      	movs	r0, #0
  10ba10:	e7f0      	b.n	10b9f4 <get_ss_cfg+0x2c>
  10ba12:	bf00      	nop

0010ba14 <hal_crypto_init>:
//
//*****************************************************************************
void hal_crypto_init(uint level)
{

    ce_globle_init();
  10ba14:	f7f8 b9d8 	b.w	103dc8 <ce_globle_init>

0010ba18 <hal_dio_creat_handle>:
spin_lock_t dio_spin_lock = SPIN_LOCK_INITIAL_VALUE;

static struct dio_handle s_dio_handle;

bool hal_dio_creat_handle(void **handle, uint32_t dio_res_glb_idx)
{
  10ba18:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct dio_handle *p_handle;
    int8_t ret = 0;
    paddr_t phy_addr = 0;
  10ba1a:	2600      	movs	r6, #0
{
  10ba1c:	b083      	sub	sp, #12
  10ba1e:	4607      	mov	r7, r0
    int32_t real_idx = 0;
  10ba20:	aa02      	add	r2, sp, #8
    paddr_t phy_addr = 0;
  10ba22:	9600      	str	r6, [sp, #0]
    spin_lock_saved_state_t states;

    ret = res_get_info_by_id(dio_res_glb_idx, &phy_addr, &real_idx);
  10ba24:	4608      	mov	r0, r1
    int32_t real_idx = 0;
  10ba26:	f842 6d04 	str.w	r6, [r2, #-4]!
    ret = res_get_info_by_id(dio_res_glb_idx, &phy_addr, &real_idx);
  10ba2a:	4669      	mov	r1, r13
  10ba2c:	f004 fc82 	bl	110334 <res_get_info_by_id>

    if (ret != -1) {
  10ba30:	b240      	sxtb	r0, r0
  10ba32:	3001      	adds	r0, #1
  10ba34:	d032      	beq.n	10ba9c <hal_dio_creat_handle+0x84>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10ba36:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10ba3a:	f013 0580 	ands.w	r5, r3, #128	; 0x80
  10ba3e:	d117      	bne.n	10ba70 <hal_dio_creat_handle+0x58>
    __asm__ volatile("cpsid i");
  10ba40:	b672      	cpsid	i
        return false;
    }

    p_handle = &s_dio_handle;
    spin_lock_irqsave(&dio_spin_lock, states);
    p_handle->phy_addr = phy_addr;
  10ba42:	f24f 53cc 	movw	r3, #62924	; 0xf5cc
    *lock = 1;
  10ba46:	f24f 56c8 	movw	r6, #62920	; 0xf5c8
  10ba4a:	9a00      	ldr	r2, [sp, #0]
  10ba4c:	f2c0 0312 	movt	r3, #18
  10ba50:	2401      	movs	r4, #1
  10ba52:	f2c0 0612 	movt	r6, #18
  10ba56:	601a      	str	r2, [r3, #0]
    p_handle->real_idx = real_idx;
    *handle = p_handle;
    Dio_SetHandle((void *)p_handle);
  10ba58:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  10ba5a:	9a01      	ldr	r2, [sp, #4]
  10ba5c:	605a      	str	r2, [r3, #4]
  10ba5e:	6034      	str	r4, [r6, #0]
    *handle = p_handle;
  10ba60:	603b      	str	r3, [r7, #0]
    Dio_SetHandle((void *)p_handle);
  10ba62:	f7f8 fa03 	bl	103e6c <Dio_SetHandle>
    *lock = 0;
  10ba66:	6035      	str	r5, [r6, #0]
    __asm__ volatile("cpsie i");
  10ba68:	b662      	cpsie	i
    spin_unlock_irqrestore(&dio_spin_lock, states);

    return true;
  10ba6a:	4620      	mov	r0, r4
}
  10ba6c:	b003      	add	sp, #12
  10ba6e:	bdf0      	pop	{r4, r5, r6, r7, r15}
    p_handle->phy_addr = phy_addr;
  10ba70:	f24f 53cc 	movw	r3, #62924	; 0xf5cc
    *lock = 1;
  10ba74:	f24f 55c8 	movw	r5, #62920	; 0xf5c8
  10ba78:	9a00      	ldr	r2, [sp, #0]
  10ba7a:	f2c0 0312 	movt	r3, #18
  10ba7e:	2401      	movs	r4, #1
  10ba80:	f2c0 0512 	movt	r5, #18
  10ba84:	601a      	str	r2, [r3, #0]
    Dio_SetHandle((void *)p_handle);
  10ba86:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  10ba88:	9a01      	ldr	r2, [sp, #4]
  10ba8a:	602c      	str	r4, [r5, #0]
  10ba8c:	605a      	str	r2, [r3, #4]
    *handle = p_handle;
  10ba8e:	603b      	str	r3, [r7, #0]
    Dio_SetHandle((void *)p_handle);
  10ba90:	f7f8 f9ec 	bl	103e6c <Dio_SetHandle>
    *lock = 0;
  10ba94:	602e      	str	r6, [r5, #0]
    return true;
  10ba96:	4620      	mov	r0, r4
}
  10ba98:	b003      	add	sp, #12
  10ba9a:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_dio_creat_handle: res_get_info_by_id failed! 02\n");
  10ba9c:	f64b 501c 	movw	r0, #48412	; 0xbd1c
  10baa0:	f2c0 0011 	movt	r0, #17
  10baa4:	f008 fe96 	bl	1147d4 <puts>
        return false;
  10baa8:	4630      	mov	r0, r6
}
  10baaa:	b003      	add	sp, #12
  10baac:	bdf0      	pop	{r4, r5, r6, r7, r15}
  10baae:	bf00      	nop

0010bab0 <hal_dio_release_handle>:

bool hal_dio_release_handle(void **handle)
{
  10bab0:	b510      	push	{r4, r14}
  10bab2:	b082      	sub	sp, #8
    ASSERT(handle);
  10bab4:	b310      	cbz	r0, 10bafc <hal_dio_release_handle+0x4c>
    struct dio_handle *dio = *handle;
  10bab6:	6802      	ldr	r2, [r0, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10bab8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10babc:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  10bac0:	d10e      	bne.n	10bae0 <hal_dio_release_handle+0x30>
    __asm__ volatile("cpsid i");
  10bac2:	b672      	cpsid	i
    *lock = 0;
  10bac4:	f24f 51c8 	movw	r1, #62920	; 0xf5c8
    spin_lock_saved_state_t states;
    spin_lock_irqsave(&dio_spin_lock, states);
    dio->phy_addr = 0;
    dio->real_idx = -1;
  10bac8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  10bacc:	f2c0 0112 	movt	r1, #18
  10bad0:	e9c2 3400 	strd	r3, r4, [r2]
    *handle = NULL;
  10bad4:	6003      	str	r3, [r0, #0]
  10bad6:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
  10bad8:	b662      	cpsie	i
    spin_unlock_irqrestore(&dio_spin_lock, states);
    return true;
}
  10bada:	2001      	movs	r0, #1
  10badc:	b002      	add	sp, #8
  10bade:	bd10      	pop	{r4, r15}
  10bae0:	f24f 53c8 	movw	r3, #62920	; 0xf5c8
    dio->phy_addr = 0;
  10bae4:	2100      	movs	r1, #0
    dio->real_idx = -1;
  10bae6:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  10baea:	f2c0 0312 	movt	r3, #18
  10baee:	e9c2 1400 	strd	r1, r4, [r2]
    *handle = NULL;
  10baf2:	6001      	str	r1, [r0, #0]
}
  10baf4:	2001      	movs	r0, #1
  10baf6:	6019      	str	r1, [r3, #0]
  10baf8:	b002      	add	sp, #8
  10bafa:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  10bafc:	f647 4370 	movw	r3, #31856	; 0x7c70
  10bb00:	f64b 5250 	movw	r2, #48464	; 0xbd50
  10bb04:	f647 4134 	movw	r1, #31796	; 0x7c34
  10bb08:	f2c0 0311 	movt	r3, #17
  10bb0c:	4670      	mov	r0, r14
  10bb0e:	f2c0 0211 	movt	r2, #17
  10bb12:	9300      	str	r3, [sp, #0]
  10bb14:	f2c0 0111 	movt	r1, #17
  10bb18:	233b      	movs	r3, #59	; 0x3b
  10bb1a:	f007 fe3f 	bl	11379c <_panic>
  10bb1e:	bf00      	nop

0010bb20 <hal_dio_write_channel>:
}

void hal_dio_write_channel(void *handle, const Dio_ChannelType ChannelId,
                           const Dio_LevelType Level)
{
    ASSERT(handle);
  10bb20:	b120      	cbz	r0, 10bb2c <hal_dio_write_channel+0xc>
  10bb22:	460b      	mov	r3, r1
    Dio_WriteChannel(ChannelId, Level);
  10bb24:	4611      	mov	r1, r2
  10bb26:	4618      	mov	r0, r3
  10bb28:	f7f8 b978 	b.w	103e1c <Dio_WriteChannel>
    ASSERT(handle);
  10bb2c:	f647 4370 	movw	r3, #31856	; 0x7c70
  10bb30:	f64b 5250 	movw	r2, #48464	; 0xbd50
{
  10bb34:	b500      	push	{r14}
    ASSERT(handle);
  10bb36:	f2c0 0311 	movt	r3, #17
  10bb3a:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  10bb3e:	b083      	sub	sp, #12
  10bb40:	4670      	mov	r0, r14
    ASSERT(handle);
  10bb42:	f2c0 0211 	movt	r2, #17
  10bb46:	9300      	str	r3, [sp, #0]
  10bb48:	f2c0 0111 	movt	r1, #17
  10bb4c:	236d      	movs	r3, #109	; 0x6d
  10bb4e:	f007 fe25 	bl	11379c <_panic>
  10bb52:	bf00      	nop

0010bb54 <get_resource_from_table>:
}
#endif

int get_resource_from_table(int table_item, const enum_res_to_idx *table,
                            int *num_out, mod_res_t **out)
{
  10bb54:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  10bb58:	4698      	mov	r8, r3
    mod_res_t *r = NULL;
    int res_num = 0;
    int i;
    // size_t table_size = ARRAY_SIZE(table);

    if (table_item == -1) {
  10bb5a:	1c46      	adds	r6, r0, #1
{
  10bb5c:	b082      	sub	sp, #8
    if (table_item == -1) {
  10bb5e:	d010      	beq.n	10bb82 <get_resource_from_table+0x2e>
        goto FAIL_DOMAIN;
    }
    item = NULL;
    for (i = 0;table[i].enum_res_id != -1; i++) {
  10bb60:	680b      	ldr	r3, [r1, #0]
  10bb62:	1c5d      	adds	r5, r3, #1
  10bb64:	d00d      	beq.n	10bb82 <get_resource_from_table+0x2e>
  10bb66:	4691      	mov	r9, r2
        if (table[i].enum_res_id == table_item) {
  10bb68:	4298      	cmp	r0, r3
  10bb6a:	bf18      	it	ne
  10bb6c:	f101 0324 	addne.w	r3, r1, #36	; 0x24
  10bb70:	d102      	bne.n	10bb78 <get_resource_from_table+0x24>
  10bb72:	e00e      	b.n	10bb92 <get_resource_from_table+0x3e>
  10bb74:	4282      	cmp	r2, r0
  10bb76:	d00c      	beq.n	10bb92 <get_resource_from_table+0x3e>
    for (i = 0;table[i].enum_res_id != -1; i++) {
  10bb78:	681a      	ldr	r2, [r3, #0]
  10bb7a:	4619      	mov	r1, r3
  10bb7c:	3324      	adds	r3, #36	; 0x24
  10bb7e:	1c54      	adds	r4, r2, #1
  10bb80:	d1f8      	bne.n	10bb74 <get_resource_from_table+0x20>
    return 0;

FAIL_DOMAIN:
    if (r)
        free(r);
    *out = NULL;
  10bb82:	2300      	movs	r3, #0
    return -1;
  10bb84:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    *out = NULL;
  10bb88:	f8c8 3000 	str.w	r3, [r8]
}
  10bb8c:	b002      	add	sp, #8
  10bb8e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        if (item->resources[i] == 0)
  10bb92:	684b      	ldr	r3, [r1, #4]
  10bb94:	f101 0608 	add.w	r6, r1, #8
  10bb98:	4632      	mov	r2, r6
    for (i = 0, res_num = 0;; i++)
  10bb9a:	2700      	movs	r7, #0
        if (item->resources[i] == 0)
  10bb9c:	b383      	cbz	r3, 10bc00 <get_resource_from_table+0xac>
  10bb9e:	f852 5b04 	ldr.w	r5, [r2], #4
        res_num++;
  10bba2:	3701      	adds	r7, #1
        if (item->resources[i] == 0)
  10bba4:	2d00      	cmp	r5, #0
  10bba6:	d1fa      	bne.n	10bb9e <get_resource_from_table+0x4a>
  10bba8:	9301      	str	r3, [sp, #4]
    r = malloc(sizeof(mod_res_t) * res_num);
  10bbaa:	ebc7 00c7 	rsb	r0, r7, r7, lsl #3
  10bbae:	0080      	lsls	r0, r0, #2
  10bbb0:	f005 fcce 	bl	111550 <malloc>
  10bbb4:	9b01      	ldr	r3, [sp, #4]
  10bbb6:	4682      	mov	r10, r0
  10bbb8:	1d04      	adds	r4, r0, #4
  10bbba:	e004      	b.n	10bbc6 <get_resource_from_table+0x72>
    for (i = 0; i < res_num; i++)
  10bbbc:	3501      	adds	r5, #1
  10bbbe:	42af      	cmp	r7, r5
  10bbc0:	d023      	beq.n	10bc0a <get_resource_from_table+0xb6>
  10bbc2:	f856 3b04 	ldr.w	r3, [r6], #4
        r[i].res_id = item->resources[i];
  10bbc6:	f844 3c04 	str.w	r3, [r4, #-4]
        ret = res_get_info_by_id(r[i].res_id, &r[i].base, &r[i].index);
  10bbca:	4618      	mov	r0, r3
  10bbcc:	4621      	mov	r1, r4
  10bbce:	1d22      	adds	r2, r4, #4
  10bbd0:	f004 fbb0 	bl	110334 <res_get_info_by_id>
  10bbd4:	341c      	adds	r4, #28
        if (ret) {
  10bbd6:	4603      	mov	r3, r0
  10bbd8:	2800      	cmp	r0, #0
  10bbda:	d0ef      	beq.n	10bbbc <get_resource_from_table+0x68>
            LOGE("Error get info by id: %d,  (%d)",i, ret);
  10bbdc:	f64b 51e0 	movw	r1, #48608	; 0xbde0
  10bbe0:	f64b 6064 	movw	r0, #48740	; 0xbe64
  10bbe4:	462a      	mov	r2, r5
  10bbe6:	f2c0 0111 	movt	r1, #17
  10bbea:	f2c0 0011 	movt	r0, #17
  10bbee:	f008 fe09 	bl	114804 <printf>
    if (r)
  10bbf2:	f1ba 0f00 	cmp.w	r10, #0
  10bbf6:	d0c4      	beq.n	10bb82 <get_resource_from_table+0x2e>
        free(r);
  10bbf8:	4650      	mov	r0, r10
  10bbfa:	f005 fcbf 	bl	11157c <free>
  10bbfe:	e7c0      	b.n	10bb82 <get_resource_from_table+0x2e>
    r = malloc(sizeof(mod_res_t) * res_num);
  10bc00:	4618      	mov	r0, r3
    for (i = 0, res_num = 0;; i++)
  10bc02:	461f      	mov	r7, r3
    r = malloc(sizeof(mod_res_t) * res_num);
  10bc04:	f005 fca4 	bl	111550 <malloc>
  10bc08:	4682      	mov	r10, r0
    *num_out = res_num;
  10bc0a:	f8c9 7000 	str.w	r7, [r9]
    return 0;
  10bc0e:	2000      	movs	r0, #0
    *out = r;
  10bc10:	f8c8 a000 	str.w	r10, [r8]
}
  10bc14:	b002      	add	sp, #8
  10bc16:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  10bc1a:	bf00      	nop

0010bc1c <install_resource>:

int install_resource(struct display_resource *res, struct sdm_domain_res **out)
{
  10bc1c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10bc1e:	4606      	mov	r6, r0
  10bc20:	460f      	mov	r7, r1
    struct sdm_domain_res *dm = NULL;
    int ret = 0;

    dm = (struct sdm_domain_res *)malloc(sizeof(struct sdm_domain_res));
  10bc22:	2018      	movs	r0, #24
  10bc24:	2101      	movs	r1, #1
  10bc26:	f005 fc99 	bl	11155c <calloc>
    if (!dm)
  10bc2a:	4604      	mov	r4, r0
  10bc2c:	2800      	cmp	r0, #0
  10bc2e:	d037      	beq.n	10bca0 <install_resource+0x84>
        //goto DM_FAIL;
    }
#endif

//dc
    ret = get_resource_from_table(res->dc_res, table_dc_res, &dm->num_dc, &dm->dc);
  10bc30:	f242 4188 	movw	r1, #9352	; 0x2488
  10bc34:	f100 030c 	add.w	r3, r0, #12
  10bc38:	f100 0208 	add.w	r2, r0, #8
  10bc3c:	f8d6 0088 	ldr.w	r0, [r6, #136]	; 0x88
  10bc40:	f2c0 0112 	movt	r1, #18
  10bc44:	f7ff ff86 	bl	10bb54 <get_resource_from_table>
    if (ret)
  10bc48:	4605      	mov	r5, r0
  10bc4a:	b958      	cbnz	r0, 10bc64 <install_resource+0x48>
        LOGE("get dc failed\n");
        goto DM_FAIL;
    }

//if-res
    switch (res->if_res)
  10bc4c:	f8d6 008c 	ldr.w	r0, [r6, #140]	; 0x8c
  10bc50:	1e43      	subs	r3, r0, #1
  10bc52:	2b08      	cmp	r3, #8
  10bc54:	d821      	bhi.n	10bc9a <install_resource+0x7e>
  10bc56:	e8df f003 	tbb	[r15, r3]
  10bc5a:	4848      	.short	0x4848
  10bc5c:	2f2f2f2f 	.word	0x2f2f2f2f
  10bc60:	2f2f      	.short	0x2f2f
  10bc62:	48          	.byte	0x48
  10bc63:	00          	.byte	0x00
        LOGE("get dc failed\n");
  10bc64:	f64b 51f8 	movw	r1, #48632	; 0xbdf8
  10bc68:	f64b 70f0 	movw	r0, #49136	; 0xbff0
  10bc6c:	f2c0 0111 	movt	r1, #17
  10bc70:	f2c0 0011 	movt	r0, #17
  10bc74:	f008 fdc6 	bl	114804 <printf>

	*out = dm;
    return 0;

DM_FAIL:
    if (dm->dp)
  10bc78:	6860      	ldr	r0, [r4, #4]
  10bc7a:	b108      	cbz	r0, 10bc80 <install_resource+0x64>
        free(dm->dp);
  10bc7c:	f005 fc7e 	bl	11157c <free>
    if (dm->dc)
  10bc80:	68e0      	ldr	r0, [r4, #12]
  10bc82:	b108      	cbz	r0, 10bc88 <install_resource+0x6c>
        free(dm->dc);
  10bc84:	f005 fc7a 	bl	11157c <free>
    if (dm->intf)
  10bc88:	6960      	ldr	r0, [r4, #20]
  10bc8a:	b108      	cbz	r0, 10bc90 <install_resource+0x74>
        free(dm->intf);
  10bc8c:	f005 fc76 	bl	11157c <free>
    if (dm)
        free(dm);
  10bc90:	4620      	mov	r0, r4
  10bc92:	f005 fc73 	bl	11157c <free>
    return ret;
}
  10bc96:	4628      	mov	r0, r5
  10bc98:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
	*out = dm;
  10bc9a:	603c      	str	r4, [r7, #0]
}
  10bc9c:	4628      	mov	r0, r5
  10bc9e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        LOGE("malloc dm failed\n");
  10bca0:	f64b 51f8 	movw	r1, #48632	; 0xbdf8
  10bca4:	f64b 70c8 	movw	r0, #49096	; 0xbfc8
  10bca8:	f2c0 0111 	movt	r1, #17
    int ret = 0;
  10bcac:	4625      	mov	r5, r4
        LOGE("malloc dm failed\n");
  10bcae:	f2c0 0011 	movt	r0, #17
  10bcb2:	f008 fda7 	bl	114804 <printf>
        goto DM_FAIL;
  10bcb6:	e7df      	b.n	10bc78 <install_resource+0x5c>
            ret = get_resource_from_table(res->if_res, table_if_res, &dm->num_intf, &dm->intf);
  10bcb8:	f242 51a8 	movw	r1, #9640	; 0x25a8
  10bcbc:	f104 0314 	add.w	r3, r4, #20
  10bcc0:	f2c0 0112 	movt	r1, #18
  10bcc4:	f104 0210 	add.w	r2, r4, #16
  10bcc8:	f7ff ff44 	bl	10bb54 <get_resource_from_table>
            if (ret)
  10bccc:	4603      	mov	r3, r0
  10bcce:	2800      	cmp	r0, #0
  10bcd0:	d0e3      	beq.n	10bc9a <install_resource+0x7e>
                LOGE("get lvds failed\n");
  10bcd2:	f64b 51f8 	movw	r1, #48632	; 0xbdf8
  10bcd6:	f24c 0038 	movw	r0, #49208	; 0xc038
  10bcda:	f2c0 0111 	movt	r1, #17
                goto DM_FAIL;
  10bcde:	461d      	mov	r5, r3
                LOGE("get lvds failed\n");
  10bce0:	f2c0 0011 	movt	r0, #17
  10bce4:	f008 fd8e 	bl	114804 <printf>
                goto DM_FAIL;
  10bce8:	e7c6      	b.n	10bc78 <install_resource+0x5c>
        ret = get_resource_from_table(res->if_res, table_if_res, &dm->num_intf, &dm->intf);
  10bcea:	f242 51a8 	movw	r1, #9640	; 0x25a8
  10bcee:	f104 0314 	add.w	r3, r4, #20
  10bcf2:	f2c0 0112 	movt	r1, #18
  10bcf6:	f104 0210 	add.w	r2, r4, #16
  10bcfa:	f7ff ff2b 	bl	10bb54 <get_resource_from_table>
        if (ret)
  10bcfe:	4603      	mov	r3, r0
  10bd00:	2800      	cmp	r0, #0
  10bd02:	d0ca      	beq.n	10bc9a <install_resource+0x7e>
            LOGE("get dsi failed\n");
  10bd04:	f64b 51f8 	movw	r1, #48632	; 0xbdf8
  10bd08:	f24c 0014 	movw	r0, #49172	; 0xc014
  10bd0c:	f2c0 0111 	movt	r1, #17
            goto DM_FAIL;
  10bd10:	461d      	mov	r5, r3
            LOGE("get dsi failed\n");
  10bd12:	f2c0 0011 	movt	r0, #17
  10bd16:	f008 fd75 	bl	114804 <printf>
            goto DM_FAIL;
  10bd1a:	e7ad      	b.n	10bc78 <install_resource+0x5c>

0010bd1c <hal_sdm_set_pll_clk>:
    return dc_pll[dc_id];
}


void hal_sdm_set_pll_clk(display_handle *handle, int clk)
{
  10bd1c:	b5f0      	push	{r4, r5, r6, r7, r14}
  10bd1e:	4605      	mov	r5, r0
  10bd20:	b095      	sub	sp, #84	; 0x54
  10bd22:	460c      	mov	r4, r1
    struct {
        int idx;
        int clk_id;
        int clean_ref1;
        int clean_ref2;
    } idx_to_clkid[] = {
  10bd24:	f64b 5178 	movw	r1, #48504	; 0xbd78
  10bd28:	2250      	movs	r2, #80	; 0x50
  10bd2a:	f2c0 0111 	movt	r1, #17
  10bd2e:	4668      	mov	r0, r13
  10bd30:	f007 edb6 	blx	1138a0 <memcpy>

    int ret = 0;
    int pll_id = 0;
    uint8_t j = 0;

    if (!handle->res && (handle->res->dc_res < 0))
  10bd34:	68ab      	ldr	r3, [r5, #8]
  10bd36:	2b00      	cmp	r3, #0
  10bd38:	d04c      	beq.n	10bdd4 <hal_sdm_set_pll_clk+0xb8>
        return;

    for (j = 0; idx_to_clkid[j].idx != -1; j++) {
  10bd3a:	9a00      	ldr	r2, [sp, #0]
  10bd3c:	1c50      	adds	r0, r2, #1
  10bd3e:	d040      	beq.n	10bdc2 <hal_sdm_set_pll_clk+0xa6>
  10bd40:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
  10bd44:	f242 36dc 	movw	r6, #9180	; 0x23dc
    switch (handle->res->dc_res) {
  10bd48:	2300      	movs	r3, #0
  10bd4a:	f64b 57c8 	movw	r7, #48584	; 0xbdc8
    for (j = 0; idx_to_clkid[j].idx != -1; j++) {
  10bd4e:	461d      	mov	r5, r3
  10bd50:	3801      	subs	r0, #1
  10bd52:	f2c0 0612 	movt	r6, #18
  10bd56:	f2c0 0711 	movt	r7, #17
  10bd5a:	e009      	b.n	10bd70 <hal_sdm_set_pll_clk+0x54>
  10bd5c:	3301      	adds	r3, #1
  10bd5e:	aa14      	add	r2, sp, #80	; 0x50
  10bd60:	b2db      	uxtb	r3, r3
  10bd62:	461d      	mov	r5, r3
  10bd64:	eb02 1203 	add.w	r2, r2, r3, lsl #4
  10bd68:	f852 2c50 	ldr.w	r2, [r2, #-80]
  10bd6c:	1c51      	adds	r1, r2, #1
  10bd6e:	d028      	beq.n	10bdc2 <hal_sdm_set_pll_clk+0xa6>
  10bd70:	2805      	cmp	r0, #5
  10bd72:	bf8c      	ite	hi
  10bd74:	2100      	movhi	r1, #0
  10bd76:	f857 1020 	ldrls.w	r1, [r7, r0, lsl #2]
    return dc_pll[dc_id];
  10bd7a:	5c71      	ldrb	r1, [r6, r1]
        pll_id = get_wrap_id(handle);

        if (pll_id  == idx_to_clkid[j].idx)
  10bd7c:	4291      	cmp	r1, r2
  10bd7e:	d1ed      	bne.n	10bd5c <hal_sdm_set_pll_clk+0x40>
    if (idx_to_clkid[j].idx == -1) {
        dprintf(CRITICAL, "disp pll cfg -- get clk_id by idx failed.\n");
        return;
    }

    ret = res_clk_request(PER_ID_DISP, idx_to_clkid[j].clean_ref1, 0);
  10bd80:	2200      	movs	r2, #0
  10bd82:	ab14      	add	r3, sp, #80	; 0x50
  10bd84:	4610      	mov	r0, r2
  10bd86:	eb03 1505 	add.w	r5, r3, r5, lsl #4
  10bd8a:	f855 1c48 	ldr.w	r1, [r5, #-72]
  10bd8e:	f003 f887 	bl	10eea0 <res_clk_request>
    if (ret) {
  10bd92:	4602      	mov	r2, r0
  10bd94:	b140      	cbz	r0, 10bda8 <hal_sdm_set_pll_clk+0x8c>
        dprintf(CRITICAL, "disp pll cfg -- clean ref1 failed.\n");
  10bd96:	f64b 7034 	movw	r0, #48948	; 0xbf34
  10bd9a:	f2c0 0011 	movt	r0, #17
    if (ret) {
        dprintf(CRITICAL, "disp pll cfg -- set clk failed.\n");
        return;
    }
#endif
}
  10bd9e:	b015      	add	sp, #84	; 0x54
  10bda0:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
        dprintf(CRITICAL, "disp pll cfg -- get clk_id by idx failed.\n");
  10bda4:	f008 bd16 	b.w	1147d4 <puts>
    ret = res_clk_request(PER_ID_DISP, idx_to_clkid[j].clean_ref2, 0);
  10bda8:	f855 1c44 	ldr.w	r1, [r5, #-68]
  10bdac:	f003 f878 	bl	10eea0 <res_clk_request>
    if (ret) {
  10bdb0:	b998      	cbnz	r0, 10bdda <hal_sdm_set_pll_clk+0xbe>
    ret = res_clk_request(PER_ID_DISP, idx_to_clkid[j].clk_id, clk);
  10bdb2:	f855 1c4c 	ldr.w	r1, [r5, #-76]
  10bdb6:	4622      	mov	r2, r4
  10bdb8:	f003 f872 	bl	10eea0 <res_clk_request>
    if (ret) {
  10bdbc:	b9b0      	cbnz	r0, 10bdec <hal_sdm_set_pll_clk+0xd0>
}
  10bdbe:	b015      	add	sp, #84	; 0x54
  10bdc0:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "disp pll cfg -- get clk_id by idx failed.\n");
  10bdc2:	f64b 709c 	movw	r0, #49052	; 0xbf9c
  10bdc6:	f2c0 0011 	movt	r0, #17
}
  10bdca:	b015      	add	sp, #84	; 0x54
  10bdcc:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
        dprintf(CRITICAL, "disp pll cfg -- get clk_id by idx failed.\n");
  10bdd0:	f008 bd00 	b.w	1147d4 <puts>
    if (!handle->res && (handle->res->dc_res < 0))
  10bdd4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  10bdd8:	deff      	udf	#255	; 0xff
        dprintf(CRITICAL, "disp pll cfg -- clean ref2 failed.\n");
  10bdda:	f64b 7058 	movw	r0, #48984	; 0xbf58
  10bdde:	f2c0 0011 	movt	r0, #17
}
  10bde2:	b015      	add	sp, #84	; 0x54
  10bde4:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
        dprintf(CRITICAL, "disp pll cfg -- get clk_id by idx failed.\n");
  10bde8:	f008 bcf4 	b.w	1147d4 <puts>
        dprintf(CRITICAL, "disp pll cfg -- set clk failed.\n");
  10bdec:	f64b 707c 	movw	r0, #49020	; 0xbf7c
  10bdf0:	f2c0 0011 	movt	r0, #17
  10bdf4:	e7d3      	b.n	10bd9e <hal_sdm_set_pll_clk+0x82>
  10bdf6:	bf00      	nop

0010bdf8 <hal_sdm_panel_connect>:

int hal_sdm_panel_connect(display_handle *handle, int sub_id, struct sdm_panel *panel)
{
  10bdf8:	b508      	push	{r3, r14}
    return disp_panel_connect(handle, sub_id, panel) == true? 0: -1;
  10bdfa:	f7f9 fcf1 	bl	1057e0 <disp_panel_connect>
  10bdfe:	f080 0001 	eor.w	r0, r0, #1
  10be02:	b2c0      	uxtb	r0, r0
}
  10be04:	4240      	negs	r0, r0
  10be06:	bd08      	pop	{r3, r15}

0010be08 <hal_display_num>:
    return 0;
}

int hal_display_num()
{
    return g_display_num;
  10be08:	f24f 53d4 	movw	r3, #62932	; 0xf5d4
  10be0c:	f2c0 0312 	movt	r3, #18
}
  10be10:	6818      	ldr	r0, [r3, #0]
  10be12:	4770      	bx	r14

0010be14 <hal_get_display_handle>:

display_handle *hal_get_display_handle(enum DISPLAY_TYPE display)
{
  10be14:	b410      	push	{r4}
  10be16:	f24f 54d8 	movw	r4, #62936	; 0xf5d8
	int i;
	for (i = 0; i < DISPLAY_TYPE_MAX;i++) {
  10be1a:	2300      	movs	r3, #0
  10be1c:	f2c0 0412 	movt	r4, #18
  10be20:	4622      	mov	r2, r4
		display_handle *handle = &g_instances[i];
		if (handle->display_id == display)
  10be22:	6811      	ldr	r1, [r2, #0]
  10be24:	3254      	adds	r2, #84	; 0x54
  10be26:	4281      	cmp	r1, r0
  10be28:	d006      	beq.n	10be38 <hal_get_display_handle+0x24>
	for (i = 0; i < DISPLAY_TYPE_MAX;i++) {
  10be2a:	3301      	adds	r3, #1
  10be2c:	2b0a      	cmp	r3, #10
  10be2e:	d1f8      	bne.n	10be22 <hal_get_display_handle+0xe>
			return handle;
	}
    // return display < DISPLAY_TYPE_MAX ? &g_instances[display] : NULL;
    return NULL;
}
  10be30:	f85d 4b04 	ldr.w	r4, [r13], #4
    return NULL;
  10be34:	2000      	movs	r0, #0
}
  10be36:	4770      	bx	r14
		display_handle *handle = &g_instances[i];
  10be38:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  10be3c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  10be40:	eb04 0083 	add.w	r0, r4, r3, lsl #2
}
  10be44:	f85d 4b04 	ldr.w	r4, [r13], #4
  10be48:	4770      	bx	r14
  10be4a:	bf00      	nop

0010be4c <hal_get_display_handle_by_index>:

display_handle *hal_get_display_handle_by_index(uint32_t index)
{
    if (index < DISPLAY_TYPE_MAX)
  10be4c:	2809      	cmp	r0, #9
        return &g_instances[index];
  10be4e:	bf9f      	itttt	ls
  10be50:	f24f 53d8 	movwls	r3, #62936	; 0xf5d8
  10be54:	eb00 0040 	addls.w	r0, r0, r0, lsl #1
  10be58:	f2c0 0312 	movtls	r3, #18
  10be5c:	ebc0 00c0 	rsbls	r0, r0, r0, lsl #3
  10be60:	bf94      	ite	ls
  10be62:	eb03 0080 	addls.w	r0, r3, r0, lsl #2

    return NULL;
  10be66:	2000      	movhi	r0, #0
}
  10be68:	4770      	bx	r14
  10be6a:	bf00      	nop

0010be6c <hal_display_handle_install_resource>:
}

int hal_display_handle_install_resource(struct display_resource *res)
{
    static uint8_t index = 0;
    if (res->type > DISPLAY_TYPE_MAX || res->type < DISPLAY_TYPE_INVALID)
  10be6c:	f8d0 2080 	ldr.w	r2, [r0, #128]	; 0x80
{
  10be70:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (res->type > DISPLAY_TYPE_MAX || res->type < DISPLAY_TYPE_INVALID)
  10be72:	1c53      	adds	r3, r2, #1
  10be74:	2b0b      	cmp	r3, #11
  10be76:	d828      	bhi.n	10beca <hal_display_handle_install_resource+0x5e>
    {
        LOGE("Error: invalid display type: %d", res->type);
        return -1;
    }

    if (res->type == DISPLAY_TYPE_INVALID)
  10be78:	1c53      	adds	r3, r2, #1
  10be7a:	d023      	beq.n	10bec4 <hal_display_handle_install_resource+0x58>
    {
        LOGD("display may not choosed");
        return -2;
    }

    display_handle *handle = &g_instances[index++];
  10be7c:	f64f 1420 	movw	r4, #63776	; 0xf920
    handle->res = res;
  10be80:	f24f 55d8 	movw	r5, #62936	; 0xf5d8
    display_handle *handle = &g_instances[index++];
  10be84:	f2c0 0412 	movt	r4, #18
  10be88:	7821      	ldrb	r1, [r4, #0]
    handle->res = res;
  10be8a:	eb01 0341 	add.w	r3, r1, r1, lsl #1
    handle->name = res->name;
    handle->hotplug = NULL;
    handle->vsync = NULL;
    handle->inited = false;
    handle->panel_post_end_done = false;
    return install_resource(res, &handle->dm);
  10be8e:	f04f 0c54 	mov.w	r12, #84	; 0x54
    handle->res = res;
  10be92:	f2c0 0512 	movt	r5, #18
  10be96:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
    display_handle *handle = &g_instances[index++];
  10be9a:	1c4f      	adds	r7, r1, #1
    handle->res = res;
  10be9c:	009b      	lsls	r3, r3, #2
    return install_resource(res, &handle->dm);
  10be9e:	fb0c 5101 	mla	r1, r12, r1, r5
    display_handle *handle = &g_instances[index++];
  10bea2:	7027      	strb	r7, [r4, #0]
    handle->res = res;
  10bea4:	18ec      	adds	r4, r5, r3
    handle->display_id = res->type;//billy need change name.
  10bea6:	50ea      	str	r2, [r5, r3]
    handle->hotplug = NULL;
  10bea8:	2300      	movs	r3, #0
    handle->name = res->name;
  10beaa:	e9c4 0001 	strd	r0, r0, [r4, #4]
    return install_resource(res, &handle->dm);
  10beae:	310c      	adds	r1, #12
    handle->vsync = NULL;
  10beb0:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
    handle->inited = false;
  10beb4:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    handle->panel_post_end_done = false;
  10beb8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
}
  10bebc:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    return install_resource(res, &handle->dm);
  10bec0:	f7ff beac 	b.w	10bc1c <install_resource>
        return -2;
  10bec4:	f06f 0001 	mvn.w	r0, #1
}
  10bec8:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        LOGE("Error: invalid display type: %d", res->type);
  10beca:	f64b 6124 	movw	r1, #48676	; 0xbe24
  10bece:	f64b 7000 	movw	r0, #48896	; 0xbf00
  10bed2:	f2c0 0111 	movt	r1, #17
  10bed6:	f2c0 0011 	movt	r0, #17
  10beda:	f008 fc93 	bl	114804 <printf>
        return -1;
  10bede:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10bee2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010bee4 <hal_display_connect_all>:
{
  10bee4:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    res_count = ARRAY_SIZE(g_display_res);
  10bee8:	f64f 1724 	movw	r7, #63780	; 0xf924
  10beec:	2301      	movs	r3, #1
    disp_link_init(dc_pll, g_display_res, res_count);
  10beee:	f242 31e4 	movw	r1, #9188	; 0x23e4
    res_count = ARRAY_SIZE(g_display_res);
  10bef2:	f2c0 0712 	movt	r7, #18
    disp_link_init(dc_pll, g_display_res, res_count);
  10bef6:	f242 30dc 	movw	r0, #9180	; 0x23dc
  10befa:	461a      	mov	r2, r3
  10befc:	f2c0 0112 	movt	r1, #18
    res_count = ARRAY_SIZE(g_display_res);
  10bf00:	603b      	str	r3, [r7, #0]
    disp_link_init(dc_pll, g_display_res, res_count);
  10bf02:	f2c0 0012 	movt	r0, #18
  10bf06:	f000 f8b9 	bl	10c07c <disp_link_init>
    g_display_num = 0;
  10bf0a:	f24f 58d4 	movw	r8, #62932	; 0xf5d4
    for (i = 0; i < res_count; i++)
  10bf0e:	683b      	ldr	r3, [r7, #0]
    g_display_num = 0;
  10bf10:	f2c0 0812 	movt	r8, #18
  10bf14:	2600      	movs	r6, #0
  10bf16:	f8c8 6000 	str.w	r6, [r8]
    for (i = 0; i < res_count; i++)
  10bf1a:	b35b      	cbz	r3, 10bf74 <hal_display_connect_all+0x90>
  10bf1c:	f242 34e4 	movw	r4, #9188	; 0x23e4
            LOGE("Error: probe display %d-%d failed\n", i, res->type);
  10bf20:	f64b 6a0c 	movw	r10, #48652	; 0xbe0c
  10bf24:	f64b 6998 	movw	r9, #48792	; 0xbe98
    for (i = 0; i < res_count; i++)
  10bf28:	4635      	mov	r5, r6
  10bf2a:	f2c0 0412 	movt	r4, #18
            LOGE("Error: probe display %d-%d failed\n", i, res->type);
  10bf2e:	f2c0 0a11 	movt	r10, #17
  10bf32:	f2c0 0911 	movt	r9, #17
  10bf36:	e006      	b.n	10bf46 <hal_display_connect_all+0x62>
    for (i = 0; i < res_count; i++)
  10bf38:	683b      	ldr	r3, [r7, #0]
  10bf3a:	3501      	adds	r5, #1
        count++;
  10bf3c:	3601      	adds	r6, #1
    for (i = 0; i < res_count; i++)
  10bf3e:	42ab      	cmp	r3, r5
  10bf40:	f104 04a4 	add.w	r4, r4, #164	; 0xa4
  10bf44:	d911      	bls.n	10bf6a <hal_display_connect_all+0x86>
        if (hal_display_handle_install_resource(res))
  10bf46:	4620      	mov	r0, r4
  10bf48:	f7ff ff90 	bl	10be6c <hal_display_handle_install_resource>
  10bf4c:	2800      	cmp	r0, #0
  10bf4e:	d0f3      	beq.n	10bf38 <hal_display_connect_all+0x54>
            LOGE("Error: probe display %d-%d failed\n", i, res->type);
  10bf50:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  10bf54:	462a      	mov	r2, r5
  10bf56:	4651      	mov	r1, r10
  10bf58:	4648      	mov	r0, r9
  10bf5a:	f008 fc53 	bl	114804 <printf>
    for (i = 0; i < res_count; i++)
  10bf5e:	683b      	ldr	r3, [r7, #0]
  10bf60:	3501      	adds	r5, #1
  10bf62:	42ab      	cmp	r3, r5
  10bf64:	f104 04a4 	add.w	r4, r4, #164	; 0xa4
  10bf68:	d8ed      	bhi.n	10bf46 <hal_display_connect_all+0x62>
    g_display_num = count;
  10bf6a:	f8c8 6000 	str.w	r6, [r8]
}
  10bf6e:	2000      	movs	r0, #0
  10bf70:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    int count = 0;
  10bf74:	461e      	mov	r6, r3
}
  10bf76:	2000      	movs	r0, #0
    g_display_num = count;
  10bf78:	f8c8 6000 	str.w	r6, [r8]
}
  10bf7c:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}

0010bf80 <hal_display_create_handle>:

int hal_display_create_handle(display_handle **handle, enum DISPLAY_TYPE display)
{
  10bf80:	b570      	push	{r4, r5, r6, r14}
    return g_display_num;
  10bf82:	f24f 55d4 	movw	r5, #62932	; 0xf5d4
{
  10bf86:	4606      	mov	r6, r0
  10bf88:	460c      	mov	r4, r1
    return g_display_num;
  10bf8a:	f2c0 0512 	movt	r5, #18
    if (hal_display_num() == 0)
  10bf8e:	682b      	ldr	r3, [r5, #0]
  10bf90:	b1bb      	cbz	r3, 10bfc2 <hal_display_create_handle+0x42>
  10bf92:	f24f 51d8 	movw	r1, #62936	; 0xf5d8
{
  10bf96:	2300      	movs	r3, #0
  10bf98:	f2c0 0112 	movt	r1, #18
  10bf9c:	460a      	mov	r2, r1
		if (handle->display_id == display)
  10bf9e:	6810      	ldr	r0, [r2, #0]
  10bfa0:	3254      	adds	r2, #84	; 0x54
  10bfa2:	4284      	cmp	r4, r0
  10bfa4:	d006      	beq.n	10bfb4 <hal_display_create_handle+0x34>
	for (i = 0; i < DISPLAY_TYPE_MAX;i++) {
  10bfa6:	3301      	adds	r3, #1
  10bfa8:	2b0a      	cmp	r3, #10
  10bfaa:	d1f8      	bne.n	10bf9e <hal_display_create_handle+0x1e>
    return NULL;
  10bfac:	2300      	movs	r3, #0
    {
        hal_display_connect_all();
    }
    if (hal_display_num())
        *handle = hal_get_display_handle(display);
  10bfae:	6033      	str	r3, [r6, #0]
        LOGE("can not found any display\n");
        *handle = NULL;
        return -1;
    }

    return 0;
  10bfb0:	2000      	movs	r0, #0
}
  10bfb2:	bd70      	pop	{r4, r5, r6, r15}
		display_handle *handle = &g_instances[i];
  10bfb4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  10bfb8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  10bfbc:	eb01 0383 	add.w	r3, r1, r3, lsl #2
  10bfc0:	e7f5      	b.n	10bfae <hal_display_create_handle+0x2e>
        hal_display_connect_all();
  10bfc2:	f7ff ff8f 	bl	10bee4 <hal_display_connect_all>
    if (hal_display_num())
  10bfc6:	682d      	ldr	r5, [r5, #0]
  10bfc8:	2d00      	cmp	r5, #0
  10bfca:	d1e2      	bne.n	10bf92 <hal_display_create_handle+0x12>
        LOGE("can not found any display\n");
  10bfcc:	f64b 6148 	movw	r1, #48712	; 0xbe48
  10bfd0:	f64b 60d0 	movw	r0, #48848	; 0xbed0
  10bfd4:	f2c0 0111 	movt	r1, #17
  10bfd8:	f2c0 0011 	movt	r0, #17
  10bfdc:	f008 fc12 	bl	114804 <printf>
        *handle = NULL;
  10bfe0:	6035      	str	r5, [r6, #0]
        return -1;
  10bfe2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10bfe6:	bd70      	pop	{r4, r5, r6, r15}

0010bfe8 <hal_display_release_handle>:

void hal_display_release_handle(display_handle *handle)
{
    LOGD("%d:%s released\n", handle->display_id, handle->name);
}
  10bfe8:	4770      	bx	r14
  10bfea:	bf00      	nop

0010bfec <hal_sdm_init>:

int hal_sdm_init(display_handle *handle)
{
    return disp_init(handle);
  10bfec:	f7f9 b8a4 	b.w	105138 <disp_init>

0010bff0 <hal_sdm_post_config>:
}

int hal_sdm_post_config(display_handle *handle, struct sdm_post_config *post)
{
    /*For sis funciton*/
    if (handle->panels[handle->found_panel]->rtos_screen) {
  10bff0:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
  10bff2:	b4f0      	push	{r4, r5, r6, r7}
    if (handle->panels[handle->found_panel]->rtos_screen) {
  10bff4:	eb00 0383 	add.w	r3, r0, r3, lsl #2
  10bff8:	695b      	ldr	r3, [r3, #20]
  10bffa:	6b1e      	ldr	r6, [r3, #48]	; 0x30
  10bffc:	b19e      	cbz	r6, 10c026 <hal_sdm_post_config+0x36>
        for (size_t i = 0; i < post->n_bufs; i++)
  10bffe:	680a      	ldr	r2, [r1, #0]
  10c000:	b18a      	cbz	r2, 10c026 <hal_sdm_post_config+0x36>
  10c002:	684b      	ldr	r3, [r1, #4]
  10c004:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
  10c008:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
            if (post->bufs[i].layer_en) {
  10c00c:	689c      	ldr	r4, [r3, #8]
  10c00e:	b13c      	cbz	r4, 10c020 <hal_sdm_post_config+0x30>
                post->bufs[i].dst.x += handle->panels[handle->found_panel]->rtos_screen->pos_x;
  10c010:	6837      	ldr	r7, [r6, #0]
  10c012:	6d1d      	ldr	r5, [r3, #80]	; 0x50
                post->bufs[i].dst.y += handle->panels[handle->found_panel]->rtos_screen->pos_y;
  10c014:	6d5c      	ldr	r4, [r3, #84]	; 0x54
                post->bufs[i].dst.x += handle->panels[handle->found_panel]->rtos_screen->pos_x;
  10c016:	443d      	add	r5, r7
  10c018:	651d      	str	r5, [r3, #80]	; 0x50
                post->bufs[i].dst.y += handle->panels[handle->found_panel]->rtos_screen->pos_y;
  10c01a:	6875      	ldr	r5, [r6, #4]
  10c01c:	442c      	add	r4, r5
  10c01e:	655c      	str	r4, [r3, #84]	; 0x54
  10c020:	3378      	adds	r3, #120	; 0x78
        for (size_t i = 0; i < post->n_bufs; i++)
  10c022:	4293      	cmp	r3, r2
  10c024:	d1f2      	bne.n	10c00c <hal_sdm_post_config+0x1c>
            }
    }

    return disp_post_config(handle, post);
}
  10c026:	bcf0      	pop	{r4, r5, r6, r7}
    return disp_post_config(handle, post);
  10c028:	f7f9 ba90 	b.w	10554c <disp_post_config>

0010c02c <disp_link_get_cfg_info>:
  10c02c:	b570      	push	{r4, r5, r6, r14}
  10c02e:	f64f 1434 	movw	r4, #63796	; 0xf934
  10c032:	b082      	sub	sp, #8
  10c034:	2300      	movs	r3, #0
  10c036:	f2c0 0412 	movt	r4, #18
  10c03a:	9301      	str	r3, [sp, #4]
  10c03c:	6825      	ldr	r5, [r4, #0]
  10c03e:	b11d      	cbz	r5, 10c048 <disp_link_get_cfg_info+0x1c>
  10c040:	461d      	mov	r5, r3
  10c042:	4628      	mov	r0, r5
  10c044:	b002      	add	sp, #8
  10c046:	bd70      	pop	{r4, r5, r6, r15}
  10c048:	2002      	movs	r0, #2
  10c04a:	a901      	add	r1, sp, #4
  10c04c:	f008 fc5c 	bl	114908 <get_config_info>
  10c050:	9b01      	ldr	r3, [sp, #4]
  10c052:	b183      	cbz	r3, 10c076 <disp_link_get_cfg_info+0x4a>
  10c054:	f64f 1140 	movw	r1, #63808	; 0xf940
  10c058:	f64f 1228 	movw	r2, #63784	; 0xf928
  10c05c:	f2c0 0112 	movt	r1, #18
  10c060:	2001      	movs	r0, #1
  10c062:	f2c0 0212 	movt	r2, #18
  10c066:	f853 6b04 	ldr.w	r6, [r3], #4
  10c06a:	6020      	str	r0, [r4, #0]
  10c06c:	4628      	mov	r0, r5
  10c06e:	600b      	str	r3, [r1, #0]
  10c070:	6016      	str	r6, [r2, #0]
  10c072:	b002      	add	sp, #8
  10c074:	bd70      	pop	{r4, r5, r6, r15}
  10c076:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  10c07a:	e7e2      	b.n	10c042 <disp_link_get_cfg_info+0x16>

0010c07c <disp_link_init>:
  10c07c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10c080:	4605      	mov	r5, r0
  10c082:	b085      	sub	sp, #20
  10c084:	2900      	cmp	r1, #0
  10c086:	f000 8308 	beq.w	10c69a <disp_link_init+0x61e>
  10c08a:	f64f 1040 	movw	r0, #63808	; 0xf940
  10c08e:	f64f 1328 	movw	r3, #63784	; 0xf928
  10c092:	f2c0 0012 	movt	r0, #18
  10c096:	f2c0 0312 	movt	r3, #18
  10c09a:	6001      	str	r1, [r0, #0]
  10c09c:	601a      	str	r2, [r3, #0]
  10c09e:	f64f 1438 	movw	r4, #63800	; 0xf938
  10c0a2:	1e6b      	subs	r3, r5, #1
  10c0a4:	f2c0 0412 	movt	r4, #18
  10c0a8:	4622      	mov	r2, r4
  10c0aa:	1d28      	adds	r0, r5, #4
  10c0ac:	f813 1f01 	ldrb.w	r1, [r3, #1]!
  10c0b0:	f802 1b01 	strb.w	r1, [r2], #1
  10c0b4:	4298      	cmp	r0, r3
  10c0b6:	d1f9      	bne.n	10c0ac <disp_link_init+0x30>
  10c0b8:	200b      	movs	r0, #11
  10c0ba:	f005 fa49 	bl	111550 <malloc>
  10c0be:	2800      	cmp	r0, #0
  10c0c0:	f000 832f 	beq.w	10c722 <disp_link_init+0x6a6>
  10c0c4:	f64f 1a28 	movw	r10, #63784	; 0xf928
  10c0c8:	f64f 1b30 	movw	r11, #63792	; 0xf930
  10c0cc:	f2c0 0a12 	movt	r10, #18
  10c0d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10c0d4:	f2c0 0b12 	movt	r11, #18
  10c0d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  10c0dc:	f64f 1644 	movw	r6, #63812	; 0xf944
  10c0e0:	f8da 1000 	ldr.w	r1, [r10]
  10c0e4:	f2c0 0612 	movt	r6, #18
  10c0e8:	f8db c000 	ldr.w	r12, [r11]
  10c0ec:	f896 e000 	ldrb.w	r14, [r6]
  10c0f0:	6003      	str	r3, [r0, #0]
  10c0f2:	2500      	movs	r5, #0
  10c0f4:	6043      	str	r3, [r0, #4]
  10c0f6:	8103      	strh	r3, [r0, #8]
  10c0f8:	7282      	strb	r2, [r0, #10]
  10c0fa:	2900      	cmp	r1, #0
  10c0fc:	f000 815a 	beq.w	10c3b4 <disp_link_init+0x338>
  10c100:	f64f 1340 	movw	r3, #63808	; 0xf940
  10c104:	eb01 0281 	add.w	r2, r1, r1, lsl #2
  10c108:	4677      	mov	r7, r14
  10c10a:	f2c0 0312 	movt	r3, #18
  10c10e:	f04f 0801 	mov.w	r8, #1
  10c112:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  10c116:	681b      	ldr	r3, [r3, #0]
  10c118:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  10c11c:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
  10c120:	2a03      	cmp	r2, #3
  10c122:	d80e      	bhi.n	10c142 <disp_link_init+0xc6>
  10c124:	e8df f002 	tbb	[r15, r2]
  10c128:	021e2622 	.word	0x021e2622
  10c12c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c130:	2a05      	cmp	r2, #5
  10c132:	bf0b      	itete	eq
  10c134:	f44f 7280 	moveq.w	r2, #256	; 0x100
  10c138:	b2d2      	uxtbne	r2, r2
  10c13a:	8002      	strheq	r2, [r0, #0]
  10c13c:	7002      	strbne	r2, [r0, #0]
  10c13e:	bf18      	it	ne
  10c140:	7042      	strbne	r2, [r0, #1]
  10c142:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  10c146:	2a0a      	cmp	r2, #10
  10c148:	d81b      	bhi.n	10c182 <disp_link_init+0x106>
  10c14a:	e8df f012 	tbh	[r15, r2, lsl #1]
  10c14e:	0017      	.short	0x0017
  10c150:	0112011a 	.word	0x0112011a
  10c154:	0102010a 	.word	0x0102010a
  10c158:	00f200fa 	.word	0x00f200fa
  10c15c:	00d800e5 	.word	0x00d800e5
  10c160:	0122001a 	.word	0x0122001a
  10c164:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c168:	7082      	strb	r2, [r0, #2]
  10c16a:	e7ea      	b.n	10c142 <disp_link_init+0xc6>
  10c16c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c170:	7002      	strb	r2, [r0, #0]
  10c172:	e7e6      	b.n	10c142 <disp_link_init+0xc6>
  10c174:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c178:	7042      	strb	r2, [r0, #1]
  10c17a:	e7e2      	b.n	10c142 <disp_link_init+0xc6>
  10c17c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c180:	7142      	strb	r2, [r0, #5]
  10c182:	33a4      	adds	r3, #164	; 0xa4
  10c184:	4299      	cmp	r1, r3
  10c186:	d1c9      	bne.n	10c11c <disp_link_init+0xa0>
  10c188:	2d00      	cmp	r5, #0
  10c18a:	f040 82cd 	bne.w	10c728 <disp_link_init+0x6ac>
  10c18e:	f890 9000 	ldrb.w	r9, [r0]
  10c192:	7841      	ldrb	r1, [r0, #1]
  10c194:	7882      	ldrb	r2, [r0, #2]
  10c196:	78c6      	ldrb	r6, [r0, #3]
  10c198:	7907      	ldrb	r7, [r0, #4]
  10c19a:	f890 8005 	ldrb.w	r8, [r0, #5]
  10c19e:	7985      	ldrb	r5, [r0, #6]
  10c1a0:	f10c 0340 	add.w	r3, r12, #64	; 0x40
  10c1a4:	f1bc 0f00 	cmp.w	r12, #0
  10c1a8:	f000 810e 	beq.w	10c3c8 <disp_link_init+0x34c>
  10c1ac:	f8d3 c000 	ldr.w	r12, [r3]
  10c1b0:	f1b9 0f00 	cmp.w	r9, #0
  10c1b4:	f000 8117 	beq.w	10c3e6 <disp_link_init+0x36a>
  10c1b8:	f1b9 0f01 	cmp.w	r9, #1
  10c1bc:	bf08      	it	eq
  10c1be:	f04f 0c00 	moveq.w	r12, #0
  10c1c2:	2900      	cmp	r1, #0
  10c1c4:	f000 8114 	beq.w	10c3f0 <disp_link_init+0x374>
  10c1c8:	2901      	cmp	r1, #1
  10c1ca:	bf08      	it	eq
  10c1cc:	f02c 0c02 	biceq.w	r12, r12, #2
  10c1d0:	2a02      	cmp	r2, #2
  10c1d2:	f000 8116 	beq.w	10c402 <disp_link_init+0x386>
  10c1d6:	2a03      	cmp	r2, #3
  10c1d8:	f040 811e 	bne.w	10c418 <disp_link_init+0x39c>
  10c1dc:	ea6f 020c 	mvn.w	r2, r12
  10c1e0:	f002 0204 	and.w	r2, r2, #4
  10c1e4:	ea82 020c 	eor.w	r2, r2, r12
  10c1e8:	601a      	str	r2, [r3, #0]
  10c1ea:	f8db 3000 	ldr.w	r3, [r11]
  10c1ee:	f64f 112c 	movw	r1, #63788	; 0xf92c
  10c1f2:	f2c0 0112 	movt	r1, #18
  10c1f6:	f103 0c04 	add.w	r12, r3, #4
  10c1fa:	f103 0988 	add.w	r9, r3, #136	; 0x88
  10c1fe:	680a      	ldr	r2, [r1, #0]
  10c200:	2a00      	cmp	r2, #0
  10c202:	f000 824d 	beq.w	10c6a0 <disp_link_init+0x624>
  10c206:	1d11      	adds	r1, r2, #4
  10c208:	2e04      	cmp	r6, #4
  10c20a:	9100      	str	r1, [sp, #0]
  10c20c:	f240 822a 	bls.w	10c664 <disp_link_init+0x5e8>
  10c210:	2f04      	cmp	r7, #4
  10c212:	f240 8211 	bls.w	10c638 <disp_link_init+0x5bc>
  10c216:	f1b8 0f04 	cmp.w	r8, #4
  10c21a:	f240 81bc 	bls.w	10c596 <disp_link_init+0x51a>
  10c21e:	f8c9 e000 	str.w	r14, [r9]
  10c222:	2d01      	cmp	r5, #1
  10c224:	f8dc 6000 	ldr.w	r6, [r12]
  10c228:	f240 81c5 	bls.w	10c5b6 <disp_link_init+0x53a>
  10c22c:	6895      	ldr	r5, [r2, #8]
  10c22e:	f025 5500 	bic.w	r5, r5, #536870912	; 0x20000000
  10c232:	6095      	str	r5, [r2, #8]
  10c234:	f890 e007 	ldrb.w	r14, [r0, #7]
  10c238:	f1be 0f06 	cmp.w	r14, #6
  10c23c:	f890 c008 	ldrb.w	r12, [r0, #8]
  10c240:	bf96      	itet	ls
  10c242:	f24c 0560 	movwls	r5, #49248	; 0xc060
  10c246:	2507      	movhi	r5, #7
  10c248:	f2c0 0511 	movtls	r5, #17
  10c24c:	f894 8000 	ldrb.w	r8, [r4]
  10c250:	f8c3 800c 	str.w	r8, [r3, #12]
  10c254:	f894 9001 	ldrb.w	r9, [r4, #1]
  10c258:	f8c3 9010 	str.w	r9, [r3, #16]
  10c25c:	78a1      	ldrb	r1, [r4, #2]
  10c25e:	bf98      	it	ls
  10c260:	f855 502e 	ldrls.w	r5, [r5, r14, lsl #2]
  10c264:	f1bc 0f06 	cmp.w	r12, #6
  10c268:	6159      	str	r1, [r3, #20]
  10c26a:	7a47      	ldrb	r7, [r0, #9]
  10c26c:	9101      	str	r1, [sp, #4]
  10c26e:	78e1      	ldrb	r1, [r4, #3]
  10c270:	6199      	str	r1, [r3, #24]
  10c272:	ea85 0506 	eor.w	r5, r5, r6
  10c276:	9102      	str	r1, [sp, #8]
  10c278:	7921      	ldrb	r1, [r4, #4]
  10c27a:	9103      	str	r1, [sp, #12]
  10c27c:	f005 0507 	and.w	r5, r5, #7
  10c280:	61d9      	str	r1, [r3, #28]
  10c282:	bf9a      	itte	ls
  10c284:	f24c 0160 	movwls	r1, #49248	; 0xc060
  10c288:	f2c0 0111 	movtls	r1, #17
  10c28c:	2138      	movhi	r1, #56	; 0x38
  10c28e:	ea86 0605 	eor.w	r6, r6, r5
  10c292:	bf9c      	itt	ls
  10c294:	f851 102c 	ldrls.w	r1, [r1, r12, lsl #2]
  10c298:	00c9      	lslls	r1, r1, #3
  10c29a:	4071      	eors	r1, r6
  10c29c:	f001 0138 	and.w	r1, r1, #56	; 0x38
  10c2a0:	2f06      	cmp	r7, #6
  10c2a2:	ea81 0506 	eor.w	r5, r1, r6
  10c2a6:	7a86      	ldrb	r6, [r0, #10]
  10c2a8:	bf97      	itett	ls
  10c2aa:	f24c 0160 	movwls	r1, #49248	; 0xc060
  10c2ae:	f44f 71e0 	movhi.w	r1, #448	; 0x1c0
  10c2b2:	f2c0 0111 	movtls	r1, #17
  10c2b6:	f851 1027 	ldrls.w	r1, [r1, r7, lsl #2]
  10c2ba:	bf98      	it	ls
  10c2bc:	0189      	lslls	r1, r1, #6
  10c2be:	4069      	eors	r1, r5
  10c2c0:	2e06      	cmp	r6, #6
  10c2c2:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
  10c2c6:	ea81 0105 	eor.w	r1, r1, r5
  10c2ca:	bf97      	itett	ls
  10c2cc:	f24c 0560 	movwls	r5, #49248	; 0xc060
  10c2d0:	f44f 6560 	movhi.w	r5, #3584	; 0xe00
  10c2d4:	f2c0 0511 	movtls	r5, #17
  10c2d8:	f855 5026 	ldrls.w	r5, [r5, r6, lsl #2]
  10c2dc:	bf98      	it	ls
  10c2de:	026d      	lslls	r5, r5, #9
  10c2e0:	404d      	eors	r5, r1
  10c2e2:	f405 6560 	and.w	r5, r5, #3584	; 0xe00
  10c2e6:	4069      	eors	r1, r5
  10c2e8:	f1be 0f04 	cmp.w	r14, #4
  10c2ec:	f200 809d 	bhi.w	10c42a <disp_link_init+0x3ae>
  10c2f0:	e8df f01e 	tbh	[r15, r14, lsl #1]
  10c2f4:	01ee0095 	.word	0x01ee0095
  10c2f8:	01f201f0 	.word	0x01f201f0
  10c2fc:	01f4      	.short	0x01f4
  10c2fe:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
  10c302:	33a4      	adds	r3, #164	; 0xa4
  10c304:	4299      	cmp	r1, r3
  10c306:	7242      	strb	r2, [r0, #9]
  10c308:	f047 0702 	orr.w	r7, r7, #2
  10c30c:	7282      	strb	r2, [r0, #10]
  10c30e:	f04f 0501 	mov.w	r5, #1
  10c312:	f47f af03 	bne.w	10c11c <disp_link_init+0xa0>
  10c316:	e737      	b.n	10c188 <disp_link_init+0x10c>
  10c318:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
  10c31c:	33a4      	adds	r3, #164	; 0xa4
  10c31e:	4299      	cmp	r1, r3
  10c320:	71c2      	strb	r2, [r0, #7]
  10c322:	f047 0701 	orr.w	r7, r7, #1
  10c326:	7202      	strb	r2, [r0, #8]
  10c328:	f04f 0501 	mov.w	r5, #1
  10c32c:	f47f aef6 	bne.w	10c11c <disp_link_init+0xa0>
  10c330:	e72a      	b.n	10c188 <disp_link_init+0x10c>
  10c332:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c336:	33a4      	adds	r3, #164	; 0xa4
  10c338:	7282      	strb	r2, [r0, #10]
  10c33a:	4299      	cmp	r1, r3
  10c33c:	f47f aeee 	bne.w	10c11c <disp_link_init+0xa0>
  10c340:	e722      	b.n	10c188 <disp_link_init+0x10c>
  10c342:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c346:	33a4      	adds	r3, #164	; 0xa4
  10c348:	7242      	strb	r2, [r0, #9]
  10c34a:	4299      	cmp	r1, r3
  10c34c:	f47f aee6 	bne.w	10c11c <disp_link_init+0xa0>
  10c350:	e71a      	b.n	10c188 <disp_link_init+0x10c>
  10c352:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c356:	33a4      	adds	r3, #164	; 0xa4
  10c358:	7202      	strb	r2, [r0, #8]
  10c35a:	4299      	cmp	r1, r3
  10c35c:	f47f aede 	bne.w	10c11c <disp_link_init+0xa0>
  10c360:	e712      	b.n	10c188 <disp_link_init+0x10c>
  10c362:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c366:	33a4      	adds	r3, #164	; 0xa4
  10c368:	71c2      	strb	r2, [r0, #7]
  10c36a:	4299      	cmp	r1, r3
  10c36c:	f47f aed6 	bne.w	10c11c <disp_link_init+0xa0>
  10c370:	e70a      	b.n	10c188 <disp_link_init+0x10c>
  10c372:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c376:	33a4      	adds	r3, #164	; 0xa4
  10c378:	7102      	strb	r2, [r0, #4]
  10c37a:	4299      	cmp	r1, r3
  10c37c:	f47f aece 	bne.w	10c11c <disp_link_init+0xa0>
  10c380:	e702      	b.n	10c188 <disp_link_init+0x10c>
  10c382:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c386:	33a4      	adds	r3, #164	; 0xa4
  10c388:	70c2      	strb	r2, [r0, #3]
  10c38a:	4299      	cmp	r1, r3
  10c38c:	f47f aec6 	bne.w	10c11c <disp_link_init+0xa0>
  10c390:	e6fa      	b.n	10c188 <disp_link_init+0x10c>
  10c392:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
  10c396:	33a4      	adds	r3, #164	; 0xa4
  10c398:	f843 8c14 	str.w	r8, [r3, #-20]
  10c39c:	f047 0704 	orr.w	r7, r7, #4
  10c3a0:	2501      	movs	r5, #1
  10c3a2:	2a05      	cmp	r2, #5
  10c3a4:	bf14      	ite	ne
  10c3a6:	4642      	movne	r2, r8
  10c3a8:	2200      	moveq	r2, #0
  10c3aa:	4299      	cmp	r1, r3
  10c3ac:	7182      	strb	r2, [r0, #6]
  10c3ae:	f47f aeb5 	bne.w	10c11c <disp_link_init+0xa0>
  10c3b2:	e6e9      	b.n	10c188 <disp_link_init+0x10c>
  10c3b4:	f1bc 0f00 	cmp.w	r12, #0
  10c3b8:	d126      	bne.n	10c408 <disp_link_init+0x38c>
  10c3ba:	25ff      	movs	r5, #255	; 0xff
  10c3bc:	46a8      	mov	r8, r5
  10c3be:	462f      	mov	r7, r5
  10c3c0:	462e      	mov	r6, r5
  10c3c2:	462a      	mov	r2, r5
  10c3c4:	4629      	mov	r1, r5
  10c3c6:	46a9      	mov	r9, r5
  10c3c8:	2340      	movs	r3, #64	; 0x40
  10c3ca:	f04f 0c00 	mov.w	r12, #0
  10c3ce:	f2cf 03d5 	movt	r3, #61653	; 0xf0d5
  10c3d2:	f2cf 0cd5 	movt	r12, #61653	; 0xf0d5
  10c3d6:	f8cb c000 	str.w	r12, [r11]
  10c3da:	f8d3 c000 	ldr.w	r12, [r3]
  10c3de:	f1b9 0f00 	cmp.w	r9, #0
  10c3e2:	f47f aee9 	bne.w	10c1b8 <disp_link_init+0x13c>
  10c3e6:	f04f 0c01 	mov.w	r12, #1
  10c3ea:	2900      	cmp	r1, #0
  10c3ec:	f47f aeec 	bne.w	10c1c8 <disp_link_init+0x14c>
  10c3f0:	ea6f 010c 	mvn.w	r1, r12
  10c3f4:	2a02      	cmp	r2, #2
  10c3f6:	f001 0102 	and.w	r1, r1, #2
  10c3fa:	ea8c 0c01 	eor.w	r12, r12, r1
  10c3fe:	f47f aeea 	bne.w	10c1d6 <disp_link_init+0x15a>
  10c402:	f02c 0204 	bic.w	r2, r12, #4
  10c406:	e6ef      	b.n	10c1e8 <disp_link_init+0x16c>
  10c408:	26ff      	movs	r6, #255	; 0xff
  10c40a:	f10c 0340 	add.w	r3, r12, #64	; 0x40
  10c40e:	f8dc c040 	ldr.w	r12, [r12, #64]	; 0x40
  10c412:	4637      	mov	r7, r6
  10c414:	46b0      	mov	r8, r6
  10c416:	4635      	mov	r5, r6
  10c418:	f8c3 c000 	str.w	r12, [r3]
  10c41c:	e6e5      	b.n	10c1ea <disp_link_init+0x16e>
  10c41e:	4645      	mov	r5, r8
  10c420:	ea81 3545 	eor.w	r5, r1, r5, lsl #13
  10c424:	f405 45c0 	and.w	r5, r5, #24576	; 0x6000
  10c428:	4069      	eors	r1, r5
  10c42a:	f1bc 0f04 	cmp.w	r12, #4
  10c42e:	d809      	bhi.n	10c444 <disp_link_init+0x3c8>
  10c430:	e8df f01c 	tbh	[r15, r12, lsl #1]
  10c434:	01560005 	.word	0x01560005
  10c438:	015a0158 	.word	0x015a0158
  10c43c:	015c      	.short	0x015c
  10c43e:	4645      	mov	r5, r8
  10c440:	f365 31d0 	bfi	r1, r5, #15, #2
  10c444:	2f04      	cmp	r7, #4
  10c446:	d809      	bhi.n	10c45c <disp_link_init+0x3e0>
  10c448:	e8df f017 	tbh	[r15, r7, lsl #1]
  10c44c:	01520005 	.word	0x01520005
  10c450:	01560154 	.word	0x01560154
  10c454:	0158      	.short	0x0158
  10c456:	4645      	mov	r5, r8
  10c458:	f365 4152 	bfi	r1, r5, #17, #2
  10c45c:	2e04      	cmp	r6, #4
  10c45e:	d80a      	bhi.n	10c476 <disp_link_init+0x3fa>
  10c460:	e8df f016 	tbh	[r15, r6, lsl #1]
  10c464:	01540007 	.word	0x01540007
  10c468:	0151014e 	.word	0x0151014e
  10c46c:	0005      	.short	0x0005
  10c46e:	f8dd 800c 	ldr.w	r8, [r13, #12]
  10c472:	f368 41d4 	bfi	r1, r8, #19, #2
  10c476:	9d00      	ldr	r5, [sp, #0]
  10c478:	6029      	str	r1, [r5, #0]
  10c47a:	f8da c000 	ldr.w	r12, [r10]
  10c47e:	f1bc 0f00 	cmp.w	r12, #0
  10c482:	f000 8145 	beq.w	10c710 <disp_link_init+0x694>
  10c486:	f64f 1140 	movw	r1, #63808	; 0xf940
  10c48a:	eb0c 078c 	add.w	r7, r12, r12, lsl #2
  10c48e:	f24c 0e7c 	movw	r14, #49276	; 0xc07c
  10c492:	f2c0 0112 	movt	r1, #18
  10c496:	eb0c 07c7 	add.w	r7, r12, r7, lsl #3
  10c49a:	f2c0 0e11 	movt	r14, #17
  10c49e:	680e      	ldr	r6, [r1, #0]
  10c4a0:	4635      	mov	r5, r6
  10c4a2:	eb06 0787 	add.w	r7, r6, r7, lsl #2
  10c4a6:	f8d5 1088 	ldr.w	r1, [r5, #136]	; 0x88
  10c4aa:	f04f 0800 	mov.w	r8, #0
  10c4ae:	f8d5 9094 	ldr.w	r9, [r5, #148]	; 0x94
  10c4b2:	35a4      	adds	r5, #164	; 0xa4
  10c4b4:	3901      	subs	r1, #1
  10c4b6:	2905      	cmp	r1, #5
  10c4b8:	bf98      	it	ls
  10c4ba:	f85e 8021 	ldrls.w	r8, [r14, r1, lsl #2]
  10c4be:	f814 8008 	ldrb.w	r8, [r4, r8]
  10c4c2:	ea4f 4808 	mov.w	r8, r8, lsl #16
  10c4c6:	f508 3880 	add.w	r8, r8, #65536	; 0x10000
  10c4ca:	f108 0804 	add.w	r8, r8, #4
  10c4ce:	f1b9 0f02 	cmp.w	r9, #2
  10c4d2:	bf14      	ite	ne
  10c4d4:	f04f 0926 	movne.w	r9, #38	; 0x26
  10c4d8:	f04f 092a 	moveq.w	r9, #42	; 0x2a
  10c4dc:	f858 1002 	ldr.w	r1, [r8, r2]
  10c4e0:	f421 61f0 	bic.w	r1, r1, #1920	; 0x780
  10c4e4:	f021 0101 	bic.w	r1, r1, #1
  10c4e8:	bf08      	it	eq
  10c4ea:	f041 0101 	orreq.w	r1, r1, #1
  10c4ee:	f421 61f7 	bic.w	r1, r1, #1976	; 0x7b8
  10c4f2:	f021 0106 	bic.w	r1, r1, #6
  10c4f6:	ea41 0109 	orr.w	r1, r1, r9
  10c4fa:	42bd      	cmp	r5, r7
  10c4fc:	f848 1002 	str.w	r1, [r8, r2]
  10c500:	d1d1      	bne.n	10c4a6 <disp_link_init+0x42a>
  10c502:	2b00      	cmp	r3, #0
  10c504:	f000 80c2 	beq.w	10c68c <disp_link_init+0x610>
  10c508:	f24c 0594 	movw	r5, #49300	; 0xc094
  10c50c:	2400      	movs	r4, #0
  10c50e:	f2c0 0511 	movt	r5, #17
  10c512:	f8d6 208c 	ldr.w	r2, [r6, #140]	; 0x8c
  10c516:	2a01      	cmp	r2, #1
  10c518:	d10d      	bne.n	10c536 <disp_link_init+0x4ba>
  10c51a:	f896 2098 	ldrb.w	r2, [r6, #152]	; 0x98
  10c51e:	6b19      	ldr	r1, [r3, #48]	; 0x30
  10c520:	2a03      	cmp	r2, #3
  10c522:	bf94      	ite	ls
  10c524:	5caa      	ldrbls	r2, [r5, r2]
  10c526:	2203      	movhi	r2, #3
  10c528:	404a      	eors	r2, r1
  10c52a:	f002 0203 	and.w	r2, r2, #3
  10c52e:	404a      	eors	r2, r1
  10c530:	631a      	str	r2, [r3, #48]	; 0x30
  10c532:	f8d6 208c 	ldr.w	r2, [r6, #140]	; 0x8c
  10c536:	2a02      	cmp	r2, #2
  10c538:	d10d      	bne.n	10c556 <disp_link_init+0x4da>
  10c53a:	f896 2098 	ldrb.w	r2, [r6, #152]	; 0x98
  10c53e:	6b99      	ldr	r1, [r3, #56]	; 0x38
  10c540:	2a03      	cmp	r2, #3
  10c542:	bf94      	ite	ls
  10c544:	5caa      	ldrbls	r2, [r5, r2]
  10c546:	2203      	movhi	r2, #3
  10c548:	404a      	eors	r2, r1
  10c54a:	f002 0203 	and.w	r2, r2, #3
  10c54e:	404a      	eors	r2, r1
  10c550:	639a      	str	r2, [r3, #56]	; 0x38
  10c552:	f8d6 208c 	ldr.w	r2, [r6, #140]	; 0x8c
  10c556:	2a09      	cmp	r2, #9
  10c558:	d112      	bne.n	10c580 <disp_link_init+0x504>
  10c55a:	f896 2098 	ldrb.w	r2, [r6, #152]	; 0x98
  10c55e:	6b1f      	ldr	r7, [r3, #48]	; 0x30
  10c560:	2a03      	cmp	r2, #3
  10c562:	bf94      	ite	ls
  10c564:	5caa      	ldrbls	r2, [r5, r2]
  10c566:	2203      	movhi	r2, #3
  10c568:	ea87 0102 	eor.w	r1, r7, r2
  10c56c:	f001 0103 	and.w	r1, r1, #3
  10c570:	4079      	eors	r1, r7
  10c572:	6319      	str	r1, [r3, #48]	; 0x30
  10c574:	6b99      	ldr	r1, [r3, #56]	; 0x38
  10c576:	404a      	eors	r2, r1
  10c578:	f002 0203 	and.w	r2, r2, #3
  10c57c:	404a      	eors	r2, r1
  10c57e:	639a      	str	r2, [r3, #56]	; 0x38
  10c580:	3401      	adds	r4, #1
  10c582:	4564      	cmp	r4, r12
  10c584:	f106 06a4 	add.w	r6, r6, #164	; 0xa4
  10c588:	d3c3      	bcc.n	10c512 <disp_link_init+0x496>
  10c58a:	f004 fff7 	bl	11157c <free>
  10c58e:	2000      	movs	r0, #0
  10c590:	b005      	add	sp, #20
  10c592:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10c596:	f24c 0198 	movw	r1, #49304	; 0xc098
  10c59a:	f2c0 0111 	movt	r1, #17
  10c59e:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  10c5a2:	2900      	cmp	r1, #0
  10c5a4:	bfa8      	it	ge
  10c5a6:	6099      	strge	r1, [r3, #8]
  10c5a8:	2d01      	cmp	r5, #1
  10c5aa:	f8c9 e000 	str.w	r14, [r9]
  10c5ae:	f8dc 6000 	ldr.w	r6, [r12]
  10c5b2:	f63f ae3b 	bhi.w	10c22c <disp_link_init+0x1b0>
  10c5b6:	f8d2 c008 	ldr.w	r12, [r2, #8]
  10c5ba:	f026 0107 	bic.w	r1, r6, #7
  10c5be:	f041 0605 	orr.w	r6, r1, #5
  10c5c2:	ea6f 070c 	mvn.w	r7, r12
  10c5c6:	f007 5700 	and.w	r7, r7, #536870912	; 0x20000000
  10c5ca:	ea87 070c 	eor.w	r7, r7, r12
  10c5ce:	43f1      	mvns	r1, r6
  10c5d0:	6097      	str	r7, [r2, #8]
  10c5d2:	f001 0138 	and.w	r1, r1, #56	; 0x38
  10c5d6:	f8d2 c008 	ldr.w	r12, [r2, #8]
  10c5da:	4071      	eors	r1, r6
  10c5dc:	f421 71e1 	bic.w	r1, r1, #450	; 0x1c2
  10c5e0:	ea6f 070c 	mvn.w	r7, r12
  10c5e4:	f441 71c0 	orr.w	r1, r1, #384	; 0x180
  10c5e8:	f007 5780 	and.w	r7, r7, #268435456	; 0x10000000
  10c5ec:	43ce      	mvns	r6, r1
  10c5ee:	ea87 070c 	eor.w	r7, r7, r12
  10c5f2:	f406 6660 	and.w	r6, r6, #3584	; 0xe00
  10c5f6:	6097      	str	r7, [r2, #8]
  10c5f8:	4071      	eors	r1, r6
  10c5fa:	2d00      	cmp	r5, #0
  10c5fc:	d15f      	bne.n	10c6be <disp_link_init+0x642>
  10c5fe:	7826      	ldrb	r6, [r4, #0]
  10c600:	60de      	str	r6, [r3, #12]
  10c602:	611e      	str	r6, [r3, #16]
  10c604:	f421 5580 	bic.w	r5, r1, #4096	; 0x1000
  10c608:	4631      	mov	r1, r6
  10c60a:	ea85 3641 	eor.w	r6, r5, r1, lsl #13
  10c60e:	f406 46c0 	and.w	r6, r6, #24576	; 0x6000
  10c612:	406e      	eors	r6, r5
  10c614:	ea86 35c1 	eor.w	r5, r6, r1, lsl #15
  10c618:	f405 35c0 	and.w	r5, r5, #98304	; 0x18000
  10c61c:	406e      	eors	r6, r5
  10c61e:	ea86 4541 	eor.w	r5, r6, r1, lsl #17
  10c622:	f405 25c0 	and.w	r5, r5, #393216	; 0x60000
  10c626:	4075      	eors	r5, r6
  10c628:	ea85 41c1 	eor.w	r1, r5, r1, lsl #19
  10c62c:	f401 11c0 	and.w	r1, r1, #1572864	; 0x180000
  10c630:	4069      	eors	r1, r5
  10c632:	9d00      	ldr	r5, [sp, #0]
  10c634:	6029      	str	r1, [r5, #0]
  10c636:	e720      	b.n	10c47a <disp_link_init+0x3fe>
  10c638:	f24c 0198 	movw	r1, #49304	; 0xc098
  10c63c:	f2c0 0111 	movt	r1, #17
  10c640:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
  10c644:	2900      	cmp	r1, #0
  10c646:	bfa1      	itttt	ge
  10c648:	f8cc 1000 	strge.w	r1, [r12]
  10c64c:	6bd9      	ldrge	r1, [r3, #60]	; 0x3c
  10c64e:	f421 61c0 	bicge.w	r1, r1, #1536	; 0x600
  10c652:	f441 7100 	orrge.w	r1, r1, #512	; 0x200
  10c656:	bfa8      	it	ge
  10c658:	63d9      	strge	r1, [r3, #60]	; 0x3c
  10c65a:	f1b8 0f04 	cmp.w	r8, #4
  10c65e:	f63f adde 	bhi.w	10c21e <disp_link_init+0x1a2>
  10c662:	e798      	b.n	10c596 <disp_link_init+0x51a>
  10c664:	f24c 0198 	movw	r1, #49304	; 0xc098
  10c668:	f2c0 0111 	movt	r1, #17
  10c66c:	f851 1026 	ldr.w	r1, [r1, r6, lsl #2]
  10c670:	2900      	cmp	r1, #0
  10c672:	bfa1      	itttt	ge
  10c674:	6019      	strge	r1, [r3, #0]
  10c676:	6b59      	ldrge	r1, [r3, #52]	; 0x34
  10c678:	f421 61c0 	bicge.w	r1, r1, #1536	; 0x600
  10c67c:	f441 7100 	orrge.w	r1, r1, #512	; 0x200
  10c680:	bfa8      	it	ge
  10c682:	6359      	strge	r1, [r3, #52]	; 0x34
  10c684:	2f04      	cmp	r7, #4
  10c686:	f63f adc6 	bhi.w	10c216 <disp_link_init+0x19a>
  10c68a:	e7d5      	b.n	10c638 <disp_link_init+0x5bc>
  10c68c:	2200      	movs	r2, #0
  10c68e:	f2cf 02d5 	movt	r2, #61653	; 0xf0d5
  10c692:	4613      	mov	r3, r2
  10c694:	f8cb 2000 	str.w	r2, [r11]
  10c698:	e736      	b.n	10c508 <disp_link_init+0x48c>
  10c69a:	f7ff fcc7 	bl	10c02c <disp_link_get_cfg_info>
  10c69e:	e4fe      	b.n	10c09e <disp_link_init+0x22>
  10c6a0:	2200      	movs	r2, #0
  10c6a2:	2e04      	cmp	r6, #4
  10c6a4:	f2cf 02c4 	movt	r2, #61636	; 0xf0c4
  10c6a8:	9201      	str	r2, [sp, #4]
  10c6aa:	f04f 0204 	mov.w	r2, #4
  10c6ae:	f2cf 02c4 	movt	r2, #61636	; 0xf0c4
  10c6b2:	9200      	str	r2, [sp, #0]
  10c6b4:	9a01      	ldr	r2, [sp, #4]
  10c6b6:	600a      	str	r2, [r1, #0]
  10c6b8:	f63f adaa 	bhi.w	10c210 <disp_link_init+0x194>
  10c6bc:	e7d2      	b.n	10c664 <disp_link_init+0x5e8>
  10c6be:	43cd      	mvns	r5, r1
  10c6c0:	78a6      	ldrb	r6, [r4, #2]
  10c6c2:	615e      	str	r6, [r3, #20]
  10c6c4:	f405 5580 	and.w	r5, r5, #4096	; 0x1000
  10c6c8:	619e      	str	r6, [r3, #24]
  10c6ca:	404d      	eors	r5, r1
  10c6cc:	4631      	mov	r1, r6
  10c6ce:	e79c      	b.n	10c60a <disp_link_init+0x58e>
  10c6d0:	464d      	mov	r5, r9
  10c6d2:	e6a5      	b.n	10c420 <disp_link_init+0x3a4>
  10c6d4:	9d01      	ldr	r5, [sp, #4]
  10c6d6:	e6a3      	b.n	10c420 <disp_link_init+0x3a4>
  10c6d8:	9d02      	ldr	r5, [sp, #8]
  10c6da:	e6a1      	b.n	10c420 <disp_link_init+0x3a4>
  10c6dc:	9d03      	ldr	r5, [sp, #12]
  10c6de:	e69f      	b.n	10c420 <disp_link_init+0x3a4>
  10c6e0:	464d      	mov	r5, r9
  10c6e2:	e6ad      	b.n	10c440 <disp_link_init+0x3c4>
  10c6e4:	9d01      	ldr	r5, [sp, #4]
  10c6e6:	e6ab      	b.n	10c440 <disp_link_init+0x3c4>
  10c6e8:	9d02      	ldr	r5, [sp, #8]
  10c6ea:	e6a9      	b.n	10c440 <disp_link_init+0x3c4>
  10c6ec:	9d03      	ldr	r5, [sp, #12]
  10c6ee:	e6a7      	b.n	10c440 <disp_link_init+0x3c4>
  10c6f0:	464d      	mov	r5, r9
  10c6f2:	e6b1      	b.n	10c458 <disp_link_init+0x3dc>
  10c6f4:	9d01      	ldr	r5, [sp, #4]
  10c6f6:	e6af      	b.n	10c458 <disp_link_init+0x3dc>
  10c6f8:	9d02      	ldr	r5, [sp, #8]
  10c6fa:	e6ad      	b.n	10c458 <disp_link_init+0x3dc>
  10c6fc:	9d03      	ldr	r5, [sp, #12]
  10c6fe:	e6ab      	b.n	10c458 <disp_link_init+0x3dc>
  10c700:	f8dd 8004 	ldr.w	r8, [r13, #4]
  10c704:	e6b5      	b.n	10c472 <disp_link_init+0x3f6>
  10c706:	f8dd 8008 	ldr.w	r8, [r13, #8]
  10c70a:	e6b2      	b.n	10c472 <disp_link_init+0x3f6>
  10c70c:	46c8      	mov	r8, r9
  10c70e:	e6b0      	b.n	10c472 <disp_link_init+0x3f6>
  10c710:	2b00      	cmp	r3, #0
  10c712:	f47f af3a 	bne.w	10c58a <disp_link_init+0x50e>
  10c716:	2300      	movs	r3, #0
  10c718:	f2cf 03d5 	movt	r3, #61653	; 0xf0d5
  10c71c:	f8cb 3000 	str.w	r3, [r11]
  10c720:	e733      	b.n	10c58a <disp_link_init+0x50e>
  10c722:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10c726:	e733      	b.n	10c590 <disp_link_init+0x514>
  10c728:	7037      	strb	r7, [r6, #0]
  10c72a:	46be      	mov	r14, r7
  10c72c:	e52f      	b.n	10c18e <disp_link_init+0x112>
  10c72e:	bf00      	nop

0010c730 <register_gpio_int_handler>:
#include "gpioirq.h"

int register_gpio_int_handler(uint16_t ChannelId, int irqflag,
                              int_handler handler, void *arg)
{
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c730:	f24c 01ac 	movw	r1, #49324	; 0xc0ac
  10c734:	f24c 00f4 	movw	r0, #49396	; 0xc0f4
{
  10c738:	b508      	push	{r3, r14}
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c73a:	f2c0 0111 	movt	r1, #17
  10c73e:	f2c0 0011 	movt	r0, #17
  10c742:	f008 f85f 	bl	114804 <printf>
    return -1;
}
  10c746:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10c74a:	bd08      	pop	{r3, r15}

0010c74c <unmask_gpio_interrupt>:

int unmask_gpio_interrupt(uint16_t ChannelId)
{
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c74c:	f24c 01c8 	movw	r1, #49352	; 0xc0c8
  10c750:	f24c 00f4 	movw	r0, #49396	; 0xc0f4
{
  10c754:	b508      	push	{r3, r14}
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c756:	f2c0 0111 	movt	r1, #17
  10c75a:	f2c0 0011 	movt	r0, #17
  10c75e:	f008 f851 	bl	114804 <printf>
    return -1;
}
  10c762:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10c766:	bd08      	pop	{r3, r15}

0010c768 <mask_gpio_interrupt>:

int mask_gpio_interrupt(uint16_t ChannelId)
{
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c768:	f24c 01e0 	movw	r1, #49376	; 0xc0e0
  10c76c:	f24c 00f4 	movw	r0, #49396	; 0xc0f4
{
  10c770:	b508      	push	{r3, r14}
    dprintf(ALWAYS, "%s, not implement\n", __func__);
  10c772:	f2c0 0111 	movt	r1, #17
  10c776:	f2c0 0011 	movt	r0, #17
  10c77a:	f008 f843 	bl	114804 <printf>
    return -1;
}
  10c77e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10c782:	bd08      	pop	{r3, r15}

0010c784 <hal_i2c_creat_handle>:
//
//*****************************************************************************
bool hal_i2c_creat_handle(void **handle, uint32_t i2c_res_glb_idx)
{
    i2c_instance_t  *instance = NULL;
    HAL_ASSERT_PARAMETER(handle);
  10c784:	2800      	cmp	r0, #0
  10c786:	f000 80e9 	beq.w	10c95c <hal_i2c_creat_handle+0x1d8>
{
  10c78a:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    int32_t cur_i2c_soc_bus_index = 0;
  10c78e:	2500      	movs	r5, #0
{
  10c790:	b08f      	sub	sp, #60	; 0x3c
  10c792:	460c      	mov	r4, r1
    int32_t cur_i2c_soc_bus_index = 0;
  10c794:	aa0e      	add	r2, sp, #56	; 0x38
  10c796:	9000      	str	r0, [sp, #0]
    if (res_get_info_by_id(i2c_res_glb_idx, &cur_i2c_phy_addr,
  10c798:	a905      	add	r1, sp, #20
    int32_t cur_i2c_soc_bus_index = 0;
  10c79a:	f842 5d28 	str.w	r5, [r2, #-40]!
    if (res_get_info_by_id(i2c_res_glb_idx, &cur_i2c_phy_addr,
  10c79e:	4620      	mov	r0, r4
  10c7a0:	f003 fdc8 	bl	110334 <res_get_info_by_id>
  10c7a4:	4682      	mov	r10, r0
  10c7a6:	2800      	cmp	r0, #0
  10c7a8:	f040 8117 	bne.w	10c9da <hal_i2c_creat_handle+0x256>
    if (cur_i2c_soc_bus_index < 1) {
  10c7ac:	9d04      	ldr	r5, [sp, #16]
  10c7ae:	2d00      	cmp	r5, #0
  10c7b0:	f340 8120 	ble.w	10c9f4 <hal_i2c_creat_handle+0x270>
  10c7b4:	f24c 1148 	movw	r1, #49480	; 0xc148
    cur_i2c_soc_bus_index = cur_i2c_soc_bus_index - 1;
  10c7b8:	3d01      	subs	r5, #1
  10c7ba:	f241 030b 	movw	r3, #4107	; 0x100b
  10c7be:	f2c0 0111 	movt	r1, #17
  10c7c2:	460a      	mov	r2, r1
  10c7c4:	f2c4 0344 	movt	r3, #16452	; 0x4044
  10c7c8:	9504      	str	r5, [sp, #16]
  10c7ca:	e005      	b.n	10c7d8 <hal_i2c_creat_handle+0x54>
    for (i = 0; i < DEFAULT_I2C_MAX_NUM; i++) {
  10c7cc:	3001      	adds	r0, #1
  10c7ce:	2810      	cmp	r0, #16
  10c7d0:	f000 80f7 	beq.w	10c9c2 <hal_i2c_creat_handle+0x23e>
  10c7d4:	f852 3f0c 	ldr.w	r3, [r2, #12]!
        if (g_i2c_glb_idx_to_num[i].res_glb_idx == i2c_res_glb_idx)
  10c7d8:	429c      	cmp	r4, r3
  10c7da:	d1f7      	bne.n	10c7cc <hal_i2c_creat_handle+0x48>
            return g_i2c_glb_idx_to_num[i].irq;
  10c7dc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  10c7e0:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  10c7e4:	6883      	ldr	r3, [r0, #8]
  10c7e6:	9303      	str	r3, [sp, #12]
    if (irq == 0) {
  10c7e8:	2b00      	cmp	r3, #0
  10c7ea:	f000 80ea 	beq.w	10c9c2 <hal_i2c_creat_handle+0x23e>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10c7ee:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10c7f2:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
  10c7f4:	bf48      	it	mi
  10c7f6:	f04f 0a00 	movmi.w	r10, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10c7fa:	d402      	bmi.n	10c802 <hal_i2c_creat_handle+0x7e>
    __asm__ volatile("cpsid i");
  10c7fc:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10c7fe:	f04f 0a01 	mov.w	r10, #1
    *lock = 1;
  10c802:	f240 186c 	movw	r8, #364	; 0x16c
  10c806:	2301      	movs	r3, #1
    if (g_i2c_init)
  10c808:	f240 1768 	movw	r7, #360	; 0x168
  10c80c:	f2c0 0813 	movt	r8, #19
  10c810:	f2c0 0713 	movt	r7, #19
  10c814:	783c      	ldrb	r4, [r7, #0]
  10c816:	f8c8 3000 	str.w	r3, [r8]
  10c81a:	b98c      	cbnz	r4, 10c840 <hal_i2c_creat_handle+0xbc>
  10c81c:	f8df 91ec 	ldr.w	r9, [r15, #492]	; 10ca0c <hal_i2c_creat_handle+0x288>
        g_i2c[i].bus = 0xff;
  10c820:	26ff      	movs	r6, #255	; 0xff
  10c822:	f509 7568 	add.w	r5, r9, #928	; 0x3a0
  10c826:	f849 6c04 	str.w	r6, [r9, #-4]
        mutex_init(&g_i2c[i].bus_mutex);
  10c82a:	4648      	mov	r0, r9
        g_i2c[i].bus_lock = SPIN_LOCK_INITIAL_VALUE;
  10c82c:	f8c9 4004 	str.w	r4, [r9, #4]
  10c830:	f109 0974 	add.w	r9, r9, #116	; 0x74
        mutex_init(&g_i2c[i].bus_mutex);
  10c834:	f009 fe7a 	bl	11652c <mutex_init>
    for (i = 0; i < I2C_RES_NUM; i++) {
  10c838:	454d      	cmp	r5, r9
  10c83a:	d1f4      	bne.n	10c826 <hal_i2c_creat_handle+0xa2>
    g_i2c_init = true;
  10c83c:	2301      	movs	r3, #1
  10c83e:	703b      	strb	r3, [r7, #0]
  10c840:	f64f 46e8 	movw	r6, #64744	; 0xfce8
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10c844:	2400      	movs	r4, #0
  10c846:	f2c0 0612 	movt	r6, #18
  10c84a:	4633      	mov	r3, r6
  10c84c:	e003      	b.n	10c856 <hal_i2c_creat_handle+0xd2>
  10c84e:	3401      	adds	r4, #1
    for (i = 0; i < MAX_I2C_DEVICE_NUM; i++) {
  10c850:	2c20      	cmp	r4, #32
  10c852:	f000 80ae 	beq.w	10c9b2 <hal_i2c_creat_handle+0x22e>
        if (g_i2cInstance[i].occupied != 1) {
  10c856:	7a1a      	ldrb	r2, [r3, #8]
  10c858:	2a01      	cmp	r2, #1
  10c85a:	f103 0324 	add.w	r3, r3, #36	; 0x24
  10c85e:	d0f6      	beq.n	10c84e <hal_i2c_creat_handle+0xca>
            memset(buffer, 0, sizeof(i2c_instance_t));
  10c860:	2224      	movs	r2, #36	; 0x24
            uint8_t *buffer = (uint8_t *)&g_i2cInstance[i];
  10c862:	00e7      	lsls	r7, r4, #3
            memset(buffer, 0, sizeof(i2c_instance_t));
  10c864:	2100      	movs	r1, #0
            uint8_t *buffer = (uint8_t *)&g_i2cInstance[i];
  10c866:	eb07 0904 	add.w	r9, r7, r4
  10c86a:	f64f 1b48 	movw	r11, #63816	; 0xf948
    for (i = 0; i < I2C_RES_NUM; i++) {
  10c86e:	2500      	movs	r5, #0
            uint8_t *buffer = (uint8_t *)&g_i2cInstance[i];
  10c870:	eb06 0989 	add.w	r9, r6, r9, lsl #2
            memset(buffer, 0, sizeof(i2c_instance_t));
  10c874:	4648      	mov	r0, r9
  10c876:	f2c0 0b12 	movt	r11, #18
  10c87a:	f007 e898 	blx	1139ac <memset>
            j = g_i2c_get_index(cur_i2c_soc_bus_index);
  10c87e:	9a04      	ldr	r2, [sp, #16]
            g_i2cInstance[i].occupied = 1;
  10c880:	2001      	movs	r0, #1
  10c882:	4659      	mov	r1, r11
  10c884:	f889 0008 	strb.w	r0, [r9, #8]
        if (g_i2c[i].bus == (uint32_t)i2cno)
  10c888:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  10c88a:	3174      	adds	r1, #116	; 0x74
        if (g_i2c[i].bus == 0xff)
  10c88c:	4293      	cmp	r3, r2
  10c88e:	bf18      	it	ne
  10c890:	2bff      	cmpne	r3, #255	; 0xff
  10c892:	f000 8088 	beq.w	10c9a6 <hal_i2c_creat_handle+0x222>
    for (i = 0; i < I2C_RES_NUM; i++) {
  10c896:	3501      	adds	r5, #1
  10c898:	2d08      	cmp	r5, #8
  10c89a:	d1f5      	bne.n	10c888 <hal_i2c_creat_handle+0x104>
    dprintf(0, "%s: index %d not found!\n", __func__, i2cno);
  10c89c:	f24c 1108 	movw	r1, #49416	; 0xc108
  10c8a0:	f24c 2054 	movw	r0, #49748	; 0xc254
  10c8a4:	f2c0 0111 	movt	r1, #17
  10c8a8:	25ff      	movs	r5, #255	; 0xff
  10c8aa:	f2c0 0011 	movt	r0, #17
  10c8ae:	f007 ffa9 	bl	114804 <printf>
  10c8b2:	f247 308c 	movw	r0, #29580	; 0x738c
  10c8b6:	f44f 62ff 	mov.w	r2, #2040	; 0x7f8
    *lock = 0;
  10c8ba:	2100      	movs	r1, #0
  10c8bc:	f8c8 1000 	str.w	r1, [r8]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10c8c0:	f1ba 0f00 	cmp.w	r10, #0
  10c8c4:	d000      	beq.n	10c8c8 <hal_i2c_creat_handle+0x144>
    __asm__ volatile("cpsie i");
  10c8c6:	b662      	cpsie	i
    *controllerTable = &s_i2cDrvInterface;
  10c8c8:	f24c 23c0 	movw	r3, #49856	; 0xc2c0
  10c8cc:	1939      	adds	r1, r7, r4
  10c8ce:	f2c0 0311 	movt	r3, #17
  10c8d2:	eb06 0181 	add.w	r1, r6, r1, lsl #2
  10c8d6:	604b      	str	r3, [r1, #4]
                g_i2cInstance[i].cur_i2c_soc_busnum = cur_i2c_soc_bus_index;
  10c8d8:	9b04      	ldr	r3, [sp, #16]
  10c8da:	f881 3021 	strb.w	r3, [r1, #33]	; 0x21
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10c8de:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10c8e2:	060b      	lsls	r3, r1, #24
    spin_lock_saved_state_t state = 0;
  10c8e4:	bf44      	itt	mi
  10c8e6:	2300      	movmi	r3, #0
  10c8e8:	9302      	strmi	r3, [sp, #8]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10c8ea:	d402      	bmi.n	10c8f2 <hal_i2c_creat_handle+0x16e>
    __asm__ volatile("cpsid i");
  10c8ec:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10c8ee:	2301      	movs	r3, #1
  10c8f0:	9302      	str	r3, [sp, #8]
    *lock = 1;
  10c8f2:	2301      	movs	r3, #1
  10c8f4:	1b51      	subs	r1, r2, r5
  10c8f6:	4458      	add	r0, r11
  10c8f8:	eb05 0181 	add.w	r1, r5, r1, lsl #2
  10c8fc:	9001      	str	r0, [sp, #4]
  10c8fe:	eb0b 0181 	add.w	r1, r11, r1, lsl #2
                if (!g_i2c[j].is_added) {
  10c902:	f891 c021 	ldrb.w	r12, [r1, #33]	; 0x21
  10c906:	630b      	str	r3, [r1, #48]	; 0x30
  10c908:	f1bc 0f00 	cmp.w	r12, #0
  10c90c:	d027      	beq.n	10c95e <hal_i2c_creat_handle+0x1da>
                    g_i2cInstance[i].i2c_con = &g_i2c[j];
  10c90e:	9b01      	ldr	r3, [sp, #4]
  10c910:	1939      	adds	r1, r7, r4
  10c912:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10c916:	9b02      	ldr	r3, [sp, #8]
    *lock = 0;
  10c918:	1b52      	subs	r2, r2, r5
  10c91a:	2100      	movs	r1, #0
  10c91c:	eb05 0582 	add.w	r5, r5, r2, lsl #2
  10c920:	eb0b 0585 	add.w	r5, r11, r5, lsl #2
  10c924:	6329      	str	r1, [r5, #48]	; 0x30
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10c926:	b103      	cbz	r3, 10c92a <hal_i2c_creat_handle+0x1a6>
    __asm__ volatile("cpsie i");
  10c928:	b662      	cpsie	i
                g_i2cInstance[i].i2c_cfg.speed = g_i2cInstance[i].i2c_con->info.speed;
  10c92a:	443c      	add	r4, r7
  10c92c:	00a4      	lsls	r4, r4, #2
  10c92e:	1933      	adds	r3, r6, r4
  10c930:	5930      	ldr	r0, [r6, r4]
                if (g_i2cInstance[i].controllerTable->init_after)
  10c932:	685a      	ldr	r2, [r3, #4]
                g_i2cInstance[i].i2c_cfg.speed = g_i2cInstance[i].i2c_con->info.speed;
  10c934:	6841      	ldr	r1, [r0, #4]
                if (g_i2cInstance[i].controllerTable->init_after)
  10c936:	6852      	ldr	r2, [r2, #4]
                g_i2cInstance[i].i2c_cfg.speed = g_i2cInstance[i].i2c_con->info.speed;
  10c938:	60d9      	str	r1, [r3, #12]
                g_i2cInstance[i].i2c_cfg.addr_bits = g_i2cInstance[i].i2c_con->info.addr_bits;
  10c93a:	6881      	ldr	r1, [r0, #8]
  10c93c:	6119      	str	r1, [r3, #16]
                g_i2cInstance[i].i2c_cfg.mode = g_i2cInstance[i].i2c_con->info.mode;
  10c93e:	68c1      	ldr	r1, [r0, #12]
  10c940:	6159      	str	r1, [r3, #20]
                g_i2cInstance[i].i2c_cfg.slave_addr = g_i2cInstance[i].i2c_con->info.slave_addr;
  10c942:	6941      	ldr	r1, [r0, #20]
  10c944:	6199      	str	r1, [r3, #24]
                g_i2cInstance[i].i2c_cfg.poll = g_i2cInstance[i].i2c_con->info.poll;
  10c946:	69c1      	ldr	r1, [r0, #28]
  10c948:	61d9      	str	r1, [r3, #28]
                if (g_i2cInstance[i].controllerTable->init_after)
  10c94a:	b102      	cbz	r2, 10c94e <hal_i2c_creat_handle+0x1ca>
                    g_i2cInstance[i].controllerTable->init_after(g_i2cInstance[i].i2c_con);
  10c94c:	4790      	blx	r2
    if (instance == NULL) {
        //mutex_destroy(&i2c_mutex);
        return false;
    }

    *handle = instance;
  10c94e:	9b00      	ldr	r3, [sp, #0]
    return true;
  10c950:	2001      	movs	r0, #1
    *handle = instance;
  10c952:	f8c3 9000 	str.w	r9, [r3]
}
  10c956:	b00f      	add	sp, #60	; 0x3c
  10c958:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10c95c:	4770      	bx	r14
                    l_config.mode = MASTER_MODE;
  10c95e:	9309      	str	r3, [sp, #36]	; 0x24
                    g_i2cInstance[i].i2c_con = &g_i2c[j];
  10c960:	eb07 0a04 	add.w	r10, r7, r4
                    l_config.restart = true;
  10c964:	f88d 3028 	strb.w	r3, [r13, #40]	; 0x28
                    l_config.speed = I2C_SPEED_FAST;
  10c968:	f04f 0e02 	mov.w	r14, #2
                    l_config.irq = irq;
  10c96c:	9803      	ldr	r0, [sp, #12]
                    g_i2cInstance[i].i2c_con = &g_i2c[j];
  10c96e:	ea4f 0a8a 	mov.w	r10, r10, lsl #2
                    l_config.poll = 0;
  10c972:	e9cd 0c0c 	strd	r0, r12, [r13, #48]	; 0x30
                    g_i2cInstance[i].i2c_con = &g_i2c[j];
  10c976:	eb06 080a 	add.w	r8, r6, r10
  10c97a:	9801      	ldr	r0, [sp, #4]
                    l_config.addr_bits = ADDR_7BITS;
  10c97c:	f8cd c020 	str.w	r12, [r13, #32]
                    if (g_i2cInstance[i].controllerTable->set_busconfig) {
  10c980:	f8d8 3004 	ldr.w	r3, [r8, #4]
  10c984:	681b      	ldr	r3, [r3, #0]
                    g_i2cInstance[i].i2c_con = &g_i2c[j];
  10c986:	f846 000a 	str.w	r0, [r6, r10]
                    l_config.io_base = cur_i2c_phy_addr;
  10c98a:	9805      	ldr	r0, [sp, #20]
  10c98c:	9006      	str	r0, [sp, #24]
                    g_i2c[j].bus = cur_i2c_soc_bus_index;
  10c98e:	9804      	ldr	r0, [sp, #16]
                    l_config.speed = I2C_SPEED_FAST;
  10c990:	f8cd e01c 	str.w	r14, [r13, #28]
                    g_i2c[j].bus = cur_i2c_soc_bus_index;
  10c994:	6288      	str	r0, [r1, #40]	; 0x28
                    if (g_i2cInstance[i].controllerTable->set_busconfig) {
  10c996:	2b00      	cmp	r3, #0
  10c998:	d0bd      	beq.n	10c916 <hal_i2c_creat_handle+0x192>
                        g_i2cInstance[i].controllerTable->set_busconfig(
  10c99a:	9801      	ldr	r0, [sp, #4]
  10c99c:	a906      	add	r1, sp, #24
  10c99e:	9203      	str	r2, [sp, #12]
  10c9a0:	4798      	blx	r3
  10c9a2:	9a03      	ldr	r2, [sp, #12]
  10c9a4:	e7b7      	b.n	10c916 <hal_i2c_creat_handle+0x192>
  10c9a6:	00ea      	lsls	r2, r5, #3
  10c9a8:	1b50      	subs	r0, r2, r5
  10c9aa:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  10c9ae:	0080      	lsls	r0, r0, #2
  10c9b0:	e783      	b.n	10c8ba <hal_i2c_creat_handle+0x136>
    *lock = 0;
  10c9b2:	2000      	movs	r0, #0
  10c9b4:	f8c8 0000 	str.w	r0, [r8]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10c9b8:	f1ba 0f00 	cmp.w	r10, #0
  10c9bc:	d00b      	beq.n	10c9d6 <hal_i2c_creat_handle+0x252>
  10c9be:	b662      	cpsie	i
  10c9c0:	e7c9      	b.n	10c956 <hal_i2c_creat_handle+0x1d2>
        dprintf(0, "%s: wrong bus irq\n", __func__);
  10c9c2:	f24c 1118 	movw	r1, #49432	; 0xc118
  10c9c6:	f24c 2040 	movw	r0, #49728	; 0xc240
  10c9ca:	f2c0 0111 	movt	r1, #17
  10c9ce:	f2c0 0011 	movt	r0, #17
  10c9d2:	f007 ff17 	bl	114804 <printf>
        return false;
  10c9d6:	2000      	movs	r0, #0
  10c9d8:	e7bd      	b.n	10c956 <hal_i2c_creat_handle+0x1d2>
        dprintf(0, "%s: error i2c_res_glb_idx:0x%x\n", __func__, i2c_res_glb_idx);
  10c9da:	f24c 1118 	movw	r1, #49432	; 0xc118
  10c9de:	f24c 2008 	movw	r0, #49672	; 0xc208
  10c9e2:	4622      	mov	r2, r4
  10c9e4:	f2c0 0111 	movt	r1, #17
  10c9e8:	f2c0 0011 	movt	r0, #17
  10c9ec:	f007 ff0a 	bl	114804 <printf>
        return false;
  10c9f0:	4628      	mov	r0, r5
  10c9f2:	e7b0      	b.n	10c956 <hal_i2c_creat_handle+0x1d2>
        dprintf(0, "%s: wrong bus index\n", __func__);
  10c9f4:	f24c 1118 	movw	r1, #49432	; 0xc118
  10c9f8:	f24c 2028 	movw	r0, #49704	; 0xc228
  10c9fc:	f2c0 0111 	movt	r1, #17
  10ca00:	f2c0 0011 	movt	r0, #17
  10ca04:	f007 fefe 	bl	114804 <printf>
        return false;
  10ca08:	4650      	mov	r0, r10
  10ca0a:	e7a4      	b.n	10c956 <hal_i2c_creat_handle+0x1d2>
  10ca0c:	0012f974 	.word	0x0012f974

0010ca10 <hal_i2c_release_handle>:
//
//*****************************************************************************
bool hal_i2c_release_handle(void *handle)
{
    i2c_instance_t *instance = NULL;
    HAL_ASSERT_PARAMETER(handle);
  10ca10:	4603      	mov	r3, r0
  10ca12:	b118      	cbz	r0, 10ca1c <hal_i2c_release_handle+0xc>
    instance = (i2c_instance_t *)handle;
    instance->occupied = 0;
  10ca14:	2200      	movs	r2, #0
    //mutex_destroy(&i2c_mutex);
    return true;
  10ca16:	2001      	movs	r0, #1
    instance->occupied = 0;
  10ca18:	721a      	strb	r2, [r3, #8]
    return true;
  10ca1a:	4770      	bx	r14
}
  10ca1c:	4770      	bx	r14
  10ca1e:	bf00      	nop

0010ca20 <hal_i2c_get_busconfig>:

i2c_app_config_t hal_i2c_get_busconfig(void *handle)
{
  10ca20:	b4f0      	push	{r4, r5, r6, r7}
    i2c_app_config_t i2c_app_cfg;
    i2c_instance_t *instance = NULL;
    memset(&i2c_app_cfg, 0, sizeof(i2c_app_cfg));
  10ca22:	2300      	movs	r3, #0
{
  10ca24:	b086      	sub	sp, #24
  10ca26:	4684      	mov	r12, r0
    memset(&i2c_app_cfg, 0, sizeof(i2c_app_cfg));
  10ca28:	e9cd 3301 	strd	r3, r3, [r13, #4]
  10ca2c:	e9cd 3303 	strd	r3, r3, [r13, #12]
  10ca30:	9305      	str	r3, [sp, #20]

    if (handle == NULL)
  10ca32:	b171      	cbz	r1, 10ca52 <hal_i2c_get_busconfig+0x32>
        return i2c_app_cfg;

    instance = (i2c_instance_t *)handle;
    i2c_app_cfg = instance->i2c_cfg;
  10ca34:	f101 050c 	add.w	r5, r1, #12
    return i2c_app_cfg;
  10ca38:	4606      	mov	r6, r0
  10ca3a:	af01      	add	r7, sp, #4
    i2c_app_cfg = instance->i2c_cfg;
  10ca3c:	463c      	mov	r4, r7
  10ca3e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  10ca40:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    return i2c_app_cfg;
  10ca42:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
    i2c_app_cfg = instance->i2c_cfg;
  10ca44:	682c      	ldr	r4, [r5, #0]
    return i2c_app_cfg;
  10ca46:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  10ca48:	6034      	str	r4, [r6, #0]
}
  10ca4a:	4660      	mov	r0, r12
  10ca4c:	b006      	add	sp, #24
  10ca4e:	bcf0      	pop	{r4, r5, r6, r7}
  10ca50:	4770      	bx	r14
        return i2c_app_cfg;
  10ca52:	e9c0 1100 	strd	r1, r1, [r0]
  10ca56:	e9c0 1102 	strd	r1, r1, [r0, #8]
  10ca5a:	6101      	str	r1, [r0, #16]
}
  10ca5c:	4660      	mov	r0, r12
  10ca5e:	b006      	add	sp, #24
  10ca60:	bcf0      	pop	{r4, r5, r6, r7}
  10ca62:	4770      	bx	r14

0010ca64 <hal_i2c_set_busconfig>:
//*****************************************************************************
bool hal_i2c_set_busconfig(void *handle, i2c_app_config_t *i2c_app_cfg)
{
    bool ret = false;
    i2c_instance_t *instance = NULL;
    HAL_ASSERT_PARAMETER(handle);
  10ca64:	2800      	cmp	r0, #0
  10ca66:	d04b      	beq.n	10cb00 <hal_i2c_set_busconfig+0x9c>
    dw_i2c_config_t l_config;
    instance = (i2c_instance_t *)handle;

    if (i2c_app_cfg->addr_bits == HAL_I2C_ADDR_10BITS) {
  10ca68:	684b      	ldr	r3, [r1, #4]
{
  10ca6a:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10ca6e:	460c      	mov	r4, r1
    if (i2c_app_cfg->addr_bits == HAL_I2C_ADDR_10BITS) {
  10ca70:	2b01      	cmp	r3, #1
{
  10ca72:	b088      	sub	sp, #32
    if (i2c_app_cfg->addr_bits == HAL_I2C_ADDR_10BITS) {
  10ca74:	d028      	beq.n	10cac8 <hal_i2c_set_busconfig+0x64>
        dprintf(0, "%s(): 10bit address mode not implement!\n", __func__);
        return false;
    }

    if (i2c_app_cfg->mode == HAL_I2C_SLAVE_MODE) {
  10ca76:	688d      	ldr	r5, [r1, #8]
  10ca78:	2d00      	cmp	r5, #0
  10ca7a:	d033      	beq.n	10cae4 <hal_i2c_set_busconfig+0x80>
        dprintf(0, "%s(): slave mode not implement!\n", __func__);
        return false;
    }

    instance->i2c_cfg = *i2c_app_cfg;
  10ca7c:	460e      	mov	r6, r1
  10ca7e:	f100 050c 	add.w	r5, r0, #12
    l_config.io_base = instance->i2c_con->info.io_base;
  10ca82:	e9d0 7c00 	ldrd	r7, r12, [r0]
    instance->i2c_cfg = *i2c_app_cfg;
  10ca86:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
    l_config.speed = i2c_app_cfg->speed;
    l_config.addr_bits = i2c_app_cfg->addr_bits;
    l_config.slave_addr = i2c_app_cfg->slave_addr;
    l_config.poll = i2c_app_cfg->poll;

    if (instance->controllerTable->set_busconfig) {
  10ca88:	f8dc 8000 	ldr.w	r8, [r12]
    l_config.restart = true;
  10ca8c:	f04f 0c01 	mov.w	r12, #1
    instance->i2c_cfg = *i2c_app_cfg;
  10ca90:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  10ca92:	6833      	ldr	r3, [r6, #0]
  10ca94:	602b      	str	r3, [r5, #0]
    l_config.io_base = instance->i2c_con->info.io_base;
  10ca96:	683b      	ldr	r3, [r7, #0]
    l_config.poll = i2c_app_cfg->poll;
  10ca98:	6925      	ldr	r5, [r4, #16]
    l_config.mode = i2c_app_cfg->mode;
  10ca9a:	68a1      	ldr	r1, [r4, #8]
    l_config.speed = i2c_app_cfg->speed;
  10ca9c:	6822      	ldr	r2, [r4, #0]
    l_config.irq = instance->i2c_con->info.irq;
  10ca9e:	69b8      	ldr	r0, [r7, #24]
    l_config.io_base = instance->i2c_con->info.io_base;
  10caa0:	9300      	str	r3, [sp, #0]
    l_config.addr_bits = i2c_app_cfg->addr_bits;
  10caa2:	6863      	ldr	r3, [r4, #4]
    l_config.slave_addr = i2c_app_cfg->slave_addr;
  10caa4:	68e4      	ldr	r4, [r4, #12]
    l_config.irq = instance->i2c_con->info.irq;
  10caa6:	e9cd 0506 	strd	r0, r5, [r13, #24]
    l_config.mode = i2c_app_cfg->mode;
  10caaa:	9103      	str	r1, [sp, #12]
    l_config.addr_bits = i2c_app_cfg->addr_bits;
  10caac:	e9cd 2301 	strd	r2, r3, [r13, #4]
    l_config.slave_addr = i2c_app_cfg->slave_addr;
  10cab0:	9405      	str	r4, [sp, #20]
    l_config.restart = true;
  10cab2:	f88d c010 	strb.w	r12, [r13, #16]
    if (instance->controllerTable->set_busconfig) {
  10cab6:	f1b8 0f00 	cmp.w	r8, #0
  10caba:	d00f      	beq.n	10cadc <hal_i2c_set_busconfig+0x78>
        ret = instance->controllerTable->set_busconfig(
  10cabc:	4638      	mov	r0, r7
  10cabe:	4669      	mov	r1, r13
  10cac0:	47c0      	blx	r8
        LTRACEF("hal_i2c_set_busconfig false\n");
        return false;
    }

    return true;
}
  10cac2:	b008      	add	sp, #32
  10cac4:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(0, "%s(): 10bit address mode not implement!\n", __func__);
  10cac8:	f24c 1130 	movw	r1, #49456	; 0xc130
  10cacc:	f24c 2070 	movw	r0, #49776	; 0xc270
  10cad0:	f2c0 0111 	movt	r1, #17
  10cad4:	f2c0 0011 	movt	r0, #17
  10cad8:	f007 fe94 	bl	114804 <printf>
        return false;
  10cadc:	2000      	movs	r0, #0
}
  10cade:	b008      	add	sp, #32
  10cae0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(0, "%s(): slave mode not implement!\n", __func__);
  10cae4:	f24c 1130 	movw	r1, #49456	; 0xc130
  10cae8:	f24c 209c 	movw	r0, #49820	; 0xc29c
  10caec:	f2c0 0111 	movt	r1, #17
  10caf0:	f2c0 0011 	movt	r0, #17
  10caf4:	f007 fe86 	bl	114804 <printf>
        return false;
  10caf8:	4628      	mov	r0, r5
}
  10cafa:	b008      	add	sp, #32
  10cafc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    HAL_ASSERT_PARAMETER(handle);
  10cb00:	2000      	movs	r0, #0
}
  10cb02:	4770      	bx	r14

0010cb04 <hal_i2c_write_reg_data>:
    return ret;
}

status_t hal_i2c_write_reg_data(void *handle, uint8_t address, void *reg,
                                size_t reg_cnt, void *data, size_t cnt)
{
  10cb04:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10cb08:	b083      	sub	sp, #12
  10cb0a:	e9dd 9a0c 	ldrd	r9, r10, [r13, #48]	; 0x30
    i2c_instance_t *instance = NULL;
    status_t ret = -1;
    int retry = 0;
    HAL_ASSERT_PARAMETER(handle);
  10cb0e:	b1f8      	cbz	r0, 10cb50 <hal_i2c_write_reg_data+0x4c>
    instance = (i2c_instance_t *)handle;

    if (instance->controllerTable->write_reg_data) {
  10cb10:	6844      	ldr	r4, [r0, #4]
  10cb12:	f8d4 b024 	ldr.w	r11, [r4, #36]	; 0x24
  10cb16:	f1bb 0f00 	cmp.w	r11, #0
  10cb1a:	d014      	beq.n	10cb46 <hal_i2c_write_reg_data+0x42>
  10cb1c:	4604      	mov	r4, r0
  10cb1e:	4698      	mov	r8, r3
  10cb20:	4617      	mov	r7, r2
  10cb22:	460e      	mov	r6, r1
  10cb24:	2503      	movs	r5, #3
        while (retry++ < MAX_I2C_RETRY) {
            ret = instance->controllerTable->write_reg_data(
  10cb26:	6820      	ldr	r0, [r4, #0]
  10cb28:	4643      	mov	r3, r8
  10cb2a:	463a      	mov	r2, r7
  10cb2c:	4631      	mov	r1, r6
  10cb2e:	f8cd a004 	str.w	r10, [r13, #4]
  10cb32:	f8cd 9000 	str.w	r9, [r13]
  10cb36:	47d8      	blx	r11
                      instance->i2c_con, address, reg, reg_cnt, data, cnt);

            if (!ret)
  10cb38:	b150      	cbz	r0, 10cb50 <hal_i2c_write_reg_data+0x4c>
        while (retry++ < MAX_I2C_RETRY) {
  10cb3a:	3d01      	subs	r5, #1
  10cb3c:	d005      	beq.n	10cb4a <hal_i2c_write_reg_data+0x46>
  10cb3e:	6863      	ldr	r3, [r4, #4]
  10cb40:	f8d3 b024 	ldr.w	r11, [r3, #36]	; 0x24
  10cb44:	e7ef      	b.n	10cb26 <hal_i2c_write_reg_data+0x22>
    status_t ret = -1;
  10cb46:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }
    }

    dprintf(I2C_LOG, "%s: ret=%d\n", __func__, ret);
    return ret;
}
  10cb4a:	b003      	add	sp, #12
  10cb4c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    HAL_ASSERT_PARAMETER(handle);
  10cb50:	2000      	movs	r0, #0
}
  10cb52:	b003      	add	sp, #12
  10cb54:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

0010cb58 <hal_i2c_read_reg_data>:

status_t hal_i2c_read_reg_data(void *handle, uint8_t address, void *reg,
                               size_t reg_cnt, void *data, size_t cnt)
{
  10cb58:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10cb5c:	b083      	sub	sp, #12
  10cb5e:	e9dd 9a0c 	ldrd	r9, r10, [r13, #48]	; 0x30
    i2c_instance_t *instance = NULL;
    status_t ret = -1;
    int retry = 0;
    HAL_ASSERT_PARAMETER(handle);
  10cb62:	b1f8      	cbz	r0, 10cba4 <hal_i2c_read_reg_data+0x4c>
    instance = (i2c_instance_t *)handle;

    if (instance->controllerTable->read_reg_data) {
  10cb64:	6844      	ldr	r4, [r0, #4]
  10cb66:	f8d4 b028 	ldr.w	r11, [r4, #40]	; 0x28
  10cb6a:	f1bb 0f00 	cmp.w	r11, #0
  10cb6e:	d014      	beq.n	10cb9a <hal_i2c_read_reg_data+0x42>
  10cb70:	4604      	mov	r4, r0
  10cb72:	4698      	mov	r8, r3
  10cb74:	4617      	mov	r7, r2
  10cb76:	460e      	mov	r6, r1
  10cb78:	2503      	movs	r5, #3
        while (retry++ <  MAX_I2C_RETRY) {
            ret = instance->controllerTable->read_reg_data(
  10cb7a:	6820      	ldr	r0, [r4, #0]
  10cb7c:	4643      	mov	r3, r8
  10cb7e:	463a      	mov	r2, r7
  10cb80:	4631      	mov	r1, r6
  10cb82:	f8cd a004 	str.w	r10, [r13, #4]
  10cb86:	f8cd 9000 	str.w	r9, [r13]
  10cb8a:	47d8      	blx	r11
                      instance->i2c_con, address, reg, reg_cnt, data, cnt);

            if (!ret)
  10cb8c:	b150      	cbz	r0, 10cba4 <hal_i2c_read_reg_data+0x4c>
        while (retry++ <  MAX_I2C_RETRY) {
  10cb8e:	3d01      	subs	r5, #1
  10cb90:	d005      	beq.n	10cb9e <hal_i2c_read_reg_data+0x46>
  10cb92:	6863      	ldr	r3, [r4, #4]
  10cb94:	f8d3 b028 	ldr.w	r11, [r3, #40]	; 0x28
  10cb98:	e7ef      	b.n	10cb7a <hal_i2c_read_reg_data+0x22>
    status_t ret = -1;
  10cb9a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }
    }

    dprintf(I2C_LOG, "%s: ret=%d\n", __func__, ret);
    return ret;
}
  10cb9e:	b003      	add	sp, #12
  10cba0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    HAL_ASSERT_PARAMETER(handle);
  10cba4:	2000      	movs	r0, #0
}
  10cba6:	b003      	add	sp, #12
  10cba8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

0010cbac <hal_arm_gic_create_handle>:


bool hal_arm_gic_create_handle(void **phandle, uint32_t res_glb_idx)
{
    return true;
}
  10cbac:	2001      	movs	r0, #1
  10cbae:	4770      	bx	r14

0010cbb0 <hal_arm_gic_release_handle>:

bool hal_arm_gic_release_handle(void *handle)
{
    return true;
}
  10cbb0:	2001      	movs	r0, #1
  10cbb2:	4770      	bx	r14

0010cbb4 <hal_arm_gic_init>:

bool hal_arm_gic_init(void *handle)
{
  10cbb4:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10cbb6:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10cbba:	061b      	lsls	r3, r3, #24
  10cbbc:	d40d      	bmi.n	10cbda <hal_arm_gic_init+0x26>
    __asm__ volatile("cpsid i");
  10cbbe:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    static bool initialized = false;

    spin_lock_irqsave(&init_lock,state);

    if(false == initialized)
  10cbc0:	f240 1470 	movw	r4, #368	; 0x170
  10cbc4:	f2c0 0413 	movt	r4, #19
  10cbc8:	7823      	ldrb	r3, [r4, #0]
  10cbca:	b91b      	cbnz	r3, 10cbd4 <hal_arm_gic_init+0x20>
    {
        arm_gic_init();
  10cbcc:	f7fb f804 	bl	107bd8 <arm_gic_init>
        initialized = true;
  10cbd0:	2301      	movs	r3, #1
  10cbd2:	7023      	strb	r3, [r4, #0]
    __asm__ volatile("cpsie i");
  10cbd4:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&init_lock,state);

    return true;
}
  10cbd6:	2001      	movs	r0, #1
  10cbd8:	bd10      	pop	{r4, r15}
    if(false == initialized)
  10cbda:	f240 1470 	movw	r4, #368	; 0x170
  10cbde:	f2c0 0413 	movt	r4, #19
  10cbe2:	7823      	ldrb	r3, [r4, #0]
  10cbe4:	2b00      	cmp	r3, #0
  10cbe6:	d1f6      	bne.n	10cbd6 <hal_arm_gic_init+0x22>
        arm_gic_init();
  10cbe8:	f7fa fff6 	bl	107bd8 <arm_gic_init>
        initialized = true;
  10cbec:	2301      	movs	r3, #1
  10cbee:	7023      	strb	r3, [r4, #0]
    return true;
  10cbf0:	e7f1      	b.n	10cbd6 <hal_arm_gic_init+0x22>
  10cbf2:	bf00      	nop

0010cbf4 <hal_arm_gic_enable_interrupt>:
    arm_gic_igroup_init();
    return true;
}

bool hal_arm_gic_enable_interrupt(void *handle, uint32_t irq_number)
{
  10cbf4:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_unmask_interrupt(irq_number) == 0 ? true : false );
  10cbf6:	4608      	mov	r0, r1
  10cbf8:	f7fb f8a4 	bl	107d44 <arm_gic_unmask_interrupt>

    return ret;

}
  10cbfc:	fab0 f080 	clz	r0, r0
  10cc00:	0940      	lsrs	r0, r0, #5
  10cc02:	bd08      	pop	{r3, r15}

0010cc04 <hal_arm_gic_disable_interrupt>:

bool hal_arm_gic_disable_interrupt(void *handle, uint32_t irq_number)
{
  10cc04:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_mask_interrupt(irq_number) == 0 ? true : false );
  10cc06:	4608      	mov	r0, r1
  10cc08:	f7fb f87e 	bl	107d08 <arm_gic_mask_interrupt>

    return ret;
}
  10cc0c:	fab0 f080 	clz	r0, r0
  10cc10:	0940      	lsrs	r0, r0, #5
  10cc12:	bd08      	pop	{r3, r15}

0010cc14 <hal_arm_gic_register_interrupt>:
bool hal_arm_gic_register_interrupt(void *handle,
    uint32_t irq_number,
    uint8_t priority,
    int_handler irq_handler,
    void* arg)
{
  10cc14:	b538      	push	{r3, r4, r5, r14}
  10cc16:	460c      	mov	r4, r1
  10cc18:	4615      	mov	r5, r2
    arm_gic_register_int_handler(irq_number, irq_handler, arg);
  10cc1a:	4619      	mov	r1, r3
  10cc1c:	4620      	mov	r0, r4
  10cc1e:	9a04      	ldr	r2, [sp, #16]
  10cc20:	f7fa ffae 	bl	107b80 <arm_gic_register_int_handler>
    arm_gic_set_priority(irq_number, priority);
  10cc24:	4629      	mov	r1, r5
  10cc26:	4620      	mov	r0, r4
  10cc28:	f7fb f840 	bl	107cac <arm_gic_set_priority>

    return true;
}
  10cc2c:	2001      	movs	r0, #1
  10cc2e:	bd38      	pop	{r3, r4, r5, r15}

0010cc30 <init_per_items>:

    // find moudle node in table
    for (i = 0; i < arraynum; i++) {
        item = &module_per_table[i];

        if ((int)item->per_id == per_id) { //found
  10cc30:	f242 7034 	movw	r0, #10036	; 0x2734
  10cc34:	f2c0 0012 	movt	r0, #18
{
  10cc38:	b508      	push	{r3, r14}
        if ((int)item->per_id == per_id) { //found
  10cc3a:	6803      	ldr	r3, [r0, #0]
  10cc3c:	b123      	cbz	r3, 10cc48 <init_per_items+0x18>
  10cc3e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  10cc40:	b10b      	cbz	r3, 10cc46 <init_per_items+0x16>
}
  10cc42:	2000      	movs	r0, #0
  10cc44:	bd08      	pop	{r3, r15}
        item = &module_per_table[i];
  10cc46:	3038      	adds	r0, #56	; 0x38
        if (item->init) {
  10cc48:	6b43      	ldr	r3, [r0, #52]	; 0x34
        item->cur_state = 0;
  10cc4a:	2200      	movs	r2, #0
  10cc4c:	6242      	str	r2, [r0, #36]	; 0x24
        if (item->init) {
  10cc4e:	2b00      	cmp	r3, #0
  10cc50:	d0f7      	beq.n	10cc42 <init_per_items+0x12>
            item->init(item);
  10cc52:	4798      	blx	r3
}
  10cc54:	2000      	movs	r0, #0
  10cc56:	bd08      	pop	{r3, r15}

0010cc58 <module_helper_init>:
{
  10cc58:	b510      	push	{r4, r14}
    if (!have_init) {
  10cc5a:	f240 1471 	movw	r4, #369	; 0x171
  10cc5e:	f2c0 0413 	movt	r4, #19
  10cc62:	7823      	ldrb	r3, [r4, #0]
  10cc64:	b93b      	cbnz	r3, 10cc76 <module_helper_init+0x1e>
        register_res_clks();
  10cc66:	f002 f953 	bl	10ef10 <register_res_clks>
        register_res_rstgens();
  10cc6a:	f002 fea7 	bl	10f9bc <register_res_rstgens>
        init_per_items();
  10cc6e:	f7ff ffdf 	bl	10cc30 <init_per_items>
        have_init = true;
  10cc72:	2301      	movs	r3, #1
  10cc74:	7023      	strb	r3, [r4, #0]
}
  10cc76:	2000      	movs	r0, #0
  10cc78:	bd10      	pop	{r4, r15}
  10cc7a:	bf00      	nop

0010cc7c <module_set_state>:
    }

    return item->cur_state;
}
int module_set_state(enum module_per_id per_id, int state)
{
  10cc7c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if (!have_init) {
  10cc80:	f240 1471 	movw	r4, #369	; 0x171
{
  10cc84:	b082      	sub	sp, #8
  10cc86:	46f0      	mov	r8, r14
    if (!have_init) {
  10cc88:	f2c0 0413 	movt	r4, #19
{
  10cc8c:	4605      	mov	r5, r0
  10cc8e:	460f      	mov	r7, r1
    if (!have_init) {
  10cc90:	7823      	ldrb	r3, [r4, #0]
  10cc92:	b1ab      	cbz	r3, 10ccc0 <module_set_state+0x44>
        if ((int)item->per_id == per_id) { //found
  10cc94:	f242 7334 	movw	r3, #10036	; 0x2734
  10cc98:	f2c0 0312 	movt	r3, #18
  10cc9c:	681a      	ldr	r2, [r3, #0]
  10cc9e:	4295      	cmp	r5, r2
  10cca0:	d017      	beq.n	10ccd2 <module_set_state+0x56>
  10cca2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  10cca4:	4295      	cmp	r5, r2
  10cca6:	d040      	beq.n	10cd2a <module_set_state+0xae>
    int ret = 0;
    module_helper_init();
    item = get_per_item_by_id(per_id);

    if (!item) {
        dprintf(CRITICAL, "not found this per %d\n", per_id);
  10cca8:	f24c 20f0 	movw	r0, #49904	; 0xc2f0
  10ccac:	4629      	mov	r1, r5
  10ccae:	f2c0 0011 	movt	r0, #17
  10ccb2:	f007 fda7 	bl	114804 <printf>
        return -1;  //not found
  10ccb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    if (ret == 0) {
        item->cur_state = state;
    }

    return ret;
}
  10ccba:	b002      	add	sp, #8
  10ccbc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        register_res_clks();
  10ccc0:	f002 f926 	bl	10ef10 <register_res_clks>
        register_res_rstgens();
  10ccc4:	f002 fe7a 	bl	10f9bc <register_res_rstgens>
        init_per_items();
  10ccc8:	f7ff ffb2 	bl	10cc30 <init_per_items>
        have_init = true;
  10cccc:	2301      	movs	r3, #1
  10ccce:	7023      	strb	r3, [r4, #0]
  10ccd0:	e7e0      	b.n	10cc94 <module_set_state+0x18>
        item = &module_per_table[i];
  10ccd2:	461e      	mov	r6, r3
    if (state >= item->state_num) {
  10ccd4:	6ab2      	ldr	r2, [r6, #40]	; 0x28
  10ccd6:	42ba      	cmp	r2, r7
  10ccd8:	dd2a      	ble.n	10cd30 <module_set_state+0xb4>
    if (item->cur_state == state) {
  10ccda:	6a71      	ldr	r1, [r6, #36]	; 0x24
  10ccdc:	42b9      	cmp	r1, r7
  10ccde:	d020      	beq.n	10cd22 <module_set_state+0xa6>
                ((item->cur_state * item->state_num) + state) * (sizeof(void *)));
  10cce0:	fb01 7202 	mla	r2, r1, r2, r7
    if ((*res_handle) == NULL) {
  10cce4:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  10cce6:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
  10ccea:	b364      	cbz	r4, 10cd46 <module_set_state+0xca>
    ret = module_state_change_res_handle(item->per_id, *res_handle);
  10ccec:	6835      	ldr	r5, [r6, #0]
  10ccee:	e008      	b.n	10cd02 <module_set_state+0x86>
        switch (res->resid) {
  10ccf0:	f5b1 7fc1 	cmp.w	r1, #386	; 0x182
  10ccf4:	d231      	bcs.n	10cd5a <module_set_state+0xde>
                res_rstgen_request(per_id, res->resid, res->resparams);
  10ccf6:	6862      	ldr	r2, [r4, #4]
  10ccf8:	4628      	mov	r0, r5
  10ccfa:	f002 fe15 	bl	10f928 <res_rstgen_request>
    for (; res != NULL && res->resid != RES_INVALID; res++) {
  10ccfe:	3408      	adds	r4, #8
  10cd00:	d00a      	beq.n	10cd18 <module_set_state+0x9c>
  10cd02:	6821      	ldr	r1, [r4, #0]
  10cd04:	b141      	cbz	r1, 10cd18 <module_set_state+0x9c>
        switch (res->resid) {
  10cd06:	f5b1 7f88 	cmp.w	r1, #272	; 0x110
  10cd0a:	d2f1      	bcs.n	10ccf0 <module_set_state+0x74>
                res_clk_request(per_id, res->resid, res->resparams);
  10cd0c:	6862      	ldr	r2, [r4, #4]
  10cd0e:	4628      	mov	r0, r5
  10cd10:	f002 f8c6 	bl	10eea0 <res_clk_request>
    for (; res != NULL && res->resid != RES_INVALID; res++) {
  10cd14:	3408      	adds	r4, #8
  10cd16:	d1f4      	bne.n	10cd02 <module_set_state+0x86>
        item->cur_state = state;
  10cd18:	6277      	str	r7, [r6, #36]	; 0x24
    return ret;
  10cd1a:	2000      	movs	r0, #0
}
  10cd1c:	b002      	add	sp, #8
  10cd1e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return 0;
  10cd22:	2000      	movs	r0, #0
}
  10cd24:	b002      	add	sp, #8
  10cd26:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        item = &module_per_table[i];
  10cd2a:	f103 0638 	add.w	r6, r3, #56	; 0x38
  10cd2e:	e7d1      	b.n	10ccd4 <module_set_state+0x58>
        dprintf(CRITICAL, "out of state table %d max is %d\n", state,
  10cd30:	f24c 3008 	movw	r0, #49928	; 0xc308
  10cd34:	3a01      	subs	r2, #1
  10cd36:	4639      	mov	r1, r7
  10cd38:	f2c0 0011 	movt	r0, #17
  10cd3c:	f007 fd62 	bl	114804 <printf>
        return -1; //out of state table
  10cd40:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10cd44:	e7b9      	b.n	10ccba <module_set_state+0x3e>
        dprintf(CRITICAL, "not allowed change state from %d to %d\n",
  10cd46:	f24c 302c 	movw	r0, #49964	; 0xc32c
  10cd4a:	463a      	mov	r2, r7
  10cd4c:	f2c0 0011 	movt	r0, #17
  10cd50:	f007 fd58 	bl	114804 <printf>
        return -1;
  10cd54:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10cd58:	e7af      	b.n	10ccba <module_set_state+0x3e>
                dprintf(CRITICAL, "no such res %ld\n", res->resid);
  10cd5a:	f24c 3054 	movw	r0, #50004	; 0xc354
  10cd5e:	f2c0 0011 	movt	r0, #17
  10cd62:	f007 fd4f 	bl	114804 <printf>
                ASSERT(0);
  10cd66:	f649 0384 	movw	r3, #39044	; 0x9884
  10cd6a:	f24c 3268 	movw	r2, #50024	; 0xc368
  10cd6e:	f2c0 0311 	movt	r3, #17
  10cd72:	f647 4134 	movw	r1, #31796	; 0x7c34
  10cd76:	4640      	mov	r0, r8
  10cd78:	9300      	str	r3, [sp, #0]
  10cd7a:	f2c0 0211 	movt	r2, #17
  10cd7e:	2386      	movs	r3, #134	; 0x86
  10cd80:	f2c0 0111 	movt	r1, #17
  10cd84:	f006 fd0a 	bl	11379c <_panic>

0010cd88 <calculate_pll_rate>:
    &pll_cfg_2128M,
    &pll_cfg_2664M,
};

static unsigned long calculate_pll_rate(pll_config_t *config, int plldiv)
{
  10cd88:	b430      	push	{r4, r5}
    /*2^24*/
#define FRACM (16777216)
    unsigned long tmp = 0;
    unsigned long freq = 0;

    if (config->integer == 0) {
  10cd8a:	7903      	ldrb	r3, [r0, #4]
  10cd8c:	bb2b      	cbnz	r3, 10cdda <calculate_pll_rate+0x52>
        tmp = config->frac * (1000) / (FRACM / 1000);
  10cd8e:	69c2      	ldr	r2, [r0, #28]
  10cd90:	f24d 24f1 	movw	r4, #54001	; 0xd2f1
  10cd94:	f6cf 2400 	movt	r4, #64000	; 0xfa00
  10cd98:	ebc2 1342 	rsb	r3, r2, r2, lsl #5
  10cd9c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  10cda0:	00db      	lsls	r3, r3, #3
  10cda2:	fba4 2303 	umull	r2, r3, r4, r3
  10cda6:	0b9b      	lsrs	r3, r3, #14
    }

    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
                24) / config->refdiv);
  10cda8:	68c5      	ldr	r5, [r0, #12]
  10cdaa:	2218      	movs	r2, #24
    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
  10cdac:	6904      	ldr	r4, [r0, #16]
                24) / config->refdiv);
  10cdae:	fbb2 f2f5 	udiv	r2, r2, r5
    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
  10cdb2:	ebc4 1544 	rsb	r5, r4, r4, lsl #5
  10cdb6:	ebc5 1585 	rsb	r5, r5, r5, lsl #6
  10cdba:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
  10cdbe:	eb03 1384 	add.w	r3, r3, r4, lsl #6
  10cdc2:	fb02 f303 	mul.w	r3, r2, r3

    if (plldiv == PLL_ROOT) {//root
  10cdc6:	b191      	cbz	r1, 10cdee <calculate_pll_rate+0x66>
        freq = freq / config->postdiv[0] / config->postdiv[1];
    }
    else if (plldiv >= PLL_DIVA && plldiv <= PLL_DIVD) {
  10cdc8:	1e4a      	subs	r2, r1, #1
  10cdca:	2a03      	cmp	r2, #3
  10cdcc:	d907      	bls.n	10cdde <calculate_pll_rate+0x56>
        freq = freq / config->out_div[plldiv - 1];
    }
    else if (plldiv == PLL_DUMMY_ROOT) {
  10cdce:	2905      	cmp	r1, #5
        return freq;
    }
    else {
        freq = 0;
  10cdd0:	bf18      	it	ne
  10cdd2:	2300      	movne	r3, #0
    }

    return freq;
}
  10cdd4:	4618      	mov	r0, r3
  10cdd6:	bc30      	pop	{r4, r5}
  10cdd8:	4770      	bx	r14
    unsigned long tmp = 0;
  10cdda:	2300      	movs	r3, #0
  10cddc:	e7e4      	b.n	10cda8 <calculate_pll_rate+0x20>
        freq = freq / config->out_div[plldiv - 1];
  10cdde:	3107      	adds	r1, #7
}
  10cde0:	bc30      	pop	{r4, r5}
        freq = freq / config->out_div[plldiv - 1];
  10cde2:	f850 2021 	ldr.w	r2, [r0, r1, lsl #2]
  10cde6:	fbb3 f3f2 	udiv	r3, r3, r2
}
  10cdea:	4618      	mov	r0, r3
  10cdec:	4770      	bx	r14
        freq = freq / config->postdiv[0] / config->postdiv[1];
  10cdee:	e9d0 1205 	ldrd	r1, r2, [r0, #20]
}
  10cdf2:	bc30      	pop	{r4, r5}
        freq = freq / config->postdiv[0] / config->postdiv[1];
  10cdf4:	fbb3 f3f1 	udiv	r3, r3, r1
  10cdf8:	fbb3 f3f2 	udiv	r3, r3, r2
}
  10cdfc:	4618      	mov	r0, r3
  10cdfe:	4770      	bx	r14

0010ce00 <get_clk_by_id_internal>:
}

//
static struct clk *get_clk_by_id_internal(struct list_node *list,
        unsigned long clkid)
{
  10ce00:	b570      	push	{r4, r5, r6, r14}
    struct clk *clk;

    if (!list) {
        return get_clk_by_id_internal(&g_clk_root, clkid);
  10ce02:	f642 0518 	movw	r5, #10264	; 0x2818
  10ce06:	f2c0 0512 	movt	r5, #18
  10ce0a:	2800      	cmp	r0, #0
  10ce0c:	bf18      	it	ne
  10ce0e:	4605      	movne	r5, r0
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
    return (list->next == list) ? true : false;
  10ce10:	686b      	ldr	r3, [r5, #4]
    }

    if (list_is_empty(list)) {
  10ce12:	42ab      	cmp	r3, r5
  10ce14:	d021      	beq.n	10ce5a <get_clk_by_id_internal+0x5a>
        return NULL;
    }

    list_for_every_entry(list, clk, struct clk, node) {
  10ce16:	429d      	cmp	r5, r3
  10ce18:	f1a3 0460 	sub.w	r4, r3, #96	; 0x60
  10ce1c:	d01d      	beq.n	10ce5a <get_clk_by_id_internal+0x5a>
        if (clk->clkid == clkid) {
  10ce1e:	f853 3c60 	ldr.w	r3, [r3, #-96]
  10ce22:	460e      	mov	r6, r1
  10ce24:	4299      	cmp	r1, r3
  10ce26:	d00f      	beq.n	10ce48 <get_clk_by_id_internal+0x48>
            return clk;
        }

        if (list_is_empty(&clk->child)) {
  10ce28:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
  10ce2a:	f104 0368 	add.w	r3, r4, #104	; 0x68
            continue;
        }

        struct clk *child = get_clk_by_id_internal(&clk->child, clkid);
  10ce2e:	4631      	mov	r1, r6
  10ce30:	4618      	mov	r0, r3
        if (list_is_empty(&clk->child)) {
  10ce32:	4293      	cmp	r3, r2
  10ce34:	d10a      	bne.n	10ce4c <get_clk_by_id_internal+0x4c>
    list_for_every_entry(list, clk, struct clk, node) {
  10ce36:	6e63      	ldr	r3, [r4, #100]	; 0x64
  10ce38:	429d      	cmp	r5, r3
  10ce3a:	f1a3 0460 	sub.w	r4, r3, #96	; 0x60
  10ce3e:	d00c      	beq.n	10ce5a <get_clk_by_id_internal+0x5a>
        if (clk->clkid == clkid) {
  10ce40:	f853 3c60 	ldr.w	r3, [r3, #-96]
  10ce44:	42b3      	cmp	r3, r6
  10ce46:	d1ef      	bne.n	10ce28 <get_clk_by_id_internal+0x28>
        if (child) {
            return child;
        }
    }
    return NULL;
}
  10ce48:	4620      	mov	r0, r4
  10ce4a:	bd70      	pop	{r4, r5, r6, r15}
        struct clk *child = get_clk_by_id_internal(&clk->child, clkid);
  10ce4c:	f7ff ffd8 	bl	10ce00 <get_clk_by_id_internal>
        if (child) {
  10ce50:	2800      	cmp	r0, #0
  10ce52:	d0f0      	beq.n	10ce36 <get_clk_by_id_internal+0x36>
        struct clk *child = get_clk_by_id_internal(&clk->child, clkid);
  10ce54:	4604      	mov	r4, r0
}
  10ce56:	4620      	mov	r0, r4
  10ce58:	bd70      	pop	{r4, r5, r6, r15}
        return NULL;
  10ce5a:	2400      	movs	r4, #0
}
  10ce5c:	4620      	mov	r0, r4
  10ce5e:	bd70      	pop	{r4, r5, r6, r15}

0010ce60 <clk_get_refcount>:
    return count;
}


static int clk_get_refcount(struct clk *clk, bool freqcare)
{
  10ce60:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    int count = 0;
  10ce62:	2400      	movs	r4, #0
            if ((1 << j)&n) {
  10ce64:	2601      	movs	r6, #1
        n = ref[i];
  10ce66:	6b05      	ldr	r5, [r0, #48]	; 0x30
        for (j = 0; j < 32; j++) {
  10ce68:	4623      	mov	r3, r4
            if ((1 << j)&n) {
  10ce6a:	fa06 f203 	lsl.w	r2, r6, r3
  10ce6e:	422a      	tst	r2, r5
  10ce70:	f103 0301 	add.w	r3, r3, #1
                count++;
  10ce74:	bf18      	it	ne
  10ce76:	3401      	addne	r4, #1
        for (j = 0; j < 32; j++) {
  10ce78:	2b20      	cmp	r3, #32
  10ce7a:	d1f6      	bne.n	10ce6a <clk_get_refcount+0xa>
    struct clk *child = NULL;
    //count refcount bitmap
    count += clk_get_refcount_bits(clk, true);

    //count refcount en bitmap
    if (!freqcare) {
  10ce7c:	b969      	cbnz	r1, 10ce9a <clk_get_refcount+0x3a>
        n = ref[i];
  10ce7e:	6b47      	ldr	r7, [r0, #52]	; 0x34
    int count = 0;
  10ce80:	460d      	mov	r5, r1
        for (j = 0; j < 32; j++) {
  10ce82:	460b      	mov	r3, r1
            if ((1 << j)&n) {
  10ce84:	2601      	movs	r6, #1
  10ce86:	fa06 f203 	lsl.w	r2, r6, r3
  10ce8a:	423a      	tst	r2, r7
  10ce8c:	f103 0301 	add.w	r3, r3, #1
                count++;
  10ce90:	bf18      	it	ne
  10ce92:	3501      	addne	r5, #1
        for (j = 0; j < 32; j++) {
  10ce94:	2b20      	cmp	r3, #32
  10ce96:	d1f6      	bne.n	10ce86 <clk_get_refcount+0x26>
        count += clk_get_refcount_bits(clk, false);
  10ce98:	442c      	add	r4, r5
  10ce9a:	6ec5      	ldr	r5, [r0, #108]	; 0x6c
    }

    //cound child
    if (list_is_empty(&clk->child)) {
  10ce9c:	f100 0668 	add.w	r6, r0, #104	; 0x68
  10cea0:	42ae      	cmp	r6, r5
  10cea2:	d00b      	beq.n	10cebc <clk_get_refcount+0x5c>
  10cea4:	460f      	mov	r7, r1
        return count;
    }

    list_for_every_entry(&clk->child, child, struct clk, node) {
  10cea6:	3d60      	subs	r5, #96	; 0x60
        count += clk_get_refcount(child, freqcare);
  10cea8:	4628      	mov	r0, r5
  10ceaa:	4639      	mov	r1, r7
  10ceac:	f7ff ffd8 	bl	10ce60 <clk_get_refcount>
    list_for_every_entry(&clk->child, child, struct clk, node) {
  10ceb0:	6e6b      	ldr	r3, [r5, #100]	; 0x64
  10ceb2:	429e      	cmp	r6, r3
  10ceb4:	f1a3 0560 	sub.w	r5, r3, #96	; 0x60
        count += clk_get_refcount(child, freqcare);
  10ceb8:	4404      	add	r4, r0
    list_for_every_entry(&clk->child, child, struct clk, node) {
  10ceba:	d1f5      	bne.n	10cea8 <clk_get_refcount+0x48>
    }
    return count;
}
  10cebc:	4620      	mov	r0, r4
  10cebe:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010cec0 <res_clk_get_rate>:
        return true;
    }
}

static unsigned long res_clk_get_rate(struct clk *clk, bool bymonitor)
{
  10cec0:	b570      	push	{r4, r5, r6, r14}
    struct clk *p = NULL;
    unsigned long prate;

    if (clk->cur_parent_index == -1) {
  10cec2:	6b85      	ldr	r5, [r0, #56]	; 0x38
{
  10cec4:	460a      	mov	r2, r1
    if (clk->cur_parent_index == -1) {
  10cec6:	1c6c      	adds	r4, r5, #1
  10cec8:	d107      	bne.n	10ceda <res_clk_get_rate+0x1a>
        if (clk->get_rate) {
  10ceca:	f8d0 40e4 	ldr.w	r4, [r0, #228]	; 0xe4
  10cece:	b19c      	cbz	r4, 10cef8 <res_clk_get_rate+0x38>
            return clk->get_rate(clk, 0, bymonitor);
  10ced0:	4623      	mov	r3, r4
  10ced2:	2100      	movs	r1, #0
    }

    p = clk->parents[clk->cur_parent_index];
    prate = res_clk_get_rate(p, bymonitor);
    return clk->get_rate(clk, prate, bymonitor);
}
  10ced4:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
            return clk->get_rate(clk, 0, bymonitor);
  10ced8:	4718      	bx	r3
  10ceda:	4604      	mov	r4, r0
    p = clk->parents[clk->cur_parent_index];
  10cedc:	3510      	adds	r5, #16
  10cede:	460e      	mov	r6, r1
    prate = res_clk_get_rate(p, bymonitor);
  10cee0:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
  10cee4:	f7ff ffec 	bl	10cec0 <res_clk_get_rate>
    return clk->get_rate(clk, prate, bymonitor);
  10cee8:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
  10ceec:	4632      	mov	r2, r6
  10ceee:	4601      	mov	r1, r0
  10cef0:	4620      	mov	r0, r4
}
  10cef2:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    return clk->get_rate(clk, prate, bymonitor);
  10cef6:	4718      	bx	r3
            return clk->rate;
  10cef8:	6f00      	ldr	r0, [r0, #112]	; 0x70
}
  10cefa:	bd70      	pop	{r4, r5, r6, r15}

0010cefc <get_ckgen_uuu_ctl>:
/*UUU*/
static unsigned long get_ckgen_uuu_rate(unsigned long resid, int uuu_type,
                                        unsigned long prate, bool bymonitor);

static int get_ckgen_uuu_ctl(unsigned long resid, clkgen_uuu_ctl *ctl)
{
  10cefc:	b530      	push	{r4, r5, r14}
  10cefe:	4604      	mov	r4, r0
  10cf00:	b083      	sub	sp, #12
  10cf02:	460d      	mov	r5, r1
    bool ret = false;
    void *g_handle;
    ret = hal_clock_creat_handle(&g_handle);
  10cf04:	a801      	add	r0, sp, #4
  10cf06:	f7fd fb13 	bl	10a530 <hal_clock_creat_handle>

    if (!ret) {
  10cf0a:	b170      	cbz	r0, 10cf2a <get_ckgen_uuu_ctl+0x2e>
        printf("do get_ckgen_ip_ctl creat handle failed\n");
        return -1;
    }

    ret = hal_clock_uuuctl_get(g_handle, resid, ctl);
  10cf0c:	4621      	mov	r1, r4
  10cf0e:	462a      	mov	r2, r5
  10cf10:	9801      	ldr	r0, [sp, #4]
  10cf12:	f7fe f8a1 	bl	10b058 <hal_clock_uuuctl_get>
  10cf16:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10cf18:	9801      	ldr	r0, [sp, #4]
  10cf1a:	f7fd fb25 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10cf1e:	f084 0001 	eor.w	r0, r4, #1
  10cf22:	b2c0      	uxtb	r0, r0
  10cf24:	4240      	negs	r0, r0
}
  10cf26:	b003      	add	sp, #12
  10cf28:	bd30      	pop	{r4, r5, r15}
        printf("do get_ckgen_ip_ctl creat handle failed\n");
  10cf2a:	f24c 603c 	movw	r0, #50748	; 0xc63c
  10cf2e:	f2c0 0011 	movt	r0, #17
  10cf32:	f007 fc4f 	bl	1147d4 <puts>
        return -1;
  10cf36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10cf3a:	e7f4      	b.n	10cf26 <get_ckgen_uuu_ctl+0x2a>

0010cf3c <set_ckgen_uuu_ctl>:

static int set_ckgen_uuu_ctl(unsigned long resid, clkgen_uuu_ctl *ctl)
{
  10cf3c:	b530      	push	{r4, r5, r14}
  10cf3e:	4604      	mov	r4, r0
  10cf40:	b083      	sub	sp, #12
  10cf42:	460d      	mov	r5, r1
    bool ret = false;
    void *g_handle;
    ret = hal_clock_creat_handle(&g_handle);
  10cf44:	a801      	add	r0, sp, #4
  10cf46:	f7fd faf3 	bl	10a530 <hal_clock_creat_handle>

    if (!ret) {
  10cf4a:	b170      	cbz	r0, 10cf6a <set_ckgen_uuu_ctl+0x2e>
        printf("do get_ckgen_ip_ctl creat handle failed\n");
        return -1;
    }

    ret = hal_clock_uuuctl_set(g_handle, resid, ctl);
  10cf4c:	4621      	mov	r1, r4
  10cf4e:	462a      	mov	r2, r5
  10cf50:	9801      	ldr	r0, [sp, #4]
  10cf52:	f7fe f8b5 	bl	10b0c0 <hal_clock_uuuctl_set>
  10cf56:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10cf58:	9801      	ldr	r0, [sp, #4]
  10cf5a:	f7fd fb05 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10cf5e:	f084 0001 	eor.w	r0, r4, #1
  10cf62:	b2c0      	uxtb	r0, r0
  10cf64:	4240      	negs	r0, r0
}
  10cf66:	b003      	add	sp, #12
  10cf68:	bd30      	pop	{r4, r5, r15}
        printf("do get_ckgen_ip_ctl creat handle failed\n");
  10cf6a:	f24c 603c 	movw	r0, #50748	; 0xc63c
  10cf6e:	f2c0 0011 	movt	r0, #17
  10cf72:	f007 fc2f 	bl	1147d4 <puts>
        return -1;
  10cf76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10cf7a:	e7f4      	b.n	10cf66 <set_ckgen_uuu_ctl+0x2a>

0010cf7c <get_ckgen_uuu_rate>:
}


static unsigned long get_ckgen_uuu_rate(unsigned long resid, int uuu_type,
                                        unsigned long prate, bool bymonitor)
{
  10cf7c:	b5f0      	push	{r4, r5, r6, r7, r14}
  10cf7e:	460d      	mov	r5, r1
  10cf80:	b083      	sub	sp, #12
    int ret;
    clkgen_uuu_ctl ctl;

    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10cf82:	4669      	mov	r1, r13
{
  10cf84:	4614      	mov	r4, r2
  10cf86:	461e      	mov	r6, r3
  10cf88:	4607      	mov	r7, r0
    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10cf8a:	f7ff ffb7 	bl	10cefc <get_ckgen_uuu_ctl>
  10cf8e:	2800      	cmp	r0, #0
        return -1;
  10cf90:	bfb8      	it	lt
  10cf92:	f04f 30ff 	movlt.w	r0, #4294967295	; 0xffffffff
    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10cf96:	db15      	blt.n	10cfc4 <get_ckgen_uuu_rate+0x48>
    }

    if (uuu_type == UUU_SEL0
  10cf98:	2d01      	cmp	r5, #1
            || uuu_type == UUU_SEL1) { //dummy node, return parent rate.
        return prate;
  10cf9a:	bf98      	it	ls
  10cf9c:	4620      	movls	r0, r4
    if (uuu_type == UUU_SEL0
  10cf9e:	d911      	bls.n	10cfc4 <get_ckgen_uuu_rate+0x48>
    }

    if (bymonitor) {
  10cfa0:	b996      	cbnz	r6, 10cfc8 <get_ckgen_uuu_rate+0x4c>
        hal_clock_release_handle(g_handle);
        //the monitor point is after the M, so...
        prate = rate * (ctl.m_div + 1);
    }

    if (uuu_type == UUU_M) {
  10cfa2:	2d02      	cmp	r5, #2
  10cfa4:	d02e      	beq.n	10d004 <get_ckgen_uuu_rate+0x88>
        return prate / (ctl.m_div + 1);
    }
    else if (uuu_type == UUU_N) {
  10cfa6:	2d03      	cmp	r5, #3
  10cfa8:	d034      	beq.n	10d014 <get_ckgen_uuu_rate+0x98>
        return prate / (ctl.n_div + 1);
    }
    else if (uuu_type == UUU_P) {
  10cfaa:	2d04      	cmp	r5, #4
  10cfac:	d023      	beq.n	10cff6 <get_ckgen_uuu_rate+0x7a>
        return prate / (ctl.p_div + 1);
    }
    else if (uuu_type == UUU_Q) {
  10cfae:	2d05      	cmp	r5, #5
        return prate / (ctl.q_div + 1);
  10cfb0:	bf09      	itett	eq
  10cfb2:	f89d 0000 	ldrbeq.w	r0, [r13]
    }

    return 0;
  10cfb6:	2000      	movne	r0, #0
        return prate / (ctl.q_div + 1);
  10cfb8:	f000 000f 	andeq.w	r0, r0, #15
  10cfbc:	3001      	addeq	r0, #1
  10cfbe:	bf08      	it	eq
  10cfc0:	fbb4 f0f0 	udiveq	r0, r4, r0
}
  10cfc4:	b003      	add	sp, #12
  10cfc6:	bdf0      	pop	{r4, r5, r6, r7, r15}
        ret = hal_clock_creat_handle(&g_handle);
  10cfc8:	a801      	add	r0, sp, #4
  10cfca:	f7fd fab1 	bl	10a530 <hal_clock_creat_handle>
        if (!ret) {
  10cfce:	4604      	mov	r4, r0
  10cfd0:	b340      	cbz	r0, 10d024 <get_ckgen_uuu_rate+0xa8>
        rate = hal_clock_uuuclk_get(g_handle, resid,
  10cfd2:	2300      	movs	r3, #0
  10cfd4:	4639      	mov	r1, r7
  10cfd6:	9801      	ldr	r0, [sp, #4]
  10cfd8:	461a      	mov	r2, r3
  10cfda:	f7fe f90d 	bl	10b1f8 <hal_clock_uuuclk_get>
        if (rate == 0) //maybe it's too slow, try monitor with 32k
  10cfde:	4604      	mov	r4, r0
  10cfe0:	b340      	cbz	r0, 10d034 <get_ckgen_uuu_rate+0xb8>
        hal_clock_release_handle(g_handle);
  10cfe2:	9801      	ldr	r0, [sp, #4]
  10cfe4:	f7fd fac0 	bl	10a568 <hal_clock_release_handle>
        prate = rate * (ctl.m_div + 1);
  10cfe8:	f89d 0001 	ldrb.w	r0, [r13, #1]
  10cfec:	0900      	lsrs	r0, r0, #4
  10cfee:	3001      	adds	r0, #1
  10cff0:	fb04 f400 	mul.w	r4, r4, r0
  10cff4:	e7d5      	b.n	10cfa2 <get_ckgen_uuu_rate+0x26>
        return prate / (ctl.p_div + 1);
  10cff6:	f89d 0000 	ldrb.w	r0, [r13]
  10cffa:	0900      	lsrs	r0, r0, #4
  10cffc:	3001      	adds	r0, #1
  10cffe:	fbb4 f0f0 	udiv	r0, r4, r0
  10d002:	e7df      	b.n	10cfc4 <get_ckgen_uuu_rate+0x48>
        return prate / (ctl.m_div + 1);
  10d004:	f89d 0001 	ldrb.w	r0, [r13, #1]
  10d008:	0900      	lsrs	r0, r0, #4
  10d00a:	3001      	adds	r0, #1
  10d00c:	fbb4 f0f0 	udiv	r0, r4, r0
}
  10d010:	b003      	add	sp, #12
  10d012:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return prate / (ctl.n_div + 1);
  10d014:	f89d 0001 	ldrb.w	r0, [r13, #1]
  10d018:	f000 000f 	and.w	r0, r0, #15
  10d01c:	3001      	adds	r0, #1
  10d01e:	fbb4 f0f0 	udiv	r0, r4, r0
  10d022:	e7cf      	b.n	10cfc4 <get_ckgen_uuu_rate+0x48>
            printf("do get_ckgen_uuu_rate creat handle failed\n");
  10d024:	f24c 6064 	movw	r0, #50788	; 0xc664
  10d028:	f2c0 0011 	movt	r0, #17
  10d02c:	f007 fbd2 	bl	1147d4 <puts>
            return 0;
  10d030:	4620      	mov	r0, r4
  10d032:	e7c7      	b.n	10cfc4 <get_ckgen_uuu_rate+0x48>
            rate = hal_clock_uuuclk_get(g_handle, resid,
  10d034:	4603      	mov	r3, r0
  10d036:	4639      	mov	r1, r7
  10d038:	9801      	ldr	r0, [sp, #4]
  10d03a:	2201      	movs	r2, #1
  10d03c:	f7fe f8dc 	bl	10b1f8 <hal_clock_uuuclk_get>
  10d040:	4604      	mov	r4, r0
  10d042:	e7ce      	b.n	10cfe2 <get_ckgen_uuu_rate+0x66>

0010d044 <is_valid_pll_config.isra.1.part.2>:

    hal_pll_config(pll, &cur);
    hal_pll_delete_handle(pll);
    return 0;
}
static bool is_valid_pll_config(struct clk *clk, pll_config_t *conf)
  10d044:	b4f0      	push	{r4, r5, r6, r7}
    if (config->integer == 0) {
  10d046:	7901      	ldrb	r1, [r0, #4]
  10d048:	e9d0 6203 	ldrd	r6, r2, [r0, #12]
  10d04c:	2318      	movs	r3, #24
  10d04e:	ebc2 1542 	rsb	r5, r2, r2, lsl #5
  10d052:	fbb3 f4f6 	udiv	r4, r3, r6
  10d056:	ebc5 1585 	rsb	r5, r5, r5, lsl #6
  10d05a:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
  10d05e:	0192      	lsls	r2, r2, #6
  10d060:	bb69      	cbnz	r1, 10d0be <is_valid_pll_config.isra.1.part.2+0x7a>
        tmp = config->frac * (1000) / (FRACM / 1000);
  10d062:	69c5      	ldr	r5, [r0, #28]
  10d064:	f24d 20f1 	movw	r0, #54001	; 0xd2f1
        //fvco 800MHZ~3200MHZ
        unsigned long fvco;
        unsigned pfd;
        fvco = calculate_pll_rate(conf, PLL_DUMMY_ROOT);

        if (fvco < 800000000 || fvco > 3200000000) {
  10d068:	f44f 4778 	mov.w	r7, #63488	; 0xf800
        tmp = config->frac * (1000) / (FRACM / 1000);
  10d06c:	f6cf 2000 	movt	r0, #64000	; 0xfa00
  10d070:	ebc5 1345 	rsb	r3, r5, r5, lsl #5
        if (fvco < 800000000 || fvco > 3200000000) {
  10d074:	f2cd 0750 	movt	r7, #53328	; 0xd050
        tmp = config->frac * (1000) / (FRACM / 1000);
  10d078:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  10d07c:	00db      	lsls	r3, r3, #3
  10d07e:	fba0 0303 	umull	r0, r3, r0, r3
        if (fvco < 800000000 || fvco > 3200000000) {
  10d082:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
  10d086:	f6c8 700d 	movt	r0, #36621	; 0x8f0d
    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
  10d08a:	eb02 3393 	add.w	r3, r2, r3, lsr #14
        if (fvco < 800000000 || fvco > 3200000000) {
  10d08e:	fb04 7303 	mla	r3, r4, r3, r7
  10d092:	4283      	cmp	r3, r0
  10d094:	d810      	bhi.n	10d0b8 <is_valid_pll_config.isra.1.part.2+0x74>
            return false;
        }

        //pfd >10Mhz in fac mode. and >5Mhz in int mode
        pfd = 24000000 / conf->refdiv;
  10d096:	f44f 5358 	mov.w	r3, #13824	; 0x3600

        if (conf->integer && pfd <= 5000000) {
            return false;
        }

        if (conf->integer == 0 && pfd <= 10000000) {
  10d09a:	f249 6280 	movw	r2, #38528	; 0x9680
        pfd = 24000000 / conf->refdiv;
  10d09e:	f2c0 136e 	movt	r3, #366	; 0x16e
        if (conf->integer == 0 && pfd <= 10000000) {
  10d0a2:	f2c0 0298 	movt	r2, #152	; 0x98
        pfd = 24000000 / conf->refdiv;
  10d0a6:	fbb3 f6f6 	udiv	r6, r3, r6
        if (conf->integer == 0 && pfd <= 10000000) {
  10d0aa:	4296      	cmp	r6, r2
  10d0ac:	d904      	bls.n	10d0b8 <is_valid_pll_config.isra.1.part.2+0x74>
            return false;
        }

        if (conf->integer == 0 && conf->frac >= 16777216) {
  10d0ae:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
  10d0b2:	bf2c      	ite	cs
  10d0b4:	2100      	movcs	r1, #0
  10d0b6:	2101      	movcc	r1, #1
            return false;
        }
    }

    return true;
}
  10d0b8:	4608      	mov	r0, r1
  10d0ba:	bcf0      	pop	{r4, r5, r6, r7}
  10d0bc:	4770      	bx	r14
        if (fvco < 800000000 || fvco > 3200000000) {
  10d0be:	f44f 4378 	mov.w	r3, #63488	; 0xf800
  10d0c2:	f44f 51c0 	mov.w	r1, #6144	; 0x1800
  10d0c6:	f2cd 0350 	movt	r3, #53328	; 0xd050
  10d0ca:	f6c8 710d 	movt	r1, #36621	; 0x8f0d
  10d0ce:	fb02 3304 	mla	r3, r2, r4, r3
  10d0d2:	428b      	cmp	r3, r1
  10d0d4:	d810      	bhi.n	10d0f8 <is_valid_pll_config.isra.1.part.2+0xb4>
        pfd = 24000000 / conf->refdiv;
  10d0d6:	f44f 5158 	mov.w	r1, #13824	; 0x3600
        if (conf->integer && pfd <= 5000000) {
  10d0da:	f644 3040 	movw	r0, #19264	; 0x4b40
        pfd = 24000000 / conf->refdiv;
  10d0de:	f2c0 116e 	movt	r1, #366	; 0x16e
        if (conf->integer && pfd <= 5000000) {
  10d0e2:	f2c0 004c 	movt	r0, #76	; 0x4c
        pfd = 24000000 / conf->refdiv;
  10d0e6:	fbb1 f1f6 	udiv	r1, r1, r6
}
  10d0ea:	bcf0      	pop	{r4, r5, r6, r7}
        if (conf->integer && pfd <= 5000000) {
  10d0ec:	4281      	cmp	r1, r0
  10d0ee:	bf94      	ite	ls
  10d0f0:	2100      	movls	r1, #0
  10d0f2:	2101      	movhi	r1, #1
}
  10d0f4:	4608      	mov	r0, r1
  10d0f6:	4770      	bx	r14
            return false;
  10d0f8:	2100      	movs	r1, #0
}
  10d0fa:	4608      	mov	r0, r1
  10d0fc:	bcf0      	pop	{r4, r5, r6, r7}
  10d0fe:	4770      	bx	r14

0010d100 <clk_test_refcount_bit.part.12>:
    ASSERT(i < REFCNT_NUM);
  10d100:	f24c 6310 	movw	r3, #50704	; 0xc610
  10d104:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
static int clk_test_refcount_bit(struct clk *clk, int per_id,
  10d108:	b500      	push	{r14}
    ASSERT(i < REFCNT_NUM);
  10d10a:	f2c0 0311 	movt	r3, #17
  10d10e:	f647 4134 	movw	r1, #31796	; 0x7c34
static int clk_test_refcount_bit(struct clk *clk, int per_id,
  10d112:	b083      	sub	sp, #12
    ASSERT(i < REFCNT_NUM);
  10d114:	4670      	mov	r0, r14
  10d116:	f2c0 0211 	movt	r2, #17
  10d11a:	9300      	str	r3, [sp, #0]
  10d11c:	f2c0 0111 	movt	r1, #17
  10d120:	f240 33c7 	movw	r3, #967	; 0x3c7
  10d124:	f006 fb3a 	bl	11379c <_panic>

0010d128 <clk_clear_refcount_bit>:
    int i = per_id / 32;
  10d128:	f101 031f 	add.w	r3, r1, #31
{
  10d12c:	b530      	push	{r4, r5, r14}
    int i = per_id / 32;
  10d12e:	ea13 0321 	ands.w	r3, r3, r1, asr #32
  10d132:	bf38      	it	cc
  10d134:	460b      	movcc	r3, r1
{
  10d136:	b083      	sub	sp, #12
    int i = per_id / 32;
  10d138:	115b      	asrs	r3, r3, #5
    if (freqcare) {
  10d13a:	b1ba      	cbz	r2, 10d16c <clk_clear_refcount_bit+0x44>
    ASSERT(i < REFCNT_NUM);
  10d13c:	2b00      	cmp	r3, #0
        ref = &clk->refcount[0];
  10d13e:	f100 0230 	add.w	r2, r0, #48	; 0x30
    ASSERT(i < REFCNT_NUM);
  10d142:	dc17      	bgt.n	10d174 <clk_clear_refcount_bit+0x4c>
    ref[i] &= ~(1 << (per_id % 32));
  10d144:	2501      	movs	r5, #1
  10d146:	424c      	negs	r4, r1
  10d148:	f004 041f 	and.w	r4, r4, #31
}
  10d14c:	f04f 0000 	mov.w	r0, #0
    ref[i] &= ~(1 << (per_id % 32));
  10d150:	f001 011f 	and.w	r1, r1, #31
  10d154:	bf58      	it	pl
  10d156:	4261      	negpl	r1, r4
  10d158:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
  10d15c:	fa05 f101 	lsl.w	r1, r5, r1
  10d160:	ea24 0401 	bic.w	r4, r4, r1
  10d164:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
}
  10d168:	b003      	add	sp, #12
  10d16a:	bd30      	pop	{r4, r5, r15}
    ASSERT(i < REFCNT_NUM);
  10d16c:	2b00      	cmp	r3, #0
        ref = &clk->refcount_en[0];
  10d16e:	f100 0234 	add.w	r2, r0, #52	; 0x34
    ASSERT(i < REFCNT_NUM);
  10d172:	dde7      	ble.n	10d144 <clk_clear_refcount_bit+0x1c>
  10d174:	f24c 6310 	movw	r3, #50704	; 0xc610
  10d178:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d17c:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d180:	f2c0 0311 	movt	r3, #17
  10d184:	4670      	mov	r0, r14
  10d186:	f2c0 0211 	movt	r2, #17
  10d18a:	9300      	str	r3, [sp, #0]
  10d18c:	f2c0 0111 	movt	r1, #17
  10d190:	f240 33b5 	movw	r3, #949	; 0x3b5
  10d194:	f006 fb02 	bl	11379c <_panic>

0010d198 <res_clk_dec_refcount>:
static int res_clk_dec_refcount(struct clk *clk, unsigned long per_id)
{
    int new_refcount;
    int ret = 0;

    if (per_id != INVALID_PER_ID) {
  10d198:	2901      	cmp	r1, #1
{
  10d19a:	b538      	push	{r3, r4, r5, r14}
  10d19c:	4604      	mov	r4, r0
    if (per_id != INVALID_PER_ID) {
  10d19e:	d008      	beq.n	10d1b2 <res_clk_dec_refcount+0x1a>
  10d1a0:	460d      	mov	r5, r1
        clk_clear_refcount_bit(clk, per_id, true);
  10d1a2:	2201      	movs	r2, #1
  10d1a4:	f7ff ffc0 	bl	10d128 <clk_clear_refcount_bit>
        clk_clear_refcount_bit(clk, per_id, false);
  10d1a8:	4629      	mov	r1, r5
  10d1aa:	2200      	movs	r2, #0
  10d1ac:	4620      	mov	r0, r4
  10d1ae:	f7ff ffbb 	bl	10d128 <clk_clear_refcount_bit>
    }

    new_refcount = clk_get_refcount(clk, false);
  10d1b2:	2100      	movs	r1, #0
  10d1b4:	4620      	mov	r0, r4
  10d1b6:	f7ff fe53 	bl	10ce60 <clk_get_refcount>

    if (new_refcount == 0) {
  10d1ba:	4605      	mov	r5, r0
  10d1bc:	b980      	cbnz	r0, 10d1e0 <res_clk_dec_refcount+0x48>
        bool is_enabled = true;

        if (clk->is_enable) {
  10d1be:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
  10d1c2:	b113      	cbz	r3, 10d1ca <res_clk_dec_refcount+0x32>
            is_enabled = clk->is_enable(clk);
  10d1c4:	4620      	mov	r0, r4
  10d1c6:	4798      	blx	r3
        }

        if (is_enabled && clk->disable) {
  10d1c8:	b128      	cbz	r0, 10d1d6 <res_clk_dec_refcount+0x3e>
  10d1ca:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
  10d1ce:	b113      	cbz	r3, 10d1d6 <res_clk_dec_refcount+0x3e>
            ret = clk->disable(clk);
  10d1d0:	4620      	mov	r0, r4
  10d1d2:	4798      	blx	r3
  10d1d4:	4605      	mov	r5, r0
        }

        if (clk->cur_parent_index != -1) {
  10d1d6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  10d1d8:	1c5a      	adds	r2, r3, #1
  10d1da:	d104      	bne.n	10d1e6 <res_clk_dec_refcount+0x4e>
                                        INVALID_PER_ID);
        }
    }

    return ret;
}
  10d1dc:	4628      	mov	r0, r5
  10d1de:	bd38      	pop	{r3, r4, r5, r15}
    int ret = 0;
  10d1e0:	2500      	movs	r5, #0
}
  10d1e2:	4628      	mov	r0, r5
  10d1e4:	bd38      	pop	{r3, r4, r5, r15}
            ret |= res_clk_dec_refcount(clk->parents[clk->cur_parent_index],
  10d1e6:	2101      	movs	r1, #1
  10d1e8:	3310      	adds	r3, #16
  10d1ea:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
  10d1ee:	f7ff ffd3 	bl	10d198 <res_clk_dec_refcount>
  10d1f2:	4305      	orrs	r5, r0
}
  10d1f4:	4628      	mov	r0, r5
  10d1f6:	bd38      	pop	{r3, r4, r5, r15}

0010d1f8 <res_clk_inc_refcount>:
    if (per_id != INVALID_PER_ID) {
  10d1f8:	2901      	cmp	r1, #1
{
  10d1fa:	b5f0      	push	{r4, r5, r6, r7, r14}
  10d1fc:	4616      	mov	r6, r2
  10d1fe:	b083      	sub	sp, #12
  10d200:	4605      	mov	r5, r0
    if (per_id != INVALID_PER_ID) {
  10d202:	d119      	bne.n	10d238 <res_clk_inc_refcount+0x40>
    new_refcount = clk_get_refcount(clk, false);
  10d204:	2100      	movs	r1, #0
  10d206:	4628      	mov	r0, r5
  10d208:	f7ff fe2a 	bl	10ce60 <clk_get_refcount>
    if (new_refcount) {
  10d20c:	4604      	mov	r4, r0
  10d20e:	b180      	cbz	r0, 10d232 <res_clk_inc_refcount+0x3a>
        if (clk->cur_parent_index != -1) {
  10d210:	6bab      	ldr	r3, [r5, #56]	; 0x38
  10d212:	1c5a      	adds	r2, r3, #1
    int ret = 0;
  10d214:	bf08      	it	eq
  10d216:	2400      	moveq	r4, #0
        if (clk->cur_parent_index != -1) {
  10d218:	d132      	bne.n	10d280 <res_clk_inc_refcount+0x88>
        if (clk->is_enable) {
  10d21a:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
  10d21e:	b113      	cbz	r3, 10d226 <res_clk_inc_refcount+0x2e>
            is_enabled = clk->is_enable(clk);
  10d220:	4628      	mov	r0, r5
  10d222:	4798      	blx	r3
        if (!is_enabled && clk->enable) {
  10d224:	b928      	cbnz	r0, 10d232 <res_clk_inc_refcount+0x3a>
  10d226:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
  10d22a:	b113      	cbz	r3, 10d232 <res_clk_inc_refcount+0x3a>
            ret |= clk->enable(clk);
  10d22c:	4628      	mov	r0, r5
  10d22e:	4798      	blx	r3
  10d230:	4304      	orrs	r4, r0
}
  10d232:	4620      	mov	r0, r4
  10d234:	b003      	add	sp, #12
  10d236:	bdf0      	pop	{r4, r5, r6, r7, r15}
  10d238:	460c      	mov	r4, r1
        clk_clear_refcount_bit(clk, per_id, !freqcare);
  10d23a:	f082 0201 	eor.w	r2, r2, #1
  10d23e:	4677      	mov	r7, r14
  10d240:	f7ff ff72 	bl	10d128 <clk_clear_refcount_bit>
    int i = per_id / 32;
  10d244:	f104 031f 	add.w	r3, r4, #31
        ref = &clk->refcount[0];
  10d248:	f105 0030 	add.w	r0, r5, #48	; 0x30
    int i = per_id / 32;
  10d24c:	ea13 0324 	ands.w	r3, r3, r4, asr #32
  10d250:	bf38      	it	cc
  10d252:	4623      	movcc	r3, r4
  10d254:	115b      	asrs	r3, r3, #5
    if (freqcare) {
  10d256:	b90e      	cbnz	r6, 10d25c <res_clk_inc_refcount+0x64>
        ref = &clk->refcount_en[0];
  10d258:	f105 0034 	add.w	r0, r5, #52	; 0x34
    ASSERT(i < REFCNT_NUM);
  10d25c:	2b00      	cmp	r3, #0
  10d25e:	dc1c      	bgt.n	10d29a <res_clk_inc_refcount+0xa2>
    ref[i] |= 1 << (per_id % 32);
  10d260:	2101      	movs	r1, #1
  10d262:	4262      	negs	r2, r4
  10d264:	f002 021f 	and.w	r2, r2, #31
  10d268:	f004 041f 	and.w	r4, r4, #31
  10d26c:	bf58      	it	pl
  10d26e:	4254      	negpl	r4, r2
  10d270:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
  10d274:	fa01 f404 	lsl.w	r4, r1, r4
  10d278:	4322      	orrs	r2, r4
  10d27a:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
  10d27e:	e7c1      	b.n	10d204 <res_clk_inc_refcount+0xc>
            ret = res_clk_inc_refcount(clk->parents[clk->cur_parent_index],
  10d280:	4632      	mov	r2, r6
  10d282:	3310      	adds	r3, #16
  10d284:	2101      	movs	r1, #1
  10d286:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
  10d28a:	f7ff ffb5 	bl	10d1f8 <res_clk_inc_refcount>
        if (clk->is_enable) {
  10d28e:	f8d5 30d4 	ldr.w	r3, [r5, #212]	; 0xd4
            ret = res_clk_inc_refcount(clk->parents[clk->cur_parent_index],
  10d292:	4604      	mov	r4, r0
        if (clk->is_enable) {
  10d294:	2b00      	cmp	r3, #0
  10d296:	d1c3      	bne.n	10d220 <res_clk_inc_refcount+0x28>
  10d298:	e7c5      	b.n	10d226 <res_clk_inc_refcount+0x2e>
    ASSERT(i < REFCNT_NUM);
  10d29a:	f24c 6310 	movw	r3, #50704	; 0xc610
  10d29e:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d2a2:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d2a6:	f2c0 0311 	movt	r3, #17
  10d2aa:	4638      	mov	r0, r7
  10d2ac:	f2c0 0211 	movt	r2, #17
  10d2b0:	9300      	str	r3, [sp, #0]
  10d2b2:	f2c0 0111 	movt	r1, #17
  10d2b6:	f240 33a3 	movw	r3, #931	; 0x3a3
  10d2ba:	f006 fa6f 	bl	11379c <_panic>
  10d2be:	bf00      	nop

0010d2c0 <clk_is_enable>:
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d2c0:	6803      	ldr	r3, [r0, #0]
  10d2c2:	3b05      	subs	r3, #5
  10d2c4:	f5b3 7f85 	cmp.w	r3, #266	; 0x10a
  10d2c8:	d913      	bls.n	10d2f2 <clk_is_enable+0x32>
        ASSERT(0);
  10d2ca:	f649 0384 	movw	r3, #39044	; 0x9884
  10d2ce:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
{
  10d2d2:	b500      	push	{r14}
        ASSERT(0);
  10d2d4:	f2c0 0311 	movt	r3, #17
  10d2d8:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  10d2dc:	b083      	sub	sp, #12
  10d2de:	4670      	mov	r0, r14
        ASSERT(0);
  10d2e0:	f2c0 0211 	movt	r2, #17
  10d2e4:	9300      	str	r3, [sp, #0]
  10d2e6:	f2c0 0111 	movt	r1, #17
  10d2ea:	f44f 73f9 	mov.w	r3, #498	; 0x1f2
  10d2ee:	f006 fa55 	bl	11379c <_panic>
        return clk->enable_cnt > clk->disable_cnt;
  10d2f2:	e9d0 3033 	ldrd	r3, r0, [r0, #204]	; 0xcc
  10d2f6:	4283      	cmp	r3, r0
  10d2f8:	bfd4      	ite	le
  10d2fa:	2000      	movle	r0, #0
  10d2fc:	2001      	movgt	r0, #1
}
  10d2fe:	4770      	bx	r14

0010d300 <clk_set_depends_on>:
{
  10d300:	b570      	push	{r4, r5, r6, r14}
  10d302:	460d      	mov	r5, r1
  10d304:	b082      	sub	sp, #8
    return get_clk_by_id_internal(NULL, clkid);
  10d306:	4601      	mov	r1, r0
  10d308:	2000      	movs	r0, #0
  10d30a:	4676      	mov	r6, r14
  10d30c:	f7ff fd78 	bl	10ce00 <get_clk_by_id_internal>
  10d310:	4629      	mov	r1, r5
  10d312:	4604      	mov	r4, r0
  10d314:	2000      	movs	r0, #0
  10d316:	f7ff fd73 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk || !dp) {
  10d31a:	fab0 f380 	clz	r3, r0
  10d31e:	095b      	lsrs	r3, r3, #5
  10d320:	2c00      	cmp	r4, #0
  10d322:	bf08      	it	eq
  10d324:	2301      	moveq	r3, #1
  10d326:	b9cb      	cbnz	r3, 10d35c <clk_set_depends_on+0x5c>
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d328:	6822      	ldr	r2, [r4, #0]
  10d32a:	3a05      	subs	r2, #5
  10d32c:	2a65      	cmp	r2, #101	; 0x65
    clk->pll.dependson = dp;
  10d32e:	bf9c      	itt	ls
  10d330:	f8c4 0094 	strls.w	r0, [r4, #148]	; 0x94
    return 0;
  10d334:	4618      	movls	r0, r3
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d336:	d913      	bls.n	10d360 <clk_set_depends_on+0x60>
    ASSERT(is_pll(clk));
  10d338:	f24c 4368 	movw	r3, #50280	; 0xc468
  10d33c:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d340:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d344:	f2c0 0311 	movt	r3, #17
  10d348:	4630      	mov	r0, r6
  10d34a:	f2c0 0211 	movt	r2, #17
  10d34e:	9300      	str	r3, [sp, #0]
  10d350:	f2c0 0111 	movt	r1, #17
  10d354:	f44f 734c 	mov.w	r3, #816	; 0x330
  10d358:	f006 fa20 	bl	11379c <_panic>
        return -1;
  10d35c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10d360:	b002      	add	sp, #8
  10d362:	bd70      	pop	{r4, r5, r6, r15}

0010d364 <get_pll_rate.isra.20>:
static unsigned long get_pll_rate(struct clk *clk,
  10d364:	b5f0      	push	{r4, r5, r6, r7, r14}
  10d366:	4605      	mov	r5, r0
  10d368:	b08d      	sub	sp, #52	; 0x34
  10d36a:	460e      	mov	r6, r1
  10d36c:	4617      	mov	r7, r2
    pll_config_t conf = {0};
  10d36e:	2100      	movs	r1, #0
  10d370:	2230      	movs	r2, #48	; 0x30
  10d372:	4668      	mov	r0, r13
static unsigned long get_pll_rate(struct clk *clk,
  10d374:	461c      	mov	r4, r3
    pll_config_t conf = {0};
  10d376:	f006 eb1a 	blx	1139ac <memset>
    pll =  hal_pll_create_handle(clk->resid);
  10d37a:	4628      	mov	r0, r5
  10d37c:	f002 fba4 	bl	10fac8 <hal_pll_create_handle>
    if (pll == (pll_handle_t)0) {
  10d380:	4605      	mov	r5, r0
  10d382:	b918      	cbnz	r0, 10d38c <get_pll_rate.isra.20+0x28>
        return 0;
  10d384:	4604      	mov	r4, r0
}
  10d386:	4620      	mov	r0, r4
  10d388:	b00d      	add	sp, #52	; 0x34
  10d38a:	bdf0      	pop	{r4, r5, r6, r7, r15}
    hal_pll_get_config(pll, &conf);
  10d38c:	4669      	mov	r1, r13
  10d38e:	f002 fc0b 	bl	10fba8 <hal_pll_get_config>
    if (bymonitor) {
  10d392:	b94c      	cbnz	r4, 10d3a8 <get_pll_rate.isra.20+0x44>
        if (plldiv == PLL_DUMMY_ROOT) {
  10d394:	2e05      	cmp	r6, #5
  10d396:	d007      	beq.n	10d3a8 <get_pll_rate.isra.20+0x44>
        else if (plldiv == PLL_ROOT) {
  10d398:	b98e      	cbnz	r6, 10d3be <get_pll_rate.isra.20+0x5a>
            rate = prate / conf.postdiv[0] / conf.postdiv[1];
  10d39a:	e9dd 3205 	ldrd	r3, r2, [r13, #20]
  10d39e:	fbb7 f4f3 	udiv	r4, r7, r3
  10d3a2:	fbb4 f4f2 	udiv	r4, r4, r2
  10d3a6:	e004      	b.n	10d3b2 <get_pll_rate.isra.20+0x4e>
            rate = calculate_pll_rate(&conf, plldiv);
  10d3a8:	4631      	mov	r1, r6
  10d3aa:	4668      	mov	r0, r13
  10d3ac:	f7ff fcec 	bl	10cd88 <calculate_pll_rate>
  10d3b0:	4604      	mov	r4, r0
    hal_pll_delete_handle(pll);
  10d3b2:	4628      	mov	r0, r5
  10d3b4:	f002 fba8 	bl	10fb08 <hal_pll_delete_handle>
}
  10d3b8:	4620      	mov	r0, r4
  10d3ba:	b00d      	add	sp, #52	; 0x34
  10d3bc:	bdf0      	pop	{r4, r5, r6, r7, r15}
        else if (plldiv >= PLL_DIVA && plldiv <= PLL_DIVD) {
  10d3be:	1e73      	subs	r3, r6, #1
  10d3c0:	2b03      	cmp	r3, #3
  10d3c2:	d8f6      	bhi.n	10d3b2 <get_pll_rate.isra.20+0x4e>
            if (conf.out_div[plldiv - 1] != 0) {
  10d3c4:	ab0c      	add	r3, sp, #48	; 0x30
  10d3c6:	eb03 0686 	add.w	r6, r3, r6, lsl #2
  10d3ca:	f856 4c14 	ldr.w	r4, [r6, #-20]
  10d3ce:	2c00      	cmp	r4, #0
  10d3d0:	d0ef      	beq.n	10d3b2 <get_pll_rate.isra.20+0x4e>
                rate = prate / conf.out_div[plldiv - 1];
  10d3d2:	fbb7 f4f4 	udiv	r4, r7, r4
  10d3d6:	e7ec      	b.n	10d3b2 <get_pll_rate.isra.20+0x4e>

0010d3d8 <get_ckgen_core_ctl>:
{
  10d3d8:	b530      	push	{r4, r5, r14}
  10d3da:	4604      	mov	r4, r0
  10d3dc:	b083      	sub	sp, #12
  10d3de:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d3e0:	a801      	add	r0, sp, #4
  10d3e2:	f7fd f8a5 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d3e6:	b170      	cbz	r0, 10d406 <get_ckgen_core_ctl+0x2e>
    ret = hal_clock_corectl_get(g_handle, resid, ctl);
  10d3e8:	4621      	mov	r1, r4
  10d3ea:	462a      	mov	r2, r5
  10d3ec:	9801      	ldr	r0, [sp, #4]
  10d3ee:	f7fd fd8b 	bl	10af08 <hal_clock_corectl_get>
  10d3f2:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d3f4:	9801      	ldr	r0, [sp, #4]
  10d3f6:	f7fd f8b7 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d3fa:	f084 0001 	eor.w	r0, r4, #1
  10d3fe:	b2c0      	uxtb	r0, r0
  10d400:	4240      	negs	r0, r0
}
  10d402:	b003      	add	sp, #12
  10d404:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d406:	f24c 31c0 	movw	r1, #50112	; 0xc3c0
  10d40a:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d40e:	f2c0 0111 	movt	r1, #17
  10d412:	f2c0 0011 	movt	r0, #17
  10d416:	f007 f9f5 	bl	114804 <printf>
  10d41a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d41e:	e7f0      	b.n	10d402 <get_ckgen_core_ctl+0x2a>

0010d420 <set_ckgen_core_ctl>:
{
  10d420:	b530      	push	{r4, r5, r14}
  10d422:	4604      	mov	r4, r0
  10d424:	b083      	sub	sp, #12
  10d426:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d428:	a801      	add	r0, sp, #4
  10d42a:	f7fd f881 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d42e:	b170      	cbz	r0, 10d44e <set_ckgen_core_ctl+0x2e>
    ret = hal_clock_corectl_set(g_handle, resid, ctl);
  10d430:	4621      	mov	r1, r4
  10d432:	462a      	mov	r2, r5
  10d434:	9801      	ldr	r0, [sp, #4]
  10d436:	f7fd fd99 	bl	10af6c <hal_clock_corectl_set>
  10d43a:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d43c:	9801      	ldr	r0, [sp, #4]
  10d43e:	f7fd f893 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d442:	f084 0001 	eor.w	r0, r4, #1
  10d446:	b2c0      	uxtb	r0, r0
  10d448:	4240      	negs	r0, r0
}
  10d44a:	b003      	add	sp, #12
  10d44c:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d44e:	f24c 31d4 	movw	r1, #50132	; 0xc3d4
  10d452:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d456:	f2c0 0111 	movt	r1, #17
  10d45a:	f2c0 0011 	movt	r0, #17
  10d45e:	f007 f9d1 	bl	114804 <printf>
  10d462:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d466:	e7f0      	b.n	10d44a <set_ckgen_core_ctl+0x2a>

0010d468 <get_ckgen_ip_ctl>:
{
  10d468:	b530      	push	{r4, r5, r14}
  10d46a:	4604      	mov	r4, r0
  10d46c:	b083      	sub	sp, #12
  10d46e:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d470:	a801      	add	r0, sp, #4
  10d472:	f7fd f85d 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d476:	b170      	cbz	r0, 10d496 <get_ckgen_ip_ctl+0x2e>
    ret = hal_clock_ipctl_get(g_handle, resid, ctl);
  10d478:	4621      	mov	r1, r4
  10d47a:	462a      	mov	r2, r5
  10d47c:	9801      	ldr	r0, [sp, #4]
  10d47e:	f7fd fba5 	bl	10abcc <hal_clock_ipctl_get>
  10d482:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d484:	9801      	ldr	r0, [sp, #4]
  10d486:	f7fd f86f 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d48a:	f084 0001 	eor.w	r0, r4, #1
  10d48e:	b2c0      	uxtb	r0, r0
  10d490:	4240      	negs	r0, r0
}
  10d492:	b003      	add	sp, #12
  10d494:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d496:	f24c 31e8 	movw	r1, #50152	; 0xc3e8
  10d49a:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d49e:	f2c0 0111 	movt	r1, #17
  10d4a2:	f2c0 0011 	movt	r0, #17
  10d4a6:	f007 f9ad 	bl	114804 <printf>
  10d4aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d4ae:	e7f0      	b.n	10d492 <get_ckgen_ip_ctl+0x2a>

0010d4b0 <set_ckgen_ip_ctl>:
{
  10d4b0:	b530      	push	{r4, r5, r14}
  10d4b2:	4604      	mov	r4, r0
  10d4b4:	b083      	sub	sp, #12
  10d4b6:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d4b8:	a801      	add	r0, sp, #4
  10d4ba:	f7fd f839 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d4be:	b170      	cbz	r0, 10d4de <set_ckgen_ip_ctl+0x2e>
    ret = hal_clock_ipctl_set(g_handle, resid, ctl);
  10d4c0:	4621      	mov	r1, r4
  10d4c2:	462a      	mov	r2, r5
  10d4c4:	9801      	ldr	r0, [sp, #4]
  10d4c6:	f7fd fbb1 	bl	10ac2c <hal_clock_ipctl_set>
  10d4ca:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d4cc:	9801      	ldr	r0, [sp, #4]
  10d4ce:	f7fd f84b 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d4d2:	f084 0001 	eor.w	r0, r4, #1
  10d4d6:	b2c0      	uxtb	r0, r0
  10d4d8:	4240      	negs	r0, r0
}
  10d4da:	b003      	add	sp, #12
  10d4dc:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d4de:	f24c 31fc 	movw	r1, #50172	; 0xc3fc
  10d4e2:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d4e6:	f2c0 0111 	movt	r1, #17
  10d4ea:	f2c0 0011 	movt	r0, #17
  10d4ee:	f007 f989 	bl	114804 <printf>
  10d4f2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d4f6:	e7f0      	b.n	10d4da <set_ckgen_ip_ctl+0x2a>

0010d4f8 <clk_set_moreprecise.constprop.30>:
static int clk_set_moreprecise(unsigned long clkid, bool need,
  10d4f8:	b510      	push	{r4, r14}
    return get_clk_by_id_internal(NULL, clkid);
  10d4fa:	4601      	mov	r1, r0
static int clk_set_moreprecise(unsigned long clkid, bool need,
  10d4fc:	b082      	sub	sp, #8
    return get_clk_by_id_internal(NULL, clkid);
  10d4fe:	2000      	movs	r0, #0
  10d500:	4674      	mov	r4, r14
  10d502:	f7ff fc7d 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10d506:	b328      	cbz	r0, 10d554 <clk_set_moreprecise.constprop.30+0x5c>
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d508:	6802      	ldr	r2, [r0, #0]
  10d50a:	4603      	mov	r3, r0
  10d50c:	3a05      	subs	r2, #5
  10d50e:	2a65      	cmp	r2, #101	; 0x65
  10d510:	d80e      	bhi.n	10d530 <clk_set_moreprecise.constprop.30+0x38>
    ASSERT(is_pll(clk) && clk->pll.plldiv == PLL_DUMMY_ROOT);
  10d512:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
  10d516:	2a05      	cmp	r2, #5
  10d518:	d10a      	bne.n	10d530 <clk_set_moreprecise.constprop.30+0x38>
        clk->pll.config.frac = frac;
  10d51a:	2200      	movs	r2, #0
    clk->pll.moreprecise = need;
  10d51c:	2101      	movs	r1, #1
    return 0;
  10d51e:	4610      	mov	r0, r2
    clk->pll.moreprecise = need;
  10d520:	f883 1098 	strb.w	r1, [r3, #152]	; 0x98
            clk->pll.config.integer = true;
  10d524:	f883 10a0 	strb.w	r1, [r3, #160]	; 0xa0
        clk->pll.config.frac = frac;
  10d528:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
  10d52c:	b002      	add	sp, #8
  10d52e:	bd10      	pop	{r4, r15}
    ASSERT(is_pll(clk) && clk->pll.plldiv == PLL_DUMMY_ROOT);
  10d530:	f24c 4374 	movw	r3, #50292	; 0xc474
  10d534:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d538:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d53c:	f2c0 0311 	movt	r3, #17
  10d540:	4620      	mov	r0, r4
  10d542:	f2c0 0211 	movt	r2, #17
  10d546:	9300      	str	r3, [sp, #0]
  10d548:	f2c0 0111 	movt	r1, #17
  10d54c:	f240 333e 	movw	r3, #830	; 0x33e
  10d550:	f006 f924 	bl	11379c <_panic>
        return -1;
  10d554:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d558:	e7e8      	b.n	10d52c <clk_set_moreprecise.constprop.30+0x34>
  10d55a:	bf00      	nop

0010d55c <set_ckgen_bus_ctl.constprop.31>:
static int set_ckgen_bus_ctl(unsigned long resid,
  10d55c:	b530      	push	{r4, r5, r14}
  10d55e:	4604      	mov	r4, r0
  10d560:	b083      	sub	sp, #12
  10d562:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d564:	a801      	add	r0, sp, #4
  10d566:	f7fc ffe3 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d56a:	b178      	cbz	r0, 10d58c <set_ckgen_bus_ctl.constprop.31+0x30>
    ret = hal_clock_busctl_set(g_handle, resid, ctl, gasket);
  10d56c:	4621      	mov	r1, r4
  10d56e:	462a      	mov	r2, r5
  10d570:	9801      	ldr	r0, [sp, #4]
  10d572:	2300      	movs	r3, #0
  10d574:	f7fd fc0a 	bl	10ad8c <hal_clock_busctl_set>
  10d578:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d57a:	9801      	ldr	r0, [sp, #4]
  10d57c:	f7fc fff4 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d580:	f084 0001 	eor.w	r0, r4, #1
  10d584:	b2c0      	uxtb	r0, r0
  10d586:	4240      	negs	r0, r0
}
  10d588:	b003      	add	sp, #12
  10d58a:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d58c:	f24c 31ac 	movw	r1, #50092	; 0xc3ac
  10d590:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d594:	f2c0 0111 	movt	r1, #17
  10d598:	f2c0 0011 	movt	r0, #17
  10d59c:	f007 f932 	bl	114804 <printf>
  10d5a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d5a4:	e7f0      	b.n	10d588 <set_ckgen_bus_ctl.constprop.31+0x2c>
  10d5a6:	bf00      	nop

0010d5a8 <get_ckgen_bus_ctl.constprop.32>:
static int get_ckgen_bus_ctl(unsigned long resid, clkgen_bus_ctl *ctl,
  10d5a8:	b530      	push	{r4, r5, r14}
  10d5aa:	4604      	mov	r4, r0
  10d5ac:	b083      	sub	sp, #12
  10d5ae:	460d      	mov	r5, r1
    ret = hal_clock_creat_handle(&g_handle);
  10d5b0:	a801      	add	r0, sp, #4
  10d5b2:	f7fc ffbd 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10d5b6:	b178      	cbz	r0, 10d5d8 <get_ckgen_bus_ctl.constprop.32+0x30>
    ret = hal_clock_busctl_get(g_handle, resid, ctl, gasket);
  10d5b8:	4621      	mov	r1, r4
  10d5ba:	462a      	mov	r2, r5
  10d5bc:	9801      	ldr	r0, [sp, #4]
  10d5be:	2300      	movs	r3, #0
  10d5c0:	f7fd fbb0 	bl	10ad24 <hal_clock_busctl_get>
  10d5c4:	4604      	mov	r4, r0
    hal_clock_release_handle(g_handle);
  10d5c6:	9801      	ldr	r0, [sp, #4]
  10d5c8:	f7fc ffce 	bl	10a568 <hal_clock_release_handle>
    return ret ? 0 : -1;
  10d5cc:	f084 0001 	eor.w	r0, r4, #1
  10d5d0:	b2c0      	uxtb	r0, r0
  10d5d2:	4240      	negs	r0, r0
}
  10d5d4:	b003      	add	sp, #12
  10d5d6:	bd30      	pop	{r4, r5, r15}
        printf("do %s creat handle failed\n", __func__);
  10d5d8:	f24c 3198 	movw	r1, #50072	; 0xc398
  10d5dc:	f24c 6020 	movw	r0, #50720	; 0xc620
  10d5e0:	f2c0 0111 	movt	r1, #17
  10d5e4:	f2c0 0011 	movt	r0, #17
  10d5e8:	f007 f90c 	bl	114804 <printf>
  10d5ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d5f0:	e7f0      	b.n	10d5d4 <get_ckgen_bus_ctl.constprop.32+0x2c>
  10d5f2:	bf00      	nop

0010d5f4 <clk_is_hw_enable>:
    if (is_pll(clk)) {
  10d5f4:	6803      	ldr	r3, [r0, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d5f6:	1f5a      	subs	r2, r3, #5
  10d5f8:	2a65      	cmp	r2, #101	; 0x65
  10d5fa:	d91d      	bls.n	10d638 <clk_is_hw_enable+0x44>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10d5fc:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10d600:	2a06      	cmp	r2, #6
{
  10d602:	b500      	push	{r14}
  10d604:	b083      	sub	sp, #12
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10d606:	d91e      	bls.n	10d646 <clk_is_hw_enable+0x52>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10d608:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10d60c:	2a06      	cmp	r2, #6
  10d60e:	d93c      	bls.n	10d68a <clk_is_hw_enable+0x96>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10d610:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10d614:	2a54      	cmp	r2, #84	; 0x54
  10d616:	d927      	bls.n	10d668 <clk_is_hw_enable+0x74>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10d618:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10d61a:	2b41      	cmp	r3, #65	; 0x41
  10d61c:	d831      	bhi.n	10d682 <clk_is_hw_enable+0x8e>
        return get_ckgen_uuu_endis(clk->resid, clk->uuu.uuu_type);
  10d61e:	f8d0 1088 	ldr.w	r1, [r0, #136]	; 0x88
    if (uuu_type == UUU_SEL0
  10d622:	2901      	cmp	r1, #1
  10d624:	d92d      	bls.n	10d682 <clk_is_hw_enable+0x8e>
    unsigned long freq = get_ckgen_uuu_rate(resid, uuu_type, 0, true);
  10d626:	2301      	movs	r3, #1
  10d628:	2200      	movs	r2, #0
  10d62a:	6840      	ldr	r0, [r0, #4]
  10d62c:	f7ff fca6 	bl	10cf7c <get_ckgen_uuu_rate>
    if (freq) {
  10d630:	3000      	adds	r0, #0
  10d632:	bf18      	it	ne
  10d634:	2001      	movne	r0, #1
  10d636:	e014      	b.n	10d662 <clk_is_hw_enable+0x6e>
        return clk->enable_cnt > clk->disable_cnt;
  10d638:	e9d0 3033 	ldrd	r3, r0, [r0, #204]	; 0xcc
  10d63c:	4283      	cmp	r3, r0
  10d63e:	bfd4      	ite	le
  10d640:	2000      	movle	r0, #0
  10d642:	2001      	movgt	r0, #1
}
  10d644:	4770      	bx	r14
    if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10d646:	6840      	ldr	r0, [r0, #4]
  10d648:	a901      	add	r1, sp, #4
  10d64a:	f7ff ffad 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10d64e:	2800      	cmp	r0, #0
  10d650:	db21      	blt.n	10d696 <clk_is_hw_enable+0xa2>
    if (ctl.a_b_sel == 0) {
  10d652:	f89d 3005 	ldrb.w	r3, [r13, #5]
  10d656:	079b      	lsls	r3, r3, #30
  10d658:	d50c      	bpl.n	10d674 <clk_is_hw_enable+0x80>
        return ctl.cg_en_b == 1;
  10d65a:	f89d 0006 	ldrb.w	r0, [r13, #6]
  10d65e:	f000 0001 	and.w	r0, r0, #1
  10d662:	b003      	add	sp, #12
  10d664:	f85d fb04 	ldr.w	r15, [r13], #4
    if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10d668:	6840      	ldr	r0, [r0, #4]
  10d66a:	a901      	add	r1, sp, #4
  10d66c:	f7ff fefc 	bl	10d468 <get_ckgen_ip_ctl>
  10d670:	2800      	cmp	r0, #0
  10d672:	db10      	blt.n	10d696 <clk_is_hw_enable+0xa2>
    return ctl.cg_en == 1;
  10d674:	f89d 0004 	ldrb.w	r0, [r13, #4]
  10d678:	f000 0001 	and.w	r0, r0, #1
  10d67c:	b003      	add	sp, #12
  10d67e:	f85d fb04 	ldr.w	r15, [r13], #4
        return true;
  10d682:	2001      	movs	r0, #1
}
  10d684:	b003      	add	sp, #12
  10d686:	f85d fb04 	ldr.w	r15, [r13], #4
    if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10d68a:	6840      	ldr	r0, [r0, #4]
  10d68c:	a901      	add	r1, sp, #4
  10d68e:	f7ff fea3 	bl	10d3d8 <get_ckgen_core_ctl>
  10d692:	2800      	cmp	r0, #0
  10d694:	dadd      	bge.n	10d652 <clk_is_hw_enable+0x5e>
        return false;
  10d696:	2000      	movs	r0, #0
  10d698:	b003      	add	sp, #12
  10d69a:	f85d fb04 	ldr.w	r15, [r13], #4
  10d69e:	bf00      	nop

0010d6a0 <is_clk_can_access.part.27>:
    if (!clk->pll.dependson || clk_is_hw_enable(clk->pll.dependson)) {
  10d6a0:	f8d0 0094 	ldr.w	r0, [r0, #148]	; 0x94
  10d6a4:	b108      	cbz	r0, 10d6aa <is_clk_can_access.part.27+0xa>
  10d6a6:	f7ff bfa5 	b.w	10d5f4 <clk_is_hw_enable>
}
  10d6aa:	2001      	movs	r0, #1
  10d6ac:	4770      	bx	r14
  10d6ae:	bf00      	nop

0010d6b0 <clk_set_parent>:
    if (!is_pll(clk)) {
  10d6b0:	6803      	ldr	r3, [r0, #0]
{
  10d6b2:	b570      	push	{r4, r5, r6, r14}
  10d6b4:	4604      	mov	r4, r0
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d6b6:	1f5a      	subs	r2, r3, #5
  10d6b8:	2a65      	cmp	r2, #101	; 0x65
  10d6ba:	4676      	mov	r6, r14
{
  10d6bc:	b084      	sub	sp, #16
  10d6be:	460d      	mov	r5, r1
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d6c0:	d92c      	bls.n	10d71c <clk_set_parent+0x6c>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10d6c2:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10d6c6:	2a06      	cmp	r2, #6
  10d6c8:	d94a      	bls.n	10d760 <clk_set_parent+0xb0>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10d6ca:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10d6ce:	2a06      	cmp	r2, #6
  10d6d0:	d961      	bls.n	10d796 <clk_set_parent+0xe6>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10d6d2:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10d6d6:	2a54      	cmp	r2, #84	; 0x54
  10d6d8:	d97f      	bls.n	10d7da <clk_set_parent+0x12a>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10d6da:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10d6dc:	2b41      	cmp	r3, #65	; 0x41
  10d6de:	f200 8092 	bhi.w	10d806 <clk_set_parent+0x156>
        return set_ckgen_uuu_parent(clk->resid, clk->uuu.uuu_type, parent_index);
  10d6e2:	6866      	ldr	r6, [r4, #4]
                                int p_index)
{
    int ret = 0;
    clkgen_uuu_ctl ctl;

    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10d6e4:	a903      	add	r1, sp, #12
  10d6e6:	f8d4 4088 	ldr.w	r4, [r4, #136]	; 0x88
  10d6ea:	4630      	mov	r0, r6
  10d6ec:	f7ff fc06 	bl	10cefc <get_ckgen_uuu_ctl>
  10d6f0:	2800      	cmp	r0, #0
  10d6f2:	f2c0 8085 	blt.w	10d800 <clk_set_parent+0x150>
        return -1;
    }

    if (uuu_type == UUU_SEL0) {
  10d6f6:	2c00      	cmp	r4, #0
  10d6f8:	d068      	beq.n	10d7cc <clk_set_parent+0x11c>
        ctl.uuu_sel0 = p_index;
    }
    else if (uuu_type >= UUU_M
             && uuu_type <= UUU_Q) {//mnpq only have one parent.
  10d6fa:	3c02      	subs	r4, #2
    else if (uuu_type >= UUU_M
  10d6fc:	2c03      	cmp	r4, #3
        return 0;
  10d6fe:	bf98      	it	ls
  10d700:	2000      	movls	r0, #0
    else if (uuu_type >= UUU_M
  10d702:	d909      	bls.n	10d718 <clk_set_parent+0x68>
    }
    else {  // sel1
        ctl.uuu_sel1 = p_index;
  10d704:	f89d 300e 	ldrb.w	r3, [r13, #14]
  10d708:	f365 0341 	bfi	r3, r5, #1, #1
  10d70c:	f88d 300e 	strb.w	r3, [r13, #14]
    }

    ret |= set_ckgen_uuu_ctl(resid, &ctl);
  10d710:	4630      	mov	r0, r6
  10d712:	a903      	add	r1, sp, #12
  10d714:	f7ff fc12 	bl	10cf3c <set_ckgen_uuu_ctl>
}
  10d718:	b004      	add	sp, #16
  10d71a:	bd70      	pop	{r4, r5, r6, r15}
  10d71c:	f7ff ffc0 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10d720:	2800      	cmp	r0, #0
  10d722:	d0f9      	beq.n	10d718 <clk_set_parent+0x68>
    if (is_pll(clk)) {
  10d724:	6823      	ldr	r3, [r4, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d726:	1f5a      	subs	r2, r3, #5
  10d728:	2a65      	cmp	r2, #101	; 0x65
  10d72a:	d8ca      	bhi.n	10d6c2 <clk_set_parent+0x12>
        CLK_TRACE(CRITICAL, "pll %s no parent or fixed parent\n", clk->name);
  10d72c:	f24c 40a8 	movw	r0, #50344	; 0xc4a8
  10d730:	f104 0108 	add.w	r1, r4, #8
  10d734:	f2c0 0011 	movt	r0, #17
  10d738:	f007 f864 	bl	114804 <printf>
        ASSERT(0);
  10d73c:	f649 0384 	movw	r3, #39044	; 0x9884
  10d740:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d744:	f2c0 0311 	movt	r3, #17
  10d748:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d74c:	4630      	mov	r0, r6
  10d74e:	9300      	str	r3, [sp, #0]
  10d750:	f2c0 0211 	movt	r2, #17
  10d754:	f44f 7325 	mov.w	r3, #660	; 0x294
  10d758:	f2c0 0111 	movt	r1, #17
  10d75c:	f006 f81e 	bl	11379c <_panic>
        return set_ckgen_bus_parent(clk->resid, parent_index);
  10d760:	6864      	ldr	r4, [r4, #4]
    if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10d762:	a903      	add	r1, sp, #12
  10d764:	4620      	mov	r0, r4
  10d766:	f7ff ff1f 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10d76a:	2800      	cmp	r0, #0
  10d76c:	db48      	blt.n	10d800 <clk_set_parent+0x150>
    ctl.src_sel_a = ctl.src_sel_b = p_index;
  10d76e:	f005 0507 	and.w	r5, r5, #7
  10d772:	f89d 200e 	ldrb.w	r2, [r13, #14]
  10d776:	f89d 300c 	ldrb.w	r3, [r13, #12]
  10d77a:	f365 0243 	bfi	r2, r5, #1, #3
  10d77e:	f365 0343 	bfi	r3, r5, #1, #3
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10d782:	4620      	mov	r0, r4
  10d784:	a903      	add	r1, sp, #12
    ctl.src_sel_a = ctl.src_sel_b = p_index;
  10d786:	f88d 200e 	strb.w	r2, [r13, #14]
  10d78a:	f88d 300c 	strb.w	r3, [r13, #12]
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10d78e:	f7ff fee5 	bl	10d55c <set_ckgen_bus_ctl.constprop.31>
}
  10d792:	b004      	add	sp, #16
  10d794:	bd70      	pop	{r4, r5, r6, r15}
        return set_ckgen_core_parent(clk->resid, parent_index);
  10d796:	6864      	ldr	r4, [r4, #4]
    if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10d798:	a903      	add	r1, sp, #12
  10d79a:	4620      	mov	r0, r4
  10d79c:	f7ff fe1c 	bl	10d3d8 <get_ckgen_core_ctl>
  10d7a0:	2800      	cmp	r0, #0
  10d7a2:	db2d      	blt.n	10d800 <clk_set_parent+0x150>
    ctl.src_sel_a = ctl.src_sel_b = p_index;
  10d7a4:	f005 0507 	and.w	r5, r5, #7
  10d7a8:	f89d 200e 	ldrb.w	r2, [r13, #14]
  10d7ac:	f89d 300c 	ldrb.w	r3, [r13, #12]
  10d7b0:	f365 0243 	bfi	r2, r5, #1, #3
  10d7b4:	f365 0343 	bfi	r3, r5, #1, #3
    ret |= set_ckgen_core_ctl(resid, &ctl);
  10d7b8:	4620      	mov	r0, r4
  10d7ba:	a903      	add	r1, sp, #12
    ctl.src_sel_a = ctl.src_sel_b = p_index;
  10d7bc:	f88d 200e 	strb.w	r2, [r13, #14]
  10d7c0:	f88d 300c 	strb.w	r3, [r13, #12]
    ret |= set_ckgen_core_ctl(resid, &ctl);
  10d7c4:	f7ff fe2c 	bl	10d420 <set_ckgen_core_ctl>
}
  10d7c8:	b004      	add	sp, #16
  10d7ca:	bd70      	pop	{r4, r5, r6, r15}
        ctl.uuu_sel0 = p_index;
  10d7cc:	f89d 300e 	ldrb.w	r3, [r13, #14]
  10d7d0:	f365 0300 	bfi	r3, r5, #0, #1
  10d7d4:	f88d 300e 	strb.w	r3, [r13, #14]
  10d7d8:	e79a      	b.n	10d710 <clk_set_parent+0x60>
        return set_ckgen_ip_parent(clk->resid, parent_index);
  10d7da:	6864      	ldr	r4, [r4, #4]
    if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10d7dc:	a903      	add	r1, sp, #12
  10d7de:	4620      	mov	r0, r4
  10d7e0:	f7ff fe42 	bl	10d468 <get_ckgen_ip_ctl>
  10d7e4:	2800      	cmp	r0, #0
  10d7e6:	db0b      	blt.n	10d800 <clk_set_parent+0x150>
    ctl.src_sel = p_index;
  10d7e8:	f89d 300c 	ldrb.w	r3, [r13, #12]
  10d7ec:	f365 0343 	bfi	r3, r5, #1, #3
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10d7f0:	4620      	mov	r0, r4
  10d7f2:	a903      	add	r1, sp, #12
    ctl.src_sel = p_index;
  10d7f4:	f88d 300c 	strb.w	r3, [r13, #12]
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10d7f8:	f7ff fe5a 	bl	10d4b0 <set_ckgen_ip_ctl>
}
  10d7fc:	b004      	add	sp, #16
  10d7fe:	bd70      	pop	{r4, r5, r6, r15}
        return -1;
  10d800:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10d804:	e788      	b.n	10d718 <clk_set_parent+0x68>
        ASSERT(0);
  10d806:	f649 0384 	movw	r3, #39044	; 0x9884
  10d80a:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d80e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d812:	f2c0 0311 	movt	r3, #17
  10d816:	4630      	mov	r0, r6
  10d818:	f2c0 0211 	movt	r2, #17
  10d81c:	9300      	str	r3, [sp, #0]
  10d81e:	f2c0 0111 	movt	r1, #17
  10d822:	f240 23a5 	movw	r3, #677	; 0x2a5
  10d826:	f005 ffb9 	bl	11379c <_panic>
  10d82a:	bf00      	nop

0010d82c <clk_get_rate>:
{
  10d82c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10d830:	460c      	mov	r4, r1
  10d832:	b084      	sub	sp, #16
    if (!is_pll(clk)) {
  10d834:	6801      	ldr	r1, [r0, #0]
{
  10d836:	4605      	mov	r5, r0
  10d838:	46f0      	mov	r8, r14
  10d83a:	4617      	mov	r7, r2
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d83c:	1f4e      	subs	r6, r1, #5
  10d83e:	2e65      	cmp	r6, #101	; 0x65
  10d840:	d91b      	bls.n	10d87a <clk_get_rate+0x4e>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10d842:	f1a1 036b 	sub.w	r3, r1, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10d846:	2b06      	cmp	r3, #6
  10d848:	d92d      	bls.n	10d8a6 <clk_get_rate+0x7a>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10d84a:	f1a1 0372 	sub.w	r3, r1, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10d84e:	2b06      	cmp	r3, #6
  10d850:	d963      	bls.n	10d91a <clk_get_rate+0xee>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10d852:	f1a1 0379 	sub.w	r3, r1, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10d856:	2b54      	cmp	r3, #84	; 0x54
  10d858:	d946      	bls.n	10d8e8 <clk_get_rate+0xbc>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10d85a:	39ce      	subs	r1, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10d85c:	2941      	cmp	r1, #65	; 0x41
  10d85e:	f200 80b9 	bhi.w	10d9d4 <clk_get_rate+0x1a8>
        return get_ckgen_uuu_rate(clk->resid, clk->uuu.uuu_type, prate, bymonitor);
  10d862:	4622      	mov	r2, r4
  10d864:	463b      	mov	r3, r7
  10d866:	f8d5 1088 	ldr.w	r1, [r5, #136]	; 0x88
  10d86a:	6868      	ldr	r0, [r5, #4]
  10d86c:	f7ff fb86 	bl	10cf7c <get_ckgen_uuu_rate>
  10d870:	4604      	mov	r4, r0
}
  10d872:	4620      	mov	r0, r4
  10d874:	b004      	add	sp, #16
  10d876:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  10d87a:	f7ff ff11 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10d87e:	b370      	cbz	r0, 10d8de <clk_get_rate+0xb2>
    if (is_pll(clk)) {
  10d880:	6829      	ldr	r1, [r5, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d882:	1f4b      	subs	r3, r1, #5
  10d884:	2b65      	cmp	r3, #101	; 0x65
  10d886:	d8dc      	bhi.n	10d842 <clk_get_rate+0x16>
        rate = get_pll_rate(clk, prate, bymonitor);
  10d888:	4622      	mov	r2, r4
  10d88a:	463b      	mov	r3, r7
  10d88c:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
  10d890:	6868      	ldr	r0, [r5, #4]
  10d892:	f7ff fd67 	bl	10d364 <get_pll_rate.isra.20>
        if (rate == 0) { //may be not belong this domain, so return fake rate
  10d896:	4604      	mov	r4, r0
  10d898:	2800      	cmp	r0, #0
  10d89a:	d1ea      	bne.n	10d872 <clk_get_rate+0x46>
            rate = clk->rate;
  10d89c:	6f2c      	ldr	r4, [r5, #112]	; 0x70
}
  10d89e:	4620      	mov	r0, r4
  10d8a0:	b004      	add	sp, #16
  10d8a2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return get_ckgen_bus_rate(clk->resid, prate, bymonitor);
  10d8a6:	686d      	ldr	r5, [r5, #4]
    if (bymonitor) {
  10d8a8:	2f00      	cmp	r7, #0
  10d8aa:	d045      	beq.n	10d938 <clk_get_rate+0x10c>
        ret = hal_clock_creat_handle(&g_handle);
  10d8ac:	a803      	add	r0, sp, #12
  10d8ae:	f7fc fe3f 	bl	10a530 <hal_clock_creat_handle>
        if (!ret) {
  10d8b2:	4604      	mov	r4, r0
  10d8b4:	2800      	cmp	r0, #0
  10d8b6:	d038      	beq.n	10d92a <clk_get_rate+0xfe>
        rate = hal_clock_busclk_get(g_handle, resid,
  10d8b8:	2300      	movs	r3, #0
  10d8ba:	4629      	mov	r1, r5
  10d8bc:	9803      	ldr	r0, [sp, #12]
  10d8be:	461a      	mov	r2, r3
  10d8c0:	f7fd f9e4 	bl	10ac8c <hal_clock_busclk_get>
        if (rate == 0) //maybe it's too slow, need monitor with 32k
  10d8c4:	4604      	mov	r4, r0
  10d8c6:	b930      	cbnz	r0, 10d8d6 <clk_get_rate+0xaa>
            rate = hal_clock_busclk_get(g_handle, resid,
  10d8c8:	4603      	mov	r3, r0
  10d8ca:	4629      	mov	r1, r5
  10d8cc:	9803      	ldr	r0, [sp, #12]
  10d8ce:	2201      	movs	r2, #1
  10d8d0:	f7fd f9dc 	bl	10ac8c <hal_clock_busclk_get>
  10d8d4:	4604      	mov	r4, r0
        hal_clock_release_handle(g_handle);
  10d8d6:	9803      	ldr	r0, [sp, #12]
  10d8d8:	f7fc fe46 	bl	10a568 <hal_clock_release_handle>
  10d8dc:	e7c9      	b.n	10d872 <clk_get_rate+0x46>
        return 0;
  10d8de:	4604      	mov	r4, r0
}
  10d8e0:	4620      	mov	r0, r4
  10d8e2:	b004      	add	sp, #16
  10d8e4:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return get_ckgen_ip_rate(clk->resid, prate, bymonitor);
  10d8e8:	686d      	ldr	r5, [r5, #4]
    if (bymonitor) {
  10d8ea:	2f00      	cmp	r7, #0
  10d8ec:	d04a      	beq.n	10d984 <clk_get_rate+0x158>
        ret = hal_clock_creat_handle(&g_handle);
  10d8ee:	a803      	add	r0, sp, #12
  10d8f0:	f7fc fe1e 	bl	10a530 <hal_clock_creat_handle>
        if (!ret) {
  10d8f4:	4604      	mov	r4, r0
  10d8f6:	b1c0      	cbz	r0, 10d92a <clk_get_rate+0xfe>
        rate = hal_clock_ipclk_get(g_handle, resid,
  10d8f8:	2300      	movs	r3, #0
  10d8fa:	4629      	mov	r1, r5
  10d8fc:	9803      	ldr	r0, [sp, #12]
  10d8fe:	461a      	mov	r2, r3
  10d900:	f7fd f91a 	bl	10ab38 <hal_clock_ipclk_get>
        if (rate == 0) //maybe it's too slow, try monitor with 32k
  10d904:	4604      	mov	r4, r0
  10d906:	2800      	cmp	r0, #0
  10d908:	d1e5      	bne.n	10d8d6 <clk_get_rate+0xaa>
            rate = hal_clock_ipclk_get(g_handle, resid,
  10d90a:	4603      	mov	r3, r0
  10d90c:	4629      	mov	r1, r5
  10d90e:	9803      	ldr	r0, [sp, #12]
  10d910:	2201      	movs	r2, #1
  10d912:	f7fd f911 	bl	10ab38 <hal_clock_ipclk_get>
  10d916:	4604      	mov	r4, r0
  10d918:	e7dd      	b.n	10d8d6 <clk_get_rate+0xaa>
        return get_ckgen_core_rate(clk->resid, prate, bymonitor);
  10d91a:	686d      	ldr	r5, [r5, #4]
    if (bymonitor) {
  10d91c:	b33f      	cbz	r7, 10d96e <clk_get_rate+0x142>
        ret = hal_clock_creat_handle(&g_handle);
  10d91e:	a803      	add	r0, sp, #12
  10d920:	f7fc fe06 	bl	10a530 <hal_clock_creat_handle>
        if (!ret) {
  10d924:	4604      	mov	r4, r0
  10d926:	2800      	cmp	r0, #0
  10d928:	d140      	bne.n	10d9ac <clk_get_rate+0x180>
            printf("do get_ckgen_bus_rate creat handle failed\n");
  10d92a:	f24c 403c 	movw	r0, #50236	; 0xc43c
  10d92e:	f2c0 0011 	movt	r0, #17
  10d932:	f006 ff4f 	bl	1147d4 <puts>
  10d936:	e79c      	b.n	10d872 <clk_get_rate+0x46>
        if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10d938:	4628      	mov	r0, r5
  10d93a:	a903      	add	r1, sp, #12
  10d93c:	f7ff fe34 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10d940:	2800      	cmp	r0, #0
  10d942:	db44      	blt.n	10d9ce <clk_get_rate+0x1a2>
  10d944:	f89d 200d 	ldrb.w	r2, [r13, #13]
  10d948:	0893      	lsrs	r3, r2, #2
        if (ctl.a_b_sel == 0) { //A PATH
  10d94a:	0792      	lsls	r2, r2, #30
            div = (ctl.pre_div_num_a + 1) * (ctl.post_div_num + 1);
  10d94c:	bf54      	ite	pl
  10d94e:	f89d 200c 	ldrbpl.w	r2, [r13, #12]
            div = (ctl.pre_div_num_b + 1) * (ctl.post_div_num + 1);
  10d952:	f89d 200e 	ldrbmi.w	r2, [r13, #14]
  10d956:	f3c2 1202 	ubfx	r2, r2, #4, #3
  10d95a:	3301      	adds	r3, #1
  10d95c:	3201      	adds	r2, #1
  10d95e:	fb03 f302 	mul.w	r3, r3, r2
        rate = prate / div;
  10d962:	fbb4 f4f3 	udiv	r4, r4, r3
}
  10d966:	4620      	mov	r0, r4
  10d968:	b004      	add	sp, #16
  10d96a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10d96e:	4628      	mov	r0, r5
  10d970:	a903      	add	r1, sp, #12
  10d972:	f7ff fd31 	bl	10d3d8 <get_ckgen_core_ctl>
  10d976:	2800      	cmp	r0, #0
  10d978:	db29      	blt.n	10d9ce <clk_get_rate+0x1a2>
        div = ctl.post_div_num + 1;
  10d97a:	f89d 300d 	ldrb.w	r3, [r13, #13]
  10d97e:	089b      	lsrs	r3, r3, #2
  10d980:	3301      	adds	r3, #1
  10d982:	e7ee      	b.n	10d962 <clk_get_rate+0x136>
        if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10d984:	4628      	mov	r0, r5
  10d986:	a903      	add	r1, sp, #12
  10d988:	f7ff fd6e 	bl	10d468 <get_ckgen_ip_ctl>
  10d98c:	2800      	cmp	r0, #0
  10d98e:	db1e      	blt.n	10d9ce <clk_get_rate+0x1a2>
        div = (ctl.pre_div_num + 1) * (ctl.post_div_num + 1);
  10d990:	f89d 200c 	ldrb.w	r2, [r13, #12]
  10d994:	f89d 300d 	ldrb.w	r3, [r13, #13]
  10d998:	f3c2 1202 	ubfx	r2, r2, #4, #3
  10d99c:	089b      	lsrs	r3, r3, #2
  10d99e:	3201      	adds	r2, #1
  10d9a0:	3301      	adds	r3, #1
  10d9a2:	fb03 f302 	mul.w	r3, r3, r2
        rate = prate / div;
  10d9a6:	fbb4 f4f3 	udiv	r4, r4, r3
  10d9aa:	e762      	b.n	10d872 <clk_get_rate+0x46>
        rate = hal_clock_coreclk_get(g_handle, resid,
  10d9ac:	2300      	movs	r3, #0
  10d9ae:	4629      	mov	r1, r5
  10d9b0:	9803      	ldr	r0, [sp, #12]
  10d9b2:	461a      	mov	r2, r3
  10d9b4:	f7fd fa5c 	bl	10ae70 <hal_clock_coreclk_get>
        if (rate == 0) //maybe it's too slow, need monitor with 32k
  10d9b8:	4604      	mov	r4, r0
  10d9ba:	2800      	cmp	r0, #0
  10d9bc:	d18b      	bne.n	10d8d6 <clk_get_rate+0xaa>
            rate = hal_clock_coreclk_get(g_handle, resid,
  10d9be:	4603      	mov	r3, r0
  10d9c0:	4629      	mov	r1, r5
  10d9c2:	9803      	ldr	r0, [sp, #12]
  10d9c4:	2201      	movs	r2, #1
  10d9c6:	f7fd fa53 	bl	10ae70 <hal_clock_coreclk_get>
  10d9ca:	4604      	mov	r4, r0
  10d9cc:	e783      	b.n	10d8d6 <clk_get_rate+0xaa>
            return -1;
  10d9ce:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  10d9d2:	e74e      	b.n	10d872 <clk_get_rate+0x46>
        ASSERT(0);
  10d9d4:	f649 0384 	movw	r3, #39044	; 0x9884
  10d9d8:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10d9dc:	f647 4134 	movw	r1, #31796	; 0x7c34
  10d9e0:	f2c0 0311 	movt	r3, #17
  10d9e4:	4640      	mov	r0, r8
  10d9e6:	f2c0 0211 	movt	r2, #17
  10d9ea:	9300      	str	r3, [sp, #0]
  10d9ec:	f2c0 0111 	movt	r1, #17
  10d9f0:	f240 2366 	movw	r3, #614	; 0x266
  10d9f4:	f005 fed2 	bl	11379c <_panic>

0010d9f8 <clk_endis>:
    if (!is_pll(clk)) {
  10d9f8:	6803      	ldr	r3, [r0, #0]
{
  10d9fa:	b5f0      	push	{r4, r5, r6, r7, r14}
  10d9fc:	4604      	mov	r4, r0
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10d9fe:	1f5a      	subs	r2, r3, #5
  10da00:	2a65      	cmp	r2, #101	; 0x65
  10da02:	4676      	mov	r6, r14
{
  10da04:	b085      	sub	sp, #20
  10da06:	460d      	mov	r5, r1
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10da08:	d94a      	bls.n	10daa0 <clk_endis+0xa8>
    if (clk->clkid >= CLK_ID_CKGEN_FIRST && clk->clkid <= CLK_ID_CKGEN_LAST) {
  10da0a:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
  10da0e:	2aa4      	cmp	r2, #164	; 0xa4
  10da10:	d829      	bhi.n	10da66 <clk_endis+0x6e>
    if (is_ckgen_clk(clk) && (clk->gate_resid != 0)) {
  10da12:	6fe7      	ldr	r7, [r4, #124]	; 0x7c
  10da14:	2f00      	cmp	r7, #0
  10da16:	d177      	bne.n	10db08 <clk_endis+0x110>
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10da18:	2a06      	cmp	r2, #6
  10da1a:	d824      	bhi.n	10da66 <clk_endis+0x6e>
        ret = set_ckgen_bus_endis(clk->resid, isenable);
  10da1c:	6867      	ldr	r7, [r4, #4]
    if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10da1e:	ae03      	add	r6, sp, #12
  10da20:	4638      	mov	r0, r7
  10da22:	4631      	mov	r1, r6
  10da24:	f7ff fdc0 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10da28:	2800      	cmp	r0, #0
  10da2a:	f2c0 80bb 	blt.w	10dba4 <clk_endis+0x1ac>
        ctl.cg_en_a = ctl.cg_en_b = 0;
  10da2e:	f89d 200e 	ldrb.w	r2, [r13, #14]
    if (!enable) {
  10da32:	2d00      	cmp	r5, #0
  10da34:	d17a      	bne.n	10db2c <clk_endis+0x134>
        ctl.cg_en_a = ctl.cg_en_b = 0;
  10da36:	f89d 300c 	ldrb.w	r3, [r13, #12]
  10da3a:	f365 0200 	bfi	r2, r5, #0, #1
  10da3e:	f365 0300 	bfi	r3, r5, #0, #1
  10da42:	f88d 200e 	strb.w	r2, [r13, #14]
  10da46:	f88d 300c 	strb.w	r3, [r13, #12]
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10da4a:	4631      	mov	r1, r6
  10da4c:	4638      	mov	r0, r7
  10da4e:	f7ff fd85 	bl	10d55c <set_ckgen_bus_ctl.constprop.31>
    if (!ret) {
  10da52:	b930      	cbnz	r0, 10da62 <clk_endis+0x6a>
        isenable ? clk->enable_cnt++ : clk->disable_cnt++;
  10da54:	bb75      	cbnz	r5, 10dab4 <clk_endis+0xbc>
  10da56:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
  10da5a:	4628      	mov	r0, r5
  10da5c:	3301      	adds	r3, #1
  10da5e:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
}
  10da62:	b005      	add	sp, #20
  10da64:	bdf0      	pop	{r4, r5, r6, r7, r15}
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10da66:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10da6a:	2a06      	cmp	r2, #6
  10da6c:	d92a      	bls.n	10dac4 <clk_endis+0xcc>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10da6e:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10da72:	2a54      	cmp	r2, #84	; 0x54
  10da74:	d965      	bls.n	10db42 <clk_endis+0x14a>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10da76:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10da78:	2b41      	cmp	r3, #65	; 0x41
  10da7a:	d9eb      	bls.n	10da54 <clk_endis+0x5c>
        ASSERT(0);
  10da7c:	f649 0384 	movw	r3, #39044	; 0x9884
  10da80:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10da84:	f647 4134 	movw	r1, #31796	; 0x7c34
  10da88:	f2c0 0311 	movt	r3, #17
  10da8c:	4630      	mov	r0, r6
  10da8e:	f2c0 0211 	movt	r2, #17
  10da92:	9300      	str	r3, [sp, #0]
  10da94:	f2c0 0111 	movt	r1, #17
  10da98:	f240 2316 	movw	r3, #534	; 0x216
  10da9c:	f005 fe7e 	bl	11379c <_panic>
  10daa0:	f7ff fdfe 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10daa4:	2800      	cmp	r0, #0
  10daa6:	d0dc      	beq.n	10da62 <clk_endis+0x6a>
    if (is_pll(clk)) {
  10daa8:	6823      	ldr	r3, [r4, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10daaa:	1f5a      	subs	r2, r3, #5
  10daac:	2a65      	cmp	r2, #101	; 0x65
  10daae:	d8ac      	bhi.n	10da0a <clk_endis+0x12>
        isenable ? clk->enable_cnt++ : clk->disable_cnt++;
  10dab0:	2d00      	cmp	r5, #0
  10dab2:	d0d0      	beq.n	10da56 <clk_endis+0x5e>
  10dab4:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
  10dab8:	2000      	movs	r0, #0
  10daba:	3301      	adds	r3, #1
  10dabc:	f8c4 30cc 	str.w	r3, [r4, #204]	; 0xcc
}
  10dac0:	b005      	add	sp, #20
  10dac2:	bdf0      	pop	{r4, r5, r6, r7, r15}
        ret = set_ckgen_core_endis(clk->resid, isenable);
  10dac4:	6867      	ldr	r7, [r4, #4]
    if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10dac6:	ae03      	add	r6, sp, #12
  10dac8:	4638      	mov	r0, r7
  10daca:	4631      	mov	r1, r6
  10dacc:	f7ff fc84 	bl	10d3d8 <get_ckgen_core_ctl>
  10dad0:	2800      	cmp	r0, #0
  10dad2:	db67      	blt.n	10dba4 <clk_endis+0x1ac>
    if (!enable) {
  10dad4:	2d00      	cmp	r5, #0
  10dad6:	d04b      	beq.n	10db70 <clk_endis+0x178>
        if (ctl.a_b_sel == 0) {
  10dad8:	f89d 300d 	ldrb.w	r3, [r13, #13]
  10dadc:	079b      	lsls	r3, r3, #30
            ctl.cg_en_a = 1;
  10dade:	bf55      	itete	pl
  10dae0:	f89d 300c 	ldrbpl.w	r3, [r13, #12]
            ctl.cg_en_b = 1;
  10dae4:	f89d 300e 	ldrbmi.w	r3, [r13, #14]
            ctl.cg_en_a = 1;
  10dae8:	f043 0301 	orrpl.w	r3, r3, #1
            ctl.cg_en_b = 1;
  10daec:	f043 0301 	orrmi.w	r3, r3, #1
            ctl.cg_en_a = 1;
  10daf0:	bf54      	ite	pl
  10daf2:	f88d 300c 	strbpl.w	r3, [r13, #12]
            ctl.cg_en_b = 1;
  10daf6:	f88d 300e 	strbmi.w	r3, [r13, #14]
    ret |= set_ckgen_core_ctl(resid, &ctl);
  10dafa:	4631      	mov	r1, r6
  10dafc:	4638      	mov	r0, r7
  10dafe:	f7ff fc8f 	bl	10d420 <set_ckgen_core_ctl>
    if (!ret) {
  10db02:	2800      	cmp	r0, #0
  10db04:	d0a6      	beq.n	10da54 <clk_endis+0x5c>
  10db06:	e7ac      	b.n	10da62 <clk_endis+0x6a>
    ret = hal_clock_creat_handle(&g_handle);
  10db08:	a803      	add	r0, sp, #12
  10db0a:	f7fc fd11 	bl	10a530 <hal_clock_creat_handle>
    if (!ret) {
  10db0e:	2800      	cmp	r0, #0
  10db10:	d04b      	beq.n	10dbaa <clk_endis+0x1b2>
  10db12:	9803      	ldr	r0, [sp, #12]
    result = enable ? hal_clock_enable(g_handle,
  10db14:	4639      	mov	r1, r7
                                       resid) : hal_clock_disable(g_handle, resid);
  10db16:	bbc5      	cbnz	r5, 10db8a <clk_endis+0x192>
  10db18:	f7fc ffda 	bl	10aad0 <hal_clock_disable>
  10db1c:	9b03      	ldr	r3, [sp, #12]
    if (!result) {
  10db1e:	bbe0      	cbnz	r0, 10db9a <clk_endis+0x1a2>
    hal_clock_release_handle(g_handle);
  10db20:	4618      	mov	r0, r3
  10db22:	f7fc fd21 	bl	10a568 <hal_clock_release_handle>
        ret = -1;
  10db26:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10db2a:	e79a      	b.n	10da62 <clk_endis+0x6a>
        ctl.cg_en_a = ctl.cg_en_b = 1;
  10db2c:	f89d 300c 	ldrb.w	r3, [r13, #12]
  10db30:	f042 0201 	orr.w	r2, r2, #1
  10db34:	f043 0301 	orr.w	r3, r3, #1
  10db38:	f88d 200e 	strb.w	r2, [r13, #14]
  10db3c:	f88d 300c 	strb.w	r3, [r13, #12]
  10db40:	e783      	b.n	10da4a <clk_endis+0x52>
        ret = set_ckgen_ip_endis(clk->resid, isenable);
  10db42:	6867      	ldr	r7, [r4, #4]
    if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10db44:	ae03      	add	r6, sp, #12
  10db46:	4638      	mov	r0, r7
  10db48:	4631      	mov	r1, r6
  10db4a:	f7ff fc8d 	bl	10d468 <get_ckgen_ip_ctl>
  10db4e:	2800      	cmp	r0, #0
  10db50:	db28      	blt.n	10dba4 <clk_endis+0x1ac>
        ctl.cg_en = 0;
  10db52:	f89d 300c 	ldrb.w	r3, [r13, #12]
    if (!enable) {
  10db56:	b1dd      	cbz	r5, 10db90 <clk_endis+0x198>
        ctl.cg_en = 1;
  10db58:	f043 0301 	orr.w	r3, r3, #1
  10db5c:	f88d 300c 	strb.w	r3, [r13, #12]
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10db60:	4631      	mov	r1, r6
  10db62:	4638      	mov	r0, r7
  10db64:	f7ff fca4 	bl	10d4b0 <set_ckgen_ip_ctl>
    if (!ret) {
  10db68:	2800      	cmp	r0, #0
  10db6a:	f43f af73 	beq.w	10da54 <clk_endis+0x5c>
  10db6e:	e778      	b.n	10da62 <clk_endis+0x6a>
        ctl.cg_en_a = 0;
  10db70:	f89d 200c 	ldrb.w	r2, [r13, #12]
        ctl.cg_en_b = 0;
  10db74:	f89d 300e 	ldrb.w	r3, [r13, #14]
        ctl.cg_en_a = 0;
  10db78:	f365 0200 	bfi	r2, r5, #0, #1
        ctl.cg_en_b = 0;
  10db7c:	f365 0300 	bfi	r3, r5, #0, #1
        ctl.cg_en_a = 0;
  10db80:	f88d 200c 	strb.w	r2, [r13, #12]
        ctl.cg_en_b = 0;
  10db84:	f88d 300e 	strb.w	r3, [r13, #14]
  10db88:	e7b7      	b.n	10dafa <clk_endis+0x102>
    result = enable ? hal_clock_enable(g_handle,
  10db8a:	f7fc ff6d 	bl	10aa68 <hal_clock_enable>
  10db8e:	e7c5      	b.n	10db1c <clk_endis+0x124>
        ctl.cg_en = 0;
  10db90:	f365 0300 	bfi	r3, r5, #0, #1
  10db94:	f88d 300c 	strb.w	r3, [r13, #12]
  10db98:	e7e2      	b.n	10db60 <clk_endis+0x168>
    hal_clock_release_handle(g_handle);
  10db9a:	4618      	mov	r0, r3
  10db9c:	f7fc fce4 	bl	10a568 <hal_clock_release_handle>
    ret = hal_clock_creat_handle(&g_handle);
  10dba0:	2001      	movs	r0, #1
  10dba2:	e75e      	b.n	10da62 <clk_endis+0x6a>
        return -1;
  10dba4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10dba8:	e75b      	b.n	10da62 <clk_endis+0x6a>
        printf("do set_ckgen_gate_endis creat handle failed\n");
  10dbaa:	f24c 4010 	movw	r0, #50192	; 0xc410
  10dbae:	f2c0 0011 	movt	r0, #17
  10dbb2:	f006 fe0f 	bl	1147d4 <puts>
        return -1;
  10dbb6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10dbba:	e752      	b.n	10da62 <clk_endis+0x6a>

0010dbbc <clk_disable>:
    return clk_endis(clk, false);
  10dbbc:	2100      	movs	r1, #0
  10dbbe:	f7ff bf1b 	b.w	10d9f8 <clk_endis>
  10dbc2:	bf00      	nop

0010dbc4 <clk_enable>:
    return clk_endis(clk, true);
  10dbc4:	2101      	movs	r1, #1
  10dbc6:	f7ff bf17 	b.w	10d9f8 <clk_endis>
  10dbca:	bf00      	nop

0010dbcc <clk_get_refcount_by_perid.constprop.33>:
static int clk_get_refcount_by_perid(struct clk *clk, int per_id,
  10dbcc:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    int i = per_id / 32;
  10dbce:	f101 031f 	add.w	r3, r1, #31
  10dbd2:	ea13 0321 	ands.w	r3, r3, r1, asr #32
  10dbd6:	bf38      	it	cc
  10dbd8:	460b      	movcc	r3, r1
  10dbda:	115b      	asrs	r3, r3, #5
    ASSERT(i < REFCNT_NUM);
  10dbdc:	2b00      	cmp	r3, #0
  10dbde:	dc23      	bgt.n	10dc28 <clk_get_refcount_by_perid.constprop.33+0x5c>
  10dbe0:	460d      	mov	r5, r1
  10dbe2:	f100 0430 	add.w	r4, r0, #48	; 0x30
  10dbe6:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
    return (ref[i] & (1 << (per_id % 32)));
  10dbe8:	4249      	negs	r1, r1
  10dbea:	f001 011f 	and.w	r1, r1, #31
  10dbee:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    if (list_is_empty(&clk->child)) {
  10dbf2:	f100 0768 	add.w	r7, r0, #104	; 0x68
    return (ref[i] & (1 << (per_id % 32)));
  10dbf6:	f04f 0401 	mov.w	r4, #1
  10dbfa:	f005 021f 	and.w	r2, r5, #31
  10dbfe:	bf58      	it	pl
  10dc00:	424a      	negpl	r2, r1
    if (list_is_empty(&clk->child)) {
  10dc02:	42b7      	cmp	r7, r6
    return (ref[i] & (1 << (per_id % 32)));
  10dc04:	fa04 f402 	lsl.w	r4, r4, r2
  10dc08:	ea04 0403 	and.w	r4, r4, r3
    if (list_is_empty(&clk->child)) {
  10dc0c:	d00a      	beq.n	10dc24 <clk_get_refcount_by_perid.constprop.33+0x58>
    list_for_every_entry(&clk->child, child, struct clk, node) {
  10dc0e:	3e60      	subs	r6, #96	; 0x60
        count += clk_get_refcount_by_perid(child, per_id, freqcare);
  10dc10:	4630      	mov	r0, r6
  10dc12:	4629      	mov	r1, r5
  10dc14:	f7ff ffda 	bl	10dbcc <clk_get_refcount_by_perid.constprop.33>
    list_for_every_entry(&clk->child, child, struct clk, node) {
  10dc18:	6e73      	ldr	r3, [r6, #100]	; 0x64
  10dc1a:	429f      	cmp	r7, r3
  10dc1c:	f1a3 0660 	sub.w	r6, r3, #96	; 0x60
        count += clk_get_refcount_by_perid(child, per_id, freqcare);
  10dc20:	4404      	add	r4, r0
    list_for_every_entry(&clk->child, child, struct clk, node) {
  10dc22:	d1f5      	bne.n	10dc10 <clk_get_refcount_by_perid.constprop.33+0x44>
}
  10dc24:	4620      	mov	r0, r4
  10dc26:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  10dc28:	f7ff fa6a 	bl	10d100 <clk_test_refcount_bit.part.12>

0010dc2c <res_clk_is_valid_request>:
{
  10dc2c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10dc30:	460c      	mov	r4, r1
    if (pindex != -1) {
  10dc32:	3101      	adds	r1, #1
{
  10dc34:	4616      	mov	r6, r2
  10dc36:	4698      	mov	r8, r3
  10dc38:	4605      	mov	r5, r0
    if (pindex != -1) {
  10dc3a:	d01a      	beq.n	10dc72 <res_clk_is_valid_request+0x46>
    if (rate != res_clk_get_rate(clk, false)) {
  10dc3c:	2100      	movs	r1, #0
        p = clk->parents[pindex];
  10dc3e:	f104 0310 	add.w	r3, r4, #16
  10dc42:	f850 7023 	ldr.w	r7, [r0, r3, lsl #2]
    if (rate != res_clk_get_rate(clk, false)) {
  10dc46:	f7ff f93b 	bl	10cec0 <res_clk_get_rate>
  10dc4a:	42b0      	cmp	r0, r6
  10dc4c:	d117      	bne.n	10dc7e <res_clk_is_valid_request+0x52>
    if (p && prate != res_clk_get_rate(p, false)) {
  10dc4e:	b16f      	cbz	r7, 10dc6c <res_clk_is_valid_request+0x40>
  10dc50:	2100      	movs	r1, #0
  10dc52:	4638      	mov	r0, r7
  10dc54:	f7ff f934 	bl	10cec0 <res_clk_get_rate>
  10dc58:	4540      	cmp	r0, r8
  10dc5a:	d007      	beq.n	10dc6c <res_clk_is_valid_request+0x40>
        int rfcnt = clk_get_refcount(p, true);
  10dc5c:	2101      	movs	r1, #1
  10dc5e:	4638      	mov	r0, r7
  10dc60:	f7ff f8fe 	bl	10ce60 <clk_get_refcount>
  10dc64:	4606      	mov	r6, r0
        if (rfcnt > 1) {
  10dc66:	2801      	cmp	r0, #1
  10dc68:	dc0f      	bgt.n	10dc8a <res_clk_is_valid_request+0x5e>
        else if (rfcnt == 1
  10dc6a:	d03b      	beq.n	10dce4 <res_clk_is_valid_request+0xb8>
    return true;
  10dc6c:	2001      	movs	r0, #1
}
  10dc6e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    if (rate != res_clk_get_rate(clk, false)) {
  10dc72:	2100      	movs	r1, #0
  10dc74:	f7ff f924 	bl	10cec0 <res_clk_get_rate>
  10dc78:	4286      	cmp	r6, r0
  10dc7a:	d0f7      	beq.n	10dc6c <res_clk_is_valid_request+0x40>
    struct clk *p = NULL;
  10dc7c:	2700      	movs	r7, #0
        int refcnt = clk_get_refcount(clk, true);
  10dc7e:	2101      	movs	r1, #1
  10dc80:	4628      	mov	r0, r5
  10dc82:	f7ff f8ed 	bl	10ce60 <clk_get_refcount>
        if (refcnt > 1) {
  10dc86:	2801      	cmp	r0, #1
  10dc88:	dd02      	ble.n	10dc90 <res_clk_is_valid_request+0x64>
            return false;
  10dc8a:	2000      	movs	r0, #0
}
  10dc8c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        if (refcnt == 1 && clk_get_refcount_by_perid(clk, cur_per_id, true) == 0) {
  10dc90:	d03d      	beq.n	10dd0e <res_clk_is_valid_request+0xe2>
        if (cur_clkid != clk->clkid
  10dc92:	682a      	ldr	r2, [r5, #0]
  10dc94:	f240 1374 	movw	r3, #372	; 0x174
  10dc98:	f2c0 0313 	movt	r3, #19
  10dc9c:	681b      	ldr	r3, [r3, #0]
  10dc9e:	429a      	cmp	r2, r3
  10dca0:	d0d5      	beq.n	10dc4e <res_clk_is_valid_request+0x22>
                && clk_get_refcount_by_perid_level1(clk, cur_per_id, true) == 1) {
  10dca2:	f240 1378 	movw	r3, #376	; 0x178
        ref = &clk->refcount[0];
  10dca6:	f105 0030 	add.w	r0, r5, #48	; 0x30
                && clk_get_refcount_by_perid_level1(clk, cur_per_id, true) == 1) {
  10dcaa:	f2c0 0313 	movt	r3, #19
  10dcae:	681b      	ldr	r3, [r3, #0]
    int i = per_id / 32;
  10dcb0:	f103 021f 	add.w	r2, r3, #31
  10dcb4:	ea12 0223 	ands.w	r2, r2, r3, asr #32
  10dcb8:	bf38      	it	cc
  10dcba:	461a      	movcc	r2, r3
  10dcbc:	1152      	asrs	r2, r2, #5
    ASSERT(i < REFCNT_NUM);
  10dcbe:	2a00      	cmp	r2, #0
  10dcc0:	dc30      	bgt.n	10dd24 <res_clk_is_valid_request+0xf8>
    return (ref[i] & (1 << (per_id % 32)));
  10dcc2:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  10dcc6:	4259      	negs	r1, r3
  10dcc8:	f04f 0201 	mov.w	r2, #1
  10dccc:	f001 011f 	and.w	r1, r1, #31
  10dcd0:	f003 031f 	and.w	r3, r3, #31
  10dcd4:	bf58      	it	pl
  10dcd6:	424b      	negpl	r3, r1
  10dcd8:	fa02 f303 	lsl.w	r3, r2, r3
  10dcdc:	4003      	ands	r3, r0
                && clk_get_refcount_by_perid_level1(clk, cur_per_id, true) == 1) {
  10dcde:	4293      	cmp	r3, r2
  10dce0:	d1b5      	bne.n	10dc4e <res_clk_is_valid_request+0x22>
  10dce2:	e7d2      	b.n	10dc8a <res_clk_is_valid_request+0x5e>
                 && ((clk->cur_parent_index != pindex)
  10dce4:	6bab      	ldr	r3, [r5, #56]	; 0x38
  10dce6:	42a3      	cmp	r3, r4
  10dce8:	d1cf      	bne.n	10dc8a <res_clk_is_valid_request+0x5e>
                     || clk_get_refcount_by_perid(p, cur_per_id, true) == 0)) {
  10dcea:	f240 1378 	movw	r3, #376	; 0x178
  10dcee:	4638      	mov	r0, r7
  10dcf0:	f2c0 0313 	movt	r3, #19
  10dcf4:	6819      	ldr	r1, [r3, #0]
  10dcf6:	f7ff ff69 	bl	10dbcc <clk_get_refcount_by_perid.constprop.33>
  10dcfa:	2800      	cmp	r0, #0
  10dcfc:	d0c5      	beq.n	10dc8a <res_clk_is_valid_request+0x5e>
                 && clk_get_refcount(clk, true) == 0) {
  10dcfe:	4631      	mov	r1, r6
  10dd00:	4628      	mov	r0, r5
  10dd02:	f7ff f8ad 	bl	10ce60 <clk_get_refcount>
  10dd06:	3000      	adds	r0, #0
  10dd08:	bf18      	it	ne
  10dd0a:	2001      	movne	r0, #1
  10dd0c:	e7be      	b.n	10dc8c <res_clk_is_valid_request+0x60>
        if (refcnt == 1 && clk_get_refcount_by_perid(clk, cur_per_id, true) == 0) {
  10dd0e:	f240 1378 	movw	r3, #376	; 0x178
  10dd12:	4628      	mov	r0, r5
  10dd14:	f2c0 0313 	movt	r3, #19
  10dd18:	6819      	ldr	r1, [r3, #0]
  10dd1a:	f7ff ff57 	bl	10dbcc <clk_get_refcount_by_perid.constprop.33>
  10dd1e:	2800      	cmp	r0, #0
  10dd20:	d1b7      	bne.n	10dc92 <res_clk_is_valid_request+0x66>
  10dd22:	e7b2      	b.n	10dc8a <res_clk_is_valid_request+0x5e>
  10dd24:	f7ff f9ec 	bl	10d100 <clk_test_refcount_bit.part.12>

0010dd28 <res_clk_round_rate>:
    if (!clk->parent_nums) {
  10dd28:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
{
  10dd2a:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    unsigned long prate = 0;
  10dd2e:	2700      	movs	r7, #0
{
  10dd30:	b085      	sub	sp, #20
  10dd32:	4604      	mov	r4, r0
  10dd34:	460e      	mov	r6, r1
    unsigned long prate = 0;
  10dd36:	9703      	str	r7, [sp, #12]
    if (!clk->parent_nums) {
  10dd38:	b982      	cbnz	r2, 10dd5c <res_clk_round_rate+0x34>
        if (clk->round_rate) {
  10dd3a:	f8d0 50e8 	ldr.w	r5, [r0, #232]	; 0xe8
        req->best_parent_index = clk->cur_parent_index;
  10dd3e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  10dd40:	608b      	str	r3, [r1, #8]
        if (clk->round_rate) {
  10dd42:	2d00      	cmp	r5, #0
  10dd44:	f000 80a7 	beq.w	10de96 <res_clk_round_rate+0x16e>
            req->best_prate = clk->round_rate(clk, -1, 0, req->request);
  10dd48:	6833      	ldr	r3, [r6, #0]
  10dd4a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10dd4e:	47a8      	blx	r5
  10dd50:	6070      	str	r0, [r6, #4]
  10dd52:	4680      	mov	r8, r0
}
  10dd54:	4640      	mov	r0, r8
  10dd56:	b005      	add	sp, #20
  10dd58:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    bestrate = res_clk_get_rate(clk, false);
  10dd5c:	4639      	mov	r1, r7
  10dd5e:	f7ff f8af 	bl	10cec0 <res_clk_get_rate>
    best_parent_index = clk->cur_parent_index;
  10dd62:	f8d4 b038 	ldr.w	r11, [r4, #56]	; 0x38
    bestprate = res_clk_get_rate(clk->parents[clk->cur_parent_index], false);
  10dd66:	4639      	mov	r1, r7
  10dd68:	f10b 0310 	add.w	r3, r11, #16
    bestrate = res_clk_get_rate(clk, false);
  10dd6c:	4680      	mov	r8, r0
    bestprate = res_clk_get_rate(clk->parents[clk->cur_parent_index], false);
  10dd6e:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
  10dd72:	f7ff f8a5 	bl	10cec0 <res_clk_get_rate>
        int i = clk->cur_parent_index;
  10dd76:	6ba5      	ldr	r5, [r4, #56]	; 0x38
        prate = res_clk_get_rate(p, false);
  10dd78:	4639      	mov	r1, r7
        p = clk->parents[i];
  10dd7a:	f105 0310 	add.w	r3, r5, #16
    bestprate = res_clk_get_rate(clk->parents[clk->cur_parent_index], false);
  10dd7e:	9001      	str	r0, [sp, #4]
        prate = res_clk_get_rate(p, false);
  10dd80:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
  10dd84:	f7ff f89c 	bl	10cec0 <res_clk_get_rate>
        if (clk->round_rate) {
  10dd88:	f8d4 70e8 	ldr.w	r7, [r4, #232]	; 0xe8
        prate = res_clk_get_rate(p, false);
  10dd8c:	9003      	str	r0, [sp, #12]
        if (clk->round_rate) {
  10dd8e:	2f00      	cmp	r7, #0
  10dd90:	f000 8087 	beq.w	10dea2 <res_clk_round_rate+0x17a>
            rate = clk->round_rate(clk, i, &prate, req->request);
  10dd94:	6833      	ldr	r3, [r6, #0]
  10dd96:	aa03      	add	r2, sp, #12
  10dd98:	4629      	mov	r1, r5
  10dd9a:	4620      	mov	r0, r4
  10dd9c:	47b8      	blx	r7
  10dd9e:	4607      	mov	r7, r0
    if (round_rate_filter_en) {
  10dda0:	f64a 1a10 	movw	r10, #43280	; 0xa910
  10dda4:	f2c0 0a12 	movt	r10, #18
  10dda8:	f8da 3000 	ldr.w	r3, [r10]
  10ddac:	2b00      	cmp	r3, #0
  10ddae:	d15e      	bne.n	10de6e <res_clk_round_rate+0x146>
        diff = abs_clk(rate, req->request);
  10ddb0:	6833      	ldr	r3, [r6, #0]
  10ddb2:	42bb      	cmp	r3, r7
  10ddb4:	d23f      	bcs.n	10de36 <res_clk_round_rate+0x10e>
  10ddb6:	eba7 0903 	sub.w	r9, r7, r3
        if (diff < diffrate) {
  10ddba:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
  10ddbe:	d003      	beq.n	10ddc8 <res_clk_round_rate+0xa0>
            best_parent_index = i;
  10ddc0:	46ab      	mov	r11, r5
            bestprate = prate;
  10ddc2:	46b8      	mov	r8, r7
  10ddc4:	9b03      	ldr	r3, [sp, #12]
  10ddc6:	9301      	str	r3, [sp, #4]
    for (i = 0; i < clk->parent_nums; i++) {
  10ddc8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  10ddca:	2a00      	cmp	r2, #0
  10ddcc:	bfc8      	it	gt
  10ddce:	2500      	movgt	r5, #0
  10ddd0:	dc0c      	bgt.n	10ddec <res_clk_round_rate+0xc4>
  10ddd2:	e03c      	b.n	10de4e <res_clk_round_rate+0x126>
        diff = abs_clk(rate, req->request);
  10ddd4:	1afb      	subs	r3, r7, r3
        if (diff < diffrate) {
  10ddd6:	454b      	cmp	r3, r9
  10ddd8:	d204      	bcs.n	10dde4 <res_clk_round_rate+0xbc>
            bestprate = prate;
  10ddda:	46b8      	mov	r8, r7
  10dddc:	46ab      	mov	r11, r5
  10ddde:	4699      	mov	r9, r3
  10dde0:	9b03      	ldr	r3, [sp, #12]
  10dde2:	9301      	str	r3, [sp, #4]
  10dde4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
    for (i = 0; i < clk->parent_nums; i++) {
  10dde6:	3501      	adds	r5, #1
  10dde8:	42aa      	cmp	r2, r5
  10ddea:	dd30      	ble.n	10de4e <res_clk_round_rate+0x126>
        if (i == clk->cur_parent_index) { continue; }
  10ddec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  10ddee:	42ab      	cmp	r3, r5
  10ddf0:	d0f9      	beq.n	10dde6 <res_clk_round_rate+0xbe>
        prate = res_clk_get_rate(p, false);
  10ddf2:	2100      	movs	r1, #0
        p = clk->parents[i];
  10ddf4:	eb04 0385 	add.w	r3, r4, r5, lsl #2
        prate = res_clk_get_rate(p, false);
  10ddf8:	6c18      	ldr	r0, [r3, #64]	; 0x40
  10ddfa:	f7ff f861 	bl	10cec0 <res_clk_get_rate>
        if (clk->round_rate) {
  10ddfe:	f8d4 70e8 	ldr.w	r7, [r4, #232]	; 0xe8
        prate = res_clk_get_rate(p, false);
  10de02:	9003      	str	r0, [sp, #12]
        if (clk->round_rate) {
  10de04:	2f00      	cmp	r7, #0
  10de06:	d040      	beq.n	10de8a <res_clk_round_rate+0x162>
            rate = clk->round_rate(clk, i, &prate, req->request);
  10de08:	6833      	ldr	r3, [r6, #0]
  10de0a:	aa03      	add	r2, sp, #12
  10de0c:	4629      	mov	r1, r5
  10de0e:	4620      	mov	r0, r4
  10de10:	47b8      	blx	r7
  10de12:	4607      	mov	r7, r0
    if (round_rate_filter_en) {
  10de14:	f8da 3000 	ldr.w	r3, [r10]
  10de18:	bb03      	cbnz	r3, 10de5c <res_clk_round_rate+0x134>
        diff = abs_clk(rate, req->request);
  10de1a:	6833      	ldr	r3, [r6, #0]
  10de1c:	42bb      	cmp	r3, r7
  10de1e:	d3d9      	bcc.n	10ddd4 <res_clk_round_rate+0xac>
  10de20:	1bdb      	subs	r3, r3, r7
        if (diff < diffrate) {
  10de22:	454b      	cmp	r3, r9
  10de24:	d2de      	bcs.n	10dde4 <res_clk_round_rate+0xbc>
            bestprate = prate;
  10de26:	9a03      	ldr	r2, [sp, #12]
  10de28:	9201      	str	r2, [sp, #4]
            if (diff == 0) {
  10de2a:	b35b      	cbz	r3, 10de84 <res_clk_round_rate+0x15c>
  10de2c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  10de2e:	4699      	mov	r9, r3
  10de30:	46b8      	mov	r8, r7
  10de32:	46ab      	mov	r11, r5
  10de34:	e7d7      	b.n	10dde6 <res_clk_round_rate+0xbe>
        diff = abs_clk(rate, req->request);
  10de36:	eba3 0907 	sub.w	r9, r3, r7
        if (diff < diffrate) {
  10de3a:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
  10de3e:	d0c3      	beq.n	10ddc8 <res_clk_round_rate+0xa0>
            bestprate = prate;
  10de40:	9b03      	ldr	r3, [sp, #12]
            best_parent_index = i;
  10de42:	46ab      	mov	r11, r5
            bestprate = prate;
  10de44:	9301      	str	r3, [sp, #4]
found:
  10de46:	46b8      	mov	r8, r7
            if (diff == 0) {
  10de48:	f1b9 0f00 	cmp.w	r9, #0
  10de4c:	d1bc      	bne.n	10ddc8 <res_clk_round_rate+0xa0>
    req->best_prate = bestprate;
  10de4e:	9b01      	ldr	r3, [sp, #4]
}
  10de50:	4640      	mov	r0, r8
    req->best_parent_index = best_parent_index;
  10de52:	e9c6 3b01 	strd	r3, r11, [r6, #4]
}
  10de56:	b005      	add	sp, #20
  10de58:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10de5c:	9b03      	ldr	r3, [sp, #12]
  10de5e:	463a      	mov	r2, r7
  10de60:	4629      	mov	r1, r5
  10de62:	4620      	mov	r0, r4
  10de64:	f7ff fee2 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, i, rate, prate)) { continue; }
  10de68:	2800      	cmp	r0, #0
  10de6a:	d1d6      	bne.n	10de1a <res_clk_round_rate+0xf2>
  10de6c:	e7ba      	b.n	10dde4 <res_clk_round_rate+0xbc>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10de6e:	9b03      	ldr	r3, [sp, #12]
  10de70:	463a      	mov	r2, r7
  10de72:	4629      	mov	r1, r5
  10de74:	4620      	mov	r0, r4
  10de76:	f7ff fed9 	bl	10dc2c <res_clk_is_valid_request>
    unsigned long diffrate = UINT32_MAX;
  10de7a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
        if (!res_clk_is_valid_round_rate(clk, i, rate, prate)) { goto notvalid; }
  10de7e:	2800      	cmp	r0, #0
  10de80:	d0a2      	beq.n	10ddc8 <res_clk_round_rate+0xa0>
  10de82:	e795      	b.n	10ddb0 <res_clk_round_rate+0x88>
found:
  10de84:	46ab      	mov	r11, r5
  10de86:	46b8      	mov	r8, r7
  10de88:	e7e1      	b.n	10de4e <res_clk_round_rate+0x126>
            rate = res_clk_get_rate(clk, false);
  10de8a:	4639      	mov	r1, r7
  10de8c:	4620      	mov	r0, r4
  10de8e:	f7ff f817 	bl	10cec0 <res_clk_get_rate>
  10de92:	4607      	mov	r7, r0
  10de94:	e7be      	b.n	10de14 <res_clk_round_rate+0xec>
            req->best_prate = res_clk_get_rate(clk, false);
  10de96:	4629      	mov	r1, r5
  10de98:	f7ff f812 	bl	10cec0 <res_clk_get_rate>
  10de9c:	6070      	str	r0, [r6, #4]
  10de9e:	4680      	mov	r8, r0
        return req->best_prate;
  10dea0:	e758      	b.n	10dd54 <res_clk_round_rate+0x2c>
            rate = res_clk_get_rate(clk, false);
  10dea2:	4639      	mov	r1, r7
  10dea4:	4620      	mov	r0, r4
  10dea6:	f7ff f80b 	bl	10cec0 <res_clk_get_rate>
  10deaa:	4607      	mov	r7, r0
  10deac:	e778      	b.n	10dda0 <res_clk_round_rate+0x78>
  10deae:	bf00      	nop

0010deb0 <get_ckgen_bus_ip_round_rate_clk>:
{
  10deb0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10deb4:	461f      	mov	r7, r3
  10deb6:	4693      	mov	r11, r2
    maxdiv = MIN(clk->maxdiv, prediv_max * postdiv_max);
  10deb8:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
    struct clk *p = clk->parents[pindex];
  10debc:	f101 0210 	add.w	r2, r1, #16
{
  10dec0:	b08f      	sub	sp, #60	; 0x3c
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10dec2:	f8db a000 	ldr.w	r10, [r11]
    maxdiv = MIN(clk->maxdiv, prediv_max * postdiv_max);
  10dec6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    struct clk *p = clk->parents[pindex];
  10deca:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    maxdiv = MIN(clk->maxdiv, prediv_max * postdiv_max);
  10dece:	bfa8      	it	ge
  10ded0:	f44f 7300 	movge.w	r3, #512	; 0x200
{
  10ded4:	9008      	str	r0, [sp, #32]
  10ded6:	9109      	str	r1, [sp, #36]	; 0x24
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ded8:	fba3 0107 	umull	r0, r1, r3, r7
    struct clk *p = clk->parents[pindex];
  10dedc:	9207      	str	r2, [sp, #28]
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10dede:	2900      	cmp	r1, #0
  10dee0:	d167      	bne.n	10dfb2 <get_ckgen_bus_ip_round_rate_clk+0x102>
    mindiv = MAX(clk->mindiv, 1);
  10dee2:	9a08      	ldr	r2, [sp, #32]
    if (round_rate_filter_en) {
  10dee4:	f64a 1110 	movw	r1, #43280	; 0xa910
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10dee8:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  10deec:	f2c0 0112 	movt	r1, #18
    maxdiv = MAX(maxdiv, mindiv);
  10def0:	9703      	str	r7, [sp, #12]
    mindiv = MAX(clk->mindiv, 1);
  10def2:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
  10def6:	9106      	str	r1, [sp, #24]
    for (i = 1; i <= prediv_max; i++) {
  10def8:	2101      	movs	r1, #1
    mindiv = MAX(clk->mindiv, 1);
  10defa:	2a01      	cmp	r2, #1
    for (i = 1; i <= prediv_max; i++) {
  10defc:	9102      	str	r1, [sp, #8]
    mindiv = MAX(clk->mindiv, 1);
  10defe:	bfb8      	it	lt
  10df00:	2201      	movlt	r2, #1
    maxdiv = MAX(maxdiv, mindiv);
  10df02:	4293      	cmp	r3, r2
    mindiv = MAX(clk->mindiv, 1);
  10df04:	9204      	str	r2, [sp, #16]
    maxdiv = MAX(maxdiv, mindiv);
  10df06:	bf38      	it	cc
  10df08:	4613      	movcc	r3, r2
    mindiv = MAX(clk->mindiv, 1);
  10df0a:	9201      	str	r2, [sp, #4]
    maxdiv = MAX(maxdiv, mindiv);
  10df0c:	9305      	str	r3, [sp, #20]
{
  10df0e:	e9dd 4502 	ldrd	r4, r5, [r13, #8]
  10df12:	f04f 0840 	mov.w	r8, #64	; 0x40
  10df16:	e00e      	b.n	10df36 <get_ckgen_bus_ip_round_rate_clk+0x86>
            diff = abs_clk(freq, prate_cur / (i * j));
  10df18:	1afb      	subs	r3, r7, r3
            if (diff < bestratediff) {
  10df1a:	9a01      	ldr	r2, [sp, #4]
  10df1c:	4599      	cmp	r9, r3
  10df1e:	bf82      	ittt	hi
  10df20:	4622      	movhi	r2, r4
  10df22:	46b2      	movhi	r10, r6
  10df24:	4699      	movhi	r9, r3
  10df26:	9201      	str	r2, [sp, #4]
  10df28:	9b02      	ldr	r3, [sp, #8]
        for (j = 1; j <= postdiv_max; j++) {
  10df2a:	f1b8 0801 	subs.w	r8, r8, #1
  10df2e:	441c      	add	r4, r3
  10df30:	9b03      	ldr	r3, [sp, #12]
  10df32:	441d      	add	r5, r3
  10df34:	d02d      	beq.n	10df92 <get_ckgen_bus_ip_round_rate_clk+0xe2>
            if (((i * j) < (int)mindiv) || ((i * j) > (int)maxdiv)) {
  10df36:	9b04      	ldr	r3, [sp, #16]
  10df38:	42a3      	cmp	r3, r4
  10df3a:	dc2a      	bgt.n	10df92 <get_ckgen_bus_ip_round_rate_clk+0xe2>
  10df3c:	9b05      	ldr	r3, [sp, #20]
  10df3e:	42a3      	cmp	r3, r4
  10df40:	db27      	blt.n	10df92 <get_ckgen_bus_ip_round_rate_clk+0xe2>
    if (freq * div_i == parent_rate_saved) {
  10df42:	f8db 3000 	ldr.w	r3, [r11]
  10df46:	42ab      	cmp	r3, r5
  10df48:	bf04      	itt	eq
  10df4a:	462e      	moveq	r6, r5
  10df4c:	463a      	moveq	r2, r7
  10df4e:	d009      	beq.n	10df64 <get_ckgen_bus_ip_round_rate_clk+0xb4>
    *prate = res_clk_round_rate(p, &req);
  10df50:	9807      	ldr	r0, [sp, #28]
  10df52:	a90b      	add	r1, sp, #44	; 0x2c
    req.request = freq * div_i;
  10df54:	950b      	str	r5, [sp, #44]	; 0x2c
    *prate = res_clk_round_rate(p, &req);
  10df56:	f7ff fee7 	bl	10dd28 <res_clk_round_rate>
    now = DIV_ROUND_UP(*prate, div_i);
  10df5a:	1e62      	subs	r2, r4, #1
    *prate = res_clk_round_rate(p, &req);
  10df5c:	4606      	mov	r6, r0
    now = DIV_ROUND_UP(*prate, div_i);
  10df5e:	4402      	add	r2, r0
  10df60:	fbb2 f2f4 	udiv	r2, r2, r4
    if (round_rate_filter_en) {
  10df64:	9b06      	ldr	r3, [sp, #24]
  10df66:	681b      	ldr	r3, [r3, #0]
  10df68:	b95b      	cbnz	r3, 10df82 <get_ckgen_bus_ip_round_rate_clk+0xd2>
            diff = abs_clk(freq, prate_cur / (i * j));
  10df6a:	fbb6 f3f4 	udiv	r3, r6, r4
  10df6e:	42bb      	cmp	r3, r7
  10df70:	d3d2      	bcc.n	10df18 <get_ckgen_bus_ip_round_rate_clk+0x68>
            if (diff == 0) {
  10df72:	1bdb      	subs	r3, r3, r7
  10df74:	d1d1      	bne.n	10df1a <get_ckgen_bus_ip_round_rate_clk+0x6a>
                *prate = prate_cur;
  10df76:	f8cb 6000 	str.w	r6, [r11]
                return freq;
  10df7a:	4638      	mov	r0, r7
}
  10df7c:	b00f      	add	sp, #60	; 0x3c
  10df7e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10df82:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
  10df86:	4633      	mov	r3, r6
  10df88:	f7ff fe50 	bl	10dc2c <res_clk_is_valid_request>
            if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }
  10df8c:	2800      	cmp	r0, #0
  10df8e:	d1ec      	bne.n	10df6a <get_ckgen_bus_ip_round_rate_clk+0xba>
  10df90:	e7ca      	b.n	10df28 <get_ckgen_bus_ip_round_rate_clk+0x78>
    for (i = 1; i <= prediv_max; i++) {
  10df92:	9b02      	ldr	r3, [sp, #8]
  10df94:	9a03      	ldr	r2, [sp, #12]
  10df96:	3301      	adds	r3, #1
  10df98:	443a      	add	r2, r7
  10df9a:	9302      	str	r3, [sp, #8]
  10df9c:	2b09      	cmp	r3, #9
  10df9e:	9203      	str	r2, [sp, #12]
  10dfa0:	d1b5      	bne.n	10df0e <get_ckgen_bus_ip_round_rate_clk+0x5e>
    bestrate = (bestprate) / (bestdiv);
  10dfa2:	9b01      	ldr	r3, [sp, #4]
    *prate = bestprate;
  10dfa4:	f8cb a000 	str.w	r10, [r11]
    bestrate = (bestprate) / (bestdiv);
  10dfa8:	fbba f0f3 	udiv	r0, r10, r3
}
  10dfac:	b00f      	add	sp, #60	; 0x3c
  10dfae:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10dfb2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10dfb6:	fbb3 f3f7 	udiv	r3, r3, r7
  10dfba:	e792      	b.n	10dee2 <get_ckgen_bus_ip_round_rate_clk+0x32>

0010dfbc <res_clk_set_rate>:

static int res_clk_set_rate(struct clk *clk, enum module_per_id per_id,
                            unsigned long freq)
{
  10dfbc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10dfc0:	b089      	sub	sp, #36	; 0x24
    int ret = 0;

    if (!freq) {
  10dfc2:	2a00      	cmp	r2, #0
  10dfc4:	f000 8083 	beq.w	10e0ce <res_clk_set_rate+0x112>
  10dfc8:	4615      	mov	r5, r2
        return res_clk_dec_refcount(clk, per_id);
    }
    else if (freq == 1) {
  10dfca:	2a01      	cmp	r2, #1
  10dfcc:	d077      	beq.n	10e0be <res_clk_set_rate+0x102>
  10dfce:	460f      	mov	r7, r1
    else {
        unsigned long rate;
        struct clk_request req;
        int oldrefcnt;

        if (freq == res_clk_get_rate(clk, false)) {
  10dfd0:	2100      	movs	r1, #0
  10dfd2:	4676      	mov	r6, r14
  10dfd4:	4604      	mov	r4, r0
  10dfd6:	f7fe ff73 	bl	10cec0 <res_clk_get_rate>
  10dfda:	42a8      	cmp	r0, r5
  10dfdc:	d07e      	beq.n	10e0dc <res_clk_set_rate+0x120>
            res_clk_inc_refcount(clk, per_id, true);
            return ret;
        }

        req.request = freq;
        rate = res_clk_round_rate(clk, &req);
  10dfde:	4620      	mov	r0, r4
        req.request = freq;
  10dfe0:	a908      	add	r1, sp, #32
  10dfe2:	f841 5d0c 	str.w	r5, [r1, #-12]!
        rate = res_clk_round_rate(clk, &req);
  10dfe6:	f7ff fe9f 	bl	10dd28 <res_clk_round_rate>
        CLK_TRACE(DBGV, "%s req is %lu round rate %lu, best p %d, prate %lu\n",
                  clk->name, freq, rate, req.best_parent_index, req.best_prate);
        //may be can check if the round rate is match the requirement.
        oldrefcnt = clk_get_refcount(clk, false);
  10dfea:	2100      	movs	r1, #0
        rate = res_clk_round_rate(clk, &req);
  10dfec:	4682      	mov	r10, r0
        oldrefcnt = clk_get_refcount(clk, false);
  10dfee:	4620      	mov	r0, r4
  10dff0:	f7fe ff36 	bl	10ce60 <clk_get_refcount>

        if (!res_clk_is_valid_request(clk, req.best_parent_index, rate,
  10dff4:	e9dd 3106 	ldrd	r3, r1, [r13, #24]
  10dff8:	4652      	mov	r2, r10
        oldrefcnt = clk_get_refcount(clk, false);
  10dffa:	4681      	mov	r9, r0
        if (!res_clk_is_valid_request(clk, req.best_parent_index, rate,
  10dffc:	4620      	mov	r0, r4
  10dffe:	f7ff fe15 	bl	10dc2c <res_clk_is_valid_request>
  10e002:	2800      	cmp	r0, #0
  10e004:	d074      	beq.n	10e0f0 <res_clk_set_rate+0x134>
                return -1;
            }
        }

        //request the same freq
        if (rate == res_clk_get_rate(clk, false)) {
  10e006:	2100      	movs	r1, #0
  10e008:	4620      	mov	r0, r4
  10e00a:	f7fe ff59 	bl	10cec0 <res_clk_get_rate>
  10e00e:	4550      	cmp	r0, r10
  10e010:	d064      	beq.n	10e0dc <res_clk_set_rate+0x120>
            res_clk_inc_refcount(clk, per_id, true);
            return ret;
        }

        //allowed to change rate and parent
        if (req.best_parent_index != -1
  10e012:	9b07      	ldr	r3, [sp, #28]
  10e014:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
  10e018:	1c5a      	adds	r2, r3, #1
  10e01a:	f000 8091 	beq.w	10e140 <res_clk_set_rate+0x184>
                && req.best_parent_index != clk->cur_parent_index) {
  10e01e:	4543      	cmp	r3, r8
  10e020:	f000 809a 	beq.w	10e158 <res_clk_set_rate+0x19c>
    item->next->prev = item->prev;
  10e024:	6e60      	ldr	r0, [r4, #100]	; 0x64
            struct clk *new_parent = clk->parents[req.best_parent_index];
  10e026:	3310      	adds	r3, #16
  10e028:	6e21      	ldr	r1, [r4, #96]	; 0x60
    item->prev = item->next = 0;
  10e02a:	2500      	movs	r5, #0
            int oldpindex = clk->cur_parent_index;
            //delete node from old parent.
            list_delete(&clk->node);
            //add node to new parent.
            list_add_head(&(new_parent->child), &clk->node);
            res_clk_inc_refcount(new_parent, INVALID_PER_ID,
  10e02c:	462a      	mov	r2, r5
            list_delete(&clk->node);
  10e02e:	f104 0c60 	add.w	r12, r4, #96	; 0x60
            struct clk *new_parent = clk->parents[req.best_parent_index];
  10e032:	f854 b023 	ldr.w	r11, [r4, r3, lsl #2]
    item->next->prev = item->prev;
  10e036:	6001      	str	r1, [r0, #0]
    item->prev->next = item->next;
  10e038:	6e23      	ldr	r3, [r4, #96]	; 0x60
  10e03a:	6058      	str	r0, [r3, #4]
            list_add_head(&(new_parent->child), &clk->node);
  10e03c:	f10b 0068 	add.w	r0, r11, #104	; 0x68
    item->prev = item->next = 0;
  10e040:	6665      	str	r5, [r4, #100]	; 0x64
    item->next = list->next;
  10e042:	f8db 306c 	ldr.w	r3, [r11, #108]	; 0x6c
  10e046:	6663      	str	r3, [r4, #100]	; 0x64
    list->next->prev = item;
  10e048:	f8db 106c 	ldr.w	r1, [r11, #108]	; 0x6c
    item->prev = list;
  10e04c:	6620      	str	r0, [r4, #96]	; 0x60
            res_clk_inc_refcount(new_parent, INVALID_PER_ID,
  10e04e:	4658      	mov	r0, r11
    list->next->prev = item;
  10e050:	f8c1 c000 	str.w	r12, [r1]
  10e054:	2101      	movs	r1, #1
    list->next = item;
  10e056:	f8cb c06c 	str.w	r12, [r11, #108]	; 0x6c
  10e05a:	f7ff f8cd 	bl	10d1f8 <res_clk_inc_refcount>
                                 false);

            if (req.best_prate != res_clk_get_rate(new_parent,
  10e05e:	9b06      	ldr	r3, [sp, #24]
  10e060:	4658      	mov	r0, r11
  10e062:	4629      	mov	r1, r5
  10e064:	9303      	str	r3, [sp, #12]
  10e066:	f7fe ff2b 	bl	10cec0 <res_clk_get_rate>
  10e06a:	9b03      	ldr	r3, [sp, #12]
  10e06c:	4283      	cmp	r3, r0
  10e06e:	f040 808f 	bne.w	10e190 <res_clk_set_rate+0x1d4>
                                                   false)) {
                ret |= res_clk_set_rate(new_parent,
                                        INVALID_PER_ID, req.best_prate);
            }

            if (clk->set_rate) {
  10e072:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
  10e076:	2b00      	cmp	r3, #0
  10e078:	f000 80a3 	beq.w	10e1c2 <res_clk_set_rate+0x206>
                ret |= clk->set_rate(clk, req.best_prate, rate);
  10e07c:	4652      	mov	r2, r10
  10e07e:	4620      	mov	r0, r4
  10e080:	9906      	ldr	r1, [sp, #24]
  10e082:	4798      	blx	r3
            }
            else {
                ASSERT(0);
            }

            ret |= clk->set_parent(clk, req.best_parent_index);
  10e084:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
  10e088:	9907      	ldr	r1, [sp, #28]
                ret |= clk->set_rate(clk, req.best_prate, rate);
  10e08a:	4606      	mov	r6, r0
            ret |= clk->set_parent(clk, req.best_parent_index);
  10e08c:	4620      	mov	r0, r4
  10e08e:	4798      	blx	r3
            clk->cur_parent_index = req.best_parent_index;
  10e090:	9b07      	ldr	r3, [sp, #28]
  10e092:	63a3      	str	r3, [r4, #56]	; 0x38
            ret |= clk->set_parent(clk, req.best_parent_index);
  10e094:	4330      	orrs	r0, r6
  10e096:	4305      	orrs	r5, r0

            //change parent, need dec refcount from old parent.

            if (oldrefcnt != 0) {
  10e098:	f1b9 0f00 	cmp.w	r9, #0
  10e09c:	d006      	beq.n	10e0ac <res_clk_set_rate+0xf0>
                res_clk_dec_refcount(clk->parents[oldpindex], INVALID_PER_ID);
  10e09e:	2101      	movs	r1, #1
  10e0a0:	f108 0810 	add.w	r8, r8, #16
  10e0a4:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  10e0a8:	f7ff f876 	bl	10d198 <res_clk_dec_refcount>
            else {
                ASSERT(0);
            }
        }

        res_clk_inc_refcount(clk, per_id, true);
  10e0ac:	4639      	mov	r1, r7
  10e0ae:	4620      	mov	r0, r4
  10e0b0:	2201      	movs	r2, #1
  10e0b2:	f7ff f8a1 	bl	10d1f8 <res_clk_inc_refcount>
    }

    return ret;
}
  10e0b6:	4628      	mov	r0, r5
  10e0b8:	b009      	add	sp, #36	; 0x24
  10e0ba:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_inc_refcount(clk, per_id, false);
  10e0be:	2200      	movs	r2, #0
  10e0c0:	f7ff f89a 	bl	10d1f8 <res_clk_inc_refcount>
  10e0c4:	4605      	mov	r5, r0
}
  10e0c6:	4628      	mov	r0, r5
  10e0c8:	b009      	add	sp, #36	; 0x24
  10e0ca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_dec_refcount(clk, per_id);
  10e0ce:	f7ff f863 	bl	10d198 <res_clk_dec_refcount>
  10e0d2:	4605      	mov	r5, r0
}
  10e0d4:	4628      	mov	r0, r5
  10e0d6:	b009      	add	sp, #36	; 0x24
  10e0d8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            res_clk_inc_refcount(clk, per_id, true);
  10e0dc:	4639      	mov	r1, r7
  10e0de:	4620      	mov	r0, r4
  10e0e0:	2201      	movs	r2, #1
            return ret;
  10e0e2:	2500      	movs	r5, #0
            res_clk_inc_refcount(clk, per_id, true);
  10e0e4:	f7ff f888 	bl	10d1f8 <res_clk_inc_refcount>
}
  10e0e8:	4628      	mov	r0, r5
  10e0ea:	b009      	add	sp, #36	; 0x24
  10e0ec:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            CLK_TRACE(CRITICAL,
  10e0f0:	4601      	mov	r1, r0
  10e0f2:	4620      	mov	r0, r4
  10e0f4:	f7fe fee4 	bl	10cec0 <res_clk_get_rate>
  10e0f8:	4653      	mov	r3, r10
  10e0fa:	f104 0108 	add.w	r1, r4, #8
  10e0fe:	4602      	mov	r2, r0
  10e100:	f24c 60c4 	movw	r0, #50884	; 0xc6c4
  10e104:	f2c0 0011 	movt	r0, #17
  10e108:	f006 fb7c 	bl	114804 <printf>
            if (!set_rate_overwrite_allow) {
  10e10c:	f240 1380 	movw	r3, #384	; 0x180
  10e110:	f2c0 0313 	movt	r3, #19
  10e114:	681b      	ldr	r3, [r3, #0]
  10e116:	2b00      	cmp	r3, #0
  10e118:	f47f af75 	bne.w	10e006 <res_clk_set_rate+0x4a>
                ASSERT(0);
  10e11c:	f649 0384 	movw	r3, #39044	; 0x9884
  10e120:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10e124:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e128:	f2c0 0311 	movt	r3, #17
  10e12c:	4630      	mov	r0, r6
  10e12e:	f2c0 0211 	movt	r2, #17
  10e132:	9300      	str	r3, [sp, #0]
  10e134:	f2c0 0111 	movt	r1, #17
  10e138:	f240 533e 	movw	r3, #1342	; 0x53e
  10e13c:	f005 fb2e 	bl	11379c <_panic>
        else if (clk->cur_parent_index != -1
  10e140:	f1b8 3fff 	cmp.w	r8, #4294967295	; 0xffffffff
  10e144:	d108      	bne.n	10e158 <res_clk_set_rate+0x19c>
            if (clk->set_rate) {
  10e146:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
  10e14a:	b343      	cbz	r3, 10e19e <res_clk_set_rate+0x1e2>
                ret |= clk->set_rate(clk, req.best_prate, rate);
  10e14c:	4652      	mov	r2, r10
  10e14e:	4620      	mov	r0, r4
  10e150:	9906      	ldr	r1, [sp, #24]
  10e152:	4798      	blx	r3
  10e154:	4605      	mov	r5, r0
  10e156:	e7a9      	b.n	10e0ac <res_clk_set_rate+0xf0>
                 && req.best_prate != res_clk_get_rate(clk->parents[clk->cur_parent_index],
  10e158:	2100      	movs	r1, #0
  10e15a:	f108 0810 	add.w	r8, r8, #16
  10e15e:	9d06      	ldr	r5, [sp, #24]
  10e160:	f854 0028 	ldr.w	r0, [r4, r8, lsl #2]
  10e164:	f7fe feac 	bl	10cec0 <res_clk_get_rate>
  10e168:	4285      	cmp	r5, r0
  10e16a:	d0ec      	beq.n	10e146 <res_clk_set_rate+0x18a>
            ret |= res_clk_set_rate(clk->parents[clk->cur_parent_index],
  10e16c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  10e16e:	2101      	movs	r1, #1
  10e170:	9a06      	ldr	r2, [sp, #24]
  10e172:	3310      	adds	r3, #16
  10e174:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
  10e178:	f7ff ff20 	bl	10dfbc <res_clk_set_rate>
            if (clk->set_rate) {
  10e17c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
            ret |= res_clk_set_rate(clk->parents[clk->cur_parent_index],
  10e180:	4605      	mov	r5, r0
            if (clk->set_rate) {
  10e182:	b383      	cbz	r3, 10e1e6 <res_clk_set_rate+0x22a>
                ret |= clk->set_rate(clk, req.best_prate, rate);
  10e184:	4652      	mov	r2, r10
  10e186:	4620      	mov	r0, r4
  10e188:	9906      	ldr	r1, [sp, #24]
  10e18a:	4798      	blx	r3
  10e18c:	4305      	orrs	r5, r0
            if (clk->set_rate) {
  10e18e:	e78d      	b.n	10e0ac <res_clk_set_rate+0xf0>
                ret |= res_clk_set_rate(new_parent,
  10e190:	4658      	mov	r0, r11
  10e192:	2101      	movs	r1, #1
  10e194:	9a06      	ldr	r2, [sp, #24]
  10e196:	f7ff ff11 	bl	10dfbc <res_clk_set_rate>
  10e19a:	4605      	mov	r5, r0
  10e19c:	e769      	b.n	10e072 <res_clk_set_rate+0xb6>
                ASSERT(0);
  10e19e:	f649 0384 	movw	r3, #39044	; 0x9884
  10e1a2:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10e1a6:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e1aa:	f2c0 0311 	movt	r3, #17
  10e1ae:	4630      	mov	r0, r6
  10e1b0:	f2c0 0211 	movt	r2, #17
  10e1b4:	9300      	str	r3, [sp, #0]
  10e1b6:	f2c0 0111 	movt	r1, #17
  10e1ba:	f240 537d 	movw	r3, #1405	; 0x57d
  10e1be:	f005 faed 	bl	11379c <_panic>
                ASSERT(0);
  10e1c2:	f649 0384 	movw	r3, #39044	; 0x9884
  10e1c6:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10e1ca:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e1ce:	f2c0 0311 	movt	r3, #17
  10e1d2:	4630      	mov	r0, r6
  10e1d4:	f2c0 0211 	movt	r2, #17
  10e1d8:	9300      	str	r3, [sp, #0]
  10e1da:	f2c0 0111 	movt	r1, #17
  10e1de:	f240 535f 	movw	r3, #1375	; 0x55f
  10e1e2:	f005 fadb 	bl	11379c <_panic>
                ASSERT(0);
  10e1e6:	f649 0384 	movw	r3, #39044	; 0x9884
  10e1ea:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10e1ee:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e1f2:	f2c0 0311 	movt	r3, #17
  10e1f6:	4630      	mov	r0, r6
  10e1f8:	f2c0 0211 	movt	r2, #17
  10e1fc:	9300      	str	r3, [sp, #0]
  10e1fe:	f2c0 0111 	movt	r1, #17
  10e202:	f240 5375 	movw	r3, #1397	; 0x575
  10e206:	f005 fac9 	bl	11379c <_panic>
  10e20a:	bf00      	nop

0010e20c <find_config_in_database>:
{
  10e20c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    int size = clk->pll.ratetable_size;
  10e210:	f8d0 9088 	ldr.w	r9, [r0, #136]	; 0x88
    for (i = 0; i < size; i++)
  10e214:	f1b9 0f00 	cmp.w	r9, #0
  10e218:	dd14      	ble.n	10e244 <find_config_in_database+0x38>
  10e21a:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
  10e21e:	4690      	mov	r8, r2
  10e220:	460f      	mov	r7, r1
  10e222:	2400      	movs	r4, #0
  10e224:	3d04      	subs	r5, #4
  10e226:	e001      	b.n	10e22c <find_config_in_database+0x20>
  10e228:	45a1      	cmp	r9, r4
  10e22a:	d00b      	beq.n	10e244 <find_config_in_database+0x38>
        if (calculate_pll_rate(clk->pll.ratetable[i], plldiv) == freq) {
  10e22c:	f855 6f04 	ldr.w	r6, [r5, #4]!
  10e230:	4639      	mov	r1, r7
  10e232:	4630      	mov	r0, r6
    for (i = 0; i < size; i++)
  10e234:	3401      	adds	r4, #1
        if (calculate_pll_rate(clk->pll.ratetable[i], plldiv) == freq) {
  10e236:	f7fe fda7 	bl	10cd88 <calculate_pll_rate>
  10e23a:	4540      	cmp	r0, r8
  10e23c:	d1f4      	bne.n	10e228 <find_config_in_database+0x1c>
}
  10e23e:	4630      	mov	r0, r6
  10e240:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    return NULL;
  10e244:	2600      	movs	r6, #0
}
  10e246:	4630      	mov	r0, r6
  10e248:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}

0010e24c <clk_set_rate>:
    if (!is_pll(clk)) {
  10e24c:	6803      	ldr	r3, [r0, #0]
{
  10e24e:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  10e252:	4614      	mov	r4, r2
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10e254:	1f5a      	subs	r2, r3, #5
  10e256:	2a65      	cmp	r2, #101	; 0x65
{
  10e258:	4605      	mov	r5, r0
  10e25a:	b08e      	sub	sp, #56	; 0x38
  10e25c:	4676      	mov	r6, r14
  10e25e:	4688      	mov	r8, r1
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10e260:	d943      	bls.n	10e2ea <clk_set_rate+0x9e>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10e262:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10e266:	2a06      	cmp	r2, #6
  10e268:	d977      	bls.n	10e35a <clk_set_rate+0x10e>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10e26a:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10e26e:	2a06      	cmp	r2, #6
  10e270:	f240 80a6 	bls.w	10e3c0 <clk_set_rate+0x174>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10e274:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10e278:	2a54      	cmp	r2, #84	; 0x54
  10e27a:	f240 80bc 	bls.w	10e3f6 <clk_set_rate+0x1aa>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10e27e:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10e280:	2b41      	cmp	r3, #65	; 0x41
  10e282:	f200 81e6 	bhi.w	10e652 <clk_set_rate+0x406>
        return set_ckgen_uuu_rate(clk->resid, clk->uuu.uuu_type, prate, freq);
  10e286:	f8d5 9004 	ldr.w	r9, [r5, #4]
    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10e28a:	af02      	add	r7, sp, #8
  10e28c:	4648      	mov	r0, r9
  10e28e:	4639      	mov	r1, r7
  10e290:	f8d5 5088 	ldr.w	r5, [r5, #136]	; 0x88
  10e294:	f7fe fe32 	bl	10cefc <get_ckgen_uuu_ctl>
  10e298:	2800      	cmp	r0, #0
  10e29a:	f2c0 81a2 	blt.w	10e5e2 <clk_set_rate+0x396>
    if (uuu_type == UUU_SEL0 || uuu_type == UUU_SEL1) { //dummy node.
  10e29e:	2d01      	cmp	r5, #1
  10e2a0:	d957      	bls.n	10e352 <clk_set_rate+0x106>
    else if (uuu_type >= UUU_M && uuu_type <= UUU_Q) {
  10e2a2:	1eab      	subs	r3, r5, #2
  10e2a4:	2b03      	cmp	r3, #3
  10e2a6:	f200 81c2 	bhi.w	10e62e <clk_set_rate+0x3e2>
    div = prate / freq;
  10e2aa:	fbb8 f4f4 	udiv	r4, r8, r4
    ASSERT(div <= maxdiv);
  10e2ae:	2c10      	cmp	r4, #16
  10e2b0:	f200 8173 	bhi.w	10e59a <clk_set_rate+0x34e>
    if (uuu_type == UUU_M) {
  10e2b4:	2d02      	cmp	r5, #2
  10e2b6:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
  10e2ba:	f004 040f 	and.w	r4, r4, #15
  10e2be:	f000 80e5 	beq.w	10e48c <clk_set_rate+0x240>
    else if (uuu_type == UUU_N) {
  10e2c2:	2d03      	cmp	r5, #3
  10e2c4:	f000 813d 	beq.w	10e542 <clk_set_rate+0x2f6>
    else if (uuu_type == UUU_P) {
  10e2c8:	2d04      	cmp	r5, #4
        ctl.p_div = div - 1;
  10e2ca:	f89d 3008 	ldrb.w	r3, [r13, #8]
  10e2ce:	bf0c      	ite	eq
  10e2d0:	f364 1307 	bfieq	r3, r4, #4, #4
        ctl.q_div = div - 1;
  10e2d4:	f364 0303 	bfine	r3, r4, #0, #4
  10e2d8:	f88d 3008 	strb.w	r3, [r13, #8]
    ret |= set_ckgen_uuu_ctl(resid, &ctl);
  10e2dc:	4639      	mov	r1, r7
  10e2de:	4648      	mov	r0, r9
  10e2e0:	f7fe fe2c 	bl	10cf3c <set_ckgen_uuu_ctl>
}
  10e2e4:	b00e      	add	sp, #56	; 0x38
  10e2e6:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  10e2ea:	f7ff f9d9 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10e2ee:	b388      	cbz	r0, 10e354 <clk_set_rate+0x108>
    if (is_pll(clk)) {
  10e2f0:	682b      	ldr	r3, [r5, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10e2f2:	1f5a      	subs	r2, r3, #5
  10e2f4:	2a65      	cmp	r2, #101	; 0x65
  10e2f6:	d8b4      	bhi.n	10e262 <clk_set_rate+0x16>
    pll_config_t cur = {0};
  10e2f8:	2230      	movs	r2, #48	; 0x30
  10e2fa:	af02      	add	r7, sp, #8
  10e2fc:	2100      	movs	r1, #0
  10e2fe:	4638      	mov	r0, r7
  10e300:	f005 eb54 	blx	1139ac <memset>
    pll_handle_t pll =  hal_pll_create_handle(clk->resid);
  10e304:	6868      	ldr	r0, [r5, #4]
    int plldiv = clk->pll.plldiv;
  10e306:	f8d5 a090 	ldr.w	r10, [r5, #144]	; 0x90
    pll_handle_t pll =  hal_pll_create_handle(clk->resid);
  10e30a:	f001 fbdd 	bl	10fac8 <hal_pll_create_handle>
    if (pll == (pll_handle_t)0) {
  10e30e:	4681      	mov	r9, r0
  10e310:	b1f8      	cbz	r0, 10e352 <clk_set_rate+0x106>
    hal_pll_get_config(pll, &cur);
  10e312:	4639      	mov	r1, r7
  10e314:	f001 fc48 	bl	10fba8 <hal_pll_get_config>
    stuff_valid_value(&cur);
  10e318:	4638      	mov	r0, r7
  10e31a:	f7f9 ff6f 	bl	1081fc <stuff_valid_value>
    if (plldiv == PLL_DUMMY_ROOT) { //will ignore the prate
  10e31e:	f1ba 0f05 	cmp.w	r10, #5
  10e322:	f000 80d0 	beq.w	10e4c6 <clk_set_rate+0x27a>
    else if (plldiv == PLL_ROOT) {
  10e326:	f1ba 0f00 	cmp.w	r10, #0
  10e32a:	f000 808d 	beq.w	10e448 <clk_set_rate+0x1fc>
    else if (plldiv >= PLL_DIVA && plldiv <= PLL_DIVD) {
  10e32e:	f10a 33ff 	add.w	r3, r10, #4294967295	; 0xffffffff
  10e332:	2b03      	cmp	r3, #3
        cur.out_div[plldiv - 1] = div;
  10e334:	bf9f      	itttt	ls
  10e336:	ab0e      	addls	r3, sp, #56	; 0x38
        div = prate / rate;
  10e338:	fbb8 f4f4 	udivls	r4, r8, r4
        cur.out_div[plldiv - 1] = div;
  10e33c:	eb03 0a8a 	addls.w	r10, r3, r10, lsl #2
  10e340:	f84a 4c14 	strls.w	r4, [r10, #-20]
    hal_pll_config(pll, &cur);
  10e344:	4648      	mov	r0, r9
  10e346:	4639      	mov	r1, r7
  10e348:	f001 fbe0 	bl	10fb0c <hal_pll_config>
    hal_pll_delete_handle(pll);
  10e34c:	4648      	mov	r0, r9
  10e34e:	f001 fbdb 	bl	10fb08 <hal_pll_delete_handle>
        return 0;
  10e352:	2000      	movs	r0, #0
}
  10e354:	b00e      	add	sp, #56	; 0x38
  10e356:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        return set_ckgen_bus_rate(clk->resid, prate, freq);
  10e35a:	686d      	ldr	r5, [r5, #4]
    if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10e35c:	af02      	add	r7, sp, #8
  10e35e:	4628      	mov	r0, r5
  10e360:	4639      	mov	r1, r7
  10e362:	f7ff f921 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10e366:	2800      	cmp	r0, #0
  10e368:	f2c0 813b 	blt.w	10e5e2 <clk_set_rate+0x396>
    div = prate / freq;
  10e36c:	fbb8 f4f4 	udiv	r4, r8, r4
    for (i = 1; i <= prediv_max; i++) {
  10e370:	2201      	movs	r2, #1
        for (i = 1; i <= post0div_max; i++) {
  10e372:	4610      	mov	r0, r2
        for (j = 1; j <= postdiv_max; j++) {
  10e374:	2301      	movs	r3, #1
  10e376:	e004      	b.n	10e382 <clk_set_rate+0x136>
  10e378:	3301      	adds	r3, #1
  10e37a:	2b41      	cmp	r3, #65	; 0x41
  10e37c:	4410      	add	r0, r2
  10e37e:	f000 808c 	beq.w	10e49a <clk_set_rate+0x24e>
            if ((i * j) == (int)div) {
  10e382:	4284      	cmp	r4, r0
  10e384:	d1f8      	bne.n	10e378 <clk_set_rate+0x12c>
    ctl.pre_div_num_a = ctl.pre_div_num_b = i - 1;
  10e386:	3a01      	subs	r2, #1
    ctl.post_div_num = j - 1;
  10e388:	f89d 6009 	ldrb.w	r6, [r13, #9]
    ctl.pre_div_num_a = ctl.pre_div_num_b = i - 1;
  10e38c:	f002 0207 	and.w	r2, r2, #7
  10e390:	f89d 400a 	ldrb.w	r4, [r13, #10]
    ctl.post_div_num = j - 1;
  10e394:	3b01      	subs	r3, #1
  10e396:	f363 0687 	bfi	r6, r3, #2, #6
    ctl.pre_div_num_a = ctl.pre_div_num_b = i - 1;
  10e39a:	f89d 3008 	ldrb.w	r3, [r13, #8]
  10e39e:	f362 1406 	bfi	r4, r2, #4, #3
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10e3a2:	4639      	mov	r1, r7
    ctl.pre_div_num_a = ctl.pre_div_num_b = i - 1;
  10e3a4:	f362 1306 	bfi	r3, r2, #4, #3
    ctl.post_div_num = j - 1;
  10e3a8:	f88d 6009 	strb.w	r6, [r13, #9]
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10e3ac:	4628      	mov	r0, r5
    ctl.pre_div_num_a = ctl.pre_div_num_b = i - 1;
  10e3ae:	f88d 400a 	strb.w	r4, [r13, #10]
  10e3b2:	f88d 3008 	strb.w	r3, [r13, #8]
    ret |= set_ckgen_bus_ctl(resid, &ctl, NULL);
  10e3b6:	f7ff f8d1 	bl	10d55c <set_ckgen_bus_ctl.constprop.31>
}
  10e3ba:	b00e      	add	sp, #56	; 0x38
  10e3bc:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        return set_ckgen_core_rate(clk->resid, prate, freq);
  10e3c0:	686d      	ldr	r5, [r5, #4]
    if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10e3c2:	a902      	add	r1, sp, #8
  10e3c4:	4628      	mov	r0, r5
  10e3c6:	f7ff f807 	bl	10d3d8 <get_ckgen_core_ctl>
  10e3ca:	2800      	cmp	r0, #0
  10e3cc:	f2c0 8109 	blt.w	10e5e2 <clk_set_rate+0x396>
    div = prate / freq;
  10e3d0:	fbb8 f4f4 	udiv	r4, r8, r4
    ASSERT(div <= postdiv_max);
  10e3d4:	2c40      	cmp	r4, #64	; 0x40
  10e3d6:	f200 80f2 	bhi.w	10e5be <clk_set_rate+0x372>
    ctl.post_div_num = div - 1;
  10e3da:	3c01      	subs	r4, #1
  10e3dc:	f89d 3009 	ldrb.w	r3, [r13, #9]
  10e3e0:	f364 0387 	bfi	r3, r4, #2, #6
    ret |= set_ckgen_core_ctl(resid, &ctl);
  10e3e4:	4628      	mov	r0, r5
  10e3e6:	a902      	add	r1, sp, #8
    ctl.post_div_num = div - 1;
  10e3e8:	f88d 3009 	strb.w	r3, [r13, #9]
    ret |= set_ckgen_core_ctl(resid, &ctl);
  10e3ec:	f7ff f818 	bl	10d420 <set_ckgen_core_ctl>
}
  10e3f0:	b00e      	add	sp, #56	; 0x38
  10e3f2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        return set_ckgen_ip_rate(clk->resid, prate, freq);
  10e3f6:	686d      	ldr	r5, [r5, #4]
    if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10e3f8:	af02      	add	r7, sp, #8
  10e3fa:	4628      	mov	r0, r5
  10e3fc:	4639      	mov	r1, r7
  10e3fe:	f7ff f833 	bl	10d468 <get_ckgen_ip_ctl>
  10e402:	2800      	cmp	r0, #0
  10e404:	f2c0 80ed 	blt.w	10e5e2 <clk_set_rate+0x396>
    div = prate / freq;
  10e408:	fbb8 f4f4 	udiv	r4, r8, r4
    for (i = 1; i <= prediv_max; i++) {
  10e40c:	2101      	movs	r1, #1
        return -1;
  10e40e:	460a      	mov	r2, r1
        for (j = 1; j <= postdiv_max; j++) {
  10e410:	2301      	movs	r3, #1
  10e412:	e004      	b.n	10e41e <clk_set_rate+0x1d2>
  10e414:	3301      	adds	r3, #1
  10e416:	2b41      	cmp	r3, #65	; 0x41
  10e418:	440a      	add	r2, r1
  10e41a:	f000 80a8 	beq.w	10e56e <clk_set_rate+0x322>
            if ((i * j) == (int)div) {
  10e41e:	42a2      	cmp	r2, r4
  10e420:	d1f8      	bne.n	10e414 <clk_set_rate+0x1c8>
    ctl.pre_div_num = i - 1;
  10e422:	3901      	subs	r1, #1
  10e424:	f89d 4008 	ldrb.w	r4, [r13, #8]
    ctl.post_div_num = j - 1;
  10e428:	3b01      	subs	r3, #1
  10e42a:	f89d 2009 	ldrb.w	r2, [r13, #9]
    ctl.pre_div_num = i - 1;
  10e42e:	f361 1406 	bfi	r4, r1, #4, #3
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10e432:	4628      	mov	r0, r5
    ctl.post_div_num = j - 1;
  10e434:	f363 0287 	bfi	r2, r3, #2, #6
    ctl.pre_div_num = i - 1;
  10e438:	f88d 4008 	strb.w	r4, [r13, #8]
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10e43c:	4639      	mov	r1, r7
    ctl.post_div_num = j - 1;
  10e43e:	f88d 2009 	strb.w	r2, [r13, #9]
    ret |= set_ckgen_ip_ctl(resid, &ctl);
  10e442:	f7ff f835 	bl	10d4b0 <set_ckgen_ip_ctl>
  10e446:	e785      	b.n	10e354 <clk_set_rate+0x108>
        div = prate / rate;
  10e448:	fbb8 f4f4 	udiv	r4, r8, r4
        for (i = 1; i <= post0div_max; i++) {
  10e44c:	2101      	movs	r1, #1
    unsigned long tmp = 0;
  10e44e:	460a      	mov	r2, r1
            for (j = 1; j <= post1div_max; j++) {
  10e450:	2301      	movs	r3, #1
                if (i < j) { continue; } //post0 >= post1
  10e452:	4299      	cmp	r1, r3
  10e454:	db01      	blt.n	10e45a <clk_set_rate+0x20e>
                if ((i * j) == (int)div) {
  10e456:	4294      	cmp	r4, r2
  10e458:	d07a      	beq.n	10e550 <clk_set_rate+0x304>
            for (j = 1; j <= post1div_max; j++) {
  10e45a:	3301      	adds	r3, #1
  10e45c:	2b08      	cmp	r3, #8
  10e45e:	440a      	add	r2, r1
  10e460:	d1f7      	bne.n	10e452 <clk_set_rate+0x206>
        for (i = 1; i <= post0div_max; i++) {
  10e462:	3101      	adds	r1, #1
  10e464:	2908      	cmp	r1, #8
  10e466:	d1f2      	bne.n	10e44e <clk_set_rate+0x202>
        ASSERT(i <= post0div_max && j <= post1div_max);
  10e468:	f24c 5348 	movw	r3, #50504	; 0xc548
  10e46c:	f24c 42cc 	movw	r2, #50380	; 0xc4cc
  10e470:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e474:	f2c0 0311 	movt	r3, #17
  10e478:	4630      	mov	r0, r6
  10e47a:	f2c0 0211 	movt	r2, #17
  10e47e:	9300      	str	r3, [sp, #0]
  10e480:	f2c0 0111 	movt	r1, #17
  10e484:	f44f 7393 	mov.w	r3, #294	; 0x126
  10e488:	f005 f988 	bl	11379c <_panic>
        ctl.m_div = div - 1;
  10e48c:	f89d 3009 	ldrb.w	r3, [r13, #9]
  10e490:	f364 1307 	bfi	r3, r4, #4, #4
  10e494:	f88d 3009 	strb.w	r3, [r13, #9]
  10e498:	e720      	b.n	10e2dc <clk_set_rate+0x90>
    for (i = 1; i <= prediv_max; i++) {
  10e49a:	3201      	adds	r2, #1
  10e49c:	2a09      	cmp	r2, #9
  10e49e:	f47f af68 	bne.w	10e372 <clk_set_rate+0x126>
    ASSERT(i <= prediv_max && j <= postdiv_max);
  10e4a2:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
  10e4a6:	f24c 5270 	movw	r2, #50544	; 0xc570
  10e4aa:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e4ae:	f2c0 0311 	movt	r3, #17
  10e4b2:	4630      	mov	r0, r6
  10e4b4:	f2c0 0211 	movt	r2, #17
  10e4b8:	9300      	str	r3, [sp, #0]
  10e4ba:	f2c0 0111 	movt	r1, #17
  10e4be:	f44f 7304 	mov.w	r3, #528	; 0x210
  10e4c2:	f005 f96b 	bl	11379c <_panic>
        if (clk->pll.moreprecise) {
  10e4c6:	f895 3098 	ldrb.w	r3, [r5, #152]	; 0x98
  10e4ca:	2b00      	cmp	r3, #0
  10e4cc:	d043      	beq.n	10e556 <clk_set_rate+0x30a>
    if (config->integer == 0) {
  10e4ce:	f895 c0a0 	ldrb.w	r12, [r5, #160]	; 0xa0
    unsigned long tmp = 0;
  10e4d2:	2300      	movs	r3, #0
            config = &clk->pll.config;
  10e4d4:	f105 009c 	add.w	r0, r5, #156	; 0x9c
    if (config->integer == 0) {
  10e4d8:	f1bc 0f00 	cmp.w	r12, #0
  10e4dc:	d10d      	bne.n	10e4fa <clk_set_rate+0x2ae>
        tmp = config->frac * (1000) / (FRACM / 1000);
  10e4de:	f8d5 30b8 	ldr.w	r3, [r5, #184]	; 0xb8
  10e4e2:	f24d 22f1 	movw	r2, #54001	; 0xd2f1
  10e4e6:	f6cf 2200 	movt	r2, #64000	; 0xfa00
  10e4ea:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
  10e4ee:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  10e4f2:	00db      	lsls	r3, r3, #3
  10e4f4:	fba2 2303 	umull	r2, r3, r2, r3
  10e4f8:	0b9b      	lsrs	r3, r3, #14
                24) / config->refdiv);
  10e4fa:	f8d5 e0a8 	ldr.w	r14, [r5, #168]	; 0xa8
  10e4fe:	2218      	movs	r2, #24
    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
  10e500:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
                24) / config->refdiv);
  10e504:	fbb2 f5fe 	udiv	r5, r2, r14
    freq = (tmp + (unsigned long)(config->fbdiv * (1000000))) * ((
  10e508:	ebc1 1241 	rsb	r2, r1, r1, lsl #5
  10e50c:	ebc2 1282 	rsb	r2, r2, r2, lsl #6
  10e510:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  10e514:	eb03 1382 	add.w	r3, r3, r2, lsl #6
  10e518:	fb05 f303 	mul.w	r3, r5, r3
            ASSERT(rate == calculate_pll_rate(&clk->pll.config, PLL_DUMMY_ROOT));
  10e51c:	429c      	cmp	r4, r3
  10e51e:	d175      	bne.n	10e60c <clk_set_rate+0x3c0>
            if (cur.integer) {
  10e520:	f89d 300d 	ldrb.w	r3, [r13, #13]
        cur.frac = config->frac;
  10e524:	69c2      	ldr	r2, [r0, #28]
  10e526:	9209      	str	r2, [sp, #36]	; 0x24
            if (cur.integer) {
  10e528:	ea1c 0f03 	tst.w	r12, r3
        cur.integer = config->integer;
  10e52c:	f88d c00c 	strb.w	r12, [r13, #12]
                cur.integer = false;
  10e530:	bf18      	it	ne
  10e532:	2300      	movne	r3, #0
        cur.fbdiv = config->fbdiv;
  10e534:	e9cd e105 	strd	r14, r1, [r13, #20]
                cur.integer = false;
  10e538:	bf1c      	itt	ne
  10e53a:	f88d 300c 	strbne.w	r3, [r13, #12]
                cur.frac = 0;
  10e53e:	9309      	strne	r3, [sp, #36]	; 0x24
  10e540:	e700      	b.n	10e344 <clk_set_rate+0xf8>
        ctl.n_div = div - 1;
  10e542:	f89d 3009 	ldrb.w	r3, [r13, #9]
  10e546:	f364 0303 	bfi	r3, r4, #0, #4
  10e54a:	f88d 3009 	strb.w	r3, [r13, #9]
  10e54e:	e6c5      	b.n	10e2dc <clk_set_rate+0x90>
        cur.postdiv[1] = j;
  10e550:	e9cd 1307 	strd	r1, r3, [r13, #28]
  10e554:	e6f6      	b.n	10e344 <clk_set_rate+0xf8>
            config = find_config_in_database(clk, plldiv, rate);
  10e556:	4622      	mov	r2, r4
  10e558:	4651      	mov	r1, r10
  10e55a:	4628      	mov	r0, r5
  10e55c:	f7ff fe56 	bl	10e20c <find_config_in_database>
        ASSERT(config != NULL);
  10e560:	2800      	cmp	r0, #0
  10e562:	d041      	beq.n	10e5e8 <clk_set_rate+0x39c>
  10e564:	f890 c004 	ldrb.w	r12, [r0, #4]
  10e568:	e9d0 e103 	ldrd	r14, r1, [r0, #12]
  10e56c:	e7d8      	b.n	10e520 <clk_set_rate+0x2d4>
    for (i = 1; i <= prediv_max; i++) {
  10e56e:	3101      	adds	r1, #1
  10e570:	2909      	cmp	r1, #9
  10e572:	f47f af4c 	bne.w	10e40e <clk_set_rate+0x1c2>
    ASSERT(i <= prediv_max && j <= postdiv_max);
  10e576:	f24c 53b4 	movw	r3, #50612	; 0xc5b4
  10e57a:	f24c 5270 	movw	r2, #50544	; 0xc570
  10e57e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e582:	f2c0 0311 	movt	r3, #17
  10e586:	4630      	mov	r0, r6
  10e588:	f2c0 0211 	movt	r2, #17
  10e58c:	9300      	str	r3, [sp, #0]
  10e58e:	f2c0 0111 	movt	r1, #17
  10e592:	f44f 736a 	mov.w	r3, #936	; 0x3a8
  10e596:	f005 f901 	bl	11379c <_panic>
    ASSERT(div <= maxdiv);
  10e59a:	f24c 53d8 	movw	r3, #50648	; 0xc5d8
  10e59e:	f24c 5270 	movw	r2, #50544	; 0xc570
  10e5a2:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e5a6:	f2c0 0311 	movt	r3, #17
  10e5aa:	4630      	mov	r0, r6
  10e5ac:	f2c0 0211 	movt	r2, #17
  10e5b0:	9300      	str	r3, [sp, #0]
  10e5b2:	f2c0 0111 	movt	r1, #17
  10e5b6:	f240 4355 	movw	r3, #1109	; 0x455
  10e5ba:	f005 f8ef 	bl	11379c <_panic>
    ASSERT(div <= postdiv_max);
  10e5be:	f24c 53a0 	movw	r3, #50592	; 0xc5a0
  10e5c2:	f24c 5270 	movw	r2, #50544	; 0xc570
  10e5c6:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e5ca:	f2c0 0311 	movt	r3, #17
  10e5ce:	4630      	mov	r0, r6
  10e5d0:	f2c0 0211 	movt	r2, #17
  10e5d4:	9300      	str	r3, [sp, #0]
  10e5d6:	f2c0 0111 	movt	r1, #17
  10e5da:	f240 23de 	movw	r3, #734	; 0x2de
  10e5de:	f005 f8dd 	bl	11379c <_panic>
        return -1;
  10e5e2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10e5e6:	e6b5      	b.n	10e354 <clk_set_rate+0x108>
  10e5e8:	f24c 5338 	movw	r3, #50488	; 0xc538
  10e5ec:	f24c 42cc 	movw	r2, #50380	; 0xc4cc
  10e5f0:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e5f4:	f2c0 0311 	movt	r3, #17
  10e5f8:	4630      	mov	r0, r6
  10e5fa:	f2c0 0211 	movt	r2, #17
  10e5fe:	9300      	str	r3, [sp, #0]
  10e600:	f2c0 0111 	movt	r1, #17
  10e604:	f44f 7382 	mov.w	r3, #260	; 0x104
  10e608:	f005 f8c8 	bl	11379c <_panic>
            ASSERT(rate == calculate_pll_rate(&clk->pll.config, PLL_DUMMY_ROOT));
  10e60c:	f24c 43f8 	movw	r3, #50424	; 0xc4f8
  10e610:	f24c 42cc 	movw	r2, #50380	; 0xc4cc
  10e614:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e618:	f2c0 0311 	movt	r3, #17
  10e61c:	4630      	mov	r0, r6
  10e61e:	f2c0 0211 	movt	r2, #17
  10e622:	9300      	str	r3, [sp, #0]
  10e624:	f2c0 0111 	movt	r1, #17
  10e628:	23fe      	movs	r3, #254	; 0xfe
  10e62a:	f005 f8b7 	bl	11379c <_panic>
        ASSERT(0);
  10e62e:	f649 0384 	movw	r3, #39044	; 0x9884
  10e632:	f24c 5270 	movw	r2, #50544	; 0xc570
  10e636:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e63a:	f2c0 0311 	movt	r3, #17
  10e63e:	4630      	mov	r0, r6
  10e640:	f2c0 0211 	movt	r2, #17
  10e644:	9300      	str	r3, [sp, #0]
  10e646:	f2c0 0111 	movt	r1, #17
  10e64a:	f44f 638a 	mov.w	r3, #1104	; 0x450
  10e64e:	f005 f8a5 	bl	11379c <_panic>
        ASSERT(0);
  10e652:	f649 0384 	movw	r3, #39044	; 0x9884
  10e656:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10e65a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e65e:	f2c0 0311 	movt	r3, #17
  10e662:	4630      	mov	r0, r6
  10e664:	f2c0 0211 	movt	r2, #17
  10e668:	9300      	str	r3, [sp, #0]
  10e66a:	f2c0 0111 	movt	r1, #17
  10e66e:	f240 2342 	movw	r3, #578	; 0x242
  10e672:	f005 f893 	bl	11379c <_panic>
  10e676:	bf00      	nop

0010e678 <get_pll_dummy_root_round_rate_clk>:
{
    int size = clk->pll.ratetable_size;
    int i;
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, rate;
    unsigned long diff;
    ASSERT(clk->pll.plldiv == PLL_DUMMY_ROOT);
  10e678:	f8d0 1090 	ldr.w	r1, [r0, #144]	; 0x90
{
  10e67c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    ASSERT(clk->pll.plldiv == PLL_DUMMY_ROOT);
  10e680:	2905      	cmp	r1, #5
{
  10e682:	b097      	sub	sp, #92	; 0x5c
    ASSERT(clk->pll.plldiv == PLL_DUMMY_ROOT);
  10e684:	f040 8117 	bne.w	10e8b6 <get_pll_dummy_root_round_rate_clk+0x23e>
  10e688:	4605      	mov	r5, r0
  10e68a:	461e      	mov	r6, r3

    if (clk->pll.moreprecise) {
  10e68c:	f890 4098 	ldrb.w	r4, [r0, #152]	; 0x98
  10e690:	bbac      	cbnz	r4, 10e6fe <get_pll_dummy_root_round_rate_clk+0x86>
    int size = clk->pll.ratetable_size;
  10e692:	f8d0 b088 	ldr.w	r11, [r0, #136]	; 0x88
        bestrate = rate;
        //printf("bestrate %lu freq %lu frac %u name %s\n", bestrate, freq, conf.frac, clk->name);
        return bestrate;
    }
    else {
        for (i = 0; i < size; i++) {
  10e696:	f1bb 0f00 	cmp.w	r11, #0
  10e69a:	bfc1      	itttt	gt
  10e69c:	f64a 1a10 	movwgt	r10, #43280	; 0xa910
  10e6a0:	46a0      	movgt	r8, r4
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, rate;
  10e6a2:	f04f 39ff 	movgt.w	r9, #4294967295	; 0xffffffff
  10e6a6:	f2c0 0a12 	movtgt	r10, #18
        for (i = 0; i < size; i++) {
  10e6aa:	dc0b      	bgt.n	10e6c4 <get_pll_dummy_root_round_rate_clk+0x4c>
  10e6ac:	e019      	b.n	10e6e2 <get_pll_dummy_root_round_rate_clk+0x6a>
            rate = calculate_pll_rate(clk->pll.ratetable[i], clk->pll.plldiv);

            //dprintf(CRITICAL, "pll %s req %lu round get rate %lu index %d\n", clk->name, freq, rate, i);
            if (!res_clk_is_valid_round_rate(clk, -1, rate, 0)) { continue; }

            diff = abs_clk(freq, rate);
  10e6ae:	1bf3      	subs	r3, r6, r7
            rate = calculate_pll_rate(clk->pll.ratetable[i], clk->pll.plldiv);
  10e6b0:	4599      	cmp	r9, r3
  10e6b2:	bf84      	itt	hi
  10e6b4:	4699      	movhi	r9, r3
  10e6b6:	463c      	movhi	r4, r7
        for (i = 0; i < size; i++) {
  10e6b8:	f108 0801 	add.w	r8, r8, #1
  10e6bc:	45c3      	cmp	r11, r8
  10e6be:	d010      	beq.n	10e6e2 <get_pll_dummy_root_round_rate_clk+0x6a>
  10e6c0:	f8d5 1090 	ldr.w	r1, [r5, #144]	; 0x90
            rate = calculate_pll_rate(clk->pll.ratetable[i], clk->pll.plldiv);
  10e6c4:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
  10e6c8:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
  10e6cc:	f7fe fb5c 	bl	10cd88 <calculate_pll_rate>
    if (round_rate_filter_en) {
  10e6d0:	f8da 3000 	ldr.w	r3, [r10]
  10e6d4:	4607      	mov	r7, r0
  10e6d6:	b943      	cbnz	r3, 10e6ea <get_pll_dummy_root_round_rate_clk+0x72>
            diff = abs_clk(freq, rate);
  10e6d8:	42b7      	cmp	r7, r6
  10e6da:	d3e8      	bcc.n	10e6ae <get_pll_dummy_root_round_rate_clk+0x36>

            //dprintf(CRITICAL, "pll %s req %lu round get rate %lu index %d diff %lu \n", clk->name, freq, rate, i, diff);
            if (diff == 0) {
  10e6dc:	1bbb      	subs	r3, r7, r6
  10e6de:	d1e7      	bne.n	10e6b0 <get_pll_dummy_root_round_rate_clk+0x38>
  10e6e0:	4634      	mov	r4, r6
        }
    }

    //dprintf(CRITICAL, "pll %s round get best %lu prate %lu\n", clk->name, bestrate, *prate);
    return bestrate;
}
  10e6e2:	4620      	mov	r0, r4
  10e6e4:	b017      	add	sp, #92	; 0x5c
  10e6e6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10e6ea:	4602      	mov	r2, r0
  10e6ec:	2300      	movs	r3, #0
  10e6ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10e6f2:	4628      	mov	r0, r5
  10e6f4:	f7ff fa9a 	bl	10dc2c <res_clk_is_valid_request>
            if (!res_clk_is_valid_round_rate(clk, -1, rate, 0)) { continue; }
  10e6f8:	2800      	cmp	r0, #0
  10e6fa:	d1ed      	bne.n	10e6d8 <get_pll_dummy_root_round_rate_clk+0x60>
  10e6fc:	e7dc      	b.n	10e6b8 <get_pll_dummy_root_round_rate_clk+0x40>
        pll_config_t conf = {0};
  10e6fe:	2230      	movs	r2, #48	; 0x30
  10e700:	2100      	movs	r1, #0
  10e702:	a80a      	add	r0, sp, #40	; 0x28
  10e704:	f005 e952 	blx	1139ac <memset>
        pll_handle_t pll =  hal_pll_create_handle(clk->resid);
  10e708:	6868      	ldr	r0, [r5, #4]
  10e70a:	f001 f9dd 	bl	10fac8 <hal_pll_create_handle>
        if (pll == (pll_handle_t)0) {
  10e70e:	4604      	mov	r4, r0
  10e710:	2800      	cmp	r0, #0
  10e712:	d0e6      	beq.n	10e6e2 <get_pll_dummy_root_round_rate_clk+0x6a>
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e714:	f64d 6283 	movw	r2, #56963	; 0xde83
        hal_pll_get_config(pll, &clk->pll.config);
  10e718:	f105 039c 	add.w	r3, r5, #156	; 0x9c
  10e71c:	4619      	mov	r1, r3
  10e71e:	461f      	mov	r7, r3
  10e720:	9303      	str	r3, [sp, #12]
    if (round_rate_filter_en) {
  10e722:	f64a 1b10 	movw	r11, #43280	; 0xa910
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e726:	9206      	str	r2, [sp, #24]
        hal_pll_get_config(pll, &clk->pll.config);
  10e728:	f001 fa3e 	bl	10fba8 <hal_pll_get_config>
        hal_pll_delete_handle(pll);
  10e72c:	4620      	mov	r0, r4
  10e72e:	f2c0 0b12 	movt	r11, #18
  10e732:	f001 f9e9 	bl	10fb08 <hal_pll_delete_handle>
        stuff_valid_value(&clk->pll.config);
  10e736:	4638      	mov	r0, r7
  10e738:	f7f9 fd60 	bl	1081fc <stuff_valid_value>
        conf.spread = clk->pll.config.spread;
  10e73c:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
  10e740:	930c      	str	r3, [sp, #48]	; 0x30
        bestrate = calculate_pll_rate(&clk->pll.config, clk->pll.plldiv);
  10e742:	4638      	mov	r0, r7
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e744:	9b06      	ldr	r3, [sp, #24]
        conf.downspread = clk->pll.config.downspread;
  10e746:	f895 20a2 	ldrb.w	r2, [r5, #162]	; 0xa2
        bestrate = calculate_pll_rate(&clk->pll.config, clk->pll.plldiv);
  10e74a:	f8d5 8090 	ldr.w	r8, [r5, #144]	; 0x90
        conf.integer = clk->pll.config.integer;
  10e74e:	f895 90a0 	ldrb.w	r9, [r5, #160]	; 0xa0
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e752:	f2c4 331b 	movt	r3, #17179	; 0x431b
        conf.spread_spectrum = clk->pll.config.spread_spectrum;
  10e756:	f895 40a1 	ldrb.w	r4, [r5, #161]	; 0xa1
        conf.frac = clk->pll.config.frac;
  10e75a:	f8d5 70b8 	ldr.w	r7, [r5, #184]	; 0xb8
        bestrate = calculate_pll_rate(&clk->pll.config, clk->pll.plldiv);
  10e75e:	4641      	mov	r1, r8
        conf.downspread = clk->pll.config.downspread;
  10e760:	f88d 202e 	strb.w	r2, [r13, #46]	; 0x2e
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, rate;
  10e764:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
        conf.integer = clk->pll.config.integer;
  10e768:	f88d 902c 	strb.w	r9, [r13, #44]	; 0x2c
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e76c:	9306      	str	r3, [sp, #24]
        conf.spread_spectrum = clk->pll.config.spread_spectrum;
  10e76e:	f88d 402d 	strb.w	r4, [r13, #45]	; 0x2d
        freq = MIN(freq, 3200000000);
  10e772:	f44f 5400 	mov.w	r4, #8192	; 0x2000
        conf.frac = clk->pll.config.frac;
  10e776:	9711      	str	r7, [sp, #68]	; 0x44
        bestrate = calculate_pll_rate(&clk->pll.config, clk->pll.plldiv);
  10e778:	f7fe fb06 	bl	10cd88 <calculate_pll_rate>
            fbdiv_min = 16;
  10e77c:	f1b9 0f00 	cmp.w	r9, #0
  10e780:	bf0c      	ite	eq
  10e782:	2214      	moveq	r2, #20
  10e784:	2210      	movne	r2, #16
        freq = MAX(freq, 800000000);
  10e786:	f44f 6300 	mov.w	r3, #2048	; 0x800
        freq = MIN(freq, 3200000000);
  10e78a:	f6cb 64bc 	movt	r4, #48828	; 0xbebc
        for (refdiv = 1; refdiv <= refdiv_max; refdiv++) {
  10e78e:	f04f 0901 	mov.w	r9, #1
        freq = MAX(freq, 800000000);
  10e792:	f6c2 73af 	movt	r3, #12207	; 0x2faf
            fbdiv_min = 16;
  10e796:	9208      	str	r2, [sp, #32]
  10e798:	bf08      	it	eq
  10e79a:	f44f 72a0 	moveq.w	r2, #320	; 0x140
        bestrate = calculate_pll_rate(&clk->pll.config, clk->pll.plldiv);
  10e79e:	9004      	str	r0, [sp, #16]
            fbdiv_min = 16;
  10e7a0:	bf18      	it	ne
  10e7a2:	f44f 7220 	movne.w	r2, #640	; 0x280
  10e7a6:	9207      	str	r2, [sp, #28]
  10e7a8:	bf0c      	ite	eq
  10e7aa:	2202      	moveq	r2, #2
  10e7ac:	2204      	movne	r2, #4
        freq = MIN(freq, 3200000000);
  10e7ae:	42b4      	cmp	r4, r6
  10e7b0:	bf28      	it	cs
  10e7b2:	4634      	movcs	r4, r6
            fbdiv_min = 16;
  10e7b4:	9209      	str	r2, [sp, #36]	; 0x24
        freq = MAX(freq, 800000000);
  10e7b6:	429c      	cmp	r4, r3
  10e7b8:	bf38      	it	cc
  10e7ba:	461c      	movcc	r4, r3
  10e7bc:	462b      	mov	r3, r5
  10e7be:	464d      	mov	r5, r9
  10e7c0:	4699      	mov	r9, r3
  10e7c2:	9405      	str	r4, [sp, #20]
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e7c4:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  10e7c8:	ebc7 1247 	rsb	r2, r7, r7, lsl #5
  10e7cc:	9905      	ldr	r1, [sp, #20]
  10e7ce:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  10e7d2:	ebc2 1282 	rsb	r2, r2, r2, lsl #6
  10e7d6:	fba3 1301 	umull	r1, r3, r3, r1
  10e7da:	eb07 07c2 	add.w	r7, r7, r2, lsl #3
  10e7de:	f3c7 4787 	ubfx	r7, r7, #18, #8
  10e7e2:	ebc7 1713 	rsb	r7, r7, r3, lsr #4
  10e7e6:	9b06      	ldr	r3, [sp, #24]
  10e7e8:	fba3 3707 	umull	r3, r7, r3, r7
            fbdivmin = MAX(fbtmp - 2, fbdiv_min);
  10e7ec:	9b08      	ldr	r3, [sp, #32]
            int fbtmp = ((freq * refdiv / 24) - (conf.frac * 1000000) / 16777216) /
  10e7ee:	0cbf      	lsrs	r7, r7, #18
            fbdivmin = MAX(fbtmp - 2, fbdiv_min);
  10e7f0:	1ebe      	subs	r6, r7, #2
  10e7f2:	429e      	cmp	r6, r3
  10e7f4:	bfb8      	it	lt
  10e7f6:	461e      	movlt	r6, r3
            fbdivmax = MIN(fbtmp + 2, fbdiv_max);
  10e7f8:	3702      	adds	r7, #2
  10e7fa:	9b07      	ldr	r3, [sp, #28]
  10e7fc:	429f      	cmp	r7, r3
  10e7fe:	bfa8      	it	ge
  10e800:	461f      	movge	r7, r3
            for (fbdiv = fbdivmin; fbdiv <= fbdivmax; fbdiv++) {
  10e802:	42be      	cmp	r6, r7
  10e804:	dd1e      	ble.n	10e844 <get_pll_dummy_root_round_rate_clk+0x1cc>
  10e806:	e04d      	b.n	10e8a4 <get_pll_dummy_root_round_rate_clk+0x22c>
                diff = abs_clk(freq, rate);
  10e808:	eba4 0308 	sub.w	r3, r4, r8
                if (diff < bestratediff) {
  10e80c:	459a      	cmp	r10, r3
                    clk->pll.config = conf;
  10e80e:	bf81      	itttt	hi
  10e810:	469a      	movhi	r10, r3
  10e812:	f10d 0e28 	addhi.w	r14, r13, #40	; 0x28
                rate = calculate_pll_rate(&conf, clk->pll.plldiv);
  10e816:	f8cd 8010 	strhi.w	r8, [r13, #16]
                    clk->pll.config = conf;
  10e81a:	f8dd c00c 	ldrhi.w	r12, [r13, #12]
  10e81e:	bf81      	itttt	hi
  10e820:	e8be 000f 	ldmiahi.w	r14!, {r0, r1, r2, r3}
  10e824:	e8ac 000f 	stmiahi.w	r12!, {r0, r1, r2, r3}
  10e828:	e8be 000f 	ldmiahi.w	r14!, {r0, r1, r2, r3}
  10e82c:	e8ac 000f 	stmiahi.w	r12!, {r0, r1, r2, r3}
  10e830:	bf84      	itt	hi
  10e832:	e89e 000f 	ldmiahi.w	r14, {r0, r1, r2, r3}
  10e836:	e88c 000f 	stmiahi.w	r12, {r0, r1, r2, r3}
  10e83a:	f8d9 8090 	ldr.w	r8, [r9, #144]	; 0x90
            for (fbdiv = fbdivmin; fbdiv <= fbdivmax; fbdiv++) {
  10e83e:	3601      	adds	r6, #1
  10e840:	42b7      	cmp	r7, r6
  10e842:	db2f      	blt.n	10e8a4 <get_pll_dummy_root_round_rate_clk+0x22c>
                conf.refdiv = refdiv;
  10e844:	e9cd 560d 	strd	r5, r6, [r13, #52]	; 0x34
    if (clk->pll.plldiv == PLL_DUMMY_ROOT) { // check the pll limit
  10e848:	f1b8 0f05 	cmp.w	r8, #5
  10e84c:	d01a      	beq.n	10e884 <get_pll_dummy_root_round_rate_clk+0x20c>
                rate = calculate_pll_rate(&conf, clk->pll.plldiv);
  10e84e:	4641      	mov	r1, r8
  10e850:	a80a      	add	r0, sp, #40	; 0x28
  10e852:	f7fe fa99 	bl	10cd88 <calculate_pll_rate>
  10e856:	f8db 3000 	ldr.w	r3, [r11]
  10e85a:	4680      	mov	r8, r0
  10e85c:	b9c3      	cbnz	r3, 10e890 <get_pll_dummy_root_round_rate_clk+0x218>
                diff = abs_clk(freq, rate);
  10e85e:	4544      	cmp	r4, r8
  10e860:	d8d2      	bhi.n	10e808 <get_pll_dummy_root_round_rate_clk+0x190>
                if (diff == 0) {
  10e862:	ebb8 0304 	subs.w	r3, r8, r4
  10e866:	d1d1      	bne.n	10e80c <get_pll_dummy_root_round_rate_clk+0x194>
        clk->pll.config = conf;
  10e868:	9d03      	ldr	r5, [sp, #12]
  10e86a:	ae0a      	add	r6, sp, #40	; 0x28
  10e86c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  10e86e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  10e870:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
  10e872:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  10e874:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
  10e878:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
}
  10e87c:	4620      	mov	r0, r4
  10e87e:	b017      	add	sp, #92	; 0x5c
  10e880:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10e884:	a80a      	add	r0, sp, #40	; 0x28
  10e886:	f7fe fbdd 	bl	10d044 <is_valid_pll_config.isra.1.part.2>
                if (!is_valid_pll_config(clk, &conf)) { continue; }
  10e88a:	2800      	cmp	r0, #0
  10e88c:	d1df      	bne.n	10e84e <get_pll_dummy_root_round_rate_clk+0x1d6>
  10e88e:	e7d6      	b.n	10e83e <get_pll_dummy_root_round_rate_clk+0x1c6>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10e890:	4602      	mov	r2, r0
  10e892:	2300      	movs	r3, #0
  10e894:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10e898:	4648      	mov	r0, r9
  10e89a:	f7ff f9c7 	bl	10dc2c <res_clk_is_valid_request>
                if (!res_clk_is_valid_round_rate(clk, -1, rate, 0)) { continue; }
  10e89e:	2800      	cmp	r0, #0
  10e8a0:	d1dd      	bne.n	10e85e <get_pll_dummy_root_round_rate_clk+0x1e6>
  10e8a2:	e7ca      	b.n	10e83a <get_pll_dummy_root_round_rate_clk+0x1c2>
  10e8a4:	9b05      	ldr	r3, [sp, #20]
        for (refdiv = 1; refdiv <= refdiv_max; refdiv++) {
  10e8a6:	3501      	adds	r5, #1
  10e8a8:	4423      	add	r3, r4
  10e8aa:	9305      	str	r3, [sp, #20]
  10e8ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
  10e8ae:	42ab      	cmp	r3, r5
  10e8b0:	db13      	blt.n	10e8da <get_pll_dummy_root_round_rate_clk+0x262>
  10e8b2:	9f11      	ldr	r7, [sp, #68]	; 0x44
  10e8b4:	e786      	b.n	10e7c4 <get_pll_dummy_root_round_rate_clk+0x14c>
    ASSERT(clk->pll.plldiv == PLL_DUMMY_ROOT);
  10e8b6:	f24c 6390 	movw	r3, #50832	; 0xc690
  10e8ba:	f24c 42cc 	movw	r2, #50380	; 0xc4cc
  10e8be:	f647 4134 	movw	r1, #31796	; 0x7c34
  10e8c2:	f2c0 0311 	movt	r3, #17
  10e8c6:	4670      	mov	r0, r14
  10e8c8:	f2c0 0211 	movt	r2, #17
  10e8cc:	9300      	str	r3, [sp, #0]
  10e8ce:	f2c0 0111 	movt	r1, #17
  10e8d2:	f44f 73ad 	mov.w	r3, #346	; 0x15a
  10e8d6:	f004 ff61 	bl	11379c <_panic>
        conf = clk->pll.config;
  10e8da:	9f03      	ldr	r7, [sp, #12]
  10e8dc:	ae0a      	add	r6, sp, #40	; 0x28
  10e8de:	464d      	mov	r5, r9
  10e8e0:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  10e8e2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  10e8e4:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  10e8e6:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  10e8e8:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
  10e8ec:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
        if (bestrate > freq && conf.integer == 1) {
  10e8f0:	9b04      	ldr	r3, [sp, #16]
  10e8f2:	429c      	cmp	r4, r3
  10e8f4:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  10e8f6:	d204      	bcs.n	10e902 <get_pll_dummy_root_round_rate_clk+0x28a>
  10e8f8:	f89d 202c 	ldrb.w	r2, [r13, #44]	; 0x2c
  10e8fc:	b10a      	cbz	r2, 10e902 <get_pll_dummy_root_round_rate_clk+0x28a>
            conf.fbdiv--;
  10e8fe:	3b01      	subs	r3, #1
  10e900:	930e      	str	r3, [sp, #56]	; 0x38
        conf.frac = ((freq / 1000 * conf.refdiv / 24) - conf.fbdiv * 1000) *
  10e902:	f644 51d3 	movw	r1, #19923	; 0x4dd3
  10e906:	f64a 26ab 	movw	r6, #43691	; 0xaaab
  10e90a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  10e90c:	f2c1 0162 	movt	r1, #4194	; 0x1062
  10e910:	f6ca 26aa 	movt	r6, #43690	; 0xaaaa
  10e914:	fba1 4004 	umull	r4, r0, r1, r4
  10e918:	ebc3 1443 	rsb	r4, r3, r3, lsl #5
  10e91c:	0980      	lsrs	r0, r0, #6
  10e91e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  10e922:	fb02 f200 	mul.w	r2, r2, r0
  10e926:	00db      	lsls	r3, r3, #3
  10e928:	fba6 0202 	umull	r0, r2, r6, r2
  10e92c:	ebc3 1312 	rsb	r3, r3, r2, lsr #4
  10e930:	061b      	lsls	r3, r3, #24
                    16777216 / 1000;
  10e932:	fba1 2303 	umull	r2, r3, r1, r3
  10e936:	099b      	lsrs	r3, r3, #6
        conf.frac = ((freq / 1000 * conf.refdiv / 24) - conf.fbdiv * 1000) *
  10e938:	9311      	str	r3, [sp, #68]	; 0x44
        if (conf.frac) {
  10e93a:	b113      	cbz	r3, 10e942 <get_pll_dummy_root_round_rate_clk+0x2ca>
            conf.integer = 0;
  10e93c:	2300      	movs	r3, #0
  10e93e:	f88d 302c 	strb.w	r3, [r13, #44]	; 0x2c
    if (clk->pll.plldiv == PLL_DUMMY_ROOT) { // check the pll limit
  10e942:	f1b8 0f05 	cmp.w	r8, #5
  10e946:	d017      	beq.n	10e978 <get_pll_dummy_root_round_rate_clk+0x300>
        rate = calculate_pll_rate(&conf, clk->pll.plldiv);
  10e948:	4641      	mov	r1, r8
  10e94a:	a80a      	add	r0, sp, #40	; 0x28
  10e94c:	f7fe fa1c 	bl	10cd88 <calculate_pll_rate>
    if (round_rate_filter_en) {
  10e950:	f64a 1310 	movw	r3, #43280	; 0xa910
  10e954:	f2c0 0312 	movt	r3, #18
  10e958:	681b      	ldr	r3, [r3, #0]
  10e95a:	4604      	mov	r4, r0
  10e95c:	2b00      	cmp	r3, #0
  10e95e:	d083      	beq.n	10e868 <get_pll_dummy_root_round_rate_clk+0x1f0>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10e960:	4628      	mov	r0, r5
  10e962:	2300      	movs	r3, #0
  10e964:	4622      	mov	r2, r4
  10e966:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10e96a:	f7ff f95f 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, -1, rate, 0)) { return bestrate; }
  10e96e:	2800      	cmp	r0, #0
  10e970:	f47f af7a 	bne.w	10e868 <get_pll_dummy_root_round_rate_clk+0x1f0>
  10e974:	9c04      	ldr	r4, [sp, #16]
  10e976:	e6b4      	b.n	10e6e2 <get_pll_dummy_root_round_rate_clk+0x6a>
  10e978:	a80a      	add	r0, sp, #40	; 0x28
  10e97a:	f7fe fb63 	bl	10d044 <is_valid_pll_config.isra.1.part.2>
        if (!is_valid_pll_config(clk, &conf)) { return bestrate; }
  10e97e:	2800      	cmp	r0, #0
  10e980:	d1e2      	bne.n	10e948 <get_pll_dummy_root_round_rate_clk+0x2d0>
  10e982:	e7f7      	b.n	10e974 <get_pll_dummy_root_round_rate_clk+0x2fc>

0010e984 <clk_round_rate>:
{
  10e984:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10e988:	469a      	mov	r10, r3
  10e98a:	b091      	sub	sp, #68	; 0x44
    if (!is_pll(clk)) {
  10e98c:	6803      	ldr	r3, [r0, #0]
{
  10e98e:	4683      	mov	r11, r0
  10e990:	e9cd 2102 	strd	r2, r1, [r13, #8]
  10e994:	4675      	mov	r5, r14
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10e996:	1f5a      	subs	r2, r3, #5
  10e998:	2a65      	cmp	r2, #101	; 0x65
  10e99a:	d974      	bls.n	10ea86 <clk_round_rate+0x102>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10e99c:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10e9a0:	2a06      	cmp	r2, #6
  10e9a2:	f240 8091 	bls.w	10eac8 <clk_round_rate+0x144>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10e9a6:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10e9aa:	2a06      	cmp	r2, #6
  10e9ac:	f240 810e 	bls.w	10ebcc <clk_round_rate+0x248>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10e9b0:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10e9b4:	2a54      	cmp	r2, #84	; 0x54
  10e9b6:	f240 8087 	bls.w	10eac8 <clk_round_rate+0x144>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10e9ba:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10e9bc:	2b41      	cmp	r3, #65	; 0x41
  10e9be:	f200 8225 	bhi.w	10ee0c <clk_round_rate+0x488>
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
                  prate_cur = *prate, rate;
    unsigned int mindiv = 1, maxdiv = 0, bestdiv = 0;
    unsigned long diff;
    int uuu_type = clk->uuu.uuu_type;
    struct clk *p = clk->parents[pindex];
  10e9c2:	9b03      	ldr	r3, [sp, #12]
  10e9c4:	f103 0210 	add.w	r2, r3, #16

    if (uuu_type == UUU_SEL0 || uuu_type == UUU_SEL1) {
  10e9c8:	f8db 3088 	ldr.w	r3, [r11, #136]	; 0x88
    struct clk *p = clk->parents[pindex];
  10e9cc:	f85b 2022 	ldr.w	r2, [r11, r2, lsl #2]
    if (uuu_type == UUU_SEL0 || uuu_type == UUU_SEL1) {
  10e9d0:	2b01      	cmp	r3, #1
    struct clk *p = clk->parents[pindex];
  10e9d2:	9205      	str	r2, [sp, #20]
    if (uuu_type == UUU_SEL0 || uuu_type == UUU_SEL1) {
  10e9d4:	f240 81f5 	bls.w	10edc2 <clk_round_rate+0x43e>
        }

        *prate = bestrate;
        return bestrate;
    }
    else if (uuu_type >= UUU_M && uuu_type <= UUU_Q) {
  10e9d8:	3b02      	subs	r3, #2
  10e9da:	2b03      	cmp	r3, #3
  10e9dc:	f200 824e 	bhi.w	10ee7c <clk_round_rate+0x4f8>
        maxdiv = MIN(clk->maxdiv, 1 << 4);
  10e9e0:	f8db 3084 	ldr.w	r3, [r11, #132]	; 0x84
  10e9e4:	2b10      	cmp	r3, #16
  10e9e6:	bfa8      	it	ge
  10e9e8:	2310      	movge	r3, #16
  10e9ea:	4619      	mov	r1, r3
        maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10e9ec:	fba3 230a 	umull	r2, r3, r3, r10
  10e9f0:	2b00      	cmp	r3, #0
  10e9f2:	f040 823e 	bne.w	10ee72 <clk_round_rate+0x4ee>
        mindiv = MAX(clk->mindiv, 1);
  10e9f6:	f8db 5080 	ldr.w	r5, [r11, #128]	; 0x80
        maxdiv = MAX(maxdiv, mindiv);
  10e9fa:	460a      	mov	r2, r1
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10e9fc:	9b02      	ldr	r3, [sp, #8]
        mindiv = MAX(clk->mindiv, 1);
  10e9fe:	2d01      	cmp	r5, #1
  10ea00:	bfb8      	it	lt
  10ea02:	2501      	movlt	r5, #1
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ea04:	681b      	ldr	r3, [r3, #0]
        maxdiv = MAX(maxdiv, mindiv);
  10ea06:	42a9      	cmp	r1, r5
  10ea08:	bf38      	it	cc
  10ea0a:	462a      	movcc	r2, r5
        mindiv = MAX(clk->mindiv, 1);
  10ea0c:	4628      	mov	r0, r5
    else {
        //could not be here
        ASSERT(0);
    }

    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ea0e:	42aa      	cmp	r2, r5
        maxdiv = MAX(maxdiv, mindiv);
  10ea10:	9204      	str	r2, [sp, #16]
    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ea12:	f2c0 81f7 	blt.w	10ee04 <clk_round_rate+0x480>
  10ea16:	fb05 f60a 	mul.w	r6, r5, r10
  10ea1a:	f64a 1710 	movw	r7, #43280	; 0xa910
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ea1e:	461c      	mov	r4, r3
  10ea20:	f8cd b018 	str.w	r11, [r13, #24]
  10ea24:	f2c0 0712 	movt	r7, #18
  10ea28:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  10ea2c:	46ab      	mov	r11, r5
    if (freq * div_i == parent_rate_saved) {
  10ea2e:	429e      	cmp	r6, r3
  10ea30:	bf04      	itt	eq
  10ea32:	46b0      	moveq	r8, r6
  10ea34:	4652      	moveq	r2, r10
  10ea36:	d009      	beq.n	10ea4c <clk_round_rate+0xc8>
    *prate = res_clk_round_rate(p, &req);
  10ea38:	9805      	ldr	r0, [sp, #20]
  10ea3a:	a90d      	add	r1, sp, #52	; 0x34
    req.request = freq * div_i;
  10ea3c:	960d      	str	r6, [sp, #52]	; 0x34
    *prate = res_clk_round_rate(p, &req);
  10ea3e:	f7ff f973 	bl	10dd28 <res_clk_round_rate>
    now = DIV_ROUND_UP(*prate, div_i);
  10ea42:	1e6a      	subs	r2, r5, #1
    *prate = res_clk_round_rate(p, &req);
  10ea44:	4680      	mov	r8, r0
    now = DIV_ROUND_UP(*prate, div_i);
  10ea46:	4402      	add	r2, r0
  10ea48:	fbb2 f2f5 	udiv	r2, r2, r5
    if (round_rate_filter_en) {
  10ea4c:	683b      	ldr	r3, [r7, #0]
  10ea4e:	2b00      	cmp	r3, #0
  10ea50:	d145      	bne.n	10eade <clk_round_rate+0x15a>
        rate = res_clk_div_round_rate(clk, p, i, &prate_cur, freq);

        //dprintf(CRITICAL, "ckgen uuu %s old p %lu req %lu round get p %lu, rate %lu div %d\n", clk->name, *prate, freq, prate_cur, rate, i);
        if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }

        diff = abs_clk(freq, prate_cur / (i));
  10ea52:	fbb8 f3f5 	udiv	r3, r8, r5
  10ea56:	459a      	cmp	r10, r3
  10ea58:	bf88      	it	hi
  10ea5a:	ebaa 0303 	subhi.w	r3, r10, r3
  10ea5e:	d801      	bhi.n	10ea64 <clk_round_rate+0xe0>
  10ea60:	eba3 030a 	sub.w	r3, r3, r10

        //dprintf(CRITICAL, "ckgen uuu %s old p %lu req %lu round get p %lu ,diff %lu div %d\n", clk->name, *prate, freq, prate_cur, diff, i);
        if (diff == 0) {
  10ea64:	2b00      	cmp	r3, #0
  10ea66:	f000 80a9 	beq.w	10ebbc <clk_round_rate+0x238>
            *prate = prate_cur;
            return freq;
        }

        if (diff < bestratediff) {
  10ea6a:	454b      	cmp	r3, r9
  10ea6c:	bf3e      	ittt	cc
  10ea6e:	46ab      	movcc	r11, r5
  10ea70:	4644      	movcc	r4, r8
  10ea72:	4699      	movcc	r9, r3
    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ea74:	9b04      	ldr	r3, [sp, #16]
  10ea76:	3501      	adds	r5, #1
  10ea78:	4456      	add	r6, r10
  10ea7a:	42ab      	cmp	r3, r5
  10ea7c:	f2c0 810c 	blt.w	10ec98 <clk_round_rate+0x314>
  10ea80:	9b02      	ldr	r3, [sp, #8]
  10ea82:	681b      	ldr	r3, [r3, #0]
  10ea84:	e7d3      	b.n	10ea2e <clk_round_rate+0xaa>
  10ea86:	f7fe fe0b 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10ea8a:	b1c0      	cbz	r0, 10eabe <clk_round_rate+0x13a>
    if (is_pll(clk)) {
  10ea8c:	f8db 3000 	ldr.w	r3, [r11]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10ea90:	1f5a      	subs	r2, r3, #5
  10ea92:	2a65      	cmp	r2, #101	; 0x65
  10ea94:	d882      	bhi.n	10e99c <clk_round_rate+0x18>
  10ea96:	f8db 1090 	ldr.w	r1, [r11, #144]	; 0x90
        if (dont_change_pll) {
  10ea9a:	f240 137c 	movw	r3, #380	; 0x17c
  10ea9e:	f2c0 0313 	movt	r3, #19
  10eaa2:	681a      	ldr	r2, [r3, #0]
  10eaa4:	b31a      	cbz	r2, 10eaee <clk_round_rate+0x16a>
            return get_pll_rate(clk, *prate, false);
  10eaa6:	9b02      	ldr	r3, [sp, #8]
  10eaa8:	f8db 0004 	ldr.w	r0, [r11, #4]
  10eaac:	681a      	ldr	r2, [r3, #0]
  10eaae:	2300      	movs	r3, #0
  10eab0:	f7fe fc58 	bl	10d364 <get_pll_rate.isra.20>
  10eab4:	4604      	mov	r4, r0
}
  10eab6:	4620      	mov	r0, r4
  10eab8:	b011      	add	sp, #68	; 0x44
  10eaba:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return 0;
  10eabe:	4604      	mov	r4, r0
}
  10eac0:	4620      	mov	r0, r4
  10eac2:	b011      	add	sp, #68	; 0x44
  10eac4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return get_ckgen_bus_ip_round_rate_clk(clk, pindex, prate, freq);
  10eac8:	4653      	mov	r3, r10
  10eaca:	4658      	mov	r0, r11
  10eacc:	e9dd 2102 	ldrd	r2, r1, [r13, #8]
  10ead0:	f7ff f9ee 	bl	10deb0 <get_ckgen_bus_ip_round_rate_clk>
  10ead4:	4604      	mov	r4, r0
}
  10ead6:	4620      	mov	r0, r4
  10ead8:	b011      	add	sp, #68	; 0x44
  10eada:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10eade:	9903      	ldr	r1, [sp, #12]
  10eae0:	4643      	mov	r3, r8
  10eae2:	9806      	ldr	r0, [sp, #24]
  10eae4:	f7ff f8a2 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }
  10eae8:	2800      	cmp	r0, #0
  10eaea:	d1b2      	bne.n	10ea52 <clk_round_rate+0xce>
  10eaec:	e7c2      	b.n	10ea74 <clk_round_rate+0xf0>
static unsigned long get_pll_round_rate_clk(struct clk *clk,
        int pindex, unsigned long *prate, unsigned long freq)
{
    int plldiv = clk->pll.plldiv;

    if (plldiv == PLL_DUMMY_ROOT) { // ignore prate
  10eaee:	2905      	cmp	r1, #5
  10eaf0:	f000 815f 	beq.w	10edb2 <clk_round_rate+0x42e>
        return get_pll_dummy_root_round_rate_clk(clk, pindex, prate, freq);
    }
    else if (plldiv == PLL_ROOT) {
  10eaf4:	2900      	cmp	r1, #0
  10eaf6:	f000 80d5 	beq.w	10eca4 <clk_round_rate+0x320>
        return get_pll_root_round_rate_clk(clk, pindex, prate, freq);
    }
    else if (plldiv >= PLL_DIVA && plldiv <= PLL_DIVD) {
  10eafa:	3901      	subs	r1, #1
  10eafc:	2903      	cmp	r1, #3
  10eafe:	f200 819c 	bhi.w	10ee3a <clk_round_rate+0x4b6>
    if (pindex != -1) {
  10eb02:	9903      	ldr	r1, [sp, #12]
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10eb04:	9b02      	ldr	r3, [sp, #8]
    if (pindex != -1) {
  10eb06:	1c48      	adds	r0, r1, #1
        p = clk->parents[pindex];
  10eb08:	bf18      	it	ne
  10eb0a:	f101 0210 	addne.w	r2, r1, #16
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10eb0e:	681b      	ldr	r3, [r3, #0]
        p = clk->parents[pindex];
  10eb10:	bf18      	it	ne
  10eb12:	f85b 2022 	ldrne.w	r2, [r11, r2, lsl #2]
    struct clk *p = NULL;
  10eb16:	9205      	str	r2, [sp, #20]
    maxdiv = MIN(clk->maxdiv, div_max);
  10eb18:	f8db 2084 	ldr.w	r2, [r11, #132]	; 0x84
  10eb1c:	2a10      	cmp	r2, #16
  10eb1e:	bfa8      	it	ge
  10eb20:	2210      	movge	r2, #16
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10eb22:	fba2 010a 	umull	r0, r1, r2, r10
  10eb26:	2900      	cmp	r1, #0
  10eb28:	f040 8182 	bne.w	10ee30 <clk_round_rate+0x4ac>
    mindiv = MAX(clk->mindiv, 1);
  10eb2c:	f8db 4080 	ldr.w	r4, [r11, #128]	; 0x80
  10eb30:	2c01      	cmp	r4, #1
  10eb32:	bfb8      	it	lt
  10eb34:	2401      	movlt	r4, #1
    maxdiv = MAX(maxdiv, mindiv);
  10eb36:	42a2      	cmp	r2, r4
  10eb38:	bf38      	it	cc
  10eb3a:	4622      	movcc	r2, r4
    for (i = 1; i <= (int)maxdiv; i++) {
  10eb3c:	2a00      	cmp	r2, #0
    maxdiv = MAX(maxdiv, mindiv);
  10eb3e:	9204      	str	r2, [sp, #16]
    for (i = 1; i <= (int)maxdiv; i++) {
  10eb40:	f340 815e 	ble.w	10ee00 <clk_round_rate+0x47c>
  10eb44:	f64a 1710 	movw	r7, #43280	; 0xa910
  10eb48:	4656      	mov	r6, r10
    *prate = res_clk_round_rate(p, &req);
  10eb4a:	f8cd b018 	str.w	r11, [r13, #24]
  10eb4e:	f2c0 0712 	movt	r7, #18
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10eb52:	461a      	mov	r2, r3
  10eb54:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
    for (i = 1; i <= (int)maxdiv; i++) {
  10eb58:	2501      	movs	r5, #1
  10eb5a:	469b      	mov	r11, r3
    if (freq * div_i == parent_rate_saved) {
  10eb5c:	429e      	cmp	r6, r3
  10eb5e:	bf04      	itt	eq
  10eb60:	46b0      	moveq	r8, r6
  10eb62:	4652      	moveq	r2, r10
  10eb64:	d009      	beq.n	10eb7a <clk_round_rate+0x1f6>
    *prate = res_clk_round_rate(p, &req);
  10eb66:	9805      	ldr	r0, [sp, #20]
  10eb68:	a90d      	add	r1, sp, #52	; 0x34
    req.request = freq * div_i;
  10eb6a:	960d      	str	r6, [sp, #52]	; 0x34
    *prate = res_clk_round_rate(p, &req);
  10eb6c:	f7ff f8dc 	bl	10dd28 <res_clk_round_rate>
    now = DIV_ROUND_UP(*prate, div_i);
  10eb70:	1e6a      	subs	r2, r5, #1
    *prate = res_clk_round_rate(p, &req);
  10eb72:	4680      	mov	r8, r0
    now = DIV_ROUND_UP(*prate, div_i);
  10eb74:	4402      	add	r2, r0
  10eb76:	fbb2 f2f5 	udiv	r2, r2, r5
    if (round_rate_filter_en) {
  10eb7a:	683b      	ldr	r3, [r7, #0]
  10eb7c:	b9b3      	cbnz	r3, 10ebac <clk_round_rate+0x228>
        diff = abs_clk(freq, prate_cur / i);
  10eb7e:	fbb8 f3f5 	udiv	r3, r8, r5
  10eb82:	459a      	cmp	r10, r3
  10eb84:	bf88      	it	hi
  10eb86:	ebaa 0303 	subhi.w	r3, r10, r3
  10eb8a:	d801      	bhi.n	10eb90 <clk_round_rate+0x20c>
  10eb8c:	eba3 030a 	sub.w	r3, r3, r10
        if (diff == 0) {
  10eb90:	b1a3      	cbz	r3, 10ebbc <clk_round_rate+0x238>
        if (diff < bestratediff) {
  10eb92:	4599      	cmp	r9, r3
  10eb94:	bf82      	ittt	hi
  10eb96:	462c      	movhi	r4, r5
  10eb98:	46c3      	movhi	r11, r8
  10eb9a:	4699      	movhi	r9, r3
    for (i = 1; i <= (int)maxdiv; i++) {
  10eb9c:	9b04      	ldr	r3, [sp, #16]
  10eb9e:	3501      	adds	r5, #1
  10eba0:	4456      	add	r6, r10
  10eba2:	429d      	cmp	r5, r3
  10eba4:	dc71      	bgt.n	10ec8a <clk_round_rate+0x306>
  10eba6:	9b02      	ldr	r3, [sp, #8]
  10eba8:	681b      	ldr	r3, [r3, #0]
  10ebaa:	e7d7      	b.n	10eb5c <clk_round_rate+0x1d8>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10ebac:	9903      	ldr	r1, [sp, #12]
  10ebae:	4643      	mov	r3, r8
  10ebb0:	9806      	ldr	r0, [sp, #24]
  10ebb2:	f7ff f83b 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }
  10ebb6:	2800      	cmp	r0, #0
  10ebb8:	d1e1      	bne.n	10eb7e <clk_round_rate+0x1fa>
  10ebba:	e7ef      	b.n	10eb9c <clk_round_rate+0x218>
            *prate = prate_cur;
  10ebbc:	9b02      	ldr	r3, [sp, #8]
  10ebbe:	4654      	mov	r4, r10
  10ebc0:	f8c3 8000 	str.w	r8, [r3]
}
  10ebc4:	4620      	mov	r0, r4
  10ebc6:	b011      	add	sp, #68	; 0x44
  10ebc8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    maxdiv = MIN(clk->maxdiv, postdiv_max);
  10ebcc:	f8db 2084 	ldr.w	r2, [r11, #132]	; 0x84
    struct clk *p = clk->parents[pindex];
  10ebd0:	9b03      	ldr	r3, [sp, #12]
    maxdiv = MIN(clk->maxdiv, postdiv_max);
  10ebd2:	2a40      	cmp	r2, #64	; 0x40
  10ebd4:	bfa8      	it	ge
  10ebd6:	2240      	movge	r2, #64	; 0x40
    struct clk *p = clk->parents[pindex];
  10ebd8:	f103 0110 	add.w	r1, r3, #16
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ebdc:	9b02      	ldr	r3, [sp, #8]
    maxdiv = MIN(clk->maxdiv, postdiv_max);
  10ebde:	4614      	mov	r4, r2
    struct clk *p = clk->parents[pindex];
  10ebe0:	f85b 2021 	ldr.w	r2, [r11, r1, lsl #2]
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ebe4:	fba4 010a 	umull	r0, r1, r4, r10
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ebe8:	681b      	ldr	r3, [r3, #0]
    struct clk *p = clk->parents[pindex];
  10ebea:	9205      	str	r2, [sp, #20]
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ebec:	2900      	cmp	r1, #0
  10ebee:	f040 8136 	bne.w	10ee5e <clk_round_rate+0x4da>
    mindiv = MAX(clk->mindiv, 1);
  10ebf2:	f8db 5080 	ldr.w	r5, [r11, #128]	; 0x80
    maxdiv = MAX(maxdiv, mindiv);
  10ebf6:	4622      	mov	r2, r4
    mindiv = MAX(clk->mindiv, 1);
  10ebf8:	2d01      	cmp	r5, #1
  10ebfa:	bfb8      	it	lt
  10ebfc:	2501      	movlt	r5, #1
  10ebfe:	4629      	mov	r1, r5
    maxdiv = MAX(maxdiv, mindiv);
  10ec00:	42ac      	cmp	r4, r5
  10ec02:	bf38      	it	cc
  10ec04:	462a      	movcc	r2, r5
    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ec06:	4295      	cmp	r5, r2
    maxdiv = MAX(maxdiv, mindiv);
  10ec08:	9204      	str	r2, [sp, #16]
    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ec0a:	f300 80fd 	bgt.w	10ee08 <clk_round_rate+0x484>
  10ec0e:	fb05 f60a 	mul.w	r6, r5, r10
  10ec12:	f64a 1710 	movw	r7, #43280	; 0xa910
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ec16:	461c      	mov	r4, r3
    *prate = res_clk_round_rate(p, &req);
  10ec18:	f8cd b018 	str.w	r11, [r13, #24]
  10ec1c:	f2c0 0712 	movt	r7, #18
  10ec20:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  10ec24:	46ab      	mov	r11, r5
    if (freq * div_i == parent_rate_saved) {
  10ec26:	42b3      	cmp	r3, r6
  10ec28:	bf04      	itt	eq
  10ec2a:	46b0      	moveq	r8, r6
  10ec2c:	4652      	moveq	r2, r10
  10ec2e:	d009      	beq.n	10ec44 <clk_round_rate+0x2c0>
    *prate = res_clk_round_rate(p, &req);
  10ec30:	9805      	ldr	r0, [sp, #20]
  10ec32:	a90d      	add	r1, sp, #52	; 0x34
    req.request = freq * div_i;
  10ec34:	960d      	str	r6, [sp, #52]	; 0x34
    *prate = res_clk_round_rate(p, &req);
  10ec36:	f7ff f877 	bl	10dd28 <res_clk_round_rate>
    now = DIV_ROUND_UP(*prate, div_i);
  10ec3a:	1e6a      	subs	r2, r5, #1
    *prate = res_clk_round_rate(p, &req);
  10ec3c:	4680      	mov	r8, r0
    now = DIV_ROUND_UP(*prate, div_i);
  10ec3e:	4402      	add	r2, r0
  10ec40:	fbb2 f2f5 	udiv	r2, r2, r5
    if (round_rate_filter_en) {
  10ec44:	683b      	ldr	r3, [r7, #0]
  10ec46:	b9c3      	cbnz	r3, 10ec7a <clk_round_rate+0x2f6>
        diff = abs_clk(freq, prate_cur / (i));
  10ec48:	fbb8 f3f5 	udiv	r3, r8, r5
  10ec4c:	459a      	cmp	r10, r3
  10ec4e:	bf88      	it	hi
  10ec50:	ebaa 0303 	subhi.w	r3, r10, r3
  10ec54:	d801      	bhi.n	10ec5a <clk_round_rate+0x2d6>
  10ec56:	eba3 030a 	sub.w	r3, r3, r10
        if (diff == 0) {
  10ec5a:	2b00      	cmp	r3, #0
  10ec5c:	d0ae      	beq.n	10ebbc <clk_round_rate+0x238>
        if (diff < bestratediff) {
  10ec5e:	454b      	cmp	r3, r9
  10ec60:	bf3e      	ittt	cc
  10ec62:	46ab      	movcc	r11, r5
  10ec64:	4644      	movcc	r4, r8
  10ec66:	4699      	movcc	r9, r3
    for (i = (int)mindiv; i <= (int)maxdiv; i++) {
  10ec68:	9b04      	ldr	r3, [sp, #16]
  10ec6a:	3501      	adds	r5, #1
  10ec6c:	4456      	add	r6, r10
  10ec6e:	429d      	cmp	r5, r3
  10ec70:	f300 8099 	bgt.w	10eda6 <clk_round_rate+0x422>
  10ec74:	9b02      	ldr	r3, [sp, #8]
  10ec76:	681b      	ldr	r3, [r3, #0]
  10ec78:	e7d5      	b.n	10ec26 <clk_round_rate+0x2a2>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10ec7a:	9903      	ldr	r1, [sp, #12]
  10ec7c:	4643      	mov	r3, r8
  10ec7e:	9806      	ldr	r0, [sp, #24]
  10ec80:	f7fe ffd4 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }
  10ec84:	2800      	cmp	r0, #0
  10ec86:	d1df      	bne.n	10ec48 <clk_round_rate+0x2c4>
  10ec88:	e7ee      	b.n	10ec68 <clk_round_rate+0x2e4>
  10ec8a:	4659      	mov	r1, r11
    *prate = bestprate;
  10ec8c:	9b02      	ldr	r3, [sp, #8]
  10ec8e:	461a      	mov	r2, r3
    bestrate = (bestprate) / (bestdiv);
  10ec90:	fbb1 f4f4 	udiv	r4, r1, r4
    *prate = bestprate;
  10ec94:	6011      	str	r1, [r2, #0]
  10ec96:	e70e      	b.n	10eab6 <clk_round_rate+0x132>
  10ec98:	4658      	mov	r0, r11
            bestprate = prate_cur;
            bestdiv = i;
        }
    }

    *prate = bestprate;
  10ec9a:	9b02      	ldr	r3, [sp, #8]
  10ec9c:	601c      	str	r4, [r3, #0]
    bestrate = bestprate / bestdiv;
  10ec9e:	fbb4 f4f0 	udiv	r4, r4, r0
  10eca2:	e708      	b.n	10eab6 <clk_round_rate+0x132>
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10eca4:	9b02      	ldr	r3, [sp, #8]
  10eca6:	681b      	ldr	r3, [r3, #0]
  10eca8:	9304      	str	r3, [sp, #16]
    if (pindex != -1) {
  10ecaa:	9b03      	ldr	r3, [sp, #12]
  10ecac:	1c5a      	adds	r2, r3, #1
        p = clk->parents[pindex];
  10ecae:	bf17      	itett	ne
  10ecb0:	3310      	addne	r3, #16
    struct clk *p = NULL;
  10ecb2:	910a      	streq	r1, [sp, #40]	; 0x28
        p = clk->parents[pindex];
  10ecb4:	f85b 3023 	ldrne.w	r3, [r11, r3, lsl #2]
  10ecb8:	930a      	strne	r3, [sp, #40]	; 0x28
    maxdiv = MIN(clk->maxdiv, postdiv0div_max * postdiv1div_max);
  10ecba:	f8db 3084 	ldr.w	r3, [r11, #132]	; 0x84
  10ecbe:	2b31      	cmp	r3, #49	; 0x31
  10ecc0:	bfa8      	it	ge
  10ecc2:	2331      	movge	r3, #49	; 0x31
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ecc4:	fba3 010a 	umull	r0, r1, r3, r10
  10ecc8:	2900      	cmp	r1, #0
  10ecca:	f040 80cd 	bne.w	10ee68 <clk_round_rate+0x4e4>
    mindiv = MAX(clk->mindiv, 1);
  10ecce:	f8db 2080 	ldr.w	r2, [r11, #128]	; 0x80
    if (round_rate_filter_en) {
  10ecd2:	f64a 1110 	movw	r1, #43280	; 0xa910
  10ecd6:	f8cd b02c 	str.w	r11, [r13, #44]	; 0x2c
  10ecda:	f2c0 0112 	movt	r1, #18
  10ecde:	f8dd b008 	ldr.w	r11, [r13, #8]
  10ece2:	2a01      	cmp	r2, #1
  10ece4:	bfb8      	it	lt
  10ece6:	2201      	movlt	r2, #1
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ece8:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
    for (i = 1; i <= postdiv0div_max; i++) {
  10ecec:	f04f 0801 	mov.w	r8, #1
    maxdiv = MAX(maxdiv, mindiv);
  10ecf0:	4293      	cmp	r3, r2
  10ecf2:	9109      	str	r1, [sp, #36]	; 0x24
  10ecf4:	bf38      	it	cc
  10ecf6:	4613      	movcc	r3, r2
  10ecf8:	f8cd a018 	str.w	r10, [r13, #24]
    mindiv = MAX(clk->mindiv, 1);
  10ecfc:	9207      	str	r2, [sp, #28]
  10ecfe:	9205      	str	r2, [sp, #20]
    maxdiv = MAX(maxdiv, mindiv);
  10ed00:	9308      	str	r3, [sp, #32]
    struct clk *p = NULL;
  10ed02:	9e06      	ldr	r6, [sp, #24]
  10ed04:	4644      	mov	r4, r8
        for (j = 1; j <= postdiv1div_max; j++) {
  10ed06:	2501      	movs	r5, #1
            if (((i * j) < (int)mindiv) || ((i * j) > (int)maxdiv)) {
  10ed08:	9b07      	ldr	r3, [sp, #28]
  10ed0a:	42a3      	cmp	r3, r4
  10ed0c:	dc33      	bgt.n	10ed76 <clk_round_rate+0x3f2>
            if (i < j) { //post0 >= post1
  10ed0e:	9b08      	ldr	r3, [sp, #32]
  10ed10:	45a8      	cmp	r8, r5
  10ed12:	bfa8      	it	ge
  10ed14:	42a3      	cmpge	r3, r4
  10ed16:	db2e      	blt.n	10ed76 <clk_round_rate+0x3f2>
    if (freq * div_i == parent_rate_saved) {
  10ed18:	f8db 3000 	ldr.w	r3, [r11]
  10ed1c:	42b3      	cmp	r3, r6
  10ed1e:	bf04      	itt	eq
  10ed20:	4637      	moveq	r7, r6
  10ed22:	4652      	moveq	r2, r10
  10ed24:	d009      	beq.n	10ed3a <clk_round_rate+0x3b6>
    *prate = res_clk_round_rate(p, &req);
  10ed26:	980a      	ldr	r0, [sp, #40]	; 0x28
  10ed28:	a90d      	add	r1, sp, #52	; 0x34
    req.request = freq * div_i;
  10ed2a:	960d      	str	r6, [sp, #52]	; 0x34
    *prate = res_clk_round_rate(p, &req);
  10ed2c:	f7fe fffc 	bl	10dd28 <res_clk_round_rate>
    now = DIV_ROUND_UP(*prate, div_i);
  10ed30:	1e62      	subs	r2, r4, #1
    *prate = res_clk_round_rate(p, &req);
  10ed32:	4607      	mov	r7, r0
    now = DIV_ROUND_UP(*prate, div_i);
  10ed34:	4402      	add	r2, r0
  10ed36:	fbb2 f2f4 	udiv	r2, r2, r4
    if (round_rate_filter_en) {
  10ed3a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  10ed3c:	681b      	ldr	r3, [r3, #0]
  10ed3e:	bb53      	cbnz	r3, 10ed96 <clk_round_rate+0x412>
            diff = abs_clk(freq, prate_cur / (i * j));
  10ed40:	fbb7 f3f4 	udiv	r3, r7, r4
  10ed44:	459a      	cmp	r10, r3
  10ed46:	bf88      	it	hi
  10ed48:	ebaa 0303 	subhi.w	r3, r10, r3
  10ed4c:	d801      	bhi.n	10ed52 <clk_round_rate+0x3ce>
  10ed4e:	eba3 030a 	sub.w	r3, r3, r10
            if (diff == 0) {
  10ed52:	2b00      	cmp	r3, #0
  10ed54:	d045      	beq.n	10ede2 <clk_round_rate+0x45e>
            if (diff < bestratediff) {
  10ed56:	9a05      	ldr	r2, [sp, #20]
  10ed58:	454b      	cmp	r3, r9
  10ed5a:	bf3c      	itt	cc
  10ed5c:	4622      	movcc	r2, r4
  10ed5e:	4699      	movcc	r9, r3
  10ed60:	9205      	str	r2, [sp, #20]
  10ed62:	9a04      	ldr	r2, [sp, #16]
  10ed64:	bf38      	it	cc
  10ed66:	463a      	movcc	r2, r7
  10ed68:	9204      	str	r2, [sp, #16]
  10ed6a:	9b06      	ldr	r3, [sp, #24]
        for (j = 1; j <= postdiv1div_max; j++) {
  10ed6c:	3501      	adds	r5, #1
  10ed6e:	2d08      	cmp	r5, #8
  10ed70:	4444      	add	r4, r8
  10ed72:	441e      	add	r6, r3
  10ed74:	d1c8      	bne.n	10ed08 <clk_round_rate+0x384>
  10ed76:	9b06      	ldr	r3, [sp, #24]
    for (i = 1; i <= postdiv0div_max; i++) {
  10ed78:	f108 0801 	add.w	r8, r8, #1
  10ed7c:	f1b8 0f08 	cmp.w	r8, #8
  10ed80:	4453      	add	r3, r10
  10ed82:	9306      	str	r3, [sp, #24]
  10ed84:	d1bd      	bne.n	10ed02 <clk_round_rate+0x37e>
    *prate = bestprate;
  10ed86:	9b02      	ldr	r3, [sp, #8]
  10ed88:	461a      	mov	r2, r3
  10ed8a:	9b04      	ldr	r3, [sp, #16]
  10ed8c:	6013      	str	r3, [r2, #0]
    bestrate = (bestprate) / (bestdiv);
  10ed8e:	9a05      	ldr	r2, [sp, #20]
  10ed90:	fbb3 f4f2 	udiv	r4, r3, r2
  10ed94:	e68f      	b.n	10eab6 <clk_round_rate+0x132>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10ed96:	9903      	ldr	r1, [sp, #12]
  10ed98:	463b      	mov	r3, r7
  10ed9a:	980b      	ldr	r0, [sp, #44]	; 0x2c
  10ed9c:	f7fe ff46 	bl	10dc2c <res_clk_is_valid_request>
            if (!res_clk_is_valid_round_rate(clk, pindex, rate, prate_cur)) { continue; }
  10eda0:	2800      	cmp	r0, #0
  10eda2:	d1cd      	bne.n	10ed40 <clk_round_rate+0x3bc>
  10eda4:	e7e1      	b.n	10ed6a <clk_round_rate+0x3e6>
  10eda6:	4659      	mov	r1, r11
    *prate = bestprate;
  10eda8:	9b02      	ldr	r3, [sp, #8]
  10edaa:	601c      	str	r4, [r3, #0]
    bestrate = (bestprate) / (bestdiv);
  10edac:	fbb4 f4f1 	udiv	r4, r4, r1
  10edb0:	e681      	b.n	10eab6 <clk_round_rate+0x132>
        return get_pll_dummy_root_round_rate_clk(clk, pindex, prate, freq);
  10edb2:	4653      	mov	r3, r10
  10edb4:	4658      	mov	r0, r11
  10edb6:	e9dd 2102 	ldrd	r2, r1, [r13, #8]
  10edba:	f7ff fc5d 	bl	10e678 <get_pll_dummy_root_round_rate_clk>
  10edbe:	4604      	mov	r4, r0
  10edc0:	e679      	b.n	10eab6 <clk_round_rate+0x132>
        bestrate = res_clk_round_rate(clk->parents[pindex], &req);
  10edc2:	4610      	mov	r0, r2
        req.request = freq;
  10edc4:	a910      	add	r1, sp, #64	; 0x40
  10edc6:	f841 ad0c 	str.w	r10, [r1, #-12]!
        bestrate = res_clk_round_rate(clk->parents[pindex], &req);
  10edca:	f7fe ffad 	bl	10dd28 <res_clk_round_rate>
    if (round_rate_filter_en) {
  10edce:	f64a 1310 	movw	r3, #43280	; 0xa910
  10edd2:	f2c0 0312 	movt	r3, #18
  10edd6:	681b      	ldr	r3, [r3, #0]
  10edd8:	4604      	mov	r4, r0
  10edda:	b933      	cbnz	r3, 10edea <clk_round_rate+0x466>
        *prate = bestrate;
  10eddc:	9b02      	ldr	r3, [sp, #8]
  10edde:	601c      	str	r4, [r3, #0]
  10ede0:	e669      	b.n	10eab6 <clk_round_rate+0x132>
                *prate = prate_cur;
  10ede2:	9b02      	ldr	r3, [sp, #8]
  10ede4:	4654      	mov	r4, r10
  10ede6:	601f      	str	r7, [r3, #0]
  10ede8:	e665      	b.n	10eab6 <clk_round_rate+0x132>
        return res_clk_is_valid_request(clk, pindex, rate, prate);
  10edea:	9903      	ldr	r1, [sp, #12]
  10edec:	4658      	mov	r0, r11
  10edee:	4623      	mov	r3, r4
  10edf0:	4622      	mov	r2, r4
  10edf2:	f7fe ff1b 	bl	10dc2c <res_clk_is_valid_request>
        if (!res_clk_is_valid_round_rate(clk, pindex, bestrate, bestrate)) {
  10edf6:	2800      	cmp	r0, #0
  10edf8:	d1f0      	bne.n	10eddc <clk_round_rate+0x458>
            bestrate = *prate;
  10edfa:	9b02      	ldr	r3, [sp, #8]
  10edfc:	681c      	ldr	r4, [r3, #0]
  10edfe:	e7ed      	b.n	10eddc <clk_round_rate+0x458>
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ee00:	4619      	mov	r1, r3
  10ee02:	e743      	b.n	10ec8c <clk_round_rate+0x308>
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ee04:	461c      	mov	r4, r3
  10ee06:	e748      	b.n	10ec9a <clk_round_rate+0x316>
    unsigned long bestrate = 0, bestratediff = UINT32_MAX, bestprate = *prate,
  10ee08:	461c      	mov	r4, r3
  10ee0a:	e7cd      	b.n	10eda8 <clk_round_rate+0x424>
        ASSERT(0);
  10ee0c:	f649 0384 	movw	r3, #39044	; 0x9884
  10ee10:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10ee14:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ee18:	f2c0 0311 	movt	r3, #17
  10ee1c:	4628      	mov	r0, r5
  10ee1e:	f2c0 0211 	movt	r2, #17
  10ee22:	9300      	str	r3, [sp, #0]
  10ee24:	f2c0 0111 	movt	r1, #17
  10ee28:	f240 2387 	movw	r3, #647	; 0x287
  10ee2c:	f004 fcb6 	bl	11379c <_panic>
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ee30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  10ee34:	fbb2 f2fa 	udiv	r2, r2, r10
  10ee38:	e678      	b.n	10eb2c <clk_round_rate+0x1a8>
        return get_pll_div_round_rate_clk(clk, pindex, prate, freq);
    }
    else {
        //could not be here
        ASSERT(0);
  10ee3a:	f649 0384 	movw	r3, #39044	; 0x9884
  10ee3e:	f24c 42cc 	movw	r2, #50380	; 0xc4cc
  10ee42:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ee46:	f2c0 0311 	movt	r3, #17
  10ee4a:	4628      	mov	r0, r5
  10ee4c:	f2c0 0211 	movt	r2, #17
  10ee50:	9300      	str	r3, [sp, #0]
  10ee52:	f2c0 0111 	movt	r1, #17
  10ee56:	f240 234f 	movw	r3, #591	; 0x24f
  10ee5a:	f004 fc9f 	bl	11379c <_panic>
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ee5e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  10ee62:	fbb2 f4fa 	udiv	r4, r2, r10
  10ee66:	e6c4      	b.n	10ebf2 <clk_round_rate+0x26e>
    maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ee68:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10ee6c:	fbb3 f3fa 	udiv	r3, r3, r10
  10ee70:	e72d      	b.n	10ecce <clk_round_rate+0x34a>
        maxdiv = MIN(UINT32_MAX / freq, maxdiv);
  10ee72:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10ee76:	fbb3 f1fa 	udiv	r1, r3, r10
  10ee7a:	e5bc      	b.n	10e9f6 <clk_round_rate+0x72>
        ASSERT(0);
  10ee7c:	f649 0384 	movw	r3, #39044	; 0x9884
  10ee80:	f24c 5270 	movw	r2, #50544	; 0xc570
  10ee84:	f647 4134 	movw	r1, #31796	; 0x7c34
  10ee88:	f2c0 0311 	movt	r3, #17
  10ee8c:	4628      	mov	r0, r5
  10ee8e:	f2c0 0211 	movt	r2, #17
  10ee92:	9300      	str	r3, [sp, #0]
  10ee94:	f2c0 0111 	movt	r1, #17
  10ee98:	f240 43bb 	movw	r3, #1211	; 0x4bb
  10ee9c:	f004 fc7e 	bl	11379c <_panic>

0010eea0 <res_clk_request>:

int res_clk_request(enum module_per_id per_id, enum clk_id clkid,
                    unsigned long param)
{
  10eea0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10eea2:	460d      	mov	r5, r1
  10eea4:	4606      	mov	r6, r0
  10eea6:	4617      	mov	r7, r2
    struct clk *clk=NULL;
    unsigned long freq = param;
    int ret;

    module_helper_init();
  10eea8:	f7fd fed6 	bl	10cc58 <module_helper_init>
    return get_clk_by_id_internal(NULL, clkid);
  10eeac:	4629      	mov	r1, r5
  10eeae:	2000      	movs	r0, #0
  10eeb0:	f7fd ffa6 	bl	10ce00 <get_clk_by_id_internal>
    clk = get_clk_by_id(clkid);
    //TODO:can check if this clk allowed to be accessed by user
    CLK_TRACE(DBGV, "req from %d : clk %p id %d param %lu\n", per_id, clk,
              clkid, param);

    if (!clk) {
  10eeb4:	b310      	cbz	r0, 10eefc <res_clk_request+0x5c>
  10eeb6:	4604      	mov	r4, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10eeb8:	f3ef 8300 	mrs	r3, CPSR
  10eebc:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
  10eebe:	bf48      	it	mi
  10eec0:	2200      	movmi	r2, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10eec2:	d518      	bpl.n	10eef6 <res_clk_request+0x56>
        CLK_TRACE(CRITICAL, "no such clk %d\n", clkid);
        return -1;
    }

    spin_lock_irqsave(&clk->lock, clk->lockstate);
    cur_per_id = per_id;
  10eec4:	f240 1078 	movw	r0, #376	; 0x178
    *lock = 1;
  10eec8:	2101      	movs	r1, #1
    cur_clkid = clkid;
  10eeca:	f240 1374 	movw	r3, #372	; 0x174
    cur_per_id = per_id;
  10eece:	f2c0 0013 	movt	r0, #19
    *statep = state;
  10eed2:	62e2      	str	r2, [r4, #44]	; 0x2c
    cur_clkid = clkid;
  10eed4:	f2c0 0313 	movt	r3, #19
    cur_per_id = per_id;
  10eed8:	6006      	str	r6, [r0, #0]
    ret = res_clk_set_rate(clk, per_id, freq);
  10eeda:	463a      	mov	r2, r7
    *lock = 1;
  10eedc:	62a1      	str	r1, [r4, #40]	; 0x28
  10eede:	4620      	mov	r0, r4
    cur_clkid = clkid;
  10eee0:	601d      	str	r5, [r3, #0]
    ret = res_clk_set_rate(clk, per_id, freq);
  10eee2:	4631      	mov	r1, r6
  10eee4:	f7ff f86a 	bl	10dfbc <res_clk_set_rate>
    spin_unlock_irqrestore(&clk->lock, clk->lockstate);
  10eee8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    *lock = 0;
  10eeea:	2200      	movs	r2, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10eeec:	07db      	lsls	r3, r3, #31
    *lock = 0;
  10eeee:	62a2      	str	r2, [r4, #40]	; 0x28
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10eef0:	d500      	bpl.n	10eef4 <res_clk_request+0x54>
    __asm__ volatile("cpsie i");
  10eef2:	b662      	cpsie	i
    return ret;
}
  10eef4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
  10eef6:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10eef8:	2201      	movs	r2, #1
  10eefa:	e7e3      	b.n	10eec4 <res_clk_request+0x24>
        CLK_TRACE(CRITICAL, "no such clk %d\n", clkid);
  10eefc:	f24c 60b4 	movw	r0, #50868	; 0xc6b4
  10ef00:	4629      	mov	r1, r5
  10ef02:	f2c0 0011 	movt	r0, #17
  10ef06:	f005 fc7d 	bl	114804 <printf>
        return -1;
  10ef0a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10ef0e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010ef10 <register_res_clks>:
    return 0;
}


void register_res_clks(void)
{
  10ef10:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
        }
        else if (is_pll(clk)) {
            clk->pll.dependson = NULL;
            clk->is_enable = clk_is_enable;
            clk->enable = clk_enable;
            clk->disable = clk_disable;
  10ef14:	f64d 31bd 	movw	r1, #56253	; 0xdbbd
    list->prev = list->next = list;
  10ef18:	f642 0718 	movw	r7, #10264	; 0x2818
  10ef1c:	4c1c      	ldr	r4, [pc, #112]	; (10ef90 <register_res_clks+0x80>)
            clk->is_enable = clk_is_enable;
  10ef1e:	f24d 23c1 	movw	r3, #53953	; 0xd2c1
            clk->enable = clk_enable;
  10ef22:	f64d 32c5 	movw	r2, #56261	; 0xdbc5
            clk->disable = clk_disable;
  10ef26:	f2c0 0110 	movt	r1, #16
{
  10ef2a:	b089      	sub	sp, #36	; 0x24
  10ef2c:	f1a4 0b68 	sub.w	r11, r4, #104	; 0x68
  10ef30:	f2c0 0712 	movt	r7, #18
            clk->is_enable = clk_is_enable;
  10ef34:	f2c0 0310 	movt	r3, #16
  10ef38:	4688      	mov	r8, r1
            clk->enable = clk_enable;
  10ef3a:	f2c0 0210 	movt	r2, #16
  10ef3e:	f8cd e010 	str.w	r14, [r13, #16]
            clk->is_enable = clk_is_enable;
  10ef42:	9302      	str	r3, [sp, #8]
            clk->enable = clk_enable;
  10ef44:	9203      	str	r2, [sp, #12]
  10ef46:	e9c7 7700 	strd	r7, r7, [r7]
  10ef4a:	f8cd b014 	str.w	r11, [r13, #20]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10ef4e:	f854 cc68 	ldr.w	r12, [r4, #-104]
    item->prev = item->next = 0;
  10ef52:	2200      	movs	r2, #0
    list->prev = list->next = list;
  10ef54:	6064      	str	r4, [r4, #4]
  10ef56:	f1a4 0968 	sub.w	r9, r4, #104	; 0x68
  10ef5a:	6024      	str	r4, [r4, #0]
  10ef5c:	f1ac 0305 	sub.w	r3, r12, #5
  10ef60:	2b65      	cmp	r3, #101	; 0x65
    item->prev = item->next = 0;
  10ef62:	e944 2202 	strd	r2, r2, [r4, #-8]
  10ef66:	f1a4 0608 	sub.w	r6, r4, #8
    *lock = SPIN_LOCK_INITIAL_VALUE;
  10ef6a:	f844 2c40 	str.w	r2, [r4, #-64]
        clk->refcount_en[i] = 0;
  10ef6e:	e944 220e 	strd	r2, r2, [r4, #-56]	; 0x38
    int *table = clk->ptable;
  10ef72:	6920      	ldr	r0, [r4, #16]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10ef74:	f200 82e3 	bhi.w	10f53e <register_res_clks+0x62e>
        if (clk->pll.plldiv == PLL_DUMMY_ROOT) {
  10ef78:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  10ef7a:	2b05      	cmp	r3, #5
  10ef7c:	f000 8342 	beq.w	10f604 <register_res_clks+0x6f4>
            clk->parent_nums = 1;
  10ef80:	2101      	movs	r1, #1
    for (i = 0; i < num; i++) {
  10ef82:	4613      	mov	r3, r2
            clk->cur_parent_index = 0;
  10ef84:	f844 2c30 	str.w	r2, [r4, #-48]
            clk->parents[0] = get_clk_by_id_from_array((unsigned long)table);
  10ef88:	465a      	mov	r2, r11
            clk->parent_nums = 1;
  10ef8a:	f844 1c2c 	str.w	r1, [r4, #-44]
  10ef8e:	e007      	b.n	10efa0 <register_res_clks+0x90>
  10ef90:	00122888 	.word	0x00122888
    for (i = 0; i < num; i++) {
  10ef94:	3301      	adds	r3, #1
  10ef96:	2b86      	cmp	r3, #134	; 0x86
  10ef98:	f102 02f0 	add.w	r2, r2, #240	; 0xf0
  10ef9c:	f000 8371 	beq.w	10f682 <register_res_clks+0x772>
        if (init_clks_table[i].clkid == clkid) {
  10efa0:	6811      	ldr	r1, [r2, #0]
  10efa2:	4288      	cmp	r0, r1
  10efa4:	d1f6      	bne.n	10ef94 <register_res_clks+0x84>
            return &init_clks_table[i];
  10efa6:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  10efaa:	eb0b 1303 	add.w	r3, r11, r3, lsl #4
            clk->parents[0] = get_clk_by_id_from_array((unsigned long)table);
  10efae:	f844 3c28 	str.w	r3, [r4, #-40]
            && clk->clkid <= CLK_ID_FIXRATE_LAST) {
  10efb2:	f10c 3cff 	add.w	r12, r12, #4294967295	; 0xffffffff
    if (clk->clkid >= CLK_ID_FIXRATE_FIRST
  10efb6:	f1bc 0f03 	cmp.w	r12, #3
  10efba:	f240 82ba 	bls.w	10f532 <register_res_clks+0x622>
            clk->set_rate = clk_set_rate;
  10efbe:	f24e 204d 	movw	r0, #57933	; 0xe24d
            clk->get_rate = clk_get_rate;
  10efc2:	f64d 012d 	movw	r1, #55341	; 0xd82d
            clk->round_rate = clk_round_rate;
  10efc6:	f64e 1285 	movw	r2, #59781	; 0xe985
            clk->set_parent = clk_set_parent;
  10efca:	f24d 63b1 	movw	r3, #54961	; 0xd6b1
            clk->is_enable = clk_is_enable;
  10efce:	9d02      	ldr	r5, [sp, #8]
            clk->set_rate = clk_set_rate;
  10efd0:	f2c0 0010 	movt	r0, #16
            clk->get_rate = clk_get_rate;
  10efd4:	f2c0 0110 	movt	r1, #16
            clk->round_rate = clk_round_rate;
  10efd8:	f2c0 0210 	movt	r2, #16
            clk->pll.dependson = NULL;
  10efdc:	f04f 0c00 	mov.w	r12, #0
            clk->set_parent = clk_set_parent;
  10efe0:	f2c0 0310 	movt	r3, #16
            clk->is_enable = clk_is_enable;
  10efe4:	66e5      	str	r5, [r4, #108]	; 0x6c
            clk->enable = clk_enable;
  10efe6:	9d03      	ldr	r5, [sp, #12]
            clk->disable = clk_disable;
  10efe8:	e9c4 581c 	strd	r5, r8, [r4, #112]	; 0x70
            clk->get_rate = clk_get_rate;
  10efec:	e9c4 011e 	strd	r0, r1, [r4, #120]	; 0x78
            clk->set_parent = clk_set_parent;
  10eff0:	e9c4 2320 	strd	r2, r3, [r4, #128]	; 0x80
            clk->pll.dependson = NULL;
  10eff4:	f8c4 c02c 	str.w	r12, [r4, #44]	; 0x2c
    int32_t slice_idx = -1;
  10eff8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10effc:	aa08      	add	r2, sp, #32
        else {
            ASSERT(0);
        }

        //mindiv maxdiv limit
        clk->mindiv = 1;
  10effe:	f04f 0c01 	mov.w	r12, #1
        clk->maxdiv = INT16_MAX;
  10f002:	f647 73ff 	movw	r3, #32767	; 0x7fff
    int32_t slice_idx = -1;
  10f006:	f842 1d04 	str.w	r1, [r2, #-4]!
    ret = res_get_info_by_id(resid, &phy_addr, &slice_idx);
  10f00a:	a906      	add	r1, sp, #24
        //freq limit
        //clk->minfreq =0;
        //clk->maxfreq =UINT32_MAX;

        //TODO , if not belong this domain, will using dummy rate
        if (!is_rc(clk) && !is_res_belong_this_domain(clk->resid)) {
  10f00c:	f854 0c64 	ldr.w	r0, [r4, #-100]
        clk->maxdiv = INT16_MAX;
  10f010:	e9c4 c306 	strd	r12, r3, [r4, #24]
    ret = res_get_info_by_id(resid, &phy_addr, &slice_idx);
  10f014:	f001 f98e 	bl	110334 <res_get_info_by_id>
    if (ret == -1) {
  10f018:	3001      	adds	r0, #1
  10f01a:	f000 82e3 	beq.w	10f5e4 <register_res_clks+0x6d4>
    item->prev = list->prev;
  10f01e:	683b      	ldr	r3, [r7, #0]
            }
        }

        list_add_tail(&g_clk_root, &clk->node);
        //init enable status
        clk->enable_cnt = clk_is_hw_enable(clk);
  10f020:	4648      	mov	r0, r9
  10f022:	e944 3702 	strd	r3, r7, [r4, #-8]
    list->prev->next = item;
  10f026:	605e      	str	r6, [r3, #4]
    list->prev = item;
  10f028:	603e      	str	r6, [r7, #0]
  10f02a:	f7fe fae3 	bl	10d5f4 <clk_is_hw_enable>
  10f02e:	6660      	str	r0, [r4, #100]	; 0x64
    for (i = 0; i < num; i++) {
  10f030:	4bbc      	ldr	r3, [pc, #752]	; (10f324 <register_res_clks+0x414>)
  10f032:	34f0      	adds	r4, #240	; 0xf0
  10f034:	42a3      	cmp	r3, r4
  10f036:	d18a      	bne.n	10ef4e <register_res_clks+0x3e>
    return get_clk_by_id_internal(NULL, clkid);
  10f038:	21cf      	movs	r1, #207	; 0xcf
  10f03a:	2000      	movs	r0, #0
  10f03c:	9e05      	ldr	r6, [sp, #20]
  10f03e:	f7fd fedf 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f042:	b120      	cbz	r0, 10f04e <register_res_clks+0x13e>
    clk->maxdiv = maxdiv;
  10f044:	2201      	movs	r2, #1
  10f046:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f04a:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f04e:	21d1      	movs	r1, #209	; 0xd1
  10f050:	2000      	movs	r0, #0
  10f052:	f7fd fed5 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f056:	b120      	cbz	r0, 10f062 <register_res_clks+0x152>
    clk->maxdiv = maxdiv;
  10f058:	2202      	movs	r2, #2
  10f05a:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f05e:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f062:	21d2      	movs	r1, #210	; 0xd2
  10f064:	2000      	movs	r0, #0
  10f066:	f7fd fecb 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f06a:	b120      	cbz	r0, 10f076 <register_res_clks+0x166>
    clk->maxdiv = maxdiv;
  10f06c:	2204      	movs	r2, #4
  10f06e:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f072:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f076:	21d3      	movs	r1, #211	; 0xd3
  10f078:	2000      	movs	r0, #0
  10f07a:	f7fd fec1 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f07e:	b120      	cbz	r0, 10f08a <register_res_clks+0x17a>
    clk->maxdiv = maxdiv;
  10f080:	2208      	movs	r2, #8
  10f082:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f086:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f08a:	21d5      	movs	r1, #213	; 0xd5
  10f08c:	2000      	movs	r0, #0
  10f08e:	f7fd feb7 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f092:	b120      	cbz	r0, 10f09e <register_res_clks+0x18e>
    clk->maxdiv = maxdiv;
  10f094:	2201      	movs	r2, #1
  10f096:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f09a:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f09e:	21d7      	movs	r1, #215	; 0xd7
  10f0a0:	2000      	movs	r0, #0
  10f0a2:	f7fd fead 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f0a6:	b120      	cbz	r0, 10f0b2 <register_res_clks+0x1a2>
    clk->maxdiv = maxdiv;
  10f0a8:	2202      	movs	r2, #2
  10f0aa:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f0ae:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f0b2:	21d8      	movs	r1, #216	; 0xd8
  10f0b4:	2000      	movs	r0, #0
  10f0b6:	f7fd fea3 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f0ba:	b120      	cbz	r0, 10f0c6 <register_res_clks+0x1b6>
    clk->maxdiv = maxdiv;
  10f0bc:	2204      	movs	r2, #4
  10f0be:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f0c2:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f0c6:	21d9      	movs	r1, #217	; 0xd9
  10f0c8:	2000      	movs	r0, #0
  10f0ca:	f7fd fe99 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f0ce:	b120      	cbz	r0, 10f0da <register_res_clks+0x1ca>
    clk->maxdiv = maxdiv;
  10f0d0:	2208      	movs	r2, #8
  10f0d2:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f0d6:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f0da:	21db      	movs	r1, #219	; 0xdb
  10f0dc:	2000      	movs	r0, #0
  10f0de:	f7fd fe8f 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f0e2:	b120      	cbz	r0, 10f0ee <register_res_clks+0x1de>
    clk->maxdiv = maxdiv;
  10f0e4:	2201      	movs	r2, #1
  10f0e6:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f0ea:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f0ee:	21dd      	movs	r1, #221	; 0xdd
  10f0f0:	2000      	movs	r0, #0
  10f0f2:	f7fd fe85 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f0f6:	b120      	cbz	r0, 10f102 <register_res_clks+0x1f2>
    clk->maxdiv = maxdiv;
  10f0f8:	2202      	movs	r2, #2
  10f0fa:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f0fe:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f102:	21de      	movs	r1, #222	; 0xde
  10f104:	2000      	movs	r0, #0
  10f106:	f7fd fe7b 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f10a:	b120      	cbz	r0, 10f116 <register_res_clks+0x206>
    clk->maxdiv = maxdiv;
  10f10c:	2204      	movs	r2, #4
  10f10e:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f112:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f116:	21df      	movs	r1, #223	; 0xdf
  10f118:	2000      	movs	r0, #0
  10f11a:	f7fd fe71 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f11e:	b120      	cbz	r0, 10f12a <register_res_clks+0x21a>
    clk->maxdiv = maxdiv;
  10f120:	2208      	movs	r2, #8
  10f122:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f126:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f12a:	21e1      	movs	r1, #225	; 0xe1
  10f12c:	2000      	movs	r0, #0
  10f12e:	f7fd fe67 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f132:	b120      	cbz	r0, 10f13e <register_res_clks+0x22e>
    clk->maxdiv = maxdiv;
  10f134:	2201      	movs	r2, #1
  10f136:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f13a:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f13e:	21e3      	movs	r1, #227	; 0xe3
  10f140:	2000      	movs	r0, #0
  10f142:	f7fd fe5d 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f146:	b120      	cbz	r0, 10f152 <register_res_clks+0x242>
    clk->maxdiv = maxdiv;
  10f148:	2201      	movs	r2, #1
  10f14a:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f14e:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f152:	21e4      	movs	r1, #228	; 0xe4
  10f154:	2000      	movs	r0, #0
  10f156:	f7fd fe53 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f15a:	b120      	cbz	r0, 10f166 <register_res_clks+0x256>
    clk->maxdiv = maxdiv;
  10f15c:	2204      	movs	r2, #4
  10f15e:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f162:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f166:	21e5      	movs	r1, #229	; 0xe5
  10f168:	2000      	movs	r0, #0
  10f16a:	f7fd fe49 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f16e:	b120      	cbz	r0, 10f17a <register_res_clks+0x26a>
    clk->maxdiv = maxdiv;
  10f170:	2201      	movs	r2, #1
  10f172:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f176:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f17a:	21e7      	movs	r1, #231	; 0xe7
  10f17c:	2000      	movs	r0, #0
  10f17e:	f7fd fe3f 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f182:	b120      	cbz	r0, 10f18e <register_res_clks+0x27e>
    clk->maxdiv = maxdiv;
  10f184:	2201      	movs	r2, #1
  10f186:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f18a:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f18e:	21e9      	movs	r1, #233	; 0xe9
  10f190:	2000      	movs	r0, #0
  10f192:	f7fd fe35 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f196:	b120      	cbz	r0, 10f1a2 <register_res_clks+0x292>
    clk->maxdiv = maxdiv;
  10f198:	2201      	movs	r2, #1
  10f19a:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f19e:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f1a2:	21ea      	movs	r1, #234	; 0xea
  10f1a4:	2000      	movs	r0, #0
  10f1a6:	f7fd fe2b 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f1aa:	b120      	cbz	r0, 10f1b6 <register_res_clks+0x2a6>
    clk->maxdiv = maxdiv;
  10f1ac:	2204      	movs	r2, #4
  10f1ae:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f1b2:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f1b6:	21eb      	movs	r1, #235	; 0xeb
  10f1b8:	2000      	movs	r0, #0
  10f1ba:	f7fd fe21 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f1be:	b120      	cbz	r0, 10f1ca <register_res_clks+0x2ba>
    clk->maxdiv = maxdiv;
  10f1c0:	2201      	movs	r2, #1
  10f1c2:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f1c6:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f1ca:	21f9      	movs	r1, #249	; 0xf9
  10f1cc:	2000      	movs	r0, #0
  10f1ce:	f7fd fe17 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f1d2:	b120      	cbz	r0, 10f1de <register_res_clks+0x2ce>
    clk->maxdiv = maxdiv;
  10f1d4:	2201      	movs	r2, #1
  10f1d6:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f1da:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f1de:	21fb      	movs	r1, #251	; 0xfb
  10f1e0:	2000      	movs	r0, #0
  10f1e2:	f7fd fe0d 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f1e6:	b120      	cbz	r0, 10f1f2 <register_res_clks+0x2e2>
    clk->maxdiv = maxdiv;
  10f1e8:	2204      	movs	r2, #4
  10f1ea:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f1ee:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f1f2:	21fc      	movs	r1, #252	; 0xfc
  10f1f4:	2000      	movs	r0, #0
  10f1f6:	f7fd fe03 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f1fa:	b120      	cbz	r0, 10f206 <register_res_clks+0x2f6>
    clk->maxdiv = maxdiv;
  10f1fc:	2201      	movs	r2, #1
  10f1fe:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f202:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f206:	21fd      	movs	r1, #253	; 0xfd
  10f208:	2000      	movs	r0, #0
  10f20a:	f7fd fdf9 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f20e:	b120      	cbz	r0, 10f21a <register_res_clks+0x30a>
    clk->maxdiv = maxdiv;
  10f210:	2201      	movs	r2, #1
  10f212:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f216:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f21a:	21ff      	movs	r1, #255	; 0xff
  10f21c:	2000      	movs	r0, #0
  10f21e:	f7fd fdef 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f222:	b120      	cbz	r0, 10f22e <register_res_clks+0x31e>
    clk->maxdiv = maxdiv;
  10f224:	2201      	movs	r2, #1
  10f226:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f22a:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f22e:	f240 1101 	movw	r1, #257	; 0x101
  10f232:	2000      	movs	r0, #0
  10f234:	f7fd fde4 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f238:	b120      	cbz	r0, 10f244 <register_res_clks+0x334>
    clk->maxdiv = maxdiv;
  10f23a:	2204      	movs	r2, #4
  10f23c:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f240:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f244:	f44f 7181 	mov.w	r1, #258	; 0x102
  10f248:	2000      	movs	r0, #0
  10f24a:	f7fd fdd9 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f24e:	b120      	cbz	r0, 10f25a <register_res_clks+0x34a>
    clk->maxdiv = maxdiv;
  10f250:	2201      	movs	r2, #1
  10f252:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f256:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f25a:	f240 1103 	movw	r1, #259	; 0x103
  10f25e:	2000      	movs	r0, #0
  10f260:	f7fd fdce 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f264:	b120      	cbz	r0, 10f270 <register_res_clks+0x360>
    clk->maxdiv = maxdiv;
  10f266:	2201      	movs	r2, #1
  10f268:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f26c:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f270:	f240 1105 	movw	r1, #261	; 0x105
  10f274:	2000      	movs	r0, #0
  10f276:	f7fd fdc3 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f27a:	b120      	cbz	r0, 10f286 <register_res_clks+0x376>
    clk->maxdiv = maxdiv;
  10f27c:	2201      	movs	r2, #1
  10f27e:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f282:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f286:	f240 1107 	movw	r1, #263	; 0x107
  10f28a:	2000      	movs	r0, #0
  10f28c:	f7fd fdb8 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f290:	b120      	cbz	r0, 10f29c <register_res_clks+0x38c>
    clk->maxdiv = maxdiv;
  10f292:	2202      	movs	r2, #2
  10f294:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f298:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f29c:	f44f 7184 	mov.w	r1, #264	; 0x108
  10f2a0:	2000      	movs	r0, #0
  10f2a2:	f7fd fdad 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f2a6:	b120      	cbz	r0, 10f2b2 <register_res_clks+0x3a2>
    clk->maxdiv = maxdiv;
  10f2a8:	2204      	movs	r2, #4
  10f2aa:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f2ae:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f2b2:	f240 1109 	movw	r1, #265	; 0x109
  10f2b6:	2000      	movs	r0, #0
  10f2b8:	f7fd fda2 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f2bc:	b120      	cbz	r0, 10f2c8 <register_res_clks+0x3b8>
    clk->maxdiv = maxdiv;
  10f2be:	2201      	movs	r2, #1
  10f2c0:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f2c4:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f2c8:	f240 110b 	movw	r1, #267	; 0x10b
  10f2cc:	2000      	movs	r0, #0
  10f2ce:	f7fd fd97 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f2d2:	b120      	cbz	r0, 10f2de <register_res_clks+0x3ce>
    clk->maxdiv = maxdiv;
  10f2d4:	2201      	movs	r2, #1
  10f2d6:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f2da:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f2de:	f240 110d 	movw	r1, #269	; 0x10d
  10f2e2:	2000      	movs	r0, #0
  10f2e4:	f7fd fd8c 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f2e8:	b120      	cbz	r0, 10f2f4 <register_res_clks+0x3e4>
    clk->maxdiv = maxdiv;
  10f2ea:	220a      	movs	r2, #10
  10f2ec:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f2f0:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f2f4:	f44f 7187 	mov.w	r1, #270	; 0x10e
  10f2f8:	2000      	movs	r0, #0
  10f2fa:	f7fd fd81 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f2fe:	b120      	cbz	r0, 10f30a <register_res_clks+0x3fa>
    clk->maxdiv = maxdiv;
  10f300:	2202      	movs	r2, #2
  10f302:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f306:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
    return get_clk_by_id_internal(NULL, clkid);
  10f30a:	f240 110f 	movw	r1, #271	; 0x10f
  10f30e:	2000      	movs	r0, #0
  10f310:	f7fd fd76 	bl	10ce00 <get_clk_by_id_internal>
    if (!clk) {
  10f314:	b140      	cbz	r0, 10f328 <register_res_clks+0x418>
    clk->maxdiv = maxdiv;
  10f316:	2204      	movs	r2, #4
  10f318:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f31c:	e9c0 2320 	strd	r2, r3, [r0, #128]	; 0x80
  10f320:	e002      	b.n	10f328 <register_res_clks+0x418>
  10f322:	bf00      	nop
  10f324:	0012a628 	.word	0x0012a628
    CLK_UUU_RATIO_LIMIT(CLK_ID_VPU_BUS, 1, 4, 1, 1)
    CLK_UUU_RATIO_LIMIT(CLK_ID_VSN_BUS, 1, 4, 1, 1)
    CLK_UUU_RATIO_LIMIT(CLK_ID_DDR, 1, 2, 4, 1)
    CLK_UUU_RATIO_LIMIT(CLK_ID_HIS_BUS, 1, 10, 2, 4)
    //init dependson
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_CPU1A, CLK_ID_CPU1A_2)
  10f328:	21d2      	movs	r1, #210	; 0xd2
  10f32a:	2011      	movs	r0, #17
  10f32c:	f7fd ffe8 	bl	10d300 <clk_set_depends_on>
  10f330:	21d2      	movs	r1, #210	; 0xd2
  10f332:	204d      	movs	r0, #77	; 0x4d
  10f334:	f50b 45fb 	add.w	r5, r11, #32128	; 0x7d80
  10f338:	f7fd ffe2 	bl	10d300 <clk_set_depends_on>
  10f33c:	21d2      	movs	r1, #210	; 0xd2
  10f33e:	204e      	movs	r0, #78	; 0x4e
  10f340:	3520      	adds	r5, #32
  10f342:	f7fd ffdd 	bl	10d300 <clk_set_depends_on>
  10f346:	21d2      	movs	r1, #210	; 0xd2
  10f348:	204f      	movs	r0, #79	; 0x4f
    return get_clk_by_id_internal(NULL, clkid);
  10f34a:	f04f 0a00 	mov.w	r10, #0
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_CPU1A, CLK_ID_CPU1A_2)
  10f34e:	f7fd ffd7 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_CPU1B, CLK_ID_CPU1A_2)
  10f352:	21d2      	movs	r1, #210	; 0xd2
  10f354:	2012      	movs	r0, #18
        }
        else if (clk->parent_nums == 1) {
            clk->cur_parent_index = 0;
        }
        else {
            clk->cur_parent_index = -1;
  10f356:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_CPU1B, CLK_ID_CPU1A_2)
  10f35a:	f7fd ffd1 	bl	10d300 <clk_set_depends_on>
  10f35e:	21d2      	movs	r1, #210	; 0xd2
  10f360:	2050      	movs	r0, #80	; 0x50
  10f362:	f7fd ffcd 	bl	10d300 <clk_set_depends_on>
  10f366:	21d2      	movs	r1, #210	; 0xd2
  10f368:	2051      	movs	r0, #81	; 0x51
  10f36a:	f7fd ffc9 	bl	10d300 <clk_set_depends_on>
  10f36e:	21d2      	movs	r1, #210	; 0xd2
  10f370:	2052      	movs	r0, #82	; 0x52
  10f372:	f7fd ffc5 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_CPU2, CLK_ID_CPU2_2)
  10f376:	21de      	movs	r1, #222	; 0xde
  10f378:	2013      	movs	r0, #19
  10f37a:	f7fd ffc1 	bl	10d300 <clk_set_depends_on>
  10f37e:	21de      	movs	r1, #222	; 0xde
  10f380:	2053      	movs	r0, #83	; 0x53
  10f382:	f7fd ffbd 	bl	10d300 <clk_set_depends_on>
  10f386:	21de      	movs	r1, #222	; 0xde
  10f388:	2054      	movs	r0, #84	; 0x54
  10f38a:	f7fd ffb9 	bl	10d300 <clk_set_depends_on>
  10f38e:	21de      	movs	r1, #222	; 0xde
  10f390:	2055      	movs	r0, #85	; 0x55
  10f392:	f7fd ffb5 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_GPU1, CLK_ID_GPU1_2)
  10f396:	21e4      	movs	r1, #228	; 0xe4
  10f398:	2014      	movs	r0, #20
  10f39a:	f7fd ffb1 	bl	10d300 <clk_set_depends_on>
  10f39e:	21e4      	movs	r1, #228	; 0xe4
  10f3a0:	2056      	movs	r0, #86	; 0x56
  10f3a2:	f7fd ffad 	bl	10d300 <clk_set_depends_on>
  10f3a6:	21e4      	movs	r1, #228	; 0xe4
  10f3a8:	2057      	movs	r0, #87	; 0x57
  10f3aa:	f7fd ffa9 	bl	10d300 <clk_set_depends_on>
  10f3ae:	21e4      	movs	r1, #228	; 0xe4
  10f3b0:	2058      	movs	r0, #88	; 0x58
  10f3b2:	f7fd ffa5 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_GPU2, CLK_ID_GPU2_2)
  10f3b6:	21ea      	movs	r1, #234	; 0xea
  10f3b8:	2015      	movs	r0, #21
  10f3ba:	f7fd ffa1 	bl	10d300 <clk_set_depends_on>
  10f3be:	21ea      	movs	r1, #234	; 0xea
  10f3c0:	2059      	movs	r0, #89	; 0x59
  10f3c2:	f7fd ff9d 	bl	10d300 <clk_set_depends_on>
  10f3c6:	21ea      	movs	r1, #234	; 0xea
  10f3c8:	205a      	movs	r0, #90	; 0x5a
  10f3ca:	f7fd ff99 	bl	10d300 <clk_set_depends_on>
  10f3ce:	21ea      	movs	r1, #234	; 0xea
  10f3d0:	205b      	movs	r0, #91	; 0x5b
  10f3d2:	f7fd ff95 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_VPU, CLK_ID_VPU_BUS_1)
  10f3d6:	21fb      	movs	r1, #251	; 0xfb
  10f3d8:	2016      	movs	r0, #22
  10f3da:	f7fd ff91 	bl	10d300 <clk_set_depends_on>
  10f3de:	21fb      	movs	r1, #251	; 0xfb
  10f3e0:	205c      	movs	r0, #92	; 0x5c
  10f3e2:	f7fd ff8d 	bl	10d300 <clk_set_depends_on>
  10f3e6:	21fb      	movs	r1, #251	; 0xfb
  10f3e8:	205d      	movs	r0, #93	; 0x5d
  10f3ea:	f7fd ff89 	bl	10d300 <clk_set_depends_on>
  10f3ee:	21fb      	movs	r1, #251	; 0xfb
  10f3f0:	205e      	movs	r0, #94	; 0x5e
  10f3f2:	f7fd ff85 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_DDR, CLK_ID_DDR_2)
  10f3f6:	f44f 7184 	mov.w	r1, #264	; 0x108
  10f3fa:	201a      	movs	r0, #26
  10f3fc:	f7fd ff80 	bl	10d300 <clk_set_depends_on>
  10f400:	f44f 7184 	mov.w	r1, #264	; 0x108
  10f404:	2068      	movs	r0, #104	; 0x68
  10f406:	f7fd ff7b 	bl	10d300 <clk_set_depends_on>
  10f40a:	f44f 7184 	mov.w	r1, #264	; 0x108
  10f40e:	2069      	movs	r0, #105	; 0x69
  10f410:	f7fd ff76 	bl	10d300 <clk_set_depends_on>
  10f414:	f44f 7184 	mov.w	r1, #264	; 0x108
  10f418:	206a      	movs	r0, #106	; 0x6a
  10f41a:	f7fd ff71 	bl	10d300 <clk_set_depends_on>
    SET_CLK_PLL_DEPENDS_AB(CLK_ID_PLL_VSN, CLK_ID_VSN_BUS_1)
  10f41e:	f240 1101 	movw	r1, #257	; 0x101
  10f422:	2017      	movs	r0, #23
  10f424:	f7fd ff6c 	bl	10d300 <clk_set_depends_on>
  10f428:	f240 1101 	movw	r1, #257	; 0x101
  10f42c:	205f      	movs	r0, #95	; 0x5f
  10f42e:	f7fd ff67 	bl	10d300 <clk_set_depends_on>
  10f432:	f240 1101 	movw	r1, #257	; 0x101
  10f436:	2060      	movs	r0, #96	; 0x60
  10f438:	f7fd ff62 	bl	10d300 <clk_set_depends_on>
  10f43c:	f240 1101 	movw	r1, #257	; 0x101
  10f440:	2061      	movs	r0, #97	; 0x61
  10f442:	f7fd ff5d 	bl	10d300 <clk_set_depends_on>
    clk_set_moreprecise(CLK_ID_PLL_DDR, true, 0);
  10f446:	201a      	movs	r0, #26
  10f448:	f7fe f856 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
    clk_set_moreprecise(CLK_ID_PLL_DISP, true, 0);
  10f44c:	200c      	movs	r0, #12
  10f44e:	f7fe f853 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
    clk_set_moreprecise(CLK_ID_PLL_LVDS1, true, 0);
  10f452:	200d      	movs	r0, #13
  10f454:	f7fe f850 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
    clk_set_moreprecise(CLK_ID_PLL_LVDS2, true, 0);
  10f458:	200e      	movs	r0, #14
  10f45a:	f7fe f84d 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
    clk_set_moreprecise(CLK_ID_PLL_LVDS3, true, 0);
  10f45e:	200f      	movs	r0, #15
  10f460:	f7fe f84a 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
    clk_set_moreprecise(CLK_ID_PLL_LVDS4, true, 0);
  10f464:	2010      	movs	r0, #16
  10f466:	f7fe f847 	bl	10d4f8 <clk_set_moreprecise.constprop.30>
  10f46a:	e007      	b.n	10f47c <register_res_clks+0x56c>
            clk->cur_parent_index = -1;
  10f46c:	bf18      	it	ne
  10f46e:	f8c0 8038 	strne.w	r8, [r0, #56]	; 0x38
        else if (clk->parent_nums == 1) {
  10f472:	f000 80b3 	beq.w	10f5dc <register_res_clks+0x6cc>
  10f476:	36f0      	adds	r6, #240	; 0xf0
    for (i = 0; i < num; i++) {
  10f478:	42b5      	cmp	r5, r6
  10f47a:	d04f      	beq.n	10f51c <register_res_clks+0x60c>
    return get_clk_by_id_internal(NULL, clkid);
  10f47c:	6831      	ldr	r1, [r6, #0]
  10f47e:	2000      	movs	r0, #0
  10f480:	f7fd fcbe 	bl	10ce00 <get_clk_by_id_internal>
        if (!clk) { continue; }
  10f484:	4604      	mov	r4, r0
  10f486:	2800      	cmp	r0, #0
  10f488:	d0f5      	beq.n	10f476 <register_res_clks+0x566>
        if (clk->parent_nums > 1) {
  10f48a:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
  10f48c:	2b01      	cmp	r3, #1
  10f48e:	dded      	ble.n	10f46c <register_res_clks+0x55c>
    if (!is_pll(clk)) {
  10f490:	6803      	ldr	r3, [r0, #0]
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10f492:	1f5a      	subs	r2, r3, #5
  10f494:	2a65      	cmp	r2, #101	; 0x65
  10f496:	f240 80ba 	bls.w	10f60e <register_res_clks+0x6fe>
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10f49a:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10f49e:	2a06      	cmp	r2, #6
  10f4a0:	f240 80be 	bls.w	10f620 <register_res_clks+0x710>
            && clk->clkid <= CLK_ID_CKGEN_CORE_LAST) {
  10f4a4:	f1a3 0272 	sub.w	r2, r3, #114	; 0x72
    if (clk->clkid >= CLK_ID_CKGEN_CORE_FIRST
  10f4a8:	2a06      	cmp	r2, #6
  10f4aa:	f240 80d3 	bls.w	10f654 <register_res_clks+0x744>
            && clk->clkid <= CLK_ID_CKGEN_IP_LAST) {
  10f4ae:	f1a3 0279 	sub.w	r2, r3, #121	; 0x79
    if (clk->clkid >= CLK_ID_CKGEN_IP_FIRST
  10f4b2:	2a54      	cmp	r2, #84	; 0x54
  10f4b4:	f240 80c3 	bls.w	10f63e <register_res_clks+0x72e>
            && clk->clkid <= CLK_ID_CKGEN_UUU_LAST) {
  10f4b8:	3bce      	subs	r3, #206	; 0xce
    if (clk->clkid >= CLK_ID_CKGEN_UUU_FIRST
  10f4ba:	2b41      	cmp	r3, #65	; 0x41
  10f4bc:	f200 80ee 	bhi.w	10f69c <register_res_clks+0x78c>
    if (get_ckgen_uuu_ctl(resid, &ctl) < 0) {
  10f4c0:	6860      	ldr	r0, [r4, #4]
  10f4c2:	a907      	add	r1, sp, #28
        return get_ckgen_uuu_parent(clk->resid, clk->uuu.uuu_type);
  10f4c4:	f8d4 9088 	ldr.w	r9, [r4, #136]	; 0x88
  10f4c8:	f7fd fd18 	bl	10cefc <get_ckgen_uuu_ctl>
  10f4cc:	2800      	cmp	r0, #0
  10f4ce:	f2c0 80c7 	blt.w	10f660 <register_res_clks+0x750>
    if (uuu_type == UUU_SEL0) {
  10f4d2:	f1b9 0f00 	cmp.w	r9, #0
  10f4d6:	f000 80cf 	beq.w	10f678 <register_res_clks+0x768>
             && uuu_type <= UUU_Q) {//mnpq only have one parent.
  10f4da:	f1a9 0902 	sub.w	r9, r9, #2
    else if (uuu_type >= UUU_M
  10f4de:	f1b9 0f03 	cmp.w	r9, #3
  10f4e2:	d97b      	bls.n	10f5dc <register_res_clks+0x6cc>
        return ctl.uuu_sel1;
  10f4e4:	f89d 301e 	ldrb.w	r3, [r13, #30]
  10f4e8:	f3c3 0340 	ubfx	r3, r3, #1, #1
            clk->cur_parent_index = clk_get_current_parent_from_hw(clk);
  10f4ec:	63a3      	str	r3, [r4, #56]	; 0x38
    item->next->prev = item->prev;
  10f4ee:	6e27      	ldr	r7, [r4, #96]	; 0x60
        }

        // add to global list or child of parent
        if (clk->cur_parent_index != -1) {
            struct clk *p = clk->parents[clk->cur_parent_index];
  10f4f0:	3310      	adds	r3, #16
  10f4f2:	6e61      	ldr	r1, [r4, #100]	; 0x64
  10f4f4:	36f0      	adds	r6, #240	; 0xf0
            list_delete(&clk->node);
  10f4f6:	f104 0060 	add.w	r0, r4, #96	; 0x60
            struct clk *p = clk->parents[clk->cur_parent_index];
  10f4fa:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    for (i = 0; i < num; i++) {
  10f4fe:	42b5      	cmp	r5, r6
  10f500:	600f      	str	r7, [r1, #0]
    item->prev = list->prev;
  10f502:	461a      	mov	r2, r3
    item->prev->next = item->next;
  10f504:	6e27      	ldr	r7, [r4, #96]	; 0x60
  10f506:	6079      	str	r1, [r7, #4]
    item->prev = item->next = 0;
  10f508:	f8c4 a060 	str.w	r10, [r4, #96]	; 0x60
    item->prev = list->prev;
  10f50c:	f852 1f68 	ldr.w	r1, [r2, #104]!
  10f510:	6621      	str	r1, [r4, #96]	; 0x60
    list->prev->next = item;
  10f512:	6e99      	ldr	r1, [r3, #104]	; 0x68
    item->next = list;
  10f514:	6662      	str	r2, [r4, #100]	; 0x64
    list->prev->next = item;
  10f516:	6048      	str	r0, [r1, #4]
    list->prev = item;
  10f518:	6698      	str	r0, [r3, #104]	; 0x68
  10f51a:	d1af      	bne.n	10f47c <register_res_clks+0x56c>
            list_add_tail(&(p->child), &clk->node);
        }
    }
}
  10f51c:	b009      	add	sp, #36	; 0x24
  10f51e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        clk->cur_parent_index = -1; //root clk
  10f522:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
            && clk->clkid <= CLK_ID_FIXRATE_LAST) {
  10f526:	eb0c 0302 	add.w	r3, r12, r2
        clk->cur_parent_index = -1; //root clk
  10f52a:	e944 210c 	strd	r2, r1, [r4, #-48]	; 0x30
    if (clk->clkid >= CLK_ID_FIXRATE_FIRST
  10f52e:	2b03      	cmp	r3, #3
  10f530:	d832      	bhi.n	10f598 <register_res_clks+0x688>
        clk->maxdiv = INT16_MAX;
  10f532:	2201      	movs	r2, #1
  10f534:	f647 73ff 	movw	r3, #32767	; 0x7fff
  10f538:	e9c4 2306 	strd	r2, r3, [r4, #24]
  10f53c:	e56f      	b.n	10f01e <register_res_clks+0x10e>
    else if (!clk->ptable_size) {
  10f53e:	68e1      	ldr	r1, [r4, #12]
  10f540:	2900      	cmp	r1, #0
  10f542:	d0ee      	beq.n	10f522 <register_res_clks+0x612>
  10f544:	bfc2      	ittt	gt
  10f546:	4684      	movgt	r12, r0
  10f548:	f1a4 0e2c 	subgt.w	r14, r4, #44	; 0x2c
  10f54c:	eb0c 0a81 	addgt.w	r10, r12, r1, lsl #2
        for (i = 0; i < clk->ptable_size; i++) {
  10f550:	dd16      	ble.n	10f580 <register_res_clks+0x670>
            clk->parents[i] = get_clk_by_id_from_array((unsigned long)table[i]);
  10f552:	f85c 2b04 	ldr.w	r2, [r12], #4
  10f556:	4658      	mov	r0, r11
    for (i = 0; i < num; i++) {
  10f558:	2300      	movs	r3, #0
  10f55a:	e004      	b.n	10f566 <register_res_clks+0x656>
  10f55c:	3301      	adds	r3, #1
  10f55e:	2b86      	cmp	r3, #134	; 0x86
  10f560:	f100 00f0 	add.w	r0, r0, #240	; 0xf0
  10f564:	d038      	beq.n	10f5d8 <register_res_clks+0x6c8>
        if (init_clks_table[i].clkid == clkid) {
  10f566:	6805      	ldr	r5, [r0, #0]
  10f568:	42aa      	cmp	r2, r5
  10f56a:	d1f7      	bne.n	10f55c <register_res_clks+0x64c>
            return &init_clks_table[i];
  10f56c:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  10f570:	eb0b 1303 	add.w	r3, r11, r3, lsl #4
            clk->parents[i] = get_clk_by_id_from_array((unsigned long)table[i]);
  10f574:	f84e 3f04 	str.w	r3, [r14, #4]!
        for (i = 0; i < clk->ptable_size; i++) {
  10f578:	45d4      	cmp	r12, r10
  10f57a:	d1ea      	bne.n	10f552 <register_res_clks+0x642>
  10f57c:	f854 cc68 	ldr.w	r12, [r4, #-104]
        clk->cur_parent_index = 0;
  10f580:	2200      	movs	r2, #0
            && clk->clkid <= CLK_ID_FIXRATE_LAST) {
  10f582:	f10c 33ff 	add.w	r3, r12, #4294967295	; 0xffffffff
    if (clk->clkid >= CLK_ID_FIXRATE_FIRST
  10f586:	2b03      	cmp	r3, #3
        clk->cur_parent_index = 0;
  10f588:	e944 210c 	strd	r2, r1, [r4, #-48]	; 0x30
    if (clk->clkid >= CLK_ID_FIXRATE_FIRST
  10f58c:	d9d1      	bls.n	10f532 <register_res_clks+0x622>
    if (clk->clkid >= CLK_ID_PLL_FIRST && clk->clkid <= CLK_ID_PLL_LAST) {
  10f58e:	f1ac 0305 	sub.w	r3, r12, #5
  10f592:	2b65      	cmp	r3, #101	; 0x65
  10f594:	f67f ad13 	bls.w	10efbe <register_res_clks+0xae>
    if (clk->clkid >= CLK_ID_CKGEN_FIRST && clk->clkid <= CLK_ID_CKGEN_LAST) {
  10f598:	f1ac 0c6b 	sub.w	r12, r12, #107	; 0x6b
  10f59c:	f1bc 0fa4 	cmp.w	r12, #164	; 0xa4
  10f5a0:	f200 808e 	bhi.w	10f6c0 <register_res_clks+0x7b0>
            clk->set_rate = clk_set_rate;
  10f5a4:	f24e 204d 	movw	r0, #57933	; 0xe24d
            clk->get_rate = clk_get_rate;
  10f5a8:	f64d 012d 	movw	r1, #55341	; 0xd82d
            clk->round_rate = clk_round_rate;
  10f5ac:	f64e 1285 	movw	r2, #59781	; 0xe985
            clk->set_parent = clk_set_parent;
  10f5b0:	f24d 63b1 	movw	r3, #54961	; 0xd6b1
            clk->is_enable = clk_is_enable;
  10f5b4:	9d02      	ldr	r5, [sp, #8]
            clk->set_rate = clk_set_rate;
  10f5b6:	f2c0 0010 	movt	r0, #16
            clk->get_rate = clk_get_rate;
  10f5ba:	f2c0 0110 	movt	r1, #16
            clk->round_rate = clk_round_rate;
  10f5be:	f2c0 0210 	movt	r2, #16
            clk->is_enable = clk_is_enable;
  10f5c2:	66e5      	str	r5, [r4, #108]	; 0x6c
            clk->set_parent = clk_set_parent;
  10f5c4:	f2c0 0310 	movt	r3, #16
            clk->enable = clk_enable;
  10f5c8:	9d03      	ldr	r5, [sp, #12]
            clk->disable = clk_disable;
  10f5ca:	e9c4 581c 	strd	r5, r8, [r4, #112]	; 0x70
            clk->get_rate = clk_get_rate;
  10f5ce:	e9c4 011e 	strd	r0, r1, [r4, #120]	; 0x78
            clk->set_parent = clk_set_parent;
  10f5d2:	e9c4 2320 	strd	r2, r3, [r4, #128]	; 0x80
  10f5d6:	e50f      	b.n	10eff8 <register_res_clks+0xe8>
    return NULL;
  10f5d8:	2300      	movs	r3, #0
  10f5da:	e7cb      	b.n	10f574 <register_res_clks+0x664>
            clk->cur_parent_index = 0;
  10f5dc:	f8c4 a038 	str.w	r10, [r4, #56]	; 0x38
        if (clk->cur_parent_index != -1) {
  10f5e0:	2300      	movs	r3, #0
  10f5e2:	e784      	b.n	10f4ee <register_res_clks+0x5de>
            if (clk->clkid == CLK_ID_PLL1 || clk->clkid == CLK_ID_PLL1_ROOT
  10f5e4:	f854 2c68 	ldr.w	r2, [r4, #-104]
  10f5e8:	f1a2 031b 	sub.w	r3, r2, #27
                    || clk->clkid == CLK_ID_PLL1_DIVC || clk->clkid == CLK_ID_PLL1_DIVD
  10f5ec:	2a05      	cmp	r2, #5
  10f5ee:	bf18      	it	ne
  10f5f0:	2b04      	cmpne	r3, #4
  10f5f2:	bf94      	ite	ls
  10f5f4:	2301      	movls	r3, #1
  10f5f6:	2300      	movhi	r3, #0
  10f5f8:	d845      	bhi.n	10f686 <register_res_clks+0x776>
                clk->rate = 0;
  10f5fa:	2300      	movs	r3, #0
  10f5fc:	60a3      	str	r3, [r4, #8]
                clk->round_rate = NULL;
  10f5fe:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  10f602:	e50c      	b.n	10f01e <register_res_clks+0x10e>
            clk->cur_parent_index = -1; //root clk
  10f604:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10f608:	e944 320c 	strd	r3, r2, [r4, #-48]	; 0x30
  10f60c:	e4d1      	b.n	10efb2 <register_res_clks+0xa2>
  10f60e:	f7fe f847 	bl	10d6a0 <is_clk_can_access.part.27>
    if (!is_clk_can_access(clk)) {
  10f612:	b378      	cbz	r0, 10f674 <register_res_clks+0x764>
  10f614:	6823      	ldr	r3, [r4, #0]
            && clk->clkid <= CLK_ID_CKGEN_BUS_LAST) {
  10f616:	f1a3 026b 	sub.w	r2, r3, #107	; 0x6b
    if (clk->clkid >= CLK_ID_CKGEN_BUS_FIRST
  10f61a:	2a06      	cmp	r2, #6
  10f61c:	f63f af42 	bhi.w	10f4a4 <register_res_clks+0x594>
    if (get_ckgen_bus_ctl(resid, &ctl, NULL) < 0) {
  10f620:	6860      	ldr	r0, [r4, #4]
  10f622:	a907      	add	r1, sp, #28
  10f624:	f7fd ffc0 	bl	10d5a8 <get_ckgen_bus_ctl.constprop.32>
  10f628:	2800      	cmp	r0, #0
  10f62a:	db19      	blt.n	10f660 <register_res_clks+0x750>
    return (ctl.a_b_sel == 0) ? ctl.src_sel_a : ctl.src_sel_b;
  10f62c:	f89d 301d 	ldrb.w	r3, [r13, #29]
  10f630:	079b      	lsls	r3, r3, #30
  10f632:	d50a      	bpl.n	10f64a <register_res_clks+0x73a>
  10f634:	f89d 301e 	ldrb.w	r3, [r13, #30]
  10f638:	f3c3 0342 	ubfx	r3, r3, #1, #3
  10f63c:	e756      	b.n	10f4ec <register_res_clks+0x5dc>
    if (get_ckgen_ip_ctl(resid, &ctl) < 0) {
  10f63e:	6860      	ldr	r0, [r4, #4]
  10f640:	a907      	add	r1, sp, #28
  10f642:	f7fd ff11 	bl	10d468 <get_ckgen_ip_ctl>
  10f646:	2800      	cmp	r0, #0
  10f648:	db0a      	blt.n	10f660 <register_res_clks+0x750>
    return ctl.src_sel;
  10f64a:	f89d 301c 	ldrb.w	r3, [r13, #28]
  10f64e:	f3c3 0342 	ubfx	r3, r3, #1, #3
  10f652:	e74b      	b.n	10f4ec <register_res_clks+0x5dc>
    if (get_ckgen_core_ctl(resid, &ctl) < 0) {
  10f654:	6860      	ldr	r0, [r4, #4]
  10f656:	a907      	add	r1, sp, #28
  10f658:	f7fd febe 	bl	10d3d8 <get_ckgen_core_ctl>
  10f65c:	2800      	cmp	r0, #0
  10f65e:	dae5      	bge.n	10f62c <register_res_clks+0x71c>
    item->next->prev = item->prev;
  10f660:	e9d4 2318 	ldrd	r2, r3, [r4, #96]	; 0x60
            clk->cur_parent_index = clk_get_current_parent_from_hw(clk);
  10f664:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  10f668:	601a      	str	r2, [r3, #0]
    item->prev->next = item->next;
  10f66a:	6e22      	ldr	r2, [r4, #96]	; 0x60
  10f66c:	6053      	str	r3, [r2, #4]
    item->prev = item->next = 0;
  10f66e:	e9c4 aa18 	strd	r10, r10, [r4, #96]	; 0x60
                continue;
  10f672:	e700      	b.n	10f476 <register_res_clks+0x566>
            clk->cur_parent_index = clk_get_current_parent_from_hw(clk);
  10f674:	63a0      	str	r0, [r4, #56]	; 0x38
  10f676:	e7b3      	b.n	10f5e0 <register_res_clks+0x6d0>
        return ctl.uuu_sel0;
  10f678:	f89d 301e 	ldrb.w	r3, [r13, #30]
  10f67c:	f003 0301 	and.w	r3, r3, #1
  10f680:	e734      	b.n	10f4ec <register_res_clks+0x5dc>
    return NULL;
  10f682:	2300      	movs	r3, #0
  10f684:	e493      	b.n	10efae <register_res_clks+0x9e>
            else if (clk->clkid == CLK_ID_PLL2 || clk->clkid == CLK_ID_PLL2_ROOT
  10f686:	f1a2 0120 	sub.w	r1, r2, #32
                     || clk->clkid == CLK_ID_PLL2_DIVC || clk->clkid == CLK_ID_PLL2_DIVD
  10f68a:	2a06      	cmp	r2, #6
  10f68c:	bf18      	it	ne
  10f68e:	2904      	cmpne	r1, #4
  10f690:	f63f acce 	bhi.w	10f030 <register_res_clks+0x120>
                clk->rate = 0;
  10f694:	60a3      	str	r3, [r4, #8]
                clk->round_rate = NULL;
  10f696:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  10f69a:	e4c0      	b.n	10f01e <register_res_clks+0x10e>
        ASSERT(0);
  10f69c:	f649 0384 	movw	r3, #39044	; 0x9884
  10f6a0:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10f6a4:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f6a8:	f2c0 0311 	movt	r3, #17
  10f6ac:	9804      	ldr	r0, [sp, #16]
  10f6ae:	f2c0 0211 	movt	r2, #17
  10f6b2:	9300      	str	r3, [sp, #0]
  10f6b4:	f2c0 0111 	movt	r1, #17
  10f6b8:	f240 23bd 	movw	r3, #701	; 0x2bd
  10f6bc:	f004 f86e 	bl	11379c <_panic>
            ASSERT(0);
  10f6c0:	f649 0384 	movw	r3, #39044	; 0x9884
  10f6c4:	f24c 52e8 	movw	r2, #50664	; 0xc5e8
  10f6c8:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f6cc:	f2c0 0311 	movt	r3, #17
  10f6d0:	9804      	ldr	r0, [sp, #16]
  10f6d2:	f2c0 0211 	movt	r2, #17
  10f6d6:	9300      	str	r3, [sp, #0]
  10f6d8:	f2c0 0111 	movt	r1, #17
  10f6dc:	f240 53d7 	movw	r3, #1495	; 0x5d7
  10f6e0:	f004 f85c 	bl	11379c <_panic>

0010f6e4 <rstgen_is_released>:
        return RST_INVALID;
    }
}
static int rstgen_is_released(struct rstgen *rst)
{
    return rst->release_cnt > rst->hold_cnt;
  10f6e4:	e9d0 200f 	ldrd	r2, r0, [r0, #60]	; 0x3c
}
  10f6e8:	4282      	cmp	r2, r0
  10f6ea:	bfd4      	ite	le
  10f6ec:	2000      	movle	r0, #0
  10f6ee:	2001      	movgt	r0, #1
  10f6f0:	4770      	bx	r14
  10f6f2:	bf00      	nop

0010f6f4 <rstgen_endis>:

static int rstgen_endis(struct rstgen *rst, bool isrelease)
{
  10f6f4:	b570      	push	{r4, r5, r6, r14}
  10f6f6:	460d      	mov	r5, r1
  10f6f8:	b084      	sub	sp, #16
    int ret = 0;
    void *g_handle;
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10f6fa:	f44f 6180 	mov.w	r1, #1024	; 0x400
{
  10f6fe:	4604      	mov	r4, r0
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10f700:	f2c8 1196 	movt	r1, #33174	; 0x8196
  10f704:	4676      	mov	r6, r14
  10f706:	a803      	add	r0, sp, #12
  10f708:	f000 fe80 	bl	11040c <hal_rstgen_creat_handle>

    if (!ret) {
  10f70c:	2800      	cmp	r0, #0
  10f70e:	d03c      	beq.n	10f78a <rstgen_endis+0x96>
        return -1;
    }

    /*get handle ok and enable rstgen is true*/
    ret = hal_rstgen_init(g_handle);
  10f710:	9803      	ldr	r0, [sp, #12]
  10f712:	f000 fef7 	bl	110504 <hal_rstgen_init>

    if (!ret) {
  10f716:	2800      	cmp	r0, #0
  10f718:	d041      	beq.n	10f79e <rstgen_endis+0xaa>
        hal_rstgen_release_handle(g_handle);
        return -1;
    }

    if (rstgen_is_iso(rst)) {
  10f71a:	6823      	ldr	r3, [r4, #0]
            && rst->rstid <= RSTGEN_TYPE_ISO_END);
  10f71c:	f5a3 7288 	sub.w	r2, r3, #272	; 0x110
    if (rstgen_is_iso(rst)) {
  10f720:	2a04      	cmp	r2, #4
  10f722:	d91a      	bls.n	10f75a <rstgen_endis+0x66>
            && rst->rstid <= RSTGEN_TYPE_MODULE_END);
  10f724:	f46f 7191 	mvn.w	r1, #290	; 0x122
  10f728:	185a      	adds	r2, r3, r1
        }
        else {
            ret = hal_rstgen_iso_enable(g_handle, rst->resid);
        }
    }
    else if (rstgen_is_module(rst)) {
  10f72a:	2a5e      	cmp	r2, #94	; 0x5e
  10f72c:	d930      	bls.n	10f790 <rstgen_endis+0x9c>
            && rst->rstid <= RSTGEN_TYPE_CORE_END);
  10f72e:	f46f 728a 	mvn.w	r2, #276	; 0x114
  10f732:	4413      	add	r3, r2
        ret = hal_rstgen_module_ctl(g_handle, rst->resid, isrelease);
    }
    else if (rstgen_is_core(rst)) {
  10f734:	2b0d      	cmp	r3, #13
  10f736:	d836      	bhi.n	10f7a6 <rstgen_endis+0xb2>
        ret = hal_rstgen_core_ctl(g_handle, rst->resid, isrelease);
  10f738:	6861      	ldr	r1, [r4, #4]
  10f73a:	462a      	mov	r2, r5
  10f73c:	9803      	ldr	r0, [sp, #12]
  10f73e:	f000 ff4f 	bl	1105e0 <hal_rstgen_core_ctl>
  10f742:	4606      	mov	r6, r0
    }
    else {
        ASSERT(0);
    }

    hal_rstgen_release_handle(g_handle);
  10f744:	9803      	ldr	r0, [sp, #12]
  10f746:	f000 fed1 	bl	1104ec <hal_rstgen_release_handle>

    if (ret) {
  10f74a:	b1f6      	cbz	r6, 10f78a <rstgen_endis+0x96>
    else {
        ret = -1;
    }

    if (ret == 0) {
        isrelease ? rst->release_cnt++ : rst->hold_cnt++;
  10f74c:	b97d      	cbnz	r5, 10f76e <rstgen_endis+0x7a>
  10f74e:	6c23      	ldr	r3, [r4, #64]	; 0x40
        ret = 0;
  10f750:	2000      	movs	r0, #0
        isrelease ? rst->release_cnt++ : rst->hold_cnt++;
  10f752:	3301      	adds	r3, #1
  10f754:	6423      	str	r3, [r4, #64]	; 0x40
    }

    return ret;
}
  10f756:	b004      	add	sp, #16
  10f758:	bd70      	pop	{r4, r5, r6, r15}
  10f75a:	9803      	ldr	r0, [sp, #12]
  10f75c:	6861      	ldr	r1, [r4, #4]
        if (isrelease) {
  10f75e:	b165      	cbz	r5, 10f77a <rstgen_endis+0x86>
            ret = hal_rstgen_iso_disable(g_handle, rst->resid);
  10f760:	f000 feee 	bl	110540 <hal_rstgen_iso_disable>
  10f764:	4605      	mov	r5, r0
    hal_rstgen_release_handle(g_handle);
  10f766:	9803      	ldr	r0, [sp, #12]
  10f768:	f000 fec0 	bl	1104ec <hal_rstgen_release_handle>
    if (ret) {
  10f76c:	b16d      	cbz	r5, 10f78a <rstgen_endis+0x96>
        isrelease ? rst->release_cnt++ : rst->hold_cnt++;
  10f76e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
        ret = 0;
  10f770:	2000      	movs	r0, #0
        isrelease ? rst->release_cnt++ : rst->hold_cnt++;
  10f772:	3301      	adds	r3, #1
  10f774:	63e3      	str	r3, [r4, #60]	; 0x3c
}
  10f776:	b004      	add	sp, #16
  10f778:	bd70      	pop	{r4, r5, r6, r15}
            ret = hal_rstgen_iso_enable(g_handle, rst->resid);
  10f77a:	f000 fec5 	bl	110508 <hal_rstgen_iso_enable>
  10f77e:	4605      	mov	r5, r0
    hal_rstgen_release_handle(g_handle);
  10f780:	9803      	ldr	r0, [sp, #12]
  10f782:	f000 feb3 	bl	1104ec <hal_rstgen_release_handle>
    if (ret) {
  10f786:	2d00      	cmp	r5, #0
  10f788:	d1e1      	bne.n	10f74e <rstgen_endis+0x5a>
        return -1;
  10f78a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10f78e:	e7e2      	b.n	10f756 <rstgen_endis+0x62>
        ret = hal_rstgen_module_ctl(g_handle, rst->resid, isrelease);
  10f790:	6861      	ldr	r1, [r4, #4]
  10f792:	462a      	mov	r2, r5
  10f794:	9803      	ldr	r0, [sp, #12]
  10f796:	f000 ff5d 	bl	110654 <hal_rstgen_module_ctl>
  10f79a:	4606      	mov	r6, r0
  10f79c:	e7d2      	b.n	10f744 <rstgen_endis+0x50>
        hal_rstgen_release_handle(g_handle);
  10f79e:	9803      	ldr	r0, [sp, #12]
  10f7a0:	f000 fea4 	bl	1104ec <hal_rstgen_release_handle>
  10f7a4:	e7f1      	b.n	10f78a <rstgen_endis+0x96>
        ASSERT(0);
  10f7a6:	f649 0384 	movw	r3, #39044	; 0x9884
  10f7aa:	f24c 7224 	movw	r2, #50980	; 0xc724
  10f7ae:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f7b2:	f2c0 0311 	movt	r3, #17
  10f7b6:	4630      	mov	r0, r6
  10f7b8:	f2c0 0211 	movt	r2, #17
  10f7bc:	9300      	str	r3, [sp, #0]
  10f7be:	f2c0 0111 	movt	r1, #17
  10f7c2:	2379      	movs	r3, #121	; 0x79
  10f7c4:	f003 ffea 	bl	11379c <_panic>

0010f7c8 <rstgen_hold>:
{
    return rstgen_endis(rst, true);
}
static int rstgen_hold(struct rstgen *rst)
{
    return rstgen_endis(rst, false);
  10f7c8:	2100      	movs	r1, #0
  10f7ca:	f7ff bf93 	b.w	10f6f4 <rstgen_endis>
  10f7ce:	bf00      	nop

0010f7d0 <rstgen_release>:
    return rstgen_endis(rst, true);
  10f7d0:	2101      	movs	r1, #1
  10f7d2:	f7ff bf8f 	b.w	10f6f4 <rstgen_endis>
  10f7d6:	bf00      	nop

0010f7d8 <res_rstgen_dec_refcount>:
                                   unsigned long per_id)
{
    int ret = 0;
    bool is_released = true;

    if (per_id != INVALID_PER_ID) {
  10f7d8:	2901      	cmp	r1, #1
{
  10f7da:	b530      	push	{r4, r5, r14}
  10f7dc:	4605      	mov	r5, r0
  10f7de:	b083      	sub	sp, #12
    if (per_id != INVALID_PER_ID) {
  10f7e0:	d12e      	bne.n	10f840 <res_rstgen_dec_refcount+0x68>
  10f7e2:	6a80      	ldr	r0, [r0, #40]	; 0x28
    int count = 0;
  10f7e4:	2100      	movs	r1, #0
            if ((1 << j)&n) {
  10f7e6:	2401      	movs	r4, #1
        for (j = 0; j < 32; j++) {
  10f7e8:	460b      	mov	r3, r1
            if ((1 << j)&n) {
  10f7ea:	fa04 f203 	lsl.w	r2, r4, r3
  10f7ee:	4202      	tst	r2, r0
        for (j = 0; j < 32; j++) {
  10f7f0:	f103 0301 	add.w	r3, r3, #1
                count++;
  10f7f4:	bf18      	it	ne
  10f7f6:	3101      	addne	r1, #1
        for (j = 0; j < 32; j++) {
  10f7f8:	2b20      	cmp	r3, #32
  10f7fa:	d1f6      	bne.n	10f7ea <res_rstgen_dec_refcount+0x12>
        rstgen_clear_refcount_bit(rst, per_id);
    }

    int cnt = rstgen_get_refcount(rst);

    if (cnt == 0) {
  10f7fc:	b111      	cbz	r1, 10f804 <res_rstgen_dec_refcount+0x2c>
            }
        }
    }

    return ret;
}
  10f7fe:	2000      	movs	r0, #0
  10f800:	b003      	add	sp, #12
  10f802:	bd30      	pop	{r4, r5, r15}
        if (rst->polar) {
  10f804:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  10f806:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  10f808:	b16a      	cbz	r2, 10f826 <res_rstgen_dec_refcount+0x4e>
            if (rst->is_released) {
  10f80a:	2b00      	cmp	r3, #0
  10f80c:	d0f7      	beq.n	10f7fe <res_rstgen_dec_refcount+0x26>
                is_released = rst->is_released(rst);
  10f80e:	4628      	mov	r0, r5
  10f810:	4798      	blx	r3
            if (!is_released && rst->release) {
  10f812:	2800      	cmp	r0, #0
  10f814:	d1f3      	bne.n	10f7fe <res_rstgen_dec_refcount+0x26>
  10f816:	6cab      	ldr	r3, [r5, #72]	; 0x48
  10f818:	2b00      	cmp	r3, #0
  10f81a:	d0f0      	beq.n	10f7fe <res_rstgen_dec_refcount+0x26>
                ret = rst->hold(rst);
  10f81c:	4628      	mov	r0, r5
}
  10f81e:	b003      	add	sp, #12
  10f820:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
                ret = rst->hold(rst);
  10f824:	4718      	bx	r3
            if (rst->is_released) {
  10f826:	b11b      	cbz	r3, 10f830 <res_rstgen_dec_refcount+0x58>
                is_released = rst->is_released(rst);
  10f828:	4628      	mov	r0, r5
  10f82a:	4798      	blx	r3
            if (is_released && rst->hold) {
  10f82c:	2800      	cmp	r0, #0
  10f82e:	d0e6      	beq.n	10f7fe <res_rstgen_dec_refcount+0x26>
  10f830:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  10f832:	2b00      	cmp	r3, #0
  10f834:	d0e3      	beq.n	10f7fe <res_rstgen_dec_refcount+0x26>
                ret = rst->hold(rst);
  10f836:	4628      	mov	r0, r5
}
  10f838:	b003      	add	sp, #12
  10f83a:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
                ret = rst->hold(rst);
  10f83e:	4718      	bx	r3
    ASSERT(i < REFCNT_NUM);
  10f840:	291f      	cmp	r1, #31
  10f842:	dc0e      	bgt.n	10f862 <res_rstgen_dec_refcount+0x8a>
    rst->refcount[i] &= ~(1 << (per_id % 32));
  10f844:	2301      	movs	r3, #1
  10f846:	424a      	negs	r2, r1
  10f848:	6a80      	ldr	r0, [r0, #40]	; 0x28
  10f84a:	f002 021f 	and.w	r2, r2, #31
  10f84e:	f001 011f 	and.w	r1, r1, #31
  10f852:	bf58      	it	pl
  10f854:	4251      	negpl	r1, r2
  10f856:	fa03 f101 	lsl.w	r1, r3, r1
  10f85a:	ea20 0001 	bic.w	r0, r0, r1
  10f85e:	62a8      	str	r0, [r5, #40]	; 0x28
  10f860:	e7c0      	b.n	10f7e4 <res_rstgen_dec_refcount+0xc>
    ASSERT(i < REFCNT_NUM);
  10f862:	f24c 6310 	movw	r3, #50704	; 0xc610
  10f866:	f24c 7224 	movw	r2, #50980	; 0xc724
  10f86a:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f86e:	f2c0 0311 	movt	r3, #17
  10f872:	4670      	mov	r0, r14
  10f874:	f2c0 0211 	movt	r2, #17
  10f878:	9300      	str	r3, [sp, #0]
  10f87a:	f2c0 0111 	movt	r1, #17
  10f87e:	23da      	movs	r3, #218	; 0xda
  10f880:	f003 ff8c 	bl	11379c <_panic>

0010f884 <res_rstgen_inc_refcount>:
    if (per_id != INVALID_PER_ID) {
  10f884:	2901      	cmp	r1, #1
{
  10f886:	b530      	push	{r4, r5, r14}
  10f888:	4605      	mov	r5, r0
  10f88a:	b083      	sub	sp, #12
    if (per_id != INVALID_PER_ID) {
  10f88c:	d111      	bne.n	10f8b2 <res_rstgen_inc_refcount+0x2e>
  10f88e:	6a81      	ldr	r1, [r0, #40]	; 0x28
    int count = 0;
  10f890:	2000      	movs	r0, #0
            if ((1 << j)&n) {
  10f892:	2401      	movs	r4, #1
        for (j = 0; j < 32; j++) {
  10f894:	4603      	mov	r3, r0
            if ((1 << j)&n) {
  10f896:	fa04 f203 	lsl.w	r2, r4, r3
  10f89a:	420a      	tst	r2, r1
        for (j = 0; j < 32; j++) {
  10f89c:	f103 0301 	add.w	r3, r3, #1
                count++;
  10f8a0:	bf18      	it	ne
  10f8a2:	3001      	addne	r0, #1
        for (j = 0; j < 32; j++) {
  10f8a4:	2b20      	cmp	r3, #32
  10f8a6:	d1f6      	bne.n	10f896 <res_rstgen_inc_refcount+0x12>
    if (cnt == 1) {
  10f8a8:	2801      	cmp	r0, #1
  10f8aa:	d012      	beq.n	10f8d2 <res_rstgen_inc_refcount+0x4e>
}
  10f8ac:	2000      	movs	r0, #0
  10f8ae:	b003      	add	sp, #12
  10f8b0:	bd30      	pop	{r4, r5, r15}
    ASSERT(i < REFCNT_NUM);
  10f8b2:	291f      	cmp	r1, #31
  10f8b4:	dc27      	bgt.n	10f906 <res_rstgen_inc_refcount+0x82>
    rst->refcount[i] |= 1 << (per_id % 32);
  10f8b6:	424a      	negs	r2, r1
  10f8b8:	f001 031f 	and.w	r3, r1, #31
  10f8bc:	f04f 0101 	mov.w	r1, #1
  10f8c0:	f002 021f 	and.w	r2, r2, #31
  10f8c4:	bf58      	it	pl
  10f8c6:	4253      	negpl	r3, r2
  10f8c8:	6a82      	ldr	r2, [r0, #40]	; 0x28
  10f8ca:	4099      	lsls	r1, r3
  10f8cc:	4311      	orrs	r1, r2
  10f8ce:	6281      	str	r1, [r0, #40]	; 0x28
  10f8d0:	e7de      	b.n	10f890 <res_rstgen_inc_refcount+0xc>
        if (rst->polar) {
  10f8d2:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  10f8d4:	6c6b      	ldr	r3, [r5, #68]	; 0x44
  10f8d6:	b962      	cbnz	r2, 10f8f2 <res_rstgen_inc_refcount+0x6e>
            if (rst->is_released) {
  10f8d8:	b11b      	cbz	r3, 10f8e2 <res_rstgen_inc_refcount+0x5e>
                is_released = rst->is_released(rst);
  10f8da:	4628      	mov	r0, r5
  10f8dc:	4798      	blx	r3
            if (!is_released && rst->release) {
  10f8de:	2800      	cmp	r0, #0
  10f8e0:	d1e4      	bne.n	10f8ac <res_rstgen_inc_refcount+0x28>
  10f8e2:	6cab      	ldr	r3, [r5, #72]	; 0x48
  10f8e4:	2b00      	cmp	r3, #0
  10f8e6:	d0e1      	beq.n	10f8ac <res_rstgen_inc_refcount+0x28>
                ret |= rst->release(rst);
  10f8e8:	4628      	mov	r0, r5
}
  10f8ea:	b003      	add	sp, #12
  10f8ec:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
                ret |= rst->release(rst);
  10f8f0:	4718      	bx	r3
            if (rst->is_released) {
  10f8f2:	2b00      	cmp	r3, #0
  10f8f4:	d0da      	beq.n	10f8ac <res_rstgen_inc_refcount+0x28>
                is_released = rst->is_released(rst);
  10f8f6:	4628      	mov	r0, r5
  10f8f8:	4798      	blx	r3
            if (is_released && rst->hold) {
  10f8fa:	2800      	cmp	r0, #0
  10f8fc:	d0d6      	beq.n	10f8ac <res_rstgen_inc_refcount+0x28>
  10f8fe:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
  10f900:	2b00      	cmp	r3, #0
  10f902:	d1f1      	bne.n	10f8e8 <res_rstgen_inc_refcount+0x64>
  10f904:	e7d2      	b.n	10f8ac <res_rstgen_inc_refcount+0x28>
    ASSERT(i < REFCNT_NUM);
  10f906:	f24c 6310 	movw	r3, #50704	; 0xc610
  10f90a:	f24c 7224 	movw	r2, #50980	; 0xc724
  10f90e:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f912:	f2c0 0311 	movt	r3, #17
  10f916:	4670      	mov	r0, r14
  10f918:	f2c0 0211 	movt	r2, #17
  10f91c:	9300      	str	r3, [sp, #0]
  10f91e:	f2c0 0111 	movt	r1, #17
  10f922:	23d2      	movs	r3, #210	; 0xd2
  10f924:	f003 ff3a 	bl	11379c <_panic>

0010f928 <res_rstgen_request>:

int res_rstgen_request(unsigned long per_id, unsigned long rstid,
                       unsigned long param)
{
  10f928:	b530      	push	{r4, r5, r14}
    return (list->next == list) ? true : false;
  10f92a:	f64a 1514 	movw	r5, #43284	; 0xa914
  10f92e:	b083      	sub	sp, #12
  10f930:	f2c0 0512 	movt	r5, #18
  10f934:	686b      	ldr	r3, [r5, #4]
    if (list_is_empty(list)) {
  10f936:	42ab      	cmp	r3, r5
  10f938:	d024      	beq.n	10f984 <res_rstgen_request+0x5c>
    list_for_every_entry(list, rst, struct rstgen, node) {
  10f93a:	429d      	cmp	r5, r3
  10f93c:	f1a3 042c 	sub.w	r4, r3, #44	; 0x2c
  10f940:	d105      	bne.n	10f94e <res_rstgen_request+0x26>
  10f942:	e01f      	b.n	10f984 <res_rstgen_request+0x5c>
  10f944:	6b23      	ldr	r3, [r4, #48]	; 0x30
  10f946:	429d      	cmp	r5, r3
  10f948:	f1a3 042c 	sub.w	r4, r3, #44	; 0x2c
  10f94c:	d01a      	beq.n	10f984 <res_rstgen_request+0x5c>
        if (rst->rstid ==
  10f94e:	f853 3c2c 	ldr.w	r3, [r3, #-44]
  10f952:	4299      	cmp	r1, r3
  10f954:	d1f6      	bne.n	10f944 <res_rstgen_request+0x1c>
        return -1;
    }

    enum rstgen_param p = param;

    if (rst->polar) {
  10f956:	6b63      	ldr	r3, [r4, #52]	; 0x34
  10f958:	b14b      	cbz	r3, 10f96e <res_rstgen_request+0x46>
        if (p == RST_HOLD) {
  10f95a:	b162      	cbz	r2, 10f976 <res_rstgen_request+0x4e>
            return res_rstgen_inc_refcount(rst, per_id);
        }
        else if (p == RST_RELEASE) {
  10f95c:	2a01      	cmp	r2, #1
  10f95e:	d11b      	bne.n	10f998 <res_rstgen_request+0x70>
            return res_rstgen_dec_refcount(rst, per_id);
        }
    }
    else {
        if (p == RST_HOLD) {
            return res_rstgen_dec_refcount(rst, per_id);
  10f960:	4601      	mov	r1, r0
  10f962:	4620      	mov	r0, r4
        }
    }

    ASSERT(0);
    return 0;
}
  10f964:	b003      	add	sp, #12
  10f966:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
            return res_rstgen_dec_refcount(rst, per_id);
  10f96a:	f7ff bf35 	b.w	10f7d8 <res_rstgen_dec_refcount>
        if (p == RST_HOLD) {
  10f96e:	2a00      	cmp	r2, #0
  10f970:	d0f6      	beq.n	10f960 <res_rstgen_request+0x38>
        else if (p == RST_RELEASE) {
  10f972:	2a01      	cmp	r2, #1
  10f974:	d110      	bne.n	10f998 <res_rstgen_request+0x70>
            return res_rstgen_inc_refcount(rst, per_id);
  10f976:	4601      	mov	r1, r0
  10f978:	4620      	mov	r0, r4
}
  10f97a:	b003      	add	sp, #12
  10f97c:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
            return res_rstgen_inc_refcount(rst, per_id);
  10f980:	f7ff bf80 	b.w	10f884 <res_rstgen_inc_refcount>
        dprintf(CRITICAL, "no such rst %ld\n", rstid);
  10f984:	f24c 7010 	movw	r0, #50960	; 0xc710
  10f988:	f2c0 0011 	movt	r0, #17
  10f98c:	f004 ff3a 	bl	114804 <printf>
}
  10f990:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10f994:	b003      	add	sp, #12
  10f996:	bd30      	pop	{r4, r5, r15}
    ASSERT(0);
  10f998:	f649 0384 	movw	r3, #39044	; 0x9884
  10f99c:	f24c 7224 	movw	r2, #50980	; 0xc724
  10f9a0:	f647 4134 	movw	r1, #31796	; 0x7c34
  10f9a4:	f2c0 0311 	movt	r3, #17
  10f9a8:	4670      	mov	r0, r14
  10f9aa:	f2c0 0211 	movt	r2, #17
  10f9ae:	9300      	str	r3, [sp, #0]
  10f9b0:	f2c0 0111 	movt	r1, #17
  10f9b4:	f240 135b 	movw	r3, #347	; 0x15b
  10f9b8:	f003 fef0 	bl	11379c <_panic>

0010f9bc <register_res_rstgens>:

    return true;
}

void register_res_rstgens(void)
{
  10f9bc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    list->prev = list->next = list;
  10f9c0:	f64a 1614 	movw	r6, #43284	; 0xa914
  10f9c4:	f64a 141c 	movw	r4, #43292	; 0xa91c

        list_clear_node(&rst->node);
        //list_initialize(&rst->child);
        //init refcount
        rstgen_init_refcount_bitmap(rst);
        rst->is_released = rstgen_is_released;
  10f9c8:	f24f 69e5 	movw	r9, #63205	; 0xf6e5
  10f9cc:	f2c0 0612 	movt	r6, #18
        rst->release = rstgen_release;
  10f9d0:	f24f 78d1 	movw	r8, #63441	; 0xf7d1
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10f9d4:	f44f 6a80 	mov.w	r10, #1024	; 0x400
  10f9d8:	4f3a      	ldr	r7, [pc, #232]	; (10fac4 <register_res_rstgens+0x108>)
{
  10f9da:	b083      	sub	sp, #12
  10f9dc:	f2c0 0412 	movt	r4, #18
        rst->is_released = rstgen_is_released;
  10f9e0:	f2c0 0910 	movt	r9, #16
        rst->release = rstgen_release;
  10f9e4:	f2c0 0810 	movt	r8, #16
  10f9e8:	e9c6 6600 	strd	r6, r6, [r6]
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10f9ec:	f2c8 1a96 	movt	r10, #33174	; 0x8196
  10f9f0:	e00e      	b.n	10fa10 <register_res_rstgens+0x54>
            && rst->rstid <= RSTGEN_TYPE_CORE_END);
  10f9f2:	f46f 718a 	mvn.w	r1, #276	; 0x114
  10f9f6:	185a      	adds	r2, r3, r1
    else if (rstgen_is_core(rst)) {
  10f9f8:	2a0d      	cmp	r2, #13
  10f9fa:	d94c      	bls.n	10fa96 <register_res_rstgens+0xda>
            && rst->rstid <= RSTGEN_TYPE_MODULE_END);
  10f9fc:	f46f 7291 	mvn.w	r2, #290	; 0x122
  10fa00:	4413      	add	r3, r2
    else if (rstgen_is_module(rst)) {
  10fa02:	2b5e      	cmp	r3, #94	; 0x5e
  10fa04:	d958      	bls.n	10fab8 <register_res_rstgens+0xfc>
    hal_rstgen_release_handle(g_handle);
  10fa06:	f000 fd71 	bl	1104ec <hal_rstgen_release_handle>
  10fa0a:	3450      	adds	r4, #80	; 0x50
    for (i = 0; i < num; i++) {
  10fa0c:	42a7      	cmp	r7, r4
  10fa0e:	d03b      	beq.n	10fa88 <register_res_rstgens+0xcc>
    int32_t slice_idx = -1;
  10fa10:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    ret = res_get_info_by_id(resid, &phy_addr, &slice_idx);
  10fa14:	aa01      	add	r2, sp, #4
        if (!is_res_belong_this_domain(rst->resid)) {
  10fa16:	6860      	ldr	r0, [r4, #4]
    ret = res_get_info_by_id(resid, &phy_addr, &slice_idx);
  10fa18:	4669      	mov	r1, r13
    int32_t slice_idx = -1;
  10fa1a:	9301      	str	r3, [sp, #4]
    ret = res_get_info_by_id(resid, &phy_addr, &slice_idx);
  10fa1c:	f000 fc8a 	bl	110334 <res_get_info_by_id>
    if (ret == -1) {
  10fa20:	3001      	adds	r0, #1
  10fa22:	d0f2      	beq.n	10fa0a <register_res_rstgens+0x4e>
        rst->hold = rstgen_hold;
  10fa24:	f24f 72c9 	movw	r2, #63433	; 0xf7c9
    item->prev = item->next = 0;
  10fa28:	2300      	movs	r3, #0
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10fa2a:	4651      	mov	r1, r10
        rst->hold = rstgen_hold;
  10fa2c:	f2c0 0210 	movt	r2, #16
        rst->is_released = rstgen_is_released;
  10fa30:	f8c4 9044 	str.w	r9, [r4, #68]	; 0x44
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10fa34:	a801      	add	r0, sp, #4
        rst->hold = rstgen_hold;
  10fa36:	e9c4 8212 	strd	r8, r2, [r4, #72]	; 0x48
  10fa3a:	f104 052c 	add.w	r5, r4, #44	; 0x2c
  10fa3e:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
        rst->refcount[i] = 0;
  10fa42:	62a3      	str	r3, [r4, #40]	; 0x28
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
  10fa44:	f000 fce2 	bl	11040c <hal_rstgen_creat_handle>
    if (!ret) {
  10fa48:	2800      	cmp	r0, #0
  10fa4a:	d0de      	beq.n	10fa0a <register_res_rstgens+0x4e>
    ret = hal_rstgen_init(g_handle);
  10fa4c:	9801      	ldr	r0, [sp, #4]
  10fa4e:	f000 fd59 	bl	110504 <hal_rstgen_init>
    if (!ret) {
  10fa52:	b1e0      	cbz	r0, 10fa8e <register_res_rstgens+0xd2>
    if (rstgen_is_iso(rst)) {
  10fa54:	6823      	ldr	r3, [r4, #0]
  10fa56:	9801      	ldr	r0, [sp, #4]
            && rst->rstid <= RSTGEN_TYPE_ISO_END);
  10fa58:	f5a3 7288 	sub.w	r2, r3, #272	; 0x110
    if (rstgen_is_iso(rst)) {
  10fa5c:	2a04      	cmp	r2, #4
  10fa5e:	d8c8      	bhi.n	10f9f2 <register_res_rstgens+0x36>
        ret = hal_rstgen_iso_status(g_handle, rst->resid);
  10fa60:	6861      	ldr	r1, [r4, #4]
  10fa62:	f000 fd89 	bl	110578 <hal_rstgen_iso_status>
  10fa66:	4683      	mov	r11, r0
    hal_rstgen_release_handle(g_handle);
  10fa68:	9801      	ldr	r0, [sp, #4]
  10fa6a:	f000 fd3f 	bl	1104ec <hal_rstgen_release_handle>
    if (ret == 0) {
  10fa6e:	f1bb 0f00 	cmp.w	r11, #0
  10fa72:	d11a      	bne.n	10faaa <register_res_rstgens+0xee>

        if (rst_status == RST_RELEASE) {
            rst->release_cnt = 1;
        }
        else if (rst_status == RST_HOLD) {
            rst->hold_cnt = 1;
  10fa74:	2301      	movs	r3, #1
  10fa76:	6423      	str	r3, [r4, #64]	; 0x40
    item->prev = list->prev;
  10fa78:	6833      	ldr	r3, [r6, #0]
  10fa7a:	e9c4 360b 	strd	r3, r6, [r4, #44]	; 0x2c
  10fa7e:	3450      	adds	r4, #80	; 0x50
    list->prev = item;
  10fa80:	6035      	str	r5, [r6, #0]
    for (i = 0; i < num; i++) {
  10fa82:	42a7      	cmp	r7, r4
    list->prev->next = item;
  10fa84:	605d      	str	r5, [r3, #4]
  10fa86:	d1c3      	bne.n	10fa10 <register_res_rstgens+0x54>
            continue;
        }

        list_add_tail(&g_rstgen_root, &rst->node);
    }
}
  10fa88:	b003      	add	sp, #12
  10fa8a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        hal_rstgen_release_handle(g_handle);
  10fa8e:	9801      	ldr	r0, [sp, #4]
  10fa90:	f000 fd2c 	bl	1104ec <hal_rstgen_release_handle>
  10fa94:	e7b9      	b.n	10fa0a <register_res_rstgens+0x4e>
        ret = hal_rstgen_core_status(g_handle, rst->resid);
  10fa96:	6861      	ldr	r1, [r4, #4]
  10fa98:	f000 fe0e 	bl	1106b8 <hal_rstgen_core_status>
  10fa9c:	4683      	mov	r11, r0
    hal_rstgen_release_handle(g_handle);
  10fa9e:	9801      	ldr	r0, [sp, #4]
  10faa0:	f000 fd24 	bl	1104ec <hal_rstgen_release_handle>
    if (ret == 0) {
  10faa4:	f1bb 0f00 	cmp.w	r11, #0
  10faa8:	d0e4      	beq.n	10fa74 <register_res_rstgens+0xb8>
    else if (ret == 1) {
  10faaa:	f1bb 0f01 	cmp.w	r11, #1
            rst->release_cnt = 1;
  10faae:	bf08      	it	eq
  10fab0:	f8c4 b03c 	streq.w	r11, [r4, #60]	; 0x3c
    else if (ret == 1) {
  10fab4:	d0e0      	beq.n	10fa78 <register_res_rstgens+0xbc>
  10fab6:	e7a8      	b.n	10fa0a <register_res_rstgens+0x4e>
        ret = hal_rstgen_module_status(g_handle, rst->resid);
  10fab8:	6861      	ldr	r1, [r4, #4]
  10faba:	f000 fde5 	bl	110688 <hal_rstgen_module_status>
  10fabe:	4683      	mov	r11, r0
  10fac0:	e7d2      	b.n	10fa68 <register_res_rstgens+0xac>
  10fac2:	bf00      	nop
  10fac4:	0012c6cc 	.word	0x0012c6cc

0010fac8 <hal_pll_create_handle>:

    return config;
}

pll_handle_t hal_pll_create_handle(uint32_t resid)
{
  10fac8:	b510      	push	{r4, r14}
  10faca:	4604      	mov	r4, r0
  10facc:	b082      	sub	sp, #8
    addr_t      pll_addr;
    int32_t     index;
    pll_e       pll;

    if (!res_get_info_by_id(resid, &pll_addr, &index) &&
  10face:	4669      	mov	r1, r13
  10fad0:	aa01      	add	r2, sp, #4
  10fad2:	f000 fc2f 	bl	110334 <res_get_info_by_id>
  10fad6:	b998      	cbnz	r0, 10fb00 <hal_pll_create_handle+0x38>
  10fad8:	f24c 7350 	movw	r3, #51024	; 0xc750
  10fadc:	f241 0225 	movw	r2, #4133	; 0x1025
  10fae0:	f2c0 0311 	movt	r3, #17
  10fae4:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  10fae8:	f2c4 022e 	movt	r2, #16430	; 0x402e
  10faec:	e003      	b.n	10faf6 <hal_pll_create_handle+0x2e>
    for (pll_e i = 0; i < PLL_MAX; i++) {
  10faee:	428b      	cmp	r3, r1
  10faf0:	d006      	beq.n	10fb00 <hal_pll_create_handle+0x38>
  10faf2:	f853 2f08 	ldr.w	r2, [r3, #8]!
        if (g_pll_res[i].resid == resid) {
  10faf6:	4294      	cmp	r4, r2
  10faf8:	d1f9      	bne.n	10faee <hal_pll_create_handle+0x26>
  10fafa:	4620      	mov	r0, r4
    }
    else {
        //LTRACEF("Can not create pll handle, resid 0x%x\n", resid);
        return (pll_handle_t)0;
    }
}
  10fafc:	b002      	add	sp, #8
  10fafe:	bd10      	pop	{r4, r15}
        return (pll_handle_t)0;
  10fb00:	2000      	movs	r0, #0
}
  10fb02:	b002      	add	sp, #8
  10fb04:	bd10      	pop	{r4, r15}
  10fb06:	bf00      	nop

0010fb08 <hal_pll_delete_handle>:

void hal_pll_delete_handle(pll_handle_t handle)
{
    return;
}
  10fb08:	4770      	bx	r14
  10fb0a:	bf00      	nop

0010fb0c <hal_pll_config>:

void hal_pll_config(pll_handle_t handle, const pll_config_t *config)
{
  10fb0c:	b530      	push	{r4, r5, r14}
  10fb0e:	460d      	mov	r5, r1
  10fb10:	b083      	sub	sp, #12
    uint32_t            resid = (uint32_t)handle;
    pll_e               pll;
    addr_t              pll_addr;
    int32_t             index;

    if (res_get_info_by_id(resid, &pll_addr, &index) != 0 ||
  10fb12:	4669      	mov	r1, r13
  10fb14:	aa01      	add	r2, sp, #4
{
  10fb16:	4604      	mov	r4, r0
    if (res_get_info_by_id(resid, &pll_addr, &index) != 0 ||
  10fb18:	f000 fc0c 	bl	110334 <res_get_info_by_id>
  10fb1c:	b9f8      	cbnz	r0, 10fb5e <hal_pll_config+0x52>
  10fb1e:	f241 0325 	movw	r3, #4133	; 0x1025
  10fb22:	f24c 7250 	movw	r2, #51024	; 0xc750
    for (pll_e i = 0; i < PLL_MAX; i++) {
  10fb26:	4601      	mov	r1, r0
  10fb28:	f2c4 032e 	movt	r3, #16430	; 0x402e
  10fb2c:	f2c0 0211 	movt	r2, #17
  10fb30:	e004      	b.n	10fb3c <hal_pll_config+0x30>
  10fb32:	3101      	adds	r1, #1
  10fb34:	2916      	cmp	r1, #22
  10fb36:	d012      	beq.n	10fb5e <hal_pll_config+0x52>
  10fb38:	f852 3031 	ldr.w	r3, [r2, r1, lsl #3]
        if (g_pll_res[i].resid == resid) {
  10fb3c:	429c      	cmp	r4, r3
  10fb3e:	d1f8      	bne.n	10fb32 <hal_pll_config+0x26>
            (pll = res2pll(resid)) == PLL_INVALID) {
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
        return;
    }

    if (!config) {
  10fb40:	b1c5      	cbz	r5, 10fb74 <hal_pll_config+0x68>
            return;
        }
    }

    /* Override PLL address if necessary. */
    if (g_pll_res[pll].paddr) {
  10fb42:	f24c 7050 	movw	r0, #51024	; 0xc750
  10fb46:	f2c0 0011 	movt	r0, #17
  10fb4a:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
  10fb4e:	6848      	ldr	r0, [r1, #4]
  10fb50:	b170      	cbz	r0, 10fb70 <hal_pll_config+0x64>
        pll_addr = g_pll_res[pll].paddr;
  10fb52:	9000      	str	r0, [sp, #0]
    }

    LTRACEF("pll_init pll %d, addr 0x%x\n", pll, (uint32_t)pll_addr);
    pll_config(pll_addr, config);
  10fb54:	4629      	mov	r1, r5
  10fb56:	f7f8 f96d 	bl	107e34 <pll_config>
}
  10fb5a:	b003      	add	sp, #12
  10fb5c:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
  10fb5e:	f64c 0000 	movw	r0, #51200	; 0xc800
  10fb62:	4621      	mov	r1, r4
  10fb64:	f2c0 0011 	movt	r0, #17
  10fb68:	f004 fe4c 	bl	114804 <printf>
}
  10fb6c:	b003      	add	sp, #12
  10fb6e:	bd30      	pop	{r4, r5, r15}
  10fb70:	9800      	ldr	r0, [sp, #0]
  10fb72:	e7ef      	b.n	10fb54 <hal_pll_config+0x48>
  10fb74:	f64c 0034 	movw	r0, #51252	; 0xc834
    if (!config) {
  10fb78:	462b      	mov	r3, r5
  10fb7a:	f2c0 0011 	movt	r0, #17
  10fb7e:	4602      	mov	r2, r0
  10fb80:	e004      	b.n	10fb8c <hal_pll_config+0x80>
    for (size_t i = 0; i < sizeof(pll_configs) / sizeof(pll_configs[0]); i++) {
  10fb82:	3501      	adds	r5, #1
  10fb84:	2d17      	cmp	r5, #23
  10fb86:	d008      	beq.n	10fb9a <hal_pll_config+0x8e>
  10fb88:	f852 3f30 	ldr.w	r3, [r2, #48]!
        if (pll_configs[i].pll == pll) {
  10fb8c:	428b      	cmp	r3, r1
  10fb8e:	d1f8      	bne.n	10fb82 <hal_pll_config+0x76>
            config = &pll_configs[i];
  10fb90:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  10fb94:	eb00 1505 	add.w	r5, r0, r5, lsl #4
  10fb98:	e7d3      	b.n	10fb42 <hal_pll_config+0x36>
            dprintf(CRITICAL, "no config for pll %d\n", pll);
  10fb9a:	f64c 001c 	movw	r0, #51228	; 0xc81c
  10fb9e:	f2c0 0011 	movt	r0, #17
  10fba2:	f004 fe2f 	bl	114804 <printf>
            return;
  10fba6:	e7e1      	b.n	10fb6c <hal_pll_config+0x60>

0010fba8 <hal_pll_get_config>:
    uint32_t            resid = (uint32_t)handle;
    pll_e               pll;
    addr_t              pll_addr;
    int32_t             index;

    if (!config) { return -1; }
  10fba8:	b3a9      	cbz	r1, 10fc16 <hal_pll_get_config+0x6e>
{
  10fbaa:	b570      	push	{r4, r5, r6, r14}
  10fbac:	460e      	mov	r6, r1
  10fbae:	b082      	sub	sp, #8

    if (res_get_info_by_id(resid, &pll_addr, &index) != 0 ||
  10fbb0:	4669      	mov	r1, r13
  10fbb2:	aa01      	add	r2, sp, #4
  10fbb4:	4604      	mov	r4, r0
  10fbb6:	f000 fbbd 	bl	110334 <res_get_info_by_id>
  10fbba:	bb00      	cbnz	r0, 10fbfe <hal_pll_get_config+0x56>
  10fbbc:	f241 0225 	movw	r2, #4133	; 0x1025
  10fbc0:	f24c 7550 	movw	r5, #51024	; 0xc750
    for (pll_e i = 0; i < PLL_MAX; i++) {
  10fbc4:	4603      	mov	r3, r0
  10fbc6:	f2c4 022e 	movt	r2, #16430	; 0x402e
  10fbca:	f2c0 0511 	movt	r5, #17
  10fbce:	e004      	b.n	10fbda <hal_pll_get_config+0x32>
  10fbd0:	3301      	adds	r3, #1
  10fbd2:	2b16      	cmp	r3, #22
  10fbd4:	d013      	beq.n	10fbfe <hal_pll_get_config+0x56>
  10fbd6:	f855 2033 	ldr.w	r2, [r5, r3, lsl #3]
        if (g_pll_res[i].resid == resid) {
  10fbda:	4294      	cmp	r4, r2
  10fbdc:	d1f8      	bne.n	10fbd0 <hal_pll_get_config+0x28>
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
        return 0;
    }

    /* Override PLL address if necessary. */
    if (g_pll_res[pll].paddr) {
  10fbde:	f24c 7250 	movw	r2, #51024	; 0xc750
  10fbe2:	f2c0 0211 	movt	r2, #17
  10fbe6:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  10fbea:	6850      	ldr	r0, [r2, #4]
  10fbec:	b988      	cbnz	r0, 10fc12 <hal_pll_get_config+0x6a>
  10fbee:	9800      	ldr	r0, [sp, #0]
        pll_addr = g_pll_res[pll].paddr;
    }

    config->pll = pll;
  10fbf0:	6033      	str	r3, [r6, #0]
    pll_config_get(pll_addr, config);
  10fbf2:	4631      	mov	r1, r6
  10fbf4:	f7f8 fa9c 	bl	108130 <pll_config_get>
    return 0;
  10fbf8:	2000      	movs	r0, #0
}
  10fbfa:	b002      	add	sp, #8
  10fbfc:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
  10fbfe:	f64c 0000 	movw	r0, #51200	; 0xc800
  10fc02:	4621      	mov	r1, r4
  10fc04:	f2c0 0011 	movt	r0, #17
  10fc08:	f004 fdfc 	bl	114804 <printf>
        return 0;
  10fc0c:	2000      	movs	r0, #0
}
  10fc0e:	b002      	add	sp, #8
  10fc10:	bd70      	pop	{r4, r5, r6, r15}
        pll_addr = g_pll_res[pll].paddr;
  10fc12:	9000      	str	r0, [sp, #0]
  10fc14:	e7ec      	b.n	10fbf0 <hal_pll_get_config+0x48>
    if (!config) { return -1; }
  10fc16:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10fc1a:	4770      	bx	r14

0010fc1c <hal_pmu_drv_ops_init>:
pmudev_t dev = {
	.name = "pmu",
};

void hal_pmu_drv_ops_init(void)
{
  10fc1c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
	memset(&drv_ops, 0, sizeof(pmu_drv_ops_t));
  10fc1e:	f240 1484 	movw	r4, #388	; 0x184
  10fc22:	22c4      	movs	r2, #196	; 0xc4
  10fc24:	2100      	movs	r1, #0
  10fc26:	f2c0 0413 	movt	r4, #19

	/* global ops */
	drv_ops.global.init = pmu_init;
  10fc2a:	f248 2675 	movw	r6, #33397	; 0x8275
	memset(&drv_ops, 0, sizeof(pmu_drv_ops_t));
  10fc2e:	f104 0018 	add.w	r0, r4, #24
  10fc32:	f003 eebc 	blx	1139ac <memset>
	drv_ops.global.exit = pmu_exit;
  10fc36:	f248 25c1 	movw	r5, #33473	; 0x82c1
	drv_ops.global.get_status = pmu_get_status;
  10fc3a:	f248 3009 	movw	r0, #33545	; 0x8309
	drv_ops.global.get_event_source = pmu_get_event_source;
  10fc3e:	f248 3191 	movw	r1, #33681	; 0x8391
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  10fc42:	f248 32d9 	movw	r2, #33753	; 0x83d9
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  10fc46:	f248 4319 	movw	r3, #33817	; 0x8419
	drv_ops.global.init = pmu_init;
  10fc4a:	f2c0 0610 	movt	r6, #16
	drv_ops.global.exit = pmu_exit;
  10fc4e:	f2c0 0510 	movt	r5, #16
	drv_ops.global.get_status = pmu_get_status;
  10fc52:	f2c0 0010 	movt	r0, #16
	drv_ops.global.get_event_source = pmu_get_event_source;
  10fc56:	f2c0 0110 	movt	r1, #16
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  10fc5a:	f2c0 0210 	movt	r2, #16
	drv_ops.global.init = pmu_init;
  10fc5e:	6026      	str	r6, [r4, #0]
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  10fc60:	f2c0 0310 	movt	r3, #16
	drv_ops.global.exit = pmu_exit;
  10fc64:	6065      	str	r5, [r4, #4]

	/* pwr_on*/
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  10fc66:	f248 47e5 	movw	r7, #34021	; 0x84e5
	drv_ops.global.get_status = pmu_get_status;
  10fc6a:	60a0      	str	r0, [r4, #8]
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  10fc6c:	f248 46a1 	movw	r6, #33953	; 0x84a1
	drv_ops.global.get_event_source = pmu_get_event_source;
  10fc70:	60e1      	str	r1, [r4, #12]
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  10fc72:	f248 4551 	movw	r5, #33873	; 0x8451
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  10fc76:	6122      	str	r2, [r4, #16]

	/*pwr_ctrl*/
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  10fc78:	f248 5099 	movw	r0, #34201	; 0x8599
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  10fc7c:	6163      	str	r3, [r4, #20]
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  10fc7e:	f248 5125 	movw	r1, #34085	; 0x8525
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  10fc82:	f248 6209 	movw	r2, #34313	; 0x8609
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  10fc86:	f248 6381 	movw	r3, #34433	; 0x8681
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  10fc8a:	f2c0 0710 	movt	r7, #16
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  10fc8e:	f2c0 0610 	movt	r6, #16
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  10fc92:	f2c0 0510 	movt	r5, #16
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  10fc96:	f2c0 0010 	movt	r0, #16
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  10fc9a:	f2c0 0110 	movt	r1, #16
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  10fc9e:	f2c0 0210 	movt	r2, #16
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  10fca2:	6267      	str	r7, [r4, #36]	; 0x24
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  10fca4:	f2c0 0310 	movt	r3, #16
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  10fca8:	6226      	str	r6, [r4, #32]
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  10fcaa:	f248 67fd 	movw	r7, #34557	; 0x86fd
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  10fcae:	61e5      	str	r5, [r4, #28]
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  10fcb0:	f248 7675 	movw	r6, #34677	; 0x8775
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  10fcb4:	6460      	str	r0, [r4, #68]	; 0x44

	/*por*/
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  10fcb6:	f648 5561 	movw	r5, #36193	; 0x8d61
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  10fcba:	6421      	str	r1, [r4, #64]	; 0x40
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  10fcbc:	f648 50a5 	movw	r0, #36261	; 0x8da5
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  10fcc0:	64a2      	str	r2, [r4, #72]	; 0x48
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  10fcc2:	f648 51e9 	movw	r1, #36329	; 0x8de9
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  10fcc6:	64e3      	str	r3, [r4, #76]	; 0x4c

	/*internal powerdown*/
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  10fcc8:	f248 72f5 	movw	r2, #34805	; 0x87f5
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  10fccc:	f648 0349 	movw	r3, #34889	; 0x8849
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  10fcd0:	f2c0 0710 	movt	r7, #16
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  10fcd4:	f2c0 0610 	movt	r6, #16
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  10fcd8:	f2c0 0510 	movt	r5, #16
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  10fcdc:	f2c0 0010 	movt	r0, #16
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  10fce0:	f2c0 0110 	movt	r1, #16
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  10fce4:	f2c0 0210 	movt	r2, #16
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  10fce8:	6527      	str	r7, [r4, #80]	; 0x50
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  10fcea:	f2c0 0310 	movt	r3, #16
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  10fcee:	6566      	str	r6, [r4, #84]	; 0x54
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  10fcf0:	f648 07a1 	movw	r7, #34977	; 0x88a1
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  10fcf4:	6625      	str	r5, [r4, #96]	; 0x60

	/*external reset*/
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  10fcf6:	f648 1601 	movw	r6, #35073	; 0x8901
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  10fcfa:	65a0      	str	r0, [r4, #88]	; 0x58
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  10fcfc:	f648 1555 	movw	r5, #35157	; 0x8955
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  10fd00:	65e1      	str	r1, [r4, #92]	; 0x5c
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  10fd02:	f648 10ad 	movw	r0, #35245	; 0x89ad
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  10fd06:	67a2      	str	r2, [r4, #120]	; 0x78
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  10fd08:	f648 2105 	movw	r1, #35333	; 0x8a05
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  10fd0c:	67e3      	str	r3, [r4, #124]	; 0x7c
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  10fd0e:	f648 225d 	movw	r2, #35421	; 0x8a5d

	/*internal wakeup*/
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  10fd12:	f648 23bd 	movw	r3, #35517	; 0x8abd
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  10fd16:	f2c0 0710 	movt	r7, #16
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  10fd1a:	f2c0 0610 	movt	r6, #16
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  10fd1e:	f2c0 0510 	movt	r5, #16
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  10fd22:	f2c0 0010 	movt	r0, #16
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  10fd26:	f2c0 0110 	movt	r1, #16
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  10fd2a:	f2c0 0210 	movt	r2, #16
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  10fd2e:	f8c4 7088 	str.w	r7, [r4, #136]	; 0x88
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  10fd32:	f2c0 0310 	movt	r3, #16
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  10fd36:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c

	/*external wakeup*/
	drv_ops.external_wakeup.set_enable = pmu_set_external_wakeup_enable;
  10fd3a:	f648 370d 	movw	r7, #35597	; 0x8b0d
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  10fd3e:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  10fd42:	f648 3665 	movw	r6, #35685	; 0x8b65
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  10fd46:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
	drv_ops.external_wakeup.set_debounce_enable = pmu_set_external_wakeup_debounce_enable;
  10fd4a:	f648 35bd 	movw	r5, #35773	; 0x8bbd
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  10fd4e:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  10fd52:	f648 4015 	movw	r0, #35861	; 0x8c15
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  10fd56:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  10fd5a:	f648 416d 	movw	r1, #35949	; 0x8c6d
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  10fd5e:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

	/*glitch filter*/
	drv_ops.glitch_filter.set_debounce_enable = pmu_set_glitch_filter_enable;
  10fd62:	f648 5211 	movw	r2, #36113	; 0x8d11
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  10fd66:	f648 43cd 	movw	r3, #36045	; 0x8ccd
	drv_ops.external_wakeup.set_enable = pmu_set_external_wakeup_enable;
  10fd6a:	f2c0 0710 	movt	r7, #16
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  10fd6e:	f2c0 0610 	movt	r6, #16
	drv_ops.external_wakeup.set_debounce_enable = pmu_set_external_wakeup_debounce_enable;
  10fd72:	f2c0 0510 	movt	r5, #16
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  10fd76:	f2c0 0010 	movt	r0, #16
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  10fd7a:	f2c0 0110 	movt	r1, #16
	drv_ops.glitch_filter.set_debounce_enable = pmu_set_glitch_filter_enable;
  10fd7e:	f2c0 0210 	movt	r2, #16
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  10fd82:	e9c4 762d 	strd	r7, r6, [r4, #180]	; 0xb4
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  10fd86:	f2c0 0310 	movt	r3, #16
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  10fd8a:	e9c4 502f 	strd	r5, r0, [r4, #188]	; 0xbc
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  10fd8e:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  10fd92:	e9c4 2334 	strd	r2, r3, [r4, #208]	; 0xd0
}
  10fd96:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010fd98 <hal_pmu_creat_handle>:


int32_t hal_pmu_creat_handle(void **handle, uint32_t pmu_res_glb_idx)
{
  10fd98:	b570      	push	{r4, r5, r6, r14}
  10fd9a:	b082      	sub	sp, #8
	static int flag = 0;
	int32_t ret;
	addr_t paddr;

	if (handle == NULL) {
  10fd9c:	b388      	cbz	r0, 10fe02 <hal_pmu_creat_handle+0x6a>
		pmu_err("parameters is wrong\n");
		return -1;
	}

	ret = res_get_info_by_id(pmu_res_glb_idx, &paddr, &dev.id);
  10fd9e:	f24c 74f4 	movw	r4, #51188	; 0xc7f4
  10fda2:	4606      	mov	r6, r0
  10fda4:	4608      	mov	r0, r1
  10fda6:	f2c0 0412 	movt	r4, #18
  10fdaa:	1d22      	adds	r2, r4, #4
  10fdac:	a901      	add	r1, sp, #4
  10fdae:	f000 fac1 	bl	110334 <res_get_info_by_id>
	if (ret < 0) {
  10fdb2:	1e05      	subs	r5, r0, #0
  10fdb4:	db17      	blt.n	10fde6 <hal_pmu_creat_handle+0x4e>
		pmu_err("res_get_info_by_id fail\n");
		return ret;
	}

	if (flag == 0) {
  10fdb6:	f240 2560 	movw	r5, #608	; 0x260
  10fdba:	f2c0 0513 	movt	r5, #19
  10fdbe:	682b      	ldr	r3, [r5, #0]
  10fdc0:	b123      	cbz	r3, 10fdcc <hal_pmu_creat_handle+0x34>
		dev.base_paddr = (volatile uint8_t *)paddr;
		dev.base_vaddr = (volatile uint8_t *)phys_to_virt(paddr);
		flag = 1;
	}

	*handle = (void *)&dev;
  10fdc2:	6034      	str	r4, [r6, #0]
	return 0;
  10fdc4:	2500      	movs	r5, #0
}
  10fdc6:	4628      	mov	r0, r5
  10fdc8:	b002      	add	sp, #8
  10fdca:	bd70      	pop	{r4, r5, r6, r15}
		hal_pmu_drv_ops_init();
  10fdcc:	f7ff ff26 	bl	10fc1c <hal_pmu_drv_ops_init>
		dev.priv_data = (void *)&drv_ops;
  10fdd0:	f240 1384 	movw	r3, #388	; 0x184
		flag = 1;
  10fdd4:	2101      	movs	r1, #1
		dev.priv_data = (void *)&drv_ops;
  10fdd6:	f2c0 0313 	movt	r3, #19
		dev.base_paddr = (volatile uint8_t *)paddr;
  10fdda:	9a01      	ldr	r2, [sp, #4]
		dev.priv_data = (void *)&drv_ops;
  10fddc:	6163      	str	r3, [r4, #20]
		flag = 1;
  10fdde:	6029      	str	r1, [r5, #0]
		dev.base_vaddr = (volatile uint8_t *)phys_to_virt(paddr);
  10fde0:	e9c4 2203 	strd	r2, r2, [r4, #12]
  10fde4:	e7ed      	b.n	10fdc2 <hal_pmu_creat_handle+0x2a>
		pmu_err("res_get_info_by_id fail\n");
  10fde6:	f64c 4184 	movw	r1, #52356	; 0xcc84
  10fdea:	f64c 5038 	movw	r0, #52536	; 0xcd38
  10fdee:	2258      	movs	r2, #88	; 0x58
  10fdf0:	f2c0 0111 	movt	r1, #17
  10fdf4:	f2c0 0011 	movt	r0, #17
  10fdf8:	f004 fd04 	bl	114804 <printf>
}
  10fdfc:	4628      	mov	r0, r5
  10fdfe:	b002      	add	sp, #8
  10fe00:	bd70      	pop	{r4, r5, r6, r15}
		pmu_err("parameters is wrong\n");
  10fe02:	f64c 4184 	movw	r1, #52356	; 0xcc84
  10fe06:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10fe0a:	2252      	movs	r2, #82	; 0x52
  10fe0c:	f2c0 0111 	movt	r1, #17
		return -1;
  10fe10:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		pmu_err("parameters is wrong\n");
  10fe14:	f2c0 0011 	movt	r0, #17
  10fe18:	f004 fcf4 	bl	114804 <printf>
		return -1;
  10fe1c:	e7d3      	b.n	10fdc6 <hal_pmu_creat_handle+0x2e>
  10fe1e:	bf00      	nop

0010fe20 <hal_pmu_release_handle>:


int32_t hal_pmu_release_handle(void *handle)
{
	return 0;
}
  10fe20:	2000      	movs	r0, #0
  10fe22:	4770      	bx	r14

0010fe24 <hal_pmu_init>:

int32_t hal_pmu_init(void *handle)
{
  10fe24:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  10fe26:	b130      	cbz	r0, 10fe36 <hal_pmu_init+0x12>
  10fe28:	6943      	ldr	r3, [r0, #20]
  10fe2a:	b123      	cbz	r3, 10fe36 <hal_pmu_init+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->global.init != NULL)
  10fe2c:	681b      	ldr	r3, [r3, #0]
  10fe2e:	b183      	cbz	r3, 10fe52 <hal_pmu_init+0x2e>
		return ops->global.init(dev);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  10fe30:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->global.init(dev);
  10fe34:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  10fe36:	f64c 419c 	movw	r1, #52380	; 0xcc9c
  10fe3a:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10fe3e:	f2c0 0111 	movt	r1, #17
  10fe42:	2274      	movs	r2, #116	; 0x74
  10fe44:	f2c0 0011 	movt	r0, #17
  10fe48:	f004 fcdc 	bl	114804 <printf>
}
  10fe4c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10fe50:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  10fe52:	f64c 439c 	movw	r3, #52380	; 0xcc9c
  10fe56:	f64c 5058 	movw	r0, #52568	; 0xcd58
  10fe5a:	227d      	movs	r2, #125	; 0x7d
  10fe5c:	f2c0 0311 	movt	r3, #17
  10fe60:	4619      	mov	r1, r3
  10fe62:	f2c0 0011 	movt	r0, #17
  10fe66:	f004 fccd 	bl	114804 <printf>
	return -1;
  10fe6a:	e7ef      	b.n	10fe4c <hal_pmu_init+0x28>

0010fe6c <hal_pmu_exit>:

int32_t hal_pmu_exit(void *handle)
{
  10fe6c:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  10fe6e:	b130      	cbz	r0, 10fe7e <hal_pmu_exit+0x12>
  10fe70:	6943      	ldr	r3, [r0, #20]
  10fe72:	b123      	cbz	r3, 10fe7e <hal_pmu_exit+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->global.exit != NULL)
  10fe74:	685b      	ldr	r3, [r3, #4]
  10fe76:	b183      	cbz	r3, 10fe9a <hal_pmu_exit+0x2e>
		return ops->global.exit(dev);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  10fe78:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->global.exit(dev);
  10fe7c:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  10fe7e:	f64c 41ac 	movw	r1, #52396	; 0xccac
  10fe82:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10fe86:	f2c0 0111 	movt	r1, #17
  10fe8a:	2287      	movs	r2, #135	; 0x87
  10fe8c:	f2c0 0011 	movt	r0, #17
  10fe90:	f004 fcb8 	bl	114804 <printf>
}
  10fe94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10fe98:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  10fe9a:	f64c 43ac 	movw	r3, #52396	; 0xccac
  10fe9e:	f64c 5058 	movw	r0, #52568	; 0xcd58
  10fea2:	2290      	movs	r2, #144	; 0x90
  10fea4:	f2c0 0311 	movt	r3, #17
  10fea8:	4619      	mov	r1, r3
  10feaa:	f2c0 0011 	movt	r0, #17
  10feae:	f004 fca9 	bl	114804 <printf>
	return -1;
  10feb2:	e7ef      	b.n	10fe94 <hal_pmu_exit+0x28>

0010feb4 <hal_pmu_set_powerctrl_io_mode>:
	pmu_err("%s is not support\n", __func__);
	return -1;
}

int32_t hal_pmu_set_powerctrl_io_mode(void *handle, int ctrl_id, int mode)
{
  10feb4:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  10feb6:	b130      	cbz	r0, 10fec6 <hal_pmu_set_powerctrl_io_mode+0x12>
  10feb8:	6943      	ldr	r3, [r0, #20]
  10feba:	b123      	cbz	r3, 10fec6 <hal_pmu_set_powerctrl_io_mode+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_io_mode != NULL)
  10febc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  10febe:	b18b      	cbz	r3, 10fee4 <hal_pmu_set_powerctrl_io_mode+0x30>
		return ops->pwr_ctrl.set_io_mode(dev, ctrl_id, mode);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  10fec0:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_io_mode(dev, ctrl_id, mode);
  10fec4:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  10fec6:	f64c 41bc 	movw	r1, #52412	; 0xccbc
  10feca:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10fece:	f2c0 0111 	movt	r1, #17
  10fed2:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
  10fed6:	f2c0 0011 	movt	r0, #17
  10feda:	f004 fc93 	bl	114804 <printf>
}
  10fede:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10fee2:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  10fee4:	f64c 43bc 	movw	r3, #52412	; 0xccbc
  10fee8:	f64c 5058 	movw	r0, #52568	; 0xcd58
  10feec:	f240 12ad 	movw	r2, #429	; 0x1ad
  10fef0:	f2c0 0311 	movt	r3, #17
  10fef4:	4619      	mov	r1, r3
  10fef6:	f2c0 0011 	movt	r0, #17
  10fefa:	f004 fc83 	bl	114804 <printf>
	return -1;
  10fefe:	e7ee      	b.n	10fede <hal_pmu_set_powerctrl_io_mode+0x2a>

0010ff00 <hal_pmu_set_powerctrl_out_mode>:

int32_t hal_pmu_set_powerctrl_out_mode(void *handle, int ctrl_id, int mode)
{
  10ff00:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  10ff02:	b130      	cbz	r0, 10ff12 <hal_pmu_set_powerctrl_out_mode+0x12>
  10ff04:	6943      	ldr	r3, [r0, #20]
  10ff06:	b123      	cbz	r3, 10ff12 <hal_pmu_set_powerctrl_out_mode+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_out_mode != NULL)
  10ff08:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  10ff0a:	b18b      	cbz	r3, 10ff30 <hal_pmu_set_powerctrl_out_mode+0x30>
		return ops->pwr_ctrl.set_out_mode(dev, ctrl_id, mode);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  10ff0c:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_out_mode(dev, ctrl_id, mode);
  10ff10:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  10ff12:	f64c 41dc 	movw	r1, #52444	; 0xccdc
  10ff16:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10ff1a:	f2c0 0111 	movt	r1, #17
  10ff1e:	f240 12b7 	movw	r2, #439	; 0x1b7
  10ff22:	f2c0 0011 	movt	r0, #17
  10ff26:	f004 fc6d 	bl	114804 <printf>
}
  10ff2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10ff2e:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  10ff30:	f64c 43dc 	movw	r3, #52444	; 0xccdc
  10ff34:	f64c 5058 	movw	r0, #52568	; 0xcd58
  10ff38:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
  10ff3c:	f2c0 0311 	movt	r3, #17
  10ff40:	4619      	mov	r1, r3
  10ff42:	f2c0 0011 	movt	r0, #17
  10ff46:	f004 fc5d 	bl	114804 <printf>
	return -1;
  10ff4a:	e7ee      	b.n	10ff2a <hal_pmu_set_powerctrl_out_mode+0x2a>

0010ff4c <hal_pmu_set_powerctrl_out_ctrl>:

int32_t hal_pmu_set_powerctrl_out_ctrl(void *handle, int ctrl_id, int out)
{
  10ff4c:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  10ff4e:	b130      	cbz	r0, 10ff5e <hal_pmu_set_powerctrl_out_ctrl+0x12>
  10ff50:	6943      	ldr	r3, [r0, #20]
  10ff52:	b123      	cbz	r3, 10ff5e <hal_pmu_set_powerctrl_out_ctrl+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_out_ctrl != NULL)
  10ff54:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  10ff56:	b18b      	cbz	r3, 10ff7c <hal_pmu_set_powerctrl_out_ctrl+0x30>
		return ops->pwr_ctrl.set_out_ctrl(dev, ctrl_id, out);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  10ff58:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_out_ctrl(dev, ctrl_id, out);
  10ff5c:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  10ff5e:	f64c 41fc 	movw	r1, #52476	; 0xccfc
  10ff62:	f64c 501c 	movw	r0, #52508	; 0xcd1c
  10ff66:	f2c0 0111 	movt	r1, #17
  10ff6a:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
  10ff6e:	f2c0 0011 	movt	r0, #17
  10ff72:	f004 fc47 	bl	114804 <printf>
}
  10ff76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  10ff7a:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  10ff7c:	f64c 43fc 	movw	r3, #52476	; 0xccfc
  10ff80:	f64c 5058 	movw	r0, #52568	; 0xcd58
  10ff84:	f240 12d3 	movw	r2, #467	; 0x1d3
  10ff88:	f2c0 0311 	movt	r3, #17
  10ff8c:	4619      	mov	r1, r3
  10ff8e:	f2c0 0011 	movt	r0, #17
  10ff92:	f004 fc37 	bl	114804 <printf>
	return -1;
  10ff96:	e7ee      	b.n	10ff76 <hal_pmu_set_powerctrl_out_ctrl+0x2a>

0010ff98 <hal_port_creat_handle>:
spin_lock_t port_spin_lock = SPIN_LOCK_INITIAL_VALUE;

static struct port_handle s_port_handle;

bool hal_port_creat_handle(void **handle, uint32_t port_res_glb_idx)
{
  10ff98:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct port_handle *p_handle;
    int8_t ret = 0;
    paddr_t phy_addr = 0;
  10ff9a:	2400      	movs	r4, #0
{
  10ff9c:	b085      	sub	sp, #20
  10ff9e:	4606      	mov	r6, r0
    paddr_t dio_phy_addr = 0;
    int32_t dio_real_idx = 0;
    spin_lock_saved_state_t states;
    LTRACEF("+hal_port_creat_handle \n");

    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  10ffa0:	aa01      	add	r2, sp, #4
    int32_t real_idx = 0;
  10ffa2:	e9cd 4400 	strd	r4, r4, [r13]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  10ffa6:	4608      	mov	r0, r1
    int32_t dio_real_idx = 0;
  10ffa8:	e9cd 4402 	strd	r4, r4, [r13, #8]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  10ffac:	4669      	mov	r1, r13
  10ffae:	f000 f9c1 	bl	110334 <res_get_info_by_id>

    if (ret != -1) {
  10ffb2:	b240      	sxtb	r0, r0
  10ffb4:	3001      	adds	r0, #1
  10ffb6:	d046      	beq.n	110046 <hal_port_creat_handle+0xae>
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
        return false;
    }

    /* To get GPIO base address for Port */
    ret = res_get_info_by_id(g_gpio_res.res_id[0], &dio_phy_addr, &dio_real_idx);
  10ffb8:	f64d 43d4 	movw	r3, #56532	; 0xdcd4
  10ffbc:	aa03      	add	r2, sp, #12
  10ffbe:	f2c0 0311 	movt	r3, #17
  10ffc2:	a902      	add	r1, sp, #8
  10ffc4:	6858      	ldr	r0, [r3, #4]
  10ffc6:	f000 f9b5 	bl	110334 <res_get_info_by_id>

    if (ret != -1) {
  10ffca:	b240      	sxtb	r0, r0
  10ffcc:	3001      	adds	r0, #1
  10ffce:	d043      	beq.n	110058 <hal_port_creat_handle+0xc0>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10ffd0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10ffd4:	f013 0580 	ands.w	r5, r3, #128	; 0x80
  10ffd8:	d11b      	bne.n	110012 <hal_port_creat_handle+0x7a>
    __asm__ volatile("cpsid i");
  10ffda:	b672      	cpsid	i

#endif

    p_handle = &s_port_handle;
    spin_lock_irqsave(&port_spin_lock, states);
    p_handle->phy_addr = phy_addr;
  10ffdc:	f240 2368 	movw	r3, #616	; 0x268
    *lock = 1;
  10ffe0:	f240 2764 	movw	r7, #612	; 0x264
  10ffe4:	9a00      	ldr	r2, [sp, #0]
  10ffe6:	f2c0 0313 	movt	r3, #19
  10ffea:	2401      	movs	r4, #1
  10ffec:	f2c0 0713 	movt	r7, #19
  10fff0:	601a      	str	r2, [r3, #0]
    p_handle->real_idx = real_idx;
    p_handle->dio_phy_addr = dio_phy_addr;
    p_handle->dio_real_idx = dio_real_idx;
    *handle = p_handle;
    Port_SetHandle((void *)p_handle);
  10fff2:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  10fff4:	9a01      	ldr	r2, [sp, #4]
  10fff6:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  10fff8:	9a02      	ldr	r2, [sp, #8]
  10fffa:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  10fffc:	9a03      	ldr	r2, [sp, #12]
  10fffe:	60da      	str	r2, [r3, #12]
  110000:	603c      	str	r4, [r7, #0]
    *handle = p_handle;
  110002:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  110004:	f7f9 f988 	bl	109318 <Port_SetHandle>
    *lock = 0;
  110008:	603d      	str	r5, [r7, #0]
    __asm__ volatile("cpsie i");
  11000a:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);


    LTRACEF("-hal_port_creat_handle finished\n");

    return true;
  11000c:	4620      	mov	r0, r4
}
  11000e:	b005      	add	sp, #20
  110010:	bdf0      	pop	{r4, r5, r6, r7, r15}
    p_handle->phy_addr = phy_addr;
  110012:	f240 2368 	movw	r3, #616	; 0x268
    *lock = 1;
  110016:	f240 2764 	movw	r7, #612	; 0x264
  11001a:	9a00      	ldr	r2, [sp, #0]
  11001c:	f2c0 0313 	movt	r3, #19
  110020:	2501      	movs	r5, #1
  110022:	f2c0 0713 	movt	r7, #19
  110026:	601a      	str	r2, [r3, #0]
    Port_SetHandle((void *)p_handle);
  110028:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  11002a:	9a01      	ldr	r2, [sp, #4]
  11002c:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  11002e:	9a02      	ldr	r2, [sp, #8]
  110030:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  110032:	9a03      	ldr	r2, [sp, #12]
  110034:	603d      	str	r5, [r7, #0]
  110036:	60da      	str	r2, [r3, #12]
    *handle = p_handle;
  110038:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  11003a:	f7f9 f96d 	bl	109318 <Port_SetHandle>
    *lock = 0;
  11003e:	603c      	str	r4, [r7, #0]
    return true;
  110040:	4628      	mov	r0, r5
}
  110042:	b005      	add	sp, #20
  110044:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
  110046:	f24d 5020 	movw	r0, #54560	; 0xd520
  11004a:	f2c0 0011 	movt	r0, #17
  11004e:	f004 fbc1 	bl	1147d4 <puts>
        return false;
  110052:	4620      	mov	r0, r4
}
  110054:	b005      	add	sp, #20
  110056:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for dio failed! 03\n");
  110058:	f24d 5060 	movw	r0, #54624	; 0xd560
  11005c:	f2c0 0011 	movt	r0, #17
  110060:	f004 fbb8 	bl	1147d4 <puts>
        return false;
  110064:	4620      	mov	r0, r4
}
  110066:	b005      	add	sp, #20
  110068:	bdf0      	pop	{r4, r5, r6, r7, r15}
  11006a:	bf00      	nop

0011006c <hal_port_release_handle>:

bool hal_port_release_handle(void **handle)
{
  11006c:	b510      	push	{r4, r14}
  11006e:	b082      	sub	sp, #8
    ASSERT(handle);
  110070:	b310      	cbz	r0, 1100b8 <hal_port_release_handle+0x4c>
    struct port_handle *port = *handle;
  110072:	6802      	ldr	r2, [r0, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  110074:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  110078:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  11007c:	d10e      	bne.n	11009c <hal_port_release_handle+0x30>
    __asm__ volatile("cpsid i");
  11007e:	b672      	cpsid	i
    *lock = 0;
  110080:	f240 2164 	movw	r1, #612	; 0x264
    spin_lock_saved_state_t states;

    spin_lock_irqsave(&port_spin_lock, states);
    port->phy_addr = 0;
    port->real_idx = -1;
  110084:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  110088:	f2c0 0113 	movt	r1, #19
  11008c:	e9c2 3400 	strd	r3, r4, [r2]
    *handle = NULL;
  110090:	6003      	str	r3, [r0, #0]
  110092:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
  110094:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);

    return true;
}
  110096:	2001      	movs	r0, #1
  110098:	b002      	add	sp, #8
  11009a:	bd10      	pop	{r4, r15}
  11009c:	f240 2364 	movw	r3, #612	; 0x264
    port->phy_addr = 0;
  1100a0:	2100      	movs	r1, #0
    port->real_idx = -1;
  1100a2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  1100a6:	f2c0 0313 	movt	r3, #19
  1100aa:	e9c2 1400 	strd	r1, r4, [r2]
    *handle = NULL;
  1100ae:	6001      	str	r1, [r0, #0]
}
  1100b0:	2001      	movs	r0, #1
  1100b2:	6019      	str	r1, [r3, #0]
  1100b4:	b002      	add	sp, #8
  1100b6:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  1100b8:	f647 4370 	movw	r3, #31856	; 0x7c70
  1100bc:	f24d 52b8 	movw	r2, #54712	; 0xd5b8
  1100c0:	f647 4134 	movw	r1, #31796	; 0x7c34
  1100c4:	f2c0 0311 	movt	r3, #17
  1100c8:	4670      	mov	r0, r14
  1100ca:	f2c0 0211 	movt	r2, #17
  1100ce:	9300      	str	r3, [sp, #0]
  1100d0:	f2c0 0111 	movt	r1, #17
  1100d4:	2374      	movs	r3, #116	; 0x74
  1100d6:	f003 fb61 	bl	11379c <_panic>
  1100da:	bf00      	nop

001100dc <hal_port_init>:

    return true;
}

int hal_port_init(void *handle)
{
  1100dc:	b500      	push	{r14}
  1100de:	b085      	sub	sp, #20
    ASSERT(handle);
  1100e0:	b1e0      	cbz	r0, 11011c <hal_port_init+0x40>

#if NOT_USE_SYS_CFG
    port_config = (Port_ConfigType){&Port_kConfiguration[0]};
#else
    //check port configs source
    addr_t addr_config = 0;
  1100e2:	2300      	movs	r3, #0
  1100e4:	a904      	add	r1, sp, #16

    uint32_t res = get_config_info(MODULE_PORT_CFG, &addr_config);
  1100e6:	2004      	movs	r0, #4
    addr_t addr_config = 0;
  1100e8:	f841 3d04 	str.w	r3, [r1, #-4]!
    uint32_t res = get_config_info(MODULE_PORT_CFG, &addr_config);
  1100ec:	f004 fc0c 	bl	114908 <get_config_info>
    if (0 != res) {
  1100f0:	b940      	cbnz	r0, 110104 <hal_port_init+0x28>
        dprintf(CRITICAL, "get config info fail.\n");
        port_config = (Port_ConfigType){&Port_kConfiguration[0]};
    }
    else {
        LTRACEF("hal_port_init use binary config.\n");
        port_config = (Port_ConfigType){(Port_n_ConfigType*)(void*)addr_config};
  1100f2:	9b03      	ldr	r3, [sp, #12]
  1100f4:	9302      	str	r3, [sp, #8]
    }
#endif

    LTRACEF("hal_port_init \n");
    Port_Init(&port_config);
  1100f6:	a802      	add	r0, sp, #8
  1100f8:	f7f8 ff3e 	bl	108f78 <Port_Init>

    return true;
}
  1100fc:	2001      	movs	r0, #1
  1100fe:	b005      	add	sp, #20
  110100:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(CRITICAL, "get config info fail.\n");
  110104:	f24d 50a0 	movw	r0, #54688	; 0xd5a0
  110108:	f2c0 0011 	movt	r0, #17
  11010c:	f004 fb62 	bl	1147d4 <puts>
        port_config = (Port_ConfigType){&Port_kConfiguration[0]};
  110110:	f64c 5378 	movw	r3, #52600	; 0xcd78
  110114:	f2c0 0311 	movt	r3, #17
  110118:	9302      	str	r3, [sp, #8]
  11011a:	e7ec      	b.n	1100f6 <hal_port_init+0x1a>
    ASSERT(handle);
  11011c:	f647 4370 	movw	r3, #31856	; 0x7c70
  110120:	f24d 52b8 	movw	r2, #54712	; 0xd5b8
  110124:	f647 4134 	movw	r1, #31796	; 0x7c34
  110128:	f2c0 0311 	movt	r3, #17
  11012c:	4670      	mov	r0, r14
  11012e:	f2c0 0211 	movt	r2, #17
  110132:	9300      	str	r3, [sp, #0]
  110134:	f2c0 0111 	movt	r1, #17
  110138:	2395      	movs	r3, #149	; 0x95
  11013a:	f003 fb2f 	bl	11379c <_panic>
  11013e:	bf00      	nop

00110140 <hal_port_set_pin_mode>:
    return true;
}

int hal_port_set_pin_mode(void *handle, const Port_PinType pin,
                          const Port_PinModeType mode)
{
  110140:	b510      	push	{r4, r14}
  110142:	b084      	sub	sp, #16
  110144:	ac02      	add	r4, sp, #8
  110146:	e884 000c 	stmia.w	r4, {r2, r3}
    ASSERT(handle);
  11014a:	b138      	cbz	r0, 11015c <hal_port_set_pin_mode+0x1c>
    Port_SetPinMode(pin, mode);
  11014c:	4608      	mov	r0, r1
  11014e:	e894 0006 	ldmia.w	r4, {r1, r2}
  110152:	f7f9 f873 	bl	10923c <Port_SetPinMode>

    return true;
}
  110156:	2001      	movs	r0, #1
  110158:	b004      	add	sp, #16
  11015a:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  11015c:	f647 4370 	movw	r3, #31856	; 0x7c70
  110160:	f24d 52b8 	movw	r2, #54712	; 0xd5b8
  110164:	f647 4134 	movw	r1, #31796	; 0x7c34
  110168:	f2c0 0311 	movt	r3, #17
  11016c:	4670      	mov	r0, r14
  11016e:	f2c0 0211 	movt	r2, #17
  110172:	9300      	str	r3, [sp, #0]
  110174:	f2c0 0111 	movt	r1, #17
  110178:	23f6      	movs	r3, #246	; 0xf6
  11017a:	f003 fb0f 	bl	11379c <_panic>
  11017e:	bf00      	nop

00110180 <parse_paddr_ppc>:
    return -1;
}

/* Parse address for peripheral type resources */
int32_t parse_paddr_ppc(uint32_t ppc_index, uint32_t slot_index, addr_t * paddr)
{
  110180:	b5f0      	push	{r4, r5, r6, r7, r14}
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  110182:	f24d 54e0 	movw	r4, #54752	; 0xd5e0
{
  110186:	4607      	mov	r7, r0
  110188:	468c      	mov	r12, r1
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  11018a:	f2c0 0411 	movt	r4, #17
{
  11018e:	4696      	mov	r14, r2
                                APBMUX5_IP_BASE, APBMUX6_IP_BASE, APBMUX7_IP_BASE, APBMUX8_IP_BASE,
                                APB_DDR_CFG_BASE, APB_SMMU_BASE, APB_CE2_REG_BASE, APB_SCR4K_SID_BASE,
                                APB_SCR4K_SSID_BASE, APB_CSSYS_BASE};
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  110190:	f104 0538 	add.w	r5, r4, #56	; 0x38
{
  110194:	b09d      	sub	sp, #116	; 0x74
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  110196:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  110198:	466e      	mov	r6, r13
  11019a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  11019c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  11019e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  1101a0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  1101a2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  1101a4:	e894 0003 	ldmia.w	r4, {r0, r1}
                                APBMUX5_IP_SIZE, APBMUX6_IP_SIZE, APBMUX7_IP_SIZE, APBMUX8_IP_SIZE,
                                APB_DDR_CFG_SIZE, APB_SMMU_SIZE, APB_CE2_REG_SIZE, APB_SCR4K_SID_SIZE,
                                APB_SCR4K_SSID_SIZE, APB_CSSYS_SIZE};

    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  1101a8:	ab1c      	add	r3, sp, #112	; 0x70
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  1101aa:	e886 0003 	stmia.w	r6, {r0, r1}
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  1101ae:	eb03 0687 	add.w	r6, r3, r7, lsl #2
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  1101b2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1101b4:	ac0e      	add	r4, sp, #56	; 0x38
  1101b6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1101b8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1101ba:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1101bc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  1101be:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  1101c0:	e895 0003 	ldmia.w	r5, {r0, r1}
  1101c4:	e884 0003 	stmia.w	r4, {r0, r1}

    return 0;
}
  1101c8:	2000      	movs	r0, #0
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  1101ca:	f856 2c38 	ldr.w	r2, [r6, #-56]
  1101ce:	f856 3c70 	ldr.w	r3, [r6, #-112]
  1101d2:	fb02 330c 	mla	r3, r2, r12, r3
  1101d6:	f8ce 3000 	str.w	r3, [r14]
}
  1101da:	b01d      	add	sp, #116	; 0x74
  1101dc:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1101de:	bf00      	nop

001101e0 <parse_paddr_rpc>:

/* Parse address and index for register level resources */
int32_t parse_paddr_rpc(uint32_t rpc_index, uint32_t slot_index, addr_t * paddr, int32_t * index)
{
  1101e0:	b410      	push	{r4}
    if (slot_index >= 2046) {
  1101e2:	f240 74fd 	movw	r4, #2045	; 0x7fd
  1101e6:	42a1      	cmp	r1, r4
  1101e8:	d824      	bhi.n	110234 <parse_paddr_rpc+0x54>
        return -1;
    }

    uint32_t addr_offset = 0;

    if (slot_index >= IOMUXC_INDEX) {
  1101ea:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
  1101ee:	d213      	bcs.n	110218 <parse_paddr_rpc+0x38>
        *index = slot_index - IOMUXC_INDEX;
        addr_offset = 5;
    }
    else if (slot_index >= RSTGEN_INDEX) {
  1101f0:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  1101f4:	d32b      	bcc.n	11024e <parse_paddr_rpc+0x6e>
        *index = slot_index - RSTGEN_INDEX;
        addr_offset = 4;
  1101f6:	2404      	movs	r4, #4
        *index = slot_index - RSTGEN_INDEX;
  1101f8:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
  1101fc:	6019      	str	r1, [r3, #0]
    }
    else {
        *index = slot_index;
    }

    switch (rpc_index) {
  1101fe:	2801      	cmp	r0, #1
  110200:	d010      	beq.n	110224 <parse_paddr_rpc+0x44>
  110202:	d31c      	bcc.n	11023e <parse_paddr_rpc+0x5e>
  110204:	2802      	cmp	r0, #2
  110206:	d115      	bne.n	110234 <parse_paddr_rpc+0x54>
        default:
            return -1;
        break;
    }

    return 0;
  110208:	2000      	movs	r0, #0
            *paddr = APB_RPC_SAF_BASE + addr_offset * RPC_ADDR_OFFSET;
  11020a:	f504 647c 	add.w	r4, r4, #4032	; 0xfc0
  11020e:	0524      	lsls	r4, r4, #20
  110210:	6014      	str	r4, [r2, #0]
}
  110212:	f85d 4b04 	ldr.w	r4, [r13], #4
  110216:	4770      	bx	r14
        *index = slot_index - IOMUXC_INDEX;
  110218:	f5a1 61a0 	sub.w	r1, r1, #1280	; 0x500
        addr_offset = 5;
  11021c:	2405      	movs	r4, #5
    switch (rpc_index) {
  11021e:	2801      	cmp	r0, #1
        *index = slot_index - IOMUXC_INDEX;
  110220:	6019      	str	r1, [r3, #0]
    switch (rpc_index) {
  110222:	d1ee      	bne.n	110202 <parse_paddr_rpc+0x22>
    return 0;
  110224:	2000      	movs	r0, #0
            *paddr = APB_RPC_SEC_BASE + addr_offset * RPC_ADDR_OFFSET;
  110226:	f504 6478 	add.w	r4, r4, #3968	; 0xf80
  11022a:	0524      	lsls	r4, r4, #20
  11022c:	6014      	str	r4, [r2, #0]
}
  11022e:	f85d 4b04 	ldr.w	r4, [r13], #4
  110232:	4770      	bx	r14
  110234:	f85d 4b04 	ldr.w	r4, [r13], #4
            return -1;
  110238:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  11023c:	4770      	bx	r14
    return 0;
  11023e:	2000      	movs	r0, #0
            *paddr = APB_RPC_SOC_BASE + addr_offset * RPC_ADDR_OFFSET;
  110240:	f504 6476 	add.w	r4, r4, #3936	; 0xf60
  110244:	0524      	lsls	r4, r4, #20
  110246:	6014      	str	r4, [r2, #0]
}
  110248:	f85d 4b04 	ldr.w	r4, [r13], #4
  11024c:	4770      	bx	r14
    else if (slot_index >= SCR_INDEX) {
  11024e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
        addr_offset = 2;
  110252:	bf26      	itte	cs
  110254:	2402      	movcs	r4, #2
        *index = slot_index - SCR_INDEX;
  110256:	f5a1 7100 	subcs.w	r1, r1, #512	; 0x200
    uint32_t addr_offset = 0;
  11025a:	2400      	movcc	r4, #0
        *index = slot_index;
  11025c:	6019      	str	r1, [r3, #0]
  11025e:	e7ce      	b.n	1101fe <parse_paddr_rpc+0x1e>

00110260 <res_parse_info>:

/* Parse resource ID to acquire base address and index of resource */
int32_t res_parse_info(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  110260:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t rapc_type;
    uint32_t rapc_index;
    uint32_t slot_index;
    int32_t res = 0;

    *index = -1;
  110262:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

    rapc_type = res_id >> 30;
  110266:	0f84      	lsrs	r4, r0, #30
{
  110268:	4613      	mov	r3, r2
    rapc_index = (res_id >> 24) & 0x3F;
    slot_index = res_id & 0xFFF;

    switch (rapc_type) {
  11026a:	2c02      	cmp	r4, #2
    *index = -1;
  11026c:	6015      	str	r5, [r2, #0]
    rapc_index = (res_id >> 24) & 0x3F;
  11026e:	f3c0 6605 	ubfx	r6, r0, #24, #6
    slot_index = res_id & 0xFFF;
  110272:	f3c0 070b 	ubfx	r7, r0, #0, #12
    switch (rapc_type) {
  110276:	d042      	beq.n	1102fe <res_parse_info+0x9e>
  110278:	2c03      	cmp	r4, #3
  11027a:	d02d      	beq.n	1102d8 <res_parse_info+0x78>
  11027c:	2c01      	cmp	r4, #1
  11027e:	d020      	beq.n	1102c2 <res_parse_info+0x62>
        case 0: //MPC
            if (rapc_index >= MPC_MAX_NUM) {
  110280:	2e1a      	cmp	r6, #26
  110282:	d839      	bhi.n	1102f8 <res_parse_info+0x98>
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  110284:	f3c0 4246 	ubfx	r2, r0, #17, #7
    if (cat_id >= MPC_CATEGORY_MAX) {
  110288:	2a0d      	cmp	r2, #13
  11028a:	d835      	bhi.n	1102f8 <res_parse_info+0x98>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  11028c:	f64c 030c 	movw	r3, #51212	; 0xc80c
  110290:	f2c0 0312 	movt	r3, #18
  110294:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  110298:	6816      	ldr	r6, [r2, #0]
  11029a:	2e00      	cmp	r6, #0
  11029c:	dd2c      	ble.n	1102f8 <res_parse_info+0x98>
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  11029e:	6853      	ldr	r3, [r2, #4]
  1102a0:	4298      	cmp	r0, r3
  1102a2:	bf1c      	itt	ne
  1102a4:	4614      	movne	r4, r2
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  1102a6:	2300      	movne	r3, #0
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  1102a8:	d103      	bne.n	1102b2 <res_parse_info+0x52>
  1102aa:	e030      	b.n	11030e <res_parse_info+0xae>
  1102ac:	6865      	ldr	r5, [r4, #4]
  1102ae:	42a8      	cmp	r0, r5
  1102b0:	d02e      	beq.n	110310 <res_parse_info+0xb0>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  1102b2:	3301      	adds	r3, #1
  1102b4:	429e      	cmp	r6, r3
  1102b6:	f104 0408 	add.w	r4, r4, #8
  1102ba:	d1f7      	bne.n	1102ac <res_parse_info+0x4c>
            }

            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
            break;
        case 3: //unprotected
            res = -1;
  1102bc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1102c0:	e01b      	b.n	1102fa <res_parse_info+0x9a>
            if (rapc_index >= PPC_MAX_NUM) {
  1102c2:	2e0d      	cmp	r6, #13
  1102c4:	d818      	bhi.n	1102f8 <res_parse_info+0x98>
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  1102c6:	460a      	mov	r2, r1
            *index = (res_id >> 12) & 0x1F;
  1102c8:	f3c0 3004 	ubfx	r0, r0, #12, #5
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  1102cc:	4639      	mov	r1, r7
            *index = (res_id >> 12) & 0x1F;
  1102ce:	6018      	str	r0, [r3, #0]
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  1102d0:	4630      	mov	r0, r6
        default:
            return -1;
    }

    return res;
}
  1102d2:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  1102d4:	f7ff bf54 	b.w	110180 <parse_paddr_ppc>
                if (res_id == mem_info_unprotected.mem_info[i].res_id) {
  1102d8:	f64e 4310 	movw	r3, #60432	; 0xec10
  1102dc:	f2c0 0311 	movt	r3, #17
  1102e0:	685a      	ldr	r2, [r3, #4]
  1102e2:	4290      	cmp	r0, r2
  1102e4:	d01a      	beq.n	11031c <res_parse_info+0xbc>
  1102e6:	68da      	ldr	r2, [r3, #12]
  1102e8:	4290      	cmp	r0, r2
  1102ea:	d01e      	beq.n	11032a <res_parse_info+0xca>
  1102ec:	695a      	ldr	r2, [r3, #20]
  1102ee:	4290      	cmp	r0, r2
  1102f0:	d01d      	beq.n	11032e <res_parse_info+0xce>
  1102f2:	69da      	ldr	r2, [r3, #28]
  1102f4:	4290      	cmp	r0, r2
  1102f6:	d012      	beq.n	11031e <res_parse_info+0xbe>
            res = -1;
  1102f8:	4628      	mov	r0, r5
}
  1102fa:	bcf0      	pop	{r4, r5, r6, r7}
  1102fc:	4770      	bx	r14
            if (rapc_index >= PPC_MAX_NUM) {
  1102fe:	2e0d      	cmp	r6, #13
  110300:	d8fa      	bhi.n	1102f8 <res_parse_info+0x98>
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  110302:	460a      	mov	r2, r1
  110304:	4630      	mov	r0, r6
  110306:	4639      	mov	r1, r7
}
  110308:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  11030a:	f7ff bf69 	b.w	1101e0 <parse_paddr_rpc>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  11030e:	2300      	movs	r3, #0
            return 0;
  110310:	2000      	movs	r0, #0
            *paddr = mem_info_init[cat_id]->mem_info[i].paddr;
  110312:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  110316:	689b      	ldr	r3, [r3, #8]
  110318:	600b      	str	r3, [r1, #0]
  11031a:	e7ee      	b.n	1102fa <res_parse_info+0x9a>
            for (int i = 0; i < mem_info_unprotected.res_num; i++) {
  11031c:	2400      	movs	r4, #0
                    res = 0;
  11031e:	2000      	movs	r0, #0
                    *paddr = mem_info_unprotected.mem_info[i].paddr;
  110320:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  110324:	68a3      	ldr	r3, [r4, #8]
  110326:	600b      	str	r3, [r1, #0]
                    break;
  110328:	e7e7      	b.n	1102fa <res_parse_info+0x9a>
            for (int i = 0; i < mem_info_unprotected.res_num; i++) {
  11032a:	2401      	movs	r4, #1
  11032c:	e7f7      	b.n	11031e <res_parse_info+0xbe>
  11032e:	2402      	movs	r4, #2
  110330:	e7f5      	b.n	11031e <res_parse_info+0xbe>
  110332:	bf00      	nop

00110334 <res_get_info_by_id>:

/* Get resource info by ID. */
const int32_t res_get_info_by_id(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  110334:	b470      	push	{r4, r5, r6}
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  110336:	f3c0 4446 	ubfx	r4, r0, #17, #7

    if (cat_id >= (sizeof(g_res_cat) / sizeof(g_res_cat[0]))) {
  11033a:	2c4d      	cmp	r4, #77	; 0x4d
  11033c:	d817      	bhi.n	11036e <res_get_info_by_id+0x3a>
        return -1;
    }

    if (NULL != g_res_cat[cat_id]) { //check avaibility of resource
  11033e:	f24e 5368 	movw	r3, #58728	; 0xe568
  110342:	f2c0 0311 	movt	r3, #17
  110346:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
  11034a:	b184      	cbz	r4, 11036e <res_get_info_by_id+0x3a>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  11034c:	6826      	ldr	r6, [r4, #0]
  11034e:	2e00      	cmp	r6, #0
  110350:	dd0d      	ble.n	11036e <res_get_info_by_id+0x3a>
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  110352:	6863      	ldr	r3, [r4, #4]
  110354:	4298      	cmp	r0, r3
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  110356:	bf1c      	itt	ne
  110358:	2300      	movne	r3, #0
  11035a:	3404      	addne	r4, #4
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  11035c:	d104      	bne.n	110368 <res_get_info_by_id+0x34>
  11035e:	e00a      	b.n	110376 <res_get_info_by_id+0x42>
  110360:	f854 5f04 	ldr.w	r5, [r4, #4]!
  110364:	4285      	cmp	r5, r0
  110366:	d006      	beq.n	110376 <res_get_info_by_id+0x42>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  110368:	3301      	adds	r3, #1
  11036a:	42b3      	cmp	r3, r6
  11036c:	d1f8      	bne.n	110360 <res_get_info_by_id+0x2c>
                return res_parse_info(res_id, paddr, index);
        }
    }

    return -1;
}
  11036e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  110372:	bc70      	pop	{r4, r5, r6}
  110374:	4770      	bx	r14
  110376:	bc70      	pop	{r4, r5, r6}
                return res_parse_info(res_id, paddr, index);
  110378:	f7ff bf72 	b.w	110260 <res_parse_info>

0011037c <p2ap>:
    addrmap_def
};

/* Transform address from r core to a core */
paddr_t p2ap(paddr_t pa)
{
  11037c:	f44f 0296 	mov.w	r2, #4915200	; 0x4b0000
    int i = 0;
    struct addr_map *addr;
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  110380:	2300      	movs	r3, #0
{
  110382:	b430      	push	{r4, r5}
  110384:	f24d 6450 	movw	r4, #54864	; 0xd650
        addr = &addrmap_tab[i];
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
  110388:	4290      	cmp	r0, r2
  11038a:	f2c0 0411 	movt	r4, #17
  11038e:	4621      	mov	r1, r4
  110390:	eba0 0502 	sub.w	r5, r0, r2
  110394:	d302      	bcc.n	11039c <p2ap+0x20>
  110396:	684a      	ldr	r2, [r1, #4]
  110398:	4295      	cmp	r5, r2
  11039a:	d30b      	bcc.n	1103b4 <p2ap+0x38>
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  11039c:	3301      	adds	r3, #1
  11039e:	2b03      	cmp	r3, #3
  1103a0:	d00e      	beq.n	1103c0 <p2ap+0x44>
  1103a2:	f851 2f0c 	ldr.w	r2, [r1, #12]!
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
  1103a6:	4290      	cmp	r0, r2
  1103a8:	eba0 0502 	sub.w	r5, r0, r2
  1103ac:	d3f6      	bcc.n	11039c <p2ap+0x20>
  1103ae:	684a      	ldr	r2, [r1, #4]
  1103b0:	4295      	cmp	r5, r2
  1103b2:	d2f3      	bcs.n	11039c <p2ap+0x20>
            return (pa - addr->src + addr->dst);
  1103b4:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  1103b8:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  1103bc:	6898      	ldr	r0, [r3, #8]
  1103be:	4428      	add	r0, r5
        }
    }
    return pa;
}
  1103c0:	bc30      	pop	{r4, r5}
  1103c2:	4770      	bx	r14

001103c4 <ap2p>:

/* Transform address from a core to r core */
paddr_t ap2p(paddr_t va)
{
  1103c4:	f44f 114c 	mov.w	r1, #3342336	; 0x330000
    int i = 0;
    struct addr_map *addr;
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  1103c8:	2200      	movs	r2, #0
{
  1103ca:	b430      	push	{r4, r5}
  1103cc:	f24d 6550 	movw	r5, #54864	; 0xd650
        addr = &addrmap_tab[i];
        if (va >= addr->dst && (va - addr->dst) < addr->size) {
  1103d0:	4288      	cmp	r0, r1
  1103d2:	f2c0 0511 	movt	r5, #17
  1103d6:	462b      	mov	r3, r5
  1103d8:	eba0 0401 	sub.w	r4, r0, r1
  1103dc:	d302      	bcc.n	1103e4 <ap2p+0x20>
  1103de:	6859      	ldr	r1, [r3, #4]
  1103e0:	428c      	cmp	r4, r1
  1103e2:	d30c      	bcc.n	1103fe <ap2p+0x3a>
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  1103e4:	3201      	adds	r2, #1
  1103e6:	2a03      	cmp	r2, #3
  1103e8:	f103 030c 	add.w	r3, r3, #12
  1103ec:	d00c      	beq.n	110408 <ap2p+0x44>
  1103ee:	6899      	ldr	r1, [r3, #8]
        if (va >= addr->dst && (va - addr->dst) < addr->size) {
  1103f0:	4288      	cmp	r0, r1
  1103f2:	eba0 0401 	sub.w	r4, r0, r1
  1103f6:	d3f5      	bcc.n	1103e4 <ap2p+0x20>
  1103f8:	6859      	ldr	r1, [r3, #4]
  1103fa:	428c      	cmp	r4, r1
  1103fc:	d2f2      	bcs.n	1103e4 <ap2p+0x20>
            return (va - addr->dst + addr->src);
  1103fe:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  110402:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
  110406:	4420      	add	r0, r4
        }
    }
    return va;
}
  110408:	bc30      	pop	{r4, r5}
  11040a:	4770      	bx	r14

0011040c <hal_rstgen_creat_handle>:
//! \return rstgen handle
//
//*****************************************************************************
bool hal_rstgen_creat_handle(void **handle,
                             uint32_t global_rst_res_idx)
{
  11040c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    int32_t idx = -1;
  110410:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  110414:	b083      	sub	sp, #12
    int32_t idx = -1;
  110416:	9301      	str	r3, [sp, #4]
    rstgen_instance_t  *instance = NULL;

    if (handle == NULL) {
  110418:	b390      	cbz	r0, 110480 <hal_rstgen_creat_handle+0x74>
        LTRACEF("hal_get_resource paramenter error handle:%p\n", handle);
        return false;
    }

    if (rstgen_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  11041a:	f240 25a4 	movw	r5, #676	; 0x2a4
  11041e:	f2c0 0513 	movt	r5, #19
  110422:	682b      	ldr	r3, [r5, #0]
  110424:	b10b      	cbz	r3, 11042a <hal_rstgen_creat_handle+0x1e>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  110426:	2300      	movs	r3, #0
  110428:	602b      	str	r3, [r5, #0]
  11042a:	4607      	mov	r7, r0
  11042c:	4689      	mov	r9, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  11042e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  110432:	f013 0680 	ands.w	r6, r3, #128	; 0x80
  110436:	d127      	bne.n	110488 <hal_rstgen_creat_handle+0x7c>
    __asm__ volatile("cpsid i");
  110438:	b672      	cpsid	i
    if (g_RstgenInstance.occupied != 1) {
  11043a:	f240 2478 	movw	r4, #632	; 0x278
    *lock = 1;
  11043e:	f04f 0801 	mov.w	r8, #1
  110442:	f2c0 0413 	movt	r4, #19
  110446:	7a23      	ldrb	r3, [r4, #8]
  110448:	4543      	cmp	r3, r8
  11044a:	d048      	beq.n	1104de <hal_rstgen_creat_handle+0xd2>
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  11044c:	2228      	movs	r2, #40	; 0x28
  11044e:	4631      	mov	r1, r6
  110450:	4620      	mov	r0, r4
  110452:	f003 eaac 	blx	1139ac <memset>
            g_RstgenInstance.occupied = 1;
  110456:	f884 8008 	strb.w	r8, [r4, #8]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  11045a:	f884 801b 	strb.w	r8, [r4, #27]
    *controllerTable = &s_RstgenDrvInterface;
  11045e:	f64e 4334 	movw	r3, #60468	; 0xec34
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  110462:	f884 801c 	strb.w	r8, [r4, #28]
    *controllerTable = &s_RstgenDrvInterface;
  110466:	f2c0 0311 	movt	r3, #17
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  11046a:	f884 801d 	strb.w	r8, [r4, #29]
    *lock = 0;
  11046e:	602e      	str	r6, [r5, #0]
    *controllerTable = &s_RstgenDrvInterface;
  110470:	62a3      	str	r3, [r4, #40]	; 0x28
    __asm__ volatile("cpsie i");
  110472:	b662      	cpsie	i

    if (instance == NULL) {
        return false;
    }

    if (res_get_info_by_id(global_rst_res_idx,
  110474:	491b      	ldr	r1, [pc, #108]	; (1104e4 <hal_rstgen_creat_handle+0xd8>)
  110476:	4648      	mov	r0, r9
  110478:	aa01      	add	r2, sp, #4
  11047a:	f7ff ff5b 	bl	110334 <res_get_info_by_id>
  11047e:	b1a8      	cbz	r0, 1104ac <hal_rstgen_creat_handle+0xa0>
        return false;
  110480:	2000      	movs	r0, #0

    mutex_init(&instance->rstgenMutex);

    *handle = instance;
    return true;
}
  110482:	b003      	add	sp, #12
  110484:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    if (g_RstgenInstance.occupied != 1) {
  110488:	f240 2478 	movw	r4, #632	; 0x278
    *lock = 1;
  11048c:	2601      	movs	r6, #1
  11048e:	f2c0 0413 	movt	r4, #19
  110492:	7a23      	ldrb	r3, [r4, #8]
  110494:	42b3      	cmp	r3, r6
    *lock = 0;
  110496:	bf04      	itt	eq
  110498:	2300      	moveq	r3, #0
  11049a:	602b      	streq	r3, [r5, #0]
  11049c:	d10e      	bne.n	1104bc <hal_rstgen_creat_handle+0xb0>
    if (res_get_info_by_id(global_rst_res_idx,
  11049e:	4648      	mov	r0, r9
  1104a0:	aa01      	add	r2, sp, #4
  1104a2:	4910      	ldr	r1, [pc, #64]	; (1104e4 <hal_rstgen_creat_handle+0xd8>)
  1104a4:	f7ff ff46 	bl	110334 <res_get_info_by_id>
  1104a8:	2800      	cmp	r0, #0
  1104aa:	d1e9      	bne.n	110480 <hal_rstgen_creat_handle+0x74>
    mutex_init(&instance->rstgenMutex);
  1104ac:	480e      	ldr	r0, [pc, #56]	; (1104e8 <hal_rstgen_creat_handle+0xdc>)
  1104ae:	f006 f83d 	bl	11652c <mutex_init>
    *handle = instance;
  1104b2:	603c      	str	r4, [r7, #0]
    return true;
  1104b4:	2001      	movs	r0, #1
}
  1104b6:	b003      	add	sp, #12
  1104b8:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  1104bc:	2228      	movs	r2, #40	; 0x28
  1104be:	2100      	movs	r1, #0
  1104c0:	4620      	mov	r0, r4
  1104c2:	f003 ea74 	blx	1139ac <memset>
    *controllerTable = &s_RstgenDrvInterface;
  1104c6:	f64e 4334 	movw	r3, #60468	; 0xec34
  1104ca:	2200      	movs	r2, #0
  1104cc:	f2c0 0311 	movt	r3, #17
            g_RstgenInstance.occupied = 1;
  1104d0:	7226      	strb	r6, [r4, #8]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  1104d2:	76e6      	strb	r6, [r4, #27]
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  1104d4:	7726      	strb	r6, [r4, #28]
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  1104d6:	7766      	strb	r6, [r4, #29]
    *controllerTable = &s_RstgenDrvInterface;
  1104d8:	62a3      	str	r3, [r4, #40]	; 0x28
  1104da:	602a      	str	r2, [r5, #0]
  1104dc:	e7df      	b.n	11049e <hal_rstgen_creat_handle+0x92>
  1104de:	602e      	str	r6, [r5, #0]
  1104e0:	e7c7      	b.n	110472 <hal_rstgen_creat_handle+0x66>
  1104e2:	bf00      	nop
  1104e4:	00130284 	.word	0x00130284
  1104e8:	0013027c 	.word	0x0013027c

001104ec <hal_rstgen_release_handle>:
//*****************************************************************************
bool hal_rstgen_release_handle(void *handle)
{
    rstgen_instance_t *instance = NULL;

    if (handle == NULL) {
  1104ec:	b140      	cbz	r0, 110500 <hal_rstgen_release_handle+0x14>
{
  1104ee:	b508      	push	{r3, r14}
                handle);
        return false;
    }

    instance = (rstgen_instance_t *)handle;
    instance->occupied = 0;
  1104f0:	2200      	movs	r2, #0
  1104f2:	4603      	mov	r3, r0
    mutex_destroy(&instance->rstgenMutex);
  1104f4:	3004      	adds	r0, #4
    instance->occupied = 0;
  1104f6:	721a      	strb	r2, [r3, #8]
    mutex_destroy(&instance->rstgenMutex);
  1104f8:	f006 f820 	bl	11653c <mutex_destroy>
    return true;
  1104fc:	2001      	movs	r0, #1
}
  1104fe:	bd08      	pop	{r3, r15}
  110500:	4770      	bx	r14
  110502:	bf00      	nop

00110504 <hal_rstgen_init>:
}
#else
bool hal_rstgen_init(void *handle)
{
    return true;
}
  110504:	2001      	movs	r0, #1
  110506:	4770      	bx	r14

00110508 <hal_rstgen_iso_enable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_iso_enable(void *handle, uint32_t res_glb_idx)
{
  110508:	b530      	push	{r4, r5, r14}
    bool ret = false;
    paddr_t phy_addr = 0;
    int32_t iso_idx = -1;
  11050a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  11050e:	b083      	sub	sp, #12
    paddr_t phy_addr = 0;
  110510:	2400      	movs	r4, #0
    int32_t iso_idx = -1;
  110512:	aa02      	add	r2, sp, #8
{
  110514:	4605      	mov	r5, r0
    vaddr_t base = 0x0;
    rstgen_instance_t *instance = NULL;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110516:	4608      	mov	r0, r1
    int32_t iso_idx = -1;
  110518:	f842 3d04 	str.w	r3, [r2, #-4]!
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  11051c:	4669      	mov	r1, r13
    paddr_t phy_addr = 0;
  11051e:	9400      	str	r4, [sp, #0]
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110520:	f7ff ff08 	bl	110334 <res_get_info_by_id>
  110524:	b948      	cbnz	r0, 11053a <hal_rstgen_iso_enable+0x32>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((iso_idx > 0) && instance->controllerTable->iso_enable) {
  110526:	9901      	ldr	r1, [sp, #4]
  110528:	42a1      	cmp	r1, r4
  11052a:	dd04      	ble.n	110536 <hal_rstgen_iso_enable+0x2e>
  11052c:	6aab      	ldr	r3, [r5, #40]	; 0x28
  11052e:	69dc      	ldr	r4, [r3, #28]
  110530:	b11c      	cbz	r4, 11053a <hal_rstgen_iso_enable+0x32>
        ret = instance->controllerTable->iso_enable(
  110532:	9800      	ldr	r0, [sp, #0]
  110534:	47a0      	blx	r4
                  (vaddr_t)base, (uint32_t)iso_idx);
    }

    return ret;
}
  110536:	b003      	add	sp, #12
  110538:	bd30      	pop	{r4, r5, r15}
        return ret;
  11053a:	4620      	mov	r0, r4
}
  11053c:	b003      	add	sp, #12
  11053e:	bd30      	pop	{r4, r5, r15}

00110540 <hal_rstgen_iso_disable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_iso_disable(void *handle, uint32_t res_glb_idx)
{
  110540:	b530      	push	{r4, r5, r14}
    bool ret = false;
    paddr_t phy_addr = 0;
    int32_t iso_idx = -1;
  110542:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  110546:	b083      	sub	sp, #12
    paddr_t phy_addr = 0;
  110548:	2400      	movs	r4, #0
    int32_t iso_idx = -1;
  11054a:	aa02      	add	r2, sp, #8
{
  11054c:	4605      	mov	r5, r0
    vaddr_t base = 0x0;
    rstgen_instance_t *instance = NULL;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  11054e:	4608      	mov	r0, r1
    int32_t iso_idx = -1;
  110550:	f842 3d04 	str.w	r3, [r2, #-4]!
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110554:	4669      	mov	r1, r13
    paddr_t phy_addr = 0;
  110556:	9400      	str	r4, [sp, #0]
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110558:	f7ff feec 	bl	110334 <res_get_info_by_id>
  11055c:	b948      	cbnz	r0, 110572 <hal_rstgen_iso_disable+0x32>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((iso_idx > 0) && instance->controllerTable->iso_disable) {
  11055e:	9901      	ldr	r1, [sp, #4]
  110560:	42a1      	cmp	r1, r4
  110562:	dd04      	ble.n	11056e <hal_rstgen_iso_disable+0x2e>
  110564:	6aab      	ldr	r3, [r5, #40]	; 0x28
  110566:	6a1c      	ldr	r4, [r3, #32]
  110568:	b11c      	cbz	r4, 110572 <hal_rstgen_iso_disable+0x32>
        ret = instance->controllerTable->iso_disable(
  11056a:	9800      	ldr	r0, [sp, #0]
  11056c:	47a0      	blx	r4
                  (vaddr_t)base, (uint32_t)iso_idx);
    }

    return ret;
}
  11056e:	b003      	add	sp, #12
  110570:	bd30      	pop	{r4, r5, r15}
        return ret;
  110572:	4620      	mov	r0, r4
}
  110574:	b003      	add	sp, #12
  110576:	bd30      	pop	{r4, r5, r15}

00110578 <hal_rstgen_iso_status>:
//!
//! \return status, 1 not isolated, 0 isolated, -1 invalid res idx.
//
//*****************************************************************************
uint32_t hal_rstgen_iso_status(void *handle, uint32_t res_glb_idx)
{
  110578:	b530      	push	{r4, r5, r14}
    uint32_t ret = -1;
    paddr_t phy_addr = 0;
    int32_t iso_idx = -1;
  11057a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
{
  11057e:	b083      	sub	sp, #12
    paddr_t phy_addr = 0;
  110580:	2300      	movs	r3, #0
    int32_t iso_idx = -1;
  110582:	aa02      	add	r2, sp, #8
{
  110584:	4605      	mov	r5, r0
    vaddr_t base = 0x0;
    rstgen_instance_t *instance = NULL;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110586:	4608      	mov	r0, r1
    int32_t iso_idx = -1;
  110588:	f842 4d04 	str.w	r4, [r2, #-4]!
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  11058c:	4669      	mov	r1, r13
    paddr_t phy_addr = 0;
  11058e:	9300      	str	r3, [sp, #0]
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  110590:	f7ff fed0 	bl	110334 <res_get_info_by_id>
  110594:	b948      	cbnz	r0, 1105aa <hal_rstgen_iso_status+0x32>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((iso_idx > 0) && instance->controllerTable->iso_status) {
  110596:	9901      	ldr	r1, [sp, #4]
  110598:	2900      	cmp	r1, #0
  11059a:	dd06      	ble.n	1105aa <hal_rstgen_iso_status+0x32>
  11059c:	6aab      	ldr	r3, [r5, #40]	; 0x28
  11059e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  1105a0:	b11b      	cbz	r3, 1105aa <hal_rstgen_iso_status+0x32>
        ret = instance->controllerTable->iso_status(
  1105a2:	9800      	ldr	r0, [sp, #0]
  1105a4:	4798      	blx	r3
                  (vaddr_t)base, (uint32_t)iso_idx);
    }

    return ret;
}
  1105a6:	b003      	add	sp, #12
  1105a8:	bd30      	pop	{r4, r5, r15}
        return ret;
  1105aa:	4620      	mov	r0, r4
}
  1105ac:	b003      	add	sp, #12
  1105ae:	bd30      	pop	{r4, r5, r15}

001105b0 <hal_rstgen_core_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_core_reset(void *handle, uint32_t res_glb_idx)
{
  1105b0:	b510      	push	{r4, r14}
  1105b2:	4604      	mov	r4, r0
  1105b4:	b082      	sub	sp, #8
    paddr_t phy_addr;
    int32_t core_idx;
    vaddr_t base;
    bool ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &core_idx)) {
  1105b6:	4608      	mov	r0, r1
  1105b8:	aa01      	add	r2, sp, #4
  1105ba:	4669      	mov	r1, r13
  1105bc:	f7ff feba 	bl	110334 <res_get_info_by_id>
  1105c0:	b948      	cbnz	r0, 1105d6 <hal_rstgen_core_reset+0x26>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((core_idx > 0) && instance->controllerTable->core_reset) {
  1105c2:	9901      	ldr	r1, [sp, #4]
  1105c4:	2900      	cmp	r1, #0
  1105c6:	dd04      	ble.n	1105d2 <hal_rstgen_core_reset+0x22>
  1105c8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1105ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  1105cc:	b133      	cbz	r3, 1105dc <hal_rstgen_core_reset+0x2c>
        ret = instance->controllerTable->core_reset(
  1105ce:	9800      	ldr	r0, [sp, #0]
  1105d0:	4798      	blx	r3
                  (vaddr_t)base, (uint32_t)core_idx);
    }

    return ret;
}
  1105d2:	b002      	add	sp, #8
  1105d4:	bd10      	pop	{r4, r15}
        return ret;
  1105d6:	2000      	movs	r0, #0
}
  1105d8:	b002      	add	sp, #8
  1105da:	bd10      	pop	{r4, r15}
        return ret;
  1105dc:	4618      	mov	r0, r3
  1105de:	e7f8      	b.n	1105d2 <hal_rstgen_core_reset+0x22>

001105e0 <hal_rstgen_core_ctl>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_core_ctl(void *handle, uint32_t res_glb_idx, bool release)
{
  1105e0:	b530      	push	{r4, r5, r14}
  1105e2:	4604      	mov	r4, r0
  1105e4:	b083      	sub	sp, #12
  1105e6:	4615      	mov	r5, r2
    paddr_t phy_addr;
    int32_t core_idx;
    vaddr_t base;
    bool ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &core_idx)) {
  1105e8:	4608      	mov	r0, r1
  1105ea:	4669      	mov	r1, r13
  1105ec:	aa01      	add	r2, sp, #4
  1105ee:	f7ff fea1 	bl	110334 <res_get_info_by_id>
  1105f2:	b950      	cbnz	r0, 11060a <hal_rstgen_core_ctl+0x2a>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((core_idx > 0) && instance->controllerTable->core_ctl) {
  1105f4:	9901      	ldr	r1, [sp, #4]
  1105f6:	2900      	cmp	r1, #0
  1105f8:	dd05      	ble.n	110606 <hal_rstgen_core_ctl+0x26>
  1105fa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1105fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1105fe:	b13b      	cbz	r3, 110610 <hal_rstgen_core_ctl+0x30>
        ret = instance->controllerTable->core_ctl(
  110600:	9800      	ldr	r0, [sp, #0]
  110602:	462a      	mov	r2, r5
  110604:	4798      	blx	r3
                  (vaddr_t)base, (uint32_t)core_idx, release);
    }

    return ret;
}
  110606:	b003      	add	sp, #12
  110608:	bd30      	pop	{r4, r5, r15}
        return ret;
  11060a:	2000      	movs	r0, #0
}
  11060c:	b003      	add	sp, #12
  11060e:	bd30      	pop	{r4, r5, r15}
        return ret;
  110610:	4618      	mov	r0, r3
  110612:	e7f8      	b.n	110606 <hal_rstgen_core_ctl+0x26>

00110614 <hal_rstgen_module_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_module_reset(void *handle, uint32_t res_glb_idx)
{
  110614:	b530      	push	{r4, r5, r14}
  110616:	4604      	mov	r4, r0
  110618:	b083      	sub	sp, #12
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    bool        ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
  11061a:	4608      	mov	r0, r1
  11061c:	aa01      	add	r2, sp, #4
  11061e:	4669      	mov	r1, r13
  110620:	f7ff fe88 	bl	110334 <res_get_info_by_id>
  110624:	b988      	cbnz	r0, 11064a <hal_rstgen_module_reset+0x36>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_ctl) {
  110626:	9901      	ldr	r1, [sp, #4]
  110628:	2900      	cmp	r1, #0
  11062a:	dd0c      	ble.n	110646 <hal_rstgen_module_reset+0x32>
  11062c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  11062e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  110630:	b173      	cbz	r3, 110650 <hal_rstgen_module_reset+0x3c>
    base = (vaddr_t)_ioaddr(phy_addr);
  110632:	9d00      	ldr	r5, [sp, #0]
        ret = instance->controllerTable->module_ctl(
  110634:	4602      	mov	r2, r0
  110636:	4628      	mov	r0, r5
  110638:	4798      	blx	r3
                  base, (uint32_t)module_idx, false);
        ret = instance->controllerTable->module_ctl(
  11063a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  11063c:	4628      	mov	r0, r5
  11063e:	2201      	movs	r2, #1
  110640:	9901      	ldr	r1, [sp, #4]
  110642:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  110644:	4798      	blx	r3
                  base, (uint32_t)module_idx, true);
    }

    return ret;
}
  110646:	b003      	add	sp, #12
  110648:	bd30      	pop	{r4, r5, r15}
        return ret;
  11064a:	2000      	movs	r0, #0
}
  11064c:	b003      	add	sp, #12
  11064e:	bd30      	pop	{r4, r5, r15}
        return ret;
  110650:	4618      	mov	r0, r3
  110652:	e7f8      	b.n	110646 <hal_rstgen_module_reset+0x32>

00110654 <hal_rstgen_module_ctl>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_module_ctl(void *handle, uint32_t res_glb_idx, bool release)
{
  110654:	b530      	push	{r4, r5, r14}
  110656:	4604      	mov	r4, r0
  110658:	b083      	sub	sp, #12
  11065a:	4615      	mov	r5, r2
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    bool        ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
  11065c:	4608      	mov	r0, r1
  11065e:	4669      	mov	r1, r13
  110660:	aa01      	add	r2, sp, #4
  110662:	f7ff fe67 	bl	110334 <res_get_info_by_id>
  110666:	b950      	cbnz	r0, 11067e <hal_rstgen_module_ctl+0x2a>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_ctl) {
  110668:	9901      	ldr	r1, [sp, #4]
  11066a:	2900      	cmp	r1, #0
  11066c:	dd05      	ble.n	11067a <hal_rstgen_module_ctl+0x26>
  11066e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  110670:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  110672:	b13b      	cbz	r3, 110684 <hal_rstgen_module_ctl+0x30>
        ret = instance->controllerTable->module_ctl(
  110674:	9800      	ldr	r0, [sp, #0]
  110676:	462a      	mov	r2, r5
  110678:	4798      	blx	r3
                  base, (uint32_t)module_idx, release);
    }

    return ret;
}
  11067a:	b003      	add	sp, #12
  11067c:	bd30      	pop	{r4, r5, r15}
        return ret;
  11067e:	2000      	movs	r0, #0
}
  110680:	b003      	add	sp, #12
  110682:	bd30      	pop	{r4, r5, r15}
        return ret;
  110684:	4618      	mov	r0, r3
  110686:	e7f8      	b.n	11067a <hal_rstgen_module_ctl+0x26>

00110688 <hal_rstgen_module_status>:
//! \return 0, the module reset hasn't been released.
//! \return 0xffffffff, invaled module id.
//
//*****************************************************************************
uint32_t hal_rstgen_module_status(void *handle, uint32_t res_glb_idx)
{
  110688:	b510      	push	{r4, r14}
  11068a:	4604      	mov	r4, r0
  11068c:	b082      	sub	sp, #8
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    uint32_t    ret = -1;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
  11068e:	4608      	mov	r0, r1
  110690:	aa01      	add	r2, sp, #4
  110692:	4669      	mov	r1, r13
  110694:	f7ff fe4e 	bl	110334 <res_get_info_by_id>
  110698:	b948      	cbnz	r0, 1106ae <hal_rstgen_module_status+0x26>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_reset_status) {
  11069a:	9901      	ldr	r1, [sp, #4]
  11069c:	2900      	cmp	r1, #0
  11069e:	dd06      	ble.n	1106ae <hal_rstgen_module_status+0x26>
  1106a0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1106a2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  1106a4:	b11b      	cbz	r3, 1106ae <hal_rstgen_module_status+0x26>
        ret = instance->controllerTable->module_reset_status(
  1106a6:	9800      	ldr	r0, [sp, #0]
  1106a8:	4798      	blx	r3
                  base, (uint32_t)module_idx);
    }

    return ret;
}
  1106aa:	b002      	add	sp, #8
  1106ac:	bd10      	pop	{r4, r15}
        return ret;
  1106ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1106b2:	b002      	add	sp, #8
  1106b4:	bd10      	pop	{r4, r15}
  1106b6:	bf00      	nop

001106b8 <hal_rstgen_core_status>:
//! \return 0, the core reset hasn't been released.
//! \return 0xffffffff, invaled module id.
//
//*****************************************************************************
uint32_t hal_rstgen_core_status(void *handle, uint32_t res_glb_idx)
{
  1106b8:	b510      	push	{r4, r14}
  1106ba:	4604      	mov	r4, r0
  1106bc:	b082      	sub	sp, #8
    paddr_t     phy_addr;
    int32_t     core_idx;
    vaddr_t     base;
    uint32_t    ret = -1;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &core_idx)) {
  1106be:	4608      	mov	r0, r1
  1106c0:	aa01      	add	r2, sp, #4
  1106c2:	4669      	mov	r1, r13
  1106c4:	f7ff fe36 	bl	110334 <res_get_info_by_id>
  1106c8:	b948      	cbnz	r0, 1106de <hal_rstgen_core_status+0x26>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (core_idx > 0 && instance->controllerTable->core_reset_status) {
  1106ca:	9901      	ldr	r1, [sp, #4]
  1106cc:	2900      	cmp	r1, #0
  1106ce:	dd06      	ble.n	1106de <hal_rstgen_core_status+0x26>
  1106d0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1106d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  1106d4:	b11b      	cbz	r3, 1106de <hal_rstgen_core_status+0x26>
        ret = instance->controllerTable->core_reset_status(
  1106d6:	9800      	ldr	r0, [sp, #0]
  1106d8:	4798      	blx	r3
                  base, (uint32_t)core_idx);
    }

    return ret;
}
  1106da:	b002      	add	sp, #8
  1106dc:	bd10      	pop	{r4, r15}
        return ret;
  1106de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1106e2:	b002      	add	sp, #8
  1106e4:	bd10      	pop	{r4, r15}
  1106e6:	bf00      	nop

001106e8 <hal_scr_create_handle>:

    return (scr_handle_t)0;
    #else
    return (scr_handle_t)scr_signal;
    #endif
}
  1106e8:	4770      	bx	r14
  1106ea:	bf00      	nop

001106ec <hal_scr_delete_handle>:

void hal_scr_delete_handle(scr_handle_t handle)
{
    ASSERT(handle);
  1106ec:	ea50 0301 	orrs.w	r3, r0, r1
  1106f0:	d000      	beq.n	1106f4 <hal_scr_delete_handle+0x8>
  1106f2:	4770      	bx	r14
  1106f4:	f647 4370 	movw	r3, #31856	; 0x7c70
  1106f8:	f64e 4270 	movw	r2, #60528	; 0xec70
{
  1106fc:	b500      	push	{r14}
    ASSERT(handle);
  1106fe:	f2c0 0311 	movt	r3, #17
  110702:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  110706:	b083      	sub	sp, #12
  110708:	4670      	mov	r0, r14
    ASSERT(handle);
  11070a:	f2c0 0211 	movt	r2, #17
  11070e:	9300      	str	r3, [sp, #0]
  110710:	f2c0 0111 	movt	r1, #17
  110714:	2357      	movs	r3, #87	; 0x57
  110716:	f003 f841 	bl	11379c <_panic>
  11071a:	bf00      	nop

0011071c <hal_scr_get>:
}

uint32_t hal_scr_get(scr_handle_t handle)
{
    ASSERT(handle);
  11071c:	ea50 0301 	orrs.w	r3, r0, r1
  110720:	d001      	beq.n	110726 <hal_scr_get+0xa>
    return scr_get((scr_signal_t)handle);
  110722:	f7f9 b829 	b.w	109778 <scr_get>
    ASSERT(handle);
  110726:	f647 4370 	movw	r3, #31856	; 0x7c70
  11072a:	f64e 4270 	movw	r2, #60528	; 0xec70
{
  11072e:	b500      	push	{r14}
    ASSERT(handle);
  110730:	f2c0 0311 	movt	r3, #17
  110734:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  110738:	b083      	sub	sp, #12
  11073a:	4670      	mov	r0, r14
    ASSERT(handle);
  11073c:	f2c0 0211 	movt	r2, #17
  110740:	9300      	str	r3, [sp, #0]
  110742:	f2c0 0111 	movt	r1, #17
  110746:	235c      	movs	r3, #92	; 0x5c
  110748:	f003 f828 	bl	11379c <_panic>

0011074c <hal_scr_set>:
}

bool hal_scr_set(scr_handle_t handle, uint32_t value)
{
    ASSERT(handle);
  11074c:	ea50 0301 	orrs.w	r3, r0, r1
  110750:	d001      	beq.n	110756 <hal_scr_set+0xa>
    return scr_set((scr_signal_t)handle, value);
  110752:	f7f9 b8a7 	b.w	1098a4 <scr_set>
    ASSERT(handle);
  110756:	f647 4370 	movw	r3, #31856	; 0x7c70
  11075a:	f64e 4270 	movw	r2, #60528	; 0xec70
{
  11075e:	b500      	push	{r14}
    ASSERT(handle);
  110760:	f2c0 0311 	movt	r3, #17
  110764:	f647 4134 	movw	r1, #31796	; 0x7c34
{
  110768:	b083      	sub	sp, #12
  11076a:	4670      	mov	r0, r14
    ASSERT(handle);
  11076c:	f2c0 0211 	movt	r2, #17
  110770:	9300      	str	r3, [sp, #0]
  110772:	f2c0 0111 	movt	r1, #17
  110776:	2362      	movs	r3, #98	; 0x62
  110778:	f003 f810 	bl	11379c <_panic>

0011077c <hal_timer_func_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_timer_func_irq_handle(void *arg)
{
    timer_instance_t *instance = (timer_instance_t *)arg;

    if (instance == NULL)
  11077c:	b120      	cbz	r0, 110788 <hal_timer_func_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return timer_drv_func_irq_handle(instance->timer,
  11077e:	f100 0118 	add.w	r1, r0, #24
  110782:	6940      	ldr	r0, [r0, #20]
  110784:	f7f9 b9a4 	b.w	109ad0 <timer_drv_func_irq_handle>
                                     &(instance->drv_context));
}
  110788:	4770      	bx	r14
  11078a:	bf00      	nop

0011078c <hal_timer_ovf_irq_handle>:
    if (instance == NULL)
  11078c:	b120      	cbz	r0, 110798 <hal_timer_ovf_irq_handle+0xc>
    return timer_drv_ovf_irq_handle(instance->timer, &(instance->drv_context));
  11078e:	f100 0118 	add.w	r1, r0, #24
  110792:	6940      	ldr	r0, [r0, #20]
  110794:	f7f9 b96e 	b.w	109a74 <timer_drv_ovf_irq_handle>
}
  110798:	4770      	bx	r14
  11079a:	bf00      	nop

0011079c <hal_timer_creat_handle>:
{
  11079c:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  1107a0:	f240 6568 	movw	r5, #1640	; 0x668
{
  1107a4:	b082      	sub	sp, #8
  1107a6:	4606      	mov	r6, r0
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  1107a8:	f2c0 0513 	movt	r5, #19
  1107ac:	682b      	ldr	r3, [r5, #0]
  1107ae:	b10b      	cbz	r3, 1107b4 <hal_timer_creat_handle+0x18>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  1107b0:	2300      	movs	r3, #0
  1107b2:	602b      	str	r3, [r5, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1107b4:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1107b8:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  1107bc:	d161      	bne.n	110882 <hal_timer_creat_handle+0xe6>
    __asm__ volatile("cpsid i");
  1107be:	b672      	cpsid	i
    *lock = 1;
  1107c0:	2701      	movs	r7, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  1107c2:	4608      	mov	r0, r1
  1107c4:	4669      	mov	r1, r13
  1107c6:	aa01      	add	r2, sp, #4
  1107c8:	602f      	str	r7, [r5, #0]
  1107ca:	f7ff fdb3 	bl	110334 <res_get_info_by_id>
  1107ce:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1107d0:	bfa8      	it	ge
  1107d2:	46be      	movge	r14, r7
  1107d4:	db67      	blt.n	1108a6 <hal_timer_creat_handle+0x10a>
  1107d6:	f240 2ca8 	movw	r12, #680	; 0x2a8
            if (!g_timer_instance[index].occupied
  1107da:	f04f 0800 	mov.w	r8, #0
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  1107de:	9c00      	ldr	r4, [sp, #0]
  1107e0:	f2c0 0c13 	movt	r12, #19
  1107e4:	4667      	mov	r7, r12
            if (!g_timer_instance[index].occupied
  1107e6:	f2cf 0818 	movt	r8, #61464	; 0xf018
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  1107ea:	2000      	movs	r0, #0
            if (!g_timer_instance[index].occupied
  1107ec:	783b      	ldrb	r3, [r7, #0]
  1107ee:	bbbb      	cbnz	r3, 110860 <hal_timer_creat_handle+0xc4>
  1107f0:	4a30      	ldr	r2, [pc, #192]	; (1108b4 <hal_timer_creat_handle+0x118>)
  1107f2:	4641      	mov	r1, r8
        if (timer_addr2irq_table[i].addr == addr) {
  1107f4:	428c      	cmp	r4, r1
  1107f6:	f102 020c 	add.w	r2, r2, #12
  1107fa:	d007      	beq.n	11080c <hal_timer_creat_handle+0x70>
    for (i = 0; i < DEFAULT_TIMER_MAX_NUM; i++) {
  1107fc:	3301      	adds	r3, #1
  1107fe:	2b08      	cmp	r3, #8
  110800:	d02e      	beq.n	110860 <hal_timer_creat_handle+0xc4>
  110802:	f852 1c0c 	ldr.w	r1, [r2, #-12]
  110806:	320c      	adds	r2, #12
        if (timer_addr2irq_table[i].addr == addr) {
  110808:	428c      	cmp	r4, r1
  11080a:	d1f7      	bne.n	1107fc <hal_timer_creat_handle+0x60>
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  11080c:	f64e 4288 	movw	r2, #60552	; 0xec88
  110810:	eb03 0343 	add.w	r3, r3, r3, lsl #1
                g_timer_instance[index].occupied = true;
  110814:	ea4f 1800 	mov.w	r8, r0, lsl #4
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  110818:	f2c0 0211 	movt	r2, #17
                g_timer_instance[index].occupied = true;
  11081c:	eba8 0700 	sub.w	r7, r8, r0
  110820:	f04f 0b01 	mov.w	r11, #1
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  110824:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *lock = 0;
  110828:	2200      	movs	r2, #0
                g_timer_instance[index].occupied = true;
  11082a:	00ff      	lsls	r7, r7, #3
  11082c:	eb0c 0907 	add.w	r9, r12, r7
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  110830:	6859      	ldr	r1, [r3, #4]
  110832:	f8c9 1004 	str.w	r1, [r9, #4]
            *fun_irq_num = timer_addr2irq_table[i].fun_irq_num;
  110836:	6899      	ldr	r1, [r3, #8]
                g_timer_instance[index].timer = (sdrv_timer_t *)(phy_addr);
  110838:	f8c9 4014 	str.w	r4, [r9, #20]
                g_timer_instance[index].fun_irq_num = fun_irq_num;
  11083c:	f8c9 1008 	str.w	r1, [r9, #8]
                g_timer_instance[index].occupied = true;
  110840:	f80c b007 	strb.w	r11, [r12, r7]
  110844:	602a      	str	r2, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  110846:	f1be 0f00 	cmp.w	r14, #0
  11084a:	d000      	beq.n	11084e <hal_timer_creat_handle+0xb2>
    __asm__ volatile("cpsie i");
  11084c:	b662      	cpsie	i
                *instance = &g_timer_instance[index];
  11084e:	eba8 0300 	sub.w	r3, r8, r0
    return true;
  110852:	2001      	movs	r0, #1
                *instance = &g_timer_instance[index];
  110854:	eb0c 03c3 	add.w	r3, r12, r3, lsl #3
    *handle = instance;
  110858:	6033      	str	r3, [r6, #0]
}
  11085a:	b002      	add	sp, #8
  11085c:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
        for (index = 0; index < DEFAULT_TIMER_MAX_NUM; index++) {
  110860:	3001      	adds	r0, #1
  110862:	2808      	cmp	r0, #8
  110864:	f107 0778 	add.w	r7, r7, #120	; 0x78
  110868:	d1c0      	bne.n	1107ec <hal_timer_creat_handle+0x50>
    *lock = 0;
  11086a:	2300      	movs	r3, #0
  11086c:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  11086e:	f1be 0f00 	cmp.w	r14, #0
  110872:	d000      	beq.n	110876 <hal_timer_creat_handle+0xda>
  110874:	b662      	cpsie	i
        *handle = NULL;
  110876:	2300      	movs	r3, #0
        return false;
  110878:	4618      	mov	r0, r3
        *handle = NULL;
  11087a:	6033      	str	r3, [r6, #0]
}
  11087c:	b002      	add	sp, #8
  11087e:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
    *lock = 1;
  110882:	2301      	movs	r3, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  110884:	4608      	mov	r0, r1
  110886:	4669      	mov	r1, r13
  110888:	aa01      	add	r2, sp, #4
  11088a:	602b      	str	r3, [r5, #0]
  11088c:	f7ff fd52 	bl	110334 <res_get_info_by_id>
  110890:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  110892:	bfa8      	it	ge
  110894:	f04f 0e00 	movge.w	r14, #0
  110898:	da9d      	bge.n	1107d6 <hal_timer_creat_handle+0x3a>
    *lock = 0;
  11089a:	2300      	movs	r3, #0
  11089c:	602b      	str	r3, [r5, #0]
        *handle = NULL;
  11089e:	2300      	movs	r3, #0
        return false;
  1108a0:	4618      	mov	r0, r3
        *handle = NULL;
  1108a2:	6033      	str	r3, [r6, #0]
  1108a4:	e7ea      	b.n	11087c <hal_timer_creat_handle+0xe0>
  1108a6:	602c      	str	r4, [r5, #0]
  1108a8:	b662      	cpsie	i
  1108aa:	2300      	movs	r3, #0
        return false;
  1108ac:	4618      	mov	r0, r3
        *handle = NULL;
  1108ae:	6033      	str	r3, [r6, #0]
  1108b0:	e7e4      	b.n	11087c <hal_timer_creat_handle+0xe0>
  1108b2:	bf00      	nop
  1108b4:	0011ec94 	.word	0x0011ec94

001108b8 <hal_timer_global_init>:
{
  1108b8:	b570      	push	{r4, r5, r6, r14}
  1108ba:	460c      	mov	r4, r1
  1108bc:	4605      	mov	r5, r0
    sdrv_timer_t *timer = instance->timer;
  1108be:	6946      	ldr	r6, [r0, #20]
    timer_drv_clk_init(timer, cfg->clk_sel, cfg->clk_div);
  1108c0:	688a      	ldr	r2, [r1, #8]
  1108c2:	4630      	mov	r0, r6
  1108c4:	6809      	ldr	r1, [r1, #0]
  1108c6:	f7f9 f8b9 	bl	109a3c <timer_drv_clk_init>
    timer_drv_cascade_set(timer, cfg->cascade);
  1108ca:	4630      	mov	r0, r6
  1108cc:	7b21      	ldrb	r1, [r4, #12]
  1108ce:	f7f9 f8ab 	bl	109a28 <timer_drv_cascade_set>
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  1108d2:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  1108d6:	f644 51d3 	movw	r1, #19923	; 0x4dd3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  1108da:	f64d 6083 	movw	r0, #56963	; 0xde83
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  1108de:	3301      	adds	r3, #1
  1108e0:	f2c1 0162 	movt	r1, #4194	; 0x1062
  1108e4:	fbb2 f3f3 	udiv	r3, r2, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  1108e8:	f2c4 301b 	movt	r0, #17179	; 0x431b
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  1108ec:	fba1 2103 	umull	r2, r1, r1, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  1108f0:	fba0 2303 	umull	r2, r3, r0, r3
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  1108f4:	0989      	lsrs	r1, r1, #6
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  1108f6:	0c9b      	lsrs	r3, r3, #18
  1108f8:	e9c5 1303 	strd	r1, r3, [r5, #12]
}
  1108fc:	bd70      	pop	{r4, r5, r6, r15}
  1108fe:	bf00      	nop

00110900 <hal_timer_ovf_init>:
{
  110900:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  110902:	4615      	mov	r5, r2
  110904:	460e      	mov	r6, r1
    sdrv_timer_t *timer = instance->timer;
  110906:	6947      	ldr	r7, [r0, #20]
{
  110908:	4604      	mov	r4, r0
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  11090a:	6892      	ldr	r2, [r2, #8]
  11090c:	4638      	mov	r0, r7
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  11090e:	4434      	add	r4, r6
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  110910:	f7f9 f872 	bl	1099f8 <timer_drv_ovf_set>
    timer_drv_cntr_set(timer, (timer_drv_sub_t)sub_cntr, cfg->cnt_val);
  110914:	4638      	mov	r0, r7
  110916:	4631      	mov	r1, r6
  110918:	686a      	ldr	r2, [r5, #4]
  11091a:	f7f9 f82d 	bl	109978 <timer_drv_cntr_set>
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  11091e:	782b      	ldrb	r3, [r5, #0]
  110920:	7623      	strb	r3, [r4, #24]
}
  110922:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00110924 <hal_timer_int_src_enable>:
    if (handle == NULL)
  110924:	b158      	cbz	r0, 11093e <hal_timer_int_src_enable+0x1a>
{
  110926:	b538      	push	{r3, r4, r5, r14}
  110928:	4604      	mov	r4, r0
  11092a:	460d      	mov	r5, r1
    timer_drv_int_sta_enable(instance->timer, int_src);
  11092c:	6940      	ldr	r0, [r0, #20]
  11092e:	f7f9 f891 	bl	109a54 <timer_drv_int_sta_enable>
    timer_drv_int_sig_enable(instance->timer, int_src);
  110932:	4629      	mov	r1, r5
  110934:	6960      	ldr	r0, [r4, #20]
}
  110936:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_enable(instance->timer, int_src);
  11093a:	f7f9 b893 	b.w	109a64 <timer_drv_int_sig_enable>
  11093e:	4770      	bx	r14

00110940 <hal_timer_int_cbk_register>:

void hal_timer_int_cbk_register(void *handle, hal_timer_int_src_t int_src,
                                hal_timer_int_cbk cbk)
{
    if (handle == NULL)
  110940:	2800      	cmp	r0, #0
  110942:	d047      	beq.n	1109d4 <hal_timer_int_cbk_register+0x94>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;

    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
            && (int_src <= HAL_TIMER_CNT_G1_OVF_INT_SRC)) {
  110944:	f1a1 0308 	sub.w	r3, r1, #8
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  110948:	2b01      	cmp	r3, #1
{
  11094a:	b510      	push	{r4, r14}
  11094c:	4604      	mov	r4, r0
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  11094e:	d917      	bls.n	110980 <hal_timer_int_cbk_register+0x40>
                                 handle);
            unmask_interrupt(instance->ovf_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
             && (int_src <= HAL_TIMER_CNT_LD_OVF_INT_SRC)) {
  110950:	f1a1 030a 	sub.w	r3, r1, #10
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
  110954:	2b03      	cmp	r3, #3
  110956:	d90d      	bls.n	110974 <hal_timer_int_cbk_register+0x34>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CPT_A_INT_SRC)
  110958:	2903      	cmp	r1, #3
  11095a:	d934      	bls.n	1109c6 <hal_timer_int_cbk_register+0x86>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
             && (int_src <= HAL_TIMER_CMP_D_INT_SRC)) {
  11095c:	1f0b      	subs	r3, r1, #4
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
  11095e:	2b03      	cmp	r3, #3
  110960:	d91f      	bls.n	1109a2 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_UNDERRUN_INT_SRC)) {
  110962:	f1a1 0310 	sub.w	r3, r1, #16
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
  110966:	2b03      	cmp	r3, #3
  110968:	d91b      	bls.n	1109a2 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_OVERRUN_INT_SRC)) {
  11096a:	f1a1 0314 	sub.w	r3, r1, #20
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
  11096e:	2b03      	cmp	r3, #3
  110970:	d805      	bhi.n	11097e <hal_timer_int_cbk_register+0x3e>
        instance->drv_context.local_overrun_cbk[int_src -
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  110972:	3102      	adds	r1, #2

        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  110974:	68a0      	ldr	r0, [r4, #8]
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  110976:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  11097a:	1c43      	adds	r3, r0, #1
  11097c:	d117      	bne.n	1109ae <hal_timer_int_cbk_register+0x6e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
}
  11097e:	bd10      	pop	{r4, r15}
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  110980:	6840      	ldr	r0, [r0, #4]
                                                     HAL_TIMER_CNT_G0_OVF_INT_SRC] = cbk;
  110982:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  110986:	1c43      	adds	r3, r0, #1
  110988:	d0f9      	beq.n	11097e <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->ovf_irq_num, hal_timer_ovf_irq_handle,
  11098a:	f240 718d 	movw	r1, #1933	; 0x78d
  11098e:	4622      	mov	r2, r4
  110990:	f2c0 0111 	movt	r1, #17
  110994:	f7ef febc 	bl	100710 <register_int_handler>
            unmask_interrupt(instance->ovf_irq_num);
  110998:	6860      	ldr	r0, [r4, #4]
}
  11099a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->ovf_irq_num);
  11099e:	f7ef bf15 	b.w	1007cc <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1109a2:	68a0      	ldr	r0, [r4, #8]
                        HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC] = cbk;
  1109a4:	310a      	adds	r1, #10
  1109a6:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1109aa:	1c42      	adds	r2, r0, #1
  1109ac:	d0e7      	beq.n	11097e <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
  1109ae:	f240 717d 	movw	r1, #1917	; 0x77d
  1109b2:	4622      	mov	r2, r4
  1109b4:	f2c0 0111 	movt	r1, #17
  1109b8:	f7ef feaa 	bl	100710 <register_int_handler>
            unmask_interrupt(instance->fun_irq_num);
  1109bc:	68a0      	ldr	r0, [r4, #8]
}
  1109be:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->fun_irq_num);
  1109c2:	f7ef bf03 	b.w	1007cc <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1109c6:	6880      	ldr	r0, [r0, #8]
        instance->drv_context.local_cpt_cbk[int_src - HAL_TIMER_CPT_A_INT_SRC] =
  1109c8:	3112      	adds	r1, #18
  1109ca:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1109ce:	1c41      	adds	r1, r0, #1
  1109d0:	d1ed      	bne.n	1109ae <hal_timer_int_cbk_register+0x6e>
}
  1109d2:	bd10      	pop	{r4, r15}
  1109d4:	4770      	bx	r14
  1109d6:	bf00      	nop

001109d8 <hal_timer_glb_cntr_get>:
{
    uint32_t g0_val, g1_val, g0_new;
    spin_lock_saved_state_t state;
    timer_instance_t *instance = (timer_instance_t *)handle;

    if (handle == NULL)
  1109d8:	b318      	cbz	r0, 110a22 <hal_timer_glb_cntr_get+0x4a>
{
  1109da:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1109dc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1109e0:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1109e2:	bf48      	it	mi
  1109e4:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1109e6:	d519      	bpl.n	110a1c <hal_timer_glb_cntr_get+0x44>
  1109e8:	4604      	mov	r4, r0
        return 0;

    arch_interrupt_save(&state, SPIN_LOCK_FLAG_INTERRUPTS);

    g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  1109ea:	2100      	movs	r1, #0
  1109ec:	6940      	ldr	r0, [r0, #20]
  1109ee:	f7f8 ffeb 	bl	1099c8 <timer_drv_cntr_get>
  1109f2:	4605      	mov	r5, r0
  1109f4:	e000      	b.n	1109f8 <hal_timer_glb_cntr_get+0x20>
  1109f6:	4605      	mov	r5, r0
    do {
        g0_val = g0_new;
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  1109f8:	6960      	ldr	r0, [r4, #20]
  1109fa:	2101      	movs	r1, #1
  1109fc:	f7f8 ffe4 	bl	1099c8 <timer_drv_cntr_get>
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  110a00:	2100      	movs	r1, #0
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  110a02:	4606      	mov	r6, r0
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  110a04:	6960      	ldr	r0, [r4, #20]
  110a06:	f7f8 ffdf 	bl	1099c8 <timer_drv_cntr_get>
    } while (g0_val > g0_new);
  110a0a:	4285      	cmp	r5, r0
  110a0c:	d8f3      	bhi.n	1109f6 <hal_timer_glb_cntr_get+0x1e>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  110a0e:	b107      	cbz	r7, 110a12 <hal_timer_glb_cntr_get+0x3a>
    __asm__ volatile("cpsie i");
  110a10:	b662      	cpsie	i

    arch_interrupt_restore(state, SPIN_LOCK_FLAG_INTERRUPTS);

    return ((uint64_t)g0_val | (((uint64_t)g1_val) << 32U));
  110a12:	2300      	movs	r3, #0
  110a14:	4631      	mov	r1, r6
  110a16:	ea43 0005 	orr.w	r0, r3, r5
}
  110a1a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
  110a1c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  110a1e:	2701      	movs	r7, #1
  110a20:	e7e2      	b.n	1109e8 <hal_timer_glb_cntr_get+0x10>
        return 0;
  110a22:	2000      	movs	r0, #0
  110a24:	2100      	movs	r1, #0
}
  110a26:	4770      	bx	r14

00110a28 <hal_uart_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_uart_irq_handle(void *arg)
{
    uart_instance_t *instance = (uart_instance_t *)arg;

    if (instance == NULL)
  110a28:	b120      	cbz	r0, 110a34 <hal_uart_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return uart_drv_irq_handle(instance->uartc, &(instance->drv_context));
  110a2a:	f100 0110 	add.w	r1, r0, #16
  110a2e:	68c0      	ldr	r0, [r0, #12]
  110a30:	f7f9 baaa 	b.w	109f88 <uart_drv_irq_handle>
}
  110a34:	4770      	bx	r14
  110a36:	bf00      	nop

00110a38 <hal_uart_creat_handle>:
{
  110a38:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  110a3c:	4605      	mov	r5, r0
  110a3e:	b083      	sub	sp, #12
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  110a40:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  110a44:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  110a48:	d16a      	bne.n	110b20 <hal_uart_creat_handle+0xe8>
    __asm__ volatile("cpsid i");
  110a4a:	b672      	cpsid	i
    *lock = 1;
  110a4c:	f640 17ac 	movw	r7, #2476	; 0x9ac
  110a50:	2601      	movs	r6, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  110a52:	4608      	mov	r0, r1
  110a54:	f2c0 0713 	movt	r7, #19
  110a58:	4669      	mov	r1, r13
  110a5a:	aa01      	add	r2, sp, #4
  110a5c:	603e      	str	r6, [r7, #0]
  110a5e:	f7ff fc69 	bl	110334 <res_get_info_by_id>
  110a62:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  110a64:	bfa8      	it	ge
  110a66:	46b0      	movge	r8, r6
  110a68:	db6d      	blt.n	110b46 <hal_uart_creat_handle+0x10e>
  110a6a:	f240 6e6c 	movw	r14, #1644	; 0x66c
            if (!g_uart_instance[index].occupied
  110a6e:	f04f 0900 	mov.w	r9, #0
  110a72:	f64e 40e8 	movw	r0, #60648	; 0xece8
  110a76:	f2c0 0e13 	movt	r14, #19
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  110a7a:	9e00      	ldr	r6, [sp, #0]
  110a7c:	4674      	mov	r4, r14
            if (!g_uart_instance[index].occupied
  110a7e:	f2cf 090f 	movt	r9, #61455	; 0xf00f
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  110a82:	f04f 0c00 	mov.w	r12, #0
  110a86:	f2c0 0011 	movt	r0, #17
            if (!g_uart_instance[index].occupied
  110a8a:	7822      	ldrb	r2, [r4, #0]
  110a8c:	bbaa      	cbnz	r2, 110afa <hal_uart_creat_handle+0xc2>
  110a8e:	4649      	mov	r1, r9
  110a90:	e004      	b.n	110a9c <hal_uart_creat_handle+0x64>
  110a92:	461a      	mov	r2, r3
    for (i = 0; i < DEFAULT_UART_MAX_NUM; i++) {
  110a94:	2b10      	cmp	r3, #16
  110a96:	d030      	beq.n	110afa <hal_uart_creat_handle+0xc2>
  110a98:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
        if (uart_addr2irq_table[i].addr == addr) {
  110a9c:	428e      	cmp	r6, r1
  110a9e:	f102 0301 	add.w	r3, r2, #1
  110aa2:	d1f6      	bne.n	110a92 <hal_uart_creat_handle+0x5a>
            *irq_num = uart_addr2irq_table[i].irq_num;
  110aa4:	f64e 49e8 	movw	r9, #60648	; 0xece8
                g_uart_instance[index].occupied = true;
  110aa8:	ea4f 004c 	mov.w	r0, r12, lsl #1
  110aac:	eb00 010c 	add.w	r1, r0, r12
  110ab0:	2401      	movs	r4, #1
            *irq_num = uart_addr2irq_table[i].irq_num;
  110ab2:	f2c0 0911 	movt	r9, #17
                g_uart_instance[index].occupied = true;
  110ab6:	eb0c 0181 	add.w	r1, r12, r1, lsl #2
            *phy_num = i + 1;
  110aba:	9301      	str	r3, [sp, #4]
            *irq_num = uart_addr2irq_table[i].irq_num;
  110abc:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
                g_uart_instance[index].occupied = true;
  110ac0:	0089      	lsls	r1, r1, #2
  110ac2:	eb0e 0901 	add.w	r9, r14, r1
            *irq_num = uart_addr2irq_table[i].irq_num;
  110ac6:	6852      	ldr	r2, [r2, #4]
  110ac8:	f8c9 2008 	str.w	r2, [r9, #8]
    *lock = 0;
  110acc:	2200      	movs	r2, #0
                g_uart_instance[index].occupied = true;
  110ace:	f80e 4001 	strb.w	r4, [r14, r1]
                g_uart_instance[index].uartc = (DW_APB_UART_uart_TypeDef *)(phy_addr);
  110ad2:	f8c9 600c 	str.w	r6, [r9, #12]
                g_uart_instance[index].phy_num = phy_num;
  110ad6:	f8c9 3004 	str.w	r3, [r9, #4]
  110ada:	603a      	str	r2, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  110adc:	f1b8 0f00 	cmp.w	r8, #0
  110ae0:	d000      	beq.n	110ae4 <hal_uart_creat_handle+0xac>
    __asm__ volatile("cpsie i");
  110ae2:	b662      	cpsie	i
                *instance = &g_uart_instance[index];
  110ae4:	eb00 030c 	add.w	r3, r0, r12
    return true;
  110ae8:	2001      	movs	r0, #1
                *instance = &g_uart_instance[index];
  110aea:	eb0c 0383 	add.w	r3, r12, r3, lsl #2
  110aee:	eb0e 0383 	add.w	r3, r14, r3, lsl #2
    *handle = instance;
  110af2:	602b      	str	r3, [r5, #0]
}
  110af4:	b003      	add	sp, #12
  110af6:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        for (index = 0; index < DEFAULT_UART_MAX_NUM; index++) {
  110afa:	f10c 0c01 	add.w	r12, r12, #1
  110afe:	f1bc 0f10 	cmp.w	r12, #16
  110b02:	f104 0434 	add.w	r4, r4, #52	; 0x34
  110b06:	d1c0      	bne.n	110a8a <hal_uart_creat_handle+0x52>
    *lock = 0;
  110b08:	2300      	movs	r3, #0
  110b0a:	603b      	str	r3, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  110b0c:	f1b8 0f00 	cmp.w	r8, #0
  110b10:	d000      	beq.n	110b14 <hal_uart_creat_handle+0xdc>
  110b12:	b662      	cpsie	i
        *handle = NULL;
  110b14:	2300      	movs	r3, #0
        return false;
  110b16:	4618      	mov	r0, r3
        *handle = NULL;
  110b18:	602b      	str	r3, [r5, #0]
}
  110b1a:	b003      	add	sp, #12
  110b1c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    *lock = 1;
  110b20:	f640 17ac 	movw	r7, #2476	; 0x9ac
  110b24:	2301      	movs	r3, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  110b26:	4608      	mov	r0, r1
  110b28:	f2c0 0713 	movt	r7, #19
  110b2c:	4669      	mov	r1, r13
  110b2e:	aa01      	add	r2, sp, #4
  110b30:	603b      	str	r3, [r7, #0]
  110b32:	f7ff fbff 	bl	110334 <res_get_info_by_id>
  110b36:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  110b38:	bfa8      	it	ge
  110b3a:	f04f 0800 	movge.w	r8, #0
  110b3e:	da94      	bge.n	110a6a <hal_uart_creat_handle+0x32>
    *lock = 0;
  110b40:	2300      	movs	r3, #0
  110b42:	603b      	str	r3, [r7, #0]
  110b44:	e7e6      	b.n	110b14 <hal_uart_creat_handle+0xdc>
  110b46:	603c      	str	r4, [r7, #0]
  110b48:	b662      	cpsie	i
  110b4a:	e7e3      	b.n	110b14 <hal_uart_creat_handle+0xdc>

00110b4c <hal_uart_init>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   cfg         pointer of the hal confuration
 *****************************************************************************/
void hal_uart_init(void *handle, hal_uart_cfg_t *cfg)
{
    if (handle == NULL)
  110b4c:	b1f0      	cbz	r0, 110b8c <hal_uart_init+0x40>
{
  110b4e:	b530      	push	{r4, r5, r14}
  110b50:	b08b      	sub	sp, #44	; 0x2c
    if ((hal_cfg == NULL) || (drv_cfg == NULL))
  110b52:	b199      	cbz	r1, 110b7c <hal_uart_init+0x30>
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  110b54:	680d      	ldr	r5, [r1, #0]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  110b56:	7d0a      	ldrb	r2, [r1, #20]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  110b58:	684c      	ldr	r4, [r1, #4]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  110b5a:	7e0b      	ldrb	r3, [r1, #24]
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  110b5c:	9501      	str	r5, [sp, #4]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  110b5e:	9402      	str	r4, [sp, #8]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  110b60:	688d      	ldr	r5, [r1, #8]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  110b62:	68cc      	ldr	r4, [r1, #12]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  110b64:	9503      	str	r5, [sp, #12]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  110b66:	9404      	str	r4, [sp, #16]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  110b68:	690d      	ldr	r5, [r1, #16]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  110b6a:	e9d1 4107 	ldrd	r4, r1, [r1, #28]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  110b6e:	9505      	str	r5, [sp, #20]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  110b70:	e9cd 4108 	strd	r4, r1, [r13, #32]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  110b74:	f88d 2018 	strb.w	r2, [r13, #24]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  110b78:	f88d 301c 	strb.w	r3, [r13, #28]
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_cfg_t drv_cfg;
    hal_uart_cfg_copy_to_drv(cfg, &drv_cfg);
    uart_drv_init(instance->uartc, &(instance->drv_context), &drv_cfg);
  110b7c:	f100 0110 	add.w	r1, r0, #16
  110b80:	68c0      	ldr	r0, [r0, #12]
  110b82:	aa01      	add	r2, sp, #4
  110b84:	f7f9 f8b4 	bl	109cf0 <uart_drv_init>
}
  110b88:	b00b      	add	sp, #44	; 0x2c
  110b8a:	bd30      	pop	{r4, r5, r15}
  110b8c:	4770      	bx	r14
  110b8e:	bf00      	nop

00110b90 <hal_uart_putc>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   data        Character to put
 *****************************************************************************/
void hal_uart_putc(void *handle, char data)
{
    if (handle == NULL)
  110b90:	b128      	cbz	r0, 110b9e <hal_uart_putc+0xe>
        uart_drv_rs485_driver_set(instance->uartc, true);
        uart_drv_rs485_receiver_set(instance->uartc, false);
    }

#endif
    uart_drv_putc(instance->uartc, &(instance->drv_context), data);
  110b92:	460a      	mov	r2, r1
  110b94:	f100 0110 	add.w	r1, r0, #16
  110b98:	68c0      	ldr	r0, [r0, #12]
  110b9a:	f7f9 b9b7 	b.w	109f0c <uart_drv_putc>
        uart_drv_rs485_driver_set(instance->uartc, false);
        uart_drv_rs485_receiver_set(instance->uartc, true);
    }

#endif
}
  110b9e:	4770      	bx	r14

00110ba0 <hal_uart_int_cbk_register>:
 ** \param [in]   cbk
 *****************************************************************************/
void hal_uart_int_cbk_register(void *handle, hal_uart_int_src_t int_src,
                               hal_uart_int_callback cbk)
{
    if (handle == NULL)
  110ba0:	b1a0      	cbz	r0, 110bcc <hal_uart_int_cbk_register+0x2c>
{
  110ba2:	b510      	push	{r4, r14}
  110ba4:	4604      	mov	r4, r0
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_int_cbk_register(&(instance->drv_context), int_src, cbk);
  110ba6:	3010      	adds	r0, #16
  110ba8:	f7f9 f9be 	bl	109f28 <uart_drv_int_cbk_register>

    if (instance->irq_num != UART_HAL_INVALID_IRQ_NUM) {
  110bac:	68a0      	ldr	r0, [r4, #8]
  110bae:	1c43      	adds	r3, r0, #1
  110bb0:	d00b      	beq.n	110bca <hal_uart_int_cbk_register+0x2a>
        register_int_handler(instance->irq_num, hal_uart_irq_handle, handle);
  110bb2:	f640 2129 	movw	r1, #2601	; 0xa29
  110bb6:	4622      	mov	r2, r4
  110bb8:	f2c0 0111 	movt	r1, #17
  110bbc:	f7ef fda8 	bl	100710 <register_int_handler>
        unmask_interrupt(instance->irq_num);
  110bc0:	68a0      	ldr	r0, [r4, #8]
    }
}
  110bc2:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        unmask_interrupt(instance->irq_num);
  110bc6:	f7ef be01 	b.w	1007cc <unmask_interrupt>
}
  110bca:	bd10      	pop	{r4, r15}
  110bcc:	4770      	bx	r14
  110bce:	bf00      	nop

00110bd0 <hal_uart_int_src_enable>:
    unmask_interrupt(instance->irq_num);
}

void hal_uart_int_src_enable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  110bd0:	b108      	cbz	r0, 110bd6 <hal_uart_int_src_enable+0x6>
        return;

    uart_drv_int_src_enable(handle, int_src);
  110bd2:	f7f9 b9b5 	b.w	109f40 <uart_drv_int_src_enable>
}
  110bd6:	4770      	bx	r14

00110bd8 <hal_uart_int_src_disable>:

void hal_uart_int_src_disable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  110bd8:	b108      	cbz	r0, 110bde <hal_uart_int_src_disable+0x6>
        return;

    uart_drv_int_src_disable(handle, int_src);
  110bda:	f7f9 b9c1 	b.w	109f60 <uart_drv_int_src_disable>
}
  110bde:	4770      	bx	r14

00110be0 <FreeRTOS_SWI_Handler>:
 *****************************************************************************/
.align 4
.type FreeRTOS_SWI_Handler, %function
FreeRTOS_SWI_Handler:
	/* Save the context of the current task and select a new task to run. */
	portSAVE_CONTEXT
  110be0:	f96d051f 	srsdb	r13!, #31
  110be4:	f102001f 	cps	#31
  110be8:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  110bec:	e59f2258 	ldr	r2, [pc, #600]	; 110e4c <ulCriticalNestingConst>
  110bf0:	e5921000 	ldr	r1, [r2]
  110bf4:	e52d1004 	push	{r1}		; (str r1, [r13, #-4]!)
  110bf8:	e59f2250 	ldr	r2, [pc, #592]	; 110e50 <ulPortTaskHasFPUContextConst>
  110bfc:	e5923000 	ldr	r3, [r2]
  110c00:	e3530000 	cmp	r3, #0
  110c04:	1ef11a10 	vmrsne	r1, fpscr
  110c08:	1d2d0b20 	vpushne	{d0-d15}
  110c0c:	152d1004 	pushne	{r1}		; (strne r1, [r13, #-4]!)
  110c10:	e52d3004 	push	{r3}		; (str r3, [r13, #-4]!)
  110c14:	e59f022c 	ldr	r0, [pc, #556]	; 110e48 <pxCurrentTCBConst>
  110c18:	e5901000 	ldr	r1, [r0]
  110c1c:	e581d000 	str	r13, [r1]
	LDR R0, vTaskSwitchContextConst
  110c20:	e59f0230 	ldr	r0, [pc, #560]	; 110e58 <vTaskSwitchContextConst>
	BLX	R0
  110c24:	e12fff30 	blx	r0
	portRESTORE_CONTEXT
  110c28:	e59f0218 	ldr	r0, [pc, #536]	; 110e48 <pxCurrentTCBConst>
  110c2c:	e5901000 	ldr	r1, [r0]
  110c30:	e591d000 	ldr	r13, [r1]
  110c34:	e59f0214 	ldr	r0, [pc, #532]	; 110e50 <ulPortTaskHasFPUContextConst>
  110c38:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110c3c:	e5801000 	str	r1, [r0]
  110c40:	e3510000 	cmp	r1, #0
  110c44:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  110c48:	1cbd0b20 	vpopne	{d0-d15}
  110c4c:	1ee10a10 	vmsrne	fpscr, r0
  110c50:	e59f01f4 	ldr	r0, [pc, #500]	; 110e4c <ulCriticalNestingConst>
  110c54:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110c58:	e5801000 	str	r1, [r0]
  110c5c:	e59f21e0 	ldr	r2, [pc, #480]	; 110e44 <ulICCPMRConst>
  110c60:	e5922000 	ldr	r2, [r2]
  110c64:	e3510000 	cmp	r1, #0
  110c68:	03a040ff 	moveq	r4, #255	; 0xff
  110c6c:	159f41e0 	ldrne	r4, [pc, #480]	; 110e54 <ulMaxAPIPriorityMaskConst>
  110c70:	15944000 	ldrne	r4, [r4]
  110c74:	e5824000 	str	r4, [r2]
  110c78:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  110c7c:	f8bd0a00 	rfeia	r13!

00110c80 <vPortRestoreTaskContext>:
 * vPortRestoreTaskContext is used to start the scheduler.
 *****************************************************************************/
.type vPortRestoreTaskContext, %function
vPortRestoreTaskContext:
	/* Switch to system mode. */
	CPS		#SYS_MODE
  110c80:	f102001f 	cps	#31
	portRESTORE_CONTEXT
  110c84:	e59f01bc 	ldr	r0, [pc, #444]	; 110e48 <pxCurrentTCBConst>
  110c88:	e5901000 	ldr	r1, [r0]
  110c8c:	e591d000 	ldr	r13, [r1]
  110c90:	e59f01b8 	ldr	r0, [pc, #440]	; 110e50 <ulPortTaskHasFPUContextConst>
  110c94:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110c98:	e5801000 	str	r1, [r0]
  110c9c:	e3510000 	cmp	r1, #0
  110ca0:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  110ca4:	1cbd0b20 	vpopne	{d0-d15}
  110ca8:	1ee10a10 	vmsrne	fpscr, r0
  110cac:	e59f0198 	ldr	r0, [pc, #408]	; 110e4c <ulCriticalNestingConst>
  110cb0:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110cb4:	e5801000 	str	r1, [r0]
  110cb8:	e59f2184 	ldr	r2, [pc, #388]	; 110e44 <ulICCPMRConst>
  110cbc:	e5922000 	ldr	r2, [r2]
  110cc0:	e3510000 	cmp	r1, #0
  110cc4:	03a040ff 	moveq	r4, #255	; 0xff
  110cc8:	159f4184 	ldrne	r4, [pc, #388]	; 110e54 <ulMaxAPIPriorityMaskConst>
  110ccc:	15944000 	ldrne	r4, [r4]
  110cd0:	e5824000 	str	r4, [r2]
  110cd4:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  110cd8:	f8bd0a00 	rfeia	r13!
  110cdc:	e320f000 	nop	{0}

00110ce0 <FreeRTOS_IRQ_Handler>:
.align 4
.type FreeRTOS_IRQ_Handler, %function
FreeRTOS_IRQ_Handler:

	/* Return to the interrupted instruction. */
	SUB		lr, lr, #4
  110ce0:	e24ee004 	sub	r14, r14, #4

	/* Push the return address and SPSR. */
	PUSH	{lr}
  110ce4:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	MRS		lr, SPSR
  110ce8:	e14fe000 	mrs	r14, SPSR
	PUSH	{lr}
  110cec:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)

	/* Change to supervisor mode to allow reentry. */
	CPS		#SVC_MODE
  110cf0:	f1020013 	cps	#19

	/* Push used registers. */
	PUSH	{r0-r4, r12}
  110cf4:	e92d101f 	push	{r0, r1, r2, r3, r4, r12}

	/* Increment nesting count.  r3 holds the address of ulPortInterruptNesting
	for future use.  r1 holds the original ulPortInterruptNesting value for
	future use. */
	LDR		r3, ulPortInterruptNestingConst
  110cf8:	e59f3160 	ldr	r3, [pc, #352]	; 110e60 <ulPortInterruptNestingConst>
	LDR		r1, [r3]
  110cfc:	e5931000 	ldr	r1, [r3]
	ADD		r4, r1, #1
  110d00:	e2814001 	add	r4, r1, #1
	STR		r4, [r3]
  110d04:	e5834000 	str	r4, [r3]

	/* Read value from the interrupt acknowledge register, which is stored in r0
	for future parameter and interrupt clearing use. */
	LDR 	r2, ulICCIARConst
  110d08:	e59f212c 	ldr	r2, [pc, #300]	; 110e3c <ulICCIARConst>
	LDR		r2, [r2]
  110d0c:	e5922000 	ldr	r2, [r2]
	LDR		r0, [r2]
  110d10:	e5920000 	ldr	r0, [r2]

	/* Ensure bit 2 of the stack pointer is clear.  r2 holds the bit 2 value for
	future use.  _RB_ Is this ever needed provided the start of the stack is
	alligned on an 8-byte boundary? */
	MOV		r2, sp
  110d14:	e1a0200d 	mov	r2, r13
	AND		r2, r2, #4
  110d18:	e2022004 	and	r2, r2, #4
	SUB		sp, sp, r2
  110d1c:	e04dd002 	sub	r13, r13, r2

	/* Call the interrupt handler. */
	PUSH	{r0-r4, lr}
  110d20:	e92d401f 	push	{r0, r1, r2, r3, r4, r14}
	LDR		r1, vApplicationIRQHandlerConst
  110d24:	e59f1130 	ldr	r1, [pc, #304]	; 110e5c <vApplicationIRQHandlerConst>
	BLX		r1
  110d28:	e12fff31 	blx	r1
	POP		{r0-r4, lr}
  110d2c:	e8bd401f 	pop	{r0, r1, r2, r3, r4, r14}
	ADD		sp, sp, r2
  110d30:	e08dd002 	add	r13, r13, r2

	CPSID	i
  110d34:	f10c0080 	cpsid	i
	DSB
  110d38:	f57ff04f 	dsb	sy
	ISB
  110d3c:	f57ff06f 	isb	sy

	/* Write the value read from ICCIAR to ICCEOIR. */
	LDR 	r4, ulICCEOIRConst
  110d40:	e59f40f8 	ldr	r4, [pc, #248]	; 110e40 <ulICCEOIRConst>
	LDR		r4, [r4]
  110d44:	e5944000 	ldr	r4, [r4]
	STR		r0, [r4]
  110d48:	e5840000 	str	r0, [r4]

	/* Restore the old nesting count. */
	STR		r1, [r3]
  110d4c:	e5831000 	str	r1, [r3]

	/* A context switch is never performed if the nesting count is not 0. */
	CMP		r1, #0
  110d50:	e3510000 	cmp	r1, #0
	BNE		exit_without_switch
  110d54:	1a000003 	bne	110d68 <exit_without_switch>

	/* Did the interrupt request a context switch?  r1 holds the address of
	ulPortYieldRequired and r0 the value of ulPortYieldRequired for future
	use. */
	LDR		r1, =ulPortYieldRequired
  110d58:	e59f1104 	ldr	r1, [pc, #260]	; 110e64 <ulPortInterruptNestingConst+0x4>
	LDR		r0, [r1]
  110d5c:	e5910000 	ldr	r0, [r1]
	CMP		r0, #0
  110d60:	e3500000 	cmp	r0, #0
	BNE		switch_before_exit
  110d64:	1a000005 	bne	110d80 <switch_before_exit>

00110d68 <exit_without_switch>:

exit_without_switch:
	/* No context switch.  Restore used registers, LR_irq and SPSR before
	returning. */
	POP		{r0-r4, r12}
  110d68:	e8bd101f 	pop	{r0, r1, r2, r3, r4, r12}
	CPS		#IRQ_MODE
  110d6c:	f1020012 	cps	#18
	POP		{LR}
  110d70:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MSR		SPSR_cxsf, LR
  110d74:	e16ff00e 	msr	SPSR_fsxc, r14
	POP		{LR}
  110d78:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MOVS	PC, LR
  110d7c:	e1b0f00e 	movs	r15, r14

00110d80 <switch_before_exit>:

switch_before_exit:
	/* A context swtich is to be performed.  Clear the context switch pending
	flag. */
	MOV		r0, #0
  110d80:	e3a00000 	mov	r0, #0
	STR		r0, [r1]
  110d84:	e5810000 	str	r0, [r1]

	/* Restore used registers, LR-irq and SPSR before saving the context
	to the task stack. */
	POP		{r0-r4, r12}
  110d88:	e8bd101f 	pop	{r0, r1, r2, r3, r4, r12}
	CPS		#IRQ_MODE
  110d8c:	f1020012 	cps	#18
	POP		{LR}
  110d90:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MSR		SPSR_cxsf, LR
  110d94:	e16ff00e 	msr	SPSR_fsxc, r14
	POP		{LR}
  110d98:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	portSAVE_CONTEXT
  110d9c:	f96d051f 	srsdb	r13!, #31
  110da0:	f102001f 	cps	#31
  110da4:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  110da8:	e59f209c 	ldr	r2, [pc, #156]	; 110e4c <ulCriticalNestingConst>
  110dac:	e5921000 	ldr	r1, [r2]
  110db0:	e52d1004 	push	{r1}		; (str r1, [r13, #-4]!)
  110db4:	e59f2094 	ldr	r2, [pc, #148]	; 110e50 <ulPortTaskHasFPUContextConst>
  110db8:	e5923000 	ldr	r3, [r2]
  110dbc:	e3530000 	cmp	r3, #0
  110dc0:	1ef11a10 	vmrsne	r1, fpscr
  110dc4:	1d2d0b20 	vpushne	{d0-d15}
  110dc8:	152d1004 	pushne	{r1}		; (strne r1, [r13, #-4]!)
  110dcc:	e52d3004 	push	{r3}		; (str r3, [r13, #-4]!)
  110dd0:	e59f0070 	ldr	r0, [pc, #112]	; 110e48 <pxCurrentTCBConst>
  110dd4:	e5901000 	ldr	r1, [r0]
  110dd8:	e581d000 	str	r13, [r1]

	/* Call the function that selects the new task to execute.
	vTaskSwitchContext() if vTaskSwitchContext() uses LDRD or STRD
	instructions, or 8 byte aligned stack allocated data.  LR does not need
	saving as a new LR will be loaded by portRESTORE_CONTEXT anyway. */
	LDR		R0, vTaskSwitchContextConst
  110ddc:	e59f0074 	ldr	r0, [pc, #116]	; 110e58 <vTaskSwitchContextConst>
	BLX		R0
  110de0:	e12fff30 	blx	r0

	/* Restore the context of, and branch to, the task selected to execute
	next. */
	portRESTORE_CONTEXT
  110de4:	e59f005c 	ldr	r0, [pc, #92]	; 110e48 <pxCurrentTCBConst>
  110de8:	e5901000 	ldr	r1, [r0]
  110dec:	e591d000 	ldr	r13, [r1]
  110df0:	e59f0058 	ldr	r0, [pc, #88]	; 110e50 <ulPortTaskHasFPUContextConst>
  110df4:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110df8:	e5801000 	str	r1, [r0]
  110dfc:	e3510000 	cmp	r1, #0
  110e00:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  110e04:	1cbd0b20 	vpopne	{d0-d15}
  110e08:	1ee10a10 	vmsrne	fpscr, r0
  110e0c:	e59f0038 	ldr	r0, [pc, #56]	; 110e4c <ulCriticalNestingConst>
  110e10:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  110e14:	e5801000 	str	r1, [r0]
  110e18:	e59f2024 	ldr	r2, [pc, #36]	; 110e44 <ulICCPMRConst>
  110e1c:	e5922000 	ldr	r2, [r2]
  110e20:	e3510000 	cmp	r1, #0
  110e24:	03a040ff 	moveq	r4, #255	; 0xff
  110e28:	159f4024 	ldrne	r4, [pc, #36]	; 110e54 <ulMaxAPIPriorityMaskConst>
  110e2c:	15944000 	ldrne	r4, [r4]
  110e30:	e5824000 	str	r4, [r2]
  110e34:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  110e38:	f8bd0a00 	rfeia	r13!

00110e3c <ulICCIARConst>:
  110e3c:	0011ed6c 	.word	0x0011ed6c

00110e40 <ulICCEOIRConst>:
  110e40:	0011ed68 	.word	0x0011ed68

00110e44 <ulICCPMRConst>:
  110e44:	0011ed70 	.word	0x0011ed70

00110e48 <pxCurrentTCBConst>:
  110e48:	00132cdc 	.word	0x00132cdc

00110e4c <ulCriticalNestingConst>:
  110e4c:	0012c844 	.word	0x0012c844

00110e50 <ulPortTaskHasFPUContextConst>:
  110e50:	001309b4 	.word	0x001309b4

00110e54 <ulMaxAPIPriorityMaskConst>:
  110e54:	0011ed74 	.word	0x0011ed74

00110e58 <vTaskSwitchContextConst>:
  110e58:	00112dd5 	.word	0x00112dd5

00110e5c <vApplicationIRQHandlerConst>:
  110e5c:	00100865 	.word	0x00100865

00110e60 <ulPortInterruptNestingConst>:
  110e60:	001309b0 	.word	0x001309b0
	LDR		r1, =ulPortYieldRequired
  110e64:	001309b8 	.word	0x001309b8

00110e68 <FreeRTOS_Tick_Handler>:
	}
}
/*-----------------------------------------------------------*/

void FreeRTOS_Tick_Handler( void )
{
  110e68:	b508      	push	{r3, r14}
	/* Set interrupt mask before altering scheduler structures.   The tick
	handler runs at the lowest priority, so interrupts cannot already be masked,
	so there is no need to save and restore the current mask value.  It is
	necessary to turn off interrupts in the CPU itself while the ICCPMR is being
	updated. */
	portCPU_IRQ_DISABLE();
  110e6a:	b672      	cpsid	i
  110e6c:	f3bf 8f4f 	dsb	sy
  110e70:	f3bf 8f6f 	isb	sy
	portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  110e74:	f242 0304 	movw	r3, #8196	; 0x2004
  110e78:	2290      	movs	r2, #144	; 0x90
  110e7a:	f2cf 5340 	movt	r3, #62784	; 0xf540
  110e7e:	601a      	str	r2, [r3, #0]
	__asm volatile (	"dsb		\n"
  110e80:	f3bf 8f4f 	dsb	sy
  110e84:	f3bf 8f6f 	isb	sy
						"isb		\n" ::: "memory" );
	portCPU_IRQ_ENABLE();
  110e88:	b662      	cpsie	i
  110e8a:	f3bf 8f4f 	dsb	sy
  110e8e:	f3bf 8f6f 	isb	sy

	/* Increment the RTOS tick. */
	if( xTaskIncrementTick() != pdFALSE )
  110e92:	f001 fe29 	bl	112ae8 <xTaskIncrementTick>
  110e96:	b128      	cbz	r0, 110ea4 <FreeRTOS_Tick_Handler+0x3c>
	{
		ulPortYieldRequired = pdTRUE;
  110e98:	f640 13b8 	movw	r3, #2488	; 0x9b8
  110e9c:	2201      	movs	r2, #1
  110e9e:	f2c0 0313 	movt	r3, #19
  110ea2:	601a      	str	r2, [r3, #0]
	}

	/* Ensure all interrupt priorities are active again. */
	portCLEAR_INTERRUPT_MASK();
  110ea4:	b672      	cpsid	i
  110ea6:	f3bf 8f4f 	dsb	sy
  110eaa:	f3bf 8f6f 	isb	sy
  110eae:	f242 0304 	movw	r3, #8196	; 0x2004
  110eb2:	22ff      	movs	r2, #255	; 0xff
  110eb4:	f2cf 5340 	movt	r3, #62784	; 0xf540
  110eb8:	601a      	str	r2, [r3, #0]
  110eba:	f3bf 8f4f 	dsb	sy
  110ebe:	f3bf 8f6f 	isb	sy
  110ec2:	b662      	cpsie	i
  110ec4:	f3bf 8f4f 	dsb	sy
  110ec8:	f3bf 8f6f 	isb	sy
	configCLEAR_TICK_INTERRUPT();
}
  110ecc:	bd08      	pop	{r3, r15}
  110ece:	bf00      	nop

00110ed0 <pxPortInitialiseStack>:
{
  110ed0:	4603      	mov	r3, r0
	if( ( ( uint32_t ) pxCode & portTHUMB_MODE_ADDRESS ) != 0x00UL )
  110ed2:	f011 0f01 	tst.w	r1, #1
{
  110ed6:	b470      	push	{r4, r5, r6}
	*pxTopOfStack = ( StackType_t ) pxCode;
  110ed8:	f840 1c10 	str.w	r1, [r0, #-16]
	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
  110edc:	f04f 3412 	mov.w	r4, #303174162	; 0x12121212
		*pxTopOfStack |= portTHUMB_MODE_BIT;
  110ee0:	bf14      	ite	ne
  110ee2:	253f      	movne	r5, #63	; 0x3f
  110ee4:	251f      	moveq	r5, #31
	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
  110ee6:	f04f 3010 	mov.w	r0, #269488144	; 0x10101010
	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
  110eea:	f04f 3106 	mov.w	r1, #101058054	; 0x6060606
	*pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
  110eee:	f843 2c48 	str.w	r2, [r3, #-72]
	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
  110ef2:	f04f 3209 	mov.w	r2, #151587081	; 0x9090909
  110ef6:	f843 5c0c 	str.w	r5, [r3, #-12]
	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
  110efa:	f04f 3508 	mov.w	r5, #134744072	; 0x8080808
	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
  110efe:	f843 4c18 	str.w	r4, [r3, #-24]
	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
  110f02:	f04f 3407 	mov.w	r4, #117901063	; 0x7070707
	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
  110f06:	f843 0c20 	str.w	r0, [r3, #-32]
	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
  110f0a:	f04f 3005 	mov.w	r0, #84215045	; 0x5050505
	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
  110f0e:	f843 2c24 	str.w	r2, [r3, #-36]
	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
  110f12:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
  110f16:	f843 5c28 	str.w	r5, [r3, #-40]
	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
  110f1a:	f04f 3611 	mov.w	r6, #286331153	; 0x11111111
	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
  110f1e:	f843 4c2c 	str.w	r4, [r3, #-44]
	*pxTopOfStack = ( StackType_t ) 0x03030303;	/* R3 */
  110f22:	f04f 3503 	mov.w	r5, #50529027	; 0x3030303
	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
  110f26:	f843 1c30 	str.w	r1, [r3, #-48]
	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
  110f2a:	f04f 3402 	mov.w	r4, #33686018	; 0x2020202
	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
  110f2e:	f843 0c34 	str.w	r0, [r3, #-52]
	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
  110f32:	f04f 3101 	mov.w	r1, #16843009	; 0x1010101
	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
  110f36:	f843 2c38 	str.w	r2, [r3, #-56]
	*pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
  110f3a:	4618      	mov	r0, r3
	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
  110f3c:	f843 6c1c 	str.w	r6, [r3, #-28]
	*pxTopOfStack = ( StackType_t ) NULL;
  110f40:	2200      	movs	r2, #0
	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
  110f42:	e943 4510 	strd	r4, r5, [r3, #-64]	; 0x40
	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
  110f46:	f843 1c44 	str.w	r1, [r3, #-68]
	*pxTopOfStack = ( StackType_t ) NULL;
  110f4a:	e943 2201 	strd	r2, r2, [r3, #-4]
	*pxTopOfStack = ( StackType_t ) NULL;
  110f4e:	f843 2c08 	str.w	r2, [r3, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* R14 */
  110f52:	f843 2c14 	str.w	r2, [r3, #-20]
	*pxTopOfStack = portNO_CRITICAL_NESTING;
  110f56:	f843 2c4c 	str.w	r2, [r3, #-76]
}
  110f5a:	bc70      	pop	{r4, r5, r6}
	*pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
  110f5c:	f840 2d50 	str.w	r2, [r0, #-80]!
}
  110f60:	4770      	bx	r14
  110f62:	bf00      	nop

00110f64 <xPortStartScheduler>:
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  110f64:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  110f68:	20ff      	movs	r0, #255	; 0xff
{
  110f6a:	b500      	push	{r14}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  110f6c:	f2cf 5340 	movt	r3, #62784	; 0xf540
  110f70:	7819      	ldrb	r1, [r3, #0]
{
  110f72:	b083      	sub	sp, #12
		while( ( ucMaxPriorityValue & portBIT_0_SET ) != portBIT_0_SET )
  110f74:	2208      	movs	r2, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  110f76:	b2c9      	uxtb	r1, r1
  110f78:	9101      	str	r1, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  110f7a:	7018      	strb	r0, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  110f7c:	781b      	ldrb	r3, [r3, #0]
  110f7e:	b2db      	uxtb	r3, r3
  110f80:	f88d 3003 	strb.w	r3, [r13, #3]
		while( ( ucMaxPriorityValue & portBIT_0_SET ) != portBIT_0_SET )
  110f84:	f89d 3003 	ldrb.w	r3, [r13, #3]
  110f88:	07db      	lsls	r3, r3, #31
  110f8a:	d407      	bmi.n	110f9c <xPortStartScheduler+0x38>
			ucMaxPriorityValue >>= ( uint8_t ) 0x01;
  110f8c:	f89d 3003 	ldrb.w	r3, [r13, #3]
			if( ulCycles == 0 )
  110f90:	3a01      	subs	r2, #1
			ucMaxPriorityValue >>= ( uint8_t ) 0x01;
  110f92:	ea4f 0353 	mov.w	r3, r3, lsr #1
  110f96:	f88d 3003 	strb.w	r3, [r13, #3]
			if( ulCycles == 0 )
  110f9a:	d1f3      	bne.n	110f84 <xPortStartScheduler+0x20>
		configASSERT( ucMaxPriorityValue == portLOWEST_INTERRUPT_PRIORITY );
  110f9c:	f89d 3003 	ldrb.w	r3, [r13, #3]
  110fa0:	2b1f      	cmp	r3, #31
  110fa2:	d00d      	beq.n	110fc0 <xPortStartScheduler+0x5c>

}

void vMainAssertCalled(const char *pcFileName, uint32_t ulLineNumber)
{
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  110fa4:	f64e 51ac 	movw	r1, #60844	; 0xedac
  110fa8:	f64e 6020 	movw	r0, #60960	; 0xee20
  110fac:	f44f 72a3 	mov.w	r2, #326	; 0x146
  110fb0:	f2c0 0111 	movt	r1, #17
  110fb4:	f2c0 0011 	movt	r0, #17
  110fb8:	f003 fc24 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  110fbc:	b673      	cpsid	if
	__asm__ volatile("b .");
  110fbe:	e7fe      	b.n	110fbe <xPortStartScheduler+0x5a>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  110fc0:	9b01      	ldr	r3, [sp, #4]
  110fc2:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  110fc6:	f2cf 5240 	movt	r2, #62784	; 0xf540
  110fca:	b2db      	uxtb	r3, r3
  110fcc:	7013      	strb	r3, [r2, #0]
	__asm volatile ( "MRS %0, APSR" : "=r" ( ulAPSR ) :: "memory" );
  110fce:	f3ef 8300 	mrs	r3, CPSR
	ulAPSR &= portAPSR_MODE_BITS_MASK;
  110fd2:	f003 031f 	and.w	r3, r3, #31
	configASSERT( ulAPSR != portAPSR_USER_MODE );
  110fd6:	2b10      	cmp	r3, #16
  110fd8:	d035      	beq.n	111046 <xPortStartScheduler+0xe2>
		configASSERT( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE );
  110fda:	f242 0308 	movw	r3, #8200	; 0x2008
  110fde:	f2cf 5340 	movt	r3, #62784	; 0xf540
  110fe2:	681b      	ldr	r3, [r3, #0]
  110fe4:	f003 0303 	and.w	r3, r3, #3
  110fe8:	2b03      	cmp	r3, #3
  110fea:	d01d      	beq.n	111028 <xPortStartScheduler+0xc4>
		if( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE )
  110fec:	f242 0308 	movw	r3, #8200	; 0x2008
  110ff0:	f2cf 5340 	movt	r3, #62784	; 0xf540
  110ff4:	681b      	ldr	r3, [r3, #0]
  110ff6:	f003 0303 	and.w	r3, r3, #3
  110ffa:	2b03      	cmp	r3, #3
  110ffc:	d103      	bne.n	111006 <xPortStartScheduler+0xa2>
}
  110ffe:	2000      	movs	r0, #0
  111000:	b003      	add	sp, #12
  111002:	f85d fb04 	ldr.w	r15, [r13], #4
			portCPU_IRQ_DISABLE();
  111006:	b672      	cpsid	i
  111008:	f3bf 8f4f 	dsb	sy
  11100c:	f3bf 8f6f 	isb	sy
	vPortTickTimerEnable(FreeRTOS_Tick_Handler);
  111010:	f640 6069 	movw	r0, #3689	; 0xe69
  111014:	f2c0 0011 	movt	r0, #17
  111018:	f7ef fb5a 	bl	1006d0 <vPortTickTimerEnable>
			vPortRestoreTaskContext();
  11101c:	f7ff ee30 	blx	110c80 <vPortRestoreTaskContext>
}
  111020:	2000      	movs	r0, #0
  111022:	b003      	add	sp, #12
  111024:	f85d fb04 	ldr.w	r15, [r13], #4
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  111028:	f64e 51ac 	movw	r1, #60844	; 0xedac
  11102c:	f64e 6020 	movw	r0, #60960	; 0xee20
  111030:	f240 1259 	movw	r2, #345	; 0x159
  111034:	f2c0 0111 	movt	r1, #17
  111038:	f2c0 0011 	movt	r0, #17
  11103c:	f003 fbe2 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  111040:	b673      	cpsid	if
	__asm__ volatile("b .");
  111042:	e7fe      	b.n	111042 <xPortStartScheduler+0xde>
  111044:	e7d2      	b.n	110fec <xPortStartScheduler+0x88>
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  111046:	f64e 51ac 	movw	r1, #60844	; 0xedac
  11104a:	f64e 6020 	movw	r0, #60960	; 0xee20
  11104e:	f44f 72a9 	mov.w	r2, #338	; 0x152
  111052:	f2c0 0111 	movt	r1, #17
  111056:	f2c0 0011 	movt	r0, #17
  11105a:	f003 fbd3 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  11105e:	b673      	cpsid	if
	__asm__ volatile("b .");
  111060:	e7fe      	b.n	111060 <xPortStartScheduler+0xfc>
}
  111062:	2000      	movs	r0, #0
  111064:	b003      	add	sp, #12
  111066:	f85d fb04 	ldr.w	r15, [r13], #4
  11106a:	bf00      	nop

0011106c <vPortEnterCritical>:
{
  11106c:	b508      	push	{r3, r14}
	portCPU_IRQ_DISABLE();
  11106e:	b672      	cpsid	i
  111070:	f3bf 8f4f 	dsb	sy
  111074:	f3bf 8f6f 	isb	sy
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  111078:	f242 0304 	movw	r3, #8196	; 0x2004
  11107c:	f2cf 5340 	movt	r3, #62784	; 0xf540
  111080:	681a      	ldr	r2, [r3, #0]
  111082:	2a90      	cmp	r2, #144	; 0x90
  111084:	d005      	beq.n	111092 <vPortEnterCritical+0x26>
		portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  111086:	2290      	movs	r2, #144	; 0x90
  111088:	601a      	str	r2, [r3, #0]
		__asm volatile (	"dsb		\n"
  11108a:	f3bf 8f4f 	dsb	sy
  11108e:	f3bf 8f6f 	isb	sy
	portCPU_IRQ_ENABLE();
  111092:	b662      	cpsie	i
  111094:	f3bf 8f4f 	dsb	sy
  111098:	f3bf 8f6f 	isb	sy
	ulCriticalNesting++;
  11109c:	f64c 0344 	movw	r3, #51268	; 0xc844
  1110a0:	f2c0 0312 	movt	r3, #18
  1110a4:	681a      	ldr	r2, [r3, #0]
  1110a6:	3201      	adds	r2, #1
  1110a8:	601a      	str	r2, [r3, #0]
	if( ulCriticalNesting == 1 )
  1110aa:	681b      	ldr	r3, [r3, #0]
  1110ac:	2b01      	cmp	r3, #1
  1110ae:	d000      	beq.n	1110b2 <vPortEnterCritical+0x46>
}
  1110b0:	bd08      	pop	{r3, r15}
		configASSERT( ulPortInterruptNesting == 0 );
  1110b2:	f640 13b0 	movw	r3, #2480	; 0x9b0
  1110b6:	f2c0 0313 	movt	r3, #19
  1110ba:	681b      	ldr	r3, [r3, #0]
  1110bc:	2b00      	cmp	r3, #0
  1110be:	d0f7      	beq.n	1110b0 <vPortEnterCritical+0x44>
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  1110c0:	f64e 51ac 	movw	r1, #60844	; 0xedac
  1110c4:	f64e 6020 	movw	r0, #60960	; 0xee20
  1110c8:	f44f 72c7 	mov.w	r2, #398	; 0x18e
  1110cc:	f2c0 0111 	movt	r1, #17
  1110d0:	f2c0 0011 	movt	r0, #17
  1110d4:	f003 fb96 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  1110d8:	b673      	cpsid	if
	__asm__ volatile("b .");
  1110da:	e7fe      	b.n	1110da <vPortEnterCritical+0x6e>
}
  1110dc:	bd08      	pop	{r3, r15}
  1110de:	bf00      	nop

001110e0 <vPortExitCritical>:
	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
  1110e0:	f64c 0344 	movw	r3, #51268	; 0xc844
  1110e4:	f2c0 0312 	movt	r3, #18
  1110e8:	681a      	ldr	r2, [r3, #0]
  1110ea:	b1c2      	cbz	r2, 11111e <vPortExitCritical+0x3e>
		ulCriticalNesting--;
  1110ec:	681a      	ldr	r2, [r3, #0]
  1110ee:	3a01      	subs	r2, #1
  1110f0:	601a      	str	r2, [r3, #0]
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
  1110f2:	681b      	ldr	r3, [r3, #0]
  1110f4:	b99b      	cbnz	r3, 11111e <vPortExitCritical+0x3e>
			portCLEAR_INTERRUPT_MASK();
  1110f6:	b672      	cpsid	i
  1110f8:	f3bf 8f4f 	dsb	sy
  1110fc:	f3bf 8f6f 	isb	sy
  111100:	f242 0304 	movw	r3, #8196	; 0x2004
  111104:	22ff      	movs	r2, #255	; 0xff
  111106:	f2cf 5340 	movt	r3, #62784	; 0xf540
  11110a:	601a      	str	r2, [r3, #0]
  11110c:	f3bf 8f4f 	dsb	sy
  111110:	f3bf 8f6f 	isb	sy
  111114:	b662      	cpsie	i
  111116:	f3bf 8f4f 	dsb	sy
  11111a:	f3bf 8f6f 	isb	sy
}
  11111e:	4770      	bx	r14

00111120 <vPortTaskUsesFPU>:
	ulPortTaskHasFPUContext = pdTRUE;
  111120:	f640 13b4 	movw	r3, #2484	; 0x9b4
  111124:	2101      	movs	r1, #1
	__asm volatile ( "FMXR 	FPSCR, %0" :: "r" (ulInitialFPSCR) : "memory" );
  111126:	2200      	movs	r2, #0
	ulPortTaskHasFPUContext = pdTRUE;
  111128:	f2c0 0313 	movt	r3, #19
  11112c:	6019      	str	r1, [r3, #0]
	__asm volatile ( "FMXR 	FPSCR, %0" :: "r" (ulInitialFPSCR) : "memory" );
  11112e:	eee1 2a10 	vmsr	fpscr, r2
}
  111132:	4770      	bx	r14

00111134 <vPortClearInterruptMask>:
	if( ulNewMaskValue == pdFALSE )
  111134:	b998      	cbnz	r0, 11115e <vPortClearInterruptMask+0x2a>
		portCLEAR_INTERRUPT_MASK();
  111136:	b672      	cpsid	i
  111138:	f3bf 8f4f 	dsb	sy
  11113c:	f3bf 8f6f 	isb	sy
  111140:	f242 0304 	movw	r3, #8196	; 0x2004
  111144:	22ff      	movs	r2, #255	; 0xff
  111146:	f2cf 5340 	movt	r3, #62784	; 0xf540
  11114a:	601a      	str	r2, [r3, #0]
  11114c:	f3bf 8f4f 	dsb	sy
  111150:	f3bf 8f6f 	isb	sy
  111154:	b662      	cpsie	i
  111156:	f3bf 8f4f 	dsb	sy
  11115a:	f3bf 8f6f 	isb	sy
}
  11115e:	4770      	bx	r14

00111160 <ulPortSetInterruptMask>:
	portCPU_IRQ_DISABLE();
  111160:	b672      	cpsid	i
  111162:	f3bf 8f4f 	dsb	sy
  111166:	f3bf 8f6f 	isb	sy
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  11116a:	f242 0304 	movw	r3, #8196	; 0x2004
  11116e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  111172:	681a      	ldr	r2, [r3, #0]
  111174:	2a90      	cmp	r2, #144	; 0x90
		ulReturn = pdTRUE;
  111176:	bf08      	it	eq
  111178:	2001      	moveq	r0, #1
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  11117a:	d006      	beq.n	11118a <ulPortSetInterruptMask+0x2a>
		portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  11117c:	2290      	movs	r2, #144	; 0x90
  11117e:	601a      	str	r2, [r3, #0]
		__asm volatile (	"dsb		\n"
  111180:	f3bf 8f4f 	dsb	sy
  111184:	f3bf 8f6f 	isb	sy
		ulReturn = pdFALSE;
  111188:	2000      	movs	r0, #0
	portCPU_IRQ_ENABLE();
  11118a:	b662      	cpsie	i
  11118c:	f3bf 8f4f 	dsb	sy
  111190:	f3bf 8f6f 	isb	sy
}
  111194:	4770      	bx	r14
  111196:	bf00      	nop

00111198 <vPortValidateInterruptPriority>:
	{
  111198:	b508      	push	{r3, r14}
		configASSERT( portICCRPR_RUNNING_PRIORITY_REGISTER >= ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) );
  11119a:	f242 0314 	movw	r3, #8212	; 0x2014
  11119e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  1111a2:	681b      	ldr	r3, [r3, #0]
  1111a4:	2b8f      	cmp	r3, #143	; 0x8f
  1111a6:	d918      	bls.n	1111da <vPortValidateInterruptPriority+0x42>
		configASSERT( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE );
  1111a8:	f242 0308 	movw	r3, #8200	; 0x2008
  1111ac:	f2cf 5340 	movt	r3, #62784	; 0xf540
  1111b0:	681b      	ldr	r3, [r3, #0]
  1111b2:	f003 0303 	and.w	r3, r3, #3
  1111b6:	2b03      	cmp	r3, #3
  1111b8:	d000      	beq.n	1111bc <vPortValidateInterruptPriority+0x24>
	}
  1111ba:	bd08      	pop	{r3, r15}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  1111bc:	f64e 51ac 	movw	r1, #60844	; 0xedac
  1111c0:	f64e 6020 	movw	r0, #60960	; 0xee20
  1111c4:	f240 2212 	movw	r2, #530	; 0x212
  1111c8:	f2c0 0111 	movt	r1, #17
  1111cc:	f2c0 0011 	movt	r0, #17
  1111d0:	f003 fb18 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  1111d4:	b673      	cpsid	if
	__asm__ volatile("b .");
  1111d6:	e7fe      	b.n	1111d6 <vPortValidateInterruptPriority+0x3e>
	}
  1111d8:	bd08      	pop	{r3, r15}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  1111da:	f64e 51ac 	movw	r1, #60844	; 0xedac
  1111de:	f64e 6020 	movw	r0, #60960	; 0xee20
  1111e2:	f240 2206 	movw	r2, #518	; 0x206
  1111e6:	f2c0 0111 	movt	r1, #17
  1111ea:	f2c0 0011 	movt	r0, #17
  1111ee:	f003 fb09 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  1111f2:	b673      	cpsid	if
	__asm__ volatile("b .");
  1111f4:	e7fe      	b.n	1111f4 <vPortValidateInterruptPriority+0x5c>
  1111f6:	e7d7      	b.n	1111a8 <vPortValidateInterruptPriority+0x10>

001111f8 <vApplicationGetTimerTaskMemory>:
{
  1111f8:	b430      	push	{r4, r5}
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  1111fa:	f640 4384 	movw	r3, #3204	; 0xc84
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  1111fe:	f640 4420 	movw	r4, #3104	; 0xc20
	*pulTimerTaskStackSize = configTASK_TIMER_STACK_SIZE;
  111202:	f44f 6500 	mov.w	r5, #2048	; 0x800
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  111206:	f2c0 0413 	movt	r4, #19
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  11120a:	f2c0 0313 	movt	r3, #19
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  11120e:	6004      	str	r4, [r0, #0]
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  111210:	600b      	str	r3, [r1, #0]
	*pulTimerTaskStackSize = configTASK_TIMER_STACK_SIZE;
  111212:	6015      	str	r5, [r2, #0]
}
  111214:	bc30      	pop	{r4, r5}
  111216:	4770      	bx	r14

00111218 <vApplicationGetIdleTaskMemory>:
{
  111218:	b430      	push	{r4, r5}
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  11121a:	f640 2320 	movw	r3, #2592	; 0xa20
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  11121e:	f640 14bc 	movw	r4, #2492	; 0x9bc
	*pulTimerTaskStackSize = configTASK_IDLE_STACK_SIZE;
  111222:	2580      	movs	r5, #128	; 0x80
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  111224:	f2c0 0413 	movt	r4, #19
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  111228:	f2c0 0313 	movt	r3, #19
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  11122c:	6004      	str	r4, [r0, #0]
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  11122e:	600b      	str	r3, [r1, #0]
	*pulTimerTaskStackSize = configTASK_IDLE_STACK_SIZE;
  111230:	6015      	str	r5, [r2, #0]
}
  111232:	bc30      	pop	{r4, r5}
  111234:	4770      	bx	r14
  111236:	bf00      	nop

00111238 <vApplicationIdleHook>:
  111238:	4770      	bx	r14
  11123a:	bf00      	nop

0011123c <vApplicationTickHook>:
  11123c:	4770      	bx	r14
  11123e:	bf00      	nop

00111240 <vApplicationMallocFailedHook>:
  111240:	4770      	bx	r14
  111242:	bf00      	nop

00111244 <vApplicationStackOverflowHook>:
	printf("FreeRTOS Kernel Fault:%20s Task StackOverFlow!\r\n", pcTaskName);
  111244:	f64e 5078 	movw	r0, #60792	; 0xed78
{
  111248:	b508      	push	{r3, r14}
	printf("FreeRTOS Kernel Fault:%20s Task StackOverFlow!\r\n", pcTaskName);
  11124a:	f2c0 0011 	movt	r0, #17
  11124e:	f003 fad9 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  111252:	b673      	cpsid	if
	__asm__ volatile("b .");
  111254:	e7fe      	b.n	111254 <vApplicationStackOverflowHook+0x10>
}
  111256:	bd08      	pop	{r3, r15}

00111258 <traceTASK_SWITCHED_OUT_HOOK>:
  111258:	4770      	bx	r14
  11125a:	bf00      	nop

0011125c <traceTASK_SWITCHED_IN_HOOK>:
  11125c:	4770      	bx	r14
  11125e:	bf00      	nop

00111260 <vMainAssertCalled>:
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  111260:	460a      	mov	r2, r1
  111262:	4601      	mov	r1, r0
  111264:	f64e 6020 	movw	r0, #60960	; 0xee20
{
  111268:	b508      	push	{r3, r14}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  11126a:	f2c0 0011 	movt	r0, #17
  11126e:	f003 fac9 	bl	114804 <printf>
	__asm__ volatile("cpsid if");
  111272:	b673      	cpsid	if
	__asm__ volatile("b .");
  111274:	e7fe      	b.n	111274 <vMainAssertCalled+0x14>
}
  111276:	bd08      	pop	{r3, r15}

00111278 <vPortGetCurrentTimeMs>:

unsigned long current_time(void);
unsigned long vPortGetCurrentTimeMs( void )
{
	return current_time();
  111278:	f7ef b9ea 	b.w	100650 <current_time>

0011127c <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  11127c:	f642 4294 	movw	r2, #11412	; 0x2c94
{
  111280:	b410      	push	{r4}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  111282:	f2c0 0213 	movt	r2, #19
  111286:	e000      	b.n	11128a <prvInsertBlockIntoFreeList+0xe>
  111288:	461a      	mov	r2, r3
  11128a:	6813      	ldr	r3, [r2, #0]
  11128c:	4283      	cmp	r3, r0
  11128e:	d3fb      	bcc.n	111288 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  111290:	6851      	ldr	r1, [r2, #4]
  111292:	1854      	adds	r4, r2, r1
  111294:	42a0      	cmp	r0, r4
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  111296:	bf05      	ittet	eq
  111298:	6844      	ldreq	r4, [r0, #4]
  11129a:	4610      	moveq	r0, r2
  11129c:	6841      	ldrne	r1, [r0, #4]
  11129e:	1909      	addeq	r1, r1, r4
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  1112a0:	eb00 0401 	add.w	r4, r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  1112a4:	bf08      	it	eq
  1112a6:	6051      	streq	r1, [r2, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  1112a8:	42a3      	cmp	r3, r4
  1112aa:	d006      	beq.n	1112ba <prvInsertBlockIntoFreeList+0x3e>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  1112ac:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  1112ae:	4290      	cmp	r0, r2
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  1112b0:	f85d 4b04 	ldr.w	r4, [r13], #4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  1112b4:	bf18      	it	ne
  1112b6:	6010      	strne	r0, [r2, #0]
}
  1112b8:	4770      	bx	r14
		if( pxIterator->pxNextFreeBlock != pxEnd )
  1112ba:	f642 4484 	movw	r4, #11396	; 0x2c84
  1112be:	f2c0 0413 	movt	r4, #19
  1112c2:	6824      	ldr	r4, [r4, #0]
  1112c4:	42a3      	cmp	r3, r4
  1112c6:	d0f1      	beq.n	1112ac <prvInsertBlockIntoFreeList+0x30>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  1112c8:	e9d3 3400 	ldrd	r3, r4, [r3]
	if( pxIterator != pxBlockToInsert )
  1112cc:	4290      	cmp	r0, r2
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  1112ce:	4421      	add	r1, r4
}
  1112d0:	f85d 4b04 	ldr.w	r4, [r13], #4
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  1112d4:	e9c0 3100 	strd	r3, r1, [r0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  1112d8:	bf18      	it	ne
  1112da:	6010      	strne	r0, [r2, #0]
}
  1112dc:	4770      	bx	r14
  1112de:	bf00      	nop

001112e0 <pvPortMallocAligned>:
{
  1112e0:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  1112e4:	460f      	mov	r7, r1
	configASSERT(!(xBoundary & (xBoundary - 1)));
  1112e6:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
{
  1112ea:	4606      	mov	r6, r0
	configASSERT(!(xBoundary & (xBoundary - 1)));
  1112ec:	ea19 0f01 	tst.w	r9, r1
  1112f0:	f040 8090 	bne.w	111414 <pvPortMallocAligned+0x134>
	vTaskSuspendAll();
  1112f4:	f001 fbe4 	bl	112ac0 <vTaskSuspendAll>
		if( pxEnd == NULL )
  1112f8:	f642 4284 	movw	r2, #11396	; 0x2c84
  1112fc:	f2c0 0213 	movt	r2, #19
  111300:	6813      	ldr	r3, [r2, #0]
  111302:	2b00      	cmp	r3, #0
  111304:	f000 808e 	beq.w	111424 <pvPortMallocAligned+0x144>
  111308:	f642 4888 	movw	r8, #11400	; 0x2c88
  11130c:	f2c0 0813 	movt	r8, #19
  111310:	f8d8 0000 	ldr.w	r0, [r8]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  111314:	4206      	tst	r6, r0
  111316:	d175      	bne.n	111404 <pvPortMallocAligned+0x124>
			if( xWantedSize > 0 )
  111318:	2e00      	cmp	r6, #0
  11131a:	d073      	beq.n	111404 <pvPortMallocAligned+0x124>
				xWantedSize += xHeapStructSize;
  11131c:	3608      	adds	r6, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  11131e:	0771      	lsls	r1, r6, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  111320:	bf1c      	itt	ne
  111322:	f026 0607 	bicne.w	r6, r6, #7
  111326:	3608      	addne	r6, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  111328:	2e00      	cmp	r6, #0
  11132a:	d06b      	beq.n	111404 <pvPortMallocAligned+0x124>
  11132c:	f642 4a8c 	movw	r10, #11404	; 0x2c8c
  111330:	f2c0 0a13 	movt	r10, #19
  111334:	f8da 3000 	ldr.w	r3, [r10]
  111338:	42b3      	cmp	r3, r6
  11133a:	d363      	bcc.n	111404 <pvPortMallocAligned+0x124>
				pxBlock = xStart.pxNextFreeBlock;
  11133c:	f642 4194 	movw	r1, #11412	; 0x2c94
  111340:	f2c0 0113 	movt	r1, #19
  111344:	6808      	ldr	r0, [r1, #0]
				xPaddingSize = (( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 ));
  111346:	1a3d      	subs	r5, r7, r0
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  111348:	6843      	ldr	r3, [r0, #4]
				xPaddingSize = (( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 ));
  11134a:	3d08      	subs	r5, #8
  11134c:	ea05 0509 	and.w	r5, r5, r9
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  111350:	1974      	adds	r4, r6, r5
  111352:	42a3      	cmp	r3, r4
  111354:	f080 809c 	bcs.w	111490 <pvPortMallocAligned+0x1b0>
  111358:	6804      	ldr	r4, [r0, #0]
  11135a:	2c00      	cmp	r4, #0
  11135c:	f000 8098 	beq.w	111490 <pvPortMallocAligned+0x1b0>
  111360:	3f08      	subs	r7, #8
  111362:	e003      	b.n	11136c <pvPortMallocAligned+0x8c>
  111364:	6823      	ldr	r3, [r4, #0]
  111366:	b143      	cbz	r3, 11137a <pvPortMallocAligned+0x9a>
  111368:	4620      	mov	r0, r4
  11136a:	461c      	mov	r4, r3
  11136c:	6863      	ldr	r3, [r4, #4]
					xPaddingSize = ( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 );
  11136e:	1b3d      	subs	r5, r7, r4
  111370:	ea05 0509 	and.w	r5, r5, r9
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  111374:	1971      	adds	r1, r6, r5
  111376:	428b      	cmp	r3, r1
  111378:	d3f4      	bcc.n	111364 <pvPortMallocAligned+0x84>
				if( pxBlock != pxEnd )
  11137a:	6813      	ldr	r3, [r2, #0]
  11137c:	42a3      	cmp	r3, r4
  11137e:	d041      	beq.n	111404 <pvPortMallocAligned+0x124>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  111380:	6823      	ldr	r3, [r4, #0]
  111382:	6003      	str	r3, [r0, #0]
					if( xPaddingSize > 0 )
  111384:	b15d      	cbz	r5, 11139e <pvPortMallocAligned+0xbe>
						configASSERT( xPaddingSize >= xHeapStructSize );
  111386:	2d07      	cmp	r5, #7
  111388:	f240 8085 	bls.w	111496 <pvPortMallocAligned+0x1b6>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xPaddingSize;
  11138c:	6863      	ldr	r3, [r4, #4]
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xPaddingSize );
  11138e:	1962      	adds	r2, r4, r5
						prvInsertBlockIntoFreeList( pxBlock );
  111390:	4620      	mov	r0, r4
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xPaddingSize;
  111392:	1b5b      	subs	r3, r3, r5
  111394:	6053      	str	r3, [r2, #4]
						pxBlock->xBlockSize = xPaddingSize;
  111396:	6065      	str	r5, [r4, #4]
						prvInsertBlockIntoFreeList( pxBlock );
  111398:	4614      	mov	r4, r2
  11139a:	f7ff ff6f 	bl	11127c <prvInsertBlockIntoFreeList>
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  11139e:	6862      	ldr	r2, [r4, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xHeapStructSize );
  1113a0:	f104 0508 	add.w	r5, r4, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  1113a4:	1b93      	subs	r3, r2, r6
  1113a6:	2b10      	cmp	r3, #16
  1113a8:	d908      	bls.n	1113bc <pvPortMallocAligned+0xdc>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  1113aa:	19a7      	adds	r7, r4, r6
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  1113ac:	077a      	lsls	r2, r7, #29
  1113ae:	d17a      	bne.n	1114a6 <pvPortMallocAligned+0x1c6>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  1113b0:	607b      	str	r3, [r7, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  1113b2:	4638      	mov	r0, r7
						pxBlock->xBlockSize = xWantedSize;
  1113b4:	6066      	str	r6, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  1113b6:	f7ff ff61 	bl	11127c <prvInsertBlockIntoFreeList>
  1113ba:	6862      	ldr	r2, [r4, #4]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  1113bc:	f8da 3000 	ldr.w	r3, [r10]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  1113c0:	f642 4090 	movw	r0, #11408	; 0x2c90
  1113c4:	f2c0 0013 	movt	r0, #19
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  1113c8:	1a9b      	subs	r3, r3, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  1113ca:	6801      	ldr	r1, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  1113cc:	f8ca 3000 	str.w	r3, [r10]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  1113d0:	428b      	cmp	r3, r1
					pxBlock->pxNextFreeBlock = NULL;
  1113d2:	f04f 0100 	mov.w	r1, #0
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  1113d6:	bf38      	it	cc
  1113d8:	6003      	strcc	r3, [r0, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  1113da:	f8d8 3000 	ldr.w	r3, [r8]
  1113de:	431a      	orrs	r2, r3
  1113e0:	e9c4 1200 	strd	r1, r2, [r4]
	( void ) xTaskResumeAll();
  1113e4:	f001 fc4a 	bl	112c7c <xTaskResumeAll>
		if( pvReturn == NULL )
  1113e8:	b175      	cbz	r5, 111408 <pvPortMallocAligned+0x128>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  1113ea:	076b      	lsls	r3, r5, #29
  1113ec:	d00f      	beq.n	11140e <pvPortMallocAligned+0x12e>
  1113ee:	f64e 6050 	movw	r0, #61008	; 0xee50
  1113f2:	f44f 718c 	mov.w	r1, #280	; 0x118
  1113f6:	f2c0 0011 	movt	r0, #17
  1113fa:	f7ff ff31 	bl	111260 <vMainAssertCalled>
}
  1113fe:	4628      	mov	r0, r5
  111400:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	( void ) xTaskResumeAll();
  111404:	f001 fc3a 	bl	112c7c <xTaskResumeAll>
			vApplicationMallocFailedHook();
  111408:	f7ff ff1a 	bl	111240 <vApplicationMallocFailedHook>
  11140c:	2500      	movs	r5, #0
}
  11140e:	4628      	mov	r0, r5
  111410:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT(!(xBoundary & (xBoundary - 1)));
  111414:	f64e 6050 	movw	r0, #61008	; 0xee50
  111418:	2179      	movs	r1, #121	; 0x79
  11141a:	f2c0 0011 	movt	r0, #17
  11141e:	f7ff ff1f 	bl	111260 <vMainAssertCalled>
  111422:	e767      	b.n	1112f4 <pvPortMallocAligned+0x14>
	uxAddress = ( size_t ) __heap;
  111424:	f243 310c 	movw	r1, #13068	; 0x330c
  111428:	f64c 43f4 	movw	r3, #52468	; 0xccf4
  11142c:	f2c0 0113 	movt	r1, #19
  111430:	f2c0 0304 	movt	r3, #4
  111434:	440b      	add	r3, r1
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  111436:	0748      	lsls	r0, r1, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  111438:	bf18      	it	ne
  11143a:	3107      	addne	r1, #7
	uxAddress -= xHeapStructSize;
  11143c:	f1a3 0308 	sub.w	r3, r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  111440:	f023 0307 	bic.w	r3, r3, #7
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  111444:	f642 4c90 	movw	r12, #11408	; 0x2c90
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  111448:	bf18      	it	ne
  11144a:	f021 0107 	bicne.w	r1, r1, #7
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  11144e:	1a5d      	subs	r5, r3, r1
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  111450:	f642 408c 	movw	r0, #11404	; 0x2c8c
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  111454:	f2c0 0c13 	movt	r12, #19
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  111458:	f642 4494 	movw	r4, #11412	; 0x2c94
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  11145c:	f642 4888 	movw	r8, #11400	; 0x2c88
  111460:	f04f 4e00 	mov.w	r14, #2147483648	; 0x80000000
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  111464:	f2c0 0013 	movt	r0, #19
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  111468:	f2c0 0413 	movt	r4, #19
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  11146c:	f8cc 5000 	str.w	r5, [r12]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  111470:	f2c0 0813 	movt	r8, #19
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  111474:	6005      	str	r5, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
  111476:	f04f 0c00 	mov.w	r12, #0
	pxEnd = ( void * ) uxAddress;
  11147a:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  11147c:	4670      	mov	r0, r14
	pxEnd->pxNextFreeBlock = NULL;
  11147e:	e9c3 cc00 	strd	r12, r12, [r3]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  111482:	f8c8 e000 	str.w	r14, [r8]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  111486:	e9c4 1c00 	strd	r1, r12, [r4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  11148a:	e9c1 3500 	strd	r3, r5, [r1]
  11148e:	e741      	b.n	111314 <pvPortMallocAligned+0x34>
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  111490:	4604      	mov	r4, r0
				pxPreviousBlock = &xStart;
  111492:	4608      	mov	r0, r1
  111494:	e771      	b.n	11137a <pvPortMallocAligned+0x9a>
						configASSERT( xPaddingSize >= xHeapStructSize );
  111496:	f64e 6050 	movw	r0, #61008	; 0xee50
  11149a:	21c1      	movs	r1, #193	; 0xc1
  11149c:	f2c0 0011 	movt	r0, #17
  1114a0:	f7ff fede 	bl	111260 <vMainAssertCalled>
  1114a4:	e772      	b.n	11138c <pvPortMallocAligned+0xac>
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  1114a6:	f64e 6050 	movw	r0, #61008	; 0xee50
  1114aa:	21d8      	movs	r1, #216	; 0xd8
  1114ac:	f2c0 0011 	movt	r0, #17
  1114b0:	f7ff fed6 	bl	111260 <vMainAssertCalled>
  1114b4:	6863      	ldr	r3, [r4, #4]
  1114b6:	1b9b      	subs	r3, r3, r6
  1114b8:	e77a      	b.n	1113b0 <pvPortMallocAligned+0xd0>
  1114ba:	bf00      	nop

001114bc <vPortFree>:
	if( pv != NULL )
  1114bc:	2800      	cmp	r0, #0
  1114be:	d046      	beq.n	11154e <vPortFree+0x92>
{
  1114c0:	b538      	push	{r3, r4, r5, r14}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  1114c2:	f642 4588 	movw	r5, #11400	; 0x2c88
  1114c6:	4604      	mov	r4, r0
  1114c8:	f850 3c04 	ldr.w	r3, [r0, #-4]
  1114cc:	f2c0 0513 	movt	r5, #19
  1114d0:	682a      	ldr	r2, [r5, #0]
  1114d2:	4213      	tst	r3, r2
  1114d4:	d013      	beq.n	1114fe <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  1114d6:	f850 1c08 	ldr.w	r1, [r0, #-8]
  1114da:	b309      	cbz	r1, 111520 <vPortFree+0x64>
  1114dc:	f64e 6050 	movw	r0, #61008	; 0xee50
  1114e0:	f44f 7199 	mov.w	r1, #306	; 0x132
  1114e4:	f2c0 0011 	movt	r0, #17
  1114e8:	f7ff feba 	bl	111260 <vMainAssertCalled>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  1114ec:	682a      	ldr	r2, [r5, #0]
  1114ee:	f854 3c04 	ldr.w	r3, [r4, #-4]
  1114f2:	4213      	tst	r3, r2
  1114f4:	d002      	beq.n	1114fc <vPortFree+0x40>
			if( pxLink->pxNextFreeBlock == NULL )
  1114f6:	f854 1c08 	ldr.w	r1, [r4, #-8]
  1114fa:	b189      	cbz	r1, 111520 <vPortFree+0x64>
}
  1114fc:	bd38      	pop	{r3, r4, r5, r15}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  1114fe:	f64e 6050 	movw	r0, #61008	; 0xee50
  111502:	f240 1131 	movw	r1, #305	; 0x131
  111506:	f2c0 0011 	movt	r0, #17
  11150a:	f7ff fea9 	bl	111260 <vMainAssertCalled>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  11150e:	f854 3c08 	ldr.w	r3, [r4, #-8]
  111512:	2b00      	cmp	r3, #0
  111514:	d1e2      	bne.n	1114dc <vPortFree+0x20>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  111516:	682a      	ldr	r2, [r5, #0]
  111518:	f854 3c04 	ldr.w	r3, [r4, #-4]
  11151c:	4213      	tst	r3, r2
  11151e:	d0ed      	beq.n	1114fc <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  111520:	ea23 0302 	bic.w	r3, r3, r2
  111524:	f844 3c04 	str.w	r3, [r4, #-4]
				vTaskSuspendAll();
  111528:	f001 faca 	bl	112ac0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
  11152c:	f642 438c 	movw	r3, #11404	; 0x2c8c
  111530:	f854 2c04 	ldr.w	r2, [r4, #-4]
  111534:	f2c0 0313 	movt	r3, #19
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  111538:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
  11153c:	6819      	ldr	r1, [r3, #0]
  11153e:	440a      	add	r2, r1
  111540:	601a      	str	r2, [r3, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  111542:	f7ff fe9b 	bl	11127c <prvInsertBlockIntoFreeList>
}
  111546:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
				( void ) xTaskResumeAll();
  11154a:	f001 bb97 	b.w	112c7c <xTaskResumeAll>
  11154e:	4770      	bx	r14

00111550 <malloc>:
	return pvPortMallocAligned(xWantedSize, 1);
}

void* memalign(size_t boundary, size_t size)
{
	return pvPortMallocAligned(size, boundary);
  111550:	2101      	movs	r1, #1
  111552:	f7ff bec5 	b.w	1112e0 <pvPortMallocAligned>
  111556:	bf00      	nop

00111558 <pvPortMalloc>:
  111558:	f7ff bffa 	b.w	111550 <malloc>

0011155c <calloc>:
{
	return memalign(1, size);
}

void* calloc(size_t count, size_t size)
{
  11155c:	b538      	push	{r3, r4, r5, r14}
	void* p = malloc(size * count);
  11155e:	fb00 f401 	mul.w	r4, r0, r1
	return pvPortMallocAligned(size, boundary);
  111562:	2101      	movs	r1, #1
  111564:	4620      	mov	r0, r4
  111566:	f7ff febb 	bl	1112e0 <pvPortMallocAligned>
	if(!p)
  11156a:	4605      	mov	r5, r0
  11156c:	b118      	cbz	r0, 111576 <calloc+0x1a>
		return NULL;

	memset(p,0,size * count);
  11156e:	4622      	mov	r2, r4
  111570:	2100      	movs	r1, #0
  111572:	f002 ea1c 	blx	1139ac <memset>

	return p;
}
  111576:	4628      	mov	r0, r5
  111578:	bd38      	pop	{r3, r4, r5, r15}
  11157a:	bf00      	nop

0011157c <free>:

void free(void* p)
{
	vPortFree(p);
  11157c:	f7ff bf9e 	b.w	1114bc <vPortFree>

00111580 <vListInitialise>:
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  111580:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  111584:	f100 0308 	add.w	r3, r0, #8
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  111588:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  11158a:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  11158c:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  11158e:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  111590:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  111594:	4770      	bx	r14
  111596:	bf00      	nop

00111598 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  111598:	2300      	movs	r3, #0
  11159a:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  11159c:	4770      	bx	r14
  11159e:	bf00      	nop

001115a0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
  1115a0:	6843      	ldr	r3, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
  1115a2:	6802      	ldr	r2, [r0, #0]
{
  1115a4:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  1115a6:	689c      	ldr	r4, [r3, #8]
	( pxList->uxNumberOfItems )++;
  1115a8:	3201      	adds	r2, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  1115aa:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  1115ac:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
  1115ae:	604b      	str	r3, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  1115b0:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
  1115b2:	6099      	str	r1, [r3, #8]
}
  1115b4:	f85d 4b04 	ldr.w	r4, [r13], #4
	pxNewListItem->pxContainer = pxList;
  1115b8:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
  1115ba:	6002      	str	r2, [r0, #0]
}
  1115bc:	4770      	bx	r14
  1115be:	bf00      	nop

001115c0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  1115c0:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  1115c2:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  1115c4:	1c6b      	adds	r3, r5, #1
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  1115c6:	bf18      	it	ne
  1115c8:	f100 0208 	addne.w	r2, r0, #8
	if( xValueOfInsertion == portMAX_DELAY )
  1115cc:	d101      	bne.n	1115d2 <vListInsert+0x12>
  1115ce:	e00e      	b.n	1115ee <vListInsert+0x2e>
  1115d0:	461a      	mov	r2, r3
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  1115d2:	6853      	ldr	r3, [r2, #4]
  1115d4:	681c      	ldr	r4, [r3, #0]
  1115d6:	42ac      	cmp	r4, r5
  1115d8:	d9fa      	bls.n	1115d0 <vListInsert+0x10>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
  1115da:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
  1115dc:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  1115de:	6099      	str	r1, [r3, #8]
	( pxList->uxNumberOfItems )++;
  1115e0:	3401      	adds	r4, #1
	pxNewListItem->pxPrevious = pxIterator;
  1115e2:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
  1115e4:	6051      	str	r1, [r2, #4]
	pxNewListItem->pxContainer = pxList;
  1115e6:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
  1115e8:	6004      	str	r4, [r0, #0]
}
  1115ea:	bc30      	pop	{r4, r5}
  1115ec:	4770      	bx	r14
		pxIterator = pxList->xListEnd.pxPrevious;
  1115ee:	6902      	ldr	r2, [r0, #16]
  1115f0:	6853      	ldr	r3, [r2, #4]
  1115f2:	e7f2      	b.n	1115da <vListInsert+0x1a>

001115f4 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  1115f4:	6903      	ldr	r3, [r0, #16]
{
  1115f6:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  1115f8:	e9d0 2101 	ldrd	r2, r1, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  1115fc:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  1115fe:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  111600:	6881      	ldr	r1, [r0, #8]
	if( pxList->pxIndex == pxItemToRemove )
  111602:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  111604:	604a      	str	r2, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
  111606:	681a      	ldr	r2, [r3, #0]
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  111608:	bf08      	it	eq
  11160a:	6059      	streq	r1, [r3, #4]
	pxItemToRemove->pxContainer = NULL;
  11160c:	2100      	movs	r1, #0

	return pxList->uxNumberOfItems;
}
  11160e:	f85d 4b04 	ldr.w	r4, [r13], #4
	( pxList->uxNumberOfItems )--;
  111612:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
  111614:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
  111616:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
  111618:	6818      	ldr	r0, [r3, #0]
}
  11161a:	4770      	bx	r14

0011161c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  11161c:	b570      	push	{r4, r5, r6, r14}
  11161e:	4616      	mov	r6, r2
  111620:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  111622:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111624:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  111626:	b932      	cbnz	r2, 111636 <prvCopyDataToQueue+0x1a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  111628:	6806      	ldr	r6, [r0, #0]
  11162a:	3501      	adds	r5, #1
  11162c:	2e00      	cmp	r6, #0
  11162e:	d02b      	beq.n	111688 <prvCopyDataToQueue+0x6c>
BaseType_t xReturn = pdFALSE;
  111630:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  111632:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
  111634:	bd70      	pop	{r4, r5, r6, r15}
	else if( xPosition == queueSEND_TO_BACK )
  111636:	b97e      	cbnz	r6, 111658 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  111638:	6840      	ldr	r0, [r0, #4]
  11163a:	3501      	adds	r5, #1
  11163c:	f002 e930 	blx	1138a0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  111640:	6863      	ldr	r3, [r4, #4]
  111642:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  111644:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  111646:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  111648:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  11164a:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  11164c:	d3f0      	bcc.n	111630 <prvCopyDataToQueue+0x14>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  11164e:	6823      	ldr	r3, [r4, #0]
BaseType_t xReturn = pdFALSE;
  111650:	4630      	mov	r0, r6
			pxQueue->pcWriteTo = pxQueue->pcHead;
  111652:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  111654:	63a5      	str	r5, [r4, #56]	; 0x38
}
  111656:	bd70      	pop	{r4, r5, r6, r15}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  111658:	68c0      	ldr	r0, [r0, #12]
  11165a:	f002 e922 	blx	1138a0 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  11165e:	6c22      	ldr	r2, [r4, #64]	; 0x40
  111660:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  111662:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  111664:	4252      	negs	r2, r2
  111666:	4413      	add	r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  111668:	428b      	cmp	r3, r1
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  11166a:	60e3      	str	r3, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  11166c:	bf3e      	ittt	cc
  11166e:	68a3      	ldrcc	r3, [r4, #8]
  111670:	18d2      	addcc	r2, r2, r3
  111672:	60e2      	strcc	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
  111674:	2e02      	cmp	r6, #2
BaseType_t xReturn = pdFALSE;
  111676:	bf1c      	itt	ne
  111678:	2000      	movne	r0, #0
  11167a:	3501      	addne	r5, #1
		if( xPosition == queueOVERWRITE )
  11167c:	d1d9      	bne.n	111632 <prvCopyDataToQueue+0x16>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  11167e:	2d00      	cmp	r5, #0
  111680:	d1d6      	bne.n	111630 <prvCopyDataToQueue+0x14>
  111682:	2501      	movs	r5, #1
BaseType_t xReturn = pdFALSE;
  111684:	2000      	movs	r0, #0
  111686:	e7d4      	b.n	111632 <prvCopyDataToQueue+0x16>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  111688:	6880      	ldr	r0, [r0, #8]
  11168a:	f001 fd1d 	bl	1130c8 <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  11168e:	60a6      	str	r6, [r4, #8]
  111690:	e7cf      	b.n	111632 <prvCopyDataToQueue+0x16>
  111692:	bf00      	nop

00111694 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
  111694:	b570      	push	{r4, r5, r6, r14}
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  111696:	6c84      	ldr	r4, [r0, #72]	; 0x48
	{
  111698:	b082      	sub	sp, #8
  11169a:	460d      	mov	r5, r1
  11169c:	9001      	str	r0, [sp, #4]
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
  11169e:	2c00      	cmp	r4, #0
  1116a0:	d030      	beq.n	111704 <prvNotifyQueueSetContainer+0x70>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  1116a2:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  1116a4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  1116a6:	4299      	cmp	r1, r3
  1116a8:	d222      	bcs.n	1116f0 <prvNotifyQueueSetContainer+0x5c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  1116aa:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  1116ac:	4299      	cmp	r1, r3
	BaseType_t xReturn = pdFALSE;
  1116ae:	bf28      	it	cs
  1116b0:	2600      	movcs	r6, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  1116b2:	d302      	bcc.n	1116ba <prvNotifyQueueSetContainer+0x26>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
  1116b4:	4630      	mov	r0, r6
  1116b6:	b002      	add	sp, #8
  1116b8:	bd70      	pop	{r4, r5, r6, r15}
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  1116ba:	462a      	mov	r2, r5
  1116bc:	a901      	add	r1, sp, #4
  1116be:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  1116c0:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  1116c4:	f7ff ffaa 	bl	11161c <prvCopyDataToQueue>
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  1116c8:	b26d      	sxtb	r5, r5
			if( cTxLock == queueUNLOCKED )
  1116ca:	1c6b      	adds	r3, r5, #1
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
  1116cc:	bf1e      	ittt	ne
  1116ce:	3501      	addne	r5, #1
  1116d0:	b26d      	sxtbne	r5, r5
  1116d2:	f884 5045 	strbne.w	r5, [r4, #69]	; 0x45
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  1116d6:	4606      	mov	r6, r0
			if( cTxLock == queueUNLOCKED )
  1116d8:	d1ec      	bne.n	1116b4 <prvNotifyQueueSetContainer+0x20>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  1116da:	6a63      	ldr	r3, [r4, #36]	; 0x24
  1116dc:	2b00      	cmp	r3, #0
  1116de:	d0e9      	beq.n	1116b4 <prvNotifyQueueSetContainer+0x20>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  1116e0:	f104 0024 	add.w	r0, r4, #36	; 0x24
  1116e4:	f001 fbc4 	bl	112e70 <xTaskRemoveFromEventList>
						xReturn = pdTRUE;
  1116e8:	2800      	cmp	r0, #0
  1116ea:	bf18      	it	ne
  1116ec:	2601      	movne	r6, #1
  1116ee:	e7e1      	b.n	1116b4 <prvNotifyQueueSetContainer+0x20>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  1116f0:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  1116f4:	f640 3146 	movw	r1, #2886	; 0xb46
  1116f8:	f2c0 0011 	movt	r0, #17
  1116fc:	f7ff fdb0 	bl	111260 <vMainAssertCalled>
  111700:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  111702:	e7d2      	b.n	1116aa <prvNotifyQueueSetContainer+0x16>
		configASSERT( pxQueueSetContainer );
  111704:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111708:	f640 3145 	movw	r1, #2885	; 0xb45
  11170c:	f2c0 0011 	movt	r0, #17
  111710:	f7ff fda6 	bl	111260 <vMainAssertCalled>
  111714:	e7c5      	b.n	1116a2 <prvNotifyQueueSetContainer+0xe>
  111716:	bf00      	nop

00111718 <prvCopyDataFromQueue>:
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  111718:	6c02      	ldr	r2, [r0, #64]	; 0x40
  11171a:	b172      	cbz	r2, 11173a <prvCopyDataFromQueue+0x22>
{
  11171c:	b410      	push	{r4}
  11171e:	460b      	mov	r3, r1
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  111720:	e9d0 4102 	ldrd	r4, r1, [r0, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  111724:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  111726:	42a1      	cmp	r1, r4
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  111728:	60c1      	str	r1, [r0, #12]
}
  11172a:	f85d 4b04 	ldr.w	r4, [r13], #4
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  11172e:	bf24      	itt	cs
  111730:	6801      	ldrcs	r1, [r0, #0]
  111732:	60c1      	strcs	r1, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  111734:	4618      	mov	r0, r3
  111736:	f006 ba37 	b.w	117ba8 <__memcpy_from_thumb>
  11173a:	4770      	bx	r14

0011173c <prvUnlockQueue>:
{
  11173c:	b570      	push	{r4, r5, r6, r14}
  11173e:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
  111740:	f7ff fc94 	bl	11106c <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
  111744:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
  111748:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
  11174a:	2c00      	cmp	r4, #0
  11174c:	dd1c      	ble.n	111788 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  11174e:	f105 0624 	add.w	r6, r5, #36	; 0x24
  111752:	e006      	b.n	111762 <prvUnlockQueue+0x26>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  111754:	f7ff ff9e 	bl	111694 <prvNotifyQueueSetContainer>
  111758:	b978      	cbnz	r0, 11177a <prvUnlockQueue+0x3e>
  11175a:	3c01      	subs	r4, #1
  11175c:	b2e3      	uxtb	r3, r4
  11175e:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
  111760:	b193      	cbz	r3, 111788 <prvUnlockQueue+0x4c>
				if( pxQueue->pxQueueSetContainer != NULL )
  111762:	6cab      	ldr	r3, [r5, #72]	; 0x48
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  111764:	2100      	movs	r1, #0
  111766:	4628      	mov	r0, r5
				if( pxQueue->pxQueueSetContainer != NULL )
  111768:	2b00      	cmp	r3, #0
  11176a:	d1f3      	bne.n	111754 <prvUnlockQueue+0x18>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  11176c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  11176e:	4630      	mov	r0, r6
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  111770:	b153      	cbz	r3, 111788 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  111772:	f001 fb7d 	bl	112e70 <xTaskRemoveFromEventList>
  111776:	2800      	cmp	r0, #0
  111778:	d0ef      	beq.n	11175a <prvUnlockQueue+0x1e>
  11177a:	3c01      	subs	r4, #1
						vTaskMissedYield();
  11177c:	f001 fc30 	bl	112fe0 <vTaskMissedYield>
  111780:	b2e3      	uxtb	r3, r4
  111782:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
  111784:	2b00      	cmp	r3, #0
  111786:	d1ec      	bne.n	111762 <prvUnlockQueue+0x26>
		pxQueue->cTxLock = queueUNLOCKED;
  111788:	23ff      	movs	r3, #255	; 0xff
  11178a:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
  11178e:	f7ff fca7 	bl	1110e0 <vPortExitCritical>
	taskENTER_CRITICAL();
  111792:	f7ff fc6b 	bl	11106c <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
  111796:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
  11179a:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
  11179c:	2c00      	cmp	r4, #0
  11179e:	dd16      	ble.n	1117ce <prvUnlockQueue+0x92>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  1117a0:	692b      	ldr	r3, [r5, #16]
  1117a2:	b1a3      	cbz	r3, 1117ce <prvUnlockQueue+0x92>
  1117a4:	f105 0610 	add.w	r6, r5, #16
  1117a8:	e005      	b.n	1117b6 <prvUnlockQueue+0x7a>
  1117aa:	3c01      	subs	r4, #1
  1117ac:	b2e3      	uxtb	r3, r4
  1117ae:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
  1117b0:	b16b      	cbz	r3, 1117ce <prvUnlockQueue+0x92>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  1117b2:	692b      	ldr	r3, [r5, #16]
  1117b4:	b15b      	cbz	r3, 1117ce <prvUnlockQueue+0x92>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  1117b6:	4630      	mov	r0, r6
  1117b8:	f001 fb5a 	bl	112e70 <xTaskRemoveFromEventList>
  1117bc:	2800      	cmp	r0, #0
  1117be:	d0f4      	beq.n	1117aa <prvUnlockQueue+0x6e>
  1117c0:	3c01      	subs	r4, #1
					vTaskMissedYield();
  1117c2:	f001 fc0d 	bl	112fe0 <vTaskMissedYield>
  1117c6:	b2e3      	uxtb	r3, r4
  1117c8:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
  1117ca:	2b00      	cmp	r3, #0
  1117cc:	d1f1      	bne.n	1117b2 <prvUnlockQueue+0x76>
		pxQueue->cRxLock = queueUNLOCKED;
  1117ce:	23ff      	movs	r3, #255	; 0xff
  1117d0:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
}
  1117d4:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
	taskEXIT_CRITICAL();
  1117d8:	f7ff bc82 	b.w	1110e0 <vPortExitCritical>

001117dc <xQueueGenericReset>:
{
  1117dc:	b538      	push	{r3, r4, r5, r14}
  1117de:	460d      	mov	r5, r1
	configASSERT( pxQueue );
  1117e0:	4604      	mov	r4, r0
  1117e2:	b388      	cbz	r0, 111848 <xQueueGenericReset+0x6c>
	taskENTER_CRITICAL();
  1117e4:	f7ff fc42 	bl	11106c <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  1117e8:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
  1117ec:	6822      	ldr	r2, [r4, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  1117ee:	2000      	movs	r0, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
  1117f0:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  1117f2:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  1117f6:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
  1117f8:	20ff      	movs	r0, #255	; 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  1117fa:	1acb      	subs	r3, r1, r3
		pxQueue->cRxLock = queueUNLOCKED;
  1117fc:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  111800:	4413      	add	r3, r2
		pxQueue->cTxLock = queueUNLOCKED;
  111802:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  111806:	440a      	add	r2, r1
  111808:	e9c4 2302 	strd	r2, r3, [r4, #8]
		if( xNewQueue == pdFALSE )
  11180c:	b985      	cbnz	r5, 111830 <xQueueGenericReset+0x54>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  11180e:	6923      	ldr	r3, [r4, #16]
  111810:	b91b      	cbnz	r3, 11181a <xQueueGenericReset+0x3e>
	taskEXIT_CRITICAL();
  111812:	f7ff fc65 	bl	1110e0 <vPortExitCritical>
}
  111816:	2001      	movs	r0, #1
  111818:	bd38      	pop	{r3, r4, r5, r15}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  11181a:	f104 0010 	add.w	r0, r4, #16
  11181e:	f001 fb27 	bl	112e70 <xTaskRemoveFromEventList>
  111822:	2800      	cmp	r0, #0
  111824:	d0f5      	beq.n	111812 <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
  111826:	df00      	svc	0
	taskEXIT_CRITICAL();
  111828:	f7ff fc5a 	bl	1110e0 <vPortExitCritical>
}
  11182c:	2001      	movs	r0, #1
  11182e:	bd38      	pop	{r3, r4, r5, r15}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  111830:	f104 0010 	add.w	r0, r4, #16
  111834:	f7ff fea4 	bl	111580 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  111838:	f104 0024 	add.w	r0, r4, #36	; 0x24
  11183c:	f7ff fea0 	bl	111580 <vListInitialise>
	taskEXIT_CRITICAL();
  111840:	f7ff fc4e 	bl	1110e0 <vPortExitCritical>
}
  111844:	2001      	movs	r0, #1
  111846:	bd38      	pop	{r3, r4, r5, r15}
	configASSERT( pxQueue );
  111848:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  11184c:	f240 1103 	movw	r1, #259	; 0x103
  111850:	f2c0 0011 	movt	r0, #17
  111854:	f7ff fd04 	bl	111260 <vMainAssertCalled>
  111858:	e7c4      	b.n	1117e4 <xQueueGenericReset+0x8>
  11185a:	bf00      	nop

0011185c <xQueueGenericCreateStatic>:
	{
  11185c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  111860:	460e      	mov	r6, r1
  111862:	b082      	sub	sp, #8
  111864:	4615      	mov	r5, r2
  111866:	461c      	mov	r4, r3
  111868:	f89d 8020 	ldrb.w	r8, [r13, #32]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  11186c:	4607      	mov	r7, r0
  11186e:	2800      	cmp	r0, #0
  111870:	d03d      	beq.n	1118ee <xQueueGenericCreateStatic+0x92>
		configASSERT( pxStaticQueue != NULL );
  111872:	2c00      	cmp	r4, #0
  111874:	d045      	beq.n	111902 <xQueueGenericCreateStatic+0xa6>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
  111876:	1c33      	adds	r3, r6, #0
  111878:	bf18      	it	ne
  11187a:	2301      	movne	r3, #1
  11187c:	2d00      	cmp	r5, #0
  11187e:	bf08      	it	eq
  111880:	2301      	moveq	r3, #1
  111882:	2b00      	cmp	r3, #0
  111884:	d046      	beq.n	111914 <xQueueGenericCreateStatic+0xb8>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
  111886:	fab6 f386 	clz	r3, r6
  11188a:	095b      	lsrs	r3, r3, #5
  11188c:	2d00      	cmp	r5, #0
  11188e:	bf18      	it	ne
  111890:	2301      	movne	r3, #1
  111892:	b31b      	cbz	r3, 1118dc <xQueueGenericCreateStatic+0x80>
			volatile size_t xSize = sizeof( StaticQueue_t );
  111894:	2354      	movs	r3, #84	; 0x54
  111896:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
  111898:	9b01      	ldr	r3, [sp, #4]
  11189a:	2b54      	cmp	r3, #84	; 0x54
  11189c:	d007      	beq.n	1118ae <xQueueGenericCreateStatic+0x52>
  11189e:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  1118a2:	f240 114b 	movw	r1, #331	; 0x14b
  1118a6:	f2c0 0011 	movt	r0, #17
  1118aa:	f7ff fcd9 	bl	111260 <vMainAssertCalled>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
  1118ae:	9b01      	ldr	r3, [sp, #4]
		if( pxNewQueue != NULL )
  1118b0:	b184      	cbz	r4, 1118d4 <xQueueGenericCreateStatic+0x78>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
  1118b2:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  1118b4:	2e00      	cmp	r6, #0
  1118b6:	bf08      	it	eq
  1118b8:	4625      	moveq	r5, r4
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  1118ba:	4619      	mov	r1, r3
  1118bc:	4620      	mov	r0, r4
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
  1118be:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  1118c2:	6025      	str	r5, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
  1118c4:	63e7      	str	r7, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  1118c6:	6426      	str	r6, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  1118c8:	f7ff ff88 	bl	1117dc <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
  1118cc:	f884 8050 	strb.w	r8, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
  1118d0:	2300      	movs	r3, #0
  1118d2:	64a3      	str	r3, [r4, #72]	; 0x48
	}
  1118d4:	4620      	mov	r0, r4
  1118d6:	b002      	add	sp, #8
  1118d8:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
  1118dc:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  1118e0:	f240 1143 	movw	r1, #323	; 0x143
  1118e4:	f2c0 0011 	movt	r0, #17
  1118e8:	f7ff fcba 	bl	111260 <vMainAssertCalled>
  1118ec:	e7d2      	b.n	111894 <xQueueGenericCreateStatic+0x38>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  1118ee:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  1118f2:	f44f 719d 	mov.w	r1, #314	; 0x13a
  1118f6:	f2c0 0011 	movt	r0, #17
  1118fa:	f7ff fcb1 	bl	111260 <vMainAssertCalled>
		configASSERT( pxStaticQueue != NULL );
  1118fe:	2c00      	cmp	r4, #0
  111900:	d1b9      	bne.n	111876 <xQueueGenericCreateStatic+0x1a>
  111902:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111906:	f44f 719f 	mov.w	r1, #318	; 0x13e
  11190a:	f2c0 0011 	movt	r0, #17
  11190e:	f7ff fca7 	bl	111260 <vMainAssertCalled>
  111912:	e7b0      	b.n	111876 <xQueueGenericCreateStatic+0x1a>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
  111914:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111918:	f44f 71a1 	mov.w	r1, #322	; 0x142
  11191c:	f2c0 0011 	movt	r0, #17
  111920:	f7ff fc9e 	bl	111260 <vMainAssertCalled>
  111924:	e7b6      	b.n	111894 <xQueueGenericCreateStatic+0x38>
  111926:	bf00      	nop

00111928 <xQueueGenericCreate>:
	{
  111928:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  11192a:	460d      	mov	r5, r1
  11192c:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  11192e:	4606      	mov	r6, r0
  111930:	b310      	cbz	r0, 111978 <xQueueGenericCreate+0x50>
		if( uxItemSize == ( UBaseType_t ) 0 )
  111932:	b16d      	cbz	r5, 111950 <xQueueGenericCreate+0x28>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  111934:	fb05 f006 	mul.w	r0, r5, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  111938:	3054      	adds	r0, #84	; 0x54
  11193a:	f7ff fe0d 	bl	111558 <pvPortMalloc>
		if( pxNewQueue != NULL )
  11193e:	4604      	mov	r4, r0
  111940:	b318      	cbz	r0, 11198a <xQueueGenericCreate+0x62>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  111942:	2200      	movs	r2, #0
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  111944:	f100 0354 	add.w	r3, r0, #84	; 0x54
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  111948:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  11194c:	6003      	str	r3, [r0, #0]
  11194e:	e007      	b.n	111960 <xQueueGenericCreate+0x38>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  111950:	2054      	movs	r0, #84	; 0x54
  111952:	f7ff fe01 	bl	111558 <pvPortMalloc>
		if( pxNewQueue != NULL )
  111956:	4604      	mov	r4, r0
  111958:	b1b8      	cbz	r0, 11198a <xQueueGenericCreate+0x62>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  11195a:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  11195e:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
  111960:	63e6      	str	r6, [r4, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  111962:	2101      	movs	r1, #1
	pxNewQueue->uxItemSize = uxItemSize;
  111964:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  111966:	4620      	mov	r0, r4
  111968:	f7ff ff38 	bl	1117dc <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
  11196c:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
  11196e:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
	}
  111972:	4620      	mov	r0, r4
		pxNewQueue->pxQueueSetContainer = NULL;
  111974:	64a3      	str	r3, [r4, #72]	; 0x48
	}
  111976:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  111978:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  11197c:	f44f 71bb 	mov.w	r1, #374	; 0x176
  111980:	f2c0 0011 	movt	r0, #17
  111984:	f7ff fc6c 	bl	111260 <vMainAssertCalled>
  111988:	e7d3      	b.n	111932 <xQueueGenericCreate+0xa>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  11198a:	2400      	movs	r4, #0
	}
  11198c:	4620      	mov	r0, r4
  11198e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00111990 <xQueueGenericSend>:
{
  111990:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  111994:	4689      	mov	r9, r1
  111996:	b084      	sub	sp, #16
  111998:	4698      	mov	r8, r3
	configASSERT( pxQueue );
  11199a:	4604      	mov	r4, r0
{
  11199c:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
  11199e:	2800      	cmp	r0, #0
  1119a0:	f000 809f 	beq.w	111ae2 <xQueueGenericSend+0x152>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  1119a4:	f1b9 0f00 	cmp.w	r9, #0
  1119a8:	d07f      	beq.n	111aaa <xQueueGenericSend+0x11a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  1119aa:	f1b8 0f02 	cmp.w	r8, #2
  1119ae:	d070      	beq.n	111a92 <xQueueGenericSend+0x102>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  1119b0:	f001 fb1e 	bl	112ff0 <xTaskGetSchedulerState>
  1119b4:	b918      	cbnz	r0, 1119be <xQueueGenericSend+0x2e>
  1119b6:	9b01      	ldr	r3, [sp, #4]
  1119b8:	2b00      	cmp	r3, #0
  1119ba:	f040 809b 	bne.w	111af4 <xQueueGenericSend+0x164>
{
  1119be:	f04f 0a00 	mov.w	r10, #0
  1119c2:	f1a8 0602 	sub.w	r6, r8, #2
		prvLockQueue( pxQueue );
  1119c6:	4657      	mov	r7, r10
  1119c8:	fab6 f686 	clz	r6, r6
  1119cc:	0976      	lsrs	r6, r6, #5
  1119ce:	e028      	b.n	111a22 <xQueueGenericSend+0x92>
		taskEXIT_CRITICAL();
  1119d0:	f7ff fb86 	bl	1110e0 <vPortExitCritical>
		vTaskSuspendAll();
  1119d4:	f001 f874 	bl	112ac0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  1119d8:	f7ff fb48 	bl	11106c <vPortEnterCritical>
  1119dc:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  1119e0:	2bff      	cmp	r3, #255	; 0xff
  1119e2:	bf08      	it	eq
  1119e4:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
  1119e8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  1119ec:	2bff      	cmp	r3, #255	; 0xff
  1119ee:	bf08      	it	eq
  1119f0:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
  1119f4:	f7ff fb74 	bl	1110e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  1119f8:	a901      	add	r1, sp, #4
  1119fa:	a802      	add	r0, sp, #8
  1119fc:	f001 fa94 	bl	112f28 <xTaskCheckForTimeOut>
  111a00:	2800      	cmp	r0, #0
  111a02:	d165      	bne.n	111ad0 <xQueueGenericSend+0x140>
	taskENTER_CRITICAL();
  111a04:	f7ff fb32 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  111a08:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  111a0a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  111a0c:	429a      	cmp	r2, r3
  111a0e:	d01c      	beq.n	111a4a <xQueueGenericSend+0xba>
	taskEXIT_CRITICAL();
  111a10:	f7ff fb66 	bl	1110e0 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  111a14:	4620      	mov	r0, r4
  111a16:	f7ff fe91 	bl	11173c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  111a1a:	f001 f92f 	bl	112c7c <xTaskResumeAll>
  111a1e:	f04f 0a01 	mov.w	r10, #1
		taskENTER_CRITICAL();
  111a22:	f7ff fb23 	bl	11106c <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  111a26:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111a28:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  111a2a:	4293      	cmp	r3, r2
  111a2c:	bf2c      	ite	cs
  111a2e:	4633      	movcs	r3, r6
  111a30:	f046 0301 	orrcc.w	r3, r6, #1
  111a34:	b9cb      	cbnz	r3, 111a6a <xQueueGenericSend+0xda>
				if( xTicksToWait == ( TickType_t ) 0 )
  111a36:	9d01      	ldr	r5, [sp, #4]
  111a38:	2d00      	cmp	r5, #0
  111a3a:	d043      	beq.n	111ac4 <xQueueGenericSend+0x134>
				else if( xEntryTimeSet == pdFALSE )
  111a3c:	f1ba 0f00 	cmp.w	r10, #0
  111a40:	d1c6      	bne.n	1119d0 <xQueueGenericSend+0x40>
					vTaskInternalSetTimeOutState( &xTimeOut );
  111a42:	a802      	add	r0, sp, #8
  111a44:	f001 fa62 	bl	112f0c <vTaskInternalSetTimeOutState>
  111a48:	e7c2      	b.n	1119d0 <xQueueGenericSend+0x40>
	taskEXIT_CRITICAL();
  111a4a:	f7ff fb49 	bl	1110e0 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  111a4e:	9901      	ldr	r1, [sp, #4]
  111a50:	f104 0010 	add.w	r0, r4, #16
  111a54:	f001 f9ce 	bl	112df4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  111a58:	4620      	mov	r0, r4
  111a5a:	f7ff fe6f 	bl	11173c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  111a5e:	f001 f90d 	bl	112c7c <xTaskResumeAll>
  111a62:	2800      	cmp	r0, #0
  111a64:	d1db      	bne.n	111a1e <xQueueGenericSend+0x8e>
					portYIELD_WITHIN_API();
  111a66:	df00      	svc	0
  111a68:	e7d9      	b.n	111a1e <xQueueGenericSend+0x8e>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  111a6a:	4649      	mov	r1, r9
  111a6c:	4642      	mov	r2, r8
				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
  111a6e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  111a70:	4620      	mov	r0, r4
  111a72:	f7ff fdd3 	bl	11161c <prvCopyDataToQueue>
					if( pxQueue->pxQueueSetContainer != NULL )
  111a76:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  111a78:	2b00      	cmp	r3, #0
  111a7a:	d044      	beq.n	111b06 <xQueueGenericSend+0x176>
						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
  111a7c:	2d00      	cmp	r5, #0
  111a7e:	bf08      	it	eq
  111a80:	2600      	moveq	r6, #0
  111a82:	2e00      	cmp	r6, #0
  111a84:	d045      	beq.n	111b12 <xQueueGenericSend+0x182>
				taskEXIT_CRITICAL();
  111a86:	f7ff fb2b 	bl	1110e0 <vPortExitCritical>
				return pdPASS;
  111a8a:	2001      	movs	r0, #1
}
  111a8c:	b004      	add	sp, #16
  111a8e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  111a92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  111a94:	2b01      	cmp	r3, #1
  111a96:	d08b      	beq.n	1119b0 <xQueueGenericSend+0x20>
  111a98:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111a9c:	f240 21f3 	movw	r1, #755	; 0x2f3
  111aa0:	f2c0 0011 	movt	r0, #17
  111aa4:	f7ff fbdc 	bl	111260 <vMainAssertCalled>
  111aa8:	e782      	b.n	1119b0 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111aaa:	6c23      	ldr	r3, [r4, #64]	; 0x40
  111aac:	2b00      	cmp	r3, #0
  111aae:	f43f af7c 	beq.w	1119aa <xQueueGenericSend+0x1a>
  111ab2:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111ab6:	f240 21f2 	movw	r1, #754	; 0x2f2
  111aba:	f2c0 0011 	movt	r0, #17
  111abe:	f7ff fbcf 	bl	111260 <vMainAssertCalled>
  111ac2:	e772      	b.n	1119aa <xQueueGenericSend+0x1a>
					taskEXIT_CRITICAL();
  111ac4:	f7ff fb0c 	bl	1110e0 <vPortExitCritical>
					return errQUEUE_FULL;
  111ac8:	4628      	mov	r0, r5
}
  111aca:	b004      	add	sp, #16
  111acc:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
			prvUnlockQueue( pxQueue );
  111ad0:	4620      	mov	r0, r4
  111ad2:	f7ff fe33 	bl	11173c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  111ad6:	f001 f8d1 	bl	112c7c <xTaskResumeAll>
			return errQUEUE_FULL;
  111ada:	2000      	movs	r0, #0
}
  111adc:	b004      	add	sp, #16
  111ade:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT( pxQueue );
  111ae2:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111ae6:	f240 21f1 	movw	r1, #753	; 0x2f1
  111aea:	f2c0 0011 	movt	r0, #17
  111aee:	f7ff fbb7 	bl	111260 <vMainAssertCalled>
  111af2:	e757      	b.n	1119a4 <xQueueGenericSend+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111af4:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111af8:	f240 21f6 	movw	r1, #758	; 0x2f6
  111afc:	f2c0 0011 	movt	r0, #17
  111b00:	f7ff fbae 	bl	111260 <vMainAssertCalled>
  111b04:	e75b      	b.n	1119be <xQueueGenericSend+0x2e>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  111b06:	6a63      	ldr	r3, [r4, #36]	; 0x24
  111b08:	b953      	cbnz	r3, 111b20 <xQueueGenericSend+0x190>
						else if( xYieldRequired != pdFALSE )
  111b0a:	2800      	cmp	r0, #0
  111b0c:	d0bb      	beq.n	111a86 <xQueueGenericSend+0xf6>
							queueYIELD_IF_USING_PREEMPTION();
  111b0e:	df00      	svc	0
  111b10:	e7b9      	b.n	111a86 <xQueueGenericSend+0xf6>
						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  111b12:	4641      	mov	r1, r8
  111b14:	4620      	mov	r0, r4
  111b16:	f7ff fdbd 	bl	111694 <prvNotifyQueueSetContainer>
  111b1a:	2800      	cmp	r0, #0
  111b1c:	d1f7      	bne.n	111b0e <xQueueGenericSend+0x17e>
  111b1e:	e7b2      	b.n	111a86 <xQueueGenericSend+0xf6>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  111b20:	f104 0024 	add.w	r0, r4, #36	; 0x24
  111b24:	f001 f9a4 	bl	112e70 <xTaskRemoveFromEventList>
  111b28:	2800      	cmp	r0, #0
  111b2a:	d1f0      	bne.n	111b0e <xQueueGenericSend+0x17e>
  111b2c:	e7ab      	b.n	111a86 <xQueueGenericSend+0xf6>
  111b2e:	bf00      	nop

00111b30 <xQueueCreateMutex>:
	{
  111b30:	b538      	push	{r3, r4, r5, r14}
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
  111b32:	4602      	mov	r2, r0
  111b34:	2100      	movs	r1, #0
  111b36:	2001      	movs	r0, #1
  111b38:	f7ff fef6 	bl	111928 <xQueueGenericCreate>
		if( pxNewQueue != NULL )
  111b3c:	4604      	mov	r4, r0
  111b3e:	b140      	cbz	r0, 111b52 <xQueueCreateMutex+0x22>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  111b40:	2500      	movs	r5, #0
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  111b42:	462b      	mov	r3, r5
  111b44:	462a      	mov	r2, r5
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  111b46:	60a5      	str	r5, [r4, #8]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  111b48:	4629      	mov	r1, r5
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  111b4a:	6005      	str	r5, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
  111b4c:	60c5      	str	r5, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  111b4e:	f7ff ff1f 	bl	111990 <xQueueGenericSend>
	}
  111b52:	4620      	mov	r0, r4
  111b54:	bd38      	pop	{r3, r4, r5, r15}
  111b56:	bf00      	nop

00111b58 <xQueueGenericSendFromISR>:
{
  111b58:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  111b5c:	460d      	mov	r5, r1
  111b5e:	4690      	mov	r8, r2
  111b60:	461e      	mov	r6, r3
	configASSERT( pxQueue );
  111b62:	4604      	mov	r4, r0
  111b64:	2800      	cmp	r0, #0
  111b66:	d04e      	beq.n	111c06 <xQueueGenericSendFromISR+0xae>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111b68:	b37d      	cbz	r5, 111bca <xQueueGenericSendFromISR+0x72>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  111b6a:	2e02      	cmp	r6, #2
  111b6c:	d00f      	beq.n	111b8e <xQueueGenericSendFromISR+0x36>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  111b6e:	f7ff fb13 	bl	111198 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111b72:	f7ff faf5 	bl	111160 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  111b76:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  111b78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  111b7a:	429a      	cmp	r2, r3
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111b7c:	4607      	mov	r7, r0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  111b7e:	d30f      	bcc.n	111ba0 <xQueueGenericSendFromISR+0x48>
			xReturn = errQUEUE_FULL;
  111b80:	2600      	movs	r6, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  111b82:	4638      	mov	r0, r7
  111b84:	f7ff fad6 	bl	111134 <vPortClearInterruptMask>
}
  111b88:	4630      	mov	r0, r6
  111b8a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  111b8e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  111b90:	2b01      	cmp	r3, #1
  111b92:	d141      	bne.n	111c18 <xQueueGenericSendFromISR+0xc0>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  111b94:	f7ff fb00 	bl	111198 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111b98:	f7ff fae2 	bl	111160 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  111b9c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111b9e:	4607      	mov	r7, r0
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  111ba0:	4629      	mov	r1, r5
  111ba2:	4632      	mov	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
  111ba4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  111ba8:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
  111baa:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  111bac:	f7ff fd36 	bl	11161c <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
  111bb0:	1c6b      	adds	r3, r5, #1
  111bb2:	d016      	beq.n	111be2 <xQueueGenericSendFromISR+0x8a>
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  111bb4:	4638      	mov	r0, r7
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  111bb6:	3501      	adds	r5, #1
			xReturn = pdPASS;
  111bb8:	2601      	movs	r6, #1
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  111bba:	b26d      	sxtb	r5, r5
  111bbc:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  111bc0:	f7ff fab8 	bl	111134 <vPortClearInterruptMask>
}
  111bc4:	4630      	mov	r0, r6
  111bc6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111bca:	6c23      	ldr	r3, [r4, #64]	; 0x40
  111bcc:	2b00      	cmp	r3, #0
  111bce:	d0cc      	beq.n	111b6a <xQueueGenericSendFromISR+0x12>
  111bd0:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111bd4:	f44f 7171 	mov.w	r1, #964	; 0x3c4
  111bd8:	f2c0 0011 	movt	r0, #17
  111bdc:	f7ff fb40 	bl	111260 <vMainAssertCalled>
  111be0:	e7c3      	b.n	111b6a <xQueueGenericSendFromISR+0x12>
					if( pxQueue->pxQueueSetContainer != NULL )
  111be2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  111be4:	b33b      	cbz	r3, 111c36 <xQueueGenericSendFromISR+0xde>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  111be6:	4631      	mov	r1, r6
  111be8:	4620      	mov	r0, r4
  111bea:	f7ff fd53 	bl	111694 <prvNotifyQueueSetContainer>
							if( pxHigherPriorityTaskWoken != NULL )
  111bee:	2800      	cmp	r0, #0
  111bf0:	bf18      	it	ne
  111bf2:	f1b8 0f00 	cmpne.w	r8, #0
  111bf6:	d12a      	bne.n	111c4e <xQueueGenericSendFromISR+0xf6>
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  111bf8:	4638      	mov	r0, r7
			xReturn = pdPASS;
  111bfa:	2601      	movs	r6, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  111bfc:	f7ff fa9a 	bl	111134 <vPortClearInterruptMask>
}
  111c00:	4630      	mov	r0, r6
  111c02:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( pxQueue );
  111c06:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111c0a:	f240 31c3 	movw	r1, #963	; 0x3c3
  111c0e:	f2c0 0011 	movt	r0, #17
  111c12:	f7ff fb25 	bl	111260 <vMainAssertCalled>
  111c16:	e7a7      	b.n	111b68 <xQueueGenericSendFromISR+0x10>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  111c18:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111c1c:	f240 31c5 	movw	r1, #965	; 0x3c5
  111c20:	f2c0 0011 	movt	r0, #17
  111c24:	f7ff fb1c 	bl	111260 <vMainAssertCalled>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  111c28:	f7ff fab6 	bl	111198 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111c2c:	f7ff fa98 	bl	111160 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  111c30:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  111c32:	4607      	mov	r7, r0
  111c34:	e7b4      	b.n	111ba0 <xQueueGenericSendFromISR+0x48>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  111c36:	6a63      	ldr	r3, [r4, #36]	; 0x24
  111c38:	2b00      	cmp	r3, #0
  111c3a:	d0dd      	beq.n	111bf8 <xQueueGenericSendFromISR+0xa0>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  111c3c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  111c40:	f001 f916 	bl	112e70 <xTaskRemoveFromEventList>
								if( pxHigherPriorityTaskWoken != NULL )
  111c44:	2800      	cmp	r0, #0
  111c46:	bf18      	it	ne
  111c48:	f1b8 0f00 	cmpne.w	r8, #0
  111c4c:	d0d4      	beq.n	111bf8 <xQueueGenericSendFromISR+0xa0>
									*pxHigherPriorityTaskWoken = pdTRUE;
  111c4e:	2301      	movs	r3, #1
			xReturn = pdPASS;
  111c50:	461e      	mov	r6, r3
									*pxHigherPriorityTaskWoken = pdTRUE;
  111c52:	f8c8 3000 	str.w	r3, [r8]
  111c56:	e794      	b.n	111b82 <xQueueGenericSendFromISR+0x2a>

00111c58 <xQueueReceive>:
{
  111c58:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  111c5c:	4688      	mov	r8, r1
  111c5e:	b084      	sub	sp, #16
	configASSERT( ( pxQueue ) );
  111c60:	4604      	mov	r4, r0
{
  111c62:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
  111c64:	2800      	cmp	r0, #0
  111c66:	f000 8086 	beq.w	111d76 <xQueueReceive+0x11e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111c6a:	f1b8 0f00 	cmp.w	r8, #0
  111c6e:	d076      	beq.n	111d5e <xQueueReceive+0x106>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111c70:	f001 f9be 	bl	112ff0 <xTaskGetSchedulerState>
  111c74:	b918      	cbnz	r0, 111c7e <xQueueReceive+0x26>
  111c76:	9b01      	ldr	r3, [sp, #4]
  111c78:	2b00      	cmp	r3, #0
  111c7a:	f040 8085 	bne.w	111d88 <xQueueReceive+0x130>
		taskENTER_CRITICAL();
  111c7e:	f7ff f9f5 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111c82:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111c84:	2d00      	cmp	r5, #0
  111c86:	d146      	bne.n	111d16 <xQueueReceive+0xbe>
				if( xTicksToWait == ( TickType_t ) 0 )
  111c88:	9b01      	ldr	r3, [sp, #4]
  111c8a:	2b00      	cmp	r3, #0
  111c8c:	d061      	beq.n	111d52 <xQueueReceive+0xfa>
		prvLockQueue( pxQueue );
  111c8e:	462e      	mov	r6, r5
					vTaskInternalSetTimeOutState( &xTimeOut );
  111c90:	a802      	add	r0, sp, #8
  111c92:	f001 f93b 	bl	112f0c <vTaskInternalSetTimeOutState>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  111c96:	f104 0724 	add.w	r7, r4, #36	; 0x24
  111c9a:	e012      	b.n	111cc2 <xQueueReceive+0x6a>
	taskENTER_CRITICAL();
  111c9c:	f7ff f9e6 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111ca0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111ca2:	2b00      	cmp	r3, #0
  111ca4:	d046      	beq.n	111d34 <xQueueReceive+0xdc>
	taskEXIT_CRITICAL();
  111ca6:	f7ff fa1b 	bl	1110e0 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  111caa:	4620      	mov	r0, r4
  111cac:	f7ff fd46 	bl	11173c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  111cb0:	f000 ffe4 	bl	112c7c <xTaskResumeAll>
		taskENTER_CRITICAL();
  111cb4:	f7ff f9da 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111cb8:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111cba:	bb65      	cbnz	r5, 111d16 <xQueueReceive+0xbe>
				if( xTicksToWait == ( TickType_t ) 0 )
  111cbc:	9b01      	ldr	r3, [sp, #4]
  111cbe:	2b00      	cmp	r3, #0
  111cc0:	d047      	beq.n	111d52 <xQueueReceive+0xfa>
		taskEXIT_CRITICAL();
  111cc2:	f7ff fa0d 	bl	1110e0 <vPortExitCritical>
		vTaskSuspendAll();
  111cc6:	f000 fefb 	bl	112ac0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  111cca:	f7ff f9cf 	bl	11106c <vPortEnterCritical>
  111cce:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  111cd2:	2bff      	cmp	r3, #255	; 0xff
  111cd4:	bf08      	it	eq
  111cd6:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
  111cda:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  111cde:	2bff      	cmp	r3, #255	; 0xff
  111ce0:	bf08      	it	eq
  111ce2:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
  111ce6:	f7ff f9fb 	bl	1110e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  111cea:	a901      	add	r1, sp, #4
  111cec:	a802      	add	r0, sp, #8
  111cee:	f001 f91b 	bl	112f28 <xTaskCheckForTimeOut>
  111cf2:	2800      	cmp	r0, #0
  111cf4:	d0d2      	beq.n	111c9c <xQueueReceive+0x44>
			prvUnlockQueue( pxQueue );
  111cf6:	4620      	mov	r0, r4
  111cf8:	f7ff fd20 	bl	11173c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  111cfc:	f000 ffbe 	bl	112c7c <xTaskResumeAll>
	taskENTER_CRITICAL();
  111d00:	f7ff f9b4 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111d04:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111d06:	b323      	cbz	r3, 111d52 <xQueueReceive+0xfa>
	taskEXIT_CRITICAL();
  111d08:	f7ff f9ea 	bl	1110e0 <vPortExitCritical>
		taskENTER_CRITICAL();
  111d0c:	f7ff f9ae 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111d10:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111d12:	2d00      	cmp	r5, #0
  111d14:	d0d2      	beq.n	111cbc <xQueueReceive+0x64>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  111d16:	4641      	mov	r1, r8
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  111d18:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  111d1a:	4620      	mov	r0, r4
  111d1c:	f7ff fcfc 	bl	111718 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  111d20:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  111d22:	6923      	ldr	r3, [r4, #16]
  111d24:	2b00      	cmp	r3, #0
  111d26:	d138      	bne.n	111d9a <xQueueReceive+0x142>
				taskEXIT_CRITICAL();
  111d28:	f7ff f9da 	bl	1110e0 <vPortExitCritical>
				return pdPASS;
  111d2c:	2001      	movs	r0, #1
}
  111d2e:	b004      	add	sp, #16
  111d30:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	taskEXIT_CRITICAL();
  111d34:	f7ff f9d4 	bl	1110e0 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  111d38:	9901      	ldr	r1, [sp, #4]
  111d3a:	4638      	mov	r0, r7
  111d3c:	f001 f85a 	bl	112df4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  111d40:	4620      	mov	r0, r4
  111d42:	f7ff fcfb 	bl	11173c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  111d46:	f000 ff99 	bl	112c7c <xTaskResumeAll>
  111d4a:	2800      	cmp	r0, #0
  111d4c:	d1b2      	bne.n	111cb4 <xQueueReceive+0x5c>
					portYIELD_WITHIN_API();
  111d4e:	df00      	svc	0
  111d50:	e7b0      	b.n	111cb4 <xQueueReceive+0x5c>
					taskEXIT_CRITICAL();
  111d52:	f7ff f9c5 	bl	1110e0 <vPortExitCritical>
					return errQUEUE_EMPTY;
  111d56:	2000      	movs	r0, #0
}
  111d58:	b004      	add	sp, #16
  111d5a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111d5e:	6c23      	ldr	r3, [r4, #64]	; 0x40
  111d60:	2b00      	cmp	r3, #0
  111d62:	d085      	beq.n	111c70 <xQueueReceive+0x18>
  111d64:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111d68:	f240 5104 	movw	r1, #1284	; 0x504
  111d6c:	f2c0 0011 	movt	r0, #17
  111d70:	f7ff fa76 	bl	111260 <vMainAssertCalled>
  111d74:	e77c      	b.n	111c70 <xQueueReceive+0x18>
	configASSERT( ( pxQueue ) );
  111d76:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111d7a:	f44f 61a0 	mov.w	r1, #1280	; 0x500
  111d7e:	f2c0 0011 	movt	r0, #17
  111d82:	f7ff fa6d 	bl	111260 <vMainAssertCalled>
  111d86:	e770      	b.n	111c6a <xQueueReceive+0x12>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111d88:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111d8c:	f240 5109 	movw	r1, #1289	; 0x509
  111d90:	f2c0 0011 	movt	r0, #17
  111d94:	f7ff fa64 	bl	111260 <vMainAssertCalled>
  111d98:	e771      	b.n	111c7e <xQueueReceive+0x26>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  111d9a:	f104 0010 	add.w	r0, r4, #16
  111d9e:	f001 f867 	bl	112e70 <xTaskRemoveFromEventList>
  111da2:	2800      	cmp	r0, #0
  111da4:	d0c0      	beq.n	111d28 <xQueueReceive+0xd0>
						queueYIELD_IF_USING_PREEMPTION();
  111da6:	df00      	svc	0
  111da8:	e7be      	b.n	111d28 <xQueueReceive+0xd0>
  111daa:	bf00      	nop

00111dac <xQueueSemaphoreTake>:
{
  111dac:	b5f0      	push	{r4, r5, r6, r7, r14}
	configASSERT( ( pxQueue ) );
  111dae:	4604      	mov	r4, r0
{
  111db0:	b085      	sub	sp, #20
  111db2:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
  111db4:	2800      	cmp	r0, #0
  111db6:	f000 80ad 	beq.w	111f14 <xQueueSemaphoreTake+0x168>
	configASSERT( pxQueue->uxItemSize == 0 );
  111dba:	6c23      	ldr	r3, [r4, #64]	; 0x40
  111dbc:	2b00      	cmp	r3, #0
  111dbe:	d17b      	bne.n	111eb8 <xQueueSemaphoreTake+0x10c>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111dc0:	f001 f916 	bl	112ff0 <xTaskGetSchedulerState>
  111dc4:	b918      	cbnz	r0, 111dce <xQueueSemaphoreTake+0x22>
  111dc6:	9b01      	ldr	r3, [sp, #4]
  111dc8:	2b00      	cmp	r3, #0
  111dca:	f040 8087 	bne.w	111edc <xQueueSemaphoreTake+0x130>
{
  111dce:	2700      	movs	r7, #0
  111dd0:	463d      	mov	r5, r7
		prvLockQueue( pxQueue );
  111dd2:	463e      	mov	r6, r7
  111dd4:	e00c      	b.n	111df0 <xQueueSemaphoreTake+0x44>
	taskENTER_CRITICAL();
  111dd6:	f7ff f949 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111dda:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111ddc:	2b00      	cmp	r3, #0
  111dde:	d03b      	beq.n	111e58 <xQueueSemaphoreTake+0xac>
	taskEXIT_CRITICAL();
  111de0:	f7ff f97e 	bl	1110e0 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  111de4:	4620      	mov	r0, r4
  111de6:	f7ff fca9 	bl	11173c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  111dea:	f000 ff47 	bl	112c7c <xTaskResumeAll>
  111dee:	2501      	movs	r5, #1
		taskENTER_CRITICAL();
  111df0:	f7ff f93c 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  111df4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
  111df6:	2b00      	cmp	r3, #0
  111df8:	d141      	bne.n	111e7e <xQueueSemaphoreTake+0xd2>
				if( xTicksToWait == ( TickType_t ) 0 )
  111dfa:	9b01      	ldr	r3, [sp, #4]
  111dfc:	2b00      	cmp	r3, #0
  111dfe:	d04c      	beq.n	111e9a <xQueueSemaphoreTake+0xee>
				else if( xEntryTimeSet == pdFALSE )
  111e00:	b335      	cbz	r5, 111e50 <xQueueSemaphoreTake+0xa4>
		taskEXIT_CRITICAL();
  111e02:	f7ff f96d 	bl	1110e0 <vPortExitCritical>
		vTaskSuspendAll();
  111e06:	f000 fe5b 	bl	112ac0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  111e0a:	f7ff f92f 	bl	11106c <vPortEnterCritical>
  111e0e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  111e12:	2bff      	cmp	r3, #255	; 0xff
  111e14:	bf08      	it	eq
  111e16:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
  111e1a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  111e1e:	2bff      	cmp	r3, #255	; 0xff
  111e20:	bf08      	it	eq
  111e22:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
  111e26:	f7ff f95b 	bl	1110e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  111e2a:	a901      	add	r1, sp, #4
  111e2c:	a802      	add	r0, sp, #8
  111e2e:	f001 f87b 	bl	112f28 <xTaskCheckForTimeOut>
  111e32:	2800      	cmp	r0, #0
  111e34:	d0cf      	beq.n	111dd6 <xQueueSemaphoreTake+0x2a>
			prvUnlockQueue( pxQueue );
  111e36:	4620      	mov	r0, r4
  111e38:	f7ff fc80 	bl	11173c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  111e3c:	f000 ff1e 	bl	112c7c <xTaskResumeAll>
	taskENTER_CRITICAL();
  111e40:	f7ff f914 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111e44:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111e46:	2b00      	cmp	r3, #0
  111e48:	d051      	beq.n	111eee <xQueueSemaphoreTake+0x142>
	taskEXIT_CRITICAL();
  111e4a:	f7ff f949 	bl	1110e0 <vPortExitCritical>
  111e4e:	e7ce      	b.n	111dee <xQueueSemaphoreTake+0x42>
					vTaskInternalSetTimeOutState( &xTimeOut );
  111e50:	a802      	add	r0, sp, #8
  111e52:	f001 f85b 	bl	112f0c <vTaskInternalSetTimeOutState>
  111e56:	e7d4      	b.n	111e02 <xQueueSemaphoreTake+0x56>
	taskEXIT_CRITICAL();
  111e58:	f7ff f942 	bl	1110e0 <vPortExitCritical>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  111e5c:	6823      	ldr	r3, [r4, #0]
  111e5e:	2b00      	cmp	r3, #0
  111e60:	d033      	beq.n	111eca <xQueueSemaphoreTake+0x11e>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  111e62:	9901      	ldr	r1, [sp, #4]
  111e64:	f104 0024 	add.w	r0, r4, #36	; 0x24
  111e68:	f000 ffc4 	bl	112df4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  111e6c:	4620      	mov	r0, r4
  111e6e:	f7ff fc65 	bl	11173c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  111e72:	f000 ff03 	bl	112c7c <xTaskResumeAll>
  111e76:	2800      	cmp	r0, #0
  111e78:	d1b9      	bne.n	111dee <xQueueSemaphoreTake+0x42>
					portYIELD_WITHIN_API();
  111e7a:	df00      	svc	0
  111e7c:	e7b7      	b.n	111dee <xQueueSemaphoreTake+0x42>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  111e7e:	6822      	ldr	r2, [r4, #0]
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
  111e80:	3b01      	subs	r3, #1
  111e82:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  111e84:	2a00      	cmp	r2, #0
  111e86:	d056      	beq.n	111f36 <xQueueSemaphoreTake+0x18a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  111e88:	6923      	ldr	r3, [r4, #16]
  111e8a:	2b00      	cmp	r3, #0
  111e8c:	d14b      	bne.n	111f26 <xQueueSemaphoreTake+0x17a>
				taskEXIT_CRITICAL();
  111e8e:	f7ff f927 	bl	1110e0 <vPortExitCritical>
				return pdPASS;
  111e92:	2701      	movs	r7, #1
}
  111e94:	4638      	mov	r0, r7
  111e96:	b005      	add	sp, #20
  111e98:	bdf0      	pop	{r4, r5, r6, r7, r15}
						configASSERT( xInheritanceOccurred == pdFALSE );
  111e9a:	b13f      	cbz	r7, 111eac <xQueueSemaphoreTake+0x100>
  111e9c:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111ea0:	f240 51e1 	movw	r1, #1505	; 0x5e1
  111ea4:	f2c0 0011 	movt	r0, #17
  111ea8:	f7ff f9da 	bl	111260 <vMainAssertCalled>
					taskEXIT_CRITICAL();
  111eac:	f7ff f918 	bl	1110e0 <vPortExitCritical>
					return errQUEUE_EMPTY;
  111eb0:	2700      	movs	r7, #0
}
  111eb2:	4638      	mov	r0, r7
  111eb4:	b005      	add	sp, #20
  111eb6:	bdf0      	pop	{r4, r5, r6, r7, r15}
	configASSERT( pxQueue->uxItemSize == 0 );
  111eb8:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111ebc:	f240 5195 	movw	r1, #1429	; 0x595
  111ec0:	f2c0 0011 	movt	r0, #17
  111ec4:	f7ff f9cc 	bl	111260 <vMainAssertCalled>
  111ec8:	e77a      	b.n	111dc0 <xQueueSemaphoreTake+0x14>
						taskENTER_CRITICAL();
  111eca:	f7ff f8cf 	bl	11106c <vPortEnterCritical>
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
  111ece:	68a0      	ldr	r0, [r4, #8]
  111ed0:	f001 f8a0 	bl	113014 <xTaskPriorityInherit>
  111ed4:	4607      	mov	r7, r0
						taskEXIT_CRITICAL();
  111ed6:	f7ff f903 	bl	1110e0 <vPortExitCritical>
  111eda:	e7c2      	b.n	111e62 <xQueueSemaphoreTake+0xb6>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111edc:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111ee0:	f240 519a 	movw	r1, #1434	; 0x59a
  111ee4:	f2c0 0011 	movt	r0, #17
  111ee8:	f7ff f9ba 	bl	111260 <vMainAssertCalled>
  111eec:	e76f      	b.n	111dce <xQueueSemaphoreTake+0x22>
	taskEXIT_CRITICAL();
  111eee:	f7ff f8f7 	bl	1110e0 <vPortExitCritical>
					if( xInheritanceOccurred != pdFALSE )
  111ef2:	2f00      	cmp	r7, #0
  111ef4:	d0ce      	beq.n	111e94 <xQueueSemaphoreTake+0xe8>
						taskENTER_CRITICAL();
  111ef6:	f7ff f8b9 	bl	11106c <vPortEnterCritical>
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  111efa:	6a61      	ldr	r1, [r4, #36]	; 0x24
  111efc:	b119      	cbz	r1, 111f06 <xQueueSemaphoreTake+0x15a>
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
  111efe:	6b23      	ldr	r3, [r4, #48]	; 0x30
  111f00:	6819      	ldr	r1, [r3, #0]
  111f02:	f1c1 0120 	rsb	r1, r1, #32
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  111f06:	68a0      	ldr	r0, [r4, #8]
				return errQUEUE_EMPTY;
  111f08:	2700      	movs	r7, #0
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  111f0a:	f001 f947 	bl	11319c <vTaskPriorityDisinheritAfterTimeout>
						taskEXIT_CRITICAL();
  111f0e:	f7ff f8e7 	bl	1110e0 <vPortExitCritical>
  111f12:	e7bf      	b.n	111e94 <xQueueSemaphoreTake+0xe8>
	configASSERT( ( pxQueue ) );
  111f14:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  111f18:	f240 5191 	movw	r1, #1425	; 0x591
  111f1c:	f2c0 0011 	movt	r0, #17
  111f20:	f7ff f99e 	bl	111260 <vMainAssertCalled>
  111f24:	e749      	b.n	111dba <xQueueSemaphoreTake+0xe>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  111f26:	f104 0010 	add.w	r0, r4, #16
  111f2a:	f000 ffa1 	bl	112e70 <xTaskRemoveFromEventList>
  111f2e:	2800      	cmp	r0, #0
  111f30:	d0ad      	beq.n	111e8e <xQueueSemaphoreTake+0xe2>
						queueYIELD_IF_USING_PREEMPTION();
  111f32:	df00      	svc	0
  111f34:	e7ab      	b.n	111e8e <xQueueSemaphoreTake+0xe2>
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
  111f36:	f001 f99b 	bl	113270 <pvTaskIncrementMutexHeldCount>
  111f3a:	60a0      	str	r0, [r4, #8]
  111f3c:	e7a4      	b.n	111e88 <xQueueSemaphoreTake+0xdc>
  111f3e:	bf00      	nop

00111f40 <xQueuePeek>:
{
  111f40:	b5f0      	push	{r4, r5, r6, r7, r14}
  111f42:	460f      	mov	r7, r1
  111f44:	b085      	sub	sp, #20
	configASSERT( ( pxQueue ) );
  111f46:	4604      	mov	r4, r0
{
  111f48:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
  111f4a:	2800      	cmp	r0, #0
  111f4c:	f000 8081 	beq.w	112052 <xQueuePeek+0x112>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  111f50:	2f00      	cmp	r7, #0
  111f52:	d072      	beq.n	11203a <xQueuePeek+0xfa>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  111f54:	f001 f84c 	bl	112ff0 <xTaskGetSchedulerState>
  111f58:	b918      	cbnz	r0, 111f62 <xQueuePeek+0x22>
  111f5a:	9b01      	ldr	r3, [sp, #4]
  111f5c:	2b00      	cmp	r3, #0
  111f5e:	f040 8081 	bne.w	112064 <xQueuePeek+0x124>
		taskENTER_CRITICAL();
  111f62:	f7ff f883 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111f66:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111f68:	2d00      	cmp	r5, #0
  111f6a:	d145      	bne.n	111ff8 <xQueuePeek+0xb8>
				if( xTicksToWait == ( TickType_t ) 0 )
  111f6c:	9b01      	ldr	r3, [sp, #4]
  111f6e:	2b00      	cmp	r3, #0
  111f70:	d05e      	beq.n	112030 <xQueuePeek+0xf0>
					vTaskInternalSetTimeOutState( &xTimeOut );
  111f72:	a802      	add	r0, sp, #8
  111f74:	f000 ffca 	bl	112f0c <vTaskInternalSetTimeOutState>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  111f78:	f104 0624 	add.w	r6, r4, #36	; 0x24
  111f7c:	e012      	b.n	111fa4 <xQueuePeek+0x64>
	taskENTER_CRITICAL();
  111f7e:	f7ff f875 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111f82:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111f84:	2b00      	cmp	r3, #0
  111f86:	d044      	beq.n	112012 <xQueuePeek+0xd2>
	taskEXIT_CRITICAL();
  111f88:	f7ff f8aa 	bl	1110e0 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  111f8c:	4620      	mov	r0, r4
  111f8e:	f7ff fbd5 	bl	11173c <prvUnlockQueue>
				( void ) xTaskResumeAll();
  111f92:	f000 fe73 	bl	112c7c <xTaskResumeAll>
		taskENTER_CRITICAL();
  111f96:	f7ff f869 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111f9a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111f9c:	bb63      	cbnz	r3, 111ff8 <xQueuePeek+0xb8>
				if( xTicksToWait == ( TickType_t ) 0 )
  111f9e:	9b01      	ldr	r3, [sp, #4]
  111fa0:	2b00      	cmp	r3, #0
  111fa2:	d045      	beq.n	112030 <xQueuePeek+0xf0>
		taskEXIT_CRITICAL();
  111fa4:	f7ff f89c 	bl	1110e0 <vPortExitCritical>
		vTaskSuspendAll();
  111fa8:	f000 fd8a 	bl	112ac0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  111fac:	f7ff f85e 	bl	11106c <vPortEnterCritical>
  111fb0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  111fb4:	2bff      	cmp	r3, #255	; 0xff
  111fb6:	bf08      	it	eq
  111fb8:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
  111fbc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  111fc0:	2bff      	cmp	r3, #255	; 0xff
  111fc2:	bf08      	it	eq
  111fc4:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
  111fc8:	f7ff f88a 	bl	1110e0 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  111fcc:	a901      	add	r1, sp, #4
  111fce:	a802      	add	r0, sp, #8
  111fd0:	f000 ffaa 	bl	112f28 <xTaskCheckForTimeOut>
  111fd4:	2800      	cmp	r0, #0
  111fd6:	d0d2      	beq.n	111f7e <xQueuePeek+0x3e>
			prvUnlockQueue( pxQueue );
  111fd8:	4620      	mov	r0, r4
  111fda:	f7ff fbaf 	bl	11173c <prvUnlockQueue>
			( void ) xTaskResumeAll();
  111fde:	f000 fe4d 	bl	112c7c <xTaskResumeAll>
	taskENTER_CRITICAL();
  111fe2:	f7ff f843 	bl	11106c <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  111fe6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  111fe8:	b313      	cbz	r3, 112030 <xQueuePeek+0xf0>
	taskEXIT_CRITICAL();
  111fea:	f7ff f879 	bl	1110e0 <vPortExitCritical>
		taskENTER_CRITICAL();
  111fee:	f7ff f83d 	bl	11106c <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  111ff2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  111ff4:	2b00      	cmp	r3, #0
  111ff6:	d0d2      	beq.n	111f9e <xQueuePeek+0x5e>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  111ff8:	4639      	mov	r1, r7
  111ffa:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  111ffc:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  111ffe:	f7ff fb8b 	bl	111718 <prvCopyDataFromQueue>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  112002:	6a63      	ldr	r3, [r4, #36]	; 0x24
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  112004:	60e5      	str	r5, [r4, #12]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  112006:	bbb3      	cbnz	r3, 112076 <xQueuePeek+0x136>
				taskEXIT_CRITICAL();
  112008:	f7ff f86a 	bl	1110e0 <vPortExitCritical>
				return pdPASS;
  11200c:	2001      	movs	r0, #1
}
  11200e:	b005      	add	sp, #20
  112010:	bdf0      	pop	{r4, r5, r6, r7, r15}
	taskEXIT_CRITICAL();
  112012:	f7ff f865 	bl	1110e0 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  112016:	9901      	ldr	r1, [sp, #4]
  112018:	4630      	mov	r0, r6
  11201a:	f000 feeb 	bl	112df4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  11201e:	4620      	mov	r0, r4
  112020:	f7ff fb8c 	bl	11173c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  112024:	f000 fe2a 	bl	112c7c <xTaskResumeAll>
  112028:	2800      	cmp	r0, #0
  11202a:	d1e0      	bne.n	111fee <xQueuePeek+0xae>
					portYIELD_WITHIN_API();
  11202c:	df00      	svc	0
  11202e:	e7de      	b.n	111fee <xQueuePeek+0xae>
					taskEXIT_CRITICAL();
  112030:	f7ff f856 	bl	1110e0 <vPortExitCritical>
					return errQUEUE_EMPTY;
  112034:	2000      	movs	r0, #0
}
  112036:	b005      	add	sp, #20
  112038:	bdf0      	pop	{r4, r5, r6, r7, r15}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  11203a:	6c23      	ldr	r3, [r4, #64]	; 0x40
  11203c:	2b00      	cmp	r3, #0
  11203e:	d089      	beq.n	111f54 <xQueuePeek+0x14>
  112040:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  112044:	f240 616c 	movw	r1, #1644	; 0x66c
  112048:	f2c0 0011 	movt	r0, #17
  11204c:	f7ff f908 	bl	111260 <vMainAssertCalled>
  112050:	e780      	b.n	111f54 <xQueuePeek+0x14>
	configASSERT( ( pxQueue ) );
  112052:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  112056:	f44f 61cd 	mov.w	r1, #1640	; 0x668
  11205a:	f2c0 0011 	movt	r0, #17
  11205e:	f7ff f8ff 	bl	111260 <vMainAssertCalled>
  112062:	e775      	b.n	111f50 <xQueuePeek+0x10>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  112064:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  112068:	f240 6171 	movw	r1, #1649	; 0x671
  11206c:	f2c0 0011 	movt	r0, #17
  112070:	f7ff f8f6 	bl	111260 <vMainAssertCalled>
  112074:	e775      	b.n	111f62 <xQueuePeek+0x22>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  112076:	f104 0024 	add.w	r0, r4, #36	; 0x24
  11207a:	f000 fef9 	bl	112e70 <xTaskRemoveFromEventList>
  11207e:	2800      	cmp	r0, #0
  112080:	d0c2      	beq.n	112008 <xQueuePeek+0xc8>
						queueYIELD_IF_USING_PREEMPTION();
  112082:	df00      	svc	0
  112084:	e7c0      	b.n	112008 <xQueuePeek+0xc8>
  112086:	bf00      	nop

00112088 <vQueueDelete>:
{
  112088:	b510      	push	{r4, r14}
	configASSERT( pxQueue );
  11208a:	4604      	mov	r4, r0
  11208c:	b1f8      	cbz	r0, 1120ce <vQueueDelete+0x46>
  11208e:	f642 409c 	movw	r0, #11420	; 0x2c9c
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  112092:	2200      	movs	r2, #0
  112094:	f2c0 0013 	movt	r0, #19
  112098:	4603      	mov	r3, r0
			if( xQueueRegistry[ ux ].xHandle == xQueue )
  11209a:	6859      	ldr	r1, [r3, #4]
  11209c:	3308      	adds	r3, #8
  11209e:	428c      	cmp	r4, r1
  1120a0:	d006      	beq.n	1120b0 <vQueueDelete+0x28>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  1120a2:	3201      	adds	r2, #1
  1120a4:	2a08      	cmp	r2, #8
  1120a6:	d1f8      	bne.n	11209a <vQueueDelete+0x12>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
  1120a8:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  1120ac:	b153      	cbz	r3, 1120c4 <vQueueDelete+0x3c>
}
  1120ae:	bd10      	pop	{r4, r15}
				xQueueRegistry[ ux ].pcQueueName = NULL;
  1120b0:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
  1120b2:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
				xQueueRegistry[ ux ].pcQueueName = NULL;
  1120b6:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
  1120ba:	604b      	str	r3, [r1, #4]
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
  1120bc:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  1120c0:	2b00      	cmp	r3, #0
  1120c2:	d1f4      	bne.n	1120ae <vQueueDelete+0x26>
			vPortFree( pxQueue );
  1120c4:	4620      	mov	r0, r4
}
  1120c6:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
			vPortFree( pxQueue );
  1120ca:	f7ff b9f7 	b.w	1114bc <vPortFree>
	configASSERT( pxQueue );
  1120ce:	f64e 60bc 	movw	r0, #61116	; 0xeebc
  1120d2:	f240 71b7 	movw	r1, #1975	; 0x7b7
  1120d6:	f2c0 0011 	movt	r0, #17
  1120da:	f7ff f8c1 	bl	111260 <vMainAssertCalled>
  1120de:	e7d6      	b.n	11208e <vQueueDelete+0x6>

001120e0 <vQueueAddToRegistry>:
	{
  1120e0:	b430      	push	{r4, r5}
  1120e2:	f642 449c 	movw	r4, #11420	; 0x2c9c
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  1120e6:	2300      	movs	r3, #0
  1120e8:	f2c0 0413 	movt	r4, #19
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
  1120ec:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
  1120f0:	00dd      	lsls	r5, r3, #3
  1120f2:	b122      	cbz	r2, 1120fe <vQueueAddToRegistry+0x1e>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  1120f4:	3301      	adds	r3, #1
  1120f6:	2b08      	cmp	r3, #8
  1120f8:	d1f8      	bne.n	1120ec <vQueueAddToRegistry+0xc>
	}
  1120fa:	bc30      	pop	{r4, r5}
  1120fc:	4770      	bx	r14
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
  1120fe:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
  112102:	4425      	add	r5, r4
  112104:	6068      	str	r0, [r5, #4]
	}
  112106:	bc30      	pop	{r4, r5}
  112108:	4770      	bx	r14
  11210a:	bf00      	nop

0011210c <vQueueWaitForMessageRestricted>:
	{
  11210c:	b570      	push	{r4, r5, r6, r14}
  11210e:	4604      	mov	r4, r0
  112110:	460d      	mov	r5, r1
  112112:	4616      	mov	r6, r2
		prvLockQueue( pxQueue );
  112114:	f7fe ffaa 	bl	11106c <vPortEnterCritical>
  112118:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  11211c:	2bff      	cmp	r3, #255	; 0xff
  11211e:	bf04      	itt	eq
  112120:	2300      	moveq	r3, #0
  112122:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
  112126:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  11212a:	2bff      	cmp	r3, #255	; 0xff
  11212c:	bf04      	itt	eq
  11212e:	2300      	moveq	r3, #0
  112130:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
  112134:	f7fe ffd4 	bl	1110e0 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  112138:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  11213a:	b92b      	cbnz	r3, 112148 <vQueueWaitForMessageRestricted+0x3c>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  11213c:	4632      	mov	r2, r6
  11213e:	4629      	mov	r1, r5
  112140:	f104 0024 	add.w	r0, r4, #36	; 0x24
  112144:	f000 fe72 	bl	112e2c <vTaskPlaceOnEventListRestricted>
		prvUnlockQueue( pxQueue );
  112148:	4620      	mov	r0, r4
	}
  11214a:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
		prvUnlockQueue( pxQueue );
  11214e:	f7ff baf5 	b.w	11173c <prvUnlockQueue>
  112152:	bf00      	nop

00112154 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  112154:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
  112158:	4606      	mov	r6, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  11215a:	f7fe ff87 	bl	11106c <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  11215e:	f642 736c 	movw	r3, #12140	; 0x2f6c
		if( pxCurrentTCB == NULL )
  112162:	f642 45dc 	movw	r5, #11484	; 0x2cdc
		uxCurrentNumberOfTasks++;
  112166:	f2c0 0313 	movt	r3, #19
		if( pxCurrentTCB == NULL )
  11216a:	f2c0 0513 	movt	r5, #19
		uxCurrentNumberOfTasks++;
  11216e:	681a      	ldr	r2, [r3, #0]
  112170:	3201      	adds	r2, #1
  112172:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
  112174:	682a      	ldr	r2, [r5, #0]
  112176:	2a00      	cmp	r2, #0
  112178:	d03a      	beq.n	1121f0 <prvAddNewTaskToReadyList+0x9c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  11217a:	f642 78c8 	movw	r8, #12232	; 0x2fc8
  11217e:	f642 49e8 	movw	r9, #11496	; 0x2ce8
  112182:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  112184:	f2c0 0813 	movt	r8, #19
  112188:	f2c0 0913 	movt	r9, #19
  11218c:	f8d8 3000 	ldr.w	r3, [r8]
  112190:	b323      	cbz	r3, 1121dc <prvAddNewTaskToReadyList+0x88>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  112192:	f642 747c 	movw	r4, #12156	; 0x2f7c
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  112196:	f642 7280 	movw	r2, #12160	; 0x2f80
		uxTaskNumber++;
  11219a:	f2c0 0413 	movt	r4, #19
		prvAddTaskToReadyList( pxNewTCB );
  11219e:	2301      	movs	r3, #1
  1121a0:	f2c0 0213 	movt	r2, #19
  1121a4:	eb01 0081 	add.w	r0, r1, r1, lsl #2
		uxTaskNumber++;
  1121a8:	6827      	ldr	r7, [r4, #0]
		prvAddTaskToReadyList( pxNewTCB );
  1121aa:	408b      	lsls	r3, r1
  1121ac:	6811      	ldr	r1, [r2, #0]
		uxTaskNumber++;
  1121ae:	3701      	adds	r7, #1
		prvAddTaskToReadyList( pxNewTCB );
  1121b0:	eb09 0080 	add.w	r0, r9, r0, lsl #2
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  1121b4:	64b7      	str	r7, [r6, #72]	; 0x48
		prvAddTaskToReadyList( pxNewTCB );
  1121b6:	430b      	orrs	r3, r1
		uxTaskNumber++;
  1121b8:	6027      	str	r7, [r4, #0]
		prvAddTaskToReadyList( pxNewTCB );
  1121ba:	1d31      	adds	r1, r6, #4
  1121bc:	6013      	str	r3, [r2, #0]
  1121be:	f7ff f9ef 	bl	1115a0 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  1121c2:	f7fe ff8d 	bl	1110e0 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
  1121c6:	f8d8 3000 	ldr.w	r3, [r8]
  1121ca:	b12b      	cbz	r3, 1121d8 <prvAddNewTaskToReadyList+0x84>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  1121cc:	682a      	ldr	r2, [r5, #0]
  1121ce:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  1121d0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  1121d2:	429a      	cmp	r2, r3
  1121d4:	d200      	bcs.n	1121d8 <prvAddNewTaskToReadyList+0x84>
		{
			taskYIELD_IF_USING_PREEMPTION();
  1121d6:	df00      	svc	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  1121d8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  1121dc:	682b      	ldr	r3, [r5, #0]
  1121de:	f642 49e8 	movw	r9, #11496	; 0x2ce8
  1121e2:	f2c0 0913 	movt	r9, #19
  1121e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1121e8:	428b      	cmp	r3, r1
					pxCurrentTCB = pxNewTCB;
  1121ea:	bf98      	it	ls
  1121ec:	602e      	strls	r6, [r5, #0]
  1121ee:	e7d0      	b.n	112192 <prvAddNewTaskToReadyList+0x3e>
			pxCurrentTCB = pxNewTCB;
  1121f0:	602e      	str	r6, [r5, #0]
  1121f2:	f642 49e8 	movw	r9, #11496	; 0x2ce8
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  1121f6:	681b      	ldr	r3, [r3, #0]
  1121f8:	2b01      	cmp	r3, #1
  1121fa:	d007      	beq.n	11220c <prvAddNewTaskToReadyList+0xb8>
  1121fc:	f642 78c8 	movw	r8, #12232	; 0x2fc8
  112200:	f2c0 0913 	movt	r9, #19
  112204:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  112206:	f2c0 0813 	movt	r8, #19
  11220a:	e7c2      	b.n	112192 <prvAddNewTaskToReadyList+0x3e>
  11220c:	f2c0 0913 	movt	r9, #19
  112210:	464c      	mov	r4, r9
  112212:	f509 7720 	add.w	r7, r9, #640	; 0x280
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  112216:	4620      	mov	r0, r4
  112218:	3414      	adds	r4, #20
  11221a:	f7ff f9b1 	bl	111580 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  11221e:	42a7      	cmp	r7, r4
  112220:	d1f9      	bne.n	112216 <prvAddNewTaskToReadyList+0xc2>
	}

	vListInitialise( &xDelayedTaskList1 );
  112222:	f642 7784 	movw	r7, #12164	; 0x2f84
	vListInitialise( &xDelayedTaskList2 );
  112226:	f642 7498 	movw	r4, #12184	; 0x2f98
	vListInitialise( &xDelayedTaskList1 );
  11222a:	f2c0 0713 	movt	r7, #19
  11222e:	4638      	mov	r0, r7
	vListInitialise( &xDelayedTaskList2 );
  112230:	f2c0 0413 	movt	r4, #19
	vListInitialise( &xDelayedTaskList1 );
  112234:	f7ff f9a4 	bl	111580 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  112238:	4620      	mov	r0, r4
  11223a:	f7ff f9a1 	bl	111580 <vListInitialise>
	vListInitialise( &xPendingReadyList );
  11223e:	f642 70b4 	movw	r0, #12212	; 0x2fb4
  112242:	f642 78c8 	movw	r8, #12232	; 0x2fc8
  112246:	f2c0 0013 	movt	r0, #19
  11224a:	f7ff f999 	bl	111580 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  11224e:	f642 70e0 	movw	r0, #12256	; 0x2fe0
  112252:	f2c0 0013 	movt	r0, #19
  112256:	f7ff f993 	bl	111580 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  11225a:	f642 70cc 	movw	r0, #12236	; 0x2fcc
  11225e:	f2c0 0013 	movt	r0, #19
  112262:	f7ff f98d 	bl	111580 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  112266:	f642 42e0 	movw	r2, #11488	; 0x2ce0
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  11226a:	f642 43e4 	movw	r3, #11492	; 0x2ce4
	pxDelayedTaskList = &xDelayedTaskList1;
  11226e:	f2c0 0213 	movt	r2, #19
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  112272:	f2c0 0313 	movt	r3, #19
	pxDelayedTaskList = &xDelayedTaskList1;
  112276:	6017      	str	r7, [r2, #0]
  112278:	f2c0 0813 	movt	r8, #19
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  11227c:	601c      	str	r4, [r3, #0]
  11227e:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  112280:	e787      	b.n	112192 <prvAddNewTaskToReadyList+0x3e>
  112282:	bf00      	nop

00112284 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  112284:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  112286:	f642 73f4 	movw	r3, #12276	; 0x2ff4
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  11228a:	f642 44dc 	movw	r4, #11484	; 0x2cdc
const TickType_t xConstTickCount = xTickCount;
  11228e:	f2c0 0313 	movt	r3, #19
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  112292:	2200      	movs	r2, #0
  112294:	f2c0 0413 	movt	r4, #19
{
  112298:	4606      	mov	r6, r0
  11229a:	460f      	mov	r7, r1
const TickType_t xConstTickCount = xTickCount;
  11229c:	681d      	ldr	r5, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  11229e:	6823      	ldr	r3, [r4, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1122a0:	6820      	ldr	r0, [r4, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  1122a2:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1122a6:	3004      	adds	r0, #4
  1122a8:	f7ff f9a4 	bl	1115f4 <uxListRemove>
  1122ac:	b958      	cbnz	r0, 1122c6 <prvAddCurrentTaskToDelayedList+0x42>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
  1122ae:	6822      	ldr	r2, [r4, #0]
  1122b0:	f642 7380 	movw	r3, #12160	; 0x2f80
  1122b4:	2101      	movs	r1, #1
  1122b6:	f2c0 0313 	movt	r3, #19
  1122ba:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  1122bc:	681a      	ldr	r2, [r3, #0]
  1122be:	4081      	lsls	r1, r0
  1122c0:	ea22 0201 	bic.w	r2, r2, r1
  1122c4:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  1122c6:	f1a6 33ff 	sub.w	r3, r6, #4294967295	; 0xffffffff
  1122ca:	fab3 f383 	clz	r3, r3
  1122ce:	2f00      	cmp	r7, #0
  1122d0:	ea4f 1353 	mov.w	r3, r3, lsr #5
  1122d4:	bf08      	it	eq
  1122d6:	2300      	moveq	r3, #0
  1122d8:	bb03      	cbnz	r3, 11231c <prvAddCurrentTaskToDelayedList+0x98>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  1122da:	6823      	ldr	r3, [r4, #0]
  1122dc:	19ad      	adds	r5, r5, r6
  1122de:	605d      	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
  1122e0:	d211      	bcs.n	112306 <prvAddCurrentTaskToDelayedList+0x82>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  1122e2:	f642 43e0 	movw	r3, #11488	; 0x2ce0
  1122e6:	f2c0 0313 	movt	r3, #19
  1122ea:	6818      	ldr	r0, [r3, #0]
  1122ec:	6821      	ldr	r1, [r4, #0]
  1122ee:	3104      	adds	r1, #4
  1122f0:	f7ff f966 	bl	1115c0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  1122f4:	f642 73ac 	movw	r3, #12204	; 0x2fac
  1122f8:	f2c0 0313 	movt	r3, #19
  1122fc:	681a      	ldr	r2, [r3, #0]
  1122fe:	42aa      	cmp	r2, r5
				{
					xNextTaskUnblockTime = xTimeToWake;
  112300:	bf88      	it	hi
  112302:	601d      	strhi	r5, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  112304:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  112306:	f642 43e4 	movw	r3, #11492	; 0x2ce4
  11230a:	f2c0 0313 	movt	r3, #19
  11230e:	6818      	ldr	r0, [r3, #0]
  112310:	6821      	ldr	r1, [r4, #0]
}
  112312:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  112316:	3104      	adds	r1, #4
  112318:	f7ff b952 	b.w	1115c0 <vListInsert>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  11231c:	6821      	ldr	r1, [r4, #0]
  11231e:	f642 70cc 	movw	r0, #12236	; 0x2fcc
  112322:	f2c0 0013 	movt	r0, #19
  112326:	3104      	adds	r1, #4
}
  112328:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  11232c:	f7ff b938 	b.w	1115a0 <vListInsertEnd>

00112330 <prvResetNextTaskUnblockTime.part.0>:
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112330:	f642 42e0 	movw	r2, #11488	; 0x2ce0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  112334:	f642 73ac 	movw	r3, #12204	; 0x2fac
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112338:	f2c0 0213 	movt	r2, #19
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  11233c:	f2c0 0313 	movt	r3, #19
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112340:	6812      	ldr	r2, [r2, #0]
  112342:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  112344:	68d2      	ldr	r2, [r2, #12]
  112346:	6852      	ldr	r2, [r2, #4]
  112348:	601a      	str	r2, [r3, #0]
}
  11234a:	4770      	bx	r14

0011234c <prvTaskIsTaskSuspended>:
	{
  11234c:	b510      	push	{r4, r14}
		configASSERT( xTask );
  11234e:	4604      	mov	r4, r0
  112350:	b1a8      	cbz	r0, 11237e <prvTaskIsTaskSuspended+0x32>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  112352:	6962      	ldr	r2, [r4, #20]
  112354:	f642 73cc 	movw	r3, #12236	; 0x2fcc
  112358:	f2c0 0313 	movt	r3, #19
  11235c:	429a      	cmp	r2, r3
	BaseType_t xReturn = pdFALSE;
  11235e:	bf18      	it	ne
  112360:	2200      	movne	r2, #0
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  112362:	d10a      	bne.n	11237a <prvTaskIsTaskSuspended+0x2e>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  112364:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  112366:	f642 70b4 	movw	r0, #12212	; 0x2fb4
  11236a:	f2c0 0013 	movt	r0, #19
	BaseType_t xReturn = pdFALSE;
  11236e:	1a1a      	subs	r2, r3, r0
  112370:	bf18      	it	ne
  112372:	2201      	movne	r2, #1
  112374:	2b00      	cmp	r3, #0
  112376:	bf18      	it	ne
  112378:	2200      	movne	r2, #0
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  11237a:	4610      	mov	r0, r2
  11237c:	bd10      	pop	{r4, r15}
		configASSERT( xTask );
  11237e:	f64e 7018 	movw	r0, #61208	; 0xef18
  112382:	f240 7111 	movw	r1, #1809	; 0x711
  112386:	f2c0 0011 	movt	r0, #17
  11238a:	f7fe ff69 	bl	111260 <vMainAssertCalled>
  11238e:	e7e0      	b.n	112352 <prvTaskIsTaskSuspended+0x6>

00112390 <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  112390:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  112394:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  112396:	ea4f 0982 	mov.w	r9, r2, lsl #2
  11239a:	464a      	mov	r2, r9
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  11239c:	4607      	mov	r7, r0
  11239e:	468a      	mov	r10, r1
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  1123a0:	21a5      	movs	r1, #165	; 0xa5
  1123a2:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  1123a4:	4698      	mov	r8, r3
  1123a6:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  1123aa:	f001 eb00 	blx	1139ac <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  1123ae:	6b23      	ldr	r3, [r4, #48]	; 0x30
  1123b0:	f1a9 0904 	sub.w	r9, r9, #4
  1123b4:	4499      	add	r9, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  1123b6:	f029 0907 	bic.w	r9, r9, #7
	if( pcName != NULL )
  1123ba:	f1ba 0f00 	cmp.w	r10, #0
  1123be:	d038      	beq.n	112432 <prvInitialiseNewTask.isra.2+0xa2>
  1123c0:	f10a 33ff 	add.w	r3, r10, #4294967295	; 0xffffffff
  1123c4:	f10a 0113 	add.w	r1, r10, #19
  1123c8:	f104 0233 	add.w	r2, r4, #51	; 0x33
  1123cc:	e001      	b.n	1123d2 <prvInitialiseNewTask.isra.2+0x42>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  1123ce:	428b      	cmp	r3, r1
  1123d0:	d006      	beq.n	1123e0 <prvInitialiseNewTask.isra.2+0x50>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  1123d2:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  1123d6:	f802 0f01 	strb.w	r0, [r2, #1]!
			if( pcName[ x ] == ( char ) 0x00 )
  1123da:	7818      	ldrb	r0, [r3, #0]
  1123dc:	2800      	cmp	r0, #0
  1123de:	d1f6      	bne.n	1123ce <prvInitialiseNewTask.isra.2+0x3e>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  1123e0:	2300      	movs	r3, #0
  1123e2:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
		pxNewTCB->uxMutexesHeld = 0;
  1123e6:	f04f 0a00 	mov.w	r10, #0
  1123ea:	2d1f      	cmp	r5, #31
  1123ec:	bf28      	it	cs
  1123ee:	251f      	movcs	r5, #31
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  1123f0:	1d20      	adds	r0, r4, #4
	pxNewTCB->uxPriority = uxPriority;
  1123f2:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxMutexesHeld = 0;
  1123f4:	e9c4 5a14 	strd	r5, r10, [r4, #80]	; 0x50
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1123f8:	f1c5 0520 	rsb	r5, r5, #32
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  1123fc:	f7ff f8cc 	bl	111598 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  112400:	f104 0018 	add.w	r0, r4, #24
  112404:	f7ff f8c8 	bl	111598 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
  112408:	f8c4 a05c 	str.w	r10, [r4, #92]	; 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  11240c:	4642      	mov	r2, r8
  11240e:	4639      	mov	r1, r7
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  112410:	61a5      	str	r5, [r4, #24]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  112412:	4648      	mov	r0, r9
		pxNewTCB->ulRunTimeCounter = 0UL;
  112414:	f8c4 a058 	str.w	r10, [r4, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  112418:	f884 a060 	strb.w	r10, [r4, #96]	; 0x60
		pxNewTCB->ucDelayAborted = pdFALSE;
  11241c:	f884 a062 	strb.w	r10, [r4, #98]	; 0x62
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  112420:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  112422:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  112424:	f7fe fd54 	bl	110ed0 <pxPortInitialiseStack>
  112428:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
  11242a:	b106      	cbz	r6, 11242e <prvInitialiseNewTask.isra.2+0x9e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  11242c:	6034      	str	r4, [r6, #0]
}
  11242e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  112432:	f884 a034 	strb.w	r10, [r4, #52]	; 0x34
  112436:	e7d6      	b.n	1123e6 <prvInitialiseNewTask.isra.2+0x56>

00112438 <prvDeleteTCB>:
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
  112438:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
  11243c:	b163      	cbz	r3, 112458 <prvDeleteTCB+0x20>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
  11243e:	2b01      	cmp	r3, #1
  112440:	d014      	beq.n	11246c <prvDeleteTCB+0x34>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
  112442:	2b02      	cmp	r3, #2
  112444:	d007      	beq.n	112456 <prvDeleteTCB+0x1e>
  112446:	f64e 7018 	movw	r0, #61208	; 0xef18
  11244a:	f640 7122 	movw	r1, #3874	; 0xf22
  11244e:	f2c0 0011 	movt	r0, #17
  112452:	f7fe bf05 	b.w	111260 <vMainAssertCalled>
  112456:	4770      	bx	r14
	{
  112458:	b510      	push	{r4, r14}
  11245a:	4604      	mov	r4, r0
				vPortFree( pxTCB->pxStack );
  11245c:	6b00      	ldr	r0, [r0, #48]	; 0x30
  11245e:	f7ff f82d 	bl	1114bc <vPortFree>
				vPortFree( pxTCB );
  112462:	4620      	mov	r0, r4
	}
  112464:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
				vPortFree( pxTCB );
  112468:	f7ff b828 	b.w	1114bc <vPortFree>
				vPortFree( pxTCB );
  11246c:	f7ff b826 	b.w	1114bc <vPortFree>

00112470 <prvIdleTask>:
{
  112470:	f642 7470 	movw	r4, #12144	; 0x2f70
  112474:	f642 76e0 	movw	r6, #12256	; 0x2fe0
  112478:	f642 756c 	movw	r5, #12140	; 0x2f6c
  11247c:	f642 48e8 	movw	r8, #11496	; 0x2ce8
  112480:	b580      	push	{r7, r14}
  112482:	f2c0 0413 	movt	r4, #19
  112486:	f2c0 0613 	movt	r6, #19
  11248a:	f2c0 0513 	movt	r5, #19
  11248e:	f2c0 0813 	movt	r8, #19
  112492:	e011      	b.n	1124b8 <prvIdleTask+0x48>
			taskENTER_CRITICAL();
  112494:	f7fe fdea 	bl	11106c <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112498:	68f3      	ldr	r3, [r6, #12]
  11249a:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  11249c:	1d38      	adds	r0, r7, #4
  11249e:	f7ff f8a9 	bl	1115f4 <uxListRemove>
				--uxCurrentNumberOfTasks;
  1124a2:	682b      	ldr	r3, [r5, #0]
  1124a4:	3b01      	subs	r3, #1
  1124a6:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
  1124a8:	6823      	ldr	r3, [r4, #0]
  1124aa:	3b01      	subs	r3, #1
  1124ac:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
  1124ae:	f7fe fe17 	bl	1110e0 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
  1124b2:	4638      	mov	r0, r7
  1124b4:	f7ff ffc0 	bl	112438 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  1124b8:	6823      	ldr	r3, [r4, #0]
  1124ba:	2b00      	cmp	r3, #0
  1124bc:	d1ea      	bne.n	112494 <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  1124be:	f8d8 3000 	ldr.w	r3, [r8]
  1124c2:	2b01      	cmp	r3, #1
  1124c4:	d900      	bls.n	1124c8 <prvIdleTask+0x58>
				taskYIELD();
  1124c6:	df00      	svc	0
			vApplicationIdleHook();
  1124c8:	f7fe feb6 	bl	111238 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
  1124cc:	e7f4      	b.n	1124b8 <prvIdleTask+0x48>
  1124ce:	bf00      	nop

001124d0 <vTaskSwitchContext.part.6>:
void vTaskSwitchContext( void )
  1124d0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
		xYieldPending = pdFALSE;
  1124d2:	f642 73f8 	movw	r3, #12280	; 0x2ff8
  1124d6:	2200      	movs	r2, #0
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  1124d8:	f642 47dc 	movw	r7, #11484	; 0x2cdc
		xYieldPending = pdFALSE;
  1124dc:	f2c0 0313 	movt	r3, #19
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  1124e0:	f2c0 0713 	movt	r7, #19
		xYieldPending = pdFALSE;
  1124e4:	601a      	str	r2, [r3, #0]
		traceTASK_SWITCHED_OUT();
  1124e6:	f7fe feb7 	bl	111258 <traceTASK_SWITCHED_OUT_HOOK>
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
  1124ea:	f7fe fec5 	bl	111278 <vPortGetCurrentTimeMs>
			if( ulTotalRunTime > ulTaskSwitchedInTime )
  1124ee:	f642 7368 	movw	r3, #12136	; 0x2f68
  1124f2:	f2c0 0313 	movt	r3, #19
  1124f6:	6819      	ldr	r1, [r3, #0]
			ulTaskSwitchedInTime = ulTotalRunTime;
  1124f8:	6018      	str	r0, [r3, #0]
			if( ulTotalRunTime > ulTaskSwitchedInTime )
  1124fa:	4288      	cmp	r0, r1
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  1124fc:	bf81      	itttt	hi
  1124fe:	683c      	ldrhi	r4, [r7, #0]
  112500:	6da2      	ldrhi	r2, [r4, #88]	; 0x58
  112502:	1a52      	subhi	r2, r2, r1
  112504:	1812      	addhi	r2, r2, r0
  112506:	bf88      	it	hi
  112508:	65a2      	strhi	r2, [r4, #88]	; 0x58
		taskCHECK_FOR_STACK_OVERFLOW();
  11250a:	683a      	ldr	r2, [r7, #0]
  11250c:	6b13      	ldr	r3, [r2, #48]	; 0x30
  11250e:	681a      	ldr	r2, [r3, #0]
  112510:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  112514:	d103      	bne.n	11251e <vTaskSwitchContext.part.6+0x4e>
  112516:	685a      	ldr	r2, [r3, #4]
  112518:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  11251c:	d031      	beq.n	112582 <vTaskSwitchContext.part.6+0xb2>
  11251e:	6838      	ldr	r0, [r7, #0]
  112520:	6839      	ldr	r1, [r7, #0]
  112522:	3134      	adds	r1, #52	; 0x34
  112524:	f7fe fe8e 	bl	111244 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112528:	f642 7380 	movw	r3, #12160	; 0x2f80
  11252c:	f642 45e8 	movw	r5, #11496	; 0x2ce8
  112530:	f2c0 0313 	movt	r3, #19
  112534:	f2c0 0513 	movt	r5, #19
  112538:	681c      	ldr	r4, [r3, #0]
  11253a:	fab4 f484 	clz	r4, r4
  11253e:	f1c4 061f 	rsb	r6, r4, #31
  112542:	00b4      	lsls	r4, r6, #2
  112544:	19a3      	adds	r3, r4, r6
  112546:	009b      	lsls	r3, r3, #2
  112548:	58eb      	ldr	r3, [r5, r3]
  11254a:	b18b      	cbz	r3, 112570 <vTaskSwitchContext.part.6+0xa0>
  11254c:	4434      	add	r4, r6
  11254e:	00a4      	lsls	r4, r4, #2
  112550:	192a      	adds	r2, r5, r4
  112552:	3408      	adds	r4, #8
  112554:	442c      	add	r4, r5
  112556:	6853      	ldr	r3, [r2, #4]
  112558:	685b      	ldr	r3, [r3, #4]
  11255a:	6053      	str	r3, [r2, #4]
  11255c:	42a3      	cmp	r3, r4
  11255e:	bf04      	itt	eq
  112560:	685b      	ldreq	r3, [r3, #4]
  112562:	6053      	streq	r3, [r2, #4]
  112564:	68db      	ldr	r3, [r3, #12]
  112566:	603b      	str	r3, [r7, #0]
}
  112568:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
		traceTASK_SWITCHED_IN();
  11256c:	f7fe be76 	b.w	11125c <traceTASK_SWITCHED_IN_HOOK>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112570:	f64e 7018 	movw	r0, #61208	; 0xef18
  112574:	f640 31bb 	movw	r1, #3003	; 0xbbb
  112578:	f2c0 0011 	movt	r0, #17
  11257c:	f7fe fe70 	bl	111260 <vMainAssertCalled>
  112580:	e7e4      	b.n	11254c <vTaskSwitchContext.part.6+0x7c>
		taskCHECK_FOR_STACK_OVERFLOW();
  112582:	689a      	ldr	r2, [r3, #8]
  112584:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  112588:	d1c9      	bne.n	11251e <vTaskSwitchContext.part.6+0x4e>
  11258a:	68db      	ldr	r3, [r3, #12]
  11258c:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
  112590:	d1c5      	bne.n	11251e <vTaskSwitchContext.part.6+0x4e>
  112592:	e7c9      	b.n	112528 <vTaskSwitchContext.part.6+0x58>

00112594 <xTaskCreateStatic>:
	{
  112594:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  112598:	4606      	mov	r6, r0
  11259a:	b087      	sub	sp, #28
  11259c:	460f      	mov	r7, r1
  11259e:	4690      	mov	r8, r2
  1125a0:	4699      	mov	r9, r3
  1125a2:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  1125a4:	9c10      	ldr	r4, [sp, #64]	; 0x40
		configASSERT( puxStackBuffer != NULL );
  1125a6:	2d00      	cmp	r5, #0
  1125a8:	d033      	beq.n	112612 <xTaskCreateStatic+0x7e>
		configASSERT( pxTaskBuffer != NULL );
  1125aa:	2c00      	cmp	r4, #0
  1125ac:	d03b      	beq.n	112626 <xTaskCreateStatic+0x92>
			volatile size_t xSize = sizeof( StaticTask_t );
  1125ae:	2364      	movs	r3, #100	; 0x64
  1125b0:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
  1125b2:	9904      	ldr	r1, [sp, #16]
  1125b4:	4299      	cmp	r1, r3
  1125b6:	d10a      	bne.n	1125ce <xTaskCreateStatic+0x3a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
  1125b8:	9b04      	ldr	r3, [sp, #16]
		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
  1125ba:	1c28      	adds	r0, r5, #0
  1125bc:	bf18      	it	ne
  1125be:	2001      	movne	r0, #1
  1125c0:	2c00      	cmp	r4, #0
  1125c2:	bf08      	it	eq
  1125c4:	2000      	moveq	r0, #0
  1125c6:	b958      	cbnz	r0, 1125e0 <xTaskCreateStatic+0x4c>
	}
  1125c8:	b007      	add	sp, #28
  1125ca:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
			configASSERT( xSize == sizeof( TCB_t ) );
  1125ce:	f64e 7018 	movw	r0, #61208	; 0xef18
  1125d2:	f240 2157 	movw	r1, #599	; 0x257
  1125d6:	f2c0 0011 	movt	r0, #17
  1125da:	f7fe fe41 	bl	111260 <vMainAssertCalled>
  1125de:	e7eb      	b.n	1125b8 <xTaskCreateStatic+0x24>
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
  1125e0:	f04f 0e02 	mov.w	r14, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  1125e4:	f10d 0c14 	add.w	r12, r13, #20
  1125e8:	990e      	ldr	r1, [sp, #56]	; 0x38
  1125ea:	464b      	mov	r3, r9
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
  1125ec:	6325      	str	r5, [r4, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  1125ee:	4642      	mov	r2, r8
  1125f0:	9100      	str	r1, [sp, #0]
  1125f2:	4630      	mov	r0, r6
  1125f4:	9402      	str	r4, [sp, #8]
  1125f6:	4639      	mov	r1, r7
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
  1125f8:	f884 e061 	strb.w	r14, [r4, #97]	; 0x61
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  1125fc:	f8cd c004 	str.w	r12, [r13, #4]
  112600:	f7ff fec6 	bl	112390 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
  112604:	4620      	mov	r0, r4
  112606:	f7ff fda5 	bl	112154 <prvAddNewTaskToReadyList>
		return xReturn;
  11260a:	9805      	ldr	r0, [sp, #20]
	}
  11260c:	b007      	add	sp, #28
  11260e:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
		configASSERT( puxStackBuffer != NULL );
  112612:	f64e 7018 	movw	r0, #61208	; 0xef18
  112616:	f240 214e 	movw	r1, #590	; 0x24e
  11261a:	f2c0 0011 	movt	r0, #17
  11261e:	f7fe fe1f 	bl	111260 <vMainAssertCalled>
		configASSERT( pxTaskBuffer != NULL );
  112622:	2c00      	cmp	r4, #0
  112624:	d1c3      	bne.n	1125ae <xTaskCreateStatic+0x1a>
  112626:	f64e 7018 	movw	r0, #61208	; 0xef18
  11262a:	f240 214f 	movw	r1, #591	; 0x24f
  11262e:	f2c0 0011 	movt	r0, #17
  112632:	f7fe fe15 	bl	111260 <vMainAssertCalled>
			volatile size_t xSize = sizeof( StaticTask_t );
  112636:	2364      	movs	r3, #100	; 0x64
  112638:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
  11263a:	9b04      	ldr	r3, [sp, #16]
  11263c:	2b64      	cmp	r3, #100	; 0x64
  11263e:	d1c6      	bne.n	1125ce <xTaskCreateStatic+0x3a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
  112640:	9b04      	ldr	r3, [sp, #16]
			xReturn = NULL;
  112642:	4620      	mov	r0, r4
  112644:	e7c0      	b.n	1125c8 <xTaskCreateStatic+0x34>
  112646:	bf00      	nop

00112648 <xTaskCreate>:
	{
  112648:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  11264c:	4607      	mov	r7, r0
  11264e:	b085      	sub	sp, #20
  112650:	4616      	mov	r6, r2
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  112652:	0090      	lsls	r0, r2, #2
	{
  112654:	4688      	mov	r8, r1
  112656:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  112658:	f7fe ff7e 	bl	111558 <pvPortMalloc>
			if( pxStack != NULL )
  11265c:	b320      	cbz	r0, 1126a8 <xTaskCreate+0x60>
  11265e:	4605      	mov	r5, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  112660:	2064      	movs	r0, #100	; 0x64
  112662:	f7fe ff79 	bl	111558 <pvPortMalloc>
				if( pxNewTCB != NULL )
  112666:	4604      	mov	r4, r0
  112668:	b1b0      	cbz	r0, 112698 <xTaskCreate+0x50>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
  11266a:	f04f 0c00 	mov.w	r12, #0
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  11266e:	464b      	mov	r3, r9
					pxNewTCB->pxStack = pxStack;
  112670:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  112672:	4632      	mov	r2, r6
  112674:	9d0d      	ldr	r5, [sp, #52]	; 0x34
  112676:	4641      	mov	r1, r8
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
  112678:	f884 c061 	strb.w	r12, [r4, #97]	; 0x61
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  11267c:	4638      	mov	r0, r7
  11267e:	9501      	str	r5, [sp, #4]
  112680:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  112682:	9402      	str	r4, [sp, #8]
  112684:	9500      	str	r5, [sp, #0]
  112686:	f7ff fe83 	bl	112390 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
  11268a:	4620      	mov	r0, r4
  11268c:	f7ff fd62 	bl	112154 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  112690:	2001      	movs	r0, #1
	}
  112692:	b005      	add	sp, #20
  112694:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
					vPortFree( pxStack );
  112698:	4628      	mov	r0, r5
  11269a:	f7fe ff0f 	bl	1114bc <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  11269e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
  1126a2:	b005      	add	sp, #20
  1126a4:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  1126a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return xReturn;
  1126ac:	e7f1      	b.n	112692 <xTaskCreate+0x4a>
  1126ae:	bf00      	nop

001126b0 <vTaskDelete>:
	{
  1126b0:	b570      	push	{r4, r5, r6, r14}
  1126b2:	4604      	mov	r4, r0
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  1126b4:	f642 45dc 	movw	r5, #11484	; 0x2cdc
		taskENTER_CRITICAL();
  1126b8:	f7fe fcd8 	bl	11106c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  1126bc:	f2c0 0513 	movt	r5, #19
  1126c0:	2c00      	cmp	r4, #0
  1126c2:	d060      	beq.n	112786 <vTaskDelete+0xd6>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1126c4:	1d26      	adds	r6, r4, #4
  1126c6:	4630      	mov	r0, r6
  1126c8:	f7fe ff94 	bl	1115f4 <uxListRemove>
  1126cc:	b948      	cbnz	r0, 1126e2 <vTaskDelete+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  1126ce:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  1126d0:	f642 42e8 	movw	r2, #11496	; 0x2ce8
  1126d4:	f2c0 0213 	movt	r2, #19
  1126d8:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  1126dc:	009b      	lsls	r3, r3, #2
  1126de:	58d3      	ldr	r3, [r2, r3]
  1126e0:	b3a3      	cbz	r3, 11274c <vTaskDelete+0x9c>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  1126e2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1126e4:	b11b      	cbz	r3, 1126ee <vTaskDelete+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  1126e6:	f104 0018 	add.w	r0, r4, #24
  1126ea:	f7fe ff83 	bl	1115f4 <uxListRemove>
			if( pxTCB == pxCurrentTCB )
  1126ee:	6829      	ldr	r1, [r5, #0]
			uxTaskNumber++;
  1126f0:	f642 737c 	movw	r3, #12156	; 0x2f7c
  1126f4:	f2c0 0313 	movt	r3, #19
			if( pxTCB == pxCurrentTCB )
  1126f8:	42a1      	cmp	r1, r4
			uxTaskNumber++;
  1126fa:	681a      	ldr	r2, [r3, #0]
  1126fc:	f102 0201 	add.w	r2, r2, #1
  112700:	601a      	str	r2, [r3, #0]
			if( pxTCB == pxCurrentTCB )
  112702:	d031      	beq.n	112768 <vTaskDelete+0xb8>
				--uxCurrentNumberOfTasks;
  112704:	f642 736c 	movw	r3, #12140	; 0x2f6c
				prvDeleteTCB( pxTCB );
  112708:	4620      	mov	r0, r4
				--uxCurrentNumberOfTasks;
  11270a:	f2c0 0313 	movt	r3, #19
  11270e:	681a      	ldr	r2, [r3, #0]
  112710:	3a01      	subs	r2, #1
  112712:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
  112714:	f7ff fe90 	bl	112438 <prvDeleteTCB>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  112718:	f642 43e0 	movw	r3, #11488	; 0x2ce0
  11271c:	f2c0 0313 	movt	r3, #19
  112720:	681b      	ldr	r3, [r3, #0]
  112722:	681b      	ldr	r3, [r3, #0]
  112724:	b9eb      	cbnz	r3, 112762 <vTaskDelete+0xb2>
		xNextTaskUnblockTime = portMAX_DELAY;
  112726:	f642 73ac 	movw	r3, #12204	; 0x2fac
  11272a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  11272e:	f2c0 0313 	movt	r3, #19
  112732:	601a      	str	r2, [r3, #0]
		taskEXIT_CRITICAL();
  112734:	f7fe fcd4 	bl	1110e0 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
  112738:	f642 73c8 	movw	r3, #12232	; 0x2fc8
  11273c:	f2c0 0313 	movt	r3, #19
  112740:	681b      	ldr	r3, [r3, #0]
  112742:	b113      	cbz	r3, 11274a <vTaskDelete+0x9a>
			if( pxTCB == pxCurrentTCB )
  112744:	682b      	ldr	r3, [r5, #0]
  112746:	42a3      	cmp	r3, r4
  112748:	d01f      	beq.n	11278a <vTaskDelete+0xda>
	}
  11274a:	bd70      	pop	{r4, r5, r6, r15}
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  11274c:	f642 7380 	movw	r3, #12160	; 0x2f80
  112750:	2201      	movs	r2, #1
  112752:	f2c0 0313 	movt	r3, #19
  112756:	408a      	lsls	r2, r1
  112758:	6819      	ldr	r1, [r3, #0]
  11275a:	ea21 0102 	bic.w	r1, r1, r2
  11275e:	6019      	str	r1, [r3, #0]
  112760:	e7bf      	b.n	1126e2 <vTaskDelete+0x32>
  112762:	f7ff fde5 	bl	112330 <prvResetNextTaskUnblockTime.part.0>
  112766:	e7e5      	b.n	112734 <vTaskDelete+0x84>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
  112768:	f642 70e0 	movw	r0, #12256	; 0x2fe0
  11276c:	4631      	mov	r1, r6
  11276e:	f2c0 0013 	movt	r0, #19
  112772:	f7fe ff15 	bl	1115a0 <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
  112776:	f642 7370 	movw	r3, #12144	; 0x2f70
  11277a:	f2c0 0313 	movt	r3, #19
  11277e:	681a      	ldr	r2, [r3, #0]
  112780:	3201      	adds	r2, #1
  112782:	601a      	str	r2, [r3, #0]
  112784:	e7d6      	b.n	112734 <vTaskDelete+0x84>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  112786:	682c      	ldr	r4, [r5, #0]
  112788:	e79c      	b.n	1126c4 <vTaskDelete+0x14>
				configASSERT( uxSchedulerSuspended == 0 );
  11278a:	f642 7378 	movw	r3, #12152	; 0x2f78
  11278e:	f2c0 0313 	movt	r3, #19
  112792:	681b      	ldr	r3, [r3, #0]
  112794:	b90b      	cbnz	r3, 11279a <vTaskDelete+0xea>
				portYIELD_WITHIN_API();
  112796:	df00      	svc	0
	}
  112798:	bd70      	pop	{r4, r5, r6, r15}
				configASSERT( uxSchedulerSuspended == 0 );
  11279a:	f64e 7018 	movw	r0, #61208	; 0xef18
  11279e:	f240 41d5 	movw	r1, #1237	; 0x4d5
  1127a2:	f2c0 0011 	movt	r0, #17
  1127a6:	f7fe fd5b 	bl	111260 <vMainAssertCalled>
  1127aa:	e7f4      	b.n	112796 <vTaskDelete+0xe6>

001127ac <vTaskPrioritySet>:
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  1127ac:	291f      	cmp	r1, #31
	{
  1127ae:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1127b2:	4604      	mov	r4, r0
  1127b4:	bf98      	it	ls
  1127b6:	460d      	movls	r5, r1
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  1127b8:	d850      	bhi.n	11285c <vTaskPrioritySet+0xb0>
		taskENTER_CRITICAL();
  1127ba:	f7fe fc57 	bl	11106c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
  1127be:	2c00      	cmp	r4, #0
  1127c0:	d059      	beq.n	112876 <vTaskPrioritySet+0xca>
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  1127c2:	6d23      	ldr	r3, [r4, #80]	; 0x50
			if( uxCurrentBasePriority != uxNewPriority )
  1127c4:	429d      	cmp	r5, r3
  1127c6:	d045      	beq.n	112854 <vTaskPrioritySet+0xa8>
					if( pxTCB != pxCurrentTCB )
  1127c8:	f642 42dc 	movw	r2, #11484	; 0x2cdc
  1127cc:	f2c0 0213 	movt	r2, #19
				if( uxNewPriority > uxCurrentBasePriority )
  1127d0:	d90b      	bls.n	1127ea <vTaskPrioritySet+0x3e>
					if( pxTCB != pxCurrentTCB )
  1127d2:	6811      	ldr	r1, [r2, #0]
  1127d4:	42a1      	cmp	r1, r4
	BaseType_t xYieldRequired = pdFALSE;
  1127d6:	bf08      	it	eq
  1127d8:	2700      	moveq	r7, #0
					if( pxTCB != pxCurrentTCB )
  1127da:	d00b      	beq.n	1127f4 <vTaskPrioritySet+0x48>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  1127dc:	6812      	ldr	r2, [r2, #0]
  1127de:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
  1127e0:	42af      	cmp	r7, r5
  1127e2:	bf8c      	ite	hi
  1127e4:	2700      	movhi	r7, #0
  1127e6:	2701      	movls	r7, #1
  1127e8:	e004      	b.n	1127f4 <vTaskPrioritySet+0x48>
				else if( pxTCB == pxCurrentTCB )
  1127ea:	6817      	ldr	r7, [r2, #0]
  1127ec:	1b3f      	subs	r7, r7, r4
  1127ee:	fab7 f787 	clz	r7, r7
  1127f2:	097f      	lsrs	r7, r7, #5
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  1127f4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
					pxTCB->uxBasePriority = uxNewPriority;
  1127f6:	6525      	str	r5, [r4, #80]	; 0x50
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1127f8:	6962      	ldr	r2, [r4, #20]
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  1127fa:	42b3      	cmp	r3, r6
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  1127fc:	69a3      	ldr	r3, [r4, #24]
						pxTCB->uxPriority = uxNewPriority;
  1127fe:	bf08      	it	eq
  112800:	62e5      	streq	r5, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  112802:	2b00      	cmp	r3, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  112804:	bfa8      	it	ge
  112806:	f1c5 0520 	rsbge	r5, r5, #32
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  11280a:	eb06 0386 	add.w	r3, r6, r6, lsl #2
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  11280e:	bfa8      	it	ge
  112810:	61a5      	strge	r5, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  112812:	f642 45e8 	movw	r5, #11496	; 0x2ce8
  112816:	f2c0 0513 	movt	r5, #19
  11281a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  11281e:	429a      	cmp	r2, r3
  112820:	d116      	bne.n	112850 <vTaskPrioritySet+0xa4>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  112822:	f104 0804 	add.w	r8, r4, #4
  112826:	4640      	mov	r0, r8
  112828:	f7fe fee4 	bl	1115f4 <uxListRemove>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
  11282c:	f642 7280 	movw	r2, #12160	; 0x2f80
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  112830:	b338      	cbz	r0, 112882 <vTaskPrioritySet+0xd6>
  112832:	f2c0 0213 	movt	r2, #19
					prvAddTaskToReadyList( pxTCB );
  112836:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  112838:	2301      	movs	r3, #1
  11283a:	6814      	ldr	r4, [r2, #0]
  11283c:	4641      	mov	r1, r8
  11283e:	4083      	lsls	r3, r0
  112840:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  112844:	4323      	orrs	r3, r4
  112846:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  11284a:	6013      	str	r3, [r2, #0]
  11284c:	f7fe fea8 	bl	1115a0 <vListInsertEnd>
				if( xYieldRequired != pdFALSE )
  112850:	b107      	cbz	r7, 112854 <vTaskPrioritySet+0xa8>
					taskYIELD_IF_USING_PREEMPTION();
  112852:	df00      	svc	0
	}
  112854:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
		taskEXIT_CRITICAL();
  112858:	f7fe bc42 	b.w	1110e0 <vPortExitCritical>
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  11285c:	f64e 7018 	movw	r0, #61208	; 0xef18
  112860:	f240 6105 	movw	r1, #1541	; 0x605
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  112864:	251f      	movs	r5, #31
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  112866:	f2c0 0011 	movt	r0, #17
  11286a:	f7fe fcf9 	bl	111260 <vMainAssertCalled>
		taskENTER_CRITICAL();
  11286e:	f7fe fbfd 	bl	11106c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
  112872:	2c00      	cmp	r4, #0
  112874:	d1a5      	bne.n	1127c2 <vTaskPrioritySet+0x16>
  112876:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  11287a:	f2c0 0313 	movt	r3, #19
  11287e:	681c      	ldr	r4, [r3, #0]
  112880:	e79f      	b.n	1127c2 <vTaskPrioritySet+0x16>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
  112882:	2301      	movs	r3, #1
  112884:	f2c0 0213 	movt	r2, #19
  112888:	40b3      	lsls	r3, r6
  11288a:	6816      	ldr	r6, [r2, #0]
  11288c:	ea26 0603 	bic.w	r6, r6, r3
  112890:	6016      	str	r6, [r2, #0]
  112892:	e7d0      	b.n	112836 <vTaskPrioritySet+0x8a>

00112894 <vTaskSuspend>:
	{
  112894:	b570      	push	{r4, r5, r6, r14}
  112896:	4604      	mov	r4, r0
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  112898:	f642 45dc 	movw	r5, #11484	; 0x2cdc
		taskENTER_CRITICAL();
  11289c:	f7fe fbe6 	bl	11106c <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  1128a0:	f2c0 0513 	movt	r5, #19
  1128a4:	2c00      	cmp	r4, #0
  1128a6:	d05f      	beq.n	112968 <vTaskSuspend+0xd4>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1128a8:	1d26      	adds	r6, r4, #4
  1128aa:	4630      	mov	r0, r6
  1128ac:	f7fe fea2 	bl	1115f4 <uxListRemove>
  1128b0:	b948      	cbnz	r0, 1128c6 <vTaskSuspend+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  1128b2:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  1128b4:	f642 42e8 	movw	r2, #11496	; 0x2ce8
  1128b8:	f2c0 0213 	movt	r2, #19
  1128bc:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  1128c0:	009b      	lsls	r3, r3, #2
  1128c2:	58d3      	ldr	r3, [r2, r3]
  1128c4:	b393      	cbz	r3, 11292c <vTaskSuspend+0x98>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  1128c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  1128c8:	b11b      	cbz	r3, 1128d2 <vTaskSuspend+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  1128ca:	f104 0018 	add.w	r0, r4, #24
  1128ce:	f7fe fe91 	bl	1115f4 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  1128d2:	f642 70cc 	movw	r0, #12236	; 0x2fcc
  1128d6:	4631      	mov	r1, r6
		if( xSchedulerRunning != pdFALSE )
  1128d8:	f642 76c8 	movw	r6, #12232	; 0x2fc8
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  1128dc:	f2c0 0013 	movt	r0, #19
  1128e0:	f7fe fe5e 	bl	1115a0 <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
  1128e4:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  1128e8:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  1128ea:	bf08      	it	eq
  1128ec:	2300      	moveq	r3, #0
		if( xSchedulerRunning != pdFALSE )
  1128ee:	f2c0 0613 	movt	r6, #19
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  1128f2:	bf08      	it	eq
  1128f4:	f884 3060 	strbeq.w	r3, [r4, #96]	; 0x60
		taskEXIT_CRITICAL();
  1128f8:	f7fe fbf2 	bl	1110e0 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
  1128fc:	6833      	ldr	r3, [r6, #0]
  1128fe:	bb03      	cbnz	r3, 112942 <vTaskSuspend+0xae>
		if( pxTCB == pxCurrentTCB )
  112900:	682b      	ldr	r3, [r5, #0]
  112902:	42a3      	cmp	r3, r4
  112904:	d000      	beq.n	112908 <vTaskSuspend+0x74>
	}
  112906:	bd70      	pop	{r4, r5, r6, r15}
			if( xSchedulerRunning != pdFALSE )
  112908:	6833      	ldr	r3, [r6, #0]
  11290a:	b37b      	cbz	r3, 11296c <vTaskSuspend+0xd8>
				configASSERT( uxSchedulerSuspended == 0 );
  11290c:	f642 7378 	movw	r3, #12152	; 0x2f78
  112910:	f2c0 0313 	movt	r3, #19
  112914:	681b      	ldr	r3, [r3, #0]
  112916:	b13b      	cbz	r3, 112928 <vTaskSuspend+0x94>
  112918:	f64e 7018 	movw	r0, #61208	; 0xef18
  11291c:	f240 61e7 	movw	r1, #1767	; 0x6e7
  112920:	f2c0 0011 	movt	r0, #17
  112924:	f7fe fc9c 	bl	111260 <vMainAssertCalled>
				portYIELD_WITHIN_API();
  112928:	df00      	svc	0
	}
  11292a:	bd70      	pop	{r4, r5, r6, r15}
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  11292c:	f642 7380 	movw	r3, #12160	; 0x2f80
  112930:	2201      	movs	r2, #1
  112932:	f2c0 0313 	movt	r3, #19
  112936:	408a      	lsls	r2, r1
  112938:	6819      	ldr	r1, [r3, #0]
  11293a:	ea21 0102 	bic.w	r1, r1, r2
  11293e:	6019      	str	r1, [r3, #0]
  112940:	e7c1      	b.n	1128c6 <vTaskSuspend+0x32>
			taskENTER_CRITICAL();
  112942:	f7fe fb93 	bl	11106c <vPortEnterCritical>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  112946:	f642 43e0 	movw	r3, #11488	; 0x2ce0
  11294a:	f2c0 0313 	movt	r3, #19
  11294e:	681b      	ldr	r3, [r3, #0]
  112950:	681b      	ldr	r3, [r3, #0]
  112952:	bb33      	cbnz	r3, 1129a2 <vTaskSuspend+0x10e>
		xNextTaskUnblockTime = portMAX_DELAY;
  112954:	f642 73ac 	movw	r3, #12204	; 0x2fac
  112958:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  11295c:	f2c0 0313 	movt	r3, #19
  112960:	601a      	str	r2, [r3, #0]
			taskEXIT_CRITICAL();
  112962:	f7fe fbbd 	bl	1110e0 <vPortExitCritical>
  112966:	e7cb      	b.n	112900 <vTaskSuspend+0x6c>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  112968:	682c      	ldr	r4, [r5, #0]
  11296a:	e79d      	b.n	1128a8 <vTaskSuspend+0x14>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  11296c:	f642 71cc 	movw	r1, #12236	; 0x2fcc
  112970:	f642 726c 	movw	r2, #12140	; 0x2f6c
  112974:	f2c0 0113 	movt	r1, #19
  112978:	f2c0 0213 	movt	r2, #19
  11297c:	6809      	ldr	r1, [r1, #0]
  11297e:	6812      	ldr	r2, [r2, #0]
  112980:	4291      	cmp	r1, r2
					pxCurrentTCB = NULL;
  112982:	bf08      	it	eq
  112984:	602b      	streq	r3, [r5, #0]
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  112986:	d0be      	beq.n	112906 <vTaskSuspend+0x72>
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  112988:	f642 7378 	movw	r3, #12152	; 0x2f78
  11298c:	f2c0 0313 	movt	r3, #19
  112990:	681b      	ldr	r3, [r3, #0]
  112992:	b14b      	cbz	r3, 1129a8 <vTaskSuspend+0x114>
		xYieldPending = pdTRUE;
  112994:	f642 73f8 	movw	r3, #12280	; 0x2ff8
  112998:	2201      	movs	r2, #1
  11299a:	f2c0 0313 	movt	r3, #19
  11299e:	601a      	str	r2, [r3, #0]
	}
  1129a0:	bd70      	pop	{r4, r5, r6, r15}
  1129a2:	f7ff fcc5 	bl	112330 <prvResetNextTaskUnblockTime.part.0>
  1129a6:	e7dc      	b.n	112962 <vTaskSuspend+0xce>
  1129a8:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
  1129ac:	f7ff bd90 	b.w	1124d0 <vTaskSwitchContext.part.6>

001129b0 <vTaskResume>:
	{
  1129b0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
		configASSERT( xTaskToResume );
  1129b2:	b188      	cbz	r0, 1129d8 <vTaskResume+0x28>
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  1129b4:	f642 45dc 	movw	r5, #11484	; 0x2cdc
  1129b8:	4604      	mov	r4, r0
  1129ba:	f2c0 0513 	movt	r5, #19
  1129be:	682b      	ldr	r3, [r5, #0]
  1129c0:	4298      	cmp	r0, r3
  1129c2:	d016      	beq.n	1129f2 <vTaskResume+0x42>
			taskENTER_CRITICAL();
  1129c4:	f7fe fb52 	bl	11106c <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  1129c8:	4620      	mov	r0, r4
  1129ca:	f7ff fcbf 	bl	11234c <prvTaskIsTaskSuspended>
  1129ce:	b988      	cbnz	r0, 1129f4 <vTaskResume+0x44>
	}
  1129d0:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
			taskEXIT_CRITICAL();
  1129d4:	f7fe bb84 	b.w	1110e0 <vPortExitCritical>
		configASSERT( xTaskToResume );
  1129d8:	f64e 7018 	movw	r0, #61208	; 0xef18
  1129dc:	f240 713b 	movw	r1, #1851	; 0x73b
  1129e0:	f2c0 0011 	movt	r0, #17
  1129e4:	f7fe fc3c 	bl	111260 <vMainAssertCalled>
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  1129e8:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  1129ec:	f2c0 0313 	movt	r3, #19
  1129f0:	681b      	ldr	r3, [r3, #0]
	}
  1129f2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
					prvAddTaskToReadyList( pxTCB );
  1129f4:	f642 7680 	movw	r6, #12160	; 0x2f80
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  1129f8:	1d27      	adds	r7, r4, #4
  1129fa:	4638      	mov	r0, r7
					prvAddTaskToReadyList( pxTCB );
  1129fc:	f2c0 0613 	movt	r6, #19
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  112a00:	f7fe fdf8 	bl	1115f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  112a04:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  112a06:	2301      	movs	r3, #1
  112a08:	4639      	mov	r1, r7
  112a0a:	6837      	ldr	r7, [r6, #0]
  112a0c:	f642 40e8 	movw	r0, #11496	; 0x2ce8
  112a10:	4093      	lsls	r3, r2
  112a12:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  112a16:	433b      	orrs	r3, r7
  112a18:	f2c0 0013 	movt	r0, #19
  112a1c:	6033      	str	r3, [r6, #0]
  112a1e:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  112a22:	f7fe fdbd 	bl	1115a0 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  112a26:	682b      	ldr	r3, [r5, #0]
  112a28:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  112a2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  112a2c:	429a      	cmp	r2, r3
  112a2e:	d3cf      	bcc.n	1129d0 <vTaskResume+0x20>
						taskYIELD_IF_USING_PREEMPTION();
  112a30:	df00      	svc	0
  112a32:	e7cd      	b.n	1129d0 <vTaskResume+0x20>

00112a34 <vTaskStartScheduler>:
{
  112a34:	b530      	push	{r4, r5, r14}
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
  112a36:	2400      	movs	r4, #0
{
  112a38:	b089      	sub	sp, #36	; 0x24
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
  112a3a:	aa07      	add	r2, sp, #28
  112a3c:	a906      	add	r1, sp, #24
		StackType_t *pxIdleTaskStackBuffer = NULL;
  112a3e:	e9cd 4405 	strd	r4, r4, [r13, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
  112a42:	a805      	add	r0, sp, #20
  112a44:	f7fe fbe8 	bl	111218 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
  112a48:	9d05      	ldr	r5, [sp, #20]
  112a4a:	f64e 7174 	movw	r1, #61300	; 0xef74
  112a4e:	f242 4071 	movw	r0, #9329	; 0x2471
  112a52:	9502      	str	r5, [sp, #8]
  112a54:	4623      	mov	r3, r4
  112a56:	9d06      	ldr	r5, [sp, #24]
  112a58:	f2c0 0111 	movt	r1, #17
  112a5c:	9a07      	ldr	r2, [sp, #28]
  112a5e:	f2c0 0011 	movt	r0, #17
  112a62:	9400      	str	r4, [sp, #0]
  112a64:	9501      	str	r5, [sp, #4]
  112a66:	f7ff fd95 	bl	112594 <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
  112a6a:	b170      	cbz	r0, 112a8a <vTaskStartScheduler+0x56>
			xReturn = xTimerCreateTimerTask();
  112a6c:	f000 fc78 	bl	113360 <xTimerCreateTimerTask>
  112a70:	4605      	mov	r5, r0
	if( xReturn == pdPASS )
  112a72:	2801      	cmp	r0, #1
  112a74:	d00b      	beq.n	112a8e <vTaskStartScheduler+0x5a>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  112a76:	1c45      	adds	r5, r0, #1
  112a78:	d107      	bne.n	112a8a <vTaskStartScheduler+0x56>
  112a7a:	f64e 7018 	movw	r0, #61208	; 0xef18
  112a7e:	f640 0123 	movw	r1, #2083	; 0x823
  112a82:	f2c0 0011 	movt	r0, #17
  112a86:	f7fe fbeb 	bl	111260 <vMainAssertCalled>
}
  112a8a:	b009      	add	sp, #36	; 0x24
  112a8c:	bd30      	pop	{r4, r5, r15}
		portDISABLE_INTERRUPTS();
  112a8e:	f7fe fb67 	bl	111160 <ulPortSetInterruptMask>
		xNextTaskUnblockTime = portMAX_DELAY;
  112a92:	f642 71ac 	movw	r1, #12204	; 0x2fac
		xSchedulerRunning = pdTRUE;
  112a96:	f642 72c8 	movw	r2, #12232	; 0x2fc8
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  112a9a:	f642 73f4 	movw	r3, #12276	; 0x2ff4
		xNextTaskUnblockTime = portMAX_DELAY;
  112a9e:	f2c0 0113 	movt	r1, #19
		xSchedulerRunning = pdTRUE;
  112aa2:	f2c0 0213 	movt	r2, #19
		xNextTaskUnblockTime = portMAX_DELAY;
  112aa6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  112aaa:	f2c0 0313 	movt	r3, #19
		xNextTaskUnblockTime = portMAX_DELAY;
  112aae:	6008      	str	r0, [r1, #0]
		xSchedulerRunning = pdTRUE;
  112ab0:	6015      	str	r5, [r2, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  112ab2:	601c      	str	r4, [r3, #0]
		traceTASK_SWITCHED_IN();
  112ab4:	f7fe fbd2 	bl	11125c <traceTASK_SWITCHED_IN_HOOK>
		if( xPortStartScheduler() != pdFALSE )
  112ab8:	f7fe fa54 	bl	110f64 <xPortStartScheduler>
}
  112abc:	b009      	add	sp, #36	; 0x24
  112abe:	bd30      	pop	{r4, r5, r15}

00112ac0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  112ac0:	f642 7378 	movw	r3, #12152	; 0x2f78
  112ac4:	f2c0 0313 	movt	r3, #19
  112ac8:	681a      	ldr	r2, [r3, #0]
  112aca:	3201      	adds	r2, #1
  112acc:	601a      	str	r2, [r3, #0]
}
  112ace:	4770      	bx	r14

00112ad0 <xTaskGetTickCount>:
{
  112ad0:	b510      	push	{r4, r14}
	portTICK_TYPE_ENTER_CRITICAL();
  112ad2:	f7fe facb 	bl	11106c <vPortEnterCritical>
		xTicks = xTickCount;
  112ad6:	f642 73f4 	movw	r3, #12276	; 0x2ff4
  112ada:	f2c0 0313 	movt	r3, #19
  112ade:	681c      	ldr	r4, [r3, #0]
	portTICK_TYPE_EXIT_CRITICAL();
  112ae0:	f7fe fafe 	bl	1110e0 <vPortExitCritical>
}
  112ae4:	4620      	mov	r0, r4
  112ae6:	bd10      	pop	{r4, r15}

00112ae8 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112ae8:	f642 7378 	movw	r3, #12152	; 0x2f78
  112aec:	f2c0 0313 	movt	r3, #19
{
  112af0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112af4:	681b      	ldr	r3, [r3, #0]
{
  112af6:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112af8:	2b00      	cmp	r3, #0
  112afa:	f040 80a4 	bne.w	112c46 <xTaskIncrementTick+0x15e>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  112afe:	f642 73f4 	movw	r3, #12276	; 0x2ff4
  112b02:	f2c0 0313 	movt	r3, #19
  112b06:	681e      	ldr	r6, [r3, #0]
  112b08:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
  112b0a:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  112b0c:	b37e      	cbz	r6, 112b6e <xTaskIncrementTick+0x86>
  112b0e:	f642 73ac 	movw	r3, #12204	; 0x2fac
  112b12:	f2c0 0313 	movt	r3, #19
  112b16:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
  112b18:	9b01      	ldr	r3, [sp, #4]
  112b1a:	681b      	ldr	r3, [r3, #0]
  112b1c:	42b3      	cmp	r3, r6
  112b1e:	d94d      	bls.n	112bbc <xTaskIncrementTick+0xd4>
  112b20:	f642 48e8 	movw	r8, #11496	; 0x2ce8
  112b24:	f642 49dc 	movw	r9, #11484	; 0x2cdc
  112b28:	f2c0 0813 	movt	r8, #19
BaseType_t xSwitchRequired = pdFALSE;
  112b2c:	2500      	movs	r5, #0
  112b2e:	f2c0 0913 	movt	r9, #19
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  112b32:	f8d9 3000 	ldr.w	r3, [r9]
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  112b36:	f642 7274 	movw	r2, #12148	; 0x2f74
  112b3a:	f2c0 0213 	movt	r2, #19
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  112b3e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  112b40:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  112b44:	009b      	lsls	r3, r3, #2
  112b46:	f858 1003 	ldr.w	r1, [r8, r3]
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  112b4a:	6813      	ldr	r3, [r2, #0]
				xSwitchRequired = pdTRUE;
  112b4c:	2902      	cmp	r1, #2
  112b4e:	bf28      	it	cs
  112b50:	2501      	movcs	r5, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  112b52:	2b00      	cmp	r3, #0
  112b54:	d07f      	beq.n	112c56 <xTaskIncrementTick+0x16e>
		if( xYieldPending != pdFALSE )
  112b56:	f642 73f8 	movw	r3, #12280	; 0x2ff8
  112b5a:	f2c0 0313 	movt	r3, #19
  112b5e:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
  112b60:	2b00      	cmp	r3, #0
}
  112b62:	bf0c      	ite	eq
  112b64:	4628      	moveq	r0, r5
  112b66:	2001      	movne	r0, #1
  112b68:	b003      	add	sp, #12
  112b6a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
			taskSWITCH_DELAYED_LISTS();
  112b6e:	f642 44e0 	movw	r4, #11488	; 0x2ce0
  112b72:	f2c0 0413 	movt	r4, #19
  112b76:	6823      	ldr	r3, [r4, #0]
  112b78:	681b      	ldr	r3, [r3, #0]
  112b7a:	2b00      	cmp	r3, #0
  112b7c:	d174      	bne.n	112c68 <xTaskIncrementTick+0x180>
  112b7e:	f642 42e4 	movw	r2, #11492	; 0x2ce4
  112b82:	f642 73b0 	movw	r3, #12208	; 0x2fb0
  112b86:	f2c0 0213 	movt	r2, #19
  112b8a:	6821      	ldr	r1, [r4, #0]
  112b8c:	f2c0 0313 	movt	r3, #19
  112b90:	6810      	ldr	r0, [r2, #0]
  112b92:	6020      	str	r0, [r4, #0]
  112b94:	6011      	str	r1, [r2, #0]
  112b96:	681a      	ldr	r2, [r3, #0]
  112b98:	3201      	adds	r2, #1
  112b9a:	601a      	str	r2, [r3, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  112b9c:	6823      	ldr	r3, [r4, #0]
  112b9e:	681b      	ldr	r3, [r3, #0]
  112ba0:	2b00      	cmp	r3, #0
  112ba2:	d15e      	bne.n	112c62 <xTaskIncrementTick+0x17a>
		xNextTaskUnblockTime = portMAX_DELAY;
  112ba4:	f642 72ac 	movw	r2, #12204	; 0x2fac
  112ba8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  112bac:	f2c0 0213 	movt	r2, #19
  112bb0:	9201      	str	r2, [sp, #4]
  112bb2:	6013      	str	r3, [r2, #0]
		if( xConstTickCount >= xNextTaskUnblockTime )
  112bb4:	9b01      	ldr	r3, [sp, #4]
  112bb6:	681b      	ldr	r3, [r3, #0]
  112bb8:	42b3      	cmp	r3, r6
  112bba:	d8b1      	bhi.n	112b20 <xTaskIncrementTick+0x38>
  112bbc:	f642 44e0 	movw	r4, #11488	; 0x2ce0
  112bc0:	f642 48e8 	movw	r8, #11496	; 0x2ce8
  112bc4:	f642 49dc 	movw	r9, #11484	; 0x2cdc
					prvAddTaskToReadyList( pxTCB );
  112bc8:	f642 7780 	movw	r7, #12160	; 0x2f80
  112bcc:	f2c0 0413 	movt	r4, #19
  112bd0:	f2c0 0813 	movt	r8, #19
  112bd4:	f2c0 0913 	movt	r9, #19
BaseType_t xSwitchRequired = pdFALSE;
  112bd8:	2500      	movs	r5, #0
					prvAddTaskToReadyList( pxTCB );
  112bda:	f2c0 0713 	movt	r7, #19
  112bde:	e029      	b.n	112c34 <xTaskIncrementTick+0x14c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112be0:	6823      	ldr	r3, [r4, #0]
  112be2:	68db      	ldr	r3, [r3, #12]
  112be4:	f8d3 b00c 	ldr.w	r11, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  112be8:	f10b 0a04 	add.w	r10, r11, #4
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  112bec:	f8db 2004 	ldr.w	r2, [r11, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  112bf0:	4650      	mov	r0, r10
					if( xConstTickCount < xItemValue )
  112bf2:	4296      	cmp	r6, r2
  112bf4:	d332      	bcc.n	112c5c <xTaskIncrementTick+0x174>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  112bf6:	f7fe fcfd 	bl	1115f4 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  112bfa:	f8db 2028 	ldr.w	r2, [r11, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  112bfe:	f10b 0018 	add.w	r0, r11, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  112c02:	b10a      	cbz	r2, 112c08 <xTaskIncrementTick+0x120>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  112c04:	f7fe fcf6 	bl	1115f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  112c08:	f8db 002c 	ldr.w	r0, [r11, #44]	; 0x2c
  112c0c:	2201      	movs	r2, #1
  112c0e:	683b      	ldr	r3, [r7, #0]
  112c10:	4651      	mov	r1, r10
  112c12:	4082      	lsls	r2, r0
  112c14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  112c18:	431a      	orrs	r2, r3
  112c1a:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  112c1e:	603a      	str	r2, [r7, #0]
  112c20:	f7fe fcbe 	bl	1115a0 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  112c24:	f8d9 1000 	ldr.w	r1, [r9]
  112c28:	f8db 202c 	ldr.w	r2, [r11, #44]	; 0x2c
  112c2c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
  112c2e:	429a      	cmp	r2, r3
  112c30:	bf28      	it	cs
  112c32:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  112c34:	6823      	ldr	r3, [r4, #0]
  112c36:	681b      	ldr	r3, [r3, #0]
  112c38:	2b00      	cmp	r3, #0
  112c3a:	d1d1      	bne.n	112be0 <xTaskIncrementTick+0xf8>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  112c3c:	9a01      	ldr	r2, [sp, #4]
  112c3e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  112c42:	6013      	str	r3, [r2, #0]
					break;
  112c44:	e775      	b.n	112b32 <xTaskIncrementTick+0x4a>
		++uxPendedTicks;
  112c46:	f642 7374 	movw	r3, #12148	; 0x2f74
BaseType_t xSwitchRequired = pdFALSE;
  112c4a:	2500      	movs	r5, #0
		++uxPendedTicks;
  112c4c:	f2c0 0313 	movt	r3, #19
  112c50:	681a      	ldr	r2, [r3, #0]
  112c52:	3201      	adds	r2, #1
  112c54:	601a      	str	r2, [r3, #0]
			vApplicationTickHook();
  112c56:	f7fe faf1 	bl	11123c <vApplicationTickHook>
  112c5a:	e77c      	b.n	112b56 <xTaskIncrementTick+0x6e>
						xNextTaskUnblockTime = xItemValue;
  112c5c:	9b01      	ldr	r3, [sp, #4]
  112c5e:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  112c60:	e767      	b.n	112b32 <xTaskIncrementTick+0x4a>
  112c62:	f7ff fb65 	bl	112330 <prvResetNextTaskUnblockTime.part.0>
  112c66:	e752      	b.n	112b0e <xTaskIncrementTick+0x26>
			taskSWITCH_DELAYED_LISTS();
  112c68:	f64e 7018 	movw	r0, #61208	; 0xef18
  112c6c:	f640 2182 	movw	r1, #2690	; 0xa82
  112c70:	f2c0 0011 	movt	r0, #17
  112c74:	f7fe faf4 	bl	111260 <vMainAssertCalled>
  112c78:	e781      	b.n	112b7e <xTaskIncrementTick+0x96>
  112c7a:	bf00      	nop

00112c7c <xTaskResumeAll>:
{
  112c7c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
	configASSERT( uxSchedulerSuspended );
  112c80:	f642 7478 	movw	r4, #12152	; 0x2f78
  112c84:	f2c0 0413 	movt	r4, #19
  112c88:	6823      	ldr	r3, [r4, #0]
  112c8a:	2b00      	cmp	r3, #0
  112c8c:	d076      	beq.n	112d7c <xTaskResumeAll+0x100>
	taskENTER_CRITICAL();
  112c8e:	f7fe f9ed 	bl	11106c <vPortEnterCritical>
		--uxSchedulerSuspended;
  112c92:	6823      	ldr	r3, [r4, #0]
  112c94:	3b01      	subs	r3, #1
  112c96:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112c98:	6824      	ldr	r4, [r4, #0]
  112c9a:	2c00      	cmp	r4, #0
  112c9c:	d168      	bne.n	112d70 <xTaskResumeAll+0xf4>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  112c9e:	f642 736c 	movw	r3, #12140	; 0x2f6c
  112ca2:	f2c0 0313 	movt	r3, #19
  112ca6:	681b      	ldr	r3, [r3, #0]
  112ca8:	2b00      	cmp	r3, #0
  112caa:	d061      	beq.n	112d70 <xTaskResumeAll+0xf4>
  112cac:	f642 79f8 	movw	r9, #12280	; 0x2ff8
  112cb0:	f642 7bb4 	movw	r11, #12212	; 0x2fb4
					prvAddTaskToReadyList( pxTCB );
  112cb4:	f642 7680 	movw	r6, #12160	; 0x2f80
  112cb8:	f642 48e8 	movw	r8, #11496	; 0x2ce8
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  112cbc:	f642 47dc 	movw	r7, #11484	; 0x2cdc
  112cc0:	f2c0 0913 	movt	r9, #19
  112cc4:	f2c0 0b13 	movt	r11, #19
					prvAddTaskToReadyList( pxTCB );
  112cc8:	f2c0 0613 	movt	r6, #19
  112ccc:	f2c0 0813 	movt	r8, #19
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  112cd0:	f2c0 0713 	movt	r7, #19
  112cd4:	e01f      	b.n	112d16 <xTaskResumeAll+0x9a>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112cd6:	f8db 300c 	ldr.w	r3, [r11, #12]
  112cda:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  112cdc:	f104 0a04 	add.w	r10, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  112ce0:	f104 0018 	add.w	r0, r4, #24
  112ce4:	f7fe fc86 	bl	1115f4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  112ce8:	4650      	mov	r0, r10
  112cea:	f7fe fc83 	bl	1115f4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  112cee:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  112cf0:	6832      	ldr	r2, [r6, #0]
  112cf2:	4651      	mov	r1, r10
  112cf4:	fa05 f300 	lsl.w	r3, r5, r0
  112cf8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  112cfc:	4313      	orrs	r3, r2
  112cfe:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  112d02:	6033      	str	r3, [r6, #0]
  112d04:	f7fe fc4c 	bl	1115a0 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  112d08:	683b      	ldr	r3, [r7, #0]
  112d0a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  112d0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  112d0e:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
  112d10:	bf28      	it	cs
  112d12:	f8c9 5000 	strcs.w	r5, [r9]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  112d16:	f8db 3000 	ldr.w	r3, [r11]
					prvAddTaskToReadyList( pxTCB );
  112d1a:	2501      	movs	r5, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  112d1c:	2b00      	cmp	r3, #0
  112d1e:	d1da      	bne.n	112cd6 <xTaskResumeAll+0x5a>
				if( pxTCB != NULL )
  112d20:	b16c      	cbz	r4, 112d3e <xTaskResumeAll+0xc2>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  112d22:	f642 43e0 	movw	r3, #11488	; 0x2ce0
  112d26:	f2c0 0313 	movt	r3, #19
  112d2a:	681b      	ldr	r3, [r3, #0]
  112d2c:	681b      	ldr	r3, [r3, #0]
  112d2e:	bb73      	cbnz	r3, 112d8e <xTaskResumeAll+0x112>
		xNextTaskUnblockTime = portMAX_DELAY;
  112d30:	f642 73ac 	movw	r3, #12204	; 0x2fac
  112d34:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  112d38:	f2c0 0313 	movt	r3, #19
  112d3c:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  112d3e:	f642 7574 	movw	r5, #12148	; 0x2f74
  112d42:	f2c0 0513 	movt	r5, #19
  112d46:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
  112d48:	b144      	cbz	r4, 112d5c <xTaskResumeAll+0xe0>
								xYieldPending = pdTRUE;
  112d4a:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
  112d4c:	f7ff fecc 	bl	112ae8 <xTaskIncrementTick>
  112d50:	b108      	cbz	r0, 112d56 <xTaskResumeAll+0xda>
								xYieldPending = pdTRUE;
  112d52:	f8c9 6000 	str.w	r6, [r9]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  112d56:	3c01      	subs	r4, #1
  112d58:	d1f8      	bne.n	112d4c <xTaskResumeAll+0xd0>
						uxPendedTicks = 0;
  112d5a:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
  112d5c:	f8d9 3000 	ldr.w	r3, [r9]
  112d60:	b133      	cbz	r3, 112d70 <xTaskResumeAll+0xf4>
					taskYIELD_IF_USING_PREEMPTION();
  112d62:	df00      	svc	0
						xAlreadyYielded = pdTRUE;
  112d64:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  112d66:	f7fe f9bb 	bl	1110e0 <vPortExitCritical>
}
  112d6a:	4620      	mov	r0, r4
  112d6c:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
BaseType_t xAlreadyYielded = pdFALSE;
  112d70:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  112d72:	f7fe f9b5 	bl	1110e0 <vPortExitCritical>
}
  112d76:	4620      	mov	r0, r4
  112d78:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
	configASSERT( uxSchedulerSuspended );
  112d7c:	f64e 7018 	movw	r0, #61208	; 0xef18
  112d80:	f640 0188 	movw	r1, #2184	; 0x888
  112d84:	f2c0 0011 	movt	r0, #17
  112d88:	f7fe fa6a 	bl	111260 <vMainAssertCalled>
  112d8c:	e77f      	b.n	112c8e <xTaskResumeAll+0x12>
  112d8e:	f7ff facf 	bl	112330 <prvResetNextTaskUnblockTime.part.0>
  112d92:	e7d4      	b.n	112d3e <xTaskResumeAll+0xc2>

00112d94 <vTaskDelay>:
		if( xTicksToDelay > ( TickType_t ) 0U )
  112d94:	b908      	cbnz	r0, 112d9a <vTaskDelay+0x6>
			portYIELD_WITHIN_API();
  112d96:	df00      	svc	0
  112d98:	4770      	bx	r14
	{
  112d9a:	b538      	push	{r3, r4, r5, r14}
			configASSERT( uxSchedulerSuspended == 0 );
  112d9c:	f642 7578 	movw	r5, #12152	; 0x2f78
  112da0:	4604      	mov	r4, r0
  112da2:	f2c0 0513 	movt	r5, #19
  112da6:	682b      	ldr	r3, [r5, #0]
  112da8:	b95b      	cbnz	r3, 112dc2 <vTaskDelay+0x2e>
	++uxSchedulerSuspended;
  112daa:	682b      	ldr	r3, [r5, #0]
  112dac:	3301      	adds	r3, #1
  112dae:	602b      	str	r3, [r5, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  112db0:	2100      	movs	r1, #0
  112db2:	4620      	mov	r0, r4
  112db4:	f7ff fa66 	bl	112284 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
  112db8:	f7ff ff60 	bl	112c7c <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
  112dbc:	b900      	cbnz	r0, 112dc0 <vTaskDelay+0x2c>
			portYIELD_WITHIN_API();
  112dbe:	df00      	svc	0
	}
  112dc0:	bd38      	pop	{r3, r4, r5, r15}
			configASSERT( uxSchedulerSuspended == 0 );
  112dc2:	f64e 7018 	movw	r0, #61208	; 0xef18
  112dc6:	f240 513f 	movw	r1, #1343	; 0x53f
  112dca:	f2c0 0011 	movt	r0, #17
  112dce:	f7fe fa47 	bl	111260 <vMainAssertCalled>
  112dd2:	e7ea      	b.n	112daa <vTaskDelay+0x16>

00112dd4 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  112dd4:	f642 7378 	movw	r3, #12152	; 0x2f78
  112dd8:	f2c0 0313 	movt	r3, #19
  112ddc:	681b      	ldr	r3, [r3, #0]
  112dde:	b133      	cbz	r3, 112dee <vTaskSwitchContext+0x1a>
		xYieldPending = pdTRUE;
  112de0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
  112de4:	2201      	movs	r2, #1
  112de6:	f2c0 0313 	movt	r3, #19
  112dea:	601a      	str	r2, [r3, #0]
}
  112dec:	4770      	bx	r14
  112dee:	f7ff bb6f 	b.w	1124d0 <vTaskSwitchContext.part.6>
  112df2:	bf00      	nop

00112df4 <vTaskPlaceOnEventList>:
{
  112df4:	b538      	push	{r3, r4, r5, r14}
  112df6:	460d      	mov	r5, r1
	configASSERT( pxEventList );
  112df8:	4604      	mov	r4, r0
  112dfa:	b170      	cbz	r0, 112e1a <vTaskPlaceOnEventList+0x26>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  112dfc:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  112e00:	4620      	mov	r0, r4
  112e02:	f2c0 0313 	movt	r3, #19
  112e06:	6819      	ldr	r1, [r3, #0]
  112e08:	3118      	adds	r1, #24
  112e0a:	f7fe fbd9 	bl	1115c0 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  112e0e:	4628      	mov	r0, r5
  112e10:	2101      	movs	r1, #1
}
  112e12:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  112e16:	f7ff ba35 	b.w	112284 <prvAddCurrentTaskToDelayedList>
	configASSERT( pxEventList );
  112e1a:	f64e 7018 	movw	r0, #61208	; 0xef18
  112e1e:	f640 31d2 	movw	r1, #3026	; 0xbd2
  112e22:	f2c0 0011 	movt	r0, #17
  112e26:	f7fe fa1b 	bl	111260 <vMainAssertCalled>
  112e2a:	e7e7      	b.n	112dfc <vTaskPlaceOnEventList+0x8>

00112e2c <vTaskPlaceOnEventListRestricted>:
	{
  112e2c:	b570      	push	{r4, r5, r6, r14}
  112e2e:	460e      	mov	r6, r1
  112e30:	4614      	mov	r4, r2
		configASSERT( pxEventList );
  112e32:	4605      	mov	r5, r0
  112e34:	b190      	cbz	r0, 112e5c <vTaskPlaceOnEventListRestricted+0x30>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  112e36:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  112e3a:	4628      	mov	r0, r5
  112e3c:	f2c0 0313 	movt	r3, #19
  112e40:	6819      	ldr	r1, [r3, #0]
  112e42:	3118      	adds	r1, #24
  112e44:	f7fe fbac 	bl	1115a0 <vListInsertEnd>
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  112e48:	4621      	mov	r1, r4
		if( xWaitIndefinitely != pdFALSE )
  112e4a:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  112e4c:	bf0c      	ite	eq
  112e4e:	4630      	moveq	r0, r6
  112e50:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
	}
  112e54:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  112e58:	f7ff ba14 	b.w	112284 <prvAddCurrentTaskToDelayedList>
		configASSERT( pxEventList );
  112e5c:	f64e 7018 	movw	r0, #61208	; 0xef18
  112e60:	f640 31fd 	movw	r1, #3069	; 0xbfd
  112e64:	f2c0 0011 	movt	r0, #17
  112e68:	f7fe f9fa 	bl	111260 <vMainAssertCalled>
  112e6c:	e7e3      	b.n	112e36 <vTaskPlaceOnEventListRestricted+0xa>
  112e6e:	bf00      	nop

00112e70 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112e70:	68c3      	ldr	r3, [r0, #12]
{
  112e72:	b570      	push	{r4, r5, r6, r14}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  112e74:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  112e76:	2c00      	cmp	r4, #0
  112e78:	d03e      	beq.n	112ef8 <xTaskRemoveFromEventList+0x88>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  112e7a:	f104 0518 	add.w	r5, r4, #24
  112e7e:	4628      	mov	r0, r5
  112e80:	f7fe fbb8 	bl	1115f4 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112e84:	f642 7378 	movw	r3, #12152	; 0x2f78
  112e88:	f2c0 0313 	movt	r3, #19
  112e8c:	681b      	ldr	r3, [r3, #0]
  112e8e:	bb5b      	cbnz	r3, 112ee8 <xTaskRemoveFromEventList+0x78>
		prvAddTaskToReadyList( pxUnblockedTCB );
  112e90:	f642 7580 	movw	r5, #12160	; 0x2f80
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  112e94:	1d26      	adds	r6, r4, #4
  112e96:	4630      	mov	r0, r6
		prvAddTaskToReadyList( pxUnblockedTCB );
  112e98:	f2c0 0513 	movt	r5, #19
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  112e9c:	f7fe fbaa 	bl	1115f4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  112ea0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  112ea2:	2301      	movs	r3, #1
  112ea4:	4631      	mov	r1, r6
  112ea6:	682e      	ldr	r6, [r5, #0]
  112ea8:	f642 40e8 	movw	r0, #11496	; 0x2ce8
  112eac:	4093      	lsls	r3, r2
  112eae:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  112eb2:	f2c0 0013 	movt	r0, #19
  112eb6:	4333      	orrs	r3, r6
  112eb8:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  112ebc:	602b      	str	r3, [r5, #0]
  112ebe:	f7fe fb6f 	bl	1115a0 <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  112ec2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  112ec4:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  112ec8:	f2c0 0313 	movt	r3, #19
  112ecc:	681b      	ldr	r3, [r3, #0]
  112ece:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  112ed0:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
  112ed2:	bf81      	itttt	hi
  112ed4:	f642 73f8 	movwhi	r3, #12280	; 0x2ff8
  112ed8:	2201      	movhi	r2, #1
		xReturn = pdTRUE;
  112eda:	4610      	movhi	r0, r2
		xYieldPending = pdTRUE;
  112edc:	f2c0 0313 	movthi	r3, #19
		xReturn = pdFALSE;
  112ee0:	bf94      	ite	ls
  112ee2:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
  112ee4:	601a      	strhi	r2, [r3, #0]
}
  112ee6:	bd70      	pop	{r4, r5, r6, r15}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  112ee8:	f642 70b4 	movw	r0, #12212	; 0x2fb4
  112eec:	4629      	mov	r1, r5
  112eee:	f2c0 0013 	movt	r0, #19
  112ef2:	f7fe fb55 	bl	1115a0 <vListInsertEnd>
  112ef6:	e7e4      	b.n	112ec2 <xTaskRemoveFromEventList+0x52>
	configASSERT( pxUnblockedTCB );
  112ef8:	f64e 7018 	movw	r0, #61208	; 0xef18
  112efc:	f640 412d 	movw	r1, #3117	; 0xc2d
  112f00:	f2c0 0011 	movt	r0, #17
  112f04:	f7fe f9ac 	bl	111260 <vMainAssertCalled>
  112f08:	e7b7      	b.n	112e7a <xTaskRemoveFromEventList+0xa>
  112f0a:	bf00      	nop

00112f0c <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  112f0c:	f642 72b0 	movw	r2, #12208	; 0x2fb0
	pxTimeOut->xTimeOnEntering = xTickCount;
  112f10:	f642 73f4 	movw	r3, #12276	; 0x2ff4
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  112f14:	f2c0 0213 	movt	r2, #19
	pxTimeOut->xTimeOnEntering = xTickCount;
  112f18:	f2c0 0313 	movt	r3, #19
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  112f1c:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  112f1e:	681b      	ldr	r3, [r3, #0]
  112f20:	e9c0 2300 	strd	r2, r3, [r0]
}
  112f24:	4770      	bx	r14
  112f26:	bf00      	nop

00112f28 <xTaskCheckForTimeOut>:
{
  112f28:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  112f2a:	460e      	mov	r6, r1
	configASSERT( pxTimeOut );
  112f2c:	4605      	mov	r5, r0
  112f2e:	2800      	cmp	r0, #0
  112f30:	d03d      	beq.n	112fae <xTaskCheckForTimeOut+0x86>
	configASSERT( pxTicksToWait );
  112f32:	2e00      	cmp	r6, #0
  112f34:	d045      	beq.n	112fc2 <xTaskCheckForTimeOut+0x9a>
	taskENTER_CRITICAL();
  112f36:	f7fe f899 	bl	11106c <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
  112f3a:	f642 77f4 	movw	r7, #12276	; 0x2ff4
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  112f3e:	f642 43dc 	movw	r3, #11484	; 0x2cdc
		const TickType_t xConstTickCount = xTickCount;
  112f42:	f2c0 0713 	movt	r7, #19
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  112f46:	f2c0 0313 	movt	r3, #19
		const TickType_t xConstTickCount = xTickCount;
  112f4a:	683a      	ldr	r2, [r7, #0]
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  112f4c:	6819      	ldr	r1, [r3, #0]
  112f4e:	f891 4062 	ldrb.w	r4, [r1, #98]	; 0x62
  112f52:	bb1c      	cbnz	r4, 112f9c <xTaskCheckForTimeOut+0x74>
			if( *pxTicksToWait == portMAX_DELAY )
  112f54:	6833      	ldr	r3, [r6, #0]
  112f56:	1c59      	adds	r1, r3, #1
  112f58:	d01c      	beq.n	112f94 <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  112f5a:	6828      	ldr	r0, [r5, #0]
  112f5c:	f642 71b0 	movw	r1, #12208	; 0x2fb0
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  112f60:	686c      	ldr	r4, [r5, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  112f62:	f2c0 0113 	movt	r1, #19
  112f66:	f8d1 c000 	ldr.w	r12, [r1]
  112f6a:	ebb0 000c 	subs.w	r0, r0, r12
  112f6e:	bf18      	it	ne
  112f70:	2001      	movne	r0, #1
  112f72:	4294      	cmp	r4, r2
  112f74:	bf88      	it	hi
  112f76:	2000      	movhi	r0, #0
  112f78:	bb60      	cbnz	r0, 112fd4 <xTaskCheckForTimeOut+0xac>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  112f7a:	1b12      	subs	r2, r2, r4
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  112f7c:	4293      	cmp	r3, r2
			xReturn = pdFALSE;
  112f7e:	bf87      	ittee	hi
  112f80:	4604      	movhi	r4, r0
			*pxTicksToWait -= xElapsedTime;
  112f82:	1a9a      	subhi	r2, r3, r2
			*pxTicksToWait = 0;
  112f84:	6030      	strls	r0, [r6, #0]
			xReturn = pdTRUE;
  112f86:	2401      	movls	r4, #1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  112f88:	bf81      	itttt	hi
  112f8a:	6809      	ldrhi	r1, [r1, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  112f8c:	683b      	ldrhi	r3, [r7, #0]
			*pxTicksToWait -= xElapsedTime;
  112f8e:	6032      	strhi	r2, [r6, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  112f90:	e9c5 1300 	strdhi	r1, r3, [r5]
	taskEXIT_CRITICAL();
  112f94:	f7fe f8a4 	bl	1110e0 <vPortExitCritical>
}
  112f98:	4620      	mov	r0, r4
  112f9a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
				pxCurrentTCB->ucDelayAborted = pdFALSE;
  112f9c:	2200      	movs	r2, #0
				xReturn = pdTRUE;
  112f9e:	2401      	movs	r4, #1
				pxCurrentTCB->ucDelayAborted = pdFALSE;
  112fa0:	681b      	ldr	r3, [r3, #0]
  112fa2:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	taskEXIT_CRITICAL();
  112fa6:	f7fe f89b 	bl	1110e0 <vPortExitCritical>
}
  112faa:	4620      	mov	r0, r4
  112fac:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
	configASSERT( pxTimeOut );
  112fae:	f64e 7018 	movw	r0, #61208	; 0xef18
  112fb2:	f640 4198 	movw	r1, #3224	; 0xc98
  112fb6:	f2c0 0011 	movt	r0, #17
  112fba:	f7fe f951 	bl	111260 <vMainAssertCalled>
	configASSERT( pxTicksToWait );
  112fbe:	2e00      	cmp	r6, #0
  112fc0:	d1b9      	bne.n	112f36 <xTaskCheckForTimeOut+0xe>
  112fc2:	f64e 7018 	movw	r0, #61208	; 0xef18
  112fc6:	f640 4199 	movw	r1, #3225	; 0xc99
  112fca:	f2c0 0011 	movt	r0, #17
  112fce:	f7fe f947 	bl	111260 <vMainAssertCalled>
  112fd2:	e7b0      	b.n	112f36 <xTaskCheckForTimeOut+0xe>
			xReturn = pdTRUE;
  112fd4:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  112fd6:	f7fe f883 	bl	1110e0 <vPortExitCritical>
}
  112fda:	4620      	mov	r0, r4
  112fdc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  112fde:	bf00      	nop

00112fe0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
  112fe0:	f642 73f8 	movw	r3, #12280	; 0x2ff8
  112fe4:	2201      	movs	r2, #1
  112fe6:	f2c0 0313 	movt	r3, #19
  112fea:	601a      	str	r2, [r3, #0]
}
  112fec:	4770      	bx	r14
  112fee:	bf00      	nop

00112ff0 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
  112ff0:	f642 73c8 	movw	r3, #12232	; 0x2fc8
  112ff4:	f2c0 0313 	movt	r3, #19
  112ff8:	681b      	ldr	r3, [r3, #0]
  112ffa:	b14b      	cbz	r3, 113010 <xTaskGetSchedulerState+0x20>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  112ffc:	f642 7378 	movw	r3, #12152	; 0x2f78
  113000:	f2c0 0313 	movt	r3, #19
  113004:	681b      	ldr	r3, [r3, #0]
  113006:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
  113008:	bf0c      	ite	eq
  11300a:	2002      	moveq	r0, #2
  11300c:	2000      	movne	r0, #0
  11300e:	4770      	bx	r14
			xReturn = taskSCHEDULER_NOT_STARTED;
  113010:	2001      	movs	r0, #1
	}
  113012:	4770      	bx	r14

00113014 <xTaskPriorityInherit>:
	{
  113014:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
		if( pxMutexHolder != NULL )
  113016:	4606      	mov	r6, r0
  113018:	b1f8      	cbz	r0, 11305a <xTaskPriorityInherit+0x46>
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
  11301a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  11301c:	f642 44dc 	movw	r4, #11484	; 0x2cdc
  113020:	f2c0 0413 	movt	r4, #19
  113024:	6821      	ldr	r1, [r4, #0]
  113026:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  113028:	428a      	cmp	r2, r1
  11302a:	d217      	bcs.n	11305c <xTaskPriorityInherit+0x48>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  11302c:	6981      	ldr	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  11302e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  113032:	f642 45e8 	movw	r5, #11496	; 0x2ce8
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  113036:	2900      	cmp	r1, #0
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  113038:	f2c0 0513 	movt	r5, #19
  11303c:	eb05 0282 	add.w	r2, r5, r2, lsl #2
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  113040:	bfa1      	itttt	ge
  113042:	6821      	ldrge	r1, [r4, #0]
  113044:	6ac9      	ldrge	r1, [r1, #44]	; 0x2c
  113046:	f1c1 0120 	rsbge	r1, r1, #32
  11304a:	6181      	strge	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  11304c:	6941      	ldr	r1, [r0, #20]
  11304e:	4291      	cmp	r1, r2
  113050:	d00c      	beq.n	11306c <xTaskPriorityInherit+0x58>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  113052:	6822      	ldr	r2, [r4, #0]
				xReturn = pdTRUE;
  113054:	2001      	movs	r0, #1
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  113056:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  113058:	62f2      	str	r2, [r6, #44]	; 0x2c
	}
  11305a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
  11305c:	6822      	ldr	r2, [r4, #0]
  11305e:	6d00      	ldr	r0, [r0, #80]	; 0x50
  113060:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  113062:	4298      	cmp	r0, r3
  113064:	bf2c      	ite	cs
  113066:	2000      	movcs	r0, #0
  113068:	2001      	movcc	r0, #1
	}
  11306a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  11306c:	1d07      	adds	r7, r0, #4
  11306e:	4638      	mov	r0, r7
  113070:	f7fe fac0 	bl	1115f4 <uxListRemove>
  113074:	f642 7280 	movw	r2, #12160	; 0x2f80
  113078:	f2c0 0213 	movt	r2, #19
  11307c:	b978      	cbnz	r0, 11309e <xTaskPriorityInherit+0x8a>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
  11307e:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  113080:	f642 7280 	movw	r2, #12160	; 0x2f80
  113084:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  113088:	009b      	lsls	r3, r3, #2
  11308a:	58eb      	ldr	r3, [r5, r3]
  11308c:	b9cb      	cbnz	r3, 1130c2 <xTaskPriorityInherit+0xae>
  11308e:	2301      	movs	r3, #1
  113090:	f2c0 0213 	movt	r2, #19
  113094:	408b      	lsls	r3, r1
  113096:	6811      	ldr	r1, [r2, #0]
  113098:	ea21 0103 	bic.w	r1, r1, r3
  11309c:	6011      	str	r1, [r2, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  11309e:	6823      	ldr	r3, [r4, #0]
					prvAddTaskToReadyList( pxMutexHolderTCB );
  1130a0:	2401      	movs	r4, #1
  1130a2:	4639      	mov	r1, r7
  1130a4:	6817      	ldr	r7, [r2, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  1130a6:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
  1130a8:	62f0      	str	r0, [r6, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
  1130aa:	fa04 f300 	lsl.w	r3, r4, r0
  1130ae:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  1130b2:	433b      	orrs	r3, r7
  1130b4:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  1130b8:	6013      	str	r3, [r2, #0]
  1130ba:	f7fe fa71 	bl	1115a0 <vListInsertEnd>
				xReturn = pdTRUE;
  1130be:	4620      	mov	r0, r4
	}
  1130c0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  1130c2:	f2c0 0213 	movt	r2, #19
  1130c6:	e7ea      	b.n	11309e <xTaskPriorityInherit+0x8a>

001130c8 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
  1130c8:	b348      	cbz	r0, 11311e <xTaskPriorityDisinherit+0x56>
	{
  1130ca:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
			configASSERT( pxTCB == pxCurrentTCB );
  1130cc:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  1130d0:	4604      	mov	r4, r0
  1130d2:	f2c0 0313 	movt	r3, #19
  1130d6:	681b      	ldr	r3, [r3, #0]
  1130d8:	4283      	cmp	r3, r0
  1130da:	d007      	beq.n	1130ec <xTaskPriorityDisinherit+0x24>
  1130dc:	f64e 7018 	movw	r0, #61208	; 0xef18
  1130e0:	f640 71d5 	movw	r1, #4053	; 0xfd5
  1130e4:	f2c0 0011 	movt	r0, #17
  1130e8:	f7fe f8ba 	bl	111260 <vMainAssertCalled>
			configASSERT( pxTCB->uxMutexesHeld );
  1130ec:	6d63      	ldr	r3, [r4, #84]	; 0x54
  1130ee:	b163      	cbz	r3, 11310a <xTaskPriorityDisinherit+0x42>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  1130f0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			( pxTCB->uxMutexesHeld )--;
  1130f2:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  1130f4:	6d21      	ldr	r1, [r4, #80]	; 0x50
			( pxTCB->uxMutexesHeld )--;
  1130f6:	6563      	str	r3, [r4, #84]	; 0x54
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  1130f8:	1a42      	subs	r2, r0, r1
  1130fa:	bf18      	it	ne
  1130fc:	2201      	movne	r2, #1
  1130fe:	2b00      	cmp	r3, #0
  113100:	bf18      	it	ne
  113102:	2200      	movne	r2, #0
	BaseType_t xReturn = pdFALSE;
  113104:	2000      	movs	r0, #0
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  113106:	b962      	cbnz	r2, 113122 <xTaskPriorityDisinherit+0x5a>
	}
  113108:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
			configASSERT( pxTCB->uxMutexesHeld );
  11310a:	f64e 7018 	movw	r0, #61208	; 0xef18
  11310e:	f640 71d6 	movw	r1, #4054	; 0xfd6
  113112:	f2c0 0011 	movt	r0, #17
  113116:	f7fe f8a3 	bl	111260 <vMainAssertCalled>
  11311a:	6d63      	ldr	r3, [r4, #84]	; 0x54
  11311c:	e7e8      	b.n	1130f0 <xTaskPriorityDisinherit+0x28>
	BaseType_t xReturn = pdFALSE;
  11311e:	2000      	movs	r0, #0
	}
  113120:	4770      	bx	r14
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  113122:	1d27      	adds	r7, r4, #4
  113124:	4638      	mov	r0, r7
  113126:	f7fe fa65 	bl	1115f4 <uxListRemove>
  11312a:	b1f0      	cbz	r0, 11316a <xTaskPriorityDisinherit+0xa2>
  11312c:	f642 40e8 	movw	r0, #11496	; 0x2ce8
  113130:	f642 7280 	movw	r2, #12160	; 0x2f80
  113134:	f2c0 0013 	movt	r0, #19
  113138:	f2c0 0213 	movt	r2, #19
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  11313c:	6d23      	ldr	r3, [r4, #80]	; 0x50
					prvAddTaskToReadyList( pxTCB );
  11313e:	2501      	movs	r5, #1
  113140:	f8d2 e000 	ldr.w	r14, [r2]
  113144:	4639      	mov	r1, r7
  113146:	fa05 f603 	lsl.w	r6, r5, r3
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  11314a:	f1c3 0c20 	rsb	r12, r3, #32
					prvAddTaskToReadyList( pxTCB );
  11314e:	eb03 0783 	add.w	r7, r3, r3, lsl #2
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  113152:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  113154:	ea46 060e 	orr.w	r6, r6, r14
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  113158:	f8c4 c018 	str.w	r12, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
  11315c:	eb00 0087 	add.w	r0, r0, r7, lsl #2
  113160:	6016      	str	r6, [r2, #0]
  113162:	f7fe fa1d 	bl	1115a0 <vListInsertEnd>
					xReturn = pdTRUE;
  113166:	4628      	mov	r0, r5
	}
  113168:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  11316a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  11316c:	f642 40e8 	movw	r0, #11496	; 0x2ce8
  113170:	f642 7280 	movw	r2, #12160	; 0x2f80
  113174:	f2c0 0013 	movt	r0, #19
  113178:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  11317c:	009b      	lsls	r3, r3, #2
  11317e:	58c3      	ldr	r3, [r0, r3]
  113180:	b943      	cbnz	r3, 113194 <xTaskPriorityDisinherit+0xcc>
  113182:	2301      	movs	r3, #1
  113184:	f2c0 0213 	movt	r2, #19
  113188:	408b      	lsls	r3, r1
  11318a:	6811      	ldr	r1, [r2, #0]
  11318c:	ea21 0103 	bic.w	r1, r1, r3
  113190:	6011      	str	r1, [r2, #0]
  113192:	e7d3      	b.n	11313c <xTaskPriorityDisinherit+0x74>
  113194:	f2c0 0213 	movt	r2, #19
  113198:	e7d0      	b.n	11313c <xTaskPriorityDisinherit+0x74>
  11319a:	bf00      	nop

0011319c <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
  11319c:	b1c0      	cbz	r0, 1131d0 <vTaskPriorityDisinheritAfterTimeout+0x34>
	{
  11319e:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
			configASSERT( pxTCB->uxMutexesHeld );
  1131a0:	6d43      	ldr	r3, [r0, #84]	; 0x54
  1131a2:	4604      	mov	r4, r0
  1131a4:	460d      	mov	r5, r1
  1131a6:	b153      	cbz	r3, 1131be <vTaskPriorityDisinheritAfterTimeout+0x22>
  1131a8:	6d21      	ldr	r1, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != uxPriorityToUse )
  1131aa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  1131ac:	428d      	cmp	r5, r1
  1131ae:	bf38      	it	cc
  1131b0:	460d      	movcc	r5, r1
  1131b2:	42ab      	cmp	r3, r5
  1131b4:	d002      	beq.n	1131bc <vTaskPriorityDisinheritAfterTimeout+0x20>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
  1131b6:	6d62      	ldr	r2, [r4, #84]	; 0x54
  1131b8:	2a01      	cmp	r2, #1
  1131ba:	d00a      	beq.n	1131d2 <vTaskPriorityDisinheritAfterTimeout+0x36>
	}
  1131bc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
			configASSERT( pxTCB->uxMutexesHeld );
  1131be:	f64e 7018 	movw	r0, #61208	; 0xef18
  1131c2:	f241 0124 	movw	r1, #4132	; 0x1024
  1131c6:	f2c0 0011 	movt	r0, #17
  1131ca:	f7fe f849 	bl	111260 <vMainAssertCalled>
  1131ce:	e7eb      	b.n	1131a8 <vTaskPriorityDisinheritAfterTimeout+0xc>
  1131d0:	4770      	bx	r14
					configASSERT( pxTCB != pxCurrentTCB );
  1131d2:	f642 42dc 	movw	r2, #11484	; 0x2cdc
  1131d6:	f2c0 0213 	movt	r2, #19
  1131da:	6812      	ldr	r2, [r2, #0]
  1131dc:	42a2      	cmp	r2, r4
  1131de:	d029      	beq.n	113234 <vTaskPriorityDisinheritAfterTimeout+0x98>
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  1131e0:	69a2      	ldr	r2, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1131e2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
					pxTCB->uxPriority = uxPriorityToUse;
  1131e6:	62e5      	str	r5, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  1131e8:	2a00      	cmp	r2, #0
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1131ea:	6962      	ldr	r2, [r4, #20]
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1131ec:	bfa4      	itt	ge
  1131ee:	f1c5 0520 	rsbge	r5, r5, #32
  1131f2:	61a5      	strge	r5, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1131f4:	f642 45e8 	movw	r5, #11496	; 0x2ce8
  1131f8:	f2c0 0513 	movt	r5, #19
  1131fc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  113200:	429a      	cmp	r2, r3
  113202:	d1db      	bne.n	1131bc <vTaskPriorityDisinheritAfterTimeout+0x20>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  113204:	1d27      	adds	r7, r4, #4
  113206:	4638      	mov	r0, r7
  113208:	f7fe f9f4 	bl	1115f4 <uxListRemove>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  11320c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  11320e:	2401      	movs	r4, #1
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  113210:	b1d0      	cbz	r0, 113248 <vTaskPriorityDisinheritAfterTimeout+0xac>
  113212:	f642 7380 	movw	r3, #12160	; 0x2f80
  113216:	4094      	lsls	r4, r2
  113218:	0090      	lsls	r0, r2, #2
  11321a:	f2c0 0313 	movt	r3, #19
						prvAddTaskToReadyList( pxTCB );
  11321e:	681e      	ldr	r6, [r3, #0]
  113220:	4410      	add	r0, r2
  113222:	4639      	mov	r1, r7
  113224:	4334      	orrs	r4, r6
  113226:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  11322a:	601c      	str	r4, [r3, #0]
	}
  11322c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
						prvAddTaskToReadyList( pxTCB );
  113230:	f7fe b9b6 	b.w	1115a0 <vListInsertEnd>
					configASSERT( pxTCB != pxCurrentTCB );
  113234:	f64e 7018 	movw	r0, #61208	; 0xef18
  113238:	f241 013f 	movw	r1, #4159	; 0x103f
  11323c:	f2c0 0011 	movt	r0, #17
  113240:	f7fe f80e 	bl	111260 <vMainAssertCalled>
  113244:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  113246:	e7cb      	b.n	1131e0 <vTaskPriorityDisinheritAfterTimeout+0x44>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  113248:	0090      	lsls	r0, r2, #2
  11324a:	1883      	adds	r3, r0, r2
  11324c:	4094      	lsls	r4, r2
  11324e:	009b      	lsls	r3, r3, #2
  113250:	58eb      	ldr	r3, [r5, r3]
  113252:	b123      	cbz	r3, 11325e <vTaskPriorityDisinheritAfterTimeout+0xc2>
  113254:	f642 7380 	movw	r3, #12160	; 0x2f80
  113258:	f2c0 0313 	movt	r3, #19
  11325c:	e7df      	b.n	11321e <vTaskPriorityDisinheritAfterTimeout+0x82>
  11325e:	f642 7380 	movw	r3, #12160	; 0x2f80
  113262:	f2c0 0313 	movt	r3, #19
  113266:	6819      	ldr	r1, [r3, #0]
  113268:	ea21 0104 	bic.w	r1, r1, r4
  11326c:	6019      	str	r1, [r3, #0]
  11326e:	e7d6      	b.n	11321e <vTaskPriorityDisinheritAfterTimeout+0x82>

00113270 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
  113270:	f642 43dc 	movw	r3, #11484	; 0x2cdc
  113274:	f2c0 0313 	movt	r3, #19
  113278:	681a      	ldr	r2, [r3, #0]
  11327a:	b11a      	cbz	r2, 113284 <pvTaskIncrementMutexHeldCount+0x14>
			( pxCurrentTCB->uxMutexesHeld )++;
  11327c:	6819      	ldr	r1, [r3, #0]
  11327e:	6d4a      	ldr	r2, [r1, #84]	; 0x54
  113280:	3201      	adds	r2, #1
  113282:	654a      	str	r2, [r1, #84]	; 0x54
		return pxCurrentTCB;
  113284:	6818      	ldr	r0, [r3, #0]
	}
  113286:	4770      	bx	r14

00113288 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  113288:	b5f0      	push	{r4, r5, r6, r7, r14}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
  11328a:	f243 1424 	movw	r4, #12580	; 0x3124
{
  11328e:	b083      	sub	sp, #12
		if( xTimerQueue == NULL )
  113290:	f2c0 0413 	movt	r4, #19
	taskENTER_CRITICAL();
  113294:	f7fd feea 	bl	11106c <vPortEnterCritical>
		if( xTimerQueue == NULL )
  113298:	6825      	ldr	r5, [r4, #0]
  11329a:	b125      	cbz	r5, 1132a6 <prvCheckForValidListAndQueue+0x1e>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
  11329c:	b003      	add	sp, #12
  11329e:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
	taskEXIT_CRITICAL();
  1132a2:	f7fd bf1d 	b.w	1110e0 <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
  1132a6:	f243 07a4 	movw	r7, #12452	; 0x30a4
			vListInitialise( &xActiveTimerList2 );
  1132aa:	f243 06b8 	movw	r6, #12472	; 0x30b8
			vListInitialise( &xActiveTimerList1 );
  1132ae:	f2c0 0713 	movt	r7, #19
  1132b2:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
  1132b4:	f2c0 0613 	movt	r6, #19
			vListInitialise( &xActiveTimerList1 );
  1132b8:	f7fe f962 	bl	111580 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
  1132bc:	4630      	mov	r0, r6
  1132be:	f7fe f95f 	bl	111580 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
  1132c2:	f642 72fc 	movw	r2, #12284	; 0x2ffc
			pxOverflowTimerList = &xActiveTimerList2;
  1132c6:	f243 0c00 	movw	r12, #12288	; 0x3000
			pxCurrentTimerList = &xActiveTimerList1;
  1132ca:	f2c0 0213 	movt	r2, #19
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  1132ce:	9500      	str	r5, [sp, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  1132d0:	f2c0 0c13 	movt	r12, #19
			pxCurrentTimerList = &xActiveTimerList1;
  1132d4:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  1132d6:	f243 03d0 	movw	r3, #12496	; 0x30d0
  1132da:	f243 0204 	movw	r2, #12292	; 0x3004
  1132de:	f2c0 0313 	movt	r3, #19
  1132e2:	2110      	movs	r1, #16
  1132e4:	f2c0 0213 	movt	r2, #19
			pxOverflowTimerList = &xActiveTimerList2;
  1132e8:	f8cc 6000 	str.w	r6, [r12]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  1132ec:	200a      	movs	r0, #10
  1132ee:	f7fe fab5 	bl	11185c <xQueueGenericCreateStatic>
  1132f2:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
  1132f4:	2800      	cmp	r0, #0
  1132f6:	d0d1      	beq.n	11329c <prvCheckForValidListAndQueue+0x14>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
  1132f8:	f64e 717c 	movw	r1, #61308	; 0xef7c
  1132fc:	f2c0 0111 	movt	r1, #17
  113300:	f7fe feee 	bl	1120e0 <vQueueAddToRegistry>
}
  113304:	b003      	add	sp, #12
  113306:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
	taskEXIT_CRITICAL();
  11330a:	f7fd bee9 	b.w	1110e0 <vPortExitCritical>
  11330e:	bf00      	nop

00113310 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
  113310:	4291      	cmp	r1, r2
{
  113312:	b510      	push	{r4, r14}
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  113314:	6100      	str	r0, [r0, #16]
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  113316:	6041      	str	r1, [r0, #4]
	if( xNextExpiryTime <= xTimeNow )
  113318:	d805      	bhi.n	113326 <prvInsertTimerInActiveList+0x16>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  11331a:	6981      	ldr	r1, [r0, #24]
  11331c:	1ad2      	subs	r2, r2, r3
  11331e:	428a      	cmp	r2, r1
  113320:	d314      	bcc.n	11334c <prvInsertTimerInActiveList+0x3c>
			xProcessTimerNow = pdTRUE;
  113322:	2001      	movs	r0, #1
}
  113324:	bd10      	pop	{r4, r15}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  113326:	429a      	cmp	r2, r3
  113328:	bf34      	ite	cc
  11332a:	2401      	movcc	r4, #1
  11332c:	2400      	movcs	r4, #0
  11332e:	4299      	cmp	r1, r3
  113330:	bf38      	it	cc
  113332:	2400      	movcc	r4, #0
  113334:	2c00      	cmp	r4, #0
  113336:	d1f4      	bne.n	113322 <prvInsertTimerInActiveList+0x12>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  113338:	f642 73fc 	movw	r3, #12284	; 0x2ffc
  11333c:	1d01      	adds	r1, r0, #4
  11333e:	f2c0 0313 	movt	r3, #19
  113342:	6818      	ldr	r0, [r3, #0]
  113344:	f7fe f93c 	bl	1115c0 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
  113348:	4620      	mov	r0, r4
}
  11334a:	bd10      	pop	{r4, r15}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  11334c:	f243 0300 	movw	r3, #12288	; 0x3000
  113350:	1d01      	adds	r1, r0, #4
  113352:	f2c0 0313 	movt	r3, #19
  113356:	6818      	ldr	r0, [r3, #0]
  113358:	f7fe f932 	bl	1115c0 <vListInsert>
  11335c:	2000      	movs	r0, #0
}
  11335e:	bd10      	pop	{r4, r15}

00113360 <xTimerCreateTimerTask>:
{
  113360:	b570      	push	{r4, r5, r6, r14}
  113362:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
  113364:	f7ff ff90 	bl	113288 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
  113368:	f243 1324 	movw	r3, #12580	; 0x3124
  11336c:	f2c0 0313 	movt	r3, #19
  113370:	681b      	ldr	r3, [r3, #0]
  113372:	b313      	cbz	r3, 1133ba <xTimerCreateTimerTask+0x5a>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
  113374:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  113376:	aa07      	add	r2, sp, #28
  113378:	a906      	add	r1, sp, #24
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
  11337a:	261f      	movs	r6, #31
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  11337c:	a805      	add	r0, sp, #20
			StackType_t *pxTimerTaskStackBuffer = NULL;
  11337e:	e9cd 4405 	strd	r4, r4, [r13, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  113382:	f7fd ff39 	bl	1111f8 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
  113386:	4623      	mov	r3, r4
  113388:	f64e 7184 	movw	r1, #61316	; 0xef84
  11338c:	9d05      	ldr	r5, [sp, #20]
  11338e:	f243 40cd 	movw	r0, #13517	; 0x34cd
  113392:	9c06      	ldr	r4, [sp, #24]
  113394:	f2c0 0111 	movt	r1, #17
  113398:	9a07      	ldr	r2, [sp, #28]
  11339a:	f2c0 0011 	movt	r0, #17
  11339e:	9600      	str	r6, [sp, #0]
  1133a0:	9502      	str	r5, [sp, #8]
  1133a2:	9401      	str	r4, [sp, #4]
  1133a4:	f7ff f8f6 	bl	112594 <xTaskCreateStatic>
  1133a8:	f243 1328 	movw	r3, #12584	; 0x3128
  1133ac:	f2c0 0313 	movt	r3, #19
  1133b0:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
  1133b2:	b110      	cbz	r0, 1133ba <xTimerCreateTimerTask+0x5a>
				xReturn = pdPASS;
  1133b4:	2001      	movs	r0, #1
}
  1133b6:	b008      	add	sp, #32
  1133b8:	bd70      	pop	{r4, r5, r6, r15}
	configASSERT( xReturn );
  1133ba:	f64e 708c 	movw	r0, #61324	; 0xef8c
  1133be:	f240 1113 	movw	r1, #275	; 0x113
  1133c2:	f2c0 0011 	movt	r0, #17
  1133c6:	f7fd ff4b 	bl	111260 <vMainAssertCalled>
  1133ca:	2000      	movs	r0, #0
}
  1133cc:	b008      	add	sp, #32
  1133ce:	bd70      	pop	{r4, r5, r6, r15}

001133d0 <xTimerGenericCommand>:
{
  1133d0:	b570      	push	{r4, r5, r6, r14}
  1133d2:	460e      	mov	r6, r1
  1133d4:	b086      	sub	sp, #24
	configASSERT( xTimer );
  1133d6:	4605      	mov	r5, r0
  1133d8:	b310      	cbz	r0, 113420 <xTimerGenericCommand+0x50>
	if( xTimerQueue != NULL )
  1133da:	f243 1424 	movw	r4, #12580	; 0x3124
  1133de:	f2c0 0413 	movt	r4, #19
  1133e2:	6820      	ldr	r0, [r4, #0]
  1133e4:	b198      	cbz	r0, 11340e <xTimerGenericCommand+0x3e>
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  1133e6:	e9cd 6202 	strd	r6, r2, [r13, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  1133ea:	2e05      	cmp	r6, #5
		xMessage.u.xTimerParameters.pxTimer = xTimer;
  1133ec:	9504      	str	r5, [sp, #16]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  1133ee:	dc10      	bgt.n	113412 <xTimerGenericCommand+0x42>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  1133f0:	f7ff fdfe 	bl	112ff0 <xTaskGetSchedulerState>
  1133f4:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  1133f6:	bf11      	iteee	ne
  1133f8:	2300      	movne	r3, #0
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  1133fa:	2300      	moveq	r3, #0
  1133fc:	a902      	addeq	r1, sp, #8
  1133fe:	6820      	ldreq	r0, [r4, #0]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  113400:	bf17      	itett	ne
  113402:	a902      	addne	r1, sp, #8
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  113404:	9a0a      	ldreq	r2, [sp, #40]	; 0x28
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  113406:	461a      	movne	r2, r3
  113408:	6820      	ldrne	r0, [r4, #0]
  11340a:	f7fe fac1 	bl	111990 <xQueueGenericSend>
}
  11340e:	b006      	add	sp, #24
  113410:	bd70      	pop	{r4, r5, r6, r15}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  113412:	461a      	mov	r2, r3
  113414:	a902      	add	r1, sp, #8
  113416:	2300      	movs	r3, #0
  113418:	f7fe fb9e 	bl	111b58 <xQueueGenericSendFromISR>
}
  11341c:	b006      	add	sp, #24
  11341e:	bd70      	pop	{r4, r5, r6, r15}
	configASSERT( xTimer );
  113420:	f64e 708c 	movw	r0, #61324	; 0xef8c
  113424:	f44f 71c1 	mov.w	r1, #386	; 0x182
  113428:	e9cd 2300 	strd	r2, r3, [r13]
  11342c:	f2c0 0011 	movt	r0, #17
  113430:	f7fd ff16 	bl	111260 <vMainAssertCalled>
  113434:	e9dd 2300 	ldrd	r2, r3, [r13]
  113438:	e7cf      	b.n	1133da <xTimerGenericCommand+0xa>
  11343a:	bf00      	nop

0011343c <prvSwitchTimerLists>:
{
  11343c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  113440:	f642 75fc 	movw	r5, #12284	; 0x2ffc
				configASSERT( xResult );
  113444:	f64e 7a8c 	movw	r10, #61324	; 0xef8c
{
  113448:	b082      	sub	sp, #8
  11344a:	f2c0 0513 	movt	r5, #19
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  11344e:	f04f 0800 	mov.w	r8, #0
				configASSERT( xResult );
  113452:	f2c0 0a11 	movt	r10, #17
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  113456:	e00e      	b.n	113476 <prvSwitchTimerLists+0x3a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  113458:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  11345a:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  11345c:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  11345e:	f104 0904 	add.w	r9, r4, #4
  113462:	4648      	mov	r0, r9
  113464:	f7fe f8c6 	bl	1115f4 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  113468:	6a23      	ldr	r3, [r4, #32]
  11346a:	4620      	mov	r0, r4
  11346c:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  11346e:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  113472:	075b      	lsls	r3, r3, #29
  113474:	d40d      	bmi.n	113492 <prvSwitchTimerLists+0x56>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  113476:	682b      	ldr	r3, [r5, #0]
  113478:	681a      	ldr	r2, [r3, #0]
  11347a:	2a00      	cmp	r2, #0
  11347c:	d1ec      	bne.n	113458 <prvSwitchTimerLists+0x1c>
	pxCurrentTimerList = pxOverflowTimerList;
  11347e:	f243 0200 	movw	r2, #12288	; 0x3000
  113482:	f2c0 0213 	movt	r2, #19
  113486:	6811      	ldr	r1, [r2, #0]
  113488:	6029      	str	r1, [r5, #0]
	pxOverflowTimerList = pxTemp;
  11348a:	6013      	str	r3, [r2, #0]
}
  11348c:	b002      	add	sp, #8
  11348e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  113492:	69a7      	ldr	r7, [r4, #24]
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  113494:	2300      	movs	r3, #0
  113496:	4632      	mov	r2, r6
  113498:	4619      	mov	r1, r3
  11349a:	4620      	mov	r0, r4
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  11349c:	eb06 0c07 	add.w	r12, r6, r7
			if( xReloadTime > xNextExpireTime )
  1134a0:	4566      	cmp	r6, r12
  1134a2:	d207      	bcs.n	1134b4 <prvSwitchTimerLists+0x78>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  1134a4:	f8c4 c004 	str.w	r12, [r4, #4]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  1134a8:	4649      	mov	r1, r9
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  1134aa:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  1134ac:	6828      	ldr	r0, [r5, #0]
  1134ae:	f7fe f887 	bl	1115c0 <vListInsert>
  1134b2:	e7e0      	b.n	113476 <prvSwitchTimerLists+0x3a>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  1134b4:	f8cd 8000 	str.w	r8, [r13]
  1134b8:	f7ff ff8a 	bl	1133d0 <xTimerGenericCommand>
				configASSERT( xResult );
  1134bc:	2800      	cmp	r0, #0
  1134be:	d1da      	bne.n	113476 <prvSwitchTimerLists+0x3a>
  1134c0:	f44f 7161 	mov.w	r1, #900	; 0x384
  1134c4:	4650      	mov	r0, r10
  1134c6:	f7fd fecb 	bl	111260 <vMainAssertCalled>
  1134ca:	e7d4      	b.n	113476 <prvSwitchTimerLists+0x3a>

001134cc <prvTimerTask>:
{
  1134cc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1134d0:	f642 77fc 	movw	r7, #12284	; 0x2ffc
  1134d4:	f243 06cc 	movw	r6, #12492	; 0x30cc
  1134d8:	f243 1524 	movw	r5, #12580	; 0x3124
  1134dc:	f243 0800 	movw	r8, #12288	; 0x3000
			configASSERT( xResult );
  1134e0:	f64e 798c 	movw	r9, #61324	; 0xef8c
{
  1134e4:	b087      	sub	sp, #28
  1134e6:	f2c0 0713 	movt	r7, #19
  1134ea:	f2c0 0613 	movt	r6, #19
  1134ee:	f2c0 0513 	movt	r5, #19
  1134f2:	f2c0 0813 	movt	r8, #19
			configASSERT( xResult );
  1134f6:	f2c0 0911 	movt	r9, #17
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  1134fa:	683b      	ldr	r3, [r7, #0]
  1134fc:	681c      	ldr	r4, [r3, #0]
  1134fe:	2c00      	cmp	r4, #0
  113500:	f000 8091 	beq.w	113626 <prvTimerTask+0x15a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  113504:	68db      	ldr	r3, [r3, #12]
  113506:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
  113508:	f7ff fada 	bl	112ac0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
  11350c:	f7ff fae0 	bl	112ad0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  113510:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  113512:	4682      	mov	r10, r0
	if( xTimeNow < xLastTime )
  113514:	4298      	cmp	r0, r3
  113516:	f0c0 808e 	bcc.w	113636 <prvTimerTask+0x16a>
	xLastTime = xTimeNow;
  11351a:	6030      	str	r0, [r6, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  11351c:	4284      	cmp	r4, r0
  11351e:	bf88      	it	hi
  113520:	2200      	movhi	r2, #0
  113522:	f240 809b 	bls.w	11365c <prvTimerTask+0x190>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
  113526:	6828      	ldr	r0, [r5, #0]
  113528:	eba4 010a 	sub.w	r1, r4, r10
  11352c:	f7fe fdee 	bl	11210c <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
  113530:	f7ff fba4 	bl	112c7c <xTaskResumeAll>
  113534:	b900      	cbnz	r0, 113538 <prvTimerTask+0x6c>
					portYIELD_WITHIN_API();
  113536:	df00      	svc	0
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  113538:	2200      	movs	r2, #0
  11353a:	a902      	add	r1, sp, #8
  11353c:	6828      	ldr	r0, [r5, #0]
  11353e:	f7fe fb8b 	bl	111c58 <xQueueReceive>
  113542:	2800      	cmp	r0, #0
  113544:	d0d9      	beq.n	1134fa <prvTimerTask+0x2e>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
  113546:	9b02      	ldr	r3, [sp, #8]
  113548:	9c04      	ldr	r4, [sp, #16]
  11354a:	2b00      	cmp	r3, #0
  11354c:	da07      	bge.n	11355e <prvTimerTask+0x92>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
  11354e:	9b03      	ldr	r3, [sp, #12]
  113550:	4620      	mov	r0, r4
  113552:	9905      	ldr	r1, [sp, #20]
  113554:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
  113556:	9b02      	ldr	r3, [sp, #8]
  113558:	2b00      	cmp	r3, #0
  11355a:	dbed      	blt.n	113538 <prvTimerTask+0x6c>
  11355c:	9c04      	ldr	r4, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
  11355e:	6963      	ldr	r3, [r4, #20]
  113560:	b113      	cbz	r3, 113568 <prvTimerTask+0x9c>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  113562:	1d20      	adds	r0, r4, #4
  113564:	f7fe f846 	bl	1115f4 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
  113568:	f7ff fab2 	bl	112ad0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  11356c:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  11356e:	4683      	mov	r11, r0
	if( xTimeNow < xLastTime )
  113570:	4298      	cmp	r0, r3
  113572:	d367      	bcc.n	113644 <prvTimerTask+0x178>
			switch( xMessage.xMessageID )
  113574:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
  113576:	f8c6 b000 	str.w	r11, [r6]
			switch( xMessage.xMessageID )
  11357a:	2b09      	cmp	r3, #9
  11357c:	d8dc      	bhi.n	113538 <prvTimerTask+0x6c>
  11357e:	e8df f003 	tbb	[r15, r3]
  113582:	2424      	.short	0x2424
  113584:	05124b24 	.word	0x05124b24
  113588:	124b2424 	.word	0x124b2424
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
  11358c:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  113590:	079a      	lsls	r2, r3, #30
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  113592:	bf44      	itt	mi
  113594:	f023 0301 	bicmi.w	r3, r3, #1
  113598:	f884 3028 	strbmi.w	r3, [r4, #40]	; 0x28
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
  11359c:	d4cc      	bmi.n	113538 <prvTimerTask+0x6c>
							vPortFree( pxTimer );
  11359e:	4620      	mov	r0, r4
  1135a0:	f7fd ff8c 	bl	1114bc <vPortFree>
  1135a4:	e7c8      	b.n	113538 <prvTimerTask+0x6c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  1135a6:	9903      	ldr	r1, [sp, #12]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  1135a8:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  1135ac:	61a1      	str	r1, [r4, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  1135ae:	f043 0301 	orr.w	r3, r3, #1
  1135b2:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  1135b6:	2900      	cmp	r1, #0
  1135b8:	f000 8081 	beq.w	1136be <prvTimerTask+0x1f2>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  1135bc:	4620      	mov	r0, r4
  1135be:	4459      	add	r1, r11
  1135c0:	465b      	mov	r3, r11
  1135c2:	465a      	mov	r2, r11
  1135c4:	f7ff fea4 	bl	113310 <prvInsertTimerInActiveList>
  1135c8:	e7b6      	b.n	113538 <prvTimerTask+0x6c>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  1135ca:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  1135ce:	9b03      	ldr	r3, [sp, #12]
  1135d0:	69a1      	ldr	r1, [r4, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  1135d2:	f040 0001 	orr.w	r0, r0, #1
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  1135d6:	465a      	mov	r2, r11
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  1135d8:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  1135dc:	4419      	add	r1, r3
  1135de:	4620      	mov	r0, r4
  1135e0:	f7ff fe96 	bl	113310 <prvInsertTimerInActiveList>
  1135e4:	2800      	cmp	r0, #0
  1135e6:	d0a7      	beq.n	113538 <prvTimerTask+0x6c>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  1135e8:	6a23      	ldr	r3, [r4, #32]
  1135ea:	4620      	mov	r0, r4
  1135ec:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  1135ee:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  1135f2:	0759      	lsls	r1, r3, #29
  1135f4:	d5a0      	bpl.n	113538 <prvTimerTask+0x6c>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  1135f6:	69a2      	ldr	r2, [r4, #24]
  1135f8:	2300      	movs	r3, #0
  1135fa:	4620      	mov	r0, r4
  1135fc:	4619      	mov	r1, r3
  1135fe:	9c03      	ldr	r4, [sp, #12]
  113600:	9300      	str	r3, [sp, #0]
  113602:	4422      	add	r2, r4
  113604:	f7ff fee4 	bl	1133d0 <xTimerGenericCommand>
							configASSERT( xResult );
  113608:	2800      	cmp	r0, #0
  11360a:	d195      	bne.n	113538 <prvTimerTask+0x6c>
  11360c:	f240 3113 	movw	r1, #787	; 0x313
  113610:	4648      	mov	r0, r9
  113612:	f7fd fe25 	bl	111260 <vMainAssertCalled>
  113616:	e78f      	b.n	113538 <prvTimerTask+0x6c>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  113618:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  11361c:	f023 0301 	bic.w	r3, r3, #1
  113620:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  113624:	e788      	b.n	113538 <prvTimerTask+0x6c>
	vTaskSuspendAll();
  113626:	f7ff fa4b 	bl	112ac0 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
  11362a:	f7ff fa51 	bl	112ad0 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  11362e:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  113630:	4682      	mov	r10, r0
	if( xTimeNow < xLastTime )
  113632:	4298      	cmp	r0, r3
  113634:	d209      	bcs.n	11364a <prvTimerTask+0x17e>
		prvSwitchTimerLists();
  113636:	f7ff ff01 	bl	11343c <prvSwitchTimerLists>
	xLastTime = xTimeNow;
  11363a:	f8c6 a000 	str.w	r10, [r6]
			( void ) xTaskResumeAll();
  11363e:	f7ff fb1d 	bl	112c7c <xTaskResumeAll>
  113642:	e779      	b.n	113538 <prvTimerTask+0x6c>
		prvSwitchTimerLists();
  113644:	f7ff fefa 	bl	11343c <prvSwitchTimerLists>
  113648:	e794      	b.n	113574 <prvTimerTask+0xa8>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  11364a:	f8d8 3000 	ldr.w	r3, [r8]
	xLastTime = xTimeNow;
  11364e:	f8c6 a000 	str.w	r10, [r6]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  113652:	681a      	ldr	r2, [r3, #0]
  113654:	fab2 f282 	clz	r2, r2
  113658:	0952      	lsrs	r2, r2, #5
  11365a:	e764      	b.n	113526 <prvTimerTask+0x5a>
				( void ) xTaskResumeAll();
  11365c:	f7ff fb0e 	bl	112c7c <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  113660:	683b      	ldr	r3, [r7, #0]
  113662:	68db      	ldr	r3, [r3, #12]
  113664:	f8d3 b00c 	ldr.w	r11, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  113668:	f10b 0004 	add.w	r0, r11, #4
  11366c:	f7fd ffc2 	bl	1115f4 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  113670:	f89b 3028 	ldrb.w	r3, [r11, #40]	; 0x28
  113674:	0758      	lsls	r0, r3, #29
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  113676:	bf5c      	itt	pl
  113678:	f023 0301 	bicpl.w	r3, r3, #1
  11367c:	f88b 3028 	strbpl.w	r3, [r11, #40]	; 0x28
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  113680:	d404      	bmi.n	11368c <prvTimerTask+0x1c0>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  113682:	f8db 3020 	ldr.w	r3, [r11, #32]
  113686:	4658      	mov	r0, r11
  113688:	4798      	blx	r3
  11368a:	e755      	b.n	113538 <prvTimerTask+0x6c>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
  11368c:	f8db 1018 	ldr.w	r1, [r11, #24]
  113690:	4652      	mov	r2, r10
  113692:	4623      	mov	r3, r4
  113694:	4658      	mov	r0, r11
  113696:	4421      	add	r1, r4
  113698:	f7ff fe3a 	bl	113310 <prvInsertTimerInActiveList>
  11369c:	2800      	cmp	r0, #0
  11369e:	d0f0      	beq.n	113682 <prvTimerTask+0x1b6>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  1136a0:	2300      	movs	r3, #0
  1136a2:	4622      	mov	r2, r4
  1136a4:	4619      	mov	r1, r3
  1136a6:	4658      	mov	r0, r11
  1136a8:	9300      	str	r3, [sp, #0]
  1136aa:	f7ff fe91 	bl	1133d0 <xTimerGenericCommand>
			configASSERT( xResult );
  1136ae:	2800      	cmp	r0, #0
  1136b0:	d1e7      	bne.n	113682 <prvTimerTask+0x1b6>
  1136b2:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
  1136b6:	4648      	mov	r0, r9
  1136b8:	f7fd fdd2 	bl	111260 <vMainAssertCalled>
  1136bc:	e7e1      	b.n	113682 <prvTimerTask+0x1b6>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  1136be:	f240 312b 	movw	r1, #811	; 0x32b
  1136c2:	4648      	mov	r0, r9
  1136c4:	f7fd fdcc 	bl	111260 <vMainAssertCalled>
  1136c8:	69a1      	ldr	r1, [r4, #24]
  1136ca:	e777      	b.n	1135bc <prvTimerTask+0xf0>

001136cc <app_thread_entry>:
        }
    }
}

static int app_thread_entry(void *arg)
{
  1136cc:	b508      	push	{r3, r14}
    const struct app_descriptor *app = (const struct app_descriptor *)arg;

    app->entry(app, NULL);
  1136ce:	6883      	ldr	r3, [r0, #8]
  1136d0:	2100      	movs	r1, #0
  1136d2:	4798      	blx	r3

    return 0;
}
  1136d4:	2000      	movs	r0, #0
  1136d6:	bd08      	pop	{r3, r15}

001136d8 <apps_init>:
{
  1136d8:	b5f0      	push	{r4, r5, r6, r7, r14}
    for (app = __apps_start; app != __apps_end; app++) {
  1136da:	f24f 5344 	movw	r3, #62788	; 0xf544
  1136de:	f24f 5558 	movw	r5, #62808	; 0xf558
  1136e2:	f2c0 0311 	movt	r3, #17
  1136e6:	f2c0 0511 	movt	r5, #17
  1136ea:	42ab      	cmp	r3, r5
{
  1136ec:	b083      	sub	sp, #12
    for (app = __apps_start; app != __apps_end; app++) {
  1136ee:	d041      	beq.n	113774 <apps_init+0x9c>
  1136f0:	461c      	mov	r4, r3
  1136f2:	f103 0214 	add.w	r2, r3, #20
  1136f6:	1aaa      	subs	r2, r5, r2
  1136f8:	f64c 45cd 	movw	r5, #52429	; 0xcccd
  1136fc:	0892      	lsrs	r2, r2, #2
  1136fe:	f6c0 45cc 	movt	r5, #3276	; 0xccc
  113702:	fb05 f502 	mul.w	r5, r5, r2
  113706:	f025 4540 	bic.w	r5, r5, #3221225472	; 0xc0000000
  11370a:	3501      	adds	r5, #1
  11370c:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  113710:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        if (app->init)
  113714:	6863      	ldr	r3, [r4, #4]
            app->init(app);
  113716:	4620      	mov	r0, r4
    for (app = __apps_start; app != __apps_end; app++) {
  113718:	3414      	adds	r4, #20
        if (app->init)
  11371a:	b103      	cbz	r3, 11371e <apps_init+0x46>
            app->init(app);
  11371c:	4798      	blx	r3
    for (app = __apps_start; app != __apps_end; app++) {
  11371e:	42ac      	cmp	r4, r5
  113720:	d1f8      	bne.n	113714 <apps_init+0x3c>
    for (app = __apps_start; app != __apps_end; app++) {
  113722:	f24f 5544 	movw	r5, #62788	; 0xf544
static void start_app(const struct app_descriptor *app)
{
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

    dprintf(INFO, "starting app %s\n", app->name);
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  113726:	f243 66cd 	movw	r6, #14029	; 0x36cd
    for (app = __apps_start; app != __apps_end; app++) {
  11372a:	f2c0 0511 	movt	r5, #17
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  11372e:	f2c0 0611 	movt	r6, #17
  113732:	e002      	b.n	11373a <apps_init+0x62>
    for (app = __apps_start; app != __apps_end; app++) {
  113734:	3514      	adds	r5, #20
  113736:	42a5      	cmp	r5, r4
  113738:	d01c      	beq.n	113774 <apps_init+0x9c>
        if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
  11373a:	68ab      	ldr	r3, [r5, #8]
  11373c:	2b00      	cmp	r3, #0
  11373e:	d0f9      	beq.n	113734 <apps_init+0x5c>
  113740:	68eb      	ldr	r3, [r5, #12]
  113742:	07da      	lsls	r2, r3, #31
  113744:	d4f6      	bmi.n	113734 <apps_init+0x5c>
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  113746:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  11374a:	f013 0f02 	tst.w	r3, #2
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  11374e:	6828      	ldr	r0, [r5, #0]
  113750:	f04f 0310 	mov.w	r3, #16
  113754:	4631      	mov	r1, r6
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  113756:	bf18      	it	ne
  113758:	692a      	ldrne	r2, [r5, #16]
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  11375a:	9200      	str	r2, [sp, #0]
  11375c:	462a      	mov	r2, r5
  11375e:	f002 ff81 	bl	116664 <thread_create>
    for (app = __apps_start; app != __apps_end; app++) {
  113762:	3514      	adds	r5, #20
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  113764:	4607      	mov	r7, r0
    thread_detach(t);
  113766:	f003 f837 	bl	1167d8 <thread_detach>
    thread_resume(t);
  11376a:	4638      	mov	r0, r7
  11376c:	f003 f80a 	bl	116784 <thread_resume>
    for (app = __apps_start; app != __apps_end; app++) {
  113770:	42a5      	cmp	r5, r4
  113772:	d1e2      	bne.n	11373a <apps_init+0x62>
}
  113774:	b003      	add	sp, #12
  113776:	bdf0      	pop	{r4, r5, r6, r7, r15}

00113778 <spin>:
#include <platform.h>
#include <platform/debug.h>
#include <kernel/spinlock.h>

void spin(uint32_t usecs)
{
  113778:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  11377a:	4604      	mov	r4, r0
    lk_bigtime_t start = current_time_hires();
  11377c:	f7ec ff5a 	bl	100634 <current_time_hires>
  113780:	2500      	movs	r5, #0
  113782:	4606      	mov	r6, r0
  113784:	460f      	mov	r7, r1

    while ((current_time_hires() - start) < usecs)
  113786:	f7ec ff55 	bl	100634 <current_time_hires>
  11378a:	1b82      	subs	r2, r0, r6
  11378c:	eb61 0307 	sbc.w	r3, r1, r7
  113790:	42ab      	cmp	r3, r5
  113792:	bf08      	it	eq
  113794:	42a2      	cmpeq	r2, r4
  113796:	d3f6      	bcc.n	113786 <spin+0xe>
        ;
}
  113798:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  11379a:	bf00      	nop

0011379c <_panic>:

void _panic(void *caller, const char *fmt, ...)
{
  11379c:	b40e      	push	{r1, r2, r3}
  11379e:	b500      	push	{r14}
    printf("panic (caller %p): ", caller);
  1137a0:	4601      	mov	r1, r0
{
  1137a2:	b082      	sub	sp, #8
    printf("panic (caller %p): ", caller);
  1137a4:	f64e 70e8 	movw	r0, #61416	; 0xefe8
{
  1137a8:	ac03      	add	r4, sp, #12
    printf("panic (caller %p): ", caller);
  1137aa:	f2c0 0011 	movt	r0, #17
{
  1137ae:	f854 5b04 	ldr.w	r5, [r4], #4
    printf("panic (caller %p): ", caller);
  1137b2:	f001 f827 	bl	114804 <printf>

    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
  1137b6:	4621      	mov	r1, r4
  1137b8:	4628      	mov	r0, r5
    va_start(ap, fmt);
  1137ba:	9401      	str	r4, [sp, #4]
    vprintf(fmt, ap);
  1137bc:	f001 f84e 	bl	11485c <_vprintf>
    va_end(ap);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  1137c0:	2109      	movs	r1, #9
  1137c2:	2000      	movs	r0, #0
  1137c4:	f7ec fea2 	bl	10050c <platform_halt>

001137c8 <hexdump>:

    return &panic_fd;
}

void hexdump(const void *ptr, size_t len)
{
  1137c8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1137cc:	b089      	sub	sp, #36	; 0x24
    addr_t address = (addr_t)ptr;
    size_t count;

    for (count = 0 ; count < len; count += 16) {
  1137ce:	9102      	str	r1, [sp, #8]
  1137d0:	2900      	cmp	r1, #0
  1137d2:	d05b      	beq.n	11388c <hexdump+0xc4>
            uint8_t  cbuf[16];
        } u;
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
        size_t i;

        printf("0x%08lx: ", address);
  1137d4:	f64e 73fc 	movw	r3, #61436	; 0xeffc
        for (i = 0; i < s / 4; i++) {
            u.buf[i] = ((const uint32_t *)address)[i];
            printf("%08x ", u.buf[i]);
  1137d8:	f24f 0908 	movw	r9, #61448	; 0xf008
        }
        for (; i < 4; i++) {
            printf("         ");
  1137dc:	f24f 0810 	movw	r8, #61456	; 0xf010
        printf("0x%08lx: ", address);
  1137e0:	f2c0 0311 	movt	r3, #17
  1137e4:	4606      	mov	r6, r0
            printf("%08x ", u.buf[i]);
  1137e6:	f2c0 0911 	movt	r9, #17
        printf("0x%08lx: ", address);
  1137ea:	9303      	str	r3, [sp, #12]
            printf("         ");
  1137ec:	f2c0 0811 	movt	r8, #17
    for (count = 0 ; count < len; count += 16) {
  1137f0:	2300      	movs	r3, #0
  1137f2:	9301      	str	r3, [sp, #4]
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  1137f4:	e9dd 2301 	ldrd	r2, r3, [r13, #4]
        printf("0x%08lx: ", address);
  1137f8:	4631      	mov	r1, r6
  1137fa:	9803      	ldr	r0, [sp, #12]
  1137fc:	f10d 0a10 	add.w	r10, r13, #16
        for (i = 0; i < s / 4; i++) {
  113800:	46b3      	mov	r11, r6
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  113802:	1a9c      	subs	r4, r3, r2
  113804:	2c10      	cmp	r4, #16
  113806:	bf28      	it	cs
  113808:	2410      	movcs	r4, #16
        printf("0x%08lx: ", address);
  11380a:	f000 fffb 	bl	114804 <printf>
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  11380e:	3403      	adds	r4, #3
  113810:	f024 0503 	bic.w	r5, r4, #3
        for (i = 0; i < s / 4; i++) {
  113814:	08a4      	lsrs	r4, r4, #2
  113816:	eb06 0784 	add.w	r7, r6, r4, lsl #2
            u.buf[i] = ((const uint32_t *)address)[i];
  11381a:	f85b 3b04 	ldr.w	r3, [r11], #4
            printf("%08x ", u.buf[i]);
  11381e:	4648      	mov	r0, r9
            u.buf[i] = ((const uint32_t *)address)[i];
  113820:	f84a 3b04 	str.w	r3, [r10], #4
            printf("%08x ", u.buf[i]);
  113824:	4619      	mov	r1, r3
  113826:	f000 ffed 	bl	114804 <printf>
        for (i = 0; i < s / 4; i++) {
  11382a:	455f      	cmp	r7, r11
  11382c:	d1f5      	bne.n	11381a <hexdump+0x52>
        for (; i < 4; i++) {
  11382e:	2c04      	cmp	r4, #4
  113830:	d005      	beq.n	11383e <hexdump+0x76>
            printf("         ");
  113832:	4640      	mov	r0, r8
        for (; i < 4; i++) {
  113834:	3401      	adds	r4, #1
            printf("         ");
  113836:	f000 ffe5 	bl	114804 <printf>
        for (; i < 4; i++) {
  11383a:	2c04      	cmp	r4, #4
  11383c:	d1f9      	bne.n	113832 <hexdump+0x6a>
        }
        printf("|");
  11383e:	207c      	movs	r0, #124	; 0x7c

        for (i=0; i < 16; i++) {
  113840:	2400      	movs	r4, #0
        printf("|");
  113842:	f000 ffab 	bl	11479c <putchar>
  113846:	e005      	b.n	113854 <hexdump+0x8c>
            char c = u.cbuf[i];
            if (i < s && isprint(c)) {
                printf("%c", c);
            } else {
                printf(".");
  113848:	202e      	movs	r0, #46	; 0x2e
        for (i=0; i < 16; i++) {
  11384a:	3401      	adds	r4, #1
                printf(".");
  11384c:	f000 ffa6 	bl	11479c <putchar>
        for (i=0; i < 16; i++) {
  113850:	2c10      	cmp	r4, #16
  113852:	d00e      	beq.n	113872 <hexdump+0xaa>
            if (i < s && isprint(c)) {
  113854:	42a5      	cmp	r5, r4
  113856:	d9f7      	bls.n	113848 <hexdump+0x80>
  113858:	ab04      	add	r3, sp, #16
  11385a:	5d1f      	ldrb	r7, [r3, r4]
  11385c:	4638      	mov	r0, r7
  11385e:	f000 f8ef 	bl	113a40 <isprint>
  113862:	2800      	cmp	r0, #0
  113864:	d0f0      	beq.n	113848 <hexdump+0x80>
                printf("%c", c);
  113866:	4638      	mov	r0, r7
        for (i=0; i < 16; i++) {
  113868:	3401      	adds	r4, #1
                printf("%c", c);
  11386a:	f000 ff97 	bl	11479c <putchar>
        for (i=0; i < 16; i++) {
  11386e:	2c10      	cmp	r4, #16
  113870:	d1f0      	bne.n	113854 <hexdump+0x8c>
    for (count = 0 ; count < len; count += 16) {
  113872:	9c01      	ldr	r4, [sp, #4]
            }
        }
        printf("|\n");
  113874:	f24f 001c 	movw	r0, #61468	; 0xf01c
  113878:	f2c0 0011 	movt	r0, #17
    for (count = 0 ; count < len; count += 16) {
  11387c:	3410      	adds	r4, #16
        address += 16;
  11387e:	3610      	adds	r6, #16
    for (count = 0 ; count < len; count += 16) {
  113880:	9401      	str	r4, [sp, #4]
        printf("|\n");
  113882:	f000 ffa7 	bl	1147d4 <puts>
    for (count = 0 ; count < len; count += 16) {
  113886:	9b02      	ldr	r3, [sp, #8]
  113888:	42a3      	cmp	r3, r4
  11388a:	d8b3      	bhi.n	1137f4 <hexdump+0x2c>
    }
}
  11388c:	b009      	add	sp, #36	; 0x24
  11388e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  113892:	bf00      	nop

00113894 <bcopy>:
.align 2

/* void bcopy(const void *src, void *dest, size_t n); */
FUNCTION(bcopy)
    // swap args for bcopy
    mov     r12, r0
  113894:	e1a0c000 	mov	r12, r0
    mov     r0, r1
  113898:	e1a00001 	mov	r0, r1
    mov     r1, r12
  11389c:	e1a0100c 	mov	r1, r12

001138a0 <memcpy>:

/* void *memcpy(void *dest, const void *src, size_t n); */
FUNCTION(memmove)
FUNCTION(memcpy)
    // check for zero length copy or the same pointer
    cmp     r2, #0
  1138a0:	e3520000 	cmp	r2, #0
    cmpne   r1, r0
  1138a4:	11510000 	cmpne	r1, r0
    bxeq    lr
  1138a8:	012fff1e 	bxeq	r14

    // save a few registers for use and the return code (input dst)
    stmfd   sp!, {r0, r4, r5, lr}
  1138ac:	e92d4031 	push	{r0, r4, r5, r14}

    // check for forwards overlap (src > dst, distance < len)
    subs    r3, r0, r1
  1138b0:	e0503001 	subs	r3, r0, r1
    cmphi   r2, r3
  1138b4:	81520003 	cmphi	r2, r3
    bhi     .L_forwardoverlap
  1138b8:	8a000030 	bhi	113980 <memcpy+0xe0>

    // check for a short copy len.
    // 20 bytes is enough so that if a 16 byte alignment needs to happen there is at least a 
    //   wordwise copy worth of work to be done.
    cmp     r2, #(16+4)
  1138bc:	e3520014 	cmp	r2, #20
    blo     .L_bytewise
  1138c0:	3a000019 	bcc	11392c <memcpy+0x8c>

    // see if they are similarly aligned on 4 byte boundaries
    eor     r3, r0, r1
  1138c4:	e0203001 	eor	r3, r0, r1
    tst     r3, #3
  1138c8:	e3130003 	tst	r3, #3
    bne     .L_bytewise     // dissimilarly aligned, nothing we can do (for now)
  1138cc:	1a000016 	bne	11392c <memcpy+0x8c>

    // check for 16 byte alignment on dst.
    // this will also catch src being not 4 byte aligned, since it is similarly 4 byte 
    //   aligned with dst at this point.
    tst     r0, #15
  1138d0:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  1138d4:	1a00001a 	bne	113944 <memcpy+0xa4>

    // check to see if we have at least 32 bytes of data to copy.
    // if not, just revert to wordwise copy
    cmp     r2, #32
  1138d8:	e3520020 	cmp	r2, #32
    blo     .L_wordwise
  1138dc:	3a00000b 	bcc	113910 <memcpy+0x70>
.L_bigcopy:
    // copy 32 bytes at a time. src & dst need to be at least 4 byte aligned, 
    // and we need at least 32 bytes remaining to copy

    // save r6-r7 for use in the big copy
    stmfd   sp!, {r6-r11}
  1138e0:	e92d0fc0 	push	{r6, r7, r8, r9, r10, r11}

    sub     r2, r2, #32     // subtract an extra 32 to the len so we can avoid an extra compare
  1138e4:	e2422020 	sub	r2, r2, #32

.L_bigcopy_loop:
    pld     [r1, #64]
  1138e8:	f5d1f040 	pld	[r1, #64]	; 0x40
    ldmia   r1!, {r4-r11}
  1138ec:	e8b10ff0 	ldm	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
    subs    r2, r2, #32
  1138f0:	e2522020 	subs	r2, r2, #32
    stmia   r0!, {r4-r11}
  1138f4:	e8a00ff0 	stmia	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
    bhs     .L_bigcopy_loop
  1138f8:	2afffffa 	bcs	1138e8 <memcpy+0x48>

    // restore r6-r7
    ldmfd   sp!, {r6-r11}
  1138fc:	e8bd0fc0 	pop	{r6, r7, r8, r9, r10, r11}

    // see if we are done
    adds    r2, r2, #32
  113900:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  113904:	0a00000c 	beq	11393c <memcpy+0x9c>

    // less then 4 bytes left?
    cmp     r2, #4
  113908:	e3520004 	cmp	r2, #4
    blo     .L_bytewise
  11390c:	3a000006 	bcc	11392c <memcpy+0x8c>

.L_wordwise:
    // copy 4 bytes at a time.
    // src & dst are guaranteed to be word aligned, and at least 4 bytes are left to copy.
    subs    r2, r2, #4
  113910:	e2522004 	subs	r2, r2, #4

.L_wordwise_loop:
    ldr     r3, [r1], #4
  113914:	e4913004 	ldr	r3, [r1], #4
    subs    r2, r2, #4
  113918:	e2522004 	subs	r2, r2, #4
    str     r3, [r0], #4
  11391c:	e4803004 	str	r3, [r0], #4
    bhs     .L_wordwise_loop
  113920:	2afffffb 	bcs	113914 <memcpy+0x74>

    // correct the remaining len and test for completion
    adds    r2, r2, #4  
  113924:	e2922004 	adds	r2, r2, #4
    beq     .L_done
  113928:	0a000003 	beq	11393c <memcpy+0x9c>

.L_bytewise:
    // simple bytewise copy
    ldrb    r3, [r1], #1
  11392c:	e4d13001 	ldrb	r3, [r1], #1
    subs    r2, r2, #1
  113930:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #1
  113934:	e4c03001 	strb	r3, [r0], #1
    bhi     .L_bytewise
  113938:	8afffffb 	bhi	11392c <memcpy+0x8c>
.L_done:
    // load dst for return and restore r4,r5
#if ARM_ARCH_LEVEL >= 5
    ldmfd   sp!, {r0, r4, r5, pc}
#else
    ldmfd   sp!, {r0, r4, r5, lr}
  11393c:	e8bd4031 	pop	{r0, r4, r5, r14}
    bx      lr
  113940:	e12fff1e 	bx	r14
.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will copy up to 15 bytes to get it aligned.
    // src is guaranteed to be similarly word aligned with dst.

    // set the condition flags based on the alignment.
    lsl     r12, r0, #28
  113944:	e1a0ce00 	lsl	r12, r0, #28
    rsb     r12, r12, #0
  113948:	e26cc000 	rsb	r12, r12, #0
    msr     CPSR_f, r12             // move into NZCV fields in CPSR
  11394c:	e128f00c 	msr	CPSR_f, r12

    // move as many bytes as necessary to get the dst aligned
    ldrvsb  r3, [r1], #1            // V set
  113950:	64d13001 	ldrbvs	r3, [r1], #1
    ldrcsh  r4, [r1], #2            // C set
  113954:	20d140b2 	ldrhcs	r4, [r1], #2
    ldreq   r5, [r1], #4            // Z set
  113958:	04915004 	ldreq	r5, [r1], #4

    strvsb  r3, [r0], #1
  11395c:	64c03001 	strbvs	r3, [r0], #1
    strcsh  r4, [r0], #2
  113960:	20c040b2 	strhcs	r4, [r0], #2
    streq   r5, [r0], #4
  113964:	04805004 	streq	r5, [r0], #4

    ldmmiia r1!, {r3-r4}            // N set
  113968:	48b10018 	ldmmi	r1!, {r3, r4}
    stmmiia r0!, {r3-r4}
  11396c:	48a00018 	stmiami	r0!, {r3, r4}

    // fix the remaining len
    sub     r2, r2, r12, lsr #28
  113970:	e0422e2c 	sub	r2, r2, r12, lsr #28

    // test to see what we should do now
    cmp     r2, #32
  113974:	e3520020 	cmp	r2, #32
    bhs     .L_bigcopy
  113978:	2affffd8 	bcs	1138e0 <memcpy+0x40>
    b       .L_wordwise
  11397c:	eaffffe3 	b	113910 <memcpy+0x70>

    // src and dest overlap 'forwards' or dst > src
.L_forwardoverlap:

    // do a bytewise reverse copy for now
    add     r1, r1, r2
  113980:	e0811002 	add	r1, r1, r2
    add     r0, r0, r2
  113984:	e0800002 	add	r0, r0, r2
    sub     r1, r1, #1
  113988:	e2411001 	sub	r1, r1, #1
    sub     r0, r0, #1
  11398c:	e2400001 	sub	r0, r0, #1

.L_bytewisereverse:
    // simple bytewise reverse copy
    ldrb    r3, [r1], #-1
  113990:	e4513001 	ldrb	r3, [r1], #-1
    subs    r2, r2, #1
  113994:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #-1
  113998:	e4403001 	strb	r3, [r0], #-1
    bhi     .L_bytewisereverse
  11399c:	8afffffb 	bhi	113990 <memcpy+0xf0>

    b       .L_done
  1139a0:	eaffffe5 	b	11393c <memcpy+0x9c>

001139a4 <bzero>:
.text
.align 2

/* void bzero(void *s, size_t n); */
FUNCTION(bzero)
    mov     r2, r1
  1139a4:	e1a02001 	mov	r2, r1
    mov     r1, #0
  1139a8:	e3a01000 	mov	r1, #0

001139ac <memset>:

/* void *memset(void *s, int c, size_t n); */
FUNCTION(memset)
    // check for zero length
    cmp     r2, #0
  1139ac:	e3520000 	cmp	r2, #0
    bxeq    lr
  1139b0:	012fff1e 	bxeq	r14

    // save the original pointer
    mov     r12, r0
  1139b4:	e1a0c000 	mov	r12, r0

    // short memsets aren't worth optimizing
    cmp     r2, #(32 + 16)
  1139b8:	e3520030 	cmp	r2, #48	; 0x30
    blt     .L_bytewise
  1139bc:	ba000010 	blt	113a04 <memset+0x58>

    // fill a 32 bit register with the 8 bit value
    and     r1, r1, #0xff
  1139c0:	e20110ff 	and	r1, r1, #255	; 0xff
    orr     r1, r1, r1, lsl #8
  1139c4:	e1811401 	orr	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
  1139c8:	e1811801 	orr	r1, r1, r1, lsl #16

    // check for 16 byte alignment
    tst     r0, #15
  1139cc:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  1139d0:	1a000010 	bne	113a18 <memset+0x6c>

.L_bigset:
    // dump some registers to make space for our values
    stmfd   sp!, { r4-r5 }
  1139d4:	e92d0030 	push	{r4, r5}

    // fill a bunch of registers with the set value
    mov     r3, r1
  1139d8:	e1a03001 	mov	r3, r1
    mov     r4, r1
  1139dc:	e1a04001 	mov	r4, r1
    mov     r5, r1
  1139e0:	e1a05001 	mov	r5, r1

    // prepare the count register so we can avoid an extra compare
    sub     r2, r2, #32
  1139e4:	e2422020 	sub	r2, r2, #32

    // 32 bytes at a time
.L_bigset_loop:
    stmia   r0!, { r1, r3, r4, r5 }
  1139e8:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    subs    r2, r2, #32
  1139ec:	e2522020 	subs	r2, r2, #32
    stmia   r0!, { r1, r3, r4, r5 }
  1139f0:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    bge     .L_bigset_loop
  1139f4:	aafffffb 	bge	1139e8 <memset+0x3c>

    // restore our dumped registers
    ldmfd   sp!, { r4-r5 }
  1139f8:	e8bd0030 	pop	{r4, r5}

    // see if we're done
    adds    r2, r2, #32
  1139fc:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  113a00:	0a000002 	beq	113a10 <memset+0x64>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
  113a04:	e2522001 	subs	r2, r2, #1
    strb    r1, [r0], #1
  113a08:	e4c01001 	strb	r1, [r0], #1
    bgt     .L_bytewise
  113a0c:	cafffffc 	bgt	113a04 <memset+0x58>

.L_done:
    // restore the base pointer as return value
    mov     r0, r12
  113a10:	e1a0000c 	mov	r0, r12
    bx      lr
  113a14:	e12fff1e 	bx	r14

.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will set up to 15 bytes to get it aligned.

    // set the condition flags based on the alignment.
    lsl     r3, r0, #28
  113a18:	e1a03e00 	lsl	r3, r0, #28
    rsb     r3, r3, #0
  113a1c:	e2633000 	rsb	r3, r3, #0
    msr     CPSR_f, r3             // move into NZCV fields in CPSR
  113a20:	e128f003 	msr	CPSR_f, r3

    // move as many bytes as necessary to get the dst aligned
    strvsb  r1, [r0], #1            // V set
  113a24:	64c01001 	strbvs	r1, [r0], #1
    strcsh  r1, [r0], #2            // C set
  113a28:	20c010b2 	strhcs	r1, [r0], #2
    streq   r1, [r0], #4            // Z set
  113a2c:	04801004 	streq	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  113a30:	44801004 	strmi	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  113a34:	44801004 	strmi	r1, [r0], #4

    // fix the remaining len
    sub     r2, r2, r3, lsr #28
  113a38:	e0422e23 	sub	r2, r2, r3, lsr #28

    // do the large memset
    b       .L_bigset
  113a3c:	eaffffe4 	b	1139d4 <memset+0x28>

00113a40 <isprint>:
    return ((c < ' ') || (c == 0x7f));
}

int isprint(int c)
{
    return ((c >= 0x20) && (c < 0x7f));
  113a40:	3820      	subs	r0, #32
}
  113a42:	285e      	cmp	r0, #94	; 0x5e
  113a44:	bf8c      	ite	hi
  113a46:	2000      	movhi	r0, #0
  113a48:	2001      	movls	r0, #1
  113a4a:	4770      	bx	r14

00113a4c <longlong_to_string>:
#define LEFTFORMATFLAG 0x00000800
#define LEADZEROFLAG   0x00001000
#define BLANKPOSFLAG   0x00002000

__NO_INLINE static char *longlong_to_string(char *buf, unsigned long long n, size_t len, uint flag, char *signchar)
{
  113a4c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  113a50:	f8dd 902c 	ldr.w	r9, [r13, #44]	; 0x2c
  113a54:	4680      	mov	r8, r0
  113a56:	4614      	mov	r4, r2
  113a58:	461d      	mov	r5, r3
  113a5a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    size_t pos = len;
    int negative = 0;

    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  113a5c:	f419 6a80 	ands.w	r10, r9, #1024	; 0x400
  113a60:	d006      	beq.n	113a70 <longlong_to_string+0x24>
  113a62:	2a00      	cmp	r2, #0
  113a64:	f175 0300 	sbcs.w	r3, r5, #0
    int negative = 0;
  113a68:	bfa8      	it	ge
  113a6a:	f04f 0a00 	movge.w	r10, #0
    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  113a6e:	db44      	blt.n	113afa <longlong_to_string+0xae>
    }

    buf[--pos] = 0;

    /* only do the math if the number is >= 10 */
    while (n >= 10) {
  113a70:	2d00      	cmp	r5, #0
    buf[--pos] = 0;
  113a72:	f04f 0300 	mov.w	r3, #0
  113a76:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    while (n >= 10) {
  113a7a:	bf08      	it	eq
  113a7c:	2c0a      	cmpeq	r4, #10
    buf[--pos] = 0;
  113a7e:	f808 3007 	strb.w	r3, [r8, r7]
  113a82:	eb08 0b07 	add.w	r11, r8, r7
    while (n >= 10) {
  113a86:	d316      	bcc.n	113ab6 <longlong_to_string+0x6a>
        int digit = n % 10;
  113a88:	4620      	mov	r0, r4
  113a8a:	4629      	mov	r1, r5
  113a8c:	220a      	movs	r2, #10
  113a8e:	2300      	movs	r3, #0
  113a90:	f003 ffcc 	bl	117a2c <__aeabi_uldivmod>

        n /= 10;
  113a94:	4620      	mov	r0, r4
  113a96:	4629      	mov	r1, r5
  113a98:	2300      	movs	r3, #0

        buf[--pos] = digit + '0';
  113a9a:	3f01      	subs	r7, #1
        int digit = n % 10;
  113a9c:	4616      	mov	r6, r2
        n /= 10;
  113a9e:	220a      	movs	r2, #10
  113aa0:	f003 ffc4 	bl	117a2c <__aeabi_uldivmod>
        buf[--pos] = digit + '0';
  113aa4:	3630      	adds	r6, #48	; 0x30
  113aa6:	f80b 6d01 	strb.w	r6, [r11, #-1]!
        n /= 10;
  113aaa:	4604      	mov	r4, r0
    while (n >= 10) {
  113aac:	2900      	cmp	r1, #0
        n /= 10;
  113aae:	460d      	mov	r5, r1
    while (n >= 10) {
  113ab0:	bf08      	it	eq
  113ab2:	280a      	cmpeq	r0, #10
  113ab4:	d2e8      	bcs.n	113a88 <longlong_to_string+0x3c>
    }
    buf[--pos] = n + '0';
  113ab6:	3f01      	subs	r7, #1
  113ab8:	3430      	adds	r4, #48	; 0x30
  113aba:	eb08 0007 	add.w	r0, r8, r7
  113abe:	f808 4007 	strb.w	r4, [r8, r7]

    if (negative)
  113ac2:	f1ba 0f00 	cmp.w	r10, #0
  113ac6:	d113      	bne.n	113af0 <longlong_to_string+0xa4>
        *signchar = '-';
    else if ((flag & SHOWSIGNFLAG))
  113ac8:	f419 7f00 	tst.w	r9, #512	; 0x200
  113acc:	d10b      	bne.n	113ae6 <longlong_to_string+0x9a>
        *signchar = '+';
    else if ((flag & BLANKPOSFLAG))
  113ace:	f419 5f00 	tst.w	r9, #8192	; 0x2000
        *signchar = ' ';
  113ad2:	bf1b      	ittet	ne
  113ad4:	2320      	movne	r3, #32
  113ad6:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
    else
        *signchar = '\0';
  113ad8:	9b0c      	ldreq	r3, [sp, #48]	; 0x30
        *signchar = ' ';
  113ada:	7013      	strbne	r3, [r2, #0]
        *signchar = '\0';
  113adc:	bf08      	it	eq
  113ade:	f883 a000 	strbeq.w	r10, [r3]

    return &buf[pos];
}
  113ae2:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '+';
  113ae6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  113ae8:	232b      	movs	r3, #43	; 0x2b
  113aea:	7013      	strb	r3, [r2, #0]
}
  113aec:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '-';
  113af0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  113af2:	232d      	movs	r3, #45	; 0x2d
  113af4:	7013      	strb	r3, [r2, #0]
}
  113af6:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        negative = 1;
  113afa:	f04f 0a01 	mov.w	r10, #1
        n = -n;
  113afe:	4254      	negs	r4, r2
  113b00:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  113b04:	e7b4      	b.n	113a70 <longlong_to_string+0x24>
  113b06:	bf00      	nop

00113b08 <exponent_to_string>:
__NO_INLINE static size_t exponent_to_string(char *buf, int32_t exponent)
{
    size_t pos = 0;

    /* handle sign */
    if (exponent < 0) {
  113b08:	2900      	cmp	r1, #0
        OUT('-');
  113b0a:	bfba      	itte	lt
  113b0c:	232d      	movlt	r3, #45	; 0x2d
        exponent = -exponent;
  113b0e:	4249      	neglt	r1, r1
    }
    else {
        OUT('+');
  113b10:	232b      	movge	r3, #43	; 0x2b
    }

    /* see how far we need to bump into the string to print from the right */
    if (exponent >= 1000) pos += 4;
  113b12:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
{
  113b16:	b4f0      	push	{r4, r5, r6, r7}
        OUT('+');
  113b18:	7003      	strb	r3, [r0, #0]
{
  113b1a:	4605      	mov	r5, r0
    if (exponent >= 1000) pos += 4;
  113b1c:	bfa8      	it	ge
  113b1e:	2005      	movge	r0, #5
  113b20:	da03      	bge.n	113b2a <exponent_to_string+0x22>
    else if (exponent >= 100) pos += 3;
  113b22:	2963      	cmp	r1, #99	; 0x63
  113b24:	bfc8      	it	gt
  113b26:	2004      	movgt	r0, #4
  113b28:	dd1a      	ble.n	113b60 <exponent_to_string+0x58>
    else pos++;

    /* print decimal string, from the right */
    uint i = pos;
    do {
        uint digit = (uint32_t)exponent % 10;
  113b2a:	f64c 47cd 	movw	r7, #52429	; 0xcccd

        buf[--i] = digit + '0';

        exponent /= 10;
  113b2e:	f246 6667 	movw	r6, #26215	; 0x6667
  113b32:	4405      	add	r5, r0
        uint digit = (uint32_t)exponent % 10;
  113b34:	f6cc 47cc 	movt	r7, #52428	; 0xcccc
        exponent /= 10;
  113b38:	f2c6 6666 	movt	r6, #26214	; 0x6666
        uint digit = (uint32_t)exponent % 10;
  113b3c:	fba7 2301 	umull	r2, r3, r7, r1
        exponent /= 10;
  113b40:	fb86 2401 	smull	r2, r4, r6, r1
        uint digit = (uint32_t)exponent % 10;
  113b44:	08db      	lsrs	r3, r3, #3
        exponent /= 10;
  113b46:	17ca      	asrs	r2, r1, #31
        uint digit = (uint32_t)exponent % 10;
  113b48:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  113b4c:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
        buf[--i] = digit + '0';
  113b50:	3130      	adds	r1, #48	; 0x30
  113b52:	f805 1d01 	strb.w	r1, [r5, #-1]!
    }
    while (exponent != 0);
  113b56:	ebd2 01a4 	rsbs	r1, r2, r4, asr #2
  113b5a:	d1ef      	bne.n	113b3c <exponent_to_string+0x34>

    /* return number of characters printed */
    return pos;
}
  113b5c:	bcf0      	pop	{r4, r5, r6, r7}
  113b5e:	4770      	bx	r14
    else pos++;
  113b60:	2909      	cmp	r1, #9
  113b62:	bfcc      	ite	gt
  113b64:	2003      	movgt	r0, #3
  113b66:	2002      	movle	r0, #2
  113b68:	e7df      	b.n	113b2a <exponent_to_string+0x22>
  113b6a:	bf00      	nop

00113b6c <double_to_hexstring.isra.0>:

    buf[pos] = 0;
    return buf;
}

__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  113b6c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  113b70:	ec57 6b10 	vmov	r6, r7, d0
  113b74:	4605      	mov	r5, r0
{
    size_t pos = 0;
    union double_int u = { d };

    uint32_t exponent = (u.i >> 52) & 0x7ff;
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113b76:	f64f 79ff 	movw	r9, #65535	; 0xffff
__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  113b7a:	b085      	sub	sp, #20
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113b7c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  113b80:	f401 7180 	and.w	r1, r1, #256	; 0x100
    bool neg = !!(u.i & (1ULL << 63));

    /* start constructing the string */
    if (neg) {
  113b84:	2e00      	cmp	r6, #0
  113b86:	f177 0300 	sbcs.w	r3, r7, #0
        OUT('-');
  113b8a:	bfb8      	it	lt
  113b8c:	222d      	movlt	r2, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  113b8e:	f3c7 500a 	ubfx	r0, r7, #20, #11
        OUT('-');
  113b92:	bfb6      	itet	lt
  113b94:	2301      	movlt	r3, #1
    size_t pos = 0;
  113b96:	2300      	movge	r3, #0
        OUT('-');
  113b98:	702a      	strblt	r2, [r5, #0]
    }

    /* look for special cases */
    if (exponent == 0x7ff) {
  113b9a:	f240 72ff 	movw	r2, #2047	; 0x7ff
  113b9e:	4290      	cmp	r0, r2
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113ba0:	f2c0 090f 	movt	r9, #15
  113ba4:	ea06 0a08 	and.w	r10, r6, r8
  113ba8:	9101      	str	r1, [sp, #4]
  113baa:	ea07 0b09 	and.w	r11, r7, r9
    if (exponent == 0x7ff) {
  113bae:	f000 8097 	beq.w	113ce0 <double_to_hexstring.isra.0+0x174>
            /* NaN */
            if (flag & CAPSFLAG) OUTSTR("NAN");
            else OUTSTR("nan");
        }
    }
    else if (exponent == 0) {
  113bb2:	b9f0      	cbnz	r0, 113bf2 <double_to_hexstring.isra.0+0x86>
        if (fraction == 0) {
  113bb4:	ea5a 020b 	orrs.w	r2, r10, r11
            /* zero */
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  113bb8:	9a01      	ldr	r2, [sp, #4]
        if (fraction == 0) {
  113bba:	f000 80d5 	beq.w	113d68 <double_to_hexstring.isra.0+0x1fc>
            else OUTSTR("0x0p+0");
        }
        else {
            /* denormalized */
            /* XXX does not handle */
            if (flag & CAPSFLAG) OUTSTR("DEN");
  113bbe:	2a00      	cmp	r2, #0
  113bc0:	f040 810f 	bne.w	113de2 <double_to_hexstring.isra.0+0x276>
            else OUTSTR("den");
  113bc4:	2064      	movs	r0, #100	; 0x64
  113bc6:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("DEN");
  113bc8:	2265      	movs	r2, #101	; 0x65
            else OUTSTR("den");
  113bca:	3301      	adds	r3, #1
  113bcc:	4c95      	ldr	r4, [pc, #596]	; (113e24 <double_to_hexstring.isra.0+0x2b8>)
  113bce:	f801 0b01 	strb.w	r0, [r1], #1
  113bd2:	b13a      	cbz	r2, 113be4 <double_to_hexstring.isra.0+0x78>
  113bd4:	4610      	mov	r0, r2
  113bd6:	3301      	adds	r3, #1
  113bd8:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113bdc:	f801 0b01 	strb.w	r0, [r1], #1
  113be0:	2a00      	cmp	r2, #0
  113be2:	d1f7      	bne.n	113bd4 <double_to_hexstring.isra.0+0x68>
        /* handle the exponent */
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
        pos += exponent_to_string(&buf[pos], exponent_signed);
    }

    buf[pos] = 0;
  113be4:	2200      	movs	r2, #0
  113be6:	442b      	add	r3, r5
    return buf;
}
  113be8:	4628      	mov	r0, r5
    buf[pos] = 0;
  113bea:	701a      	strb	r2, [r3, #0]
}
  113bec:	b005      	add	sp, #20
  113bee:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        int exponent_signed = exponent - 1023;
  113bf2:	f2a0 32ff 	subw	r2, r0, #1023	; 0x3ff
  113bf6:	9203      	str	r2, [sp, #12]
        if (flag & CAPSFLAG) OUTSTR("0X1");
  113bf8:	9a01      	ldr	r2, [sp, #4]
  113bfa:	2a00      	cmp	r2, #0
  113bfc:	f000 809e 	beq.w	113d3c <double_to_hexstring.isra.0+0x1d0>
  113c00:	2030      	movs	r0, #48	; 0x30
  113c02:	18e9      	adds	r1, r5, r3
  113c04:	2258      	movs	r2, #88	; 0x58
  113c06:	3301      	adds	r3, #1
  113c08:	4c87      	ldr	r4, [pc, #540]	; (113e28 <double_to_hexstring.isra.0+0x2bc>)
  113c0a:	f801 0b01 	strb.w	r0, [r1], #1
  113c0e:	b13a      	cbz	r2, 113c20 <double_to_hexstring.isra.0+0xb4>
  113c10:	4610      	mov	r0, r2
  113c12:	3301      	adds	r3, #1
  113c14:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113c18:	f801 0b01 	strb.w	r0, [r1], #1
  113c1c:	2a00      	cmp	r2, #0
  113c1e:	d1f7      	bne.n	113c10 <double_to_hexstring.isra.0+0xa4>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113c20:	f24f 027c 	movw	r2, #61564	; 0xf07c
  113c24:	f2c0 0211 	movt	r2, #17
  113c28:	9202      	str	r2, [sp, #8]
        bool output_dot = false;
  113c2a:	f04f 0900 	mov.w	r9, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  113c2e:	2130      	movs	r1, #48	; 0x30
        int zero_count = 0;
  113c30:	464e      	mov	r6, r9
                    OUT('0');
  113c32:	468c      	mov	r12, r1
  113c34:	e002      	b.n	113c3c <double_to_hexstring.isra.0+0xd0>
        for (int i = 52 - 4; i >= 0; i -= 4) {
  113c36:	3904      	subs	r1, #4
  113c38:	1d0a      	adds	r2, r1, #4
  113c3a:	d045      	beq.n	113cc8 <double_to_hexstring.isra.0+0x15c>
            uint digit = (fraction >> i) & 0xf;
  113c3c:	f1c1 0420 	rsb	r4, r1, #32
  113c40:	fa0b f404 	lsl.w	r4, r11, r4
  113c44:	fa2a f201 	lsr.w	r2, r10, r1
  113c48:	f1a1 0020 	sub.w	r0, r1, #32
  113c4c:	4322      	orrs	r2, r4
  113c4e:	fa2b f000 	lsr.w	r0, r11, r0
  113c52:	4302      	orrs	r2, r0
            if (digit == 0) {
  113c54:	f012 020f 	ands.w	r2, r2, #15
  113c58:	f103 0401 	add.w	r4, r3, #1
  113c5c:	eb05 0004 	add.w	r0, r5, r4
  113c60:	eb05 0e03 	add.w	r14, r5, r3
                zero_count++;
  113c64:	bf08      	it	eq
  113c66:	3601      	addeq	r6, #1
            if (digit == 0) {
  113c68:	d0e5      	beq.n	113c36 <double_to_hexstring.isra.0+0xca>
  113c6a:	1c9f      	adds	r7, r3, #2
  113c6c:	eb05 0807 	add.w	r8, r5, r7
                if (!output_dot) {
  113c70:	f1b9 0f00 	cmp.w	r9, #0
  113c74:	d10c      	bne.n	113c90 <double_to_hexstring.isra.0+0x124>
  113c76:	f103 0903 	add.w	r9, r3, #3
                    OUT('.');
  113c7a:	f04f 032e 	mov.w	r3, #46	; 0x2e
  113c7e:	f88e 3000 	strb.w	r3, [r14]
  113c82:	4623      	mov	r3, r4
  113c84:	4686      	mov	r14, r0
  113c86:	463c      	mov	r4, r7
  113c88:	4640      	mov	r0, r8
  113c8a:	464f      	mov	r7, r9
  113c8c:	eb05 0809 	add.w	r8, r5, r9
                while (zero_count > 0) {
  113c90:	2e00      	cmp	r6, #0
  113c92:	d079      	beq.n	113d88 <double_to_hexstring.isra.0+0x21c>
  113c94:	19ac      	adds	r4, r5, r6
  113c96:	441c      	add	r4, r3
  113c98:	18e8      	adds	r0, r5, r3
                    OUT('0');
  113c9a:	f800 cb01 	strb.w	r12, [r0], #1
                while (zero_count > 0) {
  113c9e:	4284      	cmp	r4, r0
  113ca0:	d1fb      	bne.n	113c9a <double_to_hexstring.isra.0+0x12e>
  113ca2:	441e      	add	r6, r3
  113ca4:	19a8      	adds	r0, r5, r6
  113ca6:	1c73      	adds	r3, r6, #1
  113ca8:	9000      	str	r0, [sp, #0]
  113caa:	1cb4      	adds	r4, r6, #2
  113cac:	eb05 0e03 	add.w	r14, r5, r3
  113cb0:	1928      	adds	r0, r5, r4
                buf[pos++] = table[digit];
  113cb2:	9f02      	ldr	r7, [sp, #8]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  113cb4:	3904      	subs	r1, #4
                buf[pos++] = table[digit];
  113cb6:	5cba      	ldrb	r2, [r7, r2]
  113cb8:	9f00      	ldr	r7, [sp, #0]
  113cba:	703a      	strb	r2, [r7, #0]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  113cbc:	1d0a      	adds	r2, r1, #4
                buf[pos++] = table[digit];
  113cbe:	f04f 0901 	mov.w	r9, #1
  113cc2:	f04f 0600 	mov.w	r6, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  113cc6:	d1b9      	bne.n	113c3c <double_to_hexstring.isra.0+0xd0>
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  113cc8:	9b01      	ldr	r3, [sp, #4]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  113cca:	9903      	ldr	r1, [sp, #12]
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  113ccc:	2b00      	cmp	r3, #0
  113cce:	bf0c      	ite	eq
  113cd0:	2370      	moveq	r3, #112	; 0x70
  113cd2:	2350      	movne	r3, #80	; 0x50
  113cd4:	f88e 3000 	strb.w	r3, [r14]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  113cd8:	f7ff ff16 	bl	113b08 <exponent_to_string>
  113cdc:	1903      	adds	r3, r0, r4
  113cde:	e781      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
        if (fraction == 0) {
  113ce0:	ea5a 020b 	orrs.w	r2, r10, r11
  113ce4:	d114      	bne.n	113d10 <double_to_hexstring.isra.0+0x1a4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  113ce6:	2900      	cmp	r1, #0
  113ce8:	d155      	bne.n	113d96 <double_to_hexstring.isra.0+0x22a>
            else OUTSTR("inf");
  113cea:	2069      	movs	r0, #105	; 0x69
  113cec:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("INF");
  113cee:	226e      	movs	r2, #110	; 0x6e
            else OUTSTR("inf");
  113cf0:	3301      	adds	r3, #1
  113cf2:	4c4e      	ldr	r4, [pc, #312]	; (113e2c <double_to_hexstring.isra.0+0x2c0>)
  113cf4:	f801 0b01 	strb.w	r0, [r1], #1
  113cf8:	2a00      	cmp	r2, #0
  113cfa:	f43f af73 	beq.w	113be4 <double_to_hexstring.isra.0+0x78>
  113cfe:	4610      	mov	r0, r2
  113d00:	3301      	adds	r3, #1
  113d02:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113d06:	f801 0b01 	strb.w	r0, [r1], #1
  113d0a:	2a00      	cmp	r2, #0
  113d0c:	d1f7      	bne.n	113cfe <double_to_hexstring.isra.0+0x192>
  113d0e:	e769      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  113d10:	9a01      	ldr	r2, [sp, #4]
  113d12:	2a00      	cmp	r2, #0
  113d14:	d152      	bne.n	113dbc <double_to_hexstring.isra.0+0x250>
            else OUTSTR("nan");
  113d16:	206e      	movs	r0, #110	; 0x6e
  113d18:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("NAN");
  113d1a:	2261      	movs	r2, #97	; 0x61
            else OUTSTR("nan");
  113d1c:	3301      	adds	r3, #1
  113d1e:	4c44      	ldr	r4, [pc, #272]	; (113e30 <double_to_hexstring.isra.0+0x2c4>)
  113d20:	f801 0b01 	strb.w	r0, [r1], #1
  113d24:	2a00      	cmp	r2, #0
  113d26:	f43f af5d 	beq.w	113be4 <double_to_hexstring.isra.0+0x78>
  113d2a:	4610      	mov	r0, r2
  113d2c:	3301      	adds	r3, #1
  113d2e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113d32:	f801 0b01 	strb.w	r0, [r1], #1
  113d36:	2a00      	cmp	r2, #0
  113d38:	d1f7      	bne.n	113d2a <double_to_hexstring.isra.0+0x1be>
  113d3a:	e753      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
        else OUTSTR("0x1");
  113d3c:	2030      	movs	r0, #48	; 0x30
  113d3e:	18e9      	adds	r1, r5, r3
        if (flag & CAPSFLAG) OUTSTR("0X1");
  113d40:	2278      	movs	r2, #120	; 0x78
        else OUTSTR("0x1");
  113d42:	3301      	adds	r3, #1
  113d44:	4c3b      	ldr	r4, [pc, #236]	; (113e34 <double_to_hexstring.isra.0+0x2c8>)
  113d46:	f801 0b01 	strb.w	r0, [r1], #1
  113d4a:	b13a      	cbz	r2, 113d5c <double_to_hexstring.isra.0+0x1f0>
  113d4c:	4610      	mov	r0, r2
  113d4e:	3301      	adds	r3, #1
  113d50:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113d54:	f801 0b01 	strb.w	r0, [r1], #1
  113d58:	2a00      	cmp	r2, #0
  113d5a:	d1f7      	bne.n	113d4c <double_to_hexstring.isra.0+0x1e0>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113d5c:	f24f 026c 	movw	r2, #61548	; 0xf06c
  113d60:	f2c0 0211 	movt	r2, #17
  113d64:	9202      	str	r2, [sp, #8]
  113d66:	e760      	b.n	113c2a <double_to_hexstring.isra.0+0xbe>
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  113d68:	2a00      	cmp	r2, #0
  113d6a:	d14d      	bne.n	113e08 <double_to_hexstring.isra.0+0x29c>
  113d6c:	4c32      	ldr	r4, [pc, #200]	; (113e38 <double_to_hexstring.isra.0+0x2cc>)
  113d6e:	18e9      	adds	r1, r5, r3
  113d70:	2278      	movs	r2, #120	; 0x78
            else OUTSTR("0x0p+0");
  113d72:	2030      	movs	r0, #48	; 0x30
  113d74:	e002      	b.n	113d7c <double_to_hexstring.isra.0+0x210>
  113d76:	4610      	mov	r0, r2
  113d78:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113d7c:	f801 0b01 	strb.w	r0, [r1], #1
  113d80:	3301      	adds	r3, #1
  113d82:	2a00      	cmp	r2, #0
  113d84:	d1f7      	bne.n	113d76 <double_to_hexstring.isra.0+0x20a>
  113d86:	e72d      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
                while (zero_count > 0) {
  113d88:	f8cd e000 	str.w	r14, [r13]
  113d8c:	4623      	mov	r3, r4
  113d8e:	4686      	mov	r14, r0
  113d90:	463c      	mov	r4, r7
  113d92:	4640      	mov	r0, r8
  113d94:	e78d      	b.n	113cb2 <double_to_hexstring.isra.0+0x146>
            if (flag & CAPSFLAG) OUTSTR("INF");
  113d96:	2049      	movs	r0, #73	; 0x49
  113d98:	18e9      	adds	r1, r5, r3
  113d9a:	224e      	movs	r2, #78	; 0x4e
  113d9c:	3301      	adds	r3, #1
  113d9e:	4c27      	ldr	r4, [pc, #156]	; (113e3c <double_to_hexstring.isra.0+0x2d0>)
  113da0:	f801 0b01 	strb.w	r0, [r1], #1
  113da4:	2a00      	cmp	r2, #0
  113da6:	f43f af1d 	beq.w	113be4 <double_to_hexstring.isra.0+0x78>
  113daa:	4610      	mov	r0, r2
  113dac:	3301      	adds	r3, #1
  113dae:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113db2:	f801 0b01 	strb.w	r0, [r1], #1
  113db6:	2a00      	cmp	r2, #0
  113db8:	d1f7      	bne.n	113daa <double_to_hexstring.isra.0+0x23e>
  113dba:	e713      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  113dbc:	204e      	movs	r0, #78	; 0x4e
  113dbe:	18e9      	adds	r1, r5, r3
  113dc0:	2241      	movs	r2, #65	; 0x41
  113dc2:	3301      	adds	r3, #1
  113dc4:	4c1e      	ldr	r4, [pc, #120]	; (113e40 <double_to_hexstring.isra.0+0x2d4>)
  113dc6:	f801 0b01 	strb.w	r0, [r1], #1
  113dca:	2a00      	cmp	r2, #0
  113dcc:	f43f af0a 	beq.w	113be4 <double_to_hexstring.isra.0+0x78>
  113dd0:	4610      	mov	r0, r2
  113dd2:	3301      	adds	r3, #1
  113dd4:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113dd8:	f801 0b01 	strb.w	r0, [r1], #1
  113ddc:	2a00      	cmp	r2, #0
  113dde:	d1f7      	bne.n	113dd0 <double_to_hexstring.isra.0+0x264>
  113de0:	e700      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  113de2:	2044      	movs	r0, #68	; 0x44
  113de4:	18e9      	adds	r1, r5, r3
  113de6:	2245      	movs	r2, #69	; 0x45
  113de8:	3301      	adds	r3, #1
  113dea:	4c16      	ldr	r4, [pc, #88]	; (113e44 <double_to_hexstring.isra.0+0x2d8>)
  113dec:	f801 0b01 	strb.w	r0, [r1], #1
  113df0:	2a00      	cmp	r2, #0
  113df2:	f43f aef7 	beq.w	113be4 <double_to_hexstring.isra.0+0x78>
  113df6:	4610      	mov	r0, r2
  113df8:	3301      	adds	r3, #1
  113dfa:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113dfe:	f801 0b01 	strb.w	r0, [r1], #1
  113e02:	2a00      	cmp	r2, #0
  113e04:	d1f7      	bne.n	113df6 <double_to_hexstring.isra.0+0x28a>
  113e06:	e6ed      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
  113e08:	4c0f      	ldr	r4, [pc, #60]	; (113e48 <double_to_hexstring.isra.0+0x2dc>)
  113e0a:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  113e0c:	2258      	movs	r2, #88	; 0x58
  113e0e:	2030      	movs	r0, #48	; 0x30
  113e10:	e002      	b.n	113e18 <double_to_hexstring.isra.0+0x2ac>
  113e12:	4610      	mov	r0, r2
  113e14:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  113e18:	f801 0b01 	strb.w	r0, [r1], #1
  113e1c:	3301      	adds	r3, #1
  113e1e:	2a00      	cmp	r2, #0
  113e20:	d1f7      	bne.n	113e12 <double_to_hexstring.isra.0+0x2a6>
  113e22:	e6df      	b.n	113be4 <double_to_hexstring.isra.0+0x78>
  113e24:	0011f049 	.word	0x0011f049
  113e28:	0011f055 	.word	0x0011f055
  113e2c:	0011f029 	.word	0x0011f029
  113e30:	0011f031 	.word	0x0011f031
  113e34:	0011f051 	.word	0x0011f051
  113e38:	0011f039 	.word	0x0011f039
  113e3c:	0011f02d 	.word	0x0011f02d
  113e40:	0011f035 	.word	0x0011f035
  113e44:	0011f04d 	.word	0x0011f04d
  113e48:	0011f041 	.word	0x0011f041

00113e4c <longlong_to_hexstring.constprop.1>:
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  113e4c:	e92d 08f0 	stmdb	r13!, {r4, r5, r6, r7, r11}
  113e50:	9905      	ldr	r1, [sp, #20]
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113e52:	f24f 077c 	movw	r7, #61564	; 0xf07c
    buf[--pos] = 0;
  113e56:	2500      	movs	r5, #0
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113e58:	f2c0 0711 	movt	r7, #17
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  113e5c:	4693      	mov	r11, r2
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113e5e:	f411 7f80 	tst.w	r1, #256	; 0x100
  113e62:	f24f 016c 	movw	r1, #61548	; 0xf06c
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  113e66:	469c      	mov	r12, r3
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  113e68:	f2c0 0111 	movt	r1, #17
  113e6c:	bf08      	it	eq
  113e6e:	460f      	moveq	r7, r1
  113e70:	f100 041e 	add.w	r4, r0, #30
    buf[--pos] = 0;
  113e74:	77c5      	strb	r5, [r0, #31]
        u /= 16;
  113e76:	ea4f 111b 	mov.w	r1, r11, lsr #4
  113e7a:	ea41 710c 	orr.w	r1, r1, r12, lsl #28
  113e7e:	ea4f 161c 	mov.w	r6, r12, lsr #4
  113e82:	46b4      	mov	r12, r6
        unsigned int digit = u % 16;
  113e84:	f00b 020f 	and.w	r2, r11, #15
        u /= 16;
  113e88:	468b      	mov	r11, r1
        buf[--pos] = table[digit];
  113e8a:	5cbd      	ldrb	r5, [r7, r2]
  113e8c:	4620      	mov	r0, r4
    while (u != 0);
  113e8e:	ea5b 030c 	orrs.w	r3, r11, r12
        buf[--pos] = table[digit];
  113e92:	f804 5901 	strb.w	r5, [r4], #-1
    while (u != 0);
  113e96:	d1ee      	bne.n	113e76 <longlong_to_hexstring.constprop.1+0x2a>
}
  113e98:	e8bd 08f0 	ldmia.w	r13!, {r4, r5, r6, r7, r11}
  113e9c:	4770      	bx	r14
  113e9e:	bf00      	nop

00113ea0 <double_to_string.constprop.2>:
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  113ea0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  113ea4:	ec57 6b10 	vmov	r6, r7, d0
  113ea8:	4604      	mov	r4, r0
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113eaa:	f64f 7bff 	movw	r11, #65535	; 0xffff
  113eae:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
  113eb2:	f2c0 0b0f 	movt	r11, #15
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  113eb6:	ee10 8a10 	vmov	r8, s0
    if (neg) {
  113eba:	2e00      	cmp	r6, #0
  113ebc:	f177 0000 	sbcs.w	r0, r7, #0
        OUT('-');
  113ec0:	bfb8      	it	lt
  113ec2:	202d      	movlt	r0, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  113ec4:	f3c7 550a 	ubfx	r5, r7, #20, #11
  113ec8:	46b9      	mov	r9, r7
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113eca:	ea0b 0307 	and.w	r3, r11, r7
        OUT('-');
  113ece:	bfb8      	it	lt
  113ed0:	7020      	strblt	r0, [r4, #0]
    if (exponent == 0x7ff) {
  113ed2:	f240 70ff 	movw	r0, #2047	; 0x7ff
        OUT('-');
  113ed6:	bfba      	itte	lt
  113ed8:	f04f 0c01 	movlt.w	r12, #1
        d = -d;
  113edc:	f087 4700 	eorlt.w	r7, r7, #2147483648	; 0x80000000
    size_t pos = 0;
  113ee0:	f04f 0c00 	movge.w	r12, #0
    if (exponent == 0x7ff) {
  113ee4:	4285      	cmp	r5, r0
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  113ee6:	b089      	sub	sp, #36	; 0x24
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  113ee8:	ea0a 0206 	and.w	r2, r10, r6
    if (exponent == 0x7ff) {
  113eec:	d033      	beq.n	113f56 <double_to_string.constprop.2+0xb6>
    else if (exponent == 0) {
  113eee:	b9f5      	cbnz	r5, 113f2e <double_to_string.constprop.2+0x8e>
        if (fraction == 0) {
  113ef0:	4313      	orrs	r3, r2
  113ef2:	d059      	beq.n	113fa8 <double_to_string.constprop.2+0x108>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  113ef4:	05cb      	lsls	r3, r1, #23
  113ef6:	f100 80ce 	bmi.w	114096 <double_to_string.constprop.2+0x1f6>
            else OUTSTR("den");
  113efa:	2164      	movs	r1, #100	; 0x64
  113efc:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("DEN");
  113f00:	2365      	movs	r3, #101	; 0x65
            else OUTSTR("den");
  113f02:	f10c 0c01 	add.w	r12, r12, #1
  113f06:	488c      	ldr	r0, [pc, #560]	; (114138 <double_to_string.constprop.2+0x298>)
  113f08:	f802 1b01 	strb.w	r1, [r2], #1
  113f0c:	b143      	cbz	r3, 113f20 <double_to_string.constprop.2+0x80>
  113f0e:	4619      	mov	r1, r3
  113f10:	f10c 0c01 	add.w	r12, r12, #1
  113f14:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  113f18:	f802 1b01 	strb.w	r1, [r2], #1
  113f1c:	2b00      	cmp	r3, #0
  113f1e:	d1f6      	bne.n	113f0e <double_to_string.constprop.2+0x6e>
    buf[pos] = 0;
  113f20:	2300      	movs	r3, #0
  113f22:	4620      	mov	r0, r4
  113f24:	f804 300c 	strb.w	r3, [r4, r12]
}
  113f28:	b009      	add	sp, #36	; 0x24
  113f2a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (exponent_signed < -52 || exponent_signed > 52) {
  113f2e:	f2a5 30cb 	subw	r0, r5, #971	; 0x3cb
  113f32:	2868      	cmp	r0, #104	; 0x68
  113f34:	d948      	bls.n	113fc8 <double_to_string.constprop.2+0x128>
  113f36:	4881      	ldr	r0, [pc, #516]	; (11413c <double_to_string.constprop.2+0x29c>)
  113f38:	eb04 020c 	add.w	r2, r4, r12
  113f3c:	2372      	movs	r3, #114	; 0x72
            OUTSTR("<range>");
  113f3e:	213c      	movs	r1, #60	; 0x3c
  113f40:	e002      	b.n	113f48 <double_to_string.constprop.2+0xa8>
  113f42:	4619      	mov	r1, r3
  113f44:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  113f48:	f802 1b01 	strb.w	r1, [r2], #1
  113f4c:	f10c 0c01 	add.w	r12, r12, #1
  113f50:	2b00      	cmp	r3, #0
  113f52:	d1f6      	bne.n	113f42 <double_to_string.constprop.2+0xa2>
  113f54:	e7e4      	b.n	113f20 <double_to_string.constprop.2+0x80>
        if (fraction == 0) {
  113f56:	4313      	orrs	r3, r2
  113f58:	f401 7180 	and.w	r1, r1, #256	; 0x100
  113f5c:	d112      	bne.n	113f84 <double_to_string.constprop.2+0xe4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  113f5e:	2900      	cmp	r1, #0
  113f60:	f040 8089 	bne.w	114076 <double_to_string.constprop.2+0x1d6>
  113f64:	4876      	ldr	r0, [pc, #472]	; (114140 <double_to_string.constprop.2+0x2a0>)
  113f66:	eb04 020c 	add.w	r2, r4, r12
  113f6a:	236e      	movs	r3, #110	; 0x6e
            else OUTSTR("inf");
  113f6c:	2169      	movs	r1, #105	; 0x69
  113f6e:	e002      	b.n	113f76 <double_to_string.constprop.2+0xd6>
  113f70:	4619      	mov	r1, r3
  113f72:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  113f76:	f802 1b01 	strb.w	r1, [r2], #1
  113f7a:	f10c 0c01 	add.w	r12, r12, #1
  113f7e:	2b00      	cmp	r3, #0
  113f80:	d1f6      	bne.n	113f70 <double_to_string.constprop.2+0xd0>
  113f82:	e7cd      	b.n	113f20 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  113f84:	2900      	cmp	r1, #0
  113f86:	d166      	bne.n	114056 <double_to_string.constprop.2+0x1b6>
  113f88:	486e      	ldr	r0, [pc, #440]	; (114144 <double_to_string.constprop.2+0x2a4>)
  113f8a:	eb04 020c 	add.w	r2, r4, r12
  113f8e:	2361      	movs	r3, #97	; 0x61
            else OUTSTR("nan");
  113f90:	216e      	movs	r1, #110	; 0x6e
  113f92:	e002      	b.n	113f9a <double_to_string.constprop.2+0xfa>
  113f94:	4619      	mov	r1, r3
  113f96:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  113f9a:	f802 1b01 	strb.w	r1, [r2], #1
  113f9e:	f10c 0c01 	add.w	r12, r12, #1
  113fa2:	2b00      	cmp	r3, #0
  113fa4:	d1f6      	bne.n	113f94 <double_to_string.constprop.2+0xf4>
  113fa6:	e7bb      	b.n	113f20 <double_to_string.constprop.2+0x80>
  113fa8:	4867      	ldr	r0, [pc, #412]	; (114148 <double_to_string.constprop.2+0x2a8>)
  113faa:	eb04 020c 	add.w	r2, r4, r12
        if (fraction == 0) {
  113fae:	232e      	movs	r3, #46	; 0x2e
            OUTSTR("0.000000");
  113fb0:	2130      	movs	r1, #48	; 0x30
  113fb2:	e002      	b.n	113fba <double_to_string.constprop.2+0x11a>
  113fb4:	4619      	mov	r1, r3
  113fb6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  113fba:	f802 1b01 	strb.w	r1, [r2], #1
  113fbe:	f10c 0c01 	add.w	r12, r12, #1
  113fc2:	2b00      	cmp	r3, #0
  113fc4:	d1f6      	bne.n	113fb4 <double_to_string.constprop.2+0x114>
  113fc6:	e7ab      	b.n	113f20 <double_to_string.constprop.2+0x80>
            OUTREV(0);
  113fc8:	2000      	movs	r0, #0
  113fca:	46a2      	mov	r10, r4
                OUTREV('0');
  113fcc:	f04f 0c30 	mov.w	r12, #48	; 0x30
  113fd0:	f104 0e18 	add.w	r14, r4, #24
            OUTREV(0);
  113fd4:	f80a 0f1f 	strb.w	r0, [r10, #31]!
  113fd8:	4650      	mov	r0, r10
                OUTREV('0');
  113fda:	f800 cd01 	strb.w	r12, [r0, #-1]!
            for (int i = 0; i <= 6; i++)
  113fde:	4570      	cmp	r0, r14
  113fe0:	d1fb      	bne.n	113fda <double_to_string.constprop.2+0x13a>
        int exponent_signed = exponent - 1023;
  113fe2:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
            if (exponent_signed >= 0) {
  113fe6:	2d00      	cmp	r5, #0
                OUTREV('0');
  113fe8:	bfbc      	itt	lt
  113fea:	2517      	movlt	r5, #23
  113fec:	f884 c017 	strblt.w	r12, [r4, #23]
            if (exponent_signed >= 0) {
  113ff0:	da67      	bge.n	1140c2 <double_to_string.constprop.2+0x222>
            uint32_t frac = ((d - u) * 1000000) + .5;
  113ff2:	ed9f 6b4f 	vldr	d6, [r15, #316]	; 114130 <double_to_string.constprop.2+0x290>
  113ff6:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  113ffa:	ec47 6b15 	vmov	d5, r6, r7
            buf[decimal_spot] = '.';
  113ffe:	232e      	movs	r3, #46	; 0x2e
  114000:	7623      	strb	r3, [r4, #24]
            uint32_t frac = ((d - u) * 1000000) + .5;
  114002:	ee05 7b06 	vmla.f64	d7, d5, d6
  114006:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  11400a:	ee17 3a90 	vmov	r3, s15
            while (frac != 0) {
  11400e:	b18b      	cbz	r3, 114034 <double_to_string.constprop.2+0x194>
                uint digit = frac % 10;
  114010:	f64c 40cd 	movw	r0, #52429	; 0xcccd
  114014:	f6cc 40cc 	movt	r0, #52428	; 0xcccc
  114018:	fba0 1203 	umull	r1, r2, r0, r3
  11401c:	08d2      	lsrs	r2, r2, #3
  11401e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  114022:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
                buf[--i] = digit + '0';
  114026:	f103 0130 	add.w	r1, r3, #48	; 0x30
            while (frac != 0) {
  11402a:	4613      	mov	r3, r2
                buf[--i] = digit + '0';
  11402c:	f80a 1d01 	strb.w	r1, [r10, #-1]!
            while (frac != 0) {
  114030:	2a00      	cmp	r2, #0
  114032:	d1f1      	bne.n	114018 <double_to_string.constprop.2+0x178>
            if (neg)
  114034:	f1b8 0f00 	cmp.w	r8, #0
  114038:	f179 0300 	sbcs.w	r3, r9, #0
  11403c:	bfa8      	it	ge
  11403e:	1960      	addge	r0, r4, r5
  114040:	f6bf af72 	bge.w	113f28 <double_to_string.constprop.2+0x88>
                OUTREV('-');
  114044:	4620      	mov	r0, r4
  114046:	2d00      	cmp	r5, #0
  114048:	f43f af6e 	beq.w	113f28 <double_to_string.constprop.2+0x88>
  11404c:	232d      	movs	r3, #45	; 0x2d
  11404e:	3d01      	subs	r5, #1
  114050:	1960      	adds	r0, r4, r5
  114052:	5563      	strb	r3, [r4, r5]
  114054:	e768      	b.n	113f28 <double_to_string.constprop.2+0x88>
  114056:	483d      	ldr	r0, [pc, #244]	; (11414c <double_to_string.constprop.2+0x2ac>)
  114058:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("NAN");
  11405c:	2341      	movs	r3, #65	; 0x41
  11405e:	214e      	movs	r1, #78	; 0x4e
  114060:	e002      	b.n	114068 <double_to_string.constprop.2+0x1c8>
  114062:	4619      	mov	r1, r3
  114064:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  114068:	f802 1b01 	strb.w	r1, [r2], #1
  11406c:	f10c 0c01 	add.w	r12, r12, #1
  114070:	2b00      	cmp	r3, #0
  114072:	d1f6      	bne.n	114062 <double_to_string.constprop.2+0x1c2>
  114074:	e754      	b.n	113f20 <double_to_string.constprop.2+0x80>
  114076:	4836      	ldr	r0, [pc, #216]	; (114150 <double_to_string.constprop.2+0x2b0>)
  114078:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("INF");
  11407c:	234e      	movs	r3, #78	; 0x4e
  11407e:	2149      	movs	r1, #73	; 0x49
  114080:	e002      	b.n	114088 <double_to_string.constprop.2+0x1e8>
  114082:	4619      	mov	r1, r3
  114084:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  114088:	f802 1b01 	strb.w	r1, [r2], #1
  11408c:	f10c 0c01 	add.w	r12, r12, #1
  114090:	2b00      	cmp	r3, #0
  114092:	d1f6      	bne.n	114082 <double_to_string.constprop.2+0x1e2>
  114094:	e744      	b.n	113f20 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  114096:	2144      	movs	r1, #68	; 0x44
  114098:	eb04 020c 	add.w	r2, r4, r12
  11409c:	2345      	movs	r3, #69	; 0x45
  11409e:	f10c 0c01 	add.w	r12, r12, #1
  1140a2:	482c      	ldr	r0, [pc, #176]	; (114154 <double_to_string.constprop.2+0x2b4>)
  1140a4:	f802 1b01 	strb.w	r1, [r2], #1
  1140a8:	2b00      	cmp	r3, #0
  1140aa:	f43f af39 	beq.w	113f20 <double_to_string.constprop.2+0x80>
  1140ae:	4619      	mov	r1, r3
  1140b0:	f10c 0c01 	add.w	r12, r12, #1
  1140b4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1140b8:	f802 1b01 	strb.w	r1, [r2], #1
  1140bc:	2b00      	cmp	r3, #0
  1140be:	d1f6      	bne.n	1140ae <double_to_string.constprop.2+0x20e>
  1140c0:	e72e      	b.n	113f20 <double_to_string.constprop.2+0x80>
                u |= (1ULL<<52);
  1140c2:	4693      	mov	r11, r2
  1140c4:	f443 1c80 	orr.w	r12, r3, #1048576	; 0x100000
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140c8:	f04f 0e19 	mov.w	r14, #25
                u >>= (52 - exponent_signed);
  1140cc:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
  1140d0:	e9cd bc04 	strd	r11, r12, [r13, #16]
  1140d4:	f1c5 0020 	rsb	r0, r5, #32
  1140d8:	9b05      	ldr	r3, [sp, #20]
  1140da:	fa0c f000 	lsl.w	r0, r12, r0
  1140de:	fa22 fb05 	lsr.w	r11, r2, r5
  1140e2:	f1a5 0220 	sub.w	r2, r5, #32
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140e6:	f10d 0c20 	add.w	r12, r13, #32
                u >>= (52 - exponent_signed);
  1140ea:	fa23 f202 	lsr.w	r2, r3, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140ee:	9101      	str	r1, [sp, #4]
                u >>= (52 - exponent_signed);
  1140f0:	ea4b 0b00 	orr.w	r11, r11, r0
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140f4:	2000      	movs	r0, #0
                u >>= (52 - exponent_signed);
  1140f6:	ea4b 0b02 	orr.w	r11, r11, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140fa:	465a      	mov	r2, r11
                u >>= (52 - exponent_signed);
  1140fc:	40eb      	lsrs	r3, r5
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  1140fe:	f80c 0d01 	strb.w	r0, [r12, #-1]!
  114102:	4620      	mov	r0, r4
  114104:	f8cd c008 	str.w	r12, [r13, #8]
                u >>= (52 - exponent_signed);
  114108:	461d      	mov	r5, r3
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  11410a:	f8cd e000 	str.w	r14, [r13]
  11410e:	f7ff fc9d 	bl	113a4c <longlong_to_string>
  114112:	4629      	mov	r1, r5
                pos = s - buf;
  114114:	1b05      	subs	r5, r0, r4
  114116:	4658      	mov	r0, r11
  114118:	f003 fc52 	bl	1179c0 <__aeabi_ul2d>
  11411c:	ec47 6b17 	vmov	d7, r6, r7
  114120:	ec41 0b16 	vmov	d6, r0, r1
  114124:	ee37 7b46 	vsub.f64	d7, d7, d6
  114128:	ec57 6b17 	vmov	r6, r7, d7
  11412c:	e761      	b.n	113ff2 <double_to_string.constprop.2+0x152>
  11412e:	bf00      	nop
  114130:	00000000 	.word	0x00000000
  114134:	412e8480 	.word	0x412e8480
  114138:	0011f049 	.word	0x0011f049
  11413c:	0011f065 	.word	0x0011f065
  114140:	0011f029 	.word	0x0011f029
  114144:	0011f031 	.word	0x0011f031
  114148:	0011f059 	.word	0x0011f059
  11414c:	0011f035 	.word	0x0011f035
  114150:	0011f02d 	.word	0x0011f02d
  114154:	0011f04d 	.word	0x0011f04d

00114158 <_printf_engine>:
#include <kernel/spinlock.h>
static spin_lock_t printf_lock=SPIN_LOCK_INITIAL_VALUE;
#endif

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
  114158:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
                OUTPUT_CHAR(uc);
                break;
            case 's':
                s = va_arg(ap, const char *);
                if (s == 0)
                    s = "<null>";
  11415c:	f24f 0420 	movw	r4, #61472	; 0xf020
{
  114160:	b093      	sub	sp, #76	; 0x4c
  114162:	4607      	mov	r7, r0
                    s = "<null>";
  114164:	f2c0 0411 	movt	r4, #17
    size_t chars_written = 0;
  114168:	2600      	movs	r6, #0
{
  11416a:	4688      	mov	r8, r1
  11416c:	4610      	mov	r0, r2
  11416e:	469b      	mov	r11, r3
                    s = "<null>";
  114170:	9406      	str	r4, [sp, #24]
        signchar = '\0';
  114172:	f04f 0300 	mov.w	r3, #0
        while ((c = *fmt++) != 0) {
  114176:	1c44      	adds	r4, r0, #1
  114178:	7801      	ldrb	r1, [r0, #0]
        signchar = '\0';
  11417a:	f88d 3027 	strb.w	r3, [r13, #39]	; 0x27
        while ((c = *fmt++) != 0) {
  11417e:	b149      	cbz	r1, 114194 <_printf_engine+0x3c>
            if (c == '%')
  114180:	2925      	cmp	r1, #37	; 0x25
  114182:	d102      	bne.n	11418a <_printf_engine+0x32>
  114184:	e010      	b.n	1141a8 <_printf_engine+0x50>
  114186:	2b25      	cmp	r3, #37	; 0x25
  114188:	d00f      	beq.n	1141aa <_printf_engine+0x52>
  11418a:	1a21      	subs	r1, r4, r0
        while ((c = *fmt++) != 0) {
  11418c:	f814 3b01 	ldrb.w	r3, [r4], #1
  114190:	2b00      	cmp	r3, #0
  114192:	d1f8      	bne.n	114186 <_printf_engine+0x2e>
        OUTPUT_STRING(s, string_len);
  114194:	4642      	mov	r2, r8
  114196:	47b8      	blx	r7
  114198:	f1b0 0c00 	subs.w	r12, r0, #0
  11419c:	f280 80d0 	bge.w	114340 <_printf_engine+0x1e8>
exit:
#if WITH_SMP
    spin_unlock_irqrestore(&printf_lock, sstate);
#endif
    return (err < 0) ? err : (int)chars_written;
}
  1141a0:	4660      	mov	r0, r12
  1141a2:	b013      	add	sp, #76	; 0x4c
  1141a4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        string_len = 0;
  1141a8:	2100      	movs	r1, #0
        OUTPUT_STRING(s, string_len);
  1141aa:	4642      	mov	r2, r8
  1141ac:	47b8      	blx	r7
  1141ae:	f1b0 0c00 	subs.w	r12, r0, #0
  1141b2:	dbf5      	blt.n	1141a0 <_printf_engine+0x48>
        format_num = 0;
  1141b4:	2500      	movs	r5, #0
        OUTPUT_STRING(s, string_len);
  1141b6:	4466      	add	r6, r12
        flags = 0;
  1141b8:	46aa      	mov	r10, r5
        c = *fmt++;
  1141ba:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c == 0)
  1141be:	2b00      	cmp	r3, #0
  1141c0:	f000 80bf 	beq.w	114342 <_printf_engine+0x1ea>
        switch (c) {
  1141c4:	f1a3 0220 	sub.w	r2, r3, #32
  1141c8:	2a5a      	cmp	r2, #90	; 0x5a
  1141ca:	f200 821d 	bhi.w	114608 <_printf_engine+0x4b0>
  1141ce:	a101      	add	r1, pc, #4	; (adr r1, 1141d4 <_printf_engine+0x7c>)
  1141d0:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
  1141d4:	001144f9 	.word	0x001144f9
  1141d8:	00114609 	.word	0x00114609
  1141dc:	00114609 	.word	0x00114609
  1141e0:	00114527 	.word	0x00114527
  1141e4:	00114609 	.word	0x00114609
  1141e8:	00114505 	.word	0x00114505
  1141ec:	00114609 	.word	0x00114609
  1141f0:	00114609 	.word	0x00114609
  1141f4:	00114609 	.word	0x00114609
  1141f8:	00114609 	.word	0x00114609
  1141fc:	00114609 	.word	0x00114609
  114200:	00114521 	.word	0x00114521
  114204:	00114609 	.word	0x00114609
  114208:	0011452d 	.word	0x0011452d
  11420c:	001141bb 	.word	0x001141bb
  114210:	00114609 	.word	0x00114609
  114214:	00114533 	.word	0x00114533
  114218:	00114533 	.word	0x00114533
  11421c:	00114533 	.word	0x00114533
  114220:	00114533 	.word	0x00114533
  114224:	00114533 	.word	0x00114533
  114228:	00114533 	.word	0x00114533
  11422c:	00114533 	.word	0x00114533
  114230:	00114533 	.word	0x00114533
  114234:	00114533 	.word	0x00114533
  114238:	00114533 	.word	0x00114533
  11423c:	00114609 	.word	0x00114609
  114240:	00114609 	.word	0x00114609
  114244:	00114609 	.word	0x00114609
  114248:	00114609 	.word	0x00114609
  11424c:	00114609 	.word	0x00114609
  114250:	00114609 	.word	0x00114609
  114254:	00114609 	.word	0x00114609
  114258:	00114493 	.word	0x00114493
  11425c:	00114609 	.word	0x00114609
  114260:	00114609 	.word	0x00114609
  114264:	00114609 	.word	0x00114609
  114268:	00114609 	.word	0x00114609
  11426c:	00114431 	.word	0x00114431
  114270:	00114609 	.word	0x00114609
  114274:	00114609 	.word	0x00114609
  114278:	00114609 	.word	0x00114609
  11427c:	00114609 	.word	0x00114609
  114280:	00114609 	.word	0x00114609
  114284:	00114609 	.word	0x00114609
  114288:	00114609 	.word	0x00114609
  11428c:	00114609 	.word	0x00114609
  114290:	00114609 	.word	0x00114609
  114294:	00114609 	.word	0x00114609
  114298:	00114609 	.word	0x00114609
  11429c:	00114609 	.word	0x00114609
  1142a0:	00114609 	.word	0x00114609
  1142a4:	00114609 	.word	0x00114609
  1142a8:	00114609 	.word	0x00114609
  1142ac:	00114609 	.word	0x00114609
  1142b0:	00114609 	.word	0x00114609
  1142b4:	001145df 	.word	0x001145df
  1142b8:	00114609 	.word	0x00114609
  1142bc:	00114609 	.word	0x00114609
  1142c0:	00114609 	.word	0x00114609
  1142c4:	00114609 	.word	0x00114609
  1142c8:	00114609 	.word	0x00114609
  1142cc:	00114609 	.word	0x00114609
  1142d0:	00114609 	.word	0x00114609
  1142d4:	00114609 	.word	0x00114609
  1142d8:	00114497 	.word	0x00114497
  1142dc:	00114609 	.word	0x00114609
  1142e0:	0011454d 	.word	0x0011454d
  1142e4:	0011456f 	.word	0x0011456f
  1142e8:	00114609 	.word	0x00114609
  1142ec:	00114435 	.word	0x00114435
  1142f0:	00114609 	.word	0x00114609
  1142f4:	001145ad 	.word	0x001145ad
  1142f8:	0011456f 	.word	0x0011456f
  1142fc:	001145ed 	.word	0x001145ed
  114300:	00114609 	.word	0x00114609
  114304:	001145f3 	.word	0x001145f3
  114308:	00114609 	.word	0x00114609
  11430c:	001144b9 	.word	0x001144b9
  114310:	00114609 	.word	0x00114609
  114314:	0011434d 	.word	0x0011434d
  114318:	00114609 	.word	0x00114609
  11431c:	00114609 	.word	0x00114609
  114320:	00114591 	.word	0x00114591
  114324:	00114603 	.word	0x00114603
  114328:	001145bd 	.word	0x001145bd
  11432c:	00114609 	.word	0x00114609
  114330:	00114609 	.word	0x00114609
  114334:	00114351 	.word	0x00114351
  114338:	00114609 	.word	0x00114609
  11433c:	001144ff 	.word	0x001144ff
        OUTPUT_STRING(s, string_len);
  114340:	4466      	add	r6, r12
    return (err < 0) ? err : (int)chars_written;
  114342:	46b4      	mov	r12, r6
}
  114344:	4660      	mov	r0, r12
  114346:	b013      	add	sp, #76	; 0x4c
  114348:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= LONGFLAG | ALTFLAG;
  11434c:	f04a 0a81 	orr.w	r10, r10, #129	; 0x81
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  114350:	f01a 0f02 	tst.w	r10, #2
  114354:	f000 80be 	beq.w	1144d4 <_printf_engine+0x37c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  114358:	f10b 0307 	add.w	r3, r11, #7
  11435c:	f023 0307 	bic.w	r3, r3, #7
  114360:	f103 0b08 	add.w	r11, r3, #8
  114364:	e9d3 2300 	ldrd	r2, r3, [r3]
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  114368:	f8cd a000 	str.w	r10, [r13]
  11436c:	a80a      	add	r0, sp, #40	; 0x28
  11436e:	f7ff fd6d 	bl	113e4c <longlong_to_hexstring.constprop.1>
                if (flags & ALTFLAG) {
  114372:	f01a 0f80 	tst.w	r10, #128	; 0x80
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  114376:	9005      	str	r0, [sp, #20]
  114378:	4681      	mov	r9, r0
                if (flags & ALTFLAG) {
  11437a:	f000 81b1 	beq.w	1146e0 <_printf_engine+0x588>
                    OUTPUT_CHAR('0');
  11437e:	2330      	movs	r3, #48	; 0x30
  114380:	4642      	mov	r2, r8
  114382:	2101      	movs	r1, #1
  114384:	a809      	add	r0, sp, #36	; 0x24
  114386:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  11438a:	47b8      	blx	r7
  11438c:	f1b0 0c00 	subs.w	r12, r0, #0
  114390:	f6ff af06 	blt.w	1141a0 <_printf_engine+0x48>
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  114394:	4642      	mov	r2, r8
  114396:	f41a 7f80 	tst.w	r10, #256	; 0x100
  11439a:	bf0c      	ite	eq
  11439c:	2378      	moveq	r3, #120	; 0x78
  11439e:	2358      	movne	r3, #88	; 0x58
  1143a0:	2101      	movs	r1, #1
  1143a2:	a809      	add	r0, sp, #36	; 0x24
  1143a4:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                    OUTPUT_CHAR('0');
  1143a8:	4466      	add	r6, r12
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  1143aa:	47b8      	blx	r7
  1143ac:	f1b0 0c00 	subs.w	r12, r0, #0
  1143b0:	f6ff aef6 	blt.w	1141a0 <_printf_engine+0x48>
  1143b4:	4648      	mov	r0, r9
  1143b6:	4466      	add	r6, r12
  1143b8:	f000 fa5c 	bl	114874 <strlen>
        if (flags & LEFTFORMATFLAG) {
  1143bc:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  1143c0:	4681      	mov	r9, r0
  1143c2:	d14a      	bne.n	11445a <_printf_engine+0x302>
  1143c4:	f40a 5380 	and.w	r3, r10, #4096	; 0x1000
  1143c8:	461a      	mov	r2, r3
  1143ca:	9307      	str	r3, [sp, #28]
            if (signchar != '\0' && format_num > 0)
  1143cc:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
  1143d0:	b18b      	cbz	r3, 1143f6 <_printf_engine+0x29e>
  1143d2:	2d00      	cmp	r5, #0
  1143d4:	f000 8143 	beq.w	11465e <_printf_engine+0x506>
                format_num--;
  1143d8:	3d01      	subs	r5, #1
            if (flags & LEADZEROFLAG && signchar != '\0')
  1143da:	2a00      	cmp	r2, #0
  1143dc:	f000 81d4 	beq.w	114788 <_printf_engine+0x630>
                OUTPUT_CHAR(signchar);
  1143e0:	4642      	mov	r2, r8
  1143e2:	2101      	movs	r1, #1
  1143e4:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  1143e8:	a809      	add	r0, sp, #36	; 0x24
  1143ea:	47b8      	blx	r7
  1143ec:	f1b0 0c00 	subs.w	r12, r0, #0
  1143f0:	f6ff aed6 	blt.w	1141a0 <_printf_engine+0x48>
  1143f4:	4466      	add	r6, r12
            for (; format_num > string_len; format_num--)
  1143f6:	454d      	cmp	r5, r9
  1143f8:	f240 811f 	bls.w	11463a <_printf_engine+0x4e2>
  1143fc:	9b07      	ldr	r3, [sp, #28]
  1143fe:	2b00      	cmp	r3, #0
  114400:	bf14      	ite	ne
  114402:	f04f 0a30 	movne.w	r10, #48	; 0x30
  114406:	f04f 0a20 	moveq.w	r10, #32
  11440a:	e002      	b.n	114412 <_printf_engine+0x2ba>
  11440c:	454d      	cmp	r5, r9
  11440e:	f000 8114 	beq.w	11463a <_printf_engine+0x4e2>
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  114412:	4642      	mov	r2, r8
  114414:	2101      	movs	r1, #1
  114416:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  11441a:	a809      	add	r0, sp, #36	; 0x24
  11441c:	47b8      	blx	r7
            for (; format_num > string_len; format_num--)
  11441e:	3d01      	subs	r5, #1
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  114420:	2800      	cmp	r0, #0
  114422:	4406      	add	r6, r0
  114424:	daf2      	bge.n	11440c <_printf_engine+0x2b4>
  114426:	4684      	mov	r12, r0
}
  114428:	4660      	mov	r0, r12
  11442a:	b013      	add	sp, #76	; 0x4c
  11442c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= CAPSFLAG;
  114430:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  114434:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  114436:	f10b 0b07 	add.w	r11, r11, #7
  11443a:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  11443e:	a80a      	add	r0, sp, #40	; 0x28
  114440:	ed9b 0b00 	vldr	d0, [r11]
  114444:	f7ff fd2c 	bl	113ea0 <double_to_string.constprop.2>
                double d = va_arg(ap, double);
  114448:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  11444c:	9005      	str	r0, [sp, #20]
  11444e:	f000 fa11 	bl	114874 <strlen>
  114452:	4681      	mov	r9, r0
        if (flags & LEFTFORMATFLAG) {
  114454:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  114458:	d0b4      	beq.n	1143c4 <_printf_engine+0x26c>
            OUTPUT_STRING(s, string_len);
  11445a:	4649      	mov	r1, r9
  11445c:	4642      	mov	r2, r8
  11445e:	9805      	ldr	r0, [sp, #20]
  114460:	47b8      	blx	r7
  114462:	f1b0 0c00 	subs.w	r12, r0, #0
  114466:	f6ff ae9b 	blt.w	1141a0 <_printf_engine+0x48>
  11446a:	46e1      	mov	r9, r12
            for (; format_num > written; format_num--)
  11446c:	45ac      	cmp	r12, r5
            OUTPUT_STRING(s, string_len);
  11446e:	4466      	add	r6, r12
            for (; format_num > written; format_num--)
  114470:	d22e      	bcs.n	1144d0 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  114472:	f04f 0a20 	mov.w	r10, #32
  114476:	e001      	b.n	11447c <_printf_engine+0x324>
            for (; format_num > written; format_num--)
  114478:	45a9      	cmp	r9, r5
  11447a:	d029      	beq.n	1144d0 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  11447c:	4642      	mov	r2, r8
  11447e:	2101      	movs	r1, #1
  114480:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  114484:	a809      	add	r0, sp, #36	; 0x24
  114486:	47b8      	blx	r7
            for (; format_num > written; format_num--)
  114488:	3d01      	subs	r5, #1
                OUTPUT_CHAR(' ');
  11448a:	2800      	cmp	r0, #0
  11448c:	4406      	add	r6, r0
  11448e:	daf3      	bge.n	114478 <_printf_engine+0x320>
  114490:	e7c9      	b.n	114426 <_printf_engine+0x2ce>
                flags |= CAPSFLAG;
  114492:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  114496:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  114498:	f10b 0b07 	add.w	r11, r11, #7
  11449c:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  1144a0:	a80a      	add	r0, sp, #40	; 0x28
  1144a2:	ed9b 0b00 	vldr	d0, [r11]
  1144a6:	f7ff fb61 	bl	113b6c <double_to_hexstring.isra.0>
                double d = va_arg(ap, double);
  1144aa:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  1144ae:	9005      	str	r0, [sp, #20]
  1144b0:	f000 f9e0 	bl	114874 <strlen>
  1144b4:	4681      	mov	r9, r0
                goto _output_string;
  1144b6:	e7cd      	b.n	114454 <_printf_engine+0x2fc>
                if (flags & LONGLONGFLAG)
  1144b8:	f01a 0f02 	tst.w	r10, #2
                ptr = va_arg(ap, void *);
  1144bc:	f8db 3000 	ldr.w	r3, [r11]
  1144c0:	f10b 0204 	add.w	r2, r11, #4
                if (flags & LONGLONGFLAG)
  1144c4:	f000 80f7 	beq.w	1146b6 <_printf_engine+0x55e>
                    *(long long *)ptr = chars_written;
  1144c8:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  1144ca:	4693      	mov	r11, r2
                    *(long long *)ptr = chars_written;
  1144cc:	2200      	movs	r2, #0
  1144ce:	605a      	str	r2, [r3, #4]
                ptr = va_arg(ap, void *);
  1144d0:	4620      	mov	r0, r4
  1144d2:	e64e      	b.n	114172 <_printf_engine+0x1a>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  1144d4:	f01a 0f01 	tst.w	r10, #1
  1144d8:	f040 80bb 	bne.w	114652 <_printf_engine+0x4fa>
  1144dc:	f01a 0f08 	tst.w	r10, #8
  1144e0:	f040 8102 	bne.w	1146e8 <_printf_engine+0x590>
  1144e4:	f01a 0f04 	tst.w	r10, #4
  1144e8:	f000 8115 	beq.w	114716 <_printf_engine+0x5be>
  1144ec:	f8bb 2000 	ldrh.w	r2, [r11]
  1144f0:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  1144f2:	f10b 0b04 	add.w	r11, r11, #4
  1144f6:	e737      	b.n	114368 <_printf_engine+0x210>
                flags |= BLANKPOSFLAG;
  1144f8:	f44a 5a00 	orr.w	r10, r10, #8192	; 0x2000
                goto next_format;
  1144fc:	e65d      	b.n	1141ba <_printf_engine+0x62>
                flags |= SIZETFLAG;
  1144fe:	f04a 0a10 	orr.w	r10, r10, #16
                goto next_format;
  114502:	e65a      	b.n	1141ba <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  114504:	2325      	movs	r3, #37	; 0x25
  114506:	4642      	mov	r2, r8
  114508:	2101      	movs	r1, #1
  11450a:	a809      	add	r0, sp, #36	; 0x24
  11450c:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  114510:	47b8      	blx	r7
  114512:	f1b0 0c00 	subs.w	r12, r0, #0
  114516:	f6ff ae43 	blt.w	1141a0 <_printf_engine+0x48>
                OUTPUT_CHAR(c);
  11451a:	4466      	add	r6, r12
                ptr = va_arg(ap, void *);
  11451c:	4620      	mov	r0, r4
  11451e:	e628      	b.n	114172 <_printf_engine+0x1a>
                flags |= SHOWSIGNFLAG;
  114520:	f44a 7a00 	orr.w	r10, r10, #512	; 0x200
                goto next_format;
  114524:	e649      	b.n	1141ba <_printf_engine+0x62>
                flags |= ALTFLAG;
  114526:	f04a 0a80 	orr.w	r10, r10, #128	; 0x80
                goto next_format;
  11452a:	e646      	b.n	1141ba <_printf_engine+0x62>
                flags |= LEFTFORMATFLAG;
  11452c:	f44a 6a00 	orr.w	r10, r10, #2048	; 0x800
                goto next_format;
  114530:	e643      	b.n	1141ba <_printf_engine+0x62>
                if (c == '0' && format_num == 0)
  114532:	2b30      	cmp	r3, #48	; 0x30
  114534:	bf08      	it	eq
  114536:	2d00      	cmpeq	r5, #0
                format_num *= 10;
  114538:	eb05 0585 	add.w	r5, r5, r5, lsl #2
                format_num += c - '0';
  11453c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
                    flags |= LEADZEROFLAG;
  114540:	bf08      	it	eq
  114542:	f44a 5a80 	orreq.w	r10, r10, #4096	; 0x1000
                format_num += c - '0';
  114546:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                goto next_format;
  11454a:	e636      	b.n	1141ba <_printf_engine+0x62>
                uc = va_arg(ap, unsigned int);
  11454c:	f8db 3000 	ldr.w	r3, [r11]
                OUTPUT_CHAR(uc);
  114550:	4642      	mov	r2, r8
  114552:	2101      	movs	r1, #1
  114554:	a809      	add	r0, sp, #36	; 0x24
                uc = va_arg(ap, unsigned int);
  114556:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                OUTPUT_CHAR(uc);
  11455a:	47b8      	blx	r7
  11455c:	f1b0 0c00 	subs.w	r12, r0, #0
  114560:	f6ff ae1e 	blt.w	1141a0 <_printf_engine+0x48>
                uc = va_arg(ap, unsigned int);
  114564:	f10b 0b04 	add.w	r11, r11, #4
                ptr = va_arg(ap, void *);
  114568:	4620      	mov	r0, r4
                OUTPUT_CHAR(uc);
  11456a:	4466      	add	r6, r12
  11456c:	e601      	b.n	114172 <_printf_engine+0x1a>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  11456e:	f01a 0f02 	tst.w	r10, #2
  114572:	d17f      	bne.n	114674 <_printf_engine+0x51c>
  114574:	f01a 0f01 	tst.w	r10, #1
  114578:	f040 80bc 	bne.w	1146f4 <_printf_engine+0x59c>
  11457c:	f01a 0f08 	tst.w	r10, #8
  114580:	f000 80ed 	beq.w	11475e <_printf_engine+0x606>
  114584:	f99b 2000 	ldrsb.w	r2, [r11]
                    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
  114588:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  11458c:	17d3      	asrs	r3, r2, #31
  11458e:	e079      	b.n	114684 <_printf_engine+0x52c>
                s = va_arg(ap, const char *);
  114590:	f8db 0000 	ldr.w	r0, [r11]
  114594:	f10b 0b04 	add.w	r11, r11, #4
  114598:	9005      	str	r0, [sp, #20]
                if (s == 0)
  11459a:	2800      	cmp	r0, #0
  11459c:	f000 80b6 	beq.w	11470c <_printf_engine+0x5b4>
  1145a0:	f000 f968 	bl	114874 <strlen>
  1145a4:	4681      	mov	r9, r0
                flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
  1145a6:	f42a 5a80 	bic.w	r10, r10, #4096	; 0x1000
                goto _output_string;
  1145aa:	e753      	b.n	114454 <_printf_engine+0x2fc>
                if (flags & HALFFLAG)
  1145ac:	f01a 0f04 	tst.w	r10, #4
                    flags |= HALFHALFFLAG;
  1145b0:	bf18      	it	ne
  1145b2:	f04a 0a08 	orrne.w	r10, r10, #8
                flags |= HALFFLAG;
  1145b6:	f04a 0a04 	orr.w	r10, r10, #4
                goto next_format;
  1145ba:	e5fe      	b.n	1141ba <_printf_engine+0x62>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  1145bc:	f01a 0f02 	tst.w	r10, #2
  1145c0:	d170      	bne.n	1146a4 <_printf_engine+0x54c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  1145c2:	f01a 0f01 	tst.w	r10, #1
  1145c6:	f040 809b 	bne.w	114700 <_printf_engine+0x5a8>
  1145ca:	f01a 0f08 	tst.w	r10, #8
  1145ce:	f000 80bd 	beq.w	11474c <_printf_engine+0x5f4>
  1145d2:	f89b 2000 	ldrb.w	r2, [r11]
  1145d6:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  1145d8:	f10b 0b04 	add.w	r11, r11, #4
  1145dc:	e054      	b.n	114688 <_printf_engine+0x530>
                flags |= CAPSFLAG;
  1145de:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  1145e2:	f01a 0f02 	tst.w	r10, #2
  1145e6:	f43f af75 	beq.w	1144d4 <_printf_engine+0x37c>
  1145ea:	e6b5      	b.n	114358 <_printf_engine+0x200>
                flags |= INTMAXFLAG;
  1145ec:	f04a 0a20 	orr.w	r10, r10, #32
                goto next_format;
  1145f0:	e5e3      	b.n	1141ba <_printf_engine+0x62>
                if (flags & LONGFLAG)
  1145f2:	f01a 0f01 	tst.w	r10, #1
                    flags |= LONGLONGFLAG;
  1145f6:	bf18      	it	ne
  1145f8:	f04a 0a02 	orrne.w	r10, r10, #2
                flags |= LONGFLAG;
  1145fc:	f04a 0a01 	orr.w	r10, r10, #1
                goto next_format;
  114600:	e5db      	b.n	1141ba <_printf_engine+0x62>
                flags |= PTRDIFFFLAG;
  114602:	f04a 0a40 	orr.w	r10, r10, #64	; 0x40
                goto next_format;
  114606:	e5d8      	b.n	1141ba <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  114608:	2525      	movs	r5, #37	; 0x25
  11460a:	4642      	mov	r2, r8
  11460c:	9305      	str	r3, [sp, #20]
  11460e:	2101      	movs	r1, #1
  114610:	f88d 5024 	strb.w	r5, [r13, #36]	; 0x24
  114614:	a809      	add	r0, sp, #36	; 0x24
  114616:	47b8      	blx	r7
  114618:	1e05      	subs	r5, r0, #0
  11461a:	f2c0 80b3 	blt.w	114784 <_printf_engine+0x62c>
                OUTPUT_CHAR(c);
  11461e:	9b05      	ldr	r3, [sp, #20]
  114620:	4642      	mov	r2, r8
  114622:	2101      	movs	r1, #1
  114624:	a809      	add	r0, sp, #36	; 0x24
  114626:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  11462a:	47b8      	blx	r7
  11462c:	f1b0 0c00 	subs.w	r12, r0, #0
  114630:	f6ff adb6 	blt.w	1141a0 <_printf_engine+0x48>
                OUTPUT_CHAR('%');
  114634:	442e      	add	r6, r5
                OUTPUT_CHAR(c);
  114636:	4466      	add	r6, r12
  114638:	e770      	b.n	11451c <_printf_engine+0x3c4>
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  11463a:	9b07      	ldr	r3, [sp, #28]
  11463c:	2b00      	cmp	r3, #0
  11463e:	d075      	beq.n	11472c <_printf_engine+0x5d4>
            OUTPUT_STRING(s, string_len);
  114640:	4649      	mov	r1, r9
  114642:	4642      	mov	r2, r8
  114644:	9805      	ldr	r0, [sp, #20]
  114646:	47b8      	blx	r7
  114648:	f1b0 0c00 	subs.w	r12, r0, #0
  11464c:	f6ff ada8 	blt.w	1141a0 <_printf_engine+0x48>
  114650:	e763      	b.n	11451a <_printf_engine+0x3c2>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  114652:	f8db 2000 	ldr.w	r2, [r11]
  114656:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  114658:	f10b 0b04 	add.w	r11, r11, #4
  11465c:	e684      	b.n	114368 <_printf_engine+0x210>
            if (flags & LEADZEROFLAG && signchar != '\0')
  11465e:	9a07      	ldr	r2, [sp, #28]
  114660:	2a00      	cmp	r2, #0
  114662:	f47f aebd 	bne.w	1143e0 <_printf_engine+0x288>
  114666:	e065      	b.n	114734 <_printf_engine+0x5dc>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  114668:	f01a 0f10 	tst.w	r10, #16
  11466c:	d142      	bne.n	1146f4 <_printf_engine+0x59c>
  11466e:	f01a 0f20 	tst.w	r10, #32
  114672:	d03f      	beq.n	1146f4 <_printf_engine+0x59c>
                    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
  114674:	f10b 0307 	add.w	r3, r11, #7
  114678:	f023 0307 	bic.w	r3, r3, #7
  11467c:	f103 0b08 	add.w	r11, r3, #8
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  114680:	e9d3 2300 	ldrd	r2, r3, [r3]
                flags |= SIGNEDFLAG;
  114684:	f44a 6a80 	orr.w	r10, r10, #1024	; 0x400
                s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
  114688:	2120      	movs	r1, #32
  11468a:	f10d 0027 	add.w	r0, r13, #39	; 0x27
  11468e:	9100      	str	r1, [sp, #0]
  114690:	e9cd a001 	strd	r10, r0, [r13, #4]
  114694:	a80a      	add	r0, sp, #40	; 0x28
  114696:	f7ff f9d9 	bl	113a4c <longlong_to_string>
  11469a:	9005      	str	r0, [sp, #20]
  11469c:	f000 f8ea 	bl	114874 <strlen>
  1146a0:	4681      	mov	r9, r0
                goto _output_string;
  1146a2:	e6d7      	b.n	114454 <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  1146a4:	f10b 0307 	add.w	r3, r11, #7
  1146a8:	f023 0307 	bic.w	r3, r3, #7
  1146ac:	f103 0b08 	add.w	r11, r3, #8
  1146b0:	e9d3 2300 	ldrd	r2, r3, [r3]
  1146b4:	e7e8      	b.n	114688 <_printf_engine+0x530>
                else if (flags & LONGFLAG)
  1146b6:	f01a 0f01 	tst.w	r10, #1
  1146ba:	d10d      	bne.n	1146d8 <_printf_engine+0x580>
                else if (flags & HALFHALFFLAG)
  1146bc:	f01a 0f08 	tst.w	r10, #8
                ptr = va_arg(ap, void *);
  1146c0:	bf1c      	itt	ne
  1146c2:	4693      	movne	r11, r2
                    *(signed char *)ptr = chars_written;
  1146c4:	701e      	strbne	r6, [r3, #0]
                else if (flags & HALFHALFFLAG)
  1146c6:	f47f af03 	bne.w	1144d0 <_printf_engine+0x378>
                else if (flags & HALFFLAG)
  1146ca:	f01a 0f04 	tst.w	r10, #4
                ptr = va_arg(ap, void *);
  1146ce:	bf1c      	itt	ne
  1146d0:	4693      	movne	r11, r2
                    *(short *)ptr = chars_written;
  1146d2:	801e      	strhne	r6, [r3, #0]
                else if (flags & HALFFLAG)
  1146d4:	f47f aefc 	bne.w	1144d0 <_printf_engine+0x378>
                    *(int *)ptr = chars_written;
  1146d8:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  1146da:	4693      	mov	r11, r2
  1146dc:	4620      	mov	r0, r4
  1146de:	e548      	b.n	114172 <_printf_engine+0x1a>
  1146e0:	f000 f8c8 	bl	114874 <strlen>
  1146e4:	4681      	mov	r9, r0
  1146e6:	e6b5      	b.n	114454 <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  1146e8:	f89b 2000 	ldrb.w	r2, [r11]
  1146ec:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  1146ee:	f10b 0b04 	add.w	r11, r11, #4
  1146f2:	e639      	b.n	114368 <_printf_engine+0x210>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  1146f4:	f8db 2000 	ldr.w	r2, [r11]
                    va_arg(ap, int);
  1146f8:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  1146fc:	17d3      	asrs	r3, r2, #31
  1146fe:	e7c1      	b.n	114684 <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  114700:	f8db 2000 	ldr.w	r2, [r11]
  114704:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  114706:	f10b 0b04 	add.w	r11, r11, #4
  11470a:	e7bd      	b.n	114688 <_printf_engine+0x530>
                    s = "<null>";
  11470c:	9b06      	ldr	r3, [sp, #24]
  11470e:	f04f 0906 	mov.w	r9, #6
  114712:	9305      	str	r3, [sp, #20]
  114714:	e747      	b.n	1145a6 <_printf_engine+0x44e>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  114716:	f01a 0f10 	tst.w	r10, #16
  11471a:	d19a      	bne.n	114652 <_printf_engine+0x4fa>
  11471c:	f01a 0f20 	tst.w	r10, #32
  114720:	f47f ae1a 	bne.w	114358 <_printf_engine+0x200>
  114724:	f85b 2b04 	ldr.w	r2, [r11], #4
  114728:	2300      	movs	r3, #0
  11472a:	e61d      	b.n	114368 <_printf_engine+0x210>
  11472c:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  114730:	2b00      	cmp	r3, #0
  114732:	d085      	beq.n	114640 <_printf_engine+0x4e8>
                OUTPUT_CHAR(signchar);
  114734:	4642      	mov	r2, r8
  114736:	2101      	movs	r1, #1
  114738:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  11473c:	a809      	add	r0, sp, #36	; 0x24
  11473e:	47b8      	blx	r7
  114740:	f1b0 0c00 	subs.w	r12, r0, #0
  114744:	f6ff ad2c 	blt.w	1141a0 <_printf_engine+0x48>
  114748:	4466      	add	r6, r12
  11474a:	e779      	b.n	114640 <_printf_engine+0x4e8>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  11474c:	f01a 0f04 	tst.w	r10, #4
  114750:	d00e      	beq.n	114770 <_printf_engine+0x618>
  114752:	f8bb 2000 	ldrh.w	r2, [r11]
  114756:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  114758:	f10b 0b04 	add.w	r11, r11, #4
  11475c:	e794      	b.n	114688 <_printf_engine+0x530>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  11475e:	f01a 0f04 	tst.w	r10, #4
  114762:	d081      	beq.n	114668 <_printf_engine+0x510>
  114764:	f9bb 2000 	ldrsh.w	r2, [r11]
                    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
  114768:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  11476c:	17d3      	asrs	r3, r2, #31
  11476e:	e789      	b.n	114684 <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  114770:	f01a 0f10 	tst.w	r10, #16
  114774:	d1c4      	bne.n	114700 <_printf_engine+0x5a8>
  114776:	f01a 0f20 	tst.w	r10, #32
  11477a:	d193      	bne.n	1146a4 <_printf_engine+0x54c>
  11477c:	f85b 2b04 	ldr.w	r2, [r11], #4
  114780:	2300      	movs	r3, #0
  114782:	e781      	b.n	114688 <_printf_engine+0x530>
                OUTPUT_CHAR('%');
  114784:	46ac      	mov	r12, r5
  114786:	e50b      	b.n	1141a0 <_printf_engine+0x48>
            for (; format_num > string_len; format_num--)
  114788:	454d      	cmp	r5, r9
  11478a:	f63f ae37 	bhi.w	1143fc <_printf_engine+0x2a4>
  11478e:	e7cf      	b.n	114730 <_printf_engine+0x5d8>

00114790 <_fprintf_output_func>:

static int _fprintf_output_func(const char *str, size_t len, void *state)
{
    FILE *fp = (FILE *)state;

    return io_write(fp->io, str, len);
  114790:	6813      	ldr	r3, [r2, #0]
  114792:	460a      	mov	r2, r1
  114794:	4601      	mov	r1, r0
  114796:	4618      	mov	r0, r3
  114798:	f002 b964 	b.w	116a64 <io_write>

0011479c <putchar>:
    return io_write(fp->io, (char *)&c, 1);
  11479c:	f64c 0348 	movw	r3, #51272	; 0xc848
  1147a0:	2201      	movs	r2, #1
{
  1147a2:	b500      	push	{r14}
    return io_write(fp->io, (char *)&c, 1);
  1147a4:	f2c0 0312 	movt	r3, #18
{
  1147a8:	b083      	sub	sp, #12
    unsigned char c = _c;
  1147aa:	a902      	add	r1, sp, #8
  1147ac:	f801 0d01 	strb.w	r0, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
  1147b0:	6858      	ldr	r0, [r3, #4]
  1147b2:	f002 f957 	bl	116a64 <io_write>
}
  1147b6:	b003      	add	sp, #12
  1147b8:	f85d fb04 	ldr.w	r15, [r13], #4

001147bc <fputs>:
{
  1147bc:	b538      	push	{r3, r4, r5, r14}
  1147be:	460c      	mov	r4, r1
  1147c0:	4605      	mov	r5, r0
    size_t len = strlen(s);
  1147c2:	f000 f857 	bl	114874 <strlen>
    return io_write(fp->io, s, len);
  1147c6:	4629      	mov	r1, r5
  1147c8:	4602      	mov	r2, r0
  1147ca:	6820      	ldr	r0, [r4, #0]
}
  1147cc:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return io_write(fp->io, s, len);
  1147d0:	f002 b948 	b.w	116a64 <io_write>

001147d4 <puts>:
{
  1147d4:	b510      	push	{r4, r14}
    int err = fputs(str, stdout);
  1147d6:	490a      	ldr	r1, [pc, #40]	; (114800 <puts+0x2c>)
{
  1147d8:	b082      	sub	sp, #8
    int err = fputs(str, stdout);
  1147da:	f7ff ffef 	bl	1147bc <fputs>
    if (err >= 0)
  1147de:	2800      	cmp	r0, #0
  1147e0:	db0b      	blt.n	1147fa <puts+0x26>
    return io_write(fp->io, (char *)&c, 1);
  1147e2:	f64c 0348 	movw	r3, #51272	; 0xc848
    unsigned char c = _c;
  1147e6:	240a      	movs	r4, #10
    return io_write(fp->io, (char *)&c, 1);
  1147e8:	f2c0 0312 	movt	r3, #18
  1147ec:	2201      	movs	r2, #1
    unsigned char c = _c;
  1147ee:	a902      	add	r1, sp, #8
    return io_write(fp->io, (char *)&c, 1);
  1147f0:	6858      	ldr	r0, [r3, #4]
    unsigned char c = _c;
  1147f2:	f801 4d01 	strb.w	r4, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
  1147f6:	f002 f935 	bl	116a64 <io_write>
}
  1147fa:	b002      	add	sp, #8
  1147fc:	bd10      	pop	{r4, r15}
  1147fe:	bf00      	nop
  114800:	0012c84c 	.word	0x0012c84c

00114804 <printf>:
    return err;
}

#if !DISABLE_DEBUG_OUTPUT
int printf(const char *fmt, ...)
{
  114804:	b40f      	push	{r0, r1, r2, r3}
  114806:	b510      	push	{r4, r14}
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  114808:	f244 7091 	movw	r0, #18321	; 0x4791
{
  11480c:	b082      	sub	sp, #8
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  11480e:	4907      	ldr	r1, [pc, #28]	; (11482c <printf+0x28>)
{
  114810:	ac04      	add	r4, sp, #16
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  114812:	f2c0 0011 	movt	r0, #17
{
  114816:	f854 2b04 	ldr.w	r2, [r4], #4
    va_list ap;
    int err;

    va_start(ap, fmt);
  11481a:	9401      	str	r4, [sp, #4]
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  11481c:	4623      	mov	r3, r4
  11481e:	f7ff fc9b 	bl	114158 <_printf_engine>
    err = vfprintf(stdout, fmt, ap);
    va_end(ap);

    return err;
}
  114822:	b002      	add	sp, #8
  114824:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  114828:	b004      	add	sp, #16
  11482a:	4770      	bx	r14
  11482c:	0012c84c 	.word	0x0012c84c

00114830 <_printf>:
#endif

int _printf(const char *fmt, ...)
{
  114830:	b40f      	push	{r0, r1, r2, r3}
  114832:	b510      	push	{r4, r14}
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  114834:	f244 7091 	movw	r0, #18321	; 0x4791
{
  114838:	b082      	sub	sp, #8
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  11483a:	4907      	ldr	r1, [pc, #28]	; (114858 <_printf+0x28>)
{
  11483c:	ac04      	add	r4, sp, #16
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  11483e:	f2c0 0011 	movt	r0, #17
{
  114842:	f854 2b04 	ldr.w	r2, [r4], #4
    va_list ap;
    int err;

    va_start(ap, fmt);
  114846:	9401      	str	r4, [sp, #4]
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  114848:	4623      	mov	r3, r4
  11484a:	f7ff fc85 	bl	114158 <_printf_engine>
    err = vfprintf(stdout, fmt, ap);
    va_end(ap);

    return err;
}
  11484e:	b002      	add	sp, #8
  114850:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  114854:	b004      	add	sp, #16
  114856:	4770      	bx	r14
  114858:	0012c84c 	.word	0x0012c84c

0011485c <_vprintf>:
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  11485c:	4602      	mov	r2, r0
  11485e:	f244 7091 	movw	r0, #18321	; 0x4791
  114862:	460b      	mov	r3, r1
  114864:	f2c0 0011 	movt	r0, #17
  114868:	4901      	ldr	r1, [pc, #4]	; (114870 <_vprintf+0x14>)
  11486a:	f7ff bc75 	b.w	114158 <_printf_engine>
  11486e:	bf00      	nop
  114870:	0012c84c 	.word	0x0012c84c

00114874 <strlen>:
strlen(char const *s)
{
    size_t i;

    i= 0;
    while (s[i]) {
  114874:	7803      	ldrb	r3, [r0, #0]
  114876:	b13b      	cbz	r3, 114888 <strlen+0x14>
  114878:	4603      	mov	r3, r0
    i= 0;
  11487a:	2000      	movs	r0, #0
        i+= 1;
  11487c:	3001      	adds	r0, #1
    while (s[i]) {
  11487e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  114882:	2a00      	cmp	r2, #0
  114884:	d1fa      	bne.n	11487c <strlen+0x8>
  114886:	4770      	bx	r14
    i= 0;
  114888:	4618      	mov	r0, r3
    }

    return i;
}
  11488a:	4770      	bx	r14

0011488c <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
    signed char __res = 0;

    while (count > 0) {
  11488c:	b1e2      	cbz	r2, 1148c8 <strncmp+0x3c>
{
  11488e:	b430      	push	{r4, r5}
        if ((__res = *cs - *ct++) != 0 || !*cs++)
  114890:	7805      	ldrb	r5, [r0, #0]
  114892:	780b      	ldrb	r3, [r1, #0]
  114894:	1aeb      	subs	r3, r5, r3
  114896:	1c4c      	adds	r4, r1, #1
  114898:	b25b      	sxtb	r3, r3
  11489a:	b97b      	cbnz	r3, 1148bc <strncmp+0x30>
  11489c:	b15d      	cbz	r5, 1148b6 <strncmp+0x2a>
  11489e:	4411      	add	r1, r2
  1148a0:	e007      	b.n	1148b2 <strncmp+0x26>
  1148a2:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  1148a6:	f814 3b01 	ldrb.w	r3, [r4], #1
  1148aa:	1ad3      	subs	r3, r2, r3
  1148ac:	b25b      	sxtb	r3, r3
  1148ae:	b92b      	cbnz	r3, 1148bc <strncmp+0x30>
  1148b0:	b13a      	cbz	r2, 1148c2 <strncmp+0x36>
    while (count > 0) {
  1148b2:	42a1      	cmp	r1, r4
  1148b4:	d1f5      	bne.n	1148a2 <strncmp+0x16>
  1148b6:	2000      	movs	r0, #0
            break;
        count--;
    }

    return __res;
}
  1148b8:	bc30      	pop	{r4, r5}
  1148ba:	4770      	bx	r14
  1148bc:	4618      	mov	r0, r3
  1148be:	bc30      	pop	{r4, r5}
  1148c0:	4770      	bx	r14
  1148c2:	4610      	mov	r0, r2
  1148c4:	bc30      	pop	{r4, r5}
  1148c6:	4770      	bx	r14
    while (count > 0) {
  1148c8:	4610      	mov	r0, r2
}
  1148ca:	4770      	bx	r14

001148cc <configs_init.part.0>:
    if (result) {
        return result;
    }

    config_header_t *config_header = (config_header_t*)CONFIGS_BASE;
    config_count = config_header->config_count;
  1148cc:	2300      	movs	r3, #0
  1148ce:	f243 1030 	movw	r0, #12592	; 0x3130
  1148d2:	f2c3 0360 	movt	r3, #12384	; 0x3060
  1148d6:	f2c0 0013 	movt	r0, #19
int configs_init(void)
  1148da:	b410      	push	{r4}
    config_count = config_header->config_count;
  1148dc:	689c      	ldr	r4, [r3, #8]
    addr_module_header = config_header->config_offset + CONFIGS_BASE;
  1148de:	f243 122c 	movw	r2, #12588	; 0x312c
    config_count = config_header->config_count;
  1148e2:	6004      	str	r4, [r0, #0]
    init_done = true;
  1148e4:	f243 1134 	movw	r1, #12596	; 0x3134
    addr_module_header = config_header->config_offset + CONFIGS_BASE;
  1148e8:	68db      	ldr	r3, [r3, #12]
  1148ea:	f2c0 0213 	movt	r2, #19
    init_done = true;
  1148ee:	2001      	movs	r0, #1
  1148f0:	f2c0 0113 	movt	r1, #19
    configs_info(config_header);

    dprintf(INFO, "config_head addr: 0x%lx, config_count: %d\n", (addr_t)config_header, config_count);

    return result;
}
  1148f4:	f85d 4b04 	ldr.w	r4, [r13], #4
    addr_module_header = config_header->config_offset + CONFIGS_BASE;
  1148f8:	f103 5341 	add.w	r3, r3, #809500672	; 0x30400000
    init_done = true;
  1148fc:	7008      	strb	r0, [r1, #0]
    addr_module_header = config_header->config_offset + CONFIGS_BASE;
  1148fe:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  114902:	6013      	str	r3, [r2, #0]
}
  114904:	4770      	bx	r14
  114906:	bf00      	nop

00114908 <get_config_info>:

int get_config_info(config_module_type_t module_type, addr_t * addr_base)
{
  114908:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    int result = CONFIG_NO_ERROR;
    addr_t addr_header = 0;
    module_header_t *module_header;
    uint32_t i = 0;

    if (!init_done) {
  11490a:	f243 1334 	movw	r3, #12596	; 0x3134
{
  11490e:	4606      	mov	r6, r0
  114910:	460f      	mov	r7, r1
    if (!init_done) {
  114912:	f2c0 0313 	movt	r3, #19
  114916:	781b      	ldrb	r3, [r3, #0]
  114918:	b30b      	cbz	r3, 11495e <get_config_info+0x56>
        if (CONFIG_NO_ERROR != result) {
            return result;
        }
    }
    addr_header = addr_module_header;
    for (; i < config_count; i++) {
  11491a:	f243 1230 	movw	r2, #12592	; 0x3130
    addr_header = addr_module_header;
  11491e:	f243 132c 	movw	r3, #12588	; 0x312c
    for (; i < config_count; i++) {
  114922:	f2c0 0213 	movt	r2, #19
    addr_header = addr_module_header;
  114926:	f2c0 0313 	movt	r3, #19
    for (; i < config_count; i++) {
  11492a:	6815      	ldr	r5, [r2, #0]
    addr_header = addr_module_header;
  11492c:	681b      	ldr	r3, [r3, #0]
    for (; i < config_count; i++) {
  11492e:	b165      	cbz	r5, 11494a <get_config_info+0x42>
        module_header = (module_header_t*)addr_header;

        if (module_type == module_header->module_type) {
  114930:	685a      	ldr	r2, [r3, #4]
  114932:	42b2      	cmp	r2, r6
  114934:	d00b      	beq.n	11494e <get_config_info+0x46>
    uint32_t i = 0;
  114936:	2200      	movs	r2, #0
  114938:	e002      	b.n	114940 <get_config_info+0x38>
        if (module_type == module_header->module_type) {
  11493a:	685c      	ldr	r4, [r3, #4]
  11493c:	42b4      	cmp	r4, r6
  11493e:	d006      	beq.n	11494e <get_config_info+0x46>
    for (; i < config_count; i++) {
  114940:	3201      	adds	r2, #1
  114942:	42aa      	cmp	r2, r5
            *addr_base = module_header->config_offset + CONFIGS_BASE;
            break;
        }

        addr_header += MODULE_HEADER_SIZE;
  114944:	f103 0320 	add.w	r3, r3, #32
    for (; i < config_count; i++) {
  114948:	d1f7      	bne.n	11493a <get_config_info+0x32>
    }

    if (i >= config_count) {
        return CONFIG_MODULE_NOT_FOUND;
  11494a:	2002      	movs	r0, #2
    }

    return result;
}
  11494c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            *addr_base = module_header->config_offset + CONFIGS_BASE;
  11494e:	68db      	ldr	r3, [r3, #12]
    return result;
  114950:	2000      	movs	r0, #0
            *addr_base = module_header->config_offset + CONFIGS_BASE;
  114952:	f103 5341 	add.w	r3, r3, #809500672	; 0x30400000
  114956:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  11495a:	603b      	str	r3, [r7, #0]
}
  11495c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  11495e:	f7ff ffb5 	bl	1148cc <configs_init.part.0>
  114962:	e7da      	b.n	11491a <get_config_info+0x12>

00114964 <platform_mpu_r5_common>:
{
#if ARM_WITH_MPU
    extern addr_t _nocacheable_start;
    extern addr_t _nocacheable_end;

    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  114964:	f64c 4200 	movw	r2, #52224	; 0xcc00
  114968:	f64c 4100 	movw	r1, #52224	; 0xcc00
  11496c:	f2c0 0212 	movt	r2, #18
  114970:	f2c0 0112 	movt	r1, #18
  114974:	1a52      	subs	r2, r2, r1
  114976:	2a00      	cmp	r2, #0
{
  114978:	b570      	push	{r4, r5, r6, r14}
  11497a:	4604      	mov	r4, r0
  11497c:	b082      	sub	sp, #8
  11497e:	f100 0501 	add.w	r5, r0, #1
    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  114982:	dd08      	ble.n	114996 <platform_mpu_r5_common+0x32>
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
  114984:	2603      	movs	r6, #3
                       &_nocacheable_end - &_nocacheable_start, MPU_REGION_NORMAL_NONCACHEABLE);
  114986:	1092      	asrs	r2, r2, #2
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
  114988:	9600      	str	r6, [sp, #0]
  11498a:	17d3      	asrs	r3, r2, #31
  11498c:	f7ec fea8 	bl	1016e0 <mpu_add_region>
  114990:	1ca3      	adds	r3, r4, #2
  114992:	462c      	mov	r4, r5
  114994:	461d      	mov	r5, r3
    }

    mpu_add_region(region++, APB_CKGEN_SEC_BASE, 0x04000000, MPU_REGION_DEVICE);
  114996:	2101      	movs	r1, #1
  114998:	4620      	mov	r0, r4
  11499a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  11499e:	2300      	movs	r3, #0
  1149a0:	9100      	str	r1, [sp, #0]
  1149a2:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  1149a6:	f7ec fe9b 	bl	1016e0 <mpu_add_region>

#endif
    return region;
}
  1149aa:	4628      	mov	r0, r5
  1149ac:	b002      	add	sp, #8
  1149ae:	bd70      	pop	{r4, r5, r6, r15}

001149b0 <sdm_connect_panel>:
int send_spi_command(struct sdm_panel *panel) {
    LOGD("send spi command %p\n", panel->cmd_data);
    return -1;
}

int sdm_connect_panel(display_handle *handle, int sub_id, struct sdm_panel *panel) {
  1149b0:	b510      	push	{r4, r14}
  1149b2:	4614      	mov	r4, r2
    int ret = hal_sdm_panel_connect(handle, sub_id, panel);
  1149b4:	f7f7 fa20 	bl	10bdf8 <hal_sdm_panel_connect>

    switch (panel->if_type)
  1149b8:	6863      	ldr	r3, [r4, #4]
  1149ba:	3b01      	subs	r3, #1
  1149bc:	2b05      	cmp	r3, #5
  1149be:	d810      	bhi.n	1149e2 <sdm_connect_panel+0x32>
  1149c0:	e8df f003 	tbb	[r15, r3]
  1149c4:	03030303 	.word	0x03030303
  1149c8:	0304      	.short	0x0304
    default:
        LOGD("invalid panel if_type: %d\n", panel->if_type);
        return -2;
    }

    if (ret) {
  1149ca:	b938      	cbnz	r0, 1149dc <sdm_connect_panel+0x2c>
        LOGD("panel init failed in driver: %d\n", ret);
        return -1;
    }

    switch (panel->cmd_intf)
  1149cc:	68a3      	ldr	r3, [r4, #8]
  1149ce:	3b03      	subs	r3, #3
    {
    case IF_TYPE_I2C:
       	return send_i2c_command(panel);
  1149d0:	2b01      	cmp	r3, #1
  1149d2:	bf8c      	ite	hi
  1149d4:	2000      	movhi	r0, #0
  1149d6:	f04f 30ff 	movls.w	r0, #4294967295	; 0xffffffff
    }

    //LOGD("panel %s conncted success\n", panel->panel_name);

    return 0;
}
  1149da:	bd10      	pop	{r4, r15}
        return -1;
  1149dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1149e0:	bd10      	pop	{r4, r15}
        return -2;
  1149e2:	f06f 0001 	mvn.w	r0, #1
}
  1149e6:	bd10      	pop	{r4, r15}

001149e8 <sdm_panel_probe>:

int sdm_panel_probe(display_handle *handle, int sub_id, struct sdm_panel *panels[], int n_panels) {
  1149e8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    int found = -1;
	//LOGD("n_panels count %d", n_panels);

    for (int i = 0; i < n_panels; i++)
  1149ec:	f1b3 0800 	subs.w	r8, r3, #0
  1149f0:	dd12      	ble.n	114a18 <sdm_panel_probe+0x30>
  1149f2:	460f      	mov	r7, r1
  1149f4:	4606      	mov	r6, r0
  1149f6:	2400      	movs	r4, #0
  1149f8:	1f15      	subs	r5, r2, #4
  1149fa:	e002      	b.n	114a02 <sdm_panel_probe+0x1a>
  1149fc:	3401      	adds	r4, #1
  1149fe:	45a0      	cmp	r8, r4
  114a00:	d00a      	beq.n	114a18 <sdm_panel_probe+0x30>
    {
        struct sdm_panel *p = panels[i];
        //LOGD("check panel %s...\n", p->panel_name);
        if (0 == sdm_connect_panel(handle, sub_id, p)) {
  114a02:	f855 2f04 	ldr.w	r2, [r5, #4]!
  114a06:	4639      	mov	r1, r7
  114a08:	4630      	mov	r0, r6
  114a0a:	f7ff ffd1 	bl	1149b0 <sdm_connect_panel>
  114a0e:	2800      	cmp	r0, #0
  114a10:	d1f4      	bne.n	1149fc <sdm_panel_probe+0x14>
        LOGD("can not found a valid panel");
        return -1;
    }

    return found;
}
  114a12:	4620      	mov	r0, r4
  114a14:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return -1;
  114a18:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
}
  114a1c:	4620      	mov	r0, r4
  114a1e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  114a22:	bf00      	nop

00114a24 <LT9611_LowPower_mode.part.0>:
    HDMI_WriteI2C_Byte(0x23,0x80);
    HDMI_WriteI2C_Byte(0x30,0x00);
    HDMI_WriteI2C_Byte(0x01,0x00); /* i2c stop work */
}

void LT9611_LowPower_mode(bool on)
  114a24:	b508      	push	{r3, r14}
{
    /* only hpd irq is working for low power consumption */
    /* 1.8V: 15 mA */
    if(on)
    {
        HDMI_WriteI2C_Byte(0xFF,0x81);
  114a26:	2181      	movs	r1, #129	; 0x81
  114a28:	20ff      	movs	r0, #255	; 0xff
  114a2a:	f001 fc89 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x02,0x49);
  114a2e:	2149      	movs	r1, #73	; 0x49
  114a30:	2002      	movs	r0, #2
  114a32:	f001 fc85 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x23,0x80);
  114a36:	2180      	movs	r1, #128	; 0x80
  114a38:	2023      	movs	r0, #35	; 0x23
  114a3a:	f001 fc81 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x30,0x00); //0x00 --> 0xc0, tx phy and clk can not power down, otherwise dc det don't work.
  114a3e:	2100      	movs	r1, #0
  114a40:	2030      	movs	r0, #48	; 0x30
  114a42:	f001 fc7d 	bl	116340 <HDMI_WriteI2C_Byte>

        HDMI_WriteI2C_Byte(0xff,0x80);
  114a46:	2180      	movs	r1, #128	; 0x80
  114a48:	20ff      	movs	r0, #255	; 0xff
  114a4a:	f001 fc79 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0x0a);
  114a4e:	210a      	movs	r1, #10
  114a50:	2011      	movs	r0, #17

        HDMI_WriteI2C_Byte(0xff,0x80);
        HDMI_WriteI2C_Byte(0x11,0xfa);
        dprintf(LT9611_LOG, "\r\n\33[35mLT9611_LowPower_mode: exit low power mode\033[37m\n");
    }
}
  114a52:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        HDMI_WriteI2C_Byte(0x11,0x0a);
  114a56:	f001 bc73 	b.w	116340 <HDMI_WriteI2C_Byte>
  114a5a:	bf00      	nop

00114a5c <LT9611_CSC.part.2>:
           HDMI_WriteI2C_Byte(0xc7,0x04);  //PB4
           HDMI_WriteI2C_Byte(0xc8,0x00);  //PB5
        }
}

void LT9611_CSC(void)
  114a5c:	b508      	push	{r3, r14}
{
    if(lt9611.input_color_space == YUV422)
    {
       HDMI_WriteI2C_Byte(0xff,0x82);
  114a5e:	2182      	movs	r1, #130	; 0x82
  114a60:	20ff      	movs	r0, #255	; 0xff
  114a62:	f001 fc6d 	bl	116340 <HDMI_WriteI2C_Byte>
       HDMI_WriteI2C_Byte(0xb9,0x18);
  114a66:	2118      	movs	r1, #24
  114a68:	20b9      	movs	r0, #185	; 0xb9
       dprintf(LT9611_LOG, "\r\nLT9611_CSC: Ypbpr 422 to RGB888");
    }
}
  114a6a:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
       HDMI_WriteI2C_Byte(0xb9,0x18);
  114a6e:	f001 bc67 	b.w	116340 <HDMI_WriteI2C_Byte>
  114a72:	bf00      	nop

00114a74 <LT9611_HDMI_CEC_ON.part.4>:
    }
}


//CEC: start
void LT9611_HDMI_CEC_ON(bool enable)
  114a74:	b508      	push	{r3, r14}
{
  if(enable){
    /* cec init */
    HDMI_WriteI2C_Byte(0xff, 0x80);
  114a76:	2180      	movs	r1, #128	; 0x80
  114a78:	20ff      	movs	r0, #255	; 0xff
  114a7a:	f001 fc61 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0d, 0xff);
  114a7e:	21ff      	movs	r1, #255	; 0xff
  114a80:	200d      	movs	r0, #13
  114a82:	f001 fc5d 	bl	116340 <HDMI_WriteI2C_Byte>
  HDMI_WriteI2C_Byte(0x15, 0xf1); //reset cec logic
  114a86:	21f1      	movs	r1, #241	; 0xf1
  114a88:	2015      	movs	r0, #21
  114a8a:	f001 fc59 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15, 0xf9);
  114a8e:	21f9      	movs	r1, #249	; 0xf9
  114a90:	2015      	movs	r0, #21
  114a92:	f001 fc55 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff, 0x86);
  114a96:	2186      	movs	r1, #134	; 0x86
  114a98:	20ff      	movs	r0, #255	; 0xff
  114a9a:	f001 fc51 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xfe, 0xa5); //clk div
  114a9e:	21a5      	movs	r1, #165	; 0xa5
  114aa0:	20fe      	movs	r0, #254	; 0xfe
    }
    else{
    HDMI_WriteI2C_Byte(0xff, 0x80);
    HDMI_WriteI2C_Byte(0x15, 0xf1);
    }
}
  114aa2:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0xfe, 0xa5); //clk div
  114aa6:	f001 bc4b 	b.w	116340 <HDMI_WriteI2C_Byte>
  114aaa:	bf00      	nop

00114aac <LT9611_Chip_ID>:
{
  114aac:	b508      	push	{r3, r14}
    ret = HDMI_WriteI2C_Byte(0xFF,0x80);
  114aae:	2180      	movs	r1, #128	; 0x80
  114ab0:	20ff      	movs	r0, #255	; 0xff
  114ab2:	f001 fc45 	bl	116340 <HDMI_WriteI2C_Byte>
    if (ret == false)
  114ab6:	b188      	cbz	r0, 114adc <LT9611_Chip_ID+0x30>
    HDMI_WriteI2C_Byte(0xee,0x01);
  114ab8:	2101      	movs	r1, #1
  114aba:	20ee      	movs	r0, #238	; 0xee
  114abc:	f001 fc40 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xFF,0x81);
  114ac0:	2181      	movs	r1, #129	; 0x81
  114ac2:	20ff      	movs	r0, #255	; 0xff
  114ac4:	f001 fc3c 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x01,0x18); //sel xtal clock
  114ac8:	2118      	movs	r1, #24
  114aca:	2001      	movs	r0, #1
  114acc:	f001 fc38 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xFF,0x80);
  114ad0:	2180      	movs	r1, #128	; 0x80
  114ad2:	20ff      	movs	r0, #255	; 0xff
  114ad4:	f001 fc34 	bl	116340 <HDMI_WriteI2C_Byte>
    return 0;
  114ad8:	2000      	movs	r0, #0
}
  114ada:	bd08      	pop	{r3, r15}
        return -1;
  114adc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  114ae0:	bd08      	pop	{r3, r15}
  114ae2:	bf00      	nop

00114ae4 <LT9611_LowPower_mode>:
    if(on)
  114ae4:	b9d0      	cbnz	r0, 114b1c <LT9611_LowPower_mode+0x38>
{
  114ae6:	b508      	push	{r3, r14}
        HDMI_WriteI2C_Byte(0xFF,0x81);
  114ae8:	2181      	movs	r1, #129	; 0x81
  114aea:	20ff      	movs	r0, #255	; 0xff
  114aec:	f001 fc28 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x02,0x12);
  114af0:	2112      	movs	r1, #18
  114af2:	2002      	movs	r0, #2
  114af4:	f001 fc24 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x23,0x40);
  114af8:	2140      	movs	r1, #64	; 0x40
  114afa:	2023      	movs	r0, #35	; 0x23
  114afc:	f001 fc20 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x30,0xea);
  114b00:	21ea      	movs	r1, #234	; 0xea
  114b02:	2030      	movs	r0, #48	; 0x30
  114b04:	f001 fc1c 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x80);
  114b08:	2180      	movs	r1, #128	; 0x80
  114b0a:	20ff      	movs	r0, #255	; 0xff
  114b0c:	f001 fc18 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0xfa);
  114b10:	21fa      	movs	r1, #250	; 0xfa
  114b12:	2011      	movs	r0, #17
}
  114b14:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        HDMI_WriteI2C_Byte(0x11,0xfa);
  114b18:	f001 bc12 	b.w	116340 <HDMI_WriteI2C_Byte>
  114b1c:	f7ff bf82 	b.w	114a24 <LT9611_LowPower_mode.part.0>

00114b20 <LT9611_System_Init>:
{
  114b20:	b508      	push	{r3, r14}
        HDMI_WriteI2C_Byte(0xFF,0x82);
  114b22:	2182      	movs	r1, #130	; 0x82
  114b24:	20ff      	movs	r0, #255	; 0xff
  114b26:	f001 fc0b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x51,0x11);
  114b2a:	2111      	movs	r1, #17
  114b2c:	2051      	movs	r0, #81	; 0x51
  114b2e:	f001 fc07 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xFF,0x82);
  114b32:	2182      	movs	r1, #130	; 0x82
  114b34:	20ff      	movs	r0, #255	; 0xff
  114b36:	f001 fc03 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x1b,0x69); //Timer 2
  114b3a:	2169      	movs	r1, #105	; 0x69
  114b3c:	201b      	movs	r0, #27
  114b3e:	f001 fbff 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x1c,0x78);
  114b42:	2178      	movs	r1, #120	; 0x78
  114b44:	201c      	movs	r0, #28
  114b46:	f001 fbfb 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xcb,0x69); //Timer 1
  114b4a:	2169      	movs	r1, #105	; 0x69
  114b4c:	20cb      	movs	r0, #203	; 0xcb
  114b4e:	f001 fbf7 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xcc,0x78);
  114b52:	2178      	movs	r1, #120	; 0x78
  114b54:	20cc      	movs	r0, #204	; 0xcc
  114b56:	f001 fbf3 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x80);
  114b5a:	2180      	movs	r1, #128	; 0x80
  114b5c:	20ff      	movs	r0, #255	; 0xff
  114b5e:	f001 fbef 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x04,0xf0);
  114b62:	21f0      	movs	r1, #240	; 0xf0
  114b64:	2004      	movs	r0, #4
  114b66:	f001 fbeb 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x06,0xf0);
  114b6a:	21f0      	movs	r1, #240	; 0xf0
  114b6c:	2006      	movs	r0, #6
  114b6e:	f001 fbe7 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0a,0x80);
  114b72:	2180      	movs	r1, #128	; 0x80
  114b74:	200a      	movs	r0, #10
  114b76:	f001 fbe3 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0b,0x46); //csc clk
  114b7a:	2146      	movs	r1, #70	; 0x46
  114b7c:	200b      	movs	r0, #11
  114b7e:	f001 fbdf 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0d,0xef);
  114b82:	21ef      	movs	r1, #239	; 0xef
  114b84:	200d      	movs	r0, #13
  114b86:	f001 fbdb 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0xfa);
  114b8a:	21fa      	movs	r1, #250	; 0xfa
  114b8c:	2011      	movs	r0, #17
}
  114b8e:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        HDMI_WriteI2C_Byte(0x11,0xfa);
  114b92:	f001 bbd5 	b.w	116340 <HDMI_WriteI2C_Byte>
  114b96:	bf00      	nop

00114b98 <LT9611_MIPI_Input_Analog>:
{
  114b98:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x81);
  114b9a:	2181      	movs	r1, #129	; 0x81
  114b9c:	20ff      	movs	r0, #255	; 0xff
  114b9e:	f001 fbcf 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x06,0x60); //port A rx current
  114ba2:	2160      	movs	r1, #96	; 0x60
  114ba4:	2006      	movs	r0, #6
  114ba6:	f001 fbcb 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x07,0x3f); //eq
  114baa:	213f      	movs	r1, #63	; 0x3f
  114bac:	2007      	movs	r0, #7
  114bae:	f001 fbc7 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x08,0x3f); //eq
  114bb2:	213f      	movs	r1, #63	; 0x3f
  114bb4:	2008      	movs	r0, #8
  114bb6:	f001 fbc3 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0a,0xfe); //port A ldo voltage set
  114bba:	21fe      	movs	r1, #254	; 0xfe
  114bbc:	200a      	movs	r0, #10
  114bbe:	f001 fbbf 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0b,0xbf); //enable port A lprx
  114bc2:	21bf      	movs	r1, #191	; 0xbf
  114bc4:	200b      	movs	r0, #11
  114bc6:	f001 fbbb 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x11,0x60); //port B rx current
  114bca:	2160      	movs	r1, #96	; 0x60
  114bcc:	2011      	movs	r0, #17
  114bce:	f001 fbb7 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x12,0x3f); //eq
  114bd2:	213f      	movs	r1, #63	; 0x3f
  114bd4:	2012      	movs	r0, #18
  114bd6:	f001 fbb3 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x13,0x3f); //eq
  114bda:	213f      	movs	r1, #63	; 0x3f
  114bdc:	2013      	movs	r0, #19
  114bde:	f001 fbaf 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0xfe); //port B ldo voltage set
  114be2:	21fe      	movs	r1, #254	; 0xfe
  114be4:	2015      	movs	r0, #21
  114be6:	f001 fbab 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x16,0xbf); //enable port B lprx
  114bea:	21bf      	movs	r1, #191	; 0xbf
  114bec:	2016      	movs	r0, #22
  114bee:	f001 fba7 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x1c,0x03); //PortA clk lane no-LP mode.
  114bf2:	2103      	movs	r1, #3
  114bf4:	201c      	movs	r0, #28
  114bf6:	f001 fba3 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x20,0x03); //PortB clk lane no-LP mode.
  114bfa:	2103      	movs	r1, #3
  114bfc:	2020      	movs	r0, #32
}
  114bfe:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x20,0x03); //PortB clk lane no-LP mode.
  114c02:	f001 bb9d 	b.w	116340 <HDMI_WriteI2C_Byte>
  114c06:	bf00      	nop

00114c08 <LT9611_MIPI_Input_Digtal>:
{
  114c08:	b538      	push	{r3, r4, r5, r14}
    HDMI_WriteI2C_Byte(0xff,0x82);
  114c0a:	2182      	movs	r1, #130	; 0x82
    lanes = lt9611.mipi_lane_cnt;
  114c0c:	f64c 04bc 	movw	r4, #51388	; 0xc8bc
    HDMI_WriteI2C_Byte(0xff,0x82);
  114c10:	20ff      	movs	r0, #255	; 0xff
    lanes = lt9611.mipi_lane_cnt;
  114c12:	f2c0 0412 	movt	r4, #18
  114c16:	7865      	ldrb	r5, [r4, #1]
    HDMI_WriteI2C_Byte(0xff,0x82);
  114c18:	f001 fb92 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x4f,0x80);    //[7] = Select ad_txpll_d_clk.
  114c1c:	2180      	movs	r1, #128	; 0x80
  114c1e:	204f      	movs	r0, #79	; 0x4f
  114c20:	f001 fb8e 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x50,0x10);
  114c24:	2110      	movs	r1, #16
  114c26:	2050      	movs	r0, #80	; 0x50
  114c28:	f001 fb8a 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x83);
  114c2c:	2183      	movs	r1, #131	; 0x83
  114c2e:	20ff      	movs	r0, #255	; 0xff
  114c30:	f001 fb86 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x00,lanes);
  114c34:	4629      	mov	r1, r5
  114c36:	2000      	movs	r0, #0
  114c38:	f001 fb82 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x02,0x0A); //settle
  114c3c:	210a      	movs	r1, #10
  114c3e:	2002      	movs	r0, #2
  114c40:	f001 fb7e 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x06,0x0A); //settle
  114c44:	210a      	movs	r1, #10
  114c46:	2006      	movs	r0, #6
  114c48:	f001 fb7a 	bl	116340 <HDMI_WriteI2C_Byte>
     HDMI_WriteI2C_Byte(0x0a,0x00); //1=dual_lr, 0=dual_en
  114c4c:	2100      	movs	r1, #0
  114c4e:	200a      	movs	r0, #10
  114c50:	f001 fb76 	bl	116340 <HDMI_WriteI2C_Byte>
    if(lt9611.mipi_mode==csi)
  114c54:	78a3      	ldrb	r3, [r4, #2]
  114c56:	b903      	cbnz	r3, 114c5a <LT9611_MIPI_Input_Digtal+0x52>
}
  114c58:	bd38      	pop	{r3, r4, r5, r15}
        HDMI_WriteI2C_Byte(0xff,0x83);
  114c5a:	2183      	movs	r1, #131	; 0x83
  114c5c:	20ff      	movs	r0, #255	; 0xff
  114c5e:	f001 fb6f 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x08,0x10); //csi_en
  114c62:	2110      	movs	r1, #16
  114c64:	2008      	movs	r0, #8
  114c66:	f001 fb6b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x2c,0x40); //csi_sel
  114c6a:	2140      	movs	r1, #64	; 0x40
  114c6c:	202c      	movs	r0, #44	; 0x2c
  114c6e:	f001 fb67 	bl	116340 <HDMI_WriteI2C_Byte>
        if(lt9611.input_color_space == RGB888)
  114c72:	7a23      	ldrb	r3, [r4, #8]
  114c74:	2b00      	cmp	r3, #0
  114c76:	d1ef      	bne.n	114c58 <LT9611_MIPI_Input_Digtal+0x50>
           HDMI_WriteI2C_Byte(0xff,0x83);
  114c78:	2183      	movs	r1, #131	; 0x83
  114c7a:	20ff      	movs	r0, #255	; 0xff
  114c7c:	f001 fb60 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x1c,0x01);
  114c80:	2101      	movs	r1, #1
  114c82:	201c      	movs	r0, #28
}
  114c84:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
           HDMI_WriteI2C_Byte(0x1c,0x01);
  114c88:	f001 bb5a 	b.w	116340 <HDMI_WriteI2C_Byte>

00114c8c <LT9611_Video_Check>:
{
  114c8c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    HDMI_WriteI2C_Byte(0xff,0x82); // top video check module
  114c8e:	2182      	movs	r1, #130	; 0x82
  114c90:	20ff      	movs	r0, #255	; 0xff
  114c92:	f001 fb55 	bl	116340 <HDMI_WriteI2C_Byte>
    h_total_sysclk = HDMI_ReadI2C_Byte(0x86);
  114c96:	2086      	movs	r0, #134	; 0x86
  114c98:	f001 fb20 	bl	1162dc <HDMI_ReadI2C_Byte>
  114c9c:	4607      	mov	r7, r0
    h_total_sysclk = (h_total_sysclk<<8) + HDMI_ReadI2C_Byte(0x87);
  114c9e:	2087      	movs	r0, #135	; 0x87
  114ca0:	f001 fb1c 	bl	1162dc <HDMI_ReadI2C_Byte>
  114ca4:	4606      	mov	r6, r0
    v_act=HDMI_ReadI2C_Byte(0x82);
  114ca6:	2082      	movs	r0, #130	; 0x82
  114ca8:	f001 fb18 	bl	1162dc <HDMI_ReadI2C_Byte>
    v_act=(v_act<<8)+HDMI_ReadI2C_Byte(0x83);
  114cac:	0205      	lsls	r5, r0, #8
  114cae:	2083      	movs	r0, #131	; 0x83
  114cb0:	f001 fb14 	bl	1162dc <HDMI_ReadI2C_Byte>
  114cb4:	b2ad      	uxth	r5, r5
  114cb6:	4405      	add	r5, r0
    v_tal=HDMI_ReadI2C_Byte(0x6c);
  114cb8:	206c      	movs	r0, #108	; 0x6c
  114cba:	f001 fb0f 	bl	1162dc <HDMI_ReadI2C_Byte>
    v_tal=(v_tal<<8)+HDMI_ReadI2C_Byte(0x6d);
  114cbe:	206d      	movs	r0, #109	; 0x6d
  114cc0:	f001 fb0c 	bl	1162dc <HDMI_ReadI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x83);
  114cc4:	2183      	movs	r1, #131	; 0x83
  114cc6:	20ff      	movs	r0, #255	; 0xff
    v_act=(v_act<<8)+HDMI_ReadI2C_Byte(0x83);
  114cc8:	b2ad      	uxth	r5, r5
    HDMI_WriteI2C_Byte(0xff,0x83);
  114cca:	f001 fb39 	bl	116340 <HDMI_WriteI2C_Byte>
    h_act_a = HDMI_ReadI2C_Byte(0x82);
  114cce:	2082      	movs	r0, #130	; 0x82
  114cd0:	f001 fb04 	bl	1162dc <HDMI_ReadI2C_Byte>
    h_act_a = (h_act_a<<8)+HDMI_ReadI2C_Byte(0x83);
  114cd4:	0204      	lsls	r4, r0, #8
  114cd6:	2083      	movs	r0, #131	; 0x83
  114cd8:	f001 fb00 	bl	1162dc <HDMI_ReadI2C_Byte>
  114cdc:	b2a4      	uxth	r4, r4
  114cde:	4404      	add	r4, r0
    h_act_b = HDMI_ReadI2C_Byte(0x86);
  114ce0:	2086      	movs	r0, #134	; 0x86
  114ce2:	f001 fafb 	bl	1162dc <HDMI_ReadI2C_Byte>
    h_act_b =(h_act_b<<8)+HDMI_ReadI2C_Byte(0x87);
  114ce6:	2087      	movs	r0, #135	; 0x87
  114ce8:	f001 faf8 	bl	1162dc <HDMI_ReadI2C_Byte>
    if(lt9611.input_color_space==YUV422)
  114cec:	f64c 03bc 	movw	r3, #51388	; 0xc8bc
    h_act_a = (h_act_a<<8)+HDMI_ReadI2C_Byte(0x83);
  114cf0:	b2a4      	uxth	r4, r4
    if(lt9611.input_color_space==YUV422)
  114cf2:	f2c0 0312 	movt	r3, #18
  114cf6:	7a1b      	ldrb	r3, [r3, #8]
  114cf8:	2b01      	cmp	r3, #1
        h_act_a /= 2;
  114cfa:	bf08      	it	eq
  114cfc:	0864      	lsreq	r4, r4, #1
    if(lt9611.input_color_space==YUV422)
  114cfe:	d001      	beq.n	114d04 <LT9611_Video_Check+0x78>
    else if(lt9611.input_color_space==RGB888)
  114d00:	2b00      	cmp	r3, #0
  114d02:	d04c      	beq.n	114d9e <LT9611_Video_Check+0x112>
    mipi_video_format=HDMI_ReadI2C_Byte(0x88);
  114d04:	2088      	movs	r0, #136	; 0x88
  114d06:	f001 fae9 	bl	1162dc <HDMI_ReadI2C_Byte>
    LT9611_Chip_ID();
  114d0a:	f7ff fecf 	bl	114aac <LT9611_Chip_ID>
      if((h_act==video_640x480_60Hz.hact)&&(v_act==video_640x480_60Hz.vact))
  114d0e:	f64c 2368 	movw	r3, #51816	; 0xca68
  114d12:	f2c0 0312 	movt	r3, #18
  114d16:	88da      	ldrh	r2, [r3, #6]
  114d18:	42a2      	cmp	r2, r4
  114d1a:	f000 8092 	beq.w	114e42 <LT9611_Video_Check+0x1b6>
      else if((h_act==(video_720x480_60Hz.hact))&&(v_act==video_720x480_60Hz.vact))
  114d1e:	f64c 2388 	movw	r3, #51848	; 0xca88
  114d22:	f2c0 0312 	movt	r3, #18
  114d26:	88da      	ldrh	r2, [r3, #6]
  114d28:	42a2      	cmp	r2, r4
  114d2a:	f000 809a 	beq.w	114e62 <LT9611_Video_Check+0x1d6>
      else if((h_act==(video_720x576_50Hz.hact))&&(v_act==video_720x576_50Hz.vact))
  114d2e:	f64c 23a8 	movw	r3, #51880	; 0xcaa8
  114d32:	f2c0 0312 	movt	r3, #18
  114d36:	88da      	ldrh	r2, [r3, #6]
  114d38:	42a2      	cmp	r2, r4
  114d3a:	f000 80a2 	beq.w	114e82 <LT9611_Video_Check+0x1f6>
      else if((h_act==video_1280x720_60Hz.hact) && (v_act==video_1280x720_60Hz.vact))
  114d3e:	f64c 1328 	movw	r3, #51496	; 0xc928
    h_total_sysclk = (h_total_sysclk<<8) + HDMI_ReadI2C_Byte(0x87);
  114d42:	eb06 2607 	add.w	r6, r6, r7, lsl #8
      else if((h_act==video_1280x720_60Hz.hact) && (v_act==video_1280x720_60Hz.vact))
  114d46:	f2c0 0312 	movt	r3, #18
  114d4a:	88da      	ldrh	r2, [r3, #6]
  114d4c:	42a2      	cmp	r2, r4
    h_total_sysclk = (h_total_sysclk<<8) + HDMI_ReadI2C_Byte(0x87);
  114d4e:	b2b6      	uxth	r6, r6
      else if((h_act==video_1280x720_60Hz.hact) && (v_act==video_1280x720_60Hz.vact))
  114d50:	d02e      	beq.n	114db0 <LT9611_Video_Check+0x124>
      else if((h_act==video_1920x1080_60Hz.hact) && (v_act==video_1920x1080_60Hz.vact))//1080P
  114d52:	f64c 13c8 	movw	r3, #51656	; 0xc9c8
  114d56:	f2c0 0312 	movt	r3, #18
  114d5a:	88da      	ldrh	r2, [r3, #6]
  114d5c:	42a2      	cmp	r2, r4
  114d5e:	d048      	beq.n	114df2 <LT9611_Video_Check+0x166>
        else if((h_act==video_3840x2160_30Hz.hact) && (v_act==video_3840x2160_30Hz.vact)) //2160P
  114d60:	f64c 2348 	movw	r3, #51784	; 0xca48
  114d64:	f2c0 0312 	movt	r3, #18
  114d68:	88da      	ldrh	r2, [r3, #6]
  114d6a:	42a2      	cmp	r2, r4
  114d6c:	f000 8099 	beq.w	114ea2 <LT9611_Video_Check+0x216>
    else if((h_act==video_1200x1920_60Hz.hact)&&(v_act==video_1200x1920_60Hz.vact))//&&
  114d70:	f64c 03c8 	movw	r3, #51400	; 0xc8c8
  114d74:	f2c0 0312 	movt	r3, #18
  114d78:	88da      	ldrh	r2, [r3, #6]
  114d7a:	42a2      	cmp	r2, r4
  114d7c:	f000 80af 	beq.w	114ede <LT9611_Video_Check+0x252>
    else if((h_act==video_1920x720_60Hz.hact)&&(v_act==video_1920x720_60Hz.vact))//&&
  114d80:	f64c 13e8 	movw	r3, #51688	; 0xc9e8
  114d84:	f2c0 0312 	movt	r3, #18
  114d88:	88da      	ldrh	r2, [r3, #6]
  114d8a:	42a2      	cmp	r2, r4
  114d8c:	f000 80b7 	beq.w	114efe <LT9611_Video_Check+0x272>
            Video_Format = video_none;
  114d90:	f243 233c 	movw	r3, #12860	; 0x323c
  114d94:	2220      	movs	r2, #32
  114d96:	f2c0 0313 	movt	r3, #19
  114d9a:	601a      	str	r2, [r3, #0]
}
  114d9c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        h_act_a /= 3;
  114d9e:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  114da2:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  114da6:	fba3 3404 	umull	r3, r4, r3, r4
  114daa:	f3c4 044f 	ubfx	r4, r4, #1, #16
  114dae:	e7a9      	b.n	114d04 <LT9611_Video_Check+0x78>
      else if((h_act==video_1280x720_60Hz.hact) && (v_act==video_1280x720_60Hz.vact))
  114db0:	8a1a      	ldrh	r2, [r3, #16]
  114db2:	42aa      	cmp	r2, r5
  114db4:	d1cd      	bne.n	114d52 <LT9611_Video_Check+0xc6>
          if(h_total_sysclk < 630)
  114db6:	f240 2275 	movw	r2, #629	; 0x275
  114dba:	4296      	cmp	r6, r2
  114dbc:	f240 80a4 	bls.w	114f08 <LT9611_Video_Check+0x27c>
          else if(h_total_sysclk < 750)
  114dc0:	f240 23ed 	movw	r3, #749	; 0x2ed
  114dc4:	429e      	cmp	r6, r3
  114dc6:	f240 80c3 	bls.w	114f50 <LT9611_Video_Check+0x2c4>
          else if(h_total_sysclk < 1230)
  114dca:	f240 43cd 	movw	r3, #1229	; 0x4cd
  114dce:	429e      	cmp	r6, r3
  114dd0:	d8e4      	bhi.n	114d9c <LT9611_Video_Check+0x110>
                Video_Format=video_1280x720_30Hz_vic;
  114dd2:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1280x720_30Hz;
  114dd6:	f243 236c 	movw	r3, #12908	; 0x326c
  114dda:	f64c 02e8 	movw	r2, #51432	; 0xc8e8
                Video_Format=video_1280x720_30Hz_vic;
  114dde:	f2c0 0113 	movt	r1, #19
  114de2:	200c      	movs	r0, #12
                video = &video_1280x720_30Hz;
  114de4:	f2c0 0313 	movt	r3, #19
  114de8:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1280x720_30Hz_vic;
  114dec:	6008      	str	r0, [r1, #0]
                video = &video_1280x720_30Hz;
  114dee:	601a      	str	r2, [r3, #0]
}
  114df0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
      else if((h_act==video_1920x1080_60Hz.hact) && (v_act==video_1920x1080_60Hz.vact))//1080P
  114df2:	8a1a      	ldrh	r2, [r3, #16]
  114df4:	42aa      	cmp	r2, r5
  114df6:	d1b3      	bne.n	114d60 <LT9611_Video_Check+0xd4>
            if(h_total_sysclk < 430)
  114df8:	f5b6 7fd7 	cmp.w	r6, #430	; 0x1ae
  114dfc:	f0c0 8090 	bcc.w	114f20 <LT9611_Video_Check+0x294>
            else if(h_total_sysclk < 510)
  114e00:	f5b6 7fff 	cmp.w	r6, #510	; 0x1fe
  114e04:	f0c0 80b4 	bcc.w	114f70 <LT9611_Video_Check+0x2e4>
            else if(h_total_sysclk < 830)
  114e08:	f240 333d 	movw	r3, #829	; 0x33d
  114e0c:	429e      	cmp	r6, r3
  114e0e:	f240 80cf 	bls.w	114fb0 <LT9611_Video_Check+0x324>
            else if(h_total_sysclk < 980)
  114e12:	f5b6 7f75 	cmp.w	r6, #980	; 0x3d4
  114e16:	f0c0 80db 	bcc.w	114fd0 <LT9611_Video_Check+0x344>
            else if(h_total_sysclk < 1030)
  114e1a:	f240 4305 	movw	r3, #1029	; 0x405
  114e1e:	429e      	cmp	r6, r3
  114e20:	d8bc      	bhi.n	114d9c <LT9611_Video_Check+0x110>
                Video_Format=video_1920x1080_24Hz_vic;
  114e22:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1920x1080_24Hz;
  114e26:	f243 236c 	movw	r3, #12908	; 0x326c
  114e2a:	f64c 1248 	movw	r2, #51528	; 0xc948
                Video_Format=video_1920x1080_24Hz_vic;
  114e2e:	f2c0 0113 	movt	r1, #19
  114e32:	201d      	movs	r0, #29
                video = &video_1920x1080_24Hz;
  114e34:	f2c0 0313 	movt	r3, #19
  114e38:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1920x1080_24Hz_vic;
  114e3c:	6008      	str	r0, [r1, #0]
                video = &video_1920x1080_24Hz;
  114e3e:	601a      	str	r2, [r3, #0]
}
  114e40:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
      if((h_act==video_640x480_60Hz.hact)&&(v_act==video_640x480_60Hz.vact))
  114e42:	8a1a      	ldrh	r2, [r3, #16]
  114e44:	42aa      	cmp	r2, r5
  114e46:	f47f af6a 	bne.w	114d1e <LT9611_Video_Check+0x92>
            Video_Format=video_640x480_60Hz_vic1;
  114e4a:	f243 213c 	movw	r1, #12860	; 0x323c
            video = &video_640x480_60Hz;
  114e4e:	f243 226c 	movw	r2, #12908	; 0x326c
            Video_Format=video_640x480_60Hz_vic1;
  114e52:	2001      	movs	r0, #1
  114e54:	f2c0 0113 	movt	r1, #19
            video = &video_640x480_60Hz;
  114e58:	f2c0 0213 	movt	r2, #19
            Video_Format=video_640x480_60Hz_vic1;
  114e5c:	6008      	str	r0, [r1, #0]
            video = &video_640x480_60Hz;
  114e5e:	6013      	str	r3, [r2, #0]
}
  114e60:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
      else if((h_act==(video_720x480_60Hz.hact))&&(v_act==video_720x480_60Hz.vact))
  114e62:	8a1a      	ldrh	r2, [r3, #16]
  114e64:	42aa      	cmp	r2, r5
  114e66:	f47f af62 	bne.w	114d2e <LT9611_Video_Check+0xa2>
            Video_Format=video_720x480_60Hz_vic3;
  114e6a:	f243 213c 	movw	r1, #12860	; 0x323c
            video = &video_720x480_60Hz;
  114e6e:	f243 226c 	movw	r2, #12908	; 0x326c
            Video_Format=video_720x480_60Hz_vic3;
  114e72:	2002      	movs	r0, #2
  114e74:	f2c0 0113 	movt	r1, #19
            video = &video_720x480_60Hz;
  114e78:	f2c0 0213 	movt	r2, #19
            Video_Format=video_720x480_60Hz_vic3;
  114e7c:	6008      	str	r0, [r1, #0]
            video = &video_720x480_60Hz;
  114e7e:	6013      	str	r3, [r2, #0]
}
  114e80:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
      else if((h_act==(video_720x576_50Hz.hact))&&(v_act==video_720x576_50Hz.vact))
  114e82:	8a1a      	ldrh	r2, [r3, #16]
  114e84:	42aa      	cmp	r2, r5
  114e86:	f47f af5a 	bne.w	114d3e <LT9611_Video_Check+0xb2>
            Video_Format=video_720x576_50Hz_vic;
  114e8a:	f243 213c 	movw	r1, #12860	; 0x323c
            video = &video_720x576_50Hz;
  114e8e:	f243 226c 	movw	r2, #12908	; 0x326c
            Video_Format=video_720x576_50Hz_vic;
  114e92:	2003      	movs	r0, #3
  114e94:	f2c0 0113 	movt	r1, #19
            video = &video_720x576_50Hz;
  114e98:	f2c0 0213 	movt	r2, #19
            Video_Format=video_720x576_50Hz_vic;
  114e9c:	6008      	str	r0, [r1, #0]
            video = &video_720x576_50Hz;
  114e9e:	6013      	str	r3, [r2, #0]
}
  114ea0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        else if((h_act==video_3840x2160_30Hz.hact) && (v_act==video_3840x2160_30Hz.vact)) //2160P
  114ea2:	8a1a      	ldrh	r2, [r3, #16]
  114ea4:	42aa      	cmp	r2, r5
  114ea6:	f47f af63 	bne.w	114d70 <LT9611_Video_Check+0xe4>
            if(h_total_sysclk < 430)
  114eaa:	f5b6 7fd7 	cmp.w	r6, #430	; 0x1ae
  114eae:	d343      	bcc.n	114f38 <LT9611_Video_Check+0x2ac>
            else if(h_total_sysclk < 490)
  114eb0:	f5b6 7ff5 	cmp.w	r6, #490	; 0x1ea
  114eb4:	d36c      	bcc.n	114f90 <LT9611_Video_Check+0x304>
            else if(h_total_sysclk < 520)
  114eb6:	f5b6 7f02 	cmp.w	r6, #520	; 0x208
  114eba:	f4bf af6f 	bcs.w	114d9c <LT9611_Video_Check+0x110>
                Video_Format=video_3840x2160_24Hz_vic;
  114ebe:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_3840x2160_24Hz;
  114ec2:	f243 236c 	movw	r3, #12908	; 0x326c
  114ec6:	f64c 2208 	movw	r2, #51720	; 0xca08
                Video_Format=video_3840x2160_24Hz_vic;
  114eca:	f2c0 0113 	movt	r1, #19
  114ece:	200f      	movs	r0, #15
                video = &video_3840x2160_24Hz;
  114ed0:	f2c0 0313 	movt	r3, #19
  114ed4:	f2c0 0212 	movt	r2, #18
                Video_Format=video_3840x2160_24Hz_vic;
  114ed8:	6008      	str	r0, [r1, #0]
                video = &video_3840x2160_24Hz;
  114eda:	601a      	str	r2, [r3, #0]
}
  114edc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    else if((h_act==video_1200x1920_60Hz.hact)&&(v_act==video_1200x1920_60Hz.vact))//&&
  114ede:	8a1a      	ldrh	r2, [r3, #16]
  114ee0:	42aa      	cmp	r2, r5
  114ee2:	f47f af4d 	bne.w	114d80 <LT9611_Video_Check+0xf4>
            Video_Format = video_other;
  114ee6:	f243 213c 	movw	r1, #12860	; 0x323c
            video = &video_1920x720_60Hz;
  114eea:	f243 226c 	movw	r2, #12908	; 0x326c
            Video_Format = video_other;
  114eee:	201f      	movs	r0, #31
  114ef0:	f2c0 0113 	movt	r1, #19
            video = &video_1920x720_60Hz;
  114ef4:	f2c0 0213 	movt	r2, #19
            Video_Format = video_other;
  114ef8:	6008      	str	r0, [r1, #0]
            video = &video_1920x720_60Hz;
  114efa:	6013      	str	r3, [r2, #0]
}
  114efc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    else if((h_act==video_1920x720_60Hz.hact)&&(v_act==video_1920x720_60Hz.vact))//&&
  114efe:	8a1a      	ldrh	r2, [r3, #16]
  114f00:	42aa      	cmp	r2, r5
  114f02:	f47f af45 	bne.w	114d90 <LT9611_Video_Check+0x104>
  114f06:	e7ee      	b.n	114ee6 <LT9611_Video_Check+0x25a>
                Video_Format=video_1280x720_60Hz_vic4;
  114f08:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1280x720_60Hz;
  114f0c:	f243 226c 	movw	r2, #12908	; 0x326c
                Video_Format=video_1280x720_60Hz_vic4;
  114f10:	2004      	movs	r0, #4
  114f12:	f2c0 0113 	movt	r1, #19
                video = &video_1280x720_60Hz;
  114f16:	f2c0 0213 	movt	r2, #19
                Video_Format=video_1280x720_60Hz_vic4;
  114f1a:	6008      	str	r0, [r1, #0]
                video = &video_1280x720_60Hz;
  114f1c:	6013      	str	r3, [r2, #0]
}
  114f1e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_1920x1080_60Hz_vic16;
  114f20:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1920x1080_60Hz;
  114f24:	f243 226c 	movw	r2, #12908	; 0x326c
                Video_Format=video_1920x1080_60Hz_vic16;
  114f28:	2005      	movs	r0, #5
  114f2a:	f2c0 0113 	movt	r1, #19
                video = &video_1920x1080_60Hz;
  114f2e:	f2c0 0213 	movt	r2, #19
                Video_Format=video_1920x1080_60Hz_vic16;
  114f32:	6008      	str	r0, [r1, #0]
                video = &video_1920x1080_60Hz;
  114f34:	6013      	str	r3, [r2, #0]
}
  114f36:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_3840x2160_30Hz_vic;
  114f38:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_3840x2160_30Hz;
  114f3c:	f243 226c 	movw	r2, #12908	; 0x326c
                Video_Format=video_3840x2160_30Hz_vic;
  114f40:	200d      	movs	r0, #13
  114f42:	f2c0 0113 	movt	r1, #19
                video = &video_3840x2160_30Hz;
  114f46:	f2c0 0213 	movt	r2, #19
                Video_Format=video_3840x2160_30Hz_vic;
  114f4a:	6008      	str	r0, [r1, #0]
                video = &video_3840x2160_30Hz;
  114f4c:	6013      	str	r3, [r2, #0]
}
  114f4e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_1280x720_50Hz_vic;
  114f50:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1280x720_50Hz;
  114f54:	f243 236c 	movw	r3, #12908	; 0x326c
  114f58:	f64c 1208 	movw	r2, #51464	; 0xc908
                Video_Format=video_1280x720_50Hz_vic;
  114f5c:	f2c0 0113 	movt	r1, #19
  114f60:	200b      	movs	r0, #11
                video = &video_1280x720_50Hz;
  114f62:	f2c0 0313 	movt	r3, #19
  114f66:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1280x720_50Hz_vic;
  114f6a:	6008      	str	r0, [r1, #0]
                video = &video_1280x720_50Hz;
  114f6c:	601a      	str	r2, [r3, #0]
}
  114f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_1920x1080_50Hz_vic;
  114f70:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1920x1080_50Hz;
  114f74:	f243 236c 	movw	r3, #12908	; 0x326c
  114f78:	f64c 12a8 	movw	r2, #51624	; 0xc9a8
                Video_Format=video_1920x1080_50Hz_vic;
  114f7c:	f2c0 0113 	movt	r1, #19
  114f80:	201a      	movs	r0, #26
                video = &video_1920x1080_50Hz;
  114f82:	f2c0 0313 	movt	r3, #19
  114f86:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1920x1080_50Hz_vic;
  114f8a:	6008      	str	r0, [r1, #0]
                video = &video_1920x1080_50Hz;
  114f8c:	601a      	str	r2, [r3, #0]
}
  114f8e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_3840x2160_25Hz_vic;
  114f90:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_3840x2160_25Hz;
  114f94:	f243 236c 	movw	r3, #12908	; 0x326c
  114f98:	f64c 2228 	movw	r2, #51752	; 0xca28
                Video_Format=video_3840x2160_25Hz_vic;
  114f9c:	f2c0 0113 	movt	r1, #19
  114fa0:	200e      	movs	r0, #14
                video = &video_3840x2160_25Hz;
  114fa2:	f2c0 0313 	movt	r3, #19
  114fa6:	f2c0 0212 	movt	r2, #18
                Video_Format=video_3840x2160_25Hz_vic;
  114faa:	6008      	str	r0, [r1, #0]
                video = &video_3840x2160_25Hz;
  114fac:	601a      	str	r2, [r3, #0]
}
  114fae:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_1920x1080_30Hz_vic;
  114fb0:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1920x1080_30Hz;
  114fb4:	f243 236c 	movw	r3, #12908	; 0x326c
  114fb8:	f64c 1288 	movw	r2, #51592	; 0xc988
                Video_Format=video_1920x1080_30Hz_vic;
  114fbc:	f2c0 0113 	movt	r1, #19
  114fc0:	201b      	movs	r0, #27
                video = &video_1920x1080_30Hz;
  114fc2:	f2c0 0313 	movt	r3, #19
  114fc6:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1920x1080_30Hz_vic;
  114fca:	6008      	str	r0, [r1, #0]
                video = &video_1920x1080_30Hz;
  114fcc:	601a      	str	r2, [r3, #0]
}
  114fce:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                Video_Format=video_1920x1080_25Hz_vic;
  114fd0:	f243 213c 	movw	r1, #12860	; 0x323c
                video = &video_1920x1080_25Hz;
  114fd4:	f243 236c 	movw	r3, #12908	; 0x326c
  114fd8:	f64c 1268 	movw	r2, #51560	; 0xc968
                Video_Format=video_1920x1080_25Hz_vic;
  114fdc:	f2c0 0113 	movt	r1, #19
  114fe0:	201c      	movs	r0, #28
                video = &video_1920x1080_25Hz;
  114fe2:	f2c0 0313 	movt	r3, #19
  114fe6:	f2c0 0212 	movt	r2, #18
                Video_Format=video_1920x1080_25Hz_vic;
  114fea:	6008      	str	r0, [r1, #0]
                video = &video_1920x1080_25Hz;
  114fec:	601a      	str	r2, [r3, #0]
}
  114fee:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00114ff0 <LT9611_MIPI_Video_Timing>:
{
  114ff0:	b510      	push	{r4, r14}
    HDMI_WriteI2C_Byte(0xff,0x83);
  114ff2:	2183      	movs	r1, #131	; 0x83
{
  114ff4:	4604      	mov	r4, r0
    HDMI_WriteI2C_Byte(0xff,0x83);
  114ff6:	20ff      	movs	r0, #255	; 0xff
  114ff8:	f001 f9a2 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0d,(u8)(video_format->vtotal/256));
  114ffc:	8a61      	ldrh	r1, [r4, #18]
  114ffe:	200d      	movs	r0, #13
  115000:	0a09      	lsrs	r1, r1, #8
  115002:	f001 f99d 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0e,(u8)(video_format->vtotal%256));//vtotal
  115006:	7ca1      	ldrb	r1, [r4, #18]
  115008:	200e      	movs	r0, #14
  11500a:	f001 f999 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x0f,(u8)(video_format->vact/256));
  11500e:	8a21      	ldrh	r1, [r4, #16]
  115010:	200f      	movs	r0, #15
  115012:	0a09      	lsrs	r1, r1, #8
  115014:	f001 f994 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x10,(u8)(video_format->vact%256));  //vactive
  115018:	7c21      	ldrb	r1, [r4, #16]
  11501a:	2010      	movs	r0, #16
  11501c:	f001 f990 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x11,(u8)(video_format->htotal/256));
  115020:	8921      	ldrh	r1, [r4, #8]
  115022:	2011      	movs	r0, #17
  115024:	0a09      	lsrs	r1, r1, #8
  115026:	f001 f98b 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x12,(u8)(video_format->htotal%256));//htotal
  11502a:	7a21      	ldrb	r1, [r4, #8]
  11502c:	2012      	movs	r0, #18
  11502e:	f001 f987 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x13,(u8)(video_format->hact/256));
  115032:	88e1      	ldrh	r1, [r4, #6]
  115034:	2013      	movs	r0, #19
  115036:	0a09      	lsrs	r1, r1, #8
  115038:	f001 f982 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x14,(u8)(video_format->hact%256)); //hactive
  11503c:	79a1      	ldrb	r1, [r4, #6]
  11503e:	2014      	movs	r0, #20
  115040:	f001 f97e 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,(u8)(video_format->vs%256));   //vsa
  115044:	7b21      	ldrb	r1, [r4, #12]
  115046:	2015      	movs	r0, #21
  115048:	f001 f97a 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x16,(u8)(video_format->hs%256));   //hsa
  11504c:	78a1      	ldrb	r1, [r4, #2]
  11504e:	2016      	movs	r0, #22
  115050:	f001 f976 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x17,(u8)(video_format->vfp%256));  //vfp
  115054:	7aa1      	ldrb	r1, [r4, #10]
  115056:	2017      	movs	r0, #23
  115058:	f001 f972 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x18,(u8)((video_format->vs+video_format->vbp)%256));  //vss
  11505c:	89e3      	ldrh	r3, [r4, #14]
  11505e:	89a1      	ldrh	r1, [r4, #12]
  115060:	2018      	movs	r0, #24
  115062:	4419      	add	r1, r3
  115064:	b2c9      	uxtb	r1, r1
  115066:	f001 f96b 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x19,(u8)(video_format->hfp%256));  //hfp
  11506a:	7821      	ldrb	r1, [r4, #0]
  11506c:	2019      	movs	r0, #25
  11506e:	f001 f967 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x1a,(u8)(((video_format->hfp/256)<<4)+(video_format->hs+video_format->hbp)/256));   //20180901
  115072:	8821      	ldrh	r1, [r4, #0]
  115074:	8863      	ldrh	r3, [r4, #2]
  115076:	88a2      	ldrh	r2, [r4, #4]
  115078:	0a09      	lsrs	r1, r1, #8
  11507a:	201a      	movs	r0, #26
  11507c:	4413      	add	r3, r2
  11507e:	0109      	lsls	r1, r1, #4
  115080:	eb01 2113 	add.w	r1, r1, r3, lsr #8
  115084:	b2c9      	uxtb	r1, r1
  115086:	f001 f95b 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x1b,(u8)((video_format->hs+video_format->hbp)%256));  //hss
  11508a:	8861      	ldrh	r1, [r4, #2]
  11508c:	88a3      	ldrh	r3, [r4, #4]
  11508e:	201b      	movs	r0, #27
  115090:	4419      	add	r1, r3
}
  115092:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0x1b,(u8)((video_format->hs+video_format->hbp)%256));  //hss
  115096:	b2c9      	uxtb	r1, r1
  115098:	f001 b952 	b.w	116340 <HDMI_WriteI2C_Byte>

0011509c <LT9611_MIPI_Pcr>:
    POL = (video_format-> h_polarity)*0x02 + (video_format-> v_polarity);
  11509c:	7d03      	ldrb	r3, [r0, #20]
{
  11509e:	b510      	push	{r4, r14}
    POL = (video_format-> h_polarity)*0x02 + (video_format-> v_polarity);
  1150a0:	7d44      	ldrb	r4, [r0, #21]
    HDMI_WriteI2C_Byte(0xff,0x83);
  1150a2:	2183      	movs	r1, #131	; 0x83
  1150a4:	20ff      	movs	r0, #255	; 0xff
    POL = (video_format-> h_polarity)*0x02 + (video_format-> v_polarity);
  1150a6:	eb04 0443 	add.w	r4, r4, r3, lsl #1
    HDMI_WriteI2C_Byte(0xff,0x83);
  1150aa:	f001 f949 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0b,0x01); //vsync read delay(reference value)
  1150ae:	2101      	movs	r1, #1
  1150b0:	200b      	movs	r0, #11
  1150b2:	f001 f945 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0c,0x10); //
  1150b6:	2110      	movs	r1, #16
  1150b8:	200c      	movs	r0, #12
    POL = (video_format-> h_polarity)*0x02 + (video_format-> v_polarity);
  1150ba:	b2e4      	uxtb	r4, r4
        HDMI_WriteI2C_Byte(0x0c,0x10); //
  1150bc:	f001 f940 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x48,0x00); //de mode delay
  1150c0:	2100      	movs	r1, #0
  1150c2:	2048      	movs	r0, #72	; 0x48
  1150c4:	f001 f93c 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x49,0x81); //=1/4 hact
  1150c8:	2181      	movs	r1, #129	; 0x81
  1150ca:	2049      	movs	r0, #73	; 0x49
  1150cc:	f001 f938 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x21,0x4a); //bit[3:0] step[11:8]
  1150d0:	214a      	movs	r1, #74	; 0x4a
  1150d2:	2021      	movs	r0, #33	; 0x21
  1150d4:	f001 f934 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x24,0x71); //bit[7:4]v/h/de mode; line for clk stb[11:8]
  1150d8:	2171      	movs	r1, #113	; 0x71
  1150da:	2024      	movs	r0, #36	; 0x24
  1150dc:	f001 f930 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x25,0x30); //line for clk stb[7:0]
  1150e0:	2130      	movs	r1, #48	; 0x30
  1150e2:	2025      	movs	r0, #37	; 0x25
  1150e4:	f001 f92c 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x2a,0x01); //clk stable in
  1150e8:	2101      	movs	r1, #1
  1150ea:	202a      	movs	r0, #42	; 0x2a
  1150ec:	f001 f928 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x4a,0x40); //offset //0x10
  1150f0:	2140      	movs	r1, #64	; 0x40
  1150f2:	204a      	movs	r0, #74	; 0x4a
  1150f4:	f001 f924 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x1d,(0x10|POL)); //PCR de mode step setting.
  1150f8:	201d      	movs	r0, #29
  1150fa:	f084 0113 	eor.w	r1, r4, #19
  1150fe:	f001 f91f 	bl	116340 <HDMI_WriteI2C_Byte>
    switch(Video_Format)
  115102:	f243 233c 	movw	r3, #12860	; 0x323c
  115106:	f2c0 0313 	movt	r3, #19
  11510a:	681b      	ldr	r3, [r3, #0]
  11510c:	3b01      	subs	r3, #1
  11510e:	2b14      	cmp	r3, #20
  115110:	d81c      	bhi.n	11514c <LT9611_MIPI_Pcr+0xb0>
  115112:	e8df f003 	tbb	[r15, r3]
  115116:	3c3c      	.short	0x3c3c
  115118:	1b1b1b1b 	.word	0x1b1b1b1b
  11511c:	1b1b1b1b 	.word	0x1b1b1b1b
  115120:	1b1b1b1b 	.word	0x1b1b1b1b
  115124:	1b0b1b1b 	.word	0x1b0b1b1b
  115128:	1b1b      	.short	0x1b1b
  11512a:	0b          	.byte	0x0b
  11512b:	00          	.byte	0x00
        HDMI_WriteI2C_Byte(0x24,0x70); //bit[7:4]v/h/de mode; line for clk stb[11:8]
  11512c:	2170      	movs	r1, #112	; 0x70
  11512e:	2024      	movs	r0, #36	; 0x24
  115130:	f001 f906 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x25,0x80); //line for clk stb[7:0]
  115134:	2180      	movs	r1, #128	; 0x80
  115136:	2025      	movs	r0, #37	; 0x25
  115138:	f001 f902 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x2a,0x10); //clk stable in
  11513c:	2110      	movs	r1, #16
  11513e:	202a      	movs	r0, #42	; 0x2a
  115140:	f001 f8fe 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x1d,0xf0); //PCR de mode step setting.
  115144:	21f0      	movs	r1, #240	; 0xf0
  115146:	201d      	movs	r0, #29
  115148:	f001 f8fa 	bl	116340 <HDMI_WriteI2C_Byte>
            LT9611_MIPI_Video_Timing(video);
  11514c:	f243 236c 	movw	r3, #12908	; 0x326c
  115150:	f2c0 0313 	movt	r3, #19
  115154:	6818      	ldr	r0, [r3, #0]
  115156:	f7ff ff4b 	bl	114ff0 <LT9611_MIPI_Video_Timing>
        HDMI_WriteI2C_Byte(0xff,0x83);
  11515a:	2183      	movs	r1, #131	; 0x83
  11515c:	20ff      	movs	r0, #255	; 0xff
  11515e:	f001 f8ef 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x26,pcr_m);
  115162:	f243 236a 	movw	r3, #12906	; 0x326a
  115166:	2026      	movs	r0, #38	; 0x26
  115168:	f2c0 0313 	movt	r3, #19
  11516c:	7819      	ldrb	r1, [r3, #0]
  11516e:	f001 f8e7 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x80);
  115172:	2180      	movs	r1, #128	; 0x80
  115174:	20ff      	movs	r0, #255	; 0xff
  115176:	f001 f8e3 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0x5a); //Pcr reset
  11517a:	215a      	movs	r1, #90	; 0x5a
  11517c:	2011      	movs	r0, #17
  11517e:	f001 f8df 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0xfa);
  115182:	21fa      	movs	r1, #250	; 0xfa
  115184:	2011      	movs	r0, #17
}
  115186:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        HDMI_WriteI2C_Byte(0x11,0xfa);
  11518a:	f001 b8d9 	b.w	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0xff,0x83);
  11518e:	2183      	movs	r1, #131	; 0x83
  115190:	20ff      	movs	r0, #255	; 0xff
  115192:	f001 f8d5 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x0b,0x02);
  115196:	2102      	movs	r1, #2
  115198:	200b      	movs	r0, #11
  11519a:	f001 f8d1 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x0c,0x40);
  11519e:	2140      	movs	r1, #64	; 0x40
  1151a0:	200c      	movs	r0, #12
  1151a2:	f001 f8cd 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x48,0x01);
  1151a6:	2101      	movs	r1, #1
  1151a8:	2048      	movs	r0, #72	; 0x48
  1151aa:	f001 f8c9 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x49,0x10);
  1151ae:	2110      	movs	r1, #16
  1151b0:	2049      	movs	r0, #73	; 0x49
  1151b2:	f001 f8c5 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x24,0x70);
  1151b6:	2170      	movs	r1, #112	; 0x70
  1151b8:	2024      	movs	r0, #36	; 0x24
  1151ba:	f001 f8c1 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x25,0x80);
  1151be:	2180      	movs	r1, #128	; 0x80
  1151c0:	2025      	movs	r0, #37	; 0x25
  1151c2:	f001 f8bd 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x2a,0x10);
  1151c6:	2110      	movs	r1, #16
  1151c8:	202a      	movs	r0, #42	; 0x2a
  1151ca:	f001 f8b9 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x2b,0x80);
  1151ce:	2180      	movs	r1, #128	; 0x80
  1151d0:	202b      	movs	r0, #43	; 0x2b
  1151d2:	f001 f8b5 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x23,0x28);  //
  1151d6:	2128      	movs	r1, #40	; 0x28
  1151d8:	2023      	movs	r0, #35	; 0x23
  1151da:	f001 f8b1 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x4a,0x10);
  1151de:	2110      	movs	r1, #16
  1151e0:	204a      	movs	r0, #74	; 0x4a
  1151e2:	f001 f8ad 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x1d,0xf3);  //
  1151e6:	21f3      	movs	r1, #243	; 0xf3
  1151e8:	201d      	movs	r0, #29
  1151ea:	f001 f8a9 	bl	116340 <HDMI_WriteI2C_Byte>
        break;
  1151ee:	e7ad      	b.n	11514c <LT9611_MIPI_Pcr+0xb0>

001151f0 <LT9611_PLL>:
{
  1151f0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    pclk = video_format->pclk_khz;
  1151f2:	69c4      	ldr	r4, [r0, #28]
    HDMI_WriteI2C_Byte(0xff,0x81);
  1151f4:	2181      	movs	r1, #129	; 0x81
  1151f6:	20ff      	movs	r0, #255	; 0xff
  1151f8:	f001 f8a2 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x23,0x40); //Enable LDO and disable PD
  1151fc:	2140      	movs	r1, #64	; 0x40
  1151fe:	2023      	movs	r0, #35	; 0x23
  115200:	f001 f89e 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x24,0x62); //0x62, LG25UM58 issue, 20180824
  115204:	2162      	movs	r1, #98	; 0x62
  115206:	2024      	movs	r0, #36	; 0x24
  115208:	f001 f89a 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x25,0x80); //pre-divider
  11520c:	2180      	movs	r1, #128	; 0x80
  11520e:	2025      	movs	r0, #37	; 0x25
  115210:	f001 f896 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x26,0x55);
  115214:	2155      	movs	r1, #85	; 0x55
  115216:	2026      	movs	r0, #38	; 0x26
  115218:	f001 f892 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x2c,0x37);
  11521c:	2137      	movs	r1, #55	; 0x37
  11521e:	202c      	movs	r0, #44	; 0x2c
  115220:	f001 f88e 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x2f,0x01);
  115224:	2101      	movs	r1, #1
  115226:	202f      	movs	r0, #47	; 0x2f
  115228:	f001 f88a 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x27,0x66);
  11522c:	2166      	movs	r1, #102	; 0x66
  11522e:	2027      	movs	r0, #39	; 0x27
  115230:	f001 f886 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x28,0x88);
  115234:	2188      	movs	r1, #136	; 0x88
  115236:	2028      	movs	r0, #40	; 0x28
  115238:	f001 f882 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x2a,0x20); //for U3.
  11523c:	2120      	movs	r1, #32
  11523e:	202a      	movs	r0, #42	; 0x2a
  115240:	f001 f87e 	bl	116340 <HDMI_WriteI2C_Byte>
    if(pclk > 150000)
  115244:	f644 13f0 	movw	r3, #18928	; 0x49f0
  115248:	f2c0 0302 	movt	r3, #2
  11524c:	429c      	cmp	r4, r3
  11524e:	f200 80b4 	bhi.w	1153ba <LT9611_PLL+0x1ca>
    else if(pclk > 80000)
  115252:	f44f 5362 	mov.w	r3, #14464	; 0x3880
  115256:	f2c0 0301 	movt	r3, #1
  11525a:	429c      	cmp	r4, r3
  11525c:	f200 80a7 	bhi.w	1153ae <LT9611_PLL+0x1be>
          HDMI_WriteI2C_Byte(0x2d,0xaa); //0xaa
  115260:	21aa      	movs	r1, #170	; 0xaa
  115262:	202d      	movs	r0, #45	; 0x2d
  115264:	f001 f86c 	bl	116340 <HDMI_WriteI2C_Byte>
  115268:	2304      	movs	r3, #4
        pcr_m = (u8)((pclk*5*hdmi_post_div)/27000);
  11526a:	f640 52cf 	movw	r2, #3535	; 0xdcf
  11526e:	eb04 0184 	add.w	r1, r4, r4, lsl #2
        pcr_m --;
  115272:	f243 276a 	movw	r7, #12906	; 0x326a
        pcr_m = (u8)((pclk*5*hdmi_post_div)/27000);
  115276:	f2c2 62d6 	movt	r2, #9942	; 0x26d6
  11527a:	fb03 f301 	mul.w	r3, r3, r1
        HDMI_WriteI2C_Byte(0xff,0x83);
  11527e:	20ff      	movs	r0, #255	; 0xff
        pcr_m --;
  115280:	f2c0 0713 	movt	r7, #19
        HDMI_WriteI2C_Byte(0xff,0x83);
  115284:	2183      	movs	r1, #131	; 0x83
        pclk = pclk / 2;
  115286:	0866      	lsrs	r6, r4, #1
        HDMI_WriteI2C_Byte(0x16,0xf3); /*start calibration*/
  115288:	2506      	movs	r5, #6
        pcr_m = (u8)((pclk*5*hdmi_post_div)/27000);
  11528a:	08db      	lsrs	r3, r3, #3
        pclk = pclk % 65536;
  11528c:	b2b6      	uxth	r6, r6
        pcr_m = (u8)((pclk*5*hdmi_post_div)/27000);
  11528e:	fba2 2303 	umull	r2, r3, r2, r3
  115292:	0a5b      	lsrs	r3, r3, #9
        pcr_m --;
  115294:	3b01      	subs	r3, #1
  115296:	703b      	strb	r3, [r7, #0]
        HDMI_WriteI2C_Byte(0xff,0x83);
  115298:	f001 f852 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x2d,0x40); //M up limit
  11529c:	2140      	movs	r1, #64	; 0x40
  11529e:	202d      	movs	r0, #45	; 0x2d
  1152a0:	f001 f84e 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x31,0x08); //M down limit
  1152a4:	2108      	movs	r1, #8
  1152a6:	2031      	movs	r0, #49	; 0x31
  1152a8:	f001 f84a 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x26,0x80|pcr_m); /* fixed M is to let pll locked*/
  1152ac:	7839      	ldrb	r1, [r7, #0]
  1152ae:	2026      	movs	r0, #38	; 0x26
  1152b0:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  1152b4:	f001 f844 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x82);     //13.5M
  1152b8:	2182      	movs	r1, #130	; 0x82
  1152ba:	20ff      	movs	r0, #255	; 0xff
  1152bc:	f001 f840 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xe3,pclk/65536);
  1152c0:	20e3      	movs	r0, #227	; 0xe3
  1152c2:	f3c4 4147 	ubfx	r1, r4, #17, #8
  1152c6:	f001 f83b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xe4,pclk/256);
  1152ca:	20e4      	movs	r0, #228	; 0xe4
  1152cc:	0a31      	lsrs	r1, r6, #8
  1152ce:	f001 f837 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xe5,pclk%256);
  1152d2:	20e5      	movs	r0, #229	; 0xe5
  1152d4:	b2f1      	uxtb	r1, r6
  1152d6:	f001 f833 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xde,0x20); // pll cal en, start calibration
  1152da:	2120      	movs	r1, #32
  1152dc:	20de      	movs	r0, #222	; 0xde
  1152de:	f001 f82f 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xde,0xe0);
  1152e2:	21e0      	movs	r1, #224	; 0xe0
  1152e4:	20de      	movs	r0, #222	; 0xde
  1152e6:	f001 f82b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x80);
  1152ea:	2180      	movs	r1, #128	; 0x80
  1152ec:	20ff      	movs	r0, #255	; 0xff
  1152ee:	f001 f827 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0x5a); /* Pcr clk reset */
  1152f2:	215a      	movs	r1, #90	; 0x5a
  1152f4:	2011      	movs	r0, #17
  1152f6:	f001 f823 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x11,0xfa);
  1152fa:	21fa      	movs	r1, #250	; 0xfa
  1152fc:	2011      	movs	r0, #17
  1152fe:	f001 f81f 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x16,0xf2); /* pll cal digital reset */
  115302:	21f2      	movs	r1, #242	; 0xf2
  115304:	2016      	movs	r0, #22
  115306:	f001 f81b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x18,0xdc); /* pll analog reset */
  11530a:	21dc      	movs	r1, #220	; 0xdc
  11530c:	2018      	movs	r0, #24
  11530e:	f001 f817 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x18,0xfc);
  115312:	21fc      	movs	r1, #252	; 0xfc
  115314:	2018      	movs	r0, #24
  115316:	f001 f813 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x16,0xf3); /*start calibration*/
  11531a:	21f3      	movs	r1, #243	; 0xf3
  11531c:	2016      	movs	r0, #22
  11531e:	f001 f80f 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x80);
  115322:	2180      	movs	r1, #128	; 0x80
  115324:	20ff      	movs	r0, #255	; 0xff
  115326:	f001 f80b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x16,0xe3); /* pll lock logic reset */
  11532a:	21e3      	movs	r1, #227	; 0xe3
  11532c:	2016      	movs	r0, #22
  11532e:	f001 f807 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x16,0xf3);
  115332:	21f3      	movs	r1, #243	; 0xf3
  115334:	2016      	movs	r0, #22
  115336:	f001 f803 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x82);
  11533a:	2182      	movs	r1, #130	; 0x82
  11533c:	20ff      	movs	r0, #255	; 0xff
  11533e:	f000 ffff 	bl	116340 <HDMI_WriteI2C_Byte>
        cal_done_flag = HDMI_ReadI2C_Byte(0xe7);
  115342:	20e7      	movs	r0, #231	; 0xe7
  115344:	f000 ffca 	bl	1162dc <HDMI_ReadI2C_Byte>
  115348:	4604      	mov	r4, r0
        band_out = HDMI_ReadI2C_Byte(0xe6);
  11534a:	20e6      	movs	r0, #230	; 0xe6
  11534c:	f000 ffc6 	bl	1162dc <HDMI_ReadI2C_Byte>
        if((pll_lock_flag & 0x80)&&(cal_done_flag & 0x80)&&(band_out != 0xff))
  115350:	f3c4 14c0 	ubfx	r4, r4, #7, #1
        band_out = HDMI_ReadI2C_Byte(0xe6);
  115354:	4606      	mov	r6, r0
        pll_lock_flag = HDMI_ReadI2C_Byte(0x15);
  115356:	2015      	movs	r0, #21
  115358:	f000 ffc0 	bl	1162dc <HDMI_ReadI2C_Byte>
            HDMI_WriteI2C_Byte(0xff,0x80);
  11535c:	2180      	movs	r1, #128	; 0x80
        if((pll_lock_flag & 0x80)&&(cal_done_flag & 0x80)&&(band_out != 0xff))
  11535e:	ea04 14d0 	and.w	r4, r4, r0, lsr #7
            HDMI_WriteI2C_Byte(0xff,0x80);
  115362:	20ff      	movs	r0, #255	; 0xff
        if((pll_lock_flag & 0x80)&&(cal_done_flag & 0x80)&&(band_out != 0xff))
  115364:	4286      	cmp	r6, r0
  115366:	bf0c      	ite	eq
  115368:	2400      	moveq	r4, #0
  11536a:	f004 0401 	andne.w	r4, r4, #1
  11536e:	b9ec      	cbnz	r4, 1153ac <LT9611_PLL+0x1bc>
            HDMI_WriteI2C_Byte(0xff,0x80);
  115370:	f000 ffe6 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x11,0x5a); /* Pcr clk reset */
  115374:	215a      	movs	r1, #90	; 0x5a
  115376:	2011      	movs	r0, #17
  115378:	f000 ffe2 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x11,0xfa);
  11537c:	21fa      	movs	r1, #250	; 0xfa
  11537e:	2011      	movs	r0, #17
  115380:	f000 ffde 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x16,0xf2); /* pll cal digital reset */
  115384:	21f2      	movs	r1, #242	; 0xf2
  115386:	2016      	movs	r0, #22
  115388:	f000 ffda 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x18,0xdc); /* pll analog reset */
  11538c:	21dc      	movs	r1, #220	; 0xdc
  11538e:	2018      	movs	r0, #24
  115390:	f000 ffd6 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x18,0xfc);
  115394:	21fc      	movs	r1, #252	; 0xfc
  115396:	2018      	movs	r0, #24
  115398:	f000 ffd2 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x16,0xf3); /*start calibration*/
  11539c:	21f3      	movs	r1, #243	; 0xf3
  11539e:	2016      	movs	r0, #22
  1153a0:	f000 ffce 	bl	116340 <HDMI_WriteI2C_Byte>
  1153a4:	1e6b      	subs	r3, r5, #1
    for(i = 0; i < 6 ; i++)
  1153a6:	f013 05ff 	ands.w	r5, r3, #255	; 0xff
  1153aa:	d1ba      	bne.n	115322 <LT9611_PLL+0x132>
}
  1153ac:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            HDMI_WriteI2C_Byte(0x2d,0x99);
  1153ae:	2199      	movs	r1, #153	; 0x99
  1153b0:	202d      	movs	r0, #45	; 0x2d
  1153b2:	f000 ffc5 	bl	116340 <HDMI_WriteI2C_Byte>
  1153b6:	2302      	movs	r3, #2
  1153b8:	e757      	b.n	11526a <LT9611_PLL+0x7a>
        HDMI_WriteI2C_Byte(0x2d,0x88);
  1153ba:	2188      	movs	r1, #136	; 0x88
  1153bc:	202d      	movs	r0, #45	; 0x2d
  1153be:	f000 ffbf 	bl	116340 <HDMI_WriteI2C_Byte>
  1153c2:	2301      	movs	r3, #1
  1153c4:	e751      	b.n	11526a <LT9611_PLL+0x7a>
  1153c6:	bf00      	nop

001153c8 <LT9611_HDMI_TX_Phy>:
{
  1153c8:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x81);
  1153ca:	2181      	movs	r1, #129	; 0x81
  1153cc:	20ff      	movs	r0, #255	; 0xff
  1153ce:	f000 ffb7 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x30,0x6a);
  1153d2:	216a      	movs	r1, #106	; 0x6a
  1153d4:	2030      	movs	r0, #48	; 0x30
  1153d6:	f000 ffb3 	bl	116340 <HDMI_WriteI2C_Byte>
    if(lt9611.hdmi_coupling_mode==ac_mode)
  1153da:	f64c 03bc 	movw	r3, #51388	; 0xc8bc
  1153de:	f2c0 0312 	movt	r3, #18
  1153e2:	795b      	ldrb	r3, [r3, #5]
  1153e4:	b3ab      	cbz	r3, 115452 <LT9611_HDMI_TX_Phy+0x8a>
        HDMI_WriteI2C_Byte(0x31,0x44);
  1153e6:	2144      	movs	r1, #68	; 0x44
  1153e8:	2031      	movs	r0, #49	; 0x31
  1153ea:	f000 ffa9 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x32,0x4a);
  1153ee:	214a      	movs	r1, #74	; 0x4a
  1153f0:	2032      	movs	r0, #50	; 0x32
  1153f2:	f000 ffa5 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x33,0x0b);
  1153f6:	210b      	movs	r1, #11
  1153f8:	2033      	movs	r0, #51	; 0x33
  1153fa:	f000 ffa1 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x34,0x00);
  1153fe:	2100      	movs	r1, #0
  115400:	2034      	movs	r0, #52	; 0x34
  115402:	f000 ff9d 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x35,0x00);
  115406:	2100      	movs	r1, #0
  115408:	2035      	movs	r0, #53	; 0x35
  11540a:	f000 ff99 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x36,0x00);
  11540e:	2100      	movs	r1, #0
  115410:	2036      	movs	r0, #54	; 0x36
  115412:	f000 ff95 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x37,0x44);
  115416:	2144      	movs	r1, #68	; 0x44
  115418:	2037      	movs	r0, #55	; 0x37
  11541a:	f000 ff91 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x3f,0x0f);
  11541e:	210f      	movs	r1, #15
  115420:	203f      	movs	r0, #63	; 0x3f
  115422:	f000 ff8d 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x40,0x98); //clk swing
  115426:	2198      	movs	r1, #152	; 0x98
  115428:	2040      	movs	r0, #64	; 0x40
  11542a:	f000 ff89 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x41,0x98); //D0 swing
  11542e:	2198      	movs	r1, #152	; 0x98
  115430:	2041      	movs	r0, #65	; 0x41
  115432:	f000 ff85 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x42,0x98); //D1 swing
  115436:	2198      	movs	r1, #152	; 0x98
  115438:	2042      	movs	r0, #66	; 0x42
  11543a:	f000 ff81 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x43,0x98); //D2 swing
  11543e:	2198      	movs	r1, #152	; 0x98
  115440:	2043      	movs	r0, #67	; 0x43
  115442:	f000 ff7d 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x44,0x0a);
  115446:	210a      	movs	r1, #10
  115448:	2044      	movs	r0, #68	; 0x44
}
  11544a:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        HDMI_WriteI2C_Byte(0x44,0x0a);
  11544e:	f000 bf77 	b.w	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x31,0x73); //DC: 0x44, AC:0x73
  115452:	2173      	movs	r1, #115	; 0x73
  115454:	2031      	movs	r0, #49	; 0x31
  115456:	f000 ff73 	bl	116340 <HDMI_WriteI2C_Byte>
  11545a:	e7c8      	b.n	1153ee <LT9611_HDMI_TX_Phy+0x26>

0011545c <LT9611_HDCP_Init>:
{
  11545c:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x85);
  11545e:	2185      	movs	r1, #133	; 0x85
  115460:	20ff      	movs	r0, #255	; 0xff
  115462:	f000 ff6d 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x07,0x1f);
  115466:	211f      	movs	r1, #31
  115468:	2007      	movs	r0, #7
  11546a:	f000 ff69 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x13,0xfe);// [7]=force_hpd, [6]=force_rsen, [5]=vsync_pol, [4]=hsync_pol,
  11546e:	21fe      	movs	r1, #254	; 0xfe
  115470:	2013      	movs	r0, #19
  115472:	f000 ff65 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x17,0x0f);// [7]=ri_short_read, [3]=sync_pol_mode, [2]=srm_chk_done,
  115476:	210f      	movs	r1, #15
  115478:	2017      	movs	r0, #23
  11547a:	f000 ff61 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0x05);
  11547e:	2105      	movs	r1, #5
  115480:	2015      	movs	r0, #21
}
  115482:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x15,0x05);
  115486:	f000 bf5b 	b.w	116340 <HDMI_WriteI2C_Byte>
  11548a:	bf00      	nop

0011548c <LT9611_HDCP_Enable>:
{
  11548c:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x80);
  11548e:	2180      	movs	r1, #128	; 0x80
  115490:	20ff      	movs	r0, #255	; 0xff
  115492:	f000 ff55 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x14,0x7f);
  115496:	217f      	movs	r1, #127	; 0x7f
  115498:	2014      	movs	r0, #20
  11549a:	f000 ff51 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x14,0xff);
  11549e:	21ff      	movs	r1, #255	; 0xff
  1154a0:	2014      	movs	r0, #20
  1154a2:	f000 ff4d 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x85);
  1154a6:	2185      	movs	r1, #133	; 0x85
  1154a8:	20ff      	movs	r0, #255	; 0xff
  1154aa:	f000 ff49 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0x01); //disable HDCP
  1154ae:	2101      	movs	r1, #1
  1154b0:	2015      	movs	r0, #21
  1154b2:	f000 ff45 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0x71); //enable HDCP
  1154b6:	2171      	movs	r1, #113	; 0x71
  1154b8:	2015      	movs	r0, #21
  1154ba:	f000 ff41 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0x65); //enable HDCP
  1154be:	2165      	movs	r1, #101	; 0x65
  1154c0:	2015      	movs	r0, #21
}
  1154c2:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x15,0x65); //enable HDCP
  1154c6:	f000 bf3b 	b.w	116340 <HDMI_WriteI2C_Byte>
  1154ca:	bf00      	nop

001154cc <LT9611_HDCP_Disable>:
{
  1154cc:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x85);
  1154ce:	2185      	movs	r1, #133	; 0x85
  1154d0:	20ff      	movs	r0, #255	; 0xff
  1154d2:	f000 ff35 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15,0x45); //enable HDCP
  1154d6:	2145      	movs	r1, #69	; 0x45
  1154d8:	2015      	movs	r0, #21
}
  1154da:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x15,0x45); //enable HDCP
  1154de:	f000 bf2f 	b.w	116340 <HDMI_WriteI2C_Byte>
  1154e2:	bf00      	nop

001154e4 <LT9611_HDMI_Out_Enable>:
{
  1154e4:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x81);
  1154e6:	2181      	movs	r1, #129	; 0x81
  1154e8:	20ff      	movs	r0, #255	; 0xff
  1154ea:	f000 ff29 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x23,0x40);
  1154ee:	2140      	movs	r1, #64	; 0x40
  1154f0:	2023      	movs	r0, #35	; 0x23
  1154f2:	f000 ff25 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x82);
  1154f6:	2182      	movs	r1, #130	; 0x82
  1154f8:	20ff      	movs	r0, #255	; 0xff
  1154fa:	f000 ff21 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xde,0x20);
  1154fe:	2120      	movs	r1, #32
  115500:	20de      	movs	r0, #222	; 0xde
  115502:	f000 ff1d 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xde,0xe0);
  115506:	21e0      	movs	r1, #224	; 0xe0
  115508:	20de      	movs	r0, #222	; 0xde
  11550a:	f000 ff19 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x80);
  11550e:	2180      	movs	r1, #128	; 0x80
  115510:	20ff      	movs	r0, #255	; 0xff
  115512:	f000 ff15 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x18,0xdc); /* txpll sw rst */
  115516:	21dc      	movs	r1, #220	; 0xdc
  115518:	2018      	movs	r0, #24
  11551a:	f000 ff11 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x18,0xfc);
  11551e:	21fc      	movs	r1, #252	; 0xfc
  115520:	2018      	movs	r0, #24
  115522:	f000 ff0d 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x16,0xf1); /* txpll calibration rest */
  115526:	21f1      	movs	r1, #241	; 0xf1
  115528:	2016      	movs	r0, #22
  11552a:	f000 ff09 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x16,0xf3);
  11552e:	21f3      	movs	r1, #243	; 0xf3
  115530:	2016      	movs	r0, #22
  115532:	f000 ff05 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x11,0x5a); //Pcr reset
  115536:	215a      	movs	r1, #90	; 0x5a
  115538:	2011      	movs	r0, #17
  11553a:	f000 ff01 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x11,0xfa);
  11553e:	21fa      	movs	r1, #250	; 0xfa
  115540:	2011      	movs	r0, #17
  115542:	f000 fefd 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xff,0x81);
  115546:	2181      	movs	r1, #129	; 0x81
  115548:	20ff      	movs	r0, #255	; 0xff
  11554a:	f000 fef9 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x30,0xea);
  11554e:	21ea      	movs	r1, #234	; 0xea
  115550:	2030      	movs	r0, #48	; 0x30
  115552:	f000 fef5 	bl	116340 <HDMI_WriteI2C_Byte>
    if(lt9611.hdcp_encryption == hdcp_enable)
  115556:	f64c 03bc 	movw	r3, #51388	; 0xc8bc
  11555a:	f2c0 0312 	movt	r3, #18
  11555e:	799b      	ldrb	r3, [r3, #6]
  115560:	b91b      	cbnz	r3, 11556a <LT9611_HDMI_Out_Enable+0x86>
}
  115562:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        LT9611_HDCP_Disable();
  115566:	f7ff bfb1 	b.w	1154cc <LT9611_HDCP_Disable>
}
  11556a:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        LT9611_HDCP_Enable();
  11556e:	f7ff bf8d 	b.w	11548c <LT9611_HDCP_Enable>
  115572:	bf00      	nop

00115574 <LT9611_HDMI_Out_Disable>:
{
  115574:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x81);
  115576:	2181      	movs	r1, #129	; 0x81
  115578:	20ff      	movs	r0, #255	; 0xff
  11557a:	f000 fee1 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x30,0x00); /* Txphy PD */
  11557e:	2100      	movs	r1, #0
  115580:	2030      	movs	r0, #48	; 0x30
  115582:	f000 fedd 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x23,0x80); /* Txpll PD */
  115586:	2180      	movs	r1, #128	; 0x80
  115588:	2023      	movs	r0, #35	; 0x23
  11558a:	f000 fed9 	bl	116340 <HDMI_WriteI2C_Byte>
}
  11558e:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    LT9611_HDCP_Disable();
  115592:	f7ff bf9b 	b.w	1154cc <LT9611_HDCP_Disable>
  115596:	bf00      	nop

00115598 <LT9611_HDMI_TX_Digital>:
{
  115598:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
        pb2 =  (AR<<4) + 0x08;
  11559a:	7e04      	ldrb	r4, [r0, #24]
        u8 VIC = video_format->vic;
  11559c:	7d86      	ldrb	r6, [r0, #22]
        pb2 =  (AR<<4) + 0x08;
  11559e:	0124      	lsls	r4, r4, #4
        HDMI_WriteI2C_Byte(0xff,0x82);
  1155a0:	2182      	movs	r1, #130	; 0x82
    pb0 = ((pb2 + pb4) <= 0x5f)?(0x5f - pb2 - pb4):(0x15f - pb2 - pb4);
  1155a2:	f5c6 73ab 	rsb	r3, r6, #342	; 0x156
        pb2 =  (AR<<4) + 0x08;
  1155a6:	b2e4      	uxtb	r4, r4
    pb0 = ((pb2 + pb4) <= 0x5f)?(0x5f - pb2 - pb4):(0x15f - pb2 - pb4);
  1155a8:	3301      	adds	r3, #1
  1155aa:	1b1b      	subs	r3, r3, r4
        HDMI_WriteI2C_Byte(0xff,0x82);
  1155ac:	20ff      	movs	r0, #255	; 0xff
        pb2 =  (AR<<4) + 0x08;
  1155ae:	f104 0708 	add.w	r7, r4, #8
        if(lt9611.hdmi_mode == HDMI)
  1155b2:	f64c 05bc 	movw	r5, #51388	; 0xc8bc
    pb0 = ((pb2 + pb4) <= 0x5f)?(0x5f - pb2 - pb4):(0x15f - pb2 - pb4);
  1155b6:	b2dc      	uxtb	r4, r3
        if(lt9611.hdmi_mode == HDMI)
  1155b8:	f2c0 0512 	movt	r5, #18
        HDMI_WriteI2C_Byte(0xff,0x82);
  1155bc:	f000 fec0 	bl	116340 <HDMI_WriteI2C_Byte>
        pb2 =  (AR<<4) + 0x08;
  1155c0:	b2ff      	uxtb	r7, r7
        if(lt9611.hdmi_mode == HDMI)
  1155c2:	79eb      	ldrb	r3, [r5, #7]
  1155c4:	2b00      	cmp	r3, #0
  1155c6:	d05a      	beq.n	11567e <LT9611_HDMI_TX_Digital+0xe6>
                HDMI_WriteI2C_Byte(0xd6,0x8e); //sync polarity
  1155c8:	218e      	movs	r1, #142	; 0x8e
  1155ca:	20d6      	movs	r0, #214	; 0xd6
  1155cc:	f000 feb8 	bl	116340 <HDMI_WriteI2C_Byte>
        if(lt9611.audio_out==audio_i2s)
  1155d0:	792b      	ldrb	r3, [r5, #4]
  1155d2:	2b00      	cmp	r3, #0
  1155d4:	d05a      	beq.n	11568c <LT9611_HDMI_TX_Digital+0xf4>
            HDMI_WriteI2C_Byte(0xd7,0x80);
  1155d6:	2180      	movs	r1, #128	; 0x80
  1155d8:	20d7      	movs	r0, #215	; 0xd7
  1155da:	f000 feb1 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x84);
  1155de:	2184      	movs	r1, #132	; 0x84
  1155e0:	20ff      	movs	r0, #255	; 0xff
  1155e2:	f000 fead 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x43,pb0);   //AVI_PB0
  1155e6:	4621      	mov	r1, r4
  1155e8:	2043      	movs	r0, #67	; 0x43
  1155ea:	f000 fea9 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x45,pb2);  //AVI_PB2
  1155ee:	4639      	mov	r1, r7
  1155f0:	2045      	movs	r0, #69	; 0x45
  1155f2:	f000 fea5 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x47,pb4);   //AVI_PB4
  1155f6:	4631      	mov	r1, r6
  1155f8:	2047      	movs	r0, #71	; 0x47
  1155fa:	f000 fea1 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x84);
  1155fe:	2184      	movs	r1, #132	; 0x84
  115600:	20ff      	movs	r0, #255	; 0xff
  115602:	f000 fe9d 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x10,0x02); //data iland
  115606:	2102      	movs	r1, #2
  115608:	2010      	movs	r0, #16
  11560a:	f000 fe99 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x12,0x64); //act_h_blank
  11560e:	2164      	movs	r1, #100	; 0x64
  115610:	2012      	movs	r0, #18
  115612:	f000 fe95 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xff,0x84);
  115616:	2184      	movs	r1, #132	; 0x84
  115618:	20ff      	movs	r0, #255	; 0xff
        if(VIC == 95)
  11561a:	2e5f      	cmp	r6, #95	; 0x5f
  11561c:	d03e      	beq.n	11569c <LT9611_HDMI_TX_Digital+0x104>
           HDMI_WriteI2C_Byte(0xff,0x84);
  11561e:	f000 fe8f 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x3d,infoFrame_en); //UD1 infoframe enable
  115622:	210e      	movs	r1, #14
  115624:	203d      	movs	r0, #61	; 0x3d
  115626:	f000 fe8b 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xff,0x84);
  11562a:	2184      	movs	r1, #132	; 0x84
  11562c:	20ff      	movs	r0, #255	; 0xff
  11562e:	f000 fe87 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc0,0x83);  //HB0
  115632:	2183      	movs	r1, #131	; 0x83
  115634:	20c0      	movs	r0, #192	; 0xc0
  115636:	f000 fe83 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc1,0x01);  //HB1
  11563a:	2101      	movs	r1, #1
  11563c:	20c1      	movs	r0, #193	; 0xc1
  11563e:	f000 fe7f 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc2,0x19);  //HB2
  115642:	2119      	movs	r1, #25
  115644:	20c2      	movs	r0, #194	; 0xc2
  115646:	f000 fe7b 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc3,0x00);  //PB0
  11564a:	2100      	movs	r1, #0
  11564c:	20c3      	movs	r0, #195	; 0xc3
  11564e:	f000 fe77 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc4,0x01);  //PB1
  115652:	2101      	movs	r1, #1
  115654:	20c4      	movs	r0, #196	; 0xc4
  115656:	f000 fe73 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc5,0x02);  //PB2
  11565a:	2102      	movs	r1, #2
  11565c:	20c5      	movs	r0, #197	; 0xc5
  11565e:	f000 fe6f 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc6,0x03);  //PB3
  115662:	2103      	movs	r1, #3
  115664:	20c6      	movs	r0, #198	; 0xc6
  115666:	f000 fe6b 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc7,0x04);  //PB4
  11566a:	2104      	movs	r1, #4
  11566c:	20c7      	movs	r0, #199	; 0xc7
  11566e:	f000 fe67 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0xc8,0x00);  //PB5
  115672:	2100      	movs	r1, #0
  115674:	20c8      	movs	r0, #200	; 0xc8
}
  115676:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
           HDMI_WriteI2C_Byte(0xc8,0x00);  //PB5
  11567a:	f000 be61 	b.w	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0xd6,0x0e); //sync polarity
  11567e:	210e      	movs	r1, #14
  115680:	20d6      	movs	r0, #214	; 0xd6
  115682:	f000 fe5d 	bl	116340 <HDMI_WriteI2C_Byte>
        if(lt9611.audio_out==audio_i2s)
  115686:	792b      	ldrb	r3, [r5, #4]
  115688:	2b00      	cmp	r3, #0
  11568a:	d1a4      	bne.n	1155d6 <LT9611_HDMI_TX_Digital+0x3e>
            HDMI_WriteI2C_Byte(0xd7,0x04);
  11568c:	2104      	movs	r1, #4
  11568e:	20d7      	movs	r0, #215	; 0xd7
  115690:	f000 fe56 	bl	116340 <HDMI_WriteI2C_Byte>
        if(lt9611.audio_out==audio_spdif)
  115694:	792b      	ldrb	r3, [r5, #4]
  115696:	2b00      	cmp	r3, #0
  115698:	d0a1      	beq.n	1155de <LT9611_HDMI_TX_Digital+0x46>
  11569a:	e79c      	b.n	1155d6 <LT9611_HDMI_TX_Digital+0x3e>
           HDMI_WriteI2C_Byte(0xff,0x84);
  11569c:	f000 fe50 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x3d,infoFrame_en|UD0_PKT_EN); //UD1 infoframe enable //revise on 20200715
  1156a0:	212e      	movs	r1, #46	; 0x2e
  1156a2:	203d      	movs	r0, #61	; 0x3d
  1156a4:	f000 fe4c 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x74,0x81);  //HB0
  1156a8:	2181      	movs	r1, #129	; 0x81
  1156aa:	2074      	movs	r0, #116	; 0x74
  1156ac:	f000 fe48 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x75,0x01);  //HB1
  1156b0:	2101      	movs	r1, #1
  1156b2:	2075      	movs	r0, #117	; 0x75
  1156b4:	f000 fe44 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x76,0x05);  //HB2
  1156b8:	2105      	movs	r1, #5
  1156ba:	2076      	movs	r0, #118	; 0x76
  1156bc:	f000 fe40 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x77,0x49);  //PB0
  1156c0:	2149      	movs	r1, #73	; 0x49
  1156c2:	2077      	movs	r0, #119	; 0x77
  1156c4:	f000 fe3c 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x78,0x03);  //PB1
  1156c8:	2103      	movs	r1, #3
  1156ca:	2078      	movs	r0, #120	; 0x78
  1156cc:	f000 fe38 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x79,0x0c);  //PB2
  1156d0:	210c      	movs	r1, #12
  1156d2:	2079      	movs	r0, #121	; 0x79
  1156d4:	f000 fe34 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x7a,0x00);  //PB3
  1156d8:	2100      	movs	r1, #0
  1156da:	207a      	movs	r0, #122	; 0x7a
  1156dc:	f000 fe30 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x7b,0x20);  //PB4
  1156e0:	2120      	movs	r1, #32
  1156e2:	207b      	movs	r0, #123	; 0x7b
  1156e4:	f000 fe2c 	bl	116340 <HDMI_WriteI2C_Byte>
           HDMI_WriteI2C_Byte(0x7c,0x01);  //PB5
  1156e8:	2101      	movs	r1, #1
  1156ea:	207c      	movs	r0, #124	; 0x7c
  1156ec:	f000 fe28 	bl	116340 <HDMI_WriteI2C_Byte>
  1156f0:	e79b      	b.n	11562a <LT9611_HDMI_TX_Digital+0x92>
  1156f2:	bf00      	nop

001156f4 <LT9611_Audio_Init>:
{
  1156f4:	b538      	push	{r3, r4, r5, r14}
    if(lt9611.audio_out==audio_i2s)
  1156f6:	f64c 04bc 	movw	r4, #51388	; 0xc8bc
  1156fa:	f2c0 0412 	movt	r4, #18
  1156fe:	7925      	ldrb	r5, [r4, #4]
  115700:	b18d      	cbz	r5, 115726 <LT9611_Audio_Init+0x32>
        HDMI_WriteI2C_Byte(0xff,0x84);
  115702:	2184      	movs	r1, #132	; 0x84
  115704:	20ff      	movs	r0, #255	; 0xff
  115706:	f000 fe1b 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x06,0x0c);
  11570a:	210c      	movs	r1, #12
  11570c:	2006      	movs	r0, #6
  11570e:	f000 fe17 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x07,0x10);
  115712:	2110      	movs	r1, #16
  115714:	2007      	movs	r0, #7
  115716:	f000 fe13 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x34,0xd4); //CTS_N
  11571a:	21d4      	movs	r1, #212	; 0xd4
  11571c:	2034      	movs	r0, #52	; 0x34
}
  11571e:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
        HDMI_WriteI2C_Byte(0x34,0xd4); //CTS_N
  115722:	f000 be0d 	b.w	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xff,0x84);
  115726:	2184      	movs	r1, #132	; 0x84
  115728:	20ff      	movs	r0, #255	; 0xff
  11572a:	f000 fe09 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x06,0x08);
  11572e:	2108      	movs	r1, #8
  115730:	2006      	movs	r0, #6
  115732:	f000 fe05 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x07,0x10);
  115736:	2110      	movs	r1, #16
  115738:	2007      	movs	r0, #7
  11573a:	f000 fe01 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x0f,0x2b); //0x2b: 48K, 0xab:96K
  11573e:	212b      	movs	r1, #43	; 0x2b
  115740:	200f      	movs	r0, #15
  115742:	f000 fdfd 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x34,0xd4); //CTS_N 20180823 0xd5: sclk = 32fs, 0xd4: sclk = 64fs
  115746:	21d4      	movs	r1, #212	; 0xd4
  115748:	2034      	movs	r0, #52	; 0x34
  11574a:	f000 fdf9 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x35,0x00); // N value = 6144
  11574e:	4629      	mov	r1, r5
  115750:	2035      	movs	r0, #53	; 0x35
  115752:	f000 fdf5 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x36,0x18);
  115756:	2118      	movs	r1, #24
  115758:	2036      	movs	r0, #54	; 0x36
  11575a:	f000 fdf1 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x37,0x00);
  11575e:	4629      	mov	r1, r5
  115760:	2037      	movs	r0, #55	; 0x37
  115762:	f000 fded 	bl	116340 <HDMI_WriteI2C_Byte>
    if(lt9611.audio_out==audio_spdif)
  115766:	7923      	ldrb	r3, [r4, #4]
  115768:	2b00      	cmp	r3, #0
  11576a:	d1ca      	bne.n	115702 <LT9611_Audio_Init+0xe>
}
  11576c:	bd38      	pop	{r3, r4, r5, r15}
  11576e:	bf00      	nop

00115770 <LT9611_Read_EDID>:
            memset(Sink_EDID,0,sizeof Sink_EDID);
  115770:	f243 1038 	movw	r0, #12600	; 0x3138
  115774:	f44f 7280 	mov.w	r2, #256	; 0x100
{
  115778:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
            memset(Sink_EDID,0,sizeof Sink_EDID);
  11577c:	2100      	movs	r1, #0
  11577e:	f2c0 0013 	movt	r0, #19
            HDMI_WriteI2C_Byte(0x14,0x7f);
  115782:	460e      	mov	r6, r1
            memset(Sink_EDID,0,sizeof Sink_EDID);
  115784:	f7fe e912 	blx	1139ac <memset>
            HDMI_WriteI2C_Byte(0xff,0x85);
  115788:	2185      	movs	r1, #133	; 0x85
  11578a:	20ff      	movs	r0, #255	; 0xff
  11578c:	f000 fdd8 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x03,0xc9);
  115790:	21c9      	movs	r1, #201	; 0xc9
  115792:	2003      	movs	r0, #3
                                Sink_EDID[i*32+j]= edid_data; // write edid data to Sink_EDID[];
  115794:	f243 1838 	movw	r8, #12600	; 0x3138
            HDMI_WriteI2C_Byte(0x03,0xc9);
  115798:	f000 fdd2 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x04,0xa0); //0xA0 is EDID device address
  11579c:	21a0      	movs	r1, #160	; 0xa0
  11579e:	2004      	movs	r0, #4
            HDMI_WriteI2C_Byte(0x14,0x7f);
  1157a0:	4637      	mov	r7, r6
            HDMI_WriteI2C_Byte(0x04,0xa0); //0xA0 is EDID device address
  1157a2:	f000 fdcd 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x05,0x00); //0x00 is EDID offset address
  1157a6:	4631      	mov	r1, r6
  1157a8:	2005      	movs	r0, #5
                                Sink_EDID[i*32+j]= edid_data; // write edid data to Sink_EDID[];
  1157aa:	f2c0 0813 	movt	r8, #19
            HDMI_WriteI2C_Byte(0x05,0x00); //0x00 is EDID offset address
  1157ae:	f000 fdc7 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x06,0x20); //length for read
  1157b2:	2120      	movs	r1, #32
  1157b4:	2006      	movs	r0, #6
            u8 extended_flag = 00;
  1157b6:	4635      	mov	r5, r6
            HDMI_WriteI2C_Byte(0x06,0x20); //length for read
  1157b8:	f000 fdc2 	bl	116340 <HDMI_WriteI2C_Byte>
            HDMI_WriteI2C_Byte(0x14,0x7f);
  1157bc:	217f      	movs	r1, #127	; 0x7f
  1157be:	2014      	movs	r0, #20
  1157c0:	f000 fdbe 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x05,i*32); //0x00 is EDID offset address
  1157c4:	2005      	movs	r0, #5
  1157c6:	b2f1      	uxtb	r1, r6
  1157c8:	f000 fdba 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x36);
  1157cc:	2136      	movs	r1, #54	; 0x36
  1157ce:	2007      	movs	r0, #7
  1157d0:	f000 fdb6 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x34); //0x31
  1157d4:	2134      	movs	r1, #52	; 0x34
  1157d6:	2007      	movs	r0, #7
  1157d8:	f000 fdb2 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x37); //0x37
  1157dc:	2137      	movs	r1, #55	; 0x37
  1157de:	2007      	movs	r0, #7
  1157e0:	f000 fdae 	bl	116340 <HDMI_WriteI2C_Byte>
                mdelay(5); // wait 5ms for reading edid data.
  1157e4:	f241 3088 	movw	r0, #5000	; 0x1388
  1157e8:	f7fd ffc6 	bl	113778 <spin>
                if(HDMI_ReadI2C_Byte(0x40)&0x02) //KEY_DDC_ACCS_DONE=1
  1157ec:	2040      	movs	r0, #64	; 0x40
  1157ee:	f000 fd75 	bl	1162dc <HDMI_ReadI2C_Byte>
  1157f2:	0782      	lsls	r2, r0, #30
  1157f4:	d56d      	bpl.n	1158d2 <LT9611_Read_EDID+0x162>
                    if(HDMI_ReadI2C_Byte(0x40)&0x50)//DDC No Ack or Abitration lost
  1157f6:	2040      	movs	r0, #64	; 0x40
  1157f8:	f000 fd70 	bl	1162dc <HDMI_ReadI2C_Byte>
  1157fc:	f010 0450 	ands.w	r4, r0, #80	; 0x50
  115800:	d167      	bne.n	1158d2 <LT9611_Read_EDID+0x162>
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  115802:	2083      	movs	r0, #131	; 0x83
                                if((i == 3)&&( j == 30))
  115804:	fa5f f987 	uxtb.w	r9, r7
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  115808:	f000 fd68 	bl	1162dc <HDMI_ReadI2C_Byte>
                                if((i == 3)&&( j == 30))
  11580c:	f1a9 0903 	sub.w	r9, r9, #3
  115810:	fab9 f989 	clz	r9, r9
  115814:	eb08 0a06 	add.w	r10, r8, r6
  115818:	ea4f 1959 	mov.w	r9, r9, lsr #5
                                Sink_EDID[i*32+j]= edid_data; // write edid data to Sink_EDID[];
  11581c:	f808 0006 	strb.w	r0, [r8, r6]
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  115820:	2083      	movs	r0, #131	; 0x83
                        for(j=0; j<32; j++)
  115822:	3401      	adds	r4, #1
  115824:	b2e4      	uxtb	r4, r4
  115826:	2c20      	cmp	r4, #32
  115828:	d011      	beq.n	11584e <LT9611_Read_EDID+0xde>
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  11582a:	f000 fd57 	bl	1162dc <HDMI_ReadI2C_Byte>
                                if((i == 3)&&( j == 30))
  11582e:	2c1e      	cmp	r4, #30
  115830:	bf14      	ite	ne
  115832:	2300      	movne	r3, #0
  115834:	f009 0301 	andeq.w	r3, r9, #1
                                Sink_EDID[i*32+j]= edid_data; // write edid data to Sink_EDID[];
  115838:	f80a 0f01 	strb.w	r0, [r10, #1]!
                                if((i == 3)&&( j == 30))
  11583c:	2b00      	cmp	r3, #0
  11583e:	d0ef      	beq.n	115820 <LT9611_Read_EDID+0xb0>
                        for(j=0; j<32; j++)
  115840:	3401      	adds	r4, #1
                                    extended_flag = edid_data & 0x03;
  115842:	f000 0503 	and.w	r5, r0, #3
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  115846:	2083      	movs	r0, #131	; 0x83
                        for(j=0; j<32; j++)
  115848:	b2e4      	uxtb	r4, r4
  11584a:	2c20      	cmp	r4, #32
  11584c:	d1ed      	bne.n	11582a <LT9611_Read_EDID+0xba>
                            if(extended_flag < 1) //no block 1, stop reading edid.
  11584e:	2d00      	cmp	r5, #0
  115850:	bf0c      	ite	eq
  115852:	464b      	moveq	r3, r9
  115854:	2300      	movne	r3, #0
  115856:	bbe3      	cbnz	r3, 1158d2 <LT9611_Read_EDID+0x162>
  115858:	3701      	adds	r7, #1
            for(i=0;i < 8;i++) // block 0 & 1
  11585a:	2f08      	cmp	r7, #8
  11585c:	f106 0620 	add.w	r6, r6, #32
  115860:	d1b0      	bne.n	1157c4 <LT9611_Read_EDID+0x54>
          if(extended_flag < 2) //no block 2, stop reading edid.
  115862:	2d01      	cmp	r5, #1
  115864:	d935      	bls.n	1158d2 <LT9611_Read_EDID+0x162>
  115866:	4699      	mov	r9, r3
                HDMI_WriteI2C_Byte(0x05,i*32); //0x00 is EDID offset address
  115868:	2005      	movs	r0, #5
  11586a:	fa5f f689 	uxtb.w	r6, r9
  11586e:	fa06 f100 	lsl.w	r1, r6, r0
  115872:	f001 01e0 	and.w	r1, r1, #224	; 0xe0
  115876:	f000 fd63 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x76); //0x31
  11587a:	2176      	movs	r1, #118	; 0x76
  11587c:	2007      	movs	r0, #7
  11587e:	f000 fd5f 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x74); //0x31
  115882:	2174      	movs	r1, #116	; 0x74
  115884:	2007      	movs	r0, #7
  115886:	f000 fd5b 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x07,0x77); //0x37
  11588a:	2177      	movs	r1, #119	; 0x77
  11588c:	2007      	movs	r0, #7
  11588e:	f000 fd57 	bl	116340 <HDMI_WriteI2C_Byte>
                mdelay(2); // wait 5ms for reading edid data.
  115892:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
  115896:	f7fd ff6f 	bl	113778 <spin>
                if(HDMI_ReadI2C_Byte(0x40)&0x02) //KEY_DDC_ACCS_DONE=1
  11589a:	2040      	movs	r0, #64	; 0x40
  11589c:	f000 fd1e 	bl	1162dc <HDMI_ReadI2C_Byte>
  1158a0:	0783      	lsls	r3, r0, #30
  1158a2:	d516      	bpl.n	1158d2 <LT9611_Read_EDID+0x162>
                    if(HDMI_ReadI2C_Byte(0x40)&0x50)//DDC No Ack or Abitration lost
  1158a4:	2040      	movs	r0, #64	; 0x40
  1158a6:	f000 fd19 	bl	1162dc <HDMI_ReadI2C_Byte>
  1158aa:	f010 0f50 	tst.w	r0, #80	; 0x50
  1158ae:	d110      	bne.n	1158d2 <LT9611_Read_EDID+0x162>
  1158b0:	2420      	movs	r4, #32
                                edid_data = HDMI_ReadI2C_Byte(0x83);
  1158b2:	2083      	movs	r0, #131	; 0x83
  1158b4:	f000 fd12 	bl	1162dc <HDMI_ReadI2C_Byte>
  1158b8:	1e63      	subs	r3, r4, #1
                        for(j=0; j<32; j++)
  1158ba:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
  1158be:	d1f8      	bne.n	1158b2 <LT9611_Read_EDID+0x142>
                            if(extended_flag < 3) //no block 1, stop reading edid.
  1158c0:	2d02      	cmp	r5, #2
  1158c2:	bf08      	it	eq
  1158c4:	2e03      	cmpeq	r6, #3
  1158c6:	d004      	beq.n	1158d2 <LT9611_Read_EDID+0x162>
  1158c8:	f109 0901 	add.w	r9, r9, #1
          for(i=0;i< 8;i++) //  // block 2 & 3
  1158cc:	f1b9 0f08 	cmp.w	r9, #8
  1158d0:	d1ca      	bne.n	115868 <LT9611_Read_EDID+0xf8>
HDMI_WriteI2C_Byte(0x03,0xc2);
  1158d2:	21c2      	movs	r1, #194	; 0xc2
  1158d4:	2003      	movs	r0, #3
  1158d6:	f000 fd33 	bl	116340 <HDMI_WriteI2C_Byte>
HDMI_WriteI2C_Byte(0x07,0x1f);
  1158da:	211f      	movs	r1, #31
  1158dc:	2007      	movs	r0, #7
}
  1158de:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
HDMI_WriteI2C_Byte(0x07,0x1f);
  1158e2:	f000 bd2d 	b.w	116340 <HDMI_WriteI2C_Byte>
  1158e6:	bf00      	nop

001158e8 <LT9611_Get_HPD_Status>:
{
  1158e8:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff,0x82);
  1158ea:	2182      	movs	r1, #130	; 0x82
  1158ec:	20ff      	movs	r0, #255	; 0xff
  1158ee:	f000 fd27 	bl	116340 <HDMI_WriteI2C_Byte>
    reg_825e = HDMI_ReadI2C_Byte(0x5e);
  1158f2:	205e      	movs	r0, #94	; 0x5e
  1158f4:	f000 fcf2 	bl	1162dc <HDMI_ReadI2C_Byte>
}
  1158f8:	f3c0 0080 	ubfx	r0, r0, #2, #1
  1158fc:	bd08      	pop	{r3, r15}
  1158fe:	bf00      	nop

00115900 <lt9611_cec_logical_reset>:

void lt9611_cec_logical_reset(void)
{
  115900:	b508      	push	{r3, r14}
    HDMI_WriteI2C_Byte(0xff, 0x80);
  115902:	2180      	movs	r1, #128	; 0x80
  115904:	20ff      	movs	r0, #255	; 0xff
  115906:	f000 fd1b 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15, 0xf1); //reset cec logic
  11590a:	21f1      	movs	r1, #241	; 0xf1
  11590c:	2015      	movs	r0, #21
  11590e:	f000 fd17 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x15, 0xf9);
  115912:	21f9      	movs	r1, #249	; 0xf9
  115914:	2015      	movs	r0, #21
}
  115916:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x15, 0xf9);
  11591a:	f000 bd11 	b.w	116340 <HDMI_WriteI2C_Byte>
  11591e:	bf00      	nop

00115920 <lt9611_cec_msg_set_logical_address>:


void lt9611_cec_msg_set_logical_address(struct cec_msg *cec_msg)
{
  115920:	b510      	push	{r4, r14}
    0x30, 0x00,  //LA 14
    0x40, 0x00   //LA 15
*/


    if(!cec_msg->la_allocation_done)
  115922:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
  115926:	b1ab      	cbz	r3, 115954 <lt9611_cec_msg_set_logical_address+0x34>
        logical_address = 15;
    else
        logical_address = cec_msg->logical_address;
  115928:	f890 4023 	ldrb.w	r4, [r0, #35]	; 0x23

    if(logical_address > 15)
  11592c:	2c0f      	cmp	r4, #15
  11592e:	d810      	bhi.n	115952 <lt9611_cec_msg_set_logical_address+0x32>
    {
        dprintf(LT9611_LOG, "\n LA error!");
        return;
    }

    HDMI_WriteI2C_Byte(0xff, 0x86);
  115930:	2186      	movs	r1, #134	; 0x86

    switch(logical_address) {
  115932:	3c01      	subs	r4, #1
    HDMI_WriteI2C_Byte(0xff, 0x86);
  115934:	20ff      	movs	r0, #255	; 0xff
  115936:	f000 fd03 	bl	116340 <HDMI_WriteI2C_Byte>
    switch(logical_address) {
  11593a:	2c0e      	cmp	r4, #14
  11593c:	d822      	bhi.n	115984 <lt9611_cec_msg_set_logical_address+0x64>
  11593e:	e8df f004 	tbb	[r15, r4]
  115942:	2d2b      	.short	0x2d2b
  115944:	3533312f 	.word	0x3533312f
  115948:	4d433937 	.word	0x4d433937
  11594c:	176b6157 	.word	0x176b6157
  115950:	0d          	.byte	0x0d
  115951:	00          	.byte	0x00
    break;

    default: break;
    }

}
  115952:	bd10      	pop	{r4, r15}
    HDMI_WriteI2C_Byte(0xff, 0x86);
  115954:	2186      	movs	r1, #134	; 0x86
  115956:	20ff      	movs	r0, #255	; 0xff
  115958:	f000 fcf2 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  11595c:	2100      	movs	r1, #0
  11595e:	20f7      	movs	r0, #247	; 0xf7
  115960:	f000 fcee 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x40);
  115964:	2140      	movs	r1, #64	; 0x40
  115966:	20f8      	movs	r0, #248	; 0xf8
}
  115968:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x40);
  11596c:	f000 bce8 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  115970:	2100      	movs	r1, #0
  115972:	20f7      	movs	r0, #247	; 0xf7
  115974:	f000 fce4 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x30);
  115978:	2130      	movs	r1, #48	; 0x30
  11597a:	20f8      	movs	r0, #248	; 0xf8
}
  11597c:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x30);
  115980:	f000 bcde 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x01);
  115984:	2101      	movs	r1, #1
    HDMI_WriteI2C_Byte(0xf7, 0x02);
  115986:	20f7      	movs	r0, #247	; 0xf7
  115988:	f000 fcda 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x00);
  11598c:	2100      	movs	r1, #0
  11598e:	20f8      	movs	r0, #248	; 0xf8
}
  115990:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x00);
  115994:	f000 bcd4 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x02);
  115998:	2102      	movs	r1, #2
  11599a:	e7f4      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x03);
  11599c:	2103      	movs	r1, #3
  11599e:	e7f2      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x04);
  1159a0:	2104      	movs	r1, #4
  1159a2:	e7f0      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x10);
  1159a4:	2110      	movs	r1, #16
  1159a6:	e7ee      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x20);
  1159a8:	2120      	movs	r1, #32
  1159aa:	e7ec      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x30);
  1159ac:	2130      	movs	r1, #48	; 0x30
  1159ae:	e7ea      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x40);
  1159b0:	2140      	movs	r1, #64	; 0x40
  1159b2:	e7e8      	b.n	115986 <lt9611_cec_msg_set_logical_address+0x66>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  1159b4:	2100      	movs	r1, #0
  1159b6:	20f7      	movs	r0, #247	; 0xf7
  1159b8:	f000 fcc2 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x01);
  1159bc:	2101      	movs	r1, #1
  1159be:	20f8      	movs	r0, #248	; 0xf8
}
  1159c0:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x01);
  1159c4:	f000 bcbc 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  1159c8:	2100      	movs	r1, #0
  1159ca:	20f7      	movs	r0, #247	; 0xf7
  1159cc:	f000 fcb8 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x02);
  1159d0:	2102      	movs	r1, #2
  1159d2:	20f8      	movs	r0, #248	; 0xf8
}
  1159d4:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x02);
  1159d8:	f000 bcb2 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  1159dc:	2100      	movs	r1, #0
  1159de:	20f7      	movs	r0, #247	; 0xf7
  1159e0:	f000 fcae 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x03);
  1159e4:	2103      	movs	r1, #3
  1159e6:	20f8      	movs	r0, #248	; 0xf8
}
  1159e8:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x03);
  1159ec:	f000 bca8 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  1159f0:	2100      	movs	r1, #0
  1159f2:	20f7      	movs	r0, #247	; 0xf7
  1159f4:	f000 fca4 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x04);
  1159f8:	2104      	movs	r1, #4
  1159fa:	20f8      	movs	r0, #248	; 0xf8
}
  1159fc:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x04);
  115a00:	f000 bc9e 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  115a04:	2100      	movs	r1, #0
  115a06:	20f7      	movs	r0, #247	; 0xf7
  115a08:	f000 fc9a 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x10);
  115a0c:	2110      	movs	r1, #16
  115a0e:	20f8      	movs	r0, #248	; 0xf8
}
  115a10:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x10);
  115a14:	f000 bc94 	b.w	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf7, 0x00);
  115a18:	2100      	movs	r1, #0
  115a1a:	20f7      	movs	r0, #247	; 0xf7
  115a1c:	f000 fc90 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf8, 0x20);
  115a20:	2120      	movs	r1, #32
  115a22:	20f8      	movs	r0, #248	; 0xf8
}
  115a24:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    HDMI_WriteI2C_Byte(0xf8, 0x20);
  115a28:	f000 bc8a 	b.w	116340 <HDMI_WriteI2C_Byte>

00115a2c <lt9611_parse_physical_address>:
    return 1;
}


int lt9611_parse_physical_address(struct cec_msg *cec_msg, u8 *edid) // parse edid data from edid.
{
  115a2c:	b4f0      	push	{r4, r5, r6, r7}
    int offset = 0;
    int offset_d = 0;
    int tag_code;
    u16 physical_address;

    version = edid[0x81];
  115a2e:	f891 6081 	ldrb.w	r6, [r1, #129]	; 0x81
    offset_d = edid[0x82];
  115a32:	f891 7082 	ldrb.w	r7, [r1, #130]	; 0x82
    unsigned char check = x[len];
  115a36:	f891 c0ff 	ldrb.w	r12, [r1, #255]	; 0xff
  115a3a:	1e4a      	subs	r2, r1, #1
    unsigned char sum = 0;
  115a3c:	2300      	movs	r3, #0
  115a3e:	f101 05fe 	add.w	r5, r1, #254	; 0xfe
        sum += x[i];
  115a42:	f812 4f01 	ldrb.w	r4, [r2, #1]!
  115a46:	4423      	add	r3, r4
    for (i = 0; i < len; i++)
  115a48:	4295      	cmp	r5, r2
        sum += x[i];
  115a4a:	b2db      	uxtb	r3, r3
    for (i = 0; i < len; i++)
  115a4c:	d1f9      	bne.n	115a42 <lt9611_parse_physical_address+0x16>

    if(!do_checksum(edid, 255))
        return 0; //prase_physical_address fail.

    if (version < 3)
  115a4e:	2e02      	cmp	r6, #2
  115a50:	bf8c      	ite	hi
  115a52:	2200      	movhi	r2, #0
  115a54:	2201      	movls	r2, #1
    if ((unsigned char)(check + sum) != 0) {
  115a56:	eb0c 0403 	add.w	r4, r12, r3
        return 0; //prase_physical_address fail.

    if (offset_d < 5)
  115a5a:	2f04      	cmp	r7, #4
  115a5c:	bfcc      	ite	gt
  115a5e:	4613      	movgt	r3, r2
  115a60:	f042 0301 	orrle.w	r3, r2, #1
    if ((unsigned char)(check + sum) != 0) {
  115a64:	b2e2      	uxtb	r2, r4
    if (offset_d < 5)
  115a66:	2a00      	cmp	r2, #0
  115a68:	bf18      	it	ne
  115a6a:	2301      	movne	r3, #1
  115a6c:	b11b      	cbz	r3, 115a76 <lt9611_parse_physical_address+0x4a>
        return 0; //prase_physical_address fail.
  115a6e:	2300      	movs	r3, #0
            cec_msg->physical_address = physical_address;
            dprintf(LT9611_LOG, "\nprase physical address success! %x",physical_address);
            return 1;
        }
return 0;
}
  115a70:	4618      	mov	r0, r3
  115a72:	bcf0      	pop	{r4, r5, r6, r7}
  115a74:	4770      	bx	r14
    tag_code = (edid[0x84 + offset] & 0xe0)>>5;
  115a76:	f891 2084 	ldrb.w	r2, [r1, #132]	; 0x84
    while(tag_code != 0x03){
  115a7a:	0954      	lsrs	r4, r2, #5
  115a7c:	2c03      	cmp	r4, #3
  115a7e:	d032      	beq.n	115ae6 <lt9611_parse_physical_address+0xba>
        if((edid[0x84 + offset]&0x1f) == 0 )
  115a80:	f012 021f 	ands.w	r2, r2, #31
  115a84:	d0f3      	beq.n	115a6e <lt9611_parse_physical_address+0x42>
        if(offset > (offset_d - 4))
  115a86:	3f03      	subs	r7, #3
        offset++;
  115a88:	1c54      	adds	r4, r2, #1
        if(offset > (offset_d - 4))
  115a8a:	42bc      	cmp	r4, r7
  115a8c:	db0b      	blt.n	115aa6 <lt9611_parse_physical_address+0x7a>
  115a8e:	e7ef      	b.n	115a70 <lt9611_parse_physical_address+0x44>
  115a90:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
        if((edid[0x84 + offset]&0x1f) == 0 )
  115a94:	f013 031f 	ands.w	r3, r3, #31
        offset += edid[0x84 + offset]&0x1f;
  115a98:	eb03 0204 	add.w	r2, r3, r4
        offset++;
  115a9c:	f102 0401 	add.w	r4, r2, #1
        if((edid[0x84 + offset]&0x1f) == 0 )
  115aa0:	d0e6      	beq.n	115a70 <lt9611_parse_physical_address+0x44>
        if(offset > (offset_d - 4))
  115aa2:	42bc      	cmp	r4, r7
  115aa4:	dae3      	bge.n	115a6e <lt9611_parse_physical_address+0x42>
        tag_code = (edid[0x84 + offset] & 0xe0)>>5;
  115aa6:	188b      	adds	r3, r1, r2
  115aa8:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
    while(tag_code != 0x03){
  115aac:	095b      	lsrs	r3, r3, #5
  115aae:	2b03      	cmp	r3, #3
        if((edid[0x84 + offset]&0x1f) == 0 )
  115ab0:	eb01 0304 	add.w	r3, r1, r4
    while(tag_code != 0x03){
  115ab4:	d1ec      	bne.n	115a90 <lt9611_parse_physical_address+0x64>
  115ab6:	4623      	mov	r3, r4
  115ab8:	f104 0285 	add.w	r2, r4, #133	; 0x85
    if((edid[0x84 + offset + 1] == 0x03)&&
  115abc:	5c8a      	ldrb	r2, [r1, r2]
  115abe:	2a03      	cmp	r2, #3
  115ac0:	d1d5      	bne.n	115a6e <lt9611_parse_physical_address+0x42>
        (edid[0x84 + offset + 2] == 0x0c)&&
  115ac2:	440b      	add	r3, r1
    if((edid[0x84 + offset + 1] == 0x03)&&
  115ac4:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
  115ac8:	2a0c      	cmp	r2, #12
  115aca:	d1d0      	bne.n	115a6e <lt9611_parse_physical_address+0x42>
        (edid[0x84 + offset + 2] == 0x0c)&&
  115acc:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
  115ad0:	2a00      	cmp	r2, #0
  115ad2:	d1cc      	bne.n	115a6e <lt9611_parse_physical_address+0x42>
            physical_address = edid[0x84 + offset + 4];
  115ad4:	f893 1088 	ldrb.w	r1, [r3, #136]	; 0x88
            physical_address = (physical_address<<8) + edid[0x84 + offset + 5];
  115ad8:	f893 2089 	ldrb.w	r2, [r3, #137]	; 0x89
            return 1;
  115adc:	2301      	movs	r3, #1
            physical_address = (physical_address<<8) + edid[0x84 + offset + 5];
  115ade:	eb02 2201 	add.w	r2, r2, r1, lsl #8
            cec_msg->physical_address = physical_address;
  115ae2:	8482      	strh	r2, [r0, #36]	; 0x24
            return 1;
  115ae4:	e7c4      	b.n	115a70 <lt9611_parse_physical_address+0x44>
    while(tag_code != 0x03){
  115ae6:	2285      	movs	r2, #133	; 0x85
  115ae8:	e7e8      	b.n	115abc <lt9611_parse_physical_address+0x90>
  115aea:	bf00      	nop

00115aec <lt9611_hdmi_cec_read>:

void lt9611_hdmi_cec_read(struct cec_msg *cec_msg) // transfer cec msg from LT9611 regisrer to rx_buffer.
{
  115aec:	b570      	push	{r4, r5, r6, r14}
    u8 size, i;
    HDMI_WriteI2C_Byte(0xff, 0x86);
  115aee:	2186      	movs	r1, #134	; 0x86
{
  115af0:	4606      	mov	r6, r0
    HDMI_WriteI2C_Byte(0xff, 0x86);
  115af2:	20ff      	movs	r0, #255	; 0xff
  115af4:	f000 fc24 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf5, 0x01); //lock rx data buff
  115af8:	2101      	movs	r1, #1
  115afa:	20f5      	movs	r0, #245	; 0xf5
  115afc:	f000 fc20 	bl	116340 <HDMI_WriteI2C_Byte>
    size = HDMI_ReadI2C_Byte(0xd3);
  115b00:	20d3      	movs	r0, #211	; 0xd3
  115b02:	f000 fbeb 	bl	1162dc <HDMI_ReadI2C_Byte>
    cec_msg->rx_data_buff[0] = size;
  115b06:	7070      	strb	r0, [r6, #1]
    //dprintf(LT9611_LOG, "\r\ncec rec: ");
    for(i = 1;i<= size; i++)
  115b08:	b160      	cbz	r0, 115b24 <lt9611_hdmi_cec_read+0x38>
  115b0a:	4605      	mov	r5, r0
  115b0c:	2401      	movs	r4, #1
    {
        cec_msg->rx_data_buff[i] = HDMI_ReadI2C_Byte(0xd3 + i);
  115b0e:	f1a4 002d 	sub.w	r0, r4, #45	; 0x2d
  115b12:	b2c0      	uxtb	r0, r0
  115b14:	f000 fbe2 	bl	1162dc <HDMI_ReadI2C_Byte>
    for(i = 1;i<= size; i++)
  115b18:	1c62      	adds	r2, r4, #1
        cec_msg->rx_data_buff[i] = HDMI_ReadI2C_Byte(0xd3 + i);
  115b1a:	1933      	adds	r3, r6, r4
    for(i = 1;i<= size; i++)
  115b1c:	b2d4      	uxtb	r4, r2
  115b1e:	42a5      	cmp	r5, r4
        cec_msg->rx_data_buff[i] = HDMI_ReadI2C_Byte(0xd3 + i);
  115b20:	7058      	strb	r0, [r3, #1]
    for(i = 1;i<= size; i++)
  115b22:	d2f4      	bcs.n	115b0e <lt9611_hdmi_cec_read+0x22>
        //dprintf(LT9611_LOG, "0x%02x, ",cec_msg->rx_data_buff[i]);
    }
    HDMI_WriteI2C_Byte(0xf5, 0x00); //unlock rx data buff
  115b24:	2100      	movs	r1, #0
  115b26:	20f5      	movs	r0, #245	; 0xf5
}
  115b28:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    HDMI_WriteI2C_Byte(0xf5, 0x00); //unlock rx data buff
  115b2c:	f000 bc08 	b.w	116340 <HDMI_WriteI2C_Byte>

00115b30 <lt9611_hdmi_cec_write>:


void lt9611_hdmi_cec_write(struct cec_msg *cec_msg)// send cec msg which is in tx_buffer.
{
  115b30:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  115b32:	4606      	mov	r6, r0
    u8 size, i;
    size = cec_msg->tx_data_buff[0];
    cec_msg->retries_times = 0;
  115b34:	2400      	movs	r4, #0

    HDMI_WriteI2C_Byte(0xff, 0x86);
  115b36:	2186      	movs	r1, #134	; 0x86
  115b38:	20ff      	movs	r0, #255	; 0xff
    cec_msg->retries_times = 0;
  115b3a:	f886 4027 	strb.w	r4, [r6, #39]	; 0x27
    size = cec_msg->tx_data_buff[0];
  115b3e:	7c77      	ldrb	r7, [r6, #17]
    HDMI_WriteI2C_Byte(0xff, 0x86);
  115b40:	f000 fbfe 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf5, 0x01); //lock rx data buff
  115b44:	2101      	movs	r1, #1
  115b46:	20f5      	movs	r0, #245	; 0xf5
  115b48:	f000 fbfa 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xf4, size);
  115b4c:	4639      	mov	r1, r7
  115b4e:	20f4      	movs	r0, #244	; 0xf4
  115b50:	f000 fbf6 	bl	116340 <HDMI_WriteI2C_Byte>
  115b54:	4623      	mov	r3, r4
    for(i = 0;i<= size; i++)
    {
        HDMI_WriteI2C_Byte(0xe4+i, cec_msg->tx_data_buff[1+i]);
  115b56:	f1a4 001c 	sub.w	r0, r4, #28
  115b5a:	1c5d      	adds	r5, r3, #1
  115b5c:	3401      	adds	r4, #1
  115b5e:	1973      	adds	r3, r6, r5
  115b60:	7c59      	ldrb	r1, [r3, #17]
  115b62:	b2c0      	uxtb	r0, r0
  115b64:	f000 fbec 	bl	116340 <HDMI_WriteI2C_Byte>
    for(i = 0;i<= size; i++)
  115b68:	b2e3      	uxtb	r3, r4
  115b6a:	429f      	cmp	r7, r3
  115b6c:	d2f3      	bcs.n	115b56 <lt9611_hdmi_cec_write+0x26>
    }
    HDMI_WriteI2C_Byte(0xf9, 0x03); //start send msg
  115b6e:	2103      	movs	r1, #3
    mdelay(2*i); //wait HDMI
  115b70:	b2ed      	uxtb	r5, r5
    HDMI_WriteI2C_Byte(0xf9, 0x03); //start send msg
  115b72:	20f9      	movs	r0, #249	; 0xf9
  115b74:	f000 fbe4 	bl	116340 <HDMI_WriteI2C_Byte>
    mdelay(2*i); //wait HDMI
  115b78:	ebc5 1045 	rsb	r0, r5, r5, lsl #5
  115b7c:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  115b80:	0100      	lsls	r0, r0, #4
  115b82:	f7fd fdf9 	bl	113778 <spin>
    HDMI_WriteI2C_Byte(0xf5, 0x00); //unlock rx data buff
  115b86:	2100      	movs	r1, #0
  115b88:	20f5      	movs	r0, #245	; 0xf5
}
  115b8a:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    HDMI_WriteI2C_Byte(0xf5, 0x00); //unlock rx data buff
  115b8e:	f000 bbd7 	b.w	116340 <HDMI_WriteI2C_Byte>
  115b92:	bf00      	nop

00115b94 <lt9611_cec_msg_rx_parse.part.5>:

        } while (0);
}


void lt9611_cec_msg_rx_parse(struct cec_msg *cec_msg)
  115b94:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  115b96:	4604      	mov	r4, r0

    if(!(cec_status&CEC_REC_DATA)){
        return;
        }

    lt9611_hdmi_cec_read(&lt9611_cec_msg);
  115b98:	f243 2040 	movw	r0, #12864	; 0x3240
  115b9c:	f2c0 0013 	movt	r0, #19
  115ba0:	f7ff ffa4 	bl	115aec <lt9611_hdmi_cec_read>

    if(cec_msg ->rx_data_buff[0] < 1) //check rx data length
  115ba4:	7863      	ldrb	r3, [r4, #1]
  115ba6:	2b01      	cmp	r3, #1
  115ba8:	d90d      	bls.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
    dprintf(LT9611_LOG, "\nrx_date: ");
    for(i = 0; i < cec_msg->rx_data_buff[0]; i++)
    dprintf(LT9611_LOG, "0x%02x, ",cec_msg->rx_data_buff[i + 1]);

    dprintf(LT9611_LOG, "parse <<");
    header = cec_msg ->rx_data_buff[1];
  115baa:	78a1      	ldrb	r1, [r4, #2]
        return;

    opcode = cec_msg ->rx_data_buff[2];

// CECT 12 Invalid Msg Tests
if((header&0x0f) == 0x0f){
  115bac:	f001 000f 	and.w	r0, r1, #15
  115bb0:	280f      	cmp	r0, #15
    opcode = cec_msg ->rx_data_buff[2];
  115bb2:	78e2      	ldrb	r2, [r4, #3]
if((header&0x0f) == 0x0f){
  115bb4:	d008      	beq.n	115bc8 <lt9611_cec_msg_rx_parse.part.5+0x34>
        (opcode == 0xff)){
        dprintf(LT9611_LOG, "Invalid msg, destination address error"); //these msg should not be broadcast msg, but they do.
        return;
    }
}else{
    if((opcode == 0x84)||
  115bb6:	2a84      	cmp	r2, #132	; 0x84
  115bb8:	d005      	beq.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
        dprintf(LT9611_LOG, "Invalid msg, destination address error"); //these msg should be broadcast msg, but they not.
        return;
    }
}

    if(opcode == 0xff) //abort
  115bba:	2aff      	cmp	r2, #255	; 0xff
  115bbc:	d042      	beq.n	115c44 <lt9611_cec_msg_rx_parse.part.5+0xb0>
            return;
        cec_msg ->destintion = initiator;
        lt9611_cec_feature_abort(cec_msg, CEC_ABORT_REASON_0);
    }

    if(opcode == 0x83) //give physical address
  115bbe:	2a83      	cmp	r2, #131	; 0x83
  115bc0:	d051      	beq.n	115c66 <lt9611_cec_msg_rx_parse.part.5+0xd2>
    {
        dprintf(LT9611_LOG, "give physical address.");
        lt9611_cec_report_physical_address(cec_msg);
    }

    if(opcode == 0x90) //report power status
  115bc2:	2a90      	cmp	r2, #144	; 0x90
  115bc4:	d10d      	bne.n	115be2 <lt9611_cec_msg_rx_parse.part.5+0x4e>
        }
        lt9611_cec_report_physical_address(cec_msg);
        mdelay(12);
        lt9611_cec_menu_activate(cec_msg);
    }
}
  115bc6:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if((opcode == 0x00)||
  115bc8:	2a83      	cmp	r2, #131	; 0x83
  115bca:	bf18      	it	ne
  115bcc:	2a00      	cmpne	r2, #0
  115bce:	d0fa      	beq.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
        (opcode == 0x8e)||
  115bd0:	f102 0172 	add.w	r1, r2, #114	; 0x72
  115bd4:	f001 01fd 	and.w	r1, r1, #253	; 0xfd
    if(opcode == 0xff) //abort
  115bd8:	2900      	cmp	r1, #0
  115bda:	bf18      	it	ne
  115bdc:	2aff      	cmpne	r2, #255	; 0xff
  115bde:	d1ee      	bne.n	115bbe <lt9611_cec_msg_rx_parse.part.5+0x2a>
}
  115be0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if(opcode == 0x8e) //menu status
  115be2:	2a8e      	cmp	r2, #142	; 0x8e
  115be4:	d153      	bne.n	115c8e <lt9611_cec_msg_rx_parse.part.5+0xfa>
        if(cec_msg ->rx_data_buff[0] < 3) {
  115be6:	2b02      	cmp	r3, #2
  115be8:	d9ed      	bls.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
    if(opcode == 0x86) //set stream path
  115bea:	2a86      	cmp	r2, #134	; 0x86
  115bec:	d1eb      	bne.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
        if(cec_msg ->rx_data_buff[0] < 4) {
  115bee:	7863      	ldrb	r3, [r4, #1]
  115bf0:	2b03      	cmp	r3, #3
  115bf2:	d9e8      	bls.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115bf4:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115bf8:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115bfa:	2184      	movs	r1, #132	; 0x84
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115bfc:	011b      	lsls	r3, r3, #4
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115bfe:	0a17      	lsrs	r7, r2, #8
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115c00:	2504      	movs	r5, #4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115c02:	f043 030f 	orr.w	r3, r3, #15
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115c06:	2605      	movs	r6, #5
        lt9611_hdmi_cec_write(cec_msg);
  115c08:	4620      	mov	r0, r4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115c0a:	74a3      	strb	r3, [r4, #18]
        cec_msg->tx_data_buff[4] = (u8)(cec_msg->physical_address); //parameter of opcode
  115c0c:	7562      	strb	r2, [r4, #21]
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115c0e:	74e1      	strb	r1, [r4, #19]
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115c10:	7527      	strb	r7, [r4, #20]
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115c12:	7466      	strb	r6, [r4, #17]
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115c14:	75a5      	strb	r5, [r4, #22]
        lt9611_hdmi_cec_write(cec_msg);
  115c16:	f7ff ff8b 	bl	115b30 <lt9611_hdmi_cec_write>
        mdelay(12);
  115c1a:	f642 60e0 	movw	r0, #12000	; 0x2ee0
  115c1e:	f7fd fdab 	bl	113778 <spin>
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c22:	f894 2023 	ldrb.w	r2, [r4, #35]	; 0x23
  115c26:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
        cec_msg->tx_data_buff[2] = 0x8e; //opcode
  115c2a:	218e      	movs	r1, #142	; 0x8e
        lt9611_hdmi_cec_write(cec_msg);
  115c2c:	4620      	mov	r0, r4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c2e:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
        cec_msg->tx_data_buff[0] = 0x04; //data counter to be send
  115c32:	7465      	strb	r5, [r4, #17]
        cec_msg->tx_data_buff[3] = 0x00; //parameter of opcode
  115c34:	2200      	movs	r2, #0
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c36:	74a3      	strb	r3, [r4, #18]
        cec_msg->tx_data_buff[2] = 0x8e; //opcode
  115c38:	74e1      	strb	r1, [r4, #19]
        cec_msg->tx_data_buff[3] = 0x00; //parameter of opcode
  115c3a:	7522      	strb	r2, [r4, #20]
}
  115c3c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
        lt9611_hdmi_cec_write(cec_msg);
  115c40:	f7ff bf76 	b.w	115b30 <lt9611_hdmi_cec_write>
        cec_msg->tx_data_buff[2] = 0x00; //opcode
  115c44:	2200      	movs	r2, #0
    initiator = (header&0xf0) >> 4;
  115c46:	0909      	lsrs	r1, r1, #4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c48:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
        cec_msg->tx_data_buff[0] = 0x03; //data counter to be send
  115c4c:	2503      	movs	r5, #3
        lt9611_hdmi_cec_write(cec_msg);
  115c4e:	4620      	mov	r0, r4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c50:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
        cec_msg ->destintion = initiator;
  115c54:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|cec_msg->destintion;
  115c58:	74a3      	strb	r3, [r4, #18]
        cec_msg->tx_data_buff[0] = 0x03; //data counter to be send
  115c5a:	7465      	strb	r5, [r4, #17]
        cec_msg->tx_data_buff[2] = 0x00; //opcode
  115c5c:	74e2      	strb	r2, [r4, #19]
        cec_msg->tx_data_buff[3] = reason; //parameter1 of opcode
  115c5e:	7522      	strb	r2, [r4, #20]
        lt9611_hdmi_cec_write(cec_msg);
  115c60:	f7ff ff66 	bl	115b30 <lt9611_hdmi_cec_write>
}
  115c64:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115c66:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115c6a:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115c6c:	2605      	movs	r6, #5
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115c6e:	011b      	lsls	r3, r3, #4
  115c70:	f043 030f 	orr.w	r3, r3, #15
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115c74:	2584      	movs	r5, #132	; 0x84
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115c76:	0a17      	lsrs	r7, r2, #8
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115c78:	2104      	movs	r1, #4
        lt9611_hdmi_cec_write(cec_msg);
  115c7a:	4620      	mov	r0, r4
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115c7c:	74a3      	strb	r3, [r4, #18]
        cec_msg->tx_data_buff[4] = (u8)(cec_msg->physical_address); //parameter of opcode
  115c7e:	7562      	strb	r2, [r4, #21]
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115c80:	7527      	strb	r7, [r4, #20]
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115c82:	7466      	strb	r6, [r4, #17]
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115c84:	74e5      	strb	r5, [r4, #19]
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115c86:	75a1      	strb	r1, [r4, #22]
        lt9611_hdmi_cec_write(cec_msg);
  115c88:	f7ff ff52 	bl	115b30 <lt9611_hdmi_cec_write>
}
  115c8c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if(opcode == 0x00) //feature abort
  115c8e:	2a00      	cmp	r2, #0
  115c90:	d099      	beq.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
    if(opcode == 0x9e) //cec version
  115c92:	2a9e      	cmp	r2, #158	; 0x9e
  115c94:	d097      	beq.n	115bc6 <lt9611_cec_msg_rx_parse.part.5+0x32>
    if(opcode == 0x84) //report physical address
  115c96:	2a84      	cmp	r2, #132	; 0x84
  115c98:	d1a7      	bne.n	115bea <lt9611_cec_msg_rx_parse.part.5+0x56>
}
  115c9a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00115c9c <lt9611_cec_frame_retransmission>:
{
  115c9c:	b510      	push	{r4, r14}
    if(cec_msg->retries_times < 5){
  115c9e:	f890 3027 	ldrb.w	r3, [r0, #39]	; 0x27
{
  115ca2:	4604      	mov	r4, r0
    if(cec_msg->retries_times < 5){
  115ca4:	2b04      	cmp	r3, #4
  115ca6:	d80d      	bhi.n	115cc4 <lt9611_cec_frame_retransmission+0x28>
        HDMI_WriteI2C_Byte(0xff, 0x86);
  115ca8:	2186      	movs	r1, #134	; 0x86
  115caa:	20ff      	movs	r0, #255	; 0xff
  115cac:	f000 fb48 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xf9, 0x02);
  115cb0:	2102      	movs	r1, #2
  115cb2:	20f9      	movs	r0, #249	; 0xf9
  115cb4:	f000 fb44 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xf9, 0x03);   //start send msg
  115cb8:	2103      	movs	r1, #3
  115cba:	20f9      	movs	r0, #249	; 0xf9
  115cbc:	f000 fb40 	bl	116340 <HDMI_WriteI2C_Byte>
  115cc0:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
    cec_msg->retries_times ++;
  115cc4:	3301      	adds	r3, #1
  115cc6:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
}
  115cca:	bd10      	pop	{r4, r15}

00115ccc <lt9611_cec_msg_tx_handle>:
{
  115ccc:	b570      	push	{r4, r5, r6, r14}
    cec_status = cec_msg ->cec_status;
  115cce:	7804      	ldrb	r4, [r0, #0]
    if(cec_status&CEC_ERROR_INITIATOR){
  115cd0:	06e5      	lsls	r5, r4, #27
  115cd2:	d447      	bmi.n	115d64 <lt9611_cec_msg_tx_handle+0x98>
    if(cec_status&CEC_ARB_LOST){
  115cd4:	0721      	lsls	r1, r4, #28
  115cd6:	d444      	bmi.n	115d62 <lt9611_cec_msg_tx_handle+0x96>
    if(cec_status&(CEC_SEND_DONE|CEC_NACK|CEC_ERROR_FOLLOWER)) do {
  115cd8:	f014 0f25 	tst.w	r4, #37	; 0x25
  115cdc:	d041      	beq.n	115d62 <lt9611_cec_msg_tx_handle+0x96>
        header = cec_msg ->tx_data_buff[1];
  115cde:	7c83      	ldrb	r3, [r0, #18]
  115ce0:	4605      	mov	r5, r0
        if((header == 0x44)||(header == 0x88)||(header == 0xbb)) //logical address allocation
  115ce2:	2b88      	cmp	r3, #136	; 0x88
  115ce4:	bf18      	it	ne
  115ce6:	2b44      	cmpne	r3, #68	; 0x44
        for(i = 0; i < cec_msg->tx_data_buff[0]; i++)
  115ce8:	7c41      	ldrb	r1, [r0, #17]
        if((header == 0x44)||(header == 0x88)||(header == 0xbb)) //logical address allocation
  115cea:	bf0c      	ite	eq
  115cec:	2201      	moveq	r2, #1
  115cee:	2200      	movne	r2, #0
  115cf0:	2bbb      	cmp	r3, #187	; 0xbb
  115cf2:	bf08      	it	eq
  115cf4:	f042 0201 	orreq.w	r2, r2, #1
  115cf8:	b32a      	cbz	r2, 115d46 <lt9611_cec_msg_tx_handle+0x7a>
            if(cec_status&CEC_NACK){
  115cfa:	0762      	lsls	r2, r4, #29
  115cfc:	d436      	bmi.n	115d6c <lt9611_cec_msg_tx_handle+0xa0>
            if(cec_status&CEC_SEND_DONE){
  115cfe:	07e3      	lsls	r3, r4, #31
  115d00:	d52f      	bpl.n	115d62 <lt9611_cec_msg_tx_handle+0x96>
                if(cec_msg->logical_address == 4)// go to next la.
  115d02:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
  115d06:	2b04      	cmp	r3, #4
                    cec_msg->logical_address = 8;
  115d08:	bf02      	ittt	eq
  115d0a:	2208      	moveq	r2, #8
  115d0c:	2388      	moveq	r3, #136	; 0x88
  115d0e:	f885 2023 	strbeq.w	r2, [r5, #35]	; 0x23
                if(cec_msg->logical_address == 4)// go to next la.
  115d12:	d010      	beq.n	115d36 <lt9611_cec_msg_tx_handle+0x6a>
                else if(cec_msg->logical_address == 8)// go to next la.
  115d14:	2b08      	cmp	r3, #8
                    cec_msg->logical_address = 11;
  115d16:	bf02      	ittt	eq
  115d18:	220b      	moveq	r2, #11
  115d1a:	23bb      	moveq	r3, #187	; 0xbb
  115d1c:	f885 2023 	strbeq.w	r2, [r5, #35]	; 0x23
                else if(cec_msg->logical_address == 8)// go to next la.
  115d20:	d009      	beq.n	115d36 <lt9611_cec_msg_tx_handle+0x6a>
                else if(cec_msg->logical_address == 11) // go to next la.
  115d22:	2b0b      	cmp	r3, #11
                    cec_msg->logical_address = 4;
  115d24:	bf09      	itett	eq
  115d26:	2204      	moveq	r2, #4
  115d28:	ea43 1303 	orrne.w	r3, r3, r3, lsl #4
  115d2c:	2344      	moveq	r3, #68	; 0x44
  115d2e:	f885 2023 	strbeq.w	r2, [r5, #35]	; 0x23
  115d32:	bf18      	it	ne
  115d34:	b2db      	uxtbne	r3, r3
    cec_msg->tx_data_buff[0] = 0x01; //data counter to be send
  115d36:	2201      	movs	r2, #1
    lt9611_hdmi_cec_write(cec_msg);
  115d38:	4628      	mov	r0, r5
    cec_msg->tx_data_buff[1] = (logical_address<<4)|logical_address;
  115d3a:	74ab      	strb	r3, [r5, #18]
    cec_msg->tx_data_buff[0] = 0x01; //data counter to be send
  115d3c:	746a      	strb	r2, [r5, #17]
}
  115d3e:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    lt9611_hdmi_cec_write(cec_msg);
  115d42:	f7ff bef5 	b.w	115b30 <lt9611_hdmi_cec_write>
        if(cec_status&(CEC_NACK|CEC_ERROR_FOLLOWER)){
  115d46:	f014 0f24 	tst.w	r4, #36	; 0x24
  115d4a:	d002      	beq.n	115d52 <lt9611_cec_msg_tx_handle+0x86>
            lt9611_cec_frame_retransmission(cec_msg);
  115d4c:	f7ff ffa6 	bl	115c9c <lt9611_cec_frame_retransmission>
  115d50:	7c69      	ldrb	r1, [r5, #17]
        if(cec_msg ->tx_data_buff[0] < 2)  //check tx data length
  115d52:	2901      	cmp	r1, #1
  115d54:	d905      	bls.n	115d62 <lt9611_cec_msg_tx_handle+0x96>
        if(opcode == 0x84){
  115d56:	7ceb      	ldrb	r3, [r5, #19]
  115d58:	2b84      	cmp	r3, #132	; 0x84
              cec_msg ->report_physical_address_done = 1;
  115d5a:	bf04      	itt	eq
  115d5c:	2301      	moveq	r3, #1
  115d5e:	f885 3029 	strbeq.w	r3, [r5, #41]	; 0x29
}
  115d62:	bd70      	pop	{r4, r5, r6, r15}
  115d64:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        lt9611_cec_logical_reset();
  115d68:	f7ff bdca 	b.w	115900 <lt9611_cec_logical_reset>
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115d6c:	2605      	movs	r6, #5
            cec_msg ->logical_address = header&0x0f;
  115d6e:	f003 030f 	and.w	r3, r3, #15
  115d72:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
            lt9611_cec_msg_set_logical_address(cec_msg);
  115d76:	f7ff fdd3 	bl	115920 <lt9611_cec_msg_set_logical_address>
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115d7a:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115d7e:	8caa      	ldrh	r2, [r5, #36]	; 0x24
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115d80:	2184      	movs	r1, #132	; 0x84
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115d82:	011b      	lsls	r3, r3, #4
  115d84:	f043 030f 	orr.w	r3, r3, #15
        cec_msg->tx_data_buff[4] = (u8)(cec_msg->physical_address); //parameter of opcode
  115d88:	756a      	strb	r2, [r5, #21]
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115d8a:	0a10      	lsrs	r0, r2, #8
        cec_msg->tx_data_buff[1] = (cec_msg->logical_address<<4)|0x0f;
  115d8c:	74ab      	strb	r3, [r5, #18]
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115d8e:	2304      	movs	r3, #4
        cec_msg->tx_data_buff[3] = (u8)(cec_msg->physical_address>>8); //parameter of opcode
  115d90:	7528      	strb	r0, [r5, #20]
        lt9611_hdmi_cec_write(cec_msg);
  115d92:	4628      	mov	r0, r5
        cec_msg->tx_data_buff[0] = 0x05; //data counter to be send
  115d94:	746e      	strb	r6, [r5, #17]
        cec_msg->tx_data_buff[2] = 0x84; //opcode
  115d96:	74e9      	strb	r1, [r5, #19]
        cec_msg->tx_data_buff[5] = 0x04; //device type = playback device
  115d98:	75ab      	strb	r3, [r5, #22]
        lt9611_hdmi_cec_write(cec_msg);
  115d9a:	f7ff fec9 	bl	115b30 <lt9611_hdmi_cec_write>
  115d9e:	e7ae      	b.n	115cfe <lt9611_cec_msg_tx_handle+0x32>

00115da0 <LT9611_Frequency_Meter_Byte_Clk>:

/////////////////////////////////////////////////////////////
//These function for debug: start
/////////////////////////////////////////////////////////////
void LT9611_Frequency_Meter_Byte_Clk(void)
{
  115da0:	b508      	push	{r3, r14}
    u8 temp;
    u32 reg=0x00;

    dprintf(LT9611_LOG, "\33[32m");
    /* port A byte clk meter */
    HDMI_WriteI2C_Byte(0xff,0x82);
  115da2:	2182      	movs	r1, #130	; 0x82
  115da4:	20ff      	movs	r0, #255	; 0xff
  115da6:	f000 facb 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xc7,0x03); //PortA
  115daa:	2103      	movs	r1, #3
  115dac:	20c7      	movs	r0, #199	; 0xc7
  115dae:	f000 fac7 	bl	116340 <HDMI_WriteI2C_Byte>
    mdelay(5);
  115db2:	f241 3088 	movw	r0, #5000	; 0x1388
  115db6:	f7fd fcdf 	bl	113778 <spin>
    temp = HDMI_ReadI2C_Byte(0xcd);
  115dba:	20cd      	movs	r0, #205	; 0xcd
  115dbc:	f000 fa8e 	bl	1162dc <HDMI_ReadI2C_Byte>
    if((temp&0x60)==0x60) /* clk stable */
  115dc0:	f000 0060 	and.w	r0, r0, #96	; 0x60
  115dc4:	2860      	cmp	r0, #96	; 0x60
  115dc6:	d01b      	beq.n	115e00 <LT9611_Frequency_Meter_Byte_Clk+0x60>
    else /* clk unstable */
        dprintf(LT9611_LOG, "\r\nport A byte clk unstable");


    /* port B byte clk meter */
    HDMI_WriteI2C_Byte(0xff,0x82);
  115dc8:	2182      	movs	r1, #130	; 0x82
  115dca:	20ff      	movs	r0, #255	; 0xff
  115dcc:	f000 fab8 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0xc7,0x04);
  115dd0:	2104      	movs	r1, #4
  115dd2:	20c7      	movs	r0, #199	; 0xc7
  115dd4:	f000 fab4 	bl	116340 <HDMI_WriteI2C_Byte>
    mdelay(5);
  115dd8:	f241 3088 	movw	r0, #5000	; 0x1388
  115ddc:	f7fd fccc 	bl	113778 <spin>
    temp = HDMI_ReadI2C_Byte(0xcd);
  115de0:	20cd      	movs	r0, #205	; 0xcd
  115de2:	f000 fa7b 	bl	1162dc <HDMI_ReadI2C_Byte>
    if((temp&0x60)==0x60) /* clk stable */
  115de6:	f000 0060 	and.w	r0, r0, #96	; 0x60
  115dea:	2860      	cmp	r0, #96	; 0x60
  115dec:	d000      	beq.n	115df0 <LT9611_Frequency_Meter_Byte_Clk+0x50>
        dprintf(LT9611_LOG, "\r\nport B byte clk = %d",reg);
    }
    else /* clk unstable */
           dprintf(LT9611_LOG, "\r\nport B byte clk unstable");
           dprintf(LT9611_LOG, "\033[37m\033[37m");
}
  115dee:	bd08      	pop	{r3, r15}
        temp = HDMI_ReadI2C_Byte(0xce);
  115df0:	20ce      	movs	r0, #206	; 0xce
  115df2:	f000 fa73 	bl	1162dc <HDMI_ReadI2C_Byte>
        temp = HDMI_ReadI2C_Byte(0xcf);
  115df6:	20cf      	movs	r0, #207	; 0xcf
}
  115df8:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
        temp = HDMI_ReadI2C_Byte(0xcf);
  115dfc:	f000 ba6e 	b.w	1162dc <HDMI_ReadI2C_Byte>
        temp = HDMI_ReadI2C_Byte(0xce);
  115e00:	20ce      	movs	r0, #206	; 0xce
  115e02:	f000 fa6b 	bl	1162dc <HDMI_ReadI2C_Byte>
        temp = HDMI_ReadI2C_Byte(0xcf);
  115e06:	20cf      	movs	r0, #207	; 0xcf
  115e08:	f000 fa68 	bl	1162dc <HDMI_ReadI2C_Byte>
  115e0c:	e7dc      	b.n	115dc8 <LT9611_Frequency_Meter_Byte_Clk+0x28>
  115e0e:	bf00      	nop

00115e10 <LT9611_Htotal_Sysclk>:

void LT9611_Htotal_Sysclk(void)
{
  115e10:	b510      	push	{r4, r14}
  115e12:	240a      	movs	r4, #10
#ifdef _htotal_stable_check_
    u16 reg;
    u8 loopx;
    for(loopx = 0; loopx < 10; loopx++)
    {
        HDMI_WriteI2C_Byte(0xff,0x82);
  115e14:	2182      	movs	r1, #130	; 0x82
  115e16:	20ff      	movs	r0, #255	; 0xff
  115e18:	f000 fa92 	bl	116340 <HDMI_WriteI2C_Byte>
        reg = HDMI_ReadI2C_Byte(0x86);
  115e1c:	2086      	movs	r0, #134	; 0x86
  115e1e:	f000 fa5d 	bl	1162dc <HDMI_ReadI2C_Byte>
        reg = reg*256+HDMI_ReadI2C_Byte(0x87);
  115e22:	2087      	movs	r0, #135	; 0x87
  115e24:	f000 fa5a 	bl	1162dc <HDMI_ReadI2C_Byte>
  115e28:	1e63      	subs	r3, r4, #1
    for(loopx = 0; loopx < 10; loopx++)
  115e2a:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
  115e2e:	d1f1      	bne.n	115e14 <LT9611_Htotal_Sysclk+0x4>
        dprintf(LT9611_LOG, "\r\nHtotal_Sysclk = %d", reg);
        //printdec_u32(reg);
    }
#endif
}
  115e30:	bd10      	pop	{r4, r15}
  115e32:	bf00      	nop

00115e34 <LT9611_Pcr_MK_Print>:
void LT9611_Pcr_MK_Print(void)
{
  115e34:	b538      	push	{r3, r4, r5, r14}
        dprintf(LT9611_LOG, "\r\nM:0x%x",HDMI_ReadI2C_Byte(0x97));
        dprintf(LT9611_LOG, " 0x%x",HDMI_ReadI2C_Byte(0xb4));
        dprintf(LT9611_LOG, " 0x%x",HDMI_ReadI2C_Byte(0xb5));
        dprintf(LT9611_LOG, " 0x%x",HDMI_ReadI2C_Byte(0xb6));
        dprintf(LT9611_LOG, " 0x%x",HDMI_ReadI2C_Byte(0xb7));
        mdelay(100);
  115e36:	f248 65a0 	movw	r5, #34464	; 0x86a0
{
  115e3a:	2408      	movs	r4, #8
        mdelay(100);
  115e3c:	f2c0 0501 	movt	r5, #1
        HDMI_WriteI2C_Byte(0xff,0x83);
  115e40:	2183      	movs	r1, #131	; 0x83
  115e42:	20ff      	movs	r0, #255	; 0xff
  115e44:	f000 fa7c 	bl	116340 <HDMI_WriteI2C_Byte>
        mdelay(100);
  115e48:	4628      	mov	r0, r5
  115e4a:	f7fd fc95 	bl	113778 <spin>
  115e4e:	1e63      	subs	r3, r4, #1
    for(loopx = 0; loopx < 8; loopx++)
  115e50:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
  115e54:	d1f4      	bne.n	115e40 <LT9611_Pcr_MK_Print+0xc>
    }
    #endif
}
  115e56:	bd38      	pop	{r3, r4, r5, r15}

00115e58 <LT9611_Dphy_debug>:

void LT9611_Dphy_debug(void)
{
  115e58:	b508      	push	{r3, r14}
    #ifdef _mipi_Dphy_debug_
    u8 temp;

    HDMI_WriteI2C_Byte(0xff,0x83);
  115e5a:	2183      	movs	r1, #131	; 0x83
  115e5c:	20ff      	movs	r0, #255	; 0xff
  115e5e:	f000 fa6f 	bl	116340 <HDMI_WriteI2C_Byte>
    temp = HDMI_ReadI2C_Byte(0xbc);
  115e62:	20bc      	movs	r0, #188	; 0xbc
  115e64:	f000 fa3a 	bl	1162dc <HDMI_ReadI2C_Byte>
    if(temp == 0x55)
    dprintf(LT9611_LOG, "\r\nport A lane PN is right");
    else
    dprintf(LT9611_LOG, "\r\nport A lane PN error 0x83bc = 0x%x",temp);

    temp = HDMI_ReadI2C_Byte(0x99);
  115e68:	2099      	movs	r0, #153	; 0x99
  115e6a:	f000 fa37 	bl	1162dc <HDMI_ReadI2C_Byte>
    if(temp == 0xb8)
    dprintf(LT9611_LOG, "\r\nport A lane 0 sot right ");
    else
    dprintf(LT9611_LOG, "\r\nport A lane 0 sot error = 0x%x",temp);

    temp = HDMI_ReadI2C_Byte(0x9b);
  115e6e:	209b      	movs	r0, #155	; 0x9b
  115e70:	f000 fa34 	bl	1162dc <HDMI_ReadI2C_Byte>
    if(temp == 0xb8)
    dprintf(LT9611_LOG, "\r\nport A lane 1 sot right ");
    else
    dprintf(LT9611_LOG, "\r\nport A lane 1 sot error = 0x%x",temp);

    temp = HDMI_ReadI2C_Byte(0x9d);
  115e74:	209d      	movs	r0, #157	; 0x9d
  115e76:	f000 fa31 	bl	1162dc <HDMI_ReadI2C_Byte>
    if(temp == 0xb8)
    dprintf(LT9611_LOG, "\r\nport A lane 2 sot right ");
    else
    dprintf(LT9611_LOG, "\r\nport A lane 2 sot error = 0x%x",temp);

    temp = HDMI_ReadI2C_Byte(0x9f);
  115e7a:	209f      	movs	r0, #159	; 0x9f
    dprintf(LT9611_LOG, "\r\nport A lane 1 settle = 0x%x",HDMI_ReadI2C_Byte(0x9a));
    dprintf(LT9611_LOG, "\r\nport A lane 2 settle = 0x%x",HDMI_ReadI2C_Byte(0x9c));
    dprintf(LT9611_LOG, "\r\nport A lane 3 settle = 0x%x",HDMI_ReadI2C_Byte(0x9e));

    #endif
}
  115e7c:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    temp = HDMI_ReadI2C_Byte(0x9f);
  115e80:	f000 ba2c 	b.w	1162dc <HDMI_ReadI2C_Byte>

00115e84 <LT9611_IRQ_Init>:
//These function for debug: end
/////////////////////////////////////////////////////////////


void LT9611_IRQ_Init(void) //dsren
{
  115e84:	b508      	push	{r3, r14}
    //int hpd interrupt
    HDMI_WriteI2C_Byte(0xff,0x82);
  115e86:	2182      	movs	r1, #130	; 0x82
  115e88:	20ff      	movs	r0, #255	; 0xff
  115e8a:	f000 fa59 	bl	116340 <HDMI_WriteI2C_Byte>
    //HDMI_WriteI2C_Byte(0x10,0x00); //Output low level active;
    HDMI_WriteI2C_Byte(0x58,0x0a); //Det HPD 0x0a --> 0x08 20200727
  115e8e:	210a      	movs	r1, #10
  115e90:	2058      	movs	r0, #88	; 0x58
  115e92:	f000 fa55 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x59,0x80); //HPD debounce width
  115e96:	2180      	movs	r1, #128	; 0x80
  115e98:	2059      	movs	r0, #89	; 0x59
  115e9a:	f000 fa51 	bl	116340 <HDMI_WriteI2C_Byte>

    //intial vid change interrupt
    HDMI_WriteI2C_Byte(0x9e,0xf7);
  115e9e:	21f7      	movs	r1, #247	; 0xf7
  115ea0:	209e      	movs	r0, #158	; 0x9e
}
  115ea2:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    HDMI_WriteI2C_Byte(0x9e,0xf7);
  115ea6:	f000 ba4b 	b.w	116340 <HDMI_WriteI2C_Byte>
  115eaa:	bf00      	nop

00115eac <LT9611_Enable_Interrupts>:

}

void LT9611_Enable_Interrupts(u8 interrupts, bool on)
{
     if(interrupts == HPD_INTERRUPT_ENABLE)
  115eac:	2801      	cmp	r0, #1
{
  115eae:	b510      	push	{r4, r14}
  115eb0:	460c      	mov	r4, r1
     if(interrupts == HPD_INTERRUPT_ENABLE)
  115eb2:	d03b      	beq.n	115f2c <LT9611_Enable_Interrupts+0x80>
                   HDMI_WriteI2C_Byte(0x03,0xff); //mask3  //Tx_det
                   dprintf(LT9611_LOG, "\r\nLT9611_Enable_Interrupts: hpd_irq_disable");
            }
        }

     if(interrupts == VID_CHG_INTERRUPT_ENABLE)
  115eb4:	2802      	cmp	r0, #2
  115eb6:	d11b      	bne.n	115ef0 <LT9611_Enable_Interrupts+0x44>
        {
         if(on)
            {
                HDMI_WriteI2C_Byte(0xff,0x82);
  115eb8:	2182      	movs	r1, #130	; 0x82
  115eba:	20ff      	movs	r0, #255	; 0xff
         if(on)
  115ebc:	2c00      	cmp	r4, #0
  115ebe:	d054      	beq.n	115f6a <LT9611_Enable_Interrupts+0xbe>
                HDMI_WriteI2C_Byte(0xff,0x82);
  115ec0:	f000 fa3e 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x9e,0xff); //clear vid chk irq
  115ec4:	21ff      	movs	r1, #255	; 0xff
  115ec6:	209e      	movs	r0, #158	; 0x9e
  115ec8:	f000 fa3a 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x9e,0xf7);
  115ecc:	21f7      	movs	r1, #247	; 0xf7
  115ece:	209e      	movs	r0, #158	; 0x9e
  115ed0:	f000 fa36 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x04,0xff); //clear0
  115ed4:	21ff      	movs	r1, #255	; 0xff
  115ed6:	2004      	movs	r0, #4
  115ed8:	f000 fa32 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x04,0xfe); //clear0
  115edc:	21fe      	movs	r1, #254	; 0xfe
  115ede:	2004      	movs	r0, #4
  115ee0:	f000 fa2e 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x00,0xfe); //mask0 vid_chk_IRQ
  115ee4:	21fe      	movs	r1, #254	; 0xfe
  115ee6:	2000      	movs	r0, #0
                    HDMI_WriteI2C_Byte(0x01, 0xff); //mask bit[7]
                    HDMI_WriteI2C_Byte(0x05, 0xff); //clr bit[7]
                }

        }
}
  115ee8:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                HDMI_WriteI2C_Byte(0x00,0xfe); //mask0 vid_chk_IRQ
  115eec:	f000 ba28 	b.w	116340 <HDMI_WriteI2C_Byte>
     if(interrupts == CEC_INTERRUPT_ENABLE)
  115ef0:	2803      	cmp	r0, #3
  115ef2:	d166      	bne.n	115fc2 <LT9611_Enable_Interrupts+0x116>
                    HDMI_WriteI2C_Byte(0xff, 0x86);
  115ef4:	2186      	movs	r1, #134	; 0x86
  115ef6:	20ff      	movs	r0, #255	; 0xff
            if(on)
  115ef8:	2c00      	cmp	r4, #0
  115efa:	d142      	bne.n	115f82 <LT9611_Enable_Interrupts+0xd6>
                    HDMI_WriteI2C_Byte(0xff, 0x86);
  115efc:	f000 fa20 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xfa, 0xff); //cec interrup mask
  115f00:	21ff      	movs	r1, #255	; 0xff
  115f02:	20fa      	movs	r0, #250	; 0xfa
  115f04:	f000 fa1c 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xfc, 0x7f); //cec irq clr
  115f08:	217f      	movs	r1, #127	; 0x7f
  115f0a:	20fc      	movs	r0, #252	; 0xfc
  115f0c:	f000 fa18 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xff, 0x82);
  115f10:	2182      	movs	r1, #130	; 0x82
  115f12:	20ff      	movs	r0, #255	; 0xff
  115f14:	f000 fa14 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0x01, 0xff); //mask bit[7]
  115f18:	21ff      	movs	r1, #255	; 0xff
  115f1a:	2001      	movs	r0, #1
  115f1c:	f000 fa10 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0x05, 0xff); //clr bit[7]
  115f20:	21ff      	movs	r1, #255	; 0xff
  115f22:	2005      	movs	r0, #5
}
  115f24:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                    HDMI_WriteI2C_Byte(0x05, 0xff); //clr bit[7]
  115f28:	f000 ba0a 	b.w	116340 <HDMI_WriteI2C_Byte>
               HDMI_WriteI2C_Byte(0xff,0x82);
  115f2c:	2182      	movs	r1, #130	; 0x82
  115f2e:	20ff      	movs	r0, #255	; 0xff
        if(on)
  115f30:	b17c      	cbz	r4, 115f52 <LT9611_Enable_Interrupts+0xa6>
               HDMI_WriteI2C_Byte(0xff,0x82);
  115f32:	f000 fa05 	bl	116340 <HDMI_WriteI2C_Byte>
                   HDMI_WriteI2C_Byte(0x07,0xff); //clear3
  115f36:	21ff      	movs	r1, #255	; 0xff
  115f38:	2007      	movs	r0, #7
  115f3a:	f000 fa01 	bl	116340 <HDMI_WriteI2C_Byte>
                   HDMI_WriteI2C_Byte(0x07,0x3f); //clear3
  115f3e:	213f      	movs	r1, #63	; 0x3f
  115f40:	2007      	movs	r0, #7
  115f42:	f000 f9fd 	bl	116340 <HDMI_WriteI2C_Byte>
                   HDMI_WriteI2C_Byte(0x03,0x3f); //mask3  //Tx_det
  115f46:	213f      	movs	r1, #63	; 0x3f
  115f48:	2003      	movs	r0, #3
}
  115f4a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                   HDMI_WriteI2C_Byte(0x03,0x3f); //mask3  //Tx_det
  115f4e:	f000 b9f7 	b.w	116340 <HDMI_WriteI2C_Byte>
               HDMI_WriteI2C_Byte(0xff,0x82);
  115f52:	f000 f9f5 	bl	116340 <HDMI_WriteI2C_Byte>
                   HDMI_WriteI2C_Byte(0x07,0xff); //clear3
  115f56:	21ff      	movs	r1, #255	; 0xff
  115f58:	2007      	movs	r0, #7
  115f5a:	f000 f9f1 	bl	116340 <HDMI_WriteI2C_Byte>
                   HDMI_WriteI2C_Byte(0x03,0xff); //mask3  //Tx_det
  115f5e:	21ff      	movs	r1, #255	; 0xff
  115f60:	2003      	movs	r0, #3
}
  115f62:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                   HDMI_WriteI2C_Byte(0x03,0xff); //mask3  //Tx_det
  115f66:	f000 b9eb 	b.w	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0xff,0x82);
  115f6a:	f000 f9e9 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x04,0xff); //clear0
  115f6e:	21ff      	movs	r1, #255	; 0xff
  115f70:	2004      	movs	r0, #4
  115f72:	f000 f9e5 	bl	116340 <HDMI_WriteI2C_Byte>
                HDMI_WriteI2C_Byte(0x00,0xff); //mask0 vid_chk_IRQ
  115f76:	4620      	mov	r0, r4
  115f78:	21ff      	movs	r1, #255	; 0xff
}
  115f7a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                HDMI_WriteI2C_Byte(0x00,0xff); //mask0 vid_chk_IRQ
  115f7e:	f000 b9df 	b.w	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xff, 0x86);
  115f82:	f000 f9dd 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xfa, 0x00); //cec interrup mask
  115f86:	2100      	movs	r1, #0
  115f88:	20fa      	movs	r0, #250	; 0xfa
  115f8a:	f000 f9d9 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xfc, 0x7f); //cec irq clr
  115f8e:	217f      	movs	r1, #127	; 0x7f
  115f90:	20fc      	movs	r0, #252	; 0xfc
  115f92:	f000 f9d5 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xfc, 0x00);
  115f96:	2100      	movs	r1, #0
  115f98:	20fc      	movs	r0, #252	; 0xfc
  115f9a:	f000 f9d1 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0xff, 0x82);
  115f9e:	2182      	movs	r1, #130	; 0x82
  115fa0:	20ff      	movs	r0, #255	; 0xff
  115fa2:	f000 f9cd 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0x01, 0x7f); //mask bit[7]
  115fa6:	217f      	movs	r1, #127	; 0x7f
  115fa8:	2001      	movs	r0, #1
  115faa:	f000 f9c9 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0x05, 0xff); //clr bit[7]
  115fae:	21ff      	movs	r1, #255	; 0xff
  115fb0:	2005      	movs	r0, #5
  115fb2:	f000 f9c5 	bl	116340 <HDMI_WriteI2C_Byte>
                    HDMI_WriteI2C_Byte(0x05, 0x7f);
  115fb6:	217f      	movs	r1, #127	; 0x7f
  115fb8:	2005      	movs	r0, #5
}
  115fba:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                    HDMI_WriteI2C_Byte(0x05, 0x7f);
  115fbe:	f000 b9bf 	b.w	116340 <HDMI_WriteI2C_Byte>
}
  115fc2:	bd10      	pop	{r4, r15}

00115fc4 <LT9611_HDP_Interrupt_Handle>:

void LT9611_HDP_Interrupt_Handle(void)
{
  115fc4:	b510      	push	{r4, r14}
     Tx_HPD = LT9611_Get_HPD_Status();
  115fc6:	f7ff fc8f 	bl	1158e8 <LT9611_Get_HPD_Status>
  115fca:	f243 2438 	movw	r4, #12856	; 0x3238

     HDMI_WriteI2C_Byte(0xff,0x82);
  115fce:	2182      	movs	r1, #130	; 0x82
     Tx_HPD = LT9611_Get_HPD_Status();
  115fd0:	f2c0 0413 	movt	r4, #19
  115fd4:	7020      	strb	r0, [r4, #0]
     HDMI_WriteI2C_Byte(0xff,0x82);
  115fd6:	20ff      	movs	r0, #255	; 0xff
  115fd8:	f000 f9b2 	bl	116340 <HDMI_WriteI2C_Byte>
     HDMI_WriteI2C_Byte(0x07,0xff); //clear3
  115fdc:	21ff      	movs	r1, #255	; 0xff
  115fde:	2007      	movs	r0, #7
  115fe0:	f000 f9ae 	bl	116340 <HDMI_WriteI2C_Byte>
     HDMI_WriteI2C_Byte(0x07,0x3f); //clear3
  115fe4:	213f      	movs	r1, #63	; 0x3f
  115fe6:	2007      	movs	r0, #7
  115fe8:	f000 f9aa 	bl	116340 <HDMI_WriteI2C_Byte>

     if(Tx_HPD)
  115fec:	7824      	ldrb	r4, [r4, #0]
  115fee:	b3dc      	cbz	r4, 116068 <LT9611_HDP_Interrupt_Handle+0xa4>
        {
            dprintf(LT9611_LOG, "\r\nLT9611_HDP_Interrupt_Handle: HDMI connected");
            LT9611_LowPower_mode(0);
  115ff0:	2000      	movs	r0, #0
            LT9611_Enable_Interrupts(VID_CHG_INTERRUPT_ENABLE, 1);
            mdelay(10);
            LT9611_Read_EDID();
#ifdef cec_on
            lt9611_parse_physical_address(&lt9611_cec_msg, Sink_EDID);
  115ff2:	f243 2440 	movw	r4, #12864	; 0x3240
            LT9611_LowPower_mode(0);
  115ff6:	f7fe fd75 	bl	114ae4 <LT9611_LowPower_mode>
            LT9611_Enable_Interrupts(VID_CHG_INTERRUPT_ENABLE, 1);
  115ffa:	2101      	movs	r1, #1
  115ffc:	2002      	movs	r0, #2
            lt9611_parse_physical_address(&lt9611_cec_msg, Sink_EDID);
  115ffe:	f2c0 0413 	movt	r4, #19
            LT9611_Enable_Interrupts(VID_CHG_INTERRUPT_ENABLE, 1);
  116002:	f7ff ff53 	bl	115eac <LT9611_Enable_Interrupts>
            mdelay(10);
  116006:	f242 7010 	movw	r0, #10000	; 0x2710
  11600a:	f7fd fbb5 	bl	113778 <spin>
            LT9611_Read_EDID();
  11600e:	f7ff fbaf 	bl	115770 <LT9611_Read_EDID>
            lt9611_parse_physical_address(&lt9611_cec_msg, Sink_EDID);
  116012:	f243 1138 	movw	r1, #12600	; 0x3138
  116016:	4620      	mov	r0, r4
  116018:	f2c0 0113 	movt	r1, #19
  11601c:	f7ff fd06 	bl	115a2c <lt9611_parse_physical_address>
    cec_msg->tx_data_buff[0] = 0x01; //data counter to be send
  116020:	2201      	movs	r2, #1
    logical_address = cec_msg->logical_address;
  116022:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    lt9611_hdmi_cec_write(cec_msg);
  116026:	4620      	mov	r0, r4
    cec_msg->tx_data_buff[0] = 0x01; //data counter to be send
  116028:	7462      	strb	r2, [r4, #17]
    cec_msg->tx_data_buff[1] = (logical_address<<4)|logical_address;
  11602a:	ea43 1303 	orr.w	r3, r3, r3, lsl #4
  11602e:	74a3      	strb	r3, [r4, #18]
    lt9611_hdmi_cec_write(cec_msg);
  116030:	f7ff fd7e 	bl	115b30 <lt9611_hdmi_cec_write>
            lt9611_cec_la_allocation(&lt9611_cec_msg);
#endif

        LT9611_Video_Check();
  116034:	f7fe fe2a 	bl	114c8c <LT9611_Video_Check>
        if(Video_Format != video_none)
  116038:	f243 233c 	movw	r3, #12860	; 0x323c
  11603c:	f2c0 0313 	movt	r3, #19
  116040:	681b      	ldr	r3, [r3, #0]
  116042:	2b20      	cmp	r3, #32
  116044:	d02b      	beq.n	11609e <LT9611_HDP_Interrupt_Handle+0xda>
            {
                   LT9611_PLL(video);
  116046:	f243 246c 	movw	r4, #12908	; 0x326c
  11604a:	f2c0 0413 	movt	r4, #19
  11604e:	6820      	ldr	r0, [r4, #0]
  116050:	f7ff f8ce 	bl	1151f0 <LT9611_PLL>
                   LT9611_MIPI_Pcr(video);
  116054:	6820      	ldr	r0, [r4, #0]
  116056:	f7ff f821 	bl	11509c <LT9611_MIPI_Pcr>
                   LT9611_HDMI_TX_Digital(video);
  11605a:	6820      	ldr	r0, [r4, #0]
  11605c:	f7ff fa9c 	bl	115598 <LT9611_HDMI_TX_Digital>
            LT9611_LowPower_mode(1);
#ifdef cec_on
            lt9611_cec_msg_init(&lt9611_cec_msg);
#endif
        }
}
  116060:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                   LT9611_HDMI_Out_Enable();
  116064:	f7ff ba3e 	b.w	1154e4 <LT9611_HDMI_Out_Enable>
            LT9611_Enable_Interrupts(VID_CHG_INTERRUPT_ENABLE, 0);
  116068:	4621      	mov	r1, r4
  11606a:	2002      	movs	r0, #2
  11606c:	f7ff ff1e 	bl	115eac <LT9611_Enable_Interrupts>
  116070:	f7fe fcd8 	bl	114a24 <LT9611_LowPower_mode.part.0>
  116074:	f7fe fcfe 	bl	114a74 <LT9611_HDMI_CEC_ON.part.4>
    cec_msg->physical_address = 0x2000;
  116078:	f243 2340 	movw	r3, #12864	; 0x3240
    cec_msg->logical_address = 4;
  11607c:	2204      	movs	r2, #4
    cec_msg->physical_address = 0x2000;
  11607e:	f2c0 0313 	movt	r3, #19
  116082:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    lt9611_cec_msg_set_logical_address(cec_msg);
  116086:	4618      	mov	r0, r3
    cec_msg->report_physical_address_done = 0;
  116088:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
    cec_msg->la_allocation_done = 0;
  11608c:	f883 4028 	strb.w	r4, [r3, #40]	; 0x28
    cec_msg->logical_address = 4;
  116090:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
}
  116094:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    cec_msg->physical_address = 0x2000;
  116098:	8499      	strh	r1, [r3, #36]	; 0x24
    lt9611_cec_msg_set_logical_address(cec_msg);
  11609a:	f7ff bc41 	b.w	115920 <lt9611_cec_msg_set_logical_address>
}
  11609e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                LT9611_HDMI_Out_Disable();
  1160a2:	f7ff ba67 	b.w	115574 <LT9611_HDMI_Out_Disable>
  1160a6:	bf00      	nop

001160a8 <LT9611_Vid_Chg_Interrupt_Handle>:

void LT9611_Vid_Chg_Interrupt_Handle(void)
{
  1160a8:	b510      	push	{r4, r14}

        dprintf(LT9611_LOG, "\r\nLT9611_Vid_Chg_Interrupt_Handle: ");
        #if 1
        HDMI_WriteI2C_Byte(0xff,0x82);
  1160aa:	2182      	movs	r1, #130	; 0x82
  1160ac:	20ff      	movs	r0, #255	; 0xff
  1160ae:	f000 f947 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x9e,0xff); //clear vid chk irq
  1160b2:	21ff      	movs	r1, #255	; 0xff
  1160b4:	209e      	movs	r0, #158	; 0x9e
  1160b6:	f000 f943 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x9e,0xf7);
  1160ba:	21f7      	movs	r1, #247	; 0xf7
  1160bc:	209e      	movs	r0, #158	; 0x9e
  1160be:	f000 f93f 	bl	116340 <HDMI_WriteI2C_Byte>

        HDMI_WriteI2C_Byte(0x04,0xff); //clear0 irq
  1160c2:	21ff      	movs	r1, #255	; 0xff
  1160c4:	2004      	movs	r0, #4
  1160c6:	f000 f93b 	bl	116340 <HDMI_WriteI2C_Byte>
    HDMI_WriteI2C_Byte(0x04,0xfe);
  1160ca:	21fe      	movs	r1, #254	; 0xfe
  1160cc:	2004      	movs	r0, #4
  1160ce:	f000 f937 	bl	116340 <HDMI_WriteI2C_Byte>
        #endif
        //mdelay(100);
        LT9611_Video_Check();
  1160d2:	f7fe fddb 	bl	114c8c <LT9611_Video_Check>

        if(Video_Format != video_none)
  1160d6:	f243 233c 	movw	r3, #12860	; 0x323c
  1160da:	f2c0 0313 	movt	r3, #19
  1160de:	681b      	ldr	r3, [r3, #0]
  1160e0:	2b20      	cmp	r3, #32
  1160e2:	d010      	beq.n	116106 <LT9611_Vid_Chg_Interrupt_Handle+0x5e>
        {
            LT9611_PLL(video);
  1160e4:	f243 246c 	movw	r4, #12908	; 0x326c
  1160e8:	f2c0 0413 	movt	r4, #19
  1160ec:	6820      	ldr	r0, [r4, #0]
  1160ee:	f7ff f87f 	bl	1151f0 <LT9611_PLL>
            LT9611_MIPI_Pcr(video);
  1160f2:	6820      	ldr	r0, [r4, #0]
  1160f4:	f7fe ffd2 	bl	11509c <LT9611_MIPI_Pcr>
            LT9611_HDMI_TX_Digital(video);
  1160f8:	6820      	ldr	r0, [r4, #0]
  1160fa:	f7ff fa4d 	bl	115598 <LT9611_HDMI_TX_Digital>
        else
        {
              //dprintf(LT9611_LOG, "\r\nLT9611_Vid_Chg_Interrupt_Handle: no mipi video");
                LT9611_HDMI_Out_Disable();
        }
}
  1160fe:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            LT9611_HDMI_Out_Enable();
  116102:	f7ff b9ef 	b.w	1154e4 <LT9611_HDMI_Out_Enable>
}
  116106:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
                LT9611_HDMI_Out_Disable();
  11610a:	f7ff ba33 	b.w	115574 <LT9611_HDMI_Out_Disable>
  11610e:	bf00      	nop

00116110 <lt9611_cec_msg_Interrupt_Handle>:

void lt9611_cec_msg_Interrupt_Handle(struct cec_msg *cec_msg)
{
  116110:	b510      	push	{r4, r14}
        u8 cec_status;

        HDMI_WriteI2C_Byte(0xff,0x86);
  116112:	2186      	movs	r1, #134	; 0x86
{
  116114:	4604      	mov	r4, r0
        HDMI_WriteI2C_Byte(0xff,0x86);
  116116:	20ff      	movs	r0, #255	; 0xff
  116118:	f000 f912 	bl	116340 <HDMI_WriteI2C_Byte>
        cec_status = HDMI_ReadI2C_Byte(0xd2) ;
  11611c:	20d2      	movs	r0, #210	; 0xd2
  11611e:	f000 f8dd 	bl	1162dc <HDMI_ReadI2C_Byte>

        cec_msg->cec_status = cec_status;
        dprintf(LT9611_LOG, "\nIRQ cec_status: 0x%02x",cec_status);

        HDMI_WriteI2C_Byte(0xff, 0x86);
  116122:	2186      	movs	r1, #134	; 0x86
        cec_msg->cec_status = cec_status;
  116124:	7020      	strb	r0, [r4, #0]
        HDMI_WriteI2C_Byte(0xff, 0x86);
  116126:	20ff      	movs	r0, #255	; 0xff
  116128:	f000 f90a 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xfc, 0x7f); //cec irq clr
  11612c:	217f      	movs	r1, #127	; 0x7f
  11612e:	20fc      	movs	r0, #252	; 0xfc
  116130:	f000 f906 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0xfc, 0x00);
  116134:	2100      	movs	r1, #0
  116136:	20fc      	movs	r0, #252	; 0xfc
  116138:	f000 f902 	bl	116340 <HDMI_WriteI2C_Byte>

        HDMI_WriteI2C_Byte(0xff,0x82);
  11613c:	2182      	movs	r1, #130	; 0x82
  11613e:	20ff      	movs	r0, #255	; 0xff
  116140:	f000 f8fe 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x05,0xff); //clear3
  116144:	21ff      	movs	r1, #255	; 0xff
  116146:	2005      	movs	r0, #5
  116148:	f000 f8fa 	bl	116340 <HDMI_WriteI2C_Byte>
        HDMI_WriteI2C_Byte(0x05,0x7f); //clear3
  11614c:	217f      	movs	r1, #127	; 0x7f
  11614e:	2005      	movs	r0, #5
  116150:	f000 f8f6 	bl	116340 <HDMI_WriteI2C_Byte>

        lt9611_cec_msg_tx_handle(cec_msg);
  116154:	4620      	mov	r0, r4
  116156:	f7ff fdb9 	bl	115ccc <lt9611_cec_msg_tx_handle>
    cec_status = cec_msg ->cec_status;
  11615a:	7823      	ldrb	r3, [r4, #0]
    if(cec_status&CEC_ERROR_FOLLOWER){
  11615c:	069a      	lsls	r2, r3, #26
  11615e:	d401      	bmi.n	116164 <lt9611_cec_msg_Interrupt_Handle+0x54>
    if(!(cec_status&CEC_REC_DATA)){
  116160:	079b      	lsls	r3, r3, #30
  116162:	d400      	bmi.n	116166 <lt9611_cec_msg_Interrupt_Handle+0x56>
        lt9611_cec_msg_rx_parse(cec_msg);
}
  116164:	bd10      	pop	{r4, r15}
  116166:	4620      	mov	r0, r4
  116168:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  11616c:	f7ff bd12 	b.w	115b94 <lt9611_cec_msg_rx_parse.part.5>

00116170 <LT9611_Init>:
//These function for debug: end
/////////////////////////////////////////////////////////////


int LT9611_Init(void)
{
  116170:	b510      	push	{r4, r14}
	int ret;
    //u32 cnt = 0;
    //RESET_LT9611();
    ret = LT9611_Chip_ID();
  116172:	f7fe fc9b 	bl	114aac <LT9611_Chip_ID>
    if (ret < 0)
  116176:	2800      	cmp	r0, #0
  116178:	db5c      	blt.n	116234 <LT9611_Init+0xc4>
    LT9611_MIPI_Input_Digtal();

    mdelay(100);
    LT9611_Video_Check();

    LT9611_PLL(video);
  11617a:	f243 246c 	movw	r4, #12908	; 0x326c
    LT9611_System_Init();
  11617e:	f7fe fccf 	bl	114b20 <LT9611_System_Init>
    LT9611_PLL(video);
  116182:	f2c0 0413 	movt	r4, #19
    LT9611_MIPI_Input_Analog();
  116186:	f7fe fd07 	bl	114b98 <LT9611_MIPI_Input_Analog>
    LT9611_MIPI_Input_Digtal();
  11618a:	f7fe fd3d 	bl	114c08 <LT9611_MIPI_Input_Digtal>
    mdelay(100);
  11618e:	f248 60a0 	movw	r0, #34464	; 0x86a0
  116192:	f2c0 0001 	movt	r0, #1
  116196:	f7fd faef 	bl	113778 <spin>
    LT9611_Video_Check();
  11619a:	f7fe fd77 	bl	114c8c <LT9611_Video_Check>
    LT9611_PLL(video);
  11619e:	6820      	ldr	r0, [r4, #0]
  1161a0:	f7ff f826 	bl	1151f0 <LT9611_PLL>
    LT9611_MIPI_Pcr(video); //pcr setup
  1161a4:	6820      	ldr	r0, [r4, #0]
  1161a6:	f7fe ff79 	bl	11509c <LT9611_MIPI_Pcr>

    LT9611_Audio_Init();
  1161aa:	f7ff faa3 	bl	1156f4 <LT9611_Audio_Init>
    if(lt9611.input_color_space == YUV422)
  1161ae:	f64c 03bc 	movw	r3, #51388	; 0xc8bc
  1161b2:	f2c0 0312 	movt	r3, #18
  1161b6:	7a1b      	ldrb	r3, [r3, #8]
  1161b8:	2b01      	cmp	r3, #1
  1161ba:	d038      	beq.n	11622e <LT9611_Init+0xbe>
    LT9611_CSC();
    LT9611_HDCP_Init();
  1161bc:	f7ff f94e 	bl	11545c <LT9611_HDCP_Init>
    LT9611_HDMI_TX_Digital(video);
  1161c0:	6820      	ldr	r0, [r4, #0]
  1161c2:	f7ff f9e9 	bl	115598 <LT9611_HDMI_TX_Digital>
    LT9611_HDMI_TX_Phy();
  1161c6:	f7ff f8ff 	bl	1153c8 <LT9611_HDMI_TX_Phy>

    LT9611_IRQ_Init();;
  1161ca:	f7ff fe5b 	bl	115e84 <LT9611_IRQ_Init>
  1161ce:	f7fe fc51 	bl	114a74 <LT9611_HDMI_CEC_ON.part.4>
    cec_msg->physical_address = 0x2000;
  1161d2:	f243 2340 	movw	r3, #12864	; 0x3240
    cec_msg->logical_address = 4;
  1161d6:	2204      	movs	r2, #4
    cec_msg->report_physical_address_done = 0;
  1161d8:	2400      	movs	r4, #0
    cec_msg->physical_address = 0x2000;
  1161da:	f2c0 0313 	movt	r3, #19
  1161de:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    lt9611_cec_msg_set_logical_address(cec_msg);
  1161e2:	4618      	mov	r0, r3
    cec_msg->logical_address = 4;
  1161e4:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
    cec_msg->physical_address = 0x2000;
  1161e8:	8499      	strh	r1, [r3, #36]	; 0x24
    cec_msg->report_physical_address_done = 0;
  1161ea:	f883 4029 	strb.w	r4, [r3, #41]	; 0x29
    cec_msg->la_allocation_done = 0;
  1161ee:	f883 4028 	strb.w	r4, [r3, #40]	; 0x28
    lt9611_cec_msg_set_logical_address(cec_msg);
  1161f2:	f7ff fb95 	bl	115920 <lt9611_cec_msg_set_logical_address>

//  LT9611_HDMI_CEC_ON(1);
//  lt9611_cec_msg_set_logical_address();
  lt9611_cec_msg_init(&lt9611_cec_msg);

    LT9611_Enable_Interrupts(HPD_INTERRUPT_ENABLE, 1);
  1161f6:	2101      	movs	r1, #1
  1161f8:	4608      	mov	r0, r1
  1161fa:	f7ff fe57 	bl	115eac <LT9611_Enable_Interrupts>
  LT9611_Enable_Interrupts(VID_CHG_INTERRUPT_ENABLE, 0);
  1161fe:	4621      	mov	r1, r4
  116200:	2002      	movs	r0, #2
  116202:	f7ff fe53 	bl	115eac <LT9611_Enable_Interrupts>
    LT9611_Enable_Interrupts(CEC_INTERRUPT_ENABLE, 1);
  116206:	2101      	movs	r1, #1
  116208:	2003      	movs	r0, #3
  11620a:	f7ff fe4f 	bl	115eac <LT9611_Enable_Interrupts>

    LT9611_Frequency_Meter_Byte_Clk();
  11620e:	f7ff fdc7 	bl	115da0 <LT9611_Frequency_Meter_Byte_Clk>
    LT9611_Dphy_debug();
  116212:	f7ff fe21 	bl	115e58 <LT9611_Dphy_debug>
    LT9611_Htotal_Sysclk();
  116216:	f7ff fdfb 	bl	115e10 <LT9611_Htotal_Sysclk>
    LT9611_Pcr_MK_Print();
  11621a:	f7ff fe0b 	bl	115e34 <LT9611_Pcr_MK_Print>

    dprintf(LT9611_LOG, "\r\n==========================LT9611 Initial End===============================");
    mdelay(20); //HPD have debounce, wait HPD irq.
  11621e:	f644 6020 	movw	r0, #20000	; 0x4e20
  116222:	f7fd faa9 	bl	113778 <spin>
    //while(1);
    LT9611_HDP_Interrupt_Handle();
  116226:	f7ff fecd 	bl	115fc4 <LT9611_HDP_Interrupt_Handle>
          //set_EPI;
      }

//    lt9611_cec_msg_mainloop(&lt9611_cec_msg);
    }*/
    return 0;
  11622a:	4620      	mov	r0, r4
}
  11622c:	bd10      	pop	{r4, r15}
  11622e:	f7fe fc15 	bl	114a5c <LT9611_CSC.part.2>
  116232:	e7c3      	b.n	1161bc <LT9611_Init+0x4c>
        return -1;
  116234:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  116238:	bd10      	pop	{r4, r15}
  11623a:	bf00      	nop

0011623c <LT9611_IRQ_Task>:
    clr_EPI;
}
*/

void LT9611_IRQ_Task(void)
{
  11623c:	b570      	push	{r4, r5, r6, r14}
    u8 irq_flag0;
    u8 irq_flag1;

    //dprintf(LT9611_LOG, "\r\nLT9611_IRQ_Task :IRQ Task");

    HDMI_WriteI2C_Byte(0xff,0x82);
  11623e:	2182      	movs	r1, #130	; 0x82
  116240:	20ff      	movs	r0, #255	; 0xff
  116242:	f000 f87d 	bl	116340 <HDMI_WriteI2C_Byte>

    irq_flag0=HDMI_ReadI2C_Byte(0x0c);
  116246:	200c      	movs	r0, #12
  116248:	f000 f848 	bl	1162dc <HDMI_ReadI2C_Byte>
  11624c:	4604      	mov	r4, r0
    irq_flag1=HDMI_ReadI2C_Byte(0x0d);
  11624e:	200d      	movs	r0, #13
  116250:	f000 f844 	bl	1162dc <HDMI_ReadI2C_Byte>
  116254:	4606      	mov	r6, r0
    irq_flag3=HDMI_ReadI2C_Byte(0x0f);
  116256:	200f      	movs	r0, #15
  116258:	f000 f840 	bl	1162dc <HDMI_ReadI2C_Byte>

    if((irq_flag1&0x80) == 0x80)
  11625c:	0632      	lsls	r2, r6, #24
    irq_flag3=HDMI_ReadI2C_Byte(0x0f);
  11625e:	4605      	mov	r5, r0
    if((irq_flag1&0x80) == 0x80)
  116260:	d40c      	bmi.n	11627c <LT9611_IRQ_Task+0x40>
  {
        lt9611_cec_msg_Interrupt_Handle(&lt9611_cec_msg);
    }

    if(irq_flag3&0xc0)   //HPD interrupt
  116262:	f015 0fc0 	tst.w	r5, #192	; 0xc0
  116266:	d106      	bne.n	116276 <LT9611_IRQ_Task+0x3a>
    {
        LT9611_HDP_Interrupt_Handle();
    }

    if(irq_flag0&0x01) //vid_chk
  116268:	07e3      	lsls	r3, r4, #31
  11626a:	d400      	bmi.n	11626e <LT9611_IRQ_Task+0x32>
    {
        LT9611_Vid_Chg_Interrupt_Handle();
  }
}
  11626c:	bd70      	pop	{r4, r5, r6, r15}
  11626e:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        LT9611_Vid_Chg_Interrupt_Handle();
  116272:	f7ff bf19 	b.w	1160a8 <LT9611_Vid_Chg_Interrupt_Handle>
        LT9611_HDP_Interrupt_Handle();
  116276:	f7ff fea5 	bl	115fc4 <LT9611_HDP_Interrupt_Handle>
  11627a:	e7f5      	b.n	116268 <LT9611_IRQ_Task+0x2c>
        lt9611_cec_msg_Interrupt_Handle(&lt9611_cec_msg);
  11627c:	f243 2040 	movw	r0, #12864	; 0x3240
  116280:	f2c0 0013 	movt	r0, #19
  116284:	f7ff ff44 	bl	116110 <lt9611_cec_msg_Interrupt_Handle>
  116288:	e7eb      	b.n	116262 <LT9611_IRQ_Task+0x26>
  11628a:	bf00      	nop

0011628c <lt9611_i2c_init>:
    uint16_t addr;
    uint16_t adapter;
};

int lt9611_i2c_init(uint32_t i2c_res_glb_idx, uint8_t i2c_addr)
{
  11628c:	b538      	push	{r3, r4, r5, r14}
    hal_i2c_creat_handle(&lt9611_i2c_handle, i2c_res_glb_idx);
  11628e:	f243 2474 	movw	r4, #12916	; 0x3274
{
  116292:	460d      	mov	r5, r1
    hal_i2c_creat_handle(&lt9611_i2c_handle, i2c_res_glb_idx);
  116294:	4601      	mov	r1, r0
  116296:	f2c0 0413 	movt	r4, #19
  11629a:	4620      	mov	r0, r4
  11629c:	f7f6 fa72 	bl	10c784 <hal_i2c_creat_handle>
    if (lt9611_i2c_handle == NULL){
        dprintf(0, "[err]%s(), lt9611_i2c_handle is NULL !\n", __func__);
  1162a0:	f24f 01cc 	movw	r1, #61644	; 0xf0cc
    if (lt9611_i2c_handle == NULL){
  1162a4:	6823      	ldr	r3, [r4, #0]
  1162a6:	b173      	cbz	r3, 1162c6 <lt9611_i2c_init+0x3a>
        return -1;
    }
    dprintf(0, "%s(), lt9611_i2c_handle creat succesed !\n", __func__);
  1162a8:	f24f 1028 	movw	r0, #61736	; 0xf128
  1162ac:	f2c0 0111 	movt	r1, #17
  1162b0:	f2c0 0011 	movt	r0, #17
  1162b4:	f7fe faa6 	bl	114804 <printf>
    lt9611_i2c_addr = i2c_addr;
  1162b8:	f243 2370 	movw	r3, #12912	; 0x3270

    return 0;
  1162bc:	2000      	movs	r0, #0
    lt9611_i2c_addr = i2c_addr;
  1162be:	f2c0 0313 	movt	r3, #19
  1162c2:	601d      	str	r5, [r3, #0]
}
  1162c4:	bd38      	pop	{r3, r4, r5, r15}
        dprintf(0, "[err]%s(), lt9611_i2c_handle is NULL !\n", __func__);
  1162c6:	f24f 1000 	movw	r0, #61696	; 0xf100
  1162ca:	f2c0 0111 	movt	r1, #17
  1162ce:	f2c0 0011 	movt	r0, #17
  1162d2:	f7fe fa97 	bl	114804 <printf>
        return -1;
  1162d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1162da:	bd38      	pop	{r3, r4, r5, r15}

001162dc <HDMI_ReadI2C_Byte>:
{

    uint8_t val = 0;
    int ret = 0;

    ret = lt9611_read_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, &val);
  1162dc:	f243 2170 	movw	r1, #12912	; 0x3270
  1162e0:	f243 2274 	movw	r2, #12916	; 0x3274
  1162e4:	f2c0 0113 	movt	r1, #19
  1162e8:	f2c0 0213 	movt	r2, #19
{
  1162ec:	b530      	push	{r4, r5, r14}
    ret = lt9611_read_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, &val);
  1162ee:	6809      	ldr	r1, [r1, #0]
{
  1162f0:	b085      	sub	sp, #20
    ret = hal_i2c_read_reg_data(i2c_handle, slave_addr, &reg, 1, buf, 1);
  1162f2:	2301      	movs	r3, #1
  1162f4:	ad03      	add	r5, sp, #12
    ret = lt9611_read_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, &val);
  1162f6:	6812      	ldr	r2, [r2, #0]
    memset(buf, 0, sizeof(buf));
  1162f8:	2400      	movs	r4, #0
  1162fa:	f88d 000f 	strb.w	r0, [r13, #15]
    ret = hal_i2c_read_reg_data(i2c_handle, slave_addr, &reg, 1, buf, 1);
  1162fe:	b2c9      	uxtb	r1, r1
  116300:	e9cd 5300 	strd	r5, r3, [r13]
  116304:	4610      	mov	r0, r2
    memset(buf, 0, sizeof(buf));
  116306:	f88d 400c 	strb.w	r4, [r13, #12]
    ret = hal_i2c_read_reg_data(i2c_handle, slave_addr, &reg, 1, buf, 1);
  11630a:	f10d 020f 	add.w	r2, r13, #15
  11630e:	f7f6 fc23 	bl	10cb58 <hal_i2c_read_reg_data>
    if (ret < 0) {
  116312:	42a0      	cmp	r0, r4
    *val = buf[0];
  116314:	bfa8      	it	ge
  116316:	f89d 000c 	ldrbge.w	r0, [r13, #12]
    if (ret < 0) {
  11631a:	db01      	blt.n	116320 <HDMI_ReadI2C_Byte+0x44>
    if (ret < 0)
        return 0;

    return val;
}
  11631c:	b005      	add	sp, #20
  11631e:	bd30      	pop	{r4, r5, r15}
        dprintf(0, "%s: error: read reg=%x\n", __func__, reg);
  116320:	f24f 01dc 	movw	r1, #61660	; 0xf0dc
  116324:	f24f 0098 	movw	r0, #61592	; 0xf098
  116328:	f2c0 0111 	movt	r1, #17
  11632c:	f89d 200f 	ldrb.w	r2, [r13, #15]
  116330:	f2c0 0011 	movt	r0, #17
  116334:	f7fe fa66 	bl	114804 <printf>
        return 0;
  116338:	4620      	mov	r0, r4
}
  11633a:	b005      	add	sp, #20
  11633c:	bd30      	pop	{r4, r5, r15}
  11633e:	bf00      	nop

00116340 <HDMI_WriteI2C_Byte>:

bool HDMI_WriteI2C_Byte(uint8_t RegAddr, uint8_t d)
{
    int ret = 0;

    ret = lt9611_write_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, d);
  116340:	f243 2370 	movw	r3, #12912	; 0x3270
  116344:	f243 2274 	movw	r2, #12916	; 0x3274
  116348:	f2c0 0313 	movt	r3, #19
{
  11634c:	b5f0      	push	{r4, r5, r6, r7, r14}
    ret = lt9611_write_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, d);
  11634e:	f8d3 c000 	ldr.w	r12, [r3]
{
  116352:	b085      	sub	sp, #20
    ret = hal_i2c_write_reg_data(i2c_handle, slave_addr, buf, 1, buf + 1, 1);
  116354:	2401      	movs	r4, #1
    ret = lt9611_write_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, d);
  116356:	f2c0 0213 	movt	r2, #19
{
  11635a:	4605      	mov	r5, r0
    ret = hal_i2c_write_reg_data(i2c_handle, slave_addr, buf, 1, buf + 1, 1);
  11635c:	f10d 070d 	add.w	r7, r13, #13
{
  116360:	460e      	mov	r6, r1
    ret = hal_i2c_write_reg_data(i2c_handle, slave_addr, buf, 1, buf + 1, 1);
  116362:	4623      	mov	r3, r4
    ret = lt9611_write_reg(lt9611_i2c_handle, lt9611_i2c_addr, RegAddr, d);
  116364:	6810      	ldr	r0, [r2, #0]
    ret = hal_i2c_write_reg_data(i2c_handle, slave_addr, buf, 1, buf + 1, 1);
  116366:	fa5f f18c 	uxtb.w	r1, r12
  11636a:	e9cd 7400 	strd	r7, r4, [r13]
  11636e:	aa03      	add	r2, sp, #12
    buf[0] = reg;
  116370:	f88d 500c 	strb.w	r5, [r13, #12]
    buf[1] = val;
  116374:	f88d 600d 	strb.w	r6, [r13, #13]
    ret = hal_i2c_write_reg_data(i2c_handle, slave_addr, buf, 1, buf + 1, 1);
  116378:	f7f6 fbc4 	bl	10cb04 <hal_i2c_write_reg_data>
    if (ret < 0)
  11637c:	2800      	cmp	r0, #0
    if (ret < 0)
        return false;

    return true;
  11637e:	bfa8      	it	ge
  116380:	4620      	movge	r0, r4
    if (ret < 0)
  116382:	db01      	blt.n	116388 <HDMI_WriteI2C_Byte+0x48>
}
  116384:	b005      	add	sp, #20
  116386:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "%s: error: reg=%x, val=%x\n", __func__, reg, val);
  116388:	f24f 01ec 	movw	r1, #61676	; 0xf0ec
  11638c:	f24f 00b0 	movw	r0, #61616	; 0xf0b0
  116390:	4633      	mov	r3, r6
  116392:	462a      	mov	r2, r5
  116394:	f2c0 0111 	movt	r1, #17
  116398:	f2c0 0011 	movt	r0, #17
  11639c:	f7fe fa32 	bl	114804 <printf>
        return false;
  1163a0:	2000      	movs	r0, #0
}
  1163a2:	b005      	add	sp, #20
  1163a4:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1163a6:	bf00      	nop

001163a8 <event_init>:


/*********************** event API redirection *******************/

WRAPPER_FUNCTION void event_init(event_t *e, bool initial, uint flags)
{
  1163a8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  1163aa:	4614      	mov	r4, r2

    e->pfrts_evt_handle = xQueueCreate(1,0);
  1163ac:	2200      	movs	r2, #0
{
  1163ae:	4605      	mov	r5, r0
  1163b0:	460e      	mov	r6, r1
    e->pfrts_evt_handle = xQueueCreate(1,0);
  1163b2:	2001      	movs	r0, #1
  1163b4:	4611      	mov	r1, r2
  1163b6:	4677      	mov	r7, r14
  1163b8:	f7fb fab6 	bl	111928 <xQueueGenericCreate>
  1163bc:	6028      	str	r0, [r5, #0]

    /*as freertos create event group with zero value, if init state
     *was set by parameter, in this place should call make sure the event
     *bit was set before this event to be waiting.
     */
    if(initial)
  1163be:	b936      	cbnz	r6, 1163ce <event_init+0x26>
        RESCHED_ASSERT();

        xQueueSend(e->pfrts_evt_handle,NULL,0);
    }

    e->auto_clear = (flags == EVENT_FLAG_AUTOUNSIGNAL ? pdTRUE : pdFALSE);
  1163c0:	f1a4 0401 	sub.w	r4, r4, #1
  1163c4:	fab4 f484 	clz	r4, r4
  1163c8:	0964      	lsrs	r4, r4, #5
  1163ca:	712c      	strb	r4, [r5, #4]
}
  1163cc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  1163ce:	f7fc fe0f 	bl	112ff0 <xTaskGetSchedulerState>
  1163d2:	2801      	cmp	r0, #1
  1163d4:	d0fa      	beq.n	1163cc <event_init+0x24>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1163d6:	f3ef 8300 	mrs	r3, CPSR
        RESCHED_ASSERT();
  1163da:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  1163de:	d105      	bne.n	1163ec <event_init+0x44>
        xQueueSend(e->pfrts_evt_handle,NULL,0);
  1163e0:	461a      	mov	r2, r3
  1163e2:	4619      	mov	r1, r3
  1163e4:	6828      	ldr	r0, [r5, #0]
  1163e6:	f7fb fad3 	bl	111990 <xQueueGenericSend>
  1163ea:	e7e9      	b.n	1163c0 <event_init+0x18>
        RESCHED_ASSERT();
  1163ec:	f24f 1254 	movw	r2, #61780	; 0xf154
  1163f0:	f24f 1174 	movw	r1, #61812	; 0xf174
  1163f4:	4638      	mov	r0, r7
  1163f6:	f2c0 0211 	movt	r2, #17
  1163fa:	2321      	movs	r3, #33	; 0x21
  1163fc:	f2c0 0111 	movt	r1, #17
  116400:	f7fd f9cc 	bl	11379c <_panic>

00116404 <event_wait_timeout>:
{
    vQueueDelete(e->pfrts_evt_handle);
}

WRAPPER_FUNCTION status_t event_wait_timeout(event_t *e, lk_time_t timeout) /* wait on the event with a timeout */
{
  116404:	b570      	push	{r4, r5, r6, r14}
  116406:	4675      	mov	r5, r14
  116408:	4606      	mov	r6, r0
  11640a:	460c      	mov	r4, r1
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  11640c:	f7fc fdf0 	bl	112ff0 <xTaskGetSchedulerState>
  116410:	2801      	cmp	r0, #1
  116412:	d01c      	beq.n	11644e <event_wait_timeout+0x4a>
    return NO_ERROR;

    TickType_t xTicksToWait = (timeout == INFINITE_TIME ? portMAX_DELAY : LKMS_TO_FRTS_TICK(timeout));
  116414:	1c63      	adds	r3, r4, #1
  116416:	bf1b      	ittet	ne
  116418:	f644 51d3 	movwne	r1, #19923	; 0x4dd3
  11641c:	ebc4 1244 	rsbne	r2, r4, r4, lsl #5
  116420:	4622      	moveq	r2, r4
  116422:	f2c1 0162 	movtne	r1, #4194	; 0x1062
  116426:	bf1f      	itttt	ne
  116428:	eb04 0282 	addne.w	r2, r4, r2, lsl #2
  11642c:	00d2      	lslne	r2, r2, #3
  11642e:	fba1 3202 	umullne	r3, r2, r1, r2
  116432:	0992      	lsrne	r2, r2, #6
  116434:	f3ef 8100 	mrs	r1, CPSR

    BaseType_t ret = pdFALSE;

    RESCHED_ASSERT();
  116438:	f011 0180 	ands.w	r1, r1, #128	; 0x80
  11643c:	d10f      	bne.n	11645e <event_wait_timeout+0x5a>
  11643e:	6830      	ldr	r0, [r6, #0]

    if(e->auto_clear)
  116440:	7933      	ldrb	r3, [r6, #4]
  116442:	b933      	cbnz	r3, 116452 <event_wait_timeout+0x4e>
    {
        ret = xQueueReceive(e->pfrts_evt_handle,NULL,xTicksToWait);
    }
    else
    {
        ret = xQueuePeek(e->pfrts_evt_handle,NULL,xTicksToWait);
  116444:	4619      	mov	r1, r3
  116446:	f7fb fd7b 	bl	111f40 <xQueuePeek>
    }

    return (ret == pdTRUE ? NO_ERROR : ERR_TIMED_OUT);
  11644a:	2801      	cmp	r0, #1
  11644c:	d104      	bne.n	116458 <event_wait_timeout+0x54>
    return NO_ERROR;
  11644e:	2000      	movs	r0, #0
}
  116450:	bd70      	pop	{r4, r5, r6, r15}
        ret = xQueueReceive(e->pfrts_evt_handle,NULL,xTicksToWait);
  116452:	f7fb fc01 	bl	111c58 <xQueueReceive>
  116456:	e7f8      	b.n	11644a <event_wait_timeout+0x46>
    return (ret == pdTRUE ? NO_ERROR : ERR_TIMED_OUT);
  116458:	f06f 000c 	mvn.w	r0, #12
}
  11645c:	bd70      	pop	{r4, r5, r6, r15}
    RESCHED_ASSERT();
  11645e:	f24f 1254 	movw	r2, #61780	; 0xf154
  116462:	f24f 1174 	movw	r1, #61812	; 0xf174
  116466:	4628      	mov	r0, r5
  116468:	f2c0 0211 	movt	r2, #17
  11646c:	2337      	movs	r3, #55	; 0x37
  11646e:	f2c0 0111 	movt	r1, #17
  116472:	f7fd f993 	bl	11379c <_panic>
  116476:	bf00      	nop

00116478 <event_signal>:

WRAPPER_FUNCTION status_t event_signal(event_t *e, bool reschedule)
{
  116478:	b530      	push	{r4, r5, r14}
  11647a:	4675      	mov	r5, r14
  11647c:	b083      	sub	sp, #12
  11647e:	4604      	mov	r4, r0
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  116480:	f7fc fdb6 	bl	112ff0 <xTaskGetSchedulerState>
  116484:	2801      	cmp	r0, #1
  116486:	d00f      	beq.n	1164a8 <event_signal+0x30>
    /*in freertos, a set of event may autoresch
     *if there is a blocked task is waiting for
     *this event. So caller should treat this as resched as always.
     */

    if(ulPortInterruptNesting > 0)
  116488:	f640 13b0 	movw	r3, #2480	; 0x9b0
  11648c:	f2c0 0313 	movt	r3, #19
  116490:	681b      	ldr	r3, [r3, #0]
  116492:	b963      	cbnz	r3, 1164ae <event_signal+0x36>
  116494:	f3ef 8300 	mrs	r3, CPSR
    else
    {
        /* Here is in task context. call classic API. */
        /* We still need to check if in spinlocked state, as no bottom scetion may
         * take responsiblity to do deferred resched. */
        RESCHED_ASSERT();
  116498:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  11649c:	d11b      	bne.n	1164d6 <event_signal+0x5e>

        xQueueSend(e->pfrts_evt_handle,NULL,0);
  11649e:	6820      	ldr	r0, [r4, #0]
  1164a0:	461a      	mov	r2, r3
  1164a2:	4619      	mov	r1, r3
  1164a4:	f7fb fa74 	bl	111990 <xQueueGenericSend>
    }

    return NO_ERROR;
}
  1164a8:	2000      	movs	r0, #0
  1164aa:	b003      	add	sp, #12
  1164ac:	bd30      	pop	{r4, r5, r15}
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  1164ae:	2300      	movs	r3, #0
  1164b0:	aa02      	add	r2, sp, #8
        xQueueSendFromISR(e->pfrts_evt_handle,NULL,&xHigherPriorityTaskWoken);
  1164b2:	6820      	ldr	r0, [r4, #0]
  1164b4:	4619      	mov	r1, r3
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  1164b6:	f842 3d04 	str.w	r3, [r2, #-4]!
        xQueueSendFromISR(e->pfrts_evt_handle,NULL,&xHigherPriorityTaskWoken);
  1164ba:	f7fb fb4d 	bl	111b58 <xQueueGenericSendFromISR>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  1164be:	9b01      	ldr	r3, [sp, #4]
  1164c0:	2b00      	cmp	r3, #0
  1164c2:	d0f1      	beq.n	1164a8 <event_signal+0x30>
  1164c4:	f640 13b8 	movw	r3, #2488	; 0x9b8
  1164c8:	2201      	movs	r2, #1
}
  1164ca:	2000      	movs	r0, #0
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  1164cc:	f2c0 0313 	movt	r3, #19
  1164d0:	601a      	str	r2, [r3, #0]
}
  1164d2:	b003      	add	sp, #12
  1164d4:	bd30      	pop	{r4, r5, r15}
        RESCHED_ASSERT();
  1164d6:	f24f 1254 	movw	r2, #61780	; 0xf154
  1164da:	f24f 1174 	movw	r1, #61812	; 0xf174
  1164de:	4628      	mov	r0, r5
  1164e0:	f2c0 0211 	movt	r2, #17
  1164e4:	2360      	movs	r3, #96	; 0x60
  1164e6:	f2c0 0111 	movt	r1, #17
  1164ea:	f7fd f957 	bl	11379c <_panic>
  1164ee:	bf00      	nop

001164f0 <event_unsignal>:

WRAPPER_FUNCTION status_t event_unsignal(event_t *e)
{
  1164f0:	b538      	push	{r3, r4, r5, r14}
  1164f2:	4675      	mov	r5, r14
  1164f4:	4604      	mov	r4, r0
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  1164f6:	f7fc fd7b 	bl	112ff0 <xTaskGetSchedulerState>
  1164fa:	2801      	cmp	r0, #1
  1164fc:	d008      	beq.n	116510 <event_unsignal+0x20>
    return NO_ERROR;

    ISR_ASSERT();
  1164fe:	f640 13b0 	movw	r3, #2480	; 0x9b0
  116502:	f2c0 0313 	movt	r3, #19
  116506:	6819      	ldr	r1, [r3, #0]
  116508:	b921      	cbnz	r1, 116514 <event_unsignal+0x24>

    xQueueReset(e->pfrts_evt_handle);
  11650a:	6820      	ldr	r0, [r4, #0]
  11650c:	f7fb f966 	bl	1117dc <xQueueGenericReset>


    return NO_ERROR;
}
  116510:	2000      	movs	r0, #0
  116512:	bd38      	pop	{r3, r4, r5, r15}
    ISR_ASSERT();
  116514:	f24f 1254 	movw	r2, #61780	; 0xf154
  116518:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  11651c:	4628      	mov	r0, r5
  11651e:	f2c0 0211 	movt	r2, #17
  116522:	236d      	movs	r3, #109	; 0x6d
  116524:	f2c0 0111 	movt	r1, #17
  116528:	f7fd f938 	bl	11379c <_panic>

0011652c <mutex_init>:
#include <lk_wrapper.h>

/*********************** mutex API redirection *******************/

WRAPPER_FUNCTION void mutex_init(mutex_t *mutex)
{
  11652c:	b510      	push	{r4, r14}
  11652e:	4604      	mov	r4, r0
    *mutex = xSemaphoreCreateMutex();
  116530:	2001      	movs	r0, #1
  116532:	f7fb fafd 	bl	111b30 <xQueueCreateMutex>
  116536:	6020      	str	r0, [r4, #0]
    DEBUG_ASSERT(*mutex);
}
  116538:	bd10      	pop	{r4, r15}
  11653a:	bf00      	nop

0011653c <mutex_destroy>:

WRAPPER_FUNCTION void mutex_destroy(mutex_t *mutex)
{
  11653c:	b510      	push	{r4, r14}
  11653e:	4604      	mov	r4, r0
    vSemaphoreDelete(*mutex);
  116540:	6800      	ldr	r0, [r0, #0]
  116542:	f7fb fda1 	bl	112088 <vQueueDelete>
    *mutex = NULL;
  116546:	2300      	movs	r3, #0
  116548:	6023      	str	r3, [r4, #0]
}
  11654a:	bd10      	pop	{r4, r15}

0011654c <mutex_acquire_timeout>:

WRAPPER_FUNCTION status_t mutex_acquire_timeout(mutex_t *mutex, lk_time_t timeout) /* try to acquire the mutex with a timeout value */
{
  11654c:	b570      	push	{r4, r5, r6, r14}
  11654e:	4676      	mov	r6, r14
  116550:	4605      	mov	r5, r0
  116552:	460c      	mov	r4, r1
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  116554:	f7fc fd4c 	bl	112ff0 <xTaskGetSchedulerState>
  116558:	2801      	cmp	r0, #1
  11655a:	d01e      	beq.n	11659a <mutex_acquire_timeout+0x4e>
    return NO_ERROR;

    ISR_ASSERT();
  11655c:	f640 13b0 	movw	r3, #2480	; 0x9b0
  116560:	f2c0 0313 	movt	r3, #19
  116564:	681b      	ldr	r3, [r3, #0]
  116566:	bb4b      	cbnz	r3, 1165bc <mutex_acquire_timeout+0x70>
  116568:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  11656c:	061a      	lsls	r2, r3, #24
  11656e:	d419      	bmi.n	1165a4 <mutex_acquire_timeout+0x58>

    BaseType_t ret = xSemaphoreTake(*mutex, (timeout == INFINITE_TIME ? portMAX_DELAY : LKMS_TO_FRTS_TICK(timeout) ));
  116570:	6828      	ldr	r0, [r5, #0]
  116572:	1c63      	adds	r3, r4, #1
  116574:	bf1b      	ittet	ne
  116576:	f644 53d3 	movwne	r3, #19923	; 0x4dd3
  11657a:	ebc4 1144 	rsbne	r1, r4, r4, lsl #5
  11657e:	4621      	moveq	r1, r4
  116580:	f2c1 0362 	movtne	r3, #4194	; 0x1062
  116584:	bf1f      	itttt	ne
  116586:	eb04 0181 	addne.w	r1, r4, r1, lsl #2
  11658a:	00c9      	lslne	r1, r1, #3
  11658c:	fba3 3101 	umullne	r3, r1, r3, r1
  116590:	0989      	lsrne	r1, r1, #6
  116592:	f7fb fc0b 	bl	111dac <xQueueSemaphoreTake>
    return (pdTRUE == ret ? NO_ERROR : ERR_TIMED_OUT);
  116596:	2801      	cmp	r0, #1
  116598:	d101      	bne.n	11659e <mutex_acquire_timeout+0x52>
    return NO_ERROR;
  11659a:	2000      	movs	r0, #0
}
  11659c:	bd70      	pop	{r4, r5, r6, r15}
    return (pdTRUE == ret ? NO_ERROR : ERR_TIMED_OUT);
  11659e:	f06f 000c 	mvn.w	r0, #12
}
  1165a2:	bd70      	pop	{r4, r5, r6, r15}
    RESCHED_ASSERT();
  1165a4:	f24f 12cc 	movw	r2, #61900	; 0xf1cc
  1165a8:	f24f 1174 	movw	r1, #61812	; 0xf174
  1165ac:	4630      	mov	r0, r6
  1165ae:	f2c0 0211 	movt	r2, #17
  1165b2:	2321      	movs	r3, #33	; 0x21
  1165b4:	f2c0 0111 	movt	r1, #17
  1165b8:	f7fd f8f0 	bl	11379c <_panic>
    ISR_ASSERT();
  1165bc:	f24f 12cc 	movw	r2, #61900	; 0xf1cc
  1165c0:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  1165c4:	4630      	mov	r0, r6
  1165c6:	f2c0 0211 	movt	r2, #17
  1165ca:	231f      	movs	r3, #31
  1165cc:	f2c0 0111 	movt	r1, #17
  1165d0:	f7fd f8e4 	bl	11379c <_panic>

001165d4 <mutex_release>:

WRAPPER_FUNCTION status_t mutex_release(mutex_t *mutex)
{
  1165d4:	b538      	push	{r3, r4, r5, r14}
  1165d6:	4675      	mov	r5, r14
  1165d8:	4604      	mov	r4, r0
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  1165da:	f7fc fd09 	bl	112ff0 <xTaskGetSchedulerState>
  1165de:	2801      	cmp	r0, #1
  1165e0:	d011      	beq.n	116606 <mutex_release+0x32>
    return NO_ERROR;

    ISR_ASSERT();
  1165e2:	f640 13b0 	movw	r3, #2480	; 0x9b0
  1165e6:	f2c0 0313 	movt	r3, #19
  1165ea:	681b      	ldr	r3, [r3, #0]
  1165ec:	b9e3      	cbnz	r3, 116628 <mutex_release+0x54>
  1165ee:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  1165f2:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  1165f6:	d10b      	bne.n	116610 <mutex_release+0x3c>

    BaseType_t ret = xSemaphoreGive(*mutex);
  1165f8:	6820      	ldr	r0, [r4, #0]
  1165fa:	461a      	mov	r2, r3
  1165fc:	4619      	mov	r1, r3
  1165fe:	f7fb f9c7 	bl	111990 <xQueueGenericSend>
    return (pdTRUE == ret ? NO_ERROR : ERR_TIMED_OUT);
  116602:	2801      	cmp	r0, #1
  116604:	d101      	bne.n	11660a <mutex_release+0x36>
    return NO_ERROR;
  116606:	2000      	movs	r0, #0
}
  116608:	bd38      	pop	{r3, r4, r5, r15}
    return (pdTRUE == ret ? NO_ERROR : ERR_TIMED_OUT);
  11660a:	f06f 000c 	mvn.w	r0, #12
}
  11660e:	bd38      	pop	{r3, r4, r5, r15}
    RESCHED_ASSERT();
  116610:	f24f 12cc 	movw	r2, #61900	; 0xf1cc
  116614:	f24f 1174 	movw	r1, #61812	; 0xf174
  116618:	4628      	mov	r0, r5
  11661a:	f2c0 0211 	movt	r2, #17
  11661e:	232e      	movs	r3, #46	; 0x2e
  116620:	f2c0 0111 	movt	r1, #17
  116624:	f7fd f8ba 	bl	11379c <_panic>
    ISR_ASSERT();
  116628:	f24f 12cc 	movw	r2, #61900	; 0xf1cc
  11662c:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  116630:	4628      	mov	r0, r5
  116632:	f2c0 0211 	movt	r2, #17
  116636:	232c      	movs	r3, #44	; 0x2c
  116638:	f2c0 0111 	movt	r1, #17
  11663c:	f7fd f8ae 	bl	11379c <_panic>

00116640 <task_dispatch>:
    thread_start_routine entry;
    void* arg;
};

static void task_dispatch(void* arg)
{
  116640:	b510      	push	{r4, r14}
  116642:	4604      	mov	r4, r0
    struct task_dispatcher_t* dispatcher = (struct task_dispatcher_t*) arg;

#if ARM_WITH_VFP==1
    //enable fpu context save/restore
    portTASK_USES_FLOATING_POINT();
  116644:	f7fa fd6c 	bl	111120 <vPortTaskUsesFPU>
#endif

    dispatcher->entry(dispatcher->arg);
  116648:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
  11664c:	4798      	blx	r3

    /* Task should not reach here in FreeRTOS programming model in theory,
    But as we are LK now, we could reach here if thread return.
    But we need to recycle the memory we used then delete itself. */

    vPortFree(dispatcher->task_handle);
  11664e:	6820      	ldr	r0, [r4, #0]
  116650:	f7fa ff34 	bl	1114bc <vPortFree>
    vPortFree(dispatcher);
  116654:	4620      	mov	r0, r4
  116656:	f7fa ff31 	bl	1114bc <vPortFree>
    vTaskDelete(NULL);
  11665a:	2000      	movs	r0, #0
}
  11665c:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    vTaskDelete(NULL);
  116660:	f7fc b826 	b.w	1126b0 <vTaskDelete>

00116664 <thread_create>:


WRAPPER_FUNCTION thread_t* thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size)
{
  116664:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  116668:	4680      	mov	r8, r0
  11666a:	b082      	sub	sp, #8

    TaskHandle_t* task = pvPortMalloc(sizeof(TaskHandle_t));
  11666c:	2004      	movs	r0, #4
  11666e:	46f2      	mov	r10, r14
{
  116670:	460e      	mov	r6, r1
  116672:	4617      	mov	r7, r2
  116674:	4699      	mov	r9, r3
    TaskHandle_t* task = pvPortMalloc(sizeof(TaskHandle_t));
  116676:	f7fa ff6f 	bl	111558 <pvPortMalloc>
    ASSERT(task);
  11667a:	b320      	cbz	r0, 1166c6 <thread_create+0x62>
  11667c:	4604      	mov	r4, r0

    struct task_dispatcher_t* dispatcher = pvPortMalloc(sizeof(struct task_dispatcher_t));
  11667e:	200c      	movs	r0, #12
  116680:	f7fa ff6a 	bl	111558 <pvPortMalloc>
    ASSERT(dispatcher);
  116684:	4605      	mov	r5, r0
  116686:	b378      	cbz	r0, 1166e8 <thread_create+0x84>
     * as same as LK programming model.
     */

    /* Pass 0 as priority to make sure the task to be created will not preempt
     * current thread. Setback after suspended. */
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  116688:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  11668a:	2300      	movs	r3, #0
    dispatcher->task_handle = task;
  11668c:	6004      	str	r4, [r0, #0]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  11668e:	4641      	mov	r1, r8
    dispatcher->arg = arg;
  116690:	6087      	str	r7, [r0, #8]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  116692:	3203      	adds	r2, #3
  116694:	f246 6041 	movw	r0, #26177	; 0x6641
  116698:	f3c2 028f 	ubfx	r2, r2, #2, #16
    dispatcher->entry = entry;
  11669c:	606e      	str	r6, [r5, #4]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  11669e:	f2c0 0011 	movt	r0, #17
  1166a2:	9300      	str	r3, [sp, #0]
  1166a4:	462b      	mov	r3, r5
  1166a6:	9401      	str	r4, [sp, #4]
  1166a8:	f7fb ffce 	bl	112648 <xTaskCreate>

    if(pdFALSE == ret)
  1166ac:	4606      	mov	r6, r0
  1166ae:	b360      	cbz	r0, 11670a <thread_create+0xa6>
    /*as lk place new thread in suspend list(not ready),
    * frts place new task in ready list default(waiting for sch),
    * we manually migrate it into suspend list from ready list
    * in FreeRTOS.
    */
    vTaskSuspend(*task);
  1166b0:	6820      	ldr	r0, [r4, #0]
  1166b2:	f7fc f8ef 	bl	112894 <vTaskSuspend>

    /* Set back to wanted priority. */
    vTaskPrioritySet(*task,(UBaseType_t)priority);
  1166b6:	6820      	ldr	r0, [r4, #0]
  1166b8:	4649      	mov	r1, r9
  1166ba:	f7fc f877 	bl	1127ac <vTaskPrioritySet>

    return (thread_t*)task;
}
  1166be:	4620      	mov	r0, r4
  1166c0:	b002      	add	sp, #8
  1166c2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    ASSERT(task);
  1166c6:	f24f 230c 	movw	r3, #61964	; 0xf20c
  1166ca:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  1166ce:	f647 4134 	movw	r1, #31796	; 0x7c34
  1166d2:	f2c0 0311 	movt	r3, #17
  1166d6:	4650      	mov	r0, r10
  1166d8:	f2c0 0211 	movt	r2, #17
  1166dc:	9300      	str	r3, [sp, #0]
  1166de:	f2c0 0111 	movt	r1, #17
  1166e2:	2332      	movs	r3, #50	; 0x32
  1166e4:	f7fd f85a 	bl	11379c <_panic>
    ASSERT(dispatcher);
  1166e8:	f24f 2314 	movw	r3, #61972	; 0xf214
  1166ec:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  1166f0:	f647 4134 	movw	r1, #31796	; 0x7c34
  1166f4:	f2c0 0311 	movt	r3, #17
  1166f8:	4650      	mov	r0, r10
  1166fa:	f2c0 0211 	movt	r2, #17
  1166fe:	9300      	str	r3, [sp, #0]
  116700:	f2c0 0111 	movt	r1, #17
  116704:	2335      	movs	r3, #53	; 0x35
  116706:	f7fd f849 	bl	11379c <_panic>
        vPortFree(dispatcher);
  11670a:	4628      	mov	r0, r5
  11670c:	f7fa fed6 	bl	1114bc <vPortFree>
        vPortFree(task);
  116710:	4620      	mov	r0, r4
  116712:	f7fa fed3 	bl	1114bc <vPortFree>
        return NULL;
  116716:	4634      	mov	r4, r6
  116718:	e7d1      	b.n	1166be <thread_create+0x5a>
  11671a:	bf00      	nop

0011671c <thread_sleep>:

WRAPPER_FUNCTION void thread_sleep(lk_time_t delay)
{
  11671c:	b508      	push	{r3, r14}
    ISR_ASSERT();
  11671e:	f640 13b0 	movw	r3, #2480	; 0x9b0
  116722:	f2c0 0313 	movt	r3, #19
  116726:	681b      	ldr	r3, [r3, #0]
  116728:	b99b      	cbnz	r3, 116752 <thread_sleep+0x36>
  11672a:	f3ef 8300 	mrs	r3, CPSR
    RESCHED_ASSERT();
  11672e:	061b      	lsls	r3, r3, #24
  116730:	d41b      	bmi.n	11676a <thread_sleep+0x4e>

    vTaskDelay(LKMS_TO_FRTS_TICK(delay));
  116732:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  116736:	ebc0 1240 	rsb	r2, r0, r0, lsl #5
  11673a:	f2c1 0362 	movt	r3, #4194	; 0x1062
  11673e:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  116742:	00c0      	lsls	r0, r0, #3
  116744:	fba3 3000 	umull	r3, r0, r3, r0
}
  116748:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    vTaskDelay(LKMS_TO_FRTS_TICK(delay));
  11674c:	0980      	lsrs	r0, r0, #6
  11674e:	f7fc bb21 	b.w	112d94 <vTaskDelay>
    ISR_ASSERT();
  116752:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  116756:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  11675a:	4670      	mov	r0, r14
  11675c:	f2c0 0211 	movt	r2, #17
  116760:	235a      	movs	r3, #90	; 0x5a
  116762:	f2c0 0111 	movt	r1, #17
  116766:	f7fd f819 	bl	11379c <_panic>
    RESCHED_ASSERT();
  11676a:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  11676e:	f24f 1174 	movw	r1, #61812	; 0xf174
  116772:	4670      	mov	r0, r14
  116774:	f2c0 0211 	movt	r2, #17
  116778:	235b      	movs	r3, #91	; 0x5b
  11677a:	f2c0 0111 	movt	r1, #17
  11677e:	f7fd f80d 	bl	11379c <_panic>
  116782:	bf00      	nop

00116784 <thread_resume>:
     * pxCurrentTCB which is NULL. Werid concern: No validity check
     * while compare priority between pxTCB and pxCurrentTCB in case of
     * pxCurrentTCB was NULL.
    */

    ISR_ASSERT();
  116784:	f640 13b0 	movw	r3, #2480	; 0x9b0
  116788:	f2c0 0313 	movt	r3, #19
{
  11678c:	b510      	push	{r4, r14}
    ISR_ASSERT();
  11678e:	681b      	ldr	r3, [r3, #0]
  116790:	b94b      	cbnz	r3, 1167a6 <thread_resume+0x22>
  116792:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  116796:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  11679a:	d110      	bne.n	1167be <thread_resume+0x3a>

    vTaskResume(*task);
  11679c:	6800      	ldr	r0, [r0, #0]
  11679e:	f7fc f907 	bl	1129b0 <vTaskResume>


    return NO_ERROR;
}
  1167a2:	4620      	mov	r0, r4
  1167a4:	bd10      	pop	{r4, r15}
    ISR_ASSERT();
  1167a6:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  1167aa:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  1167ae:	4670      	mov	r0, r14
  1167b0:	f2c0 0211 	movt	r2, #17
  1167b4:	237b      	movs	r3, #123	; 0x7b
  1167b6:	f2c0 0111 	movt	r1, #17
  1167ba:	f7fc ffef 	bl	11379c <_panic>
    RESCHED_ASSERT();
  1167be:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  1167c2:	f24f 1174 	movw	r1, #61812	; 0xf174
  1167c6:	4670      	mov	r0, r14
  1167c8:	f2c0 0211 	movt	r2, #17
  1167cc:	237d      	movs	r3, #125	; 0x7d
  1167ce:	f2c0 0111 	movt	r1, #17
  1167d2:	f7fc ffe3 	bl	11379c <_panic>
  1167d6:	bf00      	nop

001167d8 <thread_detach>:

WRAPPER_FUNCTION status_t thread_detach(thread_t *t)
{
    TaskHandle_t* task = (TaskHandle_t*)t;

    ISR_ASSERT();
  1167d8:	f640 13b0 	movw	r3, #2480	; 0x9b0
  1167dc:	f2c0 0313 	movt	r3, #19
{
  1167e0:	b510      	push	{r4, r14}
    ISR_ASSERT();
  1167e2:	681b      	ldr	r3, [r3, #0]
  1167e4:	b94b      	cbnz	r3, 1167fa <thread_detach+0x22>
  1167e6:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  1167ea:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  1167ee:	d110      	bne.n	116812 <thread_detach+0x3a>

    vTaskSuspend(*task);
  1167f0:	6800      	ldr	r0, [r0, #0]
  1167f2:	f7fc f84f 	bl	112894 <vTaskSuspend>
    return NO_ERROR;
}
  1167f6:	4620      	mov	r0, r4
  1167f8:	bd10      	pop	{r4, r15}
    ISR_ASSERT();
  1167fa:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  1167fe:	f24f 11a4 	movw	r1, #61860	; 0xf1a4
  116802:	4670      	mov	r0, r14
  116804:	f2c0 0211 	movt	r2, #17
  116808:	2389      	movs	r3, #137	; 0x89
  11680a:	f2c0 0111 	movt	r1, #17
  11680e:	f7fc ffc5 	bl	11379c <_panic>
    RESCHED_ASSERT();
  116812:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
  116816:	f24f 1174 	movw	r1, #61812	; 0xf174
  11681a:	4670      	mov	r0, r14
  11681c:	f2c0 0211 	movt	r2, #17
  116820:	238b      	movs	r3, #139	; 0x8b
  116822:	f2c0 0111 	movt	r1, #17
  116826:	f7fc ffb9 	bl	11379c <_panic>
  11682a:	bf00      	nop

0011682c <thread_detach_and_resume>:

WRAPPER_FUNCTION status_t thread_detach_and_resume(thread_t *t)
{
  11682c:	b510      	push	{r4, r14}
  11682e:	4604      	mov	r4, r0
    thread_detach(t);
  116830:	f7ff ffd2 	bl	1167d8 <thread_detach>
    thread_resume(t);
  116834:	4620      	mov	r0, r4
  116836:	f7ff ffa5 	bl	116784 <thread_resume>
    return NO_ERROR;
}
  11683a:	2000      	movs	r0, #0
  11683c:	bd10      	pop	{r4, r15}
  11683e:	bf00      	nop

00116840 <cbuf_initialize>:

#define INC_POINTER(cbuf, ptr, inc) \
    modpow2(((ptr) + (inc)), (cbuf)->len_pow2)

void cbuf_initialize(cbuf_t *cbuf, size_t len)
{
  116840:	b570      	push	{r4, r5, r6, r14}
  116842:	4604      	mov	r4, r0
  116844:	b082      	sub	sp, #8
    void *buf = malloc(len);
  116846:	4608      	mov	r0, r1
{
  116848:	460d      	mov	r5, r1
  11684a:	4676      	mov	r6, r14
    void *buf = malloc(len);
  11684c:	f7fa fe80 	bl	111550 <malloc>

    if (!buf) {
  116850:	b1a0      	cbz	r0, 11687c <cbuf_initialize+0x3c>
{
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(len > 0);
    DEBUG_ASSERT(ispow2(len));

    cbuf->head = 0;
  116852:	2200      	movs	r2, #0
  116854:	4603      	mov	r3, r0
    cbuf->tail = 0;
  116856:	e9c4 2200 	strd	r2, r2, [r4]
    return ((val - 1) & val) == 0;
}

static inline __ALWAYS_INLINE uint log2_uint(uint val)
{
    if (val == 0)
  11685a:	b11d      	cbz	r5, 116864 <cbuf_initialize+0x24>
        return 0; // undefined

    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
  11685c:	fab5 f585 	clz	r5, r5
  116860:	f1c5 051f 	rsb	r5, r5, #31
    cbuf->len_pow2 = log2_uint(len);
    cbuf->buf = buf;
    event_init(&cbuf->event, false, 0);
  116864:	2200      	movs	r2, #0
  116866:	f104 0010 	add.w	r0, r4, #16
    cbuf->buf = buf;
  11686a:	60e3      	str	r3, [r4, #12]
    event_init(&cbuf->event, false, 0);
  11686c:	4611      	mov	r1, r2
    cbuf->len_pow2 = log2_uint(len);
  11686e:	60a5      	str	r5, [r4, #8]
    event_init(&cbuf->event, false, 0);
  116870:	f7ff fd9a 	bl	1163a8 <event_init>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  116874:	2300      	movs	r3, #0
  116876:	61a3      	str	r3, [r4, #24]
}
  116878:	b002      	add	sp, #8
  11687a:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(0, "No memory for cbuf\n");
  11687c:	f24f 2020 	movw	r0, #61984	; 0xf220
  116880:	f2c0 0011 	movt	r0, #17
  116884:	f7fd ffa6 	bl	1147d4 <puts>
        ASSERT(0);
  116888:	f649 0384 	movw	r3, #39044	; 0x9884
  11688c:	f24f 2234 	movw	r2, #62004	; 0xf234
  116890:	f2c0 0311 	movt	r3, #17
  116894:	f647 4134 	movw	r1, #31796	; 0x7c34
  116898:	4630      	mov	r0, r6
  11689a:	9300      	str	r3, [sp, #0]
  11689c:	f2c0 0211 	movt	r2, #17
  1168a0:	232c      	movs	r3, #44	; 0x2c
  1168a2:	f2c0 0111 	movt	r1, #17
  1168a6:	f7fc ff79 	bl	11379c <_panic>
  1168aa:	bf00      	nop

001168ac <cbuf_space_avail>:

    memset(cbuf, 0, sizeof(cbuf_t));
}

size_t cbuf_space_avail(cbuf_t *cbuf)
{
  1168ac:	b430      	push	{r4, r5}
}

static inline __ALWAYS_INLINE uint valpow2(uint valp2)
{
    return 1U << valp2;
  1168ae:	2201      	movs	r2, #1
    return val >> divp2;
}

static inline __ALWAYS_INLINE uint modpow2(uint val, uint modp2)
{
    return val & ((1UL << modp2) - 1);
  1168b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  1168b4:	6884      	ldr	r4, [r0, #8]
  1168b6:	e9d0 3500 	ldrd	r3, r5, [r0]
    return 1U << valp2;
  1168ba:	fa02 f004 	lsl.w	r0, r2, r4
  1168be:	1b5b      	subs	r3, r3, r5
    return val & ((1UL << modp2) - 1);
  1168c0:	fa01 f204 	lsl.w	r2, r1, r4
    return valpow2(cbuf->len_pow2) - consumed - 1;
  1168c4:	4408      	add	r0, r1
  1168c6:	ea23 0302 	bic.w	r3, r3, r2
}
  1168ca:	1ac0      	subs	r0, r0, r3
  1168cc:	bc30      	pop	{r4, r5}
  1168ce:	4770      	bx	r14

001168d0 <cbuf_write_char>:
    spin_unlock_irqrestore(&cbuf->lock, state);
    return ret;
}

size_t cbuf_write_char(cbuf_t *cbuf, char c, bool canreschedule)
{
  1168d0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  1168d2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1168d6:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1168d8:	bf48      	it	mi
  1168da:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1168dc:	d401      	bmi.n	1168e2 <cbuf_write_char+0x12>
    __asm__ volatile("cpsid i");
  1168de:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1168e0:	2701      	movs	r7, #1
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  1168e2:	6883      	ldr	r3, [r0, #8]
  1168e4:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  1168e8:	f8d0 c000 	ldr.w	r12, [r0]
    *lock = 1;
  1168ec:	2501      	movs	r5, #1
  1168ee:	6844      	ldr	r4, [r0, #4]
  1168f0:	fa06 fe03 	lsl.w	r14, r6, r3
  1168f4:	ebac 0404 	sub.w	r4, r12, r4
  1168f8:	ea24 040e 	bic.w	r4, r4, r14
    return 1U << valp2;
  1168fc:	fa05 f303 	lsl.w	r3, r5, r3
  116900:	6185      	str	r5, [r0, #24]
    return valpow2(cbuf->len_pow2) - consumed - 1;
  116902:	1b1b      	subs	r3, r3, r4
    bool signal = false;
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    size_t ret = 0;
    if (cbuf_space_avail(cbuf) > 0) {
  116904:	42ab      	cmp	r3, r5
  116906:	d017      	beq.n	116938 <cbuf_write_char+0x68>
        cbuf->buf[cbuf->head] = c;
  116908:	68c3      	ldr	r3, [r0, #12]
  11690a:	f803 100c 	strb.w	r1, [r3, r12]
    return val & ((1UL << modp2) - 1);
  11690e:	6883      	ldr	r3, [r0, #8]

        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  116910:	6804      	ldr	r4, [r0, #0]
  116912:	409e      	lsls	r6, r3
        ret = 1;

        if (cbuf->head != cbuf->tail)
  116914:	6841      	ldr	r1, [r0, #4]
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  116916:	1963      	adds	r3, r4, r5
  116918:	ea23 0306 	bic.w	r3, r3, r6
        if (cbuf->head != cbuf->tail)
  11691c:	4299      	cmp	r1, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  11691e:	6003      	str	r3, [r0, #0]
        if (cbuf->head != cbuf->tail)
  116920:	d00b      	beq.n	11693a <cbuf_write_char+0x6a>
    *lock = 0;
  116922:	2300      	movs	r3, #0
  116924:	6183      	str	r3, [r0, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  116926:	b107      	cbz	r7, 11692a <cbuf_write_char+0x5a>
    __asm__ volatile("cpsie i");
  116928:	b662      	cpsie	i
  11692a:	4611      	mov	r1, r2
    }

    spin_unlock_irqrestore(&cbuf->lock, state);

    if(signal == true)
        event_signal(&cbuf->event, canreschedule);
  11692c:	3010      	adds	r0, #16
  11692e:	f7ff fda3 	bl	116478 <event_signal>
  116932:	2501      	movs	r5, #1

    return ret;
}
  116934:	4628      	mov	r0, r5
  116936:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    size_t ret = 0;
  116938:	2500      	movs	r5, #0
    *lock = 0;
  11693a:	2300      	movs	r3, #0
  11693c:	6183      	str	r3, [r0, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  11693e:	2f00      	cmp	r7, #0
  116940:	d0f8      	beq.n	116934 <cbuf_write_char+0x64>
  116942:	b662      	cpsie	i
}
  116944:	4628      	mov	r0, r5
  116946:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00116948 <cbuf_read_char>:

size_t cbuf_read_char(cbuf_t *cbuf, char *c, bool block)
{
  116948:	b570      	push	{r4, r5, r6, r14}
  11694a:	4604      	mov	r4, r0
  11694c:	460e      	mov	r6, r1
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(c);

retry:
    if (block)
  11694e:	4615      	mov	r5, r2
  116950:	bb42      	cbnz	r2, 1169a4 <cbuf_read_char+0x5c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  116952:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  116956:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  11695a:	d12e      	bne.n	1169ba <cbuf_read_char+0x72>
    __asm__ volatile("cpsid i");
  11695c:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    // see if there's data available
    size_t ret = 0;
    if (cbuf->tail != cbuf->head) {
  11695e:	e9d4 0100 	ldrd	r0, r1, [r4]
    *lock = 1;
  116962:	2201      	movs	r2, #1
  116964:	61a2      	str	r2, [r4, #24]
  116966:	4281      	cmp	r1, r0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  116968:	bf18      	it	ne
  11696a:	4615      	movne	r5, r2
  11696c:	d015      	beq.n	11699a <cbuf_read_char+0x52>

        *c = cbuf->buf[cbuf->tail];
  11696e:	68e2      	ldr	r2, [r4, #12]
  116970:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  116974:	5c52      	ldrb	r2, [r2, r1]
  116976:	7032      	strb	r2, [r6, #0]
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  116978:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
  11697c:	fa03 f101 	lsl.w	r1, r3, r1
  116980:	1c53      	adds	r3, r2, #1

        if (cbuf->tail == cbuf->head) {
  116982:	6822      	ldr	r2, [r4, #0]
  116984:	ea23 0301 	bic.w	r3, r3, r1
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  116988:	6063      	str	r3, [r4, #4]
        if (cbuf->tail == cbuf->head) {
  11698a:	429a      	cmp	r2, r3
  11698c:	d022      	beq.n	1169d4 <cbuf_read_char+0x8c>
    *lock = 0;
  11698e:	2300      	movs	r3, #0
  116990:	61a3      	str	r3, [r4, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  116992:	b1ed      	cbz	r5, 1169d0 <cbuf_read_char+0x88>
    __asm__ volatile("cpsie i");
  116994:	b662      	cpsie	i
  116996:	2001      	movs	r0, #1

    if (block && ret == 0)
        goto retry;

    return ret;
}
  116998:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 0;
  11699a:	61a3      	str	r3, [r4, #24]
  11699c:	b662      	cpsie	i
  11699e:	4628      	mov	r0, r5
    if (block && ret == 0)
  1169a0:	2d00      	cmp	r5, #0
  1169a2:	d0f9      	beq.n	116998 <cbuf_read_char+0x50>
*   para: event handle.
*   return： NO_ERROR if unsignal succ or blocked forever.
*/
static inline status_t event_wait(event_t *e)
{
    return event_wait_timeout(e, INFINITE_TIME);
  1169a4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1169a8:	f104 0010 	add.w	r0, r4, #16
  1169ac:	f7ff fd2a 	bl	116404 <event_wait_timeout>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1169b0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1169b4:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  1169b8:	d0d0      	beq.n	11695c <cbuf_read_char+0x14>
    if (cbuf->tail != cbuf->head) {
  1169ba:	e9d4 3100 	ldrd	r3, r1, [r4]
    *lock = 1;
  1169be:	2201      	movs	r2, #1
  1169c0:	61a2      	str	r2, [r4, #24]
  1169c2:	4299      	cmp	r1, r3
    *lock = 0;
  1169c4:	bf04      	itt	eq
  1169c6:	2300      	moveq	r3, #0
  1169c8:	61a3      	streq	r3, [r4, #24]
  1169ca:	d0e8      	beq.n	11699e <cbuf_read_char+0x56>
    spin_lock_saved_state_t state = 0;
  1169cc:	2500      	movs	r5, #0
  1169ce:	e7ce      	b.n	11696e <cbuf_read_char+0x26>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1169d0:	2001      	movs	r0, #1
}
  1169d2:	bd70      	pop	{r4, r5, r6, r15}
            event_unsignal(&cbuf->event);
  1169d4:	f104 0010 	add.w	r0, r4, #16
  1169d8:	f7ff fd8a 	bl	1164f0 <event_unsignal>
  1169dc:	e7d7      	b.n	11698e <cbuf_read_char+0x46>
  1169de:	bf00      	nop

001169e0 <__debug_stdio_write>:

    spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
}

static ssize_t __debug_stdio_write(io_handle_t *io, const char *s, size_t len)
{
  1169e0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    return (list->next == list) ? true : false;
  1169e4:	f64c 26d0 	movw	r6, #51920	; 0xcad0
  1169e8:	460c      	mov	r4, r1
  1169ea:	4617      	mov	r7, r2
  1169ec:	f2c0 0612 	movt	r6, #18
  1169f0:	6875      	ldr	r5, [r6, #4]
    if (!list_is_empty(&print_callbacks)) {
  1169f2:	42b5      	cmp	r5, r6
  1169f4:	d013      	beq.n	116a1e <__debug_stdio_write+0x3e>
  1169f6:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1169fa:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1169fc:	bf48      	it	mi
  1169fe:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  116a02:	d519      	bpl.n	116a38 <__debug_stdio_write+0x58>
            if (cb->print)
  116a04:	68ab      	ldr	r3, [r5, #8]
                cb->print(cb, str, len);
  116a06:	4628      	mov	r0, r5
  116a08:	463a      	mov	r2, r7
  116a0a:	4621      	mov	r1, r4
            if (cb->print)
  116a0c:	b103      	cbz	r3, 116a10 <__debug_stdio_write+0x30>
                cb->print(cb, str, len);
  116a0e:	4798      	blx	r3
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  116a10:	686d      	ldr	r5, [r5, #4]
  116a12:	42b5      	cmp	r5, r6
  116a14:	d1f6      	bne.n	116a04 <__debug_stdio_write+0x24>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  116a16:	f1b8 0f00 	cmp.w	r8, #0
  116a1a:	d000      	beq.n	116a1e <__debug_stdio_write+0x3e>
    __asm__ volatile("cpsie i");
  116a1c:	b662      	cpsie	i
    for (i = 0; i < len; i++) {
  116a1e:	b147      	cbz	r7, 116a32 <__debug_stdio_write+0x52>
  116a20:	1e7d      	subs	r5, r7, #1
  116a22:	4425      	add	r5, r4
  116a24:	3c01      	subs	r4, #1
        platform_dputc(str[i]);
  116a26:	f814 0f01 	ldrb.w	r0, [r4, #1]!
  116a2a:	f7e9 fd71 	bl	100510 <platform_dputc>
    for (i = 0; i < len; i++) {
  116a2e:	42a5      	cmp	r5, r4
  116a30:	d1f9      	bne.n	116a26 <__debug_stdio_write+0x46>
    out_count(s, len);
    return len;
}
  116a32:	4638      	mov	r0, r7
  116a34:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    __asm__ volatile("cpsid i");
  116a38:	b672      	cpsid	i
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  116a3a:	6875      	ldr	r5, [r6, #4]
  116a3c:	42b5      	cmp	r5, r6
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  116a3e:	bf18      	it	ne
  116a40:	f04f 0801 	movne.w	r8, #1
  116a44:	d1de      	bne.n	116a04 <__debug_stdio_write+0x24>
  116a46:	e7e9      	b.n	116a1c <__debug_stdio_write+0x3c>

00116a48 <__debug_stdio_read>:

static ssize_t __debug_stdio_read(io_handle_t *io, char *s, size_t len)
{
    if (len == 0)
  116a48:	b90a      	cbnz	r2, 116a4e <__debug_stdio_read+0x6>
        return 0;
  116a4a:	4610      	mov	r0, r2
    if (err < 0)
        return err;

    return 1;
#endif
}
  116a4c:	4770      	bx	r14
{
  116a4e:	b508      	push	{r3, r14}
  116a50:	4608      	mov	r0, r1
    int err = platform_dgetc(s, true);
  116a52:	2101      	movs	r1, #1
  116a54:	f7e9 fd5e 	bl	100514 <platform_dgetc>
    return 1;
  116a58:	ea10 0020 	ands.w	r0, r0, r0, asr #32
  116a5c:	bf38      	it	cc
  116a5e:	2001      	movcc	r0, #1
}
  116a60:	bd08      	pop	{r3, r15}
  116a62:	bf00      	nop

00116a64 <io_write>:

ssize_t io_write(io_handle_t *io, const char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->write)
  116a64:	6843      	ldr	r3, [r0, #4]
  116a66:	681b      	ldr	r3, [r3, #0]
  116a68:	b103      	cbz	r3, 116a6c <io_write+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->write(io, buf, len);
  116a6a:	4718      	bx	r3
}
  116a6c:	f06f 0017 	mvn.w	r0, #23
  116a70:	4770      	bx	r14
  116a72:	bf00      	nop

00116a74 <reboot_mp>:
     * */
    sdrv_common_reg_set_value(SDRV_REG_STATUS, SDRV_REG_STATUS_SDPE_LD_DONE,
                              SDRV_REG_STATUS_SDPE_LD_DONE);
#endif
    return NO_ERROR;
}
  116a74:	2000      	movs	r0, #0
  116a76:	4770      	bx	r14

00116a78 <kick_module>:
{
  116a78:	b5f0      	push	{r4, r5, r6, r7, r14}
  116a7a:	4604      	mov	r4, r0
  116a7c:	b085      	sub	sp, #20
  116a7e:	4675      	mov	r5, r14
    ret = hal_cpu_create_handle(&handle);
  116a80:	a803      	add	r0, sp, #12
{
  116a82:	4616      	mov	r6, r2
  116a84:	461f      	mov	r7, r3
    ret = hal_cpu_create_handle(&handle);
  116a86:	f7f4 fc31 	bl	10b2ec <hal_cpu_create_handle>
    ASSERT(ret);
  116a8a:	b158      	cbz	r0, 116aa4 <kick_module+0x2c>
    hal_cpu_boot(handle, id, entry);
  116a8c:	4632      	mov	r2, r6
  116a8e:	463b      	mov	r3, r7
  116a90:	9803      	ldr	r0, [sp, #12]
  116a92:	4621      	mov	r1, r4
  116a94:	f7f4 fc30 	bl	10b2f8 <hal_cpu_boot>
    hal_cpu_release_handle(handle);
  116a98:	9803      	ldr	r0, [sp, #12]
  116a9a:	f7f4 fc29 	bl	10b2f0 <hal_cpu_release_handle>
}
  116a9e:	2000      	movs	r0, #0
  116aa0:	b005      	add	sp, #20
  116aa2:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT(ret);
  116aa4:	f24a 6310 	movw	r3, #42512	; 0xa610
  116aa8:	f24f 2280 	movw	r2, #62080	; 0xf280
  116aac:	f647 4134 	movw	r1, #31796	; 0x7c34
  116ab0:	f2c0 0311 	movt	r3, #17
  116ab4:	4628      	mov	r0, r5
  116ab6:	f2c0 0211 	movt	r2, #17
  116aba:	9300      	str	r3, [sp, #0]
  116abc:	f2c0 0111 	movt	r1, #17
  116ac0:	2373      	movs	r3, #115	; 0x73
  116ac2:	f7fc fe6b 	bl	11379c <_panic>
  116ac6:	bf00      	nop

00116ac8 <reboot_ap2>:
{
  116ac8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    void *handle = NULL;
  116acc:	2400      	movs	r4, #0
{
  116ace:	b086      	sub	sp, #24
  116ad0:	460d      	mov	r5, r1
    void *handle = NULL;
  116ad2:	a806      	add	r0, sp, #24
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  116ad4:	f44f 6180 	mov.w	r1, #1024	; 0x400
  116ad8:	46f0      	mov	r8, r14
    void *handle = NULL;
  116ada:	f840 4d14 	str.w	r4, [r0, #-20]!
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  116ade:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116ae2:	f7f9 fc93 	bl	11040c <hal_rstgen_creat_handle>
    if (!ret) {
  116ae6:	2800      	cmp	r0, #0
  116ae8:	d05d      	beq.n	116ba6 <reboot_ap2+0xde>
    ret = hal_rstgen_init(handle);
  116aea:	9801      	ldr	r0, [sp, #4]
  116aec:	f7f9 fd0a 	bl	110504 <hal_rstgen_init>
    if (!ret) {
  116af0:	2800      	cmp	r0, #0
  116af2:	d061      	beq.n	116bb8 <reboot_ap2+0xf0>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU2_SS, 0x0);
  116af4:	4622      	mov	r2, r4
  116af6:	4621      	mov	r1, r4
  116af8:	9801      	ldr	r0, [sp, #4]
  116afa:	f7f9 fdab 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_core_ctl(handle, RES_CORE_RST_SEC_CPU2_CORE_SW, 0x0);
  116afe:	4622      	mov	r2, r4
  116b00:	9801      	ldr	r0, [sp, #4]
  116b02:	4621      	mov	r1, r4
  116b04:	f7f9 fd6c 	bl	1105e0 <hal_rstgen_core_ctl>
    hal_rstgen_module_reset(handle, RES_MODULE_RST_SEC_GIC5);
  116b08:	9801      	ldr	r0, [sp, #4]
  116b0a:	f240 4162 	movw	r1, #1122	; 0x462
  116b0e:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116b12:	f7f9 fd7f 	bl	110614 <hal_rstgen_module_reset>
    hal_rstgen_release_handle(handle);
  116b16:	9801      	ldr	r0, [sp, #4]
  116b18:	f7f9 fce8 	bl	1104ec <hal_rstgen_release_handle>
    entry = arg->entry;
  116b1c:	e9d5 6700 	ldrd	r6, r7, [r5]
    if (!entry) {
  116b20:	ea56 0307 	orrs.w	r3, r6, r7
  116b24:	d04e      	beq.n	116bc4 <reboot_ap2+0xfc>
    if (is_str_resume(STR_AP2)) {
  116b26:	2001      	movs	r0, #1
  116b28:	f7e9 fe9e 	bl	100868 <is_str_resume>
  116b2c:	b9b8      	cbnz	r0, 116b5e <reboot_ap2+0x96>
    load_addr = ap2p(entry);
  116b2e:	4630      	mov	r0, r6
  116b30:	f7f9 fc48 	bl	1103c4 <ap2p>
    ret = mem_image_seek(seeker_base, pt_name, &info);
  116b34:	f24f 3150 	movw	r1, #62288	; 0xf350
  116b38:	aa02      	add	r2, sp, #8
  116b3a:	f2c0 0111 	movt	r1, #17
    load_addr = ap2p(entry);
  116b3e:	4604      	mov	r4, r0
    ret = mem_image_seek(seeker_base, pt_name, &info);
  116b40:	2000      	movs	r0, #0
  116b42:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116b46:	f000 fd1b 	bl	117580 <mem_image_seek>
    if (ret) {
  116b4a:	b988      	cbnz	r0, 116b70 <reboot_ap2+0xa8>
    memcpy((void *)load_addr, (void *)(addr_t)info.base, info.sz);
  116b4c:	9902      	ldr	r1, [sp, #8]
  116b4e:	4620      	mov	r0, r4
  116b50:	9a04      	ldr	r2, [sp, #16]
  116b52:	f7fc eea6 	blx	1138a0 <memcpy>
    arch_clean_cache_range(load_addr, info.sz);
  116b56:	9904      	ldr	r1, [sp, #16]
  116b58:	4620      	mov	r0, r4
  116b5a:	f7ea ee70 	blx	10183c <arch_clean_cache_range>
    kick_module(CPU_ID_AP2, entry);
  116b5e:	4632      	mov	r2, r6
  116b60:	463b      	mov	r3, r7
  116b62:	2002      	movs	r0, #2
  116b64:	f7ff ff88 	bl	116a78 <kick_module>
    return NO_ERROR;
  116b68:	2000      	movs	r0, #0
}
  116b6a:	b006      	add	sp, #24
  116b6c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        ret = mem_image_seek(seeker_base, "preloader", &info);
  116b70:	f24f 3158 	movw	r1, #62296	; 0xf358
  116b74:	2000      	movs	r0, #0
  116b76:	aa02      	add	r2, sp, #8
  116b78:	f2c0 0111 	movt	r1, #17
  116b7c:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116b80:	f000 fcfe 	bl	117580 <mem_image_seek>
        if (ret) {
  116b84:	2800      	cmp	r0, #0
  116b86:	d0e1      	beq.n	116b4c <reboot_ap2+0x84>
            ERROR("don't find preloader for ap2 image!");
  116b88:	f24f 2158 	movw	r1, #62040	; 0xf258
  116b8c:	f24f 3064 	movw	r0, #62308	; 0xf364
  116b90:	f2c0 0111 	movt	r1, #17
  116b94:	f44f 728b 	mov.w	r2, #278	; 0x116
  116b98:	f2c0 0011 	movt	r0, #17
  116b9c:	f7fd fe32 	bl	114804 <printf>
            return ERR_NOT_FOUND;
  116ba0:	f06f 0001 	mvn.w	r0, #1
  116ba4:	e7e1      	b.n	116b6a <reboot_ap2+0xa2>
        dprintf(CRITICAL, "reboot_ap2 hal_rstgen_creat_handle fail \n");
  116ba6:	f24f 3010 	movw	r0, #62224	; 0xf310
  116baa:	f2c0 0011 	movt	r0, #17
  116bae:	f7fd fe11 	bl	1147d4 <puts>
        return -1;
  116bb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  116bb6:	e7d8      	b.n	116b6a <reboot_ap2+0xa2>
        hal_rstgen_release_handle(handle);
  116bb8:	9801      	ldr	r0, [sp, #4]
  116bba:	f7f9 fc97 	bl	1104ec <hal_rstgen_release_handle>
        return -1;
  116bbe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  116bc2:	e7d2      	b.n	116b6a <reboot_ap2+0xa2>
        panic("ap2 entry is 0!\n");
  116bc4:	f24f 313c 	movw	r1, #62268	; 0xf33c
  116bc8:	4640      	mov	r0, r8
  116bca:	f2c0 0111 	movt	r1, #17
  116bce:	f7fc fde5 	bl	11379c <_panic>
  116bd2:	bf00      	nop

00116bd4 <reboot_ap1>:
{
  116bd4:	b5f0      	push	{r4, r5, r6, r7, r14}
    void *handle = NULL;
  116bd6:	2400      	movs	r4, #0
{
  116bd8:	b087      	sub	sp, #28
  116bda:	460d      	mov	r5, r1
    void *handle = NULL;
  116bdc:	a806      	add	r0, sp, #24
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  116bde:	f44f 6180 	mov.w	r1, #1024	; 0x400
    void *handle = NULL;
  116be2:	f840 4d14 	str.w	r4, [r0, #-20]!
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  116be6:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116bea:	f7f9 fc0f 	bl	11040c <hal_rstgen_creat_handle>
    if (!ret) {
  116bee:	2800      	cmp	r0, #0
  116bf0:	f000 80be 	beq.w	116d70 <reboot_ap1+0x19c>
    ret = hal_rstgen_init(handle);
  116bf4:	9801      	ldr	r0, [sp, #4]
  116bf6:	f7f9 fc85 	bl	110504 <hal_rstgen_init>
    if (!ret) {
  116bfa:	2800      	cmp	r0, #0
  116bfc:	f000 80c1 	beq.w	116d82 <reboot_ap1+0x1ae>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_SS, 0x0);
  116c00:	f240 416d 	movw	r1, #1133	; 0x46d
  116c04:	4622      	mov	r2, r4
  116c06:	9801      	ldr	r0, [sp, #4]
  116c08:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c0c:	f7f9 fd22 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE0_WARM, 0x0);
  116c10:	f240 4155 	movw	r1, #1109	; 0x455
  116c14:	4622      	mov	r2, r4
  116c16:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c1a:	9801      	ldr	r0, [sp, #4]
  116c1c:	f7f9 fd1a 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE1_WARM, 0x0);
  116c20:	f240 4156 	movw	r1, #1110	; 0x456
  116c24:	4622      	mov	r2, r4
  116c26:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c2a:	9801      	ldr	r0, [sp, #4]
  116c2c:	f7f9 fd12 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE2_WARM, 0x0);
  116c30:	f240 4157 	movw	r1, #1111	; 0x457
  116c34:	4622      	mov	r2, r4
  116c36:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c3a:	9801      	ldr	r0, [sp, #4]
  116c3c:	f7f9 fd0a 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE3_WARM, 0x0);
  116c40:	f44f 618b 	mov.w	r1, #1112	; 0x458
  116c44:	4622      	mov	r2, r4
  116c46:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c4a:	9801      	ldr	r0, [sp, #4]
  116c4c:	f7f9 fd02 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE4_WARM, 0x0);
  116c50:	f240 4159 	movw	r1, #1113	; 0x459
  116c54:	4622      	mov	r2, r4
  116c56:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c5a:	9801      	ldr	r0, [sp, #4]
  116c5c:	f7f9 fcfa 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_CORE5_WARM, 0x0);
  116c60:	f240 415a 	movw	r1, #1114	; 0x45a
  116c64:	4622      	mov	r2, r4
  116c66:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c6a:	9801      	ldr	r0, [sp, #4]
  116c6c:	f7f9 fcf2 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_CPU1_SCU_WARM, 0x0);
  116c70:	f240 415b 	movw	r1, #1115	; 0x45b
  116c74:	4622      	mov	r2, r4
  116c76:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c7a:	9801      	ldr	r0, [sp, #4]
  116c7c:	f7f9 fcea 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_core_ctl(handle, RES_CORE_RST_SEC_CPU1_CORE_ALL_SW, 0x0);
  116c80:	f44f 6181 	mov.w	r1, #1032	; 0x408
  116c84:	4622      	mov	r2, r4
  116c86:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c8a:	9801      	ldr	r0, [sp, #4]
  116c8c:	f7f9 fca8 	bl	1105e0 <hal_rstgen_core_ctl>
    hal_rstgen_module_reset(handle, RES_MODULE_RST_SEC_GIC4);
  116c90:	9801      	ldr	r0, [sp, #4]
  116c92:	f240 4161 	movw	r1, #1121	; 0x461
  116c96:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116c9a:	f7f9 fcbb 	bl	110614 <hal_rstgen_module_reset>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIEPHY, 0x0);
  116c9e:	f240 4171 	movw	r1, #1137	; 0x471
  116ca2:	4622      	mov	r2, r4
  116ca4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116ca8:	9801      	ldr	r0, [sp, #4]
  116caa:	f7f9 fcd3 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIE1, 0x0);
  116cae:	f240 416f 	movw	r1, #1135	; 0x46f
  116cb2:	4622      	mov	r2, r4
  116cb4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116cb8:	9801      	ldr	r0, [sp, #4]
  116cba:	f7f9 fccb 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIE2, 0x0);
  116cbe:	f44f 618e 	mov.w	r1, #1136	; 0x470
  116cc2:	4622      	mov	r2, r4
  116cc4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116cc8:	9801      	ldr	r0, [sp, #4]
  116cca:	f7f9 fcc3 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIEPHY, 0x1);
  116cce:	f240 4171 	movw	r1, #1137	; 0x471
  116cd2:	2201      	movs	r2, #1
  116cd4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116cd8:	9801      	ldr	r0, [sp, #4]
  116cda:	f7f9 fcbb 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIE1, 0x1);
  116cde:	f240 416f 	movw	r1, #1135	; 0x46f
  116ce2:	2201      	movs	r2, #1
  116ce4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116ce8:	9801      	ldr	r0, [sp, #4]
  116cea:	f7f9 fcb3 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_module_ctl(handle, RES_MODULE_RST_SEC_PCIE2, 0x1);
  116cee:	f44f 618e 	mov.w	r1, #1136	; 0x470
  116cf2:	2201      	movs	r2, #1
  116cf4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  116cf8:	9801      	ldr	r0, [sp, #4]
  116cfa:	f7f9 fcab 	bl	110654 <hal_rstgen_module_ctl>
    hal_rstgen_release_handle(handle);
  116cfe:	9801      	ldr	r0, [sp, #4]
  116d00:	f7f9 fbf4 	bl	1104ec <hal_rstgen_release_handle>
    entry = arg->entry;
  116d04:	e9d5 4500 	ldrd	r4, r5, [r5]
    if (is_str_resume(STR_AP1)) {
  116d08:	2000      	movs	r0, #0
    if (!entry) {
  116d0a:	ea54 0305 	orrs.w	r3, r4, r5
        entry = AP1_PRELOADER_MEMBASE;
  116d0e:	bf02      	ittt	eq
  116d10:	2400      	moveq	r4, #0
  116d12:	2500      	moveq	r5, #0
  116d14:	f6c5 1420 	movteq	r4, #22816	; 0x5920
    if (is_str_resume(STR_AP1)) {
  116d18:	f7e9 fda6 	bl	100868 <is_str_resume>
  116d1c:	bb00      	cbnz	r0, 116d60 <reboot_ap1+0x18c>
    load_addr = ap2p(entry);
  116d1e:	4620      	mov	r0, r4
  116d20:	f7f9 fb50 	bl	1103c4 <ap2p>
    if (mem_image_seek(seeker_base, "preloader", &info)) {
  116d24:	f24f 3158 	movw	r1, #62296	; 0xf358
  116d28:	f2c0 0111 	movt	r1, #17
  116d2c:	aa02      	add	r2, sp, #8
    load_addr = ap2p(entry);
  116d2e:	4607      	mov	r7, r0
    if (mem_image_seek(seeker_base, "preloader", &info)) {
  116d30:	2000      	movs	r0, #0
  116d32:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116d36:	f000 fc23 	bl	117580 <mem_image_seek>
  116d3a:	4606      	mov	r6, r0
  116d3c:	bb38      	cbnz	r0, 116d8e <reboot_ap1+0x1ba>
    memcpy((void *)load_addr, (void *)(addr_t)info.base, info.sz);
  116d3e:	9a04      	ldr	r2, [sp, #16]
  116d40:	4638      	mov	r0, r7
  116d42:	9902      	ldr	r1, [sp, #8]
  116d44:	f7fc edac 	blx	1138a0 <memcpy>
    arch_clean_cache_range(load_addr, info.sz);
  116d48:	9904      	ldr	r1, [sp, #16]
  116d4a:	4638      	mov	r0, r7
  116d4c:	f7ea ed76 	blx	10183c <arch_clean_cache_range>
    kick_module(CPU_ID_AP1, entry);
  116d50:	4622      	mov	r2, r4
  116d52:	462b      	mov	r3, r5
  116d54:	2001      	movs	r0, #1
  116d56:	f7ff fe8f 	bl	116a78 <kick_module>
    return NO_ERROR;
  116d5a:	4630      	mov	r0, r6
}
  116d5c:	b007      	add	sp, #28
  116d5e:	bdf0      	pop	{r4, r5, r6, r7, r15}
        kick_module(CPU_ID_AP1, entry);
  116d60:	4622      	mov	r2, r4
  116d62:	462b      	mov	r3, r5
  116d64:	2001      	movs	r0, #1
  116d66:	f7ff fe87 	bl	116a78 <kick_module>
        return NO_ERROR;
  116d6a:	2000      	movs	r0, #0
}
  116d6c:	b007      	add	sp, #28
  116d6e:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "reboot_ap1 hal_rstgen_creat_handle fail \n");
  116d70:	f24f 20b0 	movw	r0, #62128	; 0xf2b0
  116d74:	f2c0 0011 	movt	r0, #17
  116d78:	f7fd fd2c 	bl	1147d4 <puts>
        return -1;
  116d7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  116d80:	e7ec      	b.n	116d5c <reboot_ap1+0x188>
        hal_rstgen_release_handle(handle);
  116d82:	9801      	ldr	r0, [sp, #4]
  116d84:	f7f9 fbb2 	bl	1104ec <hal_rstgen_release_handle>
        return -1;
  116d88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  116d8c:	e7e6      	b.n	116d5c <reboot_ap1+0x188>
        ERROR("don't find preloader for ap1 image!");
  116d8e:	f24f 214c 	movw	r1, #62028	; 0xf24c
  116d92:	f24f 20dc 	movw	r0, #62172	; 0xf2dc
  116d96:	f2c0 0111 	movt	r1, #17
  116d9a:	22cd      	movs	r2, #205	; 0xcd
  116d9c:	f2c0 0011 	movt	r0, #17
  116da0:	f7fd fd30 	bl	114804 <printf>
        return ERR_NOT_FOUND;
  116da4:	f06f 0001 	mvn.w	r0, #1
  116da8:	e7d8      	b.n	116d5c <reboot_ap1+0x188>
  116daa:	bf00      	nop

00116dac <reboot_saf>:
    if (!arg)
  116dac:	b139      	cbz	r1, 116dbe <reboot_saf+0x12>
{
  116dae:	b508      	push	{r3, r14}
    kick_module(CPU_ID_SAF, entry);
  116db0:	680a      	ldr	r2, [r1, #0]
  116db2:	2300      	movs	r3, #0
  116db4:	2005      	movs	r0, #5
  116db6:	f7ff fe5f 	bl	116a78 <kick_module>
    return NO_ERROR;
  116dba:	2000      	movs	r0, #0
}
  116dbc:	bd08      	pop	{r3, r15}
        return ERR_INVALID_ARGS;
  116dbe:	f06f 0007 	mvn.w	r0, #7
}
  116dc2:	4770      	bx	r14

00116dc4 <reboot_sec>:
    mem_image_entry_t info;
    const char *pt_name;
    uint32_t ret;
    size_t seeker_size = IMG_BACKUP_LOW_SZ;
    addr_t seeker_base = IMG_BACKUP_LOW_BASE;
    mem_image_init(seeker_base, seeker_size);
  116dc4:	2000      	movs	r0, #0
{
  116dc6:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  116dca:	460e      	mov	r6, r1
  116dcc:	b087      	sub	sp, #28
    mem_image_init(seeker_base, seeker_size);
  116dce:	f44f 11f8 	mov.w	r1, #2031616	; 0x1f0000
  116dd2:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116dd6:	f000 fbaf 	bl	117538 <mem_image_init>
    pt_name = "fda_spl";
    ret = mem_image_seek(seeker_base, pt_name, &info);
  116dda:	f24f 31c4 	movw	r1, #62404	; 0xf3c4
  116dde:	2000      	movs	r0, #0
  116de0:	aa02      	add	r2, sp, #8
  116de2:	f2c0 0111 	movt	r1, #17
  116de6:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116dea:	f000 fbc9 	bl	117580 <mem_image_seek>

    if (ret) {
  116dee:	bb18      	cbnz	r0, 116e38 <reboot_sec+0x74>
            ERROR("don't find ssystem image!");
            return ERR_NOT_FOUND;
        }
    }

    if (arg->flags & RB_COLD && (boot_get_pin() == BOOT_PIN_0)) {
  116df0:	6933      	ldr	r3, [r6, #16]
  116df2:	079b      	lsls	r3, r3, #30
  116df4:	d43b      	bmi.n	116e6e <reboot_sec+0xaa>
        send_peer_load_msg(info.base);
    }
    else if (HAS_BPT_HEADER(info.base)) {
  116df6:	9b02      	ldr	r3, [sp, #8]
  116df8:	f245 4201 	movw	r2, #21505	; 0x5401
  116dfc:	f2c4 2250 	movt	r2, #16976	; 0x4250
  116e00:	6819      	ldr	r1, [r3, #0]
  116e02:	4291      	cmp	r1, r2
  116e04:	d173      	bne.n	116eee <reboot_sec+0x12a>
        if (NO_ERROR != verified_image((void *)(addr_t)(info.base),
                                       info.sz, pt_name)) {
            return ERR_NOT_VALID;
        }

        memcpy((void *)(addr_t)GET_BPT_IMG_LDA(info.base),
  116e06:	9a04      	ldr	r2, [sp, #16]
  116e08:	f503 6100 	add.w	r1, r3, #2048	; 0x800
  116e0c:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
  116e0e:	f5a2 6200 	sub.w	r2, r2, #2048	; 0x800
  116e12:	f7fc ed46 	blx	1138a0 <memcpy>
               (void *)(addr_t)(info.base + BPT_SIZE), info.sz - BPT_SIZE);
        arch_clean_cache_range(GET_BPT_IMG_LDA(info.base), info.sz - BPT_SIZE);
  116e16:	9b02      	ldr	r3, [sp, #8]
  116e18:	9904      	ldr	r1, [sp, #16]
  116e1a:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
  116e1c:	f5a1 6100 	sub.w	r1, r1, #2048	; 0x800
  116e20:	f7ea ed0c 	blx	10183c <arch_clean_cache_range>
        kick_module(CPU_ID_SEC, GET_BPT_IMG_EP(info.base));
  116e24:	9a02      	ldr	r2, [sp, #8]
  116e26:	2300      	movs	r3, #0
  116e28:	2004      	movs	r0, #4
  116e2a:	6d52      	ldr	r2, [r2, #84]	; 0x54
  116e2c:	f7ff fe24 	bl	116a78 <kick_module>
    else {
        ERROR("ssystem format error!");
        return ERR_INVALID_ARGS;
    }

    return NO_ERROR;
  116e30:	2000      	movs	r0, #0
}
  116e32:	b007      	add	sp, #28
  116e34:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        ret = mem_image_seek(seeker_base, pt_name, &info);
  116e38:	f24f 31cc 	movw	r1, #62412	; 0xf3cc
  116e3c:	2000      	movs	r0, #0
  116e3e:	aa02      	add	r2, sp, #8
  116e40:	f2c0 0111 	movt	r1, #17
  116e44:	f2c3 0081 	movt	r0, #12417	; 0x3081
  116e48:	f000 fb9a 	bl	117580 <mem_image_seek>
        if (ret) {
  116e4c:	2800      	cmp	r0, #0
  116e4e:	d0cf      	beq.n	116df0 <reboot_sec+0x2c>
            ERROR("don't find ssystem image!");
  116e50:	f24f 2164 	movw	r1, #62052	; 0xf264
  116e54:	f24f 30d4 	movw	r0, #62420	; 0xf3d4
  116e58:	f2c0 0111 	movt	r1, #17
  116e5c:	f44f 72c9 	mov.w	r2, #402	; 0x192
  116e60:	f2c0 0011 	movt	r0, #17
  116e64:	f7fd fcce 	bl	114804 <printf>
            return ERR_NOT_FOUND;
  116e68:	f06f 0001 	mvn.w	r0, #1
  116e6c:	e7e1      	b.n	116e32 <reboot_sec+0x6e>
    if (arg->flags & RB_COLD && (boot_get_pin() == BOOT_PIN_0)) {
  116e6e:	f000 fc17 	bl	1176a0 <boot_get_pin>
  116e72:	2800      	cmp	r0, #0
  116e74:	d1bf      	bne.n	116df6 <reboot_sec+0x32>
    struct peer_boot_message msg_ori = MK_PEER_LOAD_MSG(para);
  116e76:	f640 03fc 	movw	r3, #2300	; 0x8fc
  116e7a:	46ec      	mov	r12, r13
  116e7c:	22fc      	movs	r2, #252	; 0xfc
  116e7e:	f2c0 13f1 	movt	r3, #497	; 0x1f1
    uint64_t val = 0ull;
  116e82:	2600      	movs	r6, #0
  116e84:	2700      	movs	r7, #0
    struct peer_boot_message msg_ori = MK_PEER_LOAD_MSG(para);
  116e86:	9300      	str	r3, [sp, #0]
        send_peer_load_msg(info.base);
  116e88:	9b02      	ldr	r3, [sp, #8]
    struct peer_boot_message msg_ori = MK_PEER_LOAD_MSG(para);
  116e8a:	9301      	str	r3, [sp, #4]
  116e8c:	e001      	b.n	116e92 <reboot_sec+0xce>
  116e8e:	f81c 2f01 	ldrb.w	r2, [r12, #1]!
        val |= ((uint64_t)msg[i] << (i * 8));
  116e92:	fa5f f882 	uxtb.w	r8, r2
  116e96:	f1a0 0120 	sub.w	r1, r0, #32
  116e9a:	f1c0 0320 	rsb	r3, r0, #32
  116e9e:	fa08 f501 	lsl.w	r5, r8, r1
  116ea2:	fa28 f303 	lsr.w	r3, r8, r3
    for (uint32_t i = 0; i < len; i++) {
  116ea6:	2838      	cmp	r0, #56	; 0x38
        val |= ((uint64_t)msg[i] << (i * 8));
  116ea8:	fa08 f400 	lsl.w	r4, r8, r0
  116eac:	ea45 0503 	orr.w	r5, r5, r3
  116eb0:	ea46 0604 	orr.w	r6, r6, r4
  116eb4:	ea47 0705 	orr.w	r7, r7, r5
  116eb8:	f100 0008 	add.w	r0, r0, #8
    for (uint32_t i = 0; i < len; i++) {
  116ebc:	d1e7      	bne.n	116e8e <reboot_sec+0xca>
    *tmh0  = FV_TMH0_MDP(mask) | FV_TMH0_TXMES_LEN((len + 1) / 2) |
  116ebe:	2404      	movs	r4, #4
    tmc_reg[msg_id] |= BM_TMC0_TMC0_MSG_SEND;
  116ec0:	230c      	movs	r3, #12
    *tmh1 = (uint32_t)val;
  116ec2:	4621      	mov	r1, r4
    tmc_reg[msg_id] |= BM_TMC0_TMC0_MSG_SEND;
  116ec4:	f2cf 4304 	movt	r3, #62468	; 0xf404
    *tmh0  = FV_TMH0_MDP(mask) | FV_TMH0_TXMES_LEN((len + 1) / 2) |
  116ec8:	2000      	movs	r0, #0
        *tmh2 = (uint32_t)(val >> 32);
  116eca:	2208      	movs	r2, #8
    *tmh0  = FV_TMH0_MDP(mask) | FV_TMH0_TXMES_LEN((len + 1) / 2) |
  116ecc:	f2cf 4004 	movt	r0, #62468	; 0xf404
        *tmh2 = (uint32_t)(val >> 32);
  116ed0:	f2cf 4204 	movt	r2, #62468	; 0xf404
    *tmh0  = FV_TMH0_MDP(mask) | FV_TMH0_TXMES_LEN((len + 1) / 2) |
  116ed4:	f2c0 0402 	movt	r4, #2
    *tmh1 = (uint32_t)val;
  116ed8:	f2cf 4104 	movt	r1, #62468	; 0xf404
    *tmh0  = FV_TMH0_MDP(mask) | FV_TMH0_TXMES_LEN((len + 1) / 2) |
  116edc:	6004      	str	r4, [r0, #0]
    return NO_ERROR;
  116ede:	2000      	movs	r0, #0
    *tmh1 = (uint32_t)val;
  116ee0:	600e      	str	r6, [r1, #0]
        *tmh2 = (uint32_t)(val >> 32);
  116ee2:	6017      	str	r7, [r2, #0]
    tmc_reg[msg_id] |= BM_TMC0_TMC0_MSG_SEND;
  116ee4:	681a      	ldr	r2, [r3, #0]
  116ee6:	f042 0201 	orr.w	r2, r2, #1
  116eea:	601a      	str	r2, [r3, #0]
  116eec:	e7a1      	b.n	116e32 <reboot_sec+0x6e>
        ERROR("ssystem format error!");
  116eee:	f24f 2164 	movw	r1, #62052	; 0xf264
  116ef2:	f24f 30fc 	movw	r0, #62460	; 0xf3fc
  116ef6:	f2c0 0111 	movt	r1, #17
  116efa:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
  116efe:	f2c0 0011 	movt	r0, #17
  116f02:	f7fd fc7f 	bl	114804 <printf>
        return ERR_INVALID_ARGS;
  116f06:	f06f 0007 	mvn.w	r0, #7
  116f0a:	e792      	b.n	116e32 <reboot_sec+0x6e>

00116f0c <reboot_module>:
    reboot_ap2
};

int reboot_module(rb_module_e m, rb_opc_e opc, rb_arg *arg)
{
    if (m < 0 || m >= RB_MAX_M || !arg) {
  116f0c:	fab2 f382 	clz	r3, r2
{
  116f10:	b510      	push	{r4, r14}
  116f12:	4604      	mov	r4, r0
    if (m < 0 || m >= RB_MAX_M || !arg) {
  116f14:	095b      	lsrs	r3, r3, #5
  116f16:	2804      	cmp	r0, #4
  116f18:	bf88      	it	hi
  116f1a:	f043 0301 	orrhi.w	r3, r3, #1
  116f1e:	b953      	cbnz	r3, 116f36 <reboot_module+0x2a>
        ERROR("invalid module id:%d or arg", m);
        return ERR_NOT_FOUND;
    }

    return (proc[m])(opc, arg);
  116f20:	f24f 239c 	movw	r3, #62108	; 0xf29c
  116f24:	4608      	mov	r0, r1
  116f26:	4611      	mov	r1, r2
  116f28:	f2c0 0311 	movt	r3, #17
  116f2c:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
}
  116f30:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    return (proc[m])(opc, arg);
  116f34:	4718      	bx	r3
  116f36:	4603      	mov	r3, r0
        ERROR("invalid module id:%d or arg", m);
  116f38:	f24f 2170 	movw	r1, #62064	; 0xf270
  116f3c:	f24f 3098 	movw	r0, #62360	; 0xf398
  116f40:	f2c0 0111 	movt	r1, #17
  116f44:	f44f 72de 	mov.w	r2, #444	; 0x1bc
  116f48:	f2c0 0011 	movt	r0, #17
  116f4c:	f7fd fc5a 	bl	114804 <printf>
}
  116f50:	f06f 0001 	mvn.w	r0, #1
  116f54:	bd10      	pop	{r4, r15}
  116f56:	bf00      	nop

00116f58 <tca9539_input_val>:
static int tca9539_input_val(struct tca9539_device *dev, int port_index)
{
    int ret = 0;
    u8 reg, val = 0;

    if (port_index >= 1 && port_index <= 8) {
  116f58:	1e4b      	subs	r3, r1, #1
  116f5a:	2b07      	cmp	r3, #7
{
  116f5c:	b5f0      	push	{r4, r5, r6, r7, r14}
  116f5e:	4602      	mov	r2, r0
  116f60:	b085      	sub	sp, #20
  116f62:	460d      	mov	r5, r1
    if (port_index >= 1 && port_index <= 8) {
  116f64:	d923      	bls.n	116fae <tca9539_input_val+0x56>
        reg = TCA9539_REG_INPUT_PORT0;
    }
    else if (port_index >= 9 && port_index <= 16) {
  116f66:	f1a1 0309 	sub.w	r3, r1, #9
  116f6a:	2b07      	cmp	r3, #7
  116f6c:	d821      	bhi.n	116fb2 <tca9539_input_val+0x5a>
        reg = TCA9539_REG_INPUT_PORT1;
  116f6e:	2701      	movs	r7, #1
        port_index -= 8;
  116f70:	f1a1 0508 	sub.w	r5, r1, #8
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116f74:	2601      	movs	r6, #1
  116f76:	ab03      	add	r3, sp, #12
    else {
        printf("error port index: %d\n", port_index);
        return ret;
    }

    ret = tca9539_read_reg(dev, reg, &val);
  116f78:	68d0      	ldr	r0, [r2, #12]
    memset(buf, 0, sizeof(buf));
  116f7a:	2400      	movs	r4, #0
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116f7c:	e9cd 3600 	strd	r3, r6, [r13]
  116f80:	4633      	mov	r3, r6
    ret = tca9539_read_reg(dev, reg, &val);
  116f82:	7a11      	ldrb	r1, [r2, #8]
  116f84:	f88d 700f 	strb.w	r7, [r13, #15]
    memset(buf, 0, sizeof(buf));
  116f88:	f88d 400c 	strb.w	r4, [r13, #12]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116f8c:	f10d 020f 	add.w	r2, r13, #15
  116f90:	f7f5 fde2 	bl	10cb58 <hal_i2c_read_reg_data>
    if (ret < 0) {
  116f94:	42a0      	cmp	r0, r4
  116f96:	bfa9      	itett	ge
  116f98:	f89d 000c 	ldrbge.w	r0, [r13, #12]
  116f9c:	4620      	movlt	r0, r4
  116f9e:	f105 35ff 	addge.w	r5, r5, #4294967295	; 0xffffffff
  116fa2:	40ae      	lslge	r6, r5
  116fa4:	bfa4      	itt	ge
  116fa6:	4030      	andge	r0, r6
  116fa8:	4128      	asrge	r0, r5
    dprintf(TCA9539_LOG, "\t	reg=0x%x, val=0x%x, \n", reg, val);
    ret = (val & (1 << (port_index - 1))) >> (port_index - 1);
    dprintf(TCA9539_LOG, "\t	i2c=%d, addr=0x%x, port=%d, val=0x%x, \n",
            dev->i2c_bus, dev->device_address, port_index, ret);
    return ret;
}
  116faa:	b005      	add	sp, #20
  116fac:	bdf0      	pop	{r4, r5, r6, r7, r15}
        reg = TCA9539_REG_INPUT_PORT0;
  116fae:	2700      	movs	r7, #0
  116fb0:	e7e0      	b.n	116f74 <tca9539_input_val+0x1c>
        printf("error port index: %d\n", port_index);
  116fb2:	f24f 4050 	movw	r0, #62544	; 0xf450
  116fb6:	f2c0 0011 	movt	r0, #17
  116fba:	f7fd fc23 	bl	114804 <printf>
        return ret;
  116fbe:	2000      	movs	r0, #0
}
  116fc0:	b005      	add	sp, #20
  116fc2:	bdf0      	pop	{r4, r5, r6, r7, r15}

00116fc4 <tca9539_input_enable>:

static int tca9539_input_enable(struct tca9539_device *dev, int port_index)
{
  116fc4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  116fc8:	4606      	mov	r6, r0
    int ret = 0;
    u8 reg, val = 0;

    if (port_index >= 1 && port_index <= 8) {
  116fca:	1e4d      	subs	r5, r1, #1
  116fcc:	2d07      	cmp	r5, #7
{
  116fce:	b084      	sub	sp, #16
    if (port_index >= 1 && port_index <= 8) {
  116fd0:	d92e      	bls.n	117030 <tca9539_input_enable+0x6c>
        reg = TCA9539_REG_CONFIG_PORT0;
    }
    else if (port_index >= 9 && port_index <= 16) {
  116fd2:	f1a1 0209 	sub.w	r2, r1, #9
  116fd6:	2a07      	cmp	r2, #7
  116fd8:	d82c      	bhi.n	117034 <tca9539_input_enable+0x70>
  116fda:	4615      	mov	r5, r2
        reg = TCA9539_REG_CONFIG_PORT1;
  116fdc:	2707      	movs	r7, #7
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116fde:	2301      	movs	r3, #1
  116fe0:	f10d 080c 	add.w	r8, r13, #12
    memset(buf, 0, sizeof(buf));
  116fe4:	2400      	movs	r4, #0
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116fe6:	f10d 020b 	add.w	r2, r13, #11
    else {
        printf("error port index: %d\n", port_index);
        return ret;
    }

    ret = tca9539_read_reg(dev, reg, &val);
  116fea:	68f0      	ldr	r0, [r6, #12]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116fec:	e9cd 8300 	strd	r8, r3, [r13]
    ret = tca9539_read_reg(dev, reg, &val);
  116ff0:	7a31      	ldrb	r1, [r6, #8]
    memset(buf, 0, sizeof(buf));
  116ff2:	f88d 400c 	strb.w	r4, [r13, #12]
  116ff6:	f88d 700b 	strb.w	r7, [r13, #11]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  116ffa:	f7f5 fdad 	bl	10cb58 <hal_i2c_read_reg_data>

    val |= 1 << (port_index - 1);
  116ffe:	2301      	movs	r3, #1
    dprintf(TCA9539_LOG, "%s: reg:0x%x, val:0x%x\n", __func__, reg, val);
    ret = tca9539_write_reg(dev, reg, val);
  117000:	7a31      	ldrb	r1, [r6, #8]
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  117002:	4642      	mov	r2, r8
    val |= 1 << (port_index - 1);
  117004:	fa03 f505 	lsl.w	r5, r3, r5
    if (ret < 0) {
  117008:	42a0      	cmp	r0, r4
  11700a:	bfa8      	it	ge
  11700c:	f99d 400c 	ldrsbge.w	r4, [r13, #12]
    buf[0] = reg;
  117010:	f88d 700c 	strb.w	r7, [r13, #12]
    val |= 1 << (port_index - 1);
  117014:	432c      	orrs	r4, r5
    ret = tca9539_write_reg(dev, reg, val);
  117016:	68f0      	ldr	r0, [r6, #12]
    buf[1] = val;
  117018:	af04      	add	r7, sp, #16
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  11701a:	9301      	str	r3, [sp, #4]
    buf[1] = val;
  11701c:	f807 4d03 	strb.w	r4, [r7, #-3]!
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  117020:	9700      	str	r7, [sp, #0]
  117022:	f7f5 fd6f 	bl	10cb04 <hal_i2c_write_reg_data>
  117026:	ea00 70e0 	and.w	r0, r0, r0, asr #31

    //tca9539_dump_registers(dev);

    return ret;
}
  11702a:	b004      	add	sp, #16
  11702c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        reg = TCA9539_REG_CONFIG_PORT0;
  117030:	2706      	movs	r7, #6
  117032:	e7d4      	b.n	116fde <tca9539_input_enable+0x1a>
        printf("error port index: %d\n", port_index);
  117034:	f24f 4050 	movw	r0, #62544	; 0xf450
  117038:	f2c0 0011 	movt	r0, #17
  11703c:	f7fd fbe2 	bl	114804 <printf>
        return ret;
  117040:	2000      	movs	r0, #0
}
  117042:	b004      	add	sp, #16
  117044:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00117048 <tca9539_output_val>:
{
  117048:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  11704c:	4605      	mov	r5, r0
    if (port_index >= 1 && port_index <= 8) {
  11704e:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
  117052:	f1b9 0f07 	cmp.w	r9, #7
{
  117056:	4690      	mov	r8, r2
  117058:	b085      	sub	sp, #20
    if (port_index >= 1 && port_index <= 8) {
  11705a:	d937      	bls.n	1170cc <tca9539_output_val+0x84>
    else if (port_index >= 9 && port_index <= 16) {
  11705c:	f1a1 0209 	sub.w	r2, r1, #9
  117060:	2a07      	cmp	r2, #7
  117062:	d835      	bhi.n	1170d0 <tca9539_output_val+0x88>
  117064:	4691      	mov	r9, r2
        reg = TCA9539_REG_OUTPUT_PORT1;
  117066:	2603      	movs	r6, #3
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117068:	2301      	movs	r3, #1
  11706a:	af03      	add	r7, sp, #12
    memset(buf, 0, sizeof(buf));
  11706c:	2400      	movs	r4, #0
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  11706e:	f10d 020b 	add.w	r2, r13, #11
    ret = tca9539_read_reg(dev, reg, &val);
  117072:	68e8      	ldr	r0, [r5, #12]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117074:	e9cd 7300 	strd	r7, r3, [r13]
    ret = tca9539_read_reg(dev, reg, &val);
  117078:	7a29      	ldrb	r1, [r5, #8]
    memset(buf, 0, sizeof(buf));
  11707a:	f88d 400c 	strb.w	r4, [r13, #12]
  11707e:	f88d 600b 	strb.w	r6, [r13, #11]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117082:	f7f5 fd69 	bl	10cb58 <hal_i2c_read_reg_data>
  117086:	2301      	movs	r3, #1
    buf[1] = val;
  117088:	a904      	add	r1, sp, #16
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  11708a:	f04f 0c01 	mov.w	r12, #1
  11708e:	463a      	mov	r2, r7
  117090:	fa03 f309 	lsl.w	r3, r3, r9
  117094:	b25b      	sxtb	r3, r3
    if (ret < 0) {
  117096:	42a0      	cmp	r0, r4
  117098:	bfa8      	it	ge
  11709a:	f99d 400c 	ldrsbge.w	r4, [r13, #12]
    buf[0] = reg;
  11709e:	f88d 600c 	strb.w	r6, [r13, #12]
    if (v == 1)
  1170a2:	f1b8 0f01 	cmp.w	r8, #1
        val |= 1 << (port_index - 1);
  1170a6:	bf0c      	ite	eq
  1170a8:	431c      	orreq	r4, r3
        val &= ~(1 << (port_index - 1));
  1170aa:	439c      	bicne	r4, r3
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  1170ac:	4663      	mov	r3, r12
        val &= ~(1 << (port_index - 1));
  1170ae:	b2e4      	uxtb	r4, r4
    buf[1] = val;
  1170b0:	f801 4d03 	strb.w	r4, [r1, #-3]!
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  1170b4:	9100      	str	r1, [sp, #0]
    ret = tca9539_write_reg(dev, reg, val);
  1170b6:	7a29      	ldrb	r1, [r5, #8]
  1170b8:	68e8      	ldr	r0, [r5, #12]
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  1170ba:	f8cd c004 	str.w	r12, [r13, #4]
  1170be:	f7f5 fd21 	bl	10cb04 <hal_i2c_write_reg_data>
  1170c2:	ea00 70e0 	and.w	r0, r0, r0, asr #31
}
  1170c6:	b005      	add	sp, #20
  1170c8:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        reg = TCA9539_REG_OUTPUT_PORT0;
  1170cc:	2602      	movs	r6, #2
  1170ce:	e7cb      	b.n	117068 <tca9539_output_val+0x20>
        printf("error port index: %d\n", port_index);
  1170d0:	f24f 4050 	movw	r0, #62544	; 0xf450
  1170d4:	f2c0 0011 	movt	r0, #17
  1170d8:	f7fd fb94 	bl	114804 <printf>
        return ret;
  1170dc:	2000      	movs	r0, #0
}
  1170de:	b005      	add	sp, #20
  1170e0:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}

001170e4 <tca9539_output_enable>:
    if (port_index >= 1 && port_index <= 8) {
  1170e4:	1e4b      	subs	r3, r1, #1
  1170e6:	2b07      	cmp	r3, #7
{
  1170e8:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  1170ec:	460c      	mov	r4, r1
  1170ee:	b085      	sub	sp, #20
  1170f0:	4606      	mov	r6, r0
    if (port_index >= 1 && port_index <= 8) {
  1170f2:	d937      	bls.n	117164 <tca9539_output_enable+0x80>
    else if (port_index >= 9 && port_index <= 16) {
  1170f4:	f1a1 0309 	sub.w	r3, r1, #9
  1170f8:	2b07      	cmp	r3, #7
  1170fa:	d835      	bhi.n	117168 <tca9539_output_enable+0x84>
        reg = TCA9539_REG_CONFIG_PORT1;
  1170fc:	2707      	movs	r7, #7
        port_index -= 8;
  1170fe:	f1a1 0408 	sub.w	r4, r1, #8
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117102:	f04f 0901 	mov.w	r9, #1
  117106:	f10d 080c 	add.w	r8, r13, #12
    memset(buf, 0, sizeof(buf));
  11710a:	2500      	movs	r5, #0
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  11710c:	464b      	mov	r3, r9
    ret = tca9539_read_reg(dev, reg, &val);
  11710e:	68f0      	ldr	r0, [r6, #12]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117110:	f10d 020b 	add.w	r2, r13, #11
  117114:	f8cd 9004 	str.w	r9, [r13, #4]
  117118:	f8cd 8000 	str.w	r8, [r13]
    ret = tca9539_read_reg(dev, reg, &val);
  11711c:	7a31      	ldrb	r1, [r6, #8]
    memset(buf, 0, sizeof(buf));
  11711e:	f88d 500c 	strb.w	r5, [r13, #12]
  117122:	f88d 700b 	strb.w	r7, [r13, #11]
    ret = hal_i2c_read_reg_data(dev->i2c_handle, dev->device_address, &reg, 1,
  117126:	f7f5 fd17 	bl	10cb58 <hal_i2c_read_reg_data>
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  11712a:	4642      	mov	r2, r8
    buf[1] = val;
  11712c:	a904      	add	r1, sp, #16
    if (ret < 0) {
  11712e:	42a8      	cmp	r0, r5
  117130:	bfa8      	it	ge
  117132:	f89d 500c 	ldrbge.w	r5, [r13, #12]
    buf[0] = reg;
  117136:	f88d 700c 	strb.w	r7, [r13, #12]
  11713a:	bfa2      	ittt	ge
  11713c:	f104 34ff 	addge.w	r4, r4, #4294967295	; 0xffffffff
  117140:	fa09 f404 	lslge.w	r4, r9, r4
  117144:	43a5      	bicge	r5, r4
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  117146:	2401      	movs	r4, #1
    buf[1] = val;
  117148:	f801 5d03 	strb.w	r5, [r1, #-3]!
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  11714c:	4623      	mov	r3, r4
  11714e:	9100      	str	r1, [sp, #0]
    ret = tca9539_write_reg(dev, reg, val);
  117150:	7a31      	ldrb	r1, [r6, #8]
  117152:	68f0      	ldr	r0, [r6, #12]
    ret = hal_i2c_write_reg_data(dev->i2c_handle, dev->device_address, buf, 1,
  117154:	9401      	str	r4, [sp, #4]
  117156:	f7f5 fcd5 	bl	10cb04 <hal_i2c_write_reg_data>
  11715a:	ea00 70e0 	and.w	r0, r0, r0, asr #31
}
  11715e:	b005      	add	sp, #20
  117160:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        reg = TCA9539_REG_CONFIG_PORT0;
  117164:	2706      	movs	r7, #6
  117166:	e7cc      	b.n	117102 <tca9539_output_enable+0x1e>
        printf("error port index: %d\n", port_index);
  117168:	f24f 4050 	movw	r0, #62544	; 0xf450
  11716c:	f2c0 0011 	movt	r0, #17
  117170:	f7fd fb48 	bl	114804 <printf>
        return ret;
  117174:	2000      	movs	r0, #0
}
  117176:	b005      	add	sp, #20
  117178:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}

0011717c <tca9539_init>:
    .input_val = tca9539_input_val,
    .input_enable = tca9539_input_enable,
};

struct tca9539_device *tca9539_init(int i2c_bus, u8 addr)
{
  11717c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    struct tca9539_device *dev = NULL;
    void *i2c_handle = NULL;
  117180:	2200      	movs	r2, #0
{
  117182:	b082      	sub	sp, #8
  117184:	f243 2578 	movw	r5, #12920	; 0x3278
    void *i2c_handle = NULL;
  117188:	9201      	str	r2, [sp, #4]
  11718a:	f2c0 0513 	movt	r5, #19
  11718e:	462f      	mov	r7, r5
  117190:	f105 0640 	add.w	r6, r5, #64	; 0x40
  117194:	462b      	mov	r3, r5
  117196:	e001      	b.n	11719c <tca9539_init+0x20>
    int i;

    for (i = 0; i < MAX_DEVICE_NUM; i++) {
  117198:	42b3      	cmp	r3, r6
  11719a:	d010      	beq.n	1171be <tca9539_init+0x42>
        if (pdev[i] != NULL) {
  11719c:	f853 4b04 	ldr.w	r4, [r3], #4
  1171a0:	2c00      	cmp	r4, #0
  1171a2:	d0f9      	beq.n	117198 <tca9539_init+0x1c>
            if (pdev[i]->i2c_bus == i2c_bus && pdev[i]->device_address == addr) {
  1171a4:	6862      	ldr	r2, [r4, #4]
  1171a6:	4282      	cmp	r2, r0
  1171a8:	d1f6      	bne.n	117198 <tca9539_init+0x1c>
  1171aa:	7a22      	ldrb	r2, [r4, #8]
  1171ac:	428a      	cmp	r2, r1
  1171ae:	d1f3      	bne.n	117198 <tca9539_init+0x1c>
                pdev[i]->count++;
  1171b0:	6823      	ldr	r3, [r4, #0]
  1171b2:	3301      	adds	r3, #1
  1171b4:	6023      	str	r3, [r4, #0]

    dev->ops = dev_ops;

    dprintf(TCA9539_LOG, "%s() end\n\n", __func__);
    return dev;
}
  1171b6:	4620      	mov	r0, r4
  1171b8:	b002      	add	sp, #8
  1171ba:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  1171be:	4688      	mov	r8, r1
    switch (i2c_bus) {
  1171c0:	1e43      	subs	r3, r0, #1
  1171c2:	4606      	mov	r6, r0
  1171c4:	2b0f      	cmp	r3, #15
  1171c6:	f200 80b7 	bhi.w	117338 <tca9539_init+0x1bc>
  1171ca:	e8df f003 	tbb	[r15, r3]
  1171ce:	9ea6      	.short	0x9ea6
  1171d0:	7e868e96 	.word	0x7e868e96
  1171d4:	5e666e76 	.word	0x5e666e76
  1171d8:	3e464e56 	.word	0x3e464e56
  1171dc:	0836      	.short	0x0836
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C16);
  1171de:	2137      	movs	r1, #55	; 0x37
  1171e0:	a801      	add	r0, sp, #4
  1171e2:	f2c4 2145 	movt	r1, #16965	; 0x4245
  1171e6:	f7f5 facd 	bl	10c784 <hal_i2c_creat_handle>
    dev = malloc(sizeof(*dev));
  1171ea:	2101      	movs	r1, #1
  1171ec:	2020      	movs	r0, #32
  1171ee:	f7fa f9b5 	bl	11155c <calloc>
    if (!dev)
  1171f2:	4604      	mov	r4, r0
  1171f4:	2800      	cmp	r0, #0
  1171f6:	d0de      	beq.n	1171b6 <tca9539_init+0x3a>
    dev->i2c_handle = i2c_handle;
  1171f8:	9a01      	ldr	r2, [sp, #4]
    for (i = 0; i < MAX_DEVICE_NUM; i++) {
  1171fa:	2300      	movs	r3, #0
    dev->i2c_bus = i2c_bus;
  1171fc:	6046      	str	r6, [r0, #4]
    dev->device_address = addr;
  1171fe:	f880 8008 	strb.w	r8, [r0, #8]
    dev->i2c_handle = i2c_handle;
  117202:	60c2      	str	r2, [r0, #12]
  117204:	e003      	b.n	11720e <tca9539_init+0x92>
    for (i = 0; i < MAX_DEVICE_NUM; i++) {
  117206:	3301      	adds	r3, #1
  117208:	2b10      	cmp	r3, #16
  11720a:	f000 808e 	beq.w	11732a <tca9539_init+0x1ae>
        if (pdev[i] == NULL) {
  11720e:	f855 2b04 	ldr.w	r2, [r5], #4
  117212:	2a00      	cmp	r2, #0
  117214:	d1f7      	bne.n	117206 <tca9539_init+0x8a>
            pdev[i]->count++;
  117216:	6822      	ldr	r2, [r4, #0]
            pdev[i] = dev;
  117218:	f847 4023 	str.w	r4, [r7, r3, lsl #2]
            pdev[i]->count++;
  11721c:	3201      	adds	r2, #1
  11721e:	6022      	str	r2, [r4, #0]
    dev->ops = dev_ops;
  117220:	f24f 4320 	movw	r3, #62496	; 0xf420
  117224:	f104 0510 	add.w	r5, r4, #16
  117228:	f2c0 0311 	movt	r3, #17
  11722c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  11722e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
}
  117232:	4620      	mov	r0, r4
  117234:	b002      	add	sp, #8
  117236:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C15);
  11723a:	f24f 0136 	movw	r1, #61494	; 0xf036
  11723e:	a801      	add	r0, sp, #4
  117240:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117244:	f7f5 fa9e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117248:	e7cf      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C14);
  11724a:	f24e 0135 	movw	r1, #57397	; 0xe035
  11724e:	a801      	add	r0, sp, #4
  117250:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117254:	f7f5 fa96 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117258:	e7c7      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C13);
  11725a:	f24d 0134 	movw	r1, #53300	; 0xd034
  11725e:	a801      	add	r0, sp, #4
  117260:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117264:	f7f5 fa8e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117268:	e7bf      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C12);
  11726a:	f24c 0133 	movw	r1, #49203	; 0xc033
  11726e:	a801      	add	r0, sp, #4
  117270:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117274:	f7f5 fa86 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117278:	e7b7      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C11);
  11727a:	f24b 0132 	movw	r1, #45106	; 0xb032
  11727e:	a801      	add	r0, sp, #4
  117280:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117284:	f7f5 fa7e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117288:	e7af      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C10);
  11728a:	f24a 0131 	movw	r1, #41009	; 0xa031
  11728e:	a801      	add	r0, sp, #4
  117290:	f2c4 2144 	movt	r1, #16964	; 0x4244
  117294:	f7f5 fa76 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117298:	e7a7      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C9);
  11729a:	f249 0130 	movw	r1, #36912	; 0x9030
  11729e:	a801      	add	r0, sp, #4
  1172a0:	f2c4 2144 	movt	r1, #16964	; 0x4244
  1172a4:	f7f5 fa6e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172a8:	e79f      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C8);
  1172aa:	f248 012f 	movw	r1, #32815	; 0x802f
  1172ae:	a801      	add	r0, sp, #4
  1172b0:	f2c4 2144 	movt	r1, #16964	; 0x4244
  1172b4:	f7f5 fa66 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172b8:	e797      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C7);
  1172ba:	f247 012e 	movw	r1, #28718	; 0x702e
  1172be:	a801      	add	r0, sp, #4
  1172c0:	f2c4 2144 	movt	r1, #16964	; 0x4244
  1172c4:	f7f5 fa5e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172c8:	e78f      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C6);
  1172ca:	f246 012d 	movw	r1, #24621	; 0x602d
  1172ce:	a801      	add	r0, sp, #4
  1172d0:	f2c4 2144 	movt	r1, #16964	; 0x4244
  1172d4:	f7f5 fa56 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172d8:	e787      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C5);
  1172da:	f245 012c 	movw	r1, #20524	; 0x502c
  1172de:	a801      	add	r0, sp, #4
  1172e0:	f2c4 2144 	movt	r1, #16964	; 0x4244
  1172e4:	f7f5 fa4e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172e8:	e77f      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C4);
  1172ea:	f244 010e 	movw	r1, #16398	; 0x400e
  1172ee:	a801      	add	r0, sp, #4
  1172f0:	f2c4 0144 	movt	r1, #16452	; 0x4044
  1172f4:	f7f5 fa46 	bl	10c784 <hal_i2c_creat_handle>
            break;
  1172f8:	e777      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C3);
  1172fa:	f243 010d 	movw	r1, #12301	; 0x300d
  1172fe:	a801      	add	r0, sp, #4
  117300:	f2c4 0144 	movt	r1, #16452	; 0x4044
  117304:	f7f5 fa3e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117308:	e76f      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C2);
  11730a:	f242 010c 	movw	r1, #8204	; 0x200c
  11730e:	a801      	add	r0, sp, #4
  117310:	f2c4 0144 	movt	r1, #16452	; 0x4044
  117314:	f7f5 fa36 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117318:	e767      	b.n	1171ea <tca9539_init+0x6e>
            hal_i2c_creat_handle(&i2c_handle, RES_I2C_I2C1);
  11731a:	f241 010b 	movw	r1, #4107	; 0x100b
  11731e:	a801      	add	r0, sp, #4
  117320:	f2c4 0144 	movt	r1, #16452	; 0x4044
  117324:	f7f5 fa2e 	bl	10c784 <hal_i2c_creat_handle>
            break;
  117328:	e75f      	b.n	1171ea <tca9539_init+0x6e>
        printf("have no space!\n");
  11732a:	f24f 4040 	movw	r0, #62528	; 0xf440
  11732e:	f2c0 0011 	movt	r0, #17
  117332:	f7fd fa4f 	bl	1147d4 <puts>
  117336:	e773      	b.n	117220 <tca9539_init+0xa4>
            printf("wrong i2c bus\n");
  117338:	f24f 4030 	movw	r0, #62512	; 0xf430
            return 0;
  11733c:	2400      	movs	r4, #0
            printf("wrong i2c bus\n");
  11733e:	f2c0 0011 	movt	r0, #17
  117342:	f7fd fa47 	bl	1147d4 <puts>
            return 0;
  117346:	e736      	b.n	1171b6 <tca9539_init+0x3a>

00117348 <tca9539_enable_i2cpoll>:

int tca9539_enable_i2cpoll(struct tca9539_device *dev)
{
  117348:	b5f0      	push	{r4, r5, r6, r7, r14}
    void *i2c_handle = NULL;
    i2c_app_config_t i2c_conf;

    i2c_handle = dev->i2c_handle;
  11734a:	68c6      	ldr	r6, [r0, #12]
{
  11734c:	b08d      	sub	sp, #52	; 0x34

    if (!i2c_handle)
  11734e:	b186      	cbz	r6, 117372 <tca9539_enable_i2cpoll+0x2a>
        return -1;

    i2c_conf = hal_i2c_get_busconfig(i2c_handle);
  117350:	466c      	mov	r4, r13
  117352:	4668      	mov	r0, r13
  117354:	4631      	mov	r1, r6
  117356:	ad07      	add	r5, sp, #28
  117358:	f7f5 fb62 	bl	10ca20 <hal_i2c_get_busconfig>
    i2c_conf.poll = 1;
  11735c:	2701      	movs	r7, #1
    i2c_conf = hal_i2c_get_busconfig(i2c_handle);
  11735e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  117360:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    hal_i2c_set_busconfig(i2c_handle, &i2c_conf);
  117362:	4630      	mov	r0, r6
  117364:	a907      	add	r1, sp, #28
    i2c_conf.poll = 1;
  117366:	970b      	str	r7, [sp, #44]	; 0x2c
    hal_i2c_set_busconfig(i2c_handle, &i2c_conf);
  117368:	f7f5 fb7c 	bl	10ca64 <hal_i2c_set_busconfig>
    return 0;
  11736c:	2000      	movs	r0, #0
}
  11736e:	b00d      	add	sp, #52	; 0x34
  117370:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return -1;
  117372:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  117376:	e7fa      	b.n	11736e <tca9539_enable_i2cpoll+0x26>

00117378 <tca9539_deinit>:

void tca9539_deinit(struct tca9539_device *dev)
{
  117378:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  11737a:	4c0d      	ldr	r4, [pc, #52]	; (1173b0 <tca9539_deinit+0x38>)
  11737c:	4605      	mov	r5, r0
  11737e:	f104 0740 	add.w	r7, r4, #64	; 0x40
  117382:	e001      	b.n	117388 <tca9539_deinit+0x10>
    for (int i = 0; i < MAX_DEVICE_NUM; i++) {
  117384:	42bc      	cmp	r4, r7
  117386:	d011      	beq.n	1173ac <tca9539_deinit+0x34>
        if (pdev[i] == dev) {
  117388:	f854 3f04 	ldr.w	r3, [r4, #4]!
  11738c:	42ab      	cmp	r3, r5
  11738e:	d1f9      	bne.n	117384 <tca9539_deinit+0xc>
            dev->count--;
  117390:	682e      	ldr	r6, [r5, #0]
  117392:	3e01      	subs	r6, #1
  117394:	602e      	str	r6, [r5, #0]

            if (dev->count == 0) {
  117396:	2e00      	cmp	r6, #0
  117398:	d1f4      	bne.n	117384 <tca9539_deinit+0xc>
                hal_i2c_release_handle(dev->i2c_handle);
  11739a:	68e8      	ldr	r0, [r5, #12]
  11739c:	f7f5 fb38 	bl	10ca10 <hal_i2c_release_handle>
                free(dev);
  1173a0:	4628      	mov	r0, r5
  1173a2:	f7fa f8eb 	bl	11157c <free>
                pdev[i] = NULL;
  1173a6:	6026      	str	r6, [r4, #0]
    for (int i = 0; i < MAX_DEVICE_NUM; i++) {
  1173a8:	42bc      	cmp	r4, r7
  1173aa:	d1ed      	bne.n	117388 <tca9539_deinit+0x10>
            }
        }
    }
}
  1173ac:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  1173ae:	bf00      	nop
  1173b0:	00133274 	.word	0x00133274

001173b4 <lt9611_irq_handler>:
    }
    return 0;
}

static enum handler_return lt9611_irq_handler(void *arg)
{
  1173b4:	b508      	push	{r3, r14}
    mask_gpio_interrupt(LT9611_HPD_IRQ_GPIO);
  1173b6:	204d      	movs	r0, #77	; 0x4d
  1173b8:	f7f5 f9d6 	bl	10c768 <mask_gpio_interrupt>
    event_signal(&event_hdmi_hpd, false);
  1173bc:	f243 20fc 	movw	r0, #13052	; 0x32fc
  1173c0:	2100      	movs	r1, #0
  1173c2:	f2c0 0013 	movt	r0, #19
  1173c6:	f7ff f857 	bl	116478 <event_signal>
    printf("lt9611 LT9611_HPD_IRQ_GPIO(D13(77) irq handler attch !\n");
  1173ca:	f24f 408c 	movw	r0, #62604	; 0xf48c
  1173ce:	f2c0 0011 	movt	r0, #17
  1173d2:	f7fd f9ff 	bl	1147d4 <puts>
    return INT_RESCHEDULE;
}
  1173d6:	2001      	movs	r0, #1
  1173d8:	bd08      	pop	{r3, r15}
  1173da:	bf00      	nop

001173dc <lt9611_work_func>:
  1173dc:	f243 25fc 	movw	r5, #13052	; 0x32fc
        printf("lt9611_work_func hpd attch !\n");
  1173e0:	f24f 44c4 	movw	r4, #62660	; 0xf4c4
  1173e4:	f2c0 0513 	movt	r5, #19
  1173e8:	f2c0 0411 	movt	r4, #17
{
  1173ec:	b508      	push	{r3, r14}
  1173ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1173f2:	4628      	mov	r0, r5
  1173f4:	f7ff f806 	bl	116404 <event_wait_timeout>
        LT9611_IRQ_Task();
  1173f8:	f7fe ff20 	bl	11623c <LT9611_IRQ_Task>
        printf("lt9611_work_func hpd attch !\n");
  1173fc:	4620      	mov	r0, r4
  1173fe:	f7fd f9e9 	bl	1147d4 <puts>
        unmask_gpio_interrupt(LT9611_HPD_IRQ_GPIO);
  117402:	204d      	movs	r0, #77	; 0x4d
  117404:	f7f5 f9a2 	bl	10c74c <unmask_gpio_interrupt>
  117408:	e7f1      	b.n	1173ee <lt9611_work_func+0x12>
  11740a:	bf00      	nop

0011740c <config_lt9611_reset_pin>:
{
  11740c:	b538      	push	{r3, r4, r5, r14}
    pd = tca9539_init(12, 0x76);
  11740e:	2176      	movs	r1, #118	; 0x76
{
  117410:	4605      	mov	r5, r0
    pd = tca9539_init(12, 0x76);
  117412:	200c      	movs	r0, #12
  117414:	f7ff feb2 	bl	11717c <tca9539_init>
    if (pd == NULL) {
  117418:	b180      	cbz	r0, 11743c <config_lt9611_reset_pin+0x30>
  11741a:	4604      	mov	r4, r0
    tca9539_enable_i2cpoll(pd);
  11741c:	f7ff ff94 	bl	117348 <tca9539_enable_i2cpoll>
    pd->ops.output_enable(pd, TCA9539_P00);
  117420:	2101      	movs	r1, #1
  117422:	4620      	mov	r0, r4
  117424:	6923      	ldr	r3, [r4, #16]
  117426:	4798      	blx	r3
    pd->ops.output_val(pd, TCA9539_P00, level);
  117428:	462a      	mov	r2, r5
  11742a:	6963      	ldr	r3, [r4, #20]
  11742c:	4620      	mov	r0, r4
  11742e:	2101      	movs	r1, #1
  117430:	4798      	blx	r3
    tca9539_deinit(pd);
  117432:	4620      	mov	r0, r4
}
  117434:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    tca9539_deinit(pd);
  117438:	f7ff bf9e 	b.w	117378 <tca9539_deinit>
        printf("init tca9359 error!\n");
  11743c:	f24f 4078 	movw	r0, #62584	; 0xf478
  117440:	f2c0 0011 	movt	r0, #17
}
  117444:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
        printf("init tca9359 error!\n");
  117448:	f7fd b9c4 	b.w	1147d4 <puts>

0011744c <panel_post_end>:

static thread_t *lt9611_thread;
static int panel_post_end(void)
{
    int ret;
    printf("%s enter\n", __func__);
  11744c:	f24f 4168 	movw	r1, #62568	; 0xf468
  117450:	f24f 40e4 	movw	r0, #62692	; 0xf4e4
{
  117454:	b500      	push	{r14}
    printf("%s enter\n", __func__);
  117456:	f2c0 0111 	movt	r1, #17
{
  11745a:	b083      	sub	sp, #12
    printf("%s enter\n", __func__);
  11745c:	f2c0 0011 	movt	r0, #17
  117460:	f7fd f9d0 	bl	114804 <printf>

    //config lt9611
    const uint8_t i2c_addr = 0x39;
#if (TARGET_REFERENCE_D9 || TARGET_REFERENCE_D9P)
    lt9611_i2c_init(RES_I2C_I2C11, i2c_addr);
  117464:	f24b 0032 	movw	r0, #45106	; 0xb032
  117468:	2139      	movs	r1, #57	; 0x39
  11746a:	f2c4 2044 	movt	r0, #16964	; 0x4244
  11746e:	f7fe ff0d 	bl	11628c <lt9611_i2c_init>
    config_lt9611_reset_pin(0);
  117472:	2000      	movs	r0, #0
  117474:	f7ff ffca 	bl	11740c <config_lt9611_reset_pin>
    config_lt9611_reset_pin(1);
  117478:	2001      	movs	r0, #1
  11747a:	f7ff ffc7 	bl	11740c <config_lt9611_reset_pin>
#endif
    //LT9611_Reset
    lt9611_chip_reset();

    //LT9611 init
    ret = LT9611_Init();
  11747e:	f7fe fe77 	bl	116170 <LT9611_Init>
    if (ret < 0) {
  117482:	2800      	cmp	r0, #0
  117484:	db32      	blt.n	1174ec <panel_post_end+0xa0>
        printf("%s(): lt9611 init falied \n", __func__);
        return -1;
    }

    //HPD deal thread
    event_init(&event_hdmi_hpd, false, EVENT_FLAG_AUTOUNSIGNAL);
  117486:	f243 20fc 	movw	r0, #13052	; 0x32fc
  11748a:	2201      	movs	r2, #1
  11748c:	2100      	movs	r1, #0
  11748e:	f2c0 0013 	movt	r0, #19
  117492:	f7fe ff89 	bl	1163a8 <event_init>
    lt9611_thread = thread_create("lt9611", lt9611_work_func, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
  117496:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  11749a:	f247 31dd 	movw	r1, #29661	; 0x73dd
  11749e:	f24f 500c 	movw	r0, #62732	; 0xf50c
  1174a2:	2200      	movs	r2, #0
  1174a4:	f2c0 0111 	movt	r1, #17
  1174a8:	9300      	str	r3, [sp, #0]
  1174aa:	f2c0 0011 	movt	r0, #17
  1174ae:	2310      	movs	r3, #16
  1174b0:	f7ff f8d8 	bl	116664 <thread_create>
    thread_detach_and_resume(lt9611_thread);
  1174b4:	f7ff f9ba 	bl	11682c <thread_detach_and_resume>

    //register hpd gpio(PortConf_PIN_GPIO_D13(77)) irq
    register_gpio_int_handler(LT9611_HPD_IRQ_GPIO, IRQ_TYPE_EDGE_FALLING,
  1174b8:	f247 32b5 	movw	r2, #29621	; 0x73b5
  1174bc:	2300      	movs	r3, #0
  1174be:	f2c0 0211 	movt	r2, #17
  1174c2:	2102      	movs	r1, #2
  1174c4:	204d      	movs	r0, #77	; 0x4d
  1174c6:	f7f5 f933 	bl	10c730 <register_gpio_int_handler>
                              lt9611_irq_handler, NULL);
    unmask_gpio_interrupt(LT9611_HPD_IRQ_GPIO);
  1174ca:	204d      	movs	r0, #77	; 0x4d
  1174cc:	f7f5 f93e 	bl	10c74c <unmask_gpio_interrupt>
    dprintf(LCM_MIPI_LT9611_LOG, "register lt9611 irq\n");
    printf("%s down\n", __func__);
  1174d0:	f24f 4168 	movw	r1, #62568	; 0xf468
  1174d4:	f24f 5014 	movw	r0, #62740	; 0xf514
  1174d8:	f2c0 0111 	movt	r1, #17
  1174dc:	f2c0 0011 	movt	r0, #17
  1174e0:	f7fd f990 	bl	114804 <printf>

    return 0;
  1174e4:	2000      	movs	r0, #0
}
  1174e6:	b003      	add	sp, #12
  1174e8:	f85d fb04 	ldr.w	r15, [r13], #4
        printf("%s(): lt9611 init falied \n", __func__);
  1174ec:	f24f 4168 	movw	r1, #62568	; 0xf468
  1174f0:	f24f 40f0 	movw	r0, #62704	; 0xf4f0
  1174f4:	f2c0 0111 	movt	r1, #17
  1174f8:	f2c0 0011 	movt	r0, #17
  1174fc:	f7fd f982 	bl	114804 <printf>
        return -1;
  117500:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  117504:	e7ef      	b.n	1174e6 <panel_post_end+0x9a>
  117506:	bf00      	nop

00117508 <panel_post_begin>:
    ioret = hal_dio_creat_handle(&dio_handle, g_gpio_res.res_id[0]);
  117508:	f64d 43d4 	movw	r3, #56532	; 0xdcd4
  11750c:	f2c0 0311 	movt	r3, #17
{
  117510:	b510      	push	{r4, r14}
    ioret = hal_dio_creat_handle(&dio_handle, g_gpio_res.res_id[0]);
  117512:	6859      	ldr	r1, [r3, #4]
  117514:	f243 24f8 	movw	r4, #13048	; 0x32f8
  117518:	f2c0 0413 	movt	r4, #19
  11751c:	4620      	mov	r0, r4
  11751e:	f7f4 fa7b 	bl	10ba18 <hal_dio_creat_handle>
    if (!ioret) {
  117522:	b138      	cbz	r0, 117534 <panel_post_begin+0x2c>
    hal_dio_write_channel(dio_handle, PortConf_PIN_I2S_SC8_SCK, 1);
  117524:	6820      	ldr	r0, [r4, #0]
  117526:	2201      	movs	r2, #1
  117528:	2177      	movs	r1, #119	; 0x77
  11752a:	f7f4 faf9 	bl	10bb20 <hal_dio_write_channel>
    hal_dio_release_handle(&dio_handle);
  11752e:	4620      	mov	r0, r4
  117530:	f7f4 fabe 	bl	10bab0 <hal_dio_release_handle>
}
  117534:	2000      	movs	r0, #0
  117536:	bd10      	pop	{r4, r15}

00117538 <mem_image_init>:
    char name[MAX_GPT_NAME_SIZE];
    uint8_t reserved[40];
};

uint32_t mem_image_init(addr_t base, size_t sz)
{
  117538:	b538      	push	{r3, r4, r5, r14}
  11753a:	4604      	mov	r4, r0
  11753c:	460d      	mov	r5, r1
    mem_image_header_t *header = (mem_image_header_t *)base;
    uint32_t info_sz;

    info_sz = sizeof(mem_image_header_t);
    arch_invalidate_cache_range(base, info_sz);
  11753e:	2140      	movs	r1, #64	; 0x40
  117540:	f7ea e980 	blx	101844 <arch_invalidate_cache_range>
    if ( header->magic == IMG_SEEKER_MAGIC
  117544:	f247 7371 	movw	r3, #30577	; 0x7771
  117548:	6822      	ldr	r2, [r4, #0]
  11754a:	f2c7 7373 	movt	r3, #30579	; 0x7773
  11754e:	429a      	cmp	r2, r3
  117550:	d102      	bne.n	117558 <mem_image_init+0x20>
            && header->inited) {
  117552:	7d23      	ldrb	r3, [r4, #20]
        return 1;
  117554:	2001      	movs	r0, #1
            && header->inited) {
  117556:	b98b      	cbnz	r3, 11757c <mem_image_init+0x44>
    }

    memset(header, 0x0, info_sz);
  117558:	223c      	movs	r2, #60	; 0x3c
  11755a:	2100      	movs	r1, #0
  11755c:	1d20      	adds	r0, r4, #4
  11755e:	f7fc ea26 	blx	1139ac <memset>
    header->magic = IMG_SEEKER_MAGIC;
  117562:	f247 7371 	movw	r3, #30577	; 0x7771
    header->inited = 1;
  117566:	2201      	movs	r2, #1
    header->magic = IMG_SEEKER_MAGIC;
  117568:	f2c7 7373 	movt	r3, #30579	; 0x7773
    header->total_sz = sz;
    arch_clean_invalidate_cache_range(base, info_sz);
  11756c:	4620      	mov	r0, r4
  11756e:	2140      	movs	r1, #64	; 0x40
    header->total_sz = sz;
  117570:	60a5      	str	r5, [r4, #8]
    header->magic = IMG_SEEKER_MAGIC;
  117572:	6023      	str	r3, [r4, #0]
    header->inited = 1;
  117574:	7522      	strb	r2, [r4, #20]
    arch_clean_invalidate_cache_range(base, info_sz);
  117576:	f7ea e964 	blx	101840 <arch_clean_invalidate_cache_range>
    return 0;
  11757a:	2000      	movs	r0, #0
}
  11757c:	bd38      	pop	{r3, r4, r5, r15}
  11757e:	bf00      	nop

00117580 <mem_image_seek>:

    return 1;
}

uint32_t mem_image_seek(addr_t h, const char *name, mem_image_entry_t *info)
{
  117580:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
  117584:	4604      	mov	r4, r0
  117586:	460d      	mov	r5, r1
    uint32_t name_len;
    mem_image_header_t *header = (mem_image_header_t *)h;
    struct __mem_image_entry_info *__info = (struct __mem_image_entry_info *)(h + sizeof(mem_image_header_t));

    arch_invalidate_cache_range(h, HEADER_ENTRY_INFO_SIZE);
  117588:	f44f 6188 	mov.w	r1, #1088	; 0x440
{
  11758c:	4616      	mov	r6, r2
    arch_invalidate_cache_range(h, HEADER_ENTRY_INFO_SIZE);
  11758e:	f7ea e95a 	blx	101844 <arch_invalidate_cache_range>
    name_len = strlen(name);
  117592:	4628      	mov	r0, r5
  117594:	f7fd f96e 	bl	114874 <strlen>
    if (header->magic != IMG_SEEKER_MAGIC
  117598:	6822      	ldr	r2, [r4, #0]
  11759a:	f247 7371 	movw	r3, #30577	; 0x7771
  11759e:	f2c7 7373 	movt	r3, #30579	; 0x7773
  1175a2:	429a      	cmp	r2, r3
  1175a4:	d002      	beq.n	1175ac <mem_image_seek+0x2c>
            info->sz = __info->addr_info.sz;
            return 0;
        }
    }
out:
    return 1;
  1175a6:	2001      	movs	r0, #1
}
  1175a8:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
            || !header->inited) {
  1175ac:	7d23      	ldrb	r3, [r4, #20]
  1175ae:	2b00      	cmp	r3, #0
  1175b0:	d0f9      	beq.n	1175a6 <mem_image_seek+0x26>
  1175b2:	4680      	mov	r8, r0
    if (header->img_cnt > MAX_IMG_SEEKER_ENTRY_CNT || name_len == 0 || name_len > MAX_GPT_NAME_SIZE) {
  1175b4:	1e43      	subs	r3, r0, #1
  1175b6:	2b47      	cmp	r3, #71	; 0x47
  1175b8:	d8f5      	bhi.n	1175a6 <mem_image_seek+0x26>
  1175ba:	6923      	ldr	r3, [r4, #16]
    for (uint32_t i = 0; i < header->img_cnt; i++, __info++) {
  1175bc:	1e5a      	subs	r2, r3, #1
  1175be:	2a07      	cmp	r2, #7
  1175c0:	d8f1      	bhi.n	1175a6 <mem_image_seek+0x26>
    struct __mem_image_entry_info *__info = (struct __mem_image_entry_info *)(h + sizeof(mem_image_header_t));
  1175c2:	f104 0740 	add.w	r7, r4, #64	; 0x40
  1175c6:	eb07 19c3 	add.w	r9, r7, r3, lsl #7
  1175ca:	e002      	b.n	1175d2 <mem_image_seek+0x52>
    for (uint32_t i = 0; i < header->img_cnt; i++, __info++) {
  1175cc:	3780      	adds	r7, #128	; 0x80
  1175ce:	454f      	cmp	r7, r9
  1175d0:	d0e9      	beq.n	1175a6 <mem_image_seek+0x26>
        if (!strncmp(__info->name, name, strlen(name))) {
  1175d2:	4642      	mov	r2, r8
  1175d4:	4629      	mov	r1, r5
  1175d6:	f107 0010 	add.w	r0, r7, #16
  1175da:	f7fd f957 	bl	11488c <strncmp>
  1175de:	2800      	cmp	r0, #0
  1175e0:	d1f4      	bne.n	1175cc <mem_image_seek+0x4c>
            info->base = __info->addr_info.base + h;
  1175e2:	e9d7 8900 	ldrd	r8, r9, [r7]
            info->sz = __info->addr_info.sz;
  1175e6:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
  1175ea:	e9c6 2302 	strd	r2, r3, [r6, #8]
            info->base = __info->addr_info.base + h;
  1175ee:	eb18 0b04 	adds.w	r11, r8, r4
  1175f2:	f149 0c00 	adc.w	r12, r9, #0
  1175f6:	e9c6 bc00 	strd	r11, r12, [r6]
            return 0;
  1175fa:	e7d5      	b.n	1175a8 <mem_image_seek+0x28>

001175fc <update_boot_info.constprop.1>:
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
    bootinfo->boot_pin = data;
    return data;
}

static void update_boot_info(boot_info_t *bootinfo)
  1175fc:	b538      	push	{r3, r4, r5, r14}
{
    uint32_t data, pin;

    if (bootinfo->boot_ops & BOOT_INFO_BOOT_PIN_UPDATE_MASK)
  1175fe:	f243 3404 	movw	r4, #13060	; 0x3304
  117602:	f2c0 0413 	movt	r4, #19
  117606:	6823      	ldr	r3, [r4, #0]
  117608:	2b00      	cmp	r3, #0
  11760a:	db27      	blt.n	11765c <update_boot_info.constprop.1+0x60>
    data = readl(_ioaddr(APB_SCR_SEC_BASE + ((0x200 + 4 * 49) << 10)));
  11760c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  117610:	f6cf 022b 	movt	r2, #63531	; 0xf82b
  117614:	6812      	ldr	r2, [r2, #0]
    if (data & (1 << 8)) {
  117616:	05d1      	lsls	r1, r2, #23
  117618:	d421      	bmi.n	11765e <update_boot_info.constprop.1+0x62>
    data = readl(_ioaddr(APB_EFUSEC_BASE + 0x1000 + FUSE_BT_CGF_INDEX0 * 4));
  11761a:	f241 22b4 	movw	r2, #4788	; 0x12b4
  11761e:	f2cf 0201 	movt	r2, #61441	; 0xf001
  117622:	6812      	ldr	r2, [r2, #0]
    if (data & (1 << 25)) {
  117624:	0195      	lsls	r5, r2, #6
  117626:	d521      	bpl.n	11766c <update_boot_info.constprop.1+0x70>
        bootinfo->boot_ops |= BOOT_INFO_FROM_FUSE_MASK;
  117628:	f043 0302 	orr.w	r3, r3, #2
        data = (data & 0x3c000000) >> 26;
  11762c:	f3c2 6283 	ubfx	r2, r2, #26, #4
        bootinfo->boot_pin = data;
  117630:	e9c4 3200 	strd	r3, r2, [r4]
    if (pin == PIN_ERROR)
        pin = boot_get_pin_fuse(bootinfo);
    if (pin == PIN_ERROR)
        pin = boot_get_pin_gpio(bootinfo);

    data = readl(_ioaddr(APB_EFUSEC_BASE + 0x1000 + FUSE_BT_CGF_INDEX0 * 4));
  117634:	f241 22b4 	movw	r2, #4788	; 0x12b4
  117638:	f2cf 0201 	movt	r2, #61441	; 0xf001
  11763c:	6812      	ldr	r2, [r2, #0]
    /*  BT_FUSE0[24], 0 - Enable, 1 - Disable */
    if (data & 1 << 24) {
  11763e:	01d0      	lsls	r0, r2, #7
        bootinfo->boot_ops |= BOOT_INFO_USB_PROVISION_DIS_MASK;
  117640:	bf48      	it	mi
  117642:	f043 0308 	orrmi.w	r3, r3, #8
    }
    /* BT_FUSE0[18] */
    if (data & 1 << 18) {
  117646:	0351      	lsls	r1, r2, #13
        bootinfo->boot_ops |= BOOT_INFO_SAFETY_HANDOVER_DIS_MASK;
  117648:	bf48      	it	mi
  11764a:	f043 0310 	orrmi.w	r3, r3, #16
    }
    /* BT_FUSE0[17], 1 - Disable */
    if (data & 1 << 17) {
  11764e:	0392      	lsls	r2, r2, #14
        bootinfo->boot_ops |= BOOT_INFO_PEER_LOAD_ON_SAF_FAILURE_DIS_MASK;
  117650:	bf48      	it	mi
  117652:	f043 0320 	orrmi.w	r3, r3, #32
    }

    bootinfo->boot_ops |= BOOT_INFO_BOOT_PIN_UPDATE_MASK;
  117656:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  11765a:	6023      	str	r3, [r4, #0]
}
  11765c:	bd38      	pop	{r3, r4, r5, r15}
        bootinfo->boot_ops |= BOOT_INFO_FROM_SCR_MASK;
  11765e:	f043 0304 	orr.w	r3, r3, #4
        data &= 0xf;
  117662:	f002 020f 	and.w	r2, r2, #15
        bootinfo->boot_pin = data;
  117666:	e9c4 3200 	strd	r3, r2, [r4]
  11766a:	e7e3      	b.n	117634 <update_boot_info.constprop.1+0x38>
    handle_bootmode = hal_scr_create_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  11766c:	2004      	movs	r0, #4
  11766e:	f240 1101 	movw	r1, #257	; 0x101
  117672:	f2c0 1000 	movt	r0, #256	; 0x100
  117676:	f7f9 f837 	bl	1106e8 <hal_scr_create_handle>
    data = hal_scr_get(handle_bootmode);
  11767a:	f7f9 f84f 	bl	11071c <hal_scr_get>
    hal_scr_delete_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  11767e:	f240 1101 	movw	r1, #257	; 0x101
    data = hal_scr_get(handle_bootmode);
  117682:	4605      	mov	r5, r0
    hal_scr_delete_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  117684:	2004      	movs	r0, #4
  117686:	f2c0 1000 	movt	r0, #256	; 0x100
  11768a:	f7f9 f82f 	bl	1106ec <hal_scr_delete_handle>
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
  11768e:	6823      	ldr	r3, [r4, #0]
    data &= 0xf;
  117690:	f005 050f 	and.w	r5, r5, #15
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
  117694:	f043 0301 	orr.w	r3, r3, #1
  117698:	e9c4 3500 	strd	r3, r5, [r4]
  11769c:	e7ca      	b.n	117634 <update_boot_info.constprop.1+0x38>
  11769e:	bf00      	nop

001176a0 <boot_get_pin>:

uint32_t boot_get_pin(void)
{
  1176a0:	b508      	push	{r3, r14}
    update_boot_info(&g_bootinfo);
  1176a2:	f7ff ffab 	bl	1175fc <update_boot_info.constprop.1>
    return g_bootinfo.boot_pin;
  1176a6:	f243 3304 	movw	r3, #13060	; 0x3304
  1176aa:	f2c0 0313 	movt	r3, #19
}
  1176ae:	6858      	ldr	r0, [r3, #4]
  1176b0:	bd08      	pop	{r3, r15}
  1176b2:	bf00      	nop

001176b4 <__aeabi_drsub>:
  1176b4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  1176b8:	e002      	b.n	1176c0 <__adddf3>
  1176ba:	bf00      	nop

001176bc <__aeabi_dsub>:
  1176bc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

001176c0 <__adddf3>:
  1176c0:	b530      	push	{r4, r5, r14}
  1176c2:	ea4f 0441 	mov.w	r4, r1, lsl #1
  1176c6:	ea4f 0543 	mov.w	r5, r3, lsl #1
  1176ca:	ea94 0f05 	teq	r4, r5
  1176ce:	bf08      	it	eq
  1176d0:	ea90 0f02 	teqeq	r0, r2
  1176d4:	bf1f      	itttt	ne
  1176d6:	ea54 0c00 	orrsne.w	r12, r4, r0
  1176da:	ea55 0c02 	orrsne.w	r12, r5, r2
  1176de:	ea7f 5c64 	mvnsne.w	r12, r4, asr #21
  1176e2:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  1176e6:	f000 80e2 	beq.w	1178ae <__adddf3+0x1ee>
  1176ea:	ea4f 5454 	mov.w	r4, r4, lsr #21
  1176ee:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  1176f2:	bfb8      	it	lt
  1176f4:	426d      	neglt	r5, r5
  1176f6:	dd0c      	ble.n	117712 <__adddf3+0x52>
  1176f8:	442c      	add	r4, r5
  1176fa:	ea80 0202 	eor.w	r2, r0, r2
  1176fe:	ea81 0303 	eor.w	r3, r1, r3
  117702:	ea82 0000 	eor.w	r0, r2, r0
  117706:	ea83 0101 	eor.w	r1, r3, r1
  11770a:	ea80 0202 	eor.w	r2, r0, r2
  11770e:	ea81 0303 	eor.w	r3, r1, r3
  117712:	2d36      	cmp	r5, #54	; 0x36
  117714:	bf88      	it	hi
  117716:	bd30      	pophi	{r4, r5, r15}
  117718:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  11771c:	ea4f 3101 	mov.w	r1, r1, lsl #12
  117720:	f44f 1c80 	mov.w	r12, #1048576	; 0x100000
  117724:	ea4c 3111 	orr.w	r1, r12, r1, lsr #12
  117728:	d002      	beq.n	117730 <__adddf3+0x70>
  11772a:	4240      	negs	r0, r0
  11772c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  117730:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  117734:	ea4f 3303 	mov.w	r3, r3, lsl #12
  117738:	ea4c 3313 	orr.w	r3, r12, r3, lsr #12
  11773c:	d002      	beq.n	117744 <__adddf3+0x84>
  11773e:	4252      	negs	r2, r2
  117740:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  117744:	ea94 0f05 	teq	r4, r5
  117748:	f000 80a7 	beq.w	11789a <__adddf3+0x1da>
  11774c:	f1a4 0401 	sub.w	r4, r4, #1
  117750:	f1d5 0e20 	rsbs	r14, r5, #32
  117754:	db0d      	blt.n	117772 <__adddf3+0xb2>
  117756:	fa02 fc0e 	lsl.w	r12, r2, r14
  11775a:	fa22 f205 	lsr.w	r2, r2, r5
  11775e:	1880      	adds	r0, r0, r2
  117760:	f141 0100 	adc.w	r1, r1, #0
  117764:	fa03 f20e 	lsl.w	r2, r3, r14
  117768:	1880      	adds	r0, r0, r2
  11776a:	fa43 f305 	asr.w	r3, r3, r5
  11776e:	4159      	adcs	r1, r3
  117770:	e00e      	b.n	117790 <__adddf3+0xd0>
  117772:	f1a5 0520 	sub.w	r5, r5, #32
  117776:	f10e 0e20 	add.w	r14, r14, #32
  11777a:	2a01      	cmp	r2, #1
  11777c:	fa03 fc0e 	lsl.w	r12, r3, r14
  117780:	bf28      	it	cs
  117782:	f04c 0c02 	orrcs.w	r12, r12, #2
  117786:	fa43 f305 	asr.w	r3, r3, r5
  11778a:	18c0      	adds	r0, r0, r3
  11778c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  117790:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  117794:	d507      	bpl.n	1177a6 <__adddf3+0xe6>
  117796:	f04f 0e00 	mov.w	r14, #0
  11779a:	f1dc 0c00 	rsbs	r12, r12, #0
  11779e:	eb7e 0000 	sbcs.w	r0, r14, r0
  1177a2:	eb6e 0101 	sbc.w	r1, r14, r1
  1177a6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  1177aa:	d31b      	bcc.n	1177e4 <__adddf3+0x124>
  1177ac:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  1177b0:	d30c      	bcc.n	1177cc <__adddf3+0x10c>
  1177b2:	0849      	lsrs	r1, r1, #1
  1177b4:	ea5f 0030 	movs.w	r0, r0, rrx
  1177b8:	ea4f 0c3c 	mov.w	r12, r12, rrx
  1177bc:	f104 0401 	add.w	r4, r4, #1
  1177c0:	ea4f 5244 	mov.w	r2, r4, lsl #21
  1177c4:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  1177c8:	f080 809a 	bcs.w	117900 <__adddf3+0x240>
  1177cc:	f1bc 4f00 	cmp.w	r12, #2147483648	; 0x80000000
  1177d0:	bf08      	it	eq
  1177d2:	ea5f 0c50 	movseq.w	r12, r0, lsr #1
  1177d6:	f150 0000 	adcs.w	r0, r0, #0
  1177da:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  1177de:	ea41 0105 	orr.w	r1, r1, r5
  1177e2:	bd30      	pop	{r4, r5, r15}
  1177e4:	ea5f 0c4c 	movs.w	r12, r12, lsl #1
  1177e8:	4140      	adcs	r0, r0
  1177ea:	eb41 0101 	adc.w	r1, r1, r1
  1177ee:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  1177f2:	f1a4 0401 	sub.w	r4, r4, #1
  1177f6:	d1e9      	bne.n	1177cc <__adddf3+0x10c>
  1177f8:	f091 0f00 	teq	r1, #0
  1177fc:	bf04      	itt	eq
  1177fe:	4601      	moveq	r1, r0
  117800:	2000      	moveq	r0, #0
  117802:	fab1 f381 	clz	r3, r1
  117806:	bf08      	it	eq
  117808:	3320      	addeq	r3, #32
  11780a:	f1a3 030b 	sub.w	r3, r3, #11
  11780e:	f1b3 0220 	subs.w	r2, r3, #32
  117812:	da0c      	bge.n	11782e <__adddf3+0x16e>
  117814:	320c      	adds	r2, #12
  117816:	dd08      	ble.n	11782a <__adddf3+0x16a>
  117818:	f102 0c14 	add.w	r12, r2, #20
  11781c:	f1c2 020c 	rsb	r2, r2, #12
  117820:	fa01 f00c 	lsl.w	r0, r1, r12
  117824:	fa21 f102 	lsr.w	r1, r1, r2
  117828:	e00c      	b.n	117844 <__adddf3+0x184>
  11782a:	f102 0214 	add.w	r2, r2, #20
  11782e:	bfd8      	it	le
  117830:	f1c2 0c20 	rsble	r12, r2, #32
  117834:	fa01 f102 	lsl.w	r1, r1, r2
  117838:	fa20 fc0c 	lsr.w	r12, r0, r12
  11783c:	bfdc      	itt	le
  11783e:	ea41 010c 	orrle.w	r1, r1, r12
  117842:	4090      	lslle	r0, r2
  117844:	1ae4      	subs	r4, r4, r3
  117846:	bfa2      	ittt	ge
  117848:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  11784c:	4329      	orrge	r1, r5
  11784e:	bd30      	popge	{r4, r5, r15}
  117850:	ea6f 0404 	mvn.w	r4, r4
  117854:	3c1f      	subs	r4, #31
  117856:	da1c      	bge.n	117892 <__adddf3+0x1d2>
  117858:	340c      	adds	r4, #12
  11785a:	dc0e      	bgt.n	11787a <__adddf3+0x1ba>
  11785c:	f104 0414 	add.w	r4, r4, #20
  117860:	f1c4 0220 	rsb	r2, r4, #32
  117864:	fa20 f004 	lsr.w	r0, r0, r4
  117868:	fa01 f302 	lsl.w	r3, r1, r2
  11786c:	ea40 0003 	orr.w	r0, r0, r3
  117870:	fa21 f304 	lsr.w	r3, r1, r4
  117874:	ea45 0103 	orr.w	r1, r5, r3
  117878:	bd30      	pop	{r4, r5, r15}
  11787a:	f1c4 040c 	rsb	r4, r4, #12
  11787e:	f1c4 0220 	rsb	r2, r4, #32
  117882:	fa20 f002 	lsr.w	r0, r0, r2
  117886:	fa01 f304 	lsl.w	r3, r1, r4
  11788a:	ea40 0003 	orr.w	r0, r0, r3
  11788e:	4629      	mov	r1, r5
  117890:	bd30      	pop	{r4, r5, r15}
  117892:	fa21 f004 	lsr.w	r0, r1, r4
  117896:	4629      	mov	r1, r5
  117898:	bd30      	pop	{r4, r5, r15}
  11789a:	f094 0f00 	teq	r4, #0
  11789e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  1178a2:	bf06      	itte	eq
  1178a4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  1178a8:	3401      	addeq	r4, #1
  1178aa:	3d01      	subne	r5, #1
  1178ac:	e74e      	b.n	11774c <__adddf3+0x8c>
  1178ae:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  1178b2:	bf18      	it	ne
  1178b4:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  1178b8:	d029      	beq.n	11790e <__adddf3+0x24e>
  1178ba:	ea94 0f05 	teq	r4, r5
  1178be:	bf08      	it	eq
  1178c0:	ea90 0f02 	teqeq	r0, r2
  1178c4:	d005      	beq.n	1178d2 <__adddf3+0x212>
  1178c6:	ea54 0c00 	orrs.w	r12, r4, r0
  1178ca:	bf04      	itt	eq
  1178cc:	4619      	moveq	r1, r3
  1178ce:	4610      	moveq	r0, r2
  1178d0:	bd30      	pop	{r4, r5, r15}
  1178d2:	ea91 0f03 	teq	r1, r3
  1178d6:	bf1e      	ittt	ne
  1178d8:	2100      	movne	r1, #0
  1178da:	2000      	movne	r0, #0
  1178dc:	bd30      	popne	{r4, r5, r15}
  1178de:	ea5f 5c54 	movs.w	r12, r4, lsr #21
  1178e2:	d105      	bne.n	1178f0 <__adddf3+0x230>
  1178e4:	0040      	lsls	r0, r0, #1
  1178e6:	4149      	adcs	r1, r1
  1178e8:	bf28      	it	cs
  1178ea:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  1178ee:	bd30      	pop	{r4, r5, r15}
  1178f0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  1178f4:	bf3c      	itt	cc
  1178f6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  1178fa:	bd30      	popcc	{r4, r5, r15}
  1178fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  117900:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  117904:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  117908:	f04f 0000 	mov.w	r0, #0
  11790c:	bd30      	pop	{r4, r5, r15}
  11790e:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  117912:	bf1a      	itte	ne
  117914:	4619      	movne	r1, r3
  117916:	4610      	movne	r0, r2
  117918:	ea7f 5c65 	mvnseq.w	r12, r5, asr #21
  11791c:	bf1c      	itt	ne
  11791e:	460b      	movne	r3, r1
  117920:	4602      	movne	r2, r0
  117922:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  117926:	bf06      	itte	eq
  117928:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  11792c:	ea91 0f03 	teqeq	r1, r3
  117930:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  117934:	bd30      	pop	{r4, r5, r15}
  117936:	bf00      	nop

00117938 <__aeabi_ui2d>:
  117938:	f090 0f00 	teq	r0, #0
  11793c:	bf04      	itt	eq
  11793e:	2100      	moveq	r1, #0
  117940:	4770      	bxeq	r14
  117942:	b530      	push	{r4, r5, r14}
  117944:	f44f 6480 	mov.w	r4, #1024	; 0x400
  117948:	f104 0432 	add.w	r4, r4, #50	; 0x32
  11794c:	f04f 0500 	mov.w	r5, #0
  117950:	f04f 0100 	mov.w	r1, #0
  117954:	e750      	b.n	1177f8 <__adddf3+0x138>
  117956:	bf00      	nop

00117958 <__aeabi_i2d>:
  117958:	f090 0f00 	teq	r0, #0
  11795c:	bf04      	itt	eq
  11795e:	2100      	moveq	r1, #0
  117960:	4770      	bxeq	r14
  117962:	b530      	push	{r4, r5, r14}
  117964:	f44f 6480 	mov.w	r4, #1024	; 0x400
  117968:	f104 0432 	add.w	r4, r4, #50	; 0x32
  11796c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  117970:	bf48      	it	mi
  117972:	4240      	negmi	r0, r0
  117974:	f04f 0100 	mov.w	r1, #0
  117978:	e73e      	b.n	1177f8 <__adddf3+0x138>
  11797a:	bf00      	nop

0011797c <__aeabi_f2d>:
  11797c:	0042      	lsls	r2, r0, #1
  11797e:	ea4f 01e2 	mov.w	r1, r2, asr #3
  117982:	ea4f 0131 	mov.w	r1, r1, rrx
  117986:	ea4f 7002 	mov.w	r0, r2, lsl #28
  11798a:	bf1f      	itttt	ne
  11798c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  117990:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  117994:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  117998:	4770      	bxne	r14
  11799a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
  11799e:	bf08      	it	eq
  1179a0:	4770      	bxeq	r14
  1179a2:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
  1179a6:	bf04      	itt	eq
  1179a8:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
  1179ac:	4770      	bxeq	r14
  1179ae:	b530      	push	{r4, r5, r14}
  1179b0:	f44f 7460 	mov.w	r4, #896	; 0x380
  1179b4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  1179b8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  1179bc:	e71c      	b.n	1177f8 <__adddf3+0x138>
  1179be:	bf00      	nop

001179c0 <__aeabi_ul2d>:
  1179c0:	ea50 0201 	orrs.w	r2, r0, r1
  1179c4:	bf08      	it	eq
  1179c6:	4770      	bxeq	r14
  1179c8:	b530      	push	{r4, r5, r14}
  1179ca:	f04f 0500 	mov.w	r5, #0
  1179ce:	e00a      	b.n	1179e6 <__aeabi_l2d+0x16>

001179d0 <__aeabi_l2d>:
  1179d0:	ea50 0201 	orrs.w	r2, r0, r1
  1179d4:	bf08      	it	eq
  1179d6:	4770      	bxeq	r14
  1179d8:	b530      	push	{r4, r5, r14}
  1179da:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  1179de:	d502      	bpl.n	1179e6 <__aeabi_l2d+0x16>
  1179e0:	4240      	negs	r0, r0
  1179e2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  1179e6:	f44f 6480 	mov.w	r4, #1024	; 0x400
  1179ea:	f104 0432 	add.w	r4, r4, #50	; 0x32
  1179ee:	ea5f 5c91 	movs.w	r12, r1, lsr #22
  1179f2:	f43f aed8 	beq.w	1177a6 <__adddf3+0xe6>
  1179f6:	f04f 0203 	mov.w	r2, #3
  1179fa:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  1179fe:	bf18      	it	ne
  117a00:	3203      	addne	r2, #3
  117a02:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  117a06:	bf18      	it	ne
  117a08:	3203      	addne	r2, #3
  117a0a:	eb02 02dc 	add.w	r2, r2, r12, lsr #3
  117a0e:	f1c2 0320 	rsb	r3, r2, #32
  117a12:	fa00 fc03 	lsl.w	r12, r0, r3
  117a16:	fa20 f002 	lsr.w	r0, r0, r2
  117a1a:	fa01 fe03 	lsl.w	r14, r1, r3
  117a1e:	ea40 000e 	orr.w	r0, r0, r14
  117a22:	fa21 f102 	lsr.w	r1, r1, r2
  117a26:	4414      	add	r4, r2
  117a28:	e6bd      	b.n	1177a6 <__adddf3+0xe6>
  117a2a:	bf00      	nop

00117a2c <__aeabi_uldivmod>:
  117a2c:	b953      	cbnz	r3, 117a44 <__aeabi_uldivmod+0x18>
  117a2e:	b94a      	cbnz	r2, 117a44 <__aeabi_uldivmod+0x18>
  117a30:	2900      	cmp	r1, #0
  117a32:	bf08      	it	eq
  117a34:	2800      	cmpeq	r0, #0
  117a36:	bf1c      	itt	ne
  117a38:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
  117a3c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  117a40:	f000 b8ae 	b.w	117ba0 <__aeabi_idiv0>
  117a44:	f1ad 0c08 	sub.w	r12, r13, #8
  117a48:	e96d ce04 	strd	r12, r14, [r13, #-16]!
  117a4c:	f000 f806 	bl	117a5c <__udivmoddi4>
  117a50:	f8dd e004 	ldr.w	r14, [r13, #4]
  117a54:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
  117a58:	b004      	add	sp, #16
  117a5a:	4770      	bx	r14

00117a5c <__udivmoddi4>:
  117a5c:	4299      	cmp	r1, r3
  117a5e:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  117a62:	bf08      	it	eq
  117a64:	4290      	cmpeq	r0, r2
  117a66:	b083      	sub	sp, #12
  117a68:	4682      	mov	r10, r0
  117a6a:	468b      	mov	r11, r1
  117a6c:	f8dd 8030 	ldr.w	r8, [r13, #48]	; 0x30
  117a70:	d37c      	bcc.n	117b6c <__udivmoddi4+0x110>
  117a72:	4610      	mov	r0, r2
  117a74:	4619      	mov	r1, r3
  117a76:	fab3 f283 	clz	r2, r3
  117a7a:	2b00      	cmp	r3, #0
  117a7c:	f000 8084 	beq.w	117b88 <__udivmoddi4+0x12c>
  117a80:	fabb f38b 	clz	r3, r11
  117a84:	f1bb 0f00 	cmp.w	r11, #0
  117a88:	d07a      	beq.n	117b80 <__udivmoddi4+0x124>
  117a8a:	1ad3      	subs	r3, r2, r3
  117a8c:	f1a3 0e20 	sub.w	r14, r3, #32
  117a90:	fa01 f703 	lsl.w	r7, r1, r3
  117a94:	fa00 f20e 	lsl.w	r2, r0, r14
  117a98:	f1c3 0c20 	rsb	r12, r3, #32
  117a9c:	4317      	orrs	r7, r2
  117a9e:	fa20 f20c 	lsr.w	r2, r0, r12
  117aa2:	4317      	orrs	r7, r2
  117aa4:	fa00 f603 	lsl.w	r6, r0, r3
  117aa8:	45bb      	cmp	r11, r7
  117aaa:	bf08      	it	eq
  117aac:	45b2      	cmpeq	r10, r6
  117aae:	d362      	bcc.n	117b76 <__udivmoddi4+0x11a>
  117ab0:	ebba 0a06 	subs.w	r10, r10, r6
  117ab4:	f04f 0201 	mov.w	r2, #1
  117ab8:	eb6b 0b07 	sbc.w	r11, r11, r7
  117abc:	fa02 f10e 	lsl.w	r1, r2, r14
  117ac0:	fa22 f90c 	lsr.w	r9, r2, r12
  117ac4:	409a      	lsls	r2, r3
  117ac6:	ea41 0109 	orr.w	r1, r1, r9
  117aca:	9200      	str	r2, [sp, #0]
  117acc:	9101      	str	r1, [sp, #4]
  117ace:	2b00      	cmp	r3, #0
  117ad0:	d042      	beq.n	117b58 <__udivmoddi4+0xfc>
  117ad2:	087f      	lsrs	r7, r7, #1
  117ad4:	ea4f 0636 	mov.w	r6, r6, rrx
  117ad8:	461a      	mov	r2, r3
  117ada:	e00c      	b.n	117af6 <__udivmoddi4+0x9a>
  117adc:	ebba 0006 	subs.w	r0, r10, r6
  117ae0:	eb6b 0107 	sbc.w	r1, r11, r7
  117ae4:	1804      	adds	r4, r0, r0
  117ae6:	eb41 0501 	adc.w	r5, r1, r1
  117aea:	f114 0a01 	adds.w	r10, r4, #1
  117aee:	f145 0b00 	adc.w	r11, r5, #0
  117af2:	3a01      	subs	r2, #1
  117af4:	d009      	beq.n	117b0a <__udivmoddi4+0xae>
  117af6:	45bb      	cmp	r11, r7
  117af8:	bf08      	it	eq
  117afa:	45b2      	cmpeq	r10, r6
  117afc:	d2ee      	bcs.n	117adc <__udivmoddi4+0x80>
  117afe:	eb1a 0a0a 	adds.w	r10, r10, r10
  117b02:	eb4b 0b0b 	adc.w	r11, r11, r11
  117b06:	3a01      	subs	r2, #1
  117b08:	d1f5      	bne.n	117af6 <__udivmoddi4+0x9a>
  117b0a:	fa0b fc0c 	lsl.w	r12, r11, r12
  117b0e:	e9dd 0100 	ldrd	r0, r1, [r13]
  117b12:	fa2a f203 	lsr.w	r2, r10, r3
  117b16:	fa2b fe0e 	lsr.w	r14, r11, r14
  117b1a:	ea42 020c 	orr.w	r2, r2, r12
  117b1e:	eb10 000a 	adds.w	r0, r0, r10
  117b22:	fa2b f903 	lsr.w	r9, r11, r3
  117b26:	ea42 0a0e 	orr.w	r10, r2, r14
  117b2a:	f1a3 0c20 	sub.w	r12, r3, #32
  117b2e:	f1c3 0220 	rsb	r2, r3, #32
  117b32:	fa09 f703 	lsl.w	r7, r9, r3
  117b36:	fa0a fc0c 	lsl.w	r12, r10, r12
  117b3a:	ea47 070c 	orr.w	r7, r7, r12
  117b3e:	fa2a f202 	lsr.w	r2, r10, r2
  117b42:	fa0a f603 	lsl.w	r6, r10, r3
  117b46:	eb41 010b 	adc.w	r1, r1, r11
  117b4a:	4317      	orrs	r7, r2
  117b4c:	1b80      	subs	r0, r0, r6
  117b4e:	46cb      	mov	r11, r9
  117b50:	eb61 0107 	sbc.w	r1, r1, r7
  117b54:	e9cd 0100 	strd	r0, r1, [r13]
  117b58:	f1b8 0f00 	cmp.w	r8, #0
  117b5c:	d001      	beq.n	117b62 <__udivmoddi4+0x106>
  117b5e:	e9c8 ab00 	strd	r10, r11, [r8]
  117b62:	e9dd 0100 	ldrd	r0, r1, [r13]
  117b66:	b003      	add	sp, #12
  117b68:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  117b6c:	2300      	movs	r3, #0
  117b6e:	2400      	movs	r4, #0
  117b70:	e9cd 3400 	strd	r3, r4, [r13]
  117b74:	e7f0      	b.n	117b58 <__udivmoddi4+0xfc>
  117b76:	2100      	movs	r1, #0
  117b78:	2200      	movs	r2, #0
  117b7a:	e9cd 1200 	strd	r1, r2, [r13]
  117b7e:	e7a6      	b.n	117ace <__udivmoddi4+0x72>
  117b80:	faba f38a 	clz	r3, r10
  117b84:	3320      	adds	r3, #32
  117b86:	e780      	b.n	117a8a <__udivmoddi4+0x2e>
  117b88:	fab0 f380 	clz	r3, r0
  117b8c:	f103 0220 	add.w	r2, r3, #32
  117b90:	fabb f38b 	clz	r3, r11
  117b94:	f1bb 0f00 	cmp.w	r11, #0
  117b98:	f47f af77 	bne.w	117a8a <__udivmoddi4+0x2e>
  117b9c:	e7f0      	b.n	117b80 <__udivmoddi4+0x124>
  117b9e:	bf00      	nop

00117ba0 <__aeabi_idiv0>:
  117ba0:	4770      	bx	r14
  117ba2:	bf00      	nop
  117ba4:	0000      	movs	r0, r0
	...

00117ba8 <__memcpy_from_thumb>:
  117ba8:	4778      	bx	r15
  117baa:	46c0      	nop			; (mov r8, r8)
  117bac:	eaffef3b 	b	1138a0 <memcpy>
