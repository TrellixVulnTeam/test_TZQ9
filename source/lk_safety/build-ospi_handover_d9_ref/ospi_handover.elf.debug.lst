
build-ospi_handover_d9_ref/ospi_handover.elf:     file format elf32-littlearm


Disassembly of section .text:

00100000 <_start>:
.globl _start

.section ".text.boot"

_start:
    b         platform_reset
  100000:	ea00000e 	b	100040 <arm_reset>
    ldr pc,   arm_undefined_const
  100004:	e59ff018 	ldr	r15, [pc, #24]	; 100024 <arm_undefined_const>
    ldr pc,	  FreeRTOS_SWI_Handler_const	/* arm_syscall */
  100008:	e59ff018 	ldr	r15, [pc, #24]	; 100028 <FreeRTOS_SWI_Handler_const>
    ldr pc,   arm_prefetch_abort_const
  10000c:	e59ff018 	ldr	r15, [pc, #24]	; 10002c <arm_prefetch_abort_const>
    ldr pc,   arm_data_abort_const
  100010:	e59ff018 	ldr	r15, [pc, #24]	; 100030 <arm_data_abort_const>
    ldr pc,   arm_reserved_const
  100014:	e59ff018 	ldr	r15, [pc, #24]	; 100034 <arm_reserved_const>
    ldr pc,	  FreeRTOS_IRQ_Handler_const	/* arm_irq */
  100018:	e59ff018 	ldr	r15, [pc, #24]	; 100038 <FreeRTOS_IRQ_Handler_const>
    ldr pc,   arm_fiq_const
  10001c:	e59ff018 	ldr	r15, [pc, #24]	; 10003c <arm_fiq_const>

00100020 <platform_reset_const>:
  100020:	00100040 	.word	0x00100040

00100024 <arm_undefined_const>:
  100024:	00100c40 	.word	0x00100c40

00100028 <FreeRTOS_SWI_Handler_const>:
  100028:	00107a50 	.word	0x00107a50

0010002c <arm_prefetch_abort_const>:
  10002c:	00100cf0 	.word	0x00100cf0

00100030 <arm_data_abort_const>:
  100030:	00100d4c 	.word	0x00100d4c

00100034 <arm_reserved_const>:
  100034:	00100da8 	.word	0x00100da8

00100038 <FreeRTOS_IRQ_Handler_const>:
  100038:	00107b50 	.word	0x00107b50

0010003c <arm_fiq_const>:
  10003c:	00100e2c 	.word	0x00100e2c

00100040 <arm_reset>:
    /* Fall through for the weak symbol */

.globl arm_reset
arm_reset:
#ifdef LOCKSTEP_SCR_ADDR
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  100040:	e59f0118 	ldr	r0, [pc, #280]	; 100160 <arm_reset+0x120>
    ldr     r1, [r0, #0]
  100044:	e5901000 	ldr	r1, [r0]
    bic     r1, #(0x3<<LOCKSTEP_SCR_BIT)
  100048:	e3c11003 	bic	r1, r1, #3
    str     r1, [r0, #0]
  10004c:	e5801000 	str	r1, [r0]
#endif

    /* do some early cpu setup */
    mrc     p15, 0, r12, c1, c0, 0
  100050:	ee11cf10 	mrc	15, 0, r12, cr1, cr0, {0}
    /* i/d cache disable, mmu disabled */
    bic     r12, #(1<<12)
  100054:	e3ccca01 	bic	r12, r12, #4096	; 0x1000
    bic     r12, #(1<<2 | 1<<0)
  100058:	e3ccc005 	bic	r12, r12, #5
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    orr     r12, r12, #(1<<12)
    orr     r12, r12, #(1<<2)
#endif // WITH_KERNEL_VM
    mcr     p15, 0, r12, c1, c0, 0
  10005c:	ee01cf10 	mcr	15, 0, r12, cr1, cr0, {0}

    /* calculate the physical offset from our eventual virtual location */
.Lphys_offset:
    ldr     r4, =.Lphys_offset
  100060:	e59f40fc 	ldr	r4, [pc, #252]	; 100164 <arm_reset+0x124>
    adr     r11, .Lphys_offset
  100064:	e24fb00c 	sub	r11, r15, #12
    sub     r11, r11, r4
  100068:	e04bb004 	sub	r11, r11, r4

#if WITH_NO_PHYS_RELOCATION
    /* assume that image is properly loaded in physical memory */
#else
    /* see if we need to relocate to our proper location in physical memory */
    adr     r4, _start                           /* this emits sub r4, pc, #constant */
  10006c:	e24f4074 	sub	r4, r15, #116	; 0x74
    ldr     r5, =(MEMBASE + KERNEL_LOAD_OFFSET)  /* calculate the binary's physical load address */
  100070:	e3a05601 	mov	r5, #1048576	; 0x100000
    subs    r12, r4, r5                          /* calculate the delta between where we're loaded and the proper spot */
  100074:	e054c005 	subs	r12, r4, r5
    beq     .Lrelocate_done
  100078:	0a00000a 	beq	1000a8 <arm_reset+0x68>

    /* we need to relocate ourselves to the proper spot */
    ldr     r6, =__data_end
  10007c:	e59f60e4 	ldr	r6, [pc, #228]	; 100168 <arm_reset+0x128>
    ldr     r7, =(KERNEL_BASE - MEMBASE)
  100080:	e3a07000 	mov	r7, #0
    sub     r6, r7
  100084:	e0466007 	sub	r6, r6, r7
    add     r6, r12
  100088:	e086600c 	add	r6, r6, r12

.Lrelocate_loop:
    ldr     r7, [r4], #4
  10008c:	e4947004 	ldr	r7, [r4], #4
    str     r7, [r5], #4
  100090:	e4857004 	str	r7, [r5], #4
    cmp     r4, r6
  100094:	e1540006 	cmp	r4, r6
    bne     .Lrelocate_loop
  100098:	1afffffb 	bne	10008c <arm_reset+0x4c>

    /* we're relocated, jump to the right address */
    sub     pc, r12
  10009c:	e04ff00c 	sub	r15, r15, r12
    nop     /* skipped in the add to pc */
  1000a0:	e320f000 	nop	{0}

    /* recalculate the physical offset */
    sub     r11, r11, r12
  1000a4:	e04bb00c 	sub	r11, r11, r12
#endif // WITH_KERNEL_VM

    /* at this point we're running at our final location in virtual memory (if enabled) */
.Lstack_setup:
    /* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */
	mov 	r12, #0
  1000a8:	e3a0c000 	mov	r12, #0

    /* Setup normal interrupt stack */
    cpsid 	i, 	#MODE_IRQ
  1000ac:	f10e0092 	cpsid	i,#18
    ldr 	r12, =irq_stack
  1000b0:	e59fc0b4 	ldr	r12, [pc, #180]	; 10016c <arm_reset+0x12c>
    add 	r12, #ARCH_IRQ_STACK_SIZE
  1000b4:	e28ccc02 	add	r12, r12, #512	; 0x200
    mov 	sp, r12
  1000b8:	e1a0d00c 	mov	r13, r12

    /* Setup fast interrupt stack */
    cpsid 	i, 	#MODE_FIQ
  1000bc:	f10e0091 	cpsid	i,#17
    ldr 	r12, =fiq_stack
  1000c0:	e59fc0a8 	ldr	r12, [pc, #168]	; 100170 <arm_reset+0x130>
    add 	r12, #ARCH_FIQ_STACK_SIZE
  1000c4:	e28ccc01 	add	r12, r12, #256	; 0x100
    mov 	sp, r12
  1000c8:	e1a0d00c 	mov	r13, r12

    /* Setup data abort stack */
    cpsid 	i, 	#MODE_ABT
  1000cc:	f10e0097 	cpsid	i,#23
    ldr 	r12, =abt_stack
  1000d0:	e59fc09c 	ldr	r12, [pc, #156]	; 100174 <arm_reset+0x134>
    add 	r12, #ARCH_ABT_STACK_SIZE
  1000d4:	e28cc080 	add	r12, r12, #128	; 0x80
    mov 	sp, r12
  1000d8:	e1a0d00c 	mov	r13, r12

	/* Setup undefined instruction stack */
    cpsid 	i, 	#MODE_UND
  1000dc:	f10e009b 	cpsid	i,#27
    ldr 	r12, =und_stack
  1000e0:	e59fc090 	ldr	r12, [pc, #144]	; 100178 <arm_reset+0x138>
    add 	r12, #ARCH_UND_STACK_SIZE
  1000e4:	e28cc080 	add	r12, r12, #128	; 0x80
    mov 	sp, r12
  1000e8:	e1a0d00c 	mov	r13, r12

    /* Setup system/user stack */
    cpsid 	i, 	#MODE_SYS
  1000ec:	f10e009f 	cpsid	i,#31
    ldr 	r12, =sys_stack
  1000f0:	e59fc084 	ldr	r12, [pc, #132]	; 10017c <arm_reset+0x13c>
    add 	r12, #ARCH_SYS_STACK_SIZE
  1000f4:	e28ccb02 	add	r12, r12, #2048	; 0x800
    mov 	sp, r12
  1000f8:	e1a0d00c 	mov	r13, r12

    /* Setup supervisor stack */
    cpsid 	i, 	#MODE_SVC
  1000fc:	f10e0093 	cpsid	i,#19
    ldr 	r12, =svc_stack
  100100:	e59fc078 	ldr	r12, [pc, #120]	; 100180 <arm_reset+0x140>
    add 	r12, #ARCH_SVC_STACK_SIZE
  100104:	e28ccb02 	add	r12, r12, #2048	; 0x800
    mov 	sp, r12
  100108:	e1a0d00c 	mov	r13, r12

    /* stay in supervisor mode from now on out */
    mov r0,#3
  10010c:	e3a00003 	mov	r0, #3
    bl arch_enable_cache
  100110:	eb000209 	bl	10093c <arch_enable_cache>

    /* copy the initialized data segment out of rom if necessary */
    ldr     r4, =__data_start_rom
  100114:	e59f4068 	ldr	r4, [pc, #104]	; 100184 <arm_reset+0x144>
    ldr     r5, =__data_start
  100118:	e59f5068 	ldr	r5, [pc, #104]	; 100188 <arm_reset+0x148>
    ldr     r6, =__data_end
  10011c:	e59f6044 	ldr	r6, [pc, #68]	; 100168 <arm_reset+0x128>

    cmp     r4, r5
  100120:	e1540005 	cmp	r4, r5
    beq     .L__do_bss
  100124:	0a000003 	beq	100138 <arm_reset+0xf8>

.L__copy_loop:
    cmp     r5, r6
  100128:	e1550006 	cmp	r5, r6
    ldrlt   r7, [r4], #4
  10012c:	b4947004 	ldrlt	r7, [r4], #4
    strlt   r7, [r5], #4
  100130:	b4857004 	strlt	r7, [r5], #4
    blt     .L__copy_loop
  100134:	bafffffb 	blt	100128 <arm_reset+0xe8>

.L__do_bss:
    /* clear out the bss */
    ldr     r4, =__bss_start
  100138:	e59f404c 	ldr	r4, [pc, #76]	; 10018c <arm_reset+0x14c>
    ldr     r5, =_end
  10013c:	e59f504c 	ldr	r5, [pc, #76]	; 100190 <arm_reset+0x150>
    mov     r6, #0
  100140:	e3a06000 	mov	r6, #0
.L__bss_loop:
    cmp     r4, r5
  100144:	e1540005 	cmp	r4, r5
    strlt   r6, [r4], #4
  100148:	b4846004 	strlt	r6, [r4], #4
    blt     .L__bss_loop
  10014c:	bafffffc 	blt	100144 <arm_reset+0x104>

#endif

.L__STARTUP:
    /* change to system mode */
    cpsid 	i, 	#MODE_SYS
  100150:	f10e009f 	cpsid	i,#31

    ldr     r0, =lk_main
  100154:	e59f0038 	ldr	r0, [pc, #56]	; 100194 <arm_reset+0x154>
    blx     r0
  100158:	e12fff30 	blx	r0
    b       .
  10015c:	eafffffe 	b	10015c <arm_reset+0x11c>
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  100160:	fc297000 	.word	0xfc297000
    ldr     r4, =.Lphys_offset
  100164:	00100060 	.word	0x00100060
    ldr     r6, =__data_end
  100168:	001149d8 	.word	0x001149d8
    ldr 	r12, =irq_stack
  10016c:	00114ba0 	.word	0x00114ba0
    ldr 	r12, =fiq_stack
  100170:	00114aa0 	.word	0x00114aa0
    ldr 	r12, =abt_stack
  100174:	00114a20 	.word	0x00114a20
    ldr 	r12, =und_stack
  100178:	00115da0 	.word	0x00115da0
    ldr 	r12, =sys_stack
  10017c:	001155a0 	.word	0x001155a0
    ldr 	r12, =svc_stack
  100180:	00114da0 	.word	0x00114da0
    ldr     r4, =__data_start_rom
  100184:	00111f98 	.word	0x00111f98
    ldr     r5, =__data_start
  100188:	00111f98 	.word	0x00111f98
    ldr     r4, =__bss_start
  10018c:	001149e0 	.word	0x001149e0
    ldr     r5, =_end
  100190:	0011a08c 	.word	0x0011a08c
    ldr     r0, =lk_main
  100194:	0010197d 	.word	0x0010197d

00100198 <target_early_init>:
void sdm_display_init(void);

void target_early_init(void)
{

}
  100198:	4770      	bx	r14
  10019a:	bf00      	nop

0010019c <target_init>:
  10019c:	4770      	bx	r14
  10019e:	bf00      	nop

001001a0 <uart_port_init>:
};



void uart_port_init(void)
{
  1001a0:	b500      	push	{r14}
    void *port_init_handle = NULL;
  1001a2:	2300      	movs	r3, #0
{
  1001a4:	b083      	sub	sp, #12
    hal_port_creat_handle(&port_init_handle,
  1001a6:	f44f 61a0 	mov.w	r1, #1280	; 0x500
    void *port_init_handle = NULL;
  1001aa:	a802      	add	r0, sp, #8
    hal_port_creat_handle(&port_init_handle,
  1001ac:	f2c8 2194 	movt	r1, #33428	; 0x8294
    void *port_init_handle = NULL;
  1001b0:	f840 3d04 	str.w	r3, [r0, #-4]!
    hal_port_creat_handle(&port_init_handle,
  1001b4:	f006 ff34 	bl	107020 <hal_port_creat_handle>
                          RES_PAD_CONTROL_SAF_JTAG_TMS);//safety iomuxc res

    if (port_init_handle) {
  1001b8:	9801      	ldr	r0, [sp, #4]
  1001ba:	b1b0      	cbz	r0, 1001ea <uart_port_init+0x4a>
        hal_port_set_pin_mode(port_init_handle, UART_TX_PIN, UART_TX_PIN_MODE);
  1001bc:	f64b 6300 	movw	r3, #48640	; 0xbe00
  1001c0:	2120      	movs	r1, #32
  1001c2:	f2c0 0310 	movt	r3, #16
  1001c6:	cb0c      	ldmia	r3, {r2, r3}
  1001c8:	f006 ffee 	bl	1071a8 <hal_port_set_pin_mode>
        hal_port_set_pin_mode(port_init_handle, UART_RX_PIN, UART_RX_PIN_MODE);
  1001cc:	f64b 53f8 	movw	r3, #48632	; 0xbdf8
  1001d0:	2121      	movs	r1, #33	; 0x21
  1001d2:	f2c0 0310 	movt	r3, #16
  1001d6:	9801      	ldr	r0, [sp, #4]
  1001d8:	cb0c      	ldmia	r3, {r2, r3}
  1001da:	f006 ffe5 	bl	1071a8 <hal_port_set_pin_mode>
        hal_port_release_handle(port_init_handle);
  1001de:	9801      	ldr	r0, [sp, #4]
  1001e0:	f006 ff88 	bl	1070f4 <hal_port_release_handle>
    }
    else {
        dprintf(ALWAYS, "port get handle failed!\n");
    }
}
  1001e4:	b003      	add	sp, #12
  1001e6:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(ALWAYS, "port get handle failed!\n");
  1001ea:	f64b 6008 	movw	r0, #48648	; 0xbe08
  1001ee:	f2c0 0010 	movt	r0, #16
  1001f2:	f00b f85b 	bl	10b2ac <puts>
}
  1001f6:	b003      	add	sp, #12
  1001f8:	f85d fb04 	ldr.w	r15, [r13], #4

001001fc <tcm_init>:
#include <asm.h>
/*void tcm_init(uint32_t tcmA_base,uint32_t tcmB_base,uint32_t tcmA_size,uint32_t tcmB_size) */
FUNCTION(tcm_init)
    push {r4,r5,r6,r7}
  1001fc:	e92d00f0 	push	{r4, r5, r6, r7}
    mov r6,r0
  100200:	e1a06000 	mov	r6, r0
    mov r7,r1
  100204:	e1a07001 	mov	r7, r1
    @ mrc p15, 0, r0, c9, c1, 1   // Read ATCM Region Register
    @ // r0 now contains ATCM size in bits[6:2]
    @ mrc p15, 0, r0, c9, c1, 0   // Read BTCM Region Register
    @ // r0 now contains BTCM size in bits[6:2]
    @ // Write to TCMTR.size will be ignored
    orr r0, r0, #1  // Enable ATCM
  100208:	e3800001 	orr	r0, r0, #1
    mcr p15, 0, r0, c9, c1, 1
  10020c:	ee090f31 	mcr	15, 0, r0, cr9, cr1, {1}
    orr r1, r1, #1  // Enable BTCM
  100210:	e3811001 	orr	r1, r1, #1
    mcr p15, 0, r1, c9, c1, 0
  100214:	ee091f11 	mcr	15, 0, r1, cr9, cr1, {0}

    @ r2 = tcmA_base + tcmA_size = tcmA_end
    add r2,r6,r2
  100218:	e0862002 	add	r2, r6, r2
    @ r3 = tcmB_base + tcmB_size = tcmB_end
    add r3,r7,r3
  10021c:	e0873003 	add	r3, r7, r3
    @combine to 64 bit
    mov r4,#0
  100220:	e3a04000 	mov	r4, #0
    mov r5,#0
  100224:	e3a05000 	mov	r5, #0
.Ltcm_clrA:
    cmp r6,r2
  100228:	e1560002 	cmp	r6, r2
    bhs .Ltcm_clrB
  10022c:	2a000001 	bcs	100238 <tcm_init+0x3c>
    stmia r6!, {r4-r5}
  100230:	e8a60030 	stmia	r6!, {r4, r5}
    b .Ltcm_clrA
  100234:	eafffffb 	b	100228 <tcm_init+0x2c>

.Ltcm_clrB:
    cmp r7,r3
  100238:	e1570003 	cmp	r7, r3
    bhs .Ltcm_clr_done
  10023c:	2a000001 	bcs	100248 <tcm_init+0x4c>
    stmia r7!, {r4-r5}
  100240:	e8a70030 	stmia	r7!, {r4, r5}
    b .Ltcm_clrB
  100244:	eafffffb 	b	100238 <tcm_init+0x3c>

.Ltcm_clr_done:

    pop {r4,r5,r6,r7}
  100248:	e8bd00f0 	pop	{r4, r5, r6, r7}
    bx lr
  10024c:	e12fff1e 	bx	r14

00100250 <vector_remap>:
}

static void vector_remap(addr_t vector_base)
{
    /* base address must be 4 KB aligned */
    ASSERT((vector_base & 0xFFF) == 0);
  100250:	f3c0 030b 	ubfx	r3, r0, #0, #12
{
  100254:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  100258:	46f0      	mov	r8, r14
  10025a:	b082      	sub	sp, #8
    ASSERT((vector_base & 0xFFF) == 0);
  10025c:	bbb3      	cbnz	r3, 1002cc <vector_remap+0x7c>
    dprintf(INFO, "Remapping ARM vector to 0x%lx!\n", vector_base);
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  10025e:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  100262:	f644 5250 	movw	r2, #19792	; 0x4d50
  100266:	f6cf 4341 	movt	r3, #64577	; 0xfc41
  10026a:	4604      	mov	r4, r0
  10026c:	f2c5 2245 	movt	r2, #21061	; 0x5245
    /* Enable R5 remapping to vector base. The remap config doesn't
     * take effect until REMAP module detects R5 core reset.
     */
    scr_handle_t handle;
    handle = hal_scr_create_handle(
  100270:	2014      	movs	r0, #20
  100272:	2103      	movs	r1, #3
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  100274:	601a      	str	r2, [r3, #0]
    handle = hal_scr_create_handle(
  100276:	f2c0 4000 	movt	r0, #1024	; 0x400
  10027a:	f007 f96d 	bl	107558 <hal_scr_create_handle>
  10027e:	4606      	mov	r6, r0
  100280:	460f      	mov	r7, r1
                 SCR_SAFETY__L31__remap_cr5_saf_ar_addr_offset_19_0);
    ASSERT(handle);
  100282:	ea56 0307 	orrs.w	r3, r6, r7
  100286:	d032      	beq.n	1002ee <vector_remap+0x9e>
    hal_scr_set(handle, vector_base >> 12);
  100288:	0b22      	lsrs	r2, r4, #12
  10028a:	f007 f997 	bl	1075bc <hal_scr_set>
    hal_scr_delete_handle(handle);
  10028e:	4630      	mov	r0, r6
  100290:	4639      	mov	r1, r7
  100292:	f007 f963 	bl	10755c <hal_scr_delete_handle>
    handle = hal_scr_create_handle(
  100296:	a128      	add	r1, pc, #160	; (adr r1, 100338 <vector_remap+0xe8>)
  100298:	e9d1 0100 	ldrd	r0, r1, [r1]
  10029c:	f007 f95c 	bl	107558 <hal_scr_create_handle>
  1002a0:	4604      	mov	r4, r0
  1002a2:	460d      	mov	r5, r1
                 SCR_SAFETY__L31__remap_cr5_saf_ar_remap_ovrd_en);
    ASSERT(handle);
  1002a4:	ea54 0305 	orrs.w	r3, r4, r5
  1002a8:	d032      	beq.n	100310 <vector_remap+0xc0>
    hal_scr_set(handle, 1);
  1002aa:	2201      	movs	r2, #1
  1002ac:	f007 f986 	bl	1075bc <hal_scr_set>
    hal_scr_delete_handle(handle);
  1002b0:	4620      	mov	r0, r4
  1002b2:	4629      	mov	r1, r5
  1002b4:	f007 f952 	bl	10755c <hal_scr_delete_handle>
    /* ROMC Stick Reg
     *
     * [0]: ROMC_STICKY_REMAP_EN. This bit is AND'ed with
     *      SCR remap_en bit, to enable remapping.
     */
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
  1002b8:	2334      	movs	r3, #52	; 0x34
  1002ba:	f2cf 0320 	movt	r3, #61472	; 0xf020
  1002be:	681a      	ldr	r2, [r3, #0]
  1002c0:	f042 0201 	orr.w	r2, r2, #1
  1002c4:	601a      	str	r2, [r3, #0]
}
  1002c6:	b002      	add	sp, #8
  1002c8:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    ASSERT((vector_base & 0xFFF) == 0);
  1002cc:	f64b 637c 	movw	r3, #48764	; 0xbe7c
  1002d0:	f64b 6238 	movw	r2, #48696	; 0xbe38
  1002d4:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1002d8:	f2c0 0310 	movt	r3, #16
  1002dc:	4670      	mov	r0, r14
  1002de:	f2c0 0210 	movt	r2, #16
  1002e2:	9300      	str	r3, [sp, #0]
  1002e4:	f2c0 0110 	movt	r1, #16
  1002e8:	2371      	movs	r3, #113	; 0x71
  1002ea:	f009 ffc3 	bl	10a274 <_panic>
    ASSERT(handle);
  1002ee:	f64b 6398 	movw	r3, #48792	; 0xbe98
  1002f2:	f64b 6238 	movw	r2, #48696	; 0xbe38
  1002f6:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1002fa:	f2c0 0310 	movt	r3, #16
  1002fe:	4640      	mov	r0, r8
  100300:	f2c0 0210 	movt	r2, #16
  100304:	9300      	str	r3, [sp, #0]
  100306:	f2c0 0110 	movt	r1, #16
  10030a:	237a      	movs	r3, #122	; 0x7a
  10030c:	f009 ffb2 	bl	10a274 <_panic>
    ASSERT(handle);
  100310:	f64b 6398 	movw	r3, #48792	; 0xbe98
  100314:	f64b 6238 	movw	r2, #48696	; 0xbe38
  100318:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10031c:	f2c0 0310 	movt	r3, #16
  100320:	4640      	mov	r0, r8
  100322:	f2c0 0210 	movt	r2, #16
  100326:	9300      	str	r3, [sp, #0]
  100328:	f2c0 0110 	movt	r1, #16
  10032c:	237f      	movs	r3, #127	; 0x7f
  10032e:	f009 ffa1 	bl	10a274 <_panic>
  100332:	bf00      	nop
  100334:	f3af 8000 	nop.w
  100338:	04001401 	.word	0x04001401
  10033c:	00000003 	.word	0x00000003

00100340 <platform_core_reset>:
{
  100340:	b510      	push	{r4, r14}
    addr_t phy_addr = 0;
  100342:	2300      	movs	r3, #0
{
  100344:	b084      	sub	sp, #16
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  100346:	f240 4002 	movw	r0, #1026	; 0x402
    int32_t idx = 0;
  10034a:	aa04      	add	r2, sp, #16
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10034c:	a902      	add	r1, sp, #8
    int32_t idx = 0;
  10034e:	f842 3d04 	str.w	r3, [r2, #-4]!
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  100352:	f2c8 2096 	movt	r0, #33430	; 0x8296
    addr_t phy_addr = 0;
  100356:	9302      	str	r3, [sp, #8]
  100358:	4674      	mov	r4, r14
    ret = res_get_info_by_id(RES_CORE_RST_SAF_CR5_SAF_SW, &phy_addr, &idx);
  10035a:	f007 f81f 	bl	10739c <res_get_info_by_id>
    ASSERT(!ret);
  10035e:	b960      	cbnz	r0, 10037a <platform_core_reset+0x3a>
    rstgen_core_reset(phy_addr, idx);
  100360:	9802      	ldr	r0, [sp, #8]
    writel(readl(LOCKSTEP_SCR_ADDR) | (0x3 << LOCKSTEP_SCR_BIT),
  100362:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
  100366:	f6cf 4329 	movt	r3, #64553	; 0xfc29
  10036a:	681a      	ldr	r2, [r3, #0]
  10036c:	f042 0203 	orr.w	r2, r2, #3
  100370:	601a      	str	r2, [r3, #0]
    rstgen_core_reset(phy_addr, idx);
  100372:	9903      	ldr	r1, [sp, #12]
  100374:	f005 f96c 	bl	105650 <rstgen_core_reset>
  100378:	e7fe      	b.n	100378 <platform_core_reset+0x38>
    ASSERT(!ret);
  10037a:	f64b 6320 	movw	r3, #48672	; 0xbe20
  10037e:	f64b 6238 	movw	r2, #48696	; 0xbe38
  100382:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  100386:	f2c0 0310 	movt	r3, #16
  10038a:	4620      	mov	r0, r4
  10038c:	f2c0 0210 	movt	r2, #16
  100390:	9300      	str	r3, [sp, #0]
  100392:	f2c0 0110 	movt	r1, #16
  100396:	2359      	movs	r3, #89	; 0x59
  100398:	f009 ff6c 	bl	10a274 <_panic>

0010039c <platform_early_init>:

static void platform_remap(void)
{
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  10039c:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
  1003a0:	f644 5350 	movw	r3, #19792	; 0x4d50
  1003a4:	f6cf 4041 	movt	r0, #64577	; 0xfc41
  1003a8:	f2c5 2345 	movt	r3, #21061	; 0x5245
        mpu_enable(true);
    }
}

void platform_early_init(void)
{
  1003ac:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  1003b0:	6802      	ldr	r2, [r0, #0]
{
  1003b2:	b084      	sub	sp, #16
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  1003b4:	429a      	cmp	r2, r3
  1003b6:	f040 8097 	bne.w	1004e8 <platform_early_init+0x14c>
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1003ba:	2400      	movs	r4, #0
    platform_remap();
    tcm_init(TCMA_BASE, TCMB_BASE, TCMA_SIZE, TCMB_SIZE);
  1003bc:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  1003c0:	461a      	mov	r2, r3
  1003c2:	f44f 0196 	mov.w	r1, #4915200	; 0x4b0000
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1003c6:	6004      	str	r4, [r0, #0]
    tcm_init(TCMA_BASE, TCMB_BASE, TCMA_SIZE, TCMB_SIZE);
  1003c8:	f44f 0098 	mov.w	r0, #4980736	; 0x4c0000
  1003cc:	4677      	mov	r7, r14
  1003ce:	f7ff ef16 	blx	1001fc <tcm_init>
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003d2:	f44f 6088 	mov.w	r0, #1088	; 0x440
    int32_t idx = 0;
  1003d6:	aa04      	add	r2, sp, #16
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003d8:	a902      	add	r1, sp, #8
    int32_t idx = 0;
  1003da:	f842 4d04 	str.w	r4, [r2, #-4]!
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003de:	f2c8 2096 	movt	r0, #33430	; 0x8296
    addr_t phy_addr = 0;
  1003e2:	9402      	str	r4, [sp, #8]
    ret = res_get_info_by_id(RES_MODULE_RST_SAF_GIC1, &phy_addr, &idx);
  1003e4:	f006 ffda 	bl	10739c <res_get_info_by_id>
    ASSERT(!ret);
  1003e8:	4604      	mov	r4, r0
  1003ea:	2800      	cmp	r0, #0
  1003ec:	d15a      	bne.n	1004a4 <platform_early_init+0x108>
    rstgen_module_ctl(phy_addr, idx, false);
  1003ee:	4602      	mov	r2, r0
  1003f0:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
  1003f4:	f005 f97c 	bl	1056f0 <rstgen_module_ctl>
    rstgen_module_ctl(phy_addr, idx, true);
  1003f8:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
  1003fc:	2201      	movs	r2, #1
  1003fe:	f005 f977 	bl	1056f0 <rstgen_module_ctl>
    //enable gic IP
    platform_gic_reset();
    uart_port_init();
  100402:	f7ff fecd 	bl	1001a0 <uart_port_init>

    uart_init_early();
  100406:	f000 f8db 	bl	1005c0 <uart_init_early>
    sdrpc_notify_msg(NULL, 0xff, NULL);
#ifndef WITH_APPLICATION_EARLY_APP
    sdrpc_notify_msg(NULL, COM_DC_STATUS, NULL);
#endif
#endif
    arm_gic_init_early();
  10040a:	f000 f9fb 	bl	100804 <arm_gic_init_early>
    timer_init_early();
  10040e:	f000 f949 	bl	1006a4 <timer_init_early>
    dcf_early_init();
  100412:	f006 f81b 	bl	10644c <dcf_early_init>
    arm_fpu_set_enable(true);
  100416:	2001      	movs	r0, #1
  100418:	f001 f90e 	bl	101638 <arm_fpu_set_enable>
    __asm__ volatile("VMRS %0, FPSID" : "=r"(fpsid));
  10041c:	eef0 3a10 	vmrs	r3, fpsid
    mpu_add_region(region++, 0x0, REMAP_SZ, MPU_REGION_NO_ACCESS);
  100420:	f04f 0805 	mov.w	r8, #5
    mpu_enable(false);
  100424:	4620      	mov	r0, r4
    mpu_add_region(region++, cospi_trigger_address,
  100426:	2501      	movs	r5, #1
    mpu_add_region(region++, 0, 0x40, MPU_REGION_NORMAL_RO);
  100428:	2604      	movs	r6, #4
    __asm__ volatile("VMRS %0, FPSID" : "=r"(fpsid));
  10042a:	9303      	str	r3, [sp, #12]
    mpu_enable(false);
  10042c:	f001 f9e6 	bl	1017fc <mpu_enable>
    mpu_add_region(region++, 0x0, REMAP_SZ, MPU_REGION_NO_ACCESS);
  100430:	4621      	mov	r1, r4
  100432:	4620      	mov	r0, r4
  100434:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  100438:	2300      	movs	r3, #0
  10043a:	f8cd 8000 	str.w	r8, [r13]
  10043e:	f001 f943 	bl	1016c8 <mpu_add_region>
    mpu_add_region(region++, cospi_trigger_address,
  100442:	f44f 417e 	mov.w	r1, #65024	; 0xfe00
  100446:	4628      	mov	r0, r5
  100448:	f2c0 71ff 	movt	r1, #2047	; 0x7ff
  10044c:	f44f 7200 	mov.w	r2, #512	; 0x200
  100450:	2300      	movs	r3, #0
  100452:	9500      	str	r5, [sp, #0]
  100454:	f001 f938 	bl	1016c8 <mpu_add_region>
    mpu_add_region(region++, cospi_trigger_address,
  100458:	f44f 417e 	mov.w	r1, #65024	; 0xfe00
  10045c:	2002      	movs	r0, #2
  10045e:	f6c0 31ff 	movt	r1, #3071	; 0xbff
  100462:	f44f 7200 	mov.w	r2, #512	; 0x200
  100466:	2300      	movs	r3, #0
  100468:	9500      	str	r5, [sp, #0]
  10046a:	f001 f92d 	bl	1016c8 <mpu_add_region>
    mpu_add_region(region++, 0, 0x40, MPU_REGION_NORMAL_RO);
  10046e:	4621      	mov	r1, r4
  100470:	2003      	movs	r0, #3
  100472:	2240      	movs	r2, #64	; 0x40
  100474:	9600      	str	r6, [sp, #0]
  100476:	2300      	movs	r3, #0
  100478:	f001 f926 	bl	1016c8 <mpu_add_region>
    mpu_add_region(region++, MEMBASE, 0x40, MPU_REGION_NORMAL_RO);
  10047c:	4630      	mov	r0, r6
  10047e:	2240      	movs	r2, #64	; 0x40
  100480:	2300      	movs	r3, #0
  100482:	9600      	str	r6, [sp, #0]
  100484:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  100488:	f001 f91e 	bl	1016c8 <mpu_add_region>
    region = platform_mpu_r5_common(region);
  10048c:	4640      	mov	r0, r8
  10048e:	f00a ff53 	bl	10b338 <platform_mpu_r5_common>
    ASSERT(region <= 16);
  100492:	2810      	cmp	r0, #16
  100494:	dc17      	bgt.n	1004c6 <platform_early_init+0x12a>
    if (region != 0) {
  100496:	b110      	cbz	r0, 10049e <platform_early_init+0x102>
        mpu_enable(true);
  100498:	4628      	mov	r0, r5
  10049a:	f001 f9af 	bl	1017fc <mpu_enable>
    dprintf(INFO, "------------------------------\n\n");
    dprintf(INFO, "Welcome to Semidrive Safety\n\n");
    dprintf(INFO, "Build on: %s - %s\n\n", __DATE__, __TIME__);
    dprintf(INFO, "------------------------------\n\n");
    dprintf(INFO, "platform_early_init done\n");
}
  10049e:	b004      	add	sp, #16
  1004a0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    ASSERT(!ret);
  1004a4:	f64b 6320 	movw	r3, #48672	; 0xbe20
  1004a8:	f64b 6238 	movw	r2, #48696	; 0xbe38
  1004ac:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1004b0:	f2c0 0310 	movt	r3, #16
  1004b4:	4638      	mov	r0, r7
  1004b6:	f2c0 0210 	movt	r2, #16
  1004ba:	9300      	str	r3, [sp, #0]
  1004bc:	f2c0 0110 	movt	r1, #16
  1004c0:	2369      	movs	r3, #105	; 0x69
  1004c2:	f009 fed7 	bl	10a274 <_panic>
    ASSERT(region <= 16);
  1004c6:	f64b 6328 	movw	r3, #48680	; 0xbe28
  1004ca:	f64b 6238 	movw	r2, #48696	; 0xbe38
  1004ce:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1004d2:	f2c0 0310 	movt	r3, #16
  1004d6:	4638      	mov	r0, r7
  1004d8:	f2c0 0210 	movt	r2, #16
  1004dc:	9300      	str	r3, [sp, #0]
  1004de:	f2c0 0110 	movt	r1, #16
  1004e2:	23cf      	movs	r3, #207	; 0xcf
  1004e4:	f009 fec6 	bl	10a274 <_panic>
        vector_remap(MEMBASE);
  1004e8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
  1004ec:	f7ff feb0 	bl	100250 <vector_remap>
        platform_core_reset();
  1004f0:	f7ff ff26 	bl	100340 <platform_core_reset>

001004f4 <platform_init>:
{
#if SUPPORT_BOARDINFO
    init_hwid();
#endif

    uart_init();
  1004f4:	f000 b84a 	b.w	10058c <uart_init>

001004f8 <_dputc>:
#ifdef SUPPORT_VIRT_UART
#include <dev/vuart.h>
#endif

void _dputc(char c)
{
  1004f8:	b538      	push	{r3, r4, r5, r14}
  1004fa:	4604      	mov	r4, r0
    int port = uart_get_current_port();
  1004fc:	f000 f8b4 	bl	100668 <uart_get_current_port>
        vuart_putc(c);
    }

#endif

    if (c == '\n') {
  100500:	2c0a      	cmp	r4, #10
    int port = uart_get_current_port();
  100502:	4605      	mov	r5, r0
    if (c == '\n') {
  100504:	d005      	beq.n	100512 <_dputc+0x1a>
        uart_putc(port, '\r');
    }

    uart_putc(port, c);
  100506:	4621      	mov	r1, r4
  100508:	4628      	mov	r0, r5
}
  10050a:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  10050e:	f000 b883 	b.w	100618 <uart_putc>
        uart_putc(port, '\r');
  100512:	210d      	movs	r1, #13
  100514:	f000 f880 	bl	100618 <uart_putc>
    uart_putc(port, c);
  100518:	4621      	mov	r1, r4
  10051a:	4628      	mov	r0, r5
}
  10051c:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  100520:	f000 b87a 	b.w	100618 <uart_putc>

00100524 <dgetc>:

int dgetc(char *c, bool wait)
{
  100524:	b538      	push	{r3, r4, r5, r14}
  100526:	460c      	mov	r4, r1
  100528:	4605      	mov	r5, r0
    int _c;
    int port = uart_get_current_port();
  10052a:	f000 f89d 	bl	100668 <uart_get_current_port>
        return -1;
    }

#else

    if ((_c = uart_getc(port, wait)) < 0) {
  10052e:	4621      	mov	r1, r4
  100530:	f000 f87c 	bl	10062c <uart_getc>
  100534:	2800      	cmp	r0, #0
        return -1;
  100536:	bfb2      	itee	lt
  100538:	f04f 30ff 	movlt.w	r0, #4294967295	; 0xffffffff
    }

#endif
    *c = _c;
  10053c:	7028      	strbge	r0, [r5, #0]
    return 0;
  10053e:	2000      	movge	r0, #0
}
  100540:	bd38      	pop	{r3, r4, r5, r15}
  100542:	bf00      	nop

00100544 <platform_halt>:
    __asm__ volatile("cpsie i");
}

static inline void arch_disable_ints(void)
{
    __asm__ volatile("cpsid i");
  100544:	b672      	cpsid	i
    CF;
  100546:	e7fe      	b.n	100546 <platform_halt+0x2>

00100548 <platform_dputc>:
    PANIC_UNIMPLEMENTED;
}

void platform_dputc(char c)
{
    _dputc(c);
  100548:	f7ff bfd6 	b.w	1004f8 <_dputc>

0010054c <platform_dgetc>:
}

int platform_dgetc(char *c, bool wait)
{
    return dgetc(c, wait);
  10054c:	f7ff bfea 	b.w	100524 <dgetc>

00100550 <save_char>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
static int save_char(uint8_t data)
{
  100550:	b538      	push	{r3, r4, r5, r14}
  100552:	4605      	mov	r5, r0
#if CONSOLE_HAS_INPUT_BUFFER
    cbuf_write_char(&console_input_cbuf, c, false);
#else

    if (cbuf_space_avail(&uart_rx_buf) == 0) {  //uart_rx_buf no space
  100554:	f644 10e4 	movw	r0, #18916	; 0x49e4
  100558:	f2c0 0011 	movt	r0, #17
  10055c:	f00b f8dc 	bl	10b718 <cbuf_space_avail>
  100560:	b148      	cbz	r0, 100576 <save_char+0x26>
        hal_uart_int_src_disable(safety_log_handle,
                                 UART_HAL_RX_CHAR_INT_SRC); //disable the receive data interrupt
        return 0;
    }

    cbuf_write_char(&uart_rx_buf, data, false);
  100562:	f644 10e4 	movw	r0, #18916	; 0x49e4
  100566:	4629      	mov	r1, r5
  100568:	2200      	movs	r2, #0
  10056a:	f2c0 0011 	movt	r0, #17
  10056e:	f00b f8e5 	bl	10b73c <cbuf_write_char>
    //dprintf(PLATFORM_UART_DEBUG_LEVEL, "%c", data);
#endif
    return 1;
  100572:	2001      	movs	r0, #1
}
  100574:	bd38      	pop	{r3, r4, r5, r15}
        hal_uart_int_src_disable(safety_log_handle,
  100576:	f644 13e0 	movw	r3, #18912	; 0x49e0
  10057a:	4604      	mov	r4, r0
  10057c:	4601      	mov	r1, r0
  10057e:	f2c0 0311 	movt	r3, #17
  100582:	6818      	ldr	r0, [r3, #0]
  100584:	f007 fa60 	bl	107a48 <hal_uart_int_src_disable>
  100588:	4620      	mov	r0, r4
}
  10058a:	bd38      	pop	{r3, r4, r5, r15}

0010058c <uart_init>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init(void)
{
  10058c:	b510      	push	{r4, r14}

    if (safety_log_handle != NULL) {
  10058e:	f644 14e0 	movw	r4, #18912	; 0x49e0
  100592:	f2c0 0411 	movt	r4, #17
  100596:	6823      	ldr	r3, [r4, #0]
  100598:	b183      	cbz	r3, 1005bc <uart_init+0x30>
        cbuf_initialize(&uart_rx_buf,
  10059a:	f644 10e4 	movw	r0, #18916	; 0x49e4
  10059e:	2110      	movs	r1, #16
  1005a0:	f2c0 0011 	movt	r0, #17
  1005a4:	f00b f882 	bl	10b6ac <cbuf_initialize>
                        RXBUF_SIZE);   // create circular buffer to hold received data

        hal_uart_int_cbk_register(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC,
  1005a8:	f240 5251 	movw	r2, #1361	; 0x551
  1005ac:	6820      	ldr	r0, [r4, #0]
  1005ae:	f2c0 0210 	movt	r2, #16
  1005b2:	2100      	movs	r1, #0
                                  save_char);
    }

    dprintf(PLATFORM_UART_DEBUG_LEVEL, "Platform UART inited!\r\n");

}
  1005b4:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        hal_uart_int_cbk_register(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC,
  1005b8:	f007 ba2a 	b.w	107a10 <hal_uart_int_cbk_register>
}
  1005bc:	bd10      	pop	{r4, r15}
  1005be:	bf00      	nop

001005c0 <uart_init_early>:
 ** \param [in]
 ** \param [out]
 *****************************************************************************/

void uart_init_early(void)
{
  1005c0:	b570      	push	{r4, r5, r6, r14}
    hal_uart_cfg_t  hal_cfg;
    uart_instance_t *instance;

    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));

    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  1005c2:	f644 14e0 	movw	r4, #18912	; 0x49e0
{
  1005c6:	b08a      	sub	sp, #40	; 0x28
    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));
  1005c8:	2224      	movs	r2, #36	; 0x24
  1005ca:	2100      	movs	r1, #0
    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  1005cc:	f2c0 0411 	movt	r4, #17
    memset(&hal_cfg,0,sizeof(hal_uart_cfg_t));
  1005d0:	a801      	add	r0, sp, #4
  1005d2:	f009 ef58 	blx	10a484 <memset>
    hal_uart_creat_handle(&safety_log_handle, DEBUG_COM);
  1005d6:	f243 0111 	movw	r1, #12305	; 0x3011
  1005da:	4620      	mov	r0, r4
  1005dc:	f2c4 0142 	movt	r1, #16450	; 0x4042
  1005e0:	f007 f962 	bl	1078a8 <hal_uart_creat_handle>

    if (safety_log_handle != NULL) {
  1005e4:	6820      	ldr	r0, [r4, #0]
  1005e6:	b1a8      	cbz	r0, 100614 <uart_init_early+0x54>
        instance = (uart_instance_t *)safety_log_handle;
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005e8:	f44f 4234 	mov.w	r2, #46080	; 0xb400
        hal_cfg.port_cfg.baud = UART_BAUD;
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  1005ec:	2300      	movs	r3, #0
        hal_cfg.port_cfg.baud = UART_BAUD;
  1005ee:	f44f 36e1 	mov.w	r6, #115200	; 0x1c200
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005f2:	f2c0 42c4 	movt	r2, #1220	; 0x4c4
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
  1005f6:	2503      	movs	r5, #3
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  1005f8:	2402      	movs	r4, #2
        hal_cfg.port_cfg.sclk = SAFETY_UART_SCLK;
  1005fa:	9201      	str	r2, [sp, #4]
        hal_cfg.fifo_cfg.fifo_enable = true;
  1005fc:	2201      	movs	r2, #1
        hal_cfg.port_cfg.baud = UART_BAUD;
  1005fe:	9602      	str	r6, [sp, #8]
        hal_cfg.nine_bits_cfg.nine_bits_enable = false;
#endif
#ifdef UART_DRV_SUPPORT_DMA
        hal_cfg.dma_cfg.dma_enable = false;
#endif
        hal_uart_init(safety_log_handle, &hal_cfg);
  100600:	a901      	add	r1, sp, #4
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  100602:	e9cd 5303 	strd	r5, r3, [r13, #12]
        hal_cfg.fifo_cfg.tx_trigger = UART_HAL_TX_FIFO_EMPTY;
  100606:	e9cd 3308 	strd	r3, r3, [r13, #32]
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  10060a:	9405      	str	r4, [sp, #20]
        hal_cfg.fifo_cfg.fifo_enable = true;
  10060c:	f88d 201c 	strb.w	r2, [r13, #28]
        hal_uart_init(safety_log_handle, &hal_cfg);
  100610:	f007 f9d4 	bl	1079bc <hal_uart_init>
        uart_platform_cfg_printf(instance, &hal_cfg);
    }

}
  100614:	b00a      	add	sp, #40	; 0x28
  100616:	bd70      	pop	{r4, r5, r6, r15}

00100618 <uart_putc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_putc(int port, char data)
{
  100618:	b508      	push	{r3, r14}
    hal_uart_putc(safety_log_handle, data);
  10061a:	f644 13e0 	movw	r3, #18912	; 0x49e0
  10061e:	f2c0 0311 	movt	r3, #17
  100622:	6818      	ldr	r0, [r3, #0]
  100624:	f007 f9ec 	bl	107a00 <hal_uart_putc>
    return 1;
}
  100628:	2001      	movs	r0, #1
  10062a:	bd08      	pop	{r3, r15}

0010062c <uart_getc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_getc(int port, bool wait)
{
  10062c:	b510      	push	{r4, r14}
    cbuf_t *rxbuf = &uart_rx_buf;
    char c;

    if (!safety_log_handle)
  10062e:	f644 14e0 	movw	r4, #18912	; 0x49e0
{
  100632:	b082      	sub	sp, #8
    if (!safety_log_handle)
  100634:	f2c0 0411 	movt	r4, #17
  100638:	6823      	ldr	r3, [r4, #0]
  10063a:	b193      	cbz	r3, 100662 <uart_getc+0x36>
        return -1;

    if (cbuf_read_char(rxbuf, &c, wait) == 1) {
  10063c:	f644 10e4 	movw	r0, #18916	; 0x49e4
  100640:	460a      	mov	r2, r1
  100642:	f2c0 0011 	movt	r0, #17
  100646:	f10d 0107 	add.w	r1, r13, #7
  10064a:	f00b f8b3 	bl	10b7b4 <cbuf_read_char>
  10064e:	2801      	cmp	r0, #1
  100650:	d107      	bne.n	100662 <uart_getc+0x36>
        hal_uart_int_src_enable(safety_log_handle, UART_HAL_RX_CHAR_INT_SRC);
  100652:	6820      	ldr	r0, [r4, #0]
  100654:	2100      	movs	r1, #0
  100656:	f007 f9f3 	bl	107a40 <hal_uart_int_src_enable>
        return c;
  10065a:	f89d 0007 	ldrb.w	r0, [r13, #7]
    }

    return -1;
}
  10065e:	b002      	add	sp, #8
  100660:	bd10      	pop	{r4, r15}
        return -1;
  100662:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  100666:	e7fa      	b.n	10065e <uart_getc+0x32>

00100668 <uart_get_current_port>:
}

int uart_get_current_port(void)
{
    return 0;
}
  100668:	2000      	movs	r0, #0
  10066a:	4770      	bx	r14

0010066c <current_time_hires>:
    return hal_timer_glb_cntr_get(kernel_tick);
}

lk_bigtime_t current_time_hires(void)
{
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  10066c:	f644 2300 	movw	r3, #18944	; 0x4a00
  100670:	f2c0 0311 	movt	r3, #17
{
  100674:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  100676:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(kernel_tick);
  100678:	4620      	mov	r0, r4
  10067a:	f007 f8e5 	bl	107848 <hal_timer_glb_cntr_get>
    lk_bigtime_t us = timer_current_stamp() / instance->cnt_per_us;
  10067e:	2300      	movs	r3, #0
  100680:	6922      	ldr	r2, [r4, #16]
  100682:	f00b fae9 	bl	10bc58 <__aeabi_uldivmod>
    // dprintf(TIMER_DEBUG_LEVEL, "current_time_hires:%d", (uint32_t)us);
    return (lk_bigtime_t)us;
}
  100686:	bd10      	pop	{r4, r15}

00100688 <current_time>:

lk_time_t current_time(void)
{
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  100688:	f644 2300 	movw	r3, #18944	; 0x4a00
  10068c:	f2c0 0311 	movt	r3, #17
{
  100690:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)kernel_tick;
  100692:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(kernel_tick);
  100694:	4620      	mov	r0, r4
  100696:	f007 f8d7 	bl	107848 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
  10069a:	2300      	movs	r3, #0
  10069c:	68e2      	ldr	r2, [r4, #12]
  10069e:	f00b fadb 	bl	10bc58 <__aeabi_uldivmod>
    // dprintf(TIMER_DEBUG_LEVEL, "current_time:%d", (uint32_t)ms);
    return (lk_time_t)ms;
}
  1006a2:	bd10      	pop	{r4, r15}

001006a4 <timer_init_early>:

void timer_init_early(void)
{
  1006a4:	b5f0      	push	{r4, r5, r6, r7, r14}
    hal_timer_glb_cfg_t glb_cfg;
    hal_timer_ovf_cfg_t ovf_cfg;
    timer_instance_t *instance;

    hal_timer_creat_handle(&kernel_tick, RES_KERNEL_TIMER);
  1006a6:	f644 2400 	movw	r4, #18944	; 0x4a00
  1006aa:	f242 0119 	movw	r1, #8217	; 0x2019
  1006ae:	f2c0 0411 	movt	r4, #17
  1006b2:	4620      	mov	r0, r4
{
  1006b4:	b089      	sub	sp, #36	; 0x24
    hal_timer_creat_handle(&kernel_tick, RES_KERNEL_TIMER);
  1006b6:	f2c4 013e 	movt	r1, #16446	; 0x403e
  1006ba:	f006 ffa7 	bl	10760c <hal_timer_creat_handle>

    if (kernel_tick != NULL) {
  1006be:	6820      	ldr	r0, [r4, #0]
  1006c0:	b1f8      	cbz	r0, 100702 <timer_init_early+0x5e>
        instance = (timer_instance_t *)kernel_tick;
        glb_cfg.cascade = true;
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
        glb_cfg.clk_frq = TIMER_FREQ;
  1006c2:	f44f 5358 	mov.w	r3, #13824	; 0x3600
        glb_cfg.cascade = true;
  1006c6:	2501      	movs	r5, #1
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  1006c8:	2202      	movs	r2, #2
        glb_cfg.clk_frq = TIMER_FREQ;
  1006ca:	f2c0 136e 	movt	r3, #366	; 0x16e
        glb_cfg.clk_div = 1;
        hal_timer_global_init(kernel_tick, &glb_cfg);
        ovf_cfg.cnt_val = 0;
        ovf_cfg.ovf_val = 0xFFFFFFFF;
        ovf_cfg.periodic = true;
  1006ce:	ae08      	add	r6, sp, #32
        glb_cfg.clk_frq = TIMER_FREQ;
  1006d0:	9305      	str	r3, [sp, #20]
        hal_timer_global_init(kernel_tick, &glb_cfg);
  1006d2:	a904      	add	r1, sp, #16
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  1006d4:	9204      	str	r2, [sp, #16]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  1006d6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        glb_cfg.cascade = true;
  1006da:	f88d 501c 	strb.w	r5, [r13, #28]
        glb_cfg.clk_div = 1;
  1006de:	9506      	str	r5, [sp, #24]
        hal_timer_global_init(kernel_tick, &glb_cfg);
  1006e0:	f007 f822 	bl	107728 <hal_timer_global_init>
        ovf_cfg.periodic = true;
  1006e4:	f806 5d1c 	strb.w	r5, [r6, #-28]!
        ovf_cfg.cnt_val = 0;
  1006e8:	2300      	movs	r3, #0
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G0, &ovf_cfg);
  1006ea:	4632      	mov	r2, r6
  1006ec:	4619      	mov	r1, r3
  1006ee:	6820      	ldr	r0, [r4, #0]
        ovf_cfg.cnt_val = 0;
  1006f0:	9302      	str	r3, [sp, #8]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  1006f2:	9703      	str	r7, [sp, #12]
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G0, &ovf_cfg);
  1006f4:	f007 f83c 	bl	107770 <hal_timer_ovf_init>
        hal_timer_ovf_init(kernel_tick, HAL_TIMER_G1, &ovf_cfg);
  1006f8:	4632      	mov	r2, r6
  1006fa:	4629      	mov	r1, r5
  1006fc:	6820      	ldr	r0, [r4, #0]
  1006fe:	f007 f837 	bl	107770 <hal_timer_ovf_init>
        dprintf(TIMER_DEBUG_LEVEL,
                "Platform timer init finished, cnt per ms:%d, cnt per us:%d\n",
                instance->cnt_per_ms,
                instance->cnt_per_us);
    }
}
  100702:	b009      	add	sp, #36	; 0x24
  100704:	bdf0      	pop	{r4, r5, r6, r7, r15}
  100706:	bf00      	nop

00100708 <vPortTickTimerEnable>:
/******************************* vPortTickTimerEnable implementation *******************************/

void vPortTickTimerEnable( void (*Tick_Handler)( void ) )
{
  100708:	b570      	push	{r4, r5, r6, r14}
    //timer_instance_t *instance;

    ovf_cfg.cnt_val = 0;
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
    ovf_cfg.periodic = true;
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  10070a:	f644 2400 	movw	r4, #18944	; 0x4a00
{
  10070e:	b084      	sub	sp, #16
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  100710:	f2c0 0411 	movt	r4, #17
    ovf_cfg.periodic = true;
  100714:	2601      	movs	r6, #1
  100716:	aa04      	add	r2, sp, #16
    ovf_cfg.cnt_val = 0;
  100718:	2100      	movs	r1, #0
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
  10071a:	f642 63e0 	movw	r3, #12000	; 0x2ee0
    ovf_cfg.periodic = true;
  10071e:	f802 6d0c 	strb.w	r6, [r2, #-12]!
{
  100722:	4605      	mov	r5, r0
    ovf_cfg.cnt_val = 0;
  100724:	9102      	str	r1, [sp, #8]
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  100726:	2102      	movs	r1, #2
  100728:	6820      	ldr	r0, [r4, #0]
    ovf_cfg.ovf_val = configTICK_OVF_VAL;
  10072a:	9303      	str	r3, [sp, #12]
    hal_timer_ovf_init(kernel_tick, HAL_TIMER_LOCAL_A, &ovf_cfg);
  10072c:	f007 f820 	bl	107770 <hal_timer_ovf_init>

    hal_timer_int_cbk_register(kernel_tick, HAL_TIMER_CNT_LA_OVF_INT_SRC, (hal_timer_int_cbk)Tick_Handler);
  100730:	462a      	mov	r2, r5
  100732:	210a      	movs	r1, #10
  100734:	6820      	ldr	r0, [r4, #0]
  100736:	f007 f83b 	bl	1077b0 <hal_timer_int_cbk_register>
    hal_timer_int_src_enable(kernel_tick, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  10073a:	6820      	ldr	r0, [r4, #0]
  10073c:	210a      	movs	r1, #10
  10073e:	f007 f829 	bl	107794 <hal_timer_int_src_enable>
}
  100742:	b004      	add	sp, #16
  100744:	bd70      	pop	{r4, r5, r6, r15}
  100746:	bf00      	nop

00100748 <register_int_handler>:

#endif


void register_int_handler(unsigned int vector, int_handler handler, void *arg)
{
  100748:	b570      	push	{r4, r5, r6, r14}
    void* gic_handle = NULL;
  10074a:	2500      	movs	r5, #0
{
  10074c:	b084      	sub	sp, #16
  10074e:	460e      	mov	r6, r1
    void* gic_handle = NULL;
  100750:	ab04      	add	r3, sp, #16
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100752:	f44f 5180 	mov.w	r1, #4096	; 0x1000
{
  100756:	4604      	mov	r4, r0
    void* gic_handle = NULL;
  100758:	f843 5d04 	str.w	r5, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  10075c:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  100760:	4618      	mov	r0, r3
{
  100762:	4615      	mov	r5, r2
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100764:	f006 f9f4 	bl	106b50 <hal_arm_gic_create_handle>
  100768:	b1b8      	cbz	r0, 10079a <register_int_handler+0x52>
    {
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else if(vector > MAX_INT)
  10076a:	f5b4 7f89 	cmp.w	r4, #274	; 0x112
  10076e:	d80b      	bhi.n	100788 <register_int_handler+0x40>
        vSetInterruptControlBlock(ICB,handler,arg,vector);
        spin_unlock_irqrestore(&ICB_lock,states);

        hal_arm_gic_register_interrupt(gic_handle, ICB->usMeta.ulVector, ICB->usMeta.ucPriority, uInterruptTopHalf, ICB);
#else
        hal_arm_gic_register_interrupt(gic_handle, vector, DEFAULT_INTERRUPT_PRIORITY, handler, arg);
  100770:	4633      	mov	r3, r6
  100772:	4621      	mov	r1, r4
  100774:	9803      	ldr	r0, [sp, #12]
  100776:	221e      	movs	r2, #30
  100778:	9500      	str	r5, [sp, #0]
  10077a:	f006 fa15 	bl	106ba8 <hal_arm_gic_register_interrupt>
#endif
        hal_arm_gic_release_handle(gic_handle);
  10077e:	9803      	ldr	r0, [sp, #12]
  100780:	f006 f9e8 	bl	106b54 <hal_arm_gic_release_handle>
    }

    return;
}
  100784:	b004      	add	sp, #16
  100786:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  100788:	f64b 60c8 	movw	r0, #48840	; 0xbec8
  10078c:	4621      	mov	r1, r4
  10078e:	f2c0 0010 	movt	r0, #16
  100792:	f00a fda3 	bl	10b2dc <printf>
}
  100796:	b004      	add	sp, #16
  100798:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  10079a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  10079e:	f64b 60a0 	movw	r0, #48800	; 0xbea0
  1007a2:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  1007a6:	f2c0 0010 	movt	r0, #16
  1007aa:	f00a fd97 	bl	10b2dc <printf>
}
  1007ae:	b004      	add	sp, #16
  1007b0:	bd70      	pop	{r4, r5, r6, r15}
  1007b2:	bf00      	nop

001007b4 <unmask_interrupt>:
    }

    return ret;
}
status_t unmask_interrupt(unsigned int vector)
{
  1007b4:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
  1007b6:	2200      	movs	r2, #0
{
  1007b8:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007ba:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  1007be:	ab02      	add	r3, sp, #8
{
  1007c0:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007c2:	f2cc 010a 	movt	r1, #49162	; 0xc00a
    void* gic_handle = NULL;
  1007c6:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1007ca:	4618      	mov	r0, r3
  1007cc:	f006 f9c0 	bl	106b50 <hal_arm_gic_create_handle>
  1007d0:	b150      	cbz	r0, 1007e8 <unmask_interrupt+0x34>
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_enable_interrupt(gic_handle, vector);
  1007d2:	9801      	ldr	r0, [sp, #4]
  1007d4:	4621      	mov	r1, r4
  1007d6:	f006 f9df 	bl	106b98 <hal_arm_gic_enable_interrupt>
  1007da:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
  1007dc:	9801      	ldr	r0, [sp, #4]
  1007de:	f006 f9b9 	bl	106b54 <hal_arm_gic_release_handle>
    }

    return ret;
}
  1007e2:	4620      	mov	r0, r4
  1007e4:	b002      	add	sp, #8
  1007e6:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_ERROR_LEVEL,
  1007e8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  1007ec:	f64b 60a0 	movw	r0, #48800	; 0xbea0
  1007f0:	f2cc 010a 	movt	r1, #49162	; 0xc00a
        ret = -1;
  1007f4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_ERROR_LEVEL,
  1007f8:	f2c0 0010 	movt	r0, #16
  1007fc:	f00a fd6e 	bl	10b2dc <printf>
  100800:	e7ef      	b.n	1007e2 <unmask_interrupt+0x2e>
  100802:	bf00      	nop

00100804 <arm_gic_init_early>:

void arm_gic_init_early(void)
{
  100804:	b500      	push	{r14}
    void* gic_handle = NULL;
  100806:	2300      	movs	r3, #0
{
  100808:	b083      	sub	sp, #12

    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  10080a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  10080e:	a802      	add	r0, sp, #8
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100810:	f2cc 010a 	movt	r1, #49162	; 0xc00a
    void* gic_handle = NULL;
  100814:	f840 3d04 	str.w	r3, [r0, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  100818:	f006 f99a 	bl	106b50 <hal_arm_gic_create_handle>
  10081c:	b140      	cbz	r0, 100830 <arm_gic_init_early+0x2c>
        dprintf(INTERRUPT_ERROR_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_init(gic_handle);
  10081e:	9801      	ldr	r0, [sp, #4]
  100820:	f006 f99a 	bl	106b58 <hal_arm_gic_init>
        hal_arm_gic_release_handle(gic_handle);
  100824:	9801      	ldr	r0, [sp, #4]
  100826:	f006 f995 	bl	106b54 <hal_arm_gic_release_handle>
    }

    return;
}
  10082a:	b003      	add	sp, #12
  10082c:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(INTERRUPT_ERROR_LEVEL,
  100830:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  100834:	f64b 60a0 	movw	r0, #48800	; 0xbea0
  100838:	f2cc 010a 	movt	r1, #49162	; 0xc00a
  10083c:	f2c0 0010 	movt	r0, #16
  100840:	f00a fd4c 	bl	10b2dc <printf>
}
  100844:	b003      	add	sp, #12
  100846:	f85d fb04 	ldr.w	r15, [r13], #4
  10084a:	bf00      	nop

0010084c <vApplicationIRQHandler>:

/* FreeRTOS IRQ implementation. */
void vApplicationIRQHandler(uint32_t ulICCIAR)
{
    arm_gic_platform_irq_spotless(ulICCIAR);
  10084c:	f003 bc78 	b.w	104140 <arm_gic_platform_irq_spotless>

00100850 <sysd_reboot_probe>:
#endif /* STATIC HANDOVER */

SYSD_CALL(reboot_probe)
{
#if STATIC_HANDOVER
    ospi_handover_entry();
  100850:	f001 b95c 	b.w	101b0c <ospi_handover_entry>

00100854 <arm_context_switch>:
     */
/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */
FUNCTION(arm_context_switch)
    /* save non callee trashed supervisor registers */
    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */
    push    { r4-r11, lr }
  100854:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    /* save old sp */
    str     sp, [r0]
  100858:	e580d000 	str	r13, [r0]

    /* clear any exlusive locks that the old thread holds */
#if ARM_ARCH_LEVEL >= 7
    /* can clear it directly */
    clrex
  10085c:	f57ff01f 	clrex
    ldr     r0, =strex_spot
    strex   r3, r2, [r0]
#endif

    /* load new regs */
    mov     sp, r1
  100860:	e1a0d001 	mov	r13, r1
    pop     { r4-r11, lr }
  100864:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
    bx      lr
  100868:	e12fff1e 	bx	r14

0010086c <arm_save_mode_regs>:
#endif

.text

FUNCTION(arm_save_mode_regs)
    mrs     r1, cpsr
  10086c:	e10f1000 	mrs	r1, CPSR

    stmia   r0, { r13, r14 }^ /* usr */
  100870:	e8c06000 	stmia	r0, {r13, r14}^
    add     r0, #8
  100874:	e2800008 	add	r0, r0, #8

    cps     #0x11   /* fiq */
  100878:	f1020011 	cps	#17
    str     r13, [r0], #4
  10087c:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  100880:	e480e004 	str	r14, [r0], #4

    cps     #0x12   /* irq */
  100884:	f1020012 	cps	#18
    str     r13, [r0], #4
  100888:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  10088c:	e480e004 	str	r14, [r0], #4

    cps     #0x13   /* svc */
  100890:	f1020013 	cps	#19
    str     r13, [r0], #4
  100894:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  100898:	e480e004 	str	r14, [r0], #4

    cps     #0x17   /* abt */
  10089c:	f1020017 	cps	#23
    str     r13, [r0], #4
  1008a0:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008a4:	e480e004 	str	r14, [r0], #4

    cps     #0x1b   /* und */
  1008a8:	f102001b 	cps	#27
    str     r13, [r0], #4
  1008ac:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008b0:	e480e004 	str	r14, [r0], #4

    cps     #0x1f   /* sys */
  1008b4:	f102001f 	cps	#31
    str     r13, [r0], #4
  1008b8:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1008bc:	e480e004 	str	r14, [r0], #4

    msr     cpsr_c, r1
  1008c0:	e121f001 	msr	CPSR_c, r1

    bx      lr
  1008c4:	e12fff1e 	bx	r14

001008c8 <arm_chain_load>:

/* void arm_chain_load(paddr_t entry, ulong arg0, ulong arg1, ulong arg2, ulong arg3) __NO_RETURN; */
/* shut down the system, branching into the secondary system */
FUNCTION(arm_chain_load)
    /* shuffle the args around */
    mov     r4, r0      /* r4 = entry point */
  1008c8:	e1a04000 	mov	r4, r0
    mov     r0, r1
  1008cc:	e1a00001 	mov	r0, r1
    mov     r1, r2
  1008d0:	e1a01002 	mov	r1, r2
    mov     r2, r3
  1008d4:	e1a02003 	mov	r2, r3
    ldr     r3, [sp]
  1008d8:	e59d3000 	ldr	r3, [r13]
    isb

#endif // WITH_KERNEL_VM

    /* call the entry point */
    bx      r4
  1008dc:	e12fff14 	bx	r4

001008e0 <arch_disable_cache>:

#elif ARM_ISA_ARMV7

/* void arch_disable_cache(uint flags) */
FUNCTION(arch_disable_cache)
    stmfd   sp!, {r4-r11, lr}
  1008e0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    mov     r7, r0                      // save flags
  1008e4:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  1008e8:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  1008ec:	f10c01c0 	cpsid	aif

.Ldcache_disable:
    tst     r7, #DCACHE
  1008f0:	e3170002 	tst	r7, #2
    beq     .Licache_disable
  1008f4:	0a000007 	beq	100918 <arch_disable_cache+0x38>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  1008f8:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already disabled?
  1008fc:	e3100004 	tst	r0, #4
    beq     .Ldcache_already_disabled
  100900:	0a000003 	beq	100914 <arch_disable_cache+0x34>

    bic     r0, #(1<<2)
  100904:	e3c00004 	bic	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // disable dcache
  100908:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    // flush and invalidate the dcache
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
    bl      flush_invalidate_cache_v7
  10090c:	eb000021 	bl	100998 <flush_invalidate_cache_v7>

    b       .Ldcache_disable_L2
  100910:	ea000000 	b	100918 <arch_disable_cache+0x38>

.Ldcache_already_disabled:
    // make sure all of the caches are invalidated
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  100914:	eb000044 	bl	100a2c <invalidate_cache_v7>
    bic     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // disable L2 dcache
#endif

.Licache_disable:
    tst     r7, #ICACHE
  100918:	e3170001 	tst	r7, #1
    beq     .Ldone_disable
  10091c:	0a000002 	beq	10092c <arch_disable_cache+0x4c>

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100920:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, #(1<<12)
  100924:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // disable icache
  100928:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_disable:
    // make sure the icache is always invalidated
    mov     r0, #0
  10092c:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  100930:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    msr     cpsr, r8
  100934:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r11, pc}
  100938:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

0010093c <arch_enable_cache>:

/* void arch_enable_cache(uint flags) */
FUNCTION(arch_enable_cache)
    stmfd   sp!, {r4-r12, lr}
  10093c:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}

    mov     r7, r0                      // save flags
  100940:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  100944:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  100948:	f10c01c0 	cpsid	aif

.Ldcache_enable:
    tst     r7, #DCACHE
  10094c:	e3170002 	tst	r7, #2
    beq     .Licache_enable
  100950:	0a000006 	beq	100970 <arch_enable_cache+0x34>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100954:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already enabled?
  100958:	e3100004 	tst	r0, #4
    bne     .Licache_enable
  10095c:	1a000003 	bne	100970 <arch_enable_cache+0x34>

    // invalidate L1 and L2
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  100960:	eb000031 	bl	100a2c <invalidate_cache_v7>
    mrc     p15, 0, r0, c1, c0, 1       // aux cr1
    orr     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // enable L2 dcache
#endif

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100964:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<2)
  100968:	e3800004 	orr	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // enable dcache
  10096c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Licache_enable:
    tst     r7, #ICACHE
  100970:	e3170001 	tst	r7, #1
    beq     .Ldone_enable
  100974:	0a000004 	beq	10098c <arch_enable_cache+0x50>

    mov     r0, #0
  100978:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  10097c:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  100980:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<12)
  100984:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // enable icache
  100988:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_enable:
    isb
  10098c:	f57ff06f 	isb	sy
    msr     cpsr, r8
  100990:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r12, pc}
  100994:	e8bd9ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r15}

00100998 <flush_invalidate_cache_v7>:

// flush & invalidate cache routine, trashes r0-r6, r9-r11
flush_invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  100998:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  10099c:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  1009a0:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  1009a4:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished
  1009a8:	0a00001a 	beq	100a18 <flush_invalidate_cache_v7+0x80>
    MOV     R10, #0
  1009ac:	e3a0a000 	mov	r10, #0
.Loop1:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  1009b0:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  1009b4:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  1009b8:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  1009bc:	e3510002 	cmp	r1, #2
    BLT     .Lskip                      // no cache or only instruction cache at this level
  1009c0:	ba000011 	blt	100a0c <flush_invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  1009c4:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  1009c8:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  1009cc:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  1009d0:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  1009d4:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  1009d8:	e59f4160 	ldr	r4, [pc, #352]	; 100b40 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  1009dc:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  1009e0:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  1009e4:	e59f6158 	ldr	r6, [pc, #344]	; 100b44 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  1009e8:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  1009ec:	e1a09004 	mov	r9, r4
.Loop3:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  1009f0:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  1009f4:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c14, 2     // clean & invalidate by set/way
  1009f8:	ee07bf5e 	mcr	15, 0, r11, cr7, cr14, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  1009fc:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3
  100a00:	aafffffa 	bge	1009f0 <flush_invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  100a04:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2
  100a08:	aafffff7 	bge	1009ec <flush_invalidate_cache_v7+0x54>
.Lskip:
    ADD     R10, R10, #2                    // increment the cache number
  100a0c:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  100a10:	e153000a 	cmp	r3, r10
    BGT     .Loop1
  100a14:	caffffe5 	bgt	1009b0 <flush_invalidate_cache_v7+0x18>

.Lfinished:
    mov     r10, #0
  100a18:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  100a1c:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    dsb
  100a20:	f57ff04f 	dsb	sy
    isb
  100a24:	f57ff06f 	isb	sy

    bx      lr
  100a28:	e12fff1e 	bx	r14

00100a2c <invalidate_cache_v7>:

// invalidate cache routine, trashes r0-r6, r9-r11
invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  100a2c:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  100a30:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  100a34:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  100a38:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished_invalidate
  100a3c:	0a00001a 	beq	100aac <invalidate_cache_v7+0x80>
    MOV     R10, #0
  100a40:	e3a0a000 	mov	r10, #0
.Loop1_invalidate:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  100a44:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  100a48:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  100a4c:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  100a50:	e3510002 	cmp	r1, #2
    BLT     .Lskip_invalidate           // no cache or only instruction cache at this level
  100a54:	ba000011 	blt	100aa0 <invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  100a58:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  100a5c:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  100a60:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  100a64:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  100a68:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  100a6c:	e59f40cc 	ldr	r4, [pc, #204]	; 100b40 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  100a70:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  100a74:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  100a78:	e59f60c4 	ldr	r6, [pc, #196]	; 100b44 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  100a7c:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2_invalidate:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  100a80:	e1a09004 	mov	r9, r4
.Loop3_invalidate:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  100a84:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  100a88:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c6, 2      // invalidate by set/way
  100a8c:	ee07bf56 	mcr	15, 0, r11, cr7, cr6, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  100a90:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3_invalidate
  100a94:	aafffffa 	bge	100a84 <invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  100a98:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2_invalidate
  100a9c:	aafffff7 	bge	100a80 <invalidate_cache_v7+0x54>
.Lskip_invalidate:
    ADD     R10, R10, #2                // increment the cache number
  100aa0:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  100aa4:	e153000a 	cmp	r3, r10
    BGT     .Loop1_invalidate
  100aa8:	caffffe5 	bgt	100a44 <invalidate_cache_v7+0x18>

.Lfinished_invalidate:
    dsb
  100aac:	f57ff04f 	dsb	sy
    mov     r10, #0
  100ab0:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  100ab4:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb
  100ab8:	f57ff06f 	isb	sy

    bx      lr
  100abc:	e12fff1e 	bx	r14

00100ac0 <arch_clean_cache_range_asm>:
/* shared cache flush routines */

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100ac0:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100ac4:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100ac8:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c10, 1      // clean cache to PoC by MVA
  100acc:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
    add     r0, #CACHE_LINE
  100ad0:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100ad4:	e1500002 	cmp	r0, r2
    blo     0b
  100ad8:	3afffffb 	bcc	100acc <arch_clean_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100adc:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_range
#else
    bx      lr
  100ae0:	e12fff1e 	bx	r14

00100ae4 <arch_clean_invalidate_cache_range_asm>:
#endif

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100ae4:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100ae8:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100aec:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c14, 1      // clean & invalidate dcache to PoC by MVA
  100af0:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
    add     r0, r0, #CACHE_LINE
  100af4:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100af8:	e1500002 	cmp	r0, r2
    blo     0b
  100afc:	3afffffb 	bcc	100af0 <arch_clean_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100b00:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_invalidate_range
#else
    bx      lr
  100b04:	e12fff1e 	bx	r14

00100b08 <arch_invalidate_cache_range_asm>:
#endif

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  100b08:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  100b0c:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  100b10:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c6, 1       // invalidate dcache to PoC by MVA
  100b14:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
    add     r0, r0, #CACHE_LINE
  100b18:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  100b1c:	e1500002 	cmp	r0, r2
    blo     0b
  100b20:	3afffffb 	bcc	100b14 <arch_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  100b24:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_invalidate_range
#else
    bx      lr
  100b28:	e12fff1e 	bx	r14

00100b2c <arch_sync_cache_range_asm>:
#endif

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range_asm)
    push    { r14 }
  100b2c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
    bl      arch_clean_cache_range_asm
  100b30:	ebffffe2 	bl	100ac0 <arch_clean_cache_range_asm>

    mov     r0, #0
  100b34:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  100b38:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    pop     { pc }
  100b3c:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
    LDR     R4, =0x3FF
  100b40:	000003ff 	.word	0x000003ff
    LDR     R6, =0x00007FFF
  100b44:	00007fff 	.word	0x00007fff

00100b48 <_arch_enable_ints>:

.text

/* void _arch_enable_ints(void); */
FUNCTION(_arch_enable_ints)
    mrs     r0, cpsr
  100b48:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #(1<<7)     /* clear the I bit */
  100b4c:	e3c00080 	bic	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  100b50:	e121f000 	msr	CPSR_c, r0
    bx      lr
  100b54:	e12fff1e 	bx	r14

00100b58 <_arch_disable_ints>:

/* void _arch_disable_ints(void); */
FUNCTION(_arch_disable_ints)
    mrs     r0, cpsr
  100b58:	e10f0000 	mrs	r0, CPSR
    orr     r0, r0, #(1<<7)
  100b5c:	e3800080 	orr	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  100b60:	e121f000 	msr	CPSR_c, r0
    bx      lr
  100b64:	e12fff1e 	bx	r14

00100b68 <_atomic_swap>:

/* int _atomic_swap(int *ptr, int val); */
FUNCTION(_atomic_swap)
.L_loop_swap:
    ldrex   r12, [r0]
  100b68:	e190cf9f 	ldrex	r12, [r0]
    strex   r2, r1, [r0]
  100b6c:	e1802f91 	strex	r2, r1, [r0]
    cmp     r2, #0
  100b70:	e3520000 	cmp	r2, #0
    bne     .L_loop_swap
  100b74:	1afffffb 	bne	100b68 <_atomic_swap>

    /* save old value */
    mov     r0, r12
  100b78:	e1a0000c 	mov	r0, r12
    bx      lr
  100b7c:	e12fff1e 	bx	r14

00100b80 <_atomic_add>:

/* int _atomic_add(int *ptr, int val); */
FUNCTION(_atomic_add)
    /* use load/store exclusive */
.L_loop_add:
    ldrex   r12, [r0]
  100b80:	e190cf9f 	ldrex	r12, [r0]
    add     r2, r12, r1
  100b84:	e08c2001 	add	r2, r12, r1
    strex   r3, r2, [r0]
  100b88:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100b8c:	e3530000 	cmp	r3, #0
    bne     .L_loop_add
  100b90:	1afffffa 	bne	100b80 <_atomic_add>

    /* save old value */
    mov     r0, r12
  100b94:	e1a0000c 	mov	r0, r12
    bx      lr
  100b98:	e12fff1e 	bx	r14

00100b9c <_atomic_and>:

/* int _atomic_and(int *ptr, int val); */
FUNCTION(_atomic_and)
    /* use load/store exclusive */
.L_loop_and:
    ldrex   r12, [r0]
  100b9c:	e190cf9f 	ldrex	r12, [r0]
    and     r2, r12, r1
  100ba0:	e00c2001 	and	r2, r12, r1
    strex   r3, r2, [r0]
  100ba4:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100ba8:	e3530000 	cmp	r3, #0
    bne     .L_loop_and
  100bac:	1afffffa 	bne	100b9c <_atomic_and>

    /* save old value */
    mov     r0, r12
  100bb0:	e1a0000c 	mov	r0, r12
    bx      lr
  100bb4:	e12fff1e 	bx	r14

00100bb8 <_atomic_or>:

/* int _atomic_or(int *ptr, int val); */
FUNCTION(_atomic_or)
    /* use load/store exclusive */
.L_loop_or:
    ldrex   r12, [r0]
  100bb8:	e190cf9f 	ldrex	r12, [r0]
    orr     r2, r12, r1
  100bbc:	e18c2001 	orr	r2, r12, r1
    strex   r3, r2, [r0]
  100bc0:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  100bc4:	e3530000 	cmp	r3, #0
    bne     .L_loop_or
  100bc8:	1afffffa 	bne	100bb8 <_atomic_or>

    /* save old value */
    mov     r0, r12
  100bcc:	e1a0000c 	mov	r0, r12
    bx      lr
  100bd0:	e12fff1e 	bx	r14

00100bd4 <arch_spin_trylock>:

FUNCTION(arch_spin_trylock)
    mov     r2, r0
  100bd4:	e1a02000 	mov	r2, r0
    mov     r1, #1
  100bd8:	e3a01001 	mov	r1, #1
    ldrex   r0, [r2]
  100bdc:	e1920f9f 	ldrex	r0, [r2]
    cmp     r0, #0
  100be0:	e3500000 	cmp	r0, #0
    strexeq r0, r1, [r2]
  100be4:	01820f91 	strexeq	r0, r1, [r2]
    dmb
  100be8:	f57ff05f 	dmb	sy
    bx      lr
  100bec:	e12fff1e 	bx	r14

00100bf0 <arch_spin_lock>:

FUNCTION(arch_spin_lock)
    mov     r1, #1
  100bf0:	e3a01001 	mov	r1, #1
1:
    ldrex   r2, [r0]
  100bf4:	e1902f9f 	ldrex	r2, [r0]
    cmp     r2, #0
  100bf8:	e3520000 	cmp	r2, #0
    wfene
  100bfc:	1320f002 	wfene
    strexeq r2, r1, [r0]
  100c00:	01802f91 	strexeq	r2, r1, [r0]
    cmpeq   r2, #0
  100c04:	03520000 	cmpeq	r2, #0
    bne     1b
  100c08:	1afffff9 	bne	100bf4 <arch_spin_lock+0x4>
    dmb
  100c0c:	f57ff05f 	dmb	sy
    bx      lr
  100c10:	e12fff1e 	bx	r14

00100c14 <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
    mov     r1, #0
  100c14:	e3a01000 	mov	r1, #0
    dmb
  100c18:	f57ff05f 	dmb	sy
    str     r1, [r0]
  100c1c:	e5801000 	str	r1, [r0]
    dsb
  100c20:	f57ff04f 	dsb	sy
    sev
  100c24:	e320f004 	sev
    bx      lr
  100c28:	e12fff1e 	bx	r14

00100c2c <arch_idle>:

/* void arch_idle(); */
FUNCTION(arch_idle)
#if ARM_ARCH_LEVEL >= 7
    wfi
  100c2c:	e320f003 	wfi
    mov     r0, #0
    mcr     p15, 0, r0, c7, c0, #4
#else
#error unknown cpu
#endif
    bx      lr
  100c30:	e12fff1e 	bx	r14

00100c34 <arm_invalidate_tlb>:

/* void arm_invalidate_tlb(void) */
FUNCTION(arm_invalidate_tlb)
    mov     r0, #0
  100c34:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c8, c7, 0
  100c38:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    bx      lr
  100c3c:	e12fff1e 	bx	r14

00100c40 <arm_undefined>:
    /* return to whence we came from */
    rfeia   sp!
.endm

FUNCTION(arm_undefined)
    save
  100c40:	f96d0513 	srsdb	r13!, #19
  100c44:	f10e0093 	cpsid	i,#19
  100c48:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100c4c:	e24dd008 	sub	r13, r13, #8
  100c50:	e8cd6000 	stmia	r13, {r13, r14}^
  100c54:	eef80a10 	vmrs	r0, fpexc
  100c58:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100c5c:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100c60:	eee80a10 	vmsr	fpexc, r0
  100c64:	e1a0000d 	mov	r0, r13
  100c68:	e31d0004 	tst	r13, #4
  100c6c:	024dd004 	subeq	r13, r13, #4
  100c70:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_undefined_handler
  100c74:	fa00018a 	blx	1012a4 <arm_undefined_handler>

    restore
  100c78:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100c7c:	e1a0d000 	mov	r13, r0
  100c80:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100c84:	eee80a10 	vmsr	fpexc, r0
  100c88:	e8dd6000 	ldm	r13, {r13, r14}^
  100c8c:	e28dd008 	add	r13, r13, #8
  100c90:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100c94:	f8bd0a00 	rfeia	r13!

00100c98 <arm_syscall>:

#ifndef WITH_LIB_SYSCALL
FUNCTION(arm_syscall)
    saveall
  100c98:	f96d0513 	srsdb	r13!, #19
  100c9c:	f10e0093 	cpsid	i,#19
  100ca0:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100ca4:	e24dd008 	sub	r13, r13, #8
  100ca8:	e8cd6000 	stmia	r13, {r13, r14}^
  100cac:	eef80a10 	vmrs	r0, fpexc
  100cb0:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100cb4:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100cb8:	eee80a10 	vmsr	fpexc, r0
  100cbc:	e1a0000d 	mov	r0, r13
  100cc0:	e31d0004 	tst	r13, #4
  100cc4:	024dd004 	subeq	r13, r13, #4
  100cc8:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_syscall_handler
  100ccc:	fa000170 	blx	101294 <arm_syscall_handler>

    restoreall
  100cd0:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100cd4:	e1a0d000 	mov	r13, r0
  100cd8:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100cdc:	eee80a10 	vmsr	fpexc, r0
  100ce0:	e8dd6000 	ldm	r13, {r13, r14}^
  100ce4:	e28dd008 	add	r13, r13, #8
  100ce8:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100cec:	f8bd0a00 	rfeia	r13!

00100cf0 <arm_prefetch_abort>:
#endif

FUNCTION(arm_prefetch_abort)
    saveall_offset #4
  100cf0:	e24ee004 	sub	r14, r14, #4
  100cf4:	f96d0513 	srsdb	r13!, #19
  100cf8:	f10e0093 	cpsid	i,#19
  100cfc:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d00:	e24dd008 	sub	r13, r13, #8
  100d04:	e8cd6000 	stmia	r13, {r13, r14}^
  100d08:	eef80a10 	vmrs	r0, fpexc
  100d0c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100d10:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100d14:	eee80a10 	vmsr	fpexc, r0
  100d18:	e1a0000d 	mov	r0, r13
  100d1c:	e31d0004 	tst	r13, #4
  100d20:	024dd004 	subeq	r13, r13, #4
  100d24:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_prefetch_abort_handler
  100d28:	fa000206 	blx	101548 <arm_prefetch_abort_handler>

    restoreall
  100d2c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d30:	e1a0d000 	mov	r13, r0
  100d34:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d38:	eee80a10 	vmsr	fpexc, r0
  100d3c:	e8dd6000 	ldm	r13, {r13, r14}^
  100d40:	e28dd008 	add	r13, r13, #8
  100d44:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d48:	f8bd0a00 	rfeia	r13!

00100d4c <arm_data_abort>:

FUNCTION(arm_data_abort)
    saveall_offset #8
  100d4c:	e24ee008 	sub	r14, r14, #8
  100d50:	f96d0513 	srsdb	r13!, #19
  100d54:	f10e0093 	cpsid	i,#19
  100d58:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100d5c:	e24dd008 	sub	r13, r13, #8
  100d60:	e8cd6000 	stmia	r13, {r13, r14}^
  100d64:	eef80a10 	vmrs	r0, fpexc
  100d68:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100d6c:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100d70:	eee80a10 	vmsr	fpexc, r0
  100d74:	e1a0000d 	mov	r0, r13
  100d78:	e31d0004 	tst	r13, #4
  100d7c:	024dd004 	subeq	r13, r13, #4
  100d80:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_data_abort_handler
  100d84:	fa000180 	blx	10138c <arm_data_abort_handler>

    restoreall
  100d88:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d8c:	e1a0d000 	mov	r13, r0
  100d90:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100d94:	eee80a10 	vmsr	fpexc, r0
  100d98:	e8dd6000 	ldm	r13, {r13, r14}^
  100d9c:	e28dd008 	add	r13, r13, #8
  100da0:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  100da4:	f8bd0a00 	rfeia	r13!

00100da8 <arm_reserved>:

FUNCTION(arm_reserved)
    b   .
  100da8:	eafffffe 	b	100da8 <arm_reserved>

00100dac <arm_irq>:
    /* read the cycle count */
    mrc     p15, 0, sp, c9, c13, 0
    str     sp, [pc, #__irq_cycle_count - . - 8]
#endif

    save_offset    #4
  100dac:	e24ee004 	sub	r14, r14, #4
  100db0:	f96d0513 	srsdb	r13!, #19
  100db4:	f10e0093 	cpsid	i,#19
  100db8:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100dbc:	e24dd008 	sub	r13, r13, #8
  100dc0:	e8cd6000 	stmia	r13, {r13, r14}^
  100dc4:	eef80a10 	vmrs	r0, fpexc
  100dc8:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100dcc:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100dd0:	eee80a10 	vmsr	fpexc, r0
  100dd4:	e1a0000d 	mov	r0, r13
  100dd8:	e31d0004 	tst	r13, #4
  100ddc:	024dd004 	subeq	r13, r13, #4
  100de0:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)

    /* r0 now holds pointer to iframe */

    /* track that we're inside an irq handler */
    LOADCONST(r2, __arm_in_handler)
  100de4:	e3012f98 	movw	r2, #8088	; 0x1f98
  100de8:	e3402011 	movt	r2, #17
    mov     r1, #1
  100dec:	e3a01001 	mov	r1, #1
    str     r1, [r2]
  100df0:	e5821000 	str	r1, [r2]

    /* call into higher level code */
    bl  platform_irq
  100df4:	fa000cb9 	blx	1040e0 <platform_irq>

    /* clear the irq handler status */
    LOADCONST(r1, __arm_in_handler)
  100df8:	e3011f98 	movw	r1, #8088	; 0x1f98
  100dfc:	e3401011 	movt	r1, #17
    mov     r2, #0
  100e00:	e3a02000 	mov	r2, #0
    str     r2, [r1]
  100e04:	e5812000 	str	r2, [r1]

    /* reschedule if the handler returns nonzero */
    cmp     r0, #0
  100e08:	e3500000 	cmp	r0, #0
    /* blne    thread_preempt */

    restore
  100e0c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e10:	e1a0d000 	mov	r13, r0
  100e14:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e18:	eee80a10 	vmsr	fpexc, r0
  100e1c:	e8dd6000 	ldm	r13, {r13, r14}^
  100e20:	e28dd008 	add	r13, r13, #8
  100e24:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100e28:	f8bd0a00 	rfeia	r13!

00100e2c <arm_fiq>:

FUNCTION(arm_fiq)
    save_offset #4
  100e2c:	e24ee004 	sub	r14, r14, #4
  100e30:	f96d0513 	srsdb	r13!, #19
  100e34:	f10e0093 	cpsid	i,#19
  100e38:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  100e3c:	e24dd008 	sub	r13, r13, #8
  100e40:	e8cd6000 	stmia	r13, {r13, r14}^
  100e44:	eef80a10 	vmrs	r0, fpexc
  100e48:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  100e4c:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  100e50:	eee80a10 	vmsr	fpexc, r0
  100e54:	e1a0000d 	mov	r0, r13
  100e58:	e31d0004 	tst	r13, #4
  100e5c:	024dd004 	subeq	r13, r13, #4
  100e60:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl  platform_fiq
  100e64:	fa000cc4 	blx	10417c <platform_fiq>

    restore
  100e68:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e6c:	e1a0d000 	mov	r13, r0
  100e70:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  100e74:	eee80a10 	vmsr	fpexc, r0
  100e78:	e8dd6000 	ldm	r13, {r13, r14}^
  100e7c:	e28dd008 	add	r13, r13, #8
  100e80:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  100e84:	f8bd0a00 	rfeia	r13!

00100e88 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cmp	r2, #0
  100e88:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_done
  100e8c:	0a000003 	beq	100ea0 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	r3, [r1], #1
  100e90:	e4d13001 	ldrb	r3, [r1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	strbt	r3, [r0], #1
  100e94:	e4e03001 	strbt	r3, [r0], #1

	subs	r2, r2, #1
  100e98:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_to_user_loop
  100e9c:	8afffffb 	bhi	100e90 <arch_copy_to_user+0x8>
.Larch_copy_to_user_done:
	mov	r0, #0
  100ea0:	e3a00000 	mov	r0, #0
	bx	lr
  100ea4:	e12fff1e 	bx	r14

00100ea8 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cmp	r2, #0
  100ea8:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_from_user_done
  100eac:	0a000003 	beq	100ec0 <arch_copy_from_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldrbt	r3, [r1], #1
  100eb0:	e4f13001 	ldrbt	r3, [r1], #1

	strb	r3, [r0], #1
  100eb4:	e4c03001 	strb	r3, [r0], #1
	subs	r2, r2, #1
  100eb8:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_loop
  100ebc:	8afffffb 	bhi	100eb0 <arch_copy_from_user+0x8>
.Larch_copy_from_user_done:
	mov	r0, #0
  100ec0:	e3a00000 	mov	r0, #0
	bx	lr
  100ec4:	e12fff1e 	bx	r14

00100ec8 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	ip, r1
  100ec8:	e1a0c001 	mov	r12, r1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldrbt	r3, [r1]
  100ecc:	e4f13000 	ldrbt	r3, [r1], #0

	cmp	r3, #0
  100ed0:	e3530000 	cmp	r3, #0
	addne	r1, r1, #1
  100ed4:	12811001 	addne	r1, r1, #1

	cmp	r2, #0
  100ed8:	e3520000 	cmp	r2, #0
	beq	.Larch_strlcpy_from_user_dst_full
  100edc:	0a000002 	beq	100eec <arch_strlcpy_from_user+0x24>
	subs	r2, r2, #1
  100ee0:	e2522001 	subs	r2, r2, #1
	streqb	r2, [r0], #1
  100ee4:	04c02001 	strbeq	r2, [r0], #1
	strneb	r3, [r0], #1
  100ee8:	14c03001 	strbne	r3, [r0], #1
.Larch_strlcpy_from_user_dst_full:
	cmp	r3, #0
  100eec:	e3530000 	cmp	r3, #0
	bne	.Larch_strlcpy_from_user_loop
  100ef0:	1afffff5 	bne	100ecc <arch_strlcpy_from_user+0x4>

	sub	r0, r1, ip
  100ef4:	e041000c 	sub	r0, r1, r12
	bx	lr
  100ef8:	e12fff1e 	bx	r14

.Larch_strlcpy_from_user_fault:
	cmp	r2, #0
  100efc:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_fault
  100f00:	0a000003 	beq	100f14 <arch_strlcpy_from_user+0x4c>
.Larch_copy_from_user_fault:
	mov	r1, #0
  100f04:	e3a01000 	mov	r1, #0
	strb	r1, [r0], #1
  100f08:	e4c01001 	strb	r1, [r0], #1
	subs	r2, r2, #1
  100f0c:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_fault
  100f10:	8afffffb 	bhi	100f04 <arch_strlcpy_from_user+0x3c>
.Larch_copy_to_user_fault:
	mov	r0, #ERR_FAULT
  100f14:	e3e00027 	mvn	r0, #39	; 0x27
	bx	lr
  100f18:	e12fff1e 	bx	r14

00100f1c <dump_mode_regs>:

extern struct fault_handler_table_entry __fault_handler_table_start[];
extern struct fault_handler_table_entry __fault_handler_table_end[];

static void dump_mode_regs(uint32_t spsr, uint32_t svc_r13, uint32_t svc_r14)
{
  100f1c:	b570      	push	{r4, r5, r6, r14}
  100f1e:	4604      	mov	r4, r0
  100f20:	b090      	sub	sp, #64	; 0x40
    struct arm_mode_regs regs;
    arm_save_mode_regs(&regs);
  100f22:	a802      	add	r0, sp, #8
{
  100f24:	4615      	mov	r5, r2

    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  100f26:	f004 041f 	and.w	r4, r4, #31
{
  100f2a:	460e      	mov	r6, r1
    arm_save_mode_regs(&regs);
  100f2c:	f7ff ec9e 	blx	10086c <arm_save_mode_regs>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  100f30:	9b03      	ldr	r3, [sp, #12]
  100f32:	2c10      	cmp	r4, #16
  100f34:	f24c 1274 	movw	r2, #49524	; 0xc174
  100f38:	f24c 1078 	movw	r0, #49528	; 0xc178
  100f3c:	9300      	str	r3, [sp, #0]
  100f3e:	f2c0 0210 	movt	r2, #16
  100f42:	9b02      	ldr	r3, [sp, #8]
  100f44:	f2c0 0010 	movt	r0, #16
  100f48:	f000 80d8 	beq.w	1010fc <dump_mode_regs+0x1e0>
  100f4c:	2120      	movs	r1, #32
  100f4e:	f00a f9c5 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  100f52:	9b05      	ldr	r3, [sp, #20]
  100f54:	f24c 1294 	movw	r2, #49556	; 0xc194
  100f58:	2c11      	cmp	r4, #17
  100f5a:	f24c 1078 	movw	r0, #49528	; 0xc178
  100f5e:	f2c0 0210 	movt	r2, #16
  100f62:	9300      	str	r3, [sp, #0]
  100f64:	f2c0 0010 	movt	r0, #16
  100f68:	9b04      	ldr	r3, [sp, #16]
  100f6a:	d158      	bne.n	10101e <dump_mode_regs+0x102>
  100f6c:	212a      	movs	r1, #42	; 0x2a
  100f6e:	f00a f9b5 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  100f72:	9b07      	ldr	r3, [sp, #28]
  100f74:	f24c 1298 	movw	r2, #49560	; 0xc198
  100f78:	f24c 1078 	movw	r0, #49528	; 0xc178
  100f7c:	9300      	str	r3, [sp, #0]
  100f7e:	f2c0 0210 	movt	r2, #16
  100f82:	9b06      	ldr	r3, [sp, #24]
  100f84:	2120      	movs	r1, #32
  100f86:	f2c0 0010 	movt	r0, #16
  100f8a:	f00a f9a7 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  100f8e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  100f90:	f24c 129c 	movw	r2, #49564	; 0xc19c
  100f94:	f24c 1078 	movw	r0, #49528	; 0xc178
  100f98:	9300      	str	r3, [sp, #0]
  100f9a:	f2c0 0210 	movt	r2, #16
  100f9e:	9b08      	ldr	r3, [sp, #32]
  100fa0:	2161      	movs	r1, #97	; 0x61
  100fa2:	f2c0 0010 	movt	r0, #16
  100fa6:	f00a f999 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  100faa:	f24c 129c 	movw	r2, #49564	; 0xc19c
  100fae:	f24c 1078 	movw	r0, #49528	; 0xc178
  100fb2:	f2c0 0210 	movt	r2, #16
  100fb6:	9500      	str	r5, [sp, #0]
  100fb8:	f2c0 0010 	movt	r0, #16
  100fbc:	4633      	mov	r3, r6
  100fbe:	2120      	movs	r1, #32
  100fc0:	f00a f98c 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  100fc4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  100fc6:	f24c 12a0 	movw	r2, #49568	; 0xc1a0
  100fca:	f24c 1078 	movw	r0, #49528	; 0xc178
  100fce:	f2c0 0210 	movt	r2, #16
  100fd2:	9300      	str	r3, [sp, #0]
  100fd4:	f2c0 0010 	movt	r0, #16
  100fd8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  100fda:	2120      	movs	r1, #32
  100fdc:	f00a f97e 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  100fe0:	2c1f      	cmp	r4, #31
  100fe2:	d159      	bne.n	101098 <dump_mode_regs+0x17c>
  100fe4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  100fe6:	f24c 12a4 	movw	r2, #49572	; 0xc1a4
  100fea:	f24c 1078 	movw	r0, #49528	; 0xc178
  100fee:	f2c0 0210 	movt	r2, #16
  100ff2:	9300      	str	r3, [sp, #0]
  100ff4:	f2c0 0010 	movt	r0, #16
  100ff8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  100ffa:	212a      	movs	r1, #42	; 0x2a
  100ffc:	f00a f96e 	bl	10b2dc <printf>
            break;
        case CPSR_MODE_UND:
            stack = regs.und_r13;
            break;
        case CPSR_MODE_SYS:
            stack = regs.sys_r13;
  101000:	9e0e      	ldr	r6, [sp, #56]	; 0x38
            break;
        default:
            stack = 0;
    }

    if (stack != 0) {
  101002:	b156      	cbz	r6, 10101a <dump_mode_regs+0xfe>
        dprintf(CRITICAL, "bottom of stack at 0x%08x:\n", (unsigned int)stack);
  101004:	f24c 10a8 	movw	r0, #49576	; 0xc1a8
  101008:	4631      	mov	r1, r6
  10100a:	f2c0 0010 	movt	r0, #16
  10100e:	f00a f965 	bl	10b2dc <printf>
        hexdump((void *)stack, 128);
  101012:	4630      	mov	r0, r6
  101014:	2180      	movs	r1, #128	; 0x80
  101016:	f009 f943 	bl	10a2a0 <hexdump>
    }
}
  10101a:	b010      	add	sp, #64	; 0x40
  10101c:	bd70      	pop	{r4, r5, r6, r15}
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  10101e:	2120      	movs	r1, #32
  101020:	f00a f95c 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  101024:	9b07      	ldr	r3, [sp, #28]
  101026:	f24c 1298 	movw	r2, #49560	; 0xc198
  10102a:	2c12      	cmp	r4, #18
  10102c:	f24c 1078 	movw	r0, #49528	; 0xc178
  101030:	f2c0 0210 	movt	r2, #16
  101034:	9300      	str	r3, [sp, #0]
  101036:	f2c0 0010 	movt	r0, #16
  10103a:	9b06      	ldr	r3, [sp, #24]
  10103c:	f040 8096 	bne.w	10116c <dump_mode_regs+0x250>
  101040:	212a      	movs	r1, #42	; 0x2a
  101042:	f00a f94b 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  101046:	9b09      	ldr	r3, [sp, #36]	; 0x24
  101048:	f24c 129c 	movw	r2, #49564	; 0xc19c
  10104c:	f24c 1078 	movw	r0, #49528	; 0xc178
  101050:	9300      	str	r3, [sp, #0]
  101052:	f2c0 0210 	movt	r2, #16
  101056:	9b08      	ldr	r3, [sp, #32]
  101058:	2161      	movs	r1, #97	; 0x61
  10105a:	f2c0 0010 	movt	r0, #16
  10105e:	f00a f93d 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  101062:	f24c 129c 	movw	r2, #49564	; 0xc19c
  101066:	f24c 1078 	movw	r0, #49528	; 0xc178
  10106a:	f2c0 0210 	movt	r2, #16
  10106e:	4633      	mov	r3, r6
  101070:	2120      	movs	r1, #32
  101072:	9500      	str	r5, [sp, #0]
  101074:	f2c0 0010 	movt	r0, #16
  101078:	f00a f930 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  10107c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  10107e:	f24c 12a0 	movw	r2, #49568	; 0xc1a0
  101082:	f24c 1078 	movw	r0, #49528	; 0xc178
  101086:	9300      	str	r3, [sp, #0]
  101088:	f2c0 0210 	movt	r2, #16
  10108c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  10108e:	f2c0 0010 	movt	r0, #16
  101092:	2120      	movs	r1, #32
  101094:	f00a f922 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  101098:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  10109a:	f24c 12a4 	movw	r2, #49572	; 0xc1a4
  10109e:	f24c 1078 	movw	r0, #49528	; 0xc178
    switch (spsr & CPSR_MODE_MASK) {
  1010a2:	3c11      	subs	r4, #17
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1010a4:	9300      	str	r3, [sp, #0]
  1010a6:	f2c0 0210 	movt	r2, #16
  1010aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  1010ac:	f2c0 0010 	movt	r0, #16
  1010b0:	2120      	movs	r1, #32
  1010b2:	f00a f913 	bl	10b2dc <printf>
    switch (spsr & CPSR_MODE_MASK) {
  1010b6:	2c0e      	cmp	r4, #14
  1010b8:	d8af      	bhi.n	10101a <dump_mode_regs+0xfe>
  1010ba:	a301      	add	r3, pc, #4	; (adr r3, 1010c0 <dump_mode_regs+0x1a4>)
  1010bc:	f853 f024 	ldr.w	r15, [r3, r4, lsl #2]
  1010c0:	00101169 	.word	0x00101169
  1010c4:	00101165 	.word	0x00101165
  1010c8:	00101003 	.word	0x00101003
  1010cc:	0010101b 	.word	0x0010101b
  1010d0:	0010101b 	.word	0x0010101b
  1010d4:	0010101b 	.word	0x0010101b
  1010d8:	0010101b 	.word	0x0010101b
  1010dc:	0010101b 	.word	0x0010101b
  1010e0:	0010101b 	.word	0x0010101b
  1010e4:	0010101b 	.word	0x0010101b
  1010e8:	00101161 	.word	0x00101161
  1010ec:	0010101b 	.word	0x0010101b
  1010f0:	0010101b 	.word	0x0010101b
  1010f4:	0010101b 	.word	0x0010101b
  1010f8:	00101001 	.word	0x00101001
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  1010fc:	212a      	movs	r1, #42	; 0x2a
  1010fe:	f00a f8ed 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  101102:	9b05      	ldr	r3, [sp, #20]
  101104:	f24c 1294 	movw	r2, #49556	; 0xc194
  101108:	f24c 1078 	movw	r0, #49528	; 0xc178
  10110c:	9300      	str	r3, [sp, #0]
  10110e:	f2c0 0210 	movt	r2, #16
  101112:	9b04      	ldr	r3, [sp, #16]
  101114:	f2c0 0010 	movt	r0, #16
  101118:	2120      	movs	r1, #32
  10111a:	e728      	b.n	100f6e <dump_mode_regs+0x52>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  10111c:	2120      	movs	r1, #32
  10111e:	f00a f8dd 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  101122:	2c1b      	cmp	r4, #27
  101124:	f47f af4e 	bne.w	100fc4 <dump_mode_regs+0xa8>
  101128:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  10112a:	f24c 12a0 	movw	r2, #49568	; 0xc1a0
  10112e:	f24c 1078 	movw	r0, #49528	; 0xc178
  101132:	f2c0 0210 	movt	r2, #16
  101136:	9300      	str	r3, [sp, #0]
  101138:	212a      	movs	r1, #42	; 0x2a
  10113a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  10113c:	f2c0 0010 	movt	r0, #16
  101140:	f00a f8cc 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  101144:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  101146:	f24c 12a4 	movw	r2, #49572	; 0xc1a4
  10114a:	f24c 1078 	movw	r0, #49528	; 0xc178
  10114e:	9300      	str	r3, [sp, #0]
  101150:	f2c0 0210 	movt	r2, #16
  101154:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  101156:	f2c0 0010 	movt	r0, #16
  10115a:	2120      	movs	r1, #32
  10115c:	f00a f8be 	bl	10b2dc <printf>
            stack = regs.und_r13;
  101160:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            break;
  101162:	e74e      	b.n	101002 <dump_mode_regs+0xe6>
            stack = regs.irq_r13;
  101164:	9e06      	ldr	r6, [sp, #24]
            break;
  101166:	e74c      	b.n	101002 <dump_mode_regs+0xe6>
            stack = regs.fiq_r13;
  101168:	9e04      	ldr	r6, [sp, #16]
            break;
  10116a:	e74a      	b.n	101002 <dump_mode_regs+0xe6>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  10116c:	2120      	movs	r1, #32
  10116e:	f00a f8b5 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  101172:	9b09      	ldr	r3, [sp, #36]	; 0x24
  101174:	f24c 129c 	movw	r2, #49564	; 0xc19c
  101178:	f24c 1078 	movw	r0, #49528	; 0xc178
  10117c:	9300      	str	r3, [sp, #0]
  10117e:	f2c0 0210 	movt	r2, #16
  101182:	9b08      	ldr	r3, [sp, #32]
  101184:	f2c0 0010 	movt	r0, #16
  101188:	2161      	movs	r1, #97	; 0x61
  10118a:	f00a f8a7 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  10118e:	f24c 129c 	movw	r2, #49564	; 0xc19c
  101192:	f24c 1078 	movw	r0, #49528	; 0xc178
  101196:	2c13      	cmp	r4, #19
  101198:	9500      	str	r5, [sp, #0]
  10119a:	f2c0 0210 	movt	r2, #16
  10119e:	4633      	mov	r3, r6
  1011a0:	f2c0 0010 	movt	r0, #16
  1011a4:	d1ba      	bne.n	10111c <dump_mode_regs+0x200>
  1011a6:	212a      	movs	r1, #42	; 0x2a
  1011a8:	f00a f898 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  1011ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1011ae:	f24c 12a0 	movw	r2, #49568	; 0xc1a0
  1011b2:	f24c 1078 	movw	r0, #49528	; 0xc178
  1011b6:	9300      	str	r3, [sp, #0]
  1011b8:	f2c0 0210 	movt	r2, #16
  1011bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1011be:	2120      	movs	r1, #32
  1011c0:	f2c0 0010 	movt	r0, #16
  1011c4:	f00a f88a 	bl	10b2dc <printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1011c8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  1011ca:	f24c 12a4 	movw	r2, #49572	; 0xc1a4
  1011ce:	f24c 1078 	movw	r0, #49528	; 0xc178
  1011d2:	9300      	str	r3, [sp, #0]
  1011d4:	f2c0 0210 	movt	r2, #16
  1011d8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  1011da:	2120      	movs	r1, #32
  1011dc:	f2c0 0010 	movt	r0, #16
  1011e0:	f00a f87c 	bl	10b2dc <printf>
  1011e4:	e70d      	b.n	101002 <dump_mode_regs+0xe6>
  1011e6:	bf00      	nop

001011e8 <exception_die>:

    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
}

static void exception_die(struct arm_fault_frame *frame, const char *msg)
{
  1011e8:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  1011ea:	f24c 10c4 	movw	r0, #49604	; 0xc1c4
{
  1011ee:	b500      	push	{r14}
    dprintf(CRITICAL, "%s", msg);
  1011f0:	f2c0 0010 	movt	r0, #16
{
  1011f4:	b083      	sub	sp, #12
    dprintf(CRITICAL, "%s", msg);
  1011f6:	f00a f871 	bl	10b2dc <printf>

GEN_CP15_REG_FUNCS(fcseidr, 0, c13, c0, 0);
GEN_CP15_REG_FUNCS(contextidr, 0, c13, c0, 1);
GEN_CP15_REG_FUNCS(tpidrurw, 0, c13, c0, 2);
GEN_CP15_REG_FUNCS(tpidruro, 0, c13, c0, 3);
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  1011fa:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    dprintf(CRITICAL, "current_thread %p, name %s\n",
  1011fe:	f501 72b2 	add.w	r2, r1, #356	; 0x164
  101202:	b919      	cbnz	r1, 10120c <exception_die+0x24>
  101204:	f641 324c 	movw	r2, #6988	; 0x1b4c
  101208:	f2c0 0211 	movt	r2, #17
  10120c:	f24c 10c8 	movw	r0, #49608	; 0xc1c8
  101210:	f2c0 0010 	movt	r0, #16
  101214:	f00a f862 	bl	10b2dc <printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
  101218:	69a5      	ldr	r5, [r4, #24]
  10121a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  10121e:	f24c 10e4 	movw	r0, #49636	; 0xc1e4
  101222:	68e1      	ldr	r1, [r4, #12]
  101224:	f2c0 0010 	movt	r0, #16
  101228:	9500      	str	r5, [sp, #0]
  10122a:	f00a f857 	bl	10b2dc <printf>
    dprintf(CRITICAL, "r4  0x%08x r5  0x%08x r6  0x%08x r7  0x%08x\n", frame->r[4], frame->r[5], frame->r[6], frame->r[7]);
  10122e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  101230:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  101234:	f24c 2014 	movw	r0, #49684	; 0xc214
  101238:	69e1      	ldr	r1, [r4, #28]
  10123a:	f2c0 0010 	movt	r0, #16
  10123e:	9500      	str	r5, [sp, #0]
  101240:	f00a f84c 	bl	10b2dc <printf>
    dprintf(CRITICAL, "r8  0x%08x r9  0x%08x r10 0x%08x r11 0x%08x\n", frame->r[8], frame->r[9], frame->r[10], frame->r[11]);
  101244:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  101246:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
  10124a:	f24c 2044 	movw	r0, #49732	; 0xc244
  10124e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  101250:	f2c0 0010 	movt	r0, #16
  101254:	9500      	str	r5, [sp, #0]
  101256:	f00a f841 	bl	10b2dc <printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r[12], frame->usp, frame->ulr, frame->pc);
  10125a:	6c65      	ldr	r5, [r4, #68]	; 0x44
  10125c:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  101260:	f24c 2074 	movw	r0, #49780	; 0xc274
  101264:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  101266:	f2c0 0010 	movt	r0, #16
  10126a:	9500      	str	r5, [sp, #0]
  10126c:	f00a f836 	bl	10b2dc <printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  101270:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  101272:	f24c 20a4 	movw	r0, #49828	; 0xc2a4
  101276:	f2c0 0010 	movt	r0, #16
  10127a:	f00a f82f 	bl	10b2dc <printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  10127e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  101280:	6c22      	ldr	r2, [r4, #64]	; 0x40
  101282:	f104 014c 	add.w	r1, r4, #76	; 0x4c
  101286:	f7ff fe49 	bl	100f1c <dump_mode_regs>
    dump_fault_frame(frame);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  10128a:	2109      	movs	r1, #9
  10128c:	2000      	movs	r0, #0
  10128e:	f7ff f959 	bl	100544 <platform_halt>
  101292:	bf00      	nop

00101294 <arm_syscall_handler>:
    for (;;);
}

__WEAK void arm_syscall_handler(struct arm_fault_frame *frame)
{
    exception_die(frame, "unhandled syscall, halting\n");
  101294:	f24c 113c 	movw	r1, #49468	; 0xc13c
{
  101298:	b508      	push	{r3, r14}
    exception_die(frame, "unhandled syscall, halting\n");
  10129a:	f2c0 0110 	movt	r1, #16
  10129e:	f7ff ffa3 	bl	1011e8 <exception_die>
  1012a2:	bf00      	nop

001012a4 <arm_undefined_handler>:
}

void arm_undefined_handler(struct arm_iframe *frame)
{
  1012a4:	e9d0 3209 	ldrd	r3, r2, [r0, #36]	; 0x24
  1012a8:	b510      	push	{r4, r14}
    /* look at the undefined instruction, figure out if it's something we can handle */
    bool in_thumb = frame->spsr & (1<<5);
    if (in_thumb) {
  1012aa:	0692      	lsls	r2, r2, #26
{
  1012ac:	b082      	sub	sp, #8
    if (in_thumb) {
  1012ae:	d524      	bpl.n	1012fa <arm_undefined_handler+0x56>
        if (opcode & 0x0000e800) {
            /* swap the 16bit words */
            opcode = (opcode >> 16) | (opcode << 16);
        }

        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012b0:	f44f 6120 	mov.w	r1, #2560	; 0xa00
        frame->pc -= 2;
  1012b4:	1e9a      	subs	r2, r3, #2
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012b6:	f6ce 4100 	movt	r1, #60416	; 0xec00
        frame->pc -= 2;
  1012ba:	6242      	str	r2, [r0, #36]	; 0x24
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012bc:	f44f 6260 	mov.w	r2, #3584	; 0xe00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  1012c0:	f853 3c02 	ldr.w	r3, [r3, #-2]
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012c4:	f6ce 4200 	movt	r2, #60416	; 0xec00
        if (opcode & 0x0000e800) {
  1012c8:	f413 4f68 	tst.w	r3, #59392	; 0xe800
            opcode = (opcode >> 16) | (opcode << 16);
  1012cc:	bf18      	it	ne
  1012ce:	ea4f 4333 	movne.w	r3, r3, ror #16
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012d2:	401a      	ands	r2, r3
  1012d4:	428a      	cmp	r2, r1
  1012d6:	d00b      	beq.n	1012f0 <arm_undefined_handler+0x4c>
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  1012d8:	f003 426f 	and.w	r2, r3, #4009754624	; 0xef000000
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1012dc:	f1b2 4f6f 	cmp.w	r2, #4009754624	; 0xef000000
  1012e0:	d006      	beq.n	1012f0 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf9000000)) { // VLD
  1012e2:	2200      	movs	r2, #0
  1012e4:	f6cf 7210 	movt	r2, #65296	; 0xff10
  1012e8:	401a      	ands	r2, r3
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  1012ea:	f1b2 4f79 	cmp.w	r2, #4177526784	; 0xf9000000
  1012ee:	d11f      	bne.n	101330 <arm_undefined_handler+0x8c>

#if ARM_WITH_VFP
fpu:
    arm_fpu_undefined_instruction(frame);
#endif
}
  1012f0:	b002      	add	sp, #8
  1012f2:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    arm_fpu_undefined_instruction(frame);
  1012f6:	f000 b9a7 	b.w	101648 <arm_fpu_undefined_instruction>
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  1012fa:	f44f 6260 	mov.w	r2, #3584	; 0xe00
        frame->pc -= 4;
  1012fe:	1f1c      	subs	r4, r3, #4
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101300:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  101304:	f6c0 4200 	movt	r2, #3072	; 0xc00
        frame->pc -= 4;
  101308:	6244      	str	r4, [r0, #36]	; 0x24
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  10130a:	f6c0 4100 	movt	r1, #3072	; 0xc00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  10130e:	f853 3c04 	ldr.w	r3, [r3, #-4]
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  101312:	401a      	ands	r2, r3
  101314:	428a      	cmp	r2, r1
  101316:	d0eb      	beq.n	1012f0 <arm_undefined_handler+0x4c>
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  101318:	f003 427e 	and.w	r2, r3, #4261412864	; 0xfe000000
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  10131c:	f1b2 4f72 	cmp.w	r2, #4060086272	; 0xf2000000
  101320:	d0e6      	beq.n	1012f0 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf4000000)) { // VLD
  101322:	2200      	movs	r2, #0
  101324:	f6cf 7210 	movt	r2, #65296	; 0xff10
  101328:	401a      	ands	r2, r3
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  10132a:	f1b2 4f74 	cmp.w	r2, #4093640704	; 0xf4000000
  10132e:	d0df      	beq.n	1012f0 <arm_undefined_handler+0x4c>
  101330:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  101332:	f24c 1058 	movw	r0, #49496	; 0xc158
  101336:	f2c0 0010 	movt	r0, #16
  10133a:	f009 ffb7 	bl	10b2ac <puts>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r0, frame->r1, frame->r2, frame->r3);
  10133e:	f24c 10e4 	movw	r0, #49636	; 0xc1e4
  101342:	69a3      	ldr	r3, [r4, #24]
  101344:	f2c0 0010 	movt	r0, #16
  101348:	9300      	str	r3, [sp, #0]
  10134a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  10134e:	68e1      	ldr	r1, [r4, #12]
  101350:	f009 ffc4 	bl	10b2dc <printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r12, frame->usp, frame->ulr, frame->pc);
  101354:	6a63      	ldr	r3, [r4, #36]	; 0x24
  101356:	9300      	str	r3, [sp, #0]
  101358:	f24c 2074 	movw	r0, #49780	; 0xc274
  10135c:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  101360:	f2c0 0010 	movt	r0, #16
  101364:	69e1      	ldr	r1, [r4, #28]
  101366:	f009 ffb9 	bl	10b2dc <printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  10136a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  10136c:	f24c 20a4 	movw	r0, #49828	; 0xc2a4
  101370:	f2c0 0010 	movt	r0, #16
  101374:	f009 ffb2 	bl	10b2dc <printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  101378:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  10137a:	6a22      	ldr	r2, [r4, #32]
  10137c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  101380:	f7ff fdcc 	bl	100f1c <dump_mode_regs>
    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  101384:	2109      	movs	r1, #9
  101386:	2000      	movs	r0, #0
  101388:	f7ff f8dc 	bl	100544 <platform_halt>

0010138c <arm_data_abort_handler>:

void arm_data_abort_handler(struct arm_fault_frame *frame)
{
  10138c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
GEN_CP15_REG_FUNCS(dfsr, 0, c5, c0, 0);
  10138e:	ee15 5f10 	mrc	15, 0, r5, cr5, cr0, {0}
GEN_CP15_REG_FUNCS(dfar, 0, c6, c0, 0);
  101392:	ee16 6f10 	mrc	15, 0, r6, cr6, cr0, {0}
    uint32_t fsr = arm_read_dfsr();
    uint32_t far = arm_read_dfar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  101396:	f64b 53e0 	movw	r3, #48608	; 0xbde0
  10139a:	f64b 52f8 	movw	r2, #48632	; 0xbdf8
  10139e:	f2c0 0310 	movt	r3, #16
  1013a2:	f2c0 0210 	movt	r2, #16
  1013a6:	4293      	cmp	r3, r2
  1013a8:	d216      	bcs.n	1013d8 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1013aa:	6c47      	ldr	r7, [r0, #68]	; 0x44
  1013ac:	6819      	ldr	r1, [r3, #0]
  1013ae:	42b9      	cmp	r1, r7
  1013b0:	bf1f      	itttt	ne
  1013b2:	43dc      	mvnne	r4, r3
  1013b4:	18a4      	addne	r4, r4, r2
  1013b6:	f024 0407 	bicne.w	r4, r4, #7
  1013ba:	18e4      	addne	r4, r4, r3
  1013bc:	d00a      	beq.n	1013d4 <arm_data_abort_handler+0x48>
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1013be:	42a3      	cmp	r3, r4
  1013c0:	f103 0208 	add.w	r2, r3, #8
  1013c4:	d008      	beq.n	1013d8 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1013c6:	6811      	ldr	r1, [r2, #0]
  1013c8:	4613      	mov	r3, r2
  1013ca:	42b9      	cmp	r1, r7
  1013cc:	d1f7      	bne.n	1013be <arm_data_abort_handler+0x32>
            frame->pc = fault_handler->fault_handler;
  1013ce:	6853      	ldr	r3, [r2, #4]
  1013d0:	6443      	str	r3, [r0, #68]	; 0x44

    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);

    exception_die(frame, "halting\n");
}
  1013d2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1013d4:	461a      	mov	r2, r3
  1013d6:	e7fa      	b.n	1013ce <arm_data_abort_handler+0x42>
  1013d8:	4604      	mov	r4, r0
    dprintf(CRITICAL, "\n\ncpu %u data abort, ", arch_curr_cpu_num());
  1013da:	f64b 7010 	movw	r0, #48912	; 0xbf10
  1013de:	2100      	movs	r1, #0
  1013e0:	f2c0 0010 	movt	r0, #16
  1013e4:	f009 ff7a 	bl	10b2dc <printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  1013e8:	09ab      	lsrs	r3, r5, #6
  1013ea:	f005 020f 	and.w	r2, r5, #15
  1013ee:	f003 0310 	and.w	r3, r3, #16
  1013f2:	4313      	orrs	r3, r2
    switch (fault_status) {
  1013f4:	3b01      	subs	r3, #1
    bool write = !!BIT(fsr, 11);
  1013f6:	f405 6200 	and.w	r2, r5, #2048	; 0x800
    switch (fault_status) {
  1013fa:	2b15      	cmp	r3, #21
  1013fc:	d80c      	bhi.n	101418 <arm_data_abort_handler+0x8c>
  1013fe:	e8df f003 	tbb	[r15, r3]
  101402:	8990      	.short	0x8990
  101404:	77650b77 	.word	0x77650b77
  101408:	0b4a5365 	.word	0x0b4a5365
  10140c:	0b380b4a 	.word	0x0b380b4a
  101410:	0b0b0b38 	.word	0x0b0b0b38
  101414:	260b0b0b 	.word	0x260b0b0b
            dprintf(CRITICAL, "unhandled fault\n");
  101418:	f24c 0000 	movw	r0, #49152	; 0xc000
  10141c:	f2c0 0010 	movt	r0, #16
  101420:	f009 ff44 	bl	10b2ac <puts>
    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
  101424:	f24c 0010 	movw	r0, #49168	; 0xc010
  101428:	4631      	mov	r1, r6
  10142a:	f2c0 0010 	movt	r0, #16
  10142e:	f009 ff55 	bl	10b2dc <printf>
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);
  101432:	f24c 002c 	movw	r0, #49196	; 0xc02c
  101436:	4629      	mov	r1, r5
  101438:	f2c0 0010 	movt	r0, #16
  10143c:	f009 ff4e 	bl	10b2dc <printf>
    exception_die(frame, "halting\n");
  101440:	f24c 0150 	movw	r1, #49232	; 0xc050
  101444:	4620      	mov	r0, r4
  101446:	f2c0 0110 	movt	r1, #16
  10144a:	f7ff fecd 	bl	1011e8 <exception_die>
            dprintf(CRITICAL, "asynchronous external abort on %s\n", write ? "write" : "read");
  10144e:	f64b 7108 	movw	r1, #48904	; 0xbf08
  101452:	f64d 5394 	movw	r3, #56724	; 0xdd94
  101456:	f2c0 0310 	movt	r3, #16
  10145a:	f64b 70dc 	movw	r0, #49116	; 0xbfdc
  10145e:	f2c0 0110 	movt	r1, #16
  101462:	f2c0 0010 	movt	r0, #16
  101466:	2a00      	cmp	r2, #0
  101468:	bf08      	it	eq
  10146a:	4619      	moveq	r1, r3
  10146c:	f009 ff36 	bl	10b2dc <printf>
            break;
  101470:	e7d8      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "permission fault on %s\n", write ? "write" : "read");
  101472:	f64b 7108 	movw	r1, #48904	; 0xbf08
  101476:	f64d 5394 	movw	r3, #56724	; 0xdd94
  10147a:	f2c0 0310 	movt	r3, #16
  10147e:	f64b 7094 	movw	r0, #49044	; 0xbf94
  101482:	f2c0 0110 	movt	r1, #16
  101486:	f2c0 0010 	movt	r0, #16
  10148a:	2a00      	cmp	r2, #0
  10148c:	bf08      	it	eq
  10148e:	4619      	moveq	r1, r3
  101490:	f009 ff24 	bl	10b2dc <printf>
            break;
  101494:	e7c6      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  101496:	f64b 7078 	movw	r0, #49016	; 0xbf78
  10149a:	f3c5 1103 	ubfx	r1, r5, #4, #4
  10149e:	f2c0 0010 	movt	r0, #16
  1014a2:	f009 ff1b 	bl	10b2dc <printf>
            break;
  1014a6:	e7bd      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "synchronous external abort on %s\n", write ? "write" : "read");
  1014a8:	f64b 7108 	movw	r1, #48904	; 0xbf08
  1014ac:	f64d 5394 	movw	r3, #56724	; 0xdd94
  1014b0:	f2c0 0310 	movt	r3, #16
  1014b4:	f64b 70b8 	movw	r0, #49080	; 0xbfb8
  1014b8:	f2c0 0110 	movt	r1, #16
  1014bc:	f2c0 0010 	movt	r0, #16
  1014c0:	2a00      	cmp	r2, #0
  1014c2:	bf08      	it	eq
  1014c4:	4619      	moveq	r1, r3
  1014c6:	f009 ff09 	bl	10b2dc <printf>
            break;
  1014ca:	e7ab      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "translation fault on %s\n", write ? "write" : "read");
  1014cc:	f64b 7108 	movw	r1, #48904	; 0xbf08
  1014d0:	f64d 5394 	movw	r3, #56724	; 0xdd94
  1014d4:	f2c0 0310 	movt	r3, #16
  1014d8:	f64b 7040 	movw	r0, #48960	; 0xbf40
  1014dc:	f2c0 0110 	movt	r1, #16
  1014e0:	f2c0 0010 	movt	r0, #16
  1014e4:	2a00      	cmp	r2, #0
  1014e6:	bf08      	it	eq
  1014e8:	4619      	moveq	r1, r3
  1014ea:	f009 fef7 	bl	10b2dc <printf>
            break;
  1014ee:	e799      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "access flag fault on %s\n", write ? "write" : "read");
  1014f0:	f64b 7108 	movw	r1, #48904	; 0xbf08
  1014f4:	f64d 5394 	movw	r3, #56724	; 0xdd94
  1014f8:	f2c0 0310 	movt	r3, #16
  1014fc:	f64b 705c 	movw	r0, #48988	; 0xbf5c
  101500:	f2c0 0110 	movt	r1, #16
  101504:	f2c0 0010 	movt	r0, #16
  101508:	2a00      	cmp	r2, #0
  10150a:	bf08      	it	eq
  10150c:	4619      	moveq	r1, r3
  10150e:	f009 fee5 	bl	10b2dc <printf>
            break;
  101512:	e787      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "debug event\n");
  101514:	f64b 70ac 	movw	r0, #49068	; 0xbfac
  101518:	f2c0 0010 	movt	r0, #16
  10151c:	f009 fec6 	bl	10b2ac <puts>
            break;
  101520:	e780      	b.n	101424 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "alignment fault on %s\n", write ? "write" : "read");
  101522:	f64b 7108 	movw	r1, #48904	; 0xbf08
  101526:	f64d 5394 	movw	r3, #56724	; 0xdd94
  10152a:	f2c0 0310 	movt	r3, #16
  10152e:	f64b 7028 	movw	r0, #48936	; 0xbf28
  101532:	f2c0 0110 	movt	r1, #16
  101536:	f2c0 0010 	movt	r0, #16
  10153a:	2a00      	cmp	r2, #0
  10153c:	bf08      	it	eq
  10153e:	4619      	moveq	r1, r3
  101540:	f009 fecc 	bl	10b2dc <printf>
            break;
  101544:	e76e      	b.n	101424 <arm_data_abort_handler+0x98>
  101546:	bf00      	nop

00101548 <arm_prefetch_abort_handler>:

void arm_prefetch_abort_handler(struct arm_fault_frame *frame)
{
  101548:	b570      	push	{r4, r5, r6, r14}
  10154a:	4605      	mov	r5, r0
GEN_CP15_REG_FUNCS(ifsr, 0, c5, c0, 1);
  10154c:	ee15 4f30 	mrc	15, 0, r4, cr5, cr0, {1}
GEN_CP15_REG_FUNCS(ifar, 0, c6, c0, 2);
  101550:	ee16 6f50 	mrc	15, 0, r6, cr6, cr0, {2}
    uint32_t fsr = arm_read_ifsr();
    uint32_t far = arm_read_ifar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
  101554:	f24c 005c 	movw	r0, #49244	; 0xc05c
  101558:	2100      	movs	r1, #0
  10155a:	f2c0 0010 	movt	r0, #16
  10155e:	f009 febd 	bl	10b2dc <printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  101562:	09a3      	lsrs	r3, r4, #6
  101564:	f003 0310 	and.w	r3, r3, #16
  101568:	f004 020f 	and.w	r2, r4, #15
  10156c:	4313      	orrs	r3, r2

    /* decode the fault status (from table B3-23) */
    switch (fault_status) {
  10156e:	3b01      	subs	r3, #1
  101570:	2b15      	cmp	r3, #21
  101572:	d85a      	bhi.n	10162a <arm_prefetch_abort_handler+0xe2>
  101574:	e8df f003 	tbb	[r15, r3]
  101578:	59342d26 	.word	0x59342d26
  10157c:	423b343b 	.word	0x423b343b
  101580:	59495949 	.word	0x59495949
  101584:	59525952 	.word	0x59525952
  101588:	59595959 	.word	0x59595959
  10158c:	0b59      	.short	0x0b59
            break;
        case 0x08: // synchronous external abort
            dprintf(CRITICAL, "synchronous external abort\n");
            break;
        case 0x16: // asynchronous external abort
            dprintf(CRITICAL, "asynchronous external abort\n");
  10158e:	f24c 00e0 	movw	r0, #49376	; 0xc0e0
  101592:	f2c0 0010 	movt	r0, #16
  101596:	f009 fe89 	bl	10b2ac <puts>
        default:
            dprintf(CRITICAL, "unhandled fault\n");
            ;
    }

    dprintf(CRITICAL, "IFAR 0x%x (fault address)\n", far);
  10159a:	f24c 00fc 	movw	r0, #49404	; 0xc0fc
  10159e:	4631      	mov	r1, r6
  1015a0:	f2c0 0010 	movt	r0, #16
  1015a4:	f009 fe9a 	bl	10b2dc <printf>
    dprintf(CRITICAL, "IFSR 0x%x (fault status register)\n", fsr);
  1015a8:	f24c 1018 	movw	r0, #49432	; 0xc118
  1015ac:	4621      	mov	r1, r4
  1015ae:	f2c0 0010 	movt	r0, #16
  1015b2:	f009 fe93 	bl	10b2dc <printf>

    exception_die(frame, "halting\n");
  1015b6:	f24c 0150 	movw	r1, #49232	; 0xc050
  1015ba:	4628      	mov	r0, r5
  1015bc:	f2c0 0110 	movt	r1, #16
  1015c0:	f7ff fe12 	bl	1011e8 <exception_die>
            dprintf(CRITICAL, "alignment fault\n");
  1015c4:	f24c 0078 	movw	r0, #49272	; 0xc078
  1015c8:	f2c0 0010 	movt	r0, #16
  1015cc:	f009 fe6e 	bl	10b2ac <puts>
            break;
  1015d0:	e7e3      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "debug event\n");
  1015d2:	f64b 70ac 	movw	r0, #49068	; 0xbfac
  1015d6:	f2c0 0010 	movt	r0, #16
  1015da:	f009 fe67 	bl	10b2ac <puts>
            break;
  1015de:	e7dc      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "access flag fault\n");
  1015e0:	f24c 009c 	movw	r0, #49308	; 0xc09c
  1015e4:	f2c0 0010 	movt	r0, #16
  1015e8:	f009 fe60 	bl	10b2ac <puts>
            break;
  1015ec:	e7d5      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "translation fault\n");
  1015ee:	f24c 0088 	movw	r0, #49288	; 0xc088
  1015f2:	f2c0 0010 	movt	r0, #16
  1015f6:	f009 fe59 	bl	10b2ac <puts>
            break;
  1015fa:	e7ce      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "synchronous external abort\n");
  1015fc:	f24c 00c4 	movw	r0, #49348	; 0xc0c4
  101600:	f2c0 0010 	movt	r0, #16
  101604:	f009 fe52 	bl	10b2ac <puts>
            break;
  101608:	e7c7      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  10160a:	f64b 7078 	movw	r0, #49016	; 0xbf78
  10160e:	f3c4 1103 	ubfx	r1, r4, #4, #4
  101612:	f2c0 0010 	movt	r0, #16
  101616:	f009 fe61 	bl	10b2dc <printf>
            break;
  10161a:	e7be      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "permission fault\n");
  10161c:	f24c 00b0 	movw	r0, #49328	; 0xc0b0
  101620:	f2c0 0010 	movt	r0, #16
  101624:	f009 fe42 	bl	10b2ac <puts>
            break;
  101628:	e7b7      	b.n	10159a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "unhandled fault\n");
  10162a:	f24c 0000 	movw	r0, #49152	; 0xc000
  10162e:	f2c0 0010 	movt	r0, #16
  101632:	f009 fe3b 	bl	10b2ac <puts>
  101636:	e7b0      	b.n	10159a <arm_prefetch_abort_handler+0x52>

00101638 <arm_fpu_set_enable>:
}

void arm_fpu_set_enable(bool enable)
{
    /* set enable bit in fpexc */
    write_fpexc(enable ? (1<<30) : 0);
  101638:	2800      	cmp	r0, #0
  10163a:	bf14      	ite	ne
  10163c:	f04f 4380 	movne.w	r3, #1073741824	; 0x40000000
  101640:	2300      	moveq	r3, #0
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  101642:	eee8 3a10 	vmsr	fpexc, r3
}
  101646:	4770      	bx	r14

00101648 <arm_fpu_undefined_instruction>:

#if ARM_WITH_VFP
void arm_fpu_undefined_instruction(struct arm_iframe *frame)
{
  101648:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10164a:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  10164c:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    return (ipsr & IPSR_ISR_Msk);
#else
    /* set by the interrupt glue to track that the cpu is inside a handler */
    extern bool __arm_in_handler;

    return __arm_in_handler;
  101650:	f641 7498 	movw	r4, #8088	; 0x1f98
  101654:	f2c0 0411 	movt	r4, #17
    thread_t *t = get_current_thread();

    if (unlikely(arch_in_int_handler())) {
  101658:	7823      	ldrb	r3, [r4, #0]
  10165a:	b9b3      	cbnz	r3, 10168a <arm_fpu_undefined_instruction+0x42>
    }
false_alarm:

    LTRACEF("enabling fpu on thread %p\n", t);

    t->arch.fpused = true;
  10165c:	2301      	movs	r3, #1
  10165e:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

            arm_fpu_set_enable(false);
        }
    }

    if (newthread) {
  101662:	b16d      	cbz	r5, 101680 <arm_fpu_undefined_instruction+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  101664:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  101668:	eee8 3a10 	vmsr	fpexc, r3
        if (newthread->arch.fpused) {
            // load the new state
            arm_fpu_set_enable(true);
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
  10166c:	6bab      	ldr	r3, [r5, #56]	; 0x38
  10166e:	eee1 3a10 	vmsr	fpscr, r3

            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
  101672:	f105 0340 	add.w	r3, r5, #64	; 0x40
  101676:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  10167a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  10167c:	eee8 3a10 	vmsr	fpexc, r3
    frame->fpexc |= (1<<30);
  101680:	6833      	ldr	r3, [r6, #0]
  101682:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  101686:	6033      	str	r3, [r6, #0]
}
  101688:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "floating point code while some cpu is in irq context. pc 0x%x\n", frame->pc);
  10168a:	f24c 20b4 	movw	r0, #49844	; 0xc2b4
  10168e:	4677      	mov	r7, r14
  101690:	6a71      	ldr	r1, [r6, #36]	; 0x24
  101692:	f2c0 0010 	movt	r0, #16
  101696:	f009 fe21 	bl	10b2dc <printf>
        for (i = 0; i < 1000; i++) {
  10169a:	2100      	movs	r1, #0
  10169c:	7823      	ldrb	r3, [r4, #0]
            if (!arch_in_int_handler()) {
  10169e:	b15b      	cbz	r3, 1016b8 <arm_fpu_undefined_instruction+0x70>
        for (i = 0; i < 1000; i++) {
  1016a0:	3101      	adds	r1, #1
  1016a2:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
  1016a6:	d1fa      	bne.n	10169e <arm_fpu_undefined_instruction+0x56>
        panic("floating point code in irq context. pc 0x%x\n", frame->pc);
  1016a8:	f24c 3128 	movw	r1, #49960	; 0xc328
  1016ac:	4638      	mov	r0, r7
  1016ae:	6a72      	ldr	r2, [r6, #36]	; 0x24
  1016b0:	f2c0 0110 	movt	r1, #16
  1016b4:	f008 fdde 	bl	10a274 <_panic>
                dprintf(CRITICAL, "arch_in_int_handler status cleared after %d reads\n", i);
  1016b8:	f24c 20f4 	movw	r0, #49908	; 0xc2f4
  1016bc:	f2c0 0010 	movt	r0, #16
  1016c0:	f009 fe0c 	bl	10b2dc <printf>
                goto false_alarm;
  1016c4:	e7ca      	b.n	10165c <arm_fpu_undefined_instruction+0x14>
  1016c6:	bf00      	nop

001016c8 <mpu_add_region>:
    return false;
}
#endif
void mpu_add_region(int region, uint32_t base, uint64_t size,
                    mpu_region_type_e type)
{
  1016c8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1016cc:	b083      	sub	sp, #12
  1016ce:	46f3      	mov	r11, r14
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016d0:	f1b0 0a00 	subs.w	r10, r0, #0
{
  1016d4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016d6:	db4d      	blt.n	101774 <mpu_add_region+0xac>
  1016d8:	460f      	mov	r7, r1

GEN_CP15_REG_FUNCS(l2ctlr, 1, c9, c0, 2);
GEN_CP15_REG_FUNCS(l2ectlr, 1, c9, c0, 3);

/* mpu registers (using unified memory regions) */
GEN_CP15_REG_FUNCS(mpuir, 0, c0, c0, 4);
  1016da:	ee10 1f90 	mrc	15, 0, r1, cr0, cr0, {4}
    return (int)BITS_SHIFT(val, 15, 8);   /* 0, 12 or 16 */
  1016de:	f3c1 2107 	ubfx	r1, r1, #8, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
  1016e2:	458a      	cmp	r10, r1
  1016e4:	da46      	bge.n	101774 <mpu_add_region+0xac>
  1016e6:	4614      	mov	r4, r2
    ASSERT((size & (size - 1)) == 0 &&
  1016e8:	f112 38ff 	adds.w	r8, r2, #4294967295	; 0xffffffff
  1016ec:	f143 39ff 	adc.w	r9, r3, #4294967295	; 0xffffffff
  1016f0:	ea08 0002 	and.w	r0, r8, r2
  1016f4:	461d      	mov	r5, r3
  1016f6:	ea09 0103 	and.w	r1, r9, r3
  1016fa:	4301      	orrs	r1, r0
  1016fc:	d14b      	bne.n	101796 <mpu_add_region+0xce>
  1016fe:	f04f 0900 	mov.w	r9, #0
  101702:	f1b2 0020 	subs.w	r0, r2, #32
  101706:	f143 31ff 	adc.w	r1, r3, #4294967295	; 0xffffffff
  10170a:	f06f 081f 	mvn.w	r8, #31
  10170e:	4589      	cmp	r9, r1
  101710:	bf08      	it	eq
  101712:	4580      	cmpeq	r8, r0
  101714:	d33f      	bcc.n	101796 <mpu_add_region+0xce>
           size >= 32ull &&
           size <= 4ull * 1024 * 1024 * 1024);
    ASSERT(base % size == 0);
  101716:	4638      	mov	r0, r7
  101718:	2100      	movs	r1, #0
  10171a:	f00a fa9d 	bl	10bc58 <__aeabi_uldivmod>
  10171e:	4313      	orrs	r3, r2
  101720:	d14a      	bne.n	1017b8 <mpu_add_region+0xf0>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  101722:	2e05      	cmp	r6, #5
  101724:	d859      	bhi.n	1017da <mpu_add_region+0x112>
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
  101726:	fab5 f385 	clz	r3, r5
  10172a:	b1fd      	cbz	r5, 10176c <mpu_add_region+0xa4>
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
GEN_CP15_REG_FUNCS(rgnr, 0, c6, c2, 0);
  10172c:	ee06 af12 	mcr	15, 0, r10, cr6, cr2, {0}
  101730:	f3bf 8f6f 	isb	sy
    /* Calculate size field of RSR register.
     *  pow(2, sz + 1) = size
     */
    uint32_t sz = (uint32_t)log2ull(size) - 1;
    arm_write_rgnr(region);
    arm_write_rbar(base & MPU_RBAR_MASK);
  101734:	f027 071f 	bic.w	r7, r7, #31
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
  101738:	ee06 7f11 	mcr	15, 0, r7, cr6, cr1, {0}
  10173c:	f3bf 8f6f 	isb	sy
    arm_write_racr(g_racr_config[type]);
  101740:	f24c 3258 	movw	r2, #50008	; 0xc358
  101744:	f2c0 0210 	movt	r2, #16
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
  101748:	f852 2026 	ldr.w	r2, [r2, r6, lsl #2]
  10174c:	ee06 2f91 	mcr	15, 0, r2, cr6, cr1, {4}
  101750:	f3bf 8f6f 	isb	sy
    uint32_t sz = (uint32_t)log2ull(size) - 1;
  101754:	f1c3 033e 	rsb	r3, r3, #62	; 0x3e
    /* TODO - support sub regions? */
    arm_write_rsr((sz << RSR_SIZE_SHIFT) | RSR_EN);
  101758:	005b      	lsls	r3, r3, #1
  10175a:	f043 0301 	orr.w	r3, r3, #1
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
  10175e:	ee06 3f51 	mcr	15, 0, r3, cr6, cr1, {2}
  101762:	f3bf 8f6f 	isb	sy
    if (type != MPU_REGION_NORMAL) {
        add_region(base, size);
    }

#endif
}
  101766:	b003      	add	sp, #12
  101768:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
  10176c:	fab4 f384 	clz	r3, r4
  101770:	3320      	adds	r3, #32
  101772:	e7db      	b.n	10172c <mpu_add_region+0x64>
    ASSERT(region >= 0 && region < mpu_region_nr());
  101774:	f24c 3384 	movw	r3, #50052	; 0xc384
  101778:	f24c 3270 	movw	r2, #50032	; 0xc370
  10177c:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  101780:	f2c0 0310 	movt	r3, #16
  101784:	4658      	mov	r0, r11
  101786:	f2c0 0210 	movt	r2, #16
  10178a:	9300      	str	r3, [sp, #0]
  10178c:	f2c0 0110 	movt	r1, #16
  101790:	239c      	movs	r3, #156	; 0x9c
  101792:	f008 fd6f 	bl	10a274 <_panic>
    ASSERT((size & (size - 1)) == 0 &&
  101796:	f24c 33ac 	movw	r3, #50092	; 0xc3ac
  10179a:	f24c 3270 	movw	r2, #50032	; 0xc370
  10179e:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1017a2:	f2c0 0310 	movt	r3, #16
  1017a6:	4658      	mov	r0, r11
  1017a8:	f2c0 0210 	movt	r2, #16
  1017ac:	9300      	str	r3, [sp, #0]
  1017ae:	f2c0 0110 	movt	r1, #16
  1017b2:	239f      	movs	r3, #159	; 0x9f
  1017b4:	f008 fd5e 	bl	10a274 <_panic>
    ASSERT(base % size == 0);
  1017b8:	f24c 33fc 	movw	r3, #50172	; 0xc3fc
  1017bc:	f24c 3270 	movw	r2, #50032	; 0xc370
  1017c0:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1017c4:	f2c0 0310 	movt	r3, #16
  1017c8:	4658      	mov	r0, r11
  1017ca:	f2c0 0210 	movt	r2, #16
  1017ce:	9300      	str	r3, [sp, #0]
  1017d0:	f2c0 0110 	movt	r1, #16
  1017d4:	23a0      	movs	r3, #160	; 0xa0
  1017d6:	f008 fd4d 	bl	10a274 <_panic>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  1017da:	f24c 4310 	movw	r3, #50192	; 0xc410
  1017de:	f24c 3270 	movw	r2, #50032	; 0xc370
  1017e2:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1017e6:	f2c0 0310 	movt	r3, #16
  1017ea:	4658      	mov	r0, r11
  1017ec:	f2c0 0210 	movt	r2, #16
  1017f0:	9300      	str	r3, [sp, #0]
  1017f2:	f2c0 0110 	movt	r1, #16
  1017f6:	23a1      	movs	r3, #161	; 0xa1
  1017f8:	f008 fd3c 	bl	10a274 <_panic>

001017fc <mpu_enable>:
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
  1017fc:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
 */
void mpu_enable(bool enable)
{
    uint32_t val = arm_read_sctlr();

    if (enable)
  101800:	b930      	cbnz	r0, 101810 <mpu_enable+0x14>
         */
    {
        val |= SCTLR_BR | SCTLR_M;
    }
    else {
        val &= ~SCTLR_M;
  101802:	f023 0301 	bic.w	r3, r3, #1
  101806:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  10180a:	f3bf 8f6f 	isb	sy
    }

    arm_write_sctlr(val);
}
  10180e:	4770      	bx	r14
        val |= SCTLR_BR | SCTLR_M;
  101810:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  101814:	f043 0301 	orr.w	r3, r3, #1
  101818:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  10181c:	f3bf 8f6f 	isb	sy
}
  101820:	4770      	bx	r14
  101822:	bf00      	nop

00101824 <arch_invalidate_cache_range>:
        _f##_asm(start, len);   \
    }

CACHE_OPS(arch_clean_cache_range)
CACHE_OPS(arch_clean_invalidate_cache_range)
CACHE_OPS(arch_invalidate_cache_range)
  101824:	eafffcb7 	b	100b08 <arch_invalidate_cache_range_asm>

00101828 <arch_early_init>:
CACHE_OPS(arch_sync_cache_range)

void arch_early_init(void)
{
  101828:	e92d4010 	push	{r4, r14}
    /* turn off the cache */
    arch_disable_cache(UCACHE);
  10182c:	e3a00003 	mov	r0, #3
  101830:	ebfffc2a 	bl	1008e0 <arch_disable_cache>
  101834:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
    sctlr |= (1 << 11); /* enable program flow prediction */
    sctlr &= ~(1 << 14); /* random cache/tlb replacement */
    sctlr &= ~(1 << 25); /* E bit set to 0 on exception */
    sctlr &= ~(1 << 30); /* no thumb exceptions */
    sctlr |= (1 << 22); /* enable unaligned access */
    sctlr &= ~(1 << 1); /* disable alignment abort */
  101838:	e30b3bfd 	movw	r3, #48125	; 0xbbfd
  10183c:	e34b3dff 	movt	r3, #48639	; 0xbdff
  101840:	e0033002 	and	r3, r3, r2
  101844:	e3833501 	orr	r3, r3, #4194304	; 0x400000
  101848:	e3833b02 	orr	r3, r3, #2048	; 0x800
  10184c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
  101850:	f57ff06f 	isb	sy
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  101854:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
  101858:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
  10185c:	f57ff06f 	isb	sy
#endif // ARM_CPU_CORTEX_A7
    arm_write_actlr(actlr);
#if ENABLE_CYCLE_COUNTER && ARM_ISA_ARMV7
    /* enable the cycle count register */
    uint32_t en;
    __asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r"(en));
  101860:	ee193f1c 	mrc	15, 0, r3, cr9, cr12, {0}
    en &= ~(1 << 3); /* cycle count every cycle */
  101864:	e3c33008 	bic	r3, r3, #8
    en |= 1; /* enable all performance counters */
  101868:	e3833001 	orr	r3, r3, #1
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r"(en));
  10186c:	ee093f1c 	mcr	15, 0, r3, cr9, cr12, {0}
    /* enable cycle counter */
    en = (1 << 31);
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r"(en));
  101870:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  101874:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
GEN_CP15_REG_FUNCS(cpacr, 0, c1, c0, 2);
  101878:	ee113f50 	mrc	15, 0, r3, cr1, cr0, {2}
#endif
#if ARM_WITH_VFP
    /* enable cp10 and cp11 */
    uint32_t val = arm_read_cpacr();
    val |= (3 << 22) | (3 << 20);
  10187c:	e383360f 	orr	r3, r3, #15728640	; 0xf00000
  101880:	ee013f50 	mcr	15, 0, r3, cr1, cr0, {2}
  101884:	f57ff06f 	isb	sy
    arm_write_cpacr(val);
    /* set enable bit in fpexc */
    __asm__ volatile("mrc  p10, 7, %0, c8, c0, 0" : "=r"(val));
  101888:	eef83a10 	vmrs	r3, fpexc
    val |= (1 << 30);
  10188c:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r"(val));
  101890:	eee83a10 	vmsr	fpexc, r3
    /* make sure the fpu starts off disabled */
    arm_fpu_set_enable(false);
  101894:	e3a00000 	mov	r0, #0
  101898:	faffff66 	blx	101638 <arm_fpu_set_enable>
    arch_enable_cache(UCACHE);
  10189c:	e3a00003 	mov	r0, #3
}
  1018a0:	e8bd4010 	pop	{r4, r14}
    arch_enable_cache(UCACHE);
  1018a4:	eafffc24 	b	10093c <arch_enable_cache>

001018a8 <arch_init>:
}
  1018a8:	e12fff1e 	bx	r14

001018ac <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
  1018ac:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1018b0:	b083      	sub	sp, #12
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
  1018b2:	2900      	cmp	r1, #0
  1018b4:	d051      	beq.n	10195a <lk_init_level+0xae>
  1018b6:	f641 781c 	movw	r8, #7964	; 0x1f1c
  1018ba:	f641 768c 	movw	r6, #8076	; 0x1f8c
  1018be:	f2c0 0811 	movt	r8, #17
  1018c2:	4691      	mov	r9, r2
  1018c4:	f2c0 0611 	movt	r6, #17
  1018c8:	4683      	mov	r11, r0
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  1018ca:	45b0      	cmp	r8, r6
  1018cc:	468a      	mov	r10, r1
    uint last_called_level = start_level - 1;
  1018ce:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    const struct lk_init_struct *last = NULL;
  1018d2:	f04f 0500 	mov.w	r5, #0
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  1018d6:	d03b      	beq.n	101950 <lk_init_level+0xa4>
  1018d8:	f641 731c 	movw	r3, #7964	; 0x1f1c
        bool seen_last = false;
  1018dc:	2400      	movs	r4, #0
        const struct lk_init_struct *found = NULL;
  1018de:	4621      	mov	r1, r4
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  1018e0:	f2c0 0311 	movt	r3, #17
  1018e4:	e002      	b.n	1018ec <lk_init_level+0x40>
  1018e6:	3310      	adds	r3, #16
  1018e8:	42b3      	cmp	r3, r6
  1018ea:	d029      	beq.n	101940 <lk_init_level+0x94>

            if (ptr == last)
                seen_last = true;

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
  1018ec:	6858      	ldr	r0, [r3, #4]
                seen_last = true;
  1018ee:	429d      	cmp	r5, r3
  1018f0:	bf08      	it	eq
  1018f2:	2401      	moveq	r4, #1
            if (!(ptr->flags & required_flag))
  1018f4:	ea1b 0f00 	tst.w	r11, r0
  1018f8:	d0f5      	beq.n	1018e6 <lk_init_level+0x3a>
                continue;
            if (ptr->level > stop_level)
  1018fa:	6818      	ldr	r0, [r3, #0]
                continue;
            if (ptr->level < last_called_level)
  1018fc:	4548      	cmp	r0, r9
  1018fe:	bf98      	it	ls
  101900:	4282      	cmpls	r2, r0
  101902:	d8f0      	bhi.n	1018e6 <lk_init_level+0x3a>
                continue;
            if (found && found->level <= ptr->level)
  101904:	b111      	cbz	r1, 10190c <lk_init_level+0x60>
  101906:	680f      	ldr	r7, [r1, #0]
  101908:	42b8      	cmp	r0, r7
  10190a:	d2ec      	bcs.n	1018e6 <lk_init_level+0x3a>
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
  10190c:	4282      	cmp	r2, r0
  10190e:	bf34      	ite	cc
  101910:	f04f 0c01 	movcc.w	r12, #1
  101914:	f04f 0c00 	movcs.w	r12, #0
  101918:	4550      	cmp	r0, r10
  10191a:	bf38      	it	cc
  10191c:	f04f 0c00 	movcc.w	r12, #0
  101920:	f1bc 0f00 	cmp.w	r12, #0
  101924:	d117      	bne.n	101956 <lk_init_level+0xaa>

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
  101926:	4282      	cmp	r2, r0
  101928:	d1dd      	bne.n	1018e6 <lk_init_level+0x3a>
  10192a:	429d      	cmp	r5, r3
  10192c:	bf0c      	ite	eq
  10192e:	f04f 0c00 	moveq.w	r12, #0
  101932:	f004 0c01 	andne.w	r12, r4, #1
  101936:	f1bc 0f00 	cmp.w	r12, #0
  10193a:	d0d4      	beq.n	1018e6 <lk_init_level+0x3a>
  10193c:	461d      	mov	r5, r3
  10193e:	e002      	b.n	101946 <lk_init_level+0x9a>
                found = ptr;
                break;
            }
        }

        if (!found)
  101940:	b131      	cbz	r1, 101950 <lk_init_level+0xa4>
  101942:	6808      	ldr	r0, [r1, #0]
  101944:	460d      	mov	r5, r1
        if (found->level >= EARLIEST_TRACE_LEVEL && (required_flag & TRACE_INIT_FLAGS)) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
  101946:	68ab      	ldr	r3, [r5, #8]
  101948:	4798      	blx	r3
        last_called_level = found->level;
  10194a:	682a      	ldr	r2, [r5, #0]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  10194c:	45b0      	cmp	r8, r6
  10194e:	d1c3      	bne.n	1018d8 <lk_init_level+0x2c>
        last = found;
    }
}
  101950:	b003      	add	sp, #12
  101952:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  101956:	4619      	mov	r1, r3
  101958:	e7c5      	b.n	1018e6 <lk_init_level+0x3a>
    ASSERT(start_level > 0);
  10195a:	f24c 4358 	movw	r3, #50264	; 0xc458
  10195e:	f24c 424c 	movw	r2, #50252	; 0xc44c
  101962:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  101966:	f2c0 0310 	movt	r3, #16
  10196a:	4670      	mov	r0, r14
  10196c:	f2c0 0210 	movt	r2, #16
  101970:	9300      	str	r3, [sp, #0]
  101972:	f2c0 0110 	movt	r1, #16
  101976:	2334      	movs	r3, #52	; 0x34
  101978:	f008 fc7c 	bl	10a274 <_panic>

0010197c <lk_main>:

/* called from arch code */
void lk_main(ulong arg0, ulong arg1, ulong arg2, ulong arg3)
{
    // save the boot args
    lk_boot_args[0] = arg0;
  10197c:	f645 6420 	movw	r4, #24096	; 0x5e20
  101980:	f2c0 0411 	movt	r4, #17
{
  101984:	b500      	push	{r14}
    lk_boot_args[1] = arg1;
  101986:	6061      	str	r1, [r4, #4]

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level)
{
    lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
  101988:	2101      	movs	r1, #1
    lk_boot_args[0] = arg0;
  10198a:	6020      	str	r0, [r4, #0]
{
  10198c:	b083      	sub	sp, #12
    lk_boot_args[2] = arg2;
  10198e:	60a2      	str	r2, [r4, #8]
  101990:	4608      	mov	r0, r1
    lk_boot_args[3] = arg3;
  101992:	60e3      	str	r3, [r4, #12]
  101994:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101998:	f7ff ff88 	bl	1018ac <lk_init_level>

    // early arch stuff
    lk_primary_cpu_init_level(LK_INIT_LEVEL_EARLIEST, LK_INIT_LEVEL_ARCH_EARLY - 1);
    arch_early_init();
  10199c:	f7ff ef44 	blx	101828 <arch_early_init>
  1019a0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019a4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  1019a8:	2001      	movs	r0, #1
  1019aa:	f2c0 0201 	movt	r2, #1
  1019ae:	f7ff ff7d 	bl	1018ac <lk_init_level>

    // do any super early platform initialization
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH_EARLY, LK_INIT_LEVEL_PLATFORM_EARLY - 1);
    platform_early_init();
  1019b2:	f7fe fcf3 	bl	10039c <platform_early_init>
  1019b6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019ba:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  1019be:	2001      	movs	r0, #1
  1019c0:	f2c0 0202 	movt	r2, #2
  1019c4:	f7ff ff72 	bl	1018ac <lk_init_level>

    // do any super early target initialization
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_LEVEL_TARGET_EARLY - 1);
    target_early_init();
  1019c8:	f7fe fbe6 	bl	100198 <target_early_init>
  1019cc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  1019d0:	f44f 3140 	mov.w	r1, #196608	; 0x30000
  1019d4:	2001      	movs	r0, #1
  1019d6:	f2c0 0203 	movt	r2, #3
  1019da:	f7ff ff67 	bl	1018ac <lk_init_level>
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  1019de:	f644 12d8 	movw	r2, #18904	; 0x49d8
  1019e2:	f644 13d8 	movw	r3, #18904	; 0x49d8
  1019e6:	f2c0 0211 	movt	r2, #17
  1019ea:	f2c0 0311 	movt	r3, #17
  1019ee:	429a      	cmp	r2, r3
  1019f0:	d00b      	beq.n	101a0a <lk_main+0x8e>
  1019f2:	4615      	mov	r5, r2
  1019f4:	1d14      	adds	r4, r2, #4
  1019f6:	1b1c      	subs	r4, r3, r4
  1019f8:	f024 0403 	bic.w	r4, r4, #3
  1019fc:	3404      	adds	r4, #4
  1019fe:	4414      	add	r4, r2
        (*ctor)();
  101a00:	f855 3b04 	ldr.w	r3, [r5], #4
  101a04:	4798      	blx	r3
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  101a06:	42a5      	cmp	r5, r4
  101a08:	d1fa      	bne.n	101a00 <lk_main+0x84>
  101a0a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a0e:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  101a12:	2001      	movs	r0, #1
  101a14:	f2c0 0205 	movt	r2, #5
  101a18:	f7ff ff48 	bl	1018ac <lk_init_level>
  101a1c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a20:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
  101a24:	f2c0 0206 	movt	r2, #6
  101a28:	2001      	movs	r0, #1
  101a2a:	f7ff ff3f 	bl	1018ac <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_KERNEL, LK_INIT_LEVEL_THREADING - 1);

    // create a thread to complete system initialization
    dprintf(SPEW, "creating bootstrap completion thread\n");
    thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
  101a2e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  101a32:	f641 2161 	movw	r1, #6753	; 0x1a61
  101a36:	f24c 4068 	movw	r0, #50280	; 0xc468
  101a3a:	2200      	movs	r2, #0
  101a3c:	f2c0 0110 	movt	r1, #16
  101a40:	9300      	str	r3, [sp, #0]
  101a42:	f2c0 0010 	movt	r0, #16
  101a46:	2310      	movs	r3, #16
  101a48:	f009 fd80 	bl	10b54c <thread_create>
  101a4c:	4604      	mov	r4, r0
    thread_set_pinned_cpu(t, 0);
    thread_detach(t);
  101a4e:	f009 fe03 	bl	10b658 <thread_detach>
    thread_resume(t);
  101a52:	4620      	mov	r0, r4
  101a54:	f009 fdd6 	bl	10b604 <thread_resume>
    vTaskStartScheduler();
  101a58:	f007 fe48 	bl	1096ec <vTaskStartScheduler>
  101a5c:	e7fe      	b.n	101a5c <lk_main+0xe0>
  101a5e:	bf00      	nop

00101a60 <bootstrap2>:
  101a60:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a64:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
    // become the idle thread and enable interrupts to start the scheduler
    thread_become_idle();
}

static int bootstrap2(void *arg)
{
  101a68:	b508      	push	{r3, r14}
  101a6a:	2001      	movs	r0, #1
  101a6c:	f2c0 0207 	movt	r2, #7
  101a70:	f7ff ff1c 	bl	1018ac <lk_init_level>
    dprintf(SPEW, "top of bootstrap2()\n");

    lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
    arch_init();
  101a74:	f7ff ef18 	blx	1018a8 <arch_init>
  101a78:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a7c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  101a80:	2001      	movs	r0, #1
  101a82:	f2c0 0208 	movt	r2, #8
  101a86:	f7ff ff11 	bl	1018ac <lk_init_level>

    // initialize the rest of the platform
    dprintf(SPEW, "initializing platform\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
    platform_init();
  101a8a:	f7fe fd33 	bl	1004f4 <platform_init>
  101a8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101a92:	f44f 2110 	mov.w	r1, #589824	; 0x90000
  101a96:	2001      	movs	r0, #1
  101a98:	f2c0 0209 	movt	r2, #9
  101a9c:	f7ff ff06 	bl	1018ac <lk_init_level>

    // initialize the target
    dprintf(SPEW, "initializing target\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
    target_init();
  101aa0:	f7fe fb7c 	bl	10019c <target_init>
  101aa4:	f64f 72ff 	movw	r2, #65535	; 0xffff
  101aa8:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
  101aac:	2001      	movs	r0, #1
  101aae:	f2c0 020a 	movt	r2, #10
  101ab2:	f7ff fefb 	bl	1018ac <lk_init_level>

    dprintf(SPEW, "calling apps_init()\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
    apps_init();
  101ab6:	f008 fb7b 	bl	10a1b0 <apps_init>
  101aba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  101abe:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
  101ac2:	2001      	movs	r0, #1
  101ac4:	f7ff fef2 	bl	1018ac <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

    return 0;
}
  101ac8:	2000      	movs	r0, #0
  101aca:	bd08      	pop	{r3, r15}

00101acc <soc_global_rst>:
    rstgen_module_ctl(ospic_addr, idx, false);
    rstgen_module_ctl(ospic_addr, idx, true);
}

void soc_global_rst(void)
{
  101acc:	b510      	push	{r4, r14}
    int idx = 0;
    if(!rstgenc_addr)
  101ace:	f645 6434 	movw	r4, #24116	; 0x5e34
{
  101ad2:	b082      	sub	sp, #8
    int idx = 0;
  101ad4:	2300      	movs	r3, #0
    if(!rstgenc_addr)
  101ad6:	f2c0 0411 	movt	r4, #17
    int idx = 0;
  101ada:	9301      	str	r3, [sp, #4]
    if(!rstgenc_addr)
  101adc:	6820      	ldr	r0, [r4, #0]
  101ade:	b940      	cbnz	r0, 101af2 <soc_global_rst+0x26>
    {
        res_get_info_by_id(RES_GLOBAL_RST_SAF_RST_EN, &rstgenc_addr, &idx);
  101ae0:	f44f 6080 	mov.w	r0, #1024	; 0x400
  101ae4:	aa01      	add	r2, sp, #4
  101ae6:	4621      	mov	r1, r4
  101ae8:	f2c8 2096 	movt	r0, #33430	; 0x8296
  101aec:	f005 fc56 	bl	10739c <res_get_info_by_id>
  101af0:	6820      	ldr	r0, [r4, #0]
    }

    rstgen_global_rst_enable(rstgenc_addr,1);
  101af2:	2101      	movs	r1, #1
  101af4:	f003 fd62 	bl	1055bc <rstgen_global_rst_enable>
    rstgen_sw_self_rst(rstgenc_addr,false);
  101af8:	6820      	ldr	r0, [r4, #0]
  101afa:	2100      	movs	r1, #0
  101afc:	f003 fd74 	bl	1055e8 <rstgen_sw_self_rst>
    rstgen_sw_self_rst(rstgenc_addr,true);
  101b00:	6820      	ldr	r0, [r4, #0]
  101b02:	2101      	movs	r1, #1
  101b04:	f003 fd70 	bl	1055e8 <rstgen_sw_self_rst>

}
  101b08:	b002      	add	sp, #8
  101b0a:	bd10      	pop	{r4, r15}

00101b0c <ospi_handover_entry>:
	hal_clock_release_handle(g_saf_handle);
}
#endif

void ospi_handover_entry(void)
{
  101b0c:	b530      	push	{r4, r5, r14}
    int idx = 0;
  101b0e:	2300      	movs	r3, #0
{
  101b10:	b083      	sub	sp, #12
    res_get_info_by_id(RES_GLOBAL_RST_SAF_RST_EN, &rstgenc_addr, &idx);
  101b12:	f645 6134 	movw	r1, #24116	; 0x5e34
    int idx = 0;
  101b16:	ad02      	add	r5, sp, #8
    res_get_info_by_id(RES_GLOBAL_RST_SAF_RST_EN, &rstgenc_addr, &idx);
  101b18:	f44f 6080 	mov.w	r0, #1024	; 0x400
  101b1c:	f2c0 0111 	movt	r1, #17
    int idx = 0;
  101b20:	f845 3d08 	str.w	r3, [r5, #-8]!
    res_get_info_by_id(RES_GLOBAL_RST_SAF_RST_EN, &rstgenc_addr, &idx);
  101b24:	f2c8 2096 	movt	r0, #33430	; 0x8296
  101b28:	462a      	mov	r2, r5
    res_get_info_by_id(RES_MODULE_RST_SAF_OSPI1, &ospic_addr, &idx);
  101b2a:	f645 6430 	movw	r4, #24112	; 0x5e30
    res_get_info_by_id(RES_GLOBAL_RST_SAF_RST_EN, &rstgenc_addr, &idx);
  101b2e:	f005 fc35 	bl	10739c <res_get_info_by_id>
    res_get_info_by_id(RES_MODULE_RST_SAF_OSPI1, &ospic_addr, &idx);
  101b32:	f240 4041 	movw	r0, #1089	; 0x441
  101b36:	462a      	mov	r2, r5
  101b38:	f2c0 0411 	movt	r4, #17
  101b3c:	4621      	mov	r1, r4
  101b3e:	f2c8 2096 	movt	r0, #33430	; 0x8296
  101b42:	f005 fc2b 	bl	10739c <res_get_info_by_id>
    dprintf(ALWAYS,"%s handover ospi to secure core E\n", __func__);
  101b46:	f24c 4174 	movw	r1, #50292	; 0xc474
  101b4a:	f24c 4088 	movw	r0, #50312	; 0xc488
  101b4e:	f2c0 0110 	movt	r1, #16
  101b52:	f2c0 0010 	movt	r0, #16
  101b56:	f009 fbc1 	bl	10b2dc <printf>

    __asm__ volatile("cpsid if"); //disable interrupt to avoid crash while ospi handover
  101b5a:	b673      	cpsid	if
    if(ospic_addr)
  101b5c:	6820      	ldr	r0, [r4, #0]

    ospi_modules_rst(idx);
  101b5e:	9900      	ldr	r1, [sp, #0]
  101b60:	9101      	str	r1, [sp, #4]
    if(ospic_addr)
  101b62:	b148      	cbz	r0, 101b78 <ospi_handover_entry+0x6c>
        res_get_info_by_id(RES_MODULE_RST_SAF_OSPI1, &ospic_addr, &idx);
  101b64:	f240 4041 	movw	r0, #1089	; 0x441
  101b68:	4621      	mov	r1, r4
  101b6a:	aa01      	add	r2, sp, #4
  101b6c:	f2c8 2096 	movt	r0, #33430	; 0x8296
  101b70:	f005 fc14 	bl	10739c <res_get_info_by_id>
  101b74:	6820      	ldr	r0, [r4, #0]
  101b76:	9901      	ldr	r1, [sp, #4]
    rstgen_module_ctl(ospic_addr, idx, false);
  101b78:	2200      	movs	r2, #0
  101b7a:	f003 fdb9 	bl	1056f0 <rstgen_module_ctl>
    rstgen_module_ctl(ospic_addr, idx, true);
  101b7e:	6820      	ldr	r0, [r4, #0]
  101b80:	9901      	ldr	r1, [sp, #4]
  101b82:	2201      	movs	r2, #1
  101b84:	f003 fdb4 	bl	1056f0 <rstgen_module_ctl>
    //writel(0x3FFF,  APB_SCR_SAF_BASE + (0x200 <<10));
    //writel(0x7FFF,  APB_SCR_SAF_BASE + (0x204 <<10));
    //writel(0xEFFF,  APB_SCR_SAF_BASE + (0x208 <<10));
    //writel(0x7FF,  APB_SCR_SAF_BASE + (0x20C <<10));
#else
    RMWREG32(APB_SCR_SAF_BASE + (0x200 <<10), 3, 1, 1);
  101b88:	2000      	movs	r0, #0
    RMWREG32(APB_SCR_SAF_BASE + (0x208 <<10), 13, 1, 1);
  101b8a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    RMWREG32(APB_SCR_SAF_BASE + (0x200 <<10), 3, 1, 1);
  101b8e:	f6cf 4028 	movt	r0, #64552	; 0xfc28

static inline void sdrv_common_reg_set_value(uint32_t reg, uint32_t value,
        uint32_t mask)
{
    uint32_t tmp_value;
    tmp_value = readl(_ioaddr(SDRV_GENERAL_REG(reg))) & ~mask;
  101b92:	f44f 4120 	mov.w	r1, #40960	; 0xa000
    RMWREG32(APB_SCR_SAF_BASE + (0x208 <<10), 13, 1, 1);
  101b96:	f6cf 4328 	movt	r3, #64552	; 0xfc28
    return readl(_ioaddr(SDRV_GENERAL_REG(reg))) & mask;
  101b9a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    tmp_value = readl(_ioaddr(SDRV_GENERAL_REG(reg))) & ~mask;
  101b9e:	f6cf 0141 	movt	r1, #63553	; 0xf841
    RMWREG32(APB_SCR_SAF_BASE + (0x200 <<10), 3, 1, 1);
  101ba2:	6804      	ldr	r4, [r0, #0]
    return readl(_ioaddr(SDRV_GENERAL_REG(reg))) & mask;
  101ba4:	f6cf 0241 	movt	r2, #63553	; 0xf841
  101ba8:	f044 0408 	orr.w	r4, r4, #8
  101bac:	6004      	str	r4, [r0, #0]
    RMWREG32(APB_SCR_SAF_BASE + (0x208 <<10), 13, 1, 1);
  101bae:	6818      	ldr	r0, [r3, #0]
  101bb0:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
  101bb4:	6018      	str	r0, [r3, #0]
    tmp_value = readl(_ioaddr(SDRV_GENERAL_REG(reg))) & ~mask;
  101bb6:	6808      	ldr	r0, [r1, #0]
    tmp_value |= value & mask;
  101bb8:	43c3      	mvns	r3, r0
  101bba:	f003 0320 	and.w	r3, r3, #32
  101bbe:	4043      	eors	r3, r0
    writel(tmp_value, _ioaddr(SDRV_GENERAL_REG(reg)));
  101bc0:	600b      	str	r3, [r1, #0]
    return readl(_ioaddr(SDRV_GENERAL_REG(reg))) & mask;
  101bc2:	6813      	ldr	r3, [r2, #0]
  101bc4:	f003 030f 	and.w	r3, r3, #15
#endif
    // RMWREG32(ROMC_STICKY_REG, STICKY_SAFE_RPC_DSEL, STICKY_SAFE_RPC_DSEL_WIDTH, 1);

    sdrv_common_reg_set_value(SDRV_REG_STATUS,SDRV_REG_STATUS_HANDOVER_DONE,SDRV_REG_STATUS_HANDOVER_DONE);

    while(sdrv_common_reg_get_value(SDRV_REG_BOOTREASON,0x0000000F) != HALT_REASON_SW_RESET);
  101bc8:	2b07      	cmp	r3, #7
  101bca:	d1fa      	bne.n	101bc2 <ospi_handover_entry+0xb6>
    tmp_value = readl(_ioaddr(SDRV_GENERAL_REG(reg))) & ~mask;
  101bcc:	6813      	ldr	r3, [r2, #0]
    writel(tmp_value, _ioaddr(SDRV_GENERAL_REG(reg)));
  101bce:	6013      	str	r3, [r2, #0]

    sdrv_common_reg_set_value(SDRV_REG_BOOTREASON,0,0);

    soc_global_rst();
  101bd0:	f7ff ff7c 	bl	101acc <soc_global_rst>

    dprintf(ALWAYS,"%s X\n", __func__);
  101bd4:	f24c 4174 	movw	r1, #50292	; 0xc474
  101bd8:	f24c 40ac 	movw	r0, #50348	; 0xc4ac
  101bdc:	f2c0 0110 	movt	r1, #16
  101be0:	f2c0 0010 	movt	r0, #16
  101be4:	f009 fb7a 	bl	10b2dc <printf>
    return;
}
  101be8:	b003      	add	sp, #12
  101bea:	bd30      	pop	{r4, r5, r15}

00101bec <setup_pll>:
    sdrpc_notify_msg(NULL, COM_HANDOVER_STATUS, NULL);
#endif
}

static void setup_pll(uint32_t resid)
{
  101bec:	b538      	push	{r3, r4, r5, r14}
  101bee:	4605      	mov	r5, r0
    pll_handle_t pll;
    pll =  hal_pll_create_handle(resid);
  101bf0:	f004 ffe8 	bl	106bc4 <hal_pll_create_handle>

    //ASSERT(pll);
    if (pll == (pll_handle_t)0) {
  101bf4:	b140      	cbz	r0, 101c08 <setup_pll+0x1c>
  101bf6:	4604      	mov	r4, r0
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
        return;
    }

    hal_pll_config(pll, NULL);
  101bf8:	2100      	movs	r1, #0
  101bfa:	f005 f805 	bl	106c08 <hal_pll_config>
    hal_pll_delete_handle(pll);
  101bfe:	4620      	mov	r0, r4
}
  101c00:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    hal_pll_delete_handle(pll);
  101c04:	f004 bffe 	b.w	106c04 <hal_pll_delete_handle>
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
  101c08:	f24c 600c 	movw	r0, #50700	; 0xc60c
  101c0c:	4629      	mov	r1, r5
  101c0e:	f2c0 0010 	movt	r0, #16
}
  101c12:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
        dprintf(CRITICAL, "pll res 0x%x not belong this domain\n", resid);
  101c16:	f009 bb61 	b.w	10b2dc <printf>
  101c1a:	bf00      	nop

00101c1c <setup_pll>:

    hal_clock_release_handle(g_sec_handle);
}

static void setup_pll(uint32_t resid)
{
  101c1c:	b510      	push	{r4, r14}
    pll_handle_t pll;
    pll =  hal_pll_create_handle(resid);
  101c1e:	f004 ffd1 	bl	106bc4 <hal_pll_create_handle>

    if (pll == (pll_handle_t)0) {
  101c22:	b900      	cbnz	r0, 101c26 <setup_pll+0xa>
        return;
    }

    hal_pll_config(pll, NULL);
    hal_pll_delete_handle(pll);
}
  101c24:	bd10      	pop	{r4, r15}
  101c26:	4604      	mov	r4, r0
    hal_pll_config(pll, NULL);
  101c28:	2100      	movs	r1, #0
  101c2a:	f004 ffed 	bl	106c08 <hal_pll_config>
    hal_pll_delete_handle(pll);
  101c2e:	4620      	mov	r0, r4
}
  101c30:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_pll_delete_handle(pll);
  101c34:	f004 bfe6 	b.w	106c04 <hal_pll_delete_handle>

00101c38 <safety_init>:
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101c38:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    spi_nor_reset_slave(ospic_reg);
}
#endif

static void safety_init(uint32_t level)
{
  101c3c:	b5f0      	push	{r4, r5, r6, r7, r14}
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101c3e:	f6cf 4224 	movt	r2, #64548	; 0xfc24
{
  101c42:	b083      	sub	sp, #12
    while (!(readl(APB_SCR_SAF_BASE + (0x104 << 10)) & 0x8000000));
  101c44:	6813      	ldr	r3, [r2, #0]
  101c46:	011b      	lsls	r3, r3, #4
  101c48:	d5fc      	bpl.n	101c44 <safety_init+0xc>
    setup_pll(RES_PLL_PLL2);
  101c4a:	f242 0026 	movw	r0, #8230	; 0x2026
  101c4e:	f2c4 002e 	movt	r0, #16430	; 0x402e
  101c52:	f7ff ffcb 	bl	101bec <setup_pll>
    hal_saf_clock_set_default();
  101c56:	f004 fd41 	bl	1066dc <hal_saf_clock_set_default>
    setup_pll(RES_PLL_PLL1);
  101c5a:	f241 0025 	movw	r0, #4133	; 0x1025
  101c5e:	f2c4 002e 	movt	r0, #16430	; 0x402e
  101c62:	f7ff ffc3 	bl	101bec <setup_pll>
    ret = hal_clock_creat_handle(&handle);
  101c66:	a801      	add	r0, sp, #4
  101c68:	f004 fc70 	bl	10654c <hal_clock_creat_handle>
    if (!ret) {
  101c6c:	2800      	cmp	r0, #0
  101c6e:	d062      	beq.n	101d36 <safety_init+0xfe>
  101c70:	f24c 44b4 	movw	r4, #50356	; 0xc4b4
  101c74:	f44f 759c 	mov.w	r5, #312	; 0x138
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101c78:	f24c 57e0 	movw	r7, #50656	; 0xc5e0
  101c7c:	f2c0 0410 	movt	r4, #16
  101c80:	f104 062c 	add.w	r6, r4, #44	; 0x2c
    if (!ret) {
  101c84:	f2c8 259a 	movt	r5, #33434	; 0x829a
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101c88:	f2c0 0710 	movt	r7, #16
  101c8c:	e003      	b.n	101c96 <safety_init+0x5e>
    for (uint32_t i = 0;
  101c8e:	42b4      	cmp	r4, r6
  101c90:	d00d      	beq.n	101cae <safety_init+0x76>
  101c92:	f854 5f04 	ldr.w	r5, [r4, #4]!
        ret = hal_clock_enable(handle, default_clk_gating_enabled_table[i]);
  101c96:	9801      	ldr	r0, [sp, #4]
  101c98:	4629      	mov	r1, r5
  101c9a:	f004 fea1 	bl	1069e0 <hal_clock_enable>
        if (!ret) {
  101c9e:	2800      	cmp	r0, #0
  101ca0:	d1f5      	bne.n	101c8e <safety_init+0x56>
            dprintf(ALWAYS, "clock gating enable fail. IP gate RES:0x%x\n",
  101ca2:	4629      	mov	r1, r5
  101ca4:	4638      	mov	r0, r7
  101ca6:	f009 fb19 	bl	10b2dc <printf>
    for (uint32_t i = 0;
  101caa:	42b4      	cmp	r4, r6
  101cac:	d1f1      	bne.n	101c92 <safety_init+0x5a>
    hal_clock_release_handle(handle);
  101cae:	9801      	ldr	r0, [sp, #4]
  101cb0:	f004 fc68 	bl	106584 <hal_clock_release_handle>
#endif
    /* before this line should not invoke
     * ANY OS API.
    */
    /* enable tsgen */
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101cb4:	2300      	movs	r3, #0
  101cb6:	f24c 44e4 	movw	r4, #50404	; 0xc4e4
    addr_t module_phy_addr = 0;
  101cba:	2100      	movs	r1, #0
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101cbc:	f2cf 1341 	movt	r3, #61761	; 0xf141
    int32_t idx = 0;
  101cc0:	f240 404a 	movw	r0, #1098	; 0x44a
  101cc4:	f2c0 0410 	movt	r4, #16
  101cc8:	f104 0524 	add.w	r5, r4, #36	; 0x24
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101ccc:	681a      	ldr	r2, [r3, #0]
    int32_t idx = 0;
  101cce:	f2c8 2096 	movt	r0, #33430	; 0x8296
    RMWREG32(_ioaddr(TSGEN_BASE + CNTCR), 0, 1, 1);
  101cd2:	f042 0201 	orr.w	r2, r2, #1
  101cd6:	601a      	str	r2, [r3, #0]
    int32_t idx = 0;
  101cd8:	e9cd 1100 	strd	r1, r1, [r13]
  101cdc:	e003      	b.n	101ce6 <safety_init+0xae>
    for (uint32_t i = 0;
  101cde:	42ac      	cmp	r4, r5
  101ce0:	d013      	beq.n	101d0a <safety_init+0xd2>
  101ce2:	f854 0f04 	ldr.w	r0, [r4, #4]!
        ret = res_get_info_by_id(default_rst_ip_module[i], &module_phy_addr, &idx);
  101ce6:	4669      	mov	r1, r13
  101ce8:	aa01      	add	r2, sp, #4
  101cea:	f005 fb57 	bl	10739c <res_get_info_by_id>
        if (0 == ret) {
  101cee:	2800      	cmp	r0, #0
  101cf0:	d1f5      	bne.n	101cde <safety_init+0xa6>
            rstgen_module_ctl(module_phy_addr, idx, false);
  101cf2:	4602      	mov	r2, r0
  101cf4:	e9dd 0100 	ldrd	r0, r1, [r13]
  101cf8:	f003 fcfa 	bl	1056f0 <rstgen_module_ctl>
            rstgen_module_ctl(module_phy_addr, idx, true);
  101cfc:	e9dd 0100 	ldrd	r0, r1, [r13]
  101d00:	2201      	movs	r2, #1
  101d02:	f003 fcf5 	bl	1056f0 <rstgen_module_ctl>
    for (uint32_t i = 0;
  101d06:	42ac      	cmp	r4, r5
  101d08:	d1eb      	bne.n	101ce2 <safety_init+0xaa>
  101d0a:	f24c 510c 	movw	r1, #50444	; 0xc50c
        RMWREG32(handover_list.handover_info[i].op_addr,
  101d0e:	2501      	movs	r5, #1
  101d10:	f2c0 0110 	movt	r1, #16
  101d14:	f101 04b4 	add.w	r4, r1, #180	; 0xb4
  101d18:	6888      	ldr	r0, [r1, #8]
  101d1a:	f811 3f0c 	ldrb.w	r3, [r1, #12]!
  101d1e:	fa05 f203 	lsl.w	r2, r5, r3
    for (i = 0; i < handover_list.handover_num; i++) {
  101d22:	428c      	cmp	r4, r1
        RMWREG32(handover_list.handover_info[i].op_addr,
  101d24:	6803      	ldr	r3, [r0, #0]
  101d26:	ea23 0302 	bic.w	r3, r3, r2
  101d2a:	ea43 0302 	orr.w	r3, r3, r2
  101d2e:	6003      	str	r3, [r0, #0]
    for (i = 0; i < handover_list.handover_num; i++) {
  101d30:	d1f2      	bne.n	101d18 <safety_init+0xe0>
#ifdef ENABLE_RTC
    /* should call it before handover */
    platform_rtc_init();
#endif
    platform_handover();
}
  101d32:	b003      	add	sp, #12
  101d34:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(ALWAYS, "clock handle create fail\n");
  101d36:	f24c 50c4 	movw	r0, #50628	; 0xc5c4
  101d3a:	f2c0 0010 	movt	r0, #16
  101d3e:	f009 fab5 	bl	10b2ac <puts>
  101d42:	e7b7      	b.n	101cb4 <safety_init+0x7c>

00101d44 <set_pmu_ctrl_ap_domain>:
{
  101d44:	b510      	push	{r4, r14}
    ret = hal_pmu_creat_handle(&handle, RES_PMU_PMU);
  101d46:	f241 0105 	movw	r1, #4101	; 0x1005
{
  101d4a:	b082      	sub	sp, #8
  101d4c:	4604      	mov	r4, r0
    ret = hal_pmu_creat_handle(&handle, RES_PMU_PMU);
  101d4e:	f2c4 617e 	movt	r1, #18046	; 0x467e
  101d52:	a801      	add	r0, sp, #4
  101d54:	f005 f864 	bl	106e20 <hal_pmu_creat_handle>
    if (ret != 0) {
  101d58:	bb30      	cbnz	r0, 101da8 <set_pmu_ctrl_ap_domain+0x64>
    ret = hal_pmu_init(handle);
  101d5a:	9801      	ldr	r0, [sp, #4]
  101d5c:	f005 f8a6 	bl	106eac <hal_pmu_init>
    if (ret != 0) {
  101d60:	b9c8      	cbnz	r0, 101d96 <set_pmu_ctrl_ap_domain+0x52>
	ret = hal_pmu_set_powerctrl_io_mode(handle, PWR_CTRL_2, 0);
  101d62:	4602      	mov	r2, r0
  101d64:	2102      	movs	r1, #2
  101d66:	9801      	ldr	r0, [sp, #4]
  101d68:	f005 f8e8 	bl	106f3c <hal_pmu_set_powerctrl_io_mode>
	if (ret != 0) {
  101d6c:	bb28      	cbnz	r0, 101dba <set_pmu_ctrl_ap_domain+0x76>
	ret = hal_pmu_set_powerctrl_out_mode(handle, PWR_CTRL_2, 1);
  101d6e:	2201      	movs	r2, #1
  101d70:	2102      	movs	r1, #2
  101d72:	9801      	ldr	r0, [sp, #4]
  101d74:	f005 f908 	bl	106f88 <hal_pmu_set_powerctrl_out_mode>
	if (ret != 0) {
  101d78:	bb40      	cbnz	r0, 101dcc <set_pmu_ctrl_ap_domain+0x88>
	ret = hal_pmu_set_powerctrl_out_ctrl(handle, PWR_CTRL_2, state);
  101d7a:	4622      	mov	r2, r4
  101d7c:	2102      	movs	r1, #2
  101d7e:	9801      	ldr	r0, [sp, #4]
  101d80:	f005 f928 	bl	106fd4 <hal_pmu_set_powerctrl_out_ctrl>
	if (ret != 0) {
  101d84:	bb50      	cbnz	r0, 101ddc <set_pmu_ctrl_ap_domain+0x98>
    ret = hal_pmu_exit(handle);
  101d86:	9801      	ldr	r0, [sp, #4]
  101d88:	f005 f8b4 	bl	106ef4 <hal_pmu_exit>
    if (ret != 0) {
  101d8c:	bb70      	cbnz	r0, 101dec <set_pmu_ctrl_ap_domain+0xa8>
    return hal_pmu_release_handle(handle);
  101d8e:	9801      	ldr	r0, [sp, #4]
  101d90:	f005 f88a 	bl	106ea8 <hal_pmu_release_handle>
  101d94:	e006      	b.n	101da4 <set_pmu_ctrl_ap_domain+0x60>
        printf("pmu init fail\n");
  101d96:	f24c 70a4 	movw	r0, #51108	; 0xc7a4
  101d9a:	f2c0 0010 	movt	r0, #16
  101d9e:	f009 fa85 	bl	10b2ac <puts>
        return 1;
  101da2:	2001      	movs	r0, #1
}
  101da4:	b002      	add	sp, #8
  101da6:	bd10      	pop	{r4, r15}
        printf("get handle fail\n");
  101da8:	f24c 7094 	movw	r0, #51092	; 0xc794
  101dac:	f2c0 0010 	movt	r0, #16
  101db0:	f009 fa7c 	bl	10b2ac <puts>
        return 1;
  101db4:	2001      	movs	r0, #1
}
  101db6:	b002      	add	sp, #8
  101db8:	bd10      	pop	{r4, r15}
		printf("pmu set power ctrl PWR_CTRL_2 to out mode fail\n");
  101dba:	f24c 70b4 	movw	r0, #51124	; 0xc7b4
  101dbe:	f2c0 0010 	movt	r0, #16
  101dc2:	f009 fa73 	bl	10b2ac <puts>
		return 1;
  101dc6:	2001      	movs	r0, #1
}
  101dc8:	b002      	add	sp, #8
  101dca:	bd10      	pop	{r4, r15}
		printf("pmu set power ctrl PWR_CTRL_2 to soft mode fail\n");
  101dcc:	f24c 70e4 	movw	r0, #51172	; 0xc7e4
  101dd0:	f2c0 0010 	movt	r0, #16
  101dd4:	f009 fa6a 	bl	10b2ac <puts>
		return 1;
  101dd8:	2001      	movs	r0, #1
  101dda:	e7e3      	b.n	101da4 <set_pmu_ctrl_ap_domain+0x60>
		printf("pmu set power ctrl PWR_CTRL_2 to low level fail\n");
  101ddc:	f64c 0014 	movw	r0, #51220	; 0xc814
  101de0:	f2c0 0010 	movt	r0, #16
  101de4:	f009 fa62 	bl	10b2ac <puts>
		return 1;
  101de8:	2001      	movs	r0, #1
  101dea:	e7db      	b.n	101da4 <set_pmu_ctrl_ap_domain+0x60>
        printf("pmu exit fail\n");
  101dec:	f64c 0044 	movw	r0, #51268	; 0xc844
  101df0:	f2c0 0010 	movt	r0, #16
  101df4:	f009 fa5a 	bl	10b2ac <puts>
        return 1;
  101df8:	2001      	movs	r0, #1
  101dfa:	e7d3      	b.n	101da4 <set_pmu_ctrl_ap_domain+0x60>

00101dfc <module_iso_disable>:

void module_iso_disable(uint32_t res_id)
{
  101dfc:	b510      	push	{r4, r14}
    void *handle = NULL;
  101dfe:	2200      	movs	r2, #0
{
  101e00:	b082      	sub	sp, #8
  101e02:	4604      	mov	r4, r0
    void *handle = NULL;
  101e04:	ab02      	add	r3, sp, #8
    bool ret = false;
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101e06:	4601      	mov	r1, r0
    void *handle = NULL;
  101e08:	f843 2d04 	str.w	r2, [r3, #-4]!
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101e0c:	4618      	mov	r0, r3
  101e0e:	f005 fae9 	bl	1073e4 <hal_rstgen_creat_handle>

    if (!ret) {
  101e12:	b1e8      	cbz	r0, 101e50 <module_iso_disable+0x54>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
        return;
    }

    ret = hal_rstgen_init(handle);
  101e14:	9801      	ldr	r0, [sp, #4]
  101e16:	f005 fb61 	bl	1074dc <hal_rstgen_init>

    if (!ret) {
  101e1a:	b958      	cbnz	r0, 101e34 <module_iso_disable+0x38>
        dprintf(CRITICAL, "hal_rstgen_init res_id 0x%x fail.\n", res_id);
  101e1c:	f24c 60f8 	movw	r0, #50936	; 0xc6f8
  101e20:	4621      	mov	r1, r4
  101e22:	f2c0 0010 	movt	r0, #16
  101e26:	f009 fa59 	bl	10b2dc <printf>
    if (!ret) {
        dprintf(CRITICAL, "hal_rstgen_iso_disable res_id 0x%x fail.\n", res_id);
    }

fail:
    hal_rstgen_release_handle(handle);
  101e2a:	9801      	ldr	r0, [sp, #4]
  101e2c:	f005 fb4a 	bl	1074c4 <hal_rstgen_release_handle>
}
  101e30:	b002      	add	sp, #8
  101e32:	bd10      	pop	{r4, r15}
    ret = hal_rstgen_iso_disable(handle, res_id);
  101e34:	9801      	ldr	r0, [sp, #4]
  101e36:	4621      	mov	r1, r4
  101e38:	f005 fb52 	bl	1074e0 <hal_rstgen_iso_disable>
    if (!ret) {
  101e3c:	2800      	cmp	r0, #0
  101e3e:	d1f4      	bne.n	101e2a <module_iso_disable+0x2e>
        dprintf(CRITICAL, "hal_rstgen_iso_disable res_id 0x%x fail.\n", res_id);
  101e40:	f24c 701c 	movw	r0, #50972	; 0xc71c
  101e44:	4621      	mov	r1, r4
  101e46:	f2c0 0010 	movt	r0, #16
  101e4a:	f009 fa47 	bl	10b2dc <printf>
  101e4e:	e7ec      	b.n	101e2a <module_iso_disable+0x2e>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
  101e50:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
  101e54:	4621      	mov	r1, r4
  101e56:	f2c0 0010 	movt	r0, #16
  101e5a:	f009 fa3f 	bl	10b2dc <printf>
}
  101e5e:	b002      	add	sp, #8
  101e60:	bd10      	pop	{r4, r15}
  101e62:	bf00      	nop

00101e64 <module_rst>:

void module_rst(uint32_t res_id)
{
  101e64:	b510      	push	{r4, r14}
    void *handle = NULL;
  101e66:	2200      	movs	r2, #0
{
  101e68:	b082      	sub	sp, #8
  101e6a:	4604      	mov	r4, r0
    void *handle = NULL;
  101e6c:	ab02      	add	r3, sp, #8
    bool ret = false;
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101e6e:	4601      	mov	r1, r0
    void *handle = NULL;
  101e70:	f843 2d04 	str.w	r2, [r3, #-4]!
    ret = hal_rstgen_creat_handle(&handle, res_id);
  101e74:	4618      	mov	r0, r3
  101e76:	f005 fab5 	bl	1073e4 <hal_rstgen_creat_handle>

    if (!ret) {
  101e7a:	b1e8      	cbz	r0, 101eb8 <module_rst+0x54>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
        return;
    }

    ret = hal_rstgen_init(handle);
  101e7c:	9801      	ldr	r0, [sp, #4]
  101e7e:	f005 fb2d 	bl	1074dc <hal_rstgen_init>

    if (!ret) {
  101e82:	b958      	cbnz	r0, 101e9c <module_rst+0x38>
        dprintf(CRITICAL, "hal_rstgen_init res_id 0x%x fail.\n", res_id);
  101e84:	f24c 60f8 	movw	r0, #50936	; 0xc6f8
  101e88:	4621      	mov	r1, r4
  101e8a:	f2c0 0010 	movt	r0, #16
  101e8e:	f009 fa25 	bl	10b2dc <printf>
    if (!ret) {
        dprintf(CRITICAL, "hal_rstgen_module_reset res_id 0x%x fail.\n", res_id);
    }

fail:
    hal_rstgen_release_handle(handle);
  101e92:	9801      	ldr	r0, [sp, #4]
  101e94:	f005 fb16 	bl	1074c4 <hal_rstgen_release_handle>
}
  101e98:	b002      	add	sp, #8
  101e9a:	bd10      	pop	{r4, r15}
    ret = hal_rstgen_module_reset(handle, res_id);
  101e9c:	9801      	ldr	r0, [sp, #4]
  101e9e:	4621      	mov	r1, r4
  101ea0:	f005 fb3a 	bl	107518 <hal_rstgen_module_reset>
    if (!ret) {
  101ea4:	2800      	cmp	r0, #0
  101ea6:	d1f4      	bne.n	101e92 <module_rst+0x2e>
        dprintf(CRITICAL, "hal_rstgen_module_reset res_id 0x%x fail.\n", res_id);
  101ea8:	f24c 7048 	movw	r0, #51016	; 0xc748
  101eac:	4621      	mov	r1, r4
  101eae:	f2c0 0010 	movt	r0, #16
  101eb2:	f009 fa13 	bl	10b2dc <printf>
  101eb6:	e7ec      	b.n	101e92 <module_rst+0x2e>
        dprintf(CRITICAL, "hal_rstgen_creat_handle res_id 0x%x fail.\n", res_id);
  101eb8:	f24c 60cc 	movw	r0, #50892	; 0xc6cc
  101ebc:	4621      	mov	r1, r4
  101ebe:	f2c0 0010 	movt	r0, #16
  101ec2:	f009 fa0b 	bl	10b2dc <printf>
}
  101ec6:	b002      	add	sp, #8
  101ec8:	bd10      	pop	{r4, r15}
  101eca:	bf00      	nop

00101ecc <init_gpu1_ss>:

void init_gpu1_ss(void)
{
  101ecc:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
    bool ret = false;
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101ece:	f240 4027 	movw	r0, #1063	; 0x427
{
  101ed2:	b087      	sub	sp, #28
    void *handle = NULL;
  101ed4:	2400      	movs	r4, #0
  101ed6:	ad06      	add	r5, sp, #24
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101ed8:	f2c8 1096 	movt	r0, #33174	; 0x8196
    void *handle = NULL;
  101edc:	f845 4d18 	str.w	r4, [r5, #-24]!
    module_iso_disable(RES_ISO_EN_SEC_GPU1);
  101ee0:	f7ff ff8c 	bl	101dfc <module_iso_disable>
    module_rst(RES_MODULE_RST_SEC_GPU1_SS);
  101ee4:	f240 4091 	movw	r0, #1169	; 0x491
  101ee8:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101eec:	f7ff ffba 	bl	101e64 <module_rst>
    module_rst(RES_MODULE_RST_SEC_GPU1_CORE);
  101ef0:	f44f 6092 	mov.w	r0, #1168	; 0x490
  101ef4:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101ef8:	f7ff ffb4 	bl	101e64 <module_rst>

    ret = hal_clock_creat_handle(&handle);
  101efc:	4628      	mov	r0, r5
  101efe:	f004 fb25 	bl	10654c <hal_clock_creat_handle>

    if (!ret) {
  101f02:	2800      	cmp	r0, #0
  101f04:	d039      	beq.n	101f7a <init_gpu1_ss+0xae>
    corecfg.clk_src_select_a_num = 0;
    /* default--24MHz */
    corecfg.clk_src_select_b_num = 0;
    corecfg.clk_a_b_select = 0;
    corecfg.post_div = 0;
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU1, &corecfg);
  101f06:	21c3      	movs	r1, #195	; 0xc3
  101f08:	aa01      	add	r2, sp, #4
  101f0a:	9800      	ldr	r0, [sp, #0]
  101f0c:	f2c8 019a 	movt	r1, #32922	; 0x809a
    corecfg.clk_src_select_a_num = 0;
  101f10:	f8ad 4004 	strh.w	r4, [r13, #4]
    corecfg.clk_src_select_b_num = 0;
  101f14:	f88d 4006 	strb.w	r4, [r13, #6]
    corecfg.post_div = 0;
  101f18:	9402      	str	r4, [sp, #8]
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU1, &corecfg);
  101f1a:	f004 fd95 	bl	106a48 <hal_clock_coreclk_set>

    if (!ret) {
  101f1e:	b968      	cbnz	r0, 101f3c <init_gpu1_ss+0x70>
        dprintf(CRITICAL, "clock_coreclk resid 0x%x fail\n",
  101f20:	21c3      	movs	r1, #195	; 0xc3
  101f22:	f24c 6068 	movw	r0, #50792	; 0xc668
  101f26:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f2a:	f2c0 0010 	movt	r0, #16
  101f2e:	f009 f9d5 	bl	10b2dc <printf>
    }

    /* config pll_gpu1 */
    setup_pll(RES_PLL_PLL_GPU1);
fail:
    hal_clock_release_handle(handle);
  101f32:	9800      	ldr	r0, [sp, #0]
  101f34:	f004 fb26 	bl	106584 <hal_clock_release_handle>
}
  101f38:	b007      	add	sp, #28
  101f3a:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU1, &uuu_clk);
  101f3c:	f240 1183 	movw	r1, #387	; 0x183
  101f40:	aa03      	add	r2, sp, #12
  101f42:	9800      	ldr	r0, [sp, #0]
  101f44:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  101f48:	e9cd 4403 	strd	r4, r4, [r13, #12]
  101f4c:	9405      	str	r4, [sp, #20]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU1, &uuu_clk);
  101f4e:	f004 fdb9 	bl	106ac4 <hal_clock_uuuclk_set>
    if (!ret) {
  101f52:	b1d0      	cbz	r0, 101f8a <init_gpu1_ss+0xbe>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_GPU1_2);
  101f54:	9800      	ldr	r0, [sp, #0]
  101f56:	f240 111f 	movw	r1, #287	; 0x11f
  101f5a:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f5e:	f004 fd3f 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  101f62:	b9e8      	cbnz	r0, 101fa0 <init_gpu1_ss+0xd4>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  101f64:	f240 111f 	movw	r1, #287	; 0x11f
  101f68:	f24c 60a8 	movw	r0, #50856	; 0xc6a8
  101f6c:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f70:	f2c0 0010 	movt	r0, #16
  101f74:	f009 f9b2 	bl	10b2dc <printf>
        goto fail;
  101f78:	e7db      	b.n	101f32 <init_gpu1_ss+0x66>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  101f7a:	f24c 604c 	movw	r0, #50764	; 0xc64c
  101f7e:	f2c0 0010 	movt	r0, #16
  101f82:	f009 f993 	bl	10b2ac <puts>
}
  101f86:	b007      	add	sp, #28
  101f88:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_GPU1);
  101f8a:	f240 1183 	movw	r1, #387	; 0x183
  101f8e:	f24c 6088 	movw	r0, #50824	; 0xc688
  101f92:	f2c8 019a 	movt	r1, #32922	; 0x809a
  101f96:	f2c0 0010 	movt	r0, #16
  101f9a:	f009 f99f 	bl	10b2dc <printf>
        goto fail;
  101f9e:	e7c8      	b.n	101f32 <init_gpu1_ss+0x66>
    setup_pll(RES_PLL_PLL_GPU1);
  101fa0:	f241 0008 	movw	r0, #4104	; 0x1008
  101fa4:	f2c4 502e 	movt	r0, #17710	; 0x452e
  101fa8:	f7ff fe38 	bl	101c1c <setup_pll>
  101fac:	e7c1      	b.n	101f32 <init_gpu1_ss+0x66>
  101fae:	bf00      	nop

00101fb0 <init_gpu2_ss>:

void init_gpu2_ss(void)
{
  101fb0:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
    bool ret = false;
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101fb2:	f240 4093 	movw	r0, #1171	; 0x493
{
  101fb6:	b087      	sub	sp, #28
    void *handle = NULL;
  101fb8:	2400      	movs	r4, #0
  101fba:	ad06      	add	r5, sp, #24
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101fbc:	f2c8 1096 	movt	r0, #33174	; 0x8196
    void *handle = NULL;
  101fc0:	f845 4d18 	str.w	r4, [r5, #-24]!
    module_rst(RES_MODULE_RST_SEC_GPU2_SS);
  101fc4:	f7ff ff4e 	bl	101e64 <module_rst>
    module_rst(RES_MODULE_RST_SEC_GPU2_CORE);
  101fc8:	f240 4092 	movw	r0, #1170	; 0x492
  101fcc:	f2c8 1096 	movt	r0, #33174	; 0x8196
  101fd0:	f7ff ff48 	bl	101e64 <module_rst>
    ret = hal_clock_creat_handle(&handle);
  101fd4:	4628      	mov	r0, r5
  101fd6:	f004 fab9 	bl	10654c <hal_clock_creat_handle>

    if (!ret) {
  101fda:	2800      	cmp	r0, #0
  101fdc:	d039      	beq.n	102052 <init_gpu2_ss+0xa2>
    corecfg.clk_src_select_a_num = 0;
    /* default--24MHz */
    corecfg.clk_src_select_b_num = 0;
    corecfg.clk_a_b_select = 0;
    corecfg.post_div = 0;
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU2, &corecfg);
  101fde:	21c4      	movs	r1, #196	; 0xc4
  101fe0:	aa01      	add	r2, sp, #4
  101fe2:	9800      	ldr	r0, [sp, #0]
  101fe4:	f2c8 019a 	movt	r1, #32922	; 0x809a
    corecfg.clk_src_select_a_num = 0;
  101fe8:	f8ad 4004 	strh.w	r4, [r13, #4]
    corecfg.clk_src_select_b_num = 0;
  101fec:	f88d 4006 	strb.w	r4, [r13, #6]
    corecfg.post_div = 0;
  101ff0:	9402      	str	r4, [sp, #8]
    ret = hal_clock_coreclk_set(handle, RES_CORE_SLICE_SOC_GPU2, &corecfg);
  101ff2:	f004 fd29 	bl	106a48 <hal_clock_coreclk_set>

    if (!ret) {
  101ff6:	b968      	cbnz	r0, 102014 <init_gpu2_ss+0x64>
        dprintf(CRITICAL, "clock_coreclk resid 0x%x fail\n",
  101ff8:	21c4      	movs	r1, #196	; 0xc4
  101ffa:	f24c 6068 	movw	r0, #50792	; 0xc668
  101ffe:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102002:	f2c0 0010 	movt	r0, #16
  102006:	f009 f969 	bl	10b2dc <printf>
    }

    /* config pll_gpu2 */
    setup_pll(RES_PLL_PLL_GPU2);
fail:
    hal_clock_release_handle(handle);
  10200a:	9800      	ldr	r0, [sp, #0]
  10200c:	f004 faba 	bl	106584 <hal_clock_release_handle>
}
  102010:	b007      	add	sp, #28
  102012:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU2, &uuu_clk);
  102014:	f44f 71c2 	mov.w	r1, #388	; 0x184
  102018:	aa03      	add	r2, sp, #12
  10201a:	9800      	ldr	r0, [sp, #0]
  10201c:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  102020:	e9cd 4403 	strd	r4, r4, [r13, #12]
  102024:	9405      	str	r4, [sp, #20]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_GPU2, &uuu_clk);
  102026:	f004 fd4d 	bl	106ac4 <hal_clock_uuuclk_set>
    if (!ret) {
  10202a:	b1d0      	cbz	r0, 102062 <init_gpu2_ss+0xb2>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_GPU2_2);
  10202c:	9800      	ldr	r0, [sp, #0]
  10202e:	f240 1121 	movw	r1, #289	; 0x121
  102032:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102036:	f004 fcd3 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  10203a:	b9e8      	cbnz	r0, 102078 <init_gpu2_ss+0xc8>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  10203c:	f240 1121 	movw	r1, #289	; 0x121
  102040:	f24c 60a8 	movw	r0, #50856	; 0xc6a8
  102044:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102048:	f2c0 0010 	movt	r0, #16
  10204c:	f009 f946 	bl	10b2dc <printf>
        goto fail;
  102050:	e7db      	b.n	10200a <init_gpu2_ss+0x5a>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  102052:	f24c 604c 	movw	r0, #50764	; 0xc64c
  102056:	f2c0 0010 	movt	r0, #16
  10205a:	f009 f927 	bl	10b2ac <puts>
}
  10205e:	b007      	add	sp, #28
  102060:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_GPU2);
  102062:	f44f 71c2 	mov.w	r1, #388	; 0x184
  102066:	f24c 6088 	movw	r0, #50824	; 0xc688
  10206a:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10206e:	f2c0 0010 	movt	r0, #16
  102072:	f009 f933 	bl	10b2dc <printf>
        goto fail;
  102076:	e7c8      	b.n	10200a <init_gpu2_ss+0x5a>
    setup_pll(RES_PLL_PLL_GPU2);
  102078:	f242 0009 	movw	r0, #8201	; 0x2009
  10207c:	f2c4 502e 	movt	r0, #17710	; 0x452e
  102080:	f7ff fdcc 	bl	101c1c <setup_pll>
  102084:	e7c1      	b.n	10200a <init_gpu2_ss+0x5a>
  102086:	bf00      	nop

00102088 <init_vpu_ss>:
        addr += lvds_clock_offset;
    }
}

void init_vpu_ss(void)
{
  102088:	b530      	push	{r4, r5, r14}
    void *handle = NULL;
  10208a:	2400      	movs	r4, #0
{
  10208c:	b085      	sub	sp, #20
    void *handle = NULL;
  10208e:	a804      	add	r0, sp, #16
  102090:	f840 4d10 	str.w	r4, [r0, #-16]!
    bool ret = false;
    ret = hal_clock_creat_handle(&handle);
  102094:	f004 fa5a 	bl	10654c <hal_clock_creat_handle>

    if (!ret) {
  102098:	2800      	cmp	r0, #0
  10209a:	f000 808b 	beq.w	1021b4 <init_vpu_ss+0x12c>
        return;
    }

    /* config uuu for vpu_bus */
    clkgen_app_uuu_cfg_t uuu_clk = {0};
    uuu_clk.uuu_input_clk_sel = 3;
  10209e:	2503      	movs	r5, #3
    uuu_clk.low_power_mode_en = 0;
    uuu_clk.m_div = 0;
    uuu_clk.n_div = 3;
    uuu_clk.p_div = 0;
    uuu_clk.q_div = 0;
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU_BUS, &uuu_clk);
  1020a0:	f240 1187 	movw	r1, #391	; 0x187
  1020a4:	aa01      	add	r2, sp, #4
  1020a6:	9800      	ldr	r0, [sp, #0]
  1020a8:	f2c8 019a 	movt	r1, #32922	; 0x809a
    clkgen_app_uuu_cfg_t uuu_clk = {0};
  1020ac:	e9cd 4402 	strd	r4, r4, [r13, #8]
    uuu_clk.uuu_input_clk_sel = 3;
  1020b0:	9501      	str	r5, [sp, #4]
    uuu_clk.n_div = 3;
  1020b2:	f88d 500a 	strb.w	r5, [r13, #10]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU_BUS, &uuu_clk);
  1020b6:	f004 fd05 	bl	106ac4 <hal_clock_uuuclk_set>

    if (!ret) {
  1020ba:	b970      	cbnz	r0, 1020da <init_vpu_ss+0x52>
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n",
  1020bc:	f240 1187 	movw	r1, #391	; 0x187
  1020c0:	f24c 6088 	movw	r0, #50824	; 0xc688
  1020c4:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1020c8:	f2c0 0010 	movt	r0, #16
  1020cc:	f009 f906 	bl	10b2dc <printf>
                RES_GATING_EN_SOC_GPU1_2);
        goto fail;
    }

fail:
    hal_clock_release_handle(handle);
  1020d0:	9800      	ldr	r0, [sp, #0]
  1020d2:	f004 fa57 	bl	106584 <hal_clock_release_handle>
}
  1020d6:	b005      	add	sp, #20
  1020d8:	bd30      	pop	{r4, r5, r15}
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU1, &uuu_clk);
  1020da:	f240 1185 	movw	r1, #389	; 0x185
  1020de:	aa01      	add	r2, sp, #4
  1020e0:	9800      	ldr	r0, [sp, #0]
  1020e2:	f2c8 019a 	movt	r1, #32922	; 0x809a
    uuu_clk.uuu_input_clk_sel = 3;
  1020e6:	9501      	str	r5, [sp, #4]
    uuu_clk.low_power_mode_en = 0;
  1020e8:	f88d 4008 	strb.w	r4, [r13, #8]
    uuu_clk.m_div = 0;
  1020ec:	f88d 4009 	strb.w	r4, [r13, #9]
    uuu_clk.n_div = 0;
  1020f0:	f88d 400a 	strb.w	r4, [r13, #10]
    uuu_clk.p_div = 0;
  1020f4:	f88d 400b 	strb.w	r4, [r13, #11]
    uuu_clk.q_div = 0;
  1020f8:	f88d 400c 	strb.w	r4, [r13, #12]
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_VPU1, &uuu_clk);
  1020fc:	f004 fce2 	bl	106ac4 <hal_clock_uuuclk_set>
    ret = hal_clock_uuuclk_set(handle, RES_UUU_WRAP_SOC_MJPEG, &uuu_clk);
  102100:	f44f 71c3 	mov.w	r1, #390	; 0x186
  102104:	aa01      	add	r2, sp, #4
  102106:	9800      	ldr	r0, [sp, #0]
  102108:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10210c:	f004 fcda 	bl	106ac4 <hal_clock_uuuclk_set>
    if (!ret) {
  102110:	2800      	cmp	r0, #0
  102112:	d057      	beq.n	1021c4 <init_vpu_ss+0x13c>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_VPU2_PCLK);
  102114:	9800      	ldr	r0, [sp, #0]
  102116:	f240 1123 	movw	r1, #291	; 0x123
  10211a:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10211e:	f004 fc5f 	bl	1069e0 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_VPU1_PCLK);
  102122:	9800      	ldr	r0, [sp, #0]
  102124:	f44f 7191 	mov.w	r1, #290	; 0x122
  102128:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10212c:	f004 fc58 	bl	1069e0 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_MJPEG_PCLK);
  102130:	9800      	ldr	r0, [sp, #0]
  102132:	f44f 7192 	mov.w	r1, #292	; 0x124
  102136:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10213a:	f004 fc51 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  10213e:	2800      	cmp	r0, #0
  102140:	d04b      	beq.n	1021da <init_vpu_ss+0x152>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_VPU2_ACLK);
  102142:	9800      	ldr	r0, [sp, #0]
  102144:	f240 1123 	movw	r1, #291	; 0x123
  102148:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10214c:	f004 fc48 	bl	1069e0 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_VPU1_ACLK);
  102150:	9800      	ldr	r0, [sp, #0]
  102152:	f44f 7191 	mov.w	r1, #290	; 0x122
  102156:	f2c8 019a 	movt	r1, #32922	; 0x809a
  10215a:	f004 fc41 	bl	1069e0 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_0_MJPEG_ACLK);
  10215e:	9800      	ldr	r0, [sp, #0]
  102160:	f44f 7192 	mov.w	r1, #292	; 0x124
  102164:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102168:	f004 fc3a 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  10216c:	b3a8      	cbz	r0, 1021da <init_vpu_ss+0x152>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU1);
  10216e:	9800      	ldr	r0, [sp, #0]
  102170:	f44f 7191 	mov.w	r1, #290	; 0x122
  102174:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102178:	f004 fc32 	bl	1069e0 <hal_clock_enable>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_MJPEG);
  10217c:	9800      	ldr	r0, [sp, #0]
  10217e:	f44f 7192 	mov.w	r1, #292	; 0x124
  102182:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102186:	f004 fc2b 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  10218a:	b140      	cbz	r0, 10219e <init_vpu_ss+0x116>
    ret = hal_clock_enable(handle, RES_GATING_EN_SOC_VPU_BUS_1_PLL_VPU);
  10218c:	9800      	ldr	r0, [sp, #0]
  10218e:	f240 1125 	movw	r1, #293	; 0x125
  102192:	f2c8 019a 	movt	r1, #32922	; 0x809a
  102196:	f004 fc23 	bl	1069e0 <hal_clock_enable>
    if (!ret) {
  10219a:	2800      	cmp	r0, #0
  10219c:	d198      	bne.n	1020d0 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  10219e:	f240 111f 	movw	r1, #287	; 0x11f
  1021a2:	f24c 60a8 	movw	r0, #50856	; 0xc6a8
  1021a6:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1021aa:	f2c0 0010 	movt	r0, #16
  1021ae:	f009 f895 	bl	10b2dc <printf>
        goto fail;
  1021b2:	e78d      	b.n	1020d0 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_creat_handle fail\n");
  1021b4:	f24c 604c 	movw	r0, #50764	; 0xc64c
  1021b8:	f2c0 0010 	movt	r0, #16
  1021bc:	f009 f876 	bl	10b2ac <puts>
}
  1021c0:	b005      	add	sp, #20
  1021c2:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "clock_uuuclk resid 0x%x fail\n", RES_UUU_WRAP_SOC_VPU1);
  1021c4:	f240 1185 	movw	r1, #389	; 0x185
  1021c8:	f24c 6088 	movw	r0, #50824	; 0xc688
  1021cc:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1021d0:	f2c0 0010 	movt	r0, #16
  1021d4:	f009 f882 	bl	10b2dc <printf>
        goto fail;
  1021d8:	e77a      	b.n	1020d0 <init_vpu_ss+0x48>
        dprintf(CRITICAL, "hal_clock_enable resid 0x%x fail\n",
  1021da:	f44f 7191 	mov.w	r1, #290	; 0x122
  1021de:	f24c 60a8 	movw	r0, #50856	; 0xc6a8
  1021e2:	f2c8 019a 	movt	r1, #32922	; 0x809a
  1021e6:	f2c0 0010 	movt	r0, #16
  1021ea:	f009 f877 	bl	10b2dc <printf>
        goto fail;
  1021ee:	e76f      	b.n	1020d0 <init_vpu_ss+0x48>

001021f0 <rstgen_sec_module_rst>:
{
    unsigned int rval;
    uint32_t count = 100;
    const uint32_t module_rst_offset = 0x100 << 10;
    addr_t addr = APB_RSTGEN_SEC_BASE + module_rst_offset + ((
                      0x4 * idx) << 10);
  1021f0:	0300      	lsls	r0, r0, #12
    addr_t addr = APB_RSTGEN_SEC_BASE + module_rst_offset + ((
  1021f2:	f100 4078 	add.w	r0, r0, #4160749568	; 0xf8000000
  1021f6:	f500 0088 	add.w	r0, r0, #4456448	; 0x440000
{
  1021fa:	b410      	push	{r4}
    rval = readl(addr);
  1021fc:	6802      	ldr	r2, [r0, #0]
    writel(((rval & (~(0x1 << 1))) | (0x1 << 1)), addr);
  1021fe:	2364      	movs	r3, #100	; 0x64
  102200:	f042 0202 	orr.w	r2, r2, #2
  102204:	6002      	str	r2, [r0, #0]
  102206:	e001      	b.n	10220c <rstgen_sec_module_rst+0x1c>

    /* Wait module reset enable done. */
    while ((count--) && (!((readl(addr) & (0x1 << 1)) == (0x1 << 1))));
  102208:	3b01      	subs	r3, #1
  10220a:	d002      	beq.n	102212 <rstgen_sec_module_rst+0x22>
  10220c:	6802      	ldr	r2, [r0, #0]
  10220e:	0792      	lsls	r2, r2, #30
  102210:	d5fa      	bpl.n	102208 <rstgen_sec_module_rst+0x18>

    rval = readl(addr);
  102212:	6803      	ldr	r3, [r0, #0]
    writel(((rval & (~(0x1 << 0))) | rst_b), addr);
    /* Wait module reset done. */
    count = 100;

    while ((count--) && ((readl(addr) & (0x1 << 30)) != rst_b << 30));
  102214:	078c      	lsls	r4, r1, #30
  102216:	2264      	movs	r2, #100	; 0x64
    writel(((rval & (~(0x1 << 0))) | rst_b), addr);
  102218:	f023 0301 	bic.w	r3, r3, #1
  10221c:	4319      	orrs	r1, r3
  10221e:	6001      	str	r1, [r0, #0]
  102220:	e001      	b.n	102226 <rstgen_sec_module_rst+0x36>
    while ((count--) && ((readl(addr) & (0x1 << 30)) != rst_b << 30));
  102222:	3a01      	subs	r2, #1
  102224:	d004      	beq.n	102230 <rstgen_sec_module_rst+0x40>
  102226:	6803      	ldr	r3, [r0, #0]
  102228:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  10222c:	42a3      	cmp	r3, r4
  10222e:	d1f8      	bne.n	102222 <rstgen_sec_module_rst+0x32>
}
  102230:	f85d 4b04 	ldr.w	r4, [r13], #4
  102234:	4770      	bx	r14
  102236:	bf00      	nop

00102238 <release_rst_all>:

void release_rst_all(void)
{
  102238:	b510      	push	{r4, r14}
    for (unsigned int i = 0; i < 104; i++) {
  10223a:	2400      	movs	r4, #0
        /* skip vdsp dreset */
        if (i == 38) {
            continue;
        }

        rstgen_sec_module_rst(i, 0x1);
  10223c:	2101      	movs	r1, #1
        if (i >= 21 && i <= 26) {
  10223e:	f1a4 0315 	sub.w	r3, r4, #21
        rstgen_sec_module_rst(i, 0x1);
  102242:	4620      	mov	r0, r4
        if (i == 38) {
  102244:	2c26      	cmp	r4, #38	; 0x26
  102246:	bf18      	it	ne
  102248:	2b05      	cmpne	r3, #5
    for (unsigned int i = 0; i < 104; i++) {
  10224a:	440c      	add	r4, r1
        if (i == 38) {
  10224c:	d901      	bls.n	102252 <release_rst_all+0x1a>
        rstgen_sec_module_rst(i, 0x1);
  10224e:	f7ff ffcf 	bl	1021f0 <rstgen_sec_module_rst>
    for (unsigned int i = 0; i < 104; i++) {
  102252:	2c68      	cmp	r4, #104	; 0x68
  102254:	d1f2      	bne.n	10223c <release_rst_all+0x4>
    }
}
  102256:	bd10      	pop	{r4, r15}

00102258 <enable_gating_all>:
    uint32_t rval = readl(addr);
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
}

void enable_gating_all(void)
{
  102258:	2300      	movs	r3, #0
    uint32_t i;
    const uint32_t gating_max_num = 128;

    for (i = 0; i < gating_max_num; i++) {
  10225a:	4619      	mov	r1, r3
{
  10225c:	f2cf 6310 	movt	r3, #62992	; 0xf610
    for (i = 0; i < gating_max_num; i++) {
  102260:	f2cf 6118 	movt	r1, #63000	; 0xf618
    uint32_t rval = readl(addr);
  102264:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  102266:	f022 0202 	bic.w	r2, r2, #2
  10226a:	601a      	str	r2, [r3, #0]
  10226c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    for (i = 0; i < gating_max_num; i++) {
  102270:	428b      	cmp	r3, r1
  102272:	d1f7      	bne.n	102264 <enable_gating_all+0xc>
  102274:	2300      	movs	r3, #0
  102276:	f6cf 0310 	movt	r3, #63504	; 0xf810
    uint32_t rval = readl(addr);
  10227a:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  10227c:	f022 0202 	bic.w	r2, r2, #2
  102280:	601a      	str	r2, [r3, #0]
  102282:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
        ckgen_lp_gating_disable(APB_CKGEN_SOC_BASE, i, 0x0);
    }

    for (i = 0; i < gating_max_num; i++) {
  102286:	f113 6ffd 	cmn.w	r3, #132644864	; 0x7e80000
  10228a:	d1f6      	bne.n	10227a <enable_gating_all+0x22>
  10228c:	2300      	movs	r3, #0
        ckgen_lp_gating_disable(APB_CKGEN_SEC_BASE, i, 0x0);
    }

    for (i = 0; i < gating_max_num; i++) {
  10228e:	4619      	mov	r1, r3
  102290:	f2cf 6330 	movt	r3, #63024	; 0xf630
  102294:	f2cf 6138 	movt	r1, #63032	; 0xf638
    uint32_t rval = readl(addr);
  102298:	681a      	ldr	r2, [r3, #0]
    writel(((rval & (~(0x1 << 1))) | (value << 1)), addr);
  10229a:	f022 0202 	bic.w	r2, r2, #2
  10229e:	601a      	str	r2, [r3, #0]
  1022a0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    for (i = 0; i < gating_max_num; i++) {
  1022a4:	428b      	cmp	r3, r1
  1022a6:	d1f7      	bne.n	102298 <enable_gating_all+0x40>
        ckgen_lp_gating_disable(APB_CKGEN_DISP_BASE, i, 0x0);
    }
}
  1022a8:	4770      	bx	r14
  1022aa:	bf00      	nop

001022ac <module_config_init>:

/* init module config */
int module_config_init(void)
{
    //init pll
    setup_pll(RES_PLL_PLL6);
  1022ac:	f246 0003 	movw	r0, #24579	; 0x6003
{
  1022b0:	b508      	push	{r3, r14}
    setup_pll(RES_PLL_PLL6);
  1022b2:	f2c4 202e 	movt	r0, #16942	; 0x422e
  1022b6:	f7ff fcb1 	bl	101c1c <setup_pll>
    setup_pll(RES_PLL_PLL7);
  1022ba:	f247 0004 	movw	r0, #28676	; 0x7004
  1022be:	f2c4 202e 	movt	r0, #16942	; 0x422e
  1022c2:	f7ff fcab 	bl	101c1c <setup_pll>
#if !DISABLE_VPU
    setup_pll(RES_PLL_PLL_VPU);
  1022c6:	f241 0005 	movw	r0, #4101	; 0x1005
  1022ca:	f2c4 502e 	movt	r0, #17710	; 0x452e
  1022ce:	f7ff fca5 	bl	101c1c <setup_pll>
#endif
    setup_pll(RES_PLL_PLL_HIS);
  1022d2:	f241 0015 	movw	r0, #4117	; 0x1015
  1022d6:	f2c4 402e 	movt	r0, #17454	; 0x442e
  1022da:	f7ff fc9f 	bl	101c1c <setup_pll>
    module_iso_disable(RES_ISO_EN_SEC_USB);
  1022de:	f240 4025 	movw	r0, #1061	; 0x425
  1022e2:	f2c8 1096 	movt	r0, #33174	; 0x8196
  1022e6:	f7ff fd89 	bl	101dfc <module_iso_disable>
    module_iso_disable(RES_ISO_EN_SEC_PCIE);
  1022ea:	f240 4024 	movw	r0, #1060	; 0x424
  1022ee:	f2c8 1096 	movt	r0, #33174	; 0x8196
  1022f2:	f7ff fd83 	bl	101dfc <module_iso_disable>
    init_pcie_ss();
    //debug
#if !defined(PLATFORM_G9X) && !defined(PLATFORM_G9Q)
    /* init GPU */
#if !DISABLE_GPU
    init_gpu1_ss();
  1022f6:	f7ff fde9 	bl	101ecc <init_gpu1_ss>
    init_gpu2_ss();
  1022fa:	f7ff fe59 	bl	101fb0 <init_gpu2_ss>
    addr_t addr = APB_LVDS_COMMON_BASE + lvds_clock_offset + 0x4;
  1022fe:	2204      	movs	r2, #4
    for (int i = 0; i < 4; i++) {
  102300:	4611      	mov	r1, r2
    addr_t addr = APB_LVDS_COMMON_BASE + lvds_clock_offset + 0x4;
  102302:	f2cf 02c5 	movt	r2, #61637	; 0xf0c5
    for (int i = 0; i < 4; i++) {
  102306:	f2cf 01c9 	movt	r1, #61641	; 0xf0c9
        rval = readl(addr);
  10230a:	6813      	ldr	r3, [r2, #0]
        writel((rval & (~(0x3F))) | 0x26, addr);
  10230c:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
  102310:	f043 0326 	orr.w	r3, r3, #38	; 0x26
  102314:	6013      	str	r3, [r2, #0]
        addr += lvds_clock_offset;
  102316:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
    for (int i = 0; i < 4; i++) {
  10231a:	428a      	cmp	r2, r1
  10231c:	d1f5      	bne.n	10230a <module_config_init+0x5e>
#endif
    /* init disp */
    init_display_ss();
    /* init vpu */
#if !DISABLE_VPU
    init_vpu_ss();
  10231e:	f7ff feb3 	bl	102088 <init_vpu_ss>
#endif

#ifdef VDSP_ENABLE
    init_vsn_ss();
#endif
    hpi_qos_init();
  102322:	f000 f84f 	bl	1023c4 <hpi_qos_init>
    hal_sec_clock_set_default();
  102326:	f004 fa23 	bl	106770 <hal_sec_clock_set_default>
    hal_soc_clock_set_default();
  10232a:	f004 fad7 	bl	1068dc <hal_soc_clock_set_default>
#if SUPPORT_DISP_SDDRV
    hal_disp_clock_set_default();
#endif
    /* enable all gating_en of sec/disp/soc */
    enable_gating_all();
  10232e:	f7ff ff93 	bl	102258 <enable_gating_all>
    /* release all module_rst of sec */
    release_rst_all();
  102332:	f7ff ff81 	bl	102238 <release_rst_all>
    return 0;
}
  102336:	2000      	movs	r0, #0
  102338:	bd08      	pop	{r3, r15}
  10233a:	bf00      	nop

0010233c <soc_init>:

    hal_port_release_handle(port_init_handle);
}

void soc_init(uint level)
{
  10233c:	b530      	push	{r4, r5, r14}
  10233e:	b083      	sub	sp, #12
    ret = hal_clock_creat_handle(&g_sec_handle);
  102340:	a801      	add	r0, sp, #4
  102342:	f004 f903 	bl	10654c <hal_clock_creat_handle>
    if (!ret) {
  102346:	b398      	cbz	r0, 1023b0 <soc_init+0x74>
  102348:	4c1d      	ldr	r4, [pc, #116]	; (1023c0 <soc_init+0x84>)
  10234a:	f44f 7128 	mov.w	r1, #672	; 0x2a0
  10234e:	f2c8 1198 	movt	r1, #33176	; 0x8198
  102352:	f104 051c 	add.w	r5, r4, #28
  102356:	e001      	b.n	10235c <soc_init+0x20>
  102358:	f854 1b04 	ldr.w	r1, [r4], #4
        ret = hal_clock_osc_init(g_sec_handle, refclk_ResIdx[i], xtal_saf_24M,
  10235c:	2301      	movs	r3, #1
  10235e:	2200      	movs	r2, #0
  102360:	9801      	ldr	r0, [sp, #4]
  102362:	f004 f917 	bl	106594 <hal_clock_osc_init>
    for (uint8_t i = 0; i < glb_res_idx_size; i++) {
  102366:	42ac      	cmp	r4, r5
  102368:	d1f6      	bne.n	102358 <soc_init+0x1c>
    hal_clock_release_handle(g_sec_handle);
  10236a:	9801      	ldr	r0, [sp, #4]
  10236c:	f004 f90a 	bl	106584 <hal_clock_release_handle>
    refclk_config();
    scr_init();
  102370:	f000 fdba 	bl	102ee8 <scr_init>

    module_config_init();
  102374:	f7ff ff9a 	bl	1022ac <module_config_init>
    void *port_init_handle = NULL;
  102378:	2300      	movs	r3, #0
    hal_port_creat_handle(&port_init_handle, RES_PAD_CONTROL_SAF_JTAG_TMS);
  10237a:	f44f 61a0 	mov.w	r1, #1280	; 0x500
  10237e:	a801      	add	r0, sp, #4
    void *port_init_handle = NULL;
  102380:	9301      	str	r3, [sp, #4]
    hal_port_creat_handle(&port_init_handle, RES_PAD_CONTROL_SAF_JTAG_TMS);
  102382:	f2c8 2194 	movt	r1, #33428	; 0x8294
  102386:	f004 fe4b 	bl	107020 <hal_port_creat_handle>
    if (port_init_handle) {
  10238a:	9801      	ldr	r0, [sp, #4]
  10238c:	b148      	cbz	r0, 1023a2 <soc_init+0x66>
        hal_port_init(port_init_handle);
  10238e:	f004 fee9 	bl	107164 <hal_port_init>
    hal_port_release_handle(port_init_handle);
  102392:	9801      	ldr	r0, [sp, #4]
  102394:	f004 feae 	bl	1070f4 <hal_port_release_handle>
    platform_port_init();
	set_pmu_ctrl_ap_domain(1);
  102398:	2001      	movs	r0, #1
  10239a:	f7ff fcd3 	bl	101d44 <set_pmu_ctrl_ap_domain>
}
  10239e:	b003      	add	sp, #12
  1023a0:	bd30      	pop	{r4, r5, r15}
        dprintf(ALWAYS, "port get handle failed!\n");
  1023a2:	f64b 6008 	movw	r0, #48648	; 0xbe08
  1023a6:	f2c0 0010 	movt	r0, #16
  1023aa:	f008 ff7f 	bl	10b2ac <puts>
  1023ae:	e7f0      	b.n	102392 <soc_init+0x56>
        printf("clkgen creat handle failed\n");
  1023b0:	f64c 0054 	movw	r0, #51284	; 0xc854
  1023b4:	f2c0 0010 	movt	r0, #16
  1023b8:	f008 ff78 	bl	10b2ac <puts>
  1023bc:	e7d8      	b.n	102370 <soc_init+0x34>
  1023be:	bf00      	nop
  1023c0:	0010c778 	.word	0x0010c778

001023c4 <hpi_qos_init>:
void init_qos_by_module(addr_t iobase, int offset,
                        uint32_t pri, uint32_t mode,
                        uint32_t bw, uint32_t satur, uint32_t ext)
{
    /* priority */
    writel(pri, iobase + offset + 0x8);
  1023c4:	f240 5103 	movw	r1, #1283	; 0x503
  1023c8:	f44f 72c4 	mov.w	r2, #392	; 0x188
  1023cc:	f2c8 0100 	movt	r1, #32768	; 0x8000
    /* ext */
    writel(ext, iobase + offset + 0x18);
}

void hpi_qos_init(void)
{
  1023d0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    writel(pri, iobase + offset + 0x8);
  1023d4:	460e      	mov	r6, r1
{
  1023d6:	b083      	sub	sp, #12
    writel(mode, iobase + offset + 0xc);
  1023d8:	f44f 7bc6 	mov.w	r11, #396	; 0x18c
    writel(pri, iobase + offset + 0x8);
  1023dc:	f2cf 02cf 	movt	r2, #61647	; 0xf0cf
  1023e0:	9601      	str	r6, [sp, #4]
    writel(mode, iobase + offset + 0xc);
  1023e2:	f2cf 0bcf 	movt	r11, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1023e6:	6016      	str	r6, [r2, #0]
    writel(mode, iobase + offset + 0xc);
  1023e8:	2203      	movs	r2, #3
    writel(bw, iobase + offset + 0x10);
  1023ea:	f44f 70c8 	mov.w	r0, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  1023ee:	f44f 73ca 	mov.w	r3, #404	; 0x194
    writel(mode, iobase + offset + 0xc);
  1023f2:	f8cb 2000 	str.w	r2, [r11]
    writel(bw, iobase + offset + 0x10);
  1023f6:	f2cf 00cf 	movt	r0, #61647	; 0xf0cf
  1023fa:	f44f 7bb6 	mov.w	r11, #364	; 0x16c
    writel(satur, iobase + offset + 0x14);
  1023fe:	f2cf 03cf 	movt	r3, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102402:	f44f 7acc 	mov.w	r10, #408	; 0x198
    writel(pri, iobase + offset + 0x8);
  102406:	f44f 7802 	mov.w	r8, #520	; 0x208
    writel(bw, iobase + offset + 0x10);
  10240a:	f8c0 b000 	str.w	r11, [r0]
    writel(satur, iobase + offset + 0x14);
  10240e:	2080      	movs	r0, #128	; 0x80
    writel(pri, iobase + offset + 0x8);
  102410:	f240 6906 	movw	r9, #1542	; 0x606
    writel(mode, iobase + offset + 0xc);
  102414:	f44f 7e03 	mov.w	r14, #524	; 0x20c
    writel(bw, iobase + offset + 0x10);
  102418:	f44f 7c04 	mov.w	r12, #528	; 0x210
    writel(satur, iobase + offset + 0x14);
  10241c:	f44f 7505 	mov.w	r5, #532	; 0x214
  102420:	6018      	str	r0, [r3, #0]
    writel(ext, iobase + offset + 0x18);
  102422:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
  102426:	2300      	movs	r3, #0
    writel(pri, iobase + offset + 0x8);
  102428:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
  10242c:	f2c8 0900 	movt	r9, #32768	; 0x8000
    writel(mode, iobase + offset + 0xc);
  102430:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102434:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102438:	f44f 7706 	mov.w	r7, #536	; 0x218
    writel(satur, iobase + offset + 0x14);
  10243c:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102440:	2408      	movs	r4, #8
    writel(mode, iobase + offset + 0xc);
  102442:	210c      	movs	r1, #12
    writel(ext, iobase + offset + 0x18);
  102444:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102448:	f2cf 04cf 	movt	r4, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  10244c:	f8ca 3000 	str.w	r3, [r10]
    writel(mode, iobase + offset + 0xc);
  102450:	f2cf 01cf 	movt	r1, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102454:	f8c8 9000 	str.w	r9, [r8]
    writel(bw, iobase + offset + 0x10);
  102458:	2610      	movs	r6, #16
    writel(mode, iobase + offset + 0xc);
  10245a:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  10245e:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  102462:	f8cc b000 	str.w	r11, [r12]
    writel(satur, iobase + offset + 0x14);
  102466:	f04f 0814 	mov.w	r8, #20
  10246a:	6028      	str	r0, [r5, #0]
    writel(ext, iobase + offset + 0x18);
  10246c:	f04f 0e18 	mov.w	r14, #24
    writel(pri, iobase + offset + 0x8);
  102470:	9d01      	ldr	r5, [sp, #4]
    writel(satur, iobase + offset + 0x14);
  102472:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102476:	603b      	str	r3, [r7, #0]
  102478:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  10247c:	6025      	str	r5, [r4, #0]
  10247e:	f04f 0c88 	mov.w	r12, #136	; 0x88
    writel(mode, iobase + offset + 0xc);
  102482:	600a      	str	r2, [r1, #0]
    writel(bw, iobase + offset + 0x10);
  102484:	f240 1111 	movw	r1, #273	; 0x111
    writel(mode, iobase + offset + 0xc);
  102488:	f04f 0a8c 	mov.w	r10, #140	; 0x8c
    writel(pri, iobase + offset + 0x8);
  10248c:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102490:	6031      	str	r1, [r6, #0]
  102492:	2790      	movs	r7, #144	; 0x90
    writel(satur, iobase + offset + 0x14);
  102494:	2494      	movs	r4, #148	; 0x94
    writel(ext, iobase + offset + 0x18);
  102496:	f04f 0998 	mov.w	r9, #152	; 0x98
    writel(pri, iobase + offset + 0x8);
  10249a:	f44f 7684 	mov.w	r6, #264	; 0x108
    writel(mode, iobase + offset + 0xc);
  10249e:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1024a2:	f8c8 0000 	str.w	r0, [r8]
    writel(bw, iobase + offset + 0x10);
  1024a6:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1024aa:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  1024ae:	f2cf 04cf 	movt	r4, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1024b2:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1024b6:	f44f 7886 	mov.w	r8, #268	; 0x10c
    writel(pri, iobase + offset + 0x8);
  1024ba:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1024be:	f44f 7e88 	mov.w	r14, #272	; 0x110
    writel(mode, iobase + offset + 0xc);
  1024c2:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1024c6:	f8cc 5000 	str.w	r5, [r12]
    writel(bw, iobase + offset + 0x10);
  1024ca:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1024ce:	f8ca 2000 	str.w	r2, [r10]
    writel(satur, iobase + offset + 0x14);
  1024d2:	f44f 7c8a 	mov.w	r12, #276	; 0x114
    writel(bw, iobase + offset + 0x10);
  1024d6:	6039      	str	r1, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  1024d8:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
  1024dc:	6020      	str	r0, [r4, #0]
    writel(ext, iobase + offset + 0x18);
  1024de:	f44f 7a8c 	mov.w	r10, #280	; 0x118
  1024e2:	f8c9 3000 	str.w	r3, [r9]
    writel(pri, iobase + offset + 0x8);
  1024e6:	f44f 7722 	mov.w	r7, #648	; 0x288
  1024ea:	9501      	str	r5, [sp, #4]
  1024ec:	f240 7404 	movw	r4, #1796	; 0x704
  1024f0:	6035      	str	r5, [r6, #0]
    writel(mode, iobase + offset + 0xc);
  1024f2:	f44f 7923 	mov.w	r9, #652	; 0x28c
    writel(bw, iobase + offset + 0x10);
  1024f6:	f44f 7624 	mov.w	r6, #656	; 0x290
    writel(pri, iobase + offset + 0x8);
  1024fa:	f2c8 0400 	movt	r4, #32768	; 0x8000
    writel(mode, iobase + offset + 0xc);
  1024fe:	f8c8 2000 	str.w	r2, [r8]
    writel(ext, iobase + offset + 0x18);
  102502:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102506:	f8ce 1000 	str.w	r1, [r14]
    writel(pri, iobase + offset + 0x8);
  10250a:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10250e:	f240 21d9 	movw	r1, #729	; 0x2d9
    writel(mode, iobase + offset + 0xc);
  102512:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102516:	f8cc 0000 	str.w	r0, [r12]
    writel(bw, iobase + offset + 0x10);
  10251a:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10251e:	f44f 7825 	mov.w	r8, #660	; 0x294
    writel(ext, iobase + offset + 0x18);
  102522:	f44f 7e26 	mov.w	r14, #664	; 0x298
    writel(pri, iobase + offset + 0x8);
  102526:	f44f 7c42 	mov.w	r12, #776	; 0x308
    writel(mode, iobase + offset + 0xc);
  10252a:	f44f 7543 	mov.w	r5, #780	; 0x30c
    writel(ext, iobase + offset + 0x18);
  10252e:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  102532:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102536:	603c      	str	r4, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102538:	f44f 7a00 	mov.w	r10, #512	; 0x200
    writel(mode, iobase + offset + 0xc);
  10253c:	f8c9 2000 	str.w	r2, [r9]
    writel(ext, iobase + offset + 0x18);
  102540:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102544:	6031      	str	r1, [r6, #0]
    writel(pri, iobase + offset + 0x8);
  102546:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10254a:	f44f 7744 	mov.w	r7, #784	; 0x310
    writel(mode, iobase + offset + 0xc);
  10254e:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102552:	f44f 7945 	mov.w	r9, #788	; 0x314
    writel(ext, iobase + offset + 0x18);
  102556:	f44f 7646 	mov.w	r6, #792	; 0x318
    writel(bw, iobase + offset + 0x10);
  10255a:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10255e:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  102562:	f8c8 a000 	str.w	r10, [r8]
    writel(ext, iobase + offset + 0x18);
  102566:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  10256a:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  10256e:	f44f 7862 	mov.w	r8, #904	; 0x388
  102572:	f8cc 4000 	str.w	r4, [r12]
    writel(mode, iobase + offset + 0xc);
  102576:	f44f 7e63 	mov.w	r14, #908	; 0x38c
  10257a:	602a      	str	r2, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  10257c:	f44f 7c64 	mov.w	r12, #912	; 0x390
    writel(satur, iobase + offset + 0x14);
  102580:	f44f 7565 	mov.w	r5, #916	; 0x394
    writel(pri, iobase + offset + 0x8);
  102584:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102588:	6039      	str	r1, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  10258a:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10258e:	f8c9 0000 	str.w	r0, [r9]
    writel(bw, iobase + offset + 0x10);
  102592:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102596:	6033      	str	r3, [r6, #0]
    writel(satur, iobase + offset + 0x14);
  102598:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  10259c:	f44f 7766 	mov.w	r7, #920	; 0x398
    writel(pri, iobase + offset + 0x8);
  1025a0:	f44f 6981 	mov.w	r9, #1032	; 0x408
    writel(mode, iobase + offset + 0xc);
  1025a4:	f240 460c 	movw	r6, #1036	; 0x40c
    writel(ext, iobase + offset + 0x18);
  1025a8:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1025ac:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  1025b0:	f8c8 4000 	str.w	r4, [r8]
    writel(mode, iobase + offset + 0xc);
  1025b4:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  1025b8:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  1025bc:	f44f 6882 	mov.w	r8, #1040	; 0x410
  1025c0:	f8cc 1000 	str.w	r1, [r12]
    writel(satur, iobase + offset + 0x14);
  1025c4:	f240 4e14 	movw	r14, #1044	; 0x414
  1025c8:	f8c5 a000 	str.w	r10, [r5]
    writel(ext, iobase + offset + 0x18);
  1025cc:	f44f 6c83 	mov.w	r12, #1048	; 0x418
    writel(pri, iobase + offset + 0x8);
  1025d0:	f44f 6591 	mov.w	r5, #1160	; 0x488
    writel(bw, iobase + offset + 0x10);
  1025d4:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  1025d8:	603b      	str	r3, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  1025da:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1025de:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  1025e2:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1025e6:	6032      	str	r2, [r6, #0]
    writel(pri, iobase + offset + 0x8);
  1025e8:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1025ec:	f240 478c 	movw	r7, #1164	; 0x48c
    writel(bw, iobase + offset + 0x10);
  1025f0:	f44f 6992 	mov.w	r9, #1168	; 0x490
    writel(satur, iobase + offset + 0x14);
  1025f4:	f240 4694 	movw	r6, #1172	; 0x494
    writel(mode, iobase + offset + 0xc);
  1025f8:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  1025fc:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
  102600:	f8c8 1000 	str.w	r1, [r8]
    writel(satur, iobase + offset + 0x14);
  102604:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
  102608:	f8ce 0000 	str.w	r0, [r14]
    writel(ext, iobase + offset + 0x18);
  10260c:	f44f 6893 	mov.w	r8, #1176	; 0x498
  102610:	f8cc 3000 	str.w	r3, [r12]
    writel(pri, iobase + offset + 0x8);
  102614:	f44f 6ea1 	mov.w	r14, #1288	; 0x508
  102618:	602c      	str	r4, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  10261a:	f240 5c0c 	movw	r12, #1292	; 0x50c
    writel(bw, iobase + offset + 0x10);
  10261e:	f44f 65a2 	mov.w	r5, #1296	; 0x510
    writel(ext, iobase + offset + 0x18);
  102622:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  102626:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102628:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10262c:	f8c9 1000 	str.w	r1, [r9]
    writel(mode, iobase + offset + 0xc);
  102630:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102634:	f8c6 a000 	str.w	r10, [r6]
    writel(bw, iobase + offset + 0x10);
  102638:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  10263c:	f240 5714 	movw	r7, #1300	; 0x514
    writel(ext, iobase + offset + 0x18);
  102640:	f44f 66a3 	mov.w	r6, #1304	; 0x518
    writel(satur, iobase + offset + 0x14);
  102644:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102648:	f8c8 3000 	str.w	r3, [r8]
  10264c:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  102650:	f8ce 4000 	str.w	r4, [r14]
  102654:	f44f 69b1 	mov.w	r9, #1416	; 0x588
    writel(mode, iobase + offset + 0xc);
  102658:	f8cc 2000 	str.w	r2, [r12]
  10265c:	f240 588c 	movw	r8, #1420	; 0x58c
    writel(bw, iobase + offset + 0x10);
  102660:	6029      	str	r1, [r5, #0]
  102662:	f44f 6cb2 	mov.w	r12, #1424	; 0x590
    writel(satur, iobase + offset + 0x14);
  102666:	f240 5194 	movw	r1, #1428	; 0x594
    writel(ext, iobase + offset + 0x18);
  10266a:	f44f 65b3 	mov.w	r5, #1432	; 0x598
    writel(pri, iobase + offset + 0x8);
  10266e:	f44f 6ec1 	mov.w	r14, #1544	; 0x608
  102672:	f2cf 09cf 	movt	r9, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102676:	6038      	str	r0, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  102678:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  10267c:	6033      	str	r3, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  10267e:	f2cf 0ccf 	movt	r12, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  102682:	f2cf 01cf 	movt	r1, #61647	; 0xf0cf
    writel(ext, iobase + offset + 0x18);
  102686:	f2cf 05cf 	movt	r5, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  10268a:	f240 670c 	movw	r7, #1548	; 0x60c
    writel(pri, iobase + offset + 0x8);
  10268e:	f2cf 0ecf 	movt	r14, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  102692:	f44f 66c2 	mov.w	r6, #1552	; 0x610
    writel(satur, iobase + offset + 0x14);
  102696:	f240 6a14 	movw	r10, #1556	; 0x614
    writel(mode, iobase + offset + 0xc);
  10269a:	f2cf 07cf 	movt	r7, #61647	; 0xf0cf
    writel(bw, iobase + offset + 0x10);
  10269e:	f2cf 06cf 	movt	r6, #61647	; 0xf0cf
    writel(pri, iobase + offset + 0x8);
  1026a2:	f8c9 4000 	str.w	r4, [r9]
    writel(satur, iobase + offset + 0x14);
  1026a6:	f2cf 0acf 	movt	r10, #61647	; 0xf0cf
    writel(mode, iobase + offset + 0xc);
  1026aa:	f8c8 2000 	str.w	r2, [r8]
    writel(ext, iobase + offset + 0x18);
  1026ae:	f44f 68c3 	mov.w	r8, #1560	; 0x618
    writel(bw, iobase + offset + 0x10);
  1026b2:	f8cc b000 	str.w	r11, [r12]
    writel(pri, iobase + offset + 0x8);
  1026b6:	f04f 0c08 	mov.w	r12, #8
    writel(satur, iobase + offset + 0x14);
  1026ba:	6008      	str	r0, [r1, #0]
    writel(pri, iobase + offset + 0x8);
  1026bc:	f240 3101 	movw	r1, #769	; 0x301
    writel(ext, iobase + offset + 0x18);
  1026c0:	602b      	str	r3, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  1026c2:	250c      	movs	r5, #12
    writel(pri, iobase + offset + 0x8);
  1026c4:	f8ce 4000 	str.w	r4, [r14]
    writel(bw, iobase + offset + 0x10);
  1026c8:	2410      	movs	r4, #16
    writel(mode, iobase + offset + 0xc);
  1026ca:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  1026cc:	f2c8 0100 	movt	r1, #32768	; 0x8000
    writel(bw, iobase + offset + 0x10);
  1026d0:	f8c6 b000 	str.w	r11, [r6]
    writel(ext, iobase + offset + 0x18);
  1026d4:	f2cf 08cf 	movt	r8, #61647	; 0xf0cf
    writel(satur, iobase + offset + 0x14);
  1026d8:	f8ca 0000 	str.w	r0, [r10]
    writel(pri, iobase + offset + 0x8);
  1026dc:	f2cf 1c30 	movt	r12, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  1026e0:	f240 2a0a 	movw	r10, #522	; 0x20a
    writel(mode, iobase + offset + 0xc);
  1026e4:	f2cf 1530 	movt	r5, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  1026e8:	f04f 0914 	mov.w	r9, #20
    writel(bw, iobase + offset + 0x10);
  1026ec:	f2cf 1430 	movt	r4, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1026f0:	f04f 0e18 	mov.w	r14, #24
    writel(pri, iobase + offset + 0x8);
  1026f4:	2788      	movs	r7, #136	; 0x88
  1026f6:	f240 4602 	movw	r6, #1026	; 0x402
    writel(satur, iobase + offset + 0x14);
  1026fa:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1026fe:	f8c8 3000 	str.w	r3, [r8]
    writel(pri, iobase + offset + 0x8);
  102702:	f2c8 0600 	movt	r6, #32768	; 0x8000
  102706:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  10270a:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  10270e:	602a      	str	r2, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  102710:	f2cf 1730 	movt	r7, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  102714:	f8c4 a000 	str.w	r10, [r4]
    writel(mode, iobase + offset + 0xc);
  102718:	f04f 0b8c 	mov.w	r11, #140	; 0x8c
    writel(satur, iobase + offset + 0x14);
  10271c:	2440      	movs	r4, #64	; 0x40
    writel(bw, iobase + offset + 0x10);
  10271e:	f04f 0890 	mov.w	r8, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  102722:	f2cf 1b30 	movt	r11, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  102726:	f04f 0c94 	mov.w	r12, #148	; 0x94
    writel(bw, iobase + offset + 0x10);
  10272a:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  10272e:	2598      	movs	r5, #152	; 0x98
    writel(satur, iobase + offset + 0x14);
  102730:	f2cf 1c30 	movt	r12, #61744	; 0xf130
  102734:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  102738:	f2cf 1530 	movt	r5, #61744	; 0xf130
  10273c:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  102740:	f44f 7984 	mov.w	r9, #264	; 0x108
  102744:	603e      	str	r6, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  102746:	f44f 7e86 	mov.w	r14, #268	; 0x10c
    writel(bw, iobase + offset + 0x10);
  10274a:	f44f 7788 	mov.w	r7, #272	; 0x110
    writel(pri, iobase + offset + 0x8);
  10274e:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  102752:	f8cb 2000 	str.w	r2, [r11]
  102756:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(bw, iobase + offset + 0x10);
  10275a:	f8c8 a000 	str.w	r10, [r8]
  10275e:	f2cf 1730 	movt	r7, #61744	; 0xf130
  102762:	f240 1aeb 	movw	r10, #491	; 0x1eb
    writel(satur, iobase + offset + 0x14);
  102766:	f44f 788a 	mov.w	r8, #276	; 0x114
  10276a:	f8cc 4000 	str.w	r4, [r12]
  10276e:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  102772:	602b      	str	r3, [r5, #0]
  102774:	f44f 7c8c 	mov.w	r12, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  102778:	f44f 75c4 	mov.w	r5, #392	; 0x188
    writel(ext, iobase + offset + 0x18);
  10277c:	f2cf 1c30 	movt	r12, #61744	; 0xf130
    writel(pri, iobase + offset + 0x8);
  102780:	f8c9 6000 	str.w	r6, [r9]
  102784:	f2cf 1530 	movt	r5, #61744	; 0xf130
    writel(mode, iobase + offset + 0xc);
  102788:	f8ce 2000 	str.w	r2, [r14]
  10278c:	f44f 79c6 	mov.w	r9, #396	; 0x18c
    writel(bw, iobase + offset + 0x10);
  102790:	f8c7 a000 	str.w	r10, [r7]
  102794:	f44f 7ec8 	mov.w	r14, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  102798:	f44f 77ca 	mov.w	r7, #404	; 0x194
    writel(mode, iobase + offset + 0xc);
  10279c:	f2cf 1930 	movt	r9, #61744	; 0xf130
    writel(satur, iobase + offset + 0x14);
  1027a0:	f8c8 4000 	str.w	r4, [r8]
    writel(bw, iobase + offset + 0x10);
  1027a4:	f2cf 1e30 	movt	r14, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1027a8:	f44f 78cc 	mov.w	r8, #408	; 0x198
    writel(satur, iobase + offset + 0x14);
  1027ac:	f2cf 1730 	movt	r7, #61744	; 0xf130
    writel(ext, iobase + offset + 0x18);
  1027b0:	f8cc 3000 	str.w	r3, [r12]
  1027b4:	f2cf 1830 	movt	r8, #61744	; 0xf130
    writel(pri, iobase + offset + 0x8);
  1027b8:	602e      	str	r6, [r5, #0]
  1027ba:	f04f 0c08 	mov.w	r12, #8
    writel(mode, iobase + offset + 0xc);
  1027be:	250c      	movs	r5, #12
    writel(pri, iobase + offset + 0x8);
  1027c0:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  1027c4:	f8c9 2000 	str.w	r2, [r9]
  1027c8:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1027cc:	f8ce a000 	str.w	r10, [r14]
  1027d0:	f04f 0910 	mov.w	r9, #16
    writel(satur, iobase + offset + 0x14);
  1027d4:	603c      	str	r4, [r7, #0]
  1027d6:	f04f 0e14 	mov.w	r14, #20
    writel(ext, iobase + offset + 0x18);
  1027da:	2718      	movs	r7, #24
    writel(pri, iobase + offset + 0x8);
  1027dc:	f04f 0a88 	mov.w	r10, #136	; 0x88
    writel(ext, iobase + offset + 0x18);
  1027e0:	f8c8 3000 	str.w	r3, [r8]
    writel(bw, iobase + offset + 0x10);
  1027e4:	f2cf 1947 	movt	r9, #61767	; 0xf147
  1027e8:	f44f 7890 	mov.w	r8, #288	; 0x120
    writel(satur, iobase + offset + 0x14);
  1027ec:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1027f0:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1027f4:	f8cc 1000 	str.w	r1, [r12]
  1027f8:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  1027fc:	602a      	str	r2, [r5, #0]
  1027fe:	f04f 0c8c 	mov.w	r12, #140	; 0x8c
    writel(bw, iobase + offset + 0x10);
  102802:	2590      	movs	r5, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  102804:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102808:	f8c9 8000 	str.w	r8, [r9]
  10280c:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  102810:	f8ce 4000 	str.w	r4, [r14]
  102814:	f04f 0994 	mov.w	r9, #148	; 0x94
    writel(ext, iobase + offset + 0x18);
  102818:	603b      	str	r3, [r7, #0]
  10281a:	f04f 0e98 	mov.w	r14, #152	; 0x98
    writel(pri, iobase + offset + 0x8);
  10281e:	f8ca 1000 	str.w	r1, [r10]
  102822:	f44f 7784 	mov.w	r7, #264	; 0x108
    writel(mode, iobase + offset + 0xc);
  102826:	f44f 7a86 	mov.w	r10, #268	; 0x10c
    writel(satur, iobase + offset + 0x14);
  10282a:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  10282e:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102832:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(mode, iobase + offset + 0xc);
  102836:	f8cc 2000 	str.w	r2, [r12]
  10283a:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  10283e:	602b      	str	r3, [r5, #0]
  102840:	f44f 7c88 	mov.w	r12, #272	; 0x110
    writel(satur, iobase + offset + 0x14);
  102844:	f44f 758a 	mov.w	r5, #276	; 0x114
    writel(bw, iobase + offset + 0x10);
  102848:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  10284c:	f8c9 4000 	str.w	r4, [r9]
  102850:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  102854:	f8ce 3000 	str.w	r3, [r14]
  102858:	f44f 798c 	mov.w	r9, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  10285c:	6039      	str	r1, [r7, #0]
  10285e:	f44f 7ec4 	mov.w	r14, #392	; 0x188
    writel(mode, iobase + offset + 0xc);
  102862:	f8ca 2000 	str.w	r2, [r10]
  102866:	f44f 77c6 	mov.w	r7, #396	; 0x18c
    writel(bw, iobase + offset + 0x10);
  10286a:	f04f 0a30 	mov.w	r10, #48	; 0x30
    writel(ext, iobase + offset + 0x18);
  10286e:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102872:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102876:	f8cc a000 	str.w	r10, [r12]
    writel(mode, iobase + offset + 0xc);
  10287a:	f2cf 1747 	movt	r7, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  10287e:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  102880:	f44f 7cc8 	mov.w	r12, #400	; 0x190
    writel(satur, iobase + offset + 0x14);
  102884:	f44f 75ca 	mov.w	r5, #404	; 0x194
    writel(bw, iobase + offset + 0x10);
  102888:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  10288c:	f8c9 3000 	str.w	r3, [r9]
    writel(satur, iobase + offset + 0x14);
  102890:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102894:	f8ce 1000 	str.w	r1, [r14]
    writel(ext, iobase + offset + 0x18);
  102898:	f44f 7acc 	mov.w	r10, #408	; 0x198
    writel(mode, iobase + offset + 0xc);
  10289c:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  10289e:	f44f 7902 	mov.w	r9, #520	; 0x208
    writel(bw, iobase + offset + 0x10);
  1028a2:	2790      	movs	r7, #144	; 0x90
    writel(mode, iobase + offset + 0xc);
  1028a4:	f44f 7e03 	mov.w	r14, #524	; 0x20c
    writel(ext, iobase + offset + 0x18);
  1028a8:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028ac:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1028b0:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  1028b4:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1028b8:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1028ba:	f44f 7c04 	mov.w	r12, #528	; 0x210
    writel(satur, iobase + offset + 0x14);
  1028be:	f44f 7505 	mov.w	r5, #532	; 0x214
    writel(bw, iobase + offset + 0x10);
  1028c2:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  1028c6:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  1028ca:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028ce:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  1028d2:	f44f 7a06 	mov.w	r10, #536	; 0x218
    writel(mode, iobase + offset + 0xc);
  1028d6:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  1028da:	f44f 7922 	mov.w	r9, #648	; 0x288
    writel(mode, iobase + offset + 0xc);
  1028de:	f44f 7e23 	mov.w	r14, #652	; 0x28c
    writel(ext, iobase + offset + 0x18);
  1028e2:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  1028e6:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  1028ea:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  1028ee:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  1028f2:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  1028f4:	f44f 7c24 	mov.w	r12, #656	; 0x290
    writel(satur, iobase + offset + 0x14);
  1028f8:	f44f 7525 	mov.w	r5, #660	; 0x294
    writel(bw, iobase + offset + 0x10);
  1028fc:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  102900:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  102904:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102908:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  10290c:	f44f 7a26 	mov.w	r10, #664	; 0x298
    writel(mode, iobase + offset + 0xc);
  102910:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  102914:	f44f 7942 	mov.w	r9, #776	; 0x308
    writel(mode, iobase + offset + 0xc);
  102918:	f44f 7e43 	mov.w	r14, #780	; 0x30c
    writel(ext, iobase + offset + 0x18);
  10291c:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102920:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102924:	f8cc 7000 	str.w	r7, [r12]
    writel(mode, iobase + offset + 0xc);
  102928:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  10292c:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  10292e:	f44f 7c44 	mov.w	r12, #784	; 0x310
    writel(satur, iobase + offset + 0x14);
  102932:	f44f 7545 	mov.w	r5, #788	; 0x314
    writel(bw, iobase + offset + 0x10);
  102936:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  10293a:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  10293e:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  102942:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  102946:	f44f 7a46 	mov.w	r10, #792	; 0x318
    writel(mode, iobase + offset + 0xc);
  10294a:	f8ce 2000 	str.w	r2, [r14]
    writel(pri, iobase + offset + 0x8);
  10294e:	f44f 7962 	mov.w	r9, #904	; 0x388
    writel(mode, iobase + offset + 0xc);
  102952:	f44f 7e63 	mov.w	r14, #908	; 0x38c
    writel(ext, iobase + offset + 0x18);
  102956:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  10295a:	f2cf 1947 	movt	r9, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  10295e:	f8cc 3000 	str.w	r3, [r12]
    writel(mode, iobase + offset + 0xc);
  102962:	f2cf 1e47 	movt	r14, #61767	; 0xf147
    writel(satur, iobase + offset + 0x14);
  102966:	602c      	str	r4, [r5, #0]
    writel(bw, iobase + offset + 0x10);
  102968:	f44f 7c64 	mov.w	r12, #912	; 0x390
    writel(satur, iobase + offset + 0x14);
  10296c:	f44f 7565 	mov.w	r5, #916	; 0x394
    writel(bw, iobase + offset + 0x10);
  102970:	f2cf 1c47 	movt	r12, #61767	; 0xf147
    writel(ext, iobase + offset + 0x18);
  102974:	f8ca 3000 	str.w	r3, [r10]
    writel(satur, iobase + offset + 0x14);
  102978:	f2cf 1547 	movt	r5, #61767	; 0xf147
    writel(pri, iobase + offset + 0x8);
  10297c:	f8c9 1000 	str.w	r1, [r9]
    writel(ext, iobase + offset + 0x18);
  102980:	f44f 7a66 	mov.w	r10, #920	; 0x398
    writel(mode, iobase + offset + 0xc);
  102984:	f8ce 2000 	str.w	r2, [r14]
    writel(bw, iobase + offset + 0x10);
  102988:	f04f 0ed8 	mov.w	r14, #216	; 0xd8
    writel(pri, iobase + offset + 0x8);
  10298c:	f242 1908 	movw	r9, #8456	; 0x2108
    writel(ext, iobase + offset + 0x18);
  102990:	f2cf 1a47 	movt	r10, #61767	; 0xf147
    writel(bw, iobase + offset + 0x10);
  102994:	f8cc e000 	str.w	r14, [r12]
    writel(pri, iobase + offset + 0x8);
  102998:	f240 4c03 	movw	r12, #1027	; 0x403
    writel(satur, iobase + offset + 0x14);
  10299c:	602c      	str	r4, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  10299e:	f242 150c 	movw	r5, #8460	; 0x210c
    writel(pri, iobase + offset + 0x8);
  1029a2:	f2c8 0c00 	movt	r12, #32768	; 0x8000
  1029a6:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  1029aa:	f242 1410 	movw	r4, #8464	; 0x2110
    writel(mode, iobase + offset + 0xc);
  1029ae:	f2cf 154c 	movt	r5, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029b2:	f8ca 3000 	str.w	r3, [r10]
    writel(bw, iobase + offset + 0x10);
  1029b6:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  1029ba:	f242 1e14 	movw	r14, #8468	; 0x2114
    writel(ext, iobase + offset + 0x18);
  1029be:	f242 1b18 	movw	r11, #8472	; 0x2118
    writel(pri, iobase + offset + 0x8);
  1029c2:	f242 1a88 	movw	r10, #8584	; 0x2188
    writel(satur, iobase + offset + 0x14);
  1029c6:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  1029ca:	f8c9 c000 	str.w	r12, [r9]
    writel(ext, iobase + offset + 0x18);
  1029ce:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  1029d2:	602a      	str	r2, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  1029d4:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  1029d8:	2510      	movs	r5, #16
    writel(mode, iobase + offset + 0xc);
  1029da:	f242 198c 	movw	r9, #8588	; 0x218c
    writel(bw, iobase + offset + 0x10);
  1029de:	6023      	str	r3, [r4, #0]
  1029e0:	f242 1490 	movw	r4, #8592	; 0x2190
    writel(satur, iobase + offset + 0x14);
  1029e4:	f8ce 5000 	str.w	r5, [r14]
    writel(mode, iobase + offset + 0xc);
  1029e8:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  1029ec:	f8cb 3000 	str.w	r3, [r11]
    writel(bw, iobase + offset + 0x10);
  1029f0:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  1029f4:	f8ca c000 	str.w	r12, [r10]
    writel(satur, iobase + offset + 0x14);
  1029f8:	f242 1e94 	movw	r14, #8596	; 0x2194
    writel(ext, iobase + offset + 0x18);
  1029fc:	f242 1b98 	movw	r11, #8600	; 0x2198
    writel(pri, iobase + offset + 0x8);
  102a00:	f242 2a08 	movw	r10, #8712	; 0x2208
    writel(satur, iobase + offset + 0x14);
  102a04:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a08:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a0c:	f8c9 2000 	str.w	r2, [r9]
    writel(pri, iobase + offset + 0x8);
  102a10:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102a14:	6023      	str	r3, [r4, #0]
    writel(mode, iobase + offset + 0xc);
  102a16:	f242 290c 	movw	r9, #8716	; 0x220c
    writel(bw, iobase + offset + 0x10);
  102a1a:	f242 2410 	movw	r4, #8720	; 0x2210
    writel(mode, iobase + offset + 0xc);
  102a1e:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a22:	f8ce 5000 	str.w	r5, [r14]
    writel(bw, iobase + offset + 0x10);
  102a26:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a2a:	f8cb 3000 	str.w	r3, [r11]
    writel(satur, iobase + offset + 0x14);
  102a2e:	f242 2e14 	movw	r14, #8724	; 0x2214
    writel(pri, iobase + offset + 0x8);
  102a32:	f8ca c000 	str.w	r12, [r10]
    writel(ext, iobase + offset + 0x18);
  102a36:	f242 2b18 	movw	r11, #8728	; 0x2218
    writel(pri, iobase + offset + 0x8);
  102a3a:	f242 2a88 	movw	r10, #8840	; 0x2288
    writel(satur, iobase + offset + 0x14);
  102a3e:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a42:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a46:	f8c9 2000 	str.w	r2, [r9]
    writel(pri, iobase + offset + 0x8);
  102a4a:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102a4e:	6027      	str	r7, [r4, #0]
    writel(mode, iobase + offset + 0xc);
  102a50:	f242 298c 	movw	r9, #8844	; 0x228c
    writel(bw, iobase + offset + 0x10);
  102a54:	f242 2490 	movw	r4, #8848	; 0x2290
    writel(mode, iobase + offset + 0xc);
  102a58:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a5c:	f8ce 5000 	str.w	r5, [r14]
    writel(bw, iobase + offset + 0x10);
  102a60:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a64:	f8cb 3000 	str.w	r3, [r11]
    writel(satur, iobase + offset + 0x14);
  102a68:	f242 2e94 	movw	r14, #8852	; 0x2294
    writel(pri, iobase + offset + 0x8);
  102a6c:	f8ca c000 	str.w	r12, [r10]
  102a70:	f242 3b08 	movw	r11, #8968	; 0x2308
    writel(ext, iobase + offset + 0x18);
  102a74:	f242 2c98 	movw	r12, #8856	; 0x2298
    writel(mode, iobase + offset + 0xc);
  102a78:	f242 3a0c 	movw	r10, #8972	; 0x230c
    writel(satur, iobase + offset + 0x14);
  102a7c:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102a80:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102a84:	f2cf 1b4c 	movt	r11, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102a88:	f8c9 2000 	str.w	r2, [r9]
  102a8c:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(bw, iobase + offset + 0x10);
  102a90:	6027      	str	r7, [r4, #0]
  102a92:	f242 3410 	movw	r4, #8976	; 0x2310
    writel(pri, iobase + offset + 0x8);
  102a96:	9f01      	ldr	r7, [sp, #4]
    writel(bw, iobase + offset + 0x10);
  102a98:	f2cf 144c 	movt	r4, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102a9c:	f8ce 5000 	str.w	r5, [r14]
  102aa0:	f242 3914 	movw	r9, #8980	; 0x2314
    writel(ext, iobase + offset + 0x18);
  102aa4:	f8cc 3000 	str.w	r3, [r12]
    writel(satur, iobase + offset + 0x14);
  102aa8:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102aac:	f8cb 7000 	str.w	r7, [r11]
    writel(ext, iobase + offset + 0x18);
  102ab0:	f242 3e18 	movw	r14, #8984	; 0x2318
    writel(mode, iobase + offset + 0xc);
  102ab4:	f8ca 2000 	str.w	r2, [r10]
    writel(bw, iobase + offset + 0x10);
  102ab8:	f04f 0a1c 	mov.w	r10, #28
    writel(pri, iobase + offset + 0x8);
  102abc:	f242 4c88 	movw	r12, #9352	; 0x2488
    writel(mode, iobase + offset + 0xc);
  102ac0:	f242 478c 	movw	r7, #9356	; 0x248c
    writel(bw, iobase + offset + 0x10);
  102ac4:	f8c4 a000 	str.w	r10, [r4]
    writel(satur, iobase + offset + 0x14);
  102ac8:	2408      	movs	r4, #8
    writel(bw, iobase + offset + 0x10);
  102aca:	f242 4a90 	movw	r10, #9360	; 0x2490
    writel(ext, iobase + offset + 0x18);
  102ace:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102ad2:	f8c9 4000 	str.w	r4, [r9]
    writel(pri, iobase + offset + 0x8);
  102ad6:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102ada:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102ade:	f242 4994 	movw	r9, #9364	; 0x2494
    writel(bw, iobase + offset + 0x10);
  102ae2:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102ae6:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102aea:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102aee:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102af2:	f242 4e98 	movw	r14, #9368	; 0x2498
    writel(mode, iobase + offset + 0xc);
  102af6:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102af8:	f242 5c08 	movw	r12, #9480	; 0x2508
    writel(bw, iobase + offset + 0x10);
  102afc:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102b00:	f242 570c 	movw	r7, #9484	; 0x250c
    writel(bw, iobase + offset + 0x10);
  102b04:	f242 5a10 	movw	r10, #9488	; 0x2510
    writel(ext, iobase + offset + 0x18);
  102b08:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102b0c:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102b10:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102b14:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102b18:	f242 5914 	movw	r9, #9492	; 0x2514
    writel(bw, iobase + offset + 0x10);
  102b1c:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102b20:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102b24:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102b28:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102b2c:	f242 5e18 	movw	r14, #9496	; 0x2518
    writel(mode, iobase + offset + 0xc);
  102b30:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102b32:	f242 5c88 	movw	r12, #9608	; 0x2588
    writel(bw, iobase + offset + 0x10);
  102b36:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102b3a:	f242 578c 	movw	r7, #9612	; 0x258c
    writel(bw, iobase + offset + 0x10);
  102b3e:	f242 5a90 	movw	r10, #9616	; 0x2590
    writel(ext, iobase + offset + 0x18);
  102b42:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102b46:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102b4a:	f2cf 1c4c 	movt	r12, #61772	; 0xf14c
    writel(mode, iobase + offset + 0xc);
  102b4e:	f2cf 174c 	movt	r7, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102b52:	f242 5994 	movw	r9, #9620	; 0x2594
    writel(bw, iobase + offset + 0x10);
  102b56:	f2cf 1a4c 	movt	r10, #61772	; 0xf14c
    writel(ext, iobase + offset + 0x18);
  102b5a:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102b5e:	f2cf 194c 	movt	r9, #61772	; 0xf14c
    writel(pri, iobase + offset + 0x8);
  102b62:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102b66:	f242 5e98 	movw	r14, #9624	; 0x2598
    writel(mode, iobase + offset + 0xc);
  102b6a:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102b6c:	f44f 6c91 	mov.w	r12, #1160	; 0x488
    writel(bw, iobase + offset + 0x10);
  102b70:	f8ca 8000 	str.w	r8, [r10]
    writel(mode, iobase + offset + 0xc);
  102b74:	f240 478c 	movw	r7, #1164	; 0x48c
    writel(bw, iobase + offset + 0x10);
  102b78:	f44f 6a92 	mov.w	r10, #1168	; 0x490
    writel(ext, iobase + offset + 0x18);
  102b7c:	f2cf 1e4c 	movt	r14, #61772	; 0xf14c
    writel(satur, iobase + offset + 0x14);
  102b80:	f8c9 0000 	str.w	r0, [r9]
    writel(pri, iobase + offset + 0x8);
  102b84:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102b88:	20f5      	movs	r0, #245	; 0xf5
    writel(mode, iobase + offset + 0xc);
  102b8a:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102b8e:	f240 4b94 	movw	r11, #1172	; 0x494
    writel(bw, iobase + offset + 0x10);
  102b92:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102b96:	f44f 6993 	mov.w	r9, #1176	; 0x498
    writel(pri, iobase + offset + 0x8);
  102b9a:	f44f 68a1 	mov.w	r8, #1288	; 0x508
    writel(ext, iobase + offset + 0x18);
  102b9e:	f8ce 3000 	str.w	r3, [r14]
    writel(satur, iobase + offset + 0x14);
  102ba2:	f2cf 0b6c 	movt	r11, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102ba6:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102baa:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102bae:	603a      	str	r2, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102bb0:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102bb4:	f8ca 0000 	str.w	r0, [r10]
    writel(mode, iobase + offset + 0xc);
  102bb8:	f240 5e0c 	movw	r14, #1292	; 0x50c
    writel(satur, iobase + offset + 0x14);
  102bbc:	f04f 0a20 	mov.w	r10, #32
    writel(mode, iobase + offset + 0xc);
  102bc0:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102bc4:	f44f 6ca2 	mov.w	r12, #1296	; 0x510
    writel(satur, iobase + offset + 0x14);
  102bc8:	f240 5714 	movw	r7, #1300	; 0x514
  102bcc:	f8cb a000 	str.w	r10, [r11]
    writel(bw, iobase + offset + 0x10);
  102bd0:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102bd4:	f8c9 3000 	str.w	r3, [r9]
    writel(satur, iobase + offset + 0x14);
  102bd8:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102bdc:	f8c8 6000 	str.w	r6, [r8]
    writel(bw, iobase + offset + 0x10);
  102be0:	f04f 084c 	mov.w	r8, #76	; 0x4c
    writel(mode, iobase + offset + 0xc);
  102be4:	f8ce 2000 	str.w	r2, [r14]
    writel(ext, iobase + offset + 0x18);
  102be8:	f44f 6ba3 	mov.w	r11, #1304	; 0x518
    writel(pri, iobase + offset + 0x8);
  102bec:	f44f 66b1 	mov.w	r6, #1416	; 0x588
    writel(mode, iobase + offset + 0xc);
  102bf0:	f240 5e8c 	movw	r14, #1420	; 0x58c
    writel(bw, iobase + offset + 0x10);
  102bf4:	f8cc 8000 	str.w	r8, [r12]
    writel(ext, iobase + offset + 0x18);
  102bf8:	f2cf 0b6c 	movt	r11, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102bfc:	603d      	str	r5, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102bfe:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102c02:	f44f 6cb2 	mov.w	r12, #1424	; 0x590
    writel(mode, iobase + offset + 0xc);
  102c06:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c0a:	f240 5894 	movw	r8, #1428	; 0x594
    writel(ext, iobase + offset + 0x18);
  102c0e:	f44f 67b3 	mov.w	r7, #1432	; 0x598
    writel(pri, iobase + offset + 0x8);
  102c12:	f44f 65c1 	mov.w	r5, #1544	; 0x608
    writel(mode, iobase + offset + 0xc);
  102c16:	f240 690c 	movw	r9, #1548	; 0x60c
    writel(bw, iobase + offset + 0x10);
  102c1a:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c1e:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102c22:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102c26:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102c2a:	f8cb 3000 	str.w	r3, [r11]
    writel(mode, iobase + offset + 0xc);
  102c2e:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102c32:	6031      	str	r1, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  102c34:	f44f 66c2 	mov.w	r6, #1552	; 0x610
    writel(mode, iobase + offset + 0xc);
  102c38:	f8ce 2000 	str.w	r2, [r14]
    writel(satur, iobase + offset + 0x14);
  102c3c:	f240 6e14 	movw	r14, #1556	; 0x614
    writel(bw, iobase + offset + 0x10);
  102c40:	f8cc 0000 	str.w	r0, [r12]
  102c44:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c48:	f8c8 a000 	str.w	r10, [r8]
  102c4c:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102c50:	603b      	str	r3, [r7, #0]
  102c52:	f44f 6cc3 	mov.w	r12, #1560	; 0x618
    writel(pri, iobase + offset + 0x8);
  102c56:	6029      	str	r1, [r5, #0]
    writel(ext, iobase + offset + 0x18);
  102c58:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102c5c:	f8c9 2000 	str.w	r2, [r9]
    writel(bw, iobase + offset + 0x10);
  102c60:	f04f 097a 	mov.w	r9, #122	; 0x7a
    writel(pri, iobase + offset + 0x8);
  102c64:	f44f 68d1 	mov.w	r8, #1672	; 0x688
    writel(mode, iobase + offset + 0xc);
  102c68:	f240 678c 	movw	r7, #1676	; 0x68c
    writel(bw, iobase + offset + 0x10);
  102c6c:	f8c6 9000 	str.w	r9, [r6]
    writel(pri, iobase + offset + 0x8);
  102c70:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c74:	f8ce a000 	str.w	r10, [r14]
    writel(mode, iobase + offset + 0xc);
  102c78:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102c7c:	f44f 65d2 	mov.w	r5, #1680	; 0x690
    writel(satur, iobase + offset + 0x14);
  102c80:	f240 6094 	movw	r0, #1684	; 0x694
    writel(ext, iobase + offset + 0x18);
  102c84:	f44f 66d3 	mov.w	r6, #1688	; 0x698
    writel(pri, iobase + offset + 0x8);
  102c88:	f44f 6ee1 	mov.w	r14, #1800	; 0x708
    writel(ext, iobase + offset + 0x18);
  102c8c:	f8cc 3000 	str.w	r3, [r12]
    writel(bw, iobase + offset + 0x10);
  102c90:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102c94:	f2cf 006c 	movt	r0, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102c98:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102c9c:	f240 7c0c 	movw	r12, #1804	; 0x70c
    writel(pri, iobase + offset + 0x8);
  102ca0:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102ca4:	f8c8 1000 	str.w	r1, [r8]
    writel(mode, iobase + offset + 0xc);
  102ca8:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102cac:	603a      	str	r2, [r7, #0]
    writel(bw, iobase + offset + 0x10);
  102cae:	f44f 68e2 	mov.w	r8, #1808	; 0x710
    writel(satur, iobase + offset + 0x14);
  102cb2:	f240 7714 	movw	r7, #1812	; 0x714
    writel(bw, iobase + offset + 0x10);
  102cb6:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102cba:	f8c5 9000 	str.w	r9, [r5]
    writel(satur, iobase + offset + 0x14);
  102cbe:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102cc2:	f8c0 a000 	str.w	r10, [r0]
    writel(ext, iobase + offset + 0x18);
  102cc6:	f44f 65e3 	mov.w	r5, #1816	; 0x718
    writel(bw, iobase + offset + 0x10);
  102cca:	203d      	movs	r0, #61	; 0x3d
    writel(pri, iobase + offset + 0x8);
  102ccc:	f44f 69f1 	mov.w	r9, #1928	; 0x788
    writel(ext, iobase + offset + 0x18);
  102cd0:	6033      	str	r3, [r6, #0]
    writel(mode, iobase + offset + 0xc);
  102cd2:	f240 768c 	movw	r6, #1932	; 0x78c
    writel(pri, iobase + offset + 0x8);
  102cd6:	f8ce 1000 	str.w	r1, [r14]
    writel(bw, iobase + offset + 0x10);
  102cda:	f44f 6ef2 	mov.w	r14, #1936	; 0x790
    writel(mode, iobase + offset + 0xc);
  102cde:	f8cc 2000 	str.w	r2, [r12]
    writel(ext, iobase + offset + 0x18);
  102ce2:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102ce6:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102cea:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102cee:	f240 7c94 	movw	r12, #1940	; 0x794
    writel(bw, iobase + offset + 0x10);
  102cf2:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102cf6:	f8c8 0000 	str.w	r0, [r8]
    writel(satur, iobase + offset + 0x14);
  102cfa:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102cfe:	f8c7 a000 	str.w	r10, [r7]
    writel(ext, iobase + offset + 0x18);
  102d02:	f44f 68f3 	mov.w	r8, #1944	; 0x798
    writel(pri, iobase + offset + 0x8);
  102d06:	f640 0708 	movw	r7, #2056	; 0x808
    writel(ext, iobase + offset + 0x18);
  102d0a:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102d0e:	602b      	str	r3, [r5, #0]
    writel(pri, iobase + offset + 0x8);
  102d10:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102d14:	f8c9 1000 	str.w	r1, [r9]
    writel(mode, iobase + offset + 0xc);
  102d18:	f640 0a0c 	movw	r10, #2060	; 0x80c
  102d1c:	6032      	str	r2, [r6, #0]
    writel(bw, iobase + offset + 0x10);
  102d1e:	f44f 6501 	mov.w	r5, #2064	; 0x810
  102d22:	f8ce 0000 	str.w	r0, [r14]
    writel(satur, iobase + offset + 0x14);
  102d26:	f640 0914 	movw	r9, #2068	; 0x814
    writel(ext, iobase + offset + 0x18);
  102d2a:	f640 0e18 	movw	r14, #2072	; 0x818
    writel(mode, iobase + offset + 0xc);
  102d2e:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102d32:	f8cc 4000 	str.w	r4, [r12]
    writel(bw, iobase + offset + 0x10);
  102d36:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102d3a:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d3e:	f640 0c88 	movw	r12, #2184	; 0x888
    writel(ext, iobase + offset + 0x18);
  102d42:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102d46:	f8c8 3000 	str.w	r3, [r8]
    writel(pri, iobase + offset + 0x8);
  102d4a:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102d4e:	6039      	str	r1, [r7, #0]
    writel(mode, iobase + offset + 0xc);
  102d50:	f640 088c 	movw	r8, #2188	; 0x88c
    writel(bw, iobase + offset + 0x10);
  102d54:	f44f 6709 	mov.w	r7, #2192	; 0x890
    writel(mode, iobase + offset + 0xc);
  102d58:	f2cf 086c 	movt	r8, #61548	; 0xf06c
  102d5c:	f8ca 2000 	str.w	r2, [r10]
    writel(bw, iobase + offset + 0x10);
  102d60:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102d64:	6028      	str	r0, [r5, #0]
    writel(satur, iobase + offset + 0x14);
  102d66:	f640 0694 	movw	r6, #2196	; 0x894
  102d6a:	f8c9 4000 	str.w	r4, [r9]
    writel(ext, iobase + offset + 0x18);
  102d6e:	f640 0a98 	movw	r10, #2200	; 0x898
  102d72:	f8ce 3000 	str.w	r3, [r14]
    writel(pri, iobase + offset + 0x8);
  102d76:	f640 1908 	movw	r9, #2312	; 0x908
    writel(mode, iobase + offset + 0xc);
  102d7a:	f640 1e0c 	movw	r14, #2316	; 0x90c
    writel(satur, iobase + offset + 0x14);
  102d7e:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d82:	f8cc 1000 	str.w	r1, [r12]
    writel(ext, iobase + offset + 0x18);
  102d86:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102d8a:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102d8e:	f44f 6c11 	mov.w	r12, #2320	; 0x910
    writel(mode, iobase + offset + 0xc);
  102d92:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
  102d96:	f8c8 2000 	str.w	r2, [r8]
    writel(bw, iobase + offset + 0x10);
  102d9a:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102d9e:	6038      	str	r0, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102da0:	f640 1814 	movw	r8, #2324	; 0x914
    writel(ext, iobase + offset + 0x18);
  102da4:	f640 1518 	movw	r5, #2328	; 0x918
    writel(pri, iobase + offset + 0x8);
  102da8:	f640 1788 	movw	r7, #2440	; 0x988
    writel(satur, iobase + offset + 0x14);
  102dac:	6034      	str	r4, [r6, #0]
  102dae:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102db2:	f8ca 3000 	str.w	r3, [r10]
  102db6:	f2cf 056c 	movt	r5, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102dba:	f8c9 1000 	str.w	r1, [r9]
  102dbe:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102dc2:	f8ce 2000 	str.w	r2, [r14]
  102dc6:	f640 1a8c 	movw	r10, #2444	; 0x98c
    writel(bw, iobase + offset + 0x10);
  102dca:	f44f 6919 	mov.w	r9, #2448	; 0x990
    writel(satur, iobase + offset + 0x14);
  102dce:	f640 1e94 	movw	r14, #2452	; 0x994
    writel(bw, iobase + offset + 0x10);
  102dd2:	f8cc 0000 	str.w	r0, [r12]
    writel(mode, iobase + offset + 0xc);
  102dd6:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102dda:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102dde:	f640 1c98 	movw	r12, #2456	; 0x998
    writel(satur, iobase + offset + 0x14);
  102de2:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102de6:	f640 2608 	movw	r6, #2568	; 0xa08
    writel(ext, iobase + offset + 0x18);
  102dea:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102dee:	f8c8 4000 	str.w	r4, [r8]
    writel(pri, iobase + offset + 0x8);
  102df2:	f2cf 066c 	movt	r6, #61548	; 0xf06c
    writel(ext, iobase + offset + 0x18);
  102df6:	602b      	str	r3, [r5, #0]
    writel(mode, iobase + offset + 0xc);
  102df8:	f640 280c 	movw	r8, #2572	; 0xa0c
    writel(pri, iobase + offset + 0x8);
  102dfc:	6039      	str	r1, [r7, #0]
    writel(bw, iobase + offset + 0x10);
  102dfe:	f44f 6721 	mov.w	r7, #2576	; 0xa10
    writel(mode, iobase + offset + 0xc);
  102e02:	f8ca 2000 	str.w	r2, [r10]
  102e06:	f2cf 086c 	movt	r8, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102e0a:	f8c9 0000 	str.w	r0, [r9]
  102e0e:	f2cf 076c 	movt	r7, #61548	; 0xf06c
    writel(satur, iobase + offset + 0x14);
  102e12:	f8ce 4000 	str.w	r4, [r14]
  102e16:	f640 2a14 	movw	r10, #2580	; 0xa14
    writel(ext, iobase + offset + 0x18);
  102e1a:	f640 2918 	movw	r9, #2584	; 0xa18
    writel(pri, iobase + offset + 0x8);
  102e1e:	f640 2e88 	movw	r14, #2696	; 0xa88
    writel(ext, iobase + offset + 0x18);
  102e22:	f8cc 3000 	str.w	r3, [r12]
    writel(satur, iobase + offset + 0x14);
  102e26:	f2cf 0a6c 	movt	r10, #61548	; 0xf06c
    writel(pri, iobase + offset + 0x8);
  102e2a:	6031      	str	r1, [r6, #0]
    writel(ext, iobase + offset + 0x18);
  102e2c:	f2cf 096c 	movt	r9, #61548	; 0xf06c
    writel(mode, iobase + offset + 0xc);
  102e30:	f640 258c 	movw	r5, #2700	; 0xa8c
    writel(pri, iobase + offset + 0x8);
  102e34:	f2cf 0e6c 	movt	r14, #61548	; 0xf06c
    writel(bw, iobase + offset + 0x10);
  102e38:	f44f 6629 	mov.w	r6, #2704	; 0xa90
    writel(mode, iobase + offset + 0xc);
  102e3c:	f2cf 056c 	movt	r5, #61548	; 0xf06c
  102e40:	f8c8 2000 	str.w	r2, [r8]
    writel(bw, iobase + offset + 0x10);
  102e44:	f2cf 066c 	movt	r6, #61548	; 0xf06c
  102e48:	6038      	str	r0, [r7, #0]
    writel(satur, iobase + offset + 0x14);
  102e4a:	f640 2c94 	movw	r12, #2708	; 0xa94
    writel(ext, iobase + offset + 0x18);
  102e4e:	f640 2798 	movw	r7, #2712	; 0xa98
    writel(satur, iobase + offset + 0x14);
  102e52:	f2cf 0c6c 	movt	r12, #61548	; 0xf06c
  102e56:	f8ca 4000 	str.w	r4, [r10]
    writel(ext, iobase + offset + 0x18);
  102e5a:	f2cf 076c 	movt	r7, #61548	; 0xf06c
  102e5e:	f8c9 3000 	str.w	r3, [r9]
    writel(pri, iobase + offset + 0x8);
  102e62:	f44f 7884 	mov.w	r8, #264	; 0x108
  102e66:	f8ce 1000 	str.w	r1, [r14]
    writel(mode, iobase + offset + 0xc);
  102e6a:	f44f 7986 	mov.w	r9, #268	; 0x10c
    writel(bw, iobase + offset + 0x10);
  102e6e:	f44f 7a88 	mov.w	r10, #272	; 0x110
    writel(satur, iobase + offset + 0x14);
  102e72:	f44f 7e8a 	mov.w	r14, #276	; 0x114
    writel(ext, iobase + offset + 0x18);
  102e76:	f44f 718c 	mov.w	r1, #280	; 0x118
    writel(pri, iobase + offset + 0x8);
  102e7a:	f2cf 086e 	movt	r8, #61550	; 0xf06e
    writel(mode, iobase + offset + 0xc);
  102e7e:	602a      	str	r2, [r5, #0]
  102e80:	f2cf 096e 	movt	r9, #61550	; 0xf06e
    writel(bw, iobase + offset + 0x10);
  102e84:	6030      	str	r0, [r6, #0]
  102e86:	f2cf 0a6e 	movt	r10, #61550	; 0xf06e
    writel(satur, iobase + offset + 0x14);
  102e8a:	f2cf 0e6e 	movt	r14, #61550	; 0xf06e
    writel(bw, iobase + offset + 0x10);
  102e8e:	2099      	movs	r0, #153	; 0x99
    writel(ext, iobase + offset + 0x18);
  102e90:	f2cf 016e 	movt	r1, #61550	; 0xf06e
    writel(satur, iobase + offset + 0x14);
  102e94:	f8cc 4000 	str.w	r4, [r12]
    writel(ext, iobase + offset + 0x18);
  102e98:	603b      	str	r3, [r7, #0]
    writel(pri, iobase + offset + 0x8);
  102e9a:	9f01      	ldr	r7, [sp, #4]
  102e9c:	f8c8 7000 	str.w	r7, [r8]
    writel(mode, iobase + offset + 0xc);
  102ea0:	f8c9 2000 	str.w	r2, [r9]
    writel(bw, iobase + offset + 0x10);
  102ea4:	f8ca 0000 	str.w	r0, [r10]
    writel(satur, iobase + offset + 0x14);
  102ea8:	f8ce 4000 	str.w	r4, [r14]
    writel(ext, iobase + offset + 0x18);
  102eac:	600b      	str	r3, [r1, #0]
                       0x00000008, 0x0);
    /* enet1 */
    init_qos_by_module(iobase, 0x300, 0x80000402, 0x00000003, 0x0000004c,
                       0x00000010, 0x0);
#endif
}
  102eae:	b003      	add	sp, #12
  102eb0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

00102eb4 <ce_key_ctrl>:
                (uint32_t)(phy_addr + (offset_index << 12)), data);
    }
}

int ce_key_ctrl(void)
{
  102eb4:	b500      	push	{r14}

    int ret = 0;
    paddr_t phy_addr = 0;
  102eb6:	2300      	movs	r3, #0
{
  102eb8:	b083      	sub	sp, #12
    int32_t resid = 0;
    int32_t offset_index = 0;

    resid = RES_SCR_L16_SAF_CE1_KEY_PERCTRL_SCR_KEY_ENABLE;
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102eba:	f44f 7021 	mov.w	r0, #644	; 0x284
    int32_t offset_index = 0;
  102ebe:	aa02      	add	r2, sp, #8
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102ec0:	4669      	mov	r1, r13
  102ec2:	f2c8 2098 	movt	r0, #33432	; 0x8298
    int32_t offset_index = 0;
  102ec6:	f842 3d04 	str.w	r3, [r2, #-4]!
    paddr_t phy_addr = 0;
  102eca:	9300      	str	r3, [sp, #0]
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  102ecc:	f004 fa66 	bl	10739c <res_get_info_by_id>

    if (ret == -1) {
  102ed0:	1c43      	adds	r3, r0, #1
    writel(data, phy_addr + (offset_index << 12));
  102ed2:	bf1f      	itttt	ne
  102ed4:	210d      	movne	r1, #13
  102ed6:	9b01      	ldrne	r3, [sp, #4]
  102ed8:	9a00      	ldrne	r2, [sp, #0]
  102eda:	031b      	lslne	r3, r3, #12
  102edc:	bf18      	it	ne
  102ede:	5099      	strne	r1, [r3, r2]
    else {
        L16_ce1key_enable_init(phy_addr, offset_index);
    }

    return ret;
}
  102ee0:	b003      	add	sp, #12
  102ee2:	f85d fb04 	ldr.w	r15, [r13], #4
  102ee6:	bf00      	nop

00102ee8 <scr_init>:
    writel(rval, SCR_SEC_BASE + (0xC << 10));
}
/* hardcode scr init end */

int scr_init(void)
{
  102ee8:	b510      	push	{r4, r14}
    int ret = 0;

    /* ce key setting */
    ret = ce_key_ctrl();
  102eea:	f7ff ffe3 	bl	102eb4 <ce_key_ctrl>

    if (ret) {
  102eee:	4604      	mov	r4, r0
  102ef0:	b998      	cbnz	r0, 102f1a <scr_init+0x32>
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102ef2:	f44f 41a0 	mov.w	r1, #20480	; 0x5000
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102ef6:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102efa:	f6cf 0138 	movt	r1, #63544	; 0xf838

    /* other setting */
    src_init_hc();

    return ret;
}
  102efe:	4620      	mov	r0, r4
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102f00:	f6cf 0220 	movt	r2, #63520	; 0xf820
    rval = readl(SCR_SEC_BASE + (0x614 << 10));
  102f04:	680b      	ldr	r3, [r1, #0]
    rval = (rval & (~0x38)) | 0x8;
  102f06:	f023 0338 	bic.w	r3, r3, #56	; 0x38
  102f0a:	f043 0308 	orr.w	r3, r3, #8
    writel(rval, SCR_SEC_BASE + (0x614 << 10));
  102f0e:	600b      	str	r3, [r1, #0]
    rval = readl(SCR_SEC_BASE + (0xC << 10));
  102f10:	6813      	ldr	r3, [r2, #0]
    rval =  rval  | 0x3D;
  102f12:	f043 033d 	orr.w	r3, r3, #61	; 0x3d
    writel(rval, SCR_SEC_BASE + (0xC << 10));
  102f16:	6013      	str	r3, [r2, #0]
}
  102f18:	bd10      	pop	{r4, r15}
        dprintf(CRITICAL, "ce_key_ctrl fail.\n");
  102f1a:	f64c 0070 	movw	r0, #51312	; 0xc870
  102f1e:	f2c0 0010 	movt	r0, #16
  102f22:	f008 f9c3 	bl	10b2ac <puts>
}
  102f26:	4620      	mov	r0, r4
  102f28:	bd10      	pop	{r4, r15}
  102f2a:	bf00      	nop

00102f2c <clkgen_get_default_config>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_get_default_config(clkgen_default_cfg_t *def_cfg)
{
  102f2c:	4603      	mov	r3, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_get_default_config start...............\n");
    def_cfg->src_sel_mask = 2;
    def_cfg->safety_mode = true;
  102f2e:	2201      	movs	r2, #1
    def_cfg->src_sel_mask = 2;
  102f30:	2102      	movs	r1, #2
  102f32:	7001      	strb	r1, [r0, #0]
    return true;
}
  102f34:	4610      	mov	r0, r2
    def_cfg->safety_mode = true;
  102f36:	705a      	strb	r2, [r3, #1]
}
  102f38:	4770      	bx	r14
  102f3a:	bf00      	nop

00102f3c <clkgen_fsrefclk_sel>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_fsrefclk_sel(vaddr_t base, uint32_t scr_idx,
                         uint32_t src_sel_mask, bool safety_mode)
{
  102f3c:	b410      	push	{r4}
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if ((base != SCR_SAF_BASE)
            && (base != SCR_SEC_BASE)) {
  102f3e:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
    if ((base != SCR_SAF_BASE)
  102f42:	f114 6ffc 	cmn.w	r4, #132120576	; 0x7e00000
        LTRACEF("base paramenter error \n");
        return false;
  102f46:	bf18      	it	ne
  102f48:	2200      	movne	r2, #0
    if ((base != SCR_SAF_BASE)
  102f4a:	d110      	bne.n	102f6e <clkgen_fsrefclk_sel+0x32>
    }

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_fsrefclk_sel scr_idx:0x%x,src_sel_mask:0x%x,safety_mode:0x%x\n",
                  scr_idx, src_sel_mask, safety_mode);
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  102f4c:	3180      	adds	r1, #128	; 0x80
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
                              CLKGEN_FSREFCLK_FS_XTAL_EN(1)));
    writel(reg_write, scr_base_addr);
    //select clk src:xtal_saf = 0x0U,xtal_ap = 0x1U,rc_24m = 0x2U,
    reg_read = readl(scr_base_addr);
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  102f4e:	f002 0203 	and.w	r2, r2, #3
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  102f52:	0309      	lsls	r1, r1, #12
    reg_read = readl(scr_base_addr);
  102f54:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
  102f56:	f024 0418 	bic.w	r4, r4, #24
    writel(reg_write, scr_base_addr);
  102f5a:	500c      	str	r4, [r1, r0]
    reg_read = readl(scr_base_addr);
  102f5c:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  102f5e:	4322      	orrs	r2, r4
    writel(reg_write, scr_base_addr);
  102f60:	500a      	str	r2, [r1, r0]

    //enable safety mode
    if (safety_mode) {
  102f62:	b943      	cbnz	r3, 102f76 <clkgen_fsrefclk_sel+0x3a>
                                CLKGEN_FSREFCLK_FS_XTAL_EN(1));
        writel(reg_write, scr_base_addr);
    }

    //enable xtal cg gate
    reg_read = readl(scr_base_addr);
  102f64:	580b      	ldr	r3, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
    writel(reg_write, scr_base_addr);
    return true;
  102f66:	2201      	movs	r2, #1
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
  102f68:	f043 0304 	orr.w	r3, r3, #4
    writel(reg_write, scr_base_addr);
  102f6c:	500b      	str	r3, [r1, r0]
}
  102f6e:	f85d 4b04 	ldr.w	r4, [r13], #4
  102f72:	4610      	mov	r0, r2
  102f74:	4770      	bx	r14
        reg_read = readl(scr_base_addr);
  102f76:	580b      	ldr	r3, [r1, r0]
        reg_write = reg_read | (CLKGEN_FSREFCLK_FS_RC_EN(1) |
  102f78:	f043 0318 	orr.w	r3, r3, #24
        writel(reg_write, scr_base_addr);
  102f7c:	500b      	str	r3, [r1, r0]
  102f7e:	e7f1      	b.n	102f64 <clkgen_fsrefclk_sel+0x28>

00102f80 <clkgen_gating_enable>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_gating_enable(vaddr_t base, uint16_t gating_idx, bool enable)
{
  102f80:	4603      	mov	r3, r0
    vaddr_t gating_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  102f82:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  102f86:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  102f8a:	d004      	beq.n	102f96 <clkgen_gating_enable+0x16>
  102f8c:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  102f90:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  102f94:	d117      	bne.n	102fc6 <clkgen_gating_enable+0x46>
    gating_base_addr = base + CLKGEN_LP_GATING_EN_OFF(gating_idx);
  102f96:	0309      	lsls	r1, r1, #12
  102f98:	f501 1180 	add.w	r1, r1, #1048576	; 0x100000
{
  102f9c:	b410      	push	{r4}
    //unlock gating register
    reg_read = readl(gating_base_addr);
  102f9e:	58c8      	ldr	r0, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_GATING_LOCK_MASK));
  102fa0:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    writel(reg_write, gating_base_addr);
  102fa4:	50c8      	str	r0, [r1, r3]
    //set sw disable
    reg_read = readl(gating_base_addr);
  102fa6:	58cc      	ldr	r4, [r1, r3]

    if (enable) {
  102fa8:	b932      	cbnz	r2, 102fb8 <clkgen_gating_enable+0x38>
    else {
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
        writel(reg_write, gating_base_addr);
    }

    return true;
  102faa:	2001      	movs	r0, #1
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
  102fac:	f044 0202 	orr.w	r2, r4, #2
}
  102fb0:	f85d 4b04 	ldr.w	r4, [r13], #4
        writel(reg_write, gating_base_addr);
  102fb4:	50ca      	str	r2, [r1, r3]
}
  102fb6:	4770      	bx	r14
    return true;
  102fb8:	4610      	mov	r0, r2
        reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK));
  102fba:	f024 0402 	bic.w	r4, r4, #2
        writel(reg_write, gating_base_addr);
  102fbe:	50cc      	str	r4, [r1, r3]
}
  102fc0:	f85d 4b04 	ldr.w	r4, [r13], #4
  102fc4:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  102fc6:	2000      	movs	r0, #0
}
  102fc8:	4770      	bx	r14
  102fca:	bf00      	nop

00102fcc <clkgen_ip_slice_set>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_ip_slice_set(vaddr_t base, uint8_t ip_slice_idx,
                         uint8_t clk_src_sel, uint16_t pre_div, uint16_t post_div)
{
  102fcc:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  102fd0:	f8bd 7018 	ldrh.w	r7, [r13, #24]
    bool ret = false;
    vaddr_t ip_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  102fd4:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  102fd8:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  102fdc:	d004      	beq.n	102fe8 <clkgen_ip_slice_set+0x1c>
  102fde:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  102fe2:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  102fe6:	d152      	bne.n	10308e <clkgen_ip_slice_set+0xc2>
    ip_slice_base_addr = base + CLKGEN_IP_SLICE_CTL_OFF(ip_slice_idx);
  102fe8:	030e      	lsls	r6, r1, #12
  102fea:	1834      	adds	r4, r6, r0
    //clear pre_en
    reg_read = readl(ip_slice_base_addr);
  102fec:	5831      	ldr	r1, [r6, r0]

    if ((reg_read & CLKGEN_IP_SLICE_CTL_CG_EN_MASK) != 0) {
  102fee:	07cd      	lsls	r5, r1, #31
  102ff0:	d50d      	bpl.n	10300e <clkgen_ip_slice_set+0x42>
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
        writel(reg_write, ip_slice_base_addr);
  102ff2:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
  102ff4:	f021 0101 	bic.w	r1, r1, #1
        writel(reg_write, ip_slice_base_addr);
  102ff8:	5031      	str	r1, [r6, r0]
  102ffa:	e001      	b.n	103000 <clkgen_ip_slice_set+0x34>
    } while (--retrycount);
  102ffc:	3d01      	subs	r5, #1
  102ffe:	d006      	beq.n	10300e <clkgen_ip_slice_set+0x42>
        v = readl(reg);
  103000:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103002:	00c9      	lsls	r1, r1, #3
  103004:	d5fa      	bpl.n	102ffc <clkgen_ip_slice_set+0x30>
    RMWREG32(reg, start, width, setvalue);
  103006:	5831      	ldr	r1, [r6, r0]
  103008:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  10300c:	5031      	str	r1, [r6, r0]
        reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                       1, 1, 0, 100);
    }

    //select clk src
    reg_read = readl(ip_slice_base_addr);
  10300e:	5835      	ldr	r5, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
                CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL(clk_src_sel);
  103010:	0051      	lsls	r1, r2, #1
  103012:	f001 010e 	and.w	r1, r1, #14
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
  103016:	f025 020e 	bic.w	r2, r5, #14
  10301a:	4311      	orrs	r1, r2
    writel(reg_write, ip_slice_base_addr);
    //set pre_en
    reg_read = readl(ip_slice_base_addr);
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
    writel(reg_write, ip_slice_base_addr);
  10301c:	2264      	movs	r2, #100	; 0x64
    writel(reg_write, ip_slice_base_addr);
  10301e:	5031      	str	r1, [r6, r0]
    reg_read = readl(ip_slice_base_addr);
  103020:	5831      	ldr	r1, [r6, r0]
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
  103022:	f041 0101 	orr.w	r1, r1, #1
    writel(reg_write, ip_slice_base_addr);
  103026:	5031      	str	r1, [r6, r0]
  103028:	e001      	b.n	10302e <clkgen_ip_slice_set+0x62>
    } while (--retrycount);
  10302a:	3a01      	subs	r2, #1
  10302c:	d006      	beq.n	10303c <clkgen_ip_slice_set+0x70>
        v = readl(reg);
  10302e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103030:	00e9      	lsls	r1, r5, #3
  103032:	d5fa      	bpl.n	10302a <clkgen_ip_slice_set+0x5e>
    RMWREG32(reg, start, width, setvalue);
  103034:	5832      	ldr	r2, [r6, r0]
  103036:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  10303a:	5032      	str	r2, [r6, r0]
    reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                   1, 1, 0, 100);
    //set pre_div
    reg_read = readl(ip_slice_base_addr);
  10303c:	5832      	ldr	r2, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM(pre_div);
  10303e:	011b      	lsls	r3, r3, #4
  103040:	4680      	mov	r8, r0
  103042:	f003 0370 	and.w	r3, r3, #112	; 0x70
    writel(reg_write, ip_slice_base_addr);
  103046:	2564      	movs	r5, #100	; 0x64
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
  103048:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  10304c:	4313      	orrs	r3, r2
    writel(reg_write, ip_slice_base_addr);
  10304e:	5033      	str	r3, [r6, r0]
  103050:	e003      	b.n	10305a <clkgen_ip_slice_set+0x8e>
        spin(1);
  103052:	f007 f8fd 	bl	10a250 <spin>
    } while (--retrycount);
  103056:	3d01      	subs	r5, #1
  103058:	d003      	beq.n	103062 <clkgen_ip_slice_set+0x96>
        v = readl(reg);
  10305a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10305c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10305e:	005b      	lsls	r3, r3, #1
  103060:	d4f7      	bmi.n	103052 <clkgen_ip_slice_set+0x86>
    //wait pre_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
    //set post_div
    reg_read = readl(ip_slice_base_addr);
  103062:	f856 3008 	ldr.w	r3, [r6, r8]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  103066:	02bf      	lsls	r7, r7, #10
    writel(reg_write, ip_slice_base_addr);
  103068:	2564      	movs	r5, #100	; 0x64
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  10306a:	b2bf      	uxth	r7, r7
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
  10306c:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
  103070:	431f      	orrs	r7, r3
    writel(reg_write, ip_slice_base_addr);
  103072:	f846 7008 	str.w	r7, [r6, r8]
  103076:	e003      	b.n	103080 <clkgen_ip_slice_set+0xb4>
        spin(1);
  103078:	f007 f8ea 	bl	10a250 <spin>
    } while (--retrycount);
  10307c:	3d01      	subs	r5, #1
  10307e:	d006      	beq.n	10308e <clkgen_ip_slice_set+0xc2>
        v = readl(reg);
  103080:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103082:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103084:	2b00      	cmp	r3, #0
  103086:	dbf7      	blt.n	103078 <clkgen_ip_slice_set+0xac>
            return true;
  103088:	2001      	movs	r0, #1
    //wait post_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    return ret;
}
  10308a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    CLKGEN_ASSERT_PARAMETER(base);
  10308e:	2000      	movs	r0, #0
}
  103090:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00103094 <clkgen_ip_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

    // Check the arguments.
    if (ctl) {
  103094:	b112      	cbz	r2, 10309c <clkgen_ip_ctl_get+0x8>
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  103096:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  103098:	580b      	ldr	r3, [r1, r0]
  10309a:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  10309c:	2001      	movs	r0, #1
  10309e:	4770      	bx	r14

001030a0 <clkgen_ip_ctl_set>:
{
    bool ret = true;
    vaddr_t slice_addr;
    clkgen_ip_ctl v;

    if (ctl) {
  1030a0:	2a00      	cmp	r2, #0
  1030a2:	d051      	beq.n	103148 <clkgen_ip_ctl_set+0xa8>
{
  1030a4:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  1030a8:	030e      	lsls	r6, r1, #12
  1030aa:	1834      	adds	r4, r6, r0
        //clear pre_en
        v.val = readl(slice_addr);
  1030ac:	5837      	ldr	r7, [r6, r0]

        if (v.cg_en != 0) {
  1030ae:	07fb      	lsls	r3, r7, #31
  1030b0:	d50d      	bpl.n	1030ce <clkgen_ip_ctl_set+0x2e>
            v.cg_en = 0;
            writel(v.val, slice_addr);
  1030b2:	2364      	movs	r3, #100	; 0x64
            v.cg_en = 0;
  1030b4:	f36f 0700 	bfc	r7, #0, #1
            writel(v.val, slice_addr);
  1030b8:	5037      	str	r7, [r6, r0]
  1030ba:	e001      	b.n	1030c0 <clkgen_ip_ctl_set+0x20>
    } while (--retrycount);
  1030bc:	3b01      	subs	r3, #1
  1030be:	d006      	beq.n	1030ce <clkgen_ip_ctl_set+0x2e>
        v = readl(reg);
  1030c0:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1030c2:	00cd      	lsls	r5, r1, #3
  1030c4:	d5fa      	bpl.n	1030bc <clkgen_ip_ctl_set+0x1c>
    RMWREG32(reg, start, width, setvalue);
  1030c6:	5833      	ldr	r3, [r6, r0]
  1030c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  1030cc:	5033      	str	r3, [r6, r0]
            ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                                  1, 1, 0, 100);
        }

        //select clk src
        v.src_sel = ctl->src_sel;
  1030ce:	7813      	ldrb	r3, [r2, #0]
  1030d0:	f3c3 0342 	ubfx	r3, r3, #1, #3
  1030d4:	f363 0743 	bfi	r7, r3, #1, #3
        writel(v.val, slice_addr);
        //set pre_en
        v.cg_en = ctl->cg_en;
        writel(v.val, slice_addr);
  1030d8:	2364      	movs	r3, #100	; 0x64
        writel(v.val, slice_addr);
  1030da:	5037      	str	r7, [r6, r0]
        v.cg_en = ctl->cg_en;
  1030dc:	7811      	ldrb	r1, [r2, #0]
  1030de:	f3c1 0100 	ubfx	r1, r1, #0, #1
  1030e2:	f361 0700 	bfi	r7, r1, #0, #1
        writel(v.val, slice_addr);
  1030e6:	5037      	str	r7, [r6, r0]
  1030e8:	e001      	b.n	1030ee <clkgen_ip_ctl_set+0x4e>
    } while (--retrycount);
  1030ea:	3b01      	subs	r3, #1
  1030ec:	d006      	beq.n	1030fc <clkgen_ip_ctl_set+0x5c>
        v = readl(reg);
  1030ee:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1030f0:	00e9      	lsls	r1, r5, #3
  1030f2:	d5fa      	bpl.n	1030ea <clkgen_ip_ctl_set+0x4a>
    RMWREG32(reg, start, width, setvalue);
  1030f4:	5833      	ldr	r3, [r6, r0]
  1030f6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  1030fa:	5033      	str	r3, [r6, r0]
        ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                              1, 1, 0, 100);
        //set pre_div
        v.pre_div_num = ctl->pre_div_num;
  1030fc:	7813      	ldrb	r3, [r2, #0]
  1030fe:	4691      	mov	r9, r2
  103100:	4680      	mov	r8, r0
  103102:	f3c3 1302 	ubfx	r3, r3, #4, #3
        writel(v.val, slice_addr);
  103106:	2564      	movs	r5, #100	; 0x64
        v.pre_div_num = ctl->pre_div_num;
  103108:	f363 1706 	bfi	r7, r3, #4, #3
        writel(v.val, slice_addr);
  10310c:	5037      	str	r7, [r6, r0]
  10310e:	e003      	b.n	103118 <clkgen_ip_ctl_set+0x78>
        spin(1);
  103110:	f007 f89e 	bl	10a250 <spin>
    } while (--retrycount);
  103114:	3d01      	subs	r5, #1
  103116:	d003      	beq.n	103120 <clkgen_ip_ctl_set+0x80>
        v = readl(reg);
  103118:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10311a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10311c:	005b      	lsls	r3, r3, #1
  10311e:	d4f7      	bmi.n	103110 <clkgen_ip_ctl_set+0x70>
        //wait pre_upd_ack is 0
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
        //set post_div
        v.post_div_num = ctl->post_div_num;
  103120:	f899 3001 	ldrb.w	r3, [r9, #1]
        writel(v.val, slice_addr);
  103124:	2564      	movs	r5, #100	; 0x64
        v.post_div_num = ctl->post_div_num;
  103126:	089b      	lsrs	r3, r3, #2
  103128:	f363 278f 	bfi	r7, r3, #10, #6
        writel(v.val, slice_addr);
  10312c:	f846 7008 	str.w	r7, [r6, r8]
  103130:	e003      	b.n	10313a <clkgen_ip_ctl_set+0x9a>
        spin(1);
  103132:	f007 f88d 	bl	10a250 <spin>
    } while (--retrycount);
  103136:	3d01      	subs	r5, #1
  103138:	d008      	beq.n	10314c <clkgen_ip_ctl_set+0xac>
        v = readl(reg);
  10313a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10313c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10313e:	2b00      	cmp	r3, #0
  103140:	dbf7      	blt.n	103132 <clkgen_ip_ctl_set+0x92>
    bool ret = true;
  103142:	2001      	movs	r0, #1
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  103144:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    bool ret = true;
  103148:	2001      	movs	r0, #1
}
  10314a:	4770      	bx	r14
    return false;
  10314c:	4628      	mov	r0, r5
  10314e:	e7f9      	b.n	103144 <clkgen_ip_ctl_set+0xa4>

00103150 <clkgen_bus_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_bus_slice_switch(vaddr_t base,
                             clkgen_bus_slice_drv_t *bus_clk_cfg)
{
  103150:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    vaddr_t bus_gasket_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103154:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103158:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  10315c:	d007      	beq.n	10316e <clkgen_bus_slice_switch+0x1e>
  10315e:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103162:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103166:	bf18      	it	ne
  103168:	2000      	movne	r0, #0
  10316a:	f040 808a 	bne.w	103282 <clkgen_bus_slice_switch+0x132>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  10316e:	680b      	ldr	r3, [r1, #0]
  103170:	4688      	mov	r8, r1
  103172:	4606      	mov	r6, r0
  103174:	3340      	adds	r3, #64	; 0x40
  103176:	035f      	lsls	r7, r3, #13
                              bus_clk_cfg->bus_slice_idx);
    bus_gasket_slice_base_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(
  103178:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
  10317c:	eb03 0900 	add.w	r9, r3, r0
                                     bus_clk_cfg->bus_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(bus_slice_base_addr);
  103180:	583a      	ldr	r2, [r7, r0]
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  103182:	183c      	adds	r4, r7, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
        (a_b_sel == bus_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(bus_slice_base_addr);
  103184:	5839      	ldr	r1, [r7, r0]
    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
  103186:	0595      	lsls	r5, r2, #22
  103188:	d47d      	bmi.n	103286 <clkgen_bus_slice_switch+0x136>

        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK) != 0) {
  10318a:	03c8      	lsls	r0, r1, #15
  10318c:	d50d      	bpl.n	1031aa <clkgen_bus_slice_switch+0x5a>
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, bus_slice_base_addr);
  10318e:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
  103190:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
            writel(reg_write, bus_slice_base_addr);
  103194:	51b9      	str	r1, [r7, r6]
  103196:	e001      	b.n	10319c <clkgen_bus_slice_switch+0x4c>
    } while (--retrycount);
  103198:	3a01      	subs	r2, #1
  10319a:	d006      	beq.n	1031aa <clkgen_bus_slice_switch+0x5a>
        v = readl(reg);
  10319c:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10319e:	0109      	lsls	r1, r1, #4
  1031a0:	d5fa      	bpl.n	103198 <clkgen_bus_slice_switch+0x48>
    RMWREG32(reg, start, width, setvalue);
  1031a2:	59ba      	ldr	r2, [r7, r6]
  1031a4:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  1031a8:	51ba      	str	r2, [r7, r6]
                    & (~(CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM_MASK));
        reg_write = reg_write
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1031aa:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1031ae:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1031b2:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  1031b4:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1031b8:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1031ba:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1031be:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1031c2:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  1031c6:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  1031c8:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  1031cc:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  1031ce:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1031d0:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  1031d2:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1031d4:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  1031d8:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  1031dc:	4302      	orrs	r2, r0
        reg_write = reg_read
  1031de:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  1031e2:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  1031e4:	519a      	str	r2, [r3, r6]
  1031e6:	e003      	b.n	1031f0 <clkgen_bus_slice_switch+0xa0>
        spin(1);
  1031e8:	f007 f832 	bl	10a250 <spin>
    } while (--retrycount);
  1031ec:	3d01      	subs	r5, #1
  1031ee:	d004      	beq.n	1031fa <clkgen_bus_slice_switch+0xaa>
        v = readl(reg);
  1031f0:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  1031f4:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1031f6:	0f1b      	lsrs	r3, r3, #28
  1031f8:	d1f6      	bne.n	1031e8 <clkgen_bus_slice_switch+0x98>
        ret = reg_poll_value(bus_gasket_slice_base_addr,
                             CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  1031fa:	f898 2006 	ldrb.w	r2, [r8, #6]
        reg_read = readl(bus_slice_base_addr);
  1031fe:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  103200:	0452      	lsls	r2, r2, #17
  103202:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  103206:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  10320a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  10320e:	431a      	orrs	r2, r3
                    | CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, bus_slice_base_addr);
  103210:	2364      	movs	r3, #100	; 0x64
  103212:	51ba      	str	r2, [r7, r6]
  103214:	e001      	b.n	10321a <clkgen_bus_slice_switch+0xca>
    } while (--retrycount);
  103216:	3b01      	subs	r3, #1
  103218:	d006      	beq.n	103228 <clkgen_bus_slice_switch+0xd8>
        v = readl(reg);
  10321a:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10321c:	0112      	lsls	r2, r2, #4
  10321e:	d5fa      	bpl.n	103216 <clkgen_bus_slice_switch+0xc6>
    RMWREG32(reg, start, width, setvalue);
  103220:	59bb      	ldr	r3, [r7, r6]
  103222:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  103226:	51bb      	str	r3, [r7, r6]
        reg_poll_clear(bus_slice_base_addr,
                       CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
  103228:	59ba      	ldr	r2, [r7, r6]
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  10322a:	f898 3008 	ldrb.w	r3, [r8, #8]
        writel(reg_write, bus_slice_base_addr);
  10322e:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  103230:	051b      	lsls	r3, r3, #20
  103232:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
  103236:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
  10323a:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  10323c:	51bb      	str	r3, [r7, r6]
  10323e:	e003      	b.n	103248 <clkgen_bus_slice_switch+0xf8>
        spin(1);
  103240:	f007 f806 	bl	10a250 <spin>
    } while (--retrycount);
  103244:	3d01      	subs	r5, #1
  103246:	d003      	beq.n	103250 <clkgen_bus_slice_switch+0x100>
        v = readl(reg);
  103248:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10324a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10324c:	009b      	lsls	r3, r3, #2
  10324e:	d4f7      	bmi.n	103240 <clkgen_bus_slice_switch+0xf0>
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  103250:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  103254:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  103256:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  103258:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  10325a:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  10325e:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  103260:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  103262:	51bb      	str	r3, [r7, r6]
  103264:	e004      	b.n	103270 <clkgen_bus_slice_switch+0x120>
        spin(1);
  103266:	f006 fff3 	bl	10a250 <spin>
    } while (--retrycount);
  10326a:	3d01      	subs	r5, #1
  10326c:	f000 808a 	beq.w	103384 <clkgen_bus_slice_switch+0x234>
        v = readl(reg);
  103270:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103272:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103274:	2b00      	cmp	r3, #0
  103276:	dbf6      	blt.n	103266 <clkgen_bus_slice_switch+0x116>
            return true;
  103278:	2001      	movs	r0, #1
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(bus_slice_base_addr);
  10327a:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read | CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK;
  10327c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  103280:	51bb      	str	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
        writel(reg_write, bus_slice_base_addr);
    }

    return ret;
}
  103282:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK) != 0) {
  103286:	07c8      	lsls	r0, r1, #31
  103288:	d50d      	bpl.n	1032a6 <clkgen_bus_slice_switch+0x156>
            writel(reg_write, bus_slice_base_addr);
  10328a:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK);
  10328c:	f021 0101 	bic.w	r1, r1, #1
            writel(reg_write, bus_slice_base_addr);
  103290:	51b9      	str	r1, [r7, r6]
  103292:	e001      	b.n	103298 <clkgen_bus_slice_switch+0x148>
    } while (--retrycount);
  103294:	3a01      	subs	r2, #1
  103296:	d006      	beq.n	1032a6 <clkgen_bus_slice_switch+0x156>
        v = readl(reg);
  103298:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10329a:	00c9      	lsls	r1, r1, #3
  10329c:	d5fa      	bpl.n	103294 <clkgen_bus_slice_switch+0x144>
    RMWREG32(reg, start, width, setvalue);
  10329e:	59ba      	ldr	r2, [r7, r6]
  1032a0:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  1032a4:	51ba      	str	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1032a6:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1032aa:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1032ae:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  1032b0:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1032b4:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1032b6:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  1032ba:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  1032be:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  1032c2:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  1032c4:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  1032c8:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  1032ca:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1032cc:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  1032ce:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  1032d0:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  1032d4:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  1032d8:	4302      	orrs	r2, r0
        reg_write = reg_read
  1032da:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  1032de:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  1032e0:	519a      	str	r2, [r3, r6]
  1032e2:	e003      	b.n	1032ec <clkgen_bus_slice_switch+0x19c>
        spin(1);
  1032e4:	f006 ffb4 	bl	10a250 <spin>
    } while (--retrycount);
  1032e8:	3d01      	subs	r5, #1
  1032ea:	d004      	beq.n	1032f6 <clkgen_bus_slice_switch+0x1a6>
        v = readl(reg);
  1032ec:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  1032f0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1032f2:	0f1b      	lsrs	r3, r3, #28
  1032f4:	d1f6      	bne.n	1032e4 <clkgen_bus_slice_switch+0x194>
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  1032f6:	f898 2005 	ldrb.w	r2, [r8, #5]
        reg_read = readl(bus_slice_base_addr);
  1032fa:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  1032fc:	0052      	lsls	r2, r2, #1
  1032fe:	f002 020e 	and.w	r2, r2, #14
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  103302:	f023 030e 	bic.w	r3, r3, #14
  103306:	f042 0201 	orr.w	r2, r2, #1
  10330a:	431a      	orrs	r2, r3
        writel(reg_write, bus_slice_base_addr);
  10330c:	2364      	movs	r3, #100	; 0x64
  10330e:	51ba      	str	r2, [r7, r6]
  103310:	e001      	b.n	103316 <clkgen_bus_slice_switch+0x1c6>
    } while (--retrycount);
  103312:	3b01      	subs	r3, #1
  103314:	d006      	beq.n	103324 <clkgen_bus_slice_switch+0x1d4>
        v = readl(reg);
  103316:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103318:	00d2      	lsls	r2, r2, #3
  10331a:	d5fa      	bpl.n	103312 <clkgen_bus_slice_switch+0x1c2>
    RMWREG32(reg, start, width, setvalue);
  10331c:	59bb      	ldr	r3, [r7, r6]
  10331e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  103322:	51bb      	str	r3, [r7, r6]
        reg_read = readl(bus_slice_base_addr);
  103324:	59ba      	ldr	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  103326:	f898 3007 	ldrb.w	r3, [r8, #7]
        writel(reg_write, bus_slice_base_addr);
  10332a:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  10332c:	011b      	lsls	r3, r3, #4
  10332e:	f003 0370 	and.w	r3, r3, #112	; 0x70
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A_MASK))
  103332:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  103336:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  103338:	51bb      	str	r3, [r7, r6]
  10333a:	e003      	b.n	103344 <clkgen_bus_slice_switch+0x1f4>
        spin(1);
  10333c:	f006 ff88 	bl	10a250 <spin>
    } while (--retrycount);
  103340:	3d01      	subs	r5, #1
  103342:	d003      	beq.n	10334c <clkgen_bus_slice_switch+0x1fc>
        v = readl(reg);
  103344:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103346:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103348:	005b      	lsls	r3, r3, #1
  10334a:	d4f7      	bmi.n	10333c <clkgen_bus_slice_switch+0x1ec>
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  10334c:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  103350:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  103352:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  103354:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  103356:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  10335a:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  10335c:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  10335e:	51bb      	str	r3, [r7, r6]
  103360:	e003      	b.n	10336a <clkgen_bus_slice_switch+0x21a>
        spin(1);
  103362:	f006 ff75 	bl	10a250 <spin>
    } while (--retrycount);
  103366:	3d01      	subs	r5, #1
  103368:	d00a      	beq.n	103380 <clkgen_bus_slice_switch+0x230>
        v = readl(reg);
  10336a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10336c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10336e:	2b00      	cmp	r3, #0
  103370:	dbf7      	blt.n	103362 <clkgen_bus_slice_switch+0x212>
            return true;
  103372:	2001      	movs	r0, #1
        reg_read = readl(bus_slice_base_addr);
  103374:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
  103376:	f423 7300 	bic.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  10337a:	51bb      	str	r3, [r7, r6]
}
  10337c:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    return false;
  103380:	4628      	mov	r0, r5
  103382:	e7f7      	b.n	103374 <clkgen_bus_slice_switch+0x224>
  103384:	4628      	mov	r0, r5
  103386:	e778      	b.n	10327a <clkgen_bus_slice_switch+0x12a>

00103388 <clkgen_bus_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  103388:	b17a      	cbz	r2, 1033aa <clkgen_bus_ctl_get+0x22>
{
  10338a:	b410      	push	{r4}
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  10338c:	f101 0440 	add.w	r4, r1, #64	; 0x40
  103390:	0364      	lsls	r4, r4, #13
        ctl->val = readl(slice_addr);
  103392:	5824      	ldr	r4, [r4, r0]
  103394:	6014      	str	r4, [r2, #0]
    }

    if (gasket) {
  103396:	b123      	cbz	r3, 1033a2 <clkgen_bus_ctl_get+0x1a>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  103398:	0349      	lsls	r1, r1, #13
  10339a:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  10339e:	580a      	ldr	r2, [r1, r0]
  1033a0:	601a      	str	r2, [r3, #0]
    }

    return ret;
}
  1033a2:	f85d 4b04 	ldr.w	r4, [r13], #4
  1033a6:	2001      	movs	r0, #1
  1033a8:	4770      	bx	r14
    if (gasket) {
  1033aa:	b123      	cbz	r3, 1033b6 <clkgen_bus_ctl_get+0x2e>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1033ac:	0349      	lsls	r1, r1, #13
  1033ae:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  1033b2:	580a      	ldr	r2, [r1, r0]
  1033b4:	601a      	str	r2, [r3, #0]
}
  1033b6:	2001      	movs	r0, #1
  1033b8:	4770      	bx	r14
  1033ba:	bf00      	nop

001033bc <clkgen_bus_ctl_set>:
                        const clkgen_bus_gasket *gasket)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  1033bc:	2a00      	cmp	r2, #0
  1033be:	f000 80ec 	beq.w	10359a <clkgen_bus_ctl_set+0x1de>
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  1033c2:	3140      	adds	r1, #64	; 0x40
{
  1033c4:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  1033c8:	4691      	mov	r9, r2
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  1033ca:	ea4f 3841 	mov.w	r8, r1, lsl #13
  1033ce:	4607      	mov	r7, r0
  1033d0:	00c9      	lsls	r1, r1, #3
  1033d2:	eb08 0500 	add.w	r5, r8, r0
        clkgen_bus_ctl v;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        v.val = readl(slice_addr);
  1033d6:	f858 6000 	ldr.w	r6, [r8, r0]

        if (v.a_b_sel == 0) {
  1033da:	f3c6 2207 	ubfx	r2, r6, #8, #8
  1033de:	f012 0202 	ands.w	r2, r2, #2
  1033e2:	d16e      	bne.n	1034c2 <clkgen_bus_ctl_set+0x106>
            //set pre_en_b to 0x0,disable the clock
            if (v.cg_en_b != 0) {
  1033e4:	03f4      	lsls	r4, r6, #15
  1033e6:	f100 80ec 	bmi.w	1035c2 <clkgen_bus_ctl_set+0x206>
                reg_poll_clear(slice_addr, CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1,
                               0, 100);
            }

            //set m/n/p/q div
            if (gasket) {
  1033ea:	b31b      	cbz	r3, 103434 <clkgen_bus_ctl_set+0x78>
                vaddr_t g_addr;
                clkgen_bus_gasket g;
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1033ec:	3104      	adds	r1, #4
                g.val = readl(g_addr);
                g.m_div_num = gasket->m_div_num;
                g.n_div_num = gasket->n_div_num;
                g.p_div_num = gasket->p_div_num;
  1033ee:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  1033f0:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  1033f2:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1033f4:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  1033f6:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  1033fa:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  1033fe:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  103400:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  103404:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  103408:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  10340c:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  103410:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  103414:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  103418:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  10341a:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  10341e:	51cb      	str	r3, [r1, r7]
  103420:	e003      	b.n	10342a <clkgen_bus_ctl_set+0x6e>
        spin(1);
  103422:	f006 ff15 	bl	10a250 <spin>
    } while (--retrycount);
  103426:	3c01      	subs	r4, #1
  103428:	d004      	beq.n	103434 <clkgen_bus_ctl_set+0x78>
        v = readl(reg);
  10342a:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  10342e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103430:	0f1b      	lsrs	r3, r3, #28
  103432:	d1f6      	bne.n	103422 <clkgen_bus_ctl_set+0x66>
                ret = reg_poll_value(g_addr,
                                     CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            v.src_sel_b = ctl->src_sel_a;
  103434:	f899 3000 	ldrb.w	r3, [r9]
  103438:	f3c3 0242 	ubfx	r2, r3, #1, #3
  10343c:	f362 4653 	bfi	r6, r2, #17, #3
            v.cg_en_b = ctl->cg_en_a;
  103440:	f3c3 0200 	ubfx	r2, r3, #0, #1
  103444:	f362 4610 	bfi	r6, r2, #16, #1

            if (v.cg_en_b != 0) {
  103448:	03f1      	lsls	r1, r6, #15
  10344a:	d511      	bpl.n	103470 <clkgen_bus_ctl_set+0xb4>
                writel(v.val, slice_addr);
  10344c:	f848 6007 	str.w	r6, [r8, r7]
  103450:	2364      	movs	r3, #100	; 0x64
  103452:	e002      	b.n	10345a <clkgen_bus_ctl_set+0x9e>
    } while (--retrycount);
  103454:	3b01      	subs	r3, #1
  103456:	f000 80cb 	beq.w	1035f0 <clkgen_bus_ctl_set+0x234>
        v = readl(reg);
  10345a:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10345c:	0112      	lsls	r2, r2, #4
  10345e:	d5f9      	bpl.n	103454 <clkgen_bus_ctl_set+0x98>
    RMWREG32(reg, start, width, setvalue);
  103460:	f858 3007 	ldr.w	r3, [r8, r7]
  103464:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  103468:	f848 3007 	str.w	r3, [r8, r7]
  10346c:	f899 3000 	ldrb.w	r3, [r9]
                               0, 100);
            }

            //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
            v.pre_div_num_b = ctl->pre_div_num_a;
            writel(v.val, slice_addr);
  103470:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_b = ctl->pre_div_num_a;
  103472:	f3c3 1302 	ubfx	r3, r3, #4, #3
  103476:	f363 5616 	bfi	r6, r3, #20, #3
            writel(v.val, slice_addr);
  10347a:	f848 6007 	str.w	r6, [r8, r7]
  10347e:	e003      	b.n	103488 <clkgen_bus_ctl_set+0xcc>
        spin(1);
  103480:	f006 fee6 	bl	10a250 <spin>
    } while (--retrycount);
  103484:	3c01      	subs	r4, #1
  103486:	d003      	beq.n	103490 <clkgen_bus_ctl_set+0xd4>
        v = readl(reg);
  103488:	682b      	ldr	r3, [r5, #0]
        spin(1);
  10348a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10348c:	009b      	lsls	r3, r3, #2
  10348e:	d4f7      	bmi.n	103480 <clkgen_bus_ctl_set+0xc4>
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            v.post_div_num = ctl->post_div_num;
  103490:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  103494:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  103496:	089b      	lsrs	r3, r3, #2
  103498:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  10349c:	f848 6007 	str.w	r6, [r8, r7]
  1034a0:	e004      	b.n	1034ac <clkgen_bus_ctl_set+0xf0>
        spin(1);
  1034a2:	f006 fed5 	bl	10a250 <spin>
    } while (--retrycount);
  1034a6:	3c01      	subs	r4, #1
  1034a8:	f000 809e 	beq.w	1035e8 <clkgen_bus_ctl_set+0x22c>
        v = readl(reg);
  1034ac:	682b      	ldr	r3, [r5, #0]
        spin(1);
  1034ae:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1034b0:	2b00      	cmp	r3, #0
  1034b2:	dbf6      	blt.n	1034a2 <clkgen_bus_ctl_set+0xe6>
            return true;
  1034b4:	2001      	movs	r0, #1
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
            //invert pre_a_b_sel
            v.a_b_sel = 1;
  1034b6:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(v.val, slice_addr);
  1034ba:	f848 6007 	str.w	r6, [r8, r7]
            writel(v.val, slice_addr);
        }
    }

    return ret;
}
  1034be:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            if (v.cg_en_a != 0) {
  1034c2:	07f4      	lsls	r4, r6, #31
  1034c4:	d46b      	bmi.n	10359e <clkgen_bus_ctl_set+0x1e2>
            if (gasket) {
  1034c6:	b31b      	cbz	r3, 103510 <clkgen_bus_ctl_set+0x154>
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1034c8:	3104      	adds	r1, #4
                g.p_div_num = gasket->p_div_num;
  1034ca:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  1034cc:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  1034ce:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1034d0:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  1034d2:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  1034d6:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  1034da:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  1034dc:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  1034e0:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  1034e4:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  1034e8:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  1034ec:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  1034f0:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  1034f4:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1034f6:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  1034fa:	51cb      	str	r3, [r1, r7]
  1034fc:	e003      	b.n	103506 <clkgen_bus_ctl_set+0x14a>
        spin(1);
  1034fe:	f006 fea7 	bl	10a250 <spin>
    } while (--retrycount);
  103502:	3c01      	subs	r4, #1
  103504:	d004      	beq.n	103510 <clkgen_bus_ctl_set+0x154>
        v = readl(reg);
  103506:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  10350a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10350c:	0f1b      	lsrs	r3, r3, #28
  10350e:	d1f6      	bne.n	1034fe <clkgen_bus_ctl_set+0x142>
            v.src_sel_a = ctl->src_sel_a;
  103510:	f899 3000 	ldrb.w	r3, [r9]
  103514:	f3c3 0242 	ubfx	r2, r3, #1, #3
  103518:	f362 0643 	bfi	r6, r2, #1, #3
            v.cg_en_a = ctl->cg_en_a;
  10351c:	f3c3 0200 	ubfx	r2, r3, #0, #1
  103520:	f362 0600 	bfi	r6, r2, #0, #1
            if (v.cg_en_a != 0) {
  103524:	07f1      	lsls	r1, r6, #31
  103526:	d510      	bpl.n	10354a <clkgen_bus_ctl_set+0x18e>
                writel(v.val, slice_addr);
  103528:	f848 6007 	str.w	r6, [r8, r7]
  10352c:	2364      	movs	r3, #100	; 0x64
  10352e:	e001      	b.n	103534 <clkgen_bus_ctl_set+0x178>
    } while (--retrycount);
  103530:	3b01      	subs	r3, #1
  103532:	d060      	beq.n	1035f6 <clkgen_bus_ctl_set+0x23a>
        v = readl(reg);
  103534:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103536:	00d2      	lsls	r2, r2, #3
  103538:	d5fa      	bpl.n	103530 <clkgen_bus_ctl_set+0x174>
    RMWREG32(reg, start, width, setvalue);
  10353a:	f858 3007 	ldr.w	r3, [r8, r7]
  10353e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  103542:	f848 3007 	str.w	r3, [r8, r7]
  103546:	f899 3000 	ldrb.w	r3, [r9]
            writel(v.val, slice_addr);
  10354a:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_a = ctl->pre_div_num_a;
  10354c:	f3c3 1302 	ubfx	r3, r3, #4, #3
  103550:	f363 1606 	bfi	r6, r3, #4, #3
            writel(v.val, slice_addr);
  103554:	f848 6007 	str.w	r6, [r8, r7]
  103558:	e003      	b.n	103562 <clkgen_bus_ctl_set+0x1a6>
        spin(1);
  10355a:	f006 fe79 	bl	10a250 <spin>
    } while (--retrycount);
  10355e:	3c01      	subs	r4, #1
  103560:	d003      	beq.n	10356a <clkgen_bus_ctl_set+0x1ae>
        v = readl(reg);
  103562:	682b      	ldr	r3, [r5, #0]
        spin(1);
  103564:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103566:	005b      	lsls	r3, r3, #1
  103568:	d4f7      	bmi.n	10355a <clkgen_bus_ctl_set+0x19e>
            v.post_div_num = ctl->post_div_num;
  10356a:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  10356e:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  103570:	089b      	lsrs	r3, r3, #2
  103572:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  103576:	f848 6007 	str.w	r6, [r8, r7]
  10357a:	e003      	b.n	103584 <clkgen_bus_ctl_set+0x1c8>
        spin(1);
  10357c:	f006 fe68 	bl	10a250 <spin>
    } while (--retrycount);
  103580:	3c01      	subs	r4, #1
  103582:	d033      	beq.n	1035ec <clkgen_bus_ctl_set+0x230>
        v = readl(reg);
  103584:	682b      	ldr	r3, [r5, #0]
        spin(1);
  103586:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103588:	2b00      	cmp	r3, #0
  10358a:	dbf7      	blt.n	10357c <clkgen_bus_ctl_set+0x1c0>
            return true;
  10358c:	2001      	movs	r0, #1
            v.a_b_sel = 0;
  10358e:	f36f 2649 	bfc	r6, #9, #1
            writel(v.val, slice_addr);
  103592:	f848 6007 	str.w	r6, [r8, r7]
}
  103596:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    bool ret = true;
  10359a:	2001      	movs	r0, #1
}
  10359c:	4770      	bx	r14
                writel(v.val, slice_addr);
  10359e:	2264      	movs	r2, #100	; 0x64
                v.cg_en_a = 0;
  1035a0:	f36f 0600 	bfc	r6, #0, #1
                writel(v.val, slice_addr);
  1035a4:	f848 6000 	str.w	r6, [r8, r0]
  1035a8:	e001      	b.n	1035ae <clkgen_bus_ctl_set+0x1f2>
    } while (--retrycount);
  1035aa:	3a01      	subs	r2, #1
  1035ac:	d08b      	beq.n	1034c6 <clkgen_bus_ctl_set+0x10a>
        v = readl(reg);
  1035ae:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1035b0:	00c0      	lsls	r0, r0, #3
  1035b2:	d5fa      	bpl.n	1035aa <clkgen_bus_ctl_set+0x1ee>
    RMWREG32(reg, start, width, setvalue);
  1035b4:	f858 2007 	ldr.w	r2, [r8, r7]
  1035b8:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  1035bc:	f848 2007 	str.w	r2, [r8, r7]
  1035c0:	e781      	b.n	1034c6 <clkgen_bus_ctl_set+0x10a>
                v.cg_en_b = 0;
  1035c2:	f362 4610 	bfi	r6, r2, #16, #1
                writel(v.val, slice_addr);
  1035c6:	2264      	movs	r2, #100	; 0x64
  1035c8:	f848 6000 	str.w	r6, [r8, r0]
  1035cc:	e002      	b.n	1035d4 <clkgen_bus_ctl_set+0x218>
    } while (--retrycount);
  1035ce:	3a01      	subs	r2, #1
  1035d0:	f43f af0b 	beq.w	1033ea <clkgen_bus_ctl_set+0x2e>
        v = readl(reg);
  1035d4:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1035d6:	0100      	lsls	r0, r0, #4
  1035d8:	d5f9      	bpl.n	1035ce <clkgen_bus_ctl_set+0x212>
    RMWREG32(reg, start, width, setvalue);
  1035da:	f858 2007 	ldr.w	r2, [r8, r7]
  1035de:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  1035e2:	f848 2007 	str.w	r2, [r8, r7]
  1035e6:	e700      	b.n	1033ea <clkgen_bus_ctl_set+0x2e>
    return false;
  1035e8:	4620      	mov	r0, r4
  1035ea:	e764      	b.n	1034b6 <clkgen_bus_ctl_set+0xfa>
  1035ec:	4620      	mov	r0, r4
  1035ee:	e7ce      	b.n	10358e <clkgen_bus_ctl_set+0x1d2>
  1035f0:	f899 3000 	ldrb.w	r3, [r9]
  1035f4:	e73c      	b.n	103470 <clkgen_bus_ctl_set+0xb4>
  1035f6:	f899 3000 	ldrb.w	r3, [r9]
  1035fa:	e7a6      	b.n	10354a <clkgen_bus_ctl_set+0x18e>

001035fc <clkgen_core_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_core_slice_switch(vaddr_t base,
                              clkgen_core_slice_drv_t *core_clk_cfg)
{
  1035fc:	b538      	push	{r3, r4, r5, r14}
    vaddr_t core_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1035fe:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103602:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103606:	d005      	beq.n	103614 <clkgen_core_slice_switch+0x18>
  103608:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  10360c:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103610:	f040 8084 	bne.w	10371c <clkgen_core_slice_switch+0x120>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    core_slice_base_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(
  103614:	680b      	ldr	r3, [r1, #0]
  103616:	33c0      	adds	r3, #192	; 0xc0
  103618:	031b      	lsls	r3, r3, #12
  10361a:	181c      	adds	r4, r3, r0
                               core_clk_cfg->core_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(core_slice_base_addr);
  10361c:	581a      	ldr	r2, [r3, r0]
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
        (a_b_sel == core_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(core_slice_base_addr);
  10361e:	581d      	ldr	r5, [r3, r0]
    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
  103620:	0592      	lsls	r2, r2, #22
  103622:	d43d      	bmi.n	1036a0 <clkgen_core_slice_switch+0xa4>

        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK) != 0) {
  103624:	03ea      	lsls	r2, r5, #15
  103626:	d50d      	bpl.n	103644 <clkgen_core_slice_switch+0x48>
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, core_slice_base_addr);
  103628:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
  10362a:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
            writel(reg_write, core_slice_base_addr);
  10362e:	501d      	str	r5, [r3, r0]
  103630:	e001      	b.n	103636 <clkgen_core_slice_switch+0x3a>
    } while (--retrycount);
  103632:	3a01      	subs	r2, #1
  103634:	d006      	beq.n	103644 <clkgen_core_slice_switch+0x48>
        v = readl(reg);
  103636:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103638:	012d      	lsls	r5, r5, #4
  10363a:	d5fa      	bpl.n	103632 <clkgen_core_slice_switch+0x36>
    RMWREG32(reg, start, width, setvalue);
  10363c:	581a      	ldr	r2, [r3, r0]
  10363e:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  103642:	501a      	str	r2, [r3, r0]
        }

        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  103644:	798d      	ldrb	r5, [r1, #6]
        reg_read = readl(core_slice_base_addr);
  103646:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  103648:	046d      	lsls	r5, r5, #17
  10364a:	f405 2560 	and.w	r5, r5, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  10364e:	f422 2260 	bic.w	r2, r2, #917504	; 0xe0000
  103652:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
  103656:	4315      	orrs	r5, r2
                    | CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, core_slice_base_addr);
  103658:	2264      	movs	r2, #100	; 0x64
  10365a:	501d      	str	r5, [r3, r0]
  10365c:	e001      	b.n	103662 <clkgen_core_slice_switch+0x66>
    } while (--retrycount);
  10365e:	3a01      	subs	r2, #1
  103660:	d006      	beq.n	103670 <clkgen_core_slice_switch+0x74>
        v = readl(reg);
  103662:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103664:	012d      	lsls	r5, r5, #4
  103666:	d5fa      	bpl.n	10365e <clkgen_core_slice_switch+0x62>
    RMWREG32(reg, start, width, setvalue);
  103668:	581a      	ldr	r2, [r3, r0]
  10366a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  10366e:	501a      	str	r2, [r3, r0]
        reg_poll_clear(core_slice_base_addr,
                       CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(core_slice_base_addr);
  103670:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
        writel(reg_write, core_slice_base_addr);
  103672:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read | CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK;
  103674:	f442 7200 	orr.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  103678:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  10367a:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  10367c:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  10367e:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  103680:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  103684:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  103686:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  103688:	501a      	str	r2, [r3, r0]
  10368a:	e003      	b.n	103694 <clkgen_core_slice_switch+0x98>
        spin(1);
  10368c:	f006 fde0 	bl	10a250 <spin>
    } while (--retrycount);
  103690:	3d01      	subs	r5, #1
  103692:	d043      	beq.n	10371c <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  103694:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103696:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103698:	2b00      	cmp	r3, #0
  10369a:	dbf7      	blt.n	10368c <clkgen_core_slice_switch+0x90>
            return true;
  10369c:	2001      	movs	r0, #1
        ret = reg_poll_value(core_slice_base_addr,
                             CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  10369e:	bd38      	pop	{r3, r4, r5, r15}
        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK) != 0) {
  1036a0:	07ea      	lsls	r2, r5, #31
  1036a2:	d50d      	bpl.n	1036c0 <clkgen_core_slice_switch+0xc4>
            writel(reg_write, core_slice_base_addr);
  1036a4:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK);
  1036a6:	f025 0501 	bic.w	r5, r5, #1
            writel(reg_write, core_slice_base_addr);
  1036aa:	501d      	str	r5, [r3, r0]
  1036ac:	e001      	b.n	1036b2 <clkgen_core_slice_switch+0xb6>
    } while (--retrycount);
  1036ae:	3a01      	subs	r2, #1
  1036b0:	d006      	beq.n	1036c0 <clkgen_core_slice_switch+0xc4>
        v = readl(reg);
  1036b2:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1036b4:	00ed      	lsls	r5, r5, #3
  1036b6:	d5fa      	bpl.n	1036ae <clkgen_core_slice_switch+0xb2>
    RMWREG32(reg, start, width, setvalue);
  1036b8:	581a      	ldr	r2, [r3, r0]
  1036ba:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  1036be:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  1036c0:	794d      	ldrb	r5, [r1, #5]
        reg_read = readl(core_slice_base_addr);
  1036c2:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  1036c4:	006d      	lsls	r5, r5, #1
  1036c6:	f005 050e 	and.w	r5, r5, #14
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  1036ca:	f022 020e 	bic.w	r2, r2, #14
  1036ce:	f045 0501 	orr.w	r5, r5, #1
  1036d2:	4315      	orrs	r5, r2
        writel(reg_write, core_slice_base_addr);
  1036d4:	2264      	movs	r2, #100	; 0x64
  1036d6:	501d      	str	r5, [r3, r0]
  1036d8:	e001      	b.n	1036de <clkgen_core_slice_switch+0xe2>
    } while (--retrycount);
  1036da:	3a01      	subs	r2, #1
  1036dc:	d006      	beq.n	1036ec <clkgen_core_slice_switch+0xf0>
        v = readl(reg);
  1036de:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1036e0:	00ed      	lsls	r5, r5, #3
  1036e2:	d5fa      	bpl.n	1036da <clkgen_core_slice_switch+0xde>
    RMWREG32(reg, start, width, setvalue);
  1036e4:	581a      	ldr	r2, [r3, r0]
  1036e6:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  1036ea:	501a      	str	r2, [r3, r0]
        reg_read = readl(core_slice_base_addr);
  1036ec:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
  1036ee:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK);
  1036f0:	f422 7200 	bic.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  1036f4:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  1036f6:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  1036f8:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  1036fa:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  1036fc:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  103700:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  103702:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  103704:	501a      	str	r2, [r3, r0]
  103706:	e003      	b.n	103710 <clkgen_core_slice_switch+0x114>
        spin(1);
  103708:	f006 fda2 	bl	10a250 <spin>
    } while (--retrycount);
  10370c:	3d01      	subs	r5, #1
  10370e:	d005      	beq.n	10371c <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  103710:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103712:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103714:	2b00      	cmp	r3, #0
  103716:	dbf7      	blt.n	103708 <clkgen_core_slice_switch+0x10c>
            return true;
  103718:	2001      	movs	r0, #1
  10371a:	e7c0      	b.n	10369e <clkgen_core_slice_switch+0xa2>
    CLKGEN_ASSERT_PARAMETER(base);
  10371c:	2000      	movs	r0, #0
}
  10371e:	bd38      	pop	{r3, r4, r5, r15}

00103720 <clkgen_core_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  103720:	b11a      	cbz	r2, 10372a <clkgen_core_ctl_get+0xa>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  103722:	31c0      	adds	r1, #192	; 0xc0
  103724:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  103726:	580b      	ldr	r3, [r1, r0]
  103728:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  10372a:	2001      	movs	r0, #1
  10372c:	4770      	bx	r14
  10372e:	bf00      	nop

00103730 <clkgen_core_ctl_set>:
                         const clkgen_core_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  103730:	2a00      	cmp	r2, #0
  103732:	f000 8081 	beq.w	103838 <clkgen_core_ctl_set+0x108>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  103736:	f101 03c0 	add.w	r3, r1, #192	; 0xc0
{
  10373a:	b570      	push	{r4, r5, r6, r14}
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  10373c:	031b      	lsls	r3, r3, #12
  10373e:	181c      	adds	r4, r3, r0
        clkgen_core_ctl c;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        c.val = readl(slice_addr);
  103740:	581e      	ldr	r6, [r3, r0]

        if (c.a_b_sel == 0) {
  103742:	f3c6 2107 	ubfx	r1, r6, #8, #8
  103746:	f011 0102 	ands.w	r1, r1, #2
  10374a:	d13a      	bne.n	1037c2 <clkgen_core_ctl_set+0x92>
            //set pre_en_b to 0x0,disable the clock
            if (c.cg_en_b != 0) {
  10374c:	03f5      	lsls	r5, r6, #15
  10374e:	d50d      	bpl.n	10376c <clkgen_core_ctl_set+0x3c>
                c.cg_en_b = 0;
  103750:	f361 4610 	bfi	r6, r1, #16, #1
                writel(c.val, slice_addr);
  103754:	2164      	movs	r1, #100	; 0x64
  103756:	501e      	str	r6, [r3, r0]
  103758:	e001      	b.n	10375e <clkgen_core_ctl_set+0x2e>
    } while (--retrycount);
  10375a:	3901      	subs	r1, #1
  10375c:	d006      	beq.n	10376c <clkgen_core_ctl_set+0x3c>
        v = readl(reg);
  10375e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103760:	012d      	lsls	r5, r5, #4
  103762:	d5fa      	bpl.n	10375a <clkgen_core_ctl_set+0x2a>
    RMWREG32(reg, start, width, setvalue);
  103764:	5819      	ldr	r1, [r3, r0]
  103766:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  10376a:	5019      	str	r1, [r3, r0]
                reg_poll_clear(slice_addr, CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1,
                               1, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            c.src_sel_b = ctl->src_sel_a;
  10376c:	7811      	ldrb	r1, [r2, #0]
  10376e:	f3c1 0542 	ubfx	r5, r1, #1, #3
  103772:	f365 4653 	bfi	r6, r5, #17, #3
            c.cg_en_b = ctl->cg_en_a;
  103776:	f3c1 0100 	ubfx	r1, r1, #0, #1
  10377a:	f361 4610 	bfi	r6, r1, #16, #1
            writel(c.val, slice_addr);

            if (c.cg_en_b)
  10377e:	03f1      	lsls	r1, r6, #15
            writel(c.val, slice_addr);
  103780:	501e      	str	r6, [r3, r0]
            if (c.cg_en_b)
  103782:	d50a      	bpl.n	10379a <clkgen_core_ctl_set+0x6a>
  103784:	2164      	movs	r1, #100	; 0x64
  103786:	e001      	b.n	10378c <clkgen_core_ctl_set+0x5c>
    } while (--retrycount);
  103788:	3901      	subs	r1, #1
  10378a:	d006      	beq.n	10379a <clkgen_core_ctl_set+0x6a>
        v = readl(reg);
  10378c:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  10378e:	012d      	lsls	r5, r5, #4
  103790:	d5fa      	bpl.n	103788 <clkgen_core_ctl_set+0x58>
    RMWREG32(reg, start, width, setvalue);
  103792:	5819      	ldr	r1, [r3, r0]
  103794:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  103798:	5019      	str	r1, [r3, r0]
            //invert pre_a_b_sel
            c.a_b_sel = 1;
            writel(c.val, slice_addr);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            c.post_div_num = ctl->post_div_num;
            writel(c.val, slice_addr);
  10379a:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 1;
  10379c:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(c.val, slice_addr);
  1037a0:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  1037a2:	7852      	ldrb	r2, [r2, #1]
  1037a4:	0892      	lsrs	r2, r2, #2
  1037a6:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  1037aa:	501e      	str	r6, [r3, r0]
  1037ac:	e003      	b.n	1037b6 <clkgen_core_ctl_set+0x86>
        spin(1);
  1037ae:	f006 fd4f 	bl	10a250 <spin>
    } while (--retrycount);
  1037b2:	3d01      	subs	r5, #1
  1037b4:	d042      	beq.n	10383c <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  1037b6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1037b8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1037ba:	2b00      	cmp	r3, #0
  1037bc:	dbf7      	blt.n	1037ae <clkgen_core_ctl_set+0x7e>
            return true;
  1037be:	2001      	movs	r0, #1
                                 CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        }
    }

    return ret;
}
  1037c0:	bd70      	pop	{r4, r5, r6, r15}
            if (c.cg_en_a != 0) {
  1037c2:	07f1      	lsls	r1, r6, #31
  1037c4:	d50d      	bpl.n	1037e2 <clkgen_core_ctl_set+0xb2>
                writel(c.val, slice_addr);
  1037c6:	2164      	movs	r1, #100	; 0x64
                c.cg_en_a = 0;
  1037c8:	f36f 0600 	bfc	r6, #0, #1
                writel(c.val, slice_addr);
  1037cc:	501e      	str	r6, [r3, r0]
  1037ce:	e001      	b.n	1037d4 <clkgen_core_ctl_set+0xa4>
    } while (--retrycount);
  1037d0:	3901      	subs	r1, #1
  1037d2:	d006      	beq.n	1037e2 <clkgen_core_ctl_set+0xb2>
        v = readl(reg);
  1037d4:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1037d6:	00ed      	lsls	r5, r5, #3
  1037d8:	d5fa      	bpl.n	1037d0 <clkgen_core_ctl_set+0xa0>
    RMWREG32(reg, start, width, setvalue);
  1037da:	5819      	ldr	r1, [r3, r0]
  1037dc:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  1037e0:	5019      	str	r1, [r3, r0]
            c.src_sel_a = ctl->src_sel_a;
  1037e2:	7811      	ldrb	r1, [r2, #0]
  1037e4:	f3c1 0542 	ubfx	r5, r1, #1, #3
  1037e8:	f365 0643 	bfi	r6, r5, #1, #3
            c.cg_en_a = ctl->cg_en_a;
  1037ec:	f3c1 0100 	ubfx	r1, r1, #0, #1
  1037f0:	f361 0600 	bfi	r6, r1, #0, #1
            if (c.cg_en_a)
  1037f4:	07f1      	lsls	r1, r6, #31
            writel(c.val, slice_addr);
  1037f6:	501e      	str	r6, [r3, r0]
            if (c.cg_en_a)
  1037f8:	d50a      	bpl.n	103810 <clkgen_core_ctl_set+0xe0>
  1037fa:	2164      	movs	r1, #100	; 0x64
  1037fc:	e001      	b.n	103802 <clkgen_core_ctl_set+0xd2>
    } while (--retrycount);
  1037fe:	3901      	subs	r1, #1
  103800:	d006      	beq.n	103810 <clkgen_core_ctl_set+0xe0>
        v = readl(reg);
  103802:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  103804:	00ed      	lsls	r5, r5, #3
  103806:	d5fa      	bpl.n	1037fe <clkgen_core_ctl_set+0xce>
    RMWREG32(reg, start, width, setvalue);
  103808:	5819      	ldr	r1, [r3, r0]
  10380a:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  10380e:	5019      	str	r1, [r3, r0]
            writel(c.val, slice_addr);
  103810:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 0;
  103812:	f36f 2649 	bfc	r6, #9, #1
            writel(c.val, slice_addr);
  103816:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  103818:	7852      	ldrb	r2, [r2, #1]
  10381a:	0892      	lsrs	r2, r2, #2
  10381c:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  103820:	501e      	str	r6, [r3, r0]
  103822:	e003      	b.n	10382c <clkgen_core_ctl_set+0xfc>
        spin(1);
  103824:	f006 fd14 	bl	10a250 <spin>
    } while (--retrycount);
  103828:	3d01      	subs	r5, #1
  10382a:	d007      	beq.n	10383c <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  10382c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10382e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103830:	2b00      	cmp	r3, #0
  103832:	dbf7      	blt.n	103824 <clkgen_core_ctl_set+0xf4>
            return true;
  103834:	2001      	movs	r0, #1
  103836:	e7c3      	b.n	1037c0 <clkgen_core_ctl_set+0x90>
    bool ret = true;
  103838:	2001      	movs	r0, #1
}
  10383a:	4770      	bx	r14
    return false;
  10383c:	2000      	movs	r0, #0
}
  10383e:	bd70      	pop	{r4, r5, r6, r15}

00103840 <clkgen_mon_ip_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_ip_slice(vaddr_t base, uint16_t ip_slice_idx,
                             clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                             clkgen_slice_mon_ret_type ret_type)
{
  103840:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  103844:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103846:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  10384a:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  10384e:	d006      	beq.n	10385e <clkgen_mon_ip_slice+0x1e>
  103850:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  103854:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  103858:	bf18      	it	ne
  10385a:	2000      	movne	r0, #0
  10385c:	d162      	bne.n	103924 <clkgen_mon_ip_slice+0xe4>
  10385e:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  103860:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  103864:	4692      	mov	r10, r2
  103866:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  10386a:	4689      	mov	r9, r1
  10386c:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  10386e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    ip_slice_mon_base_addr = base + CLKGEN_IP_SLICE_MON_CTL_OFF;
  103872:	f500 1be4 	add.w	r11, r0, #1867776	; 0x1c8000
    reg_read = readl(mon_ctl_base_addr);
  103876:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103878:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  10387c:	6023      	str	r3, [r4, #0]
  10387e:	e003      	b.n	103888 <clkgen_mon_ip_slice+0x48>
        spin(1);
  103880:	f006 fce6 	bl	10a250 <spin>
    } while (--retrycount);
  103884:	3d01      	subs	r5, #1
  103886:	d003      	beq.n	103890 <clkgen_mon_ip_slice+0x50>
        v = readl(reg);
  103888:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10388a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  10388c:	015b      	lsls	r3, r3, #5
  10388e:	d5f7      	bpl.n	103880 <clkgen_mon_ip_slice+0x40>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(ip_slice_mon_base_addr);
  103890:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read & (~CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL_MASK);
  103894:	0c09      	lsrs	r1, r1, #16
  103896:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL(
  103898:	ea49 0101 	orr.w	r1, r9, r1
                    ip_slice_idx);
    writel(reg_write, ip_slice_mon_base_addr);
  10389c:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  1038a0:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  1038a2:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
                    slice_mon_ip_clk); //ip slice
    writel(reg_write, mon_ctl_base_addr);
  1038a6:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  1038a8:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  1038aa:	f1ba 0f00 	cmp.w	r10, #0
  1038ae:	d03b      	beq.n	103928 <clkgen_mon_ip_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  1038b0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  1038b4:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  1038b6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  1038b8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  1038bc:	0c1b      	lsrs	r3, r3, #16
  1038be:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  1038c0:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  1038c4:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  1038c6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  1038c8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1038cc:	6023      	str	r3, [r4, #0]
  1038ce:	e003      	b.n	1038d8 <clkgen_mon_ip_slice+0x98>
        spin(1);
  1038d0:	f006 fcbe 	bl	10a250 <spin>
    } while (--retrycount);
  1038d4:	3d01      	subs	r5, #1
  1038d6:	d003      	beq.n	1038e0 <clkgen_mon_ip_slice+0xa0>
        v = readl(reg);
  1038d8:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1038da:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1038dc:	0159      	lsls	r1, r3, #5
  1038de:	d4f7      	bmi.n	1038d0 <clkgen_mon_ip_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  1038e0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  1038e4:	e003      	b.n	1038ee <clkgen_mon_ip_slice+0xae>
        spin(1);
  1038e6:	f006 fcb3 	bl	10a250 <spin>
    } while (--retrycount);
  1038ea:	3d01      	subs	r5, #1
  1038ec:	d003      	beq.n	1038f6 <clkgen_mon_ip_slice+0xb6>
        v = readl(reg);
  1038ee:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1038f0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1038f2:	011a      	lsls	r2, r3, #4
  1038f4:	d5f7      	bpl.n	1038e6 <clkgen_mon_ip_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  1038f6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  1038f8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  1038fc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  103900:	6023      	str	r3, [r4, #0]
  103902:	e003      	b.n	10390c <clkgen_mon_ip_slice+0xcc>
        spin(1);
  103904:	f006 fca4 	bl	10a250 <spin>
    } while (--retrycount);
  103908:	3d01      	subs	r5, #1
  10390a:	d003      	beq.n	103914 <clkgen_mon_ip_slice+0xd4>
        v = readl(reg);
  10390c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  10390e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103910:	00db      	lsls	r3, r3, #3
  103912:	d4f7      	bmi.n	103904 <clkgen_mon_ip_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  103914:	b967      	cbnz	r7, 103930 <clkgen_mon_ip_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  103916:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  10391a:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  10391c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  10391e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103922:	6023      	str	r3, [r4, #0]
    return ret;
}
  103924:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  103928:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  10392c:	6023      	str	r3, [r4, #0]
  10392e:	e7c2      	b.n	1038b6 <clkgen_mon_ip_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  103930:	2f01      	cmp	r7, #1
  103932:	d00e      	beq.n	103952 <clkgen_mon_ip_slice+0x112>
    else if (mon_min_freq == ret_type) {
  103934:	2f02      	cmp	r7, #2
  103936:	d008      	beq.n	10394a <clkgen_mon_ip_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  103938:	2f03      	cmp	r7, #3
  10393a:	d010      	beq.n	10395e <clkgen_mon_ip_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  10393c:	2f04      	cmp	r7, #4
        ret = 0;
  10393e:	bf12      	itee	ne
  103940:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  103942:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  103946:	6830      	ldreq	r0, [r6, #0]
  103948:	e7e8      	b.n	10391c <clkgen_mon_ip_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  10394a:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  10394e:	6830      	ldr	r0, [r6, #0]
  103950:	e7e4      	b.n	10391c <clkgen_mon_ip_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  103952:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  103956:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  10395a:	6830      	ldr	r0, [r6, #0]
  10395c:	e7de      	b.n	10391c <clkgen_mon_ip_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  10395e:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  103962:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  103966:	6830      	ldr	r0, [r6, #0]
  103968:	e7d8      	b.n	10391c <clkgen_mon_ip_slice+0xdc>
  10396a:	bf00      	nop

0010396c <clkgen_mon_bus_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_bus_slice(vaddr_t base, uint16_t bus_slice_idx,
                              clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                              clkgen_slice_mon_ret_type ret_type)
{
  10396c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  103970:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103972:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  103976:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  10397a:	d006      	beq.n	10398a <clkgen_mon_bus_slice+0x1e>
  10397c:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  103980:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  103984:	bf18      	it	ne
  103986:	2000      	movne	r0, #0
  103988:	d165      	bne.n	103a56 <clkgen_mon_bus_slice+0xea>
  10398a:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  10398c:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  103990:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  103994:	4693      	mov	r11, r2
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  103996:	f500 1ae4 	add.w	r10, r0, #1867776	; 0x1c8000
  10399a:	4689      	mov	r9, r1
  10399c:	4606      	mov	r6, r0
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
  10399e:	6823      	ldr	r3, [r4, #0]
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  1039a0:	f50a 5a80 	add.w	r10, r10, #4096	; 0x1000
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  1039a4:	2564      	movs	r5, #100	; 0x64
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  1039a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1039aa:	6023      	str	r3, [r4, #0]
  1039ac:	e003      	b.n	1039b6 <clkgen_mon_bus_slice+0x4a>
        spin(1);
  1039ae:	f006 fc4f 	bl	10a250 <spin>
    } while (--retrycount);
  1039b2:	3d01      	subs	r5, #1
  1039b4:	d003      	beq.n	1039be <clkgen_mon_bus_slice+0x52>
        v = readl(reg);
  1039b6:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1039b8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1039ba:	015b      	lsls	r3, r3, #5
  1039bc:	d5f7      	bpl.n	1039ae <clkgen_mon_bus_slice+0x42>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 100);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(bus_slice_mon_base_addr);
  1039be:	f8da 1000 	ldr.w	r1, [r10]
    reg_write = reg_read & (~CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL_MASK);
  1039c2:	0c09      	lsrs	r1, r1, #16
  1039c4:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL(
  1039c6:	ea49 0101 	orr.w	r1, r9, r1
                    bus_slice_idx);
    writel(reg_write, bus_slice_mon_base_addr);
  1039ca:	f8ca 1000 	str.w	r1, [r10]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  1039ce:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  1039d0:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  1039d4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
                    slice_mon_bus_clk); //bus slice
    writel(reg_write, mon_ctl_base_addr);
  1039d8:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  1039da:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  1039dc:	f1bb 0f00 	cmp.w	r11, #0
  1039e0:	d03b      	beq.n	103a5a <clkgen_mon_bus_slice+0xee>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  1039e2:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  1039e6:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  1039e8:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  1039ea:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  1039ee:	0c1b      	lsrs	r3, r3, #16
  1039f0:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  1039f2:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  1039f6:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  1039f8:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  1039fa:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1039fe:	6023      	str	r3, [r4, #0]
  103a00:	e003      	b.n	103a0a <clkgen_mon_bus_slice+0x9e>
        spin(1);
  103a02:	f006 fc25 	bl	10a250 <spin>
    } while (--retrycount);
  103a06:	3d01      	subs	r5, #1
  103a08:	d003      	beq.n	103a12 <clkgen_mon_bus_slice+0xa6>
        v = readl(reg);
  103a0a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103a0c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103a0e:	0159      	lsls	r1, r3, #5
  103a10:	d4f7      	bmi.n	103a02 <clkgen_mon_bus_slice+0x96>
    writel(reg_write, mon_ctl_base_addr);
  103a12:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  103a16:	e003      	b.n	103a20 <clkgen_mon_bus_slice+0xb4>
        spin(1);
  103a18:	f006 fc1a 	bl	10a250 <spin>
    } while (--retrycount);
  103a1c:	3d01      	subs	r5, #1
  103a1e:	d003      	beq.n	103a28 <clkgen_mon_bus_slice+0xbc>
        v = readl(reg);
  103a20:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103a22:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103a24:	011a      	lsls	r2, r3, #4
  103a26:	d5f7      	bpl.n	103a18 <clkgen_mon_bus_slice+0xac>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103a28:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103a2a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  103a2e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  103a32:	6023      	str	r3, [r4, #0]
  103a34:	e003      	b.n	103a3e <clkgen_mon_bus_slice+0xd2>
        spin(1);
  103a36:	f006 fc0b 	bl	10a250 <spin>
    } while (--retrycount);
  103a3a:	3d01      	subs	r5, #1
  103a3c:	d003      	beq.n	103a46 <clkgen_mon_bus_slice+0xda>
        v = readl(reg);
  103a3e:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103a40:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103a42:	00db      	lsls	r3, r3, #3
  103a44:	d4f7      	bmi.n	103a36 <clkgen_mon_bus_slice+0xca>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  103a46:	b967      	cbnz	r7, 103a62 <clkgen_mon_bus_slice+0xf6>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  103a48:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  103a4c:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103a4e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103a50:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103a54:	6023      	str	r3, [r4, #0]
    return ret;
}
  103a56:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  103a5a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103a5e:	6023      	str	r3, [r4, #0]
  103a60:	e7c2      	b.n	1039e8 <clkgen_mon_bus_slice+0x7c>
    else if (mon_avg_freq == ret_type) {
  103a62:	2f01      	cmp	r7, #1
  103a64:	d00e      	beq.n	103a84 <clkgen_mon_bus_slice+0x118>
    else if (mon_min_freq == ret_type) {
  103a66:	2f02      	cmp	r7, #2
  103a68:	d008      	beq.n	103a7c <clkgen_mon_bus_slice+0x110>
    else if (mon_max_duty == ret_type) {
  103a6a:	2f03      	cmp	r7, #3
  103a6c:	d010      	beq.n	103a90 <clkgen_mon_bus_slice+0x124>
    else if (mon_min_duty == ret_type) {
  103a6e:	2f04      	cmp	r7, #4
        ret = 0;
  103a70:	bf12      	itee	ne
  103a72:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  103a74:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  103a78:	6830      	ldreq	r0, [r6, #0]
  103a7a:	e7e8      	b.n	103a4e <clkgen_mon_bus_slice+0xe2>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  103a7c:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  103a80:	6830      	ldr	r0, [r6, #0]
  103a82:	e7e4      	b.n	103a4e <clkgen_mon_bus_slice+0xe2>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  103a84:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  103a88:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  103a8c:	6830      	ldr	r0, [r6, #0]
  103a8e:	e7de      	b.n	103a4e <clkgen_mon_bus_slice+0xe2>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  103a90:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  103a94:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  103a98:	6830      	ldr	r0, [r6, #0]
  103a9a:	e7d8      	b.n	103a4e <clkgen_mon_bus_slice+0xe2>

00103a9c <clkgen_mon_core_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_core_slice(vaddr_t base, uint16_t core_slice_idx,
                               clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                               clkgen_slice_mon_ret_type ret_type)
{
  103a9c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  103aa0:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103aa2:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  103aa6:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  103aaa:	d006      	beq.n	103aba <clkgen_mon_core_slice+0x1e>
  103aac:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  103ab0:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  103ab4:	bf18      	it	ne
  103ab6:	2000      	movne	r0, #0
  103ab8:	d162      	bne.n	103b80 <clkgen_mon_core_slice+0xe4>
  103aba:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
    core_slice_mon_base_addr = base + CLKGEN_CORE_SLICE_MON_CTL_OFF;
  103abc:	f500 1be5 	add.w	r11, r0, #1875968	; 0x1ca000
  103ac0:	4692      	mov	r10, r2
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  103ac2:	f50b 5480 	add.w	r4, r11, #4096	; 0x1000
  103ac6:	4689      	mov	r9, r1
  103ac8:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103aca:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_read = readl(mon_ctl_base_addr);
  103ace:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103ad0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103ad4:	6023      	str	r3, [r4, #0]
  103ad6:	e003      	b.n	103ae0 <clkgen_mon_core_slice+0x44>
        spin(1);
  103ad8:	f006 fbba 	bl	10a250 <spin>
    } while (--retrycount);
  103adc:	3d01      	subs	r5, #1
  103ade:	d003      	beq.n	103ae8 <clkgen_mon_core_slice+0x4c>
        v = readl(reg);
  103ae0:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103ae2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103ae4:	015b      	lsls	r3, r3, #5
  103ae6:	d5f7      	bpl.n	103ad8 <clkgen_mon_core_slice+0x3c>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(core_slice_mon_base_addr);
  103ae8:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read &
  103aec:	0c09      	lsrs	r1, r1, #16
  103aee:	0409      	lsls	r1, r1, #16
                (~CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL_MASK);
    reg_write = reg_write | CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL(
  103af0:	ea49 0101 	orr.w	r1, r9, r1
                    core_slice_idx);
    writel(reg_write, core_slice_mon_base_addr);
  103af4:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  103af8:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  103afa:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  103afe:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
                    slice_mon_core_clk); //core slice
    writel(reg_write, mon_ctl_base_addr);
  103b02:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  103b04:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  103b06:	f1ba 0f00 	cmp.w	r10, #0
  103b0a:	d03b      	beq.n	103b84 <clkgen_mon_core_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  103b0c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103b10:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  103b12:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  103b14:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  103b18:	0c1b      	lsrs	r3, r3, #16
  103b1a:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  103b1c:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  103b20:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  103b22:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  103b24:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103b28:	6023      	str	r3, [r4, #0]
  103b2a:	e003      	b.n	103b34 <clkgen_mon_core_slice+0x98>
        spin(1);
  103b2c:	f006 fb90 	bl	10a250 <spin>
    } while (--retrycount);
  103b30:	3d01      	subs	r5, #1
  103b32:	d003      	beq.n	103b3c <clkgen_mon_core_slice+0xa0>
        v = readl(reg);
  103b34:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103b36:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103b38:	0159      	lsls	r1, r3, #5
  103b3a:	d4f7      	bmi.n	103b2c <clkgen_mon_core_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  103b3c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  103b40:	e003      	b.n	103b4a <clkgen_mon_core_slice+0xae>
        spin(1);
  103b42:	f006 fb85 	bl	10a250 <spin>
    } while (--retrycount);
  103b46:	3d01      	subs	r5, #1
  103b48:	d003      	beq.n	103b52 <clkgen_mon_core_slice+0xb6>
        v = readl(reg);
  103b4a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103b4c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103b4e:	011a      	lsls	r2, r3, #4
  103b50:	d5f7      	bpl.n	103b42 <clkgen_mon_core_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103b52:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  103b54:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  103b58:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  103b5c:	6023      	str	r3, [r4, #0]
  103b5e:	e003      	b.n	103b68 <clkgen_mon_core_slice+0xcc>
        spin(1);
  103b60:	f006 fb76 	bl	10a250 <spin>
    } while (--retrycount);
  103b64:	3d01      	subs	r5, #1
  103b66:	d003      	beq.n	103b70 <clkgen_mon_core_slice+0xd4>
        v = readl(reg);
  103b68:	6823      	ldr	r3, [r4, #0]
        spin(1);
  103b6a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  103b6c:	00db      	lsls	r3, r3, #3
  103b6e:	d4f7      	bmi.n	103b60 <clkgen_mon_core_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  103b70:	b967      	cbnz	r7, 103b8c <clkgen_mon_core_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  103b72:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  103b76:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  103b78:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  103b7a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  103b7e:	6023      	str	r3, [r4, #0]
    return ret;
}
  103b80:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  103b84:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  103b88:	6023      	str	r3, [r4, #0]
  103b8a:	e7c2      	b.n	103b12 <clkgen_mon_core_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  103b8c:	2f01      	cmp	r7, #1
  103b8e:	d00e      	beq.n	103bae <clkgen_mon_core_slice+0x112>
    else if (mon_min_freq == ret_type) {
  103b90:	2f02      	cmp	r7, #2
  103b92:	d008      	beq.n	103ba6 <clkgen_mon_core_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  103b94:	2f03      	cmp	r7, #3
  103b96:	d010      	beq.n	103bba <clkgen_mon_core_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  103b98:	2f04      	cmp	r7, #4
        ret = 0;
  103b9a:	bf12      	itee	ne
  103b9c:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  103b9e:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  103ba2:	6830      	ldreq	r0, [r6, #0]
  103ba4:	e7e8      	b.n	103b78 <clkgen_mon_core_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  103ba6:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  103baa:	6830      	ldr	r0, [r6, #0]
  103bac:	e7e4      	b.n	103b78 <clkgen_mon_core_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  103bae:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  103bb2:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  103bb6:	6830      	ldr	r0, [r6, #0]
  103bb8:	e7de      	b.n	103b78 <clkgen_mon_core_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  103bba:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  103bbe:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  103bc2:	6830      	ldr	r0, [r6, #0]
  103bc4:	e7d8      	b.n	103b78 <clkgen_mon_core_slice+0xdc>
  103bc6:	bf00      	nop

00103bc8 <clkgen_uuu_clock_wrapper>:
    vaddr_t uuu_wrapper_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if (base != CKGEN_SOC_BASE) {
  103bc8:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
{
  103bcc:	b4f0      	push	{r4, r5, r6, r7}
  103bce:	f89d 5010 	ldrb.w	r5, [r13, #16]
        LTRACEF("base paramenter error \n");
        return 0;
  103bd2:	bf18      	it	ne
  103bd4:	2000      	movne	r0, #0
    if (base != CKGEN_SOC_BASE) {
  103bd6:	d001      	beq.n	103bdc <clkgen_uuu_clock_wrapper+0x14>
#endif
    }

    ret = true;
    return ret;
}
  103bd8:	bcf0      	pop	{r4, r5, r6, r7}
  103bda:	4770      	bx	r14
  103bdc:	7814      	ldrb	r4, [r2, #0]
  103bde:	0324      	lsls	r4, r4, #12
  103be0:	7856      	ldrb	r6, [r2, #1]
  103be2:	0236      	lsls	r6, r6, #8
  103be4:	b2a4      	uxth	r4, r4
  103be6:	7890      	ldrb	r0, [r2, #2]
  103be8:	f406 6670 	and.w	r6, r6, #3840	; 0xf00
  103bec:	78d7      	ldrb	r7, [r2, #3]
  103bee:	0100      	lsls	r0, r0, #4
  103bf0:	ea44 0206 	orr.w	r2, r4, r6
    uuu_wrapper_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(
  103bf4:	0309      	lsls	r1, r1, #12
  103bf6:	f007 040f 	and.w	r4, r7, #15
  103bfa:	f101 4176 	add.w	r1, r1, #4127195136	; 0xf6000000
  103bfe:	042d      	lsls	r5, r5, #16
  103c00:	4322      	orrs	r2, r4
  103c02:	b2c0      	uxtb	r0, r0
  103c04:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
  103c08:	f405 2570 	and.w	r5, r5, #983040	; 0xf0000
  103c0c:	4302      	orrs	r2, r0
    if (low_power_mode) {
  103c0e:	b963      	cbnz	r3, 103c2a <clkgen_uuu_clock_wrapper+0x62>
        reg_read = readl(uuu_wrapper_base_addr);
  103c10:	680b      	ldr	r3, [r1, #0]
    return ret;
  103c12:	2001      	movs	r0, #1
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(
  103c14:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type << 0);
  103c18:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103c1a:	600d      	str	r5, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  103c1c:	680b      	ldr	r3, [r1, #0]
}
  103c1e:	bcf0      	pop	{r4, r5, r6, r7}
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  103c20:	0c1b      	lsrs	r3, r3, #16
  103c22:	041b      	lsls	r3, r3, #16
        reg_write |= CLKGEN_UUU_SLICE_M_DIV_NUM(gasket_div->m_div_num)
  103c24:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103c26:	600a      	str	r2, [r1, #0]
}
  103c28:	4770      	bx	r14
        reg_read = readl(uuu_wrapper_base_addr);
  103c2a:	680c      	ldr	r4, [r1, #0]
    return ret;
  103c2c:	4618      	mov	r0, r3
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  103c2e:	0c23      	lsrs	r3, r4, #16
  103c30:	041b      	lsls	r3, r3, #16
        reg_write |=
  103c32:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103c34:	600a      	str	r2, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  103c36:	680b      	ldr	r3, [r1, #0]
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(0x3)));
  103c38:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type);
  103c3c:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  103c3e:	600d      	str	r5, [r1, #0]
}
  103c40:	bcf0      	pop	{r4, r5, r6, r7}
  103c42:	4770      	bx	r14

00103c44 <clkgen_uuu_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  103c44:	b122      	cbz	r2, 103c50 <clkgen_uuu_ctl_get+0xc>
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103c46:	f501 71c0 	add.w	r1, r1, #384	; 0x180
  103c4a:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  103c4c:	580b      	ldr	r3, [r1, r0]
  103c4e:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  103c50:	2001      	movs	r0, #1
  103c52:	4770      	bx	r14

00103c54 <clkgen_uuu_ctl_set>:
                        const clkgen_uuu_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  103c54:	b33a      	cbz	r2, 103ca6 <clkgen_uuu_ctl_set+0x52>
        clkgen_uuu_ctl c;
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103c56:	f501 71c0 	add.w	r1, r1, #384	; 0x180
{
  103c5a:	b470      	push	{r4, r5, r6}
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103c5c:	0309      	lsls	r1, r1, #12
        // 1.Program CKGEN_SOC corresponding slice to get proper clk_ckgen frequency. hal process
        //wait#######################
        // 2.Release SS reset(some ss don't have separate SS reset). set reset to 1 release reset,hal process
        //wait#######################
        // 3.Set clk_sel[0] and clk_sel[1]both to 0x0(default of both of them are 0x0)
        c.val = readl(slice_addr);
  103c5e:	580b      	ldr	r3, [r1, r0]
        c.uuu_sel0 = 0;
  103c60:	f36f 4310 	bfc	r3, #16, #1
        c.uuu_sel1 = 0;
  103c64:	f36f 4351 	bfc	r3, #17, #1
        writel(c.val, slice_addr);
  103c68:	500b      	str	r3, [r1, r0]
        // 4.Program PLL_x to enable PLL and get the proper frequency.(see PLL programming guide).
        // call pll func enable pll clock,
        //wait#######################
        // 5.Set Div_m/n/p/q to the proper value before change the clock source from ckgen to PLL.(Div_m/n/p/q can be changed on-the-fly.)
        c.m_div = ctl->m_div;
  103c6a:	7855      	ldrb	r5, [r2, #1]
  103c6c:	092e      	lsrs	r6, r5, #4
        c.n_div = ctl->n_div;
        c.p_div = ctl->p_div;
  103c6e:	7814      	ldrb	r4, [r2, #0]
        c.m_div = ctl->m_div;
  103c70:	f366 330f 	bfi	r3, r6, #12, #4
        c.n_div = ctl->n_div;
  103c74:	f3c5 0503 	ubfx	r5, r5, #0, #4
  103c78:	f365 230b 	bfi	r3, r5, #8, #4
        c.p_div = ctl->p_div;
  103c7c:	0925      	lsrs	r5, r4, #4
  103c7e:	f365 1307 	bfi	r3, r5, #4, #4
        c.q_div = ctl->q_div;
  103c82:	f3c4 0403 	ubfx	r4, r4, #0, #4
  103c86:	f364 0303 	bfi	r3, r4, #0, #4
        writel(c.val, slice_addr);
  103c8a:	500b      	str	r3, [r1, r0]
        // 6.Set clk_sel[0] to 0x1 to set clk_out_1/2/3 source from PLL_x.
        // 7.Set clk_sel[1] to 0x1 to set clk_out_0 source from PLL_x.
        c.uuu_sel0 = ctl->uuu_sel0;
  103c8c:	7892      	ldrb	r2, [r2, #2]
  103c8e:	f3c2 0400 	ubfx	r4, r2, #0, #1
  103c92:	f364 4310 	bfi	r3, r4, #16, #1
        c.uuu_sel1 = ctl->uuu_sel1;
  103c96:	f3c2 0240 	ubfx	r2, r2, #1, #1
  103c9a:	f362 4351 	bfi	r3, r2, #17, #1
        writel(c.val, slice_addr);
    }

    return ret;
}
  103c9e:	bc70      	pop	{r4, r5, r6}
        writel(c.val, slice_addr);
  103ca0:	500b      	str	r3, [r1, r0]
}
  103ca2:	2001      	movs	r0, #1
  103ca4:	4770      	bx	r14
  103ca6:	2001      	movs	r0, #1
  103ca8:	4770      	bx	r14
  103caa:	bf00      	nop

00103cac <clkgen_ipslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_ip_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103cac:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103cb0:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103cb4:	d004      	beq.n	103cc0 <clkgen_ipslice_debug_enable+0x14>
  103cb6:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103cba:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103cbe:	d111      	bne.n	103ce4 <clkgen_ipslice_debug_enable+0x38>
{
  103cc0:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_ip_base_addr = base + CLKGEN_IP_SLICE_DBG_CTL_OFF;
  103cc2:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103cc6:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  103cca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_ip_base_addr);
  103cce:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_ip_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103cd0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103cd4:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103cd6:	4329      	orrs	r1, r5
    writel(reg_write, debug_ip_base_addr);
  103cd8:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  103cda:	6819      	ldr	r1, [r3, #0]
}
  103cdc:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103cde:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  103ce0:	601a      	str	r2, [r3, #0]
}
  103ce2:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103ce4:	2000      	movs	r0, #0
}
  103ce6:	4770      	bx	r14

00103ce8 <clkgen_ipslice_debug_disable>:
{
    vaddr_t debug_crtl_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103ce8:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103cec:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103cf0:	d004      	beq.n	103cfc <clkgen_ipslice_debug_disable+0x14>
  103cf2:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103cf6:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103cfa:	d109      	bne.n	103d10 <clkgen_ipslice_debug_disable+0x28>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103cfc:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103d00:	2001      	movs	r0, #1
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103d02:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_crtl_base_addr);
  103d06:	681a      	ldr	r2, [r3, #0]
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103d08:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_crtl_base_addr);
  103d0c:	601a      	str	r2, [r3, #0]
    return true;
  103d0e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d10:	2000      	movs	r0, #0
}
  103d12:	4770      	bx	r14

00103d14 <clkgen_busslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_bus_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103d14:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103d18:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103d1c:	d004      	beq.n	103d28 <clkgen_busslice_debug_enable+0x14>
  103d1e:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103d22:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103d26:	d113      	bne.n	103d50 <clkgen_busslice_debug_enable+0x3c>
{
  103d28:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_bus_base_addr = base + CLKGEN_BUS_SLICE_DBG_CTL_OFF;
  103d2a:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
  103d2e:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103d32:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  103d36:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_bus_base_addr);
  103d3a:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_bus_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103d3c:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103d40:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103d42:	4329      	orrs	r1, r5
    writel(reg_write, debug_bus_base_addr);
  103d44:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  103d46:	6819      	ldr	r1, [r3, #0]
}
  103d48:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103d4a:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  103d4c:	601a      	str	r2, [r3, #0]
}
  103d4e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d50:	2000      	movs	r0, #0
}
  103d52:	4770      	bx	r14

00103d54 <clkgen_busslice_debug_disable>:
  103d54:	f7ff bfc8 	b.w	103ce8 <clkgen_ipslice_debug_disable>

00103d58 <clkgen_coreslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_core_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103d58:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  103d5c:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  103d60:	d004      	beq.n	103d6c <clkgen_coreslice_debug_enable+0x14>
  103d62:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  103d66:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  103d6a:	d10f      	bne.n	103d8c <clkgen_coreslice_debug_enable+0x34>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_core_base_addr = base + CLKGEN_CORE_SLICE_DBG_CTL_OFF;
  103d6c:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
{
  103d70:	b430      	push	{r4, r5}
    reg_read = readl(debug_core_base_addr);
  103d72:	681d      	ldr	r5, [r3, #0]
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  103d74:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  103d78:	2001      	movs	r0, #1
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  103d7a:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  103d7e:	4329      	orrs	r1, r5
    writel(reg_write, debug_core_base_addr);
  103d80:	6019      	str	r1, [r3, #0]
    reg_read = readl(debug_crtl_base_addr);
  103d82:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  103d84:	431a      	orrs	r2, r3
    writel(reg_write, debug_crtl_base_addr);
  103d86:	6022      	str	r2, [r4, #0]
}
  103d88:	bc30      	pop	{r4, r5}
  103d8a:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103d8c:	2000      	movs	r0, #0
}
  103d8e:	4770      	bx	r14

00103d90 <clkgen_coreslice_debug_disable>:
  103d90:	f7ff bfaa 	b.w	103ce8 <clkgen_ipslice_debug_disable>

00103d94 <clkgen_uuuslice_debug_enable>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_enable(vaddr_t base, uint16_t slice_idx,
                                  uint8_t dbg_div)
{
  103d94:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103d96:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  103d9a:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  103d9e:	d004      	beq.n	103daa <clkgen_uuuslice_debug_enable+0x16>
  103da0:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  103da4:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  103da8:	d111      	bne.n	103dce <clkgen_uuuslice_debug_enable+0x3a>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103daa:	0309      	lsls	r1, r1, #12
  103dac:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
{
  103db0:	b410      	push	{r4}
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
  103db2:	58cc      	ldr	r4, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1);
    reg_write = reg_write & (~(CLKGEN_UUU_SLICE_DBG_DIV_NUM(0xF)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  103db4:	06d2      	lsls	r2, r2, #27
    writel(reg_write, debug_uuu_base_addr);
    return true;
  103db6:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  103db8:	f002 42f0 	and.w	r2, r2, #2013265920	; 0x78000000
  103dbc:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
  103dc0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  103dc4:	4322      	orrs	r2, r4
}
  103dc6:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(reg_write, debug_uuu_base_addr);
  103dca:	50ca      	str	r2, [r1, r3]
}
  103dcc:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103dce:	2000      	movs	r0, #0
}
  103dd0:	4770      	bx	r14
  103dd2:	bf00      	nop

00103dd4 <clkgen_uuuslice_debug_disable>:
//! \return true/false
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_disable(vaddr_t base, uint16_t slice_idx)
{
  103dd4:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  103dd6:	f020 6280 	bic.w	r2, r0, #67108864	; 0x4000000
  103dda:	f1b2 4f78 	cmp.w	r2, #4160749568	; 0xf8000000
  103dde:	d004      	beq.n	103dea <clkgen_uuuslice_debug_disable+0x16>
  103de0:	f420 1200 	bic.w	r2, r0, #2097152	; 0x200000
  103de4:	f1b2 4f76 	cmp.w	r2, #4127195136	; 0xf6000000
  103de8:	d108      	bne.n	103dfc <clkgen_uuuslice_debug_disable+0x28>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    writel(reg_write, debug_uuu_base_addr);
    return true;
  103dea:	2001      	movs	r0, #1
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  103dec:	0309      	lsls	r1, r1, #12
  103dee:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
    reg_read = readl(debug_uuu_base_addr);
  103df2:	58ca      	ldr	r2, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
  103df4:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_uuu_base_addr);
  103df8:	50ca      	str	r2, [r1, r3]
    return true;
  103dfa:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  103dfc:	2000      	movs	r0, #0
}
  103dfe:	4770      	bx	r14

00103e00 <sram_config>:
#include <sram_conf.h>
#include <ce_reg.h>
#include <ce.h>

void sram_config(void)
{
  103e00:	b430      	push	{r4, r5}

    value = reg_value(CE4_SRAM_SIZE, 0, CE4_RAM_SIZE_SHIFT, CE4_RAM_SIZE_MASK);
    value = reg_value(CE5_SRAM_SIZE, value, CE5_RAM_SIZE_SHIFT, CE5_RAM_SIZE_MASK);
    value = reg_value(CE6_SRAM_SIZE, value, CE6_RAM_SIZE_SHIFT, CE6_RAM_SIZE_MASK);
    value = reg_value(CE7_SRAM_SIZE, value, CE7_RAM_SIZE_SHIFT, CE7_RAM_SIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103e02:	f248 0008 	movw	r0, #32776	; 0x8008
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103e06:	f248 0504 	movw	r5, #32772	; 0x8004

    value = reg_value(CE0_SEC_SRAM_SIZE, 0, CE0_RAM_SASIZE_SHIFT, CE0_RAM_SASIZE_MASK);
    value = reg_value(CE1_SEC_SRAM_SIZE, value, CE1_RAM_SASIZE_SHIFT, CE1_RAM_SASIZE_MASK);
    value = reg_value(CE2_SEC_SRAM_SIZE, value, CE2_RAM_SASIZE_SHIFT, CE2_RAM_SASIZE_MASK);
    value = reg_value(CE3_SEC_SRAM_SIZE, value, CE3_RAM_SASIZE_SHIFT, CE3_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103e0a:	f248 010c 	movw	r1, #32780	; 0x800c

    value = reg_value(CE4_SEC_SRAM_SIZE, 0, CE4_RAM_SASIZE_SHIFT, CE4_RAM_SASIZE_MASK);
    value = reg_value(CE5_SEC_SRAM_SIZE, value, CE5_RAM_SASIZE_SHIFT, CE5_RAM_SASIZE_MASK);
    value = reg_value(CE6_SEC_SRAM_SIZE, value, CE6_RAM_SASIZE_SHIFT, CE6_RAM_SASIZE_MASK);
    value = reg_value(CE7_SEC_SRAM_SIZE, value, CE7_RAM_SASIZE_SHIFT, CE7_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103e0e:	f248 0310 	movw	r3, #32784	; 0x8010
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103e12:	f04f 3408 	mov.w	r4, #134744072	; 0x8080808
  103e16:	f2cf 0534 	movt	r5, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103e1a:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103e1e:	f2cf 0034 	movt	r0, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103e22:	f2cf 0134 	movt	r1, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  103e26:	602c      	str	r4, [r5, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103e28:	f2cf 0334 	movt	r3, #61492	; 0xf034
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  103e2c:	6004      	str	r4, [r0, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  103e2e:	600a      	str	r2, [r1, #0]
}
  103e30:	bc30      	pop	{r4, r5}
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  103e32:	601a      	str	r2, [r3, #0]
}
  103e34:	4770      	bx	r14
  103e36:	bf00      	nop

00103e38 <trng_irq_handle>:
    return 0;
}

enum handler_return trng_irq_handle(void* arg)
{
    event_signal(&g_trng_signal, false);
  103e38:	f246 0044 	movw	r0, #24644	; 0x6044
  103e3c:	2100      	movs	r1, #0
{
  103e3e:	b508      	push	{r3, r14}
    event_signal(&g_trng_signal, false);
  103e40:	f2c0 0011 	movt	r0, #17
  103e44:	f007 fb06 	bl	10b454 <event_signal>

    LTRACEF("trng_irq_handle\n");

    return 0;
}
  103e48:	2000      	movs	r0, #0
  103e4a:	bd08      	pop	{r3, r15}

00103e4c <ce_globle_init>:

    return 0;
}

int32_t ce_globle_init(void)
{
  103e4c:	b538      	push	{r3, r4, r5, r14}

    if (g_ce_inited) {
  103e4e:	f246 0440 	movw	r4, #24640	; 0x6040
  103e52:	f2c0 0411 	movt	r4, #17
  103e56:	7825      	ldrb	r5, [r4, #0]
  103e58:	b9fd      	cbnz	r5, 103e9a <ce_globle_init+0x4e>
typedef unsigned long spin_lock_saved_state_t;
typedef unsigned long spin_lock_save_flags_t;

static inline void arch_spin_lock_init(spin_lock_t *lock)
{
    *lock = SPIN_LOCK_INITIAL_VALUE;
  103e5a:	f641 739c 	movw	r3, #8092	; 0x1f9c
    }

    LTRACEF("ce_globle_init enter\n");
    spin_lock_init(&(inheap.lock));

    event_init(&g_trng_signal, false, 0);
  103e5e:	f246 0044 	movw	r0, #24644	; 0x6044
  103e62:	f2c0 0311 	movt	r3, #17
  103e66:	462a      	mov	r2, r5
  103e68:	f2c0 0011 	movt	r0, #17
  103e6c:	60dd      	str	r5, [r3, #12]
  103e6e:	4629      	mov	r1, r5
  103e70:	f007 fa88 	bl	10b384 <event_init>
    register_int_handler(ZONE_TRNG_INT, &trng_irq_handle, (void*)0);
  103e74:	f643 6139 	movw	r1, #15929	; 0x3e39
  103e78:	462a      	mov	r2, r5
  103e7a:	f2c0 0110 	movt	r1, #16
  103e7e:	20cd      	movs	r0, #205	; 0xcd
  103e80:	f7fc fc62 	bl	100748 <register_int_handler>

    sram_config();
  103e84:	f7ff ffbc 	bl	103e00 <sram_config>
    writel(0xffff, _ioaddr((src_saf_base + (0x210 << 10))));
  103e88:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  103e8c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    init_vce_key_interface();

    g_ce_inited = true;
  103e90:	2201      	movs	r2, #1
    writel(0xffff, _ioaddr((src_saf_base + (0x210 << 10))));
  103e92:	f6cf 4328 	movt	r3, #64552	; 0xfc28
  103e96:	6019      	str	r1, [r3, #0]
    g_ce_inited = true;
  103e98:	7022      	strb	r2, [r4, #0]

    return 0;
}
  103e9a:	2000      	movs	r0, #0
  103e9c:	bd38      	pop	{r3, r4, r5, r15}
  103e9e:	bf00      	nop

00103ea0 <arm_gic_init_percpu>:
{
#if WITH_LIB_SM
    GICREG(GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
    GICREG(GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
#else
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103ea0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
#endif
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103ea4:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103ea8:	2001      	movs	r0, #1
  103eaa:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103eae:	21ff      	movs	r1, #255	; 0xff
  103eb0:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103eb4:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103eb6:	6019      	str	r1, [r3, #0]
}
  103eb8:	4770      	bx	r14
  103eba:	bf00      	nop

00103ebc <arm_gic_suspend_cpu>:
                   LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_FLAG_SECONDARY_CPUS);

static void arm_gic_suspend_cpu(uint level)
{
    suspend_resume_fiq(false, false);
}
  103ebc:	4770      	bx	r14
  103ebe:	bf00      	nop

00103ec0 <__arm_gic_get_priority_shift>:

static uint8_t __arm_gic_get_priority_shift(uint irq)
{
    u_int reg = irq / 4;
    u_int shift = 8 * (irq % 4);
    uint32_t origin_reg = GICREG(GICD_IPRIORITYR(reg));
  103ec0:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
  103ec4:	f020 0303 	bic.w	r3, r0, #3
  103ec8:	f2cf 5140 	movt	r1, #62784	; 0xf540
  103ecc:	4419      	add	r1, r3
    u_int shift = 8 * (irq % 4);
  103ece:	f000 0303 	and.w	r3, r0, #3
{
  103ed2:	b4f0      	push	{r4, r5, r6, r7}

    gic_set_enable(irq, false);
    //write a mask to check implemented bits.
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  103ed4:	25ff      	movs	r5, #255	; 0xff
    int reg = vector / 32;
  103ed6:	0942      	lsrs	r2, r0, #5
    uint32_t origin_reg = GICREG(GICD_IPRIORITYR(reg));
  103ed8:	680f      	ldr	r7, [r1, #0]
    u_int shift = 8 * (irq % 4);
  103eda:	00dc      	lsls	r4, r3, #3
        GICREG(GICD_ICENABLER(reg)) = mask;
  103edc:	f502 628c 	add.w	r2, r2, #1120	; 0x460
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  103ee0:	fa05 f304 	lsl.w	r3, r5, r4
    uint32_t mask = 1ULL << (vector % 32);
  103ee4:	2501      	movs	r5, #1
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  103ee6:	ea27 0603 	bic.w	r6, r7, r3
        GICREG(GICD_ICENABLER(reg)) = mask;
  103eea:	0092      	lsls	r2, r2, #2
    uint32_t mask = 1ULL << (vector % 32);
  103eec:	f000 001f 	and.w	r0, r0, #31
  103ef0:	fa05 f000 	lsl.w	r0, r5, r0
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  103ef4:	431e      	orrs	r6, r3
        GICREG(GICD_ICENABLER(reg)) = mask;
  103ef6:	f1a2 652c 	sub.w	r5, r2, #180355072	; 0xac00000
        GICREG(GICD_ISENABLER(reg)) = mask;
  103efa:	462a      	mov	r2, r5
        GICREG(GICD_ICENABLER(reg)) = mask;
  103efc:	6028      	str	r0, [r5, #0]
    GICREG(GICD_IPRIORITYR(reg)) = ( (origin_reg & ~(0xff << shift)) | ((uint32_t)0xff << shift) );
  103efe:	600e      	str	r6, [r1, #0]

    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  103f00:	680d      	ldr	r5, [r1, #0]

    uint8_t pri_bit_shift = sanity ? 3 : 4;

    GICREG(GICD_IPRIORITYR(reg)) = origin_reg;
  103f02:	600f      	str	r7, [r1, #0]
        GICREG(GICD_ISENABLER(reg)) = mask;
  103f04:	f842 0c80 	str.w	r0, [r2, #-128]
    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  103f08:	402b      	ands	r3, r5
  103f0a:	40e3      	lsrs	r3, r4

    gic_set_enable(irq, true);


    return pri_bit_shift;
}
  103f0c:	bcf0      	pop	{r4, r5, r6, r7}
    uint8_t sanity = ((GICREG(GICD_IPRIORITYR(reg)) & (0xff << shift)) >> shift) << 4;
  103f0e:	011b      	lsls	r3, r3, #4
    uint8_t pri_bit_shift = sanity ? 3 : 4;
  103f10:	f013 0ff0 	tst.w	r3, #240	; 0xf0
}
  103f14:	bf14      	ite	ne
  103f16:	2003      	movne	r0, #3
  103f18:	2004      	moveq	r0, #4
  103f1a:	4770      	bx	r14

00103f1c <arm_gic_register_int_handler>:
    if (vector >= MAX_INT)
  103f1c:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
{
  103f20:	b510      	push	{r4, r14}
    if (vector >= MAX_INT)
  103f22:	d21e      	bcs.n	103f62 <arm_gic_register_int_handler+0x46>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  103f24:	f3ef 8300 	mrs	r3, CPSR

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  103f28:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  103f2a:	bf48      	it	mi
  103f2c:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  103f2e:	d515      	bpl.n	103f5c <arm_gic_register_int_handler+0x40>
    if (vector < GIC_MAX_PER_CPU_INT)
  103f30:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
  103f32:	bf93      	iteet	ls
  103f34:	f246 73c0 	movwls	r3, #26560	; 0x67c0
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  103f38:	f1a0 0320 	subhi.w	r3, r0, #32
  103f3c:	f646 00c0 	movwhi	r0, #26816	; 0x68c0
        return &int_handler_table_per_cpu[vector][cpu];
  103f40:	f2c0 0311 	movtls	r3, #17
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  103f44:	bf8a      	itet	hi
  103f46:	f2c0 0011 	movthi	r0, #17
        return &int_handler_table_per_cpu[vector][cpu];
  103f4a:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  103f4e:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
        h->arg = arg;
  103f52:	e9c0 1200 	strd	r1, r2, [r0]
static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  103f56:	b104      	cbz	r4, 103f5a <arm_gic_register_int_handler+0x3e>
    __asm__ volatile("cpsie i");
  103f58:	b662      	cpsie	i
}
  103f5a:	bd10      	pop	{r4, r15}
    __asm__ volatile("cpsid i");
  103f5c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  103f5e:	2401      	movs	r4, #1
  103f60:	e7e6      	b.n	103f30 <arm_gic_register_int_handler+0x14>
        panic("register_int_handler: vector out of range %d\n", vector);
  103f62:	f64c 0194 	movw	r1, #51348	; 0xc894
  103f66:	4602      	mov	r2, r0
  103f68:	4670      	mov	r0, r14
  103f6a:	f2c0 0110 	movt	r1, #16
  103f6e:	f006 f981 	bl	10a274 <_panic>
  103f72:	bf00      	nop

00103f74 <arm_gic_init>:
    for (i = 0; i < MAX_INT; i+= 32) {
  103f74:	2200      	movs	r2, #0
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  103f76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
{
  103f7a:	b410      	push	{r4}
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  103f7c:	1153      	asrs	r3, r2, #5
  103f7e:	f503 638c 	add.w	r3, r3, #1120	; 0x460
    for (i = 0; i < MAX_INT; i+= 32) {
  103f82:	3220      	adds	r2, #32
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  103f84:	009b      	lsls	r3, r3, #2
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  103f86:	f503 7180 	add.w	r1, r3, #256	; 0x100
  103f8a:	f1a1 612c 	sub.w	r1, r1, #180355072	; 0xac00000
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  103f8e:	f1a3 632c 	sub.w	r3, r3, #180355072	; 0xac00000
    for (i = 0; i < MAX_INT; i+= 32) {
  103f92:	f5b2 7f90 	cmp.w	r2, #288	; 0x120
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  103f96:	6018      	str	r0, [r3, #0]
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  103f98:	6008      	str	r0, [r1, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
  103f9a:	d1ef      	bne.n	103f7c <arm_gic_init+0x8>
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
  103f9c:	f241 0304 	movw	r3, #4100	; 0x1004
  103fa0:	f2cf 5340 	movt	r3, #62784	; 0xf540
  103fa4:	681b      	ldr	r3, [r3, #0]
    if (arm_gic_max_cpu() > 0) {
  103fa6:	f013 0fe0 	tst.w	r3, #224	; 0xe0
  103faa:	d016      	beq.n	103fda <arm_gic_init+0x66>
  103fac:	f64c 04c4 	movw	r4, #51396	; 0xc8c4
  103fb0:	f04f 3101 	mov.w	r1, #16843009	; 0x1010101
        for (i = 32; i < MAX_INT; i += 4) {
  103fb4:	2220      	movs	r2, #32
  103fb6:	f2c0 0410 	movt	r4, #16
  103fba:	2308      	movs	r3, #8
  103fbc:	e001      	b.n	103fc2 <arm_gic_init+0x4e>
  103fbe:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  103fc2:	f503 63c0 	add.w	r3, r3, #1536	; 0x600
        for (i = 32; i < MAX_INT; i += 4) {
  103fc6:	3204      	adds	r2, #4
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  103fc8:	009b      	lsls	r3, r3, #2
  103fca:	f1a3 602c 	sub.w	r0, r3, #180355072	; 0xac00000
        for (i = 32; i < MAX_INT; i += 4) {
  103fce:	f5b2 7f8a 	cmp.w	r2, #276	; 0x114
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  103fd2:	6001      	str	r1, [r0, #0]
  103fd4:	ea4f 03a2 	mov.w	r3, r2, asr #2
        for (i = 32; i < MAX_INT; i += 4) {
  103fd8:	d1f1      	bne.n	103fbe <arm_gic_init+0x4a>
    GICREG(GICD_CTLR) = 1; // enable GIC0
  103fda:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103fde:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103fe2:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICD_CTLR) = 1; // enable GIC0
  103fe6:	2101      	movs	r1, #1
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103fe8:	24ff      	movs	r4, #255	; 0xff
    GICREG(GICD_CTLR) = 1; // enable GIC0
  103fea:	f2cf 5040 	movt	r0, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103fee:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICD_CTLR) = 1; // enable GIC0
  103ff2:	6001      	str	r1, [r0, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103ff4:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  103ff8:	6011      	str	r1, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  103ffa:	601c      	str	r4, [r3, #0]
}
  103ffc:	f85d 4b04 	ldr.w	r4, [r13], #4
  104000:	4770      	bx	r14
  104002:	bf00      	nop

00104004 <arm_gic_resume_cpu>:
{
  104004:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  104006:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10400a:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
  10400c:	bf48      	it	mi
  10400e:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  104010:	d401      	bmi.n	104016 <arm_gic_resume_cpu+0x12>
    __asm__ volatile("cpsid i");
  104012:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  104014:	2401      	movs	r4, #1
    if (!(GICREG(GICD_CTLR) & 1)) {
  104016:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  10401a:	f2cf 5340 	movt	r3, #62784	; 0xf540
  10401e:	681b      	ldr	r3, [r3, #0]
  104020:	07db      	lsls	r3, r3, #31
  104022:	d50e      	bpl.n	104042 <arm_gic_resume_cpu+0x3e>
    GICREG(GICC_CTLR) = 1; // enable GIC0
  104024:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  104028:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  10402c:	2001      	movs	r0, #1
  10402e:	f2cf 5240 	movt	r2, #62784	; 0xf540
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  104032:	21ff      	movs	r1, #255	; 0xff
  104034:	f2cf 5340 	movt	r3, #62784	; 0xf540
    GICREG(GICC_CTLR) = 1; // enable GIC0
  104038:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  10403a:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10403c:	b104      	cbz	r4, 104040 <arm_gic_resume_cpu+0x3c>
    __asm__ volatile("cpsie i");
  10403e:	b662      	cpsie	i
}
  104040:	bd10      	pop	{r4, r15}
        arm_gic_init();
  104042:	f7ff ff97 	bl	103f74 <arm_gic_init>
  104046:	e7f9      	b.n	10403c <arm_gic_resume_cpu+0x38>

00104048 <arm_gic_set_priority>:
    return ret;
}


status_t arm_gic_set_priority(u_int irq, uint8_t priority)
{
  104048:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10404c:	460c      	mov	r4, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10404e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  104052:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  104054:	bf48      	it	mi
  104056:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10405a:	d402      	bmi.n	104062 <arm_gic_set_priority+0x1a>
    __asm__ volatile("cpsid i");
  10405c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10405e:	f04f 0801 	mov.w	r8, #1
    regval = GICREG(GICD_IPRIORITYR(reg));
  104062:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
  104066:	f020 0303 	bic.w	r3, r0, #3
  10406a:	f2cf 5540 	movt	r5, #62784	; 0xf540
  10406e:	441d      	add	r5, r3
    u_int shift = 8 * (irq % 4);
  104070:	f000 0603 	and.w	r6, r0, #3
    regval = GICREG(GICD_IPRIORITYR(reg));
  104074:	682f      	ldr	r7, [r5, #0]
    priority = priority << (__arm_gic_get_priority_shift(irq));
  104076:	f7ff ff23 	bl	103ec0 <__arm_gic_get_priority_shift>
    u_int mask = 0xff << shift;
  10407a:	23ff      	movs	r3, #255	; 0xff
    u_int shift = 8 * (irq % 4);
  10407c:	00f6      	lsls	r6, r6, #3
    u_int mask = 0xff << shift;
  10407e:	40b3      	lsls	r3, r6
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
  104080:	ea27 0703 	bic.w	r7, r7, r3
    priority = priority << (__arm_gic_get_priority_shift(irq));
  104084:	fa04 f000 	lsl.w	r0, r4, r0
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
  104088:	b2c0      	uxtb	r0, r0
  10408a:	40b0      	lsls	r0, r6
  10408c:	4338      	orrs	r0, r7
    GICREG(GICD_IPRIORITYR(reg)) = regval;
  10408e:	6028      	str	r0, [r5, #0]
    spin_lock_saved_state_t state;

    spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
    __arm_gic_set_priority_locked(irq, priority);
    DSB;
  104090:	f3bf 8f4f 	dsb	sy
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  104094:	f1b8 0f00 	cmp.w	r8, #0
  104098:	d000      	beq.n	10409c <arm_gic_set_priority+0x54>
    __asm__ volatile("cpsie i");
  10409a:	b662      	cpsie	i
    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return 0;
}
  10409c:	2000      	movs	r0, #0
  10409e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  1040a2:	bf00      	nop

001040a4 <arm_gic_unmask_interrupt>:
    return NO_ERROR;
}

status_t arm_gic_unmask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
  1040a4:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
  1040a8:	d216      	bcs.n	1040d8 <arm_gic_unmask_interrupt+0x34>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1040aa:	f3ef 8200 	mrs	r2, CPSR
  1040ae:	2101      	movs	r1, #1
  1040b0:	0943      	lsrs	r3, r0, #5
  1040b2:	f503 6388 	add.w	r3, r3, #1088	; 0x440
  1040b6:	f000 001f 	and.w	r0, r0, #31
  1040ba:	4081      	lsls	r1, r0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1040bc:	f012 0080 	ands.w	r0, r2, #128	; 0x80
  1040c0:	ea4f 0383 	mov.w	r3, r3, lsl #2
  1040c4:	f1a3 632c 	sub.w	r3, r3, #180355072	; 0xac00000
  1040c8:	d103      	bne.n	1040d2 <arm_gic_unmask_interrupt+0x2e>
    __asm__ volatile("cpsid i");
  1040ca:	b672      	cpsid	i
        GICREG(GICD_ISENABLER(reg)) = mask;
  1040cc:	6019      	str	r1, [r3, #0]
    __asm__ volatile("cpsie i");
  1040ce:	b662      	cpsie	i
  1040d0:	4770      	bx	r14
  1040d2:	6019      	str	r1, [r3, #0]
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, true);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
  1040d4:	2000      	movs	r0, #0
  1040d6:	4770      	bx	r14
        return ERR_INVALID_ARGS;
  1040d8:	f06f 0007 	mvn.w	r0, #7
}
  1040dc:	4770      	bx	r14
  1040de:	bf00      	nop

001040e0 <platform_irq>:

static
enum handler_return __platform_irq(struct iframe *frame)
{
    // get the current vector
    uint32_t iar = GICREG(GICC_IAR);
  1040e0:	f242 030c 	movw	r3, #8204	; 0x200c
    unsigned int vector = iar & 0x3ff;

    if (vector >= 0x3fe) {
  1040e4:	f240 31fd 	movw	r1, #1021	; 0x3fd
    uint32_t iar = GICREG(GICC_IAR);
  1040e8:	f2cf 5340 	movt	r3, #62784	; 0xf540

    return ret;
}

enum handler_return platform_irq(struct iframe *frame)
{
  1040ec:	b510      	push	{r4, r14}
    uint32_t iar = GICREG(GICC_IAR);
  1040ee:	681c      	ldr	r4, [r3, #0]
    unsigned int vector = iar & 0x3ff;
  1040f0:	f3c4 0209 	ubfx	r2, r4, #0, #10
    if (vector >= 0x3fe) {
  1040f4:	428a      	cmp	r2, r1
  1040f6:	d81d      	bhi.n	104134 <platform_irq+0x54>
    if (vector < GIC_MAX_PER_CPU_INT)
  1040f8:	2a1f      	cmp	r2, #31
        return &int_handler_table_per_cpu[vector][cpu];
  1040fa:	bf93      	iteet	ls
  1040fc:	f246 73c0 	movwls	r3, #26560	; 0x67c0
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  104100:	3a20      	subhi	r2, #32
  104102:	f646 03c0 	movwhi	r3, #26816	; 0x68c0
        return &int_handler_table_per_cpu[vector][cpu];
  104106:	f2c0 0311 	movtls	r3, #17
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  10410a:	bf88      	it	hi
  10410c:	f2c0 0311 	movthi	r3, #17
  104110:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    if (handler->handler)
  104114:	681a      	ldr	r2, [r3, #0]
  104116:	b142      	cbz	r2, 10412a <platform_irq+0x4a>
        ret = handler->handler(handler->arg);
  104118:	6858      	ldr	r0, [r3, #4]
  10411a:	4790      	blx	r2
    GICREG(GICC_EOIR) = iar;
  10411c:	f242 0310 	movw	r3, #8208	; 0x2010
  104120:	f2cf 5340 	movt	r3, #62784	; 0xf540
  104124:	601c      	str	r4, [r3, #0]
    else
        ret = sm_handle_irq();
#else
    ret = __platform_irq(frame);
#endif
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  104126:	b128      	cbz	r0, 104134 <platform_irq+0x54>
        ret = INT_RESCHEDULE;

	}
    return ret;
}
  104128:	bd10      	pop	{r4, r15}
    GICREG(GICC_EOIR) = iar;
  10412a:	f242 0310 	movw	r3, #8208	; 0x2010
  10412e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  104132:	601c      	str	r4, [r3, #0]
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  104134:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  104138:	6a18      	ldr	r0, [r3, #32]
  10413a:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
  10413e:	bd10      	pop	{r4, r15}

00104140 <arm_gic_platform_irq_spotless>:
    if (vector >= 0x3fe) {
  104140:	f240 33fd 	movw	r3, #1021	; 0x3fd
    unsigned int vector = ack & 0x3ff;
  104144:	f3c0 0009 	ubfx	r0, r0, #0, #10
    if (vector >= 0x3fe) {
  104148:	4298      	cmp	r0, r3
  10414a:	d814      	bhi.n	104176 <arm_gic_platform_irq_spotless+0x36>
    if (vector < GIC_MAX_PER_CPU_INT)
  10414c:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
  10414e:	bf93      	iteet	ls
  104150:	f246 73c0 	movwls	r3, #26560	; 0x67c0
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  104154:	f1a0 0320 	subhi.w	r3, r0, #32
  104158:	f646 00c0 	movwhi	r0, #26816	; 0x68c0
        return &int_handler_table_per_cpu[vector][cpu];
  10415c:	f2c0 0311 	movtls	r3, #17
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  104160:	bf8a      	itet	hi
  104162:	f2c0 0011 	movthi	r0, #17
        return &int_handler_table_per_cpu[vector][cpu];
  104166:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  10416a:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
    if (handler->handler)
  10416e:	6803      	ldr	r3, [r0, #0]
  104170:	b10b      	cbz	r3, 104176 <arm_gic_platform_irq_spotless+0x36>
        ret = handler->handler(handler->arg);
  104172:	6840      	ldr	r0, [r0, #4]
  104174:	4718      	bx	r3

enum handler_return arm_gic_platform_irq_spotless(unsigned int ack)
{
    return __platform_irq_spotless(ack);
}
  104176:	2000      	movs	r0, #0
  104178:	4770      	bx	r14
  10417a:	bf00      	nop

0010417c <platform_fiq>:
void platform_fiq(struct iframe *frame)
{
#if WITH_LIB_SM
    sm_handle_fiq();
#else
    PANIC_UNIMPLEMENTED;
  10417c:	f64c 0284 	movw	r2, #51332	; 0xc884
  104180:	f64c 11d8 	movw	r1, #51672	; 0xc9d8
{
  104184:	b508      	push	{r3, r14}
    PANIC_UNIMPLEMENTED;
  104186:	4670      	mov	r0, r14
  104188:	f2c0 0210 	movt	r2, #16
  10418c:	f2c0 0110 	movt	r1, #16
  104190:	f006 f870 	bl	10a274 <_panic>

00104194 <pll_config>:
#define PFPLL_FRAC_MIN                  0
#define PFPLL_FRAC_MAX                  (int)BIT_MASK(24)

static void validate_pll_cfg(const pll_config_t *config)
{
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  104194:	68cb      	ldr	r3, [r1, #12]
        ASSERT(config->spread >= 1 && config->spread <= 31);
    }
}

void pll_config(paddr_t pll_base, const pll_config_t *config)
{
  104196:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  10419a:	3b01      	subs	r3, #1
  10419c:	2b3e      	cmp	r3, #62	; 0x3e
{
  10419e:	b095      	sub	sp, #84	; 0x54
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  1041a0:	f200 8110 	bhi.w	1043c4 <pll_config+0x230>
    ASSERT(config->postdiv[0] >= config->postdiv[1]);
  1041a4:	e9d1 3205 	ldrd	r3, r2, [r1, #20]
  1041a8:	460e      	mov	r6, r1
  1041aa:	4293      	cmp	r3, r2
  1041ac:	f0c0 811b 	bcc.w	1043e6 <pll_config+0x252>
        ASSERT(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  1041b0:	3b01      	subs	r3, #1
  1041b2:	2b06      	cmp	r3, #6
  1041b4:	f200 80f5 	bhi.w	1043a2 <pll_config+0x20e>
  1041b8:	3a01      	subs	r2, #1
  1041ba:	2a06      	cmp	r2, #6
  1041bc:	f200 80f1 	bhi.w	1043a2 <pll_config+0x20e>
  1041c0:	4604      	mov	r4, r0
    if (config->integer) {
  1041c2:	790a      	ldrb	r2, [r1, #4]
  1041c4:	2a00      	cmp	r2, #0
  1041c6:	f040 80a4 	bne.w	104312 <pll_config+0x17e>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_FRAC_MIN &&
  1041ca:	690b      	ldr	r3, [r1, #16]
  1041cc:	f1a3 0114 	sub.w	r1, r3, #20
  1041d0:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
  1041d4:	f200 8118 	bhi.w	104408 <pll_config+0x274>
        ASSERT(config->frac >= PFPLL_FRAC_MIN &&
  1041d8:	69f1      	ldr	r1, [r6, #28]
  1041da:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
  1041de:	f080 8135 	bcs.w	10444c <pll_config+0x2b8>
    if (config->spread_spectrum) {
  1041e2:	f896 a005 	ldrb.w	r10, [r6, #5]
  1041e6:	f1ba 0f00 	cmp.w	r10, #0
  1041ea:	d004      	beq.n	1041f6 <pll_config+0x62>
        ASSERT(config->spread >= 1 && config->spread <= 31);
  1041ec:	68b1      	ldr	r1, [r6, #8]
  1041ee:	3901      	subs	r1, #1
  1041f0:	291e      	cmp	r1, #30
  1041f2:	f200 813c 	bhi.w	10446e <pll_config+0x2da>
    LTRACEF("outdiv 0x%x 0x%x 0x%x 0x%x\n",
            config->out_div[0], config->out_div[1],
            config->out_div[2], config->out_div[3]);
    validate_pll_cfg(config);
    /* Configure refdiv, fbdiv and postdiv. */
    writel(config->fbdiv, base + PLL_FBDIV);
  1041f6:	60a3      	str	r3, [r4, #8]
    writel((config->refdiv << PLL_DIV_REFDIV) +
  1041f8:	e9d6 0305 	ldrd	r0, r3, [r6, #20]
  1041fc:	68f1      	ldr	r1, [r6, #12]
  1041fe:	025b      	lsls	r3, r3, #9
  104200:	eb03 1380 	add.w	r3, r3, r0, lsl #6
  104204:	440b      	add	r3, r1
  104206:	6063      	str	r3, [r4, #4]
           (config->postdiv[0] << PLL_DIV_POSTDIV1) +
           (config->postdiv[1] << PLL_DIV_POSTDIV2),
           base + PLL_DIV);

    if (config->integer) {
  104208:	2a00      	cmp	r2, #0
  10420a:	f000 80a0 	beq.w	10434e <pll_config+0x1ba>
        /* Integer mode. */
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 1);
  10420e:	6823      	ldr	r3, [r4, #0]
  104210:	f043 0302 	orr.w	r3, r3, #2
  104214:	6023      	str	r3, [r4, #0]
        writel(config->frac, base + PLL_FRAC);
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 0);
    }

    /* Enable PLL. */
    RMWREG32(base + PLL_CTRL, PLL_CTRL_PLLEN, 1, 1);
  104216:	6823      	ldr	r3, [r4, #0]
  104218:	f043 0301 	orr.w	r3, r3, #1
  10421c:	6023      	str	r3, [r4, #0]

    /* Wait until PLL is locked. */
    while (!(readl(base + PLL_CTRL) & (1 << PLL_CTRL_LOCK)));
  10421e:	6823      	ldr	r3, [r4, #0]
  104220:	2b00      	cmp	r3, #0
  104222:	dafc      	bge.n	10421e <pll_config+0x8a>
  104224:	f10d 0910 	add.w	r9, r13, #16
  104228:	4649      	mov	r1, r9
  10422a:	f106 0220 	add.w	r2, r6, #32
  10422e:	f106 0030 	add.w	r0, r6, #48	; 0x30
     * XXX_CG_EN=1 means turning on the clock.
     */
    int out_div_en[PLL_OUT_DIV_MAX];

    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
        out_div_en[i] = (config->out_div[i] > 0);
  104232:	f852 3b04 	ldr.w	r3, [r2], #4
  104236:	3300      	adds	r3, #0
  104238:	bf18      	it	ne
  10423a:	2301      	movne	r3, #1
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  10423c:	4282      	cmp	r2, r0
        out_div_en[i] = (config->out_div[i] > 0);
  10423e:	f841 3b04 	str.w	r3, [r1], #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  104242:	d1f6      	bne.n	104232 <pll_config+0x9e>
    writel(val, base + PLL_CTRL);
    struct pll_out_div_cfg {
        uint32_t reg;
        uint32_t num_bit;
        uint32_t busy_bit;
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104244:	f64c 2328 	movw	r3, #51752	; 0xca28
  104248:	f10d 0c20 	add.w	r12, r13, #32
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  10424c:	f8dd 8010 	ldr.w	r8, [r13, #16]
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104250:	f2c0 0310 	movt	r3, #16
  104254:	461f      	mov	r7, r3
  104256:	2500      	movs	r5, #0
    val = readl(base + PLL_CTRL);
  104258:	f8d4 b000 	ldr.w	r11, [r4]
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  10425c:	ea4f 4e88 	mov.w	r14, r8, lsl #18
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104260:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  104262:	f50e 3e80 	add.w	r14, r14, #65536	; 0x10000
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104266:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
           + (out_div_en[PLL_OUT_DIV_B] << PLL_CTRL_PLL_DIVB_CG_EN)
  10426a:	e9dd 3205 	ldrd	r3, r2, [r13, #20]
           + (out_div_en[PLL_OUT_DIV_A] << PLL_CTRL_PLL_DIVA_CG_EN)
  10426e:	f10e 0e10 	add.w	r14, r14, #16
           + (out_div_en[PLL_OUT_DIV_B] << PLL_CTRL_PLL_DIVB_CG_EN)
  104272:	eb0e 4ec3 	add.w	r14, r14, r3, lsl #19
           + (out_div_en[PLL_OUT_DIV_D] << PLL_CTRL_PLL_DIVD_CG_EN);
  104276:	9b07      	ldr	r3, [sp, #28]
           + (out_div_en[PLL_OUT_DIV_C] << PLL_CTRL_PLL_DIVC_CG_EN)
  104278:	eb0e 5e02 	add.w	r14, r14, r2, lsl #20
           + (out_div_en[PLL_OUT_DIV_D] << PLL_CTRL_PLL_DIVD_CG_EN);
  10427c:	eb0e 5e43 	add.w	r14, r14, r3, lsl #21
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104280:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  104282:	9703      	str	r7, [sp, #12]
    val |= (1 << PLL_CTRL_FOUTPOSTDIVEN)
  104284:	ea4e 070b 	orr.w	r7, r14, r11
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104288:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
  10428c:	9b03      	ldr	r3, [sp, #12]

    /* Configure outside divider clocks. */
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
        if (out_div_en[i]) {
            /* Configure outside division number. */
            RMWREG32(base + out_div_cfg[i].reg,
  10428e:	f04f 0b0f 	mov.w	r11, #15
    writel(val, base + PLL_CTRL);
  104292:	6027      	str	r7, [r4, #0]
                     4,
                     config->out_div[i] - 1);

            /* Wait div busy bit. */
            while (readl(base + out_div_cfg[i].reg) &
                    (1 << out_div_cfg[i].busy_bit));
  104294:	f04f 0e01 	mov.w	r14, #1
    } out_div_cfg[PLL_OUT_DIV_MAX] = {
  104298:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  10429a:	e88c 000f 	stmia.w	r12, {r0, r1, r2, r3}
        if (out_div_en[i]) {
  10429e:	f1b8 0f00 	cmp.w	r8, #0
  1042a2:	d107      	bne.n	1042b4 <pll_config+0x120>
  1042a4:	3504      	adds	r5, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  1042a6:	2d10      	cmp	r5, #16
  1042a8:	d021      	beq.n	1042ee <pll_config+0x15a>
  1042aa:	f859 8005 	ldr.w	r8, [r9, r5]
        if (out_div_en[i]) {
  1042ae:	f1b8 0f00 	cmp.w	r8, #0
  1042b2:	d0f7      	beq.n	1042a4 <pll_config+0x110>
  1042b4:	eb05 0345 	add.w	r3, r5, r5, lsl #1
  1042b8:	a908      	add	r1, sp, #32
            RMWREG32(base + out_div_cfg[i].reg,
  1042ba:	1972      	adds	r2, r6, r5
  1042bc:	18cf      	adds	r7, r1, r3
  1042be:	58c8      	ldr	r0, [r1, r3]
  1042c0:	6a13      	ldr	r3, [r2, #32]
  1042c2:	f8d7 c004 	ldr.w	r12, [r7, #4]
  1042c6:	5821      	ldr	r1, [r4, r0]
  1042c8:	3b01      	subs	r3, #1
                    (1 << out_div_cfg[i].busy_bit));
  1042ca:	68ba      	ldr	r2, [r7, #8]
            RMWREG32(base + out_div_cfg[i].reg,
  1042cc:	fa0b f70c 	lsl.w	r7, r11, r12
  1042d0:	ea21 0107 	bic.w	r1, r1, r7
  1042d4:	fa03 f30c 	lsl.w	r3, r3, r12
  1042d8:	430b      	orrs	r3, r1
                    (1 << out_div_cfg[i].busy_bit));
  1042da:	fa0e f202 	lsl.w	r2, r14, r2
            RMWREG32(base + out_div_cfg[i].reg,
  1042de:	5023      	str	r3, [r4, r0]
  1042e0:	1821      	adds	r1, r4, r0
            while (readl(base + out_div_cfg[i].reg) &
  1042e2:	680b      	ldr	r3, [r1, #0]
  1042e4:	4213      	tst	r3, r2
  1042e6:	d1fc      	bne.n	1042e2 <pll_config+0x14e>
  1042e8:	3504      	adds	r5, #4
    for (pll_out_div_e i = PLL_OUT_DIV_A; i < PLL_OUT_DIV_MAX; i++) {
  1042ea:	2d10      	cmp	r5, #16
  1042ec:	d1dd      	bne.n	1042aa <pll_config+0x116>
        }
    }

    /* Enable SS modulator if necessary. */
    /* Modulators may be required for display modules to reduce EMI. */
    if (config->spread_spectrum) {
  1042ee:	f1ba 0f00 	cmp.w	r10, #0
  1042f2:	d133      	bne.n	10435c <pll_config+0x1c8>
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DIVVAL, 5, 15);
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 0);
        /* TODO - add modulation parameters. */
    }
    else {
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 1);
  1042f4:	69a3      	ldr	r3, [r4, #24]
  1042f6:	f043 0302 	orr.w	r3, r3, #2
  1042fa:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_RESETPTR, 1, 1);
  1042fc:	69a3      	ldr	r3, [r4, #24]
  1042fe:	f043 0304 	orr.w	r3, r3, #4
  104302:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 1);
  104304:	69a3      	ldr	r3, [r4, #24]
  104306:	f043 0301 	orr.w	r3, r3, #1
  10430a:	61a3      	str	r3, [r4, #24]
    }
}
  10430c:	b015      	add	sp, #84	; 0x54
  10430e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ASSERT(!config->spread_spectrum);
  104312:	f891 a005 	ldrb.w	r10, [r1, #5]
  104316:	f1ba 0f00 	cmp.w	r10, #0
  10431a:	f040 8086 	bne.w	10442a <pll_config+0x296>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_INTEGER_MIN &&
  10431e:	690b      	ldr	r3, [r1, #16]
  104320:	f1a3 0110 	sub.w	r1, r3, #16
  104324:	f5b1 7f1c 	cmp.w	r1, #624	; 0x270
  104328:	f67f af65 	bls.w	1041f6 <pll_config+0x62>
  10432c:	f64c 3388 	movw	r3, #52104	; 0xcb88
  104330:	f64c 2288 	movw	r2, #51848	; 0xca88
  104334:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  104338:	f2c0 0310 	movt	r3, #16
  10433c:	4670      	mov	r0, r14
  10433e:	f2c0 0210 	movt	r2, #16
  104342:	9300      	str	r3, [sp, #0]
  104344:	f2c0 0110 	movt	r1, #16
  104348:	2376      	movs	r3, #118	; 0x76
  10434a:	f005 ff93 	bl	10a274 <_panic>
        writel(config->frac, base + PLL_FRAC);
  10434e:	69f3      	ldr	r3, [r6, #28]
  104350:	60e3      	str	r3, [r4, #12]
        RMWREG32(base + PLL_CTRL, PLL_CTRL_INT_MODE, 1, 0);
  104352:	6823      	ldr	r3, [r4, #0]
  104354:	f023 0302 	bic.w	r3, r3, #2
  104358:	6023      	str	r3, [r4, #0]
  10435a:	e75c      	b.n	104216 <pll_config+0x82>
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 0);
  10435c:	69a2      	ldr	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DOWNSPREAD, 1, config->downspread);
  10435e:	79b1      	ldrb	r1, [r6, #6]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DISABLE_SSCG, 1, 0);
  104360:	f022 0202 	bic.w	r2, r2, #2
  104364:	61a2      	str	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_RESETPTR, 1, 0);
  104366:	69a2      	ldr	r2, [r4, #24]
  104368:	f022 0204 	bic.w	r2, r2, #4
  10436c:	61a2      	str	r2, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DOWNSPREAD, 1, config->downspread);
  10436e:	69a3      	ldr	r3, [r4, #24]
  104370:	f023 0308 	bic.w	r3, r3, #8
  104374:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
  104378:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_SPREAD, 5, config->spread);
  10437a:	69a3      	ldr	r3, [r4, #24]
  10437c:	68b2      	ldr	r2, [r6, #8]
  10437e:	f423 73f8 	bic.w	r3, r3, #496	; 0x1f0
  104382:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
  104386:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_DIVVAL, 5, 15);
  104388:	69a3      	ldr	r3, [r4, #24]
  10438a:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
  10438e:	f443 53f0 	orr.w	r3, r3, #7680	; 0x1e00
  104392:	61a3      	str	r3, [r4, #24]
        RMWREG32(base + PLL_SSMOD, PLL_SSMOD_MOD_RESET, 1, 0);
  104394:	69a3      	ldr	r3, [r4, #24]
  104396:	f023 0301 	bic.w	r3, r3, #1
  10439a:	61a3      	str	r3, [r4, #24]
}
  10439c:	b015      	add	sp, #84	; 0x54
  10439e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ASSERT(config->postdiv[i] >= PFPLL_POSTDIV_MIN &&
  1043a2:	f64c 3318 	movw	r3, #51992	; 0xcb18
  1043a6:	f64c 2288 	movw	r2, #51848	; 0xca88
  1043aa:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1043ae:	f2c0 0310 	movt	r3, #16
  1043b2:	4670      	mov	r0, r14
  1043b4:	f2c0 0210 	movt	r2, #16
  1043b8:	9300      	str	r3, [sp, #0]
  1043ba:	f2c0 0110 	movt	r1, #16
  1043be:	2370      	movs	r3, #112	; 0x70
  1043c0:	f005 ff58 	bl	10a274 <_panic>
    ASSERT(config->refdiv >= PFPLL_REFDIV_MIN &&
  1043c4:	f64c 23a0 	movw	r3, #51872	; 0xcaa0
  1043c8:	f64c 2288 	movw	r2, #51848	; 0xca88
  1043cc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1043d0:	f2c0 0310 	movt	r3, #16
  1043d4:	4670      	mov	r0, r14
  1043d6:	f2c0 0210 	movt	r2, #16
  1043da:	9300      	str	r3, [sp, #0]
  1043dc:	f2c0 0110 	movt	r1, #16
  1043e0:	236b      	movs	r3, #107	; 0x6b
  1043e2:	f005 ff47 	bl	10a274 <_panic>
    ASSERT(config->postdiv[0] >= config->postdiv[1]);
  1043e6:	f64c 23ec 	movw	r3, #51948	; 0xcaec
  1043ea:	f64c 2288 	movw	r2, #51848	; 0xca88
  1043ee:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1043f2:	f2c0 0310 	movt	r3, #16
  1043f6:	4670      	mov	r0, r14
  1043f8:	f2c0 0210 	movt	r2, #16
  1043fc:	9300      	str	r3, [sp, #0]
  1043fe:	f2c0 0110 	movt	r1, #16
  104402:	236c      	movs	r3, #108	; 0x6c
  104404:	f005 ff36 	bl	10a274 <_panic>
        ASSERT(config->fbdiv >= PFPLL_FBDIV_FRAC_MIN &&
  104408:	f64c 33e0 	movw	r3, #52192	; 0xcbe0
  10440c:	f64c 2288 	movw	r2, #51848	; 0xca88
  104410:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  104414:	f2c0 0310 	movt	r3, #16
  104418:	4670      	mov	r0, r14
  10441a:	f2c0 0210 	movt	r2, #16
  10441e:	9300      	str	r3, [sp, #0]
  104420:	f2c0 0110 	movt	r1, #16
  104424:	237a      	movs	r3, #122	; 0x7a
  104426:	f005 ff25 	bl	10a274 <_panic>
        ASSERT(!config->spread_spectrum);
  10442a:	f64c 336c 	movw	r3, #52076	; 0xcb6c
  10442e:	f64c 2288 	movw	r2, #51848	; 0xca88
  104432:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  104436:	f2c0 0310 	movt	r3, #16
  10443a:	4670      	mov	r0, r14
  10443c:	f2c0 0210 	movt	r2, #16
  104440:	9300      	str	r3, [sp, #0]
  104442:	f2c0 0110 	movt	r1, #16
  104446:	2374      	movs	r3, #116	; 0x74
  104448:	f005 ff14 	bl	10a274 <_panic>
        ASSERT(config->frac >= PFPLL_FRAC_MIN &&
  10444c:	f64c 4330 	movw	r3, #52272	; 0xcc30
  104450:	f64c 2288 	movw	r2, #51848	; 0xca88
  104454:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  104458:	f2c0 0310 	movt	r3, #16
  10445c:	4670      	mov	r0, r14
  10445e:	f2c0 0210 	movt	r2, #16
  104462:	9300      	str	r3, [sp, #0]
  104464:	f2c0 0110 	movt	r1, #16
  104468:	237c      	movs	r3, #124	; 0x7c
  10446a:	f005 ff03 	bl	10a274 <_panic>
        ASSERT(config->spread >= 1 && config->spread <= 31);
  10446e:	f64c 4374 	movw	r3, #52340	; 0xcc74
  104472:	f64c 2288 	movw	r2, #51848	; 0xca88
  104476:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10447a:	f2c0 0310 	movt	r3, #16
  10447e:	4670      	mov	r0, r14
  104480:	f2c0 0210 	movt	r2, #16
  104484:	9300      	str	r3, [sp, #0]
  104486:	f2c0 0110 	movt	r1, #16
  10448a:	2380      	movs	r3, #128	; 0x80
  10448c:	f005 fef2 	bl	10a274 <_panic>

00104490 <pmu_check.part.0>:
}

static int32_t pmu_check(pmudev_t *dev)
{
	if (dev->name == NULL || dev->base_paddr == NULL
	        || dev->base_vaddr == NULL || dev->init_flag == 0)
  104490:	6903      	ldr	r3, [r0, #16]
  104492:	b123      	cbz	r3, 10449e <pmu_check.part.0+0xe>
  104494:	6880      	ldr	r0, [r0, #8]
  104496:	fab0 f080 	clz	r0, r0
  10449a:	0940      	lsrs	r0, r0, #5
  10449c:	4770      	bx	r14
		return 1;
  10449e:	2001      	movs	r0, #1
	return 0;
}
  1044a0:	4770      	bx	r14
  1044a2:	bf00      	nop

001044a4 <pmu_init>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1044a4:	6803      	ldr	r3, [r0, #0]
{
  1044a6:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1044a8:	b19b      	cbz	r3, 1044d2 <pmu_init+0x2e>
  1044aa:	68c1      	ldr	r1, [r0, #12]
  1044ac:	4602      	mov	r2, r0
  1044ae:	b181      	cbz	r1, 1044d2 <pmu_init+0x2e>
	        || dev->base_vaddr == NULL) {
  1044b0:	6901      	ldr	r1, [r0, #16]
  1044b2:	b171      	cbz	r1, 1044d2 <pmu_init+0x2e>
	dev->init_flag = 1;
  1044b4:	2401      	movs	r4, #1
	pmu_dbg("%s init okay\n", dev->name);
  1044b6:	f64c 41a0 	movw	r1, #52384	; 0xcca0
  1044ba:	f24d 1018 	movw	r0, #53528	; 0xd118
  1044be:	f2c0 0110 	movt	r1, #16
	dev->init_flag = 1;
  1044c2:	6094      	str	r4, [r2, #8]
	pmu_dbg("%s init okay\n", dev->name);
  1044c4:	f2c0 0010 	movt	r0, #16
  1044c8:	2217      	movs	r2, #23
  1044ca:	f006 ff07 	bl	10b2dc <printf>
	return 0;
  1044ce:	2000      	movs	r0, #0
}
  1044d0:	bd10      	pop	{r4, r15}
		pmu_err("init failure\n");
  1044d2:	f64c 41a0 	movw	r1, #52384	; 0xcca0
  1044d6:	f24d 1000 	movw	r0, #53504	; 0xd100
  1044da:	2212      	movs	r2, #18
  1044dc:	f2c0 0110 	movt	r1, #16
  1044e0:	f2c0 0010 	movt	r0, #16
  1044e4:	f006 fefa 	bl	10b2dc <printf>
		return -1;
  1044e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1044ec:	bd10      	pop	{r4, r15}
  1044ee:	bf00      	nop

001044f0 <pmu_exit>:
	if (dev->init_flag != 1) {
  1044f0:	6882      	ldr	r2, [r0, #8]
{
  1044f2:	b510      	push	{r4, r14}
	if (dev->init_flag != 1) {
  1044f4:	2a01      	cmp	r2, #1
  1044f6:	d110      	bne.n	10451a <pmu_exit+0x2a>
  1044f8:	4603      	mov	r3, r0
	dev->init_flag = 0;
  1044fa:	2400      	movs	r4, #0
	pmu_dbg("%s exit okay\n", dev->name);
  1044fc:	f64c 41ac 	movw	r1, #52396	; 0xccac
  104500:	f24d 00ac 	movw	r0, #53420	; 0xd0ac
	dev->init_flag = 0;
  104504:	609c      	str	r4, [r3, #8]
	pmu_dbg("%s exit okay\n", dev->name);
  104506:	f2c0 0110 	movt	r1, #16
  10450a:	681b      	ldr	r3, [r3, #0]
  10450c:	2223      	movs	r2, #35	; 0x23
  10450e:	f2c0 0010 	movt	r0, #16
  104512:	f006 fee3 	bl	10b2dc <printf>
	return 0;
  104516:	4620      	mov	r0, r4
}
  104518:	bd10      	pop	{r4, r15}
		pmu_err("exit failure\n");
  10451a:	f64c 41ac 	movw	r1, #52396	; 0xccac
  10451e:	f24d 0094 	movw	r0, #53396	; 0xd094
  104522:	221e      	movs	r2, #30
  104524:	f2c0 0110 	movt	r1, #16
  104528:	f2c0 0010 	movt	r0, #16
  10452c:	f006 fed6 	bl	10b2dc <printf>
		return -1;
  104530:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104534:	bd10      	pop	{r4, r15}
  104536:	bf00      	nop

00104538 <pmu_get_status>:
 *              0x08 - PWRDOWN
 *              0x10 - OFF
 *              < 0  - ERROR
 ************************************************/
int32_t pmu_get_status(pmudev_t *dev, int *status)
{
  104538:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10453a:	6803      	ldr	r3, [r0, #0]
  10453c:	b393      	cbz	r3, 1045a4 <pmu_get_status+0x6c>
  10453e:	68c3      	ldr	r3, [r0, #12]
  104540:	4602      	mov	r2, r0
  104542:	b37b      	cbz	r3, 1045a4 <pmu_get_status+0x6c>
  104544:	f7ff ffa4 	bl	104490 <pmu_check.part.0>
	uint32_t v = 0;

	if (pmu_check(dev) || status == NULL) {
  104548:	fab1 f381 	clz	r3, r1
  10454c:	095b      	lsrs	r3, r3, #5
  10454e:	2800      	cmp	r0, #0
  104550:	bf0c      	ite	eq
  104552:	4618      	moveq	r0, r3
  104554:	2001      	movne	r0, #1
  104556:	bb28      	cbnz	r0, 1045a4 <pmu_get_status+0x6c>
		pmu_err("check failure\n");
		return -1;
	}

	v = readl(dev->base_vaddr + PMU_RST_CTRL);
  104558:	6913      	ldr	r3, [r2, #16]
  10455a:	68db      	ldr	r3, [r3, #12]
	v = (v & (0x1f << 24)) >> 24;
  10455c:	f3c3 6304 	ubfx	r3, r3, #24, #5
	if (v != 0x01 && v != 0x02 && v != 0x04 && v != 0x08 && v != 0x10) {
  104560:	1f1a      	subs	r2, r3, #4
  104562:	f032 0204 	bics.w	r2, r2, #4
  104566:	bf18      	it	ne
  104568:	2201      	movne	r2, #1
  10456a:	f103 30ff 	add.w	r0, r3, #4294967295	; 0xffffffff
  10456e:	bf08      	it	eq
  104570:	2200      	moveq	r2, #0
  104572:	2801      	cmp	r0, #1
  104574:	bf94      	ite	ls
  104576:	2200      	movls	r2, #0
  104578:	f002 0201 	andhi.w	r2, r2, #1
  10457c:	b10a      	cbz	r2, 104582 <pmu_get_status+0x4a>
  10457e:	2b10      	cmp	r3, #16
  104580:	d102      	bne.n	104588 <pmu_get_status+0x50>
		pmu_err("get status fail v = %02x\n", v);
		return -1;
	}
	*status = v;
  104582:	600b      	str	r3, [r1, #0]
	return 0;
  104584:	2000      	movs	r0, #0
}
  104586:	bd08      	pop	{r3, r15}
		pmu_err("get status fail v = %02x\n", v);
  104588:	f64c 41b8 	movw	r1, #52408	; 0xccb8
  10458c:	f24d 00dc 	movw	r0, #53468	; 0xd0dc
  104590:	224a      	movs	r2, #74	; 0x4a
  104592:	f2c0 0110 	movt	r1, #16
  104596:	f2c0 0010 	movt	r0, #16
  10459a:	f006 fe9f 	bl	10b2dc <printf>
		return -1;
  10459e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1045a2:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1045a4:	f64c 41b8 	movw	r1, #52408	; 0xccb8
  1045a8:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  1045ac:	2243      	movs	r2, #67	; 0x43
  1045ae:	f2c0 0110 	movt	r1, #16
  1045b2:	f2c0 0010 	movt	r0, #16
  1045b6:	f006 fe91 	bl	10b2dc <printf>
		return -1;
  1045ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1045be:	bd08      	pop	{r3, r15}

001045c0 <pmu_get_event_source>:

int32_t pmu_get_event_source(pmudev_t *dev, uint32_t *event)
{
  1045c0:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1045c2:	6803      	ldr	r3, [r0, #0]
  1045c4:	b18b      	cbz	r3, 1045ea <pmu_get_event_source+0x2a>
  1045c6:	68c3      	ldr	r3, [r0, #12]
  1045c8:	4602      	mov	r2, r0
  1045ca:	b173      	cbz	r3, 1045ea <pmu_get_event_source+0x2a>
  1045cc:	f7ff ff60 	bl	104490 <pmu_check.part.0>
	uint32_t v;

	if (pmu_check(dev) || event == NULL) {
  1045d0:	fab1 f381 	clz	r3, r1
  1045d4:	095b      	lsrs	r3, r3, #5
  1045d6:	2800      	cmp	r0, #0
  1045d8:	bf0c      	ite	eq
  1045da:	4618      	moveq	r0, r3
  1045dc:	2001      	movne	r0, #1
  1045de:	b920      	cbnz	r0, 1045ea <pmu_get_event_source+0x2a>
		pmu_err("check failure\n");
		return -1;
	}

	v = readl(dev->base_vaddr + PMU_INTR);
  1045e0:	6913      	ldr	r3, [r2, #16]
  1045e2:	6a1b      	ldr	r3, [r3, #32]
	*event = v & 0xff;
  1045e4:	b2db      	uxtb	r3, r3
  1045e6:	600b      	str	r3, [r1, #0]
	return 0;
}
  1045e8:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1045ea:	f64c 41c8 	movw	r1, #52424	; 0xccc8
  1045ee:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  1045f2:	2256      	movs	r2, #86	; 0x56
  1045f4:	f2c0 0110 	movt	r1, #16
  1045f8:	f2c0 0010 	movt	r0, #16
  1045fc:	f006 fe6e 	bl	10b2dc <printf>
		return -1;
  104600:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104604:	bd08      	pop	{r3, r15}
  104606:	bf00      	nop

00104608 <pmu_clean_single_event_source>:

int32_t pmu_clean_single_event_source(pmudev_t *dev, int event_id)
{
  104608:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10460a:	6803      	ldr	r3, [r0, #0]
  10460c:	b16b      	cbz	r3, 10462a <pmu_clean_single_event_source+0x22>
  10460e:	68c3      	ldr	r3, [r0, #12]
  104610:	4602      	mov	r2, r0
  104612:	b153      	cbz	r3, 10462a <pmu_clean_single_event_source+0x22>
  104614:	f7ff ff3c 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || event_id < 0 || event_id > 7) {
  104618:	b938      	cbnz	r0, 10462a <pmu_clean_single_event_source+0x22>
  10461a:	2907      	cmp	r1, #7
  10461c:	d805      	bhi.n	10462a <pmu_clean_single_event_source+0x22>
		pmu_err("check failure\n");
		return -1;
	}

	writel(1 << event_id, dev->base_vaddr + PMU_INTR);
  10461e:	6912      	ldr	r2, [r2, #16]
  104620:	2301      	movs	r3, #1
  104622:	fa03 f101 	lsl.w	r1, r3, r1
  104626:	6211      	str	r1, [r2, #32]
	return 0;
}
  104628:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  10462a:	f64c 41e0 	movw	r1, #52448	; 0xcce0
  10462e:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104632:	2262      	movs	r2, #98	; 0x62
  104634:	f2c0 0110 	movt	r1, #16
  104638:	f2c0 0010 	movt	r0, #16
  10463c:	f006 fe4e 	bl	10b2dc <printf>
		return -1;
  104640:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104644:	bd08      	pop	{r3, r15}
  104646:	bf00      	nop

00104648 <pmu_clean_all_event_source>:

int32_t pmu_clean_all_event_source(pmudev_t *dev)
{
  104648:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10464a:	6803      	ldr	r3, [r0, #0]
  10464c:	b14b      	cbz	r3, 104662 <pmu_clean_all_event_source+0x1a>
  10464e:	68c3      	ldr	r3, [r0, #12]
  104650:	4602      	mov	r2, r0
  104652:	b133      	cbz	r3, 104662 <pmu_clean_all_event_source+0x1a>
  104654:	f7ff ff1c 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev)) {
  104658:	b918      	cbnz	r0, 104662 <pmu_clean_all_event_source+0x1a>
		pmu_err("check failure\n");
		return -1;
	}

	writel(0xff, dev->base_vaddr + PMU_INTR);
  10465a:	6913      	ldr	r3, [r2, #16]
  10465c:	21ff      	movs	r1, #255	; 0xff
  10465e:	6219      	str	r1, [r3, #32]
	return 0;
}
  104660:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  104662:	f64c 5100 	movw	r1, #52480	; 0xcd00
  104666:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  10466a:	226d      	movs	r2, #109	; 0x6d
  10466c:	f2c0 0110 	movt	r1, #16
  104670:	f2c0 0010 	movt	r0, #16
  104674:	f006 fe32 	bl	10b2dc <printf>
		return -1;
  104678:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10467c:	bd08      	pop	{r3, r15}
  10467e:	bf00      	nop

00104680 <pmu_powerdown>:

int32_t pmu_powerdown(pmudev_t *dev, int enable)
{
  104680:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104682:	6803      	ldr	r3, [r0, #0]
  104684:	b1b3      	cbz	r3, 1046b4 <pmu_powerdown+0x34>
  104686:	68c3      	ldr	r3, [r0, #12]
  104688:	4604      	mov	r4, r0
  10468a:	b19b      	cbz	r3, 1046b4 <pmu_powerdown+0x34>
  10468c:	f7ff ff00 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev)) {
  104690:	4605      	mov	r5, r0
  104692:	b978      	cbnz	r0, 1046b4 <pmu_powerdown+0x34>
		pmu_err("check failure\n");
		return -1;
	}
	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 8, 1, 0x0);
  104694:	6922      	ldr	r2, [r4, #16]
	spin(1000);
  104696:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	RMWREG32(addr, startbit, width, val);
  10469a:	6913      	ldr	r3, [r2, #16]
  10469c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  1046a0:	6113      	str	r3, [r2, #16]
	spin(1000);
  1046a2:	f005 fdd5 	bl	10a250 <spin>
	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 8, 1, 0x1);
  1046a6:	6922      	ldr	r2, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  1046a8:	6913      	ldr	r3, [r2, #16]
  1046aa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  1046ae:	6113      	str	r3, [r2, #16]
	return 0;
}
  1046b0:	4628      	mov	r0, r5
  1046b2:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  1046b4:	f64c 511c 	movw	r1, #52508	; 0xcd1c
  1046b8:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  1046bc:	2278      	movs	r2, #120	; 0x78
  1046be:	f2c0 0110 	movt	r1, #16
		return -1;
  1046c2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		pmu_err("check failure\n");
  1046c6:	f2c0 0010 	movt	r0, #16
  1046ca:	f006 fe07 	bl	10b2dc <printf>
		return -1;
  1046ce:	e7ef      	b.n	1046b0 <pmu_powerdown+0x30>

001046d0 <pmu_set_powerdown_delay>:
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerdown_delay(pmudev_t *dev, int id, int delay)
{
  1046d0:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1046d2:	6803      	ldr	r3, [r0, #0]
  1046d4:	b17b      	cbz	r3, 1046f6 <pmu_set_powerdown_delay+0x26>
  1046d6:	68c3      	ldr	r3, [r0, #12]
  1046d8:	4601      	mov	r1, r0
  1046da:	b163      	cbz	r3, 1046f6 <pmu_set_powerdown_delay+0x26>
  1046dc:	f7ff fed8 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0x0 || delay > 0xf) {
  1046e0:	b948      	cbnz	r0, 1046f6 <pmu_set_powerdown_delay+0x26>
  1046e2:	2a0f      	cmp	r2, #15
  1046e4:	d807      	bhi.n	1046f6 <pmu_set_powerdown_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 4, 4, delay);
  1046e6:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  1046e8:	690b      	ldr	r3, [r1, #16]
  1046ea:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  1046ee:	ea43 1202 	orr.w	r2, r3, r2, lsl #4
  1046f2:	610a      	str	r2, [r1, #16]
	return 0;
}
  1046f4:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  1046f6:	f64c 512c 	movw	r1, #52524	; 0xcd2c
  1046fa:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  1046fe:	2299      	movs	r2, #153	; 0x99
  104700:	f2c0 0110 	movt	r1, #16
  104704:	f2c0 0010 	movt	r0, #16
  104708:	f006 fde8 	bl	10b2dc <printf>
		return -1;
  10470c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104710:	bd08      	pop	{r3, r15}
  104712:	bf00      	nop

00104714 <pmu_set_powerup_delay>:
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerup_delay(pmudev_t *dev, int id, int delay)
{
  104714:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104716:	6803      	ldr	r3, [r0, #0]
  104718:	b173      	cbz	r3, 104738 <pmu_set_powerup_delay+0x24>
  10471a:	68c3      	ldr	r3, [r0, #12]
  10471c:	4601      	mov	r1, r0
  10471e:	b15b      	cbz	r3, 104738 <pmu_set_powerup_delay+0x24>
  104720:	f7ff feb6 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0x0 || delay > 0xf) {
  104724:	b940      	cbnz	r0, 104738 <pmu_set_powerup_delay+0x24>
  104726:	2a0f      	cmp	r2, #15
  104728:	d806      	bhi.n	104738 <pmu_set_powerup_delay+0x24>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_0, 0, 4, delay);
  10472a:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  10472c:	690b      	ldr	r3, [r1, #16]
  10472e:	f023 030f 	bic.w	r3, r3, #15
  104732:	431a      	orrs	r2, r3
  104734:	610a      	str	r2, [r1, #16]
	return 0;
}
  104736:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  104738:	f64c 5144 	movw	r1, #52548	; 0xcd44
  10473c:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104740:	22b9      	movs	r2, #185	; 0xb9
  104742:	f2c0 0110 	movt	r1, #16
  104746:	f2c0 0010 	movt	r0, #16
  10474a:	f006 fdc7 	bl	10b2dc <printf>
		return -1;
  10474e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104752:	bd08      	pop	{r3, r15}

00104754 <pmu_set_powerctrl_powerdown_delay>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104754:	6803      	ldr	r3, [r0, #0]
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerctrl_powerdown_delay(pmudev_t *dev, int ctrl_id, int delay)
{
  104756:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104758:	b343      	cbz	r3, 1047ac <pmu_set_powerctrl_powerdown_delay+0x58>
  10475a:	68c3      	ldr	r3, [r0, #12]
  10475c:	4604      	mov	r4, r0
  10475e:	b32b      	cbz	r3, 1047ac <pmu_set_powerctrl_powerdown_delay+0x58>
  104760:	f7ff fe96 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || delay < 0x0 || delay > 0xf || ctrl_id < 0 || ctrl_id > 3) {
  104764:	bb10      	cbnz	r0, 1047ac <pmu_set_powerctrl_powerdown_delay+0x58>
  104766:	2903      	cmp	r1, #3
  104768:	bf98      	it	ls
  10476a:	2a0f      	cmpls	r2, #15
  10476c:	d81e      	bhi.n	1047ac <pmu_set_powerctrl_powerdown_delay+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  10476e:	2902      	cmp	r1, #2
  104770:	d017      	beq.n	1047a2 <pmu_set_powerctrl_powerdown_delay+0x4e>
  104772:	2903      	cmp	r1, #3
  104774:	d010      	beq.n	104798 <pmu_set_powerctrl_powerdown_delay+0x44>
  104776:	2514      	movs	r5, #20
  104778:	2901      	cmp	r1, #1
  10477a:	bf07      	ittee	eq
  10477c:	f46f 26f0 	mvneq.w	r6, #491520	; 0x78000
  104780:	230f      	moveq	r3, #15
  104782:	f06f 06f0 	mvnne.w	r6, #240	; 0xf0
  104786:	2304      	movne	r3, #4
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 15;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 4, delay);
  104788:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  10478a:	fa02 f303 	lsl.w	r3, r2, r3
  10478e:	594a      	ldr	r2, [r1, r5]
  104790:	4032      	ands	r2, r6
  104792:	431a      	orrs	r2, r3
  104794:	514a      	str	r2, [r1, r5]
	return 0;
}
  104796:	bd70      	pop	{r4, r5, r6, r15}
			break;
  104798:	2518      	movs	r5, #24
  10479a:	f46f 26f0 	mvn.w	r6, #491520	; 0x78000
			reg_start_bit = 15;
  10479e:	230f      	movs	r3, #15
			break;
  1047a0:	e7f2      	b.n	104788 <pmu_set_powerctrl_powerdown_delay+0x34>
			break;
  1047a2:	2518      	movs	r5, #24
  1047a4:	f06f 06f0 	mvn.w	r6, #240	; 0xf0
			reg_start_bit = 4;
  1047a8:	2304      	movs	r3, #4
			break;
  1047aa:	e7ed      	b.n	104788 <pmu_set_powerctrl_powerdown_delay+0x34>
		pmu_err("check failure\n");
  1047ac:	f64c 515c 	movw	r1, #52572	; 0xcd5c
  1047b0:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  1047b4:	22db      	movs	r2, #219	; 0xdb
  1047b6:	f2c0 0110 	movt	r1, #16
  1047ba:	f2c0 0010 	movt	r0, #16
  1047be:	f006 fd8d 	bl	10b2dc <printf>
		return -1;
  1047c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1047c6:	bd70      	pop	{r4, r5, r6, r15}

001047c8 <pmu_set_powerctrl_powerup_delay>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1047c8:	6803      	ldr	r3, [r0, #0]
 *               0xe - 8ms
 *               0xf - 16ms
 *
 *****************************************************************************/
int32_t pmu_set_powerctrl_powerup_delay(pmudev_t *dev, int ctrl_id, int delay)
{
  1047ca:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1047cc:	b323      	cbz	r3, 104818 <pmu_set_powerctrl_powerup_delay+0x50>
  1047ce:	68c3      	ldr	r3, [r0, #12]
  1047d0:	4604      	mov	r4, r0
  1047d2:	b30b      	cbz	r3, 104818 <pmu_set_powerctrl_powerup_delay+0x50>
  1047d4:	f7ff fe5c 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || delay < 0x0 || delay > 0xf || ctrl_id < 0 || ctrl_id > 3) {
  1047d8:	b9f0      	cbnz	r0, 104818 <pmu_set_powerctrl_powerup_delay+0x50>
  1047da:	2903      	cmp	r1, #3
  1047dc:	bf98      	it	ls
  1047de:	2a0f      	cmpls	r2, #15
  1047e0:	d81a      	bhi.n	104818 <pmu_set_powerctrl_powerup_delay+0x50>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  1047e2:	2902      	cmp	r1, #2
  1047e4:	d014      	beq.n	104810 <pmu_set_powerctrl_powerup_delay+0x48>
  1047e6:	2903      	cmp	r1, #3
  1047e8:	d00d      	beq.n	104806 <pmu_set_powerctrl_powerup_delay+0x3e>
			reg_start_bit = 0;
			break;
		case PWR_CTRL_1:
			reg_offset = PMU_CTRL_1;
			reg_start_bit = 11;
			break;
  1047ea:	2514      	movs	r5, #20
	switch (ctrl_id) {
  1047ec:	2901      	cmp	r1, #1
  1047ee:	bf12      	itee	ne
  1047f0:	f06f 060f 	mvnne.w	r6, #15
  1047f4:	02d2      	lsleq	r2, r2, #11
			break;
  1047f6:	f46f 46f0 	mvneq.w	r6, #30720	; 0x7800
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 11;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 4, delay);
  1047fa:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  1047fc:	594b      	ldr	r3, [r1, r5]
  1047fe:	4033      	ands	r3, r6
  104800:	431a      	orrs	r2, r3
  104802:	514a      	str	r2, [r1, r5]
	return 0;
}
  104804:	bd70      	pop	{r4, r5, r6, r15}
  104806:	02d2      	lsls	r2, r2, #11
			break;
  104808:	2518      	movs	r5, #24
  10480a:	f46f 46f0 	mvn.w	r6, #30720	; 0x7800
  10480e:	e7f4      	b.n	1047fa <pmu_set_powerctrl_powerup_delay+0x32>
	switch (ctrl_id) {
  104810:	2518      	movs	r5, #24
  104812:	f06f 060f 	mvn.w	r6, #15
  104816:	e7f0      	b.n	1047fa <pmu_set_powerctrl_powerup_delay+0x32>
		pmu_err("check failure\n");
  104818:	f64c 5180 	movw	r1, #52608	; 0xcd80
  10481c:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104820:	f44f 7288 	mov.w	r2, #272	; 0x110
  104824:	f2c0 0110 	movt	r1, #16
  104828:	f2c0 0010 	movt	r0, #16
  10482c:	f006 fd56 	bl	10b2dc <printf>
		return -1;
  104830:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104834:	bd70      	pop	{r4, r5, r6, r15}
  104836:	bf00      	nop

00104838 <pmu_set_powerctrl_io_mode>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104838:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_powerctrl_io_mode(pmudev_t *dev, int ctrl_id, int mode)
{
  10483a:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10483c:	b343      	cbz	r3, 104890 <pmu_set_powerctrl_io_mode+0x58>
  10483e:	68c3      	ldr	r3, [r0, #12]
  104840:	4604      	mov	r4, r0
  104842:	b32b      	cbz	r3, 104890 <pmu_set_powerctrl_io_mode+0x58>
  104844:	f7ff fe24 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (mode != PWR_CTRL_INPUT && mode != PWR_CTRL_OUTPUT )
  104848:	bb10      	cbnz	r0, 104890 <pmu_set_powerctrl_io_mode+0x58>
	        || ctrl_id < 0 || ctrl_id > 3) {
  10484a:	2903      	cmp	r1, #3
  10484c:	bf98      	it	ls
  10484e:	2a01      	cmpls	r2, #1
  104850:	d81e      	bhi.n	104890 <pmu_set_powerctrl_io_mode+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  104852:	2902      	cmp	r1, #2
  104854:	d017      	beq.n	104886 <pmu_set_powerctrl_io_mode+0x4e>
  104856:	2903      	cmp	r1, #3
  104858:	d010      	beq.n	10487c <pmu_set_powerctrl_io_mode+0x44>
  10485a:	2514      	movs	r5, #20
  10485c:	2901      	cmp	r1, #1
  10485e:	bf07      	ittee	eq
  104860:	f46f 2600 	mvneq.w	r6, #524288	; 0x80000
  104864:	2313      	moveq	r3, #19
  104866:	f46f 7680 	mvnne.w	r6, #256	; 0x100
  10486a:	2308      	movne	r3, #8
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 19;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, mode);
  10486c:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  10486e:	fa02 f303 	lsl.w	r3, r2, r3
  104872:	594a      	ldr	r2, [r1, r5]
  104874:	4032      	ands	r2, r6
  104876:	431a      	orrs	r2, r3
  104878:	514a      	str	r2, [r1, r5]
	return 0;
}
  10487a:	bd70      	pop	{r4, r5, r6, r15}
			break;
  10487c:	2518      	movs	r5, #24
  10487e:	f46f 2600 	mvn.w	r6, #524288	; 0x80000
			reg_start_bit = 19;
  104882:	2313      	movs	r3, #19
			break;
  104884:	e7f2      	b.n	10486c <pmu_set_powerctrl_io_mode+0x34>
			break;
  104886:	2518      	movs	r5, #24
  104888:	f46f 7680 	mvn.w	r6, #256	; 0x100
			reg_start_bit = 8;
  10488c:	2308      	movs	r3, #8
			break;
  10488e:	e7ed      	b.n	10486c <pmu_set_powerctrl_io_mode+0x34>
		pmu_err("check failure\n");
  104890:	f64c 51a0 	movw	r1, #52640	; 0xcda0
  104894:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104898:	f240 1231 	movw	r2, #305	; 0x131
  10489c:	f2c0 0110 	movt	r1, #16
  1048a0:	f2c0 0010 	movt	r0, #16
  1048a4:	f006 fd1a 	bl	10b2dc <printf>
		return -1;
  1048a8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1048ac:	bd70      	pop	{r4, r5, r6, r15}
  1048ae:	bf00      	nop

001048b0 <pmu_set_powerctrl_out_mode>:

int32_t pmu_set_powerctrl_out_mode(pmudev_t *dev, int ctrl_id, int mode)
{
  1048b0:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1048b2:	6803      	ldr	r3, [r0, #0]
  1048b4:	b353      	cbz	r3, 10490c <pmu_set_powerctrl_out_mode+0x5c>
  1048b6:	68c3      	ldr	r3, [r0, #12]
  1048b8:	4604      	mov	r4, r0
  1048ba:	b33b      	cbz	r3, 10490c <pmu_set_powerctrl_out_mode+0x5c>
  1048bc:	f7ff fde8 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (mode != PWR_CTRL_OUTPUT_MANUAL && mode != PWR_CTRL_OUTPUT_AUTO )
  1048c0:	bb20      	cbnz	r0, 10490c <pmu_set_powerctrl_out_mode+0x5c>
	        || ctrl_id < 0 || ctrl_id > 3) {
  1048c2:	2903      	cmp	r1, #3
  1048c4:	bf98      	it	ls
  1048c6:	2a01      	cmpls	r2, #1
  1048c8:	d820      	bhi.n	10490c <pmu_set_powerctrl_out_mode+0x5c>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  1048ca:	2902      	cmp	r1, #2
  1048cc:	d019      	beq.n	104902 <pmu_set_powerctrl_out_mode+0x52>
  1048ce:	2903      	cmp	r1, #3
  1048d0:	d00d      	beq.n	1048ee <pmu_set_powerctrl_out_mode+0x3e>
  1048d2:	2901      	cmp	r1, #1
  1048d4:	d010      	beq.n	1048f8 <pmu_set_powerctrl_out_mode+0x48>
  1048d6:	2114      	movs	r1, #20
  1048d8:	f46f 7500 	mvn.w	r5, #512	; 0x200
		case PWR_CTRL_0:
			reg_offset = PMU_CTRL_1;
			reg_start_bit = 9;
  1048dc:	2309      	movs	r3, #9
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 20;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, mode);
  1048de:	6924      	ldr	r4, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  1048e0:	fa02 f303 	lsl.w	r3, r2, r3
  1048e4:	5862      	ldr	r2, [r4, r1]
  1048e6:	402a      	ands	r2, r5
  1048e8:	431a      	orrs	r2, r3
  1048ea:	5062      	str	r2, [r4, r1]
	return 0;
}
  1048ec:	bd38      	pop	{r3, r4, r5, r15}
			break;
  1048ee:	2118      	movs	r1, #24
  1048f0:	f46f 1580 	mvn.w	r5, #1048576	; 0x100000
			reg_start_bit = 20;
  1048f4:	2314      	movs	r3, #20
			break;
  1048f6:	e7f2      	b.n	1048de <pmu_set_powerctrl_out_mode+0x2e>
	switch (ctrl_id) {
  1048f8:	2114      	movs	r1, #20
  1048fa:	f46f 1580 	mvn.w	r5, #1048576	; 0x100000
			reg_start_bit = 20;
  1048fe:	460b      	mov	r3, r1
  104900:	e7ed      	b.n	1048de <pmu_set_powerctrl_out_mode+0x2e>
			break;
  104902:	2118      	movs	r1, #24
  104904:	f46f 7500 	mvn.w	r5, #512	; 0x200
			reg_start_bit = 9;
  104908:	2309      	movs	r3, #9
			break;
  10490a:	e7e8      	b.n	1048de <pmu_set_powerctrl_out_mode+0x2e>
		pmu_err("check failure\n");
  10490c:	f64c 51bc 	movw	r1, #52668	; 0xcdbc
  104910:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104914:	f44f 72a9 	mov.w	r2, #338	; 0x152
  104918:	f2c0 0110 	movt	r1, #16
  10491c:	f2c0 0010 	movt	r0, #16
  104920:	f006 fcdc 	bl	10b2dc <printf>
		return -1;
  104924:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104928:	bd38      	pop	{r3, r4, r5, r15}
  10492a:	bf00      	nop

0010492c <pmu_set_powerctrl_out_ctrl>:
	if (dev->name == NULL || dev->base_paddr == NULL
  10492c:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_powerctrl_out_ctrl(pmudev_t *dev, int ctrl_id, int out)
{
  10492e:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104930:	b343      	cbz	r3, 104984 <pmu_set_powerctrl_out_ctrl+0x58>
  104932:	68c3      	ldr	r3, [r0, #12]
  104934:	4604      	mov	r4, r0
  104936:	b32b      	cbz	r3, 104984 <pmu_set_powerctrl_out_ctrl+0x58>
  104938:	f7ff fdaa 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;

	if (pmu_check(dev) || (out != PWR_CTRL_OUTPUT_LOW && out != PWR_CTRL_OUTPUT_HIGH)
  10493c:	bb10      	cbnz	r0, 104984 <pmu_set_powerctrl_out_ctrl+0x58>
	        || ctrl_id < 0 || ctrl_id > 3) {
  10493e:	2903      	cmp	r1, #3
  104940:	bf98      	it	ls
  104942:	2a01      	cmpls	r2, #1
  104944:	d81e      	bhi.n	104984 <pmu_set_powerctrl_out_ctrl+0x58>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  104946:	2902      	cmp	r1, #2
  104948:	d017      	beq.n	10497a <pmu_set_powerctrl_out_ctrl+0x4e>
  10494a:	2903      	cmp	r1, #3
  10494c:	d010      	beq.n	104970 <pmu_set_powerctrl_out_ctrl+0x44>
  10494e:	2514      	movs	r5, #20
  104950:	2901      	cmp	r1, #1
  104952:	bf07      	ittee	eq
  104954:	f46f 1600 	mvneq.w	r6, #2097152	; 0x200000
  104958:	2315      	moveq	r3, #21
  10495a:	f46f 6680 	mvnne.w	r6, #1024	; 0x400
  10495e:	230a      	movne	r3, #10
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 21;
			break;
	}

	pmu_modify_reg32(dev->base_vaddr + reg_offset, reg_start_bit, 1, out);
  104960:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  104962:	fa02 f303 	lsl.w	r3, r2, r3
  104966:	594a      	ldr	r2, [r1, r5]
  104968:	4032      	ands	r2, r6
  10496a:	431a      	orrs	r2, r3
  10496c:	514a      	str	r2, [r1, r5]
	return 0;
}
  10496e:	bd70      	pop	{r4, r5, r6, r15}
			break;
  104970:	2518      	movs	r5, #24
  104972:	f46f 1600 	mvn.w	r6, #2097152	; 0x200000
			reg_start_bit = 21;
  104976:	2315      	movs	r3, #21
			break;
  104978:	e7f2      	b.n	104960 <pmu_set_powerctrl_out_ctrl+0x34>
			break;
  10497a:	2518      	movs	r5, #24
  10497c:	f46f 6680 	mvn.w	r6, #1024	; 0x400
			reg_start_bit = 10;
  104980:	230a      	movs	r3, #10
			break;
  104982:	e7ed      	b.n	104960 <pmu_set_powerctrl_out_ctrl+0x34>
		pmu_err("check failure\n");
  104984:	f64c 51d8 	movw	r1, #52696	; 0xcdd8
  104988:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  10498c:	f240 1273 	movw	r2, #371	; 0x173
  104990:	f2c0 0110 	movt	r1, #16
  104994:	f2c0 0010 	movt	r0, #16
  104998:	f006 fca0 	bl	10b2dc <printf>
		return -1;
  10499c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1049a0:	bd70      	pop	{r4, r5, r6, r15}
  1049a2:	bf00      	nop

001049a4 <pmu_get_powerctrl_input_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  1049a4:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_powerctrl_input_status(pmudev_t *dev, int ctrl_id, int *status)
{
  1049a6:	b570      	push	{r4, r5, r6, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  1049a8:	b363      	cbz	r3, 104a04 <pmu_get_powerctrl_input_status+0x60>
  1049aa:	68c3      	ldr	r3, [r0, #12]
  1049ac:	4604      	mov	r4, r0
  1049ae:	b34b      	cbz	r3, 104a04 <pmu_get_powerctrl_input_status+0x60>
  1049b0:	f7ff fd6e 	bl	104490 <pmu_check.part.0>
	int reg_offset, reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || ctrl_id < 0 || ctrl_id > 3) {
  1049b4:	bb30      	cbnz	r0, 104a04 <pmu_get_powerctrl_input_status+0x60>
  1049b6:	2903      	cmp	r1, #3
  1049b8:	bf94      	ite	ls
  1049ba:	2300      	movls	r3, #0
  1049bc:	2301      	movhi	r3, #1
  1049be:	2a00      	cmp	r2, #0
  1049c0:	bf08      	it	eq
  1049c2:	2301      	moveq	r3, #1
  1049c4:	b9f3      	cbnz	r3, 104a04 <pmu_get_powerctrl_input_status+0x60>
		pmu_err("check failure\n");
		return -1;
	}

	switch (ctrl_id) {
  1049c6:	2902      	cmp	r1, #2
  1049c8:	d017      	beq.n	1049fa <pmu_get_powerctrl_input_status+0x56>
  1049ca:	2903      	cmp	r1, #3
  1049cc:	d010      	beq.n	1049f0 <pmu_get_powerctrl_input_status+0x4c>
  1049ce:	2314      	movs	r3, #20
  1049d0:	2901      	cmp	r1, #1
  1049d2:	bf0b      	itete	eq
  1049d4:	f04f 4600 	moveq.w	r6, #2147483648	; 0x80000000
  1049d8:	f04f 4680 	movne.w	r6, #1073741824	; 0x40000000
  1049dc:	251f      	moveq	r5, #31
  1049de:	251e      	movne	r5, #30
			reg_offset = PMU_CTRL_2;
			reg_start_bit = 31;
			break;
	}

	v = readl(dev->base_vaddr + reg_offset);
  1049e0:	6921      	ldr	r1, [r4, #16]
  1049e2:	58cb      	ldr	r3, [r1, r3]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  1049e4:	4033      	ands	r3, r6
  1049e6:	40eb      	lsrs	r3, r5
  1049e8:	f003 0301 	and.w	r3, r3, #1
  1049ec:	6013      	str	r3, [r2, #0]
	return 0;
}
  1049ee:	bd70      	pop	{r4, r5, r6, r15}
			break;
  1049f0:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
  1049f4:	2318      	movs	r3, #24
			reg_start_bit = 31;
  1049f6:	251f      	movs	r5, #31
			break;
  1049f8:	e7f2      	b.n	1049e0 <pmu_get_powerctrl_input_status+0x3c>
			break;
  1049fa:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  1049fe:	2318      	movs	r3, #24
			reg_start_bit = 30;
  104a00:	251e      	movs	r5, #30
			break;
  104a02:	e7ed      	b.n	1049e0 <pmu_get_powerctrl_input_status+0x3c>
		pmu_err("check failure\n");
  104a04:	f64c 51f4 	movw	r1, #52724	; 0xcdf4
  104a08:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104a0c:	f44f 72ca 	mov.w	r2, #404	; 0x194
  104a10:	f2c0 0110 	movt	r1, #16
  104a14:	f2c0 0010 	movt	r0, #16
  104a18:	f006 fc60 	bl	10b2dc <printf>
		return -1;
  104a1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104a20:	bd70      	pop	{r4, r5, r6, r15}
  104a22:	bf00      	nop

00104a24 <pmu_set_internal_powerdown_enable>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104a24:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_internal_powerdown_enable(pmudev_t *dev, int id, int enable)
{
  104a26:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104a28:	b1b3      	cbz	r3, 104a58 <pmu_set_internal_powerdown_enable+0x34>
  104a2a:	68c3      	ldr	r3, [r0, #12]
  104a2c:	4604      	mov	r4, r0
  104a2e:	b19b      	cbz	r3, 104a58 <pmu_set_internal_powerdown_enable+0x34>
  104a30:	f7ff fd2e 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104a34:	b980      	cbnz	r0, 104a58 <pmu_set_internal_powerdown_enable+0x34>
	        || id < 0 || id > 1) {
  104a36:	2901      	cmp	r1, #1
  104a38:	bf98      	it	ls
  104a3a:	2a01      	cmpls	r2, #1
  104a3c:	d80c      	bhi.n	104a58 <pmu_set_internal_powerdown_enable+0x34>
  104a3e:	f06f 0301 	mvn.w	r3, #1
		pmu_err("check failure\n");
		return -1;
	}

	if (id == 0)
  104a42:	b929      	cbnz	r1, 104a50 <pmu_set_internal_powerdown_enable+0x2c>
		reg_start_bit = 0;
	else
		reg_start_bit = 2;

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_3, reg_start_bit, 1, enable);
  104a44:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  104a46:	69cc      	ldr	r4, [r1, #28]
  104a48:	4023      	ands	r3, r4
  104a4a:	431a      	orrs	r2, r3
  104a4c:	61ca      	str	r2, [r1, #28]
	return 0;
}
  104a4e:	bd10      	pop	{r4, r15}
  104a50:	0092      	lsls	r2, r2, #2
	if (id == 0)
  104a52:	f06f 0304 	mvn.w	r3, #4
  104a56:	e7f5      	b.n	104a44 <pmu_set_internal_powerdown_enable+0x20>
		pmu_err("check failure\n");
  104a58:	f64c 6114 	movw	r1, #52756	; 0xce14
  104a5c:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104a60:	f44f 72db 	mov.w	r2, #438	; 0x1b6
  104a64:	f2c0 0110 	movt	r1, #16
  104a68:	f2c0 0010 	movt	r0, #16
  104a6c:	f006 fc36 	bl	10b2dc <printf>
		return -1;
  104a70:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104a74:	bd10      	pop	{r4, r15}
  104a76:	bf00      	nop

00104a78 <pmu_set_internal_powerdown_polarity>:

int32_t pmu_set_internal_powerdown_polarity(pmudev_t *dev, int id, int polarity)
{
  104a78:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104a7a:	6803      	ldr	r3, [r0, #0]
  104a7c:	b1cb      	cbz	r3, 104ab2 <pmu_set_internal_powerdown_polarity+0x3a>
  104a7e:	68c3      	ldr	r3, [r0, #12]
  104a80:	4604      	mov	r4, r0
  104a82:	b1b3      	cbz	r3, 104ab2 <pmu_set_internal_powerdown_polarity+0x3a>
  104a84:	f7ff fd04 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  104a88:	b998      	cbnz	r0, 104ab2 <pmu_set_internal_powerdown_polarity+0x3a>
	        || id < 0 || id > 1) {
  104a8a:	2901      	cmp	r1, #1
  104a8c:	bf98      	it	ls
  104a8e:	2a01      	cmpls	r2, #1
  104a90:	d80f      	bhi.n	104ab2 <pmu_set_internal_powerdown_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 1;
	else
		reg_start_bit = 3;

	pmu_modify_reg32(dev->base_vaddr + PMU_CTRL_3, reg_start_bit, 1, polarity);
  104a92:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104a94:	2900      	cmp	r1, #0
  104a96:	bf1a      	itte	ne
  104a98:	f06f 0308 	mvnne.w	r3, #8
  104a9c:	2103      	movne	r1, #3
  104a9e:	f06f 0302 	mvneq.w	r3, #2
	RMWREG32(addr, startbit, width, val);
  104aa2:	69e5      	ldr	r5, [r4, #28]
	if (id == 0)
  104aa4:	bf08      	it	eq
  104aa6:	2101      	moveq	r1, #1
	RMWREG32(addr, startbit, width, val);
  104aa8:	408a      	lsls	r2, r1
  104aaa:	402b      	ands	r3, r5
  104aac:	431a      	orrs	r2, r3
  104aae:	61e2      	str	r2, [r4, #28]
	return 0;
}
  104ab0:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104ab2:	f64c 6138 	movw	r1, #52792	; 0xce38
  104ab6:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104aba:	f240 12c9 	movw	r2, #457	; 0x1c9
  104abe:	f2c0 0110 	movt	r1, #16
  104ac2:	f2c0 0010 	movt	r0, #16
  104ac6:	f006 fc09 	bl	10b2dc <printf>
		return -1;
  104aca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104ace:	bd38      	pop	{r3, r4, r5, r15}

00104ad0 <pmu_get_internal_powerdown_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104ad0:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_internal_powerdown_status(pmudev_t *dev, int id, int *status)
{
  104ad2:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104ad4:	b1eb      	cbz	r3, 104b12 <pmu_get_internal_powerdown_status+0x42>
  104ad6:	68c3      	ldr	r3, [r0, #12]
  104ad8:	4604      	mov	r4, r0
  104ada:	b1d3      	cbz	r3, 104b12 <pmu_get_internal_powerdown_status+0x42>
  104adc:	f7ff fcd8 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  104ae0:	b9b8      	cbnz	r0, 104b12 <pmu_get_internal_powerdown_status+0x42>
  104ae2:	2901      	cmp	r1, #1
  104ae4:	bf94      	ite	ls
  104ae6:	2300      	movls	r3, #0
  104ae8:	2301      	movhi	r3, #1
  104aea:	2a00      	cmp	r2, #0
  104aec:	bf08      	it	eq
  104aee:	2301      	moveq	r3, #1
  104af0:	b97b      	cbnz	r3, 104b12 <pmu_get_internal_powerdown_status+0x42>
	if (id == 0)
		reg_start_bit = 8;
	else
		reg_start_bit = 9;

	v = readl(dev->base_vaddr + PMU_CTRL_3);
  104af2:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104af4:	2900      	cmp	r1, #0
  104af6:	bf15      	itete	ne
  104af8:	f44f 7300 	movne.w	r3, #512	; 0x200
  104afc:	f44f 7380 	moveq.w	r3, #256	; 0x100
  104b00:	2109      	movne	r1, #9
  104b02:	2108      	moveq	r1, #8
	v = readl(dev->base_vaddr + PMU_CTRL_3);
  104b04:	69e4      	ldr	r4, [r4, #28]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  104b06:	4023      	ands	r3, r4
  104b08:	40cb      	lsrs	r3, r1
  104b0a:	f003 0301 	and.w	r3, r3, #1
  104b0e:	6013      	str	r3, [r2, #0]
	return 0;
}
  104b10:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  104b12:	f64c 615c 	movw	r1, #52828	; 0xce5c
  104b16:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104b1a:	f44f 72ee 	mov.w	r2, #476	; 0x1dc
  104b1e:	f2c0 0110 	movt	r1, #16
  104b22:	f2c0 0010 	movt	r0, #16
  104b26:	f006 fbd9 	bl	10b2dc <printf>
		return -1;
  104b2a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104b2e:	bd10      	pop	{r4, r15}

00104b30 <pmu_set_external_reset_enable>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104b30:	6803      	ldr	r3, [r0, #0]

int32_t pmu_set_external_reset_enable(pmudev_t *dev, int id, int enable)
{
  104b32:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104b34:	b1b3      	cbz	r3, 104b64 <pmu_set_external_reset_enable+0x34>
  104b36:	68c3      	ldr	r3, [r0, #12]
  104b38:	4604      	mov	r4, r0
  104b3a:	b19b      	cbz	r3, 104b64 <pmu_set_external_reset_enable+0x34>
  104b3c:	f7ff fca8 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104b40:	b980      	cbnz	r0, 104b64 <pmu_set_external_reset_enable+0x34>
	        || id < 0 || id > 1) {
  104b42:	2901      	cmp	r1, #1
  104b44:	bf98      	it	ls
  104b46:	2a01      	cmpls	r2, #1
  104b48:	d80c      	bhi.n	104b64 <pmu_set_external_reset_enable+0x34>
  104b4a:	f06f 0301 	mvn.w	r3, #1
		pmu_err("check failure\n");
		return -1;
	}

	if (id == 0)
  104b4e:	b929      	cbnz	r1, 104b5c <pmu_set_external_reset_enable+0x2c>
		reg_start_bit = 0;
	else
		reg_start_bit = 7;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  104b50:	6921      	ldr	r1, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  104b52:	680c      	ldr	r4, [r1, #0]
  104b54:	4023      	ands	r3, r4
  104b56:	431a      	orrs	r2, r3
  104b58:	600a      	str	r2, [r1, #0]
	return 0;
}
  104b5a:	bd10      	pop	{r4, r15}
  104b5c:	01d2      	lsls	r2, r2, #7
	if (id == 0)
  104b5e:	f06f 0380 	mvn.w	r3, #128	; 0x80
  104b62:	e7f5      	b.n	104b50 <pmu_set_external_reset_enable+0x20>
		pmu_err("check failure\n");
  104b64:	f64c 6180 	movw	r1, #52864	; 0xce80
  104b68:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104b6c:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
  104b70:	f2c0 0110 	movt	r1, #16
  104b74:	f2c0 0010 	movt	r0, #16
  104b78:	f006 fbb0 	bl	10b2dc <printf>
		return -1;
  104b7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104b80:	bd10      	pop	{r4, r15}
  104b82:	bf00      	nop

00104b84 <pmu_set_external_reset_polarity>:

int32_t pmu_set_external_reset_polarity(pmudev_t *dev, int id, int polarity)
{
  104b84:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104b86:	6803      	ldr	r3, [r0, #0]
  104b88:	b1cb      	cbz	r3, 104bbe <pmu_set_external_reset_polarity+0x3a>
  104b8a:	68c3      	ldr	r3, [r0, #12]
  104b8c:	4604      	mov	r4, r0
  104b8e:	b1b3      	cbz	r3, 104bbe <pmu_set_external_reset_polarity+0x3a>
  104b90:	f7ff fc7e 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  104b94:	b998      	cbnz	r0, 104bbe <pmu_set_external_reset_polarity+0x3a>
	        || id < 0 || id > 1) {
  104b96:	2901      	cmp	r1, #1
  104b98:	bf98      	it	ls
  104b9a:	2a01      	cmpls	r2, #1
  104b9c:	d80f      	bhi.n	104bbe <pmu_set_external_reset_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 1;
	else
		reg_start_bit = 8;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, polarity);
  104b9e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104ba0:	2900      	cmp	r1, #0
  104ba2:	bf1a      	itte	ne
  104ba4:	f46f 7380 	mvnne.w	r3, #256	; 0x100
  104ba8:	2108      	movne	r1, #8
  104baa:	f06f 0302 	mvneq.w	r3, #2
	RMWREG32(addr, startbit, width, val);
  104bae:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104bb0:	bf08      	it	eq
  104bb2:	2101      	moveq	r1, #1
	RMWREG32(addr, startbit, width, val);
  104bb4:	408a      	lsls	r2, r1
  104bb6:	402b      	ands	r3, r5
  104bb8:	431a      	orrs	r2, r3
  104bba:	6022      	str	r2, [r4, #0]
	return 0;
}
  104bbc:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104bbe:	f64c 61a0 	movw	r1, #52896	; 0xcea0
  104bc2:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104bc6:	f240 2203 	movw	r2, #515	; 0x203
  104bca:	f2c0 0110 	movt	r1, #16
  104bce:	f2c0 0010 	movt	r0, #16
  104bd2:	f006 fb83 	bl	10b2dc <printf>
		return -1;
  104bd6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104bda:	bd38      	pop	{r3, r4, r5, r15}

00104bdc <pmu_set_external_reset_debounce_enable>:

int32_t pmu_set_external_reset_debounce_enable(pmudev_t *dev, int id, int enable)
{
  104bdc:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104bde:	6803      	ldr	r3, [r0, #0]
  104be0:	b1cb      	cbz	r3, 104c16 <pmu_set_external_reset_debounce_enable+0x3a>
  104be2:	68c3      	ldr	r3, [r0, #12]
  104be4:	4604      	mov	r4, r0
  104be6:	b1b3      	cbz	r3, 104c16 <pmu_set_external_reset_debounce_enable+0x3a>
  104be8:	f7ff fc52 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104bec:	b998      	cbnz	r0, 104c16 <pmu_set_external_reset_debounce_enable+0x3a>
	        || id < 0 || id > 1) {
  104bee:	2901      	cmp	r1, #1
  104bf0:	bf98      	it	ls
  104bf2:	2a01      	cmpls	r2, #1
  104bf4:	d80f      	bhi.n	104c16 <pmu_set_external_reset_debounce_enable+0x3a>
	if (id == 0)
		reg_start_bit = 2;
	else
		reg_start_bit = 9;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  104bf6:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104bf8:	2900      	cmp	r1, #0
  104bfa:	bf1a      	itte	ne
  104bfc:	f46f 7300 	mvnne.w	r3, #512	; 0x200
  104c00:	2109      	movne	r1, #9
  104c02:	f06f 0304 	mvneq.w	r3, #4
	RMWREG32(addr, startbit, width, val);
  104c06:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104c08:	bf08      	it	eq
  104c0a:	2102      	moveq	r1, #2
	RMWREG32(addr, startbit, width, val);
  104c0c:	408a      	lsls	r2, r1
  104c0e:	402b      	ands	r3, r5
  104c10:	431a      	orrs	r2, r3
  104c12:	6022      	str	r2, [r4, #0]
	return 0;
}
  104c14:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104c16:	f64c 61c0 	movw	r1, #52928	; 0xcec0
  104c1a:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104c1e:	f240 2216 	movw	r2, #534	; 0x216
  104c22:	f2c0 0110 	movt	r1, #16
  104c26:	f2c0 0010 	movt	r0, #16
  104c2a:	f006 fb57 	bl	10b2dc <printf>
		return -1;
  104c2e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104c32:	bd38      	pop	{r3, r4, r5, r15}

00104c34 <pmu_set_external_reset_debounce_delay>:

int32_t pmu_set_external_reset_debounce_delay(pmudev_t *dev, int id, int delay)
{
  104c34:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104c36:	6803      	ldr	r3, [r0, #0]
  104c38:	b1cb      	cbz	r3, 104c6e <pmu_set_external_reset_debounce_delay+0x3a>
  104c3a:	68c3      	ldr	r3, [r0, #12]
  104c3c:	4604      	mov	r4, r0
  104c3e:	b1b3      	cbz	r3, 104c6e <pmu_set_external_reset_debounce_delay+0x3a>
  104c40:	f7ff fc26 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || delay < 0 || delay > 0xf || id < 0 || id > 1) {
  104c44:	b998      	cbnz	r0, 104c6e <pmu_set_external_reset_debounce_delay+0x3a>
  104c46:	2901      	cmp	r1, #1
  104c48:	bf98      	it	ls
  104c4a:	2a0f      	cmpls	r2, #15
  104c4c:	d80f      	bhi.n	104c6e <pmu_set_external_reset_debounce_delay+0x3a>
	if (id == 0)
		reg_start_bit = 3;
	else
		reg_start_bit = 10;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 4, delay);
  104c4e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104c50:	2900      	cmp	r1, #0
  104c52:	bf1a      	itte	ne
  104c54:	f46f 5370 	mvnne.w	r3, #15360	; 0x3c00
  104c58:	210a      	movne	r1, #10
  104c5a:	f06f 0378 	mvneq.w	r3, #120	; 0x78
	RMWREG32(addr, startbit, width, val);
  104c5e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104c60:	bf08      	it	eq
  104c62:	2103      	moveq	r1, #3
	RMWREG32(addr, startbit, width, val);
  104c64:	408a      	lsls	r2, r1
  104c66:	402b      	ands	r3, r5
  104c68:	431a      	orrs	r2, r3
  104c6a:	6022      	str	r2, [r4, #0]
	return 0;
}
  104c6c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104c6e:	f64c 61e8 	movw	r1, #52968	; 0xcee8
  104c72:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104c76:	f44f 720a 	mov.w	r2, #552	; 0x228
  104c7a:	f2c0 0110 	movt	r1, #16
  104c7e:	f2c0 0010 	movt	r0, #16
  104c82:	f006 fb2b 	bl	10b2dc <printf>
		return -1;
  104c86:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104c8a:	bd38      	pop	{r3, r4, r5, r15}

00104c8c <pmu_get_external_reset_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104c8c:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_external_reset_status(pmudev_t *dev, int id, int *status)
{
  104c8e:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104c90:	b1eb      	cbz	r3, 104cce <pmu_get_external_reset_status+0x42>
  104c92:	68c3      	ldr	r3, [r0, #12]
  104c94:	4604      	mov	r4, r0
  104c96:	b1d3      	cbz	r3, 104cce <pmu_get_external_reset_status+0x42>
  104c98:	f7ff fbfa 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  104c9c:	b9b8      	cbnz	r0, 104cce <pmu_get_external_reset_status+0x42>
  104c9e:	2901      	cmp	r1, #1
  104ca0:	bf94      	ite	ls
  104ca2:	2300      	movls	r3, #0
  104ca4:	2301      	movhi	r3, #1
  104ca6:	2a00      	cmp	r2, #0
  104ca8:	bf08      	it	eq
  104caa:	2301      	moveq	r3, #1
  104cac:	b97b      	cbnz	r3, 104cce <pmu_get_external_reset_status+0x42>
	if (id == 0)
		reg_start_bit = 28;
	else
		reg_start_bit = 29;

	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  104cae:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104cb0:	2900      	cmp	r1, #0
  104cb2:	bf15      	itete	ne
  104cb4:	f04f 5300 	movne.w	r3, #536870912	; 0x20000000
  104cb8:	f04f 5380 	moveq.w	r3, #268435456	; 0x10000000
  104cbc:	211d      	movne	r1, #29
  104cbe:	211c      	moveq	r1, #28
	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  104cc0:	6824      	ldr	r4, [r4, #0]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  104cc2:	4023      	ands	r3, r4
  104cc4:	40cb      	lsrs	r3, r1
  104cc6:	f003 0301 	and.w	r3, r3, #1
  104cca:	6013      	str	r3, [r2, #0]
	return 0;
}
  104ccc:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  104cce:	f64c 7110 	movw	r1, #53008	; 0xcf10
  104cd2:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104cd6:	f240 223b 	movw	r2, #571	; 0x23b
  104cda:	f2c0 0110 	movt	r1, #16
  104cde:	f2c0 0010 	movt	r0, #16
  104ce2:	f006 fafb 	bl	10b2dc <printf>
		return -1;
  104ce6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104cea:	bd10      	pop	{r4, r15}

00104cec <pmu_set_internal_wakeup_enable>:

int32_t pmu_set_internal_wakeup_enable(pmudev_t *dev, int id, int enable)
{
  104cec:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104cee:	6803      	ldr	r3, [r0, #0]
  104cf0:	b1ab      	cbz	r3, 104d1e <pmu_set_internal_wakeup_enable+0x32>
  104cf2:	68c3      	ldr	r3, [r0, #12]
  104cf4:	4604      	mov	r4, r0
  104cf6:	b193      	cbz	r3, 104d1e <pmu_set_internal_wakeup_enable+0x32>
  104cf8:	f7ff fbca 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104cfc:	b978      	cbnz	r0, 104d1e <pmu_set_internal_wakeup_enable+0x32>
	        || id < 0 || id > 1) {
  104cfe:	2901      	cmp	r1, #1
  104d00:	bf98      	it	ls
  104d02:	2a01      	cmpls	r2, #1
  104d04:	d80b      	bhi.n	104d1e <pmu_set_internal_wakeup_enable+0x32>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RTC_CTRL, id, 1, enable);
  104d06:	6925      	ldr	r5, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  104d08:	2401      	movs	r4, #1
  104d0a:	fa02 f301 	lsl.w	r3, r2, r1
  104d0e:	fa04 f101 	lsl.w	r1, r4, r1
  104d12:	686a      	ldr	r2, [r5, #4]
  104d14:	ea22 0201 	bic.w	r2, r2, r1
  104d18:	431a      	orrs	r2, r3
  104d1a:	606a      	str	r2, [r5, #4]
	return 0;
}
  104d1c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104d1e:	f64c 7130 	movw	r1, #53040	; 0xcf30
  104d22:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104d26:	f240 224d 	movw	r2, #589	; 0x24d
  104d2a:	f2c0 0110 	movt	r1, #16
  104d2e:	f2c0 0010 	movt	r0, #16
  104d32:	f006 fad3 	bl	10b2dc <printf>
		return -1;
  104d36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104d3a:	bd38      	pop	{r3, r4, r5, r15}

00104d3c <pmu_set_external_wakeup_enable>:

int32_t pmu_set_external_wakeup_enable(pmudev_t *dev, int id, int enable)
{
  104d3c:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104d3e:	6803      	ldr	r3, [r0, #0]
  104d40:	b1cb      	cbz	r3, 104d76 <pmu_set_external_wakeup_enable+0x3a>
  104d42:	68c3      	ldr	r3, [r0, #12]
  104d44:	4604      	mov	r4, r0
  104d46:	b1b3      	cbz	r3, 104d76 <pmu_set_external_wakeup_enable+0x3a>
  104d48:	f7ff fba2 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104d4c:	b998      	cbnz	r0, 104d76 <pmu_set_external_wakeup_enable+0x3a>
	        || id < 0 || id > 1) {
  104d4e:	2901      	cmp	r1, #1
  104d50:	bf98      	it	ls
  104d52:	2a01      	cmpls	r2, #1
  104d54:	d80f      	bhi.n	104d76 <pmu_set_external_wakeup_enable+0x3a>
	if (id == 0)
		reg_start_bit = 14;
	else
		reg_start_bit = 21;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  104d56:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104d58:	2900      	cmp	r1, #0
  104d5a:	bf1a      	itte	ne
  104d5c:	f46f 1300 	mvnne.w	r3, #2097152	; 0x200000
  104d60:	2115      	movne	r1, #21
  104d62:	f46f 4380 	mvneq.w	r3, #16384	; 0x4000
	RMWREG32(addr, startbit, width, val);
  104d66:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104d68:	bf08      	it	eq
  104d6a:	210e      	moveq	r1, #14
	RMWREG32(addr, startbit, width, val);
  104d6c:	408a      	lsls	r2, r1
  104d6e:	402b      	ands	r3, r5
  104d70:	431a      	orrs	r2, r3
  104d72:	6022      	str	r2, [r4, #0]
	return 0;
}
  104d74:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104d76:	f64c 7150 	movw	r1, #53072	; 0xcf50
  104d7a:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104d7e:	f240 225b 	movw	r2, #603	; 0x25b
  104d82:	f2c0 0110 	movt	r1, #16
  104d86:	f2c0 0010 	movt	r0, #16
  104d8a:	f006 faa7 	bl	10b2dc <printf>
		return -1;
  104d8e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104d92:	bd38      	pop	{r3, r4, r5, r15}

00104d94 <pmu_set_external_wakeup_polarity>:

int32_t pmu_set_external_wakeup_polarity(pmudev_t *dev, int id, int polarity)
{
  104d94:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104d96:	6803      	ldr	r3, [r0, #0]
  104d98:	b1cb      	cbz	r3, 104dce <pmu_set_external_wakeup_polarity+0x3a>
  104d9a:	68c3      	ldr	r3, [r0, #12]
  104d9c:	4604      	mov	r4, r0
  104d9e:	b1b3      	cbz	r3, 104dce <pmu_set_external_wakeup_polarity+0x3a>
  104da0:	f7ff fb76 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (polarity != HIGH_LEVEL && polarity != LOW_LEVEL)
  104da4:	b998      	cbnz	r0, 104dce <pmu_set_external_wakeup_polarity+0x3a>
	        || id < 0 || id > 1) {
  104da6:	2901      	cmp	r1, #1
  104da8:	bf98      	it	ls
  104daa:	2a01      	cmpls	r2, #1
  104dac:	d80f      	bhi.n	104dce <pmu_set_external_wakeup_polarity+0x3a>
	if (id == 0)
		reg_start_bit = 15;
	else
		reg_start_bit = 22;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, polarity);
  104dae:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104db0:	2900      	cmp	r1, #0
  104db2:	bf1a      	itte	ne
  104db4:	f46f 0380 	mvnne.w	r3, #4194304	; 0x400000
  104db8:	2116      	movne	r1, #22
  104dba:	f46f 4300 	mvneq.w	r3, #32768	; 0x8000
	RMWREG32(addr, startbit, width, val);
  104dbe:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104dc0:	bf08      	it	eq
  104dc2:	210f      	moveq	r1, #15
	RMWREG32(addr, startbit, width, val);
  104dc4:	408a      	lsls	r2, r1
  104dc6:	402b      	ands	r3, r5
  104dc8:	431a      	orrs	r2, r3
  104dca:	6022      	str	r2, [r4, #0]
	return 0;
}
  104dcc:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104dce:	f64c 7170 	movw	r1, #53104	; 0xcf70
  104dd2:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104dd6:	f240 226e 	movw	r2, #622	; 0x26e
  104dda:	f2c0 0110 	movt	r1, #16
  104dde:	f2c0 0010 	movt	r0, #16
  104de2:	f006 fa7b 	bl	10b2dc <printf>
		return -1;
  104de6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104dea:	bd38      	pop	{r3, r4, r5, r15}

00104dec <pmu_set_external_wakeup_debounce_enable>:

int32_t pmu_set_external_wakeup_debounce_enable(pmudev_t *dev, int id, int enable)
{
  104dec:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104dee:	6803      	ldr	r3, [r0, #0]
  104df0:	b1cb      	cbz	r3, 104e26 <pmu_set_external_wakeup_debounce_enable+0x3a>
  104df2:	68c3      	ldr	r3, [r0, #12]
  104df4:	4604      	mov	r4, r0
  104df6:	b1b3      	cbz	r3, 104e26 <pmu_set_external_wakeup_debounce_enable+0x3a>
  104df8:	f7ff fb4a 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104dfc:	b998      	cbnz	r0, 104e26 <pmu_set_external_wakeup_debounce_enable+0x3a>
	        || id < 0 || id > 1) {
  104dfe:	2901      	cmp	r1, #1
  104e00:	bf98      	it	ls
  104e02:	2a01      	cmpls	r2, #1
  104e04:	d80f      	bhi.n	104e26 <pmu_set_external_wakeup_debounce_enable+0x3a>
	if (id == 0)
		reg_start_bit = 16;
	else
		reg_start_bit = 23;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 1, enable);
  104e06:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104e08:	2900      	cmp	r1, #0
  104e0a:	bf1a      	itte	ne
  104e0c:	f46f 0300 	mvnne.w	r3, #8388608	; 0x800000
  104e10:	2117      	movne	r1, #23
  104e12:	f46f 3380 	mvneq.w	r3, #65536	; 0x10000
	RMWREG32(addr, startbit, width, val);
  104e16:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104e18:	bf08      	it	eq
  104e1a:	2110      	moveq	r1, #16
	RMWREG32(addr, startbit, width, val);
  104e1c:	408a      	lsls	r2, r1
  104e1e:	402b      	ands	r3, r5
  104e20:	431a      	orrs	r2, r3
  104e22:	6022      	str	r2, [r4, #0]
	return 0;
}
  104e24:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104e26:	f64c 7194 	movw	r1, #53140	; 0xcf94
  104e2a:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104e2e:	f240 2281 	movw	r2, #641	; 0x281
  104e32:	f2c0 0110 	movt	r1, #16
  104e36:	f2c0 0010 	movt	r0, #16
  104e3a:	f006 fa4f 	bl	10b2dc <printf>
		return -1;
  104e3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104e42:	bd38      	pop	{r3, r4, r5, r15}

00104e44 <pmu_set_external_wakeup_debounce_delay>:

int32_t pmu_set_external_wakeup_debounce_delay(pmudev_t *dev, int id, int delay)
{
  104e44:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104e46:	6803      	ldr	r3, [r0, #0]
  104e48:	b1cb      	cbz	r3, 104e7e <pmu_set_external_wakeup_debounce_delay+0x3a>
  104e4a:	68c3      	ldr	r3, [r0, #12]
  104e4c:	4604      	mov	r4, r0
  104e4e:	b1b3      	cbz	r3, 104e7e <pmu_set_external_wakeup_debounce_delay+0x3a>
  104e50:	f7ff fb1e 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;

	if (pmu_check(dev) || delay < 0 || delay > 0xf || id < 0 || id > 1) {
  104e54:	b998      	cbnz	r0, 104e7e <pmu_set_external_wakeup_debounce_delay+0x3a>
  104e56:	2901      	cmp	r1, #1
  104e58:	bf98      	it	ls
  104e5a:	2a0f      	cmpls	r2, #15
  104e5c:	d80f      	bhi.n	104e7e <pmu_set_external_wakeup_debounce_delay+0x3a>
	if (id == 0)
		reg_start_bit = 17;
	else
		reg_start_bit = 24;

	pmu_modify_reg32(dev->base_vaddr + PMU_EXT_CRTL, reg_start_bit, 4, delay);
  104e5e:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104e60:	2900      	cmp	r1, #0
  104e62:	bf1a      	itte	ne
  104e64:	f06f 6370 	mvnne.w	r3, #251658240	; 0xf000000
  104e68:	2118      	movne	r1, #24
  104e6a:	f46f 13f0 	mvneq.w	r3, #1966080	; 0x1e0000
	RMWREG32(addr, startbit, width, val);
  104e6e:	6825      	ldr	r5, [r4, #0]
	if (id == 0)
  104e70:	bf08      	it	eq
  104e72:	2111      	moveq	r1, #17
	RMWREG32(addr, startbit, width, val);
  104e74:	408a      	lsls	r2, r1
  104e76:	402b      	ands	r3, r5
  104e78:	431a      	orrs	r2, r3
  104e7a:	6022      	str	r2, [r4, #0]
	return 0;
}
  104e7c:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104e7e:	f64c 71bc 	movw	r1, #53180	; 0xcfbc
  104e82:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104e86:	f240 2293 	movw	r2, #659	; 0x293
  104e8a:	f2c0 0110 	movt	r1, #16
  104e8e:	f2c0 0010 	movt	r0, #16
  104e92:	f006 fa23 	bl	10b2dc <printf>
		return -1;
  104e96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104e9a:	bd38      	pop	{r3, r4, r5, r15}

00104e9c <pmu_get_external_wakeup_status>:
	if (dev->name == NULL || dev->base_paddr == NULL
  104e9c:	6803      	ldr	r3, [r0, #0]

int32_t pmu_get_external_wakeup_status(pmudev_t *dev, int id, int *status)
{
  104e9e:	b510      	push	{r4, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104ea0:	b1eb      	cbz	r3, 104ede <pmu_get_external_wakeup_status+0x42>
  104ea2:	68c3      	ldr	r3, [r0, #12]
  104ea4:	4604      	mov	r4, r0
  104ea6:	b1d3      	cbz	r3, 104ede <pmu_get_external_wakeup_status+0x42>
  104ea8:	f7ff faf2 	bl	104490 <pmu_check.part.0>
	int reg_start_bit;
	uint32_t v;

	if (pmu_check(dev) || status == NULL || id < 0 || id > 1) {
  104eac:	b9b8      	cbnz	r0, 104ede <pmu_get_external_wakeup_status+0x42>
  104eae:	2901      	cmp	r1, #1
  104eb0:	bf94      	ite	ls
  104eb2:	2300      	movls	r3, #0
  104eb4:	2301      	movhi	r3, #1
  104eb6:	2a00      	cmp	r2, #0
  104eb8:	bf08      	it	eq
  104eba:	2301      	moveq	r3, #1
  104ebc:	b97b      	cbnz	r3, 104ede <pmu_get_external_wakeup_status+0x42>
	if (id == 0)
		reg_start_bit = 30;
	else
		reg_start_bit = 31;

	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  104ebe:	6924      	ldr	r4, [r4, #16]
	if (id == 0)
  104ec0:	2900      	cmp	r1, #0
  104ec2:	bf15      	itete	ne
  104ec4:	f04f 4300 	movne.w	r3, #2147483648	; 0x80000000
  104ec8:	f04f 4380 	moveq.w	r3, #1073741824	; 0x40000000
  104ecc:	211f      	movne	r1, #31
  104ece:	211e      	moveq	r1, #30
	v = readl(dev->base_vaddr + PMU_EXT_CRTL);
  104ed0:	6824      	ldr	r4, [r4, #0]
	*status = ((v & (1 << reg_start_bit)) >> reg_start_bit) & 0x1;
  104ed2:	4023      	ands	r3, r4
  104ed4:	40cb      	lsrs	r3, r1
  104ed6:	f003 0301 	and.w	r3, r3, #1
  104eda:	6013      	str	r3, [r2, #0]
	return 0;
}
  104edc:	bd10      	pop	{r4, r15}
		pmu_err("check failure\n");
  104ede:	f64c 71e4 	movw	r1, #53220	; 0xcfe4
  104ee2:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104ee6:	f240 22a6 	movw	r2, #678	; 0x2a6
  104eea:	f2c0 0110 	movt	r1, #16
  104eee:	f2c0 0010 	movt	r0, #16
  104ef2:	f006 f9f3 	bl	10b2dc <printf>
		return -1;
  104ef6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104efa:	bd10      	pop	{r4, r15}

00104efc <pmu_set_glitch_filter_delay>:

int32_t pmu_set_glitch_filter_delay(pmudev_t *dev, int id, int delay)
{
  104efc:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104efe:	6803      	ldr	r3, [r0, #0]
  104f00:	b17b      	cbz	r3, 104f22 <pmu_set_glitch_filter_delay+0x26>
  104f02:	68c3      	ldr	r3, [r0, #12]
  104f04:	4601      	mov	r1, r0
  104f06:	b163      	cbz	r3, 104f22 <pmu_set_glitch_filter_delay+0x26>
  104f08:	f7ff fac2 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0 || delay > 0x7) {
  104f0c:	b948      	cbnz	r0, 104f22 <pmu_set_glitch_filter_delay+0x26>
  104f0e:	2a07      	cmp	r2, #7
  104f10:	d807      	bhi.n	104f22 <pmu_set_glitch_filter_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_GF_CTRL, 11, 3, delay);
  104f12:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  104f14:	688b      	ldr	r3, [r1, #8]
  104f16:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  104f1a:	ea43 22c2 	orr.w	r2, r3, r2, lsl #11
  104f1e:	608a      	str	r2, [r1, #8]
	return 0;
}
  104f20:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  104f22:	f24d 0104 	movw	r1, #53252	; 0xd004
  104f26:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104f2a:	f240 22b7 	movw	r2, #695	; 0x2b7
  104f2e:	f2c0 0110 	movt	r1, #16
  104f32:	f2c0 0010 	movt	r0, #16
  104f36:	f006 f9d1 	bl	10b2dc <printf>
		return -1;
  104f3a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104f3e:	bd08      	pop	{r3, r15}

00104f40 <pmu_set_glitch_filter_enable>:

int32_t pmu_set_glitch_filter_enable(pmudev_t *dev, int id, int enable)
{
  104f40:	b538      	push	{r3, r4, r5, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104f42:	6803      	ldr	r3, [r0, #0]
  104f44:	b1ab      	cbz	r3, 104f72 <pmu_set_glitch_filter_enable+0x32>
  104f46:	68c3      	ldr	r3, [r0, #12]
  104f48:	4604      	mov	r4, r0
  104f4a:	b193      	cbz	r3, 104f72 <pmu_set_glitch_filter_enable+0x32>
  104f4c:	f7ff faa0 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)
  104f50:	b978      	cbnz	r0, 104f72 <pmu_set_glitch_filter_enable+0x32>
	        || id < 0 || id > 10) {
  104f52:	290a      	cmp	r1, #10
  104f54:	bf98      	it	ls
  104f56:	2a01      	cmpls	r2, #1
  104f58:	d80b      	bhi.n	104f72 <pmu_set_glitch_filter_enable+0x32>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_GF_CTRL, id, 1, enable);
  104f5a:	6925      	ldr	r5, [r4, #16]
	RMWREG32(addr, startbit, width, val);
  104f5c:	2401      	movs	r4, #1
  104f5e:	fa02 f301 	lsl.w	r3, r2, r1
  104f62:	fa04 f101 	lsl.w	r1, r4, r1
  104f66:	68aa      	ldr	r2, [r5, #8]
  104f68:	ea22 0201 	bic.w	r2, r2, r1
  104f6c:	431a      	orrs	r2, r3
  104f6e:	60aa      	str	r2, [r5, #8]
	return 0;
}
  104f70:	bd38      	pop	{r3, r4, r5, r15}
		pmu_err("check failure\n");
  104f72:	f24d 0120 	movw	r1, #53280	; 0xd020
  104f76:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104f7a:	f240 22c3 	movw	r2, #707	; 0x2c3
  104f7e:	f2c0 0110 	movt	r1, #16
  104f82:	f2c0 0010 	movt	r0, #16
  104f86:	f006 f9a9 	bl	10b2dc <printf>
		return -1;
  104f8a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104f8e:	bd38      	pop	{r3, r4, r5, r15}

00104f90 <pmu_set_por_powerdown_delay>:

int32_t pmu_set_por_powerdown_delay(pmudev_t *dev, int id, int delay)
{
  104f90:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104f92:	6803      	ldr	r3, [r0, #0]
  104f94:	b17b      	cbz	r3, 104fb6 <pmu_set_por_powerdown_delay+0x26>
  104f96:	68c3      	ldr	r3, [r0, #12]
  104f98:	4601      	mov	r1, r0
  104f9a:	b163      	cbz	r3, 104fb6 <pmu_set_por_powerdown_delay+0x26>
  104f9c:	f7ff fa78 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || delay < 0 || delay > 0x7) {
  104fa0:	b948      	cbnz	r0, 104fb6 <pmu_set_por_powerdown_delay+0x26>
  104fa2:	2a07      	cmp	r2, #7
  104fa4:	d807      	bhi.n	104fb6 <pmu_set_por_powerdown_delay+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 11, 3, delay);
  104fa6:	6909      	ldr	r1, [r1, #16]
	RMWREG32(addr, startbit, width, val);
  104fa8:	68cb      	ldr	r3, [r1, #12]
  104faa:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  104fae:	ea43 22c2 	orr.w	r2, r3, r2, lsl #11
  104fb2:	60ca      	str	r2, [r1, #12]
	return 0;
}
  104fb4:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  104fb6:	f24d 0140 	movw	r1, #53312	; 0xd040
  104fba:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  104fbe:	f240 22ce 	movw	r2, #718	; 0x2ce
  104fc2:	f2c0 0110 	movt	r1, #16
  104fc6:	f2c0 0010 	movt	r0, #16
  104fca:	f006 f987 	bl	10b2dc <printf>
		return -1;
  104fce:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  104fd2:	bd08      	pop	{r3, r15}

00104fd4 <pmu_set_por_auto_powerdown>:

int32_t pmu_set_por_auto_powerdown(pmudev_t *dev, int enable)
{
  104fd4:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  104fd6:	6803      	ldr	r3, [r0, #0]
  104fd8:	b17b      	cbz	r3, 104ffa <pmu_set_por_auto_powerdown+0x26>
  104fda:	68c3      	ldr	r3, [r0, #12]
  104fdc:	4602      	mov	r2, r0
  104fde:	b163      	cbz	r3, 104ffa <pmu_set_por_auto_powerdown+0x26>
  104fe0:	f7ff fa56 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)) {
  104fe4:	b948      	cbnz	r0, 104ffa <pmu_set_por_auto_powerdown+0x26>
  104fe6:	2901      	cmp	r1, #1
  104fe8:	d807      	bhi.n	104ffa <pmu_set_por_auto_powerdown+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 10, 1, enable);
  104fea:	6912      	ldr	r2, [r2, #16]
	RMWREG32(addr, startbit, width, val);
  104fec:	68d3      	ldr	r3, [r2, #12]
  104fee:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  104ff2:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
  104ff6:	60d1      	str	r1, [r2, #12]
	return 0;
}
  104ff8:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  104ffa:	f24d 015c 	movw	r1, #53340	; 0xd05c
  104ffe:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  105002:	f240 22d9 	movw	r2, #729	; 0x2d9
  105006:	f2c0 0110 	movt	r1, #16
  10500a:	f2c0 0010 	movt	r0, #16
  10500e:	f006 f965 	bl	10b2dc <printf>
		return -1;
  105012:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  105016:	bd08      	pop	{r3, r15}

00105018 <pmu_set_por_force_powerdown>:

int32_t pmu_set_por_force_powerdown(pmudev_t *dev, int enable)
{
  105018:	b508      	push	{r3, r14}
	if (dev->name == NULL || dev->base_paddr == NULL
  10501a:	6803      	ldr	r3, [r0, #0]
  10501c:	b17b      	cbz	r3, 10503e <pmu_set_por_force_powerdown+0x26>
  10501e:	68c3      	ldr	r3, [r0, #12]
  105020:	4602      	mov	r2, r0
  105022:	b163      	cbz	r3, 10503e <pmu_set_por_force_powerdown+0x26>
  105024:	f7ff fa34 	bl	104490 <pmu_check.part.0>
	if (pmu_check(dev) || (enable != ENABLE && enable != DISABLE)) {
  105028:	b948      	cbnz	r0, 10503e <pmu_set_por_force_powerdown+0x26>
  10502a:	2901      	cmp	r1, #1
  10502c:	d807      	bhi.n	10503e <pmu_set_por_force_powerdown+0x26>
		pmu_err("check failure\n");
		return -1;
	}

	pmu_modify_reg32(dev->base_vaddr + PMU_RST_CTRL, 9, 1, enable);
  10502e:	6912      	ldr	r2, [r2, #16]
	RMWREG32(addr, startbit, width, val);
  105030:	68d3      	ldr	r3, [r2, #12]
  105032:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  105036:	ea43 2141 	orr.w	r1, r3, r1, lsl #9
  10503a:	60d1      	str	r1, [r2, #12]
	return 0;
}
  10503c:	bd08      	pop	{r3, r15}
		pmu_err("check failure\n");
  10503e:	f24d 0178 	movw	r1, #53368	; 0xd078
  105042:	f24d 00c4 	movw	r0, #53444	; 0xd0c4
  105046:	f44f 7239 	mov.w	r2, #740	; 0x2e4
  10504a:	f2c0 0110 	movt	r1, #16
  10504e:	f2c0 0010 	movt	r0, #16
  105052:	f006 f943 	bl	10b2dc <printf>
		return -1;
  105056:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  10505a:	bd08      	pop	{r3, r15}

0010505c <scr_write_signal.isra.4>:
        DBG("Can not get handle for %s\n", signal->name);
        return false;
    }
}

static bool scr_write_signal(const struct scr_signal *signal, uint32_t val)
  10505c:	b570      	push	{r4, r5, r6, r14}
  10505e:	4616      	mov	r6, r2
{
    scr_handle_t handle;

    handle = hal_scr_create_handle(signal->signal);
  105060:	f002 fa7a 	bl	107558 <hal_scr_create_handle>
  105064:	4604      	mov	r4, r0
  105066:	460d      	mov	r5, r1

    if (handle) {
  105068:	ea54 0305 	orrs.w	r3, r4, r5
        hal_scr_delete_handle(handle);
        return ret;
    }
    else {
        DBG("Can not get handle for %s\n", signal->name);
        return false;
  10506c:	bf08      	it	eq
  10506e:	2600      	moveq	r6, #0
    if (handle) {
  105070:	d007      	beq.n	105082 <scr_write_signal.isra.4+0x26>
        bool ret = hal_scr_set(handle, val);
  105072:	4632      	mov	r2, r6
  105074:	f002 faa2 	bl	1075bc <hal_scr_set>
        hal_scr_delete_handle(handle);
  105078:	4629      	mov	r1, r5
        bool ret = hal_scr_set(handle, val);
  10507a:	4606      	mov	r6, r0
        hal_scr_delete_handle(handle);
  10507c:	4620      	mov	r0, r4
  10507e:	f002 fa6d 	bl	10755c <hal_scr_delete_handle>
    }
}
  105082:	4630      	mov	r0, r6
  105084:	bd70      	pop	{r4, r5, r6, r15}
  105086:	bf00      	nop

00105088 <scr_read_signal.isra.5>:
static bool scr_read_signal(const struct scr_signal *signal, uint32_t *val)
  105088:	b570      	push	{r4, r5, r6, r14}
  10508a:	4616      	mov	r6, r2
    handle = hal_scr_create_handle(signal->signal);
  10508c:	f002 fa64 	bl	107558 <hal_scr_create_handle>
  105090:	4604      	mov	r4, r0
  105092:	460d      	mov	r5, r1
    if (handle) {
  105094:	ea54 0305 	orrs.w	r3, r4, r5
        return false;
  105098:	bf08      	it	eq
  10509a:	2000      	moveq	r0, #0
    if (handle) {
  10509c:	d100      	bne.n	1050a0 <scr_read_signal.isra.5+0x18>
}
  10509e:	bd70      	pop	{r4, r5, r6, r15}
        *val = hal_scr_get(handle);
  1050a0:	f002 fa74 	bl	10758c <hal_scr_get>
        hal_scr_delete_handle(handle);
  1050a4:	4629      	mov	r1, r5
        *val = hal_scr_get(handle);
  1050a6:	6030      	str	r0, [r6, #0]
        hal_scr_delete_handle(handle);
  1050a8:	4620      	mov	r0, r4
  1050aa:	f002 fa57 	bl	10755c <hal_scr_delete_handle>
        return true;
  1050ae:	2001      	movs	r0, #1
}
  1050b0:	bd70      	pop	{r4, r5, r6, r15}
  1050b2:	bf00      	nop

001050b4 <Port_SetGPIOSCR>:
    uint32_t pin_num_internal = 0;
    DBG("Port_SetGPIOSCR: gpio_id[%d], pin_num[%d]\n", gpio_id, pin_num);

    /* safety GPIO CTRL base address index NOT follow PinList */
    pin_num_internal =  (((pin_num) <= 47) ? ((pin_num) >= 24 ? ((
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  1050b4:	292f      	cmp	r1, #47	; 0x2f
{
  1050b6:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1050ba:	4605      	mov	r5, r0
  1050bc:	b084      	sub	sp, #16
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  1050be:	d84e      	bhi.n	10515e <Port_SetGPIOSCR+0xaa>
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  1050c0:	f24d 2680 	movw	r6, #53888	; 0xd280
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
  1050c4:	2917      	cmp	r1, #23
  1050c6:	bf8c      	ite	hi
  1050c8:	f1a1 0418 	subhi.w	r4, r1, #24
  1050cc:	f101 0418 	addls.w	r4, r1, #24
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  1050d0:	f2c0 0610 	movt	r6, #16
    uint32_t sigReg_id_mux1 = pin_num / 16;
  1050d4:	0923      	lsrs	r3, r4, #4
  1050d6:	2701      	movs	r7, #1
    scr_read_signal(signal_mux1, &val1_mux1);
  1050d8:	aa02      	add	r2, sp, #8
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
  1050da:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  1050de:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
    scr_read_signal(signal_mux1, &val1_mux1);
  1050e2:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  1050e6:	f7ff ffcf 	bl	105088 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
  1050ea:	2d01      	cmp	r5, #1
  1050ec:	f004 020f 	and.w	r2, r4, #15
  1050f0:	fa07 f702 	lsl.w	r7, r7, r2
  1050f4:	d053      	beq.n	10519e <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
  1050f6:	f24d 28c8 	movw	r8, #53960	; 0xd2c8
    uint32_t sigReg_id = pin_num / 8;
  1050fa:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
  1050fc:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
  1050fe:	f2c0 0810 	movt	r8, #16
  105102:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  105106:	eb08 08c3 	add.w	r8, r8, r3, lsl #3
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  10510a:	3d02      	subs	r5, #2
        scr_read_signal(signal, &val1);
  10510c:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
  105110:	f7ff ffba 	bl	105088 <scr_read_signal.isra.5>
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
  105114:	2003      	movs	r0, #3
  105116:	9b00      	ldr	r3, [sp, #0]
  105118:	f004 0107 	and.w	r1, r4, #7
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  10511c:	9a02      	ldr	r2, [sp, #8]
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
  10511e:	0049      	lsls	r1, r1, #1
  105120:	4088      	lsls	r0, r1
  105122:	ea23 0300 	bic.w	r3, r3, r0
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  105126:	408d      	lsls	r5, r1
  105128:	431d      	orrs	r5, r3
        scr_write_signal(signal, val1);
  10512a:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  10512e:	4317      	orrs	r7, r2
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
  105130:	9500      	str	r5, [sp, #0]
        scr_write_signal(signal, val1);
  105132:	462a      	mov	r2, r5
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
  105134:	9702      	str	r7, [sp, #8]
        scr_write_signal(signal, val1);
  105136:	f7ff ff91 	bl	10505c <scr_write_signal.isra.4>
        scr_read_signal(signal, &val2);
  10513a:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
  10513e:	aa01      	add	r2, sp, #4
  105140:	f7ff ffa2 	bl	105088 <scr_read_signal.isra.5>
  105144:	9a02      	ldr	r2, [sp, #8]
    scr_write_signal(signal_mux1, val1_mux1);
  105146:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  10514a:	f7ff ff87 	bl	10505c <scr_write_signal.isra.4>
    scr_read_signal(signal_mux1, &val2_mux1);
  10514e:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  105152:	aa03      	add	r2, sp, #12
  105154:	f7ff ff98 	bl	105088 <scr_read_signal.isra.5>
        Port_SetSecureGPIOSCR(gpio_id, pin_num_internal);
    }
    else {
        Port_SetSafetyGPIOSCR(gpio_id, pin_num_internal);
    }
}
  105158:	b004      	add	sp, #16
  10515a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    uint32_t tmpPinNum = pin_num - 48;
  10515e:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
  105162:	f24d 3158 	movw	r1, #54104	; 0xd358
    scr_read_signal(signal_mux2, &val1_mux2);
  105166:	aa02      	add	r2, sp, #8
    sigReg_id_mux2 = tmpPinNum / 16;
  105168:	0923      	lsrs	r3, r4, #4
  10516a:	2701      	movs	r7, #1
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
  10516c:	f2c0 0110 	movt	r1, #16
  105170:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  105174:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
    scr_read_signal(signal_mux2, &val1_mux2);
  105178:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
  10517c:	f7ff ff84 	bl	105088 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
  105180:	2d01      	cmp	r5, #1
  105182:	f004 020f 	and.w	r2, r4, #15
  105186:	fa07 f702 	lsl.w	r7, r7, r2
  10518a:	d008      	beq.n	10519e <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
  10518c:	f24d 4800 	movw	r8, #54272	; 0xd400
    sigReg_id = tmpPinNum / 8;
  105190:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
  105192:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
  105194:	f2c0 0810 	movt	r8, #16
  105198:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  10519c:	e7b3      	b.n	105106 <Port_SetGPIOSCR+0x52>
        val1_mux1 &= (~ (uint32_t)(0x1 << (pin_num % 16))); /* set to 0 */
  10519e:	9a02      	ldr	r2, [sp, #8]
  1051a0:	ea22 0207 	bic.w	r2, r2, r7
  1051a4:	9202      	str	r2, [sp, #8]
  1051a6:	e7ce      	b.n	105146 <Port_SetGPIOSCR+0x92>

001051a8 <Port_Init>:
    Port_kConfigPtr = ConfigPtr;
  1051a8:	f247 0350 	movw	r3, #28752	; 0x7050
  1051ac:	f240 1201 	movw	r2, #257	; 0x101
  1051b0:	f2c0 0311 	movt	r3, #17
{
  1051b4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    Port_kConfigPtr = ConfigPtr;
  1051b8:	4619      	mov	r1, r3
{
  1051ba:	b08b      	sub	sp, #44	; 0x2c
  1051bc:	f24d 1448 	movw	r4, #53576	; 0xd148
    Port_kConfigPtr = ConfigPtr;
  1051c0:	f2c0 0214 	movt	r2, #20
  1051c4:	9307      	str	r3, [sp, #28]
  1051c6:	f2c0 0410 	movt	r4, #16
  1051ca:	f44f 7380 	mov.w	r3, #256	; 0x100
  1051ce:	f504 759c 	add.w	r5, r4, #312	; 0x138
  1051d2:	6008      	str	r0, [r1, #0]
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
        const struct scr_signal *signal = &scr_mshc2_canfd_signals[i];

        if (scr_read_signal(signal, &val1)) {
            scr_write_signal(signal,
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  1051d4:	2601      	movs	r6, #1
  1051d6:	e004      	b.n	1051e2 <Port_Init+0x3a>
  1051d8:	3418      	adds	r4, #24
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
  1051da:	42a5      	cmp	r5, r4
  1051dc:	d01a      	beq.n	105214 <Port_Init+0x6c>
  1051de:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
        if (scr_read_signal(signal, &val1)) {
  1051e2:	4610      	mov	r0, r2
  1051e4:	4619      	mov	r1, r3
  1051e6:	aa08      	add	r2, sp, #32
  1051e8:	f7ff ff4e 	bl	105088 <scr_read_signal.isra.5>
  1051ec:	2800      	cmp	r0, #0
  1051ee:	d0f3      	beq.n	1051d8 <Port_Init+0x30>
    return (uint32_t)(scr_signal >> 8) & 0xff;
}

static inline uint32_t _scr_width(scr_signal_t scr_signal)
{
    return (uint32_t)scr_signal & 0xff;
  1051f0:	7a23      	ldrb	r3, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  1051f2:	6922      	ldr	r2, [r4, #16]
  1051f4:	fa06 f303 	lsl.w	r3, r6, r3
            scr_write_signal(signal,
  1051f8:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
  1051fc:	3b01      	subs	r3, #1
            scr_write_signal(signal,
  1051fe:	401a      	ands	r2, r3
  105200:	f7ff ff2c 	bl	10505c <scr_write_signal.isra.4>
            scr_read_signal(signal, &val2);
  105204:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
  105208:	aa09      	add	r2, sp, #36	; 0x24
  10520a:	3418      	adds	r4, #24
  10520c:	f7ff ff3c 	bl	105088 <scr_read_signal.isra.5>
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
  105210:	42a5      	cmp	r5, r4
  105212:	d1e4      	bne.n	1051de <Port_Init+0x36>
  105214:	f641 73f8 	movw	r3, #8184	; 0x1ff8
  105218:	f247 0a54 	movw	r10, #28756	; 0x7054
  10521c:	2200      	movs	r2, #0
  10521e:	f2c0 0311 	movt	r3, #17
  105222:	f641 79f4 	movw	r9, #8180	; 0x1ff4
  105226:	f2c0 0a11 	movt	r10, #17
  10522a:	f24d 1b30 	movw	r11, #53552	; 0xd130
  10522e:	f2c0 0911 	movt	r9, #17
  105232:	9304      	str	r3, [sp, #16]
    writel(value, vaddr);
  105234:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
  105238:	9303      	str	r3, [sp, #12]
  10523a:	4653      	mov	r3, r10
  10523c:	9202      	str	r2, [sp, #8]
  10523e:	f6cf 4153 	movt	r1, #64595	; 0xfc53
  105242:	46ca      	mov	r10, r9
  105244:	f2c0 0b10 	movt	r11, #16
  105248:	9106      	str	r1, [sp, #24]
  10524a:	4691      	mov	r9, r2
  10524c:	461a      	mov	r2, r3
            PortNumber++) {

        DBG("Port[%d]\n", PortNumber);

        if (Port_lIsPortAvailable(PortNumber) != (uint32_t)0U) {
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
  10524e:	9b07      	ldr	r3, [sp, #28]
  105250:	ea4f 1809 	mov.w	r8, r9, lsl #4
  105254:	9902      	ldr	r1, [sp, #8]
  105256:	464c      	mov	r4, r9
  105258:	f8cd 9004 	str.w	r9, [r13, #4]

            /* Address of each port configuration */
            DataPtr = (const uint32_t *)(const void *)(ConfigDataPtr);

            /* for each pin in one port */
            for (PinNumber = (uint32_t)0U;
  10525c:	2600      	movs	r6, #0
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
  10525e:	681b      	ldr	r3, [r3, #0]
  105260:	4691      	mov	r9, r2
  105262:	9f03      	ldr	r7, [sp, #12]
  105264:	681b      	ldr	r3, [r3, #0]
  105266:	440b      	add	r3, r1
  105268:	461d      	mov	r5, r3
  10526a:	9305      	str	r3, [sp, #20]
  10526c:	e05e      	b.n	10532c <Port_Init+0x184>
  10526e:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
  105270:	2ca0      	cmp	r4, #160	; 0xa0
  105272:	d065      	beq.n	105340 <Port_Init+0x198>
    if (pin >= PORT_PIN_CNT)
  105274:	2c9b      	cmp	r4, #155	; 0x9b
    writel(value, vaddr);
  105276:	bf84      	itt	hi
  105278:	2300      	movhi	r3, #0
  10527a:	6018      	strhi	r0, [r3, #0]
    if (pin >= PORT_PIN_CNT)
  10527c:	d811      	bhi.n	1052a2 <Port_Init+0xfa>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10527e:	2c2f      	cmp	r4, #47	; 0x2f
  105280:	8839      	ldrh	r1, [r7, #0]
  105282:	887b      	ldrh	r3, [r7, #2]
  105284:	ea4f 2181 	mov.w	r1, r1, lsl #10
  105288:	ea4f 2383 	mov.w	r3, r3, lsl #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  10528c:	bf96      	itet	ls
  10528e:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  105292:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  105296:	f1a3 736c 	subls.w	r3, r3, #61865984	; 0x3b00000
    writel(value, vaddr);
  10529a:	6008      	str	r0, [r1, #0]
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  10529c:	bf88      	it	hi
  10529e:	f1a3 63f6 	subhi.w	r3, r3, #128974848	; 0x7b00000
                IOPadAddr = getIOPadAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + PinNumber)), IOPadAddr);

                /* setup PIN_MUX_CONFIG, and INPUT_SOURCE_SELECT if needed */
                PinMuxAddr  = getPinMuxAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + 32 + PinNumber)), PinMuxAddr);
  1052a2:	f8d5 1080 	ldr.w	r1, [r5, #128]	; 0x80
    writel(value, vaddr);
  1052a6:	6019      	str	r1, [r3, #0]

                /* get MUX_MODE */
                RegVal = (uint32_t)(*(DataPtr + 32 + PinNumber)) & 0x7;
  1052a8:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80

                if (RegVal == PORT_PIN_MODE_GPIO) {
  1052ac:	f013 0307 	ands.w	r3, r3, #7
  1052b0:	d12e      	bne.n	105310 <Port_Init+0x168>
                    /* Non-EMMC pins GPIO Setup */
                    /* GPIO/DIO mode, do DIO Init */

                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
  1052b2:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
  1052b6:	e9d9 0302 	ldrd	r0, r3, [r9, #8]
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
  1052ba:	0c0a      	lsrs	r2, r1, #16
                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
  1052bc:	fa1f fc81 	uxth.w	r12, r1
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
  1052c0:	d15f      	bne.n	105382 <Port_Init+0x1da>

LOCAL_INLINE vaddr_t getGPIOAddr(uint32_t gpio_index)
{
    vaddr_t gpio_addr;

    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  1052c2:	459c      	cmp	r12, r3
  1052c4:	d00d      	beq.n	1052e2 <Port_Init+0x13a>
        return getGPIOBaseAddr();
    }

    if (PORT_GPIO_1 == gpio_index) {
  1052c6:	f1bc 0f01 	cmp.w	r12, #1
  1052ca:	f000 80b6 	beq.w	10543a <Port_Init+0x292>
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  1052ce:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
                + (gpio_index - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else {
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1052d0:	bf13      	iteet	ne
  1052d2:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  1052d6:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  1052da:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1052de:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  1052e2:	9b01      	ldr	r3, [sp, #4]
  1052e4:	18f3      	adds	r3, r6, r3
                        iomux_write(0x00, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  1052e6:	2b2f      	cmp	r3, #47	; 0x2f
  1052e8:	bf88      	it	hi
  1052ea:	4643      	movhi	r3, r8
  1052ec:	d805      	bhi.n	1052fa <Port_Init+0x152>
  1052ee:	2b17      	cmp	r3, #23
  1052f0:	bf8c      	ite	hi
  1052f2:	f5a8 73c0 	subhi.w	r3, r8, #384	; 0x180
  1052f6:	f508 73c0 	addls.w	r3, r8, #384	; 0x180
    writel(value, vaddr);
  1052fa:	2200      	movs	r2, #0
  1052fc:	501a      	str	r2, [r3, r0]
                    Port_SetGPIOSCR((uint32_t)(*(DataPtr + 64 + PinNumber)) & 0xffff,
  1052fe:	4621      	mov	r1, r4
  105300:	f8b5 0100 	ldrh.w	r0, [r5, #256]	; 0x100
  105304:	f7ff fed6 	bl	1050b4 <Port_SetGPIOSCR>
  105308:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
  10530c:	f003 0307 	and.w	r3, r3, #7
    if (pin >= PORT_PIN_CNT)
  105310:	2c9b      	cmp	r4, #155	; 0x9b
  105312:	d919      	bls.n	105348 <Port_Init+0x1a0>
            for (PinNumber = (uint32_t)0U;
  105314:	f8db 3000 	ldr.w	r3, [r11]
                    PinNumber <= (uint32_t)PIN_MAX_NUMBER[PortNumber]; PinNumber++) {
  105318:	3601      	adds	r6, #1
  10531a:	3401      	adds	r4, #1
            for (PinNumber = (uint32_t)0U;
  10531c:	429e      	cmp	r6, r3
  10531e:	f105 0504 	add.w	r5, r5, #4
  105322:	f108 0810 	add.w	r8, r8, #16
  105326:	f107 0744 	add.w	r7, r7, #68	; 0x44
  10532a:	d852      	bhi.n	1053d2 <Port_Init+0x22a>
                if (((run_in_domain == PORT_RUN_IN_SECURE) || (run_in_domain == PORT_RUN_IN_AP)) && (PortNumber * 32 + PinNumber) <= 47)
  10532c:	f8da 3000 	ldr.w	r3, [r10]
  105330:	3b01      	subs	r3, #1
  105332:	2b01      	cmp	r3, #1
  105334:	d89b      	bhi.n	10526e <Port_Init+0xc6>
  105336:	2c2f      	cmp	r4, #47	; 0x2f
  105338:	d9ec      	bls.n	105314 <Port_Init+0x16c>
  10533a:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
  10533c:	2ca0      	cmp	r4, #160	; 0xa0
  10533e:	d199      	bne.n	105274 <Port_Init+0xcc>
    writel(value, vaddr);
  105340:	9b06      	ldr	r3, [sp, #24]
  105342:	6018      	str	r0, [r3, #0]
  105344:	2300      	movs	r3, #0
  105346:	e7ac      	b.n	1052a2 <Port_Init+0xfa>
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  105348:	0120      	lsls	r0, r4, #4
  10534a:	1901      	adds	r1, r0, r4
  10534c:	9a04      	ldr	r2, [sp, #16]
  10534e:	00db      	lsls	r3, r3, #3
  105350:	eb03 0181 	add.w	r1, r3, r1, lsl #2
  105354:	4411      	add	r1, r2
  105356:	88c9      	ldrh	r1, [r1, #6]
  105358:	2900      	cmp	r1, #0
  10535a:	d0db      	beq.n	105314 <Port_Init+0x16c>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10535c:	9a01      	ldr	r2, [sp, #4]
  10535e:	0289      	lsls	r1, r1, #10
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  105360:	4420      	add	r0, r4
    if (pin < IOMUXC_SAF_PIN_NUM)
  105362:	eb06 0c02 	add.w	r12, r6, r2
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  105366:	9a04      	ldr	r2, [sp, #16]
    if (pin < IOMUXC_SAF_PIN_NUM)
  105368:	f1bc 0f2f 	cmp.w	r12, #47	; 0x2f
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
  10536c:	bf94      	ite	ls
  10536e:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
  105372:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  105376:	eb03 0380 	add.w	r3, r3, r0, lsl #2
  10537a:	4413      	add	r3, r2
  10537c:	895b      	ldrh	r3, [r3, #10]
    writel(value, vaddr);
  10537e:	600b      	str	r3, [r1, #0]
  105380:	e7c8      	b.n	105314 <Port_Init+0x16c>
                        if ((uint32_t)(*(DataPtr + 96)) & (0x01 << PinNumber)) {
  105382:	9a05      	ldr	r2, [sp, #20]
  105384:	f04f 0e01 	mov.w	r14, #1
  105388:	fa0e fe06 	lsl.w	r14, r14, r6
  10538c:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
  105390:	ea1e 0f01 	tst.w	r14, r1
  105394:	d033      	beq.n	1053fe <Port_Init+0x256>
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  105396:	459c      	cmp	r12, r3
  105398:	d00c      	beq.n	1053b4 <Port_Init+0x20c>
    if (PORT_GPIO_1 == gpio_index) {
  10539a:	f1bc 0f01 	cmp.w	r12, #1
  10539e:	d05c      	beq.n	10545a <Port_Init+0x2b2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  1053a0:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1053a2:	bf13      	iteet	ne
  1053a4:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  1053a8:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  1053ac:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  1053b0:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  1053b4:	9b01      	ldr	r3, [sp, #4]
  1053b6:	18f3      	adds	r3, r6, r3
                            iomux_write(0x05, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  1053b8:	2b2f      	cmp	r3, #47	; 0x2f
  1053ba:	bf88      	it	hi
  1053bc:	4641      	movhi	r1, r8
  1053be:	d805      	bhi.n	1053cc <Port_Init+0x224>
  1053c0:	2b17      	cmp	r3, #23
  1053c2:	bf8c      	ite	hi
  1053c4:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
  1053c8:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
  1053cc:	2305      	movs	r3, #5
  1053ce:	500b      	str	r3, [r1, r0]
  1053d0:	e795      	b.n	1052fe <Port_Init+0x156>
  1053d2:	9b02      	ldr	r3, [sp, #8]
  1053d4:	464a      	mov	r2, r9
  1053d6:	f8dd 9004 	ldr.w	r9, [r13, #4]
  1053da:	f10b 0b04 	add.w	r11, r11, #4
  1053de:	f503 73c4 	add.w	r3, r3, #392	; 0x188
  1053e2:	f109 0920 	add.w	r9, r9, #32
  1053e6:	9302      	str	r3, [sp, #8]
    for (PortNumber = (uint32_t)0U; PortNumber <= (uint32_t)PORT_MAX_NUMBER;
  1053e8:	f1b9 0fa0 	cmp.w	r9, #160	; 0xa0
  1053ec:	9b03      	ldr	r3, [sp, #12]
  1053ee:	f503 6308 	add.w	r3, r3, #2176	; 0x880
  1053f2:	9303      	str	r3, [sp, #12]
  1053f4:	f47f af2b 	bne.w	10524e <Port_Init+0xa6>
}/* Port_Init */
  1053f8:	b00b      	add	sp, #44	; 0x2c
  1053fa:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
  1053fe:	459c      	cmp	r12, r3
  105400:	d00c      	beq.n	10541c <Port_Init+0x274>
    if (PORT_GPIO_1 == gpio_index) {
  105402:	f1bc 0f01 	cmp.w	r12, #1
  105406:	d020      	beq.n	10544a <Port_Init+0x2a2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
  105408:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  10540a:	bf13      	iteet	ne
  10540c:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
  105410:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
  105414:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
  105418:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
  10541c:	9b01      	ldr	r3, [sp, #4]
  10541e:	18f3      	adds	r3, r6, r3
                            iomux_write(0x01, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
  105420:	2b2f      	cmp	r3, #47	; 0x2f
  105422:	bf88      	it	hi
  105424:	4641      	movhi	r1, r8
  105426:	d805      	bhi.n	105434 <Port_Init+0x28c>
  105428:	2b17      	cmp	r3, #23
  10542a:	bf8c      	ite	hi
  10542c:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
  105430:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
  105434:	2301      	movs	r3, #1
  105436:	500b      	str	r3, [r1, r0]
  105438:	e761      	b.n	1052fe <Port_Init+0x156>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10543a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10543e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  105440:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  105444:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  105448:	e74b      	b.n	1052e2 <Port_Init+0x13a>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10544a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10544e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  105450:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  105454:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  105458:	e7e0      	b.n	10541c <Port_Init+0x274>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
  10545a:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
  10545e:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
  105460:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
  105464:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
  105468:	e7a4      	b.n	1053b4 <Port_Init+0x20c>
  10546a:	bf00      	nop

0010546c <Port_SetPinMode>:
{
  10546c:	b4f0      	push	{r4, r5, r6, r7}
  10546e:	b082      	sub	sp, #8
  105470:	ab02      	add	r3, sp, #8
    if (PortConf_PIN_GPIO_SAF == pin)
  105472:	28a0      	cmp	r0, #160	; 0xa0
{
  105474:	e903 0006 	stmdb	r3, {r1, r2}
  105478:	9d01      	ldr	r5, [sp, #4]
    if (PortConf_PIN_GPIO_SAF == pin)
  10547a:	d029      	beq.n	1054d0 <Port_SetPinMode+0x64>
    if (pin >= PORT_PIN_CNT)
  10547c:	289b      	cmp	r0, #155	; 0x9b
  10547e:	d902      	bls.n	105486 <Port_SetPinMode+0x1a>
}/* Port_SetPinMode */
  105480:	b002      	add	sp, #8
  105482:	bcf0      	pop	{r4, r5, r6, r7}
  105484:	4770      	bx	r14
  105486:	f641 71f8 	movw	r1, #8184	; 0x1ff8
  10548a:	0104      	lsls	r4, r0, #4
  10548c:	1823      	adds	r3, r4, r0
    if (pin < IOMUXC_SAF_PIN_NUM)
  10548e:	282f      	cmp	r0, #47	; 0x2f
  105490:	ea4f 0383 	mov.w	r3, r3, lsl #2
  105494:	f2c0 0111 	movt	r1, #17
  105498:	5ace      	ldrh	r6, [r1, r3]
  10549a:	eb01 0203 	add.w	r2, r1, r3
  10549e:	ea4f 2686 	mov.w	r6, r6, lsl #10
  1054a2:	d91e      	bls.n	1054e2 <Port_SetPinMode+0x76>
    AltNum = (uint32_t)Mode.pin_mux_config & 0x00000007;
  1054a4:	f005 0707 	and.w	r7, r5, #7
  1054a8:	8852      	ldrh	r2, [r2, #2]
  1054aa:	0292      	lsls	r2, r2, #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  1054ac:	f1a6 6cf6 	sub.w	r12, r6, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  1054b0:	f1a2 62f6 	sub.w	r2, r2, #128974848	; 0x7b00000
        iomux_write(Mode.io_pad_config, IOPadAddr);
  1054b4:	9e00      	ldr	r6, [sp, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  1054b6:	00ff      	lsls	r7, r7, #3
    writel(value, vaddr);
  1054b8:	f8cc 6000 	str.w	r6, [r12]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  1054bc:	443b      	add	r3, r7
    writel(value, vaddr);
  1054be:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  1054c0:	440b      	add	r3, r1
  1054c2:	88db      	ldrh	r3, [r3, #6]
  1054c4:	2b00      	cmp	r3, #0
  1054c6:	d0db      	beq.n	105480 <Port_SetPinMode+0x14>
  1054c8:	029b      	lsls	r3, r3, #10
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
  1054ca:	f1a3 63f6 	sub.w	r3, r3, #128974848	; 0x7b00000
  1054ce:	e024      	b.n	10551a <Port_SetPinMode+0xae>
        iomux_write(Mode.io_pad_config, IOPadAddr);
  1054d0:	9a00      	ldr	r2, [sp, #0]
    writel(value, vaddr);
  1054d2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
  1054d6:	f6cf 4353 	movt	r3, #64595	; 0xfc53
  1054da:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  1054dc:	b002      	add	sp, #8
  1054de:	bcf0      	pop	{r4, r5, r6, r7}
  1054e0:	4770      	bx	r14
    if (IOPadAddr)
  1054e2:	f1b6 766c 	subs.w	r6, r6, #61865984	; 0x3b00000
  1054e6:	bf0f      	iteee	eq
  1054e8:	8852      	ldrheq	r2, [r2, #2]
  1054ea:	2344      	movne	r3, #68	; 0x44
        iomux_write(Mode.io_pad_config, IOPadAddr);
  1054ec:	9f00      	ldrne	r7, [sp, #0]
  1054ee:	fb03 1300 	mlane	r3, r3, r0, r1
  1054f2:	bf1c      	itt	ne
  1054f4:	885a      	ldrhne	r2, [r3, #2]
    writel(value, vaddr);
  1054f6:	6037      	strne	r7, [r6, #0]
  1054f8:	f005 0707 	and.w	r7, r5, #7
  1054fc:	0292      	lsls	r2, r2, #10
  1054fe:	1823      	adds	r3, r4, r0
  105500:	00ff      	lsls	r7, r7, #3
    if (PinMuxAddr)
  105502:	f1b2 726c 	subs.w	r2, r2, #61865984	; 0x3b00000
  105506:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  10550a:	440b      	add	r3, r1
  10550c:	88db      	ldrh	r3, [r3, #6]
  10550e:	d10d      	bne.n	10552c <Port_SetPinMode+0xc0>
  105510:	029a      	lsls	r2, r3, #10
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  105512:	2b00      	cmp	r3, #0
  105514:	d0b4      	beq.n	105480 <Port_SetPinMode+0x14>
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
  105516:	f1a2 736c 	sub.w	r3, r2, #61865984	; 0x3b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  10551a:	4420      	add	r0, r4
  10551c:	eb07 0780 	add.w	r7, r7, r0, lsl #2
  105520:	4439      	add	r1, r7
  105522:	894a      	ldrh	r2, [r1, #10]
    writel(value, vaddr);
  105524:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  105526:	b002      	add	sp, #8
  105528:	bcf0      	pop	{r4, r5, r6, r7}
  10552a:	4770      	bx	r14
    writel(value, vaddr);
  10552c:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  10552e:	2344      	movs	r3, #68	; 0x44
  105530:	fb03 7300 	mla	r3, r3, r0, r7
  105534:	440b      	add	r3, r1
  105536:	88db      	ldrh	r3, [r3, #6]
  105538:	2b00      	cmp	r3, #0
  10553a:	d0a1      	beq.n	105480 <Port_SetPinMode+0x14>
    if (pin < IOMUXC_SAF_PIN_NUM)
  10553c:	282f      	cmp	r0, #47	; 0x2f
  10553e:	ea4f 2283 	mov.w	r2, r3, lsl #10
  105542:	4613      	mov	r3, r2
  105544:	d8c1      	bhi.n	1054ca <Port_SetPinMode+0x5e>
  105546:	e7e6      	b.n	105516 <Port_SetPinMode+0xaa>

00105548 <Port_SetHandle>:
    if (handle != NULL) {
  105548:	b1a0      	cbz	r0, 105574 <Port_SetHandle+0x2c>
        g_port_handle.phy_addr = p_handle->phy_addr;
  10554a:	f247 0354 	movw	r3, #28756	; 0x7054
        run_in_domain = PORT_RUN_IN_SAFETY;
  10554e:	f641 72f4 	movw	r2, #8180	; 0x1ff4
        g_port_handle.phy_addr = p_handle->phy_addr;
  105552:	f2c0 0311 	movt	r3, #17
{
  105556:	b430      	push	{r4, r5}
        run_in_domain = PORT_RUN_IN_SAFETY;
  105558:	2100      	movs	r1, #0
  10555a:	f2c0 0211 	movt	r2, #17
        g_port_handle.real_idx = p_handle->real_idx;
  10555e:	e9d0 4500 	ldrd	r4, r5, [r0]
        g_port_handle.phy_addr = p_handle->phy_addr;
  105562:	601c      	str	r4, [r3, #0]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  105564:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
        g_port_handle.dio_phy_addr = p_handle->dio_phy_addr;
  105568:	e9c3 5401 	strd	r5, r4, [r3, #4]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  10556c:	60d8      	str	r0, [r3, #12]
        run_in_domain = PORT_RUN_IN_SAFETY;
  10556e:	6011      	str	r1, [r2, #0]
}
  105570:	bc30      	pop	{r4, r5}
  105572:	4770      	bx	r14
  105574:	4770      	bx	r14
  105576:	bf00      	nop

00105578 <rstgen_get_default_config>:
//! \return
//
//*****************************************************************************
void rstgen_get_default_config(uint32_t *global_rst_maks)
{
    if (!global_rst_maks) {
  105578:	b108      	cbz	r0, 10557e <rstgen_get_default_config+0x6>
        LTRACEF("config paramenter error !!\n");
        return;
    }

    *global_rst_maks = RSTGEN_GLB_RST_SELF_RST_EN(1)
  10557a:	2307      	movs	r3, #7
  10557c:	6003      	str	r3, [r0, #0]
                       | RSTGEN_GLB_RST_SEM_RST_EN(1)
                       | RSTGEN_GLB_RST_DBG_RST_EN(1);

    LTRACEF("rstgen_get_default_config global_rst_maks:0x%x\n", *global_rst_maks);
}
  10557e:	4770      	bx	r14

00105580 <rstgen_init>:
//! \return Returns \b true if the wdg timer is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool rstgen_init(vaddr_t base, const uint32_t global_rst_maks)
{
  105580:	b470      	push	{r4, r5, r6}
  105582:	4604      	mov	r4, r0
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);

    //clear all global register
    reg_write = 0x00000000;
    writel(reg_write, base);
  105584:	2300      	movs	r3, #0
    reg_read = readl(base);
    reg_write = reg_read | rstgen_global_cfg;
    writel(reg_write, base);

    return true;
}
  105586:	2001      	movs	r0, #1
    writel(reg_write, base);
  105588:	6023      	str	r3, [r4, #0]
    uint32_t rstgen_global_cfg = RSTGEN_GLB_RST_SELF_RST_EN(global_rst_maks)
  10558a:	ea01 0200 	and.w	r2, r1, r0
    reg_read = readl(base);
  10558e:	6825      	ldr	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  105590:	fa01 f300 	lsl.w	r3, r1, r0
    reg_write = reg_read & (~RSTGEN_GLB_RST_LOCK_MASK);
  105594:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  105598:	f003 0302 	and.w	r3, r3, #2
    writel(reg_write, base);
  10559c:	6025      	str	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  10559e:	008d      	lsls	r5, r1, #2
    reg_read = readl(base);
  1055a0:	6826      	ldr	r6, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  1055a2:	f005 0504 	and.w	r5, r5, #4
    reg_write = reg_read | rstgen_global_cfg;
  1055a6:	4332      	orrs	r2, r6
  1055a8:	4313      	orrs	r3, r2
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  1055aa:	00ca      	lsls	r2, r1, #3
    reg_write = reg_read | rstgen_global_cfg;
  1055ac:	ea43 0105 	orr.w	r1, r3, r5
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  1055b0:	f002 0308 	and.w	r3, r2, #8
    reg_write = reg_read | rstgen_global_cfg;
  1055b4:	4319      	orrs	r1, r3
    writel(reg_write, base);
  1055b6:	6021      	str	r1, [r4, #0]
}
  1055b8:	bc70      	pop	{r4, r5, r6}
  1055ba:	4770      	bx	r14

001055bc <rstgen_global_rst_enable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_enable(vaddr_t base, uint32_t mask)
{
  1055bc:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val |= mask;
    writel(val, global_rst_en);

    return true;
}
  1055be:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  1055c0:	681a      	ldr	r2, [r3, #0]
  1055c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  1055c6:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  1055c8:	681a      	ldr	r2, [r3, #0]
    val |= mask;
  1055ca:	4311      	orrs	r1, r2
    writel(val, global_rst_en);
  1055cc:	6019      	str	r1, [r3, #0]
}
  1055ce:	4770      	bx	r14

001055d0 <rstgen_global_rst_disable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_disable(vaddr_t base, uint32_t mask)
{
  1055d0:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val &= ~mask;
    writel(val, global_rst_en);

    return true;
}
  1055d2:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  1055d4:	681a      	ldr	r2, [r3, #0]
  1055d6:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  1055da:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  1055dc:	681a      	ldr	r2, [r3, #0]
    val &= ~mask;
  1055de:	ea22 0101 	bic.w	r1, r2, r1
    writel(val, global_rst_en);
  1055e2:	6019      	str	r1, [r3, #0]
}
  1055e4:	4770      	bx	r14
  1055e6:	bf00      	nop

001055e8 <rstgen_sw_self_rst>:
// RSTGEN_SEC: ap.self_rst_trig reset the AP domain (sec & ap)
//
//*****************************************************************************
bool rstgen_sw_self_rst(vaddr_t base, bool release)
{
    vaddr_t sw_self_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_SELF_RST_OFF);
  1055e8:	f500 3288 	add.w	r2, r0, #69632	; 0x11000

    /* Configure rst bit. */
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  1055ec:	2001      	movs	r0, #1
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  1055ee:	6813      	ldr	r3, [r2, #0]
  1055f0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  1055f4:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  1055f6:	6813      	ldr	r3, [r2, #0]
  1055f8:	f023 0301 	bic.w	r3, r3, #1
  1055fc:	4319      	orrs	r1, r3
  1055fe:	6011      	str	r1, [r2, #0]
}
  105600:	4770      	bx	r14
  105602:	bf00      	nop

00105604 <rstgen_sw_oth_rst>:
// RSTGEN_RTC and RSTGEN_SEC: oth reset has no effect
//
//*****************************************************************************
bool rstgen_sw_oth_rst(vaddr_t base, bool release)
{
    vaddr_t sw_oth_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_OTH_RST_OFF);
  105604:	f500 3290 	add.w	r2, r0, #73728	; 0x12000

    /* Configure rst bit. */
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  105608:	2001      	movs	r0, #1
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  10560a:	6813      	ldr	r3, [r2, #0]
  10560c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  105610:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  105612:	6813      	ldr	r3, [r2, #0]
  105614:	f023 0301 	bic.w	r3, r3, #1
  105618:	4319      	orrs	r1, r3
  10561a:	6011      	str	r1, [r2, #0]
}
  10561c:	4770      	bx	r14
  10561e:	bf00      	nop

00105620 <rstgen_get_rst_sta>:
uint32_t rstgen_get_rst_sta(vaddr_t base)
{
    vaddr_t rst_sta_addr;
    uint32_t rstgen_rst_sta = 0;

    rst_sta_addr = base + SOC_RSTGEN_REG_MAP(RSTGEN_RST_STA_OFF);
  105620:	f500 3098 	add.w	r0, r0, #77824	; 0x13000

    rstgen_rst_sta = readl(rst_sta_addr);
  105624:	6800      	ldr	r0, [r0, #0]
    LTRACEF("rstgen_get_rst_sta rst_sta:0x%x\n", rstgen_rst_sta);
    return rstgen_rst_sta;
}
  105626:	4770      	bx	r14

00105628 <rstgen_iso_enable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_enable(vaddr_t base, uint32_t iso_idx)
{
  105628:	4603      	mov	r3, r0
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  10562a:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_enable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);

    return true;
}
  10562c:	2001      	movs	r0, #1
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);
  10562e:	f06f 0201 	mvn.w	r2, #1
  105632:	50ca      	str	r2, [r1, r3]
}
  105634:	4770      	bx	r14
  105636:	bf00      	nop

00105638 <rstgen_iso_status>:
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  105638:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_status is ok iso_slice_idx:%d\n", iso_slice_idx);
    return readl(iso_addr) & RSTGEN_ISO_EN_B_MASK;
  10563a:	5808      	ldr	r0, [r1, r0]
}
  10563c:	f000 0001 	and.w	r0, r0, #1
  105640:	4770      	bx	r14
  105642:	bf00      	nop

00105644 <rstgen_iso_disable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_disable(vaddr_t base, uint32_t iso_idx)
{
  105644:	4602      	mov	r2, r0

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
    LTRACEF("rstgen_iso_disable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  105646:	2301      	movs	r3, #1

    return true;
}
  105648:	4618      	mov	r0, r3
    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  10564a:	0309      	lsls	r1, r1, #12
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  10564c:	508b      	str	r3, [r1, r2]
}
  10564e:	4770      	bx	r14

00105650 <rstgen_core_reset>:
// sure there's no active bus transaction on the core.
//
//*****************************************************************************
bool rstgen_core_reset(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  105650:	0849      	lsrs	r1, r1, #1
{
  105652:	b430      	push	{r4, r5}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  105654:	034c      	lsls	r4, r1, #13
  105656:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000
  10565a:	1825      	adds	r5, r4, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  10565c:	5823      	ldr	r3, [r4, r0]
  10565e:	2b00      	cmp	r3, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  105660:	bfb8      	it	lt
  105662:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  105664:	db17      	blt.n	105696 <rstgen_core_reset+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  105666:	0349      	lsls	r1, r1, #13
  105668:	180b      	adds	r3, r1, r0
    }

    /* Release STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, 1);
  10566a:	580a      	ldr	r2, [r1, r0]
  10566c:	f042 0201 	orr.w	r2, r2, #1
  105670:	500a      	str	r2, [r1, r0]
    while (!(readl(core_sw_rst) &
  105672:	681a      	ldr	r2, [r3, #0]
  105674:	0092      	lsls	r2, r2, #2
  105676:	d5fc      	bpl.n	105672 <rstgen_core_reset+0x22>
                 RSTGEN_CORE_SW_RST_STATIC_RST_B_STA_MASK));

    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  105678:	5822      	ldr	r2, [r4, r0]
  10567a:	f042 0201 	orr.w	r2, r2, #1
  10567e:	5022      	str	r2, [r4, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  105680:	682a      	ldr	r2, [r5, #0]
  105682:	0054      	lsls	r4, r2, #1
  105684:	d5fc      	bpl.n	105680 <rstgen_core_reset+0x30>
    /* Trigger auto-clear reset. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_AUTO_CLR_SHIFT, 1, 1);
  105686:	580a      	ldr	r2, [r1, r0]
  105688:	f042 0202 	orr.w	r2, r2, #2
  10568c:	500a      	str	r2, [r1, r0]

    /* Polling reset status */
    while (!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK));
  10568e:	681a      	ldr	r2, [r3, #0]
  105690:	0052      	lsls	r2, r2, #1
  105692:	d5fc      	bpl.n	10568e <rstgen_core_reset+0x3e>

    return true;
  105694:	2001      	movs	r0, #1
}
  105696:	bc30      	pop	{r4, r5}
  105698:	4770      	bx	r14
  10569a:	bf00      	nop

0010569c <rstgen_core_ctl>:
//
//*****************************************************************************
bool rstgen_core_ctl(vaddr_t base, uint32_t core_idx,
                               bool release)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  10569c:	0849      	lsrs	r1, r1, #1
{
  10569e:	b470      	push	{r4, r5, r6}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  1056a0:	034b      	lsls	r3, r1, #13
  1056a2:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
  1056a6:	181c      	adds	r4, r3, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  1056a8:	581d      	ldr	r5, [r3, r0]
  1056aa:	2d00      	cmp	r5, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  1056ac:	bfb8      	it	lt
  1056ae:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  1056b0:	db17      	blt.n	1056e2 <rstgen_core_ctl+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  1056b2:	0349      	lsls	r1, r1, #13
  1056b4:	180d      	adds	r5, r1, r0
    }
    /* Check core SW reset status */
    if (release && (readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  1056b6:	580e      	ldr	r6, [r1, r0]
  1056b8:	b1aa      	cbz	r2, 1056e6 <rstgen_core_ctl+0x4a>
  1056ba:	0076      	lsls	r6, r6, #1
  1056bc:	d410      	bmi.n	1056e0 <rstgen_core_ctl+0x44>
        return true;
    }

    uint32_t sw_rst = release?1:0;
    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  1056be:	581e      	ldr	r6, [r3, r0]
  1056c0:	f046 0601 	orr.w	r6, r6, #1
  1056c4:	501e      	str	r6, [r3, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  1056c6:	6823      	ldr	r3, [r4, #0]
  1056c8:	005b      	lsls	r3, r3, #1
  1056ca:	d5fc      	bpl.n	1056c6 <rstgen_core_ctl+0x2a>

    /* STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, sw_rst);
  1056cc:	580b      	ldr	r3, [r1, r0]
  1056ce:	f023 0301 	bic.w	r3, r3, #1
  1056d2:	4313      	orrs	r3, r2
  1056d4:	500b      	str	r3, [r1, r0]

    /* Wait reset done. */
    while (sw_rst != (readl(core_sw_rst)
  1056d6:	682b      	ldr	r3, [r5, #0]
                            & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK)>>RSTGEN_CORE_SW_RST_CORE_RST_STA_SHIFT);
  1056d8:	f3c3 7380 	ubfx	r3, r3, #30, #1
    while (sw_rst != (readl(core_sw_rst)
  1056dc:	4293      	cmp	r3, r2
  1056de:	d1fa      	bne.n	1056d6 <rstgen_core_ctl+0x3a>
        return true;
  1056e0:	2001      	movs	r0, #1
    return true;
}
  1056e2:	bc70      	pop	{r4, r5, r6}
  1056e4:	4770      	bx	r14
    if (!release && !(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  1056e6:	0076      	lsls	r6, r6, #1
  1056e8:	d4e9      	bmi.n	1056be <rstgen_core_ctl+0x22>
        return true;
  1056ea:	2001      	movs	r0, #1
  1056ec:	e7f9      	b.n	1056e2 <rstgen_core_ctl+0x46>
  1056ee:	bf00      	nop

001056f0 <rstgen_module_ctl>:
//*****************************************************************************
bool rstgen_module_ctl(vaddr_t base, uint32_t module_idx,
                         bool release)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  1056f0:	0309      	lsls	r1, r1, #12
{
  1056f2:	b410      	push	{r4}
                             RSTGEN_MODULE_RST_OFF(module_slice));

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d release:%d\n",
            (uint64_t)base, module_slice, release);

    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1056f4:	580b      	ldr	r3, [r1, r0]
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  1056f6:	180c      	adds	r4, r1, r0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1056f8:	2b00      	cmp	r3, #0
    {
        LTRACEF("module_slice:%d has been locked.\n", module_slice);
        return false;
  1056fa:	bfb8      	it	lt
  1056fc:	2000      	movlt	r0, #0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  1056fe:	db15      	blt.n	10572c <rstgen_module_ctl+0x3c>
    }

    if (release && (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  105700:	580b      	ldr	r3, [r1, r0]
  105702:	b1b2      	cbz	r2, 105732 <rstgen_module_ctl+0x42>
  105704:	005b      	lsls	r3, r3, #1
  105706:	d410      	bmi.n	10572a <rstgen_module_ctl+0x3a>
        LTRACEF("module_slice:%d already in assert status\n", module_slice);
        return true;
    }

    /* Enable module reset. */
    RMWREG32(module_rst, RSTGEN_MODULE_RST_EN_SHIFT, 1, 1);
  105708:	580b      	ldr	r3, [r1, r0]
  10570a:	f043 0302 	orr.w	r3, r3, #2
  10570e:	500b      	str	r3, [r1, r0]

    while (!(readl(module_rst) & RSTGEN_MODULE_RST_EN_MASK));
  105710:	6823      	ldr	r3, [r4, #0]
  105712:	079b      	lsls	r3, r3, #30
  105714:	d5fc      	bpl.n	105710 <rstgen_module_ctl+0x20>

    /* Write RST_N bit. 0 = reset, 1 = release. */
    uint32_t rst_n = release?1:0;
    RMWREG32(module_rst, RSTGEN_MODULE_RST_N_SHIFT, 1, rst_n);
  105716:	580b      	ldr	r3, [r1, r0]
  105718:	f023 0301 	bic.w	r3, r3, #1
  10571c:	4313      	orrs	r3, r2
  10571e:	500b      	str	r3, [r1, r0]

    /* Wait module reset done. */
    while (rst_n != (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK)>>RSTGEN_MODULE_RST_STA_SHIFT);
  105720:	6823      	ldr	r3, [r4, #0]
  105722:	f3c3 7380 	ubfx	r3, r3, #30, #1
  105726:	4293      	cmp	r3, r2
  105728:	d1fa      	bne.n	105720 <rstgen_module_ctl+0x30>
        return true;
  10572a:	2001      	movs	r0, #1

    return true;
}
  10572c:	f85d 4b04 	ldr.w	r4, [r13], #4
  105730:	4770      	bx	r14
    if (!release && !(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  105732:	005b      	lsls	r3, r3, #1
  105734:	d4e8      	bmi.n	105708 <rstgen_module_ctl+0x18>
        return true;
  105736:	2001      	movs	r0, #1
  105738:	e7f8      	b.n	10572c <rstgen_module_ctl+0x3c>
  10573a:	bf00      	nop

0010573c <rstgen_module_status>:
// return 0, the module reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_module_status(vaddr_t base, uint32_t module_idx)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  10573c:	0309      	lsls	r1, r1, #12

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d \n",
            (uint64_t)base, module_slice);

    /* RSTGEN_MODULE_RST_STA, 0 = reset, 1 = release. */
    return !!(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK);
  10573e:	5808      	ldr	r0, [r1, r0]
}
  105740:	f3c0 7080 	ubfx	r0, r0, #30, #1
  105744:	4770      	bx	r14
  105746:	bf00      	nop

00105748 <rstgen_core_status>:
// return 1, the core reset has be released.
// return 0, the core reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_core_status(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  105748:	0849      	lsrs	r1, r1, #1
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  10574a:	0349      	lsls	r1, r1, #13
                RSTGEN_CORE_SW_RST_OFF(core_slice));
    return !!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK);
  10574c:	5808      	ldr	r0, [r1, r0]
}
  10574e:	f3c0 7080 	ubfx	r0, r0, #30, #1
  105752:	4770      	bx	r14

00105754 <scr_get>:

/*
 * Get SCR signal value.
 */
uint32_t scr_get(scr_signal_t scr_signal)
{
  105754:	b4f0      	push	{r4, r5, r6, r7}
  105756:	4604      	mov	r4, r0
  105758:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  10575a:	f3c1 2107 	ubfx	r1, r1, #8, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10575e:	f3ef 8300 	mrs	r3, CPSR
  105762:	061b      	lsls	r3, r3, #24
  105764:	ea4f 4610 	mov.w	r6, r0, lsr #16
  105768:	d428      	bmi.n	1057bc <scr_get+0x68>
    __asm__ volatile("cpsid i");
  10576a:	b672      	cpsid	i
}

static inline uint32_t _scr_reg(scr_signal_t scr_signal)
{
    const int scr_shift[] = {
  10576c:	f64d 5220 	movw	r2, #56608	; 0xdd20
        [SCR_SEC]    = 10,
        [SCR_HPI]    = 0,
    };

    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
    return reg << scr_shift[_scr_id(scr_signal)];
  105770:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  105772:	f2c0 0210 	movt	r2, #16
    return reg << scr_shift[_scr_id(scr_signal)];
  105776:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  -----------------------------------------------------*/

/* Get physical address of SCR register. */
static inline uint32_t _scr_reg_paddr(enum scr_id scr_id, uint32_t reg)
{
    const addr_t scr_base[] = {
  10577a:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  10577e:	ad01      	add	r5, sp, #4
  105780:	ca07      	ldmia	r2, {r0, r1, r2}
  105782:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  105786:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  10578a:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  10578e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  105792:	40be      	lsls	r6, r7
        [SCR_SAFETY] = APB_SCR_SAF_BASE,
        [SCR_SEC]    = APB_SCR_SEC_BASE,
        [SCR_HPI]    = APB_SCR_HPI_BASE,
    };

    return scr_base[scr_id] + reg;
  105794:	f853 3c0c 	ldr.w	r3, [r3, #-12]
};

static inline uint32_t _scr_read_reg(enum scr_id scr_id, uint32_t reg)
{
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  105798:	58f0      	ldr	r0, [r6, r3]
    __asm__ volatile("cpsie i");
  10579a:	b662      	cpsie	i
    return (uint32_t)(scr_signal >> 8) & 0xff;
  10579c:	f3c4 2307 	ubfx	r3, r4, #8, #8
    return (uint32_t)scr_signal & 0xff;
  1057a0:	b2e4      	uxtb	r4, r4
    spin_lock_irqsave(&g_scr_lock, state);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));
    spin_unlock_irqrestore(&g_scr_lock, state);

    return (val >> _scr_start_bit(scr_signal)) &
            BIT_MASK(_scr_width(scr_signal));
  1057a2:	2c1f      	cmp	r4, #31
    return (val >> _scr_start_bit(scr_signal)) &
  1057a4:	fa20 f003 	lsr.w	r0, r0, r3
            BIT_MASK(_scr_width(scr_signal));
  1057a8:	d805      	bhi.n	1057b6 <scr_get+0x62>
  1057aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  1057ae:	fa03 f404 	lsl.w	r4, r3, r4
  1057b2:	ea20 0004 	bic.w	r0, r0, r4
}
  1057b6:	b004      	add	sp, #16
  1057b8:	bcf0      	pop	{r4, r5, r6, r7}
  1057ba:	4770      	bx	r14
    const int scr_shift[] = {
  1057bc:	f64d 5220 	movw	r2, #56608	; 0xdd20
    return reg << scr_shift[_scr_id(scr_signal)];
  1057c0:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  1057c2:	f2c0 0210 	movt	r2, #16
    return reg << scr_shift[_scr_id(scr_signal)];
  1057c6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    const addr_t scr_base[] = {
  1057ca:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  1057ce:	ad01      	add	r5, sp, #4
  1057d0:	ca07      	ldmia	r2, {r0, r1, r2}
  1057d2:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  1057d6:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1057da:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  1057de:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1057e2:	40be      	lsls	r6, r7
    return scr_base[scr_id] + reg;
  1057e4:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  1057e8:	58f0      	ldr	r0, [r6, r3]
  1057ea:	e7d7      	b.n	10579c <scr_get+0x48>

001057ec <scr_is_locked>:
    const int scr_shift[] = {
  1057ec:	f64d 5220 	movw	r2, #56608	; 0xdd20
/*
 * Check whether the SCR signal is locked - read only or manually
 * locked by SW.
 */
bool scr_is_locked(scr_signal_t scr_signal)
{
  1057f0:	460b      	mov	r3, r1
  1057f2:	b4f0      	push	{r4, r5, r6, r7}
  1057f4:	f2c0 0210 	movt	r2, #16
  1057f8:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  1057fa:	f3c1 2607 	ubfx	r6, r1, #8, #8
    return reg << scr_shift[_scr_id(scr_signal)];
  1057fe:	a904      	add	r1, sp, #16
    const addr_t scr_base[] = {
  105800:	f102 070c 	add.w	r7, r2, #12
  105804:	4605      	mov	r5, r0
    return reg << scr_shift[_scr_id(scr_signal)];
  105806:	eb01 0686 	add.w	r6, r1, r6, lsl #2
    const int scr_shift[] = {
  10580a:	ac01      	add	r4, sp, #4
  10580c:	ca07      	ldmia	r2, {r0, r1, r2}
  10580e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  105812:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  105816:	f856 cc0c 	ldr.w	r12, [r6, #-12]
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  10581a:	0c2f      	lsrs	r7, r5, #16
    const addr_t scr_base[] = {
  10581c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    uint32_t val = (uint32_t)(scr_signal >> 32) & 0xff;
  105820:	b2db      	uxtb	r3, r3
    return reg << scr_shift[_scr_id(scr_signal)];
  105822:	fa07 f70c 	lsl.w	r7, r7, r12
    return scr_base[scr_id] + reg;
  105826:	f856 2c0c 	ldr.w	r2, [r6, #-12]
    uint32_t start_bit = _scr_start_bit(scr_signal);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));

    bool locked;

    switch (_scr_type(scr_signal)) {
  10582a:	3b01      	subs	r3, #1
    return (uint32_t)(scr_signal >> 8) & 0xff;
  10582c:	f3c5 2507 	ubfx	r5, r5, #8, #8
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  105830:	58b8      	ldr	r0, [r7, r2]
  105832:	2b03      	cmp	r3, #3
  105834:	d81f      	bhi.n	105876 <scr_is_locked+0x8a>
  105836:	e8df f003 	tbb	[r15, r3]
  10583a:	1102      	.short	0x1102
  10583c:	060d      	.short	0x060d
        case R16W16:
            locked = start_bit >= 16;
            break;

        case RO:
            locked = true;
  10583e:	2001      	movs	r0, #1
            locked = false;
            break;
    }

    return locked;
}
  105840:	b004      	add	sp, #16
  105842:	bcf0      	pop	{r4, r5, r6, r7}
  105844:	4770      	bx	r14
            locked = start_bit >= 16;
  105846:	2d0f      	cmp	r5, #15
  105848:	bf94      	ite	ls
  10584a:	2000      	movls	r0, #0
  10584c:	2001      	movhi	r0, #1
}
  10584e:	b004      	add	sp, #16
  105850:	bcf0      	pop	{r4, r5, r6, r7}
  105852:	4770      	bx	r14
            locked = val & (1ul << 31);
  105854:	0fc0      	lsrs	r0, r0, #31
}
  105856:	b004      	add	sp, #16
  105858:	bcf0      	pop	{r4, r5, r6, r7}
  10585a:	4770      	bx	r14
                locked = val & (1ul << (start_bit + 16));
  10585c:	2301      	movs	r3, #1
            if (start_bit < 16)
  10585e:	2d0f      	cmp	r5, #15
                locked = val & (1ul << (start_bit + 16));
  105860:	bf98      	it	ls
  105862:	3510      	addls	r5, #16
                locked = val & (1ul << start_bit);
  105864:	fa03 f505 	lsl.w	r5, r3, r5
  105868:	4205      	tst	r5, r0
  10586a:	bf14      	ite	ne
  10586c:	4618      	movne	r0, r3
  10586e:	2000      	moveq	r0, #0
}
  105870:	b004      	add	sp, #16
  105872:	bcf0      	pop	{r4, r5, r6, r7}
  105874:	4770      	bx	r14
            locked = false;
  105876:	2000      	movs	r0, #0
}
  105878:	b004      	add	sp, #16
  10587a:	bcf0      	pop	{r4, r5, r6, r7}
  10587c:	4770      	bx	r14
  10587e:	bf00      	nop

00105880 <scr_set>:
{
  105880:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  105884:	468a      	mov	r10, r1
    const int scr_shift[] = {
  105886:	f64d 5120 	movw	r1, #56608	; 0xdd20
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  10588a:	f3ca 2607 	ubfx	r6, r10, #8, #8
  10588e:	b085      	sub	sp, #20
    const int scr_shift[] = {
  105890:	f2c0 0110 	movt	r1, #16
    return reg << scr_shift[_scr_id(scr_signal)];
  105894:	00b6      	lsls	r6, r6, #2
  105896:	ab04      	add	r3, sp, #16
  105898:	4433      	add	r3, r6
  10589a:	4605      	mov	r5, r0
    const addr_t scr_base[] = {
  10589c:	f101 070c 	add.w	r7, r1, #12
  1058a0:	4691      	mov	r9, r2
    const int scr_shift[] = {
  1058a2:	ac01      	add	r4, sp, #4
  1058a4:	c907      	ldmia	r1, {r0, r1, r2}
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  1058a6:	ea4f 4815 	mov.w	r8, r5, lsr #16
    const int scr_shift[] = {
  1058aa:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  1058ae:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1058b2:	f853 cc0c 	ldr.w	r12, [r3, #-12]
    const addr_t scr_base[] = {
  1058b6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  1058ba:	fa08 f80c 	lsl.w	r8, r8, r12
    return scr_base[scr_id] + reg;
  1058be:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  1058c2:	f858 b003 	ldr.w	r11, [r8, r3]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1058c6:	f3ef 8300 	mrs	r3, CPSR
  1058ca:	061b      	lsls	r3, r3, #24
  1058cc:	d529      	bpl.n	105922 <scr_set+0xa2>
    if (!scr_is_locked(scr_signal)) {
  1058ce:	4628      	mov	r0, r5
  1058d0:	4651      	mov	r1, r10
  1058d2:	f7ff ff8b 	bl	1057ec <scr_is_locked>
    spin_lock_saved_state_t state = 0;
  1058d6:	4684      	mov	r12, r0
  1058d8:	bb50      	cbnz	r0, 105930 <scr_set+0xb0>
    return (uint32_t)scr_signal & 0xff;
  1058da:	b2ea      	uxtb	r2, r5
        val &= ~(BIT_MASK(_scr_width(scr_signal)) << start_bit);
  1058dc:	2a1f      	cmp	r2, #31
  1058de:	bf94      	ite	ls
  1058e0:	2301      	movls	r3, #1
  1058e2:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
    return (uint32_t)(scr_signal >> 8) & 0xff;
  1058e6:	f3c5 2507 	ubfx	r5, r5, #8, #8
  1058ea:	bf9c      	itt	ls
  1058ec:	4093      	lslls	r3, r2
  1058ee:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
    return scr_base[scr_id] + reg;
  1058f2:	aa04      	add	r2, sp, #16
  1058f4:	40ab      	lsls	r3, r5
  1058f6:	4416      	add	r6, r2
  1058f8:	ea2b 0b03 	bic.w	r11, r11, r3
    const addr_t scr_base[] = {
  1058fc:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
        val |= value << start_bit;
  105900:	fa09 f905 	lsl.w	r9, r9, r5
  105904:	ea49 050b 	orr.w	r5, r9, r11
  105908:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return scr_base[scr_id] + reg;
  10590c:	f856 3c0c 	ldr.w	r3, [r6, #-12]
        ret = true;
  105910:	2001      	movs	r0, #1
}

static inline void
_scr_write_reg(enum scr_id scr_id, uint32_t reg, uint32_t val)
{
    writel(val, _ioaddr(_scr_reg_paddr(scr_id, reg)));
  105912:	f848 5003 	str.w	r5, [r8, r3]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  105916:	f1bc 0f00 	cmp.w	r12, #0
  10591a:	d118      	bne.n	10594e <scr_set+0xce>
}
  10591c:	b005      	add	sp, #20
  10591e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    __asm__ volatile("cpsid i");
  105922:	b672      	cpsid	i
    if (!scr_is_locked(scr_signal)) {
  105924:	4628      	mov	r0, r5
  105926:	4651      	mov	r1, r10
  105928:	f7ff ff60 	bl	1057ec <scr_is_locked>
  10592c:	b160      	cbz	r0, 105948 <scr_set+0xc8>
    __asm__ volatile("cpsie i");
  10592e:	b662      	cpsie	i
        dprintf(CRITICAL, "Cannot set SCR signal %llx\n", scr_signal);
  105930:	f64d 5038 	movw	r0, #56632	; 0xdd38
  105934:	462a      	mov	r2, r5
  105936:	4653      	mov	r3, r10
  105938:	f2c0 0010 	movt	r0, #16
  10593c:	f005 fcce 	bl	10b2dc <printf>
  105940:	2000      	movs	r0, #0
}
  105942:	b005      	add	sp, #20
  105944:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  105948:	f04f 0c01 	mov.w	r12, #1
  10594c:	e7c5      	b.n	1058da <scr_set+0x5a>
  10594e:	b662      	cpsie	i
        ret = true;
  105950:	2001      	movs	r0, #1
  105952:	e7e3      	b.n	10591c <scr_set+0x9c>

00105954 <cospi_early_init>:
}



static void cospi_early_init(uint level)
{
  105954:	b510      	push	{r4, r14}
    struct cospi_pdata *cospi = &s_cospi;

    memset(cospi, 0, sizeof(struct cospi_pdata));
  105956:	f247 0464 	movw	r4, #28772	; 0x7064
{
  10595a:	b082      	sub	sp, #8
    memset(cospi, 0, sizeof(struct cospi_pdata));
  10595c:	2268      	movs	r2, #104	; 0x68
  10595e:	f2c0 0411 	movt	r4, #17
  105962:	2100      	movs	r1, #0
  105964:	4620      	mov	r0, r4
  105966:	f004 ed8e 	blx	10a484 <memset>

    mutex_init(&cospi->bus_mutex);
  10596a:	f104 0010 	add.w	r0, r4, #16
  10596e:	f005 fdcb 	bl	10b508 <mutex_init>

    event_init(&cospi->dma_event, false, EVENT_FLAG_AUTOUNSIGNAL);
  105972:	2201      	movs	r2, #1
  105974:	2100      	movs	r1, #0
  105976:	f104 0014 	add.w	r0, r4, #20
  10597a:	f005 fd03 	bl	10b384 <event_init>
    event_init(&cospi->complete_event, false, EVENT_FLAG_AUTOUNSIGNAL);
  10597e:	2201      	movs	r2, #1
  105980:	2100      	movs	r1, #0
  105982:	f104 001c 	add.w	r0, r4, #28
  105986:	f005 fcfd 	bl	10b384 <event_init>
    event_init(&cospi->xfer_start_event, false, EVENT_FLAG_AUTOUNSIGNAL);
  10598a:	2201      	movs	r2, #1
  10598c:	2100      	movs	r1, #0
  10598e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  105992:	f005 fcf7 	bl	10b384 <event_init>
    event_init(&cospi->xfer_done_event, false, EVENT_FLAG_AUTOUNSIGNAL);
  105996:	2201      	movs	r2, #1
  105998:	2100      	movs	r1, #0
  10599a:	f104 002c 	add.w	r0, r4, #44	; 0x2c
  10599e:	f005 fcf1 	bl	10b384 <event_init>
    dprintf(INFO, "creat cospi thread!\n");
    thread_t *thread =
  1059a2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  1059a6:	f645 210d 	movw	r1, #23053	; 0x5a0d
  1059aa:	f64d 508c 	movw	r0, #56716	; 0xdd8c
  1059ae:	4622      	mov	r2, r4
  1059b0:	f2c0 0110 	movt	r1, #16
  1059b4:	9300      	str	r3, [sp, #0]
  1059b6:	f2c0 0010 	movt	r0, #16
  1059ba:	2318      	movs	r3, #24
  1059bc:	f005 fdc6 	bl	10b54c <thread_create>
  1059c0:	4604      	mov	r4, r0
        thread_create("cospi_thread", cospi_data_thread, (void *)cospi,
                      HIGH_PRIORITY, DEFAULT_STACK_SIZE);
    thread_detach(thread);
  1059c2:	f005 fe49 	bl	10b658 <thread_detach>
    thread_resume(thread);
  1059c6:	4620      	mov	r0, r4
}
  1059c8:	b002      	add	sp, #8
  1059ca:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    thread_resume(thread);
  1059ce:	f005 be19 	b.w	10b604 <thread_resume>
  1059d2:	bf00      	nop

001059d4 <cospi_wait_for_bit.constprop.16>:
static int cospi_wait_for_bit(addr_t reg, const u32 mask, bool clear, u32 time)
  1059d4:	b570      	push	{r4, r5, r6, r14}
  1059d6:	4606      	mov	r6, r0
  1059d8:	460d      	mov	r5, r1
  1059da:	4614      	mov	r4, r2
    timeout = current_time() + time;
  1059dc:	f7fa fe54 	bl	100688 <current_time>
        val = readl(reg);
  1059e0:	6833      	ldr	r3, [r6, #0]
        if (val == mask)
  1059e2:	422b      	tst	r3, r5
    timeout = current_time() + time;
  1059e4:	4404      	add	r4, r0
        if (val == mask)
  1059e6:	d105      	bne.n	1059f4 <cospi_wait_for_bit.constprop.16+0x20>
  1059e8:	e00d      	b.n	105a06 <cospi_wait_for_bit.constprop.16+0x32>
        udelay(1);
  1059ea:	f004 fc31 	bl	10a250 <spin>
        val = readl(reg);
  1059ee:	6833      	ldr	r3, [r6, #0]
        if (val == mask)
  1059f0:	422b      	tst	r3, r5
  1059f2:	d008      	beq.n	105a06 <cospi_wait_for_bit.constprop.16+0x32>
        if (current_time() > timeout)
  1059f4:	f7fa fe48 	bl	100688 <current_time>
  1059f8:	4284      	cmp	r4, r0
        udelay(1);
  1059fa:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
  1059fe:	d2f4      	bcs.n	1059ea <cospi_wait_for_bit.constprop.16+0x16>
            return -ETIMEDOUT;
  105a00:	f06f 0073 	mvn.w	r0, #115	; 0x73
}
  105a04:	bd70      	pop	{r4, r5, r6, r15}
            return 0;
  105a06:	2000      	movs	r0, #0
}
  105a08:	bd70      	pop	{r4, r5, r6, r15}
  105a0a:	bf00      	nop

00105a0c <cospi_data_thread>:
{
  105a0c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  105a10:	4603      	mov	r3, r0
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
  105a12:	2100      	movs	r1, #0
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
  105a14:	f64d 5454 	movw	r4, #56660	; 0xdd54
{
  105a18:	b089      	sub	sp, #36	; 0x24
  105a1a:	f100 0224 	add.w	r2, r0, #36	; 0x24
  105a1e:	332c      	adds	r3, #44	; 0x2c
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
  105a20:	f6cf 71ff 	movt	r1, #65535	; 0xffff
{
  105a24:	9005      	str	r0, [sp, #20]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
  105a26:	f2c0 0410 	movt	r4, #16
  105a2a:	9204      	str	r2, [sp, #16]
  105a2c:	9307      	str	r3, [sp, #28]
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
  105a2e:	9103      	str	r1, [sp, #12]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
  105a30:	9406      	str	r4, [sp, #24]
*   para: event handle.
*   return： NO_ERROR if unsignal succ or blocked forever.
*/
static inline status_t event_wait(event_t *e)
{
    return event_wait_timeout(e, INFINITE_TIME);
  105a32:	9804      	ldr	r0, [sp, #16]
  105a34:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  105a38:	f005 fcd2 	bl	10b3e0 <event_wait_timeout>
        nor = cospi->priv;
  105a3c:	9b05      	ldr	r3, [sp, #20]
  105a3e:	f8d3 8064 	ldr.w	r8, [r3, #100]	; 0x64
    struct cospi_pdata *cospi = nor->priv_data;
  105a42:	f8d8 207c 	ldr.w	r2, [r8, #124]	; 0x7c
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
  105a46:	f892 3052 	ldrb.w	r3, [r2, #82]	; 0x52
  105a4a:	f892 2053 	ldrb.w	r2, [r2, #83]	; 0x53
  105a4e:	fb13 f302 	smulbb	r3, r3, r2
    uint32_t remaining = cmd->size;
  105a52:	f8d8 1074 	ldr.w	r1, [r8, #116]	; 0x74
    uint8_t *xfer_buf = (uint8_t *)cmd->buf;
  105a56:	f8d8 2070 	ldr.w	r2, [r8, #112]	; 0x70
    uint32_t remaining = cmd->size;
  105a5a:	9100      	str	r1, [sp, #0]
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
  105a5c:	01db      	lsls	r3, r3, #7
    uint8_t *xfer_buf = (uint8_t *)cmd->buf;
  105a5e:	9201      	str	r2, [sp, #4]
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
  105a60:	9302      	str	r3, [sp, #8]
    while(remaining) {
  105a62:	2900      	cmp	r1, #0
  105a64:	f000 813c 	beq.w	105ce0 <cospi_data_thread+0x2d4>
    int ret = 0;
  105a68:	2000      	movs	r0, #0
  105a6a:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
        if (nor->async_mode && nor->cancel_flag) {
  105a6e:	b121      	cbz	r1, 105a7a <cospi_data_thread+0x6e>
  105a70:	f898 3058 	ldrb.w	r3, [r8, #88]	; 0x58
  105a74:	2b00      	cmp	r3, #0
  105a76:	f040 80fa 	bne.w	105c6e <cospi_data_thread+0x262>
        xfer_len = MIN(remaining, max_xfer_length);
  105a7a:	9a02      	ldr	r2, [sp, #8]
  105a7c:	9c00      	ldr	r4, [sp, #0]
        switch (cmd->type) {
  105a7e:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
        xfer_len = MIN(remaining, max_xfer_length);
  105a82:	42a2      	cmp	r2, r4
  105a84:	bf28      	it	cs
  105a86:	4622      	movcs	r2, r4
        switch (cmd->type) {
  105a88:	2b02      	cmp	r3, #2
        xfer_len = MIN(remaining, max_xfer_length);
  105a8a:	4692      	mov	r10, r2
  105a8c:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
        switch (cmd->type) {
  105a90:	d01d      	beq.n	105ace <cospi_data_thread+0xc2>
  105a92:	2b03      	cmp	r3, #3
  105a94:	d004      	beq.n	105aa0 <cospi_data_thread+0x94>
  105a96:	2b01      	cmp	r3, #1
            ret = -1;
  105a98:	bf18      	it	ne
  105a9a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
        switch (cmd->type) {
  105a9e:	d069      	beq.n	105b74 <cospi_data_thread+0x168>
        xfer_buf += xfer_len;
  105aa0:	9b01      	ldr	r3, [sp, #4]
        nor->data_cmd.addr += xfer_len;
  105aa2:	4452      	add	r2, r10
  105aa4:	f8c8 206c 	str.w	r2, [r8, #108]	; 0x6c
        xfer_buf += xfer_len;
  105aa8:	4453      	add	r3, r10
  105aaa:	9301      	str	r3, [sp, #4]
    while(remaining) {
  105aac:	9b00      	ldr	r3, [sp, #0]
  105aae:	ebb3 030a 	subs.w	r3, r3, r10
  105ab2:	9300      	str	r3, [sp, #0]
  105ab4:	d1db      	bne.n	105a6e <cospi_data_thread+0x62>
    nor->data_present = 0;
  105ab6:	2300      	movs	r3, #0
  105ab8:	f888 3050 	strb.w	r3, [r8, #80]	; 0x50
        if (nor->async_mode) {
  105abc:	2900      	cmp	r1, #0
  105abe:	f040 80db 	bne.w	105c78 <cospi_data_thread+0x26c>
            nor->data_error = ret;
  105ac2:	f8c8 0054 	str.w	r0, [r8, #84]	; 0x54
            event_signal(&cospi->xfer_done_event, false);
  105ac6:	9807      	ldr	r0, [sp, #28]
  105ac8:	f005 fcc4 	bl	10b454 <event_signal>
  105acc:	e7b1      	b.n	105a32 <cospi_data_thread+0x26>
    if (buf == NULL || size == 0)
  105ace:	9e01      	ldr	r6, [sp, #4]
  105ad0:	f1ba 0f00 	cmp.w	r10, #0
  105ad4:	bf18      	it	ne
  105ad6:	2e00      	cmpne	r6, #0
  105ad8:	f000 80c7 	beq.w	105c6a <cospi_data_thread+0x25e>
    struct cospi_pdata *cospi = nor->priv_data;
  105adc:	f8d8 907c 	ldr.w	r9, [r8, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTWR_START_MASK,
  105ae0:	2101      	movs	r1, #1
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
  105ae2:	f8d8 503c 	ldr.w	r5, [r8, #60]	; 0x3c
        udelay(1);
  105ae6:	4608      	mov	r0, r1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
  105ae8:	f8d9 3054 	ldr.w	r3, [r9, #84]	; 0x54
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
  105aec:	1e6c      	subs	r4, r5, #1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
  105aee:	f8d9 7008 	ldr.w	r7, [r9, #8]
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
  105af2:	4014      	ands	r4, r2
    u32 addr_page_bonduary_size =
  105af4:	ebc4 0445 	rsb	r4, r4, r5, lsl #1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
  105af8:	441f      	add	r7, r3
    cospi_indirect_trigger(cospi, cmd->addr, size, INDIRECT_WRITE_FLAG);
  105afa:	f8d9 3004 	ldr.w	r3, [r9, #4]
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTWRSTARTADDR);
  105afe:	679a      	str	r2, [r3, #120]	; 0x78
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTWRBYTES);
  105b00:	f8c3 a07c 	str.w	r10, [r3, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTWR_START_MASK,
  105b04:	6719      	str	r1, [r3, #112]	; 0x70
        udelay(1);
  105b06:	f004 fba3 	bl	10a250 <spin>
    arch_invalidate_cache_range(ahb_trigger_address, cospi->trigger_range_size);
  105b0a:	f8d9 1058 	ldr.w	r1, [r9, #88]	; 0x58
  105b0e:	4638      	mov	r0, r7
  105b10:	f7fb ee88 	blx	101824 <arch_invalidate_cache_range>
        if (addr_page_bonduary_size) {
  105b14:	2c00      	cmp	r4, #0
  105b16:	f000 80e0 	beq.w	105cda <cospi_data_thread+0x2ce>
            write_bytes = MIN(remaining, addr_page_bonduary_size);
  105b1a:	4635      	mov	r5, r6
  105b1c:	4554      	cmp	r4, r10
  105b1e:	bf28      	it	cs
  105b20:	4654      	movcs	r4, r10
  105b22:	4656      	mov	r6, r10
                DIV_ROUND_UP(write_bytes, cospi->fifo_width));
  105b24:	f899 3053 	ldrb.w	r3, [r9, #83]	; 0x53
  105b28:	1e5a      	subs	r2, r3, #1
  105b2a:	4422      	add	r2, r4
  105b2c:	fbb2 f2f3 	udiv	r2, r2, r3
    while (len--)
  105b30:	1e53      	subs	r3, r2, #1
  105b32:	b152      	cbz	r2, 105b4a <cospi_data_thread+0x13e>
  105b34:	462a      	mov	r2, r5
  105b36:	eba7 0c05 	sub.w	r12, r7, r5
  105b3a:	eb02 010c 	add.w	r1, r2, r12
        writel(*data++, addr++);
  105b3e:	f852 0b04 	ldr.w	r0, [r2], #4
    while (len--)
  105b42:	3b01      	subs	r3, #1
        writel(*data++, addr++);
  105b44:	6008      	str	r0, [r1, #0]
    while (len--)
  105b46:	1c59      	adds	r1, r3, #1
  105b48:	d1f7      	bne.n	105b3a <cospi_data_thread+0x12e>
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
  105b4a:	f8d9 0004 	ldr.w	r0, [r9, #4]
  105b4e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  105b52:	9903      	ldr	r1, [sp, #12]
        write_buf += write_bytes;
  105b54:	4425      	add	r5, r4
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
  105b56:	302c      	adds	r0, #44	; 0x2c
  105b58:	f7ff ff3c 	bl	1059d4 <cospi_wait_for_bit.constprop.16>
        if (ret) {
  105b5c:	2800      	cmp	r0, #0
  105b5e:	f040 80a1 	bne.w	105ca4 <cospi_data_thread+0x298>
    while (remaining) {
  105b62:	1b36      	subs	r6, r6, r4
  105b64:	f000 809b 	beq.w	105c9e <cospi_data_thread+0x292>
            write_bytes = MIN(remaining, nor->page_size);
  105b68:	f8d8 403c 	ldr.w	r4, [r8, #60]	; 0x3c
  105b6c:	42b4      	cmp	r4, r6
  105b6e:	bf28      	it	cs
  105b70:	4634      	movcs	r4, r6
  105b72:	e7d7      	b.n	105b24 <cospi_data_thread+0x118>
    if (buf == NULL || size == 0)
  105b74:	9b01      	ldr	r3, [sp, #4]
  105b76:	f1ba 0f00 	cmp.w	r10, #0
  105b7a:	bf18      	it	ne
  105b7c:	2b00      	cmpne	r3, #0
  105b7e:	d074      	beq.n	105c6a <cospi_data_thread+0x25e>
    if (cmd->queue_mode_en)
  105b80:	f898 305e 	ldrb.w	r3, [r8, #94]	; 0x5e
        trgger_size = size / 2;
  105b84:	ea4f 075a 	mov.w	r7, r10, lsr #1
    if (cmd->queue_mode_en)
  105b88:	b903      	cbnz	r3, 105b8c <cospi_data_thread+0x180>
  105b8a:	4657      	mov	r7, r10
            ret = cospi_indirect_read(nor, &nor->data_cmd, xfer_buf, xfer_len);
  105b8c:	f8d8 b07c 	ldr.w	r11, [r8, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
  105b90:	2601      	movs	r6, #1
        udelay(1);
  105b92:	4630      	mov	r0, r6
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
  105b94:	e9db 1501 	ldrd	r1, r5, [r11, #4]
  105b98:	f8db 4054 	ldr.w	r4, [r11, #84]	; 0x54
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTRDSTARTADDR);
  105b9c:	668a      	str	r2, [r1, #104]	; 0x68
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTRDBYTES);
  105b9e:	66cf      	str	r7, [r1, #108]	; 0x6c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
  105ba0:	660e      	str	r6, [r1, #96]	; 0x60
        udelay(1);
  105ba2:	f004 fb55 	bl	10a250 <spin>
    if (cmd->queue_mode_en) {
  105ba6:	f898 205e 	ldrb.w	r2, [r8, #94]	; 0x5e
  105baa:	2a00      	cmp	r2, #0
  105bac:	f040 8089 	bne.w	105cc2 <cospi_data_thread+0x2b6>
    s64 remaining = size;
  105bb0:	4656      	mov	r6, r10
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
  105bb2:	eb05 0904 	add.w	r9, r5, r4
  105bb6:	9c01      	ldr	r4, [sp, #4]
    s64 remaining = size;
  105bb8:	2700      	movs	r7, #0
    timeout = current_time() + COSPI_READ_TIMEOUT_MS;
  105bba:	f7fa fd65 	bl	100688 <current_time>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
  105bbe:	f8db 2004 	ldr.w	r2, [r11, #4]
  105bc2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
  105bc4:	b29b      	uxth	r3, r3
    timeout = current_time() + COSPI_READ_TIMEOUT_MS;
  105bc6:	f100 050a 	add.w	r5, r0, #10
        if (val)
  105bca:	b13b      	cbz	r3, 105bdc <cospi_data_thread+0x1d0>
  105bcc:	e019      	b.n	105c02 <cospi_data_thread+0x1f6>
        udelay(1);
  105bce:	f004 fb3f 	bl	10a250 <spin>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
  105bd2:	f8db 2004 	ldr.w	r2, [r11, #4]
  105bd6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
  105bd8:	b29b      	uxth	r3, r3
        if (val)
  105bda:	b993      	cbnz	r3, 105c02 <cospi_data_thread+0x1f6>
        if (current_time() > timeout)
  105bdc:	f7fa fd54 	bl	100688 <current_time>
  105be0:	4285      	cmp	r5, r0
        udelay(1);
  105be2:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
  105be6:	d2f2      	bcs.n	105bce <cospi_data_thread+0x1c2>
  105be8:	f10b 001c 	add.w	r0, r11, #28
  105bec:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  105bf0:	f005 fbf6 	bl	10b3e0 <event_wait_timeout>
    return nor->data_error;
  105bf4:	f8d8 0054 	ldr.w	r0, [r8, #84]	; 0x54
  105bf8:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
  105bfc:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
  105c00:	e74e      	b.n	105aa0 <cospi_data_thread+0x94>
  105c02:	f89b 1053 	ldrb.w	r1, [r11, #83]	; 0x53
  105c06:	e002      	b.n	105c0e <cospi_data_thread+0x202>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
  105c08:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
  105c0a:	b29b      	uxth	r3, r3
        while (words_need_read) {
  105c0c:	b34b      	cbz	r3, 105c62 <cospi_data_thread+0x256>
            words_need_read = MIN(words_need_read,
  105c0e:	f8db 5058 	ldr.w	r5, [r11, #88]	; 0x58
  105c12:	fbb5 f5f1 	udiv	r5, r5, r1
  105c16:	429d      	cmp	r5, r3
  105c18:	bf28      	it	cs
  105c1a:	461d      	movcs	r5, r3
            if (words_need_read) {
  105c1c:	2d00      	cmp	r5, #0
  105c1e:	d0f3      	beq.n	105c08 <cospi_data_thread+0x1fc>
                arch_invalidate_cache_range(ahb_trigger_address,
  105c20:	4648      	mov	r0, r9
  105c22:	4629      	mov	r1, r5
  105c24:	f7fb edfe 	blx	101824 <arch_invalidate_cache_range>
    while (len--)
  105c28:	4623      	mov	r3, r4
  105c2a:	1e6a      	subs	r2, r5, #1
  105c2c:	eba9 0004 	sub.w	r0, r9, r4
  105c30:	1819      	adds	r1, r3, r0
  105c32:	3a01      	subs	r2, #1
        *data++ = readl(addr++);
  105c34:	6809      	ldr	r1, [r1, #0]
  105c36:	f843 1b04 	str.w	r1, [r3], #4
    while (len--)
  105c3a:	1c51      	adds	r1, r2, #1
  105c3c:	d1f8      	bne.n	105c30 <cospi_data_thread+0x224>
                read_buf += words_need_read * cospi->fifo_width;
  105c3e:	f89b 1053 	ldrb.w	r1, [r11, #83]	; 0x53
  105c42:	fb05 f301 	mul.w	r3, r5, r1
                remaining -= words_need_read * cospi->fifo_width;
  105c46:	1af6      	subs	r6, r6, r3
  105c48:	f167 0700 	sbc.w	r7, r7, #0
                if (remaining < 0)
  105c4c:	2e00      	cmp	r6, #0
                read_buf += words_need_read * cospi->fifo_width;
  105c4e:	441c      	add	r4, r3
                if (remaining < 0)
  105c50:	f177 0300 	sbcs.w	r3, r7, #0
  105c54:	dbc8      	blt.n	105be8 <cospi_data_thread+0x1dc>
  105c56:	f8db 2004 	ldr.w	r2, [r11, #4]
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
  105c5a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
  105c5c:	b29b      	uxth	r3, r3
        while (words_need_read) {
  105c5e:	2b00      	cmp	r3, #0
  105c60:	d1d5      	bne.n	105c0e <cospi_data_thread+0x202>
    while (remaining > 0) {
  105c62:	ea56 0307 	orrs.w	r3, r6, r7
  105c66:	d1a8      	bne.n	105bba <cospi_data_thread+0x1ae>
  105c68:	e7be      	b.n	105be8 <cospi_data_thread+0x1dc>
        return EINVAL;
  105c6a:	2016      	movs	r0, #22
  105c6c:	e718      	b.n	105aa0 <cospi_data_thread+0x94>
    nor->data_present = 0;
  105c6e:	2300      	movs	r3, #0
  105c70:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  105c74:	f888 3050 	strb.w	r3, [r8, #80]	; 0x50
            handle = nor->parent;
  105c78:	f8d8 2078 	ldr.w	r2, [r8, #120]	; 0x78
            if (handle && handle->event_handle) {
  105c7c:	2a00      	cmp	r2, #0
  105c7e:	f43f aed8 	beq.w	105a32 <cospi_data_thread+0x26>
  105c82:	6a54      	ldr	r4, [r2, #36]	; 0x24
  105c84:	2c00      	cmp	r4, #0
  105c86:	f43f aed4 	beq.w	105a32 <cospi_data_thread+0x26>
                    ret ? SPI_NOR_OPT_FAILED : SPI_NOR_OPT_COMPLETE;
  105c8a:	1c03      	adds	r3, r0, #0
                handle->opt_type = nor->data_cmd.type;
  105c8c:	f8d8 0060 	ldr.w	r0, [r8, #96]	; 0x60
                    ret ? SPI_NOR_OPT_FAILED : SPI_NOR_OPT_COMPLETE;
  105c90:	bf18      	it	ne
  105c92:	2301      	movne	r3, #1
                handle->event_handle(handle->opt_type, handle->opt_result);
  105c94:	4619      	mov	r1, r3
                handle->opt_result =
  105c96:	e9c2 0307 	strd	r0, r3, [r2, #28]
                handle->event_handle(handle->opt_type, handle->opt_result);
  105c9a:	47a0      	blx	r4
  105c9c:	e6c9      	b.n	105a32 <cospi_data_thread+0x26>
  105c9e:	f109 001c 	add.w	r0, r9, #28
  105ca2:	e7a3      	b.n	105bec <cospi_data_thread+0x1e0>
            ret = ospi_readl(cospi->apb_base + 0xb0);
  105ca4:	f8d9 3004 	ldr.w	r3, [r9, #4]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
  105ca8:	9806      	ldr	r0, [sp, #24]
            ret = ospi_readl(cospi->apb_base + 0xb0);
  105caa:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
  105cae:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  105cb0:	f005 fb14 	bl	10b2dc <printf>
  105cb4:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
  105cb8:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
            return -1;
  105cbc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  105cc0:	e6ee      	b.n	105aa0 <cospi_data_thread+0x94>
        cospi_indirect_trigger(cospi, cmd->addr + trgger_size, trgger_size,
  105cc2:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
        udelay(1);
  105cc6:	4630      	mov	r0, r6
        cospi_indirect_trigger(cospi, cmd->addr + trgger_size, trgger_size,
  105cc8:	f8db 1004 	ldr.w	r1, [r11, #4]
  105ccc:	443a      	add	r2, r7
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTRDSTARTADDR);
  105cce:	668a      	str	r2, [r1, #104]	; 0x68
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTRDBYTES);
  105cd0:	66cf      	str	r7, [r1, #108]	; 0x6c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
  105cd2:	660e      	str	r6, [r1, #96]	; 0x60
        udelay(1);
  105cd4:	f004 fabc 	bl	10a250 <spin>
  105cd8:	e76a      	b.n	105bb0 <cospi_data_thread+0x1a4>
        if (addr_page_bonduary_size) {
  105cda:	9d01      	ldr	r5, [sp, #4]
  105cdc:	4656      	mov	r6, r10
  105cde:	e743      	b.n	105b68 <cospi_data_thread+0x15c>
    while(remaining) {
  105ce0:	9800      	ldr	r0, [sp, #0]
  105ce2:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
  105ce6:	e6e6      	b.n	105ab6 <cospi_data_thread+0xaa>

00105ce8 <timer_drv_cntr_set>:
 ** \param [in] val        Set value for sub counter.
 *****************************************************************************/
void timer_drv_cntr_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                        uint32_t val)
{
    if (val == 0) {
  105ce8:	b94a      	cbnz	r2, 105cfe <timer_drv_cntr_set+0x16>
    timer->cnt_config |= (1 << sub_timer);
  105cea:	6a42      	ldr	r2, [r0, #36]	; 0x24
  105cec:	2301      	movs	r3, #1
  105cee:	fa03 f101 	lsl.w	r1, r3, r1
  105cf2:	430a      	orrs	r2, r1
  105cf4:	6242      	str	r2, [r0, #36]	; 0x24
        while (timer->cnt_config & (1 << sub_timer));
  105cf6:	6a43      	ldr	r3, [r0, #36]	; 0x24
  105cf8:	4219      	tst	r1, r3
  105cfa:	d1fc      	bne.n	105cf6 <timer_drv_cntr_set+0xe>
  105cfc:	4770      	bx	r14
        timer_drv_cntr_reset(timer, sub_timer, true);
    }
    else {
        if (sub_timer == TIMER_DRV_G0) {
  105cfe:	b161      	cbz	r1, 105d1a <timer_drv_cntr_set+0x32>
            timer->cnt_g0_init = val;
        }
        else if (sub_timer == TIMER_DRV_G1) {
  105d00:	2901      	cmp	r1, #1
  105d02:	d00d      	beq.n	105d20 <timer_drv_cntr_set+0x38>
            timer->cnt_g1_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_A) {
  105d04:	2902      	cmp	r1, #2
  105d06:	d00e      	beq.n	105d26 <timer_drv_cntr_set+0x3e>
            timer->cnt_local_a_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_B) {
  105d08:	2903      	cmp	r1, #3
  105d0a:	d00f      	beq.n	105d2c <timer_drv_cntr_set+0x44>
            timer->cnt_local_b_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_C) {
  105d0c:	2904      	cmp	r1, #4
  105d0e:	d010      	beq.n	105d32 <timer_drv_cntr_set+0x4a>
            timer->cnt_local_c_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_D) {
  105d10:	2905      	cmp	r1, #5
            timer->cnt_local_d_init = val;
  105d12:	bf08      	it	eq
  105d14:	f8c0 20c4 	streq.w	r2, [r0, #196]	; 0xc4
        }
    }
}
  105d18:	4770      	bx	r14
            timer->cnt_g0_init = val;
  105d1a:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
  105d1e:	4770      	bx	r14
            timer->cnt_g1_init = val;
  105d20:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
  105d24:	4770      	bx	r14
            timer->cnt_local_a_init = val;
  105d26:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
  105d2a:	4770      	bx	r14
            timer->cnt_local_b_init = val;
  105d2c:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
  105d30:	4770      	bx	r14
            timer->cnt_local_c_init = val;
  105d32:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  105d36:	4770      	bx	r14

00105d38 <timer_drv_cntr_get>:
 *****************************************************************************/
uint32_t timer_drv_cntr_get(sdrv_timer_t *timer, timer_drv_sub_t sub_timer)
{
    uint32_t val = 0;

    if (sub_timer == TIMER_DRV_G0) {
  105d38:	b161      	cbz	r1, 105d54 <timer_drv_cntr_get+0x1c>
        val = timer->cnt_g0;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  105d3a:	2901      	cmp	r1, #1
  105d3c:	d00c      	beq.n	105d58 <timer_drv_cntr_get+0x20>
        val = timer->cnt_g1;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  105d3e:	2902      	cmp	r1, #2
  105d40:	d00e      	beq.n	105d60 <timer_drv_cntr_get+0x28>
        val = timer->cnt_local_a;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  105d42:	2903      	cmp	r1, #3
  105d44:	d00a      	beq.n	105d5c <timer_drv_cntr_get+0x24>
        val = timer->cnt_local_b;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  105d46:	2904      	cmp	r1, #4
  105d48:	d00c      	beq.n	105d64 <timer_drv_cntr_get+0x2c>
        val = timer->cnt_local_c;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  105d4a:	2905      	cmp	r1, #5
        val = timer->cnt_local_d;
  105d4c:	bf0c      	ite	eq
  105d4e:	6d40      	ldreq	r0, [r0, #84]	; 0x54
    uint32_t val = 0;
  105d50:	2000      	movne	r0, #0
    }

    return val;
}
  105d52:	4770      	bx	r14
        val = timer->cnt_g0;
  105d54:	6c00      	ldr	r0, [r0, #64]	; 0x40
  105d56:	4770      	bx	r14
        val = timer->cnt_g1;
  105d58:	6c40      	ldr	r0, [r0, #68]	; 0x44
  105d5a:	4770      	bx	r14
        val = timer->cnt_local_b;
  105d5c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  105d5e:	4770      	bx	r14
        val = timer->cnt_local_a;
  105d60:	6c80      	ldr	r0, [r0, #72]	; 0x48
  105d62:	4770      	bx	r14
        val = timer->cnt_local_c;
  105d64:	6d00      	ldr	r0, [r0, #80]	; 0x50
  105d66:	4770      	bx	r14

00105d68 <timer_drv_ovf_set>:
 ** \param [in] val        Set sub counter overflow value.
 *****************************************************************************/
void timer_drv_ovf_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                       uint32_t val)
{
    if (sub_timer == TIMER_DRV_G0) {
  105d68:	b159      	cbz	r1, 105d82 <timer_drv_ovf_set+0x1a>
        timer->cnt_g0_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  105d6a:	2901      	cmp	r1, #1
  105d6c:	d00b      	beq.n	105d86 <timer_drv_ovf_set+0x1e>
        timer->cnt_g1_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  105d6e:	2902      	cmp	r1, #2
  105d70:	d00d      	beq.n	105d8e <timer_drv_ovf_set+0x26>
        timer->cnt_local_a_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  105d72:	2903      	cmp	r1, #3
  105d74:	d009      	beq.n	105d8a <timer_drv_ovf_set+0x22>
        timer->cnt_local_b_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  105d76:	2904      	cmp	r1, #4
  105d78:	d00b      	beq.n	105d92 <timer_drv_ovf_set+0x2a>
        timer->cnt_local_c_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  105d7a:	2905      	cmp	r1, #5
        timer->cnt_local_d_ovf = val;
  105d7c:	bf08      	it	eq
  105d7e:	63c2      	streq	r2, [r0, #60]	; 0x3c
    }
}
  105d80:	4770      	bx	r14
        timer->cnt_g0_ovf = val;
  105d82:	6282      	str	r2, [r0, #40]	; 0x28
  105d84:	4770      	bx	r14
        timer->cnt_g1_ovf = val;
  105d86:	62c2      	str	r2, [r0, #44]	; 0x2c
  105d88:	4770      	bx	r14
        timer->cnt_local_b_ovf = val;
  105d8a:	6342      	str	r2, [r0, #52]	; 0x34
  105d8c:	4770      	bx	r14
        timer->cnt_local_a_ovf = val;
  105d8e:	6302      	str	r2, [r0, #48]	; 0x30
  105d90:	4770      	bx	r14
        timer->cnt_local_c_ovf = val;
  105d92:	6382      	str	r2, [r0, #56]	; 0x38
  105d94:	4770      	bx	r14
  105d96:	bf00      	nop

00105d98 <timer_drv_cascade_set>:
 ** \param [in] cascade    G1 cascaded G0 or not.
 *****************************************************************************/
void timer_drv_cascade_set(sdrv_timer_t *timer, bool cascade)
{
    if (cascade) {
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  105d98:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if (cascade) {
  105d9a:	b919      	cbnz	r1, 105da4 <timer_drv_cascade_set+0xc>
    }
    else {
        timer->cnt_config &= (~BM_CNT_CONFIG_CASCADE_MODE);
  105d9c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  105da0:	6243      	str	r3, [r0, #36]	; 0x24
    }
}
  105da2:	4770      	bx	r14
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  105da4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  105da8:	6243      	str	r3, [r0, #36]	; 0x24
  105daa:	4770      	bx	r14

00105dac <timer_drv_clk_init>:
 **                                     11 - Low power clock, typically from low speed on chip RCOSC
 *****************************************************************************/
void timer_drv_clk_init(sdrv_timer_t *timer, uint32_t clk_sel,
                        uint32_t clk_div)
{
    u32 value = timer->tim_clk_config;
  105dac:	6a03      	ldr	r3, [r0, #32]

    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  105dae:	0409      	lsls	r1, r1, #16
              FV_TIM_CLK_CONFIG_DIV_NUM(clk_div));
  105db0:	b292      	uxth	r2, r2
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  105db2:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
  105db6:	4311      	orrs	r1, r2
    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
  105db8:	0c9a      	lsrs	r2, r3, #18
  105dba:	0492      	lsls	r2, r2, #18
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  105dbc:	4311      	orrs	r1, r2

    timer->tim_clk_config = value;
  105dbe:	6201      	str	r1, [r0, #32]
}
  105dc0:	4770      	bx	r14
  105dc2:	bf00      	nop

00105dc4 <timer_drv_int_sta_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sta_en |= (1 << offset);
  105dc4:	2301      	movs	r3, #1
  105dc6:	fa03 f101 	lsl.w	r1, r3, r1
  105dca:	6843      	ldr	r3, [r0, #4]
  105dcc:	4319      	orrs	r1, r3
  105dce:	6041      	str	r1, [r0, #4]
}
  105dd0:	4770      	bx	r14
  105dd2:	bf00      	nop

00105dd4 <timer_drv_int_sig_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sig_en |= (1 << offset);
  105dd4:	2301      	movs	r3, #1
  105dd6:	fa03 f101 	lsl.w	r1, r3, r1
  105dda:	6883      	ldr	r3, [r0, #8]
  105ddc:	4319      	orrs	r1, r3
  105dde:	6081      	str	r1, [r0, #8]
}
  105de0:	4770      	bx	r14
  105de2:	bf00      	nop

00105de4 <timer_drv_ovf_irq_handle>:
 ** \param [in] drv_context
 *****************************************************************************/
enum handler_return timer_drv_ovf_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  105de4:	6803      	ldr	r3, [r0, #0]
  105de6:	f413 7f80 	tst.w	r3, #256	; 0x100
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  105dea:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  105dec:	d006      	beq.n	105dfc <timer_drv_ovf_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  105dee:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  105df2:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  105df4:	b171      	cbz	r1, 105e14 <timer_drv_ovf_irq_handle+0x30>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  105df6:	688b      	ldr	r3, [r1, #8]
  105df8:	b153      	cbz	r3, 105e10 <timer_drv_ovf_irq_handle+0x2c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
            return drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1]();
  105dfa:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CNT_G1_OVF) {
  105dfc:	059b      	lsls	r3, r3, #22
  105dfe:	d507      	bpl.n	105e10 <timer_drv_ovf_irq_handle+0x2c>
        timer->int_sta |= BM_INT_STA_CNT_G1_OVF;
  105e00:	6803      	ldr	r3, [r0, #0]
  105e02:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  105e06:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  105e08:	b181      	cbz	r1, 105e2c <timer_drv_ovf_irq_handle+0x48>
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
  105e0a:	68cb      	ldr	r3, [r1, #12]
  105e0c:	2b00      	cmp	r3, #0
  105e0e:	d1f4      	bne.n	105dfa <timer_drv_ovf_irq_handle+0x16>
        }
    }

    return INT_RESCHEDULE;
}
  105e10:	2001      	movs	r0, #1
  105e12:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  105e14:	6843      	ldr	r3, [r0, #4]
  105e16:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  105e1a:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105e1c:	6883      	ldr	r3, [r0, #8]
  105e1e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  105e22:	6083      	str	r3, [r0, #8]
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  105e24:	688b      	ldr	r3, [r1, #8]
  105e26:	2b00      	cmp	r3, #0
  105e28:	d1e7      	bne.n	105dfa <timer_drv_ovf_irq_handle+0x16>
  105e2a:	e7f1      	b.n	105e10 <timer_drv_ovf_irq_handle+0x2c>
    timer->int_sta_en &= ~(1 << offset);
  105e2c:	6843      	ldr	r3, [r0, #4]
  105e2e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  105e32:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105e34:	6883      	ldr	r3, [r0, #8]
  105e36:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  105e3a:	6083      	str	r3, [r0, #8]
  105e3c:	e7e5      	b.n	105e0a <timer_drv_ovf_irq_handle+0x26>
  105e3e:	bf00      	nop

00105e40 <timer_drv_func_irq_handle>:
 *****************************************************************************/
enum handler_return timer_drv_func_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    //Func A
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  105e40:	6803      	ldr	r3, [r0, #0]
  105e42:	f413 6f80 	tst.w	r3, #1024	; 0x400
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  105e46:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  105e48:	d006      	beq.n	105e58 <timer_drv_func_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  105e4a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  105e4e:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  105e50:	b1e1      	cbz	r1, 105e8c <timer_drv_func_irq_handle+0x4c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e52:	690b      	ldr	r3, [r1, #16]
  105e54:	b1c3      	cbz	r3, 105e88 <timer_drv_func_irq_handle+0x48>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D]();
  105e56:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  105e58:	f013 0f10 	tst.w	r3, #16
        timer->int_sta |= BM_INT_STA_CMP_A;
  105e5c:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  105e5e:	d005      	beq.n	105e6c <timer_drv_func_irq_handle+0x2c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e60:	6a0a      	ldr	r2, [r1, #32]
        timer->int_sta |= BM_INT_STA_CMP_A;
  105e62:	f043 0310 	orr.w	r3, r3, #16
  105e66:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e68:	b172      	cbz	r2, 105e88 <timer_drv_func_irq_handle+0x48>
    }
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;

        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  105e6a:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  105e6c:	f013 0f01 	tst.w	r3, #1
        timer->int_sta |= BM_INT_STA_CPT_A;
  105e70:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  105e72:	d117      	bne.n	105ea4 <timer_drv_func_irq_handle+0x64>
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  105e74:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  105e78:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  105e7a:	d01a      	beq.n	105eb2 <timer_drv_func_irq_handle+0x72>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e7c:	6c0a      	ldr	r2, [r1, #64]	; 0x40
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  105e7e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  105e82:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e84:	2a00      	cmp	r2, #0
  105e86:	d1f0      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
        }
    }

    return INT_NO_RESCHEDULE;
}
  105e88:	2000      	movs	r0, #0
  105e8a:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  105e8c:	6843      	ldr	r3, [r0, #4]
  105e8e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  105e92:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105e94:	6883      	ldr	r3, [r0, #8]
  105e96:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  105e9a:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105e9c:	690b      	ldr	r3, [r1, #16]
  105e9e:	2b00      	cmp	r3, #0
  105ea0:	d1d9      	bne.n	105e56 <timer_drv_func_irq_handle+0x16>
  105ea2:	e7f1      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105ea4:	6b0a      	ldr	r2, [r1, #48]	; 0x30
        timer->int_sta |= BM_INT_STA_CPT_A;
  105ea6:	f043 0301 	orr.w	r3, r3, #1
  105eaa:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105eac:	2a00      	cmp	r2, #0
  105eae:	d0eb      	beq.n	105e88 <timer_drv_func_irq_handle+0x48>
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  105eb0:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  105eb2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  105eb6:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  105eb8:	d10b      	bne.n	105ed2 <timer_drv_func_irq_handle+0x92>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  105eba:	f413 6f00 	tst.w	r3, #2048	; 0x800
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  105ebe:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  105ec0:	d00e      	beq.n	105ee0 <timer_drv_func_irq_handle+0xa0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  105ec2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  105ec6:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  105ec8:	b301      	cbz	r1, 105f0c <timer_drv_func_irq_handle+0xcc>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105eca:	694b      	ldr	r3, [r1, #20]
  105ecc:	2b00      	cmp	r3, #0
  105ece:	d1c2      	bne.n	105e56 <timer_drv_func_irq_handle+0x16>
  105ed0:	e7da      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105ed2:	6d0a      	ldr	r2, [r1, #80]	; 0x50
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  105ed4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  105ed8:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  105eda:	2a00      	cmp	r2, #0
  105edc:	d1c5      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
  105ede:	e7d3      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  105ee0:	f013 0f20 	tst.w	r3, #32
        timer->int_sta |= BM_INT_STA_CMP_B;
  105ee4:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  105ee6:	d006      	beq.n	105ef6 <timer_drv_func_irq_handle+0xb6>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105ee8:	6a4a      	ldr	r2, [r1, #36]	; 0x24
        timer->int_sta |= BM_INT_STA_CMP_B;
  105eea:	f043 0320 	orr.w	r3, r3, #32
  105eee:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105ef0:	2a00      	cmp	r2, #0
  105ef2:	d1ba      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
  105ef4:	e7c8      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  105ef6:	f013 0f02 	tst.w	r3, #2
        timer->int_sta |= BM_INT_STA_CPT_B;
  105efa:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  105efc:	d00f      	beq.n	105f1e <timer_drv_func_irq_handle+0xde>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105efe:	6b4a      	ldr	r2, [r1, #52]	; 0x34
        timer->int_sta |= BM_INT_STA_CPT_B;
  105f00:	f043 0302 	orr.w	r3, r3, #2
  105f04:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105f06:	2a00      	cmp	r2, #0
  105f08:	d1af      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
  105f0a:	e7bd      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  105f0c:	6843      	ldr	r3, [r0, #4]
  105f0e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  105f12:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105f14:	6883      	ldr	r3, [r0, #8]
  105f16:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  105f1a:	6083      	str	r3, [r0, #8]
  105f1c:	e7d5      	b.n	105eca <timer_drv_func_irq_handle+0x8a>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  105f1e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  105f22:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  105f24:	d006      	beq.n	105f34 <timer_drv_func_irq_handle+0xf4>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105f26:	6c4a      	ldr	r2, [r1, #68]	; 0x44
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  105f28:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  105f2c:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105f2e:	2a00      	cmp	r2, #0
  105f30:	d19b      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
  105f32:	e7a9      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  105f34:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  105f38:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  105f3a:	d006      	beq.n	105f4a <timer_drv_func_irq_handle+0x10a>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105f3c:	6d4a      	ldr	r2, [r1, #84]	; 0x54
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  105f3e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  105f42:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  105f44:	2a00      	cmp	r2, #0
  105f46:	d190      	bne.n	105e6a <timer_drv_func_irq_handle+0x2a>
  105f48:	e79e      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  105f4a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  105f4e:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  105f50:	d008      	beq.n	105f64 <timer_drv_func_irq_handle+0x124>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  105f52:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  105f56:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  105f58:	b1e1      	cbz	r1, 105f94 <timer_drv_func_irq_handle+0x154>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105f5a:	698b      	ldr	r3, [r1, #24]
  105f5c:	2b00      	cmp	r3, #0
  105f5e:	f47f af7a 	bne.w	105e56 <timer_drv_func_irq_handle+0x16>
  105f62:	e791      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  105f64:	f013 0f40 	tst.w	r3, #64	; 0x40
        timer->int_sta |= BM_INT_STA_CMP_C;
  105f68:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  105f6a:	d007      	beq.n	105f7c <timer_drv_func_irq_handle+0x13c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105f6c:	6a8a      	ldr	r2, [r1, #40]	; 0x28
        timer->int_sta |= BM_INT_STA_CMP_C;
  105f6e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  105f72:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105f74:	2a00      	cmp	r2, #0
  105f76:	f47f af78 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  105f7a:	e785      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  105f7c:	f013 0f04 	tst.w	r3, #4
        timer->int_sta |= BM_INT_STA_CPT_C;
  105f80:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  105f82:	d010      	beq.n	105fa6 <timer_drv_func_irq_handle+0x166>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105f84:	6b8a      	ldr	r2, [r1, #56]	; 0x38
        timer->int_sta |= BM_INT_STA_CPT_C;
  105f86:	f043 0304 	orr.w	r3, r3, #4
  105f8a:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105f8c:	2a00      	cmp	r2, #0
  105f8e:	f47f af6c 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  105f92:	e779      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  105f94:	6843      	ldr	r3, [r0, #4]
  105f96:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  105f9a:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105f9c:	6883      	ldr	r3, [r0, #8]
  105f9e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  105fa2:	6083      	str	r3, [r0, #8]
  105fa4:	e7d9      	b.n	105f5a <timer_drv_func_irq_handle+0x11a>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  105fa6:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  105faa:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  105fac:	d007      	beq.n	105fbe <timer_drv_func_irq_handle+0x17e>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105fae:	6c8a      	ldr	r2, [r1, #72]	; 0x48
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  105fb0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  105fb4:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105fb6:	2a00      	cmp	r2, #0
  105fb8:	f47f af57 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  105fbc:	e764      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  105fbe:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  105fc2:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  105fc4:	d007      	beq.n	105fd6 <timer_drv_func_irq_handle+0x196>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105fc6:	6d8a      	ldr	r2, [r1, #88]	; 0x58
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  105fc8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  105fcc:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  105fce:	2a00      	cmp	r2, #0
  105fd0:	f47f af4b 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  105fd4:	e758      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  105fd6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  105fda:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  105fdc:	d010      	beq.n	106000 <timer_drv_func_irq_handle+0x1c0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  105fde:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  105fe2:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  105fe4:	b939      	cbnz	r1, 105ff6 <timer_drv_func_irq_handle+0x1b6>
    timer->int_sta_en &= ~(1 << offset);
  105fe6:	6843      	ldr	r3, [r0, #4]
  105fe8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  105fec:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  105fee:	6883      	ldr	r3, [r0, #8]
  105ff0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  105ff4:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  105ff6:	69cb      	ldr	r3, [r1, #28]
  105ff8:	2b00      	cmp	r3, #0
  105ffa:	f47f af2c 	bne.w	105e56 <timer_drv_func_irq_handle+0x16>
  105ffe:	e743      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  106000:	f013 0f80 	tst.w	r3, #128	; 0x80
        timer->int_sta |= BM_INT_STA_CMP_D;
  106004:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  106006:	d007      	beq.n	106018 <timer_drv_func_irq_handle+0x1d8>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106008:	6aca      	ldr	r2, [r1, #44]	; 0x2c
        timer->int_sta |= BM_INT_STA_CMP_D;
  10600a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  10600e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106010:	2a00      	cmp	r2, #0
  106012:	f47f af2a 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  106016:	e737      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  106018:	f013 0f08 	tst.w	r3, #8
        timer->int_sta |= BM_INT_STA_CPT_D;
  10601c:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  10601e:	d007      	beq.n	106030 <timer_drv_func_irq_handle+0x1f0>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106020:	6bca      	ldr	r2, [r1, #60]	; 0x3c
        timer->int_sta |= BM_INT_STA_CPT_D;
  106022:	f043 0308 	orr.w	r3, r3, #8
  106026:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106028:	2a00      	cmp	r2, #0
  10602a:	f47f af1e 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  10602e:	e72b      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  106030:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  106034:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  106036:	d007      	beq.n	106048 <timer_drv_func_irq_handle+0x208>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106038:	6cca      	ldr	r2, [r1, #76]	; 0x4c
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  10603a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  10603e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106040:	2a00      	cmp	r2, #0
  106042:	f47f af12 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  106046:	e71f      	b.n	105e88 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
  106048:	031b      	lsls	r3, r3, #12
  10604a:	f57f af1d 	bpl.w	105e88 <timer_drv_func_irq_handle+0x48>
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  10604e:	6803      	ldr	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106050:	6dca      	ldr	r2, [r1, #92]	; 0x5c
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  106052:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  106056:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  106058:	2a00      	cmp	r2, #0
  10605a:	f47f af06 	bne.w	105e6a <timer_drv_func_irq_handle+0x2a>
  10605e:	e713      	b.n	105e88 <timer_drv_func_irq_handle+0x48>

00106060 <uart_drv_init>:
 **
 ** \param [in] dev         Pointer to device information descriptor
 *****************************************************************************/
void uart_drv_init(DW_APB_UART_uart_TypeDef *dev,
                   uart_drv_context_t *context, uart_drv_cfg_t *cfg)
{
  106060:	b5f0      	push	{r4, r5, r6, r7, r14}
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  106062:	e9d2 3400 	ldrd	r3, r4, [r2]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  106066:	f644 55d3 	movw	r5, #19923	; 0x4dd3
    dev->LCR.DLAB = 1;  //divisor latch access bit
  10606a:	68c7      	ldr	r7, [r0, #12]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  10606c:	f2c1 0562 	movt	r5, #4194	; 0x1062
{
  106070:	b083      	sub	sp, #12
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  106072:	0124      	lsls	r4, r4, #4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  106074:	f047 0780 	orr.w	r7, r7, #128	; 0x80
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  106078:	fbb3 f6f4 	udiv	r6, r3, r4
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  10607c:	fba5 c404 	umull	r12, r4, r5, r4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  106080:	60c7      	str	r7, [r0, #12]
    dev->DLL.DLL = divisor & 0xff;
  106082:	6807      	ldr	r7, [r0, #0]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  106084:	09a4      	lsrs	r4, r4, #6
  106086:	fbb3 f3f4 	udiv	r3, r3, r4
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  10608a:	b2b4      	uxth	r4, r6
    dev->DLL.DLL = divisor & 0xff;
  10608c:	b2f6      	uxtb	r6, r6
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  10608e:	ebc4 1c44 	rsb	r12, r4, r4, lsl #5
    dev->DLL.DLL = divisor & 0xff;
  106092:	f366 0707 	bfi	r7, r6, #0, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  106096:	eb04 068c 	add.w	r6, r4, r12, lsl #2
    dev->DLL.DLL = divisor & 0xff;
  10609a:	6007      	str	r7, [r0, #0]
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  10609c:	0a24      	lsrs	r4, r4, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  10609e:	eba3 03c6 	sub.w	r3, r3, r6, lsl #3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1060a2:	6846      	ldr	r6, [r0, #4]
    frac = frac *16/1000;
  1060a4:	b29b      	uxth	r3, r3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1060a6:	f364 0607 	bfi	r6, r4, #0, #8
    frac = frac *16/1000;
  1060aa:	011b      	lsls	r3, r3, #4
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1060ac:	6046      	str	r6, [r0, #4]
    frac = frac *16/1000;
  1060ae:	fba5 4303 	umull	r4, r3, r5, r3
    dev->DLF.DLF = frac;
  1060b2:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
  1060b6:	f3c3 1383 	ubfx	r3, r3, #6, #4
  1060ba:	f363 0403 	bfi	r4, r3, #0, #4
  1060be:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
    dev->LCR.DLAB = 0;
  1060c2:	68c3      	ldr	r3, [r0, #12]
  1060c4:	f36f 13c7 	bfc	r3, #7, #1
  1060c8:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.data_bits) {
  1060ca:	6893      	ldr	r3, [r2, #8]
  1060cc:	2b03      	cmp	r3, #3
  1060ce:	f200 8091 	bhi.w	1061f4 <uart_drv_init+0x194>
            dev->LCR.DLS = cfg->port_cfg.data_bits;
  1060d2:	68c4      	ldr	r4, [r0, #12]
  1060d4:	f363 0401 	bfi	r4, r3, #0, #2
  1060d8:	60c4      	str	r4, [r0, #12]
    switch (cfg->port_cfg.stop_bits) {
  1060da:	68d3      	ldr	r3, [r2, #12]
  1060dc:	2b01      	cmp	r3, #1
  1060de:	d06c      	beq.n	1061ba <uart_drv_init+0x15a>
  1060e0:	d343      	bcc.n	10616a <uart_drv_init+0x10a>
  1060e2:	2b02      	cmp	r3, #2
  1060e4:	f040 8097 	bne.w	106216 <uart_drv_init+0x1b6>
            if (dev->LCR.DLS == 0)
  1060e8:	68c3      	ldr	r3, [r0, #12]
  1060ea:	079b      	lsls	r3, r3, #30
  1060ec:	f000 80b5 	beq.w	10625a <uart_drv_init+0x1fa>
            dev->LCR.STOP = 1;
  1060f0:	68c3      	ldr	r3, [r0, #12]
  1060f2:	f043 0304 	orr.w	r3, r3, #4
  1060f6:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  1060f8:	6913      	ldr	r3, [r2, #16]
  1060fa:	2b01      	cmp	r3, #1
  1060fc:	d03c      	beq.n	106178 <uart_drv_init+0x118>
  1060fe:	d370      	bcc.n	1061e2 <uart_drv_init+0x182>
  106100:	2b02      	cmp	r3, #2
  106102:	f040 8099 	bne.w	106238 <uart_drv_init+0x1d8>
            dev->LCR.PEN = 0;
  106106:	68c3      	ldr	r3, [r0, #12]
  106108:	f36f 03c3 	bfc	r3, #3, #1
  10610c:	60c3      	str	r3, [r0, #12]
    if (cfg->port_cfg.loopback_enable) {
  10610e:	7d13      	ldrb	r3, [r2, #20]
  106110:	b11b      	cbz	r3, 10611a <uart_drv_init+0xba>
 ** \param [out]
 *****************************************************************************/
void uart_drv_loopback(DW_APB_UART_uart_TypeDef *dev, bool enable)
{
    if (enable) {
        dev->MCR.LOOPBACK = 1;
  106112:	6903      	ldr	r3, [r0, #16]
  106114:	f043 0310 	orr.w	r3, r3, #16
  106118:	6103      	str	r3, [r0, #16]
    if (cfg->fifo_cfg.fifo_enable) {
  10611a:	7e13      	ldrb	r3, [r2, #24]
  10611c:	2b00      	cmp	r3, #0
  10611e:	d134      	bne.n	10618a <uart_drv_init+0x12a>
        context->fcr_shadow.FIFOE = 0;
  106120:	790a      	ldrb	r2, [r1, #4]
  106122:	f363 0200 	bfi	r2, r3, #0, #1
  106126:	710a      	strb	r2, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  106128:	684a      	ldr	r2, [r1, #4]
  10612a:	6082      	str	r2, [r0, #8]
        context->fifo_enable = false;
  10612c:	700b      	strb	r3, [r1, #0]
    context->tx_str_cbk = NULL;
  10612e:	2300      	movs	r3, #0
  106130:	610b      	str	r3, [r1, #16]
    context->rx_str_cbk = NULL;
  106132:	e9c1 3302 	strd	r3, r3, [r1, #8]
    context->tx_shadow.len_rest = 0;
  106136:	e9c1 3305 	strd	r3, r3, [r1, #20]
    context->rx_shadow.len_rest = 0;
  10613a:	e9c1 3307 	strd	r3, r3, [r1, #28]
    dev->IER.ERBFI = 1;   //received data available interrupt
  10613e:	6842      	ldr	r2, [r0, #4]
  106140:	f042 0201 	orr.w	r2, r2, #1
  106144:	6042      	str	r2, [r0, #4]
        dev->IER.ETBEI = 0;
  106146:	6842      	ldr	r2, [r0, #4]
  106148:	f363 0241 	bfi	r2, r3, #1, #1
  10614c:	6042      	str	r2, [r0, #4]
    dev->IER.ELSI = 1;      //receiver line status interrupt
  10614e:	6842      	ldr	r2, [r0, #4]
  106150:	f042 0204 	orr.w	r2, r2, #4
  106154:	6042      	str	r2, [r0, #4]
    dev->IER.EDSSI = 0;     //modem status interrupt
  106156:	6842      	ldr	r2, [r0, #4]
  106158:	f363 02c3 	bfi	r2, r3, #3, #1
  10615c:	6042      	str	r2, [r0, #4]
    dev->IER.PTIME = 0;     //programmable THRE interrupt mode
  10615e:	6842      	ldr	r2, [r0, #4]
  106160:	f363 12c7 	bfi	r2, r3, #7, #1
  106164:	6042      	str	r2, [r0, #4]
}
  106166:	b003      	add	sp, #12
  106168:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dev->LCR.STOP = 0;
  10616a:	68c3      	ldr	r3, [r0, #12]
  10616c:	f36f 0382 	bfc	r3, #2, #1
  106170:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  106172:	6913      	ldr	r3, [r2, #16]
  106174:	2b01      	cmp	r3, #1
  106176:	d1c2      	bne.n	1060fe <uart_drv_init+0x9e>
            dev->LCR.EPS = 1;
  106178:	68c3      	ldr	r3, [r0, #12]
  10617a:	f043 0310 	orr.w	r3, r3, #16
  10617e:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  106180:	68c3      	ldr	r3, [r0, #12]
  106182:	f043 0308 	orr.w	r3, r3, #8
  106186:	60c3      	str	r3, [r0, #12]
  106188:	e7c1      	b.n	10610e <uart_drv_init+0xae>
        context->fcr_shadow.RFIFOR = 1; //reset fifo
  10618a:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  10618c:	69d5      	ldr	r5, [r2, #28]
        context->fcr_shadow.TET =
  10618e:	6a12      	ldr	r2, [r2, #32]
        context->fcr_shadow.XFIFOR = 1;
  106190:	f043 0306 	orr.w	r3, r3, #6
        context->fifo_enable = true;
  106194:	2401      	movs	r4, #1
        context->fcr_shadow.XFIFOR = 1;
  106196:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  106198:	684b      	ldr	r3, [r1, #4]
  10619a:	6083      	str	r3, [r0, #8]
        context->fcr_shadow.RFIFOR = 0;
  10619c:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  10619e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
  1061a2:	f365 1387 	bfi	r3, r5, #6, #2
        context->fcr_shadow.TET =
  1061a6:	f362 1305 	bfi	r3, r2, #4, #2
        context->fcr_shadow.FIFOE = 1;
  1061aa:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  1061ae:	4323      	orrs	r3, r4
  1061b0:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  1061b2:	684b      	ldr	r3, [r1, #4]
  1061b4:	6083      	str	r3, [r0, #8]
        context->fifo_enable = true;
  1061b6:	700c      	strb	r4, [r1, #0]
  1061b8:	e7b9      	b.n	10612e <uart_drv_init+0xce>
            if (dev->LCR.DLS != 0)
  1061ba:	68c3      	ldr	r3, [r0, #12]
  1061bc:	079c      	lsls	r4, r3, #30
  1061be:	d097      	beq.n	1060f0 <uart_drv_init+0x90>
                ASSERT(0);
  1061c0:	f24d 736c 	movw	r3, #55148	; 0xd76c
  1061c4:	f64d 52a4 	movw	r2, #56740	; 0xdda4
  1061c8:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1061cc:	f2c0 0310 	movt	r3, #16
  1061d0:	4670      	mov	r0, r14
  1061d2:	f2c0 0210 	movt	r2, #16
  1061d6:	9300      	str	r3, [sp, #0]
  1061d8:	f2c0 0110 	movt	r1, #16
  1061dc:	2352      	movs	r3, #82	; 0x52
  1061de:	f004 f849 	bl	10a274 <_panic>
            dev->LCR.EPS = 0;
  1061e2:	68c3      	ldr	r3, [r0, #12]
  1061e4:	f36f 1304 	bfc	r3, #4, #1
  1061e8:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  1061ea:	68c3      	ldr	r3, [r0, #12]
  1061ec:	f043 0308 	orr.w	r3, r3, #8
  1061f0:	60c3      	str	r3, [r0, #12]
  1061f2:	e78c      	b.n	10610e <uart_drv_init+0xae>
            ASSERT(0); /* no other bits*/
  1061f4:	f24d 736c 	movw	r3, #55148	; 0xd76c
  1061f8:	f64d 52a4 	movw	r2, #56740	; 0xdda4
  1061fc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106200:	f2c0 0310 	movt	r3, #16
  106204:	4670      	mov	r0, r14
  106206:	f2c0 0210 	movt	r2, #16
  10620a:	9300      	str	r3, [sp, #0]
  10620c:	f2c0 0110 	movt	r1, #16
  106210:	2346      	movs	r3, #70	; 0x46
  106212:	f004 f82f 	bl	10a274 <_panic>
            ASSERT(0);
  106216:	f24d 736c 	movw	r3, #55148	; 0xd76c
  10621a:	f64d 52a4 	movw	r2, #56740	; 0xdda4
  10621e:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106222:	f2c0 0310 	movt	r3, #16
  106226:	4670      	mov	r0, r14
  106228:	f2c0 0210 	movt	r2, #16
  10622c:	9300      	str	r3, [sp, #0]
  10622e:	f2c0 0110 	movt	r1, #16
  106232:	235f      	movs	r3, #95	; 0x5f
  106234:	f004 f81e 	bl	10a274 <_panic>
            ASSERT(0);
  106238:	f24d 736c 	movw	r3, #55148	; 0xd76c
  10623c:	f64d 52a4 	movw	r2, #56740	; 0xdda4
  106240:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106244:	f2c0 0310 	movt	r3, #16
  106248:	4670      	mov	r0, r14
  10624a:	f2c0 0210 	movt	r2, #16
  10624e:	9300      	str	r3, [sp, #0]
  106250:	f2c0 0110 	movt	r1, #16
  106254:	2374      	movs	r3, #116	; 0x74
  106256:	f004 f80d 	bl	10a274 <_panic>
                ASSERT(0);
  10625a:	f24d 736c 	movw	r3, #55148	; 0xd76c
  10625e:	f64d 52a4 	movw	r2, #56740	; 0xdda4
  106262:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106266:	f2c0 0310 	movt	r3, #16
  10626a:	4670      	mov	r0, r14
  10626c:	f2c0 0210 	movt	r2, #16
  106270:	9300      	str	r3, [sp, #0]
  106272:	f2c0 0110 	movt	r1, #16
  106276:	2359      	movs	r3, #89	; 0x59
  106278:	f003 fffc 	bl	10a274 <_panic>

0010627c <uart_drv_putc>:
        if (context->fifo_enable) {
  10627c:	780b      	ldrb	r3, [r1, #0]
  10627e:	b123      	cbz	r3, 10628a <uart_drv_putc+0xe>
            while (dev->USR.TFNF != 1); //wait transmit fifo is not full
  106280:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  106282:	0799      	lsls	r1, r3, #30
  106284:	d5fc      	bpl.n	106280 <uart_drv_putc+0x4>
        writeb(data, &dev->THR);
  106286:	7002      	strb	r2, [r0, #0]
}
  106288:	4770      	bx	r14
            while (dev->LSR.THRE != 1); //wait transmit holding register empty
  10628a:	6943      	ldr	r3, [r0, #20]
  10628c:	069b      	lsls	r3, r3, #26
  10628e:	d4fa      	bmi.n	106286 <uart_drv_putc+0xa>
  106290:	6943      	ldr	r3, [r0, #20]
  106292:	069b      	lsls	r3, r3, #26
  106294:	d5f9      	bpl.n	10628a <uart_drv_putc+0xe>
  106296:	e7f6      	b.n	106286 <uart_drv_putc+0xa>

00106298 <uart_drv_int_cbk_register>:
void uart_drv_int_cbk_register(uart_drv_context_t *context,
                               uart_drv_int_src_t int_src,
                               uart_drv_int_callback cbk)

{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  106298:	b129      	cbz	r1, 1062a6 <uart_drv_int_cbk_register+0xe>
        context->rx_char_cbk = cbk;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  10629a:	2901      	cmp	r1, #1
  10629c:	d005      	beq.n	1062aa <uart_drv_int_cbk_register+0x12>
        context->rx_str_cbk = cbk;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  10629e:	2902      	cmp	r1, #2
        context->tx_str_cbk = cbk;
  1062a0:	bf08      	it	eq
  1062a2:	6102      	streq	r2, [r0, #16]
    }
}
  1062a4:	4770      	bx	r14
        context->rx_char_cbk = cbk;
  1062a6:	6082      	str	r2, [r0, #8]
  1062a8:	4770      	bx	r14
        context->rx_str_cbk = cbk;
  1062aa:	60c2      	str	r2, [r0, #12]
  1062ac:	4770      	bx	r14
  1062ae:	bf00      	nop

001062b0 <uart_drv_int_src_enable>:

void uart_drv_int_src_enable(DW_APB_UART_uart_TypeDef *dev,
                             uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  1062b0:	b141      	cbz	r1, 1062c4 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  1062b2:	2901      	cmp	r1, #1
  1062b4:	d006      	beq.n	1062c4 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  1062b6:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 1;
  1062b8:	bf02      	ittt	eq
  1062ba:	6843      	ldreq	r3, [r0, #4]
  1062bc:	f043 0302 	orreq.w	r3, r3, #2
  1062c0:	6043      	streq	r3, [r0, #4]
    }
}
  1062c2:	4770      	bx	r14
        dev->IER.ERBFI = 1;
  1062c4:	6843      	ldr	r3, [r0, #4]
  1062c6:	f043 0301 	orr.w	r3, r3, #1
  1062ca:	6043      	str	r3, [r0, #4]
  1062cc:	4770      	bx	r14
  1062ce:	bf00      	nop

001062d0 <uart_drv_int_src_disable>:

void uart_drv_int_src_disable(DW_APB_UART_uart_TypeDef *dev,
                              uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  1062d0:	b141      	cbz	r1, 1062e4 <uart_drv_int_src_disable+0x14>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  1062d2:	2901      	cmp	r1, #1
  1062d4:	d00b      	beq.n	1062ee <uart_drv_int_src_disable+0x1e>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  1062d6:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 0;
  1062d8:	bf02      	ittt	eq
  1062da:	6843      	ldreq	r3, [r0, #4]
  1062dc:	f36f 0341 	bfceq	r3, #1, #1
  1062e0:	6043      	streq	r3, [r0, #4]
    }
}
  1062e2:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  1062e4:	6843      	ldr	r3, [r0, #4]
  1062e6:	f361 0300 	bfi	r3, r1, #0, #1
  1062ea:	6043      	str	r3, [r0, #4]
  1062ec:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  1062ee:	6843      	ldr	r3, [r0, #4]
  1062f0:	f36f 0300 	bfc	r3, #0, #1
  1062f4:	6043      	str	r3, [r0, #4]
  1062f6:	4770      	bx	r14

001062f8 <uart_drv_irq_handle>:
enum handler_return uart_drv_irq_handle(DW_APB_UART_uart_TypeDef *dev,
                                        uart_drv_context_t *context)
{
    bool resched = true;
    char data = 0;
    IIR_Type IIR = dev->IIR;        //interrupt identification register
  1062f8:	6883      	ldr	r3, [r0, #8]
{
  1062fa:	b570      	push	{r4, r5, r6, r14}
  1062fc:	460c      	mov	r4, r1
    LSR_Type LSR = dev->LSR;        //line status register

    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  1062fe:	b2db      	uxtb	r3, r3
{
  106300:	4605      	mov	r5, r0
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  106302:	f003 020d 	and.w	r2, r3, #13
    LSR_Type LSR = dev->LSR;        //line status register
  106306:	6941      	ldr	r1, [r0, #20]
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  106308:	2a04      	cmp	r2, #4
  10630a:	d13a      	bne.n	106382 <uart_drv_irq_handle+0x8a>
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
        //rx irq
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
                || LSR.ADDR_RCVD == UART_DRV_LSR_RX_ADDR_IND) {
  10630c:	f240 1301 	movw	r3, #257	; 0x101
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
  106310:	420b      	tst	r3, r1
  106312:	d034      	beq.n	10637e <uart_drv_irq_handle+0x86>
            if (context->fifo_enable) {
  106314:	7826      	ldrb	r6, [r4, #0]
  106316:	68e2      	ldr	r2, [r4, #12]
  106318:	2e00      	cmp	r6, #0
  10631a:	d163      	bne.n	1063e4 <uart_drv_irq_handle+0xec>
                    }
                }
                else
#endif
                {
                    data = dev->RBR.RBR8;
  10631c:	6800      	ldr	r0, [r0, #0]
  10631e:	b2c0      	uxtb	r0, r0
                }

                //asynchronous receive
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  106320:	2a00      	cmp	r2, #0
  106322:	d079      	beq.n	106418 <uart_drv_irq_handle+0x120>
  106324:	6a23      	ldr	r3, [r4, #32]
  106326:	2b00      	cmp	r3, #0
  106328:	d076      	beq.n	106418 <uart_drv_irq_handle+0x120>
    *context->rx_shadow.rx_ptr = data;
  10632a:	69e3      	ldr	r3, [r4, #28]
  10632c:	7018      	strb	r0, [r3, #0]
    context->rx_shadow.len_rest -= 1;
  10632e:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  106332:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  106334:	3b01      	subs	r3, #1
  106336:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  10633a:	b96b      	cbnz	r3, 106358 <uart_drv_irq_handle+0x60>
        dev->IER.ERBFI = 0;
  10633c:	686a      	ldr	r2, [r5, #4]
  10633e:	f363 0200 	bfi	r2, r3, #0, #1
  106342:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  106344:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  106346:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  106348:	f363 1205 	bfi	r2, r3, #4, #2
  10634c:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  10634e:	6862      	ldr	r2, [r4, #4]
  106350:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  106352:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  106354:	4788      	blx	r1
  106356:	6a23      	ldr	r3, [r4, #32]
                    uart_drv_async_rx_char(dev, context, data);

                    if (context->rx_shadow.len_rest) {
  106358:	fab3 f083 	clz	r0, r3
  10635c:	0940      	lsrs	r0, r0, #5
            }
        }
    }

    return resched ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
}
  10635e:	bd70      	pop	{r4, r5, r6, r15}
            if (context->tx_shadow.len_rest && dev->LSR.THRE) {
  106360:	2b00      	cmp	r3, #0
  106362:	d065      	beq.n	106430 <uart_drv_irq_handle+0x138>
  106364:	6943      	ldr	r3, [r0, #20]
  106366:	069b      	lsls	r3, r3, #26
  106368:	d509      	bpl.n	10637e <uart_drv_irq_handle+0x86>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  10636a:	6963      	ldr	r3, [r4, #20]
  10636c:	1c5a      	adds	r2, r3, #1
  10636e:	6162      	str	r2, [r4, #20]
  106370:	781b      	ldrb	r3, [r3, #0]
  106372:	7003      	strb	r3, [r0, #0]
                context->tx_shadow.len_rest -= 1;
  106374:	69a3      	ldr	r3, [r4, #24]
  106376:	3b01      	subs	r3, #1
  106378:	61a3      	str	r3, [r4, #24]
        if (context->tx_shadow.len_rest == 0) {
  10637a:	2b00      	cmp	r3, #0
  10637c:	d058      	beq.n	106430 <uart_drv_irq_handle+0x138>
  10637e:	2001      	movs	r0, #1
}
  106380:	bd70      	pop	{r4, r5, r6, r15}
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
  106382:	f003 030f 	and.w	r3, r3, #15
    else if (IIR.IID == UART_DRV_IID_RX_CHAR_TIMEOUT) {
  106386:	2b0c      	cmp	r3, #12
  106388:	d043      	beq.n	106412 <uart_drv_irq_handle+0x11a>
    else if (IIR.IID == UART_DRV_IID_THR_EMPTY) {
  10638a:	2b02      	cmp	r3, #2
  10638c:	d1f7      	bne.n	10637e <uart_drv_irq_handle+0x86>
  10638e:	69a3      	ldr	r3, [r4, #24]
        if (context->fifo_enable) {
  106390:	7822      	ldrb	r2, [r4, #0]
  106392:	2a00      	cmp	r2, #0
  106394:	d0e4      	beq.n	106360 <uart_drv_irq_handle+0x68>
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  106396:	b953      	cbnz	r3, 1063ae <uart_drv_irq_handle+0xb6>
  106398:	e04a      	b.n	106430 <uart_drv_irq_handle+0x138>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  10639a:	6963      	ldr	r3, [r4, #20]
  10639c:	1c5a      	adds	r2, r3, #1
  10639e:	6162      	str	r2, [r4, #20]
  1063a0:	781b      	ldrb	r3, [r3, #0]
  1063a2:	702b      	strb	r3, [r5, #0]
                context->tx_shadow.len_rest -= 1;
  1063a4:	69a3      	ldr	r3, [r4, #24]
  1063a6:	3b01      	subs	r3, #1
  1063a8:	61a3      	str	r3, [r4, #24]
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  1063aa:	2b00      	cmp	r3, #0
  1063ac:	d040      	beq.n	106430 <uart_drv_irq_handle+0x138>
  1063ae:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  1063b0:	079a      	lsls	r2, r3, #30
  1063b2:	d5e4      	bpl.n	10637e <uart_drv_irq_handle+0x86>
  1063b4:	e7f1      	b.n	10639a <uart_drv_irq_handle+0xa2>
    *context->rx_shadow.rx_ptr = data;
  1063b6:	69e2      	ldr	r2, [r4, #28]
  1063b8:	7013      	strb	r3, [r2, #0]
    context->rx_shadow.len_rest -= 1;
  1063ba:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  1063be:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  1063c0:	3b01      	subs	r3, #1
  1063c2:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  1063c6:	b963      	cbnz	r3, 1063e2 <uart_drv_irq_handle+0xea>
        dev->IER.ERBFI = 0;
  1063c8:	686a      	ldr	r2, [r5, #4]
  1063ca:	f363 0200 	bfi	r2, r3, #0, #1
  1063ce:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  1063d0:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  1063d2:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  1063d4:	f363 1205 	bfi	r2, r3, #4, #2
  1063d8:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  1063da:	6862      	ldr	r2, [r4, #4]
  1063dc:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  1063de:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  1063e0:	4788      	blx	r1
  1063e2:	68e2      	ldr	r2, [r4, #12]
                while (dev->USR.RFNE) {
  1063e4:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  1063e6:	0719      	lsls	r1, r3, #28
  1063e8:	d50e      	bpl.n	106408 <uart_drv_irq_handle+0x110>
                        data = dev->RBR.RBR8;
  1063ea:	682b      	ldr	r3, [r5, #0]
  1063ec:	b2db      	uxtb	r3, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  1063ee:	b11a      	cbz	r2, 1063f8 <uart_drv_irq_handle+0x100>
  1063f0:	6a21      	ldr	r1, [r4, #32]
        context->rx_str_cbk(data);
  1063f2:	4618      	mov	r0, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  1063f4:	2900      	cmp	r1, #0
  1063f6:	d1de      	bne.n	1063b6 <uart_drv_irq_handle+0xbe>
                             || (context->rx_char_cbk(data) != 1)) {
  1063f8:	4618      	mov	r0, r3
                    else if ((context->rx_char_cbk == NULL)
  1063fa:	68a3      	ldr	r3, [r4, #8]
  1063fc:	b31b      	cbz	r3, 106446 <uart_drv_irq_handle+0x14e>
                             || (context->rx_char_cbk(data) != 1)) {
  1063fe:	4798      	blx	r3
  106400:	2801      	cmp	r0, #1
  106402:	d0ee      	beq.n	1063e2 <uart_drv_irq_handle+0xea>
  106404:	68e2      	ldr	r2, [r4, #12]
                        resched = false;
  106406:	2600      	movs	r6, #0
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  106408:	b182      	cbz	r2, 10642c <uart_drv_irq_handle+0x134>
  10640a:	6a23      	ldr	r3, [r4, #32]
  10640c:	b173      	cbz	r3, 10642c <uart_drv_irq_handle+0x134>
  10640e:	2000      	movs	r0, #0
}
  106410:	bd70      	pop	{r4, r5, r6, r15}
        data = dev->RBR.RBR8;
  106412:	6803      	ldr	r3, [r0, #0]
  106414:	2001      	movs	r0, #1
}
  106416:	bd70      	pop	{r4, r5, r6, r15}
                else if ((context->rx_char_cbk == NULL)
  106418:	68a3      	ldr	r3, [r4, #8]
  10641a:	2b00      	cmp	r3, #0
  10641c:	d0f7      	beq.n	10640e <uart_drv_irq_handle+0x116>
                         || (context->rx_char_cbk(data) != 1)) {
  10641e:	4798      	blx	r3
  106420:	f1a0 0001 	sub.w	r0, r0, #1
  106424:	fab0 f080 	clz	r0, r0
  106428:	0940      	lsrs	r0, r0, #5
}
  10642a:	bd70      	pop	{r4, r5, r6, r15}
  10642c:	4630      	mov	r0, r6
  10642e:	bd70      	pop	{r4, r5, r6, r15}
        dev->IER.ETBEI = 0;
  106430:	686b      	ldr	r3, [r5, #4]
  106432:	f36f 0341 	bfc	r3, #1, #1
  106436:	606b      	str	r3, [r5, #4]
            if (context->tx_str_cbk) {
  106438:	6923      	ldr	r3, [r4, #16]
  10643a:	2b00      	cmp	r3, #0
  10643c:	d09f      	beq.n	10637e <uart_drv_irq_handle+0x86>
                context->tx_str_cbk(true);
  10643e:	2001      	movs	r0, #1
  106440:	4798      	blx	r3
  106442:	2001      	movs	r0, #1
}
  106444:	bd70      	pop	{r4, r5, r6, r15}
                        resched = false;
  106446:	461e      	mov	r6, r3
  106448:	e7de      	b.n	106408 <uart_drv_irq_handle+0x110>
  10644a:	bf00      	nop

0010644c <dcf_early_init>:
}

void dcf_early_init(void)
{
    return;
}
  10644c:	4770      	bx	r14
  10644e:	bf00      	nop

00106450 <hal_clock_get_instance>:
//!
//! \return clkgen hanle
//
//*****************************************************************************
static clkgen_instance_t *hal_clock_get_instance(void)
{
  106450:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  106452:	f3ef 8000 	mrs	r0, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  106456:	f010 0080 	ands.w	r0, r0, #128	; 0x80
  10645a:	d124      	bne.n	1064a6 <hal_clock_get_instance+0x56>
    __asm__ volatile("cpsid i");
  10645c:	b672      	cpsid	i
    *statep = state;
  10645e:	f247 01dc 	movw	r1, #28892	; 0x70dc
  106462:	2401      	movs	r4, #1
    *lock = 1;
  106464:	f247 02cc 	movw	r2, #28876	; 0x70cc
    *statep = state;
  106468:	f2c0 0111 	movt	r1, #17
    //spin_lock_saved_state_t states;
    spin_lock_irqsave(&clkgen_spin_lock, spin_lock_states);

    if (g_ClkgenInstance.occupied != 1) {
  10646c:	f247 03d0 	movw	r3, #28880	; 0x70d0
    *lock = 1;
  106470:	f2c0 0211 	movt	r2, #17
    *statep = state;
  106474:	600c      	str	r4, [r1, #0]
  106476:	f2c0 0311 	movt	r3, #17
  10647a:	7919      	ldrb	r1, [r3, #4]
    *lock = 1;
  10647c:	6014      	str	r4, [r2, #0]
  10647e:	42a1      	cmp	r1, r4
  106480:	d027      	beq.n	1064d2 <hal_clock_get_instance+0x82>
    *controllerTable = &s_ClkgenDrvInterface;
  106482:	f24f 12ec 	movw	r2, #61932	; 0xf1ec
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
  106486:	2100      	movs	r1, #0
        /* get clkgen driver API table */
        hal_clock_get_controller_interface(&(g_ClkgenInstance.controllerTable));

        if (g_ClkgenInstance.controllerTable) {
            g_ClkgenInstance.occupied = 1;
  106488:	2401      	movs	r4, #1
    *controllerTable = &s_ClkgenDrvInterface;
  10648a:	f2c0 0210 	movt	r2, #16
            //sec clkgen
            g_ClkgenInstance.controllerTable->get_default_config(&
  10648e:	4812      	ldr	r0, [pc, #72]	; (1064d8 <hal_clock_get_instance+0x88>)
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
  106490:	e9c3 1201 	strd	r1, r2, [r3, #4]
  106494:	6019      	str	r1, [r3, #0]
            g_ClkgenInstance.occupied = 1;
  106496:	711c      	strb	r4, [r3, #4]
            g_ClkgenInstance.controllerTable->get_default_config(&
  106498:	f7fc fd48 	bl	102f2c <clkgen_get_default_config>
                    (g_ClkgenInstance.def_cfg));
        }

        //spin_unlock_irqrestore(&clkgen_spin_lock, states);
        LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "hal_clock_get_instance is ok \n");
        return &g_ClkgenInstance;
  10649c:	f247 00d0 	movw	r0, #28880	; 0x70d0
  1064a0:	f2c0 0011 	movt	r0, #17

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_get_instance is failed \n");
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
    return NULL;
}
  1064a4:	bd10      	pop	{r4, r15}
    *statep = state;
  1064a6:	f247 01dc 	movw	r1, #28892	; 0x70dc
  1064aa:	2000      	movs	r0, #0
    *lock = 1;
  1064ac:	2401      	movs	r4, #1
    *statep = state;
  1064ae:	f2c0 0111 	movt	r1, #17
    *lock = 1;
  1064b2:	f247 02cc 	movw	r2, #28876	; 0x70cc
    if (g_ClkgenInstance.occupied != 1) {
  1064b6:	f247 03d0 	movw	r3, #28880	; 0x70d0
    *statep = state;
  1064ba:	6008      	str	r0, [r1, #0]
    *lock = 1;
  1064bc:	f2c0 0211 	movt	r2, #17
  1064c0:	f2c0 0311 	movt	r3, #17
  1064c4:	7919      	ldrb	r1, [r3, #4]
  1064c6:	6014      	str	r4, [r2, #0]
  1064c8:	42a1      	cmp	r1, r4
    *lock = 0;
  1064ca:	bf08      	it	eq
  1064cc:	6010      	streq	r0, [r2, #0]
  1064ce:	d1d8      	bne.n	106482 <hal_clock_get_instance+0x32>
  1064d0:	e7e8      	b.n	1064a4 <hal_clock_get_instance+0x54>
  1064d2:	6010      	str	r0, [r2, #0]
    __asm__ volatile("cpsie i");
  1064d4:	b662      	cpsie	i
}
  1064d6:	bd10      	pop	{r4, r15}
  1064d8:	001170d5 	.word	0x001170d5

001064dc <hal_clock_release_handle.part.2>:
//
//*****************************************************************************
bool hal_clock_release_handle(void *handle)
{
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((handle != NULL));
  1064dc:	f24e 23a4 	movw	r3, #58020	; 0xe2a4
  1064e0:	f24e 2274 	movw	r2, #57972	; 0xe274
bool hal_clock_release_handle(void *handle)
  1064e4:	b500      	push	{r14}
    ASSERT((handle != NULL));
  1064e6:	f2c0 0310 	movt	r3, #16
  1064ea:	f64b 615c 	movw	r1, #48732	; 0xbe5c
bool hal_clock_release_handle(void *handle)
  1064ee:	b083      	sub	sp, #12
    ASSERT((handle != NULL));
  1064f0:	4670      	mov	r0, r14
  1064f2:	f2c0 0210 	movt	r2, #16
  1064f6:	9300      	str	r3, [sp, #0]
  1064f8:	f2c0 0110 	movt	r1, #16
  1064fc:	23b9      	movs	r3, #185	; 0xb9
  1064fe:	f003 feb9 	bl	10a274 <_panic>
  106502:	bf00      	nop

00106504 <hal_clock_release_instance>:
    ASSERT((clkgenInstance != NULL));
  106504:	b178      	cbz	r0, 106526 <hal_clock_release_instance+0x22>
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  106506:	f247 02dc 	movw	r2, #28892	; 0x70dc
  10650a:	f247 03cc 	movw	r3, #28876	; 0x70cc
  10650e:	f2c0 0211 	movt	r2, #17
    clkgenInstance->occupied = 0;
  106512:	2100      	movs	r1, #0
  106514:	f2c0 0311 	movt	r3, #17
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  106518:	6812      	ldr	r2, [r2, #0]
  10651a:	6019      	str	r1, [r3, #0]
    clkgenInstance->occupied = 0;
  10651c:	7101      	strb	r1, [r0, #4]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10651e:	07d3      	lsls	r3, r2, #31
  106520:	d500      	bpl.n	106524 <hal_clock_release_instance+0x20>
  106522:	b662      	cpsie	i
  106524:	4770      	bx	r14
    ASSERT((clkgenInstance != NULL));
  106526:	f24e 23b8 	movw	r3, #58040	; 0xe2b8
  10652a:	f24e 2274 	movw	r2, #57972	; 0xe274
{
  10652e:	b500      	push	{r14}
    ASSERT((clkgenInstance != NULL));
  106530:	f2c0 0310 	movt	r3, #16
  106534:	f64b 615c 	movw	r1, #48732	; 0xbe5c
{
  106538:	b083      	sub	sp, #12
  10653a:	4670      	mov	r0, r14
    ASSERT((clkgenInstance != NULL));
  10653c:	f2c0 0210 	movt	r2, #16
  106540:	9300      	str	r3, [sp, #0]
  106542:	f2c0 0110 	movt	r1, #16
  106546:	2387      	movs	r3, #135	; 0x87
  106548:	f003 fe94 	bl	10a274 <_panic>

0010654c <hal_clock_creat_handle>:
{
  10654c:	b510      	push	{r4, r14}
  10654e:	b082      	sub	sp, #8
    ASSERT((handle != NULL));
  106550:	b138      	cbz	r0, 106562 <hal_clock_creat_handle+0x16>
  106552:	4604      	mov	r4, r0
    clkgenInstance = hal_clock_get_instance();
  106554:	f7ff ff7c 	bl	106450 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  106558:	b108      	cbz	r0, 10655e <hal_clock_creat_handle+0x12>
    *handle = clkgenInstance;
  10655a:	6020      	str	r0, [r4, #0]
    return true;
  10655c:	2001      	movs	r0, #1
}
  10655e:	b002      	add	sp, #8
  106560:	bd10      	pop	{r4, r15}
    ASSERT((handle != NULL));
  106562:	f24e 23a4 	movw	r3, #58020	; 0xe2a4
  106566:	f24e 2274 	movw	r2, #57972	; 0xe274
  10656a:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10656e:	f2c0 0310 	movt	r3, #16
  106572:	4670      	mov	r0, r14
  106574:	f2c0 0210 	movt	r2, #16
  106578:	9300      	str	r3, [sp, #0]
  10657a:	f2c0 0110 	movt	r1, #16
  10657e:	239b      	movs	r3, #155	; 0x9b
  106580:	f003 fe78 	bl	10a274 <_panic>

00106584 <hal_clock_release_handle>:
{
  106584:	b508      	push	{r3, r14}
    ASSERT((handle != NULL));
  106586:	b118      	cbz	r0, 106590 <hal_clock_release_handle+0xc>
    l_clkgenInstance = (clkgen_instance_t *)handle;
    hal_clock_release_instance(l_clkgenInstance);
  106588:	f7ff ffbc 	bl	106504 <hal_clock_release_instance>
    // mutex_destroy(&l_clkgenInstance->clkgenMutex);
    return true;
}
  10658c:	2001      	movs	r0, #1
  10658e:	bd08      	pop	{r3, r15}
  106590:	f7ff ffa4 	bl	1064dc <hal_clock_release_handle.part.2>

00106594 <hal_clock_osc_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_osc_init(void *g_handle, uint32_t res_glb_idx,
                        clkgen_app_fsrefclk_sel_type src_sel_mask, bool en_safety_mode)
{
  106594:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret = -1;
    vaddr_t clkgen_base_addr = 0x0;
    paddr_t phy_addr;
    int32_t scr_idx = -1;
  106596:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
{
  10659a:	b085      	sub	sp, #20
    int32_t scr_idx = -1;
  10659c:	9503      	str	r5, [sp, #12]
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10659e:	b1c8      	cbz	r0, 1065d4 <hal_clock_osc_init+0x40>
  1065a0:	4616      	mov	r6, r2
  1065a2:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &scr_idx);
  1065a4:	4608      	mov	r0, r1
  1065a6:	aa03      	add	r2, sp, #12
  1065a8:	461f      	mov	r7, r3
  1065aa:	a902      	add	r1, sp, #8
  1065ac:	f000 fef6 	bl	10739c <res_get_info_by_id>

    if (ret == -1) {
  1065b0:	3001      	adds	r0, #1
  1065b2:	d00c      	beq.n	1065ce <hal_clock_osc_init+0x3a>
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_osc_init res_glb_idx:0x%x,src_sel_mask:0x%x,en_safety_mode:%d\n",
                  res_glb_idx, src_sel_mask, en_safety_mode);

    if ((scr_idx >= DEFAULT_FSREFCLK_IDX_START)
  1065b4:	9903      	ldr	r1, [sp, #12]
  1065b6:	297f      	cmp	r1, #127	; 0x7f
  1065b8:	dd09      	ble.n	1065ce <hal_clock_osc_init+0x3a>
            && l_clkgenInstance->controllerTable->fsrefclk_sel) {
  1065ba:	68a3      	ldr	r3, [r4, #8]
  1065bc:	685c      	ldr	r4, [r3, #4]
  1065be:	b1dc      	cbz	r4, 1065f8 <hal_clock_osc_init+0x64>
        /*init fsrefclk*/
        if (l_clkgenInstance->controllerTable->fsrefclk_sel(clkgen_base_addr,
  1065c0:	463b      	mov	r3, r7
  1065c2:	4632      	mov	r2, r6
  1065c4:	9802      	ldr	r0, [sp, #8]
  1065c6:	3980      	subs	r1, #128	; 0x80
  1065c8:	47a0      	blx	r4

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_osc_init failed scr_idx:%d,res_glb_idx:0x%x \n", scr_idx,
                  res_glb_idx);
    return false;
}
  1065ca:	b005      	add	sp, #20
  1065cc:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return false;
  1065ce:	2000      	movs	r0, #0
}
  1065d0:	b005      	add	sp, #20
  1065d2:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT((g_handle != NULL));
  1065d4:	f24e 2360 	movw	r3, #57952	; 0xe260
  1065d8:	f24e 2274 	movw	r2, #57972	; 0xe274
  1065dc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1065e0:	f2c0 0310 	movt	r3, #16
  1065e4:	4670      	mov	r0, r14
  1065e6:	f2c0 0210 	movt	r2, #16
  1065ea:	9300      	str	r3, [sp, #0]
  1065ec:	f2c0 0110 	movt	r1, #16
  1065f0:	f240 13a3 	movw	r3, #419	; 0x1a3
  1065f4:	f003 fe3e 	bl	10a274 <_panic>
        return false;
  1065f8:	4620      	mov	r0, r4
  1065fa:	e7e9      	b.n	1065d0 <hal_clock_osc_init+0x3c>

001065fc <hal_clock_ip_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_ip_init(void *g_handle, paddr_t phy_addr,
                       const clkgen_ip_slice_t *ip_slice_default)
{
  1065fc:	b530      	push	{r4, r5, r14}
  1065fe:	460b      	mov	r3, r1
  106600:	b083      	sub	sp, #12
    vaddr_t clkgen_base_addr = 0x0;
    //paddr_t phy_addr;
    clkgen_instance_t *l_clkgenInstance = NULL;
    uint8_t ip_slice_idx = ip_slice_default->slice_index;
  106602:	7811      	ldrb	r1, [r2, #0]
    ASSERT((g_handle != NULL));
  106604:	b160      	cbz	r0, 106620 <hal_clock_ip_init+0x24>
  106606:	4614      	mov	r4, r2
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->ip_slice_set) {
  106608:	6882      	ldr	r2, [r0, #8]
  10660a:	68d5      	ldr	r5, [r2, #12]
  10660c:	b1d5      	cbz	r5, 106644 <hal_clock_ip_init+0x48>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->ip_slice_set(clkgen_base_addr,
  10660e:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
  106612:	4618      	mov	r0, r3
  106614:	8d23      	ldrh	r3, [r4, #40]	; 0x28
  106616:	8da4      	ldrh	r4, [r4, #44]	; 0x2c
  106618:	9400      	str	r4, [sp, #0]
  10661a:	47a8      	blx	r5
        }
    }

    LTRACEF("hal_clock_ip_init fail %d\n", ip_slice_idx);
    return false;
}
  10661c:	b003      	add	sp, #12
  10661e:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  106620:	f24e 2360 	movw	r3, #57952	; 0xe260
  106624:	f24e 2274 	movw	r2, #57972	; 0xe274
  106628:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10662c:	f2c0 0310 	movt	r3, #16
  106630:	4670      	mov	r0, r14
  106632:	f2c0 0210 	movt	r2, #16
  106636:	9300      	str	r3, [sp, #0]
  106638:	f2c0 0110 	movt	r1, #16
  10663c:	f44f 73e9 	mov.w	r3, #466	; 0x1d2
  106640:	f003 fe18 	bl	10a274 <_panic>
    return false;
  106644:	4628      	mov	r0, r5
  106646:	e7e9      	b.n	10661c <hal_clock_ip_init+0x20>

00106648 <hal_clock_bus_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_bus_init(void *g_handle, paddr_t phy_addr,
                        const clkgen_bus_slice_t *bus_slice_default)
{
  106648:	b570      	push	{r4, r5, r6, r14}
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_bus_slice_drv_t bus_clock_drv_cfg;
    uint8_t bus_slice_idx = bus_slice_default->slice_index;
  10664a:	6814      	ldr	r4, [r2, #0]
{
  10664c:	b086      	sub	sp, #24
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  10664e:	b388      	cbz	r0, 1066b4 <hal_clock_bus_init+0x6c>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->bus_slice_switch) {
  106650:	6883      	ldr	r3, [r0, #8]
  106652:	699b      	ldr	r3, [r3, #24]
  106654:	2b00      	cmp	r3, #0
  106656:	d03f      	beq.n	1066d8 <hal_clock_bus_init+0x90>
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
        bus_clock_drv_cfg.clk_a_b_switch =
            bus_slice_default->clk_a_b_select;
        bus_clock_drv_cfg.clk_src_sel_a =
            bus_slice_default->clk_src_select_a_num;
        bus_clock_drv_cfg.clk_src_sel_b =
  106658:	6c95      	ldr	r5, [r2, #72]	; 0x48
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
  10665a:	b2e4      	uxtb	r4, r4
        bus_clock_drv_cfg.clk_a_b_switch =
  10665c:	f892 604c 	ldrb.w	r6, [r2, #76]	; 0x4c
        bus_clock_drv_cfg.clk_src_sel_b =
  106660:	f88d 500e 	strb.w	r5, [r13, #14]
        bus_clock_drv_cfg.bus_slice_idx = bus_slice_idx;
  106664:	9402      	str	r4, [sp, #8]
            bus_slice_default->clk_src_select_b_num;
        bus_clock_drv_cfg.pre_div_a = bus_slice_default->pre_div_a;
  106666:	f892 504d 	ldrb.w	r5, [r2, #77]	; 0x4d
        bus_clock_drv_cfg.clk_src_sel_a =
  10666a:	f892 4024 	ldrb.w	r4, [r2, #36]	; 0x24
        bus_clock_drv_cfg.pre_div_a = bus_slice_default->pre_div_a;
  10666e:	f88d 500f 	strb.w	r5, [r13, #15]
        bus_clock_drv_cfg.clk_src_sel_a =
  106672:	f88d 400d 	strb.w	r4, [r13, #13]
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
        bus_clock_drv_cfg.gasket_cfg.m_div_num =
  106676:	f892 5050 	ldrb.w	r5, [r2, #80]	; 0x50
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
  10667a:	f892 404f 	ldrb.w	r4, [r2, #79]	; 0x4f
        bus_clock_drv_cfg.clk_a_b_switch =
  10667e:	f88d 600c 	strb.w	r6, [r13, #12]
        bus_clock_drv_cfg.post_div = bus_slice_default->post_div;
  106682:	f88d 4011 	strb.w	r4, [r13, #17]
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
            bus_slice_default->p_div;
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
            bus_slice_default->q_div;

        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  106686:	4608      	mov	r0, r1
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
  106688:	f892 4052 	ldrb.w	r4, [r2, #82]	; 0x52
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
  10668c:	f892 104e 	ldrb.w	r1, [r2, #78]	; 0x4e
        bus_clock_drv_cfg.gasket_cfg.m_div_num =
  106690:	f88d 5012 	strb.w	r5, [r13, #18]
        bus_clock_drv_cfg.pre_div_b = bus_slice_default->pre_div_b;
  106694:	f88d 1010 	strb.w	r1, [r13, #16]
        bus_clock_drv_cfg.gasket_cfg.n_div_num =
  106698:	f892 1051 	ldrb.w	r1, [r2, #81]	; 0x51
        bus_clock_drv_cfg.gasket_cfg.p_div_num =
  10669c:	f88d 4014 	strb.w	r4, [r13, #20]
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
  1066a0:	f892 2053 	ldrb.w	r2, [r2, #83]	; 0x53
        bus_clock_drv_cfg.gasket_cfg.n_div_num =
  1066a4:	f88d 1013 	strb.w	r1, [r13, #19]
        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  1066a8:	a902      	add	r1, sp, #8
        bus_clock_drv_cfg.gasket_cfg.q_div_num =
  1066aa:	f88d 2015 	strb.w	r2, [r13, #21]
        if (l_clkgenInstance->controllerTable->bus_slice_switch(clkgen_base_addr,
  1066ae:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_bus_init slice_idx:%d fail\n", bus_slice_idx);
    return false;
}
  1066b0:	b006      	add	sp, #24
  1066b2:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  1066b4:	f24e 2360 	movw	r3, #57952	; 0xe260
  1066b8:	f24e 2274 	movw	r2, #57972	; 0xe274
  1066bc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1066c0:	f2c0 0310 	movt	r3, #16
  1066c4:	4670      	mov	r0, r14
  1066c6:	f2c0 0210 	movt	r2, #16
  1066ca:	9300      	str	r3, [sp, #0]
  1066cc:	f2c0 0110 	movt	r1, #16
  1066d0:	f240 2303 	movw	r3, #515	; 0x203
  1066d4:	f003 fdce 	bl	10a274 <_panic>
    return false;
  1066d8:	4618      	mov	r0, r3
  1066da:	e7e9      	b.n	1066b0 <hal_clock_bus_init+0x68>

001066dc <hal_saf_clock_set_default>:
{
  1066dc:	b5f0      	push	{r4, r5, r6, r7, r14}
  1066de:	4677      	mov	r7, r14
  1066e0:	b083      	sub	sp, #12
    clkgenInstance = hal_clock_get_instance();
  1066e2:	f7ff feb5 	bl	106450 <hal_clock_get_instance>
  1066e6:	f24e 3480 	movw	r4, #58240	; 0xe380
  1066ea:	f2c0 0410 	movt	r4, #16
  1066ee:	f504 765d 	add.w	r6, r4, #884	; 0x374
    if (clkgenInstance == NULL) {
  1066f2:	4605      	mov	r5, r0
  1066f4:	b918      	cbnz	r0, 1066fe <hal_saf_clock_set_default+0x22>
  1066f6:	e030      	b.n	10675a <hal_saf_clock_set_default+0x7e>
  1066f8:	3434      	adds	r4, #52	; 0x34
    for (uint8_t i = 0; i < ARRAYSIZE(ip); i++) {
  1066fa:	42a6      	cmp	r6, r4
  1066fc:	d01b      	beq.n	106736 <hal_saf_clock_set_default+0x5a>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SAF_BASE, &ip[i]);
  1066fe:	4622      	mov	r2, r4
  106700:	f04f 417c 	mov.w	r1, #4227858432	; 0xfc000000
  106704:	4628      	mov	r0, r5
  106706:	f7ff ff79 	bl	1065fc <hal_clock_ip_init>
        if (!ret) goto fail;
  10670a:	2800      	cmp	r0, #0
  10670c:	d1f4      	bne.n	1066f8 <hal_saf_clock_set_default+0x1c>
    hal_clock_release_instance(l_clkgenInstance);
  10670e:	4628      	mov	r0, r5
  106710:	f7ff fef8 	bl	106504 <hal_clock_release_instance>
    ASSERT(ret);
  106714:	f24e 330c 	movw	r3, #58124	; 0xe30c
  106718:	f24e 2274 	movw	r2, #57972	; 0xe274
  10671c:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106720:	f2c0 0310 	movt	r3, #16
  106724:	4638      	mov	r0, r7
  106726:	f2c0 0210 	movt	r2, #16
  10672a:	9300      	str	r3, [sp, #0]
  10672c:	f2c0 0110 	movt	r1, #16
  106730:	23ea      	movs	r3, #234	; 0xea
  106732:	f003 fd9f 	bl	10a274 <_panic>
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SAF_BASE, &bus[i]);
  106736:	f64d 52c8 	movw	r2, #56776	; 0xddc8
  10673a:	f04f 417c 	mov.w	r1, #4227858432	; 0xfc000000
  10673e:	4628      	mov	r0, r5
  106740:	f2c0 0210 	movt	r2, #16
  106744:	f7ff ff80 	bl	106648 <hal_clock_bus_init>
  106748:	4604      	mov	r4, r0
    hal_clock_release_instance(l_clkgenInstance);
  10674a:	4628      	mov	r0, r5
  10674c:	f7ff feda 	bl	106504 <hal_clock_release_instance>
    ASSERT(ret);
  106750:	2c00      	cmp	r4, #0
  106752:	d0df      	beq.n	106714 <hal_saf_clock_set_default+0x38>
}
  106754:	4620      	mov	r0, r4
  106756:	b003      	add	sp, #12
  106758:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_saf_clock_set_default clkgen creat handle failed\n");
  10675a:	f24e 20d4 	movw	r0, #58068	; 0xe2d4
        return ret;
  10675e:	462c      	mov	r4, r5
        printf("hal_saf_clock_set_default clkgen creat handle failed\n");
  106760:	f2c0 0010 	movt	r0, #16
  106764:	f004 fda2 	bl	10b2ac <puts>
}
  106768:	4620      	mov	r0, r4
  10676a:	b003      	add	sp, #12
  10676c:	bdf0      	pop	{r4, r5, r6, r7, r15}
  10676e:	bf00      	nop

00106770 <hal_sec_clock_set_default>:
{
  106770:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  106774:	4677      	mov	r7, r14
  106776:	b082      	sub	sp, #8
    clkgenInstance = hal_clock_get_instance();
  106778:	f7ff fe6a 	bl	106450 <hal_clock_get_instance>
  10677c:	f24e 64f4 	movw	r4, #59124	; 0xe6f4
  106780:	f2c0 0410 	movt	r4, #16
  106784:	f504 6629 	add.w	r6, r4, #2704	; 0xa90
    if (clkgenInstance == NULL) {
  106788:	4605      	mov	r5, r0
  10678a:	b918      	cbnz	r0, 106794 <hal_sec_clock_set_default+0x24>
  10678c:	e01f      	b.n	1067ce <hal_sec_clock_set_default+0x5e>
  10678e:	3434      	adds	r4, #52	; 0x34
    for (uint8_t i = 0; i < ARRAYSIZE(ip); i++) {
  106790:	42a6      	cmp	r6, r4
  106792:	d027      	beq.n	1067e4 <hal_sec_clock_set_default+0x74>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SEC_BASE, &ip[i]);
  106794:	4622      	mov	r2, r4
  106796:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  10679a:	4628      	mov	r0, r5
  10679c:	f7ff ff2e 	bl	1065fc <hal_clock_ip_init>
        if (!ret) goto fail;
  1067a0:	2800      	cmp	r0, #0
  1067a2:	d1f4      	bne.n	10678e <hal_sec_clock_set_default+0x1e>
    hal_clock_release_instance(l_clkgenInstance);
  1067a4:	4628      	mov	r0, r5
  1067a6:	f7ff fead 	bl	106504 <hal_clock_release_instance>
    ASSERT(ret);
  1067aa:	f24e 330c 	movw	r3, #58124	; 0xe30c
  1067ae:	f24e 2274 	movw	r2, #57972	; 0xe274
  1067b2:	f2c0 0310 	movt	r3, #16
  1067b6:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1067ba:	4638      	mov	r0, r7
  1067bc:	9300      	str	r3, [sp, #0]
  1067be:	f2c0 0210 	movt	r2, #16
  1067c2:	f240 131f 	movw	r3, #287	; 0x11f
  1067c6:	f2c0 0110 	movt	r1, #16
  1067ca:	f003 fd53 	bl	10a274 <_panic>
        printf("hal_sec_clock_set_default clkgen creat handle failed\n");
  1067ce:	f24e 3010 	movw	r0, #58128	; 0xe310
        return ret;
  1067d2:	462c      	mov	r4, r5
        printf("hal_sec_clock_set_default clkgen creat handle failed\n");
  1067d4:	f2c0 0010 	movt	r0, #16
  1067d8:	f004 fd68 	bl	10b2ac <puts>
}
  1067dc:	4620      	mov	r0, r4
  1067de:	b002      	add	sp, #8
  1067e0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  1067e4:	f64d 6624 	movw	r6, #56868	; 0xde24
  1067e8:	f2c0 0610 	movt	r6, #16
  1067ec:	f506 788a 	add.w	r8, r6, #276	; 0x114
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SEC_BASE, &bus[i]);
  1067f0:	4632      	mov	r2, r6
  1067f2:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  1067f6:	4628      	mov	r0, r5
  1067f8:	f7ff ff26 	bl	106648 <hal_clock_bus_init>
        if (!ret) goto fail;
  1067fc:	4604      	mov	r4, r0
  1067fe:	2800      	cmp	r0, #0
  106800:	d0d0      	beq.n	1067a4 <hal_sec_clock_set_default+0x34>
  106802:	365c      	adds	r6, #92	; 0x5c
    for (uint8_t i = 0; i < ARRAYSIZE(bus); i++) {
  106804:	4546      	cmp	r6, r8
  106806:	d1f3      	bne.n	1067f0 <hal_sec_clock_set_default+0x80>
    hal_clock_release_instance(l_clkgenInstance);
  106808:	4628      	mov	r0, r5
  10680a:	f7ff fe7b 	bl	106504 <hal_clock_release_instance>
}
  10680e:	4620      	mov	r0, r4
  106810:	b002      	add	sp, #8
  106812:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  106816:	bf00      	nop

00106818 <hal_clock_core_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_core_init(void *g_handle, paddr_t phy_addr,
                         const clkgen_core_slice_t *core_slice_default)
{
  106818:	b570      	push	{r4, r5, r6, r14}
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_core_slice_drv_t core_clock_drv_cfg;
    clkgen_instance_t *l_clkgenInstance = NULL;
    uint8_t core_slice_idx = core_slice_default->slice_index;
  10681a:	6814      	ldr	r4, [r2, #0]
{
  10681c:	b084      	sub	sp, #16
    ASSERT((g_handle != NULL));
  10681e:	b1c0      	cbz	r0, 106852 <hal_clock_core_init+0x3a>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->core_slice_switch) {
  106820:	6883      	ldr	r3, [r0, #8]
  106822:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  106824:	b33b      	cbz	r3, 106876 <hal_clock_core_init+0x5e>
            core_slice_default->clk_a_b_select;
        core_clock_drv_cfg.clk_src_sel_a =
            core_slice_default->clk_src_select_a_num;
        core_clock_drv_cfg.clk_src_sel_b =
            core_slice_default->clk_src_select_b_num;
        core_clock_drv_cfg.post_div = core_slice_default->post_div;
  106826:	6cd6      	ldr	r6, [r2, #76]	; 0x4c
        core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  106828:	b2e4      	uxtb	r4, r4
        core_clock_drv_cfg.clk_a_b_switch =
  10682a:	f892 5049 	ldrb.w	r5, [r2, #73]	; 0x49
        core_clock_drv_cfg.post_div = core_slice_default->post_div;
  10682e:	f88d 600f 	strb.w	r6, [r13, #15]
        core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  106832:	9402      	str	r4, [sp, #8]

        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  106834:	4608      	mov	r0, r1
        core_clock_drv_cfg.clk_src_sel_a =
  106836:	f892 4024 	ldrb.w	r4, [r2, #36]	; 0x24
        core_clock_drv_cfg.clk_a_b_switch =
  10683a:	f88d 500c 	strb.w	r5, [r13, #12]
        core_clock_drv_cfg.clk_src_sel_b =
  10683e:	f892 2048 	ldrb.w	r2, [r2, #72]	; 0x48
        core_clock_drv_cfg.clk_src_sel_a =
  106842:	f88d 400d 	strb.w	r4, [r13, #13]
        core_clock_drv_cfg.clk_src_sel_b =
  106846:	f88d 200e 	strb.w	r2, [r13, #14]
        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  10684a:	a902      	add	r1, sp, #8
  10684c:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_core_init not find slice_idx:%d  \n", core_slice_idx);
    return false;
}
  10684e:	b004      	add	sp, #16
  106850:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  106852:	f24e 2360 	movw	r3, #57952	; 0xe260
  106856:	f24e 2274 	movw	r2, #57972	; 0xe274
  10685a:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10685e:	f2c0 0310 	movt	r3, #16
  106862:	4670      	mov	r0, r14
  106864:	f2c0 0210 	movt	r2, #16
  106868:	9300      	str	r3, [sp, #0]
  10686a:	f2c0 0110 	movt	r1, #16
  10686e:	f240 2347 	movw	r3, #583	; 0x247
  106872:	f003 fcff 	bl	10a274 <_panic>
    return false;
  106876:	4618      	mov	r0, r3
  106878:	e7e9      	b.n	10684e <hal_clock_core_init+0x36>
  10687a:	bf00      	nop

0010687c <hal_clock_uuu_init>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuu_init(void *g_handle, paddr_t phy_addr,
                        const clkgen_uuu_cfg_t *uuu_default)
{
  10687c:	b510      	push	{r4, r14}
  10687e:	460b      	mov	r3, r1
  106880:	b084      	sub	sp, #16
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_gasket_type_t l_gasket_div;
    uint8_t uuu_slice_idx = uuu_default->slice_index;
  106882:	7811      	ldrb	r1, [r2, #0]
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  106884:	b1b0      	cbz	r0, 1068b4 <hal_clock_uuu_init+0x38>
    }

#endif
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if (l_clkgenInstance->controllerTable->uuu_clock_wrapper) {
  106886:	6880      	ldr	r0, [r0, #8]
  106888:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
  10688a:	b32c      	cbz	r4, 1068d8 <hal_clock_uuu_init+0x5c>
        l_gasket_div.m_div_num = uuu_default->m_div;
        l_gasket_div.n_div_num = uuu_default->n_div;
        l_gasket_div.p_div_num = uuu_default->p_div;
        l_gasket_div.q_div_num = uuu_default->q_div;

        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  10688c:	4618      	mov	r0, r3
        l_gasket_div.m_div_num = uuu_default->m_div;
  10688e:	7953      	ldrb	r3, [r2, #5]
  106890:	f88d 300c 	strb.w	r3, [r13, #12]
        l_gasket_div.n_div_num = uuu_default->n_div;
  106894:	7993      	ldrb	r3, [r2, #6]
  106896:	f88d 300d 	strb.w	r3, [r13, #13]
        l_gasket_div.p_div_num = uuu_default->p_div;
  10689a:	79d3      	ldrb	r3, [r2, #7]
  10689c:	f88d 300e 	strb.w	r3, [r13, #14]
        l_gasket_div.q_div_num = uuu_default->q_div;
  1068a0:	7a13      	ldrb	r3, [r2, #8]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  1068a2:	7912      	ldrb	r2, [r2, #4]
        l_gasket_div.q_div_num = uuu_default->q_div;
  1068a4:	f88d 300f 	strb.w	r3, [r13, #15]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  1068a8:	9200      	str	r2, [sp, #0]
  1068aa:	2300      	movs	r3, #0
  1068ac:	aa03      	add	r2, sp, #12
  1068ae:	47a0      	blx	r4
        }
    }

    LTRACEF("hal_clock_uuu_init not find slice_idx:%d  \n", uuu_slice_idx);
    return false;
}
  1068b0:	b004      	add	sp, #16
  1068b2:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  1068b4:	f24e 2360 	movw	r3, #57952	; 0xe260
  1068b8:	f24e 2274 	movw	r2, #57972	; 0xe274
  1068bc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1068c0:	f2c0 0310 	movt	r3, #16
  1068c4:	4670      	mov	r0, r14
  1068c6:	f2c0 0210 	movt	r2, #16
  1068ca:	9300      	str	r3, [sp, #0]
  1068cc:	f2c0 0110 	movt	r1, #16
  1068d0:	f240 2381 	movw	r3, #641	; 0x281
  1068d4:	f003 fcce 	bl	10a274 <_panic>
    return false;
  1068d8:	4620      	mov	r0, r4
  1068da:	e7e9      	b.n	1068b0 <hal_clock_uuu_init+0x34>

001068dc <hal_soc_clock_set_default>:
{
  1068dc:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1068e0:	4677      	mov	r7, r14
  1068e2:	b082      	sub	sp, #8
    clkgenInstance = hal_clock_get_instance();
  1068e4:	f7ff fdb4 	bl	106450 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  1068e8:	4605      	mov	r5, r0
  1068ea:	2800      	cmp	r0, #0
  1068ec:	d06b      	beq.n	1069c6 <hal_soc_clock_set_default+0xea>
  1068ee:	f24f 2454 	movw	r4, #62036	; 0xf254
  1068f2:	2300      	movs	r3, #0
  1068f4:	f2c0 0410 	movt	r4, #16
  1068f8:	f104 0690 	add.w	r6, r4, #144	; 0x90
  1068fc:	e001      	b.n	106902 <hal_soc_clock_set_default+0x26>
  1068fe:	f854 3f10 	ldr.w	r3, [r4, #16]!
        if (uuu[i].slice_index == uuu_clock_wrapper_ddr) continue;
  106902:	2b09      	cmp	r3, #9
  106904:	d007      	beq.n	106916 <hal_soc_clock_set_default+0x3a>
        ret = hal_clock_uuu_init(handle, CFG_CKGEN_SOC_BASE, &uuu[i]);
  106906:	4622      	mov	r2, r4
  106908:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10690c:	4628      	mov	r0, r5
  10690e:	f7ff ffb5 	bl	10687c <hal_clock_uuu_init>
        if (!ret) goto fail;
  106912:	2800      	cmp	r0, #0
  106914:	d042      	beq.n	10699c <hal_soc_clock_set_default+0xc0>
    for (uint8_t i = 0; i < ARRAYSIZE(uuu); i++) {
  106916:	42a6      	cmp	r6, r4
  106918:	d1f1      	bne.n	1068fe <hal_soc_clock_set_default+0x22>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SOC_BASE, &ip[i]);
  10691a:	f24f 1284 	movw	r2, #61828	; 0xf184
  10691e:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  106922:	4628      	mov	r0, r5
  106924:	f2c0 0210 	movt	r2, #16
  106928:	f7ff fe68 	bl	1065fc <hal_clock_ip_init>
        if (!ret) goto fail;
  10692c:	b3b0      	cbz	r0, 10699c <hal_soc_clock_set_default+0xc0>
        ret = hal_clock_ip_init(handle, CFG_CKGEN_SOC_BASE, &ip[i]);
  10692e:	4a2b      	ldr	r2, [pc, #172]	; (1069dc <hal_soc_clock_set_default+0x100>)
  106930:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  106934:	4628      	mov	r0, r5
  106936:	f7ff fe61 	bl	1065fc <hal_clock_ip_init>
        if (!ret) goto fail;
  10693a:	b378      	cbz	r0, 10699c <hal_soc_clock_set_default+0xc0>
  10693c:	f64d 7438 	movw	r4, #57144	; 0xdf38
  106940:	f2c0 0410 	movt	r4, #16
  106944:	f504 78b8 	add.w	r8, r4, #368	; 0x170
        ret = hal_clock_bus_init(handle, CFG_CKGEN_SOC_BASE, &bus[i]);
  106948:	4622      	mov	r2, r4
  10694a:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  10694e:	4628      	mov	r0, r5
  106950:	f7ff fe7a 	bl	106648 <hal_clock_bus_init>
        if (!ret) goto fail;
  106954:	4606      	mov	r6, r0
  106956:	b308      	cbz	r0, 10699c <hal_soc_clock_set_default+0xc0>
  106958:	345c      	adds	r4, #92	; 0x5c
    for (uint8_t i = 0; i < ARRAYSIZE(bus); i++) {
  10695a:	4544      	cmp	r4, r8
  10695c:	d1f4      	bne.n	106948 <hal_soc_clock_set_default+0x6c>
  10695e:	2300      	movs	r3, #0
  106960:	f24e 04a8 	movw	r4, #57512	; 0xe0a8
        if (core[i].slice_index == soc_core_slice_ddr) continue;
  106964:	2b05      	cmp	r3, #5
  106966:	f2c0 0410 	movt	r4, #16
  10696a:	f504 78b0 	add.w	r8, r4, #352	; 0x160
  10696e:	d006      	beq.n	10697e <hal_soc_clock_set_default+0xa2>
        ret = hal_clock_core_init(handle, CFG_CKGEN_SOC_BASE, &core[i]);
  106970:	4622      	mov	r2, r4
  106972:	f04f 4176 	mov.w	r1, #4127195136	; 0xf6000000
  106976:	4628      	mov	r0, r5
  106978:	f7ff ff4e 	bl	106818 <hal_clock_core_init>
        if (!ret) goto fail;
  10697c:	b170      	cbz	r0, 10699c <hal_soc_clock_set_default+0xc0>
    for (uint8_t i = 0; i < ARRAYSIZE(core); i++) {
  10697e:	4544      	cmp	r4, r8
  106980:	d005      	beq.n	10698e <hal_soc_clock_set_default+0xb2>
  106982:	f854 3f58 	ldr.w	r3, [r4, #88]!
        if (core[i].slice_index == soc_core_slice_ddr) continue;
  106986:	2b05      	cmp	r3, #5
  106988:	d1f2      	bne.n	106970 <hal_soc_clock_set_default+0x94>
    for (uint8_t i = 0; i < ARRAYSIZE(core); i++) {
  10698a:	4544      	cmp	r4, r8
  10698c:	d1f9      	bne.n	106982 <hal_soc_clock_set_default+0xa6>
    hal_clock_release_instance(l_clkgenInstance);
  10698e:	4628      	mov	r0, r5
  106990:	f7ff fdb8 	bl	106504 <hal_clock_release_instance>
}
  106994:	4630      	mov	r0, r6
  106996:	b002      	add	sp, #8
  106998:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    hal_clock_release_instance(l_clkgenInstance);
  10699c:	4628      	mov	r0, r5
  10699e:	f7ff fdb1 	bl	106504 <hal_clock_release_instance>
    ASSERT(ret);
  1069a2:	f24e 330c 	movw	r3, #58124	; 0xe30c
  1069a6:	f24e 2274 	movw	r2, #57972	; 0xe274
  1069aa:	f2c0 0310 	movt	r3, #16
  1069ae:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1069b2:	4638      	mov	r0, r7
  1069b4:	9300      	str	r3, [sp, #0]
  1069b6:	f2c0 0210 	movt	r2, #16
  1069ba:	f44f 73b1 	mov.w	r3, #354	; 0x162
  1069be:	f2c0 0110 	movt	r1, #16
  1069c2:	f003 fc57 	bl	10a274 <_panic>
        printf("hal_soc_clock_set_default clkgen creat handle failed\n");
  1069c6:	f24e 3048 	movw	r0, #58184	; 0xe348
        return ret;
  1069ca:	462e      	mov	r6, r5
        printf("hal_soc_clock_set_default clkgen creat handle failed\n");
  1069cc:	f2c0 0010 	movt	r0, #16
  1069d0:	f004 fc6c 	bl	10b2ac <puts>
}
  1069d4:	4630      	mov	r0, r6
  1069d6:	b002      	add	sp, #8
  1069d8:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  1069dc:	0010f1b8 	.word	0x0010f1b8

001069e0 <hal_clock_enable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_clock_enable(void *g_handle, uint32_t res_glb_idx)
{
  1069e0:	b510      	push	{r4, r14}
    int ret = -1;
    int32_t gating_idx = -1;
  1069e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  1069e6:	b084      	sub	sp, #16
    int32_t gating_idx = -1;
  1069e8:	9302      	str	r3, [sp, #8]
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
  1069ea:	b1c0      	cbz	r0, 106a1e <hal_clock_enable+0x3e>
  1069ec:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &gating_idx);
  1069ee:	aa02      	add	r2, sp, #8
  1069f0:	4608      	mov	r0, r1
  1069f2:	a903      	add	r1, sp, #12
  1069f4:	f000 fcd2 	bl	10739c <res_get_info_by_id>

    if (ret == -1) {
  1069f8:	3001      	adds	r0, #1
  1069fa:	d00d      	beq.n	106a18 <hal_clock_enable+0x38>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    //enable clk gating
    if ((gating_idx >= DEFAULT_LPGATING_IDX_START) && (gating_idx != -1)
  1069fc:	9902      	ldr	r1, [sp, #8]
  1069fe:	29ff      	cmp	r1, #255	; 0xff
  106a00:	dd0a      	ble.n	106a18 <hal_clock_enable+0x38>
            && l_clkgenInstance->controllerTable->gating_enable) {
  106a02:	68a3      	ldr	r3, [r4, #8]
  106a04:	689b      	ldr	r3, [r3, #8]
  106a06:	b1e3      	cbz	r3, 106a42 <hal_clock_enable+0x62>
        if (l_clkgenInstance->controllerTable->gating_enable(clkgen_base_addr,
  106a08:	2201      	movs	r2, #1
  106a0a:	f5a1 7180 	sub.w	r1, r1, #256	; 0x100
  106a0e:	9803      	ldr	r0, [sp, #12]
  106a10:	b289      	uxth	r1, r1
  106a12:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_enable res_glb_idx:0x%x enable failed\n", res_glb_idx);
    return false;
}
  106a14:	b004      	add	sp, #16
  106a16:	bd10      	pop	{r4, r15}
        return false;
  106a18:	2000      	movs	r0, #0
}
  106a1a:	b004      	add	sp, #16
  106a1c:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
  106a1e:	f24e 2360 	movw	r3, #57952	; 0xe260
  106a22:	f24e 2274 	movw	r2, #57972	; 0xe274
  106a26:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106a2a:	f2c0 0310 	movt	r3, #16
  106a2e:	4670      	mov	r0, r14
  106a30:	f2c0 0210 	movt	r2, #16
  106a34:	9300      	str	r3, [sp, #0]
  106a36:	f2c0 0110 	movt	r1, #16
  106a3a:	f44f 732e 	mov.w	r3, #696	; 0x2b8
  106a3e:	f003 fc19 	bl	10a274 <_panic>
        return false;
  106a42:	4618      	mov	r0, r3
  106a44:	e7e9      	b.n	106a1a <hal_clock_enable+0x3a>
  106a46:	bf00      	nop

00106a48 <hal_clock_coreclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_coreclk_set(void *g_handle, uint32_t res_glb_idx,
                           clkgen_app_core_cfg_t *core_app_cfg)
{
  106a48:	b570      	push	{r4, r5, r6, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t core_slice_idx = -1;
  106a4a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  106a4e:	b086      	sub	sp, #24
    int32_t core_slice_idx = -1;
  106a50:	9303      	str	r3, [sp, #12]
    clkgen_core_slice_drv_t core_clock_drv_cfg;
    ASSERT((g_handle != NULL));
  106a52:	b328      	cbz	r0, 106aa0 <hal_clock_coreclk_set+0x58>
  106a54:	4614      	mov	r4, r2
  106a56:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &core_slice_idx);
  106a58:	4608      	mov	r0, r1
  106a5a:	aa03      	add	r2, sp, #12
  106a5c:	a902      	add	r1, sp, #8
  106a5e:	f000 fc9d 	bl	10739c <res_get_info_by_id>

    if (ret == -1) {
  106a62:	3001      	adds	r0, #1
  106a64:	d019      	beq.n	106a9a <hal_clock_coreclk_set+0x52>
        return false;
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
    //user config
    core_slice_idx -= DEFAULT_CORESLICE_IDX_START;
  106a66:	9b03      	ldr	r3, [sp, #12]
    core_clock_drv_cfg.core_slice_idx = core_slice_idx;
    core_clock_drv_cfg.clk_a_b_switch = core_app_cfg->clk_a_b_select;
  106a68:	78a0      	ldrb	r0, [r4, #2]
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
    core_clock_drv_cfg.post_div = core_app_cfg->post_div;
  106a6a:	6866      	ldr	r6, [r4, #4]
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
  106a6c:	7821      	ldrb	r1, [r4, #0]
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
  106a6e:	7862      	ldrb	r2, [r4, #1]
    core_clock_drv_cfg.clk_a_b_switch = core_app_cfg->clk_a_b_select;
  106a70:	f88d 0014 	strb.w	r0, [r13, #20]
    core_clock_drv_cfg.post_div = core_app_cfg->post_div;
  106a74:	f88d 6017 	strb.w	r6, [r13, #23]
    core_slice_idx -= DEFAULT_CORESLICE_IDX_START;
  106a78:	3bc0      	subs	r3, #192	; 0xc0
    core_clock_drv_cfg.clk_src_sel_a = core_app_cfg->clk_src_select_a_num;
  106a7a:	f88d 1015 	strb.w	r1, [r13, #21]

    if ((core_slice_idx != -1) && (core_slice_idx >= 0)
  106a7e:	2b00      	cmp	r3, #0
    core_clock_drv_cfg.core_slice_idx = core_slice_idx;
  106a80:	e9cd 3303 	strd	r3, r3, [r13, #12]
    core_clock_drv_cfg.clk_src_sel_b = core_app_cfg->clk_src_select_b_num;
  106a84:	f88d 2016 	strb.w	r2, [r13, #22]
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  106a88:	9802      	ldr	r0, [sp, #8]
    if ((core_slice_idx != -1) && (core_slice_idx >= 0)
  106a8a:	db06      	blt.n	106a9a <hal_clock_coreclk_set+0x52>
            && l_clkgenInstance->controllerTable->core_slice_switch) {
  106a8c:	68ab      	ldr	r3, [r5, #8]
  106a8e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  106a90:	b11b      	cbz	r3, 106a9a <hal_clock_coreclk_set+0x52>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->core_slice_switch(clkgen_base_addr,
  106a92:	a904      	add	r1, sp, #16
  106a94:	4798      	blx	r3
    }

    LTRACEF("hal_clock_coreclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, core_slice_idx);
    return false;
}
  106a96:	b006      	add	sp, #24
  106a98:	bd70      	pop	{r4, r5, r6, r15}
        return false;
  106a9a:	2000      	movs	r0, #0
}
  106a9c:	b006      	add	sp, #24
  106a9e:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT((g_handle != NULL));
  106aa0:	f24e 2360 	movw	r3, #57952	; 0xe260
  106aa4:	f24e 2274 	movw	r2, #57972	; 0xe274
  106aa8:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106aac:	f2c0 0310 	movt	r3, #16
  106ab0:	4670      	mov	r0, r14
  106ab2:	f2c0 0210 	movt	r2, #16
  106ab6:	9300      	str	r3, [sp, #0]
  106ab8:	f2c0 0110 	movt	r1, #16
  106abc:	f240 437f 	movw	r3, #1151	; 0x47f
  106ac0:	f003 fbd8 	bl	10a274 <_panic>

00106ac4 <hal_clock_uuuclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_uuuclk_set(void *g_handle, uint32_t res_glb_idx,
                          clkgen_app_uuu_cfg_t *uuu_app_cfg)
{
  106ac4:	b530      	push	{r4, r5, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t uuu_slice_idx = -1;
  106ac6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  106aca:	b087      	sub	sp, #28
    int32_t uuu_slice_idx = -1;
  106acc:	9304      	str	r3, [sp, #16]
    clkgen_gasket_type_t l_gasket_div;
    ASSERT((g_handle != NULL));
  106ace:	b350      	cbz	r0, 106b26 <hal_clock_uuuclk_set+0x62>
  106ad0:	4614      	mov	r4, r2
  106ad2:	4605      	mov	r5, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &uuu_slice_idx);
  106ad4:	4608      	mov	r0, r1
  106ad6:	aa04      	add	r2, sp, #16
  106ad8:	a903      	add	r1, sp, #12
  106ada:	f000 fc5f 	bl	10739c <res_get_info_by_id>

    if (ret == -1) {
  106ade:	3001      	adds	r0, #1
  106ae0:	d01e      	beq.n	106b20 <hal_clock_uuuclk_set+0x5c>
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;

    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  106ae2:	9904      	ldr	r1, [sp, #16]
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
  106ae4:	7962      	ldrb	r2, [r4, #5]
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
  106ae6:	79a3      	ldrb	r3, [r4, #6]
    l_gasket_div.m_div_num = uuu_app_cfg->m_div;
  106ae8:	f88d 2014 	strb.w	r2, [r13, #20]
    l_gasket_div.n_div_num = uuu_app_cfg->n_div;
  106aec:	f88d 3015 	strb.w	r3, [r13, #21]
    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  106af0:	f5b1 7fc0 	cmp.w	r1, #384	; 0x180
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
  106af4:	79e2      	ldrb	r2, [r4, #7]
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;
  106af6:	7a23      	ldrb	r3, [r4, #8]
    l_gasket_div.p_div_num = uuu_app_cfg->p_div;
  106af8:	f88d 2016 	strb.w	r2, [r13, #22]
    l_gasket_div.q_div_num = uuu_app_cfg->q_div;
  106afc:	f88d 3017 	strb.w	r3, [r13, #23]
    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);
  106b00:	9803      	ldr	r0, [sp, #12]
    if ((uuu_slice_idx != -1) && (uuu_slice_idx >= DEFAULT_UUUSLICE_IDX_START)
  106b02:	db0d      	blt.n	106b20 <hal_clock_uuuclk_set+0x5c>
            && l_clkgenInstance->controllerTable->uuu_clock_wrapper) {
  106b04:	68ab      	ldr	r3, [r5, #8]
  106b06:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
  106b08:	b155      	cbz	r5, 106b20 <hal_clock_uuuclk_set+0x5c>
        //set clk src and div
        uuu_slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  106b0a:	f5a1 71c0 	sub.w	r1, r1, #384	; 0x180

        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  106b0e:	7822      	ldrb	r2, [r4, #0]
  106b10:	7923      	ldrb	r3, [r4, #4]
  106b12:	9200      	str	r2, [sp, #0]
        uuu_slice_idx -= DEFAULT_UUUSLICE_IDX_START;
  106b14:	9104      	str	r1, [sp, #16]
        if (l_clkgenInstance->controllerTable->uuu_clock_wrapper(clkgen_base_addr,
  106b16:	aa05      	add	r2, sp, #20
  106b18:	b289      	uxth	r1, r1
  106b1a:	47a8      	blx	r5
    }

    LTRACEF("hal_clock_uuuclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, uuu_slice_idx);
    return false;
}
  106b1c:	b007      	add	sp, #28
  106b1e:	bd30      	pop	{r4, r5, r15}
        return false;
  106b20:	2000      	movs	r0, #0
}
  106b22:	b007      	add	sp, #28
  106b24:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  106b26:	f24e 2360 	movw	r3, #57952	; 0xe260
  106b2a:	f24e 2274 	movw	r2, #57972	; 0xe274
  106b2e:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  106b32:	f2c0 0310 	movt	r3, #16
  106b36:	4670      	mov	r0, r14
  106b38:	f2c0 0210 	movt	r2, #16
  106b3c:	9300      	str	r3, [sp, #0]
  106b3e:	f2c0 0110 	movt	r1, #16
  106b42:	f240 5334 	movw	r3, #1332	; 0x534
  106b46:	f003 fb95 	bl	10a274 <_panic>
  106b4a:	bf00      	nop

00106b4c <hal_crypto_init>:
//
//*****************************************************************************
void hal_crypto_init(uint level)
{

    ce_globle_init();
  106b4c:	f7fd b97e 	b.w	103e4c <ce_globle_init>

00106b50 <hal_arm_gic_create_handle>:


bool hal_arm_gic_create_handle(void **phandle, uint32_t res_glb_idx)
{
    return true;
}
  106b50:	2001      	movs	r0, #1
  106b52:	4770      	bx	r14

00106b54 <hal_arm_gic_release_handle>:

bool hal_arm_gic_release_handle(void *handle)
{
    return true;
}
  106b54:	2001      	movs	r0, #1
  106b56:	4770      	bx	r14

00106b58 <hal_arm_gic_init>:

bool hal_arm_gic_init(void *handle)
{
  106b58:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  106b5a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  106b5e:	061b      	lsls	r3, r3, #24
  106b60:	d40d      	bmi.n	106b7e <hal_arm_gic_init+0x26>
    __asm__ volatile("cpsid i");
  106b62:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    static bool initialized = false;

    spin_lock_irqsave(&init_lock,state);

    if(false == initialized)
  106b64:	f247 04e0 	movw	r4, #28896	; 0x70e0
  106b68:	f2c0 0411 	movt	r4, #17
  106b6c:	7823      	ldrb	r3, [r4, #0]
  106b6e:	b91b      	cbnz	r3, 106b78 <hal_arm_gic_init+0x20>
    {
        arm_gic_init();
  106b70:	f7fd fa00 	bl	103f74 <arm_gic_init>
        initialized = true;
  106b74:	2301      	movs	r3, #1
  106b76:	7023      	strb	r3, [r4, #0]
    __asm__ volatile("cpsie i");
  106b78:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&init_lock,state);

    return true;
}
  106b7a:	2001      	movs	r0, #1
  106b7c:	bd10      	pop	{r4, r15}
    if(false == initialized)
  106b7e:	f247 04e0 	movw	r4, #28896	; 0x70e0
  106b82:	f2c0 0411 	movt	r4, #17
  106b86:	7823      	ldrb	r3, [r4, #0]
  106b88:	2b00      	cmp	r3, #0
  106b8a:	d1f6      	bne.n	106b7a <hal_arm_gic_init+0x22>
        arm_gic_init();
  106b8c:	f7fd f9f2 	bl	103f74 <arm_gic_init>
        initialized = true;
  106b90:	2301      	movs	r3, #1
  106b92:	7023      	strb	r3, [r4, #0]
    return true;
  106b94:	e7f1      	b.n	106b7a <hal_arm_gic_init+0x22>
  106b96:	bf00      	nop

00106b98 <hal_arm_gic_enable_interrupt>:
    arm_gic_igroup_init();
    return true;
}

bool hal_arm_gic_enable_interrupt(void *handle, uint32_t irq_number)
{
  106b98:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_unmask_interrupt(irq_number) == 0 ? true : false );
  106b9a:	4608      	mov	r0, r1
  106b9c:	f7fd fa82 	bl	1040a4 <arm_gic_unmask_interrupt>

    return ret;

}
  106ba0:	fab0 f080 	clz	r0, r0
  106ba4:	0940      	lsrs	r0, r0, #5
  106ba6:	bd08      	pop	{r3, r15}

00106ba8 <hal_arm_gic_register_interrupt>:
bool hal_arm_gic_register_interrupt(void *handle,
    uint32_t irq_number,
    uint8_t priority,
    int_handler irq_handler,
    void* arg)
{
  106ba8:	b538      	push	{r3, r4, r5, r14}
  106baa:	460c      	mov	r4, r1
  106bac:	4615      	mov	r5, r2
    arm_gic_register_int_handler(irq_number, irq_handler, arg);
  106bae:	4619      	mov	r1, r3
  106bb0:	4620      	mov	r0, r4
  106bb2:	9a04      	ldr	r2, [sp, #16]
  106bb4:	f7fd f9b2 	bl	103f1c <arm_gic_register_int_handler>
    arm_gic_set_priority(irq_number, priority);
  106bb8:	4629      	mov	r1, r5
  106bba:	4620      	mov	r0, r4
  106bbc:	f7fd fa44 	bl	104048 <arm_gic_set_priority>

    return true;
}
  106bc0:	2001      	movs	r0, #1
  106bc2:	bd38      	pop	{r3, r4, r5, r15}

00106bc4 <hal_pll_create_handle>:

    return config;
}

pll_handle_t hal_pll_create_handle(uint32_t resid)
{
  106bc4:	b510      	push	{r4, r14}
  106bc6:	4604      	mov	r4, r0
  106bc8:	b082      	sub	sp, #8
    addr_t      pll_addr;
    int32_t     index;
    pll_e       pll;

    if (!res_get_info_by_id(resid, &pll_addr, &index) &&
  106bca:	4669      	mov	r1, r13
  106bcc:	aa01      	add	r2, sp, #4
  106bce:	f000 fbe5 	bl	10739c <res_get_info_by_id>
  106bd2:	b998      	cbnz	r0, 106bfc <hal_pll_create_handle+0x38>
  106bd4:	f24f 5330 	movw	r3, #62768	; 0xf530
  106bd8:	f241 0225 	movw	r2, #4133	; 0x1025
  106bdc:	f2c0 0310 	movt	r3, #16
  106be0:	f103 01a8 	add.w	r1, r3, #168	; 0xa8
  106be4:	f2c4 022e 	movt	r2, #16430	; 0x402e
  106be8:	e003      	b.n	106bf2 <hal_pll_create_handle+0x2e>
    for (pll_e i = 0; i < PLL_MAX; i++) {
  106bea:	428b      	cmp	r3, r1
  106bec:	d006      	beq.n	106bfc <hal_pll_create_handle+0x38>
  106bee:	f853 2f08 	ldr.w	r2, [r3, #8]!
        if (g_pll_res[i].resid == resid) {
  106bf2:	4294      	cmp	r4, r2
  106bf4:	d1f9      	bne.n	106bea <hal_pll_create_handle+0x26>
  106bf6:	4620      	mov	r0, r4
    }
    else {
        //LTRACEF("Can not create pll handle, resid 0x%x\n", resid);
        return (pll_handle_t)0;
    }
}
  106bf8:	b002      	add	sp, #8
  106bfa:	bd10      	pop	{r4, r15}
        return (pll_handle_t)0;
  106bfc:	2000      	movs	r0, #0
}
  106bfe:	b002      	add	sp, #8
  106c00:	bd10      	pop	{r4, r15}
  106c02:	bf00      	nop

00106c04 <hal_pll_delete_handle>:

void hal_pll_delete_handle(pll_handle_t handle)
{
    return;
}
  106c04:	4770      	bx	r14
  106c06:	bf00      	nop

00106c08 <hal_pll_config>:

void hal_pll_config(pll_handle_t handle, const pll_config_t *config)
{
  106c08:	b530      	push	{r4, r5, r14}
  106c0a:	460d      	mov	r5, r1
  106c0c:	b083      	sub	sp, #12
    uint32_t            resid = (uint32_t)handle;
    pll_e               pll;
    addr_t              pll_addr;
    int32_t             index;

    if (res_get_info_by_id(resid, &pll_addr, &index) != 0 ||
  106c0e:	4669      	mov	r1, r13
  106c10:	aa01      	add	r2, sp, #4
{
  106c12:	4604      	mov	r4, r0
    if (res_get_info_by_id(resid, &pll_addr, &index) != 0 ||
  106c14:	f000 fbc2 	bl	10739c <res_get_info_by_id>
  106c18:	b9f8      	cbnz	r0, 106c5a <hal_pll_config+0x52>
  106c1a:	f241 0325 	movw	r3, #4133	; 0x1025
  106c1e:	f24f 5230 	movw	r2, #62768	; 0xf530
    for (pll_e i = 0; i < PLL_MAX; i++) {
  106c22:	4601      	mov	r1, r0
  106c24:	f2c4 032e 	movt	r3, #16430	; 0x402e
  106c28:	f2c0 0210 	movt	r2, #16
  106c2c:	e004      	b.n	106c38 <hal_pll_config+0x30>
  106c2e:	3101      	adds	r1, #1
  106c30:	2916      	cmp	r1, #22
  106c32:	d012      	beq.n	106c5a <hal_pll_config+0x52>
  106c34:	f852 3031 	ldr.w	r3, [r2, r1, lsl #3]
        if (g_pll_res[i].resid == resid) {
  106c38:	429c      	cmp	r4, r3
  106c3a:	d1f8      	bne.n	106c2e <hal_pll_config+0x26>
            (pll = res2pll(resid)) == PLL_INVALID) {
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
        return;
    }

    if (!config) {
  106c3c:	b1c5      	cbz	r5, 106c70 <hal_pll_config+0x68>
            return;
        }
    }

    /* Override PLL address if necessary. */
    if (g_pll_res[pll].paddr) {
  106c3e:	f24f 5030 	movw	r0, #62768	; 0xf530
  106c42:	f2c0 0010 	movt	r0, #16
  106c46:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
  106c4a:	6848      	ldr	r0, [r1, #4]
  106c4c:	b170      	cbz	r0, 106c6c <hal_pll_config+0x64>
        pll_addr = g_pll_res[pll].paddr;
  106c4e:	9000      	str	r0, [sp, #0]
    }

    LTRACEF("pll_init pll %d, addr 0x%x\n", pll, (uint32_t)pll_addr);
    pll_config(pll_addr, config);
  106c50:	4629      	mov	r1, r5
  106c52:	f7fd fa9f 	bl	104194 <pll_config>
}
  106c56:	b003      	add	sp, #12
  106c58:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "invalid pll resource 0x%x\n", resid);
  106c5a:	f24f 50e0 	movw	r0, #62944	; 0xf5e0
  106c5e:	4621      	mov	r1, r4
  106c60:	f2c0 0010 	movt	r0, #16
  106c64:	f004 fb3a 	bl	10b2dc <printf>
}
  106c68:	b003      	add	sp, #12
  106c6a:	bd30      	pop	{r4, r5, r15}
  106c6c:	9800      	ldr	r0, [sp, #0]
  106c6e:	e7ef      	b.n	106c50 <hal_pll_config+0x48>
  106c70:	f24f 6014 	movw	r0, #62996	; 0xf614
    if (!config) {
  106c74:	462b      	mov	r3, r5
  106c76:	f2c0 0010 	movt	r0, #16
  106c7a:	4602      	mov	r2, r0
  106c7c:	e004      	b.n	106c88 <hal_pll_config+0x80>
    for (size_t i = 0; i < sizeof(pll_configs) / sizeof(pll_configs[0]); i++) {
  106c7e:	3501      	adds	r5, #1
  106c80:	2d17      	cmp	r5, #23
  106c82:	d008      	beq.n	106c96 <hal_pll_config+0x8e>
  106c84:	f852 3f30 	ldr.w	r3, [r2, #48]!
        if (pll_configs[i].pll == pll) {
  106c88:	428b      	cmp	r3, r1
  106c8a:	d1f8      	bne.n	106c7e <hal_pll_config+0x76>
            config = &pll_configs[i];
  106c8c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  106c90:	eb00 1505 	add.w	r5, r0, r5, lsl #4
  106c94:	e7d3      	b.n	106c3e <hal_pll_config+0x36>
            dprintf(CRITICAL, "no config for pll %d\n", pll);
  106c96:	f24f 50fc 	movw	r0, #62972	; 0xf5fc
  106c9a:	f2c0 0010 	movt	r0, #16
  106c9e:	f004 fb1d 	bl	10b2dc <printf>
            return;
  106ca2:	e7e1      	b.n	106c68 <hal_pll_config+0x60>

00106ca4 <hal_pmu_drv_ops_init>:
pmudev_t dev = {
	.name = "pmu",
};

void hal_pmu_drv_ops_init(void)
{
  106ca4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
	memset(&drv_ops, 0, sizeof(pmu_drv_ops_t));
  106ca6:	f247 04e4 	movw	r4, #28900	; 0x70e4
  106caa:	22c4      	movs	r2, #196	; 0xc4
  106cac:	2100      	movs	r1, #0
  106cae:	f2c0 0411 	movt	r4, #17

	/* global ops */
	drv_ops.global.init = pmu_init;
  106cb2:	f244 46a5 	movw	r6, #17573	; 0x44a5
	memset(&drv_ops, 0, sizeof(pmu_drv_ops_t));
  106cb6:	f104 0018 	add.w	r0, r4, #24
  106cba:	f003 ebe4 	blx	10a484 <memset>
	drv_ops.global.exit = pmu_exit;
  106cbe:	f244 45f1 	movw	r5, #17649	; 0x44f1
	drv_ops.global.get_status = pmu_get_status;
  106cc2:	f244 5039 	movw	r0, #17721	; 0x4539
	drv_ops.global.get_event_source = pmu_get_event_source;
  106cc6:	f244 51c1 	movw	r1, #17857	; 0x45c1
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  106cca:	f244 6209 	movw	r2, #17929	; 0x4609
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  106cce:	f244 6349 	movw	r3, #17993	; 0x4649
	drv_ops.global.init = pmu_init;
  106cd2:	f2c0 0610 	movt	r6, #16
	drv_ops.global.exit = pmu_exit;
  106cd6:	f2c0 0510 	movt	r5, #16
	drv_ops.global.get_status = pmu_get_status;
  106cda:	f2c0 0010 	movt	r0, #16
	drv_ops.global.get_event_source = pmu_get_event_source;
  106cde:	f2c0 0110 	movt	r1, #16
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  106ce2:	f2c0 0210 	movt	r2, #16
	drv_ops.global.init = pmu_init;
  106ce6:	6026      	str	r6, [r4, #0]
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  106ce8:	f2c0 0310 	movt	r3, #16
	drv_ops.global.exit = pmu_exit;
  106cec:	6065      	str	r5, [r4, #4]

	/* pwr_on*/
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  106cee:	f244 7715 	movw	r7, #18197	; 0x4715
	drv_ops.global.get_status = pmu_get_status;
  106cf2:	60a0      	str	r0, [r4, #8]
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  106cf4:	f244 66d1 	movw	r6, #18129	; 0x46d1
	drv_ops.global.get_event_source = pmu_get_event_source;
  106cf8:	60e1      	str	r1, [r4, #12]
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  106cfa:	f244 6581 	movw	r5, #18049	; 0x4681
	drv_ops.global.clean_single_event = pmu_clean_single_event_source;
  106cfe:	6122      	str	r2, [r4, #16]

	/*pwr_ctrl*/
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  106d00:	f244 70c9 	movw	r0, #18377	; 0x47c9
	drv_ops.global.clean_all_event = pmu_clean_all_event_source;
  106d04:	6163      	str	r3, [r4, #20]
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  106d06:	f244 7155 	movw	r1, #18261	; 0x4755
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  106d0a:	f644 0239 	movw	r2, #18489	; 0x4839
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  106d0e:	f644 03b1 	movw	r3, #18609	; 0x48b1
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  106d12:	f2c0 0710 	movt	r7, #16
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  106d16:	f2c0 0610 	movt	r6, #16
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  106d1a:	f2c0 0510 	movt	r5, #16
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  106d1e:	f2c0 0010 	movt	r0, #16
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  106d22:	f2c0 0110 	movt	r1, #16
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  106d26:	f2c0 0210 	movt	r2, #16
	drv_ops.pwr_on.set_pu_delay = pmu_set_powerup_delay;
  106d2a:	6267      	str	r7, [r4, #36]	; 0x24
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  106d2c:	f2c0 0310 	movt	r3, #16
	drv_ops.pwr_on.set_pd_delay = pmu_set_powerdown_delay;
  106d30:	6226      	str	r6, [r4, #32]
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  106d32:	f644 172d 	movw	r7, #18733	; 0x492d
	drv_ops.pwr_on.force_powerdown = pmu_powerdown;
  106d36:	61e5      	str	r5, [r4, #28]
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  106d38:	f644 16a5 	movw	r6, #18853	; 0x49a5
	drv_ops.pwr_ctrl.set_pu_delay = pmu_set_powerctrl_powerup_delay;
  106d3c:	6460      	str	r0, [r4, #68]	; 0x44

	/*por*/
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  106d3e:	f644 7591 	movw	r5, #20369	; 0x4f91
	drv_ops.pwr_ctrl.set_pd_delay = pmu_set_powerctrl_powerdown_delay;
  106d42:	6421      	str	r1, [r4, #64]	; 0x40
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  106d44:	f644 70d5 	movw	r0, #20437	; 0x4fd5
	drv_ops.pwr_ctrl.set_io_mode = pmu_set_powerctrl_io_mode;
  106d48:	64a2      	str	r2, [r4, #72]	; 0x48
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  106d4a:	f245 0119 	movw	r1, #20505	; 0x5019
	drv_ops.pwr_ctrl.set_out_mode = pmu_set_powerctrl_out_mode;
  106d4e:	64e3      	str	r3, [r4, #76]	; 0x4c

	/*internal powerdown*/
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  106d50:	f644 2225 	movw	r2, #18981	; 0x4a25
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  106d54:	f644 2379 	movw	r3, #19065	; 0x4a79
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  106d58:	f2c0 0710 	movt	r7, #16
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  106d5c:	f2c0 0610 	movt	r6, #16
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  106d60:	f2c0 0510 	movt	r5, #16
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  106d64:	f2c0 0010 	movt	r0, #16
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  106d68:	f2c0 0110 	movt	r1, #16
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  106d6c:	f2c0 0210 	movt	r2, #16
	drv_ops.pwr_ctrl.set_out_ctrl = pmu_set_powerctrl_out_ctrl;
  106d70:	6527      	str	r7, [r4, #80]	; 0x50
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  106d72:	f2c0 0310 	movt	r3, #16
	drv_ops.pwr_ctrl.get_input_status = pmu_get_powerctrl_input_status;
  106d76:	6566      	str	r6, [r4, #84]	; 0x54
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  106d78:	f644 27d1 	movw	r7, #19153	; 0x4ad1
	drv_ops.por.set_pd_delay = pmu_set_por_powerdown_delay;
  106d7c:	6625      	str	r5, [r4, #96]	; 0x60

	/*external reset*/
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  106d7e:	f644 3631 	movw	r6, #19249	; 0x4b31
	drv_ops.por.auto_powerdown = pmu_set_por_auto_powerdown;
  106d82:	65a0      	str	r0, [r4, #88]	; 0x58
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  106d84:	f644 3585 	movw	r5, #19333	; 0x4b85
	drv_ops.por.force_powerdown = pmu_set_por_force_powerdown;
  106d88:	65e1      	str	r1, [r4, #92]	; 0x5c
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  106d8a:	f644 30dd 	movw	r0, #19421	; 0x4bdd
	drv_ops.internal_powerdown.set_enable = pmu_set_internal_powerdown_enable;
  106d8e:	67a2      	str	r2, [r4, #120]	; 0x78
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  106d90:	f644 4135 	movw	r1, #19509	; 0x4c35
	drv_ops.internal_powerdown.set_polarity = pmu_set_internal_powerdown_polarity;
  106d94:	67e3      	str	r3, [r4, #124]	; 0x7c
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  106d96:	f644 428d 	movw	r2, #19597	; 0x4c8d

	/*internal wakeup*/
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  106d9a:	f644 43ed 	movw	r3, #19693	; 0x4ced
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  106d9e:	f2c0 0710 	movt	r7, #16
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  106da2:	f2c0 0610 	movt	r6, #16
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  106da6:	f2c0 0510 	movt	r5, #16
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  106daa:	f2c0 0010 	movt	r0, #16
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  106dae:	f2c0 0110 	movt	r1, #16
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  106db2:	f2c0 0210 	movt	r2, #16
	drv_ops.internal_powerdown.get_status = pmu_get_internal_powerdown_status;
  106db6:	f8c4 7088 	str.w	r7, [r4, #136]	; 0x88
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  106dba:	f2c0 0310 	movt	r3, #16
	drv_ops.external_reset.set_enable = pmu_set_external_reset_enable;
  106dbe:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c

	/*external wakeup*/
	drv_ops.external_wakeup.set_enable = pmu_set_external_wakeup_enable;
  106dc2:	f644 573d 	movw	r7, #19773	; 0x4d3d
	drv_ops.external_reset.set_polarity = pmu_set_external_reset_polarity;
  106dc6:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  106dca:	f644 5695 	movw	r6, #19861	; 0x4d95
	drv_ops.external_reset.set_debounce_enable = pmu_set_external_reset_debounce_enable;
  106dce:	f8c4 0094 	str.w	r0, [r4, #148]	; 0x94
	drv_ops.external_wakeup.set_debounce_enable = pmu_set_external_wakeup_debounce_enable;
  106dd2:	f644 55ed 	movw	r5, #19949	; 0x4ded
	drv_ops.external_reset.set_debounce_delay = pmu_set_external_reset_debounce_delay;
  106dd6:	f8c4 1098 	str.w	r1, [r4, #152]	; 0x98
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  106dda:	f644 6045 	movw	r0, #20037	; 0x4e45
	drv_ops.external_reset.get_status = pmu_get_external_reset_status;
  106dde:	f8c4 209c 	str.w	r2, [r4, #156]	; 0x9c
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  106de2:	f644 619d 	movw	r1, #20125	; 0x4e9d
	drv_ops.internal_wakeup.set_enable = pmu_set_internal_wakeup_enable;
  106de6:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0

	/*glitch filter*/
	drv_ops.glitch_filter.set_debounce_enable = pmu_set_glitch_filter_enable;
  106dea:	f644 7241 	movw	r2, #20289	; 0x4f41
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  106dee:	f644 63fd 	movw	r3, #20221	; 0x4efd
	drv_ops.external_wakeup.set_enable = pmu_set_external_wakeup_enable;
  106df2:	f2c0 0710 	movt	r7, #16
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  106df6:	f2c0 0610 	movt	r6, #16
	drv_ops.external_wakeup.set_debounce_enable = pmu_set_external_wakeup_debounce_enable;
  106dfa:	f2c0 0510 	movt	r5, #16
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  106dfe:	f2c0 0010 	movt	r0, #16
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  106e02:	f2c0 0110 	movt	r1, #16
	drv_ops.glitch_filter.set_debounce_enable = pmu_set_glitch_filter_enable;
  106e06:	f2c0 0210 	movt	r2, #16
	drv_ops.external_wakeup.set_polarity = pmu_set_external_wakeup_polarity;
  106e0a:	e9c4 762d 	strd	r7, r6, [r4, #180]	; 0xb4
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  106e0e:	f2c0 0310 	movt	r3, #16
	drv_ops.external_wakeup.set_debounce_delay = pmu_set_external_wakeup_debounce_delay;
  106e12:	e9c4 502f 	strd	r5, r0, [r4, #188]	; 0xbc
	drv_ops.external_wakeup.get_status = pmu_get_external_wakeup_status;
  106e16:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	drv_ops.glitch_filter.set_debounce_delay = pmu_set_glitch_filter_delay;
  106e1a:	e9c4 2334 	strd	r2, r3, [r4, #208]	; 0xd0
}
  106e1e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00106e20 <hal_pmu_creat_handle>:


int32_t hal_pmu_creat_handle(void **handle, uint32_t pmu_res_glb_idx)
{
  106e20:	b570      	push	{r4, r5, r6, r14}
  106e22:	b082      	sub	sp, #8
	static int flag = 0;
	int32_t ret;
	addr_t paddr;

	if (handle == NULL) {
  106e24:	b388      	cbz	r0, 106e8a <hal_pmu_creat_handle+0x6a>
		pmu_err("parameters is wrong\n");
		return -1;
	}

	ret = res_get_info_by_id(pmu_res_glb_idx, &paddr, &dev.id);
  106e26:	f644 1468 	movw	r4, #18792	; 0x4968
  106e2a:	4606      	mov	r6, r0
  106e2c:	4608      	mov	r0, r1
  106e2e:	f2c0 0411 	movt	r4, #17
  106e32:	1d22      	adds	r2, r4, #4
  106e34:	a901      	add	r1, sp, #4
  106e36:	f000 fab1 	bl	10739c <res_get_info_by_id>
	if (ret < 0) {
  106e3a:	1e05      	subs	r5, r0, #0
  106e3c:	db17      	blt.n	106e6e <hal_pmu_creat_handle+0x4e>
		pmu_err("res_get_info_by_id fail\n");
		return ret;
	}

	if (flag == 0) {
  106e3e:	f247 15c0 	movw	r5, #29120	; 0x71c0
  106e42:	f2c0 0511 	movt	r5, #17
  106e46:	682b      	ldr	r3, [r5, #0]
  106e48:	b123      	cbz	r3, 106e54 <hal_pmu_creat_handle+0x34>
		dev.base_paddr = (volatile uint8_t *)paddr;
		dev.base_vaddr = (volatile uint8_t *)phys_to_virt(paddr);
		flag = 1;
	}

	*handle = (void *)&dev;
  106e4a:	6034      	str	r4, [r6, #0]
	return 0;
  106e4c:	2500      	movs	r5, #0
}
  106e4e:	4628      	mov	r0, r5
  106e50:	b002      	add	sp, #8
  106e52:	bd70      	pop	{r4, r5, r6, r15}
		hal_pmu_drv_ops_init();
  106e54:	f7ff ff26 	bl	106ca4 <hal_pmu_drv_ops_init>
		dev.priv_data = (void *)&drv_ops;
  106e58:	f247 03e4 	movw	r3, #28900	; 0x70e4
		flag = 1;
  106e5c:	2101      	movs	r1, #1
		dev.priv_data = (void *)&drv_ops;
  106e5e:	f2c0 0311 	movt	r3, #17
		dev.base_paddr = (volatile uint8_t *)paddr;
  106e62:	9a01      	ldr	r2, [sp, #4]
		dev.priv_data = (void *)&drv_ops;
  106e64:	6163      	str	r3, [r4, #20]
		flag = 1;
  106e66:	6029      	str	r1, [r5, #0]
		dev.base_vaddr = (volatile uint8_t *)phys_to_virt(paddr);
  106e68:	e9c4 2203 	strd	r2, r2, [r4, #12]
  106e6c:	e7ed      	b.n	106e4a <hal_pmu_creat_handle+0x2a>
		pmu_err("res_get_info_by_id fail\n");
  106e6e:	f64f 2164 	movw	r1, #64100	; 0xfa64
  106e72:	f64f 3018 	movw	r0, #64280	; 0xfb18
  106e76:	2258      	movs	r2, #88	; 0x58
  106e78:	f2c0 0110 	movt	r1, #16
  106e7c:	f2c0 0010 	movt	r0, #16
  106e80:	f004 fa2c 	bl	10b2dc <printf>
}
  106e84:	4628      	mov	r0, r5
  106e86:	b002      	add	sp, #8
  106e88:	bd70      	pop	{r4, r5, r6, r15}
		pmu_err("parameters is wrong\n");
  106e8a:	f64f 2164 	movw	r1, #64100	; 0xfa64
  106e8e:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106e92:	2252      	movs	r2, #82	; 0x52
  106e94:	f2c0 0110 	movt	r1, #16
		return -1;
  106e98:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		pmu_err("parameters is wrong\n");
  106e9c:	f2c0 0010 	movt	r0, #16
  106ea0:	f004 fa1c 	bl	10b2dc <printf>
		return -1;
  106ea4:	e7d3      	b.n	106e4e <hal_pmu_creat_handle+0x2e>
  106ea6:	bf00      	nop

00106ea8 <hal_pmu_release_handle>:


int32_t hal_pmu_release_handle(void *handle)
{
	return 0;
}
  106ea8:	2000      	movs	r0, #0
  106eaa:	4770      	bx	r14

00106eac <hal_pmu_init>:

int32_t hal_pmu_init(void *handle)
{
  106eac:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  106eae:	b130      	cbz	r0, 106ebe <hal_pmu_init+0x12>
  106eb0:	6943      	ldr	r3, [r0, #20]
  106eb2:	b123      	cbz	r3, 106ebe <hal_pmu_init+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->global.init != NULL)
  106eb4:	681b      	ldr	r3, [r3, #0]
  106eb6:	b183      	cbz	r3, 106eda <hal_pmu_init+0x2e>
		return ops->global.init(dev);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  106eb8:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->global.init(dev);
  106ebc:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  106ebe:	f64f 217c 	movw	r1, #64124	; 0xfa7c
  106ec2:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106ec6:	f2c0 0110 	movt	r1, #16
  106eca:	2274      	movs	r2, #116	; 0x74
  106ecc:	f2c0 0010 	movt	r0, #16
  106ed0:	f004 fa04 	bl	10b2dc <printf>
}
  106ed4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  106ed8:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  106eda:	f64f 237c 	movw	r3, #64124	; 0xfa7c
  106ede:	f64f 3038 	movw	r0, #64312	; 0xfb38
  106ee2:	227d      	movs	r2, #125	; 0x7d
  106ee4:	f2c0 0310 	movt	r3, #16
  106ee8:	4619      	mov	r1, r3
  106eea:	f2c0 0010 	movt	r0, #16
  106eee:	f004 f9f5 	bl	10b2dc <printf>
	return -1;
  106ef2:	e7ef      	b.n	106ed4 <hal_pmu_init+0x28>

00106ef4 <hal_pmu_exit>:

int32_t hal_pmu_exit(void *handle)
{
  106ef4:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  106ef6:	b130      	cbz	r0, 106f06 <hal_pmu_exit+0x12>
  106ef8:	6943      	ldr	r3, [r0, #20]
  106efa:	b123      	cbz	r3, 106f06 <hal_pmu_exit+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->global.exit != NULL)
  106efc:	685b      	ldr	r3, [r3, #4]
  106efe:	b183      	cbz	r3, 106f22 <hal_pmu_exit+0x2e>
		return ops->global.exit(dev);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  106f00:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->global.exit(dev);
  106f04:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  106f06:	f64f 218c 	movw	r1, #64140	; 0xfa8c
  106f0a:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106f0e:	f2c0 0110 	movt	r1, #16
  106f12:	2287      	movs	r2, #135	; 0x87
  106f14:	f2c0 0010 	movt	r0, #16
  106f18:	f004 f9e0 	bl	10b2dc <printf>
}
  106f1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  106f20:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  106f22:	f64f 238c 	movw	r3, #64140	; 0xfa8c
  106f26:	f64f 3038 	movw	r0, #64312	; 0xfb38
  106f2a:	2290      	movs	r2, #144	; 0x90
  106f2c:	f2c0 0310 	movt	r3, #16
  106f30:	4619      	mov	r1, r3
  106f32:	f2c0 0010 	movt	r0, #16
  106f36:	f004 f9d1 	bl	10b2dc <printf>
	return -1;
  106f3a:	e7ef      	b.n	106f1c <hal_pmu_exit+0x28>

00106f3c <hal_pmu_set_powerctrl_io_mode>:
	pmu_err("%s is not support\n", __func__);
	return -1;
}

int32_t hal_pmu_set_powerctrl_io_mode(void *handle, int ctrl_id, int mode)
{
  106f3c:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  106f3e:	b130      	cbz	r0, 106f4e <hal_pmu_set_powerctrl_io_mode+0x12>
  106f40:	6943      	ldr	r3, [r0, #20]
  106f42:	b123      	cbz	r3, 106f4e <hal_pmu_set_powerctrl_io_mode+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_io_mode != NULL)
  106f44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  106f46:	b18b      	cbz	r3, 106f6c <hal_pmu_set_powerctrl_io_mode+0x30>
		return ops->pwr_ctrl.set_io_mode(dev, ctrl_id, mode);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  106f48:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_io_mode(dev, ctrl_id, mode);
  106f4c:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  106f4e:	f64f 219c 	movw	r1, #64156	; 0xfa9c
  106f52:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106f56:	f2c0 0110 	movt	r1, #16
  106f5a:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
  106f5e:	f2c0 0010 	movt	r0, #16
  106f62:	f004 f9bb 	bl	10b2dc <printf>
}
  106f66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  106f6a:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  106f6c:	f64f 239c 	movw	r3, #64156	; 0xfa9c
  106f70:	f64f 3038 	movw	r0, #64312	; 0xfb38
  106f74:	f240 12ad 	movw	r2, #429	; 0x1ad
  106f78:	f2c0 0310 	movt	r3, #16
  106f7c:	4619      	mov	r1, r3
  106f7e:	f2c0 0010 	movt	r0, #16
  106f82:	f004 f9ab 	bl	10b2dc <printf>
	return -1;
  106f86:	e7ee      	b.n	106f66 <hal_pmu_set_powerctrl_io_mode+0x2a>

00106f88 <hal_pmu_set_powerctrl_out_mode>:

int32_t hal_pmu_set_powerctrl_out_mode(void *handle, int ctrl_id, int mode)
{
  106f88:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  106f8a:	b130      	cbz	r0, 106f9a <hal_pmu_set_powerctrl_out_mode+0x12>
  106f8c:	6943      	ldr	r3, [r0, #20]
  106f8e:	b123      	cbz	r3, 106f9a <hal_pmu_set_powerctrl_out_mode+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_out_mode != NULL)
  106f90:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  106f92:	b18b      	cbz	r3, 106fb8 <hal_pmu_set_powerctrl_out_mode+0x30>
		return ops->pwr_ctrl.set_out_mode(dev, ctrl_id, mode);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  106f94:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_out_mode(dev, ctrl_id, mode);
  106f98:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  106f9a:	f64f 21bc 	movw	r1, #64188	; 0xfabc
  106f9e:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106fa2:	f2c0 0110 	movt	r1, #16
  106fa6:	f240 12b7 	movw	r2, #439	; 0x1b7
  106faa:	f2c0 0010 	movt	r0, #16
  106fae:	f004 f995 	bl	10b2dc <printf>
}
  106fb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  106fb6:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  106fb8:	f64f 23bc 	movw	r3, #64188	; 0xfabc
  106fbc:	f64f 3038 	movw	r0, #64312	; 0xfb38
  106fc0:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
  106fc4:	f2c0 0310 	movt	r3, #16
  106fc8:	4619      	mov	r1, r3
  106fca:	f2c0 0010 	movt	r0, #16
  106fce:	f004 f985 	bl	10b2dc <printf>
	return -1;
  106fd2:	e7ee      	b.n	106fb2 <hal_pmu_set_powerctrl_out_mode+0x2a>

00106fd4 <hal_pmu_set_powerctrl_out_ctrl>:

int32_t hal_pmu_set_powerctrl_out_ctrl(void *handle, int ctrl_id, int out)
{
  106fd4:	b510      	push	{r4, r14}
	pmudev_t *dev = (pmudev_t *)handle;
	pmu_drv_ops_t *ops;

	if (dev == NULL || dev->priv_data == NULL) {
  106fd6:	b130      	cbz	r0, 106fe6 <hal_pmu_set_powerctrl_out_ctrl+0x12>
  106fd8:	6943      	ldr	r3, [r0, #20]
  106fda:	b123      	cbz	r3, 106fe6 <hal_pmu_set_powerctrl_out_ctrl+0x12>
		return -1;
	}

	ops = (pmu_drv_ops_t *)dev->priv_data;

	if (ops->pwr_ctrl.set_out_ctrl != NULL)
  106fdc:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  106fde:	b18b      	cbz	r3, 107004 <hal_pmu_set_powerctrl_out_ctrl+0x30>
		return ops->pwr_ctrl.set_out_ctrl(dev, ctrl_id, out);

	pmu_err("%s is not support\n", __func__);
	return -1;
}
  106fe0:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
		return ops->pwr_ctrl.set_out_ctrl(dev, ctrl_id, out);
  106fe4:	4718      	bx	r3
		pmu_err("parameters is wrong\n");
  106fe6:	f64f 21dc 	movw	r1, #64220	; 0xfadc
  106fea:	f64f 20fc 	movw	r0, #64252	; 0xfafc
  106fee:	f2c0 0110 	movt	r1, #16
  106ff2:	f44f 72e5 	mov.w	r2, #458	; 0x1ca
  106ff6:	f2c0 0010 	movt	r0, #16
  106ffa:	f004 f96f 	bl	10b2dc <printf>
}
  106ffe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  107002:	bd10      	pop	{r4, r15}
	pmu_err("%s is not support\n", __func__);
  107004:	f64f 23dc 	movw	r3, #64220	; 0xfadc
  107008:	f64f 3038 	movw	r0, #64312	; 0xfb38
  10700c:	f240 12d3 	movw	r2, #467	; 0x1d3
  107010:	f2c0 0310 	movt	r3, #16
  107014:	4619      	mov	r1, r3
  107016:	f2c0 0010 	movt	r0, #16
  10701a:	f004 f95f 	bl	10b2dc <printf>
	return -1;
  10701e:	e7ee      	b.n	106ffe <hal_pmu_set_powerctrl_out_ctrl+0x2a>

00107020 <hal_port_creat_handle>:
spin_lock_t port_spin_lock = SPIN_LOCK_INITIAL_VALUE;

static struct port_handle s_port_handle;

bool hal_port_creat_handle(void **handle, uint32_t port_res_glb_idx)
{
  107020:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct port_handle *p_handle;
    int8_t ret = 0;
    paddr_t phy_addr = 0;
  107022:	2400      	movs	r4, #0
{
  107024:	b085      	sub	sp, #20
  107026:	4606      	mov	r6, r0
    paddr_t dio_phy_addr = 0;
    int32_t dio_real_idx = 0;
    spin_lock_saved_state_t states;
    LTRACEF("+hal_port_creat_handle \n");

    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  107028:	aa01      	add	r2, sp, #4
    int32_t real_idx = 0;
  10702a:	e9cd 4400 	strd	r4, r4, [r13]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  10702e:	4608      	mov	r0, r1
    int32_t dio_real_idx = 0;
  107030:	e9cd 4402 	strd	r4, r4, [r13, #8]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  107034:	4669      	mov	r1, r13
  107036:	f000 f9b1 	bl	10739c <res_get_info_by_id>

    if (ret != -1) {
  10703a:	b240      	sxtb	r0, r0
  10703c:	3001      	adds	r0, #1
  10703e:	d046      	beq.n	1070ce <hal_port_creat_handle+0xae>
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
        return false;
    }

    /* To get GPIO base address for Port */
    ret = res_get_info_by_id(g_gpio_res.res_id[0], &dio_phy_addr, &dio_real_idx);
  107040:	f640 2378 	movw	r3, #2680	; 0xa78
  107044:	aa03      	add	r2, sp, #12
  107046:	f2c0 0311 	movt	r3, #17
  10704a:	a902      	add	r1, sp, #8
  10704c:	6858      	ldr	r0, [r3, #4]
  10704e:	f000 f9a5 	bl	10739c <res_get_info_by_id>

    if (ret != -1) {
  107052:	b240      	sxtb	r0, r0
  107054:	3001      	adds	r0, #1
  107056:	d043      	beq.n	1070e0 <hal_port_creat_handle+0xc0>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107058:	f3ef 8300 	mrs	r3, CPSR
  10705c:	f013 0580 	ands.w	r5, r3, #128	; 0x80
  107060:	d11b      	bne.n	10709a <hal_port_creat_handle+0x7a>
    __asm__ volatile("cpsid i");
  107062:	b672      	cpsid	i

#endif

    p_handle = &s_port_handle;
    spin_lock_irqsave(&port_spin_lock, states);
    p_handle->phy_addr = phy_addr;
  107064:	f247 13c8 	movw	r3, #29128	; 0x71c8
    *lock = 1;
  107068:	f247 17c4 	movw	r7, #29124	; 0x71c4
  10706c:	9a00      	ldr	r2, [sp, #0]
  10706e:	f2c0 0311 	movt	r3, #17
  107072:	2401      	movs	r4, #1
  107074:	f2c0 0711 	movt	r7, #17
  107078:	601a      	str	r2, [r3, #0]
    p_handle->real_idx = real_idx;
    p_handle->dio_phy_addr = dio_phy_addr;
    p_handle->dio_real_idx = dio_real_idx;
    *handle = p_handle;
    Port_SetHandle((void *)p_handle);
  10707a:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  10707c:	9a01      	ldr	r2, [sp, #4]
  10707e:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  107080:	9a02      	ldr	r2, [sp, #8]
  107082:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  107084:	9a03      	ldr	r2, [sp, #12]
  107086:	60da      	str	r2, [r3, #12]
  107088:	603c      	str	r4, [r7, #0]
    *handle = p_handle;
  10708a:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  10708c:	f7fe fa5c 	bl	105548 <Port_SetHandle>
    *lock = 0;
  107090:	603d      	str	r5, [r7, #0]
    __asm__ volatile("cpsie i");
  107092:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);


    LTRACEF("-hal_port_creat_handle finished\n");

    return true;
  107094:	4620      	mov	r0, r4
}
  107096:	b005      	add	sp, #20
  107098:	bdf0      	pop	{r4, r5, r6, r7, r15}
    p_handle->phy_addr = phy_addr;
  10709a:	f247 13c8 	movw	r3, #29128	; 0x71c8
    *lock = 1;
  10709e:	f247 17c4 	movw	r7, #29124	; 0x71c4
  1070a2:	9a00      	ldr	r2, [sp, #0]
  1070a4:	f2c0 0311 	movt	r3, #17
  1070a8:	2501      	movs	r5, #1
  1070aa:	f2c0 0711 	movt	r7, #17
  1070ae:	601a      	str	r2, [r3, #0]
    Port_SetHandle((void *)p_handle);
  1070b0:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  1070b2:	9a01      	ldr	r2, [sp, #4]
  1070b4:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  1070b6:	9a02      	ldr	r2, [sp, #8]
  1070b8:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  1070ba:	9a03      	ldr	r2, [sp, #12]
  1070bc:	603d      	str	r5, [r7, #0]
  1070be:	60da      	str	r2, [r3, #12]
    *handle = p_handle;
  1070c0:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  1070c2:	f7fe fa41 	bl	105548 <Port_SetHandle>
    *lock = 0;
  1070c6:	603c      	str	r4, [r7, #0]
    return true;
  1070c8:	4628      	mov	r0, r5
}
  1070ca:	b005      	add	sp, #20
  1070cc:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
  1070ce:	f240 3000 	movw	r0, #768	; 0x300
  1070d2:	f2c0 0011 	movt	r0, #17
  1070d6:	f004 f8e9 	bl	10b2ac <puts>
        return false;
  1070da:	4620      	mov	r0, r4
}
  1070dc:	b005      	add	sp, #20
  1070de:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for dio failed! 03\n");
  1070e0:	f240 3040 	movw	r0, #832	; 0x340
  1070e4:	f2c0 0011 	movt	r0, #17
  1070e8:	f004 f8e0 	bl	10b2ac <puts>
        return false;
  1070ec:	4620      	mov	r0, r4
}
  1070ee:	b005      	add	sp, #20
  1070f0:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1070f2:	bf00      	nop

001070f4 <hal_port_release_handle>:

bool hal_port_release_handle(void **handle)
{
  1070f4:	b510      	push	{r4, r14}
  1070f6:	b082      	sub	sp, #8
    ASSERT(handle);
  1070f8:	b310      	cbz	r0, 107140 <hal_port_release_handle+0x4c>
    struct port_handle *port = *handle;
  1070fa:	6802      	ldr	r2, [r0, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1070fc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107100:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  107104:	d10e      	bne.n	107124 <hal_port_release_handle+0x30>
    __asm__ volatile("cpsid i");
  107106:	b672      	cpsid	i
    *lock = 0;
  107108:	f247 11c4 	movw	r1, #29124	; 0x71c4
    spin_lock_saved_state_t states;

    spin_lock_irqsave(&port_spin_lock, states);
    port->phy_addr = 0;
    port->real_idx = -1;
  10710c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  107110:	f2c0 0111 	movt	r1, #17
  107114:	e9c2 3400 	strd	r3, r4, [r2]
    *handle = NULL;
  107118:	6003      	str	r3, [r0, #0]
  10711a:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
  10711c:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);

    return true;
}
  10711e:	2001      	movs	r0, #1
  107120:	b002      	add	sp, #8
  107122:	bd10      	pop	{r4, r15}
  107124:	f247 13c4 	movw	r3, #29124	; 0x71c4
    port->phy_addr = 0;
  107128:	2100      	movs	r1, #0
    port->real_idx = -1;
  10712a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  10712e:	f2c0 0311 	movt	r3, #17
  107132:	e9c2 1400 	strd	r1, r4, [r2]
    *handle = NULL;
  107136:	6001      	str	r1, [r0, #0]
}
  107138:	2001      	movs	r0, #1
  10713a:	6019      	str	r1, [r3, #0]
  10713c:	b002      	add	sp, #8
  10713e:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  107140:	f64b 6398 	movw	r3, #48792	; 0xbe98
  107144:	f240 3280 	movw	r2, #896	; 0x380
  107148:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10714c:	f2c0 0310 	movt	r3, #16
  107150:	4670      	mov	r0, r14
  107152:	f2c0 0211 	movt	r2, #17
  107156:	9300      	str	r3, [sp, #0]
  107158:	f2c0 0110 	movt	r1, #16
  10715c:	2374      	movs	r3, #116	; 0x74
  10715e:	f003 f889 	bl	10a274 <_panic>
  107162:	bf00      	nop

00107164 <hal_port_init>:

    return true;
}

int hal_port_init(void *handle)
{
  107164:	b500      	push	{r14}
  107166:	b085      	sub	sp, #20
    ASSERT(handle);
  107168:	b160      	cbz	r0, 107184 <hal_port_init+0x20>

    Port_ConfigType port_config;

#if NOT_USE_SYS_CFG
    port_config = (Port_ConfigType){&Port_kConfiguration[0]};
  10716a:	f64f 3358 	movw	r3, #64344	; 0xfb58
  10716e:	a804      	add	r0, sp, #16
  107170:	f2c0 0310 	movt	r3, #16
  107174:	f840 3d04 	str.w	r3, [r0, #-4]!
        port_config = (Port_ConfigType){(Port_n_ConfigType*)(void*)addr_config};
    }
#endif

    LTRACEF("hal_port_init \n");
    Port_Init(&port_config);
  107178:	f7fe f816 	bl	1051a8 <Port_Init>

    return true;
}
  10717c:	2001      	movs	r0, #1
  10717e:	b005      	add	sp, #20
  107180:	f85d fb04 	ldr.w	r15, [r13], #4
    ASSERT(handle);
  107184:	f64b 6398 	movw	r3, #48792	; 0xbe98
  107188:	f240 3280 	movw	r2, #896	; 0x380
  10718c:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  107190:	f2c0 0310 	movt	r3, #16
  107194:	4670      	mov	r0, r14
  107196:	f2c0 0211 	movt	r2, #17
  10719a:	9300      	str	r3, [sp, #0]
  10719c:	f2c0 0110 	movt	r1, #16
  1071a0:	2395      	movs	r3, #149	; 0x95
  1071a2:	f003 f867 	bl	10a274 <_panic>
  1071a6:	bf00      	nop

001071a8 <hal_port_set_pin_mode>:
    return true;
}

int hal_port_set_pin_mode(void *handle, const Port_PinType pin,
                          const Port_PinModeType mode)
{
  1071a8:	b510      	push	{r4, r14}
  1071aa:	b084      	sub	sp, #16
  1071ac:	ac02      	add	r4, sp, #8
  1071ae:	e884 000c 	stmia.w	r4, {r2, r3}
    ASSERT(handle);
  1071b2:	b138      	cbz	r0, 1071c4 <hal_port_set_pin_mode+0x1c>
    Port_SetPinMode(pin, mode);
  1071b4:	4608      	mov	r0, r1
  1071b6:	e894 0006 	ldmia.w	r4, {r1, r2}
  1071ba:	f7fe f957 	bl	10546c <Port_SetPinMode>

    return true;
}
  1071be:	2001      	movs	r0, #1
  1071c0:	b004      	add	sp, #16
  1071c2:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  1071c4:	f64b 6398 	movw	r3, #48792	; 0xbe98
  1071c8:	f240 3280 	movw	r2, #896	; 0x380
  1071cc:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  1071d0:	f2c0 0310 	movt	r3, #16
  1071d4:	4670      	mov	r0, r14
  1071d6:	f2c0 0211 	movt	r2, #17
  1071da:	9300      	str	r3, [sp, #0]
  1071dc:	f2c0 0110 	movt	r1, #16
  1071e0:	23f6      	movs	r3, #246	; 0xf6
  1071e2:	f003 f847 	bl	10a274 <_panic>
  1071e6:	bf00      	nop

001071e8 <parse_paddr_ppc>:
    return -1;
}

/* Parse address for peripheral type resources */
int32_t parse_paddr_ppc(uint32_t ppc_index, uint32_t slot_index, addr_t * paddr)
{
  1071e8:	b5f0      	push	{r4, r5, r6, r7, r14}
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  1071ea:	f240 34a8 	movw	r4, #936	; 0x3a8
{
  1071ee:	4607      	mov	r7, r0
  1071f0:	468c      	mov	r12, r1
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  1071f2:	f2c0 0411 	movt	r4, #17
{
  1071f6:	4696      	mov	r14, r2
                                APBMUX5_IP_BASE, APBMUX6_IP_BASE, APBMUX7_IP_BASE, APBMUX8_IP_BASE,
                                APB_DDR_CFG_BASE, APB_SMMU_BASE, APB_CE2_REG_BASE, APB_SCR4K_SID_BASE,
                                APB_SCR4K_SSID_BASE, APB_CSSYS_BASE};
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  1071f8:	f104 0538 	add.w	r5, r4, #56	; 0x38
{
  1071fc:	b09d      	sub	sp, #116	; 0x74
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  1071fe:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  107200:	466e      	mov	r6, r13
  107202:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  107204:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  107206:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  107208:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  10720a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  10720c:	e894 0003 	ldmia.w	r4, {r0, r1}
                                APBMUX5_IP_SIZE, APBMUX6_IP_SIZE, APBMUX7_IP_SIZE, APBMUX8_IP_SIZE,
                                APB_DDR_CFG_SIZE, APB_SMMU_SIZE, APB_CE2_REG_SIZE, APB_SCR4K_SID_SIZE,
                                APB_SCR4K_SSID_SIZE, APB_CSSYS_SIZE};

    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  107210:	ab1c      	add	r3, sp, #112	; 0x70
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  107212:	e886 0003 	stmia.w	r6, {r0, r1}
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  107216:	eb03 0687 	add.w	r6, r3, r7, lsl #2
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  10721a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  10721c:	ac0e      	add	r4, sp, #56	; 0x38
  10721e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  107220:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  107222:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  107224:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  107226:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  107228:	e895 0003 	ldmia.w	r5, {r0, r1}
  10722c:	e884 0003 	stmia.w	r4, {r0, r1}

    return 0;
}
  107230:	2000      	movs	r0, #0
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  107232:	f856 2c38 	ldr.w	r2, [r6, #-56]
  107236:	f856 3c70 	ldr.w	r3, [r6, #-112]
  10723a:	fb02 330c 	mla	r3, r2, r12, r3
  10723e:	f8ce 3000 	str.w	r3, [r14]
}
  107242:	b01d      	add	sp, #116	; 0x74
  107244:	bdf0      	pop	{r4, r5, r6, r7, r15}
  107246:	bf00      	nop

00107248 <parse_paddr_rpc>:

/* Parse address and index for register level resources */
int32_t parse_paddr_rpc(uint32_t rpc_index, uint32_t slot_index, addr_t * paddr, int32_t * index)
{
  107248:	b410      	push	{r4}
    if (slot_index >= 2046) {
  10724a:	f240 74fd 	movw	r4, #2045	; 0x7fd
  10724e:	42a1      	cmp	r1, r4
  107250:	d824      	bhi.n	10729c <parse_paddr_rpc+0x54>
        return -1;
    }

    uint32_t addr_offset = 0;

    if (slot_index >= IOMUXC_INDEX) {
  107252:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
  107256:	d213      	bcs.n	107280 <parse_paddr_rpc+0x38>
        *index = slot_index - IOMUXC_INDEX;
        addr_offset = 5;
    }
    else if (slot_index >= RSTGEN_INDEX) {
  107258:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  10725c:	d32b      	bcc.n	1072b6 <parse_paddr_rpc+0x6e>
        *index = slot_index - RSTGEN_INDEX;
        addr_offset = 4;
  10725e:	2404      	movs	r4, #4
        *index = slot_index - RSTGEN_INDEX;
  107260:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
  107264:	6019      	str	r1, [r3, #0]
    }
    else {
        *index = slot_index;
    }

    switch (rpc_index) {
  107266:	2801      	cmp	r0, #1
  107268:	d010      	beq.n	10728c <parse_paddr_rpc+0x44>
  10726a:	d31c      	bcc.n	1072a6 <parse_paddr_rpc+0x5e>
  10726c:	2802      	cmp	r0, #2
  10726e:	d115      	bne.n	10729c <parse_paddr_rpc+0x54>
        default:
            return -1;
        break;
    }

    return 0;
  107270:	2000      	movs	r0, #0
            *paddr = APB_RPC_SAF_BASE + addr_offset * RPC_ADDR_OFFSET;
  107272:	f504 647c 	add.w	r4, r4, #4032	; 0xfc0
  107276:	0524      	lsls	r4, r4, #20
  107278:	6014      	str	r4, [r2, #0]
}
  10727a:	f85d 4b04 	ldr.w	r4, [r13], #4
  10727e:	4770      	bx	r14
        *index = slot_index - IOMUXC_INDEX;
  107280:	f5a1 61a0 	sub.w	r1, r1, #1280	; 0x500
        addr_offset = 5;
  107284:	2405      	movs	r4, #5
    switch (rpc_index) {
  107286:	2801      	cmp	r0, #1
        *index = slot_index - IOMUXC_INDEX;
  107288:	6019      	str	r1, [r3, #0]
    switch (rpc_index) {
  10728a:	d1ee      	bne.n	10726a <parse_paddr_rpc+0x22>
    return 0;
  10728c:	2000      	movs	r0, #0
            *paddr = APB_RPC_SEC_BASE + addr_offset * RPC_ADDR_OFFSET;
  10728e:	f504 6478 	add.w	r4, r4, #3968	; 0xf80
  107292:	0524      	lsls	r4, r4, #20
  107294:	6014      	str	r4, [r2, #0]
}
  107296:	f85d 4b04 	ldr.w	r4, [r13], #4
  10729a:	4770      	bx	r14
  10729c:	f85d 4b04 	ldr.w	r4, [r13], #4
            return -1;
  1072a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1072a4:	4770      	bx	r14
    return 0;
  1072a6:	2000      	movs	r0, #0
            *paddr = APB_RPC_SOC_BASE + addr_offset * RPC_ADDR_OFFSET;
  1072a8:	f504 6476 	add.w	r4, r4, #3936	; 0xf60
  1072ac:	0524      	lsls	r4, r4, #20
  1072ae:	6014      	str	r4, [r2, #0]
}
  1072b0:	f85d 4b04 	ldr.w	r4, [r13], #4
  1072b4:	4770      	bx	r14
    else if (slot_index >= SCR_INDEX) {
  1072b6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
        addr_offset = 2;
  1072ba:	bf26      	itte	cs
  1072bc:	2402      	movcs	r4, #2
        *index = slot_index - SCR_INDEX;
  1072be:	f5a1 7100 	subcs.w	r1, r1, #512	; 0x200
    uint32_t addr_offset = 0;
  1072c2:	2400      	movcc	r4, #0
        *index = slot_index;
  1072c4:	6019      	str	r1, [r3, #0]
  1072c6:	e7ce      	b.n	107266 <parse_paddr_rpc+0x1e>

001072c8 <res_parse_info>:

/* Parse resource ID to acquire base address and index of resource */
int32_t res_parse_info(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  1072c8:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t rapc_type;
    uint32_t rapc_index;
    uint32_t slot_index;
    int32_t res = 0;

    *index = -1;
  1072ca:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff

    rapc_type = res_id >> 30;
  1072ce:	0f84      	lsrs	r4, r0, #30
{
  1072d0:	4613      	mov	r3, r2
    rapc_index = (res_id >> 24) & 0x3F;
    slot_index = res_id & 0xFFF;

    switch (rapc_type) {
  1072d2:	2c02      	cmp	r4, #2
    *index = -1;
  1072d4:	6015      	str	r5, [r2, #0]
    rapc_index = (res_id >> 24) & 0x3F;
  1072d6:	f3c0 6605 	ubfx	r6, r0, #24, #6
    slot_index = res_id & 0xFFF;
  1072da:	f3c0 070b 	ubfx	r7, r0, #0, #12
    switch (rapc_type) {
  1072de:	d042      	beq.n	107366 <res_parse_info+0x9e>
  1072e0:	2c03      	cmp	r4, #3
  1072e2:	d02d      	beq.n	107340 <res_parse_info+0x78>
  1072e4:	2c01      	cmp	r4, #1
  1072e6:	d020      	beq.n	10732a <res_parse_info+0x62>
        case 0: //MPC
            if (rapc_index >= MPC_MAX_NUM) {
  1072e8:	2e1a      	cmp	r6, #26
  1072ea:	d839      	bhi.n	107360 <res_parse_info+0x98>
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  1072ec:	f3c0 4246 	ubfx	r2, r0, #17, #7
    if (cat_id >= MPC_CATEGORY_MAX) {
  1072f0:	2a0d      	cmp	r2, #13
  1072f2:	d835      	bhi.n	107360 <res_parse_info+0x98>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  1072f4:	f644 1380 	movw	r3, #18816	; 0x4980
  1072f8:	f2c0 0311 	movt	r3, #17
  1072fc:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  107300:	6816      	ldr	r6, [r2, #0]
  107302:	2e00      	cmp	r6, #0
  107304:	dd2c      	ble.n	107360 <res_parse_info+0x98>
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  107306:	6853      	ldr	r3, [r2, #4]
  107308:	4298      	cmp	r0, r3
  10730a:	bf1c      	itt	ne
  10730c:	4614      	movne	r4, r2
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  10730e:	2300      	movne	r3, #0
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  107310:	d103      	bne.n	10731a <res_parse_info+0x52>
  107312:	e030      	b.n	107376 <res_parse_info+0xae>
  107314:	6865      	ldr	r5, [r4, #4]
  107316:	42a8      	cmp	r0, r5
  107318:	d02e      	beq.n	107378 <res_parse_info+0xb0>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  10731a:	3301      	adds	r3, #1
  10731c:	429e      	cmp	r6, r3
  10731e:	f104 0408 	add.w	r4, r4, #8
  107322:	d1f7      	bne.n	107314 <res_parse_info+0x4c>
            }

            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
            break;
        case 3: //unprotected
            res = -1;
  107324:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  107328:	e01b      	b.n	107362 <res_parse_info+0x9a>
            if (rapc_index >= PPC_MAX_NUM) {
  10732a:	2e0d      	cmp	r6, #13
  10732c:	d818      	bhi.n	107360 <res_parse_info+0x98>
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  10732e:	460a      	mov	r2, r1
            *index = (res_id >> 12) & 0x1F;
  107330:	f3c0 3004 	ubfx	r0, r0, #12, #5
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  107334:	4639      	mov	r1, r7
            *index = (res_id >> 12) & 0x1F;
  107336:	6018      	str	r0, [r3, #0]
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  107338:	4630      	mov	r0, r6
        default:
            return -1;
    }

    return res;
}
  10733a:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  10733c:	f7ff bf54 	b.w	1071e8 <parse_paddr_ppc>
                if (res_id == mem_info_unprotected.mem_info[i].res_id) {
  107340:	f641 13b4 	movw	r3, #6580	; 0x19b4
  107344:	f2c0 0311 	movt	r3, #17
  107348:	685a      	ldr	r2, [r3, #4]
  10734a:	4290      	cmp	r0, r2
  10734c:	d01a      	beq.n	107384 <res_parse_info+0xbc>
  10734e:	68da      	ldr	r2, [r3, #12]
  107350:	4290      	cmp	r0, r2
  107352:	d01e      	beq.n	107392 <res_parse_info+0xca>
  107354:	695a      	ldr	r2, [r3, #20]
  107356:	4290      	cmp	r0, r2
  107358:	d01d      	beq.n	107396 <res_parse_info+0xce>
  10735a:	69da      	ldr	r2, [r3, #28]
  10735c:	4290      	cmp	r0, r2
  10735e:	d012      	beq.n	107386 <res_parse_info+0xbe>
            res = -1;
  107360:	4628      	mov	r0, r5
}
  107362:	bcf0      	pop	{r4, r5, r6, r7}
  107364:	4770      	bx	r14
            if (rapc_index >= PPC_MAX_NUM) {
  107366:	2e0d      	cmp	r6, #13
  107368:	d8fa      	bhi.n	107360 <res_parse_info+0x98>
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  10736a:	460a      	mov	r2, r1
  10736c:	4630      	mov	r0, r6
  10736e:	4639      	mov	r1, r7
}
  107370:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  107372:	f7ff bf69 	b.w	107248 <parse_paddr_rpc>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  107376:	2300      	movs	r3, #0
            return 0;
  107378:	2000      	movs	r0, #0
            *paddr = mem_info_init[cat_id]->mem_info[i].paddr;
  10737a:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  10737e:	689b      	ldr	r3, [r3, #8]
  107380:	600b      	str	r3, [r1, #0]
  107382:	e7ee      	b.n	107362 <res_parse_info+0x9a>
            for (int i = 0; i < mem_info_unprotected.res_num; i++) {
  107384:	2400      	movs	r4, #0
                    res = 0;
  107386:	2000      	movs	r0, #0
                    *paddr = mem_info_unprotected.mem_info[i].paddr;
  107388:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  10738c:	68a3      	ldr	r3, [r4, #8]
  10738e:	600b      	str	r3, [r1, #0]
                    break;
  107390:	e7e7      	b.n	107362 <res_parse_info+0x9a>
            for (int i = 0; i < mem_info_unprotected.res_num; i++) {
  107392:	2401      	movs	r4, #1
  107394:	e7f7      	b.n	107386 <res_parse_info+0xbe>
  107396:	2402      	movs	r4, #2
  107398:	e7f5      	b.n	107386 <res_parse_info+0xbe>
  10739a:	bf00      	nop

0010739c <res_get_info_by_id>:

/* Get resource info by ID. */
const int32_t res_get_info_by_id(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  10739c:	b470      	push	{r4, r5, r6}
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  10739e:	f3c0 4446 	ubfx	r4, r0, #17, #7

    if (cat_id >= (sizeof(g_res_cat) / sizeof(g_res_cat[0]))) {
  1073a2:	2c4d      	cmp	r4, #77	; 0x4d
  1073a4:	d817      	bhi.n	1073d6 <res_get_info_by_id+0x3a>
        return -1;
    }

    if (NULL != g_res_cat[cat_id]) { //check avaibility of resource
  1073a6:	f241 330c 	movw	r3, #4876	; 0x130c
  1073aa:	f2c0 0311 	movt	r3, #17
  1073ae:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
  1073b2:	b184      	cbz	r4, 1073d6 <res_get_info_by_id+0x3a>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  1073b4:	6826      	ldr	r6, [r4, #0]
  1073b6:	2e00      	cmp	r6, #0
  1073b8:	dd0d      	ble.n	1073d6 <res_get_info_by_id+0x3a>
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  1073ba:	6863      	ldr	r3, [r4, #4]
  1073bc:	4298      	cmp	r0, r3
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  1073be:	bf1c      	itt	ne
  1073c0:	2300      	movne	r3, #0
  1073c2:	3404      	addne	r4, #4
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  1073c4:	d104      	bne.n	1073d0 <res_get_info_by_id+0x34>
  1073c6:	e00a      	b.n	1073de <res_get_info_by_id+0x42>
  1073c8:	f854 5f04 	ldr.w	r5, [r4, #4]!
  1073cc:	4285      	cmp	r5, r0
  1073ce:	d006      	beq.n	1073de <res_get_info_by_id+0x42>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  1073d0:	3301      	adds	r3, #1
  1073d2:	42b3      	cmp	r3, r6
  1073d4:	d1f8      	bne.n	1073c8 <res_get_info_by_id+0x2c>
                return res_parse_info(res_id, paddr, index);
        }
    }

    return -1;
}
  1073d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1073da:	bc70      	pop	{r4, r5, r6}
  1073dc:	4770      	bx	r14
  1073de:	bc70      	pop	{r4, r5, r6}
                return res_parse_info(res_id, paddr, index);
  1073e0:	f7ff bf72 	b.w	1072c8 <res_parse_info>

001073e4 <hal_rstgen_creat_handle>:
//! \return rstgen handle
//
//*****************************************************************************
bool hal_rstgen_creat_handle(void **handle,
                             uint32_t global_rst_res_idx)
{
  1073e4:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    int32_t idx = -1;
  1073e8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  1073ec:	b083      	sub	sp, #12
    int32_t idx = -1;
  1073ee:	9301      	str	r3, [sp, #4]
    rstgen_instance_t  *instance = NULL;

    if (handle == NULL) {
  1073f0:	b390      	cbz	r0, 107458 <hal_rstgen_creat_handle+0x74>
        LTRACEF("hal_get_resource paramenter error handle:%p\n", handle);
        return false;
    }

    if (rstgen_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  1073f2:	f247 2504 	movw	r5, #29188	; 0x7204
  1073f6:	f2c0 0511 	movt	r5, #17
  1073fa:	682b      	ldr	r3, [r5, #0]
  1073fc:	b10b      	cbz	r3, 107402 <hal_rstgen_creat_handle+0x1e>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  1073fe:	2300      	movs	r3, #0
  107400:	602b      	str	r3, [r5, #0]
  107402:	4607      	mov	r7, r0
  107404:	4689      	mov	r9, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107406:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10740a:	f013 0680 	ands.w	r6, r3, #128	; 0x80
  10740e:	d127      	bne.n	107460 <hal_rstgen_creat_handle+0x7c>
    __asm__ volatile("cpsid i");
  107410:	b672      	cpsid	i
    if (g_RstgenInstance.occupied != 1) {
  107412:	f247 14d8 	movw	r4, #29144	; 0x71d8
    *lock = 1;
  107416:	f04f 0801 	mov.w	r8, #1
  10741a:	f2c0 0411 	movt	r4, #17
  10741e:	7a23      	ldrb	r3, [r4, #8]
  107420:	4543      	cmp	r3, r8
  107422:	d048      	beq.n	1074b6 <hal_rstgen_creat_handle+0xd2>
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  107424:	2228      	movs	r2, #40	; 0x28
  107426:	4631      	mov	r1, r6
  107428:	4620      	mov	r0, r4
  10742a:	f003 e82c 	blx	10a484 <memset>
            g_RstgenInstance.occupied = 1;
  10742e:	f884 8008 	strb.w	r8, [r4, #8]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  107432:	f884 801b 	strb.w	r8, [r4, #27]
    *controllerTable = &s_RstgenDrvInterface;
  107436:	f641 13d8 	movw	r3, #6616	; 0x19d8
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  10743a:	f884 801c 	strb.w	r8, [r4, #28]
    *controllerTable = &s_RstgenDrvInterface;
  10743e:	f2c0 0311 	movt	r3, #17
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  107442:	f884 801d 	strb.w	r8, [r4, #29]
    *lock = 0;
  107446:	602e      	str	r6, [r5, #0]
    *controllerTable = &s_RstgenDrvInterface;
  107448:	62a3      	str	r3, [r4, #40]	; 0x28
    __asm__ volatile("cpsie i");
  10744a:	b662      	cpsie	i

    if (instance == NULL) {
        return false;
    }

    if (res_get_info_by_id(global_rst_res_idx,
  10744c:	491b      	ldr	r1, [pc, #108]	; (1074bc <hal_rstgen_creat_handle+0xd8>)
  10744e:	4648      	mov	r0, r9
  107450:	aa01      	add	r2, sp, #4
  107452:	f7ff ffa3 	bl	10739c <res_get_info_by_id>
  107456:	b1a8      	cbz	r0, 107484 <hal_rstgen_creat_handle+0xa0>
        return false;
  107458:	2000      	movs	r0, #0

    mutex_init(&instance->rstgenMutex);

    *handle = instance;
    return true;
}
  10745a:	b003      	add	sp, #12
  10745c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    if (g_RstgenInstance.occupied != 1) {
  107460:	f247 14d8 	movw	r4, #29144	; 0x71d8
    *lock = 1;
  107464:	2601      	movs	r6, #1
  107466:	f2c0 0411 	movt	r4, #17
  10746a:	7a23      	ldrb	r3, [r4, #8]
  10746c:	42b3      	cmp	r3, r6
    *lock = 0;
  10746e:	bf04      	itt	eq
  107470:	2300      	moveq	r3, #0
  107472:	602b      	streq	r3, [r5, #0]
  107474:	d10e      	bne.n	107494 <hal_rstgen_creat_handle+0xb0>
    if (res_get_info_by_id(global_rst_res_idx,
  107476:	4648      	mov	r0, r9
  107478:	aa01      	add	r2, sp, #4
  10747a:	4910      	ldr	r1, [pc, #64]	; (1074bc <hal_rstgen_creat_handle+0xd8>)
  10747c:	f7ff ff8e 	bl	10739c <res_get_info_by_id>
  107480:	2800      	cmp	r0, #0
  107482:	d1e9      	bne.n	107458 <hal_rstgen_creat_handle+0x74>
    mutex_init(&instance->rstgenMutex);
  107484:	480e      	ldr	r0, [pc, #56]	; (1074c0 <hal_rstgen_creat_handle+0xdc>)
  107486:	f004 f83f 	bl	10b508 <mutex_init>
    *handle = instance;
  10748a:	603c      	str	r4, [r7, #0]
    return true;
  10748c:	2001      	movs	r0, #1
}
  10748e:	b003      	add	sp, #12
  107490:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  107494:	2228      	movs	r2, #40	; 0x28
  107496:	2100      	movs	r1, #0
  107498:	4620      	mov	r0, r4
  10749a:	f002 eff4 	blx	10a484 <memset>
    *controllerTable = &s_RstgenDrvInterface;
  10749e:	f641 13d8 	movw	r3, #6616	; 0x19d8
  1074a2:	2200      	movs	r2, #0
  1074a4:	f2c0 0311 	movt	r3, #17
            g_RstgenInstance.occupied = 1;
  1074a8:	7226      	strb	r6, [r4, #8]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  1074aa:	76e6      	strb	r6, [r4, #27]
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  1074ac:	7726      	strb	r6, [r4, #28]
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  1074ae:	7766      	strb	r6, [r4, #29]
    *controllerTable = &s_RstgenDrvInterface;
  1074b0:	62a3      	str	r3, [r4, #40]	; 0x28
  1074b2:	602a      	str	r2, [r5, #0]
  1074b4:	e7df      	b.n	107476 <hal_rstgen_creat_handle+0x92>
  1074b6:	602e      	str	r6, [r5, #0]
  1074b8:	e7c7      	b.n	10744a <hal_rstgen_creat_handle+0x66>
  1074ba:	bf00      	nop
  1074bc:	001171e4 	.word	0x001171e4
  1074c0:	001171dc 	.word	0x001171dc

001074c4 <hal_rstgen_release_handle>:
//*****************************************************************************
bool hal_rstgen_release_handle(void *handle)
{
    rstgen_instance_t *instance = NULL;

    if (handle == NULL) {
  1074c4:	b140      	cbz	r0, 1074d8 <hal_rstgen_release_handle+0x14>
{
  1074c6:	b508      	push	{r3, r14}
                handle);
        return false;
    }

    instance = (rstgen_instance_t *)handle;
    instance->occupied = 0;
  1074c8:	2200      	movs	r2, #0
  1074ca:	4603      	mov	r3, r0
    mutex_destroy(&instance->rstgenMutex);
  1074cc:	3004      	adds	r0, #4
    instance->occupied = 0;
  1074ce:	721a      	strb	r2, [r3, #8]
    mutex_destroy(&instance->rstgenMutex);
  1074d0:	f004 f822 	bl	10b518 <mutex_destroy>
    return true;
  1074d4:	2001      	movs	r0, #1
}
  1074d6:	bd08      	pop	{r3, r15}
  1074d8:	4770      	bx	r14
  1074da:	bf00      	nop

001074dc <hal_rstgen_init>:
}
#else
bool hal_rstgen_init(void *handle)
{
    return true;
}
  1074dc:	2001      	movs	r0, #1
  1074de:	4770      	bx	r14

001074e0 <hal_rstgen_iso_disable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_iso_disable(void *handle, uint32_t res_glb_idx)
{
  1074e0:	b530      	push	{r4, r5, r14}
    bool ret = false;
    paddr_t phy_addr = 0;
    int32_t iso_idx = -1;
  1074e2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  1074e6:	b083      	sub	sp, #12
    paddr_t phy_addr = 0;
  1074e8:	2400      	movs	r4, #0
    int32_t iso_idx = -1;
  1074ea:	aa02      	add	r2, sp, #8
{
  1074ec:	4605      	mov	r5, r0
    vaddr_t base = 0x0;
    rstgen_instance_t *instance = NULL;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  1074ee:	4608      	mov	r0, r1
    int32_t iso_idx = -1;
  1074f0:	f842 3d04 	str.w	r3, [r2, #-4]!
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  1074f4:	4669      	mov	r1, r13
    paddr_t phy_addr = 0;
  1074f6:	9400      	str	r4, [sp, #0]
    if (res_get_info_by_id(res_glb_idx, &phy_addr, &iso_idx)) {
  1074f8:	f7ff ff50 	bl	10739c <res_get_info_by_id>
  1074fc:	b948      	cbnz	r0, 107512 <hal_rstgen_iso_disable+0x32>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((iso_idx > 0) && instance->controllerTable->iso_disable) {
  1074fe:	9901      	ldr	r1, [sp, #4]
  107500:	42a1      	cmp	r1, r4
  107502:	dd04      	ble.n	10750e <hal_rstgen_iso_disable+0x2e>
  107504:	6aab      	ldr	r3, [r5, #40]	; 0x28
  107506:	6a1c      	ldr	r4, [r3, #32]
  107508:	b11c      	cbz	r4, 107512 <hal_rstgen_iso_disable+0x32>
        ret = instance->controllerTable->iso_disable(
  10750a:	9800      	ldr	r0, [sp, #0]
  10750c:	47a0      	blx	r4
                  (vaddr_t)base, (uint32_t)iso_idx);
    }

    return ret;
}
  10750e:	b003      	add	sp, #12
  107510:	bd30      	pop	{r4, r5, r15}
        return ret;
  107512:	4620      	mov	r0, r4
}
  107514:	b003      	add	sp, #12
  107516:	bd30      	pop	{r4, r5, r15}

00107518 <hal_rstgen_module_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_module_reset(void *handle, uint32_t res_glb_idx)
{
  107518:	b530      	push	{r4, r5, r14}
  10751a:	4604      	mov	r4, r0
  10751c:	b083      	sub	sp, #12
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    bool        ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
  10751e:	4608      	mov	r0, r1
  107520:	aa01      	add	r2, sp, #4
  107522:	4669      	mov	r1, r13
  107524:	f7ff ff3a 	bl	10739c <res_get_info_by_id>
  107528:	b988      	cbnz	r0, 10754e <hal_rstgen_module_reset+0x36>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_ctl) {
  10752a:	9901      	ldr	r1, [sp, #4]
  10752c:	2900      	cmp	r1, #0
  10752e:	dd0c      	ble.n	10754a <hal_rstgen_module_reset+0x32>
  107530:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  107532:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  107534:	b173      	cbz	r3, 107554 <hal_rstgen_module_reset+0x3c>
    base = (vaddr_t)_ioaddr(phy_addr);
  107536:	9d00      	ldr	r5, [sp, #0]
        ret = instance->controllerTable->module_ctl(
  107538:	4602      	mov	r2, r0
  10753a:	4628      	mov	r0, r5
  10753c:	4798      	blx	r3
                  base, (uint32_t)module_idx, false);
        ret = instance->controllerTable->module_ctl(
  10753e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  107540:	4628      	mov	r0, r5
  107542:	2201      	movs	r2, #1
  107544:	9901      	ldr	r1, [sp, #4]
  107546:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  107548:	4798      	blx	r3
                  base, (uint32_t)module_idx, true);
    }

    return ret;
}
  10754a:	b003      	add	sp, #12
  10754c:	bd30      	pop	{r4, r5, r15}
        return ret;
  10754e:	2000      	movs	r0, #0
}
  107550:	b003      	add	sp, #12
  107552:	bd30      	pop	{r4, r5, r15}
        return ret;
  107554:	4618      	mov	r0, r3
  107556:	e7f8      	b.n	10754a <hal_rstgen_module_reset+0x32>

00107558 <hal_scr_create_handle>:

    return (scr_handle_t)0;
    #else
    return (scr_handle_t)scr_signal;
    #endif
}
  107558:	4770      	bx	r14
  10755a:	bf00      	nop

0010755c <hal_scr_delete_handle>:

void hal_scr_delete_handle(scr_handle_t handle)
{
    ASSERT(handle);
  10755c:	ea50 0301 	orrs.w	r3, r0, r1
  107560:	d000      	beq.n	107564 <hal_scr_delete_handle+0x8>
  107562:	4770      	bx	r14
  107564:	f64b 6398 	movw	r3, #48792	; 0xbe98
  107568:	f641 2214 	movw	r2, #6676	; 0x1a14
{
  10756c:	b500      	push	{r14}
    ASSERT(handle);
  10756e:	f2c0 0310 	movt	r3, #16
  107572:	f64b 615c 	movw	r1, #48732	; 0xbe5c
{
  107576:	b083      	sub	sp, #12
  107578:	4670      	mov	r0, r14
    ASSERT(handle);
  10757a:	f2c0 0211 	movt	r2, #17
  10757e:	9300      	str	r3, [sp, #0]
  107580:	f2c0 0110 	movt	r1, #16
  107584:	2357      	movs	r3, #87	; 0x57
  107586:	f002 fe75 	bl	10a274 <_panic>
  10758a:	bf00      	nop

0010758c <hal_scr_get>:
}

uint32_t hal_scr_get(scr_handle_t handle)
{
    ASSERT(handle);
  10758c:	ea50 0301 	orrs.w	r3, r0, r1
  107590:	d001      	beq.n	107596 <hal_scr_get+0xa>
    return scr_get((scr_signal_t)handle);
  107592:	f7fe b8df 	b.w	105754 <scr_get>
    ASSERT(handle);
  107596:	f64b 6398 	movw	r3, #48792	; 0xbe98
  10759a:	f641 2214 	movw	r2, #6676	; 0x1a14
{
  10759e:	b500      	push	{r14}
    ASSERT(handle);
  1075a0:	f2c0 0310 	movt	r3, #16
  1075a4:	f64b 615c 	movw	r1, #48732	; 0xbe5c
{
  1075a8:	b083      	sub	sp, #12
  1075aa:	4670      	mov	r0, r14
    ASSERT(handle);
  1075ac:	f2c0 0211 	movt	r2, #17
  1075b0:	9300      	str	r3, [sp, #0]
  1075b2:	f2c0 0110 	movt	r1, #16
  1075b6:	235c      	movs	r3, #92	; 0x5c
  1075b8:	f002 fe5c 	bl	10a274 <_panic>

001075bc <hal_scr_set>:
}

bool hal_scr_set(scr_handle_t handle, uint32_t value)
{
    ASSERT(handle);
  1075bc:	ea50 0301 	orrs.w	r3, r0, r1
  1075c0:	d001      	beq.n	1075c6 <hal_scr_set+0xa>
    return scr_set((scr_signal_t)handle, value);
  1075c2:	f7fe b95d 	b.w	105880 <scr_set>
    ASSERT(handle);
  1075c6:	f64b 6398 	movw	r3, #48792	; 0xbe98
  1075ca:	f641 2214 	movw	r2, #6676	; 0x1a14
{
  1075ce:	b500      	push	{r14}
    ASSERT(handle);
  1075d0:	f2c0 0310 	movt	r3, #16
  1075d4:	f64b 615c 	movw	r1, #48732	; 0xbe5c
{
  1075d8:	b083      	sub	sp, #12
  1075da:	4670      	mov	r0, r14
    ASSERT(handle);
  1075dc:	f2c0 0211 	movt	r2, #17
  1075e0:	9300      	str	r3, [sp, #0]
  1075e2:	f2c0 0110 	movt	r1, #16
  1075e6:	2362      	movs	r3, #98	; 0x62
  1075e8:	f002 fe44 	bl	10a274 <_panic>

001075ec <hal_timer_func_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_timer_func_irq_handle(void *arg)
{
    timer_instance_t *instance = (timer_instance_t *)arg;

    if (instance == NULL)
  1075ec:	b120      	cbz	r0, 1075f8 <hal_timer_func_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return timer_drv_func_irq_handle(instance->timer,
  1075ee:	f100 0118 	add.w	r1, r0, #24
  1075f2:	6940      	ldr	r0, [r0, #20]
  1075f4:	f7fe bc24 	b.w	105e40 <timer_drv_func_irq_handle>
                                     &(instance->drv_context));
}
  1075f8:	4770      	bx	r14
  1075fa:	bf00      	nop

001075fc <hal_timer_ovf_irq_handle>:
    if (instance == NULL)
  1075fc:	b120      	cbz	r0, 107608 <hal_timer_ovf_irq_handle+0xc>
    return timer_drv_ovf_irq_handle(instance->timer, &(instance->drv_context));
  1075fe:	f100 0118 	add.w	r1, r0, #24
  107602:	6940      	ldr	r0, [r0, #20]
  107604:	f7fe bbee 	b.w	105de4 <timer_drv_ovf_irq_handle>
}
  107608:	4770      	bx	r14
  10760a:	bf00      	nop

0010760c <hal_timer_creat_handle>:
{
  10760c:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  107610:	f247 55c8 	movw	r5, #30152	; 0x75c8
{
  107614:	b082      	sub	sp, #8
  107616:	4606      	mov	r6, r0
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  107618:	f2c0 0511 	movt	r5, #17
  10761c:	682b      	ldr	r3, [r5, #0]
  10761e:	b10b      	cbz	r3, 107624 <hal_timer_creat_handle+0x18>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  107620:	2300      	movs	r3, #0
  107622:	602b      	str	r3, [r5, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  107624:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107628:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  10762c:	d161      	bne.n	1076f2 <hal_timer_creat_handle+0xe6>
    __asm__ volatile("cpsid i");
  10762e:	b672      	cpsid	i
    *lock = 1;
  107630:	2701      	movs	r7, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  107632:	4608      	mov	r0, r1
  107634:	4669      	mov	r1, r13
  107636:	aa01      	add	r2, sp, #4
  107638:	602f      	str	r7, [r5, #0]
  10763a:	f7ff feaf 	bl	10739c <res_get_info_by_id>
  10763e:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  107640:	bfa8      	it	ge
  107642:	46be      	movge	r14, r7
  107644:	db67      	blt.n	107716 <hal_timer_creat_handle+0x10a>
  107646:	f247 2c08 	movw	r12, #29192	; 0x7208
            if (!g_timer_instance[index].occupied
  10764a:	f04f 0800 	mov.w	r8, #0
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  10764e:	9c00      	ldr	r4, [sp, #0]
  107650:	f2c0 0c11 	movt	r12, #17
  107654:	4667      	mov	r7, r12
            if (!g_timer_instance[index].occupied
  107656:	f2cf 0818 	movt	r8, #61464	; 0xf018
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  10765a:	2000      	movs	r0, #0
            if (!g_timer_instance[index].occupied
  10765c:	783b      	ldrb	r3, [r7, #0]
  10765e:	bbbb      	cbnz	r3, 1076d0 <hal_timer_creat_handle+0xc4>
  107660:	4a30      	ldr	r2, [pc, #192]	; (107724 <hal_timer_creat_handle+0x118>)
  107662:	4641      	mov	r1, r8
        if (timer_addr2irq_table[i].addr == addr) {
  107664:	428c      	cmp	r4, r1
  107666:	f102 020c 	add.w	r2, r2, #12
  10766a:	d007      	beq.n	10767c <hal_timer_creat_handle+0x70>
    for (i = 0; i < DEFAULT_TIMER_MAX_NUM; i++) {
  10766c:	3301      	adds	r3, #1
  10766e:	2b08      	cmp	r3, #8
  107670:	d02e      	beq.n	1076d0 <hal_timer_creat_handle+0xc4>
  107672:	f852 1c0c 	ldr.w	r1, [r2, #-12]
  107676:	320c      	adds	r2, #12
        if (timer_addr2irq_table[i].addr == addr) {
  107678:	428c      	cmp	r4, r1
  10767a:	d1f7      	bne.n	10766c <hal_timer_creat_handle+0x60>
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  10767c:	f641 222c 	movw	r2, #6700	; 0x1a2c
  107680:	eb03 0343 	add.w	r3, r3, r3, lsl #1
                g_timer_instance[index].occupied = true;
  107684:	ea4f 1800 	mov.w	r8, r0, lsl #4
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  107688:	f2c0 0211 	movt	r2, #17
                g_timer_instance[index].occupied = true;
  10768c:	eba8 0700 	sub.w	r7, r8, r0
  107690:	f04f 0b01 	mov.w	r11, #1
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  107694:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *lock = 0;
  107698:	2200      	movs	r2, #0
                g_timer_instance[index].occupied = true;
  10769a:	00ff      	lsls	r7, r7, #3
  10769c:	eb0c 0907 	add.w	r9, r12, r7
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  1076a0:	6859      	ldr	r1, [r3, #4]
  1076a2:	f8c9 1004 	str.w	r1, [r9, #4]
            *fun_irq_num = timer_addr2irq_table[i].fun_irq_num;
  1076a6:	6899      	ldr	r1, [r3, #8]
                g_timer_instance[index].timer = (sdrv_timer_t *)(phy_addr);
  1076a8:	f8c9 4014 	str.w	r4, [r9, #20]
                g_timer_instance[index].fun_irq_num = fun_irq_num;
  1076ac:	f8c9 1008 	str.w	r1, [r9, #8]
                g_timer_instance[index].occupied = true;
  1076b0:	f80c b007 	strb.w	r11, [r12, r7]
  1076b4:	602a      	str	r2, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1076b6:	f1be 0f00 	cmp.w	r14, #0
  1076ba:	d000      	beq.n	1076be <hal_timer_creat_handle+0xb2>
    __asm__ volatile("cpsie i");
  1076bc:	b662      	cpsie	i
                *instance = &g_timer_instance[index];
  1076be:	eba8 0300 	sub.w	r3, r8, r0
    return true;
  1076c2:	2001      	movs	r0, #1
                *instance = &g_timer_instance[index];
  1076c4:	eb0c 03c3 	add.w	r3, r12, r3, lsl #3
    *handle = instance;
  1076c8:	6033      	str	r3, [r6, #0]
}
  1076ca:	b002      	add	sp, #8
  1076cc:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
        for (index = 0; index < DEFAULT_TIMER_MAX_NUM; index++) {
  1076d0:	3001      	adds	r0, #1
  1076d2:	2808      	cmp	r0, #8
  1076d4:	f107 0778 	add.w	r7, r7, #120	; 0x78
  1076d8:	d1c0      	bne.n	10765c <hal_timer_creat_handle+0x50>
    *lock = 0;
  1076da:	2300      	movs	r3, #0
  1076dc:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1076de:	f1be 0f00 	cmp.w	r14, #0
  1076e2:	d000      	beq.n	1076e6 <hal_timer_creat_handle+0xda>
  1076e4:	b662      	cpsie	i
        *handle = NULL;
  1076e6:	2300      	movs	r3, #0
        return false;
  1076e8:	4618      	mov	r0, r3
        *handle = NULL;
  1076ea:	6033      	str	r3, [r6, #0]
}
  1076ec:	b002      	add	sp, #8
  1076ee:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
    *lock = 1;
  1076f2:	2301      	movs	r3, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  1076f4:	4608      	mov	r0, r1
  1076f6:	4669      	mov	r1, r13
  1076f8:	aa01      	add	r2, sp, #4
  1076fa:	602b      	str	r3, [r5, #0]
  1076fc:	f7ff fe4e 	bl	10739c <res_get_info_by_id>
  107700:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  107702:	bfa8      	it	ge
  107704:	f04f 0e00 	movge.w	r14, #0
  107708:	da9d      	bge.n	107646 <hal_timer_creat_handle+0x3a>
    *lock = 0;
  10770a:	2300      	movs	r3, #0
  10770c:	602b      	str	r3, [r5, #0]
        *handle = NULL;
  10770e:	2300      	movs	r3, #0
        return false;
  107710:	4618      	mov	r0, r3
        *handle = NULL;
  107712:	6033      	str	r3, [r6, #0]
  107714:	e7ea      	b.n	1076ec <hal_timer_creat_handle+0xe0>
  107716:	602c      	str	r4, [r5, #0]
  107718:	b662      	cpsie	i
  10771a:	2300      	movs	r3, #0
        return false;
  10771c:	4618      	mov	r0, r3
        *handle = NULL;
  10771e:	6033      	str	r3, [r6, #0]
  107720:	e7e4      	b.n	1076ec <hal_timer_creat_handle+0xe0>
  107722:	bf00      	nop
  107724:	00111a38 	.word	0x00111a38

00107728 <hal_timer_global_init>:
{
  107728:	b570      	push	{r4, r5, r6, r14}
  10772a:	460c      	mov	r4, r1
  10772c:	4605      	mov	r5, r0
    sdrv_timer_t *timer = instance->timer;
  10772e:	6946      	ldr	r6, [r0, #20]
    timer_drv_clk_init(timer, cfg->clk_sel, cfg->clk_div);
  107730:	688a      	ldr	r2, [r1, #8]
  107732:	4630      	mov	r0, r6
  107734:	6809      	ldr	r1, [r1, #0]
  107736:	f7fe fb39 	bl	105dac <timer_drv_clk_init>
    timer_drv_cascade_set(timer, cfg->cascade);
  10773a:	4630      	mov	r0, r6
  10773c:	7b21      	ldrb	r1, [r4, #12]
  10773e:	f7fe fb2b 	bl	105d98 <timer_drv_cascade_set>
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  107742:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  107746:	f644 51d3 	movw	r1, #19923	; 0x4dd3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  10774a:	f64d 6083 	movw	r0, #56963	; 0xde83
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  10774e:	3301      	adds	r3, #1
  107750:	f2c1 0162 	movt	r1, #4194	; 0x1062
  107754:	fbb2 f3f3 	udiv	r3, r2, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  107758:	f2c4 301b 	movt	r0, #17179	; 0x431b
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  10775c:	fba1 2103 	umull	r2, r1, r1, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  107760:	fba0 2303 	umull	r2, r3, r0, r3
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  107764:	0989      	lsrs	r1, r1, #6
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  107766:	0c9b      	lsrs	r3, r3, #18
  107768:	e9c5 1303 	strd	r1, r3, [r5, #12]
}
  10776c:	bd70      	pop	{r4, r5, r6, r15}
  10776e:	bf00      	nop

00107770 <hal_timer_ovf_init>:
{
  107770:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  107772:	4615      	mov	r5, r2
  107774:	460e      	mov	r6, r1
    sdrv_timer_t *timer = instance->timer;
  107776:	6947      	ldr	r7, [r0, #20]
{
  107778:	4604      	mov	r4, r0
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  10777a:	6892      	ldr	r2, [r2, #8]
  10777c:	4638      	mov	r0, r7
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  10777e:	4434      	add	r4, r6
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  107780:	f7fe faf2 	bl	105d68 <timer_drv_ovf_set>
    timer_drv_cntr_set(timer, (timer_drv_sub_t)sub_cntr, cfg->cnt_val);
  107784:	4638      	mov	r0, r7
  107786:	4631      	mov	r1, r6
  107788:	686a      	ldr	r2, [r5, #4]
  10778a:	f7fe faad 	bl	105ce8 <timer_drv_cntr_set>
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  10778e:	782b      	ldrb	r3, [r5, #0]
  107790:	7623      	strb	r3, [r4, #24]
}
  107792:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00107794 <hal_timer_int_src_enable>:
    if (handle == NULL)
  107794:	b158      	cbz	r0, 1077ae <hal_timer_int_src_enable+0x1a>
{
  107796:	b538      	push	{r3, r4, r5, r14}
  107798:	4604      	mov	r4, r0
  10779a:	460d      	mov	r5, r1
    timer_drv_int_sta_enable(instance->timer, int_src);
  10779c:	6940      	ldr	r0, [r0, #20]
  10779e:	f7fe fb11 	bl	105dc4 <timer_drv_int_sta_enable>
    timer_drv_int_sig_enable(instance->timer, int_src);
  1077a2:	4629      	mov	r1, r5
  1077a4:	6960      	ldr	r0, [r4, #20]
}
  1077a6:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_enable(instance->timer, int_src);
  1077aa:	f7fe bb13 	b.w	105dd4 <timer_drv_int_sig_enable>
  1077ae:	4770      	bx	r14

001077b0 <hal_timer_int_cbk_register>:

void hal_timer_int_cbk_register(void *handle, hal_timer_int_src_t int_src,
                                hal_timer_int_cbk cbk)
{
    if (handle == NULL)
  1077b0:	2800      	cmp	r0, #0
  1077b2:	d047      	beq.n	107844 <hal_timer_int_cbk_register+0x94>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;

    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
            && (int_src <= HAL_TIMER_CNT_G1_OVF_INT_SRC)) {
  1077b4:	f1a1 0308 	sub.w	r3, r1, #8
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  1077b8:	2b01      	cmp	r3, #1
{
  1077ba:	b510      	push	{r4, r14}
  1077bc:	4604      	mov	r4, r0
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  1077be:	d917      	bls.n	1077f0 <hal_timer_int_cbk_register+0x40>
                                 handle);
            unmask_interrupt(instance->ovf_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
             && (int_src <= HAL_TIMER_CNT_LD_OVF_INT_SRC)) {
  1077c0:	f1a1 030a 	sub.w	r3, r1, #10
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
  1077c4:	2b03      	cmp	r3, #3
  1077c6:	d90d      	bls.n	1077e4 <hal_timer_int_cbk_register+0x34>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CPT_A_INT_SRC)
  1077c8:	2903      	cmp	r1, #3
  1077ca:	d934      	bls.n	107836 <hal_timer_int_cbk_register+0x86>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
             && (int_src <= HAL_TIMER_CMP_D_INT_SRC)) {
  1077cc:	1f0b      	subs	r3, r1, #4
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
  1077ce:	2b03      	cmp	r3, #3
  1077d0:	d91f      	bls.n	107812 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_UNDERRUN_INT_SRC)) {
  1077d2:	f1a1 0310 	sub.w	r3, r1, #16
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
  1077d6:	2b03      	cmp	r3, #3
  1077d8:	d91b      	bls.n	107812 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_OVERRUN_INT_SRC)) {
  1077da:	f1a1 0314 	sub.w	r3, r1, #20
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
  1077de:	2b03      	cmp	r3, #3
  1077e0:	d805      	bhi.n	1077ee <hal_timer_int_cbk_register+0x3e>
        instance->drv_context.local_overrun_cbk[int_src -
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  1077e2:	3102      	adds	r1, #2

        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1077e4:	68a0      	ldr	r0, [r4, #8]
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  1077e6:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1077ea:	1c43      	adds	r3, r0, #1
  1077ec:	d117      	bne.n	10781e <hal_timer_int_cbk_register+0x6e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
}
  1077ee:	bd10      	pop	{r4, r15}
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1077f0:	6840      	ldr	r0, [r0, #4]
                                                     HAL_TIMER_CNT_G0_OVF_INT_SRC] = cbk;
  1077f2:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  1077f6:	1c43      	adds	r3, r0, #1
  1077f8:	d0f9      	beq.n	1077ee <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->ovf_irq_num, hal_timer_ovf_irq_handle,
  1077fa:	f247 51fd 	movw	r1, #30205	; 0x75fd
  1077fe:	4622      	mov	r2, r4
  107800:	f2c0 0110 	movt	r1, #16
  107804:	f7f8 ffa0 	bl	100748 <register_int_handler>
            unmask_interrupt(instance->ovf_irq_num);
  107808:	6860      	ldr	r0, [r4, #4]
}
  10780a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->ovf_irq_num);
  10780e:	f7f8 bfd1 	b.w	1007b4 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  107812:	68a0      	ldr	r0, [r4, #8]
                        HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC] = cbk;
  107814:	310a      	adds	r1, #10
  107816:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  10781a:	1c42      	adds	r2, r0, #1
  10781c:	d0e7      	beq.n	1077ee <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
  10781e:	f247 51ed 	movw	r1, #30189	; 0x75ed
  107822:	4622      	mov	r2, r4
  107824:	f2c0 0110 	movt	r1, #16
  107828:	f7f8 ff8e 	bl	100748 <register_int_handler>
            unmask_interrupt(instance->fun_irq_num);
  10782c:	68a0      	ldr	r0, [r4, #8]
}
  10782e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->fun_irq_num);
  107832:	f7f8 bfbf 	b.w	1007b4 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  107836:	6880      	ldr	r0, [r0, #8]
        instance->drv_context.local_cpt_cbk[int_src - HAL_TIMER_CPT_A_INT_SRC] =
  107838:	3112      	adds	r1, #18
  10783a:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  10783e:	1c41      	adds	r1, r0, #1
  107840:	d1ed      	bne.n	10781e <hal_timer_int_cbk_register+0x6e>
}
  107842:	bd10      	pop	{r4, r15}
  107844:	4770      	bx	r14
  107846:	bf00      	nop

00107848 <hal_timer_glb_cntr_get>:
{
    uint32_t g0_val, g1_val, g0_new;
    spin_lock_saved_state_t state;
    timer_instance_t *instance = (timer_instance_t *)handle;

    if (handle == NULL)
  107848:	b318      	cbz	r0, 107892 <hal_timer_glb_cntr_get+0x4a>
{
  10784a:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10784c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107850:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  107852:	bf48      	it	mi
  107854:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  107856:	d519      	bpl.n	10788c <hal_timer_glb_cntr_get+0x44>
  107858:	4604      	mov	r4, r0
        return 0;

    arch_interrupt_save(&state, SPIN_LOCK_FLAG_INTERRUPTS);

    g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  10785a:	2100      	movs	r1, #0
  10785c:	6940      	ldr	r0, [r0, #20]
  10785e:	f7fe fa6b 	bl	105d38 <timer_drv_cntr_get>
  107862:	4605      	mov	r5, r0
  107864:	e000      	b.n	107868 <hal_timer_glb_cntr_get+0x20>
  107866:	4605      	mov	r5, r0
    do {
        g0_val = g0_new;
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  107868:	6960      	ldr	r0, [r4, #20]
  10786a:	2101      	movs	r1, #1
  10786c:	f7fe fa64 	bl	105d38 <timer_drv_cntr_get>
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  107870:	2100      	movs	r1, #0
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  107872:	4606      	mov	r6, r0
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  107874:	6960      	ldr	r0, [r4, #20]
  107876:	f7fe fa5f 	bl	105d38 <timer_drv_cntr_get>
    } while (g0_val > g0_new);
  10787a:	4285      	cmp	r5, r0
  10787c:	d8f3      	bhi.n	107866 <hal_timer_glb_cntr_get+0x1e>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10787e:	b107      	cbz	r7, 107882 <hal_timer_glb_cntr_get+0x3a>
    __asm__ volatile("cpsie i");
  107880:	b662      	cpsie	i

    arch_interrupt_restore(state, SPIN_LOCK_FLAG_INTERRUPTS);

    return ((uint64_t)g0_val | (((uint64_t)g1_val) << 32U));
  107882:	2300      	movs	r3, #0
  107884:	4631      	mov	r1, r6
  107886:	ea43 0005 	orr.w	r0, r3, r5
}
  10788a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
  10788c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10788e:	2701      	movs	r7, #1
  107890:	e7e2      	b.n	107858 <hal_timer_glb_cntr_get+0x10>
        return 0;
  107892:	2000      	movs	r0, #0
  107894:	2100      	movs	r1, #0
}
  107896:	4770      	bx	r14

00107898 <hal_uart_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_uart_irq_handle(void *arg)
{
    uart_instance_t *instance = (uart_instance_t *)arg;

    if (instance == NULL)
  107898:	b120      	cbz	r0, 1078a4 <hal_uart_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return uart_drv_irq_handle(instance->uartc, &(instance->drv_context));
  10789a:	f100 0110 	add.w	r1, r0, #16
  10789e:	68c0      	ldr	r0, [r0, #12]
  1078a0:	f7fe bd2a 	b.w	1062f8 <uart_drv_irq_handle>
}
  1078a4:	4770      	bx	r14
  1078a6:	bf00      	nop

001078a8 <hal_uart_creat_handle>:
{
  1078a8:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  1078ac:	4605      	mov	r5, r0
  1078ae:	b083      	sub	sp, #12
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1078b0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1078b4:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  1078b8:	d16a      	bne.n	107990 <hal_uart_creat_handle+0xe8>
    __asm__ volatile("cpsid i");
  1078ba:	b672      	cpsid	i
    *lock = 1;
  1078bc:	f647 170c 	movw	r7, #30988	; 0x790c
  1078c0:	2601      	movs	r6, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  1078c2:	4608      	mov	r0, r1
  1078c4:	f2c0 0711 	movt	r7, #17
  1078c8:	4669      	mov	r1, r13
  1078ca:	aa01      	add	r2, sp, #4
  1078cc:	603e      	str	r6, [r7, #0]
  1078ce:	f7ff fd65 	bl	10739c <res_get_info_by_id>
  1078d2:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1078d4:	bfa8      	it	ge
  1078d6:	46b0      	movge	r8, r6
  1078d8:	db6d      	blt.n	1079b6 <hal_uart_creat_handle+0x10e>
  1078da:	f247 5ecc 	movw	r14, #30156	; 0x75cc
            if (!g_uart_instance[index].occupied
  1078de:	f04f 0900 	mov.w	r9, #0
  1078e2:	f641 208c 	movw	r0, #6796	; 0x1a8c
  1078e6:	f2c0 0e11 	movt	r14, #17
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  1078ea:	9e00      	ldr	r6, [sp, #0]
  1078ec:	4674      	mov	r4, r14
            if (!g_uart_instance[index].occupied
  1078ee:	f2cf 090f 	movt	r9, #61455	; 0xf00f
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  1078f2:	f04f 0c00 	mov.w	r12, #0
  1078f6:	f2c0 0011 	movt	r0, #17
            if (!g_uart_instance[index].occupied
  1078fa:	7822      	ldrb	r2, [r4, #0]
  1078fc:	bbaa      	cbnz	r2, 10796a <hal_uart_creat_handle+0xc2>
  1078fe:	4649      	mov	r1, r9
  107900:	e004      	b.n	10790c <hal_uart_creat_handle+0x64>
  107902:	461a      	mov	r2, r3
    for (i = 0; i < DEFAULT_UART_MAX_NUM; i++) {
  107904:	2b10      	cmp	r3, #16
  107906:	d030      	beq.n	10796a <hal_uart_creat_handle+0xc2>
  107908:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
        if (uart_addr2irq_table[i].addr == addr) {
  10790c:	428e      	cmp	r6, r1
  10790e:	f102 0301 	add.w	r3, r2, #1
  107912:	d1f6      	bne.n	107902 <hal_uart_creat_handle+0x5a>
            *irq_num = uart_addr2irq_table[i].irq_num;
  107914:	f641 298c 	movw	r9, #6796	; 0x1a8c
                g_uart_instance[index].occupied = true;
  107918:	ea4f 004c 	mov.w	r0, r12, lsl #1
  10791c:	eb00 010c 	add.w	r1, r0, r12
  107920:	2401      	movs	r4, #1
            *irq_num = uart_addr2irq_table[i].irq_num;
  107922:	f2c0 0911 	movt	r9, #17
                g_uart_instance[index].occupied = true;
  107926:	eb0c 0181 	add.w	r1, r12, r1, lsl #2
            *phy_num = i + 1;
  10792a:	9301      	str	r3, [sp, #4]
            *irq_num = uart_addr2irq_table[i].irq_num;
  10792c:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
                g_uart_instance[index].occupied = true;
  107930:	0089      	lsls	r1, r1, #2
  107932:	eb0e 0901 	add.w	r9, r14, r1
            *irq_num = uart_addr2irq_table[i].irq_num;
  107936:	6852      	ldr	r2, [r2, #4]
  107938:	f8c9 2008 	str.w	r2, [r9, #8]
    *lock = 0;
  10793c:	2200      	movs	r2, #0
                g_uart_instance[index].occupied = true;
  10793e:	f80e 4001 	strb.w	r4, [r14, r1]
                g_uart_instance[index].uartc = (DW_APB_UART_uart_TypeDef *)(phy_addr);
  107942:	f8c9 600c 	str.w	r6, [r9, #12]
                g_uart_instance[index].phy_num = phy_num;
  107946:	f8c9 3004 	str.w	r3, [r9, #4]
  10794a:	603a      	str	r2, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10794c:	f1b8 0f00 	cmp.w	r8, #0
  107950:	d000      	beq.n	107954 <hal_uart_creat_handle+0xac>
    __asm__ volatile("cpsie i");
  107952:	b662      	cpsie	i
                *instance = &g_uart_instance[index];
  107954:	eb00 030c 	add.w	r3, r0, r12
    return true;
  107958:	2001      	movs	r0, #1
                *instance = &g_uart_instance[index];
  10795a:	eb0c 0383 	add.w	r3, r12, r3, lsl #2
  10795e:	eb0e 0383 	add.w	r3, r14, r3, lsl #2
    *handle = instance;
  107962:	602b      	str	r3, [r5, #0]
}
  107964:	b003      	add	sp, #12
  107966:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        for (index = 0; index < DEFAULT_UART_MAX_NUM; index++) {
  10796a:	f10c 0c01 	add.w	r12, r12, #1
  10796e:	f1bc 0f10 	cmp.w	r12, #16
  107972:	f104 0434 	add.w	r4, r4, #52	; 0x34
  107976:	d1c0      	bne.n	1078fa <hal_uart_creat_handle+0x52>
    *lock = 0;
  107978:	2300      	movs	r3, #0
  10797a:	603b      	str	r3, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10797c:	f1b8 0f00 	cmp.w	r8, #0
  107980:	d000      	beq.n	107984 <hal_uart_creat_handle+0xdc>
  107982:	b662      	cpsie	i
        *handle = NULL;
  107984:	2300      	movs	r3, #0
        return false;
  107986:	4618      	mov	r0, r3
        *handle = NULL;
  107988:	602b      	str	r3, [r5, #0]
}
  10798a:	b003      	add	sp, #12
  10798c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    *lock = 1;
  107990:	f647 170c 	movw	r7, #30988	; 0x790c
  107994:	2301      	movs	r3, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  107996:	4608      	mov	r0, r1
  107998:	f2c0 0711 	movt	r7, #17
  10799c:	4669      	mov	r1, r13
  10799e:	aa01      	add	r2, sp, #4
  1079a0:	603b      	str	r3, [r7, #0]
  1079a2:	f7ff fcfb 	bl	10739c <res_get_info_by_id>
  1079a6:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  1079a8:	bfa8      	it	ge
  1079aa:	f04f 0800 	movge.w	r8, #0
  1079ae:	da94      	bge.n	1078da <hal_uart_creat_handle+0x32>
    *lock = 0;
  1079b0:	2300      	movs	r3, #0
  1079b2:	603b      	str	r3, [r7, #0]
  1079b4:	e7e6      	b.n	107984 <hal_uart_creat_handle+0xdc>
  1079b6:	603c      	str	r4, [r7, #0]
  1079b8:	b662      	cpsie	i
  1079ba:	e7e3      	b.n	107984 <hal_uart_creat_handle+0xdc>

001079bc <hal_uart_init>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   cfg         pointer of the hal confuration
 *****************************************************************************/
void hal_uart_init(void *handle, hal_uart_cfg_t *cfg)
{
    if (handle == NULL)
  1079bc:	b1f0      	cbz	r0, 1079fc <hal_uart_init+0x40>
{
  1079be:	b530      	push	{r4, r5, r14}
  1079c0:	b08b      	sub	sp, #44	; 0x2c
    if ((hal_cfg == NULL) || (drv_cfg == NULL))
  1079c2:	b199      	cbz	r1, 1079ec <hal_uart_init+0x30>
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  1079c4:	680d      	ldr	r5, [r1, #0]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  1079c6:	7d0a      	ldrb	r2, [r1, #20]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  1079c8:	684c      	ldr	r4, [r1, #4]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  1079ca:	7e0b      	ldrb	r3, [r1, #24]
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  1079cc:	9501      	str	r5, [sp, #4]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  1079ce:	9402      	str	r4, [sp, #8]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  1079d0:	688d      	ldr	r5, [r1, #8]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  1079d2:	68cc      	ldr	r4, [r1, #12]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  1079d4:	9503      	str	r5, [sp, #12]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  1079d6:	9404      	str	r4, [sp, #16]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  1079d8:	690d      	ldr	r5, [r1, #16]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  1079da:	e9d1 4107 	ldrd	r4, r1, [r1, #28]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  1079de:	9505      	str	r5, [sp, #20]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  1079e0:	e9cd 4108 	strd	r4, r1, [r13, #32]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  1079e4:	f88d 2018 	strb.w	r2, [r13, #24]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  1079e8:	f88d 301c 	strb.w	r3, [r13, #28]
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_cfg_t drv_cfg;
    hal_uart_cfg_copy_to_drv(cfg, &drv_cfg);
    uart_drv_init(instance->uartc, &(instance->drv_context), &drv_cfg);
  1079ec:	f100 0110 	add.w	r1, r0, #16
  1079f0:	68c0      	ldr	r0, [r0, #12]
  1079f2:	aa01      	add	r2, sp, #4
  1079f4:	f7fe fb34 	bl	106060 <uart_drv_init>
}
  1079f8:	b00b      	add	sp, #44	; 0x2c
  1079fa:	bd30      	pop	{r4, r5, r15}
  1079fc:	4770      	bx	r14
  1079fe:	bf00      	nop

00107a00 <hal_uart_putc>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   data        Character to put
 *****************************************************************************/
void hal_uart_putc(void *handle, char data)
{
    if (handle == NULL)
  107a00:	b128      	cbz	r0, 107a0e <hal_uart_putc+0xe>
        uart_drv_rs485_driver_set(instance->uartc, true);
        uart_drv_rs485_receiver_set(instance->uartc, false);
    }

#endif
    uart_drv_putc(instance->uartc, &(instance->drv_context), data);
  107a02:	460a      	mov	r2, r1
  107a04:	f100 0110 	add.w	r1, r0, #16
  107a08:	68c0      	ldr	r0, [r0, #12]
  107a0a:	f7fe bc37 	b.w	10627c <uart_drv_putc>
        uart_drv_rs485_driver_set(instance->uartc, false);
        uart_drv_rs485_receiver_set(instance->uartc, true);
    }

#endif
}
  107a0e:	4770      	bx	r14

00107a10 <hal_uart_int_cbk_register>:
 ** \param [in]   cbk
 *****************************************************************************/
void hal_uart_int_cbk_register(void *handle, hal_uart_int_src_t int_src,
                               hal_uart_int_callback cbk)
{
    if (handle == NULL)
  107a10:	b1a0      	cbz	r0, 107a3c <hal_uart_int_cbk_register+0x2c>
{
  107a12:	b510      	push	{r4, r14}
  107a14:	4604      	mov	r4, r0
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_int_cbk_register(&(instance->drv_context), int_src, cbk);
  107a16:	3010      	adds	r0, #16
  107a18:	f7fe fc3e 	bl	106298 <uart_drv_int_cbk_register>

    if (instance->irq_num != UART_HAL_INVALID_IRQ_NUM) {
  107a1c:	68a0      	ldr	r0, [r4, #8]
  107a1e:	1c43      	adds	r3, r0, #1
  107a20:	d00b      	beq.n	107a3a <hal_uart_int_cbk_register+0x2a>
        register_int_handler(instance->irq_num, hal_uart_irq_handle, handle);
  107a22:	f647 0199 	movw	r1, #30873	; 0x7899
  107a26:	4622      	mov	r2, r4
  107a28:	f2c0 0110 	movt	r1, #16
  107a2c:	f7f8 fe8c 	bl	100748 <register_int_handler>
        unmask_interrupt(instance->irq_num);
  107a30:	68a0      	ldr	r0, [r4, #8]
    }
}
  107a32:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        unmask_interrupt(instance->irq_num);
  107a36:	f7f8 bebd 	b.w	1007b4 <unmask_interrupt>
}
  107a3a:	bd10      	pop	{r4, r15}
  107a3c:	4770      	bx	r14
  107a3e:	bf00      	nop

00107a40 <hal_uart_int_src_enable>:
    unmask_interrupt(instance->irq_num);
}

void hal_uart_int_src_enable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  107a40:	b108      	cbz	r0, 107a46 <hal_uart_int_src_enable+0x6>
        return;

    uart_drv_int_src_enable(handle, int_src);
  107a42:	f7fe bc35 	b.w	1062b0 <uart_drv_int_src_enable>
}
  107a46:	4770      	bx	r14

00107a48 <hal_uart_int_src_disable>:

void hal_uart_int_src_disable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  107a48:	b108      	cbz	r0, 107a4e <hal_uart_int_src_disable+0x6>
        return;

    uart_drv_int_src_disable(handle, int_src);
  107a4a:	f7fe bc41 	b.w	1062d0 <uart_drv_int_src_disable>
}
  107a4e:	4770      	bx	r14

00107a50 <FreeRTOS_SWI_Handler>:
 *****************************************************************************/
.align 4
.type FreeRTOS_SWI_Handler, %function
FreeRTOS_SWI_Handler:
	/* Save the context of the current task and select a new task to run. */
	portSAVE_CONTEXT
  107a50:	f96d051f 	srsdb	r13!, #31
  107a54:	f102001f 	cps	#31
  107a58:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  107a5c:	e59f2258 	ldr	r2, [pc, #600]	; 107cbc <ulCriticalNestingConst>
  107a60:	e5921000 	ldr	r1, [r2]
  107a64:	e52d1004 	push	{r1}		; (str r1, [r13, #-4]!)
  107a68:	e59f2250 	ldr	r2, [pc, #592]	; 107cc0 <ulPortTaskHasFPUContextConst>
  107a6c:	e5923000 	ldr	r3, [r2]
  107a70:	e3530000 	cmp	r3, #0
  107a74:	1ef11a10 	vmrsne	r1, fpscr
  107a78:	1d2d0b20 	vpushne	{d0-d15}
  107a7c:	152d1004 	pushne	{r1}		; (strne r1, [r13, #-4]!)
  107a80:	e52d3004 	push	{r3}		; (str r3, [r13, #-4]!)
  107a84:	e59f022c 	ldr	r0, [pc, #556]	; 107cb8 <pxCurrentTCBConst>
  107a88:	e5901000 	ldr	r1, [r0]
  107a8c:	e581d000 	str	r13, [r1]
	LDR R0, vTaskSwitchContextConst
  107a90:	e59f0230 	ldr	r0, [pc, #560]	; 107cc8 <vTaskSwitchContextConst>
	BLX	R0
  107a94:	e12fff30 	blx	r0
	portRESTORE_CONTEXT
  107a98:	e59f0218 	ldr	r0, [pc, #536]	; 107cb8 <pxCurrentTCBConst>
  107a9c:	e5901000 	ldr	r1, [r0]
  107aa0:	e591d000 	ldr	r13, [r1]
  107aa4:	e59f0214 	ldr	r0, [pc, #532]	; 107cc0 <ulPortTaskHasFPUContextConst>
  107aa8:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107aac:	e5801000 	str	r1, [r0]
  107ab0:	e3510000 	cmp	r1, #0
  107ab4:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  107ab8:	1cbd0b20 	vpopne	{d0-d15}
  107abc:	1ee10a10 	vmsrne	fpscr, r0
  107ac0:	e59f01f4 	ldr	r0, [pc, #500]	; 107cbc <ulCriticalNestingConst>
  107ac4:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107ac8:	e5801000 	str	r1, [r0]
  107acc:	e59f21e0 	ldr	r2, [pc, #480]	; 107cb4 <ulICCPMRConst>
  107ad0:	e5922000 	ldr	r2, [r2]
  107ad4:	e3510000 	cmp	r1, #0
  107ad8:	03a040ff 	moveq	r4, #255	; 0xff
  107adc:	159f41e0 	ldrne	r4, [pc, #480]	; 107cc4 <ulMaxAPIPriorityMaskConst>
  107ae0:	15944000 	ldrne	r4, [r4]
  107ae4:	e5824000 	str	r4, [r2]
  107ae8:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  107aec:	f8bd0a00 	rfeia	r13!

00107af0 <vPortRestoreTaskContext>:
 * vPortRestoreTaskContext is used to start the scheduler.
 *****************************************************************************/
.type vPortRestoreTaskContext, %function
vPortRestoreTaskContext:
	/* Switch to system mode. */
	CPS		#SYS_MODE
  107af0:	f102001f 	cps	#31
	portRESTORE_CONTEXT
  107af4:	e59f01bc 	ldr	r0, [pc, #444]	; 107cb8 <pxCurrentTCBConst>
  107af8:	e5901000 	ldr	r1, [r0]
  107afc:	e591d000 	ldr	r13, [r1]
  107b00:	e59f01b8 	ldr	r0, [pc, #440]	; 107cc0 <ulPortTaskHasFPUContextConst>
  107b04:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107b08:	e5801000 	str	r1, [r0]
  107b0c:	e3510000 	cmp	r1, #0
  107b10:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  107b14:	1cbd0b20 	vpopne	{d0-d15}
  107b18:	1ee10a10 	vmsrne	fpscr, r0
  107b1c:	e59f0198 	ldr	r0, [pc, #408]	; 107cbc <ulCriticalNestingConst>
  107b20:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107b24:	e5801000 	str	r1, [r0]
  107b28:	e59f2184 	ldr	r2, [pc, #388]	; 107cb4 <ulICCPMRConst>
  107b2c:	e5922000 	ldr	r2, [r2]
  107b30:	e3510000 	cmp	r1, #0
  107b34:	03a040ff 	moveq	r4, #255	; 0xff
  107b38:	159f4184 	ldrne	r4, [pc, #388]	; 107cc4 <ulMaxAPIPriorityMaskConst>
  107b3c:	15944000 	ldrne	r4, [r4]
  107b40:	e5824000 	str	r4, [r2]
  107b44:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  107b48:	f8bd0a00 	rfeia	r13!
  107b4c:	e320f000 	nop	{0}

00107b50 <FreeRTOS_IRQ_Handler>:
.align 4
.type FreeRTOS_IRQ_Handler, %function
FreeRTOS_IRQ_Handler:

	/* Return to the interrupted instruction. */
	SUB		lr, lr, #4
  107b50:	e24ee004 	sub	r14, r14, #4

	/* Push the return address and SPSR. */
	PUSH	{lr}
  107b54:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
	MRS		lr, SPSR
  107b58:	e14fe000 	mrs	r14, SPSR
	PUSH	{lr}
  107b5c:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)

	/* Change to supervisor mode to allow reentry. */
	CPS		#SVC_MODE
  107b60:	f1020013 	cps	#19

	/* Push used registers. */
	PUSH	{r0-r4, r12}
  107b64:	e92d101f 	push	{r0, r1, r2, r3, r4, r12}

	/* Increment nesting count.  r3 holds the address of ulPortInterruptNesting
	for future use.  r1 holds the original ulPortInterruptNesting value for
	future use. */
	LDR		r3, ulPortInterruptNestingConst
  107b68:	e59f3160 	ldr	r3, [pc, #352]	; 107cd0 <ulPortInterruptNestingConst>
	LDR		r1, [r3]
  107b6c:	e5931000 	ldr	r1, [r3]
	ADD		r4, r1, #1
  107b70:	e2814001 	add	r4, r1, #1
	STR		r4, [r3]
  107b74:	e5834000 	str	r4, [r3]

	/* Read value from the interrupt acknowledge register, which is stored in r0
	for future parameter and interrupt clearing use. */
	LDR 	r2, ulICCIARConst
  107b78:	e59f212c 	ldr	r2, [pc, #300]	; 107cac <ulICCIARConst>
	LDR		r2, [r2]
  107b7c:	e5922000 	ldr	r2, [r2]
	LDR		r0, [r2]
  107b80:	e5920000 	ldr	r0, [r2]

	/* Ensure bit 2 of the stack pointer is clear.  r2 holds the bit 2 value for
	future use.  _RB_ Is this ever needed provided the start of the stack is
	alligned on an 8-byte boundary? */
	MOV		r2, sp
  107b84:	e1a0200d 	mov	r2, r13
	AND		r2, r2, #4
  107b88:	e2022004 	and	r2, r2, #4
	SUB		sp, sp, r2
  107b8c:	e04dd002 	sub	r13, r13, r2

	/* Call the interrupt handler. */
	PUSH	{r0-r4, lr}
  107b90:	e92d401f 	push	{r0, r1, r2, r3, r4, r14}
	LDR		r1, vApplicationIRQHandlerConst
  107b94:	e59f1130 	ldr	r1, [pc, #304]	; 107ccc <vApplicationIRQHandlerConst>
	BLX		r1
  107b98:	e12fff31 	blx	r1
	POP		{r0-r4, lr}
  107b9c:	e8bd401f 	pop	{r0, r1, r2, r3, r4, r14}
	ADD		sp, sp, r2
  107ba0:	e08dd002 	add	r13, r13, r2

	CPSID	i
  107ba4:	f10c0080 	cpsid	i
	DSB
  107ba8:	f57ff04f 	dsb	sy
	ISB
  107bac:	f57ff06f 	isb	sy

	/* Write the value read from ICCIAR to ICCEOIR. */
	LDR 	r4, ulICCEOIRConst
  107bb0:	e59f40f8 	ldr	r4, [pc, #248]	; 107cb0 <ulICCEOIRConst>
	LDR		r4, [r4]
  107bb4:	e5944000 	ldr	r4, [r4]
	STR		r0, [r4]
  107bb8:	e5840000 	str	r0, [r4]

	/* Restore the old nesting count. */
	STR		r1, [r3]
  107bbc:	e5831000 	str	r1, [r3]

	/* A context switch is never performed if the nesting count is not 0. */
	CMP		r1, #0
  107bc0:	e3510000 	cmp	r1, #0
	BNE		exit_without_switch
  107bc4:	1a000003 	bne	107bd8 <exit_without_switch>

	/* Did the interrupt request a context switch?  r1 holds the address of
	ulPortYieldRequired and r0 the value of ulPortYieldRequired for future
	use. */
	LDR		r1, =ulPortYieldRequired
  107bc8:	e59f1104 	ldr	r1, [pc, #260]	; 107cd4 <ulPortInterruptNestingConst+0x4>
	LDR		r0, [r1]
  107bcc:	e5910000 	ldr	r0, [r1]
	CMP		r0, #0
  107bd0:	e3500000 	cmp	r0, #0
	BNE		switch_before_exit
  107bd4:	1a000005 	bne	107bf0 <switch_before_exit>

00107bd8 <exit_without_switch>:

exit_without_switch:
	/* No context switch.  Restore used registers, LR_irq and SPSR before
	returning. */
	POP		{r0-r4, r12}
  107bd8:	e8bd101f 	pop	{r0, r1, r2, r3, r4, r12}
	CPS		#IRQ_MODE
  107bdc:	f1020012 	cps	#18
	POP		{LR}
  107be0:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MSR		SPSR_cxsf, LR
  107be4:	e16ff00e 	msr	SPSR_fsxc, r14
	POP		{LR}
  107be8:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MOVS	PC, LR
  107bec:	e1b0f00e 	movs	r15, r14

00107bf0 <switch_before_exit>:

switch_before_exit:
	/* A context swtich is to be performed.  Clear the context switch pending
	flag. */
	MOV		r0, #0
  107bf0:	e3a00000 	mov	r0, #0
	STR		r0, [r1]
  107bf4:	e5810000 	str	r0, [r1]

	/* Restore used registers, LR-irq and SPSR before saving the context
	to the task stack. */
	POP		{r0-r4, r12}
  107bf8:	e8bd101f 	pop	{r0, r1, r2, r3, r4, r12}
	CPS		#IRQ_MODE
  107bfc:	f1020012 	cps	#18
	POP		{LR}
  107c00:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	MSR		SPSR_cxsf, LR
  107c04:	e16ff00e 	msr	SPSR_fsxc, r14
	POP		{LR}
  107c08:	e49de004 	pop	{r14}		; (ldr r14, [r13], #4)
	portSAVE_CONTEXT
  107c0c:	f96d051f 	srsdb	r13!, #31
  107c10:	f102001f 	cps	#31
  107c14:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  107c18:	e59f209c 	ldr	r2, [pc, #156]	; 107cbc <ulCriticalNestingConst>
  107c1c:	e5921000 	ldr	r1, [r2]
  107c20:	e52d1004 	push	{r1}		; (str r1, [r13, #-4]!)
  107c24:	e59f2094 	ldr	r2, [pc, #148]	; 107cc0 <ulPortTaskHasFPUContextConst>
  107c28:	e5923000 	ldr	r3, [r2]
  107c2c:	e3530000 	cmp	r3, #0
  107c30:	1ef11a10 	vmrsne	r1, fpscr
  107c34:	1d2d0b20 	vpushne	{d0-d15}
  107c38:	152d1004 	pushne	{r1}		; (strne r1, [r13, #-4]!)
  107c3c:	e52d3004 	push	{r3}		; (str r3, [r13, #-4]!)
  107c40:	e59f0070 	ldr	r0, [pc, #112]	; 107cb8 <pxCurrentTCBConst>
  107c44:	e5901000 	ldr	r1, [r0]
  107c48:	e581d000 	str	r13, [r1]

	/* Call the function that selects the new task to execute.
	vTaskSwitchContext() if vTaskSwitchContext() uses LDRD or STRD
	instructions, or 8 byte aligned stack allocated data.  LR does not need
	saving as a new LR will be loaded by portRESTORE_CONTEXT anyway. */
	LDR		R0, vTaskSwitchContextConst
  107c4c:	e59f0074 	ldr	r0, [pc, #116]	; 107cc8 <vTaskSwitchContextConst>
	BLX		R0
  107c50:	e12fff30 	blx	r0

	/* Restore the context of, and branch to, the task selected to execute
	next. */
	portRESTORE_CONTEXT
  107c54:	e59f005c 	ldr	r0, [pc, #92]	; 107cb8 <pxCurrentTCBConst>
  107c58:	e5901000 	ldr	r1, [r0]
  107c5c:	e591d000 	ldr	r13, [r1]
  107c60:	e59f0058 	ldr	r0, [pc, #88]	; 107cc0 <ulPortTaskHasFPUContextConst>
  107c64:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107c68:	e5801000 	str	r1, [r0]
  107c6c:	e3510000 	cmp	r1, #0
  107c70:	149d0004 	popne	{r0}		; (ldrne r0, [r13], #4)
  107c74:	1cbd0b20 	vpopne	{d0-d15}
  107c78:	1ee10a10 	vmsrne	fpscr, r0
  107c7c:	e59f0038 	ldr	r0, [pc, #56]	; 107cbc <ulCriticalNestingConst>
  107c80:	e49d1004 	pop	{r1}		; (ldr r1, [r13], #4)
  107c84:	e5801000 	str	r1, [r0]
  107c88:	e59f2024 	ldr	r2, [pc, #36]	; 107cb4 <ulICCPMRConst>
  107c8c:	e5922000 	ldr	r2, [r2]
  107c90:	e3510000 	cmp	r1, #0
  107c94:	03a040ff 	moveq	r4, #255	; 0xff
  107c98:	159f4024 	ldrne	r4, [pc, #36]	; 107cc4 <ulMaxAPIPriorityMaskConst>
  107c9c:	15944000 	ldrne	r4, [r4]
  107ca0:	e5824000 	str	r4, [r2]
  107ca4:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  107ca8:	f8bd0a00 	rfeia	r13!

00107cac <ulICCIARConst>:
  107cac:	00111b10 	.word	0x00111b10

00107cb0 <ulICCEOIRConst>:
  107cb0:	00111b0c 	.word	0x00111b0c

00107cb4 <ulICCPMRConst>:
  107cb4:	00111b14 	.word	0x00111b14

00107cb8 <pxCurrentTCBConst>:
  107cb8:	00119c3c 	.word	0x00119c3c

00107cbc <ulCriticalNestingConst>:
  107cbc:	001149b8 	.word	0x001149b8

00107cc0 <ulPortTaskHasFPUContextConst>:
  107cc0:	00117914 	.word	0x00117914

00107cc4 <ulMaxAPIPriorityMaskConst>:
  107cc4:	00111b18 	.word	0x00111b18

00107cc8 <vTaskSwitchContextConst>:
  107cc8:	00109a4d 	.word	0x00109a4d

00107ccc <vApplicationIRQHandlerConst>:
  107ccc:	0010084d 	.word	0x0010084d

00107cd0 <ulPortInterruptNestingConst>:
  107cd0:	00117910 	.word	0x00117910
	LDR		r1, =ulPortYieldRequired
  107cd4:	00117918 	.word	0x00117918

00107cd8 <FreeRTOS_Tick_Handler>:
	}
}
/*-----------------------------------------------------------*/

void FreeRTOS_Tick_Handler( void )
{
  107cd8:	b508      	push	{r3, r14}
	/* Set interrupt mask before altering scheduler structures.   The tick
	handler runs at the lowest priority, so interrupts cannot already be masked,
	so there is no need to save and restore the current mask value.  It is
	necessary to turn off interrupts in the CPU itself while the ICCPMR is being
	updated. */
	portCPU_IRQ_DISABLE();
  107cda:	b672      	cpsid	i
  107cdc:	f3bf 8f4f 	dsb	sy
  107ce0:	f3bf 8f6f 	isb	sy
	portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  107ce4:	f242 0304 	movw	r3, #8196	; 0x2004
  107ce8:	2290      	movs	r2, #144	; 0x90
  107cea:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107cee:	601a      	str	r2, [r3, #0]
	__asm volatile (	"dsb		\n"
  107cf0:	f3bf 8f4f 	dsb	sy
  107cf4:	f3bf 8f6f 	isb	sy
						"isb		\n" ::: "memory" );
	portCPU_IRQ_ENABLE();
  107cf8:	b662      	cpsie	i
  107cfa:	f3bf 8f4f 	dsb	sy
  107cfe:	f3bf 8f6f 	isb	sy

	/* Increment the RTOS tick. */
	if( xTaskIncrementTick() != pdFALSE )
  107d02:	f001 fd4d 	bl	1097a0 <xTaskIncrementTick>
  107d06:	b128      	cbz	r0, 107d14 <FreeRTOS_Tick_Handler+0x3c>
	{
		ulPortYieldRequired = pdTRUE;
  107d08:	f647 1318 	movw	r3, #31000	; 0x7918
  107d0c:	2201      	movs	r2, #1
  107d0e:	f2c0 0311 	movt	r3, #17
  107d12:	601a      	str	r2, [r3, #0]
	}

	/* Ensure all interrupt priorities are active again. */
	portCLEAR_INTERRUPT_MASK();
  107d14:	b672      	cpsid	i
  107d16:	f3bf 8f4f 	dsb	sy
  107d1a:	f3bf 8f6f 	isb	sy
  107d1e:	f242 0304 	movw	r3, #8196	; 0x2004
  107d22:	22ff      	movs	r2, #255	; 0xff
  107d24:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107d28:	601a      	str	r2, [r3, #0]
  107d2a:	f3bf 8f4f 	dsb	sy
  107d2e:	f3bf 8f6f 	isb	sy
  107d32:	b662      	cpsie	i
  107d34:	f3bf 8f4f 	dsb	sy
  107d38:	f3bf 8f6f 	isb	sy
	configCLEAR_TICK_INTERRUPT();
}
  107d3c:	bd08      	pop	{r3, r15}
  107d3e:	bf00      	nop

00107d40 <pxPortInitialiseStack>:
{
  107d40:	4603      	mov	r3, r0
	if( ( ( uint32_t ) pxCode & portTHUMB_MODE_ADDRESS ) != 0x00UL )
  107d42:	f011 0f01 	tst.w	r1, #1
{
  107d46:	b470      	push	{r4, r5, r6}
	*pxTopOfStack = ( StackType_t ) pxCode;
  107d48:	f840 1c10 	str.w	r1, [r0, #-16]
	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
  107d4c:	f04f 3412 	mov.w	r4, #303174162	; 0x12121212
		*pxTopOfStack |= portTHUMB_MODE_BIT;
  107d50:	bf14      	ite	ne
  107d52:	253f      	movne	r5, #63	; 0x3f
  107d54:	251f      	moveq	r5, #31
	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
  107d56:	f04f 3010 	mov.w	r0, #269488144	; 0x10101010
	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
  107d5a:	f04f 3106 	mov.w	r1, #101058054	; 0x6060606
	*pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
  107d5e:	f843 2c48 	str.w	r2, [r3, #-72]
	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
  107d62:	f04f 3209 	mov.w	r2, #151587081	; 0x9090909
  107d66:	f843 5c0c 	str.w	r5, [r3, #-12]
	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
  107d6a:	f04f 3508 	mov.w	r5, #134744072	; 0x8080808
	*pxTopOfStack = ( StackType_t ) 0x12121212;	/* R12 */
  107d6e:	f843 4c18 	str.w	r4, [r3, #-24]
	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
  107d72:	f04f 3407 	mov.w	r4, #117901063	; 0x7070707
	*pxTopOfStack = ( StackType_t ) 0x10101010;	/* R10 */
  107d76:	f843 0c20 	str.w	r0, [r3, #-32]
	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
  107d7a:	f04f 3005 	mov.w	r0, #84215045	; 0x5050505
	*pxTopOfStack = ( StackType_t ) 0x09090909;	/* R9 */
  107d7e:	f843 2c24 	str.w	r2, [r3, #-36]
	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
  107d82:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
	*pxTopOfStack = ( StackType_t ) 0x08080808;	/* R8 */
  107d86:	f843 5c28 	str.w	r5, [r3, #-40]
	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
  107d8a:	f04f 3611 	mov.w	r6, #286331153	; 0x11111111
	*pxTopOfStack = ( StackType_t ) 0x07070707;	/* R7 */
  107d8e:	f843 4c2c 	str.w	r4, [r3, #-44]
	*pxTopOfStack = ( StackType_t ) 0x03030303;	/* R3 */
  107d92:	f04f 3503 	mov.w	r5, #50529027	; 0x3030303
	*pxTopOfStack = ( StackType_t ) 0x06060606;	/* R6 */
  107d96:	f843 1c30 	str.w	r1, [r3, #-48]
	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
  107d9a:	f04f 3402 	mov.w	r4, #33686018	; 0x2020202
	*pxTopOfStack = ( StackType_t ) 0x05050505;	/* R5 */
  107d9e:	f843 0c34 	str.w	r0, [r3, #-52]
	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
  107da2:	f04f 3101 	mov.w	r1, #16843009	; 0x1010101
	*pxTopOfStack = ( StackType_t ) 0x04040404;	/* R4 */
  107da6:	f843 2c38 	str.w	r2, [r3, #-56]
	*pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
  107daa:	4618      	mov	r0, r3
	*pxTopOfStack = ( StackType_t ) 0x11111111;	/* R11 */
  107dac:	f843 6c1c 	str.w	r6, [r3, #-28]
	*pxTopOfStack = ( StackType_t ) NULL;
  107db0:	2200      	movs	r2, #0
	*pxTopOfStack = ( StackType_t ) 0x02020202;	/* R2 */
  107db2:	e943 4510 	strd	r4, r5, [r3, #-64]	; 0x40
	*pxTopOfStack = ( StackType_t ) 0x01010101;	/* R1 */
  107db6:	f843 1c44 	str.w	r1, [r3, #-68]
	*pxTopOfStack = ( StackType_t ) NULL;
  107dba:	e943 2201 	strd	r2, r2, [r3, #-4]
	*pxTopOfStack = ( StackType_t ) NULL;
  107dbe:	f843 2c08 	str.w	r2, [r3, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* R14 */
  107dc2:	f843 2c14 	str.w	r2, [r3, #-20]
	*pxTopOfStack = portNO_CRITICAL_NESTING;
  107dc6:	f843 2c4c 	str.w	r2, [r3, #-76]
}
  107dca:	bc70      	pop	{r4, r5, r6}
	*pxTopOfStack = portNO_FLOATING_POINT_CONTEXT;
  107dcc:	f840 2d50 	str.w	r2, [r0, #-80]!
}
  107dd0:	4770      	bx	r14
  107dd2:	bf00      	nop

00107dd4 <xPortStartScheduler>:
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  107dd4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  107dd8:	20ff      	movs	r0, #255	; 0xff
{
  107dda:	b500      	push	{r14}
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  107ddc:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107de0:	7819      	ldrb	r1, [r3, #0]
{
  107de2:	b083      	sub	sp, #12
		while( ( ucMaxPriorityValue & portBIT_0_SET ) != portBIT_0_SET )
  107de4:	2208      	movs	r2, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  107de6:	b2c9      	uxtb	r1, r1
  107de8:	9101      	str	r1, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  107dea:	7018      	strb	r0, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  107dec:	781b      	ldrb	r3, [r3, #0]
  107dee:	b2db      	uxtb	r3, r3
  107df0:	f88d 3003 	strb.w	r3, [r13, #3]
		while( ( ucMaxPriorityValue & portBIT_0_SET ) != portBIT_0_SET )
  107df4:	f89d 3003 	ldrb.w	r3, [r13, #3]
  107df8:	07db      	lsls	r3, r3, #31
  107dfa:	d407      	bmi.n	107e0c <xPortStartScheduler+0x38>
			ucMaxPriorityValue >>= ( uint8_t ) 0x01;
  107dfc:	f89d 3003 	ldrb.w	r3, [r13, #3]
			if( ulCycles == 0 )
  107e00:	3a01      	subs	r2, #1
			ucMaxPriorityValue >>= ( uint8_t ) 0x01;
  107e02:	ea4f 0353 	mov.w	r3, r3, lsr #1
  107e06:	f88d 3003 	strb.w	r3, [r13, #3]
			if( ulCycles == 0 )
  107e0a:	d1f3      	bne.n	107df4 <xPortStartScheduler+0x20>
		configASSERT( ucMaxPriorityValue == portLOWEST_INTERRUPT_PRIORITY );
  107e0c:	f89d 3003 	ldrb.w	r3, [r13, #3]
  107e10:	2b1f      	cmp	r3, #31
  107e12:	d00d      	beq.n	107e30 <xPortStartScheduler+0x5c>

}

void vMainAssertCalled(const char *pcFileName, uint32_t ulLineNumber)
{
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  107e14:	f641 3150 	movw	r1, #6992	; 0x1b50
  107e18:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  107e1c:	f44f 72a3 	mov.w	r2, #326	; 0x146
  107e20:	f2c0 0111 	movt	r1, #17
  107e24:	f2c0 0011 	movt	r0, #17
  107e28:	f003 fa58 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  107e2c:	b673      	cpsid	if
	__asm__ volatile("b .");
  107e2e:	e7fe      	b.n	107e2e <xPortStartScheduler+0x5a>
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  107e30:	9b01      	ldr	r3, [sp, #4]
  107e32:	f44f 52a0 	mov.w	r2, #5120	; 0x1400
  107e36:	f2cf 5240 	movt	r2, #62784	; 0xf540
  107e3a:	b2db      	uxtb	r3, r3
  107e3c:	7013      	strb	r3, [r2, #0]
	__asm volatile ( "MRS %0, APSR" : "=r" ( ulAPSR ) :: "memory" );
  107e3e:	f3ef 8300 	mrs	r3, CPSR
	ulAPSR &= portAPSR_MODE_BITS_MASK;
  107e42:	f003 031f 	and.w	r3, r3, #31
	configASSERT( ulAPSR != portAPSR_USER_MODE );
  107e46:	2b10      	cmp	r3, #16
  107e48:	d035      	beq.n	107eb6 <xPortStartScheduler+0xe2>
		configASSERT( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE );
  107e4a:	f242 0308 	movw	r3, #8200	; 0x2008
  107e4e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107e52:	681b      	ldr	r3, [r3, #0]
  107e54:	f003 0303 	and.w	r3, r3, #3
  107e58:	2b03      	cmp	r3, #3
  107e5a:	d01d      	beq.n	107e98 <xPortStartScheduler+0xc4>
		if( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE )
  107e5c:	f242 0308 	movw	r3, #8200	; 0x2008
  107e60:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107e64:	681b      	ldr	r3, [r3, #0]
  107e66:	f003 0303 	and.w	r3, r3, #3
  107e6a:	2b03      	cmp	r3, #3
  107e6c:	d103      	bne.n	107e76 <xPortStartScheduler+0xa2>
}
  107e6e:	2000      	movs	r0, #0
  107e70:	b003      	add	sp, #12
  107e72:	f85d fb04 	ldr.w	r15, [r13], #4
			portCPU_IRQ_DISABLE();
  107e76:	b672      	cpsid	i
  107e78:	f3bf 8f4f 	dsb	sy
  107e7c:	f3bf 8f6f 	isb	sy
	vPortTickTimerEnable(FreeRTOS_Tick_Handler);
  107e80:	f647 40d9 	movw	r0, #31961	; 0x7cd9
  107e84:	f2c0 0010 	movt	r0, #16
  107e88:	f7f8 fc3e 	bl	100708 <vPortTickTimerEnable>
			vPortRestoreTaskContext();
  107e8c:	f7ff ee30 	blx	107af0 <vPortRestoreTaskContext>
}
  107e90:	2000      	movs	r0, #0
  107e92:	b003      	add	sp, #12
  107e94:	f85d fb04 	ldr.w	r15, [r13], #4
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  107e98:	f641 3150 	movw	r1, #6992	; 0x1b50
  107e9c:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  107ea0:	f240 1259 	movw	r2, #345	; 0x159
  107ea4:	f2c0 0111 	movt	r1, #17
  107ea8:	f2c0 0011 	movt	r0, #17
  107eac:	f003 fa16 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  107eb0:	b673      	cpsid	if
	__asm__ volatile("b .");
  107eb2:	e7fe      	b.n	107eb2 <xPortStartScheduler+0xde>
  107eb4:	e7d2      	b.n	107e5c <xPortStartScheduler+0x88>
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  107eb6:	f641 3150 	movw	r1, #6992	; 0x1b50
  107eba:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  107ebe:	f44f 72a9 	mov.w	r2, #338	; 0x152
  107ec2:	f2c0 0111 	movt	r1, #17
  107ec6:	f2c0 0011 	movt	r0, #17
  107eca:	f003 fa07 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  107ece:	b673      	cpsid	if
	__asm__ volatile("b .");
  107ed0:	e7fe      	b.n	107ed0 <xPortStartScheduler+0xfc>
}
  107ed2:	2000      	movs	r0, #0
  107ed4:	b003      	add	sp, #12
  107ed6:	f85d fb04 	ldr.w	r15, [r13], #4
  107eda:	bf00      	nop

00107edc <vPortEnterCritical>:
{
  107edc:	b508      	push	{r3, r14}
	portCPU_IRQ_DISABLE();
  107ede:	b672      	cpsid	i
  107ee0:	f3bf 8f4f 	dsb	sy
  107ee4:	f3bf 8f6f 	isb	sy
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  107ee8:	f242 0304 	movw	r3, #8196	; 0x2004
  107eec:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107ef0:	681a      	ldr	r2, [r3, #0]
  107ef2:	2a90      	cmp	r2, #144	; 0x90
  107ef4:	d005      	beq.n	107f02 <vPortEnterCritical+0x26>
		portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  107ef6:	2290      	movs	r2, #144	; 0x90
  107ef8:	601a      	str	r2, [r3, #0]
		__asm volatile (	"dsb		\n"
  107efa:	f3bf 8f4f 	dsb	sy
  107efe:	f3bf 8f6f 	isb	sy
	portCPU_IRQ_ENABLE();
  107f02:	b662      	cpsie	i
  107f04:	f3bf 8f4f 	dsb	sy
  107f08:	f3bf 8f6f 	isb	sy
	ulCriticalNesting++;
  107f0c:	f644 13b8 	movw	r3, #18872	; 0x49b8
  107f10:	f2c0 0311 	movt	r3, #17
  107f14:	681a      	ldr	r2, [r3, #0]
  107f16:	3201      	adds	r2, #1
  107f18:	601a      	str	r2, [r3, #0]
	if( ulCriticalNesting == 1 )
  107f1a:	681b      	ldr	r3, [r3, #0]
  107f1c:	2b01      	cmp	r3, #1
  107f1e:	d000      	beq.n	107f22 <vPortEnterCritical+0x46>
}
  107f20:	bd08      	pop	{r3, r15}
		configASSERT( ulPortInterruptNesting == 0 );
  107f22:	f647 1310 	movw	r3, #30992	; 0x7910
  107f26:	f2c0 0311 	movt	r3, #17
  107f2a:	681b      	ldr	r3, [r3, #0]
  107f2c:	2b00      	cmp	r3, #0
  107f2e:	d0f7      	beq.n	107f20 <vPortEnterCritical+0x44>
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  107f30:	f641 3150 	movw	r1, #6992	; 0x1b50
  107f34:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  107f38:	f44f 72c7 	mov.w	r2, #398	; 0x18e
  107f3c:	f2c0 0111 	movt	r1, #17
  107f40:	f2c0 0011 	movt	r0, #17
  107f44:	f003 f9ca 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  107f48:	b673      	cpsid	if
	__asm__ volatile("b .");
  107f4a:	e7fe      	b.n	107f4a <vPortEnterCritical+0x6e>
}
  107f4c:	bd08      	pop	{r3, r15}
  107f4e:	bf00      	nop

00107f50 <vPortExitCritical>:
	if( ulCriticalNesting > portNO_CRITICAL_NESTING )
  107f50:	f644 13b8 	movw	r3, #18872	; 0x49b8
  107f54:	f2c0 0311 	movt	r3, #17
  107f58:	681a      	ldr	r2, [r3, #0]
  107f5a:	b1c2      	cbz	r2, 107f8e <vPortExitCritical+0x3e>
		ulCriticalNesting--;
  107f5c:	681a      	ldr	r2, [r3, #0]
  107f5e:	3a01      	subs	r2, #1
  107f60:	601a      	str	r2, [r3, #0]
		if( ulCriticalNesting == portNO_CRITICAL_NESTING )
  107f62:	681b      	ldr	r3, [r3, #0]
  107f64:	b99b      	cbnz	r3, 107f8e <vPortExitCritical+0x3e>
			portCLEAR_INTERRUPT_MASK();
  107f66:	b672      	cpsid	i
  107f68:	f3bf 8f4f 	dsb	sy
  107f6c:	f3bf 8f6f 	isb	sy
  107f70:	f242 0304 	movw	r3, #8196	; 0x2004
  107f74:	22ff      	movs	r2, #255	; 0xff
  107f76:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107f7a:	601a      	str	r2, [r3, #0]
  107f7c:	f3bf 8f4f 	dsb	sy
  107f80:	f3bf 8f6f 	isb	sy
  107f84:	b662      	cpsie	i
  107f86:	f3bf 8f4f 	dsb	sy
  107f8a:	f3bf 8f6f 	isb	sy
}
  107f8e:	4770      	bx	r14

00107f90 <vPortTaskUsesFPU>:
	ulPortTaskHasFPUContext = pdTRUE;
  107f90:	f647 1314 	movw	r3, #30996	; 0x7914
  107f94:	2101      	movs	r1, #1
	__asm volatile ( "FMXR 	FPSCR, %0" :: "r" (ulInitialFPSCR) : "memory" );
  107f96:	2200      	movs	r2, #0
	ulPortTaskHasFPUContext = pdTRUE;
  107f98:	f2c0 0311 	movt	r3, #17
  107f9c:	6019      	str	r1, [r3, #0]
	__asm volatile ( "FMXR 	FPSCR, %0" :: "r" (ulInitialFPSCR) : "memory" );
  107f9e:	eee1 2a10 	vmsr	fpscr, r2
}
  107fa2:	4770      	bx	r14

00107fa4 <vPortClearInterruptMask>:
	if( ulNewMaskValue == pdFALSE )
  107fa4:	b998      	cbnz	r0, 107fce <vPortClearInterruptMask+0x2a>
		portCLEAR_INTERRUPT_MASK();
  107fa6:	b672      	cpsid	i
  107fa8:	f3bf 8f4f 	dsb	sy
  107fac:	f3bf 8f6f 	isb	sy
  107fb0:	f242 0304 	movw	r3, #8196	; 0x2004
  107fb4:	22ff      	movs	r2, #255	; 0xff
  107fb6:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107fba:	601a      	str	r2, [r3, #0]
  107fbc:	f3bf 8f4f 	dsb	sy
  107fc0:	f3bf 8f6f 	isb	sy
  107fc4:	b662      	cpsie	i
  107fc6:	f3bf 8f4f 	dsb	sy
  107fca:	f3bf 8f6f 	isb	sy
}
  107fce:	4770      	bx	r14

00107fd0 <ulPortSetInterruptMask>:
	portCPU_IRQ_DISABLE();
  107fd0:	b672      	cpsid	i
  107fd2:	f3bf 8f4f 	dsb	sy
  107fd6:	f3bf 8f6f 	isb	sy
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  107fda:	f242 0304 	movw	r3, #8196	; 0x2004
  107fde:	f2cf 5340 	movt	r3, #62784	; 0xf540
  107fe2:	681a      	ldr	r2, [r3, #0]
  107fe4:	2a90      	cmp	r2, #144	; 0x90
		ulReturn = pdTRUE;
  107fe6:	bf08      	it	eq
  107fe8:	2001      	moveq	r0, #1
	if( portICCPMR_PRIORITY_MASK_REGISTER == ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) )
  107fea:	d006      	beq.n	107ffa <ulPortSetInterruptMask+0x2a>
		portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
  107fec:	2290      	movs	r2, #144	; 0x90
  107fee:	601a      	str	r2, [r3, #0]
		__asm volatile (	"dsb		\n"
  107ff0:	f3bf 8f4f 	dsb	sy
  107ff4:	f3bf 8f6f 	isb	sy
		ulReturn = pdFALSE;
  107ff8:	2000      	movs	r0, #0
	portCPU_IRQ_ENABLE();
  107ffa:	b662      	cpsie	i
  107ffc:	f3bf 8f4f 	dsb	sy
  108000:	f3bf 8f6f 	isb	sy
}
  108004:	4770      	bx	r14
  108006:	bf00      	nop

00108008 <vPortValidateInterruptPriority>:
	{
  108008:	b508      	push	{r3, r14}
		configASSERT( portICCRPR_RUNNING_PRIORITY_REGISTER >= ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT ) );
  10800a:	f242 0314 	movw	r3, #8212	; 0x2014
  10800e:	f2cf 5340 	movt	r3, #62784	; 0xf540
  108012:	681b      	ldr	r3, [r3, #0]
  108014:	2b8f      	cmp	r3, #143	; 0x8f
  108016:	d918      	bls.n	10804a <vPortValidateInterruptPriority+0x42>
		configASSERT( ( portICCBPR_BINARY_POINT_REGISTER & portBINARY_POINT_BITS ) <= portMAX_BINARY_POINT_VALUE );
  108018:	f242 0308 	movw	r3, #8200	; 0x2008
  10801c:	f2cf 5340 	movt	r3, #62784	; 0xf540
  108020:	681b      	ldr	r3, [r3, #0]
  108022:	f003 0303 	and.w	r3, r3, #3
  108026:	2b03      	cmp	r3, #3
  108028:	d000      	beq.n	10802c <vPortValidateInterruptPriority+0x24>
	}
  10802a:	bd08      	pop	{r3, r15}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  10802c:	f641 3150 	movw	r1, #6992	; 0x1b50
  108030:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  108034:	f240 2212 	movw	r2, #530	; 0x212
  108038:	f2c0 0111 	movt	r1, #17
  10803c:	f2c0 0011 	movt	r0, #17
  108040:	f003 f94c 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  108044:	b673      	cpsid	if
	__asm__ volatile("b .");
  108046:	e7fe      	b.n	108046 <vPortValidateInterruptPriority+0x3e>
	}
  108048:	bd08      	pop	{r3, r15}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  10804a:	f641 3150 	movw	r1, #6992	; 0x1b50
  10804e:	f641 30c4 	movw	r0, #7108	; 0x1bc4
  108052:	f240 2206 	movw	r2, #518	; 0x206
  108056:	f2c0 0111 	movt	r1, #17
  10805a:	f2c0 0011 	movt	r0, #17
  10805e:	f003 f93d 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  108062:	b673      	cpsid	if
	__asm__ volatile("b .");
  108064:	e7fe      	b.n	108064 <vPortValidateInterruptPriority+0x5c>
  108066:	e7d7      	b.n	108018 <vPortValidateInterruptPriority+0x10>

00108068 <vApplicationGetTimerTaskMemory>:
{
  108068:	b430      	push	{r4, r5}
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  10806a:	f647 33e4 	movw	r3, #31716	; 0x7be4
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  10806e:	f647 3480 	movw	r4, #31616	; 0x7b80
	*pulTimerTaskStackSize = configTASK_TIMER_STACK_SIZE;
  108072:	f44f 6500 	mov.w	r5, #2048	; 0x800
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  108076:	f2c0 0411 	movt	r4, #17
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  10807a:	f2c0 0311 	movt	r3, #17
	*ppxTimerTaskTCBBuffer = &xTimerTaskMem;
  10807e:	6004      	str	r4, [r0, #0]
	*ppxTimerTaskStackBuffer = xTimerTaskStack;
  108080:	600b      	str	r3, [r1, #0]
	*pulTimerTaskStackSize = configTASK_TIMER_STACK_SIZE;
  108082:	6015      	str	r5, [r2, #0]
}
  108084:	bc30      	pop	{r4, r5}
  108086:	4770      	bx	r14

00108088 <vApplicationGetIdleTaskMemory>:
{
  108088:	b430      	push	{r4, r5}
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  10808a:	f647 1380 	movw	r3, #31104	; 0x7980
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  10808e:	f647 141c 	movw	r4, #31004	; 0x791c
	*pulTimerTaskStackSize = configTASK_IDLE_STACK_SIZE;
  108092:	2580      	movs	r5, #128	; 0x80
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  108094:	f2c0 0411 	movt	r4, #17
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  108098:	f2c0 0311 	movt	r3, #17
	*ppxTimerTaskTCBBuffer = &xIdleTaskMem;
  10809c:	6004      	str	r4, [r0, #0]
	*ppxTimerTaskStackBuffer = xIdleTaskStack;
  10809e:	600b      	str	r3, [r1, #0]
	*pulTimerTaskStackSize = configTASK_IDLE_STACK_SIZE;
  1080a0:	6015      	str	r5, [r2, #0]
}
  1080a2:	bc30      	pop	{r4, r5}
  1080a4:	4770      	bx	r14
  1080a6:	bf00      	nop

001080a8 <vApplicationIdleHook>:
  1080a8:	4770      	bx	r14
  1080aa:	bf00      	nop

001080ac <vApplicationTickHook>:
  1080ac:	4770      	bx	r14
  1080ae:	bf00      	nop

001080b0 <vApplicationMallocFailedHook>:
  1080b0:	4770      	bx	r14
  1080b2:	bf00      	nop

001080b4 <vApplicationStackOverflowHook>:
	printf("FreeRTOS Kernel Fault:%20s Task StackOverFlow!\r\n", pcTaskName);
  1080b4:	f641 301c 	movw	r0, #6940	; 0x1b1c
{
  1080b8:	b508      	push	{r3, r14}
	printf("FreeRTOS Kernel Fault:%20s Task StackOverFlow!\r\n", pcTaskName);
  1080ba:	f2c0 0011 	movt	r0, #17
  1080be:	f003 f90d 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  1080c2:	b673      	cpsid	if
	__asm__ volatile("b .");
  1080c4:	e7fe      	b.n	1080c4 <vApplicationStackOverflowHook+0x10>
}
  1080c6:	bd08      	pop	{r3, r15}

001080c8 <traceTASK_SWITCHED_OUT_HOOK>:
  1080c8:	4770      	bx	r14
  1080ca:	bf00      	nop

001080cc <traceTASK_SWITCHED_IN_HOOK>:
  1080cc:	4770      	bx	r14
  1080ce:	bf00      	nop

001080d0 <vMainAssertCalled>:
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  1080d0:	460a      	mov	r2, r1
  1080d2:	4601      	mov	r1, r0
  1080d4:	f641 30c4 	movw	r0, #7108	; 0x1bc4
{
  1080d8:	b508      	push	{r3, r14}
	printf("FreeRTOS Kernel Fault:%s, %d Assertion Fail!\r\n", pcFileName, ulLineNumber);
  1080da:	f2c0 0011 	movt	r0, #17
  1080de:	f003 f8fd 	bl	10b2dc <printf>
	__asm__ volatile("cpsid if");
  1080e2:	b673      	cpsid	if
	__asm__ volatile("b .");
  1080e4:	e7fe      	b.n	1080e4 <vMainAssertCalled+0x14>
}
  1080e6:	bd08      	pop	{r3, r15}

001080e8 <vPortGetCurrentTimeMs>:

unsigned long current_time(void);
unsigned long vPortGetCurrentTimeMs( void )
{
	return current_time();
  1080e8:	f7f8 bace 	b.w	100688 <current_time>

001080ec <prvInsertBlockIntoFreeList>:
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  1080ec:	f649 32f4 	movw	r2, #39924	; 0x9bf4
{
  1080f0:	b410      	push	{r4}
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  1080f2:	f2c0 0211 	movt	r2, #17
  1080f6:	e000      	b.n	1080fa <prvInsertBlockIntoFreeList+0xe>
  1080f8:	461a      	mov	r2, r3
  1080fa:	6813      	ldr	r3, [r2, #0]
  1080fc:	4283      	cmp	r3, r0
  1080fe:	d3fb      	bcc.n	1080f8 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  108100:	6851      	ldr	r1, [r2, #4]
  108102:	1854      	adds	r4, r2, r1
  108104:	42a0      	cmp	r0, r4
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  108106:	bf05      	ittet	eq
  108108:	6844      	ldreq	r4, [r0, #4]
  10810a:	4610      	moveq	r0, r2
  10810c:	6841      	ldrne	r1, [r0, #4]
  10810e:	1909      	addeq	r1, r1, r4
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  108110:	eb00 0401 	add.w	r4, r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  108114:	bf08      	it	eq
  108116:	6051      	streq	r1, [r2, #4]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  108118:	42a3      	cmp	r3, r4
  10811a:	d006      	beq.n	10812a <prvInsertBlockIntoFreeList+0x3e>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  10811c:	6003      	str	r3, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  10811e:	4290      	cmp	r0, r2
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  108120:	f85d 4b04 	ldr.w	r4, [r13], #4
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  108124:	bf18      	it	ne
  108126:	6010      	strne	r0, [r2, #0]
}
  108128:	4770      	bx	r14
		if( pxIterator->pxNextFreeBlock != pxEnd )
  10812a:	f649 34e4 	movw	r4, #39908	; 0x9be4
  10812e:	f2c0 0411 	movt	r4, #17
  108132:	6824      	ldr	r4, [r4, #0]
  108134:	42a3      	cmp	r3, r4
  108136:	d0f1      	beq.n	10811c <prvInsertBlockIntoFreeList+0x30>
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  108138:	e9d3 3400 	ldrd	r3, r4, [r3]
	if( pxIterator != pxBlockToInsert )
  10813c:	4290      	cmp	r0, r2
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  10813e:	4421      	add	r1, r4
}
  108140:	f85d 4b04 	ldr.w	r4, [r13], #4
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  108144:	e9c0 3100 	strd	r3, r1, [r0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  108148:	bf18      	it	ne
  10814a:	6010      	strne	r0, [r2, #0]
}
  10814c:	4770      	bx	r14
  10814e:	bf00      	nop

00108150 <pvPortMallocAligned>:
{
  108150:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  108154:	460f      	mov	r7, r1
	configASSERT(!(xBoundary & (xBoundary - 1)));
  108156:	f101 39ff 	add.w	r9, r1, #4294967295	; 0xffffffff
{
  10815a:	4606      	mov	r6, r0
	configASSERT(!(xBoundary & (xBoundary - 1)));
  10815c:	ea19 0f01 	tst.w	r9, r1
  108160:	f040 8090 	bne.w	108284 <pvPortMallocAligned+0x134>
	vTaskSuspendAll();
  108164:	f001 fb08 	bl	109778 <vTaskSuspendAll>
		if( pxEnd == NULL )
  108168:	f649 32e4 	movw	r2, #39908	; 0x9be4
  10816c:	f2c0 0211 	movt	r2, #17
  108170:	6813      	ldr	r3, [r2, #0]
  108172:	2b00      	cmp	r3, #0
  108174:	f000 808e 	beq.w	108294 <pvPortMallocAligned+0x144>
  108178:	f649 38e8 	movw	r8, #39912	; 0x9be8
  10817c:	f2c0 0811 	movt	r8, #17
  108180:	f8d8 0000 	ldr.w	r0, [r8]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  108184:	4206      	tst	r6, r0
  108186:	d175      	bne.n	108274 <pvPortMallocAligned+0x124>
			if( xWantedSize > 0 )
  108188:	2e00      	cmp	r6, #0
  10818a:	d073      	beq.n	108274 <pvPortMallocAligned+0x124>
				xWantedSize += xHeapStructSize;
  10818c:	3608      	adds	r6, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  10818e:	0771      	lsls	r1, r6, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  108190:	bf1c      	itt	ne
  108192:	f026 0607 	bicne.w	r6, r6, #7
  108196:	3608      	addne	r6, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  108198:	2e00      	cmp	r6, #0
  10819a:	d06b      	beq.n	108274 <pvPortMallocAligned+0x124>
  10819c:	f649 3aec 	movw	r10, #39916	; 0x9bec
  1081a0:	f2c0 0a11 	movt	r10, #17
  1081a4:	f8da 3000 	ldr.w	r3, [r10]
  1081a8:	42b3      	cmp	r3, r6
  1081aa:	d363      	bcc.n	108274 <pvPortMallocAligned+0x124>
				pxBlock = xStart.pxNextFreeBlock;
  1081ac:	f649 31f4 	movw	r1, #39924	; 0x9bf4
  1081b0:	f2c0 0111 	movt	r1, #17
  1081b4:	6808      	ldr	r0, [r1, #0]
				xPaddingSize = (( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 ));
  1081b6:	1a3d      	subs	r5, r7, r0
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  1081b8:	6843      	ldr	r3, [r0, #4]
				xPaddingSize = (( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 ));
  1081ba:	3d08      	subs	r5, #8
  1081bc:	ea05 0509 	and.w	r5, r5, r9
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  1081c0:	1974      	adds	r4, r6, r5
  1081c2:	42a3      	cmp	r3, r4
  1081c4:	f080 809c 	bcs.w	108300 <pvPortMallocAligned+0x1b0>
  1081c8:	6804      	ldr	r4, [r0, #0]
  1081ca:	2c00      	cmp	r4, #0
  1081cc:	f000 8098 	beq.w	108300 <pvPortMallocAligned+0x1b0>
  1081d0:	3f08      	subs	r7, #8
  1081d2:	e003      	b.n	1081dc <pvPortMallocAligned+0x8c>
  1081d4:	6823      	ldr	r3, [r4, #0]
  1081d6:	b143      	cbz	r3, 1081ea <pvPortMallocAligned+0x9a>
  1081d8:	4620      	mov	r0, r4
  1081da:	461c      	mov	r4, r3
  1081dc:	6863      	ldr	r3, [r4, #4]
					xPaddingSize = ( xBoundary - ( uintptr_t )pxBlock - xHeapStructSize ) & ( xBoundary - 1 );
  1081de:	1b3d      	subs	r5, r7, r4
  1081e0:	ea05 0509 	and.w	r5, r5, r9
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  1081e4:	1971      	adds	r1, r6, r5
  1081e6:	428b      	cmp	r3, r1
  1081e8:	d3f4      	bcc.n	1081d4 <pvPortMallocAligned+0x84>
				if( pxBlock != pxEnd )
  1081ea:	6813      	ldr	r3, [r2, #0]
  1081ec:	42a3      	cmp	r3, r4
  1081ee:	d041      	beq.n	108274 <pvPortMallocAligned+0x124>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  1081f0:	6823      	ldr	r3, [r4, #0]
  1081f2:	6003      	str	r3, [r0, #0]
					if( xPaddingSize > 0 )
  1081f4:	b15d      	cbz	r5, 10820e <pvPortMallocAligned+0xbe>
						configASSERT( xPaddingSize >= xHeapStructSize );
  1081f6:	2d07      	cmp	r5, #7
  1081f8:	f240 8085 	bls.w	108306 <pvPortMallocAligned+0x1b6>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xPaddingSize;
  1081fc:	6863      	ldr	r3, [r4, #4]
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xPaddingSize );
  1081fe:	1962      	adds	r2, r4, r5
						prvInsertBlockIntoFreeList( pxBlock );
  108200:	4620      	mov	r0, r4
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xPaddingSize;
  108202:	1b5b      	subs	r3, r3, r5
  108204:	6053      	str	r3, [r2, #4]
						pxBlock->xBlockSize = xPaddingSize;
  108206:	6065      	str	r5, [r4, #4]
						prvInsertBlockIntoFreeList( pxBlock );
  108208:	4614      	mov	r4, r2
  10820a:	f7ff ff6f 	bl	1080ec <prvInsertBlockIntoFreeList>
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  10820e:	6862      	ldr	r2, [r4, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xHeapStructSize );
  108210:	f104 0508 	add.w	r5, r4, #8
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  108214:	1b93      	subs	r3, r2, r6
  108216:	2b10      	cmp	r3, #16
  108218:	d908      	bls.n	10822c <pvPortMallocAligned+0xdc>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  10821a:	19a7      	adds	r7, r4, r6
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  10821c:	077a      	lsls	r2, r7, #29
  10821e:	d17a      	bne.n	108316 <pvPortMallocAligned+0x1c6>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  108220:	607b      	str	r3, [r7, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  108222:	4638      	mov	r0, r7
						pxBlock->xBlockSize = xWantedSize;
  108224:	6066      	str	r6, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  108226:	f7ff ff61 	bl	1080ec <prvInsertBlockIntoFreeList>
  10822a:	6862      	ldr	r2, [r4, #4]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  10822c:	f8da 3000 	ldr.w	r3, [r10]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  108230:	f649 30f0 	movw	r0, #39920	; 0x9bf0
  108234:	f2c0 0011 	movt	r0, #17
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  108238:	1a9b      	subs	r3, r3, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  10823a:	6801      	ldr	r1, [r0, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
  10823c:	f8ca 3000 	str.w	r3, [r10]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  108240:	428b      	cmp	r3, r1
					pxBlock->pxNextFreeBlock = NULL;
  108242:	f04f 0100 	mov.w	r1, #0
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  108246:	bf38      	it	cc
  108248:	6003      	strcc	r3, [r0, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  10824a:	f8d8 3000 	ldr.w	r3, [r8]
  10824e:	431a      	orrs	r2, r3
  108250:	e9c4 1200 	strd	r1, r2, [r4]
	( void ) xTaskResumeAll();
  108254:	f001 fb6e 	bl	109934 <xTaskResumeAll>
		if( pvReturn == NULL )
  108258:	b175      	cbz	r5, 108278 <pvPortMallocAligned+0x128>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  10825a:	076b      	lsls	r3, r5, #29
  10825c:	d00f      	beq.n	10827e <pvPortMallocAligned+0x12e>
  10825e:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  108262:	f44f 718c 	mov.w	r1, #280	; 0x118
  108266:	f2c0 0011 	movt	r0, #17
  10826a:	f7ff ff31 	bl	1080d0 <vMainAssertCalled>
}
  10826e:	4628      	mov	r0, r5
  108270:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	( void ) xTaskResumeAll();
  108274:	f001 fb5e 	bl	109934 <xTaskResumeAll>
			vApplicationMallocFailedHook();
  108278:	f7ff ff1a 	bl	1080b0 <vApplicationMallocFailedHook>
  10827c:	2500      	movs	r5, #0
}
  10827e:	4628      	mov	r0, r5
  108280:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT(!(xBoundary & (xBoundary - 1)));
  108284:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  108288:	2179      	movs	r1, #121	; 0x79
  10828a:	f2c0 0011 	movt	r0, #17
  10828e:	f7ff ff1f 	bl	1080d0 <vMainAssertCalled>
  108292:	e767      	b.n	108164 <pvPortMallocAligned+0x14>
	uxAddress = ( size_t ) __heap;
  108294:	f24a 018c 	movw	r1, #41100	; 0xa08c
  108298:	f645 7374 	movw	r3, #24436	; 0x5f74
  10829c:	f2c0 0111 	movt	r1, #17
  1082a0:	f2c0 0306 	movt	r3, #6
  1082a4:	440b      	add	r3, r1
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  1082a6:	0748      	lsls	r0, r1, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  1082a8:	bf18      	it	ne
  1082aa:	3107      	addne	r1, #7
	uxAddress -= xHeapStructSize;
  1082ac:	f1a3 0308 	sub.w	r3, r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  1082b0:	f023 0307 	bic.w	r3, r3, #7
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082b4:	f649 3cf0 	movw	r12, #39920	; 0x9bf0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  1082b8:	bf18      	it	ne
  1082ba:	f021 0107 	bicne.w	r1, r1, #7
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  1082be:	1a5d      	subs	r5, r3, r1
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082c0:	f649 30ec 	movw	r0, #39916	; 0x9bec
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082c4:	f2c0 0c11 	movt	r12, #17
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  1082c8:	f649 34f4 	movw	r4, #39924	; 0x9bf4
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  1082cc:	f649 38e8 	movw	r8, #39912	; 0x9be8
  1082d0:	f04f 4e00 	mov.w	r14, #2147483648	; 0x80000000
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082d4:	f2c0 0011 	movt	r0, #17
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  1082d8:	f2c0 0411 	movt	r4, #17
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082dc:	f8cc 5000 	str.w	r5, [r12]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  1082e0:	f2c0 0811 	movt	r8, #17
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  1082e4:	6005      	str	r5, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
  1082e6:	f04f 0c00 	mov.w	r12, #0
	pxEnd = ( void * ) uxAddress;
  1082ea:	6013      	str	r3, [r2, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  1082ec:	4670      	mov	r0, r14
	pxEnd->pxNextFreeBlock = NULL;
  1082ee:	e9c3 cc00 	strd	r12, r12, [r3]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  1082f2:	f8c8 e000 	str.w	r14, [r8]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  1082f6:	e9c4 1c00 	strd	r1, r12, [r4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  1082fa:	e9c1 3500 	strd	r3, r5, [r1]
  1082fe:	e741      	b.n	108184 <pvPortMallocAligned+0x34>
				while( ( pxBlock->xBlockSize < xPaddingSize + xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  108300:	4604      	mov	r4, r0
				pxPreviousBlock = &xStart;
  108302:	4608      	mov	r0, r1
  108304:	e771      	b.n	1081ea <pvPortMallocAligned+0x9a>
						configASSERT( xPaddingSize >= xHeapStructSize );
  108306:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  10830a:	21c1      	movs	r1, #193	; 0xc1
  10830c:	f2c0 0011 	movt	r0, #17
  108310:	f7ff fede 	bl	1080d0 <vMainAssertCalled>
  108314:	e772      	b.n	1081fc <pvPortMallocAligned+0xac>
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  108316:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  10831a:	21d8      	movs	r1, #216	; 0xd8
  10831c:	f2c0 0011 	movt	r0, #17
  108320:	f7ff fed6 	bl	1080d0 <vMainAssertCalled>
  108324:	6863      	ldr	r3, [r4, #4]
  108326:	1b9b      	subs	r3, r3, r6
  108328:	e77a      	b.n	108220 <pvPortMallocAligned+0xd0>
  10832a:	bf00      	nop

0010832c <vPortFree>:
	if( pv != NULL )
  10832c:	2800      	cmp	r0, #0
  10832e:	d046      	beq.n	1083be <vPortFree+0x92>
{
  108330:	b538      	push	{r3, r4, r5, r14}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  108332:	f649 35e8 	movw	r5, #39912	; 0x9be8
  108336:	4604      	mov	r4, r0
  108338:	f850 3c04 	ldr.w	r3, [r0, #-4]
  10833c:	f2c0 0511 	movt	r5, #17
  108340:	682a      	ldr	r2, [r5, #0]
  108342:	4213      	tst	r3, r2
  108344:	d013      	beq.n	10836e <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  108346:	f850 1c08 	ldr.w	r1, [r0, #-8]
  10834a:	b309      	cbz	r1, 108390 <vPortFree+0x64>
  10834c:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  108350:	f44f 7199 	mov.w	r1, #306	; 0x132
  108354:	f2c0 0011 	movt	r0, #17
  108358:	f7ff feba 	bl	1080d0 <vMainAssertCalled>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  10835c:	682a      	ldr	r2, [r5, #0]
  10835e:	f854 3c04 	ldr.w	r3, [r4, #-4]
  108362:	4213      	tst	r3, r2
  108364:	d002      	beq.n	10836c <vPortFree+0x40>
			if( pxLink->pxNextFreeBlock == NULL )
  108366:	f854 1c08 	ldr.w	r1, [r4, #-8]
  10836a:	b189      	cbz	r1, 108390 <vPortFree+0x64>
}
  10836c:	bd38      	pop	{r3, r4, r5, r15}
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  10836e:	f641 30f4 	movw	r0, #7156	; 0x1bf4
  108372:	f240 1131 	movw	r1, #305	; 0x131
  108376:	f2c0 0011 	movt	r0, #17
  10837a:	f7ff fea9 	bl	1080d0 <vMainAssertCalled>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  10837e:	f854 3c08 	ldr.w	r3, [r4, #-8]
  108382:	2b00      	cmp	r3, #0
  108384:	d1e2      	bne.n	10834c <vPortFree+0x20>
		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  108386:	682a      	ldr	r2, [r5, #0]
  108388:	f854 3c04 	ldr.w	r3, [r4, #-4]
  10838c:	4213      	tst	r3, r2
  10838e:	d0ed      	beq.n	10836c <vPortFree+0x40>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  108390:	ea23 0302 	bic.w	r3, r3, r2
  108394:	f844 3c04 	str.w	r3, [r4, #-4]
				vTaskSuspendAll();
  108398:	f001 f9ee 	bl	109778 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
  10839c:	f649 33ec 	movw	r3, #39916	; 0x9bec
  1083a0:	f854 2c04 	ldr.w	r2, [r4, #-4]
  1083a4:	f2c0 0311 	movt	r3, #17
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  1083a8:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
  1083ac:	6819      	ldr	r1, [r3, #0]
  1083ae:	440a      	add	r2, r1
  1083b0:	601a      	str	r2, [r3, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  1083b2:	f7ff fe9b 	bl	1080ec <prvInsertBlockIntoFreeList>
}
  1083b6:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
				( void ) xTaskResumeAll();
  1083ba:	f001 babb 	b.w	109934 <xTaskResumeAll>
  1083be:	4770      	bx	r14

001083c0 <malloc>:
	return pvPortMallocAligned(xWantedSize, 1);
}

void* memalign(size_t boundary, size_t size)
{
	return pvPortMallocAligned(size, boundary);
  1083c0:	2101      	movs	r1, #1
  1083c2:	f7ff bec5 	b.w	108150 <pvPortMallocAligned>
  1083c6:	bf00      	nop

001083c8 <pvPortMalloc>:
  1083c8:	f7ff bffa 	b.w	1083c0 <malloc>

001083cc <vListInitialise>:
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1083cc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  1083d0:	f100 0308 	add.w	r3, r0, #8
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  1083d4:	2200      	movs	r2, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  1083d6:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  1083d8:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  1083da:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  1083dc:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  1083e0:	4770      	bx	r14
  1083e2:	bf00      	nop

001083e4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  1083e4:	2300      	movs	r3, #0
  1083e6:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  1083e8:	4770      	bx	r14
  1083ea:	bf00      	nop

001083ec <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
  1083ec:	6843      	ldr	r3, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
  1083ee:	6802      	ldr	r2, [r0, #0]
{
  1083f0:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  1083f2:	689c      	ldr	r4, [r3, #8]
	( pxList->uxNumberOfItems )++;
  1083f4:	3201      	adds	r2, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  1083f6:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  1083f8:	689c      	ldr	r4, [r3, #8]
	pxNewListItem->pxNext = pxIndex;
  1083fa:	604b      	str	r3, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
  1083fc:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
  1083fe:	6099      	str	r1, [r3, #8]
}
  108400:	f85d 4b04 	ldr.w	r4, [r13], #4
	pxNewListItem->pxContainer = pxList;
  108404:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
  108406:	6002      	str	r2, [r0, #0]
}
  108408:	4770      	bx	r14
  10840a:	bf00      	nop

0010840c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  10840c:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  10840e:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  108410:	1c6b      	adds	r3, r5, #1
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  108412:	bf18      	it	ne
  108414:	f100 0208 	addne.w	r2, r0, #8
	if( xValueOfInsertion == portMAX_DELAY )
  108418:	d101      	bne.n	10841e <vListInsert+0x12>
  10841a:	e00e      	b.n	10843a <vListInsert+0x2e>
  10841c:	461a      	mov	r2, r3
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  10841e:	6853      	ldr	r3, [r2, #4]
  108420:	681c      	ldr	r4, [r3, #0]
  108422:	42ac      	cmp	r4, r5
  108424:	d9fa      	bls.n	10841c <vListInsert+0x10>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
  108426:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
  108428:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  10842a:	6099      	str	r1, [r3, #8]
	( pxList->uxNumberOfItems )++;
  10842c:	3401      	adds	r4, #1
	pxNewListItem->pxPrevious = pxIterator;
  10842e:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
  108430:	6051      	str	r1, [r2, #4]
	pxNewListItem->pxContainer = pxList;
  108432:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
  108434:	6004      	str	r4, [r0, #0]
}
  108436:	bc30      	pop	{r4, r5}
  108438:	4770      	bx	r14
		pxIterator = pxList->xListEnd.pxPrevious;
  10843a:	6902      	ldr	r2, [r0, #16]
  10843c:	6853      	ldr	r3, [r2, #4]
  10843e:	e7f2      	b.n	108426 <vListInsert+0x1a>

00108440 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  108440:	6903      	ldr	r3, [r0, #16]
{
  108442:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  108444:	e9d0 2101 	ldrd	r2, r1, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  108448:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  10844a:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  10844c:	6881      	ldr	r1, [r0, #8]
	if( pxList->pxIndex == pxItemToRemove )
  10844e:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  108450:	604a      	str	r2, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
  108452:	681a      	ldr	r2, [r3, #0]
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  108454:	bf08      	it	eq
  108456:	6059      	streq	r1, [r3, #4]
	pxItemToRemove->pxContainer = NULL;
  108458:	2100      	movs	r1, #0

	return pxList->uxNumberOfItems;
}
  10845a:	f85d 4b04 	ldr.w	r4, [r13], #4
	( pxList->uxNumberOfItems )--;
  10845e:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
  108460:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
  108462:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
  108464:	6818      	ldr	r0, [r3, #0]
}
  108466:	4770      	bx	r14

00108468 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  108468:	b570      	push	{r4, r5, r6, r14}
  10846a:	4616      	mov	r6, r2
  10846c:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  10846e:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108470:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  108472:	b932      	cbnz	r2, 108482 <prvCopyDataToQueue+0x1a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  108474:	6806      	ldr	r6, [r0, #0]
  108476:	3501      	adds	r5, #1
  108478:	2e00      	cmp	r6, #0
  10847a:	d02b      	beq.n	1084d4 <prvCopyDataToQueue+0x6c>
BaseType_t xReturn = pdFALSE;
  10847c:	2000      	movs	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  10847e:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
  108480:	bd70      	pop	{r4, r5, r6, r15}
	else if( xPosition == queueSEND_TO_BACK )
  108482:	b97e      	cbnz	r6, 1084a4 <prvCopyDataToQueue+0x3c>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  108484:	6840      	ldr	r0, [r0, #4]
  108486:	3501      	adds	r5, #1
  108488:	f001 ef76 	blx	10a378 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  10848c:	6863      	ldr	r3, [r4, #4]
  10848e:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  108490:	68a2      	ldr	r2, [r4, #8]
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  108492:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  108494:	4293      	cmp	r3, r2
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  108496:	6063      	str	r3, [r4, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  108498:	d3f0      	bcc.n	10847c <prvCopyDataToQueue+0x14>
			pxQueue->pcWriteTo = pxQueue->pcHead;
  10849a:	6823      	ldr	r3, [r4, #0]
BaseType_t xReturn = pdFALSE;
  10849c:	4630      	mov	r0, r6
			pxQueue->pcWriteTo = pxQueue->pcHead;
  10849e:	6063      	str	r3, [r4, #4]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  1084a0:	63a5      	str	r5, [r4, #56]	; 0x38
}
  1084a2:	bd70      	pop	{r4, r5, r6, r15}
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  1084a4:	68c0      	ldr	r0, [r0, #12]
  1084a6:	f001 ef68 	blx	10a378 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  1084aa:	6c22      	ldr	r2, [r4, #64]	; 0x40
  1084ac:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  1084ae:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  1084b0:	4252      	negs	r2, r2
  1084b2:	4413      	add	r3, r2
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  1084b4:	428b      	cmp	r3, r1
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  1084b6:	60e3      	str	r3, [r4, #12]
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  1084b8:	bf3e      	ittt	cc
  1084ba:	68a3      	ldrcc	r3, [r4, #8]
  1084bc:	18d2      	addcc	r2, r2, r3
  1084be:	60e2      	strcc	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
  1084c0:	2e02      	cmp	r6, #2
BaseType_t xReturn = pdFALSE;
  1084c2:	bf1c      	itt	ne
  1084c4:	2000      	movne	r0, #0
  1084c6:	3501      	addne	r5, #1
		if( xPosition == queueOVERWRITE )
  1084c8:	d1d9      	bne.n	10847e <prvCopyDataToQueue+0x16>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  1084ca:	2d00      	cmp	r5, #0
  1084cc:	d1d6      	bne.n	10847c <prvCopyDataToQueue+0x14>
  1084ce:	2501      	movs	r5, #1
BaseType_t xReturn = pdFALSE;
  1084d0:	2000      	movs	r0, #0
  1084d2:	e7d4      	b.n	10847e <prvCopyDataToQueue+0x16>
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  1084d4:	6880      	ldr	r0, [r0, #8]
  1084d6:	f001 fbd9 	bl	109c8c <xTaskPriorityDisinherit>
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  1084da:	60a6      	str	r6, [r4, #8]
  1084dc:	e7cf      	b.n	10847e <prvCopyDataToQueue+0x16>
  1084de:	bf00      	nop

001084e0 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
	{
  1084e0:	b570      	push	{r4, r5, r6, r14}
	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
  1084e2:	6c84      	ldr	r4, [r0, #72]	; 0x48
	{
  1084e4:	b082      	sub	sp, #8
  1084e6:	460d      	mov	r5, r1
  1084e8:	9001      	str	r0, [sp, #4]
	BaseType_t xReturn = pdFALSE;

		/* This function must be called form a critical section. */

		configASSERT( pxQueueSetContainer );
  1084ea:	2c00      	cmp	r4, #0
  1084ec:	d030      	beq.n	108550 <prvNotifyQueueSetContainer+0x70>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  1084ee:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  1084f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  1084f2:	4299      	cmp	r1, r3
  1084f4:	d222      	bcs.n	10853c <prvNotifyQueueSetContainer+0x5c>

		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  1084f6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
  1084f8:	4299      	cmp	r1, r3
	BaseType_t xReturn = pdFALSE;
  1084fa:	bf28      	it	cs
  1084fc:	2600      	movcs	r6, #0
		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
  1084fe:	d302      	bcc.n	108506 <prvNotifyQueueSetContainer+0x26>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
  108500:	4630      	mov	r0, r6
  108502:	b002      	add	sp, #8
  108504:	bd70      	pop	{r4, r5, r6, r15}
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  108506:	462a      	mov	r2, r5
  108508:	a901      	add	r1, sp, #4
  10850a:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  10850c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  108510:	f7ff ffaa 	bl	108468 <prvCopyDataToQueue>
			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
  108514:	b26d      	sxtb	r5, r5
			if( cTxLock == queueUNLOCKED )
  108516:	1c6b      	adds	r3, r5, #1
				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
  108518:	bf1e      	ittt	ne
  10851a:	3501      	addne	r5, #1
  10851c:	b26d      	sxtbne	r5, r5
  10851e:	f884 5045 	strbne.w	r5, [r4, #69]	; 0x45
			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
  108522:	4606      	mov	r6, r0
			if( cTxLock == queueUNLOCKED )
  108524:	d1ec      	bne.n	108500 <prvNotifyQueueSetContainer+0x20>
				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
  108526:	6a63      	ldr	r3, [r4, #36]	; 0x24
  108528:	2b00      	cmp	r3, #0
  10852a:	d0e9      	beq.n	108500 <prvNotifyQueueSetContainer+0x20>
					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
  10852c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108530:	f001 fada 	bl	109ae8 <xTaskRemoveFromEventList>
						xReturn = pdTRUE;
  108534:	2800      	cmp	r0, #0
  108536:	bf18      	it	ne
  108538:	2601      	movne	r6, #1
  10853a:	e7e1      	b.n	108500 <prvNotifyQueueSetContainer+0x20>
		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
  10853c:	f641 4060 	movw	r0, #7264	; 0x1c60
  108540:	f640 3146 	movw	r1, #2886	; 0xb46
  108544:	f2c0 0011 	movt	r0, #17
  108548:	f7ff fdc2 	bl	1080d0 <vMainAssertCalled>
  10854c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  10854e:	e7d2      	b.n	1084f6 <prvNotifyQueueSetContainer+0x16>
		configASSERT( pxQueueSetContainer );
  108550:	f641 4060 	movw	r0, #7264	; 0x1c60
  108554:	f640 3145 	movw	r1, #2885	; 0xb45
  108558:	f2c0 0011 	movt	r0, #17
  10855c:	f7ff fdb8 	bl	1080d0 <vMainAssertCalled>
  108560:	e7c5      	b.n	1084ee <prvNotifyQueueSetContainer+0xe>
  108562:	bf00      	nop

00108564 <prvCopyDataFromQueue>:
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  108564:	6c02      	ldr	r2, [r0, #64]	; 0x40
  108566:	b172      	cbz	r2, 108586 <prvCopyDataFromQueue+0x22>
{
  108568:	b410      	push	{r4}
  10856a:	460b      	mov	r3, r1
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  10856c:	e9d0 4102 	ldrd	r4, r1, [r0, #8]
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  108570:	4411      	add	r1, r2
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  108572:	42a1      	cmp	r1, r4
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  108574:	60c1      	str	r1, [r0, #12]
}
  108576:	f85d 4b04 	ldr.w	r4, [r13], #4
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  10857a:	bf24      	itt	cs
  10857c:	6801      	ldrcs	r1, [r0, #0]
  10857e:	60c1      	strcs	r1, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  108580:	4618      	mov	r0, r3
  108582:	f003 bc25 	b.w	10bdd0 <__memcpy_from_thumb>
  108586:	4770      	bx	r14

00108588 <prvUnlockQueue>:
{
  108588:	b570      	push	{r4, r5, r6, r14}
  10858a:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
  10858c:	f7ff fca6 	bl	107edc <vPortEnterCritical>
		int8_t cTxLock = pxQueue->cTxLock;
  108590:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
  108594:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
  108596:	2c00      	cmp	r4, #0
  108598:	dd1c      	ble.n	1085d4 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  10859a:	f105 0624 	add.w	r6, r5, #36	; 0x24
  10859e:	e006      	b.n	1085ae <prvUnlockQueue+0x26>
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  1085a0:	f7ff ff9e 	bl	1084e0 <prvNotifyQueueSetContainer>
  1085a4:	b978      	cbnz	r0, 1085c6 <prvUnlockQueue+0x3e>
  1085a6:	3c01      	subs	r4, #1
  1085a8:	b2e3      	uxtb	r3, r4
  1085aa:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
  1085ac:	b193      	cbz	r3, 1085d4 <prvUnlockQueue+0x4c>
				if( pxQueue->pxQueueSetContainer != NULL )
  1085ae:	6cab      	ldr	r3, [r5, #72]	; 0x48
					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
  1085b0:	2100      	movs	r1, #0
  1085b2:	4628      	mov	r0, r5
				if( pxQueue->pxQueueSetContainer != NULL )
  1085b4:	2b00      	cmp	r3, #0
  1085b6:	d1f3      	bne.n	1085a0 <prvUnlockQueue+0x18>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  1085b8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  1085ba:	4630      	mov	r0, r6
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  1085bc:	b153      	cbz	r3, 1085d4 <prvUnlockQueue+0x4c>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  1085be:	f001 fa93 	bl	109ae8 <xTaskRemoveFromEventList>
  1085c2:	2800      	cmp	r0, #0
  1085c4:	d0ef      	beq.n	1085a6 <prvUnlockQueue+0x1e>
  1085c6:	3c01      	subs	r4, #1
						vTaskMissedYield();
  1085c8:	f001 fb46 	bl	109c58 <vTaskMissedYield>
  1085cc:	b2e3      	uxtb	r3, r4
  1085ce:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
  1085d0:	2b00      	cmp	r3, #0
  1085d2:	d1ec      	bne.n	1085ae <prvUnlockQueue+0x26>
		pxQueue->cTxLock = queueUNLOCKED;
  1085d4:	23ff      	movs	r3, #255	; 0xff
  1085d6:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
  1085da:	f7ff fcb9 	bl	107f50 <vPortExitCritical>
	taskENTER_CRITICAL();
  1085de:	f7ff fc7d 	bl	107edc <vPortEnterCritical>
		int8_t cRxLock = pxQueue->cRxLock;
  1085e2:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
  1085e6:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
  1085e8:	2c00      	cmp	r4, #0
  1085ea:	dd16      	ble.n	10861a <prvUnlockQueue+0x92>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  1085ec:	692b      	ldr	r3, [r5, #16]
  1085ee:	b1a3      	cbz	r3, 10861a <prvUnlockQueue+0x92>
  1085f0:	f105 0610 	add.w	r6, r5, #16
  1085f4:	e005      	b.n	108602 <prvUnlockQueue+0x7a>
  1085f6:	3c01      	subs	r4, #1
  1085f8:	b2e3      	uxtb	r3, r4
  1085fa:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
  1085fc:	b16b      	cbz	r3, 10861a <prvUnlockQueue+0x92>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  1085fe:	692b      	ldr	r3, [r5, #16]
  108600:	b15b      	cbz	r3, 10861a <prvUnlockQueue+0x92>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  108602:	4630      	mov	r0, r6
  108604:	f001 fa70 	bl	109ae8 <xTaskRemoveFromEventList>
  108608:	2800      	cmp	r0, #0
  10860a:	d0f4      	beq.n	1085f6 <prvUnlockQueue+0x6e>
  10860c:	3c01      	subs	r4, #1
					vTaskMissedYield();
  10860e:	f001 fb23 	bl	109c58 <vTaskMissedYield>
  108612:	b2e3      	uxtb	r3, r4
  108614:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
  108616:	2b00      	cmp	r3, #0
  108618:	d1f1      	bne.n	1085fe <prvUnlockQueue+0x76>
		pxQueue->cRxLock = queueUNLOCKED;
  10861a:	23ff      	movs	r3, #255	; 0xff
  10861c:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
}
  108620:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
	taskEXIT_CRITICAL();
  108624:	f7ff bc94 	b.w	107f50 <vPortExitCritical>

00108628 <xQueueGenericReset>:
{
  108628:	b538      	push	{r3, r4, r5, r14}
  10862a:	460d      	mov	r5, r1
	configASSERT( pxQueue );
  10862c:	4604      	mov	r4, r0
  10862e:	b388      	cbz	r0, 108694 <xQueueGenericReset+0x6c>
	taskENTER_CRITICAL();
  108630:	f7ff fc54 	bl	107edc <vPortEnterCritical>
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  108634:	e9d4 130f 	ldrd	r1, r3, [r4, #60]	; 0x3c
  108638:	6822      	ldr	r2, [r4, #0]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  10863a:	2000      	movs	r0, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
  10863c:	6062      	str	r2, [r4, #4]
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  10863e:	fb01 f103 	mul.w	r1, r1, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  108642:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock = queueUNLOCKED;
  108644:	20ff      	movs	r0, #255	; 0xff
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  108646:	1acb      	subs	r3, r1, r3
		pxQueue->cRxLock = queueUNLOCKED;
  108648:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  10864c:	4413      	add	r3, r2
		pxQueue->cTxLock = queueUNLOCKED;
  10864e:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  108652:	440a      	add	r2, r1
  108654:	e9c4 2302 	strd	r2, r3, [r4, #8]
		if( xNewQueue == pdFALSE )
  108658:	b985      	cbnz	r5, 10867c <xQueueGenericReset+0x54>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  10865a:	6923      	ldr	r3, [r4, #16]
  10865c:	b91b      	cbnz	r3, 108666 <xQueueGenericReset+0x3e>
	taskEXIT_CRITICAL();
  10865e:	f7ff fc77 	bl	107f50 <vPortExitCritical>
}
  108662:	2001      	movs	r0, #1
  108664:	bd38      	pop	{r3, r4, r5, r15}
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  108666:	f104 0010 	add.w	r0, r4, #16
  10866a:	f001 fa3d 	bl	109ae8 <xTaskRemoveFromEventList>
  10866e:	2800      	cmp	r0, #0
  108670:	d0f5      	beq.n	10865e <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
  108672:	df00      	svc	0
	taskEXIT_CRITICAL();
  108674:	f7ff fc6c 	bl	107f50 <vPortExitCritical>
}
  108678:	2001      	movs	r0, #1
  10867a:	bd38      	pop	{r3, r4, r5, r15}
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  10867c:	f104 0010 	add.w	r0, r4, #16
  108680:	f7ff fea4 	bl	1083cc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  108684:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108688:	f7ff fea0 	bl	1083cc <vListInitialise>
	taskEXIT_CRITICAL();
  10868c:	f7ff fc60 	bl	107f50 <vPortExitCritical>
}
  108690:	2001      	movs	r0, #1
  108692:	bd38      	pop	{r3, r4, r5, r15}
	configASSERT( pxQueue );
  108694:	f641 4060 	movw	r0, #7264	; 0x1c60
  108698:	f240 1103 	movw	r1, #259	; 0x103
  10869c:	f2c0 0011 	movt	r0, #17
  1086a0:	f7ff fd16 	bl	1080d0 <vMainAssertCalled>
  1086a4:	e7c4      	b.n	108630 <xQueueGenericReset+0x8>
  1086a6:	bf00      	nop

001086a8 <xQueueGenericCreateStatic>:
	{
  1086a8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1086ac:	460e      	mov	r6, r1
  1086ae:	b082      	sub	sp, #8
  1086b0:	4615      	mov	r5, r2
  1086b2:	461c      	mov	r4, r3
  1086b4:	f89d 8020 	ldrb.w	r8, [r13, #32]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  1086b8:	4607      	mov	r7, r0
  1086ba:	2800      	cmp	r0, #0
  1086bc:	d03d      	beq.n	10873a <xQueueGenericCreateStatic+0x92>
		configASSERT( pxStaticQueue != NULL );
  1086be:	2c00      	cmp	r4, #0
  1086c0:	d045      	beq.n	10874e <xQueueGenericCreateStatic+0xa6>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
  1086c2:	1c33      	adds	r3, r6, #0
  1086c4:	bf18      	it	ne
  1086c6:	2301      	movne	r3, #1
  1086c8:	2d00      	cmp	r5, #0
  1086ca:	bf08      	it	eq
  1086cc:	2301      	moveq	r3, #1
  1086ce:	2b00      	cmp	r3, #0
  1086d0:	d046      	beq.n	108760 <xQueueGenericCreateStatic+0xb8>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
  1086d2:	fab6 f386 	clz	r3, r6
  1086d6:	095b      	lsrs	r3, r3, #5
  1086d8:	2d00      	cmp	r5, #0
  1086da:	bf18      	it	ne
  1086dc:	2301      	movne	r3, #1
  1086de:	b31b      	cbz	r3, 108728 <xQueueGenericCreateStatic+0x80>
			volatile size_t xSize = sizeof( StaticQueue_t );
  1086e0:	2354      	movs	r3, #84	; 0x54
  1086e2:	9301      	str	r3, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
  1086e4:	9b01      	ldr	r3, [sp, #4]
  1086e6:	2b54      	cmp	r3, #84	; 0x54
  1086e8:	d007      	beq.n	1086fa <xQueueGenericCreateStatic+0x52>
  1086ea:	f641 4060 	movw	r0, #7264	; 0x1c60
  1086ee:	f240 114b 	movw	r1, #331	; 0x14b
  1086f2:	f2c0 0011 	movt	r0, #17
  1086f6:	f7ff fceb 	bl	1080d0 <vMainAssertCalled>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
  1086fa:	9b01      	ldr	r3, [sp, #4]
		if( pxNewQueue != NULL )
  1086fc:	b184      	cbz	r4, 108720 <xQueueGenericCreateStatic+0x78>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
  1086fe:	2301      	movs	r3, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  108700:	2e00      	cmp	r6, #0
  108702:	bf08      	it	eq
  108704:	4625      	moveq	r5, r4
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  108706:	4619      	mov	r1, r3
  108708:	4620      	mov	r0, r4
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
  10870a:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  10870e:	6025      	str	r5, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
  108710:	63e7      	str	r7, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  108712:	6426      	str	r6, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  108714:	f7ff ff88 	bl	108628 <xQueueGenericReset>
		pxNewQueue->ucQueueType = ucQueueType;
  108718:	f884 8050 	strb.w	r8, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
  10871c:	2300      	movs	r3, #0
  10871e:	64a3      	str	r3, [r4, #72]	; 0x48
	}
  108720:	4620      	mov	r0, r4
  108722:	b002      	add	sp, #8
  108724:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
  108728:	f641 4060 	movw	r0, #7264	; 0x1c60
  10872c:	f240 1143 	movw	r1, #323	; 0x143
  108730:	f2c0 0011 	movt	r0, #17
  108734:	f7ff fccc 	bl	1080d0 <vMainAssertCalled>
  108738:	e7d2      	b.n	1086e0 <xQueueGenericCreateStatic+0x38>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  10873a:	f641 4060 	movw	r0, #7264	; 0x1c60
  10873e:	f44f 719d 	mov.w	r1, #314	; 0x13a
  108742:	f2c0 0011 	movt	r0, #17
  108746:	f7ff fcc3 	bl	1080d0 <vMainAssertCalled>
		configASSERT( pxStaticQueue != NULL );
  10874a:	2c00      	cmp	r4, #0
  10874c:	d1b9      	bne.n	1086c2 <xQueueGenericCreateStatic+0x1a>
  10874e:	f641 4060 	movw	r0, #7264	; 0x1c60
  108752:	f44f 719f 	mov.w	r1, #318	; 0x13e
  108756:	f2c0 0011 	movt	r0, #17
  10875a:	f7ff fcb9 	bl	1080d0 <vMainAssertCalled>
  10875e:	e7b0      	b.n	1086c2 <xQueueGenericCreateStatic+0x1a>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
  108760:	f641 4060 	movw	r0, #7264	; 0x1c60
  108764:	f44f 71a1 	mov.w	r1, #322	; 0x142
  108768:	f2c0 0011 	movt	r0, #17
  10876c:	f7ff fcb0 	bl	1080d0 <vMainAssertCalled>
  108770:	e7b6      	b.n	1086e0 <xQueueGenericCreateStatic+0x38>
  108772:	bf00      	nop

00108774 <xQueueGenericCreate>:
	{
  108774:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  108776:	460d      	mov	r5, r1
  108778:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  10877a:	4606      	mov	r6, r0
  10877c:	b310      	cbz	r0, 1087c4 <xQueueGenericCreate+0x50>
		if( uxItemSize == ( UBaseType_t ) 0 )
  10877e:	b16d      	cbz	r5, 10879c <xQueueGenericCreate+0x28>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  108780:	fb05 f006 	mul.w	r0, r5, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  108784:	3054      	adds	r0, #84	; 0x54
  108786:	f7ff fe1f 	bl	1083c8 <pvPortMalloc>
		if( pxNewQueue != NULL )
  10878a:	4604      	mov	r4, r0
  10878c:	b318      	cbz	r0, 1087d6 <xQueueGenericCreate+0x62>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  10878e:	2200      	movs	r2, #0
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  108790:	f100 0354 	add.w	r3, r0, #84	; 0x54
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  108794:	f880 2046 	strb.w	r2, [r0, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  108798:	6003      	str	r3, [r0, #0]
  10879a:	e007      	b.n	1087ac <xQueueGenericCreate+0x38>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  10879c:	2054      	movs	r0, #84	; 0x54
  10879e:	f7ff fe13 	bl	1083c8 <pvPortMalloc>
		if( pxNewQueue != NULL )
  1087a2:	4604      	mov	r4, r0
  1087a4:	b1b8      	cbz	r0, 1087d6 <xQueueGenericCreate+0x62>
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  1087a6:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  1087aa:	6024      	str	r4, [r4, #0]
	pxNewQueue->uxLength = uxQueueLength;
  1087ac:	63e6      	str	r6, [r4, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  1087ae:	2101      	movs	r1, #1
	pxNewQueue->uxItemSize = uxItemSize;
  1087b0:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  1087b2:	4620      	mov	r0, r4
  1087b4:	f7ff ff38 	bl	108628 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
  1087b8:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
  1087ba:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
	}
  1087be:	4620      	mov	r0, r4
		pxNewQueue->pxQueueSetContainer = NULL;
  1087c0:	64a3      	str	r3, [r4, #72]	; 0x48
	}
  1087c2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  1087c4:	f641 4060 	movw	r0, #7264	; 0x1c60
  1087c8:	f44f 71bb 	mov.w	r1, #374	; 0x176
  1087cc:	f2c0 0011 	movt	r0, #17
  1087d0:	f7ff fc7e 	bl	1080d0 <vMainAssertCalled>
  1087d4:	e7d3      	b.n	10877e <xQueueGenericCreate+0xa>
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  1087d6:	2400      	movs	r4, #0
	}
  1087d8:	4620      	mov	r0, r4
  1087da:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

001087dc <xQueueGenericSend>:
{
  1087dc:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  1087e0:	4689      	mov	r9, r1
  1087e2:	b084      	sub	sp, #16
  1087e4:	4698      	mov	r8, r3
	configASSERT( pxQueue );
  1087e6:	4604      	mov	r4, r0
{
  1087e8:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
  1087ea:	2800      	cmp	r0, #0
  1087ec:	f000 809f 	beq.w	10892e <xQueueGenericSend+0x152>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  1087f0:	f1b9 0f00 	cmp.w	r9, #0
  1087f4:	d07f      	beq.n	1088f6 <xQueueGenericSend+0x11a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  1087f6:	f1b8 0f02 	cmp.w	r8, #2
  1087fa:	d070      	beq.n	1088de <xQueueGenericSend+0x102>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  1087fc:	f001 fa34 	bl	109c68 <xTaskGetSchedulerState>
  108800:	b918      	cbnz	r0, 10880a <xQueueGenericSend+0x2e>
  108802:	9b01      	ldr	r3, [sp, #4]
  108804:	2b00      	cmp	r3, #0
  108806:	f040 809b 	bne.w	108940 <xQueueGenericSend+0x164>
{
  10880a:	f04f 0a00 	mov.w	r10, #0
  10880e:	f1a8 0602 	sub.w	r6, r8, #2
		prvLockQueue( pxQueue );
  108812:	4657      	mov	r7, r10
  108814:	fab6 f686 	clz	r6, r6
  108818:	0976      	lsrs	r6, r6, #5
  10881a:	e028      	b.n	10886e <xQueueGenericSend+0x92>
		taskEXIT_CRITICAL();
  10881c:	f7ff fb98 	bl	107f50 <vPortExitCritical>
		vTaskSuspendAll();
  108820:	f000 ffaa 	bl	109778 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  108824:	f7ff fb5a 	bl	107edc <vPortEnterCritical>
  108828:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  10882c:	2bff      	cmp	r3, #255	; 0xff
  10882e:	bf08      	it	eq
  108830:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
  108834:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  108838:	2bff      	cmp	r3, #255	; 0xff
  10883a:	bf08      	it	eq
  10883c:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
  108840:	f7ff fb86 	bl	107f50 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  108844:	a901      	add	r1, sp, #4
  108846:	a802      	add	r0, sp, #8
  108848:	f001 f9aa 	bl	109ba0 <xTaskCheckForTimeOut>
  10884c:	2800      	cmp	r0, #0
  10884e:	d165      	bne.n	10891c <xQueueGenericSend+0x140>
	taskENTER_CRITICAL();
  108850:	f7ff fb44 	bl	107edc <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  108854:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  108856:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  108858:	429a      	cmp	r2, r3
  10885a:	d01c      	beq.n	108896 <xQueueGenericSend+0xba>
	taskEXIT_CRITICAL();
  10885c:	f7ff fb78 	bl	107f50 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  108860:	4620      	mov	r0, r4
  108862:	f7ff fe91 	bl	108588 <prvUnlockQueue>
				( void ) xTaskResumeAll();
  108866:	f001 f865 	bl	109934 <xTaskResumeAll>
  10886a:	f04f 0a01 	mov.w	r10, #1
		taskENTER_CRITICAL();
  10886e:	f7ff fb35 	bl	107edc <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  108872:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108874:	6be2      	ldr	r2, [r4, #60]	; 0x3c
  108876:	4293      	cmp	r3, r2
  108878:	bf2c      	ite	cs
  10887a:	4633      	movcs	r3, r6
  10887c:	f046 0301 	orrcc.w	r3, r6, #1
  108880:	b9cb      	cbnz	r3, 1088b6 <xQueueGenericSend+0xda>
				if( xTicksToWait == ( TickType_t ) 0 )
  108882:	9d01      	ldr	r5, [sp, #4]
  108884:	2d00      	cmp	r5, #0
  108886:	d043      	beq.n	108910 <xQueueGenericSend+0x134>
				else if( xEntryTimeSet == pdFALSE )
  108888:	f1ba 0f00 	cmp.w	r10, #0
  10888c:	d1c6      	bne.n	10881c <xQueueGenericSend+0x40>
					vTaskInternalSetTimeOutState( &xTimeOut );
  10888e:	a802      	add	r0, sp, #8
  108890:	f001 f978 	bl	109b84 <vTaskInternalSetTimeOutState>
  108894:	e7c2      	b.n	10881c <xQueueGenericSend+0x40>
	taskEXIT_CRITICAL();
  108896:	f7ff fb5b 	bl	107f50 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  10889a:	9901      	ldr	r1, [sp, #4]
  10889c:	f104 0010 	add.w	r0, r4, #16
  1088a0:	f001 f8e4 	bl	109a6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  1088a4:	4620      	mov	r0, r4
  1088a6:	f7ff fe6f 	bl	108588 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  1088aa:	f001 f843 	bl	109934 <xTaskResumeAll>
  1088ae:	2800      	cmp	r0, #0
  1088b0:	d1db      	bne.n	10886a <xQueueGenericSend+0x8e>
					portYIELD_WITHIN_API();
  1088b2:	df00      	svc	0
  1088b4:	e7d9      	b.n	10886a <xQueueGenericSend+0x8e>
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  1088b6:	4649      	mov	r1, r9
  1088b8:	4642      	mov	r2, r8
				UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
  1088ba:	6ba5      	ldr	r5, [r4, #56]	; 0x38
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  1088bc:	4620      	mov	r0, r4
  1088be:	f7ff fdd3 	bl	108468 <prvCopyDataToQueue>
					if( pxQueue->pxQueueSetContainer != NULL )
  1088c2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  1088c4:	2b00      	cmp	r3, #0
  1088c6:	d044      	beq.n	108952 <xQueueGenericSend+0x176>
						if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
  1088c8:	2d00      	cmp	r5, #0
  1088ca:	bf08      	it	eq
  1088cc:	2600      	moveq	r6, #0
  1088ce:	2e00      	cmp	r6, #0
  1088d0:	d045      	beq.n	10895e <xQueueGenericSend+0x182>
				taskEXIT_CRITICAL();
  1088d2:	f7ff fb3d 	bl	107f50 <vPortExitCritical>
				return pdPASS;
  1088d6:	2001      	movs	r0, #1
}
  1088d8:	b004      	add	sp, #16
  1088da:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  1088de:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  1088e0:	2b01      	cmp	r3, #1
  1088e2:	d08b      	beq.n	1087fc <xQueueGenericSend+0x20>
  1088e4:	f641 4060 	movw	r0, #7264	; 0x1c60
  1088e8:	f240 21f3 	movw	r1, #755	; 0x2f3
  1088ec:	f2c0 0011 	movt	r0, #17
  1088f0:	f7ff fbee 	bl	1080d0 <vMainAssertCalled>
  1088f4:	e782      	b.n	1087fc <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  1088f6:	6c23      	ldr	r3, [r4, #64]	; 0x40
  1088f8:	2b00      	cmp	r3, #0
  1088fa:	f43f af7c 	beq.w	1087f6 <xQueueGenericSend+0x1a>
  1088fe:	f641 4060 	movw	r0, #7264	; 0x1c60
  108902:	f240 21f2 	movw	r1, #754	; 0x2f2
  108906:	f2c0 0011 	movt	r0, #17
  10890a:	f7ff fbe1 	bl	1080d0 <vMainAssertCalled>
  10890e:	e772      	b.n	1087f6 <xQueueGenericSend+0x1a>
					taskEXIT_CRITICAL();
  108910:	f7ff fb1e 	bl	107f50 <vPortExitCritical>
					return errQUEUE_FULL;
  108914:	4628      	mov	r0, r5
}
  108916:	b004      	add	sp, #16
  108918:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
			prvUnlockQueue( pxQueue );
  10891c:	4620      	mov	r0, r4
  10891e:	f7ff fe33 	bl	108588 <prvUnlockQueue>
			( void ) xTaskResumeAll();
  108922:	f001 f807 	bl	109934 <xTaskResumeAll>
			return errQUEUE_FULL;
  108926:	2000      	movs	r0, #0
}
  108928:	b004      	add	sp, #16
  10892a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
	configASSERT( pxQueue );
  10892e:	f641 4060 	movw	r0, #7264	; 0x1c60
  108932:	f240 21f1 	movw	r1, #753	; 0x2f1
  108936:	f2c0 0011 	movt	r0, #17
  10893a:	f7ff fbc9 	bl	1080d0 <vMainAssertCalled>
  10893e:	e757      	b.n	1087f0 <xQueueGenericSend+0x14>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  108940:	f641 4060 	movw	r0, #7264	; 0x1c60
  108944:	f240 21f6 	movw	r1, #758	; 0x2f6
  108948:	f2c0 0011 	movt	r0, #17
  10894c:	f7ff fbc0 	bl	1080d0 <vMainAssertCalled>
  108950:	e75b      	b.n	10880a <xQueueGenericSend+0x2e>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  108952:	6a63      	ldr	r3, [r4, #36]	; 0x24
  108954:	b953      	cbnz	r3, 10896c <xQueueGenericSend+0x190>
						else if( xYieldRequired != pdFALSE )
  108956:	2800      	cmp	r0, #0
  108958:	d0bb      	beq.n	1088d2 <xQueueGenericSend+0xf6>
							queueYIELD_IF_USING_PREEMPTION();
  10895a:	df00      	svc	0
  10895c:	e7b9      	b.n	1088d2 <xQueueGenericSend+0xf6>
						else if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  10895e:	4641      	mov	r1, r8
  108960:	4620      	mov	r0, r4
  108962:	f7ff fdbd 	bl	1084e0 <prvNotifyQueueSetContainer>
  108966:	2800      	cmp	r0, #0
  108968:	d1f7      	bne.n	10895a <xQueueGenericSend+0x17e>
  10896a:	e7b2      	b.n	1088d2 <xQueueGenericSend+0xf6>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  10896c:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108970:	f001 f8ba 	bl	109ae8 <xTaskRemoveFromEventList>
  108974:	2800      	cmp	r0, #0
  108976:	d1f0      	bne.n	10895a <xQueueGenericSend+0x17e>
  108978:	e7ab      	b.n	1088d2 <xQueueGenericSend+0xf6>
  10897a:	bf00      	nop

0010897c <xQueueCreateMutex>:
	{
  10897c:	b538      	push	{r3, r4, r5, r14}
		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
  10897e:	4602      	mov	r2, r0
  108980:	2100      	movs	r1, #0
  108982:	2001      	movs	r0, #1
  108984:	f7ff fef6 	bl	108774 <xQueueGenericCreate>
		if( pxNewQueue != NULL )
  108988:	4604      	mov	r4, r0
  10898a:	b140      	cbz	r0, 10899e <xQueueCreateMutex+0x22>
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  10898c:	2500      	movs	r5, #0
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  10898e:	462b      	mov	r3, r5
  108990:	462a      	mov	r2, r5
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
  108992:	60a5      	str	r5, [r4, #8]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  108994:	4629      	mov	r1, r5
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
  108996:	6005      	str	r5, [r0, #0]
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
  108998:	60c5      	str	r5, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
  10899a:	f7ff ff1f 	bl	1087dc <xQueueGenericSend>
	}
  10899e:	4620      	mov	r0, r4
  1089a0:	bd38      	pop	{r3, r4, r5, r15}
  1089a2:	bf00      	nop

001089a4 <xQueueGenericSendFromISR>:
{
  1089a4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1089a8:	460d      	mov	r5, r1
  1089aa:	4690      	mov	r8, r2
  1089ac:	461e      	mov	r6, r3
	configASSERT( pxQueue );
  1089ae:	4604      	mov	r4, r0
  1089b0:	2800      	cmp	r0, #0
  1089b2:	d04e      	beq.n	108a52 <xQueueGenericSendFromISR+0xae>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  1089b4:	b37d      	cbz	r5, 108a16 <xQueueGenericSendFromISR+0x72>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  1089b6:	2e02      	cmp	r6, #2
  1089b8:	d00f      	beq.n	1089da <xQueueGenericSendFromISR+0x36>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  1089ba:	f7ff fb25 	bl	108008 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  1089be:	f7ff fb07 	bl	107fd0 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  1089c2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  1089c4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  1089c6:	429a      	cmp	r2, r3
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  1089c8:	4607      	mov	r7, r0
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  1089ca:	d30f      	bcc.n	1089ec <xQueueGenericSendFromISR+0x48>
			xReturn = errQUEUE_FULL;
  1089cc:	2600      	movs	r6, #0
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  1089ce:	4638      	mov	r0, r7
  1089d0:	f7ff fae8 	bl	107fa4 <vPortClearInterruptMask>
}
  1089d4:	4630      	mov	r0, r6
  1089d6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  1089da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  1089dc:	2b01      	cmp	r3, #1
  1089de:	d141      	bne.n	108a64 <xQueueGenericSendFromISR+0xc0>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  1089e0:	f7ff fb12 	bl	108008 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  1089e4:	f7ff faf4 	bl	107fd0 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  1089e8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  1089ea:	4607      	mov	r7, r0
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  1089ec:	4629      	mov	r1, r5
  1089ee:	4632      	mov	r2, r6
			const int8_t cTxLock = pxQueue->cTxLock;
  1089f0:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  1089f4:	4620      	mov	r0, r4
			const int8_t cTxLock = pxQueue->cTxLock;
  1089f6:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  1089f8:	f7ff fd36 	bl	108468 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
  1089fc:	1c6b      	adds	r3, r5, #1
  1089fe:	d016      	beq.n	108a2e <xQueueGenericSendFromISR+0x8a>
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  108a00:	4638      	mov	r0, r7
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  108a02:	3501      	adds	r5, #1
			xReturn = pdPASS;
  108a04:	2601      	movs	r6, #1
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  108a06:	b26d      	sxtb	r5, r5
  108a08:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  108a0c:	f7ff faca 	bl	107fa4 <vPortClearInterruptMask>
}
  108a10:	4630      	mov	r0, r6
  108a12:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  108a16:	6c23      	ldr	r3, [r4, #64]	; 0x40
  108a18:	2b00      	cmp	r3, #0
  108a1a:	d0cc      	beq.n	1089b6 <xQueueGenericSendFromISR+0x12>
  108a1c:	f641 4060 	movw	r0, #7264	; 0x1c60
  108a20:	f44f 7171 	mov.w	r1, #964	; 0x3c4
  108a24:	f2c0 0011 	movt	r0, #17
  108a28:	f7ff fb52 	bl	1080d0 <vMainAssertCalled>
  108a2c:	e7c3      	b.n	1089b6 <xQueueGenericSendFromISR+0x12>
					if( pxQueue->pxQueueSetContainer != NULL )
  108a2e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  108a30:	b33b      	cbz	r3, 108a82 <xQueueGenericSendFromISR+0xde>
						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
  108a32:	4631      	mov	r1, r6
  108a34:	4620      	mov	r0, r4
  108a36:	f7ff fd53 	bl	1084e0 <prvNotifyQueueSetContainer>
							if( pxHigherPriorityTaskWoken != NULL )
  108a3a:	2800      	cmp	r0, #0
  108a3c:	bf18      	it	ne
  108a3e:	f1b8 0f00 	cmpne.w	r8, #0
  108a42:	d12a      	bne.n	108a9a <xQueueGenericSendFromISR+0xf6>
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  108a44:	4638      	mov	r0, r7
			xReturn = pdPASS;
  108a46:	2601      	movs	r6, #1
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  108a48:	f7ff faac 	bl	107fa4 <vPortClearInterruptMask>
}
  108a4c:	4630      	mov	r0, r6
  108a4e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( pxQueue );
  108a52:	f641 4060 	movw	r0, #7264	; 0x1c60
  108a56:	f240 31c3 	movw	r1, #963	; 0x3c3
  108a5a:	f2c0 0011 	movt	r0, #17
  108a5e:	f7ff fb37 	bl	1080d0 <vMainAssertCalled>
  108a62:	e7a7      	b.n	1089b4 <xQueueGenericSendFromISR+0x10>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  108a64:	f641 4060 	movw	r0, #7264	; 0x1c60
  108a68:	f240 31c5 	movw	r1, #965	; 0x3c5
  108a6c:	f2c0 0011 	movt	r0, #17
  108a70:	f7ff fb2e 	bl	1080d0 <vMainAssertCalled>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  108a74:	f7ff fac8 	bl	108008 <vPortValidateInterruptPriority>
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  108a78:	f7ff faaa 	bl	107fd0 <ulPortSetInterruptMask>
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  108a7c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  108a7e:	4607      	mov	r7, r0
  108a80:	e7b4      	b.n	1089ec <xQueueGenericSendFromISR+0x48>
						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  108a82:	6a63      	ldr	r3, [r4, #36]	; 0x24
  108a84:	2b00      	cmp	r3, #0
  108a86:	d0dd      	beq.n	108a44 <xQueueGenericSendFromISR+0xa0>
							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  108a88:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108a8c:	f001 f82c 	bl	109ae8 <xTaskRemoveFromEventList>
								if( pxHigherPriorityTaskWoken != NULL )
  108a90:	2800      	cmp	r0, #0
  108a92:	bf18      	it	ne
  108a94:	f1b8 0f00 	cmpne.w	r8, #0
  108a98:	d0d4      	beq.n	108a44 <xQueueGenericSendFromISR+0xa0>
									*pxHigherPriorityTaskWoken = pdTRUE;
  108a9a:	2301      	movs	r3, #1
			xReturn = pdPASS;
  108a9c:	461e      	mov	r6, r3
									*pxHigherPriorityTaskWoken = pdTRUE;
  108a9e:	f8c8 3000 	str.w	r3, [r8]
  108aa2:	e794      	b.n	1089ce <xQueueGenericSendFromISR+0x2a>

00108aa4 <xQueueReceive>:
{
  108aa4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  108aa8:	4688      	mov	r8, r1
  108aaa:	b084      	sub	sp, #16
	configASSERT( ( pxQueue ) );
  108aac:	4604      	mov	r4, r0
{
  108aae:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
  108ab0:	2800      	cmp	r0, #0
  108ab2:	f000 8086 	beq.w	108bc2 <xQueueReceive+0x11e>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  108ab6:	f1b8 0f00 	cmp.w	r8, #0
  108aba:	d076      	beq.n	108baa <xQueueReceive+0x106>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  108abc:	f001 f8d4 	bl	109c68 <xTaskGetSchedulerState>
  108ac0:	b918      	cbnz	r0, 108aca <xQueueReceive+0x26>
  108ac2:	9b01      	ldr	r3, [sp, #4]
  108ac4:	2b00      	cmp	r3, #0
  108ac6:	f040 8085 	bne.w	108bd4 <xQueueReceive+0x130>
		taskENTER_CRITICAL();
  108aca:	f7ff fa07 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108ace:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108ad0:	2d00      	cmp	r5, #0
  108ad2:	d146      	bne.n	108b62 <xQueueReceive+0xbe>
				if( xTicksToWait == ( TickType_t ) 0 )
  108ad4:	9b01      	ldr	r3, [sp, #4]
  108ad6:	2b00      	cmp	r3, #0
  108ad8:	d061      	beq.n	108b9e <xQueueReceive+0xfa>
		prvLockQueue( pxQueue );
  108ada:	462e      	mov	r6, r5
					vTaskInternalSetTimeOutState( &xTimeOut );
  108adc:	a802      	add	r0, sp, #8
  108ade:	f001 f851 	bl	109b84 <vTaskInternalSetTimeOutState>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  108ae2:	f104 0724 	add.w	r7, r4, #36	; 0x24
  108ae6:	e012      	b.n	108b0e <xQueueReceive+0x6a>
	taskENTER_CRITICAL();
  108ae8:	f7ff f9f8 	bl	107edc <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  108aec:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108aee:	2b00      	cmp	r3, #0
  108af0:	d046      	beq.n	108b80 <xQueueReceive+0xdc>
	taskEXIT_CRITICAL();
  108af2:	f7ff fa2d 	bl	107f50 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  108af6:	4620      	mov	r0, r4
  108af8:	f7ff fd46 	bl	108588 <prvUnlockQueue>
				( void ) xTaskResumeAll();
  108afc:	f000 ff1a 	bl	109934 <xTaskResumeAll>
		taskENTER_CRITICAL();
  108b00:	f7ff f9ec 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108b04:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108b06:	bb65      	cbnz	r5, 108b62 <xQueueReceive+0xbe>
				if( xTicksToWait == ( TickType_t ) 0 )
  108b08:	9b01      	ldr	r3, [sp, #4]
  108b0a:	2b00      	cmp	r3, #0
  108b0c:	d047      	beq.n	108b9e <xQueueReceive+0xfa>
		taskEXIT_CRITICAL();
  108b0e:	f7ff fa1f 	bl	107f50 <vPortExitCritical>
		vTaskSuspendAll();
  108b12:	f000 fe31 	bl	109778 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  108b16:	f7ff f9e1 	bl	107edc <vPortEnterCritical>
  108b1a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  108b1e:	2bff      	cmp	r3, #255	; 0xff
  108b20:	bf08      	it	eq
  108b22:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
  108b26:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  108b2a:	2bff      	cmp	r3, #255	; 0xff
  108b2c:	bf08      	it	eq
  108b2e:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
  108b32:	f7ff fa0d 	bl	107f50 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  108b36:	a901      	add	r1, sp, #4
  108b38:	a802      	add	r0, sp, #8
  108b3a:	f001 f831 	bl	109ba0 <xTaskCheckForTimeOut>
  108b3e:	2800      	cmp	r0, #0
  108b40:	d0d2      	beq.n	108ae8 <xQueueReceive+0x44>
			prvUnlockQueue( pxQueue );
  108b42:	4620      	mov	r0, r4
  108b44:	f7ff fd20 	bl	108588 <prvUnlockQueue>
			( void ) xTaskResumeAll();
  108b48:	f000 fef4 	bl	109934 <xTaskResumeAll>
	taskENTER_CRITICAL();
  108b4c:	f7ff f9c6 	bl	107edc <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  108b50:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108b52:	b323      	cbz	r3, 108b9e <xQueueReceive+0xfa>
	taskEXIT_CRITICAL();
  108b54:	f7ff f9fc 	bl	107f50 <vPortExitCritical>
		taskENTER_CRITICAL();
  108b58:	f7ff f9c0 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108b5c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108b5e:	2d00      	cmp	r5, #0
  108b60:	d0d2      	beq.n	108b08 <xQueueReceive+0x64>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  108b62:	4641      	mov	r1, r8
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  108b64:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  108b66:	4620      	mov	r0, r4
  108b68:	f7ff fcfc 	bl	108564 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  108b6c:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  108b6e:	6923      	ldr	r3, [r4, #16]
  108b70:	2b00      	cmp	r3, #0
  108b72:	d138      	bne.n	108be6 <xQueueReceive+0x142>
				taskEXIT_CRITICAL();
  108b74:	f7ff f9ec 	bl	107f50 <vPortExitCritical>
				return pdPASS;
  108b78:	2001      	movs	r0, #1
}
  108b7a:	b004      	add	sp, #16
  108b7c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	taskEXIT_CRITICAL();
  108b80:	f7ff f9e6 	bl	107f50 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  108b84:	9901      	ldr	r1, [sp, #4]
  108b86:	4638      	mov	r0, r7
  108b88:	f000 ff70 	bl	109a6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  108b8c:	4620      	mov	r0, r4
  108b8e:	f7ff fcfb 	bl	108588 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  108b92:	f000 fecf 	bl	109934 <xTaskResumeAll>
  108b96:	2800      	cmp	r0, #0
  108b98:	d1b2      	bne.n	108b00 <xQueueReceive+0x5c>
					portYIELD_WITHIN_API();
  108b9a:	df00      	svc	0
  108b9c:	e7b0      	b.n	108b00 <xQueueReceive+0x5c>
					taskEXIT_CRITICAL();
  108b9e:	f7ff f9d7 	bl	107f50 <vPortExitCritical>
					return errQUEUE_EMPTY;
  108ba2:	2000      	movs	r0, #0
}
  108ba4:	b004      	add	sp, #16
  108ba6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  108baa:	6c23      	ldr	r3, [r4, #64]	; 0x40
  108bac:	2b00      	cmp	r3, #0
  108bae:	d085      	beq.n	108abc <xQueueReceive+0x18>
  108bb0:	f641 4060 	movw	r0, #7264	; 0x1c60
  108bb4:	f240 5104 	movw	r1, #1284	; 0x504
  108bb8:	f2c0 0011 	movt	r0, #17
  108bbc:	f7ff fa88 	bl	1080d0 <vMainAssertCalled>
  108bc0:	e77c      	b.n	108abc <xQueueReceive+0x18>
	configASSERT( ( pxQueue ) );
  108bc2:	f641 4060 	movw	r0, #7264	; 0x1c60
  108bc6:	f44f 61a0 	mov.w	r1, #1280	; 0x500
  108bca:	f2c0 0011 	movt	r0, #17
  108bce:	f7ff fa7f 	bl	1080d0 <vMainAssertCalled>
  108bd2:	e770      	b.n	108ab6 <xQueueReceive+0x12>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  108bd4:	f641 4060 	movw	r0, #7264	; 0x1c60
  108bd8:	f240 5109 	movw	r1, #1289	; 0x509
  108bdc:	f2c0 0011 	movt	r0, #17
  108be0:	f7ff fa76 	bl	1080d0 <vMainAssertCalled>
  108be4:	e771      	b.n	108aca <xQueueReceive+0x26>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  108be6:	f104 0010 	add.w	r0, r4, #16
  108bea:	f000 ff7d 	bl	109ae8 <xTaskRemoveFromEventList>
  108bee:	2800      	cmp	r0, #0
  108bf0:	d0c0      	beq.n	108b74 <xQueueReceive+0xd0>
						queueYIELD_IF_USING_PREEMPTION();
  108bf2:	df00      	svc	0
  108bf4:	e7be      	b.n	108b74 <xQueueReceive+0xd0>
  108bf6:	bf00      	nop

00108bf8 <xQueuePeek>:
{
  108bf8:	b5f0      	push	{r4, r5, r6, r7, r14}
  108bfa:	460f      	mov	r7, r1
  108bfc:	b085      	sub	sp, #20
	configASSERT( ( pxQueue ) );
  108bfe:	4604      	mov	r4, r0
{
  108c00:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
  108c02:	2800      	cmp	r0, #0
  108c04:	f000 8081 	beq.w	108d0a <xQueuePeek+0x112>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  108c08:	2f00      	cmp	r7, #0
  108c0a:	d072      	beq.n	108cf2 <xQueuePeek+0xfa>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  108c0c:	f001 f82c 	bl	109c68 <xTaskGetSchedulerState>
  108c10:	b918      	cbnz	r0, 108c1a <xQueuePeek+0x22>
  108c12:	9b01      	ldr	r3, [sp, #4]
  108c14:	2b00      	cmp	r3, #0
  108c16:	f040 8081 	bne.w	108d1c <xQueuePeek+0x124>
		taskENTER_CRITICAL();
  108c1a:	f7ff f95f 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108c1e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108c20:	2d00      	cmp	r5, #0
  108c22:	d145      	bne.n	108cb0 <xQueuePeek+0xb8>
				if( xTicksToWait == ( TickType_t ) 0 )
  108c24:	9b01      	ldr	r3, [sp, #4]
  108c26:	2b00      	cmp	r3, #0
  108c28:	d05e      	beq.n	108ce8 <xQueuePeek+0xf0>
					vTaskInternalSetTimeOutState( &xTimeOut );
  108c2a:	a802      	add	r0, sp, #8
  108c2c:	f000 ffaa 	bl	109b84 <vTaskInternalSetTimeOutState>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  108c30:	f104 0624 	add.w	r6, r4, #36	; 0x24
  108c34:	e012      	b.n	108c5c <xQueuePeek+0x64>
	taskENTER_CRITICAL();
  108c36:	f7ff f951 	bl	107edc <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  108c3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108c3c:	2b00      	cmp	r3, #0
  108c3e:	d044      	beq.n	108cca <xQueuePeek+0xd2>
	taskEXIT_CRITICAL();
  108c40:	f7ff f986 	bl	107f50 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
  108c44:	4620      	mov	r0, r4
  108c46:	f7ff fc9f 	bl	108588 <prvUnlockQueue>
				( void ) xTaskResumeAll();
  108c4a:	f000 fe73 	bl	109934 <xTaskResumeAll>
		taskENTER_CRITICAL();
  108c4e:	f7ff f945 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108c52:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108c54:	bb63      	cbnz	r3, 108cb0 <xQueuePeek+0xb8>
				if( xTicksToWait == ( TickType_t ) 0 )
  108c56:	9b01      	ldr	r3, [sp, #4]
  108c58:	2b00      	cmp	r3, #0
  108c5a:	d045      	beq.n	108ce8 <xQueuePeek+0xf0>
		taskEXIT_CRITICAL();
  108c5c:	f7ff f978 	bl	107f50 <vPortExitCritical>
		vTaskSuspendAll();
  108c60:	f000 fd8a 	bl	109778 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  108c64:	f7ff f93a 	bl	107edc <vPortEnterCritical>
  108c68:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  108c6c:	2bff      	cmp	r3, #255	; 0xff
  108c6e:	bf08      	it	eq
  108c70:	f884 5044 	strbeq.w	r5, [r4, #68]	; 0x44
  108c74:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  108c78:	2bff      	cmp	r3, #255	; 0xff
  108c7a:	bf08      	it	eq
  108c7c:	f884 5045 	strbeq.w	r5, [r4, #69]	; 0x45
  108c80:	f7ff f966 	bl	107f50 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  108c84:	a901      	add	r1, sp, #4
  108c86:	a802      	add	r0, sp, #8
  108c88:	f000 ff8a 	bl	109ba0 <xTaskCheckForTimeOut>
  108c8c:	2800      	cmp	r0, #0
  108c8e:	d0d2      	beq.n	108c36 <xQueuePeek+0x3e>
			prvUnlockQueue( pxQueue );
  108c90:	4620      	mov	r0, r4
  108c92:	f7ff fc79 	bl	108588 <prvUnlockQueue>
			( void ) xTaskResumeAll();
  108c96:	f000 fe4d 	bl	109934 <xTaskResumeAll>
	taskENTER_CRITICAL();
  108c9a:	f7ff f91f 	bl	107edc <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  108c9e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108ca0:	b313      	cbz	r3, 108ce8 <xQueuePeek+0xf0>
	taskEXIT_CRITICAL();
  108ca2:	f7ff f955 	bl	107f50 <vPortExitCritical>
		taskENTER_CRITICAL();
  108ca6:	f7ff f919 	bl	107edc <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  108caa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  108cac:	2b00      	cmp	r3, #0
  108cae:	d0d2      	beq.n	108c56 <xQueuePeek+0x5e>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  108cb0:	4639      	mov	r1, r7
  108cb2:	4620      	mov	r0, r4
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
  108cb4:	68e5      	ldr	r5, [r4, #12]
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  108cb6:	f7ff fc55 	bl	108564 <prvCopyDataFromQueue>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  108cba:	6a63      	ldr	r3, [r4, #36]	; 0x24
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
  108cbc:	60e5      	str	r5, [r4, #12]
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  108cbe:	bbb3      	cbnz	r3, 108d2e <xQueuePeek+0x136>
				taskEXIT_CRITICAL();
  108cc0:	f7ff f946 	bl	107f50 <vPortExitCritical>
				return pdPASS;
  108cc4:	2001      	movs	r0, #1
}
  108cc6:	b005      	add	sp, #20
  108cc8:	bdf0      	pop	{r4, r5, r6, r7, r15}
	taskEXIT_CRITICAL();
  108cca:	f7ff f941 	bl	107f50 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  108cce:	9901      	ldr	r1, [sp, #4]
  108cd0:	4630      	mov	r0, r6
  108cd2:	f000 fecb 	bl	109a6c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  108cd6:	4620      	mov	r0, r4
  108cd8:	f7ff fc56 	bl	108588 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  108cdc:	f000 fe2a 	bl	109934 <xTaskResumeAll>
  108ce0:	2800      	cmp	r0, #0
  108ce2:	d1e0      	bne.n	108ca6 <xQueuePeek+0xae>
					portYIELD_WITHIN_API();
  108ce4:	df00      	svc	0
  108ce6:	e7de      	b.n	108ca6 <xQueuePeek+0xae>
					taskEXIT_CRITICAL();
  108ce8:	f7ff f932 	bl	107f50 <vPortExitCritical>
					return errQUEUE_EMPTY;
  108cec:	2000      	movs	r0, #0
}
  108cee:	b005      	add	sp, #20
  108cf0:	bdf0      	pop	{r4, r5, r6, r7, r15}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  108cf2:	6c23      	ldr	r3, [r4, #64]	; 0x40
  108cf4:	2b00      	cmp	r3, #0
  108cf6:	d089      	beq.n	108c0c <xQueuePeek+0x14>
  108cf8:	f641 4060 	movw	r0, #7264	; 0x1c60
  108cfc:	f240 616c 	movw	r1, #1644	; 0x66c
  108d00:	f2c0 0011 	movt	r0, #17
  108d04:	f7ff f9e4 	bl	1080d0 <vMainAssertCalled>
  108d08:	e780      	b.n	108c0c <xQueuePeek+0x14>
	configASSERT( ( pxQueue ) );
  108d0a:	f641 4060 	movw	r0, #7264	; 0x1c60
  108d0e:	f44f 61cd 	mov.w	r1, #1640	; 0x668
  108d12:	f2c0 0011 	movt	r0, #17
  108d16:	f7ff f9db 	bl	1080d0 <vMainAssertCalled>
  108d1a:	e775      	b.n	108c08 <xQueuePeek+0x10>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  108d1c:	f641 4060 	movw	r0, #7264	; 0x1c60
  108d20:	f240 6171 	movw	r1, #1649	; 0x671
  108d24:	f2c0 0011 	movt	r0, #17
  108d28:	f7ff f9d2 	bl	1080d0 <vMainAssertCalled>
  108d2c:	e775      	b.n	108c1a <xQueuePeek+0x22>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  108d2e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108d32:	f000 fed9 	bl	109ae8 <xTaskRemoveFromEventList>
  108d36:	2800      	cmp	r0, #0
  108d38:	d0c2      	beq.n	108cc0 <xQueuePeek+0xc8>
						queueYIELD_IF_USING_PREEMPTION();
  108d3a:	df00      	svc	0
  108d3c:	e7c0      	b.n	108cc0 <xQueuePeek+0xc8>
  108d3e:	bf00      	nop

00108d40 <vQueueDelete>:
{
  108d40:	b510      	push	{r4, r14}
	configASSERT( pxQueue );
  108d42:	4604      	mov	r4, r0
  108d44:	b1f8      	cbz	r0, 108d86 <vQueueDelete+0x46>
  108d46:	f649 30fc 	movw	r0, #39932	; 0x9bfc
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  108d4a:	2200      	movs	r2, #0
  108d4c:	f2c0 0011 	movt	r0, #17
  108d50:	4603      	mov	r3, r0
			if( xQueueRegistry[ ux ].xHandle == xQueue )
  108d52:	6859      	ldr	r1, [r3, #4]
  108d54:	3308      	adds	r3, #8
  108d56:	428c      	cmp	r4, r1
  108d58:	d006      	beq.n	108d68 <vQueueDelete+0x28>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  108d5a:	3201      	adds	r2, #1
  108d5c:	2a08      	cmp	r2, #8
  108d5e:	d1f8      	bne.n	108d52 <vQueueDelete+0x12>
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
  108d60:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  108d64:	b153      	cbz	r3, 108d7c <vQueueDelete+0x3c>
}
  108d66:	bd10      	pop	{r4, r15}
				xQueueRegistry[ ux ].pcQueueName = NULL;
  108d68:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
  108d6a:	eb00 01c2 	add.w	r1, r0, r2, lsl #3
				xQueueRegistry[ ux ].pcQueueName = NULL;
  108d6e:	f840 3032 	str.w	r3, [r0, r2, lsl #3]
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
  108d72:	604b      	str	r3, [r1, #4]
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
  108d74:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
  108d78:	2b00      	cmp	r3, #0
  108d7a:	d1f4      	bne.n	108d66 <vQueueDelete+0x26>
			vPortFree( pxQueue );
  108d7c:	4620      	mov	r0, r4
}
  108d7e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
			vPortFree( pxQueue );
  108d82:	f7ff bad3 	b.w	10832c <vPortFree>
	configASSERT( pxQueue );
  108d86:	f641 4060 	movw	r0, #7264	; 0x1c60
  108d8a:	f240 71b7 	movw	r1, #1975	; 0x7b7
  108d8e:	f2c0 0011 	movt	r0, #17
  108d92:	f7ff f99d 	bl	1080d0 <vMainAssertCalled>
  108d96:	e7d6      	b.n	108d46 <vQueueDelete+0x6>

00108d98 <vQueueAddToRegistry>:
	{
  108d98:	b430      	push	{r4, r5}
  108d9a:	f649 34fc 	movw	r4, #39932	; 0x9bfc
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  108d9e:	2300      	movs	r3, #0
  108da0:	f2c0 0411 	movt	r4, #17
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
  108da4:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
  108da8:	00dd      	lsls	r5, r3, #3
  108daa:	b122      	cbz	r2, 108db6 <vQueueAddToRegistry+0x1e>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  108dac:	3301      	adds	r3, #1
  108dae:	2b08      	cmp	r3, #8
  108db0:	d1f8      	bne.n	108da4 <vQueueAddToRegistry+0xc>
	}
  108db2:	bc30      	pop	{r4, r5}
  108db4:	4770      	bx	r14
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
  108db6:	f844 1033 	str.w	r1, [r4, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
  108dba:	4425      	add	r5, r4
  108dbc:	6068      	str	r0, [r5, #4]
	}
  108dbe:	bc30      	pop	{r4, r5}
  108dc0:	4770      	bx	r14
  108dc2:	bf00      	nop

00108dc4 <vQueueWaitForMessageRestricted>:
	{
  108dc4:	b570      	push	{r4, r5, r6, r14}
  108dc6:	4604      	mov	r4, r0
  108dc8:	460d      	mov	r5, r1
  108dca:	4616      	mov	r6, r2
		prvLockQueue( pxQueue );
  108dcc:	f7ff f886 	bl	107edc <vPortEnterCritical>
  108dd0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
  108dd4:	2bff      	cmp	r3, #255	; 0xff
  108dd6:	bf04      	itt	eq
  108dd8:	2300      	moveq	r3, #0
  108dda:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
  108dde:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
  108de2:	2bff      	cmp	r3, #255	; 0xff
  108de4:	bf04      	itt	eq
  108de6:	2300      	moveq	r3, #0
  108de8:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
  108dec:	f7ff f8b0 	bl	107f50 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  108df0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  108df2:	b92b      	cbnz	r3, 108e00 <vQueueWaitForMessageRestricted+0x3c>
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  108df4:	4632      	mov	r2, r6
  108df6:	4629      	mov	r1, r5
  108df8:	f104 0024 	add.w	r0, r4, #36	; 0x24
  108dfc:	f000 fe52 	bl	109aa4 <vTaskPlaceOnEventListRestricted>
		prvUnlockQueue( pxQueue );
  108e00:	4620      	mov	r0, r4
	}
  108e02:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
		prvUnlockQueue( pxQueue );
  108e06:	f7ff bbbf 	b.w	108588 <prvUnlockQueue>
  108e0a:	bf00      	nop

00108e0c <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  108e0c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
  108e10:	4606      	mov	r6, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  108e12:	f7ff f863 	bl	107edc <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  108e16:	f649 63cc 	movw	r3, #40652	; 0x9ecc
		if( pxCurrentTCB == NULL )
  108e1a:	f649 453c 	movw	r5, #39996	; 0x9c3c
		uxCurrentNumberOfTasks++;
  108e1e:	f2c0 0311 	movt	r3, #17
		if( pxCurrentTCB == NULL )
  108e22:	f2c0 0511 	movt	r5, #17
		uxCurrentNumberOfTasks++;
  108e26:	681a      	ldr	r2, [r3, #0]
  108e28:	3201      	adds	r2, #1
  108e2a:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
  108e2c:	682a      	ldr	r2, [r5, #0]
  108e2e:	2a00      	cmp	r2, #0
  108e30:	d03a      	beq.n	108ea8 <prvAddNewTaskToReadyList+0x9c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  108e32:	f649 7828 	movw	r8, #40744	; 0x9f28
  108e36:	f649 4948 	movw	r9, #40008	; 0x9c48
  108e3a:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  108e3c:	f2c0 0811 	movt	r8, #17
  108e40:	f2c0 0911 	movt	r9, #17
  108e44:	f8d8 3000 	ldr.w	r3, [r8]
  108e48:	b323      	cbz	r3, 108e94 <prvAddNewTaskToReadyList+0x88>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  108e4a:	f649 64dc 	movw	r4, #40668	; 0x9edc
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  108e4e:	f649 62e0 	movw	r2, #40672	; 0x9ee0
		uxTaskNumber++;
  108e52:	f2c0 0411 	movt	r4, #17
		prvAddTaskToReadyList( pxNewTCB );
  108e56:	2301      	movs	r3, #1
  108e58:	f2c0 0211 	movt	r2, #17
  108e5c:	eb01 0081 	add.w	r0, r1, r1, lsl #2
		uxTaskNumber++;
  108e60:	6827      	ldr	r7, [r4, #0]
		prvAddTaskToReadyList( pxNewTCB );
  108e62:	408b      	lsls	r3, r1
  108e64:	6811      	ldr	r1, [r2, #0]
		uxTaskNumber++;
  108e66:	3701      	adds	r7, #1
		prvAddTaskToReadyList( pxNewTCB );
  108e68:	eb09 0080 	add.w	r0, r9, r0, lsl #2
			pxNewTCB->uxTCBNumber = uxTaskNumber;
  108e6c:	64b7      	str	r7, [r6, #72]	; 0x48
		prvAddTaskToReadyList( pxNewTCB );
  108e6e:	430b      	orrs	r3, r1
		uxTaskNumber++;
  108e70:	6027      	str	r7, [r4, #0]
		prvAddTaskToReadyList( pxNewTCB );
  108e72:	1d31      	adds	r1, r6, #4
  108e74:	6013      	str	r3, [r2, #0]
  108e76:	f7ff fab9 	bl	1083ec <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  108e7a:	f7ff f869 	bl	107f50 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
  108e7e:	f8d8 3000 	ldr.w	r3, [r8]
  108e82:	b12b      	cbz	r3, 108e90 <prvAddNewTaskToReadyList+0x84>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  108e84:	682a      	ldr	r2, [r5, #0]
  108e86:	6af3      	ldr	r3, [r6, #44]	; 0x2c
  108e88:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  108e8a:	429a      	cmp	r2, r3
  108e8c:	d200      	bcs.n	108e90 <prvAddNewTaskToReadyList+0x84>
		{
			taskYIELD_IF_USING_PREEMPTION();
  108e8e:	df00      	svc	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  108e90:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  108e94:	682b      	ldr	r3, [r5, #0]
  108e96:	f649 4948 	movw	r9, #40008	; 0x9c48
  108e9a:	f2c0 0911 	movt	r9, #17
  108e9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  108ea0:	428b      	cmp	r3, r1
					pxCurrentTCB = pxNewTCB;
  108ea2:	bf98      	it	ls
  108ea4:	602e      	strls	r6, [r5, #0]
  108ea6:	e7d0      	b.n	108e4a <prvAddNewTaskToReadyList+0x3e>
			pxCurrentTCB = pxNewTCB;
  108ea8:	602e      	str	r6, [r5, #0]
  108eaa:	f649 4948 	movw	r9, #40008	; 0x9c48
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  108eae:	681b      	ldr	r3, [r3, #0]
  108eb0:	2b01      	cmp	r3, #1
  108eb2:	d007      	beq.n	108ec4 <prvAddNewTaskToReadyList+0xb8>
  108eb4:	f649 7828 	movw	r8, #40744	; 0x9f28
  108eb8:	f2c0 0911 	movt	r9, #17
  108ebc:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  108ebe:	f2c0 0811 	movt	r8, #17
  108ec2:	e7c2      	b.n	108e4a <prvAddNewTaskToReadyList+0x3e>
  108ec4:	f2c0 0911 	movt	r9, #17
  108ec8:	464c      	mov	r4, r9
  108eca:	f509 7720 	add.w	r7, r9, #640	; 0x280
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  108ece:	4620      	mov	r0, r4
  108ed0:	3414      	adds	r4, #20
  108ed2:	f7ff fa7b 	bl	1083cc <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  108ed6:	42a7      	cmp	r7, r4
  108ed8:	d1f9      	bne.n	108ece <prvAddNewTaskToReadyList+0xc2>
	}

	vListInitialise( &xDelayedTaskList1 );
  108eda:	f649 67e4 	movw	r7, #40676	; 0x9ee4
	vListInitialise( &xDelayedTaskList2 );
  108ede:	f649 64f8 	movw	r4, #40696	; 0x9ef8
	vListInitialise( &xDelayedTaskList1 );
  108ee2:	f2c0 0711 	movt	r7, #17
  108ee6:	4638      	mov	r0, r7
	vListInitialise( &xDelayedTaskList2 );
  108ee8:	f2c0 0411 	movt	r4, #17
	vListInitialise( &xDelayedTaskList1 );
  108eec:	f7ff fa6e 	bl	1083cc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  108ef0:	4620      	mov	r0, r4
  108ef2:	f7ff fa6b 	bl	1083cc <vListInitialise>
	vListInitialise( &xPendingReadyList );
  108ef6:	f649 7014 	movw	r0, #40724	; 0x9f14
  108efa:	f649 7828 	movw	r8, #40744	; 0x9f28
  108efe:	f2c0 0011 	movt	r0, #17
  108f02:	f7ff fa63 	bl	1083cc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  108f06:	f649 7040 	movw	r0, #40768	; 0x9f40
  108f0a:	f2c0 0011 	movt	r0, #17
  108f0e:	f7ff fa5d 	bl	1083cc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  108f12:	f649 702c 	movw	r0, #40748	; 0x9f2c
  108f16:	f2c0 0011 	movt	r0, #17
  108f1a:	f7ff fa57 	bl	1083cc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  108f1e:	f649 4240 	movw	r2, #40000	; 0x9c40
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  108f22:	f649 4344 	movw	r3, #40004	; 0x9c44
	pxDelayedTaskList = &xDelayedTaskList1;
  108f26:	f2c0 0211 	movt	r2, #17
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  108f2a:	f2c0 0311 	movt	r3, #17
	pxDelayedTaskList = &xDelayedTaskList1;
  108f2e:	6017      	str	r7, [r2, #0]
  108f30:	f2c0 0811 	movt	r8, #17
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  108f34:	601c      	str	r4, [r3, #0]
  108f36:	6af1      	ldr	r1, [r6, #44]	; 0x2c
  108f38:	e787      	b.n	108e4a <prvAddNewTaskToReadyList+0x3e>
  108f3a:	bf00      	nop

00108f3c <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  108f3c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  108f3e:	f649 7354 	movw	r3, #40788	; 0x9f54
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  108f42:	f649 443c 	movw	r4, #39996	; 0x9c3c
const TickType_t xConstTickCount = xTickCount;
  108f46:	f2c0 0311 	movt	r3, #17
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  108f4a:	2200      	movs	r2, #0
  108f4c:	f2c0 0411 	movt	r4, #17
{
  108f50:	4606      	mov	r6, r0
  108f52:	460f      	mov	r7, r1
const TickType_t xConstTickCount = xTickCount;
  108f54:	681d      	ldr	r5, [r3, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  108f56:	6823      	ldr	r3, [r4, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  108f58:	6820      	ldr	r0, [r4, #0]
		pxCurrentTCB->ucDelayAborted = pdFALSE;
  108f5a:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  108f5e:	3004      	adds	r0, #4
  108f60:	f7ff fa6e 	bl	108440 <uxListRemove>
  108f64:	b958      	cbnz	r0, 108f7e <prvAddCurrentTaskToDelayedList+0x42>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
  108f66:	6822      	ldr	r2, [r4, #0]
  108f68:	f649 63e0 	movw	r3, #40672	; 0x9ee0
  108f6c:	2101      	movs	r1, #1
  108f6e:	f2c0 0311 	movt	r3, #17
  108f72:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  108f74:	681a      	ldr	r2, [r3, #0]
  108f76:	4081      	lsls	r1, r0
  108f78:	ea22 0201 	bic.w	r2, r2, r1
  108f7c:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  108f7e:	f1a6 33ff 	sub.w	r3, r6, #4294967295	; 0xffffffff
  108f82:	fab3 f383 	clz	r3, r3
  108f86:	2f00      	cmp	r7, #0
  108f88:	ea4f 1353 	mov.w	r3, r3, lsr #5
  108f8c:	bf08      	it	eq
  108f8e:	2300      	moveq	r3, #0
  108f90:	bb03      	cbnz	r3, 108fd4 <prvAddCurrentTaskToDelayedList+0x98>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  108f92:	6823      	ldr	r3, [r4, #0]
  108f94:	19ad      	adds	r5, r5, r6
  108f96:	605d      	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
  108f98:	d211      	bcs.n	108fbe <prvAddCurrentTaskToDelayedList+0x82>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  108f9a:	f649 4340 	movw	r3, #40000	; 0x9c40
  108f9e:	f2c0 0311 	movt	r3, #17
  108fa2:	6818      	ldr	r0, [r3, #0]
  108fa4:	6821      	ldr	r1, [r4, #0]
  108fa6:	3104      	adds	r1, #4
  108fa8:	f7ff fa30 	bl	10840c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
  108fac:	f649 730c 	movw	r3, #40716	; 0x9f0c
  108fb0:	f2c0 0311 	movt	r3, #17
  108fb4:	681a      	ldr	r2, [r3, #0]
  108fb6:	42aa      	cmp	r2, r5
				{
					xNextTaskUnblockTime = xTimeToWake;
  108fb8:	bf88      	it	hi
  108fba:	601d      	strhi	r5, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  108fbc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  108fbe:	f649 4344 	movw	r3, #40004	; 0x9c44
  108fc2:	f2c0 0311 	movt	r3, #17
  108fc6:	6818      	ldr	r0, [r3, #0]
  108fc8:	6821      	ldr	r1, [r4, #0]
}
  108fca:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  108fce:	3104      	adds	r1, #4
  108fd0:	f7ff ba1c 	b.w	10840c <vListInsert>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  108fd4:	6821      	ldr	r1, [r4, #0]
  108fd6:	f649 702c 	movw	r0, #40748	; 0x9f2c
  108fda:	f2c0 0011 	movt	r0, #17
  108fde:	3104      	adds	r1, #4
}
  108fe0:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  108fe4:	f7ff ba02 	b.w	1083ec <vListInsertEnd>

00108fe8 <prvResetNextTaskUnblockTime.part.0>:
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  108fe8:	f649 4240 	movw	r2, #40000	; 0x9c40
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  108fec:	f649 730c 	movw	r3, #40716	; 0x9f0c
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  108ff0:	f2c0 0211 	movt	r2, #17
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  108ff4:	f2c0 0311 	movt	r3, #17
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  108ff8:	6812      	ldr	r2, [r2, #0]
  108ffa:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  108ffc:	68d2      	ldr	r2, [r2, #12]
  108ffe:	6852      	ldr	r2, [r2, #4]
  109000:	601a      	str	r2, [r3, #0]
}
  109002:	4770      	bx	r14

00109004 <prvTaskIsTaskSuspended>:
	{
  109004:	b510      	push	{r4, r14}
		configASSERT( xTask );
  109006:	4604      	mov	r4, r0
  109008:	b1a8      	cbz	r0, 109036 <prvTaskIsTaskSuspended+0x32>
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  10900a:	6962      	ldr	r2, [r4, #20]
  10900c:	f649 732c 	movw	r3, #40748	; 0x9f2c
  109010:	f2c0 0311 	movt	r3, #17
  109014:	429a      	cmp	r2, r3
	BaseType_t xReturn = pdFALSE;
  109016:	bf18      	it	ne
  109018:	2200      	movne	r2, #0
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
  10901a:	d10a      	bne.n	109032 <prvTaskIsTaskSuspended+0x2e>
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
  10901c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  10901e:	f649 7014 	movw	r0, #40724	; 0x9f14
  109022:	f2c0 0011 	movt	r0, #17
	BaseType_t xReturn = pdFALSE;
  109026:	1a1a      	subs	r2, r3, r0
  109028:	bf18      	it	ne
  10902a:	2201      	movne	r2, #1
  10902c:	2b00      	cmp	r3, #0
  10902e:	bf18      	it	ne
  109030:	2200      	movne	r2, #0
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
  109032:	4610      	mov	r0, r2
  109034:	bd10      	pop	{r4, r15}
		configASSERT( xTask );
  109036:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  10903a:	f240 7111 	movw	r1, #1809	; 0x711
  10903e:	f2c0 0011 	movt	r0, #17
  109042:	f7ff f845 	bl	1080d0 <vMainAssertCalled>
  109046:	e7e0      	b.n	10900a <prvTaskIsTaskSuspended+0x6>

00109048 <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  109048:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  10904c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  10904e:	ea4f 0982 	mov.w	r9, r2, lsl #2
  109052:	464a      	mov	r2, r9
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  109054:	4607      	mov	r7, r0
  109056:	468a      	mov	r10, r1
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  109058:	21a5      	movs	r1, #165	; 0xa5
  10905a:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
  10905c:	4698      	mov	r8, r3
  10905e:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
  109062:	f001 ea10 	blx	10a484 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  109066:	6b23      	ldr	r3, [r4, #48]	; 0x30
  109068:	f1a9 0904 	sub.w	r9, r9, #4
  10906c:	4499      	add	r9, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  10906e:	f029 0907 	bic.w	r9, r9, #7
	if( pcName != NULL )
  109072:	f1ba 0f00 	cmp.w	r10, #0
  109076:	d038      	beq.n	1090ea <prvInitialiseNewTask.isra.2+0xa2>
  109078:	f10a 33ff 	add.w	r3, r10, #4294967295	; 0xffffffff
  10907c:	f10a 0113 	add.w	r1, r10, #19
  109080:	f104 0233 	add.w	r2, r4, #51	; 0x33
  109084:	e001      	b.n	10908a <prvInitialiseNewTask.isra.2+0x42>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  109086:	428b      	cmp	r3, r1
  109088:	d006      	beq.n	109098 <prvInitialiseNewTask.isra.2+0x50>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  10908a:	f813 0f01 	ldrb.w	r0, [r3, #1]!
  10908e:	f802 0f01 	strb.w	r0, [r2, #1]!
			if( pcName[ x ] == ( char ) 0x00 )
  109092:	7818      	ldrb	r0, [r3, #0]
  109094:	2800      	cmp	r0, #0
  109096:	d1f6      	bne.n	109086 <prvInitialiseNewTask.isra.2+0x3e>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  109098:	2300      	movs	r3, #0
  10909a:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
		pxNewTCB->uxMutexesHeld = 0;
  10909e:	f04f 0a00 	mov.w	r10, #0
  1090a2:	2d1f      	cmp	r5, #31
  1090a4:	bf28      	it	cs
  1090a6:	251f      	movcs	r5, #31
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  1090a8:	1d20      	adds	r0, r4, #4
	pxNewTCB->uxPriority = uxPriority;
  1090aa:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxMutexesHeld = 0;
  1090ac:	e9c4 5a14 	strd	r5, r10, [r4, #80]	; 0x50
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1090b0:	f1c5 0520 	rsb	r5, r5, #32
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  1090b4:	f7ff f996 	bl	1083e4 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  1090b8:	f104 0018 	add.w	r0, r4, #24
  1090bc:	f7ff f992 	bl	1083e4 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
  1090c0:	f8c4 a05c 	str.w	r10, [r4, #92]	; 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  1090c4:	4642      	mov	r2, r8
  1090c6:	4639      	mov	r1, r7
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1090c8:	61a5      	str	r5, [r4, #24]
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  1090ca:	4648      	mov	r0, r9
		pxNewTCB->ulRunTimeCounter = 0UL;
  1090cc:	f8c4 a058 	str.w	r10, [r4, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  1090d0:	f884 a060 	strb.w	r10, [r4, #96]	; 0x60
		pxNewTCB->ucDelayAborted = pdFALSE;
  1090d4:	f884 a062 	strb.w	r10, [r4, #98]	; 0x62
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  1090d8:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  1090da:	6264      	str	r4, [r4, #36]	; 0x24
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  1090dc:	f7fe fe30 	bl	107d40 <pxPortInitialiseStack>
  1090e0:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
  1090e2:	b106      	cbz	r6, 1090e6 <prvInitialiseNewTask.isra.2+0x9e>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  1090e4:	6034      	str	r4, [r6, #0]
}
  1090e6:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  1090ea:	f884 a034 	strb.w	r10, [r4, #52]	; 0x34
  1090ee:	e7d6      	b.n	10909e <prvInitialiseNewTask.isra.2+0x56>

001090f0 <prvDeleteTCB>:
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
  1090f0:	f890 3061 	ldrb.w	r3, [r0, #97]	; 0x61
  1090f4:	b163      	cbz	r3, 109110 <prvDeleteTCB+0x20>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
  1090f6:	2b01      	cmp	r3, #1
  1090f8:	d014      	beq.n	109124 <prvDeleteTCB+0x34>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
  1090fa:	2b02      	cmp	r3, #2
  1090fc:	d007      	beq.n	10910e <prvDeleteTCB+0x1e>
  1090fe:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109102:	f640 7122 	movw	r1, #3874	; 0xf22
  109106:	f2c0 0011 	movt	r0, #17
  10910a:	f7fe bfe1 	b.w	1080d0 <vMainAssertCalled>
  10910e:	4770      	bx	r14
	{
  109110:	b510      	push	{r4, r14}
  109112:	4604      	mov	r4, r0
				vPortFree( pxTCB->pxStack );
  109114:	6b00      	ldr	r0, [r0, #48]	; 0x30
  109116:	f7ff f909 	bl	10832c <vPortFree>
				vPortFree( pxTCB );
  10911a:	4620      	mov	r0, r4
	}
  10911c:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
				vPortFree( pxTCB );
  109120:	f7ff b904 	b.w	10832c <vPortFree>
				vPortFree( pxTCB );
  109124:	f7ff b902 	b.w	10832c <vPortFree>

00109128 <prvIdleTask>:
{
  109128:	f649 64d0 	movw	r4, #40656	; 0x9ed0
  10912c:	f649 7640 	movw	r6, #40768	; 0x9f40
  109130:	f649 65cc 	movw	r5, #40652	; 0x9ecc
  109134:	f649 4848 	movw	r8, #40008	; 0x9c48
  109138:	b580      	push	{r7, r14}
  10913a:	f2c0 0411 	movt	r4, #17
  10913e:	f2c0 0611 	movt	r6, #17
  109142:	f2c0 0511 	movt	r5, #17
  109146:	f2c0 0811 	movt	r8, #17
  10914a:	e011      	b.n	109170 <prvIdleTask+0x48>
			taskENTER_CRITICAL();
  10914c:	f7fe fec6 	bl	107edc <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109150:	68f3      	ldr	r3, [r6, #12]
  109152:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  109154:	1d38      	adds	r0, r7, #4
  109156:	f7ff f973 	bl	108440 <uxListRemove>
				--uxCurrentNumberOfTasks;
  10915a:	682b      	ldr	r3, [r5, #0]
  10915c:	3b01      	subs	r3, #1
  10915e:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
  109160:	6823      	ldr	r3, [r4, #0]
  109162:	3b01      	subs	r3, #1
  109164:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
  109166:	f7fe fef3 	bl	107f50 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
  10916a:	4638      	mov	r0, r7
  10916c:	f7ff ffc0 	bl	1090f0 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  109170:	6823      	ldr	r3, [r4, #0]
  109172:	2b00      	cmp	r3, #0
  109174:	d1ea      	bne.n	10914c <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  109176:	f8d8 3000 	ldr.w	r3, [r8]
  10917a:	2b01      	cmp	r3, #1
  10917c:	d900      	bls.n	109180 <prvIdleTask+0x58>
				taskYIELD();
  10917e:	df00      	svc	0
			vApplicationIdleHook();
  109180:	f7fe ff92 	bl	1080a8 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
  109184:	e7f4      	b.n	109170 <prvIdleTask+0x48>
  109186:	bf00      	nop

00109188 <vTaskSwitchContext.part.6>:
void vTaskSwitchContext( void )
  109188:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
		xYieldPending = pdFALSE;
  10918a:	f649 7358 	movw	r3, #40792	; 0x9f58
  10918e:	2200      	movs	r2, #0
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  109190:	f649 473c 	movw	r7, #39996	; 0x9c3c
		xYieldPending = pdFALSE;
  109194:	f2c0 0311 	movt	r3, #17
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  109198:	f2c0 0711 	movt	r7, #17
		xYieldPending = pdFALSE;
  10919c:	601a      	str	r2, [r3, #0]
		traceTASK_SWITCHED_OUT();
  10919e:	f7fe ff93 	bl	1080c8 <traceTASK_SWITCHED_OUT_HOOK>
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
  1091a2:	f7fe ffa1 	bl	1080e8 <vPortGetCurrentTimeMs>
			if( ulTotalRunTime > ulTaskSwitchedInTime )
  1091a6:	f649 63c8 	movw	r3, #40648	; 0x9ec8
  1091aa:	f2c0 0311 	movt	r3, #17
  1091ae:	6819      	ldr	r1, [r3, #0]
			ulTaskSwitchedInTime = ulTotalRunTime;
  1091b0:	6018      	str	r0, [r3, #0]
			if( ulTotalRunTime > ulTaskSwitchedInTime )
  1091b2:	4288      	cmp	r0, r1
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
  1091b4:	bf81      	itttt	hi
  1091b6:	683c      	ldrhi	r4, [r7, #0]
  1091b8:	6da2      	ldrhi	r2, [r4, #88]	; 0x58
  1091ba:	1a52      	subhi	r2, r2, r1
  1091bc:	1812      	addhi	r2, r2, r0
  1091be:	bf88      	it	hi
  1091c0:	65a2      	strhi	r2, [r4, #88]	; 0x58
		taskCHECK_FOR_STACK_OVERFLOW();
  1091c2:	683a      	ldr	r2, [r7, #0]
  1091c4:	6b13      	ldr	r3, [r2, #48]	; 0x30
  1091c6:	681a      	ldr	r2, [r3, #0]
  1091c8:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  1091cc:	d103      	bne.n	1091d6 <vTaskSwitchContext.part.6+0x4e>
  1091ce:	685a      	ldr	r2, [r3, #4]
  1091d0:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  1091d4:	d031      	beq.n	10923a <vTaskSwitchContext.part.6+0xb2>
  1091d6:	6838      	ldr	r0, [r7, #0]
  1091d8:	6839      	ldr	r1, [r7, #0]
  1091da:	3134      	adds	r1, #52	; 0x34
  1091dc:	f7fe ff6a 	bl	1080b4 <vApplicationStackOverflowHook>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  1091e0:	f649 63e0 	movw	r3, #40672	; 0x9ee0
  1091e4:	f649 4548 	movw	r5, #40008	; 0x9c48
  1091e8:	f2c0 0311 	movt	r3, #17
  1091ec:	f2c0 0511 	movt	r5, #17
  1091f0:	681c      	ldr	r4, [r3, #0]
  1091f2:	fab4 f484 	clz	r4, r4
  1091f6:	f1c4 061f 	rsb	r6, r4, #31
  1091fa:	00b4      	lsls	r4, r6, #2
  1091fc:	19a3      	adds	r3, r4, r6
  1091fe:	009b      	lsls	r3, r3, #2
  109200:	58eb      	ldr	r3, [r5, r3]
  109202:	b18b      	cbz	r3, 109228 <vTaskSwitchContext.part.6+0xa0>
  109204:	4434      	add	r4, r6
  109206:	00a4      	lsls	r4, r4, #2
  109208:	192a      	adds	r2, r5, r4
  10920a:	3408      	adds	r4, #8
  10920c:	442c      	add	r4, r5
  10920e:	6853      	ldr	r3, [r2, #4]
  109210:	685b      	ldr	r3, [r3, #4]
  109212:	6053      	str	r3, [r2, #4]
  109214:	42a3      	cmp	r3, r4
  109216:	bf04      	itt	eq
  109218:	685b      	ldreq	r3, [r3, #4]
  10921a:	6053      	streq	r3, [r2, #4]
  10921c:	68db      	ldr	r3, [r3, #12]
  10921e:	603b      	str	r3, [r7, #0]
}
  109220:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
		traceTASK_SWITCHED_IN();
  109224:	f7fe bf52 	b.w	1080cc <traceTASK_SWITCHED_IN_HOOK>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109228:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  10922c:	f640 31bb 	movw	r1, #3003	; 0xbbb
  109230:	f2c0 0011 	movt	r0, #17
  109234:	f7fe ff4c 	bl	1080d0 <vMainAssertCalled>
  109238:	e7e4      	b.n	109204 <vTaskSwitchContext.part.6+0x7c>
		taskCHECK_FOR_STACK_OVERFLOW();
  10923a:	689a      	ldr	r2, [r3, #8]
  10923c:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
  109240:	d1c9      	bne.n	1091d6 <vTaskSwitchContext.part.6+0x4e>
  109242:	68db      	ldr	r3, [r3, #12]
  109244:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
  109248:	d1c5      	bne.n	1091d6 <vTaskSwitchContext.part.6+0x4e>
  10924a:	e7c9      	b.n	1091e0 <vTaskSwitchContext.part.6+0x58>

0010924c <xTaskCreateStatic>:
	{
  10924c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  109250:	4606      	mov	r6, r0
  109252:	b087      	sub	sp, #28
  109254:	460f      	mov	r7, r1
  109256:	4690      	mov	r8, r2
  109258:	4699      	mov	r9, r3
  10925a:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  10925c:	9c10      	ldr	r4, [sp, #64]	; 0x40
		configASSERT( puxStackBuffer != NULL );
  10925e:	2d00      	cmp	r5, #0
  109260:	d033      	beq.n	1092ca <xTaskCreateStatic+0x7e>
		configASSERT( pxTaskBuffer != NULL );
  109262:	2c00      	cmp	r4, #0
  109264:	d03b      	beq.n	1092de <xTaskCreateStatic+0x92>
			volatile size_t xSize = sizeof( StaticTask_t );
  109266:	2364      	movs	r3, #100	; 0x64
  109268:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
  10926a:	9904      	ldr	r1, [sp, #16]
  10926c:	4299      	cmp	r1, r3
  10926e:	d10a      	bne.n	109286 <xTaskCreateStatic+0x3a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
  109270:	9b04      	ldr	r3, [sp, #16]
		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
  109272:	1c28      	adds	r0, r5, #0
  109274:	bf18      	it	ne
  109276:	2001      	movne	r0, #1
  109278:	2c00      	cmp	r4, #0
  10927a:	bf08      	it	eq
  10927c:	2000      	moveq	r0, #0
  10927e:	b958      	cbnz	r0, 109298 <xTaskCreateStatic+0x4c>
	}
  109280:	b007      	add	sp, #28
  109282:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
			configASSERT( xSize == sizeof( TCB_t ) );
  109286:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  10928a:	f240 2157 	movw	r1, #599	; 0x257
  10928e:	f2c0 0011 	movt	r0, #17
  109292:	f7fe ff1d 	bl	1080d0 <vMainAssertCalled>
  109296:	e7eb      	b.n	109270 <xTaskCreateStatic+0x24>
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
  109298:	f04f 0e02 	mov.w	r14, #2
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  10929c:	f10d 0c14 	add.w	r12, r13, #20
  1092a0:	990e      	ldr	r1, [sp, #56]	; 0x38
  1092a2:	464b      	mov	r3, r9
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
  1092a4:	6325      	str	r5, [r4, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  1092a6:	4642      	mov	r2, r8
  1092a8:	9100      	str	r1, [sp, #0]
  1092aa:	4630      	mov	r0, r6
  1092ac:	9402      	str	r4, [sp, #8]
  1092ae:	4639      	mov	r1, r7
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
  1092b0:	f884 e061 	strb.w	r14, [r4, #97]	; 0x61
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  1092b4:	f8cd c004 	str.w	r12, [r13, #4]
  1092b8:	f7ff fec6 	bl	109048 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
  1092bc:	4620      	mov	r0, r4
  1092be:	f7ff fda5 	bl	108e0c <prvAddNewTaskToReadyList>
		return xReturn;
  1092c2:	9805      	ldr	r0, [sp, #20]
	}
  1092c4:	b007      	add	sp, #28
  1092c6:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
		configASSERT( puxStackBuffer != NULL );
  1092ca:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  1092ce:	f240 214e 	movw	r1, #590	; 0x24e
  1092d2:	f2c0 0011 	movt	r0, #17
  1092d6:	f7fe fefb 	bl	1080d0 <vMainAssertCalled>
		configASSERT( pxTaskBuffer != NULL );
  1092da:	2c00      	cmp	r4, #0
  1092dc:	d1c3      	bne.n	109266 <xTaskCreateStatic+0x1a>
  1092de:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  1092e2:	f240 214f 	movw	r1, #591	; 0x24f
  1092e6:	f2c0 0011 	movt	r0, #17
  1092ea:	f7fe fef1 	bl	1080d0 <vMainAssertCalled>
			volatile size_t xSize = sizeof( StaticTask_t );
  1092ee:	2364      	movs	r3, #100	; 0x64
  1092f0:	9304      	str	r3, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
  1092f2:	9b04      	ldr	r3, [sp, #16]
  1092f4:	2b64      	cmp	r3, #100	; 0x64
  1092f6:	d1c6      	bne.n	109286 <xTaskCreateStatic+0x3a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
  1092f8:	9b04      	ldr	r3, [sp, #16]
			xReturn = NULL;
  1092fa:	4620      	mov	r0, r4
  1092fc:	e7c0      	b.n	109280 <xTaskCreateStatic+0x34>
  1092fe:	bf00      	nop

00109300 <xTaskCreate>:
	{
  109300:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  109304:	4607      	mov	r7, r0
  109306:	b085      	sub	sp, #20
  109308:	4616      	mov	r6, r2
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  10930a:	0090      	lsls	r0, r2, #2
	{
  10930c:	4688      	mov	r8, r1
  10930e:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  109310:	f7ff f85a 	bl	1083c8 <pvPortMalloc>
			if( pxStack != NULL )
  109314:	b320      	cbz	r0, 109360 <xTaskCreate+0x60>
  109316:	4605      	mov	r5, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  109318:	2064      	movs	r0, #100	; 0x64
  10931a:	f7ff f855 	bl	1083c8 <pvPortMalloc>
				if( pxNewTCB != NULL )
  10931e:	4604      	mov	r4, r0
  109320:	b1b0      	cbz	r0, 109350 <xTaskCreate+0x50>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
  109322:	f04f 0c00 	mov.w	r12, #0
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  109326:	464b      	mov	r3, r9
					pxNewTCB->pxStack = pxStack;
  109328:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  10932a:	4632      	mov	r2, r6
  10932c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
  10932e:	4641      	mov	r1, r8
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
  109330:	f884 c061 	strb.w	r12, [r4, #97]	; 0x61
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  109334:	4638      	mov	r0, r7
  109336:	9501      	str	r5, [sp, #4]
  109338:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  10933a:	9402      	str	r4, [sp, #8]
  10933c:	9500      	str	r5, [sp, #0]
  10933e:	f7ff fe83 	bl	109048 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
  109342:	4620      	mov	r0, r4
  109344:	f7ff fd62 	bl	108e0c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  109348:	2001      	movs	r0, #1
	}
  10934a:	b005      	add	sp, #20
  10934c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
					vPortFree( pxStack );
  109350:	4628      	mov	r0, r5
  109352:	f7fe ffeb 	bl	10832c <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  109356:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}
  10935a:	b005      	add	sp, #20
  10935c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  109360:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return xReturn;
  109364:	e7f1      	b.n	10934a <xTaskCreate+0x4a>
  109366:	bf00      	nop

00109368 <vTaskDelete>:
	{
  109368:	b570      	push	{r4, r5, r6, r14}
  10936a:	4604      	mov	r4, r0
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  10936c:	f649 453c 	movw	r5, #39996	; 0x9c3c
		taskENTER_CRITICAL();
  109370:	f7fe fdb4 	bl	107edc <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  109374:	f2c0 0511 	movt	r5, #17
  109378:	2c00      	cmp	r4, #0
  10937a:	d060      	beq.n	10943e <vTaskDelete+0xd6>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  10937c:	1d26      	adds	r6, r4, #4
  10937e:	4630      	mov	r0, r6
  109380:	f7ff f85e 	bl	108440 <uxListRemove>
  109384:	b948      	cbnz	r0, 10939a <vTaskDelete+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  109386:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  109388:	f649 4248 	movw	r2, #40008	; 0x9c48
  10938c:	f2c0 0211 	movt	r2, #17
  109390:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  109394:	009b      	lsls	r3, r3, #2
  109396:	58d3      	ldr	r3, [r2, r3]
  109398:	b3a3      	cbz	r3, 109404 <vTaskDelete+0x9c>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  10939a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  10939c:	b11b      	cbz	r3, 1093a6 <vTaskDelete+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  10939e:	f104 0018 	add.w	r0, r4, #24
  1093a2:	f7ff f84d 	bl	108440 <uxListRemove>
			if( pxTCB == pxCurrentTCB )
  1093a6:	6829      	ldr	r1, [r5, #0]
			uxTaskNumber++;
  1093a8:	f649 63dc 	movw	r3, #40668	; 0x9edc
  1093ac:	f2c0 0311 	movt	r3, #17
			if( pxTCB == pxCurrentTCB )
  1093b0:	42a1      	cmp	r1, r4
			uxTaskNumber++;
  1093b2:	681a      	ldr	r2, [r3, #0]
  1093b4:	f102 0201 	add.w	r2, r2, #1
  1093b8:	601a      	str	r2, [r3, #0]
			if( pxTCB == pxCurrentTCB )
  1093ba:	d031      	beq.n	109420 <vTaskDelete+0xb8>
				--uxCurrentNumberOfTasks;
  1093bc:	f649 63cc 	movw	r3, #40652	; 0x9ecc
				prvDeleteTCB( pxTCB );
  1093c0:	4620      	mov	r0, r4
				--uxCurrentNumberOfTasks;
  1093c2:	f2c0 0311 	movt	r3, #17
  1093c6:	681a      	ldr	r2, [r3, #0]
  1093c8:	3a01      	subs	r2, #1
  1093ca:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
  1093cc:	f7ff fe90 	bl	1090f0 <prvDeleteTCB>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  1093d0:	f649 4340 	movw	r3, #40000	; 0x9c40
  1093d4:	f2c0 0311 	movt	r3, #17
  1093d8:	681b      	ldr	r3, [r3, #0]
  1093da:	681b      	ldr	r3, [r3, #0]
  1093dc:	b9eb      	cbnz	r3, 10941a <vTaskDelete+0xb2>
		xNextTaskUnblockTime = portMAX_DELAY;
  1093de:	f649 730c 	movw	r3, #40716	; 0x9f0c
  1093e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  1093e6:	f2c0 0311 	movt	r3, #17
  1093ea:	601a      	str	r2, [r3, #0]
		taskEXIT_CRITICAL();
  1093ec:	f7fe fdb0 	bl	107f50 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
  1093f0:	f649 7328 	movw	r3, #40744	; 0x9f28
  1093f4:	f2c0 0311 	movt	r3, #17
  1093f8:	681b      	ldr	r3, [r3, #0]
  1093fa:	b113      	cbz	r3, 109402 <vTaskDelete+0x9a>
			if( pxTCB == pxCurrentTCB )
  1093fc:	682b      	ldr	r3, [r5, #0]
  1093fe:	42a3      	cmp	r3, r4
  109400:	d01f      	beq.n	109442 <vTaskDelete+0xda>
	}
  109402:	bd70      	pop	{r4, r5, r6, r15}
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  109404:	f649 63e0 	movw	r3, #40672	; 0x9ee0
  109408:	2201      	movs	r2, #1
  10940a:	f2c0 0311 	movt	r3, #17
  10940e:	408a      	lsls	r2, r1
  109410:	6819      	ldr	r1, [r3, #0]
  109412:	ea21 0102 	bic.w	r1, r1, r2
  109416:	6019      	str	r1, [r3, #0]
  109418:	e7bf      	b.n	10939a <vTaskDelete+0x32>
  10941a:	f7ff fde5 	bl	108fe8 <prvResetNextTaskUnblockTime.part.0>
  10941e:	e7e5      	b.n	1093ec <vTaskDelete+0x84>
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
  109420:	f649 7040 	movw	r0, #40768	; 0x9f40
  109424:	4631      	mov	r1, r6
  109426:	f2c0 0011 	movt	r0, #17
  10942a:	f7fe ffdf 	bl	1083ec <vListInsertEnd>
				++uxDeletedTasksWaitingCleanUp;
  10942e:	f649 63d0 	movw	r3, #40656	; 0x9ed0
  109432:	f2c0 0311 	movt	r3, #17
  109436:	681a      	ldr	r2, [r3, #0]
  109438:	3201      	adds	r2, #1
  10943a:	601a      	str	r2, [r3, #0]
  10943c:	e7d6      	b.n	1093ec <vTaskDelete+0x84>
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
  10943e:	682c      	ldr	r4, [r5, #0]
  109440:	e79c      	b.n	10937c <vTaskDelete+0x14>
				configASSERT( uxSchedulerSuspended == 0 );
  109442:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  109446:	f2c0 0311 	movt	r3, #17
  10944a:	681b      	ldr	r3, [r3, #0]
  10944c:	b90b      	cbnz	r3, 109452 <vTaskDelete+0xea>
				portYIELD_WITHIN_API();
  10944e:	df00      	svc	0
	}
  109450:	bd70      	pop	{r4, r5, r6, r15}
				configASSERT( uxSchedulerSuspended == 0 );
  109452:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109456:	f240 41d5 	movw	r1, #1237	; 0x4d5
  10945a:	f2c0 0011 	movt	r0, #17
  10945e:	f7fe fe37 	bl	1080d0 <vMainAssertCalled>
  109462:	e7f4      	b.n	10944e <vTaskDelete+0xe6>

00109464 <vTaskPrioritySet>:
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  109464:	291f      	cmp	r1, #31
	{
  109466:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  10946a:	4604      	mov	r4, r0
  10946c:	bf98      	it	ls
  10946e:	460d      	movls	r5, r1
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  109470:	d850      	bhi.n	109514 <vTaskPrioritySet+0xb0>
		taskENTER_CRITICAL();
  109472:	f7fe fd33 	bl	107edc <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
  109476:	2c00      	cmp	r4, #0
  109478:	d059      	beq.n	10952e <vTaskPrioritySet+0xca>
				uxCurrentBasePriority = pxTCB->uxBasePriority;
  10947a:	6d23      	ldr	r3, [r4, #80]	; 0x50
			if( uxCurrentBasePriority != uxNewPriority )
  10947c:	429d      	cmp	r5, r3
  10947e:	d045      	beq.n	10950c <vTaskPrioritySet+0xa8>
					if( pxTCB != pxCurrentTCB )
  109480:	f649 423c 	movw	r2, #39996	; 0x9c3c
  109484:	f2c0 0211 	movt	r2, #17
				if( uxNewPriority > uxCurrentBasePriority )
  109488:	d90b      	bls.n	1094a2 <vTaskPrioritySet+0x3e>
					if( pxTCB != pxCurrentTCB )
  10948a:	6811      	ldr	r1, [r2, #0]
  10948c:	42a1      	cmp	r1, r4
	BaseType_t xYieldRequired = pdFALSE;
  10948e:	bf08      	it	eq
  109490:	2700      	moveq	r7, #0
					if( pxTCB != pxCurrentTCB )
  109492:	d00b      	beq.n	1094ac <vTaskPrioritySet+0x48>
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
  109494:	6812      	ldr	r2, [r2, #0]
  109496:	6ad7      	ldr	r7, [r2, #44]	; 0x2c
  109498:	42af      	cmp	r7, r5
  10949a:	bf8c      	ite	hi
  10949c:	2700      	movhi	r7, #0
  10949e:	2701      	movls	r7, #1
  1094a0:	e004      	b.n	1094ac <vTaskPrioritySet+0x48>
				else if( pxTCB == pxCurrentTCB )
  1094a2:	6817      	ldr	r7, [r2, #0]
  1094a4:	1b3f      	subs	r7, r7, r4
  1094a6:	fab7 f787 	clz	r7, r7
  1094aa:	097f      	lsrs	r7, r7, #5
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
  1094ac:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
					pxTCB->uxBasePriority = uxNewPriority;
  1094ae:	6525      	str	r5, [r4, #80]	; 0x50
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1094b0:	6962      	ldr	r2, [r4, #20]
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
  1094b2:	42b3      	cmp	r3, r6
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  1094b4:	69a3      	ldr	r3, [r4, #24]
						pxTCB->uxPriority = uxNewPriority;
  1094b6:	bf08      	it	eq
  1094b8:	62e5      	streq	r5, [r4, #44]	; 0x2c
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  1094ba:	2b00      	cmp	r3, #0
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1094bc:	bfa8      	it	ge
  1094be:	f1c5 0520 	rsbge	r5, r5, #32
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1094c2:	eb06 0386 	add.w	r3, r6, r6, lsl #2
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1094c6:	bfa8      	it	ge
  1094c8:	61a5      	strge	r5, [r4, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  1094ca:	f649 4548 	movw	r5, #40008	; 0x9c48
  1094ce:	f2c0 0511 	movt	r5, #17
  1094d2:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  1094d6:	429a      	cmp	r2, r3
  1094d8:	d116      	bne.n	109508 <vTaskPrioritySet+0xa4>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1094da:	f104 0804 	add.w	r8, r4, #4
  1094de:	4640      	mov	r0, r8
  1094e0:	f7fe ffae 	bl	108440 <uxListRemove>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
  1094e4:	f649 62e0 	movw	r2, #40672	; 0x9ee0
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  1094e8:	b338      	cbz	r0, 10953a <vTaskPrioritySet+0xd6>
  1094ea:	f2c0 0211 	movt	r2, #17
					prvAddTaskToReadyList( pxTCB );
  1094ee:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  1094f0:	2301      	movs	r3, #1
  1094f2:	6814      	ldr	r4, [r2, #0]
  1094f4:	4641      	mov	r1, r8
  1094f6:	4083      	lsls	r3, r0
  1094f8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  1094fc:	4323      	orrs	r3, r4
  1094fe:	eb05 0080 	add.w	r0, r5, r0, lsl #2
  109502:	6013      	str	r3, [r2, #0]
  109504:	f7fe ff72 	bl	1083ec <vListInsertEnd>
				if( xYieldRequired != pdFALSE )
  109508:	b107      	cbz	r7, 10950c <vTaskPrioritySet+0xa8>
					taskYIELD_IF_USING_PREEMPTION();
  10950a:	df00      	svc	0
	}
  10950c:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
		taskEXIT_CRITICAL();
  109510:	f7fe bd1e 	b.w	107f50 <vPortExitCritical>
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  109514:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109518:	f240 6105 	movw	r1, #1541	; 0x605
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  10951c:	251f      	movs	r5, #31
		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
  10951e:	f2c0 0011 	movt	r0, #17
  109522:	f7fe fdd5 	bl	1080d0 <vMainAssertCalled>
		taskENTER_CRITICAL();
  109526:	f7fe fcd9 	bl	107edc <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTask );
  10952a:	2c00      	cmp	r4, #0
  10952c:	d1a5      	bne.n	10947a <vTaskPrioritySet+0x16>
  10952e:	f649 433c 	movw	r3, #39996	; 0x9c3c
  109532:	f2c0 0311 	movt	r3, #17
  109536:	681c      	ldr	r4, [r3, #0]
  109538:	e79f      	b.n	10947a <vTaskPrioritySet+0x16>
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
  10953a:	2301      	movs	r3, #1
  10953c:	f2c0 0211 	movt	r2, #17
  109540:	40b3      	lsls	r3, r6
  109542:	6816      	ldr	r6, [r2, #0]
  109544:	ea26 0603 	bic.w	r6, r6, r3
  109548:	6016      	str	r6, [r2, #0]
  10954a:	e7d0      	b.n	1094ee <vTaskPrioritySet+0x8a>

0010954c <vTaskSuspend>:
	{
  10954c:	b570      	push	{r4, r5, r6, r14}
  10954e:	4604      	mov	r4, r0
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  109550:	f649 453c 	movw	r5, #39996	; 0x9c3c
		taskENTER_CRITICAL();
  109554:	f7fe fcc2 	bl	107edc <vPortEnterCritical>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  109558:	f2c0 0511 	movt	r5, #17
  10955c:	2c00      	cmp	r4, #0
  10955e:	d05f      	beq.n	109620 <vTaskSuspend+0xd4>
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  109560:	1d26      	adds	r6, r4, #4
  109562:	4630      	mov	r0, r6
  109564:	f7fe ff6c 	bl	108440 <uxListRemove>
  109568:	b948      	cbnz	r0, 10957e <vTaskSuspend+0x32>
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  10956a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  10956c:	f649 4248 	movw	r2, #40008	; 0x9c48
  109570:	f2c0 0211 	movt	r2, #17
  109574:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  109578:	009b      	lsls	r3, r3, #2
  10957a:	58d3      	ldr	r3, [r2, r3]
  10957c:	b393      	cbz	r3, 1095e4 <vTaskSuspend+0x98>
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  10957e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  109580:	b11b      	cbz	r3, 10958a <vTaskSuspend+0x3e>
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  109582:	f104 0018 	add.w	r0, r4, #24
  109586:	f7fe ff5b 	bl	108440 <uxListRemove>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  10958a:	f649 702c 	movw	r0, #40748	; 0x9f2c
  10958e:	4631      	mov	r1, r6
		if( xSchedulerRunning != pdFALSE )
  109590:	f649 7628 	movw	r6, #40744	; 0x9f28
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
  109594:	f2c0 0011 	movt	r0, #17
  109598:	f7fe ff28 	bl	1083ec <vListInsertEnd>
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
  10959c:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
  1095a0:	2b01      	cmp	r3, #1
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  1095a2:	bf08      	it	eq
  1095a4:	2300      	moveq	r3, #0
		if( xSchedulerRunning != pdFALSE )
  1095a6:	f2c0 0611 	movt	r6, #17
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  1095aa:	bf08      	it	eq
  1095ac:	f884 3060 	strbeq.w	r3, [r4, #96]	; 0x60
		taskEXIT_CRITICAL();
  1095b0:	f7fe fcce 	bl	107f50 <vPortExitCritical>
		if( xSchedulerRunning != pdFALSE )
  1095b4:	6833      	ldr	r3, [r6, #0]
  1095b6:	bb03      	cbnz	r3, 1095fa <vTaskSuspend+0xae>
		if( pxTCB == pxCurrentTCB )
  1095b8:	682b      	ldr	r3, [r5, #0]
  1095ba:	42a3      	cmp	r3, r4
  1095bc:	d000      	beq.n	1095c0 <vTaskSuspend+0x74>
	}
  1095be:	bd70      	pop	{r4, r5, r6, r15}
			if( xSchedulerRunning != pdFALSE )
  1095c0:	6833      	ldr	r3, [r6, #0]
  1095c2:	b37b      	cbz	r3, 109624 <vTaskSuspend+0xd8>
				configASSERT( uxSchedulerSuspended == 0 );
  1095c4:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  1095c8:	f2c0 0311 	movt	r3, #17
  1095cc:	681b      	ldr	r3, [r3, #0]
  1095ce:	b13b      	cbz	r3, 1095e0 <vTaskSuspend+0x94>
  1095d0:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  1095d4:	f240 61e7 	movw	r1, #1767	; 0x6e7
  1095d8:	f2c0 0011 	movt	r0, #17
  1095dc:	f7fe fd78 	bl	1080d0 <vMainAssertCalled>
				portYIELD_WITHIN_API();
  1095e0:	df00      	svc	0
	}
  1095e2:	bd70      	pop	{r4, r5, r6, r15}
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  1095e4:	f649 63e0 	movw	r3, #40672	; 0x9ee0
  1095e8:	2201      	movs	r2, #1
  1095ea:	f2c0 0311 	movt	r3, #17
  1095ee:	408a      	lsls	r2, r1
  1095f0:	6819      	ldr	r1, [r3, #0]
  1095f2:	ea21 0102 	bic.w	r1, r1, r2
  1095f6:	6019      	str	r1, [r3, #0]
  1095f8:	e7c1      	b.n	10957e <vTaskSuspend+0x32>
			taskENTER_CRITICAL();
  1095fa:	f7fe fc6f 	bl	107edc <vPortEnterCritical>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  1095fe:	f649 4340 	movw	r3, #40000	; 0x9c40
  109602:	f2c0 0311 	movt	r3, #17
  109606:	681b      	ldr	r3, [r3, #0]
  109608:	681b      	ldr	r3, [r3, #0]
  10960a:	bb33      	cbnz	r3, 10965a <vTaskSuspend+0x10e>
		xNextTaskUnblockTime = portMAX_DELAY;
  10960c:	f649 730c 	movw	r3, #40716	; 0x9f0c
  109610:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  109614:	f2c0 0311 	movt	r3, #17
  109618:	601a      	str	r2, [r3, #0]
			taskEXIT_CRITICAL();
  10961a:	f7fe fc99 	bl	107f50 <vPortExitCritical>
  10961e:	e7cb      	b.n	1095b8 <vTaskSuspend+0x6c>
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
  109620:	682c      	ldr	r4, [r5, #0]
  109622:	e79d      	b.n	109560 <vTaskSuspend+0x14>
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  109624:	f649 712c 	movw	r1, #40748	; 0x9f2c
  109628:	f649 62cc 	movw	r2, #40652	; 0x9ecc
  10962c:	f2c0 0111 	movt	r1, #17
  109630:	f2c0 0211 	movt	r2, #17
  109634:	6809      	ldr	r1, [r1, #0]
  109636:	6812      	ldr	r2, [r2, #0]
  109638:	4291      	cmp	r1, r2
					pxCurrentTCB = NULL;
  10963a:	bf08      	it	eq
  10963c:	602b      	streq	r3, [r5, #0]
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
  10963e:	d0be      	beq.n	1095be <vTaskSuspend+0x72>
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  109640:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  109644:	f2c0 0311 	movt	r3, #17
  109648:	681b      	ldr	r3, [r3, #0]
  10964a:	b14b      	cbz	r3, 109660 <vTaskSuspend+0x114>
		xYieldPending = pdTRUE;
  10964c:	f649 7358 	movw	r3, #40792	; 0x9f58
  109650:	2201      	movs	r2, #1
  109652:	f2c0 0311 	movt	r3, #17
  109656:	601a      	str	r2, [r3, #0]
	}
  109658:	bd70      	pop	{r4, r5, r6, r15}
  10965a:	f7ff fcc5 	bl	108fe8 <prvResetNextTaskUnblockTime.part.0>
  10965e:	e7dc      	b.n	10961a <vTaskSuspend+0xce>
  109660:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
  109664:	f7ff bd90 	b.w	109188 <vTaskSwitchContext.part.6>

00109668 <vTaskResume>:
	{
  109668:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
		configASSERT( xTaskToResume );
  10966a:	b188      	cbz	r0, 109690 <vTaskResume+0x28>
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  10966c:	f649 453c 	movw	r5, #39996	; 0x9c3c
  109670:	4604      	mov	r4, r0
  109672:	f2c0 0511 	movt	r5, #17
  109676:	682b      	ldr	r3, [r5, #0]
  109678:	4298      	cmp	r0, r3
  10967a:	d016      	beq.n	1096aa <vTaskResume+0x42>
			taskENTER_CRITICAL();
  10967c:	f7fe fc2e 	bl	107edc <vPortEnterCritical>
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
  109680:	4620      	mov	r0, r4
  109682:	f7ff fcbf 	bl	109004 <prvTaskIsTaskSuspended>
  109686:	b988      	cbnz	r0, 1096ac <vTaskResume+0x44>
	}
  109688:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
			taskEXIT_CRITICAL();
  10968c:	f7fe bc60 	b.w	107f50 <vPortExitCritical>
		configASSERT( xTaskToResume );
  109690:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109694:	f240 713b 	movw	r1, #1851	; 0x73b
  109698:	f2c0 0011 	movt	r0, #17
  10969c:	f7fe fd18 	bl	1080d0 <vMainAssertCalled>
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
  1096a0:	f649 433c 	movw	r3, #39996	; 0x9c3c
  1096a4:	f2c0 0311 	movt	r3, #17
  1096a8:	681b      	ldr	r3, [r3, #0]
	}
  1096aa:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
					prvAddTaskToReadyList( pxTCB );
  1096ac:	f649 66e0 	movw	r6, #40672	; 0x9ee0
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  1096b0:	1d27      	adds	r7, r4, #4
  1096b2:	4638      	mov	r0, r7
					prvAddTaskToReadyList( pxTCB );
  1096b4:	f2c0 0611 	movt	r6, #17
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
  1096b8:	f7fe fec2 	bl	108440 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  1096bc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  1096be:	2301      	movs	r3, #1
  1096c0:	4639      	mov	r1, r7
  1096c2:	6837      	ldr	r7, [r6, #0]
  1096c4:	f649 4048 	movw	r0, #40008	; 0x9c48
  1096c8:	4093      	lsls	r3, r2
  1096ca:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  1096ce:	433b      	orrs	r3, r7
  1096d0:	f2c0 0011 	movt	r0, #17
  1096d4:	6033      	str	r3, [r6, #0]
  1096d6:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  1096da:	f7fe fe87 	bl	1083ec <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  1096de:	682b      	ldr	r3, [r5, #0]
  1096e0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  1096e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1096e4:	429a      	cmp	r2, r3
  1096e6:	d3cf      	bcc.n	109688 <vTaskResume+0x20>
						taskYIELD_IF_USING_PREEMPTION();
  1096e8:	df00      	svc	0
  1096ea:	e7cd      	b.n	109688 <vTaskResume+0x20>

001096ec <vTaskStartScheduler>:
{
  1096ec:	b530      	push	{r4, r5, r14}
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
  1096ee:	2400      	movs	r4, #0
{
  1096f0:	b089      	sub	sp, #36	; 0x24
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
  1096f2:	aa07      	add	r2, sp, #28
  1096f4:	a906      	add	r1, sp, #24
		StackType_t *pxIdleTaskStackBuffer = NULL;
  1096f6:	e9cd 4405 	strd	r4, r4, [r13, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
  1096fa:	a805      	add	r0, sp, #20
  1096fc:	f7fe fcc4 	bl	108088 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
  109700:	9d05      	ldr	r5, [sp, #20]
  109702:	f641 5118 	movw	r1, #7448	; 0x1d18
  109706:	f249 1029 	movw	r0, #37161	; 0x9129
  10970a:	9502      	str	r5, [sp, #8]
  10970c:	4623      	mov	r3, r4
  10970e:	9d06      	ldr	r5, [sp, #24]
  109710:	f2c0 0111 	movt	r1, #17
  109714:	9a07      	ldr	r2, [sp, #28]
  109716:	f2c0 0010 	movt	r0, #16
  10971a:	9400      	str	r4, [sp, #0]
  10971c:	9501      	str	r5, [sp, #4]
  10971e:	f7ff fd95 	bl	10924c <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
  109722:	b170      	cbz	r0, 109742 <vTaskStartScheduler+0x56>
			xReturn = xTimerCreateTimerTask();
  109724:	f000 fb88 	bl	109e38 <xTimerCreateTimerTask>
  109728:	4605      	mov	r5, r0
	if( xReturn == pdPASS )
  10972a:	2801      	cmp	r0, #1
  10972c:	d00b      	beq.n	109746 <vTaskStartScheduler+0x5a>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  10972e:	1c45      	adds	r5, r0, #1
  109730:	d107      	bne.n	109742 <vTaskStartScheduler+0x56>
  109732:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109736:	f640 0123 	movw	r1, #2083	; 0x823
  10973a:	f2c0 0011 	movt	r0, #17
  10973e:	f7fe fcc7 	bl	1080d0 <vMainAssertCalled>
}
  109742:	b009      	add	sp, #36	; 0x24
  109744:	bd30      	pop	{r4, r5, r15}
		portDISABLE_INTERRUPTS();
  109746:	f7fe fc43 	bl	107fd0 <ulPortSetInterruptMask>
		xNextTaskUnblockTime = portMAX_DELAY;
  10974a:	f649 710c 	movw	r1, #40716	; 0x9f0c
		xSchedulerRunning = pdTRUE;
  10974e:	f649 7228 	movw	r2, #40744	; 0x9f28
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  109752:	f649 7354 	movw	r3, #40788	; 0x9f54
		xNextTaskUnblockTime = portMAX_DELAY;
  109756:	f2c0 0111 	movt	r1, #17
		xSchedulerRunning = pdTRUE;
  10975a:	f2c0 0211 	movt	r2, #17
		xNextTaskUnblockTime = portMAX_DELAY;
  10975e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  109762:	f2c0 0311 	movt	r3, #17
		xNextTaskUnblockTime = portMAX_DELAY;
  109766:	6008      	str	r0, [r1, #0]
		xSchedulerRunning = pdTRUE;
  109768:	6015      	str	r5, [r2, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10976a:	601c      	str	r4, [r3, #0]
		traceTASK_SWITCHED_IN();
  10976c:	f7fe fcae 	bl	1080cc <traceTASK_SWITCHED_IN_HOOK>
		if( xPortStartScheduler() != pdFALSE )
  109770:	f7fe fb30 	bl	107dd4 <xPortStartScheduler>
}
  109774:	b009      	add	sp, #36	; 0x24
  109776:	bd30      	pop	{r4, r5, r15}

00109778 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
  109778:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  10977c:	f2c0 0311 	movt	r3, #17
  109780:	681a      	ldr	r2, [r3, #0]
  109782:	3201      	adds	r2, #1
  109784:	601a      	str	r2, [r3, #0]
}
  109786:	4770      	bx	r14

00109788 <xTaskGetTickCount>:
{
  109788:	b510      	push	{r4, r14}
	portTICK_TYPE_ENTER_CRITICAL();
  10978a:	f7fe fba7 	bl	107edc <vPortEnterCritical>
		xTicks = xTickCount;
  10978e:	f649 7354 	movw	r3, #40788	; 0x9f54
  109792:	f2c0 0311 	movt	r3, #17
  109796:	681c      	ldr	r4, [r3, #0]
	portTICK_TYPE_EXIT_CRITICAL();
  109798:	f7fe fbda 	bl	107f50 <vPortExitCritical>
}
  10979c:	4620      	mov	r0, r4
  10979e:	bd10      	pop	{r4, r15}

001097a0 <xTaskIncrementTick>:
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  1097a0:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  1097a4:	f2c0 0311 	movt	r3, #17
{
  1097a8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  1097ac:	681b      	ldr	r3, [r3, #0]
{
  1097ae:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  1097b0:	2b00      	cmp	r3, #0
  1097b2:	f040 80a4 	bne.w	1098fe <xTaskIncrementTick+0x15e>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  1097b6:	f649 7354 	movw	r3, #40788	; 0x9f54
  1097ba:	f2c0 0311 	movt	r3, #17
  1097be:	681e      	ldr	r6, [r3, #0]
  1097c0:	3601      	adds	r6, #1
		xTickCount = xConstTickCount;
  1097c2:	601e      	str	r6, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  1097c4:	b37e      	cbz	r6, 109826 <xTaskIncrementTick+0x86>
  1097c6:	f649 730c 	movw	r3, #40716	; 0x9f0c
  1097ca:	f2c0 0311 	movt	r3, #17
  1097ce:	9301      	str	r3, [sp, #4]
		if( xConstTickCount >= xNextTaskUnblockTime )
  1097d0:	9b01      	ldr	r3, [sp, #4]
  1097d2:	681b      	ldr	r3, [r3, #0]
  1097d4:	42b3      	cmp	r3, r6
  1097d6:	d94d      	bls.n	109874 <xTaskIncrementTick+0xd4>
  1097d8:	f649 4848 	movw	r8, #40008	; 0x9c48
  1097dc:	f649 493c 	movw	r9, #39996	; 0x9c3c
  1097e0:	f2c0 0811 	movt	r8, #17
BaseType_t xSwitchRequired = pdFALSE;
  1097e4:	2500      	movs	r5, #0
  1097e6:	f2c0 0911 	movt	r9, #17
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  1097ea:	f8d9 3000 	ldr.w	r3, [r9]
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  1097ee:	f649 62d4 	movw	r2, #40660	; 0x9ed4
  1097f2:	f2c0 0211 	movt	r2, #17
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  1097f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1097f8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  1097fc:	009b      	lsls	r3, r3, #2
  1097fe:	f858 1003 	ldr.w	r1, [r8, r3]
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  109802:	6813      	ldr	r3, [r2, #0]
				xSwitchRequired = pdTRUE;
  109804:	2902      	cmp	r1, #2
  109806:	bf28      	it	cs
  109808:	2501      	movcs	r5, #1
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  10980a:	2b00      	cmp	r3, #0
  10980c:	d07f      	beq.n	10990e <xTaskIncrementTick+0x16e>
		if( xYieldPending != pdFALSE )
  10980e:	f649 7358 	movw	r3, #40792	; 0x9f58
  109812:	f2c0 0311 	movt	r3, #17
  109816:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
  109818:	2b00      	cmp	r3, #0
}
  10981a:	bf0c      	ite	eq
  10981c:	4628      	moveq	r0, r5
  10981e:	2001      	movne	r0, #1
  109820:	b003      	add	sp, #12
  109822:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
			taskSWITCH_DELAYED_LISTS();
  109826:	f649 4440 	movw	r4, #40000	; 0x9c40
  10982a:	f2c0 0411 	movt	r4, #17
  10982e:	6823      	ldr	r3, [r4, #0]
  109830:	681b      	ldr	r3, [r3, #0]
  109832:	2b00      	cmp	r3, #0
  109834:	d174      	bne.n	109920 <xTaskIncrementTick+0x180>
  109836:	f649 4244 	movw	r2, #40004	; 0x9c44
  10983a:	f649 7310 	movw	r3, #40720	; 0x9f10
  10983e:	f2c0 0211 	movt	r2, #17
  109842:	6821      	ldr	r1, [r4, #0]
  109844:	f2c0 0311 	movt	r3, #17
  109848:	6810      	ldr	r0, [r2, #0]
  10984a:	6020      	str	r0, [r4, #0]
  10984c:	6011      	str	r1, [r2, #0]
  10984e:	681a      	ldr	r2, [r3, #0]
  109850:	3201      	adds	r2, #1
  109852:	601a      	str	r2, [r3, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  109854:	6823      	ldr	r3, [r4, #0]
  109856:	681b      	ldr	r3, [r3, #0]
  109858:	2b00      	cmp	r3, #0
  10985a:	d15e      	bne.n	10991a <xTaskIncrementTick+0x17a>
		xNextTaskUnblockTime = portMAX_DELAY;
  10985c:	f649 720c 	movw	r2, #40716	; 0x9f0c
  109860:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  109864:	f2c0 0211 	movt	r2, #17
  109868:	9201      	str	r2, [sp, #4]
  10986a:	6013      	str	r3, [r2, #0]
		if( xConstTickCount >= xNextTaskUnblockTime )
  10986c:	9b01      	ldr	r3, [sp, #4]
  10986e:	681b      	ldr	r3, [r3, #0]
  109870:	42b3      	cmp	r3, r6
  109872:	d8b1      	bhi.n	1097d8 <xTaskIncrementTick+0x38>
  109874:	f649 4440 	movw	r4, #40000	; 0x9c40
  109878:	f649 4848 	movw	r8, #40008	; 0x9c48
  10987c:	f649 493c 	movw	r9, #39996	; 0x9c3c
					prvAddTaskToReadyList( pxTCB );
  109880:	f649 67e0 	movw	r7, #40672	; 0x9ee0
  109884:	f2c0 0411 	movt	r4, #17
  109888:	f2c0 0811 	movt	r8, #17
  10988c:	f2c0 0911 	movt	r9, #17
BaseType_t xSwitchRequired = pdFALSE;
  109890:	2500      	movs	r5, #0
					prvAddTaskToReadyList( pxTCB );
  109892:	f2c0 0711 	movt	r7, #17
  109896:	e029      	b.n	1098ec <xTaskIncrementTick+0x14c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109898:	6823      	ldr	r3, [r4, #0]
  10989a:	68db      	ldr	r3, [r3, #12]
  10989c:	f8d3 b00c 	ldr.w	r11, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  1098a0:	f10b 0a04 	add.w	r10, r11, #4
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  1098a4:	f8db 2004 	ldr.w	r2, [r11, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  1098a8:	4650      	mov	r0, r10
					if( xConstTickCount < xItemValue )
  1098aa:	4296      	cmp	r6, r2
  1098ac:	d332      	bcc.n	109914 <xTaskIncrementTick+0x174>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  1098ae:	f7fe fdc7 	bl	108440 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  1098b2:	f8db 2028 	ldr.w	r2, [r11, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  1098b6:	f10b 0018 	add.w	r0, r11, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  1098ba:	b10a      	cbz	r2, 1098c0 <xTaskIncrementTick+0x120>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  1098bc:	f7fe fdc0 	bl	108440 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  1098c0:	f8db 002c 	ldr.w	r0, [r11, #44]	; 0x2c
  1098c4:	2201      	movs	r2, #1
  1098c6:	683b      	ldr	r3, [r7, #0]
  1098c8:	4651      	mov	r1, r10
  1098ca:	4082      	lsls	r2, r0
  1098cc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  1098d0:	431a      	orrs	r2, r3
  1098d2:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  1098d6:	603a      	str	r2, [r7, #0]
  1098d8:	f7fe fd88 	bl	1083ec <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  1098dc:	f8d9 1000 	ldr.w	r1, [r9]
  1098e0:	f8db 202c 	ldr.w	r2, [r11, #44]	; 0x2c
  1098e4:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
  1098e6:	429a      	cmp	r2, r3
  1098e8:	bf28      	it	cs
  1098ea:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  1098ec:	6823      	ldr	r3, [r4, #0]
  1098ee:	681b      	ldr	r3, [r3, #0]
  1098f0:	2b00      	cmp	r3, #0
  1098f2:	d1d1      	bne.n	109898 <xTaskIncrementTick+0xf8>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  1098f4:	9a01      	ldr	r2, [sp, #4]
  1098f6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  1098fa:	6013      	str	r3, [r2, #0]
					break;
  1098fc:	e775      	b.n	1097ea <xTaskIncrementTick+0x4a>
		++uxPendedTicks;
  1098fe:	f649 63d4 	movw	r3, #40660	; 0x9ed4
BaseType_t xSwitchRequired = pdFALSE;
  109902:	2500      	movs	r5, #0
		++uxPendedTicks;
  109904:	f2c0 0311 	movt	r3, #17
  109908:	681a      	ldr	r2, [r3, #0]
  10990a:	3201      	adds	r2, #1
  10990c:	601a      	str	r2, [r3, #0]
			vApplicationTickHook();
  10990e:	f7fe fbcd 	bl	1080ac <vApplicationTickHook>
  109912:	e77c      	b.n	10980e <xTaskIncrementTick+0x6e>
						xNextTaskUnblockTime = xItemValue;
  109914:	9b01      	ldr	r3, [sp, #4]
  109916:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  109918:	e767      	b.n	1097ea <xTaskIncrementTick+0x4a>
  10991a:	f7ff fb65 	bl	108fe8 <prvResetNextTaskUnblockTime.part.0>
  10991e:	e752      	b.n	1097c6 <xTaskIncrementTick+0x26>
			taskSWITCH_DELAYED_LISTS();
  109920:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109924:	f640 2182 	movw	r1, #2690	; 0xa82
  109928:	f2c0 0011 	movt	r0, #17
  10992c:	f7fe fbd0 	bl	1080d0 <vMainAssertCalled>
  109930:	e781      	b.n	109836 <xTaskIncrementTick+0x96>
  109932:	bf00      	nop

00109934 <xTaskResumeAll>:
{
  109934:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
	configASSERT( uxSchedulerSuspended );
  109938:	f649 64d8 	movw	r4, #40664	; 0x9ed8
  10993c:	f2c0 0411 	movt	r4, #17
  109940:	6823      	ldr	r3, [r4, #0]
  109942:	2b00      	cmp	r3, #0
  109944:	d076      	beq.n	109a34 <xTaskResumeAll+0x100>
	taskENTER_CRITICAL();
  109946:	f7fe fac9 	bl	107edc <vPortEnterCritical>
		--uxSchedulerSuspended;
  10994a:	6823      	ldr	r3, [r4, #0]
  10994c:	3b01      	subs	r3, #1
  10994e:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  109950:	6824      	ldr	r4, [r4, #0]
  109952:	2c00      	cmp	r4, #0
  109954:	d168      	bne.n	109a28 <xTaskResumeAll+0xf4>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  109956:	f649 63cc 	movw	r3, #40652	; 0x9ecc
  10995a:	f2c0 0311 	movt	r3, #17
  10995e:	681b      	ldr	r3, [r3, #0]
  109960:	2b00      	cmp	r3, #0
  109962:	d061      	beq.n	109a28 <xTaskResumeAll+0xf4>
  109964:	f649 7958 	movw	r9, #40792	; 0x9f58
  109968:	f649 7b14 	movw	r11, #40724	; 0x9f14
					prvAddTaskToReadyList( pxTCB );
  10996c:	f649 66e0 	movw	r6, #40672	; 0x9ee0
  109970:	f649 4848 	movw	r8, #40008	; 0x9c48
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  109974:	f649 473c 	movw	r7, #39996	; 0x9c3c
  109978:	f2c0 0911 	movt	r9, #17
  10997c:	f2c0 0b11 	movt	r11, #17
					prvAddTaskToReadyList( pxTCB );
  109980:	f2c0 0611 	movt	r6, #17
  109984:	f2c0 0811 	movt	r8, #17
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  109988:	f2c0 0711 	movt	r7, #17
  10998c:	e01f      	b.n	1099ce <xTaskResumeAll+0x9a>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  10998e:	f8db 300c 	ldr.w	r3, [r11, #12]
  109992:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  109994:	f104 0a04 	add.w	r10, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  109998:	f104 0018 	add.w	r0, r4, #24
  10999c:	f7fe fd50 	bl	108440 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  1099a0:	4650      	mov	r0, r10
  1099a2:	f7fe fd4d 	bl	108440 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  1099a6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  1099a8:	6832      	ldr	r2, [r6, #0]
  1099aa:	4651      	mov	r1, r10
  1099ac:	fa05 f300 	lsl.w	r3, r5, r0
  1099b0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  1099b4:	4313      	orrs	r3, r2
  1099b6:	eb08 0080 	add.w	r0, r8, r0, lsl #2
  1099ba:	6033      	str	r3, [r6, #0]
  1099bc:	f7fe fd16 	bl	1083ec <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  1099c0:	683b      	ldr	r3, [r7, #0]
  1099c2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  1099c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  1099c6:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
  1099c8:	bf28      	it	cs
  1099ca:	f8c9 5000 	strcs.w	r5, [r9]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  1099ce:	f8db 3000 	ldr.w	r3, [r11]
					prvAddTaskToReadyList( pxTCB );
  1099d2:	2501      	movs	r5, #1
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  1099d4:	2b00      	cmp	r3, #0
  1099d6:	d1da      	bne.n	10998e <xTaskResumeAll+0x5a>
				if( pxTCB != NULL )
  1099d8:	b16c      	cbz	r4, 1099f6 <xTaskResumeAll+0xc2>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  1099da:	f649 4340 	movw	r3, #40000	; 0x9c40
  1099de:	f2c0 0311 	movt	r3, #17
  1099e2:	681b      	ldr	r3, [r3, #0]
  1099e4:	681b      	ldr	r3, [r3, #0]
  1099e6:	bb73      	cbnz	r3, 109a46 <xTaskResumeAll+0x112>
		xNextTaskUnblockTime = portMAX_DELAY;
  1099e8:	f649 730c 	movw	r3, #40716	; 0x9f0c
  1099ec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  1099f0:	f2c0 0311 	movt	r3, #17
  1099f4:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  1099f6:	f649 65d4 	movw	r5, #40660	; 0x9ed4
  1099fa:	f2c0 0511 	movt	r5, #17
  1099fe:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
  109a00:	b144      	cbz	r4, 109a14 <xTaskResumeAll+0xe0>
								xYieldPending = pdTRUE;
  109a02:	2601      	movs	r6, #1
							if( xTaskIncrementTick() != pdFALSE )
  109a04:	f7ff fecc 	bl	1097a0 <xTaskIncrementTick>
  109a08:	b108      	cbz	r0, 109a0e <xTaskResumeAll+0xda>
								xYieldPending = pdTRUE;
  109a0a:	f8c9 6000 	str.w	r6, [r9]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  109a0e:	3c01      	subs	r4, #1
  109a10:	d1f8      	bne.n	109a04 <xTaskResumeAll+0xd0>
						uxPendedTicks = 0;
  109a12:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
  109a14:	f8d9 3000 	ldr.w	r3, [r9]
  109a18:	b133      	cbz	r3, 109a28 <xTaskResumeAll+0xf4>
					taskYIELD_IF_USING_PREEMPTION();
  109a1a:	df00      	svc	0
						xAlreadyYielded = pdTRUE;
  109a1c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  109a1e:	f7fe fa97 	bl	107f50 <vPortExitCritical>
}
  109a22:	4620      	mov	r0, r4
  109a24:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
BaseType_t xAlreadyYielded = pdFALSE;
  109a28:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
  109a2a:	f7fe fa91 	bl	107f50 <vPortExitCritical>
}
  109a2e:	4620      	mov	r0, r4
  109a30:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
	configASSERT( uxSchedulerSuspended );
  109a34:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109a38:	f640 0188 	movw	r1, #2184	; 0x888
  109a3c:	f2c0 0011 	movt	r0, #17
  109a40:	f7fe fb46 	bl	1080d0 <vMainAssertCalled>
  109a44:	e77f      	b.n	109946 <xTaskResumeAll+0x12>
  109a46:	f7ff facf 	bl	108fe8 <prvResetNextTaskUnblockTime.part.0>
  109a4a:	e7d4      	b.n	1099f6 <xTaskResumeAll+0xc2>

00109a4c <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  109a4c:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  109a50:	f2c0 0311 	movt	r3, #17
  109a54:	681b      	ldr	r3, [r3, #0]
  109a56:	b133      	cbz	r3, 109a66 <vTaskSwitchContext+0x1a>
		xYieldPending = pdTRUE;
  109a58:	f649 7358 	movw	r3, #40792	; 0x9f58
  109a5c:	2201      	movs	r2, #1
  109a5e:	f2c0 0311 	movt	r3, #17
  109a62:	601a      	str	r2, [r3, #0]
}
  109a64:	4770      	bx	r14
  109a66:	f7ff bb8f 	b.w	109188 <vTaskSwitchContext.part.6>
  109a6a:	bf00      	nop

00109a6c <vTaskPlaceOnEventList>:
{
  109a6c:	b538      	push	{r3, r4, r5, r14}
  109a6e:	460d      	mov	r5, r1
	configASSERT( pxEventList );
  109a70:	4604      	mov	r4, r0
  109a72:	b170      	cbz	r0, 109a92 <vTaskPlaceOnEventList+0x26>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  109a74:	f649 433c 	movw	r3, #39996	; 0x9c3c
  109a78:	4620      	mov	r0, r4
  109a7a:	f2c0 0311 	movt	r3, #17
  109a7e:	6819      	ldr	r1, [r3, #0]
  109a80:	3118      	adds	r1, #24
  109a82:	f7fe fcc3 	bl	10840c <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  109a86:	4628      	mov	r0, r5
  109a88:	2101      	movs	r1, #1
}
  109a8a:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  109a8e:	f7ff ba55 	b.w	108f3c <prvAddCurrentTaskToDelayedList>
	configASSERT( pxEventList );
  109a92:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109a96:	f640 31d2 	movw	r1, #3026	; 0xbd2
  109a9a:	f2c0 0011 	movt	r0, #17
  109a9e:	f7fe fb17 	bl	1080d0 <vMainAssertCalled>
  109aa2:	e7e7      	b.n	109a74 <vTaskPlaceOnEventList+0x8>

00109aa4 <vTaskPlaceOnEventListRestricted>:
	{
  109aa4:	b570      	push	{r4, r5, r6, r14}
  109aa6:	460e      	mov	r6, r1
  109aa8:	4614      	mov	r4, r2
		configASSERT( pxEventList );
  109aaa:	4605      	mov	r5, r0
  109aac:	b190      	cbz	r0, 109ad4 <vTaskPlaceOnEventListRestricted+0x30>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  109aae:	f649 433c 	movw	r3, #39996	; 0x9c3c
  109ab2:	4628      	mov	r0, r5
  109ab4:	f2c0 0311 	movt	r3, #17
  109ab8:	6819      	ldr	r1, [r3, #0]
  109aba:	3118      	adds	r1, #24
  109abc:	f7fe fc96 	bl	1083ec <vListInsertEnd>
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  109ac0:	4621      	mov	r1, r4
		if( xWaitIndefinitely != pdFALSE )
  109ac2:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  109ac4:	bf0c      	ite	eq
  109ac6:	4630      	moveq	r0, r6
  109ac8:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
	}
  109acc:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
  109ad0:	f7ff ba34 	b.w	108f3c <prvAddCurrentTaskToDelayedList>
		configASSERT( pxEventList );
  109ad4:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109ad8:	f640 31fd 	movw	r1, #3069	; 0xbfd
  109adc:	f2c0 0011 	movt	r0, #17
  109ae0:	f7fe faf6 	bl	1080d0 <vMainAssertCalled>
  109ae4:	e7e3      	b.n	109aae <vTaskPlaceOnEventListRestricted+0xa>
  109ae6:	bf00      	nop

00109ae8 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109ae8:	68c3      	ldr	r3, [r0, #12]
{
  109aea:	b570      	push	{r4, r5, r6, r14}
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109aec:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
  109aee:	2c00      	cmp	r4, #0
  109af0:	d03e      	beq.n	109b70 <xTaskRemoveFromEventList+0x88>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  109af2:	f104 0518 	add.w	r5, r4, #24
  109af6:	4628      	mov	r0, r5
  109af8:	f7fe fca2 	bl	108440 <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  109afc:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  109b00:	f2c0 0311 	movt	r3, #17
  109b04:	681b      	ldr	r3, [r3, #0]
  109b06:	bb5b      	cbnz	r3, 109b60 <xTaskRemoveFromEventList+0x78>
		prvAddTaskToReadyList( pxUnblockedTCB );
  109b08:	f649 65e0 	movw	r5, #40672	; 0x9ee0
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  109b0c:	1d26      	adds	r6, r4, #4
  109b0e:	4630      	mov	r0, r6
		prvAddTaskToReadyList( pxUnblockedTCB );
  109b10:	f2c0 0511 	movt	r5, #17
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  109b14:	f7fe fc94 	bl	108440 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  109b18:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  109b1a:	2301      	movs	r3, #1
  109b1c:	4631      	mov	r1, r6
  109b1e:	682e      	ldr	r6, [r5, #0]
  109b20:	f649 4048 	movw	r0, #40008	; 0x9c48
  109b24:	4093      	lsls	r3, r2
  109b26:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  109b2a:	f2c0 0011 	movt	r0, #17
  109b2e:	4333      	orrs	r3, r6
  109b30:	eb00 0082 	add.w	r0, r0, r2, lsl #2
  109b34:	602b      	str	r3, [r5, #0]
  109b36:	f7fe fc59 	bl	1083ec <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  109b3a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  109b3c:	f649 433c 	movw	r3, #39996	; 0x9c3c
  109b40:	f2c0 0311 	movt	r3, #17
  109b44:	681b      	ldr	r3, [r3, #0]
  109b46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  109b48:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
  109b4a:	bf81      	itttt	hi
  109b4c:	f649 7358 	movwhi	r3, #40792	; 0x9f58
  109b50:	2201      	movhi	r2, #1
		xReturn = pdTRUE;
  109b52:	4610      	movhi	r0, r2
		xYieldPending = pdTRUE;
  109b54:	f2c0 0311 	movthi	r3, #17
		xReturn = pdFALSE;
  109b58:	bf94      	ite	ls
  109b5a:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
  109b5c:	601a      	strhi	r2, [r3, #0]
}
  109b5e:	bd70      	pop	{r4, r5, r6, r15}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  109b60:	f649 7014 	movw	r0, #40724	; 0x9f14
  109b64:	4629      	mov	r1, r5
  109b66:	f2c0 0011 	movt	r0, #17
  109b6a:	f7fe fc3f 	bl	1083ec <vListInsertEnd>
  109b6e:	e7e4      	b.n	109b3a <xTaskRemoveFromEventList+0x52>
	configASSERT( pxUnblockedTCB );
  109b70:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109b74:	f640 412d 	movw	r1, #3117	; 0xc2d
  109b78:	f2c0 0011 	movt	r0, #17
  109b7c:	f7fe faa8 	bl	1080d0 <vMainAssertCalled>
  109b80:	e7b7      	b.n	109af2 <xTaskRemoveFromEventList+0xa>
  109b82:	bf00      	nop

00109b84 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  109b84:	f649 7210 	movw	r2, #40720	; 0x9f10
	pxTimeOut->xTimeOnEntering = xTickCount;
  109b88:	f649 7354 	movw	r3, #40788	; 0x9f54
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  109b8c:	f2c0 0211 	movt	r2, #17
	pxTimeOut->xTimeOnEntering = xTickCount;
  109b90:	f2c0 0311 	movt	r3, #17
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  109b94:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  109b96:	681b      	ldr	r3, [r3, #0]
  109b98:	e9c0 2300 	strd	r2, r3, [r0]
}
  109b9c:	4770      	bx	r14
  109b9e:	bf00      	nop

00109ba0 <xTaskCheckForTimeOut>:
{
  109ba0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  109ba2:	460e      	mov	r6, r1
	configASSERT( pxTimeOut );
  109ba4:	4605      	mov	r5, r0
  109ba6:	2800      	cmp	r0, #0
  109ba8:	d03d      	beq.n	109c26 <xTaskCheckForTimeOut+0x86>
	configASSERT( pxTicksToWait );
  109baa:	2e00      	cmp	r6, #0
  109bac:	d045      	beq.n	109c3a <xTaskCheckForTimeOut+0x9a>
	taskENTER_CRITICAL();
  109bae:	f7fe f995 	bl	107edc <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
  109bb2:	f649 7754 	movw	r7, #40788	; 0x9f54
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  109bb6:	f649 433c 	movw	r3, #39996	; 0x9c3c
		const TickType_t xConstTickCount = xTickCount;
  109bba:	f2c0 0711 	movt	r7, #17
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  109bbe:	f2c0 0311 	movt	r3, #17
		const TickType_t xConstTickCount = xTickCount;
  109bc2:	683a      	ldr	r2, [r7, #0]
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
  109bc4:	6819      	ldr	r1, [r3, #0]
  109bc6:	f891 4062 	ldrb.w	r4, [r1, #98]	; 0x62
  109bca:	bb1c      	cbnz	r4, 109c14 <xTaskCheckForTimeOut+0x74>
			if( *pxTicksToWait == portMAX_DELAY )
  109bcc:	6833      	ldr	r3, [r6, #0]
  109bce:	1c59      	adds	r1, r3, #1
  109bd0:	d01c      	beq.n	109c0c <xTaskCheckForTimeOut+0x6c>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  109bd2:	6828      	ldr	r0, [r5, #0]
  109bd4:	f649 7110 	movw	r1, #40720	; 0x9f10
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  109bd8:	686c      	ldr	r4, [r5, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  109bda:	f2c0 0111 	movt	r1, #17
  109bde:	f8d1 c000 	ldr.w	r12, [r1]
  109be2:	ebb0 000c 	subs.w	r0, r0, r12
  109be6:	bf18      	it	ne
  109be8:	2001      	movne	r0, #1
  109bea:	4294      	cmp	r4, r2
  109bec:	bf88      	it	hi
  109bee:	2000      	movhi	r0, #0
  109bf0:	bb60      	cbnz	r0, 109c4c <xTaskCheckForTimeOut+0xac>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  109bf2:	1b12      	subs	r2, r2, r4
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  109bf4:	4293      	cmp	r3, r2
			xReturn = pdFALSE;
  109bf6:	bf87      	ittee	hi
  109bf8:	4604      	movhi	r4, r0
			*pxTicksToWait -= xElapsedTime;
  109bfa:	1a9a      	subhi	r2, r3, r2
			*pxTicksToWait = 0;
  109bfc:	6030      	strls	r0, [r6, #0]
			xReturn = pdTRUE;
  109bfe:	2401      	movls	r4, #1
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  109c00:	bf81      	itttt	hi
  109c02:	6809      	ldrhi	r1, [r1, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  109c04:	683b      	ldrhi	r3, [r7, #0]
			*pxTicksToWait -= xElapsedTime;
  109c06:	6032      	strhi	r2, [r6, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  109c08:	e9c5 1300 	strdhi	r1, r3, [r5]
	taskEXIT_CRITICAL();
  109c0c:	f7fe f9a0 	bl	107f50 <vPortExitCritical>
}
  109c10:	4620      	mov	r0, r4
  109c12:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
				pxCurrentTCB->ucDelayAborted = pdFALSE;
  109c14:	2200      	movs	r2, #0
				xReturn = pdTRUE;
  109c16:	2401      	movs	r4, #1
				pxCurrentTCB->ucDelayAborted = pdFALSE;
  109c18:	681b      	ldr	r3, [r3, #0]
  109c1a:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	taskEXIT_CRITICAL();
  109c1e:	f7fe f997 	bl	107f50 <vPortExitCritical>
}
  109c22:	4620      	mov	r0, r4
  109c24:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
	configASSERT( pxTimeOut );
  109c26:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109c2a:	f640 4198 	movw	r1, #3224	; 0xc98
  109c2e:	f2c0 0011 	movt	r0, #17
  109c32:	f7fe fa4d 	bl	1080d0 <vMainAssertCalled>
	configASSERT( pxTicksToWait );
  109c36:	2e00      	cmp	r6, #0
  109c38:	d1b9      	bne.n	109bae <xTaskCheckForTimeOut+0xe>
  109c3a:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109c3e:	f640 4199 	movw	r1, #3225	; 0xc99
  109c42:	f2c0 0011 	movt	r0, #17
  109c46:	f7fe fa43 	bl	1080d0 <vMainAssertCalled>
  109c4a:	e7b0      	b.n	109bae <xTaskCheckForTimeOut+0xe>
			xReturn = pdTRUE;
  109c4c:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
  109c4e:	f7fe f97f 	bl	107f50 <vPortExitCritical>
}
  109c52:	4620      	mov	r0, r4
  109c54:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  109c56:	bf00      	nop

00109c58 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
  109c58:	f649 7358 	movw	r3, #40792	; 0x9f58
  109c5c:	2201      	movs	r2, #1
  109c5e:	f2c0 0311 	movt	r3, #17
  109c62:	601a      	str	r2, [r3, #0]
}
  109c64:	4770      	bx	r14
  109c66:	bf00      	nop

00109c68 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
  109c68:	f649 7328 	movw	r3, #40744	; 0x9f28
  109c6c:	f2c0 0311 	movt	r3, #17
  109c70:	681b      	ldr	r3, [r3, #0]
  109c72:	b14b      	cbz	r3, 109c88 <xTaskGetSchedulerState+0x20>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  109c74:	f649 63d8 	movw	r3, #40664	; 0x9ed8
  109c78:	f2c0 0311 	movt	r3, #17
  109c7c:	681b      	ldr	r3, [r3, #0]
  109c7e:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
  109c80:	bf0c      	ite	eq
  109c82:	2002      	moveq	r0, #2
  109c84:	2000      	movne	r0, #0
  109c86:	4770      	bx	r14
			xReturn = taskSCHEDULER_NOT_STARTED;
  109c88:	2001      	movs	r0, #1
	}
  109c8a:	4770      	bx	r14

00109c8c <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
  109c8c:	b348      	cbz	r0, 109ce2 <xTaskPriorityDisinherit+0x56>
	{
  109c8e:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
			configASSERT( pxTCB == pxCurrentTCB );
  109c90:	f649 433c 	movw	r3, #39996	; 0x9c3c
  109c94:	4604      	mov	r4, r0
  109c96:	f2c0 0311 	movt	r3, #17
  109c9a:	681b      	ldr	r3, [r3, #0]
  109c9c:	4283      	cmp	r3, r0
  109c9e:	d007      	beq.n	109cb0 <xTaskPriorityDisinherit+0x24>
  109ca0:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109ca4:	f640 71d5 	movw	r1, #4053	; 0xfd5
  109ca8:	f2c0 0011 	movt	r0, #17
  109cac:	f7fe fa10 	bl	1080d0 <vMainAssertCalled>
			configASSERT( pxTCB->uxMutexesHeld );
  109cb0:	6d63      	ldr	r3, [r4, #84]	; 0x54
  109cb2:	b163      	cbz	r3, 109cce <xTaskPriorityDisinherit+0x42>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  109cb4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
			( pxTCB->uxMutexesHeld )--;
  109cb6:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  109cb8:	6d21      	ldr	r1, [r4, #80]	; 0x50
			( pxTCB->uxMutexesHeld )--;
  109cba:	6563      	str	r3, [r4, #84]	; 0x54
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  109cbc:	1a42      	subs	r2, r0, r1
  109cbe:	bf18      	it	ne
  109cc0:	2201      	movne	r2, #1
  109cc2:	2b00      	cmp	r3, #0
  109cc4:	bf18      	it	ne
  109cc6:	2200      	movne	r2, #0
	BaseType_t xReturn = pdFALSE;
  109cc8:	2000      	movs	r0, #0
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  109cca:	b962      	cbnz	r2, 109ce6 <xTaskPriorityDisinherit+0x5a>
	}
  109ccc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
			configASSERT( pxTCB->uxMutexesHeld );
  109cce:	f641 40bc 	movw	r0, #7356	; 0x1cbc
  109cd2:	f640 71d6 	movw	r1, #4054	; 0xfd6
  109cd6:	f2c0 0011 	movt	r0, #17
  109cda:	f7fe f9f9 	bl	1080d0 <vMainAssertCalled>
  109cde:	6d63      	ldr	r3, [r4, #84]	; 0x54
  109ce0:	e7e8      	b.n	109cb4 <xTaskPriorityDisinherit+0x28>
	BaseType_t xReturn = pdFALSE;
  109ce2:	2000      	movs	r0, #0
	}
  109ce4:	4770      	bx	r14
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  109ce6:	1d27      	adds	r7, r4, #4
  109ce8:	4638      	mov	r0, r7
  109cea:	f7fe fba9 	bl	108440 <uxListRemove>
  109cee:	b1f0      	cbz	r0, 109d2e <xTaskPriorityDisinherit+0xa2>
  109cf0:	f649 4048 	movw	r0, #40008	; 0x9c48
  109cf4:	f649 62e0 	movw	r2, #40672	; 0x9ee0
  109cf8:	f2c0 0011 	movt	r0, #17
  109cfc:	f2c0 0211 	movt	r2, #17
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  109d00:	6d23      	ldr	r3, [r4, #80]	; 0x50
					prvAddTaskToReadyList( pxTCB );
  109d02:	2501      	movs	r5, #1
  109d04:	f8d2 e000 	ldr.w	r14, [r2]
  109d08:	4639      	mov	r1, r7
  109d0a:	fa05 f603 	lsl.w	r6, r5, r3
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  109d0e:	f1c3 0c20 	rsb	r12, r3, #32
					prvAddTaskToReadyList( pxTCB );
  109d12:	eb03 0783 	add.w	r7, r3, r3, lsl #2
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  109d16:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
  109d18:	ea46 060e 	orr.w	r6, r6, r14
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  109d1c:	f8c4 c018 	str.w	r12, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
  109d20:	eb00 0087 	add.w	r0, r0, r7, lsl #2
  109d24:	6016      	str	r6, [r2, #0]
  109d26:	f7fe fb61 	bl	1083ec <vListInsertEnd>
					xReturn = pdTRUE;
  109d2a:	4628      	mov	r0, r5
	}
  109d2c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  109d2e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  109d30:	f649 4048 	movw	r0, #40008	; 0x9c48
  109d34:	f649 62e0 	movw	r2, #40672	; 0x9ee0
  109d38:	f2c0 0011 	movt	r0, #17
  109d3c:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  109d40:	009b      	lsls	r3, r3, #2
  109d42:	58c3      	ldr	r3, [r0, r3]
  109d44:	b943      	cbnz	r3, 109d58 <xTaskPriorityDisinherit+0xcc>
  109d46:	2301      	movs	r3, #1
  109d48:	f2c0 0211 	movt	r2, #17
  109d4c:	408b      	lsls	r3, r1
  109d4e:	6811      	ldr	r1, [r2, #0]
  109d50:	ea21 0103 	bic.w	r1, r1, r3
  109d54:	6011      	str	r1, [r2, #0]
  109d56:	e7d3      	b.n	109d00 <xTaskPriorityDisinherit+0x74>
  109d58:	f2c0 0211 	movt	r2, #17
  109d5c:	e7d0      	b.n	109d00 <xTaskPriorityDisinherit+0x74>
  109d5e:	bf00      	nop

00109d60 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
  109d60:	b5f0      	push	{r4, r5, r6, r7, r14}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
  109d62:	f24a 0484 	movw	r4, #41092	; 0xa084
{
  109d66:	b083      	sub	sp, #12
		if( xTimerQueue == NULL )
  109d68:	f2c0 0411 	movt	r4, #17
	taskENTER_CRITICAL();
  109d6c:	f7fe f8b6 	bl	107edc <vPortEnterCritical>
		if( xTimerQueue == NULL )
  109d70:	6825      	ldr	r5, [r4, #0]
  109d72:	b125      	cbz	r5, 109d7e <prvCheckForValidListAndQueue+0x1e>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
  109d74:	b003      	add	sp, #12
  109d76:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
	taskEXIT_CRITICAL();
  109d7a:	f7fe b8e9 	b.w	107f50 <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
  109d7e:	f24a 0704 	movw	r7, #40964	; 0xa004
			vListInitialise( &xActiveTimerList2 );
  109d82:	f24a 0618 	movw	r6, #40984	; 0xa018
			vListInitialise( &xActiveTimerList1 );
  109d86:	f2c0 0711 	movt	r7, #17
  109d8a:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
  109d8c:	f2c0 0611 	movt	r6, #17
			vListInitialise( &xActiveTimerList1 );
  109d90:	f7fe fb1c 	bl	1083cc <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
  109d94:	4630      	mov	r0, r6
  109d96:	f7fe fb19 	bl	1083cc <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
  109d9a:	f649 725c 	movw	r2, #40796	; 0x9f5c
			pxOverflowTimerList = &xActiveTimerList2;
  109d9e:	f649 7c60 	movw	r12, #40800	; 0x9f60
			pxCurrentTimerList = &xActiveTimerList1;
  109da2:	f2c0 0211 	movt	r2, #17
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  109da6:	9500      	str	r5, [sp, #0]
			pxOverflowTimerList = &xActiveTimerList2;
  109da8:	f2c0 0c11 	movt	r12, #17
			pxCurrentTimerList = &xActiveTimerList1;
  109dac:	6017      	str	r7, [r2, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  109dae:	f24a 0330 	movw	r3, #41008	; 0xa030
  109db2:	f649 7264 	movw	r2, #40804	; 0x9f64
  109db6:	f2c0 0311 	movt	r3, #17
  109dba:	2110      	movs	r1, #16
  109dbc:	f2c0 0211 	movt	r2, #17
			pxOverflowTimerList = &xActiveTimerList2;
  109dc0:	f8cc 6000 	str.w	r6, [r12]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
  109dc4:	200a      	movs	r0, #10
  109dc6:	f7fe fc6f 	bl	1086a8 <xQueueGenericCreateStatic>
  109dca:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
  109dcc:	2800      	cmp	r0, #0
  109dce:	d0d1      	beq.n	109d74 <prvCheckForValidListAndQueue+0x14>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
  109dd0:	f641 5120 	movw	r1, #7456	; 0x1d20
  109dd4:	f2c0 0111 	movt	r1, #17
  109dd8:	f7fe ffde 	bl	108d98 <vQueueAddToRegistry>
}
  109ddc:	b003      	add	sp, #12
  109dde:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
	taskEXIT_CRITICAL();
  109de2:	f7fe b8b5 	b.w	107f50 <vPortExitCritical>
  109de6:	bf00      	nop

00109de8 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
  109de8:	4291      	cmp	r1, r2
{
  109dea:	b510      	push	{r4, r14}
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  109dec:	6100      	str	r0, [r0, #16]
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
  109dee:	6041      	str	r1, [r0, #4]
	if( xNextExpiryTime <= xTimeNow )
  109df0:	d805      	bhi.n	109dfe <prvInsertTimerInActiveList+0x16>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  109df2:	6981      	ldr	r1, [r0, #24]
  109df4:	1ad2      	subs	r2, r2, r3
  109df6:	428a      	cmp	r2, r1
  109df8:	d314      	bcc.n	109e24 <prvInsertTimerInActiveList+0x3c>
			xProcessTimerNow = pdTRUE;
  109dfa:	2001      	movs	r0, #1
}
  109dfc:	bd10      	pop	{r4, r15}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
  109dfe:	429a      	cmp	r2, r3
  109e00:	bf34      	ite	cc
  109e02:	2401      	movcc	r4, #1
  109e04:	2400      	movcs	r4, #0
  109e06:	4299      	cmp	r1, r3
  109e08:	bf38      	it	cc
  109e0a:	2400      	movcc	r4, #0
  109e0c:	2c00      	cmp	r4, #0
  109e0e:	d1f4      	bne.n	109dfa <prvInsertTimerInActiveList+0x12>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  109e10:	f649 735c 	movw	r3, #40796	; 0x9f5c
  109e14:	1d01      	adds	r1, r0, #4
  109e16:	f2c0 0311 	movt	r3, #17
  109e1a:	6818      	ldr	r0, [r3, #0]
  109e1c:	f7fe faf6 	bl	10840c <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
  109e20:	4620      	mov	r0, r4
}
  109e22:	bd10      	pop	{r4, r15}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
  109e24:	f649 7360 	movw	r3, #40800	; 0x9f60
  109e28:	1d01      	adds	r1, r0, #4
  109e2a:	f2c0 0311 	movt	r3, #17
  109e2e:	6818      	ldr	r0, [r3, #0]
  109e30:	f7fe faec 	bl	10840c <vListInsert>
  109e34:	2000      	movs	r0, #0
}
  109e36:	bd10      	pop	{r4, r15}

00109e38 <xTimerCreateTimerTask>:
{
  109e38:	b570      	push	{r4, r5, r6, r14}
  109e3a:	b088      	sub	sp, #32
	prvCheckForValidListAndQueue();
  109e3c:	f7ff ff90 	bl	109d60 <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
  109e40:	f24a 0384 	movw	r3, #41092	; 0xa084
  109e44:	f2c0 0311 	movt	r3, #17
  109e48:	681b      	ldr	r3, [r3, #0]
  109e4a:	b313      	cbz	r3, 109e92 <xTimerCreateTimerTask+0x5a>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
  109e4c:	2400      	movs	r4, #0
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  109e4e:	aa07      	add	r2, sp, #28
  109e50:	a906      	add	r1, sp, #24
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
  109e52:	261f      	movs	r6, #31
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  109e54:	a805      	add	r0, sp, #20
			StackType_t *pxTimerTaskStackBuffer = NULL;
  109e56:	e9cd 4405 	strd	r4, r4, [r13, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
  109e5a:	f7fe f905 	bl	108068 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
  109e5e:	4623      	mov	r3, r4
  109e60:	f641 5128 	movw	r1, #7464	; 0x1d28
  109e64:	9d05      	ldr	r5, [sp, #20]
  109e66:	f649 70a5 	movw	r0, #40869	; 0x9fa5
  109e6a:	9c06      	ldr	r4, [sp, #24]
  109e6c:	f2c0 0111 	movt	r1, #17
  109e70:	9a07      	ldr	r2, [sp, #28]
  109e72:	f2c0 0010 	movt	r0, #16
  109e76:	9600      	str	r6, [sp, #0]
  109e78:	9502      	str	r5, [sp, #8]
  109e7a:	9401      	str	r4, [sp, #4]
  109e7c:	f7ff f9e6 	bl	10924c <xTaskCreateStatic>
  109e80:	f24a 0388 	movw	r3, #41096	; 0xa088
  109e84:	f2c0 0311 	movt	r3, #17
  109e88:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
  109e8a:	b110      	cbz	r0, 109e92 <xTimerCreateTimerTask+0x5a>
				xReturn = pdPASS;
  109e8c:	2001      	movs	r0, #1
}
  109e8e:	b008      	add	sp, #32
  109e90:	bd70      	pop	{r4, r5, r6, r15}
	configASSERT( xReturn );
  109e92:	f641 5030 	movw	r0, #7472	; 0x1d30
  109e96:	f240 1113 	movw	r1, #275	; 0x113
  109e9a:	f2c0 0011 	movt	r0, #17
  109e9e:	f7fe f917 	bl	1080d0 <vMainAssertCalled>
  109ea2:	2000      	movs	r0, #0
}
  109ea4:	b008      	add	sp, #32
  109ea6:	bd70      	pop	{r4, r5, r6, r15}

00109ea8 <xTimerGenericCommand>:
{
  109ea8:	b570      	push	{r4, r5, r6, r14}
  109eaa:	460e      	mov	r6, r1
  109eac:	b086      	sub	sp, #24
	configASSERT( xTimer );
  109eae:	4605      	mov	r5, r0
  109eb0:	b310      	cbz	r0, 109ef8 <xTimerGenericCommand+0x50>
	if( xTimerQueue != NULL )
  109eb2:	f24a 0484 	movw	r4, #41092	; 0xa084
  109eb6:	f2c0 0411 	movt	r4, #17
  109eba:	6820      	ldr	r0, [r4, #0]
  109ebc:	b198      	cbz	r0, 109ee6 <xTimerGenericCommand+0x3e>
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
  109ebe:	e9cd 6202 	strd	r6, r2, [r13, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  109ec2:	2e05      	cmp	r6, #5
		xMessage.u.xTimerParameters.pxTimer = xTimer;
  109ec4:	9504      	str	r5, [sp, #16]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
  109ec6:	dc10      	bgt.n	109eea <xTimerGenericCommand+0x42>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
  109ec8:	f7ff fece 	bl	109c68 <xTaskGetSchedulerState>
  109ecc:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  109ece:	bf11      	iteee	ne
  109ed0:	2300      	movne	r3, #0
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  109ed2:	2300      	moveq	r3, #0
  109ed4:	a902      	addeq	r1, sp, #8
  109ed6:	6820      	ldreq	r0, [r4, #0]
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  109ed8:	bf17      	itett	ne
  109eda:	a902      	addne	r1, sp, #8
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
  109edc:	9a0a      	ldreq	r2, [sp, #40]	; 0x28
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
  109ede:	461a      	movne	r2, r3
  109ee0:	6820      	ldrne	r0, [r4, #0]
  109ee2:	f7fe fc7b 	bl	1087dc <xQueueGenericSend>
}
  109ee6:	b006      	add	sp, #24
  109ee8:	bd70      	pop	{r4, r5, r6, r15}
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
  109eea:	461a      	mov	r2, r3
  109eec:	a902      	add	r1, sp, #8
  109eee:	2300      	movs	r3, #0
  109ef0:	f7fe fd58 	bl	1089a4 <xQueueGenericSendFromISR>
}
  109ef4:	b006      	add	sp, #24
  109ef6:	bd70      	pop	{r4, r5, r6, r15}
	configASSERT( xTimer );
  109ef8:	f641 5030 	movw	r0, #7472	; 0x1d30
  109efc:	f44f 71c1 	mov.w	r1, #386	; 0x182
  109f00:	e9cd 2300 	strd	r2, r3, [r13]
  109f04:	f2c0 0011 	movt	r0, #17
  109f08:	f7fe f8e2 	bl	1080d0 <vMainAssertCalled>
  109f0c:	e9dd 2300 	ldrd	r2, r3, [r13]
  109f10:	e7cf      	b.n	109eb2 <xTimerGenericCommand+0xa>
  109f12:	bf00      	nop

00109f14 <prvSwitchTimerLists>:
{
  109f14:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  109f18:	f649 755c 	movw	r5, #40796	; 0x9f5c
				configASSERT( xResult );
  109f1c:	f641 5a30 	movw	r10, #7472	; 0x1d30
{
  109f20:	b082      	sub	sp, #8
  109f22:	f2c0 0511 	movt	r5, #17
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  109f26:	f04f 0800 	mov.w	r8, #0
				configASSERT( xResult );
  109f2a:	f2c0 0a11 	movt	r10, #17
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  109f2e:	e00e      	b.n	109f4e <prvSwitchTimerLists+0x3a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  109f30:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  109f32:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  109f34:	681e      	ldr	r6, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  109f36:	f104 0904 	add.w	r9, r4, #4
  109f3a:	4648      	mov	r0, r9
  109f3c:	f7fe fa80 	bl	108440 <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  109f40:	6a23      	ldr	r3, [r4, #32]
  109f42:	4620      	mov	r0, r4
  109f44:	4798      	blx	r3
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  109f46:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  109f4a:	075b      	lsls	r3, r3, #29
  109f4c:	d40d      	bmi.n	109f6a <prvSwitchTimerLists+0x56>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
  109f4e:	682b      	ldr	r3, [r5, #0]
  109f50:	681a      	ldr	r2, [r3, #0]
  109f52:	2a00      	cmp	r2, #0
  109f54:	d1ec      	bne.n	109f30 <prvSwitchTimerLists+0x1c>
	pxCurrentTimerList = pxOverflowTimerList;
  109f56:	f649 7260 	movw	r2, #40800	; 0x9f60
  109f5a:	f2c0 0211 	movt	r2, #17
  109f5e:	6811      	ldr	r1, [r2, #0]
  109f60:	6029      	str	r1, [r5, #0]
	pxOverflowTimerList = pxTemp;
  109f62:	6013      	str	r3, [r2, #0]
}
  109f64:	b002      	add	sp, #8
  109f66:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  109f6a:	69a7      	ldr	r7, [r4, #24]
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  109f6c:	2300      	movs	r3, #0
  109f6e:	4632      	mov	r2, r6
  109f70:	4619      	mov	r1, r3
  109f72:	4620      	mov	r0, r4
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
  109f74:	eb06 0c07 	add.w	r12, r6, r7
			if( xReloadTime > xNextExpireTime )
  109f78:	4566      	cmp	r6, r12
  109f7a:	d207      	bcs.n	109f8c <prvSwitchTimerLists+0x78>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
  109f7c:	f8c4 c004 	str.w	r12, [r4, #4]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  109f80:	4649      	mov	r1, r9
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
  109f82:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
  109f84:	6828      	ldr	r0, [r5, #0]
  109f86:	f7fe fa41 	bl	10840c <vListInsert>
  109f8a:	e7e0      	b.n	109f4e <prvSwitchTimerLists+0x3a>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  109f8c:	f8cd 8000 	str.w	r8, [r13]
  109f90:	f7ff ff8a 	bl	109ea8 <xTimerGenericCommand>
				configASSERT( xResult );
  109f94:	2800      	cmp	r0, #0
  109f96:	d1da      	bne.n	109f4e <prvSwitchTimerLists+0x3a>
  109f98:	f44f 7161 	mov.w	r1, #900	; 0x384
  109f9c:	4650      	mov	r0, r10
  109f9e:	f7fe f897 	bl	1080d0 <vMainAssertCalled>
  109fa2:	e7d4      	b.n	109f4e <prvSwitchTimerLists+0x3a>

00109fa4 <prvTimerTask>:
{
  109fa4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  109fa8:	f649 775c 	movw	r7, #40796	; 0x9f5c
  109fac:	f24a 062c 	movw	r6, #41004	; 0xa02c
  109fb0:	f24a 0584 	movw	r5, #41092	; 0xa084
  109fb4:	f649 7860 	movw	r8, #40800	; 0x9f60
			configASSERT( xResult );
  109fb8:	f641 5930 	movw	r9, #7472	; 0x1d30
{
  109fbc:	b087      	sub	sp, #28
  109fbe:	f2c0 0711 	movt	r7, #17
  109fc2:	f2c0 0611 	movt	r6, #17
  109fc6:	f2c0 0511 	movt	r5, #17
  109fca:	f2c0 0811 	movt	r8, #17
			configASSERT( xResult );
  109fce:	f2c0 0911 	movt	r9, #17
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
  109fd2:	683b      	ldr	r3, [r7, #0]
  109fd4:	681c      	ldr	r4, [r3, #0]
  109fd6:	2c00      	cmp	r4, #0
  109fd8:	f000 8091 	beq.w	10a0fe <prvTimerTask+0x15a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
  109fdc:	68db      	ldr	r3, [r3, #12]
  109fde:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
  109fe0:	f7ff fbca 	bl	109778 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
  109fe4:	f7ff fbd0 	bl	109788 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  109fe8:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  109fea:	4682      	mov	r10, r0
	if( xTimeNow < xLastTime )
  109fec:	4298      	cmp	r0, r3
  109fee:	f0c0 808e 	bcc.w	10a10e <prvTimerTask+0x16a>
	xLastTime = xTimeNow;
  109ff2:	6030      	str	r0, [r6, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
  109ff4:	4284      	cmp	r4, r0
  109ff6:	bf88      	it	hi
  109ff8:	2200      	movhi	r2, #0
  109ffa:	f240 809b 	bls.w	10a134 <prvTimerTask+0x190>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
  109ffe:	6828      	ldr	r0, [r5, #0]
  10a000:	eba4 010a 	sub.w	r1, r4, r10
  10a004:	f7fe fede 	bl	108dc4 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
  10a008:	f7ff fc94 	bl	109934 <xTaskResumeAll>
  10a00c:	b900      	cbnz	r0, 10a010 <prvTimerTask+0x6c>
					portYIELD_WITHIN_API();
  10a00e:	df00      	svc	0
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
  10a010:	2200      	movs	r2, #0
  10a012:	a902      	add	r1, sp, #8
  10a014:	6828      	ldr	r0, [r5, #0]
  10a016:	f7fe fd45 	bl	108aa4 <xQueueReceive>
  10a01a:	2800      	cmp	r0, #0
  10a01c:	d0d9      	beq.n	109fd2 <prvTimerTask+0x2e>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
  10a01e:	9b02      	ldr	r3, [sp, #8]
  10a020:	9c04      	ldr	r4, [sp, #16]
  10a022:	2b00      	cmp	r3, #0
  10a024:	da07      	bge.n	10a036 <prvTimerTask+0x92>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
  10a026:	9b03      	ldr	r3, [sp, #12]
  10a028:	4620      	mov	r0, r4
  10a02a:	9905      	ldr	r1, [sp, #20]
  10a02c:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
  10a02e:	9b02      	ldr	r3, [sp, #8]
  10a030:	2b00      	cmp	r3, #0
  10a032:	dbed      	blt.n	10a010 <prvTimerTask+0x6c>
  10a034:	9c04      	ldr	r4, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
  10a036:	6963      	ldr	r3, [r4, #20]
  10a038:	b113      	cbz	r3, 10a040 <prvTimerTask+0x9c>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  10a03a:	1d20      	adds	r0, r4, #4
  10a03c:	f7fe fa00 	bl	108440 <uxListRemove>
	xTimeNow = xTaskGetTickCount();
  10a040:	f7ff fba2 	bl	109788 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  10a044:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  10a046:	4683      	mov	r11, r0
	if( xTimeNow < xLastTime )
  10a048:	4298      	cmp	r0, r3
  10a04a:	d367      	bcc.n	10a11c <prvTimerTask+0x178>
			switch( xMessage.xMessageID )
  10a04c:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
  10a04e:	f8c6 b000 	str.w	r11, [r6]
			switch( xMessage.xMessageID )
  10a052:	2b09      	cmp	r3, #9
  10a054:	d8dc      	bhi.n	10a010 <prvTimerTask+0x6c>
  10a056:	e8df f003 	tbb	[r15, r3]
  10a05a:	2424      	.short	0x2424
  10a05c:	05124b24 	.word	0x05124b24
  10a060:	124b2424 	.word	0x124b2424
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
  10a064:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  10a068:	079a      	lsls	r2, r3, #30
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  10a06a:	bf44      	itt	mi
  10a06c:	f023 0301 	bicmi.w	r3, r3, #1
  10a070:	f884 3028 	strbmi.w	r3, [r4, #40]	; 0x28
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
  10a074:	d4cc      	bmi.n	10a010 <prvTimerTask+0x6c>
							vPortFree( pxTimer );
  10a076:	4620      	mov	r0, r4
  10a078:	f7fe f958 	bl	10832c <vPortFree>
  10a07c:	e7c8      	b.n	10a010 <prvTimerTask+0x6c>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  10a07e:	9903      	ldr	r1, [sp, #12]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  10a080:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
  10a084:	61a1      	str	r1, [r4, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  10a086:	f043 0301 	orr.w	r3, r3, #1
  10a08a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  10a08e:	2900      	cmp	r1, #0
  10a090:	f000 8081 	beq.w	10a196 <prvTimerTask+0x1f2>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
  10a094:	4620      	mov	r0, r4
  10a096:	4459      	add	r1, r11
  10a098:	465b      	mov	r3, r11
  10a09a:	465a      	mov	r2, r11
  10a09c:	f7ff fea4 	bl	109de8 <prvInsertTimerInActiveList>
  10a0a0:	e7b6      	b.n	10a010 <prvTimerTask+0x6c>
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  10a0a2:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  10a0a6:	9b03      	ldr	r3, [sp, #12]
  10a0a8:	69a1      	ldr	r1, [r4, #24]
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  10a0aa:	f040 0001 	orr.w	r0, r0, #1
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  10a0ae:	465a      	mov	r2, r11
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
  10a0b0:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
  10a0b4:	4419      	add	r1, r3
  10a0b6:	4620      	mov	r0, r4
  10a0b8:	f7ff fe96 	bl	109de8 <prvInsertTimerInActiveList>
  10a0bc:	2800      	cmp	r0, #0
  10a0be:	d0a7      	beq.n	10a010 <prvTimerTask+0x6c>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  10a0c0:	6a23      	ldr	r3, [r4, #32]
  10a0c2:	4620      	mov	r0, r4
  10a0c4:	4798      	blx	r3
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  10a0c6:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  10a0ca:	0759      	lsls	r1, r3, #29
  10a0cc:	d5a0      	bpl.n	10a010 <prvTimerTask+0x6c>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
  10a0ce:	69a2      	ldr	r2, [r4, #24]
  10a0d0:	2300      	movs	r3, #0
  10a0d2:	4620      	mov	r0, r4
  10a0d4:	4619      	mov	r1, r3
  10a0d6:	9c03      	ldr	r4, [sp, #12]
  10a0d8:	9300      	str	r3, [sp, #0]
  10a0da:	4422      	add	r2, r4
  10a0dc:	f7ff fee4 	bl	109ea8 <xTimerGenericCommand>
							configASSERT( xResult );
  10a0e0:	2800      	cmp	r0, #0
  10a0e2:	d195      	bne.n	10a010 <prvTimerTask+0x6c>
  10a0e4:	f240 3113 	movw	r1, #787	; 0x313
  10a0e8:	4648      	mov	r0, r9
  10a0ea:	f7fd fff1 	bl	1080d0 <vMainAssertCalled>
  10a0ee:	e78f      	b.n	10a010 <prvTimerTask+0x6c>
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  10a0f0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
  10a0f4:	f023 0301 	bic.w	r3, r3, #1
  10a0f8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  10a0fc:	e788      	b.n	10a010 <prvTimerTask+0x6c>
	vTaskSuspendAll();
  10a0fe:	f7ff fb3b 	bl	109778 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
  10a102:	f7ff fb41 	bl	109788 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
  10a106:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
  10a108:	4682      	mov	r10, r0
	if( xTimeNow < xLastTime )
  10a10a:	4298      	cmp	r0, r3
  10a10c:	d209      	bcs.n	10a122 <prvTimerTask+0x17e>
		prvSwitchTimerLists();
  10a10e:	f7ff ff01 	bl	109f14 <prvSwitchTimerLists>
	xLastTime = xTimeNow;
  10a112:	f8c6 a000 	str.w	r10, [r6]
			( void ) xTaskResumeAll();
  10a116:	f7ff fc0d 	bl	109934 <xTaskResumeAll>
  10a11a:	e779      	b.n	10a010 <prvTimerTask+0x6c>
		prvSwitchTimerLists();
  10a11c:	f7ff fefa 	bl	109f14 <prvSwitchTimerLists>
  10a120:	e794      	b.n	10a04c <prvTimerTask+0xa8>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  10a122:	f8d8 3000 	ldr.w	r3, [r8]
	xLastTime = xTimeNow;
  10a126:	f8c6 a000 	str.w	r10, [r6]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
  10a12a:	681a      	ldr	r2, [r3, #0]
  10a12c:	fab2 f282 	clz	r2, r2
  10a130:	0952      	lsrs	r2, r2, #5
  10a132:	e764      	b.n	109ffe <prvTimerTask+0x5a>
				( void ) xTaskResumeAll();
  10a134:	f7ff fbfe 	bl	109934 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  10a138:	683b      	ldr	r3, [r7, #0]
  10a13a:	68db      	ldr	r3, [r3, #12]
  10a13c:	f8d3 b00c 	ldr.w	r11, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
  10a140:	f10b 0004 	add.w	r0, r11, #4
  10a144:	f7fe f97c 	bl	108440 <uxListRemove>
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  10a148:	f89b 3028 	ldrb.w	r3, [r11, #40]	; 0x28
  10a14c:	0758      	lsls	r0, r3, #29
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
  10a14e:	bf5c      	itt	pl
  10a150:	f023 0301 	bicpl.w	r3, r3, #1
  10a154:	f88b 3028 	strbpl.w	r3, [r11, #40]	; 0x28
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
  10a158:	d404      	bmi.n	10a164 <prvTimerTask+0x1c0>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
  10a15a:	f8db 3020 	ldr.w	r3, [r11, #32]
  10a15e:	4658      	mov	r0, r11
  10a160:	4798      	blx	r3
  10a162:	e755      	b.n	10a010 <prvTimerTask+0x6c>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
  10a164:	f8db 1018 	ldr.w	r1, [r11, #24]
  10a168:	4652      	mov	r2, r10
  10a16a:	4623      	mov	r3, r4
  10a16c:	4658      	mov	r0, r11
  10a16e:	4421      	add	r1, r4
  10a170:	f7ff fe3a 	bl	109de8 <prvInsertTimerInActiveList>
  10a174:	2800      	cmp	r0, #0
  10a176:	d0f0      	beq.n	10a15a <prvTimerTask+0x1b6>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
  10a178:	2300      	movs	r3, #0
  10a17a:	4622      	mov	r2, r4
  10a17c:	4619      	mov	r1, r3
  10a17e:	4658      	mov	r0, r11
  10a180:	9300      	str	r3, [sp, #0]
  10a182:	f7ff fe91 	bl	109ea8 <xTimerGenericCommand>
			configASSERT( xResult );
  10a186:	2800      	cmp	r0, #0
  10a188:	d1e7      	bne.n	10a15a <prvTimerTask+0x1b6>
  10a18a:	f44f 71fc 	mov.w	r1, #504	; 0x1f8
  10a18e:	4648      	mov	r0, r9
  10a190:	f7fd ff9e 	bl	1080d0 <vMainAssertCalled>
  10a194:	e7e1      	b.n	10a15a <prvTimerTask+0x1b6>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
  10a196:	f240 312b 	movw	r1, #811	; 0x32b
  10a19a:	4648      	mov	r0, r9
  10a19c:	f7fd ff98 	bl	1080d0 <vMainAssertCalled>
  10a1a0:	69a1      	ldr	r1, [r4, #24]
  10a1a2:	e777      	b.n	10a094 <prvTimerTask+0xf0>

0010a1a4 <app_thread_entry>:
        }
    }
}

static int app_thread_entry(void *arg)
{
  10a1a4:	b508      	push	{r3, r14}
    const struct app_descriptor *app = (const struct app_descriptor *)arg;

    app->entry(app, NULL);
  10a1a6:	6883      	ldr	r3, [r0, #8]
  10a1a8:	2100      	movs	r1, #0
  10a1aa:	4798      	blx	r3

    return 0;
}
  10a1ac:	2000      	movs	r0, #0
  10a1ae:	bd08      	pop	{r3, r15}

0010a1b0 <apps_init>:
{
  10a1b0:	b5f0      	push	{r4, r5, r6, r7, r14}
    for (app = __apps_start; app != __apps_end; app++) {
  10a1b2:	f641 7308 	movw	r3, #7944	; 0x1f08
  10a1b6:	f641 751c 	movw	r5, #7964	; 0x1f1c
  10a1ba:	f2c0 0311 	movt	r3, #17
  10a1be:	f2c0 0511 	movt	r5, #17
  10a1c2:	42ab      	cmp	r3, r5
{
  10a1c4:	b083      	sub	sp, #12
    for (app = __apps_start; app != __apps_end; app++) {
  10a1c6:	d041      	beq.n	10a24c <apps_init+0x9c>
  10a1c8:	461c      	mov	r4, r3
  10a1ca:	f103 0214 	add.w	r2, r3, #20
  10a1ce:	1aaa      	subs	r2, r5, r2
  10a1d0:	f64c 45cd 	movw	r5, #52429	; 0xcccd
  10a1d4:	0892      	lsrs	r2, r2, #2
  10a1d6:	f6c0 45cc 	movt	r5, #3276	; 0xccc
  10a1da:	fb05 f502 	mul.w	r5, r5, r2
  10a1de:	f025 4540 	bic.w	r5, r5, #3221225472	; 0xc0000000
  10a1e2:	3501      	adds	r5, #1
  10a1e4:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  10a1e8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        if (app->init)
  10a1ec:	6863      	ldr	r3, [r4, #4]
            app->init(app);
  10a1ee:	4620      	mov	r0, r4
    for (app = __apps_start; app != __apps_end; app++) {
  10a1f0:	3414      	adds	r4, #20
        if (app->init)
  10a1f2:	b103      	cbz	r3, 10a1f6 <apps_init+0x46>
            app->init(app);
  10a1f4:	4798      	blx	r3
    for (app = __apps_start; app != __apps_end; app++) {
  10a1f6:	42ac      	cmp	r4, r5
  10a1f8:	d1f8      	bne.n	10a1ec <apps_init+0x3c>
    for (app = __apps_start; app != __apps_end; app++) {
  10a1fa:	f641 7508 	movw	r5, #7944	; 0x1f08
static void start_app(const struct app_descriptor *app)
{
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

    dprintf(INFO, "starting app %s\n", app->name);
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  10a1fe:	f24a 16a5 	movw	r6, #41381	; 0xa1a5
    for (app = __apps_start; app != __apps_end; app++) {
  10a202:	f2c0 0511 	movt	r5, #17
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  10a206:	f2c0 0610 	movt	r6, #16
  10a20a:	e002      	b.n	10a212 <apps_init+0x62>
    for (app = __apps_start; app != __apps_end; app++) {
  10a20c:	3514      	adds	r5, #20
  10a20e:	42a5      	cmp	r5, r4
  10a210:	d01c      	beq.n	10a24c <apps_init+0x9c>
        if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
  10a212:	68ab      	ldr	r3, [r5, #8]
  10a214:	2b00      	cmp	r3, #0
  10a216:	d0f9      	beq.n	10a20c <apps_init+0x5c>
  10a218:	68eb      	ldr	r3, [r5, #12]
  10a21a:	07da      	lsls	r2, r3, #31
  10a21c:	d4f6      	bmi.n	10a20c <apps_init+0x5c>
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  10a21e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  10a222:	f013 0f02 	tst.w	r3, #2
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  10a226:	6828      	ldr	r0, [r5, #0]
  10a228:	f04f 0310 	mov.w	r3, #16
  10a22c:	4631      	mov	r1, r6
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  10a22e:	bf18      	it	ne
  10a230:	692a      	ldrne	r2, [r5, #16]
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  10a232:	9200      	str	r2, [sp, #0]
  10a234:	462a      	mov	r2, r5
  10a236:	f001 f989 	bl	10b54c <thread_create>
    for (app = __apps_start; app != __apps_end; app++) {
  10a23a:	3514      	adds	r5, #20
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  10a23c:	4607      	mov	r7, r0
    thread_detach(t);
  10a23e:	f001 fa0b 	bl	10b658 <thread_detach>
    thread_resume(t);
  10a242:	4638      	mov	r0, r7
  10a244:	f001 f9de 	bl	10b604 <thread_resume>
    for (app = __apps_start; app != __apps_end; app++) {
  10a248:	42a5      	cmp	r5, r4
  10a24a:	d1e2      	bne.n	10a212 <apps_init+0x62>
}
  10a24c:	b003      	add	sp, #12
  10a24e:	bdf0      	pop	{r4, r5, r6, r7, r15}

0010a250 <spin>:
#include <platform.h>
#include <platform/debug.h>
#include <kernel/spinlock.h>

void spin(uint32_t usecs)
{
  10a250:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10a252:	4604      	mov	r4, r0
    lk_bigtime_t start = current_time_hires();
  10a254:	f7f6 fa0a 	bl	10066c <current_time_hires>
  10a258:	2500      	movs	r5, #0
  10a25a:	4606      	mov	r6, r0
  10a25c:	460f      	mov	r7, r1

    while ((current_time_hires() - start) < usecs)
  10a25e:	f7f6 fa05 	bl	10066c <current_time_hires>
  10a262:	1b82      	subs	r2, r0, r6
  10a264:	eb61 0307 	sbc.w	r3, r1, r7
  10a268:	42ab      	cmp	r3, r5
  10a26a:	bf08      	it	eq
  10a26c:	42a2      	cmpeq	r2, r4
  10a26e:	d3f6      	bcc.n	10a25e <spin+0xe>
        ;
}
  10a270:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  10a272:	bf00      	nop

0010a274 <_panic>:

void _panic(void *caller, const char *fmt, ...)
{
  10a274:	b40e      	push	{r1, r2, r3}
  10a276:	b500      	push	{r14}
    printf("panic (caller %p): ", caller);
  10a278:	4601      	mov	r1, r0
{
  10a27a:	b082      	sub	sp, #8
    printf("panic (caller %p): ", caller);
  10a27c:	f641 508c 	movw	r0, #7564	; 0x1d8c
{
  10a280:	ac03      	add	r4, sp, #12
    printf("panic (caller %p): ", caller);
  10a282:	f2c0 0011 	movt	r0, #17
{
  10a286:	f854 5b04 	ldr.w	r5, [r4], #4
    printf("panic (caller %p): ", caller);
  10a28a:	f001 f827 	bl	10b2dc <printf>

    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
  10a28e:	4621      	mov	r1, r4
  10a290:	4628      	mov	r0, r5
    va_start(ap, fmt);
  10a292:	9401      	str	r4, [sp, #4]
    vprintf(fmt, ap);
  10a294:	f001 f838 	bl	10b308 <_vprintf>
    va_end(ap);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  10a298:	2109      	movs	r1, #9
  10a29a:	2000      	movs	r0, #0
  10a29c:	f7f6 f952 	bl	100544 <platform_halt>

0010a2a0 <hexdump>:

    return &panic_fd;
}

void hexdump(const void *ptr, size_t len)
{
  10a2a0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10a2a4:	b089      	sub	sp, #36	; 0x24
    addr_t address = (addr_t)ptr;
    size_t count;

    for (count = 0 ; count < len; count += 16) {
  10a2a6:	9102      	str	r1, [sp, #8]
  10a2a8:	2900      	cmp	r1, #0
  10a2aa:	d05b      	beq.n	10a364 <hexdump+0xc4>
            uint8_t  cbuf[16];
        } u;
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
        size_t i;

        printf("0x%08lx: ", address);
  10a2ac:	f641 53a0 	movw	r3, #7584	; 0x1da0
        for (i = 0; i < s / 4; i++) {
            u.buf[i] = ((const uint32_t *)address)[i];
            printf("%08x ", u.buf[i]);
  10a2b0:	f641 59ac 	movw	r9, #7596	; 0x1dac
        }
        for (; i < 4; i++) {
            printf("         ");
  10a2b4:	f641 58b4 	movw	r8, #7604	; 0x1db4
        printf("0x%08lx: ", address);
  10a2b8:	f2c0 0311 	movt	r3, #17
  10a2bc:	4606      	mov	r6, r0
            printf("%08x ", u.buf[i]);
  10a2be:	f2c0 0911 	movt	r9, #17
        printf("0x%08lx: ", address);
  10a2c2:	9303      	str	r3, [sp, #12]
            printf("         ");
  10a2c4:	f2c0 0811 	movt	r8, #17
    for (count = 0 ; count < len; count += 16) {
  10a2c8:	2300      	movs	r3, #0
  10a2ca:	9301      	str	r3, [sp, #4]
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  10a2cc:	e9dd 2301 	ldrd	r2, r3, [r13, #4]
        printf("0x%08lx: ", address);
  10a2d0:	4631      	mov	r1, r6
  10a2d2:	9803      	ldr	r0, [sp, #12]
  10a2d4:	f10d 0a10 	add.w	r10, r13, #16
        for (i = 0; i < s / 4; i++) {
  10a2d8:	46b3      	mov	r11, r6
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  10a2da:	1a9c      	subs	r4, r3, r2
  10a2dc:	2c10      	cmp	r4, #16
  10a2de:	bf28      	it	cs
  10a2e0:	2410      	movcs	r4, #16
        printf("0x%08lx: ", address);
  10a2e2:	f000 fffb 	bl	10b2dc <printf>
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  10a2e6:	3403      	adds	r4, #3
  10a2e8:	f024 0503 	bic.w	r5, r4, #3
        for (i = 0; i < s / 4; i++) {
  10a2ec:	08a4      	lsrs	r4, r4, #2
  10a2ee:	eb06 0784 	add.w	r7, r6, r4, lsl #2
            u.buf[i] = ((const uint32_t *)address)[i];
  10a2f2:	f85b 3b04 	ldr.w	r3, [r11], #4
            printf("%08x ", u.buf[i]);
  10a2f6:	4648      	mov	r0, r9
            u.buf[i] = ((const uint32_t *)address)[i];
  10a2f8:	f84a 3b04 	str.w	r3, [r10], #4
            printf("%08x ", u.buf[i]);
  10a2fc:	4619      	mov	r1, r3
  10a2fe:	f000 ffed 	bl	10b2dc <printf>
        for (i = 0; i < s / 4; i++) {
  10a302:	455f      	cmp	r7, r11
  10a304:	d1f5      	bne.n	10a2f2 <hexdump+0x52>
        for (; i < 4; i++) {
  10a306:	2c04      	cmp	r4, #4
  10a308:	d005      	beq.n	10a316 <hexdump+0x76>
            printf("         ");
  10a30a:	4640      	mov	r0, r8
        for (; i < 4; i++) {
  10a30c:	3401      	adds	r4, #1
            printf("         ");
  10a30e:	f000 ffe5 	bl	10b2dc <printf>
        for (; i < 4; i++) {
  10a312:	2c04      	cmp	r4, #4
  10a314:	d1f9      	bne.n	10a30a <hexdump+0x6a>
        }
        printf("|");
  10a316:	207c      	movs	r0, #124	; 0x7c

        for (i=0; i < 16; i++) {
  10a318:	2400      	movs	r4, #0
        printf("|");
  10a31a:	f000 ffab 	bl	10b274 <putchar>
  10a31e:	e005      	b.n	10a32c <hexdump+0x8c>
            char c = u.cbuf[i];
            if (i < s && isprint(c)) {
                printf("%c", c);
            } else {
                printf(".");
  10a320:	202e      	movs	r0, #46	; 0x2e
        for (i=0; i < 16; i++) {
  10a322:	3401      	adds	r4, #1
                printf(".");
  10a324:	f000 ffa6 	bl	10b274 <putchar>
        for (i=0; i < 16; i++) {
  10a328:	2c10      	cmp	r4, #16
  10a32a:	d00e      	beq.n	10a34a <hexdump+0xaa>
            if (i < s && isprint(c)) {
  10a32c:	42a5      	cmp	r5, r4
  10a32e:	d9f7      	bls.n	10a320 <hexdump+0x80>
  10a330:	ab04      	add	r3, sp, #16
  10a332:	5d1f      	ldrb	r7, [r3, r4]
  10a334:	4638      	mov	r0, r7
  10a336:	f000 f8ef 	bl	10a518 <isprint>
  10a33a:	2800      	cmp	r0, #0
  10a33c:	d0f0      	beq.n	10a320 <hexdump+0x80>
                printf("%c", c);
  10a33e:	4638      	mov	r0, r7
        for (i=0; i < 16; i++) {
  10a340:	3401      	adds	r4, #1
                printf("%c", c);
  10a342:	f000 ff97 	bl	10b274 <putchar>
        for (i=0; i < 16; i++) {
  10a346:	2c10      	cmp	r4, #16
  10a348:	d1f0      	bne.n	10a32c <hexdump+0x8c>
    for (count = 0 ; count < len; count += 16) {
  10a34a:	9c01      	ldr	r4, [sp, #4]
            }
        }
        printf("|\n");
  10a34c:	f641 50c0 	movw	r0, #7616	; 0x1dc0
  10a350:	f2c0 0011 	movt	r0, #17
    for (count = 0 ; count < len; count += 16) {
  10a354:	3410      	adds	r4, #16
        address += 16;
  10a356:	3610      	adds	r6, #16
    for (count = 0 ; count < len; count += 16) {
  10a358:	9401      	str	r4, [sp, #4]
        printf("|\n");
  10a35a:	f000 ffa7 	bl	10b2ac <puts>
    for (count = 0 ; count < len; count += 16) {
  10a35e:	9b02      	ldr	r3, [sp, #8]
  10a360:	42a3      	cmp	r3, r4
  10a362:	d8b3      	bhi.n	10a2cc <hexdump+0x2c>
    }
}
  10a364:	b009      	add	sp, #36	; 0x24
  10a366:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10a36a:	bf00      	nop

0010a36c <bcopy>:
.align 2

/* void bcopy(const void *src, void *dest, size_t n); */
FUNCTION(bcopy)
    // swap args for bcopy
    mov     r12, r0
  10a36c:	e1a0c000 	mov	r12, r0
    mov     r0, r1
  10a370:	e1a00001 	mov	r0, r1
    mov     r1, r12
  10a374:	e1a0100c 	mov	r1, r12

0010a378 <memcpy>:

/* void *memcpy(void *dest, const void *src, size_t n); */
FUNCTION(memmove)
FUNCTION(memcpy)
    // check for zero length copy or the same pointer
    cmp     r2, #0
  10a378:	e3520000 	cmp	r2, #0
    cmpne   r1, r0
  10a37c:	11510000 	cmpne	r1, r0
    bxeq    lr
  10a380:	012fff1e 	bxeq	r14

    // save a few registers for use and the return code (input dst)
    stmfd   sp!, {r0, r4, r5, lr}
  10a384:	e92d4031 	push	{r0, r4, r5, r14}

    // check for forwards overlap (src > dst, distance < len)
    subs    r3, r0, r1
  10a388:	e0503001 	subs	r3, r0, r1
    cmphi   r2, r3
  10a38c:	81520003 	cmphi	r2, r3
    bhi     .L_forwardoverlap
  10a390:	8a000030 	bhi	10a458 <memcpy+0xe0>

    // check for a short copy len.
    // 20 bytes is enough so that if a 16 byte alignment needs to happen there is at least a 
    //   wordwise copy worth of work to be done.
    cmp     r2, #(16+4)
  10a394:	e3520014 	cmp	r2, #20
    blo     .L_bytewise
  10a398:	3a000019 	bcc	10a404 <memcpy+0x8c>

    // see if they are similarly aligned on 4 byte boundaries
    eor     r3, r0, r1
  10a39c:	e0203001 	eor	r3, r0, r1
    tst     r3, #3
  10a3a0:	e3130003 	tst	r3, #3
    bne     .L_bytewise     // dissimilarly aligned, nothing we can do (for now)
  10a3a4:	1a000016 	bne	10a404 <memcpy+0x8c>

    // check for 16 byte alignment on dst.
    // this will also catch src being not 4 byte aligned, since it is similarly 4 byte 
    //   aligned with dst at this point.
    tst     r0, #15
  10a3a8:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  10a3ac:	1a00001a 	bne	10a41c <memcpy+0xa4>

    // check to see if we have at least 32 bytes of data to copy.
    // if not, just revert to wordwise copy
    cmp     r2, #32
  10a3b0:	e3520020 	cmp	r2, #32
    blo     .L_wordwise
  10a3b4:	3a00000b 	bcc	10a3e8 <memcpy+0x70>
.L_bigcopy:
    // copy 32 bytes at a time. src & dst need to be at least 4 byte aligned, 
    // and we need at least 32 bytes remaining to copy

    // save r6-r7 for use in the big copy
    stmfd   sp!, {r6-r11}
  10a3b8:	e92d0fc0 	push	{r6, r7, r8, r9, r10, r11}

    sub     r2, r2, #32     // subtract an extra 32 to the len so we can avoid an extra compare
  10a3bc:	e2422020 	sub	r2, r2, #32

.L_bigcopy_loop:
    pld     [r1, #64]
  10a3c0:	f5d1f040 	pld	[r1, #64]	; 0x40
    ldmia   r1!, {r4-r11}
  10a3c4:	e8b10ff0 	ldm	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
    subs    r2, r2, #32
  10a3c8:	e2522020 	subs	r2, r2, #32
    stmia   r0!, {r4-r11}
  10a3cc:	e8a00ff0 	stmia	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
    bhs     .L_bigcopy_loop
  10a3d0:	2afffffa 	bcs	10a3c0 <memcpy+0x48>

    // restore r6-r7
    ldmfd   sp!, {r6-r11}
  10a3d4:	e8bd0fc0 	pop	{r6, r7, r8, r9, r10, r11}

    // see if we are done
    adds    r2, r2, #32
  10a3d8:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  10a3dc:	0a00000c 	beq	10a414 <memcpy+0x9c>

    // less then 4 bytes left?
    cmp     r2, #4
  10a3e0:	e3520004 	cmp	r2, #4
    blo     .L_bytewise
  10a3e4:	3a000006 	bcc	10a404 <memcpy+0x8c>

.L_wordwise:
    // copy 4 bytes at a time.
    // src & dst are guaranteed to be word aligned, and at least 4 bytes are left to copy.
    subs    r2, r2, #4
  10a3e8:	e2522004 	subs	r2, r2, #4

.L_wordwise_loop:
    ldr     r3, [r1], #4
  10a3ec:	e4913004 	ldr	r3, [r1], #4
    subs    r2, r2, #4
  10a3f0:	e2522004 	subs	r2, r2, #4
    str     r3, [r0], #4
  10a3f4:	e4803004 	str	r3, [r0], #4
    bhs     .L_wordwise_loop
  10a3f8:	2afffffb 	bcs	10a3ec <memcpy+0x74>

    // correct the remaining len and test for completion
    adds    r2, r2, #4  
  10a3fc:	e2922004 	adds	r2, r2, #4
    beq     .L_done
  10a400:	0a000003 	beq	10a414 <memcpy+0x9c>

.L_bytewise:
    // simple bytewise copy
    ldrb    r3, [r1], #1
  10a404:	e4d13001 	ldrb	r3, [r1], #1
    subs    r2, r2, #1
  10a408:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #1
  10a40c:	e4c03001 	strb	r3, [r0], #1
    bhi     .L_bytewise
  10a410:	8afffffb 	bhi	10a404 <memcpy+0x8c>
.L_done:
    // load dst for return and restore r4,r5
#if ARM_ARCH_LEVEL >= 5
    ldmfd   sp!, {r0, r4, r5, pc}
#else
    ldmfd   sp!, {r0, r4, r5, lr}
  10a414:	e8bd4031 	pop	{r0, r4, r5, r14}
    bx      lr
  10a418:	e12fff1e 	bx	r14
.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will copy up to 15 bytes to get it aligned.
    // src is guaranteed to be similarly word aligned with dst.

    // set the condition flags based on the alignment.
    lsl     r12, r0, #28
  10a41c:	e1a0ce00 	lsl	r12, r0, #28
    rsb     r12, r12, #0
  10a420:	e26cc000 	rsb	r12, r12, #0
    msr     CPSR_f, r12             // move into NZCV fields in CPSR
  10a424:	e128f00c 	msr	CPSR_f, r12

    // move as many bytes as necessary to get the dst aligned
    ldrvsb  r3, [r1], #1            // V set
  10a428:	64d13001 	ldrbvs	r3, [r1], #1
    ldrcsh  r4, [r1], #2            // C set
  10a42c:	20d140b2 	ldrhcs	r4, [r1], #2
    ldreq   r5, [r1], #4            // Z set
  10a430:	04915004 	ldreq	r5, [r1], #4

    strvsb  r3, [r0], #1
  10a434:	64c03001 	strbvs	r3, [r0], #1
    strcsh  r4, [r0], #2
  10a438:	20c040b2 	strhcs	r4, [r0], #2
    streq   r5, [r0], #4
  10a43c:	04805004 	streq	r5, [r0], #4

    ldmmiia r1!, {r3-r4}            // N set
  10a440:	48b10018 	ldmmi	r1!, {r3, r4}
    stmmiia r0!, {r3-r4}
  10a444:	48a00018 	stmiami	r0!, {r3, r4}

    // fix the remaining len
    sub     r2, r2, r12, lsr #28
  10a448:	e0422e2c 	sub	r2, r2, r12, lsr #28

    // test to see what we should do now
    cmp     r2, #32
  10a44c:	e3520020 	cmp	r2, #32
    bhs     .L_bigcopy
  10a450:	2affffd8 	bcs	10a3b8 <memcpy+0x40>
    b       .L_wordwise
  10a454:	eaffffe3 	b	10a3e8 <memcpy+0x70>

    // src and dest overlap 'forwards' or dst > src
.L_forwardoverlap:

    // do a bytewise reverse copy for now
    add     r1, r1, r2
  10a458:	e0811002 	add	r1, r1, r2
    add     r0, r0, r2
  10a45c:	e0800002 	add	r0, r0, r2
    sub     r1, r1, #1
  10a460:	e2411001 	sub	r1, r1, #1
    sub     r0, r0, #1
  10a464:	e2400001 	sub	r0, r0, #1

.L_bytewisereverse:
    // simple bytewise reverse copy
    ldrb    r3, [r1], #-1
  10a468:	e4513001 	ldrb	r3, [r1], #-1
    subs    r2, r2, #1
  10a46c:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #-1
  10a470:	e4403001 	strb	r3, [r0], #-1
    bhi     .L_bytewisereverse
  10a474:	8afffffb 	bhi	10a468 <memcpy+0xf0>

    b       .L_done
  10a478:	eaffffe5 	b	10a414 <memcpy+0x9c>

0010a47c <bzero>:
.text
.align 2

/* void bzero(void *s, size_t n); */
FUNCTION(bzero)
    mov     r2, r1
  10a47c:	e1a02001 	mov	r2, r1
    mov     r1, #0
  10a480:	e3a01000 	mov	r1, #0

0010a484 <memset>:

/* void *memset(void *s, int c, size_t n); */
FUNCTION(memset)
    // check for zero length
    cmp     r2, #0
  10a484:	e3520000 	cmp	r2, #0
    bxeq    lr
  10a488:	012fff1e 	bxeq	r14

    // save the original pointer
    mov     r12, r0
  10a48c:	e1a0c000 	mov	r12, r0

    // short memsets aren't worth optimizing
    cmp     r2, #(32 + 16)
  10a490:	e3520030 	cmp	r2, #48	; 0x30
    blt     .L_bytewise
  10a494:	ba000010 	blt	10a4dc <memset+0x58>

    // fill a 32 bit register with the 8 bit value
    and     r1, r1, #0xff
  10a498:	e20110ff 	and	r1, r1, #255	; 0xff
    orr     r1, r1, r1, lsl #8
  10a49c:	e1811401 	orr	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
  10a4a0:	e1811801 	orr	r1, r1, r1, lsl #16

    // check for 16 byte alignment
    tst     r0, #15
  10a4a4:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  10a4a8:	1a000010 	bne	10a4f0 <memset+0x6c>

.L_bigset:
    // dump some registers to make space for our values
    stmfd   sp!, { r4-r5 }
  10a4ac:	e92d0030 	push	{r4, r5}

    // fill a bunch of registers with the set value
    mov     r3, r1
  10a4b0:	e1a03001 	mov	r3, r1
    mov     r4, r1
  10a4b4:	e1a04001 	mov	r4, r1
    mov     r5, r1
  10a4b8:	e1a05001 	mov	r5, r1

    // prepare the count register so we can avoid an extra compare
    sub     r2, r2, #32
  10a4bc:	e2422020 	sub	r2, r2, #32

    // 32 bytes at a time
.L_bigset_loop:
    stmia   r0!, { r1, r3, r4, r5 }
  10a4c0:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    subs    r2, r2, #32
  10a4c4:	e2522020 	subs	r2, r2, #32
    stmia   r0!, { r1, r3, r4, r5 }
  10a4c8:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    bge     .L_bigset_loop
  10a4cc:	aafffffb 	bge	10a4c0 <memset+0x3c>

    // restore our dumped registers
    ldmfd   sp!, { r4-r5 }
  10a4d0:	e8bd0030 	pop	{r4, r5}

    // see if we're done
    adds    r2, r2, #32
  10a4d4:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  10a4d8:	0a000002 	beq	10a4e8 <memset+0x64>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
  10a4dc:	e2522001 	subs	r2, r2, #1
    strb    r1, [r0], #1
  10a4e0:	e4c01001 	strb	r1, [r0], #1
    bgt     .L_bytewise
  10a4e4:	cafffffc 	bgt	10a4dc <memset+0x58>

.L_done:
    // restore the base pointer as return value
    mov     r0, r12
  10a4e8:	e1a0000c 	mov	r0, r12
    bx      lr
  10a4ec:	e12fff1e 	bx	r14

.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will set up to 15 bytes to get it aligned.

    // set the condition flags based on the alignment.
    lsl     r3, r0, #28
  10a4f0:	e1a03e00 	lsl	r3, r0, #28
    rsb     r3, r3, #0
  10a4f4:	e2633000 	rsb	r3, r3, #0
    msr     CPSR_f, r3             // move into NZCV fields in CPSR
  10a4f8:	e128f003 	msr	CPSR_f, r3

    // move as many bytes as necessary to get the dst aligned
    strvsb  r1, [r0], #1            // V set
  10a4fc:	64c01001 	strbvs	r1, [r0], #1
    strcsh  r1, [r0], #2            // C set
  10a500:	20c010b2 	strhcs	r1, [r0], #2
    streq   r1, [r0], #4            // Z set
  10a504:	04801004 	streq	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  10a508:	44801004 	strmi	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  10a50c:	44801004 	strmi	r1, [r0], #4

    // fix the remaining len
    sub     r2, r2, r3, lsr #28
  10a510:	e0422e23 	sub	r2, r2, r3, lsr #28

    // do the large memset
    b       .L_bigset
  10a514:	eaffffe4 	b	10a4ac <memset+0x28>

0010a518 <isprint>:
    return ((c < ' ') || (c == 0x7f));
}

int isprint(int c)
{
    return ((c >= 0x20) && (c < 0x7f));
  10a518:	3820      	subs	r0, #32
}
  10a51a:	285e      	cmp	r0, #94	; 0x5e
  10a51c:	bf8c      	ite	hi
  10a51e:	2000      	movhi	r0, #0
  10a520:	2001      	movls	r0, #1
  10a522:	4770      	bx	r14

0010a524 <longlong_to_string>:
#define LEFTFORMATFLAG 0x00000800
#define LEADZEROFLAG   0x00001000
#define BLANKPOSFLAG   0x00002000

__NO_INLINE static char *longlong_to_string(char *buf, unsigned long long n, size_t len, uint flag, char *signchar)
{
  10a524:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10a528:	f8dd 902c 	ldr.w	r9, [r13, #44]	; 0x2c
  10a52c:	4680      	mov	r8, r0
  10a52e:	4614      	mov	r4, r2
  10a530:	461d      	mov	r5, r3
  10a532:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    size_t pos = len;
    int negative = 0;

    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  10a534:	f419 6a80 	ands.w	r10, r9, #1024	; 0x400
  10a538:	d006      	beq.n	10a548 <longlong_to_string+0x24>
  10a53a:	2a00      	cmp	r2, #0
  10a53c:	f175 0300 	sbcs.w	r3, r5, #0
    int negative = 0;
  10a540:	bfa8      	it	ge
  10a542:	f04f 0a00 	movge.w	r10, #0
    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  10a546:	db44      	blt.n	10a5d2 <longlong_to_string+0xae>
    }

    buf[--pos] = 0;

    /* only do the math if the number is >= 10 */
    while (n >= 10) {
  10a548:	2d00      	cmp	r5, #0
    buf[--pos] = 0;
  10a54a:	f04f 0300 	mov.w	r3, #0
  10a54e:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    while (n >= 10) {
  10a552:	bf08      	it	eq
  10a554:	2c0a      	cmpeq	r4, #10
    buf[--pos] = 0;
  10a556:	f808 3007 	strb.w	r3, [r8, r7]
  10a55a:	eb08 0b07 	add.w	r11, r8, r7
    while (n >= 10) {
  10a55e:	d316      	bcc.n	10a58e <longlong_to_string+0x6a>
        int digit = n % 10;
  10a560:	4620      	mov	r0, r4
  10a562:	4629      	mov	r1, r5
  10a564:	220a      	movs	r2, #10
  10a566:	2300      	movs	r3, #0
  10a568:	f001 fb76 	bl	10bc58 <__aeabi_uldivmod>

        n /= 10;
  10a56c:	4620      	mov	r0, r4
  10a56e:	4629      	mov	r1, r5
  10a570:	2300      	movs	r3, #0

        buf[--pos] = digit + '0';
  10a572:	3f01      	subs	r7, #1
        int digit = n % 10;
  10a574:	4616      	mov	r6, r2
        n /= 10;
  10a576:	220a      	movs	r2, #10
  10a578:	f001 fb6e 	bl	10bc58 <__aeabi_uldivmod>
        buf[--pos] = digit + '0';
  10a57c:	3630      	adds	r6, #48	; 0x30
  10a57e:	f80b 6d01 	strb.w	r6, [r11, #-1]!
        n /= 10;
  10a582:	4604      	mov	r4, r0
    while (n >= 10) {
  10a584:	2900      	cmp	r1, #0
        n /= 10;
  10a586:	460d      	mov	r5, r1
    while (n >= 10) {
  10a588:	bf08      	it	eq
  10a58a:	280a      	cmpeq	r0, #10
  10a58c:	d2e8      	bcs.n	10a560 <longlong_to_string+0x3c>
    }
    buf[--pos] = n + '0';
  10a58e:	3f01      	subs	r7, #1
  10a590:	3430      	adds	r4, #48	; 0x30
  10a592:	eb08 0007 	add.w	r0, r8, r7
  10a596:	f808 4007 	strb.w	r4, [r8, r7]

    if (negative)
  10a59a:	f1ba 0f00 	cmp.w	r10, #0
  10a59e:	d113      	bne.n	10a5c8 <longlong_to_string+0xa4>
        *signchar = '-';
    else if ((flag & SHOWSIGNFLAG))
  10a5a0:	f419 7f00 	tst.w	r9, #512	; 0x200
  10a5a4:	d10b      	bne.n	10a5be <longlong_to_string+0x9a>
        *signchar = '+';
    else if ((flag & BLANKPOSFLAG))
  10a5a6:	f419 5f00 	tst.w	r9, #8192	; 0x2000
        *signchar = ' ';
  10a5aa:	bf1b      	ittet	ne
  10a5ac:	2320      	movne	r3, #32
  10a5ae:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
    else
        *signchar = '\0';
  10a5b0:	9b0c      	ldreq	r3, [sp, #48]	; 0x30
        *signchar = ' ';
  10a5b2:	7013      	strbne	r3, [r2, #0]
        *signchar = '\0';
  10a5b4:	bf08      	it	eq
  10a5b6:	f883 a000 	strbeq.w	r10, [r3]

    return &buf[pos];
}
  10a5ba:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '+';
  10a5be:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  10a5c0:	232b      	movs	r3, #43	; 0x2b
  10a5c2:	7013      	strb	r3, [r2, #0]
}
  10a5c4:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '-';
  10a5c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  10a5ca:	232d      	movs	r3, #45	; 0x2d
  10a5cc:	7013      	strb	r3, [r2, #0]
}
  10a5ce:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        negative = 1;
  10a5d2:	f04f 0a01 	mov.w	r10, #1
        n = -n;
  10a5d6:	4254      	negs	r4, r2
  10a5d8:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  10a5dc:	e7b4      	b.n	10a548 <longlong_to_string+0x24>
  10a5de:	bf00      	nop

0010a5e0 <exponent_to_string>:
__NO_INLINE static size_t exponent_to_string(char *buf, int32_t exponent)
{
    size_t pos = 0;

    /* handle sign */
    if (exponent < 0) {
  10a5e0:	2900      	cmp	r1, #0
        OUT('-');
  10a5e2:	bfba      	itte	lt
  10a5e4:	232d      	movlt	r3, #45	; 0x2d
        exponent = -exponent;
  10a5e6:	4249      	neglt	r1, r1
    }
    else {
        OUT('+');
  10a5e8:	232b      	movge	r3, #43	; 0x2b
    }

    /* see how far we need to bump into the string to print from the right */
    if (exponent >= 1000) pos += 4;
  10a5ea:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
{
  10a5ee:	b4f0      	push	{r4, r5, r6, r7}
        OUT('+');
  10a5f0:	7003      	strb	r3, [r0, #0]
{
  10a5f2:	4605      	mov	r5, r0
    if (exponent >= 1000) pos += 4;
  10a5f4:	bfa8      	it	ge
  10a5f6:	2005      	movge	r0, #5
  10a5f8:	da03      	bge.n	10a602 <exponent_to_string+0x22>
    else if (exponent >= 100) pos += 3;
  10a5fa:	2963      	cmp	r1, #99	; 0x63
  10a5fc:	bfc8      	it	gt
  10a5fe:	2004      	movgt	r0, #4
  10a600:	dd1a      	ble.n	10a638 <exponent_to_string+0x58>
    else pos++;

    /* print decimal string, from the right */
    uint i = pos;
    do {
        uint digit = (uint32_t)exponent % 10;
  10a602:	f64c 47cd 	movw	r7, #52429	; 0xcccd

        buf[--i] = digit + '0';

        exponent /= 10;
  10a606:	f246 6667 	movw	r6, #26215	; 0x6667
  10a60a:	4405      	add	r5, r0
        uint digit = (uint32_t)exponent % 10;
  10a60c:	f6cc 47cc 	movt	r7, #52428	; 0xcccc
        exponent /= 10;
  10a610:	f2c6 6666 	movt	r6, #26214	; 0x6666
        uint digit = (uint32_t)exponent % 10;
  10a614:	fba7 2301 	umull	r2, r3, r7, r1
        exponent /= 10;
  10a618:	fb86 2401 	smull	r2, r4, r6, r1
        uint digit = (uint32_t)exponent % 10;
  10a61c:	08db      	lsrs	r3, r3, #3
        exponent /= 10;
  10a61e:	17ca      	asrs	r2, r1, #31
        uint digit = (uint32_t)exponent % 10;
  10a620:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  10a624:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
        buf[--i] = digit + '0';
  10a628:	3130      	adds	r1, #48	; 0x30
  10a62a:	f805 1d01 	strb.w	r1, [r5, #-1]!
    }
    while (exponent != 0);
  10a62e:	ebd2 01a4 	rsbs	r1, r2, r4, asr #2
  10a632:	d1ef      	bne.n	10a614 <exponent_to_string+0x34>

    /* return number of characters printed */
    return pos;
}
  10a634:	bcf0      	pop	{r4, r5, r6, r7}
  10a636:	4770      	bx	r14
    else pos++;
  10a638:	2909      	cmp	r1, #9
  10a63a:	bfcc      	ite	gt
  10a63c:	2003      	movgt	r0, #3
  10a63e:	2002      	movle	r0, #2
  10a640:	e7df      	b.n	10a602 <exponent_to_string+0x22>
  10a642:	bf00      	nop

0010a644 <double_to_hexstring.isra.0>:

    buf[pos] = 0;
    return buf;
}

__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  10a644:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10a648:	ec57 6b10 	vmov	r6, r7, d0
  10a64c:	4605      	mov	r5, r0
{
    size_t pos = 0;
    union double_int u = { d };

    uint32_t exponent = (u.i >> 52) & 0x7ff;
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a64e:	f64f 79ff 	movw	r9, #65535	; 0xffff
__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  10a652:	b085      	sub	sp, #20
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a654:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  10a658:	f401 7180 	and.w	r1, r1, #256	; 0x100
    bool neg = !!(u.i & (1ULL << 63));

    /* start constructing the string */
    if (neg) {
  10a65c:	2e00      	cmp	r6, #0
  10a65e:	f177 0300 	sbcs.w	r3, r7, #0
        OUT('-');
  10a662:	bfb8      	it	lt
  10a664:	222d      	movlt	r2, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  10a666:	f3c7 500a 	ubfx	r0, r7, #20, #11
        OUT('-');
  10a66a:	bfb6      	itet	lt
  10a66c:	2301      	movlt	r3, #1
    size_t pos = 0;
  10a66e:	2300      	movge	r3, #0
        OUT('-');
  10a670:	702a      	strblt	r2, [r5, #0]
    }

    /* look for special cases */
    if (exponent == 0x7ff) {
  10a672:	f240 72ff 	movw	r2, #2047	; 0x7ff
  10a676:	4290      	cmp	r0, r2
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a678:	f2c0 090f 	movt	r9, #15
  10a67c:	ea06 0a08 	and.w	r10, r6, r8
  10a680:	9101      	str	r1, [sp, #4]
  10a682:	ea07 0b09 	and.w	r11, r7, r9
    if (exponent == 0x7ff) {
  10a686:	f000 8097 	beq.w	10a7b8 <double_to_hexstring.isra.0+0x174>
            /* NaN */
            if (flag & CAPSFLAG) OUTSTR("NAN");
            else OUTSTR("nan");
        }
    }
    else if (exponent == 0) {
  10a68a:	b9f0      	cbnz	r0, 10a6ca <double_to_hexstring.isra.0+0x86>
        if (fraction == 0) {
  10a68c:	ea5a 020b 	orrs.w	r2, r10, r11
            /* zero */
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  10a690:	9a01      	ldr	r2, [sp, #4]
        if (fraction == 0) {
  10a692:	f000 80d5 	beq.w	10a840 <double_to_hexstring.isra.0+0x1fc>
            else OUTSTR("0x0p+0");
        }
        else {
            /* denormalized */
            /* XXX does not handle */
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10a696:	2a00      	cmp	r2, #0
  10a698:	f040 810f 	bne.w	10a8ba <double_to_hexstring.isra.0+0x276>
            else OUTSTR("den");
  10a69c:	2064      	movs	r0, #100	; 0x64
  10a69e:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10a6a0:	2265      	movs	r2, #101	; 0x65
            else OUTSTR("den");
  10a6a2:	3301      	adds	r3, #1
  10a6a4:	4c95      	ldr	r4, [pc, #596]	; (10a8fc <double_to_hexstring.isra.0+0x2b8>)
  10a6a6:	f801 0b01 	strb.w	r0, [r1], #1
  10a6aa:	b13a      	cbz	r2, 10a6bc <double_to_hexstring.isra.0+0x78>
  10a6ac:	4610      	mov	r0, r2
  10a6ae:	3301      	adds	r3, #1
  10a6b0:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a6b4:	f801 0b01 	strb.w	r0, [r1], #1
  10a6b8:	2a00      	cmp	r2, #0
  10a6ba:	d1f7      	bne.n	10a6ac <double_to_hexstring.isra.0+0x68>
        /* handle the exponent */
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
        pos += exponent_to_string(&buf[pos], exponent_signed);
    }

    buf[pos] = 0;
  10a6bc:	2200      	movs	r2, #0
  10a6be:	442b      	add	r3, r5
    return buf;
}
  10a6c0:	4628      	mov	r0, r5
    buf[pos] = 0;
  10a6c2:	701a      	strb	r2, [r3, #0]
}
  10a6c4:	b005      	add	sp, #20
  10a6c6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        int exponent_signed = exponent - 1023;
  10a6ca:	f2a0 32ff 	subw	r2, r0, #1023	; 0x3ff
  10a6ce:	9203      	str	r2, [sp, #12]
        if (flag & CAPSFLAG) OUTSTR("0X1");
  10a6d0:	9a01      	ldr	r2, [sp, #4]
  10a6d2:	2a00      	cmp	r2, #0
  10a6d4:	f000 809e 	beq.w	10a814 <double_to_hexstring.isra.0+0x1d0>
  10a6d8:	2030      	movs	r0, #48	; 0x30
  10a6da:	18e9      	adds	r1, r5, r3
  10a6dc:	2258      	movs	r2, #88	; 0x58
  10a6de:	3301      	adds	r3, #1
  10a6e0:	4c87      	ldr	r4, [pc, #540]	; (10a900 <double_to_hexstring.isra.0+0x2bc>)
  10a6e2:	f801 0b01 	strb.w	r0, [r1], #1
  10a6e6:	b13a      	cbz	r2, 10a6f8 <double_to_hexstring.isra.0+0xb4>
  10a6e8:	4610      	mov	r0, r2
  10a6ea:	3301      	adds	r3, #1
  10a6ec:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a6f0:	f801 0b01 	strb.w	r0, [r1], #1
  10a6f4:	2a00      	cmp	r2, #0
  10a6f6:	d1f7      	bne.n	10a6e8 <double_to_hexstring.isra.0+0xa4>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a6f8:	f641 6220 	movw	r2, #7712	; 0x1e20
  10a6fc:	f2c0 0211 	movt	r2, #17
  10a700:	9202      	str	r2, [sp, #8]
        bool output_dot = false;
  10a702:	f04f 0900 	mov.w	r9, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  10a706:	2130      	movs	r1, #48	; 0x30
        int zero_count = 0;
  10a708:	464e      	mov	r6, r9
                    OUT('0');
  10a70a:	468c      	mov	r12, r1
  10a70c:	e002      	b.n	10a714 <double_to_hexstring.isra.0+0xd0>
        for (int i = 52 - 4; i >= 0; i -= 4) {
  10a70e:	3904      	subs	r1, #4
  10a710:	1d0a      	adds	r2, r1, #4
  10a712:	d045      	beq.n	10a7a0 <double_to_hexstring.isra.0+0x15c>
            uint digit = (fraction >> i) & 0xf;
  10a714:	f1c1 0420 	rsb	r4, r1, #32
  10a718:	fa0b f404 	lsl.w	r4, r11, r4
  10a71c:	fa2a f201 	lsr.w	r2, r10, r1
  10a720:	f1a1 0020 	sub.w	r0, r1, #32
  10a724:	4322      	orrs	r2, r4
  10a726:	fa2b f000 	lsr.w	r0, r11, r0
  10a72a:	4302      	orrs	r2, r0
            if (digit == 0) {
  10a72c:	f012 020f 	ands.w	r2, r2, #15
  10a730:	f103 0401 	add.w	r4, r3, #1
  10a734:	eb05 0004 	add.w	r0, r5, r4
  10a738:	eb05 0e03 	add.w	r14, r5, r3
                zero_count++;
  10a73c:	bf08      	it	eq
  10a73e:	3601      	addeq	r6, #1
            if (digit == 0) {
  10a740:	d0e5      	beq.n	10a70e <double_to_hexstring.isra.0+0xca>
  10a742:	1c9f      	adds	r7, r3, #2
  10a744:	eb05 0807 	add.w	r8, r5, r7
                if (!output_dot) {
  10a748:	f1b9 0f00 	cmp.w	r9, #0
  10a74c:	d10c      	bne.n	10a768 <double_to_hexstring.isra.0+0x124>
  10a74e:	f103 0903 	add.w	r9, r3, #3
                    OUT('.');
  10a752:	f04f 032e 	mov.w	r3, #46	; 0x2e
  10a756:	f88e 3000 	strb.w	r3, [r14]
  10a75a:	4623      	mov	r3, r4
  10a75c:	4686      	mov	r14, r0
  10a75e:	463c      	mov	r4, r7
  10a760:	4640      	mov	r0, r8
  10a762:	464f      	mov	r7, r9
  10a764:	eb05 0809 	add.w	r8, r5, r9
                while (zero_count > 0) {
  10a768:	2e00      	cmp	r6, #0
  10a76a:	d079      	beq.n	10a860 <double_to_hexstring.isra.0+0x21c>
  10a76c:	19ac      	adds	r4, r5, r6
  10a76e:	441c      	add	r4, r3
  10a770:	18e8      	adds	r0, r5, r3
                    OUT('0');
  10a772:	f800 cb01 	strb.w	r12, [r0], #1
                while (zero_count > 0) {
  10a776:	4284      	cmp	r4, r0
  10a778:	d1fb      	bne.n	10a772 <double_to_hexstring.isra.0+0x12e>
  10a77a:	441e      	add	r6, r3
  10a77c:	19a8      	adds	r0, r5, r6
  10a77e:	1c73      	adds	r3, r6, #1
  10a780:	9000      	str	r0, [sp, #0]
  10a782:	1cb4      	adds	r4, r6, #2
  10a784:	eb05 0e03 	add.w	r14, r5, r3
  10a788:	1928      	adds	r0, r5, r4
                buf[pos++] = table[digit];
  10a78a:	9f02      	ldr	r7, [sp, #8]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  10a78c:	3904      	subs	r1, #4
                buf[pos++] = table[digit];
  10a78e:	5cba      	ldrb	r2, [r7, r2]
  10a790:	9f00      	ldr	r7, [sp, #0]
  10a792:	703a      	strb	r2, [r7, #0]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  10a794:	1d0a      	adds	r2, r1, #4
                buf[pos++] = table[digit];
  10a796:	f04f 0901 	mov.w	r9, #1
  10a79a:	f04f 0600 	mov.w	r6, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  10a79e:	d1b9      	bne.n	10a714 <double_to_hexstring.isra.0+0xd0>
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  10a7a0:	9b01      	ldr	r3, [sp, #4]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  10a7a2:	9903      	ldr	r1, [sp, #12]
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  10a7a4:	2b00      	cmp	r3, #0
  10a7a6:	bf0c      	ite	eq
  10a7a8:	2370      	moveq	r3, #112	; 0x70
  10a7aa:	2350      	movne	r3, #80	; 0x50
  10a7ac:	f88e 3000 	strb.w	r3, [r14]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  10a7b0:	f7ff ff16 	bl	10a5e0 <exponent_to_string>
  10a7b4:	1903      	adds	r3, r0, r4
  10a7b6:	e781      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
        if (fraction == 0) {
  10a7b8:	ea5a 020b 	orrs.w	r2, r10, r11
  10a7bc:	d114      	bne.n	10a7e8 <double_to_hexstring.isra.0+0x1a4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  10a7be:	2900      	cmp	r1, #0
  10a7c0:	d155      	bne.n	10a86e <double_to_hexstring.isra.0+0x22a>
            else OUTSTR("inf");
  10a7c2:	2069      	movs	r0, #105	; 0x69
  10a7c4:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("INF");
  10a7c6:	226e      	movs	r2, #110	; 0x6e
            else OUTSTR("inf");
  10a7c8:	3301      	adds	r3, #1
  10a7ca:	4c4e      	ldr	r4, [pc, #312]	; (10a904 <double_to_hexstring.isra.0+0x2c0>)
  10a7cc:	f801 0b01 	strb.w	r0, [r1], #1
  10a7d0:	2a00      	cmp	r2, #0
  10a7d2:	f43f af73 	beq.w	10a6bc <double_to_hexstring.isra.0+0x78>
  10a7d6:	4610      	mov	r0, r2
  10a7d8:	3301      	adds	r3, #1
  10a7da:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a7de:	f801 0b01 	strb.w	r0, [r1], #1
  10a7e2:	2a00      	cmp	r2, #0
  10a7e4:	d1f7      	bne.n	10a7d6 <double_to_hexstring.isra.0+0x192>
  10a7e6:	e769      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  10a7e8:	9a01      	ldr	r2, [sp, #4]
  10a7ea:	2a00      	cmp	r2, #0
  10a7ec:	d152      	bne.n	10a894 <double_to_hexstring.isra.0+0x250>
            else OUTSTR("nan");
  10a7ee:	206e      	movs	r0, #110	; 0x6e
  10a7f0:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("NAN");
  10a7f2:	2261      	movs	r2, #97	; 0x61
            else OUTSTR("nan");
  10a7f4:	3301      	adds	r3, #1
  10a7f6:	4c44      	ldr	r4, [pc, #272]	; (10a908 <double_to_hexstring.isra.0+0x2c4>)
  10a7f8:	f801 0b01 	strb.w	r0, [r1], #1
  10a7fc:	2a00      	cmp	r2, #0
  10a7fe:	f43f af5d 	beq.w	10a6bc <double_to_hexstring.isra.0+0x78>
  10a802:	4610      	mov	r0, r2
  10a804:	3301      	adds	r3, #1
  10a806:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a80a:	f801 0b01 	strb.w	r0, [r1], #1
  10a80e:	2a00      	cmp	r2, #0
  10a810:	d1f7      	bne.n	10a802 <double_to_hexstring.isra.0+0x1be>
  10a812:	e753      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
        else OUTSTR("0x1");
  10a814:	2030      	movs	r0, #48	; 0x30
  10a816:	18e9      	adds	r1, r5, r3
        if (flag & CAPSFLAG) OUTSTR("0X1");
  10a818:	2278      	movs	r2, #120	; 0x78
        else OUTSTR("0x1");
  10a81a:	3301      	adds	r3, #1
  10a81c:	4c3b      	ldr	r4, [pc, #236]	; (10a90c <double_to_hexstring.isra.0+0x2c8>)
  10a81e:	f801 0b01 	strb.w	r0, [r1], #1
  10a822:	b13a      	cbz	r2, 10a834 <double_to_hexstring.isra.0+0x1f0>
  10a824:	4610      	mov	r0, r2
  10a826:	3301      	adds	r3, #1
  10a828:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a82c:	f801 0b01 	strb.w	r0, [r1], #1
  10a830:	2a00      	cmp	r2, #0
  10a832:	d1f7      	bne.n	10a824 <double_to_hexstring.isra.0+0x1e0>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a834:	f641 6210 	movw	r2, #7696	; 0x1e10
  10a838:	f2c0 0211 	movt	r2, #17
  10a83c:	9202      	str	r2, [sp, #8]
  10a83e:	e760      	b.n	10a702 <double_to_hexstring.isra.0+0xbe>
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  10a840:	2a00      	cmp	r2, #0
  10a842:	d14d      	bne.n	10a8e0 <double_to_hexstring.isra.0+0x29c>
  10a844:	4c32      	ldr	r4, [pc, #200]	; (10a910 <double_to_hexstring.isra.0+0x2cc>)
  10a846:	18e9      	adds	r1, r5, r3
  10a848:	2278      	movs	r2, #120	; 0x78
            else OUTSTR("0x0p+0");
  10a84a:	2030      	movs	r0, #48	; 0x30
  10a84c:	e002      	b.n	10a854 <double_to_hexstring.isra.0+0x210>
  10a84e:	4610      	mov	r0, r2
  10a850:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a854:	f801 0b01 	strb.w	r0, [r1], #1
  10a858:	3301      	adds	r3, #1
  10a85a:	2a00      	cmp	r2, #0
  10a85c:	d1f7      	bne.n	10a84e <double_to_hexstring.isra.0+0x20a>
  10a85e:	e72d      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
                while (zero_count > 0) {
  10a860:	f8cd e000 	str.w	r14, [r13]
  10a864:	4623      	mov	r3, r4
  10a866:	4686      	mov	r14, r0
  10a868:	463c      	mov	r4, r7
  10a86a:	4640      	mov	r0, r8
  10a86c:	e78d      	b.n	10a78a <double_to_hexstring.isra.0+0x146>
            if (flag & CAPSFLAG) OUTSTR("INF");
  10a86e:	2049      	movs	r0, #73	; 0x49
  10a870:	18e9      	adds	r1, r5, r3
  10a872:	224e      	movs	r2, #78	; 0x4e
  10a874:	3301      	adds	r3, #1
  10a876:	4c27      	ldr	r4, [pc, #156]	; (10a914 <double_to_hexstring.isra.0+0x2d0>)
  10a878:	f801 0b01 	strb.w	r0, [r1], #1
  10a87c:	2a00      	cmp	r2, #0
  10a87e:	f43f af1d 	beq.w	10a6bc <double_to_hexstring.isra.0+0x78>
  10a882:	4610      	mov	r0, r2
  10a884:	3301      	adds	r3, #1
  10a886:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a88a:	f801 0b01 	strb.w	r0, [r1], #1
  10a88e:	2a00      	cmp	r2, #0
  10a890:	d1f7      	bne.n	10a882 <double_to_hexstring.isra.0+0x23e>
  10a892:	e713      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  10a894:	204e      	movs	r0, #78	; 0x4e
  10a896:	18e9      	adds	r1, r5, r3
  10a898:	2241      	movs	r2, #65	; 0x41
  10a89a:	3301      	adds	r3, #1
  10a89c:	4c1e      	ldr	r4, [pc, #120]	; (10a918 <double_to_hexstring.isra.0+0x2d4>)
  10a89e:	f801 0b01 	strb.w	r0, [r1], #1
  10a8a2:	2a00      	cmp	r2, #0
  10a8a4:	f43f af0a 	beq.w	10a6bc <double_to_hexstring.isra.0+0x78>
  10a8a8:	4610      	mov	r0, r2
  10a8aa:	3301      	adds	r3, #1
  10a8ac:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a8b0:	f801 0b01 	strb.w	r0, [r1], #1
  10a8b4:	2a00      	cmp	r2, #0
  10a8b6:	d1f7      	bne.n	10a8a8 <double_to_hexstring.isra.0+0x264>
  10a8b8:	e700      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10a8ba:	2044      	movs	r0, #68	; 0x44
  10a8bc:	18e9      	adds	r1, r5, r3
  10a8be:	2245      	movs	r2, #69	; 0x45
  10a8c0:	3301      	adds	r3, #1
  10a8c2:	4c16      	ldr	r4, [pc, #88]	; (10a91c <double_to_hexstring.isra.0+0x2d8>)
  10a8c4:	f801 0b01 	strb.w	r0, [r1], #1
  10a8c8:	2a00      	cmp	r2, #0
  10a8ca:	f43f aef7 	beq.w	10a6bc <double_to_hexstring.isra.0+0x78>
  10a8ce:	4610      	mov	r0, r2
  10a8d0:	3301      	adds	r3, #1
  10a8d2:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a8d6:	f801 0b01 	strb.w	r0, [r1], #1
  10a8da:	2a00      	cmp	r2, #0
  10a8dc:	d1f7      	bne.n	10a8ce <double_to_hexstring.isra.0+0x28a>
  10a8de:	e6ed      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
  10a8e0:	4c0f      	ldr	r4, [pc, #60]	; (10a920 <double_to_hexstring.isra.0+0x2dc>)
  10a8e2:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  10a8e4:	2258      	movs	r2, #88	; 0x58
  10a8e6:	2030      	movs	r0, #48	; 0x30
  10a8e8:	e002      	b.n	10a8f0 <double_to_hexstring.isra.0+0x2ac>
  10a8ea:	4610      	mov	r0, r2
  10a8ec:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  10a8f0:	f801 0b01 	strb.w	r0, [r1], #1
  10a8f4:	3301      	adds	r3, #1
  10a8f6:	2a00      	cmp	r2, #0
  10a8f8:	d1f7      	bne.n	10a8ea <double_to_hexstring.isra.0+0x2a6>
  10a8fa:	e6df      	b.n	10a6bc <double_to_hexstring.isra.0+0x78>
  10a8fc:	00111ded 	.word	0x00111ded
  10a900:	00111df9 	.word	0x00111df9
  10a904:	00111dcd 	.word	0x00111dcd
  10a908:	00111dd5 	.word	0x00111dd5
  10a90c:	00111df5 	.word	0x00111df5
  10a910:	00111ddd 	.word	0x00111ddd
  10a914:	00111dd1 	.word	0x00111dd1
  10a918:	00111dd9 	.word	0x00111dd9
  10a91c:	00111df1 	.word	0x00111df1
  10a920:	00111de5 	.word	0x00111de5

0010a924 <longlong_to_hexstring.constprop.1>:
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  10a924:	e92d 08f0 	stmdb	r13!, {r4, r5, r6, r7, r11}
  10a928:	9905      	ldr	r1, [sp, #20]
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a92a:	f641 6720 	movw	r7, #7712	; 0x1e20
    buf[--pos] = 0;
  10a92e:	2500      	movs	r5, #0
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a930:	f2c0 0711 	movt	r7, #17
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  10a934:	4693      	mov	r11, r2
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a936:	f411 7f80 	tst.w	r1, #256	; 0x100
  10a93a:	f641 6110 	movw	r1, #7696	; 0x1e10
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  10a93e:	469c      	mov	r12, r3
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  10a940:	f2c0 0111 	movt	r1, #17
  10a944:	bf08      	it	eq
  10a946:	460f      	moveq	r7, r1
  10a948:	f100 041e 	add.w	r4, r0, #30
    buf[--pos] = 0;
  10a94c:	77c5      	strb	r5, [r0, #31]
        u /= 16;
  10a94e:	ea4f 111b 	mov.w	r1, r11, lsr #4
  10a952:	ea41 710c 	orr.w	r1, r1, r12, lsl #28
  10a956:	ea4f 161c 	mov.w	r6, r12, lsr #4
  10a95a:	46b4      	mov	r12, r6
        unsigned int digit = u % 16;
  10a95c:	f00b 020f 	and.w	r2, r11, #15
        u /= 16;
  10a960:	468b      	mov	r11, r1
        buf[--pos] = table[digit];
  10a962:	5cbd      	ldrb	r5, [r7, r2]
  10a964:	4620      	mov	r0, r4
    while (u != 0);
  10a966:	ea5b 030c 	orrs.w	r3, r11, r12
        buf[--pos] = table[digit];
  10a96a:	f804 5901 	strb.w	r5, [r4], #-1
    while (u != 0);
  10a96e:	d1ee      	bne.n	10a94e <longlong_to_hexstring.constprop.1+0x2a>
}
  10a970:	e8bd 08f0 	ldmia.w	r13!, {r4, r5, r6, r7, r11}
  10a974:	4770      	bx	r14
  10a976:	bf00      	nop

0010a978 <double_to_string.constprop.2>:
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  10a978:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10a97c:	ec57 6b10 	vmov	r6, r7, d0
  10a980:	4604      	mov	r4, r0
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a982:	f64f 7bff 	movw	r11, #65535	; 0xffff
  10a986:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
  10a98a:	f2c0 0b0f 	movt	r11, #15
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  10a98e:	ee10 8a10 	vmov	r8, s0
    if (neg) {
  10a992:	2e00      	cmp	r6, #0
  10a994:	f177 0000 	sbcs.w	r0, r7, #0
        OUT('-');
  10a998:	bfb8      	it	lt
  10a99a:	202d      	movlt	r0, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  10a99c:	f3c7 550a 	ubfx	r5, r7, #20, #11
  10a9a0:	46b9      	mov	r9, r7
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a9a2:	ea0b 0307 	and.w	r3, r11, r7
        OUT('-');
  10a9a6:	bfb8      	it	lt
  10a9a8:	7020      	strblt	r0, [r4, #0]
    if (exponent == 0x7ff) {
  10a9aa:	f240 70ff 	movw	r0, #2047	; 0x7ff
        OUT('-');
  10a9ae:	bfba      	itte	lt
  10a9b0:	f04f 0c01 	movlt.w	r12, #1
        d = -d;
  10a9b4:	f087 4700 	eorlt.w	r7, r7, #2147483648	; 0x80000000
    size_t pos = 0;
  10a9b8:	f04f 0c00 	movge.w	r12, #0
    if (exponent == 0x7ff) {
  10a9bc:	4285      	cmp	r5, r0
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  10a9be:	b089      	sub	sp, #36	; 0x24
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  10a9c0:	ea0a 0206 	and.w	r2, r10, r6
    if (exponent == 0x7ff) {
  10a9c4:	d033      	beq.n	10aa2e <double_to_string.constprop.2+0xb6>
    else if (exponent == 0) {
  10a9c6:	b9f5      	cbnz	r5, 10aa06 <double_to_string.constprop.2+0x8e>
        if (fraction == 0) {
  10a9c8:	4313      	orrs	r3, r2
  10a9ca:	d059      	beq.n	10aa80 <double_to_string.constprop.2+0x108>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10a9cc:	05cb      	lsls	r3, r1, #23
  10a9ce:	f100 80ce 	bmi.w	10ab6e <double_to_string.constprop.2+0x1f6>
            else OUTSTR("den");
  10a9d2:	2164      	movs	r1, #100	; 0x64
  10a9d4:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10a9d8:	2365      	movs	r3, #101	; 0x65
            else OUTSTR("den");
  10a9da:	f10c 0c01 	add.w	r12, r12, #1
  10a9de:	488c      	ldr	r0, [pc, #560]	; (10ac10 <double_to_string.constprop.2+0x298>)
  10a9e0:	f802 1b01 	strb.w	r1, [r2], #1
  10a9e4:	b143      	cbz	r3, 10a9f8 <double_to_string.constprop.2+0x80>
  10a9e6:	4619      	mov	r1, r3
  10a9e8:	f10c 0c01 	add.w	r12, r12, #1
  10a9ec:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10a9f0:	f802 1b01 	strb.w	r1, [r2], #1
  10a9f4:	2b00      	cmp	r3, #0
  10a9f6:	d1f6      	bne.n	10a9e6 <double_to_string.constprop.2+0x6e>
    buf[pos] = 0;
  10a9f8:	2300      	movs	r3, #0
  10a9fa:	4620      	mov	r0, r4
  10a9fc:	f804 300c 	strb.w	r3, [r4, r12]
}
  10aa00:	b009      	add	sp, #36	; 0x24
  10aa02:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (exponent_signed < -52 || exponent_signed > 52) {
  10aa06:	f2a5 30cb 	subw	r0, r5, #971	; 0x3cb
  10aa0a:	2868      	cmp	r0, #104	; 0x68
  10aa0c:	d948      	bls.n	10aaa0 <double_to_string.constprop.2+0x128>
  10aa0e:	4881      	ldr	r0, [pc, #516]	; (10ac14 <double_to_string.constprop.2+0x29c>)
  10aa10:	eb04 020c 	add.w	r2, r4, r12
  10aa14:	2372      	movs	r3, #114	; 0x72
            OUTSTR("<range>");
  10aa16:	213c      	movs	r1, #60	; 0x3c
  10aa18:	e002      	b.n	10aa20 <double_to_string.constprop.2+0xa8>
  10aa1a:	4619      	mov	r1, r3
  10aa1c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10aa20:	f802 1b01 	strb.w	r1, [r2], #1
  10aa24:	f10c 0c01 	add.w	r12, r12, #1
  10aa28:	2b00      	cmp	r3, #0
  10aa2a:	d1f6      	bne.n	10aa1a <double_to_string.constprop.2+0xa2>
  10aa2c:	e7e4      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
        if (fraction == 0) {
  10aa2e:	4313      	orrs	r3, r2
  10aa30:	f401 7180 	and.w	r1, r1, #256	; 0x100
  10aa34:	d112      	bne.n	10aa5c <double_to_string.constprop.2+0xe4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  10aa36:	2900      	cmp	r1, #0
  10aa38:	f040 8089 	bne.w	10ab4e <double_to_string.constprop.2+0x1d6>
  10aa3c:	4876      	ldr	r0, [pc, #472]	; (10ac18 <double_to_string.constprop.2+0x2a0>)
  10aa3e:	eb04 020c 	add.w	r2, r4, r12
  10aa42:	236e      	movs	r3, #110	; 0x6e
            else OUTSTR("inf");
  10aa44:	2169      	movs	r1, #105	; 0x69
  10aa46:	e002      	b.n	10aa4e <double_to_string.constprop.2+0xd6>
  10aa48:	4619      	mov	r1, r3
  10aa4a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10aa4e:	f802 1b01 	strb.w	r1, [r2], #1
  10aa52:	f10c 0c01 	add.w	r12, r12, #1
  10aa56:	2b00      	cmp	r3, #0
  10aa58:	d1f6      	bne.n	10aa48 <double_to_string.constprop.2+0xd0>
  10aa5a:	e7cd      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  10aa5c:	2900      	cmp	r1, #0
  10aa5e:	d166      	bne.n	10ab2e <double_to_string.constprop.2+0x1b6>
  10aa60:	486e      	ldr	r0, [pc, #440]	; (10ac1c <double_to_string.constprop.2+0x2a4>)
  10aa62:	eb04 020c 	add.w	r2, r4, r12
  10aa66:	2361      	movs	r3, #97	; 0x61
            else OUTSTR("nan");
  10aa68:	216e      	movs	r1, #110	; 0x6e
  10aa6a:	e002      	b.n	10aa72 <double_to_string.constprop.2+0xfa>
  10aa6c:	4619      	mov	r1, r3
  10aa6e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10aa72:	f802 1b01 	strb.w	r1, [r2], #1
  10aa76:	f10c 0c01 	add.w	r12, r12, #1
  10aa7a:	2b00      	cmp	r3, #0
  10aa7c:	d1f6      	bne.n	10aa6c <double_to_string.constprop.2+0xf4>
  10aa7e:	e7bb      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
  10aa80:	4867      	ldr	r0, [pc, #412]	; (10ac20 <double_to_string.constprop.2+0x2a8>)
  10aa82:	eb04 020c 	add.w	r2, r4, r12
        if (fraction == 0) {
  10aa86:	232e      	movs	r3, #46	; 0x2e
            OUTSTR("0.000000");
  10aa88:	2130      	movs	r1, #48	; 0x30
  10aa8a:	e002      	b.n	10aa92 <double_to_string.constprop.2+0x11a>
  10aa8c:	4619      	mov	r1, r3
  10aa8e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10aa92:	f802 1b01 	strb.w	r1, [r2], #1
  10aa96:	f10c 0c01 	add.w	r12, r12, #1
  10aa9a:	2b00      	cmp	r3, #0
  10aa9c:	d1f6      	bne.n	10aa8c <double_to_string.constprop.2+0x114>
  10aa9e:	e7ab      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
            OUTREV(0);
  10aaa0:	2000      	movs	r0, #0
  10aaa2:	46a2      	mov	r10, r4
                OUTREV('0');
  10aaa4:	f04f 0c30 	mov.w	r12, #48	; 0x30
  10aaa8:	f104 0e18 	add.w	r14, r4, #24
            OUTREV(0);
  10aaac:	f80a 0f1f 	strb.w	r0, [r10, #31]!
  10aab0:	4650      	mov	r0, r10
                OUTREV('0');
  10aab2:	f800 cd01 	strb.w	r12, [r0, #-1]!
            for (int i = 0; i <= 6; i++)
  10aab6:	4570      	cmp	r0, r14
  10aab8:	d1fb      	bne.n	10aab2 <double_to_string.constprop.2+0x13a>
        int exponent_signed = exponent - 1023;
  10aaba:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
            if (exponent_signed >= 0) {
  10aabe:	2d00      	cmp	r5, #0
                OUTREV('0');
  10aac0:	bfbc      	itt	lt
  10aac2:	2517      	movlt	r5, #23
  10aac4:	f884 c017 	strblt.w	r12, [r4, #23]
            if (exponent_signed >= 0) {
  10aac8:	da67      	bge.n	10ab9a <double_to_string.constprop.2+0x222>
            uint32_t frac = ((d - u) * 1000000) + .5;
  10aaca:	ed9f 6b4f 	vldr	d6, [r15, #316]	; 10ac08 <double_to_string.constprop.2+0x290>
  10aace:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  10aad2:	ec47 6b15 	vmov	d5, r6, r7
            buf[decimal_spot] = '.';
  10aad6:	232e      	movs	r3, #46	; 0x2e
  10aad8:	7623      	strb	r3, [r4, #24]
            uint32_t frac = ((d - u) * 1000000) + .5;
  10aada:	ee05 7b06 	vmla.f64	d7, d5, d6
  10aade:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  10aae2:	ee17 3a90 	vmov	r3, s15
            while (frac != 0) {
  10aae6:	b18b      	cbz	r3, 10ab0c <double_to_string.constprop.2+0x194>
                uint digit = frac % 10;
  10aae8:	f64c 40cd 	movw	r0, #52429	; 0xcccd
  10aaec:	f6cc 40cc 	movt	r0, #52428	; 0xcccc
  10aaf0:	fba0 1203 	umull	r1, r2, r0, r3
  10aaf4:	08d2      	lsrs	r2, r2, #3
  10aaf6:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  10aafa:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
                buf[--i] = digit + '0';
  10aafe:	f103 0130 	add.w	r1, r3, #48	; 0x30
            while (frac != 0) {
  10ab02:	4613      	mov	r3, r2
                buf[--i] = digit + '0';
  10ab04:	f80a 1d01 	strb.w	r1, [r10, #-1]!
            while (frac != 0) {
  10ab08:	2a00      	cmp	r2, #0
  10ab0a:	d1f1      	bne.n	10aaf0 <double_to_string.constprop.2+0x178>
            if (neg)
  10ab0c:	f1b8 0f00 	cmp.w	r8, #0
  10ab10:	f179 0300 	sbcs.w	r3, r9, #0
  10ab14:	bfa8      	it	ge
  10ab16:	1960      	addge	r0, r4, r5
  10ab18:	f6bf af72 	bge.w	10aa00 <double_to_string.constprop.2+0x88>
                OUTREV('-');
  10ab1c:	4620      	mov	r0, r4
  10ab1e:	2d00      	cmp	r5, #0
  10ab20:	f43f af6e 	beq.w	10aa00 <double_to_string.constprop.2+0x88>
  10ab24:	232d      	movs	r3, #45	; 0x2d
  10ab26:	3d01      	subs	r5, #1
  10ab28:	1960      	adds	r0, r4, r5
  10ab2a:	5563      	strb	r3, [r4, r5]
  10ab2c:	e768      	b.n	10aa00 <double_to_string.constprop.2+0x88>
  10ab2e:	483d      	ldr	r0, [pc, #244]	; (10ac24 <double_to_string.constprop.2+0x2ac>)
  10ab30:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("NAN");
  10ab34:	2341      	movs	r3, #65	; 0x41
  10ab36:	214e      	movs	r1, #78	; 0x4e
  10ab38:	e002      	b.n	10ab40 <double_to_string.constprop.2+0x1c8>
  10ab3a:	4619      	mov	r1, r3
  10ab3c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10ab40:	f802 1b01 	strb.w	r1, [r2], #1
  10ab44:	f10c 0c01 	add.w	r12, r12, #1
  10ab48:	2b00      	cmp	r3, #0
  10ab4a:	d1f6      	bne.n	10ab3a <double_to_string.constprop.2+0x1c2>
  10ab4c:	e754      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
  10ab4e:	4836      	ldr	r0, [pc, #216]	; (10ac28 <double_to_string.constprop.2+0x2b0>)
  10ab50:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("INF");
  10ab54:	234e      	movs	r3, #78	; 0x4e
  10ab56:	2149      	movs	r1, #73	; 0x49
  10ab58:	e002      	b.n	10ab60 <double_to_string.constprop.2+0x1e8>
  10ab5a:	4619      	mov	r1, r3
  10ab5c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10ab60:	f802 1b01 	strb.w	r1, [r2], #1
  10ab64:	f10c 0c01 	add.w	r12, r12, #1
  10ab68:	2b00      	cmp	r3, #0
  10ab6a:	d1f6      	bne.n	10ab5a <double_to_string.constprop.2+0x1e2>
  10ab6c:	e744      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  10ab6e:	2144      	movs	r1, #68	; 0x44
  10ab70:	eb04 020c 	add.w	r2, r4, r12
  10ab74:	2345      	movs	r3, #69	; 0x45
  10ab76:	f10c 0c01 	add.w	r12, r12, #1
  10ab7a:	482c      	ldr	r0, [pc, #176]	; (10ac2c <double_to_string.constprop.2+0x2b4>)
  10ab7c:	f802 1b01 	strb.w	r1, [r2], #1
  10ab80:	2b00      	cmp	r3, #0
  10ab82:	f43f af39 	beq.w	10a9f8 <double_to_string.constprop.2+0x80>
  10ab86:	4619      	mov	r1, r3
  10ab88:	f10c 0c01 	add.w	r12, r12, #1
  10ab8c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  10ab90:	f802 1b01 	strb.w	r1, [r2], #1
  10ab94:	2b00      	cmp	r3, #0
  10ab96:	d1f6      	bne.n	10ab86 <double_to_string.constprop.2+0x20e>
  10ab98:	e72e      	b.n	10a9f8 <double_to_string.constprop.2+0x80>
                u |= (1ULL<<52);
  10ab9a:	4693      	mov	r11, r2
  10ab9c:	f443 1c80 	orr.w	r12, r3, #1048576	; 0x100000
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10aba0:	f04f 0e19 	mov.w	r14, #25
                u >>= (52 - exponent_signed);
  10aba4:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
  10aba8:	e9cd bc04 	strd	r11, r12, [r13, #16]
  10abac:	f1c5 0020 	rsb	r0, r5, #32
  10abb0:	9b05      	ldr	r3, [sp, #20]
  10abb2:	fa0c f000 	lsl.w	r0, r12, r0
  10abb6:	fa22 fb05 	lsr.w	r11, r2, r5
  10abba:	f1a5 0220 	sub.w	r2, r5, #32
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abbe:	f10d 0c20 	add.w	r12, r13, #32
                u >>= (52 - exponent_signed);
  10abc2:	fa23 f202 	lsr.w	r2, r3, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abc6:	9101      	str	r1, [sp, #4]
                u >>= (52 - exponent_signed);
  10abc8:	ea4b 0b00 	orr.w	r11, r11, r0
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abcc:	2000      	movs	r0, #0
                u >>= (52 - exponent_signed);
  10abce:	ea4b 0b02 	orr.w	r11, r11, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abd2:	465a      	mov	r2, r11
                u >>= (52 - exponent_signed);
  10abd4:	40eb      	lsrs	r3, r5
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abd6:	f80c 0d01 	strb.w	r0, [r12, #-1]!
  10abda:	4620      	mov	r0, r4
  10abdc:	f8cd c008 	str.w	r12, [r13, #8]
                u >>= (52 - exponent_signed);
  10abe0:	461d      	mov	r5, r3
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  10abe2:	f8cd e000 	str.w	r14, [r13]
  10abe6:	f7ff fc9d 	bl	10a524 <longlong_to_string>
  10abea:	4629      	mov	r1, r5
                pos = s - buf;
  10abec:	1b05      	subs	r5, r0, r4
  10abee:	4658      	mov	r0, r11
  10abf0:	f000 fffc 	bl	10bbec <__aeabi_ul2d>
  10abf4:	ec47 6b17 	vmov	d7, r6, r7
  10abf8:	ec41 0b16 	vmov	d6, r0, r1
  10abfc:	ee37 7b46 	vsub.f64	d7, d7, d6
  10ac00:	ec57 6b17 	vmov	r6, r7, d7
  10ac04:	e761      	b.n	10aaca <double_to_string.constprop.2+0x152>
  10ac06:	bf00      	nop
  10ac08:	00000000 	.word	0x00000000
  10ac0c:	412e8480 	.word	0x412e8480
  10ac10:	00111ded 	.word	0x00111ded
  10ac14:	00111e09 	.word	0x00111e09
  10ac18:	00111dcd 	.word	0x00111dcd
  10ac1c:	00111dd5 	.word	0x00111dd5
  10ac20:	00111dfd 	.word	0x00111dfd
  10ac24:	00111dd9 	.word	0x00111dd9
  10ac28:	00111dd1 	.word	0x00111dd1
  10ac2c:	00111df1 	.word	0x00111df1

0010ac30 <_printf_engine>:
#include <kernel/spinlock.h>
static spin_lock_t printf_lock=SPIN_LOCK_INITIAL_VALUE;
#endif

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
  10ac30:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
                OUTPUT_CHAR(uc);
                break;
            case 's':
                s = va_arg(ap, const char *);
                if (s == 0)
                    s = "<null>";
  10ac34:	f641 54c4 	movw	r4, #7620	; 0x1dc4
{
  10ac38:	b093      	sub	sp, #76	; 0x4c
  10ac3a:	4607      	mov	r7, r0
                    s = "<null>";
  10ac3c:	f2c0 0411 	movt	r4, #17
    size_t chars_written = 0;
  10ac40:	2600      	movs	r6, #0
{
  10ac42:	4688      	mov	r8, r1
  10ac44:	4610      	mov	r0, r2
  10ac46:	469b      	mov	r11, r3
                    s = "<null>";
  10ac48:	9406      	str	r4, [sp, #24]
        signchar = '\0';
  10ac4a:	f04f 0300 	mov.w	r3, #0
        while ((c = *fmt++) != 0) {
  10ac4e:	1c44      	adds	r4, r0, #1
  10ac50:	7801      	ldrb	r1, [r0, #0]
        signchar = '\0';
  10ac52:	f88d 3027 	strb.w	r3, [r13, #39]	; 0x27
        while ((c = *fmt++) != 0) {
  10ac56:	b149      	cbz	r1, 10ac6c <_printf_engine+0x3c>
            if (c == '%')
  10ac58:	2925      	cmp	r1, #37	; 0x25
  10ac5a:	d102      	bne.n	10ac62 <_printf_engine+0x32>
  10ac5c:	e010      	b.n	10ac80 <_printf_engine+0x50>
  10ac5e:	2b25      	cmp	r3, #37	; 0x25
  10ac60:	d00f      	beq.n	10ac82 <_printf_engine+0x52>
  10ac62:	1a21      	subs	r1, r4, r0
        while ((c = *fmt++) != 0) {
  10ac64:	f814 3b01 	ldrb.w	r3, [r4], #1
  10ac68:	2b00      	cmp	r3, #0
  10ac6a:	d1f8      	bne.n	10ac5e <_printf_engine+0x2e>
        OUTPUT_STRING(s, string_len);
  10ac6c:	4642      	mov	r2, r8
  10ac6e:	47b8      	blx	r7
  10ac70:	f1b0 0c00 	subs.w	r12, r0, #0
  10ac74:	f280 80d0 	bge.w	10ae18 <_printf_engine+0x1e8>
exit:
#if WITH_SMP
    spin_unlock_irqrestore(&printf_lock, sstate);
#endif
    return (err < 0) ? err : (int)chars_written;
}
  10ac78:	4660      	mov	r0, r12
  10ac7a:	b013      	add	sp, #76	; 0x4c
  10ac7c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        string_len = 0;
  10ac80:	2100      	movs	r1, #0
        OUTPUT_STRING(s, string_len);
  10ac82:	4642      	mov	r2, r8
  10ac84:	47b8      	blx	r7
  10ac86:	f1b0 0c00 	subs.w	r12, r0, #0
  10ac8a:	dbf5      	blt.n	10ac78 <_printf_engine+0x48>
        format_num = 0;
  10ac8c:	2500      	movs	r5, #0
        OUTPUT_STRING(s, string_len);
  10ac8e:	4466      	add	r6, r12
        flags = 0;
  10ac90:	46aa      	mov	r10, r5
        c = *fmt++;
  10ac92:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c == 0)
  10ac96:	2b00      	cmp	r3, #0
  10ac98:	f000 80bf 	beq.w	10ae1a <_printf_engine+0x1ea>
        switch (c) {
  10ac9c:	f1a3 0220 	sub.w	r2, r3, #32
  10aca0:	2a5a      	cmp	r2, #90	; 0x5a
  10aca2:	f200 821d 	bhi.w	10b0e0 <_printf_engine+0x4b0>
  10aca6:	a101      	add	r1, pc, #4	; (adr r1, 10acac <_printf_engine+0x7c>)
  10aca8:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
  10acac:	0010afd1 	.word	0x0010afd1
  10acb0:	0010b0e1 	.word	0x0010b0e1
  10acb4:	0010b0e1 	.word	0x0010b0e1
  10acb8:	0010afff 	.word	0x0010afff
  10acbc:	0010b0e1 	.word	0x0010b0e1
  10acc0:	0010afdd 	.word	0x0010afdd
  10acc4:	0010b0e1 	.word	0x0010b0e1
  10acc8:	0010b0e1 	.word	0x0010b0e1
  10accc:	0010b0e1 	.word	0x0010b0e1
  10acd0:	0010b0e1 	.word	0x0010b0e1
  10acd4:	0010b0e1 	.word	0x0010b0e1
  10acd8:	0010aff9 	.word	0x0010aff9
  10acdc:	0010b0e1 	.word	0x0010b0e1
  10ace0:	0010b005 	.word	0x0010b005
  10ace4:	0010ac93 	.word	0x0010ac93
  10ace8:	0010b0e1 	.word	0x0010b0e1
  10acec:	0010b00b 	.word	0x0010b00b
  10acf0:	0010b00b 	.word	0x0010b00b
  10acf4:	0010b00b 	.word	0x0010b00b
  10acf8:	0010b00b 	.word	0x0010b00b
  10acfc:	0010b00b 	.word	0x0010b00b
  10ad00:	0010b00b 	.word	0x0010b00b
  10ad04:	0010b00b 	.word	0x0010b00b
  10ad08:	0010b00b 	.word	0x0010b00b
  10ad0c:	0010b00b 	.word	0x0010b00b
  10ad10:	0010b00b 	.word	0x0010b00b
  10ad14:	0010b0e1 	.word	0x0010b0e1
  10ad18:	0010b0e1 	.word	0x0010b0e1
  10ad1c:	0010b0e1 	.word	0x0010b0e1
  10ad20:	0010b0e1 	.word	0x0010b0e1
  10ad24:	0010b0e1 	.word	0x0010b0e1
  10ad28:	0010b0e1 	.word	0x0010b0e1
  10ad2c:	0010b0e1 	.word	0x0010b0e1
  10ad30:	0010af6b 	.word	0x0010af6b
  10ad34:	0010b0e1 	.word	0x0010b0e1
  10ad38:	0010b0e1 	.word	0x0010b0e1
  10ad3c:	0010b0e1 	.word	0x0010b0e1
  10ad40:	0010b0e1 	.word	0x0010b0e1
  10ad44:	0010af09 	.word	0x0010af09
  10ad48:	0010b0e1 	.word	0x0010b0e1
  10ad4c:	0010b0e1 	.word	0x0010b0e1
  10ad50:	0010b0e1 	.word	0x0010b0e1
  10ad54:	0010b0e1 	.word	0x0010b0e1
  10ad58:	0010b0e1 	.word	0x0010b0e1
  10ad5c:	0010b0e1 	.word	0x0010b0e1
  10ad60:	0010b0e1 	.word	0x0010b0e1
  10ad64:	0010b0e1 	.word	0x0010b0e1
  10ad68:	0010b0e1 	.word	0x0010b0e1
  10ad6c:	0010b0e1 	.word	0x0010b0e1
  10ad70:	0010b0e1 	.word	0x0010b0e1
  10ad74:	0010b0e1 	.word	0x0010b0e1
  10ad78:	0010b0e1 	.word	0x0010b0e1
  10ad7c:	0010b0e1 	.word	0x0010b0e1
  10ad80:	0010b0e1 	.word	0x0010b0e1
  10ad84:	0010b0e1 	.word	0x0010b0e1
  10ad88:	0010b0e1 	.word	0x0010b0e1
  10ad8c:	0010b0b7 	.word	0x0010b0b7
  10ad90:	0010b0e1 	.word	0x0010b0e1
  10ad94:	0010b0e1 	.word	0x0010b0e1
  10ad98:	0010b0e1 	.word	0x0010b0e1
  10ad9c:	0010b0e1 	.word	0x0010b0e1
  10ada0:	0010b0e1 	.word	0x0010b0e1
  10ada4:	0010b0e1 	.word	0x0010b0e1
  10ada8:	0010b0e1 	.word	0x0010b0e1
  10adac:	0010b0e1 	.word	0x0010b0e1
  10adb0:	0010af6f 	.word	0x0010af6f
  10adb4:	0010b0e1 	.word	0x0010b0e1
  10adb8:	0010b025 	.word	0x0010b025
  10adbc:	0010b047 	.word	0x0010b047
  10adc0:	0010b0e1 	.word	0x0010b0e1
  10adc4:	0010af0d 	.word	0x0010af0d
  10adc8:	0010b0e1 	.word	0x0010b0e1
  10adcc:	0010b085 	.word	0x0010b085
  10add0:	0010b047 	.word	0x0010b047
  10add4:	0010b0c5 	.word	0x0010b0c5
  10add8:	0010b0e1 	.word	0x0010b0e1
  10addc:	0010b0cb 	.word	0x0010b0cb
  10ade0:	0010b0e1 	.word	0x0010b0e1
  10ade4:	0010af91 	.word	0x0010af91
  10ade8:	0010b0e1 	.word	0x0010b0e1
  10adec:	0010ae25 	.word	0x0010ae25
  10adf0:	0010b0e1 	.word	0x0010b0e1
  10adf4:	0010b0e1 	.word	0x0010b0e1
  10adf8:	0010b069 	.word	0x0010b069
  10adfc:	0010b0db 	.word	0x0010b0db
  10ae00:	0010b095 	.word	0x0010b095
  10ae04:	0010b0e1 	.word	0x0010b0e1
  10ae08:	0010b0e1 	.word	0x0010b0e1
  10ae0c:	0010ae29 	.word	0x0010ae29
  10ae10:	0010b0e1 	.word	0x0010b0e1
  10ae14:	0010afd7 	.word	0x0010afd7
        OUTPUT_STRING(s, string_len);
  10ae18:	4466      	add	r6, r12
    return (err < 0) ? err : (int)chars_written;
  10ae1a:	46b4      	mov	r12, r6
}
  10ae1c:	4660      	mov	r0, r12
  10ae1e:	b013      	add	sp, #76	; 0x4c
  10ae20:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= LONGFLAG | ALTFLAG;
  10ae24:	f04a 0a81 	orr.w	r10, r10, #129	; 0x81
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  10ae28:	f01a 0f02 	tst.w	r10, #2
  10ae2c:	f000 80be 	beq.w	10afac <_printf_engine+0x37c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10ae30:	f10b 0307 	add.w	r3, r11, #7
  10ae34:	f023 0307 	bic.w	r3, r3, #7
  10ae38:	f103 0b08 	add.w	r11, r3, #8
  10ae3c:	e9d3 2300 	ldrd	r2, r3, [r3]
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  10ae40:	f8cd a000 	str.w	r10, [r13]
  10ae44:	a80a      	add	r0, sp, #40	; 0x28
  10ae46:	f7ff fd6d 	bl	10a924 <longlong_to_hexstring.constprop.1>
                if (flags & ALTFLAG) {
  10ae4a:	f01a 0f80 	tst.w	r10, #128	; 0x80
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  10ae4e:	9005      	str	r0, [sp, #20]
  10ae50:	4681      	mov	r9, r0
                if (flags & ALTFLAG) {
  10ae52:	f000 81b1 	beq.w	10b1b8 <_printf_engine+0x588>
                    OUTPUT_CHAR('0');
  10ae56:	2330      	movs	r3, #48	; 0x30
  10ae58:	4642      	mov	r2, r8
  10ae5a:	2101      	movs	r1, #1
  10ae5c:	a809      	add	r0, sp, #36	; 0x24
  10ae5e:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  10ae62:	47b8      	blx	r7
  10ae64:	f1b0 0c00 	subs.w	r12, r0, #0
  10ae68:	f6ff af06 	blt.w	10ac78 <_printf_engine+0x48>
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  10ae6c:	4642      	mov	r2, r8
  10ae6e:	f41a 7f80 	tst.w	r10, #256	; 0x100
  10ae72:	bf0c      	ite	eq
  10ae74:	2378      	moveq	r3, #120	; 0x78
  10ae76:	2358      	movne	r3, #88	; 0x58
  10ae78:	2101      	movs	r1, #1
  10ae7a:	a809      	add	r0, sp, #36	; 0x24
  10ae7c:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                    OUTPUT_CHAR('0');
  10ae80:	4466      	add	r6, r12
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  10ae82:	47b8      	blx	r7
  10ae84:	f1b0 0c00 	subs.w	r12, r0, #0
  10ae88:	f6ff aef6 	blt.w	10ac78 <_printf_engine+0x48>
  10ae8c:	4648      	mov	r0, r9
  10ae8e:	4466      	add	r6, r12
  10ae90:	f000 fa46 	bl	10b320 <strlen>
        if (flags & LEFTFORMATFLAG) {
  10ae94:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  10ae98:	4681      	mov	r9, r0
  10ae9a:	d14a      	bne.n	10af32 <_printf_engine+0x302>
  10ae9c:	f40a 5380 	and.w	r3, r10, #4096	; 0x1000
  10aea0:	461a      	mov	r2, r3
  10aea2:	9307      	str	r3, [sp, #28]
            if (signchar != '\0' && format_num > 0)
  10aea4:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
  10aea8:	b18b      	cbz	r3, 10aece <_printf_engine+0x29e>
  10aeaa:	2d00      	cmp	r5, #0
  10aeac:	f000 8143 	beq.w	10b136 <_printf_engine+0x506>
                format_num--;
  10aeb0:	3d01      	subs	r5, #1
            if (flags & LEADZEROFLAG && signchar != '\0')
  10aeb2:	2a00      	cmp	r2, #0
  10aeb4:	f000 81d4 	beq.w	10b260 <_printf_engine+0x630>
                OUTPUT_CHAR(signchar);
  10aeb8:	4642      	mov	r2, r8
  10aeba:	2101      	movs	r1, #1
  10aebc:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  10aec0:	a809      	add	r0, sp, #36	; 0x24
  10aec2:	47b8      	blx	r7
  10aec4:	f1b0 0c00 	subs.w	r12, r0, #0
  10aec8:	f6ff aed6 	blt.w	10ac78 <_printf_engine+0x48>
  10aecc:	4466      	add	r6, r12
            for (; format_num > string_len; format_num--)
  10aece:	454d      	cmp	r5, r9
  10aed0:	f240 811f 	bls.w	10b112 <_printf_engine+0x4e2>
  10aed4:	9b07      	ldr	r3, [sp, #28]
  10aed6:	2b00      	cmp	r3, #0
  10aed8:	bf14      	ite	ne
  10aeda:	f04f 0a30 	movne.w	r10, #48	; 0x30
  10aede:	f04f 0a20 	moveq.w	r10, #32
  10aee2:	e002      	b.n	10aeea <_printf_engine+0x2ba>
  10aee4:	454d      	cmp	r5, r9
  10aee6:	f000 8114 	beq.w	10b112 <_printf_engine+0x4e2>
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  10aeea:	4642      	mov	r2, r8
  10aeec:	2101      	movs	r1, #1
  10aeee:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  10aef2:	a809      	add	r0, sp, #36	; 0x24
  10aef4:	47b8      	blx	r7
            for (; format_num > string_len; format_num--)
  10aef6:	3d01      	subs	r5, #1
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  10aef8:	2800      	cmp	r0, #0
  10aefa:	4406      	add	r6, r0
  10aefc:	daf2      	bge.n	10aee4 <_printf_engine+0x2b4>
  10aefe:	4684      	mov	r12, r0
}
  10af00:	4660      	mov	r0, r12
  10af02:	b013      	add	sp, #76	; 0x4c
  10af04:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= CAPSFLAG;
  10af08:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  10af0c:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  10af0e:	f10b 0b07 	add.w	r11, r11, #7
  10af12:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  10af16:	a80a      	add	r0, sp, #40	; 0x28
  10af18:	ed9b 0b00 	vldr	d0, [r11]
  10af1c:	f7ff fd2c 	bl	10a978 <double_to_string.constprop.2>
                double d = va_arg(ap, double);
  10af20:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  10af24:	9005      	str	r0, [sp, #20]
  10af26:	f000 f9fb 	bl	10b320 <strlen>
  10af2a:	4681      	mov	r9, r0
        if (flags & LEFTFORMATFLAG) {
  10af2c:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  10af30:	d0b4      	beq.n	10ae9c <_printf_engine+0x26c>
            OUTPUT_STRING(s, string_len);
  10af32:	4649      	mov	r1, r9
  10af34:	4642      	mov	r2, r8
  10af36:	9805      	ldr	r0, [sp, #20]
  10af38:	47b8      	blx	r7
  10af3a:	f1b0 0c00 	subs.w	r12, r0, #0
  10af3e:	f6ff ae9b 	blt.w	10ac78 <_printf_engine+0x48>
  10af42:	46e1      	mov	r9, r12
            for (; format_num > written; format_num--)
  10af44:	45ac      	cmp	r12, r5
            OUTPUT_STRING(s, string_len);
  10af46:	4466      	add	r6, r12
            for (; format_num > written; format_num--)
  10af48:	d22e      	bcs.n	10afa8 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  10af4a:	f04f 0a20 	mov.w	r10, #32
  10af4e:	e001      	b.n	10af54 <_printf_engine+0x324>
            for (; format_num > written; format_num--)
  10af50:	45a9      	cmp	r9, r5
  10af52:	d029      	beq.n	10afa8 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  10af54:	4642      	mov	r2, r8
  10af56:	2101      	movs	r1, #1
  10af58:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  10af5c:	a809      	add	r0, sp, #36	; 0x24
  10af5e:	47b8      	blx	r7
            for (; format_num > written; format_num--)
  10af60:	3d01      	subs	r5, #1
                OUTPUT_CHAR(' ');
  10af62:	2800      	cmp	r0, #0
  10af64:	4406      	add	r6, r0
  10af66:	daf3      	bge.n	10af50 <_printf_engine+0x320>
  10af68:	e7c9      	b.n	10aefe <_printf_engine+0x2ce>
                flags |= CAPSFLAG;
  10af6a:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  10af6e:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  10af70:	f10b 0b07 	add.w	r11, r11, #7
  10af74:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  10af78:	a80a      	add	r0, sp, #40	; 0x28
  10af7a:	ed9b 0b00 	vldr	d0, [r11]
  10af7e:	f7ff fb61 	bl	10a644 <double_to_hexstring.isra.0>
                double d = va_arg(ap, double);
  10af82:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  10af86:	9005      	str	r0, [sp, #20]
  10af88:	f000 f9ca 	bl	10b320 <strlen>
  10af8c:	4681      	mov	r9, r0
                goto _output_string;
  10af8e:	e7cd      	b.n	10af2c <_printf_engine+0x2fc>
                if (flags & LONGLONGFLAG)
  10af90:	f01a 0f02 	tst.w	r10, #2
                ptr = va_arg(ap, void *);
  10af94:	f8db 3000 	ldr.w	r3, [r11]
  10af98:	f10b 0204 	add.w	r2, r11, #4
                if (flags & LONGLONGFLAG)
  10af9c:	f000 80f7 	beq.w	10b18e <_printf_engine+0x55e>
                    *(long long *)ptr = chars_written;
  10afa0:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  10afa2:	4693      	mov	r11, r2
                    *(long long *)ptr = chars_written;
  10afa4:	2200      	movs	r2, #0
  10afa6:	605a      	str	r2, [r3, #4]
                ptr = va_arg(ap, void *);
  10afa8:	4620      	mov	r0, r4
  10afaa:	e64e      	b.n	10ac4a <_printf_engine+0x1a>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10afac:	f01a 0f01 	tst.w	r10, #1
  10afb0:	f040 80bb 	bne.w	10b12a <_printf_engine+0x4fa>
  10afb4:	f01a 0f08 	tst.w	r10, #8
  10afb8:	f040 8102 	bne.w	10b1c0 <_printf_engine+0x590>
  10afbc:	f01a 0f04 	tst.w	r10, #4
  10afc0:	f000 8115 	beq.w	10b1ee <_printf_engine+0x5be>
  10afc4:	f8bb 2000 	ldrh.w	r2, [r11]
  10afc8:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  10afca:	f10b 0b04 	add.w	r11, r11, #4
  10afce:	e737      	b.n	10ae40 <_printf_engine+0x210>
                flags |= BLANKPOSFLAG;
  10afd0:	f44a 5a00 	orr.w	r10, r10, #8192	; 0x2000
                goto next_format;
  10afd4:	e65d      	b.n	10ac92 <_printf_engine+0x62>
                flags |= SIZETFLAG;
  10afd6:	f04a 0a10 	orr.w	r10, r10, #16
                goto next_format;
  10afda:	e65a      	b.n	10ac92 <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  10afdc:	2325      	movs	r3, #37	; 0x25
  10afde:	4642      	mov	r2, r8
  10afe0:	2101      	movs	r1, #1
  10afe2:	a809      	add	r0, sp, #36	; 0x24
  10afe4:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  10afe8:	47b8      	blx	r7
  10afea:	f1b0 0c00 	subs.w	r12, r0, #0
  10afee:	f6ff ae43 	blt.w	10ac78 <_printf_engine+0x48>
                OUTPUT_CHAR(c);
  10aff2:	4466      	add	r6, r12
                ptr = va_arg(ap, void *);
  10aff4:	4620      	mov	r0, r4
  10aff6:	e628      	b.n	10ac4a <_printf_engine+0x1a>
                flags |= SHOWSIGNFLAG;
  10aff8:	f44a 7a00 	orr.w	r10, r10, #512	; 0x200
                goto next_format;
  10affc:	e649      	b.n	10ac92 <_printf_engine+0x62>
                flags |= ALTFLAG;
  10affe:	f04a 0a80 	orr.w	r10, r10, #128	; 0x80
                goto next_format;
  10b002:	e646      	b.n	10ac92 <_printf_engine+0x62>
                flags |= LEFTFORMATFLAG;
  10b004:	f44a 6a00 	orr.w	r10, r10, #2048	; 0x800
                goto next_format;
  10b008:	e643      	b.n	10ac92 <_printf_engine+0x62>
                if (c == '0' && format_num == 0)
  10b00a:	2b30      	cmp	r3, #48	; 0x30
  10b00c:	bf08      	it	eq
  10b00e:	2d00      	cmpeq	r5, #0
                format_num *= 10;
  10b010:	eb05 0585 	add.w	r5, r5, r5, lsl #2
                format_num += c - '0';
  10b014:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
                    flags |= LEADZEROFLAG;
  10b018:	bf08      	it	eq
  10b01a:	f44a 5a80 	orreq.w	r10, r10, #4096	; 0x1000
                format_num += c - '0';
  10b01e:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                goto next_format;
  10b022:	e636      	b.n	10ac92 <_printf_engine+0x62>
                uc = va_arg(ap, unsigned int);
  10b024:	f8db 3000 	ldr.w	r3, [r11]
                OUTPUT_CHAR(uc);
  10b028:	4642      	mov	r2, r8
  10b02a:	2101      	movs	r1, #1
  10b02c:	a809      	add	r0, sp, #36	; 0x24
                uc = va_arg(ap, unsigned int);
  10b02e:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                OUTPUT_CHAR(uc);
  10b032:	47b8      	blx	r7
  10b034:	f1b0 0c00 	subs.w	r12, r0, #0
  10b038:	f6ff ae1e 	blt.w	10ac78 <_printf_engine+0x48>
                uc = va_arg(ap, unsigned int);
  10b03c:	f10b 0b04 	add.w	r11, r11, #4
                ptr = va_arg(ap, void *);
  10b040:	4620      	mov	r0, r4
                OUTPUT_CHAR(uc);
  10b042:	4466      	add	r6, r12
  10b044:	e601      	b.n	10ac4a <_printf_engine+0x1a>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b046:	f01a 0f02 	tst.w	r10, #2
  10b04a:	d17f      	bne.n	10b14c <_printf_engine+0x51c>
  10b04c:	f01a 0f01 	tst.w	r10, #1
  10b050:	f040 80bc 	bne.w	10b1cc <_printf_engine+0x59c>
  10b054:	f01a 0f08 	tst.w	r10, #8
  10b058:	f000 80ed 	beq.w	10b236 <_printf_engine+0x606>
  10b05c:	f99b 2000 	ldrsb.w	r2, [r11]
                    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
  10b060:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b064:	17d3      	asrs	r3, r2, #31
  10b066:	e079      	b.n	10b15c <_printf_engine+0x52c>
                s = va_arg(ap, const char *);
  10b068:	f8db 0000 	ldr.w	r0, [r11]
  10b06c:	f10b 0b04 	add.w	r11, r11, #4
  10b070:	9005      	str	r0, [sp, #20]
                if (s == 0)
  10b072:	2800      	cmp	r0, #0
  10b074:	f000 80b6 	beq.w	10b1e4 <_printf_engine+0x5b4>
  10b078:	f000 f952 	bl	10b320 <strlen>
  10b07c:	4681      	mov	r9, r0
                flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
  10b07e:	f42a 5a80 	bic.w	r10, r10, #4096	; 0x1000
                goto _output_string;
  10b082:	e753      	b.n	10af2c <_printf_engine+0x2fc>
                if (flags & HALFFLAG)
  10b084:	f01a 0f04 	tst.w	r10, #4
                    flags |= HALFHALFFLAG;
  10b088:	bf18      	it	ne
  10b08a:	f04a 0a08 	orrne.w	r10, r10, #8
                flags |= HALFFLAG;
  10b08e:	f04a 0a04 	orr.w	r10, r10, #4
                goto next_format;
  10b092:	e5fe      	b.n	10ac92 <_printf_engine+0x62>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  10b094:	f01a 0f02 	tst.w	r10, #2
  10b098:	d170      	bne.n	10b17c <_printf_engine+0x54c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b09a:	f01a 0f01 	tst.w	r10, #1
  10b09e:	f040 809b 	bne.w	10b1d8 <_printf_engine+0x5a8>
  10b0a2:	f01a 0f08 	tst.w	r10, #8
  10b0a6:	f000 80bd 	beq.w	10b224 <_printf_engine+0x5f4>
  10b0aa:	f89b 2000 	ldrb.w	r2, [r11]
  10b0ae:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  10b0b0:	f10b 0b04 	add.w	r11, r11, #4
  10b0b4:	e054      	b.n	10b160 <_printf_engine+0x530>
                flags |= CAPSFLAG;
  10b0b6:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  10b0ba:	f01a 0f02 	tst.w	r10, #2
  10b0be:	f43f af75 	beq.w	10afac <_printf_engine+0x37c>
  10b0c2:	e6b5      	b.n	10ae30 <_printf_engine+0x200>
                flags |= INTMAXFLAG;
  10b0c4:	f04a 0a20 	orr.w	r10, r10, #32
                goto next_format;
  10b0c8:	e5e3      	b.n	10ac92 <_printf_engine+0x62>
                if (flags & LONGFLAG)
  10b0ca:	f01a 0f01 	tst.w	r10, #1
                    flags |= LONGLONGFLAG;
  10b0ce:	bf18      	it	ne
  10b0d0:	f04a 0a02 	orrne.w	r10, r10, #2
                flags |= LONGFLAG;
  10b0d4:	f04a 0a01 	orr.w	r10, r10, #1
                goto next_format;
  10b0d8:	e5db      	b.n	10ac92 <_printf_engine+0x62>
                flags |= PTRDIFFFLAG;
  10b0da:	f04a 0a40 	orr.w	r10, r10, #64	; 0x40
                goto next_format;
  10b0de:	e5d8      	b.n	10ac92 <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  10b0e0:	2525      	movs	r5, #37	; 0x25
  10b0e2:	4642      	mov	r2, r8
  10b0e4:	9305      	str	r3, [sp, #20]
  10b0e6:	2101      	movs	r1, #1
  10b0e8:	f88d 5024 	strb.w	r5, [r13, #36]	; 0x24
  10b0ec:	a809      	add	r0, sp, #36	; 0x24
  10b0ee:	47b8      	blx	r7
  10b0f0:	1e05      	subs	r5, r0, #0
  10b0f2:	f2c0 80b3 	blt.w	10b25c <_printf_engine+0x62c>
                OUTPUT_CHAR(c);
  10b0f6:	9b05      	ldr	r3, [sp, #20]
  10b0f8:	4642      	mov	r2, r8
  10b0fa:	2101      	movs	r1, #1
  10b0fc:	a809      	add	r0, sp, #36	; 0x24
  10b0fe:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  10b102:	47b8      	blx	r7
  10b104:	f1b0 0c00 	subs.w	r12, r0, #0
  10b108:	f6ff adb6 	blt.w	10ac78 <_printf_engine+0x48>
                OUTPUT_CHAR('%');
  10b10c:	442e      	add	r6, r5
                OUTPUT_CHAR(c);
  10b10e:	4466      	add	r6, r12
  10b110:	e770      	b.n	10aff4 <_printf_engine+0x3c4>
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  10b112:	9b07      	ldr	r3, [sp, #28]
  10b114:	2b00      	cmp	r3, #0
  10b116:	d075      	beq.n	10b204 <_printf_engine+0x5d4>
            OUTPUT_STRING(s, string_len);
  10b118:	4649      	mov	r1, r9
  10b11a:	4642      	mov	r2, r8
  10b11c:	9805      	ldr	r0, [sp, #20]
  10b11e:	47b8      	blx	r7
  10b120:	f1b0 0c00 	subs.w	r12, r0, #0
  10b124:	f6ff ada8 	blt.w	10ac78 <_printf_engine+0x48>
  10b128:	e763      	b.n	10aff2 <_printf_engine+0x3c2>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b12a:	f8db 2000 	ldr.w	r2, [r11]
  10b12e:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  10b130:	f10b 0b04 	add.w	r11, r11, #4
  10b134:	e684      	b.n	10ae40 <_printf_engine+0x210>
            if (flags & LEADZEROFLAG && signchar != '\0')
  10b136:	9a07      	ldr	r2, [sp, #28]
  10b138:	2a00      	cmp	r2, #0
  10b13a:	f47f aebd 	bne.w	10aeb8 <_printf_engine+0x288>
  10b13e:	e065      	b.n	10b20c <_printf_engine+0x5dc>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b140:	f01a 0f10 	tst.w	r10, #16
  10b144:	d142      	bne.n	10b1cc <_printf_engine+0x59c>
  10b146:	f01a 0f20 	tst.w	r10, #32
  10b14a:	d03f      	beq.n	10b1cc <_printf_engine+0x59c>
                    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
  10b14c:	f10b 0307 	add.w	r3, r11, #7
  10b150:	f023 0307 	bic.w	r3, r3, #7
  10b154:	f103 0b08 	add.w	r11, r3, #8
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b158:	e9d3 2300 	ldrd	r2, r3, [r3]
                flags |= SIGNEDFLAG;
  10b15c:	f44a 6a80 	orr.w	r10, r10, #1024	; 0x400
                s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
  10b160:	2120      	movs	r1, #32
  10b162:	f10d 0027 	add.w	r0, r13, #39	; 0x27
  10b166:	9100      	str	r1, [sp, #0]
  10b168:	e9cd a001 	strd	r10, r0, [r13, #4]
  10b16c:	a80a      	add	r0, sp, #40	; 0x28
  10b16e:	f7ff f9d9 	bl	10a524 <longlong_to_string>
  10b172:	9005      	str	r0, [sp, #20]
  10b174:	f000 f8d4 	bl	10b320 <strlen>
  10b178:	4681      	mov	r9, r0
                goto _output_string;
  10b17a:	e6d7      	b.n	10af2c <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b17c:	f10b 0307 	add.w	r3, r11, #7
  10b180:	f023 0307 	bic.w	r3, r3, #7
  10b184:	f103 0b08 	add.w	r11, r3, #8
  10b188:	e9d3 2300 	ldrd	r2, r3, [r3]
  10b18c:	e7e8      	b.n	10b160 <_printf_engine+0x530>
                else if (flags & LONGFLAG)
  10b18e:	f01a 0f01 	tst.w	r10, #1
  10b192:	d10d      	bne.n	10b1b0 <_printf_engine+0x580>
                else if (flags & HALFHALFFLAG)
  10b194:	f01a 0f08 	tst.w	r10, #8
                ptr = va_arg(ap, void *);
  10b198:	bf1c      	itt	ne
  10b19a:	4693      	movne	r11, r2
                    *(signed char *)ptr = chars_written;
  10b19c:	701e      	strbne	r6, [r3, #0]
                else if (flags & HALFHALFFLAG)
  10b19e:	f47f af03 	bne.w	10afa8 <_printf_engine+0x378>
                else if (flags & HALFFLAG)
  10b1a2:	f01a 0f04 	tst.w	r10, #4
                ptr = va_arg(ap, void *);
  10b1a6:	bf1c      	itt	ne
  10b1a8:	4693      	movne	r11, r2
                    *(short *)ptr = chars_written;
  10b1aa:	801e      	strhne	r6, [r3, #0]
                else if (flags & HALFFLAG)
  10b1ac:	f47f aefc 	bne.w	10afa8 <_printf_engine+0x378>
                    *(int *)ptr = chars_written;
  10b1b0:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  10b1b2:	4693      	mov	r11, r2
  10b1b4:	4620      	mov	r0, r4
  10b1b6:	e548      	b.n	10ac4a <_printf_engine+0x1a>
  10b1b8:	f000 f8b2 	bl	10b320 <strlen>
  10b1bc:	4681      	mov	r9, r0
  10b1be:	e6b5      	b.n	10af2c <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b1c0:	f89b 2000 	ldrb.w	r2, [r11]
  10b1c4:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  10b1c6:	f10b 0b04 	add.w	r11, r11, #4
  10b1ca:	e639      	b.n	10ae40 <_printf_engine+0x210>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b1cc:	f8db 2000 	ldr.w	r2, [r11]
                    va_arg(ap, int);
  10b1d0:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b1d4:	17d3      	asrs	r3, r2, #31
  10b1d6:	e7c1      	b.n	10b15c <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b1d8:	f8db 2000 	ldr.w	r2, [r11]
  10b1dc:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  10b1de:	f10b 0b04 	add.w	r11, r11, #4
  10b1e2:	e7bd      	b.n	10b160 <_printf_engine+0x530>
                    s = "<null>";
  10b1e4:	9b06      	ldr	r3, [sp, #24]
  10b1e6:	f04f 0906 	mov.w	r9, #6
  10b1ea:	9305      	str	r3, [sp, #20]
  10b1ec:	e747      	b.n	10b07e <_printf_engine+0x44e>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b1ee:	f01a 0f10 	tst.w	r10, #16
  10b1f2:	d19a      	bne.n	10b12a <_printf_engine+0x4fa>
  10b1f4:	f01a 0f20 	tst.w	r10, #32
  10b1f8:	f47f ae1a 	bne.w	10ae30 <_printf_engine+0x200>
  10b1fc:	f85b 2b04 	ldr.w	r2, [r11], #4
  10b200:	2300      	movs	r3, #0
  10b202:	e61d      	b.n	10ae40 <_printf_engine+0x210>
  10b204:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  10b208:	2b00      	cmp	r3, #0
  10b20a:	d085      	beq.n	10b118 <_printf_engine+0x4e8>
                OUTPUT_CHAR(signchar);
  10b20c:	4642      	mov	r2, r8
  10b20e:	2101      	movs	r1, #1
  10b210:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  10b214:	a809      	add	r0, sp, #36	; 0x24
  10b216:	47b8      	blx	r7
  10b218:	f1b0 0c00 	subs.w	r12, r0, #0
  10b21c:	f6ff ad2c 	blt.w	10ac78 <_printf_engine+0x48>
  10b220:	4466      	add	r6, r12
  10b222:	e779      	b.n	10b118 <_printf_engine+0x4e8>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b224:	f01a 0f04 	tst.w	r10, #4
  10b228:	d00e      	beq.n	10b248 <_printf_engine+0x618>
  10b22a:	f8bb 2000 	ldrh.w	r2, [r11]
  10b22e:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  10b230:	f10b 0b04 	add.w	r11, r11, #4
  10b234:	e794      	b.n	10b160 <_printf_engine+0x530>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b236:	f01a 0f04 	tst.w	r10, #4
  10b23a:	d081      	beq.n	10b140 <_printf_engine+0x510>
  10b23c:	f9bb 2000 	ldrsh.w	r2, [r11]
                    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
  10b240:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  10b244:	17d3      	asrs	r3, r2, #31
  10b246:	e789      	b.n	10b15c <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  10b248:	f01a 0f10 	tst.w	r10, #16
  10b24c:	d1c4      	bne.n	10b1d8 <_printf_engine+0x5a8>
  10b24e:	f01a 0f20 	tst.w	r10, #32
  10b252:	d193      	bne.n	10b17c <_printf_engine+0x54c>
  10b254:	f85b 2b04 	ldr.w	r2, [r11], #4
  10b258:	2300      	movs	r3, #0
  10b25a:	e781      	b.n	10b160 <_printf_engine+0x530>
                OUTPUT_CHAR('%');
  10b25c:	46ac      	mov	r12, r5
  10b25e:	e50b      	b.n	10ac78 <_printf_engine+0x48>
            for (; format_num > string_len; format_num--)
  10b260:	454d      	cmp	r5, r9
  10b262:	f63f ae37 	bhi.w	10aed4 <_printf_engine+0x2a4>
  10b266:	e7cf      	b.n	10b208 <_printf_engine+0x5d8>

0010b268 <_fprintf_output_func>:

static int _fprintf_output_func(const char *str, size_t len, void *state)
{
    FILE *fp = (FILE *)state;

    return io_write(fp->io, str, len);
  10b268:	6813      	ldr	r3, [r2, #0]
  10b26a:	460a      	mov	r2, r1
  10b26c:	4601      	mov	r1, r0
  10b26e:	4618      	mov	r0, r3
  10b270:	f000 bb2e 	b.w	10b8d0 <io_write>

0010b274 <putchar>:
    return io_write(fp->io, (char *)&c, 1);
  10b274:	f644 13bc 	movw	r3, #18876	; 0x49bc
  10b278:	2201      	movs	r2, #1
{
  10b27a:	b500      	push	{r14}
    return io_write(fp->io, (char *)&c, 1);
  10b27c:	f2c0 0311 	movt	r3, #17
{
  10b280:	b083      	sub	sp, #12
    unsigned char c = _c;
  10b282:	a902      	add	r1, sp, #8
  10b284:	f801 0d01 	strb.w	r0, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
  10b288:	6858      	ldr	r0, [r3, #4]
  10b28a:	f000 fb21 	bl	10b8d0 <io_write>
}
  10b28e:	b003      	add	sp, #12
  10b290:	f85d fb04 	ldr.w	r15, [r13], #4

0010b294 <fputs>:
{
  10b294:	b538      	push	{r3, r4, r5, r14}
  10b296:	460c      	mov	r4, r1
  10b298:	4605      	mov	r5, r0
    size_t len = strlen(s);
  10b29a:	f000 f841 	bl	10b320 <strlen>
    return io_write(fp->io, s, len);
  10b29e:	4629      	mov	r1, r5
  10b2a0:	4602      	mov	r2, r0
  10b2a2:	6820      	ldr	r0, [r4, #0]
}
  10b2a4:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return io_write(fp->io, s, len);
  10b2a8:	f000 bb12 	b.w	10b8d0 <io_write>

0010b2ac <puts>:
{
  10b2ac:	b510      	push	{r4, r14}
    int err = fputs(str, stdout);
  10b2ae:	490a      	ldr	r1, [pc, #40]	; (10b2d8 <puts+0x2c>)
{
  10b2b0:	b082      	sub	sp, #8
    int err = fputs(str, stdout);
  10b2b2:	f7ff ffef 	bl	10b294 <fputs>
    if (err >= 0)
  10b2b6:	2800      	cmp	r0, #0
  10b2b8:	db0b      	blt.n	10b2d2 <puts+0x26>
    return io_write(fp->io, (char *)&c, 1);
  10b2ba:	f644 13bc 	movw	r3, #18876	; 0x49bc
    unsigned char c = _c;
  10b2be:	240a      	movs	r4, #10
    return io_write(fp->io, (char *)&c, 1);
  10b2c0:	f2c0 0311 	movt	r3, #17
  10b2c4:	2201      	movs	r2, #1
    unsigned char c = _c;
  10b2c6:	a902      	add	r1, sp, #8
    return io_write(fp->io, (char *)&c, 1);
  10b2c8:	6858      	ldr	r0, [r3, #4]
    unsigned char c = _c;
  10b2ca:	f801 4d01 	strb.w	r4, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
  10b2ce:	f000 faff 	bl	10b8d0 <io_write>
}
  10b2d2:	b002      	add	sp, #8
  10b2d4:	bd10      	pop	{r4, r15}
  10b2d6:	bf00      	nop
  10b2d8:	001149c0 	.word	0x001149c0

0010b2dc <printf>:
    return err;
}

#if !DISABLE_DEBUG_OUTPUT
int printf(const char *fmt, ...)
{
  10b2dc:	b40f      	push	{r0, r1, r2, r3}
  10b2de:	b510      	push	{r4, r14}
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  10b2e0:	f24b 2069 	movw	r0, #45673	; 0xb269
{
  10b2e4:	b082      	sub	sp, #8
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  10b2e6:	4907      	ldr	r1, [pc, #28]	; (10b304 <printf+0x28>)
{
  10b2e8:	ac04      	add	r4, sp, #16
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  10b2ea:	f2c0 0010 	movt	r0, #16
{
  10b2ee:	f854 2b04 	ldr.w	r2, [r4], #4
    va_list ap;
    int err;

    va_start(ap, fmt);
  10b2f2:	9401      	str	r4, [sp, #4]
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  10b2f4:	4623      	mov	r3, r4
  10b2f6:	f7ff fc9b 	bl	10ac30 <_printf_engine>
    err = vfprintf(stdout, fmt, ap);
    va_end(ap);

    return err;
}
  10b2fa:	b002      	add	sp, #8
  10b2fc:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  10b300:	b004      	add	sp, #16
  10b302:	4770      	bx	r14
  10b304:	001149c0 	.word	0x001149c0

0010b308 <_vprintf>:
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  10b308:	4602      	mov	r2, r0
  10b30a:	f24b 2069 	movw	r0, #45673	; 0xb269
  10b30e:	460b      	mov	r3, r1
  10b310:	f2c0 0010 	movt	r0, #16
  10b314:	4901      	ldr	r1, [pc, #4]	; (10b31c <_vprintf+0x14>)
  10b316:	f7ff bc8b 	b.w	10ac30 <_printf_engine>
  10b31a:	bf00      	nop
  10b31c:	001149c0 	.word	0x001149c0

0010b320 <strlen>:
strlen(char const *s)
{
    size_t i;

    i= 0;
    while (s[i]) {
  10b320:	7803      	ldrb	r3, [r0, #0]
  10b322:	b13b      	cbz	r3, 10b334 <strlen+0x14>
  10b324:	4603      	mov	r3, r0
    i= 0;
  10b326:	2000      	movs	r0, #0
        i+= 1;
  10b328:	3001      	adds	r0, #1
    while (s[i]) {
  10b32a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  10b32e:	2a00      	cmp	r2, #0
  10b330:	d1fa      	bne.n	10b328 <strlen+0x8>
  10b332:	4770      	bx	r14
    i= 0;
  10b334:	4618      	mov	r0, r3
    }

    return i;
}
  10b336:	4770      	bx	r14

0010b338 <platform_mpu_r5_common>:
{
#if ARM_WITH_MPU
    extern addr_t _nocacheable_start;
    extern addr_t _nocacheable_end;

    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  10b338:	f644 4200 	movw	r2, #19456	; 0x4c00
  10b33c:	f644 4100 	movw	r1, #19456	; 0x4c00
  10b340:	f2c0 0211 	movt	r2, #17
  10b344:	f2c0 0111 	movt	r1, #17
  10b348:	1a52      	subs	r2, r2, r1
  10b34a:	2a00      	cmp	r2, #0
{
  10b34c:	b570      	push	{r4, r5, r6, r14}
  10b34e:	4604      	mov	r4, r0
  10b350:	b082      	sub	sp, #8
  10b352:	f100 0501 	add.w	r5, r0, #1
    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  10b356:	dd08      	ble.n	10b36a <platform_mpu_r5_common+0x32>
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
  10b358:	2603      	movs	r6, #3
                       &_nocacheable_end - &_nocacheable_start, MPU_REGION_NORMAL_NONCACHEABLE);
  10b35a:	1092      	asrs	r2, r2, #2
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
  10b35c:	9600      	str	r6, [sp, #0]
  10b35e:	17d3      	asrs	r3, r2, #31
  10b360:	f7f6 f9b2 	bl	1016c8 <mpu_add_region>
  10b364:	1ca3      	adds	r3, r4, #2
  10b366:	462c      	mov	r4, r5
  10b368:	461d      	mov	r5, r3
    }

    mpu_add_region(region++, APB_CKGEN_SEC_BASE, 0x04000000, MPU_REGION_DEVICE);
  10b36a:	2101      	movs	r1, #1
  10b36c:	4620      	mov	r0, r4
  10b36e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  10b372:	2300      	movs	r3, #0
  10b374:	9100      	str	r1, [sp, #0]
  10b376:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  10b37a:	f7f6 f9a5 	bl	1016c8 <mpu_add_region>

#endif
    return region;
}
  10b37e:	4628      	mov	r0, r5
  10b380:	b002      	add	sp, #8
  10b382:	bd70      	pop	{r4, r5, r6, r15}

0010b384 <event_init>:


/*********************** event API redirection *******************/

WRAPPER_FUNCTION void event_init(event_t *e, bool initial, uint flags)
{
  10b384:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10b386:	4614      	mov	r4, r2

    e->pfrts_evt_handle = xQueueCreate(1,0);
  10b388:	2200      	movs	r2, #0
{
  10b38a:	4605      	mov	r5, r0
  10b38c:	460e      	mov	r6, r1
    e->pfrts_evt_handle = xQueueCreate(1,0);
  10b38e:	2001      	movs	r0, #1
  10b390:	4611      	mov	r1, r2
  10b392:	4677      	mov	r7, r14
  10b394:	f7fd f9ee 	bl	108774 <xQueueGenericCreate>
  10b398:	6028      	str	r0, [r5, #0]

    /*as freertos create event group with zero value, if init state
     *was set by parameter, in this place should call make sure the event
     *bit was set before this event to be waiting.
     */
    if(initial)
  10b39a:	b936      	cbnz	r6, 10b3aa <event_init+0x26>
        RESCHED_ASSERT();

        xQueueSend(e->pfrts_evt_handle,NULL,0);
    }

    e->auto_clear = (flags == EVENT_FLAG_AUTOUNSIGNAL ? pdTRUE : pdFALSE);
  10b39c:	f1a4 0401 	sub.w	r4, r4, #1
  10b3a0:	fab4 f484 	clz	r4, r4
  10b3a4:	0964      	lsrs	r4, r4, #5
  10b3a6:	712c      	strb	r4, [r5, #4]
}
  10b3a8:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  10b3aa:	f7fe fc5d 	bl	109c68 <xTaskGetSchedulerState>
  10b3ae:	2801      	cmp	r0, #1
  10b3b0:	d0fa      	beq.n	10b3a8 <event_init+0x24>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10b3b2:	f3ef 8300 	mrs	r3, CPSR
        RESCHED_ASSERT();
  10b3b6:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  10b3ba:	d105      	bne.n	10b3c8 <event_init+0x44>
        xQueueSend(e->pfrts_evt_handle,NULL,0);
  10b3bc:	461a      	mov	r2, r3
  10b3be:	4619      	mov	r1, r3
  10b3c0:	6828      	ldr	r0, [r5, #0]
  10b3c2:	f7fd fa0b 	bl	1087dc <xQueueGenericSend>
  10b3c6:	e7e9      	b.n	10b39c <event_init+0x18>
        RESCHED_ASSERT();
  10b3c8:	f641 6230 	movw	r2, #7728	; 0x1e30
  10b3cc:	f641 6150 	movw	r1, #7760	; 0x1e50
  10b3d0:	4638      	mov	r0, r7
  10b3d2:	f2c0 0211 	movt	r2, #17
  10b3d6:	2321      	movs	r3, #33	; 0x21
  10b3d8:	f2c0 0111 	movt	r1, #17
  10b3dc:	f7fe ff4a 	bl	10a274 <_panic>

0010b3e0 <event_wait_timeout>:
{
    vQueueDelete(e->pfrts_evt_handle);
}

WRAPPER_FUNCTION status_t event_wait_timeout(event_t *e, lk_time_t timeout) /* wait on the event with a timeout */
{
  10b3e0:	b570      	push	{r4, r5, r6, r14}
  10b3e2:	4675      	mov	r5, r14
  10b3e4:	4606      	mov	r6, r0
  10b3e6:	460c      	mov	r4, r1
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  10b3e8:	f7fe fc3e 	bl	109c68 <xTaskGetSchedulerState>
  10b3ec:	2801      	cmp	r0, #1
  10b3ee:	d01c      	beq.n	10b42a <event_wait_timeout+0x4a>
    return NO_ERROR;

    TickType_t xTicksToWait = (timeout == INFINITE_TIME ? portMAX_DELAY : LKMS_TO_FRTS_TICK(timeout));
  10b3f0:	1c63      	adds	r3, r4, #1
  10b3f2:	bf1b      	ittet	ne
  10b3f4:	f644 51d3 	movwne	r1, #19923	; 0x4dd3
  10b3f8:	ebc4 1244 	rsbne	r2, r4, r4, lsl #5
  10b3fc:	4622      	moveq	r2, r4
  10b3fe:	f2c1 0162 	movtne	r1, #4194	; 0x1062
  10b402:	bf1f      	itttt	ne
  10b404:	eb04 0282 	addne.w	r2, r4, r2, lsl #2
  10b408:	00d2      	lslne	r2, r2, #3
  10b40a:	fba1 3202 	umullne	r3, r2, r1, r2
  10b40e:	0992      	lsrne	r2, r2, #6
  10b410:	f3ef 8100 	mrs	r1, CPSR

    BaseType_t ret = pdFALSE;

    RESCHED_ASSERT();
  10b414:	f011 0180 	ands.w	r1, r1, #128	; 0x80
  10b418:	d10f      	bne.n	10b43a <event_wait_timeout+0x5a>
  10b41a:	6830      	ldr	r0, [r6, #0]

    if(e->auto_clear)
  10b41c:	7933      	ldrb	r3, [r6, #4]
  10b41e:	b933      	cbnz	r3, 10b42e <event_wait_timeout+0x4e>
    {
        ret = xQueueReceive(e->pfrts_evt_handle,NULL,xTicksToWait);
    }
    else
    {
        ret = xQueuePeek(e->pfrts_evt_handle,NULL,xTicksToWait);
  10b420:	4619      	mov	r1, r3
  10b422:	f7fd fbe9 	bl	108bf8 <xQueuePeek>
    }

    return (ret == pdTRUE ? NO_ERROR : ERR_TIMED_OUT);
  10b426:	2801      	cmp	r0, #1
  10b428:	d104      	bne.n	10b434 <event_wait_timeout+0x54>
    return NO_ERROR;
  10b42a:	2000      	movs	r0, #0
}
  10b42c:	bd70      	pop	{r4, r5, r6, r15}
        ret = xQueueReceive(e->pfrts_evt_handle,NULL,xTicksToWait);
  10b42e:	f7fd fb39 	bl	108aa4 <xQueueReceive>
  10b432:	e7f8      	b.n	10b426 <event_wait_timeout+0x46>
    return (ret == pdTRUE ? NO_ERROR : ERR_TIMED_OUT);
  10b434:	f06f 000c 	mvn.w	r0, #12
}
  10b438:	bd70      	pop	{r4, r5, r6, r15}
    RESCHED_ASSERT();
  10b43a:	f641 6230 	movw	r2, #7728	; 0x1e30
  10b43e:	f641 6150 	movw	r1, #7760	; 0x1e50
  10b442:	4628      	mov	r0, r5
  10b444:	f2c0 0211 	movt	r2, #17
  10b448:	2337      	movs	r3, #55	; 0x37
  10b44a:	f2c0 0111 	movt	r1, #17
  10b44e:	f7fe ff11 	bl	10a274 <_panic>
  10b452:	bf00      	nop

0010b454 <event_signal>:

WRAPPER_FUNCTION status_t event_signal(event_t *e, bool reschedule)
{
  10b454:	b530      	push	{r4, r5, r14}
  10b456:	4675      	mov	r5, r14
  10b458:	b083      	sub	sp, #12
  10b45a:	4604      	mov	r4, r0
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  10b45c:	f7fe fc04 	bl	109c68 <xTaskGetSchedulerState>
  10b460:	2801      	cmp	r0, #1
  10b462:	d00f      	beq.n	10b484 <event_signal+0x30>
    /*in freertos, a set of event may autoresch
     *if there is a blocked task is waiting for
     *this event. So caller should treat this as resched as always.
     */

    if(ulPortInterruptNesting > 0)
  10b464:	f647 1310 	movw	r3, #30992	; 0x7910
  10b468:	f2c0 0311 	movt	r3, #17
  10b46c:	681b      	ldr	r3, [r3, #0]
  10b46e:	b963      	cbnz	r3, 10b48a <event_signal+0x36>
  10b470:	f3ef 8300 	mrs	r3, CPSR
    else
    {
        /* Here is in task context. call classic API. */
        /* We still need to check if in spinlocked state, as no bottom scetion may
         * take responsiblity to do deferred resched. */
        RESCHED_ASSERT();
  10b474:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  10b478:	d11b      	bne.n	10b4b2 <event_signal+0x5e>

        xQueueSend(e->pfrts_evt_handle,NULL,0);
  10b47a:	6820      	ldr	r0, [r4, #0]
  10b47c:	461a      	mov	r2, r3
  10b47e:	4619      	mov	r1, r3
  10b480:	f7fd f9ac 	bl	1087dc <xQueueGenericSend>
    }

    return NO_ERROR;
}
  10b484:	2000      	movs	r0, #0
  10b486:	b003      	add	sp, #12
  10b488:	bd30      	pop	{r4, r5, r15}
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  10b48a:	2300      	movs	r3, #0
  10b48c:	aa02      	add	r2, sp, #8
        xQueueSendFromISR(e->pfrts_evt_handle,NULL,&xHigherPriorityTaskWoken);
  10b48e:	6820      	ldr	r0, [r4, #0]
  10b490:	4619      	mov	r1, r3
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
  10b492:	f842 3d04 	str.w	r3, [r2, #-4]!
        xQueueSendFromISR(e->pfrts_evt_handle,NULL,&xHigherPriorityTaskWoken);
  10b496:	f7fd fa85 	bl	1089a4 <xQueueGenericSendFromISR>
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  10b49a:	9b01      	ldr	r3, [sp, #4]
  10b49c:	2b00      	cmp	r3, #0
  10b49e:	d0f1      	beq.n	10b484 <event_signal+0x30>
  10b4a0:	f647 1318 	movw	r3, #31000	; 0x7918
  10b4a4:	2201      	movs	r2, #1
}
  10b4a6:	2000      	movs	r0, #0
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  10b4a8:	f2c0 0311 	movt	r3, #17
  10b4ac:	601a      	str	r2, [r3, #0]
}
  10b4ae:	b003      	add	sp, #12
  10b4b0:	bd30      	pop	{r4, r5, r15}
        RESCHED_ASSERT();
  10b4b2:	f641 6230 	movw	r2, #7728	; 0x1e30
  10b4b6:	f641 6150 	movw	r1, #7760	; 0x1e50
  10b4ba:	4628      	mov	r0, r5
  10b4bc:	f2c0 0211 	movt	r2, #17
  10b4c0:	2360      	movs	r3, #96	; 0x60
  10b4c2:	f2c0 0111 	movt	r1, #17
  10b4c6:	f7fe fed5 	bl	10a274 <_panic>
  10b4ca:	bf00      	nop

0010b4cc <event_unsignal>:

WRAPPER_FUNCTION status_t event_unsignal(event_t *e)
{
  10b4cc:	b538      	push	{r3, r4, r5, r14}
  10b4ce:	4675      	mov	r5, r14
  10b4d0:	4604      	mov	r4, r0
    if(taskSCHEDULER_NOT_STARTED == xTaskGetSchedulerState())
  10b4d2:	f7fe fbc9 	bl	109c68 <xTaskGetSchedulerState>
  10b4d6:	2801      	cmp	r0, #1
  10b4d8:	d008      	beq.n	10b4ec <event_unsignal+0x20>
    return NO_ERROR;

    ISR_ASSERT();
  10b4da:	f647 1310 	movw	r3, #30992	; 0x7910
  10b4de:	f2c0 0311 	movt	r3, #17
  10b4e2:	6819      	ldr	r1, [r3, #0]
  10b4e4:	b921      	cbnz	r1, 10b4f0 <event_unsignal+0x24>

    xQueueReset(e->pfrts_evt_handle);
  10b4e6:	6820      	ldr	r0, [r4, #0]
  10b4e8:	f7fd f89e 	bl	108628 <xQueueGenericReset>


    return NO_ERROR;
}
  10b4ec:	2000      	movs	r0, #0
  10b4ee:	bd38      	pop	{r3, r4, r5, r15}
    ISR_ASSERT();
  10b4f0:	f641 6230 	movw	r2, #7728	; 0x1e30
  10b4f4:	f641 6180 	movw	r1, #7808	; 0x1e80
  10b4f8:	4628      	mov	r0, r5
  10b4fa:	f2c0 0211 	movt	r2, #17
  10b4fe:	236d      	movs	r3, #109	; 0x6d
  10b500:	f2c0 0111 	movt	r1, #17
  10b504:	f7fe feb6 	bl	10a274 <_panic>

0010b508 <mutex_init>:
#include <lk_wrapper.h>

/*********************** mutex API redirection *******************/

WRAPPER_FUNCTION void mutex_init(mutex_t *mutex)
{
  10b508:	b510      	push	{r4, r14}
  10b50a:	4604      	mov	r4, r0
    *mutex = xSemaphoreCreateMutex();
  10b50c:	2001      	movs	r0, #1
  10b50e:	f7fd fa35 	bl	10897c <xQueueCreateMutex>
  10b512:	6020      	str	r0, [r4, #0]
    DEBUG_ASSERT(*mutex);
}
  10b514:	bd10      	pop	{r4, r15}
  10b516:	bf00      	nop

0010b518 <mutex_destroy>:

WRAPPER_FUNCTION void mutex_destroy(mutex_t *mutex)
{
  10b518:	b510      	push	{r4, r14}
  10b51a:	4604      	mov	r4, r0
    vSemaphoreDelete(*mutex);
  10b51c:	6800      	ldr	r0, [r0, #0]
  10b51e:	f7fd fc0f 	bl	108d40 <vQueueDelete>
    *mutex = NULL;
  10b522:	2300      	movs	r3, #0
  10b524:	6023      	str	r3, [r4, #0]
}
  10b526:	bd10      	pop	{r4, r15}

0010b528 <task_dispatch>:
    thread_start_routine entry;
    void* arg;
};

static void task_dispatch(void* arg)
{
  10b528:	b510      	push	{r4, r14}
  10b52a:	4604      	mov	r4, r0
    struct task_dispatcher_t* dispatcher = (struct task_dispatcher_t*) arg;

#if ARM_WITH_VFP==1
    //enable fpu context save/restore
    portTASK_USES_FLOATING_POINT();
  10b52c:	f7fc fd30 	bl	107f90 <vPortTaskUsesFPU>
#endif

    dispatcher->entry(dispatcher->arg);
  10b530:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
  10b534:	4798      	blx	r3

    /* Task should not reach here in FreeRTOS programming model in theory,
    But as we are LK now, we could reach here if thread return.
    But we need to recycle the memory we used then delete itself. */

    vPortFree(dispatcher->task_handle);
  10b536:	6820      	ldr	r0, [r4, #0]
  10b538:	f7fc fef8 	bl	10832c <vPortFree>
    vPortFree(dispatcher);
  10b53c:	4620      	mov	r0, r4
  10b53e:	f7fc fef5 	bl	10832c <vPortFree>
    vTaskDelete(NULL);
  10b542:	2000      	movs	r0, #0
}
  10b544:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    vTaskDelete(NULL);
  10b548:	f7fd bf0e 	b.w	109368 <vTaskDelete>

0010b54c <thread_create>:


WRAPPER_FUNCTION thread_t* thread_create(const char *name, thread_start_routine entry, void *arg, int priority, size_t stack_size)
{
  10b54c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  10b550:	4680      	mov	r8, r0
  10b552:	b082      	sub	sp, #8

    TaskHandle_t* task = pvPortMalloc(sizeof(TaskHandle_t));
  10b554:	2004      	movs	r0, #4
  10b556:	46f2      	mov	r10, r14
{
  10b558:	460e      	mov	r6, r1
  10b55a:	4617      	mov	r7, r2
  10b55c:	4699      	mov	r9, r3
    TaskHandle_t* task = pvPortMalloc(sizeof(TaskHandle_t));
  10b55e:	f7fc ff33 	bl	1083c8 <pvPortMalloc>
    ASSERT(task);
  10b562:	b320      	cbz	r0, 10b5ae <thread_create+0x62>
  10b564:	4604      	mov	r4, r0

    struct task_dispatcher_t* dispatcher = pvPortMalloc(sizeof(struct task_dispatcher_t));
  10b566:	200c      	movs	r0, #12
  10b568:	f7fc ff2e 	bl	1083c8 <pvPortMalloc>
    ASSERT(dispatcher);
  10b56c:	4605      	mov	r5, r0
  10b56e:	b378      	cbz	r0, 10b5d0 <thread_create+0x84>
     * as same as LK programming model.
     */

    /* Pass 0 as priority to make sure the task to be created will not preempt
     * current thread. Setback after suspended. */
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  10b570:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  10b572:	2300      	movs	r3, #0
    dispatcher->task_handle = task;
  10b574:	6004      	str	r4, [r0, #0]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  10b576:	4641      	mov	r1, r8
    dispatcher->arg = arg;
  10b578:	6087      	str	r7, [r0, #8]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  10b57a:	3203      	adds	r2, #3
  10b57c:	f24b 5029 	movw	r0, #46377	; 0xb529
  10b580:	f3c2 028f 	ubfx	r2, r2, #2, #16
    dispatcher->entry = entry;
  10b584:	606e      	str	r6, [r5, #4]
    BaseType_t ret =  xTaskCreate((TaskFunction_t)task_dispatch,name, lkw_STACK_DEPTH(stack_size),dispatcher,(UBaseType_t)(0),task);
  10b586:	f2c0 0010 	movt	r0, #16
  10b58a:	9300      	str	r3, [sp, #0]
  10b58c:	462b      	mov	r3, r5
  10b58e:	9401      	str	r4, [sp, #4]
  10b590:	f7fd feb6 	bl	109300 <xTaskCreate>

    if(pdFALSE == ret)
  10b594:	4606      	mov	r6, r0
  10b596:	b360      	cbz	r0, 10b5f2 <thread_create+0xa6>
    /*as lk place new thread in suspend list(not ready),
    * frts place new task in ready list default(waiting for sch),
    * we manually migrate it into suspend list from ready list
    * in FreeRTOS.
    */
    vTaskSuspend(*task);
  10b598:	6820      	ldr	r0, [r4, #0]
  10b59a:	f7fd ffd7 	bl	10954c <vTaskSuspend>

    /* Set back to wanted priority. */
    vTaskPrioritySet(*task,(UBaseType_t)priority);
  10b59e:	6820      	ldr	r0, [r4, #0]
  10b5a0:	4649      	mov	r1, r9
  10b5a2:	f7fd ff5f 	bl	109464 <vTaskPrioritySet>

    return (thread_t*)task;
}
  10b5a6:	4620      	mov	r0, r4
  10b5a8:	b002      	add	sp, #8
  10b5aa:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    ASSERT(task);
  10b5ae:	f641 63c8 	movw	r3, #7880	; 0x1ec8
  10b5b2:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b5b6:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10b5ba:	f2c0 0311 	movt	r3, #17
  10b5be:	4650      	mov	r0, r10
  10b5c0:	f2c0 0211 	movt	r2, #17
  10b5c4:	9300      	str	r3, [sp, #0]
  10b5c6:	f2c0 0110 	movt	r1, #16
  10b5ca:	2332      	movs	r3, #50	; 0x32
  10b5cc:	f7fe fe52 	bl	10a274 <_panic>
    ASSERT(dispatcher);
  10b5d0:	f641 63d0 	movw	r3, #7888	; 0x1ed0
  10b5d4:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b5d8:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10b5dc:	f2c0 0311 	movt	r3, #17
  10b5e0:	4650      	mov	r0, r10
  10b5e2:	f2c0 0211 	movt	r2, #17
  10b5e6:	9300      	str	r3, [sp, #0]
  10b5e8:	f2c0 0110 	movt	r1, #16
  10b5ec:	2335      	movs	r3, #53	; 0x35
  10b5ee:	f7fe fe41 	bl	10a274 <_panic>
        vPortFree(dispatcher);
  10b5f2:	4628      	mov	r0, r5
  10b5f4:	f7fc fe9a 	bl	10832c <vPortFree>
        vPortFree(task);
  10b5f8:	4620      	mov	r0, r4
  10b5fa:	f7fc fe97 	bl	10832c <vPortFree>
        return NULL;
  10b5fe:	4634      	mov	r4, r6
  10b600:	e7d1      	b.n	10b5a6 <thread_create+0x5a>
  10b602:	bf00      	nop

0010b604 <thread_resume>:
     * pxCurrentTCB which is NULL. Werid concern: No validity check
     * while compare priority between pxTCB and pxCurrentTCB in case of
     * pxCurrentTCB was NULL.
    */

    ISR_ASSERT();
  10b604:	f647 1310 	movw	r3, #30992	; 0x7910
  10b608:	f2c0 0311 	movt	r3, #17
{
  10b60c:	b510      	push	{r4, r14}
    ISR_ASSERT();
  10b60e:	681b      	ldr	r3, [r3, #0]
  10b610:	b94b      	cbnz	r3, 10b626 <thread_resume+0x22>
  10b612:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  10b616:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  10b61a:	d110      	bne.n	10b63e <thread_resume+0x3a>

    vTaskResume(*task);
  10b61c:	6800      	ldr	r0, [r0, #0]
  10b61e:	f7fe f823 	bl	109668 <vTaskResume>


    return NO_ERROR;
}
  10b622:	4620      	mov	r0, r4
  10b624:	bd10      	pop	{r4, r15}
    ISR_ASSERT();
  10b626:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b62a:	f641 6180 	movw	r1, #7808	; 0x1e80
  10b62e:	4670      	mov	r0, r14
  10b630:	f2c0 0211 	movt	r2, #17
  10b634:	237b      	movs	r3, #123	; 0x7b
  10b636:	f2c0 0111 	movt	r1, #17
  10b63a:	f7fe fe1b 	bl	10a274 <_panic>
    RESCHED_ASSERT();
  10b63e:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b642:	f641 6150 	movw	r1, #7760	; 0x1e50
  10b646:	4670      	mov	r0, r14
  10b648:	f2c0 0211 	movt	r2, #17
  10b64c:	237d      	movs	r3, #125	; 0x7d
  10b64e:	f2c0 0111 	movt	r1, #17
  10b652:	f7fe fe0f 	bl	10a274 <_panic>
  10b656:	bf00      	nop

0010b658 <thread_detach>:

WRAPPER_FUNCTION status_t thread_detach(thread_t *t)
{
    TaskHandle_t* task = (TaskHandle_t*)t;

    ISR_ASSERT();
  10b658:	f647 1310 	movw	r3, #30992	; 0x7910
  10b65c:	f2c0 0311 	movt	r3, #17
{
  10b660:	b510      	push	{r4, r14}
    ISR_ASSERT();
  10b662:	681b      	ldr	r3, [r3, #0]
  10b664:	b94b      	cbnz	r3, 10b67a <thread_detach+0x22>
  10b666:	f3ef 8300 	mrs	r3, CPSR

    RESCHED_ASSERT();
  10b66a:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  10b66e:	d110      	bne.n	10b692 <thread_detach+0x3a>

    vTaskSuspend(*task);
  10b670:	6800      	ldr	r0, [r0, #0]
  10b672:	f7fd ff6b 	bl	10954c <vTaskSuspend>
    return NO_ERROR;
}
  10b676:	4620      	mov	r0, r4
  10b678:	bd10      	pop	{r4, r15}
    ISR_ASSERT();
  10b67a:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b67e:	f641 6180 	movw	r1, #7808	; 0x1e80
  10b682:	4670      	mov	r0, r14
  10b684:	f2c0 0211 	movt	r2, #17
  10b688:	2389      	movs	r3, #137	; 0x89
  10b68a:	f2c0 0111 	movt	r1, #17
  10b68e:	f7fe fdf1 	bl	10a274 <_panic>
    RESCHED_ASSERT();
  10b692:	f641 62a8 	movw	r2, #7848	; 0x1ea8
  10b696:	f641 6150 	movw	r1, #7760	; 0x1e50
  10b69a:	4670      	mov	r0, r14
  10b69c:	f2c0 0211 	movt	r2, #17
  10b6a0:	238b      	movs	r3, #139	; 0x8b
  10b6a2:	f2c0 0111 	movt	r1, #17
  10b6a6:	f7fe fde5 	bl	10a274 <_panic>
  10b6aa:	bf00      	nop

0010b6ac <cbuf_initialize>:

#define INC_POINTER(cbuf, ptr, inc) \
    modpow2(((ptr) + (inc)), (cbuf)->len_pow2)

void cbuf_initialize(cbuf_t *cbuf, size_t len)
{
  10b6ac:	b570      	push	{r4, r5, r6, r14}
  10b6ae:	4604      	mov	r4, r0
  10b6b0:	b082      	sub	sp, #8
    void *buf = malloc(len);
  10b6b2:	4608      	mov	r0, r1
{
  10b6b4:	460d      	mov	r5, r1
  10b6b6:	4676      	mov	r6, r14
    void *buf = malloc(len);
  10b6b8:	f7fc fe82 	bl	1083c0 <malloc>

    if (!buf) {
  10b6bc:	b1a0      	cbz	r0, 10b6e8 <cbuf_initialize+0x3c>
{
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(len > 0);
    DEBUG_ASSERT(ispow2(len));

    cbuf->head = 0;
  10b6be:	2200      	movs	r2, #0
  10b6c0:	4603      	mov	r3, r0
    cbuf->tail = 0;
  10b6c2:	e9c4 2200 	strd	r2, r2, [r4]
    return ((val - 1) & val) == 0;
}

static inline __ALWAYS_INLINE uint log2_uint(uint val)
{
    if (val == 0)
  10b6c6:	b11d      	cbz	r5, 10b6d0 <cbuf_initialize+0x24>
        return 0; // undefined

    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
  10b6c8:	fab5 f585 	clz	r5, r5
  10b6cc:	f1c5 051f 	rsb	r5, r5, #31
    cbuf->len_pow2 = log2_uint(len);
    cbuf->buf = buf;
    event_init(&cbuf->event, false, 0);
  10b6d0:	2200      	movs	r2, #0
  10b6d2:	f104 0010 	add.w	r0, r4, #16
    cbuf->buf = buf;
  10b6d6:	60e3      	str	r3, [r4, #12]
    event_init(&cbuf->event, false, 0);
  10b6d8:	4611      	mov	r1, r2
    cbuf->len_pow2 = log2_uint(len);
  10b6da:	60a5      	str	r5, [r4, #8]
    event_init(&cbuf->event, false, 0);
  10b6dc:	f7ff fe52 	bl	10b384 <event_init>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  10b6e0:	2300      	movs	r3, #0
  10b6e2:	61a3      	str	r3, [r4, #24]
}
  10b6e4:	b002      	add	sp, #8
  10b6e6:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(0, "No memory for cbuf\n");
  10b6e8:	f641 60dc 	movw	r0, #7900	; 0x1edc
  10b6ec:	f2c0 0011 	movt	r0, #17
  10b6f0:	f7ff fddc 	bl	10b2ac <puts>
        ASSERT(0);
  10b6f4:	f24d 736c 	movw	r3, #55148	; 0xd76c
  10b6f8:	f641 62f0 	movw	r2, #7920	; 0x1ef0
  10b6fc:	f2c0 0310 	movt	r3, #16
  10b700:	f64b 615c 	movw	r1, #48732	; 0xbe5c
  10b704:	4630      	mov	r0, r6
  10b706:	9300      	str	r3, [sp, #0]
  10b708:	f2c0 0211 	movt	r2, #17
  10b70c:	232c      	movs	r3, #44	; 0x2c
  10b70e:	f2c0 0110 	movt	r1, #16
  10b712:	f7fe fdaf 	bl	10a274 <_panic>
  10b716:	bf00      	nop

0010b718 <cbuf_space_avail>:

    memset(cbuf, 0, sizeof(cbuf_t));
}

size_t cbuf_space_avail(cbuf_t *cbuf)
{
  10b718:	b430      	push	{r4, r5}
}

static inline __ALWAYS_INLINE uint valpow2(uint valp2)
{
    return 1U << valp2;
  10b71a:	2201      	movs	r2, #1
    return val >> divp2;
}

static inline __ALWAYS_INLINE uint modpow2(uint val, uint modp2)
{
    return val & ((1UL << modp2) - 1);
  10b71c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  10b720:	6884      	ldr	r4, [r0, #8]
  10b722:	e9d0 3500 	ldrd	r3, r5, [r0]
    return 1U << valp2;
  10b726:	fa02 f004 	lsl.w	r0, r2, r4
  10b72a:	1b5b      	subs	r3, r3, r5
    return val & ((1UL << modp2) - 1);
  10b72c:	fa01 f204 	lsl.w	r2, r1, r4
    return valpow2(cbuf->len_pow2) - consumed - 1;
  10b730:	4408      	add	r0, r1
  10b732:	ea23 0302 	bic.w	r3, r3, r2
}
  10b736:	1ac0      	subs	r0, r0, r3
  10b738:	bc30      	pop	{r4, r5}
  10b73a:	4770      	bx	r14

0010b73c <cbuf_write_char>:
    spin_unlock_irqrestore(&cbuf->lock, state);
    return ret;
}

size_t cbuf_write_char(cbuf_t *cbuf, char c, bool canreschedule)
{
  10b73c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  10b73e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b742:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  10b744:	bf48      	it	mi
  10b746:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b748:	d401      	bmi.n	10b74e <cbuf_write_char+0x12>
    __asm__ volatile("cpsid i");
  10b74a:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10b74c:	2701      	movs	r7, #1
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  10b74e:	6883      	ldr	r3, [r0, #8]
  10b750:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  10b754:	f8d0 c000 	ldr.w	r12, [r0]
    *lock = 1;
  10b758:	2501      	movs	r5, #1
  10b75a:	6844      	ldr	r4, [r0, #4]
  10b75c:	fa06 fe03 	lsl.w	r14, r6, r3
  10b760:	ebac 0404 	sub.w	r4, r12, r4
  10b764:	ea24 040e 	bic.w	r4, r4, r14
    return 1U << valp2;
  10b768:	fa05 f303 	lsl.w	r3, r5, r3
  10b76c:	6185      	str	r5, [r0, #24]
    return valpow2(cbuf->len_pow2) - consumed - 1;
  10b76e:	1b1b      	subs	r3, r3, r4
    bool signal = false;
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    size_t ret = 0;
    if (cbuf_space_avail(cbuf) > 0) {
  10b770:	42ab      	cmp	r3, r5
  10b772:	d017      	beq.n	10b7a4 <cbuf_write_char+0x68>
        cbuf->buf[cbuf->head] = c;
  10b774:	68c3      	ldr	r3, [r0, #12]
  10b776:	f803 100c 	strb.w	r1, [r3, r12]
    return val & ((1UL << modp2) - 1);
  10b77a:	6883      	ldr	r3, [r0, #8]

        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  10b77c:	6804      	ldr	r4, [r0, #0]
  10b77e:	409e      	lsls	r6, r3
        ret = 1;

        if (cbuf->head != cbuf->tail)
  10b780:	6841      	ldr	r1, [r0, #4]
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  10b782:	1963      	adds	r3, r4, r5
  10b784:	ea23 0306 	bic.w	r3, r3, r6
        if (cbuf->head != cbuf->tail)
  10b788:	4299      	cmp	r1, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  10b78a:	6003      	str	r3, [r0, #0]
        if (cbuf->head != cbuf->tail)
  10b78c:	d00b      	beq.n	10b7a6 <cbuf_write_char+0x6a>
    *lock = 0;
  10b78e:	2300      	movs	r3, #0
  10b790:	6183      	str	r3, [r0, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10b792:	b107      	cbz	r7, 10b796 <cbuf_write_char+0x5a>
    __asm__ volatile("cpsie i");
  10b794:	b662      	cpsie	i
  10b796:	4611      	mov	r1, r2
    }

    spin_unlock_irqrestore(&cbuf->lock, state);

    if(signal == true)
        event_signal(&cbuf->event, canreschedule);
  10b798:	3010      	adds	r0, #16
  10b79a:	f7ff fe5b 	bl	10b454 <event_signal>
  10b79e:	2501      	movs	r5, #1

    return ret;
}
  10b7a0:	4628      	mov	r0, r5
  10b7a2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    size_t ret = 0;
  10b7a4:	2500      	movs	r5, #0
    *lock = 0;
  10b7a6:	2300      	movs	r3, #0
  10b7a8:	6183      	str	r3, [r0, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10b7aa:	2f00      	cmp	r7, #0
  10b7ac:	d0f8      	beq.n	10b7a0 <cbuf_write_char+0x64>
  10b7ae:	b662      	cpsie	i
}
  10b7b0:	4628      	mov	r0, r5
  10b7b2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0010b7b4 <cbuf_read_char>:

size_t cbuf_read_char(cbuf_t *cbuf, char *c, bool block)
{
  10b7b4:	b570      	push	{r4, r5, r6, r14}
  10b7b6:	4604      	mov	r4, r0
  10b7b8:	460e      	mov	r6, r1
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(c);

retry:
    if (block)
  10b7ba:	4615      	mov	r5, r2
  10b7bc:	bb42      	cbnz	r2, 10b810 <cbuf_read_char+0x5c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10b7be:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b7c2:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  10b7c6:	d12e      	bne.n	10b826 <cbuf_read_char+0x72>
    __asm__ volatile("cpsid i");
  10b7c8:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    // see if there's data available
    size_t ret = 0;
    if (cbuf->tail != cbuf->head) {
  10b7ca:	e9d4 0100 	ldrd	r0, r1, [r4]
    *lock = 1;
  10b7ce:	2201      	movs	r2, #1
  10b7d0:	61a2      	str	r2, [r4, #24]
  10b7d2:	4281      	cmp	r1, r0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10b7d4:	bf18      	it	ne
  10b7d6:	4615      	movne	r5, r2
  10b7d8:	d015      	beq.n	10b806 <cbuf_read_char+0x52>

        *c = cbuf->buf[cbuf->tail];
  10b7da:	68e2      	ldr	r2, [r4, #12]
  10b7dc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  10b7e0:	5c52      	ldrb	r2, [r2, r1]
  10b7e2:	7032      	strb	r2, [r6, #0]
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  10b7e4:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
  10b7e8:	fa03 f101 	lsl.w	r1, r3, r1
  10b7ec:	1c53      	adds	r3, r2, #1

        if (cbuf->tail == cbuf->head) {
  10b7ee:	6822      	ldr	r2, [r4, #0]
  10b7f0:	ea23 0301 	bic.w	r3, r3, r1
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  10b7f4:	6063      	str	r3, [r4, #4]
        if (cbuf->tail == cbuf->head) {
  10b7f6:	429a      	cmp	r2, r3
  10b7f8:	d022      	beq.n	10b840 <cbuf_read_char+0x8c>
    *lock = 0;
  10b7fa:	2300      	movs	r3, #0
  10b7fc:	61a3      	str	r3, [r4, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10b7fe:	b1ed      	cbz	r5, 10b83c <cbuf_read_char+0x88>
    __asm__ volatile("cpsie i");
  10b800:	b662      	cpsie	i
  10b802:	2001      	movs	r0, #1

    if (block && ret == 0)
        goto retry;

    return ret;
}
  10b804:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 0;
  10b806:	61a3      	str	r3, [r4, #24]
  10b808:	b662      	cpsie	i
  10b80a:	4628      	mov	r0, r5
    if (block && ret == 0)
  10b80c:	2d00      	cmp	r5, #0
  10b80e:	d0f9      	beq.n	10b804 <cbuf_read_char+0x50>
  10b810:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  10b814:	f104 0010 	add.w	r0, r4, #16
  10b818:	f7ff fde2 	bl	10b3e0 <event_wait_timeout>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  10b81c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b820:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  10b824:	d0d0      	beq.n	10b7c8 <cbuf_read_char+0x14>
    if (cbuf->tail != cbuf->head) {
  10b826:	e9d4 3100 	ldrd	r3, r1, [r4]
    *lock = 1;
  10b82a:	2201      	movs	r2, #1
  10b82c:	61a2      	str	r2, [r4, #24]
  10b82e:	4299      	cmp	r1, r3
    *lock = 0;
  10b830:	bf04      	itt	eq
  10b832:	2300      	moveq	r3, #0
  10b834:	61a3      	streq	r3, [r4, #24]
  10b836:	d0e8      	beq.n	10b80a <cbuf_read_char+0x56>
    spin_lock_saved_state_t state = 0;
  10b838:	2500      	movs	r5, #0
  10b83a:	e7ce      	b.n	10b7da <cbuf_read_char+0x26>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10b83c:	2001      	movs	r0, #1
}
  10b83e:	bd70      	pop	{r4, r5, r6, r15}
            event_unsignal(&cbuf->event);
  10b840:	f104 0010 	add.w	r0, r4, #16
  10b844:	f7ff fe42 	bl	10b4cc <event_unsignal>
  10b848:	e7d7      	b.n	10b7fa <cbuf_read_char+0x46>
  10b84a:	bf00      	nop

0010b84c <__debug_stdio_write>:

    spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
}

static ssize_t __debug_stdio_write(io_handle_t *io, const char *s, size_t len)
{
  10b84c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
    return (list->next == list) ? true : false;
  10b850:	f644 16d0 	movw	r6, #18896	; 0x49d0
  10b854:	460c      	mov	r4, r1
  10b856:	4617      	mov	r7, r2
  10b858:	f2c0 0611 	movt	r6, #17
  10b85c:	6875      	ldr	r5, [r6, #4]
    if (!list_is_empty(&print_callbacks)) {
  10b85e:	42b5      	cmp	r5, r6
  10b860:	d013      	beq.n	10b88a <__debug_stdio_write+0x3e>
  10b862:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b866:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  10b868:	bf48      	it	mi
  10b86a:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  10b86e:	d519      	bpl.n	10b8a4 <__debug_stdio_write+0x58>
            if (cb->print)
  10b870:	68ab      	ldr	r3, [r5, #8]
                cb->print(cb, str, len);
  10b872:	4628      	mov	r0, r5
  10b874:	463a      	mov	r2, r7
  10b876:	4621      	mov	r1, r4
            if (cb->print)
  10b878:	b103      	cbz	r3, 10b87c <__debug_stdio_write+0x30>
                cb->print(cb, str, len);
  10b87a:	4798      	blx	r3
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  10b87c:	686d      	ldr	r5, [r5, #4]
  10b87e:	42b5      	cmp	r5, r6
  10b880:	d1f6      	bne.n	10b870 <__debug_stdio_write+0x24>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  10b882:	f1b8 0f00 	cmp.w	r8, #0
  10b886:	d000      	beq.n	10b88a <__debug_stdio_write+0x3e>
    __asm__ volatile("cpsie i");
  10b888:	b662      	cpsie	i
    for (i = 0; i < len; i++) {
  10b88a:	b147      	cbz	r7, 10b89e <__debug_stdio_write+0x52>
  10b88c:	1e7d      	subs	r5, r7, #1
  10b88e:	4425      	add	r5, r4
  10b890:	3c01      	subs	r4, #1
        platform_dputc(str[i]);
  10b892:	f814 0f01 	ldrb.w	r0, [r4, #1]!
  10b896:	f7f4 fe57 	bl	100548 <platform_dputc>
    for (i = 0; i < len; i++) {
  10b89a:	42a5      	cmp	r5, r4
  10b89c:	d1f9      	bne.n	10b892 <__debug_stdio_write+0x46>
    out_count(s, len);
    return len;
}
  10b89e:	4638      	mov	r0, r7
  10b8a0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    __asm__ volatile("cpsid i");
  10b8a4:	b672      	cpsid	i
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  10b8a6:	6875      	ldr	r5, [r6, #4]
  10b8a8:	42b5      	cmp	r5, r6
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  10b8aa:	bf18      	it	ne
  10b8ac:	f04f 0801 	movne.w	r8, #1
  10b8b0:	d1de      	bne.n	10b870 <__debug_stdio_write+0x24>
  10b8b2:	e7e9      	b.n	10b888 <__debug_stdio_write+0x3c>

0010b8b4 <__debug_stdio_read>:

static ssize_t __debug_stdio_read(io_handle_t *io, char *s, size_t len)
{
    if (len == 0)
  10b8b4:	b90a      	cbnz	r2, 10b8ba <__debug_stdio_read+0x6>
        return 0;
  10b8b6:	4610      	mov	r0, r2
    if (err < 0)
        return err;

    return 1;
#endif
}
  10b8b8:	4770      	bx	r14
{
  10b8ba:	b508      	push	{r3, r14}
  10b8bc:	4608      	mov	r0, r1
    int err = platform_dgetc(s, true);
  10b8be:	2101      	movs	r1, #1
  10b8c0:	f7f4 fe44 	bl	10054c <platform_dgetc>
    return 1;
  10b8c4:	ea10 0020 	ands.w	r0, r0, r0, asr #32
  10b8c8:	bf38      	it	cc
  10b8ca:	2001      	movcc	r0, #1
}
  10b8cc:	bd08      	pop	{r3, r15}
  10b8ce:	bf00      	nop

0010b8d0 <io_write>:

ssize_t io_write(io_handle_t *io, const char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->write)
  10b8d0:	6843      	ldr	r3, [r0, #4]
  10b8d2:	681b      	ldr	r3, [r3, #0]
  10b8d4:	b103      	cbz	r3, 10b8d8 <io_write+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->write(io, buf, len);
  10b8d6:	4718      	bx	r3
}
  10b8d8:	f06f 0017 	mvn.w	r0, #23
  10b8dc:	4770      	bx	r14
  10b8de:	bf00      	nop

0010b8e0 <__aeabi_drsub>:
  10b8e0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  10b8e4:	e002      	b.n	10b8ec <__adddf3>
  10b8e6:	bf00      	nop

0010b8e8 <__aeabi_dsub>:
  10b8e8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0010b8ec <__adddf3>:
  10b8ec:	b530      	push	{r4, r5, r14}
  10b8ee:	ea4f 0441 	mov.w	r4, r1, lsl #1
  10b8f2:	ea4f 0543 	mov.w	r5, r3, lsl #1
  10b8f6:	ea94 0f05 	teq	r4, r5
  10b8fa:	bf08      	it	eq
  10b8fc:	ea90 0f02 	teqeq	r0, r2
  10b900:	bf1f      	itttt	ne
  10b902:	ea54 0c00 	orrsne.w	r12, r4, r0
  10b906:	ea55 0c02 	orrsne.w	r12, r5, r2
  10b90a:	ea7f 5c64 	mvnsne.w	r12, r4, asr #21
  10b90e:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  10b912:	f000 80e2 	beq.w	10bada <__adddf3+0x1ee>
  10b916:	ea4f 5454 	mov.w	r4, r4, lsr #21
  10b91a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  10b91e:	bfb8      	it	lt
  10b920:	426d      	neglt	r5, r5
  10b922:	dd0c      	ble.n	10b93e <__adddf3+0x52>
  10b924:	442c      	add	r4, r5
  10b926:	ea80 0202 	eor.w	r2, r0, r2
  10b92a:	ea81 0303 	eor.w	r3, r1, r3
  10b92e:	ea82 0000 	eor.w	r0, r2, r0
  10b932:	ea83 0101 	eor.w	r1, r3, r1
  10b936:	ea80 0202 	eor.w	r2, r0, r2
  10b93a:	ea81 0303 	eor.w	r3, r1, r3
  10b93e:	2d36      	cmp	r5, #54	; 0x36
  10b940:	bf88      	it	hi
  10b942:	bd30      	pophi	{r4, r5, r15}
  10b944:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  10b948:	ea4f 3101 	mov.w	r1, r1, lsl #12
  10b94c:	f44f 1c80 	mov.w	r12, #1048576	; 0x100000
  10b950:	ea4c 3111 	orr.w	r1, r12, r1, lsr #12
  10b954:	d002      	beq.n	10b95c <__adddf3+0x70>
  10b956:	4240      	negs	r0, r0
  10b958:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  10b95c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  10b960:	ea4f 3303 	mov.w	r3, r3, lsl #12
  10b964:	ea4c 3313 	orr.w	r3, r12, r3, lsr #12
  10b968:	d002      	beq.n	10b970 <__adddf3+0x84>
  10b96a:	4252      	negs	r2, r2
  10b96c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  10b970:	ea94 0f05 	teq	r4, r5
  10b974:	f000 80a7 	beq.w	10bac6 <__adddf3+0x1da>
  10b978:	f1a4 0401 	sub.w	r4, r4, #1
  10b97c:	f1d5 0e20 	rsbs	r14, r5, #32
  10b980:	db0d      	blt.n	10b99e <__adddf3+0xb2>
  10b982:	fa02 fc0e 	lsl.w	r12, r2, r14
  10b986:	fa22 f205 	lsr.w	r2, r2, r5
  10b98a:	1880      	adds	r0, r0, r2
  10b98c:	f141 0100 	adc.w	r1, r1, #0
  10b990:	fa03 f20e 	lsl.w	r2, r3, r14
  10b994:	1880      	adds	r0, r0, r2
  10b996:	fa43 f305 	asr.w	r3, r3, r5
  10b99a:	4159      	adcs	r1, r3
  10b99c:	e00e      	b.n	10b9bc <__adddf3+0xd0>
  10b99e:	f1a5 0520 	sub.w	r5, r5, #32
  10b9a2:	f10e 0e20 	add.w	r14, r14, #32
  10b9a6:	2a01      	cmp	r2, #1
  10b9a8:	fa03 fc0e 	lsl.w	r12, r3, r14
  10b9ac:	bf28      	it	cs
  10b9ae:	f04c 0c02 	orrcs.w	r12, r12, #2
  10b9b2:	fa43 f305 	asr.w	r3, r3, r5
  10b9b6:	18c0      	adds	r0, r0, r3
  10b9b8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  10b9bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  10b9c0:	d507      	bpl.n	10b9d2 <__adddf3+0xe6>
  10b9c2:	f04f 0e00 	mov.w	r14, #0
  10b9c6:	f1dc 0c00 	rsbs	r12, r12, #0
  10b9ca:	eb7e 0000 	sbcs.w	r0, r14, r0
  10b9ce:	eb6e 0101 	sbc.w	r1, r14, r1
  10b9d2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  10b9d6:	d31b      	bcc.n	10ba10 <__adddf3+0x124>
  10b9d8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  10b9dc:	d30c      	bcc.n	10b9f8 <__adddf3+0x10c>
  10b9de:	0849      	lsrs	r1, r1, #1
  10b9e0:	ea5f 0030 	movs.w	r0, r0, rrx
  10b9e4:	ea4f 0c3c 	mov.w	r12, r12, rrx
  10b9e8:	f104 0401 	add.w	r4, r4, #1
  10b9ec:	ea4f 5244 	mov.w	r2, r4, lsl #21
  10b9f0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  10b9f4:	f080 809a 	bcs.w	10bb2c <__adddf3+0x240>
  10b9f8:	f1bc 4f00 	cmp.w	r12, #2147483648	; 0x80000000
  10b9fc:	bf08      	it	eq
  10b9fe:	ea5f 0c50 	movseq.w	r12, r0, lsr #1
  10ba02:	f150 0000 	adcs.w	r0, r0, #0
  10ba06:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  10ba0a:	ea41 0105 	orr.w	r1, r1, r5
  10ba0e:	bd30      	pop	{r4, r5, r15}
  10ba10:	ea5f 0c4c 	movs.w	r12, r12, lsl #1
  10ba14:	4140      	adcs	r0, r0
  10ba16:	eb41 0101 	adc.w	r1, r1, r1
  10ba1a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  10ba1e:	f1a4 0401 	sub.w	r4, r4, #1
  10ba22:	d1e9      	bne.n	10b9f8 <__adddf3+0x10c>
  10ba24:	f091 0f00 	teq	r1, #0
  10ba28:	bf04      	itt	eq
  10ba2a:	4601      	moveq	r1, r0
  10ba2c:	2000      	moveq	r0, #0
  10ba2e:	fab1 f381 	clz	r3, r1
  10ba32:	bf08      	it	eq
  10ba34:	3320      	addeq	r3, #32
  10ba36:	f1a3 030b 	sub.w	r3, r3, #11
  10ba3a:	f1b3 0220 	subs.w	r2, r3, #32
  10ba3e:	da0c      	bge.n	10ba5a <__adddf3+0x16e>
  10ba40:	320c      	adds	r2, #12
  10ba42:	dd08      	ble.n	10ba56 <__adddf3+0x16a>
  10ba44:	f102 0c14 	add.w	r12, r2, #20
  10ba48:	f1c2 020c 	rsb	r2, r2, #12
  10ba4c:	fa01 f00c 	lsl.w	r0, r1, r12
  10ba50:	fa21 f102 	lsr.w	r1, r1, r2
  10ba54:	e00c      	b.n	10ba70 <__adddf3+0x184>
  10ba56:	f102 0214 	add.w	r2, r2, #20
  10ba5a:	bfd8      	it	le
  10ba5c:	f1c2 0c20 	rsble	r12, r2, #32
  10ba60:	fa01 f102 	lsl.w	r1, r1, r2
  10ba64:	fa20 fc0c 	lsr.w	r12, r0, r12
  10ba68:	bfdc      	itt	le
  10ba6a:	ea41 010c 	orrle.w	r1, r1, r12
  10ba6e:	4090      	lslle	r0, r2
  10ba70:	1ae4      	subs	r4, r4, r3
  10ba72:	bfa2      	ittt	ge
  10ba74:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  10ba78:	4329      	orrge	r1, r5
  10ba7a:	bd30      	popge	{r4, r5, r15}
  10ba7c:	ea6f 0404 	mvn.w	r4, r4
  10ba80:	3c1f      	subs	r4, #31
  10ba82:	da1c      	bge.n	10babe <__adddf3+0x1d2>
  10ba84:	340c      	adds	r4, #12
  10ba86:	dc0e      	bgt.n	10baa6 <__adddf3+0x1ba>
  10ba88:	f104 0414 	add.w	r4, r4, #20
  10ba8c:	f1c4 0220 	rsb	r2, r4, #32
  10ba90:	fa20 f004 	lsr.w	r0, r0, r4
  10ba94:	fa01 f302 	lsl.w	r3, r1, r2
  10ba98:	ea40 0003 	orr.w	r0, r0, r3
  10ba9c:	fa21 f304 	lsr.w	r3, r1, r4
  10baa0:	ea45 0103 	orr.w	r1, r5, r3
  10baa4:	bd30      	pop	{r4, r5, r15}
  10baa6:	f1c4 040c 	rsb	r4, r4, #12
  10baaa:	f1c4 0220 	rsb	r2, r4, #32
  10baae:	fa20 f002 	lsr.w	r0, r0, r2
  10bab2:	fa01 f304 	lsl.w	r3, r1, r4
  10bab6:	ea40 0003 	orr.w	r0, r0, r3
  10baba:	4629      	mov	r1, r5
  10babc:	bd30      	pop	{r4, r5, r15}
  10babe:	fa21 f004 	lsr.w	r0, r1, r4
  10bac2:	4629      	mov	r1, r5
  10bac4:	bd30      	pop	{r4, r5, r15}
  10bac6:	f094 0f00 	teq	r4, #0
  10baca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  10bace:	bf06      	itte	eq
  10bad0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  10bad4:	3401      	addeq	r4, #1
  10bad6:	3d01      	subne	r5, #1
  10bad8:	e74e      	b.n	10b978 <__adddf3+0x8c>
  10bada:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  10bade:	bf18      	it	ne
  10bae0:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  10bae4:	d029      	beq.n	10bb3a <__adddf3+0x24e>
  10bae6:	ea94 0f05 	teq	r4, r5
  10baea:	bf08      	it	eq
  10baec:	ea90 0f02 	teqeq	r0, r2
  10baf0:	d005      	beq.n	10bafe <__adddf3+0x212>
  10baf2:	ea54 0c00 	orrs.w	r12, r4, r0
  10baf6:	bf04      	itt	eq
  10baf8:	4619      	moveq	r1, r3
  10bafa:	4610      	moveq	r0, r2
  10bafc:	bd30      	pop	{r4, r5, r15}
  10bafe:	ea91 0f03 	teq	r1, r3
  10bb02:	bf1e      	ittt	ne
  10bb04:	2100      	movne	r1, #0
  10bb06:	2000      	movne	r0, #0
  10bb08:	bd30      	popne	{r4, r5, r15}
  10bb0a:	ea5f 5c54 	movs.w	r12, r4, lsr #21
  10bb0e:	d105      	bne.n	10bb1c <__adddf3+0x230>
  10bb10:	0040      	lsls	r0, r0, #1
  10bb12:	4149      	adcs	r1, r1
  10bb14:	bf28      	it	cs
  10bb16:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  10bb1a:	bd30      	pop	{r4, r5, r15}
  10bb1c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  10bb20:	bf3c      	itt	cc
  10bb22:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  10bb26:	bd30      	popcc	{r4, r5, r15}
  10bb28:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  10bb2c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  10bb30:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  10bb34:	f04f 0000 	mov.w	r0, #0
  10bb38:	bd30      	pop	{r4, r5, r15}
  10bb3a:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  10bb3e:	bf1a      	itte	ne
  10bb40:	4619      	movne	r1, r3
  10bb42:	4610      	movne	r0, r2
  10bb44:	ea7f 5c65 	mvnseq.w	r12, r5, asr #21
  10bb48:	bf1c      	itt	ne
  10bb4a:	460b      	movne	r3, r1
  10bb4c:	4602      	movne	r2, r0
  10bb4e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  10bb52:	bf06      	itte	eq
  10bb54:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  10bb58:	ea91 0f03 	teqeq	r1, r3
  10bb5c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  10bb60:	bd30      	pop	{r4, r5, r15}
  10bb62:	bf00      	nop

0010bb64 <__aeabi_ui2d>:
  10bb64:	f090 0f00 	teq	r0, #0
  10bb68:	bf04      	itt	eq
  10bb6a:	2100      	moveq	r1, #0
  10bb6c:	4770      	bxeq	r14
  10bb6e:	b530      	push	{r4, r5, r14}
  10bb70:	f44f 6480 	mov.w	r4, #1024	; 0x400
  10bb74:	f104 0432 	add.w	r4, r4, #50	; 0x32
  10bb78:	f04f 0500 	mov.w	r5, #0
  10bb7c:	f04f 0100 	mov.w	r1, #0
  10bb80:	e750      	b.n	10ba24 <__adddf3+0x138>
  10bb82:	bf00      	nop

0010bb84 <__aeabi_i2d>:
  10bb84:	f090 0f00 	teq	r0, #0
  10bb88:	bf04      	itt	eq
  10bb8a:	2100      	moveq	r1, #0
  10bb8c:	4770      	bxeq	r14
  10bb8e:	b530      	push	{r4, r5, r14}
  10bb90:	f44f 6480 	mov.w	r4, #1024	; 0x400
  10bb94:	f104 0432 	add.w	r4, r4, #50	; 0x32
  10bb98:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  10bb9c:	bf48      	it	mi
  10bb9e:	4240      	negmi	r0, r0
  10bba0:	f04f 0100 	mov.w	r1, #0
  10bba4:	e73e      	b.n	10ba24 <__adddf3+0x138>
  10bba6:	bf00      	nop

0010bba8 <__aeabi_f2d>:
  10bba8:	0042      	lsls	r2, r0, #1
  10bbaa:	ea4f 01e2 	mov.w	r1, r2, asr #3
  10bbae:	ea4f 0131 	mov.w	r1, r1, rrx
  10bbb2:	ea4f 7002 	mov.w	r0, r2, lsl #28
  10bbb6:	bf1f      	itttt	ne
  10bbb8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  10bbbc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  10bbc0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  10bbc4:	4770      	bxne	r14
  10bbc6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
  10bbca:	bf08      	it	eq
  10bbcc:	4770      	bxeq	r14
  10bbce:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
  10bbd2:	bf04      	itt	eq
  10bbd4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
  10bbd8:	4770      	bxeq	r14
  10bbda:	b530      	push	{r4, r5, r14}
  10bbdc:	f44f 7460 	mov.w	r4, #896	; 0x380
  10bbe0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  10bbe4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  10bbe8:	e71c      	b.n	10ba24 <__adddf3+0x138>
  10bbea:	bf00      	nop

0010bbec <__aeabi_ul2d>:
  10bbec:	ea50 0201 	orrs.w	r2, r0, r1
  10bbf0:	bf08      	it	eq
  10bbf2:	4770      	bxeq	r14
  10bbf4:	b530      	push	{r4, r5, r14}
  10bbf6:	f04f 0500 	mov.w	r5, #0
  10bbfa:	e00a      	b.n	10bc12 <__aeabi_l2d+0x16>

0010bbfc <__aeabi_l2d>:
  10bbfc:	ea50 0201 	orrs.w	r2, r0, r1
  10bc00:	bf08      	it	eq
  10bc02:	4770      	bxeq	r14
  10bc04:	b530      	push	{r4, r5, r14}
  10bc06:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  10bc0a:	d502      	bpl.n	10bc12 <__aeabi_l2d+0x16>
  10bc0c:	4240      	negs	r0, r0
  10bc0e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  10bc12:	f44f 6480 	mov.w	r4, #1024	; 0x400
  10bc16:	f104 0432 	add.w	r4, r4, #50	; 0x32
  10bc1a:	ea5f 5c91 	movs.w	r12, r1, lsr #22
  10bc1e:	f43f aed8 	beq.w	10b9d2 <__adddf3+0xe6>
  10bc22:	f04f 0203 	mov.w	r2, #3
  10bc26:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  10bc2a:	bf18      	it	ne
  10bc2c:	3203      	addne	r2, #3
  10bc2e:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  10bc32:	bf18      	it	ne
  10bc34:	3203      	addne	r2, #3
  10bc36:	eb02 02dc 	add.w	r2, r2, r12, lsr #3
  10bc3a:	f1c2 0320 	rsb	r3, r2, #32
  10bc3e:	fa00 fc03 	lsl.w	r12, r0, r3
  10bc42:	fa20 f002 	lsr.w	r0, r0, r2
  10bc46:	fa01 fe03 	lsl.w	r14, r1, r3
  10bc4a:	ea40 000e 	orr.w	r0, r0, r14
  10bc4e:	fa21 f102 	lsr.w	r1, r1, r2
  10bc52:	4414      	add	r4, r2
  10bc54:	e6bd      	b.n	10b9d2 <__adddf3+0xe6>
  10bc56:	bf00      	nop

0010bc58 <__aeabi_uldivmod>:
  10bc58:	b953      	cbnz	r3, 10bc70 <__aeabi_uldivmod+0x18>
  10bc5a:	b94a      	cbnz	r2, 10bc70 <__aeabi_uldivmod+0x18>
  10bc5c:	2900      	cmp	r1, #0
  10bc5e:	bf08      	it	eq
  10bc60:	2800      	cmpeq	r0, #0
  10bc62:	bf1c      	itt	ne
  10bc64:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
  10bc68:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  10bc6c:	f000 b8ae 	b.w	10bdcc <__aeabi_idiv0>
  10bc70:	f1ad 0c08 	sub.w	r12, r13, #8
  10bc74:	e96d ce04 	strd	r12, r14, [r13, #-16]!
  10bc78:	f000 f806 	bl	10bc88 <__udivmoddi4>
  10bc7c:	f8dd e004 	ldr.w	r14, [r13, #4]
  10bc80:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
  10bc84:	b004      	add	sp, #16
  10bc86:	4770      	bx	r14

0010bc88 <__udivmoddi4>:
  10bc88:	4299      	cmp	r1, r3
  10bc8a:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  10bc8e:	bf08      	it	eq
  10bc90:	4290      	cmpeq	r0, r2
  10bc92:	b083      	sub	sp, #12
  10bc94:	4682      	mov	r10, r0
  10bc96:	468b      	mov	r11, r1
  10bc98:	f8dd 8030 	ldr.w	r8, [r13, #48]	; 0x30
  10bc9c:	d37c      	bcc.n	10bd98 <__udivmoddi4+0x110>
  10bc9e:	4610      	mov	r0, r2
  10bca0:	4619      	mov	r1, r3
  10bca2:	fab3 f283 	clz	r2, r3
  10bca6:	2b00      	cmp	r3, #0
  10bca8:	f000 8084 	beq.w	10bdb4 <__udivmoddi4+0x12c>
  10bcac:	fabb f38b 	clz	r3, r11
  10bcb0:	f1bb 0f00 	cmp.w	r11, #0
  10bcb4:	d07a      	beq.n	10bdac <__udivmoddi4+0x124>
  10bcb6:	1ad3      	subs	r3, r2, r3
  10bcb8:	f1a3 0e20 	sub.w	r14, r3, #32
  10bcbc:	fa01 f703 	lsl.w	r7, r1, r3
  10bcc0:	fa00 f20e 	lsl.w	r2, r0, r14
  10bcc4:	f1c3 0c20 	rsb	r12, r3, #32
  10bcc8:	4317      	orrs	r7, r2
  10bcca:	fa20 f20c 	lsr.w	r2, r0, r12
  10bcce:	4317      	orrs	r7, r2
  10bcd0:	fa00 f603 	lsl.w	r6, r0, r3
  10bcd4:	45bb      	cmp	r11, r7
  10bcd6:	bf08      	it	eq
  10bcd8:	45b2      	cmpeq	r10, r6
  10bcda:	d362      	bcc.n	10bda2 <__udivmoddi4+0x11a>
  10bcdc:	ebba 0a06 	subs.w	r10, r10, r6
  10bce0:	f04f 0201 	mov.w	r2, #1
  10bce4:	eb6b 0b07 	sbc.w	r11, r11, r7
  10bce8:	fa02 f10e 	lsl.w	r1, r2, r14
  10bcec:	fa22 f90c 	lsr.w	r9, r2, r12
  10bcf0:	409a      	lsls	r2, r3
  10bcf2:	ea41 0109 	orr.w	r1, r1, r9
  10bcf6:	9200      	str	r2, [sp, #0]
  10bcf8:	9101      	str	r1, [sp, #4]
  10bcfa:	2b00      	cmp	r3, #0
  10bcfc:	d042      	beq.n	10bd84 <__udivmoddi4+0xfc>
  10bcfe:	087f      	lsrs	r7, r7, #1
  10bd00:	ea4f 0636 	mov.w	r6, r6, rrx
  10bd04:	461a      	mov	r2, r3
  10bd06:	e00c      	b.n	10bd22 <__udivmoddi4+0x9a>
  10bd08:	ebba 0006 	subs.w	r0, r10, r6
  10bd0c:	eb6b 0107 	sbc.w	r1, r11, r7
  10bd10:	1804      	adds	r4, r0, r0
  10bd12:	eb41 0501 	adc.w	r5, r1, r1
  10bd16:	f114 0a01 	adds.w	r10, r4, #1
  10bd1a:	f145 0b00 	adc.w	r11, r5, #0
  10bd1e:	3a01      	subs	r2, #1
  10bd20:	d009      	beq.n	10bd36 <__udivmoddi4+0xae>
  10bd22:	45bb      	cmp	r11, r7
  10bd24:	bf08      	it	eq
  10bd26:	45b2      	cmpeq	r10, r6
  10bd28:	d2ee      	bcs.n	10bd08 <__udivmoddi4+0x80>
  10bd2a:	eb1a 0a0a 	adds.w	r10, r10, r10
  10bd2e:	eb4b 0b0b 	adc.w	r11, r11, r11
  10bd32:	3a01      	subs	r2, #1
  10bd34:	d1f5      	bne.n	10bd22 <__udivmoddi4+0x9a>
  10bd36:	fa0b fc0c 	lsl.w	r12, r11, r12
  10bd3a:	e9dd 0100 	ldrd	r0, r1, [r13]
  10bd3e:	fa2a f203 	lsr.w	r2, r10, r3
  10bd42:	fa2b fe0e 	lsr.w	r14, r11, r14
  10bd46:	ea42 020c 	orr.w	r2, r2, r12
  10bd4a:	eb10 000a 	adds.w	r0, r0, r10
  10bd4e:	fa2b f903 	lsr.w	r9, r11, r3
  10bd52:	ea42 0a0e 	orr.w	r10, r2, r14
  10bd56:	f1a3 0c20 	sub.w	r12, r3, #32
  10bd5a:	f1c3 0220 	rsb	r2, r3, #32
  10bd5e:	fa09 f703 	lsl.w	r7, r9, r3
  10bd62:	fa0a fc0c 	lsl.w	r12, r10, r12
  10bd66:	ea47 070c 	orr.w	r7, r7, r12
  10bd6a:	fa2a f202 	lsr.w	r2, r10, r2
  10bd6e:	fa0a f603 	lsl.w	r6, r10, r3
  10bd72:	eb41 010b 	adc.w	r1, r1, r11
  10bd76:	4317      	orrs	r7, r2
  10bd78:	1b80      	subs	r0, r0, r6
  10bd7a:	46cb      	mov	r11, r9
  10bd7c:	eb61 0107 	sbc.w	r1, r1, r7
  10bd80:	e9cd 0100 	strd	r0, r1, [r13]
  10bd84:	f1b8 0f00 	cmp.w	r8, #0
  10bd88:	d001      	beq.n	10bd8e <__udivmoddi4+0x106>
  10bd8a:	e9c8 ab00 	strd	r10, r11, [r8]
  10bd8e:	e9dd 0100 	ldrd	r0, r1, [r13]
  10bd92:	b003      	add	sp, #12
  10bd94:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  10bd98:	2300      	movs	r3, #0
  10bd9a:	2400      	movs	r4, #0
  10bd9c:	e9cd 3400 	strd	r3, r4, [r13]
  10bda0:	e7f0      	b.n	10bd84 <__udivmoddi4+0xfc>
  10bda2:	2100      	movs	r1, #0
  10bda4:	2200      	movs	r2, #0
  10bda6:	e9cd 1200 	strd	r1, r2, [r13]
  10bdaa:	e7a6      	b.n	10bcfa <__udivmoddi4+0x72>
  10bdac:	faba f38a 	clz	r3, r10
  10bdb0:	3320      	adds	r3, #32
  10bdb2:	e780      	b.n	10bcb6 <__udivmoddi4+0x2e>
  10bdb4:	fab0 f380 	clz	r3, r0
  10bdb8:	f103 0220 	add.w	r2, r3, #32
  10bdbc:	fabb f38b 	clz	r3, r11
  10bdc0:	f1bb 0f00 	cmp.w	r11, #0
  10bdc4:	f47f af77 	bne.w	10bcb6 <__udivmoddi4+0x2e>
  10bdc8:	e7f0      	b.n	10bdac <__udivmoddi4+0x124>
  10bdca:	bf00      	nop

0010bdcc <__aeabi_idiv0>:
  10bdcc:	4770      	bx	r14
  10bdce:	bf00      	nop

0010bdd0 <__memcpy_from_thumb>:
  10bdd0:	4778      	bx	r15
  10bdd2:	46c0      	nop			; (mov r8, r8)
  10bdd4:	eafff967 	b	10a378 <memcpy>
