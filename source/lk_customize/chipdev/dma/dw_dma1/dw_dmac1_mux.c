/*
 * dw_dmac1_mux.c
 *
 * Copyright (c) 2019 Semidrive Semiconductor.
 * All rights reserved.
 *
 * dw dma controller mux c file
 * This file define dmac table for hand shaking selection.
 * Revision History:
 * -----------------
 * 0.1, 4/8/2019 yishao init version
 */
#ifndef __DW_DMAC1_MUX_C
#define __DW_DMAC1_MUX_C
#include "dw_dmac1_mux.h"
#include "res.h"
#include "stdio.h"
#include "stdlib.h"
#include <debug.h>
#include <platform/debug.h>
/**
 * @description:
 * A DMA mux table, used to calculate hand shark number.
 * This init version, different version will use different table.
 */
dmac1_mux_param_t dma1_mux_tbl[] = {

    {DMA1_MUX_CAN1, APB_CAN1_BASE, 0xFFFF, DMA1_MUX_BOTH},
    {DMA1_MUX_CAN2, APB_CAN2_BASE, 0xFFFF, DMA1_MUX_BOTH},
    {DMA1_MUX_CAN3, APB_CAN3_BASE, 0xFFFF, DMA1_MUX_BOTH},
    {DMA1_MUX_CAN4, APB_CAN4_BASE, 0xFFFF, DMA1_MUX_BOTH},

    {DMA1_MUX_ENET1_REQ0, APB_ENET_QOS1_BASE + 0xb80, 4, DMA1_MUX_BOTH},
    {DMA1_MUX_ENET1_REQ1, APB_ENET_QOS1_BASE + 0xb80 + 0x10, 4, DMA1_MUX_BOTH},
    {DMA1_MUX_ENET1_REQ2, APB_ENET_QOS1_BASE + 0xb80 + 0x20, 4, DMA1_MUX_BOTH},
    {DMA1_MUX_ENET1_REQ3, APB_ENET_QOS1_BASE + 0xb80 + 0x30, 4, DMA1_MUX_BOTH},

    {DMA1_MUX_I2C1_TX, APB_I2C1_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_I2C1_RX, APB_I2C1_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_I2C2_TX, APB_I2C2_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_I2C2_RX, APB_I2C2_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_I2C3_TX, APB_I2C3_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_I2C3_RX, APB_I2C3_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_I2C4_TX, APB_I2C4_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_I2C4_RX, APB_I2C4_BASE, 0xFFFF, DMA1_MUX_RD},

    {DMA1_MUX_I2S_SC1_RX, APB_I2S_SC1_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_I2S_SC1_TX, APB_I2S_SC1_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_I2S_SC2_RX, APB_I2S_SC2_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_I2S_SC2_TX, APB_I2S_SC2_BASE, 0xFFFF, DMA1_MUX_WR},

    {DMA1_MUX_OSPI1_RX, OSPI1_BASE, 0x03FFFFFF, DMA1_MUX_RD},
    {DMA1_MUX_OSPI1_TX, OSPI1_BASE, 0x03FFFFFF, DMA1_MUX_WR},

    {DMA1_MUX_PWM1_REQ, APB_PWM1_BASE, 0xFFFF, DMA1_MUX_BOTH},
    {DMA1_MUX_PWM2_REQ, APB_PWM2_BASE, 0xFFFF, DMA1_MUX_BOTH},

    {DMA1_MUX_SPI1_RX, APB_SPI1_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_SPI1_TX, APB_SPI1_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_SPI2_RX, APB_SPI2_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_SPI2_TX, APB_SPI2_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_SPI3_RX, APB_SPI3_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_SPI3_TX, APB_SPI3_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_SPI4_RX, APB_SPI4_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_SPI4_TX, APB_SPI4_BASE, 0xFFFF, DMA1_MUX_WR},

    {DMA1_MUX_TIMER1_REQA, APB_TIMER1_BASE + 0x30, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQA, APB_TIMER1_BASE + 0xA0, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQB, APB_TIMER1_BASE + 0x34, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQB, APB_TIMER1_BASE + 0xA4, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQC, APB_TIMER1_BASE + 0x38, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQC, APB_TIMER1_BASE + 0xA8, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQD, APB_TIMER1_BASE + 0x3C, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_REQD, APB_TIMER1_BASE + 0xAC, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER1_OVF, APB_TIMER1_BASE + 0x28, 0x8, DMA1_MUX_BOTH},

    {DMA1_MUX_TIMER2_REQA, APB_TIMER2_BASE + 0x30, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQA, APB_TIMER2_BASE + 0xA0, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQB, APB_TIMER2_BASE + 0x34, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQB, APB_TIMER2_BASE + 0xA4, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQC, APB_TIMER2_BASE + 0x38, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQC, APB_TIMER2_BASE + 0xA8, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQD, APB_TIMER2_BASE + 0x3C, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_REQD, APB_TIMER2_BASE + 0xAC, 0x4, DMA1_MUX_BOTH},
    {DMA1_MUX_TIMER2_OVF, APB_TIMER2_BASE + 0x28, 0x8, DMA1_MUX_BOTH},

    {DMA1_MUX_UART1_TX, APB_UART1_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART1_RX, APB_UART1_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART2_TX, APB_UART2_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART2_RX, APB_UART2_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART3_TX, APB_UART3_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART3_RX, APB_UART3_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART4_TX, APB_UART4_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART4_RX, APB_UART4_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART5_TX, APB_UART5_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART5_RX, APB_UART5_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART6_TX, APB_UART6_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART6_RX, APB_UART6_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART7_TX, APB_UART7_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART7_RX, APB_UART7_BASE, 0xFFFF, DMA1_MUX_RD},
    {DMA1_MUX_UART8_TX, APB_UART8_BASE, 0xFFFF, DMA1_MUX_WR},
    {DMA1_MUX_UART8_RX, APB_UART8_BASE, 0xFFFF, DMA1_MUX_RD},

};

#define DMAC1_MUX_PARAM_NUM (sizeof(dma1_mux_tbl) / sizeof(dma1_mux_tbl[0]))

/* from address get hs number. */
int get_dma1_hs_id(u64 addr, DMR1_MUX_DIRECT direct)
{
  for (unsigned int i = 0; i < DMAC1_MUX_PARAM_NUM; i++)
  {
    if ((addr >= p2ap(dma1_mux_tbl[i].start_addr)) &&
        (addr < (p2ap(dma1_mux_tbl[i].start_addr) + dma1_mux_tbl[i].len)))
    {
      if ((direct & dma1_mux_tbl[i].direct) > 0)
      {
        return dma1_mux_tbl[i].port;
      }
    }
  }
  dprintf(
      ALWAYS,
      "WARNING: get_dma1_hs_id missed with direction(%d) and addr(0x%llx) \n",
      direct, addr);
  return DMA1_MUX_ERR_NO;
}
#endif
