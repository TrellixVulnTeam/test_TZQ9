/*
* Copyright (c) 2019 Semidrive Semiconductor.
* All rights reserved.
*
*/

#include <err.h>
#include <string.h>

#include <app.h>
#include <lib/console.h>
#include <platform.h>

#include <sd_rsa.h>
#include <trace.h>

#define LOCAL_TRACE 1 //close local trace 1->0

#define RSA_1024_LEN        128
#define RSA_4096_LEN        512
/*
typedef enum ce_addr_type_t {
    SRAM_PUB = 0,
    SRAM_SEC = 1,
    KEY_INT = 2,
    EXT_MEM = 3,
    PKE_INTERNAL = 4
} ce_addr_type_t;*/

uint8_t demo_msg_1024[RSA_1024_LEN] =
    "\x00\xeb\x7a\x19\xac\xe9\xe3\x00\x63\x50\xe3\x29\x50\x4b\x45\xe2"
    "\xca\x82\x31\x0b\x26\xdc\xd8\x7d\x5c\x68\xf1\xee\xa8\xf5\x52\x67"
    "\xc3\x1b\x2e\x8b\xb4\x25\x1f\x84\xd7\xe0\xb2\xc0\x46\x26\xf5\xaf"
    "\xf9\x3e\xdc\xfb\x25\xc9\xc2\xb3\xff\x8a\xe1\x0e\x83\x9a\x2d\xdb"
    "\x4c\xdc\xfe\x4f\xf4\x77\x28\xb4\xa1\xb7\xc1\x36\x2b\xaa\xd2\x9a"
    "\xb4\x8d\x28\x69\xd5\x02\x41\x21\x43\x58\x11\x59\x1b\xe3\x92\xf9"
    "\x82\xfb\x3e\x87\xd0\x95\xae\xb4\x04\x48\xdb\x97\x2f\x3a\xc1\x4f"
    "\x7b\xc2\x75\x19\x52\x81\xce\x32\xd2\xf1\xb7\x6d\x4d\x35\x3e\x2d";

uint8_t demo_n_1024[RSA_1024_LEN] =
    "\xbb\xf8\x2f\x09\x06\x82\xce\x9c\x23\x38\xac\x2b\x9d\xa8\x71\xf7"
    "\x36\x8d\x07\xee\xd4\x10\x43\xa4\x40\xd6\xb6\xf0\x74\x54\xf5\x1f"
    "\xb8\xdf\xba\xaf\x03\x5c\x02\xab\x61\xea\x48\xce\xeb\x6f\xcd\x48"
    "\x76\xed\x52\x0d\x60\xe1\xec\x46\x19\x71\x9d\x8a\x5b\x8b\x80\x7f"
    "\xaf\xb8\xe0\xa3\xdf\xc7\x37\x72\x3e\xe6\xb4\xb7\xd9\x3a\x25\x84"
    "\xee\x6a\x64\x9d\x06\x09\x53\x74\x88\x34\xb2\x45\x45\x98\x39\x4e"
    "\xe0\xaa\xb1\x2d\x7b\x61\xa5\x1f\x52\x7a\x9a\x41\xf6\xc1\x68\x7f"
    "\xe2\x53\x72\x98\xca\x2a\x8f\x59\x46\xf8\xe5\xfd\x09\x1d\xbd\xcb";

uint8_t demo_public_expo_1024[RSA_1024_LEN] =
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x11";

uint32_t rsa_encrypt_demo(uint32_t vce_id, uint32_t keysize, uint8_t* n, uint8_t* pub_expo, uint8_t* msg, uint8_t* out)
{
    uint32_t res = 0;
    rsa_pubkey_t rsa_pubkey_temp;
    uint8_t result32[RSA_4096_LEN];
    uint32_t result_len = keysize;
    void* crypto_handle;

    rsa_pubkey_temp.n = n;
    rsa_pubkey_temp.n_len = keysize;
    rsa_pubkey_temp.e = pub_expo;
    rsa_pubkey_temp.e_len = keysize;

    hal_crypto_creat_handle(&crypto_handle, vce_id);

    if (crypto_handle == NULL) {
        return res;
    }

    res = hal_rsa_encrypt(crypto_handle, &rsa_pubkey_temp, msg, keysize, result32, result_len, ESEC_RSA_PADDING_NONE);

    hal_crypto_delete_handle(crypto_handle);

    if (res == CRYPTO_SUCCESS) {

        LTRACEF("RSA_encrypt keysize = %d, success\n", keysize);
        memcpy(out, result32, keysize);
        res = 1;
    }

    return res;
}

uint32_t rsa_demo_entry(void)
{
    uint8_t enc_out[RSA_4096_LEN];
    uint32_t vce_id = RES_CE_MEM_CE2_VCE1;

    LTRACEF("-----rsa_demo_entry start------\n");
    rsa_encrypt_demo(vce_id, RSA_1024_LEN, demo_n_1024, demo_public_expo_1024, demo_msg_1024, enc_out);

    return 0;

}


#if defined(WITH_LIB_CONSOLE)

STATIC_COMMAND_START

STATIC_COMMAND("rsa_demo", "rsa demo function", (console_cmd)&rsa_demo_entry)

STATIC_COMMAND_END(rsa_demo);

#endif

APP_START(rsa_demo)
.flags = 0
         APP_END
