
lk_customize/build-dloader_d9_ref/lk.elf:     file format elf32-littlearm


Disassembly of section .text:

30000000 <_start>:

.section ".text.boot"
.globl _start
_start:
#if WITH_NO_PHYS_RELOCATION
    ldr  pc,  =platform_reset
30000000:	e59ff018 	ldr	r15, [pc, #24]	; 30000020 <_start+0x20>
    ldr  pc,  =arm_undefined
30000004:	e59ff018 	ldr	r15, [pc, #24]	; 30000024 <_start+0x24>
    ldr  pc,  =arm_syscall
30000008:	e59ff018 	ldr	r15, [pc, #24]	; 30000028 <_start+0x28>
    ldr  pc,  =arm_prefetch_abort
3000000c:	e59ff018 	ldr	r15, [pc, #24]	; 3000002c <_start+0x2c>
    ldr  pc,  =arm_data_abort
30000010:	e59ff018 	ldr	r15, [pc, #24]	; 30000030 <_start+0x30>
    ldr  pc,  =arm_reserved
30000014:	e59ff018 	ldr	r15, [pc, #24]	; 30000034 <_start+0x34>
    ldr  pc,  =arm_irq
30000018:	e59ff018 	ldr	r15, [pc, #24]	; 30000038 <_start+0x38>
    ldr  pc,  =arm_fiq
3000001c:	e59ff018 	ldr	r15, [pc, #24]	; 3000003c <_start+0x3c>
    ldr  pc,  =platform_reset
30000020:	30000040 	.word	0x30000040
    ldr  pc,  =arm_undefined
30000024:	30000d34 	.word	0x30000d34
    ldr  pc,  =arm_syscall
30000028:	30000d8c 	.word	0x30000d8c
    ldr  pc,  =arm_prefetch_abort
3000002c:	30000de4 	.word	0x30000de4
    ldr  pc,  =arm_data_abort
30000030:	30000e40 	.word	0x30000e40
    ldr  pc,  =arm_reserved
30000034:	30000e9c 	.word	0x30000e9c
    ldr  pc,  =arm_irq
30000038:	30000ea0 	.word	0x30000ea0
    ldr  pc,  =arm_fiq
3000003c:	30000f24 	.word	0x30000f24

30000040 <arm_reset>:
    /* Fall through for the weak symbol */

.globl arm_reset
arm_reset:
#ifdef LOCKSTEP_SCR_ADDR
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
30000040:	e59f017c 	ldr	r0, [pc, #380]	; 300001c4 <arm_reset+0x184>
    ldr     r1, [r0, #0]
30000044:	e5901000 	ldr	r1, [r0]
    bic     r1, #(0x3<<LOCKSTEP_SCR_BIT)
30000048:	e3c11003 	bic	r1, r1, #3
    str     r1, [r0, #0]
3000004c:	e5801000 	str	r1, [r0]
#endif
    mov     r0, #0    /* initialize general registers */
30000050:	e3a00000 	mov	r0, #0
    mov     r1, #0
30000054:	e3a01000 	mov	r1, #0
    mov     r2, #0
30000058:	e3a02000 	mov	r2, #0
    mov     r3, #0
3000005c:	e3a03000 	mov	r3, #0
    mov     r4, #0
30000060:	e3a04000 	mov	r4, #0
    mov     r5, #0
30000064:	e3a05000 	mov	r5, #0
    mov     r6, #0
30000068:	e3a06000 	mov	r6, #0
    mov     r7, #0
3000006c:	e3a07000 	mov	r7, #0
    mov     r8, #0
30000070:	e3a08000 	mov	r8, #0
    mov     r9, #0
30000074:	e3a09000 	mov	r9, #0
    mov     r10, #0
30000078:	e3a0a000 	mov	r10, #0
    mov     r11, #0
3000007c:	e3a0b000 	mov	r11, #0
    mov     r12, #0
30000080:	e3a0c000 	mov	r12, #0
    mov     sp, r0
30000084:	e1a0d000 	mov	r13, r0
    mov     lr, #0
30000088:	e3a0e000 	mov	r14, #0
    mrs     r4, cpsr	/* save the CPSR */
3000008c:	e10f4000 	mrs	r4, CPSR
    msr spsr_fsxc, r4	/*load spsr with value from cpsr*/
30000090:	e16ff004 	msr	SPSR_fsxc, r4

    /* at this point we're running at our final location in virtual memory (if enabled) */
.Lstack_setup:
    /* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */
    mov     r12, #0
30000094:	e3a0c000 	mov	r12, #0

    cpsid   i,#0x12       /* irq */
30000098:	f10e0092 	cpsid	i,#18
    mov     sp, r12
3000009c:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
300000a0:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
300000a4:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x11       /* fiq */
300000a8:	f10e0091 	cpsid	i,#17
    mov     r8, #0            /* r8/r9/r10/r11/r12 fiq dedicated registers */
300000ac:	e3a08000 	mov	r8, #0
    mov     r9, #0
300000b0:	e3a09000 	mov	r9, #0
    mov     r10, #0
300000b4:	e3a0a000 	mov	r10, #0
    mov     r11, #0
300000b8:	e3a0b000 	mov	r11, #0
    mov     r12, #0
300000bc:	e3a0c000 	mov	r12, #0
    mov     sp, r12
300000c0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
300000c4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
300000c8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x17       /* abort */
300000cc:	f10e0097 	cpsid	i,#23
    mov     sp, r12
300000d0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
300000d4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
300000d8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x1b       /* undefined */
300000dc:	f10e009b 	cpsid	i,#27
    mov     sp, r12
300000e0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
300000e4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
300000e8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x1f       /* system */
300000ec:	f10e009f 	cpsid	i,#31
    mov     sp, r12
300000f0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
300000f4:	e3a0e000 	mov	r14, #0
    cpsid   i,#0x13       /* supervisor */
300000f8:	f10e0093 	cpsid	i,#19
    ldr     r12, =abort_stack
300000fc:	e59fc0c4 	ldr	r12, [pc, #196]	; 300001c8 <arm_reset+0x188>
    add     r12, #ARCH_DEFAULT_STACK_SIZE
30000100:	e28cca01 	add	r12, r12, #4096	; 0x1000
    mov     sp, r12
30000104:	e1a0d00c 	mov	r13, r12

    /* stay in supervisor mode from now on out */

#if defined(ARM_WITH_VFP)
    ldr     r0, =0x00F00000
30000108:	e3a0060f 	mov	r0, #15728640	; 0xf00000
    mcr     p15, 0, r0, c1, c0, 2	/* Enable coprocessor access in CPACR */
3000010c:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
    ldr     r2, =0x40000000
30000110:	e3a02101 	mov	r2, #1073741824	; 0x40000000
    vmsr    fpexc, r2	/* Enable FPU access so that VFP registers can be initialized */
30000114:	eee82a10 	vmsr	fpexc, r2
    vmov    D0, r5, r6	/* r5/6 is 0 now */
30000118:	ec465b10 	vmov	d0, r5, r6
    vmov    D1, r5, r6
3000011c:	ec465b11 	vmov	d1, r5, r6
    vmov    D2, r5, r6
30000120:	ec465b12 	vmov	d2, r5, r6
    vmov    D3, r5, r6
30000124:	ec465b13 	vmov	d3, r5, r6
    vmov    D4, r5, r6
30000128:	ec465b14 	vmov	d4, r5, r6
    vmov    D5, r5, r6
3000012c:	ec465b15 	vmov	d5, r5, r6
    vmov    D6, r5, r6
30000130:	ec465b16 	vmov	d6, r5, r6
    vmov    D7, r5, r6
30000134:	ec465b17 	vmov	d7, r5, r6
    vmov    D8, r5, r6
30000138:	ec465b18 	vmov	d8, r5, r6
    vmov    D9, r5, r6
3000013c:	ec465b19 	vmov	d9, r5, r6
    vmov    D10, r5, r6
30000140:	ec465b1a 	vmov	d10, r5, r6
    vmov    D11, r5, r6
30000144:	ec465b1b 	vmov	d11, r5, r6
    vmov    D12, r5, r6
30000148:	ec465b1c 	vmov	d12, r5, r6
    vmov    D13, r5, r6
3000014c:	ec465b1d 	vmov	d13, r5, r6
    vmov    D14, r5, r6
30000150:	ec465b1e 	vmov	d14, r5, r6
    vmov    D15, r5, r6
30000154:	ec465b1f 	vmov	d15, r5, r6
#endif

    /* do some early cpu setup */
    mrc     p15, 0, r12, c1, c0, 0
30000158:	ee11cf10 	mrc	15, 0, r12, cr1, cr0, {0}
    /* i/d cache disable, mmu disabled */
    bic     r12, #(1<<12)
3000015c:	e3ccca01 	bic	r12, r12, #4096	; 0x1000
    bic     r12, #(1<<2 | 1<<0)
30000160:	e3ccc005 	bic	r12, r12, #5
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    orr     r12, r12, #(1<<12)
    orr     r12, r12, #(1<<2)
#endif // WITH_KERNEL_VM
    mcr     p15, 0, r12, c1, c0, 0
30000164:	ee01cf10 	mcr	15, 0, r12, cr1, cr0, {0}

    /* enable LLPP Normal AXI region */
    mrc     p15, 0, r12, c15, c0, 1
30000168:	ee1fcf30 	mrc	15, 0, r12, cr15, cr0, {1}
    orr     r12, r12, #1
3000016c:	e38cc001 	orr	r12, r12, #1
    mcr     p15, 0, r12, c15, c0, 1
30000170:	ee0fcf30 	mcr	15, 0, r12, cr15, cr0, {1}

    /* calculate the physical offset from our eventual virtual location */
.Lphys_offset:
    ldr     r4, =.Lphys_offset
30000174:	e59f4050 	ldr	r4, [pc, #80]	; 300001cc <arm_reset+0x18c>
    adr     r11, .Lphys_offset
30000178:	e24fb00c 	sub	r11, r15, #12
    sub     r11, r11, r4
3000017c:	e04bb004 	sub	r11, r11, r4
    /* set up the mmu */
    bl      .Lmmu_setup
#endif // WITH_KERNEL_VM

    /* copy the initialized data segment out of rom if necessary */
    ldr     r4, =__data_start_rom
30000180:	e59f4048 	ldr	r4, [pc, #72]	; 300001d0 <arm_reset+0x190>
    ldr     r5, =__data_start
30000184:	e59f5048 	ldr	r5, [pc, #72]	; 300001d4 <arm_reset+0x194>
    ldr     r6, =__data_end
30000188:	e59f6048 	ldr	r6, [pc, #72]	; 300001d8 <arm_reset+0x198>

    cmp     r4, r5
3000018c:	e1540005 	cmp	r4, r5
    beq     .L__do_bss
30000190:	0a000003 	beq	300001a4 <arm_reset+0x164>

.L__copy_loop:
    cmp     r5, r6
30000194:	e1550006 	cmp	r5, r6
    ldrlt   r7, [r4], #4
30000198:	b4947004 	ldrlt	r7, [r4], #4
    strlt   r7, [r5], #4
3000019c:	b4857004 	strlt	r7, [r5], #4
    blt     .L__copy_loop
300001a0:	bafffffb 	blt	30000194 <arm_reset+0x154>

.L__do_bss:
    /* clear out the bss */
    ldr     r4, =__bss_start
300001a4:	e59f4030 	ldr	r4, [pc, #48]	; 300001dc <arm_reset+0x19c>
    ldr     r5, =_end
300001a8:	e59f5030 	ldr	r5, [pc, #48]	; 300001e0 <arm_reset+0x1a0>
    mov     r6, #0
300001ac:	e3a06000 	mov	r6, #0
.L__bss_loop:
    cmp     r4, r5
300001b0:	e1540005 	cmp	r4, r5
    strlt   r6, [r4], #4
300001b4:	b4846004 	strlt	r6, [r4], #4
    blt     .L__bss_loop
300001b8:	bafffffc 	blt	300001b0 <arm_reset+0x170>

    bl      lk_main
300001bc:	fa0006c5 	blx	30001cd8 <lk_main>
    b       .
300001c0:	eafffffe 	b	300001c0 <arm_reset+0x180>
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
300001c4:	f82ad000 	.word	0xf82ad000
    ldr     r12, =abort_stack
300001c8:	30025c60 	.word	0x30025c60
    ldr     r4, =.Lphys_offset
300001cc:	30000174 	.word	0x30000174
    ldr     r4, =__data_start_rom
300001d0:	30022100 	.word	0x30022100
    ldr     r5, =__data_start
300001d4:	30022100 	.word	0x30022100
    ldr     r6, =__data_end
300001d8:	300254ac 	.word	0x300254ac
    ldr     r4, =__bss_start
300001dc:	30025c00 	.word	0x30025c00
    ldr     r5, =_end
300001e0:	3002e8cc 	.word	0x3002e8cc

300001e4 <target_early_init>:

static void uart_port_config(void)
{
    void *g_handle;
    bool ret;
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
300001e4:	f64f 3338 	movw	r3, #64312	; 0xfb38
300001e8:	f2c3 0301 	movt	r3, #12289	; 0x3001
    return ret;
}

#endif
void target_early_init(void)
{
300001ec:	b500      	push	{r14}
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
300001ee:	6859      	ldr	r1, [r3, #4]
{
300001f0:	b083      	sub	sp, #12
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
300001f2:	a801      	add	r0, sp, #4
300001f4:	f00f fb58 	bl	3000f8a8 <hal_port_creat_handle>
    if (!ret) {
300001f8:	b1b8      	cbz	r0, 3000022a <target_early_init+0x46>
    hal_port_set_pin_mode(g_handle, PortConf_PIN_GPIO_C6, uart10_tx);
300001fa:	f649 73e4 	movw	r3, #40932	; 0x9fe4
300001fe:	2136      	movs	r1, #54	; 0x36
30000200:	9801      	ldr	r0, [sp, #4]
30000202:	f2c3 0301 	movt	r3, #12289	; 0x3001
30000206:	cb0c      	ldmia	r3, {r2, r3}
30000208:	f00f fc12 	bl	3000fa30 <hal_port_set_pin_mode>
    hal_port_set_pin_mode(g_handle, PortConf_PIN_GPIO_C7, uart10_rx);
3000020c:	f649 73e4 	movw	r3, #40932	; 0x9fe4
30000210:	2137      	movs	r1, #55	; 0x37
30000212:	f2c3 0301 	movt	r3, #12289	; 0x3001
30000216:	9801      	ldr	r0, [sp, #4]
30000218:	cb0c      	ldmia	r3, {r2, r3}
3000021a:	f00f fc09 	bl	3000fa30 <hal_port_set_pin_mode>
    hal_port_release_handle(&g_handle);
3000021e:	a801      	add	r0, sp, #4
30000220:	f00f fbac 	bl	3000f97c <hal_port_release_handle>
        change_voltage(800, 850, 850);
    else
        change_voltage(720, 850, 850);

#endif
}
30000224:	b003      	add	sp, #12
30000226:	f85d fb04 	ldr.w	r15, [r13], #4
        printf("create prot hal failed.\n");
3000022a:	f649 70c8 	movw	r0, #40904	; 0x9fc8
3000022e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30000232:	f015 fcbd 	bl	30015bb0 <_printf>
}
30000236:	b003      	add	sp, #12
30000238:	f85d fb04 	ldr.w	r15, [r13], #4

3000023c <target_init>:

void target_init(void)
{
}
3000023c:	4770      	bx	r14
3000023e:	bf00      	nop

30000240 <platform_cpu_reset>:
 * Remap core vector, and reset the core.
 */
void platform_cpu_reset(addr_t img_base)
{
    /* base address must be 4 KB aligned */
    ASSERT((img_base & 0xFFF) == 0);
30000240:	f3c0 030b 	ubfx	r3, r0, #0, #12
{
30000244:	b5f0      	push	{r4, r5, r6, r7, r14}
30000246:	4674      	mov	r4, r14
30000248:	b085      	sub	sp, #20
    ASSERT((img_base & 0xFFF) == 0);
3000024a:	2b00      	cmp	r3, #0
3000024c:	d14e      	bne.n	300002ec <platform_cpu_reset+0xac>
    dprintf(INFO, "Remapping ARM vector to 0x%lx!\n", img_base);
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
3000024e:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
30000252:	f644 5250 	movw	r2, #19792	; 0x4d50
30000256:	f6cf 0341 	movt	r3, #63553	; 0xf841
3000025a:	4605      	mov	r5, r0
3000025c:	f2c5 2245 	movt	r2, #21061	; 0x5245
    /* Enable R5 remapping to vector base. The remap config doesn't
     * take effect until REMAP module detects R5 core reset.
     */
    scr_handle_t handle;
    handle = hal_scr_create_handle(
30000260:	2014      	movs	r0, #20
30000262:	f240 1103 	movw	r1, #259	; 0x103
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
30000266:	601a      	str	r2, [r3, #0]
    handle = hal_scr_create_handle(
30000268:	f2c0 4030 	movt	r0, #1072	; 0x430
3000026c:	f00f fdc2 	bl	3000fdf4 <hal_scr_create_handle>
30000270:	4606      	mov	r6, r0
30000272:	460f      	mov	r7, r1
                        SCR_SEC__L31__remap_cr5_sec_ar_addr_offset_19_0);
    ASSERT(handle);
30000274:	ea56 0307 	orrs.w	r3, r6, r7
30000278:	d06b      	beq.n	30000352 <platform_cpu_reset+0x112>
    hal_scr_set(handle, img_base >> 12);
3000027a:	0b2a      	lsrs	r2, r5, #12
3000027c:	f00f fdec 	bl	3000fe58 <hal_scr_set>
    hal_scr_delete_handle(handle);
30000280:	4630      	mov	r0, r6
30000282:	4639      	mov	r1, r7
30000284:	f00f fdb8 	bl	3000fdf8 <hal_scr_delete_handle>
    handle = hal_scr_create_handle(
30000288:	a13b      	add	r1, pc, #236	; (adr r1, 30000378 <platform_cpu_reset+0x138>)
3000028a:	e9d1 0100 	ldrd	r0, r1, [r1]
3000028e:	f00f fdb1 	bl	3000fdf4 <hal_scr_create_handle>
30000292:	4606      	mov	r6, r0
30000294:	460f      	mov	r7, r1
                        SCR_SEC__L31__remap_cr5_sec_ar_remap_ovrd_en);
    ASSERT(handle);
30000296:	ea56 0307 	orrs.w	r3, r6, r7
3000029a:	d049      	beq.n	30000330 <platform_cpu_reset+0xf0>
    hal_scr_set(handle, 1);
3000029c:	2201      	movs	r2, #1
3000029e:	f00f fddb 	bl	3000fe58 <hal_scr_set>
    hal_scr_delete_handle(handle);
300002a2:	4630      	mov	r0, r6
300002a4:	4639      	mov	r1, r7
300002a6:	f00f fda7 	bl	3000fdf8 <hal_scr_delete_handle>
    /* ROMC Stick Reg
     *
     * [0]: ROMC_STICKY_REMAP_EN. This bit is AND'ed with
     *      SCR remap_en bit, to enable remapping.
     */
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
300002aa:	2334      	movs	r3, #52	; 0x34
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
300002ac:	f44f 6180 	mov.w	r1, #1024	; 0x400
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
300002b0:	f2cf 036f 	movt	r3, #61551	; 0xf06f
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
300002b4:	a803      	add	r0, sp, #12
300002b6:	f2c8 1196 	movt	r1, #33174	; 0x8196
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
300002ba:	681a      	ldr	r2, [r3, #0]
300002bc:	f042 0201 	orr.w	r2, r2, #1
300002c0:	601a      	str	r2, [r3, #0]
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
300002c2:	f00f fcdb 	bl	3000fc7c <hal_rstgen_creat_handle>
    ASSERT(ret);
300002c6:	b310      	cbz	r0, 3000030e <platform_cpu_reset+0xce>
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
300002c8:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
300002cc:	f240 4104 	movw	r1, #1028	; 0x404
300002d0:	9803      	ldr	r0, [sp, #12]
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
300002d2:	f6cf 032a 	movt	r3, #63530	; 0xf82a
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
300002d6:	f2c8 1196 	movt	r1, #33174	; 0x8196
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
300002da:	681a      	ldr	r2, [r3, #0]
300002dc:	f042 0203 	orr.w	r2, r2, #3
300002e0:	601a      	str	r2, [r3, #0]
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
300002e2:	f00f fd4f 	bl	3000fd84 <hal_rstgen_core_reset>
        arch_idle();
300002e6:	f000 ed1c 	blx	30000d20 <arch_idle>
300002ea:	e7fc      	b.n	300002e6 <platform_cpu_reset+0xa6>
    ASSERT((img_base & 0xFFF) == 0);
300002ec:	f24a 033c 	movw	r3, #41020	; 0xa03c
300002f0:	f649 72ec 	movw	r2, #40940	; 0x9fec
300002f4:	f24a 011c 	movw	r1, #40988	; 0xa01c
300002f8:	f2c3 0301 	movt	r3, #12289	; 0x3001
300002fc:	4670      	mov	r0, r14
300002fe:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000302:	9300      	str	r3, [sp, #0]
30000304:	f2c3 0101 	movt	r1, #12289	; 0x3001
30000308:	2353      	movs	r3, #83	; 0x53
3000030a:	f013 ff83 	bl	30014214 <_panic>
    ASSERT(ret);
3000030e:	f24a 035c 	movw	r3, #41052	; 0xa05c
30000312:	f649 72ec 	movw	r2, #40940	; 0x9fec
30000316:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000031a:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000031e:	4620      	mov	r0, r4
30000320:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000324:	9300      	str	r3, [sp, #0]
30000326:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000032a:	2337      	movs	r3, #55	; 0x37
3000032c:	f013 ff72 	bl	30014214 <_panic>
    ASSERT(handle);
30000330:	f24a 0354 	movw	r3, #41044	; 0xa054
30000334:	f649 72ec 	movw	r2, #40940	; 0x9fec
30000338:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000033c:	f2c3 0301 	movt	r3, #12289	; 0x3001
30000340:	4620      	mov	r0, r4
30000342:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000346:	9300      	str	r3, [sp, #0]
30000348:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000034c:	2361      	movs	r3, #97	; 0x61
3000034e:	f013 ff61 	bl	30014214 <_panic>
    ASSERT(handle);
30000352:	f24a 0354 	movw	r3, #41044	; 0xa054
30000356:	f649 72ec 	movw	r2, #40940	; 0x9fec
3000035a:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000035e:	f2c3 0301 	movt	r3, #12289	; 0x3001
30000362:	4620      	mov	r0, r4
30000364:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000368:	9300      	str	r3, [sp, #0]
3000036a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000036e:	235c      	movs	r3, #92	; 0x5c
30000370:	f013 ff50 	bl	30014214 <_panic>
30000374:	f3af 8000 	nop.w
30000378:	04301401 	.word	0x04301401
3000037c:	00000103 	.word	0x00000103

30000380 <os_platform_early_init>:
    return;
}

__WEAK void os_platform_early_init(void)
{
}
30000380:	4770      	bx	r14
30000382:	bf00      	nop

30000384 <platform_early_init>:

void platform_early_init(void)
{
30000384:	b570      	push	{r4, r5, r6, r14}
30000386:	4676      	mov	r6, r14
30000388:	b084      	sub	sp, #16
    uart_init_early();
3000038a:	f000 f93d 	bl	30000608 <uart_init_early>
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
3000038e:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
30000392:	f644 5250 	movw	r2, #19792	; 0x4d50
30000396:	f6cf 0341 	movt	r3, #63553	; 0xf841
3000039a:	f2c5 2245 	movt	r2, #21061	; 0x5245
3000039e:	6819      	ldr	r1, [r3, #0]
300003a0:	4291      	cmp	r1, r2
300003a2:	d17d      	bne.n	300004a0 <platform_early_init+0x11c>
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
300003a4:	2400      	movs	r4, #0
    vuart_init();
#endif

    platform_remap();
    /* Enable TCM internal access. */
    tcm_enable(R5_SEC_TCMA_BASE, R5_SEC_TCMB_BASE, true);
300003a6:	f44f 0196 	mov.w	r1, #4915200	; 0x4b0000
300003aa:	f44f 0098 	mov.w	r0, #4980736	; 0x4c0000
300003ae:	2201      	movs	r2, #1
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
300003b0:	601c      	str	r4, [r3, #0]
    tcm_enable(R5_SEC_TCMA_BASE, R5_SEC_TCMB_BASE, true);
300003b2:	f001 fb3f 	bl	30001a34 <tcm_enable>
    /* Copy code and data into TCM. */
    platform_earlycopy();
300003b6:	f007 f9b9 	bl	3000772c <platform_earlycopy>
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
300003ba:	f44f 6180 	mov.w	r1, #1024	; 0x400
300003be:	a803      	add	r0, sp, #12
300003c0:	f2c8 1196 	movt	r1, #33174	; 0x8196
300003c4:	f00f fc5a 	bl	3000fc7c <hal_rstgen_creat_handle>
    ASSERT(ret);
300003c8:	2800      	cmp	r0, #0
300003ca:	d047      	beq.n	3000045c <platform_early_init+0xd8>
    hal_rstgen_module_reset(handle, RES_MODULE_RST_SEC_GIC2);
300003cc:	9803      	ldr	r0, [sp, #12]
300003ce:	f240 4153 	movw	r1, #1107	; 0x453
300003d2:	f2c8 1196 	movt	r1, #33174	; 0x8196
300003d6:	f00f fced 	bl	3000fdb4 <hal_rstgen_module_reset>
    hal_rstgen_release_handle(handle);
300003da:	9803      	ldr	r0, [sp, #12]
300003dc:	f00f fcc4 	bl	3000fd68 <hal_rstgen_release_handle>
    /* Release GIC from reset and initialize GIC. Clocks of GIC
     * 1~3 are enabled by default.
     */
    gic_reset();
    arm_gic_init_early();
300003e0:	f000 f9e0 	bl	300007a4 <arm_gic_init_early>
#if ARM_WITH_VFP
    arm_fpu_set_enable(true);
300003e4:	2001      	movs	r0, #1
300003e6:	f001 f9a7 	bl	30001738 <arm_fpu_set_enable>
#endif
#if SDRV_TIMER
    timer_init_early();
300003ea:	f000 fa19 	bl	30000820 <timer_init_early>
    mpu_enable(false);
300003ee:	4620      	mov	r0, r4
300003f0:	f001 fae2 	bl	300019b8 <mpu_enable>
    mpu_add_region(region++, cospi_trigger_address,
300003f4:	f44f 417e 	mov.w	r1, #65024	; 0xfe00
300003f8:	4620      	mov	r0, r4
300003fa:	f2c0 71ff 	movt	r1, #2047	; 0x7ff
300003fe:	2301      	movs	r3, #1
30000400:	f44f 7200 	mov.w	r2, #512	; 0x200
30000404:	f001 fa56 	bl	300018b4 <mpu_add_region>
    mpu_add_region(region++, cospi_trigger_address,
30000408:	2301      	movs	r3, #1
3000040a:	f44f 417e 	mov.w	r1, #65024	; 0xfe00
3000040e:	4618      	mov	r0, r3
30000410:	f44f 7200 	mov.w	r2, #512	; 0x200
30000414:	f6c0 31ff 	movt	r1, #3071	; 0xbff
30000418:	f001 fa4c 	bl	300018b4 <mpu_add_region>
    region = platform_mpu_r5_common(region);
3000041c:	2002      	movs	r0, #2
3000041e:	f012 fae1 	bl	300129e4 <platform_mpu_r5_common>
    mpu_add_region(region++, CE2_VCE1_BASE, 0x2000, MPU_REGION_NORMAL_NONCACHEABLE);   /*CE2_VCE1 8K*/
30000422:	2303      	movs	r3, #3
30000424:	f44f 5200 	mov.w	r2, #8192	; 0x2000
30000428:	f44f 01a4 	mov.w	r1, #5373952	; 0x520000
    region = platform_mpu_r5_common(region);
3000042c:	4604      	mov	r4, r0
    mpu_add_region(region++, SAF_SEC_MEMBASE + SAF_SEC_MEMSIZE - 0x4000, 0x4000, MPU_REGION_NORMAL_NONCACHEABLE);  /*HSM share-mem with safety*/
3000042e:	1c85      	adds	r5, r0, #2
    mpu_add_region(region++, CE2_VCE1_BASE, 0x2000, MPU_REGION_NORMAL_NONCACHEABLE);   /*CE2_VCE1 8K*/
30000430:	f001 fa40 	bl	300018b4 <mpu_add_region>
    mpu_add_region(region++, SAF_SEC_MEMBASE + SAF_SEC_MEMSIZE - 0x4000, 0x4000, MPU_REGION_NORMAL_NONCACHEABLE);  /*HSM share-mem with safety*/
30000434:	f44f 4140 	mov.w	r1, #49152	; 0xc000
30000438:	1c60      	adds	r0, r4, #1
3000043a:	2303      	movs	r3, #3
3000043c:	f2c3 51bf 	movt	r1, #13759	; 0x35bf
30000440:	f44f 4280 	mov.w	r2, #16384	; 0x4000
30000444:	f001 fa36 	bl	300018b4 <mpu_add_region>
    ASSERT(region <= 16);
30000448:	2d10      	cmp	r5, #16
3000044a:	dc18      	bgt.n	3000047e <platform_early_init+0xfa>
    if (region != 0) {
3000044c:	b115      	cbz	r5, 30000454 <platform_early_init+0xd0>
        mpu_enable(true);
3000044e:	2001      	movs	r0, #1
30000450:	f001 fab2 	bl	300019b8 <mpu_enable>
#else
#error "No timer defined for R5 platform"
#endif
    platform_mpu_init();
    os_platform_early_init();
30000454:	f7ff ff94 	bl	30000380 <os_platform_early_init>
}
30000458:	b004      	add	sp, #16
3000045a:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT(ret);
3000045c:	f24a 035c 	movw	r3, #41052	; 0xa05c
30000460:	f649 72ec 	movw	r2, #40940	; 0x9fec
30000464:	f24a 011c 	movw	r1, #40988	; 0xa01c
30000468:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000046c:	4630      	mov	r0, r6
3000046e:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000472:	9300      	str	r3, [sp, #0]
30000474:	f2c3 0101 	movt	r1, #12289	; 0x3001
30000478:	2348      	movs	r3, #72	; 0x48
3000047a:	f013 fecb 	bl	30014214 <_panic>
    ASSERT(region <= 16);
3000047e:	f24a 0360 	movw	r3, #41056	; 0xa060
30000482:	f649 72ec 	movw	r2, #40940	; 0x9fec
30000486:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000048a:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000048e:	4630      	mov	r0, r6
30000490:	f2c3 0201 	movt	r2, #12289	; 0x3001
30000494:	9300      	str	r3, [sp, #0]
30000496:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000049a:	2391      	movs	r3, #145	; 0x91
3000049c:	f013 feba 	bl	30014214 <_panic>
        platform_cpu_reset(MEMBASE);
300004a0:	f04f 5040 	mov.w	r0, #805306368	; 0x30000000
300004a4:	f7ff fecc 	bl	30000240 <platform_cpu_reset>

300004a8 <platform_init>:

void platform_init(void)
{
300004a8:	b508      	push	{r3, r14}
    uart_init();
300004aa:	f000 f893 	bl	300005d4 <uart_init>

#if ENABLE_SD_DMA
    hal_dma_init();
#endif
    sysd_start(SEM2);
300004ae:	2001      	movs	r0, #1
300004b0:	f00e fafe 	bl	3000eab0 <sysd_start>
    dcf_init();
}
300004b4:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    dcf_init();
300004b8:	f00e ba64 	b.w	3000e984 <dcf_init>

300004bc <_dputc>:
#endif

#define RSTGEN_BOOT_REASON_REG (APB_RSTGEN_SEC_BASE + RSTGEN_GENERAL_REG(4))

void _dputc(char c)
{
300004bc:	b538      	push	{r3, r4, r5, r14}
300004be:	4604      	mov	r4, r0
    int port = uart_get_current_port();
300004c0:	f000 f8f4 	bl	300006ac <uart_get_current_port>
        vuart_putc(c);
    }

#endif

    if (c == '\n') {
300004c4:	2c0a      	cmp	r4, #10
    int port = uart_get_current_port();
300004c6:	4605      	mov	r5, r0
    if (c == '\n') {
300004c8:	d005      	beq.n	300004d6 <_dputc+0x1a>
        uart_putc(port, '\r');
    }

    uart_putc(port, c);
300004ca:	4621      	mov	r1, r4
300004cc:	4628      	mov	r0, r5
}
300004ce:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
300004d2:	f000 b8c3 	b.w	3000065c <uart_putc>
        uart_putc(port, '\r');
300004d6:	210d      	movs	r1, #13
300004d8:	f000 f8c0 	bl	3000065c <uart_putc>
    uart_putc(port, c);
300004dc:	4621      	mov	r1, r4
300004de:	4628      	mov	r0, r5
}
300004e0:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
300004e4:	f000 b8ba 	b.w	3000065c <uart_putc>

300004e8 <dgetc>:

int dgetc(char *c, bool wait)
{
300004e8:	b538      	push	{r3, r4, r5, r14}
300004ea:	460c      	mov	r4, r1
300004ec:	4605      	mov	r5, r0
    int _c;
    int port = uart_get_current_port();
300004ee:	f000 f8dd 	bl	300006ac <uart_get_current_port>
        return -1;
    }

#else

    if ((_c = uart_getc(port, wait)) < 0) {
300004f2:	4621      	mov	r1, r4
300004f4:	f000 f8bc 	bl	30000670 <uart_getc>
300004f8:	2800      	cmp	r0, #0
        return -1;
300004fa:	bfb2      	itee	lt
300004fc:	f04f 30ff 	movlt.w	r0, #4294967295	; 0xffffffff
    }

#endif
    *c = _c;
30000500:	7028      	strbge	r0, [r5, #0]
    return 0;
30000502:	2000      	movge	r0, #0
}
30000504:	bd38      	pop	{r3, r4, r5, r15}
30000506:	bf00      	nop

30000508 <platform_halt>:
    return;
}

void platform_halt(platform_halt_action suggested_action,
                   platform_halt_reason reason)
{
30000508:	b500      	push	{r14}
    void *watchdog_handle = NULL;
3000050a:	2300      	movs	r3, #0
{
3000050c:	b089      	sub	sp, #36	; 0x24
    void *watchdog_handle = NULL;
3000050e:	9301      	str	r3, [sp, #4]
    bool ret;
    wdg_app_config_t wdg_app_cfg;

    switch (suggested_action) {
30000510:	b380      	cbz	r0, 30000574 <platform_halt+0x6c>
30000512:	2802      	cmp	r0, #2
30000514:	d901      	bls.n	3000051a <platform_halt+0x12>
    __asm__ volatile("cpsie i");
}

static inline void arch_disable_ints(void)
{
    __asm__ volatile("cpsid i");
30000516:	b672      	cpsid	i
    CF;
30000518:	e7fe      	b.n	30000518 <platform_halt+0x10>
3000051a:	460c      	mov	r4, r1

            break;

        case HALT_ACTION_REBOOT:
        case HALT_ACTION_SHUTDOWN:
            hal_wdg_creat_handle(&watchdog_handle, RES_WATCHDOG_WDT3);
3000051c:	f243 0120 	movw	r1, #12320	; 0x3020
30000520:	a801      	add	r0, sp, #4
30000522:	f2c4 213a 	movt	r1, #16954	; 0x423a
30000526:	f010 ffb3 	bl	30011490 <hal_wdg_creat_handle>

            if (watchdog_handle) {
3000052a:	9801      	ldr	r0, [sp, #4]
3000052c:	b320      	cbz	r0, 30000578 <platform_halt+0x70>
                wdg_app_cfg.workMode = wdg_mode1;
3000052e:	2301      	movs	r3, #1
30000530:	a908      	add	r1, sp, #32
30000532:	f841 3d18 	str.w	r3, [r1, #-24]!
                ret = hal_wdg_init(watchdog_handle, &wdg_app_cfg);
30000536:	f011 f81b 	bl	30011570 <hal_wdg_init>

                if (ret) {
3000053a:	2800      	cmp	r0, #0
3000053c:	d0eb      	beq.n	30000516 <platform_halt+0xe>
                    hal_wdg_set_timeout(watchdog_handle, 100);
3000053e:	2164      	movs	r1, #100	; 0x64
    return readl(_ioaddr(SDRV_GENERAL_REG(reg)));
}

static inline void sdrv_common_reg_set_u32(uint32_t value, uint32_t reg)
{
    writel(value, _ioaddr(SDRV_GENERAL_REG(reg)));
30000540:	2506      	movs	r5, #6
30000542:	9801      	ldr	r0, [sp, #4]
30000544:	f011 f882 	bl	3001164c <hal_wdg_set_timeout>
                    hal_wdg_enable_interrupts(watchdog_handle);
30000548:	9801      	ldr	r0, [sp, #4]
3000054a:	f011 f873 	bl	30011634 <hal_wdg_enable_interrupts>
    RMWREG32(_ioaddr(RSTGEN_BOOT_REASON_REG), 0, 4, reason);
3000054e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
30000552:	f44f 4180 	mov.w	r1, #16384	; 0x4000
30000556:	f6cf 0241 	movt	r2, #63553	; 0xf841
                    /* set boot reason */
                    config_bootreason(reason);
                    /* clean up system status notice reg */
                    sdrv_common_reg_set_u32(SDRV_REG_STATUS, 0);
                    hal_wdg_enable(watchdog_handle);
3000055a:	9801      	ldr	r0, [sp, #4]
3000055c:	f6cf 0141 	movt	r1, #63553	; 0xf841
    RMWREG32(_ioaddr(RSTGEN_BOOT_REASON_REG), 0, 4, reason);
30000560:	6813      	ldr	r3, [r2, #0]
30000562:	f023 030f 	bic.w	r3, r3, #15
30000566:	4323      	orrs	r3, r4
30000568:	6013      	str	r3, [r2, #0]
3000056a:	600d      	str	r5, [r1, #0]
                    hal_wdg_enable(watchdog_handle);
3000056c:	f011 f84a 	bl	30011604 <hal_wdg_enable>
    __asm__ volatile("cpsid i");
30000570:	b672      	cpsid	i
    CF;
30000572:	e7fe      	b.n	30000572 <platform_halt+0x6a>
    __asm__ volatile("cpsid i");
30000574:	b672      	cpsid	i
    CF;
30000576:	e7fe      	b.n	30000576 <platform_halt+0x6e>

                    for (;;);
                }
            }
            else {
                hal_wdg_deinit(watchdog_handle);
30000578:	f011 f818 	bl	300115ac <hal_wdg_deinit>
                hal_wdg_release_handle(watchdog_handle);
3000057c:	9801      	ldr	r0, [sp, #4]
3000057e:	f010 ffef 	bl	30011560 <hal_wdg_release_handle>
                printf("reboot/power off failed\n");
30000582:	f24a 0070 	movw	r0, #41072	; 0xa070
30000586:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000058a:	f015 fb11 	bl	30015bb0 <_printf>
3000058e:	e7c2      	b.n	30000516 <platform_halt+0xe>

30000590 <platform_dputc>:
    PANIC_UNIMPLEMENTED;
}

void platform_dputc(char c)
{
    _dputc(c);
30000590:	f7ff bf94 	b.w	300004bc <_dputc>

30000594 <platform_dgetc>:
}

int platform_dgetc(char *c, bool wait)
{
    return dgetc(c, wait);
30000594:	f7ff bfa8 	b.w	300004e8 <dgetc>

30000598 <save_char>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
static int save_char(uint8_t data)
{
30000598:	b538      	push	{r3, r4, r5, r14}
3000059a:	4605      	mov	r5, r0
#if CONSOLE_HAS_INPUT_BUFFER
    cbuf_write_char(&console_input_cbuf, c, false);
#else

    if (cbuf_space_avail(&uart_rx_buf) == 0) {  //uart_rx_buf no space
3000059c:	f645 4004 	movw	r0, #23556	; 0x5c04
300005a0:	f2c3 0002 	movt	r0, #12290	; 0x3002
300005a4:	f019 f99a 	bl	300198dc <cbuf_space_avail>
300005a8:	b148      	cbz	r0, 300005be <save_char+0x26>
        hal_uart_int_src_disable(uart_handle,
                                 UART_HAL_RX_CHAR_INT_SRC); //disable the receive data interrupt
        return 0;
    }

    cbuf_write_char(&uart_rx_buf, data, false);
300005aa:	f645 4004 	movw	r0, #23556	; 0x5c04
300005ae:	4629      	mov	r1, r5
300005b0:	2200      	movs	r2, #0
300005b2:	f2c3 0002 	movt	r0, #12290	; 0x3002
300005b6:	f019 f9a3 	bl	30019900 <cbuf_write_char>
    //dprintf(PLATFORM_UART_DEBUG_LEVEL, "%c", data);
#endif
    return 1;
300005ba:	2001      	movs	r0, #1
}
300005bc:	bd38      	pop	{r3, r4, r5, r15}
        hal_uart_int_src_disable(uart_handle,
300005be:	f645 4300 	movw	r3, #23552	; 0x5c00
300005c2:	4604      	mov	r4, r0
300005c4:	4601      	mov	r1, r0
300005c6:	f2c3 0302 	movt	r3, #12290	; 0x3002
300005ca:	6818      	ldr	r0, [r3, #0]
300005cc:	f010 f958 	bl	30010880 <hal_uart_int_src_disable>
300005d0:	4620      	mov	r0, r4
}
300005d2:	bd38      	pop	{r3, r4, r5, r15}

300005d4 <uart_init>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init(void)
{
300005d4:	b510      	push	{r4, r14}
    val &= ~1ul;
    writel(val, addr);
    /************ above will be change with the iomux hal ************/
#endif

    if (uart_handle != NULL) {
300005d6:	f645 4400 	movw	r4, #23552	; 0x5c00
300005da:	f2c3 0402 	movt	r4, #12290	; 0x3002
300005de:	6823      	ldr	r3, [r4, #0]
300005e0:	b183      	cbz	r3, 30000604 <uart_init+0x30>
        // create circular buffer to hold received data
        cbuf_initialize(&uart_rx_buf, RXBUF_SIZE);
300005e2:	f645 4004 	movw	r0, #23556	; 0x5c04
300005e6:	2110      	movs	r1, #16
300005e8:	f2c3 0002 	movt	r0, #12290	; 0x3002
300005ec:	f019 f95c 	bl	300198a8 <cbuf_initialize>
        hal_uart_int_cbk_register(uart_handle, UART_HAL_RX_CHAR_INT_SRC,
300005f0:	f240 5299 	movw	r2, #1433	; 0x599
300005f4:	6820      	ldr	r0, [r4, #0]
300005f6:	f2c3 0200 	movt	r2, #12288	; 0x3000
300005fa:	2100      	movs	r1, #0
                                  save_char);
        dprintf(PLATFORM_UART_DEBUG_LEVEL, "Platform UART inited!\r\n");
    }
}
300005fc:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        hal_uart_int_cbk_register(uart_handle, UART_HAL_RX_CHAR_INT_SRC,
30000600:	f010 b922 	b.w	30010848 <hal_uart_int_cbk_register>
}
30000604:	bd10      	pop	{r4, r15}
30000606:	bf00      	nop

30000608 <uart_init_early>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init_early(void)
{
30000608:	b530      	push	{r4, r5, r14}
    val = readl(addr);
    val &= ~1ul;
    writel(val, addr);
    /************ above will be change with the iomux hal ************/
#endif
    hal_uart_creat_handle(&uart_handle, DEBUG_COM);
3000060a:	f645 4400 	movw	r4, #23552	; 0x5c00
3000060e:	f24a 010d 	movw	r1, #40973	; 0xa00d
30000612:	f2c3 0402 	movt	r4, #12290	; 0x3002
30000616:	4620      	mov	r0, r4
{
30000618:	b08b      	sub	sp, #44	; 0x2c
    hal_uart_creat_handle(&uart_handle, DEBUG_COM);
3000061a:	f2c4 1142 	movt	r1, #16706	; 0x4142
3000061e:	f010 f85f 	bl	300106e0 <hal_uart_creat_handle>

    if (uart_handle != NULL) {
30000622:	6820      	ldr	r0, [r4, #0]
30000624:	b1b8      	cbz	r0, 30000656 <uart_init_early+0x4e>
        instance = (uart_instance_t *)uart_handle;
        hal_cfg.port_cfg.sclk = UART_SCLK;
30000626:	f44f 4207 	mov.w	r2, #34560	; 0x8700
        hal_cfg.port_cfg.baud = UART_BAUD;
3000062a:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
3000062e:	2300      	movs	r3, #0
        hal_cfg.port_cfg.sclk = UART_SCLK;
30000630:	f2c0 3293 	movt	r2, #915	; 0x393
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
30000634:	2503      	movs	r5, #3
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
30000636:	2402      	movs	r4, #2
        hal_cfg.port_cfg.sclk = UART_SCLK;
30000638:	9201      	str	r2, [sp, #4]
        hal_cfg.port_cfg.loopback_enable = false;
        hal_cfg.fifo_cfg.fifo_enable = true;
3000063a:	2201      	movs	r2, #1
        hal_cfg.port_cfg.baud = UART_BAUD;
3000063c:	9102      	str	r1, [sp, #8]
        hal_cfg.nine_bits_cfg.nine_bits_enable = false;
#endif
#ifdef UART_DRV_SUPPORT_DMA
        hal_cfg.dma_cfg.dma_enable = false;
#endif
        hal_uart_init(uart_handle, &hal_cfg);
3000063e:	a901      	add	r1, sp, #4
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
30000640:	e9cd 5303 	strd	r5, r3, [r13, #12]
        hal_cfg.port_cfg.loopback_enable = false;
30000644:	f88d 3018 	strb.w	r3, [r13, #24]
        hal_cfg.fifo_cfg.tx_trigger = UART_HAL_TX_FIFO_EMPTY;
30000648:	e9cd 3308 	strd	r3, r3, [r13, #32]
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
3000064c:	9405      	str	r4, [sp, #20]
        hal_cfg.fifo_cfg.fifo_enable = true;
3000064e:	f88d 201c 	strb.w	r2, [r13, #28]
        hal_uart_init(uart_handle, &hal_cfg);
30000652:	f010 f8cf 	bl	300107f4 <hal_uart_init>
        uart_platform_cfg_printf(instance, &hal_cfg);
    }
}
30000656:	b00b      	add	sp, #44	; 0x2c
30000658:	bd30      	pop	{r4, r5, r15}
3000065a:	bf00      	nop

3000065c <uart_putc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_putc(int port, char data)
{
3000065c:	b508      	push	{r3, r14}
    hal_uart_putc(uart_handle, data);
3000065e:	f645 4300 	movw	r3, #23552	; 0x5c00
30000662:	f2c3 0302 	movt	r3, #12290	; 0x3002
30000666:	6818      	ldr	r0, [r3, #0]
30000668:	f010 f8e6 	bl	30010838 <hal_uart_putc>
    return 1;
}
3000066c:	2001      	movs	r0, #1
3000066e:	bd08      	pop	{r3, r15}

30000670 <uart_getc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_getc(int port, bool wait)
{
30000670:	b510      	push	{r4, r14}
    cbuf_t *rxbuf = &uart_rx_buf;
    char c;

    if (!uart_handle)
30000672:	f645 4400 	movw	r4, #23552	; 0x5c00
{
30000676:	b082      	sub	sp, #8
    if (!uart_handle)
30000678:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000067c:	6823      	ldr	r3, [r4, #0]
3000067e:	b193      	cbz	r3, 300006a6 <uart_getc+0x36>
        return -1;

    if (cbuf_read_char(rxbuf, &c, wait) == 1) {
30000680:	f645 4004 	movw	r0, #23556	; 0x5c04
30000684:	460a      	mov	r2, r1
30000686:	f2c3 0002 	movt	r0, #12290	; 0x3002
3000068a:	f10d 0107 	add.w	r1, r13, #7
3000068e:	f019 f96f 	bl	30019970 <cbuf_read_char>
30000692:	2801      	cmp	r0, #1
30000694:	d107      	bne.n	300006a6 <uart_getc+0x36>
        hal_uart_int_src_enable(uart_handle, UART_HAL_RX_CHAR_INT_SRC);
30000696:	6820      	ldr	r0, [r4, #0]
30000698:	2100      	movs	r1, #0
3000069a:	f010 f8ed 	bl	30010878 <hal_uart_int_src_enable>
        return c;
3000069e:	f89d 0007 	ldrb.w	r0, [r13, #7]
    }

    return -1;
}
300006a2:	b002      	add	sp, #8
300006a4:	bd10      	pop	{r4, r15}
        return -1;
300006a6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
300006aa:	e7fa      	b.n	300006a2 <uart_getc+0x32>

300006ac <uart_get_current_port>:
}

int uart_get_current_port(void)
{
    return 0;
}
300006ac:	2000      	movs	r0, #0
300006ae:	4770      	bx	r14

300006b0 <register_int_handler>:
#include <arm_gic_hal.h>

#define INTERRUPT_DEBUG_LEVEL ALWAYS

void register_int_handler(unsigned int vector, int_handler handler, void *arg)
{
300006b0:	b570      	push	{r4, r5, r6, r14}
    void* gic_handle = NULL;
300006b2:	2400      	movs	r4, #0
{
300006b4:	b084      	sub	sp, #16
300006b6:	460e      	mov	r6, r1
    void* gic_handle = NULL;
300006b8:	ab04      	add	r3, sp, #16
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300006ba:	f44f 5180 	mov.w	r1, #4096	; 0x1000
{
300006be:	4605      	mov	r5, r0
    void* gic_handle = NULL;
300006c0:	f843 4d04 	str.w	r4, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300006c4:	f6c0 610a 	movt	r1, #3594	; 0xe0a
300006c8:	4618      	mov	r0, r3
{
300006ca:	4614      	mov	r4, r2
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300006cc:	f00e fb18 	bl	3000ed00 <hal_arm_gic_create_handle>
300006d0:	b158      	cbz	r0, 300006ea <register_int_handler+0x3a>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_register_interrupt(gic_handle, vector, GIC_INTERRUPT_PRI_LOWEST, handler, arg);
300006d2:	4633      	mov	r3, r6
300006d4:	4629      	mov	r1, r5
300006d6:	9803      	ldr	r0, [sp, #12]
300006d8:	221e      	movs	r2, #30
300006da:	9400      	str	r4, [sp, #0]
300006dc:	f00e fb44 	bl	3000ed68 <hal_arm_gic_register_interrupt>
        hal_arm_gic_release_handle(gic_handle);
300006e0:	9803      	ldr	r0, [sp, #12]
300006e2:	f00e fb0f 	bl	3000ed04 <hal_arm_gic_release_handle>
    }

    return;
}
300006e6:	b004      	add	sp, #16
300006e8:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
300006ea:	f44f 5180 	mov.w	r1, #4096	; 0x1000
300006ee:	f24a 008c 	movw	r0, #41100	; 0xa08c
300006f2:	f6c0 610a 	movt	r1, #3594	; 0xe0a
300006f6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300006fa:	f015 fa59 	bl	30015bb0 <_printf>
}
300006fe:	b004      	add	sp, #16
30000700:	bd70      	pop	{r4, r5, r6, r15}
30000702:	bf00      	nop

30000704 <mask_interrupt>:

status_t mask_interrupt(unsigned int vector)
{
30000704:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
30000706:	2200      	movs	r2, #0
{
30000708:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
3000070a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
3000070e:	ab02      	add	r3, sp, #8
{
30000710:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
30000712:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
30000716:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
3000071a:	4618      	mov	r0, r3
3000071c:	f00e faf0 	bl	3000ed00 <hal_arm_gic_create_handle>
30000720:	b150      	cbz	r0, 30000738 <mask_interrupt+0x34>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_disable_interrupt(gic_handle, vector);
30000722:	9801      	ldr	r0, [sp, #4]
30000724:	4621      	mov	r1, r4
30000726:	f00e fb17 	bl	3000ed58 <hal_arm_gic_disable_interrupt>
3000072a:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
3000072c:	9801      	ldr	r0, [sp, #4]
3000072e:	f00e fae9 	bl	3000ed04 <hal_arm_gic_release_handle>
    }

    return ret;
}
30000732:	4620      	mov	r0, r4
30000734:	b002      	add	sp, #8
30000736:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
30000738:	f44f 5180 	mov.w	r1, #4096	; 0x1000
3000073c:	f24a 008c 	movw	r0, #41100	; 0xa08c
30000740:	f6c0 610a 	movt	r1, #3594	; 0xe0a
        ret = -1;
30000744:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_DEBUG_LEVEL,
30000748:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000074c:	f015 fa30 	bl	30015bb0 <_printf>
30000750:	e7ef      	b.n	30000732 <mask_interrupt+0x2e>
30000752:	bf00      	nop

30000754 <unmask_interrupt>:
status_t unmask_interrupt(unsigned int vector)
{
30000754:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
30000756:	2200      	movs	r2, #0
{
30000758:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
3000075a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
3000075e:	ab02      	add	r3, sp, #8
{
30000760:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
30000762:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
30000766:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
3000076a:	4618      	mov	r0, r3
3000076c:	f00e fac8 	bl	3000ed00 <hal_arm_gic_create_handle>
30000770:	b150      	cbz	r0, 30000788 <unmask_interrupt+0x34>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_enable_interrupt(gic_handle, vector);
30000772:	9801      	ldr	r0, [sp, #4]
30000774:	4621      	mov	r1, r4
30000776:	f00e fae7 	bl	3000ed48 <hal_arm_gic_enable_interrupt>
3000077a:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
3000077c:	9801      	ldr	r0, [sp, #4]
3000077e:	f00e fac1 	bl	3000ed04 <hal_arm_gic_release_handle>
    }

    return ret;
}
30000782:	4620      	mov	r0, r4
30000784:	b002      	add	sp, #8
30000786:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
30000788:	f44f 5180 	mov.w	r1, #4096	; 0x1000
3000078c:	f24a 008c 	movw	r0, #41100	; 0xa08c
30000790:	f6c0 610a 	movt	r1, #3594	; 0xe0a
        ret = -1;
30000794:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_DEBUG_LEVEL,
30000798:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000079c:	f015 fa08 	bl	30015bb0 <_printf>
300007a0:	e7ef      	b.n	30000782 <unmask_interrupt+0x2e>
300007a2:	bf00      	nop

300007a4 <arm_gic_init_early>:

void arm_gic_init_early(void)
{
300007a4:	b500      	push	{r14}
    void* gic_handle = NULL;
300007a6:	2300      	movs	r3, #0
{
300007a8:	b083      	sub	sp, #12

    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300007aa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
300007ae:	a802      	add	r0, sp, #8
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300007b0:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
300007b4:	f840 3d04 	str.w	r3, [r0, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
300007b8:	f00e faa2 	bl	3000ed00 <hal_arm_gic_create_handle>
300007bc:	b140      	cbz	r0, 300007d0 <arm_gic_init_early+0x2c>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_init(gic_handle);
300007be:	9801      	ldr	r0, [sp, #4]
300007c0:	f00e faa2 	bl	3000ed08 <hal_arm_gic_init>
        hal_arm_gic_release_handle(gic_handle);
300007c4:	9801      	ldr	r0, [sp, #4]
300007c6:	f00e fa9d 	bl	3000ed04 <hal_arm_gic_release_handle>
    }

    return;
}
300007ca:	b003      	add	sp, #12
300007cc:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(INTERRUPT_DEBUG_LEVEL,
300007d0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
300007d4:	f24a 008c 	movw	r0, #41100	; 0xa08c
300007d8:	f6c0 610a 	movt	r1, #3594	; 0xe0a
300007dc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300007e0:	f015 f9e6 	bl	30015bb0 <_printf>
}
300007e4:	b003      	add	sp, #12
300007e6:	f85d fb04 	ldr.w	r15, [r13], #4
300007ea:	bf00      	nop

300007ec <platform_tick>:
    return (lk_bigtime_t)us;
}

lk_time_t current_time(void)
{
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
300007ec:	f645 4240 	movw	r2, #23616	; 0x5c40
}

static enum handler_return platform_tick(void)
{
    //dprintf(TIMER_DEBUG_LEVEL, "Timer tick!\n");
    return timer_context.callback(timer_context.arg, current_time());
300007f0:	f645 4334 	movw	r3, #23604	; 0x5c34
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
300007f4:	f2c3 0202 	movt	r2, #12290	; 0x3002
{
300007f8:	b570      	push	{r4, r5, r6, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
300007fa:	6814      	ldr	r4, [r2, #0]
    return timer_context.callback(timer_context.arg, current_time());
300007fc:	f2c3 0302 	movt	r3, #12290	; 0x3002
    return hal_timer_glb_cntr_get(timer_handle);
30000800:	4620      	mov	r0, r4
    return timer_context.callback(timer_context.arg, current_time());
30000802:	e9d3 6501 	ldrd	r6, r5, [r3, #4]
    return hal_timer_glb_cntr_get(timer_handle);
30000806:	f00f ff3b 	bl	30010680 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
3000080a:	68e2      	ldr	r2, [r4, #12]
3000080c:	2300      	movs	r3, #0
3000080e:	f019 fb07 	bl	30019e20 <__aeabi_uldivmod>
    return timer_context.callback(timer_context.arg, current_time());
30000812:	462b      	mov	r3, r5
30000814:	4601      	mov	r1, r0
30000816:	4630      	mov	r0, r6
}
30000818:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    return timer_context.callback(timer_context.arg, current_time());
3000081c:	4718      	bx	r3
3000081e:	bf00      	nop

30000820 <timer_init_early>:
{
30000820:	b5f0      	push	{r4, r5, r6, r7, r14}
    hal_timer_creat_handle(&timer_handle, SYS_TIMER);
30000822:	f645 4440 	movw	r4, #23616	; 0x5c40
30000826:	f243 010b 	movw	r1, #12299	; 0x300b
3000082a:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000082e:	4620      	mov	r0, r4
{
30000830:	b089      	sub	sp, #36	; 0x24
    hal_timer_creat_handle(&timer_handle, SYS_TIMER);
30000832:	f2c4 213e 	movt	r1, #16958	; 0x423e
30000836:	f00f fdf1 	bl	3001041c <hal_timer_creat_handle>
    if (timer_handle != NULL) {
3000083a:	6820      	ldr	r0, [r4, #0]
3000083c:	b320      	cbz	r0, 30000888 <timer_init_early+0x68>
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
3000083e:	f44f 5258 	mov.w	r2, #13824	; 0x3600
        glb_cfg.cascade = true;
30000842:	2501      	movs	r5, #1
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
30000844:	2302      	movs	r3, #2
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
30000846:	f2c0 126e 	movt	r2, #366	; 0x16e
        ovf_cfg.periodic = true;
3000084a:	ae08      	add	r6, sp, #32
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
3000084c:	9205      	str	r2, [sp, #20]
        hal_timer_global_init(timer_handle, &glb_cfg);
3000084e:	a904      	add	r1, sp, #16
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
30000850:	9304      	str	r3, [sp, #16]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
30000852:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        glb_cfg.clk_div = 2;
30000856:	9306      	str	r3, [sp, #24]
        glb_cfg.cascade = true;
30000858:	f88d 501c 	strb.w	r5, [r13, #28]
        hal_timer_global_init(timer_handle, &glb_cfg);
3000085c:	f00f fe6c 	bl	30010538 <hal_timer_global_init>
        ovf_cfg.periodic = true;
30000860:	f806 5d1c 	strb.w	r5, [r6, #-28]!
        ovf_cfg.cnt_val = 0;
30000864:	2300      	movs	r3, #0
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G0, &ovf_cfg);
30000866:	4619      	mov	r1, r3
30000868:	4632      	mov	r2, r6
3000086a:	6820      	ldr	r0, [r4, #0]
        ovf_cfg.cnt_val = 0;
3000086c:	9302      	str	r3, [sp, #8]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
3000086e:	9703      	str	r7, [sp, #12]
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G0, &ovf_cfg);
30000870:	f00f fe86 	bl	30010580 <hal_timer_ovf_init>
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G1, &ovf_cfg);
30000874:	4632      	mov	r2, r6
30000876:	4629      	mov	r1, r5
30000878:	6820      	ldr	r0, [r4, #0]
3000087a:	f00f fe81 	bl	30010580 <hal_timer_ovf_init>
        timer_context.inited = true;
3000087e:	f645 4334 	movw	r3, #23604	; 0x5c34
30000882:	f2c3 0302 	movt	r3, #12290	; 0x3002
30000886:	701d      	strb	r5, [r3, #0]
}
30000888:	b009      	add	sp, #36	; 0x24
3000088a:	bdf0      	pop	{r4, r5, r6, r7, r15}

3000088c <platform_set_oneshot_timer>:
{
3000088c:	b5f0      	push	{r4, r5, r6, r7, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
3000088e:	f645 4440 	movw	r4, #23616	; 0x5c40
{
30000892:	b085      	sub	sp, #20
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
30000894:	f2c3 0402 	movt	r4, #12290	; 0x3002
30000898:	6825      	ldr	r5, [r4, #0]
    if ((!timer_handle) || (!timer_context.inited)) {
3000089a:	b335      	cbz	r5, 300008ea <platform_set_oneshot_timer+0x5e>
3000089c:	f645 4334 	movw	r3, #23604	; 0x5c34
300008a0:	f2c3 0302 	movt	r3, #12290	; 0x3002
300008a4:	781e      	ldrb	r6, [r3, #0]
300008a6:	b306      	cbz	r6, 300008ea <platform_set_oneshot_timer+0x5e>
    ovf_cfg.ovf_val = interval * instance->cnt_per_ms;
300008a8:	f8d5 c00c 	ldr.w	r12, [r5, #12]
300008ac:	4616      	mov	r6, r2
300008ae:	4607      	mov	r7, r0
    ovf_cfg.periodic = isperiodic;
300008b0:	aa04      	add	r2, sp, #16
    timer_context.arg = arg;
300008b2:	6059      	str	r1, [r3, #4]
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
300008b4:	4628      	mov	r0, r5
    ovf_cfg.ovf_val = interval * instance->cnt_per_ms;
300008b6:	fb06 f60c 	mul.w	r6, r6, r12
    ovf_cfg.cnt_val = 0;
300008ba:	2500      	movs	r5, #0
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
300008bc:	2102      	movs	r1, #2
    timer_context.callback = callback;
300008be:	609f      	str	r7, [r3, #8]
    ovf_cfg.periodic = isperiodic;
300008c0:	f802 5d0c 	strb.w	r5, [r2, #-12]!
    ovf_cfg.cnt_val = 0;
300008c4:	e9cd 5602 	strd	r5, r6, [r13, #8]
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
300008c8:	f00f fe5a 	bl	30010580 <hal_timer_ovf_init>
    hal_timer_int_cbk_register(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC,
300008cc:	f240 72ed 	movw	r2, #2029	; 0x7ed
300008d0:	210a      	movs	r1, #10
300008d2:	6820      	ldr	r0, [r4, #0]
300008d4:	f2c3 0200 	movt	r2, #12288	; 0x3000
300008d8:	f00f fe80 	bl	300105dc <hal_timer_int_cbk_register>
    hal_timer_int_src_enable(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
300008dc:	6820      	ldr	r0, [r4, #0]
300008de:	210a      	movs	r1, #10
300008e0:	f00f fe60 	bl	300105a4 <hal_timer_int_src_enable>
    return NO_ERROR;
300008e4:	4628      	mov	r0, r5
}
300008e6:	b005      	add	sp, #20
300008e8:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return ERR_NOT_VALID;
300008ea:	f06f 0006 	mvn.w	r0, #6
    return platform_timer_set(timer_handle, callback, arg, interval, false);
300008ee:	e7fa      	b.n	300008e6 <platform_set_oneshot_timer+0x5a>

300008f0 <platform_stop_timer>:
{
300008f0:	b510      	push	{r4, r14}
    hal_timer_int_src_disable(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
300008f2:	f645 4440 	movw	r4, #23616	; 0x5c40
300008f6:	210a      	movs	r1, #10
300008f8:	f2c3 0402 	movt	r4, #12290	; 0x3002
300008fc:	6820      	ldr	r0, [r4, #0]
300008fe:	f00f fe5f 	bl	300105c0 <hal_timer_int_src_disable>
    hal_timer_int_sta_clear(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
30000902:	6820      	ldr	r0, [r4, #0]
30000904:	210a      	movs	r1, #10
}
30000906:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_timer_int_sta_clear(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
3000090a:	f00f beb3 	b.w	30010674 <hal_timer_int_sta_clear>
3000090e:	bf00      	nop

30000910 <current_time_hires>:
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
30000910:	f645 4340 	movw	r3, #23616	; 0x5c40
30000914:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30000918:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
3000091a:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(timer_handle);
3000091c:	4620      	mov	r0, r4
3000091e:	f00f feaf 	bl	30010680 <hal_timer_glb_cntr_get>
    lk_bigtime_t us = timer_current_stamp() / instance->cnt_per_us;
30000922:	2300      	movs	r3, #0
30000924:	6922      	ldr	r2, [r4, #16]
30000926:	f019 fa7b 	bl	30019e20 <__aeabi_uldivmod>
}
3000092a:	bd10      	pop	{r4, r15}

3000092c <current_time>:
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
3000092c:	f645 4340 	movw	r3, #23616	; 0x5c40
30000930:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30000934:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
30000936:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(timer_handle);
30000938:	4620      	mov	r0, r4
3000093a:	f00f fea1 	bl	30010680 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
3000093e:	2300      	movs	r3, #0
30000940:	68e2      	ldr	r2, [r4, #12]
30000942:	f019 fa6d 	bl	30019e20 <__aeabi_uldivmod>
}
30000946:	bd10      	pop	{r4, r15}

30000948 <arm_context_switch>:
     */
/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */
FUNCTION(arm_context_switch)
    /* save non callee trashed supervisor registers */
    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */
    push    { r4-r11, lr }
30000948:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    /* save old sp */
    str     sp, [r0]
3000094c:	e580d000 	str	r13, [r0]

    /* clear any exlusive locks that the old thread holds */
#if ARM_ARCH_LEVEL >= 7
    /* can clear it directly */
    clrex
30000950:	f57ff01f 	clrex
    ldr     r0, =strex_spot
    strex   r3, r2, [r0]
#endif

    /* load new regs */
    mov     sp, r1
30000954:	e1a0d001 	mov	r13, r1
    pop     { r4-r11, lr }
30000958:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
    bx      lr
3000095c:	e12fff1e 	bx	r14

30000960 <arm_save_mode_regs>:
#endif

.text

FUNCTION(arm_save_mode_regs)
    mrs     r1, cpsr
30000960:	e10f1000 	mrs	r1, CPSR

    stmia   r0, { r13, r14 }^ /* usr */
30000964:	e8c06000 	stmia	r0, {r13, r14}^
    add     r0, #8
30000968:	e2800008 	add	r0, r0, #8

    cps     #0x11   /* fiq */
3000096c:	f1020011 	cps	#17
    str     r13, [r0], #4
30000970:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
30000974:	e480e004 	str	r14, [r0], #4

    cps     #0x12   /* irq */
30000978:	f1020012 	cps	#18
    str     r13, [r0], #4
3000097c:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
30000980:	e480e004 	str	r14, [r0], #4

    cps     #0x13   /* svc */
30000984:	f1020013 	cps	#19
    str     r13, [r0], #4
30000988:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
3000098c:	e480e004 	str	r14, [r0], #4

    cps     #0x17   /* abt */
30000990:	f1020017 	cps	#23
    str     r13, [r0], #4
30000994:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
30000998:	e480e004 	str	r14, [r0], #4

    cps     #0x1b   /* und */
3000099c:	f102001b 	cps	#27
    str     r13, [r0], #4
300009a0:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
300009a4:	e480e004 	str	r14, [r0], #4

    cps     #0x1f   /* sys */
300009a8:	f102001f 	cps	#31
    str     r13, [r0], #4
300009ac:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
300009b0:	e480e004 	str	r14, [r0], #4

    msr     cpsr_c, r1
300009b4:	e121f001 	msr	CPSR_c, r1

    bx      lr
300009b8:	e12fff1e 	bx	r14

300009bc <arm_chain_load>:

/* void arm_chain_load(paddr_t entry, ulong arg0, ulong arg1, ulong arg2, ulong arg3) __NO_RETURN; */
/* shut down the system, branching into the secondary system */
FUNCTION(arm_chain_load)
    /* shuffle the args around */
    mov     r4, r0      /* r4 = entry point */
300009bc:	e1a04000 	mov	r4, r0
    mov     r0, r1
300009c0:	e1a00001 	mov	r0, r1
    mov     r1, r2
300009c4:	e1a01002 	mov	r1, r2
    mov     r2, r3
300009c8:	e1a02003 	mov	r2, r3
    ldr     r3, [sp]
300009cc:	e59d3000 	ldr	r3, [r13]
    isb

#endif // WITH_KERNEL_VM

    /* call the entry point */
    bx      r4
300009d0:	e12fff14 	bx	r4

300009d4 <arch_disable_cache>:

#elif ARM_ISA_ARMV7

/* void arch_disable_cache(uint flags) */
FUNCTION(arch_disable_cache)
    stmfd   sp!, {r4-r11, lr}
300009d4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    mov     r7, r0                      // save flags
300009d8:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
300009dc:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
300009e0:	f10c01c0 	cpsid	aif

.Ldcache_disable:
    tst     r7, #DCACHE
300009e4:	e3170002 	tst	r7, #2
    beq     .Licache_disable
300009e8:	0a000007 	beq	30000a0c <arch_disable_cache+0x38>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
300009ec:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already disabled?
300009f0:	e3100004 	tst	r0, #4
    beq     .Ldcache_already_disabled
300009f4:	0a000003 	beq	30000a08 <arch_disable_cache+0x34>

    bic     r0, #(1<<2)
300009f8:	e3c00004 	bic	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // disable dcache
300009fc:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    // flush and invalidate the dcache
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
    bl      flush_invalidate_cache_v7
30000a00:	eb000021 	bl	30000a8c <flush_invalidate_cache_v7>

    b       .Ldcache_disable_L2
30000a04:	ea000000 	b	30000a0c <arch_disable_cache+0x38>

.Ldcache_already_disabled:
    // make sure all of the caches are invalidated
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
30000a08:	eb000044 	bl	30000b20 <invalidate_cache_v7>
    bic     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // disable L2 dcache
#endif

.Licache_disable:
    tst     r7, #ICACHE
30000a0c:	e3170001 	tst	r7, #1
    beq     .Ldone_disable
30000a10:	0a000002 	beq	30000a20 <arch_disable_cache+0x4c>

    mrc     p15, 0, r0, c1, c0, 0       // cr1
30000a14:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, #(1<<12)
30000a18:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // disable icache
30000a1c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_disable:
    // make sure the icache is always invalidated
    mov     r0, #0
30000a20:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
30000a24:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    msr     cpsr, r8
30000a28:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r11, pc}
30000a2c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

30000a30 <arch_enable_cache>:

/* void arch_enable_cache(uint flags) */
FUNCTION(arch_enable_cache)
    stmfd   sp!, {r4-r12, lr}
30000a30:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}

    mov     r7, r0                      // save flags
30000a34:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
30000a38:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
30000a3c:	f10c01c0 	cpsid	aif

.Ldcache_enable:
    tst     r7, #DCACHE
30000a40:	e3170002 	tst	r7, #2
    beq     .Licache_enable
30000a44:	0a000006 	beq	30000a64 <arch_enable_cache+0x34>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
30000a48:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already enabled?
30000a4c:	e3100004 	tst	r0, #4
    bne     .Licache_enable
30000a50:	1a000003 	bne	30000a64 <arch_enable_cache+0x34>

    // invalidate L1 and L2
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
30000a54:	eb000031 	bl	30000b20 <invalidate_cache_v7>
    mrc     p15, 0, r0, c1, c0, 1       // aux cr1
    orr     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // enable L2 dcache
#endif

    mrc     p15, 0, r0, c1, c0, 0       // cr1
30000a58:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<2)
30000a5c:	e3800004 	orr	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // enable dcache
30000a60:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Licache_enable:
    tst     r7, #ICACHE
30000a64:	e3170001 	tst	r7, #1
    beq     .Ldone_enable
30000a68:	0a000004 	beq	30000a80 <arch_enable_cache+0x50>

    mov     r0, #0
30000a6c:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
30000a70:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    mrc     p15, 0, r0, c1, c0, 0       // cr1
30000a74:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<12)
30000a78:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // enable icache
30000a7c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_enable:
    isb
30000a80:	f57ff06f 	isb	sy
    msr     cpsr, r8
30000a84:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r12, pc}
30000a88:	e8bd9ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r15}

30000a8c <flush_invalidate_cache_v7>:

// flush & invalidate cache routine, trashes r0-r6, r9-r11
flush_invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
30000a8c:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
30000a90:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
30000a94:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
30000a98:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished
30000a9c:	0a00001a 	beq	30000b0c <flush_invalidate_cache_v7+0x80>
    MOV     R10, #0
30000aa0:	e3a0a000 	mov	r10, #0
.Loop1:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
30000aa4:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
30000aa8:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
30000aac:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
30000ab0:	e3510002 	cmp	r1, #2
    BLT     .Lskip                      // no cache or only instruction cache at this level
30000ab4:	ba000011 	blt	30000b00 <flush_invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
30000ab8:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
30000abc:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
30000ac0:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
30000ac4:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
30000ac8:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
30000acc:	e59f4160 	ldr	r4, [pc, #352]	; 30000c34 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
30000ad0:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
30000ad4:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
30000ad8:	e59f6158 	ldr	r6, [pc, #344]	; 30000c38 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
30000adc:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
30000ae0:	e1a09004 	mov	r9, r4
.Loop3:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
30000ae4:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
30000ae8:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c14, 2     // clean & invalidate by set/way
30000aec:	ee07bf5e 	mcr	15, 0, r11, cr7, cr14, {2}
    SUBS    R9, R9, #1                  // decrement the way number
30000af0:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3
30000af4:	aafffffa 	bge	30000ae4 <flush_invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
30000af8:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2
30000afc:	aafffff7 	bge	30000ae0 <flush_invalidate_cache_v7+0x54>
.Lskip:
    ADD     R10, R10, #2                    // increment the cache number
30000b00:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
30000b04:	e153000a 	cmp	r3, r10
    BGT     .Loop1
30000b08:	caffffe5 	bgt	30000aa4 <flush_invalidate_cache_v7+0x18>

.Lfinished:
    mov     r10, #0
30000b0c:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
30000b10:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    dsb
30000b14:	f57ff04f 	dsb	sy
    isb
30000b18:	f57ff06f 	isb	sy

    bx      lr
30000b1c:	e12fff1e 	bx	r14

30000b20 <invalidate_cache_v7>:

// invalidate cache routine, trashes r0-r6, r9-r11
invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
30000b20:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
30000b24:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
30000b28:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
30000b2c:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished_invalidate
30000b30:	0a00001a 	beq	30000ba0 <invalidate_cache_v7+0x80>
    MOV     R10, #0
30000b34:	e3a0a000 	mov	r10, #0
.Loop1_invalidate:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
30000b38:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
30000b3c:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
30000b40:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
30000b44:	e3510002 	cmp	r1, #2
    BLT     .Lskip_invalidate           // no cache or only instruction cache at this level
30000b48:	ba000011 	blt	30000b94 <invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
30000b4c:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
30000b50:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
30000b54:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
30000b58:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
30000b5c:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
30000b60:	e59f40cc 	ldr	r4, [pc, #204]	; 30000c34 <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
30000b64:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
30000b68:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
30000b6c:	e59f60c4 	ldr	r6, [pc, #196]	; 30000c38 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
30000b70:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2_invalidate:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
30000b74:	e1a09004 	mov	r9, r4
.Loop3_invalidate:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
30000b78:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
30000b7c:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c6, 2      // invalidate by set/way
30000b80:	ee07bf56 	mcr	15, 0, r11, cr7, cr6, {2}
    SUBS    R9, R9, #1                  // decrement the way number
30000b84:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3_invalidate
30000b88:	aafffffa 	bge	30000b78 <invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
30000b8c:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2_invalidate
30000b90:	aafffff7 	bge	30000b74 <invalidate_cache_v7+0x54>
.Lskip_invalidate:
    ADD     R10, R10, #2                // increment the cache number
30000b94:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
30000b98:	e153000a 	cmp	r3, r10
    BGT     .Loop1_invalidate
30000b9c:	caffffe5 	bgt	30000b38 <invalidate_cache_v7+0x18>

.Lfinished_invalidate:
    dsb
30000ba0:	f57ff04f 	dsb	sy
    mov     r10, #0
30000ba4:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
30000ba8:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb
30000bac:	f57ff06f 	isb	sy

    bx      lr
30000bb0:	e12fff1e 	bx	r14

30000bb4 <arch_clean_cache_range_asm>:
/* shared cache flush routines */

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
30000bb4:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
30000bb8:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
30000bbc:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c10, 1      // clean cache to PoC by MVA
30000bc0:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
    add     r0, #CACHE_LINE
30000bc4:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
30000bc8:	e1500002 	cmp	r0, r2
    blo     0b
30000bcc:	3afffffb 	bcc	30000bc0 <arch_clean_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
30000bd0:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_range
#else
    bx      lr
30000bd4:	e12fff1e 	bx	r14

30000bd8 <arch_clean_invalidate_cache_range_asm>:
#endif

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
30000bd8:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
30000bdc:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
30000be0:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c14, 1      // clean & invalidate dcache to PoC by MVA
30000be4:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
    add     r0, r0, #CACHE_LINE
30000be8:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
30000bec:	e1500002 	cmp	r0, r2
    blo     0b
30000bf0:	3afffffb 	bcc	30000be4 <arch_clean_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
30000bf4:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_invalidate_range
#else
    bx      lr
30000bf8:	e12fff1e 	bx	r14

30000bfc <arch_invalidate_cache_range_asm>:
#endif

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
30000bfc:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
30000c00:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
30000c04:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c6, 1       // invalidate dcache to PoC by MVA
30000c08:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
    add     r0, r0, #CACHE_LINE
30000c0c:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
30000c10:	e1500002 	cmp	r0, r2
    blo     0b
30000c14:	3afffffb 	bcc	30000c08 <arch_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
30000c18:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_invalidate_range
#else
    bx      lr
30000c1c:	e12fff1e 	bx	r14

30000c20 <arch_sync_cache_range_asm>:
#endif

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range_asm)
    push    { r14 }
30000c20:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
    bl      arch_clean_cache_range_asm
30000c24:	ebffffe2 	bl	30000bb4 <arch_clean_cache_range_asm>

    mov     r0, #0
30000c28:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
30000c2c:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    pop     { pc }
30000c30:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
    LDR     R4, =0x3FF
30000c34:	000003ff 	.word	0x000003ff
    LDR     R6, =0x00007FFF
30000c38:	00007fff 	.word	0x00007fff

30000c3c <_arch_enable_ints>:

.text

/* void _arch_enable_ints(void); */
FUNCTION(_arch_enable_ints)
    mrs     r0, cpsr
30000c3c:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #(1<<7)     /* clear the I bit */
30000c40:	e3c00080 	bic	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
30000c44:	e121f000 	msr	CPSR_c, r0
    bx      lr
30000c48:	e12fff1e 	bx	r14

30000c4c <_arch_disable_ints>:

/* void _arch_disable_ints(void); */
FUNCTION(_arch_disable_ints)
    mrs     r0, cpsr
30000c4c:	e10f0000 	mrs	r0, CPSR
    orr     r0, r0, #(1<<7)
30000c50:	e3800080 	orr	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
30000c54:	e121f000 	msr	CPSR_c, r0
    bx      lr
30000c58:	e12fff1e 	bx	r14

30000c5c <_atomic_swap>:

/* int _atomic_swap(int *ptr, int val); */
FUNCTION(_atomic_swap)
.L_loop_swap:
    ldrex   r12, [r0]
30000c5c:	e190cf9f 	ldrex	r12, [r0]
    strex   r2, r1, [r0]
30000c60:	e1802f91 	strex	r2, r1, [r0]
    cmp     r2, #0
30000c64:	e3520000 	cmp	r2, #0
    bne     .L_loop_swap
30000c68:	1afffffb 	bne	30000c5c <_atomic_swap>

    /* save old value */
    mov     r0, r12
30000c6c:	e1a0000c 	mov	r0, r12
    bx      lr
30000c70:	e12fff1e 	bx	r14

30000c74 <_atomic_add>:

/* int _atomic_add(int *ptr, int val); */
FUNCTION(_atomic_add)
    /* use load/store exclusive */
.L_loop_add:
    ldrex   r12, [r0]
30000c74:	e190cf9f 	ldrex	r12, [r0]
    add     r2, r12, r1
30000c78:	e08c2001 	add	r2, r12, r1
    strex   r3, r2, [r0]
30000c7c:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
30000c80:	e3530000 	cmp	r3, #0
    bne     .L_loop_add
30000c84:	1afffffa 	bne	30000c74 <_atomic_add>

    /* save old value */
    mov     r0, r12
30000c88:	e1a0000c 	mov	r0, r12
    bx      lr
30000c8c:	e12fff1e 	bx	r14

30000c90 <_atomic_and>:

/* int _atomic_and(int *ptr, int val); */
FUNCTION(_atomic_and)
    /* use load/store exclusive */
.L_loop_and:
    ldrex   r12, [r0]
30000c90:	e190cf9f 	ldrex	r12, [r0]
    and     r2, r12, r1
30000c94:	e00c2001 	and	r2, r12, r1
    strex   r3, r2, [r0]
30000c98:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
30000c9c:	e3530000 	cmp	r3, #0
    bne     .L_loop_and
30000ca0:	1afffffa 	bne	30000c90 <_atomic_and>

    /* save old value */
    mov     r0, r12
30000ca4:	e1a0000c 	mov	r0, r12
    bx      lr
30000ca8:	e12fff1e 	bx	r14

30000cac <_atomic_or>:

/* int _atomic_or(int *ptr, int val); */
FUNCTION(_atomic_or)
    /* use load/store exclusive */
.L_loop_or:
    ldrex   r12, [r0]
30000cac:	e190cf9f 	ldrex	r12, [r0]
    orr     r2, r12, r1
30000cb0:	e18c2001 	orr	r2, r12, r1
    strex   r3, r2, [r0]
30000cb4:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
30000cb8:	e3530000 	cmp	r3, #0
    bne     .L_loop_or
30000cbc:	1afffffa 	bne	30000cac <_atomic_or>

    /* save old value */
    mov     r0, r12
30000cc0:	e1a0000c 	mov	r0, r12
    bx      lr
30000cc4:	e12fff1e 	bx	r14

30000cc8 <arch_spin_trylock>:

FUNCTION(arch_spin_trylock)
    mov     r2, r0
30000cc8:	e1a02000 	mov	r2, r0
    mov     r1, #1
30000ccc:	e3a01001 	mov	r1, #1
    ldrex   r0, [r2]
30000cd0:	e1920f9f 	ldrex	r0, [r2]
    cmp     r0, #0
30000cd4:	e3500000 	cmp	r0, #0
    strexeq r0, r1, [r2]
30000cd8:	01820f91 	strexeq	r0, r1, [r2]
    dmb
30000cdc:	f57ff05f 	dmb	sy
    bx      lr
30000ce0:	e12fff1e 	bx	r14

30000ce4 <arch_spin_lock>:

FUNCTION(arch_spin_lock)
    mov     r1, #1
30000ce4:	e3a01001 	mov	r1, #1
1:
    ldrex   r2, [r0]
30000ce8:	e1902f9f 	ldrex	r2, [r0]
    cmp     r2, #0
30000cec:	e3520000 	cmp	r2, #0
    wfene
30000cf0:	1320f002 	wfene
    strexeq r2, r1, [r0]
30000cf4:	01802f91 	strexeq	r2, r1, [r0]
    cmpeq   r2, #0
30000cf8:	03520000 	cmpeq	r2, #0
    bne     1b
30000cfc:	1afffff9 	bne	30000ce8 <arch_spin_lock+0x4>
    dmb
30000d00:	f57ff05f 	dmb	sy
    bx      lr
30000d04:	e12fff1e 	bx	r14

30000d08 <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
    mov     r1, #0
30000d08:	e3a01000 	mov	r1, #0
    dmb
30000d0c:	f57ff05f 	dmb	sy
    str     r1, [r0]
30000d10:	e5801000 	str	r1, [r0]
    dsb
30000d14:	f57ff04f 	dsb	sy
    sev
30000d18:	e320f004 	sev
    bx      lr
30000d1c:	e12fff1e 	bx	r14

30000d20 <arch_idle>:

/* void arch_idle(); */
FUNCTION(arch_idle)
#if ARM_ARCH_LEVEL >= 7
    wfi
30000d20:	e320f003 	wfi
    mov     r0, #0
    mcr     p15, 0, r0, c7, c0, #4
#else
#error unknown cpu
#endif
    bx      lr
30000d24:	e12fff1e 	bx	r14

30000d28 <arm_invalidate_tlb>:

/* void arm_invalidate_tlb(void) */
FUNCTION(arm_invalidate_tlb)
    mov     r0, #0
30000d28:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c8, c7, 0
30000d2c:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    bx      lr
30000d30:	e12fff1e 	bx	r14

30000d34 <arm_undefined>:
    /* return to whence we came from */
    rfeia   sp!
.endm

FUNCTION(arm_undefined)
    save
30000d34:	f96d0513 	srsdb	r13!, #19
30000d38:	f10e0093 	cpsid	i,#19
30000d3c:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
30000d40:	e24dd008 	sub	r13, r13, #8
30000d44:	e8cd6000 	stmia	r13, {r13, r14}^
30000d48:	eef80a10 	vmrs	r0, fpexc
30000d4c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000d50:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000d54:	eee80a10 	vmsr	fpexc, r0
30000d58:	e1a0000d 	mov	r0, r13
30000d5c:	e31d0004 	tst	r13, #4
30000d60:	024dd004 	subeq	r13, r13, #4
30000d64:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_undefined_handler
30000d68:	fa00018b 	blx	3000139c <arm_undefined_handler>

    restore
30000d6c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000d70:	e1a0d000 	mov	r13, r0
30000d74:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000d78:	eee80a10 	vmsr	fpexc, r0
30000d7c:	e8dd6000 	ldm	r13, {r13, r14}^
30000d80:	e28dd008 	add	r13, r13, #8
30000d84:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
30000d88:	f8bd0a00 	rfeia	r13!

30000d8c <arm_syscall>:

#ifndef WITH_LIB_SYSCALL
FUNCTION(arm_syscall)
    saveall
30000d8c:	f96d0513 	srsdb	r13!, #19
30000d90:	f10e0093 	cpsid	i,#19
30000d94:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000d98:	e24dd008 	sub	r13, r13, #8
30000d9c:	e8cd6000 	stmia	r13, {r13, r14}^
30000da0:	eef80a10 	vmrs	r0, fpexc
30000da4:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000da8:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000dac:	eee80a10 	vmsr	fpexc, r0
30000db0:	e1a0000d 	mov	r0, r13
30000db4:	e31d0004 	tst	r13, #4
30000db8:	024dd004 	subeq	r13, r13, #4
30000dbc:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_syscall_handler
30000dc0:	fa000171 	blx	3000138c <arm_syscall_handler>

    restoreall
30000dc4:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000dc8:	e1a0d000 	mov	r13, r0
30000dcc:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000dd0:	eee80a10 	vmsr	fpexc, r0
30000dd4:	e8dd6000 	ldm	r13, {r13, r14}^
30000dd8:	e28dd008 	add	r13, r13, #8
30000ddc:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000de0:	f8bd0a00 	rfeia	r13!

30000de4 <arm_prefetch_abort>:
#endif

FUNCTION(arm_prefetch_abort)
    saveall_offset #4
30000de4:	e24ee004 	sub	r14, r14, #4
30000de8:	f96d0513 	srsdb	r13!, #19
30000dec:	f10e0093 	cpsid	i,#19
30000df0:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000df4:	e24dd008 	sub	r13, r13, #8
30000df8:	e8cd6000 	stmia	r13, {r13, r14}^
30000dfc:	eef80a10 	vmrs	r0, fpexc
30000e00:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000e04:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000e08:	eee80a10 	vmsr	fpexc, r0
30000e0c:	e1a0000d 	mov	r0, r13
30000e10:	e31d0004 	tst	r13, #4
30000e14:	024dd004 	subeq	r13, r13, #4
30000e18:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_prefetch_abort_handler
30000e1c:	fa000209 	blx	30001648 <arm_prefetch_abort_handler>

    restoreall
30000e20:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000e24:	e1a0d000 	mov	r13, r0
30000e28:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000e2c:	eee80a10 	vmsr	fpexc, r0
30000e30:	e8dd6000 	ldm	r13, {r13, r14}^
30000e34:	e28dd008 	add	r13, r13, #8
30000e38:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000e3c:	f8bd0a00 	rfeia	r13!

30000e40 <arm_data_abort>:

FUNCTION(arm_data_abort)
    saveall_offset #8
30000e40:	e24ee008 	sub	r14, r14, #8
30000e44:	f96d0513 	srsdb	r13!, #19
30000e48:	f10e0093 	cpsid	i,#19
30000e4c:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000e50:	e24dd008 	sub	r13, r13, #8
30000e54:	e8cd6000 	stmia	r13, {r13, r14}^
30000e58:	eef80a10 	vmrs	r0, fpexc
30000e5c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000e60:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000e64:	eee80a10 	vmsr	fpexc, r0
30000e68:	e1a0000d 	mov	r0, r13
30000e6c:	e31d0004 	tst	r13, #4
30000e70:	024dd004 	subeq	r13, r13, #4
30000e74:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_data_abort_handler
30000e78:	fa000183 	blx	3000148c <arm_data_abort_handler>

    restoreall
30000e7c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000e80:	e1a0d000 	mov	r13, r0
30000e84:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000e88:	eee80a10 	vmsr	fpexc, r0
30000e8c:	e8dd6000 	ldm	r13, {r13, r14}^
30000e90:	e28dd008 	add	r13, r13, #8
30000e94:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
30000e98:	f8bd0a00 	rfeia	r13!

30000e9c <arm_reserved>:

FUNCTION(arm_reserved)
    b   .
30000e9c:	eafffffe 	b	30000e9c <arm_reserved>

30000ea0 <arm_irq>:
    /* read the cycle count */
    mrc     p15, 0, sp, c9, c13, 0
    str     sp, [pc, #__irq_cycle_count - . - 8]
#endif

    save_offset    #4
30000ea0:	e24ee004 	sub	r14, r14, #4
30000ea4:	f96d0513 	srsdb	r13!, #19
30000ea8:	f10e0093 	cpsid	i,#19
30000eac:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
30000eb0:	e24dd008 	sub	r13, r13, #8
30000eb4:	e8cd6000 	stmia	r13, {r13, r14}^
30000eb8:	eef80a10 	vmrs	r0, fpexc
30000ebc:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000ec0:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000ec4:	eee80a10 	vmsr	fpexc, r0
30000ec8:	e1a0000d 	mov	r0, r13
30000ecc:	e31d0004 	tst	r13, #4
30000ed0:	024dd004 	subeq	r13, r13, #4
30000ed4:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)

    /* r0 now holds pointer to iframe */

    /* track that we're inside an irq handler */
    LOADCONST(r2, __arm_in_handler)
30000ed8:	e3022100 	movw	r2, #8448	; 0x2100
30000edc:	e3432002 	movt	r2, #12290	; 0x3002
    mov     r1, #1
30000ee0:	e3a01001 	mov	r1, #1
    str     r1, [r2]
30000ee4:	e5821000 	str	r1, [r2]

    /* call into higher level code */
    bl  platform_irq
30000ee8:	fa001b1b 	blx	30007b5c <platform_irq>

    /* clear the irq handler status */
    LOADCONST(r1, __arm_in_handler)
30000eec:	e3021100 	movw	r1, #8448	; 0x2100
30000ef0:	e3431002 	movt	r1, #12290	; 0x3002
    mov     r2, #0
30000ef4:	e3a02000 	mov	r2, #0
    str     r2, [r1]
30000ef8:	e5812000 	str	r2, [r1]

    /* reschedule if the handler returns nonzero */
    cmp     r0, #0
30000efc:	e3500000 	cmp	r0, #0
    blne    thread_preempt
30000f00:	1b006426 	blne	30019fa0 <__thread_preempt_from_arm>

    restore
30000f04:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000f08:	e1a0d000 	mov	r13, r0
30000f0c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000f10:	eee80a10 	vmsr	fpexc, r0
30000f14:	e8dd6000 	ldm	r13, {r13, r14}^
30000f18:	e28dd008 	add	r13, r13, #8
30000f1c:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
30000f20:	f8bd0a00 	rfeia	r13!

30000f24 <arm_fiq>:

FUNCTION(arm_fiq)
    save_offset #4
30000f24:	e24ee004 	sub	r14, r14, #4
30000f28:	f96d0513 	srsdb	r13!, #19
30000f2c:	f10e0093 	cpsid	i,#19
30000f30:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
30000f34:	e24dd008 	sub	r13, r13, #8
30000f38:	e8cd6000 	stmia	r13, {r13, r14}^
30000f3c:	eef80a10 	vmrs	r0, fpexc
30000f40:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
30000f44:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
30000f48:	eee80a10 	vmsr	fpexc, r0
30000f4c:	e1a0000d 	mov	r0, r13
30000f50:	e31d0004 	tst	r13, #4
30000f54:	024dd004 	subeq	r13, r13, #4
30000f58:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl  platform_fiq
30000f5c:	fa001b1a 	blx	30007bcc <platform_fiq>

    restore
30000f60:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000f64:	e1a0d000 	mov	r13, r0
30000f68:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
30000f6c:	eee80a10 	vmsr	fpexc, r0
30000f70:	e8dd6000 	ldm	r13, {r13, r14}^
30000f74:	e28dd008 	add	r13, r13, #8
30000f78:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
30000f7c:	f8bd0a00 	rfeia	r13!

30000f80 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cmp	r2, #0
30000f80:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_done
30000f84:	0a000003 	beq	30000f98 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	r3, [r1], #1
30000f88:	e4d13001 	ldrb	r3, [r1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	strbt	r3, [r0], #1
30000f8c:	e4e03001 	strbt	r3, [r0], #1

	subs	r2, r2, #1
30000f90:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_to_user_loop
30000f94:	8afffffb 	bhi	30000f88 <arch_copy_to_user+0x8>
.Larch_copy_to_user_done:
	mov	r0, #0
30000f98:	e3a00000 	mov	r0, #0
	bx	lr
30000f9c:	e12fff1e 	bx	r14

30000fa0 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cmp	r2, #0
30000fa0:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_from_user_done
30000fa4:	0a000003 	beq	30000fb8 <arch_copy_from_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldrbt	r3, [r1], #1
30000fa8:	e4f13001 	ldrbt	r3, [r1], #1

	strb	r3, [r0], #1
30000fac:	e4c03001 	strb	r3, [r0], #1
	subs	r2, r2, #1
30000fb0:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_loop
30000fb4:	8afffffb 	bhi	30000fa8 <arch_copy_from_user+0x8>
.Larch_copy_from_user_done:
	mov	r0, #0
30000fb8:	e3a00000 	mov	r0, #0
	bx	lr
30000fbc:	e12fff1e 	bx	r14

30000fc0 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	ip, r1
30000fc0:	e1a0c001 	mov	r12, r1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldrbt	r3, [r1]
30000fc4:	e4f13000 	ldrbt	r3, [r1], #0

	cmp	r3, #0
30000fc8:	e3530000 	cmp	r3, #0
	addne	r1, r1, #1
30000fcc:	12811001 	addne	r1, r1, #1

	cmp	r2, #0
30000fd0:	e3520000 	cmp	r2, #0
	beq	.Larch_strlcpy_from_user_dst_full
30000fd4:	0a000002 	beq	30000fe4 <arch_strlcpy_from_user+0x24>
	subs	r2, r2, #1
30000fd8:	e2522001 	subs	r2, r2, #1
	streqb	r2, [r0], #1
30000fdc:	04c02001 	strbeq	r2, [r0], #1
	strneb	r3, [r0], #1
30000fe0:	14c03001 	strbne	r3, [r0], #1
.Larch_strlcpy_from_user_dst_full:
	cmp	r3, #0
30000fe4:	e3530000 	cmp	r3, #0
	bne	.Larch_strlcpy_from_user_loop
30000fe8:	1afffff5 	bne	30000fc4 <arch_strlcpy_from_user+0x4>

	sub	r0, r1, ip
30000fec:	e041000c 	sub	r0, r1, r12
	bx	lr
30000ff0:	e12fff1e 	bx	r14

.Larch_strlcpy_from_user_fault:
	cmp	r2, #0
30000ff4:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_fault
30000ff8:	0a000003 	beq	3000100c <arch_strlcpy_from_user+0x4c>
.Larch_copy_from_user_fault:
	mov	r1, #0
30000ffc:	e3a01000 	mov	r1, #0
	strb	r1, [r0], #1
30001000:	e4c01001 	strb	r1, [r0], #1
	subs	r2, r2, #1
30001004:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_fault
30001008:	8afffffb 	bhi	30000ffc <arch_strlcpy_from_user+0x3c>
.Larch_copy_to_user_fault:
	mov	r0, #ERR_FAULT
3000100c:	e3e00027 	mvn	r0, #39	; 0x27
	bx	lr
30001010:	e12fff1e 	bx	r14

30001014 <dump_mode_regs>:

extern struct fault_handler_table_entry __fault_handler_table_start[];
extern struct fault_handler_table_entry __fault_handler_table_end[];

static void dump_mode_regs(uint32_t spsr, uint32_t svc_r13, uint32_t svc_r14)
{
30001014:	b570      	push	{r4, r5, r6, r14}
30001016:	4604      	mov	r4, r0
30001018:	b090      	sub	sp, #64	; 0x40
    struct arm_mode_regs regs;
    arm_save_mode_regs(&regs);
3000101a:	a802      	add	r0, sp, #8
{
3000101c:	4615      	mov	r5, r2

    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
3000101e:	f004 041f 	and.w	r4, r4, #31
{
30001022:	460e      	mov	r6, r1
    arm_save_mode_regs(&regs);
30001024:	f7ff ec9c 	blx	30000960 <arm_save_mode_regs>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
30001028:	9b03      	ldr	r3, [sp, #12]
3000102a:	2c10      	cmp	r4, #16
3000102c:	f24a 3230 	movw	r2, #41776	; 0xa330
30001030:	f24a 3034 	movw	r0, #41780	; 0xa334
30001034:	9300      	str	r3, [sp, #0]
30001036:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000103a:	9b02      	ldr	r3, [sp, #8]
3000103c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001040:	f000 80d8 	beq.w	300011f4 <dump_mode_regs+0x1e0>
30001044:	2120      	movs	r1, #32
30001046:	f014 fdb3 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
3000104a:	9b05      	ldr	r3, [sp, #20]
3000104c:	f24a 3250 	movw	r2, #41808	; 0xa350
30001050:	2c11      	cmp	r4, #17
30001052:	f24a 3034 	movw	r0, #41780	; 0xa334
30001056:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000105a:	9300      	str	r3, [sp, #0]
3000105c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001060:	9b04      	ldr	r3, [sp, #16]
30001062:	d158      	bne.n	30001116 <dump_mode_regs+0x102>
30001064:	212a      	movs	r1, #42	; 0x2a
30001066:	f014 fda3 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
3000106a:	9b07      	ldr	r3, [sp, #28]
3000106c:	f24a 3254 	movw	r2, #41812	; 0xa354
30001070:	f24a 3034 	movw	r0, #41780	; 0xa334
30001074:	9300      	str	r3, [sp, #0]
30001076:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000107a:	9b06      	ldr	r3, [sp, #24]
3000107c:	2120      	movs	r1, #32
3000107e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001082:	f014 fd95 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
30001086:	9b09      	ldr	r3, [sp, #36]	; 0x24
30001088:	f24a 3258 	movw	r2, #41816	; 0xa358
3000108c:	f24a 3034 	movw	r0, #41780	; 0xa334
30001090:	9300      	str	r3, [sp, #0]
30001092:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001096:	9b08      	ldr	r3, [sp, #32]
30001098:	2161      	movs	r1, #97	; 0x61
3000109a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000109e:	f014 fd87 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
300010a2:	f24a 3258 	movw	r2, #41816	; 0xa358
300010a6:	f24a 3034 	movw	r0, #41780	; 0xa334
300010aa:	f2c3 0201 	movt	r2, #12289	; 0x3001
300010ae:	9500      	str	r5, [sp, #0]
300010b0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300010b4:	4633      	mov	r3, r6
300010b6:	2120      	movs	r1, #32
300010b8:	f014 fd7a 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
300010bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
300010be:	f64b 42fc 	movw	r2, #48380	; 0xbcfc
300010c2:	f24a 3034 	movw	r0, #41780	; 0xa334
300010c6:	f2c3 0201 	movt	r2, #12289	; 0x3001
300010ca:	9300      	str	r3, [sp, #0]
300010cc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300010d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
300010d2:	2120      	movs	r1, #32
300010d4:	f014 fd6c 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
300010d8:	2c1f      	cmp	r4, #31
300010da:	d159      	bne.n	30001190 <dump_mode_regs+0x17c>
300010dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
300010de:	f24a 325c 	movw	r2, #41820	; 0xa35c
300010e2:	f24a 3034 	movw	r0, #41780	; 0xa334
300010e6:	f2c3 0201 	movt	r2, #12289	; 0x3001
300010ea:	9300      	str	r3, [sp, #0]
300010ec:	f2c3 0001 	movt	r0, #12289	; 0x3001
300010f0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
300010f2:	212a      	movs	r1, #42	; 0x2a
300010f4:	f014 fd5c 	bl	30015bb0 <_printf>
            break;
        case CPSR_MODE_UND:
            stack = regs.und_r13;
            break;
        case CPSR_MODE_SYS:
            stack = regs.sys_r13;
300010f8:	9e0e      	ldr	r6, [sp, #56]	; 0x38
            break;
        default:
            stack = 0;
    }

    if (stack != 0) {
300010fa:	b156      	cbz	r6, 30001112 <dump_mode_regs+0xfe>
        dprintf(CRITICAL, "bottom of stack at 0x%08x:\n", (unsigned int)stack);
300010fc:	f24a 3060 	movw	r0, #41824	; 0xa360
30001100:	4631      	mov	r1, r6
30001102:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001106:	f014 fd53 	bl	30015bb0 <_printf>
        hexdump((void *)stack, 128);
3000110a:	4630      	mov	r0, r6
3000110c:	2180      	movs	r1, #128	; 0x80
3000110e:	f013 f897 	bl	30014240 <hexdump>
    }
}
30001112:	b010      	add	sp, #64	; 0x40
30001114:	bd70      	pop	{r4, r5, r6, r15}
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
30001116:	2120      	movs	r1, #32
30001118:	f014 fd4a 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
3000111c:	9b07      	ldr	r3, [sp, #28]
3000111e:	f24a 3254 	movw	r2, #41812	; 0xa354
30001122:	2c12      	cmp	r4, #18
30001124:	f24a 3034 	movw	r0, #41780	; 0xa334
30001128:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000112c:	9300      	str	r3, [sp, #0]
3000112e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001132:	9b06      	ldr	r3, [sp, #24]
30001134:	f040 8096 	bne.w	30001264 <dump_mode_regs+0x250>
30001138:	212a      	movs	r1, #42	; 0x2a
3000113a:	f014 fd39 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
3000113e:	9b09      	ldr	r3, [sp, #36]	; 0x24
30001140:	f24a 3258 	movw	r2, #41816	; 0xa358
30001144:	f24a 3034 	movw	r0, #41780	; 0xa334
30001148:	9300      	str	r3, [sp, #0]
3000114a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000114e:	9b08      	ldr	r3, [sp, #32]
30001150:	2161      	movs	r1, #97	; 0x61
30001152:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001156:	f014 fd2b 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
3000115a:	f24a 3258 	movw	r2, #41816	; 0xa358
3000115e:	f24a 3034 	movw	r0, #41780	; 0xa334
30001162:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001166:	4633      	mov	r3, r6
30001168:	2120      	movs	r1, #32
3000116a:	9500      	str	r5, [sp, #0]
3000116c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001170:	f014 fd1e 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
30001174:	9b0d      	ldr	r3, [sp, #52]	; 0x34
30001176:	f64b 42fc 	movw	r2, #48380	; 0xbcfc
3000117a:	f24a 3034 	movw	r0, #41780	; 0xa334
3000117e:	9300      	str	r3, [sp, #0]
30001180:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001184:	9b0c      	ldr	r3, [sp, #48]	; 0x30
30001186:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000118a:	2120      	movs	r1, #32
3000118c:	f014 fd10 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
30001190:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
30001192:	f24a 325c 	movw	r2, #41820	; 0xa35c
30001196:	f24a 3034 	movw	r0, #41780	; 0xa334
    switch (spsr & CPSR_MODE_MASK) {
3000119a:	3c11      	subs	r4, #17
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
3000119c:	9300      	str	r3, [sp, #0]
3000119e:	f2c3 0201 	movt	r2, #12289	; 0x3001
300011a2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
300011a4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300011a8:	2120      	movs	r1, #32
300011aa:	f014 fd01 	bl	30015bb0 <_printf>
    switch (spsr & CPSR_MODE_MASK) {
300011ae:	2c0e      	cmp	r4, #14
300011b0:	d8af      	bhi.n	30001112 <dump_mode_regs+0xfe>
300011b2:	a301      	add	r3, pc, #4	; (adr r3, 300011b8 <dump_mode_regs+0x1a4>)
300011b4:	f853 f024 	ldr.w	r15, [r3, r4, lsl #2]
300011b8:	30001261 	.word	0x30001261
300011bc:	3000125d 	.word	0x3000125d
300011c0:	300010fb 	.word	0x300010fb
300011c4:	30001113 	.word	0x30001113
300011c8:	30001113 	.word	0x30001113
300011cc:	30001113 	.word	0x30001113
300011d0:	30001113 	.word	0x30001113
300011d4:	30001113 	.word	0x30001113
300011d8:	30001113 	.word	0x30001113
300011dc:	30001113 	.word	0x30001113
300011e0:	30001259 	.word	0x30001259
300011e4:	30001113 	.word	0x30001113
300011e8:	30001113 	.word	0x30001113
300011ec:	30001113 	.word	0x30001113
300011f0:	300010f9 	.word	0x300010f9
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
300011f4:	212a      	movs	r1, #42	; 0x2a
300011f6:	f014 fcdb 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
300011fa:	9b05      	ldr	r3, [sp, #20]
300011fc:	f24a 3250 	movw	r2, #41808	; 0xa350
30001200:	f24a 3034 	movw	r0, #41780	; 0xa334
30001204:	9300      	str	r3, [sp, #0]
30001206:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000120a:	9b04      	ldr	r3, [sp, #16]
3000120c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001210:	2120      	movs	r1, #32
30001212:	e728      	b.n	30001066 <dump_mode_regs+0x52>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
30001214:	2120      	movs	r1, #32
30001216:	f014 fccb 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
3000121a:	2c1b      	cmp	r4, #27
3000121c:	f47f af4e 	bne.w	300010bc <dump_mode_regs+0xa8>
30001220:	9b0d      	ldr	r3, [sp, #52]	; 0x34
30001222:	f64b 42fc 	movw	r2, #48380	; 0xbcfc
30001226:	f24a 3034 	movw	r0, #41780	; 0xa334
3000122a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000122e:	9300      	str	r3, [sp, #0]
30001230:	212a      	movs	r1, #42	; 0x2a
30001232:	9b0c      	ldr	r3, [sp, #48]	; 0x30
30001234:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001238:	f014 fcba 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
3000123c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
3000123e:	f24a 325c 	movw	r2, #41820	; 0xa35c
30001242:	f24a 3034 	movw	r0, #41780	; 0xa334
30001246:	9300      	str	r3, [sp, #0]
30001248:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000124c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
3000124e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001252:	2120      	movs	r1, #32
30001254:	f014 fcac 	bl	30015bb0 <_printf>
            stack = regs.und_r13;
30001258:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            break;
3000125a:	e74e      	b.n	300010fa <dump_mode_regs+0xe6>
            stack = regs.irq_r13;
3000125c:	9e06      	ldr	r6, [sp, #24]
            break;
3000125e:	e74c      	b.n	300010fa <dump_mode_regs+0xe6>
            stack = regs.fiq_r13;
30001260:	9e04      	ldr	r6, [sp, #16]
            break;
30001262:	e74a      	b.n	300010fa <dump_mode_regs+0xe6>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
30001264:	2120      	movs	r1, #32
30001266:	f014 fca3 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
3000126a:	9b09      	ldr	r3, [sp, #36]	; 0x24
3000126c:	f24a 3258 	movw	r2, #41816	; 0xa358
30001270:	f24a 3034 	movw	r0, #41780	; 0xa334
30001274:	9300      	str	r3, [sp, #0]
30001276:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000127a:	9b08      	ldr	r3, [sp, #32]
3000127c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001280:	2161      	movs	r1, #97	; 0x61
30001282:	f014 fc95 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
30001286:	f24a 3258 	movw	r2, #41816	; 0xa358
3000128a:	f24a 3034 	movw	r0, #41780	; 0xa334
3000128e:	2c13      	cmp	r4, #19
30001290:	9500      	str	r5, [sp, #0]
30001292:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001296:	4633      	mov	r3, r6
30001298:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000129c:	d1ba      	bne.n	30001214 <dump_mode_regs+0x200>
3000129e:	212a      	movs	r1, #42	; 0x2a
300012a0:	f014 fc86 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
300012a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
300012a6:	f64b 42fc 	movw	r2, #48380	; 0xbcfc
300012aa:	f24a 3034 	movw	r0, #41780	; 0xa334
300012ae:	9300      	str	r3, [sp, #0]
300012b0:	f2c3 0201 	movt	r2, #12289	; 0x3001
300012b4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
300012b6:	2120      	movs	r1, #32
300012b8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300012bc:	f014 fc78 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
300012c0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
300012c2:	f24a 325c 	movw	r2, #41820	; 0xa35c
300012c6:	f24a 3034 	movw	r0, #41780	; 0xa334
300012ca:	9300      	str	r3, [sp, #0]
300012cc:	f2c3 0201 	movt	r2, #12289	; 0x3001
300012d0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
300012d2:	2120      	movs	r1, #32
300012d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300012d8:	f014 fc6a 	bl	30015bb0 <_printf>
300012dc:	e70d      	b.n	300010fa <dump_mode_regs+0xe6>
300012de:	bf00      	nop

300012e0 <exception_die>:

    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
}

static void exception_die(struct arm_fault_frame *frame, const char *msg)
{
300012e0:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
300012e2:	f240 50e4 	movw	r0, #1508	; 0x5e4
{
300012e6:	b500      	push	{r14}
    dprintf(CRITICAL, "%s", msg);
300012e8:	f2c3 0002 	movt	r0, #12290	; 0x3002
{
300012ec:	b083      	sub	sp, #12
    dprintf(CRITICAL, "%s", msg);
300012ee:	f014 fc5f 	bl	30015bb0 <_printf>

GEN_CP15_REG_FUNCS(fcseidr, 0, c13, c0, 0);
GEN_CP15_REG_FUNCS(contextidr, 0, c13, c0, 1);
GEN_CP15_REG_FUNCS(tpidrurw, 0, c13, c0, 2);
GEN_CP15_REG_FUNCS(tpidruro, 0, c13, c0, 3);
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
300012f2:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    dprintf(CRITICAL, "current_thread %p, name %s\n",
300012f6:	f501 72b2 	add.w	r2, r1, #356	; 0x164
300012fa:	b919      	cbnz	r1, 30001304 <exception_die+0x24>
300012fc:	f64a 72bc 	movw	r2, #44988	; 0xafbc
30001300:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001304:	f24a 307c 	movw	r0, #41852	; 0xa37c
30001308:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000130c:	f014 fc50 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
30001310:	69a5      	ldr	r5, [r4, #24]
30001312:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
30001316:	f24a 3098 	movw	r0, #41880	; 0xa398
3000131a:	68e1      	ldr	r1, [r4, #12]
3000131c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001320:	9500      	str	r5, [sp, #0]
30001322:	f014 fc45 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r4  0x%08x r5  0x%08x r6  0x%08x r7  0x%08x\n", frame->r[4], frame->r[5], frame->r[6], frame->r[7]);
30001326:	6aa5      	ldr	r5, [r4, #40]	; 0x28
30001328:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
3000132c:	f24a 30c8 	movw	r0, #41928	; 0xa3c8
30001330:	69e1      	ldr	r1, [r4, #28]
30001332:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001336:	9500      	str	r5, [sp, #0]
30001338:	f014 fc3a 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r8  0x%08x r9  0x%08x r10 0x%08x r11 0x%08x\n", frame->r[8], frame->r[9], frame->r[10], frame->r[11]);
3000133c:	6ba5      	ldr	r5, [r4, #56]	; 0x38
3000133e:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
30001342:	f24a 30f8 	movw	r0, #41976	; 0xa3f8
30001346:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
30001348:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000134c:	9500      	str	r5, [sp, #0]
3000134e:	f014 fc2f 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r[12], frame->usp, frame->ulr, frame->pc);
30001352:	6c65      	ldr	r5, [r4, #68]	; 0x44
30001354:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
30001358:	f24a 4028 	movw	r0, #42024	; 0xa428
3000135c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
3000135e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001362:	9500      	str	r5, [sp, #0]
30001364:	f014 fc24 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
30001368:	6ca1      	ldr	r1, [r4, #72]	; 0x48
3000136a:	f24a 4058 	movw	r0, #42072	; 0xa458
3000136e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001372:	f014 fc1d 	bl	30015bb0 <_printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
30001376:	6ca0      	ldr	r0, [r4, #72]	; 0x48
30001378:	6c22      	ldr	r2, [r4, #64]	; 0x40
3000137a:	f104 014c 	add.w	r1, r4, #76	; 0x4c
3000137e:	f7ff fe49 	bl	30001014 <dump_mode_regs>
    dump_fault_frame(frame);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
30001382:	2109      	movs	r1, #9
30001384:	2000      	movs	r0, #0
30001386:	f7ff f8bf 	bl	30000508 <platform_halt>
3000138a:	bf00      	nop

3000138c <arm_syscall_handler>:
    for (;;);
}

__WEAK void arm_syscall_handler(struct arm_fault_frame *frame)
{
    exception_die(frame, "unhandled syscall, halting\n");
3000138c:	f24a 21f8 	movw	r1, #41720	; 0xa2f8
{
30001390:	b508      	push	{r3, r14}
    exception_die(frame, "unhandled syscall, halting\n");
30001392:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001396:	f7ff ffa3 	bl	300012e0 <exception_die>
3000139a:	bf00      	nop

3000139c <arm_undefined_handler>:
}

void arm_undefined_handler(struct arm_iframe *frame)
{
3000139c:	e9d0 3209 	ldrd	r3, r2, [r0, #36]	; 0x24
300013a0:	b510      	push	{r4, r14}
    /* look at the undefined instruction, figure out if it's something we can handle */
    bool in_thumb = frame->spsr & (1<<5);
    if (in_thumb) {
300013a2:	0692      	lsls	r2, r2, #26
{
300013a4:	b082      	sub	sp, #8
    if (in_thumb) {
300013a6:	d524      	bpl.n	300013f2 <arm_undefined_handler+0x56>
        if (opcode & 0x0000e800) {
            /* swap the 16bit words */
            opcode = (opcode >> 16) | (opcode << 16);
        }

        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013a8:	f44f 6120 	mov.w	r1, #2560	; 0xa00
        frame->pc -= 2;
300013ac:	1e9a      	subs	r2, r3, #2
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013ae:	f6ce 4100 	movt	r1, #60416	; 0xec00
        frame->pc -= 2;
300013b2:	6242      	str	r2, [r0, #36]	; 0x24
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013b4:	f44f 6260 	mov.w	r2, #3584	; 0xe00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
300013b8:	f853 3c02 	ldr.w	r3, [r3, #-2]
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013bc:	f6ce 4200 	movt	r2, #60416	; 0xec00
        if (opcode & 0x0000e800) {
300013c0:	f413 4f68 	tst.w	r3, #59392	; 0xe800
            opcode = (opcode >> 16) | (opcode << 16);
300013c4:	bf18      	it	ne
300013c6:	ea4f 4333 	movne.w	r3, r3, ror #16
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013ca:	401a      	ands	r2, r3
300013cc:	428a      	cmp	r2, r1
300013ce:	d00b      	beq.n	300013e8 <arm_undefined_handler+0x4c>
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
300013d0:	f003 426f 	and.w	r2, r3, #4009754624	; 0xef000000
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
300013d4:	f1b2 4f6f 	cmp.w	r2, #4009754624	; 0xef000000
300013d8:	d006      	beq.n	300013e8 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf9000000)) { // VLD
300013da:	2200      	movs	r2, #0
300013dc:	f6cf 7210 	movt	r2, #65296	; 0xff10
300013e0:	401a      	ands	r2, r3
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
300013e2:	f1b2 4f79 	cmp.w	r2, #4177526784	; 0xf9000000
300013e6:	d11f      	bne.n	30001428 <arm_undefined_handler+0x8c>

#if ARM_WITH_VFP
fpu:
    arm_fpu_undefined_instruction(frame);
#endif
}
300013e8:	b002      	add	sp, #8
300013ea:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    arm_fpu_undefined_instruction(frame);
300013ee:	f000 b9ab 	b.w	30001748 <arm_fpu_undefined_instruction>
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
300013f2:	f44f 6260 	mov.w	r2, #3584	; 0xe00
        frame->pc -= 4;
300013f6:	1f1c      	subs	r4, r3, #4
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
300013f8:	f44f 6120 	mov.w	r1, #2560	; 0xa00
300013fc:	f6c0 4200 	movt	r2, #3072	; 0xc00
        frame->pc -= 4;
30001400:	6244      	str	r4, [r0, #36]	; 0x24
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
30001402:	f6c0 4100 	movt	r1, #3072	; 0xc00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
30001406:	f853 3c04 	ldr.w	r3, [r3, #-4]
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
3000140a:	401a      	ands	r2, r3
3000140c:	428a      	cmp	r2, r1
3000140e:	d0eb      	beq.n	300013e8 <arm_undefined_handler+0x4c>
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
30001410:	f003 427e 	and.w	r2, r3, #4261412864	; 0xfe000000
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
30001414:	f1b2 4f72 	cmp.w	r2, #4060086272	; 0xf2000000
30001418:	d0e6      	beq.n	300013e8 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf4000000)) { // VLD
3000141a:	2200      	movs	r2, #0
3000141c:	f6cf 7210 	movt	r2, #65296	; 0xff10
30001420:	401a      	ands	r2, r3
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
30001422:	f1b2 4f74 	cmp.w	r2, #4093640704	; 0xf4000000
30001426:	d0df      	beq.n	300013e8 <arm_undefined_handler+0x4c>
30001428:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
3000142a:	f24a 3114 	movw	r1, #41748	; 0xa314
3000142e:	f240 50e4 	movw	r0, #1508	; 0x5e4
30001432:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001436:	f2c3 0002 	movt	r0, #12290	; 0x3002
3000143a:	f014 fbb9 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r0, frame->r1, frame->r2, frame->r3);
3000143e:	69a3      	ldr	r3, [r4, #24]
30001440:	9300      	str	r3, [sp, #0]
30001442:	f24a 3098 	movw	r0, #41880	; 0xa398
30001446:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
3000144a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000144e:	68e1      	ldr	r1, [r4, #12]
30001450:	f014 fbae 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r12, frame->usp, frame->ulr, frame->pc);
30001454:	6a63      	ldr	r3, [r4, #36]	; 0x24
30001456:	9300      	str	r3, [sp, #0]
30001458:	f24a 4028 	movw	r0, #42024	; 0xa428
3000145c:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
30001460:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001464:	69e1      	ldr	r1, [r4, #28]
30001466:	f014 fba3 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
3000146a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
3000146c:	f24a 4058 	movw	r0, #42072	; 0xa458
30001470:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001474:	f014 fb9c 	bl	30015bb0 <_printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
30001478:	6aa0      	ldr	r0, [r4, #40]	; 0x28
3000147a:	6a22      	ldr	r2, [r4, #32]
3000147c:	f104 012c 	add.w	r1, r4, #44	; 0x2c
30001480:	f7ff fdc8 	bl	30001014 <dump_mode_regs>
    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
30001484:	2109      	movs	r1, #9
30001486:	2000      	movs	r0, #0
30001488:	f7ff f83e 	bl	30000508 <platform_halt>

3000148c <arm_data_abort_handler>:

void arm_data_abort_handler(struct arm_fault_frame *frame)
{
3000148c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
GEN_CP15_REG_FUNCS(dfsr, 0, c5, c0, 0);
3000148e:	ee15 5f10 	mrc	15, 0, r5, cr5, cr0, {0}
GEN_CP15_REG_FUNCS(dfar, 0, c6, c0, 0);
30001492:	ee16 6f10 	mrc	15, 0, r6, cr6, cr0, {0}
    uint32_t fsr = arm_read_dfsr();
    uint32_t far = arm_read_dfar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
30001496:	f649 73b0 	movw	r3, #40880	; 0x9fb0
3000149a:	f649 72c8 	movw	r2, #40904	; 0x9fc8
3000149e:	f2c3 0301 	movt	r3, #12289	; 0x3001
300014a2:	f2c3 0201 	movt	r2, #12289	; 0x3001
300014a6:	4293      	cmp	r3, r2
300014a8:	d216      	bcs.n	300014d8 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
300014aa:	6c47      	ldr	r7, [r0, #68]	; 0x44
300014ac:	6819      	ldr	r1, [r3, #0]
300014ae:	42b9      	cmp	r1, r7
300014b0:	bf1f      	itttt	ne
300014b2:	43dc      	mvnne	r4, r3
300014b4:	18a4      	addne	r4, r4, r2
300014b6:	f024 0407 	bicne.w	r4, r4, #7
300014ba:	18e4      	addne	r4, r4, r3
300014bc:	d00a      	beq.n	300014d4 <arm_data_abort_handler+0x48>
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
300014be:	42a3      	cmp	r3, r4
300014c0:	f103 0208 	add.w	r2, r3, #8
300014c4:	d008      	beq.n	300014d8 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
300014c6:	6811      	ldr	r1, [r2, #0]
300014c8:	4613      	mov	r3, r2
300014ca:	42b9      	cmp	r1, r7
300014cc:	d1f7      	bne.n	300014be <arm_data_abort_handler+0x32>
            frame->pc = fault_handler->fault_handler;
300014ce:	6853      	ldr	r3, [r2, #4]
300014d0:	6443      	str	r3, [r0, #68]	; 0x44

    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);

    exception_die(frame, "halting\n");
}
300014d2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
300014d4:	461a      	mov	r2, r3
300014d6:	e7fa      	b.n	300014ce <arm_data_abort_handler+0x42>
300014d8:	4604      	mov	r4, r0
    dprintf(CRITICAL, "\n\ncpu %u data abort, ", arch_curr_cpu_num());
300014da:	f24a 00bc 	movw	r0, #41148	; 0xa0bc
300014de:	2100      	movs	r1, #0
300014e0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300014e4:	f014 fb64 	bl	30015bb0 <_printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
300014e8:	09ab      	lsrs	r3, r5, #6
300014ea:	f005 020f 	and.w	r2, r5, #15
300014ee:	f003 0310 	and.w	r3, r3, #16
300014f2:	4313      	orrs	r3, r2
    switch (fault_status) {
300014f4:	3b01      	subs	r3, #1
    bool write = !!BIT(fsr, 11);
300014f6:	f405 6200 	and.w	r2, r5, #2048	; 0x800
    switch (fault_status) {
300014fa:	2b15      	cmp	r3, #21
300014fc:	d80c      	bhi.n	30001518 <arm_data_abort_handler+0x8c>
300014fe:	e8df f003 	tbb	[r15, r3]
30001502:	8990      	.short	0x8990
30001504:	77650b77 	.word	0x77650b77
30001508:	0b4a5365 	.word	0x0b4a5365
3000150c:	0b380b4a 	.word	0x0b380b4a
30001510:	0b0b0b38 	.word	0x0b0b0b38
30001514:	260b0b0b 	.word	0x260b0b0b
            dprintf(CRITICAL, "unhandled fault\n");
30001518:	f24a 10b0 	movw	r0, #41392	; 0xa1b0
3000151c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001520:	f014 fb46 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
30001524:	f24a 10c4 	movw	r0, #41412	; 0xa1c4
30001528:	4631      	mov	r1, r6
3000152a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000152e:	f014 fb3f 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);
30001532:	f24a 10e0 	movw	r0, #41440	; 0xa1e0
30001536:	4629      	mov	r1, r5
30001538:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000153c:	f014 fb38 	bl	30015bb0 <_printf>
    exception_die(frame, "halting\n");
30001540:	f24a 2104 	movw	r1, #41476	; 0xa204
30001544:	4620      	mov	r0, r4
30001546:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000154a:	f7ff fec9 	bl	300012e0 <exception_die>
            dprintf(CRITICAL, "asynchronous external abort on %s\n", write ? "write" : "read");
3000154e:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
30001552:	f64c 433c 	movw	r3, #52284	; 0xcc3c
30001556:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000155a:	f24a 108c 	movw	r0, #41356	; 0xa18c
3000155e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001562:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001566:	2a00      	cmp	r2, #0
30001568:	bf08      	it	eq
3000156a:	4619      	moveq	r1, r3
3000156c:	f014 fb20 	bl	30015bb0 <_printf>
            break;
30001570:	e7d8      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "permission fault on %s\n", write ? "write" : "read");
30001572:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
30001576:	f64c 433c 	movw	r3, #52284	; 0xcc3c
3000157a:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000157e:	f24a 1040 	movw	r0, #41280	; 0xa140
30001582:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001586:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000158a:	2a00      	cmp	r2, #0
3000158c:	bf08      	it	eq
3000158e:	4619      	moveq	r1, r3
30001590:	f014 fb0e 	bl	30015bb0 <_printf>
            break;
30001594:	e7c6      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
30001596:	f24a 1024 	movw	r0, #41252	; 0xa124
3000159a:	f3c5 1103 	ubfx	r1, r5, #4, #4
3000159e:	f2c3 0001 	movt	r0, #12289	; 0x3001
300015a2:	f014 fb05 	bl	30015bb0 <_printf>
            break;
300015a6:	e7bd      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "synchronous external abort on %s\n", write ? "write" : "read");
300015a8:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
300015ac:	f64c 433c 	movw	r3, #52284	; 0xcc3c
300015b0:	f2c3 0301 	movt	r3, #12289	; 0x3001
300015b4:	f24a 1068 	movw	r0, #41320	; 0xa168
300015b8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300015bc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300015c0:	2a00      	cmp	r2, #0
300015c2:	bf08      	it	eq
300015c4:	4619      	moveq	r1, r3
300015c6:	f014 faf3 	bl	30015bb0 <_printf>
            break;
300015ca:	e7ab      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "translation fault on %s\n", write ? "write" : "read");
300015cc:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
300015d0:	f64c 433c 	movw	r3, #52284	; 0xcc3c
300015d4:	f2c3 0301 	movt	r3, #12289	; 0x3001
300015d8:	f24a 00ec 	movw	r0, #41196	; 0xa0ec
300015dc:	f2c3 0101 	movt	r1, #12289	; 0x3001
300015e0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300015e4:	2a00      	cmp	r2, #0
300015e6:	bf08      	it	eq
300015e8:	4619      	moveq	r1, r3
300015ea:	f014 fae1 	bl	30015bb0 <_printf>
            break;
300015ee:	e799      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "access flag fault on %s\n", write ? "write" : "read");
300015f0:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
300015f4:	f64c 433c 	movw	r3, #52284	; 0xcc3c
300015f8:	f2c3 0301 	movt	r3, #12289	; 0x3001
300015fc:	f24a 1008 	movw	r0, #41224	; 0xa108
30001600:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001604:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001608:	2a00      	cmp	r2, #0
3000160a:	bf08      	it	eq
3000160c:	4619      	moveq	r1, r3
3000160e:	f014 facf 	bl	30015bb0 <_printf>
            break;
30001612:	e787      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "debug event\n");
30001614:	f24a 1058 	movw	r0, #41304	; 0xa158
30001618:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000161c:	f014 fac8 	bl	30015bb0 <_printf>
            break;
30001620:	e780      	b.n	30001524 <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "alignment fault on %s\n", write ? "write" : "read");
30001622:	f24a 01b4 	movw	r1, #41140	; 0xa0b4
30001626:	f64c 433c 	movw	r3, #52284	; 0xcc3c
3000162a:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000162e:	f24a 00d4 	movw	r0, #41172	; 0xa0d4
30001632:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001636:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000163a:	2a00      	cmp	r2, #0
3000163c:	bf08      	it	eq
3000163e:	4619      	moveq	r1, r3
30001640:	f014 fab6 	bl	30015bb0 <_printf>
            break;
30001644:	e76e      	b.n	30001524 <arm_data_abort_handler+0x98>
30001646:	bf00      	nop

30001648 <arm_prefetch_abort_handler>:

void arm_prefetch_abort_handler(struct arm_fault_frame *frame)
{
30001648:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000164a:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(ifsr, 0, c5, c0, 1);
3000164c:	ee15 5f30 	mrc	15, 0, r5, cr5, cr0, {1}
GEN_CP15_REG_FUNCS(ifar, 0, c6, c0, 2);
30001650:	ee16 7f50 	mrc	15, 0, r7, cr6, cr0, {2}
    uint32_t fsr = arm_read_ifsr();
    uint32_t far = arm_read_ifar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
30001654:	f24a 2010 	movw	r0, #41488	; 0xa210
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
30001658:	09ab      	lsrs	r3, r5, #6
3000165a:	f003 0310 	and.w	r3, r3, #16
3000165e:	f005 040f 	and.w	r4, r5, #15
30001662:	431c      	orrs	r4, r3
    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
30001664:	2100      	movs	r1, #0
30001666:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000166a:	f014 faa1 	bl	30015bb0 <_printf>

    /* decode the fault status (from table B3-23) */
    switch (fault_status) {
3000166e:	1e63      	subs	r3, r4, #1
30001670:	2b15      	cmp	r3, #21
30001672:	d85a      	bhi.n	3000172a <arm_prefetch_abort_handler+0xe2>
30001674:	e8df f003 	tbb	[r15, r3]
30001678:	59342d26 	.word	0x59342d26
3000167c:	423b343b 	.word	0x423b343b
30001680:	59495949 	.word	0x59495949
30001684:	59525952 	.word	0x59525952
30001688:	59595959 	.word	0x59595959
3000168c:	0b59      	.short	0x0b59
            break;
        case 0b01000: // synchronous external abort
            dprintf(CRITICAL, "synchronous external abort\n");
            break;
        case 0b10110: // asynchronous external abort
            dprintf(CRITICAL, "asynchronous external abort\n");
3000168e:	f24a 2098 	movw	r0, #41624	; 0xa298
30001692:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001696:	f014 fa8b 	bl	30015bb0 <_printf>
        default:
            dprintf(CRITICAL, "unhandled fault\n");
            ;
    }

    dprintf(CRITICAL, "IFAR 0x%x (fault address)\n", far);
3000169a:	f24a 20b8 	movw	r0, #41656	; 0xa2b8
3000169e:	4639      	mov	r1, r7
300016a0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016a4:	f014 fa84 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "IFSR 0x%x (fault status register)\n", fsr);
300016a8:	f24a 20d4 	movw	r0, #41684	; 0xa2d4
300016ac:	4629      	mov	r1, r5
300016ae:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016b2:	f014 fa7d 	bl	30015bb0 <_printf>

    exception_die(frame, "halting\n");
300016b6:	f24a 2104 	movw	r1, #41476	; 0xa204
300016ba:	4630      	mov	r0, r6
300016bc:	f2c3 0101 	movt	r1, #12289	; 0x3001
300016c0:	f7ff fe0e 	bl	300012e0 <exception_die>
            dprintf(CRITICAL, "alignment fault\n");
300016c4:	f24a 202c 	movw	r0, #41516	; 0xa22c
300016c8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016cc:	f014 fa70 	bl	30015bb0 <_printf>
            break;
300016d0:	e7e3      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "debug event\n");
300016d2:	f24a 1058 	movw	r0, #41304	; 0xa158
300016d6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016da:	f014 fa69 	bl	30015bb0 <_printf>
            break;
300016de:	e7dc      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "access flag fault\n");
300016e0:	f24a 2054 	movw	r0, #41556	; 0xa254
300016e4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016e8:	f014 fa62 	bl	30015bb0 <_printf>
            break;
300016ec:	e7d5      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "translation fault\n");
300016ee:	f24a 2040 	movw	r0, #41536	; 0xa240
300016f2:	f2c3 0001 	movt	r0, #12289	; 0x3001
300016f6:	f014 fa5b 	bl	30015bb0 <_printf>
            break;
300016fa:	e7ce      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "synchronous external abort\n");
300016fc:	f24a 207c 	movw	r0, #41596	; 0xa27c
30001700:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001704:	f014 fa54 	bl	30015bb0 <_printf>
            break;
30001708:	e7c7      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
3000170a:	f24a 1024 	movw	r0, #41252	; 0xa124
3000170e:	f3c5 1103 	ubfx	r1, r5, #4, #4
30001712:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001716:	f014 fa4b 	bl	30015bb0 <_printf>
            break;
3000171a:	e7be      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "permission fault\n");
3000171c:	f24a 2068 	movw	r0, #41576	; 0xa268
30001720:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001724:	f014 fa44 	bl	30015bb0 <_printf>
            break;
30001728:	e7b7      	b.n	3000169a <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "unhandled fault\n");
3000172a:	f24a 10b0 	movw	r0, #41392	; 0xa1b0
3000172e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001732:	f014 fa3d 	bl	30015bb0 <_printf>
30001736:	e7b0      	b.n	3000169a <arm_prefetch_abort_handler+0x52>

30001738 <arm_fpu_set_enable>:
}

void arm_fpu_set_enable(bool enable)
{
    /* set enable bit in fpexc */
    write_fpexc(enable ? (1<<30) : 0);
30001738:	2800      	cmp	r0, #0
3000173a:	bf14      	ite	ne
3000173c:	f04f 4380 	movne.w	r3, #1073741824	; 0x40000000
30001740:	2300      	moveq	r3, #0
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
30001742:	eee8 3a10 	vmsr	fpexc, r3
}
30001746:	4770      	bx	r14

30001748 <arm_fpu_undefined_instruction>:

#if ARM_WITH_VFP
void arm_fpu_undefined_instruction(struct arm_iframe *frame)
{
30001748:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000174a:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
3000174c:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    return (ipsr & IPSR_ISR_Msk);
#else
    /* set by the interrupt glue to track that the cpu is inside a handler */
    extern bool __arm_in_handler;

    return __arm_in_handler;
30001750:	f242 1400 	movw	r4, #8448	; 0x2100
30001754:	f2c3 0402 	movt	r4, #12290	; 0x3002
    thread_t *t = get_current_thread();

    if (unlikely(arch_in_int_handler())) {
30001758:	7823      	ldrb	r3, [r4, #0]
3000175a:	b9b3      	cbnz	r3, 3000178a <arm_fpu_undefined_instruction+0x42>
    }
false_alarm:

    LTRACEF("enabling fpu on thread %p\n", t);

    t->arch.fpused = true;
3000175c:	2301      	movs	r3, #1
3000175e:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

            arm_fpu_set_enable(false);
        }
    }

    if (newthread) {
30001762:	b16d      	cbz	r5, 30001780 <arm_fpu_undefined_instruction+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
30001764:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
30001768:	eee8 3a10 	vmsr	fpexc, r3
        if (newthread->arch.fpused) {
            // load the new state
            arm_fpu_set_enable(true);
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
3000176c:	6bab      	ldr	r3, [r5, #56]	; 0x38
3000176e:	eee1 3a10 	vmsr	fpscr, r3

            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
30001772:	f105 0340 	add.w	r3, r5, #64	; 0x40
30001776:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
3000177a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
3000177c:	eee8 3a10 	vmsr	fpexc, r3
    frame->fpexc |= (1<<30);
30001780:	6833      	ldr	r3, [r6, #0]
30001782:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
30001786:	6033      	str	r3, [r6, #0]
}
30001788:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "floating point code while some cpu is in irq context. pc 0x%x\n", frame->pc);
3000178a:	f24a 4068 	movw	r0, #42088	; 0xa468
3000178e:	4677      	mov	r7, r14
30001790:	6a71      	ldr	r1, [r6, #36]	; 0x24
30001792:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001796:	f014 fa0b 	bl	30015bb0 <_printf>
        for (i = 0; i < 1000; i++) {
3000179a:	2100      	movs	r1, #0
3000179c:	7823      	ldrb	r3, [r4, #0]
            if (!arch_in_int_handler()) {
3000179e:	b15b      	cbz	r3, 300017b8 <arm_fpu_undefined_instruction+0x70>
        for (i = 0; i < 1000; i++) {
300017a0:	3101      	adds	r1, #1
300017a2:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
300017a6:	d1fa      	bne.n	3000179e <arm_fpu_undefined_instruction+0x56>
        panic("floating point code in irq context. pc 0x%x\n", frame->pc);
300017a8:	f24a 41dc 	movw	r1, #42204	; 0xa4dc
300017ac:	4638      	mov	r0, r7
300017ae:	6a72      	ldr	r2, [r6, #36]	; 0x24
300017b0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300017b4:	f012 fd2e 	bl	30014214 <_panic>
                dprintf(CRITICAL, "arch_in_int_handler status cleared after %d reads\n", i);
300017b8:	f24a 40a8 	movw	r0, #42152	; 0xa4a8
300017bc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300017c0:	f014 f9f6 	bl	30015bb0 <_printf>
                goto false_alarm;
300017c4:	e7ca      	b.n	3000175c <arm_fpu_undefined_instruction+0x14>
300017c6:	bf00      	nop

300017c8 <arm_fpu_thread_initialize>:
{
300017c8:	b510      	push	{r4, r14}
    memset(t->arch.fpregs, 0, sizeof(t->arch.fpregs));
300017ca:	f44f 7280 	mov.w	r2, #256	; 0x100
{
300017ce:	4604      	mov	r4, r0
    memset(t->arch.fpregs, 0, sizeof(t->arch.fpregs));
300017d0:	2100      	movs	r1, #0
300017d2:	3040      	adds	r0, #64	; 0x40
300017d4:	f013 e8cc 	blx	30014970 <memset>
    t->arch.fpscr = 0;
300017d8:	2300      	movs	r3, #0
300017da:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    t->arch.fpused = false;
300017de:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    t->arch.fpscr = 0;
300017e2:	e9c4 320e 	strd	r3, r2, [r4, #56]	; 0x38
}
300017e6:	bd10      	pop	{r4, r15}

300017e8 <arm_fpu_thread_swap>:
    if (oldthread) {
300017e8:	b110      	cbz	r0, 300017f0 <arm_fpu_thread_swap+0x8>
        if (oldthread->arch.fpused) {
300017ea:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
300017ee:	b933      	cbnz	r3, 300017fe <arm_fpu_thread_swap+0x16>
    if (newthread) {
300017f0:	b121      	cbz	r1, 300017fc <arm_fpu_thread_swap+0x14>
        if (newthread->arch.fpused) {
300017f2:	f891 3034 	ldrb.w	r3, [r1, #52]	; 0x34
300017f6:	b99b      	cbnz	r3, 30001820 <arm_fpu_thread_swap+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
300017f8:	eee8 3a10 	vmsr	fpexc, r3
            write_fpexc(newthread->arch.fpexc);
        } else {
            arm_fpu_set_enable(false);
        }
    }
}
300017fc:	4770      	bx	r14
    __asm__("mrc  p10, 7, %0, c8, c0, 0" : "=r" (val));
300017fe:	eef8 2a10 	vmrs	r2, fpexc
            oldthread->arch.fpexc = fpexc;
30001802:	63c2      	str	r2, [r0, #60]	; 0x3c
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
30001804:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
30001808:	eee8 3a10 	vmsr	fpexc, r3
            __asm__ volatile("vmrs  %0, fpscr" : "=r" (oldthread->arch.fpscr));
3000180c:	eef1 3a10 	vmrs	r3, fpscr
30001810:	6383      	str	r3, [r0, #56]	; 0x38
            __asm__ volatile("vstm   %0, { d0-d15 }" :: "r" (&oldthread->arch.fpregs[0]));
30001812:	3040      	adds	r0, #64	; 0x40
30001814:	ec80 0b20 	vstmia	r0, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
30001818:	2300      	movs	r3, #0
3000181a:	eee8 3a10 	vmsr	fpexc, r3
3000181e:	e7e7      	b.n	300017f0 <arm_fpu_thread_swap+0x8>
30001820:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
30001824:	eee8 3a10 	vmsr	fpexc, r3
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
30001828:	6b8b      	ldr	r3, [r1, #56]	; 0x38
3000182a:	eee1 3a10 	vmsr	fpscr, r3
            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
3000182e:	f101 0340 	add.w	r3, r1, #64	; 0x40
30001832:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
30001836:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
30001838:	eee8 3a10 	vmsr	fpexc, r3
3000183c:	4770      	bx	r14
3000183e:	bf00      	nop

30001840 <initial_thread_func>:

extern void arm_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
30001840:	b508      	push	{r3, r14}
    return 0;
}

static inline void arch_spin_unlock(spin_lock_t *lock)
{
    *lock = 0;
30001842:	f24d 1350 	movw	r3, #53584	; 0xd150
30001846:	2200      	movs	r2, #0
30001848:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000184c:	601a      	str	r2, [r3, #0]
    __asm__ volatile("cpsie i");
3000184e:	b662      	cpsie	i
30001850:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    /* release the thread lock that was implicitly held across the reschedule */
    spin_unlock(&thread_lock);
    arch_enable_ints();

    thread_t *ct = get_current_thread();
    ret = ct->entry(ct->arg);
30001854:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
30001858:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
3000185c:	4790      	blx	r2

//  dprintf("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

    thread_exit(ret);
3000185e:	f010 fe8d 	bl	3001257c <thread_exit>
30001862:	bf00      	nop

30001864 <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
30001864:	b570      	push	{r4, r5, r6, r14}
    // create a default stack frame on the stack
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
30001866:	f8d0 3144 	ldr.w	r3, [r0, #324]	; 0x144
{
3000186a:	4605      	mov	r5, r0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
3000186c:	f8d0 4140 	ldr.w	r4, [r0, #320]	; 0x140

    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
    frame--;

    // fill it in
    memset(frame, 0, sizeof(*frame));
30001870:	2224      	movs	r2, #36	; 0x24
30001872:	2100      	movs	r1, #0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
30001874:	441c      	add	r4, r3
    stack_top = ROUNDDOWN(stack_top, 8);
30001876:	f024 0407 	bic.w	r4, r4, #7
    frame--;
3000187a:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
    memset(frame, 0, sizeof(*frame));
3000187e:	4630      	mov	r0, r6
30001880:	f013 e876 	blx	30014970 <memset>
    frame->lr = (vaddr_t)&initial_thread_func;
30001884:	f641 0341 	movw	r3, #6209	; 0x1841

    // set the stack pointer
    t->arch.sp = (vaddr_t)frame;

#if ARM_WITH_VFP
    arm_fpu_thread_initialize(t);
30001888:	4628      	mov	r0, r5
    frame->lr = (vaddr_t)&initial_thread_func;
3000188a:	f2c3 0300 	movt	r3, #12288	; 0x3000
3000188e:	f844 3c04 	str.w	r3, [r4, #-4]
    t->arch.sp = (vaddr_t)frame;
30001892:	632e      	str	r6, [r5, #48]	; 0x30
#endif
}
30001894:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    arm_fpu_thread_initialize(t);
30001898:	f7ff bf96 	b.w	300017c8 <arm_fpu_thread_initialize>

3000189c <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
3000189c:	b538      	push	{r3, r4, r5, r14}
3000189e:	460c      	mov	r4, r1
300018a0:	4605      	mov	r5, r0
//  TRACEF("arch_context_switch: cpu %u old %p (%s), new %p (%s)\n", arch_curr_cpu_num(), oldthread, oldthread->name, newthread, newthread->name);
#if ARM_WITH_VFP
    arm_fpu_thread_swap(oldthread, newthread);
300018a2:	f7ff ffa1 	bl	300017e8 <arm_fpu_thread_swap>
#endif

    arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
300018a6:	f105 0030 	add.w	r0, r5, #48	; 0x30
300018aa:	6b21      	ldr	r1, [r4, #48]	; 0x30
}
300018ac:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
300018b0:	f018 bb72 	b.w	30019f98 <__arm_context_switch_from_thumb>

300018b4 <mpu_add_region>:
}
#endif
void mpu_add_region(int region, uint32_t base, uint32_t size,
                    mpu_region_type_e type)
{
    ASSERT(region >= 0 && region < mpu_region_nr());
300018b4:	2800      	cmp	r0, #0
{
300018b6:	b510      	push	{r4, r14}
300018b8:	b082      	sub	sp, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
300018ba:	db39      	blt.n	30001930 <mpu_add_region+0x7c>

GEN_CP15_REG_FUNCS(l2ctlr, 1, c9, c0, 2);
GEN_CP15_REG_FUNCS(l2ectlr, 1, c9, c0, 3);

/* mpu registers (using unified memory regions) */
GEN_CP15_REG_FUNCS(mpuir, 0, c0, c0, 4);
300018bc:	ee10 4f90 	mrc	15, 0, r4, cr0, cr0, {4}
    return (int)BITS_SHIFT(val, 15, 8);   /* 0, 12 or 16 */
300018c0:	f3c4 2407 	ubfx	r4, r4, #8, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
300018c4:	42a0      	cmp	r0, r4
300018c6:	da33      	bge.n	30001930 <mpu_add_region+0x7c>
    ASSERT((size & (size - 1)) == 0 &&
300018c8:	1e54      	subs	r4, r2, #1
300018ca:	4214      	tst	r4, r2
300018cc:	bf14      	ite	ne
300018ce:	2401      	movne	r4, #1
300018d0:	2400      	moveq	r4, #0
300018d2:	2a1f      	cmp	r2, #31
300018d4:	bf98      	it	ls
300018d6:	f044 0401 	orrls.w	r4, r4, #1
300018da:	bbd4      	cbnz	r4, 30001952 <mpu_add_region+0x9e>
           size >= 32ull &&
           size <= 4ull * 1024 * 1024 * 1024);
    ASSERT(base % size == 0);
300018dc:	fbb1 f4f2 	udiv	r4, r1, r2
300018e0:	fb02 1414 	mls	r4, r2, r4, r1
300018e4:	2c00      	cmp	r4, #0
300018e6:	d145      	bne.n	30001974 <mpu_add_region+0xc0>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
300018e8:	2b04      	cmp	r3, #4
300018ea:	d854      	bhi.n	30001996 <mpu_add_region+0xe2>
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
300018ec:	fab2 f282 	clz	r2, r2
300018f0:	3220      	adds	r2, #32
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
GEN_CP15_REG_FUNCS(rgnr, 0, c6, c2, 0);
300018f2:	ee06 0f12 	mcr	15, 0, r0, cr6, cr2, {0}
300018f6:	f3bf 8f6f 	isb	sy
    /* Calculate size field of RSR register.
     *  pow(2, sz + 1) = size
     */
    uint32_t sz = (uint32_t)log2ull(size) - 1;
    arm_write_rgnr(region);
    arm_write_rbar(base & MPU_RBAR_MASK);
300018fa:	f021 011f 	bic.w	r1, r1, #31
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
300018fe:	ee06 1f11 	mcr	15, 0, r1, cr6, cr1, {0}
30001902:	f3bf 8f6f 	isb	sy
    arm_write_racr(g_racr_config[type]);
30001906:	f24a 510c 	movw	r1, #42252	; 0xa50c
3000190a:	f2c3 0101 	movt	r1, #12289	; 0x3001
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
3000190e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
30001912:	ee06 3f91 	mcr	15, 0, r3, cr6, cr1, {4}
30001916:	f3bf 8f6f 	isb	sy
    uint32_t sz = (uint32_t)log2ull(size) - 1;
3000191a:	f1c2 033e 	rsb	r3, r2, #62	; 0x3e
    /* TODO - support sub regions? */
    arm_write_rsr((sz << RSR_SIZE_SHIFT) | RSR_EN);
3000191e:	005b      	lsls	r3, r3, #1
30001920:	f043 0301 	orr.w	r3, r3, #1
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
30001924:	ee06 3f51 	mcr	15, 0, r3, cr6, cr1, {2}
30001928:	f3bf 8f6f 	isb	sy
    if (type != MPU_REGION_NORMAL) {
        add_region(base, size);
    }

#endif
}
3000192c:	b002      	add	sp, #8
3000192e:	bd10      	pop	{r4, r15}
    ASSERT(region >= 0 && region < mpu_region_nr());
30001930:	f24a 5338 	movw	r3, #42296	; 0xa538
30001934:	f24a 5220 	movw	r2, #42272	; 0xa520
30001938:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000193c:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001940:	4670      	mov	r0, r14
30001942:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001946:	9300      	str	r3, [sp, #0]
30001948:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000194c:	2394      	movs	r3, #148	; 0x94
3000194e:	f012 fc61 	bl	30014214 <_panic>
    ASSERT((size & (size - 1)) == 0 &&
30001952:	f24a 5360 	movw	r3, #42336	; 0xa560
30001956:	f24a 5220 	movw	r2, #42272	; 0xa520
3000195a:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000195e:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001962:	4670      	mov	r0, r14
30001964:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001968:	9300      	str	r3, [sp, #0]
3000196a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000196e:	2397      	movs	r3, #151	; 0x97
30001970:	f012 fc50 	bl	30014214 <_panic>
    ASSERT(base % size == 0);
30001974:	f24a 53b0 	movw	r3, #42416	; 0xa5b0
30001978:	f24a 5220 	movw	r2, #42272	; 0xa520
3000197c:	f24a 011c 	movw	r1, #40988	; 0xa01c
30001980:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001984:	4670      	mov	r0, r14
30001986:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000198a:	9300      	str	r3, [sp, #0]
3000198c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001990:	2398      	movs	r3, #152	; 0x98
30001992:	f012 fc3f 	bl	30014214 <_panic>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
30001996:	f24a 53c4 	movw	r3, #42436	; 0xa5c4
3000199a:	f24a 5220 	movw	r2, #42272	; 0xa520
3000199e:	f24a 011c 	movw	r1, #40988	; 0xa01c
300019a2:	f2c3 0301 	movt	r3, #12289	; 0x3001
300019a6:	4670      	mov	r0, r14
300019a8:	f2c3 0201 	movt	r2, #12289	; 0x3001
300019ac:	9300      	str	r3, [sp, #0]
300019ae:	f2c3 0101 	movt	r1, #12289	; 0x3001
300019b2:	2399      	movs	r3, #153	; 0x99
300019b4:	f012 fc2e 	bl	30014214 <_panic>

300019b8 <mpu_enable>:
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
300019b8:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
 */
void mpu_enable(bool enable)
{
    uint32_t val = arm_read_sctlr();

    if (enable)
300019bc:	b930      	cbnz	r0, 300019cc <mpu_enable+0x14>
         */
    {
        val |= SCTLR_BR | SCTLR_M;
    }
    else {
        val &= ~SCTLR_M;
300019be:	f023 0301 	bic.w	r3, r3, #1
300019c2:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
300019c6:	f3bf 8f6f 	isb	sy
    }

    arm_write_sctlr(val);
}
300019ca:	4770      	bx	r14
        val |= SCTLR_BR | SCTLR_M;
300019cc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
300019d0:	f043 0301 	orr.w	r3, r3, #1
300019d4:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
300019d8:	f3bf 8f6f 	isb	sy
}
300019dc:	4770      	bx	r14
300019de:	bf00      	nop

300019e0 <tcm_get_size>:
/**
 * @brief Get TCM size in bytes.
 */
void tcm_get_size(size_t *atcm_size, size_t *btcm_size)
{
    ASSERT(atcm_size && btcm_size);
300019e0:	2900      	cmp	r1, #0
300019e2:	bf18      	it	ne
300019e4:	2800      	cmpne	r0, #0
{
300019e6:	b510      	push	{r4, r14}
300019e8:	b082      	sub	sp, #8
    ASSERT(atcm_size && btcm_size);
300019ea:	d012      	beq.n	30001a12 <tcm_get_size+0x32>
GEN_CP15_REG_FUNCS(pmxevcntr, 0, c9, c13, 2);

/* TCM registers */
GEN_CP15_REG_FUNCS(tcmtr, 0, c0, c0, 2);
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
GEN_CP15_REG_FUNCS(atcmrgn, 0, c9, c1, 1);
300019ec:	ee19 3f31 	mrc	15, 0, r3, cr9, cr1, {1}
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
300019f0:	ee19 2f11 	mrc	15, 0, r2, cr9, cr1, {0}

    uint32_t asize = BITS_SHIFT(arm_read_atcmrgn(), 6, 2);
    uint32_t bsize = BITS_SHIFT(arm_read_btcmrgn(), 6, 2);

    *atcm_size = 1 << (asize + 9);
300019f4:	2401      	movs	r4, #1
    uint32_t asize = BITS_SHIFT(arm_read_atcmrgn(), 6, 2);
300019f6:	f3c3 0384 	ubfx	r3, r3, #2, #5
    uint32_t bsize = BITS_SHIFT(arm_read_btcmrgn(), 6, 2);
300019fa:	f3c2 0284 	ubfx	r2, r2, #2, #5
    *atcm_size = 1 << (asize + 9);
300019fe:	3309      	adds	r3, #9
    *btcm_size = 1 << (bsize + 9);
30001a00:	3209      	adds	r2, #9
    *atcm_size = 1 << (asize + 9);
30001a02:	fa04 f303 	lsl.w	r3, r4, r3
    *btcm_size = 1 << (bsize + 9);
30001a06:	fa04 f202 	lsl.w	r2, r4, r2
    *atcm_size = 1 << (asize + 9);
30001a0a:	6003      	str	r3, [r0, #0]
    *btcm_size = 1 << (bsize + 9);
30001a0c:	600a      	str	r2, [r1, #0]
}
30001a0e:	b002      	add	sp, #8
30001a10:	bd10      	pop	{r4, r15}
    ASSERT(atcm_size && btcm_size);
30001a12:	f24a 6360 	movw	r3, #42592	; 0xa660
30001a16:	f24a 6248 	movw	r2, #42568	; 0xa648
30001a1a:	f24a 011c 	movw	r1, #40988	; 0xa01c
30001a1e:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001a22:	4670      	mov	r0, r14
30001a24:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001a28:	9300      	str	r3, [sp, #0]
30001a2a:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001a2e:	232d      	movs	r3, #45	; 0x2d
30001a30:	f012 fbf0 	bl	30014214 <_panic>

30001a34 <tcm_enable>:

/**
 * @brief Enable the TCM.
 */
void tcm_enable(uint32_t atcm_base, uint32_t btcm_base, bool enable_ecc)
{
30001a34:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30001a38:	4677      	mov	r7, r14
30001a3a:	b084      	sub	sp, #16
30001a3c:	4604      	mov	r4, r0
30001a3e:	460d      	mov	r5, r1
30001a40:	4690      	mov	r8, r2
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
30001a42:	ee11 6f30 	mrc	15, 0, r6, cr1, cr0, {1}
    size_t      atcm_size, btcm_size;
    uint32_t    actlr = arm_read_actlr();

    /* Disable ECC by default */
    actlr &= ~(ATCMPCEN | B0TCMPCEN | B1TCMPCEN);
30001a46:	f026 6660 	bic.w	r6, r6, #234881024	; 0xe000000
30001a4a:	ee01 6f30 	mcr	15, 0, r6, cr1, cr0, {1}
30001a4e:	f3bf 8f6f 	isb	sy
    arm_write_actlr(actlr);

    /* Get TCM size. */
    tcm_get_size(&atcm_size, &btcm_size);
30001a52:	a903      	add	r1, sp, #12
30001a54:	a802      	add	r0, sp, #8
30001a56:	f7ff ffc3 	bl	300019e0 <tcm_get_size>

    /* Update TCM base address. */
    if (atcm_size != 0) {
30001a5a:	9b02      	ldr	r3, [sp, #8]
30001a5c:	b143      	cbz	r3, 30001a70 <tcm_enable+0x3c>
        ASSERT(IS_ALIGNED(atcm_base, atcm_size));
30001a5e:	3b01      	subs	r3, #1
30001a60:	4223      	tst	r3, r4
30001a62:	d130      	bne.n	30001ac6 <tcm_enable+0x92>
        arm_write_atcmrgn(atcm_base | 1);
30001a64:	f044 0301 	orr.w	r3, r4, #1
GEN_CP15_REG_FUNCS(atcmrgn, 0, c9, c1, 1);
30001a68:	ee09 3f31 	mcr	15, 0, r3, cr9, cr1, {1}
30001a6c:	f3bf 8f6f 	isb	sy
    }

    if (btcm_size != 0) {
30001a70:	9b03      	ldr	r3, [sp, #12]
30001a72:	b143      	cbz	r3, 30001a86 <tcm_enable+0x52>
        ASSERT(IS_ALIGNED(btcm_base, btcm_size));
30001a74:	3b01      	subs	r3, #1
30001a76:	422b      	tst	r3, r5
30001a78:	d136      	bne.n	30001ae8 <tcm_enable+0xb4>
        arm_write_btcmrgn(btcm_base | 1);
30001a7a:	f045 0301 	orr.w	r3, r5, #1
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
30001a7e:	ee09 3f11 	mcr	15, 0, r3, cr9, cr1, {0}
30001a82:	f3bf 8f6f 	isb	sy
    }

    if (enable_ecc) {
30001a86:	f1b8 0f00 	cmp.w	r8, #0
30001a8a:	d019      	beq.n	30001ac0 <tcm_enable+0x8c>
    for (addr = base; addr < base + size; addr += 8) {
30001a8c:	9a02      	ldr	r2, [sp, #8]
30001a8e:	4422      	add	r2, r4
30001a90:	42a2      	cmp	r2, r4
30001a92:	d905      	bls.n	30001aa0 <tcm_enable+0x6c>
        __asm__ volatile(
30001a94:	2300      	movs	r3, #0
30001a96:	e9c4 3300 	strd	r3, r3, [r4]
    for (addr = base; addr < base + size; addr += 8) {
30001a9a:	3408      	adds	r4, #8
30001a9c:	42a2      	cmp	r2, r4
30001a9e:	d8fa      	bhi.n	30001a96 <tcm_enable+0x62>
30001aa0:	9a03      	ldr	r2, [sp, #12]
30001aa2:	442a      	add	r2, r5
30001aa4:	42aa      	cmp	r2, r5
30001aa6:	d905      	bls.n	30001ab4 <tcm_enable+0x80>
        __asm__ volatile(
30001aa8:	2300      	movs	r3, #0
30001aaa:	e9c5 3300 	strd	r3, r3, [r5]
    for (addr = base; addr < base + size; addr += 8) {
30001aae:	3508      	adds	r5, #8
30001ab0:	42aa      	cmp	r2, r5
30001ab2:	d8fa      	bhi.n	30001aaa <tcm_enable+0x76>
         */
        tcm_clear(atcm_base, atcm_size);
        tcm_clear(btcm_base, btcm_size);

        /* Enable ECC.  */
        actlr |= ATCMPCEN | B0TCMPCEN | B1TCMPCEN;
30001ab4:	f046 6660 	orr.w	r6, r6, #234881024	; 0xe000000
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
30001ab8:	ee01 6f30 	mcr	15, 0, r6, cr1, cr0, {1}
30001abc:	f3bf 8f6f 	isb	sy
        arm_write_actlr(actlr);
    }
}
30001ac0:	b004      	add	sp, #16
30001ac2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        ASSERT(IS_ALIGNED(atcm_base, atcm_size));
30001ac6:	f24a 6300 	movw	r3, #42496	; 0xa600
30001aca:	f24a 6248 	movw	r2, #42568	; 0xa648
30001ace:	f24a 011c 	movw	r1, #40988	; 0xa01c
30001ad2:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001ad6:	4638      	mov	r0, r7
30001ad8:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001adc:	9300      	str	r3, [sp, #0]
30001ade:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001ae2:	2347      	movs	r3, #71	; 0x47
30001ae4:	f012 fb96 	bl	30014214 <_panic>
        ASSERT(IS_ALIGNED(btcm_base, btcm_size));
30001ae8:	f24a 6324 	movw	r3, #42532	; 0xa624
30001aec:	f24a 6248 	movw	r2, #42568	; 0xa648
30001af0:	f24a 011c 	movw	r1, #40988	; 0xa01c
30001af4:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001af8:	4638      	mov	r0, r7
30001afa:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001afe:	9300      	str	r3, [sp, #0]
30001b00:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001b04:	234c      	movs	r3, #76	; 0x4c
30001b06:	f012 fb85 	bl	30014214 <_panic>
30001b0a:	bf00      	nop

30001b0c <arch_clean_cache_range>:
        if(!aligncheck(start, len)) \
            panic("ASSERT FAILED at aligncheck in %s (%p:%d, caller %p)\n", __func__, (void*)start, len, __GET_CALLER());   \
        _f##_asm(start, len);   \
    }

CACHE_OPS(arch_clean_cache_range)
30001b0c:	eafffc28 	b	30000bb4 <arch_clean_cache_range_asm>

30001b10 <arch_clean_invalidate_cache_range>:
CACHE_OPS(arch_clean_invalidate_cache_range)
30001b10:	eafffc30 	b	30000bd8 <arch_clean_invalidate_cache_range_asm>

30001b14 <arch_invalidate_cache_range>:
CACHE_OPS(arch_invalidate_cache_range)
30001b14:	eafffc38 	b	30000bfc <arch_invalidate_cache_range_asm>

30001b18 <arch_early_init>:
CACHE_OPS(arch_sync_cache_range)

void arch_early_init(void)
{
30001b18:	e92d4010 	push	{r4, r14}
    /* turn off the cache */
    arch_disable_cache(UCACHE);
30001b1c:	e3a00003 	mov	r0, #3
30001b20:	ebfffbab 	bl	300009d4 <arch_disable_cache>
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
30001b24:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
    sctlr |= (1 << 11); /* enable program flow prediction */
    sctlr &= ~(1 << 14); /* random cache/tlb replacement */
    sctlr &= ~(1 << 25); /* E bit set to 0 on exception */
    sctlr &= ~(1 << 30); /* no thumb exceptions */
    sctlr |= (1 << 22); /* enable unaligned access */
    sctlr &= ~(1 << 1); /* disable alignment abort */
30001b28:	e30b3bfd 	movw	r3, #48125	; 0xbbfd
30001b2c:	e34b3dff 	movt	r3, #48639	; 0xbdff
30001b30:	e0033002 	and	r3, r3, r2
30001b34:	e3833501 	orr	r3, r3, #4194304	; 0x400000
30001b38:	e3833b02 	orr	r3, r3, #2048	; 0x800
30001b3c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
30001b40:	f57ff06f 	isb	sy
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
30001b44:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
30001b48:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
30001b4c:	f57ff06f 	isb	sy
#endif // ARM_CPU_CORTEX_A7
    arm_write_actlr(actlr);
#if ENABLE_CYCLE_COUNTER && ARM_ISA_ARMV7
    /* enable the cycle count register */
    uint32_t en;
    __asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r"(en));
30001b50:	ee193f1c 	mrc	15, 0, r3, cr9, cr12, {0}
    en &= ~(1 << 3); /* cycle count every cycle */
30001b54:	e3c33008 	bic	r3, r3, #8
    en |= 1; /* enable all performance counters */
30001b58:	e3833001 	orr	r3, r3, #1
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r"(en));
30001b5c:	ee093f1c 	mcr	15, 0, r3, cr9, cr12, {0}
    /* enable cycle counter */
    en = (1 << 31);
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r"(en));
30001b60:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
30001b64:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
GEN_CP15_REG_FUNCS(cpacr, 0, c1, c0, 2);
30001b68:	ee113f50 	mrc	15, 0, r3, cr1, cr0, {2}
#endif
#if ARM_WITH_VFP
    /* enable cp10 and cp11 */
    uint32_t val = arm_read_cpacr();
    val |= (3 << 22) | (3 << 20);
30001b6c:	e383360f 	orr	r3, r3, #15728640	; 0xf00000
30001b70:	ee013f50 	mcr	15, 0, r3, cr1, cr0, {2}
30001b74:	f57ff06f 	isb	sy
    arm_write_cpacr(val);
    /* set enable bit in fpexc */
    __asm__ volatile("mrc  p10, 7, %0, c8, c0, 0" : "=r"(val));
30001b78:	eef83a10 	vmrs	r3, fpexc
    val |= (1 << 30);
30001b7c:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r"(val));
30001b80:	eee83a10 	vmsr	fpexc, r3
    /* make sure the fpu starts off disabled */
    arm_fpu_set_enable(false);
30001b84:	e3a00000 	mov	r0, #0
30001b88:	fafffeea 	blx	30001738 <arm_fpu_set_enable>
    arch_enable_cache(UCACHE);
30001b8c:	e3a00003 	mov	r0, #3
}
30001b90:	e8bd4010 	pop	{r4, r14}
    arch_enable_cache(UCACHE);
30001b94:	eafffba5 	b	30000a30 <arch_enable_cache>

30001b98 <arch_init>:
}
30001b98:	e12fff1e 	bx	r14

30001b9c <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
30001b9c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30001ba0:	b083      	sub	sp, #12
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
30001ba2:	2900      	cmp	r1, #0
30001ba4:	d051      	beq.n	30001c4a <lk_init_level+0xae>
30001ba6:	f242 08a0 	movw	r8, #8352	; 0x20a0
30001baa:	f242 06f0 	movw	r6, #8432	; 0x20f0
30001bae:	f2c3 0802 	movt	r8, #12290	; 0x3002
30001bb2:	4691      	mov	r9, r2
30001bb4:	f2c3 0602 	movt	r6, #12290	; 0x3002
30001bb8:	4683      	mov	r11, r0
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
30001bba:	45b0      	cmp	r8, r6
30001bbc:	468a      	mov	r10, r1
    uint last_called_level = start_level - 1;
30001bbe:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    const struct lk_init_struct *last = NULL;
30001bc2:	f04f 0500 	mov.w	r5, #0
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
30001bc6:	d03b      	beq.n	30001c40 <lk_init_level+0xa4>
30001bc8:	f242 03a0 	movw	r3, #8352	; 0x20a0
        bool seen_last = false;
30001bcc:	2400      	movs	r4, #0
        const struct lk_init_struct *found = NULL;
30001bce:	4621      	mov	r1, r4
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
30001bd0:	f2c3 0302 	movt	r3, #12290	; 0x3002
30001bd4:	e002      	b.n	30001bdc <lk_init_level+0x40>
30001bd6:	3310      	adds	r3, #16
30001bd8:	42b3      	cmp	r3, r6
30001bda:	d029      	beq.n	30001c30 <lk_init_level+0x94>

            if (ptr == last)
                seen_last = true;

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
30001bdc:	6858      	ldr	r0, [r3, #4]
                seen_last = true;
30001bde:	429d      	cmp	r5, r3
30001be0:	bf08      	it	eq
30001be2:	2401      	moveq	r4, #1
            if (!(ptr->flags & required_flag))
30001be4:	ea1b 0f00 	tst.w	r11, r0
30001be8:	d0f5      	beq.n	30001bd6 <lk_init_level+0x3a>
                continue;
            if (ptr->level > stop_level)
30001bea:	6818      	ldr	r0, [r3, #0]
                continue;
            if (ptr->level < last_called_level)
30001bec:	4548      	cmp	r0, r9
30001bee:	bf98      	it	ls
30001bf0:	4282      	cmpls	r2, r0
30001bf2:	d8f0      	bhi.n	30001bd6 <lk_init_level+0x3a>
                continue;
            if (found && found->level <= ptr->level)
30001bf4:	b111      	cbz	r1, 30001bfc <lk_init_level+0x60>
30001bf6:	680f      	ldr	r7, [r1, #0]
30001bf8:	42b8      	cmp	r0, r7
30001bfa:	d2ec      	bcs.n	30001bd6 <lk_init_level+0x3a>
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
30001bfc:	4282      	cmp	r2, r0
30001bfe:	bf34      	ite	cc
30001c00:	f04f 0c01 	movcc.w	r12, #1
30001c04:	f04f 0c00 	movcs.w	r12, #0
30001c08:	4550      	cmp	r0, r10
30001c0a:	bf38      	it	cc
30001c0c:	f04f 0c00 	movcc.w	r12, #0
30001c10:	f1bc 0f00 	cmp.w	r12, #0
30001c14:	d117      	bne.n	30001c46 <lk_init_level+0xaa>

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
30001c16:	4282      	cmp	r2, r0
30001c18:	d1dd      	bne.n	30001bd6 <lk_init_level+0x3a>
30001c1a:	429d      	cmp	r5, r3
30001c1c:	bf0c      	ite	eq
30001c1e:	f04f 0c00 	moveq.w	r12, #0
30001c22:	f004 0c01 	andne.w	r12, r4, #1
30001c26:	f1bc 0f00 	cmp.w	r12, #0
30001c2a:	d0d4      	beq.n	30001bd6 <lk_init_level+0x3a>
30001c2c:	461d      	mov	r5, r3
30001c2e:	e002      	b.n	30001c36 <lk_init_level+0x9a>
                found = ptr;
                break;
            }
        }

        if (!found)
30001c30:	b131      	cbz	r1, 30001c40 <lk_init_level+0xa4>
30001c32:	6808      	ldr	r0, [r1, #0]
30001c34:	460d      	mov	r5, r1
        if (found->level >= EARLIEST_TRACE_LEVEL && (required_flag & TRACE_INIT_FLAGS)) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
30001c36:	68ab      	ldr	r3, [r5, #8]
30001c38:	4798      	blx	r3
        last_called_level = found->level;
30001c3a:	682a      	ldr	r2, [r5, #0]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
30001c3c:	45b0      	cmp	r8, r6
30001c3e:	d1c3      	bne.n	30001bc8 <lk_init_level+0x2c>
        last = found;
    }
}
30001c40:	b003      	add	sp, #12
30001c42:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30001c46:	4619      	mov	r1, r3
30001c48:	e7c5      	b.n	30001bd6 <lk_init_level+0x3a>
    ASSERT(start_level > 0);
30001c4a:	f24a 6388 	movw	r3, #42632	; 0xa688
30001c4e:	f24a 6278 	movw	r2, #42616	; 0xa678
30001c52:	f24a 011c 	movw	r1, #40988	; 0xa01c
30001c56:	f2c3 0301 	movt	r3, #12289	; 0x3001
30001c5a:	4670      	mov	r0, r14
30001c5c:	f2c3 0201 	movt	r2, #12289	; 0x3001
30001c60:	9300      	str	r3, [sp, #0]
30001c62:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001c66:	2334      	movs	r3, #52	; 0x34
30001c68:	f012 fad4 	bl	30014214 <_panic>

30001c6c <bootstrap2>:

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level)
{
    lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
30001c6c:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001c70:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
    // become the idle thread and enable interrupts to start the scheduler
    thread_become_idle();
}

static int bootstrap2(void *arg)
{
30001c74:	b508      	push	{r3, r14}
30001c76:	2001      	movs	r0, #1
30001c78:	f2c0 0207 	movt	r2, #7
30001c7c:	f7ff ff8e 	bl	30001b9c <lk_init_level>
    dprintf(SPEW, "top of bootstrap2()\n");

    lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
    arch_init();
30001c80:	f7ff ef8a 	blx	30001b98 <arch_init>
30001c84:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001c88:	f44f 2100 	mov.w	r1, #524288	; 0x80000
30001c8c:	2001      	movs	r0, #1
30001c8e:	f2c0 0208 	movt	r2, #8
30001c92:	f7ff ff83 	bl	30001b9c <lk_init_level>

    // initialize the rest of the platform
    dprintf(SPEW, "initializing platform\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
    platform_init();
30001c96:	f7fe fc07 	bl	300004a8 <platform_init>
30001c9a:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001c9e:	f44f 2110 	mov.w	r1, #589824	; 0x90000
30001ca2:	2001      	movs	r0, #1
30001ca4:	f2c0 0209 	movt	r2, #9
30001ca8:	f7ff ff78 	bl	30001b9c <lk_init_level>

    // initialize the target
    dprintf(SPEW, "initializing target\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
    target_init();
30001cac:	f7fe fac6 	bl	3000023c <target_init>
30001cb0:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001cb4:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
30001cb8:	2001      	movs	r0, #1
30001cba:	f2c0 020a 	movt	r2, #10
30001cbe:	f7ff ff6d 	bl	30001b9c <lk_init_level>

    dprintf(SPEW, "calling apps_init()\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
    apps_init();
30001cc2:	f000 f885 	bl	30001dd0 <apps_init>
30001cc6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
30001cca:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
30001cce:	2001      	movs	r0, #1
30001cd0:	f7ff ff64 	bl	30001b9c <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

    return 0;
}
30001cd4:	2000      	movs	r0, #0
30001cd6:	bd08      	pop	{r3, r15}

30001cd8 <lk_main>:
    lk_boot_args[0] = arg0;
30001cd8:	f646 4460 	movw	r4, #27744	; 0x6c60
30001cdc:	f2c3 0402 	movt	r4, #12290	; 0x3002
{
30001ce0:	b500      	push	{r14}
    lk_boot_args[3] = arg3;
30001ce2:	e9c4 2302 	strd	r2, r3, [r4, #8]
{
30001ce6:	b083      	sub	sp, #12
    lk_boot_args[1] = arg1;
30001ce8:	e9c4 0100 	strd	r0, r1, [r4]
    thread_init_early();
30001cec:	f010 fa0e 	bl	3001210c <thread_init_early>
30001cf0:	2101      	movs	r1, #1
30001cf2:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001cf6:	4608      	mov	r0, r1
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
30001cf8:	f245 44ac 	movw	r4, #21676	; 0x54ac
30001cfc:	f7ff ff4e 	bl	30001b9c <lk_init_level>
    arch_early_init();
30001d00:	f7ff ef0a 	blx	30001b18 <arch_early_init>
30001d04:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001d08:	f44f 3180 	mov.w	r1, #65536	; 0x10000
30001d0c:	2001      	movs	r0, #1
30001d0e:	f2c0 0201 	movt	r2, #1
30001d12:	f7ff ff43 	bl	30001b9c <lk_init_level>
    platform_early_init();
30001d16:	f7fe fb35 	bl	30000384 <platform_early_init>
30001d1a:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001d1e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
30001d22:	2001      	movs	r0, #1
30001d24:	f2c0 0202 	movt	r2, #2
30001d28:	f7ff ff38 	bl	30001b9c <lk_init_level>
    target_early_init();
30001d2c:	f7fe fa5a 	bl	300001e4 <target_early_init>
30001d30:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001d34:	f44f 3140 	mov.w	r1, #196608	; 0x30000
30001d38:	2001      	movs	r0, #1
30001d3a:	f2c0 0203 	movt	r2, #3
30001d3e:	f7ff ff2d 	bl	30001b9c <lk_init_level>
    heap_init();
30001d42:	f012 fcc5 	bl	300146d0 <heap_init>
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
30001d46:	f245 43ac 	movw	r3, #21676	; 0x54ac
30001d4a:	f2c3 0402 	movt	r4, #12290	; 0x3002
30001d4e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30001d52:	429c      	cmp	r4, r3
30001d54:	d00a      	beq.n	30001d6c <lk_main+0x94>
30001d56:	1d25      	adds	r5, r4, #4
30001d58:	1b5d      	subs	r5, r3, r5
30001d5a:	f025 0503 	bic.w	r5, r5, #3
30001d5e:	3504      	adds	r5, #4
30001d60:	4425      	add	r5, r4
        (*ctor)();
30001d62:	f854 3b04 	ldr.w	r3, [r4], #4
30001d66:	4798      	blx	r3
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
30001d68:	42ac      	cmp	r4, r5
30001d6a:	d1fa      	bne.n	30001d62 <lk_main+0x8a>
30001d6c:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001d70:	f44f 2180 	mov.w	r1, #262144	; 0x40000
30001d74:	2001      	movs	r0, #1
30001d76:	f2c0 0205 	movt	r2, #5
30001d7a:	f7ff ff0f 	bl	30001b9c <lk_init_level>
    kernel_init();
30001d7e:	f00f fe11 	bl	300119a4 <kernel_init>
30001d82:	f64f 72ff 	movw	r2, #65535	; 0xffff
30001d86:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
30001d8a:	2001      	movs	r0, #1
30001d8c:	f2c0 0206 	movt	r2, #6
30001d90:	f7ff ff04 	bl	30001b9c <lk_init_level>
    thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
30001d94:	f44f 5380 	mov.w	r3, #4096	; 0x1000
30001d98:	f641 416d 	movw	r1, #7277	; 0x1c6d
30001d9c:	f24a 6098 	movw	r0, #42648	; 0xa698
30001da0:	2200      	movs	r2, #0
30001da2:	f2c3 0100 	movt	r1, #12288	; 0x3000
30001da6:	9300      	str	r3, [sp, #0]
30001da8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001dac:	2310      	movs	r3, #16
30001dae:	f010 f86f 	bl	30011e90 <thread_create>
30001db2:	4604      	mov	r4, r0
    thread_detach(t);
30001db4:	f010 fb86 	bl	300124c4 <thread_detach>
    thread_resume(t);
30001db8:	4620      	mov	r0, r4
30001dba:	f010 f8bd 	bl	30011f38 <thread_resume>
    thread_become_idle();
30001dbe:	f010 f9e9 	bl	30012194 <thread_become_idle>
30001dc2:	bf00      	nop

30001dc4 <app_thread_entry>:
        }
    }
}

static int app_thread_entry(void *arg)
{
30001dc4:	b508      	push	{r3, r14}
    const struct app_descriptor *app = (const struct app_descriptor *)arg;

    app->entry(app, NULL);
30001dc6:	6883      	ldr	r3, [r0, #8]
30001dc8:	2100      	movs	r1, #0
30001dca:	4798      	blx	r3

    return 0;
}
30001dcc:	2000      	movs	r0, #0
30001dce:	bd08      	pop	{r3, r15}

30001dd0 <apps_init>:
{
30001dd0:	b5f0      	push	{r4, r5, r6, r7, r14}
    for (app = __apps_start; app != __apps_end; app++) {
30001dd2:	f242 0378 	movw	r3, #8312	; 0x2078
30001dd6:	f242 05a0 	movw	r5, #8352	; 0x20a0
30001dda:	f2c3 0302 	movt	r3, #12290	; 0x3002
30001dde:	f2c3 0502 	movt	r5, #12290	; 0x3002
30001de2:	42ab      	cmp	r3, r5
{
30001de4:	b083      	sub	sp, #12
    for (app = __apps_start; app != __apps_end; app++) {
30001de6:	d041      	beq.n	30001e6c <apps_init+0x9c>
30001de8:	461c      	mov	r4, r3
30001dea:	f103 0214 	add.w	r2, r3, #20
30001dee:	1aaa      	subs	r2, r5, r2
30001df0:	f64c 45cd 	movw	r5, #52429	; 0xcccd
30001df4:	0892      	lsrs	r2, r2, #2
30001df6:	f6c0 45cc 	movt	r5, #3276	; 0xccc
30001dfa:	fb05 f502 	mul.w	r5, r5, r2
30001dfe:	f025 4540 	bic.w	r5, r5, #3221225472	; 0xc0000000
30001e02:	3501      	adds	r5, #1
30001e04:	eb05 0585 	add.w	r5, r5, r5, lsl #2
30001e08:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        if (app->init)
30001e0c:	6863      	ldr	r3, [r4, #4]
            app->init(app);
30001e0e:	4620      	mov	r0, r4
    for (app = __apps_start; app != __apps_end; app++) {
30001e10:	3414      	adds	r4, #20
        if (app->init)
30001e12:	b103      	cbz	r3, 30001e16 <apps_init+0x46>
            app->init(app);
30001e14:	4798      	blx	r3
    for (app = __apps_start; app != __apps_end; app++) {
30001e16:	42ac      	cmp	r4, r5
30001e18:	d1f8      	bne.n	30001e0c <apps_init+0x3c>
    for (app = __apps_start; app != __apps_end; app++) {
30001e1a:	f242 0578 	movw	r5, #8312	; 0x2078
static void start_app(const struct app_descriptor *app)
{
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

    dprintf(INFO, "starting app %s\n", app->name);
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
30001e1e:	f641 56c5 	movw	r6, #7621	; 0x1dc5
    for (app = __apps_start; app != __apps_end; app++) {
30001e22:	f2c3 0502 	movt	r5, #12290	; 0x3002
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
30001e26:	f2c3 0600 	movt	r6, #12288	; 0x3000
30001e2a:	e002      	b.n	30001e32 <apps_init+0x62>
    for (app = __apps_start; app != __apps_end; app++) {
30001e2c:	3514      	adds	r5, #20
30001e2e:	42a5      	cmp	r5, r4
30001e30:	d01c      	beq.n	30001e6c <apps_init+0x9c>
        if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
30001e32:	68ab      	ldr	r3, [r5, #8]
30001e34:	2b00      	cmp	r3, #0
30001e36:	d0f9      	beq.n	30001e2c <apps_init+0x5c>
30001e38:	68eb      	ldr	r3, [r5, #12]
30001e3a:	07da      	lsls	r2, r3, #31
30001e3c:	d4f6      	bmi.n	30001e2c <apps_init+0x5c>
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
30001e3e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
30001e42:	f013 0f02 	tst.w	r3, #2
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
30001e46:	6828      	ldr	r0, [r5, #0]
30001e48:	f04f 0310 	mov.w	r3, #16
30001e4c:	4631      	mov	r1, r6
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
30001e4e:	bf18      	it	ne
30001e50:	692a      	ldrne	r2, [r5, #16]
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
30001e52:	9200      	str	r2, [sp, #0]
30001e54:	462a      	mov	r2, r5
30001e56:	f010 f81b 	bl	30011e90 <thread_create>
    for (app = __apps_start; app != __apps_end; app++) {
30001e5a:	3514      	adds	r5, #20
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
30001e5c:	4607      	mov	r7, r0
    thread_detach(t);
30001e5e:	f010 fb31 	bl	300124c4 <thread_detach>
    thread_resume(t);
30001e62:	4638      	mov	r0, r7
30001e64:	f010 f868 	bl	30011f38 <thread_resume>
    for (app = __apps_start; app != __apps_end; app++) {
30001e68:	42a5      	cmp	r5, r4
30001e6a:	d1e2      	bne.n	30001e32 <apps_init+0x62>
}
30001e6c:	b003      	add	sp, #12
30001e6e:	bdf0      	pop	{r4, r5, r6, r7, r15}

30001e70 <shell_entry>:
    console_init();
}

static void shell_entry(const struct app_descriptor *app, void *args)
{
    console_start();
30001e70:	f012 b9a4 	b.w	300141bc <console_start>

30001e74 <shell_init>:
    console_init();
30001e74:	f012 b952 	b.w	3001411c <console_init>

30001e78 <erase_nor_flash_partition>:
}

static bool erase_nor_flash_partition(struct partition_device *ptdev,
                                      struct storage_info *st_info,
                                      const char *full_ptname, uint64_t img_sz)
{
30001e78:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct storage_device *storage;
    uint64_t size, ptn, erase_size;

    if (!ptdev || !ptdev->storage
30001e7c:	4604      	mov	r4, r0
{
30001e7e:	b087      	sub	sp, #28
    if (!ptdev || !ptdev->storage
30001e80:	b160      	cbz	r0, 30001e9c <erase_nor_flash_partition+0x24>
30001e82:	6807      	ldr	r7, [r0, #0]
30001e84:	b14f      	cbz	r7, 30001e9a <erase_nor_flash_partition+0x22>
            || !st_info || !img_sz)
30001e86:	e9dd 3510 	ldrd	r3, r5, [r13, #64]	; 0x40
30001e8a:	432b      	orrs	r3, r5
30001e8c:	bf0c      	ite	eq
30001e8e:	2501      	moveq	r5, #1
30001e90:	2500      	movne	r5, #0
30001e92:	2900      	cmp	r1, #0
30001e94:	bf08      	it	eq
30001e96:	2501      	moveq	r5, #1
30001e98:	b125      	cbz	r5, 30001ea4 <erase_nor_flash_partition+0x2c>
        return false;
30001e9a:	2400      	movs	r4, #0
    }

    DBG("erase_size:0x%llx size:0x%llx group:0x%x name:%s",
        erase_size, size, st_info->erase_grp_sz, full_ptname);
    return true;
}
30001e9c:	4620      	mov	r0, r4
30001e9e:	b007      	add	sp, #28
30001ea0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30001ea4:	460e      	mov	r6, r1
    size = ptdev_get_size(ptdev, full_ptname);
30001ea6:	4611      	mov	r1, r2
30001ea8:	4692      	mov	r10, r2
30001eaa:	f016 f819 	bl	30017ee0 <ptdev_get_size>
30001eae:	4680      	mov	r8, r0
30001eb0:	4689      	mov	r9, r1
    ptn = ptdev_get_offset(ptdev, full_ptname);
30001eb2:	4620      	mov	r0, r4
30001eb4:	4651      	mov	r1, r10
30001eb6:	f016 f839 	bl	30017f2c <ptdev_get_offset>
30001eba:	460a      	mov	r2, r1
    if (!ptn || !size) {
30001ebc:	4603      	mov	r3, r0
    ptn = ptdev_get_offset(ptdev, full_ptname);
30001ebe:	4601      	mov	r1, r0
    if (!ptn || !size) {
30001ec0:	4313      	orrs	r3, r2
30001ec2:	bf0c      	ite	eq
30001ec4:	2401      	moveq	r4, #1
30001ec6:	2400      	movne	r4, #0
    ptn = ptdev_get_offset(ptdev, full_ptname);
30001ec8:	e9cd 1202 	strd	r1, r2, [r13, #8]
    if (!ptn || !size) {
30001ecc:	ea58 0309 	orrs.w	r3, r8, r9
30001ed0:	bf08      	it	eq
30001ed2:	2401      	moveq	r4, #1
30001ed4:	2c00      	cmp	r4, #0
30001ed6:	d165      	bne.n	30001fa4 <erase_nor_flash_partition+0x12c>

static inline uint64_t round_up(uint64_t size, uint64_t aligned)
{
    uint64_t mod = 0;

    if (aligned == 0 || size < aligned)
30001ed8:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
    erase_size = round_up(img_sz, st_info->erase_grp_sz);
30001edc:	f04f 0b00 	mov.w	r11, #0
30001ee0:	6f32      	ldr	r2, [r6, #112]	; 0x70
30001ee2:	4692      	mov	r10, r2
30001ee4:	4559      	cmp	r1, r11
30001ee6:	bf08      	it	eq
30001ee8:	4290      	cmpeq	r0, r2
30001eea:	bf34      	ite	cc
30001eec:	2301      	movcc	r3, #1
30001eee:	2300      	movcs	r3, #0
30001ef0:	2a00      	cmp	r2, #0
30001ef2:	bf08      	it	eq
30001ef4:	2301      	moveq	r3, #1
30001ef6:	2b00      	cmp	r3, #0
30001ef8:	d151      	bne.n	30001f9e <erase_nor_flash_partition+0x126>
        return aligned;

    /* Sometimes, 'aligned' is not equal to power of 2 */
    mod = size % aligned;
30001efa:	465b      	mov	r3, r11
30001efc:	f017 ff90 	bl	30019e20 <__aeabi_uldivmod>

    size += mod ? aligned - mod : 0;
30001f00:	ea52 0103 	orrs.w	r1, r2, r3
30001f04:	d15d      	bne.n	30001fc2 <erase_nor_flash_partition+0x14a>
    erase_size = erase_size > size ? size : erase_size;
30001f06:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
30001f0a:	4642      	mov	r2, r8
30001f0c:	693d      	ldr	r5, [r7, #16]
30001f0e:	464b      	mov	r3, r9
30001f10:	4549      	cmp	r1, r9
30001f12:	bf08      	it	eq
30001f14:	4540      	cmpeq	r0, r8
30001f16:	bf3c      	itt	cc
30001f18:	4602      	movcc	r2, r0
30001f1a:	460b      	movcc	r3, r1
    erase_size = (size - erase_size > st_info->erase_grp_sz) ? erase_size :
30001f1c:	ebb8 0002 	subs.w	r0, r8, r2
30001f20:	eb69 0103 	sbc.w	r1, r9, r3
30001f24:	458b      	cmp	r11, r1
30001f26:	e9cd 0104 	strd	r0, r1, [r13, #16]
30001f2a:	bf08      	it	eq
30001f2c:	4582      	cmpeq	r10, r0
30001f2e:	d221      	bcs.n	30001f74 <erase_nor_flash_partition+0xfc>
    if (storage->erase(storage, ptn, erase_size)) {
30001f30:	e9cd 2300 	strd	r2, r3, [r13]
30001f34:	4638      	mov	r0, r7
30001f36:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30001f3a:	47a8      	blx	r5
30001f3c:	bb10      	cbnz	r0, 30001f84 <erase_nor_flash_partition+0x10c>
    if (( size - erase_size > st_info->erase_grp_sz)
30001f3e:	6f32      	ldr	r2, [r6, #112]	; 0x70
30001f40:	2600      	movs	r6, #0
30001f42:	4615      	mov	r5, r2
30001f44:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
30001f48:	429e      	cmp	r6, r3
30001f4a:	bf08      	it	eq
30001f4c:	4295      	cmpeq	r5, r2
30001f4e:	d20f      	bcs.n	30001f70 <erase_nor_flash_partition+0xf8>
            && storage->erase(storage, ptn + size - st_info->erase_grp_sz,
30001f50:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30001f54:	4638      	mov	r0, r7
30001f56:	e9cd 5600 	strd	r5, r6, [r13]
30001f5a:	6939      	ldr	r1, [r7, #16]
30001f5c:	eb12 0208 	adds.w	r2, r2, r8
30001f60:	eb43 0309 	adc.w	r3, r3, r9
30001f64:	1b52      	subs	r2, r2, r5
30001f66:	eb63 0306 	sbc.w	r3, r3, r6
30001f6a:	4788      	blx	r1
30001f6c:	2800      	cmp	r0, #0
30001f6e:	d134      	bne.n	30001fda <erase_nor_flash_partition+0x162>
    return true;
30001f70:	2401      	movs	r4, #1
30001f72:	e793      	b.n	30001e9c <erase_nor_flash_partition+0x24>
    if (storage->erase(storage, ptn, erase_size)) {
30001f74:	e9cd 8900 	strd	r8, r9, [r13]
30001f78:	4638      	mov	r0, r7
30001f7a:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30001f7e:	47a8      	blx	r5
30001f80:	2800      	cmp	r0, #0
30001f82:	d0f5      	beq.n	30001f70 <erase_nor_flash_partition+0xf8>
        ERROR("flash storage error\n");
30001f84:	f24a 7178 	movw	r1, #42872	; 0xa778
30001f88:	f64b 00b0 	movw	r0, #47280	; 0xb8b0
30001f8c:	f240 22b5 	movw	r2, #693	; 0x2b5
30001f90:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001f94:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001f98:	f013 fe0a 	bl	30015bb0 <_printf>
        return false;
30001f9c:	e77e      	b.n	30001e9c <erase_nor_flash_partition+0x24>
    erase_size = round_up(img_sz, st_info->erase_grp_sz);
30001f9e:	e9cd ab10 	strd	r10, r11, [r13, #64]	; 0x40
30001fa2:	e7b0      	b.n	30001f06 <erase_nor_flash_partition+0x8e>
        ERROR("ptn or size is 0. name:%s\n", full_ptname);
30001fa4:	f24a 7178 	movw	r1, #42872	; 0xa778
30001fa8:	f64b 0088 	movw	r0, #47240	; 0xb888
30001fac:	4653      	mov	r3, r10
30001fae:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001fb2:	f240 22ab 	movw	r2, #683	; 0x2ab
30001fb6:	f2c3 0001 	movt	r0, #12289	; 0x3001
        return false;
30001fba:	462c      	mov	r4, r5
        ERROR("ptn or size is 0. name:%s\n", full_ptname);
30001fbc:	f013 fdf8 	bl	30015bb0 <_printf>
        return false;
30001fc0:	e76c      	b.n	30001e9c <erase_nor_flash_partition+0x24>
30001fc2:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
30001fc6:	eb10 000a 	adds.w	r0, r0, r10
30001fca:	eb41 010b 	adc.w	r1, r1, r11
30001fce:	1a80      	subs	r0, r0, r2
30001fd0:	eb61 0103 	sbc.w	r1, r1, r3
30001fd4:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30001fd8:	e795      	b.n	30001f06 <erase_nor_flash_partition+0x8e>
        ERROR("flash storage error\n");
30001fda:	f24a 7178 	movw	r1, #42872	; 0xa778
30001fde:	f64b 00b0 	movw	r0, #47280	; 0xb8b0
30001fe2:	f240 22bd 	movw	r2, #701	; 0x2bd
30001fe6:	f2c3 0101 	movt	r1, #12289	; 0x3001
30001fea:	f2c3 0001 	movt	r0, #12289	; 0x3001
30001fee:	f013 fddf 	bl	30015bb0 <_printf>
        return false;
30001ff2:	e753      	b.n	30001e9c <erase_nor_flash_partition+0x24>

30001ff4 <patch_sfs>:
    return 1;
}

static bool patch_sfs(struct partition_device *ptdev, uint8_t *buffer,
                      uint32_t len)
{
30001ff4:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
30001ff8:	4680      	mov	r8, r0
30001ffa:	b09e      	sub	sp, #120	; 0x78
30001ffc:	4614      	mov	r4, r2
30001ffe:	468a      	mov	r10, r1
    bool patched = false;
    const char *dil = "dil";
    const char *dil_bak = "dil_bak";
    struct sfs sfs = {0};
30002000:	4668      	mov	r0, r13
30002002:	2278      	movs	r2, #120	; 0x78
30002004:	2100      	movs	r1, #0
30002006:	f012 ecb4 	blx	30014970 <memset>
    uint64_t dil_ptn = 0;
    uint64_t dil_bak_ptn = 0;
    uint32_t normal_img_base = 0;
    uint32_t backup_img_base = 0;

    if (len < SFS_SIZE || !ptdev || !ptdev->storage) {
3000200a:	f1b8 0f00 	cmp.w	r8, #0
3000200e:	bf18      	it	ne
30002010:	2c7f      	cmpne	r4, #127	; 0x7f
30002012:	bf94      	ite	ls
30002014:	2501      	movls	r5, #1
30002016:	2500      	movhi	r5, #0
30002018:	d946      	bls.n	300020a8 <patch_sfs+0xb4>
3000201a:	f8d8 3000 	ldr.w	r3, [r8]
3000201e:	2b00      	cmp	r3, #0
30002020:	d042      	beq.n	300020a8 <patch_sfs+0xb4>
        return false;
    }

    dil_ptn = ptdev_get_offset(ptdev, dil);
30002022:	f64b 3114 	movw	r1, #47892	; 0xbb14
30002026:	4640      	mov	r0, r8
30002028:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000202c:	f015 ff7e 	bl	30017f2c <ptdev_get_offset>
30002030:	460f      	mov	r7, r1
    dil_bak_ptn = ptdev_get_offset(ptdev, dil_bak);
30002032:	f64b 3118 	movw	r1, #47896	; 0xbb18
    dil_ptn = ptdev_get_offset(ptdev, dil);
30002036:	4606      	mov	r6, r0
    dil_bak_ptn = ptdev_get_offset(ptdev, dil_bak);
30002038:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000203c:	4640      	mov	r0, r8
3000203e:	f015 ff75 	bl	30017f2c <ptdev_get_offset>

    if (!dil_ptn || dil_ptn >= UINT32_MAX
30002042:	f116 32ff 	adds.w	r2, r6, #4294967295	; 0xffffffff
30002046:	f147 33ff 	adc.w	r3, r7, #4294967295	; 0xffffffff
    dil_bak_ptn = ptdev_get_offset(ptdev, dil_bak);
3000204a:	4689      	mov	r9, r1
    if (!dil_ptn || dil_ptn >= UINT32_MAX
3000204c:	2100      	movs	r1, #0
    dil_bak_ptn = ptdev_get_offset(ptdev, dil_bak);
3000204e:	4680      	mov	r8, r0
    if (!dil_ptn || dil_ptn >= UINT32_MAX
30002050:	4299      	cmp	r1, r3
30002052:	f06f 0002 	mvn.w	r0, #2
30002056:	bf08      	it	eq
30002058:	4290      	cmpeq	r0, r2
3000205a:	d307      	bcc.n	3000206c <patch_sfs+0x78>
            || !dil_bak_ptn || dil_bak_ptn >= UINT32_MAX) {
3000205c:	f118 32ff 	adds.w	r2, r8, #4294967295	; 0xffffffff
30002060:	f149 33ff 	adc.w	r3, r9, #4294967295	; 0xffffffff
30002064:	4299      	cmp	r1, r3
30002066:	bf08      	it	eq
30002068:	4290      	cmpeq	r0, r2
3000206a:	d20f      	bcs.n	3000208c <patch_sfs+0x98>
        ERROR("get dil/dil_bak ptn fail\n");
3000206c:	f24a 71f0 	movw	r1, #42992	; 0xa7f0
30002070:	f64b 3020 	movw	r0, #47904	; 0xbb20
30002074:	f240 525d 	movw	r2, #1373	; 0x55d
30002078:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000207c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002080:	f013 fd96 	bl	30015bb0 <_printf>
        crc_val = sfs_crc32(0, buffer, SFS_SIZE - 4);
        PUT_LONG(&buffer[SFS_CRC32_OFFSET], crc_val);
    }

    return patched;
}
30002084:	4628      	mov	r0, r5
30002086:	b01e      	add	sp, #120	; 0x78
30002088:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    if (get_sfs_info(&sfs, buffer, len)) {
3000208c:	4622      	mov	r2, r4
3000208e:	4668      	mov	r0, r13
30002090:	4651      	mov	r1, r10
30002092:	f003 fd47 	bl	30005b24 <get_sfs_info>
30002096:	bbd0      	cbnz	r0, 3000210e <patch_sfs+0x11a>
    normal_img_base = GET_LWORD_FROM_BYTE(&buffer[SFS_NIA_OFFSET]);
30002098:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
    backup_img_base = GET_LWORD_FROM_BYTE(&buffer[SFS_BIA_OFFSET]);
3000209c:	f8da 3074 	ldr.w	r3, [r10, #116]	; 0x74
    if (normal_img_base != (uint32_t)dil_ptn) {
300020a0:	4296      	cmp	r6, r2
300020a2:	d106      	bne.n	300020b2 <patch_sfs+0xbe>
    if (backup_img_base != (uint32_t)dil_bak_ptn) {
300020a4:	4543      	cmp	r3, r8
300020a6:	d112      	bne.n	300020ce <patch_sfs+0xda>
        return false;
300020a8:	2500      	movs	r5, #0
}
300020aa:	4628      	mov	r0, r5
300020ac:	b01e      	add	sp, #120	; 0x78
300020ae:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        PUT_LONG(&buffer[SFS_NIA_OFFSET], (uint32_t)dil_ptn);
300020b2:	0a31      	lsrs	r1, r6, #8
300020b4:	f88a 6070 	strb.w	r6, [r10, #112]	; 0x70
300020b8:	0c32      	lsrs	r2, r6, #16
    if (backup_img_base != (uint32_t)dil_bak_ptn) {
300020ba:	4543      	cmp	r3, r8
        PUT_LONG(&buffer[SFS_NIA_OFFSET], (uint32_t)dil_ptn);
300020bc:	f88a 1071 	strb.w	r1, [r10, #113]	; 0x71
300020c0:	ea4f 6616 	mov.w	r6, r6, lsr #24
300020c4:	f88a 2072 	strb.w	r2, [r10, #114]	; 0x72
300020c8:	f88a 6073 	strb.w	r6, [r10, #115]	; 0x73
    if (backup_img_base != (uint32_t)dil_bak_ptn) {
300020cc:	d00d      	beq.n	300020ea <patch_sfs+0xf6>
        PUT_LONG(&buffer[SFS_BIA_OFFSET], (uint32_t)dil_bak_ptn);
300020ce:	ea4f 2118 	mov.w	r1, r8, lsr #8
300020d2:	ea4f 4218 	mov.w	r2, r8, lsr #16
300020d6:	f88a 8074 	strb.w	r8, [r10, #116]	; 0x74
300020da:	ea4f 6318 	mov.w	r3, r8, lsr #24
300020de:	f88a 1075 	strb.w	r1, [r10, #117]	; 0x75
300020e2:	f88a 2076 	strb.w	r2, [r10, #118]	; 0x76
300020e6:	f88a 3077 	strb.w	r3, [r10, #119]	; 0x77
        crc_val = sfs_crc32(0, buffer, SFS_SIZE - 4);
300020ea:	227c      	movs	r2, #124	; 0x7c
300020ec:	4651      	mov	r1, r10
300020ee:	2000      	movs	r0, #0
        PUT_LONG(&buffer[SFS_CRC32_OFFSET], crc_val);
300020f0:	2501      	movs	r5, #1
        crc_val = sfs_crc32(0, buffer, SFS_SIZE - 4);
300020f2:	f003 fcff 	bl	30005af4 <sfs_crc32>
        PUT_LONG(&buffer[SFS_CRC32_OFFSET], crc_val);
300020f6:	0a01      	lsrs	r1, r0, #8
300020f8:	0c02      	lsrs	r2, r0, #16
300020fa:	f88a 007c 	strb.w	r0, [r10, #124]	; 0x7c
300020fe:	0e03      	lsrs	r3, r0, #24
30002100:	f88a 107d 	strb.w	r1, [r10, #125]	; 0x7d
30002104:	f88a 207e 	strb.w	r2, [r10, #126]	; 0x7e
30002108:	f88a 307f 	strb.w	r3, [r10, #127]	; 0x7f
3000210c:	e7cd      	b.n	300020aa <patch_sfs+0xb6>
        ERROR("there is no available sfs in nor flash\n");
3000210e:	f24a 71f0 	movw	r1, #42992	; 0xa7f0
30002112:	f64b 3048 	movw	r0, #47944	; 0xbb48
30002116:	f240 5262 	movw	r2, #1378	; 0x562
3000211a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000211e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002122:	f013 fd45 	bl	30015bb0 <_printf>
        return false;
30002126:	e7c0      	b.n	300020aa <patch_sfs+0xb6>

30002128 <cmd_reboot_proc>:
    erase_data(fb, arg, data, sz);
}

static void cmd_reboot_proc(fastboot_t *fb, const char *arg, void *data,
                            unsigned sz)
{
30002128:	b510      	push	{r4, r14}
3000212a:	4604      	mov	r4, r0
    uint32_t boot_reason = HALT_REASON_SW_RESET;
    printf("reboot device\n");
3000212c:	f24b 50bc 	movw	r0, #46524	; 0xb5bc
30002130:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002134:	f013 fd3c 	bl	30015bb0 <_printf>
    fastboot_common_okay(fb, "");
30002138:	f64a 71bc 	movw	r1, #44988	; 0xafbc
3000213c:	4620      	mov	r0, r4
3000213e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002142:	f012 fa69 	bl	30014618 <fastboot_common_okay>

    thread_sleep(1000);
30002146:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
3000214a:	f00f ffa1 	bl	30012090 <thread_sleep>
3000214e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
30002152:	2207      	movs	r2, #7
30002154:	f6cf 0341 	movt	r3, #63553	; 0xf841
30002158:	601a      	str	r2, [r3, #0]
    sdrv_common_reg_set_u32(boot_reason, SDRV_REG_BOOTREASON);
    //reboot_device(0);
}
3000215a:	bd10      	pop	{r4, r15}

3000215c <dloader_md5_emmc>:
    ptdev_read_table(ptdev);
    return 0;
}

int dloader_md5_emmc(int argc, const cmd_args *argv)
{
3000215c:	b570      	push	{r4, r5, r6, r14}
3000215e:	460e      	mov	r6, r1
30002160:	b086      	sub	sp, #24
    uint32_t len = 0;
    uint32_t start_addr = 0;
    uint8_t md5_calc[MD5_LEN] = {0};
30002162:	2400      	movs	r4, #0

    start_addr = strtoul(argv[1].str, NULL, 16);
30002164:	2210      	movs	r2, #16
30002166:	4621      	mov	r1, r4
30002168:	6970      	ldr	r0, [r6, #20]
    uint8_t md5_calc[MD5_LEN] = {0};
3000216a:	e9cd 4402 	strd	r4, r4, [r13, #8]
3000216e:	e9cd 4404 	strd	r4, r4, [r13, #16]
    start_addr = strtoul(argv[1].str, NULL, 16);
30002172:	f012 fd37 	bl	30014be4 <strtoul>
    len = strtoul(argv[2].str, NULL, 16);
30002176:	4621      	mov	r1, r4
30002178:	2210      	movs	r2, #16
    start_addr = strtoul(argv[1].str, NULL, 16);
3000217a:	4605      	mov	r5, r0
    len = strtoul(argv[2].str, NULL, 16);
3000217c:	6ab0      	ldr	r0, [r6, #40]	; 0x28
3000217e:	f012 fd31 	bl	30014be4 <strtoul>

    ERROR("start:0x%0x, len:0x%0x\n", start_addr, len);
30002182:	f24a 7110 	movw	r1, #42768	; 0xa710
30002186:	462b      	mov	r3, r5
30002188:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000218c:	f640 42c3 	movw	r2, #3267	; 0xcc3
    len = strtoul(argv[2].str, NULL, 16);
30002190:	4606      	mov	r6, r0
    ERROR("start:0x%0x, len:0x%0x\n", start_addr, len);
30002192:	f24b 7080 	movw	r0, #46976	; 0xb780
30002196:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000219a:	9600      	str	r6, [sp, #0]
3000219c:	f013 fd08 	bl	30015bb0 <_printf>
    md5((unsigned char *)start_addr, len, md5_calc );
300021a0:	4631      	mov	r1, r6
300021a2:	4628      	mov	r0, r5
300021a4:	aa02      	add	r2, sp, #8
300021a6:	f014 f9ef 	bl	30016588 <md5>

#endif /* DISABLE_DEBUG_OUTPUT */

static inline void hexdump8(const void *ptr, size_t len)
{
    hexdump8_ex(ptr, len, (uint64_t)((addr_t)ptr));
300021aa:	4623      	mov	r3, r4
300021ac:	2110      	movs	r1, #16
300021ae:	aa02      	add	r2, sp, #8
300021b0:	4610      	mov	r0, r2
300021b2:	f012 f8bd 	bl	30014330 <hexdump8_ex>
    hexdump8  (md5_calc, MD5_LEN);
    return 0;
}
300021b6:	4620      	mov	r0, r4
300021b8:	b006      	add	sp, #24
300021ba:	bd70      	pop	{r4, r5, r6, r15}

300021bc <parse_partition_name>:
{
300021bc:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    char storage_name[MAX_GPT_NAME_SIZE + 1]  = {0};
300021c0:	2249      	movs	r2, #73	; 0x49
{
300021c2:	b0bd      	sub	sp, #244	; 0xf4
    char storage_name[MAX_GPT_NAME_SIZE + 1]  = {0};
300021c4:	2100      	movs	r1, #0
{
300021c6:	4606      	mov	r6, r0
300021c8:	4677      	mov	r7, r14
    char storage_name[MAX_GPT_NAME_SIZE + 1]  = {0};
300021ca:	a803      	add	r0, sp, #12
300021cc:	f012 ebd0 	blx	30014970 <memset>
    current_dl_state = NULL;
300021d0:	f646 4570 	movw	r5, #27760	; 0x6c70
    char sub_ptbname[MAX_GPT_NAME_SIZE + 1]   = {0};
300021d4:	2100      	movs	r1, #0
300021d6:	2249      	movs	r2, #73	; 0x49
    current_dl_state = NULL;
300021d8:	460c      	mov	r4, r1
300021da:	f2c3 0502 	movt	r5, #12290	; 0x3002
    char sub_ptbname[MAX_GPT_NAME_SIZE + 1]   = {0};
300021de:	a816      	add	r0, sp, #88	; 0x58
300021e0:	f012 ebc6 	blx	30014970 <memset>
    char short_ptname[MAX_GPT_NAME_SIZE + 1]  = {0};
300021e4:	2249      	movs	r2, #73	; 0x49
300021e6:	4621      	mov	r1, r4
300021e8:	a829      	add	r0, sp, #164	; 0xa4
300021ea:	f012 ebc2 	blx	30014970 <memset>
    current_dl_state = NULL;
300021ee:	602c      	str	r4, [r5, #0]
    if (!full_ptname
300021f0:	2e00      	cmp	r6, #0
300021f2:	d046      	beq.n	30002282 <parse_partition_name+0xc6>
            || (full_len = strlen(full_ptname)) == 0) {
300021f4:	4630      	mov	r0, r6
300021f6:	f013 fd9b 	bl	30015d30 <strlen>
300021fa:	4680      	mov	r8, r0
300021fc:	2800      	cmp	r0, #0
300021fe:	d040      	beq.n	30002282 <parse_partition_name+0xc6>
30002200:	1e73      	subs	r3, r6, #1
30002202:	1819      	adds	r1, r3, r0
        if (full_ptname[i] == '$') {
30002204:	f813 2f01 	ldrb.w	r2, [r3, #1]!
30002208:	2a24      	cmp	r2, #36	; 0x24
            token_num++;
3000220a:	bf08      	it	eq
3000220c:	3401      	addeq	r4, #1
    for (uint32_t i = 0; i < full_len; i++) {
3000220e:	428b      	cmp	r3, r1
30002210:	d1f8      	bne.n	30002204 <parse_partition_name+0x48>
    if (token_num != 2) {
30002212:	2c02      	cmp	r4, #2
        return 2;
30002214:	bf18      	it	ne
30002216:	2002      	movne	r0, #2
    if (token_num != 2) {
30002218:	d134      	bne.n	30002284 <parse_partition_name+0xc8>
    token1 = strchr(full_ptname, '$');
3000221a:	2124      	movs	r1, #36	; 0x24
3000221c:	4630      	mov	r0, r6
3000221e:	f013 fd09 	bl	30015c34 <strchr>
    token2 = strrchr(full_ptname, '$');
30002222:	2124      	movs	r1, #36	; 0x24
    token1 = strchr(full_ptname, '$');
30002224:	4681      	mov	r9, r0
    token2 = strrchr(full_ptname, '$');
30002226:	4630      	mov	r0, r6
30002228:	f013 fdde 	bl	30015de8 <strrchr>
    strncpy(storage_name, full_ptname, token1 - full_ptname);
3000222c:	4631      	mov	r1, r6
3000222e:	eba9 0206 	sub.w	r2, r9, r6
    token2 = strrchr(full_ptname, '$');
30002232:	4604      	mov	r4, r0
    strncpy(storage_name, full_ptname, token1 - full_ptname);
30002234:	a803      	add	r0, sp, #12
30002236:	f013 fd87 	bl	30015d48 <strncpy>
    strncpy(sub_ptbname, token1 + 1, token2 - token1 - 1);
3000223a:	eba4 0209 	sub.w	r2, r4, r9
3000223e:	f109 0101 	add.w	r1, r9, #1
30002242:	3a01      	subs	r2, #1
30002244:	f242 1930 	movw	r9, #8496	; 0x2130
30002248:	a816      	add	r0, sp, #88	; 0x58
3000224a:	f013 fd7d 	bl	30015d48 <strncpy>
    strncpy(short_ptname, token2 + 1, full_len - (token2 + 1 - full_ptname));
3000224e:	1c61      	adds	r1, r4, #1
30002250:	1b8a      	subs	r2, r1, r6
30002252:	eba8 0202 	sub.w	r2, r8, r2
30002256:	a829      	add	r0, sp, #164	; 0xa4
30002258:	f013 fd76 	bl	30015d48 <strncpy>
3000225c:	2400      	movs	r4, #0
3000225e:	f2c3 0902 	movt	r9, #12290	; 0x3002
30002262:	f109 0810 	add.w	r8, r9, #16
30002266:	eb08 0604 	add.w	r6, r8, r4
        if (!strcmp(storage_dl_state[i].st_info.storage_name, storage_name)) {
3000226a:	4630      	mov	r0, r6
3000226c:	a903      	add	r1, sp, #12
3000226e:	f013 fced 	bl	30015c4c <strcmp>
30002272:	b150      	cbz	r0, 3000228a <parse_partition_name+0xce>
30002274:	f504 7490 	add.w	r4, r4, #288	; 0x120
    for (uint32_t i = 0;
30002278:	f5b4 6fd8 	cmp.w	r4, #1728	; 0x6c0
3000227c:	d1f3      	bne.n	30002266 <parse_partition_name+0xaa>
        return 3;
3000227e:	2003      	movs	r0, #3
30002280:	e000      	b.n	30002284 <parse_partition_name+0xc8>
        return 1;
30002282:	2001      	movs	r0, #1
}
30002284:	b03d      	add	sp, #244	; 0xf4
30002286:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
            current_dl_state = &storage_dl_state[i];
3000228a:	444c      	add	r4, r9
3000228c:	602c      	str	r4, [r5, #0]
    if (current_dl_state == NULL) {
3000228e:	2c00      	cmp	r4, #0
30002290:	d0f5      	beq.n	3000227e <parse_partition_name+0xc2>
    if (!(current_dl_state->storage)) {
30002292:	68a3      	ldr	r3, [r4, #8]
30002294:	2b00      	cmp	r3, #0
30002296:	d076      	beq.n	30002386 <parse_partition_name+0x1ca>
    if (!(current_dl_state->ptdev)
30002298:	68e3      	ldr	r3, [r4, #12]
3000229a:	2b00      	cmp	r3, #0
3000229c:	d04e      	beq.n	3000233c <parse_partition_name+0x180>
    pt_len      = strlen(ptname);
3000229e:	a829      	add	r0, sp, #164	; 0xa4
300022a0:	f013 fd46 	bl	30015d30 <strlen>
300022a4:	4607      	mov	r7, r0
    sub_ptb_len = strlen(sub_ptbname);
300022a6:	a816      	add	r0, sp, #88	; 0x58
300022a8:	f013 fd42 	bl	30015d30 <strlen>
300022ac:	4606      	mov	r6, r0
    if (!sub_ptb_len && !pt_len) {
300022ae:	ea57 0300 	orrs.w	r3, r7, r0
300022b2:	d03e      	beq.n	30002332 <parse_partition_name+0x176>
    is_whole      = !strcmp(ptname, "all");
300022b4:	f64b 21fc 	movw	r1, #47868	; 0xbafc
300022b8:	a829      	add	r0, sp, #164	; 0xa4
300022ba:	f2c3 0101 	movt	r1, #12289	; 0x3001
300022be:	f013 fcc5 	bl	30015c4c <strcmp>
    is_ptb        = !strcmp(ptname, "partition");
300022c2:	f64b 3100 	movw	r1, #47872	; 0xbb00
300022c6:	f2c3 0101 	movt	r1, #12289	; 0x3001
    is_whole      = !strcmp(ptname, "all");
300022ca:	4680      	mov	r8, r0
    is_ptb        = !strcmp(ptname, "partition");
300022cc:	a829      	add	r0, sp, #164	; 0xa4
300022ce:	f013 fcbd 	bl	30015c4c <strcmp>
    is_sfs        = !strcmp(ptname, SFS_PT_NAME);
300022d2:	f64b 310c 	movw	r1, #47884	; 0xbb0c
300022d6:	f2c3 0101 	movt	r1, #12289	; 0x3001
    is_ptb        = !strcmp(ptname, "partition");
300022da:	4605      	mov	r5, r0
    is_sfs        = !strcmp(ptname, SFS_PT_NAME);
300022dc:	a829      	add	r0, sp, #164	; 0xa4
300022de:	f013 fcb5 	bl	30015c4c <strcmp>
    is_spl        = !strcmp(ptname, SPL_PARTITION_NAME);
300022e2:	f64b 3110 	movw	r1, #47888	; 0xbb10
300022e6:	f2c3 0101 	movt	r1, #12289	; 0x3001
    is_sfs        = !strcmp(ptname, SFS_PT_NAME);
300022ea:	4681      	mov	r9, r0
    is_spl        = !strcmp(ptname, SPL_PARTITION_NAME);
300022ec:	a829      	add	r0, sp, #164	; 0xa4
300022ee:	f013 fcad 	bl	30015c4c <strcmp>
    if (is_ptb) {
300022f2:	2d00      	cmp	r5, #0
300022f4:	d136      	bne.n	30002364 <parse_partition_name+0x1a8>
        return (sub_ptb_len == 0) ? TYPE_PRI_PTB : TYPE_SUB_PTB;
300022f6:	2e00      	cmp	r6, #0
300022f8:	d175      	bne.n	300023e6 <parse_partition_name+0x22a>
    current_dl_state->cur_pt_info.type = parse_pt_type(sub_ptbname,
300022fa:	2301      	movs	r3, #1
300022fc:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
    memset(current_dl_state->cur_pt_info.sub_ptbname, 0x0,
30002300:	2249      	movs	r2, #73	; 0x49
30002302:	f104 0588 	add.w	r5, r4, #136	; 0x88
30002306:	2100      	movs	r1, #0
    memset(current_dl_state->cur_pt_info.ptname, 0x0,
30002308:	34d1      	adds	r4, #209	; 0xd1
    memset(current_dl_state->cur_pt_info.sub_ptbname, 0x0,
3000230a:	4628      	mov	r0, r5
3000230c:	f012 eb30 	blx	30014970 <memset>
    memset(current_dl_state->cur_pt_info.ptname, 0x0,
30002310:	2249      	movs	r2, #73	; 0x49
30002312:	2100      	movs	r1, #0
30002314:	4620      	mov	r0, r4
30002316:	f012 eb2c 	blx	30014970 <memset>
    strncpy(current_dl_state->cur_pt_info.sub_ptbname, sub_ptbname,
3000231a:	4632      	mov	r2, r6
3000231c:	4628      	mov	r0, r5
3000231e:	a916      	add	r1, sp, #88	; 0x58
30002320:	f013 fd12 	bl	30015d48 <strncpy>
    strncpy(current_dl_state->cur_pt_info.ptname, short_ptname, pt_len);
30002324:	463a      	mov	r2, r7
30002326:	4620      	mov	r0, r4
30002328:	a929      	add	r1, sp, #164	; 0xa4
3000232a:	f013 fd0d 	bl	30015d48 <strncpy>
    return 0;
3000232e:	2000      	movs	r0, #0
30002330:	e7a8      	b.n	30002284 <parse_partition_name+0xc8>
    current_dl_state->cur_pt_info.type = parse_pt_type(sub_ptbname,
30002332:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
        return 6;
30002336:	2006      	movs	r0, #6
        current_dl_state = NULL;
30002338:	602b      	str	r3, [r5, #0]
        return 6;
3000233a:	e7a3      	b.n	30002284 <parse_partition_name+0xc8>
            && st_info->ptb_offset != INVALID_PTB_OFFSET) {
3000233c:	e9d6 2316 	ldrd	r2, r3, [r6, #88]	; 0x58
30002340:	1c59      	adds	r1, r3, #1
30002342:	bf08      	it	eq
30002344:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
30002348:	d0a9      	beq.n	3000229e <parse_partition_name+0xe2>
        current_dl_state->ptdev = ptdev_setup(current_dl_state->storage,
3000234a:	68a0      	ldr	r0, [r4, #8]
3000234c:	f016 fb66 	bl	30018a1c <ptdev_setup>
        if (current_dl_state->ptdev) {
30002350:	682b      	ldr	r3, [r5, #0]
        current_dl_state->ptdev = ptdev_setup(current_dl_state->storage,
30002352:	60e0      	str	r0, [r4, #12]
        if (current_dl_state->ptdev) {
30002354:	68dc      	ldr	r4, [r3, #12]
30002356:	2c00      	cmp	r4, #0
30002358:	d05b      	beq.n	30002412 <parse_partition_name+0x256>
            ptdev_read_table(current_dl_state->ptdev);
3000235a:	4620      	mov	r0, r4
3000235c:	f015 fcd4 	bl	30017d08 <ptdev_read_table>
30002360:	682c      	ldr	r4, [r5, #0]
30002362:	e79c      	b.n	3000229e <parse_partition_name+0xe2>
    else if (is_whole && sub_ptb_len == 0) {
30002364:	ea58 0306 	orrs.w	r3, r8, r6
30002368:	d039      	beq.n	300023de <parse_partition_name+0x222>
    else if (is_spl && sub_ptb_len == 0) {
3000236a:	ea50 0306 	orrs.w	r3, r0, r6
3000236e:	d03e      	beq.n	300023ee <parse_partition_name+0x232>
    else if (is_sfs && sub_ptb_len == 0) {
30002370:	ea59 0306 	orrs.w	r3, r9, r6
30002374:	d040      	beq.n	300023f8 <parse_partition_name+0x23c>
        if (sub_ptb_len == 0) {
30002376:	2e00      	cmp	r6, #0
30002378:	d047      	beq.n	3000240a <parse_partition_name+0x24e>
        else if (pt_len == 0) {
3000237a:	2f00      	cmp	r7, #0
3000237c:	d041      	beq.n	30002402 <parse_partition_name+0x246>
    current_dl_state->cur_pt_info.type = parse_pt_type(sub_ptbname,
3000237e:	2304      	movs	r3, #4
30002380:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
30002384:	e7bc      	b.n	30002300 <parse_partition_name+0x144>
        current_dl_state->storage = setup_storage_dev(st_info->type,
30002386:	6e72      	ldr	r2, [r6, #100]	; 0x64
30002388:	e9d6 1013 	ldrd	r1, r0, [r6, #76]	; 0x4c
3000238c:	f016 fc90 	bl	30018cb0 <setup_storage_dev>
        if (current_dl_state->storage) {
30002390:	682b      	ldr	r3, [r5, #0]
        current_dl_state->storage = setup_storage_dev(st_info->type,
30002392:	60a0      	str	r0, [r4, #8]
        if (current_dl_state->storage) {
30002394:	689c      	ldr	r4, [r3, #8]
30002396:	2c00      	cmp	r4, #0
30002398:	f000 8093 	beq.w	300024c2 <parse_partition_name+0x306>
            st_info->block_size = current_dl_state->storage->get_block_size(
3000239c:	6a23      	ldr	r3, [r4, #32]
3000239e:	4620      	mov	r0, r4
300023a0:	4798      	blx	r3
            st_info->erase_grp_sz = current_dl_state->storage->get_erase_group_size(
300023a2:	682b      	ldr	r3, [r5, #0]
300023a4:	689b      	ldr	r3, [r3, #8]
300023a6:	69da      	ldr	r2, [r3, #28]
            st_info->block_size = current_dl_state->storage->get_block_size(
300023a8:	6630      	str	r0, [r6, #96]	; 0x60
            st_info->erase_grp_sz = current_dl_state->storage->get_erase_group_size(
300023aa:	4618      	mov	r0, r3
300023ac:	4790      	blx	r2
            ASSERT(st_info->block_size != 0);
300023ae:	6e33      	ldr	r3, [r6, #96]	; 0x60
            st_info->erase_grp_sz = current_dl_state->storage->get_erase_group_size(
300023b0:	6730      	str	r0, [r6, #112]	; 0x70
            ASSERT(st_info->block_size != 0);
300023b2:	2b00      	cmp	r3, #0
300023b4:	d03d      	beq.n	30002432 <parse_partition_name+0x276>
            ASSERT(st_info->erase_grp_sz != 0);
300023b6:	2800      	cmp	r0, #0
300023b8:	d04d      	beq.n	30002456 <parse_partition_name+0x29a>
            ASSERT(st_info->block_size % 4 == 0);
300023ba:	079c      	lsls	r4, r3, #30
300023bc:	d15d      	bne.n	3000247a <parse_partition_name+0x2be>
            ASSERT(st_info->erase_grp_sz % st_info->block_size == 0);
300023be:	fbb0 f2f3 	udiv	r2, r0, r3
300023c2:	fb03 0312 	mls	r3, r3, r2, r0
300023c6:	2b00      	cmp	r3, #0
300023c8:	d169      	bne.n	3000249e <parse_partition_name+0x2e2>
        if (st_info->type == OSPI) {
300023ca:	6d32      	ldr	r2, [r6, #80]	; 0x50
        storage = current_dl_state->storage;
300023cc:	682c      	ldr	r4, [r5, #0]
        if (st_info->type == OSPI) {
300023ce:	2a01      	cmp	r2, #1
    return st_info->erase_grp_sz * NOR_FLASH_PTB_SECTOR_INDEX;
300023d0:	bf01      	itttt	eq
300023d2:	f8d4 2080 	ldreq.w	r2, [r4, #128]	; 0x80
300023d6:	65f3      	streq	r3, [r6, #92]	; 0x5c
300023d8:	0052      	lsleq	r2, r2, #1
300023da:	65b2      	streq	r2, [r6, #88]	; 0x58
300023dc:	e75c      	b.n	30002298 <parse_partition_name+0xdc>
    current_dl_state->cur_pt_info.type = parse_pt_type(sub_ptbname,
300023de:	2306      	movs	r3, #6
300023e0:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
300023e4:	e78c      	b.n	30002300 <parse_partition_name+0x144>
300023e6:	2303      	movs	r3, #3
300023e8:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
300023ec:	e788      	b.n	30002300 <parse_partition_name+0x144>
300023ee:	f240 1301 	movw	r3, #257	; 0x101
300023f2:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
300023f6:	e783      	b.n	30002300 <parse_partition_name+0x144>
300023f8:	f44f 7381 	mov.w	r3, #258	; 0x102
300023fc:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
30002400:	e77e      	b.n	30002300 <parse_partition_name+0x144>
30002402:	2305      	movs	r3, #5
30002404:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
30002408:	e77a      	b.n	30002300 <parse_partition_name+0x144>
3000240a:	2302      	movs	r3, #2
3000240c:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
30002410:	e776      	b.n	30002300 <parse_partition_name+0x144>
            ERROR("get ptdev:%s error\n", storage_name);
30002412:	f64a 0140 	movw	r1, #43072	; 0xa840
30002416:	f64b 20d8 	movw	r0, #47832	; 0xbad8
3000241a:	ab03      	add	r3, sp, #12
3000241c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002420:	f640 022a 	movw	r2, #2090	; 0x82a
30002424:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002428:	f013 fbc2 	bl	30015bb0 <_printf>
            current_dl_state = NULL;
3000242c:	602c      	str	r4, [r5, #0]
            return 5;
3000242e:	2005      	movs	r0, #5
30002430:	e728      	b.n	30002284 <parse_partition_name+0xc8>
            ASSERT(st_info->block_size != 0);
30002432:	f64b 2328 	movw	r3, #47656	; 0xba28
30002436:	f64b 12f4 	movw	r2, #47604	; 0xb9f4
3000243a:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000243e:	f2c3 0301 	movt	r3, #12289	; 0x3001
30002442:	4638      	mov	r0, r7
30002444:	f2c3 0201 	movt	r2, #12289	; 0x3001
30002448:	9300      	str	r3, [sp, #0]
3000244a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000244e:	f640 030d 	movw	r3, #2061	; 0x80d
30002452:	f011 fedf 	bl	30014214 <_panic>
            ASSERT(st_info->erase_grp_sz != 0);
30002456:	f64b 2344 	movw	r3, #47684	; 0xba44
3000245a:	f64b 12f4 	movw	r2, #47604	; 0xb9f4
3000245e:	f24a 011c 	movw	r1, #40988	; 0xa01c
30002462:	f2c3 0301 	movt	r3, #12289	; 0x3001
30002466:	4638      	mov	r0, r7
30002468:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000246c:	9300      	str	r3, [sp, #0]
3000246e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002472:	f640 030e 	movw	r3, #2062	; 0x80e
30002476:	f011 fecd 	bl	30014214 <_panic>
            ASSERT(st_info->block_size % 4 == 0);
3000247a:	f64b 2360 	movw	r3, #47712	; 0xba60
3000247e:	f64b 12f4 	movw	r2, #47604	; 0xb9f4
30002482:	f24a 011c 	movw	r1, #40988	; 0xa01c
30002486:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000248a:	4638      	mov	r0, r7
3000248c:	f2c3 0201 	movt	r2, #12289	; 0x3001
30002490:	9300      	str	r3, [sp, #0]
30002492:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002496:	f640 030f 	movw	r3, #2063	; 0x80f
3000249a:	f011 febb 	bl	30014214 <_panic>
            ASSERT(st_info->erase_grp_sz % st_info->block_size == 0);
3000249e:	f64b 2380 	movw	r3, #47744	; 0xba80
300024a2:	f64b 12f4 	movw	r2, #47604	; 0xb9f4
300024a6:	f24a 011c 	movw	r1, #40988	; 0xa01c
300024aa:	f2c3 0301 	movt	r3, #12289	; 0x3001
300024ae:	4638      	mov	r0, r7
300024b0:	f2c3 0201 	movt	r2, #12289	; 0x3001
300024b4:	9300      	str	r3, [sp, #0]
300024b6:	f2c3 0101 	movt	r1, #12289	; 0x3001
300024ba:	f44f 6301 	mov.w	r3, #2064	; 0x810
300024be:	f011 fea9 	bl	30014214 <_panic>
            ERROR("get storage:%s error\n", storage_name);
300024c2:	f64a 0140 	movw	r1, #43072	; 0xa840
300024c6:	f64b 20b4 	movw	r0, #47796	; 0xbab4
300024ca:	ab03      	add	r3, sp, #12
300024cc:	f2c3 0101 	movt	r1, #12289	; 0x3001
300024d0:	f640 0213 	movw	r2, #2067	; 0x813
300024d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300024d8:	f013 fb6a 	bl	30015bb0 <_printf>
            current_dl_state = NULL;
300024dc:	602c      	str	r4, [r5, #0]
            return 4;
300024de:	2004      	movs	r0, #4
300024e0:	e6d0      	b.n	30002284 <parse_partition_name+0xc8>
300024e2:	bf00      	nop

300024e4 <dloader_erase>:
    struct partition_device *ptdev = current_dl_state->ptdev;
300024e4:	f646 4370 	movw	r3, #27760	; 0x6c70
    uint8_t buffer[512] = {0};
300024e8:	f44f 7200 	mov.w	r2, #512	; 0x200
    struct partition_device *ptdev = current_dl_state->ptdev;
300024ec:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
300024f0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct partition_device *ptdev = current_dl_state->ptdev;
300024f4:	f8d3 a000 	ldr.w	r10, [r3]
{
300024f8:	f5ad 7d0d 	sub.w	r13, r13, #564	; 0x234
300024fc:	4688      	mov	r8, r1
    uint8_t buffer[512] = {0};
300024fe:	ad0c      	add	r5, sp, #48	; 0x30
30002500:	2100      	movs	r1, #0
30002502:	4628      	mov	r0, r5
    struct partition_device *ptdev = current_dl_state->ptdev;
30002504:	f8da 300c 	ldr.w	r3, [r10, #12]
30002508:	9309      	str	r3, [sp, #36]	; 0x24
    uint8_t buffer[512] = {0};
3000250a:	f012 ea32 	blx	30014970 <memset>
    erase_start = atoull(argv[1].str);
3000250e:	f8d8 0014 	ldr.w	r0, [r8, #20]
    storage = current_dl_state->storage;
30002512:	f8da 4008 	ldr.w	r4, [r10, #8]
    erase_start = atoull(argv[1].str);
30002516:	f012 fb09 	bl	30014b2c <atoull>
    erase_len = strtoul(argv[2].str, NULL, 10);
3000251a:	220a      	movs	r2, #10
    erase_start = atoull(argv[1].str);
3000251c:	4606      	mov	r6, r0
3000251e:	460f      	mov	r7, r1
    erase_len = strtoul(argv[2].str, NULL, 10);
30002520:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
30002524:	2100      	movs	r1, #0
30002526:	f012 fb5d 	bl	30014be4 <strtoul>
    erase_grp_sz = storage->get_erase_group_size(storage);
3000252a:	69e3      	ldr	r3, [r4, #28]
    erase_len = strtoul(argv[2].str, NULL, 10);
3000252c:	4680      	mov	r8, r0
    erase_grp_sz = storage->get_erase_group_size(storage);
3000252e:	4620      	mov	r0, r4
30002530:	4798      	blx	r3
    if (st_info->type == OSPI) {
30002532:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
30002536:	2b01      	cmp	r3, #1
    erase_grp_sz = storage->get_erase_group_size(storage);
30002538:	4681      	mov	r9, r0
    if (st_info->type == OSPI) {
3000253a:	d077      	beq.n	3000262c <dloader_erase+0x148>
3000253c:	46c2      	mov	r10, r8
3000253e:	f04f 0b00 	mov.w	r11, #0
    erase_start = atoull(argv[1].str);
30002542:	e9cd 6706 	strd	r6, r7, [r13, #24]
    if (st_info->type == OSPI) {
30002546:	e9cd ab04 	strd	r10, r11, [r13, #16]
    dprintf(0, "%s start:%llu len:%u erase grp sz:%u\n", __func__, erase_start,
3000254a:	f8cd 9004 	str.w	r9, [r13, #4]
3000254e:	f24a 61dc 	movw	r1, #42716	; 0xa6dc
30002552:	f8cd 8000 	str.w	r8, [r13]
30002556:	f24b 50cc 	movw	r0, #46540	; 0xb5cc
3000255a:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
3000255e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002562:	4642      	mov	r2, r8
30002564:	464b      	mov	r3, r9
30002566:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000256a:	f013 fb21 	bl	30015bb0 <_printf>
    storage->read(storage, erase_start_orig, buffer, erase_len_orig);
3000256e:	e9cd ab02 	strd	r10, r11, [r13, #8]
30002572:	9500      	str	r5, [sp, #0]
30002574:	4632      	mov	r2, r6
30002576:	68a1      	ldr	r1, [r4, #8]
30002578:	463b      	mov	r3, r7
3000257a:	4620      	mov	r0, r4
3000257c:	4788      	blx	r1
3000257e:	462a      	mov	r2, r5
30002580:	2300      	movs	r3, #0
30002582:	2140      	movs	r1, #64	; 0x40
30002584:	4628      	mov	r0, r5
30002586:	f011 fed3 	bl	30014330 <hexdump8_ex>
    if (storage->erase(storage, erase_start, erase_len))
3000258a:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
3000258e:	e9cd 2300 	strd	r2, r3, [r13]
30002592:	4620      	mov	r0, r4
30002594:	4642      	mov	r2, r8
30002596:	464b      	mov	r3, r9
30002598:	6921      	ldr	r1, [r4, #16]
3000259a:	4788      	blx	r1
3000259c:	b148      	cbz	r0, 300025b2 <dloader_erase+0xce>
        dprintf(0, "%s fail to erase\n", __func__);
3000259e:	f24a 61dc 	movw	r1, #42716	; 0xa6dc
300025a2:	f24b 50f4 	movw	r0, #46580	; 0xb5f4
300025a6:	f2c3 0101 	movt	r1, #12289	; 0x3001
300025aa:	f2c3 0001 	movt	r0, #12289	; 0x3001
300025ae:	f013 faff 	bl	30015bb0 <_printf>
    dprintf(0, "%s after erase\n", __func__);
300025b2:	f24a 61dc 	movw	r1, #42716	; 0xa6dc
300025b6:	f24b 6008 	movw	r0, #46600	; 0xb608
300025ba:	f2c3 0101 	movt	r1, #12289	; 0x3001
300025be:	f2c3 0001 	movt	r0, #12289	; 0x3001
300025c2:	f013 faf5 	bl	30015bb0 <_printf>
    storage->read(storage, erase_start_orig, buffer, erase_len_orig);
300025c6:	9500      	str	r5, [sp, #0]
300025c8:	e9cd ab02 	strd	r10, r11, [r13, #8]
300025cc:	4632      	mov	r2, r6
300025ce:	463b      	mov	r3, r7
300025d0:	4620      	mov	r0, r4
300025d2:	68a1      	ldr	r1, [r4, #8]
300025d4:	4788      	blx	r1
300025d6:	462a      	mov	r2, r5
300025d8:	2300      	movs	r3, #0
300025da:	4628      	mov	r0, r5
300025dc:	2140      	movs	r1, #64	; 0x40
300025de:	f011 fea7 	bl	30014330 <hexdump8_ex>
    dprintf(0, "%s re-read gpt\n", __func__);
300025e2:	f24a 61dc 	movw	r1, #42716	; 0xa6dc
300025e6:	f24b 6018 	movw	r0, #46616	; 0xb618
300025ea:	f2c3 0101 	movt	r1, #12289	; 0x3001
300025ee:	f2c3 0001 	movt	r0, #12289	; 0x3001
300025f2:	f013 fadd 	bl	30015bb0 <_printf>
    read_time = current_time_hires();
300025f6:	f7fe f98b 	bl	30000910 <current_time_hires>
300025fa:	4604      	mov	r4, r0
300025fc:	460d      	mov	r5, r1
    ptdev_read_table(ptdev);
300025fe:	9809      	ldr	r0, [sp, #36]	; 0x24
30002600:	f015 fb82 	bl	30017d08 <ptdev_read_table>
    read_time = current_time_hires() - read_time;
30002604:	f7fe f984 	bl	30000910 <current_time_hires>
    dprintf(0, "%s re-read time:%llu\n", __func__, read_time);
30002608:	1b02      	subs	r2, r0, r4
3000260a:	f24b 6028 	movw	r0, #46632	; 0xb628
3000260e:	eb61 0305 	sbc.w	r3, r1, r5
30002612:	f24a 61dc 	movw	r1, #42716	; 0xa6dc
30002616:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000261a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000261e:	f013 fac7 	bl	30015bb0 <_printf>
}
30002622:	2000      	movs	r0, #0
30002624:	f50d 7d0d 	add.w	r13, r13, #564	; 0x234
30002628:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        erase_start = round_down(erase_start, erase_grp_sz);
3000262c:	2200      	movs	r2, #0

static inline uint64_t round_down(uint64_t size, uint64_t aligned)
{
    uint64_t mod = 0;

    if (aligned == 0 || size < aligned)
3000262e:	fab0 f380 	clz	r3, r0
30002632:	4601      	mov	r1, r0
30002634:	4297      	cmp	r7, r2
30002636:	ea4f 1353 	mov.w	r3, r3, lsr #5
3000263a:	e9cd 1204 	strd	r1, r2, [r13, #16]
3000263e:	bf08      	it	eq
30002640:	4286      	cmpeq	r6, r0
30002642:	930a      	str	r3, [sp, #40]	; 0x28
30002644:	bf38      	it	cc
30002646:	f043 0301 	orrcc.w	r3, r3, #1
3000264a:	bb73      	cbnz	r3, 300026aa <dloader_erase+0x1c6>
        return 0;
    /* Sometimes, 'aligned' is not equal to power of 2 */
    mod = size % aligned;
3000264c:	4613      	mov	r3, r2
3000264e:	4639      	mov	r1, r7
30002650:	4602      	mov	r2, r0
30002652:	4630      	mov	r0, r6
30002654:	f017 fbe4 	bl	30019e20 <__aeabi_uldivmod>

    size -= mod;
30002658:	1ab2      	subs	r2, r6, r2
3000265a:	eb67 0303 	sbc.w	r3, r7, r3
3000265e:	e9cd 2306 	strd	r2, r3, [r13, #24]
    if (aligned == 0 || size < aligned)
30002662:	e9dd 1204 	ldrd	r1, r2, [r13, #16]
        erase_len = round_up(erase_len, erase_grp_sz);
30002666:	f04f 0b00 	mov.w	r11, #0
3000266a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
3000266c:	46c2      	mov	r10, r8
3000266e:	4593      	cmp	r11, r2
30002670:	bf08      	it	eq
30002672:	4588      	cmpeq	r8, r1
30002674:	bf38      	it	cc
30002676:	f043 0301 	orrcc.w	r3, r3, #1
3000267a:	b9db      	cbnz	r3, 300026b4 <dloader_erase+0x1d0>
    mod = size % aligned;
3000267c:	4613      	mov	r3, r2
3000267e:	4640      	mov	r0, r8
30002680:	460a      	mov	r2, r1
30002682:	4659      	mov	r1, r11
30002684:	f017 fbcc 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002688:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
3000268c:	4313      	orrs	r3, r2
3000268e:	d013      	beq.n	300026b8 <dloader_erase+0x1d4>
30002690:	e9dd 0104 	ldrd	r0, r1, [r13, #16]
30002694:	2100      	movs	r1, #0
30002696:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
3000269a:	eb10 0008 	adds.w	r0, r0, r8
3000269e:	1a82      	subs	r2, r0, r2
300026a0:	4610      	mov	r0, r2
300026a2:	4690      	mov	r8, r2
300026a4:	e9cd 0104 	strd	r0, r1, [r13, #16]
300026a8:	e74f      	b.n	3000254a <dloader_erase+0x66>
        return 0;
300026aa:	2200      	movs	r2, #0
300026ac:	2300      	movs	r3, #0
300026ae:	e9cd 2306 	strd	r2, r3, [r13, #24]
300026b2:	e7d6      	b.n	30002662 <dloader_erase+0x17e>
    if (aligned == 0 || size < aligned)
300026b4:	46c8      	mov	r8, r9
300026b6:	e748      	b.n	3000254a <dloader_erase+0x66>
    size += mod ? aligned - mod : 0;
300026b8:	e9cd ab04 	strd	r10, r11, [r13, #16]
300026bc:	e745      	b.n	3000254a <dloader_erase+0x66>
300026be:	bf00      	nop

300026c0 <dloader_read>:
{
300026c0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    st_info = &current_dl_state->st_info;
300026c4:	f646 4870 	movw	r8, #27760	; 0x6c70
{
300026c8:	b091      	sub	sp, #68	; 0x44
    uint8_t md5_calc[MD5_LEN] = {0};
300026ca:	2400      	movs	r4, #0
    st_info = &current_dl_state->st_info;
300026cc:	f2c3 0802 	movt	r8, #12290	; 0x3002
{
300026d0:	4689      	mov	r9, r1
    read_back_addr = strtoul(argv[1].str, NULL, 16);
300026d2:	2210      	movs	r2, #16
300026d4:	6948      	ldr	r0, [r1, #20]
300026d6:	4621      	mov	r1, r4
    st_info = &current_dl_state->st_info;
300026d8:	f8d8 b000 	ldr.w	r11, [r8]
    uint8_t md5_calc[MD5_LEN] = {0};
300026dc:	e9cd 440c 	strd	r4, r4, [r13, #48]	; 0x30
300026e0:	e9cd 440e 	strd	r4, r4, [r13, #56]	; 0x38
    read_back_addr = strtoul(argv[1].str, NULL, 16);
300026e4:	f012 fa7e 	bl	30014be4 <strtoul>
    read_chunk_size = strtoul(argv[2].str, NULL, 16);
300026e8:	4621      	mov	r1, r4
300026ea:	2210      	movs	r2, #16
    read_back_addr = strtoul(argv[1].str, NULL, 16);
300026ec:	4607      	mov	r7, r0
    read_chunk_size = strtoul(argv[2].str, NULL, 16);
300026ee:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
    data = (uint8_t *)read_back_addr;
300026f2:	463d      	mov	r5, r7
    read_chunk_size = strtoul(argv[2].str, NULL, 16);
300026f4:	f012 fa76 	bl	30014be4 <strtoul>
    read_total_len = strtoul(argv[3].str, NULL, 16);
300026f8:	4621      	mov	r1, r4
300026fa:	2210      	movs	r2, #16
    read_chunk_size = strtoul(argv[2].str, NULL, 16);
300026fc:	9008      	str	r0, [sp, #32]
300026fe:	4682      	mov	r10, r0
    read_total_len = strtoul(argv[3].str, NULL, 16);
30002700:	f8d9 003c 	ldr.w	r0, [r9, #60]	; 0x3c
30002704:	f012 fa6e 	bl	30014be4 <strtoul>
    ERROR("add:0x%0x, chunk:0x%0x, len:0x%0x\n",
30002708:	f24a 61ec 	movw	r1, #42732	; 0xa6ec
3000270c:	463b      	mov	r3, r7
3000270e:	f640 4274 	movw	r2, #3188	; 0xc74
30002712:	f8cd a000 	str.w	r10, [r13]
30002716:	f2c3 0101 	movt	r1, #12289	; 0x3001
    remain = round_up(read_total_len, st_info->block_size);
3000271a:	2700      	movs	r7, #0
    read_total_len = strtoul(argv[3].str, NULL, 16);
3000271c:	4606      	mov	r6, r0
    ERROR("add:0x%0x, chunk:0x%0x, len:0x%0x\n",
3000271e:	f24b 70a8 	movw	r0, #47016	; 0xb7a8
30002722:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002726:	9601      	str	r6, [sp, #4]
    full_name = argv[4].str;
30002728:	f8d9 4050 	ldr.w	r4, [r9, #80]	; 0x50
    ERROR("add:0x%0x, chunk:0x%0x, len:0x%0x\n",
3000272c:	f013 fa40 	bl	30015bb0 <_printf>
    ptdev = current_dl_state->ptdev;
30002730:	f8d8 3000 	ldr.w	r3, [r8]
    ptn = ptdev_get_offset(ptdev, full_name);
30002734:	4621      	mov	r1, r4
    storage = current_dl_state->storage;
30002736:	e9d3 3002 	ldrd	r3, r0, [r3, #8]
3000273a:	9306      	str	r3, [sp, #24]
    ptn = ptdev_get_offset(ptdev, full_name);
3000273c:	f015 fbf6 	bl	30017f2c <ptdev_get_offset>
    remain = round_up(read_total_len, st_info->block_size);
30002740:	f8db 2070 	ldr.w	r2, [r11, #112]	; 0x70
    ptn = ptdev_get_offset(ptdev, full_name);
30002744:	e9cd 0104 	strd	r0, r1, [r13, #16]
    remain = round_up(read_total_len, st_info->block_size);
30002748:	2100      	movs	r1, #0
3000274a:	4610      	mov	r0, r2
    if (aligned == 0 || size < aligned)
3000274c:	428f      	cmp	r7, r1
3000274e:	bf08      	it	eq
30002750:	4296      	cmpeq	r6, r2
30002752:	bf34      	ite	cc
30002754:	2301      	movcc	r3, #1
30002756:	2300      	movcs	r3, #0
30002758:	2a00      	cmp	r2, #0
3000275a:	bf08      	it	eq
3000275c:	2301      	moveq	r3, #1
3000275e:	b95b      	cbnz	r3, 30002778 <dloader_read+0xb8>
    mod = size % aligned;
30002760:	460b      	mov	r3, r1
30002762:	4630      	mov	r0, r6
30002764:	4639      	mov	r1, r7
30002766:	4690      	mov	r8, r2
30002768:	f017 fb5a 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
3000276c:	ea52 0103 	orrs.w	r1, r2, r3
30002770:	bf08      	it	eq
30002772:	4630      	moveq	r0, r6
30002774:	f040 8084 	bne.w	30002880 <dloader_read+0x1c0>
30002778:	4682      	mov	r10, r0
    while (remain) {
3000277a:	2800      	cmp	r0, #0
3000277c:	d07c      	beq.n	30002878 <dloader_read+0x1b8>
        spin(1000000);
3000277e:	f244 2340 	movw	r3, #16960	; 0x4240
            ERROR("read back success!\n");
30002782:	f24a 62ec 	movw	r2, #42732	; 0xa6ec
30002786:	f24b 71f8 	movw	r1, #47096	; 0xb7f8
        spin(1000000);
3000278a:	f2c0 030f 	movt	r3, #15
            ERROR("read back success!\n");
3000278e:	f2c3 0201 	movt	r2, #12289	; 0x3001
        spin(1000000);
30002792:	9309      	str	r3, [sp, #36]	; 0x24
            ERROR("read back success!\n");
30002794:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002798:	920a      	str	r2, [sp, #40]	; 0x28
3000279a:	910b      	str	r1, [sp, #44]	; 0x2c
3000279c:	e013      	b.n	300027c6 <dloader_read+0x106>
            ERROR("read back error!\n");
3000279e:	f24b 70d8 	movw	r0, #47064	; 0xb7d8
300027a2:	f640 428b 	movw	r2, #3211	; 0xc8b
300027a6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300027aa:	f013 fa01 	bl	30015bb0 <_printf>
        ptn += r_len;
300027ae:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
        data += r_len;
300027b2:	4425      	add	r5, r4
        ptn += r_len;
300027b4:	eb12 0208 	adds.w	r2, r2, r8
300027b8:	eb43 0309 	adc.w	r3, r3, r9
    while (remain) {
300027bc:	ebba 0a04 	subs.w	r10, r10, r4
        ptn += r_len;
300027c0:	e9cd 2304 	strd	r2, r3, [r13, #16]
    while (remain) {
300027c4:	d058      	beq.n	30002878 <dloader_read+0x1b8>
300027c6:	9b08      	ldr	r3, [sp, #32]
        if (storage->read(storage, ptn, data,
300027c8:	f04f 0900 	mov.w	r9, #0
        spin(1000000);
300027cc:	9809      	ldr	r0, [sp, #36]	; 0x24
        if (storage->read(storage, ptn, data,
300027ce:	2700      	movs	r7, #0
300027d0:	4553      	cmp	r3, r10
300027d2:	bf28      	it	cs
300027d4:	4653      	movcs	r3, r10
300027d6:	461c      	mov	r4, r3
        spin(1000000);
300027d8:	f011 fd0a 	bl	300141f0 <spin>
        memset(data, 0x0, r_len);
300027dc:	4622      	mov	r2, r4
300027de:	2100      	movs	r1, #0
300027e0:	4628      	mov	r0, r5
        if (storage->read(storage, ptn, data,
300027e2:	46a0      	mov	r8, r4
        memset(data, 0x0, r_len);
300027e4:	f012 e8c4 	blx	30014970 <memset>
        if (storage->read(storage, ptn, data,
300027e8:	f8db e070 	ldr.w	r14, [r11, #112]	; 0x70
300027ec:	9b06      	ldr	r3, [sp, #24]
    if (aligned == 0 || size < aligned)
300027ee:	45b9      	cmp	r9, r7
300027f0:	4676      	mov	r6, r14
300027f2:	bf08      	it	eq
300027f4:	4574      	cmpeq	r4, r14
300027f6:	bf34      	ite	cc
300027f8:	f04f 0c01 	movcc.w	r12, #1
300027fc:	f04f 0c00 	movcs.w	r12, #0
30002800:	689b      	ldr	r3, [r3, #8]
    mod = size % aligned;
30002802:	4620      	mov	r0, r4
30002804:	9307      	str	r3, [sp, #28]
30002806:	4649      	mov	r1, r9
30002808:	4672      	mov	r2, r14
3000280a:	463b      	mov	r3, r7
    if (aligned == 0 || size < aligned)
3000280c:	f1be 0f00 	cmp.w	r14, #0
30002810:	bf08      	it	eq
30002812:	f04f 0c01 	moveq.w	r12, #1
30002816:	f1bc 0f00 	cmp.w	r12, #0
3000281a:	d10d      	bne.n	30002838 <dloader_read+0x178>
    mod = size % aligned;
3000281c:	f017 fb00 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002820:	ea52 0103 	orrs.w	r1, r2, r3
30002824:	bf04      	itt	eq
30002826:	4626      	moveq	r6, r4
30002828:	464f      	moveq	r7, r9
3000282a:	d005      	beq.n	30002838 <dloader_read+0x178>
3000282c:	1936      	adds	r6, r6, r4
3000282e:	eb47 0709 	adc.w	r7, r7, r9
30002832:	1ab6      	subs	r6, r6, r2
30002834:	eb67 0703 	sbc.w	r7, r7, r3
30002838:	4632      	mov	r2, r6
3000283a:	463b      	mov	r3, r7
3000283c:	9907      	ldr	r1, [sp, #28]
3000283e:	e9cd 2302 	strd	r2, r3, [r13, #8]
30002842:	9500      	str	r5, [sp, #0]
30002844:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
30002848:	9806      	ldr	r0, [sp, #24]
3000284a:	4788      	blx	r1
            ERROR("read back success!\n");
3000284c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
3000284e:	f640 428e 	movw	r2, #3214	; 0xc8e
30002852:	4619      	mov	r1, r3
        if (storage->read(storage, ptn, data,
30002854:	4606      	mov	r6, r0
30002856:	2800      	cmp	r0, #0
30002858:	d1a1      	bne.n	3000279e <dloader_read+0xde>
            ERROR("read back success!\n");
3000285a:	980b      	ldr	r0, [sp, #44]	; 0x2c
3000285c:	f013 f9a8 	bl	30015bb0 <_printf>
            md5((unsigned char *)data, r_len, (unsigned char *)md5_calc);
30002860:	4621      	mov	r1, r4
30002862:	4628      	mov	r0, r5
30002864:	aa0c      	add	r2, sp, #48	; 0x30
30002866:	f013 fe8f 	bl	30016588 <md5>
3000286a:	4633      	mov	r3, r6
3000286c:	2110      	movs	r1, #16
3000286e:	aa0c      	add	r2, sp, #48	; 0x30
30002870:	4610      	mov	r0, r2
30002872:	f011 fd5d 	bl	30014330 <hexdump8_ex>
30002876:	e79a      	b.n	300027ae <dloader_read+0xee>
}
30002878:	2000      	movs	r0, #0
3000287a:	b011      	add	sp, #68	; 0x44
3000287c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30002880:	eb18 0806 	adds.w	r8, r8, r6
30002884:	ebb8 0802 	subs.w	r8, r8, r2
30002888:	4640      	mov	r0, r8
3000288a:	e775      	b.n	30002778 <dloader_read+0xb8>

3000288c <backup_boot>:
    st_info = &current_dl_state->st_info;
3000288c:	f646 4370 	movw	r3, #27760	; 0x6c70
30002890:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30002894:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
                      round_up(EMMC_BOOT_PT_SIZE, st_info->block_size))) {
30002898:	681b      	ldr	r3, [r3, #0]
{
3000289a:	b085      	sub	sp, #20
3000289c:	4606      	mov	r6, r0
    if (storage->read(storage, SD_SPL_OFFSET, buffer,
3000289e:	f04f 0900 	mov.w	r9, #0
300028a2:	6887      	ldr	r7, [r0, #8]
                      round_up(EMMC_BOOT_PT_SIZE, st_info->block_size))) {
300028a4:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    if (storage->read(storage, SD_SPL_OFFSET, buffer,
300028a6:	46a0      	mov	r8, r4
    if (aligned == 0 || size < aligned)
300028a8:	1e63      	subs	r3, r4, #1
300028aa:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
300028ae:	d20e      	bcs.n	300028ce <backup_boot+0x42>
    mod = size % aligned;
300028b0:	464b      	mov	r3, r9
300028b2:	4622      	mov	r2, r4
300028b4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
300028b8:	2100      	movs	r1, #0
300028ba:	f017 fab1 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300028be:	ea52 0103 	orrs.w	r1, r2, r3
300028c2:	bf04      	itt	eq
300028c4:	f44f 2800 	moveq.w	r8, #524288	; 0x80000
300028c8:	f04f 0900 	moveq.w	r9, #0
300028cc:	d10d      	bne.n	300028ea <backup_boot+0x5e>
300028ce:	f04f 534a 	mov.w	r3, #847249408	; 0x32800000
300028d2:	4630      	mov	r0, r6
300028d4:	e9cd 8902 	strd	r8, r9, [r13, #8]
300028d8:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
300028dc:	9300      	str	r3, [sp, #0]
300028de:	2300      	movs	r3, #0
300028e0:	47b8      	blx	r7
300028e2:	b960      	cbnz	r0, 300028fe <backup_boot+0x72>
}
300028e4:	b005      	add	sp, #20
300028e6:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
300028ea:	f518 2400 	adds.w	r4, r8, #524288	; 0x80000
300028ee:	f149 0500 	adc.w	r5, r9, #0
300028f2:	1aa4      	subs	r4, r4, r2
300028f4:	46a0      	mov	r8, r4
300028f6:	eb65 0503 	sbc.w	r5, r5, r3
300028fa:	46a9      	mov	r9, r5
300028fc:	e7e7      	b.n	300028ce <backup_boot+0x42>
        ERROR("read spl error!\n");
300028fe:	f64a 019c 	movw	r1, #43164	; 0xa89c
30002902:	f64a 1098 	movw	r0, #43416	; 0xa998
30002906:	f640 121b 	movw	r2, #2331	; 0x91b
3000290a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000290e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002912:	f013 f94d 	bl	30015bb0 <_printf>
30002916:	2002      	movs	r0, #2
}
30002918:	b005      	add	sp, #20
3000291a:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
3000291e:	bf00      	nop

30002920 <restore_boot>:
    st_info = &current_dl_state->st_info;
30002920:	f646 4370 	movw	r3, #27760	; 0x6c70
30002924:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30002928:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
                       round_up(EMMC_BOOT_PT_SIZE, st_info->block_size))) {
3000292c:	681b      	ldr	r3, [r3, #0]
{
3000292e:	b085      	sub	sp, #20
30002930:	4606      	mov	r6, r0
    if (storage->write(storage, SD_SPL_OFFSET, buffer,
30002932:	f04f 0900 	mov.w	r9, #0
30002936:	68c7      	ldr	r7, [r0, #12]
                       round_up(EMMC_BOOT_PT_SIZE, st_info->block_size))) {
30002938:	6f1c      	ldr	r4, [r3, #112]	; 0x70
    if (storage->write(storage, SD_SPL_OFFSET, buffer,
3000293a:	46a0      	mov	r8, r4
    if (aligned == 0 || size < aligned)
3000293c:	1e63      	subs	r3, r4, #1
3000293e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
30002942:	d20e      	bcs.n	30002962 <restore_boot+0x42>
    mod = size % aligned;
30002944:	464b      	mov	r3, r9
30002946:	4622      	mov	r2, r4
30002948:	f44f 2000 	mov.w	r0, #524288	; 0x80000
3000294c:	2100      	movs	r1, #0
3000294e:	f017 fa67 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002952:	ea52 0103 	orrs.w	r1, r2, r3
30002956:	bf04      	itt	eq
30002958:	f44f 2800 	moveq.w	r8, #524288	; 0x80000
3000295c:	f04f 0900 	moveq.w	r9, #0
30002960:	d10d      	bne.n	3000297e <restore_boot+0x5e>
30002962:	f04f 534a 	mov.w	r3, #847249408	; 0x32800000
30002966:	4630      	mov	r0, r6
30002968:	e9cd 8902 	strd	r8, r9, [r13, #8]
3000296c:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
30002970:	9300      	str	r3, [sp, #0]
30002972:	2300      	movs	r3, #0
30002974:	47b8      	blx	r7
30002976:	b960      	cbnz	r0, 30002992 <restore_boot+0x72>
}
30002978:	b005      	add	sp, #20
3000297a:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
3000297e:	f518 2400 	adds.w	r4, r8, #524288	; 0x80000
30002982:	f149 0500 	adc.w	r5, r9, #0
30002986:	1aa4      	subs	r4, r4, r2
30002988:	46a0      	mov	r8, r4
3000298a:	eb65 0503 	sbc.w	r5, r5, r3
3000298e:	46a9      	mov	r9, r5
30002990:	e7e7      	b.n	30002962 <restore_boot+0x42>
        ERROR("write spl error!\n");
30002992:	f64a 01a8 	movw	r1, #43176	; 0xa8a8
30002996:	f64b 30b4 	movw	r0, #48052	; 0xbbb4
3000299a:	f640 1231 	movw	r2, #2353	; 0x931
3000299e:	f2c3 0101 	movt	r1, #12289	; 0x3001
300029a2:	f2c3 0001 	movt	r0, #12289	; 0x3001
300029a6:	f013 f903 	bl	30015bb0 <_printf>
300029aa:	2002      	movs	r0, #2
}
300029ac:	b005      	add	sp, #20
300029ae:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
300029b2:	bf00      	nop

300029b4 <response_error>:
    if (err < ERR_UNKNOWN || err >= ERR_MAX) {
300029b4:	1e43      	subs	r3, r0, #1
300029b6:	2b17      	cmp	r3, #23
{
300029b8:	b530      	push	{r4, r5, r14}
300029ba:	4604      	mov	r4, r0
300029bc:	b083      	sub	sp, #12
    if (err < ERR_UNKNOWN || err >= ERR_MAX) {
300029be:	d819      	bhi.n	300029f4 <response_error+0x40>
    info = err_info[err];
300029c0:	f64b 05d4 	movw	r5, #47316	; 0xb8d4
    snprintf(err_response, sizeof(err_response), "%04x:%s - %s", err, info,
300029c4:	f64b 32a4 	movw	r2, #48036	; 0xbba4
300029c8:	9101      	str	r1, [sp, #4]
    info = err_info[err];
300029ca:	f2c3 0501 	movt	r5, #12289	; 0x3001
    snprintf(err_response, sizeof(err_response), "%04x:%s - %s", err, info,
300029ce:	f646 4078 	movw	r0, #27768	; 0x6c78
300029d2:	f2c3 0201 	movt	r2, #12289	; 0x3001
300029d6:	4623      	mov	r3, r4
300029d8:	f2c3 0002 	movt	r0, #12290	; 0x3002
300029dc:	f855 1024 	ldr.w	r1, [r5, r4, lsl #2]
300029e0:	9100      	str	r1, [sp, #0]
300029e2:	2140      	movs	r1, #64	; 0x40
300029e4:	f013 f874 	bl	30015ad0 <snprintf>
    return err_response;
300029e8:	f646 4078 	movw	r0, #27768	; 0x6c78
300029ec:	f2c3 0002 	movt	r0, #12290	; 0x3002
}
300029f0:	b003      	add	sp, #12
300029f2:	bd30      	pop	{r4, r5, r15}
        ERROR("unknown error code:%d\n", err);
300029f4:	f24a 7124 	movw	r1, #42788	; 0xa724
300029f8:	f64b 3080 	movw	r0, #48000	; 0xbb80
300029fc:	4623      	mov	r3, r4
300029fe:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002a02:	f240 1265 	movw	r2, #357	; 0x165
30002a06:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002a0a:	f013 f8d1 	bl	30015bb0 <_printf>
30002a0e:	2000      	movs	r0, #0
30002a10:	e7ee      	b.n	300029f0 <response_error+0x3c>
30002a12:	bf00      	nop

30002a14 <erase_emmc_one_boot_area>:
{
30002a14:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    ptname = current_dl_state->cur_pt_info.ptname;
30002a18:	f646 4470 	movw	r4, #27760	; 0x6c70
{
30002a1c:	b0a8      	sub	sp, #160	; 0xa0
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002a1e:	2292      	movs	r2, #146	; 0x92
    ptname = current_dl_state->cur_pt_info.ptname;
30002a20:	f2c3 0402 	movt	r4, #12290	; 0x3002
{
30002a24:	4607      	mov	r7, r0
30002a26:	4688      	mov	r8, r1
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002a28:	2100      	movs	r1, #0
30002a2a:	a803      	add	r0, sp, #12
30002a2c:	f011 efa0 	blx	30014970 <memset>
    ptname = current_dl_state->cur_pt_info.ptname;
30002a30:	6825      	ldr	r5, [r4, #0]
    snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
30002a32:	f240 52e4 	movw	r2, #1508	; 0x5e4
30002a36:	a803      	add	r0, sp, #12
30002a38:	f105 03d1 	add.w	r3, r5, #209	; 0xd1
30002a3c:	2192      	movs	r1, #146	; 0x92
30002a3e:	f2c3 0202 	movt	r2, #12290	; 0x3002
    storage = current_dl_state->storage;
30002a42:	68ae      	ldr	r6, [r5, #8]
    snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
30002a44:	f013 f844 	bl	30015ad0 <snprintf>
    if (!st_info->boot_offset) {
30002a48:	e9d5 231e 	ldrd	r2, r3, [r5, #120]	; 0x78
30002a4c:	4313      	orrs	r3, r2
30002a4e:	d104      	bne.n	30002a5a <erase_emmc_one_boot_area+0x46>
        ret = storage->switch_part(storage, part_num);
30002a50:	4641      	mov	r1, r8
30002a52:	4630      	mov	r0, r6
30002a54:	6973      	ldr	r3, [r6, #20]
30002a56:	4798      	blx	r3
        if (ret) {
30002a58:	bb68      	cbnz	r0, 30002ab6 <erase_emmc_one_boot_area+0xa2>
    st_info = &current_dl_state->st_info;
30002a5a:	f8d4 8000 	ldr.w	r8, [r4]
    if (storage->erase(storage, ptn, round_up(size, st_info->block_size))) {
30002a5e:	f04f 0a00 	mov.w	r10, #0
30002a62:	f8d8 4070 	ldr.w	r4, [r8, #112]	; 0x70
30002a66:	46a1      	mov	r9, r4
    if (aligned == 0 || size < aligned)
30002a68:	1e63      	subs	r3, r4, #1
30002a6a:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
30002a6e:	d217      	bcs.n	30002aa0 <erase_emmc_one_boot_area+0x8c>
    mod = size % aligned;
30002a70:	4653      	mov	r3, r10
30002a72:	4622      	mov	r2, r4
30002a74:	f44f 2000 	mov.w	r0, #524288	; 0x80000
30002a78:	2100      	movs	r1, #0
30002a7a:	f017 f9d1 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002a7e:	ea52 0103 	orrs.w	r1, r2, r3
30002a82:	bf04      	itt	eq
30002a84:	f44f 2900 	moveq.w	r9, #524288	; 0x80000
30002a88:	f04f 0a00 	moveq.w	r10, #0
30002a8c:	d008      	beq.n	30002aa0 <erase_emmc_one_boot_area+0x8c>
30002a8e:	f519 2400 	adds.w	r4, r9, #524288	; 0x80000
30002a92:	f14a 0500 	adc.w	r5, r10, #0
30002a96:	1aa4      	subs	r4, r4, r2
30002a98:	46a1      	mov	r9, r4
30002a9a:	eb65 0503 	sbc.w	r5, r5, r3
30002a9e:	46aa      	mov	r10, r5
30002aa0:	e9d8 231e 	ldrd	r2, r3, [r8, #120]	; 0x78
30002aa4:	4630      	mov	r0, r6
30002aa6:	e9cd 9a00 	strd	r9, r10, [r13]
30002aaa:	6931      	ldr	r1, [r6, #16]
30002aac:	4788      	blx	r1
30002aae:	b9d0      	cbnz	r0, 30002ae6 <erase_emmc_one_boot_area+0xd2>
}
30002ab0:	b028      	add	sp, #160	; 0xa0
30002ab2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            ERROR("switch partition error!\n");
30002ab6:	f64a 0168 	movw	r1, #43112	; 0xa868
30002aba:	f64b 003c 	movw	r0, #47164	; 0xb83c
30002abe:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002ac2:	f640 02b3 	movw	r2, #2227	; 0x8b3
30002ac6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002aca:	f013 f871 	bl	30015bb0 <_printf>
    fastboot_common_fail(fb, response_error(err, full_ptname));
30002ace:	200a      	movs	r0, #10
30002ad0:	a903      	add	r1, sp, #12
30002ad2:	f7ff ff6f 	bl	300029b4 <response_error>
30002ad6:	4601      	mov	r1, r0
30002ad8:	4638      	mov	r0, r7
30002ada:	f011 fda1 	bl	30014620 <fastboot_common_fail>
    return 1;
30002ade:	2001      	movs	r0, #1
}
30002ae0:	b028      	add	sp, #160	; 0xa0
30002ae2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        ERROR(" erase data error!\n");
30002ae6:	f64a 0168 	movw	r1, #43112	; 0xa868
30002aea:	f64b 0064 	movw	r0, #47204	; 0xb864
30002aee:	f640 02c2 	movw	r2, #2242	; 0x8c2
30002af2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002af6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002afa:	f013 f859 	bl	30015bb0 <_printf>
        goto fail;
30002afe:	e7e6      	b.n	30002ace <erase_emmc_one_boot_area+0xba>

30002b00 <erase_boot_areas>:
    struct storage_info *st_info = &current_dl_state->st_info;
30002b00:	f646 4370 	movw	r3, #27760	; 0x6c70
30002b04:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30002b08:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct storage_info *st_info = &current_dl_state->st_info;
30002b0c:	681c      	ldr	r4, [r3, #0]
{
30002b0e:	b083      	sub	sp, #12
30002b10:	4606      	mov	r6, r0
    if (st_info->type == MMC) {
30002b12:	6e23      	ldr	r3, [r4, #96]	; 0x60
30002b14:	b133      	cbz	r3, 30002b24 <erase_boot_areas+0x24>
    else if (st_info->type == OSPI) {
30002b16:	2b01      	cmp	r3, #1
30002b18:	d015      	beq.n	30002b46 <erase_boot_areas+0x46>
    uint32_t ret = 0;
30002b1a:	2500      	movs	r5, #0
}
30002b1c:	4628      	mov	r0, r5
30002b1e:	b003      	add	sp, #12
30002b20:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ret = erase_emmc_one_boot_area(fb, PART_ACCESS_BOOT1);
30002b24:	2101      	movs	r1, #1
30002b26:	f7ff ff75 	bl	30002a14 <erase_emmc_one_boot_area>
    if (!st_info->boot_offset)
30002b2a:	e9d4 231e 	ldrd	r2, r3, [r4, #120]	; 0x78
30002b2e:	4313      	orrs	r3, r2
    ret = erase_emmc_one_boot_area(fb, PART_ACCESS_BOOT1);
30002b30:	4605      	mov	r5, r0
    if (!st_info->boot_offset)
30002b32:	d1f3      	bne.n	30002b1c <erase_boot_areas+0x1c>
        ret |= erase_emmc_one_boot_area(fb, PART_ACCESS_BOOT2);
30002b34:	4630      	mov	r0, r6
30002b36:	2102      	movs	r1, #2
30002b38:	f7ff ff6c 	bl	30002a14 <erase_emmc_one_boot_area>
30002b3c:	4305      	orrs	r5, r0
}
30002b3e:	4628      	mov	r0, r5
30002b40:	b003      	add	sp, #12
30002b42:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    enum pt_type  pttype = current_dl_state->cur_pt_info.type;
30002b46:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
    if (pttype != TYPE_SAFETY_SFS_PT && pttype != TYPE_ALL_PT) {
30002b4a:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
30002b4e:	bf18      	it	ne
30002b50:	2b06      	cmpne	r3, #6
30002b52:	d137      	bne.n	30002bc4 <erase_boot_areas+0xc4>
    if (storage->erase(storage, ptn, round_up(size, st_info->erase_grp_sz))) {
30002b54:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
30002b58:	f04f 0b00 	mov.w	r11, #0
    storage = current_dl_state->storage;
30002b5c:	68a5      	ldr	r5, [r4, #8]
    if (storage->erase(storage, ptn, round_up(size, st_info->erase_grp_sz))) {
30002b5e:	469a      	mov	r10, r3
    if (aligned == 0 || size < aligned)
30002b60:	1e5a      	subs	r2, r3, #1
30002b62:	2a7f      	cmp	r2, #127	; 0x7f
30002b64:	692f      	ldr	r7, [r5, #16]
30002b66:	d817      	bhi.n	30002b98 <erase_boot_areas+0x98>
    mod = size % aligned;
30002b68:	461a      	mov	r2, r3
30002b6a:	2080      	movs	r0, #128	; 0x80
30002b6c:	465b      	mov	r3, r11
30002b6e:	2100      	movs	r1, #0
30002b70:	f017 f956 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002b74:	ea52 0103 	orrs.w	r1, r2, r3
30002b78:	bf04      	itt	eq
30002b7a:	f04f 0a80 	moveq.w	r10, #128	; 0x80
30002b7e:	f04f 0b00 	moveq.w	r11, #0
30002b82:	d009      	beq.n	30002b98 <erase_boot_areas+0x98>
30002b84:	f11a 0880 	adds.w	r8, r10, #128	; 0x80
30002b88:	f14b 0900 	adc.w	r9, r11, #0
30002b8c:	ebb8 0802 	subs.w	r8, r8, r2
30002b90:	46c2      	mov	r10, r8
30002b92:	eb69 0903 	sbc.w	r9, r9, r3
30002b96:	46cb      	mov	r11, r9
30002b98:	e9cd ab00 	strd	r10, r11, [r13]
30002b9c:	4628      	mov	r0, r5
30002b9e:	2200      	movs	r2, #0
30002ba0:	2300      	movs	r3, #0
30002ba2:	47b8      	blx	r7
30002ba4:	2800      	cmp	r0, #0
30002ba6:	d0b8      	beq.n	30002b1a <erase_boot_areas+0x1a>
        ERROR(" erase data error!\n");
30002ba8:	f64a 0184 	movw	r1, #43140	; 0xa884
30002bac:	f64b 0064 	movw	r0, #47204	; 0xb864
30002bb0:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002bb4:	f640 02f8 	movw	r2, #2296	; 0x8f8
30002bb8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002bbc:	f012 fff8 	bl	30015bb0 <_printf>
        err = ERR_PT_ERASE_FAIL;
30002bc0:	200a      	movs	r0, #10
30002bc2:	e00c      	b.n	30002bde <erase_boot_areas+0xde>
        ERROR("pttype:%d error!\n", pttype);
30002bc4:	f64a 0184 	movw	r1, #43140	; 0xa884
30002bc8:	f64b 001c 	movw	r0, #47132	; 0xb81c
30002bcc:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002bd0:	f640 02ee 	movw	r2, #2286	; 0x8ee
30002bd4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002bd8:	f012 ffea 	bl	30015bb0 <_printf>
        err = ERR_PT_NOT_FOUND;
30002bdc:	2004      	movs	r0, #4
        ret = erase_ospi_boot_areas(fb);
30002bde:	2500      	movs	r5, #0
    fastboot_common_fail(fb, response_error(err, ptname));
30002be0:	f104 01d1 	add.w	r1, r4, #209	; 0xd1
30002be4:	f7ff fee6 	bl	300029b4 <response_error>
30002be8:	4601      	mov	r1, r0
30002bea:	4630      	mov	r0, r6
30002bec:	f011 fd18 	bl	30014620 <fastboot_common_fail>
    return ret;
30002bf0:	e794      	b.n	30002b1c <erase_boot_areas+0x1c>
30002bf2:	bf00      	nop

30002bf4 <flash_emmc_one_boot_area>:
{
30002bf4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30002bf8:	460d      	mov	r5, r1
30002bfa:	b0b7      	sub	sp, #220	; 0xdc
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002bfc:	2100      	movs	r1, #0
{
30002bfe:	4691      	mov	r9, r2
30002c00:	9005      	str	r0, [sp, #20]
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002c02:	2292      	movs	r2, #146	; 0x92
{
30002c04:	4698      	mov	r8, r3
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002c06:	a811      	add	r0, sp, #68	; 0x44
30002c08:	f011 eeb2 	blx	30014970 <memset>
    st_info = &current_dl_state->st_info;
30002c0c:	f646 4370 	movw	r3, #27760	; 0x6c70
    uint8_t md5_calc[MD5_LEN] = {0};
30002c10:	2600      	movs	r6, #0
    st_info = &current_dl_state->st_info;
30002c12:	f2c3 0302 	movt	r3, #12290	; 0x3002
    snprintf(full_ptname, sizeof(full_ptname), "%s",
30002c16:	f240 52e4 	movw	r2, #1508	; 0x5e4
30002c1a:	a811      	add	r0, sp, #68	; 0x44
30002c1c:	2192      	movs	r1, #146	; 0x92
30002c1e:	f2c3 0202 	movt	r2, #12290	; 0x3002
    st_info = &current_dl_state->st_info;
30002c22:	681c      	ldr	r4, [r3, #0]
    uint8_t md5_calc[MD5_LEN] = {0};
30002c24:	960e      	str	r6, [sp, #56]	; 0x38
30002c26:	960d      	str	r6, [sp, #52]	; 0x34
    snprintf(full_ptname, sizeof(full_ptname), "%s",
30002c28:	f104 03d1 	add.w	r3, r4, #209	; 0xd1
    uint8_t md5_calc[MD5_LEN] = {0};
30002c2c:	e9cd 660f 	strd	r6, r6, [r13, #60]	; 0x3c
    snprintf(full_ptname, sizeof(full_ptname), "%s",
30002c30:	f012 ff4e 	bl	30015ad0 <snprintf>
    if (!st_info->boot_offset && storage->switch_part(storage, part_num)) {
30002c34:	e9d4 671e 	ldrd	r6, r7, [r4, #120]	; 0x78
30002c38:	ea56 0307 	orrs.w	r3, r6, r7
30002c3c:	d108      	bne.n	30002c50 <flash_emmc_one_boot_area+0x5c>
30002c3e:	696b      	ldr	r3, [r5, #20]
30002c40:	4628      	mov	r0, r5
30002c42:	9940      	ldr	r1, [sp, #256]	; 0x100
30002c44:	4798      	blx	r3
30002c46:	2800      	cmp	r0, #0
30002c48:	f040 80af 	bne.w	30002daa <flash_emmc_one_boot_area+0x1b6>
30002c4c:	e9d4 671e 	ldrd	r6, r7, [r4, #120]	; 0x78
    if (round_up(sz, st_info->block_size) > size) {
30002c50:	6f22      	ldr	r2, [r4, #112]	; 0x70
30002c52:	2100      	movs	r1, #0
30002c54:	f04f 0b00 	mov.w	r11, #0
30002c58:	4640      	mov	r0, r8
30002c5a:	4692      	mov	r10, r2
    if (aligned == 0 || size < aligned)
30002c5c:	4559      	cmp	r1, r11
30002c5e:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30002c62:	bf08      	it	eq
30002c64:	4590      	cmpeq	r8, r2
30002c66:	bf34      	ite	cc
30002c68:	2301      	movcc	r3, #1
30002c6a:	2300      	movcs	r3, #0
30002c6c:	e9cd ab06 	strd	r10, r11, [r13, #24]
30002c70:	2a00      	cmp	r2, #0
30002c72:	bf08      	it	eq
30002c74:	2301      	moveq	r3, #1
30002c76:	e9cd 0108 	strd	r0, r1, [r13, #32]
30002c7a:	2b00      	cmp	r3, #0
30002c7c:	f000 8081 	beq.w	30002d82 <flash_emmc_one_boot_area+0x18e>
30002c80:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30002c84:	2300      	movs	r3, #0
30002c86:	f44f 2200 	mov.w	r2, #524288	; 0x80000
30002c8a:	428b      	cmp	r3, r1
30002c8c:	bf08      	it	eq
30002c8e:	4282      	cmpeq	r2, r0
30002c90:	f0c0 80da 	bcc.w	30002e48 <flash_emmc_one_boot_area+0x254>
    else if (storage->write(storage, ptn, (uint8_t *)data,
30002c94:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
30002c98:	4628      	mov	r0, r5
30002c9a:	e9cd 2302 	strd	r2, r3, [r13, #8]
30002c9e:	4632      	mov	r2, r6
30002ca0:	f8cd 9000 	str.w	r9, [r13]
30002ca4:	463b      	mov	r3, r7
30002ca6:	68e9      	ldr	r1, [r5, #12]
30002ca8:	4788      	blx	r1
30002caa:	2800      	cmp	r0, #0
30002cac:	f040 8095 	bne.w	30002dda <flash_emmc_one_boot_area+0x1e6>
    if (do_md5_check) {
30002cb0:	f646 4374 	movw	r3, #27764	; 0x6c74
30002cb4:	f2c3 0302 	movt	r3, #12290	; 0x3002
30002cb8:	781b      	ldrb	r3, [r3, #0]
30002cba:	2b00      	cmp	r3, #0
30002cbc:	f000 80a8 	beq.w	30002e10 <flash_emmc_one_boot_area+0x21c>
30002cc0:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
        if (storage->read(storage, ptn,
30002cc4:	f04f 0a00 	mov.w	r10, #0
30002cc8:	6f22      	ldr	r2, [r4, #112]	; 0x70
30002cca:	46d4      	mov	r12, r10
30002ccc:	68ac      	ldr	r4, [r5, #8]
30002cce:	4551      	cmp	r1, r10
30002cd0:	4691      	mov	r9, r2
30002cd2:	bf08      	it	eq
30002cd4:	4290      	cmpeq	r0, r2
30002cd6:	bf34      	ite	cc
30002cd8:	2301      	movcc	r3, #1
30002cda:	2300      	movcs	r3, #0
30002cdc:	4693      	mov	r11, r2
30002cde:	2a00      	cmp	r2, #0
30002ce0:	bf08      	it	eq
30002ce2:	2301      	moveq	r3, #1
30002ce4:	b98b      	cbnz	r3, 30002d0a <flash_emmc_one_boot_area+0x116>
    mod = size % aligned;
30002ce6:	4653      	mov	r3, r10
30002ce8:	f017 f89a 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002cec:	ea52 0103 	orrs.w	r1, r2, r3
30002cf0:	f000 8097 	beq.w	30002e22 <flash_emmc_one_boot_area+0x22e>
30002cf4:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30002cf8:	eb10 0009 	adds.w	r0, r0, r9
30002cfc:	eb41 010a 	adc.w	r1, r1, r10
30002d00:	1a80      	subs	r0, r0, r2
30002d02:	4683      	mov	r11, r0
30002d04:	eb61 0103 	sbc.w	r1, r1, r3
30002d08:	468c      	mov	r12, r1
30002d0a:	4658      	mov	r0, r11
30002d0c:	f04f 594a 	mov.w	r9, #847249408	; 0x32800000
30002d10:	4661      	mov	r1, r12
30002d12:	4632      	mov	r2, r6
30002d14:	f8cd 9000 	str.w	r9, [r13]
30002d18:	463b      	mov	r3, r7
30002d1a:	e9cd 0102 	strd	r0, r1, [r13, #8]
30002d1e:	4628      	mov	r0, r5
30002d20:	47a0      	blx	r4
30002d22:	2800      	cmp	r0, #0
30002d24:	d168      	bne.n	30002df8 <flash_emmc_one_boot_area+0x204>
            md5((unsigned char *)_ioaddr(SPARSE_DATA_ALIGNED_BASE), sz,
30002d26:	4641      	mov	r1, r8
30002d28:	aa0d      	add	r2, sp, #52	; 0x34
30002d2a:	4648      	mov	r0, r9
30002d2c:	f013 fc2c 	bl	30016588 <md5>
            if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30002d30:	9a0d      	ldr	r2, [sp, #52]	; 0x34
30002d32:	f646 43f8 	movw	r3, #27896	; 0x6cf8
30002d36:	f2c3 0302 	movt	r3, #12290	; 0x3002
30002d3a:	6819      	ldr	r1, [r3, #0]
30002d3c:	4291      	cmp	r1, r2
30002d3e:	d075      	beq.n	30002e2c <flash_emmc_one_boot_area+0x238>
                ERROR("md5 check fail!\n");
30002d40:	f24a 71ac 	movw	r1, #42924	; 0xa7ac
30002d44:	f64b 10a8 	movw	r0, #47528	; 0xb9a8
30002d48:	f240 42a1 	movw	r2, #1185	; 0x4a1
30002d4c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002d50:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002d54:	f012 ff2c 	bl	30015bb0 <_printf>
30002d58:	f646 42f8 	movw	r2, #27896	; 0x6cf8
30002d5c:	2300      	movs	r3, #0
30002d5e:	f2c3 0202 	movt	r2, #12290	; 0x3002
30002d62:	4610      	mov	r0, r2
30002d64:	2110      	movs	r1, #16
30002d66:	f011 fae3 	bl	30014330 <hexdump8_ex>
30002d6a:	2110      	movs	r1, #16
30002d6c:	2300      	movs	r3, #0
30002d6e:	aa0d      	add	r2, sp, #52	; 0x34
30002d70:	4610      	mov	r0, r2
30002d72:	f011 fadd 	bl	30014330 <hexdump8_ex>
                fastboot_common_fail(fb, response_error(ERR_HASH_FAIL, ""));
30002d76:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30002d7a:	2016      	movs	r0, #22
30002d7c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002d80:	e021      	b.n	30002dc6 <flash_emmc_one_boot_area+0x1d2>
    mod = size % aligned;
30002d82:	465b      	mov	r3, r11
30002d84:	468b      	mov	r11, r1
30002d86:	f017 f84b 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30002d8a:	ea52 0103 	orrs.w	r1, r2, r3
30002d8e:	d043      	beq.n	30002e18 <flash_emmc_one_boot_area+0x224>
30002d90:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30002d94:	eb10 0008 	adds.w	r0, r0, r8
30002d98:	eb41 010b 	adc.w	r1, r1, r11
30002d9c:	ebb0 0a02 	subs.w	r10, r0, r2
30002da0:	eb61 0b03 	sbc.w	r11, r1, r3
30002da4:	e9cd ab06 	strd	r10, r11, [r13, #24]
30002da8:	e76a      	b.n	30002c80 <flash_emmc_one_boot_area+0x8c>
        ERROR("switch boot partition fail!\n");
30002daa:	f24a 71ac 	movw	r1, #42924	; 0xa7ac
30002dae:	f64b 1038 	movw	r0, #47416	; 0xb938
30002db2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002db6:	f240 427c 	movw	r2, #1148	; 0x47c
30002dba:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002dbe:	f012 fef7 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, full_ptname));
30002dc2:	2009      	movs	r0, #9
30002dc4:	a911      	add	r1, sp, #68	; 0x44
                fastboot_common_fail(fb, response_error(ERR_HASH_FAIL, ""));
30002dc6:	f7ff fdf5 	bl	300029b4 <response_error>
30002dca:	4601      	mov	r1, r0
30002dcc:	9805      	ldr	r0, [sp, #20]
30002dce:	f011 fc27 	bl	30014620 <fastboot_common_fail>
                return 1;
30002dd2:	2001      	movs	r0, #1
}
30002dd4:	b037      	add	sp, #220	; 0xdc
30002dd6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ERROR("write emmc error!\n");
30002dda:	f24a 71ac 	movw	r1, #42924	; 0xa7ac
30002dde:	f64b 1088 	movw	r0, #47496	; 0xb988
30002de2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002de6:	f44f 6292 	mov.w	r2, #1168	; 0x490
30002dea:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002dee:	f012 fedf 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, full_ptname));
30002df2:	2009      	movs	r0, #9
30002df4:	a911      	add	r1, sp, #68	; 0x44
30002df6:	e7e6      	b.n	30002dc6 <flash_emmc_one_boot_area+0x1d2>
            ERROR("read back error!\n");
30002df8:	f24a 71ac 	movw	r1, #42924	; 0xa7ac
30002dfc:	f24b 70d8 	movw	r0, #47064	; 0xb7d8
30002e00:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002e04:	f240 4299 	movw	r2, #1177	; 0x499
30002e08:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002e0c:	f012 fed0 	bl	30015bb0 <_printf>
    return 0;
30002e10:	2000      	movs	r0, #0
}
30002e12:	b037      	add	sp, #220	; 0xdc
30002e14:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30002e18:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30002e1c:	e9cd 2306 	strd	r2, r3, [r13, #24]
30002e20:	e72e      	b.n	30002c80 <flash_emmc_one_boot_area+0x8c>
30002e22:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30002e26:	4693      	mov	r11, r2
30002e28:	469c      	mov	r12, r3
30002e2a:	e76e      	b.n	30002d0a <flash_emmc_one_boot_area+0x116>
            if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30002e2c:	6859      	ldr	r1, [r3, #4]
30002e2e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30002e30:	4291      	cmp	r1, r2
30002e32:	d185      	bne.n	30002d40 <flash_emmc_one_boot_area+0x14c>
30002e34:	6899      	ldr	r1, [r3, #8]
30002e36:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
30002e38:	4291      	cmp	r1, r2
30002e3a:	d181      	bne.n	30002d40 <flash_emmc_one_boot_area+0x14c>
30002e3c:	68da      	ldr	r2, [r3, #12]
30002e3e:	9b10      	ldr	r3, [sp, #64]	; 0x40
30002e40:	429a      	cmp	r2, r3
30002e42:	f47f af7d 	bne.w	30002d40 <flash_emmc_one_boot_area+0x14c>
30002e46:	e7e3      	b.n	30002e10 <flash_emmc_one_boot_area+0x21c>
        ERROR("boot image too large!\n");
30002e48:	f24a 71ac 	movw	r1, #42924	; 0xa7ac
30002e4c:	f64b 1064 	movw	r0, #47460	; 0xb964
30002e50:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002e54:	f240 4289 	movw	r2, #1161	; 0x489
30002e58:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002e5c:	f012 fea8 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, full_ptname));
30002e60:	2005      	movs	r0, #5
30002e62:	a911      	add	r1, sp, #68	; 0x44
30002e64:	e7af      	b.n	30002dc6 <flash_emmc_one_boot_area+0x1d2>
30002e66:	bf00      	nop

30002e68 <cmd_read_efuse_proc>:
{
30002e68:	b530      	push	{r4, r5, r14}
    char fuse_response[MAX_RSP_SIZE] = {0};
30002e6a:	2240      	movs	r2, #64	; 0x40
{
30002e6c:	b093      	sub	sp, #76	; 0x4c
30002e6e:	460c      	mov	r4, r1
30002e70:	4605      	mov	r5, r0
    char fuse_response[MAX_RSP_SIZE] = {0};
30002e72:	2100      	movs	r1, #0
30002e74:	a802      	add	r0, sp, #8
30002e76:	f011 ed7c 	blx	30014970 <memset>
    fuse_index = strtoul(arg, NULL, 16);
30002e7a:	4620      	mov	r0, r4
30002e7c:	2210      	movs	r2, #16
30002e7e:	2100      	movs	r1, #0
30002e80:	f011 feb0 	bl	30014be4 <strtoul>
30002e84:	4604      	mov	r4, r0
    if (errno != 0 || fuse_index > FUSE_INDEX_MAX) {
30002e86:	f011 ff4d 	bl	30014d24 <__geterrno>
30002e8a:	6803      	ldr	r3, [r0, #0]
30002e8c:	2cf9      	cmp	r4, #249	; 0xf9
30002e8e:	bf98      	it	ls
30002e90:	2b00      	cmpls	r3, #0
30002e92:	d01b      	beq.n	30002ecc <cmd_read_efuse_proc+0x64>
        ERROR("index error:%d!\n", errno);
30002e94:	f011 ff46 	bl	30014d24 <__geterrno>
30002e98:	f64a 110c 	movw	r1, #43276	; 0xa90c
30002e9c:	f640 22d4 	movw	r2, #2772	; 0xad4
30002ea0:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002ea4:	6803      	ldr	r3, [r0, #0]
30002ea6:	f24b 5088 	movw	r0, #46472	; 0xb588
30002eaa:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002eae:	f012 fe7f 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(ERR_EFUSE_INDEX, ""));
30002eb2:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30002eb6:	2017      	movs	r0, #23
30002eb8:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002ebc:	f7ff fd7a 	bl	300029b4 <response_error>
30002ec0:	4601      	mov	r1, r0
30002ec2:	4628      	mov	r0, r5
30002ec4:	f011 fbac 	bl	30014620 <fastboot_common_fail>
}
30002ec8:	b013      	add	sp, #76	; 0x4c
30002eca:	bd30      	pop	{r4, r5, r15}
    fuse_val = fuse_read(fuse_index);
30002ecc:	4620      	mov	r0, r4
30002ece:	f004 fc87 	bl	300077e0 <fuse_read>
    snprintf(fuse_response, sizeof(fuse_response), "eFuseRead:%08x:%08x",
30002ed2:	f24b 52a8 	movw	r2, #46504	; 0xb5a8
30002ed6:	4623      	mov	r3, r4
30002ed8:	f2c3 0201 	movt	r2, #12289	; 0x3001
30002edc:	2140      	movs	r1, #64	; 0x40
30002ede:	9000      	str	r0, [sp, #0]
30002ee0:	a802      	add	r0, sp, #8
30002ee2:	f012 fdf5 	bl	30015ad0 <snprintf>
    fastboot_common_okay(fb, fuse_response);
30002ee6:	4628      	mov	r0, r5
30002ee8:	a902      	add	r1, sp, #8
30002eea:	f011 fb95 	bl	30014618 <fastboot_common_okay>
}
30002eee:	b013      	add	sp, #76	; 0x4c
30002ef0:	bd30      	pop	{r4, r5, r15}
30002ef2:	bf00      	nop

30002ef4 <cmd_erase_proc>:
{
30002ef4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30002ef8:	4605      	mov	r5, r0
30002efa:	b0b9      	sub	sp, #228	; 0xe4
    ret = parse_partition_name(arg);
30002efc:	4608      	mov	r0, r1
{
30002efe:	460c      	mov	r4, r1
    ret = parse_partition_name(arg);
30002f00:	f7ff f95c 	bl	300021bc <parse_partition_name>
    if (ret) {
30002f04:	2800      	cmp	r0, #0
30002f06:	d17d      	bne.n	30003004 <cmd_erase_proc+0x110>
    enum pt_type pttype = current_dl_state->cur_pt_info.type;
30002f08:	f646 4470 	movw	r4, #27760	; 0x6c70
30002f0c:	f2c3 0402 	movt	r4, #12290	; 0x3002
30002f10:	f8d4 a000 	ldr.w	r10, [r4]
30002f14:	f8da 711c 	ldr.w	r7, [r10, #284]	; 0x11c
    if (pttype == TYPE_PRI_PTB || pttype == TYPE_SUB_PTB) {
30002f18:	f027 0302 	bic.w	r3, r7, #2
30002f1c:	2b01      	cmp	r3, #1
30002f1e:	f000 8088 	beq.w	30003032 <cmd_erase_proc+0x13e>
    else if (pttype == TYPE_ALL_PT) {
30002f22:	2f06      	cmp	r7, #6
30002f24:	f000 815d 	beq.w	300031e2 <cmd_erase_proc+0x2ee>
    else if (pttype > TYPE_NOT_IN_GPT) {
30002f28:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
30002f2c:	f200 80ab 	bhi.w	30003086 <cmd_erase_proc+0x192>
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30002f30:	4601      	mov	r1, r0
30002f32:	f10d 0b4c 	add.w	r11, r13, #76	; 0x4c
30002f36:	4658      	mov	r0, r11
30002f38:	2292      	movs	r2, #146	; 0x92
30002f3a:	f011 ed1a 	blx	30014970 <memset>
    storage = current_dl_state->storage;
30002f3e:	e9da 3802 	ldrd	r3, r8, [r10, #8]
30002f42:	9308      	str	r3, [sp, #32]
    block_size = st_info->block_size;
30002f44:	f8da 6070 	ldr.w	r6, [r10, #112]	; 0x70
    if (!ptdev) {
30002f48:	f1b8 0f00 	cmp.w	r8, #0
30002f4c:	f000 81c1 	beq.w	300032d2 <cmd_erase_proc+0x3de>
    if (st_info->type == MMC && !st_info->boot_offset) {
30002f50:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
30002f54:	b921      	cbnz	r1, 30002f60 <cmd_erase_proc+0x6c>
30002f56:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
30002f5a:	4313      	orrs	r3, r2
30002f5c:	f000 816e 	beq.w	3000323c <cmd_erase_proc+0x348>
30002f60:	4653      	mov	r3, r10
    if (pttype == TYPE_SUB_PT_WHOLE) {
30002f62:	2f05      	cmp	r7, #5
    ptname = current_dl_state->cur_pt_info.ptname;
30002f64:	f103 01d1 	add.w	r1, r3, #209	; 0xd1
    sub_ptbname = current_dl_state->cur_pt_info.sub_ptbname;
30002f68:	f103 0388 	add.w	r3, r3, #136	; 0x88
    if (pttype == TYPE_SUB_PT_WHOLE) {
30002f6c:	f000 8242 	beq.w	300033f4 <cmd_erase_proc+0x500>
    else if (pttype == TYPE_SUB_PT) {
30002f70:	2f04      	cmp	r7, #4
30002f72:	f000 8197 	beq.w	300032a4 <cmd_erase_proc+0x3b0>
        snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
30002f76:	f240 52e4 	movw	r2, #1508	; 0x5e4
30002f7a:	460b      	mov	r3, r1
30002f7c:	4658      	mov	r0, r11
30002f7e:	f2c3 0202 	movt	r2, #12290	; 0x3002
30002f82:	2192      	movs	r1, #146	; 0x92
30002f84:	f012 fda4 	bl	30015ad0 <snprintf>
    ptn = ptdev_get_offset(ptdev, full_ptname);
30002f88:	4640      	mov	r0, r8
30002f8a:	4659      	mov	r1, r11
30002f8c:	f014 ffce 	bl	30017f2c <ptdev_get_offset>
30002f90:	9006      	str	r0, [sp, #24]
30002f92:	460f      	mov	r7, r1
    size = ptdev_get_size(ptdev, full_ptname);
30002f94:	4640      	mov	r0, r8
30002f96:	4659      	mov	r1, r11
30002f98:	f014 ffa2 	bl	30017ee0 <ptdev_get_size>
    if (size < block_size || ptn == 0) {
30002f9c:	9b06      	ldr	r3, [sp, #24]
30002f9e:	ea53 0207 	orrs.w	r2, r3, r7
30002fa2:	f04f 0300 	mov.w	r3, #0
30002fa6:	4632      	mov	r2, r6
30002fa8:	bf0c      	ite	eq
30002faa:	2601      	moveq	r6, #1
30002fac:	2600      	movne	r6, #0
    size = ptdev_get_size(ptdev, full_ptname);
30002fae:	4680      	mov	r8, r0
    if (size < block_size || ptn == 0) {
30002fb0:	4299      	cmp	r1, r3
    size = ptdev_get_size(ptdev, full_ptname);
30002fb2:	4689      	mov	r9, r1
    if (size < block_size || ptn == 0) {
30002fb4:	bf08      	it	eq
30002fb6:	4290      	cmpeq	r0, r2
30002fb8:	bf38      	it	cc
30002fba:	f046 0601 	orrcc.w	r6, r6, #1
30002fbe:	2e00      	cmp	r6, #0
30002fc0:	f000 815b 	beq.w	3000327a <cmd_erase_proc+0x386>
        ERROR("partition not found ptn:%lld size:%lld! name:%s\n", ptn, size,
30002fc4:	9b06      	ldr	r3, [sp, #24]
30002fc6:	f64a 01c8 	movw	r1, #43208	; 0xa8c8
30002fca:	f64a 30a4 	movw	r0, #43940	; 0xaba4
30002fce:	f2c3 0101 	movt	r1, #12289	; 0x3001
30002fd2:	f8cd b010 	str.w	r11, [r13, #16]
30002fd6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30002fda:	e9cd 8902 	strd	r8, r9, [r13, #8]
30002fde:	f640 2214 	movw	r2, #2580	; 0xa14
30002fe2:	9300      	str	r3, [sp, #0]
30002fe4:	9701      	str	r7, [sp, #4]
30002fe6:	f012 fde3 	bl	30015bb0 <_printf>
        err = ERR_PT_NOT_FOUND;
30002fea:	2004      	movs	r0, #4
    fastboot_common_fail(fb, response_error(err, full_ptname));
30002fec:	4659      	mov	r1, r11
30002fee:	f7ff fce1 	bl	300029b4 <response_error>
30002ff2:	4601      	mov	r1, r0
30002ff4:	4628      	mov	r0, r5
30002ff6:	f011 fb13 	bl	30014620 <fastboot_common_fail>
        ptdev_read_table(current_dl_state->ptdev);
30002ffa:	6823      	ldr	r3, [r4, #0]
30002ffc:	68d8      	ldr	r0, [r3, #12]
30002ffe:	f014 fe83 	bl	30017d08 <ptdev_read_table>
30003002:	e0df      	b.n	300031c4 <cmd_erase_proc+0x2d0>
        ERROR("parse pt name error!\n");
30003004:	f64a 01fc 	movw	r1, #43260	; 0xa8fc
30003008:	f64a 10b8 	movw	r0, #43448	; 0xa9b8
3000300c:	f640 22a5 	movw	r2, #2725	; 0xaa5
30003010:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003014:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003018:	f012 fdca 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(ERR_PT_FULL_NAME_FORMAT, arg));
3000301c:	4621      	mov	r1, r4
3000301e:	200c      	movs	r0, #12
30003020:	f7ff fcc8 	bl	300029b4 <response_error>
30003024:	4601      	mov	r1, r0
30003026:	4628      	mov	r0, r5
30003028:	f011 fafa 	bl	30014620 <fastboot_common_fail>
}
3000302c:	b039      	add	sp, #228	; 0xe4
3000302e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30003032:	4601      	mov	r1, r0
30003034:	f10d 0b4c 	add.w	r11, r13, #76	; 0x4c
30003038:	4658      	mov	r0, r11
3000303a:	2292      	movs	r2, #146	; 0x92
3000303c:	f011 ec98 	blx	30014970 <memset>
    ptdev = current_dl_state->ptdev;
30003040:	e9da 4602 	ldrd	r4, r6, [r10, #8]
    capacity = storage->get_capacity(storage);
30003044:	4620      	mov	r0, r4
30003046:	69a3      	ldr	r3, [r4, #24]
30003048:	4798      	blx	r3
    if (!ptdev) {
3000304a:	2e00      	cmp	r6, #0
3000304c:	f000 8134 	beq.w	300032b8 <cmd_erase_proc+0x3c4>
    if (st_info->type == MMC && !st_info->boot_offset) {
30003050:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
30003054:	bb39      	cbnz	r1, 300030a6 <cmd_erase_proc+0x1b2>
30003056:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
3000305a:	4313      	orrs	r3, r2
3000305c:	d123      	bne.n	300030a6 <cmd_erase_proc+0x1b2>
        if (!storage->switch_part
3000305e:	6963      	ldr	r3, [r4, #20]
30003060:	b113      	cbz	r3, 30003068 <cmd_erase_proc+0x174>
                || storage->switch_part(storage, switch_pt_num)) {
30003062:	4620      	mov	r0, r4
30003064:	4798      	blx	r3
30003066:	b1f0      	cbz	r0, 300030a6 <cmd_erase_proc+0x1b2>
            ERROR("switch partition:%d error!\n",
30003068:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
3000306c:	f64a 10f4 	movw	r0, #43508	; 0xa9f4
30003070:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003074:	2300      	movs	r3, #0
30003076:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000307a:	f640 125f 	movw	r2, #2399	; 0x95f
3000307e:	f012 fd97 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
30003082:	2001      	movs	r0, #1
30003084:	e097      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        ret = erase_boot_areas(fb);
30003086:	4628      	mov	r0, r5
30003088:	f7ff fd3a 	bl	30002b00 <erase_boot_areas>
    if (ret) {
3000308c:	2800      	cmp	r0, #0
3000308e:	f040 8099 	bne.w	300031c4 <cmd_erase_proc+0x2d0>
    fastboot_common_okay(fb, "");
30003092:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003096:	4628      	mov	r0, r5
30003098:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000309c:	f011 fabc 	bl	30014618 <fastboot_common_okay>
}
300030a0:	b039      	add	sp, #228	; 0xe4
300030a2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    block_size = st_info->block_size;
300030a6:	f8da 3070 	ldr.w	r3, [r10, #112]	; 0x70
    if (!block_size || block_size % 4 != 0) {
300030aa:	2b00      	cmp	r3, #0
300030ac:	d076      	beq.n	3000319c <cmd_erase_proc+0x2a8>
300030ae:	079a      	lsls	r2, r3, #30
300030b0:	d174      	bne.n	3000319c <cmd_erase_proc+0x2a8>
    blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
300030b2:	f44f 4880 	mov.w	r8, #16384	; 0x4000
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
300030b6:	2200      	movs	r2, #0
    if (pttype == TYPE_SUB_PTB) {
300030b8:	2f03      	cmp	r7, #3
    blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
300030ba:	fbb8 f8f3 	udiv	r8, r8, r3
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
300030be:	f108 0802 	add.w	r8, r8, #2
300030c2:	fb03 f308 	mul.w	r3, r3, r8
300030c6:	4619      	mov	r1, r3
300030c8:	e9cd 1206 	strd	r1, r2, [r13, #24]
        snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
300030cc:	f240 52e4 	movw	r2, #1508	; 0x5e4
    if (pttype == TYPE_SUB_PTB) {
300030d0:	f000 81a7 	beq.w	30003422 <cmd_erase_proc+0x52e>
        snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
300030d4:	f10a 03d1 	add.w	r3, r10, #209	; 0xd1
300030d8:	2192      	movs	r1, #146	; 0x92
300030da:	f2c3 0202 	movt	r2, #12290	; 0x3002
300030de:	4658      	mov	r0, r11
300030e0:	f012 fcf6 	bl	30015ad0 <snprintf>
        ptn_pri = st_info->ptb_offset;
300030e4:	e9da 121a 	ldrd	r1, r2, [r10, #104]	; 0x68
        ptn_bak = storage->get_capacity(storage) - gpt_sz + st_info->block_size;
300030e8:	69a3      	ldr	r3, [r4, #24]
300030ea:	4620      	mov	r0, r4
        ptn_pri = st_info->ptb_offset;
300030ec:	e9cd 120c 	strd	r1, r2, [r13, #48]	; 0x30
        ptn_bak = storage->get_capacity(storage) - gpt_sz + st_info->block_size;
300030f0:	4798      	blx	r3
300030f2:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
300030f6:	2300      	movs	r3, #0
300030f8:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
300030fc:	ebb2 0808 	subs.w	r8, r2, r8
30003100:	eb63 0909 	sbc.w	r9, r3, r9
    size_bak = gpt_sz - st_info->block_size;
30003104:	e9dd 6706 	ldrd	r6, r7, [r13, #24]
        ptn_bak = storage->get_capacity(storage) - gpt_sz + st_info->block_size;
30003108:	eb18 0800 	adds.w	r8, r8, r0
3000310c:	eb49 0901 	adc.w	r9, r9, r1
    if (st_info->type == MMC  ) {
30003110:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
    size_bak = gpt_sz - st_info->block_size;
30003114:	1ab6      	subs	r6, r6, r2
30003116:	4632      	mov	r2, r6
30003118:	eb67 0703 	sbc.w	r7, r7, r3
        ptn_bak = storage->get_capacity(storage) - gpt_sz + st_info->block_size;
3000311c:	e9cd 8908 	strd	r8, r9, [r13, #32]
    size_bak = gpt_sz - st_info->block_size;
30003120:	463b      	mov	r3, r7
30003122:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
    if (st_info->type == MMC  ) {
30003126:	2900      	cmp	r1, #0
30003128:	f040 80e4 	bne.w	300032f4 <cmd_erase_proc+0x400>
        if (st_info->boot_offset > 0 && backup_boot(storage)) {
3000312c:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
30003130:	4313      	orrs	r3, r2
30003132:	f040 81f0 	bne.w	30003516 <cmd_erase_proc+0x622>
    if (storage->erase(storage, ptn_pri, size_pri)) {
30003136:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
3000313a:	4620      	mov	r0, r4
3000313c:	e9cd 2300 	strd	r2, r3, [r13]
30003140:	e9dd 230c 	ldrd	r2, r3, [r13, #48]	; 0x30
30003144:	6921      	ldr	r1, [r4, #16]
30003146:	4788      	blx	r1
30003148:	2800      	cmp	r0, #0
3000314a:	f040 8215 	bne.w	30003578 <cmd_erase_proc+0x684>
    if (storage->erase(storage, ptn_bak, size_bak)) {
3000314e:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30003152:	4620      	mov	r0, r4
30003154:	e9cd 2300 	strd	r2, r3, [r13]
30003158:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
3000315c:	6921      	ldr	r1, [r4, #16]
3000315e:	4788      	blx	r1
30003160:	2800      	cmp	r0, #0
30003162:	f040 81a8 	bne.w	300034b6 <cmd_erase_proc+0x5c2>
    if (st_info->type == MMC) {
30003166:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
3000316a:	2b00      	cmp	r3, #0
3000316c:	d191      	bne.n	30003092 <cmd_erase_proc+0x19e>
        if (st_info->boot_offset > 0
3000316e:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
30003172:	4313      	orrs	r3, r2
30003174:	d08d      	beq.n	30003092 <cmd_erase_proc+0x19e>
                && restore_boot(storage)) {
30003176:	4620      	mov	r0, r4
30003178:	f7ff fbd2 	bl	30002920 <restore_boot>
3000317c:	2800      	cmp	r0, #0
3000317e:	d088      	beq.n	30003092 <cmd_erase_proc+0x19e>
            ERROR("restore spl error!\n");
30003180:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
30003184:	f64a 3008 	movw	r0, #43784	; 0xab08
30003188:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000318c:	f640 12cf 	movw	r2, #2511	; 0x9cf
30003190:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003194:	f012 fd0c 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
30003198:	2001      	movs	r0, #1
3000319a:	e00c      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        ERROR("block size:%d error!\n", block_size);
3000319c:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
300031a0:	f64a 2020 	movw	r0, #43552	; 0xaa20
300031a4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300031a8:	f640 1268 	movw	r2, #2408	; 0x968
300031ac:	f2c3 0001 	movt	r0, #12289	; 0x3001
300031b0:	f012 fcfe 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
300031b4:	2001      	movs	r0, #1
    fastboot_common_fail(fb, response_error(err, full_ptname));
300031b6:	4659      	mov	r1, r11
300031b8:	f7ff fbfc 	bl	300029b4 <response_error>
300031bc:	4601      	mov	r1, r0
300031be:	4628      	mov	r0, r5
300031c0:	f011 fa2e 	bl	30014620 <fastboot_common_fail>
        ERROR("erase partition error!\n");
300031c4:	f64a 01f0 	movw	r1, #43248	; 0xa8f0
300031c8:	f64a 403c 	movw	r0, #44092	; 0xac3c
300031cc:	f640 2293 	movw	r2, #2707	; 0xa93
300031d0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300031d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300031d8:	f012 fcea 	bl	30015bb0 <_printf>
}
300031dc:	b039      	add	sp, #228	; 0xe4
300031de:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ret = erase_boot_areas(fb);
300031e2:	4628      	mov	r0, r5
300031e4:	f7ff fc8c 	bl	30002b00 <erase_boot_areas>
    storage = current_dl_state->storage;
300031e8:	6826      	ldr	r6, [r4, #0]
    if (st_info->type == MMC) {
300031ea:	6e31      	ldr	r1, [r6, #96]	; 0x60
    storage = current_dl_state->storage;
300031ec:	68b7      	ldr	r7, [r6, #8]
    if (st_info->type == MMC) {
300031ee:	2900      	cmp	r1, #0
300031f0:	f000 816f 	beq.w	300034d2 <cmd_erase_proc+0x5de>
    capacity = storage->get_capacity(storage);
300031f4:	69bb      	ldr	r3, [r7, #24]
300031f6:	4638      	mov	r0, r7
300031f8:	4798      	blx	r3
    capacity -= st_info->ptb_offset;
300031fa:	e9d6 ab1a 	ldrd	r10, r11, [r6, #104]	; 0x68
    if (storage->erase(storage, st_info->ptb_offset, capacity)) {
300031fe:	4652      	mov	r2, r10
30003200:	465b      	mov	r3, r11
    capacity -= st_info->ptb_offset;
30003202:	ebb0 080a 	subs.w	r8, r0, r10
    if (storage->erase(storage, st_info->ptb_offset, capacity)) {
30003206:	4638      	mov	r0, r7
    capacity -= st_info->ptb_offset;
30003208:	eb61 090b 	sbc.w	r9, r1, r11
    if (storage->erase(storage, st_info->ptb_offset, capacity)) {
3000320c:	e9cd 8900 	strd	r8, r9, [r13]
30003210:	6939      	ldr	r1, [r7, #16]
30003212:	4788      	blx	r1
30003214:	b9f8      	cbnz	r0, 30003256 <cmd_erase_proc+0x362>
    if (st_info->type == MMC) {
30003216:	6e33      	ldr	r3, [r6, #96]	; 0x60
30003218:	b923      	cbnz	r3, 30003224 <cmd_erase_proc+0x330>
        if (st_info->boot_offset > 0
3000321a:	e9d6 231e 	ldrd	r2, r3, [r6, #120]	; 0x78
3000321e:	4313      	orrs	r3, r2
30003220:	f040 8135 	bne.w	3000348e <cmd_erase_proc+0x59a>
    fastboot_common_okay(fb, "");
30003224:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003228:	4628      	mov	r0, r5
3000322a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000322e:	f011 f9f3 	bl	30014618 <fastboot_common_okay>
        ptdev_read_table(current_dl_state->ptdev);
30003232:	6823      	ldr	r3, [r4, #0]
30003234:	68d8      	ldr	r0, [r3, #12]
30003236:	f014 fd67 	bl	30017d08 <ptdev_read_table>
3000323a:	e72a      	b.n	30003092 <cmd_erase_proc+0x19e>
        if (!storage || storage->switch_part(storage, switch_pt_num)) {
3000323c:	9b08      	ldr	r3, [sp, #32]
3000323e:	2b00      	cmp	r3, #0
30003240:	f000 80e1 	beq.w	30003406 <cmd_erase_proc+0x512>
30003244:	9b08      	ldr	r3, [sp, #32]
30003246:	4618      	mov	r0, r3
30003248:	695b      	ldr	r3, [r3, #20]
3000324a:	4798      	blx	r3
3000324c:	2800      	cmp	r0, #0
3000324e:	f040 80da 	bne.w	30003406 <cmd_erase_proc+0x512>
30003252:	6823      	ldr	r3, [r4, #0]
30003254:	e685      	b.n	30002f62 <cmd_erase_proc+0x6e>
        ERROR(" erase data error!\n");
30003256:	f64a 01e0 	movw	r1, #43232	; 0xa8e0
3000325a:	f64b 0064 	movw	r0, #47204	; 0xb864
3000325e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003262:	f640 2265 	movw	r2, #2661	; 0xa65
30003266:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000326a:	f012 fca1 	bl	30015bb0 <_printf>
        err = ERR_PT_ERASE_FAIL;
3000326e:	200a      	movs	r0, #10
    fastboot_common_fail(fb, response_error(err, ""));
30003270:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003274:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003278:	e6b9      	b.n	30002fee <cmd_erase_proc+0xfa>
    if (st_info->type == OSPI) {
3000327a:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
3000327e:	2b01      	cmp	r3, #1
30003280:	f000 8188 	beq.w	30003594 <cmd_erase_proc+0x6a0>
    if (storage->erase(storage, ptn, size)) {
30003284:	9908      	ldr	r1, [sp, #32]
30003286:	463b      	mov	r3, r7
30003288:	e9cd 8900 	strd	r8, r9, [r13]
3000328c:	4608      	mov	r0, r1
3000328e:	9a06      	ldr	r2, [sp, #24]
30003290:	6909      	ldr	r1, [r1, #16]
30003292:	4788      	blx	r1
30003294:	2800      	cmp	r0, #0
30003296:	f040 80ec 	bne.w	30003472 <cmd_erase_proc+0x57e>
        ptdev_read_table(current_dl_state->ptdev);
3000329a:	6823      	ldr	r3, [r4, #0]
3000329c:	68d8      	ldr	r0, [r3, #12]
3000329e:	f014 fd33 	bl	30017d08 <ptdev_read_table>
300032a2:	e6f6      	b.n	30003092 <cmd_erase_proc+0x19e>
        snprintf(full_ptname, sizeof(full_ptname), "%s$%s", sub_ptbname, ptname);
300032a4:	f64a 329c 	movw	r2, #43932	; 0xab9c
300032a8:	4658      	mov	r0, r11
300032aa:	9100      	str	r1, [sp, #0]
300032ac:	f2c3 0201 	movt	r2, #12289	; 0x3001
300032b0:	2192      	movs	r1, #146	; 0x92
300032b2:	f012 fc0d 	bl	30015ad0 <snprintf>
300032b6:	e667      	b.n	30002f88 <cmd_erase_proc+0x94>
        ERROR("no gpt\n");
300032b8:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
300032bc:	f64a 10dc 	movw	r0, #43484	; 0xa9dc
300032c0:	f640 1256 	movw	r2, #2390	; 0x956
300032c4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300032c8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300032cc:	f012 fc70 	bl	30015bb0 <_printf>
300032d0:	e6df      	b.n	30003092 <cmd_erase_proc+0x19e>
        ERROR("ospi flash has no gpt\n");
300032d2:	f64a 01c8 	movw	r1, #43208	; 0xa8c8
300032d6:	f64a 3050 	movw	r0, #43856	; 0xab50
300032da:	f640 12f6 	movw	r2, #2550	; 0x9f6
300032de:	f2c3 0101 	movt	r1, #12289	; 0x3001
300032e2:	f2c3 0001 	movt	r0, #12289	; 0x3001
300032e6:	f012 fc63 	bl	30015bb0 <_printf>
        ptdev_read_table(current_dl_state->ptdev);
300032ea:	6823      	ldr	r3, [r4, #0]
300032ec:	68d8      	ldr	r0, [r3, #12]
300032ee:	f014 fd0b 	bl	30017d08 <ptdev_read_table>
300032f2:	e6ce      	b.n	30003092 <cmd_erase_proc+0x19e>
    else if (st_info->type == OSPI  ) {
300032f4:	2901      	cmp	r1, #1
300032f6:	f47f af1e 	bne.w	30003136 <cmd_erase_proc+0x242>
        size_pri = round_up(size_pri, st_info->erase_grp_sz);
300032fa:	f8da 3080 	ldr.w	r3, [r10, #128]	; 0x80
300032fe:	2100      	movs	r1, #0
    if (aligned == 0 || size < aligned)
30003300:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
30003304:	460f      	mov	r7, r1
30003306:	4618      	mov	r0, r3
30003308:	fab3 f283 	clz	r2, r3
3000330c:	461e      	mov	r6, r3
3000330e:	45b9      	cmp	r9, r7
30003310:	ea4f 1352 	mov.w	r3, r2, lsr #5
30003314:	e9cd 670e 	strd	r6, r7, [r13, #56]	; 0x38
30003318:	bf08      	it	eq
3000331a:	4580      	cmpeq	r8, r0
3000331c:	9311      	str	r3, [sp, #68]	; 0x44
3000331e:	bf38      	it	cc
30003320:	f043 0301 	orrcc.w	r3, r3, #1
30003324:	2b00      	cmp	r3, #0
30003326:	f040 8114 	bne.w	30003552 <cmd_erase_proc+0x65e>
    mod = size % aligned;
3000332a:	4602      	mov	r2, r0
3000332c:	463b      	mov	r3, r7
3000332e:	4640      	mov	r0, r8
30003330:	4649      	mov	r1, r9
30003332:	f016 fd75 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30003336:	ea52 0103 	orrs.w	r1, r2, r3
3000333a:	d009      	beq.n	30003350 <cmd_erase_proc+0x45c>
3000333c:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30003340:	1980      	adds	r0, r0, r6
30003342:	4179      	adcs	r1, r7
30003344:	ebb0 0802 	subs.w	r8, r0, r2
30003348:	eb61 0903 	sbc.w	r9, r1, r3
3000334c:	e9cd 8906 	strd	r8, r9, [r13, #24]
    if (aligned == 0 || size < aligned)
30003350:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30003354:	e9dd 890e 	ldrd	r8, r9, [r13, #56]	; 0x38
30003358:	9b11      	ldr	r3, [sp, #68]	; 0x44
3000335a:	4549      	cmp	r1, r9
3000335c:	bf08      	it	eq
3000335e:	4540      	cmpeq	r0, r8
30003360:	bf38      	it	cc
30003362:	f043 0301 	orrcc.w	r3, r3, #1
30003366:	2b00      	cmp	r3, #0
30003368:	f040 80ee 	bne.w	30003548 <cmd_erase_proc+0x654>
    mod = size % aligned;
3000336c:	4642      	mov	r2, r8
3000336e:	464b      	mov	r3, r9
30003370:	4606      	mov	r6, r0
30003372:	460f      	mov	r7, r1
30003374:	f016 fd54 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30003378:	ea52 0103 	orrs.w	r1, r2, r3
3000337c:	d00a      	beq.n	30003394 <cmd_erase_proc+0x4a0>
3000337e:	4630      	mov	r0, r6
30003380:	4639      	mov	r1, r7
30003382:	eb10 0008 	adds.w	r0, r0, r8
30003386:	eb41 0109 	adc.w	r1, r1, r9
3000338a:	1a80      	subs	r0, r0, r2
3000338c:	eb61 0103 	sbc.w	r1, r1, r3
30003390:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
    if (aligned == 0 || size < aligned)
30003394:	e9dd 120e 	ldrd	r1, r2, [r13, #56]	; 0x38
30003398:	e9dd 6708 	ldrd	r6, r7, [r13, #32]
3000339c:	9b11      	ldr	r3, [sp, #68]	; 0x44
3000339e:	4297      	cmp	r7, r2
300033a0:	bf08      	it	eq
300033a2:	428e      	cmpeq	r6, r1
300033a4:	bf38      	it	cc
300033a6:	f043 0301 	orrcc.w	r3, r3, #1
300033aa:	2b00      	cmp	r3, #0
300033ac:	f040 80c7 	bne.w	3000353e <cmd_erase_proc+0x64a>
    mod = size % aligned;
300033b0:	4613      	mov	r3, r2
300033b2:	4630      	mov	r0, r6
300033b4:	460a      	mov	r2, r1
300033b6:	4639      	mov	r1, r7
300033b8:	f016 fd32 	bl	30019e20 <__aeabi_uldivmod>
    size -= mod;
300033bc:	1ab6      	subs	r6, r6, r2
300033be:	eb67 0703 	sbc.w	r7, r7, r3
300033c2:	e9cd 6708 	strd	r6, r7, [r13, #32]
        if ( ptn_pri % st_info->erase_grp_sz != 0) {
300033c6:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
300033ca:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
300033ce:	f016 fd27 	bl	30019e20 <__aeabi_uldivmod>
300033d2:	4313      	orrs	r3, r2
300033d4:	f43f aeaf 	beq.w	30003136 <cmd_erase_proc+0x242>
            ERROR("nor flash ptn must be aligned to erase group size!\n");
300033d8:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
300033dc:	f64a 2064 	movw	r0, #43620	; 0xaa64
300033e0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300033e4:	f640 12b6 	movw	r2, #2486	; 0x9b6
300033e8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300033ec:	f012 fbe0 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
300033f0:	2001      	movs	r0, #1
300033f2:	e6e0      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
300033f4:	f240 52e4 	movw	r2, #1508	; 0x5e4
300033f8:	2192      	movs	r1, #146	; 0x92
300033fa:	4658      	mov	r0, r11
300033fc:	f2c3 0202 	movt	r2, #12290	; 0x3002
30003400:	f012 fb66 	bl	30015ad0 <snprintf>
30003404:	e5c0      	b.n	30002f88 <cmd_erase_proc+0x94>
            ERROR(" switch partition  error!\n");
30003406:	f64a 01c8 	movw	r1, #43208	; 0xa8c8
3000340a:	f64a 3074 	movw	r0, #43892	; 0xab74
3000340e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003412:	f640 12fc 	movw	r2, #2556	; 0x9fc
30003416:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000341a:	f012 fbc9 	bl	30015bb0 <_printf>
            err = ERR_PT_ERASE_FAIL;
3000341e:	200a      	movs	r0, #10
30003420:	e5e4      	b.n	30002fec <cmd_erase_proc+0xf8>
        snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
30003422:	f10a 0388 	add.w	r3, r10, #136	; 0x88
30003426:	2192      	movs	r1, #146	; 0x92
30003428:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000342c:	4658      	mov	r0, r11
3000342e:	f012 fb4f 	bl	30015ad0 <snprintf>
        ptn_pri  = ptdev_get_offset(ptdev, full_ptname);
30003432:	4630      	mov	r0, r6
30003434:	4659      	mov	r1, r11
30003436:	f014 fd79 	bl	30017f2c <ptdev_get_offset>
3000343a:	4602      	mov	r2, r0
3000343c:	460b      	mov	r3, r1
3000343e:	e9cd 0108 	strd	r0, r1, [r13, #32]
        size_bak = ptdev_get_size(ptdev, full_ptname);
30003442:	4630      	mov	r0, r6
        ptn_pri  = ptdev_get_offset(ptdev, full_ptname);
30003444:	e9cd 230c 	strd	r2, r3, [r13, #48]	; 0x30
        size_bak = ptdev_get_size(ptdev, full_ptname);
30003448:	4659      	mov	r1, r11
3000344a:	f014 fd49 	bl	30017ee0 <ptdev_get_size>
        ptn_bak  = ptn_pri + size_bak - gpt_sz + st_info->block_size;
3000344e:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
30003452:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
30003456:	2300      	movs	r3, #0
30003458:	ebb2 0808 	subs.w	r8, r2, r8
3000345c:	4646      	mov	r6, r8
3000345e:	eb63 0909 	sbc.w	r9, r3, r9
30003462:	464f      	mov	r7, r9
30003464:	e9dd 8908 	ldrd	r8, r9, [r13, #32]
30003468:	eb18 0806 	adds.w	r8, r8, r6
3000346c:	eb49 0907 	adc.w	r9, r9, r7
30003470:	e648      	b.n	30003104 <cmd_erase_proc+0x210>
        ERROR(" erase data error!\n");
30003472:	f64a 01c8 	movw	r1, #43208	; 0xa8c8
30003476:	f64b 0064 	movw	r0, #47204	; 0xb864
3000347a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000347e:	f640 2225 	movw	r2, #2597	; 0xa25
30003482:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003486:	f012 fb93 	bl	30015bb0 <_printf>
        err = ERR_PT_ERASE_FAIL;
3000348a:	200a      	movs	r0, #10
3000348c:	e5ae      	b.n	30002fec <cmd_erase_proc+0xf8>
                && restore_boot(storage)) {
3000348e:	4638      	mov	r0, r7
30003490:	f7ff fa46 	bl	30002920 <restore_boot>
30003494:	2800      	cmp	r0, #0
30003496:	f43f aec5 	beq.w	30003224 <cmd_erase_proc+0x330>
            ERROR("restore spl error!\n");
3000349a:	f64a 01e0 	movw	r1, #43232	; 0xa8e0
3000349e:	f64a 3008 	movw	r0, #43784	; 0xab08
300034a2:	f2c3 0101 	movt	r1, #12289	; 0x3001
300034a6:	f640 226d 	movw	r2, #2669	; 0xa6d
300034aa:	f2c3 0001 	movt	r0, #12289	; 0x3001
300034ae:	f012 fb7f 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
300034b2:	2001      	movs	r0, #1
300034b4:	e6dc      	b.n	30003270 <cmd_erase_proc+0x37c>
        ERROR(" erase backup gpt header error!\n");
300034b6:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
300034ba:	f64a 20d8 	movw	r0, #43736	; 0xaad8
300034be:	f2c3 0101 	movt	r1, #12289	; 0x3001
300034c2:	f640 12c7 	movw	r2, #2503	; 0x9c7
300034c6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300034ca:	f012 fb71 	bl	30015bb0 <_printf>
        err = ERR_PT_ERASE_FAIL;
300034ce:	200a      	movs	r0, #10
300034d0:	e671      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        if (!st_info->boot_offset
300034d2:	e9d6 231e 	ldrd	r2, r3, [r6, #120]	; 0x78
300034d6:	4313      	orrs	r3, r2
300034d8:	d109      	bne.n	300034ee <cmd_erase_proc+0x5fa>
                && storage->switch_part(storage, switch_pt_num)) {
300034da:	697b      	ldr	r3, [r7, #20]
300034dc:	4638      	mov	r0, r7
300034de:	4798      	blx	r3
300034e0:	2800      	cmp	r0, #0
300034e2:	d13b      	bne.n	3000355c <cmd_erase_proc+0x668>
        if (st_info->boot_offset > 0 && backup_boot(storage)) {
300034e4:	e9d6 231e 	ldrd	r2, r3, [r6, #120]	; 0x78
300034e8:	4313      	orrs	r3, r2
300034ea:	f43f ae83 	beq.w	300031f4 <cmd_erase_proc+0x300>
300034ee:	4638      	mov	r0, r7
300034f0:	f7ff f9cc 	bl	3000288c <backup_boot>
300034f4:	2800      	cmp	r0, #0
300034f6:	f43f ae7d 	beq.w	300031f4 <cmd_erase_proc+0x300>
            ERROR("backup spl error!\n");
300034fa:	f64a 01e0 	movw	r1, #43232	; 0xa8e0
300034fe:	f64a 2044 	movw	r0, #43588	; 0xaa44
30003502:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003506:	f640 225c 	movw	r2, #2652	; 0xa5c
3000350a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000350e:	f012 fb4f 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
30003512:	2001      	movs	r0, #1
30003514:	e6ac      	b.n	30003270 <cmd_erase_proc+0x37c>
        if (st_info->boot_offset > 0 && backup_boot(storage)) {
30003516:	4620      	mov	r0, r4
30003518:	f7ff f9b8 	bl	3000288c <backup_boot>
3000351c:	2800      	cmp	r0, #0
3000351e:	f43f ae0a 	beq.w	30003136 <cmd_erase_proc+0x242>
            ERROR("backup spl error!\n");
30003522:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
30003526:	f64a 2044 	movw	r0, #43588	; 0xaa44
3000352a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000352e:	f640 12ac 	movw	r2, #2476	; 0x9ac
30003532:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003536:	f012 fb3b 	bl	30015bb0 <_printf>
    enum dl_err_code err = ERR_UNKNOWN;
3000353a:	2001      	movs	r0, #1
3000353c:	e63b      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        return 0;
3000353e:	2200      	movs	r2, #0
30003540:	2300      	movs	r3, #0
30003542:	e9cd 2308 	strd	r2, r3, [r13, #32]
30003546:	e73e      	b.n	300033c6 <cmd_erase_proc+0x4d2>
        size_pri = round_up(size_pri, st_info->erase_grp_sz);
30003548:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
3000354c:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
30003550:	e720      	b.n	30003394 <cmd_erase_proc+0x4a0>
30003552:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
30003556:	e9cd 2306 	strd	r2, r3, [r13, #24]
3000355a:	e6f9      	b.n	30003350 <cmd_erase_proc+0x45c>
            ERROR("switch partition fail\n");
3000355c:	f64a 01e0 	movw	r1, #43232	; 0xa8e0
30003560:	f64a 302c 	movw	r0, #43820	; 0xab2c
30003564:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003568:	f640 2254 	movw	r2, #2644	; 0xa54
3000356c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003570:	f012 fb1e 	bl	30015bb0 <_printf>
            err = ERR_PT_ERASE_FAIL;
30003574:	200a      	movs	r0, #10
30003576:	e67b      	b.n	30003270 <cmd_erase_proc+0x37c>
        ERROR("erase primary gpt header error!\n");
30003578:	f64a 01b8 	movw	r1, #43192	; 0xa8b8
3000357c:	f64a 20a8 	movw	r0, #43688	; 0xaaa8
30003580:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003584:	f44f 621c 	mov.w	r2, #2496	; 0x9c0
30003588:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000358c:	f012 fb10 	bl	30015bb0 <_printf>
        err = ERR_PT_ERASE_FAIL;
30003590:	200a      	movs	r0, #10
30003592:	e610      	b.n	300031b6 <cmd_erase_proc+0x2c2>
        if (ptn % st_info->erase_grp_sz != 0
30003594:	f8da 3080 	ldr.w	r3, [r10, #128]	; 0x80
30003598:	4639      	mov	r1, r7
3000359a:	9806      	ldr	r0, [sp, #24]
3000359c:	461a      	mov	r2, r3
3000359e:	4633      	mov	r3, r6
300035a0:	4692      	mov	r10, r2
300035a2:	f016 fc3d 	bl	30019e20 <__aeabi_uldivmod>
300035a6:	4313      	orrs	r3, r2
300035a8:	d108      	bne.n	300035bc <cmd_erase_proc+0x6c8>
                || size % st_info->erase_grp_sz != 0) {
300035aa:	4652      	mov	r2, r10
300035ac:	4633      	mov	r3, r6
300035ae:	4640      	mov	r0, r8
300035b0:	4649      	mov	r1, r9
300035b2:	f016 fc35 	bl	30019e20 <__aeabi_uldivmod>
300035b6:	4313      	orrs	r3, r2
300035b8:	f43f ae64 	beq.w	30003284 <cmd_erase_proc+0x390>
            ERROR("the size of the partition in nor flash is not aligned to erase group size\n");
300035bc:	f64a 01c8 	movw	r1, #43208	; 0xa8c8
300035c0:	f64a 30e4 	movw	r0, #44004	; 0xabe4
300035c4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300035c8:	f640 221e 	movw	r2, #2590	; 0xa1e
300035cc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300035d0:	f012 faee 	bl	30015bb0 <_printf>
            err = ERR_PT_OVERLAP;
300035d4:	200b      	movs	r0, #11
300035d6:	e509      	b.n	30002fec <cmd_erase_proc+0xf8>

300035d8 <dloader_init_emmc>:
{
300035d8:	b570      	push	{r4, r5, r6, r14}
    current_dl_state = &storage_dl_state[2];
300035da:	f646 4470 	movw	r4, #27760	; 0x6c70
    storage = setup_storage_dev(MMC, RES_MSHC_SD1, &mmc_cfg);
300035de:	f242 1204 	movw	r2, #8452	; 0x2104
300035e2:	f241 0107 	movw	r1, #4103	; 0x1007
    current_dl_state = &storage_dl_state[2];
300035e6:	f2c3 0402 	movt	r4, #12290	; 0x3002
300035ea:	4b1d      	ldr	r3, [pc, #116]	; (30003660 <dloader_init_emmc+0x88>)
    storage = setup_storage_dev(MMC, RES_MSHC_SD1, &mmc_cfg);
300035ec:	f2c3 0202 	movt	r2, #12290	; 0x3002
300035f0:	2000      	movs	r0, #0
300035f2:	f2c0 0118 	movt	r1, #24
    current_dl_state = &storage_dl_state[2];
300035f6:	6023      	str	r3, [r4, #0]
    storage = setup_storage_dev(MMC, RES_MSHC_SD1, &mmc_cfg);
300035f8:	f015 fb5a 	bl	30018cb0 <setup_storage_dev>
    if (!storage) {
300035fc:	b190      	cbz	r0, 30003624 <dloader_init_emmc+0x4c>
    ptdev = ptdev_setup(storage, 0);
300035fe:	2200      	movs	r2, #0
30003600:	2300      	movs	r3, #0
30003602:	4605      	mov	r5, r0
30003604:	f015 fa0a 	bl	30018a1c <ptdev_setup>
    if (!ptdev) {
30003608:	4606      	mov	r6, r0
3000360a:	b1d0      	cbz	r0, 30003642 <dloader_init_emmc+0x6a>
    current_dl_state->storage = storage;
3000360c:	6824      	ldr	r4, [r4, #0]
    st_info->block_size = storage->get_block_size(storage);
3000360e:	4628      	mov	r0, r5
30003610:	6a2b      	ldr	r3, [r5, #32]
    current_dl_state->ptdev = ptdev;
30003612:	e9c4 5602 	strd	r5, r6, [r4, #8]
    st_info->block_size = storage->get_block_size(storage);
30003616:	4798      	blx	r3
30003618:	6720      	str	r0, [r4, #112]	; 0x70
    ptdev_read_table(ptdev);
3000361a:	4630      	mov	r0, r6
3000361c:	f014 fb74 	bl	30017d08 <ptdev_read_table>
    return 0;
30003620:	2000      	movs	r0, #0
}
30003622:	bd70      	pop	{r4, r5, r6, r15}
        ERROR("storage get error!\n");
30003624:	f24a 61fc 	movw	r1, #42748	; 0xa6fc
30003628:	f24b 6040 	movw	r0, #46656	; 0xb640
3000362c:	f640 42a6 	movw	r2, #3238	; 0xca6
30003630:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003634:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003638:	f012 faba 	bl	30015bb0 <_printf>
        return -1;
3000363c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
30003640:	bd70      	pop	{r4, r5, r6, r15}
        ERROR("ptdev get error!\n");
30003642:	f24a 61fc 	movw	r1, #42748	; 0xa6fc
30003646:	f24b 6064 	movw	r0, #46692	; 0xb664
3000364a:	f640 42ad 	movw	r2, #3245	; 0xcad
3000364e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003652:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003656:	f012 faab 	bl	30015bb0 <_printf>
3000365a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000365e:	bd70      	pop	{r4, r5, r6, r15}
30003660:	30022370 	.word	0x30022370

30003664 <dloader_main>:
}

static inline uint32_t sdrv_common_reg_get_value(uint32_t reg, uint32_t mask)
{
    return readl(_ioaddr(SDRV_GENERAL_REG(reg))) & mask;
30003664:	f44f 4200 	mov.w	r2, #32768	; 0x8000
#define LIST_INITIAL_VALUE(list) { &(list), &(list) }
#define LIST_INITIAL_CLEARED_VALUE { NULL, NULL }

static inline void list_initialize(struct list_node *list)
{
    list->prev = list->next = list;
30003668:	f242 1330 	movw	r3, #8496	; 0x2130
3000366c:	f6cf 0241 	movt	r2, #63553	; 0xf841
    current_dl_state = NULL;
30003670:	f646 4170 	movw	r1, #27760	; 0x6c70
30003674:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30003678:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
3000367c:	6812      	ldr	r2, [r2, #0]
3000367e:	f503 7790 	add.w	r7, r3, #288	; 0x120
30003682:	f503 7610 	add.w	r6, r3, #576	; 0x240
30003686:	f002 020f 	and.w	r2, r2, #15
3000368a:	f503 7558 	add.w	r5, r3, #864	; 0x360
3000368e:	f503 6490 	add.w	r4, r3, #1152	; 0x480
30003692:	f503 60b4 	add.w	r0, r3, #1440	; 0x5a0
    current_dl_state = NULL;
30003696:	f04f 0c00 	mov.w	r12, #0
3000369a:	f2c3 0102 	movt	r1, #12290	; 0x3002
    if (sdrv_common_reg_get_value(SDRV_REG_BOOTREASON,
3000369e:	2a0a      	cmp	r2, #10
300036a0:	605b      	str	r3, [r3, #4]
{
300036a2:	b08f      	sub	sp, #60	; 0x3c
300036a4:	601b      	str	r3, [r3, #0]
300036a6:	f8c3 7124 	str.w	r7, [r3, #292]	; 0x124
300036aa:	f8c3 7120 	str.w	r7, [r3, #288]	; 0x120
300036ae:	f8c3 6244 	str.w	r6, [r3, #580]	; 0x244
300036b2:	f8c3 6240 	str.w	r6, [r3, #576]	; 0x240
300036b6:	f8c3 5364 	str.w	r5, [r3, #868]	; 0x364
300036ba:	f8c3 5360 	str.w	r5, [r3, #864]	; 0x360
300036be:	f8c3 4484 	str.w	r4, [r3, #1156]	; 0x484
300036c2:	f8c3 4480 	str.w	r4, [r3, #1152]	; 0x480
300036c6:	f8c3 05a4 	str.w	r0, [r3, #1444]	; 0x5a4
300036ca:	f8c3 05a0 	str.w	r0, [r3, #1440]	; 0x5a0
    current_dl_state = NULL;
300036ce:	f8c1 c000 	str.w	r12, [r1]
    if (sdrv_common_reg_get_value(SDRV_REG_BOOTREASON,
300036d2:	f000 80ba 	beq.w	3000384a <dloader_main+0x1e6>
    do_md5_check = false;
300036d6:	f646 4374 	movw	r3, #27764	; 0x6c74
300036da:	2200      	movs	r2, #0
300036dc:	f2c3 0302 	movt	r3, #12290	; 0x3002
    ret = hal_port_creat_handle(&handle, RES_PAD_CONTROL_SEC_TMR3_CH0);
300036e0:	f44f 61a0 	mov.w	r1, #1280	; 0x500
300036e4:	af02      	add	r7, sp, #8
300036e6:	4638      	mov	r0, r7
300036e8:	f2c8 1194 	movt	r1, #33172	; 0x8194
    do_md5_check = false;
300036ec:	701a      	strb	r2, [r3, #0]
    ret = hal_port_creat_handle(&handle, RES_PAD_CONTROL_SEC_TMR3_CH0);
300036ee:	f00c f8db 	bl	3000f8a8 <hal_port_creat_handle>
    if (!ret) {
300036f2:	2800      	cmp	r0, #0
300036f4:	f000 80c6 	beq.w	30003884 <dloader_main+0x220>
    ret = hal_port_init(handle);
300036f8:	9802      	ldr	r0, [sp, #8]
300036fa:	f00c f977 	bl	3000f9ec <hal_port_init>
300036fe:	4604      	mov	r4, r0
    hal_port_release_handle(handle);
30003700:	9802      	ldr	r0, [sp, #8]
30003702:	f00c f93b 	bl	3000f97c <hal_port_release_handle>
    if (!ret) {
30003706:	2c00      	cmp	r4, #0
30003708:	f000 80c3 	beq.w	30003892 <dloader_main+0x22e>
    dprintf(CRITICAL, "port init ok.\n");
3000370c:	f24b 60e4 	movw	r0, #46820	; 0xb6e4
30003710:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003714:	f012 fa4c 	bl	30015bb0 <_printf>
    struct fastboot_cmd_desc cmd_list[] = {
30003718:	f24a 65ac 	movw	r5, #42668	; 0xa6ac
3000371c:	463e      	mov	r6, r7
3000371e:	2400      	movs	r4, #0
30003720:	f2c3 0501 	movt	r5, #12289	; 0x3001
30003724:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
30003726:	c60f      	stmia	r6!, {r0, r1, r2, r3}
30003728:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3000372a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3000372c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
30003730:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
        fastboot_register_cmd(cmd_list[i].name, cmd_list[i].cb);
30003734:	5938      	ldr	r0, [r7, r4]
30003736:	193b      	adds	r3, r7, r4
30003738:	3408      	adds	r4, #8
3000373a:	6859      	ldr	r1, [r3, #4]
3000373c:	f00d fb46 	bl	30010dcc <fastboot_register_cmd>
    for (int i = 0; i < fastboot_cmds_count; i++)
30003740:	2c30      	cmp	r4, #48	; 0x30
30003742:	d1f7      	bne.n	30003734 <dloader_main+0xd0>
    fastboot_register_var("product",  get_product());
30003744:	f24b 61f4 	movw	r1, #46836	; 0xb6f4
30003748:	f24b 60f8 	movw	r0, #46840	; 0xb6f8
3000374c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003750:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003754:	f00d fb50 	bl	30010df8 <fastboot_register_var>
    fastboot_register_var("serialno", get_serialno());
30003758:	f24b 7100 	movw	r1, #46848	; 0xb700
3000375c:	f24b 700c 	movw	r0, #46860	; 0xb70c
30003760:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003764:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003768:	f00d fb46 	bl	30010df8 <fastboot_register_var>
    fastboot_register_var("dloader-version", DLOADER_VERSION);
3000376c:	f24b 7118 	movw	r1, #46872	; 0xb718
30003770:	f24b 7024 	movw	r0, #46884	; 0xb724
30003774:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003778:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000377c:	f00d fb3c 	bl	30010df8 <fastboot_register_var>
    fastboot_register_var("dev-stage", "dloader");
30003780:	f24b 7134 	movw	r1, #46900	; 0xb734
30003784:	f24b 703c 	movw	r0, #46908	; 0xb73c
30003788:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000378c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003790:	f00d fb32 	bl	30010df8 <fastboot_register_var>
    snprintf(max_download_size, MAX_RSP_SIZE, "\t0x%x", DL_BUF_SIZE);
30003794:	f24b 7248 	movw	r2, #46920	; 0xb748
30003798:	f646 40b8 	movw	r0, #27832	; 0x6cb8
3000379c:	f2c3 0201 	movt	r2, #12289	; 0x3001
300037a0:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
300037a4:	2140      	movs	r1, #64	; 0x40
300037a6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300037aa:	f012 f991 	bl	30015ad0 <snprintf>
    fastboot_register_var("max-download-size",
300037ae:	f646 41b8 	movw	r1, #27832	; 0x6cb8
300037b2:	f24b 7050 	movw	r0, #46928	; 0xb750
300037b6:	f2c3 0102 	movt	r1, #12290	; 0x3002
300037ba:	f2c3 0001 	movt	r0, #12289	; 0x3001
300037be:	f00d fb1b 	bl	30010df8 <fastboot_register_var>
    storage = setup_storage_dev(OSPI, resid, &ospi_cfg);
300037c2:	f242 1214 	movw	r2, #8468	; 0x2114
300037c6:	f241 0102 	movw	r1, #4098	; 0x1002
300037ca:	f2c3 0202 	movt	r2, #12290	; 0x3002
300037ce:	2001      	movs	r0, #1
300037d0:	f2c4 0148 	movt	r1, #16456	; 0x4048
300037d4:	f015 fa6c 	bl	30018cb0 <setup_storage_dev>
    if (!storage)
300037d8:	4606      	mov	r6, r0
300037da:	b198      	cbz	r0, 30003804 <dloader_main+0x1a0>
    erase_grp_sz = storage->get_erase_group_size(storage);
300037dc:	69c3      	ldr	r3, [r0, #28]
    if (!storage->erase(storage, 0, round_up(SFS_SIZE, erase_grp_sz))) {
300037de:	f04f 0900 	mov.w	r9, #0
    erase_grp_sz = storage->get_erase_group_size(storage);
300037e2:	4798      	blx	r3
    if (!storage->erase(storage, 0, round_up(SFS_SIZE, erase_grp_sz))) {
300037e4:	6937      	ldr	r7, [r6, #16]
300037e6:	4680      	mov	r8, r0
    if (aligned == 0 || size < aligned)
300037e8:	1e43      	subs	r3, r0, #1
300037ea:	2b7f      	cmp	r3, #127	; 0x7f
300037ec:	d915      	bls.n	3000381a <dloader_main+0x1b6>
300037ee:	e9cd 8900 	strd	r8, r9, [r13]
300037f2:	4630      	mov	r0, r6
300037f4:	2200      	movs	r2, #0
300037f6:	2300      	movs	r3, #0
300037f8:	47b8      	blx	r7
300037fa:	2800      	cmp	r0, #0
300037fc:	d03b      	beq.n	30003876 <dloader_main+0x212>
    storage->release(storage);
300037fe:	6af3      	ldr	r3, [r6, #44]	; 0x2c
30003800:	4630      	mov	r0, r6
30003802:	4798      	blx	r3
    fb_data = fastboot_common_init((void *)dl_base, DL_BUF_SIZE);
30003804:	2000      	movs	r0, #0
30003806:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
3000380a:	f2c3 0070 	movt	r0, #12400	; 0x3070
3000380e:	f010 fe07 	bl	30014420 <fastboot_common_init>
}
30003812:	2000      	movs	r0, #0
30003814:	b00f      	add	sp, #60	; 0x3c
30003816:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    mod = size % aligned;
3000381a:	4602      	mov	r2, r0
3000381c:	464b      	mov	r3, r9
3000381e:	2080      	movs	r0, #128	; 0x80
30003820:	2100      	movs	r1, #0
30003822:	f016 fafd 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30003826:	ea52 0103 	orrs.w	r1, r2, r3
3000382a:	bf04      	itt	eq
3000382c:	f04f 0880 	moveq.w	r8, #128	; 0x80
30003830:	f04f 0900 	moveq.w	r9, #0
30003834:	d0db      	beq.n	300037ee <dloader_main+0x18a>
30003836:	f118 0480 	adds.w	r4, r8, #128	; 0x80
3000383a:	f149 0500 	adc.w	r5, r9, #0
3000383e:	1aa4      	subs	r4, r4, r2
30003840:	46a0      	mov	r8, r4
30003842:	eb65 0503 	sbc.w	r5, r5, r3
30003846:	46a9      	mov	r9, r5
30003848:	e7d1      	b.n	300037ee <dloader_main+0x18a>
3000384a:	f44f 4420 	mov.w	r4, #40960	; 0xa000
3000384e:	f6cf 0441 	movt	r4, #63553	; 0xf841
30003852:	6823      	ldr	r3, [r4, #0]
        while (!sdrv_common_reg_get_value(SDRV_REG_STATUS,
30003854:	069a      	lsls	r2, r3, #26
30003856:	f53f af3e 	bmi.w	300036d6 <dloader_main+0x72>
            printf("dloader wait for ospi handover done!\n");
3000385a:	f24b 6584 	movw	r5, #46724	; 0xb684
3000385e:	f2c3 0501 	movt	r5, #12289	; 0x3001
            thread_sleep(100);
30003862:	2064      	movs	r0, #100	; 0x64
30003864:	f00e fc14 	bl	30012090 <thread_sleep>
            printf("dloader wait for ospi handover done!\n");
30003868:	4628      	mov	r0, r5
3000386a:	f012 f9a1 	bl	30015bb0 <_printf>
3000386e:	6823      	ldr	r3, [r4, #0]
        while (!sdrv_common_reg_get_value(SDRV_REG_STATUS,
30003870:	069b      	lsls	r3, r3, #26
30003872:	d5f6      	bpl.n	30003862 <dloader_main+0x1fe>
30003874:	e72f      	b.n	300036d6 <dloader_main+0x72>
        printf("erase sfs successfully!\n");
30003876:	f24b 7064 	movw	r0, #46948	; 0xb764
3000387a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000387e:	f012 f997 	bl	30015bb0 <_printf>
30003882:	e7bc      	b.n	300037fe <dloader_main+0x19a>
        dprintf(CRITICAL, "hal_port_creat_handle fail.\n");
30003884:	f24b 60ac 	movw	r0, #46764	; 0xb6ac
30003888:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000388c:	f012 f990 	bl	30015bb0 <_printf>
30003890:	e742      	b.n	30003718 <dloader_main+0xb4>
        dprintf(CRITICAL, "hal_port_init fail.\n");
30003892:	f24b 60cc 	movw	r0, #46796	; 0xb6cc
30003896:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000389a:	f012 f989 	bl	30015bb0 <_printf>
3000389e:	e73b      	b.n	30003718 <dloader_main+0xb4>

300038a0 <dloader_entry>:
    dloader_main(0, NULL);
300038a0:	2100      	movs	r1, #0
300038a2:	4608      	mov	r0, r1
300038a4:	f7ff bede 	b.w	30003664 <dloader_main>

300038a8 <padding_avb_footer.part.7.constprop.16>:
static bool padding_avb_footer(struct storage_device *storage,
300038a8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    if (!(storage->read(storage, ptn + last_block,
300038ac:	f04f 5c4a 	mov.w	r12, #847249408	; 0x32800000
static bool padding_avb_footer(struct storage_device *storage,
300038b0:	b096      	sub	sp, #88	; 0x58
    if (!(storage->read(storage, ptn + last_block,
300038b2:	6881      	ldr	r1, [r0, #8]
static bool padding_avb_footer(struct storage_device *storage,
300038b4:	4681      	mov	r9, r0
    if (!(storage->read(storage, ptn + last_block,
300038b6:	f8cd c000 	str.w	r12, [r13]
static bool padding_avb_footer(struct storage_device *storage,
300038ba:	e9dd 671e 	ldrd	r6, r7, [r13, #120]	; 0x78
300038be:	f8dd 8088 	ldr.w	r8, [r13, #136]	; 0x88
    if (!(storage->read(storage, ptn + last_block,
300038c2:	18b4      	adds	r4, r6, r2
    last_block = pt_size - block_size;
300038c4:	4646      	mov	r6, r8
    if (!(storage->read(storage, ptn + last_block,
300038c6:	eb47 0503 	adc.w	r5, r7, r3
    last_block = pt_size - block_size;
300038ca:	2700      	movs	r7, #0
    if (!(storage->read(storage, ptn + last_block,
300038cc:	ebb4 0408 	subs.w	r4, r4, r8
300038d0:	4622      	mov	r2, r4
300038d2:	eb65 0507 	sbc.w	r5, r5, r7
300038d6:	e9cd 6702 	strd	r6, r7, [r13, #8]
300038da:	462b      	mov	r3, r5
300038dc:	e9cd 2304 	strd	r2, r3, [r13, #16]
300038e0:	4788      	blx	r1
300038e2:	b938      	cbnz	r0, 300038f4 <padding_avb_footer.part.7.constprop.16+0x4c>
    if (!image_sz || !footer)
300038e4:	e9dd 3420 	ldrd	r3, r4, [r13, #128]	; 0x80
300038e8:	4682      	mov	r10, r0
300038ea:	4323      	orrs	r3, r4
300038ec:	d112      	bne.n	30003914 <padding_avb_footer.part.7.constprop.16+0x6c>
}
300038ee:	b016      	add	sp, #88	; 0x58
300038f0:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        ERROR  ("read footer error!");
300038f4:	f24a 7134 	movw	r1, #42804	; 0xa734
300038f8:	f64b 10d4 	movw	r0, #47572	; 0xb9d4
300038fc:	f44f 72d7 	mov.w	r2, #430	; 0x1ae
30003900:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003904:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003908:	f012 f952 	bl	30015bb0 <_printf>
    return false;
3000390c:	2000      	movs	r0, #0
}
3000390e:	b016      	add	sp, #88	; 0x58
30003910:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    memset(footer, 0x0, AVB_FOOTER_SIZE);
30003914:	4651      	mov	r1, r10
30003916:	2224      	movs	r2, #36	; 0x24
30003918:	a80b      	add	r0, sp, #44	; 0x2c
3000391a:	f011 e82a 	blx	30014970 <memset>
    memcpy(footer->magic, AVB_FOOTER_MAGIC, AVB_FOOTER_MAGIC_LEN);
3000391e:	f245 6341 	movw	r3, #22081	; 0x5641
    footer->version_major = avb_htobe32(AVB_FOOTER_VERSION_MAJOR);
30003922:	2001      	movs	r0, #1
    memcpy(footer->magic, AVB_FOOTER_MAGIC, AVB_FOOTER_MAGIC_LEN);
30003924:	f2c6 6342 	movt	r3, #26178	; 0x6642
30003928:	9306      	str	r3, [sp, #24]
    footer->version_major = avb_htobe32(AVB_FOOTER_VERSION_MAJOR);
3000392a:	f010 ff63 	bl	300147f4 <avb_htobe32>
3000392e:	9007      	str	r0, [sp, #28]
    footer->version_minor = avb_htobe32(AVB_FOOTER_VERSION_MINOR);
30003930:	4650      	mov	r0, r10
30003932:	f010 ff5f 	bl	300147f4 <avb_htobe32>
            memcpy((scratch_buf + footer_offset), &footer, sizeof(AvbFooter));
30003936:	f10d 0a18 	add.w	r10, r13, #24
    footer->version_minor = avb_htobe32(AVB_FOOTER_VERSION_MINOR);
3000393a:	9008      	str	r0, [sp, #32]
    footer->original_image_size = avb_htobe64(image_sz);
3000393c:	e9dd 0120 	ldrd	r0, r1, [r13, #128]	; 0x80
30003940:	f010 ff66 	bl	30014810 <avb_htobe64>
    memcpy(&(footer->reserved[offset]), SDRV_FOOTER, SDRV_FOOTER_LEN);
30003944:	f64b 13c8 	movw	r3, #47560	; 0xb9c8
            memcpy((scratch_buf + footer_offset), &footer, sizeof(AvbFooter));
30003948:	f64f 7cc0 	movw	r12, #65472	; 0xffc0
    memcpy(&(footer->reserved[offset]), SDRV_FOOTER, SDRV_FOOTER_LEN);
3000394c:	f2c3 0301 	movt	r3, #12289	; 0x3001
            memcpy((scratch_buf + footer_offset), &footer, sizeof(AvbFooter));
30003950:	f2c3 2c7f 	movt	r12, #12927	; 0x327f
30003954:	44c4      	add	r12, r8
30003956:	f10d 0858 	add.w	r8, r13, #88	; 0x58
    footer->original_image_size = avb_htobe64(image_sz);
3000395a:	e9cd 0109 	strd	r0, r1, [r13, #36]	; 0x24
    memcpy(&(footer->reserved[offset]), SDRV_FOOTER, SDRV_FOOTER_LEN);
3000395e:	e893 0003 	ldmia.w	r3, {r0, r1}
30003962:	e948 0102 	strd	r0, r1, [r8, #-8]
            memcpy((scratch_buf + footer_offset), &footer, sizeof(AvbFooter));
30003966:	46d6      	mov	r14, r10
30003968:	f10c 0c10 	add.w	r12, r12, #16
3000396c:	f10a 0a10 	add.w	r10, r10, #16
30003970:	e8be 000f 	ldmia.w	r14!, {r0, r1, r2, r3}
30003974:	f84c 0c10 	str.w	r0, [r12, #-16]
30003978:	f84c 1c0c 	str.w	r1, [r12, #-12]
3000397c:	45c6      	cmp	r14, r8
3000397e:	f84c 2c08 	str.w	r2, [r12, #-8]
30003982:	f84c 3c04 	str.w	r3, [r12, #-4]
30003986:	d1ee      	bne.n	30003966 <padding_avb_footer.part.7.constprop.16+0xbe>
            storage->write(storage, ptn + last_block, scratch_buf, block_size);
30003988:	f04f 514a 	mov.w	r1, #847249408	; 0x32800000
3000398c:	4648      	mov	r0, r9
3000398e:	e9cd 6702 	strd	r6, r7, [r13, #8]
30003992:	9100      	str	r1, [sp, #0]
30003994:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
30003998:	f8d9 100c 	ldr.w	r1, [r9, #12]
3000399c:	4788      	blx	r1
            return true;
3000399e:	2001      	movs	r0, #1
}
300039a0:	b016      	add	sp, #88	; 0x58
300039a2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
300039a6:	bf00      	nop

300039a8 <str2hex.constprop.15>:
static void str2hex(const char *str, uint32_t str_len, uint8_t *hex,
300039a8:	b470      	push	{r4, r5, r6}
300039aa:	3901      	subs	r1, #1
        hex[i] = 0;
300039ac:	2400      	movs	r4, #0
300039ae:	f100 0520 	add.w	r5, r0, #32
300039b2:	e01a      	b.n	300039ea <str2hex.constprop.15+0x42>
        return c - 'a' + 10;
300039b4:	f1a2 0357 	sub.w	r3, r2, #87	; 0x57
300039b8:	b2db      	uxtb	r3, r3
300039ba:	011b      	lsls	r3, r3, #4
300039bc:	b2da      	uxtb	r2, r3
300039be:	b25b      	sxtb	r3, r3
        hex[i] = (char2hex(str[i * 2]) & 0xF) << 4;
300039c0:	700a      	strb	r2, [r1, #0]
        hex[i] |= char2hex(str[i * 2 + 1]) & 0xF;
300039c2:	7846      	ldrb	r6, [r0, #1]
    if (c >= '0' && c <= '9') {
300039c4:	f1a6 0230 	sub.w	r2, r6, #48	; 0x30
300039c8:	b2d2      	uxtb	r2, r2
300039ca:	2a09      	cmp	r2, #9
300039cc:	bf9c      	itt	ls
300039ce:	4313      	orrls	r3, r2
300039d0:	b25b      	sxtbls	r3, r3
300039d2:	d906      	bls.n	300039e2 <str2hex.constprop.15+0x3a>
    else if (c >= 'a' && c <= 'f') {
300039d4:	f1a6 0261 	sub.w	r2, r6, #97	; 0x61
300039d8:	2a05      	cmp	r2, #5
300039da:	d820      	bhi.n	30003a1e <str2hex.constprop.15+0x76>
        return c - 'a' + 10;
300039dc:	3e57      	subs	r6, #87	; 0x57
300039de:	4333      	orrs	r3, r6
300039e0:	b25b      	sxtb	r3, r3
        hex[i] |= char2hex(str[i * 2 + 1]) & 0xF;
300039e2:	700b      	strb	r3, [r1, #0]
300039e4:	3002      	adds	r0, #2
    for (uint32_t i = 0; i < str_len / 2 && i < hex_len; i++) {
300039e6:	4285      	cmp	r5, r0
300039e8:	d026      	beq.n	30003a38 <str2hex.constprop.15+0x90>
        hex[i] = 0;
300039ea:	f801 4f01 	strb.w	r4, [r1, #1]!
        hex[i] = (char2hex(str[i * 2]) & 0xF) << 4;
300039ee:	7802      	ldrb	r2, [r0, #0]
    if (c >= '0' && c <= '9') {
300039f0:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
300039f4:	b2db      	uxtb	r3, r3
300039f6:	2b09      	cmp	r3, #9
300039f8:	d9df      	bls.n	300039ba <str2hex.constprop.15+0x12>
    else if (c >= 'a' && c <= 'f') {
300039fa:	f1a2 0361 	sub.w	r3, r2, #97	; 0x61
300039fe:	2b05      	cmp	r3, #5
30003a00:	d9d8      	bls.n	300039b4 <str2hex.constprop.15+0xc>
    else if (c >= 'A' && c <= 'F') {
30003a02:	f1a2 0341 	sub.w	r3, r2, #65	; 0x41
30003a06:	2b05      	cmp	r3, #5
30003a08:	bf8b      	itete	hi
30003a0a:	2300      	movhi	r3, #0
        return c - 'A' + 10;
30003a0c:	f1a2 0337 	subls.w	r3, r2, #55	; 0x37
    else if (c >= 'A' && c <= 'F') {
30003a10:	461a      	movhi	r2, r3
30003a12:	b2db      	uxtbls	r3, r3
30003a14:	bf9e      	ittt	ls
30003a16:	011b      	lslls	r3, r3, #4
30003a18:	b2da      	uxtbls	r2, r3
30003a1a:	b25b      	sxtbls	r3, r3
30003a1c:	e7d0      	b.n	300039c0 <str2hex.constprop.15+0x18>
30003a1e:	f1a6 0241 	sub.w	r2, r6, #65	; 0x41
30003a22:	2a05      	cmp	r2, #5
        return c - 'A' + 10;
30003a24:	bf9c      	itt	ls
30003a26:	3e37      	subls	r6, #55	; 0x37
30003a28:	4333      	orrls	r3, r6
30003a2a:	f100 0002 	add.w	r0, r0, #2
30003a2e:	bf98      	it	ls
30003a30:	b25b      	sxtbls	r3, r3
    for (uint32_t i = 0; i < str_len / 2 && i < hex_len; i++) {
30003a32:	4285      	cmp	r5, r0
        hex[i] |= char2hex(str[i * 2 + 1]) & 0xF;
30003a34:	700b      	strb	r3, [r1, #0]
    for (uint32_t i = 0; i < str_len / 2 && i < hex_len; i++) {
30003a36:	d1d8      	bne.n	300039ea <str2hex.constprop.15+0x42>
}
30003a38:	bc70      	pop	{r4, r5, r6}
30003a3a:	4770      	bx	r14

30003a3c <cmd_program_efuse_proc>:
{
30003a3c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    uint8_t md5_r[MD5_LEN] = {0};
30003a40:	2300      	movs	r3, #0
{
30003a42:	b090      	sub	sp, #64	; 0x40
30003a44:	460c      	mov	r4, r1
30003a46:	4681      	mov	r9, r0
    val_pos = strchr(arg, token);
30003a48:	213a      	movs	r1, #58	; 0x3a
30003a4a:	4620      	mov	r0, r4
    uint8_t md5_r[MD5_LEN] = {0};
30003a4c:	e9cd 3308 	strd	r3, r3, [r13, #32]
30003a50:	e9cd 330a 	strd	r3, r3, [r13, #40]	; 0x28
    uint8_t md5_calc[MD5_LEN] = {0};
30003a54:	930c      	str	r3, [sp, #48]	; 0x30
    char val_str[UINT32_HEX_STR_LEN + 1]   = {0};
30003a56:	9302      	str	r3, [sp, #8]
    char index_str[UINT32_HEX_STR_LEN + 1] = {0};
30003a58:	9305      	str	r3, [sp, #20]
    uint8_t md5_calc[MD5_LEN] = {0};
30003a5a:	e9cd 330d 	strd	r3, r3, [r13, #52]	; 0x34
30003a5e:	930f      	str	r3, [sp, #60]	; 0x3c
    char val_str[UINT32_HEX_STR_LEN + 1]   = {0};
30003a60:	9303      	str	r3, [sp, #12]
30003a62:	f88d 3010 	strb.w	r3, [r13, #16]
    char index_str[UINT32_HEX_STR_LEN + 1] = {0};
30003a66:	9306      	str	r3, [sp, #24]
30003a68:	f88d 301c 	strb.w	r3, [r13, #28]
    val_pos = strchr(arg, token);
30003a6c:	f012 f8e2 	bl	30015c34 <strchr>
    md5_pos = strrchr(arg, token);
30003a70:	213a      	movs	r1, #58	; 0x3a
    val_pos = strchr(arg, token);
30003a72:	4605      	mov	r5, r0
    md5_pos = strrchr(arg, token);
30003a74:	4620      	mov	r0, r4
30003a76:	f012 f9b7 	bl	30015de8 <strrchr>
    if (!val_pos || val_pos == md5_pos) {
30003a7a:	4285      	cmp	r5, r0
30003a7c:	bf18      	it	ne
30003a7e:	2d00      	cmpne	r5, #0
30003a80:	d06b      	beq.n	30003b5a <cmd_program_efuse_proc+0x11e>
30003a82:	4607      	mov	r7, r0
    arg_len = strlen(arg);
30003a84:	4620      	mov	r0, r4
30003a86:	f012 f953 	bl	30015d30 <strlen>
    val_str_len = md5_pos - val_pos - 1;
30003a8a:	1b7e      	subs	r6, r7, r5
    index_str_len = val_pos - arg;
30003a8c:	eba5 0a04 	sub.w	r10, r5, r4
    val_str_len = md5_pos - val_pos - 1;
30003a90:	3e01      	subs	r6, #1
            || val_str_len > UINT32_HEX_STR_LEN
30003a92:	2e08      	cmp	r6, #8
30003a94:	bf98      	it	ls
30003a96:	f1ba 0f08 	cmpls.w	r10, #8
30003a9a:	bf8c      	ite	hi
30003a9c:	f04f 0801 	movhi.w	r8, #1
30003aa0:	f04f 0800 	movls.w	r8, #0
    md5_str_len = arg_len - index_str_len - val_str_len - 2;
30003aa4:	eba0 000a 	sub.w	r0, r0, r10
30003aa8:	1b80      	subs	r0, r0, r6
            || md5_str_len != MD5_LEN * 2) {
30003aaa:	2822      	cmp	r0, #34	; 0x22
30003aac:	bf18      	it	ne
30003aae:	f048 0801 	orrne.w	r8, r8, #1
30003ab2:	f1b8 0f00 	cmp.w	r8, #0
30003ab6:	d027      	beq.n	30003b08 <cmd_program_efuse_proc+0xcc>
        ERROR("arg len error:%s!\n", arg);
30003ab8:	f64a 1120 	movw	r1, #43296	; 0xa920
30003abc:	f24b 5008 	movw	r0, #46344	; 0xb508
30003ac0:	4623      	mov	r3, r4
30003ac2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003ac6:	f44f 6230 	mov.w	r2, #2816	; 0xb00
30003aca:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003ace:	f012 f86f 	bl	30015bb0 <_printf>
        return 2;
30003ad2:	2302      	movs	r3, #2
        ERROR("index ret:%d!\n", ret);
30003ad4:	f64a 1130 	movw	r1, #43312	; 0xa930
30003ad8:	f24b 5048 	movw	r0, #46408	; 0xb548
30003adc:	f640 322d 	movw	r2, #2861	; 0xb2d
30003ae0:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003ae4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003ae8:	f012 f862 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(ERR_EFUSE_INDEX, ""));
30003aec:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003af0:	2017      	movs	r0, #23
30003af2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003af6:	f7fe ff5d 	bl	300029b4 <response_error>
30003afa:	4601      	mov	r1, r0
30003afc:	4648      	mov	r0, r9
30003afe:	f010 fd8f 	bl	30014620 <fastboot_common_fail>
}
30003b02:	b010      	add	sp, #64	; 0x40
30003b04:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    str2hex(md5_pos + 1, md5_str_len, md5_r, MD5_LEN);
30003b08:	1c78      	adds	r0, r7, #1
30003b0a:	a908      	add	r1, sp, #32
30003b0c:	f7ff ff4c 	bl	300039a8 <str2hex.constprop.15>
    md5((const unsigned char *)arg, val_str_len + index_str_len + 1, md5_calc);
30003b10:	f10a 0101 	add.w	r1, r10, #1
30003b14:	aa0c      	add	r2, sp, #48	; 0x30
30003b16:	4620      	mov	r0, r4
30003b18:	4431      	add	r1, r6
30003b1a:	f012 fd35 	bl	30016588 <md5>
    if (memcmp(md5_calc, md5_r, MD5_LEN)) {
30003b1e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
30003b20:	9b08      	ldr	r3, [sp, #32]
30003b22:	429a      	cmp	r2, r3
30003b24:	d028      	beq.n	30003b78 <cmd_program_efuse_proc+0x13c>
        ERROR("md5 check fail!\n");
30003b26:	f64a 1120 	movw	r1, #43296	; 0xa920
30003b2a:	f64b 10a8 	movw	r0, #47528	; 0xb9a8
30003b2e:	f640 3208 	movw	r2, #2824	; 0xb08
30003b32:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003b36:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003b3a:	f012 f839 	bl	30015bb0 <_printf>
30003b3e:	2300      	movs	r3, #0
30003b40:	2110      	movs	r1, #16
30003b42:	aa08      	add	r2, sp, #32
30003b44:	4610      	mov	r0, r2
30003b46:	f010 fbf3 	bl	30014330 <hexdump8_ex>
30003b4a:	2300      	movs	r3, #0
30003b4c:	2110      	movs	r1, #16
30003b4e:	aa0c      	add	r2, sp, #48	; 0x30
30003b50:	4610      	mov	r0, r2
30003b52:	f010 fbed 	bl	30014330 <hexdump8_ex>
        return 3;
30003b56:	2303      	movs	r3, #3
30003b58:	e7bc      	b.n	30003ad4 <cmd_program_efuse_proc+0x98>
        ERROR("arg error:%s!\n", arg);
30003b5a:	f64a 1120 	movw	r1, #43296	; 0xa920
30003b5e:	f24b 40ec 	movw	r0, #46316	; 0xb4ec
30003b62:	4623      	mov	r3, r4
30003b64:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003b68:	f640 22f4 	movw	r2, #2804	; 0xaf4
30003b6c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003b70:	f012 f81e 	bl	30015bb0 <_printf>
        return 1;
30003b74:	2301      	movs	r3, #1
30003b76:	e7ad      	b.n	30003ad4 <cmd_program_efuse_proc+0x98>
    if (memcmp(md5_calc, md5_r, MD5_LEN)) {
30003b78:	9a0d      	ldr	r2, [sp, #52]	; 0x34
30003b7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
30003b7c:	429a      	cmp	r2, r3
30003b7e:	d1d2      	bne.n	30003b26 <cmd_program_efuse_proc+0xea>
30003b80:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30003b82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
30003b84:	429a      	cmp	r2, r3
30003b86:	d1ce      	bne.n	30003b26 <cmd_program_efuse_proc+0xea>
30003b88:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
30003b8a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
30003b8c:	429a      	cmp	r2, r3
30003b8e:	d1ca      	bne.n	30003b26 <cmd_program_efuse_proc+0xea>
    strncpy(index_str, arg, index_str_len);
30003b90:	4621      	mov	r1, r4
30003b92:	4652      	mov	r2, r10
30003b94:	a805      	add	r0, sp, #20
30003b96:	f012 f8d7 	bl	30015d48 <strncpy>
    strncpy(val_str, val_pos + 1, val_str_len);
30003b9a:	4632      	mov	r2, r6
30003b9c:	1c69      	adds	r1, r5, #1
30003b9e:	a802      	add	r0, sp, #8
30003ba0:	f012 f8d2 	bl	30015d48 <strncpy>
    *index = strtoul(index_str, NULL, 16);
30003ba4:	4641      	mov	r1, r8
30003ba6:	2210      	movs	r2, #16
30003ba8:	a805      	add	r0, sp, #20
30003baa:	f011 f81b 	bl	30014be4 <strtoul>
30003bae:	4604      	mov	r4, r0
    if (errno || *index > FUSE_INDEX_MAX) {
30003bb0:	f011 f8b8 	bl	30014d24 <__geterrno>
30003bb4:	2cf9      	cmp	r4, #249	; 0xf9
30003bb6:	bf94      	ite	ls
30003bb8:	2100      	movls	r1, #0
30003bba:	2101      	movhi	r1, #1
30003bbc:	6803      	ldr	r3, [r0, #0]
30003bbe:	2b00      	cmp	r3, #0
30003bc0:	bf18      	it	ne
30003bc2:	2101      	movne	r1, #1
30003bc4:	b181      	cbz	r1, 30003be8 <cmd_program_efuse_proc+0x1ac>
        ERROR("strtoul error:%d!\n", errno);
30003bc6:	f011 f8ad 	bl	30014d24 <__geterrno>
30003bca:	f64a 1120 	movw	r1, #43296	; 0xa920
30003bce:	f640 3214 	movw	r2, #2836	; 0xb14
30003bd2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003bd6:	6803      	ldr	r3, [r0, #0]
30003bd8:	f24b 5028 	movw	r0, #46376	; 0xb528
30003bdc:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003be0:	f011 ffe6 	bl	30015bb0 <_printf>
        return 4;
30003be4:	2304      	movs	r3, #4
30003be6:	e775      	b.n	30003ad4 <cmd_program_efuse_proc+0x98>
    *val = strtoul(val_str, NULL, 16);
30003be8:	2210      	movs	r2, #16
30003bea:	a802      	add	r0, sp, #8
30003bec:	f010 fffa 	bl	30014be4 <strtoul>
30003bf0:	9001      	str	r0, [sp, #4]
    if (errno) {
30003bf2:	f011 f897 	bl	30014d24 <__geterrno>
30003bf6:	9901      	ldr	r1, [sp, #4]
30003bf8:	6803      	ldr	r3, [r0, #0]
30003bfa:	bb43      	cbnz	r3, 30003c4e <cmd_program_efuse_proc+0x212>
    ret = fuse_program(fuse_index, fuse_val);
30003bfc:	4620      	mov	r0, r4
30003bfe:	f003 fe51 	bl	300078a4 <fuse_program>
    if (ret) {
30003c02:	4603      	mov	r3, r0
30003c04:	b948      	cbnz	r0, 30003c1a <cmd_program_efuse_proc+0x1de>
    fastboot_common_okay(fb, "");
30003c06:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003c0a:	4648      	mov	r0, r9
30003c0c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003c10:	f010 fd02 	bl	30014618 <fastboot_common_okay>
}
30003c14:	b010      	add	sp, #64	; 0x40
30003c16:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        ERROR("burn efuse fail:%d!\n", ret);
30003c1a:	f64a 1130 	movw	r1, #43312	; 0xa930
30003c1e:	f24b 5064 	movw	r0, #46436	; 0xb564
30003c22:	f640 3238 	movw	r2, #2872	; 0xb38
30003c26:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003c2a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003c2e:	f011 ffbf 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(ERR_EFUSE_BURN, ""));
30003c32:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003c36:	2018      	movs	r0, #24
30003c38:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003c3c:	f7fe feba 	bl	300029b4 <response_error>
30003c40:	4601      	mov	r1, r0
30003c42:	4648      	mov	r0, r9
30003c44:	f010 fcec 	bl	30014620 <fastboot_common_fail>
}
30003c48:	b010      	add	sp, #64	; 0x40
30003c4a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        ERROR("strtoul error:%d!\n", errno);
30003c4e:	f011 f869 	bl	30014d24 <__geterrno>
30003c52:	f64a 1120 	movw	r1, #43296	; 0xa920
30003c56:	f640 321b 	movw	r2, #2843	; 0xb1b
30003c5a:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003c5e:	6803      	ldr	r3, [r0, #0]
30003c60:	f24b 5028 	movw	r0, #46376	; 0xb528
30003c64:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003c68:	f011 ffa2 	bl	30015bb0 <_printf>
        return 5;
30003c6c:	2305      	movs	r3, #5
30003c6e:	e731      	b.n	30003ad4 <cmd_program_efuse_proc+0x98>

30003c70 <cmd_md5_proc>:
{
30003c70:	b5f0      	push	{r4, r5, r6, r7, r14}
30003c72:	460d      	mov	r5, r1
    memset(md5_received, 0x0, MD5_LEN);
30003c74:	f646 46f8 	movw	r6, #27896	; 0x6cf8
{
30003c78:	b08b      	sub	sp, #44	; 0x2c
    char  md5_received_str[MD5_LEN * 2 + 1] = {0};
30003c7a:	2700      	movs	r7, #0
    memset(md5_received, 0x0, MD5_LEN);
30003c7c:	f2c3 0602 	movt	r6, #12290	; 0x3002
{
30003c80:	4684      	mov	r12, r0
    memcpy(md5_received_str, arg, MD5_LEN * 2);
30003c82:	ac01      	add	r4, sp, #4
    memset(md5_received, 0x0, MD5_LEN);
30003c84:	e9c6 7702 	strd	r7, r7, [r6, #8]
30003c88:	e9c6 7700 	strd	r7, r7, [r6]
    memcpy(md5_received_str, arg, MD5_LEN * 2);
30003c8c:	6808      	ldr	r0, [r1, #0]
30003c8e:	68aa      	ldr	r2, [r5, #8]
30003c90:	68eb      	ldr	r3, [r5, #12]
30003c92:	6849      	ldr	r1, [r1, #4]
    char  md5_received_str[MD5_LEN * 2 + 1] = {0};
30003c94:	f88d 7024 	strb.w	r7, [r13, #36]	; 0x24
    memcpy(md5_received_str, arg, MD5_LEN * 2);
30003c98:	c40f      	stmia	r4!, {r0, r1, r2, r3}
30003c9a:	69aa      	ldr	r2, [r5, #24]
30003c9c:	69eb      	ldr	r3, [r5, #28]
30003c9e:	6928      	ldr	r0, [r5, #16]
30003ca0:	6969      	ldr	r1, [r5, #20]
30003ca2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    fastboot_common_okay(fb, "");
30003ca4:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003ca8:	4660      	mov	r0, r12
30003caa:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003cae:	f010 fcb3 	bl	30014618 <fastboot_common_okay>
    str2hex(md5_received_str, MD5_LEN * 2, md5_received, MD5_LEN);
30003cb2:	4631      	mov	r1, r6
30003cb4:	a801      	add	r0, sp, #4
30003cb6:	f7ff fe77 	bl	300039a8 <str2hex.constprop.15>
    do_md5_check = true;
30003cba:	f646 4374 	movw	r3, #27764	; 0x6c74
30003cbe:	2201      	movs	r2, #1
30003cc0:	f2c3 0302 	movt	r3, #12290	; 0x3002
30003cc4:	701a      	strb	r2, [r3, #0]
}
30003cc6:	b00b      	add	sp, #44	; 0x2c
30003cc8:	bdf0      	pop	{r4, r5, r6, r7, r15}
30003cca:	bf00      	nop

30003ccc <cmd_flash_storage>:
{
30003ccc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30003cd0:	f646 4770 	movw	r7, #27760	; 0x6c70
    if (sparse_header->magic == SPARSE_HEADER_MAGIC) {
30003cd4:	f64f 713a 	movw	r1, #65338	; 0xff3a
30003cd8:	6814      	ldr	r4, [r2, #0]
30003cda:	f2c3 0702 	movt	r7, #12290	; 0x3002
30003cde:	f6ce 5126 	movt	r1, #60710	; 0xed26
{
30003ce2:	b0e7      	sub	sp, #412	; 0x19c
30003ce4:	f8d7 a000 	ldr.w	r10, [r7]
    if (sparse_header->magic == SPARSE_HEADER_MAGIC) {
30003ce8:	428c      	cmp	r4, r1
{
30003cea:	9014      	str	r0, [sp, #80]	; 0x50
30003cec:	4690      	mov	r8, r2
30003cee:	9306      	str	r3, [sp, #24]
30003cf0:	f8da 611c 	ldr.w	r6, [r10, #284]	; 0x11c
    if (sparse_header->magic == SPARSE_HEADER_MAGIC) {
30003cf4:	f000 8222 	beq.w	3000413c <cmd_flash_storage+0x470>
    if (pttype == TYPE_PRI_PTB || pttype == TYPE_SUB_PTB) {
30003cf8:	f026 0502 	bic.w	r5, r6, #2
30003cfc:	2d01      	cmp	r5, #1
30003cfe:	d03a      	beq.n	30003d76 <cmd_flash_storage+0xaa>
    else if (pttype > TYPE_NOT_IN_GPT) {
30003d00:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
30003d04:	f240 8254 	bls.w	300041b0 <cmd_flash_storage+0x4e4>
    if (st_info->type == MMC) {
30003d08:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
30003d0c:	2900      	cmp	r1, #0
30003d0e:	f000 83b5 	beq.w	3000447c <cmd_flash_storage+0x7b0>
    else if (st_info->type == OSPI) {
30003d12:	2901      	cmp	r1, #1
30003d14:	f000 84ee 	beq.w	300046f4 <cmd_flash_storage+0xa28>
    if  (pttype == TYPE_SUB_PT_WHOLE) {
30003d18:	2e05      	cmp	r6, #5
30003d1a:	f000 83f1 	beq.w	30004500 <cmd_flash_storage+0x834>
    fastboot_common_okay(fb, "");
30003d1e:	9814      	ldr	r0, [sp, #80]	; 0x50
30003d20:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30003d24:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003d28:	f010 fc76 	bl	30014618 <fastboot_common_okay>
    if (current_dl_state->st_info.type == OSPI)
30003d2c:	683b      	ldr	r3, [r7, #0]
30003d2e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
30003d30:	2b01      	cmp	r3, #1
30003d32:	f040 823a 	bne.w	300041aa <cmd_flash_storage+0x4de>
    val = fuse_read(ospi_reset_index);
30003d36:	20ae      	movs	r0, #174	; 0xae
30003d38:	f003 fd52 	bl	300077e0 <fuse_read>
    if (val & TOGGLE_OSPI_RESET_BIT) {
30003d3c:	0243      	lsls	r3, r0, #9
30003d3e:	f100 8234 	bmi.w	300041aa <cmd_flash_storage+0x4de>
    val |= TOGGLE_OSPI_RESET_BIT;
30003d42:	f440 0480 	orr.w	r4, r0, #4194304	; 0x400000
    ret = fuse_program(ospi_reset_index, val);
30003d46:	4621      	mov	r1, r4
30003d48:	20ae      	movs	r0, #174	; 0xae
30003d4a:	f003 fdab 	bl	300078a4 <fuse_program>
    if (ret) {
30003d4e:	4603      	mov	r3, r0
30003d50:	2800      	cmp	r0, #0
30003d52:	f000 822a 	beq.w	300041aa <cmd_flash_storage+0x4de>
        ERROR("burn efuse fail:%d  index:0x%0x val:0x%0x\n",
30003d56:	22ae      	movs	r2, #174	; 0xae
30003d58:	f24a 7160 	movw	r1, #42848	; 0xa760
30003d5c:	f24b 40b4 	movw	r0, #46260	; 0xb4b4
30003d60:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003d64:	9200      	str	r2, [sp, #0]
30003d66:	f2c3 0001 	movt	r0, #12289	; 0x3001
30003d6a:	9401      	str	r4, [sp, #4]
30003d6c:	f240 228f 	movw	r2, #655	; 0x28f
30003d70:	f011 ff1e 	bl	30015bb0 <_printf>
    return;
30003d74:	e219      	b.n	300041aa <cmd_flash_storage+0x4de>
    if (st_info->type == MMC && !st_info->boot_offset) {
30003d76:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
    char *ptname  = current_dl_state->cur_pt_info.ptname;
30003d7a:	f10a 03d1 	add.w	r3, r10, #209	; 0xd1
    struct storage_device *storage = current_dl_state->storage;
30003d7e:	f8da 0008 	ldr.w	r0, [r10, #8]
    char *ptname  = current_dl_state->cur_pt_info.ptname;
30003d82:	930a      	str	r3, [sp, #40]	; 0x28
    char *sub_ptbname    = current_dl_state->cur_pt_info.sub_ptbname;
30003d84:	f10a 0388 	add.w	r3, r10, #136	; 0x88
    struct storage_device *storage = current_dl_state->storage;
30003d88:	900c      	str	r0, [sp, #48]	; 0x30
    char *sub_ptbname    = current_dl_state->cur_pt_info.sub_ptbname;
30003d8a:	9308      	str	r3, [sp, #32]
    if (st_info->type == MMC && !st_info->boot_offset) {
30003d8c:	2900      	cmp	r1, #0
30003d8e:	f000 835c 	beq.w	3000444a <cmd_flash_storage+0x77e>
    else if (st_info->type == OSPI) {
30003d92:	f111 33ff 	adds.w	r3, r1, #4294967295	; 0xffffffff
30003d96:	bf18      	it	ne
30003d98:	2301      	movne	r3, #1
30003d9a:	9315      	str	r3, [sp, #84]	; 0x54
    struct storage_device *storage = current_dl_state->storage;
30003d9c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
30003d9e:	9312      	str	r3, [sp, #72]	; 0x48
    if (st_info->type == MMC && !st_info->boot_offset) {
30003da0:	9b08      	ldr	r3, [sp, #32]
30003da2:	9316      	str	r3, [sp, #88]	; 0x58
30003da4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
30003da6:	931a      	str	r3, [sp, #104]	; 0x68
30003da8:	f8cd a038 	str.w	r10, [r13, #56]	; 0x38
    struct partition_device *ptdev = current_dl_state->ptdev;
30003dac:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    GPT_header buffered_gpt_header = {0};
30003dae:	f10d 0998 	add.w	r9, r13, #152	; 0x98
30003db2:	2268      	movs	r2, #104	; 0x68
30003db4:	2100      	movs	r1, #0
30003db6:	4648      	mov	r0, r9
    GPT_header storage_gpt_header  = {0};
30003db8:	ad40      	add	r5, sp, #256	; 0x100
    struct partition_device *ptdev = current_dl_state->ptdev;
30003dba:	68e3      	ldr	r3, [r4, #12]
30003dbc:	9318      	str	r3, [sp, #96]	; 0x60
    GPT_header buffered_gpt_header = {0};
30003dbe:	f010 edd8 	blx	30014970 <memset>
    GPT_header storage_gpt_header  = {0};
30003dc2:	2268      	movs	r2, #104	; 0x68
30003dc4:	4628      	mov	r0, r5
30003dc6:	2100      	movs	r1, #0
30003dc8:	f010 edd2 	blx	30014970 <memset>
    block_size = st_info->block_size;
30003dcc:	6f22      	ldr	r2, [r4, #112]	; 0x70
30003dce:	9210      	str	r2, [sp, #64]	; 0x40
    if (!block_size || block_size % 4 != 0) {
30003dd0:	2a00      	cmp	r2, #0
30003dd2:	f000 8363 	beq.w	3000449c <cmd_flash_storage+0x7d0>
30003dd6:	f012 0303 	ands.w	r3, r2, #3
30003dda:	931e      	str	r3, [sp, #120]	; 0x78
30003ddc:	f040 835e 	bne.w	3000449c <cmd_flash_storage+0x7d0>
    blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
30003de0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
30003de4:	fbb3 f3f2 	udiv	r3, r3, r2
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003de8:	3302      	adds	r3, #2
30003dea:	fb02 f303 	mul.w	r3, r2, r3
30003dee:	931c      	str	r3, [sp, #112]	; 0x70
    if (!storage) {
30003df0:	9b12      	ldr	r3, [sp, #72]	; 0x48
30003df2:	2b00      	cmp	r3, #0
30003df4:	f001 8048 	beq.w	30004e88 <cmd_flash_storage+0x11bc>
    if (sz < gpt_sz) {
30003df8:	9b06      	ldr	r3, [sp, #24]
30003dfa:	9a1c      	ldr	r2, [sp, #112]	; 0x70
30003dfc:	4293      	cmp	r3, r2
30003dfe:	f0c0 86e4 	bcc.w	30004bca <cmd_flash_storage+0xefe>
    if (st_info->type == OSPI) {
30003e02:	9b0e      	ldr	r3, [sp, #56]	; 0x38
30003e04:	9a10      	ldr	r2, [sp, #64]	; 0x40
30003e06:	991c      	ldr	r1, [sp, #112]	; 0x70
30003e08:	6e1b      	ldr	r3, [r3, #96]	; 0x60
30003e0a:	eb08 0002 	add.w	r0, r8, r2
30003e0e:	1a89      	subs	r1, r1, r2
30003e10:	9021      	str	r0, [sp, #132]	; 0x84
30003e12:	2b01      	cmp	r3, #1
30003e14:	9120      	str	r1, [sp, #128]	; 0x80
30003e16:	d11a      	bne.n	30003e4e <cmd_flash_storage+0x182>
        ret = gpt_partition_round(((uint8_t *)data + block_size),
30003e18:	9c0e      	ldr	r4, [sp, #56]	; 0x38
                                  storage->get_capacity(storage) - st_info->ptb_offset);
30003e1a:	9812      	ldr	r0, [sp, #72]	; 0x48
        ret = gpt_partition_round(((uint8_t *)data + block_size),
30003e1c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
                                  storage->get_capacity(storage) - st_info->ptb_offset);
30003e20:	6982      	ldr	r2, [r0, #24]
        ret = gpt_partition_round(((uint8_t *)data + block_size),
30003e22:	9322      	str	r3, [sp, #136]	; 0x88
                                  storage->get_capacity(storage) - st_info->ptb_offset);
30003e24:	4790      	blx	r2
        ret = gpt_partition_round(((uint8_t *)data + block_size),
30003e26:	e9d4 341a 	ldrd	r3, r4, [r4, #104]	; 0x68
30003e2a:	9a10      	ldr	r2, [sp, #64]	; 0x40
30003e2c:	469b      	mov	r11, r3
30003e2e:	9b22      	ldr	r3, [sp, #136]	; 0x88
30003e30:	ebb0 0b0b 	subs.w	r11, r0, r11
30003e34:	9821      	ldr	r0, [sp, #132]	; 0x84
30003e36:	eb61 0c04 	sbc.w	r12, r1, r4
30003e3a:	9920      	ldr	r1, [sp, #128]	; 0x80
30003e3c:	e9cd bc00 	strd	r11, r12, [r13]
30003e40:	0049      	lsls	r1, r1, #1
30003e42:	f002 fa0d 	bl	30006260 <gpt_partition_round>
        if (ret) {
30003e46:	4603      	mov	r3, r0
30003e48:	2800      	cmp	r0, #0
30003e4a:	f041 8041 	bne.w	30004ed0 <cmd_flash_storage+0x1204>
    ret = parse_gpt_table_from_buffer(((uint8_t *)data + block_size),
30003e4e:	2100      	movs	r1, #0
30003e50:	464a      	mov	r2, r9
30003e52:	9821      	ldr	r0, [sp, #132]	; 0x84
30003e54:	9100      	str	r1, [sp, #0]
30003e56:	9b10      	ldr	r3, [sp, #64]	; 0x40
30003e58:	9920      	ldr	r1, [sp, #128]	; 0x80
30003e5a:	f001 ff07 	bl	30005c6c <parse_gpt_table_from_buffer>
    if (ret) {
30003e5e:	4683      	mov	r11, r0
30003e60:	2800      	cmp	r0, #0
30003e62:	f041 80ab 	bne.w	30004fbc <cmd_flash_storage+0x12f0>
    buffer = memalign(st_info->block_size,
30003e66:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003e68:	2100      	movs	r1, #0
    buffer = memalign(st_info->block_size,
30003e6a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003e6c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    buffer = memalign(st_info->block_size,
30003e6e:	9221      	str	r2, [sp, #132]	; 0x84
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003e70:	4618      	mov	r0, r3
                      round_up(gpt_sz, st_info->block_size));
30003e72:	4613      	mov	r3, r2
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003e74:	e9cd 011e 	strd	r0, r1, [r13, #120]	; 0x78
                      round_up(gpt_sz, st_info->block_size));
30003e78:	2100      	movs	r1, #0
30003e7a:	460c      	mov	r4, r1
    if (aligned == 0 || size < aligned)
30003e7c:	e9dd 011e 	ldrd	r0, r1, [r13, #120]	; 0x78
30003e80:	e9cd 341c 	strd	r3, r4, [r13, #112]	; 0x70
30003e84:	42a1      	cmp	r1, r4
30003e86:	bf08      	it	eq
30003e88:	4290      	cmpeq	r0, r2
30003e8a:	bf34      	ite	cc
30003e8c:	2301      	movcc	r3, #1
30003e8e:	2300      	movcs	r3, #0
30003e90:	2a00      	cmp	r2, #0
30003e92:	bf08      	it	eq
30003e94:	2301      	moveq	r3, #1
30003e96:	b9d3      	cbnz	r3, 30003ece <cmd_flash_storage+0x202>
    mod = size % aligned;
30003e98:	e9dd 231c 	ldrd	r2, r3, [r13, #112]	; 0x70
30003e9c:	f015 ffc0 	bl	30019e20 <__aeabi_uldivmod>
30003ea0:	461c      	mov	r4, r3
30003ea2:	4613      	mov	r3, r2
    size += mod ? aligned - mod : 0;
30003ea4:	ea53 0204 	orrs.w	r2, r3, r4
30003ea8:	e9cd 3422 	strd	r3, r4, [r13, #136]	; 0x88
30003eac:	f001 816a 	beq.w	30005184 <cmd_flash_storage+0x14b8>
30003eb0:	e9dd 341c 	ldrd	r3, r4, [r13, #112]	; 0x70
30003eb4:	e9dd 011e 	ldrd	r0, r1, [r13, #120]	; 0x78
30003eb8:	18c0      	adds	r0, r0, r3
30003eba:	4161      	adcs	r1, r4
30003ebc:	e9dd 3422 	ldrd	r3, r4, [r13, #136]	; 0x88
30003ec0:	1ac3      	subs	r3, r0, r3
30003ec2:	4618      	mov	r0, r3
30003ec4:	eb61 0404 	sbc.w	r4, r1, r4
30003ec8:	4621      	mov	r1, r4
30003eca:	e9cd 011c 	strd	r0, r1, [r13, #112]	; 0x70
    buffer = memalign(st_info->block_size,
30003ece:	991c      	ldr	r1, [sp, #112]	; 0x70
30003ed0:	9821      	ldr	r0, [sp, #132]	; 0x84
30003ed2:	f010 fc1f 	bl	30014714 <memalign>
    if (!buffer) {
30003ed6:	901c      	str	r0, [sp, #112]	; 0x70
30003ed8:	2800      	cmp	r0, #0
30003eda:	f001 81b2 	beq.w	30005242 <cmd_flash_storage+0x1576>
    if (current_dl_state->cur_pt_info.type == TYPE_PRI_PTB) {
30003ede:	683b      	ldr	r3, [r7, #0]
30003ee0:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
30003ee4:	2b01      	cmp	r3, #1
30003ee6:	f041 8082 	bne.w	30004fee <cmd_flash_storage+0x1322>
        offset = st_info->ptb_offset;
30003eea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
30003eec:	e9d3 231a 	ldrd	r2, r3, [r3, #104]	; 0x68
    ret = storage->read(storage, offset, (uint8_t *)buffer, gpt_sz);
30003ef0:	9c12      	ldr	r4, [sp, #72]	; 0x48
30003ef2:	e9dd 011e 	ldrd	r0, r1, [r13, #120]	; 0x78
30003ef6:	e9cd 0102 	strd	r0, r1, [r13, #8]
30003efa:	4620      	mov	r0, r4
30003efc:	991c      	ldr	r1, [sp, #112]	; 0x70
30003efe:	9100      	str	r1, [sp, #0]
30003f00:	68a1      	ldr	r1, [r4, #8]
30003f02:	4788      	blx	r1
    if (ret) {
30003f04:	2800      	cmp	r0, #0
30003f06:	f001 8090 	beq.w	3000502a <cmd_flash_storage+0x135e>
        ERROR("read gpt table error:%s$%s$%s", st_info->storage_name,
30003f0a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
30003f0c:	f24a 7148 	movw	r1, #42824	; 0xa748
30003f10:	9301      	str	r3, [sp, #4]
30003f12:	f24b 10b8 	movw	r0, #45496	; 0xb1b8
30003f16:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        ret = PTB_CHECK_ERROR;
30003f18:	2402      	movs	r4, #2
        ERROR("read gpt table error:%s$%s$%s", st_info->storage_name,
30003f1a:	9a16      	ldr	r2, [sp, #88]	; 0x58
30003f1c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30003f20:	9200      	str	r2, [sp, #0]
30003f22:	3310      	adds	r3, #16
30003f24:	f240 224e 	movw	r2, #590	; 0x24e
30003f28:	f2c3 0001 	movt	r0, #12289	; 0x3001
        ret = PTB_CHECK_ERROR;
30003f2c:	46a3      	mov	r11, r4
        ERROR("read gpt table error:%s$%s$%s", st_info->storage_name,
30003f2e:	f011 fe3f 	bl	30015bb0 <_printf>
30003f32:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
    if (buffered_gpt_header.partition_entries != NULL) {
30003f36:	b115      	cbz	r5, 30003f3e <cmd_flash_storage+0x272>
        free(buffered_gpt_header.partition_entries);
30003f38:	4628      	mov	r0, r5
30003f3a:	f010 fc27 	bl	3001478c <free>
    if (storage_gpt_header.partition_entries != NULL) {
30003f3e:	9857      	ldr	r0, [sp, #348]	; 0x15c
30003f40:	b108      	cbz	r0, 30003f46 <cmd_flash_storage+0x27a>
        free(storage_gpt_header.partition_entries);
30003f42:	f010 fc23 	bl	3001478c <free>
    if (buffer) {
30003f46:	981c      	ldr	r0, [sp, #112]	; 0x70
30003f48:	b108      	cbz	r0, 30003f4e <cmd_flash_storage+0x282>
        free(buffer);
30003f4a:	f010 fc1f 	bl	3001478c <free>
    if (ret == PTB_CHECK_ERROR) {
30003f4e:	465b      	mov	r3, r11
30003f50:	2b02      	cmp	r3, #2
30003f52:	f000 82a7 	beq.w	300044a4 <cmd_flash_storage+0x7d8>
    else if (ret == PTB_NO_NEED_FLASH) {
30003f56:	2b01      	cmp	r3, #1
30003f58:	f000 80d0 	beq.w	300040fc <cmd_flash_storage+0x430>
        sub_ptbname = NULL;
30003f5c:	9b08      	ldr	r3, [sp, #32]
30003f5e:	2e01      	cmp	r6, #1
30003f60:	bf08      	it	eq
30003f62:	2300      	moveq	r3, #0
    dprintf(ALWAYS, "Attempt to write primary/sub partition:%s \n", ptname);
30003f64:	f24b 2008 	movw	r0, #45576	; 0xb208
30003f68:	990a      	ldr	r1, [sp, #40]	; 0x28
30003f6a:	f2c3 0001 	movt	r0, #12289	; 0x3001
        sub_ptbname = NULL;
30003f6e:	9308      	str	r3, [sp, #32]
    dprintf(ALWAYS, "Attempt to write primary/sub partition:%s \n", ptname);
30003f70:	f011 fe1e 	bl	30015bb0 <_printf>
    ptdev = current_dl_state->ptdev;
30003f74:	683b      	ldr	r3, [r7, #0]
30003f76:	68da      	ldr	r2, [r3, #12]
30003f78:	9212      	str	r2, [sp, #72]	; 0x48
    if (ptdev
30003f7a:	2a00      	cmp	r2, #0
30003f7c:	f000 8327 	beq.w	300045ce <cmd_flash_storage+0x902>
            && st_info->type == OSPI ) {
30003f80:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
30003f84:	2b01      	cmp	r3, #1
30003f86:	f040 80ae 	bne.w	300040e6 <cmd_flash_storage+0x41a>
        block_size = st_info->block_size;
30003f8a:	f8da 9070 	ldr.w	r9, [r10, #112]	; 0x70
        blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
30003f8e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
        capacity = storage->get_capacity(storage);
30003f92:	990c      	ldr	r1, [sp, #48]	; 0x30
        gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003f94:	2500      	movs	r5, #0
        capacity = storage->get_capacity(storage);
30003f96:	4608      	mov	r0, r1
30003f98:	468b      	mov	r11, r1
        blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
30003f9a:	fbb3 f3f9 	udiv	r3, r3, r9
        capacity = storage->get_capacity(storage);
30003f9e:	698a      	ldr	r2, [r1, #24]
        gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries + 1) * block_size;
30003fa0:	3302      	adds	r3, #2
30003fa2:	fb09 f303 	mul.w	r3, r9, r3
30003fa6:	461c      	mov	r4, r3
30003fa8:	e9cd 450e 	strd	r4, r5, [r13, #56]	; 0x38
        capacity = storage->get_capacity(storage);
30003fac:	4790      	blx	r2
        storage->erase(storage, st_info->ptb_offset,
30003fae:	f8db 3010 	ldr.w	r3, [r11, #16]
30003fb2:	9318      	str	r3, [sp, #96]	; 0x60
30003fb4:	e9da 341a 	ldrd	r3, r4, [r10, #104]	; 0x68
30003fb8:	f8da 2080 	ldr.w	r2, [r10, #128]	; 0x80
30003fbc:	e9cd 341a 	strd	r3, r4, [r13, #104]	; 0x68
30003fc0:	2400      	movs	r4, #0
30003fc2:	4613      	mov	r3, r2
30003fc4:	4693      	mov	r11, r2
30003fc6:	46a4      	mov	r12, r4
30003fc8:	e9cd bc10 	strd	r11, r12, [r13, #64]	; 0x40
        capacity = storage->get_capacity(storage);
30003fcc:	e9cd 0116 	strd	r0, r1, [r13, #88]	; 0x58
    if (aligned == 0 || size < aligned)
30003fd0:	e9dd 010e 	ldrd	r0, r1, [r13, #56]	; 0x38
30003fd4:	42a1      	cmp	r1, r4
30003fd6:	bf08      	it	eq
30003fd8:	4290      	cmpeq	r0, r2
30003fda:	bf34      	ite	cc
30003fdc:	2301      	movcc	r3, #1
30003fde:	2300      	movcs	r3, #0
30003fe0:	2a00      	cmp	r2, #0
30003fe2:	bf08      	it	eq
30003fe4:	2301      	moveq	r3, #1
30003fe6:	b99b      	cbnz	r3, 30004010 <cmd_flash_storage+0x344>
    mod = size % aligned;
30003fe8:	4623      	mov	r3, r4
30003fea:	460d      	mov	r5, r1
30003fec:	4604      	mov	r4, r0
30003fee:	f015 ff17 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30003ff2:	ea52 0103 	orrs.w	r1, r2, r3
30003ff6:	f000 870b 	beq.w	30004e10 <cmd_flash_storage+0x1144>
30003ffa:	4620      	mov	r0, r4
30003ffc:	4629      	mov	r1, r5
30003ffe:	e9dd 4510 	ldrd	r4, r5, [r13, #64]	; 0x40
30004002:	1900      	adds	r0, r0, r4
30004004:	4169      	adcs	r1, r5
30004006:	1a80      	subs	r0, r0, r2
30004008:	eb61 0103 	sbc.w	r1, r1, r3
3000400c:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
        storage->erase(storage, st_info->ptb_offset,
30004010:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
30004014:	e9cd 3400 	strd	r3, r4, [r13]
30004018:	9918      	ldr	r1, [sp, #96]	; 0x60
3000401a:	e9dd 231a 	ldrd	r2, r3, [r13, #104]	; 0x68
3000401e:	980c      	ldr	r0, [sp, #48]	; 0x30
30004020:	4788      	blx	r1
        storage->erase(storage,
30004022:	e9dd 450e 	ldrd	r4, r5, [r13, #56]	; 0x38
30004026:	2100      	movs	r1, #0
30004028:	2200      	movs	r2, #0
3000402a:	f8da 3080 	ldr.w	r3, [r10, #128]	; 0x80
3000402e:	ebb9 0404 	subs.w	r4, r9, r4
30004032:	4620      	mov	r0, r4
30004034:	eb61 0505 	sbc.w	r5, r1, r5
30004038:	4629      	mov	r1, r5
    if (aligned == 0 || size < aligned)
3000403a:	fab3 fb83 	clz	r11, r3
3000403e:	e9dd 4516 	ldrd	r4, r5, [r13, #88]	; 0x58
30004042:	ea4f 1b5b 	mov.w	r11, r11, lsr #5
30004046:	1824      	adds	r4, r4, r0
30004048:	414d      	adcs	r5, r1
3000404a:	4619      	mov	r1, r3
3000404c:	4295      	cmp	r5, r2
3000404e:	e9cd 4516 	strd	r4, r5, [r13, #88]	; 0x58
30004052:	4623      	mov	r3, r4
30004054:	e9cd 1210 	strd	r1, r2, [r13, #64]	; 0x40
30004058:	bf08      	it	eq
3000405a:	428b      	cmpeq	r3, r1
3000405c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
3000405e:	f8d3 9010 	ldr.w	r9, [r3, #16]
30004062:	bf2c      	ite	cs
30004064:	465b      	movcs	r3, r11
30004066:	f04b 0301 	orrcc.w	r3, r11, #1
3000406a:	2b00      	cmp	r3, #0
3000406c:	f040 85a1 	bne.w	30004bb2 <cmd_flash_storage+0xee6>
    mod = size % aligned;
30004070:	e9dd 4516 	ldrd	r4, r5, [r13, #88]	; 0x58
30004074:	4613      	mov	r3, r2
30004076:	4620      	mov	r0, r4
30004078:	460a      	mov	r2, r1
3000407a:	4629      	mov	r1, r5
3000407c:	f015 fed0 	bl	30019e20 <__aeabi_uldivmod>
    size -= mod;
30004080:	1aa4      	subs	r4, r4, r2
30004082:	eb65 0503 	sbc.w	r5, r5, r3
30004086:	e9cd 4516 	strd	r4, r5, [r13, #88]	; 0x58
3000408a:	e9dd 010e 	ldrd	r0, r1, [r13, #56]	; 0x38
                       round_up(gpt_sz - st_info->block_size, st_info->erase_grp_sz));
3000408e:	f8da 3070 	ldr.w	r3, [r10, #112]	; 0x70
        storage->erase(storage,
30004092:	1ac0      	subs	r0, r0, r3
    if (aligned == 0 || size < aligned)
30004094:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
30004098:	f161 0100 	sbc.w	r1, r1, #0
3000409c:	e9cd 010e 	strd	r0, r1, [r13, #56]	; 0x38
300040a0:	42a1      	cmp	r1, r4
300040a2:	bf08      	it	eq
300040a4:	4298      	cmpeq	r0, r3
300040a6:	bf2c      	ite	cs
300040a8:	465d      	movcs	r5, r11
300040aa:	f04b 0501 	orrcc.w	r5, r11, #1
300040ae:	b995      	cbnz	r5, 300040d6 <cmd_flash_storage+0x40a>
    mod = size % aligned;
300040b0:	461a      	mov	r2, r3
300040b2:	4623      	mov	r3, r4
300040b4:	460d      	mov	r5, r1
300040b6:	4604      	mov	r4, r0
300040b8:	f015 feb2 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300040bc:	ea52 0103 	orrs.w	r1, r2, r3
300040c0:	f000 86a0 	beq.w	30004e04 <cmd_flash_storage+0x1138>
300040c4:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
300040c8:	1900      	adds	r0, r0, r4
300040ca:	4169      	adcs	r1, r5
300040cc:	1a80      	subs	r0, r0, r2
300040ce:	eb61 0103 	sbc.w	r1, r1, r3
300040d2:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
300040d6:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
300040da:	e9cd 3400 	strd	r3, r4, [r13]
300040de:	980c      	ldr	r0, [sp, #48]	; 0x30
300040e0:	e9dd 2316 	ldrd	r2, r3, [r13, #88]	; 0x58
300040e4:	47c8      	blx	r9
            || ptdev_write_table(ptdev, sub_ptbname, sz, (unsigned char *) data,
300040e6:	9b15      	ldr	r3, [sp, #84]	; 0x54
300040e8:	9300      	str	r3, [sp, #0]
300040ea:	4643      	mov	r3, r8
300040ec:	9a06      	ldr	r2, [sp, #24]
300040ee:	9908      	ldr	r1, [sp, #32]
300040f0:	9812      	ldr	r0, [sp, #72]	; 0x48
300040f2:	f014 fa33 	bl	3001855c <ptdev_write_table>
300040f6:	2800      	cmp	r0, #0
300040f8:	f040 8268 	bne.w	300045cc <cmd_flash_storage+0x900>
    if (st_info->type == OSPI) {
300040fc:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
30004100:	2b01      	cmp	r3, #1
30004102:	f47f ae09 	bne.w	30003d18 <cmd_flash_storage+0x4c>
    struct storage_device *storage = current_dl_state->storage;
30004106:	683c      	ldr	r4, [r7, #0]
    if (st_info->type != OSPI) {
30004108:	6e23      	ldr	r3, [r4, #96]	; 0x60
3000410a:	2b01      	cmp	r3, #1
3000410c:	f000 8703 	beq.w	30004f16 <cmd_flash_storage+0x124a>
            ERROR("updata sfs fail\n");
30004110:	f64a 0108 	movw	r1, #43016	; 0xa808
30004114:	f24b 20f8 	movw	r0, #45816	; 0xb2f8
30004118:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000411c:	f240 622b 	movw	r2, #1579	; 0x62b
30004120:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004124:	f011 fd44 	bl	30015bb0 <_printf>
            fastboot_common_fail(fb, response_error(err, ptname));
30004128:	990a      	ldr	r1, [sp, #40]	; 0x28
            return 1;
3000412a:	2401      	movs	r4, #1
            fastboot_common_fail(fb, response_error(err, ptname));
3000412c:	2009      	movs	r0, #9
3000412e:	f7fe fc41 	bl	300029b4 <response_error>
30004132:	4601      	mov	r1, r0
30004134:	9814      	ldr	r0, [sp, #80]	; 0x50
30004136:	f010 fa73 	bl	30014620 <fastboot_common_fail>
3000413a:	e1d3      	b.n	300044e4 <cmd_flash_storage+0x818>
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
3000413c:	2292      	movs	r2, #146	; 0x92
3000413e:	ad40      	add	r5, sp, #256	; 0x100
30004140:	4628      	mov	r0, r5
30004142:	2100      	movs	r1, #0
    struct storage_device *storage = current_dl_state->storage;
30004144:	e9da 9402 	ldrd	r9, r4, [r10, #8]
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
30004148:	f010 ec12 	blx	30014970 <memset>
            || ((uint32_t)block_wrapper % st_info->block_size) != 0
3000414c:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
30004150:	f04f 534a 	mov.w	r3, #847249408	; 0x32800000
30004154:	fbb3 f3f2 	udiv	r3, r3, r2
30004158:	fb02 f303 	mul.w	r3, r2, r3
3000415c:	f1d3 534a 	rsbs	r3, r3, #847249408	; 0x32800000
30004160:	469b      	mov	r11, r3
30004162:	d109      	bne.n	30004178 <cmd_flash_storage+0x4ac>
            || (SPARSE_DATA_ALIGNED_SIZE % st_info->block_size) != 0
30004164:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
30004168:	fbb3 f3f2 	udiv	r3, r3, r2
3000416c:	fb02 f203 	mul.w	r2, r2, r3
            || SPARSE_DATA_ALIGNED_SIZE == 0) {
30004170:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
30004174:	f000 8116 	beq.w	300043a4 <cmd_flash_storage+0x6d8>
        ERROR("aligned  memory allocate fail!\n");
30004178:	f24a 7194 	movw	r1, #42900	; 0xa794
3000417c:	f64a 408c 	movw	r0, #44172	; 0xac8c
30004180:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004184:	f44f 723b 	mov.w	r2, #748	; 0x2ec
30004188:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000418c:	f011 fd10 	bl	30015bb0 <_printf>
        err = ERR_SPARSE_IMAGE_MALLOC;
30004190:	2015      	movs	r0, #21
    fastboot_common_fail(fb, response_error(err, full_ptname));
30004192:	4629      	mov	r1, r5
30004194:	f7fe fc0e 	bl	300029b4 <response_error>
30004198:	4601      	mov	r1, r0
3000419a:	9814      	ldr	r0, [sp, #80]	; 0x50
3000419c:	f010 fa40 	bl	30014620 <fastboot_common_fail>
    if (current_dl_state->st_info.type == OSPI)
300041a0:	683b      	ldr	r3, [r7, #0]
300041a2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
300041a4:	2b01      	cmp	r3, #1
300041a6:	f43f adc6 	beq.w	30003d36 <cmd_flash_storage+0x6a>
}
300041aa:	b067      	add	sp, #412	; 0x19c
300041ac:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    char *ptname      = current_dl_state->cur_pt_info.ptname;
300041b0:	f10a 04d1 	add.w	r4, r10, #209	; 0xd1
    struct storage_device *storage = current_dl_state->storage;
300041b4:	f8da 3008 	ldr.w	r3, [r10, #8]
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
300041b8:	ad40      	add	r5, sp, #256	; 0x100
300041ba:	2292      	movs	r2, #146	; 0x92
300041bc:	2100      	movs	r1, #0
300041be:	4628      	mov	r0, r5
    uint8_t md5_calc[MD5_LEN] = {0};
300041c0:	f10d 0998 	add.w	r9, r13, #152	; 0x98
    struct storage_device *storage = current_dl_state->storage;
300041c4:	9308      	str	r3, [sp, #32]
    char *ptname      = current_dl_state->cur_pt_info.ptname;
300041c6:	940a      	str	r4, [sp, #40]	; 0x28
    struct partition_device *ptdev = current_dl_state->ptdev;
300041c8:	f8da b00c 	ldr.w	r11, [r10, #12]
    char full_ptname[MAX_GPT_NAME_SIZE * 2 + 2] = {0};
300041cc:	f010 ebd0 	blx	30014970 <memset>
    uint8_t md5_calc[MD5_LEN] = {0};
300041d0:	2300      	movs	r3, #0
    char *sub_ptbname = current_dl_state->cur_pt_info.sub_ptbname;
300041d2:	f10a 0288 	add.w	r2, r10, #136	; 0x88
300041d6:	4614      	mov	r4, r2
    uint8_t md5_calc[MD5_LEN] = {0};
300041d8:	e9c9 3300 	strd	r3, r3, [r9]
300041dc:	e9c9 3302 	strd	r3, r3, [r9, #8]
    if (st_info->type == MMC && !st_info->boot_offset) {
300041e0:	f8da 1060 	ldr.w	r1, [r10, #96]	; 0x60
300041e4:	2900      	cmp	r1, #0
300041e6:	f000 8118 	beq.w	3000441a <cmd_flash_storage+0x74e>
    if (pttype == TYPE_SUB_PT) {
300041ea:	2e04      	cmp	r6, #4
300041ec:	f000 820b 	beq.w	30004606 <cmd_flash_storage+0x93a>
        snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
300041f0:	f240 52e4 	movw	r2, #1508	; 0x5e4
    else if (pttype == TYPE_SUB_PT_WHOLE) {
300041f4:	2e05      	cmp	r6, #5
        snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
300041f6:	bf08      	it	eq
300041f8:	4623      	moveq	r3, r4
        snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
300041fa:	f2c3 0202 	movt	r2, #12290	; 0x3002
300041fe:	f04f 0192 	mov.w	r1, #146	; 0x92
30004202:	4628      	mov	r0, r5
30004204:	bf18      	it	ne
30004206:	9b0a      	ldrne	r3, [sp, #40]	; 0x28
30004208:	f011 fc62 	bl	30015ad0 <snprintf>
    ptn = ptdev_get_offset(ptdev, full_ptname);
3000420c:	4629      	mov	r1, r5
3000420e:	4658      	mov	r0, r11
30004210:	f013 fe8c 	bl	30017f2c <ptdev_get_offset>
30004214:	4602      	mov	r2, r0
30004216:	460b      	mov	r3, r1
30004218:	e9cd 230e 	strd	r2, r3, [r13, #56]	; 0x38
    if (ptn == 0) {
3000421c:	4313      	orrs	r3, r2
3000421e:	f000 8174 	beq.w	3000450a <cmd_flash_storage+0x83e>
    size = ptdev_get_size(ptdev, full_ptname);
30004222:	4629      	mov	r1, r5
30004224:	4658      	mov	r0, r11
30004226:	f013 fe5b 	bl	30017ee0 <ptdev_get_size>
    if (st_info->type == OSPI) {
3000422a:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
3000422e:	2b01      	cmp	r3, #1
    size = ptdev_get_size(ptdev, full_ptname);
30004230:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
    if (st_info->type == OSPI) {
30004234:	f000 8201 	beq.w	3000463a <cmd_flash_storage+0x96e>
30004238:	9b06      	ldr	r3, [sp, #24]
3000423a:	2200      	movs	r2, #0
3000423c:	4619      	mov	r1, r3
3000423e:	e9cd 120a 	strd	r1, r2, [r13, #40]	; 0x28
    if (aligned == 0 || size < aligned)
30004242:	e9dd bc0a 	ldrd	r11, r12, [r13, #40]	; 0x28
    if (round_up(sz, st_info->block_size) > size) {
30004246:	2100      	movs	r1, #0
30004248:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
3000424c:	465b      	mov	r3, r11
3000424e:	4610      	mov	r0, r2
30004250:	458c      	cmp	r12, r1
30004252:	bf08      	it	eq
30004254:	4593      	cmpeq	r11, r2
30004256:	bf34      	ite	cc
30004258:	2301      	movcc	r3, #1
3000425a:	2300      	movcs	r3, #0
3000425c:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
30004260:	2a00      	cmp	r2, #0
30004262:	bf08      	it	eq
30004264:	2301      	moveq	r3, #1
30004266:	2b00      	cmp	r3, #0
30004268:	f000 8167 	beq.w	3000453a <cmd_flash_storage+0x86e>
3000426c:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
30004270:	e9dd 120c 	ldrd	r1, r2, [r13, #48]	; 0x30
30004274:	4294      	cmp	r4, r2
30004276:	bf08      	it	eq
30004278:	428b      	cmpeq	r3, r1
3000427a:	f0c0 8480 	bcc.w	30004b7e <cmd_flash_storage+0xeb2>
    if (!storage
3000427e:	9b08      	ldr	r3, [sp, #32]
30004280:	2b00      	cmp	r3, #0
30004282:	f000 818a 	beq.w	3000459a <cmd_flash_storage+0x8ce>
            || storage->write(storage, ptn, (uint8_t *)data, round_up(sz,
30004286:	9908      	ldr	r1, [sp, #32]
30004288:	e9dd 340c 	ldrd	r3, r4, [r13, #48]	; 0x30
3000428c:	4608      	mov	r0, r1
3000428e:	e9cd 3402 	strd	r3, r4, [r13, #8]
30004292:	f8cd 8000 	str.w	r8, [r13]
30004296:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
3000429a:	68c9      	ldr	r1, [r1, #12]
3000429c:	4788      	blx	r1
3000429e:	2800      	cmp	r0, #0
300042a0:	f040 817b 	bne.w	3000459a <cmd_flash_storage+0x8ce>
    if (!storage || pt_size - image_sz < sizeof(AvbFooter)) {
300042a4:	e9dd 2310 	ldrd	r2, r3, [r13, #64]	; 0x40
300042a8:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
300042ac:	1a12      	subs	r2, r2, r0
300042ae:	eb63 0301 	sbc.w	r3, r3, r1
300042b2:	2b00      	cmp	r3, #0
300042b4:	bf08      	it	eq
300042b6:	2a40      	cmpeq	r2, #64	; 0x40
300042b8:	f080 85b0 	bcs.w	30004e1c <cmd_flash_storage+0x1150>
    if (do_md5_check) {
300042bc:	f646 4374 	movw	r3, #27764	; 0x6c74
300042c0:	f2c3 0302 	movt	r3, #12290	; 0x3002
300042c4:	781b      	ldrb	r3, [r3, #0]
300042c6:	2b00      	cmp	r3, #0
300042c8:	f43f ad26 	beq.w	30003d18 <cmd_flash_storage+0x4c>
300042cc:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
        if (storage->read(storage, ptn, scratch_buf,
300042d0:	f04f 0b00 	mov.w	r11, #0
300042d4:	9b08      	ldr	r3, [sp, #32]
300042d6:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
300042da:	4559      	cmp	r1, r11
300042dc:	4692      	mov	r10, r2
300042de:	689d      	ldr	r5, [r3, #8]
300042e0:	bf08      	it	eq
300042e2:	4290      	cmpeq	r0, r2
300042e4:	bf34      	ite	cc
300042e6:	2301      	movcc	r3, #1
300042e8:	2300      	movcs	r3, #0
300042ea:	2a00      	cmp	r2, #0
300042ec:	bf08      	it	eq
300042ee:	2301      	moveq	r3, #1
300042f0:	b99b      	cbnz	r3, 3000431a <cmd_flash_storage+0x64e>
    mod = size % aligned;
300042f2:	465b      	mov	r3, r11
300042f4:	f015 fd94 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300042f8:	ea52 0103 	orrs.w	r1, r2, r3
300042fc:	f000 873c 	beq.w	30005178 <cmd_flash_storage+0x14ac>
30004300:	4650      	mov	r0, r10
30004302:	4659      	mov	r1, r11
30004304:	e9dd ab0a 	ldrd	r10, r11, [r13, #40]	; 0x28
30004308:	eb10 000a 	adds.w	r0, r0, r10
3000430c:	eb41 010b 	adc.w	r1, r1, r11
30004310:	1a80      	subs	r0, r0, r2
30004312:	4682      	mov	r10, r0
30004314:	eb61 0103 	sbc.w	r1, r1, r3
30004318:	468b      	mov	r11, r1
3000431a:	4650      	mov	r0, r10
3000431c:	f04f 544a 	mov.w	r4, #847249408	; 0x32800000
30004320:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
30004324:	4659      	mov	r1, r11
30004326:	9400      	str	r4, [sp, #0]
30004328:	e9cd 0102 	strd	r0, r1, [r13, #8]
3000432c:	9808      	ldr	r0, [sp, #32]
3000432e:	47a8      	blx	r5
30004330:	2800      	cmp	r0, #0
30004332:	f040 85e1 	bne.w	30004ef8 <cmd_flash_storage+0x122c>
            md5(scratch_buf, sz, md5_calc);
30004336:	9906      	ldr	r1, [sp, #24]
30004338:	464a      	mov	r2, r9
3000433a:	4620      	mov	r0, r4
3000433c:	f012 f924 	bl	30016588 <md5>
            if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30004340:	f8d9 2000 	ldr.w	r2, [r9]
30004344:	f646 43f8 	movw	r3, #27896	; 0x6cf8
30004348:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000434c:	6819      	ldr	r1, [r3, #0]
3000434e:	4291      	cmp	r1, r2
30004350:	f000 871e 	beq.w	30005190 <cmd_flash_storage+0x14c4>
                ERROR("md5 check fail!\n");
30004354:	f64a 0118 	movw	r1, #43032	; 0xa818
30004358:	f64b 10a8 	movw	r0, #47528	; 0xb9a8
3000435c:	f240 62a1 	movw	r2, #1697	; 0x6a1
30004360:	f2c3 0101 	movt	r1, #12289	; 0x3001
                return 1;
30004364:	2401      	movs	r4, #1
                ERROR("md5 check fail!\n");
30004366:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000436a:	f011 fc21 	bl	30015bb0 <_printf>
3000436e:	f646 42f8 	movw	r2, #27896	; 0x6cf8
30004372:	2300      	movs	r3, #0
30004374:	f2c3 0202 	movt	r2, #12290	; 0x3002
30004378:	4610      	mov	r0, r2
3000437a:	2110      	movs	r1, #16
3000437c:	f00f ffd8 	bl	30014330 <hexdump8_ex>
30004380:	464a      	mov	r2, r9
30004382:	4648      	mov	r0, r9
30004384:	2300      	movs	r3, #0
30004386:	2110      	movs	r1, #16
30004388:	f00f ffd2 	bl	30014330 <hexdump8_ex>
                fastboot_common_fail(fb, response_error(ERR_HASH_FAIL, ""));
3000438c:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30004390:	2016      	movs	r0, #22
30004392:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004396:	f7fe fb0d 	bl	300029b4 <response_error>
3000439a:	4601      	mov	r1, r0
3000439c:	9814      	ldr	r0, [sp, #80]	; 0x50
3000439e:	f010 f93f 	bl	30014620 <fastboot_common_fail>
300043a2:	e09f      	b.n	300044e4 <cmd_flash_storage+0x818>
    if (!storage || !ptdev) {
300043a4:	2c00      	cmp	r4, #0
300043a6:	bf18      	it	ne
300043a8:	f1b9 0f00 	cmpne.w	r9, #0
300043ac:	f000 8137 	beq.w	3000461e <cmd_flash_storage+0x952>
    if (pttype >= TYPE_NOT_IN_GPT) {
300043b0:	2eff      	cmp	r6, #255	; 0xff
300043b2:	f200 83d5 	bhi.w	30004b60 <cmd_flash_storage+0xe94>
        if (st_info->type == MMC && !st_info->boot_offset) {
300043b6:	f8da 3060 	ldr.w	r3, [r10, #96]	; 0x60
300043ba:	b943      	cbnz	r3, 300043ce <cmd_flash_storage+0x702>
300043bc:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
300043c0:	4313      	orrs	r3, r2
300043c2:	d104      	bne.n	300043ce <cmd_flash_storage+0x702>
            storage->switch_part(storage, switch_pt_num);
300043c4:	f8d9 3014 	ldr.w	r3, [r9, #20]
300043c8:	4659      	mov	r1, r11
300043ca:	4648      	mov	r0, r9
300043cc:	4798      	blx	r3
        if (pttype == TYPE_SUB_PT) {
300043ce:	2e04      	cmp	r6, #4
    const char *ptname = current_dl_state->cur_pt_info.ptname;
300043d0:	f10a 01d1 	add.w	r1, r10, #209	; 0xd1
    const char *sub_ptbname = current_dl_state->cur_pt_info.sub_ptbname;
300043d4:	f10a 0388 	add.w	r3, r10, #136	; 0x88
        if (pttype == TYPE_SUB_PT) {
300043d8:	f000 80ee 	beq.w	300045b8 <cmd_flash_storage+0x8ec>
        else if (pttype == TYPE_SUB_PT_WHOLE) {
300043dc:	2e05      	cmp	r6, #5
300043de:	f000 856d 	beq.w	30004ebc <cmd_flash_storage+0x11f0>
        else if (pttype == TYPE_PRI_PT) {
300043e2:	2e02      	cmp	r6, #2
300043e4:	f000 85df 	beq.w	30004fa6 <cmd_flash_storage+0x12da>
        ptn = ptdev_get_offset(ptdev, full_ptname);
300043e8:	4629      	mov	r1, r5
300043ea:	4620      	mov	r0, r4
300043ec:	f013 fd9e 	bl	30017f2c <ptdev_get_offset>
300043f0:	4602      	mov	r2, r0
300043f2:	460b      	mov	r3, r1
300043f4:	e9cd 2308 	strd	r2, r3, [r13, #32]
        if (ptn == 0) {
300043f8:	4313      	orrs	r3, r2
300043fa:	f040 81a4 	bne.w	30004746 <cmd_flash_storage+0xa7a>
            ERROR("ptn is 0.\n");
300043fe:	f24a 7194 	movw	r1, #42900	; 0xa794
30004402:	f64a 40f4 	movw	r0, #44276	; 0xacf4
30004406:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000440a:	f240 3211 	movw	r2, #785	; 0x311
3000440e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004412:	f011 fbcd 	bl	30015bb0 <_printf>
            err = ERR_PT_NOT_FOUND;
30004416:	2004      	movs	r0, #4
30004418:	e6bb      	b.n	30004192 <cmd_flash_storage+0x4c6>
    if (st_info->type == MMC && !st_info->boot_offset) {
3000441a:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
3000441e:	431a      	orrs	r2, r3
30004420:	f47f aee3 	bne.w	300041ea <cmd_flash_storage+0x51e>
        if (!storage->switch_part || storage->switch_part(storage, part_num)) {
30004424:	9b08      	ldr	r3, [sp, #32]
30004426:	695b      	ldr	r3, [r3, #20]
30004428:	b123      	cbz	r3, 30004434 <cmd_flash_storage+0x768>
3000442a:	9808      	ldr	r0, [sp, #32]
3000442c:	4798      	blx	r3
3000442e:	2800      	cmp	r0, #0
30004430:	f43f aedb 	beq.w	300041ea <cmd_flash_storage+0x51e>
            ERROR("switch part error\n");
30004434:	f64a 0118 	movw	r1, #43032	; 0xa818
30004438:	f24b 00cc 	movw	r0, #45260	; 0xb0cc
3000443c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004440:	f240 624c 	movw	r2, #1612	; 0x64c
30004444:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004448:	e66c      	b.n	30004124 <cmd_flash_storage+0x458>
    if (st_info->type == MMC && !st_info->boot_offset) {
3000444a:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
3000444e:	4313      	orrs	r3, r2
30004450:	d171      	bne.n	30004536 <cmd_flash_storage+0x86a>
        if (!storage->switch_part || storage->switch_part(storage, part_num)) {
30004452:	6943      	ldr	r3, [r0, #20]
30004454:	2b00      	cmp	r3, #0
30004456:	f000 8088 	beq.w	3000456a <cmd_flash_storage+0x89e>
3000445a:	980c      	ldr	r0, [sp, #48]	; 0x30
3000445c:	4798      	blx	r3
3000445e:	2800      	cmp	r0, #0
30004460:	f040 8083 	bne.w	3000456a <cmd_flash_storage+0x89e>
30004464:	683b      	ldr	r3, [r7, #0]
30004466:	930e      	str	r3, [sp, #56]	; 0x38
30004468:	461a      	mov	r2, r3
    bool last_part_extend = true;
3000446a:	9515      	str	r5, [sp, #84]	; 0x54
3000446c:	32d1      	adds	r2, #209	; 0xd1
3000446e:	921a      	str	r2, [sp, #104]	; 0x68
30004470:	461a      	mov	r2, r3
30004472:	689b      	ldr	r3, [r3, #8]
30004474:	3288      	adds	r2, #136	; 0x88
30004476:	9312      	str	r3, [sp, #72]	; 0x48
30004478:	9216      	str	r2, [sp, #88]	; 0x58
3000447a:	e497      	b.n	30003dac <cmd_flash_storage+0xe0>
    struct storage_device *storage = current_dl_state->storage;
3000447c:	f8da 5008 	ldr.w	r5, [r10, #8]
    ret = flash_emmc_one_boot_area(fb, storage, data, sz, PART_ACCESS_BOOT1);
30004480:	2101      	movs	r1, #1
30004482:	9100      	str	r1, [sp, #0]
30004484:	4629      	mov	r1, r5
30004486:	f7fe fbb5 	bl	30002bf4 <flash_emmc_one_boot_area>
    if (!st_info->boot_offset)
3000448a:	e9da 231e 	ldrd	r2, r3, [r10, #120]	; 0x78
3000448e:	4313      	orrs	r3, r2
    ret = flash_emmc_one_boot_area(fb, storage, data, sz, PART_ACCESS_BOOT1);
30004490:	4604      	mov	r4, r0
    if (!st_info->boot_offset)
30004492:	d075      	beq.n	30004580 <cmd_flash_storage+0x8b4>
    if (ret) {
30004494:	2c00      	cmp	r4, #0
30004496:	f43f ac3f 	beq.w	30003d18 <cmd_flash_storage+0x4c>
3000449a:	e023      	b.n	300044e4 <cmd_flash_storage+0x818>
    if (storage_gpt_header.partition_entries != NULL) {
3000449c:	9857      	ldr	r0, [sp, #348]	; 0x15c
3000449e:	b108      	cbz	r0, 300044a4 <cmd_flash_storage+0x7d8>
        free(storage_gpt_header.partition_entries);
300044a0:	f010 f974 	bl	3001478c <free>
        if (strlen(sub_ptbname)) {
300044a4:	f89a 3088 	ldrb.w	r3, [r10, #136]	; 0x88
        ERROR(" check error ret:%u !\n",
300044a8:	f64a 0108 	movw	r1, #43016	; 0xa808
300044ac:	f24b 10e4 	movw	r0, #45540	; 0xb1e4
    char *ptname  = current_dl_state->cur_pt_info.ptname;
300044b0:	2b00      	cmp	r3, #0
300044b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
300044b4:	bf18      	it	ne
300044b6:	2503      	movne	r5, #3
300044b8:	9c08      	ldr	r4, [sp, #32]
300044ba:	bf04      	itt	eq
300044bc:	2502      	moveq	r5, #2
300044be:	461c      	moveq	r4, r3
        ERROR(" check error ret:%u !\n",
300044c0:	f240 52ec 	movw	r2, #1516	; 0x5ec
300044c4:	2302      	movs	r3, #2
300044c6:	f2c3 0101 	movt	r1, #12289	; 0x3001
300044ca:	f2c3 0001 	movt	r0, #12289	; 0x3001
300044ce:	f011 fb6f 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, ptname));
300044d2:	4621      	mov	r1, r4
300044d4:	4628      	mov	r0, r5
        return 1;
300044d6:	2401      	movs	r4, #1
        fastboot_common_fail(fb, response_error(err, ptname));
300044d8:	f7fe fa6c 	bl	300029b4 <response_error>
300044dc:	4601      	mov	r1, r0
300044de:	9814      	ldr	r0, [sp, #80]	; 0x50
300044e0:	f010 f89e 	bl	30014620 <fastboot_common_fail>
        ERROR("flash error ret:%d!\n", ret);
300044e4:	f64a 0130 	movw	r1, #43056	; 0xa830
300044e8:	f24b 4090 	movw	r0, #46224	; 0xb490
300044ec:	4623      	mov	r3, r4
300044ee:	f2c3 0101 	movt	r1, #12289	; 0x3001
300044f2:	f240 62cf 	movw	r2, #1743	; 0x6cf
300044f6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300044fa:	f011 fb59 	bl	30015bb0 <_printf>
300044fe:	e64f      	b.n	300041a0 <cmd_flash_storage+0x4d4>
        ptdev_read_table(current_dl_state->ptdev);
30004500:	683b      	ldr	r3, [r7, #0]
30004502:	68d8      	ldr	r0, [r3, #12]
30004504:	f013 fc00 	bl	30017d08 <ptdev_read_table>
30004508:	e409      	b.n	30003d1e <cmd_flash_storage+0x52>
        ERROR(" ptn is 0!\n");
3000450a:	f64a 0118 	movw	r1, #43032	; 0xa818
3000450e:	f24b 30e8 	movw	r0, #46056	; 0xb3e8
30004512:	f240 6266 	movw	r2, #1638	; 0x666
30004516:	f2c3 0101 	movt	r1, #12289	; 0x3001
        return 1;
3000451a:	2401      	movs	r4, #1
        ERROR(" ptn is 0!\n");
3000451c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004520:	f011 fb46 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, full_ptname));
30004524:	4629      	mov	r1, r5
30004526:	2004      	movs	r0, #4
30004528:	f7fe fa44 	bl	300029b4 <response_error>
3000452c:	4601      	mov	r1, r0
3000452e:	9814      	ldr	r0, [sp, #80]	; 0x50
30004530:	f010 f876 	bl	30014620 <fastboot_common_fail>
30004534:	e7d6      	b.n	300044e4 <cmd_flash_storage+0x818>
    bool last_part_extend = true;
30004536:	9515      	str	r5, [sp, #84]	; 0x54
30004538:	e430      	b.n	30003d9c <cmd_flash_storage+0xd0>
    mod = size % aligned;
3000453a:	460b      	mov	r3, r1
3000453c:	4658      	mov	r0, r11
3000453e:	4661      	mov	r1, r12
30004540:	f015 fc6e 	bl	30019e20 <__aeabi_uldivmod>
30004544:	4693      	mov	r11, r2
30004546:	469c      	mov	r12, r3
    size += mod ? aligned - mod : 0;
30004548:	ea5b 020c 	orrs.w	r2, r11, r12
3000454c:	f000 8337 	beq.w	30004bbe <cmd_flash_storage+0xef2>
30004550:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
30004554:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30004558:	18c0      	adds	r0, r0, r3
3000455a:	4161      	adcs	r1, r4
3000455c:	ebb0 000b 	subs.w	r0, r0, r11
30004560:	eb61 010c 	sbc.w	r1, r1, r12
30004564:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
30004568:	e680      	b.n	3000426c <cmd_flash_storage+0x5a0>
            ERROR("switch part error\n");
3000456a:	f64a 0108 	movw	r1, #43016	; 0xa808
3000456e:	f24b 00cc 	movw	r0, #45260	; 0xb0cc
30004572:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004576:	f240 52d2 	movw	r2, #1490	; 0x5d2
3000457a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000457e:	e5d1      	b.n	30004124 <cmd_flash_storage+0x458>
        ret |= flash_emmc_one_boot_area(fb, storage, data, sz, PART_ACCESS_BOOT2);
30004580:	2002      	movs	r0, #2
30004582:	4642      	mov	r2, r8
30004584:	9b06      	ldr	r3, [sp, #24]
30004586:	4629      	mov	r1, r5
30004588:	9000      	str	r0, [sp, #0]
3000458a:	9814      	ldr	r0, [sp, #80]	; 0x50
3000458c:	f7fe fb32 	bl	30002bf4 <flash_emmc_one_boot_area>
30004590:	4304      	orrs	r4, r0
    if (ret) {
30004592:	2c00      	cmp	r4, #0
30004594:	f43f abc0 	beq.w	30003d18 <cmd_flash_storage+0x4c>
30004598:	e7a4      	b.n	300044e4 <cmd_flash_storage+0x818>
        ERROR(" write data error!\n");
3000459a:	f64a 0118 	movw	r1, #43032	; 0xa818
3000459e:	f24b 0004 	movw	r0, #45060	; 0xb004
300045a2:	f2c3 0101 	movt	r1, #12289	; 0x3001
300045a6:	f240 628c 	movw	r2, #1676	; 0x68c
300045aa:	f2c3 0001 	movt	r0, #12289	; 0x3001
300045ae:	f011 faff 	bl	30015bb0 <_printf>
        return 1;
300045b2:	2401      	movs	r4, #1
        fastboot_common_fail(fb, response_error(err, full_ptname));
300045b4:	4629      	mov	r1, r5
300045b6:	e5b9      	b.n	3000412c <cmd_flash_storage+0x460>
            snprintf(full_ptname, sizeof(full_ptname), "%s$%s", sub_ptbname, ptname);
300045b8:	f64a 329c 	movw	r2, #43932	; 0xab9c
300045bc:	4628      	mov	r0, r5
300045be:	9100      	str	r1, [sp, #0]
300045c0:	f2c3 0201 	movt	r2, #12289	; 0x3001
300045c4:	2192      	movs	r1, #146	; 0x92
300045c6:	f011 fa83 	bl	30015ad0 <snprintf>
300045ca:	e70d      	b.n	300043e8 <cmd_flash_storage+0x71c>
300045cc:	683b      	ldr	r3, [r7, #0]
        ERROR("write gpt table error pt:%s ptb_offset:0x%llx\n",
300045ce:	9c0a      	ldr	r4, [sp, #40]	; 0x28
300045d0:	f64a 0108 	movw	r1, #43016	; 0xa808
300045d4:	e9d3 231a 	ldrd	r2, r3, [r3, #104]	; 0x68
300045d8:	f24b 2034 	movw	r0, #45620	; 0xb234
300045dc:	e9cd 2300 	strd	r2, r3, [r13]
300045e0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300045e4:	4623      	mov	r3, r4
300045e6:	f240 621f 	movw	r2, #1567	; 0x61f
300045ea:	f2c3 0001 	movt	r0, #12289	; 0x3001
300045ee:	f011 fadf 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, ptname));
300045f2:	4621      	mov	r1, r4
300045f4:	2009      	movs	r0, #9
        return 1;
300045f6:	2401      	movs	r4, #1
        fastboot_common_fail(fb, response_error(err, ptname));
300045f8:	f7fe f9dc 	bl	300029b4 <response_error>
300045fc:	4601      	mov	r1, r0
300045fe:	9814      	ldr	r0, [sp, #80]	; 0x50
30004600:	f010 f80e 	bl	30014620 <fastboot_common_fail>
30004604:	e76e      	b.n	300044e4 <cmd_flash_storage+0x818>
        snprintf(full_ptname, sizeof(full_ptname), "%s$%s", sub_ptbname, ptname);
30004606:	990a      	ldr	r1, [sp, #40]	; 0x28
30004608:	f64a 329c 	movw	r2, #43932	; 0xab9c
3000460c:	9100      	str	r1, [sp, #0]
3000460e:	4623      	mov	r3, r4
30004610:	2192      	movs	r1, #146	; 0x92
30004612:	f2c3 0201 	movt	r2, #12289	; 0x3001
30004616:	4628      	mov	r0, r5
30004618:	f011 fa5a 	bl	30015ad0 <snprintf>
3000461c:	e5f6      	b.n	3000420c <cmd_flash_storage+0x540>
        ERROR("storage get error!\n");
3000461e:	f24a 7194 	movw	r1, #42900	; 0xa794
30004622:	f24b 6040 	movw	r0, #46656	; 0xb640
30004626:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000462a:	f240 22f2 	movw	r2, #754	; 0x2f2
3000462e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004632:	f011 fabd 	bl	30015bb0 <_printf>
        err = ERR_PT_FLASH_FAIL;
30004636:	2009      	movs	r0, #9
30004638:	e5ab      	b.n	30004192 <cmd_flash_storage+0x4c6>
        if (ptn % st_info->erase_grp_sz != 0
3000463a:	f8da 3080 	ldr.w	r3, [r10, #128]	; 0x80
3000463e:	2400      	movs	r4, #0
30004640:	9312      	str	r3, [sp, #72]	; 0x48
30004642:	461a      	mov	r2, r3
30004644:	e9cd 340c 	strd	r3, r4, [r13, #48]	; 0x30
30004648:	4623      	mov	r3, r4
3000464a:	e9dd 010e 	ldrd	r0, r1, [r13, #56]	; 0x38
3000464e:	f015 fbe7 	bl	30019e20 <__aeabi_uldivmod>
30004652:	ea52 0103 	orrs.w	r1, r2, r3
30004656:	d137      	bne.n	300046c8 <cmd_flash_storage+0x9fc>
                || round_up(sz, st_info->erase_grp_sz) > size) {
30004658:	9906      	ldr	r1, [sp, #24]
3000465a:	2300      	movs	r3, #0
3000465c:	461a      	mov	r2, r3
    if (aligned == 0 || size < aligned)
3000465e:	e9cd 120a 	strd	r1, r2, [r13, #40]	; 0x28
30004662:	460a      	mov	r2, r1
30004664:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
30004668:	428b      	cmp	r3, r1
3000466a:	bf08      	it	eq
3000466c:	4282      	cmpeq	r2, r0
3000466e:	9a12      	ldr	r2, [sp, #72]	; 0x48
30004670:	bf34      	ite	cc
30004672:	2301      	movcc	r3, #1
30004674:	2300      	movcs	r3, #0
30004676:	2a00      	cmp	r2, #0
30004678:	bf08      	it	eq
3000467a:	2301      	moveq	r3, #1
3000467c:	b9db      	cbnz	r3, 300046b6 <cmd_flash_storage+0x9ea>
    mod = size % aligned;
3000467e:	4602      	mov	r2, r0
30004680:	460b      	mov	r3, r1
30004682:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30004686:	f015 fbcb 	bl	30019e20 <__aeabi_uldivmod>
3000468a:	461c      	mov	r4, r3
3000468c:	4613      	mov	r3, r2
    size += mod ? aligned - mod : 0;
3000468e:	e9cd 3412 	strd	r3, r4, [r13, #72]	; 0x48
30004692:	4323      	orrs	r3, r4
30004694:	f000 84a5 	beq.w	30004fe2 <cmd_flash_storage+0x1316>
30004698:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
3000469c:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
300046a0:	1880      	adds	r0, r0, r2
300046a2:	4159      	adcs	r1, r3
300046a4:	e9dd 3412 	ldrd	r3, r4, [r13, #72]	; 0x48
300046a8:	1ac3      	subs	r3, r0, r3
300046aa:	4618      	mov	r0, r3
300046ac:	eb61 0404 	sbc.w	r4, r1, r4
300046b0:	4621      	mov	r1, r4
300046b2:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
300046b6:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
300046ba:	e9dd 120c 	ldrd	r1, r2, [r13, #48]	; 0x30
300046be:	4294      	cmp	r4, r2
300046c0:	bf08      	it	eq
300046c2:	428b      	cmpeq	r3, r1
300046c4:	f080 83bc 	bcs.w	30004e40 <cmd_flash_storage+0x1174>
            fastboot_common_fail(fb, response_error(err, full_ptname));
300046c8:	4629      	mov	r1, r5
300046ca:	2005      	movs	r0, #5
300046cc:	f7fe f972 	bl	300029b4 <response_error>
            return 1;
300046d0:	2401      	movs	r4, #1
            fastboot_common_fail(fb, response_error(err, full_ptname));
300046d2:	4601      	mov	r1, r0
300046d4:	9814      	ldr	r0, [sp, #80]	; 0x50
300046d6:	f00f ffa3 	bl	30014620 <fastboot_common_fail>
            ERROR("the size of partition in nor flash is too large\n");
300046da:	f64a 0118 	movw	r1, #43032	; 0xa818
300046de:	f24b 4004 	movw	r0, #46084	; 0xb404
300046e2:	f2c3 0101 	movt	r1, #12289	; 0x3001
300046e6:	f240 6275 	movw	r2, #1653	; 0x675
300046ea:	f2c3 0001 	movt	r0, #12289	; 0x3001
300046ee:	f011 fa5f 	bl	30015bb0 <_printf>
300046f2:	e6f7      	b.n	300044e4 <cmd_flash_storage+0x818>
    struct partition_device *ptdev = current_dl_state->ptdev;
300046f4:	f8da 300c 	ldr.w	r3, [r10, #12]
    uint8_t md5_calc[MD5_LEN] = {0};
300046f8:	f10d 0998 	add.w	r9, r13, #152	; 0x98
300046fc:	2100      	movs	r1, #0
    if (pttype != TYPE_SAFETY_SFS_PT) {
300046fe:	f5b6 7f81 	cmp.w	r6, #258	; 0x102
    struct partition_device *ptdev = current_dl_state->ptdev;
30004702:	930a      	str	r3, [sp, #40]	; 0x28
    struct storage_device *storage = current_dl_state->storage;
30004704:	f8da 3008 	ldr.w	r3, [r10, #8]
30004708:	9308      	str	r3, [sp, #32]
    uint8_t md5_calc[MD5_LEN] = {0};
3000470a:	e9c9 1100 	strd	r1, r1, [r9]
3000470e:	e9c9 1102 	strd	r1, r1, [r9, #8]
    if (pttype != TYPE_SAFETY_SFS_PT) {
30004712:	f000 826c 	beq.w	30004bee <cmd_flash_storage+0xf22>
        ERROR("pttype:%d error!\n", pttype);
30004716:	f24a 71d8 	movw	r1, #42968	; 0xa7d8
3000471a:	f64b 001c 	movw	r0, #47132	; 0xb81c
3000471e:	4633      	mov	r3, r6
30004720:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004724:	f240 5207 	movw	r2, #1287	; 0x507
30004728:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000472c:	f011 fa40 	bl	30015bb0 <_printf>
        err = ERR_PT_NOT_FOUND;
30004730:	2004      	movs	r0, #4
                                            current_dl_state->cur_pt_info.ptname));
30004732:	6839      	ldr	r1, [r7, #0]
    return 1;
30004734:	2401      	movs	r4, #1
    fastboot_common_fail(fb, response_error(err,
30004736:	31d1      	adds	r1, #209	; 0xd1
30004738:	f7fe f93c 	bl	300029b4 <response_error>
3000473c:	4601      	mov	r1, r0
3000473e:	9814      	ldr	r0, [sp, #80]	; 0x50
30004740:	f00f ff6e 	bl	30014620 <fastboot_common_fail>
30004744:	e6ce      	b.n	300044e4 <cmd_flash_storage+0x818>
        size = ptdev_get_size(ptdev, full_ptname);
30004746:	4629      	mov	r1, r5
30004748:	4620      	mov	r0, r4
3000474a:	f013 fbc9 	bl	30017ee0 <ptdev_get_size>
        if (sz < sizeof(sparse_header_t)) {
3000474e:	9b06      	ldr	r3, [sp, #24]
30004750:	2b1b      	cmp	r3, #27
        size = ptdev_get_size(ptdev, full_ptname);
30004752:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
        if (sz < sizeof(sparse_header_t)) {
30004756:	f240 83a2 	bls.w	30004e9e <cmd_flash_storage+0x11d2>
    if (!sparse_header->blk_sz || (sparse_header->blk_sz % 4)) {
3000475a:	f8d8 c00c 	ldr.w	r12, [r8, #12]
3000475e:	f1bc 0f00 	cmp.w	r12, #0
30004762:	f000 833f 	beq.w	30004de4 <cmd_flash_storage+0x1118>
30004766:	f01c 0f03 	tst.w	r12, #3
3000476a:	f040 833b 	bne.w	30004de4 <cmd_flash_storage+0x1118>
    if (((uint64_t)sparse_header->total_blks * (uint64_t)sparse_header->blk_sz)
3000476e:	f8d8 e010 	ldr.w	r14, [r8, #16]
30004772:	4662      	mov	r2, r12
30004774:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30004778:	2300      	movs	r3, #0
3000477a:	e9cd 2318 	strd	r2, r3, [r13, #96]	; 0x60
3000477e:	fbac 230e 	umull	r2, r3, r12, r14
30004782:	4299      	cmp	r1, r3
30004784:	bf08      	it	eq
30004786:	4290      	cmpeq	r0, r2
30004788:	f0c0 856b 	bcc.w	30005262 <cmd_flash_storage+0x1596>
    uintptr_t data_end = (uintptr_t)data + sz;
3000478c:	9b06      	ldr	r3, [sp, #24]
    data += sizeof(sparse_header_t);
3000478e:	f108 061c 	add.w	r6, r8, #28
    uintptr_t data_end = (uintptr_t)data + sz;
30004792:	4443      	add	r3, r8
    if (data_end < (uintptr_t)data) {
30004794:	429e      	cmp	r6, r3
    uintptr_t data_end = (uintptr_t)data + sz;
30004796:	9312      	str	r3, [sp, #72]	; 0x48
    if (data_end < (uintptr_t)data) {
30004798:	f200 8603 	bhi.w	300053a2 <cmd_flash_storage+0x16d6>
    if (sparse_header->file_hdr_sz != sizeof(sparse_header_t)) {
3000479c:	f8b8 3008 	ldrh.w	r3, [r8, #8]
300047a0:	2b1c      	cmp	r3, #28
300047a2:	f040 8634 	bne.w	3000540e <cmd_flash_storage+0x1742>
    for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
300047a6:	f8d8 3014 	ldr.w	r3, [r8, #20]
300047aa:	9306      	str	r3, [sp, #24]
300047ac:	2b00      	cmp	r3, #0
300047ae:	f000 87a7 	beq.w	30005700 <cmd_flash_storage+0x1a34>
        if (((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
300047b2:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
300047b6:	4313      	orrs	r3, r2
300047b8:	f000 87ce 	beq.w	30005758 <cmd_flash_storage+0x1a8c>
        if (data_end < (uintptr_t)data) {
300047bc:	9a12      	ldr	r2, [sp, #72]	; 0x48
        data += sizeof(chunk_header_t);
300047be:	f108 0328 	add.w	r3, r8, #40	; 0x28
300047c2:	9310      	str	r3, [sp, #64]	; 0x40
        if (data_end < (uintptr_t)data) {
300047c4:	429a      	cmp	r2, r3
300047c6:	f0c0 87b1 	bcc.w	3000572c <cmd_flash_storage+0x1a60>
        if (sparse_header->chunk_hdr_sz != sizeof(chunk_header_t)) {
300047ca:	f8b8 300a 	ldrh.w	r3, [r8, #10]
300047ce:	2b0c      	cmp	r3, #12
300047d0:	f041 8004 	bne.w	300057dc <cmd_flash_storage+0x1b10>
        chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
300047d4:	f8d8 e020 	ldr.w	r14, [r8, #32]
        if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
300047d8:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
        chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
300047dc:	fbac 230e 	umull	r2, r3, r12, r14
        if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
300047e0:	4299      	cmp	r1, r3
        chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
300047e2:	e9cd 230e 	strd	r2, r3, [r13, #56]	; 0x38
        if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
300047e6:	bf08      	it	eq
300047e8:	4290      	cmpeq	r0, r2
300047ea:	d375      	bcc.n	300048d8 <cmd_flash_storage+0xc0c>
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
300047ec:	970c      	str	r7, [sp, #48]	; 0x30
    st_info = &current_dl_state->st_info;
300047ee:	f10a 0310 	add.w	r3, r10, #16
        if (((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
300047f2:	2000      	movs	r0, #0
300047f4:	2100      	movs	r1, #0
    st_info = &current_dl_state->st_info;
300047f6:	931e      	str	r3, [sp, #120]	; 0x78
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
300047f8:	4677      	mov	r7, r14
300047fa:	f8cd 9054 	str.w	r9, [r13, #84]	; 0x54
    for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
300047fe:	2300      	movs	r3, #0
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
30004800:	f8dd 9040 	ldr.w	r9, [r13, #64]	; 0x40
30004804:	f8cd a058 	str.w	r10, [r13, #88]	; 0x58
30004808:	46da      	mov	r10, r11
    for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
3000480a:	9320      	str	r3, [sp, #128]	; 0x80
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
3000480c:	46b3      	mov	r11, r6
3000480e:	9421      	str	r4, [sp, #132]	; 0x84
30004810:	9e06      	ldr	r6, [sp, #24]
30004812:	f8cd 8040 	str.w	r8, [r13, #64]	; 0x40
30004816:	9506      	str	r5, [sp, #24]
        switch (chunk_header->chunk_type) {
30004818:	f8bb 3000 	ldrh.w	r3, [r11]
3000481c:	f5a3 424a 	sub.w	r2, r3, #51712	; 0xca00
30004820:	3ac1      	subs	r2, #193	; 0xc1
30004822:	2a03      	cmp	r2, #3
30004824:	f200 865c 	bhi.w	300054e0 <cmd_flash_storage+0x1814>
30004828:	e8df f012 	tbh	[r15, r2, lsl #1]
3000482c:	00d00068 	.word	0x00d00068
30004830:	000400c9 	.word	0x000400c9
                if (chunk_header->total_sz != sparse_header->chunk_hdr_sz) {
30004834:	f8db 3008 	ldr.w	r3, [r11, #8]
30004838:	2b0c      	cmp	r3, #12
3000483a:	f040 87de 	bne.w	300057fa <cmd_flash_storage+0x1b2e>
                if (total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
3000483e:	43fb      	mvns	r3, r7
30004840:	4553      	cmp	r3, r10
30004842:	f0c1 8022 	bcc.w	3000588a <cmd_flash_storage+0x1bbe>
                if ((uintptr_t)data > UINT_MAX - chunk_data_sz) {
30004846:	e9dd 010e 	ldrd	r0, r1, [r13, #56]	; 0x38
3000484a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
3000484e:	2300      	movs	r3, #0
                total_blocks += chunk_header->chunk_sz;
30004850:	44ba      	add	r10, r7
                if ((uintptr_t)data > UINT_MAX - chunk_data_sz) {
30004852:	1a10      	subs	r0, r2, r0
30004854:	4602      	mov	r2, r0
30004856:	eb63 0101 	sbc.w	r1, r3, r1
3000485a:	460b      	mov	r3, r1
3000485c:	2100      	movs	r1, #0
3000485e:	428b      	cmp	r3, r1
30004860:	bf08      	it	eq
30004862:	454a      	cmpeq	r2, r9
30004864:	f0c0 87fc 	bcc.w	30005860 <cmd_flash_storage+0x1b94>
                data += (uint32_t)chunk_data_sz;
30004868:	9b0e      	ldr	r3, [sp, #56]	; 0x38
3000486a:	444b      	add	r3, r9
3000486c:	469b      	mov	r11, r3
                if (data_end < (uintptr_t)data) {
3000486e:	9b12      	ldr	r3, [sp, #72]	; 0x48
30004870:	459b      	cmp	r11, r3
30004872:	f201 80b3 	bhi.w	300059dc <cmd_flash_storage+0x1d10>
    for (chunk = 0; chunk < sparse_header->total_chunks; chunk++) {
30004876:	9b20      	ldr	r3, [sp, #128]	; 0x80
30004878:	3301      	adds	r3, #1
3000487a:	42b3      	cmp	r3, r6
3000487c:	9320      	str	r3, [sp, #128]	; 0x80
3000487e:	f080 8734 	bcs.w	300056ea <cmd_flash_storage+0x1a1e>
        if (((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz) >= size) {
30004882:	9b10      	ldr	r3, [sp, #64]	; 0x40
30004884:	2400      	movs	r4, #0
30004886:	f8d3 c00c 	ldr.w	r12, [r3, #12]
3000488a:	4663      	mov	r3, r12
3000488c:	fbaa 010c 	umull	r0, r1, r10, r12
30004890:	e9cd 3418 	strd	r3, r4, [r13, #96]	; 0x60
30004894:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30004898:	4299      	cmp	r1, r3
3000489a:	bf08      	it	eq
3000489c:	4290      	cmpeq	r0, r2
3000489e:	f080 8759 	bcs.w	30005754 <cmd_flash_storage+0x1a88>
        if (data_end < (uintptr_t)data) {
300048a2:	9b12      	ldr	r3, [sp, #72]	; 0x48
        data += sizeof(chunk_header_t);
300048a4:	f10b 090c 	add.w	r9, r11, #12
        if (data_end < (uintptr_t)data) {
300048a8:	454b      	cmp	r3, r9
300048aa:	f0c0 873b 	bcc.w	30005724 <cmd_flash_storage+0x1a58>
        if (sparse_header->chunk_hdr_sz != sizeof(chunk_header_t)) {
300048ae:	9b10      	ldr	r3, [sp, #64]	; 0x40
300048b0:	895b      	ldrh	r3, [r3, #10]
300048b2:	2b0c      	cmp	r3, #12
300048b4:	f040 8790 	bne.w	300057d8 <cmd_flash_storage+0x1b0c>
        chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
300048b8:	f8db 7004 	ldr.w	r7, [r11, #4]
        if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
300048bc:	e9dd 450a 	ldrd	r4, r5, [r13, #40]	; 0x28
        chunk_data_sz = (uint64_t)sparse_header->blk_sz * chunk_header->chunk_sz;
300048c0:	fbac 2307 	umull	r2, r3, r12, r7
300048c4:	e9cd 230e 	strd	r2, r3, [r13, #56]	; 0x38
        if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
300048c8:	1812      	adds	r2, r2, r0
300048ca:	414b      	adcs	r3, r1
300048cc:	429d      	cmp	r5, r3
300048ce:	bf08      	it	eq
300048d0:	4294      	cmpeq	r4, r2
300048d2:	d2a1      	bcs.n	30004818 <cmd_flash_storage+0xb4c>
300048d4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300048d6:	9d06      	ldr	r5, [sp, #24]
            ERROR("chunk data too large:%llu!\n", size);
300048d8:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
300048dc:	f24a 7194 	movw	r1, #42900	; 0xa794
300048e0:	f64a 6054 	movw	r0, #44628	; 0xae54
300048e4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300048e8:	e9cd 3400 	strd	r3, r4, [r13]
300048ec:	f2c3 0001 	movt	r0, #12289	; 0x3001
300048f0:	f240 326d 	movw	r2, #877	; 0x36d
300048f4:	f011 f95c 	bl	30015bb0 <_printf>
            err = ERR_SPARSE_IMAGE_CHUNK_TOO_LARGE;
300048f8:	2012      	movs	r0, #18
300048fa:	e44a      	b.n	30004192 <cmd_flash_storage+0x4c6>
                        sparse_header->chunk_hdr_sz +
300048fc:	e9dd 450e 	ldrd	r4, r5, [r13, #56]	; 0x38
                if ((uint64_t)chunk_header->total_sz != ((uint64_t)
30004900:	2300      	movs	r3, #0
30004902:	f8db 2008 	ldr.w	r2, [r11, #8]
                        sparse_header->chunk_hdr_sz +
30004906:	340c      	adds	r4, #12
30004908:	f145 0500 	adc.w	r5, r5, #0
                if ((uint64_t)chunk_header->total_sz != ((uint64_t)
3000490c:	42ab      	cmp	r3, r5
3000490e:	bf08      	it	eq
30004910:	42a2      	cmpeq	r2, r4
30004912:	f041 804e 	bne.w	300059b2 <cmd_flash_storage+0x1ce6>
                if (data_end < (uintptr_t)data + chunk_data_sz) {
30004916:	e9dd 450e 	ldrd	r4, r5, [r13, #56]	; 0x38
3000491a:	2700      	movs	r7, #0
3000491c:	9b12      	ldr	r3, [sp, #72]	; 0x48
3000491e:	461e      	mov	r6, r3
30004920:	eb14 0409 	adds.w	r4, r4, r9
30004924:	f145 0500 	adc.w	r5, r5, #0
30004928:	42af      	cmp	r7, r5
3000492a:	bf08      	it	eq
3000492c:	42a6      	cmpeq	r6, r4
3000492e:	f0c1 8028 	bcc.w	30005982 <cmd_flash_storage+0x1cb6>
                pos = ptn + ((uint64_t)total_blocks * sparse_header->blk_sz);
30004932:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
30004936:	182b      	adds	r3, r5, r0
30004938:	eb46 0401 	adc.w	r4, r6, r1
3000493c:	4622      	mov	r2, r4
3000493e:	4619      	mov	r1, r3
                if (pos == ptn && st_info->type == OSPI) {
30004940:	4296      	cmp	r6, r2
                pos = ptn + ((uint64_t)total_blocks * sparse_header->blk_sz);
30004942:	e9cd 121c 	strd	r1, r2, [r13, #112]	; 0x70
                if (pos == ptn && st_info->type == OSPI) {
30004946:	bf08      	it	eq
30004948:	428d      	cmpeq	r5, r1
3000494a:	f000 8679 	beq.w	30005640 <cmd_flash_storage+0x1974>
                if (!IS_ALIGNED((uint32_t)data_ptr_temp, st_info->block_size)) {
3000494e:	9b16      	ldr	r3, [sp, #88]	; 0x58
30004950:	6f1b      	ldr	r3, [r3, #112]	; 0x70
30004952:	1e5a      	subs	r2, r3, #1
30004954:	ea19 0f02 	tst.w	r9, r2
30004958:	f040 85e7 	bne.w	3000552a <cmd_flash_storage+0x185e>
                    if (storage->write(storage, pos, (uint8_t *)data,
3000495c:	9a15      	ldr	r2, [sp, #84]	; 0x54
3000495e:	461c      	mov	r4, r3
30004960:	2500      	movs	r5, #0
30004962:	68d6      	ldr	r6, [r2, #12]
    if (aligned == 0 || size < aligned)
30004964:	b19b      	cbz	r3, 3000498e <cmd_flash_storage+0xcc2>
30004966:	e9dd 010e 	ldrd	r0, r1, [r13, #56]	; 0x38
3000496a:	42a9      	cmp	r1, r5
3000496c:	bf08      	it	eq
3000496e:	42a0      	cmpeq	r0, r4
30004970:	d30d      	bcc.n	3000498e <cmd_flash_storage+0xcc2>
    mod = size % aligned;
30004972:	4622      	mov	r2, r4
30004974:	462b      	mov	r3, r5
30004976:	f015 fa53 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
3000497a:	ea52 0103 	orrs.w	r1, r2, r3
3000497e:	d002      	beq.n	30004986 <cmd_flash_storage+0xcba>
30004980:	1aa2      	subs	r2, r4, r2
30004982:	eb65 0303 	sbc.w	r3, r5, r3
30004986:	e9dd 450e 	ldrd	r4, r5, [r13, #56]	; 0x38
3000498a:	18a4      	adds	r4, r4, r2
3000498c:	415d      	adcs	r5, r3
3000498e:	e9cd 4502 	strd	r4, r5, [r13, #8]
30004992:	9815      	ldr	r0, [sp, #84]	; 0x54
30004994:	f8cd 9000 	str.w	r9, [r13]
30004998:	e9dd 231c 	ldrd	r2, r3, [r13, #112]	; 0x70
3000499c:	47b0      	blx	r6
3000499e:	2800      	cmp	r0, #0
300049a0:	f040 874d 	bne.w	3000583e <cmd_flash_storage+0x1b72>
                if (total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
300049a4:	f8db 3004 	ldr.w	r3, [r11, #4]
300049a8:	43da      	mvns	r2, r3
300049aa:	4552      	cmp	r2, r10
300049ac:	f0c0 8736 	bcc.w	3000581c <cmd_flash_storage+0x1b50>
                total_blocks += chunk_header->chunk_sz;
300049b0:	449a      	add	r10, r3
                data += (uint32_t)chunk_data_sz;
300049b2:	9b0e      	ldr	r3, [sp, #56]	; 0x38
300049b4:	444b      	add	r3, r9
300049b6:	469b      	mov	r11, r3
300049b8:	9b10      	ldr	r3, [sp, #64]	; 0x40
300049ba:	695e      	ldr	r6, [r3, #20]
300049bc:	e75b      	b.n	30004876 <cmd_flash_storage+0xbaa>
                if (total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
300049be:	43fb      	mvns	r3, r7
300049c0:	4553      	cmp	r3, r10
300049c2:	f0c0 8786 	bcc.w	300058d2 <cmd_flash_storage+0x1c06>
                total_blocks += chunk_header->chunk_sz;
300049c6:	46cb      	mov	r11, r9
300049c8:	44ba      	add	r10, r7
300049ca:	e754      	b.n	30004876 <cmd_flash_storage+0xbaa>
                if (chunk_header->total_sz != (sparse_header->chunk_hdr_sz +
300049cc:	f8db 3008 	ldr.w	r3, [r11, #8]
300049d0:	2b10      	cmp	r3, #16
300049d2:	f040 876d 	bne.w	300058b0 <cmd_flash_storage+0x1be4>
    if (aligned == 0 || size < aligned)
300049d6:	e9dd 3418 	ldrd	r3, r4, [r13, #96]	; 0x60
300049da:	2c00      	cmp	r4, #0
300049dc:	bf08      	it	eq
300049de:	2b20      	cmpeq	r3, #32
300049e0:	f0c0 85a0 	bcc.w	30005524 <cmd_flash_storage+0x1858>
    size += mod ? aligned - mod : 0;
300049e4:	f01c 011f 	ands.w	r1, r12, #31
300049e8:	f000 86cd 	beq.w	30005786 <cmd_flash_storage+0x1aba>
300049ec:	2220      	movs	r2, #32
300049ee:	1a54      	subs	r4, r2, r1
300049f0:	e9dd 2318 	ldrd	r2, r3, [r13, #96]	; 0x60
300049f4:	1912      	adds	r2, r2, r4
                if (blk_sz_actual < sparse_header->blk_sz) {
300049f6:	4562      	cmp	r2, r12
300049f8:	f0c0 8792 	bcc.w	30005920 <cmd_flash_storage+0x1c54>
                if (data_end < (uintptr_t)data + sizeof(uint32_t)) {
300049fc:	9a12      	ldr	r2, [sp, #72]	; 0x48
300049fe:	f109 0304 	add.w	r3, r9, #4
30004a02:	429a      	cmp	r2, r3
30004a04:	f0c0 8778 	bcc.w	300058f8 <cmd_flash_storage+0x1c2c>
                fill_val = *(uint32_t *)data;
30004a08:	f8db 700c 	ldr.w	r7, [r11, #12]
                data = (char *) data + sizeof(uint32_t);
30004a0c:	f10b 0310 	add.w	r3, r11, #16
                while (chunk_data_sz_remain) {
30004a10:	f04f 0900 	mov.w	r9, #0
                data = (char *) data + sizeof(uint32_t);
30004a14:	931c      	str	r3, [sp, #112]	; 0x70
                while (chunk_data_sz_remain) {
30004a16:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
30004a1a:	4698      	mov	r8, r3
30004a1c:	2b00      	cmp	r3, #0
30004a1e:	f000 863a 	beq.w	30005696 <cmd_flash_storage+0x19ca>
                    if (SPARSE_DATA_ALIGNED_SIZE > chunk_data_sz_remain) {
30004a22:	f64f 73ff 	movw	r3, #65535	; 0xffff
30004a26:	2400      	movs	r4, #0
30004a28:	f2c0 037f 	movt	r3, #127	; 0x7f
30004a2c:	454c      	cmp	r4, r9
30004a2e:	bf08      	it	eq
30004a30:	4543      	cmpeq	r3, r8
30004a32:	f080 852e 	bcs.w	30005492 <cmd_flash_storage+0x17c6>
                                && i < (count_aligned / sizeof(fill_val)); i++) {
30004a36:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
30004a3a:	2100      	movs	r1, #0
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
30004a3c:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
30004a40:	2400      	movs	r4, #0
                                && i < (count_aligned / sizeof(fill_val)); i++) {
30004a42:	2200      	movs	r2, #0
30004a44:	2300      	movs	r3, #0
30004a46:	f04f 564a 	mov.w	r6, #847249408	; 0x32800000
                            fill_buf[i] = fill_val;
30004a4a:	f846 7b04 	str.w	r7, [r6], #4
30004a4e:	3201      	adds	r2, #1
30004a50:	f143 0300 	adc.w	r3, r3, #0
                                && i < (count_aligned / sizeof(fill_val)); i++) {
30004a54:	428b      	cmp	r3, r1
30004a56:	bf08      	it	eq
30004a58:	4282      	cmpeq	r2, r0
30004a5a:	d3f6      	bcc.n	30004a4a <cmd_flash_storage+0xd7e>
30004a5c:	f8cd a038 	str.w	r10, [r13, #56]	; 0x38
30004a60:	f8cd b068 	str.w	r11, [r13, #104]	; 0x68
30004a64:	46aa      	mov	r10, r5
30004a66:	46a3      	mov	r11, r4
                    if (total_blocks > (UINT_MAX - chunk_header->chunk_sz)) {
30004a68:	9b1a      	ldr	r3, [sp, #104]	; 0x68
30004a6a:	990e      	ldr	r1, [sp, #56]	; 0x38
30004a6c:	685b      	ldr	r3, [r3, #4]
30004a6e:	43da      	mvns	r2, r3
30004a70:	428a      	cmp	r2, r1
30004a72:	f0c0 86a0 	bcc.w	300057b6 <cmd_flash_storage+0x1aea>
                    if ((uint64_t)total_blocks * (uint64_t)sparse_header->blk_sz +
30004a76:	9b10      	ldr	r3, [sp, #64]	; 0x40
30004a78:	2100      	movs	r1, #0
30004a7a:	2500      	movs	r5, #0
30004a7c:	f8d3 c00c 	ldr.w	r12, [r3, #12]
30004a80:	9b0e      	ldr	r3, [sp, #56]	; 0x38
30004a82:	1c5a      	adds	r2, r3, #1
30004a84:	f141 0300 	adc.w	r3, r1, #0
30004a88:	fba2 010c 	umull	r0, r1, r2, r12
30004a8c:	fb0c 1103 	mla	r1, r12, r3, r1
30004a90:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30004a94:	428b      	cmp	r3, r1
30004a96:	bf08      	it	eq
30004a98:	4282      	cmpeq	r2, r0
30004a9a:	f0c0 8677 	bcc.w	3000578c <cmd_flash_storage+0x1ac0>
                    pos = ptn + ((uint64_t)total_blocks * sparse_header->blk_sz);
30004a9e:	ebb0 020c 	subs.w	r2, r0, r12
30004aa2:	eb61 0305 	sbc.w	r3, r1, r5
30004aa6:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30004aaa:	1886      	adds	r6, r0, r2
30004aac:	eb41 0703 	adc.w	r7, r1, r3
                    if (pos == ptn && st_info->type == OSPI) {
30004ab0:	42b9      	cmp	r1, r7
30004ab2:	bf08      	it	eq
30004ab4:	42b0      	cmpeq	r0, r6
30004ab6:	f000 8485 	beq.w	300053c4 <cmd_flash_storage+0x16f8>
                    if (storage->write(storage, pos, (uint8_t *)fill_buf,
30004aba:	9b16      	ldr	r3, [sp, #88]	; 0x58
30004abc:	2100      	movs	r1, #0
30004abe:	460d      	mov	r5, r1
    if (aligned == 0 || size < aligned)
30004ac0:	458b      	cmp	r11, r1
30004ac2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
30004ac4:	9b15      	ldr	r3, [sp, #84]	; 0x54
30004ac6:	4614      	mov	r4, r2
30004ac8:	bf08      	it	eq
30004aca:	4592      	cmpeq	r10, r2
30004acc:	68db      	ldr	r3, [r3, #12]
30004ace:	9318      	str	r3, [sp, #96]	; 0x60
30004ad0:	bf34      	ite	cc
30004ad2:	2301      	movcc	r3, #1
30004ad4:	2300      	movcs	r3, #0
30004ad6:	2a00      	cmp	r2, #0
30004ad8:	bf08      	it	eq
30004ada:	2301      	moveq	r3, #1
30004adc:	b98b      	cbnz	r3, 30004b02 <cmd_flash_storage+0xe36>
    mod = size % aligned;
30004ade:	460b      	mov	r3, r1
30004ae0:	4650      	mov	r0, r10
30004ae2:	4659      	mov	r1, r11
30004ae4:	f015 f99c 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30004ae8:	ea52 0103 	orrs.w	r1, r2, r3
30004aec:	bf04      	itt	eq
30004aee:	4654      	moveq	r4, r10
30004af0:	465d      	moveq	r5, r11
30004af2:	d006      	beq.n	30004b02 <cmd_flash_storage+0xe36>
30004af4:	eb14 040a 	adds.w	r4, r4, r10
30004af8:	eb45 050b 	adc.w	r5, r5, r11
30004afc:	1aa4      	subs	r4, r4, r2
30004afe:	eb65 0503 	sbc.w	r5, r5, r3
30004b02:	f04f 514a 	mov.w	r1, #847249408	; 0x32800000
30004b06:	463b      	mov	r3, r7
30004b08:	e9cd 4502 	strd	r4, r5, [r13, #8]
30004b0c:	4632      	mov	r2, r6
30004b0e:	9100      	str	r1, [sp, #0]
30004b10:	9815      	ldr	r0, [sp, #84]	; 0x54
30004b12:	9918      	ldr	r1, [sp, #96]	; 0x60
30004b14:	4788      	blx	r1
30004b16:	4603      	mov	r3, r0
30004b18:	2800      	cmp	r0, #0
30004b1a:	f040 85d1 	bne.w	300056c0 <cmd_flash_storage+0x19f4>
                    total_blocks += count_aligned / sparse_header->blk_sz;
30004b1e:	9a10      	ldr	r2, [sp, #64]	; 0x40
30004b20:	4650      	mov	r0, r10
30004b22:	4659      	mov	r1, r11
30004b24:	68d2      	ldr	r2, [r2, #12]
30004b26:	f015 f97b 	bl	30019e20 <__aeabi_uldivmod>
30004b2a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                    chunk_data_sz_remain -= count_aligned;
30004b2c:	ebb8 080a 	subs.w	r8, r8, r10
30004b30:	eb69 090b 	sbc.w	r9, r9, r11
                    total_blocks += count_aligned / sparse_header->blk_sz;
30004b34:	4403      	add	r3, r0
30004b36:	930e      	str	r3, [sp, #56]	; 0x38
                while (chunk_data_sz_remain) {
30004b38:	ea58 0309 	orrs.w	r3, r8, r9
30004b3c:	f000 85a7 	beq.w	3000568e <cmd_flash_storage+0x19c2>
                    if (SPARSE_DATA_ALIGNED_SIZE > chunk_data_sz_remain) {
30004b40:	f64f 72ff 	movw	r2, #65535	; 0xffff
30004b44:	2300      	movs	r3, #0
30004b46:	f2c0 027f 	movt	r2, #127	; 0x7f
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
30004b4a:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
                    if (SPARSE_DATA_ALIGNED_SIZE > chunk_data_sz_remain) {
30004b4e:	454b      	cmp	r3, r9
                        count_aligned = SPARSE_DATA_ALIGNED_SIZE;
30004b50:	f04f 0400 	mov.w	r4, #0
                    if (SPARSE_DATA_ALIGNED_SIZE > chunk_data_sz_remain) {
30004b54:	bf08      	it	eq
30004b56:	4542      	cmpeq	r2, r8
30004b58:	46c2      	mov	r10, r8
30004b5a:	46cb      	mov	r11, r9
30004b5c:	d284      	bcs.n	30004a68 <cmd_flash_storage+0xd9c>
30004b5e:	e781      	b.n	30004a64 <cmd_flash_storage+0xd98>
        ERROR("boot partition doesn't use sparse image \n");
30004b60:	f24a 7194 	movw	r1, #42900	; 0xa794
30004b64:	f64a 40bc 	movw	r0, #44220	; 0xacbc
30004b68:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004b6c:	f240 22fa 	movw	r2, #762	; 0x2fa
30004b70:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004b74:	f011 f81c 	bl	30015bb0 <_printf>
        err = ERR_IMAGE_TOO_LARGE;
30004b78:	2005      	movs	r0, #5
30004b7a:	f7ff bb0a 	b.w	30004192 <cmd_flash_storage+0x4c6>
        ERROR(" image too large:%llu!\n",
30004b7e:	e9dd 340c 	ldrd	r3, r4, [r13, #48]	; 0x30
30004b82:	f64a 0118 	movw	r1, #43032	; 0xa818
30004b86:	f24b 4068 	movw	r0, #46184	; 0xb468
30004b8a:	f240 6283 	movw	r2, #1667	; 0x683
30004b8e:	e9cd 3400 	strd	r3, r4, [r13]
30004b92:	f2c3 0101 	movt	r1, #12289	; 0x3001
        return 1;
30004b96:	2401      	movs	r4, #1
        ERROR(" image too large:%llu!\n",
30004b98:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004b9c:	f011 f808 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(err, full_ptname));
30004ba0:	4629      	mov	r1, r5
30004ba2:	2005      	movs	r0, #5
30004ba4:	f7fd ff06 	bl	300029b4 <response_error>
30004ba8:	4601      	mov	r1, r0
30004baa:	9814      	ldr	r0, [sp, #80]	; 0x50
30004bac:	f00f fd38 	bl	30014620 <fastboot_common_fail>
30004bb0:	e498      	b.n	300044e4 <cmd_flash_storage+0x818>
        return 0;
30004bb2:	2300      	movs	r3, #0
30004bb4:	2400      	movs	r4, #0
30004bb6:	e9cd 3416 	strd	r3, r4, [r13, #88]	; 0x58
30004bba:	f7ff ba66 	b.w	3000408a <cmd_flash_storage+0x3be>
    size += mod ? aligned - mod : 0;
30004bbe:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30004bc2:	e9cd 340c 	strd	r3, r4, [r13, #48]	; 0x30
30004bc6:	f7ff bb51 	b.w	3000426c <cmd_flash_storage+0x5a0>
        ERROR("download gpt image error");
30004bca:	f24a 7148 	movw	r1, #42824	; 0xa748
30004bce:	f24b 1014 	movw	r0, #45332	; 0xb114
    uint8_t  *buffer    = NULL;
30004bd2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
        ERROR("download gpt image error");
30004bd4:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004bd8:	f240 2212 	movw	r2, #530	; 0x212
30004bdc:	f2c3 0001 	movt	r0, #12289	; 0x3001
    uint8_t  *buffer    = NULL;
30004be0:	931c      	str	r3, [sp, #112]	; 0x70
        ERROR("download gpt image error");
30004be2:	f010 ffe5 	bl	30015bb0 <_printf>
    uint32_t ret        = PTB_CHECK_ERROR;
30004be6:	2302      	movs	r3, #2
30004be8:	469b      	mov	r11, r3
30004bea:	f7ff b9a2 	b.w	30003f32 <cmd_flash_storage+0x266>
    struct sfs sfs = {0};
30004bee:	2278      	movs	r2, #120	; 0x78
30004bf0:	ad40      	add	r5, sp, #256	; 0x100
30004bf2:	4628      	mov	r0, r5
30004bf4:	f00f eebc 	blx	30014970 <memset>
    if (msfs->magic != MSFS_MAGIC ||
30004bf8:	f245 334d 	movw	r3, #21325	; 0x534d
    uint64_t flash_id = 0, flash_id_mask;
30004bfc:	2000      	movs	r0, #0
    if (msfs->magic != MSFS_MAGIC ||
30004bfe:	f2c5 3346 	movt	r3, #21318	; 0x5346
    uint64_t flash_id = 0, flash_id_mask;
30004c02:	2100      	movs	r1, #0
    if (msfs->magic != MSFS_MAGIC ||
30004c04:	429c      	cmp	r4, r3
    uint64_t flash_id = 0, flash_id_mask;
30004c06:	e9cd 0124 	strd	r0, r1, [r13, #144]	; 0x90
    if (msfs->magic != MSFS_MAGIC ||
30004c0a:	d105      	bne.n	30004c18 <cmd_flash_storage+0xf4c>
            msfs->count == 0 ||
30004c0c:	f8d8 2008 	ldr.w	r2, [r8, #8]
30004c10:	1e53      	subs	r3, r2, #1
30004c12:	2b07      	cmp	r3, #7
30004c14:	f240 834d 	bls.w	300052b2 <cmd_flash_storage+0x15e6>
        dprintf(CRITICAL, "The sfs image is not muti-sfs image!\n");
30004c18:	f24b 3018 	movw	r0, #45848	; 0xb318
30004c1c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004c20:	f010 ffc6 	bl	30015bb0 <_printf>
    if (get_sfs_info(&sfs, *data, *sz)) {
30004c24:	4628      	mov	r0, r5
30004c26:	4641      	mov	r1, r8
30004c28:	9a06      	ldr	r2, [sp, #24]
30004c2a:	f000 ff7b 	bl	30005b24 <get_sfs_info>
30004c2e:	2800      	cmp	r0, #0
30004c30:	f040 81ec 	bne.w	3000500c <cmd_flash_storage+0x1340>
    patched = patch_sfs(ptdev, data, sz);
30004c34:	980a      	ldr	r0, [sp, #40]	; 0x28
30004c36:	4641      	mov	r1, r8
30004c38:	9a06      	ldr	r2, [sp, #24]
30004c3a:	f7fd f9db 	bl	30001ff4 <patch_sfs>
    if (patched)
30004c3e:	2800      	cmp	r0, #0
30004c40:	f040 83a6 	bne.w	30005390 <cmd_flash_storage+0x16c4>
    storage->erase(storage, ptn, round_up(sz, st_info->erase_grp_sz));
30004c44:	9b06      	ldr	r3, [sp, #24]
30004c46:	2100      	movs	r1, #0
30004c48:	f8da 2080 	ldr.w	r2, [r10, #128]	; 0x80
30004c4c:	461d      	mov	r5, r3
30004c4e:	2600      	movs	r6, #0
30004c50:	4610      	mov	r0, r2
30004c52:	9b08      	ldr	r3, [sp, #32]
    if (aligned == 0 || size < aligned)
30004c54:	428e      	cmp	r6, r1
30004c56:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30004c5a:	bf08      	it	eq
30004c5c:	4295      	cmpeq	r5, r2
30004c5e:	691c      	ldr	r4, [r3, #16]
30004c60:	bf34      	ite	cc
30004c62:	2301      	movcc	r3, #1
30004c64:	2300      	movcs	r3, #0
30004c66:	2a00      	cmp	r2, #0
30004c68:	bf08      	it	eq
30004c6a:	2301      	moveq	r3, #1
30004c6c:	b98b      	cbnz	r3, 30004c92 <cmd_flash_storage+0xfc6>
    mod = size % aligned;
30004c6e:	460b      	mov	r3, r1
30004c70:	4628      	mov	r0, r5
30004c72:	4631      	mov	r1, r6
30004c74:	f015 f8d4 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30004c78:	ea52 0103 	orrs.w	r1, r2, r3
30004c7c:	f000 83d9 	beq.w	30005432 <cmd_flash_storage+0x1766>
30004c80:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30004c84:	1940      	adds	r0, r0, r5
30004c86:	4171      	adcs	r1, r6
30004c88:	1a80      	subs	r0, r0, r2
30004c8a:	eb61 0103 	sbc.w	r1, r1, r3
30004c8e:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30004c92:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30004c96:	f8dd b020 	ldr.w	r11, [r13, #32]
30004c9a:	e9cd 2300 	strd	r2, r3, [r13]
30004c9e:	4658      	mov	r0, r11
30004ca0:	2200      	movs	r2, #0
30004ca2:	2300      	movs	r3, #0
30004ca4:	47a0      	blx	r4
    if (storage->write(storage, ptn, data,
30004ca6:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
30004caa:	2100      	movs	r1, #0
30004cac:	465b      	mov	r3, r11
30004cae:	4610      	mov	r0, r2
    if (aligned == 0 || size < aligned)
30004cb0:	428e      	cmp	r6, r1
30004cb2:	f8db 400c 	ldr.w	r4, [r11, #12]
30004cb6:	bf08      	it	eq
30004cb8:	4295      	cmpeq	r5, r2
30004cba:	bf34      	ite	cc
30004cbc:	2301      	movcc	r3, #1
30004cbe:	2300      	movcs	r3, #0
30004cc0:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30004cc4:	2a00      	cmp	r2, #0
30004cc6:	bf08      	it	eq
30004cc8:	2301      	moveq	r3, #1
30004cca:	b98b      	cbnz	r3, 30004cf0 <cmd_flash_storage+0x1024>
    mod = size % aligned;
30004ccc:	460b      	mov	r3, r1
30004cce:	4628      	mov	r0, r5
30004cd0:	4631      	mov	r1, r6
30004cd2:	f015 f8a5 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30004cd6:	ea52 0103 	orrs.w	r1, r2, r3
30004cda:	f000 83a7 	beq.w	3000542c <cmd_flash_storage+0x1760>
30004cde:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30004ce2:	1940      	adds	r0, r0, r5
30004ce4:	4171      	adcs	r1, r6
30004ce6:	1a80      	subs	r0, r0, r2
30004ce8:	eb61 0103 	sbc.w	r1, r1, r3
30004cec:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30004cf0:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30004cf4:	e9cd 2302 	strd	r2, r3, [r13, #8]
30004cf8:	2200      	movs	r2, #0
30004cfa:	9808      	ldr	r0, [sp, #32]
30004cfc:	2300      	movs	r3, #0
30004cfe:	f8cd 8000 	str.w	r8, [r13]
30004d02:	47a0      	blx	r4
30004d04:	2800      	cmp	r0, #0
30004d06:	f040 8334 	bne.w	30005372 <cmd_flash_storage+0x16a6>
    if (do_md5_check) {
30004d0a:	f646 4374 	movw	r3, #27764	; 0x6c74
30004d0e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30004d12:	781b      	ldrb	r3, [r3, #0]
30004d14:	2b00      	cmp	r3, #0
30004d16:	f43f a802 	beq.w	30003d1e <cmd_flash_storage+0x52>
        memset((void *)_ioaddr(SPARSE_DATA_ALIGNED_BASE), 0x0, sz);
30004d1a:	9a06      	ldr	r2, [sp, #24]
30004d1c:	4601      	mov	r1, r0
30004d1e:	f04f 504a 	mov.w	r0, #847249408	; 0x32800000
30004d22:	f00f ee26 	blx	30014970 <memset>
        if (storage->read(storage, ptn,
30004d26:	9b08      	ldr	r3, [sp, #32]
30004d28:	f8da 2070 	ldr.w	r2, [r10, #112]	; 0x70
30004d2c:	2100      	movs	r1, #0
30004d2e:	4692      	mov	r10, r2
    if (aligned == 0 || size < aligned)
30004d30:	428e      	cmp	r6, r1
30004d32:	f8d3 8008 	ldr.w	r8, [r3, #8]
30004d36:	bf08      	it	eq
30004d38:	4295      	cmpeq	r5, r2
30004d3a:	bf34      	ite	cc
30004d3c:	2301      	movcc	r3, #1
30004d3e:	2300      	movcs	r3, #0
30004d40:	468b      	mov	r11, r1
30004d42:	2a00      	cmp	r2, #0
30004d44:	bf08      	it	eq
30004d46:	2301      	moveq	r3, #1
30004d48:	b993      	cbnz	r3, 30004d70 <cmd_flash_storage+0x10a4>
    mod = size % aligned;
30004d4a:	460b      	mov	r3, r1
30004d4c:	4628      	mov	r0, r5
30004d4e:	4631      	mov	r1, r6
30004d50:	f015 f866 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30004d54:	ea52 0103 	orrs.w	r1, r2, r3
30004d58:	d005      	beq.n	30004d66 <cmd_flash_storage+0x109a>
30004d5a:	ebba 0002 	subs.w	r0, r10, r2
30004d5e:	4602      	mov	r2, r0
30004d60:	eb6b 0103 	sbc.w	r1, r11, r3
30004d64:	460b      	mov	r3, r1
30004d66:	18a8      	adds	r0, r5, r2
30004d68:	4682      	mov	r10, r0
30004d6a:	eb46 0103 	adc.w	r1, r6, r3
30004d6e:	468b      	mov	r11, r1
30004d70:	4652      	mov	r2, r10
30004d72:	465b      	mov	r3, r11
30004d74:	9808      	ldr	r0, [sp, #32]
30004d76:	f04f 544a 	mov.w	r4, #847249408	; 0x32800000
30004d7a:	e9cd 2302 	strd	r2, r3, [r13, #8]
30004d7e:	2200      	movs	r2, #0
30004d80:	9400      	str	r4, [sp, #0]
30004d82:	2300      	movs	r3, #0
30004d84:	47c0      	blx	r8
30004d86:	4605      	mov	r5, r0
30004d88:	2800      	cmp	r0, #0
30004d8a:	f040 839a 	bne.w	300054c2 <cmd_flash_storage+0x17f6>
            md5((unsigned char *)_ioaddr(SPARSE_DATA_ALIGNED_BASE), sz,
30004d8e:	9906      	ldr	r1, [sp, #24]
30004d90:	4620      	mov	r0, r4
30004d92:	464a      	mov	r2, r9
30004d94:	f011 fbf8 	bl	30016588 <md5>
            if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30004d98:	f646 40f8 	movw	r0, #27896	; 0x6cf8
30004d9c:	2210      	movs	r2, #16
30004d9e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30004da2:	4649      	mov	r1, r9
30004da4:	f010 ff26 	bl	30015bf4 <memcmp>
30004da8:	2800      	cmp	r0, #0
30004daa:	f43e afb8 	beq.w	30003d1e <cmd_flash_storage+0x52>
                ERROR("md5 check fail!\n");
30004dae:	f24a 71d8 	movw	r1, #42968	; 0xa7d8
30004db2:	f64b 10a8 	movw	r0, #47528	; 0xb9a8
30004db6:	f240 5231 	movw	r2, #1329	; 0x531
30004dba:	f2c3 0101 	movt	r1, #12289	; 0x3001
                return 1;
30004dbe:	2401      	movs	r4, #1
                ERROR("md5 check fail!\n");
30004dc0:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004dc4:	f010 fef4 	bl	30015bb0 <_printf>
30004dc8:	f646 42f8 	movw	r2, #27896	; 0x6cf8
30004dcc:	462b      	mov	r3, r5
30004dce:	f2c3 0202 	movt	r2, #12290	; 0x3002
30004dd2:	4610      	mov	r0, r2
30004dd4:	2110      	movs	r1, #16
30004dd6:	f00f faab 	bl	30014330 <hexdump8_ex>
30004dda:	464a      	mov	r2, r9
30004ddc:	462b      	mov	r3, r5
30004dde:	4648      	mov	r0, r9
30004de0:	f7ff bad1 	b.w	30004386 <cmd_flash_storage+0x6ba>
        ERROR("block size error:%u\n", sparse_header->blk_sz);
30004de4:	f24a 7194 	movw	r1, #42900	; 0xa794
30004de8:	f64a 5034 	movw	r0, #44340	; 0xad34
30004dec:	4663      	mov	r3, r12
30004dee:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004df2:	f240 3223 	movw	r2, #803	; 0x323
30004df6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004dfa:	f010 fed9 	bl	30015bb0 <_printf>
        err = ERR_INVALID_BLOCK_SIZE;
30004dfe:	200d      	movs	r0, #13
30004e00:	f7ff b9c7 	b.w	30004192 <cmd_flash_storage+0x4c6>
30004e04:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
30004e08:	e9cd 3410 	strd	r3, r4, [r13, #64]	; 0x40
30004e0c:	f7ff b963 	b.w	300040d6 <cmd_flash_storage+0x40a>
30004e10:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
30004e14:	e9cd 3410 	strd	r3, r4, [r13, #64]	; 0x40
30004e18:	f7ff b8fa 	b.w	30004010 <cmd_flash_storage+0x344>
30004e1c:	f8da 3070 	ldr.w	r3, [r10, #112]	; 0x70
30004e20:	9304      	str	r3, [sp, #16]
30004e22:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30004e26:	e9cd 3402 	strd	r3, r4, [r13, #8]
30004e2a:	e9dd 3410 	ldrd	r3, r4, [r13, #64]	; 0x40
30004e2e:	e9cd 3400 	strd	r3, r4, [r13]
30004e32:	9808      	ldr	r0, [sp, #32]
30004e34:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
30004e38:	f7fe fd36 	bl	300038a8 <padding_avb_footer.part.7.constprop.16>
30004e3c:	f7ff ba3e 	b.w	300042bc <cmd_flash_storage+0x5f0>
        if (!erase_nor_flash_partition(ptdev, st_info, full_ptname, sz)) {
30004e40:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30004e44:	4658      	mov	r0, r11
30004e46:	e9cd 3400 	strd	r3, r4, [r13]
30004e4a:	462a      	mov	r2, r5
30004e4c:	f10a 0110 	add.w	r1, r10, #16
30004e50:	f7fd f812 	bl	30001e78 <erase_nor_flash_partition>
30004e54:	2800      	cmp	r0, #0
30004e56:	f47f a9f4 	bne.w	30004242 <cmd_flash_storage+0x576>
            ERROR("erase partition fail\n");
30004e5a:	f64a 0118 	movw	r1, #43032	; 0xa818
30004e5e:	f24b 4044 	movw	r0, #46148	; 0xb444
30004e62:	f240 627a 	movw	r2, #1658	; 0x67a
30004e66:	f2c3 0101 	movt	r1, #12289	; 0x3001
            return 1;
30004e6a:	2401      	movs	r4, #1
            ERROR("erase partition fail\n");
30004e6c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004e70:	f010 fe9e 	bl	30015bb0 <_printf>
            fastboot_common_fail(fb, response_error(err, full_ptname));
30004e74:	4629      	mov	r1, r5
30004e76:	200a      	movs	r0, #10
30004e78:	f7fd fd9c 	bl	300029b4 <response_error>
30004e7c:	4601      	mov	r1, r0
30004e7e:	9814      	ldr	r0, [sp, #80]	; 0x50
30004e80:	f00f fbce 	bl	30014620 <fastboot_common_fail>
30004e84:	f7ff bb2e 	b.w	300044e4 <cmd_flash_storage+0x818>
        ERROR("storage device get error");
30004e88:	f24a 7148 	movw	r1, #42824	; 0xa748
30004e8c:	f24b 00ec 	movw	r0, #45292	; 0xb0ec
30004e90:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004e94:	f240 220d 	movw	r2, #525	; 0x20d
30004e98:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004e9c:	e6a0      	b.n	30004be0 <cmd_flash_storage+0xf14>
            ERROR("spare image size:%u error\n", sz);
30004e9e:	f24a 7194 	movw	r1, #42900	; 0xa794
30004ea2:	f64a 500c 	movw	r0, #44300	; 0xad0c
30004ea6:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004eaa:	f240 3219 	movw	r2, #793	; 0x319
30004eae:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004eb2:	f010 fe7d 	bl	30015bb0 <_printf>
            err = ERR_SPARSE_IMAGE_SIZE_TOO_LOW;
30004eb6:	200e      	movs	r0, #14
30004eb8:	f7ff b96b 	b.w	30004192 <cmd_flash_storage+0x4c6>
            snprintf(full_ptname, sizeof(full_ptname), "%s", sub_ptbname);
30004ebc:	f240 52e4 	movw	r2, #1508	; 0x5e4
30004ec0:	2192      	movs	r1, #146	; 0x92
30004ec2:	4628      	mov	r0, r5
30004ec4:	f2c3 0202 	movt	r2, #12290	; 0x3002
30004ec8:	f010 fe02 	bl	30015ad0 <snprintf>
30004ecc:	f7ff ba8c 	b.w	300043e8 <cmd_flash_storage+0x71c>
            ERROR("patch nor flash ptb error! ret:%d\n", ret);
30004ed0:	f24a 7148 	movw	r1, #42824	; 0xa748
30004ed4:	f24b 103c 	movw	r0, #45372	; 0xb13c
    uint8_t  *buffer    = NULL;
30004ed8:	9d1e      	ldr	r5, [sp, #120]	; 0x78
            ERROR("patch nor flash ptb error! ret:%d\n", ret);
30004eda:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004ede:	f44f 7207 	mov.w	r2, #540	; 0x21c
30004ee2:	f2c3 0001 	movt	r0, #12289	; 0x3001
    uint8_t  *buffer    = NULL;
30004ee6:	951c      	str	r5, [sp, #112]	; 0x70
            ERROR("patch nor flash ptb error! ret:%d\n", ret);
30004ee8:	f010 fe62 	bl	30015bb0 <_printf>
30004eec:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
            ret = PTB_CHECK_ERROR;
30004ef0:	2302      	movs	r3, #2
30004ef2:	469b      	mov	r11, r3
30004ef4:	f7ff b81f 	b.w	30003f36 <cmd_flash_storage+0x26a>
            ERROR("read back error!\n");
30004ef8:	f64a 0118 	movw	r1, #43032	; 0xa818
30004efc:	f24b 70d8 	movw	r0, #47064	; 0xb7d8
30004f00:	f44f 62d3 	mov.w	r2, #1688	; 0x698
30004f04:	f2c3 0101 	movt	r1, #12289	; 0x3001
            return 1;
30004f08:	2401      	movs	r4, #1
            ERROR("read back error!\n");
30004f0a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004f0e:	f010 fe4f 	bl	30015bb0 <_printf>
30004f12:	f7ff ba3b 	b.w	3000438c <cmd_flash_storage+0x6c0>
    sfs_size = round_up(SFS_SIZE, st_info->block_size);
30004f16:	6f25      	ldr	r5, [r4, #112]	; 0x70
30004f18:	f04f 0a00 	mov.w	r10, #0
30004f1c:	46a9      	mov	r9, r5
    if (aligned == 0 || size < aligned)
30004f1e:	1e6b      	subs	r3, r5, #1
30004f20:	2b7f      	cmp	r3, #127	; 0x7f
30004f22:	bf88      	it	hi
30004f24:	46a8      	movhi	r8, r5
30004f26:	d813      	bhi.n	30004f50 <cmd_flash_storage+0x1284>
    mod = size % aligned;
30004f28:	462a      	mov	r2, r5
30004f2a:	4653      	mov	r3, r10
30004f2c:	2080      	movs	r0, #128	; 0x80
30004f2e:	2100      	movs	r1, #0
30004f30:	f014 ff76 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30004f34:	ea52 0103 	orrs.w	r1, r2, r3
30004f38:	f000 81b4 	beq.w	300052a4 <cmd_flash_storage+0x15d8>
30004f3c:	f115 0080 	adds.w	r0, r5, #128	; 0x80
30004f40:	f14a 0100 	adc.w	r1, r10, #0
30004f44:	1a80      	subs	r0, r0, r2
30004f46:	4681      	mov	r9, r0
30004f48:	eb61 0103 	sbc.w	r1, r1, r3
30004f4c:	468a      	mov	r10, r1
30004f4e:	4680      	mov	r8, r0
    buffer = (uint8_t *)memalign(st_info->block_size, sfs_size);
30004f50:	4628      	mov	r0, r5
30004f52:	4641      	mov	r1, r8
    struct partition_device *ptdev = current_dl_state->ptdev;
30004f54:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
30004f58:	469b      	mov	r11, r3
    buffer = (uint8_t *)memalign(st_info->block_size, sfs_size);
30004f5a:	f00f fbdb 	bl	30014714 <memalign>
    if (!buffer) {
30004f5e:	4605      	mov	r5, r0
30004f60:	2800      	cmp	r0, #0
30004f62:	f000 8191 	beq.w	30005288 <cmd_flash_storage+0x15bc>
    memset(buffer, 0x0, sfs_size);
30004f66:	4642      	mov	r2, r8
30004f68:	2100      	movs	r1, #0
30004f6a:	f00f ed02 	blx	30014970 <memset>
    if (storage->read(storage, 0, buffer, sfs_size)) {
30004f6e:	e9cd 9a02 	strd	r9, r10, [r13, #8]
30004f72:	9500      	str	r5, [sp, #0]
30004f74:	4630      	mov	r0, r6
30004f76:	68b1      	ldr	r1, [r6, #8]
30004f78:	2200      	movs	r2, #0
30004f7a:	2300      	movs	r3, #0
30004f7c:	4788      	blx	r1
30004f7e:	2800      	cmp	r0, #0
30004f80:	f000 8117 	beq.w	300051b2 <cmd_flash_storage+0x14e6>
        ERROR("read nor flash fail\n");
30004f84:	f24a 71fc 	movw	r1, #43004	; 0xa7fc
30004f88:	f24b 2094 	movw	r0, #45716	; 0xb294
30004f8c:	f240 529c 	movw	r2, #1436	; 0x59c
30004f90:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004f94:	f2c3 0001 	movt	r0, #12289	; 0x3001
30004f98:	f010 fe0a 	bl	30015bb0 <_printf>
        free(buffer);
30004f9c:	4628      	mov	r0, r5
30004f9e:	f00f fbf5 	bl	3001478c <free>
30004fa2:	f7ff b8b5 	b.w	30004110 <cmd_flash_storage+0x444>
            snprintf(full_ptname, sizeof(full_ptname), "%s", ptname);
30004fa6:	f240 52e4 	movw	r2, #1508	; 0x5e4
30004faa:	460b      	mov	r3, r1
30004fac:	4628      	mov	r0, r5
30004fae:	f2c3 0202 	movt	r2, #12290	; 0x3002
30004fb2:	2192      	movs	r1, #146	; 0x92
30004fb4:	f010 fd8c 	bl	30015ad0 <snprintf>
30004fb8:	f7ff ba16 	b.w	300043e8 <cmd_flash_storage+0x71c>
        ret = PTB_NEED_FLASH;
30004fbc:	2300      	movs	r3, #0
        ERROR("parse gpt header error");
30004fbe:	f24a 7148 	movw	r1, #42824	; 0xa748
30004fc2:	f24b 106c 	movw	r0, #45420	; 0xb16c
30004fc6:	f2c3 0101 	movt	r1, #12289	; 0x3001
30004fca:	f240 222a 	movw	r2, #554	; 0x22a
30004fce:	f2c3 0001 	movt	r0, #12289	; 0x3001
    uint8_t  *buffer    = NULL;
30004fd2:	931c      	str	r3, [sp, #112]	; 0x70
        ret = PTB_NEED_FLASH;
30004fd4:	469b      	mov	r11, r3
        ERROR("parse gpt header error");
30004fd6:	f010 fdeb 	bl	30015bb0 <_printf>
30004fda:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
30004fde:	f7fe bfaa 	b.w	30003f36 <cmd_flash_storage+0x26a>
30004fe2:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30004fe6:	e9cd 340c 	strd	r3, r4, [r13, #48]	; 0x30
30004fea:	f7ff bb64 	b.w	300046b6 <cmd_flash_storage+0x9ea>
        index = ptdev_get_index(ptdev, sub_ptbname);
30004fee:	9916      	ldr	r1, [sp, #88]	; 0x58
30004ff0:	9818      	ldr	r0, [sp, #96]	; 0x60
30004ff2:	f012 ff29 	bl	30017e48 <ptdev_get_index>
        if (index == INVALID_PTN) {
30004ff6:	3001      	adds	r0, #1
30004ff8:	f43e af9b 	beq.w	30003f32 <cmd_flash_storage+0x266>
        offset = ptdev_get_offset(ptdev, sub_ptbname);
30004ffc:	9818      	ldr	r0, [sp, #96]	; 0x60
30004ffe:	9916      	ldr	r1, [sp, #88]	; 0x58
30005000:	f012 ff94 	bl	30017f2c <ptdev_get_offset>
30005004:	4602      	mov	r2, r0
30005006:	460b      	mov	r3, r1
30005008:	f7fe bf72 	b.w	30003ef0 <cmd_flash_storage+0x224>
        ERROR("The sfs is not correct!\n");
3000500c:	f24a 71c8 	movw	r1, #42952	; 0xa7c8
30005010:	f24b 30c0 	movw	r0, #46016	; 0xb3c0
30005014:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005018:	f240 42ec 	movw	r2, #1260	; 0x4ec
3000501c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005020:	f010 fdc6 	bl	30015bb0 <_printf>
        err = ERR_IMAGE_FORMAT_ERR;
30005024:	2006      	movs	r0, #6
30005026:	f7ff bb84 	b.w	30004732 <cmd_flash_storage+0xa66>
    ret = parse_gpt_table_from_buffer((buffer + block_size),
3000502a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
3000502c:	9b10      	ldr	r3, [sp, #64]	; 0x40
3000502e:	9000      	str	r0, [sp, #0]
30005030:	9920      	ldr	r1, [sp, #128]	; 0x80
30005032:	18d0      	adds	r0, r2, r3
30005034:	462a      	mov	r2, r5
30005036:	f000 fe19 	bl	30005c6c <parse_gpt_table_from_buffer>
    if (ret) {
3000503a:	900e      	str	r0, [sp, #56]	; 0x38
3000503c:	2800      	cmp	r0, #0
3000503e:	f47e af78 	bne.w	30003f32 <cmd_flash_storage+0x266>
    ret |= memcmp(new->sign, old->sign, sizeof(new->sign));
30005042:	4629      	mov	r1, r5
30005044:	2208      	movs	r2, #8
30005046:	4648      	mov	r0, r9
30005048:	f010 fdd4 	bl	30015bf4 <memcmp>
    ret |= memcmp(new->version, old->version, sizeof(new->version));
3000504c:	2204      	movs	r2, #4
3000504e:	a942      	add	r1, sp, #264	; 0x108
    ret |= memcmp(new->sign, old->sign, sizeof(new->sign));
30005050:	4683      	mov	r11, r0
    ret |= memcmp(new->version, old->version, sizeof(new->version));
30005052:	a828      	add	r0, sp, #160	; 0xa0
30005054:	f010 fdce 	bl	30015bf4 <memcmp>
    ret |= (new->current_lba != old->current_lba);
30005058:	e9d9 4506 	ldrd	r4, r5, [r9, #24]
    ret |= (new->header_sz != old->header_sz);
3000505c:	f8d9 100c 	ldr.w	r1, [r9, #12]
    ret |= (new->current_lba != old->current_lba);
30005060:	ab46      	add	r3, sp, #280	; 0x118
30005062:	e9d3 2300 	ldrd	r2, r3, [r3]
30005066:	429d      	cmp	r5, r3
    ret |= (new->header_sz != old->header_sz);
30005068:	9b43      	ldr	r3, [sp, #268]	; 0x10c
    ret |= (new->current_lba != old->current_lba);
3000506a:	bf0c      	ite	eq
3000506c:	4294      	cmpeq	r4, r2
3000506e:	2201      	movne	r2, #1
    ret |= (new->first_usable_lba != old->first_usable_lba);
30005070:	ac4a      	add	r4, sp, #296	; 0x128
    ret |= (new->current_lba != old->current_lba);
30005072:	bf08      	it	eq
30005074:	2200      	moveq	r2, #0
    ret |= (new->first_usable_lba != old->first_usable_lba);
30005076:	e9d4 4500 	ldrd	r4, r5, [r4]
    ret |= (new->actual_entries_count != old->actual_entries_count);
3000507a:	4299      	cmp	r1, r3
3000507c:	bf0c      	ite	eq
3000507e:	4613      	moveq	r3, r2
30005080:	f042 0301 	orrne.w	r3, r2, #1
    ret |= (new->first_usable_lba != old->first_usable_lba);
30005084:	e9d9 120a 	ldrd	r1, r2, [r9, #40]	; 0x28
30005088:	42aa      	cmp	r2, r5
3000508a:	bf08      	it	eq
3000508c:	42a1      	cmpeq	r1, r4
    ret |= (new->partition_entry_lba != old->partition_entry_lba);
3000508e:	e9d9 1212 	ldrd	r1, r2, [r9, #72]	; 0x48
30005092:	ac52      	add	r4, sp, #328	; 0x148
    ret |= (new->actual_entries_count != old->actual_entries_count);
30005094:	bf18      	it	ne
30005096:	2301      	movne	r3, #1
    ret |= (new->partition_entry_lba != old->partition_entry_lba);
30005098:	e9d4 4500 	ldrd	r4, r5, [r4]
3000509c:	42aa      	cmp	r2, r5
    ret |= (new->partition_entry_count != old->partition_entry_count);
3000509e:	f8d9 2050 	ldr.w	r2, [r9, #80]	; 0x50
    ret |= (new->partition_entry_lba != old->partition_entry_lba);
300050a2:	bf08      	it	eq
300050a4:	42a1      	cmpeq	r1, r4
    ret |= (new->partition_entry_count != old->partition_entry_count);
300050a6:	9954      	ldr	r1, [sp, #336]	; 0x150
    ret |= (new->actual_entries_count != old->actual_entries_count);
300050a8:	bf18      	it	ne
300050aa:	2301      	movne	r3, #1
    ret |= (new->partition_entry_sz != old->partition_entry_sz);
300050ac:	9d55      	ldr	r5, [sp, #340]	; 0x154
    ret |= (new->actual_entries_count != old->actual_entries_count);
300050ae:	f8d9 4054 	ldr.w	r4, [r9, #84]	; 0x54
300050b2:	428a      	cmp	r2, r1
300050b4:	bf0c      	ite	eq
300050b6:	461a      	moveq	r2, r3
300050b8:	f043 0201 	orrne.w	r2, r3, #1
300050bc:	f8d9 1060 	ldr.w	r1, [r9, #96]	; 0x60
300050c0:	9b58      	ldr	r3, [sp, #352]	; 0x160
300050c2:	42ac      	cmp	r4, r5
300050c4:	bf18      	it	ne
300050c6:	f042 0201 	orrne.w	r2, r2, #1
300050ca:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
300050ce:	428b      	cmp	r3, r1
300050d0:	bf0c      	ite	eq
300050d2:	4613      	moveq	r3, r2
300050d4:	f042 0301 	orrne.w	r3, r2, #1
300050d8:	465a      	mov	r2, r11
300050da:	4302      	orrs	r2, r0
    if (ret) {
300050dc:	4313      	orrs	r3, r2
300050de:	d147      	bne.n	30005170 <cmd_flash_storage+0x14a4>
    ret |= compare_gpt_entries(new->partition_entries, old->partition_entries,
300050e0:	9b57      	ldr	r3, [sp, #348]	; 0x15c
    for (uint32_t i = 0; i < count; i++) {
300050e2:	2900      	cmp	r1, #0
300050e4:	f000 82fd 	beq.w	300056e2 <cmd_flash_storage+0x1a16>
300050e8:	3338      	adds	r3, #56	; 0x38
300050ea:	9510      	str	r5, [sp, #64]	; 0x40
300050ec:	f105 0938 	add.w	r9, r5, #56	; 0x38
300050f0:	9612      	str	r6, [sp, #72]	; 0x48
300050f2:	1e4c      	subs	r4, r1, #1
300050f4:	f8cd a058 	str.w	r10, [r13, #88]	; 0x58
300050f8:	460d      	mov	r5, r1
300050fa:	46c2      	mov	r10, r8
300050fc:	461e      	mov	r6, r3
300050fe:	46b8      	mov	r8, r7
30005100:	9f0e      	ldr	r7, [sp, #56]	; 0x38
30005102:	e002      	b.n	3000510a <cmd_flash_storage+0x143e>
30005104:	42bd      	cmp	r5, r7
30005106:	f000 81d2 	beq.w	300054ae <cmd_flash_storage+0x17e2>
        ret |= strncmp((char *)new[i].name, (char *)(old[i].name),
3000510a:	4631      	mov	r1, r6
3000510c:	2248      	movs	r2, #72	; 0x48
3000510e:	4648      	mov	r0, r9
30005110:	f010 fe28 	bl	30015d64 <strncmp>
        ret |= (new[i].first_lba != old[i].first_lba);
30005114:	e956 2306 	ldrd	r2, r3, [r6, #-24]
30005118:	e959 bc06 	ldrd	r11, r12, [r9, #-24]
3000511c:	459c      	cmp	r12, r3
3000511e:	bf08      	it	eq
30005120:	4593      	cmpeq	r11, r2
        ret |= (new[i].attribute_flag != old[i].attribute_flag);
30005122:	e956 2302 	ldrd	r2, r3, [r6, #-8]
        ret |= (new[i].first_lba != old[i].first_lba);
30005126:	bf18      	it	ne
30005128:	2101      	movne	r1, #1
        ret |= (new[i].attribute_flag != old[i].attribute_flag);
3000512a:	e959 bc02 	ldrd	r11, r12, [r9, #-8]
        ret |= (new[i].first_lba != old[i].first_lba);
3000512e:	bf08      	it	eq
30005130:	2100      	moveq	r1, #0
        ret |= (new[i].attribute_flag != old[i].attribute_flag);
30005132:	459c      	cmp	r12, r3
30005134:	bf0c      	ite	eq
30005136:	4593      	cmpeq	r11, r2
30005138:	2101      	movne	r1, #1
        if (i != count - 1) {
3000513a:	42a7      	cmp	r7, r4
    for (uint32_t i = 0; i < count; i++) {
3000513c:	f107 0701 	add.w	r7, r7, #1
        ret |= (new[i].attribute_flag != old[i].attribute_flag);
30005140:	ea40 0001 	orr.w	r0, r0, r1
        if (i != count - 1) {
30005144:	d009      	beq.n	3000515a <cmd_flash_storage+0x148e>
            ret |= (new[i].last_lba != old[i].last_lba);
30005146:	e956 2304 	ldrd	r2, r3, [r6, #-16]
3000514a:	e959 bc04 	ldrd	r11, r12, [r9, #-16]
3000514e:	459c      	cmp	r12, r3
30005150:	bf08      	it	eq
30005152:	4593      	cmpeq	r11, r2
30005154:	bf18      	it	ne
30005156:	f040 0001 	orrne.w	r0, r0, #1
3000515a:	f109 0990 	add.w	r9, r9, #144	; 0x90
3000515e:	3690      	adds	r6, #144	; 0x90
        if (ret)
30005160:	2800      	cmp	r0, #0
30005162:	d0cf      	beq.n	30005104 <cmd_flash_storage+0x1438>
30005164:	9d10      	ldr	r5, [sp, #64]	; 0x40
30005166:	4647      	mov	r7, r8
30005168:	9e12      	ldr	r6, [sp, #72]	; 0x48
3000516a:	46d0      	mov	r8, r10
3000516c:	f8dd a058 	ldr.w	r10, [r13, #88]	; 0x58
        ret = PTB_CHECK_ERROR;
30005170:	2302      	movs	r3, #2
30005172:	469b      	mov	r11, r3
30005174:	f7fe bedf 	b.w	30003f36 <cmd_flash_storage+0x26a>
30005178:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
3000517c:	469a      	mov	r10, r3
3000517e:	46a3      	mov	r11, r4
30005180:	f7ff b8cb 	b.w	3000431a <cmd_flash_storage+0x64e>
30005184:	e9dd 341e 	ldrd	r3, r4, [r13, #120]	; 0x78
30005188:	e9cd 341c 	strd	r3, r4, [r13, #112]	; 0x70
3000518c:	f7fe be9f 	b.w	30003ece <cmd_flash_storage+0x202>
            if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30005190:	6859      	ldr	r1, [r3, #4]
30005192:	9a27      	ldr	r2, [sp, #156]	; 0x9c
30005194:	4291      	cmp	r1, r2
30005196:	f47f a8dd 	bne.w	30004354 <cmd_flash_storage+0x688>
3000519a:	6899      	ldr	r1, [r3, #8]
3000519c:	9a28      	ldr	r2, [sp, #160]	; 0xa0
3000519e:	4291      	cmp	r1, r2
300051a0:	f47f a8d8 	bne.w	30004354 <cmd_flash_storage+0x688>
300051a4:	68da      	ldr	r2, [r3, #12]
300051a6:	9b29      	ldr	r3, [sp, #164]	; 0xa4
300051a8:	429a      	cmp	r2, r3
300051aa:	f47f a8d3 	bne.w	30004354 <cmd_flash_storage+0x688>
300051ae:	f7fe bdb3 	b.w	30003d18 <cmd_flash_storage+0x4c>
    need_update = patch_sfs(ptdev, buffer, sfs_size);
300051b2:	4642      	mov	r2, r8
300051b4:	4658      	mov	r0, r11
300051b6:	4629      	mov	r1, r5
300051b8:	f7fc ff1c 	bl	30001ff4 <patch_sfs>
    if (!need_update)
300051bc:	2800      	cmp	r0, #0
300051be:	d03b      	beq.n	30005238 <cmd_flash_storage+0x156c>
    if (storage->erase(storage, 0,
300051c0:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
300051c4:	2100      	movs	r1, #0
300051c6:	4610      	mov	r0, r2
    if (aligned == 0 || size < aligned)
300051c8:	458a      	cmp	r10, r1
300051ca:	6934      	ldr	r4, [r6, #16]
300051cc:	bf08      	it	eq
300051ce:	4591      	cmpeq	r9, r2
300051d0:	bf34      	ite	cc
300051d2:	2301      	movcc	r3, #1
300051d4:	2300      	movcs	r3, #0
300051d6:	e9cd 0106 	strd	r0, r1, [r13, #24]
300051da:	2a00      	cmp	r2, #0
300051dc:	bf08      	it	eq
300051de:	2301      	moveq	r3, #1
300051e0:	b9a3      	cbnz	r3, 3000520c <cmd_flash_storage+0x1540>
    mod = size % aligned;
300051e2:	460b      	mov	r3, r1
300051e4:	4648      	mov	r0, r9
300051e6:	4651      	mov	r1, r10
300051e8:	f014 fe1a 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300051ec:	ea52 0103 	orrs.w	r1, r2, r3
300051f0:	d006      	beq.n	30005200 <cmd_flash_storage+0x1534>
300051f2:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
300051f6:	1a80      	subs	r0, r0, r2
300051f8:	4602      	mov	r2, r0
300051fa:	eb61 0103 	sbc.w	r1, r1, r3
300051fe:	460b      	mov	r3, r1
30005200:	eb19 0002 	adds.w	r0, r9, r2
30005204:	eb4a 0103 	adc.w	r1, r10, r3
30005208:	e9cd 0106 	strd	r0, r1, [r13, #24]
3000520c:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
30005210:	4630      	mov	r0, r6
30005212:	e9cd 2300 	strd	r2, r3, [r13]
30005216:	2200      	movs	r2, #0
30005218:	2300      	movs	r3, #0
3000521a:	47a0      	blx	r4
3000521c:	2800      	cmp	r0, #0
3000521e:	f040 823e 	bne.w	3000569e <cmd_flash_storage+0x19d2>
    if (storage->write(storage, 0, buffer, sfs_size)) {
30005222:	e9cd 9a02 	strd	r9, r10, [r13, #8]
30005226:	4630      	mov	r0, r6
30005228:	9500      	str	r5, [sp, #0]
3000522a:	2200      	movs	r2, #0
3000522c:	68f1      	ldr	r1, [r6, #12]
3000522e:	2300      	movs	r3, #0
30005230:	4788      	blx	r1
30005232:	2800      	cmp	r0, #0
30005234:	f040 8165 	bne.w	30005502 <cmd_flash_storage+0x1836>
        free(buffer);
30005238:	4628      	mov	r0, r5
3000523a:	f00f faa7 	bl	3001478c <free>
3000523e:	f7fe bd6e 	b.w	30003d1e <cmd_flash_storage+0x52>
        ERROR("mem allocate buffer error");
30005242:	f24a 7148 	movw	r1, #42824	; 0xa748
30005246:	f24b 1090 	movw	r0, #45456	; 0xb190
3000524a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000524e:	f240 2237 	movw	r2, #567	; 0x237
30005252:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005256:	f010 fcab 	bl	30015bb0 <_printf>
3000525a:	f8d9 505c 	ldr.w	r5, [r9, #92]	; 0x5c
3000525e:	f7fe be6a 	b.w	30003f36 <cmd_flash_storage+0x26a>
        ERROR("image too large :%llu\n", size);
30005262:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30005266:	f24a 7194 	movw	r1, #42900	; 0xa794
3000526a:	f64a 5058 	movw	r0, #44376	; 0xad58
3000526e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005272:	e9cd 3400 	strd	r3, r4, [r13]
30005276:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000527a:	f240 322a 	movw	r2, #810	; 0x32a
3000527e:	f010 fc97 	bl	30015bb0 <_printf>
        err = ERR_IMAGE_TOO_LARGE;
30005282:	2005      	movs	r0, #5
30005284:	f7fe bf85 	b.w	30004192 <cmd_flash_storage+0x4c6>
        ERROR("allocate memory fail\n");
30005288:	f24a 71fc 	movw	r1, #43004	; 0xa7fc
3000528c:	f24b 2070 	movw	r0, #45680	; 0xb270
30005290:	f240 5295 	movw	r2, #1429	; 0x595
30005294:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005298:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000529c:	f010 fc88 	bl	30015bb0 <_printf>
300052a0:	f7fe bf36 	b.w	30004110 <cmd_flash_storage+0x444>
300052a4:	f04f 0880 	mov.w	r8, #128	; 0x80
300052a8:	f04f 0980 	mov.w	r9, #128	; 0x80
300052ac:	f04f 0a00 	mov.w	r10, #0
300052b0:	e64e      	b.n	30004f50 <cmd_flash_storage+0x1284>
    if (storage->get_storage_id &&
300052b2:	9808      	ldr	r0, [sp, #32]
300052b4:	6a83      	ldr	r3, [r0, #40]	; 0x28
300052b6:	b15b      	cbz	r3, 300052d0 <cmd_flash_storage+0x1604>
            storage->get_storage_id(storage, (uint8_t *)&flash_id, sizeof(flash_id))) {
300052b8:	2208      	movs	r2, #8
300052ba:	a924      	add	r1, sp, #144	; 0x90
300052bc:	4798      	blx	r3
    if (storage->get_storage_id &&
300052be:	b128      	cbz	r0, 300052cc <cmd_flash_storage+0x1600>
        dprintf(CRITICAL, "Fail to get storage id!\n");
300052c0:	f24b 3040 	movw	r0, #45888	; 0xb340
300052c4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300052c8:	f010 fc72 	bl	30015bb0 <_printf>
300052cc:	f8d8 2008 	ldr.w	r2, [r8, #8]
    seq_info = (flash_seq_info_t *)((uint8_t *)msfs + msfs->offset);
300052d0:	f8d8 300c 	ldr.w	r3, [r8, #12]
300052d4:	e9dd 0124 	ldrd	r0, r1, [r13, #144]	; 0x90
300052d8:	e9cd 010e 	strd	r0, r1, [r13, #56]	; 0x38
300052dc:	4443      	add	r3, r8
    for (i =  0; i < msfs->count; i++, seq_info++) {
300052de:	2a00      	cmp	r2, #0
300052e0:	d03c      	beq.n	3000535c <cmd_flash_storage+0x1690>
        if (!((flash_id ^ seq_info->flash_id) & flash_id_mask)) {
300052e2:	68d9      	ldr	r1, [r3, #12]
300052e4:	910c      	str	r1, [sp, #48]	; 0x30
300052e6:	6919      	ldr	r1, [r3, #16]
300052e8:	910d      	str	r1, [sp, #52]	; 0x34
300052ea:	e9dd bc0e 	ldrd	r11, r12, [r13, #56]	; 0x38
300052ee:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
300052f2:	ea80 000b 	eor.w	r0, r0, r11
300052f6:	f64f 7bff 	movw	r11, #65535	; 0xffff
300052fa:	ea81 010c 	eor.w	r1, r1, r12
300052fe:	f04f 0c00 	mov.w	r12, #0
30005302:	ea0b 0b00 	and.w	r11, r11, r0
30005306:	4658      	mov	r0, r11
30005308:	ea0c 0c01 	and.w	r12, r12, r1
3000530c:	4661      	mov	r1, r12
3000530e:	4301      	orrs	r1, r0
30005310:	f000 81bb 	beq.w	3000568a <cmd_flash_storage+0x19be>
30005314:	f64f 70ff 	movw	r0, #65535	; 0xffff
30005318:	2100      	movs	r1, #0
3000531a:	46c6      	mov	r14, r8
    for (i =  0; i < msfs->count; i++, seq_info++) {
3000531c:	2600      	movs	r6, #0
3000531e:	f8cd 9048 	str.w	r9, [r13, #72]	; 0x48
30005322:	46ac      	mov	r12, r5
        if (!((flash_id ^ seq_info->flash_id) & flash_id_mask)) {
30005324:	e9cd 0106 	strd	r0, r1, [r13, #24]
30005328:	f8cd a040 	str.w	r10, [r13, #64]	; 0x40
3000532c:	e9dd 890e 	ldrd	r8, r9, [r13, #56]	; 0x38
30005330:	e00f      	b.n	30005352 <cmd_flash_storage+0x1686>
30005332:	68d8      	ldr	r0, [r3, #12]
30005334:	6919      	ldr	r1, [r3, #16]
30005336:	e9dd ab06 	ldrd	r10, r11, [r13, #24]
3000533a:	ea80 0408 	eor.w	r4, r0, r8
3000533e:	ea81 0509 	eor.w	r5, r1, r9
30005342:	ea0a 0a04 	and.w	r10, r10, r4
30005346:	4654      	mov	r4, r10
30005348:	ea0b 0b05 	and.w	r11, r11, r5
3000534c:	465d      	mov	r5, r11
3000534e:	432c      	orrs	r4, r5
30005350:	d072      	beq.n	30005438 <cmd_flash_storage+0x176c>
    for (i =  0; i < msfs->count; i++, seq_info++) {
30005352:	3601      	adds	r6, #1
30005354:	4296      	cmp	r6, r2
30005356:	f103 0320 	add.w	r3, r3, #32
3000535a:	d1ea      	bne.n	30005332 <cmd_flash_storage+0x1666>
        dprintf(CRITICAL, "No matched sfs, flash_id:0x%0llx!\n", flash_id);
3000535c:	e9dd 2324 	ldrd	r2, r3, [r13, #144]	; 0x90
30005360:	f24b 305c 	movw	r0, #45916	; 0xb35c
30005364:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005368:	f010 fc22 	bl	30015bb0 <_printf>
        err = ERR_IMAGE_FORMAT_ERR;
3000536c:	2006      	movs	r0, #6
3000536e:	f7ff b9e0 	b.w	30004732 <cmd_flash_storage+0xa66>
        ERROR(" write data error!\n");
30005372:	f24a 71d8 	movw	r1, #42968	; 0xa7d8
30005376:	f24b 0004 	movw	r0, #45060	; 0xb004
3000537a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000537e:	f240 521c 	movw	r2, #1308	; 0x51c
30005382:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005386:	f010 fc13 	bl	30015bb0 <_printf>
        err = ERR_PT_FLASH_FAIL;
3000538a:	2009      	movs	r0, #9
3000538c:	f7ff b9d1 	b.w	30004732 <cmd_flash_storage+0xa66>
        md5(data, sz, md5_received);
30005390:	f646 42f8 	movw	r2, #27896	; 0x6cf8
30005394:	4640      	mov	r0, r8
30005396:	9906      	ldr	r1, [sp, #24]
30005398:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000539c:	f011 f8f4 	bl	30016588 <md5>
300053a0:	e450      	b.n	30004c44 <cmd_flash_storage+0xf78>
        ERROR("data end:%lu  header size:%u\n", data_end, sizeof(sparse_header_t));
300053a2:	221c      	movs	r2, #28
300053a4:	f24a 7194 	movw	r1, #42900	; 0xa794
300053a8:	f64a 507c 	movw	r0, #44412	; 0xad7c
300053ac:	f2c3 0101 	movt	r1, #12289	; 0x3001
300053b0:	9200      	str	r2, [sp, #0]
300053b2:	f2c3 0001 	movt	r0, #12289	; 0x3001
300053b6:	f240 3232 	movw	r2, #818	; 0x332
300053ba:	f010 fbf9 	bl	30015bb0 <_printf>
        err = ERR_SPARSE_IMAGE_BUFFERED;
300053be:	2010      	movs	r0, #16
300053c0:	f7fe bee7 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    if (pos == ptn && st_info->type == OSPI) {
300053c4:	9b16      	ldr	r3, [sp, #88]	; 0x58
300053c6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
300053c8:	2b01      	cmp	r3, #1
300053ca:	f47f ab76 	bne.w	30004aba <cmd_flash_storage+0xdee>
                                                       sparse_header->blk_sz * sparse_header->total_blks)) {
300053ce:	9b10      	ldr	r3, [sp, #64]	; 0x40
                        if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
300053d0:	2100      	movs	r1, #0
300053d2:	9a06      	ldr	r2, [sp, #24]
300053d4:	9821      	ldr	r0, [sp, #132]	; 0x84
                                                       sparse_header->blk_sz * sparse_header->total_blks)) {
300053d6:	691b      	ldr	r3, [r3, #16]
                        if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
300053d8:	9101      	str	r1, [sp, #4]
300053da:	991e      	ldr	r1, [sp, #120]	; 0x78
                                                       sparse_header->blk_sz * sparse_header->total_blks)) {
300053dc:	fb03 f30c 	mul.w	r3, r3, r12
                        if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
300053e0:	9300      	str	r3, [sp, #0]
300053e2:	f7fc fd49 	bl	30001e78 <erase_nor_flash_partition>
300053e6:	2800      	cmp	r0, #0
300053e8:	f47f ab67 	bne.w	30004aba <cmd_flash_storage+0xdee>
                            ERROR("erase partition fail!\n");
300053ec:	f24a 7194 	movw	r1, #42900	; 0xa794
300053f0:	f64a 60e0 	movw	r0, #44768	; 0xaee0
300053f4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300053f8:	f240 420a 	movw	r2, #1034	; 0x40a
300053fc:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005400:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005402:	9d06      	ldr	r5, [sp, #24]
30005404:	f010 fbd4 	bl	30015bb0 <_printf>
                            err = ERR_PT_ERASE_FAIL;
30005408:	200a      	movs	r0, #10
3000540a:	f7fe bec2 	b.w	30004192 <cmd_flash_storage+0x4c6>
        ERROR("image header error!\n");
3000540e:	f24a 7194 	movw	r1, #42900	; 0xa794
30005412:	f64a 50cc 	movw	r0, #44492	; 0xadcc
30005416:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000541a:	f44f 724e 	mov.w	r2, #824	; 0x338
3000541e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005422:	f010 fbc5 	bl	30015bb0 <_printf>
        err = ERR_SPARSE_IMAGE_HEADER;
30005426:	200f      	movs	r0, #15
30005428:	f7fe beb3 	b.w	30004192 <cmd_flash_storage+0x4c6>
3000542c:	e9cd 560a 	strd	r5, r6, [r13, #40]	; 0x28
30005430:	e45e      	b.n	30004cf0 <cmd_flash_storage+0x1024>
30005432:	e9cd 560a 	strd	r5, r6, [r13, #40]	; 0x28
30005436:	e42c      	b.n	30004c92 <cmd_flash_storage+0xfc6>
30005438:	f8dd a040 	ldr.w	r10, [r13, #64]	; 0x40
3000543c:	46f0      	mov	r8, r14
3000543e:	f8dd 9048 	ldr.w	r9, [r13, #72]	; 0x48
30005442:	4665      	mov	r5, r12
30005444:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
            *data = (uint8_t *)msfs + seq_info->offset;
30005448:	685c      	ldr	r4, [r3, #4]
            dprintf(CRITICAL, "%s %d matched, flash_id:0x%0llx seq id:0x%0llx mask:0x%0llx!\n",
3000544a:	f64f 72ff 	movw	r2, #65535	; 0xffff
            *sz = seq_info->size;
3000544e:	689b      	ldr	r3, [r3, #8]
            dprintf(CRITICAL, "%s %d matched, flash_id:0x%0llx seq id:0x%0llx mask:0x%0llx!\n",
30005450:	f24a 71c8 	movw	r1, #42952	; 0xa7c8
            *sz = seq_info->size;
30005454:	9306      	str	r3, [sp, #24]
            dprintf(CRITICAL, "%s %d matched, flash_id:0x%0llx seq id:0x%0llx mask:0x%0llx!\n",
30005456:	2300      	movs	r3, #0
30005458:	f24b 3080 	movw	r0, #45952	; 0xb380
3000545c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005460:	e9cd 2304 	strd	r2, r3, [r13, #16]
30005464:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005468:	e9dd 230c 	ldrd	r2, r3, [r13, #48]	; 0x30
            *data = (uint8_t *)msfs + seq_info->offset;
3000546c:	4444      	add	r4, r8
            dprintf(CRITICAL, "%s %d matched, flash_id:0x%0llx seq id:0x%0llx mask:0x%0llx!\n",
3000546e:	e9cd 2302 	strd	r2, r3, [r13, #8]
30005472:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
30005476:	e9cd 2300 	strd	r2, r3, [r13]
3000547a:	f240 42df 	movw	r2, #1247	; 0x4df
3000547e:	f010 fb97 	bl	30015bb0 <_printf>
    if (i == msfs->count) {
30005482:	f8d8 3008 	ldr.w	r3, [r8, #8]
30005486:	429e      	cmp	r6, r3
30005488:	f43f af68 	beq.w	3000535c <cmd_flash_storage+0x1690>
            *data = (uint8_t *)msfs + seq_info->offset;
3000548c:	46a0      	mov	r8, r4
3000548e:	f7ff bbc9 	b.w	30004c24 <cmd_flash_storage+0xf58>
                                && i < (count_aligned / sizeof(fill_val)); i++) {
30005492:	ea4f 0098 	mov.w	r0, r8, lsr #2
30005496:	ea40 7089 	orr.w	r0, r0, r9, lsl #30
3000549a:	4645      	mov	r5, r8
3000549c:	ea4f 0199 	mov.w	r1, r9, lsr #2
300054a0:	464c      	mov	r4, r9
300054a2:	ea50 0301 	orrs.w	r3, r0, r1
300054a6:	f47f aacc 	bne.w	30004a42 <cmd_flash_storage+0xd76>
300054aa:	f7ff bad7 	b.w	30004a5c <cmd_flash_storage+0xd90>
        ret = PTB_NO_NEED_FLASH;
300054ae:	2301      	movs	r3, #1
300054b0:	4647      	mov	r7, r8
300054b2:	9d10      	ldr	r5, [sp, #64]	; 0x40
300054b4:	46d0      	mov	r8, r10
300054b6:	9e12      	ldr	r6, [sp, #72]	; 0x48
300054b8:	469b      	mov	r11, r3
300054ba:	f8dd a058 	ldr.w	r10, [r13, #88]	; 0x58
300054be:	f7fe bd3a 	b.w	30003f36 <cmd_flash_storage+0x26a>
            ERROR("read back error!\n");
300054c2:	f24a 71d8 	movw	r1, #42968	; 0xa7d8
300054c6:	f24b 70d8 	movw	r0, #47064	; 0xb7d8
300054ca:	f240 5227 	movw	r2, #1319	; 0x527
300054ce:	f2c3 0101 	movt	r1, #12289	; 0x3001
            return 1;
300054d2:	2401      	movs	r4, #1
            ERROR("read back error!\n");
300054d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300054d8:	f010 fb6a 	bl	30015bb0 <_printf>
300054dc:	f7fe bf56 	b.w	3000438c <cmd_flash_storage+0x6c0>
                ERROR("Unkown chunk type: %x\n", chunk_header->chunk_type);
300054e0:	f24a 7194 	movw	r1, #42900	; 0xa794
300054e4:	f24b 0080 	movw	r0, #45184	; 0xb080
300054e8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300054ec:	f240 4247 	movw	r2, #1095	; 0x447
300054f0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300054f4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300054f6:	9d06      	ldr	r5, [sp, #24]
300054f8:	f010 fb5a 	bl	30015bb0 <_printf>
                err = ERR_SPARSE_IMAGE_CHUNK_UNKNOWN;
300054fc:	2014      	movs	r0, #20
300054fe:	f7fe be48 	b.w	30004192 <cmd_flash_storage+0x4c6>
        ERROR("write sfs fail\n");
30005502:	f24a 71fc 	movw	r1, #43004	; 0xa7fc
30005506:	f24b 20d8 	movw	r0, #45784	; 0xb2d8
3000550a:	f240 52ae 	movw	r2, #1454	; 0x5ae
3000550e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005512:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005516:	f010 fb4b 	bl	30015bb0 <_printf>
        free(buffer);
3000551a:	4628      	mov	r0, r5
3000551c:	f00f f936 	bl	3001478c <free>
30005520:	f7fe bdf6 	b.w	30004110 <cmd_flash_storage+0x444>
        return aligned;
30005524:	2220      	movs	r2, #32
30005526:	f7ff ba66 	b.w	300049f6 <cmd_flash_storage+0xd2a>
                    while (chunk_data_sz_remain) {
3000552a:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
3000552e:	ea53 0204 	orrs.w	r2, r3, r4
30005532:	f43f aa37 	beq.w	300049a4 <cmd_flash_storage+0xcd8>
30005536:	e9cd 3418 	strd	r3, r4, [r13, #96]	; 0x60
3000553a:	46c8      	mov	r8, r9
                        memset(block_wrapper, 0x0, SPARSE_DATA_ALIGNED_SIZE);
3000553c:	f8cd b088 	str.w	r11, [r13, #136]	; 0x88
30005540:	e004      	b.n	3000554c <cmd_flash_storage+0x1880>
                    while (chunk_data_sz_remain) {
30005542:	e9dd 3418 	ldrd	r3, r4, [r13, #96]	; 0x60
30005546:	4323      	orrs	r3, r4
30005548:	f000 8119 	beq.w	3000577e <cmd_flash_storage+0x1ab2>
                        count_aligned = MIN(SPARSE_DATA_ALIGNED_SIZE, chunk_data_sz_remain);
3000554c:	e9dd 6718 	ldrd	r6, r7, [r13, #96]	; 0x60
30005550:	f04f 0c00 	mov.w	r12, #0
30005554:	f44f 0b00 	mov.w	r11, #8388608	; 0x800000
30005558:	4634      	mov	r4, r6
                        memset(block_wrapper, 0x0, SPARSE_DATA_ALIGNED_SIZE);
3000555a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
                        count_aligned = MIN(SPARSE_DATA_ALIGNED_SIZE, chunk_data_sz_remain);
3000555e:	45bc      	cmp	r12, r7
                        memset(block_wrapper, 0x0, SPARSE_DATA_ALIGNED_SIZE);
30005560:	f04f 0100 	mov.w	r1, #0
                        count_aligned = MIN(SPARSE_DATA_ALIGNED_SIZE, chunk_data_sz_remain);
30005564:	bf08      	it	eq
30005566:	45b3      	cmpeq	r11, r6
30005568:	bf38      	it	cc
3000556a:	465c      	movcc	r4, r11
                        memset(block_wrapper, 0x0, SPARSE_DATA_ALIGNED_SIZE);
3000556c:	f04f 504a 	mov.w	r0, #847249408	; 0x32800000
                        count_aligned = MIN(SPARSE_DATA_ALIGNED_SIZE, chunk_data_sz_remain);
30005570:	463d      	mov	r5, r7
30005572:	bf38      	it	cc
30005574:	4665      	movcc	r5, r12
                        memset(block_wrapper, 0x0, SPARSE_DATA_ALIGNED_SIZE);
30005576:	f00f e9fc 	blx	30014970 <memset>
                        memcpy(block_wrapper, data_ptr_temp, count_aligned);
3000557a:	4641      	mov	r1, r8
3000557c:	4622      	mov	r2, r4
3000557e:	f04f 504a 	mov.w	r0, #847249408	; 0x32800000
30005582:	f00f e970 	blx	30014864 <memcpy>
                        if (storage->write(storage, pos, block_wrapper,
30005586:	9b16      	ldr	r3, [sp, #88]	; 0x58
30005588:	2700      	movs	r7, #0
    mod = size % aligned;
3000558a:	4620      	mov	r0, r4
3000558c:	4629      	mov	r1, r5
    if (aligned == 0 || size < aligned)
3000558e:	42bd      	cmp	r5, r7
30005590:	f8d3 e070 	ldr.w	r14, [r3, #112]	; 0x70
                        data_ptr_temp = (uint8_t *)data_ptr_temp + count_aligned;
30005594:	44a0      	add	r8, r4
                        if (storage->write(storage, pos, block_wrapper,
30005596:	4676      	mov	r6, r14
    mod = size % aligned;
30005598:	4672      	mov	r2, r14
3000559a:	463b      	mov	r3, r7
    if (aligned == 0 || size < aligned)
3000559c:	bf08      	it	eq
3000559e:	4574      	cmpeq	r4, r14
    mod = size % aligned;
300055a0:	e9cd 671a 	strd	r6, r7, [r13, #104]	; 0x68
    if (aligned == 0 || size < aligned)
300055a4:	bf38      	it	cc
300055a6:	f04f 0c01 	movcc.w	r12, #1
300055aa:	9e15      	ldr	r6, [sp, #84]	; 0x54
300055ac:	bf28      	it	cs
300055ae:	f04f 0c00 	movcs.w	r12, #0
300055b2:	68f6      	ldr	r6, [r6, #12]
300055b4:	46b3      	mov	r11, r6
300055b6:	f1be 0f00 	cmp.w	r14, #0
300055ba:	bf08      	it	eq
300055bc:	f04f 0c01 	moveq.w	r12, #1
300055c0:	f1bc 0f00 	cmp.w	r12, #0
300055c4:	d110      	bne.n	300055e8 <cmd_flash_storage+0x191c>
    mod = size % aligned;
300055c6:	f014 fc2b 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300055ca:	ea52 0103 	orrs.w	r1, r2, r3
300055ce:	d006      	beq.n	300055de <cmd_flash_storage+0x1912>
300055d0:	e9dd 671a 	ldrd	r6, r7, [r13, #104]	; 0x68
300055d4:	1ab6      	subs	r6, r6, r2
300055d6:	4632      	mov	r2, r6
300055d8:	eb67 0703 	sbc.w	r7, r7, r3
300055dc:	463b      	mov	r3, r7
300055de:	18a0      	adds	r0, r4, r2
300055e0:	eb45 0103 	adc.w	r1, r5, r3
300055e4:	e9cd 011a 	strd	r0, r1, [r13, #104]	; 0x68
300055e8:	e9dd 671c 	ldrd	r6, r7, [r13, #112]	; 0x70
300055ec:	f04f 534a 	mov.w	r3, #847249408	; 0x32800000
300055f0:	9815      	ldr	r0, [sp, #84]	; 0x54
300055f2:	9300      	str	r3, [sp, #0]
300055f4:	e9dd 231a 	ldrd	r2, r3, [r13, #104]	; 0x68
300055f8:	e9cd 2302 	strd	r2, r3, [r13, #8]
300055fc:	4632      	mov	r2, r6
300055fe:	463b      	mov	r3, r7
30005600:	47d8      	blx	r11
                        chunk_data_sz_remain -= count_aligned;
30005602:	e9dd 1218 	ldrd	r1, r2, [r13, #96]	; 0x60
30005606:	1b09      	subs	r1, r1, r4
30005608:	eb62 0205 	sbc.w	r2, r2, r5
3000560c:	e9cd 1218 	strd	r1, r2, [r13, #96]	; 0x60
                        pos += count_aligned;
30005610:	1932      	adds	r2, r6, r4
30005612:	eb47 0305 	adc.w	r3, r7, r5
30005616:	e9cd 231c 	strd	r2, r3, [r13, #112]	; 0x70
                        if (storage->write(storage, pos, block_wrapper,
3000561a:	2800      	cmp	r0, #0
3000561c:	d091      	beq.n	30005542 <cmd_flash_storage+0x1876>
                            ERROR("flash storage error\n");
3000561e:	f24a 7194 	movw	r1, #42900	; 0xa794
30005622:	f64b 00b0 	movw	r0, #47280	; 0xb8b0
30005626:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000562a:	f44f 7268 	mov.w	r2, #928	; 0x3a0
3000562e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005632:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005634:	9d06      	ldr	r5, [sp, #24]
30005636:	f010 fabb 	bl	30015bb0 <_printf>
                            err = ERR_PT_FLASH_FAIL;
3000563a:	2009      	movs	r0, #9
3000563c:	f7fe bda9 	b.w	30004192 <cmd_flash_storage+0x4c6>
                if (pos == ptn && st_info->type == OSPI) {
30005640:	9b16      	ldr	r3, [sp, #88]	; 0x58
30005642:	6e1b      	ldr	r3, [r3, #96]	; 0x60
30005644:	2b01      	cmp	r3, #1
30005646:	f47f a982 	bne.w	3000494e <cmd_flash_storage+0xc82>
                                                   sparse_header->blk_sz * sparse_header->total_blks)) {
3000564a:	9b10      	ldr	r3, [sp, #64]	; 0x40
                    if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
3000564c:	2100      	movs	r1, #0
3000564e:	9a06      	ldr	r2, [sp, #24]
30005650:	9821      	ldr	r0, [sp, #132]	; 0x84
                                                   sparse_header->blk_sz * sparse_header->total_blks)) {
30005652:	691b      	ldr	r3, [r3, #16]
                    if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
30005654:	9101      	str	r1, [sp, #4]
30005656:	991e      	ldr	r1, [sp, #120]	; 0x78
                                                   sparse_header->blk_sz * sparse_header->total_blks)) {
30005658:	fb03 f30c 	mul.w	r3, r3, r12
                    if (!erase_nor_flash_partition(ptdev, st_info, full_ptname,
3000565c:	9300      	str	r3, [sp, #0]
3000565e:	f7fc fc0b 	bl	30001e78 <erase_nor_flash_partition>
30005662:	2800      	cmp	r0, #0
30005664:	f47f a973 	bne.w	3000494e <cmd_flash_storage+0xc82>
                        ERROR("erase partition fail!\n");
30005668:	f24a 7194 	movw	r1, #42900	; 0xa794
3000566c:	f64a 60e0 	movw	r0, #44768	; 0xaee0
30005670:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005674:	f240 3292 	movw	r2, #914	; 0x392
30005678:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000567c:	9f0c      	ldr	r7, [sp, #48]	; 0x30
3000567e:	9d06      	ldr	r5, [sp, #24]
30005680:	f010 fa96 	bl	30015bb0 <_printf>
                        err = ERR_PT_ERASE_FAIL;
30005684:	200a      	movs	r0, #10
30005686:	f7fe bd84 	b.w	30004192 <cmd_flash_storage+0x4c6>
    for (i =  0; i < msfs->count; i++, seq_info++) {
3000568a:	2600      	movs	r6, #0
3000568c:	e6dc      	b.n	30005448 <cmd_flash_storage+0x177c>
3000568e:	9b10      	ldr	r3, [sp, #64]	; 0x40
30005690:	f8dd a038 	ldr.w	r10, [r13, #56]	; 0x38
30005694:	695e      	ldr	r6, [r3, #20]
                data = (char *) data + sizeof(uint32_t);
30005696:	f8dd b070 	ldr.w	r11, [r13, #112]	; 0x70
3000569a:	f7ff b8ec 	b.w	30004876 <cmd_flash_storage+0xbaa>
        ERROR("erase sfs fail\n");
3000569e:	f24a 71fc 	movw	r1, #43004	; 0xa7fc
300056a2:	f24b 20b8 	movw	r0, #45752	; 0xb2b8
300056a6:	f44f 62b5 	mov.w	r2, #1448	; 0x5a8
300056aa:	f2c3 0101 	movt	r1, #12289	; 0x3001
300056ae:	f2c3 0001 	movt	r0, #12289	; 0x3001
300056b2:	f010 fa7d 	bl	30015bb0 <_printf>
        free(buffer);
300056b6:	4628      	mov	r0, r5
300056b8:	f00f f868 	bl	3001478c <free>
300056bc:	f7fe bd28 	b.w	30004110 <cmd_flash_storage+0x444>
                        ERROR(" write data error!\n");
300056c0:	f24a 7194 	movw	r1, #42900	; 0xa794
300056c4:	f24b 0004 	movw	r0, #45060	; 0xb004
300056c8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300056cc:	f240 4212 	movw	r2, #1042	; 0x412
300056d0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300056d4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300056d6:	9d06      	ldr	r5, [sp, #24]
300056d8:	f010 fa6a 	bl	30015bb0 <_printf>
                        err = ERR_PT_FLASH_FAIL;
300056dc:	2009      	movs	r0, #9
300056de:	f7fe bd58 	b.w	30004192 <cmd_flash_storage+0x4c6>
        ret = PTB_NO_NEED_FLASH;
300056e2:	2301      	movs	r3, #1
300056e4:	469b      	mov	r11, r3
300056e6:	f7fe bc26 	b.w	30003f36 <cmd_flash_storage+0x26a>
300056ea:	f8dd 8040 	ldr.w	r8, [r13, #64]	; 0x40
300056ee:	4653      	mov	r3, r10
300056f0:	f8dd 9054 	ldr.w	r9, [r13, #84]	; 0x54
300056f4:	f8dd a058 	ldr.w	r10, [r13, #88]	; 0x58
300056f8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300056fa:	9d06      	ldr	r5, [sp, #24]
300056fc:	f8d8 e010 	ldr.w	r14, [r8, #16]
    if (total_blocks != sparse_header->total_blks) {
30005700:	459e      	cmp	r14, r3
30005702:	f000 811f 	beq.w	30005944 <cmd_flash_storage+0x1c78>
        ERROR(" total block:%u error!\n", total_blocks);
30005706:	f24a 7194 	movw	r1, #42900	; 0xa794
3000570a:	f24b 00a4 	movw	r0, #45220	; 0xb0a4
3000570e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005712:	f240 4251 	movw	r2, #1105	; 0x451
30005716:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000571a:	f010 fa49 	bl	30015bb0 <_printf>
        err = ERR_PT_FLASH_FAIL;
3000571e:	2009      	movs	r0, #9
30005720:	f7fe bd37 	b.w	30004192 <cmd_flash_storage+0x4c6>
30005724:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005726:	9d06      	ldr	r5, [sp, #24]
30005728:	f8cd 9040 	str.w	r9, [r13, #64]	; 0x40
            ERROR("data end:%lu  data:%p chunk header size:%u\n",
3000572c:	220c      	movs	r2, #12
3000572e:	f24a 7194 	movw	r1, #42900	; 0xa794
30005732:	9c10      	ldr	r4, [sp, #64]	; 0x40
30005734:	f64a 50f0 	movw	r0, #44528	; 0xadf0
30005738:	9201      	str	r2, [sp, #4]
3000573a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000573e:	9b12      	ldr	r3, [sp, #72]	; 0x48
30005740:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005744:	9400      	str	r4, [sp, #0]
30005746:	f240 3256 	movw	r2, #854	; 0x356
3000574a:	f010 fa31 	bl	30015bb0 <_printf>
            err = ERR_SPARSE_IMAGE_BUFFERED;
3000574e:	2010      	movs	r0, #16
30005750:	f7fe bd1f 	b.w	30004192 <cmd_flash_storage+0x4c6>
30005754:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005756:	9d06      	ldr	r5, [sp, #24]
            ERROR("image too large:%llu!\n", size);
30005758:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
3000575c:	f24a 7194 	movw	r1, #42900	; 0xa794
30005760:	f64a 50a8 	movw	r0, #44456	; 0xada8
30005764:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005768:	e9cd 3400 	strd	r3, r4, [r13]
3000576c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005770:	f240 324b 	movw	r2, #843	; 0x34b
30005774:	f010 fa1c 	bl	30015bb0 <_printf>
            err = ERR_IMAGE_TOO_LARGE;
30005778:	2005      	movs	r0, #5
3000577a:	f7fe bd0a 	b.w	30004192 <cmd_flash_storage+0x4c6>
3000577e:	f8dd b088 	ldr.w	r11, [r13, #136]	; 0x88
30005782:	f7ff b90f 	b.w	300049a4 <cmd_flash_storage+0xcd8>
30005786:	2400      	movs	r4, #0
30005788:	f7ff b932 	b.w	300049f0 <cmd_flash_storage+0xd24>
                        ERROR(" size:%llu error!\n", size);
3000578c:	461c      	mov	r4, r3
3000578e:	4613      	mov	r3, r2
30005790:	f24a 7194 	movw	r1, #42900	; 0xa794
30005794:	f64a 70e4 	movw	r0, #45028	; 0xafe4
30005798:	e9cd 3400 	strd	r3, r4, [r13]
3000579c:	f2c3 0101 	movt	r1, #12289	; 0x3001
300057a0:	f240 32fd 	movw	r2, #1021	; 0x3fd
300057a4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300057a8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300057aa:	9d06      	ldr	r5, [sp, #24]
300057ac:	f010 fa00 	bl	30015bb0 <_printf>
                        err = ERR_SPARSE_IMAGE_CHUNK_TOO_LARGE;
300057b0:	2012      	movs	r0, #18
300057b2:	f7fe bcee 	b.w	30004192 <cmd_flash_storage+0x4c6>
                        ERROR(" chunk size:%u error!\n", chunk_header->chunk_sz);
300057b6:	f24a 7194 	movw	r1, #42900	; 0xa794
300057ba:	f64a 70c0 	movw	r0, #44992	; 0xafc0
300057be:	f2c3 0101 	movt	r1, #12289	; 0x3001
300057c2:	f240 32f5 	movw	r2, #1013	; 0x3f5
300057c6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300057ca:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300057cc:	9d06      	ldr	r5, [sp, #24]
300057ce:	f010 f9ef 	bl	30015bb0 <_printf>
                        err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
300057d2:	2013      	movs	r0, #19
300057d4:	f7fe bcdd 	b.w	30004192 <cmd_flash_storage+0x4c6>
300057d8:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300057da:	9d06      	ldr	r5, [sp, #24]
            ERROR("chunk header error:%u!\n", sparse_header->chunk_hdr_sz);
300057dc:	f24a 7194 	movw	r1, #42900	; 0xa794
300057e0:	f64a 602c 	movw	r0, #44588	; 0xae2c
300057e4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300057e8:	f240 3261 	movw	r2, #865	; 0x361
300057ec:	f2c3 0001 	movt	r0, #12289	; 0x3001
300057f0:	f010 f9de 	bl	30015bb0 <_printf>
            err = ERR_SPARSE_IMAGE_CHUNK_HEADER;
300057f4:	2011      	movs	r0, #17
300057f6:	f7fe bccc 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR(" chunk total size:%u error!\n", chunk_header->total_sz);
300057fa:	f24a 7194 	movw	r1, #42900	; 0xa794
300057fe:	f24b 0028 	movw	r0, #45096	; 0xb028
30005802:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005806:	f240 4229 	movw	r2, #1065	; 0x429
3000580a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000580e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005810:	9d06      	ldr	r5, [sp, #24]
30005812:	f010 f9cd 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
30005816:	2013      	movs	r0, #19
30005818:	f7fe bcbb 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("chunk size error:%u!\n", chunk_header->chunk_sz);
3000581c:	f24a 7194 	movw	r1, #42900	; 0xa794
30005820:	f64a 7024 	movw	r0, #44836	; 0xaf24
30005824:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005828:	f44f 726d 	mov.w	r2, #948	; 0x3b4
3000582c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005830:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005832:	9d06      	ldr	r5, [sp, #24]
30005834:	f010 f9bc 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
30005838:	2013      	movs	r0, #19
3000583a:	f7fe bcaa 	b.w	30004192 <cmd_flash_storage+0x4c6>
                        ERROR("write data error!\n");
3000583e:	f24a 7194 	movw	r1, #42900	; 0xa794
30005842:	f64a 7004 	movw	r0, #44804	; 0xaf04
30005846:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000584a:	f240 32ad 	movw	r2, #941	; 0x3ad
3000584e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005852:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005854:	9d06      	ldr	r5, [sp, #24]
30005856:	f010 f9ab 	bl	30015bb0 <_printf>
                        err = ERR_PT_FLASH_FAIL;
3000585a:	2009      	movs	r0, #9
3000585c:	f7fe bc99 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR(" chunk data size:%llu error!\n", chunk_data_sz);
30005860:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
30005864:	f24a 7194 	movw	r1, #42900	; 0xa794
30005868:	f24b 0054 	movw	r0, #45140	; 0xb054
3000586c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005870:	e9cd 3400 	strd	r3, r4, [r13]
30005874:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005878:	9f0c      	ldr	r7, [sp, #48]	; 0x30
3000587a:	f240 4237 	movw	r2, #1079	; 0x437
3000587e:	9d06      	ldr	r5, [sp, #24]
30005880:	f010 f996 	bl	30015bb0 <_printf>
                    err = ERR_IMAGE_TOO_LARGE;
30005884:	2005      	movs	r0, #5
30005886:	f7fe bc84 	b.w	30004192 <cmd_flash_storage+0x4c6>
3000588a:	46be      	mov	r14, r7
                    ERROR(" chunk size:%u error!\n", chunk_header->chunk_sz);
3000588c:	f24a 7194 	movw	r1, #42900	; 0xa794
30005890:	f64a 70c0 	movw	r0, #44992	; 0xafc0
30005894:	4673      	mov	r3, r14
30005896:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000589a:	f240 422f 	movw	r2, #1071	; 0x42f
3000589e:	f2c3 0001 	movt	r0, #12289	; 0x3001
300058a2:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300058a4:	9d06      	ldr	r5, [sp, #24]
300058a6:	f010 f983 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
300058aa:	2013      	movs	r0, #19
300058ac:	f7fe bc71 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("fill type error, size:%u!\n", chunk_header->total_sz);
300058b0:	f24a 7194 	movw	r1, #42900	; 0xa794
300058b4:	f64a 7048 	movw	r0, #44872	; 0xaf48
300058b8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300058bc:	f44f 7270 	mov.w	r2, #960	; 0x3c0
300058c0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300058c4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300058c6:	9d06      	ldr	r5, [sp, #24]
300058c8:	f010 f972 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
300058cc:	2013      	movs	r0, #19
300058ce:	f7fe bc60 	b.w	30004192 <cmd_flash_storage+0x4c6>
300058d2:	46be      	mov	r14, r7
                    ERROR(" chunk size:%u error!\n", chunk_header->chunk_sz);
300058d4:	f24a 7194 	movw	r1, #42900	; 0xa794
300058d8:	f64a 70c0 	movw	r0, #44992	; 0xafc0
300058dc:	4673      	mov	r3, r14
300058de:	f2c3 0101 	movt	r1, #12289	; 0x3001
300058e2:	f240 421f 	movw	r2, #1055	; 0x41f
300058e6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300058ea:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300058ec:	9d06      	ldr	r5, [sp, #24]
300058ee:	f010 f95f 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
300058f2:	2013      	movs	r0, #19
300058f4:	f7fe bc4d 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("data end:%lu  data:%p \n", data_end, data);
300058f8:	f24a 7194 	movw	r1, #42900	; 0xa794
300058fc:	f64a 7098 	movw	r0, #44952	; 0xaf98
30005900:	4613      	mov	r3, r2
30005902:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005906:	f8cd 9000 	str.w	r9, [r13]
3000590a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000590e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005910:	f240 32d7 	movw	r2, #983	; 0x3d7
30005914:	9d06      	ldr	r5, [sp, #24]
30005916:	f010 f94b 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_BUFFERED;
3000591a:	2010      	movs	r0, #16
3000591c:	f7fe bc39 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("blk_sz_actual:%u error!\n", blk_sz_actual);
30005920:	f24a 7194 	movw	r1, #42900	; 0xa794
30005924:	f64a 7070 	movw	r0, #44912	; 0xaf70
30005928:	4613      	mov	r3, r2
3000592a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000592e:	f240 32c9 	movw	r2, #969	; 0x3c9
30005932:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005936:	9f0c      	ldr	r7, [sp, #48]	; 0x30
30005938:	9d06      	ldr	r5, [sp, #24]
3000593a:	f010 f939 	bl	30015bb0 <_printf>
                    err = ERR_INVALID_BLOCK_SIZE;
3000593e:	200d      	movs	r0, #13
30005940:	f7fe bc27 	b.w	30004192 <cmd_flash_storage+0x4c6>
                       total_blocks * sparse_header->blk_sz,
30005944:	f8d8 200c 	ldr.w	r2, [r8, #12]
    padding_avb_footer(storage, ptn, size,
30005948:	2300      	movs	r3, #0
    if (!storage || pt_size - image_sz < sizeof(AvbFooter)) {
3000594a:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
    padding_avb_footer(storage, ptn, size,
3000594e:	f8da 4070 	ldr.w	r4, [r10, #112]	; 0x70
                       total_blocks * sparse_header->blk_sz,
30005952:	fb02 f20e 	mul.w	r2, r2, r14
    if (!storage || pt_size - image_sz < sizeof(AvbFooter)) {
30005956:	1a80      	subs	r0, r0, r2
30005958:	eb61 0103 	sbc.w	r1, r1, r3
3000595c:	2900      	cmp	r1, #0
3000595e:	bf08      	it	eq
30005960:	2840      	cmpeq	r0, #64	; 0x40
30005962:	f4fe a9dc 	bcc.w	30003d1e <cmd_flash_storage+0x52>
30005966:	e9cd 2302 	strd	r2, r3, [r13, #8]
3000596a:	4648      	mov	r0, r9
3000596c:	9404      	str	r4, [sp, #16]
3000596e:	e9dd 340a 	ldrd	r3, r4, [r13, #40]	; 0x28
30005972:	e9cd 3400 	strd	r3, r4, [r13]
30005976:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
3000597a:	f7fd ff95 	bl	300038a8 <padding_avb_footer.part.7.constprop.16>
3000597e:	f7fe b9ce 	b.w	30003d1e <cmd_flash_storage+0x52>
30005982:	464a      	mov	r2, r9
                    ERROR("data end:%lu  data:%p chunk_data_sz:%llu\n",
30005984:	f24a 7194 	movw	r1, #42900	; 0xa794
30005988:	e9dd 890e 	ldrd	r8, r9, [r13, #56]	; 0x38
3000598c:	f64a 60a8 	movw	r0, #44712	; 0xaea8
30005990:	9200      	str	r2, [sp, #0]
30005992:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005996:	9b12      	ldr	r3, [sp, #72]	; 0x48
30005998:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000599c:	e9cd 8902 	strd	r8, r9, [r13, #8]
300059a0:	f240 327e 	movw	r2, #894	; 0x37e
300059a4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300059a6:	9d06      	ldr	r5, [sp, #24]
300059a8:	f010 f902 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_BUFFERED;
300059ac:	2010      	movs	r0, #16
300059ae:	f7fe bbf0 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("chunk size:%llu error!\n", chunk_data_sz);
300059b2:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
300059b6:	f24a 7194 	movw	r1, #42900	; 0xa794
300059ba:	f64a 6080 	movw	r0, #44672	; 0xae80
300059be:	f2c3 0101 	movt	r1, #12289	; 0x3001
300059c2:	e9cd 3400 	strd	r3, r4, [r13]
300059c6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300059ca:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300059cc:	f240 3277 	movw	r2, #887	; 0x377
300059d0:	9d06      	ldr	r5, [sp, #24]
300059d2:	f010 f8ed 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_CHUNK_NOT_MATCH;
300059d6:	2013      	movs	r0, #19
300059d8:	f7fe bbdb 	b.w	30004192 <cmd_flash_storage+0x4c6>
                    ERROR("data end:%lu  data:%p \n", data_end, data);
300059dc:	f24a 7194 	movw	r1, #42900	; 0xa794
300059e0:	f64a 7098 	movw	r0, #44952	; 0xaf98
300059e4:	f8cd b000 	str.w	r11, [r13]
300059e8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300059ec:	f240 423f 	movw	r2, #1087	; 0x43f
300059f0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300059f4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
300059f6:	9d06      	ldr	r5, [sp, #24]
300059f8:	f010 f8da 	bl	30015bb0 <_printf>
                    err = ERR_SPARSE_IMAGE_BUFFERED;
300059fc:	2010      	movs	r0, #16
300059fe:	f7fe bbc8 	b.w	30004192 <cmd_flash_storage+0x4c6>
30005a02:	bf00      	nop

30005a04 <cmd_flash_proc>:
{
30005a04:	b5f0      	push	{r4, r5, r6, r7, r14}
30005a06:	460c      	mov	r4, r1
30005a08:	b085      	sub	sp, #20
    uint8_t md5_calc[MD5_LEN] = {0};
30005a0a:	2100      	movs	r1, #0
{
30005a0c:	4605      	mov	r5, r0
    ret = parse_partition_name(arg);
30005a0e:	4620      	mov	r0, r4
{
30005a10:	4616      	mov	r6, r2
    uint8_t md5_calc[MD5_LEN] = {0};
30005a12:	e9cd 1100 	strd	r1, r1, [r13]
{
30005a16:	461f      	mov	r7, r3
    uint8_t md5_calc[MD5_LEN] = {0};
30005a18:	e9cd 1102 	strd	r1, r1, [r13, #8]
    ret = parse_partition_name(arg);
30005a1c:	f7fc fbce 	bl	300021bc <parse_partition_name>
    if (ret) {
30005a20:	2800      	cmp	r0, #0
30005a22:	d14f      	bne.n	30005ac4 <cmd_flash_proc+0xc0>
    if (do_md5_check) {
30005a24:	f646 4374 	movw	r3, #27764	; 0x6c74
30005a28:	f2c3 0302 	movt	r3, #12290	; 0x3002
30005a2c:	781b      	ldrb	r3, [r3, #0]
30005a2e:	2b00      	cmp	r3, #0
30005a30:	d040      	beq.n	30005ab4 <cmd_flash_proc+0xb0>
        md5(data, sz, md5_calc);
30005a32:	466a      	mov	r2, r13
30005a34:	4639      	mov	r1, r7
30005a36:	4630      	mov	r0, r6
30005a38:	f010 fda6 	bl	30016588 <md5>
        if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30005a3c:	9a00      	ldr	r2, [sp, #0]
30005a3e:	f646 43f8 	movw	r3, #27896	; 0x6cf8
30005a42:	f2c3 0302 	movt	r3, #12290	; 0x3002
30005a46:	6819      	ldr	r1, [r3, #0]
30005a48:	4291      	cmp	r1, r2
30005a4a:	d027      	beq.n	30005a9c <cmd_flash_proc+0x98>
            ERROR("md5 check fail!\n");
30005a4c:	f64a 0158 	movw	r1, #43096	; 0xa858
30005a50:	f64b 10a8 	movw	r0, #47528	; 0xb9a8
30005a54:	f640 028c 	movw	r2, #2188	; 0x88c
30005a58:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005a5c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005a60:	f010 f8a6 	bl	30015bb0 <_printf>
30005a64:	f646 42f8 	movw	r2, #27896	; 0x6cf8
30005a68:	2300      	movs	r3, #0
30005a6a:	f2c3 0202 	movt	r2, #12290	; 0x3002
30005a6e:	4610      	mov	r0, r2
30005a70:	2110      	movs	r1, #16
30005a72:	f00e fc5d 	bl	30014330 <hexdump8_ex>
30005a76:	466a      	mov	r2, r13
30005a78:	4610      	mov	r0, r2
30005a7a:	2300      	movs	r3, #0
30005a7c:	2110      	movs	r1, #16
30005a7e:	f00e fc57 	bl	30014330 <hexdump8_ex>
            fastboot_common_fail(fb, response_error(ERR_HASH_FAIL, ""));
30005a82:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30005a86:	2016      	movs	r0, #22
30005a88:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005a8c:	f7fc ff92 	bl	300029b4 <response_error>
30005a90:	4601      	mov	r1, r0
30005a92:	4628      	mov	r0, r5
30005a94:	f00e fdc4 	bl	30014620 <fastboot_common_fail>
}
30005a98:	b005      	add	sp, #20
30005a9a:	bdf0      	pop	{r4, r5, r6, r7, r15}
        if (memcmp(md5_received, md5_calc, MD5_LEN)) {
30005a9c:	6859      	ldr	r1, [r3, #4]
30005a9e:	9a01      	ldr	r2, [sp, #4]
30005aa0:	4291      	cmp	r1, r2
30005aa2:	d1d3      	bne.n	30005a4c <cmd_flash_proc+0x48>
30005aa4:	6899      	ldr	r1, [r3, #8]
30005aa6:	9a02      	ldr	r2, [sp, #8]
30005aa8:	4291      	cmp	r1, r2
30005aaa:	d1cf      	bne.n	30005a4c <cmd_flash_proc+0x48>
30005aac:	68da      	ldr	r2, [r3, #12]
30005aae:	9b03      	ldr	r3, [sp, #12]
30005ab0:	429a      	cmp	r2, r3
30005ab2:	d1cb      	bne.n	30005a4c <cmd_flash_proc+0x48>
    cmd_flash_storage(fb, arg, data, sz);
30005ab4:	463b      	mov	r3, r7
30005ab6:	4632      	mov	r2, r6
30005ab8:	4621      	mov	r1, r4
30005aba:	4628      	mov	r0, r5
30005abc:	f7fe f906 	bl	30003ccc <cmd_flash_storage>
}
30005ac0:	b005      	add	sp, #20
30005ac2:	bdf0      	pop	{r4, r5, r6, r7, r15}
30005ac4:	4603      	mov	r3, r0
        ERROR("partition name error:%d!\n", ret);
30005ac6:	f64a 0158 	movw	r1, #43096	; 0xa858
30005aca:	f64a 4064 	movw	r0, #44132	; 0xac64
30005ace:	f640 0279 	movw	r2, #2169	; 0x879
30005ad2:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005ad6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005ada:	f010 f869 	bl	30015bb0 <_printf>
        fastboot_common_fail(fb, response_error(ERR_PT_FULL_NAME_FORMAT, arg));
30005ade:	4621      	mov	r1, r4
30005ae0:	200c      	movs	r0, #12
30005ae2:	f7fc ff67 	bl	300029b4 <response_error>
30005ae6:	4601      	mov	r1, r0
30005ae8:	4628      	mov	r0, r5
30005aea:	f00e fd99 	bl	30014620 <fastboot_common_fail>
}
30005aee:	b005      	add	sp, #20
30005af0:	bdf0      	pop	{r4, r5, r6, r7, r15}
30005af2:	bf00      	nop

30005af4 <sfs_crc32>:
               crc32_table_sfs[i+1],
               crc32_table_sfs[i+2],
               crc32_table_sfs[i+3]);
    }
#endif
    crc ^= 0xFFFFFFFFUL;
30005af4:	43c0      	mvns	r0, r0
    while (len--)
30005af6:	b19a      	cbz	r2, 30005b20 <sfs_crc32+0x2c>
{
30005af8:	b410      	push	{r4}
30005afa:	f64b 7434 	movw	r4, #48948	; 0xbf34
30005afe:	440a      	add	r2, r1
30005b00:	f2c3 0401 	movt	r4, #12289	; 0x3001
        crc = ((crc << 8)&0xFFFFFF00UL)^crc32_table_sfs[((crc>>24)&0xFFUL)^(*buffer++)];
30005b04:	f811 3b01 	ldrb.w	r3, [r1], #1
30005b08:	ea83 6310 	eor.w	r3, r3, r0, lsr #24
    while (len--)
30005b0c:	4291      	cmp	r1, r2
        crc = ((crc << 8)&0xFFFFFF00UL)^crc32_table_sfs[((crc>>24)&0xFFUL)^(*buffer++)];
30005b0e:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
30005b12:	ea83 2000 	eor.w	r0, r3, r0, lsl #8
    while (len--)
30005b16:	d1f5      	bne.n	30005b04 <sfs_crc32+0x10>
    return crc ^ 0xFFFFFFFFUL;
}
30005b18:	f85d 4b04 	ldr.w	r4, [r13], #4
30005b1c:	43c0      	mvns	r0, r0
30005b1e:	4770      	bx	r14
30005b20:	43c0      	mvns	r0, r0
30005b22:	4770      	bx	r14

30005b24 <get_sfs_info>:
{
    uint8_t *temp = buffer;
    uint32_t crc_val = 0;
    uint32_t crc_orig = 0;

    if (!sfs || !buffer) {
30005b24:	2900      	cmp	r1, #0
30005b26:	bf18      	it	ne
30005b28:	2800      	cmpne	r0, #0
{
30005b2a:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (!sfs || !buffer) {
30005b2c:	d039      	beq.n	30005ba2 <get_sfs_info+0x7e>
        dprintf(CRITICAL, "%s sfs/buffer is null\n", __func__);
        return 1;
    }

    if (len < SFS_SIZE) {
30005b2e:	2a7f      	cmp	r2, #127	; 0x7f
30005b30:	d92a      	bls.n	30005b88 <get_sfs_info+0x64>
        dprintf(CRITICAL, "%s sfs size error! size:%d\n", __func__, len);
        return 1;
    }

    if (*(uint32_t *)temp != SFS_TAG) {
30005b32:	680a      	ldr	r2, [r1, #0]
30005b34:	f245 3301 	movw	r3, #21249	; 0x5301
30005b38:	f2c5 3346 	movt	r3, #21318	; 0x5346
30005b3c:	429a      	cmp	r2, r3
30005b3e:	d13d      	bne.n	30005bbc <get_sfs_info+0x98>
        dprintf(CRITICAL, "%s sfs tag error!\n", __func__);
        return 1;
    }

    crc_orig = GET_LWORD_FROM_BYTE(&buffer[SFS_CRC32_OFFSET]);
30005b40:	460e      	mov	r6, r1
30005b42:	f64b 7734 	movw	r7, #48948	; 0xbf34
30005b46:	460d      	mov	r5, r1
30005b48:	f2c3 0701 	movt	r7, #12289	; 0x3001
    crc ^= 0xFFFFFFFFUL;
30005b4c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    crc_orig = GET_LWORD_FROM_BYTE(&buffer[SFS_CRC32_OFFSET]);
30005b50:	f856 2f7c 	ldr.w	r2, [r6, #124]!
        crc = ((crc << 8)&0xFFFFFF00UL)^crc32_table_sfs[((crc>>24)&0xFFUL)^(*buffer++)];
30005b54:	f815 3b01 	ldrb.w	r3, [r5], #1
30005b58:	ea83 6314 	eor.w	r3, r3, r4, lsr #24
    while (len--)
30005b5c:	42ae      	cmp	r6, r5
        crc = ((crc << 8)&0xFFFFFF00UL)^crc32_table_sfs[((crc>>24)&0xFFUL)^(*buffer++)];
30005b5e:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
30005b62:	ea83 2404 	eor.w	r4, r3, r4, lsl #8
    while (len--)
30005b66:	d1f5      	bne.n	30005b54 <get_sfs_info+0x30>
    return crc ^ 0xFFFFFFFFUL;
30005b68:	43e3      	mvns	r3, r4
    crc_val = sfs_crc32(0, buffer, SFS_SIZE - 4);
    if (crc_val != crc_orig) {
30005b6a:	429a      	cmp	r2, r3
30005b6c:	d033      	beq.n	30005bd6 <get_sfs_info+0xb2>
        dprintf(CRITICAL, "%s sfs crc_orig:0x%0x crc_val:0x%0x!\n", __func__, crc_orig, crc_val);
30005b6e:	f64b 7124 	movw	r1, #48932	; 0xbf24
30005b72:	f24c 307c 	movw	r0, #50044	; 0xc37c
30005b76:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005b7a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005b7e:	f010 f817 	bl	30015bb0 <_printf>
        return 1;
30005b82:	2301      	movs	r3, #1
    memcpy(sfs->ospi_settings, temp + SFS_IP_SETTINGS_OFFSET,
           SFS_IP_SETTINGS_SIZE);
    memcpy(sfs->training_pattern, temp + SFS_TP_OFFSET, SFS_TP_SIZE);

    return 0;
}
30005b84:	4618      	mov	r0, r3
30005b86:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "%s sfs size error! size:%d\n", __func__, len);
30005b88:	f64b 7124 	movw	r1, #48932	; 0xbf24
30005b8c:	f24c 304c 	movw	r0, #49996	; 0xc34c
30005b90:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005b94:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005b98:	f010 f80a 	bl	30015bb0 <_printf>
        return 1;
30005b9c:	2301      	movs	r3, #1
}
30005b9e:	4618      	mov	r0, r3
30005ba0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "%s sfs/buffer is null\n", __func__);
30005ba2:	f64b 7124 	movw	r1, #48932	; 0xbf24
30005ba6:	f24c 3034 	movw	r0, #49972	; 0xc334
30005baa:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005bae:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005bb2:	f00f fffd 	bl	30015bb0 <_printf>
        return 1;
30005bb6:	2301      	movs	r3, #1
}
30005bb8:	4618      	mov	r0, r3
30005bba:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "%s sfs tag error!\n", __func__);
30005bbc:	f64b 7124 	movw	r1, #48932	; 0xbf24
30005bc0:	f24c 3068 	movw	r0, #50024	; 0xc368
30005bc4:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005bc8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005bcc:	f00f fff0 	bl	30015bb0 <_printf>
        return 1;
30005bd0:	2301      	movs	r3, #1
}
30005bd2:	4618      	mov	r0, r3
30005bd4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    sfs->tag = *(uint32_t *)(temp + SFS_TAG_OFFSET);
30005bd6:	f245 3401 	movw	r4, #21249	; 0x5301
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005bda:	1d0b      	adds	r3, r1, #4
    sfs->tag = *(uint32_t *)(temp + SFS_TAG_OFFSET);
30005bdc:	f2c5 3446 	movt	r4, #21318	; 0x5346
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005be0:	1d02      	adds	r2, r0, #4
    sfs->tag = *(uint32_t *)(temp + SFS_TAG_OFFSET);
30005be2:	6004      	str	r4, [r0, #0]
    sfs->freq = *(temp + SFS_FREQ_OFFSET);
30005be4:	f891 4060 	ldrb.w	r4, [r1, #96]	; 0x60
30005be8:	f880 4060 	strb.w	r4, [r0, #96]	; 0x60
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005bec:	f101 0534 	add.w	r5, r1, #52	; 0x34
    sfs->normal_img_base = *(uint32_t *)(temp + SFS_NIA_OFFSET);
30005bf0:	6f0c      	ldr	r4, [r1, #112]	; 0x70
30005bf2:	66c4      	str	r4, [r0, #108]	; 0x6c
    sfs->backup_img_base = *(uint32_t *)(temp + SFS_BIA_OFFSET);
30005bf4:	6f4c      	ldr	r4, [r1, #116]	; 0x74
30005bf6:	6704      	str	r4, [r0, #112]	; 0x70
    sfs->crc32 = *(uint32_t *)(temp + SFS_CRC32_OFFSET);
30005bf8:	6fcc      	ldr	r4, [r1, #124]	; 0x7c
30005bfa:	6744      	str	r4, [r0, #116]	; 0x74
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005bfc:	f8d3 c000 	ldr.w	r12, [r3]
30005c00:	3310      	adds	r3, #16
30005c02:	f853 7c0c 	ldr.w	r7, [r3, #-12]
30005c06:	3210      	adds	r2, #16
30005c08:	f853 6c08 	ldr.w	r6, [r3, #-8]
30005c0c:	f853 4c04 	ldr.w	r4, [r3, #-4]
30005c10:	42ab      	cmp	r3, r5
30005c12:	f842 cc10 	str.w	r12, [r2, #-16]
30005c16:	f842 7c0c 	str.w	r7, [r2, #-12]
30005c1a:	f842 6c08 	str.w	r6, [r2, #-8]
30005c1e:	f842 4c04 	str.w	r4, [r2, #-4]
30005c22:	d1eb      	bne.n	30005bfc <get_sfs_info+0xd8>
30005c24:	681d      	ldr	r5, [r3, #0]
    memcpy(sfs->ospi_settings, temp + SFS_IP_SETTINGS_OFFSET,
30005c26:	460c      	mov	r4, r1
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005c28:	685e      	ldr	r6, [r3, #4]
30005c2a:	689b      	ldr	r3, [r3, #8]
30005c2c:	6093      	str	r3, [r2, #8]
    return 0;
30005c2e:	2300      	movs	r3, #0
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005c30:	6015      	str	r5, [r2, #0]
    memcpy(sfs->training_pattern, temp + SFS_TP_OFFSET, SFS_TP_SIZE);
30005c32:	460d      	mov	r5, r1
    memcpy(sfs->init_act, temp + SFS_INIT_ACT_OFFSET, SFS_INIT_ACT_SIZE);
30005c34:	6056      	str	r6, [r2, #4]
    memcpy(sfs->xfer_config, temp + SFS_XFER_CONFIG_OFFSET,
30005c36:	f851 7f40 	ldr.w	r7, [r1, #64]!
30005c3a:	684a      	ldr	r2, [r1, #4]
30005c3c:	688e      	ldr	r6, [r1, #8]
30005c3e:	68c9      	ldr	r1, [r1, #12]
30005c40:	64c1      	str	r1, [r0, #76]	; 0x4c
30005c42:	6407      	str	r7, [r0, #64]	; 0x40
30005c44:	6442      	str	r2, [r0, #68]	; 0x44
30005c46:	6486      	str	r6, [r0, #72]	; 0x48
    memcpy(sfs->ospi_settings, temp + SFS_IP_SETTINGS_OFFSET,
30005c48:	f854 cf50 	ldr.w	r12, [r4, #80]!
30005c4c:	68e1      	ldr	r1, [r4, #12]
30005c4e:	6867      	ldr	r7, [r4, #4]
30005c50:	68a6      	ldr	r6, [r4, #8]
30005c52:	6586      	str	r6, [r0, #88]	; 0x58
30005c54:	f8c0 c050 	str.w	r12, [r0, #80]	; 0x50
30005c58:	6547      	str	r7, [r0, #84]	; 0x54
30005c5a:	65c1      	str	r1, [r0, #92]	; 0x5c
    memcpy(sfs->training_pattern, temp + SFS_TP_OFFSET, SFS_TP_SIZE);
30005c5c:	f855 2f68 	ldr.w	r2, [r5, #104]!
30005c60:	6869      	ldr	r1, [r5, #4]
30005c62:	f8c0 1065 	str.w	r1, [r0, #101]	; 0x65
30005c66:	f8c0 2061 	str.w	r2, [r0, #97]	; 0x61
    return 0;
30005c6a:	e798      	b.n	30005b9e <get_sfs_info+0x7a>

30005c6c <parse_gpt_table_from_buffer>:
    return ret;
}

unsigned int parse_gpt_table_from_buffer(uint8_t *buf, uint32_t buf_len,
        GPT_header *gpt_header, uint32_t block_size, bool is_secondary_gpt)
{
30005c6c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30005c70:	460c      	mov	r4, r1
30005c72:	b0ab      	sub	sp, #172	; 0xac
30005c74:	f89d 60d0 	ldrb.w	r6, [r13, #208]	; 0xd0
30005c78:	9311      	str	r3, [sp, #68]	; 0x44
    unsigned int ret;
    struct partition_entry *partition_entries = gpt_header->partition_entries;
30005c7a:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
{
30005c7c:	920f      	str	r2, [sp, #60]	; 0x3c
30005c7e:	f8cd e058 	str.w	r14, [r13, #88]	; 0x58
30005c82:	9010      	str	r0, [sp, #64]	; 0x40

    /* Allocate partition entries array */
    if (!partition_entries) {
30005c84:	2b00      	cmp	r3, #0
30005c86:	f000 8092 	beq.w	30005dae <parse_gpt_table_from_buffer+0x142>
        partition_entries = (struct partition_entry *) calloc(NUM_PARTITIONS,
                            sizeof(struct partition_entry));
        ASSERT(partition_entries);
    }
    else {
        memset(partition_entries, 0x0,
30005c8a:	f44f 4290 	mov.w	r2, #18432	; 0x4800
30005c8e:	2100      	movs	r1, #0
30005c90:	4618      	mov	r0, r3
30005c92:	f00e ee6e 	blx	30014970 <memset>
               NUM_PARTITIONS * sizeof(struct partition_entry));
        gpt_header->actual_entries_count = 0;
30005c96:	990f      	ldr	r1, [sp, #60]	; 0x3c
30005c98:	2200      	movs	r2, #0
30005c9a:	660a      	str	r2, [r1, #96]	; 0x60
        memset(partition_entries, 0x0,
30005c9c:	4603      	mov	r3, r0
    }

    gpt_header->partition_entries = partition_entries;
30005c9e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
30005ca0:	65d3      	str	r3, [r2, #92]	; 0x5c
    uint32_t part_entry_cnt = block_size / PARTITION_ENTRY_SIZE;
    struct partition_entry *partition_entries = NULL;
    unsigned char *new_buffer = NULL;
    uint32_t partition_count = 0;

    if (is_secondary_gpt) {
30005ca2:	b366      	cbz	r6, 30005cfe <parse_gpt_table_from_buffer+0x92>
        data = buffer + (buf_len - block_size);
30005ca4:	9b11      	ldr	r3, [sp, #68]	; 0x44
30005ca6:	1ae4      	subs	r4, r4, r3
30005ca8:	9b10      	ldr	r3, [sp, #64]	; 0x40
30005caa:	441c      	add	r4, r3
    if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
30005cac:	6821      	ldr	r1, [r4, #0]
30005cae:	f244 6345 	movw	r3, #17989	; 0x4645
30005cb2:	6862      	ldr	r2, [r4, #4]
30005cb4:	f2c2 0349 	movt	r3, #8265	; 0x2049
30005cb8:	4299      	cmp	r1, r3
30005cba:	d105      	bne.n	30005cc8 <parse_gpt_table_from_buffer+0x5c>
30005cbc:	f244 1350 	movw	r3, #16720	; 0x4150
30005cc0:	f2c5 4352 	movt	r3, #21586	; 0x5452
30005cc4:	429a      	cmp	r2, r3
30005cc6:	d01c      	beq.n	30005d02 <parse_gpt_table_from_buffer+0x96>
        dprintf(CRITICAL, "GPT signature error:0x%0x  0x%0x\n",
30005cc8:	f24c 5040 	movw	r0, #50496	; 0xc540
30005ccc:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005cd0:	f00f ff6e 	bl	30015bb0 <_printf>
                                     &partition_entry_size, &header_size,
                                     &max_partition_count, gpt_header, block_size,
                                     is_secondary_gpt);

    if (ret) {
        dprintf(CRITICAL, "%s ret:%d\n", __func__, ret);
30005cd4:	f24c 31a4 	movw	r1, #50084	; 0xc3a4
30005cd8:	f24c 60f0 	movw	r0, #50928	; 0xc6f0
30005cdc:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005ce0:	2201      	movs	r2, #1
30005ce2:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005ce6:	f00f ff63 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "GPT read failed!\n");
30005cea:	f24c 60dc 	movw	r0, #50908	; 0xc6dc
30005cee:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005cf2:	f00f ff5d 	bl	30015bb0 <_printf>
        return 1;
30005cf6:	2001      	movs	r0, #1
}
30005cf8:	b02b      	add	sp, #172	; 0xac
30005cfa:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        data = buffer;
30005cfe:	9c10      	ldr	r4, [sp, #64]	; 0x40
30005d00:	e7d4      	b.n	30005cac <parse_gpt_table_from_buffer+0x40>
    *header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
30005d02:	68e7      	ldr	r7, [r4, #12]
    if (*header_size < GPT_HEADER_SIZE) {
30005d04:	2f5b      	cmp	r7, #91	; 0x5b
30005d06:	d97a      	bls.n	30005dfe <parse_gpt_table_from_buffer+0x192>
    if (*header_size > block_size) {
30005d08:	9b11      	ldr	r3, [sp, #68]	; 0x44
30005d0a:	42bb      	cmp	r3, r7
30005d0c:	d368      	bcc.n	30005de0 <parse_gpt_table_from_buffer+0x174>
    PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d0e:	2300      	movs	r3, #0
    crc_val  = crc32(0, buffer, *header_size);
30005d10:	4621      	mov	r1, r4
    crc_val_org = GET_LWORD_FROM_BYTE(&buffer[HEADER_CRC_OFFSET]);
30005d12:	6925      	ldr	r5, [r4, #16]
    crc_val  = crc32(0, buffer, *header_size);
30005d14:	463a      	mov	r2, r7
    PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d16:	7423      	strb	r3, [r4, #16]
    crc_val  = crc32(0, buffer, *header_size);
30005d18:	4618      	mov	r0, r3
    PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d1a:	7463      	strb	r3, [r4, #17]
30005d1c:	74a3      	strb	r3, [r4, #18]
30005d1e:	74e3      	strb	r3, [r4, #19]
    crc_val  = crc32(0, buffer, *header_size);
30005d20:	f00d f91a 	bl	30012f58 <crc32>
30005d24:	4601      	mov	r1, r0
    if (crc_val != crc_val_org) {
30005d26:	4285      	cmp	r5, r0
    crc_val  = crc32(0, buffer, *header_size);
30005d28:	9002      	str	r0, [sp, #8]
    if (crc_val != crc_val_org) {
30005d2a:	d160      	bne.n	30005dee <parse_gpt_table_from_buffer+0x182>
    current_lba =
30005d2c:	f8d4 901c 	ldr.w	r9, [r4, #28]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d30:	0e2b      	lsrs	r3, r5, #24
    current_lba =
30005d32:	f8d4 8018 	ldr.w	r8, [r4, #24]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d36:	0c2a      	lsrs	r2, r5, #16
30005d38:	74e3      	strb	r3, [r4, #19]
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d3a:	f1b9 0f00 	cmp.w	r9, #0
    backup_lba =
30005d3e:	6a23      	ldr	r3, [r4, #32]
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d40:	f086 0c01 	eor.w	r12, r6, #1
    backup_lba =
30005d44:	9305      	str	r3, [sp, #20]
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d46:	bf08      	it	eq
30005d48:	f1b8 0f01 	cmpeq.w	r8, #1
    backup_lba =
30005d4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d4e:	ea4f 2015 	mov.w	r0, r5, lsr #8
    last_usable_lba =
30005d52:	6b21      	ldr	r1, [r4, #48]	; 0x30
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d54:	74a2      	strb	r2, [r4, #18]
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d56:	f00c 0201 	and.w	r2, r12, #1
    backup_lba =
30005d5a:	9306      	str	r3, [sp, #24]
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d5c:	bf08      	it	eq
30005d5e:	2200      	moveq	r2, #0
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30005d60:	6aa3      	ldr	r3, [r4, #40]	; 0x28
30005d62:	930c      	str	r3, [sp, #48]	; 0x30
    last_usable_lba =
30005d64:	910a      	str	r1, [sp, #40]	; 0x28
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30005d66:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    last_usable_lba =
30005d68:	6b61      	ldr	r1, [r4, #52]	; 0x34
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30005d6a:	9308      	str	r3, [sp, #32]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30005d6c:	7425      	strb	r5, [r4, #16]
30005d6e:	7460      	strb	r0, [r4, #17]
        GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
30005d70:	6d63      	ldr	r3, [r4, #84]	; 0x54
    last_usable_lba =
30005d72:	910d      	str	r1, [sp, #52]	; 0x34
    if (!is_secondary_gpt && current_lba != GPT_LBA) {
30005d74:	2a00      	cmp	r2, #0
30005d76:	d149      	bne.n	30005e0c <parse_gpt_table_from_buffer+0x1a0>
    if (*partition_entry_size != PARTITION_ENTRY_SIZE) {
30005d78:	2b80      	cmp	r3, #128	; 0x80
30005d7a:	f040 8269 	bne.w	30006250 <parse_gpt_table_from_buffer+0x5e4>
        GET_LWORD_FROM_BYTE(&buffer[PARTITION_COUNT_OFFSET]);
30005d7e:	6d25      	ldr	r5, [r4, #80]	; 0x50
    if ((*max_partition_count) > (MIN_PARTITION_ARRAY_SIZE /
30005d80:	2d80      	cmp	r5, #128	; 0x80
30005d82:	f200 825e 	bhi.w	30006242 <parse_gpt_table_from_buffer+0x5d6>
    partition_0 = GET_LLWORD_FROM_BYTE(&buffer[PARTITION_ENTRIES_OFFSET]);
30005d86:	f8d4 b04c 	ldr.w	r11, [r4, #76]	; 0x4c
30005d8a:	f8d4 a048 	ldr.w	r10, [r4, #72]	; 0x48
    if (!is_secondary_gpt && partition_0 != 0x2) {
30005d8e:	f1bb 0f00 	cmp.w	r11, #0
30005d92:	bf08      	it	eq
30005d94:	f1ba 0f02 	cmpeq.w	r10, #2
30005d98:	d03f      	beq.n	30005e1a <parse_gpt_table_from_buffer+0x1ae>
30005d9a:	f1bc 0f00 	cmp.w	r12, #0
30005d9e:	d03c      	beq.n	30005e1a <parse_gpt_table_from_buffer+0x1ae>
        dprintf(CRITICAL, "PrimaryGPT starting LBA mismatch\n");
30005da0:	f24c 6048 	movw	r0, #50760	; 0xc648
30005da4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005da8:	f00f ff02 	bl	30015bb0 <_printf>
30005dac:	e792      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
        partition_entries = (struct partition_entry *) calloc(NUM_PARTITIONS,
30005dae:	2190      	movs	r1, #144	; 0x90
30005db0:	2080      	movs	r0, #128	; 0x80
30005db2:	f00e fccb 	bl	3001474c <calloc>
        ASSERT(partition_entries);
30005db6:	4603      	mov	r3, r0
30005db8:	2800      	cmp	r0, #0
30005dba:	f47f af70 	bne.w	30005c9e <parse_gpt_table_from_buffer+0x32>
30005dbe:	f24c 532c 	movw	r3, #50476	; 0xc52c
30005dc2:	f24c 42f0 	movw	r2, #50416	; 0xc4f0
30005dc6:	f24a 011c 	movw	r1, #40988	; 0xa01c
30005dca:	f2c3 0301 	movt	r3, #12289	; 0x3001
30005dce:	9816      	ldr	r0, [sp, #88]	; 0x58
30005dd0:	f2c3 0201 	movt	r2, #12289	; 0x3001
30005dd4:	9300      	str	r3, [sp, #0]
30005dd6:	f2c3 0101 	movt	r1, #12289	; 0x3001
30005dda:	23a5      	movs	r3, #165	; 0xa5
30005ddc:	f00e fa1a 	bl	30014214 <_panic>
        dprintf(CRITICAL, "GPT Header size is too large\n");
30005de0:	f24c 5084 	movw	r0, #50564	; 0xc584
30005de4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005de8:	f00f fee2 	bl	30015bb0 <_printf>
30005dec:	e772      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
        dprintf(CRITICAL,"Header crc mismatch crc_val = %u with crc_val_org = %u\n", crc_val,crc_val_org);
30005dee:	f24c 50a4 	movw	r0, #50596	; 0xc5a4
30005df2:	462a      	mov	r2, r5
30005df4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005df8:	f00f feda 	bl	30015bb0 <_printf>
30005dfc:	e76a      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
        dprintf(CRITICAL, "GPT Header size is too small\n");
30005dfe:	f24c 5064 	movw	r0, #50532	; 0xc564
30005e02:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005e06:	f00f fed3 	bl	30015bb0 <_printf>
30005e0a:	e763      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
        dprintf(CRITICAL, "Primary GPT first usable LBA mismatch\n");
30005e0c:	f24c 50dc 	movw	r0, #50652	; 0xc5dc
30005e10:	f2c3 0001 	movt	r0, #12289	; 0x3001
30005e14:	f00f fecc 	bl	30015bb0 <_printf>
30005e18:	e75c      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
    memcpy((void *)(gpt_header->sign), buffer, 8);
30005e1a:	6822      	ldr	r2, [r4, #0]
    memcpy((void *)(gpt_header->guid), buffer + 56, 16);
30005e1c:	4623      	mov	r3, r4
    memcpy((void *)(gpt_header->sign), buffer, 8);
30005e1e:	6860      	ldr	r0, [r4, #4]
30005e20:	990f      	ldr	r1, [sp, #60]	; 0x3c
30005e22:	6048      	str	r0, [r1, #4]
30005e24:	600a      	str	r2, [r1, #0]
    memcpy((void *)(gpt_header->version), buffer + 8, 4);
30005e26:	68a2      	ldr	r2, [r4, #8]
30005e28:	608a      	str	r2, [r1, #8]
    memcpy((void *)(gpt_header->guid), buffer + 56, 16);
30005e2a:	f853 ef38 	ldr.w	r14, [r3, #56]!
30005e2e:	68da      	ldr	r2, [r3, #12]
30005e30:	f8d3 c004 	ldr.w	r12, [r3, #4]
30005e34:	6898      	ldr	r0, [r3, #8]
30005e36:	460b      	mov	r3, r1
30005e38:	644a      	str	r2, [r1, #68]	; 0x44
30005e3a:	f8c1 e038 	str.w	r14, [r1, #56]	; 0x38
30005e3e:	f8c1 c03c 	str.w	r12, [r1, #60]	; 0x3c
30005e42:	6408      	str	r0, [r1, #64]	; 0x40
    gpt_header->header_sz             = *header_size;
30005e44:	60cf      	str	r7, [r1, #12]
    gpt_header->current_lba           = current_lba;
30005e46:	e9c1 8906 	strd	r8, r9, [r1, #24]
    gpt_header->backup_lba            = backup_lba;
30005e4a:	9905      	ldr	r1, [sp, #20]
30005e4c:	6219      	str	r1, [r3, #32]
30005e4e:	9906      	ldr	r1, [sp, #24]
30005e50:	6259      	str	r1, [r3, #36]	; 0x24
    gpt_header->first_usable_lba      = *first_usable_lba;
30005e52:	990c      	ldr	r1, [sp, #48]	; 0x30
30005e54:	6299      	str	r1, [r3, #40]	; 0x28
30005e56:	9908      	ldr	r1, [sp, #32]
30005e58:	62d9      	str	r1, [r3, #44]	; 0x2c
    gpt_header->last_usable_lba       = last_usable_lba;
30005e5a:	990a      	ldr	r1, [sp, #40]	; 0x28
30005e5c:	6319      	str	r1, [r3, #48]	; 0x30
    gpt_header->header_crc32          = crc_val;
30005e5e:	9a02      	ldr	r2, [sp, #8]
    gpt_header->last_usable_lba       = last_usable_lba;
30005e60:	990d      	ldr	r1, [sp, #52]	; 0x34
30005e62:	6359      	str	r1, [r3, #52]	; 0x34
    gpt_header->partition_entry_lba   =  partition_0;
30005e64:	e9c3 ab12 	strd	r10, r11, [r3, #72]	; 0x48
    gpt_header->partition_entry_count = *max_partition_count;
30005e68:	651d      	str	r5, [r3, #80]	; 0x50
    gpt_header->header_crc32          = crc_val;
30005e6a:	611a      	str	r2, [r3, #16]
    gpt_header->partition_entry_sz    = *partition_entry_size;
30005e6c:	2280      	movs	r2, #128	; 0x80
30005e6e:	655a      	str	r2, [r3, #84]	; 0x54
        return ret;
    }

    if (is_secondary_gpt) {
30005e70:	b91e      	cbnz	r6, 30005e7a <parse_gpt_table_from_buffer+0x20e>
        new_buffer = buffer;
    }
    else {
        new_buffer = buffer + block_size;
30005e72:	e9dd 3210 	ldrd	r3, r2, [r13, #64]	; 0x40
30005e76:	4413      	add	r3, r2
30005e78:	9310      	str	r3, [sp, #64]	; 0x40
    }

    crc_val_org = GET_LWORD_FROM_BYTE(&data[PARTITION_CRC_OFFSET]);
    crc_val  = crc32(0, new_buffer, max_partition_count * partition_entry_size);
30005e7a:	9910      	ldr	r1, [sp, #64]	; 0x40
30005e7c:	01ea      	lsls	r2, r5, #7
    crc_val_org = GET_LWORD_FROM_BYTE(&data[PARTITION_CRC_OFFSET]);
30005e7e:	6da4      	ldr	r4, [r4, #88]	; 0x58
    crc_val  = crc32(0, new_buffer, max_partition_count * partition_entry_size);
30005e80:	2000      	movs	r0, #0
30005e82:	f00d f869 	bl	30012f58 <crc32>
30005e86:	4602      	mov	r2, r0
    if (crc_val != crc_val_org) {
30005e88:	4284      	cmp	r4, r0
30005e8a:	f040 81c5 	bne.w	30006218 <parse_gpt_table_from_buffer+0x5ac>
    uint32_t part_entry_cnt = block_size / PARTITION_ENTRY_SIZE;
30005e8e:	9b11      	ldr	r3, [sp, #68]	; 0x44
        dprintf(CRITICAL,"%s Partition entires crc mismatch crc_val= 0x%08x with crc_val_org= 0x%08x\n",__func__,
                crc_val,crc_val_org);
        return 1;
    }

    gpt_header->entry_array_crc32 = crc_val;
30005e90:	990f      	ldr	r1, [sp, #60]	; 0x3c
30005e92:	658c      	str	r4, [r1, #88]	; 0x58
    uint32_t part_entry_cnt = block_size / PARTITION_ENTRY_SIZE;
30005e94:	09da      	lsrs	r2, r3, #7
    partition_entries = gpt_header->partition_entries;

    /* Read GPT Entries */
    for (i = 0;
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
30005e96:	1e53      	subs	r3, r2, #1
    uint32_t part_entry_cnt = block_size / PARTITION_ENTRY_SIZE;
30005e98:	9212      	str	r2, [sp, #72]	; 0x48
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
30005e9a:	441d      	add	r5, r3
30005e9c:	4253      	negs	r3, r2
30005e9e:	402b      	ands	r3, r5
30005ea0:	9317      	str	r3, [sp, #92]	; 0x5c
30005ea2:	fbb3 f3f2 	udiv	r3, r3, r2
    partition_entries = gpt_header->partition_entries;
30005ea6:	6dca      	ldr	r2, [r1, #92]	; 0x5c
30005ea8:	9214      	str	r2, [sp, #80]	; 0x50
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
30005eaa:	9313      	str	r3, [sp, #76]	; 0x4c
    for (i = 0;
30005eac:	2b00      	cmp	r3, #0
30005eae:	f000 81bf 	beq.w	30006230 <parse_gpt_table_from_buffer+0x5c4>
30005eb2:	9a12      	ldr	r2, [sp, #72]	; 0x48
30005eb4:	2300      	movs	r3, #0
            partition_entries[partition_count].attribute_flag =
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
                                                                      ATTRIBUTE_FLAG_OFFSET]);

            memset(&UTF16_name, 0x00, MAX_GPT_NAME_SIZE);
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
30005eb6:	af18      	add	r7, sp, #96	; 0x60
    for (i = 0;
30005eb8:	930e      	str	r3, [sp, #56]	; 0x38
    uint32_t partition_count = 0;
30005eba:	930c      	str	r3, [sp, #48]	; 0x30
30005ebc:	01d2      	lsls	r2, r2, #7
30005ebe:	9215      	str	r2, [sp, #84]	; 0x54
        data = (new_buffer + (i * block_size));
30005ec0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
30005ec2:	e9dd 1210 	ldrd	r1, r2, [r13, #64]	; 0x40
30005ec6:	fb02 1603 	mla	r6, r2, r3, r1
        for (j = 0; j < part_entry_cnt; j++) {
30005eca:	9b12      	ldr	r3, [sp, #72]	; 0x48
30005ecc:	2b00      	cmp	r3, #0
30005ece:	f000 8185 	beq.w	300061dc <parse_gpt_table_from_buffer+0x570>
30005ed2:	9a15      	ldr	r2, [sp, #84]	; 0x54
30005ed4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
30005ed6:	18b2      	adds	r2, r6, r2
30005ed8:	920d      	str	r2, [sp, #52]	; 0x34
30005eda:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
30005ede:	9a14      	ldr	r2, [sp, #80]	; 0x50
30005ee0:	eb02 1303 	add.w	r3, r2, r3, lsl #4
30005ee4:	9305      	str	r3, [sp, #20]
            memcpy(&(partition_entries[partition_count].type_guid),
30005ee6:	6832      	ldr	r2, [r6, #0]
30005ee8:	9b05      	ldr	r3, [sp, #20]
30005eea:	6870      	ldr	r0, [r6, #4]
30005eec:	68b1      	ldr	r1, [r6, #8]
30005eee:	68f4      	ldr	r4, [r6, #12]
30005ef0:	60dc      	str	r4, [r3, #12]
30005ef2:	601a      	str	r2, [r3, #0]
            if (partition_entries[partition_count].type_guid[0] ==
30005ef4:	881a      	ldrh	r2, [r3, #0]
            memcpy(&(partition_entries[partition_count].type_guid),
30005ef6:	6058      	str	r0, [r3, #4]
30005ef8:	6099      	str	r1, [r3, #8]
            if (partition_entries[partition_count].type_guid[0] ==
30005efa:	2a00      	cmp	r2, #0
30005efc:	f000 8189 	beq.w	30006212 <parse_gpt_table_from_buffer+0x5a6>
            memcpy(&(partition_entries[partition_count].unique_partition_guid),
30005f00:	4635      	mov	r5, r6
30005f02:	f103 0910 	add.w	r9, r3, #16
30005f06:	9c05      	ldr	r4, [sp, #20]
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
30005f08:	2248      	movs	r2, #72	; 0x48
            memcpy(&(partition_entries[partition_count].unique_partition_guid),
30005f0a:	f855 8f10 	ldr.w	r8, [r5, #16]!
30005f0e:	f8d5 e004 	ldr.w	r14, [r5, #4]
30005f12:	f8d5 c008 	ldr.w	r12, [r5, #8]
30005f16:	68ed      	ldr	r5, [r5, #12]
30005f18:	f8c4 8010 	str.w	r8, [r4, #16]
30005f1c:	f8c9 e004 	str.w	r14, [r9, #4]
30005f20:	f8c9 c008 	str.w	r12, [r9, #8]
30005f24:	f8c9 500c 	str.w	r5, [r9, #12]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
30005f28:	f896 8021 	ldrb.w	r8, [r6, #33]	; 0x21
30005f2c:	f896 4022 	ldrb.w	r4, [r6, #34]	; 0x22
30005f30:	ea4f 6118 	mov.w	r1, r8, lsr #24
30005f34:	ea4f 4b14 	mov.w	r11, r4, lsr #16
30005f38:	f896 3026 	ldrb.w	r3, [r6, #38]	; 0x26
30005f3c:	ea41 090b 	orr.w	r9, r1, r11
30005f40:	ea4f 4a04 	mov.w	r10, r4, lsl #16
30005f44:	f896 4023 	ldrb.w	r4, [r6, #35]	; 0x23
30005f48:	0a21      	lsrs	r1, r4, #8
30005f4a:	0624      	lsls	r4, r4, #24
30005f4c:	9103      	str	r1, [sp, #12]
30005f4e:	ea4f 2008 	mov.w	r0, r8, lsl #8
30005f52:	9402      	str	r4, [sp, #8]
30005f54:	ea40 080a 	orr.w	r8, r0, r10
30005f58:	f04f 0b00 	mov.w	r11, #0
30005f5c:	f896 a020 	ldrb.w	r10, [r6, #32]
30005f60:	ea49 010b 	orr.w	r1, r9, r11
30005f64:	f896 4025 	ldrb.w	r4, [r6, #37]	; 0x25
30005f68:	ea48 000a 	orr.w	r0, r8, r10
30005f6c:	e9dd 8902 	ldrd	r8, r9, [r13, #8]
30005f70:	ea48 0800 	orr.w	r8, r8, r0
30005f74:	ea49 0901 	orr.w	r9, r9, r1
30005f78:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
30005f7c:	9103      	str	r1, [sp, #12]
30005f7e:	2100      	movs	r1, #0
30005f80:	e9cd 8906 	strd	r8, r9, [r13, #24]
30005f84:	ea4f 2904 	mov.w	r9, r4, lsl #8
30005f88:	9102      	str	r1, [sp, #8]
30005f8a:	2400      	movs	r4, #0
30005f8c:	e9dd ab02 	ldrd	r10, r11, [r13, #8]
30005f90:	e9cd 3408 	strd	r3, r4, [r13, #32]
30005f94:	4650      	mov	r0, r10
30005f96:	e9dd 3406 	ldrd	r3, r4, [r13, #24]
30005f9a:	4659      	mov	r1, r11
30005f9c:	46d0      	mov	r8, r10
30005f9e:	4303      	orrs	r3, r0
30005fa0:	4618      	mov	r0, r3
30005fa2:	430c      	orrs	r4, r1
30005fa4:	9b08      	ldr	r3, [sp, #32]
30005fa6:	4621      	mov	r1, r4
30005fa8:	2400      	movs	r4, #0
30005faa:	ea4f 4b03 	mov.w	r11, r3, lsl #16
30005fae:	f896 3027 	ldrb.w	r3, [r6, #39]	; 0x27
30005fb2:	e9cd 3406 	strd	r3, r4, [r13, #24]
30005fb6:	ea40 0308 	orr.w	r3, r0, r8
30005fba:	9d06      	ldr	r5, [sp, #24]
30005fbc:	ea41 0409 	orr.w	r4, r1, r9
30005fc0:	4618      	mov	r0, r3
30005fc2:	4621      	mov	r1, r4
30005fc4:	e9dd 3402 	ldrd	r3, r4, [r13, #8]
30005fc8:	ea41 010b 	orr.w	r1, r1, r11
30005fcc:	ea4f 6905 	mov.w	r9, r5, lsl #24
30005fd0:	4318      	orrs	r0, r3
30005fd2:	4303      	orrs	r3, r0
30005fd4:	4698      	mov	r8, r3
30005fd6:	ea41 0409 	orr.w	r4, r1, r9
            partition_entries[partition_count].first_lba =
30005fda:	9905      	ldr	r1, [sp, #20]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
30005fdc:	46a1      	mov	r9, r4
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
30005fde:	2400      	movs	r4, #0
            partition_entries[partition_count].first_lba =
30005fe0:	e9cd 8908 	strd	r8, r9, [r13, #32]
30005fe4:	e9c1 8908 	strd	r8, r9, [r1, #32]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
30005fe8:	f896 002a 	ldrb.w	r0, [r6, #42]	; 0x2a
30005fec:	f896 8029 	ldrb.w	r8, [r6, #41]	; 0x29
30005ff0:	0c03      	lsrs	r3, r0, #16
30005ff2:	ea4f 6b18 	mov.w	r11, r8, lsr #24
30005ff6:	9307      	str	r3, [sp, #28]
30005ff8:	0403      	lsls	r3, r0, #16
30005ffa:	2100      	movs	r1, #0
30005ffc:	ea4f 2a08 	mov.w	r10, r8, lsl #8
30006000:	9306      	str	r3, [sp, #24]
30006002:	f896 0028 	ldrb.w	r0, [r6, #40]	; 0x28
30006006:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
3000600a:	f896 302b 	ldrb.w	r3, [r6, #43]	; 0x2b
3000600e:	e9cd 340a 	strd	r3, r4, [r13, #40]	; 0x28
30006012:	ea48 080a 	orr.w	r8, r8, r10
30006016:	ea49 090b 	orr.w	r9, r9, r11
3000601a:	ea40 0a08 	orr.w	r10, r0, r8
3000601e:	ea41 0b09 	orr.w	r11, r1, r9
30006022:	e9cd ab06 	strd	r10, r11, [r13, #24]
30006026:	e9dd 9a0a 	ldrd	r9, r10, [r13, #40]	; 0x28
3000602a:	f896 a02d 	ldrb.w	r10, [r6, #45]	; 0x2d
3000602e:	4649      	mov	r1, r9
30006030:	ea4f 290a 	mov.w	r9, r10, lsl #8
30006034:	0a0d      	lsrs	r5, r1, #8
30006036:	060c      	lsls	r4, r1, #24
30006038:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
3000603c:	4320      	orrs	r0, r4
3000603e:	2400      	movs	r4, #0
30006040:	4329      	orrs	r1, r5
30006042:	ea44 0a00 	orr.w	r10, r4, r0
30006046:	f896 502c 	ldrb.w	r5, [r6, #44]	; 0x2c
3000604a:	f896 002e 	ldrb.w	r0, [r6, #46]	; 0x2e
3000604e:	ea45 0b01 	orr.w	r11, r5, r1
30006052:	0401      	lsls	r1, r0, #16
30006054:	f896 002f 	ldrb.w	r0, [r6, #47]	; 0x2f
30006058:	e9cd ab06 	strd	r10, r11, [r13, #24]
3000605c:	e9dd ab02 	ldrd	r10, r11, [r13, #8]
30006060:	9103      	str	r1, [sp, #12]
30006062:	2100      	movs	r1, #0
30006064:	e9dd 4506 	ldrd	r4, r5, [r13, #24]
30006068:	f8cd a008 	str.w	r10, [r13, #8]
3000606c:	e9cd 0106 	strd	r0, r1, [r13, #24]
30006070:	ea44 040a 	orr.w	r4, r4, r10
30006074:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
30006078:	ea45 0509 	orr.w	r5, r5, r9
3000607c:	9b06      	ldr	r3, [sp, #24]
3000607e:	4320      	orrs	r0, r4
30006080:	4604      	mov	r4, r0
30006082:	4329      	orrs	r1, r5
30006084:	460d      	mov	r5, r1
30006086:	ea4f 6903 	mov.w	r9, r3, lsl #24
3000608a:	e9cd ab02 	strd	r10, r11, [r13, #8]
3000608e:	ea4a 0a04 	orr.w	r10, r10, r4
30006092:	ea49 0b05 	orr.w	r11, r9, r5
            partition_entries[partition_count].last_lba =
30006096:	9d05      	ldr	r5, [sp, #20]
                partition_entries[partition_count].first_lba + 1;
30006098:	f11a 0801 	adds.w	r8, r10, #1
            partition_entries[partition_count].last_lba =
3000609c:	e9c5 ab0a 	strd	r10, r11, [r5, #40]	; 0x28
                partition_entries[partition_count].first_lba + 1;
300060a0:	f14b 0900 	adc.w	r9, r11, #0
300060a4:	e9dd ab08 	ldrd	r10, r11, [r13, #32]
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
300060a8:	f106 0138 	add.w	r1, r6, #56	; 0x38
300060ac:	4638      	mov	r0, r7
                partition_entries[partition_count].first_lba + 1;
300060ae:	ebb8 0a0a 	subs.w	r10, r8, r10
300060b2:	46d0      	mov	r8, r10
300060b4:	eb69 0b0b 	sbc.w	r11, r9, r11
300060b8:	46d9      	mov	r9, r11
            partition_entries[partition_count].size =
300060ba:	e9c5 8922 	strd	r8, r9, [r5, #136]	; 0x88
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
300060be:	2500      	movs	r5, #0
300060c0:	f896 8031 	ldrb.w	r8, [r6, #49]	; 0x31
300060c4:	f896 4032 	ldrb.w	r4, [r6, #50]	; 0x32
300060c8:	e9cd 4508 	strd	r4, r5, [r13, #32]
300060cc:	ea4f 6318 	mov.w	r3, r8, lsr #24
300060d0:	2500      	movs	r5, #0
300060d2:	ea4f 4b14 	mov.w	r11, r4, lsr #16
300060d6:	9307      	str	r3, [sp, #28]
300060d8:	ea4f 2408 	mov.w	r4, r8, lsl #8
300060dc:	9406      	str	r4, [sp, #24]
300060de:	9c08      	ldr	r4, [sp, #32]
300060e0:	ea4f 4a04 	mov.w	r10, r4, lsl #16
300060e4:	f896 4033 	ldrb.w	r4, [r6, #51]	; 0x33
300060e8:	e9cd 450a 	strd	r4, r5, [r13, #40]	; 0x28
300060ec:	e9dd 4506 	ldrd	r4, r5, [r13, #24]
300060f0:	ea45 050b 	orr.w	r5, r5, r11
300060f4:	f04f 0b00 	mov.w	r11, #0
300060f8:	ea44 040a 	orr.w	r4, r4, r10
300060fc:	ea45 090b 	orr.w	r9, r5, r11
30006100:	f896 a030 	ldrb.w	r10, [r6, #48]	; 0x30
30006104:	e9dd bc0a 	ldrd	r11, r12, [r13, #40]	; 0x28
30006108:	ea44 080a 	orr.w	r8, r4, r10
3000610c:	465c      	mov	r4, r11
3000610e:	f896 c034 	ldrb.w	r12, [r6, #52]	; 0x34
30006112:	e9cd 8908 	strd	r8, r9, [r13, #32]
30006116:	0a23      	lsrs	r3, r4, #8
30006118:	9307      	str	r3, [sp, #28]
3000611a:	0623      	lsls	r3, r4, #24
3000611c:	e9dd 4508 	ldrd	r4, r5, [r13, #32]
30006120:	9306      	str	r3, [sp, #24]
30006122:	e9dd 8906 	ldrd	r8, r9, [r13, #24]
30006126:	ea48 0804 	orr.w	r8, r8, r4
3000612a:	4644      	mov	r4, r8
3000612c:	ea49 0905 	orr.w	r9, r9, r5
30006130:	464d      	mov	r5, r9
30006132:	f896 8035 	ldrb.w	r8, [r6, #53]	; 0x35
30006136:	e9cd 4508 	strd	r4, r5, [r13, #32]
3000613a:	9c02      	ldr	r4, [sp, #8]
3000613c:	46a2      	mov	r10, r4
3000613e:	ea4f 2408 	mov.w	r4, r8, lsl #8
30006142:	f8dd 8008 	ldr.w	r8, [r13, #8]
30006146:	9407      	str	r4, [sp, #28]
30006148:	e9dd 4508 	ldrd	r4, r5, [r13, #32]
3000614c:	ea4c 0b05 	orr.w	r11, r12, r5
30006150:	2500      	movs	r5, #0
30006152:	ea4a 0a04 	orr.w	r10, r10, r4
30006156:	f896 4036 	ldrb.w	r4, [r6, #54]	; 0x36
3000615a:	e9cd 4508 	strd	r4, r5, [r13, #32]
3000615e:	9c02      	ldr	r4, [sp, #8]
30006160:	9406      	str	r4, [sp, #24]
30006162:	9c08      	ldr	r4, [sp, #32]
30006164:	ea4f 4904 	mov.w	r9, r4, lsl #16
30006168:	e9dd 4506 	ldrd	r4, r5, [r13, #24]
3000616c:	ea45 050b 	orr.w	r5, r5, r11
30006170:	46ab      	mov	r11, r5
30006172:	2500      	movs	r5, #0
30006174:	ea44 040a 	orr.w	r4, r4, r10
30006178:	46a2      	mov	r10, r4
3000617a:	f896 4037 	ldrb.w	r4, [r6, #55]	; 0x37
3000617e:	e9cd 4508 	strd	r4, r5, [r13, #32]
30006182:	ea4b 0509 	orr.w	r5, r11, r9
30006186:	9b08      	ldr	r3, [sp, #32]
30006188:	ea4a 0408 	orr.w	r4, r10, r8
3000618c:	e9dd 8902 	ldrd	r8, r9, [r13, #8]
30006190:	46a2      	mov	r10, r4
30006192:	f8cd 8018 	str.w	r8, [r13, #24]
30006196:	061b      	lsls	r3, r3, #24
30006198:	9307      	str	r3, [sp, #28]
3000619a:	e9dd 3406 	ldrd	r3, r4, [r13, #24]
3000619e:	ea43 030a 	orr.w	r3, r3, r10
300061a2:	469a      	mov	r10, r3
300061a4:	432c      	orrs	r4, r5
            partition_entries[partition_count].attribute_flag =
300061a6:	9d05      	ldr	r5, [sp, #20]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
300061a8:	46a3      	mov	r11, r4
            partition_entries[partition_count].attribute_flag =
300061aa:	e9c5 ab0c 	strd	r10, r11, [r5, #48]	; 0x30
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
300061ae:	f00e eb5a 	blx	30014864 <memcpy>

            /*
             * Currently partition names in *.xml are UTF-8 and lowercase
             * Only supporting english for now so removing 2nd byte of UTF-16
             */
            for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
300061b2:	4642      	mov	r2, r8
300061b4:	462b      	mov	r3, r5
300061b6:	f105 0137 	add.w	r1, r5, #55	; 0x37
                partition_entries[partition_count].name[n] =
300061ba:	f817 0012 	ldrb.w	r0, [r7, r2, lsl #1]
300061be:	f801 0f01 	strb.w	r0, [r1, #1]!
            for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
300061c2:	3201      	adds	r2, #1
300061c4:	2a24      	cmp	r2, #36	; 0x24
300061c6:	d1f8      	bne.n	300061ba <parse_gpt_table_from_buffer+0x54e>
                    UTF16_name[n * 2];
            }

            partition_count++;
300061c8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
300061ca:	3390      	adds	r3, #144	; 0x90
300061cc:	3680      	adds	r6, #128	; 0x80
300061ce:	9305      	str	r3, [sp, #20]
300061d0:	3201      	adds	r2, #1
        for (j = 0; j < part_entry_cnt; j++) {
300061d2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
            partition_count++;
300061d4:	920c      	str	r2, [sp, #48]	; 0x30
        for (j = 0; j < part_entry_cnt; j++) {
300061d6:	429e      	cmp	r6, r3
300061d8:	f47f ae85 	bne.w	30005ee6 <parse_gpt_table_from_buffer+0x27a>
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
300061dc:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    for (i = 0;
300061de:	9a13      	ldr	r2, [sp, #76]	; 0x4c
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
300061e0:	3301      	adds	r3, #1
    for (i = 0;
300061e2:	4293      	cmp	r3, r2
            i < (ROUNDUP(max_partition_count, part_entry_cnt)) / part_entry_cnt; i++) {
300061e4:	930e      	str	r3, [sp, #56]	; 0x38
    for (i = 0;
300061e6:	d224      	bcs.n	30006232 <parse_gpt_table_from_buffer+0x5c6>
        ASSERT(partition_count < NUM_PARTITIONS);
300061e8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
300061ea:	2b7f      	cmp	r3, #127	; 0x7f
300061ec:	f67f ae68 	bls.w	30005ec0 <parse_gpt_table_from_buffer+0x254>
300061f0:	f24c 63b8 	movw	r3, #50872	; 0xc6b8
300061f4:	f24c 42f0 	movw	r2, #50416	; 0xc4f0
300061f8:	f24a 011c 	movw	r1, #40988	; 0xa01c
300061fc:	f2c3 0301 	movt	r3, #12289	; 0x3001
30006200:	9816      	ldr	r0, [sp, #88]	; 0x58
30006202:	f2c3 0201 	movt	r2, #12289	; 0x3001
30006206:	9300      	str	r3, [sp, #0]
30006208:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000620c:	23f4      	movs	r3, #244	; 0xf4
3000620e:	f00e f801 	bl	30014214 <_panic>
            if (partition_entries[partition_count].type_guid[0] ==
30006212:	9b17      	ldr	r3, [sp, #92]	; 0x5c
30006214:	930e      	str	r3, [sp, #56]	; 0x38
30006216:	e7e1      	b.n	300061dc <parse_gpt_table_from_buffer+0x570>
        dprintf(CRITICAL,"%s Partition entires crc mismatch crc_val= 0x%08x with crc_val_org= 0x%08x\n",__func__,
30006218:	f24c 31a4 	movw	r1, #50084	; 0xc3a4
3000621c:	f24c 606c 	movw	r0, #50796	; 0xc66c
30006220:	4623      	mov	r3, r4
30006222:	f2c3 0101 	movt	r1, #12289	; 0x3001
30006226:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000622a:	f00f fcc1 	bl	30015bb0 <_printf>
3000622e:	e55c      	b.n	30005cea <parse_gpt_table_from_buffer+0x7e>
    uint32_t partition_count = 0;
30006230:	930c      	str	r3, [sp, #48]	; 0x30
        }
    }

    gpt_header->actual_entries_count = partition_count;
30006232:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    return 0;
30006234:	2000      	movs	r0, #0
    gpt_header->actual_entries_count = partition_count;
30006236:	461a      	mov	r2, r3
30006238:	9b0c      	ldr	r3, [sp, #48]	; 0x30
3000623a:	6613      	str	r3, [r2, #96]	; 0x60
}
3000623c:	b02b      	add	sp, #172	; 0xac
3000623e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "Invalid maximum partition count\n");
30006242:	f24c 6024 	movw	r0, #50724	; 0xc624
30006246:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000624a:	f00f fcb1 	bl	30015bb0 <_printf>
3000624e:	e541      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
        dprintf(CRITICAL, "Invalid parition entry size\n");
30006250:	f24c 6004 	movw	r0, #50692	; 0xc604
30006254:	f2c3 0001 	movt	r0, #12289	; 0x3001
30006258:	f00f fcaa 	bl	30015bb0 <_printf>
3000625c:	e53a      	b.n	30005cd4 <parse_gpt_table_from_buffer+0x68>
3000625e:	bf00      	nop

30006260 <gpt_partition_round>:
    return info;
}

uint32_t gpt_partition_round(uint8_t *buffer, uint32_t buf_len,
                             uint32_t block_size, uint32_t sector_sz, uint64_t capacity)
{
30006260:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30006264:	460d      	mov	r5, r1
30006266:	b0cb      	sub	sp, #300	; 0x12c
    uint32_t crc_val = 0;
    uint64_t size_in_lba = 0;
    uint64_t patch_size = 0;
    uint8_t *primary_header = NULL;
    uint8_t *secondary_header = NULL;
    GPT_header gpt_header_pri = {0};
30006268:	2100      	movs	r1, #0
{
3000626a:	4693      	mov	r11, r2
3000626c:	9008      	str	r0, [sp, #32]
    GPT_header gpt_header_pri = {0};
3000626e:	2268      	movs	r2, #104	; 0x68
{
30006270:	4698      	mov	r8, r3
    GPT_header gpt_header_pri = {0};
30006272:	a816      	add	r0, sp, #88	; 0x58
30006274:	f00e eb7c 	blx	30014970 <memset>
    GPT_header gpt_header_bak = {0};
30006278:	2268      	movs	r2, #104	; 0x68
3000627a:	2100      	movs	r1, #0
3000627c:	a830      	add	r0, sp, #192	; 0xc0
3000627e:	f00e eb78 	blx	30014970 <memset>
    uint32_t gpt_in_sector;

    blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries) * block_size;

    if (buf_len < GPT_HEADER_SIZE * 2 + MIN_PARTITION_ARRAY_SIZE * 2
30006282:	f248 03b7 	movw	r3, #32951	; 0x80b7
30006286:	429d      	cmp	r5, r3
30006288:	d935      	bls.n	300062f6 <gpt_partition_round+0x96>
    blocks_for_entries = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
3000628a:	f44f 4480 	mov.w	r4, #16384	; 0x4000
3000628e:	fbb4 f4fb 	udiv	r4, r4, r11
    gpt_sz = (GPT_HEADER_BLOCKS + blocks_for_entries) * block_size;
30006292:	3401      	adds	r4, #1
30006294:	fb0b f404 	mul.w	r4, r11, r4
            || buf_len < gpt_sz * 2) {
30006298:	ebb5 0f44 	cmp.w	r5, r4, lsl #1
3000629c:	d32b      	bcc.n	300062f6 <gpt_partition_round+0x96>
        dprintf(CRITICAL, "%s ptb buffer len:%u error!\n", __func__, buf_len);
        return 1;
    }

    if (!capacity || capacity % block_size != 0) {
3000629e:	ab54      	add	r3, sp, #336	; 0x150
300062a0:	e9d3 2300 	ldrd	r2, r3, [r3]
300062a4:	4313      	orrs	r3, r2
300062a6:	d037      	beq.n	30006318 <gpt_partition_round+0xb8>
300062a8:	2300      	movs	r3, #0
300062aa:	a954      	add	r1, sp, #336	; 0x150
300062ac:	465a      	mov	r2, r11
300062ae:	e9d1 0100 	ldrd	r0, r1, [r1]
300062b2:	f013 fdb5 	bl	30019e20 <__aeabi_uldivmod>
300062b6:	4616      	mov	r6, r2
300062b8:	461f      	mov	r7, r3
300062ba:	ea56 0307 	orrs.w	r3, r6, r7
300062be:	d12b      	bne.n	30006318 <gpt_partition_round+0xb8>
        dprintf(CRITICAL, "%s capacity:%llu error, block_size:%u!\n", __func__, capacity, block_size);
        return 1;
    }

    if (!sector_sz || sector_sz % block_size != 0) {
300062c0:	f1b8 0f00 	cmp.w	r8, #0
300062c4:	d005      	beq.n	300062d2 <gpt_partition_round+0x72>
300062c6:	fbb8 f3fb 	udiv	r3, r8, r11
300062ca:	fb0b 8313 	mls	r3, r11, r3, r8
300062ce:	2b00      	cmp	r3, #0
300062d0:	d037      	beq.n	30006342 <gpt_partition_round+0xe2>
        dprintf(CRITICAL, "%s sector_sz:%u error, block_size:%u!\n", __func__, sector_sz, block_size);
300062d2:	f24c 31b0 	movw	r1, #50096	; 0xc3b0
300062d6:	f24c 400c 	movw	r0, #50188	; 0xc40c
300062da:	465b      	mov	r3, r11
300062dc:	4642      	mov	r2, r8
300062de:	f2c3 0101 	movt	r1, #12289	; 0x3001
300062e2:	f2c3 0001 	movt	r0, #12289	; 0x3001
300062e6:	f00f fc63 	bl	30015bb0 <_printf>
        return 1;
300062ea:	2301      	movs	r3, #1
300062ec:	9305      	str	r3, [sp, #20]

    if (gpt_header_bak.partition_entries) {
        free(gpt_header_bak.partition_entries);
    }
    return ret;
}
300062ee:	9805      	ldr	r0, [sp, #20]
300062f0:	b04b      	add	sp, #300	; 0x12c
300062f2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "%s ptb buffer len:%u error!\n", __func__, buf_len);
300062f6:	f24c 31b0 	movw	r1, #50096	; 0xc3b0
300062fa:	f24c 30c4 	movw	r0, #50116	; 0xc3c4
300062fe:	462a      	mov	r2, r5
30006300:	f2c3 0101 	movt	r1, #12289	; 0x3001
30006304:	f2c3 0001 	movt	r0, #12289	; 0x3001
30006308:	f00f fc52 	bl	30015bb0 <_printf>
        return 1;
3000630c:	2301      	movs	r3, #1
3000630e:	9305      	str	r3, [sp, #20]
}
30006310:	9805      	ldr	r0, [sp, #20]
30006312:	b04b      	add	sp, #300	; 0x12c
30006314:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "%s capacity:%llu error, block_size:%u!\n", __func__, capacity, block_size);
30006318:	f24c 31b0 	movw	r1, #50096	; 0xc3b0
3000631c:	ab54      	add	r3, sp, #336	; 0x150
3000631e:	f24c 30e4 	movw	r0, #50148	; 0xc3e4
30006322:	f2c3 0101 	movt	r1, #12289	; 0x3001
30006326:	f8cd b000 	str.w	r11, [r13]
3000632a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000632e:	e9d3 2300 	ldrd	r2, r3, [r3]
30006332:	f00f fc3d 	bl	30015bb0 <_printf>
        return 1;
30006336:	2301      	movs	r3, #1
30006338:	9305      	str	r3, [sp, #20]
}
3000633a:	9805      	ldr	r0, [sp, #20]
3000633c:	b04b      	add	sp, #300	; 0x12c
3000633e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ret = parse_gpt_table_from_buffer(buffer, buf_len - gpt_sz, &gpt_header_pri, block_size, false);
30006342:	f8dd a020 	ldr.w	r10, [r13, #32]
30006346:	1b2d      	subs	r5, r5, r4
30006348:	9300      	str	r3, [sp, #0]
3000634a:	aa16      	add	r2, sp, #88	; 0x58
3000634c:	4629      	mov	r1, r5
3000634e:	465b      	mov	r3, r11
30006350:	4650      	mov	r0, r10
30006352:	f7ff fc8b 	bl	30005c6c <parse_gpt_table_from_buffer>
    ret |= parse_gpt_table_from_buffer(buffer + gpt_sz, buf_len - gpt_sz, &gpt_header_bak, block_size, true);
30006356:	465b      	mov	r3, r11
30006358:	4629      	mov	r1, r5
3000635a:	aa30      	add	r2, sp, #192	; 0xc0
    ret = parse_gpt_table_from_buffer(buffer, buf_len - gpt_sz, &gpt_header_pri, block_size, false);
3000635c:	4681      	mov	r9, r0
    ret |= parse_gpt_table_from_buffer(buffer + gpt_sz, buf_len - gpt_sz, &gpt_header_bak, block_size, true);
3000635e:	2001      	movs	r0, #1
30006360:	9000      	str	r0, [sp, #0]
30006362:	4650      	mov	r0, r10
30006364:	4420      	add	r0, r4
30006366:	f7ff fc81 	bl	30005c6c <parse_gpt_table_from_buffer>
    if (ret) {
3000636a:	ea59 0300 	orrs.w	r3, r9, r0
3000636e:	9305      	str	r3, [sp, #20]
30006370:	f040 8265 	bne.w	3000683e <gpt_partition_round+0x5de>
    gpt_in_sector = round_up(gpt_sz, sector_sz);
30006374:	2300      	movs	r3, #0
30006376:	2500      	movs	r5, #0
30006378:	4642      	mov	r2, r8
    if (aligned == 0 || size < aligned)
3000637a:	429d      	cmp	r5, r3
3000637c:	bf08      	it	eq
3000637e:	4544      	cmpeq	r4, r8
30006380:	e9cd 2306 	strd	r2, r3, [r13, #24]
30006384:	f0c0 8258 	bcc.w	30006838 <gpt_partition_round+0x5d8>
    mod = size % aligned;
30006388:	4620      	mov	r0, r4
3000638a:	4629      	mov	r1, r5
3000638c:	f013 fd48 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30006390:	ea52 0103 	orrs.w	r1, r2, r3
30006394:	d003      	beq.n	3000639e <gpt_partition_round+0x13e>
30006396:	eb18 0004 	adds.w	r0, r8, r4
3000639a:	1a80      	subs	r0, r0, r2
3000639c:	4604      	mov	r4, r0
        GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
3000639e:	9808      	ldr	r0, [sp, #32]
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300063a0:	992e      	ldr	r1, [sp, #184]	; 0xb8
        GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
300063a2:	6d42      	ldr	r2, [r0, #84]	; 0x54
        GET_LWORD_FROM_BYTE(&buffer[PARTITION_COUNT_OFFSET]);
300063a4:	6d03      	ldr	r3, [r0, #80]	; 0x50
        GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
300063a6:	920f      	str	r2, [sp, #60]	; 0x3c
    partition_entry_array_size = partition_entry_size * max_partition_count;
300063a8:	fb02 f303 	mul.w	r3, r2, r3
300063ac:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
300063b0:	9313      	str	r3, [sp, #76]	; 0x4c
300063b2:	bf38      	it	cc
300063b4:	f44f 4380 	movcc.w	r3, #16384	; 0x4000
    secondary_header = buffer + block_size + offset;
300063b8:	eb0b 0243 	add.w	r2, r11, r3, lsl #1
300063bc:	4410      	add	r0, r2
300063be:	9012      	str	r0, [sp, #72]	; 0x48
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300063c0:	2900      	cmp	r1, #0
300063c2:	f000 81d2 	beq.w	3000676a <gpt_partition_round+0x50a>
300063c6:	9908      	ldr	r1, [sp, #32]
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
300063c8:	f50d 7ca8 	add.w	r12, r13, #336	; 0x150
        dprintf(CRITICAL, "%s %d first_lba:%llu last_lba:%llu\n",
300063cc:	f24c 30b0 	movw	r0, #50096	; 0xc3b0
300063d0:	1ad3      	subs	r3, r2, r3
300063d2:	460a      	mov	r2, r1
300063d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
300063d8:	e9dc 8900 	ldrd	r8, r9, [r12]
300063dc:	445a      	add	r2, r11
300063de:	9315      	str	r3, [sp, #84]	; 0x54
300063e0:	18cd      	adds	r5, r1, r3
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300063e2:	2300      	movs	r3, #0
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
300063e4:	ebb8 0804 	subs.w	r8, r8, r4
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300063e8:	f8cd b024 	str.w	r11, [r13, #36]	; 0x24
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
300063ec:	f169 0900 	sbc.w	r9, r9, #0
300063f0:	9214      	str	r2, [sp, #80]	; 0x50
300063f2:	4614      	mov	r4, r2
300063f4:	e9cd 8910 	strd	r8, r9, [r13, #64]	; 0x40
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300063f8:	469b      	mov	r11, r3
        dprintf(CRITICAL, "%s %d first_lba:%llu last_lba:%llu\n",
300063fa:	900e      	str	r0, [sp, #56]	; 0x38
300063fc:	e06b      	b.n	300064d6 <gpt_partition_round+0x276>
        entry->last_lba = size_in_lba + entry->first_lba - 1;
300063fe:	e9ca 670a 	strd	r6, r7, [r10, #40]	; 0x28
        if ( i == gpt_header_pri.actual_entries_count - 1) {
30006402:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
30006404:	3b01      	subs	r3, #1
30006406:	455b      	cmp	r3, r11
30006408:	f000 8125 	beq.w	30006656 <gpt_partition_round+0x3f6>
3000640c:	e9da 230a 	ldrd	r2, r3, [r10, #40]	; 0x28
        if (entry->last_lba <= entry->first_lba) {
30006410:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30006414:	4299      	cmp	r1, r3
30006416:	bf08      	it	eq
30006418:	4290      	cmpeq	r0, r2
3000641a:	f080 8176 	bcs.w	3000670a <gpt_partition_round+0x4aa>
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
3000641e:	f884 2028 	strb.w	r2, [r4, #40]	; 0x28
        dprintf(CRITICAL, "%s %d after patch first_lba:%llu last_lba:%llu\n",
30006422:	f24c 40c0 	movw	r0, #50368	; 0xc4c0
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
30006426:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
        dprintf(CRITICAL, "%s %d after patch first_lba:%llu last_lba:%llu\n",
3000642a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000642e:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
30006430:	f240 12fb 	movw	r2, #507	; 0x1fb
30006434:	990e      	ldr	r1, [sp, #56]	; 0x38
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
30006436:	f10b 0b01 	add.w	r11, r11, #1
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
3000643a:	0a1b      	lsrs	r3, r3, #8
3000643c:	f884 3029 	strb.w	r3, [r4, #41]	; 0x29
30006440:	f8ba 302a 	ldrh.w	r3, [r10, #42]	; 0x2a
30006444:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
30006448:	f89a 302b 	ldrb.w	r3, [r10, #43]	; 0x2b
3000644c:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
30006450:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
30006454:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
30006458:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
3000645c:	0a1b      	lsrs	r3, r3, #8
3000645e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
30006462:	f8ba 302e 	ldrh.w	r3, [r10, #46]	; 0x2e
30006466:	f884 302e 	strb.w	r3, [r4, #46]	; 0x2e
3000646a:	f89a 302f 	ldrb.w	r3, [r10, #47]	; 0x2f
3000646e:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
30006472:	4434      	add	r4, r6
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
30006474:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
30006478:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
3000647c:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
30006480:	0a1b      	lsrs	r3, r3, #8
30006482:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
30006486:	f8ba 302a 	ldrh.w	r3, [r10, #42]	; 0x2a
3000648a:	f885 302a 	strb.w	r3, [r5, #42]	; 0x2a
3000648e:	f89a 302b 	ldrb.w	r3, [r10, #43]	; 0x2b
30006492:	f885 302b 	strb.w	r3, [r5, #43]	; 0x2b
30006496:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
3000649a:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
3000649e:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
300064a2:	0a1b      	lsrs	r3, r3, #8
300064a4:	f885 302d 	strb.w	r3, [r5, #45]	; 0x2d
300064a8:	f8ba 302e 	ldrh.w	r3, [r10, #46]	; 0x2e
300064ac:	f885 302e 	strb.w	r3, [r5, #46]	; 0x2e
300064b0:	f89a 302f 	ldrb.w	r3, [r10, #47]	; 0x2f
300064b4:	f885 302f 	strb.w	r3, [r5, #47]	; 0x2f
300064b8:	4435      	add	r5, r6
        last_entry_last_lba = entry->last_lba;
300064ba:	e9da 670a 	ldrd	r6, r7, [r10, #40]	; 0x28
        dprintf(CRITICAL, "%s %d after patch first_lba:%llu last_lba:%llu\n",
300064be:	e9cd 6702 	strd	r6, r7, [r13, #8]
300064c2:	e9da 8908 	ldrd	r8, r9, [r10, #32]
300064c6:	e9cd 8900 	strd	r8, r9, [r13]
300064ca:	f00f fb71 	bl	30015bb0 <_printf>
    for (uint32_t i= 0; i < gpt_header_pri.actual_entries_count; i++) {
300064ce:	9b2e      	ldr	r3, [sp, #184]	; 0xb8
300064d0:	455b      	cmp	r3, r11
300064d2:	f240 814f 	bls.w	30006774 <gpt_partition_round+0x514>
        entry = &gpt_header_pri.partition_entries[i];
300064d6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
300064d8:	eb0b 0acb 	add.w	r10, r11, r11, lsl #3
        dprintf(CRITICAL, "%s %d first_lba:%llu last_lba:%llu\n",
300064dc:	f24c 4048 	movw	r0, #50248	; 0xc448
300064e0:	f44f 72e1 	mov.w	r2, #450	; 0x1c2
        entry = &gpt_header_pri.partition_entries[i];
300064e4:	eb03 1a0a 	add.w	r10, r3, r10, lsl #4
        dprintf(CRITICAL, "%s %d first_lba:%llu last_lba:%llu\n",
300064e8:	990e      	ldr	r1, [sp, #56]	; 0x38
300064ea:	f2c3 0001 	movt	r0, #12289	; 0x3001
300064ee:	e9da 890a 	ldrd	r8, r9, [r10, #40]	; 0x28
300064f2:	e9cd 8902 	strd	r8, r9, [r13, #8]
300064f6:	e9da 8908 	ldrd	r8, r9, [r10, #32]
300064fa:	e9cd 8900 	strd	r8, r9, [r13]
300064fe:	f00f fb57 	bl	30015bb0 <_printf>
        size_in_lba = entry->last_lba - entry->first_lba + 1;
30006502:	e9da 8908 	ldrd	r8, r9, [r10, #32]
30006506:	e9da 230a 	ldrd	r2, r3, [r10, #40]	; 0x28
3000650a:	ebb2 0208 	subs.w	r2, r2, r8
3000650e:	eb63 0309 	sbc.w	r3, r3, r9
30006512:	e9cd 230c 	strd	r2, r3, [r13, #48]	; 0x30
30006516:	3201      	adds	r2, #1
30006518:	f143 0300 	adc.w	r3, r3, #0
        if (entry->first_lba <= last_entry_last_lba)
3000651c:	454f      	cmp	r7, r9
        size_in_lba = entry->last_lba - entry->first_lba + 1;
3000651e:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
        if (entry->first_lba <= last_entry_last_lba)
30006522:	bf08      	it	eq
30006524:	4546      	cmpeq	r6, r8
30006526:	d305      	bcc.n	30006534 <gpt_partition_round+0x2d4>
            entry->first_lba = last_entry_last_lba + 1;
30006528:	f116 0801 	adds.w	r8, r6, #1
3000652c:	f147 0900 	adc.w	r9, r7, #0
30006530:	e9ca 8908 	strd	r8, r9, [r10, #32]
        if ((entry->first_lba * block_size) % sector_sz !=0 ) {
30006534:	9909      	ldr	r1, [sp, #36]	; 0x24
30006536:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
3000653a:	fba1 6708 	umull	r6, r7, r1, r8
3000653e:	4630      	mov	r0, r6
30006540:	fb01 7709 	mla	r7, r1, r9, r7
30006544:	4639      	mov	r1, r7
30006546:	f013 fc6b 	bl	30019e20 <__aeabi_uldivmod>
3000654a:	ea52 0103 	orrs.w	r1, r2, r3
3000654e:	d013      	beq.n	30006578 <gpt_partition_round+0x318>
    if (aligned == 0 || size < aligned)
30006550:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30006554:	428f      	cmp	r7, r1
30006556:	bf08      	it	eq
30006558:	4286      	cmpeq	r6, r0
3000655a:	f0c0 80e9 	bcc.w	30006730 <gpt_partition_round+0x4d0>
    size += mod ? aligned - mod : 0;
3000655e:	1980      	adds	r0, r0, r6
30006560:	4179      	adcs	r1, r7
30006562:	1a80      	subs	r0, r0, r2
30006564:	eb61 0103 	sbc.w	r1, r1, r3
            entry->first_lba = round_up(entry->first_lba * block_size, sector_sz) / block_size;
30006568:	9a09      	ldr	r2, [sp, #36]	; 0x24
3000656a:	2300      	movs	r3, #0
3000656c:	f013 fc58 	bl	30019e20 <__aeabi_uldivmod>
30006570:	4680      	mov	r8, r0
30006572:	4689      	mov	r9, r1
30006574:	e9ca 8908 	strd	r8, r9, [r10, #32]
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
30006578:	f884 8020 	strb.w	r8, [r4, #32]
3000657c:	f8da 3020 	ldr.w	r3, [r10, #32]
        patch_size = (size_in_lba * block_size) % sector_sz;
30006580:	e9dd 890a 	ldrd	r8, r9, [r13, #40]	; 0x28
30006584:	9a09      	ldr	r2, [sp, #36]	; 0x24
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
30006586:	0a1b      	lsrs	r3, r3, #8
30006588:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
3000658c:	f8ba 3022 	ldrh.w	r3, [r10, #34]	; 0x22
30006590:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
30006594:	f89a 3023 	ldrb.w	r3, [r10, #35]	; 0x23
30006598:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
3000659c:	f8da 3024 	ldr.w	r3, [r10, #36]	; 0x24
300065a0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
300065a4:	f8da 3024 	ldr.w	r3, [r10, #36]	; 0x24
        patch_size = (size_in_lba * block_size) % sector_sz;
300065a8:	fba2 0108 	umull	r0, r1, r2, r8
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
300065ac:	0a1b      	lsrs	r3, r3, #8
300065ae:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
300065b2:	f8ba 3026 	ldrh.w	r3, [r10, #38]	; 0x26
300065b6:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
300065ba:	f89a 3027 	ldrb.w	r3, [r10, #39]	; 0x27
300065be:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
300065c2:	f8da 3020 	ldr.w	r3, [r10, #32]
300065c6:	f885 3020 	strb.w	r3, [r5, #32]
300065ca:	f8da 3020 	ldr.w	r3, [r10, #32]
        patch_size = (size_in_lba * block_size) % sector_sz;
300065ce:	fb02 1109 	mla	r1, r2, r9, r1
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
300065d2:	0a1b      	lsrs	r3, r3, #8
300065d4:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
300065d8:	f8ba 3022 	ldrh.w	r3, [r10, #34]	; 0x22
300065dc:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
300065e0:	f89a 3023 	ldrb.w	r3, [r10, #35]	; 0x23
300065e4:	f885 3023 	strb.w	r3, [r5, #35]	; 0x23
300065e8:	f8da 3024 	ldr.w	r3, [r10, #36]	; 0x24
300065ec:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
300065f0:	f8da 6024 	ldr.w	r6, [r10, #36]	; 0x24
        patch_size = (size_in_lba * block_size) % sector_sz;
300065f4:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
        PUT_LONG_LONG(buffer + block_size + i * partition_entry_size +
300065f8:	0a36      	lsrs	r6, r6, #8
300065fa:	f885 6025 	strb.w	r6, [r5, #37]	; 0x25
300065fe:	f8ba 6026 	ldrh.w	r6, [r10, #38]	; 0x26
30006602:	f885 6026 	strb.w	r6, [r5, #38]	; 0x26
30006606:	f89a 6027 	ldrb.w	r6, [r10, #39]	; 0x27
3000660a:	f885 6027 	strb.w	r6, [r5, #39]	; 0x27
        entry->last_lba = size_in_lba + entry->first_lba - 1;
3000660e:	e9da 6708 	ldrd	r6, r7, [r10, #32]
30006612:	e9cd 670a 	strd	r6, r7, [r13, #40]	; 0x28
30006616:	f116 36ff 	adds.w	r6, r6, #4294967295	; 0xffffffff
3000661a:	f147 37ff 	adc.w	r7, r7, #4294967295	; 0xffffffff
3000661e:	eb18 0806 	adds.w	r8, r8, r6
30006622:	4646      	mov	r6, r8
30006624:	eb49 0907 	adc.w	r9, r9, r7
        patch_size = (size_in_lba * block_size) % sector_sz;
30006628:	f013 fbfa 	bl	30019e20 <__aeabi_uldivmod>
        entry->last_lba = size_in_lba + entry->first_lba - 1;
3000662c:	464f      	mov	r7, r9
        if (patch_size != 0)
3000662e:	ea52 0103 	orrs.w	r1, r2, r3
30006632:	f43f aee4 	beq.w	300063fe <gpt_partition_round+0x19e>
            entry->last_lba += patch_size / block_size;
30006636:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
3000663a:	1a80      	subs	r0, r0, r2
3000663c:	9a09      	ldr	r2, [sp, #36]	; 0x24
3000663e:	eb61 0103 	sbc.w	r1, r1, r3
30006642:	2300      	movs	r3, #0
30006644:	f013 fbec 	bl	30019e20 <__aeabi_uldivmod>
30006648:	eb10 0208 	adds.w	r2, r0, r8
3000664c:	eb41 0309 	adc.w	r3, r1, r9
30006650:	e9ca 230a 	strd	r2, r3, [r10, #40]	; 0x28
30006654:	e6d5      	b.n	30006402 <gpt_partition_round+0x1a2>
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
30006656:	9a09      	ldr	r2, [sp, #36]	; 0x24
30006658:	2300      	movs	r3, #0
3000665a:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
3000665e:	f013 fbdf 	bl	30019e20 <__aeabi_uldivmod>
            PUT_LONG_LONG(primary_header + LAST_USABLE_LBA_OFFSET, entry->last_lba);
30006662:	9a08      	ldr	r2, [sp, #32]
            entry->last_lba = (capacity - gpt_in_sector)/ block_size - 1;
30006664:	f110 36ff 	adds.w	r6, r0, #4294967295	; 0xffffffff
30006668:	f141 37ff 	adc.w	r7, r1, #4294967295	; 0xffffffff
3000666c:	e9ca 670a 	strd	r6, r7, [r10, #40]	; 0x28
            PUT_LONG_LONG(primary_header + LAST_USABLE_LBA_OFFSET, entry->last_lba);
30006670:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
30006674:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
30006678:	0a1b      	lsrs	r3, r3, #8
3000667a:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
3000667e:	f8ba 302a 	ldrh.w	r3, [r10, #42]	; 0x2a
30006682:	f882 3032 	strb.w	r3, [r2, #50]	; 0x32
30006686:	f89a 302b 	ldrb.w	r3, [r10, #43]	; 0x2b
3000668a:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
3000668e:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
30006692:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
30006696:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
3000669a:	0a1b      	lsrs	r3, r3, #8
3000669c:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
300066a0:	f8ba 302e 	ldrh.w	r3, [r10, #46]	; 0x2e
300066a4:	f882 3036 	strb.w	r3, [r2, #54]	; 0x36
300066a8:	f89a 302f 	ldrb.w	r3, [r10, #47]	; 0x2f
300066ac:	f882 3037 	strb.w	r3, [r2, #55]	; 0x37
            PUT_LONG_LONG(secondary_header + LAST_USABLE_LBA_OFFSET, entry->last_lba);
300066b0:	9a12      	ldr	r2, [sp, #72]	; 0x48
300066b2:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
300066b6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
300066ba:	f8da 3028 	ldr.w	r3, [r10, #40]	; 0x28
300066be:	0a1b      	lsrs	r3, r3, #8
300066c0:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
300066c4:	f8ba 302a 	ldrh.w	r3, [r10, #42]	; 0x2a
300066c8:	f882 3032 	strb.w	r3, [r2, #50]	; 0x32
300066cc:	f89a 302b 	ldrb.w	r3, [r10, #43]	; 0x2b
300066d0:	f882 3033 	strb.w	r3, [r2, #51]	; 0x33
300066d4:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
300066d8:	f882 3034 	strb.w	r3, [r2, #52]	; 0x34
300066dc:	f8da 302c 	ldr.w	r3, [r10, #44]	; 0x2c
300066e0:	0a1b      	lsrs	r3, r3, #8
300066e2:	f882 3035 	strb.w	r3, [r2, #53]	; 0x35
300066e6:	f8ba 302e 	ldrh.w	r3, [r10, #46]	; 0x2e
300066ea:	f882 3036 	strb.w	r3, [r2, #54]	; 0x36
300066ee:	f89a 302f 	ldrb.w	r3, [r10, #47]	; 0x2f
300066f2:	f882 3037 	strb.w	r3, [r2, #55]	; 0x37
            if((entry->last_lba >= entry->first_lba)
300066f6:	e9da 6708 	ldrd	r6, r7, [r10, #32]
300066fa:	e9da 230a 	ldrd	r2, r3, [r10, #40]	; 0x28
300066fe:	e9cd 670a 	strd	r6, r7, [r13, #40]	; 0x28
30006702:	42bb      	cmp	r3, r7
30006704:	bf08      	it	eq
30006706:	42b2      	cmpeq	r2, r6
30006708:	d215      	bcs.n	30006736 <gpt_partition_round+0x4d6>
3000670a:	e9dd 890a 	ldrd	r8, r9, [r13, #40]	; 0x28
            dprintf(CRITICAL, "%s partition size error: first lba:%llu last_lba:%llu!\n", __func__,
3000670e:	f24c 31b0 	movw	r1, #50096	; 0xc3b0
30006712:	f24c 4088 	movw	r0, #50312	; 0xc488
30006716:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000671a:	e9cd 2300 	strd	r2, r3, [r13]
3000671e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30006722:	464b      	mov	r3, r9
30006724:	4642      	mov	r2, r8
30006726:	f00f fa43 	bl	30015bb0 <_printf>
            return 3;
3000672a:	2303      	movs	r3, #3
3000672c:	9305      	str	r3, [sp, #20]
3000672e:	e5ef      	b.n	30006310 <gpt_partition_round+0xb0>
    if (aligned == 0 || size < aligned)
30006730:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30006734:	e718      	b.n	30006568 <gpt_partition_round+0x308>
                && (entry->last_lba - entry->first_lba < size_in_lba - 1))
30006736:	1b96      	subs	r6, r2, r6
30006738:	4630      	mov	r0, r6
3000673a:	eb63 0707 	sbc.w	r7, r3, r7
3000673e:	4639      	mov	r1, r7
30006740:	e9dd 670c 	ldrd	r6, r7, [r13, #48]	; 0x30
30006744:	42b9      	cmp	r1, r7
30006746:	bf08      	it	eq
30006748:	42b0      	cmpeq	r0, r6
3000674a:	f4bf ae61 	bcs.w	30006410 <gpt_partition_round+0x1b0>
                dprintf(CRITICAL, "%s shrink the last entry!\n", __func__);
3000674e:	990e      	ldr	r1, [sp, #56]	; 0x38
30006750:	f24c 406c 	movw	r0, #50284	; 0xc46c
30006754:	f2c3 0001 	movt	r0, #12289	; 0x3001
30006758:	f00f fa2a 	bl	30015bb0 <_printf>
3000675c:	e9da 0108 	ldrd	r0, r1, [r10, #32]
30006760:	e9da 230a 	ldrd	r2, r3, [r10, #40]	; 0x28
30006764:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30006768:	e652      	b.n	30006410 <gpt_partition_round+0x1b0>
3000676a:	9908      	ldr	r1, [sp, #32]
3000676c:	1ad3      	subs	r3, r2, r3
3000676e:	9315      	str	r3, [sp, #84]	; 0x54
30006770:	4459      	add	r1, r11
30006772:	9114      	str	r1, [sp, #80]	; 0x50
    crc_val = crc32(0, primary_header + block_size, partition_entry_size * max_partition_count);
30006774:	e9dd 4113 	ldrd	r4, r1, [r13, #76]	; 0x4c
30006778:	2000      	movs	r0, #0
3000677a:	4622      	mov	r2, r4
    PUT_LONG(primary_header + HEADER_CRC_OFFSET, 0);
3000677c:	4605      	mov	r5, r0
    crc_val = crc32(0, primary_header + block_size, partition_entry_size * max_partition_count);
3000677e:	f00c fbeb 	bl	30012f58 <crc32>
    crc_val = crc32(0, primary_header + block_size + partition_entry_array_size,
30006782:	9b15      	ldr	r3, [sp, #84]	; 0x54
30006784:	9f08      	ldr	r7, [sp, #32]
30006786:	4622      	mov	r2, r4
30006788:	4619      	mov	r1, r3
3000678a:	4439      	add	r1, r7
    PUT_LONG(primary_header + PARTITION_CRC_OFFSET, crc_val);
3000678c:	0e03      	lsrs	r3, r0, #24
3000678e:	0a06      	lsrs	r6, r0, #8
30006790:	f887 0058 	strb.w	r0, [r7, #88]	; 0x58
30006794:	0c04      	lsrs	r4, r0, #16
30006796:	f887 6059 	strb.w	r6, [r7, #89]	; 0x59
    crc_val = crc32(0, primary_header + block_size + partition_entry_array_size,
3000679a:	4628      	mov	r0, r5
    PUT_LONG(primary_header + PARTITION_CRC_OFFSET, crc_val);
3000679c:	f887 405a 	strb.w	r4, [r7, #90]	; 0x5a
300067a0:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    crc_val = crc32(0, primary_header + block_size + partition_entry_array_size,
300067a4:	f00c fbd8 	bl	30012f58 <crc32>
    PUT_LONG(secondary_header + PARTITION_CRC_OFFSET, crc_val);
300067a8:	9e12      	ldr	r6, [sp, #72]	; 0x48
    crc_val = crc32(0, primary_header, GPT_HEADER_SIZE);
300067aa:	225c      	movs	r2, #92	; 0x5c
300067ac:	4639      	mov	r1, r7
    crc_val = crc32(0, primary_header + block_size + partition_entry_array_size,
300067ae:	4603      	mov	r3, r0
    crc_val = crc32(0, primary_header, GPT_HEADER_SIZE);
300067b0:	4628      	mov	r0, r5
    PUT_LONG(secondary_header + PARTITION_CRC_OFFSET, crc_val);
300067b2:	f886 3058 	strb.w	r3, [r6, #88]	; 0x58
300067b6:	ea4f 2c13 	mov.w	r12, r3, lsr #8
300067ba:	0c1c      	lsrs	r4, r3, #16
300067bc:	f886 c059 	strb.w	r12, [r6, #89]	; 0x59
300067c0:	0e1b      	lsrs	r3, r3, #24
300067c2:	f886 405a 	strb.w	r4, [r6, #90]	; 0x5a
    crc_val = crc32(0, primary_header, GPT_HEADER_SIZE);
300067c6:	46bc      	mov	r12, r7
    PUT_LONG(secondary_header + PARTITION_CRC_OFFSET, crc_val);
300067c8:	f886 305b 	strb.w	r3, [r6, #91]	; 0x5b
    PUT_LONG(primary_header + HEADER_CRC_OFFSET, 0);
300067cc:	4666      	mov	r6, r12
300067ce:	f88c 5010 	strb.w	r5, [r12, #16]
300067d2:	f88c 5011 	strb.w	r5, [r12, #17]
300067d6:	f88c 5012 	strb.w	r5, [r12, #18]
300067da:	f88c 5013 	strb.w	r5, [r12, #19]
    crc_val = crc32(0, primary_header, GPT_HEADER_SIZE);
300067de:	f00c fbbb 	bl	30012f58 <crc32>
    crc_val = crc32(0, secondary_header, GPT_HEADER_SIZE);
300067e2:	f8dd c048 	ldr.w	r12, [r13, #72]	; 0x48
300067e6:	225c      	movs	r2, #92	; 0x5c
    crc_val = crc32(0, primary_header, GPT_HEADER_SIZE);
300067e8:	4603      	mov	r3, r0
    crc_val = crc32(0, secondary_header, GPT_HEADER_SIZE);
300067ea:	4628      	mov	r0, r5
    PUT_LONG(primary_header + HEADER_CRC_OFFSET, crc_val);
300067ec:	7433      	strb	r3, [r6, #16]
300067ee:	0a19      	lsrs	r1, r3, #8
300067f0:	0c1c      	lsrs	r4, r3, #16
300067f2:	7471      	strb	r1, [r6, #17]
300067f4:	0e1b      	lsrs	r3, r3, #24
300067f6:	74b4      	strb	r4, [r6, #18]
    crc_val = crc32(0, secondary_header, GPT_HEADER_SIZE);
300067f8:	4661      	mov	r1, r12
    PUT_LONG(primary_header + HEADER_CRC_OFFSET, crc_val);
300067fa:	74f3      	strb	r3, [r6, #19]
    PUT_LONG(secondary_header + HEADER_CRC_OFFSET, 0);
300067fc:	4666      	mov	r6, r12
300067fe:	f88c 5010 	strb.w	r5, [r12, #16]
30006802:	f88c 5011 	strb.w	r5, [r12, #17]
30006806:	f88c 5012 	strb.w	r5, [r12, #18]
3000680a:	f88c 5013 	strb.w	r5, [r12, #19]
    crc_val = crc32(0, secondary_header, GPT_HEADER_SIZE);
3000680e:	f00c fba3 	bl	30012f58 <crc32>
    if (gpt_header_pri.partition_entries) {
30006812:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
    PUT_LONG(secondary_header + HEADER_CRC_OFFSET, crc_val);
30006814:	0a04      	lsrs	r4, r0, #8
30006816:	0c01      	lsrs	r1, r0, #16
30006818:	7430      	strb	r0, [r6, #16]
3000681a:	0e02      	lsrs	r2, r0, #24
3000681c:	7474      	strb	r4, [r6, #17]
3000681e:	74b1      	strb	r1, [r6, #18]
30006820:	74f2      	strb	r2, [r6, #19]
    if (gpt_header_pri.partition_entries) {
30006822:	b113      	cbz	r3, 3000682a <gpt_partition_round+0x5ca>
        free(gpt_header_pri.partition_entries);
30006824:	4618      	mov	r0, r3
30006826:	f00d ffb1 	bl	3001478c <free>
    if (gpt_header_bak.partition_entries) {
3000682a:	9847      	ldr	r0, [sp, #284]	; 0x11c
3000682c:	2800      	cmp	r0, #0
3000682e:	f43f ad6f 	beq.w	30006310 <gpt_partition_round+0xb0>
        free(gpt_header_bak.partition_entries);
30006832:	f00d ffab 	bl	3001478c <free>
30006836:	e56b      	b.n	30006310 <gpt_partition_round+0xb0>
30006838:	e9dd 4506 	ldrd	r4, r5, [r13, #24]
3000683c:	e5af      	b.n	3000639e <gpt_partition_round+0x13e>
        dprintf(CRITICAL, "%s ptb check fail!\n", __func__);
3000683e:	f24c 31b0 	movw	r1, #50096	; 0xc3b0
30006842:	f24c 4034 	movw	r0, #50228	; 0xc434
30006846:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000684a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000684e:	f00f f9af 	bl	30015bb0 <_printf>
        return 2;
30006852:	2302      	movs	r3, #2
30006854:	9305      	str	r3, [sp, #20]
30006856:	e55b      	b.n	30006310 <gpt_partition_round+0xb0>

30006858 <clkgen_get_default_config>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_get_default_config(clkgen_default_cfg_t *def_cfg)
{
30006858:	4603      	mov	r3, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_get_default_config start...............\n");
    def_cfg->src_sel_mask = 2;
    def_cfg->safety_mode = true;
3000685a:	2201      	movs	r2, #1
    def_cfg->src_sel_mask = 2;
3000685c:	2102      	movs	r1, #2
3000685e:	7001      	strb	r1, [r0, #0]
    return true;
}
30006860:	4610      	mov	r0, r2
    def_cfg->safety_mode = true;
30006862:	705a      	strb	r2, [r3, #1]
}
30006864:	4770      	bx	r14
30006866:	bf00      	nop

30006868 <clkgen_fsrefclk_sel>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_fsrefclk_sel(vaddr_t base, uint32_t scr_idx,
                         uint32_t src_sel_mask, bool safety_mode)
{
30006868:	b410      	push	{r4}
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if ((base != SCR_SAF_BASE)
            && (base != SCR_SEC_BASE)) {
3000686a:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
    if ((base != SCR_SAF_BASE)
3000686e:	f114 6ffc 	cmn.w	r4, #132120576	; 0x7e00000
        LTRACEF("base paramenter error \n");
        return false;
30006872:	bf18      	it	ne
30006874:	2200      	movne	r2, #0
    if ((base != SCR_SAF_BASE)
30006876:	d110      	bne.n	3000689a <clkgen_fsrefclk_sel+0x32>
    }

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_fsrefclk_sel scr_idx:0x%x,src_sel_mask:0x%x,safety_mode:0x%x\n",
                  scr_idx, src_sel_mask, safety_mode);
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
30006878:	3180      	adds	r1, #128	; 0x80
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
                              CLKGEN_FSREFCLK_FS_XTAL_EN(1)));
    writel(reg_write, scr_base_addr);
    //select clk src:xtal_saf = 0x0U,xtal_ap = 0x1U,rc_24m = 0x2U,
    reg_read = readl(scr_base_addr);
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
3000687a:	f002 0203 	and.w	r2, r2, #3
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
3000687e:	0309      	lsls	r1, r1, #12
    reg_read = readl(scr_base_addr);
30006880:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
30006882:	f024 0418 	bic.w	r4, r4, #24
    writel(reg_write, scr_base_addr);
30006886:	500c      	str	r4, [r1, r0]
    reg_read = readl(scr_base_addr);
30006888:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
3000688a:	4322      	orrs	r2, r4
    writel(reg_write, scr_base_addr);
3000688c:	500a      	str	r2, [r1, r0]

    //enable safety mode
    if (safety_mode) {
3000688e:	b943      	cbnz	r3, 300068a2 <clkgen_fsrefclk_sel+0x3a>
                                CLKGEN_FSREFCLK_FS_XTAL_EN(1));
        writel(reg_write, scr_base_addr);
    }

    //enable xtal cg gate
    reg_read = readl(scr_base_addr);
30006890:	580b      	ldr	r3, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
    writel(reg_write, scr_base_addr);
    return true;
30006892:	2201      	movs	r2, #1
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
30006894:	f043 0304 	orr.w	r3, r3, #4
    writel(reg_write, scr_base_addr);
30006898:	500b      	str	r3, [r1, r0]
}
3000689a:	f85d 4b04 	ldr.w	r4, [r13], #4
3000689e:	4610      	mov	r0, r2
300068a0:	4770      	bx	r14
        reg_read = readl(scr_base_addr);
300068a2:	580b      	ldr	r3, [r1, r0]
        reg_write = reg_read | (CLKGEN_FSREFCLK_FS_RC_EN(1) |
300068a4:	f043 0318 	orr.w	r3, r3, #24
        writel(reg_write, scr_base_addr);
300068a8:	500b      	str	r3, [r1, r0]
300068aa:	e7f1      	b.n	30006890 <clkgen_fsrefclk_sel+0x28>

300068ac <clkgen_gating_enable>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_gating_enable(vaddr_t base, uint16_t gating_idx, bool enable)
{
300068ac:	4603      	mov	r3, r0
    vaddr_t gating_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
300068ae:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
300068b2:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
300068b6:	d004      	beq.n	300068c2 <clkgen_gating_enable+0x16>
300068b8:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
300068bc:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
300068c0:	d117      	bne.n	300068f2 <clkgen_gating_enable+0x46>
    gating_base_addr = base + CLKGEN_LP_GATING_EN_OFF(gating_idx);
300068c2:	0309      	lsls	r1, r1, #12
300068c4:	f501 1180 	add.w	r1, r1, #1048576	; 0x100000
{
300068c8:	b410      	push	{r4}
    //unlock gating register
    reg_read = readl(gating_base_addr);
300068ca:	58c8      	ldr	r0, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_GATING_LOCK_MASK));
300068cc:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    writel(reg_write, gating_base_addr);
300068d0:	50c8      	str	r0, [r1, r3]
    //set sw disable
    reg_read = readl(gating_base_addr);
300068d2:	58cc      	ldr	r4, [r1, r3]

    if (enable) {
300068d4:	b932      	cbnz	r2, 300068e4 <clkgen_gating_enable+0x38>
    else {
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
        writel(reg_write, gating_base_addr);
    }

    return true;
300068d6:	2001      	movs	r0, #1
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
300068d8:	f044 0202 	orr.w	r2, r4, #2
}
300068dc:	f85d 4b04 	ldr.w	r4, [r13], #4
        writel(reg_write, gating_base_addr);
300068e0:	50ca      	str	r2, [r1, r3]
}
300068e2:	4770      	bx	r14
    return true;
300068e4:	4610      	mov	r0, r2
        reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK));
300068e6:	f024 0402 	bic.w	r4, r4, #2
        writel(reg_write, gating_base_addr);
300068ea:	50cc      	str	r4, [r1, r3]
}
300068ec:	f85d 4b04 	ldr.w	r4, [r13], #4
300068f0:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
300068f2:	2000      	movs	r0, #0
}
300068f4:	4770      	bx	r14
300068f6:	bf00      	nop

300068f8 <clkgen_ip_slice_set>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_ip_slice_set(vaddr_t base, uint8_t ip_slice_idx,
                         uint8_t clk_src_sel, uint16_t pre_div, uint16_t post_div)
{
300068f8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
300068fc:	f8bd 7018 	ldrh.w	r7, [r13, #24]
    bool ret = false;
    vaddr_t ip_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30006900:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
30006904:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
30006908:	d004      	beq.n	30006914 <clkgen_ip_slice_set+0x1c>
3000690a:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
3000690e:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
30006912:	d152      	bne.n	300069ba <clkgen_ip_slice_set+0xc2>
    ip_slice_base_addr = base + CLKGEN_IP_SLICE_CTL_OFF(ip_slice_idx);
30006914:	030e      	lsls	r6, r1, #12
30006916:	1834      	adds	r4, r6, r0
    //clear pre_en
    reg_read = readl(ip_slice_base_addr);
30006918:	5831      	ldr	r1, [r6, r0]

    if ((reg_read & CLKGEN_IP_SLICE_CTL_CG_EN_MASK) != 0) {
3000691a:	07cd      	lsls	r5, r1, #31
3000691c:	d50d      	bpl.n	3000693a <clkgen_ip_slice_set+0x42>
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
        writel(reg_write, ip_slice_base_addr);
3000691e:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
30006920:	f021 0101 	bic.w	r1, r1, #1
        writel(reg_write, ip_slice_base_addr);
30006924:	5031      	str	r1, [r6, r0]
30006926:	e001      	b.n	3000692c <clkgen_ip_slice_set+0x34>
    } while (--retrycount);
30006928:	3d01      	subs	r5, #1
3000692a:	d006      	beq.n	3000693a <clkgen_ip_slice_set+0x42>
        v = readl(reg);
3000692c:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
3000692e:	00c9      	lsls	r1, r1, #3
30006930:	d5fa      	bpl.n	30006928 <clkgen_ip_slice_set+0x30>
    RMWREG32(reg, start, width, setvalue);
30006932:	5831      	ldr	r1, [r6, r0]
30006934:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
30006938:	5031      	str	r1, [r6, r0]
        reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                       1, 1, 0, 100);
    }

    //select clk src
    reg_read = readl(ip_slice_base_addr);
3000693a:	5835      	ldr	r5, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
                CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL(clk_src_sel);
3000693c:	0051      	lsls	r1, r2, #1
3000693e:	f001 010e 	and.w	r1, r1, #14
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
30006942:	f025 020e 	bic.w	r2, r5, #14
30006946:	4311      	orrs	r1, r2
    writel(reg_write, ip_slice_base_addr);
    //set pre_en
    reg_read = readl(ip_slice_base_addr);
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
    writel(reg_write, ip_slice_base_addr);
30006948:	2264      	movs	r2, #100	; 0x64
    writel(reg_write, ip_slice_base_addr);
3000694a:	5031      	str	r1, [r6, r0]
    reg_read = readl(ip_slice_base_addr);
3000694c:	5831      	ldr	r1, [r6, r0]
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
3000694e:	f041 0101 	orr.w	r1, r1, #1
    writel(reg_write, ip_slice_base_addr);
30006952:	5031      	str	r1, [r6, r0]
30006954:	e001      	b.n	3000695a <clkgen_ip_slice_set+0x62>
    } while (--retrycount);
30006956:	3a01      	subs	r2, #1
30006958:	d006      	beq.n	30006968 <clkgen_ip_slice_set+0x70>
        v = readl(reg);
3000695a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
3000695c:	00e9      	lsls	r1, r5, #3
3000695e:	d5fa      	bpl.n	30006956 <clkgen_ip_slice_set+0x5e>
    RMWREG32(reg, start, width, setvalue);
30006960:	5832      	ldr	r2, [r6, r0]
30006962:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
30006966:	5032      	str	r2, [r6, r0]
    reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                   1, 1, 0, 100);
    //set pre_div
    reg_read = readl(ip_slice_base_addr);
30006968:	5832      	ldr	r2, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM(pre_div);
3000696a:	011b      	lsls	r3, r3, #4
3000696c:	4680      	mov	r8, r0
3000696e:	f003 0370 	and.w	r3, r3, #112	; 0x70
    writel(reg_write, ip_slice_base_addr);
30006972:	2564      	movs	r5, #100	; 0x64
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
30006974:	f022 0270 	bic.w	r2, r2, #112	; 0x70
30006978:	4313      	orrs	r3, r2
    writel(reg_write, ip_slice_base_addr);
3000697a:	5033      	str	r3, [r6, r0]
3000697c:	e003      	b.n	30006986 <clkgen_ip_slice_set+0x8e>
        spin(1);
3000697e:	f00d fc37 	bl	300141f0 <spin>
    } while (--retrycount);
30006982:	3d01      	subs	r5, #1
30006984:	d003      	beq.n	3000698e <clkgen_ip_slice_set+0x96>
        v = readl(reg);
30006986:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006988:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000698a:	005b      	lsls	r3, r3, #1
3000698c:	d4f7      	bmi.n	3000697e <clkgen_ip_slice_set+0x86>
    //wait pre_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
    //set post_div
    reg_read = readl(ip_slice_base_addr);
3000698e:	f856 3008 	ldr.w	r3, [r6, r8]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
30006992:	02bf      	lsls	r7, r7, #10
    writel(reg_write, ip_slice_base_addr);
30006994:	2564      	movs	r5, #100	; 0x64
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
30006996:	b2bf      	uxth	r7, r7
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
30006998:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
3000699c:	431f      	orrs	r7, r3
    writel(reg_write, ip_slice_base_addr);
3000699e:	f846 7008 	str.w	r7, [r6, r8]
300069a2:	e003      	b.n	300069ac <clkgen_ip_slice_set+0xb4>
        spin(1);
300069a4:	f00d fc24 	bl	300141f0 <spin>
    } while (--retrycount);
300069a8:	3d01      	subs	r5, #1
300069aa:	d006      	beq.n	300069ba <clkgen_ip_slice_set+0xc2>
        v = readl(reg);
300069ac:	6823      	ldr	r3, [r4, #0]
        spin(1);
300069ae:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
300069b0:	2b00      	cmp	r3, #0
300069b2:	dbf7      	blt.n	300069a4 <clkgen_ip_slice_set+0xac>
            return true;
300069b4:	2001      	movs	r0, #1
    //wait post_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    return ret;
}
300069b6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    CLKGEN_ASSERT_PARAMETER(base);
300069ba:	2000      	movs	r0, #0
}
300069bc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

300069c0 <clkgen_ip_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

    // Check the arguments.
    if (ctl) {
300069c0:	b112      	cbz	r2, 300069c8 <clkgen_ip_ctl_get+0x8>
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
300069c2:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
300069c4:	580b      	ldr	r3, [r1, r0]
300069c6:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
300069c8:	2001      	movs	r0, #1
300069ca:	4770      	bx	r14

300069cc <clkgen_ip_ctl_set>:
{
    bool ret = true;
    vaddr_t slice_addr;
    clkgen_ip_ctl v;

    if (ctl) {
300069cc:	2a00      	cmp	r2, #0
300069ce:	d051      	beq.n	30006a74 <clkgen_ip_ctl_set+0xa8>
{
300069d0:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
300069d4:	030e      	lsls	r6, r1, #12
300069d6:	1834      	adds	r4, r6, r0
        //clear pre_en
        v.val = readl(slice_addr);
300069d8:	5837      	ldr	r7, [r6, r0]

        if (v.cg_en != 0) {
300069da:	07fb      	lsls	r3, r7, #31
300069dc:	d50d      	bpl.n	300069fa <clkgen_ip_ctl_set+0x2e>
            v.cg_en = 0;
            writel(v.val, slice_addr);
300069de:	2364      	movs	r3, #100	; 0x64
            v.cg_en = 0;
300069e0:	f36f 0700 	bfc	r7, #0, #1
            writel(v.val, slice_addr);
300069e4:	5037      	str	r7, [r6, r0]
300069e6:	e001      	b.n	300069ec <clkgen_ip_ctl_set+0x20>
    } while (--retrycount);
300069e8:	3b01      	subs	r3, #1
300069ea:	d006      	beq.n	300069fa <clkgen_ip_ctl_set+0x2e>
        v = readl(reg);
300069ec:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
300069ee:	00cd      	lsls	r5, r1, #3
300069f0:	d5fa      	bpl.n	300069e8 <clkgen_ip_ctl_set+0x1c>
    RMWREG32(reg, start, width, setvalue);
300069f2:	5833      	ldr	r3, [r6, r0]
300069f4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
300069f8:	5033      	str	r3, [r6, r0]
            ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                                  1, 1, 0, 100);
        }

        //select clk src
        v.src_sel = ctl->src_sel;
300069fa:	7813      	ldrb	r3, [r2, #0]
300069fc:	f3c3 0342 	ubfx	r3, r3, #1, #3
30006a00:	f363 0743 	bfi	r7, r3, #1, #3
        writel(v.val, slice_addr);
        //set pre_en
        v.cg_en = ctl->cg_en;
        writel(v.val, slice_addr);
30006a04:	2364      	movs	r3, #100	; 0x64
        writel(v.val, slice_addr);
30006a06:	5037      	str	r7, [r6, r0]
        v.cg_en = ctl->cg_en;
30006a08:	7811      	ldrb	r1, [r2, #0]
30006a0a:	f3c1 0100 	ubfx	r1, r1, #0, #1
30006a0e:	f361 0700 	bfi	r7, r1, #0, #1
        writel(v.val, slice_addr);
30006a12:	5037      	str	r7, [r6, r0]
30006a14:	e001      	b.n	30006a1a <clkgen_ip_ctl_set+0x4e>
    } while (--retrycount);
30006a16:	3b01      	subs	r3, #1
30006a18:	d006      	beq.n	30006a28 <clkgen_ip_ctl_set+0x5c>
        v = readl(reg);
30006a1a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006a1c:	00e9      	lsls	r1, r5, #3
30006a1e:	d5fa      	bpl.n	30006a16 <clkgen_ip_ctl_set+0x4a>
    RMWREG32(reg, start, width, setvalue);
30006a20:	5833      	ldr	r3, [r6, r0]
30006a22:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
30006a26:	5033      	str	r3, [r6, r0]
        ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                              1, 1, 0, 100);
        //set pre_div
        v.pre_div_num = ctl->pre_div_num;
30006a28:	7813      	ldrb	r3, [r2, #0]
30006a2a:	4691      	mov	r9, r2
30006a2c:	4680      	mov	r8, r0
30006a2e:	f3c3 1302 	ubfx	r3, r3, #4, #3
        writel(v.val, slice_addr);
30006a32:	2564      	movs	r5, #100	; 0x64
        v.pre_div_num = ctl->pre_div_num;
30006a34:	f363 1706 	bfi	r7, r3, #4, #3
        writel(v.val, slice_addr);
30006a38:	5037      	str	r7, [r6, r0]
30006a3a:	e003      	b.n	30006a44 <clkgen_ip_ctl_set+0x78>
        spin(1);
30006a3c:	f00d fbd8 	bl	300141f0 <spin>
    } while (--retrycount);
30006a40:	3d01      	subs	r5, #1
30006a42:	d003      	beq.n	30006a4c <clkgen_ip_ctl_set+0x80>
        v = readl(reg);
30006a44:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006a46:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006a48:	005b      	lsls	r3, r3, #1
30006a4a:	d4f7      	bmi.n	30006a3c <clkgen_ip_ctl_set+0x70>
        //wait pre_upd_ack is 0
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
        //set post_div
        v.post_div_num = ctl->post_div_num;
30006a4c:	f899 3001 	ldrb.w	r3, [r9, #1]
        writel(v.val, slice_addr);
30006a50:	2564      	movs	r5, #100	; 0x64
        v.post_div_num = ctl->post_div_num;
30006a52:	089b      	lsrs	r3, r3, #2
30006a54:	f363 278f 	bfi	r7, r3, #10, #6
        writel(v.val, slice_addr);
30006a58:	f846 7008 	str.w	r7, [r6, r8]
30006a5c:	e003      	b.n	30006a66 <clkgen_ip_ctl_set+0x9a>
        spin(1);
30006a5e:	f00d fbc7 	bl	300141f0 <spin>
    } while (--retrycount);
30006a62:	3d01      	subs	r5, #1
30006a64:	d008      	beq.n	30006a78 <clkgen_ip_ctl_set+0xac>
        v = readl(reg);
30006a66:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006a68:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006a6a:	2b00      	cmp	r3, #0
30006a6c:	dbf7      	blt.n	30006a5e <clkgen_ip_ctl_set+0x92>
    bool ret = true;
30006a6e:	2001      	movs	r0, #1
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
30006a70:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    bool ret = true;
30006a74:	2001      	movs	r0, #1
}
30006a76:	4770      	bx	r14
    return false;
30006a78:	4628      	mov	r0, r5
30006a7a:	e7f9      	b.n	30006a70 <clkgen_ip_ctl_set+0xa4>

30006a7c <clkgen_bus_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_bus_slice_switch(vaddr_t base,
                             clkgen_bus_slice_drv_t *bus_clk_cfg)
{
30006a7c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    vaddr_t bus_gasket_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30006a80:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
30006a84:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
30006a88:	d007      	beq.n	30006a9a <clkgen_bus_slice_switch+0x1e>
30006a8a:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
30006a8e:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
30006a92:	bf18      	it	ne
30006a94:	2000      	movne	r0, #0
30006a96:	f040 808a 	bne.w	30006bae <clkgen_bus_slice_switch+0x132>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
30006a9a:	680b      	ldr	r3, [r1, #0]
30006a9c:	4688      	mov	r8, r1
30006a9e:	4606      	mov	r6, r0
30006aa0:	3340      	adds	r3, #64	; 0x40
30006aa2:	035f      	lsls	r7, r3, #13
                              bus_clk_cfg->bus_slice_idx);
    bus_gasket_slice_base_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(
30006aa4:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
30006aa8:	eb03 0900 	add.w	r9, r3, r0
                                     bus_clk_cfg->bus_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(bus_slice_base_addr);
30006aac:	583a      	ldr	r2, [r7, r0]
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
30006aae:	183c      	adds	r4, r7, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
        (a_b_sel == bus_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(bus_slice_base_addr);
30006ab0:	5839      	ldr	r1, [r7, r0]
    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
30006ab2:	0595      	lsls	r5, r2, #22
30006ab4:	d47d      	bmi.n	30006bb2 <clkgen_bus_slice_switch+0x136>

        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK) != 0) {
30006ab6:	03c8      	lsls	r0, r1, #15
30006ab8:	d50d      	bpl.n	30006ad6 <clkgen_bus_slice_switch+0x5a>
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, bus_slice_base_addr);
30006aba:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
30006abc:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
            writel(reg_write, bus_slice_base_addr);
30006ac0:	51b9      	str	r1, [r7, r6]
30006ac2:	e001      	b.n	30006ac8 <clkgen_bus_slice_switch+0x4c>
    } while (--retrycount);
30006ac4:	3a01      	subs	r2, #1
30006ac6:	d006      	beq.n	30006ad6 <clkgen_bus_slice_switch+0x5a>
        v = readl(reg);
30006ac8:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006aca:	0109      	lsls	r1, r1, #4
30006acc:	d5fa      	bpl.n	30006ac4 <clkgen_bus_slice_switch+0x48>
    RMWREG32(reg, start, width, setvalue);
30006ace:	59ba      	ldr	r2, [r7, r6]
30006ad0:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
30006ad4:	51ba      	str	r2, [r7, r6]
                    & (~(CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM_MASK));
        reg_write = reg_write
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006ad6:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006ada:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006ade:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
30006ae0:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006ae4:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006ae6:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006aea:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006aee:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
30006af2:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
30006af4:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
30006af8:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
30006afa:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006afc:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
30006afe:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006b00:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
30006b04:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
30006b08:	4302      	orrs	r2, r0
        reg_write = reg_read
30006b0a:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
30006b0e:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
30006b10:	519a      	str	r2, [r3, r6]
30006b12:	e003      	b.n	30006b1c <clkgen_bus_slice_switch+0xa0>
        spin(1);
30006b14:	f00d fb6c 	bl	300141f0 <spin>
    } while (--retrycount);
30006b18:	3d01      	subs	r5, #1
30006b1a:	d004      	beq.n	30006b26 <clkgen_bus_slice_switch+0xaa>
        v = readl(reg);
30006b1c:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
30006b20:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006b22:	0f1b      	lsrs	r3, r3, #28
30006b24:	d1f6      	bne.n	30006b14 <clkgen_bus_slice_switch+0x98>
        ret = reg_poll_value(bus_gasket_slice_base_addr,
                             CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
30006b26:	f898 2006 	ldrb.w	r2, [r8, #6]
        reg_read = readl(bus_slice_base_addr);
30006b2a:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
30006b2c:	0452      	lsls	r2, r2, #17
30006b2e:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
30006b32:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
30006b36:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
30006b3a:	431a      	orrs	r2, r3
                    | CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, bus_slice_base_addr);
30006b3c:	2364      	movs	r3, #100	; 0x64
30006b3e:	51ba      	str	r2, [r7, r6]
30006b40:	e001      	b.n	30006b46 <clkgen_bus_slice_switch+0xca>
    } while (--retrycount);
30006b42:	3b01      	subs	r3, #1
30006b44:	d006      	beq.n	30006b54 <clkgen_bus_slice_switch+0xd8>
        v = readl(reg);
30006b46:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006b48:	0112      	lsls	r2, r2, #4
30006b4a:	d5fa      	bpl.n	30006b42 <clkgen_bus_slice_switch+0xc6>
    RMWREG32(reg, start, width, setvalue);
30006b4c:	59bb      	ldr	r3, [r7, r6]
30006b4e:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
30006b52:	51bb      	str	r3, [r7, r6]
        reg_poll_clear(bus_slice_base_addr,
                       CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
30006b54:	59ba      	ldr	r2, [r7, r6]
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
30006b56:	f898 3008 	ldrb.w	r3, [r8, #8]
        writel(reg_write, bus_slice_base_addr);
30006b5a:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
30006b5c:	051b      	lsls	r3, r3, #20
30006b5e:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
30006b62:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
30006b66:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
30006b68:	51bb      	str	r3, [r7, r6]
30006b6a:	e003      	b.n	30006b74 <clkgen_bus_slice_switch+0xf8>
        spin(1);
30006b6c:	f00d fb40 	bl	300141f0 <spin>
    } while (--retrycount);
30006b70:	3d01      	subs	r5, #1
30006b72:	d003      	beq.n	30006b7c <clkgen_bus_slice_switch+0x100>
        v = readl(reg);
30006b74:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006b76:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006b78:	009b      	lsls	r3, r3, #2
30006b7a:	d4f7      	bmi.n	30006b6c <clkgen_bus_slice_switch+0xf0>
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006b7c:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
30006b80:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
30006b82:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006b84:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
30006b86:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006b8a:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
30006b8c:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
30006b8e:	51bb      	str	r3, [r7, r6]
30006b90:	e004      	b.n	30006b9c <clkgen_bus_slice_switch+0x120>
        spin(1);
30006b92:	f00d fb2d 	bl	300141f0 <spin>
    } while (--retrycount);
30006b96:	3d01      	subs	r5, #1
30006b98:	f000 808a 	beq.w	30006cb0 <clkgen_bus_slice_switch+0x234>
        v = readl(reg);
30006b9c:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006b9e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006ba0:	2b00      	cmp	r3, #0
30006ba2:	dbf6      	blt.n	30006b92 <clkgen_bus_slice_switch+0x116>
            return true;
30006ba4:	2001      	movs	r0, #1
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(bus_slice_base_addr);
30006ba6:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read | CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK;
30006ba8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
30006bac:	51bb      	str	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
        writel(reg_write, bus_slice_base_addr);
    }

    return ret;
}
30006bae:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK) != 0) {
30006bb2:	07c8      	lsls	r0, r1, #31
30006bb4:	d50d      	bpl.n	30006bd2 <clkgen_bus_slice_switch+0x156>
            writel(reg_write, bus_slice_base_addr);
30006bb6:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK);
30006bb8:	f021 0101 	bic.w	r1, r1, #1
            writel(reg_write, bus_slice_base_addr);
30006bbc:	51b9      	str	r1, [r7, r6]
30006bbe:	e001      	b.n	30006bc4 <clkgen_bus_slice_switch+0x148>
    } while (--retrycount);
30006bc0:	3a01      	subs	r2, #1
30006bc2:	d006      	beq.n	30006bd2 <clkgen_bus_slice_switch+0x156>
        v = readl(reg);
30006bc4:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006bc6:	00c9      	lsls	r1, r1, #3
30006bc8:	d5fa      	bpl.n	30006bc0 <clkgen_bus_slice_switch+0x144>
    RMWREG32(reg, start, width, setvalue);
30006bca:	59ba      	ldr	r2, [r7, r6]
30006bcc:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
30006bd0:	51ba      	str	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006bd2:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006bd6:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006bda:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
30006bdc:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006be0:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006be2:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
30006be6:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
30006bea:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
30006bee:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
30006bf0:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
30006bf4:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
30006bf6:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006bf8:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
30006bfa:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
30006bfc:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
30006c00:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
30006c04:	4302      	orrs	r2, r0
        reg_write = reg_read
30006c06:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
30006c0a:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
30006c0c:	519a      	str	r2, [r3, r6]
30006c0e:	e003      	b.n	30006c18 <clkgen_bus_slice_switch+0x19c>
        spin(1);
30006c10:	f00d faee 	bl	300141f0 <spin>
    } while (--retrycount);
30006c14:	3d01      	subs	r5, #1
30006c16:	d004      	beq.n	30006c22 <clkgen_bus_slice_switch+0x1a6>
        v = readl(reg);
30006c18:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
30006c1c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006c1e:	0f1b      	lsrs	r3, r3, #28
30006c20:	d1f6      	bne.n	30006c10 <clkgen_bus_slice_switch+0x194>
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
30006c22:	f898 2005 	ldrb.w	r2, [r8, #5]
        reg_read = readl(bus_slice_base_addr);
30006c26:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
30006c28:	0052      	lsls	r2, r2, #1
30006c2a:	f002 020e 	and.w	r2, r2, #14
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A_MASK))
30006c2e:	f023 030e 	bic.w	r3, r3, #14
30006c32:	f042 0201 	orr.w	r2, r2, #1
30006c36:	431a      	orrs	r2, r3
        writel(reg_write, bus_slice_base_addr);
30006c38:	2364      	movs	r3, #100	; 0x64
30006c3a:	51ba      	str	r2, [r7, r6]
30006c3c:	e001      	b.n	30006c42 <clkgen_bus_slice_switch+0x1c6>
    } while (--retrycount);
30006c3e:	3b01      	subs	r3, #1
30006c40:	d006      	beq.n	30006c50 <clkgen_bus_slice_switch+0x1d4>
        v = readl(reg);
30006c42:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006c44:	00d2      	lsls	r2, r2, #3
30006c46:	d5fa      	bpl.n	30006c3e <clkgen_bus_slice_switch+0x1c2>
    RMWREG32(reg, start, width, setvalue);
30006c48:	59bb      	ldr	r3, [r7, r6]
30006c4a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
30006c4e:	51bb      	str	r3, [r7, r6]
        reg_read = readl(bus_slice_base_addr);
30006c50:	59ba      	ldr	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
30006c52:	f898 3007 	ldrb.w	r3, [r8, #7]
        writel(reg_write, bus_slice_base_addr);
30006c56:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
30006c58:	011b      	lsls	r3, r3, #4
30006c5a:	f003 0370 	and.w	r3, r3, #112	; 0x70
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A_MASK))
30006c5e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
30006c62:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
30006c64:	51bb      	str	r3, [r7, r6]
30006c66:	e003      	b.n	30006c70 <clkgen_bus_slice_switch+0x1f4>
        spin(1);
30006c68:	f00d fac2 	bl	300141f0 <spin>
    } while (--retrycount);
30006c6c:	3d01      	subs	r5, #1
30006c6e:	d003      	beq.n	30006c78 <clkgen_bus_slice_switch+0x1fc>
        v = readl(reg);
30006c70:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006c72:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006c74:	005b      	lsls	r3, r3, #1
30006c76:	d4f7      	bmi.n	30006c68 <clkgen_bus_slice_switch+0x1ec>
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006c78:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
30006c7c:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
30006c7e:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006c80:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
30006c82:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
30006c86:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
30006c88:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
30006c8a:	51bb      	str	r3, [r7, r6]
30006c8c:	e003      	b.n	30006c96 <clkgen_bus_slice_switch+0x21a>
        spin(1);
30006c8e:	f00d faaf 	bl	300141f0 <spin>
    } while (--retrycount);
30006c92:	3d01      	subs	r5, #1
30006c94:	d00a      	beq.n	30006cac <clkgen_bus_slice_switch+0x230>
        v = readl(reg);
30006c96:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006c98:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006c9a:	2b00      	cmp	r3, #0
30006c9c:	dbf7      	blt.n	30006c8e <clkgen_bus_slice_switch+0x212>
            return true;
30006c9e:	2001      	movs	r0, #1
        reg_read = readl(bus_slice_base_addr);
30006ca0:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
30006ca2:	f423 7300 	bic.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
30006ca6:	51bb      	str	r3, [r7, r6]
}
30006ca8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    return false;
30006cac:	4628      	mov	r0, r5
30006cae:	e7f7      	b.n	30006ca0 <clkgen_bus_slice_switch+0x224>
30006cb0:	4628      	mov	r0, r5
30006cb2:	e778      	b.n	30006ba6 <clkgen_bus_slice_switch+0x12a>

30006cb4 <clkgen_bus_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
30006cb4:	b17a      	cbz	r2, 30006cd6 <clkgen_bus_ctl_get+0x22>
{
30006cb6:	b410      	push	{r4}
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
30006cb8:	f101 0440 	add.w	r4, r1, #64	; 0x40
30006cbc:	0364      	lsls	r4, r4, #13
        ctl->val = readl(slice_addr);
30006cbe:	5824      	ldr	r4, [r4, r0]
30006cc0:	6014      	str	r4, [r2, #0]
    }

    if (gasket) {
30006cc2:	b123      	cbz	r3, 30006cce <clkgen_bus_ctl_get+0x1a>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006cc4:	0349      	lsls	r1, r1, #13
30006cc6:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
30006cca:	580a      	ldr	r2, [r1, r0]
30006ccc:	601a      	str	r2, [r3, #0]
    }

    return ret;
}
30006cce:	f85d 4b04 	ldr.w	r4, [r13], #4
30006cd2:	2001      	movs	r0, #1
30006cd4:	4770      	bx	r14
    if (gasket) {
30006cd6:	b123      	cbz	r3, 30006ce2 <clkgen_bus_ctl_get+0x2e>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006cd8:	0349      	lsls	r1, r1, #13
30006cda:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
30006cde:	580a      	ldr	r2, [r1, r0]
30006ce0:	601a      	str	r2, [r3, #0]
}
30006ce2:	2001      	movs	r0, #1
30006ce4:	4770      	bx	r14
30006ce6:	bf00      	nop

30006ce8 <clkgen_bus_ctl_set>:
                        const clkgen_bus_gasket *gasket)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
30006ce8:	2a00      	cmp	r2, #0
30006cea:	f000 80ec 	beq.w	30006ec6 <clkgen_bus_ctl_set+0x1de>
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
30006cee:	3140      	adds	r1, #64	; 0x40
{
30006cf0:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
30006cf4:	4691      	mov	r9, r2
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
30006cf6:	ea4f 3841 	mov.w	r8, r1, lsl #13
30006cfa:	4607      	mov	r7, r0
30006cfc:	00c9      	lsls	r1, r1, #3
30006cfe:	eb08 0500 	add.w	r5, r8, r0
        clkgen_bus_ctl v;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        v.val = readl(slice_addr);
30006d02:	f858 6000 	ldr.w	r6, [r8, r0]

        if (v.a_b_sel == 0) {
30006d06:	f3c6 2207 	ubfx	r2, r6, #8, #8
30006d0a:	f012 0202 	ands.w	r2, r2, #2
30006d0e:	d16e      	bne.n	30006dee <clkgen_bus_ctl_set+0x106>
            //set pre_en_b to 0x0,disable the clock
            if (v.cg_en_b != 0) {
30006d10:	03f4      	lsls	r4, r6, #15
30006d12:	f100 80ec 	bmi.w	30006eee <clkgen_bus_ctl_set+0x206>
                reg_poll_clear(slice_addr, CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1,
                               0, 100);
            }

            //set m/n/p/q div
            if (gasket) {
30006d16:	b31b      	cbz	r3, 30006d60 <clkgen_bus_ctl_set+0x78>
                vaddr_t g_addr;
                clkgen_bus_gasket g;
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006d18:	3104      	adds	r1, #4
                g.val = readl(g_addr);
                g.m_div_num = gasket->m_div_num;
                g.n_div_num = gasket->n_div_num;
                g.p_div_num = gasket->p_div_num;
30006d1a:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
30006d1c:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
30006d1e:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006d20:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
30006d22:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
30006d26:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
30006d2a:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
30006d2c:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
30006d30:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
30006d34:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
30006d38:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
30006d3c:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
30006d40:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
30006d44:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006d46:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
30006d4a:	51cb      	str	r3, [r1, r7]
30006d4c:	e003      	b.n	30006d56 <clkgen_bus_ctl_set+0x6e>
        spin(1);
30006d4e:	f00d fa4f 	bl	300141f0 <spin>
    } while (--retrycount);
30006d52:	3c01      	subs	r4, #1
30006d54:	d004      	beq.n	30006d60 <clkgen_bus_ctl_set+0x78>
        v = readl(reg);
30006d56:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
30006d5a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006d5c:	0f1b      	lsrs	r3, r3, #28
30006d5e:	d1f6      	bne.n	30006d4e <clkgen_bus_ctl_set+0x66>
                ret = reg_poll_value(g_addr,
                                     CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            v.src_sel_b = ctl->src_sel_a;
30006d60:	f899 3000 	ldrb.w	r3, [r9]
30006d64:	f3c3 0242 	ubfx	r2, r3, #1, #3
30006d68:	f362 4653 	bfi	r6, r2, #17, #3
            v.cg_en_b = ctl->cg_en_a;
30006d6c:	f3c3 0200 	ubfx	r2, r3, #0, #1
30006d70:	f362 4610 	bfi	r6, r2, #16, #1

            if (v.cg_en_b != 0) {
30006d74:	03f1      	lsls	r1, r6, #15
30006d76:	d511      	bpl.n	30006d9c <clkgen_bus_ctl_set+0xb4>
                writel(v.val, slice_addr);
30006d78:	f848 6007 	str.w	r6, [r8, r7]
30006d7c:	2364      	movs	r3, #100	; 0x64
30006d7e:	e002      	b.n	30006d86 <clkgen_bus_ctl_set+0x9e>
    } while (--retrycount);
30006d80:	3b01      	subs	r3, #1
30006d82:	f000 80cb 	beq.w	30006f1c <clkgen_bus_ctl_set+0x234>
        v = readl(reg);
30006d86:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006d88:	0112      	lsls	r2, r2, #4
30006d8a:	d5f9      	bpl.n	30006d80 <clkgen_bus_ctl_set+0x98>
    RMWREG32(reg, start, width, setvalue);
30006d8c:	f858 3007 	ldr.w	r3, [r8, r7]
30006d90:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
30006d94:	f848 3007 	str.w	r3, [r8, r7]
30006d98:	f899 3000 	ldrb.w	r3, [r9]
                               0, 100);
            }

            //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
            v.pre_div_num_b = ctl->pre_div_num_a;
            writel(v.val, slice_addr);
30006d9c:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_b = ctl->pre_div_num_a;
30006d9e:	f3c3 1302 	ubfx	r3, r3, #4, #3
30006da2:	f363 5616 	bfi	r6, r3, #20, #3
            writel(v.val, slice_addr);
30006da6:	f848 6007 	str.w	r6, [r8, r7]
30006daa:	e003      	b.n	30006db4 <clkgen_bus_ctl_set+0xcc>
        spin(1);
30006dac:	f00d fa20 	bl	300141f0 <spin>
    } while (--retrycount);
30006db0:	3c01      	subs	r4, #1
30006db2:	d003      	beq.n	30006dbc <clkgen_bus_ctl_set+0xd4>
        v = readl(reg);
30006db4:	682b      	ldr	r3, [r5, #0]
        spin(1);
30006db6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006db8:	009b      	lsls	r3, r3, #2
30006dba:	d4f7      	bmi.n	30006dac <clkgen_bus_ctl_set+0xc4>
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            v.post_div_num = ctl->post_div_num;
30006dbc:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
30006dc0:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
30006dc2:	089b      	lsrs	r3, r3, #2
30006dc4:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
30006dc8:	f848 6007 	str.w	r6, [r8, r7]
30006dcc:	e004      	b.n	30006dd8 <clkgen_bus_ctl_set+0xf0>
        spin(1);
30006dce:	f00d fa0f 	bl	300141f0 <spin>
    } while (--retrycount);
30006dd2:	3c01      	subs	r4, #1
30006dd4:	f000 809e 	beq.w	30006f14 <clkgen_bus_ctl_set+0x22c>
        v = readl(reg);
30006dd8:	682b      	ldr	r3, [r5, #0]
        spin(1);
30006dda:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006ddc:	2b00      	cmp	r3, #0
30006dde:	dbf6      	blt.n	30006dce <clkgen_bus_ctl_set+0xe6>
            return true;
30006de0:	2001      	movs	r0, #1
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
            //invert pre_a_b_sel
            v.a_b_sel = 1;
30006de2:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(v.val, slice_addr);
30006de6:	f848 6007 	str.w	r6, [r8, r7]
            writel(v.val, slice_addr);
        }
    }

    return ret;
}
30006dea:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            if (v.cg_en_a != 0) {
30006dee:	07f4      	lsls	r4, r6, #31
30006df0:	d46b      	bmi.n	30006eca <clkgen_bus_ctl_set+0x1e2>
            if (gasket) {
30006df2:	b31b      	cbz	r3, 30006e3c <clkgen_bus_ctl_set+0x154>
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006df4:	3104      	adds	r1, #4
                g.p_div_num = gasket->p_div_num;
30006df6:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
30006df8:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
30006dfa:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006dfc:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
30006dfe:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
30006e02:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
30006e06:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
30006e08:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
30006e0c:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
30006e10:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
30006e14:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
30006e18:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
30006e1c:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
30006e20:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
30006e22:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
30006e26:	51cb      	str	r3, [r1, r7]
30006e28:	e003      	b.n	30006e32 <clkgen_bus_ctl_set+0x14a>
        spin(1);
30006e2a:	f00d f9e1 	bl	300141f0 <spin>
    } while (--retrycount);
30006e2e:	3c01      	subs	r4, #1
30006e30:	d004      	beq.n	30006e3c <clkgen_bus_ctl_set+0x154>
        v = readl(reg);
30006e32:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
30006e36:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006e38:	0f1b      	lsrs	r3, r3, #28
30006e3a:	d1f6      	bne.n	30006e2a <clkgen_bus_ctl_set+0x142>
            v.src_sel_a = ctl->src_sel_a;
30006e3c:	f899 3000 	ldrb.w	r3, [r9]
30006e40:	f3c3 0242 	ubfx	r2, r3, #1, #3
30006e44:	f362 0643 	bfi	r6, r2, #1, #3
            v.cg_en_a = ctl->cg_en_a;
30006e48:	f3c3 0200 	ubfx	r2, r3, #0, #1
30006e4c:	f362 0600 	bfi	r6, r2, #0, #1
            if (v.cg_en_a != 0) {
30006e50:	07f1      	lsls	r1, r6, #31
30006e52:	d510      	bpl.n	30006e76 <clkgen_bus_ctl_set+0x18e>
                writel(v.val, slice_addr);
30006e54:	f848 6007 	str.w	r6, [r8, r7]
30006e58:	2364      	movs	r3, #100	; 0x64
30006e5a:	e001      	b.n	30006e60 <clkgen_bus_ctl_set+0x178>
    } while (--retrycount);
30006e5c:	3b01      	subs	r3, #1
30006e5e:	d060      	beq.n	30006f22 <clkgen_bus_ctl_set+0x23a>
        v = readl(reg);
30006e60:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006e62:	00d2      	lsls	r2, r2, #3
30006e64:	d5fa      	bpl.n	30006e5c <clkgen_bus_ctl_set+0x174>
    RMWREG32(reg, start, width, setvalue);
30006e66:	f858 3007 	ldr.w	r3, [r8, r7]
30006e6a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
30006e6e:	f848 3007 	str.w	r3, [r8, r7]
30006e72:	f899 3000 	ldrb.w	r3, [r9]
            writel(v.val, slice_addr);
30006e76:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_a = ctl->pre_div_num_a;
30006e78:	f3c3 1302 	ubfx	r3, r3, #4, #3
30006e7c:	f363 1606 	bfi	r6, r3, #4, #3
            writel(v.val, slice_addr);
30006e80:	f848 6007 	str.w	r6, [r8, r7]
30006e84:	e003      	b.n	30006e8e <clkgen_bus_ctl_set+0x1a6>
        spin(1);
30006e86:	f00d f9b3 	bl	300141f0 <spin>
    } while (--retrycount);
30006e8a:	3c01      	subs	r4, #1
30006e8c:	d003      	beq.n	30006e96 <clkgen_bus_ctl_set+0x1ae>
        v = readl(reg);
30006e8e:	682b      	ldr	r3, [r5, #0]
        spin(1);
30006e90:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006e92:	005b      	lsls	r3, r3, #1
30006e94:	d4f7      	bmi.n	30006e86 <clkgen_bus_ctl_set+0x19e>
            v.post_div_num = ctl->post_div_num;
30006e96:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
30006e9a:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
30006e9c:	089b      	lsrs	r3, r3, #2
30006e9e:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
30006ea2:	f848 6007 	str.w	r6, [r8, r7]
30006ea6:	e003      	b.n	30006eb0 <clkgen_bus_ctl_set+0x1c8>
        spin(1);
30006ea8:	f00d f9a2 	bl	300141f0 <spin>
    } while (--retrycount);
30006eac:	3c01      	subs	r4, #1
30006eae:	d033      	beq.n	30006f18 <clkgen_bus_ctl_set+0x230>
        v = readl(reg);
30006eb0:	682b      	ldr	r3, [r5, #0]
        spin(1);
30006eb2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006eb4:	2b00      	cmp	r3, #0
30006eb6:	dbf7      	blt.n	30006ea8 <clkgen_bus_ctl_set+0x1c0>
            return true;
30006eb8:	2001      	movs	r0, #1
            v.a_b_sel = 0;
30006eba:	f36f 2649 	bfc	r6, #9, #1
            writel(v.val, slice_addr);
30006ebe:	f848 6007 	str.w	r6, [r8, r7]
}
30006ec2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    bool ret = true;
30006ec6:	2001      	movs	r0, #1
}
30006ec8:	4770      	bx	r14
                writel(v.val, slice_addr);
30006eca:	2264      	movs	r2, #100	; 0x64
                v.cg_en_a = 0;
30006ecc:	f36f 0600 	bfc	r6, #0, #1
                writel(v.val, slice_addr);
30006ed0:	f848 6000 	str.w	r6, [r8, r0]
30006ed4:	e001      	b.n	30006eda <clkgen_bus_ctl_set+0x1f2>
    } while (--retrycount);
30006ed6:	3a01      	subs	r2, #1
30006ed8:	d08b      	beq.n	30006df2 <clkgen_bus_ctl_set+0x10a>
        v = readl(reg);
30006eda:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006edc:	00c0      	lsls	r0, r0, #3
30006ede:	d5fa      	bpl.n	30006ed6 <clkgen_bus_ctl_set+0x1ee>
    RMWREG32(reg, start, width, setvalue);
30006ee0:	f858 2007 	ldr.w	r2, [r8, r7]
30006ee4:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
30006ee8:	f848 2007 	str.w	r2, [r8, r7]
30006eec:	e781      	b.n	30006df2 <clkgen_bus_ctl_set+0x10a>
                v.cg_en_b = 0;
30006eee:	f362 4610 	bfi	r6, r2, #16, #1
                writel(v.val, slice_addr);
30006ef2:	2264      	movs	r2, #100	; 0x64
30006ef4:	f848 6000 	str.w	r6, [r8, r0]
30006ef8:	e002      	b.n	30006f00 <clkgen_bus_ctl_set+0x218>
    } while (--retrycount);
30006efa:	3a01      	subs	r2, #1
30006efc:	f43f af0b 	beq.w	30006d16 <clkgen_bus_ctl_set+0x2e>
        v = readl(reg);
30006f00:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006f02:	0100      	lsls	r0, r0, #4
30006f04:	d5f9      	bpl.n	30006efa <clkgen_bus_ctl_set+0x212>
    RMWREG32(reg, start, width, setvalue);
30006f06:	f858 2007 	ldr.w	r2, [r8, r7]
30006f0a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
30006f0e:	f848 2007 	str.w	r2, [r8, r7]
30006f12:	e700      	b.n	30006d16 <clkgen_bus_ctl_set+0x2e>
    return false;
30006f14:	4620      	mov	r0, r4
30006f16:	e764      	b.n	30006de2 <clkgen_bus_ctl_set+0xfa>
30006f18:	4620      	mov	r0, r4
30006f1a:	e7ce      	b.n	30006eba <clkgen_bus_ctl_set+0x1d2>
30006f1c:	f899 3000 	ldrb.w	r3, [r9]
30006f20:	e73c      	b.n	30006d9c <clkgen_bus_ctl_set+0xb4>
30006f22:	f899 3000 	ldrb.w	r3, [r9]
30006f26:	e7a6      	b.n	30006e76 <clkgen_bus_ctl_set+0x18e>

30006f28 <clkgen_core_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_core_slice_switch(vaddr_t base,
                              clkgen_core_slice_drv_t *core_clk_cfg)
{
30006f28:	b538      	push	{r3, r4, r5, r14}
    vaddr_t core_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30006f2a:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
30006f2e:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
30006f32:	d005      	beq.n	30006f40 <clkgen_core_slice_switch+0x18>
30006f34:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
30006f38:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
30006f3c:	f040 8084 	bne.w	30007048 <clkgen_core_slice_switch+0x120>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    core_slice_base_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(
30006f40:	680b      	ldr	r3, [r1, #0]
30006f42:	33c0      	adds	r3, #192	; 0xc0
30006f44:	031b      	lsls	r3, r3, #12
30006f46:	181c      	adds	r4, r3, r0
                               core_clk_cfg->core_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(core_slice_base_addr);
30006f48:	581a      	ldr	r2, [r3, r0]
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
        (a_b_sel == core_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(core_slice_base_addr);
30006f4a:	581d      	ldr	r5, [r3, r0]
    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
30006f4c:	0592      	lsls	r2, r2, #22
30006f4e:	d43d      	bmi.n	30006fcc <clkgen_core_slice_switch+0xa4>

        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK) != 0) {
30006f50:	03ea      	lsls	r2, r5, #15
30006f52:	d50d      	bpl.n	30006f70 <clkgen_core_slice_switch+0x48>
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, core_slice_base_addr);
30006f54:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
30006f56:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
            writel(reg_write, core_slice_base_addr);
30006f5a:	501d      	str	r5, [r3, r0]
30006f5c:	e001      	b.n	30006f62 <clkgen_core_slice_switch+0x3a>
    } while (--retrycount);
30006f5e:	3a01      	subs	r2, #1
30006f60:	d006      	beq.n	30006f70 <clkgen_core_slice_switch+0x48>
        v = readl(reg);
30006f62:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006f64:	012d      	lsls	r5, r5, #4
30006f66:	d5fa      	bpl.n	30006f5e <clkgen_core_slice_switch+0x36>
    RMWREG32(reg, start, width, setvalue);
30006f68:	581a      	ldr	r2, [r3, r0]
30006f6a:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
30006f6e:	501a      	str	r2, [r3, r0]
        }

        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
30006f70:	798d      	ldrb	r5, [r1, #6]
        reg_read = readl(core_slice_base_addr);
30006f72:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
30006f74:	046d      	lsls	r5, r5, #17
30006f76:	f405 2560 	and.w	r5, r5, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
30006f7a:	f422 2260 	bic.w	r2, r2, #917504	; 0xe0000
30006f7e:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
30006f82:	4315      	orrs	r5, r2
                    | CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, core_slice_base_addr);
30006f84:	2264      	movs	r2, #100	; 0x64
30006f86:	501d      	str	r5, [r3, r0]
30006f88:	e001      	b.n	30006f8e <clkgen_core_slice_switch+0x66>
    } while (--retrycount);
30006f8a:	3a01      	subs	r2, #1
30006f8c:	d006      	beq.n	30006f9c <clkgen_core_slice_switch+0x74>
        v = readl(reg);
30006f8e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006f90:	012d      	lsls	r5, r5, #4
30006f92:	d5fa      	bpl.n	30006f8a <clkgen_core_slice_switch+0x62>
    RMWREG32(reg, start, width, setvalue);
30006f94:	581a      	ldr	r2, [r3, r0]
30006f96:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
30006f9a:	501a      	str	r2, [r3, r0]
        reg_poll_clear(core_slice_base_addr,
                       CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(core_slice_base_addr);
30006f9c:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
        writel(reg_write, core_slice_base_addr);
30006f9e:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read | CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK;
30006fa0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
30006fa4:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
30006fa6:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
30006fa8:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
30006faa:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
30006fac:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
30006fb0:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
30006fb2:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
30006fb4:	501a      	str	r2, [r3, r0]
30006fb6:	e003      	b.n	30006fc0 <clkgen_core_slice_switch+0x98>
        spin(1);
30006fb8:	f00d f91a 	bl	300141f0 <spin>
    } while (--retrycount);
30006fbc:	3d01      	subs	r5, #1
30006fbe:	d043      	beq.n	30007048 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
30006fc0:	6823      	ldr	r3, [r4, #0]
        spin(1);
30006fc2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30006fc4:	2b00      	cmp	r3, #0
30006fc6:	dbf7      	blt.n	30006fb8 <clkgen_core_slice_switch+0x90>
            return true;
30006fc8:	2001      	movs	r0, #1
        ret = reg_poll_value(core_slice_base_addr,
                             CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
30006fca:	bd38      	pop	{r3, r4, r5, r15}
        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK) != 0) {
30006fcc:	07ea      	lsls	r2, r5, #31
30006fce:	d50d      	bpl.n	30006fec <clkgen_core_slice_switch+0xc4>
            writel(reg_write, core_slice_base_addr);
30006fd0:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK);
30006fd2:	f025 0501 	bic.w	r5, r5, #1
            writel(reg_write, core_slice_base_addr);
30006fd6:	501d      	str	r5, [r3, r0]
30006fd8:	e001      	b.n	30006fde <clkgen_core_slice_switch+0xb6>
    } while (--retrycount);
30006fda:	3a01      	subs	r2, #1
30006fdc:	d006      	beq.n	30006fec <clkgen_core_slice_switch+0xc4>
        v = readl(reg);
30006fde:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30006fe0:	00ed      	lsls	r5, r5, #3
30006fe2:	d5fa      	bpl.n	30006fda <clkgen_core_slice_switch+0xb2>
    RMWREG32(reg, start, width, setvalue);
30006fe4:	581a      	ldr	r2, [r3, r0]
30006fe6:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
30006fea:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
30006fec:	794d      	ldrb	r5, [r1, #5]
        reg_read = readl(core_slice_base_addr);
30006fee:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
30006ff0:	006d      	lsls	r5, r5, #1
30006ff2:	f005 050e 	and.w	r5, r5, #14
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A_MASK))
30006ff6:	f022 020e 	bic.w	r2, r2, #14
30006ffa:	f045 0501 	orr.w	r5, r5, #1
30006ffe:	4315      	orrs	r5, r2
        writel(reg_write, core_slice_base_addr);
30007000:	2264      	movs	r2, #100	; 0x64
30007002:	501d      	str	r5, [r3, r0]
30007004:	e001      	b.n	3000700a <clkgen_core_slice_switch+0xe2>
    } while (--retrycount);
30007006:	3a01      	subs	r2, #1
30007008:	d006      	beq.n	30007018 <clkgen_core_slice_switch+0xf0>
        v = readl(reg);
3000700a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
3000700c:	00ed      	lsls	r5, r5, #3
3000700e:	d5fa      	bpl.n	30007006 <clkgen_core_slice_switch+0xde>
    RMWREG32(reg, start, width, setvalue);
30007010:	581a      	ldr	r2, [r3, r0]
30007012:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
30007016:	501a      	str	r2, [r3, r0]
        reg_read = readl(core_slice_base_addr);
30007018:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
3000701a:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK);
3000701c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
30007020:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
30007022:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
30007024:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
30007026:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
30007028:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
3000702c:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
3000702e:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
30007030:	501a      	str	r2, [r3, r0]
30007032:	e003      	b.n	3000703c <clkgen_core_slice_switch+0x114>
        spin(1);
30007034:	f00d f8dc 	bl	300141f0 <spin>
    } while (--retrycount);
30007038:	3d01      	subs	r5, #1
3000703a:	d005      	beq.n	30007048 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
3000703c:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000703e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007040:	2b00      	cmp	r3, #0
30007042:	dbf7      	blt.n	30007034 <clkgen_core_slice_switch+0x10c>
            return true;
30007044:	2001      	movs	r0, #1
30007046:	e7c0      	b.n	30006fca <clkgen_core_slice_switch+0xa2>
    CLKGEN_ASSERT_PARAMETER(base);
30007048:	2000      	movs	r0, #0
}
3000704a:	bd38      	pop	{r3, r4, r5, r15}

3000704c <clkgen_core_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
3000704c:	b11a      	cbz	r2, 30007056 <clkgen_core_ctl_get+0xa>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
3000704e:	31c0      	adds	r1, #192	; 0xc0
30007050:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
30007052:	580b      	ldr	r3, [r1, r0]
30007054:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
30007056:	2001      	movs	r0, #1
30007058:	4770      	bx	r14
3000705a:	bf00      	nop

3000705c <clkgen_core_ctl_set>:
                         const clkgen_core_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
3000705c:	2a00      	cmp	r2, #0
3000705e:	f000 8081 	beq.w	30007164 <clkgen_core_ctl_set+0x108>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
30007062:	f101 03c0 	add.w	r3, r1, #192	; 0xc0
{
30007066:	b570      	push	{r4, r5, r6, r14}
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
30007068:	031b      	lsls	r3, r3, #12
3000706a:	181c      	adds	r4, r3, r0
        clkgen_core_ctl c;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        c.val = readl(slice_addr);
3000706c:	581e      	ldr	r6, [r3, r0]

        if (c.a_b_sel == 0) {
3000706e:	f3c6 2107 	ubfx	r1, r6, #8, #8
30007072:	f011 0102 	ands.w	r1, r1, #2
30007076:	d13a      	bne.n	300070ee <clkgen_core_ctl_set+0x92>
            //set pre_en_b to 0x0,disable the clock
            if (c.cg_en_b != 0) {
30007078:	03f5      	lsls	r5, r6, #15
3000707a:	d50d      	bpl.n	30007098 <clkgen_core_ctl_set+0x3c>
                c.cg_en_b = 0;
3000707c:	f361 4610 	bfi	r6, r1, #16, #1
                writel(c.val, slice_addr);
30007080:	2164      	movs	r1, #100	; 0x64
30007082:	501e      	str	r6, [r3, r0]
30007084:	e001      	b.n	3000708a <clkgen_core_ctl_set+0x2e>
    } while (--retrycount);
30007086:	3901      	subs	r1, #1
30007088:	d006      	beq.n	30007098 <clkgen_core_ctl_set+0x3c>
        v = readl(reg);
3000708a:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
3000708c:	012d      	lsls	r5, r5, #4
3000708e:	d5fa      	bpl.n	30007086 <clkgen_core_ctl_set+0x2a>
    RMWREG32(reg, start, width, setvalue);
30007090:	5819      	ldr	r1, [r3, r0]
30007092:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
30007096:	5019      	str	r1, [r3, r0]
                reg_poll_clear(slice_addr, CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1,
                               1, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            c.src_sel_b = ctl->src_sel_a;
30007098:	7811      	ldrb	r1, [r2, #0]
3000709a:	f3c1 0542 	ubfx	r5, r1, #1, #3
3000709e:	f365 4653 	bfi	r6, r5, #17, #3
            c.cg_en_b = ctl->cg_en_a;
300070a2:	f3c1 0100 	ubfx	r1, r1, #0, #1
300070a6:	f361 4610 	bfi	r6, r1, #16, #1
            writel(c.val, slice_addr);

            if (c.cg_en_b)
300070aa:	03f1      	lsls	r1, r6, #15
            writel(c.val, slice_addr);
300070ac:	501e      	str	r6, [r3, r0]
            if (c.cg_en_b)
300070ae:	d50a      	bpl.n	300070c6 <clkgen_core_ctl_set+0x6a>
300070b0:	2164      	movs	r1, #100	; 0x64
300070b2:	e001      	b.n	300070b8 <clkgen_core_ctl_set+0x5c>
    } while (--retrycount);
300070b4:	3901      	subs	r1, #1
300070b6:	d006      	beq.n	300070c6 <clkgen_core_ctl_set+0x6a>
        v = readl(reg);
300070b8:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
300070ba:	012d      	lsls	r5, r5, #4
300070bc:	d5fa      	bpl.n	300070b4 <clkgen_core_ctl_set+0x58>
    RMWREG32(reg, start, width, setvalue);
300070be:	5819      	ldr	r1, [r3, r0]
300070c0:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
300070c4:	5019      	str	r1, [r3, r0]
            //invert pre_a_b_sel
            c.a_b_sel = 1;
            writel(c.val, slice_addr);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            c.post_div_num = ctl->post_div_num;
            writel(c.val, slice_addr);
300070c6:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 1;
300070c8:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(c.val, slice_addr);
300070cc:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
300070ce:	7852      	ldrb	r2, [r2, #1]
300070d0:	0892      	lsrs	r2, r2, #2
300070d2:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
300070d6:	501e      	str	r6, [r3, r0]
300070d8:	e003      	b.n	300070e2 <clkgen_core_ctl_set+0x86>
        spin(1);
300070da:	f00d f889 	bl	300141f0 <spin>
    } while (--retrycount);
300070de:	3d01      	subs	r5, #1
300070e0:	d042      	beq.n	30007168 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
300070e2:	6823      	ldr	r3, [r4, #0]
        spin(1);
300070e4:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
300070e6:	2b00      	cmp	r3, #0
300070e8:	dbf7      	blt.n	300070da <clkgen_core_ctl_set+0x7e>
            return true;
300070ea:	2001      	movs	r0, #1
                                 CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        }
    }

    return ret;
}
300070ec:	bd70      	pop	{r4, r5, r6, r15}
            if (c.cg_en_a != 0) {
300070ee:	07f1      	lsls	r1, r6, #31
300070f0:	d50d      	bpl.n	3000710e <clkgen_core_ctl_set+0xb2>
                writel(c.val, slice_addr);
300070f2:	2164      	movs	r1, #100	; 0x64
                c.cg_en_a = 0;
300070f4:	f36f 0600 	bfc	r6, #0, #1
                writel(c.val, slice_addr);
300070f8:	501e      	str	r6, [r3, r0]
300070fa:	e001      	b.n	30007100 <clkgen_core_ctl_set+0xa4>
    } while (--retrycount);
300070fc:	3901      	subs	r1, #1
300070fe:	d006      	beq.n	3000710e <clkgen_core_ctl_set+0xb2>
        v = readl(reg);
30007100:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30007102:	00ed      	lsls	r5, r5, #3
30007104:	d5fa      	bpl.n	300070fc <clkgen_core_ctl_set+0xa0>
    RMWREG32(reg, start, width, setvalue);
30007106:	5819      	ldr	r1, [r3, r0]
30007108:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
3000710c:	5019      	str	r1, [r3, r0]
            c.src_sel_a = ctl->src_sel_a;
3000710e:	7811      	ldrb	r1, [r2, #0]
30007110:	f3c1 0542 	ubfx	r5, r1, #1, #3
30007114:	f365 0643 	bfi	r6, r5, #1, #3
            c.cg_en_a = ctl->cg_en_a;
30007118:	f3c1 0100 	ubfx	r1, r1, #0, #1
3000711c:	f361 0600 	bfi	r6, r1, #0, #1
            if (c.cg_en_a)
30007120:	07f1      	lsls	r1, r6, #31
            writel(c.val, slice_addr);
30007122:	501e      	str	r6, [r3, r0]
            if (c.cg_en_a)
30007124:	d50a      	bpl.n	3000713c <clkgen_core_ctl_set+0xe0>
30007126:	2164      	movs	r1, #100	; 0x64
30007128:	e001      	b.n	3000712e <clkgen_core_ctl_set+0xd2>
    } while (--retrycount);
3000712a:	3901      	subs	r1, #1
3000712c:	d006      	beq.n	3000713c <clkgen_core_ctl_set+0xe0>
        v = readl(reg);
3000712e:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
30007130:	00ed      	lsls	r5, r5, #3
30007132:	d5fa      	bpl.n	3000712a <clkgen_core_ctl_set+0xce>
    RMWREG32(reg, start, width, setvalue);
30007134:	5819      	ldr	r1, [r3, r0]
30007136:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
3000713a:	5019      	str	r1, [r3, r0]
            writel(c.val, slice_addr);
3000713c:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 0;
3000713e:	f36f 2649 	bfc	r6, #9, #1
            writel(c.val, slice_addr);
30007142:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
30007144:	7852      	ldrb	r2, [r2, #1]
30007146:	0892      	lsrs	r2, r2, #2
30007148:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
3000714c:	501e      	str	r6, [r3, r0]
3000714e:	e003      	b.n	30007158 <clkgen_core_ctl_set+0xfc>
        spin(1);
30007150:	f00d f84e 	bl	300141f0 <spin>
    } while (--retrycount);
30007154:	3d01      	subs	r5, #1
30007156:	d007      	beq.n	30007168 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
30007158:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000715a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000715c:	2b00      	cmp	r3, #0
3000715e:	dbf7      	blt.n	30007150 <clkgen_core_ctl_set+0xf4>
            return true;
30007160:	2001      	movs	r0, #1
30007162:	e7c3      	b.n	300070ec <clkgen_core_ctl_set+0x90>
    bool ret = true;
30007164:	2001      	movs	r0, #1
}
30007166:	4770      	bx	r14
    return false;
30007168:	2000      	movs	r0, #0
}
3000716a:	bd70      	pop	{r4, r5, r6, r15}

3000716c <clkgen_mon_ip_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_ip_slice(vaddr_t base, uint16_t ip_slice_idx,
                             clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                             clkgen_slice_mon_ret_type ret_type)
{
3000716c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
30007170:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30007172:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
30007176:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
3000717a:	d006      	beq.n	3000718a <clkgen_mon_ip_slice+0x1e>
3000717c:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
30007180:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
30007184:	bf18      	it	ne
30007186:	2000      	movne	r0, #0
30007188:	d162      	bne.n	30007250 <clkgen_mon_ip_slice+0xe4>
3000718a:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
3000718c:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
30007190:	4692      	mov	r10, r2
30007192:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
30007196:	4689      	mov	r9, r1
30007198:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
3000719a:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    ip_slice_mon_base_addr = base + CLKGEN_IP_SLICE_MON_CTL_OFF;
3000719e:	f500 1be4 	add.w	r11, r0, #1867776	; 0x1c8000
    reg_read = readl(mon_ctl_base_addr);
300071a2:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
300071a4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
300071a8:	6023      	str	r3, [r4, #0]
300071aa:	e003      	b.n	300071b4 <clkgen_mon_ip_slice+0x48>
        spin(1);
300071ac:	f00d f820 	bl	300141f0 <spin>
    } while (--retrycount);
300071b0:	3d01      	subs	r5, #1
300071b2:	d003      	beq.n	300071bc <clkgen_mon_ip_slice+0x50>
        v = readl(reg);
300071b4:	6823      	ldr	r3, [r4, #0]
        spin(1);
300071b6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
300071b8:	015b      	lsls	r3, r3, #5
300071ba:	d5f7      	bpl.n	300071ac <clkgen_mon_ip_slice+0x40>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(ip_slice_mon_base_addr);
300071bc:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read & (~CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL_MASK);
300071c0:	0c09      	lsrs	r1, r1, #16
300071c2:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL(
300071c4:	ea49 0101 	orr.w	r1, r9, r1
                    ip_slice_idx);
    writel(reg_write, ip_slice_mon_base_addr);
300071c8:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
300071cc:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
300071ce:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
                    slice_mon_ip_clk); //ip slice
    writel(reg_write, mon_ctl_base_addr);
300071d2:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
300071d4:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
300071d6:	f1ba 0f00 	cmp.w	r10, #0
300071da:	d03b      	beq.n	30007254 <clkgen_mon_ip_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
300071dc:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
300071e0:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
300071e2:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
300071e4:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
300071e8:	0c1b      	lsrs	r3, r3, #16
300071ea:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
300071ec:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
300071f0:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
300071f2:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
300071f4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
300071f8:	6023      	str	r3, [r4, #0]
300071fa:	e003      	b.n	30007204 <clkgen_mon_ip_slice+0x98>
        spin(1);
300071fc:	f00c fff8 	bl	300141f0 <spin>
    } while (--retrycount);
30007200:	3d01      	subs	r5, #1
30007202:	d003      	beq.n	3000720c <clkgen_mon_ip_slice+0xa0>
        v = readl(reg);
30007204:	6823      	ldr	r3, [r4, #0]
        spin(1);
30007206:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007208:	0159      	lsls	r1, r3, #5
3000720a:	d4f7      	bmi.n	300071fc <clkgen_mon_ip_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
3000720c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
30007210:	e003      	b.n	3000721a <clkgen_mon_ip_slice+0xae>
        spin(1);
30007212:	f00c ffed 	bl	300141f0 <spin>
    } while (--retrycount);
30007216:	3d01      	subs	r5, #1
30007218:	d003      	beq.n	30007222 <clkgen_mon_ip_slice+0xb6>
        v = readl(reg);
3000721a:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000721c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000721e:	011a      	lsls	r2, r3, #4
30007220:	d5f7      	bpl.n	30007212 <clkgen_mon_ip_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
30007222:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
30007224:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
30007228:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
3000722c:	6023      	str	r3, [r4, #0]
3000722e:	e003      	b.n	30007238 <clkgen_mon_ip_slice+0xcc>
        spin(1);
30007230:	f00c ffde 	bl	300141f0 <spin>
    } while (--retrycount);
30007234:	3d01      	subs	r5, #1
30007236:	d003      	beq.n	30007240 <clkgen_mon_ip_slice+0xd4>
        v = readl(reg);
30007238:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000723a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000723c:	00db      	lsls	r3, r3, #3
3000723e:	d4f7      	bmi.n	30007230 <clkgen_mon_ip_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
30007240:	b967      	cbnz	r7, 3000725c <clkgen_mon_ip_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
30007242:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
30007246:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
30007248:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
3000724a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
3000724e:	6023      	str	r3, [r4, #0]
    return ret;
}
30007250:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
30007254:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
30007258:	6023      	str	r3, [r4, #0]
3000725a:	e7c2      	b.n	300071e2 <clkgen_mon_ip_slice+0x76>
    else if (mon_avg_freq == ret_type) {
3000725c:	2f01      	cmp	r7, #1
3000725e:	d00e      	beq.n	3000727e <clkgen_mon_ip_slice+0x112>
    else if (mon_min_freq == ret_type) {
30007260:	2f02      	cmp	r7, #2
30007262:	d008      	beq.n	30007276 <clkgen_mon_ip_slice+0x10a>
    else if (mon_max_duty == ret_type) {
30007264:	2f03      	cmp	r7, #3
30007266:	d010      	beq.n	3000728a <clkgen_mon_ip_slice+0x11e>
    else if (mon_min_duty == ret_type) {
30007268:	2f04      	cmp	r7, #4
        ret = 0;
3000726a:	bf12      	itee	ne
3000726c:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
3000726e:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
30007272:	6830      	ldreq	r0, [r6, #0]
30007274:	e7e8      	b.n	30007248 <clkgen_mon_ip_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
30007276:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
3000727a:	6830      	ldr	r0, [r6, #0]
3000727c:	e7e4      	b.n	30007248 <clkgen_mon_ip_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
3000727e:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
30007282:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
30007286:	6830      	ldr	r0, [r6, #0]
30007288:	e7de      	b.n	30007248 <clkgen_mon_ip_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
3000728a:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
3000728e:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
30007292:	6830      	ldr	r0, [r6, #0]
30007294:	e7d8      	b.n	30007248 <clkgen_mon_ip_slice+0xdc>
30007296:	bf00      	nop

30007298 <clkgen_mon_bus_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_bus_slice(vaddr_t base, uint16_t bus_slice_idx,
                              clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                              clkgen_slice_mon_ret_type ret_type)
{
30007298:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000729c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
3000729e:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
300072a2:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
300072a6:	d006      	beq.n	300072b6 <clkgen_mon_bus_slice+0x1e>
300072a8:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
300072ac:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
300072b0:	bf18      	it	ne
300072b2:	2000      	movne	r0, #0
300072b4:	d165      	bne.n	30007382 <clkgen_mon_bus_slice+0xea>
300072b6:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
300072b8:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
300072bc:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
300072c0:	4693      	mov	r11, r2
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
300072c2:	f500 1ae4 	add.w	r10, r0, #1867776	; 0x1c8000
300072c6:	4689      	mov	r9, r1
300072c8:	4606      	mov	r6, r0
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
300072ca:	6823      	ldr	r3, [r4, #0]
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
300072cc:	f50a 5a80 	add.w	r10, r10, #4096	; 0x1000
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
300072d0:	2564      	movs	r5, #100	; 0x64
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
300072d2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
300072d6:	6023      	str	r3, [r4, #0]
300072d8:	e003      	b.n	300072e2 <clkgen_mon_bus_slice+0x4a>
        spin(1);
300072da:	f00c ff89 	bl	300141f0 <spin>
    } while (--retrycount);
300072de:	3d01      	subs	r5, #1
300072e0:	d003      	beq.n	300072ea <clkgen_mon_bus_slice+0x52>
        v = readl(reg);
300072e2:	6823      	ldr	r3, [r4, #0]
        spin(1);
300072e4:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
300072e6:	015b      	lsls	r3, r3, #5
300072e8:	d5f7      	bpl.n	300072da <clkgen_mon_bus_slice+0x42>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 100);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(bus_slice_mon_base_addr);
300072ea:	f8da 1000 	ldr.w	r1, [r10]
    reg_write = reg_read & (~CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL_MASK);
300072ee:	0c09      	lsrs	r1, r1, #16
300072f0:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL(
300072f2:	ea49 0101 	orr.w	r1, r9, r1
                    bus_slice_idx);
    writel(reg_write, bus_slice_mon_base_addr);
300072f6:	f8ca 1000 	str.w	r1, [r10]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
300072fa:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
300072fc:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
30007300:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
                    slice_mon_bus_clk); //bus slice
    writel(reg_write, mon_ctl_base_addr);
30007304:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
30007306:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
30007308:	f1bb 0f00 	cmp.w	r11, #0
3000730c:	d03b      	beq.n	30007386 <clkgen_mon_bus_slice+0xee>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
3000730e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
30007312:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
30007314:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
30007316:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
3000731a:	0c1b      	lsrs	r3, r3, #16
3000731c:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
3000731e:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
30007322:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
30007324:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
30007326:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
3000732a:	6023      	str	r3, [r4, #0]
3000732c:	e003      	b.n	30007336 <clkgen_mon_bus_slice+0x9e>
        spin(1);
3000732e:	f00c ff5f 	bl	300141f0 <spin>
    } while (--retrycount);
30007332:	3d01      	subs	r5, #1
30007334:	d003      	beq.n	3000733e <clkgen_mon_bus_slice+0xa6>
        v = readl(reg);
30007336:	6823      	ldr	r3, [r4, #0]
        spin(1);
30007338:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000733a:	0159      	lsls	r1, r3, #5
3000733c:	d4f7      	bmi.n	3000732e <clkgen_mon_bus_slice+0x96>
    writel(reg_write, mon_ctl_base_addr);
3000733e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
30007342:	e003      	b.n	3000734c <clkgen_mon_bus_slice+0xb4>
        spin(1);
30007344:	f00c ff54 	bl	300141f0 <spin>
    } while (--retrycount);
30007348:	3d01      	subs	r5, #1
3000734a:	d003      	beq.n	30007354 <clkgen_mon_bus_slice+0xbc>
        v = readl(reg);
3000734c:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000734e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007350:	011a      	lsls	r2, r3, #4
30007352:	d5f7      	bpl.n	30007344 <clkgen_mon_bus_slice+0xac>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
30007354:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
30007356:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
3000735a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
3000735e:	6023      	str	r3, [r4, #0]
30007360:	e003      	b.n	3000736a <clkgen_mon_bus_slice+0xd2>
        spin(1);
30007362:	f00c ff45 	bl	300141f0 <spin>
    } while (--retrycount);
30007366:	3d01      	subs	r5, #1
30007368:	d003      	beq.n	30007372 <clkgen_mon_bus_slice+0xda>
        v = readl(reg);
3000736a:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000736c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000736e:	00db      	lsls	r3, r3, #3
30007370:	d4f7      	bmi.n	30007362 <clkgen_mon_bus_slice+0xca>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
30007372:	b967      	cbnz	r7, 3000738e <clkgen_mon_bus_slice+0xf6>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
30007374:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
30007378:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
3000737a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
3000737c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
30007380:	6023      	str	r3, [r4, #0]
    return ret;
}
30007382:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
30007386:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
3000738a:	6023      	str	r3, [r4, #0]
3000738c:	e7c2      	b.n	30007314 <clkgen_mon_bus_slice+0x7c>
    else if (mon_avg_freq == ret_type) {
3000738e:	2f01      	cmp	r7, #1
30007390:	d00e      	beq.n	300073b0 <clkgen_mon_bus_slice+0x118>
    else if (mon_min_freq == ret_type) {
30007392:	2f02      	cmp	r7, #2
30007394:	d008      	beq.n	300073a8 <clkgen_mon_bus_slice+0x110>
    else if (mon_max_duty == ret_type) {
30007396:	2f03      	cmp	r7, #3
30007398:	d010      	beq.n	300073bc <clkgen_mon_bus_slice+0x124>
    else if (mon_min_duty == ret_type) {
3000739a:	2f04      	cmp	r7, #4
        ret = 0;
3000739c:	bf12      	itee	ne
3000739e:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
300073a0:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
300073a4:	6830      	ldreq	r0, [r6, #0]
300073a6:	e7e8      	b.n	3000737a <clkgen_mon_bus_slice+0xe2>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
300073a8:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
300073ac:	6830      	ldr	r0, [r6, #0]
300073ae:	e7e4      	b.n	3000737a <clkgen_mon_bus_slice+0xe2>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
300073b0:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
300073b4:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
300073b8:	6830      	ldr	r0, [r6, #0]
300073ba:	e7de      	b.n	3000737a <clkgen_mon_bus_slice+0xe2>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
300073bc:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
300073c0:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
300073c4:	6830      	ldr	r0, [r6, #0]
300073c6:	e7d8      	b.n	3000737a <clkgen_mon_bus_slice+0xe2>

300073c8 <clkgen_mon_core_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_core_slice(vaddr_t base, uint16_t core_slice_idx,
                               clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                               clkgen_slice_mon_ret_type ret_type)
{
300073c8:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
300073cc:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
300073ce:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
300073d2:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
300073d6:	d006      	beq.n	300073e6 <clkgen_mon_core_slice+0x1e>
300073d8:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
300073dc:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
300073e0:	bf18      	it	ne
300073e2:	2000      	movne	r0, #0
300073e4:	d162      	bne.n	300074ac <clkgen_mon_core_slice+0xe4>
300073e6:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
    core_slice_mon_base_addr = base + CLKGEN_CORE_SLICE_MON_CTL_OFF;
300073e8:	f500 1be5 	add.w	r11, r0, #1875968	; 0x1ca000
300073ec:	4692      	mov	r10, r2
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
300073ee:	f50b 5480 	add.w	r4, r11, #4096	; 0x1000
300073f2:	4689      	mov	r9, r1
300073f4:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
300073f6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_read = readl(mon_ctl_base_addr);
300073fa:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
300073fc:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
30007400:	6023      	str	r3, [r4, #0]
30007402:	e003      	b.n	3000740c <clkgen_mon_core_slice+0x44>
        spin(1);
30007404:	f00c fef4 	bl	300141f0 <spin>
    } while (--retrycount);
30007408:	3d01      	subs	r5, #1
3000740a:	d003      	beq.n	30007414 <clkgen_mon_core_slice+0x4c>
        v = readl(reg);
3000740c:	6823      	ldr	r3, [r4, #0]
        spin(1);
3000740e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007410:	015b      	lsls	r3, r3, #5
30007412:	d5f7      	bpl.n	30007404 <clkgen_mon_core_slice+0x3c>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(core_slice_mon_base_addr);
30007414:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read &
30007418:	0c09      	lsrs	r1, r1, #16
3000741a:	0409      	lsls	r1, r1, #16
                (~CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL_MASK);
    reg_write = reg_write | CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL(
3000741c:	ea49 0101 	orr.w	r1, r9, r1
                    core_slice_idx);
    writel(reg_write, core_slice_mon_base_addr);
30007420:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
30007424:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
30007426:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
3000742a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
                    slice_mon_core_clk); //core slice
    writel(reg_write, mon_ctl_base_addr);
3000742e:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
30007430:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
30007432:	f1ba 0f00 	cmp.w	r10, #0
30007436:	d03b      	beq.n	300074b0 <clkgen_mon_core_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
30007438:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
3000743c:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
3000743e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
30007440:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
30007444:	0c1b      	lsrs	r3, r3, #16
30007446:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
30007448:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
3000744c:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
3000744e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
30007450:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
30007454:	6023      	str	r3, [r4, #0]
30007456:	e003      	b.n	30007460 <clkgen_mon_core_slice+0x98>
        spin(1);
30007458:	f00c feca 	bl	300141f0 <spin>
    } while (--retrycount);
3000745c:	3d01      	subs	r5, #1
3000745e:	d003      	beq.n	30007468 <clkgen_mon_core_slice+0xa0>
        v = readl(reg);
30007460:	6823      	ldr	r3, [r4, #0]
        spin(1);
30007462:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007464:	0159      	lsls	r1, r3, #5
30007466:	d4f7      	bmi.n	30007458 <clkgen_mon_core_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
30007468:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
3000746c:	e003      	b.n	30007476 <clkgen_mon_core_slice+0xae>
        spin(1);
3000746e:	f00c febf 	bl	300141f0 <spin>
    } while (--retrycount);
30007472:	3d01      	subs	r5, #1
30007474:	d003      	beq.n	3000747e <clkgen_mon_core_slice+0xb6>
        v = readl(reg);
30007476:	6823      	ldr	r3, [r4, #0]
        spin(1);
30007478:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
3000747a:	011a      	lsls	r2, r3, #4
3000747c:	d5f7      	bpl.n	3000746e <clkgen_mon_core_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
3000747e:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
30007480:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
30007484:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
30007488:	6023      	str	r3, [r4, #0]
3000748a:	e003      	b.n	30007494 <clkgen_mon_core_slice+0xcc>
        spin(1);
3000748c:	f00c feb0 	bl	300141f0 <spin>
    } while (--retrycount);
30007490:	3d01      	subs	r5, #1
30007492:	d003      	beq.n	3000749c <clkgen_mon_core_slice+0xd4>
        v = readl(reg);
30007494:	6823      	ldr	r3, [r4, #0]
        spin(1);
30007496:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
30007498:	00db      	lsls	r3, r3, #3
3000749a:	d4f7      	bmi.n	3000748c <clkgen_mon_core_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
3000749c:	b967      	cbnz	r7, 300074b8 <clkgen_mon_core_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
3000749e:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
300074a2:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
300074a4:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
300074a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
300074aa:	6023      	str	r3, [r4, #0]
    return ret;
}
300074ac:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
300074b0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
300074b4:	6023      	str	r3, [r4, #0]
300074b6:	e7c2      	b.n	3000743e <clkgen_mon_core_slice+0x76>
    else if (mon_avg_freq == ret_type) {
300074b8:	2f01      	cmp	r7, #1
300074ba:	d00e      	beq.n	300074da <clkgen_mon_core_slice+0x112>
    else if (mon_min_freq == ret_type) {
300074bc:	2f02      	cmp	r7, #2
300074be:	d008      	beq.n	300074d2 <clkgen_mon_core_slice+0x10a>
    else if (mon_max_duty == ret_type) {
300074c0:	2f03      	cmp	r7, #3
300074c2:	d010      	beq.n	300074e6 <clkgen_mon_core_slice+0x11e>
    else if (mon_min_duty == ret_type) {
300074c4:	2f04      	cmp	r7, #4
        ret = 0;
300074c6:	bf12      	itee	ne
300074c8:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
300074ca:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
300074ce:	6830      	ldreq	r0, [r6, #0]
300074d0:	e7e8      	b.n	300074a4 <clkgen_mon_core_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
300074d2:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
300074d6:	6830      	ldr	r0, [r6, #0]
300074d8:	e7e4      	b.n	300074a4 <clkgen_mon_core_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
300074da:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
300074de:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
300074e2:	6830      	ldr	r0, [r6, #0]
300074e4:	e7de      	b.n	300074a4 <clkgen_mon_core_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
300074e6:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
300074ea:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
300074ee:	6830      	ldr	r0, [r6, #0]
300074f0:	e7d8      	b.n	300074a4 <clkgen_mon_core_slice+0xdc>
300074f2:	bf00      	nop

300074f4 <clkgen_uuu_clock_wrapper>:
    vaddr_t uuu_wrapper_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if (base != CKGEN_SOC_BASE) {
300074f4:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
{
300074f8:	b4f0      	push	{r4, r5, r6, r7}
300074fa:	f89d 5010 	ldrb.w	r5, [r13, #16]
        LTRACEF("base paramenter error \n");
        return 0;
300074fe:	bf18      	it	ne
30007500:	2000      	movne	r0, #0
    if (base != CKGEN_SOC_BASE) {
30007502:	d001      	beq.n	30007508 <clkgen_uuu_clock_wrapper+0x14>
#endif
    }

    ret = true;
    return ret;
}
30007504:	bcf0      	pop	{r4, r5, r6, r7}
30007506:	4770      	bx	r14
30007508:	7814      	ldrb	r4, [r2, #0]
3000750a:	0324      	lsls	r4, r4, #12
3000750c:	7856      	ldrb	r6, [r2, #1]
3000750e:	0236      	lsls	r6, r6, #8
30007510:	b2a4      	uxth	r4, r4
30007512:	7890      	ldrb	r0, [r2, #2]
30007514:	f406 6670 	and.w	r6, r6, #3840	; 0xf00
30007518:	78d7      	ldrb	r7, [r2, #3]
3000751a:	0100      	lsls	r0, r0, #4
3000751c:	ea44 0206 	orr.w	r2, r4, r6
    uuu_wrapper_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(
30007520:	0309      	lsls	r1, r1, #12
30007522:	f007 040f 	and.w	r4, r7, #15
30007526:	f101 4176 	add.w	r1, r1, #4127195136	; 0xf6000000
3000752a:	042d      	lsls	r5, r5, #16
3000752c:	4322      	orrs	r2, r4
3000752e:	b2c0      	uxtb	r0, r0
30007530:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
30007534:	f405 2570 	and.w	r5, r5, #983040	; 0xf0000
30007538:	4302      	orrs	r2, r0
    if (low_power_mode) {
3000753a:	b963      	cbnz	r3, 30007556 <clkgen_uuu_clock_wrapper+0x62>
        reg_read = readl(uuu_wrapper_base_addr);
3000753c:	680b      	ldr	r3, [r1, #0]
    return ret;
3000753e:	2001      	movs	r0, #1
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(
30007540:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type << 0);
30007544:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
30007546:	600d      	str	r5, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
30007548:	680b      	ldr	r3, [r1, #0]
}
3000754a:	bcf0      	pop	{r4, r5, r6, r7}
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
3000754c:	0c1b      	lsrs	r3, r3, #16
3000754e:	041b      	lsls	r3, r3, #16
        reg_write |= CLKGEN_UUU_SLICE_M_DIV_NUM(gasket_div->m_div_num)
30007550:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
30007552:	600a      	str	r2, [r1, #0]
}
30007554:	4770      	bx	r14
        reg_read = readl(uuu_wrapper_base_addr);
30007556:	680c      	ldr	r4, [r1, #0]
    return ret;
30007558:	4618      	mov	r0, r3
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
3000755a:	0c23      	lsrs	r3, r4, #16
3000755c:	041b      	lsls	r3, r3, #16
        reg_write |=
3000755e:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
30007560:	600a      	str	r2, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
30007562:	680b      	ldr	r3, [r1, #0]
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(0x3)));
30007564:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type);
30007568:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
3000756a:	600d      	str	r5, [r1, #0]
}
3000756c:	bcf0      	pop	{r4, r5, r6, r7}
3000756e:	4770      	bx	r14

30007570 <clkgen_uuu_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
30007570:	b122      	cbz	r2, 3000757c <clkgen_uuu_ctl_get+0xc>
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
30007572:	f501 71c0 	add.w	r1, r1, #384	; 0x180
30007576:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
30007578:	580b      	ldr	r3, [r1, r0]
3000757a:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
3000757c:	2001      	movs	r0, #1
3000757e:	4770      	bx	r14

30007580 <clkgen_uuu_ctl_set>:
                        const clkgen_uuu_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
30007580:	b33a      	cbz	r2, 300075d2 <clkgen_uuu_ctl_set+0x52>
        clkgen_uuu_ctl c;
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
30007582:	f501 71c0 	add.w	r1, r1, #384	; 0x180
{
30007586:	b470      	push	{r4, r5, r6}
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
30007588:	0309      	lsls	r1, r1, #12
        // 1.Program CKGEN_SOC corresponding slice to get proper clk_ckgen frequency. hal process
        //wait#######################
        // 2.Release SS reset(some ss don't have separate SS reset). set reset to 1 release reset,hal process
        //wait#######################
        // 3.Set clk_sel[0] and clk_sel[1]both to 0x0(default of both of them are 0x0)
        c.val = readl(slice_addr);
3000758a:	580b      	ldr	r3, [r1, r0]
        c.uuu_sel0 = 0;
3000758c:	f36f 4310 	bfc	r3, #16, #1
        c.uuu_sel1 = 0;
30007590:	f36f 4351 	bfc	r3, #17, #1
        writel(c.val, slice_addr);
30007594:	500b      	str	r3, [r1, r0]
        // 4.Program PLL_x to enable PLL and get the proper frequency.(see PLL programming guide).
        // call pll func enable pll clock,
        //wait#######################
        // 5.Set Div_m/n/p/q to the proper value before change the clock source from ckgen to PLL.(Div_m/n/p/q can be changed on-the-fly.)
        c.m_div = ctl->m_div;
30007596:	7855      	ldrb	r5, [r2, #1]
30007598:	092e      	lsrs	r6, r5, #4
        c.n_div = ctl->n_div;
        c.p_div = ctl->p_div;
3000759a:	7814      	ldrb	r4, [r2, #0]
        c.m_div = ctl->m_div;
3000759c:	f366 330f 	bfi	r3, r6, #12, #4
        c.n_div = ctl->n_div;
300075a0:	f3c5 0503 	ubfx	r5, r5, #0, #4
300075a4:	f365 230b 	bfi	r3, r5, #8, #4
        c.p_div = ctl->p_div;
300075a8:	0925      	lsrs	r5, r4, #4
300075aa:	f365 1307 	bfi	r3, r5, #4, #4
        c.q_div = ctl->q_div;
300075ae:	f3c4 0403 	ubfx	r4, r4, #0, #4
300075b2:	f364 0303 	bfi	r3, r4, #0, #4
        writel(c.val, slice_addr);
300075b6:	500b      	str	r3, [r1, r0]
        // 6.Set clk_sel[0] to 0x1 to set clk_out_1/2/3 source from PLL_x.
        // 7.Set clk_sel[1] to 0x1 to set clk_out_0 source from PLL_x.
        c.uuu_sel0 = ctl->uuu_sel0;
300075b8:	7892      	ldrb	r2, [r2, #2]
300075ba:	f3c2 0400 	ubfx	r4, r2, #0, #1
300075be:	f364 4310 	bfi	r3, r4, #16, #1
        c.uuu_sel1 = ctl->uuu_sel1;
300075c2:	f3c2 0240 	ubfx	r2, r2, #1, #1
300075c6:	f362 4351 	bfi	r3, r2, #17, #1
        writel(c.val, slice_addr);
    }

    return ret;
}
300075ca:	bc70      	pop	{r4, r5, r6}
        writel(c.val, slice_addr);
300075cc:	500b      	str	r3, [r1, r0]
}
300075ce:	2001      	movs	r0, #1
300075d0:	4770      	bx	r14
300075d2:	2001      	movs	r0, #1
300075d4:	4770      	bx	r14
300075d6:	bf00      	nop

300075d8 <clkgen_ipslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_ip_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
300075d8:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
300075dc:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
300075e0:	d004      	beq.n	300075ec <clkgen_ipslice_debug_enable+0x14>
300075e2:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
300075e6:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
300075ea:	d111      	bne.n	30007610 <clkgen_ipslice_debug_enable+0x38>
{
300075ec:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_ip_base_addr = base + CLKGEN_IP_SLICE_DBG_CTL_OFF;
300075ee:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
300075f2:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
300075f6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_ip_base_addr);
300075fa:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_ip_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
300075fc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
30007600:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
30007602:	4329      	orrs	r1, r5
    writel(reg_write, debug_ip_base_addr);
30007604:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
30007606:	6819      	ldr	r1, [r3, #0]
}
30007608:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
3000760a:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
3000760c:	601a      	str	r2, [r3, #0]
}
3000760e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
30007610:	2000      	movs	r0, #0
}
30007612:	4770      	bx	r14

30007614 <clkgen_ipslice_debug_disable>:
{
    vaddr_t debug_crtl_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30007614:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
30007618:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
3000761c:	d004      	beq.n	30007628 <clkgen_ipslice_debug_disable+0x14>
3000761e:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
30007622:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
30007626:	d109      	bne.n	3000763c <clkgen_ipslice_debug_disable+0x28>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
30007628:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    writel(reg_write, debug_crtl_base_addr);
    return true;
3000762c:	2001      	movs	r0, #1
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
3000762e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_crtl_base_addr);
30007632:	681a      	ldr	r2, [r3, #0]
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
30007634:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_crtl_base_addr);
30007638:	601a      	str	r2, [r3, #0]
    return true;
3000763a:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
3000763c:	2000      	movs	r0, #0
}
3000763e:	4770      	bx	r14

30007640 <clkgen_busslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_bus_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30007640:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
30007644:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
30007648:	d004      	beq.n	30007654 <clkgen_busslice_debug_enable+0x14>
3000764a:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
3000764e:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
30007652:	d113      	bne.n	3000767c <clkgen_busslice_debug_enable+0x3c>
{
30007654:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_bus_base_addr = base + CLKGEN_BUS_SLICE_DBG_CTL_OFF;
30007656:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
3000765a:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
3000765e:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
30007662:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_bus_base_addr);
30007666:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_bus_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
30007668:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
3000766c:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
3000766e:	4329      	orrs	r1, r5
    writel(reg_write, debug_bus_base_addr);
30007670:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
30007672:	6819      	ldr	r1, [r3, #0]
}
30007674:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
30007676:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
30007678:	601a      	str	r2, [r3, #0]
}
3000767a:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
3000767c:	2000      	movs	r0, #0
}
3000767e:	4770      	bx	r14

30007680 <clkgen_busslice_debug_disable>:
30007680:	f7ff bfc8 	b.w	30007614 <clkgen_ipslice_debug_disable>

30007684 <clkgen_coreslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_core_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30007684:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
30007688:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
3000768c:	d004      	beq.n	30007698 <clkgen_coreslice_debug_enable+0x14>
3000768e:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
30007692:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
30007696:	d10f      	bne.n	300076b8 <clkgen_coreslice_debug_enable+0x34>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_core_base_addr = base + CLKGEN_CORE_SLICE_DBG_CTL_OFF;
30007698:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
{
3000769c:	b430      	push	{r4, r5}
    reg_read = readl(debug_core_base_addr);
3000769e:	681d      	ldr	r5, [r3, #0]
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
300076a0:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
300076a4:	2001      	movs	r0, #1
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
300076a6:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
300076aa:	4329      	orrs	r1, r5
    writel(reg_write, debug_core_base_addr);
300076ac:	6019      	str	r1, [r3, #0]
    reg_read = readl(debug_crtl_base_addr);
300076ae:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
300076b0:	431a      	orrs	r2, r3
    writel(reg_write, debug_crtl_base_addr);
300076b2:	6022      	str	r2, [r4, #0]
}
300076b4:	bc30      	pop	{r4, r5}
300076b6:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
300076b8:	2000      	movs	r0, #0
}
300076ba:	4770      	bx	r14

300076bc <clkgen_coreslice_debug_disable>:
300076bc:	f7ff bfaa 	b.w	30007614 <clkgen_ipslice_debug_disable>

300076c0 <clkgen_uuuslice_debug_enable>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_enable(vaddr_t base, uint16_t slice_idx,
                                  uint8_t dbg_div)
{
300076c0:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
300076c2:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
300076c6:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
300076ca:	d004      	beq.n	300076d6 <clkgen_uuuslice_debug_enable+0x16>
300076cc:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
300076d0:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
300076d4:	d111      	bne.n	300076fa <clkgen_uuuslice_debug_enable+0x3a>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
300076d6:	0309      	lsls	r1, r1, #12
300076d8:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
{
300076dc:	b410      	push	{r4}
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
300076de:	58cc      	ldr	r4, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1);
    reg_write = reg_write & (~(CLKGEN_UUU_SLICE_DBG_DIV_NUM(0xF)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
300076e0:	06d2      	lsls	r2, r2, #27
    writel(reg_write, debug_uuu_base_addr);
    return true;
300076e2:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
300076e4:	f002 42f0 	and.w	r2, r2, #2013265920	; 0x78000000
300076e8:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
300076ec:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
300076f0:	4322      	orrs	r2, r4
}
300076f2:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(reg_write, debug_uuu_base_addr);
300076f6:	50ca      	str	r2, [r1, r3]
}
300076f8:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
300076fa:	2000      	movs	r0, #0
}
300076fc:	4770      	bx	r14
300076fe:	bf00      	nop

30007700 <clkgen_uuuslice_debug_disable>:
//! \return true/false
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_disable(vaddr_t base, uint16_t slice_idx)
{
30007700:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
30007702:	f020 6280 	bic.w	r2, r0, #67108864	; 0x4000000
30007706:	f1b2 4f78 	cmp.w	r2, #4160749568	; 0xf8000000
3000770a:	d004      	beq.n	30007716 <clkgen_uuuslice_debug_disable+0x16>
3000770c:	f420 1200 	bic.w	r2, r0, #2097152	; 0x200000
30007710:	f1b2 4f76 	cmp.w	r2, #4127195136	; 0xf6000000
30007714:	d108      	bne.n	30007728 <clkgen_uuuslice_debug_disable+0x28>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    writel(reg_write, debug_uuu_base_addr);
    return true;
30007716:	2001      	movs	r0, #1
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
30007718:	0309      	lsls	r1, r1, #12
3000771a:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
    reg_read = readl(debug_uuu_base_addr);
3000771e:	58ca      	ldr	r2, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
30007720:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_uuu_base_addr);
30007724:	50ca      	str	r2, [r1, r3]
    return true;
30007726:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
30007728:	2000      	movs	r0, #0
}
3000772a:	4770      	bx	r14

3000772c <platform_earlycopy>:

extern struct early_copy_section __earlycopy_start;
extern struct early_copy_section __earlycopy_end;

void platform_earlycopy(void)
{
3000772c:	b570      	push	{r4, r5, r6, r14}
    struct early_copy_section *p;

    for (p = &__earlycopy_start; p < &__earlycopy_end; p++) {
3000772e:	f242 04f0 	movw	r4, #8432	; 0x20f0
30007732:	f242 06fc 	movw	r6, #8444	; 0x20fc
30007736:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000773a:	f2c3 0602 	movt	r6, #12290	; 0x3002
3000773e:	42b4      	cmp	r4, r6
30007740:	d211      	bcs.n	30007766 <platform_earlycopy+0x3a>
30007742:	340c      	adds	r4, #12
        LTRACEF_LEVEL(3, "vma 0x%x, lma 0x%x, size %d\n",
            p->vma, p->lma, p->size);

        memcpy((void *)p->vma, (void *)p->lma, p->size);
30007744:	f854 2c08 	ldr.w	r2, [r4, #-8]
30007748:	4625      	mov	r5, r4
3000774a:	f854 1c04 	ldr.w	r1, [r4, #-4]
3000774e:	f854 0c0c 	ldr.w	r0, [r4, #-12]
30007752:	f00d e888 	blx	30014864 <memcpy>
        arch_clean_cache_range((addr_t)p->vma, p->size);
30007756:	e954 0103 	ldrd	r0, r1, [r4, #-12]
3000775a:	f7fa e9d8 	blx	30001b0c <arch_clean_cache_range>
    for (p = &__earlycopy_start; p < &__earlycopy_end; p++) {
3000775e:	42b5      	cmp	r5, r6
30007760:	f104 040c 	add.w	r4, r4, #12
30007764:	d3ee      	bcc.n	30007744 <platform_earlycopy+0x18>
    }
}
30007766:	bd70      	pop	{r4, r5, r6, r15}

30007768 <fuse_program_raw>:
{
    addr_t b = soc_get_module_base(FUSE_CTRL1);

    DBG("%s: index=%d, v=0x%x\n", __FUNCTION__, index, v);

    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
30007768:	221c      	movs	r2, #28
3000776a:	f2cf 0201 	movt	r2, #61441	; 0xf001
{
3000776e:	b470      	push	{r4, r5, r6}
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
30007770:	6813      	ldr	r3, [r2, #0]
30007772:	07dc      	lsls	r4, r3, #31
30007774:	d4fc      	bmi.n	30007770 <fuse_program_raw+0x8>
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007776:	2501      	movs	r5, #1
    do {
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007778:	231c      	movs	r3, #28
3000777a:	462c      	mov	r4, r5
3000777c:	f2cf 0301 	movt	r3, #61441	; 0xf001
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007780:	6015      	str	r5, [r2, #0]
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007782:	601c      	str	r4, [r3, #0]
    } while (!(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_STATUS));
30007784:	681a      	ldr	r2, [r3, #0]
30007786:	0752      	lsls	r2, r2, #29
30007788:	d5fb      	bpl.n	30007782 <fuse_program_raw+0x1a>

    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
3000778a:	2200      	movs	r2, #0
3000778c:	f2cf 0201 	movt	r2, #61441	; 0xf001
30007790:	6813      	ldr	r3, [r2, #0]
30007792:	051b      	lsls	r3, r3, #20
30007794:	d4fc      	bmi.n	30007790 <fuse_program_raw+0x28>

    uint32_t ctrl = readl(b + FUSE_CTRL_OFF);
30007796:	6813      	ldr	r3, [r2, #0]
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
30007798:	2408      	movs	r4, #8
3000779a:	f2cf 0401 	movt	r4, #61441	; 0xf001

    ctrl &= ~FM_FUSE_CTRL_ADDR;
3000779e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
300077a2:	f043 4314 	orr.w	r3, r3, #2483027968	; 0x94000000
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
300077a6:	6825      	ldr	r5, [r4, #0]
    ctrl |= FV_FUSE_CTRL_ADDR(index) | FV_FUSE_CTRL_PROG_KEY(FUSE_PROG_KEY);
300077a8:	b2c0      	uxtb	r0, r0
    writel(ctrl, b + FUSE_CTRL_OFF);

    writel(v, b + PROG_DATA_OFF);
300077aa:	2604      	movs	r6, #4
300077ac:	f443 03b0 	orr.w	r3, r3, #5767168	; 0x580000
    ctrl |= FV_FUSE_CTRL_ADDR(index) | FV_FUSE_CTRL_PROG_KEY(FUSE_PROG_KEY);
300077b0:	4303      	orrs	r3, r0

    trig |= BM_FUSE_TRIG_PROG;
    writel(trig, b + FUSE_TRIG_OFF);

    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
300077b2:	2000      	movs	r0, #0
    writel(v, b + PROG_DATA_OFF);
300077b4:	f2cf 0601 	movt	r6, #61441	; 0xf001
    trig |= BM_FUSE_TRIG_PROG;
300077b8:	f045 0504 	orr.w	r5, r5, #4
    writel(ctrl, b + FUSE_CTRL_OFF);
300077bc:	6013      	str	r3, [r2, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
300077be:	f2cf 0001 	movt	r0, #61441	; 0xf001
    writel(v, b + PROG_DATA_OFF);
300077c2:	6031      	str	r1, [r6, #0]
    writel(trig, b + FUSE_TRIG_OFF);
300077c4:	6025      	str	r5, [r4, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
300077c6:	6803      	ldr	r3, [r0, #0]
300077c8:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
300077cc:	d1fb      	bne.n	300077c6 <fuse_program_raw+0x5e>

    uint32_t res = (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_ERROR) ? -1 : 0;
300077ce:	6800      	ldr	r0, [r0, #0]

    writel(0, b + SEMA_LOCK_OFF);
300077d0:	221c      	movs	r2, #28
300077d2:	f2cf 0201 	movt	r2, #61441	; 0xf001

    return res;
}
300077d6:	f340 3000 	sbfx	r0, r0, #12, #1
    writel(0, b + SEMA_LOCK_OFF);
300077da:	6013      	str	r3, [r2, #0]
}
300077dc:	bc70      	pop	{r4, r5, r6}
300077de:	4770      	bx	r14

300077e0 <fuse_read>:
    return readl(base + FUSE0_OFFSET + index * 4);
300077e0:	0080      	lsls	r0, r0, #2
300077e2:	f100 4070 	add.w	r0, r0, #4026531840	; 0xf0000000
300077e6:	f500 3088 	add.w	r0, r0, #69632	; 0x11000
300077ea:	6800      	ldr	r0, [r0, #0]
}
300077ec:	4770      	bx	r14
300077ee:	bf00      	nop

300077f0 <fuse_sense>:
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
300077f0:	221c      	movs	r2, #28
300077f2:	f2cf 0201 	movt	r2, #61441	; 0xf001
{
300077f6:	b430      	push	{r4, r5}
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
300077f8:	6813      	ldr	r3, [r2, #0]
300077fa:	07dc      	lsls	r4, r3, #31
300077fc:	d4fc      	bmi.n	300077f8 <fuse_sense+0x8>
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
300077fe:	2501      	movs	r5, #1
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007800:	231c      	movs	r3, #28
30007802:	462c      	mov	r4, r5
30007804:	f2cf 0301 	movt	r3, #61441	; 0xf001
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
30007808:	6015      	str	r5, [r2, #0]
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
3000780a:	601c      	str	r4, [r3, #0]
    } while (!(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_STATUS));
3000780c:	681a      	ldr	r2, [r3, #0]
3000780e:	0752      	lsls	r2, r2, #29
30007810:	d5fb      	bpl.n	3000780a <fuse_sense+0x1a>
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
30007812:	2200      	movs	r2, #0
30007814:	f2cf 0201 	movt	r2, #61441	; 0xf001
30007818:	6813      	ldr	r3, [r2, #0]
3000781a:	051b      	lsls	r3, r3, #20
3000781c:	d4fc      	bmi.n	30007818 <fuse_sense+0x28>
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
3000781e:	2308      	movs	r3, #8
    ctrl |= FV_FUSE_CTRL_ADDR(index);
30007820:	b2c0      	uxtb	r0, r0
    uint32_t ctrl = readl(b + FUSE_CTRL_OFF);
30007822:	6815      	ldr	r5, [r2, #0]
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
30007824:	f2cf 0301 	movt	r3, #61441	; 0xf001
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
30007828:	2400      	movs	r4, #0
    ctrl &= ~FM_FUSE_CTRL_ADDR;
3000782a:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
    ctrl |= FV_FUSE_CTRL_ADDR(index);
3000782e:	4328      	orrs	r0, r5
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
30007830:	681d      	ldr	r5, [r3, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
30007832:	f2cf 0401 	movt	r4, #61441	; 0xf001
    writel(ctrl, b + FUSE_CTRL_OFF);
30007836:	6010      	str	r0, [r2, #0]
    trig |= BM_FUSE_TRIG_READ;
30007838:	f045 0501 	orr.w	r5, r5, #1
    writel(trig, b + FUSE_TRIG_OFF);
3000783c:	601d      	str	r5, [r3, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
3000783e:	6823      	ldr	r3, [r4, #0]
30007840:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
30007844:	d1fb      	bne.n	3000783e <fuse_sense+0x4e>
    *data = readl(b + READ_FUSE_DATA_OFF);
30007846:	200c      	movs	r0, #12
    writel(0, b + SEMA_LOCK_OFF);
30007848:	221c      	movs	r2, #28
    *data = readl(b + READ_FUSE_DATA_OFF);
3000784a:	f2cf 0001 	movt	r0, #61441	; 0xf001
    writel(0, b + SEMA_LOCK_OFF);
3000784e:	f2cf 0201 	movt	r2, #61441	; 0xf001
    *data = readl(b + READ_FUSE_DATA_OFF);
30007852:	6800      	ldr	r0, [r0, #0]
30007854:	6008      	str	r0, [r1, #0]
    uint32_t res = (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_ERROR) ? -1 : 0;
30007856:	6820      	ldr	r0, [r4, #0]
    writel(0, b + SEMA_LOCK_OFF);
30007858:	6013      	str	r3, [r2, #0]
}
3000785a:	f340 3000 	sbfx	r0, r0, #12, #1
3000785e:	bc30      	pop	{r4, r5}
30007860:	4770      	bx	r14
30007862:	bf00      	nop

30007864 <cmd_fuse_sense>:
    return fuse_program(fuse, v);
}

int cmd_fuse_sense(int argc, const cmd_args *argv)
{
    if (argc != 2) {
30007864:	2802      	cmp	r0, #2
30007866:	d119      	bne.n	3000789c <cmd_fuse_sense+0x38>
30007868:	460b      	mov	r3, r1
{
3000786a:	b530      	push	{r4, r5, r14}
        DBG("%s: Opps, invalid paras.\n", __func__);
        return -1;
    }
    uint32_t fuse = argv[1].u;
    uint32_t v = 0;
3000786c:	2400      	movs	r4, #0
{
3000786e:	b083      	sub	sp, #12
    uint32_t fuse = argv[1].u;
30007870:	699d      	ldr	r5, [r3, #24]
    uint32_t v = 0;
30007872:	a902      	add	r1, sp, #8
    fuse_sense(fuse, &v);
30007874:	4628      	mov	r0, r5
    uint32_t v = 0;
30007876:	f841 4d04 	str.w	r4, [r1, #-4]!
    fuse_sense(fuse, &v);
3000787a:	f7ff ffb9 	bl	300077f0 <fuse_sense>
    printf("%s: fuse_%d = 0x%x\n", __func__, fuse, v);
3000787e:	f24c 61fc 	movw	r1, #50940	; 0xc6fc
30007882:	f24c 702c 	movw	r0, #50988	; 0xc72c
30007886:	462a      	mov	r2, r5
30007888:	9b01      	ldr	r3, [sp, #4]
3000788a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000788e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007892:	f00e f98d 	bl	30015bb0 <_printf>

    return 0;
30007896:	4620      	mov	r0, r4
}
30007898:	b003      	add	sp, #12
3000789a:	bd30      	pop	{r4, r5, r15}
        return -1;
3000789c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
300078a0:	4770      	bx	r14
300078a2:	bf00      	nop

300078a4 <fuse_program>:
{
300078a4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
300078a6:	4605      	mov	r5, r0
        res = fuse_program_raw(index, v);
300078a8:	f7ff ff5e 	bl	30007768 <fuse_program_raw>
        if (0 != res) break;
300078ac:	bb98      	cbnz	r0, 30007916 <fuse_program+0x72>
300078ae:	460c      	mov	r4, r1
    if ((id >= ECC_FUSE_START) && (id <= ECC_FUSE_END)) {
300078b0:	f1a5 0308 	sub.w	r3, r5, #8
300078b4:	2b9f      	cmp	r3, #159	; 0x9f
300078b6:	d828      	bhi.n	3000790a <fuse_program+0x66>
    *shift = ((id - ECC_FUSE_START) % 4) * 8;
300078b8:	f005 0503 	and.w	r5, r5, #3
    uint8_t ecc = 0;
300078bc:	4601      	mov	r1, r0
    *wd = ECC_VAL_START + (id - ECC_FUSE_START) / 4;
300078be:	089b      	lsrs	r3, r3, #2
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
300078c0:	f24c 7640 	movw	r6, #51008	; 0xc740
    *shift = ((id - ECC_FUSE_START) % 4) * 8;
300078c4:	00ef      	lsls	r7, r5, #3
    *wd = ECC_VAL_START + (id - ECC_FUSE_START) / 4;
300078c6:	f103 00c4 	add.w	r0, r3, #196	; 0xc4
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
300078ca:	2501      	movs	r5, #1
    for (int i =0; i < 32; i++) {
300078cc:	460b      	mov	r3, r1
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
300078ce:	f2c3 0601 	movt	r6, #12289	; 0x3001
300078d2:	fa05 f203 	lsl.w	r2, r5, r3
300078d6:	4222      	tst	r2, r4
300078d8:	bf18      	it	ne
300078da:	5d9a      	ldrbne	r2, [r3, r6]
    for (int i =0; i < 32; i++) {
300078dc:	f103 0301 	add.w	r3, r3, #1
300078e0:	bf18      	it	ne
300078e2:	4051      	eorne	r1, r2
300078e4:	2b20      	cmp	r3, #32
300078e6:	d1f4      	bne.n	300078d2 <fuse_program+0x2e>
            val &= ~(0xffu << ecc_shft);
300078e8:	22ff      	movs	r2, #255	; 0xff
    return readl(base + FUSE0_OFFSET + index * 4);
300078ea:	0083      	lsls	r3, r0, #2
300078ec:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
300078f0:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
            val |= ecc << ecc_shft;
300078f4:	40b9      	lsls	r1, r7
            val &= ~(0xffu << ecc_shft);
300078f6:	fa02 f707 	lsl.w	r7, r2, r7
    return readl(base + FUSE0_OFFSET + index * 4);
300078fa:	681b      	ldr	r3, [r3, #0]
            val &= ~(0xffu << ecc_shft);
300078fc:	ea23 0707 	bic.w	r7, r3, r7
            res = fuse_program_raw(ecc_wd, val);
30007900:	4339      	orrs	r1, r7
}
30007902:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            res = fuse_program_raw(ecc_wd, val);
30007906:	f7ff bf2f 	b.w	30007768 <fuse_program_raw>
               ((id > ECC_FUSE_END) && (id < RED_VAL_START1))) {
3000790a:	f1a5 03a8 	sub.w	r3, r5, #168	; 0xa8
    } else if ((id < ECC_FUSE_START) ||
3000790e:	2d07      	cmp	r5, #7
30007910:	bf88      	it	hi
30007912:	2b13      	cmphi	r3, #19
30007914:	d900      	bls.n	30007918 <fuse_program+0x74>
}
30007916:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (id < ECC_FUSE_START) {
30007918:	2d07      	cmp	r5, #7
        pos = RED_VAL_START1 + id;
3000791a:	bf94      	ite	ls
3000791c:	f105 00bc 	addls.w	r0, r5, #188	; 0xbc
        pos = RED_VAL_START2 + id - (ECC_FUSE_END + 1);
30007920:	f105 0044 	addhi.w	r0, r5, #68	; 0x44
}
30007924:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
                res = fuse_program_raw(red_wd, v);
30007928:	f7ff bf1e 	b.w	30007768 <fuse_program_raw>

3000792c <cmd_fuse_program>:
{
3000792c:	460b      	mov	r3, r1
    if (argc != 3) {
3000792e:	2803      	cmp	r0, #3
30007930:	d103      	bne.n	3000793a <cmd_fuse_program+0xe>
    return fuse_program(fuse, v);
30007932:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
30007934:	6998      	ldr	r0, [r3, #24]
30007936:	f7ff bfb5 	b.w	300078a4 <fuse_program>
}
3000793a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000793e:	4770      	bx	r14

30007940 <arm_gic_init_percpu>:
{
#if WITH_LIB_SM
    GICREG(GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
    GICREG(GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
#else
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007940:	f44f 5200 	mov.w	r2, #8192	; 0x2000
#endif
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007944:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007948:	2001      	movs	r0, #1
3000794a:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
3000794e:	21ff      	movs	r1, #255	; 0xff
30007950:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007954:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007956:	6019      	str	r1, [r3, #0]
}
30007958:	4770      	bx	r14
3000795a:	bf00      	nop

3000795c <arm_gic_suspend_cpu>:
                   LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_FLAG_SECONDARY_CPUS);

static void arm_gic_suspend_cpu(uint level)
{
    suspend_resume_fiq(false, false);
}
3000795c:	4770      	bx	r14
3000795e:	bf00      	nop

30007960 <arm_gic_register_int_handler>:
    if (vector >= MAX_INT)
30007960:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
{
30007964:	b510      	push	{r4, r14}
    if (vector >= MAX_INT)
30007966:	d21e      	bcs.n	300079a6 <arm_gic_register_int_handler+0x46>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30007968:	f3ef 8300 	mrs	r3, CPSR

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000796c:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
3000796e:	bf48      	it	mi
30007970:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007972:	d515      	bpl.n	300079a0 <arm_gic_register_int_handler+0x40>
    if (vector < GIC_MAX_PER_CPU_INT)
30007974:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
30007976:	bf93      	iteet	ls
30007978:	f646 5308 	movwls	r3, #27912	; 0x6d08
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
3000797c:	f1a0 0320 	subhi.w	r3, r0, #32
30007980:	f646 6008 	movwhi	r0, #28168	; 0x6e08
        return &int_handler_table_per_cpu[vector][cpu];
30007984:	f2c3 0302 	movtls	r3, #12290	; 0x3002
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
30007988:	bf8a      	itet	hi
3000798a:	f2c3 0002 	movthi	r0, #12290	; 0x3002
        return &int_handler_table_per_cpu[vector][cpu];
3000798e:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
30007992:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
        h->arg = arg;
30007996:	e9c0 1200 	strd	r1, r2, [r0]
static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
3000799a:	b104      	cbz	r4, 3000799e <arm_gic_register_int_handler+0x3e>
    __asm__ volatile("cpsie i");
3000799c:	b662      	cpsie	i
}
3000799e:	bd10      	pop	{r4, r15}
    __asm__ volatile("cpsid i");
300079a0:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
300079a2:	2401      	movs	r4, #1
300079a4:	e7e6      	b.n	30007974 <arm_gic_register_int_handler+0x14>
        panic("register_int_handler: vector out of range %d\n", vector);
300079a6:	f24c 7198 	movw	r1, #51096	; 0xc798
300079aa:	4602      	mov	r2, r0
300079ac:	4670      	mov	r0, r14
300079ae:	f2c3 0101 	movt	r1, #12289	; 0x3001
300079b2:	f00c fc2f 	bl	30014214 <_panic>
300079b6:	bf00      	nop

300079b8 <arm_gic_init>:
{
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
}

void arm_gic_init(void)
{
300079b8:	b410      	push	{r4}
    int i;

    for (i = 0; i < MAX_INT; i+= 32) {
300079ba:	2100      	movs	r1, #0
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
300079bc:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
#if !(WITH_LK_DOMU)
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
300079c0:	f44f 7280 	mov.w	r2, #256	; 0x100
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
300079c4:	114b      	asrs	r3, r1, #5
300079c6:	f503 638c 	add.w	r3, r3, #1120	; 0x460
    for (i = 0; i < MAX_INT; i+= 32) {
300079ca:	3120      	adds	r1, #32
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
300079cc:	009b      	lsls	r3, r3, #2
300079ce:	f103 4075 	add.w	r0, r3, #4110417920	; 0xf5000000
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
300079d2:	f2cf 5241 	movt	r2, #62785	; 0xf541
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
300079d6:	f500 0082 	add.w	r0, r0, #4259840	; 0x410000
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
300079da:	441a      	add	r2, r3
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
300079dc:	6004      	str	r4, [r0, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
300079de:	f5b1 7f90 	cmp.w	r1, #288	; 0x120
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
300079e2:	6014      	str	r4, [r2, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
300079e4:	d1ec      	bne.n	300079c0 <arm_gic_init+0x8>
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
300079e6:	f241 0304 	movw	r3, #4100	; 0x1004
300079ea:	f2cf 5341 	movt	r3, #62785	; 0xf541
300079ee:	681b      	ldr	r3, [r3, #0]
#endif
    }

    if (arm_gic_max_cpu() > 0) {
300079f0:	f013 0fe0 	tst.w	r3, #224	; 0xe0
300079f4:	d017      	beq.n	30007a26 <arm_gic_init+0x6e>
300079f6:	f24c 74c8 	movw	r4, #51144	; 0xc7c8
300079fa:	f04f 3001 	mov.w	r0, #16843009	; 0x1010101
        /* Set external interrupts to target cpu 0 */
        for (i = 32; i < MAX_INT; i += 4) {
300079fe:	2120      	movs	r1, #32
30007a00:	f2c3 0401 	movt	r4, #12289	; 0x3001
30007a04:	2308      	movs	r3, #8
30007a06:	e001      	b.n	30007a0c <arm_gic_init+0x54>
30007a08:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
30007a0c:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
30007a10:	009b      	lsls	r3, r3, #2
        for (i = 32; i < MAX_INT; i += 4) {
30007a12:	3104      	adds	r1, #4
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
30007a14:	f2cf 5241 	movt	r2, #62785	; 0xf541
30007a18:	441a      	add	r2, r3
        for (i = 32; i < MAX_INT; i += 4) {
30007a1a:	f5b1 7f8a 	cmp.w	r1, #276	; 0x114
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
30007a1e:	6010      	str	r0, [r2, #0]
30007a20:	ea4f 03a1 	mov.w	r3, r1, asr #2
        for (i = 32; i < MAX_INT; i += 4) {
30007a24:	d1f0      	bne.n	30007a08 <arm_gic_init+0x50>
        }
    }

    GICREG(GICD_CTLR) = 1; // enable GIC0
30007a26:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a2a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a2e:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICD_CTLR) = 1; // enable GIC0
30007a32:	2101      	movs	r1, #1
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a34:	24ff      	movs	r4, #255	; 0xff
    GICREG(GICD_CTLR) = 1; // enable GIC0
30007a36:	f2cf 5041 	movt	r0, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a3a:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICD_CTLR) = 1; // enable GIC0
30007a3e:	6001      	str	r1, [r0, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a40:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a44:	6011      	str	r1, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a46:	601c      	str	r4, [r3, #0]
        u_int reg = i / 32;
        GICREG(GICD_IGROUPR(reg)) = gicd_igroupr[reg];
    }
#endif
    arm_gic_init_percpu(0);
}
30007a48:	f85d 4b04 	ldr.w	r4, [r13], #4
30007a4c:	4770      	bx	r14
30007a4e:	bf00      	nop

30007a50 <arm_gic_resume_cpu>:
{
30007a50:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30007a52:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007a56:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
30007a58:	bf48      	it	mi
30007a5a:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007a5c:	d401      	bmi.n	30007a62 <arm_gic_resume_cpu+0x12>
    __asm__ volatile("cpsid i");
30007a5e:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30007a60:	2401      	movs	r4, #1
    if (!(GICREG(GICD_CTLR) & 1)) {
30007a62:	f44f 5380 	mov.w	r3, #4096	; 0x1000
30007a66:	f2cf 5341 	movt	r3, #62785	; 0xf541
30007a6a:	681b      	ldr	r3, [r3, #0]
30007a6c:	07db      	lsls	r3, r3, #31
30007a6e:	d50e      	bpl.n	30007a8e <arm_gic_resume_cpu+0x3e>
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a70:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a74:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a78:	2001      	movs	r0, #1
30007a7a:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a7e:	21ff      	movs	r1, #255	; 0xff
30007a80:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
30007a84:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
30007a86:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30007a88:	b104      	cbz	r4, 30007a8c <arm_gic_resume_cpu+0x3c>
    __asm__ volatile("cpsie i");
30007a8a:	b662      	cpsie	i
}
30007a8c:	bd10      	pop	{r4, r15}
        arm_gic_init();
30007a8e:	f7ff ff93 	bl	300079b8 <arm_gic_init>
30007a92:	e7f9      	b.n	30007a88 <arm_gic_resume_cpu+0x38>

30007a94 <arm_gic_set_priority>:
    return ret;
}


status_t arm_gic_set_priority(u_int irq, uint8_t priority)
{
30007a94:	b430      	push	{r4, r5}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30007a96:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007a9a:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
30007a9c:	bf48      	it	mi
30007a9e:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007aa0:	d401      	bmi.n	30007aa6 <arm_gic_set_priority+0x12>
    __asm__ volatile("cpsid i");
30007aa2:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30007aa4:	2501      	movs	r5, #1
    regval = GICREG(GICD_IPRIORITYR(reg));
30007aa6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
30007aaa:	f020 0203 	bic.w	r2, r0, #3
30007aae:	f2cf 5341 	movt	r3, #62785	; 0xf541
30007ab2:	4413      	add	r3, r2
    u_int mask = 0xff << shift;
30007ab4:	24ff      	movs	r4, #255	; 0xff
    u_int shift = 8 * (irq % 4);
30007ab6:	f000 0003 	and.w	r0, r0, #3
    regval = GICREG(GICD_IPRIORITYR(reg));
30007aba:	681a      	ldr	r2, [r3, #0]
    u_int shift = 8 * (irq % 4);
30007abc:	00c0      	lsls	r0, r0, #3
    u_int mask = 0xff << shift;
30007abe:	4084      	lsls	r4, r0
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
30007ac0:	fa01 f000 	lsl.w	r0, r1, r0
30007ac4:	ea22 0104 	bic.w	r1, r2, r4
30007ac8:	4308      	orrs	r0, r1
    GICREG(GICD_IPRIORITYR(reg)) = regval;
30007aca:	6018      	str	r0, [r3, #0]
    spin_lock_saved_state_t state;

    spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
    __arm_gic_set_priority_locked(irq, priority);
    DSB;
30007acc:	f3bf 8f4f 	dsb	sy
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30007ad0:	b105      	cbz	r5, 30007ad4 <arm_gic_set_priority+0x40>
    __asm__ volatile("cpsie i");
30007ad2:	b662      	cpsie	i
    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return 0;
}
30007ad4:	2000      	movs	r0, #0
30007ad6:	bc30      	pop	{r4, r5}
30007ad8:	4770      	bx	r14
30007ada:	bf00      	nop

30007adc <arm_gic_mask_interrupt>:
    return NO_ERROR;
}

status_t arm_gic_mask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
30007adc:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
30007ae0:	d219      	bcs.n	30007b16 <arm_gic_mask_interrupt+0x3a>
{
30007ae2:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30007ae4:	f3ef 8300 	mrs	r3, CPSR
30007ae8:	f44f 528c 	mov.w	r2, #4480	; 0x1180
30007aec:	0944      	lsrs	r4, r0, #5
30007aee:	2101      	movs	r1, #1
30007af0:	f000 001f 	and.w	r0, r0, #31
30007af4:	00a4      	lsls	r4, r4, #2
30007af6:	f2cf 5241 	movt	r2, #62785	; 0xf541
30007afa:	4081      	lsls	r1, r0
30007afc:	4422      	add	r2, r4
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30007afe:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, false);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
30007b02:	bf1c      	itt	ne
30007b04:	2000      	movne	r0, #0
        GICREG(GICD_ICENABLER(reg)) = mask;
30007b06:	6011      	strne	r1, [r2, #0]
30007b08:	d102      	bne.n	30007b10 <arm_gic_mask_interrupt+0x34>
    __asm__ volatile("cpsid i");
30007b0a:	b672      	cpsid	i
30007b0c:	6011      	str	r1, [r2, #0]
    __asm__ volatile("cpsie i");
30007b0e:	b662      	cpsie	i
}
30007b10:	f85d 4b04 	ldr.w	r4, [r13], #4
30007b14:	4770      	bx	r14
        return ERR_INVALID_ARGS;
30007b16:	f06f 0007 	mvn.w	r0, #7
}
30007b1a:	4770      	bx	r14

30007b1c <arm_gic_unmask_interrupt>:

status_t arm_gic_unmask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
30007b1c:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
30007b20:	d219      	bcs.n	30007b56 <arm_gic_unmask_interrupt+0x3a>
{
30007b22:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30007b24:	f3ef 8300 	mrs	r3, CPSR
30007b28:	f44f 5288 	mov.w	r2, #4352	; 0x1100
30007b2c:	0944      	lsrs	r4, r0, #5
30007b2e:	2101      	movs	r1, #1
30007b30:	f000 001f 	and.w	r0, r0, #31
30007b34:	00a4      	lsls	r4, r4, #2
30007b36:	f2cf 5241 	movt	r2, #62785	; 0xf541
30007b3a:	4081      	lsls	r1, r0
30007b3c:	4422      	add	r2, r4
30007b3e:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, true);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
30007b42:	bf1c      	itt	ne
30007b44:	2000      	movne	r0, #0
        GICREG(GICD_ISENABLER(reg)) = mask;
30007b46:	6011      	strne	r1, [r2, #0]
30007b48:	d102      	bne.n	30007b50 <arm_gic_unmask_interrupt+0x34>
    __asm__ volatile("cpsid i");
30007b4a:	b672      	cpsid	i
30007b4c:	6011      	str	r1, [r2, #0]
    __asm__ volatile("cpsie i");
30007b4e:	b662      	cpsie	i
}
30007b50:	f85d 4b04 	ldr.w	r4, [r13], #4
30007b54:	4770      	bx	r14
        return ERR_INVALID_ARGS;
30007b56:	f06f 0007 	mvn.w	r0, #7
}
30007b5a:	4770      	bx	r14

30007b5c <platform_irq>:

static
enum handler_return __platform_irq(struct iframe *frame)
{
    // get the current vector
    uint32_t iar = GICREG(GICC_IAR);
30007b5c:	f242 030c 	movw	r3, #8204	; 0x200c
    unsigned int vector = iar & 0x3ff;

    if (vector >= 0x3fe) {
30007b60:	f240 31fd 	movw	r1, #1021	; 0x3fd
    uint32_t iar = GICREG(GICC_IAR);
30007b64:	f2cf 5341 	movt	r3, #62785	; 0xf541

    return ret;
}

enum handler_return platform_irq(struct iframe *frame)
{
30007b68:	b510      	push	{r4, r14}
    uint32_t iar = GICREG(GICC_IAR);
30007b6a:	681c      	ldr	r4, [r3, #0]
    unsigned int vector = iar & 0x3ff;
30007b6c:	f3c4 0209 	ubfx	r2, r4, #0, #10
    if (vector >= 0x3fe) {
30007b70:	428a      	cmp	r2, r1
30007b72:	d825      	bhi.n	30007bc0 <platform_irq+0x64>
    THREAD_STATS_INC(interrupts);
30007b74:	f24d 1358 	movw	r3, #53592	; 0xd158
    if (vector < GIC_MAX_PER_CPU_INT)
30007b78:	2a1f      	cmp	r2, #31
    THREAD_STATS_INC(interrupts);
30007b7a:	f2c3 0302 	movt	r3, #12290	; 0x3002
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
30007b7e:	bf88      	it	hi
30007b80:	3a20      	subhi	r2, #32
    THREAD_STATS_INC(interrupts);
30007b82:	6a19      	ldr	r1, [r3, #32]
30007b84:	f101 0101 	add.w	r1, r1, #1
30007b88:	6219      	str	r1, [r3, #32]
        return &int_handler_table_per_cpu[vector][cpu];
30007b8a:	bf95      	itete	ls
30007b8c:	f646 5308 	movwls	r3, #27912	; 0x6d08
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
30007b90:	f646 6308 	movwhi	r3, #28168	; 0x6e08
        return &int_handler_table_per_cpu[vector][cpu];
30007b94:	f2c3 0302 	movtls	r3, #12290	; 0x3002
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
30007b98:	f2c3 0302 	movthi	r3, #12290	; 0x3002
30007b9c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    if (handler->handler)
30007ba0:	681a      	ldr	r2, [r3, #0]
30007ba2:	b142      	cbz	r2, 30007bb6 <platform_irq+0x5a>
        ret = handler->handler(handler->arg);
30007ba4:	6858      	ldr	r0, [r3, #4]
30007ba6:	4790      	blx	r2
    GICREG(GICC_EOIR) = iar;
30007ba8:	f242 0310 	movw	r3, #8208	; 0x2010
30007bac:	f2cf 5341 	movt	r3, #62785	; 0xf541
30007bb0:	601c      	str	r4, [r3, #0]
    else
        ret = sm_handle_irq();
#else
    ret = __platform_irq(frame);
#endif
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
30007bb2:	b128      	cbz	r0, 30007bc0 <platform_irq+0x64>
        ret = INT_RESCHEDULE;

	}
    return ret;
}
30007bb4:	bd10      	pop	{r4, r15}
    GICREG(GICC_EOIR) = iar;
30007bb6:	f242 0310 	movw	r3, #8208	; 0x2010
30007bba:	f2cf 5341 	movt	r3, #62785	; 0xf541
30007bbe:	601c      	str	r4, [r3, #0]
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
30007bc0:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
30007bc4:	6a18      	ldr	r0, [r3, #32]
30007bc6:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
30007bca:	bd10      	pop	{r4, r15}

30007bcc <platform_fiq>:
void platform_fiq(struct iframe *frame)
{
#if WITH_LIB_SM
    sm_handle_fiq();
#else
    PANIC_UNIMPLEMENTED;
30007bcc:	f24c 7288 	movw	r2, #51080	; 0xc788
30007bd0:	f64c 01dc 	movw	r1, #51420	; 0xc8dc
{
30007bd4:	b508      	push	{r3, r14}
    PANIC_UNIMPLEMENTED;
30007bd6:	4670      	mov	r0, r14
30007bd8:	f2c3 0201 	movt	r2, #12289	; 0x3001
30007bdc:	f2c3 0101 	movt	r1, #12289	; 0x3001
30007be0:	f00c fb18 	bl	30014214 <_panic>

30007be4 <sdhci_set_bus_power_on>:
 */
static void sdhci_set_bus_power_on(struct sdhci_host *host)
{
    uint16_t ctrl;
    uint8_t voltage;
    voltage = host->caps.voltage;
30007be4:	f890 30d5 	ldrb.w	r3, [r0, #213]	; 0xd5
    voltage <<= SDHCI_BUS_VOL_SEL;
    REG_WRITE8(host, voltage, SDHCI_PWR_CTRL_REG);
30007be8:	6841      	ldr	r1, [r0, #4]
    voltage <<= SDHCI_BUS_VOL_SEL;
30007bea:	005b      	lsls	r3, r3, #1
30007bec:	b2db      	uxtb	r3, r3
    voltage |= SDHCI_BUS_PWR_EN;
30007bee:	f043 0201 	orr.w	r2, r3, #1
    REG_WRITE8(host, voltage, SDHCI_PWR_CTRL_REG);
30007bf2:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
    REG_WRITE8(host, voltage, SDHCI_PWR_CTRL_REG);
30007bf6:	6843      	ldr	r3, [r0, #4]
30007bf8:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
    /* switch signal voltage by host ctrl2 register */
    ctrl = REG_READ16(host, SDHCI_HOST_CTRL2_REG);

    if (host->caps.voltage < SDHCI_VOL_3_3) {
30007bfc:	f890 10d5 	ldrb.w	r1, [r0, #213]	; 0xd5
    ctrl = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30007c00:	6842      	ldr	r2, [r0, #4]
    if (host->caps.voltage < SDHCI_VOL_3_3) {
30007c02:	2906      	cmp	r1, #6
    ctrl = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30007c04:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
30007c06:	b29b      	uxth	r3, r3
        ctrl |= SDHCI_1_8_VOL_SET;
    }
    else {
        ctrl &= ~SDHCI_1_8_VOL_SET;
30007c08:	bf8a      	itet	hi
30007c0a:	f023 0308 	bichi.w	r3, r3, #8
        ctrl |= SDHCI_1_8_VOL_SET;
30007c0e:	f043 0308 	orrls.w	r3, r3, #8
        ctrl &= ~SDHCI_1_8_VOL_SET;
30007c12:	b29b      	uxthhi	r3, r3
    }

    REG_WRITE16(host, ctrl, SDHCI_HOST_CTRL2_REG);
30007c14:	87d3      	strh	r3, [r2, #62]	; 0x3e
    DBG("\n %s: voltage: 0x%02x; host ctrl2: 0x%04x\n", __func__, voltage,
        ctrl);
}
30007c16:	4770      	bx	r14

30007c18 <sdhci_dumpregs.isra.7>:
static void sdhci_dumpregs(struct sdhci_host *host)
30007c18:	b510      	push	{r4, r14}
30007c1a:	4604      	mov	r4, r0
    dprintf(CRITICAL,
30007c1c:	f64c 1064 	movw	r0, #51556	; 0xc964
30007c20:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c24:	f00d ffc4 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Version:      0x%08x\n",
30007c28:	f64c 109c 	movw	r0, #51612	; 0xc99c
30007c2c:	6823      	ldr	r3, [r4, #0]
30007c2e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c32:	f8b3 10fe 	ldrh.w	r1, [r3, #254]	; 0xfe
30007c36:	f00d ffbb 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Arg2:         0x%08x\t Blk Cnt:      0x%08x\n",
30007c3a:	6823      	ldr	r3, [r4, #0]
30007c3c:	f64c 10b4 	movw	r0, #51636	; 0xc9b4
30007c40:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c44:	6819      	ldr	r1, [r3, #0]
30007c46:	88da      	ldrh	r2, [r3, #6]
30007c48:	f00d ffb2 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Arg1:         0x%08x\t Blk Sz :      0x%08x\n",
30007c4c:	6823      	ldr	r3, [r4, #0]
30007c4e:	f64c 10e0 	movw	r0, #51680	; 0xc9e0
30007c52:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c56:	6899      	ldr	r1, [r3, #8]
30007c58:	889a      	ldrh	r2, [r3, #4]
30007c5a:	f00d ffa9 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Command:      0x%08x\t Trans mode:   0x%08x\n",
30007c5e:	6823      	ldr	r3, [r4, #0]
30007c60:	f64c 200c 	movw	r0, #51724	; 0xca0c
30007c64:	89d9      	ldrh	r1, [r3, #14]
30007c66:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c6a:	899a      	ldrh	r2, [r3, #12]
30007c6c:	f00d ffa0 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Resp0:        0x%08x\t Resp1:        0x%08x\n",
30007c70:	6823      	ldr	r3, [r4, #0]
30007c72:	f64c 2038 	movw	r0, #51768	; 0xca38
30007c76:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c7a:	6919      	ldr	r1, [r3, #16]
30007c7c:	695a      	ldr	r2, [r3, #20]
30007c7e:	f00d ff97 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Resp2:        0x%08x\t Resp3:        0x%08x\n",
30007c82:	6823      	ldr	r3, [r4, #0]
30007c84:	f64c 2064 	movw	r0, #51812	; 0xca64
30007c88:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c8c:	6999      	ldr	r1, [r3, #24]
30007c8e:	69da      	ldr	r2, [r3, #28]
30007c90:	f00d ff8e 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Prsnt State:  0x%08x\t Host Ctrl1:   0x%08x\n",
30007c94:	6823      	ldr	r3, [r4, #0]
30007c96:	f64c 2090 	movw	r0, #51856	; 0xca90
30007c9a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007c9e:	6a59      	ldr	r1, [r3, #36]	; 0x24
30007ca0:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
30007ca4:	f00d ff84 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Timeout ctrl: 0x%08x\t Power Ctrl:   0x%08x\n",
30007ca8:	6823      	ldr	r3, [r4, #0]
30007caa:	f64c 20bc 	movw	r0, #51900	; 0xcabc
30007cae:	f893 102e 	ldrb.w	r1, [r3, #46]	; 0x2e
30007cb2:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007cb6:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
30007cba:	f00d ff79 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Error stat:   0x%08x\t Int Status:   0x%08x\n",
30007cbe:	6823      	ldr	r3, [r4, #0]
30007cc0:	f64c 20e8 	movw	r0, #51944	; 0xcae8
30007cc4:	8e59      	ldrh	r1, [r3, #50]	; 0x32
30007cc6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007cca:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
30007ccc:	f00d ff70 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Host Ctrl2:   0x%08x\t Clock ctrl:   0x%08x\n",
30007cd0:	6823      	ldr	r3, [r4, #0]
30007cd2:	f64c 3014 	movw	r0, #51988	; 0xcb14
30007cd6:	8fd9      	ldrh	r1, [r3, #62]	; 0x3e
30007cd8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007cdc:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
30007cde:	f00d ff67 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Caps1:        0x%08x\t Caps2:        0x%08x\n",
30007ce2:	6823      	ldr	r3, [r4, #0]
30007ce4:	f64c 3040 	movw	r0, #52032	; 0xcb40
30007ce8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007cec:	6c19      	ldr	r1, [r3, #64]	; 0x40
30007cee:	6c5a      	ldr	r2, [r3, #68]	; 0x44
30007cf0:	f00d ff5e 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Adma Err:     0x%08x\t Auto Cmd err: 0x%08x\n",
30007cf4:	6823      	ldr	r3, [r4, #0]
30007cf6:	f64c 306c 	movw	r0, #52076	; 0xcb6c
30007cfa:	f893 1054 	ldrb.w	r1, [r3, #84]	; 0x54
30007cfe:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007d02:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
30007d04:	f00d ff54 	bl	30015bb0 <_printf>
    dprintf(CRITICAL, "Adma addr1:   0x%08x\t Adma addr2:   0x%08x\n",
30007d08:	6823      	ldr	r3, [r4, #0]
30007d0a:	f64c 3098 	movw	r0, #52120	; 0xcb98
30007d0e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007d12:	6d99      	ldr	r1, [r3, #88]	; 0x58
}
30007d14:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    dprintf(CRITICAL, "Adma addr1:   0x%08x\t Adma addr2:   0x%08x\n",
30007d18:	6dda      	ldr	r2, [r3, #92]	; 0x5c
30007d1a:	f00d bf49 	b.w	30015bb0 <_printf>
30007d1e:	bf00      	nop

30007d20 <sdhci_irq_handle>:
    *lock = 1;
30007d20:	2301      	movs	r3, #1
    host->tuning_in_progress = 0;
    return ret;
}

enum handler_return sdhci_irq_handle(void *arg)
{
30007d22:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
30007d26:	6643      	str	r3, [r0, #100]	; 0x64
30007d28:	4605      	mov	r5, r0
    struct sdhci_host *host = arg;
    int max_loops = 16;
    struct mmc_command *cmd = host->cmd;
    struct mmc_command *data_cmd = &host->data_cmd;
    spin_lock(&host->spin_lock);
    int_status = REG_READ32(host, SDHCI_NRML_INT_STS_REG);
30007d2a:	6843      	ldr	r3, [r0, #4]
    struct mmc_command *cmd = host->cmd;
30007d2c:	f8d0 a07c 	ldr.w	r10, [r0, #124]	; 0x7c
    int_status = REG_READ32(host, SDHCI_NRML_INT_STS_REG);
30007d30:	6b1c      	ldr	r4, [r3, #48]	; 0x30

    if (!int_status) {
30007d32:	2c00      	cmp	r4, #0
30007d34:	d042      	beq.n	30007dbc <sdhci_irq_handle+0x9c>
30007d36:	f64f 79fc 	movw	r9, #65532	; 0xfffc
    }

    do {
        DBG("sdhci: irq status 0x%08x\n", int_status);
        /* clear the interrupts */
        mask = int_status &
30007d3a:	f04f 083f 	mov.w	r8, #63	; 0x3f
               (SDHCI_INT_CMD_MASK | SDHCI_INT_DATA_MASK | SDHCI_INT_BUS_POWER);
        REG_WRITE32(host, mask, SDHCI_NRML_INT_STS_REG);

        if (int_status & SDHCI_INT_CMD_MASK) {
30007d3e:	2701      	movs	r7, #1
30007d40:	f6cf 79ff 	movt	r9, #65535	; 0xffff
30007d44:	eba9 090a 	sub.w	r9, r9, r10
        mask = int_status &
30007d48:	f2c0 38ff 	movt	r8, #1023	; 0x3ff
    int max_loops = 16;
30007d4c:	2610      	movs	r6, #16
        if (int_status & SDHCI_INT_CMD_MASK) {
30007d4e:	f2c0 170f 	movt	r7, #271	; 0x10f
30007d52:	f103 0230 	add.w	r2, r3, #48	; 0x30
        mask = int_status &
30007d56:	ea04 0108 	and.w	r1, r4, r8
        if (int_status & SDHCI_INT_CMD_MASK) {
30007d5a:	423c      	tst	r4, r7
        REG_WRITE32(host, mask, SDHCI_NRML_INT_STS_REG);
30007d5c:	6011      	str	r1, [r2, #0]
        if (int_status & SDHCI_INT_CMD_MASK) {
30007d5e:	d010      	beq.n	30007d82 <sdhci_irq_handle+0x62>
            if (int_status &
30007d60:	2200      	movs	r2, #0
30007d62:	f2c0 120f 	movt	r2, #271	; 0x10f
30007d66:	4214      	tst	r4, r2
30007d68:	d13b      	bne.n	30007de2 <sdhci_irq_handle+0xc2>
                dprintf(CRITICAL, "sdhci cmd error! reg = 0x%08x\n",
                        int_status);
                sdhci_dumpregs(host);
            }

            if (cmd->resp_type == SDHCI_CMD_RESP_R2) {
30007d6a:	f8ba 200a 	ldrh.w	r2, [r10, #10]
30007d6e:	2a04      	cmp	r2, #4
30007d70:	d04c      	beq.n	30007e0c <sdhci_irq_handle+0xec>
                            (REG_READ32(host, SDHCI_RESP_REG + ((i - 1) * 4)) >>
                             SDHCI_RESP_RSHIFT);
                }
            }
            else {
                cmd->resp[0] = REG_READ32(host, SDHCI_RESP_REG);
30007d72:	691b      	ldr	r3, [r3, #16]
30007d74:	f8ca 300c 	str.w	r3, [r10, #12]
            }

            event_signal(&host->cmd_event, false);
30007d78:	2100      	movs	r1, #0
30007d7a:	f105 0010 	add.w	r0, r5, #16
30007d7e:	f009 fdd5 	bl	3001192c <event_signal>
        }

        /* clear the data complete flag */
        if (int_status & SDHCI_INT_DATA_MASK) {
30007d82:	233e      	movs	r3, #62	; 0x3e
30007d84:	f2c0 2370 	movt	r3, #624	; 0x270
30007d88:	421c      	tst	r4, r3
30007d8a:	d010      	beq.n	30007dae <sdhci_irq_handle+0x8e>
30007d8c:	0c23      	lsrs	r3, r4, #16
            if (data_cmd->data_present) {
30007d8e:	f895 2088 	ldrb.w	r2, [r5, #136]	; 0x88
30007d92:	f004 0402 	and.w	r4, r4, #2
30007d96:	b1aa      	cbz	r2, 30007dc4 <sdhci_irq_handle+0xa4>
                data_cmd->error = (int_status & SDHCI_INT_DATA_MASK) >> 16;
30007d98:	f403 731c 	and.w	r3, r3, #624	; 0x270
30007d9c:	f8c5 30b4 	str.w	r3, [r5, #180]	; 0xb4

                if (int_status & SDHCI_INT_DATA_END || data_cmd->error) {
30007da0:	b904      	cbnz	r4, 30007da4 <sdhci_irq_handle+0x84>
30007da2:	b123      	cbz	r3, 30007dae <sdhci_irq_handle+0x8e>
                    event_signal(&host->data_event, false);
30007da4:	2100      	movs	r1, #0
30007da6:	f105 002c 	add.w	r0, r5, #44	; 0x2c
30007daa:	f009 fdbf 	bl	3001192c <event_signal>
                    event_signal(&host->data_event, false);
                }
            }
        }

        int_status = REG_READ32(host, SDHCI_NRML_INT_STS_REG);
30007dae:	686b      	ldr	r3, [r5, #4]
    } while (int_status & --max_loops);
30007db0:	3e01      	subs	r6, #1
        int_status = REG_READ32(host, SDHCI_NRML_INT_STS_REG);
30007db2:	f103 0230 	add.w	r2, r3, #48	; 0x30
30007db6:	6b1c      	ldr	r4, [r3, #48]	; 0x30
    } while (int_status & --max_loops);
30007db8:	4226      	tst	r6, r4
30007dba:	d1cc      	bne.n	30007d56 <sdhci_irq_handle+0x36>
    *lock = 0;
30007dbc:	2000      	movs	r0, #0
30007dbe:	6668      	str	r0, [r5, #100]	; 0x64

    spin_unlock(&host->spin_lock);
    return INT_NO_RESCHEDULE;
}
30007dc0:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
                cmd->error |= (int_status & SDHCI_INT_DATA_MASK) >> 16;
30007dc4:	f8da 2034 	ldr.w	r2, [r10, #52]	; 0x34
30007dc8:	f403 731c 	and.w	r3, r3, #624	; 0x270
30007dcc:	4313      	orrs	r3, r2
30007dce:	f8ca 3034 	str.w	r3, [r10, #52]	; 0x34
                if (int_status & SDHCI_INT_DATA_END || cmd->error) {
30007dd2:	4323      	orrs	r3, r4
30007dd4:	d0eb      	beq.n	30007dae <sdhci_irq_handle+0x8e>
                    event_signal(&host->data_event, false);
30007dd6:	2100      	movs	r1, #0
30007dd8:	f105 002c 	add.w	r0, r5, #44	; 0x2c
30007ddc:	f009 fda6 	bl	3001192c <event_signal>
30007de0:	e7e5      	b.n	30007dae <sdhci_irq_handle+0x8e>
                cmd->error = (int_status & SDHCI_INT_CMD_MASK) >> 16;
30007de2:	f240 130f 	movw	r3, #271	; 0x10f
                dprintf(CRITICAL, "sdhci cmd error! reg = 0x%08x\n",
30007de6:	f64c 4044 	movw	r0, #52292	; 0xcc44
30007dea:	4621      	mov	r1, r4
                cmd->error = (int_status & SDHCI_INT_CMD_MASK) >> 16;
30007dec:	ea03 4314 	and.w	r3, r3, r4, lsr #16
                dprintf(CRITICAL, "sdhci cmd error! reg = 0x%08x\n",
30007df0:	f2c3 0001 	movt	r0, #12289	; 0x3001
                cmd->error = (int_status & SDHCI_INT_CMD_MASK) >> 16;
30007df4:	f8ca 3034 	str.w	r3, [r10, #52]	; 0x34
                dprintf(CRITICAL, "sdhci cmd error! reg = 0x%08x\n",
30007df8:	f00d feda 	bl	30015bb0 <_printf>
                sdhci_dumpregs(host);
30007dfc:	1d28      	adds	r0, r5, #4
30007dfe:	f7ff ff0b 	bl	30007c18 <sdhci_dumpregs.isra.7>
            if (cmd->resp_type == SDHCI_CMD_RESP_R2) {
30007e02:	f8ba 200a 	ldrh.w	r2, [r10, #10]
30007e06:	686b      	ldr	r3, [r5, #4]
30007e08:	2a04      	cmp	r2, #4
30007e0a:	d1b2      	bne.n	30007d72 <sdhci_irq_handle+0x52>
30007e0c:	f1ca 0004 	rsb	r0, r10, #4
30007e10:	4418      	add	r0, r3
30007e12:	f04f 0c00 	mov.w	r12, #0
30007e16:	f10a 010c 	add.w	r1, r10, #12
30007e1a:	444b      	add	r3, r9
                    cmd->resp[i] = REG_READ32(host, SDHCI_RESP_REG + (i * 4));
30007e1c:	5842      	ldr	r2, [r0, r1]
                    cmd->resp[i] <<= SDHCI_RESP_LSHIFT;
30007e1e:	0212      	lsls	r2, r2, #8
30007e20:	f841 2b04 	str.w	r2, [r1], #4
                    if (i != 0)
30007e24:	f1bc 0f00 	cmp.w	r12, #0
30007e28:	d008      	beq.n	30007e3c <sdhci_irq_handle+0x11c>
                            (REG_READ32(host, SDHCI_RESP_REG + ((i - 1) * 4)) >>
30007e2a:	f853 e001 	ldr.w	r14, [r3, r1]
                for (int i = 0; i < 4; i++) {
30007e2e:	f1bc 0f03 	cmp.w	r12, #3
                        cmd->resp[i] |=
30007e32:	ea42 621e 	orr.w	r2, r2, r14, lsr #24
30007e36:	f841 2c04 	str.w	r2, [r1, #-4]
                for (int i = 0; i < 4; i++) {
30007e3a:	d09d      	beq.n	30007d78 <sdhci_irq_handle+0x58>
                    cmd->resp[i] = REG_READ32(host, SDHCI_RESP_REG + (i * 4));
30007e3c:	5842      	ldr	r2, [r0, r1]
30007e3e:	f10c 0c01 	add.w	r12, r12, #1
                    cmd->resp[i] <<= SDHCI_RESP_LSHIFT;
30007e42:	0212      	lsls	r2, r2, #8
30007e44:	f841 2b04 	str.w	r2, [r1], #4
                    if (i != 0)
30007e48:	f1bc 0f00 	cmp.w	r12, #0
30007e4c:	d1ed      	bne.n	30007e2a <sdhci_irq_handle+0x10a>
30007e4e:	e7f5      	b.n	30007e3c <sdhci_irq_handle+0x11c>

30007e50 <sdhci_reset>:
    REG_WRITE8(host, mask, SDHCI_RESET_REG);
30007e50:	6843      	ldr	r3, [r0, #4]
30007e52:	f883 102f 	strb.w	r1, [r3, #47]	; 0x2f
        reg = REG_READ8(host, SDHCI_RESET_REG);
30007e56:	6843      	ldr	r3, [r0, #4]
30007e58:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
        if (!reg) {
30007e5c:	4219      	tst	r1, r3
30007e5e:	d018      	beq.n	30007e92 <sdhci_reset+0x42>
{
30007e60:	b570      	push	{r4, r5, r6, r14}
30007e62:	460d      	mov	r5, r1
30007e64:	4606      	mov	r6, r0
        if (!reg) {
30007e66:	2464      	movs	r4, #100	; 0x64
30007e68:	e001      	b.n	30007e6e <sdhci_reset+0x1e>
        if (!timeout) {
30007e6a:	3c01      	subs	r4, #1
30007e6c:	d008      	beq.n	30007e80 <sdhci_reset+0x30>
        thread_sleep(1);
30007e6e:	2001      	movs	r0, #1
30007e70:	f00a f90e 	bl	30012090 <thread_sleep>
        reg = REG_READ8(host, SDHCI_RESET_REG);
30007e74:	6873      	ldr	r3, [r6, #4]
30007e76:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
        if (!reg) {
30007e7a:	422b      	tst	r3, r5
30007e7c:	d1f5      	bne.n	30007e6a <sdhci_reset+0x1a>
}
30007e7e:	bd70      	pop	{r4, r5, r6, r15}
            dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
30007e80:	f64c 4064 	movw	r0, #52324	; 0xcc64
30007e84:	4629      	mov	r1, r5
30007e86:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
30007e8a:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
            dprintf(CRITICAL, "Error: sdhci reset failed for: %x\n", mask);
30007e8e:	f00d be8f 	b.w	30015bb0 <_printf>
30007e92:	4770      	bx	r14

30007e94 <sdhci_set_uhs_mode>:
    clk = REG_READ16(host, SDHCI_CLK_CTRL_REG);
30007e94:	6843      	ldr	r3, [r0, #4]
30007e96:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    clk &= ~SDHCI_CLK_EN;
30007e98:	f022 0204 	bic.w	r2, r2, #4
30007e9c:	0412      	lsls	r2, r2, #16
30007e9e:	0c12      	lsrs	r2, r2, #16
    REG_WRITE16(host, clk, SDHCI_CLK_CTRL_REG);
30007ea0:	859a      	strh	r2, [r3, #44]	; 0x2c
    ctrl = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
30007ea2:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
30007ea6:	b2d2      	uxtb	r2, r2
    if (mode > SDHCI_UHS_SDR12_MODE)
30007ea8:	b971      	cbnz	r1, 30007ec8 <sdhci_set_uhs_mode+0x34>
        ctrl &= ~SDHCI_HIGH_SPEED_EN;
30007eaa:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    REG_WRITE8(host, ctrl, SDHCI_HOST_CTRL1_REG);
30007eae:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    ctrl2 |= mode & SDHCI_UHS_MODE_MASK;
30007eb2:	f001 0107 	and.w	r1, r1, #7
    ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30007eb6:	6842      	ldr	r2, [r0, #4]
30007eb8:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
    ctrl2 &= ~SDHCI_UHS_MODE_MASK;
30007eba:	f023 0307 	bic.w	r3, r3, #7
30007ebe:	041b      	lsls	r3, r3, #16
30007ec0:	0c1b      	lsrs	r3, r3, #16
    ctrl2 |= mode & SDHCI_UHS_MODE_MASK;
30007ec2:	430b      	orrs	r3, r1
    REG_WRITE16(host, ctrl2, SDHCI_HOST_CTRL2_REG);
30007ec4:	87d3      	strh	r3, [r2, #62]	; 0x3e
}
30007ec6:	4770      	bx	r14
        ctrl |= SDHCI_HIGH_SPEED_EN;
30007ec8:	f042 0204 	orr.w	r2, r2, #4
30007ecc:	e7ef      	b.n	30007eae <sdhci_set_uhs_mode+0x1a>
30007ece:	bf00      	nop

30007ed0 <sdhci_set_bus_width>:
    reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
30007ed0:	6842      	ldr	r2, [r0, #4]
    switch (width) {
30007ed2:	2901      	cmp	r1, #1
    reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
30007ed4:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
30007ed8:	b2db      	uxtb	r3, r3
    switch (width) {
30007eda:	d011      	beq.n	30007f00 <sdhci_set_bus_width+0x30>
30007edc:	d312      	bcc.n	30007f04 <sdhci_set_bus_width+0x34>
30007ede:	2902      	cmp	r1, #2
{
30007ee0:	b510      	push	{r4, r14}
    switch (width) {
30007ee2:	d105      	bne.n	30007ef0 <sdhci_set_bus_width+0x20>
    return 0;
30007ee4:	2000      	movs	r0, #0
30007ee6:	f043 0320 	orr.w	r3, r3, #32
    REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
30007eea:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
}
30007eee:	bd10      	pop	{r4, r15}
            dprintf(CRITICAL, "Bus width is invalid: %u\n", width);
30007ef0:	f64c 5034 	movw	r0, #52532	; 0xcd34
30007ef4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30007ef8:	f00d fe5a 	bl	30015bb0 <_printf>
            return 1;
30007efc:	2001      	movs	r0, #1
}
30007efe:	bd10      	pop	{r4, r15}
30007f00:	f043 0302 	orr.w	r3, r3, #2
    REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
30007f04:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    return 0;
30007f08:	2000      	movs	r0, #0
}
30007f0a:	4770      	bx	r14

30007f0c <sdhci_send_command>:
{
30007f0c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    cmd->error = 0;
30007f10:	2300      	movs	r3, #0
{
30007f12:	b08d      	sub	sp, #52	; 0x34
30007f14:	460e      	mov	r6, r1
30007f16:	4607      	mov	r7, r0
    cmd->error = 0;
30007f18:	634b      	str	r3, [r1, #52]	; 0x34
    if (cmd->data_present) {
30007f1a:	7a0b      	ldrb	r3, [r1, #8]
30007f1c:	f8cd e020 	str.w	r14, [r13, #32]
30007f20:	b133      	cbz	r3, 30007f30 <sdhci_send_command+0x24>
        ASSERT(cmd->data.data_ptr);
30007f22:	6b8a      	ldr	r2, [r1, #56]	; 0x38
30007f24:	2a00      	cmp	r2, #0
30007f26:	f000 81c3 	beq.w	300082b0 <sdhci_send_command+0x3a4>
        ASSERT(IS_CACHE_LINE_ALIGNED(cmd->data.data_ptr));
30007f2a:	06d2      	lsls	r2, r2, #27
30007f2c:	f040 8234 	bne.w	30008398 <sdhci_send_command+0x48c>
    return cmd->data_present || cmd->resp_type & SDHCI_CMD_RESP_R1B;
30007f30:	b993      	cbnz	r3, 30007f58 <sdhci_send_command+0x4c>
30007f32:	8973      	ldrh	r3, [r6, #10]
        mask = SDHCI_STATE_CMD_MASK;
30007f34:	f013 0f02 	tst.w	r3, #2
        present_state = REG_READ32(host, SDHCI_PRESENT_STATE_REG);
30007f38:	687b      	ldr	r3, [r7, #4]
        mask = SDHCI_STATE_CMD_MASK;
30007f3a:	bf14      	ite	ne
30007f3c:	f04f 0903 	movne.w	r9, #3
30007f40:	f04f 0901 	moveq.w	r9, #1
        present_state = REG_READ32(host, SDHCI_PRESENT_STATE_REG);
30007f44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        if (!present_state) {
30007f46:	ea13 0909 	ands.w	r9, r3, r9
30007f4a:	d00c      	beq.n	30007f66 <sdhci_send_command+0x5a>
        thread_sleep(1);
30007f4c:	2001      	movs	r0, #1
30007f4e:	f00a f89f 	bl	30012090 <thread_sleep>
30007f52:	7a33      	ldrb	r3, [r6, #8]
    return cmd->data_present || cmd->resp_type & SDHCI_CMD_RESP_R1B;
30007f54:	2b00      	cmp	r3, #0
30007f56:	d0ec      	beq.n	30007f32 <sdhci_send_command+0x26>
        present_state = REG_READ32(host, SDHCI_PRESENT_STATE_REG);
30007f58:	687b      	ldr	r3, [r7, #4]
            mask |= SDHCI_STATE_DAT_MASK;
30007f5a:	f04f 0903 	mov.w	r9, #3
        present_state = REG_READ32(host, SDHCI_PRESENT_STATE_REG);
30007f5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
        if (!present_state) {
30007f60:	ea13 0909 	ands.w	r9, r3, r9
30007f64:	d1f2      	bne.n	30007f4c <sdhci_send_command+0x40>
    event_init(&host->cmd_event, false, EVENT_FLAG_AUTOUNSIGNAL);
30007f66:	2201      	movs	r2, #1
30007f68:	f107 0310 	add.w	r3, r7, #16
30007f6c:	4618      	mov	r0, r3
30007f6e:	4649      	mov	r1, r9
30007f70:	9307      	str	r3, [sp, #28]
30007f72:	f009 fc9f 	bl	300118b4 <event_init>
    sdhci_pre_xfer(host);
30007f76:	f8d7 a004 	ldr.w	r10, [r7, #4]
    REG_WRITE16(host, 0xFFFF, SDHCI_NRML_INT_STS_REG);
30007f7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    host->cmd = cmd;
30007f7e:	67fe      	str	r6, [r7, #124]	; 0x7c
    REG_WRITE16(host, 0xFFFF, SDHCI_NRML_INT_STS_REG);
30007f80:	f8aa 3030 	strh.w	r3, [r10, #48]	; 0x30
    REG_WRITE16(host, 0xFFFF, SDHCI_ERR_INT_STS_REG);
30007f84:	f8aa 3032 	strh.w	r3, [r10, #50]	; 0x32
    switch (cmd->resp_type) {
30007f88:	8973      	ldrh	r3, [r6, #10]
30007f8a:	2b04      	cmp	r3, #4
30007f8c:	f000 81ef 	beq.w	3000836e <sdhci_send_command+0x462>
30007f90:	f200 80f8 	bhi.w	30008184 <sdhci_send_command+0x278>
30007f94:	2b01      	cmp	r3, #1
30007f96:	f000 819d 	beq.w	300082d4 <sdhci_send_command+0x3c8>
30007f9a:	f0c0 81ea 	bcc.w	30008372 <sdhci_send_command+0x466>
30007f9e:	2b02      	cmp	r3, #2
            resp_type = SDHCI_CMD_RESP_48_BUSY;
30007fa0:	bf08      	it	eq
30007fa2:	2203      	moveq	r2, #3
    switch (cmd->resp_type) {
30007fa4:	f040 80f7 	bne.w	30008196 <sdhci_send_command+0x28a>
    if (cmd->data_present || cmd->cmd_index == CMD21_SEND_TUNING_BLOCK)
30007fa8:	7a31      	ldrb	r1, [r6, #8]
30007faa:	2900      	cmp	r1, #0
30007fac:	f040 8149 	bne.w	30008242 <sdhci_send_command+0x336>
30007fb0:	8831      	ldrh	r1, [r6, #0]
30007fb2:	2915      	cmp	r1, #21
30007fb4:	f000 8145 	beq.w	30008242 <sdhci_send_command+0x336>
    flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
30007fb8:	7a71      	ldrb	r1, [r6, #9]
    switch (cmd->resp_type) {
30007fba:	2b04      	cmp	r3, #4
    flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
30007fbc:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
30007fc0:	9206      	str	r2, [sp, #24]
    switch (cmd->resp_type) {
30007fc2:	f000 8147 	beq.w	30008254 <sdhci_send_command+0x348>
30007fc6:	f240 80f1 	bls.w	300081ac <sdhci_send_command+0x2a0>
30007fca:	2b40      	cmp	r3, #64	; 0x40
30007fcc:	f000 80f2 	beq.w	300081b4 <sdhci_send_command+0x2a8>
30007fd0:	2b80      	cmp	r3, #128	; 0x80
30007fd2:	f000 80ef 	beq.w	300081b4 <sdhci_send_command+0x2a8>
    if (cmd->cmd_timeout) {
30007fd6:	e9d6 340a 	ldrd	r3, r4, [r6, #40]	; 0x28
30007fda:	e9cd 3404 	strd	r3, r4, [r13, #16]
30007fde:	4323      	orrs	r3, r4
30007fe0:	f000 80ef 	beq.w	300081c2 <sdhci_send_command+0x2b6>
30007fe4:	f04f 080e 	mov.w	r8, #14
        t = 1 << (13 + i);
30007fe8:	f04f 0b01 	mov.w	r11, #1
        if (t / freq * 1000 * 1000 > us) {
30007fec:	e9cd 7609 	strd	r7, r6, [r13, #36]	; 0x24
30007ff0:	f1a8 040d 	sub.w	r4, r8, #13
    for (i = 0; i < 0xF; i++) {
30007ff4:	f1b8 0f1c 	cmp.w	r8, #28
30007ff8:	b2a4      	uxth	r4, r4
30007ffa:	f000 80e0 	beq.w	300081be <sdhci_send_command+0x2b2>
        if (t / freq * 1000 * 1000 > us) {
30007ffe:	f244 2240 	movw	r2, #16960	; 0x4240
        t = 1 << (13 + i);
30008002:	fa0b f008 	lsl.w	r0, r11, r8
        if (t / freq * 1000 * 1000 > us) {
30008006:	2300      	movs	r3, #0
30008008:	f2c0 020f 	movt	r2, #15
3000800c:	17c1      	asrs	r1, r0, #31
3000800e:	f011 ff07 	bl	30019e20 <__aeabi_uldivmod>
30008012:	f108 0801 	add.w	r8, r8, #1
30008016:	4606      	mov	r6, r0
30008018:	460f      	mov	r7, r1
3000801a:	0142      	lsls	r2, r0, #5
3000801c:	0149      	lsls	r1, r1, #5
3000801e:	1b92      	subs	r2, r2, r6
30008020:	ea41 63d6 	orr.w	r3, r1, r6, lsr #27
30008024:	eb63 0307 	sbc.w	r3, r3, r7
30008028:	ea4f 2c42 	mov.w	r12, r2, lsl #9
3000802c:	025d      	lsls	r5, r3, #9
3000802e:	ea45 55d2 	orr.w	r5, r5, r2, lsr #23
30008032:	eb1c 0206 	adds.w	r2, r12, r6
30008036:	eb45 0307 	adc.w	r3, r5, r7
3000803a:	0199      	lsls	r1, r3, #6
3000803c:	ea41 6192 	orr.w	r1, r1, r2, lsr #26
30008040:	9103      	str	r1, [sp, #12]
30008042:	0191      	lsls	r1, r2, #6
30008044:	9102      	str	r1, [sp, #8]
30008046:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
3000804a:	1a80      	subs	r0, r0, r2
3000804c:	eb61 0103 	sbc.w	r1, r1, r3
30008050:	1982      	adds	r2, r0, r6
30008052:	4610      	mov	r0, r2
30008054:	eb41 0307 	adc.w	r3, r1, r7
30008058:	4619      	mov	r1, r3
3000805a:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
3000805e:	428b      	cmp	r3, r1
30008060:	bf08      	it	eq
30008062:	4282      	cmpeq	r2, r0
30008064:	d2c4      	bcs.n	30007ff0 <sdhci_send_command+0xe4>
30008066:	4623      	mov	r3, r4
30008068:	2c0e      	cmp	r4, #14
3000806a:	e9dd 7609 	ldrd	r7, r6, [r13, #36]	; 0x24
3000806e:	bf28      	it	cs
30008070:	230e      	movcs	r3, #14
30008072:	b2db      	uxtb	r3, r3
    REG_WRITE8(host, timeout, SDHCI_TIMEOUT_REG);
30008074:	f88a 302e 	strb.w	r3, [r10, #46]	; 0x2e
    if (cmd->data_present) {
30008078:	7a33      	ldrb	r3, [r6, #8]
3000807a:	2b00      	cmp	r3, #0
3000807c:	f000 80a8 	beq.w	300081d0 <sdhci_send_command+0x2c4>
            (cmd->data.blk_sz) ? (cmd->data.num_blocks * cmd->data.blk_sz)
30008080:	6c33      	ldr	r3, [r6, #64]	; 0x40
        arch_clean_invalidate_cache_range(
30008082:	6bb0      	ldr	r0, [r6, #56]	; 0x38
30008084:	6c71      	ldr	r1, [r6, #68]	; 0x44
30008086:	2b00      	cmp	r3, #0
30008088:	f040 810a 	bne.w	300082a0 <sdhci_send_command+0x394>
3000808c:	0249      	lsls	r1, r1, #9
3000808e:	f7f9 ed40 	blx	30001b10 <arch_clean_invalidate_cache_range>
    num_blks = cmd->data.num_blocks;
30008092:	6c75      	ldr	r5, [r6, #68]	; 0x44
    data = p2ap((paddr_t)_paddr(cmd->data.data_ptr));
30008094:	6bb0      	ldr	r0, [r6, #56]	; 0x38
    num_blks = cmd->data.num_blocks;
30008096:	9509      	str	r5, [sp, #36]	; 0x24
    data = p2ap((paddr_t)_paddr(cmd->data.data_ptr));
30008098:	f007 fdcc 	bl	3000fc34 <p2ap>
    if (cmd->data.blk_sz) {
3000809c:	6c33      	ldr	r3, [r6, #64]	; 0x40
    data = p2ap((paddr_t)_paddr(cmd->data.data_ptr));
3000809e:	4604      	mov	r4, r0
    if (cmd->data.blk_sz) {
300080a0:	2b00      	cmp	r3, #0
300080a2:	f000 8145 	beq.w	30008330 <sdhci_send_command+0x424>
        sz = num_blks * cmd->data.blk_sz;
300080a6:	fb03 f805 	mul.w	r8, r3, r5
    if (host->caps.addr_64bit_v4) {
300080aa:	f897 30d4 	ldrb.w	r3, [r7, #212]	; 0xd4
        desc_len_max = SDHCI_ADMA2_DESC_LINE_SZ_V4;
300080ae:	2b00      	cmp	r3, #0
300080b0:	bf0c      	ite	eq
300080b2:	f44f 3180 	moveq.w	r1, #65536	; 0x10000
300080b6:	f04f 7180 	movne.w	r1, #16777216	; 0x1000000
    sg_len = len / desc_len_max;
300080ba:	fbb8 f3f1 	udiv	r3, r8, r1
        desc_len_max = SDHCI_ADMA2_DESC_LINE_SZ_V4;
300080be:	910b      	str	r1, [sp, #44]	; 0x2c
    if (remain) {
300080c0:	fb01 8b13 	mls	r11, r1, r3, r8
    sg_len = len / desc_len_max;
300080c4:	9304      	str	r3, [sp, #16]
300080c6:	f103 0a01 	add.w	r10, r3, #1
    if (remain) {
300080ca:	f1bb 0f00 	cmp.w	r11, #0
300080ce:	f000 8137 	beq.w	30008340 <sdhci_send_command+0x434>
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
300080d2:	2020      	movs	r0, #32
    table_len = ((sg_len + 1) * sizeof(struct desc_entry_a64));
300080d4:	f103 0b02 	add.w	r11, r3, #2
300080d8:	ea4f 1b0b 	mov.w	r11, r11, lsl #4
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
300080dc:	f10b 031f 	add.w	r3, r11, #31
300080e0:	f023 031f 	bic.w	r3, r3, #31
300080e4:	4619      	mov	r1, r3
300080e6:	930a      	str	r3, [sp, #40]	; 0x28
300080e8:	f00c fb14 	bl	30014714 <memalign>
    if (!sg_list) {
300080ec:	4605      	mov	r5, r0
300080ee:	2800      	cmp	r0, #0
300080f0:	f000 8164 	beq.w	300083bc <sdhci_send_command+0x4b0>
    memset(sg_list, 0, table_len);
300080f4:	465a      	mov	r2, r11
300080f6:	2100      	movs	r1, #0
        sg_len++;
300080f8:	f8cd a010 	str.w	r10, [r13, #16]
    memset(sg_list, 0, table_len);
300080fc:	f00c ec38 	blx	30014970 <memset>
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
30008100:	9502      	str	r5, [sp, #8]
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008102:	f8cd 9020 	str.w	r9, [r13, #32]
        sg_len++;
30008106:	f04f 0e00 	mov.w	r14, #0
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
3000810a:	f8dd 902c 	ldr.w	r9, [r13, #44]	; 0x2c
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
3000810e:	f64f 7bc0 	movw	r11, #65472	; 0xffc0
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008112:	f8dd a010 	ldr.w	r10, [r13, #16]
30008116:	960b      	str	r6, [sp, #44]	; 0x2c
30008118:	9704      	str	r7, [sp, #16]
3000811a:	e021      	b.n	30008160 <sdhci_send_command+0x254>
    dma_desc->addr_l = lower_32_bits((addr_t)addr);
3000811c:	606c      	str	r4, [r5, #4]
        offset = boundary_addr - addr;
3000811e:	1b3b      	subs	r3, r7, r4
        len -= offset;
30008120:	463c      	mov	r4, r7
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008122:	2600      	movs	r6, #0
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
30008124:	ea4f 4c03 	mov.w	r12, r3, lsl #16
30008128:	ea0b 2793 	and.w	r7, r11, r3, lsr #10
3000812c:	f04c 0c21 	orr.w	r12, r12, #33	; 0x21
30008130:	ea4c 0707 	orr.w	r7, r12, r7
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008134:	60ae      	str	r6, [r5, #8]
        len -= offset;
30008136:	1acb      	subs	r3, r1, r3
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
30008138:	f845 7b20 	str.w	r7, [r5], #32
3000813c:	041f      	lsls	r7, r3, #16
3000813e:	f047 0721 	orr.w	r7, r7, #33	; 0x21
30008142:	ea0b 2393 	and.w	r3, r11, r3, lsr #10
    for (i = 0; i < sg_len; i++) {
30008146:	f10e 0e01 	add.w	r14, r14, #1
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
3000814a:	433b      	orrs	r3, r7
        len -= tran_len;
3000814c:	eba8 0801 	sub.w	r8, r8, r1
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008150:	2100      	movs	r1, #0
    for (i = 0; i < sg_len; i++) {
30008152:	45d6      	cmp	r14, r10
    dma_desc->addr_l = lower_32_bits((addr_t)addr);
30008154:	6054      	str	r4, [r2, #4]
    if ((addr + len) > boundary_addr) {
30008156:	4604      	mov	r4, r0
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
30008158:	6091      	str	r1, [r2, #8]
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
3000815a:	6013      	str	r3, [r2, #0]
    for (i = 0; i < sg_len; i++) {
3000815c:	f000 80bc 	beq.w	300082d8 <sdhci_send_command+0x3cc>
        tran_len = MIN(len, desc_len_max);
30008160:	4641      	mov	r1, r8
30008162:	45c8      	cmp	r8, r9
30008164:	bf28      	it	cs
30008166:	4649      	movcs	r1, r9
    boundary_addr = CALC_BOUNDARY(addr, ADMA_BOUNDARY_SIZE);
30008168:	f104 6700 	add.w	r7, r4, #134217728	; 0x8000000
    if ((addr + len) > boundary_addr) {
3000816c:	1860      	adds	r0, r4, r1
    boundary_addr = CALC_BOUNDARY(addr, ADMA_BOUNDARY_SIZE);
3000816e:	f007 4778 	and.w	r7, r7, #4160749568	; 0xf8000000
    if ((addr + len) > boundary_addr) {
30008172:	4287      	cmp	r7, r0
30008174:	f105 0210 	add.w	r2, r5, #16
30008178:	d3d0      	bcc.n	3000811c <sdhci_send_command+0x210>
3000817a:	4617      	mov	r7, r2
3000817c:	460b      	mov	r3, r1
3000817e:	462a      	mov	r2, r5
30008180:	463d      	mov	r5, r7
30008182:	e7db      	b.n	3000813c <sdhci_send_command+0x230>
    switch (cmd->resp_type) {
30008184:	2b40      	cmp	r3, #64	; 0x40
30008186:	f000 80a5 	beq.w	300082d4 <sdhci_send_command+0x3c8>
3000818a:	2b80      	cmp	r3, #128	; 0x80
3000818c:	f000 80a2 	beq.w	300082d4 <sdhci_send_command+0x3c8>
30008190:	2b08      	cmp	r3, #8
30008192:	f000 809f 	beq.w	300082d4 <sdhci_send_command+0x3c8>
            dprintf(CRITICAL, "Invalid response type for the command\n");
30008196:	f64c 4088 	movw	r0, #52360	; 0xcc88
            return 1;
3000819a:	2401      	movs	r4, #1
            dprintf(CRITICAL, "Invalid response type for the command\n");
3000819c:	f2c3 0001 	movt	r0, #12289	; 0x3001
300081a0:	f00d fd06 	bl	30015bb0 <_printf>
}
300081a4:	4620      	mov	r0, r4
300081a6:	b00d      	add	sp, #52	; 0x34
300081a8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    switch (cmd->resp_type) {
300081ac:	3b01      	subs	r3, #1
300081ae:	2b01      	cmp	r3, #1
300081b0:	f63f af11 	bhi.w	30007fd6 <sdhci_send_command+0xca>
            flags |=
300081b4:	9b06      	ldr	r3, [sp, #24]
300081b6:	f043 0318 	orr.w	r3, r3, #24
300081ba:	9306      	str	r3, [sp, #24]
300081bc:	e70b      	b.n	30007fd6 <sdhci_send_command+0xca>
300081be:	e9dd 7609 	ldrd	r7, r6, [r13, #36]	; 0x24
    for (i = 0; i < 0xF; i++) {
300081c2:	230e      	movs	r3, #14
    REG_WRITE8(host, timeout, SDHCI_TIMEOUT_REG);
300081c4:	f88a 302e 	strb.w	r3, [r10, #46]	; 0x2e
    if (cmd->data_present) {
300081c8:	7a33      	ldrb	r3, [r6, #8]
300081ca:	2b00      	cmp	r3, #0
300081cc:	f47f af58 	bne.w	30008080 <sdhci_send_command+0x174>
300081d0:	687d      	ldr	r5, [r7, #4]
    REG_WRITE32(host, cmd->argument, SDHCI_ARGUMENT_REG);
300081d2:	6873      	ldr	r3, [r6, #4]
300081d4:	60ab      	str	r3, [r5, #8]
    if (cmd->data_present) {
300081d6:	7a33      	ldrb	r3, [r6, #8]
    if (cmd->trans_mode == SDHCI_MMC_READ)
300081d8:	69f2      	ldr	r2, [r6, #28]
        trans_mode |= SDHCI_READ_MODE;
300081da:	2a01      	cmp	r2, #1
300081dc:	bf08      	it	eq
300081de:	f04f 0910 	moveq.w	r9, #16
    if (cmd->data_present) {
300081e2:	b17b      	cbz	r3, 30008204 <sdhci_send_command+0x2f8>
        if (cmd->data.num_blocks > 1) {
300081e4:	6c73      	ldr	r3, [r6, #68]	; 0x44
300081e6:	2b01      	cmp	r3, #1
        trans_mode |= SDHCI_DMA_EN;
300081e8:	bf9c      	itt	ls
300081ea:	f049 0901 	orrls.w	r9, r9, #1
300081ee:	fa1f f989 	uxthls.w	r9, r9
        if (cmd->data.num_blocks > 1) {
300081f2:	d907      	bls.n	30008204 <sdhci_send_command+0x2f8>
            if (cmd->cmd23_support) {
300081f4:	6a72      	ldr	r2, [r6, #36]	; 0x24
300081f6:	2a00      	cmp	r2, #0
300081f8:	d055      	beq.n	300082a6 <sdhci_send_command+0x39a>
                REG_WRITE32(host, cmd->data.num_blocks,
300081fa:	602b      	str	r3, [r5, #0]
                trans_mode |=
300081fc:	f049 092b 	orr.w	r9, r9, #43	; 0x2b
30008200:	fa1f f989 	uxth.w	r9, r9
    REG_WRITE16(host, trans_mode, SDHCI_TRANS_MODE_REG);
30008204:	f8a5 900c 	strh.w	r9, [r5, #12]
    REG_WRITE16(host, SDHCI_PREP_CMD(cmd->cmd_index, flags), SDHCI_CMD_REG);
30008208:	f89d 3018 	ldrb.w	r3, [r13, #24]
3000820c:	8832      	ldrh	r2, [r6, #0]
3000820e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
30008212:	b29b      	uxth	r3, r3
30008214:	81eb      	strh	r3, [r5, #14]
    if (!host->tuning_in_progress)
30008216:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
3000821a:	b303      	cbz	r3, 3000825e <sdhci_send_command+0x352>
    ret = host->cmd->error;
3000821c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
3000821e:	6b5c      	ldr	r4, [r3, #52]	; 0x34
    if (ret) {
30008220:	bb34      	cbnz	r4, 30008270 <sdhci_send_command+0x364>
    if ((host->data_cmd.data_present && !host->async_mode) ||
30008222:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
30008226:	b113      	cbz	r3, 3000822e <sdhci_send_command+0x322>
30008228:	68fa      	ldr	r2, [r7, #12]
3000822a:	2a00      	cmp	r2, #0
3000822c:	d02e      	beq.n	3000828c <sdhci_send_command+0x380>
3000822e:	8972      	ldrh	r2, [r6, #10]
30008230:	2a02      	cmp	r2, #2
30008232:	f000 80a0 	beq.w	30008376 <sdhci_send_command+0x46a>
    host->cmd = NULL;
30008236:	2300      	movs	r3, #0
}
30008238:	4620      	mov	r0, r4
    host->cmd = NULL;
3000823a:	67fb      	str	r3, [r7, #124]	; 0x7c
}
3000823c:	b00d      	add	sp, #52	; 0x34
3000823e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        flags |= (1 << SDHCI_CMD_DATA_PRESENT_BIT);
30008242:	f042 0220 	orr.w	r2, r2, #32
    flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
30008246:	7a71      	ldrb	r1, [r6, #9]
    switch (cmd->resp_type) {
30008248:	2b04      	cmp	r3, #4
    flags |= (cmd->cmd_type << SDHCI_CMD_CMD_TYPE_BIT);
3000824a:	ea42 1281 	orr.w	r2, r2, r1, lsl #6
3000824e:	9206      	str	r2, [sp, #24]
    switch (cmd->resp_type) {
30008250:	f47f aeb9 	bne.w	30007fc6 <sdhci_send_command+0xba>
            flags |= (1 << SDHCI_CMD_CRC_CHECK_BIT);
30008254:	9b06      	ldr	r3, [sp, #24]
30008256:	f043 0308 	orr.w	r3, r3, #8
3000825a:	9306      	str	r3, [sp, #24]
3000825c:	e6bb      	b.n	30007fd6 <sdhci_send_command+0xca>
    return e->magic == EVENT_MAGIC;
}

static inline status_t event_wait(event_t *e)
{
    return event_wait_timeout(e, INFINITE_TIME);
3000825e:	9807      	ldr	r0, [sp, #28]
30008260:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
30008264:	f009 fb3c 	bl	300118e0 <event_wait_timeout>
    ret = host->cmd->error;
30008268:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
3000826a:	6b5c      	ldr	r4, [r3, #52]	; 0x34
    if (ret) {
3000826c:	2c00      	cmp	r4, #0
3000826e:	d0d8      	beq.n	30008222 <sdhci_send_command+0x316>
        sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
30008270:	2106      	movs	r1, #6
30008272:	4638      	mov	r0, r7
30008274:	f7ff fdec 	bl	30007e50 <sdhci_reset>
        if (cmd->resp_type == SDHCI_CMD_RESP_R1B) {
30008278:	8973      	ldrh	r3, [r6, #10]
3000827a:	2b02      	cmp	r3, #2
3000827c:	d0db      	beq.n	30008236 <sdhci_send_command+0x32a>
    if ((host->data_cmd.data_present && !host->async_mode) ||
3000827e:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
30008282:	2b00      	cmp	r3, #0
30008284:	d0d7      	beq.n	30008236 <sdhci_send_command+0x32a>
30008286:	68fb      	ldr	r3, [r7, #12]
30008288:	2b00      	cmp	r3, #0
3000828a:	d1d4      	bne.n	30008236 <sdhci_send_command+0x32a>
        if (!host->tuning_in_progress)
3000828c:	f897 3078 	ldrb.w	r3, [r7, #120]	; 0x78
30008290:	2b00      	cmp	r3, #0
30008292:	d078      	beq.n	30008386 <sdhci_send_command+0x47a>
            ret = host->data_cmd.error;
30008294:	f8d7 40b4 	ldr.w	r4, [r7, #180]	; 0xb4
            host->data_cmd.data_present = 0;
30008298:	2300      	movs	r3, #0
3000829a:	f887 3088 	strb.w	r3, [r7, #136]	; 0x88
3000829e:	e7ca      	b.n	30008236 <sdhci_send_command+0x32a>
        arch_clean_invalidate_cache_range(
300082a0:	fb01 f103 	mul.w	r1, r1, r3
300082a4:	e6f3      	b.n	3000808e <sdhci_send_command+0x182>
                trans_mode |=
300082a6:	f049 0927 	orr.w	r9, r9, #39	; 0x27
300082aa:	fa1f f989 	uxth.w	r9, r9
300082ae:	e7a9      	b.n	30008204 <sdhci_send_command+0x2f8>
        ASSERT(cmd->data.data_ptr);
300082b0:	f64c 43f4 	movw	r3, #52468	; 0xccf4
300082b4:	f64c 42cc 	movw	r2, #52428	; 0xcccc
300082b8:	f24a 011c 	movw	r1, #40988	; 0xa01c
300082bc:	f2c3 0301 	movt	r3, #12289	; 0x3001
300082c0:	9808      	ldr	r0, [sp, #32]
300082c2:	f2c3 0201 	movt	r2, #12289	; 0x3001
300082c6:	9300      	str	r3, [sp, #0]
300082c8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300082cc:	f240 3372 	movw	r3, #882	; 0x372
300082d0:	f00b ffa0 	bl	30014214 <_panic>
            resp_type = SDHCI_CMD_RESP_48;
300082d4:	2202      	movs	r2, #2
300082d6:	e667      	b.n	30007fa8 <sdhci_send_command+0x9c>
300082d8:	f8dd 9020 	ldr.w	r9, [r13, #32]
300082dc:	9f04      	ldr	r7, [sp, #16]
300082de:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
300082e0:	2303      	movs	r3, #3
    dma_desc->addr_l = lower_32_bits((addr_t)addr);
300082e2:	2400      	movs	r4, #0
    arch_clean_invalidate_cache_range((addr_t)sg_list,
300082e4:	f8dd 8008 	ldr.w	r8, [r13, #8]
    dma_desc->tran_att = attr | FV_ADMA2_ATTR_LEN(len);
300082e8:	602b      	str	r3, [r5, #0]
    arch_clean_invalidate_cache_range((addr_t)sg_list,
300082ea:	4640      	mov	r0, r8
300082ec:	990a      	ldr	r1, [sp, #40]	; 0x28
    dma_desc->addr_h = upper_32_bits((addr_t)addr);
300082ee:	e9c5 4401 	strd	r4, r4, [r5, #4]
    arch_clean_invalidate_cache_range((addr_t)sg_list,
300082f2:	f7f9 ec0e 	blx	30001b10 <arch_clean_invalidate_cache_range>
    adma_desc_paddr = p2ap((paddr_t)_paddr(adma_desc));
300082f6:	4640      	mov	r0, r8
300082f8:	f007 fc9c 	bl	3000fc34 <p2ap>
    REG_WRITE32(host, (uint32_t)adma_desc_paddr, SDHCI_ADM_ADDR_REG);
300082fc:	687d      	ldr	r5, [r7, #4]
300082fe:	65a8      	str	r0, [r5, #88]	; 0x58
    REG_WRITE32(host, upper_32_bits(adma_desc_paddr), SDHCI_ADM_ADDR_REG + 0x4);
30008300:	65ec      	str	r4, [r5, #92]	; 0x5c
    if (cmd->data.blk_sz) {
30008302:	6c33      	ldr	r3, [r6, #64]	; 0x40
30008304:	b1c3      	cbz	r3, 30008338 <sdhci_send_command+0x42c>
        REG_WRITE16(host, cmd->data.blk_sz, SDHCI_BLKSZ_REG);
30008306:	b29b      	uxth	r3, r3
30008308:	80ab      	strh	r3, [r5, #4]
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM) {
3000830a:	f897 30d1 	ldrb.w	r3, [r7, #209]	; 0xd1
        memcpy(&host->data_cmd, cmd, sizeof(struct mmc_command));
3000830e:	2248      	movs	r2, #72	; 0x48
30008310:	4631      	mov	r1, r6
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM) {
30008312:	2b02      	cmp	r3, #2
        REG_WRITE16(host, num_blks, SDHCI_BLK_CNT_REG);
30008314:	bf98      	it	ls
30008316:	f8bd 3024 	ldrhls.w	r3, [r13, #36]	; 0x24
        memcpy(&host->data_cmd, cmd, sizeof(struct mmc_command));
3000831a:	f107 0080 	add.w	r0, r7, #128	; 0x80
        REG_WRITE16(host, num_blks, SDHCI_BLK_CNT_REG);
3000831e:	bf92      	itee	ls
30008320:	80eb      	strhls	r3, [r5, #6]
        REG_WRITE32(host, num_blks, SDHCI_SDMASA_BLKCNT_REG);
30008322:	9b09      	ldrhi	r3, [sp, #36]	; 0x24
30008324:	602b      	strhi	r3, [r5, #0]
        cmd->data.sg_list = sdhci_adma_transfer(host, cmd);
30008326:	9b02      	ldr	r3, [sp, #8]
30008328:	63f3      	str	r3, [r6, #60]	; 0x3c
        memcpy(&host->data_cmd, cmd, sizeof(struct mmc_command));
3000832a:	f00c ea9c 	blx	30014864 <memcpy>
3000832e:	e750      	b.n	300081d2 <sdhci_send_command+0x2c6>
        sz = num_blks * SDHCI_MMC_BLK_SZ;
30008330:	9b09      	ldr	r3, [sp, #36]	; 0x24
30008332:	ea4f 2843 	mov.w	r8, r3, lsl #9
30008336:	e6b8      	b.n	300080aa <sdhci_send_command+0x19e>
        REG_WRITE16(host, SDHCI_MMC_BLK_SZ, SDHCI_BLKSZ_REG);
30008338:	f44f 7300 	mov.w	r3, #512	; 0x200
3000833c:	80ab      	strh	r3, [r5, #4]
3000833e:	e7e4      	b.n	3000830a <sdhci_send_command+0x3fe>
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
30008340:	2020      	movs	r0, #32
    table_len = ((sg_len + 1) * sizeof(struct desc_entry_a64));
30008342:	ea4f 1a0a 	mov.w	r10, r10, lsl #4
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
30008346:	f10a 031f 	add.w	r3, r10, #31
3000834a:	f023 031f 	bic.w	r3, r3, #31
3000834e:	4619      	mov	r1, r3
30008350:	930a      	str	r3, [sp, #40]	; 0x28
30008352:	f00c f9df 	bl	30014714 <memalign>
    if (!sg_list) {
30008356:	4605      	mov	r5, r0
30008358:	b380      	cbz	r0, 300083bc <sdhci_send_command+0x4b0>
    memset(sg_list, 0, table_len);
3000835a:	4652      	mov	r2, r10
3000835c:	4659      	mov	r1, r11
3000835e:	f00c eb08 	blx	30014970 <memset>
    for (i = 0; i < sg_len; i++) {
30008362:	9b04      	ldr	r3, [sp, #16]
    sg_list = memalign(CACHE_LINE, ROUNDUP(table_len, CACHE_LINE));
30008364:	9502      	str	r5, [sp, #8]
    for (i = 0; i < sg_len; i++) {
30008366:	2b00      	cmp	r3, #0
30008368:	f47f aecb 	bne.w	30008102 <sdhci_send_command+0x1f6>
3000836c:	e7b8      	b.n	300082e0 <sdhci_send_command+0x3d4>
            resp_type = SDHCI_CMD_RESP_136;
3000836e:	2201      	movs	r2, #1
30008370:	e61a      	b.n	30007fa8 <sdhci_send_command+0x9c>
            resp_type = SDHCI_CMD_RESP_NONE;
30008372:	464a      	mov	r2, r9
30008374:	e618      	b.n	30007fa8 <sdhci_send_command+0x9c>
        if (!host->tuning_in_progress)
30008376:	f897 2078 	ldrb.w	r2, [r7, #120]	; 0x78
3000837a:	b122      	cbz	r2, 30008386 <sdhci_send_command+0x47a>
        if (host->data_cmd.data_present) {
3000837c:	2b00      	cmp	r3, #0
3000837e:	d189      	bne.n	30008294 <sdhci_send_command+0x388>
            ret = host->cmd->error;
30008380:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
30008382:	6b5c      	ldr	r4, [r3, #52]	; 0x34
30008384:	e757      	b.n	30008236 <sdhci_send_command+0x32a>
30008386:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000838a:	f107 0048 	add.w	r0, r7, #72	; 0x48
3000838e:	f009 faa7 	bl	300118e0 <event_wait_timeout>
30008392:	f897 3088 	ldrb.w	r3, [r7, #136]	; 0x88
30008396:	e7f1      	b.n	3000837c <sdhci_send_command+0x470>
        ASSERT(IS_CACHE_LINE_ALIGNED(cmd->data.data_ptr));
30008398:	f64c 5308 	movw	r3, #52488	; 0xcd08
3000839c:	f64c 42cc 	movw	r2, #52428	; 0xcccc
300083a0:	f24a 011c 	movw	r1, #40988	; 0xa01c
300083a4:	f2c3 0301 	movt	r3, #12289	; 0x3001
300083a8:	9808      	ldr	r0, [sp, #32]
300083aa:	f2c3 0201 	movt	r2, #12289	; 0x3001
300083ae:	9300      	str	r3, [sp, #0]
300083b0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300083b4:	f240 3373 	movw	r3, #883	; 0x373
300083b8:	f00b ff2c 	bl	30014214 <_panic>
        dprintf(CRITICAL, "Error allocating memory\n");
300083bc:	f64c 40b0 	movw	r0, #52400	; 0xccb0
300083c0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300083c4:	f00d fbf4 	bl	30015bb0 <_printf>
        ASSERT(0);
300083c8:	f641 2300 	movw	r3, #6656	; 0x1a00
300083cc:	f64c 42cc 	movw	r2, #52428	; 0xcccc
300083d0:	f2c3 0302 	movt	r3, #12290	; 0x3002
300083d4:	f24a 011c 	movw	r1, #40988	; 0xa01c
300083d8:	f2c3 0201 	movt	r2, #12289	; 0x3001
300083dc:	9300      	str	r3, [sp, #0]
300083de:	f2c3 0101 	movt	r1, #12289	; 0x3001
300083e2:	9808      	ldr	r0, [sp, #32]
300083e4:	f240 23e2 	movw	r3, #738	; 0x2e2
300083e8:	f00b ff14 	bl	30014214 <_panic>

300083ec <sdhci_data_thread>:

static int sdhci_data_thread(void *arg)
{
300083ec:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
            event_signal(&host->data_complete_event, false);
            continue;
        }
        else {
            if (data_cmd->error) {
                dprintf(CRITICAL, "sdhci data error! 0x%08x\n", data_cmd->error);
300083f0:	f64c 1a48 	movw	r10, #51528	; 0xc948
                dprintf(CRITICAL, "sdhci busy error! 0x%08x\n", host->cmd->error);
300083f4:	f64c 1b2c 	movw	r11, #51500	; 0xc92c
{
300083f8:	4605      	mov	r5, r0
300083fa:	b093      	sub	sp, #76	; 0x4c
300083fc:	f100 072c 	add.w	r7, r0, #44	; 0x2c
30008400:	f100 0904 	add.w	r9, r0, #4
30008404:	f100 0848 	add.w	r8, r0, #72	; 0x48
                dprintf(CRITICAL, "sdhci data error! 0x%08x\n", data_cmd->error);
30008408:	f2c3 0a01 	movt	r10, #12289	; 0x3001
    struct mmc_handle *handle = NULL;
3000840c:	2600      	movs	r6, #0
                dprintf(CRITICAL, "sdhci busy error! 0x%08x\n", host->cmd->error);
3000840e:	f2c3 0b01 	movt	r11, #12289	; 0x3001
30008412:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
30008416:	4638      	mov	r0, r7
30008418:	f009 fa62 	bl	300118e0 <event_wait_timeout>
        if (host->parent) {
3000841c:	f8d5 40e0 	ldr.w	r4, [r5, #224]	; 0xe0
        if (!host->data_cmd.data_present) {
30008420:	f895 3088 	ldrb.w	r3, [r5, #136]	; 0x88
        if (host->parent) {
30008424:	2c00      	cmp	r4, #0
30008426:	bf08      	it	eq
30008428:	4634      	moveq	r4, r6
        if (!host->data_cmd.data_present) {
3000842a:	b1f3      	cbz	r3, 3000846a <sdhci_data_thread+0x7e>
            if (data_cmd->error) {
3000842c:	f8d5 10b4 	ldr.w	r1, [r5, #180]	; 0xb4
30008430:	bb81      	cbnz	r1, 30008494 <sdhci_data_thread+0xa8>
                /* Send abort cmd only when data present */
                sdhci_cmd_abort(host);
            }
        }

        if (data_cmd->trans_mode == SDHCI_MMC_READ) {
30008432:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
30008436:	2b01      	cmp	r3, #1
30008438:	d020      	beq.n	3000847c <sdhci_data_thread+0x90>
                    ? (data_cmd->data.num_blocks * data_cmd->data.blk_sz)
                    : (data_cmd->data.num_blocks * SDHCI_MMC_BLK_SZ));
        }

        /* Free the scatter/gather list */
        if (data_cmd->data.sg_list) {
3000843a:	f8d5 00bc 	ldr.w	r0, [r5, #188]	; 0xbc
3000843e:	b120      	cbz	r0, 3000844a <sdhci_data_thread+0x5e>
            free(data_cmd->data.sg_list);
30008440:	f00c f9a4 	bl	3001478c <free>
            data_cmd->data.sg_list = NULL;
30008444:	2300      	movs	r3, #0
30008446:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc
        }

        if (handle && handle->event_handle) {
3000844a:	2c00      	cmp	r4, #0
3000844c:	d040      	beq.n	300084d0 <sdhci_data_thread+0xe4>
3000844e:	6a23      	ldr	r3, [r4, #32]
30008450:	2b00      	cmp	r3, #0
30008452:	d03d      	beq.n	300084d0 <sdhci_data_thread+0xe4>
            data_cmd->data_present = 0;
30008454:	2100      	movs	r1, #0
{
30008456:	4626      	mov	r6, r4
            handle->opt_result = data_cmd->error;
30008458:	f8d5 20b4 	ldr.w	r2, [r5, #180]	; 0xb4
            data_cmd->data_present = 0;
3000845c:	f885 1088 	strb.w	r1, [r5, #136]	; 0x88
            handle->event_handle(handle->opt_type, handle->opt_result);
30008460:	4611      	mov	r1, r2
30008462:	69a0      	ldr	r0, [r4, #24]
            handle->opt_result = data_cmd->error;
30008464:	61e2      	str	r2, [r4, #28]
            handle->event_handle(handle->opt_type, handle->opt_result);
30008466:	4798      	blx	r3
30008468:	e7d3      	b.n	30008412 <sdhci_data_thread+0x26>
            if (host->cmd->error) {
3000846a:	6feb      	ldr	r3, [r5, #124]	; 0x7c
3000846c:	6b59      	ldr	r1, [r3, #52]	; 0x34
3000846e:	bbb9      	cbnz	r1, 300084e0 <sdhci_data_thread+0xf4>
            event_signal(&host->data_complete_event, false);
30008470:	2100      	movs	r1, #0
30008472:	4640      	mov	r0, r8
30008474:	f009 fa5a 	bl	3001192c <event_signal>
{
30008478:	4626      	mov	r6, r4
3000847a:	e7ca      	b.n	30008412 <sdhci_data_thread+0x26>
                (data_cmd->data.blk_sz)
3000847c:	f8d5 30c0 	ldr.w	r3, [r5, #192]	; 0xc0
            arch_invalidate_cache_range(
30008480:	f8d5 00b8 	ldr.w	r0, [r5, #184]	; 0xb8
30008484:	f8d5 10c4 	ldr.w	r1, [r5, #196]	; 0xc4
30008488:	b343      	cbz	r3, 300084dc <sdhci_data_thread+0xf0>
3000848a:	fb01 f103 	mul.w	r1, r1, r3
3000848e:	f7f9 eb42 	blx	30001b14 <arch_invalidate_cache_range>
30008492:	e7d2      	b.n	3000843a <sdhci_data_thread+0x4e>
                dprintf(CRITICAL, "sdhci data error! 0x%08x\n", data_cmd->error);
30008494:	4650      	mov	r0, r10
    cmd.cmd_index = CMD12_STOP_TRANSMISSION;
30008496:	260c      	movs	r6, #12
                dprintf(CRITICAL, "sdhci data error! 0x%08x\n", data_cmd->error);
30008498:	f00d fb8a 	bl	30015bb0 <_printf>
                sdhci_dumpregs(host);
3000849c:	4648      	mov	r0, r9
3000849e:	f7ff fbbb 	bl	30007c18 <sdhci_dumpregs.isra.7>
                sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
300084a2:	4628      	mov	r0, r5
300084a4:	2106      	movs	r1, #6
300084a6:	f7ff fcd3 	bl	30007e50 <sdhci_reset>
    memset(&cmd, 0, sizeof(struct mmc_command));
300084aa:	2246      	movs	r2, #70	; 0x46
300084ac:	2100      	movs	r1, #0
300084ae:	f10d 0002 	add.w	r0, r13, #2
300084b2:	f00c ea5e 	blx	30014970 <memset>
    cmd.cmd_type = SDHCI_CMD_TYPE_ABORT;
300084b6:	2203      	movs	r2, #3
    cmd.resp_type = SDHCI_CMD_RESP_R1;
300084b8:	2301      	movs	r3, #1
    sdhci_send_command(host, &cmd);
300084ba:	4669      	mov	r1, r13
    cmd.cmd_index = CMD12_STOP_TRANSMISSION;
300084bc:	f8ad 6000 	strh.w	r6, [r13]
    sdhci_send_command(host, &cmd);
300084c0:	4628      	mov	r0, r5
    cmd.cmd_type = SDHCI_CMD_TYPE_ABORT;
300084c2:	f88d 2009 	strb.w	r2, [r13, #9]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
300084c6:	f8ad 300a 	strh.w	r3, [r13, #10]
    sdhci_send_command(host, &cmd);
300084ca:	f7ff fd1f 	bl	30007f0c <sdhci_send_command>
300084ce:	e7b0      	b.n	30008432 <sdhci_data_thread+0x46>
        }
        else {
            DBG("\n %s:signal complete event!\n", __func__);
            event_signal(&host->data_complete_event, true);
300084d0:	2101      	movs	r1, #1
300084d2:	4640      	mov	r0, r8
300084d4:	f009 fa2a 	bl	3001192c <event_signal>
{
300084d8:	4626      	mov	r6, r4
300084da:	e79a      	b.n	30008412 <sdhci_data_thread+0x26>
            arch_invalidate_cache_range(
300084dc:	0249      	lsls	r1, r1, #9
300084de:	e7d6      	b.n	3000848e <sdhci_data_thread+0xa2>
                dprintf(CRITICAL, "sdhci busy error! 0x%08x\n", host->cmd->error);
300084e0:	4658      	mov	r0, r11
300084e2:	f00d fb65 	bl	30015bb0 <_printf>
                sdhci_dumpregs(host);
300084e6:	4648      	mov	r0, r9
300084e8:	f7ff fb96 	bl	30007c18 <sdhci_dumpregs.isra.7>
                sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
300084ec:	2106      	movs	r1, #6
300084ee:	4628      	mov	r0, r5
300084f0:	f7ff fcae 	bl	30007e50 <sdhci_reset>
300084f4:	e7bc      	b.n	30008470 <sdhci_data_thread+0x84>
300084f6:	bf00      	nop

300084f8 <sdhci_execute_tuning>:
{
300084f8:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
300084fc:	4616      	mov	r6, r2
300084fe:	4604      	mov	r4, r0
    ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30008500:	6842      	ldr	r2, [r0, #4]
30008502:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
    ctrl2 &= ~SDHCI_SAMPLE_CLK_SEL;
30008504:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    reg = REG_READ32(host, vender_base + SDHCI_VENDER_AT_CTRL_REG);
30008508:	f102 0740 	add.w	r7, r2, #64	; 0x40
    ctrl2 &= ~SDHCI_SAMPLE_CLK_SEL;
3000850c:	041b      	lsls	r3, r3, #16
{
3000850e:	460d      	mov	r5, r1
30008510:	b093      	sub	sp, #76	; 0x4c
    sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
30008512:	2106      	movs	r1, #6
    ctrl2 &= ~SDHCI_SAMPLE_CLK_SEL;
30008514:	0c1b      	lsrs	r3, r3, #16
    REG_WRITE16(host, ctrl2, SDHCI_HOST_CTRL2_REG);
30008516:	87d3      	strh	r3, [r2, #62]	; 0x3e
    vender_base = REG_READ16(host, SDHCI_VENDOR_BASE_REG) & 0xFFF;
30008518:	f8b2 20e8 	ldrh.w	r2, [r2, #232]	; 0xe8
    reg = REG_READ32(host, vender_base + SDHCI_VENDER_AT_CTRL_REG);
3000851c:	f3c2 020b 	ubfx	r2, r2, #0, #12
30008520:	59d3      	ldr	r3, [r2, r7]
    reg &= ~(SDHCI_TUNE_SWIN_TH_VAL_MASK << SDHCI_TUNE_SWIN_TH_VAL_LSB);
30008522:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    reg |= SDHCI_TUNE_CLK_STOP_EN_MASK;
30008526:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
3000852a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    REG_WRITE32(host, reg, vender_base + SDHCI_VENDER_AT_CTRL_REG);
3000852e:	51d3      	str	r3, [r2, r7]
    sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
30008530:	f7ff fc8e 	bl	30007e50 <sdhci_reset>
    if (host->ops->platform_execute_tuning) {
30008534:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
30008538:	695f      	ldr	r7, [r3, #20]
3000853a:	b137      	cbz	r7, 3000854a <sdhci_execute_tuning+0x52>
        return host->ops->platform_execute_tuning(host, opcode, bus_width);
3000853c:	4632      	mov	r2, r6
3000853e:	4629      	mov	r1, r5
30008540:	4620      	mov	r0, r4
30008542:	47b8      	blx	r7
}
30008544:	b013      	add	sp, #76	; 0x4c
30008546:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    clk_ctrl = REG_READ16(host, SDHCI_CLK_CTRL_REG);
3000854a:	6863      	ldr	r3, [r4, #4]
3000854c:	f8b3 802c 	ldrh.w	r8, [r3, #44]	; 0x2c
    spin(1);
30008550:	2001      	movs	r0, #1
    clk_ctrl &= ~SDHCI_CLK_EN;
30008552:	f028 0804 	bic.w	r8, r8, #4
    host->tuning_in_progress = 1;
30008556:	4681      	mov	r9, r0
    cmd.cmd_index = opcode;
30008558:	b2ad      	uxth	r5, r5
    clk_ctrl &= ~SDHCI_CLK_EN;
3000855a:	ea4f 4808 	mov.w	r8, r8, lsl #16
3000855e:	ea4f 4818 	mov.w	r8, r8, lsr #16
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
30008562:	f8a3 802c 	strh.w	r8, [r3, #44]	; 0x2c
    clk_ctrl |= SDHCI_CLK_EN;
30008566:	f048 0804 	orr.w	r8, r8, #4
    spin(1);
3000856a:	f00b fe41 	bl	300141f0 <spin>
    ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
3000856e:	6862      	ldr	r2, [r4, #4]
30008570:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
    spin(1);
30008572:	4648      	mov	r0, r9
    ctrl2 |= SDHCI_EXEC_TUNING;
30008574:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    REG_WRITE16(host, ctrl2, SDHCI_HOST_CTRL2_REG);
30008578:	87d3      	strh	r3, [r2, #62]	; 0x3e
    host->tuning_in_progress = 1;
3000857a:	f884 9078 	strb.w	r9, [r4, #120]	; 0x78
    spin(1);
3000857e:	f00b fe37 	bl	300141f0 <spin>
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
30008582:	6863      	ldr	r3, [r4, #4]
30008584:	f8a3 802c 	strh.w	r8, [r3, #44]	; 0x2c
    spin(1);
30008588:	4648      	mov	r0, r9
3000858a:	f00b fe31 	bl	300141f0 <spin>
    memset(&cmd, 0, sizeof(struct mmc_command));
3000858e:	4639      	mov	r1, r7
30008590:	2242      	movs	r2, #66	; 0x42
30008592:	f10d 0002 	add.w	r0, r13, #2
30008596:	f00c e9ec 	blx	30014970 <memset>
    if (cmd.cmd_index == CMD21_SEND_TUNING_BLOCK &&
3000859a:	2e02      	cmp	r6, #2
3000859c:	bf08      	it	eq
3000859e:	2d15      	cmpeq	r5, #21
        cmd.data.blk_sz = 128;
300085a0:	bf0c      	ite	eq
300085a2:	2380      	moveq	r3, #128	; 0x80
        cmd.data.blk_sz = 64;
300085a4:	2340      	movne	r3, #64	; 0x40
    cmd.resp_type = SDHCI_CMD_RESP_R1;
300085a6:	f8ad 900a 	strh.w	r9, [r13, #10]
300085aa:	1d27      	adds	r7, r4, #4
    cmd.trans_mode = SDHCI_MMC_READ;
300085ac:	f8cd 901c 	str.w	r9, [r13, #28]
    for (int i = 0; i < MAX_TUNING_LOOP; i++) {
300085b0:	2600      	movs	r6, #0
    cmd.data.num_blocks = 0x1;
300085b2:	f8cd 9044 	str.w	r9, [r13, #68]	; 0x44
    cmd.cmd_index = opcode;
300085b6:	f8ad 5000 	strh.w	r5, [r13]
        cmd.data.blk_sz = 64;
300085ba:	9310      	str	r3, [sp, #64]	; 0x40
300085bc:	461a      	mov	r2, r3
    REG_WRITE16(host, cmd.data.blk_sz, SDHCI_BLKSZ_REG);
300085be:	6863      	ldr	r3, [r4, #4]
300085c0:	809a      	strh	r2, [r3, #4]
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM)
300085c2:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
300085c6:	2a02      	cmp	r2, #2
        REG_WRITE32(host, cmd.data.num_blocks, SDHCI_SDMASA_BLKCNT_REG);
300085c8:	f04f 0201 	mov.w	r2, #1
300085cc:	bf8c      	ite	hi
300085ce:	601a      	strhi	r2, [r3, #0]
        REG_WRITE16(host, cmd.data.num_blocks, SDHCI_BLK_CNT_REG);
300085d0:	80da      	strhls	r2, [r3, #6]
    REG_WRITE16(host, SDHCI_READ_MODE, SDHCI_TRANS_MODE_REG);
300085d2:	2210      	movs	r2, #16
300085d4:	819a      	strh	r2, [r3, #12]
        sdhci_send_command(host, &cmd);
300085d6:	4669      	mov	r1, r13
300085d8:	4620      	mov	r0, r4
300085da:	f7ff fc97 	bl	30007f0c <sdhci_send_command>
                                     uint16_t mask, bool clear, uint32_t ms)
{
    uint32_t val;
    lk_time_t timeout;

    timeout = current_time() + ms;
300085de:	f7f8 f9a5 	bl	3000092c <current_time>

    while (1) {
        val = REG_READ16(host, reg);
300085e2:	6863      	ldr	r3, [r4, #4]
300085e4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
        if (clear)
            val = ~val;
        val &= mask;

        if (val == mask)
300085e6:	0691      	lsls	r1, r2, #26
    timeout = current_time() + ms;
300085e8:	f100 0532 	add.w	r5, r0, #50	; 0x32
        if (val == mask)
300085ec:	d42b      	bmi.n	30008646 <sdhci_execute_tuning+0x14e>
300085ee:	e005      	b.n	300085fc <sdhci_execute_tuning+0x104>
            return 0;
        if (current_time() > timeout)
            return 1;
        spin(1);
300085f0:	f00b fdfe 	bl	300141f0 <spin>
        val = REG_READ16(host, reg);
300085f4:	6863      	ldr	r3, [r4, #4]
300085f6:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
        if (val == mask)
300085f8:	0692      	lsls	r2, r2, #26
300085fa:	d424      	bmi.n	30008646 <sdhci_execute_tuning+0x14e>
        if (current_time() > timeout)
300085fc:	f7f8 f996 	bl	3000092c <current_time>
30008600:	4285      	cmp	r5, r0
        spin(1);
30008602:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
30008606:	d2f3      	bcs.n	300085f0 <sdhci_execute_tuning+0xf8>
            dprintf(CRITICAL, "sdhci tuning timeout!\n");
30008608:	f64c 401c 	movw	r0, #52252	; 0xcc1c
3000860c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008610:	f00d face 	bl	30015bb0 <_printf>
            sdhci_dumpregs(host);
30008614:	4638      	mov	r0, r7
30008616:	f7ff faff 	bl	30007c18 <sdhci_dumpregs.isra.7>
        dprintf(CRITICAL, "sdhci tuning failed, abort tuning state!\n");
3000861a:	f64c 30c4 	movw	r0, #52164	; 0xcbc4
3000861e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008622:	f00d fac5 	bl	30015bb0 <_printf>
    ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30008626:	6862      	ldr	r2, [r4, #4]
30008628:	8fd3      	ldrh	r3, [r2, #62]	; 0x3e
    sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
3000862a:	4620      	mov	r0, r4
3000862c:	2106      	movs	r1, #6
    ctrl2 &= ~SDHCI_SAMPLE_CLK_SEL;
3000862e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
30008632:	041b      	lsls	r3, r3, #16
30008634:	0c1b      	lsrs	r3, r3, #16
    REG_WRITE16(host, ctrl2, SDHCI_HOST_CTRL2_REG);
30008636:	87d3      	strh	r3, [r2, #62]	; 0x3e
    sdhci_reset(host, SOFT_RESET_CMD | SOFT_RESET_DATA);
30008638:	f7ff fc0a 	bl	30007e50 <sdhci_reset>
        ret = 1;
3000863c:	2001      	movs	r0, #1
    host->tuning_in_progress = 0;
3000863e:	2300      	movs	r3, #0
30008640:	f884 3078 	strb.w	r3, [r4, #120]	; 0x78
    return ret;
30008644:	e77e      	b.n	30008544 <sdhci_execute_tuning+0x4c>
        reg = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30008646:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
30008648:	b29b      	uxth	r3, r3
        if (!(reg & SDHCI_EXEC_TUNING)) {
3000864a:	f013 0540 	ands.w	r5, r3, #64	; 0x40
3000864e:	d003      	beq.n	30008658 <sdhci_execute_tuning+0x160>
    for (int i = 0; i < MAX_TUNING_LOOP; i++) {
30008650:	3601      	adds	r6, #1
30008652:	2e8c      	cmp	r6, #140	; 0x8c
30008654:	d1bf      	bne.n	300085d6 <sdhci_execute_tuning+0xde>
30008656:	e7e0      	b.n	3000861a <sdhci_execute_tuning+0x122>
            if (reg & SDHCI_SAMPLE_CLK_SEL) {
30008658:	061b      	lsls	r3, r3, #24
3000865a:	d5de      	bpl.n	3000861a <sdhci_execute_tuning+0x122>
                if (i < 40)
3000865c:	2e27      	cmp	r6, #39	; 0x27
3000865e:	dd01      	ble.n	30008664 <sdhci_execute_tuning+0x16c>
    uint32_t ret = 0;
30008660:	4628      	mov	r0, r5
30008662:	e7ec      	b.n	3000863e <sdhci_execute_tuning+0x146>
                    dprintf(CRITICAL, "SDHC: tuning cycle abnormal, num is %d!\n", i);
30008664:	f64c 30f0 	movw	r0, #52208	; 0xcbf0
30008668:	4631      	mov	r1, r6
3000866a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000866e:	f00d fa9f 	bl	30015bb0 <_printf>
    uint32_t ret = 0;
30008672:	4628      	mov	r0, r5
30008674:	e7e3      	b.n	3000863e <sdhci_execute_tuning+0x146>
30008676:	bf00      	nop

30008678 <sdhci_init>:
 *           4. Set initial bus width
 *           5. Set Adma mode
 *           6. Enable the error status
 */
void sdhci_init(struct sdhci_host *host)
{
30008678:	b570      	push	{r4, r5, r6, r14}
3000867a:	4604      	mov	r4, r0
    uint32_t caps[2];
    uint16_t spec_version;

    host->spin_lock = SPIN_LOCK_INITIAL_VALUE;
3000867c:	2500      	movs	r5, #0
    event_init(&host->cmd_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000867e:	4629      	mov	r1, r5
{
30008680:	b082      	sub	sp, #8
    host->spin_lock = SPIN_LOCK_INITIAL_VALUE;
30008682:	6665      	str	r5, [r4, #100]	; 0x64
    event_init(&host->cmd_event, false, EVENT_FLAG_AUTOUNSIGNAL);
30008684:	3010      	adds	r0, #16
30008686:	2201      	movs	r2, #1
30008688:	f009 f914 	bl	300118b4 <event_init>
    event_init(&host->data_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000868c:	4629      	mov	r1, r5
3000868e:	2201      	movs	r2, #1
30008690:	f104 002c 	add.w	r0, r4, #44	; 0x2c
30008694:	f009 f90e 	bl	300118b4 <event_init>
    event_init(&host->data_complete_event, false, EVENT_FLAG_AUTOUNSIGNAL);
30008698:	4629      	mov	r1, r5
3000869a:	2201      	movs	r2, #1
3000869c:	f104 0048 	add.w	r0, r4, #72	; 0x48
300086a0:	f009 f908 	bl	300118b4 <event_init>

    sdhci_reset(host, SDHCI_SOFT_RESET);
300086a4:	4620      	mov	r0, r4
300086a6:	2101      	movs	r1, #1
300086a8:	f7ff fbd2 	bl	30007e50 <sdhci_reset>

    spec_version = REG_READ16(host, SDHCI_SPEC_VERSION_REG);
300086ac:	6863      	ldr	r3, [r4, #4]
300086ae:	f8b3 20fe 	ldrh.w	r2, [r3, #254]	; 0xfe
    host->caps.spec_version = (uint8_t)(spec_version & 0xff);
300086b2:	f884 20d1 	strb.w	r2, [r4, #209]	; 0xd1
    /* Read the capabilities register & store the info */
    caps[0] = REG_READ32(host, SDHCI_CAPS_REG1);
300086b6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    caps[1] = REG_READ32(host, SDHCI_CAPS_REG2);
300086b8:	6c59      	ldr	r1, [r3, #68]	; 0x44
    DBG("\n %s: Host version: %d capability: cap1:0x%08x, cap2: 0x%08x\n",
        __func__, host->caps.spec_version, caps[0], caps[1]);

    host->caps.base_clk_rate =
        (caps[0] & SDHCI_CLK_RATE_MASK) >> SDHCI_CLK_RATE_BIT;
300086ba:	f3c2 2307 	ubfx	r3, r2, #8, #8
    host->caps.base_clk_rate *= 1000000;
    /* Get the max block length for mmc */
    host->caps.max_blk_len =
        (caps[0] & SDHCI_BLK_LEN_MASK) >> SDHCI_BLK_LEN_BIT;
300086be:	f3c2 4501 	ubfx	r5, r2, #16, #2
    host->caps.base_clk_rate *= 1000000;
300086c2:	ebc3 1043 	rsb	r0, r3, r3, lsl #5
    host->caps.max_blk_len =
300086c6:	f8c4 50cc 	str.w	r5, [r4, #204]	; 0xcc

    /* 8 bit Bus width */
    if (caps[0] & SDHCI_8BIT_WIDTH_MASK) {
300086ca:	0355      	lsls	r5, r2, #13
    host->caps.base_clk_rate *= 1000000;
300086cc:	ebc0 1080 	rsb	r0, r0, r0, lsl #6
300086d0:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
300086d4:	ea4f 1383 	mov.w	r3, r3, lsl #6
300086d8:	f8c4 30c8 	str.w	r3, [r4, #200]	; 0xc8
        host->caps.bus_width_8bit = 1;
300086dc:	bf44      	itt	mi
300086de:	2301      	movmi	r3, #1
300086e0:	f884 30d0 	strbmi.w	r3, [r4, #208]	; 0xd0
    }

    /* Adma2 support */
    if (caps[0] & SDHCI_BLK_ADMA_MASK) {
300086e4:	0310      	lsls	r0, r2, #12
        host->caps.adma2_support = 1;
300086e6:	bf44      	itt	mi
300086e8:	2301      	movmi	r3, #1
300086ea:	f884 30d2 	strbmi.w	r3, [r4, #210]	; 0xd2
    }

    /* V4 64bit address support */
    if (caps[0] & SDHCI_CAP_ADDR_64BIT_V4) {
300086ee:	0113      	lsls	r3, r2, #4
        host->caps.addr_64bit_v4 = 1;
300086f0:	bf44      	itt	mi
300086f2:	2301      	movmi	r3, #1
300086f4:	f884 30d4 	strbmi.w	r3, [r4, #212]	; 0xd4
    }

    /* V3 64bit address support */
    if (caps[0] & SDHCI_CAP_ADDR_64BIT_V3) {
300086f8:	00d6      	lsls	r6, r2, #3
        host->caps.addr_64bit_v3 = 1;
300086fa:	bf44      	itt	mi
300086fc:	2301      	movmi	r3, #1
300086fe:	f884 30d3 	strbmi.w	r3, [r4, #211]	; 0xd3
    }

    /* Supported voltage, do nothing when it has been set */
    if (host->caps.voltage) {
30008702:	f894 30d5 	ldrb.w	r3, [r4, #213]	; 0xd5
30008706:	b92b      	cbnz	r3, 30008714 <sdhci_init+0x9c>
        ;
    }
    else if (caps[0] & SDHCI_3_3_VOL_MASK) {
30008708:	01d5      	lsls	r5, r2, #7
        host->caps.voltage = SDHCI_VOL_3_3;
3000870a:	bf44      	itt	mi
3000870c:	2307      	movmi	r3, #7
3000870e:	f884 30d5 	strbmi.w	r3, [r4, #213]	; 0xd5
    else if (caps[0] & SDHCI_3_3_VOL_MASK) {
30008712:	d567      	bpl.n	300087e4 <sdhci_init+0x16c>
    }

    /* DDR mode support */
    host->caps.ddr_support = (caps[1] & SDHCI_DDR50_MODE_MASK) ? 1 : 0;
    /* SDR50 mode support */
    host->caps.sdr50_support = (caps[1] & SDHCI_SDR50_MODE_MASK) ? 1 : 0;
30008714:	f001 0201 	and.w	r2, r1, #1
    /* SDR104 mode support */
    host->caps.sdr104_support = (caps[1] & SDHCI_SDR104_MODE_MASK) ? 1 : 0;
30008718:	f3c1 0340 	ubfx	r3, r1, #1, #1
    host->caps.sdr50_support = (caps[1] & SDHCI_SDR50_MODE_MASK) ? 1 : 0;
3000871c:	f884 20d8 	strb.w	r2, [r4, #216]	; 0xd8
    host->caps.ddr_support = (caps[1] & SDHCI_DDR50_MODE_MASK) ? 1 : 0;
30008720:	f3c1 0080 	ubfx	r0, r1, #2, #1
    host->caps.sdr104_support = (caps[1] & SDHCI_SDR104_MODE_MASK) ? 1 : 0;
30008724:	f884 30d9 	strb.w	r3, [r4, #217]	; 0xd9
    sdhci_reset(host, SDHCI_SOFT_RESET);
30008728:	2101      	movs	r1, #1
    host->caps.ddr_support = (caps[1] & SDHCI_DDR50_MODE_MASK) ? 1 : 0;
3000872a:	f884 00d7 	strb.w	r0, [r4, #215]	; 0xd7
    sdhci_reset(host, SDHCI_SOFT_RESET);
3000872e:	4620      	mov	r0, r4
30008730:	f7ff fb8e 	bl	30007e50 <sdhci_reset>

    /* Set bus power on */
    if (!host->ops->set_power) {
30008734:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
30008738:	6893      	ldr	r3, [r2, #8]
3000873a:	b92b      	cbnz	r3, 30008748 <sdhci_init+0xd0>
        host->ops->set_power = sdhci_set_bus_power_on;
3000873c:	f647 31e5 	movw	r1, #31717	; 0x7be5
30008740:	f2c3 0100 	movt	r1, #12288	; 0x3000
30008744:	460b      	mov	r3, r1
30008746:	6091      	str	r1, [r2, #8]
    }

    host->ops->set_power(host);
30008748:	4620      	mov	r0, r4
3000874a:	4798      	blx	r3
    reg = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
3000874c:	6862      	ldr	r2, [r4, #4]
3000874e:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
30008752:	b2db      	uxtb	r3, r3
    REG_WRITE8(host, (reg | width), SDHCI_HOST_CTRL1_REG);
30008754:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM) {
30008758:	f894 20d1 	ldrb.w	r2, [r4, #209]	; 0xd1
    ctrl1 = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
3000875c:	6861      	ldr	r1, [r4, #4]
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM) {
3000875e:	2a02      	cmp	r2, #2
    ctrl1 = REG_READ8(host, SDHCI_HOST_CTRL1_REG);
30008760:	f891 3028 	ldrb.w	r3, [r1, #40]	; 0x28
30008764:	b2db      	uxtb	r3, r3
        ctrl1 |= SDHCI_ADMA_64BIT;
30008766:	bf98      	it	ls
30008768:	f043 0330 	orrls.w	r3, r3, #48	; 0x30
    if (host->caps.spec_version >= SDHCI_SPEC_VER4_NUM) {
3000876c:	d90d      	bls.n	3000878a <sdhci_init+0x112>
        ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
3000876e:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
        if (host->caps.addr_64bit_v4) {
30008770:	f894 00d4 	ldrb.w	r0, [r4, #212]	; 0xd4
        ctrl2 = REG_READ16(host, SDHCI_HOST_CTRL2_REG);
30008774:	b292      	uxth	r2, r2
        if (host->caps.addr_64bit_v4) {
30008776:	bb90      	cbnz	r0, 300087de <sdhci_init+0x166>
30008778:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
            ctrl2 &= ~SDHCI_ADMA_64BIT_V4;
3000877c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
        ctrl2 |= SDHCI_ADMA2_26BIT_LEN_MODE;
30008780:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
        ctrl1 |= SDHCI_ADMA2_SEL;
30008784:	f043 0310 	orr.w	r3, r3, #16
        REG_WRITE16(host, ctrl2, SDHCI_HOST_CTRL2_REG);
30008788:	87ca      	strh	r2, [r1, #62]	; 0x3e
    REG_WRITE16(host, SDHCI_NRML_INT_STS_EN, SDHCI_NRML_INT_STS_EN_REG);
3000878a:	202b      	movs	r0, #43	; 0x2b
    REG_WRITE16(host, SDHCI_ERR_INT_STS_EN, SDHCI_ERR_INT_STS_EN_REG);
3000878c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    REG_WRITE8(host, ctrl1, SDHCI_HOST_CTRL1_REG);
30008790:	f881 3028 	strb.w	r3, [r1, #40]	; 0x28
    REG_WRITE16(host, SDHCI_NRML_INT_SIG_EN, SDHCI_NRML_INT_SIG_EN_REG);
30008794:	260b      	movs	r6, #11
    /* Set bus width */
    sdhci_set_bus_width(host, SDHCI_BUS_WITDH_1BIT);
    /* Set Adma mode */
    sdhci_set_adma_mode(host);
    /* Enable error status */
    sdhci_error_status_enable(host);
30008796:	6863      	ldr	r3, [r4, #4]
#ifdef SDHCI_SUPPORT_INTERRUPT
    thread_t *thread =
30008798:	f44f 5580 	mov.w	r5, #4096	; 0x1000
    REG_WRITE16(host, SDHCI_NRML_INT_STS_EN, SDHCI_NRML_INT_STS_EN_REG);
3000879c:	8698      	strh	r0, [r3, #52]	; 0x34
    thread_t *thread =
3000879e:	f248 31ed 	movw	r1, #33773	; 0x83ed
300087a2:	f64c 4034 	movw	r0, #52276	; 0xcc34
300087a6:	f2c3 0100 	movt	r1, #12288	; 0x3000
    REG_WRITE16(host, SDHCI_ERR_INT_STS_EN, SDHCI_ERR_INT_STS_EN_REG);
300087aa:	86da      	strh	r2, [r3, #54]	; 0x36
    thread_t *thread =
300087ac:	f2c3 0001 	movt	r0, #12289	; 0x3001
    REG_WRITE16(host, SDHCI_NRML_INT_SIG_EN, SDHCI_NRML_INT_SIG_EN_REG);
300087b0:	871e      	strh	r6, [r3, #56]	; 0x38
    REG_WRITE16(host, SDHCI_ERR_INT_SIG_EN, SDHCI_ERR_INT_SIG_EN_REG);
300087b2:	875a      	strh	r2, [r3, #58]	; 0x3a
    thread_t *thread =
300087b4:	2310      	movs	r3, #16
300087b6:	9500      	str	r5, [sp, #0]
300087b8:	4622      	mov	r2, r4
300087ba:	f009 fb69 	bl	30011e90 <thread_create>
        thread_create("sdhci_thread", sdhci_data_thread, (void *)host,
                      DEFAULT_PRIORITY, INT_STACK_SZ);
    thread_resume(thread);
300087be:	f009 fbbb 	bl	30011f38 <thread_resume>
    DBG("\n Host irq: %d \n", host->irq);
    register_int_handler(host->irq, &sdhci_irq_handle, (void *)host);
300087c2:	f647 5121 	movw	r1, #32033	; 0x7d21
300087c6:	68a0      	ldr	r0, [r4, #8]
300087c8:	4622      	mov	r2, r4
300087ca:	f2c3 0100 	movt	r1, #12288	; 0x3000
300087ce:	f7f7 ff6f 	bl	300006b0 <register_int_handler>
    unmask_interrupt(host->irq);
300087d2:	68a0      	ldr	r0, [r4, #8]
#endif
}
300087d4:	b002      	add	sp, #8
300087d6:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    unmask_interrupt(host->irq);
300087da:	f7f7 bfbb 	b.w	30000754 <unmask_interrupt>
            ctrl2 |= SDHCI_ADMA_64BIT_V4;
300087de:	f442 5240 	orr.w	r2, r2, #12288	; 0x3000
300087e2:	e7cd      	b.n	30008780 <sdhci_init+0x108>
    else if (caps[0] & SDHCI_3_0_VOL_MASK) {
300087e4:	0190      	lsls	r0, r2, #6
        host->caps.voltage = SDHCI_VOL_3_0;
300087e6:	bf44      	itt	mi
300087e8:	2306      	movmi	r3, #6
300087ea:	f884 30d5 	strbmi.w	r3, [r4, #213]	; 0xd5
    else if (caps[0] & SDHCI_3_0_VOL_MASK) {
300087ee:	d491      	bmi.n	30008714 <sdhci_init+0x9c>
    else if (caps[0] & SDHCI_1_8_VOL_MASK) {
300087f0:	0153      	lsls	r3, r2, #5
        host->caps.voltage = SDHCI_VOL_1_8;
300087f2:	bf44      	itt	mi
300087f4:	2305      	movmi	r3, #5
300087f6:	f884 30d5 	strbmi.w	r3, [r4, #213]	; 0xd5
300087fa:	e78b      	b.n	30008714 <sdhci_init+0x9c>

300087fc <mmc_get_card_status.isra.4>:
 * Function: mmc get card status
 * Arg     : host, card structure & o/p argument card status
 * Return  : 0 on Success, 1 on Failure
 * Flow    : Get the current status of the card
 */
static uint32_t mmc_get_card_status(struct sdhci_host *host,
300087fc:	b570      	push	{r4, r5, r6, r14}
300087fe:	460c      	mov	r4, r1
30008800:	b092      	sub	sp, #72	; 0x48
30008802:	4605      	mov	r5, r0
                                    struct mmc_card *card, uint32_t *status)
{
    struct mmc_command cmd;
    uint32_t mmc_ret = 0;

    memset(&cmd, 0, sizeof(struct mmc_command));
30008804:	2100      	movs	r1, #0
static uint32_t mmc_get_card_status(struct sdhci_host *host,
30008806:	4616      	mov	r6, r2
    memset(&cmd, 0, sizeof(struct mmc_command));
30008808:	f10d 0002 	add.w	r0, r13, #2
3000880c:	2246      	movs	r2, #70	; 0x46
3000880e:	f00c e8b0 	blx	30014970 <memset>
    /* CMD13 Format:
     * [31:16] RCA
     * [15:0] stuff bits
     */
    cmd.cmd_index = CMD13_SEND_STATUS;
    cmd.argument = card->rca << 16;
30008812:	6823      	ldr	r3, [r4, #0]
    cmd.cmd_index = CMD13_SEND_STATUS;
30008814:	220d      	movs	r2, #13
    cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008816:	2401      	movs	r4, #1

    /* send command */
    mmc_ret = sdhci_send_command(host, &cmd);
30008818:	4628      	mov	r0, r5
3000881a:	4669      	mov	r1, r13
    cmd.cmd_index = CMD13_SEND_STATUS;
3000881c:	f8ad 2000 	strh.w	r2, [r13]
    cmd.argument = card->rca << 16;
30008820:	041b      	lsls	r3, r3, #16
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008822:	f8ad 400a 	strh.w	r4, [r13, #10]
    cmd.argument = card->rca << 16;
30008826:	9301      	str	r3, [sp, #4]
    mmc_ret = sdhci_send_command(host, &cmd);
30008828:	f7ff fb70 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret)
3000882c:	b920      	cbnz	r0, 30008838 <mmc_get_card_status.isra.4+0x3c>
        return mmc_ret;

    /* Checking ADDR_OUT_OF_RANGE error in CMD13 response */
    if ((cmd.resp[0] >> 31) & 0x01)
3000882e:	9b03      	ldr	r3, [sp, #12]
30008830:	2b00      	cmp	r3, #0
        return 1;
30008832:	bfb4      	ite	lt
30008834:	4620      	movlt	r0, r4

    *status = cmd.resp[0];
30008836:	6033      	strge	r3, [r6, #0]
    return 0;
}
30008838:	b012      	add	sp, #72	; 0x48
3000883a:	bd70      	pop	{r4, r5, r6, r15}

3000883c <mmc_switch_cmd>:
 * Return  : 0 on Success, 1 on Failure
 * Flow    : Send switch command to the card to set the ext attribute @ index
 */
static uint32_t mmc_switch_cmd(struct sdhci_host *host, struct mmc_card *card,
                               uint32_t access, uint32_t index, uint32_t value)
{
3000883c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30008840:	4615      	mov	r5, r2
30008842:	b094      	sub	sp, #80	; 0x50
30008844:	461f      	mov	r7, r3
30008846:	4604      	mov	r4, r0

    struct mmc_command cmd;
    uint32_t mmc_ret = 0;
    uint32_t mmc_status;

    memset(&cmd, 0, sizeof(struct mmc_command));
30008848:	2246      	movs	r2, #70	; 0x46
{
3000884a:	4688      	mov	r8, r1
3000884c:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    memset(&cmd, 0, sizeof(struct mmc_command));
3000884e:	2100      	movs	r1, #0
30008850:	f10d 000a 	add.w	r0, r13, #10
30008854:	f00c e88c 	blx	30014970 <memset>
    cmd.cmd_index = CMD6_SWITCH_FUNC;
    cmd.argument |= (access << 24);
    cmd.argument |= (index << 16);
    cmd.argument |= (value << 8);
    cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
    cmd.resp_type = SDHCI_CMD_RESP_R1B;
30008858:	2302      	movs	r3, #2
    cmd.argument |= (value << 8);
3000885a:	0232      	lsls	r2, r6, #8
3000885c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
30008860:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    cmd.cmd_index = CMD6_SWITCH_FUNC;
30008864:	2506      	movs	r5, #6

    mmc_ret = sdhci_send_command(host, &cmd);
30008866:	a902      	add	r1, sp, #8
    cmd.argument |= (value << 8);
30008868:	9203      	str	r2, [sp, #12]
    mmc_ret = sdhci_send_command(host, &cmd);
3000886a:	4620      	mov	r0, r4
    cmd.cmd_index = CMD6_SWITCH_FUNC;
3000886c:	f8ad 5008 	strh.w	r5, [r13, #8]
    cmd.resp_type = SDHCI_CMD_RESP_R1B;
30008870:	f8ad 3012 	strh.w	r3, [r13, #18]
    mmc_ret = sdhci_send_command(host, &cmd);
30008874:	f7ff fb4a 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret) {
30008878:	2800      	cmp	r0, #0
3000887a:	d13d      	bne.n	300088f8 <mmc_switch_cmd+0xbc>
        dprintf(CRITICAL, "CMD6 send failed\n");
        return mmc_ret;
    }

    if (index == MMC_EXT_MMC_HS_TIMING && value == SDHCI_EMMC_HISPEED_MODE) {
3000887c:	2fb9      	cmp	r7, #185	; 0xb9
3000887e:	bf08      	it	eq
30008880:	2e01      	cmpeq	r6, #1
30008882:	d10e      	bne.n	300088a2 <mmc_switch_cmd+0x66>
        /* Set the high speed mode in controller */
        host->ops->set_uhs_mode(host, SDHCI_EMMC_HISPEED_MODE);
30008884:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
30008888:	2101      	movs	r1, #1
3000888a:	4620      	mov	r0, r4
3000888c:	691b      	ldr	r3, [r3, #16]
3000888e:	4798      	blx	r3
        mmc_ret = host->ops->set_clock(host, MMC_CLK_50MHZ);
30008890:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
30008894:	f24f 0180 	movw	r1, #61568	; 0xf080
30008898:	4620      	mov	r0, r4
3000889a:	f2c0 21fa 	movt	r1, #762	; 0x2fa
3000889e:	685b      	ldr	r3, [r3, #4]
300088a0:	4798      	blx	r3
    }

    /* Check if the card completed the switch command processing */
    mmc_ret = mmc_get_card_status(host, card, &mmc_status);
300088a2:	4641      	mov	r1, r8
300088a4:	4620      	mov	r0, r4
300088a6:	aa01      	add	r2, sp, #4
300088a8:	f7ff ffa8 	bl	300087fc <mmc_get_card_status.isra.4>
    if (mmc_ret) {
300088ac:	4605      	mov	r5, r0
300088ae:	b9c8      	cbnz	r0, 300088e4 <mmc_switch_cmd+0xa8>
        dprintf(CRITICAL, "Get card status failed\n");
        return mmc_ret;
    }

    if (MMC_CARD_STATUS(mmc_status) != MMC_TRAN_STATE) {
300088b0:	9901      	ldr	r1, [sp, #4]
300088b2:	f3c1 2343 	ubfx	r3, r1, #9, #4
300088b6:	2b04      	cmp	r3, #4
300088b8:	d007      	beq.n	300088ca <mmc_switch_cmd+0x8e>
        dprintf(CRITICAL, "Switch cmd failed. Card not in tran state %x\n",
300088ba:	f24d 70d0 	movw	r0, #55248	; 0xd7d0
                mmc_status);
        mmc_ret = 1;
300088be:	2501      	movs	r5, #1
        dprintf(CRITICAL, "Switch cmd failed. Card not in tran state %x\n",
300088c0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300088c4:	f00d f974 	bl	30015bb0 <_printf>
300088c8:	9901      	ldr	r1, [sp, #4]
    }

    if (mmc_status & MMC_SWITCH_FUNC_ERR_FLAG) {
300088ca:	060b      	lsls	r3, r1, #24
300088cc:	d506      	bpl.n	300088dc <mmc_switch_cmd+0xa0>
        dprintf(CRITICAL, "Switch cmd failed. Switch Error.\n");
300088ce:	f64d 0000 	movw	r0, #55296	; 0xd800
        mmc_ret = 1;
300088d2:	2501      	movs	r5, #1
        dprintf(CRITICAL, "Switch cmd failed. Switch Error.\n");
300088d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300088d8:	f00d f96a 	bl	30015bb0 <_printf>
    }

    return mmc_ret;
}
300088dc:	4628      	mov	r0, r5
300088de:	b014      	add	sp, #80	; 0x50
300088e0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(CRITICAL, "Get card status failed\n");
300088e4:	f24d 70b8 	movw	r0, #55224	; 0xd7b8
300088e8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300088ec:	f00d f960 	bl	30015bb0 <_printf>
}
300088f0:	4628      	mov	r0, r5
300088f2:	b014      	add	sp, #80	; 0x50
300088f4:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
300088f8:	4605      	mov	r5, r0
        dprintf(CRITICAL, "CMD6 send failed\n");
300088fa:	f24d 70a4 	movw	r0, #55204	; 0xd7a4
300088fe:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008902:	f00d f955 	bl	30015bb0 <_printf>
}
30008906:	4628      	mov	r0, r5
30008908:	b014      	add	sp, #80	; 0x50
3000890a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
3000890e:	bf00      	nop

30008910 <mmc_set_bus_width>:
 * Return  : 0 on Success, 1 on Failure
 * Flow    : Send switch command to set bus width
 */
static uint32_t mmc_set_bus_width(struct sdhci_host *host,
                                  struct mmc_card *card, uint32_t width)
{
30008910:	b510      	push	{r4, r14}
    uint32_t mmc_ret = 0;

    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008912:	23b7      	movs	r3, #183	; 0xb7
{
30008914:	b082      	sub	sp, #8
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008916:	9200      	str	r2, [sp, #0]
30008918:	2203      	movs	r2, #3
3000891a:	f7ff ff8f 	bl	3000883c <mmc_switch_cmd>
                             MMC_EXT_MMC_BUS_WIDTH, width);

    if (mmc_ret) {
3000891e:	4604      	mov	r4, r0
30008920:	b128      	cbz	r0, 3000892e <mmc_set_bus_width+0x1e>
        dprintf(CRITICAL, "Switch cmd failed\n");
30008922:	f24d 50f4 	movw	r0, #54772	; 0xd5f4
30008926:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000892a:	f00d f941 	bl	30015bb0 <_printf>
        return mmc_ret;
    }

    return 0;
}
3000892e:	4620      	mov	r0, r4
30008930:	b002      	add	sp, #8
30008932:	bd10      	pop	{r4, r15}

30008934 <mmc_set_hs_interface>:
 * Flow    : Sets the host uhs mode & clock
 *           Adjust the interface speed to optimal speed
 */
static uint32_t mmc_set_hs_interface(struct sdhci_host *host,
                                     struct mmc_card *card)
{
30008934:	b570      	push	{r4, r5, r6, r14}
    uint32_t mmc_ret = 0;

    /* Setting HS_TIMING in EXT_CSD (CMD6) */
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008936:	2501      	movs	r5, #1
{
30008938:	b082      	sub	sp, #8
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
3000893a:	23b9      	movs	r3, #185	; 0xb9
3000893c:	2203      	movs	r2, #3
3000893e:	9500      	str	r5, [sp, #0]
{
30008940:	4606      	mov	r6, r0
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008942:	f7ff ff7b 	bl	3000883c <mmc_switch_cmd>
                             MMC_EXT_MMC_HS_TIMING, MMC_HS_TIMING);
    if (mmc_ret) {
30008946:	4604      	mov	r4, r0
30008948:	b918      	cbnz	r0, 30008952 <mmc_set_hs_interface+0x1e>
        dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
        return mmc_ret;
    }

    /* Save the timing value, before changing the clock */
    MMC_SAVE_TIMING(host, SDHCI_EMMC_HISPEED_MODE);
3000894a:	6735      	str	r5, [r6, #112]	; 0x70

    return mmc_ret;
}
3000894c:	4620      	mov	r0, r4
3000894e:	b002      	add	sp, #8
30008950:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
30008952:	f24d 7064 	movw	r0, #55140	; 0xd764
30008956:	f240 31db 	movw	r1, #987	; 0x3db
3000895a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000895e:	f00d f927 	bl	30015bb0 <_printf>
}
30008962:	4620      	mov	r0, r4
30008964:	b002      	add	sp, #8
30008966:	bd70      	pop	{r4, r5, r6, r15}

30008968 <mmc_set_ddr_mode>:
    if (width == MMC_DATA_BUS_WIDTH_4BIT)
30008968:	2a01      	cmp	r2, #1
{
3000896a:	b570      	push	{r4, r5, r6, r14}
3000896c:	4604      	mov	r4, r0
3000896e:	460e      	mov	r6, r1
    if (width == MMC_DATA_BUS_WIDTH_4BIT)
30008970:	d024      	beq.n	300089bc <mmc_set_ddr_mode+0x54>
    else if (width == MMC_DATA_BUS_WIDTH_8BIT)
30008972:	2a02      	cmp	r2, #2
30008974:	d009      	beq.n	3000898a <mmc_set_ddr_mode+0x22>
        dprintf(CRITICAL, "DDR mode not suport bus width: %u\n", width);
30008976:	f24d 6008 	movw	r0, #54792	; 0xd608
3000897a:	4611      	mov	r1, r2
        return 1;
3000897c:	2501      	movs	r5, #1
        dprintf(CRITICAL, "DDR mode not suport bus width: %u\n", width);
3000897e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008982:	f00d f915 	bl	30015bb0 <_printf>
}
30008986:	4628      	mov	r0, r5
30008988:	bd70      	pop	{r4, r5, r6, r15}
        mmc_ret = mmc_set_bus_width(host, card, MMC_DATA_DDR_BUS_WIDTH_8BIT);
3000898a:	2206      	movs	r2, #6
3000898c:	f7ff ffc0 	bl	30008910 <mmc_set_bus_width>
30008990:	b2c5      	uxtb	r5, r0
    if (mmc_ret) {
30008992:	b9c5      	cbnz	r5, 300089c6 <mmc_set_ddr_mode+0x5e>
    host->ops->set_uhs_mode(host, SDHCI_EMMC_DDR52_MODE);
30008994:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
    MMC_SAVE_TIMING(host, SDHCI_EMMC_DDR52_MODE);
30008998:	2304      	movs	r3, #4
    host->ops->set_uhs_mode(host, SDHCI_EMMC_DDR52_MODE);
3000899a:	4619      	mov	r1, r3
3000899c:	4620      	mov	r0, r4
    MMC_SAVE_TIMING(host, SDHCI_EMMC_DDR52_MODE);
3000899e:	6723      	str	r3, [r4, #112]	; 0x70
    host->ops->set_uhs_mode(host, SDHCI_EMMC_DDR52_MODE);
300089a0:	6913      	ldr	r3, [r2, #16]
300089a2:	4798      	blx	r3
    mmc_ret = host->ops->set_clock(host, MMC_CLK_50MHZ);
300089a4:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
300089a8:	f24f 0180 	movw	r1, #61568	; 0xf080
300089ac:	4620      	mov	r0, r4
300089ae:	f2c0 21fa 	movt	r1, #762	; 0x2fa
300089b2:	685b      	ldr	r3, [r3, #4]
300089b4:	4798      	blx	r3
300089b6:	b2c5      	uxtb	r5, r0
}
300089b8:	4628      	mov	r0, r5
300089ba:	bd70      	pop	{r4, r5, r6, r15}
        mmc_ret = mmc_set_bus_width(host, card, MMC_DATA_DDR_BUS_WIDTH_4BIT);
300089bc:	2205      	movs	r2, #5
300089be:	f7ff ffa7 	bl	30008910 <mmc_set_bus_width>
300089c2:	b2c5      	uxtb	r5, r0
300089c4:	e7e5      	b.n	30008992 <mmc_set_ddr_mode+0x2a>
        dprintf(CRITICAL, "Failure to set DDR mode for Card(RCA:%x)\n",
300089c6:	6831      	ldr	r1, [r6, #0]
300089c8:	f24d 602c 	movw	r0, #54828	; 0xd62c
300089cc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300089d0:	f00d f8ee 	bl	30015bb0 <_printf>
        return mmc_ret;
300089d4:	e7d7      	b.n	30008986 <mmc_set_ddr_mode+0x1e>
300089d6:	bf00      	nop

300089d8 <mmc_send_app_cmd.isra.9>:
    }

    return 0;
}

static uint32_t mmc_send_app_cmd(struct sdhci_host *host, struct mmc_card *card)
300089d8:	b570      	push	{r4, r5, r6, r14}
300089da:	460c      	mov	r4, r1
300089dc:	b092      	sub	sp, #72	; 0x48
300089de:	4606      	mov	r6, r0
{
    struct mmc_command cmd = {0};
300089e0:	2100      	movs	r1, #0
300089e2:	2246      	movs	r2, #70	; 0x46
300089e4:	f10d 0002 	add.w	r0, r13, #2
300089e8:	f00b efc2 	blx	30014970 <memset>

    cmd.cmd_index = CMD55_APP_CMD;
    cmd.argument = (card->rca << 16);
    cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
    cmd.resp_type = SDHCI_CMD_RESP_R1;
300089ec:	2501      	movs	r5, #1
    cmd.cmd_index = CMD55_APP_CMD;
300089ee:	2337      	movs	r3, #55	; 0x37
    cmd.argument = (card->rca << 16);
300089f0:	0424      	lsls	r4, r4, #16

    if (sdhci_send_command(host, &cmd)) {
300089f2:	4630      	mov	r0, r6
300089f4:	4669      	mov	r1, r13
    cmd.argument = (card->rca << 16);
300089f6:	9401      	str	r4, [sp, #4]
    cmd.cmd_index = CMD55_APP_CMD;
300089f8:	f8ad 3000 	strh.w	r3, [r13]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
300089fc:	f8ad 500a 	strh.w	r5, [r13, #10]
    if (sdhci_send_command(host, &cmd)) {
30008a00:	f7ff fa84 	bl	30007f0c <sdhci_send_command>
30008a04:	b130      	cbz	r0, 30008a14 <mmc_send_app_cmd.isra.9+0x3c>
        dprintf(CRITICAL, "Failed Sending CMD55\n");
30008a06:	f24d 50dc 	movw	r0, #54748	; 0xd5dc
30008a0a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a0e:	f00d f8cf 	bl	30015bb0 <_printf>
        return 1;
30008a12:	4628      	mov	r0, r5
    }
    return 0;
}
30008a14:	b012      	add	sp, #72	; 0x48
30008a16:	bd70      	pop	{r4, r5, r6, r15}

30008a18 <mmc_parse_response>:

    return 0;
}

static uint32_t mmc_parse_response(uint32_t resp)
{
30008a18:	b508      	push	{r3, r14}
    /* Trying to write beyond card capacity */
    if (resp & MMC_R1_ADDR_OUT_OF_RANGE) {
30008a1a:	1e03      	subs	r3, r0, #0
30008a1c:	db2e      	blt.n	30008a7c <mmc_parse_response+0x64>
                "Attempting to read or write beyond the Device capacity\n");
        return 1;
    }

    /* Misaligned address not matching block length */
    if (resp & MMC_R1_ADDR_ERR) {
30008a1e:	005a      	lsls	r2, r3, #1
30008a20:	d414      	bmi.n	30008a4c <mmc_parse_response+0x34>
                "The misaligned address did not match the block length used\n");
        return 1;
    }

    /* Invalid block length */
    if (resp & MMC_R1_BLOCK_LEN_ERR) {
30008a22:	0098      	lsls	r0, r3, #2
30008a24:	d41a      	bmi.n	30008a5c <mmc_parse_response+0x44>
                "The transferred bytes does not match the block length\n");
        return 1;
    }

    /* Tried to program write protected block */
    if (resp & MMC_R1_WP_VIOLATION) {
30008a26:	0159      	lsls	r1, r3, #5
30008a28:	d430      	bmi.n	30008a8c <mmc_parse_response+0x74>
        dprintf(CRITICAL, "Attempt to program a write protected block\n");
        return 1;
    }

    /* card controller error */
    if (resp & MMC_R1_CC_ERROR) {
30008a2a:	02da      	lsls	r2, r3, #11
30008a2c:	d41e      	bmi.n	30008a6c <mmc_parse_response+0x54>
                          "host command\n");
        return 1;
    }

    /* Generic error */
    if (resp & MMC_R1_GENERIC_ERR) {
30008a2e:	f413 2000 	ands.w	r0, r3, #524288	; 0x80000
30008a32:	d133      	bne.n	30008a9c <mmc_parse_response+0x84>
        dprintf(CRITICAL, "A generic Device error\n");
        return 1;
    }

    /* Finally check for card in TRAN state */
    if (MMC_CARD_STATUS(resp) != MMC_TRAN_STATE) {
30008a34:	f3c3 2343 	ubfx	r3, r3, #9, #4
30008a38:	2b04      	cmp	r3, #4
30008a3a:	d006      	beq.n	30008a4a <mmc_parse_response+0x32>
        dprintf(CRITICAL, "MMC card is not in TRAN state\n");
30008a3c:	f64c 60d4 	movw	r0, #52948	; 0xced4
30008a40:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a44:	f00d f8b4 	bl	30015bb0 <_printf>
        return 1;
30008a48:	2001      	movs	r0, #1
    }

    return 0;
}
30008a4a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL,
30008a4c:	f64c 50d8 	movw	r0, #52696	; 0xcdd8
30008a50:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a54:	f00d f8ac 	bl	30015bb0 <_printf>
        return 1;
30008a58:	2001      	movs	r0, #1
}
30008a5a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL,
30008a5c:	f64c 6014 	movw	r0, #52756	; 0xce14
30008a60:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a64:	f00d f8a4 	bl	30015bb0 <_printf>
        return 1;
30008a68:	2001      	movs	r0, #1
}
30008a6a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL, "Device error occurred, which is not related to the "
30008a6c:	f64c 6078 	movw	r0, #52856	; 0xce78
30008a70:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a74:	f00d f89c 	bl	30015bb0 <_printf>
        return 1;
30008a78:	2001      	movs	r0, #1
}
30008a7a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL,
30008a7c:	f64c 50a0 	movw	r0, #52640	; 0xcda0
30008a80:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a84:	f00d f894 	bl	30015bb0 <_printf>
        return 1;
30008a88:	2001      	movs	r0, #1
}
30008a8a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL, "Attempt to program a write protected block\n");
30008a8c:	f64c 604c 	movw	r0, #52812	; 0xce4c
30008a90:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008a94:	f00d f88c 	bl	30015bb0 <_printf>
        return 1;
30008a98:	2001      	movs	r0, #1
}
30008a9a:	bd08      	pop	{r3, r15}
        dprintf(CRITICAL, "A generic Device error\n");
30008a9c:	f64c 60bc 	movw	r0, #52924	; 0xcebc
30008aa0:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008aa4:	f00d f884 	bl	30015bb0 <_printf>
        return 1;
30008aa8:	2001      	movs	r0, #1
}
30008aaa:	bd08      	pop	{r3, r15}

30008aac <mmc_stop_command>:

static uint32_t mmc_stop_command(struct mmc_device *dev)
{
30008aac:	b530      	push	{r4, r5, r14}
30008aae:	4604      	mov	r4, r0
30008ab0:	b093      	sub	sp, #76	; 0x4c
    struct mmc_command cmd;
    uint32_t mmc_ret = 0;

    memset(&cmd, 0, sizeof(struct mmc_command));
30008ab2:	2248      	movs	r2, #72	; 0x48
30008ab4:	2100      	movs	r1, #0
30008ab6:	4668      	mov	r0, r13
        cmd.cmd_index = CMD52_SDIO_STOP_TRANSMISSION;
    else
        cmd.cmd_index = CMD12_STOP_TRANSMISSION;

    cmd.argument = (dev->card.rca << 16) | BIT(0);
    cmd.cmd_type = SDHCI_CMD_TYPE_ABORT;
30008ab8:	2503      	movs	r5, #3
    memset(&cmd, 0, sizeof(struct mmc_command));
30008aba:	f00b ef5a 	blx	30014970 <memset>
    if (dev->host.card_type == SDHCI_SDIO_CARD)
30008abe:	6f63      	ldr	r3, [r4, #116]	; 0x74
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008ac0:	2201      	movs	r2, #1

    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30008ac2:	4620      	mov	r0, r4
30008ac4:	4669      	mov	r1, r13
    if (dev->host.card_type == SDHCI_SDIO_CARD)
30008ac6:	2b03      	cmp	r3, #3
        cmd.cmd_index = CMD52_SDIO_STOP_TRANSMISSION;
30008ac8:	bf0c      	ite	eq
30008aca:	2334      	moveq	r3, #52	; 0x34
        cmd.cmd_index = CMD12_STOP_TRANSMISSION;
30008acc:	230c      	movne	r3, #12
    cmd.cmd_type = SDHCI_CMD_TYPE_ABORT;
30008ace:	f88d 5009 	strb.w	r5, [r13, #9]
        cmd.cmd_index = CMD12_STOP_TRANSMISSION;
30008ad2:	f8ad 3000 	strh.w	r3, [r13]
    cmd.argument = (dev->card.rca << 16) | BIT(0);
30008ad6:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008ada:	f8ad 200a 	strh.w	r2, [r13, #10]
    cmd.argument = (dev->card.rca << 16) | BIT(0);
30008ade:	041b      	lsls	r3, r3, #16
30008ae0:	4313      	orrs	r3, r2
30008ae2:	9301      	str	r3, [sp, #4]
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30008ae4:	f7ff fa12 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret) {
30008ae8:	4604      	mov	r4, r0
30008aea:	b930      	cbnz	r0, 30008afa <mmc_stop_command+0x4e>
    }

    /* Response contains 32 bit Card status.
     * Parse the errors & provide relevant information */

    return mmc_parse_response(cmd.resp[0]);
30008aec:	9803      	ldr	r0, [sp, #12]
30008aee:	f7ff ff93 	bl	30008a18 <mmc_parse_response>
30008af2:	4604      	mov	r4, r0
}
30008af4:	4620      	mov	r0, r4
30008af6:	b013      	add	sp, #76	; 0x4c
30008af8:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "Failed to send stop command\n");
30008afa:	f24d 7084 	movw	r0, #55172	; 0xd784
30008afe:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008b02:	f00d f855 	bl	30015bb0 <_printf>
}
30008b06:	4620      	mov	r0, r4
30008b08:	b013      	add	sp, #76	; 0x4c
30008b0a:	bd30      	pop	{r4, r5, r15}

30008b0c <mmc_set_hs200_mode>:
{
30008b0c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30008b10:	4605      	mov	r5, r0
30008b12:	b082      	sub	sp, #8
30008b14:	460e      	mov	r6, r1
30008b16:	4690      	mov	r8, r2
    mmc_ret = mmc_set_bus_width(host, card, width);
30008b18:	f7ff fefa 	bl	30008910 <mmc_set_bus_width>
    if (mmc_ret) {
30008b1c:	b9f8      	cbnz	r0, 30008b5e <mmc_set_hs200_mode+0x52>
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008b1e:	2702      	movs	r7, #2
30008b20:	4631      	mov	r1, r6
30008b22:	23b9      	movs	r3, #185	; 0xb9
30008b24:	2203      	movs	r2, #3
30008b26:	9700      	str	r7, [sp, #0]
30008b28:	4628      	mov	r0, r5
30008b2a:	f7ff fe87 	bl	3000883c <mmc_switch_cmd>
    if (mmc_ret) {
30008b2e:	4604      	mov	r4, r0
30008b30:	bb80      	cbnz	r0, 30008b94 <mmc_set_hs200_mode+0x88>
    host->ops->set_uhs_mode(host, SDHCI_EMMC_HS200_MODE);
30008b32:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
30008b36:	2103      	movs	r1, #3
    MMC_SAVE_TIMING(host, MMC_HS200_TIMING);
30008b38:	672f      	str	r7, [r5, #112]	; 0x70
    host->ops->set_uhs_mode(host, SDHCI_EMMC_HS200_MODE);
30008b3a:	4628      	mov	r0, r5
30008b3c:	691b      	ldr	r3, [r3, #16]
30008b3e:	4798      	blx	r3
    mmc_ret = host->ops->set_clock(host, MMC_CLK_200MHZ);
30008b40:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
30008b44:	f44f 4142 	mov.w	r1, #49664	; 0xc200
30008b48:	4628      	mov	r0, r5
30008b4a:	f6c0 31eb 	movt	r1, #3051	; 0xbeb
30008b4e:	685b      	ldr	r3, [r3, #4]
30008b50:	4798      	blx	r3
    if (mmc_ret)
30008b52:	4604      	mov	r4, r0
30008b54:	b178      	cbz	r0, 30008b76 <mmc_set_hs200_mode+0x6a>
}
30008b56:	4620      	mov	r0, r4
30008b58:	b002      	add	sp, #8
30008b5a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(CRITICAL, "Failure to set wide bus for Card(RCA:%x)\n",
30008b5e:	6831      	ldr	r1, [r6, #0]
30008b60:	4604      	mov	r4, r0
30008b62:	f24d 6058 	movw	r0, #54872	; 0xd658
30008b66:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008b6a:	f00d f821 	bl	30015bb0 <_printf>
}
30008b6e:	4620      	mov	r0, r4
30008b70:	b002      	add	sp, #8
30008b72:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    if ((mmc_ret = sdhci_execute_tuning(host, CMD21_SEND_TUNING_BLOCK, width)))
30008b76:	4642      	mov	r2, r8
30008b78:	4628      	mov	r0, r5
30008b7a:	2115      	movs	r1, #21
30008b7c:	f7ff fcbc 	bl	300084f8 <sdhci_execute_tuning>
30008b80:	4604      	mov	r4, r0
30008b82:	2800      	cmp	r0, #0
30008b84:	d0e7      	beq.n	30008b56 <mmc_set_hs200_mode+0x4a>
        dprintf(CRITICAL, "Tuning for hs200 failed\n");
30008b86:	f24d 6084 	movw	r0, #54916	; 0xd684
30008b8a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008b8e:	f00d f80f 	bl	30015bb0 <_printf>
30008b92:	e7e0      	b.n	30008b56 <mmc_set_hs200_mode+0x4a>
        dprintf(CRITICAL, "Switch cmd returned failure %d\n", __LINE__);
30008b94:	f24d 7064 	movw	r0, #55140	; 0xd764
30008b98:	f240 318e 	movw	r1, #910	; 0x38e
30008b9c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008ba0:	f00d f806 	bl	30015bb0 <_printf>
        return mmc_ret;
30008ba4:	e7d7      	b.n	30008b56 <mmc_set_hs200_mode+0x4a>
30008ba6:	bf00      	nop

30008ba8 <mmc_get_ext_csd.isra.13>:
static uint32_t mmc_get_ext_csd(struct sdhci_host *host, struct mmc_card *card)
30008ba8:	b5f0      	push	{r4, r5, r6, r7, r14}
30008baa:	460d      	mov	r5, r1
30008bac:	b095      	sub	sp, #84	; 0x54
30008bae:	4606      	mov	r6, r0
    vptr = memalign(CACHE_LINE, ext_csd_buf_size);
30008bb0:	f44f 7100 	mov.w	r1, #512	; 0x200
30008bb4:	2020      	movs	r0, #32
30008bb6:	4677      	mov	r7, r14
30008bb8:	f00b fdac 	bl	30014714 <memalign>
    card->ext_csd = vptr;
30008bbc:	6028      	str	r0, [r5, #0]
    ASSERT(card->ext_csd);
30008bbe:	b1e8      	cbz	r0, 30008bfc <mmc_get_ext_csd.isra.13+0x54>
    memset(card->ext_csd, 0, ext_csd_buf_size);
30008bc0:	f44f 7200 	mov.w	r2, #512	; 0x200
30008bc4:	2100      	movs	r1, #0
30008bc6:	4604      	mov	r4, r0
30008bc8:	f00b eed2 	blx	30014970 <memset>
    memset(&cmd, 0, sizeof(struct mmc_command));
30008bcc:	2242      	movs	r2, #66	; 0x42
30008bce:	2100      	movs	r1, #0
30008bd0:	f10d 000a 	add.w	r0, r13, #10
30008bd4:	f00b eecc 	blx	30014970 <memset>
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008bd8:	2301      	movs	r3, #1
    cmd.cmd_index = CMD8_SEND_EXT_CSD;
30008bda:	2208      	movs	r2, #8
    mmc_ret = sdhci_send_command(host, &cmd);
30008bdc:	4630      	mov	r0, r6
    cmd.data.data_ptr = card->ext_csd;
30008bde:	9410      	str	r4, [sp, #64]	; 0x40
    mmc_ret = sdhci_send_command(host, &cmd);
30008be0:	eb0d 0102 	add.w	r1, r13, r2
    cmd.cmd_index = CMD8_SEND_EXT_CSD;
30008be4:	f8ad 2008 	strh.w	r2, [r13, #8]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008be8:	f8ad 3012 	strh.w	r3, [r13, #18]
    cmd.data.num_blocks = 1;
30008bec:	9313      	str	r3, [sp, #76]	; 0x4c
    cmd.data_present = 0x1;
30008bee:	f88d 3010 	strb.w	r3, [r13, #16]
    cmd.trans_mode = SDHCI_MMC_READ;
30008bf2:	9309      	str	r3, [sp, #36]	; 0x24
    mmc_ret = sdhci_send_command(host, &cmd);
30008bf4:	f7ff f98a 	bl	30007f0c <sdhci_send_command>
}
30008bf8:	b015      	add	sp, #84	; 0x54
30008bfa:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT(card->ext_csd);
30008bfc:	f64c 5390 	movw	r3, #52624	; 0xcd90
30008c00:	f64c 5264 	movw	r2, #52580	; 0xcd64
30008c04:	f24a 011c 	movw	r1, #40988	; 0xa01c
30008c08:	f2c3 0301 	movt	r3, #12289	; 0x3001
30008c0c:	4638      	mov	r0, r7
30008c0e:	f2c3 0201 	movt	r2, #12289	; 0x3001
30008c12:	9300      	str	r3, [sp, #0]
30008c14:	f2c3 0101 	movt	r1, #12289	; 0x3001
30008c18:	f240 23c9 	movw	r3, #713	; 0x2c9
30008c1c:	f00b fafa 	bl	30014214 <_panic>

30008c20 <mmc_sdhci_switch_part.part.16>:
}

/*
 * Switch the partition access type to rpmb or default
 */
uint32_t mmc_sdhci_switch_part(struct mmc_device *dev, uint32_t type)
30008c20:	b570      	push	{r4, r5, r6, r14}
30008c22:	460e      	mov	r6, r1
30008c24:	b082      	sub	sp, #8
    if (!MMC_CARD_MMC(card))
        return 1;

    /* Clear the partition access */
    part_access =
        dev->card.ext_csd[MMC_PARTITION_CONFIG] & ~PARTITION_ACCESS_MASK;
30008c26:	f8d0 4108 	ldr.w	r4, [r0, #264]	; 0x108
30008c2a:	f894 40b3 	ldrb.w	r4, [r4, #179]	; 0xb3
    part_access |= type;

    ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE,
30008c2e:	23b3      	movs	r3, #179	; 0xb3
    part_access =
30008c30:	f024 0407 	bic.w	r4, r4, #7
    part_access |= type;
30008c34:	4334      	orrs	r4, r6
    ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE,
30008c36:	2203      	movs	r2, #3
30008c38:	f100 01e8 	add.w	r1, r0, #232	; 0xe8
30008c3c:	9400      	str	r4, [sp, #0]
uint32_t mmc_sdhci_switch_part(struct mmc_device *dev, uint32_t type)
30008c3e:	4605      	mov	r5, r0
    ret = mmc_switch_cmd(&dev->host, &dev->card, MMC_ACCESS_WRITE,
30008c40:	f7ff fdfc 	bl	3000883c <mmc_switch_cmd>
                         MMC_PARTITION_CONFIG, part_access);

    if (ret) {
30008c44:	b928      	cbnz	r0, 30008c52 <mmc_sdhci_switch_part.part.16+0x32>
        dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
        return 1;
    }

    dev->card.ext_csd[MMC_PARTITION_CONFIG] = part_access;
30008c46:	f8d5 3108 	ldr.w	r3, [r5, #264]	; 0x108
30008c4a:	f883 40b3 	strb.w	r4, [r3, #179]	; 0xb3
    return 0;
}
30008c4e:	b002      	add	sp, #8
30008c50:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "Failed to switch partition to type: %u\n", type);
30008c52:	f24d 5050 	movw	r0, #54608	; 0xd550
30008c56:	4631      	mov	r1, r6
30008c58:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008c5c:	f00c ffa8 	bl	30015bb0 <_printf>
        return 1;
30008c60:	2001      	movs	r0, #1
}
30008c62:	b002      	add	sp, #8
30008c64:	bd70      	pop	{r4, r5, r6, r15}
30008c66:	bf00      	nop

30008c68 <mmc_set_hs400_mode>:
    if (width != MMC_DATA_BUS_WIDTH_8BIT) {
30008c68:	2a02      	cmp	r2, #2
{
30008c6a:	b5f0      	push	{r4, r5, r6, r7, r14}
30008c6c:	4615      	mov	r5, r2
30008c6e:	b083      	sub	sp, #12
    if (width != MMC_DATA_BUS_WIDTH_8BIT) {
30008c70:	d00a      	beq.n	30008c88 <mmc_set_hs400_mode+0x20>
        dprintf(CRITICAL,
30008c72:	f24d 60a0 	movw	r0, #54944	; 0xd6a0
30008c76:	4611      	mov	r1, r2
        return 1;
30008c78:	2401      	movs	r4, #1
        dprintf(CRITICAL,
30008c7a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008c7e:	f00c ff97 	bl	30015bb0 <_printf>
}
30008c82:	4620      	mov	r0, r4
30008c84:	b003      	add	sp, #12
30008c86:	bdf0      	pop	{r4, r5, r6, r7, r15}
30008c88:	4606      	mov	r6, r0
30008c8a:	460f      	mov	r7, r1
    mmc_ret = mmc_set_hs200_mode(host, card, width);
30008c8c:	f7ff ff3e 	bl	30008b0c <mmc_set_hs200_mode>
    if (mmc_ret) {
30008c90:	4604      	mov	r4, r0
30008c92:	2800      	cmp	r0, #0
30008c94:	d13a      	bne.n	30008d0c <mmc_set_hs400_mode+0xa4>
    mmc_ret = mmc_set_hs_interface(host, card);
30008c96:	4639      	mov	r1, r7
30008c98:	4630      	mov	r0, r6
30008c9a:	f7ff fe4b 	bl	30008934 <mmc_set_hs_interface>
    if (mmc_ret) {
30008c9e:	4604      	mov	r4, r0
30008ca0:	bb38      	cbnz	r0, 30008cf2 <mmc_set_hs400_mode+0x8a>
    mmc_ret = mmc_set_ddr_mode(host, card, width);
30008ca2:	462a      	mov	r2, r5
30008ca4:	4639      	mov	r1, r7
30008ca6:	4630      	mov	r0, r6
30008ca8:	f7ff fe5e 	bl	30008968 <mmc_set_ddr_mode>
    if (mmc_ret) {
30008cac:	4604      	mov	r4, r0
30008cae:	2800      	cmp	r0, #0
30008cb0:	d13b      	bne.n	30008d2a <mmc_set_hs400_mode+0xc2>
    mmc_ret = mmc_switch_cmd(host, card, MMC_ACCESS_WRITE,
30008cb2:	2013      	movs	r0, #19
30008cb4:	4639      	mov	r1, r7
30008cb6:	23b9      	movs	r3, #185	; 0xb9
30008cb8:	2203      	movs	r2, #3
30008cba:	9000      	str	r0, [sp, #0]
30008cbc:	4630      	mov	r0, r6
30008cbe:	f7ff fdbd 	bl	3000883c <mmc_switch_cmd>
    if (mmc_ret) {
30008cc2:	4604      	mov	r4, r0
30008cc4:	2800      	cmp	r0, #0
30008cc6:	d13d      	bne.n	30008d44 <mmc_set_hs400_mode+0xdc>
    mmc_ret = host->ops->set_clock(host, MMC_CLK_200MHZ);
30008cc8:	f8d6 30e4 	ldr.w	r3, [r6, #228]	; 0xe4
    MMC_SAVE_TIMING(host, MMC_HS400_TIMING);
30008ccc:	2203      	movs	r2, #3
    mmc_ret = host->ops->set_clock(host, MMC_CLK_200MHZ);
30008cce:	f44f 4142 	mov.w	r1, #49664	; 0xc200
30008cd2:	4630      	mov	r0, r6
    MMC_SAVE_TIMING(host, MMC_HS400_TIMING);
30008cd4:	6732      	str	r2, [r6, #112]	; 0x70
    mmc_ret = host->ops->set_clock(host, MMC_CLK_200MHZ);
30008cd6:	f6c0 31eb 	movt	r1, #3051	; 0xbeb
30008cda:	685b      	ldr	r3, [r3, #4]
30008cdc:	4798      	blx	r3
    if (mmc_ret)
30008cde:	4604      	mov	r4, r0
30008ce0:	2800      	cmp	r0, #0
30008ce2:	d1ce      	bne.n	30008c82 <mmc_set_hs400_mode+0x1a>
    host->ops->set_uhs_mode(host, SDHCI_EMMC_HS400_MODE);
30008ce4:	f8d6 30e4 	ldr.w	r3, [r6, #228]	; 0xe4
30008ce8:	4630      	mov	r0, r6
30008cea:	2107      	movs	r1, #7
30008cec:	691b      	ldr	r3, [r3, #16]
30008cee:	4798      	blx	r3
30008cf0:	e7c7      	b.n	30008c82 <mmc_set_hs400_mode+0x1a>
        dprintf(CRITICAL, "Error adjusting interface speed!:%s\t%d\n", __func__,
30008cf2:	f64c 5150 	movw	r1, #52560	; 0xcd50
30008cf6:	f24d 60f8 	movw	r0, #55032	; 0xd6f8
30008cfa:	f44f 6282 	mov.w	r2, #1040	; 0x410
30008cfe:	f2c3 0101 	movt	r1, #12289	; 0x3001
30008d02:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008d06:	f00c ff53 	bl	30015bb0 <_printf>
        return mmc_ret;
30008d0a:	e7ba      	b.n	30008c82 <mmc_set_hs400_mode+0x1a>
        dprintf(CRITICAL, "Failure Setting HS200 mode %s\t%d\n", __func__,
30008d0c:	f64c 5150 	movw	r1, #52560	; 0xcd50
30008d10:	f24d 60d4 	movw	r0, #54996	; 0xd6d4
30008d14:	f44f 6281 	mov.w	r2, #1032	; 0x408
30008d18:	f2c3 0101 	movt	r1, #12289	; 0x3001
30008d1c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008d20:	f00c ff46 	bl	30015bb0 <_printf>
}
30008d24:	4620      	mov	r0, r4
30008d26:	b003      	add	sp, #12
30008d28:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "Failure setting DDR mode:%s\t%d\n", __func__,
30008d2a:	f64c 5150 	movw	r1, #52560	; 0xcd50
30008d2e:	f24d 7020 	movw	r0, #55072	; 0xd720
30008d32:	f44f 6283 	mov.w	r2, #1048	; 0x418
30008d36:	f2c3 0101 	movt	r1, #12289	; 0x3001
30008d3a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008d3e:	f00c ff37 	bl	30015bb0 <_printf>
30008d42:	e79e      	b.n	30008c82 <mmc_set_hs400_mode+0x1a>
        dprintf(CRITICAL, "Switch cmd returned failure %s\t%d\n", __func__,
30008d44:	f64c 5150 	movw	r1, #52560	; 0xcd50
30008d48:	f24d 7040 	movw	r0, #55104	; 0xd740
30008d4c:	f240 4222 	movw	r2, #1058	; 0x422
30008d50:	f2c3 0101 	movt	r1, #12289	; 0x3001
30008d54:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008d58:	f00c ff2a 	bl	30015bb0 <_printf>
30008d5c:	e791      	b.n	30008c82 <mmc_set_hs400_mode+0x1a>
30008d5e:	bf00      	nop

30008d60 <mmc_sd_card_init>:
{
30008d60:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    memset(&cmd, 0, sizeof(struct mmc_command));
30008d64:	2246      	movs	r2, #70	; 0x46
{
30008d66:	b092      	sub	sp, #72	; 0x48
30008d68:	460e      	mov	r6, r1
30008d6a:	4605      	mov	r5, r0
    memset(&cmd, 0, sizeof(struct mmc_command));
30008d6c:	2100      	movs	r1, #0
30008d6e:	f10d 0002 	add.w	r0, r13, #2
30008d72:	f00b edfe 	blx	30014970 <memset>
    card->rca = SD_CARD_RCA;
30008d76:	2300      	movs	r3, #0
        cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
30008d78:	4699      	mov	r9, r3
    card->rca = SD_CARD_RCA;
30008d7a:	2403      	movs	r4, #3
        cmd.cmd_index = CMD8_SEND_IF_COND;
30008d7c:	f04f 0808 	mov.w	r8, #8
        cmd.argument = MMC_SD_HC_VOLT_SUPPLIED;
30008d80:	f44f 77d5 	mov.w	r7, #426	; 0x1aa
    card->rca = SD_CARD_RCA;
30008d84:	6033      	str	r3, [r6, #0]
        cmd.resp_type = SDHCI_CMD_RESP_R7;
30008d86:	2380      	movs	r3, #128	; 0x80
        if (sdhci_send_command(host, &cmd)) {
30008d88:	4669      	mov	r1, r13
        cmd.cmd_index = CMD8_SEND_IF_COND;
30008d8a:	f8ad 8000 	strh.w	r8, [r13]
        if (sdhci_send_command(host, &cmd)) {
30008d8e:	4628      	mov	r0, r5
        cmd.argument = MMC_SD_HC_VOLT_SUPPLIED;
30008d90:	9701      	str	r7, [sp, #4]
        cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
30008d92:	f88d 9009 	strb.w	r9, [r13, #9]
        cmd.resp_type = SDHCI_CMD_RESP_R7;
30008d96:	f8ad 300a 	strh.w	r3, [r13, #10]
        if (sdhci_send_command(host, &cmd)) {
30008d9a:	f7ff f8b7 	bl	30007f0c <sdhci_send_command>
30008d9e:	2800      	cmp	r0, #0
30008da0:	d171      	bne.n	30008e86 <mmc_sd_card_init+0x126>
            if (cmd.resp[0] == MMC_SD_HC_VOLT_SUPPLIED)
30008da2:	9b03      	ldr	r3, [sp, #12]
        thread_sleep(1);
30008da4:	2001      	movs	r0, #1
            if (cmd.resp[0] == MMC_SD_HC_VOLT_SUPPLIED)
30008da6:	f5b3 7fd5 	cmp.w	r3, #426	; 0x1aa
30008daa:	d009      	beq.n	30008dc0 <mmc_sd_card_init+0x60>
        thread_sleep(1);
30008dac:	f009 f970 	bl	30012090 <thread_sleep>
30008db0:	1e63      	subs	r3, r4, #1
    for (i = 0; i < SD_CMD8_MAX_RETRY; i++) {
30008db2:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
30008db6:	d1e6      	bne.n	30008d86 <mmc_sd_card_init+0x26>
    if (i == SD_CMD8_MAX_RETRY && (cmd.resp[0] != MMC_SD_HC_VOLT_SUPPLIED)) {
30008db8:	9b03      	ldr	r3, [sp, #12]
30008dba:	f5b3 7fd5 	cmp.w	r3, #426	; 0x1aa
30008dbe:	d134      	bne.n	30008e2a <mmc_sd_card_init+0xca>
        cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
30008dc0:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    card->rca = SD_CARD_RCA;
30008dc4:	2414      	movs	r4, #20
        cmd.cmd_index = ACMD41_SEND_OP_COND;
30008dc6:	f04f 0929 	mov.w	r9, #41	; 0x29
        cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
30008dca:	f2c4 07ff 	movt	r7, #16639	; 0x40ff
        cmd.resp_type = SDHCI_CMD_RESP_R3;
30008dce:	f04f 0808 	mov.w	r8, #8
        if (mmc_send_app_cmd(host, card)) {
30008dd2:	6831      	ldr	r1, [r6, #0]
30008dd4:	4628      	mov	r0, r5
30008dd6:	f7ff fdff 	bl	300089d8 <mmc_send_app_cmd.isra.9>
        if (sdhci_send_command(host, &cmd)) {
30008dda:	4669      	mov	r1, r13
        if (mmc_send_app_cmd(host, card)) {
30008ddc:	4603      	mov	r3, r0
30008dde:	bb80      	cbnz	r0, 30008e42 <mmc_sd_card_init+0xe2>
        cmd.cmd_index = ACMD41_SEND_OP_COND;
30008de0:	f8ad 9000 	strh.w	r9, [r13]
        if (sdhci_send_command(host, &cmd)) {
30008de4:	4628      	mov	r0, r5
        cmd.argument = MMC_SD_OCR | MMC_SD_HC_HCS;
30008de6:	9701      	str	r7, [sp, #4]
        cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
30008de8:	f88d 3009 	strb.w	r3, [r13, #9]
        cmd.resp_type = SDHCI_CMD_RESP_R3;
30008dec:	f8ad 800a 	strh.w	r8, [r13, #10]
        if (sdhci_send_command(host, &cmd)) {
30008df0:	f7ff f88c 	bl	30007f0c <sdhci_send_command>
30008df4:	4682      	mov	r10, r0
30008df6:	bb80      	cbnz	r0, 30008e5a <mmc_sd_card_init+0xfa>
            if (cmd.resp[0] & MMC_SD_DEV_READY) {
30008df8:	9b03      	ldr	r3, [sp, #12]
        thread_sleep(50);
30008dfa:	2032      	movs	r0, #50	; 0x32
            if (cmd.resp[0] & MMC_SD_DEV_READY) {
30008dfc:	2b00      	cmp	r3, #0
30008dfe:	db38      	blt.n	30008e72 <mmc_sd_card_init+0x112>
        thread_sleep(50);
30008e00:	f009 f946 	bl	30012090 <thread_sleep>
30008e04:	1e63      	subs	r3, r4, #1
    for (i = 0; i < SD_ACMD41_MAX_RETRY; i++) {
30008e06:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
30008e0a:	d1e2      	bne.n	30008dd2 <mmc_sd_card_init+0x72>
    if (i == SD_ACMD41_MAX_RETRY && !(cmd.resp[0] & MMC_SD_DEV_READY)) {
30008e0c:	9b03      	ldr	r3, [sp, #12]
30008e0e:	2b00      	cmp	r3, #0
30008e10:	db07      	blt.n	30008e22 <mmc_sd_card_init+0xc2>
        dprintf(CRITICAL, "Error: ACMD41 response timed out\n");
30008e12:	f64c 7084 	movw	r0, #53124	; 0xcf84
        return 1;
30008e16:	f04f 0a01 	mov.w	r10, #1
        dprintf(CRITICAL, "Error: ACMD41 response timed out\n");
30008e1a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008e1e:	f00c fec7 	bl	30015bb0 <_printf>
}
30008e22:	4650      	mov	r0, r10
30008e24:	b012      	add	sp, #72	; 0x48
30008e26:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        dprintf(CRITICAL, "Error: CMD8 response timed out\n");
30008e2a:	f64c 7030 	movw	r0, #53040	; 0xcf30
        return 1;
30008e2e:	f04f 0a01 	mov.w	r10, #1
        dprintf(CRITICAL, "Error: CMD8 response timed out\n");
30008e32:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008e36:	f00c febb 	bl	30015bb0 <_printf>
}
30008e3a:	4650      	mov	r0, r10
30008e3c:	b012      	add	sp, #72	; 0x48
30008e3e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            dprintf(CRITICAL, "Failed sending App command\n");
30008e42:	f64c 7050 	movw	r0, #53072	; 0xcf50
            return 1;
30008e46:	f04f 0a01 	mov.w	r10, #1
            dprintf(CRITICAL, "Failed sending App command\n");
30008e4a:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008e4e:	f00c feaf 	bl	30015bb0 <_printf>
}
30008e52:	4650      	mov	r0, r10
30008e54:	b012      	add	sp, #72	; 0x48
30008e56:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            dprintf(CRITICAL, "Failure sending ACMD41\n");
30008e5a:	f64c 706c 	movw	r0, #53100	; 0xcf6c
            return 1;
30008e5e:	f04f 0a01 	mov.w	r10, #1
            dprintf(CRITICAL, "Failure sending ACMD41\n");
30008e62:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008e66:	f00c fea3 	bl	30015bb0 <_printf>
}
30008e6a:	4650      	mov	r0, r10
30008e6c:	b012      	add	sp, #72	; 0x48
30008e6e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
30008e72:	4650      	mov	r0, r10
                if (cmd.resp[0] & (1 << 30))
30008e74:	005b      	lsls	r3, r3, #1
                    card->type = MMC_CARD_TYPE_SDHC;
30008e76:	bf4a      	itet	mi
30008e78:	2301      	movmi	r3, #1
                    card->type = MMC_CARD_TYPE_STD_SD;
30008e7a:	f8c6 a018 	strpl.w	r10, [r6, #24]
                    card->type = MMC_CARD_TYPE_SDHC;
30008e7e:	61b3      	strmi	r3, [r6, #24]
}
30008e80:	b012      	add	sp, #72	; 0x48
30008e82:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            dprintf(
30008e86:	f64c 60f4 	movw	r0, #52980	; 0xcef4
            return 1;
30008e8a:	f04f 0a01 	mov.w	r10, #1
            dprintf(
30008e8e:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008e92:	f00c fe8d 	bl	30015bb0 <_printf>
}
30008e96:	4650      	mov	r0, r10
30008e98:	b012      	add	sp, #72	; 0x48
30008e9a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
30008e9e:	bf00      	nop

30008ea0 <mmc_sd_set_bus_width>:
{
30008ea0:	b570      	push	{r4, r5, r6, r14}
30008ea2:	460d      	mov	r5, r1
30008ea4:	b092      	sub	sp, #72	; 0x48
30008ea6:	4604      	mov	r4, r0
    struct mmc_command cmd = {0};
30008ea8:	2100      	movs	r1, #0
{
30008eaa:	4616      	mov	r6, r2
    struct mmc_command cmd = {0};
30008eac:	4668      	mov	r0, r13
30008eae:	2248      	movs	r2, #72	; 0x48
30008eb0:	f00b ed5e 	blx	30014970 <memset>
    if (mmc_send_app_cmd(host, card)) {
30008eb4:	6829      	ldr	r1, [r5, #0]
30008eb6:	4620      	mov	r0, r4
30008eb8:	f7ff fd8e 	bl	300089d8 <mmc_send_app_cmd.isra.9>
30008ebc:	b9b0      	cbnz	r0, 30008eec <mmc_sd_set_bus_width+0x4c>
30008ebe:	4603      	mov	r3, r0
    cmd.argument = (width == MMC_DATA_BUS_WIDTH_4BIT) ? (1 << 1) : 0;
30008ec0:	2e01      	cmp	r6, #1
30008ec2:	bf14      	ite	ne
30008ec4:	4603      	movne	r3, r0
30008ec6:	2302      	moveq	r3, #2
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008ec8:	2201      	movs	r2, #1
    cmd.cmd_index = ACMD6_SET_BUS_WIDTH;
30008eca:	2506      	movs	r5, #6
    cmd.cmd_type = SDHCI_CMD_TYPE_NORMAL;
30008ecc:	f88d 0009 	strb.w	r0, [r13, #9]
    if (sdhci_send_command(host, &cmd))
30008ed0:	4669      	mov	r1, r13
    cmd.argument = (width == MMC_DATA_BUS_WIDTH_4BIT) ? (1 << 1) : 0;
30008ed2:	9301      	str	r3, [sp, #4]
    if (sdhci_send_command(host, &cmd))
30008ed4:	4620      	mov	r0, r4
    cmd.cmd_index = ACMD6_SET_BUS_WIDTH;
30008ed6:	f8ad 5000 	strh.w	r5, [r13]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008eda:	f8ad 200a 	strh.w	r2, [r13, #10]
    if (sdhci_send_command(host, &cmd))
30008ede:	f7ff f815 	bl	30007f0c <sdhci_send_command>
30008ee2:	3000      	adds	r0, #0
30008ee4:	bf18      	it	ne
30008ee6:	2001      	movne	r0, #1
}
30008ee8:	b012      	add	sp, #72	; 0x48
30008eea:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "Failed sending App command\n");
30008eec:	f64c 7050 	movw	r0, #53072	; 0xcf50
30008ef0:	f2c3 0001 	movt	r0, #12289	; 0x3001
30008ef4:	f00c fe5c 	bl	30015bb0 <_printf>
        return 1;
30008ef8:	2001      	movs	r0, #1
}
30008efa:	b012      	add	sp, #72	; 0x48
30008efc:	bd70      	pop	{r4, r5, r6, r15}
30008efe:	bf00      	nop

30008f00 <mmc_sd_set_hs>:
{
30008f00:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct mmc_command cmd = {0};
30008f02:	223e      	movs	r2, #62	; 0x3e
{
30008f04:	b0ab      	sub	sp, #172	; 0xac
30008f06:	4605      	mov	r5, r0
    struct mmc_command cmd = {0};
30008f08:	2100      	movs	r1, #0
30008f0a:	f10d 0002 	add.w	r0, r13, #2
30008f0e:	f00b ed30 	blx	30014970 <memset>
    cmd.argument = MMC_SD_SWITCH_HS;
30008f12:	f64f 73f1 	movw	r3, #65521	; 0xfff1
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008f16:	2401      	movs	r4, #1
{
30008f18:	f10d 0667 	add.w	r6, r13, #103	; 0x67
    cmd.cmd_index = CMD6_SWITCH_FUNC;
30008f1c:	2706      	movs	r7, #6
{
30008f1e:	f026 061f 	bic.w	r6, r6, #31
    cmd.data.blk_sz = 0x40;
30008f22:	2240      	movs	r2, #64	; 0x40
    cmd.argument = MMC_SD_SWITCH_HS;
30008f24:	f2c8 03ff 	movt	r3, #33023	; 0x80ff
    if (sdhci_send_command(host, &cmd))
30008f28:	4628      	mov	r0, r5
30008f2a:	4669      	mov	r1, r13
    cmd.data.data_ptr = switch_resp;
30008f2c:	960e      	str	r6, [sp, #56]	; 0x38
    cmd.argument = MMC_SD_SWITCH_HS;
30008f2e:	9301      	str	r3, [sp, #4]
    cmd.cmd_index = CMD6_SWITCH_FUNC;
30008f30:	f8ad 7000 	strh.w	r7, [r13]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30008f34:	f8ad 400a 	strh.w	r4, [r13, #10]
    cmd.trans_mode = SDHCI_MMC_READ;
30008f38:	9407      	str	r4, [sp, #28]
    cmd.data_present = 0x1;
30008f3a:	f88d 4008 	strb.w	r4, [r13, #8]
    cmd.data.blk_sz = 0x40;
30008f3e:	e9cd 2410 	strd	r2, r4, [r13, #64]	; 0x40
    if (sdhci_send_command(host, &cmd))
30008f42:	f7fe ffe3 	bl	30007f0c <sdhci_send_command>
30008f46:	b998      	cbnz	r0, 30008f70 <mmc_sd_set_hs+0x70>
    host->ops->set_uhs_mode(host, SDHCI_UHS_SDR25_MODE);
30008f48:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
30008f4c:	4621      	mov	r1, r4
30008f4e:	4628      	mov	r0, r5
30008f50:	691b      	ldr	r3, [r3, #16]
30008f52:	4798      	blx	r3
    if (host->ops->set_clock(host, SDHCI_CLK_50MHZ))
30008f54:	f8d5 30e4 	ldr.w	r3, [r5, #228]	; 0xe4
30008f58:	f24f 0180 	movw	r1, #61568	; 0xf080
30008f5c:	4628      	mov	r0, r5
30008f5e:	f2c0 21fa 	movt	r1, #762	; 0x2fa
30008f62:	685b      	ldr	r3, [r3, #4]
30008f64:	4798      	blx	r3
30008f66:	3000      	adds	r0, #0
30008f68:	bf18      	it	ne
30008f6a:	2001      	movne	r0, #1
}
30008f6c:	b02b      	add	sp, #172	; 0xac
30008f6e:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return 1;
30008f70:	4620      	mov	r0, r4
}
30008f72:	b02b      	add	sp, #172	; 0xac
30008f74:	bdf0      	pop	{r4, r5, r6, r7, r15}
30008f76:	bf00      	nop

30008f78 <mmc_sdhci_init>:
{
30008f78:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30008f7c:	46f0      	mov	r8, r14
30008f7e:	b0c3      	sub	sp, #268	; 0x10c
    ASSERT(dev);
30008f80:	2800      	cmp	r0, #0
30008f82:	f000 80fd 	beq.w	30009180 <mmc_sdhci_init+0x208>
30008f86:	4604      	mov	r4, r0
    memset(&dev->card, 0, sizeof(struct mmc_card));
30008f88:	f100 05e8 	add.w	r5, r0, #232	; 0xe8
30008f8c:	22c8      	movs	r2, #200	; 0xc8
30008f8e:	4628      	mov	r0, r5
30008f90:	2100      	movs	r1, #0
30008f92:	f00b ecee 	blx	30014970 <memset>
    host->base = (vaddr_t)_ioaddr(cfg->sdhc_base);
30008f96:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
    host->irq = cfg->irq;
30008f9a:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
    host->slot = cfg->slot;
30008f9e:	f894 61b0 	ldrb.w	r6, [r4, #432]	; 0x1b0
    host->base = (vaddr_t)_ioaddr(cfg->sdhc_base);
30008fa2:	6062      	str	r2, [r4, #4]
    data = (struct sdhci_priv_data *)malloc(sizeof(struct sdhci_priv_data));
30008fa4:	2010      	movs	r0, #16
    host->irq = cfg->irq;
30008fa6:	60a3      	str	r3, [r4, #8]
    host->slot = cfg->slot;
30008fa8:	6026      	str	r6, [r4, #0]
    data = (struct sdhci_priv_data *)malloc(sizeof(struct sdhci_priv_data));
30008faa:	f00b fb9d 	bl	300146e8 <malloc>
    ASSERT(data);
30008fae:	2800      	cmp	r0, #0
30008fb0:	f000 80f8 	beq.w	300091a4 <mmc_sdhci_init+0x22c>
    if (cfg->voltage)
30008fb4:	f8d4 31c4 	ldr.w	r3, [r4, #452]	; 0x1c4
30008fb8:	f10d 07c7 	add.w	r7, r13, #199	; 0xc7
    host->max_clk_rate = cfg->max_clk_rate;
30008fbc:	f8d4 21c0 	ldr.w	r2, [r4, #448]	; 0x1c0
30008fc0:	f027 071f 	bic.w	r7, r7, #31
30008fc4:	66e2      	str	r2, [r4, #108]	; 0x6c
    data->use_io_switch = cfg->use_io_switch;
30008fc6:	f894 21ca 	ldrb.w	r2, [r4, #458]	; 0x1ca
    data->slot = cfg->slot;
30008fca:	72c6      	strb	r6, [r0, #11]
    data->use_io_switch = cfg->use_io_switch;
30008fcc:	7302      	strb	r2, [r0, #12]
    host->caps.hs200_support = cfg->hs200_support;
30008fce:	f894 21c8 	ldrb.w	r2, [r4, #456]	; 0x1c8
    host->priv_data = data;
30008fd2:	f8c4 00dc 	str.w	r0, [r4, #220]	; 0xdc
    host->caps.hs200_support = cfg->hs200_support;
30008fd6:	f884 20da 	strb.w	r2, [r4, #218]	; 0xda
    host->caps.hs400_support = cfg->hs400_support;
30008fda:	f894 21c9 	ldrb.w	r2, [r4, #457]	; 0x1c9
30008fde:	f884 20db 	strb.w	r2, [r4, #219]	; 0xdb
    if (cfg->voltage)
30008fe2:	2b00      	cmp	r3, #0
30008fe4:	f040 808c 	bne.w	30009100 <mmc_sdhci_init+0x188>
    sdhci_init(host);
30008fe8:	4620      	mov	r0, r4
30008fea:	f7ff fb45 	bl	30008678 <sdhci_init>
    if (host->ops->config_pin)
30008fee:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
30008ff2:	68da      	ldr	r2, [r3, #12]
30008ff4:	b11a      	cbz	r2, 30008ffe <mmc_sdhci_init+0x86>
        host->ops->config_pin(host);
30008ff6:	4620      	mov	r0, r4
30008ff8:	4790      	blx	r2
30008ffa:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
    host->card_type = SDHCI_EMMC_CARD;
30008ffe:	2200      	movs	r2, #0
    host->ops->priv_init(host);
30009000:	4620      	mov	r0, r4
30009002:	681b      	ldr	r3, [r3, #0]
    host->card_type = SDHCI_EMMC_CARD;
30009004:	6762      	str	r2, [r4, #116]	; 0x74
    host->ops->priv_init(host);
30009006:	4798      	blx	r3
    mmc_return = host->ops->set_clock(host, SDHCI_CLK_400KHZ);
30009008:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
3000900c:	f44f 51d4 	mov.w	r1, #6784	; 0x1a80
30009010:	4620      	mov	r0, r4
30009012:	f2c0 0106 	movt	r1, #6
30009016:	685b      	ldr	r3, [r3, #4]
30009018:	4798      	blx	r3
    if (mmc_return) {
3000901a:	4606      	mov	r6, r0
3000901c:	2800      	cmp	r0, #0
3000901e:	d172      	bne.n	30009106 <mmc_sdhci_init+0x18e>
    if (host->caps.voltage == SDHCI_VOL_1_8)
30009020:	f894 20d5 	ldrb.w	r2, [r4, #213]	; 0xd5
    card->ocr = MMC_OCR_27_36 | MMC_OCR_SEC_MODE;
30009024:	f44f 4300 	mov.w	r3, #32768	; 0x8000
30009028:	f2c4 03ff 	movt	r3, #16639	; 0x40ff
    card->status = MMC_STATUS_INACTIVE;
3000902c:	f8c4 0104 	str.w	r0, [r4, #260]	; 0x104
    if (host->caps.voltage == SDHCI_VOL_1_8)
30009030:	2a05      	cmp	r2, #5
    card->ocr = MMC_OCR_27_36 | MMC_OCR_SEC_MODE;
30009032:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
        card->ocr = MMC_OCR_17_19 | MMC_OCR_SEC_MODE;
30009036:	bf08      	it	eq
30009038:	2380      	moveq	r3, #128	; 0x80
    spin(1000);
3000903a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
        card->ocr = MMC_OCR_17_19 | MMC_OCR_SEC_MODE;
3000903e:	bf04      	itt	eq
30009040:	f2c4 0300 	movteq	r3, #16384	; 0x4000
30009044:	f8c4 30ec 	streq.w	r3, [r4, #236]	; 0xec
    spin(1000);
30009048:	f00b f8d2 	bl	300141f0 <spin>
    memset(&cmd, 0, sizeof(struct mmc_command));
3000904c:	2248      	movs	r2, #72	; 0x48
3000904e:	2100      	movs	r1, #0
30009050:	a818      	add	r0, sp, #96	; 0x60
30009052:	f00b ec8e 	blx	30014970 <memset>
    return sdhci_send_command(host, &cmd);
30009056:	4620      	mov	r0, r4
30009058:	a918      	add	r1, sp, #96	; 0x60
3000905a:	f7fe ff57 	bl	30007f0c <sdhci_send_command>
    if (mmc_return) {
3000905e:	b2c1      	uxtb	r1, r0
30009060:	2900      	cmp	r1, #0
30009062:	d15e      	bne.n	30009122 <mmc_sdhci_init+0x1aa>
    memset(&cmd, 0, sizeof(struct mmc_command));
30009064:	2246      	movs	r2, #70	; 0x46
30009066:	f10d 0862 	add.w	r8, r13, #98	; 0x62
3000906a:	4640      	mov	r0, r8
    cmd.resp_type = SDHCI_CMD_RESP_R3;
3000906c:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
    memset(&cmd, 0, sizeof(struct mmc_command));
30009070:	f00b ec7e 	blx	30014970 <memset>
    cmd.cmd_index = CMD1_SEND_OP_COND;
30009074:	2101      	movs	r1, #1
    cmd.argument = card->ocr;
30009076:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
    cmd.resp_type = SDHCI_CMD_RESP_R3;
3000907a:	2208      	movs	r2, #8
    cmd.cmd_index = CMD1_SEND_OP_COND;
3000907c:	f8ad 1060 	strh.w	r1, [r13, #96]	; 0x60
    cmd.resp_type = SDHCI_CMD_RESP_R3;
30009080:	f8ad 206a 	strh.w	r2, [r13, #106]	; 0x6a
    cmd.argument = card->ocr;
30009084:	9319      	str	r3, [sp, #100]	; 0x64
        mmc_ret = sdhci_send_command(host, &cmd);
30009086:	4620      	mov	r0, r4
30009088:	a918      	add	r1, sp, #96	; 0x60
3000908a:	f7fe ff3f 	bl	30007f0c <sdhci_send_command>
        if (mmc_ret)
3000908e:	2800      	cmp	r0, #0
30009090:	f040 8134 	bne.w	300092fc <mmc_sdhci_init+0x384>
        mmc_resp = cmd.resp[0];
30009094:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
        if (!(mmc_resp & MMC_OCR_BUSY)) {
30009096:	2b00      	cmp	r3, #0
30009098:	f280 8124 	bge.w	300092e4 <mmc_sdhci_init+0x36c>
    card->ocr = mmc_resp;
3000909c:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
    if (mmc_resp & MMC_OCR_SEC_MODE)
300090a0:	005b      	lsls	r3, r3, #1
        card->type = MMC_TYPE_STD_MMC;
300090a2:	bf5c      	itt	pl
300090a4:	2304      	movpl	r3, #4
300090a6:	f8c4 3100 	strpl.w	r3, [r4, #256]	; 0x100
    if (mmc_resp & MMC_OCR_SEC_MODE)
300090aa:	d502      	bpl.n	300090b2 <mmc_sdhci_init+0x13a>
        card->type = MMC_TYPE_MMCHC;
300090ac:	2303      	movs	r3, #3
300090ae:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
    memset(&cmd, 0, sizeof(struct mmc_command));
300090b2:	2246      	movs	r2, #70	; 0x46
300090b4:	2100      	movs	r1, #0
300090b6:	4640      	mov	r0, r8
300090b8:	f00b ec5a 	blx	30014970 <memset>
    cmd.cmd_index = CMD2_ALL_SEND_CID;
300090bc:	2202      	movs	r2, #2
    cmd.resp_type = SDHCI_CMD_RESP_R2;
300090be:	2304      	movs	r3, #4
    mmc_ret = sdhci_send_command(host, &cmd);
300090c0:	a918      	add	r1, sp, #96	; 0x60
    cmd.cmd_index = CMD2_ALL_SEND_CID;
300090c2:	f8ad 2060 	strh.w	r2, [r13, #96]	; 0x60
    mmc_ret = sdhci_send_command(host, &cmd);
300090c6:	4620      	mov	r0, r4
    cmd.resp_type = SDHCI_CMD_RESP_R2;
300090c8:	f8ad 306a 	strh.w	r3, [r13, #106]	; 0x6a
    mmc_ret = sdhci_send_command(host, &cmd);
300090cc:	f7fe ff1e 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret) {
300090d0:	4606      	mov	r6, r0
300090d2:	2800      	cmp	r0, #0
300090d4:	d078      	beq.n	300091c8 <mmc_sdhci_init+0x250>
        dprintf(CRITICAL, "Failure getting card's CID number!\n");
300090d6:	f24d 2010 	movw	r0, #53776	; 0xd210
300090da:	f2c3 0001 	movt	r0, #12289	; 0x3001
300090de:	f00c fd67 	bl	30015bb0 <_printf>
    if (mmc_ret) {
300090e2:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
300090e6:	d017      	beq.n	30009118 <mmc_sdhci_init+0x1a0>
        dprintf(CRITICAL, "Failed detecting MMC/SDC @ slot%d\n",
300090e8:	f24d 4048 	movw	r0, #54344	; 0xd448
300090ec:	f894 11b0 	ldrb.w	r1, [r4, #432]	; 0x1b0
300090f0:	f2c3 0001 	movt	r0, #12289	; 0x3001
300090f4:	f00c fd5c 	bl	30015bb0 <_printf>
}
300090f8:	4630      	mov	r0, r6
300090fa:	b043      	add	sp, #268	; 0x10c
300090fc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        host->caps.voltage = cfg->voltage;
30009100:	f884 30d5 	strb.w	r3, [r4, #213]	; 0xd5
30009104:	e770      	b.n	30008fe8 <mmc_sdhci_init+0x70>
            dprintf(CRITICAL, "Failed to set card clk\n");
30009106:	f24d 108c 	movw	r0, #53644	; 0xd18c
3000910a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000910e:	f00c fd4f 	bl	30015bb0 <_printf>
    if (mmc_ret) {
30009112:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
30009116:	d1e7      	bne.n	300090e8 <mmc_sdhci_init+0x170>
    return 0;
30009118:	2600      	movs	r6, #0
}
3000911a:	4630      	mov	r0, r6
3000911c:	b043      	add	sp, #268	; 0x10c
3000911e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "Failure resetting MMC cards!\n");
30009122:	f24d 10a4 	movw	r0, #53668	; 0xd1a4
30009126:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000912a:	f00c fd41 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "MMC card failed to respond, try for SD card\n");
3000912e:	f24d 40a0 	movw	r0, #54432	; 0xd4a0
30009132:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009136:	f00c fd3b 	bl	30015bb0 <_printf>
        host->ops->priv_init(host);
3000913a:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
        host->card_type = SDHCI_SD_CARD;
3000913e:	2201      	movs	r2, #1
        host->ops->priv_init(host);
30009140:	4620      	mov	r0, r4
30009142:	681b      	ldr	r3, [r3, #0]
        host->card_type = SDHCI_SD_CARD;
30009144:	6762      	str	r2, [r4, #116]	; 0x74
        host->ops->priv_init(host);
30009146:	4798      	blx	r3
        mmc_return = host->ops->set_clock(host, SDHCI_CLK_400KHZ);
30009148:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
3000914c:	f44f 51d4 	mov.w	r1, #6784	; 0x1a80
30009150:	4620      	mov	r0, r4
30009152:	f2c0 0106 	movt	r1, #6
30009156:	685b      	ldr	r3, [r3, #4]
30009158:	4798      	blx	r3
        if (mmc_return) {
3000915a:	4606      	mov	r6, r0
3000915c:	2800      	cmp	r0, #0
3000915e:	d1d2      	bne.n	30009106 <mmc_sdhci_init+0x18e>
        mmc_return = mmc_sd_card_init(host, card);
30009160:	4629      	mov	r1, r5
30009162:	4620      	mov	r0, r4
30009164:	f7ff fdfc 	bl	30008d60 <mmc_sd_card_init>
30009168:	f10d 0862 	add.w	r8, r13, #98	; 0x62
        if (mmc_return) {
3000916c:	4606      	mov	r6, r0
3000916e:	2800      	cmp	r0, #0
30009170:	d09f      	beq.n	300090b2 <mmc_sdhci_init+0x13a>
            dprintf(CRITICAL, "Failed to initialize SD card\n");
30009172:	f24d 10f0 	movw	r0, #53744	; 0xd1f0
30009176:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000917a:	f00c fd19 	bl	30015bb0 <_printf>
3000917e:	e7c8      	b.n	30009112 <mmc_sdhci_init+0x19a>
    ASSERT(dev);
30009180:	f24d 1380 	movw	r3, #53632	; 0xd180
30009184:	f64c 5264 	movw	r2, #52580	; 0xcd64
30009188:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000918c:	f2c3 0301 	movt	r3, #12289	; 0x3001
30009190:	4670      	mov	r0, r14
30009192:	f2c3 0201 	movt	r2, #12289	; 0x3001
30009196:	9300      	str	r3, [sp, #0]
30009198:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000919c:	f240 63d1 	movw	r3, #1745	; 0x6d1
300091a0:	f00b f838 	bl	30014214 <_panic>
    ASSERT(data);
300091a4:	f24d 1384 	movw	r3, #53636	; 0xd184
300091a8:	f64c 5264 	movw	r2, #52580	; 0xcd64
300091ac:	f24a 011c 	movw	r1, #40988	; 0xa01c
300091b0:	f2c3 0301 	movt	r3, #12289	; 0x3001
300091b4:	4640      	mov	r0, r8
300091b6:	f2c3 0201 	movt	r2, #12289	; 0x3001
300091ba:	9300      	str	r3, [sp, #0]
300091bc:	f2c3 0101 	movt	r1, #12289	; 0x3001
300091c0:	f240 434c 	movw	r3, #1100	; 0x44c
300091c4:	f00b f826 	bl	30014214 <_panic>
    if (MMC_CARD_SD(card)) {
300091c8:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
300091cc:	f8dd c078 	ldr.w	r12, [r13, #120]	; 0x78
300091d0:	2a01      	cmp	r2, #1
300091d2:	f3cc 210f 	ubfx	r1, r12, #8, #16
300091d6:	ea4f 631c 	mov.w	r3, r12, lsr #24
300091da:	f240 8096 	bls.w	3000930a <mmc_sdhci_init+0x392>
        mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
300091de:	2260      	movs	r2, #96	; 0x60
300091e0:	f10d 0027 	add.w	r0, r13, #39	; 0x27
        mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
300091e4:	9308      	str	r3, [sp, #32]
        mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
300091e6:	9109      	str	r1, [sp, #36]	; 0x24
            mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid, (104 - 8 * (i + 1)),
300091e8:	0951      	lsrs	r1, r2, #5
300091ea:	ae42      	add	r6, sp, #264	; 0x108
300091ec:	eb06 0681 	add.w	r6, r6, r1, lsl #2
300091f0:	1dd3      	adds	r3, r2, #7
300091f2:	f002 0c1f 	and.w	r12, r2, #31
300091f6:	f856 6c9c 	ldr.w	r6, [r6, #-156]
300091fa:	095b      	lsrs	r3, r3, #5
300091fc:	4299      	cmp	r1, r3
300091fe:	fa26 f60c 	lsr.w	r6, r6, r12
30009202:	d20a      	bcs.n	3000921a <mmc_sdhci_init+0x2a2>
30009204:	a942      	add	r1, sp, #264	; 0x108
30009206:	eb01 0383 	add.w	r3, r1, r3, lsl #2
3000920a:	f1cc 0c20 	rsb	r12, r12, #32
3000920e:	f853 3c9c 	ldr.w	r3, [r3, #-156]
30009212:	fa03 fc0c 	lsl.w	r12, r3, r12
30009216:	ea46 060c 	orr.w	r6, r6, r12
3000921a:	f800 6f01 	strb.w	r6, [r0, #1]!
3000921e:	3a08      	subs	r2, #8
        for (i = 0; i < 6; i++) {
30009220:	2a30      	cmp	r2, #48	; 0x30
30009222:	d1e1      	bne.n	300091e8 <mmc_sdhci_init+0x270>
        mmc_cid.prv = UNPACK_BITS(raw_cid, 48, 8, mmc_sizeof);
30009224:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009226:	f10d 0920 	add.w	r9, r13, #32
        mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
3000922a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
3000922c:	464e      	mov	r6, r9
        mmc_cid.pnm[6] = 0;
3000922e:	f04f 0e00 	mov.w	r14, #0
        mmc_cid.prv = UNPACK_BITS(raw_cid, 48, 8, mmc_sizeof);
30009232:	f3c3 4107 	ubfx	r1, r3, #16, #8
        mmc_cid.year = UNPACK_BITS(raw_cid, 12, 4, mmc_sizeof);
30009236:	f3c2 3003 	ubfx	r0, r2, #12, #4
        mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
3000923a:	041b      	lsls	r3, r3, #16
3000923c:	ea43 4312 	orr.w	r3, r3, r2, lsr #16
        mmc_cid.year += 1997;
30009240:	f200 70cd 	addw	r0, r0, #1997	; 0x7cd
        mmc_cid.pnm[6] = 0;
30009244:	f88d e02e 	strb.w	r14, [r13, #46]	; 0x2e
        mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
30009248:	f3c2 2203 	ubfx	r2, r2, #8, #4
        mmc_cid.psn = UNPACK_BITS(raw_cid, 16, 32, mmc_sizeof);
3000924c:	e9cd 130c 	strd	r1, r3, [r13, #48]	; 0x30
        mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
30009250:	e9cd 200e 	strd	r2, r0, [r13, #56]	; 0x38
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009254:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
30009256:	f8c4 012c 	str.w	r0, [r4, #300]	; 0x12c
3000925a:	f8c4 1130 	str.w	r1, [r4, #304]	; 0x130
3000925e:	f8c4 2134 	str.w	r2, [r4, #308]	; 0x134
30009262:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
30009266:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
30009268:	f8c4 013c 	str.w	r0, [r4, #316]	; 0x13c
    memset(&cmd, 0, sizeof(struct mmc_command));
3000926c:	4640      	mov	r0, r8
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
3000926e:	f8c4 1140 	str.w	r1, [r4, #320]	; 0x140
    memset(&cmd, 0, sizeof(struct mmc_command));
30009272:	4671      	mov	r1, r14
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009274:	f8c4 2144 	str.w	r2, [r4, #324]	; 0x144
    memset(&cmd, 0, sizeof(struct mmc_command));
30009278:	2246      	movs	r2, #70	; 0x46
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
3000927a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
        cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
3000927e:	2603      	movs	r6, #3
    memset(&cmd, 0, sizeof(struct mmc_command));
30009280:	f00b eb76 	blx	30014970 <memset>
        card->rca = (cmd.argument >> 16);
30009284:	2002      	movs	r0, #2
        cmd.argument = (MMC_RCA << 16);
30009286:	f44f 3200 	mov.w	r2, #131072	; 0x20000
        cmd.resp_type = SDHCI_CMD_RESP_R6;
3000928a:	2340      	movs	r3, #64	; 0x40
        card->rca = (cmd.argument >> 16);
3000928c:	f8c4 00e8 	str.w	r0, [r4, #232]	; 0xe8
        mmc_ret = sdhci_send_command(host, &cmd);
30009290:	a918      	add	r1, sp, #96	; 0x60
        cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
30009292:	f8ad 6060 	strh.w	r6, [r13, #96]	; 0x60
        mmc_ret = sdhci_send_command(host, &cmd);
30009296:	4620      	mov	r0, r4
        cmd.argument = (MMC_RCA << 16);
30009298:	9219      	str	r2, [sp, #100]	; 0x64
        cmd.resp_type = SDHCI_CMD_RESP_R6;
3000929a:	f8ad 306a 	strh.w	r3, [r13, #106]	; 0x6a
        mmc_ret = sdhci_send_command(host, &cmd);
3000929e:	f7fe fe35 	bl	30007f0c <sdhci_send_command>
        if (mmc_ret)
300092a2:	4606      	mov	r6, r0
300092a4:	2800      	cmp	r0, #0
300092a6:	f040 808f 	bne.w	300093c8 <mmc_sdhci_init+0x450>
300092aa:	f8d4 60e8 	ldr.w	r6, [r4, #232]	; 0xe8
    memset(&cmd, 0, sizeof(struct mmc_command));
300092ae:	2246      	movs	r2, #70	; 0x46
300092b0:	2100      	movs	r1, #0
300092b2:	4640      	mov	r0, r8
    mmc_arg |= card->rca << 16;
300092b4:	0436      	lsls	r6, r6, #16
    memset(&cmd, 0, sizeof(struct mmc_command));
300092b6:	f00b eb5c 	blx	30014970 <memset>
    cmd.cmd_index = CMD9_SEND_CSD;
300092ba:	2209      	movs	r2, #9
    cmd.resp_type = SDHCI_CMD_RESP_R2;
300092bc:	2304      	movs	r3, #4
    mmc_ret = sdhci_send_command(host, &cmd);
300092be:	a918      	add	r1, sp, #96	; 0x60
    cmd.argument = mmc_arg;
300092c0:	9619      	str	r6, [sp, #100]	; 0x64
    mmc_ret = sdhci_send_command(host, &cmd);
300092c2:	4620      	mov	r0, r4
    cmd.cmd_index = CMD9_SEND_CSD;
300092c4:	f8ad 2060 	strh.w	r2, [r13, #96]	; 0x60
    cmd.resp_type = SDHCI_CMD_RESP_R2;
300092c8:	f8ad 306a 	strh.w	r3, [r13, #106]	; 0x6a
    mmc_ret = sdhci_send_command(host, &cmd);
300092cc:	f7fe fe1e 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret)
300092d0:	4606      	mov	r6, r0
300092d2:	2800      	cmp	r0, #0
300092d4:	d07f      	beq.n	300093d6 <mmc_sdhci_init+0x45e>
        dprintf(CRITICAL, "Failure getting card's CSD information!\n");
300092d6:	f24d 2034 	movw	r0, #53812	; 0xd234
300092da:	f2c3 0001 	movt	r0, #12289	; 0x3001
300092de:	f00c fc67 	bl	30015bb0 <_printf>
300092e2:	e716      	b.n	30009112 <mmc_sdhci_init+0x19a>
            thread_sleep(1);
300092e4:	2001      	movs	r0, #1
300092e6:	f008 fed3 	bl	30012090 <thread_sleep>
    } while (mmc_retry < MMC_MAX_COMMAND_RETRY);
300092ea:	3e01      	subs	r6, #1
300092ec:	f47f aecb 	bne.w	30009086 <mmc_sdhci_init+0x10e>
        dprintf(CRITICAL, "Card has busy status set. Init did not complete\n");
300092f0:	f24d 406c 	movw	r0, #54380	; 0xd46c
300092f4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300092f8:	f00c fc5a 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "Failure getting OCR response from MMC Card\n");
300092fc:	f24d 10c4 	movw	r0, #53700	; 0xd1c4
30009300:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009304:	f00c fc54 	bl	30015bb0 <_printf>
30009308:	e711      	b.n	3000912e <mmc_sdhci_init+0x1b6>
        mmc_cid.mid = UNPACK_BITS(raw_cid, 120, 8, mmc_sizeof);
3000930a:	9308      	str	r3, [sp, #32]
3000930c:	ae0a      	add	r6, sp, #40	; 0x28
        mmc_cid.oid = UNPACK_BITS(raw_cid, 104, 16, mmc_sizeof);
3000930e:	9109      	str	r1, [sp, #36]	; 0x24
30009310:	2360      	movs	r3, #96	; 0x60
            mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid, (104 - 8 * (i + 1)),
30009312:	0959      	lsrs	r1, r3, #5
30009314:	aa42      	add	r2, sp, #264	; 0x108
30009316:	eb02 0281 	add.w	r2, r2, r1, lsl #2
3000931a:	f103 0e07 	add.w	r14, r3, #7
3000931e:	f003 001f 	and.w	r0, r3, #31
30009322:	f852 2c9c 	ldr.w	r2, [r2, #-156]
30009326:	ebb1 1f5e 	cmp.w	r1, r14, lsr #5
3000932a:	f1a3 0308 	sub.w	r3, r3, #8
3000932e:	fa22 f200 	lsr.w	r2, r2, r0
30009332:	bf3e      	ittt	cc
30009334:	f1c0 0020 	rsbcc	r0, r0, #32
30009338:	fa0c f000 	lslcc.w	r0, r12, r0
3000933c:	4302      	orrcc	r2, r0
        for (i = 0; i < 5; i++) {
3000933e:	2b38      	cmp	r3, #56	; 0x38
            mmc_cid.pnm[i] = (uint8_t)UNPACK_BITS(raw_cid, (104 - 8 * (i + 1)),
30009340:	f806 2b01 	strb.w	r2, [r6], #1
        for (i = 0; i < 5; i++) {
30009344:	d1e5      	bne.n	30009312 <mmc_sdhci_init+0x39a>
        mmc_cid.prv = UNPACK_BITS(raw_cid, 56, 8, mmc_sizeof);
30009346:	9a1c      	ldr	r2, [sp, #112]	; 0x70
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009348:	f10d 0920 	add.w	r9, r13, #32
        mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
3000934c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
3000934e:	464e      	mov	r6, r9
        mmc_cid.pnm[5] = 0;
30009350:	f04f 0e00 	mov.w	r14, #0
        mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
30009354:	0210      	lsls	r0, r2, #8
        mmc_cid.year = UNPACK_BITS(raw_cid, 12, 8, mmc_sizeof);
30009356:	f3c3 3107 	ubfx	r1, r3, #12, #8
        mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
3000935a:	ea40 6013 	orr.w	r0, r0, r3, lsr #24
        mmc_cid.prv = UNPACK_BITS(raw_cid, 56, 8, mmc_sizeof);
3000935e:	0e12      	lsrs	r2, r2, #24
        mmc_cid.year += 2000;
30009360:	f501 61fa 	add.w	r1, r1, #2000	; 0x7d0
        mmc_cid.pnm[5] = 0;
30009364:	f88d e02d 	strb.w	r14, [r13, #45]	; 0x2d
        mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
30009368:	f3c3 2303 	ubfx	r3, r3, #8, #4
        mmc_cid.pnm[6] = 0;
3000936c:	f88d e02e 	strb.w	r14, [r13, #46]	; 0x2e
        mmc_cid.psn = UNPACK_BITS(raw_cid, 24, 32, mmc_sizeof);
30009370:	e9cd 200c 	strd	r2, r0, [r13, #48]	; 0x30
        mmc_cid.month = UNPACK_BITS(raw_cid, 8, 4, mmc_sizeof);
30009374:	e9cd 310e 	strd	r3, r1, [r13, #56]	; 0x38
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009378:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
3000937a:	f8c4 012c 	str.w	r0, [r4, #300]	; 0x12c
3000937e:	f8c4 1130 	str.w	r1, [r4, #304]	; 0x130
30009382:	f8c4 2134 	str.w	r2, [r4, #308]	; 0x134
30009386:	f8c4 3138 	str.w	r3, [r4, #312]	; 0x138
3000938a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
3000938c:	f8c4 013c 	str.w	r0, [r4, #316]	; 0x13c
    memset(&cmd, 0, sizeof(struct mmc_command));
30009390:	4640      	mov	r0, r8
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009392:	f8c4 1140 	str.w	r1, [r4, #320]	; 0x140
    memset(&cmd, 0, sizeof(struct mmc_command));
30009396:	4671      	mov	r1, r14
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
30009398:	f8c4 2144 	str.w	r2, [r4, #324]	; 0x144
    memset(&cmd, 0, sizeof(struct mmc_command));
3000939c:	2246      	movs	r2, #70	; 0x46
    memcpy(&card->cid, &mmc_cid, sizeof(struct mmc_cid));
3000939e:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    memset(&cmd, 0, sizeof(struct mmc_command));
300093a2:	f00b eae6 	blx	30014970 <memset>
        cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
300093a6:	2203      	movs	r2, #3
        cmd.resp_type = SDHCI_CMD_RESP_R6;
300093a8:	2340      	movs	r3, #64	; 0x40
        mmc_ret = sdhci_send_command(host, &cmd);
300093aa:	a918      	add	r1, sp, #96	; 0x60
        cmd.cmd_index = CMD3_SEND_RELATIVE_ADDR;
300093ac:	f8ad 2060 	strh.w	r2, [r13, #96]	; 0x60
        mmc_ret = sdhci_send_command(host, &cmd);
300093b0:	4620      	mov	r0, r4
        cmd.resp_type = SDHCI_CMD_RESP_R6;
300093b2:	f8ad 306a 	strh.w	r3, [r13, #106]	; 0x6a
        mmc_ret = sdhci_send_command(host, &cmd);
300093b6:	f7fe fda9 	bl	30007f0c <sdhci_send_command>
        if (mmc_ret)
300093ba:	4606      	mov	r6, r0
300093bc:	b920      	cbnz	r0, 300093c8 <mmc_sdhci_init+0x450>
        card->rca = (cmd.resp[0] >> 16);
300093be:	f8bd 606e 	ldrh.w	r6, [r13, #110]	; 0x6e
300093c2:	f8c4 60e8 	str.w	r6, [r4, #232]	; 0xe8
300093c6:	e772      	b.n	300092ae <mmc_sdhci_init+0x336>
        dprintf(CRITICAL, "Failure getting card's RCA!\n");
300093c8:	f24d 40d0 	movw	r0, #54480	; 0xd4d0
300093cc:	f2c3 0001 	movt	r0, #12289	; 0x3001
300093d0:	f00c fbee 	bl	30015bb0 <_printf>
300093d4:	e69d      	b.n	30009112 <mmc_sdhci_init+0x19a>
    memcpy(card->raw_csd, cmd.resp, sizeof(cmd.resp));
300093d6:	f10d 0c6c 	add.w	r12, r13, #108	; 0x6c
300093da:	f504 7e86 	add.w	r14, r4, #268	; 0x10c
300093de:	e8bc 000f 	ldmia.w	r12!, {r0, r1, r2, r3}
300093e2:	f8c4 010c 	str.w	r0, [r4, #268]	; 0x10c
    memset(&cmd, 0, sizeof(struct mmc_command));
300093e6:	4640      	mov	r0, r8
    memcpy(card->raw_csd, cmd.resp, sizeof(cmd.resp));
300093e8:	f8ce 1004 	str.w	r1, [r14, #4]
    memset(&cmd, 0, sizeof(struct mmc_command));
300093ec:	4631      	mov	r1, r6
    memcpy(card->raw_csd, cmd.resp, sizeof(cmd.resp));
300093ee:	f8ce 2008 	str.w	r2, [r14, #8]
    memset(&cmd, 0, sizeof(struct mmc_command));
300093f2:	2246      	movs	r2, #70	; 0x46
    memcpy(card->raw_csd, cmd.resp, sizeof(cmd.resp));
300093f4:	f8ce 300c 	str.w	r3, [r14, #12]
    memset(&cmd, 0, sizeof(struct mmc_command));
300093f8:	f00b eaba 	blx	30014970 <memset>
    mmc_arg |= card->rca << 16;
300093fc:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
    cmd.cmd_index = CMD7_SELECT_DESELECT_CARD;
30009400:	2107      	movs	r1, #7
30009402:	f8ad 1060 	strh.w	r1, [r13, #96]	; 0x60
    mmc_arg |= card->rca << 16;
30009406:	041a      	lsls	r2, r3, #16
    cmd.argument = mmc_arg;
30009408:	9219      	str	r2, [sp, #100]	; 0x64
    if (card->rca) {
3000940a:	b13b      	cbz	r3, 3000941c <mmc_sdhci_init+0x4a4>
        if (MMC_CARD_SD(card))
3000940c:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
30009410:	2b01      	cmp	r3, #1
            cmd.resp_type = SDHCI_CMD_RESP_R1B;
30009412:	bf94      	ite	ls
30009414:	2302      	movls	r3, #2
            cmd.resp_type = SDHCI_CMD_RESP_R1;
30009416:	2301      	movhi	r3, #1
30009418:	f8ad 306a 	strh.w	r3, [r13, #106]	; 0x6a
    mmc_ret = sdhci_send_command(host, &cmd);
3000941c:	4620      	mov	r0, r4
3000941e:	a918      	add	r1, sp, #96	; 0x60
30009420:	f7fe fd74 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret)
30009424:	4606      	mov	r6, r0
30009426:	b140      	cbz	r0, 3000943a <mmc_sdhci_init+0x4c2>
        dprintf(CRITICAL, "Failure selecting the Card with RCA: %x\n",
30009428:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
3000942c:	f24d 2060 	movw	r0, #53856	; 0xd260
30009430:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009434:	f00c fbbc 	bl	30015bb0 <_printf>
30009438:	e66b      	b.n	30009112 <mmc_sdhci_init+0x19a>
    if (MMC_CARD_SD(card)) {
3000943a:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    card->status = MMC_STATUS_ACTIVE;
3000943e:	2201      	movs	r2, #1
30009440:	f8c4 2104 	str.w	r2, [r4, #260]	; 0x104
    if (MMC_CARD_SD(card)) {
30009444:	4293      	cmp	r3, r2
30009446:	f240 8196 	bls.w	30009776 <mmc_sdhci_init+0x7fe>
        mmc_return = mmc_set_hs_interface(host, card);
3000944a:	4629      	mov	r1, r5
3000944c:	4620      	mov	r0, r4
3000944e:	f7ff fa71 	bl	30008934 <mmc_set_hs_interface>
        if (mmc_return) {
30009452:	4606      	mov	r6, r0
30009454:	2800      	cmp	r0, #0
30009456:	f040 81bb 	bne.w	300097d0 <mmc_sdhci_init+0x858>
    if (MMC_CARD_MMC(card)) {
3000945a:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
3000945e:	3b03      	subs	r3, #3
30009460:	2b01      	cmp	r3, #1
30009462:	f240 8197 	bls.w	30009794 <mmc_sdhci_init+0x81c>
    struct mmc_command cmd = {0};
30009466:	2100      	movs	r1, #0
30009468:	2248      	movs	r2, #72	; 0x48
3000946a:	a818      	add	r0, sp, #96	; 0x60
3000946c:	f00b ea80 	blx	30014970 <memset>
    if (mmc_send_app_cmd(host, card)) {
30009470:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
30009474:	4620      	mov	r0, r4
30009476:	f7ff faaf 	bl	300089d8 <mmc_send_app_cmd.isra.9>
3000947a:	2800      	cmp	r0, #0
3000947c:	f040 819a 	bne.w	300097b4 <mmc_sdhci_init+0x83c>
    cmd.cmd_index = ACMD51_READ_CARD_SCR;
30009480:	2233      	movs	r2, #51	; 0x33
    cmd.trans_mode = SDHCI_MMC_READ;
30009482:	f04f 0801 	mov.w	r8, #1
    cmd.data.blk_sz = 0x8;
30009486:	2308      	movs	r3, #8
    cmd.argument = 0x0;
30009488:	f04f 1601 	mov.w	r6, #65537	; 0x10001
3000948c:	9019      	str	r0, [sp, #100]	; 0x64
    if (sdhci_send_command(host, &cmd))
3000948e:	a918      	add	r1, sp, #96	; 0x60
    cmd.data.data_ptr = scr_resp;
30009490:	9726      	str	r7, [sp, #152]	; 0x98
    if (sdhci_send_command(host, &cmd))
30009492:	4620      	mov	r0, r4
    cmd.cmd_index = ACMD51_READ_CARD_SCR;
30009494:	f8ad 2060 	strh.w	r2, [r13, #96]	; 0x60
    cmd.trans_mode = SDHCI_MMC_READ;
30009498:	f8cd 807c 	str.w	r8, [r13, #124]	; 0x7c
    cmd.data.num_blocks = 0x1;
3000949c:	f8cd 80a4 	str.w	r8, [r13, #164]	; 0xa4
    cmd.argument = 0x0;
300094a0:	961a      	str	r6, [sp, #104]	; 0x68
    cmd.data.blk_sz = 0x8;
300094a2:	9328      	str	r3, [sp, #160]	; 0xa0
    if (sdhci_send_command(host, &cmd))
300094a4:	f7fe fd32 	bl	30007f0c <sdhci_send_command>
300094a8:	4601      	mov	r1, r0
300094aa:	2800      	cmp	r0, #0
300094ac:	f040 8188 	bne.w	300097c0 <mmc_sdhci_init+0x848>
300094b0:	e9d7 3000 	ldrd	r3, r0, [r7]
300094b4:	ba1b      	rev	r3, r3
        (card->raw_scr[0] & SD_SCR_BUS_WIDTH_MASK) >> SD_SCR_BUS_WIDTH;
300094b6:	f3c3 4203 	ubfx	r2, r3, #16, #4
    card->raw_scr[0] = swap_endian32(raw_scr[0]);
300094ba:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
300094be:	fa90 fc80 	rev.w	r12, r0
    card->scr.bus_widths =
300094c2:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    card->scr.cmd23_support = (card->raw_scr[0] & SD_SCR_CMD23_SUPPORT);
300094c6:	f003 0002 	and.w	r0, r3, #2
    card->raw_scr[1] = swap_endian32(raw_scr[1]);
300094ca:	f8c4 c120 	str.w	r12, [r4, #288]	; 0x120
        (card->raw_scr[0] & SD_SCR_SD_SPEC_MASK) >> SD_SCR_SD_SPEC;
300094ce:	f3c3 6203 	ubfx	r2, r3, #24, #4
    card->scr.cmd23_support = (card->raw_scr[0] & SD_SCR_CMD23_SUPPORT);
300094d2:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
        (card->raw_scr[0] & SD_SCR_SD_SPEC3_MASK) >> SD_SCR_SD_SPEC3;
300094d6:	f3c3 33c0 	ubfx	r3, r3, #15, #1
    card->scr.sd_spec =
300094da:	f8c4 2190 	str.w	r2, [r4, #400]	; 0x190
    struct mmc_command cmd = {0};
300094de:	a818      	add	r0, sp, #96	; 0x60
    card->scr.sd3_spec =
300094e0:	f8c4 3194 	str.w	r3, [r4, #404]	; 0x194
    struct mmc_command cmd = {0};
300094e4:	2248      	movs	r2, #72	; 0x48
300094e6:	f00b ea44 	blx	30014970 <memset>
    if (mmc_send_app_cmd(host, card)) {
300094ea:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
300094ee:	4620      	mov	r0, r4
300094f0:	f7ff fa72 	bl	300089d8 <mmc_send_app_cmd.isra.9>
300094f4:	2800      	cmp	r0, #0
300094f6:	f040 8257 	bne.w	300099a8 <mmc_sdhci_init+0xa30>
    cmd.cmd_index = ACMD13_SEND_SD_STATUS;
300094fa:	220d      	movs	r2, #13
    cmd.data.blk_sz = 0x40;
300094fc:	2340      	movs	r3, #64	; 0x40
    cmd.argument = 0x0;
300094fe:	9019      	str	r0, [sp, #100]	; 0x64
    if (sdhci_send_command(host, &cmd))
30009500:	a918      	add	r1, sp, #96	; 0x60
    cmd.trans_mode = SDHCI_MMC_READ;
30009502:	f8cd 807c 	str.w	r8, [r13, #124]	; 0x7c
    if (sdhci_send_command(host, &cmd))
30009506:	4620      	mov	r0, r4
    cmd.argument = 0x0;
30009508:	961a      	str	r6, [sp, #104]	; 0x68
    cmd.data.data_ptr = raw_sd_status;
3000950a:	9726      	str	r7, [sp, #152]	; 0x98
    cmd.data.num_blocks = 0x1;
3000950c:	f8cd 80a4 	str.w	r8, [r13, #164]	; 0xa4
    cmd.cmd_index = ACMD13_SEND_SD_STATUS;
30009510:	f8ad 2060 	strh.w	r2, [r13, #96]	; 0x60
    cmd.data.blk_sz = 0x40;
30009514:	9328      	str	r3, [sp, #160]	; 0xa0
    if (sdhci_send_command(host, &cmd))
30009516:	f7fe fcf9 	bl	30007f0c <sdhci_send_command>
3000951a:	2800      	cmp	r0, #0
3000951c:	f040 824a 	bne.w	300099b4 <mmc_sdhci_init+0xa3c>
    memcpy(sd_status, raw_sd_status, sizeof(sd_status));
30009520:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
30009522:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
30009526:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
30009528:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
3000952c:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
3000952e:	f10d 0c5c 	add.w	r12, r13, #92	; 0x5c
30009532:	e8a9 000f 	stmia.w	r9!, {r0, r1, r2, r3}
30009536:	ae07      	add	r6, sp, #28
30009538:	e897 000f 	ldmia.w	r7, {r0, r1, r2, r3}
3000953c:	4667      	mov	r7, r12
3000953e:	e889 000f 	stmia.w	r9, {r0, r1, r2, r3}
30009542:	f856 3f04 	ldr.w	r3, [r6, #4]!
30009546:	ba1b      	rev	r3, r3
    for (i = 15, j = 0; i >= 0; i--, j++)
30009548:	42be      	cmp	r6, r7
        sd_status[i] = swap_endian32(sd_status[j]);
3000954a:	f84c 3904 	str.w	r3, [r12], #-4
    for (i = 15, j = 0; i >= 0; i--, j++)
3000954e:	d1f8      	bne.n	30009542 <mmc_sdhci_init+0x5ca>
    au_size = UNPACK_BITS(status, MMC_SD_AU_SIZE_BIT, MMC_SD_AU_SIZE_LEN, 32);
30009550:	9b15      	ldr	r3, [sp, #84]	; 0x54
    card->ssr.au_size = 1 << (au_size + 4);
30009552:	2101      	movs	r1, #1
        UNPACK_BITS(status, MMC_SD_ERASE_SIZE_BIT, MMC_SD_ERASE_SIZE_LEN, 32);
30009554:	9a14      	ldr	r2, [sp, #80]	; 0x50
    au_size = UNPACK_BITS(status, MMC_SD_AU_SIZE_BIT, MMC_SD_AU_SIZE_LEN, 32);
30009556:	f3c3 3003 	ubfx	r0, r3, #12, #4
        UNPACK_BITS(status, MMC_SD_ERASE_SIZE_BIT, MMC_SD_ERASE_SIZE_LEN, 32);
3000955a:	021b      	lsls	r3, r3, #8
3000955c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
    card->ssr.au_size = 1 << (au_size + 4);
30009560:	3004      	adds	r0, #4
        UNPACK_BITS(status, MMC_SD_ERASE_SIZE_BIT, MMC_SD_ERASE_SIZE_LEN, 32);
30009562:	b29b      	uxth	r3, r3
    card->ssr.num_aus = MAX(card->ssr.num_aus, 1);
30009564:	2b01      	cmp	r3, #1
30009566:	bf38      	it	cc
30009568:	2301      	movcc	r3, #1
    card->ssr.au_size = 1 << (au_size + 4);
3000956a:	4081      	lsls	r1, r0
        UNPACK_BITS(status, MMC_SD_ERASE_TOUT_BIT, MMC_SD_ERASE_TOUT_LEN, 32);
3000956c:	f3c2 4085 	ubfx	r0, r2, #18, #6
    card->ssr.au_size = 1 << (au_size + 4);
30009570:	f8c4 119c 	str.w	r1, [r4, #412]	; 0x19c
    card->ssr.erase_offset = UNPACK_BITS(status, MMC_SD_ERASE_OFFSET_BIT,
30009574:	f3c2 4201 	ubfx	r2, r2, #16, #2
    card->ssr.num_aus = MAX(card->ssr.num_aus, 1);
30009578:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
    card->ssr.erase_timeout =
3000957c:	f8c4 01a4 	str.w	r0, [r4, #420]	; 0x1a4
    card->ssr.erase_offset = UNPACK_BITS(status, MMC_SD_ERASE_OFFSET_BIT,
30009580:	f8c4 21a8 	str.w	r2, [r4, #424]	; 0x1a8
    mmc_csd.cmmc_structure = UNPACK_BITS(raw_csd, 126, 2, mmc_sizeof);
30009584:	f8d4 2118 	ldr.w	r2, [r4, #280]	; 0x118
30009588:	f64d 0124 	movw	r1, #55332	; 0xd824
3000958c:	f64d 0344 	movw	r3, #55364	; 0xd844
30009590:	f2c3 0101 	movt	r1, #12289	; 0x3001
30009594:	f3c2 4602 	ubfx	r6, r2, #16, #3
30009598:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000959c:	f3c2 40c3 	ubfx	r0, r2, #19, #4
300095a0:	f851 7026 	ldr.w	r7, [r1, r6, lsl #2]
300095a4:	f3c2 2107 	ubfx	r1, r2, #8, #8
300095a8:	f64c 46cd 	movw	r6, #52429	; 0xcccd
300095ac:	ea4f 7c92 	mov.w	r12, r2, lsr #30
300095b0:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
300095b4:	eb01 0181 	add.w	r1, r1, r1, lsl #2
300095b8:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
300095bc:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
300095c0:	f8cd c060 	str.w	r12, [r13, #96]	; 0x60
300095c4:	fb00 f907 	mul.w	r9, r0, r7
300095c8:	eb01 0081 	add.w	r0, r1, r1, lsl #2
300095cc:	f8d4 110c 	ldr.w	r1, [r4, #268]	; 0x10c
300095d0:	ea4f 5e13 	mov.w	r14, r3, lsr #20
300095d4:	fba6 7909 	umull	r7, r9, r6, r9
    if (MMC_CARD_SD(card)) {
300095d8:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
300095dc:	0080      	lsls	r0, r0, #2
300095de:	9703      	str	r7, [sp, #12]
300095e0:	f3c1 3840 	ubfx	r8, r1, #13, #1
300095e4:	9005      	str	r0, [sp, #20]
300095e6:	2f01      	cmp	r7, #1
300095e8:	ea4f 00d9 	mov.w	r0, r9, lsr #3
300095ec:	f3c1 3b00 	ubfx	r11, r1, #12, #1
300095f0:	9004      	str	r0, [sp, #16]
300095f2:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
300095f6:	f240 815b 	bls.w	300098b0 <mmc_sdhci_init+0x938>
        mmc_csd.read_blk_misalign = UNPACK_BITS(raw_csd, 77, 1, mmc_sizeof);
300095fa:	ea4f 3c53 	mov.w	r12, r3, lsr #13
300095fe:	f89d 609c 	ldrb.w	r6, [r13, #156]	; 0x9c
30009602:	f36c 1604 	bfi	r6, r12, #4, #1
        mmc_csd.write_blk_misalign = UNPACK_BITS(raw_csd, 78, 1, mmc_sizeof);
30009606:	ea4f 3c93 	mov.w	r12, r3, lsr #14
3000960a:	f36c 1645 	bfi	r6, r12, #5, #1
        mmc_csd.read_blk_partial = UNPACK_BITS(raw_csd, 79, 1, mmc_sizeof);
3000960e:	ea4f 3cd3 	mov.w	r12, r3, lsr #15
30009612:	f36c 1686 	bfi	r6, r12, #6, #1
        mmc_csd.write_blk_partial = UNPACK_BITS(raw_csd, 21, 1, mmc_sizeof);
30009616:	ea4f 5c51 	mov.w	r12, r1, lsr #21
3000961a:	f36c 16c7 	bfi	r6, r12, #7, #1
        mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
3000961e:	ea4f 7cd1 	mov.w	r12, r1, lsr #31
30009622:	f36c 0600 	bfi	r6, r12, #0, #1
        mmc_csd.perm_wp = UNPACK_BITS(raw_csd, 13, 1, mmc_sizeof);
30009626:	f368 0641 	bfi	r6, r8, #1, #1
        mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
3000962a:	ea4f 0c83 	mov.w	r12, r3, lsl #2
        mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
3000962e:	f36b 0682 	bfi	r6, r11, #2, #1
        mmc_csd.spec_vers = UNPACK_BITS(raw_csd, 122, 4, mmc_sizeof);
30009632:	f3c2 6283 	ubfx	r2, r2, #26, #4
        mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
30009636:	f04f 0801 	mov.w	r8, #1
        mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
3000963a:	ea4c 7c90 	orr.w	r12, r12, r0, lsr #30
        mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
3000963e:	f3c1 5983 	ubfx	r9, r1, #22, #4
        mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
30009642:	f3cc 0c0b 	ubfx	r12, r12, #0, #12
        mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
30009646:	f88d 609c 	strb.w	r6, [r13, #156]	; 0x9c
        mmc_csd.read_blk_len = 1 << UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
3000964a:	f3c3 4303 	ubfx	r3, r3, #16, #4
        mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
3000964e:	f640 76ff 	movw	r6, #4095	; 0xfff
        mmc_csd.read_blk_len = 1 << UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
30009652:	fa08 f303 	lsl.w	r3, r8, r3
        mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
30009656:	9f05      	ldr	r7, [sp, #20]
        mmc_csd.erase_grp_mult = UNPACK_BITS(raw_csd, 37, 5, mmc_sizeof);
30009658:	f3c0 1a44 	ubfx	r10, r0, #5, #5
        mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
3000965c:	fa08 f809 	lsl.w	r8, r8, r9
        mmc_csd.spec_vers = UNPACK_BITS(raw_csd, 122, 4, mmc_sizeof);
30009660:	9219      	str	r2, [sp, #100]	; 0x64
        mmc_csd.erase_grp_size = UNPACK_BITS(raw_csd, 42, 5, mmc_sizeof);
30009662:	f3c0 2984 	ubfx	r9, r0, #10, #5
        mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
30009666:	f3c0 32c2 	ubfx	r2, r0, #15, #3
        mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
3000966a:	f8cd e068 	str.w	r14, [r13, #104]	; 0x68
        mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
3000966e:	f3c1 6182 	ubfx	r1, r1, #26, #3
        mmc_csd.tran_speed = 0x00;
30009672:	f04f 0e00 	mov.w	r14, #0
        mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 5, mmc_sizeof);
30009676:	f000 001f 	and.w	r0, r0, #31
        mmc_csd.nsac_clk_cycle = UNPACK_BITS(raw_csd, 104, 8, mmc_sizeof) * 100;
3000967a:	9721      	str	r7, [sp, #132]	; 0x84
        if (mmc_csd.c_size != 0xFFF) {
3000967c:	45b4      	cmp	r12, r6
        mmc_csd.taac_ns = (taac_value[mmc_value] * taac_unit[mmc_unit]) / 10;
3000967e:	9f04      	ldr	r7, [sp, #16]
30009680:	9722      	str	r7, [sp, #136]	; 0x88
        mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
30009682:	f8cd c080 	str.w	r12, [r13, #128]	; 0x80
        mmc_csd.write_blk_len = 1 << UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
30009686:	e9cd 831b 	strd	r8, r3, [r13, #108]	; 0x6c
        mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
3000968a:	911d      	str	r1, [sp, #116]	; 0x74
        mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
3000968c:	921f      	str	r2, [sp, #124]	; 0x7c
        mmc_csd.erase_grp_size = UNPACK_BITS(raw_csd, 42, 5, mmc_sizeof);
3000968e:	e9cd e923 	strd	r14, r9, [r13, #140]	; 0x8c
        mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 5, mmc_sizeof);
30009692:	e9cd a025 	strd	r10, r0, [r13, #148]	; 0x94
        if (mmc_csd.c_size != 0xFFF) {
30009696:	f000 8196 	beq.w	300099c6 <mmc_sdhci_init+0xa4e>
            mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
3000969a:	f10c 0c01 	add.w	r12, r12, #1
3000969e:	3202      	adds	r2, #2
300096a0:	fa0c fc02 	lsl.w	r12, r12, r2
                (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
300096a4:	17d9      	asrs	r1, r3, #31
300096a6:	fbac 2303 	umull	r2, r3, r12, r3
300096aa:	fb0c 3301 	mla	r3, r12, r1, r3
300096ae:	e9c4 233e 	strd	r2, r3, [r4, #248]	; 0xf8
    memcpy(&card->csd, &mmc_csd, sizeof(struct mmc_csd));
300096b2:	9f03      	ldr	r7, [sp, #12]
300096b4:	f10d 0e60 	add.w	r14, r13, #96	; 0x60
300096b8:	f504 7ca6 	add.w	r12, r4, #332	; 0x14c
300096bc:	f10d 08a0 	add.w	r8, r13, #160	; 0xa0
300096c0:	4676      	mov	r6, r14
300096c2:	f10c 0c10 	add.w	r12, r12, #16
300096c6:	f10e 0e10 	add.w	r14, r14, #16
300096ca:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
300096cc:	f84c 0c10 	str.w	r0, [r12, #-16]
300096d0:	f84c 1c0c 	str.w	r1, [r12, #-12]
300096d4:	4546      	cmp	r6, r8
300096d6:	f84c 2c08 	str.w	r2, [r12, #-8]
300096da:	f84c 3c04 	str.w	r3, [r12, #-4]
300096de:	d1ef      	bne.n	300096c0 <mmc_sdhci_init+0x748>
    if (MMC_CARD_MMC(card)) {
300096e0:	3f03      	subs	r7, #3
300096e2:	2f01      	cmp	r7, #1
300096e4:	d97b      	bls.n	300097de <mmc_sdhci_init+0x866>
        card->wp_grp_size = (card->csd.wp_grp_size + 1) *
300096e6:	f8d4 2184 	ldr.w	r2, [r4, #388]	; 0x184
        mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
300096ea:	4629      	mov	r1, r5
                            (card->csd.erase_grp_size + 1) *
300096ec:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
        mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
300096f0:	4620      	mov	r0, r4
        if (card->scr.bus_widths & SD_SCR_WIDTH_4BIT)
300096f2:	f8d4 718c 	ldr.w	r7, [r4, #396]	; 0x18c
        card->wp_grp_size = (card->csd.wp_grp_size + 1) *
300096f6:	1c56      	adds	r6, r2, #1
                            (card->csd.erase_grp_size + 1) *
300096f8:	1c5a      	adds	r2, r3, #1
                            (card->csd.erase_grp_mult + 1);
300096fa:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
        if (card->scr.bus_widths & SD_SCR_WIDTH_4BIT)
300096fe:	f3c7 0780 	ubfx	r7, r7, #2, #1
        card->wp_grp_size = (card->csd.wp_grp_size + 1) *
30009702:	fb02 f206 	mul.w	r2, r2, r6
                            (card->csd.erase_grp_mult + 1);
30009706:	3301      	adds	r3, #1
                            (card->csd.erase_grp_size + 1) *
30009708:	fb03 f302 	mul.w	r3, r3, r2
        mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
3000970c:	463a      	mov	r2, r7
        card->wp_grp_size = (card->csd.wp_grp_size + 1) *
3000970e:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
        mmc_return = mmc_sd_set_bus_width(host, card, bus_width);
30009712:	f7ff fbc5 	bl	30008ea0 <mmc_sd_set_bus_width>
        if (mmc_return) {
30009716:	4606      	mov	r6, r0
30009718:	2800      	cmp	r0, #0
3000971a:	f040 8162 	bne.w	300099e2 <mmc_sdhci_init+0xa6a>
        mmc_return = sdhci_set_bus_width(host, bus_width);
3000971e:	4639      	mov	r1, r7
30009720:	4620      	mov	r0, r4
30009722:	f7fe fbd5 	bl	30007ed0 <sdhci_set_bus_width>
        if (mmc_return) {
30009726:	4606      	mov	r6, r0
30009728:	2800      	cmp	r0, #0
3000972a:	f040 81b2 	bne.w	30009a92 <mmc_sdhci_init+0xb1a>
    if (MMC_CARD_MMC(card)) {
3000972e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
    card->block_size = MMC_BLK_SZ;
30009732:	f44f 7200 	mov.w	r2, #512	; 0x200
30009736:	f8c4 20f0 	str.w	r2, [r4, #240]	; 0xf0
    if (MMC_CARD_MMC(card)) {
3000973a:	3b03      	subs	r3, #3
3000973c:	2b01      	cmp	r3, #1
3000973e:	f63f aceb 	bhi.w	30009118 <mmc_sdhci_init+0x1a0>
        if (!card->ext_csd[MMC_EXT_CSD_RST_N_FUNC]) {
30009742:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
30009746:	f893 30a2 	ldrb.w	r3, [r3, #162]	; 0xa2
3000974a:	2b00      	cmp	r3, #0
3000974c:	f47f ace4 	bne.w	30009118 <mmc_sdhci_init+0x1a0>
            mmc_return =
30009750:	2001      	movs	r0, #1
30009752:	4629      	mov	r1, r5
30009754:	4602      	mov	r2, r0
30009756:	23a2      	movs	r3, #162	; 0xa2
30009758:	9000      	str	r0, [sp, #0]
3000975a:	4620      	mov	r0, r4
3000975c:	f7ff f86e 	bl	3000883c <mmc_switch_cmd>
            if (mmc_return) {
30009760:	4606      	mov	r6, r0
30009762:	2800      	cmp	r0, #0
30009764:	f43f acd8 	beq.w	30009118 <mmc_sdhci_init+0x1a0>
                dprintf(CRITICAL, "Failed to enable RST_n_FUNCTION\n");
30009768:	f24d 4024 	movw	r0, #54308	; 0xd424
3000976c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009770:	f00c fa1e 	bl	30015bb0 <_printf>
30009774:	e4cd      	b.n	30009112 <mmc_sdhci_init+0x19a>
        mmc_return = mmc_sd_set_hs(host, card);
30009776:	4629      	mov	r1, r5
30009778:	4620      	mov	r0, r4
3000977a:	f7ff fbc1 	bl	30008f00 <mmc_sd_set_hs>
        if (mmc_return) {
3000977e:	4606      	mov	r6, r0
30009780:	2800      	cmp	r0, #0
30009782:	f43f ae6a 	beq.w	3000945a <mmc_sdhci_init+0x4e2>
            dprintf(CRITICAL, "Failed to set HS for SD card\n");
30009786:	f24d 208c 	movw	r0, #53900	; 0xd28c
3000978a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000978e:	f00c fa0f 	bl	30015bb0 <_printf>
30009792:	e4be      	b.n	30009112 <mmc_sdhci_init+0x19a>
        mmc_return = mmc_get_ext_csd(host, card);
30009794:	4620      	mov	r0, r4
30009796:	f504 7184 	add.w	r1, r4, #264	; 0x108
3000979a:	f7ff fa05 	bl	30008ba8 <mmc_get_ext_csd.isra.13>
        if (mmc_return) {
3000979e:	4606      	mov	r6, r0
300097a0:	2800      	cmp	r0, #0
300097a2:	f43f aeef 	beq.w	30009584 <mmc_sdhci_init+0x60c>
            dprintf(CRITICAL, "Failure getting card's ExtCSD information!\n");
300097a6:	f24d 20d0 	movw	r0, #53968	; 0xd2d0
300097aa:	f2c3 0001 	movt	r0, #12289	; 0x3001
300097ae:	f00c f9ff 	bl	30015bb0 <_printf>
300097b2:	e4ae      	b.n	30009112 <mmc_sdhci_init+0x19a>
        dprintf(CRITICAL, "Failed sending App command\n");
300097b4:	f64c 7050 	movw	r0, #53072	; 0xcf50
300097b8:	f2c3 0001 	movt	r0, #12289	; 0x3001
300097bc:	f00c f9f8 	bl	30015bb0 <_printf>
            dprintf(CRITICAL, "Failure getting card's SCR register\n");
300097c0:	f24d 20fc 	movw	r0, #54012	; 0xd2fc
300097c4:	2601      	movs	r6, #1
300097c6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300097ca:	f00c f9f1 	bl	30015bb0 <_printf>
300097ce:	e48b      	b.n	300090e8 <mmc_sdhci_init+0x170>
            dprintf(CRITICAL, "Error adjusting interface speed!\n");
300097d0:	f24d 20ac 	movw	r0, #53932	; 0xd2ac
300097d4:	f2c3 0001 	movt	r0, #12289	; 0x3001
300097d8:	f00c f9ea 	bl	30015bb0 <_printf>
300097dc:	e499      	b.n	30009112 <mmc_sdhci_init+0x19a>
        if (card->ext_csd[MMC_ERASE_GRP_DEF])
300097de:	f8d4 2108 	ldr.w	r2, [r4, #264]	; 0x108
300097e2:	f892 30af 	ldrb.w	r3, [r2, #175]	; 0xaf
300097e6:	2b00      	cmp	r3, #0
300097e8:	f000 8103 	beq.w	300099f2 <mmc_sdhci_init+0xa7a>
                                card->ext_csd[MMC_HC_ERASE_GRP_SIZE] /
300097ec:	f892 30e0 	ldrb.w	r3, [r2, #224]	; 0xe0
300097f0:	029b      	lsls	r3, r3, #10
            card->wp_grp_size = MMC_HC_ERASE_MULT *
300097f2:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
        card->rpmb_size = RPMB_PART_MIN_SIZE * card->ext_csd[RPMB_SIZE_MULT];
300097f6:	f892 30a8 	ldrb.w	r3, [r2, #168]	; 0xa8
300097fa:	ebc3 1083 	rsb	r0, r3, r3, lsl #6
        if (cfg->bus_width == MMC_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
300097fe:	f8b4 11bc 	ldrh.w	r1, [r4, #444]	; 0x1bc
30009802:	2902      	cmp	r1, #2
        card->rpmb_size = RPMB_PART_MIN_SIZE * card->ext_csd[RPMB_SIZE_MULT];
30009804:	ebc3 1300 	rsb	r3, r3, r0, lsl #4
30009808:	ea4f 2303 	mov.w	r3, r3, lsl #8
3000980c:	f8c4 3124 	str.w	r3, [r4, #292]	; 0x124
        card->rel_wr_count = card->ext_csd[REL_WR_SEC_C];
30009810:	f892 30de 	ldrb.w	r3, [r2, #222]	; 0xde
30009814:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
        if (cfg->bus_width == MMC_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
30009818:	f000 812d 	beq.w	30009a76 <mmc_sdhci_init+0xafe>
        else if (cfg->bus_width == MMC_BUS_WIDTH_4BIT)
3000981c:	f1a1 0701 	sub.w	r7, r1, #1
30009820:	fab7 f787 	clz	r7, r7
30009824:	097f      	lsrs	r7, r7, #5
30009826:	b2b9      	uxth	r1, r7
        mmc_return = sdhci_set_bus_width(host, bus_width);
30009828:	4620      	mov	r0, r4
3000982a:	f7fe fb51 	bl	30007ed0 <sdhci_set_bus_width>
        if (mmc_return) {
3000982e:	2800      	cmp	r0, #0
30009830:	f040 8126 	bne.w	30009a80 <mmc_sdhci_init+0xb08>
        if (host->caps.hs400_support && mmc_card_supports_hs400_mode(card)) {
30009834:	f894 30db 	ldrb.w	r3, [r4, #219]	; 0xdb
30009838:	b13b      	cbz	r3, 3000984a <mmc_sdhci_init+0x8d2>
    if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS400_MODE)
3000983a:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
3000983e:	f893 30c4 	ldrb.w	r3, [r3, #196]	; 0xc4
30009842:	f013 0fc0 	tst.w	r3, #192	; 0xc0
30009846:	f040 8138 	bne.w	30009aba <mmc_sdhci_init+0xb42>
        else if (host->caps.hs200_support && host->caps.sdr104_support &&
3000984a:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
3000984e:	b153      	cbz	r3, 30009866 <mmc_sdhci_init+0x8ee>
30009850:	f894 30d9 	ldrb.w	r3, [r4, #217]	; 0xd9
30009854:	b13b      	cbz	r3, 30009866 <mmc_sdhci_init+0x8ee>
    if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_HS200_MODE)
30009856:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
3000985a:	f893 30c4 	ldrb.w	r3, [r3, #196]	; 0xc4
3000985e:	f013 0f30 	tst.w	r3, #48	; 0x30
30009862:	f040 8150 	bne.w	30009b06 <mmc_sdhci_init+0xb8e>
        else if (host->caps.ddr_support && mmc_card_supports_ddr_mode(card)) {
30009866:	f894 30d7 	ldrb.w	r3, [r4, #215]	; 0xd7
3000986a:	b13b      	cbz	r3, 3000987c <mmc_sdhci_init+0x904>
    if (card->ext_csd[MMC_DEVICE_TYPE] & MMC_HS_DDR_MODE)
3000986c:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
30009870:	f893 30c4 	ldrb.w	r3, [r3, #196]	; 0xc4
30009874:	f013 0f0c 	tst.w	r3, #12
30009878:	f040 8132 	bne.w	30009ae0 <mmc_sdhci_init+0xb68>
            mmc_return = mmc_set_hs_interface(host, card);
3000987c:	4629      	mov	r1, r5
3000987e:	4620      	mov	r0, r4
30009880:	f7ff f858 	bl	30008934 <mmc_set_hs_interface>
            if (mmc_return) {
30009884:	4606      	mov	r6, r0
30009886:	2800      	cmp	r0, #0
30009888:	f040 810b 	bne.w	30009aa2 <mmc_sdhci_init+0xb2a>
            mmc_return = mmc_set_bus_width(host, card, bus_width);
3000988c:	463a      	mov	r2, r7
3000988e:	4629      	mov	r1, r5
30009890:	4620      	mov	r0, r4
30009892:	f7ff f83d 	bl	30008910 <mmc_set_bus_width>
            if (mmc_return) {
30009896:	4606      	mov	r6, r0
30009898:	2800      	cmp	r0, #0
3000989a:	f43f af48 	beq.w	3000972e <mmc_sdhci_init+0x7b6>
                dprintf(CRITICAL, "Failure to set wide bus for Card(RCA:%x)\n",
3000989e:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
300098a2:	f24d 6058 	movw	r0, #54872	; 0xd658
300098a6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300098aa:	f00c f981 	bl	30015bb0 <_printf>
300098ae:	e430      	b.n	30009112 <mmc_sdhci_init+0x19a>
300098b0:	f64d 0aa4 	movw	r10, #55460	; 0xd8a4
300098b4:	f64d 0984 	movw	r9, #55428	; 0xd884
300098b8:	f3c2 07c3 	ubfx	r7, r2, #3, #4
300098bc:	f2c3 0a01 	movt	r10, #12289	; 0x3001
300098c0:	f002 0207 	and.w	r2, r2, #7
300098c4:	f2c3 0901 	movt	r9, #12289	; 0x3001
300098c8:	f85a a027 	ldr.w	r10, [r10, r7, lsl #2]
        if (mmc_csd.cmmc_structure == 1) {
300098cc:	f1bc 0f01 	cmp.w	r12, #1
300098d0:	f859 2022 	ldr.w	r2, [r9, r2, lsl #2]
300098d4:	fb02 fa0a 	mul.w	r10, r2, r10
300098d8:	fba6 260a 	umull	r2, r6, r6, r10
300098dc:	ea4f 0ad6 	mov.w	r10, r6, lsr #3
300098e0:	f000 8097 	beq.w	30009a12 <mmc_sdhci_init+0xa9a>
            mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
300098e4:	f8cd e068 	str.w	r14, [r13, #104]	; 0x68
            mmc_temp = UNPACK_BITS(raw_csd, 22, 4, mmc_sizeof);
300098e8:	f3c1 5683 	ubfx	r6, r1, #22, #4
                (mmc_temp > 8 && mmc_temp < 12) ? (1 << mmc_temp) : 512;
300098ec:	f1a6 0209 	sub.w	r2, r6, #9
300098f0:	2a02      	cmp	r2, #2
300098f2:	bf96      	itet	ls
300098f4:	2201      	movls	r2, #1
300098f6:	f44f 7200 	movhi.w	r2, #512	; 0x200
300098fa:	40b2      	lslls	r2, r6
            mmc_temp = UNPACK_BITS(raw_csd, 80, 4, mmc_sizeof);
300098fc:	f3c3 4603 	ubfx	r6, r3, #16, #4
            mmc_csd.write_blk_len =
30009900:	921b      	str	r2, [sp, #108]	; 0x6c
                (mmc_temp > 8 && mmc_temp < 12) ? (1 << mmc_temp) : 512;
30009902:	f1a6 0c09 	sub.w	r12, r6, #9
30009906:	f1bc 0f02 	cmp.w	r12, #2
3000990a:	f200 80ac 	bhi.w	30009a66 <mmc_sdhci_init+0xaee>
3000990e:	2201      	movs	r2, #1
30009910:	40b2      	lsls	r2, r6
30009912:	4616      	mov	r6, r2
30009914:	17d7      	asrs	r7, r2, #31
30009916:	e9cd 6706 	strd	r6, r7, [r13, #24]
            mmc_csd.erase_blk_len = UNPACK_BITS(raw_csd, 46, 1, mmc_sizeof);
3000991a:	ea4f 3c90 	mov.w	r12, r0, lsr #14
3000991e:	f89d 609c 	ldrb.w	r6, [r13, #156]	; 0x9c
            mmc_csd.read_blk_len =
30009922:	921c      	str	r2, [sp, #112]	; 0x70
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
30009924:	ea4f 0983 	mov.w	r9, r3, lsl #2
            mmc_csd.read_blk_misalign = UNPACK_BITS(raw_csd, 77, 1, mmc_sizeof);
30009928:	0b5a      	lsrs	r2, r3, #13
            mmc_csd.erase_blk_len = UNPACK_BITS(raw_csd, 46, 1, mmc_sizeof);
3000992a:	f36c 06c3 	bfi	r6, r12, #3, #1
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
3000992e:	ea49 7990 	orr.w	r9, r9, r0, lsr #30
            mmc_csd.read_blk_misalign = UNPACK_BITS(raw_csd, 77, 1, mmc_sizeof);
30009932:	f362 1604 	bfi	r6, r2, #4, #1
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
30009936:	f3c9 090b 	ubfx	r9, r9, #0, #12
                UNPACK_BITS(raw_csd, 78, 1, mmc_sizeof);
3000993a:	0b9a      	lsrs	r2, r3, #14
            mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
3000993c:	f3c0 3ec2 	ubfx	r14, r0, #15, #3
            mmc_csd.write_blk_misalign =
30009940:	f362 1645 	bfi	r6, r2, #5, #1
            mmc_csd.read_blk_partial = UNPACK_BITS(raw_csd, 79, 1, mmc_sizeof);
30009944:	0bdb      	lsrs	r3, r3, #15
            mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
30009946:	f109 0c01 	add.w	r12, r9, #1
            mmc_csd.c_size_mult = UNPACK_BITS(raw_csd, 47, 3, mmc_sizeof);
3000994a:	f8cd e07c 	str.w	r14, [r13, #124]	; 0x7c
            mmc_csd.read_blk_partial = UNPACK_BITS(raw_csd, 79, 1, mmc_sizeof);
3000994e:	f363 1686 	bfi	r6, r3, #6, #1
            mmc_temp = (1 << (mmc_csd.c_size_mult + 2)) * (mmc_csd.c_size + 1);
30009952:	f10e 0302 	add.w	r3, r14, #2
30009956:	fa0c fc03 	lsl.w	r12, r12, r3
            mmc_csd.write_blk_partial = UNPACK_BITS(raw_csd, 21, 1, mmc_sizeof);
3000995a:	0d4b      	lsrs	r3, r1, #21
3000995c:	f363 16c7 	bfi	r6, r3, #7, #1
            mmc_csd.wp_grp_enable = UNPACK_BITS(raw_csd, 31, 1, mmc_sizeof);
30009960:	0fcb      	lsrs	r3, r1, #31
30009962:	f363 0600 	bfi	r6, r3, #0, #1
            mmc_csd.perm_wp = UNPACK_BITS(raw_csd, 13, 1, mmc_sizeof);
30009966:	f368 0641 	bfi	r6, r8, #1, #1
                (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
3000996a:	e9dd 7806 	ldrd	r7, r8, [r13, #24]
            mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
3000996e:	f3c1 6182 	ubfx	r1, r1, #26, #3
            mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
30009972:	f36b 0682 	bfi	r6, r11, #2, #1
            mmc_csd.r2w_factor = UNPACK_BITS(raw_csd, 26, 3, mmc_sizeof);
30009976:	911d      	str	r1, [sp, #116]	; 0x74
                (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
30009978:	fbac 2307 	umull	r2, r3, r12, r7
            mmc_csd.taac_ns =
3000997c:	9f04      	ldr	r7, [sp, #16]
            mmc_csd.tran_speed =
3000997e:	e9cd 7a22 	strd	r7, r10, [r13, #136]	; 0x88
                (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
30009982:	fb0c 3308 	mla	r3, r12, r8, r3
            mmc_csd.nsac_clk_cycle =
30009986:	9f05      	ldr	r7, [sp, #20]
            mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
30009988:	f3c0 1cc6 	ubfx	r12, r0, #7, #7
3000998c:	f10c 0c01 	add.w	r12, r12, #1
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 62, 12, mmc_sizeof);
30009990:	e9cd 9720 	strd	r9, r7, [r13, #128]	; 0x80
            mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 7, mmc_sizeof);
30009994:	f000 007f 	and.w	r0, r0, #127	; 0x7f
            mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
30009998:	f88d 609c 	strb.w	r6, [r13, #156]	; 0x9c
                (unsigned long long)mmc_temp * mmc_csd.read_blk_len;
3000999c:	e9c4 233e 	strd	r2, r3, [r4, #248]	; 0xf8
            mmc_csd.sector_size = UNPACK_BITS(raw_csd, 39, 7, mmc_sizeof) + 1;
300099a0:	f8cd c078 	str.w	r12, [r13, #120]	; 0x78
            mmc_csd.wp_grp_size = UNPACK_BITS(raw_csd, 32, 7, mmc_sizeof);
300099a4:	9026      	str	r0, [sp, #152]	; 0x98
300099a6:	e684      	b.n	300096b2 <mmc_sdhci_init+0x73a>
        dprintf(CRITICAL, "Failed sending App command\n");
300099a8:	f64c 7050 	movw	r0, #53072	; 0xcf50
300099ac:	f2c3 0001 	movt	r0, #12289	; 0x3001
300099b0:	f00c f8fe 	bl	30015bb0 <_printf>
            dprintf(CRITICAL, "Failed to get SSR from the card\n");
300099b4:	f24d 3024 	movw	r0, #54052	; 0xd324
300099b8:	2601      	movs	r6, #1
300099ba:	f2c3 0001 	movt	r0, #12289	; 0x3001
300099be:	f00c f8f7 	bl	30015bb0 <_printf>
300099c2:	f7ff bb91 	b.w	300090e8 <mmc_sdhci_init+0x170>
                (card->ext_csd[MMC_SEC_COUNT2] << MMC_SEC_COUNT2_SHIFT) |
300099c6:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
300099ca:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
            card->capacity = sec_count * MMC_BLK_SZ;
300099ce:	ea4f 79e2 	mov.w	r9, r2, asr #31
300099d2:	0251      	lsls	r1, r2, #9
300099d4:	ea4f 2349 	mov.w	r3, r9, lsl #9
300099d8:	ea43 53d2 	orr.w	r3, r3, r2, lsr #23
300099dc:	e9c4 133e 	strd	r1, r3, [r4, #248]	; 0xf8
300099e0:	e667      	b.n	300096b2 <mmc_sdhci_init+0x73a>
            dprintf(CRITICAL, "Failed to set bus width for the card\n");
300099e2:	f24d 30fc 	movw	r0, #54268	; 0xd3fc
300099e6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300099ea:	f00c f8e1 	bl	30015bb0 <_printf>
300099ee:	f7ff bb90 	b.w	30009112 <mmc_sdhci_init+0x19a>
            card->wp_grp_size = (card->csd.wp_grp_size + 1) *
300099f2:	f8d4 1184 	ldr.w	r1, [r4, #388]	; 0x184
                                (card->csd.erase_grp_size + 1) *
300099f6:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
            card->wp_grp_size = (card->csd.wp_grp_size + 1) *
300099fa:	1c48      	adds	r0, r1, #1
                                (card->csd.erase_grp_size + 1) *
300099fc:	1c59      	adds	r1, r3, #1
                                (card->csd.erase_grp_mult + 1);
300099fe:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
            card->wp_grp_size = (card->csd.wp_grp_size + 1) *
30009a02:	fb01 f100 	mul.w	r1, r1, r0
                                (card->csd.erase_grp_mult + 1);
30009a06:	3301      	adds	r3, #1
                                (card->csd.erase_grp_size + 1) *
30009a08:	fb03 f301 	mul.w	r3, r3, r1
            card->wp_grp_size = (card->csd.wp_grp_size + 1) *
30009a0c:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
30009a10:	e6f1      	b.n	300097f6 <mmc_sdhci_init+0x87e>
            mmc_csd.nsac_clk_cycle =
30009a12:	9f05      	ldr	r7, [sp, #20]
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 48, 22, mmc_sizeof);
30009a14:	041a      	lsls	r2, r3, #16
            mmc_csd.erase_blk_len = 1;
30009a16:	f89d 309c 	ldrb.w	r3, [r13, #156]	; 0x9c
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 48, 22, mmc_sizeof);
30009a1a:	ea42 4210 	orr.w	r2, r2, r0, lsr #16
30009a1e:	f3c2 0215 	ubfx	r2, r2, #0, #22
            mmc_csd.read_blk_misalign = 0;
30009a22:	f043 0308 	orr.w	r3, r3, #8
                (unsigned long long)(1 + mmc_csd.c_size) * 512 * 1024;
30009a26:	1c51      	adds	r1, r2, #1
            mmc_csd.write_blk_len = 512;
30009a28:	f44f 7000 	mov.w	r0, #512	; 0x200
            mmc_csd.perm_wp = UNPACK_BITS(raw_csd, 13, 1, mmc_sizeof);
30009a2c:	f003 030e 	and.w	r3, r3, #14
30009a30:	f368 0341 	bfi	r3, r8, #1, #1
                (unsigned long long)(1 + mmc_csd.c_size) * 512 * 1024;
30009a34:	0b4e      	lsrs	r6, r1, #13
            mmc_csd.c_size = UNPACK_BITS(raw_csd, 48, 22, mmc_sizeof);
30009a36:	9220      	str	r2, [sp, #128]	; 0x80
            mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
30009a38:	f36b 0382 	bfi	r3, r11, #2, #1
            mmc_csd.c_size_mult = 0;
30009a3c:	2200      	movs	r2, #0
                (unsigned long long)(1 + mmc_csd.c_size) * 512 * 1024;
30009a3e:	04c9      	lsls	r1, r1, #19
            mmc_csd.nsac_clk_cycle =
30009a40:	9721      	str	r7, [sp, #132]	; 0x84
            mmc_csd.r2w_factor = 0x2;
30009a42:	f04f 0c02 	mov.w	r12, #2
            mmc_csd.taac_ns =
30009a46:	9f04      	ldr	r7, [sp, #16]
            mmc_csd.card_cmd_class = UNPACK_BITS(raw_csd, 84, 12, mmc_sizeof);
30009a48:	f8cd e068 	str.w	r14, [r13, #104]	; 0x68
            mmc_csd.tran_speed =
30009a4c:	e9cd 7a22 	strd	r7, r10, [r13, #136]	; 0x88
            mmc_csd.temp_wp = UNPACK_BITS(raw_csd, 12, 1, mmc_sizeof);
30009a50:	f88d 309c 	strb.w	r3, [r13, #156]	; 0x9c
            card->capacity =
30009a54:	e9c4 163e 	strd	r1, r6, [r4, #248]	; 0xf8
            mmc_csd.read_blk_len = 512;
30009a58:	e9cd 001b 	strd	r0, r0, [r13, #108]	; 0x6c
            mmc_csd.r2w_factor = 0x2;
30009a5c:	f8cd c074 	str.w	r12, [r13, #116]	; 0x74
            mmc_csd.c_size_mult = 0;
30009a60:	921f      	str	r2, [sp, #124]	; 0x7c
            mmc_csd.wp_grp_size = 0x0;
30009a62:	9226      	str	r2, [sp, #152]	; 0x98
30009a64:	e625      	b.n	300096b2 <mmc_sdhci_init+0x73a>
                (mmc_temp > 8 && mmc_temp < 12) ? (1 << mmc_temp) : 512;
30009a66:	f44f 7600 	mov.w	r6, #512	; 0x200
30009a6a:	2700      	movs	r7, #0
30009a6c:	f44f 7200 	mov.w	r2, #512	; 0x200
30009a70:	e9cd 6706 	strd	r6, r7, [r13, #24]
30009a74:	e751      	b.n	3000991a <mmc_sdhci_init+0x9a2>
        if (cfg->bus_width == MMC_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
30009a76:	f894 70d0 	ldrb.w	r7, [r4, #208]	; 0xd0
30009a7a:	b1e7      	cbz	r7, 30009ab6 <mmc_sdhci_init+0xb3e>
            bus_width = MMC_DATA_BUS_WIDTH_8BIT;
30009a7c:	460f      	mov	r7, r1
30009a7e:	e6d3      	b.n	30009828 <mmc_sdhci_init+0x8b0>
            dprintf(CRITICAL, "Failed to set bus width for host controller\n");
30009a80:	f24d 3048 	movw	r0, #54088	; 0xd348
30009a84:	2601      	movs	r6, #1
30009a86:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009a8a:	f00c f891 	bl	30015bb0 <_printf>
30009a8e:	f7ff bb2b 	b.w	300090e8 <mmc_sdhci_init+0x170>
            dprintf(CRITICAL, "Failed to set bus width for host controller\n");
30009a92:	f24d 3048 	movw	r0, #54088	; 0xd348
30009a96:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009a9a:	f00c f889 	bl	30015bb0 <_printf>
30009a9e:	f7ff bb38 	b.w	30009112 <mmc_sdhci_init+0x19a>
                dprintf(CRITICAL,
30009aa2:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
30009aa6:	f24d 30d0 	movw	r0, #54224	; 0xd3d0
30009aaa:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009aae:	f00c f87f 	bl	30015bb0 <_printf>
30009ab2:	f7ff bb2e 	b.w	30009112 <mmc_sdhci_init+0x19a>
        if (cfg->bus_width == MMC_BUS_WIDTH_8BIT && host->caps.bus_width_8bit)
30009ab6:	4639      	mov	r1, r7
30009ab8:	e6b6      	b.n	30009828 <mmc_sdhci_init+0x8b0>
            mmc_return = mmc_set_hs400_mode(host, card, bus_width);
30009aba:	463a      	mov	r2, r7
30009abc:	4629      	mov	r1, r5
30009abe:	4620      	mov	r0, r4
30009ac0:	f7ff f8d2 	bl	30008c68 <mmc_set_hs400_mode>
            if (mmc_return) {
30009ac4:	4606      	mov	r6, r0
30009ac6:	2800      	cmp	r0, #0
30009ac8:	f43f ae31 	beq.w	3000972e <mmc_sdhci_init+0x7b6>
                dprintf(CRITICAL,
30009acc:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
30009ad0:	f24d 3078 	movw	r0, #54136	; 0xd378
30009ad4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009ad8:	f00c f86a 	bl	30015bb0 <_printf>
30009adc:	f7ff bb19 	b.w	30009112 <mmc_sdhci_init+0x19a>
            mmc_return = mmc_set_ddr_mode(host, card, bus_width);
30009ae0:	463a      	mov	r2, r7
30009ae2:	4629      	mov	r1, r5
30009ae4:	4620      	mov	r0, r4
30009ae6:	f7fe ff3f 	bl	30008968 <mmc_set_ddr_mode>
            if (mmc_return) {
30009aea:	4606      	mov	r6, r0
30009aec:	2800      	cmp	r0, #0
30009aee:	f43f ae1e 	beq.w	3000972e <mmc_sdhci_init+0x7b6>
                dprintf(CRITICAL, "Failure to set DDR mode for Card(RCA:%x)\n",
30009af2:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
30009af6:	f24d 602c 	movw	r0, #54828	; 0xd62c
30009afa:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009afe:	f00c f857 	bl	30015bb0 <_printf>
30009b02:	f7ff bb06 	b.w	30009112 <mmc_sdhci_init+0x19a>
            mmc_return = mmc_set_hs200_mode(host, card, bus_width);
30009b06:	463a      	mov	r2, r7
30009b08:	4629      	mov	r1, r5
30009b0a:	4620      	mov	r0, r4
30009b0c:	f7fe fffe 	bl	30008b0c <mmc_set_hs200_mode>
            if (mmc_return) {
30009b10:	4606      	mov	r6, r0
30009b12:	2800      	cmp	r0, #0
30009b14:	f43f ae0b 	beq.w	3000972e <mmc_sdhci_init+0x7b6>
                dprintf(CRITICAL,
30009b18:	f8d4 10e8 	ldr.w	r1, [r4, #232]	; 0xe8
30009b1c:	f24d 30a4 	movw	r0, #54180	; 0xd3a4
30009b20:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009b24:	f00c f844 	bl	30015bb0 <_printf>
30009b28:	f7ff baf3 	b.w	30009112 <mmc_sdhci_init+0x19a>

30009b2c <mmc_sdhci_read>:
{
30009b2c:	b5f0      	push	{r4, r5, r6, r7, r14}
30009b2e:	4605      	mov	r5, r0
30009b30:	b095      	sub	sp, #84	; 0x54
30009b32:	460e      	mov	r6, r1
30009b34:	4617      	mov	r7, r2
    memset(&cmd, 0, sizeof(struct mmc_command));
30009b36:	2100      	movs	r1, #0
30009b38:	a802      	add	r0, sp, #8
{
30009b3a:	9c1a      	ldr	r4, [sp, #104]	; 0x68
    memset(&cmd, 0, sizeof(struct mmc_command));
30009b3c:	2248      	movs	r2, #72	; 0x48
30009b3e:	f00a ef18 	blx	30014970 <memset>
    if (num_blocks == 1)
30009b42:	2c01      	cmp	r4, #1
        cmd.cmd_index = CMD17_READ_SINGLE_BLOCK;
30009b44:	bf0c      	ite	eq
30009b46:	2311      	moveq	r3, #17
        cmd.cmd_index = CMD18_READ_MULTIPLE_BLOCK;
30009b48:	2312      	movne	r3, #18
30009b4a:	f8ad 3008 	strh.w	r3, [r13, #8]
    if (card->type == MMC_TYPE_STD_MMC)
30009b4e:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
30009b52:	2b04      	cmp	r3, #4
30009b54:	d00c      	beq.n	30009b70 <mmc_sdhci_read+0x44>
        cmd.argument = blk_addr;
30009b56:	9703      	str	r7, [sp, #12]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009b58:	2201      	movs	r2, #1
    if (MMC_CARD_SD(card))
30009b5a:	4293      	cmp	r3, r2
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009b5c:	f8ad 2012 	strh.w	r2, [r13, #18]
    cmd.trans_mode = SDHCI_MMC_READ;
30009b60:	9209      	str	r2, [sp, #36]	; 0x24
    cmd.data_present = 0x1;
30009b62:	f88d 2010 	strb.w	r2, [r13, #16]
    if (MMC_CARD_SD(card))
30009b66:	d80e      	bhi.n	30009b86 <mmc_sdhci_read+0x5a>
        cmd.cmd23_support = dev->card.scr.cmd23_support;
30009b68:	f8d5 3198 	ldr.w	r3, [r5, #408]	; 0x198
30009b6c:	930b      	str	r3, [sp, #44]	; 0x2c
30009b6e:	e00c      	b.n	30009b8a <mmc_sdhci_read+0x5e>
        cmd.argument = blk_addr * card->block_size;
30009b70:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009b74:	2201      	movs	r2, #1
30009b76:	f8ad 2012 	strh.w	r2, [r13, #18]
        cmd.argument = blk_addr * card->block_size;
30009b7a:	fb07 f703 	mul.w	r7, r7, r3
    cmd.trans_mode = SDHCI_MMC_READ;
30009b7e:	9209      	str	r2, [sp, #36]	; 0x24
    cmd.data_present = 0x1;
30009b80:	f88d 2010 	strb.w	r2, [r13, #16]
        cmd.argument = blk_addr * card->block_size;
30009b84:	9703      	str	r7, [sp, #12]
        cmd.cmd23_support = 0x1;
30009b86:	2301      	movs	r3, #1
30009b88:	930b      	str	r3, [sp, #44]	; 0x2c
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30009b8a:	4628      	mov	r0, r5
30009b8c:	a902      	add	r1, sp, #8
    cmd.data.data_ptr = dest;
30009b8e:	9610      	str	r6, [sp, #64]	; 0x40
    cmd.data.num_blocks = num_blocks;
30009b90:	9413      	str	r4, [sp, #76]	; 0x4c
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30009b92:	f7fe f9bb 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret && num_blocks > 1) {
30009b96:	2800      	cmp	r0, #0
30009b98:	bf18      	it	ne
30009b9a:	2c01      	cmpne	r4, #1
30009b9c:	d828      	bhi.n	30009bf0 <mmc_sdhci_read+0xc4>
    if(mmc_parse_response(cmd.resp[0]))
30009b9e:	9805      	ldr	r0, [sp, #20]
30009ba0:	f7fe ff3a 	bl	30008a18 <mmc_parse_response>
        return 1;
30009ba4:	2201      	movs	r2, #1
    if(mmc_parse_response(cmd.resp[0]))
30009ba6:	bb00      	cbnz	r0, 30009bea <mmc_sdhci_read+0xbe>
30009ba8:	f242 7410 	movw	r4, #10000	; 0x2710
30009bac:	f105 06e8 	add.w	r6, r5, #232	; 0xe8
30009bb0:	e00c      	b.n	30009bcc <mmc_sdhci_read+0xa0>
        if ((status & MMC_READY_FOR_DATA) &&
30009bb2:	9b01      	ldr	r3, [sp, #4]
        udelay(1000);
30009bb4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
             (MMC_CARD_STATUS(status) == MMC_TRAN_STATE))
30009bb8:	f3c3 2143 	ubfx	r1, r3, #9, #4
        if ((status & MMC_READY_FOR_DATA) &&
30009bbc:	05db      	lsls	r3, r3, #23
30009bbe:	d501      	bpl.n	30009bc4 <mmc_sdhci_read+0x98>
30009bc0:	2904      	cmp	r1, #4
30009bc2:	d012      	beq.n	30009bea <mmc_sdhci_read+0xbe>
        udelay(1000);
30009bc4:	f00a fb14 	bl	300141f0 <spin>
        if (retry == MMC_MAX_CARD_STAT_RETRY) {
30009bc8:	3c01      	subs	r4, #1
30009bca:	d018      	beq.n	30009bfe <mmc_sdhci_read+0xd2>
        if (mmc_get_card_status(&dev->host, &dev->card, &status)) {
30009bcc:	4631      	mov	r1, r6
30009bce:	aa01      	add	r2, sp, #4
30009bd0:	4628      	mov	r0, r5
30009bd2:	f7fe fe13 	bl	300087fc <mmc_get_card_status.isra.4>
30009bd6:	4602      	mov	r2, r0
30009bd8:	2800      	cmp	r0, #0
30009bda:	d0ea      	beq.n	30009bb2 <mmc_sdhci_read+0x86>
            dprintf(CRITICAL, "Failed to get card status after read\n");
30009bdc:	f24d 40f0 	movw	r0, #54512	; 0xd4f0
30009be0:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009be4:	f00b ffe4 	bl	30015bb0 <_printf>
            return 1;
30009be8:	2201      	movs	r2, #1
}
30009bea:	4610      	mov	r0, r2
30009bec:	b015      	add	sp, #84	; 0x54
30009bee:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return mmc_stop_command(dev);
30009bf0:	4628      	mov	r0, r5
30009bf2:	f7fe ff5b 	bl	30008aac <mmc_stop_command>
30009bf6:	4602      	mov	r2, r0
}
30009bf8:	4610      	mov	r0, r2
30009bfa:	b015      	add	sp, #84	; 0x54
30009bfc:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dprintf(
30009bfe:	f24d 5018 	movw	r0, #54552	; 0xd518
30009c02:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009c06:	f00b ffd3 	bl	30015bb0 <_printf>
            return 1;
30009c0a:	2201      	movs	r2, #1
30009c0c:	e7ed      	b.n	30009bea <mmc_sdhci_read+0xbe>
30009c0e:	bf00      	nop

30009c10 <mmc_sdhci_write>:
{
30009c10:	b5f0      	push	{r4, r5, r6, r7, r14}
30009c12:	4605      	mov	r5, r0
30009c14:	b095      	sub	sp, #84	; 0x54
30009c16:	460f      	mov	r7, r1
30009c18:	4614      	mov	r4, r2
    memset(&cmd, 0, sizeof(struct mmc_command));
30009c1a:	2100      	movs	r1, #0
30009c1c:	a802      	add	r0, sp, #8
{
30009c1e:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    memset(&cmd, 0, sizeof(struct mmc_command));
30009c20:	2248      	movs	r2, #72	; 0x48
30009c22:	f00a eea6 	blx	30014970 <memset>
    if (num_blocks == 1)
30009c26:	2e01      	cmp	r6, #1
        cmd.cmd_index = CMD24_WRITE_SINGLE_BLOCK;
30009c28:	bf0c      	ite	eq
30009c2a:	2318      	moveq	r3, #24
        cmd.cmd_index = CMD25_WRITE_MULTIPLE_BLOCK;
30009c2c:	2319      	movne	r3, #25
30009c2e:	f8ad 3008 	strh.w	r3, [r13, #8]
    if (card->type == MMC_TYPE_STD_MMC)
30009c32:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
30009c36:	2b04      	cmp	r3, #4
30009c38:	d009      	beq.n	30009c4e <mmc_sdhci_write+0x3e>
        cmd.argument = blk_addr;
30009c3a:	9403      	str	r4, [sp, #12]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009c3c:	2201      	movs	r2, #1
    if (MMC_CARD_SD(card))
30009c3e:	4293      	cmp	r3, r2
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009c40:	f8ad 2012 	strh.w	r2, [r13, #18]
    if (MMC_CARD_SD(card))
30009c44:	d80b      	bhi.n	30009c5e <mmc_sdhci_write+0x4e>
        cmd.cmd23_support = dev->card.scr.cmd23_support;
30009c46:	f8d5 3198 	ldr.w	r3, [r5, #408]	; 0x198
30009c4a:	930b      	str	r3, [sp, #44]	; 0x2c
30009c4c:	e009      	b.n	30009c62 <mmc_sdhci_write+0x52>
        cmd.argument = blk_addr * card->block_size;
30009c4e:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009c52:	2201      	movs	r2, #1
30009c54:	f8ad 2012 	strh.w	r2, [r13, #18]
        cmd.argument = blk_addr * card->block_size;
30009c58:	fb04 f403 	mul.w	r4, r4, r3
30009c5c:	9403      	str	r4, [sp, #12]
        cmd.cmd23_support = 0x1;
30009c5e:	2301      	movs	r3, #1
30009c60:	930b      	str	r3, [sp, #44]	; 0x2c
    cmd.data_present = 0x1;
30009c62:	2401      	movs	r4, #1
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30009c64:	a902      	add	r1, sp, #8
    cmd.data.data_ptr = src;
30009c66:	9710      	str	r7, [sp, #64]	; 0x40
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30009c68:	4628      	mov	r0, r5
    cmd.data.num_blocks = num_blocks;
30009c6a:	9613      	str	r6, [sp, #76]	; 0x4c
    cmd.data_present = 0x1;
30009c6c:	f88d 4010 	strb.w	r4, [r13, #16]
    mmc_ret = sdhci_send_command(&dev->host, &cmd);
30009c70:	f7fe f94c 	bl	30007f0c <sdhci_send_command>
    if (mmc_ret && num_blocks > 1) {
30009c74:	2800      	cmp	r0, #0
30009c76:	bf18      	it	ne
30009c78:	42a6      	cmpne	r6, r4
30009c7a:	d828      	bhi.n	30009cce <mmc_sdhci_write+0xbe>
    if(mmc_parse_response(cmd.resp[0]))
30009c7c:	9805      	ldr	r0, [sp, #20]
30009c7e:	f7fe fecb 	bl	30008a18 <mmc_parse_response>
        return 1;
30009c82:	4623      	mov	r3, r4
    if(mmc_parse_response(cmd.resp[0]))
30009c84:	bb00      	cbnz	r0, 30009cc8 <mmc_sdhci_write+0xb8>
30009c86:	f242 7410 	movw	r4, #10000	; 0x2710
30009c8a:	f105 06e8 	add.w	r6, r5, #232	; 0xe8
30009c8e:	e00c      	b.n	30009caa <mmc_sdhci_write+0x9a>
        if ((status & MMC_READY_FOR_DATA) &&
30009c90:	9a01      	ldr	r2, [sp, #4]
        udelay(1000);
30009c92:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
             (MMC_CARD_STATUS(status) == MMC_TRAN_STATE))
30009c96:	f3c2 2143 	ubfx	r1, r2, #9, #4
        if ((status & MMC_READY_FOR_DATA) &&
30009c9a:	05d2      	lsls	r2, r2, #23
30009c9c:	d501      	bpl.n	30009ca2 <mmc_sdhci_write+0x92>
30009c9e:	2904      	cmp	r1, #4
30009ca0:	d012      	beq.n	30009cc8 <mmc_sdhci_write+0xb8>
        udelay(1000);
30009ca2:	f00a faa5 	bl	300141f0 <spin>
        if (retry == MMC_MAX_CARD_STAT_RETRY) {
30009ca6:	3c01      	subs	r4, #1
30009ca8:	d018      	beq.n	30009cdc <mmc_sdhci_write+0xcc>
        if (mmc_get_card_status(&dev->host, &dev->card, &status)) {
30009caa:	4631      	mov	r1, r6
30009cac:	aa01      	add	r2, sp, #4
30009cae:	4628      	mov	r0, r5
30009cb0:	f7fe fda4 	bl	300087fc <mmc_get_card_status.isra.4>
30009cb4:	4603      	mov	r3, r0
30009cb6:	2800      	cmp	r0, #0
30009cb8:	d0ea      	beq.n	30009c90 <mmc_sdhci_write+0x80>
            dprintf(CRITICAL, "Failed to get card status after write\n");
30009cba:	f24d 5078 	movw	r0, #54648	; 0xd578
30009cbe:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009cc2:	f00b ff75 	bl	30015bb0 <_printf>
            return 1;
30009cc6:	2301      	movs	r3, #1
}
30009cc8:	4618      	mov	r0, r3
30009cca:	b015      	add	sp, #84	; 0x54
30009ccc:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return mmc_stop_command(dev);
30009cce:	4628      	mov	r0, r5
30009cd0:	f7fe feec 	bl	30008aac <mmc_stop_command>
30009cd4:	4603      	mov	r3, r0
}
30009cd6:	4618      	mov	r0, r3
30009cd8:	b015      	add	sp, #84	; 0x54
30009cda:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dprintf(
30009cdc:	f24d 50a0 	movw	r0, #54688	; 0xd5a0
30009ce0:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009ce4:	f00b ff64 	bl	30015bb0 <_printf>
            return 1;
30009ce8:	2301      	movs	r3, #1
30009cea:	e7ed      	b.n	30009cc8 <mmc_sdhci_write+0xb8>

30009cec <mmc_sdhci_erase>:
{
30009cec:	0a52      	lsrs	r2, r2, #9
30009cee:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (MMC_CARD_MMC(card)) {
30009cf2:	f8d0 a100 	ldr.w	r10, [r0, #256]	; 0x100
{
30009cf6:	b097      	sub	sp, #92	; 0x5c
30009cf8:	4606      	mov	r6, r0
30009cfa:	ea42 52c3 	orr.w	r2, r2, r3, lsl #23
30009cfe:	4688      	mov	r8, r1
30009d00:	0a5b      	lsrs	r3, r3, #9
30009d02:	9200      	str	r2, [sp, #0]
30009d04:	9301      	str	r3, [sp, #4]
    if (MMC_CARD_MMC(card)) {
30009d06:	f1aa 0303 	sub.w	r3, r10, #3
30009d0a:	2b01      	cmp	r3, #1
30009d0c:	f240 80c8 	bls.w	30009ea0 <mmc_sdhci_erase+0x1b4>
        erase_unit_sz = dev->card.ssr.au_size * dev->card.ssr.num_aus;
30009d10:	f8d0 319c 	ldr.w	r3, [r0, #412]	; 0x19c
30009d14:	f8d0 71a0 	ldr.w	r7, [r0, #416]	; 0x1a0
    if (len < erase_unit_sz) {
30009d18:	e9dd 0100 	ldrd	r0, r1, [r13]
        erase_unit_sz = dev->card.ssr.au_size * dev->card.ssr.num_aus;
30009d1c:	fb07 f703 	mul.w	r7, r7, r3
    if (len < erase_unit_sz) {
30009d20:	2300      	movs	r3, #0
30009d22:	463a      	mov	r2, r7
30009d24:	4299      	cmp	r1, r3
30009d26:	bf08      	it	eq
30009d28:	42b8      	cmpeq	r0, r7
30009d2a:	f0c0 80ca 	bcc.w	30009ec2 <mmc_sdhci_erase+0x1d6>
    num_erase_grps = len / erase_unit_sz;
30009d2e:	e9dd ab00 	ldrd	r10, r11, [r13]
        erase_end = blk_addr + len - 1;
30009d32:	f108 35ff 	add.w	r5, r8, #4294967295	; 0xffffffff
    num_erase_grps = len / erase_unit_sz;
30009d36:	4650      	mov	r0, r10
30009d38:	4659      	mov	r1, r11
30009d3a:	f010 f871 	bl	30019e20 <__aeabi_uldivmod>
        erase_end = blk_addr + len - 1;
30009d3e:	4653      	mov	r3, r10
30009d40:	4455      	add	r5, r10
    blk_end = blk_addr + len;
30009d42:	4443      	add	r3, r8
    if (erase_end > blk_end) {
30009d44:	42ab      	cmp	r3, r5
    num_erase_grps = len / erase_unit_sz;
30009d46:	4681      	mov	r9, r0
    if (erase_end > blk_end) {
30009d48:	f0c0 80d7 	bcc.w	30009efa <mmc_sdhci_erase+0x20e>
    memset(&cmd, 0, sizeof(struct mmc_command));
30009d4c:	2246      	movs	r2, #70	; 0x46
30009d4e:	2100      	movs	r1, #0
30009d50:	f10d 0012 	add.w	r0, r13, #18
30009d54:	f00a ee0c 	blx	30014970 <memset>
30009d58:	ac04      	add	r4, sp, #16
        cmd.cmd_index = CMD32_ERASE_WR_BLK_START;
30009d5a:	2320      	movs	r3, #32
30009d5c:	f8ad 3010 	strh.w	r3, [r13, #16]
        cmd.argument = erase_start;
30009d60:	f8cd 8014 	str.w	r8, [r13, #20]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009d64:	2301      	movs	r3, #1
    if (sdhci_send_command(&dev->host, &cmd))
30009d66:	4621      	mov	r1, r4
30009d68:	4630      	mov	r0, r6
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009d6a:	f8ad 301a 	strh.w	r3, [r13, #26]
    if (sdhci_send_command(&dev->host, &cmd))
30009d6e:	f7fe f8cd 	bl	30007f0c <sdhci_send_command>
30009d72:	2800      	cmp	r0, #0
30009d74:	f040 80b6 	bne.w	30009ee4 <mmc_sdhci_erase+0x1f8>
    if (MMC_ADDR_OUT_OF_RANGE(cmd.resp[0])) {
30009d78:	9b07      	ldr	r3, [sp, #28]
30009d7a:	2b00      	cmp	r3, #0
30009d7c:	f2c0 80ac 	blt.w	30009ed8 <mmc_sdhci_erase+0x1ec>
    memset(&cmd, 0, sizeof(struct mmc_command));
30009d80:	4601      	mov	r1, r0
30009d82:	2248      	movs	r2, #72	; 0x48
30009d84:	4620      	mov	r0, r4
30009d86:	f00a edf4 	blx	30014970 <memset>
    if (MMC_CARD_MMC(card))
30009d8a:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
30009d8e:	1eda      	subs	r2, r3, #3
30009d90:	2a01      	cmp	r2, #1
        cmd.cmd_index = CMD33_ERASE_WR_BLK_END;
30009d92:	bf84      	itt	hi
30009d94:	2321      	movhi	r3, #33	; 0x21
30009d96:	f8ad 3010 	strhhi.w	r3, [r13, #16]
    if (MMC_CARD_MMC(card))
30009d9a:	f240 8117 	bls.w	30009fcc <mmc_sdhci_erase+0x2e0>
        cmd.argument = erase_end;
30009d9e:	9505      	str	r5, [sp, #20]
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009da0:	2301      	movs	r3, #1
    if (sdhci_send_command(&dev->host, &cmd))
30009da2:	4621      	mov	r1, r4
30009da4:	4630      	mov	r0, r6
    cmd.resp_type = SDHCI_CMD_RESP_R1;
30009da6:	f8ad 301a 	strh.w	r3, [r13, #26]
    if (sdhci_send_command(&dev->host, &cmd))
30009daa:	f7fe f8af 	bl	30007f0c <sdhci_send_command>
30009dae:	2800      	cmp	r0, #0
30009db0:	f040 80fd 	bne.w	30009fae <mmc_sdhci_erase+0x2c2>
    if (MMC_ADDR_OUT_OF_RANGE(cmd.resp[0])) {
30009db4:	9b07      	ldr	r3, [sp, #28]
30009db6:	2b00      	cmp	r3, #0
30009db8:	f2c0 80f3 	blt.w	30009fa2 <mmc_sdhci_erase+0x2b6>
    if (MMC_CARD_MMC(card)) {
30009dbc:	f8d6 3100 	ldr.w	r3, [r6, #256]	; 0x100
30009dc0:	3b03      	subs	r3, #3
30009dc2:	2b01      	cmp	r3, #1
30009dc4:	f240 80de 	bls.w	30009f84 <mmc_sdhci_erase+0x298>
            card->ssr.erase_timeout * num_erase_grps + card->ssr.erase_offset;
30009dc8:	f8d6 21a4 	ldr.w	r2, [r6, #420]	; 0x1a4
30009dcc:	f8d6 31a8 	ldr.w	r3, [r6, #424]	; 0x1a8
        erase_timeout = MAX(erase_timeout, 1);
30009dd0:	fb02 3309 	mla	r3, r2, r9, r3
30009dd4:	e9cd 3000 	strd	r3, r0, [r13]
30009dd8:	e9dd 2300 	ldrd	r2, r3, [r13]
30009ddc:	4313      	orrs	r3, r2
30009dde:	d103      	bne.n	30009de8 <mmc_sdhci_erase+0xfc>
30009de0:	2201      	movs	r2, #1
30009de2:	2300      	movs	r3, #0
30009de4:	e9cd 2300 	strd	r2, r3, [r13]
        erase_timeout *= 1000 * 1000;
30009de8:	e9dd ab00 	ldrd	r10, r11, [r13]
30009dec:	4650      	mov	r0, r10
30009dee:	4659      	mov	r1, r11
30009df0:	0142      	lsls	r2, r0, #5
30009df2:	0149      	lsls	r1, r1, #5
30009df4:	ebb2 080a 	subs.w	r8, r2, r10
30009df8:	ea41 63da 	orr.w	r3, r1, r10, lsr #27
30009dfc:	eb63 090b 	sbc.w	r9, r3, r11
30009e00:	ea4f 2748 	mov.w	r7, r8, lsl #9
30009e04:	ea4f 2549 	mov.w	r5, r9, lsl #9
30009e08:	eb1a 0207 	adds.w	r2, r10, r7
30009e0c:	ea45 55d8 	orr.w	r5, r5, r8, lsr #23
30009e10:	eb4b 0305 	adc.w	r3, r11, r5
30009e14:	e9dd ab00 	ldrd	r10, r11, [r13]
30009e18:	0190      	lsls	r0, r2, #6
30009e1a:	0199      	lsls	r1, r3, #6
30009e1c:	1a80      	subs	r0, r0, r2
30009e1e:	ea41 6192 	orr.w	r1, r1, r2, lsr #26
30009e22:	eb61 0103 	sbc.w	r1, r1, r3
30009e26:	eb1a 0a00 	adds.w	r10, r10, r0
30009e2a:	eb4b 0b01 	adc.w	r11, r11, r1
    memset(&cmd, 0, sizeof(struct mmc_command));
30009e2e:	2246      	movs	r2, #70	; 0x46
30009e30:	2100      	movs	r1, #0
30009e32:	f10d 0012 	add.w	r0, r13, #18
30009e36:	f00a ed9c 	blx	30014970 <memset>
    cmd.cmd_index = CMD38_ERASE;
30009e3a:	2226      	movs	r2, #38	; 0x26
    cmd.resp_type = SDHCI_CMD_RESP_R1B;
30009e3c:	2302      	movs	r3, #2
    if (sdhci_send_command(&dev->host, &cmd))
30009e3e:	4621      	mov	r1, r4
    cmd.cmd_timeout = erase_timeout;
30009e40:	e9cd ab0e 	strd	r10, r11, [r13, #56]	; 0x38
    if (sdhci_send_command(&dev->host, &cmd))
30009e44:	4630      	mov	r0, r6
    cmd.cmd_index = CMD38_ERASE;
30009e46:	f8ad 2010 	strh.w	r2, [r13, #16]
    cmd.resp_type = SDHCI_CMD_RESP_R1B;
30009e4a:	f8ad 301a 	strh.w	r3, [r13, #26]
    if (sdhci_send_command(&dev->host, &cmd))
30009e4e:	f7fe f85d 	bl	30007f0c <sdhci_send_command>
30009e52:	2800      	cmp	r0, #0
30009e54:	f040 80cc 	bne.w	30009ff0 <mmc_sdhci_erase+0x304>
            dprintf(CRITICAL, "Write Protect set for the region, only partial "
30009e58:	f24d 08d4 	movw	r8, #53460	; 0xd0d4
30009e5c:	f106 07e8 	add.w	r7, r6, #232	; 0xe8
    if (sdhci_send_command(&dev->host, &cmd))
30009e60:	f242 7510 	movw	r5, #10000	; 0x2710
            dprintf(CRITICAL, "Write Protect set for the region, only partial "
30009e64:	f2c3 0801 	movt	r8, #12289	; 0x3001
        if (mmc_get_card_status(&dev->host, &dev->card, &status)) {
30009e68:	4639      	mov	r1, r7
30009e6a:	aa03      	add	r2, sp, #12
30009e6c:	4630      	mov	r0, r6
30009e6e:	f7fe fcc5 	bl	300087fc <mmc_get_card_status.isra.4>
30009e72:	4604      	mov	r4, r0
30009e74:	2800      	cmp	r0, #0
30009e76:	f040 80b5 	bne.w	30009fe4 <mmc_sdhci_erase+0x2f8>
        if (status & MMC_R1_WP_ERASE_SKIP)
30009e7a:	9b03      	ldr	r3, [sp, #12]
30009e7c:	041a      	lsls	r2, r3, #16
30009e7e:	f100 80a1 	bmi.w	30009fc4 <mmc_sdhci_erase+0x2d8>
        udelay(1000);
30009e82:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
30009e86:	f00a f9b3 	bl	300141f0 <spin>
        if (retry == MMC_MAX_CARD_STAT_RETRY) {
30009e8a:	3d01      	subs	r5, #1
30009e8c:	f000 80b8 	beq.w	3000a000 <mmc_sdhci_erase+0x314>
    } while (!(status & MMC_READY_FOR_DATA) ||
30009e90:	9b03      	ldr	r3, [sp, #12]
             (MMC_CARD_STATUS(status) == MMC_PROG_STATE));
30009e92:	f3c3 2243 	ubfx	r2, r3, #9, #4
30009e96:	05db      	lsls	r3, r3, #23
30009e98:	d5e6      	bpl.n	30009e68 <mmc_sdhci_erase+0x17c>
    } while (!(status & MMC_READY_FOR_DATA) ||
30009e9a:	2a07      	cmp	r2, #7
30009e9c:	d0e4      	beq.n	30009e68 <mmc_sdhci_erase+0x17c>
30009e9e:	e017      	b.n	30009ed0 <mmc_sdhci_erase+0x1e4>
        if (dev->card.ext_csd[MMC_ERASE_GRP_DEF])
30009ea0:	f8d0 3108 	ldr.w	r3, [r0, #264]	; 0x108
30009ea4:	f893 20af 	ldrb.w	r2, [r3, #175]	; 0xaf
30009ea8:	2a00      	cmp	r2, #0
30009eaa:	d047      	beq.n	30009f3c <mmc_sdhci_erase+0x250>
                (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) /
30009eac:	f893 70e0 	ldrb.w	r7, [r3, #224]	; 0xe0
    if (len < erase_unit_sz) {
30009eb0:	e9dd 0100 	ldrd	r0, r1, [r13]
                (MMC_HC_ERASE_MULT * dev->card.ext_csd[MMC_HC_ERASE_GRP_SIZE]) /
30009eb4:	02bf      	lsls	r7, r7, #10
    if (len < erase_unit_sz) {
30009eb6:	463a      	mov	r2, r7
30009eb8:	17fb      	asrs	r3, r7, #31
30009eba:	4299      	cmp	r1, r3
30009ebc:	bf08      	it	eq
30009ebe:	42b8      	cmpeq	r0, r7
30009ec0:	d24c      	bcs.n	30009f5c <mmc_sdhci_erase+0x270>
        dprintf(CRITICAL,
30009ec2:	f64c 70a8 	movw	r0, #53160	; 0xcfa8
        return 1;
30009ec6:	2401      	movs	r4, #1
        dprintf(CRITICAL,
30009ec8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009ecc:	f00b fe70 	bl	30015bb0 <_printf>
}
30009ed0:	4620      	mov	r0, r4
30009ed2:	b017      	add	sp, #92	; 0x5c
30009ed4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "Address for CMD35 is out of range\n");
30009ed8:	f24d 0014 	movw	r0, #53268	; 0xd014
30009edc:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009ee0:	f00b fe66 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "Failed to send erase grp start address\n");
30009ee4:	f24d 0038 	movw	r0, #53304	; 0xd038
        return 1;
30009ee8:	2401      	movs	r4, #1
        dprintf(CRITICAL, "Failed to send erase grp start address\n");
30009eea:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009eee:	f00b fe5f 	bl	30015bb0 <_printf>
}
30009ef2:	4620      	mov	r0, r4
30009ef4:	b017      	add	sp, #92	; 0x5c
30009ef6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL,
30009efa:	f64c 70dc 	movw	r0, #53212	; 0xcfdc
    memset(&cmd, 0, sizeof(struct mmc_command));
30009efe:	ac04      	add	r4, sp, #16
        dprintf(CRITICAL,
30009f00:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009f04:	f00b fe54 	bl	30015bb0 <_printf>
30009f08:	f8d6 a100 	ldr.w	r10, [r6, #256]	; 0x100
    memset(&cmd, 0, sizeof(struct mmc_command));
30009f0c:	4620      	mov	r0, r4
30009f0e:	2248      	movs	r2, #72	; 0x48
30009f10:	2100      	movs	r1, #0
        erase_end -= erase_unit_sz;
30009f12:	1bed      	subs	r5, r5, r7
    memset(&cmd, 0, sizeof(struct mmc_command));
30009f14:	f00a ed2c 	blx	30014970 <memset>
    if (MMC_CARD_MMC(card))
30009f18:	f1aa 0303 	sub.w	r3, r10, #3
30009f1c:	2b01      	cmp	r3, #1
30009f1e:	f63f af1c 	bhi.w	30009d5a <mmc_sdhci_erase+0x6e>
        cmd.cmd_index = CMD35_ERASE_GROUP_START;
30009f22:	2323      	movs	r3, #35	; 0x23
    if (card->type == MMC_TYPE_STD_MMC)
30009f24:	f1ba 0f04 	cmp.w	r10, #4
        cmd.cmd_index = CMD35_ERASE_GROUP_START;
30009f28:	f8ad 3010 	strh.w	r3, [r13, #16]
    if (card->type == MMC_TYPE_STD_MMC)
30009f2c:	f47f af18 	bne.w	30009d60 <mmc_sdhci_erase+0x74>
        cmd.argument = erase_start * card->block_size;
30009f30:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
30009f34:	fb08 f303 	mul.w	r3, r8, r3
30009f38:	9305      	str	r3, [sp, #20]
30009f3a:	e713      	b.n	30009d64 <mmc_sdhci_erase+0x78>
            erase_unit_sz = (dev->card.csd.erase_grp_size + 1) *
30009f3c:	f8d0 317c 	ldr.w	r3, [r0, #380]	; 0x17c
                            (dev->card.csd.erase_grp_mult + 1);
30009f40:	f8d0 7180 	ldr.w	r7, [r0, #384]	; 0x180
    if (len < erase_unit_sz) {
30009f44:	e9dd 0100 	ldrd	r0, r1, [r13]
            erase_unit_sz = (dev->card.csd.erase_grp_size + 1) *
30009f48:	3301      	adds	r3, #1
                            (dev->card.csd.erase_grp_mult + 1);
30009f4a:	3701      	adds	r7, #1
            erase_unit_sz = (dev->card.csd.erase_grp_size + 1) *
30009f4c:	fb07 f703 	mul.w	r7, r7, r3
    if (len < erase_unit_sz) {
30009f50:	2300      	movs	r3, #0
30009f52:	463a      	mov	r2, r7
30009f54:	4299      	cmp	r1, r3
30009f56:	bf08      	it	eq
30009f58:	42b8      	cmpeq	r0, r7
30009f5a:	d3b2      	bcc.n	30009ec2 <mmc_sdhci_erase+0x1d6>
    num_erase_grps = len / erase_unit_sz;
30009f5c:	e9dd 0100 	ldrd	r0, r1, [r13]
30009f60:	f00f ff5e 	bl	30019e20 <__aeabi_uldivmod>
    blk_end = blk_addr + len;
30009f64:	9b00      	ldr	r3, [sp, #0]
30009f66:	4443      	add	r3, r8
    num_erase_grps = len / erase_unit_sz;
30009f68:	4681      	mov	r9, r0
        erase_end = blk_addr + ((num_erase_grps - 1) * erase_unit_sz);
30009f6a:	1e45      	subs	r5, r0, #1
30009f6c:	fb07 8505 	mla	r5, r7, r5, r8
    if (erase_end > blk_end) {
30009f70:	429d      	cmp	r5, r3
30009f72:	d8c2      	bhi.n	30009efa <mmc_sdhci_erase+0x20e>
    memset(&cmd, 0, sizeof(struct mmc_command));
30009f74:	2246      	movs	r2, #70	; 0x46
30009f76:	2100      	movs	r1, #0
30009f78:	f10d 0012 	add.w	r0, r13, #18
30009f7c:	f00a ecf8 	blx	30014970 <memset>
30009f80:	ac04      	add	r4, sp, #16
30009f82:	e7ce      	b.n	30009f22 <mmc_sdhci_erase+0x236>
        erase_timeout = (300 * 1000 * card->ext_csd[MMC_ERASE_TIMEOUT_MULT] *
30009f84:	f249 33e0 	movw	r3, #37856	; 0x93e0
30009f88:	f04f 0b00 	mov.w	r11, #0
30009f8c:	f8d6 2108 	ldr.w	r2, [r6, #264]	; 0x108
30009f90:	f2c0 0304 	movt	r3, #4
30009f94:	f892 a0df 	ldrb.w	r10, [r2, #223]	; 0xdf
30009f98:	fb03 fa0a 	mul.w	r10, r3, r10
30009f9c:	fb09 fa0a 	mul.w	r10, r9, r10
30009fa0:	e745      	b.n	30009e2e <mmc_sdhci_erase+0x142>
        dprintf(CRITICAL, "Address for CMD36 is out of range\n");
30009fa2:	f24d 0060 	movw	r0, #53344	; 0xd060
30009fa6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009faa:	f00b fe01 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "Failed to send erase grp end address\n");
30009fae:	f24d 0084 	movw	r0, #53380	; 0xd084
        return 1;
30009fb2:	2401      	movs	r4, #1
        dprintf(CRITICAL, "Failed to send erase grp end address\n");
30009fb4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009fb8:	f00b fdfa 	bl	30015bb0 <_printf>
}
30009fbc:	4620      	mov	r0, r4
30009fbe:	b017      	add	sp, #92	; 0x5c
30009fc0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            dprintf(CRITICAL, "Write Protect set for the region, only partial "
30009fc4:	4640      	mov	r0, r8
30009fc6:	f00b fdf3 	bl	30015bb0 <_printf>
30009fca:	e75a      	b.n	30009e82 <mmc_sdhci_erase+0x196>
        cmd.cmd_index = CMD36_ERASE_GROUP_END;
30009fcc:	2224      	movs	r2, #36	; 0x24
    if (card->type == MMC_TYPE_STD_MMC)
30009fce:	2b04      	cmp	r3, #4
        cmd.cmd_index = CMD36_ERASE_GROUP_END;
30009fd0:	f8ad 2010 	strh.w	r2, [r13, #16]
    if (card->type == MMC_TYPE_STD_MMC)
30009fd4:	f47f aee3 	bne.w	30009d9e <mmc_sdhci_erase+0xb2>
        cmd.argument = erase_end * card->block_size;
30009fd8:	f8d6 30f0 	ldr.w	r3, [r6, #240]	; 0xf0
30009fdc:	fb05 f503 	mul.w	r5, r5, r3
30009fe0:	9505      	str	r5, [sp, #20]
30009fe2:	e6dd      	b.n	30009da0 <mmc_sdhci_erase+0xb4>
            dprintf(CRITICAL, "Failed to get card status after erase\n");
30009fe4:	f24d 00ac 	movw	r0, #53420	; 0xd0ac
30009fe8:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009fec:	f00b fde0 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "Failed to erase the specified partition\n");
30009ff0:	f24d 1054 	movw	r0, #53588	; 0xd154
        return 1;
30009ff4:	2401      	movs	r4, #1
        dprintf(CRITICAL, "Failed to erase the specified partition\n");
30009ff6:	f2c3 0001 	movt	r0, #12289	; 0x3001
30009ffa:	f00b fdd9 	bl	30015bb0 <_printf>
        return 1;
30009ffe:	e767      	b.n	30009ed0 <mmc_sdhci_erase+0x1e4>
            dprintf(
3000a000:	f24d 1018 	movw	r0, #53528	; 0xd118
3000a004:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000a008:	f00b fdd2 	bl	30015bb0 <_printf>
3000a00c:	e7f0      	b.n	30009ff0 <mmc_sdhci_erase+0x304>
3000a00e:	bf00      	nop

3000a010 <mmc_sdhci_switch_part>:
    if (!MMC_CARD_MMC(card))
3000a010:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
3000a014:	3b03      	subs	r3, #3
3000a016:	2b01      	cmp	r3, #1
3000a018:	d901      	bls.n	3000a01e <mmc_sdhci_switch_part+0xe>
}
3000a01a:	2001      	movs	r0, #1
3000a01c:	4770      	bx	r14
3000a01e:	f7fe bdff 	b.w	30008c20 <mmc_sdhci_switch_part.part.16>
3000a022:	bf00      	nop

3000a024 <scr_write_signal.isra.4>:
        DBG("Can not get handle for %s\n", signal->name);
        return false;
    }
}

static bool scr_write_signal(const struct scr_signal *signal, uint32_t val)
3000a024:	b570      	push	{r4, r5, r6, r14}
3000a026:	4616      	mov	r6, r2
{
    scr_handle_t handle;

    handle = hal_scr_create_handle(signal->signal);
3000a028:	f005 fee4 	bl	3000fdf4 <hal_scr_create_handle>
3000a02c:	4604      	mov	r4, r0
3000a02e:	460d      	mov	r5, r1

    if (handle) {
3000a030:	ea54 0305 	orrs.w	r3, r4, r5
        hal_scr_delete_handle(handle);
        return ret;
    }
    else {
        DBG("Can not get handle for %s\n", signal->name);
        return false;
3000a034:	bf08      	it	eq
3000a036:	2600      	moveq	r6, #0
    if (handle) {
3000a038:	d007      	beq.n	3000a04a <scr_write_signal.isra.4+0x26>
        bool ret = hal_scr_set(handle, val);
3000a03a:	4632      	mov	r2, r6
3000a03c:	f005 ff0c 	bl	3000fe58 <hal_scr_set>
        hal_scr_delete_handle(handle);
3000a040:	4629      	mov	r1, r5
        bool ret = hal_scr_set(handle, val);
3000a042:	4606      	mov	r6, r0
        hal_scr_delete_handle(handle);
3000a044:	4620      	mov	r0, r4
3000a046:	f005 fed7 	bl	3000fdf8 <hal_scr_delete_handle>
    }
}
3000a04a:	4630      	mov	r0, r6
3000a04c:	bd70      	pop	{r4, r5, r6, r15}
3000a04e:	bf00      	nop

3000a050 <scr_read_signal.isra.5>:
static bool scr_read_signal(const struct scr_signal *signal, uint32_t *val)
3000a050:	b570      	push	{r4, r5, r6, r14}
3000a052:	4616      	mov	r6, r2
    handle = hal_scr_create_handle(signal->signal);
3000a054:	f005 fece 	bl	3000fdf4 <hal_scr_create_handle>
3000a058:	4604      	mov	r4, r0
3000a05a:	460d      	mov	r5, r1
    if (handle) {
3000a05c:	ea54 0305 	orrs.w	r3, r4, r5
        return false;
3000a060:	bf08      	it	eq
3000a062:	2000      	moveq	r0, #0
    if (handle) {
3000a064:	d100      	bne.n	3000a068 <scr_read_signal.isra.5+0x18>
}
3000a066:	bd70      	pop	{r4, r5, r6, r15}
        *val = hal_scr_get(handle);
3000a068:	f005 fede 	bl	3000fe28 <hal_scr_get>
        hal_scr_delete_handle(handle);
3000a06c:	4629      	mov	r1, r5
        *val = hal_scr_get(handle);
3000a06e:	6030      	str	r0, [r6, #0]
        hal_scr_delete_handle(handle);
3000a070:	4620      	mov	r0, r4
3000a072:	f005 fec1 	bl	3000fdf8 <hal_scr_delete_handle>
        return true;
3000a076:	2001      	movs	r0, #1
}
3000a078:	bd70      	pop	{r4, r5, r6, r15}
3000a07a:	bf00      	nop

3000a07c <Port_SetGPIOSCR>:
    uint32_t pin_num_internal = 0;
    DBG("Port_SetGPIOSCR: gpio_id[%d], pin_num[%d]\n", gpio_id, pin_num);

    /* safety GPIO CTRL base address index NOT follow PinList */
    pin_num_internal =  (((pin_num) <= 47) ? ((pin_num) >= 24 ? ((
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
3000a07c:	292f      	cmp	r1, #47	; 0x2f
{
3000a07e:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
3000a082:	4605      	mov	r5, r0
3000a084:	b084      	sub	sp, #16
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
3000a086:	d84e      	bhi.n	3000a126 <Port_SetGPIOSCR+0xaa>
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
3000a088:	f64d 2630 	movw	r6, #55856	; 0xda30
                             pin_num) - 24) : ((pin_num) + 24)) : (pin_num));
3000a08c:	2917      	cmp	r1, #23
3000a08e:	bf8c      	ite	hi
3000a090:	f1a1 0418 	subhi.w	r4, r1, #24
3000a094:	f101 0418 	addls.w	r4, r1, #24
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
3000a098:	f2c3 0601 	movt	r6, #12289	; 0x3001
    uint32_t sigReg_id_mux1 = pin_num / 16;
3000a09c:	0923      	lsrs	r3, r4, #4
3000a09e:	2701      	movs	r7, #1
    scr_read_signal(signal_mux1, &val1_mux1);
3000a0a0:	aa02      	add	r2, sp, #8
    const struct scr_signal *signal_mux1 = &scr_safety_mux1_signals[sigReg_id_mux1];
3000a0a2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3000a0a6:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
    scr_read_signal(signal_mux1, &val1_mux1);
3000a0aa:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
3000a0ae:	f7ff ffcf 	bl	3000a050 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
3000a0b2:	2d01      	cmp	r5, #1
3000a0b4:	f004 020f 	and.w	r2, r4, #15
3000a0b8:	fa07 f702 	lsl.w	r7, r7, r2
3000a0bc:	d053      	beq.n	3000a166 <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
3000a0be:	f64d 2878 	movw	r8, #55928	; 0xda78
    uint32_t sigReg_id = pin_num / 8;
3000a0c2:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
3000a0c4:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_safety_mux_signals[sigReg_id];
3000a0c6:	f2c3 0801 	movt	r8, #12289	; 0x3001
3000a0ca:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3000a0ce:	eb08 08c3 	add.w	r8, r8, r3, lsl #3
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
3000a0d2:	3d02      	subs	r5, #2
        scr_read_signal(signal, &val1);
3000a0d4:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
3000a0d8:	f7ff ffba 	bl	3000a050 <scr_read_signal.isra.5>
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
3000a0dc:	2003      	movs	r0, #3
3000a0de:	9b00      	ldr	r3, [sp, #0]
3000a0e0:	f004 0107 	and.w	r1, r4, #7
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
3000a0e4:	9a02      	ldr	r2, [sp, #8]
        val1 &= (~ (uint32_t)(0x3 << ((pin_num % 8) * 2))); /* set to 0 */
3000a0e6:	0049      	lsls	r1, r1, #1
3000a0e8:	4088      	lsls	r0, r1
3000a0ea:	ea23 0300 	bic.w	r3, r3, r0
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
3000a0ee:	408d      	lsls	r5, r1
3000a0f0:	431d      	orrs	r5, r3
        scr_write_signal(signal, val1);
3000a0f2:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
3000a0f6:	4317      	orrs	r7, r2
        val1 |= (uint32_t)((gpio_id - 2) << ((pin_num % 8 ) * 2)); /* set mux val */
3000a0f8:	9500      	str	r5, [sp, #0]
        scr_write_signal(signal, val1);
3000a0fa:	462a      	mov	r2, r5
        val1_mux1 |= (uint32_t)(0x1 << (pin_num % 16)); /* set to 0x1 */
3000a0fc:	9702      	str	r7, [sp, #8]
        scr_write_signal(signal, val1);
3000a0fe:	f7ff ff91 	bl	3000a024 <scr_write_signal.isra.4>
        scr_read_signal(signal, &val2);
3000a102:	e9d8 0102 	ldrd	r0, r1, [r8, #8]
3000a106:	aa01      	add	r2, sp, #4
3000a108:	f7ff ffa2 	bl	3000a050 <scr_read_signal.isra.5>
3000a10c:	9a02      	ldr	r2, [sp, #8]
    scr_write_signal(signal_mux1, val1_mux1);
3000a10e:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
3000a112:	f7ff ff87 	bl	3000a024 <scr_write_signal.isra.4>
    scr_read_signal(signal_mux1, &val2_mux1);
3000a116:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
3000a11a:	aa03      	add	r2, sp, #12
3000a11c:	f7ff ff98 	bl	3000a050 <scr_read_signal.isra.5>
        Port_SetSecureGPIOSCR(gpio_id, pin_num_internal);
    }
    else {
        Port_SetSafetyGPIOSCR(gpio_id, pin_num_internal);
    }
}
3000a120:	b004      	add	sp, #16
3000a122:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    uint32_t tmpPinNum = pin_num - 48;
3000a126:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
3000a12a:	f64d 3108 	movw	r1, #56072	; 0xdb08
    scr_read_signal(signal_mux2, &val1_mux2);
3000a12e:	aa02      	add	r2, sp, #8
    sigReg_id_mux2 = tmpPinNum / 16;
3000a130:	0923      	lsrs	r3, r4, #4
3000a132:	2701      	movs	r7, #1
    const struct scr_signal *signal_mux2 = &scr_sec_mux2_signals[sigReg_id_mux2];
3000a134:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000a138:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3000a13c:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
    scr_read_signal(signal_mux2, &val1_mux2);
3000a140:	e9d6 0102 	ldrd	r0, r1, [r6, #8]
3000a144:	f7ff ff84 	bl	3000a050 <scr_read_signal.isra.5>
    if (1 == gpio_id) {
3000a148:	2d01      	cmp	r5, #1
3000a14a:	f004 020f 	and.w	r2, r4, #15
3000a14e:	fa07 f702 	lsl.w	r7, r7, r2
3000a152:	d008      	beq.n	3000a166 <Port_SetGPIOSCR+0xea>
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
3000a154:	f64d 38b0 	movw	r8, #56240	; 0xdbb0
    sigReg_id = tmpPinNum / 8;
3000a158:	08e3      	lsrs	r3, r4, #3
        scr_read_signal(signal, &val1);
3000a15a:	466a      	mov	r2, r13
        const struct scr_signal *signal = &scr_sec_mux_signals[sigReg_id];
3000a15c:	f2c3 0801 	movt	r8, #12289	; 0x3001
3000a160:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3000a164:	e7b3      	b.n	3000a0ce <Port_SetGPIOSCR+0x52>
        val1_mux1 &= (~ (uint32_t)(0x1 << (pin_num % 16))); /* set to 0 */
3000a166:	9a02      	ldr	r2, [sp, #8]
3000a168:	ea22 0207 	bic.w	r2, r2, r7
3000a16c:	9202      	str	r2, [sp, #8]
3000a16e:	e7ce      	b.n	3000a10e <Port_SetGPIOSCR+0x92>

3000a170 <Port_Init>:
    Port_kConfigPtr = ConfigPtr;
3000a170:	f247 5398 	movw	r3, #30104	; 0x7598
3000a174:	f240 1201 	movw	r2, #257	; 0x101
3000a178:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
3000a17c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    Port_kConfigPtr = ConfigPtr;
3000a180:	4619      	mov	r1, r3
{
3000a182:	b08b      	sub	sp, #44	; 0x2c
3000a184:	f64d 04f8 	movw	r4, #55544	; 0xd8f8
    Port_kConfigPtr = ConfigPtr;
3000a188:	f2c0 0214 	movt	r2, #20
3000a18c:	9307      	str	r3, [sp, #28]
3000a18e:	f2c3 0401 	movt	r4, #12289	; 0x3001
3000a192:	f44f 7380 	mov.w	r3, #256	; 0x100
3000a196:	f504 759c 	add.w	r5, r4, #312	; 0x138
3000a19a:	6008      	str	r0, [r1, #0]
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
        const struct scr_signal *signal = &scr_mshc2_canfd_signals[i];

        if (scr_read_signal(signal, &val1)) {
            scr_write_signal(signal,
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
3000a19c:	2601      	movs	r6, #1
3000a19e:	e004      	b.n	3000a1aa <Port_Init+0x3a>
3000a1a0:	3418      	adds	r4, #24
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
3000a1a2:	42a5      	cmp	r5, r4
3000a1a4:	d01a      	beq.n	3000a1dc <Port_Init+0x6c>
3000a1a6:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
        if (scr_read_signal(signal, &val1)) {
3000a1aa:	4610      	mov	r0, r2
3000a1ac:	4619      	mov	r1, r3
3000a1ae:	aa08      	add	r2, sp, #32
3000a1b0:	f7ff ff4e 	bl	3000a050 <scr_read_signal.isra.5>
3000a1b4:	2800      	cmp	r0, #0
3000a1b6:	d0f3      	beq.n	3000a1a0 <Port_Init+0x30>
    return (uint32_t)(scr_signal >> 8) & 0xff;
}

static inline uint32_t _scr_width(scr_signal_t scr_signal)
{
    return (uint32_t)scr_signal & 0xff;
3000a1b8:	7a23      	ldrb	r3, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
3000a1ba:	6922      	ldr	r2, [r4, #16]
3000a1bc:	fa06 f303 	lsl.w	r3, r6, r3
            scr_write_signal(signal,
3000a1c0:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
                             signal->val & BIT_MASK(_scr_width(signal->signal)));
3000a1c4:	3b01      	subs	r3, #1
            scr_write_signal(signal,
3000a1c6:	401a      	ands	r2, r3
3000a1c8:	f7ff ff2c 	bl	3000a024 <scr_write_signal.isra.4>
            scr_read_signal(signal, &val2);
3000a1cc:	e9d4 0102 	ldrd	r0, r1, [r4, #8]
3000a1d0:	aa09      	add	r2, sp, #36	; 0x24
3000a1d2:	3418      	adds	r4, #24
3000a1d4:	f7ff ff3c 	bl	3000a050 <scr_read_signal.isra.5>
    for (i = 0; i < SIZEOF(scr_mshc2_canfd_signals); i++) {
3000a1d8:	42a5      	cmp	r5, r4
3000a1da:	d1e4      	bne.n	3000a1a6 <Port_Init+0x36>
3000a1dc:	f242 73f4 	movw	r3, #10228	; 0x27f4
3000a1e0:	f247 5a9c 	movw	r10, #30108	; 0x759c
3000a1e4:	2200      	movs	r2, #0
3000a1e6:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000a1ea:	f242 79f0 	movw	r9, #10224	; 0x27f0
3000a1ee:	f2c3 0a02 	movt	r10, #12290	; 0x3002
3000a1f2:	f64d 0be4 	movw	r11, #55524	; 0xd8e4
3000a1f6:	f2c3 0902 	movt	r9, #12290	; 0x3002
3000a1fa:	9304      	str	r3, [sp, #16]
    writel(value, vaddr);
3000a1fc:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
3000a200:	9303      	str	r3, [sp, #12]
3000a202:	4653      	mov	r3, r10
3000a204:	9202      	str	r2, [sp, #8]
3000a206:	f6cf 4153 	movt	r1, #64595	; 0xfc53
3000a20a:	46ca      	mov	r10, r9
3000a20c:	f2c3 0b01 	movt	r11, #12289	; 0x3001
3000a210:	9106      	str	r1, [sp, #24]
3000a212:	4691      	mov	r9, r2
3000a214:	461a      	mov	r2, r3
            PortNumber++) {

        DBG("Port[%d]\n", PortNumber);

        if (Port_lIsPortAvailable(PortNumber) != (uint32_t)0U) {
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
3000a216:	9b07      	ldr	r3, [sp, #28]
3000a218:	ea4f 1809 	mov.w	r8, r9, lsl #4
3000a21c:	9902      	ldr	r1, [sp, #8]
3000a21e:	464c      	mov	r4, r9
3000a220:	f8cd 9004 	str.w	r9, [r13, #4]

            /* Address of each port configuration */
            DataPtr = (const uint32_t *)(const void *)(ConfigDataPtr);

            /* for each pin in one port */
            for (PinNumber = (uint32_t)0U;
3000a224:	2600      	movs	r6, #0
            ConfigDataPtr = (Port_kConfigPtr->PortConfigSetPtr) + ConfigIndex ;
3000a226:	681b      	ldr	r3, [r3, #0]
3000a228:	4691      	mov	r9, r2
3000a22a:	9f03      	ldr	r7, [sp, #12]
3000a22c:	681b      	ldr	r3, [r3, #0]
3000a22e:	440b      	add	r3, r1
3000a230:	461d      	mov	r5, r3
3000a232:	9305      	str	r3, [sp, #20]
3000a234:	e05e      	b.n	3000a2f4 <Port_Init+0x184>
3000a236:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
3000a238:	2ca0      	cmp	r4, #160	; 0xa0
3000a23a:	d065      	beq.n	3000a308 <Port_Init+0x198>
    if (pin >= PORT_PIN_CNT)
3000a23c:	2c9b      	cmp	r4, #155	; 0x9b
    writel(value, vaddr);
3000a23e:	bf84      	itt	hi
3000a240:	2300      	movhi	r3, #0
3000a242:	6018      	strhi	r0, [r3, #0]
    if (pin >= PORT_PIN_CNT)
3000a244:	d811      	bhi.n	3000a26a <Port_Init+0xfa>
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a246:	2c2f      	cmp	r4, #47	; 0x2f
3000a248:	8839      	ldrh	r1, [r7, #0]
3000a24a:	887b      	ldrh	r3, [r7, #2]
3000a24c:	ea4f 2181 	mov.w	r1, r1, lsl #10
3000a250:	ea4f 2383 	mov.w	r3, r3, lsl #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
3000a254:	bf96      	itet	ls
3000a256:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
3000a25a:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
3000a25e:	f1a3 736c 	subls.w	r3, r3, #61865984	; 0x3b00000
    writel(value, vaddr);
3000a262:	6008      	str	r0, [r1, #0]
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
3000a264:	bf88      	it	hi
3000a266:	f1a3 63f6 	subhi.w	r3, r3, #128974848	; 0x7b00000
                IOPadAddr = getIOPadAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + PinNumber)), IOPadAddr);

                /* setup PIN_MUX_CONFIG, and INPUT_SOURCE_SELECT if needed */
                PinMuxAddr  = getPinMuxAddrByPin(PortNumber * 32 + PinNumber);
                iomux_write((uint32_t)(*(DataPtr + 32 + PinNumber)), PinMuxAddr);
3000a26a:	f8d5 1080 	ldr.w	r1, [r5, #128]	; 0x80
    writel(value, vaddr);
3000a26e:	6019      	str	r1, [r3, #0]

                /* get MUX_MODE */
                RegVal = (uint32_t)(*(DataPtr + 32 + PinNumber)) & 0x7;
3000a270:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80

                if (RegVal == PORT_PIN_MODE_GPIO) {
3000a274:	f013 0307 	ands.w	r3, r3, #7
3000a278:	d12e      	bne.n	3000a2d8 <Port_Init+0x168>
                    /* Non-EMMC pins GPIO Setup */
                    /* GPIO/DIO mode, do DIO Init */

                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
3000a27a:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
3000a27e:	e9d9 0302 	ldrd	r0, r3, [r9, #8]
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
3000a282:	0c0a      	lsrs	r2, r1, #16
                    gpio_index = (*(DataPtr + 64 + PinNumber)) & 0xffff;
3000a284:	fa1f fc81 	uxth.w	r12, r1
                    if (((uint32_t)(*(DataPtr + 64 + PinNumber)) >> 16) == ((uint32_t)PORT_PIN_IN)) {
3000a288:	d15f      	bne.n	3000a34a <Port_Init+0x1da>

LOCAL_INLINE vaddr_t getGPIOAddr(uint32_t gpio_index)
{
    vaddr_t gpio_addr;

    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
3000a28a:	459c      	cmp	r12, r3
3000a28c:	d00d      	beq.n	3000a2aa <Port_Init+0x13a>
        return getGPIOBaseAddr();
    }

    if (PORT_GPIO_1 == gpio_index) {
3000a28e:	f1bc 0f01 	cmp.w	r12, #1
3000a292:	f000 80b6 	beq.w	3000a402 <Port_Init+0x292>
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
3000a296:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
                + (gpio_index - PORT_GPIO_2) * GPIO_ADDR_GAP;
    }
    else {
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a298:	bf13      	iteet	ne
3000a29a:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
3000a29e:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
3000a2a2:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a2a6:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
3000a2aa:	9b01      	ldr	r3, [sp, #4]
3000a2ac:	18f3      	adds	r3, r6, r3
                        iomux_write(0x00, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
3000a2ae:	2b2f      	cmp	r3, #47	; 0x2f
3000a2b0:	bf88      	it	hi
3000a2b2:	4643      	movhi	r3, r8
3000a2b4:	d805      	bhi.n	3000a2c2 <Port_Init+0x152>
3000a2b6:	2b17      	cmp	r3, #23
3000a2b8:	bf8c      	ite	hi
3000a2ba:	f5a8 73c0 	subhi.w	r3, r8, #384	; 0x180
3000a2be:	f508 73c0 	addls.w	r3, r8, #384	; 0x180
    writel(value, vaddr);
3000a2c2:	2200      	movs	r2, #0
3000a2c4:	501a      	str	r2, [r3, r0]
                    Port_SetGPIOSCR((uint32_t)(*(DataPtr + 64 + PinNumber)) & 0xffff,
3000a2c6:	4621      	mov	r1, r4
3000a2c8:	f8b5 0100 	ldrh.w	r0, [r5, #256]	; 0x100
3000a2cc:	f7ff fed6 	bl	3000a07c <Port_SetGPIOSCR>
3000a2d0:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
3000a2d4:	f003 0307 	and.w	r3, r3, #7
    if (pin >= PORT_PIN_CNT)
3000a2d8:	2c9b      	cmp	r4, #155	; 0x9b
3000a2da:	d919      	bls.n	3000a310 <Port_Init+0x1a0>
            for (PinNumber = (uint32_t)0U;
3000a2dc:	f8db 3000 	ldr.w	r3, [r11]
                    PinNumber <= (uint32_t)PIN_MAX_NUMBER[PortNumber]; PinNumber++) {
3000a2e0:	3601      	adds	r6, #1
3000a2e2:	3401      	adds	r4, #1
            for (PinNumber = (uint32_t)0U;
3000a2e4:	429e      	cmp	r6, r3
3000a2e6:	f105 0504 	add.w	r5, r5, #4
3000a2ea:	f108 0810 	add.w	r8, r8, #16
3000a2ee:	f107 0744 	add.w	r7, r7, #68	; 0x44
3000a2f2:	d852      	bhi.n	3000a39a <Port_Init+0x22a>
                if (((run_in_domain == PORT_RUN_IN_SECURE) || (run_in_domain == PORT_RUN_IN_AP)) && (PortNumber * 32 + PinNumber) <= 47)
3000a2f4:	f8da 3000 	ldr.w	r3, [r10]
3000a2f8:	3b01      	subs	r3, #1
3000a2fa:	2b01      	cmp	r3, #1
3000a2fc:	d89b      	bhi.n	3000a236 <Port_Init+0xc6>
3000a2fe:	2c2f      	cmp	r4, #47	; 0x2f
3000a300:	d9ec      	bls.n	3000a2dc <Port_Init+0x16c>
3000a302:	6828      	ldr	r0, [r5, #0]
    if (PortConf_PIN_GPIO_SAF == pin)
3000a304:	2ca0      	cmp	r4, #160	; 0xa0
3000a306:	d199      	bne.n	3000a23c <Port_Init+0xcc>
    writel(value, vaddr);
3000a308:	9b06      	ldr	r3, [sp, #24]
3000a30a:	6018      	str	r0, [r3, #0]
3000a30c:	2300      	movs	r3, #0
3000a30e:	e7ac      	b.n	3000a26a <Port_Init+0xfa>
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a310:	0120      	lsls	r0, r4, #4
3000a312:	1901      	adds	r1, r0, r4
3000a314:	9a04      	ldr	r2, [sp, #16]
3000a316:	00db      	lsls	r3, r3, #3
3000a318:	eb03 0181 	add.w	r1, r3, r1, lsl #2
3000a31c:	4411      	add	r1, r2
3000a31e:	88c9      	ldrh	r1, [r1, #6]
3000a320:	2900      	cmp	r1, #0
3000a322:	d0db      	beq.n	3000a2dc <Port_Init+0x16c>
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a324:	9a01      	ldr	r2, [sp, #4]
3000a326:	0289      	lsls	r1, r1, #10
    val = x9_pins[pin].alt_funcs[alt].sel_val;
3000a328:	4420      	add	r0, r4
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a32a:	eb06 0c02 	add.w	r12, r6, r2
    val = x9_pins[pin].alt_funcs[alt].sel_val;
3000a32e:	9a04      	ldr	r2, [sp, #16]
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a330:	f1bc 0f2f 	cmp.w	r12, #47	; 0x2f
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
3000a334:	bf94      	ite	ls
3000a336:	f1a1 716c 	subls.w	r1, r1, #61865984	; 0x3b00000
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
3000a33a:	f1a1 61f6 	subhi.w	r1, r1, #128974848	; 0x7b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
3000a33e:	eb03 0380 	add.w	r3, r3, r0, lsl #2
3000a342:	4413      	add	r3, r2
3000a344:	895b      	ldrh	r3, [r3, #10]
    writel(value, vaddr);
3000a346:	600b      	str	r3, [r1, #0]
3000a348:	e7c8      	b.n	3000a2dc <Port_Init+0x16c>
                        if ((uint32_t)(*(DataPtr + 96)) & (0x01 << PinNumber)) {
3000a34a:	9a05      	ldr	r2, [sp, #20]
3000a34c:	f04f 0e01 	mov.w	r14, #1
3000a350:	fa0e fe06 	lsl.w	r14, r14, r6
3000a354:	f8d2 1180 	ldr.w	r1, [r2, #384]	; 0x180
3000a358:	ea1e 0f01 	tst.w	r14, r1
3000a35c:	d033      	beq.n	3000a3c6 <Port_Init+0x256>
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
3000a35e:	459c      	cmp	r12, r3
3000a360:	d00c      	beq.n	3000a37c <Port_Init+0x20c>
    if (PORT_GPIO_1 == gpio_index) {
3000a362:	f1bc 0f01 	cmp.w	r12, #1
3000a366:	d05c      	beq.n	3000a422 <Port_Init+0x2b2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
3000a368:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a36a:	bf13      	iteet	ne
3000a36c:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
3000a370:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
3000a374:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a378:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
3000a37c:	9b01      	ldr	r3, [sp, #4]
3000a37e:	18f3      	adds	r3, r6, r3
                            iomux_write(0x05, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
3000a380:	2b2f      	cmp	r3, #47	; 0x2f
3000a382:	bf88      	it	hi
3000a384:	4641      	movhi	r1, r8
3000a386:	d805      	bhi.n	3000a394 <Port_Init+0x224>
3000a388:	2b17      	cmp	r3, #23
3000a38a:	bf8c      	ite	hi
3000a38c:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
3000a390:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
3000a394:	2305      	movs	r3, #5
3000a396:	500b      	str	r3, [r1, r0]
3000a398:	e795      	b.n	3000a2c6 <Port_Init+0x156>
3000a39a:	9b02      	ldr	r3, [sp, #8]
3000a39c:	464a      	mov	r2, r9
3000a39e:	f8dd 9004 	ldr.w	r9, [r13, #4]
3000a3a2:	f10b 0b04 	add.w	r11, r11, #4
3000a3a6:	f503 73c4 	add.w	r3, r3, #392	; 0x188
3000a3aa:	f109 0920 	add.w	r9, r9, #32
3000a3ae:	9302      	str	r3, [sp, #8]
    for (PortNumber = (uint32_t)0U; PortNumber <= (uint32_t)PORT_MAX_NUMBER;
3000a3b0:	f1b9 0fa0 	cmp.w	r9, #160	; 0xa0
3000a3b4:	9b03      	ldr	r3, [sp, #12]
3000a3b6:	f503 6308 	add.w	r3, r3, #2176	; 0x880
3000a3ba:	9303      	str	r3, [sp, #12]
3000a3bc:	f47f af2b 	bne.w	3000a216 <Port_Init+0xa6>
}/* Port_Init */
3000a3c0:	b00b      	add	sp, #44	; 0x2c
3000a3c2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (gpio_index == (uint32_t)g_port_handle.dio_real_idx) {
3000a3c6:	459c      	cmp	r12, r3
3000a3c8:	d00c      	beq.n	3000a3e4 <Port_Init+0x274>
    if (PORT_GPIO_1 == gpio_index) {
3000a3ca:	f1bc 0f01 	cmp.w	r12, #1
3000a3ce:	d020      	beq.n	3000a412 <Port_Init+0x2a2>
    else if (PORT_GPIO_1 == g_port_handle.dio_real_idx) {
3000a3d0:	2b01      	cmp	r3, #1
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a3d2:	bf13      	iteet	ne
3000a3d4:	ebac 0303 	subne.w	r3, r12, r3
        gpio_addr = getGPIOBaseAddr() + GPIO1_GPIO2_ADDR_GAP
3000a3d8:	eb00 400c 	addeq.w	r0, r0, r12, lsl #16
3000a3dc:	f500 1078 	addeq.w	r0, r0, #4063232	; 0x3e0000
        gpio_addr = getGPIOBaseAddr() + (gpio_index - g_port_handle.dio_real_idx) * GPIO_ADDR_GAP;
3000a3e0:	eb00 4003 	addne.w	r0, r0, r3, lsl #16
3000a3e4:	9b01      	ldr	r3, [sp, #4]
3000a3e6:	18f3      	adds	r3, r6, r3
                            iomux_write(0x01, getGPIOAddr(gpio_index) + GPIO_CTRL_PIN_X(
3000a3e8:	2b2f      	cmp	r3, #47	; 0x2f
3000a3ea:	bf88      	it	hi
3000a3ec:	4641      	movhi	r1, r8
3000a3ee:	d805      	bhi.n	3000a3fc <Port_Init+0x28c>
3000a3f0:	2b17      	cmp	r3, #23
3000a3f2:	bf8c      	ite	hi
3000a3f4:	f5a8 71c0 	subhi.w	r1, r8, #384	; 0x180
3000a3f8:	f508 71c0 	addls.w	r1, r8, #384	; 0x180
    writel(value, vaddr);
3000a3fc:	2301      	movs	r3, #1
3000a3fe:	500b      	str	r3, [r1, r0]
3000a400:	e761      	b.n	3000a2c6 <Port_Init+0x156>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
3000a402:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
3000a406:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
3000a408:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
3000a40c:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
3000a410:	e74b      	b.n	3000a2aa <Port_Init+0x13a>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
3000a412:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
3000a416:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
3000a418:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
3000a41c:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
3000a420:	e7e0      	b.n	3000a3e4 <Port_Init+0x274>
                - (g_port_handle.dio_real_idx - PORT_GPIO_2) * GPIO_ADDR_GAP;
3000a422:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
3000a426:	33fe      	adds	r3, #254	; 0xfe
        gpio_addr = getGPIOBaseAddr() - GPIO1_GPIO2_ADDR_GAP
3000a428:	f5a0 0080 	sub.w	r0, r0, #4194304	; 0x400000
3000a42c:	eba0 4003 	sub.w	r0, r0, r3, lsl #16
3000a430:	e7a4      	b.n	3000a37c <Port_Init+0x20c>
3000a432:	bf00      	nop

3000a434 <Port_SetPinMode>:
{
3000a434:	b4f0      	push	{r4, r5, r6, r7}
3000a436:	b082      	sub	sp, #8
3000a438:	ab02      	add	r3, sp, #8
    if (PortConf_PIN_GPIO_SAF == pin)
3000a43a:	28a0      	cmp	r0, #160	; 0xa0
{
3000a43c:	e903 0006 	stmdb	r3, {r1, r2}
3000a440:	9d01      	ldr	r5, [sp, #4]
    if (PortConf_PIN_GPIO_SAF == pin)
3000a442:	d029      	beq.n	3000a498 <Port_SetPinMode+0x64>
    if (pin >= PORT_PIN_CNT)
3000a444:	289b      	cmp	r0, #155	; 0x9b
3000a446:	d902      	bls.n	3000a44e <Port_SetPinMode+0x1a>
}/* Port_SetPinMode */
3000a448:	b002      	add	sp, #8
3000a44a:	bcf0      	pop	{r4, r5, r6, r7}
3000a44c:	4770      	bx	r14
3000a44e:	f242 71f4 	movw	r1, #10228	; 0x27f4
3000a452:	0104      	lsls	r4, r0, #4
3000a454:	1823      	adds	r3, r4, r0
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a456:	282f      	cmp	r0, #47	; 0x2f
3000a458:	ea4f 0383 	mov.w	r3, r3, lsl #2
3000a45c:	f2c3 0102 	movt	r1, #12290	; 0x3002
3000a460:	5ace      	ldrh	r6, [r1, r3]
3000a462:	eb01 0203 	add.w	r2, r1, r3
3000a466:	ea4f 2686 	mov.w	r6, r6, lsl #10
3000a46a:	d91e      	bls.n	3000a4aa <Port_SetPinMode+0x76>
    AltNum = (uint32_t)Mode.pin_mux_config & 0x00000007;
3000a46c:	f005 0707 	and.w	r7, r5, #7
3000a470:	8852      	ldrh	r2, [r2, #2]
3000a472:	0292      	lsls	r2, r2, #10
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
3000a474:	f1a6 6cf6 	sub.w	r12, r6, #128974848	; 0x7b00000
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
3000a478:	f1a2 62f6 	sub.w	r2, r2, #128974848	; 0x7b00000
        iomux_write(Mode.io_pad_config, IOPadAddr);
3000a47c:	9e00      	ldr	r6, [sp, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a47e:	00ff      	lsls	r7, r7, #3
    writel(value, vaddr);
3000a480:	f8cc 6000 	str.w	r6, [r12]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a484:	443b      	add	r3, r7
    writel(value, vaddr);
3000a486:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a488:	440b      	add	r3, r1
3000a48a:	88db      	ldrh	r3, [r3, #6]
3000a48c:	2b00      	cmp	r3, #0
3000a48e:	d0db      	beq.n	3000a448 <Port_SetPinMode+0x14>
3000a490:	029b      	lsls	r3, r3, #10
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
3000a492:	f1a3 63f6 	sub.w	r3, r3, #128974848	; 0x7b00000
3000a496:	e024      	b.n	3000a4e2 <Port_SetPinMode+0xae>
        iomux_write(Mode.io_pad_config, IOPadAddr);
3000a498:	9a00      	ldr	r2, [sp, #0]
    writel(value, vaddr);
3000a49a:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
3000a49e:	f6cf 4353 	movt	r3, #64595	; 0xfc53
3000a4a2:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
3000a4a4:	b002      	add	sp, #8
3000a4a6:	bcf0      	pop	{r4, r5, r6, r7}
3000a4a8:	4770      	bx	r14
    if (IOPadAddr)
3000a4aa:	f1b6 766c 	subs.w	r6, r6, #61865984	; 0x3b00000
3000a4ae:	bf0f      	iteee	eq
3000a4b0:	8852      	ldrheq	r2, [r2, #2]
3000a4b2:	2344      	movne	r3, #68	; 0x44
        iomux_write(Mode.io_pad_config, IOPadAddr);
3000a4b4:	9f00      	ldrne	r7, [sp, #0]
3000a4b6:	fb03 1300 	mlane	r3, r3, r0, r1
3000a4ba:	bf1c      	itt	ne
3000a4bc:	885a      	ldrhne	r2, [r3, #2]
    writel(value, vaddr);
3000a4be:	6037      	strne	r7, [r6, #0]
3000a4c0:	f005 0707 	and.w	r7, r5, #7
3000a4c4:	0292      	lsls	r2, r2, #10
3000a4c6:	1823      	adds	r3, r4, r0
3000a4c8:	00ff      	lsls	r7, r7, #3
    if (PinMuxAddr)
3000a4ca:	f1b2 726c 	subs.w	r2, r2, #61865984	; 0x3b00000
3000a4ce:	eb07 0383 	add.w	r3, r7, r3, lsl #2
3000a4d2:	440b      	add	r3, r1
3000a4d4:	88db      	ldrh	r3, [r3, #6]
3000a4d6:	d10d      	bne.n	3000a4f4 <Port_SetPinMode+0xc0>
3000a4d8:	029a      	lsls	r2, r3, #10
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a4da:	2b00      	cmp	r3, #0
3000a4dc:	d0b4      	beq.n	3000a448 <Port_SetPinMode+0x14>
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
3000a4de:	f1a2 736c 	sub.w	r3, r2, #61865984	; 0x3b00000
    val = x9_pins[pin].alt_funcs[alt].sel_val;
3000a4e2:	4420      	add	r0, r4
3000a4e4:	eb07 0780 	add.w	r7, r7, r0, lsl #2
3000a4e8:	4439      	add	r1, r7
3000a4ea:	894a      	ldrh	r2, [r1, #10]
    writel(value, vaddr);
3000a4ec:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
3000a4ee:	b002      	add	sp, #8
3000a4f0:	bcf0      	pop	{r4, r5, r6, r7}
3000a4f2:	4770      	bx	r14
    writel(value, vaddr);
3000a4f4:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
3000a4f6:	2344      	movs	r3, #68	; 0x44
3000a4f8:	fb03 7300 	mla	r3, r3, r0, r7
3000a4fc:	440b      	add	r3, r1
3000a4fe:	88db      	ldrh	r3, [r3, #6]
3000a500:	2b00      	cmp	r3, #0
3000a502:	d0a1      	beq.n	3000a448 <Port_SetPinMode+0x14>
    if (pin < IOMUXC_SAF_PIN_NUM)
3000a504:	282f      	cmp	r0, #47	; 0x2f
3000a506:	ea4f 2283 	mov.w	r2, r3, lsl #10
3000a50a:	4613      	mov	r3, r2
3000a50c:	d8c1      	bhi.n	3000a492 <Port_SetPinMode+0x5e>
3000a50e:	e7e6      	b.n	3000a4de <Port_SetPinMode+0xaa>

3000a510 <Port_SetHandle>:
    if (handle != NULL) {
3000a510:	b1a0      	cbz	r0, 3000a53c <Port_SetHandle+0x2c>
        g_port_handle.phy_addr = p_handle->phy_addr;
3000a512:	f247 539c 	movw	r3, #30108	; 0x759c
        run_in_domain = PORT_RUN_IN_SECURE;
3000a516:	f242 72f0 	movw	r2, #10224	; 0x27f0
        g_port_handle.phy_addr = p_handle->phy_addr;
3000a51a:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
3000a51e:	b430      	push	{r4, r5}
        run_in_domain = PORT_RUN_IN_SECURE;
3000a520:	2101      	movs	r1, #1
3000a522:	f2c3 0202 	movt	r2, #12290	; 0x3002
        g_port_handle.real_idx = p_handle->real_idx;
3000a526:	e9d0 4500 	ldrd	r4, r5, [r0]
        g_port_handle.phy_addr = p_handle->phy_addr;
3000a52a:	601c      	str	r4, [r3, #0]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
3000a52c:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
        g_port_handle.dio_phy_addr = p_handle->dio_phy_addr;
3000a530:	e9c3 5401 	strd	r5, r4, [r3, #4]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
3000a534:	60d8      	str	r0, [r3, #12]
        run_in_domain = PORT_RUN_IN_SECURE;
3000a536:	6011      	str	r1, [r2, #0]
}
3000a538:	bc30      	pop	{r4, r5}
3000a53a:	4770      	bx	r14
3000a53c:	4770      	bx	r14
3000a53e:	bf00      	nop

3000a540 <rstgen_get_default_config>:
//! \return
//
//*****************************************************************************
void rstgen_get_default_config(uint32_t *global_rst_maks)
{
    if (!global_rst_maks) {
3000a540:	b108      	cbz	r0, 3000a546 <rstgen_get_default_config+0x6>
        LTRACEF("config paramenter error !!\n");
        return;
    }

    *global_rst_maks = RSTGEN_GLB_RST_SELF_RST_EN(1)
3000a542:	2307      	movs	r3, #7
3000a544:	6003      	str	r3, [r0, #0]
                       | RSTGEN_GLB_RST_SEM_RST_EN(1)
                       | RSTGEN_GLB_RST_DBG_RST_EN(1);

    LTRACEF("rstgen_get_default_config global_rst_maks:0x%x\n", *global_rst_maks);
}
3000a546:	4770      	bx	r14

3000a548 <rstgen_init>:
//! \return Returns \b true if the wdg timer is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool rstgen_init(vaddr_t base, const uint32_t global_rst_maks)
{
3000a548:	b470      	push	{r4, r5, r6}
3000a54a:	4604      	mov	r4, r0
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);

    //clear all global register
    reg_write = 0x00000000;
    writel(reg_write, base);
3000a54c:	2300      	movs	r3, #0
    reg_read = readl(base);
    reg_write = reg_read | rstgen_global_cfg;
    writel(reg_write, base);

    return true;
}
3000a54e:	2001      	movs	r0, #1
    writel(reg_write, base);
3000a550:	6023      	str	r3, [r4, #0]
    uint32_t rstgen_global_cfg = RSTGEN_GLB_RST_SELF_RST_EN(global_rst_maks)
3000a552:	ea01 0200 	and.w	r2, r1, r0
    reg_read = readl(base);
3000a556:	6825      	ldr	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
3000a558:	fa01 f300 	lsl.w	r3, r1, r0
    reg_write = reg_read & (~RSTGEN_GLB_RST_LOCK_MASK);
3000a55c:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
3000a560:	f003 0302 	and.w	r3, r3, #2
    writel(reg_write, base);
3000a564:	6025      	str	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
3000a566:	008d      	lsls	r5, r1, #2
    reg_read = readl(base);
3000a568:	6826      	ldr	r6, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
3000a56a:	f005 0504 	and.w	r5, r5, #4
    reg_write = reg_read | rstgen_global_cfg;
3000a56e:	4332      	orrs	r2, r6
3000a570:	4313      	orrs	r3, r2
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
3000a572:	00ca      	lsls	r2, r1, #3
    reg_write = reg_read | rstgen_global_cfg;
3000a574:	ea43 0105 	orr.w	r1, r3, r5
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
3000a578:	f002 0308 	and.w	r3, r2, #8
    reg_write = reg_read | rstgen_global_cfg;
3000a57c:	4319      	orrs	r1, r3
    writel(reg_write, base);
3000a57e:	6021      	str	r1, [r4, #0]
}
3000a580:	bc70      	pop	{r4, r5, r6}
3000a582:	4770      	bx	r14

3000a584 <rstgen_global_rst_enable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_enable(vaddr_t base, uint32_t mask)
{
3000a584:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val |= mask;
    writel(val, global_rst_en);

    return true;
}
3000a586:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
3000a588:	681a      	ldr	r2, [r3, #0]
3000a58a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
3000a58e:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
3000a590:	681a      	ldr	r2, [r3, #0]
    val |= mask;
3000a592:	4311      	orrs	r1, r2
    writel(val, global_rst_en);
3000a594:	6019      	str	r1, [r3, #0]
}
3000a596:	4770      	bx	r14

3000a598 <rstgen_global_rst_disable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_disable(vaddr_t base, uint32_t mask)
{
3000a598:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val &= ~mask;
    writel(val, global_rst_en);

    return true;
}
3000a59a:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
3000a59c:	681a      	ldr	r2, [r3, #0]
3000a59e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
3000a5a2:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
3000a5a4:	681a      	ldr	r2, [r3, #0]
    val &= ~mask;
3000a5a6:	ea22 0101 	bic.w	r1, r2, r1
    writel(val, global_rst_en);
3000a5aa:	6019      	str	r1, [r3, #0]
}
3000a5ac:	4770      	bx	r14
3000a5ae:	bf00      	nop

3000a5b0 <rstgen_sw_self_rst>:
// RSTGEN_SEC: ap.self_rst_trig reset the AP domain (sec & ap)
//
//*****************************************************************************
bool rstgen_sw_self_rst(vaddr_t base, bool release)
{
    vaddr_t sw_self_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_SELF_RST_OFF);
3000a5b0:	f500 3288 	add.w	r2, r0, #69632	; 0x11000

    /* Configure rst bit. */
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
3000a5b4:	2001      	movs	r0, #1
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
3000a5b6:	6813      	ldr	r3, [r2, #0]
3000a5b8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
3000a5bc:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
3000a5be:	6813      	ldr	r3, [r2, #0]
3000a5c0:	f023 0301 	bic.w	r3, r3, #1
3000a5c4:	4319      	orrs	r1, r3
3000a5c6:	6011      	str	r1, [r2, #0]
}
3000a5c8:	4770      	bx	r14
3000a5ca:	bf00      	nop

3000a5cc <rstgen_sw_oth_rst>:
// RSTGEN_RTC and RSTGEN_SEC: oth reset has no effect
//
//*****************************************************************************
bool rstgen_sw_oth_rst(vaddr_t base, bool release)
{
    vaddr_t sw_oth_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_OTH_RST_OFF);
3000a5cc:	f500 3290 	add.w	r2, r0, #73728	; 0x12000

    /* Configure rst bit. */
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
3000a5d0:	2001      	movs	r0, #1
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
3000a5d2:	6813      	ldr	r3, [r2, #0]
3000a5d4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
3000a5d8:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
3000a5da:	6813      	ldr	r3, [r2, #0]
3000a5dc:	f023 0301 	bic.w	r3, r3, #1
3000a5e0:	4319      	orrs	r1, r3
3000a5e2:	6011      	str	r1, [r2, #0]
}
3000a5e4:	4770      	bx	r14
3000a5e6:	bf00      	nop

3000a5e8 <rstgen_get_rst_sta>:
uint32_t rstgen_get_rst_sta(vaddr_t base)
{
    vaddr_t rst_sta_addr;
    uint32_t rstgen_rst_sta = 0;

    rst_sta_addr = base + SOC_RSTGEN_REG_MAP(RSTGEN_RST_STA_OFF);
3000a5e8:	f500 3098 	add.w	r0, r0, #77824	; 0x13000

    rstgen_rst_sta = readl(rst_sta_addr);
3000a5ec:	6800      	ldr	r0, [r0, #0]
    LTRACEF("rstgen_get_rst_sta rst_sta:0x%x\n", rstgen_rst_sta);
    return rstgen_rst_sta;
}
3000a5ee:	4770      	bx	r14

3000a5f0 <rstgen_iso_enable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_enable(vaddr_t base, uint32_t iso_idx)
{
3000a5f0:	4603      	mov	r3, r0
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
3000a5f2:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_enable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);

    return true;
}
3000a5f4:	2001      	movs	r0, #1
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);
3000a5f6:	f06f 0201 	mvn.w	r2, #1
3000a5fa:	50ca      	str	r2, [r1, r3]
}
3000a5fc:	4770      	bx	r14
3000a5fe:	bf00      	nop

3000a600 <rstgen_iso_status>:
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
3000a600:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_status is ok iso_slice_idx:%d\n", iso_slice_idx);
    return readl(iso_addr) & RSTGEN_ISO_EN_B_MASK;
3000a602:	5808      	ldr	r0, [r1, r0]
}
3000a604:	f000 0001 	and.w	r0, r0, #1
3000a608:	4770      	bx	r14
3000a60a:	bf00      	nop

3000a60c <rstgen_iso_disable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_disable(vaddr_t base, uint32_t iso_idx)
{
3000a60c:	4602      	mov	r2, r0

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
    LTRACEF("rstgen_iso_disable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
3000a60e:	2301      	movs	r3, #1

    return true;
}
3000a610:	4618      	mov	r0, r3
    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
3000a612:	0309      	lsls	r1, r1, #12
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
3000a614:	508b      	str	r3, [r1, r2]
}
3000a616:	4770      	bx	r14

3000a618 <rstgen_core_reset>:
// sure there's no active bus transaction on the core.
//
//*****************************************************************************
bool rstgen_core_reset(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
3000a618:	0849      	lsrs	r1, r1, #1
{
3000a61a:	b430      	push	{r4, r5}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
3000a61c:	034c      	lsls	r4, r1, #13
3000a61e:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000
3000a622:	1825      	adds	r5, r4, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
3000a624:	5823      	ldr	r3, [r4, r0]
3000a626:	2b00      	cmp	r3, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
3000a628:	bfb8      	it	lt
3000a62a:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
3000a62c:	db17      	blt.n	3000a65e <rstgen_core_reset+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
3000a62e:	0349      	lsls	r1, r1, #13
3000a630:	180b      	adds	r3, r1, r0
    }

    /* Release STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, 1);
3000a632:	580a      	ldr	r2, [r1, r0]
3000a634:	f042 0201 	orr.w	r2, r2, #1
3000a638:	500a      	str	r2, [r1, r0]
    while (!(readl(core_sw_rst) &
3000a63a:	681a      	ldr	r2, [r3, #0]
3000a63c:	0092      	lsls	r2, r2, #2
3000a63e:	d5fc      	bpl.n	3000a63a <rstgen_core_reset+0x22>
                 RSTGEN_CORE_SW_RST_STATIC_RST_B_STA_MASK));

    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
3000a640:	5822      	ldr	r2, [r4, r0]
3000a642:	f042 0201 	orr.w	r2, r2, #1
3000a646:	5022      	str	r2, [r4, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
3000a648:	682a      	ldr	r2, [r5, #0]
3000a64a:	0054      	lsls	r4, r2, #1
3000a64c:	d5fc      	bpl.n	3000a648 <rstgen_core_reset+0x30>
    /* Trigger auto-clear reset. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_AUTO_CLR_SHIFT, 1, 1);
3000a64e:	580a      	ldr	r2, [r1, r0]
3000a650:	f042 0202 	orr.w	r2, r2, #2
3000a654:	500a      	str	r2, [r1, r0]

    /* Polling reset status */
    while (!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK));
3000a656:	681a      	ldr	r2, [r3, #0]
3000a658:	0052      	lsls	r2, r2, #1
3000a65a:	d5fc      	bpl.n	3000a656 <rstgen_core_reset+0x3e>

    return true;
3000a65c:	2001      	movs	r0, #1
}
3000a65e:	bc30      	pop	{r4, r5}
3000a660:	4770      	bx	r14
3000a662:	bf00      	nop

3000a664 <rstgen_core_ctl>:
//
//*****************************************************************************
bool rstgen_core_ctl(vaddr_t base, uint32_t core_idx,
                               bool release)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
3000a664:	0849      	lsrs	r1, r1, #1
{
3000a666:	b470      	push	{r4, r5, r6}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
3000a668:	034b      	lsls	r3, r1, #13
3000a66a:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
3000a66e:	181c      	adds	r4, r3, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
3000a670:	581d      	ldr	r5, [r3, r0]
3000a672:	2d00      	cmp	r5, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
3000a674:	bfb8      	it	lt
3000a676:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
3000a678:	db17      	blt.n	3000a6aa <rstgen_core_ctl+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
3000a67a:	0349      	lsls	r1, r1, #13
3000a67c:	180d      	adds	r5, r1, r0
    }
    /* Check core SW reset status */
    if (release && (readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
3000a67e:	580e      	ldr	r6, [r1, r0]
3000a680:	b1aa      	cbz	r2, 3000a6ae <rstgen_core_ctl+0x4a>
3000a682:	0076      	lsls	r6, r6, #1
3000a684:	d410      	bmi.n	3000a6a8 <rstgen_core_ctl+0x44>
        return true;
    }

    uint32_t sw_rst = release?1:0;
    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
3000a686:	581e      	ldr	r6, [r3, r0]
3000a688:	f046 0601 	orr.w	r6, r6, #1
3000a68c:	501e      	str	r6, [r3, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
3000a68e:	6823      	ldr	r3, [r4, #0]
3000a690:	005b      	lsls	r3, r3, #1
3000a692:	d5fc      	bpl.n	3000a68e <rstgen_core_ctl+0x2a>

    /* STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, sw_rst);
3000a694:	580b      	ldr	r3, [r1, r0]
3000a696:	f023 0301 	bic.w	r3, r3, #1
3000a69a:	4313      	orrs	r3, r2
3000a69c:	500b      	str	r3, [r1, r0]

    /* Wait reset done. */
    while (sw_rst != (readl(core_sw_rst)
3000a69e:	682b      	ldr	r3, [r5, #0]
                            & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK)>>RSTGEN_CORE_SW_RST_CORE_RST_STA_SHIFT);
3000a6a0:	f3c3 7380 	ubfx	r3, r3, #30, #1
    while (sw_rst != (readl(core_sw_rst)
3000a6a4:	4293      	cmp	r3, r2
3000a6a6:	d1fa      	bne.n	3000a69e <rstgen_core_ctl+0x3a>
        return true;
3000a6a8:	2001      	movs	r0, #1
    return true;
}
3000a6aa:	bc70      	pop	{r4, r5, r6}
3000a6ac:	4770      	bx	r14
    if (!release && !(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
3000a6ae:	0076      	lsls	r6, r6, #1
3000a6b0:	d4e9      	bmi.n	3000a686 <rstgen_core_ctl+0x22>
        return true;
3000a6b2:	2001      	movs	r0, #1
3000a6b4:	e7f9      	b.n	3000a6aa <rstgen_core_ctl+0x46>
3000a6b6:	bf00      	nop

3000a6b8 <rstgen_module_ctl>:
//*****************************************************************************
bool rstgen_module_ctl(vaddr_t base, uint32_t module_idx,
                         bool release)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
3000a6b8:	0309      	lsls	r1, r1, #12
{
3000a6ba:	b410      	push	{r4}
                             RSTGEN_MODULE_RST_OFF(module_slice));

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d release:%d\n",
            (uint64_t)base, module_slice, release);

    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
3000a6bc:	580b      	ldr	r3, [r1, r0]
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
3000a6be:	180c      	adds	r4, r1, r0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
3000a6c0:	2b00      	cmp	r3, #0
    {
        LTRACEF("module_slice:%d has been locked.\n", module_slice);
        return false;
3000a6c2:	bfb8      	it	lt
3000a6c4:	2000      	movlt	r0, #0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
3000a6c6:	db15      	blt.n	3000a6f4 <rstgen_module_ctl+0x3c>
    }

    if (release && (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
3000a6c8:	580b      	ldr	r3, [r1, r0]
3000a6ca:	b1b2      	cbz	r2, 3000a6fa <rstgen_module_ctl+0x42>
3000a6cc:	005b      	lsls	r3, r3, #1
3000a6ce:	d410      	bmi.n	3000a6f2 <rstgen_module_ctl+0x3a>
        LTRACEF("module_slice:%d already in assert status\n", module_slice);
        return true;
    }

    /* Enable module reset. */
    RMWREG32(module_rst, RSTGEN_MODULE_RST_EN_SHIFT, 1, 1);
3000a6d0:	580b      	ldr	r3, [r1, r0]
3000a6d2:	f043 0302 	orr.w	r3, r3, #2
3000a6d6:	500b      	str	r3, [r1, r0]

    while (!(readl(module_rst) & RSTGEN_MODULE_RST_EN_MASK));
3000a6d8:	6823      	ldr	r3, [r4, #0]
3000a6da:	079b      	lsls	r3, r3, #30
3000a6dc:	d5fc      	bpl.n	3000a6d8 <rstgen_module_ctl+0x20>

    /* Write RST_N bit. 0 = reset, 1 = release. */
    uint32_t rst_n = release?1:0;
    RMWREG32(module_rst, RSTGEN_MODULE_RST_N_SHIFT, 1, rst_n);
3000a6de:	580b      	ldr	r3, [r1, r0]
3000a6e0:	f023 0301 	bic.w	r3, r3, #1
3000a6e4:	4313      	orrs	r3, r2
3000a6e6:	500b      	str	r3, [r1, r0]

    /* Wait module reset done. */
    while (rst_n != (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK)>>RSTGEN_MODULE_RST_STA_SHIFT);
3000a6e8:	6823      	ldr	r3, [r4, #0]
3000a6ea:	f3c3 7380 	ubfx	r3, r3, #30, #1
3000a6ee:	4293      	cmp	r3, r2
3000a6f0:	d1fa      	bne.n	3000a6e8 <rstgen_module_ctl+0x30>
        return true;
3000a6f2:	2001      	movs	r0, #1

    return true;
}
3000a6f4:	f85d 4b04 	ldr.w	r4, [r13], #4
3000a6f8:	4770      	bx	r14
    if (!release && !(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
3000a6fa:	005b      	lsls	r3, r3, #1
3000a6fc:	d4e8      	bmi.n	3000a6d0 <rstgen_module_ctl+0x18>
        return true;
3000a6fe:	2001      	movs	r0, #1
3000a700:	e7f8      	b.n	3000a6f4 <rstgen_module_ctl+0x3c>
3000a702:	bf00      	nop

3000a704 <rstgen_module_status>:
// return 0, the module reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_module_status(vaddr_t base, uint32_t module_idx)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
3000a704:	0309      	lsls	r1, r1, #12

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d \n",
            (uint64_t)base, module_slice);

    /* RSTGEN_MODULE_RST_STA, 0 = reset, 1 = release. */
    return !!(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK);
3000a706:	5808      	ldr	r0, [r1, r0]
}
3000a708:	f3c0 7080 	ubfx	r0, r0, #30, #1
3000a70c:	4770      	bx	r14
3000a70e:	bf00      	nop

3000a710 <rstgen_core_status>:
// return 1, the core reset has be released.
// return 0, the core reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_core_status(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
3000a710:	0849      	lsrs	r1, r1, #1
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
3000a712:	0349      	lsls	r1, r1, #13
                RSTGEN_CORE_SW_RST_OFF(core_slice));
    return !!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK);
3000a714:	5808      	ldr	r0, [r1, r0]
}
3000a716:	f3c0 7080 	ubfx	r0, r0, #30, #1
3000a71a:	4770      	bx	r14

3000a71c <scr_get>:

/*
 * Get SCR signal value.
 */
uint32_t scr_get(scr_signal_t scr_signal)
{
3000a71c:	b4f0      	push	{r4, r5, r6, r7}
3000a71e:	4604      	mov	r4, r0
3000a720:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
3000a722:	f3c1 2107 	ubfx	r1, r1, #8, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000a726:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000a72a:	061b      	lsls	r3, r3, #24
3000a72c:	ea4f 4610 	mov.w	r6, r0, lsr #16
3000a730:	d428      	bmi.n	3000a784 <scr_get+0x68>
    __asm__ volatile("cpsid i");
3000a732:	b672      	cpsid	i
}

static inline uint32_t _scr_reg(scr_signal_t scr_signal)
{
    const int scr_shift[] = {
3000a734:	f24e 42d0 	movw	r2, #58576	; 0xe4d0
        [SCR_SEC]    = 10,
        [SCR_HPI]    = 0,
    };

    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
    return reg << scr_shift[_scr_id(scr_signal)];
3000a738:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
3000a73a:	f2c3 0201 	movt	r2, #12289	; 0x3001
    return reg << scr_shift[_scr_id(scr_signal)];
3000a73e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  -----------------------------------------------------*/

/* Get physical address of SCR register. */
static inline uint32_t _scr_reg_paddr(enum scr_id scr_id, uint32_t reg)
{
    const addr_t scr_base[] = {
3000a742:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
3000a746:	ad01      	add	r5, sp, #4
3000a748:	ca07      	ldmia	r2, {r0, r1, r2}
3000a74a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
3000a74e:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a752:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
3000a756:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a75a:	40be      	lsls	r6, r7
        [SCR_SAFETY] = APB_SCR_SAF_BASE,
        [SCR_SEC]    = APB_SCR_SEC_BASE,
        [SCR_HPI]    = APB_SCR_HPI_BASE,
    };

    return scr_base[scr_id] + reg;
3000a75c:	f853 3c0c 	ldr.w	r3, [r3, #-12]
};

static inline uint32_t _scr_read_reg(enum scr_id scr_id, uint32_t reg)
{
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
3000a760:	58f0      	ldr	r0, [r6, r3]
    __asm__ volatile("cpsie i");
3000a762:	b662      	cpsie	i
    return (uint32_t)(scr_signal >> 8) & 0xff;
3000a764:	f3c4 2307 	ubfx	r3, r4, #8, #8
    return (uint32_t)scr_signal & 0xff;
3000a768:	b2e4      	uxtb	r4, r4
    spin_lock_irqsave(&g_scr_lock, state);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));
    spin_unlock_irqrestore(&g_scr_lock, state);

    return (val >> _scr_start_bit(scr_signal)) &
            BIT_MASK(_scr_width(scr_signal));
3000a76a:	2c1f      	cmp	r4, #31
    return (val >> _scr_start_bit(scr_signal)) &
3000a76c:	fa20 f003 	lsr.w	r0, r0, r3
            BIT_MASK(_scr_width(scr_signal));
3000a770:	d805      	bhi.n	3000a77e <scr_get+0x62>
3000a772:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
3000a776:	fa03 f404 	lsl.w	r4, r3, r4
3000a77a:	ea20 0004 	bic.w	r0, r0, r4
}
3000a77e:	b004      	add	sp, #16
3000a780:	bcf0      	pop	{r4, r5, r6, r7}
3000a782:	4770      	bx	r14
    const int scr_shift[] = {
3000a784:	f24e 42d0 	movw	r2, #58576	; 0xe4d0
    return reg << scr_shift[_scr_id(scr_signal)];
3000a788:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
3000a78a:	f2c3 0201 	movt	r2, #12289	; 0x3001
    return reg << scr_shift[_scr_id(scr_signal)];
3000a78e:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    const addr_t scr_base[] = {
3000a792:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
3000a796:	ad01      	add	r5, sp, #4
3000a798:	ca07      	ldmia	r2, {r0, r1, r2}
3000a79a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
3000a79e:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7a2:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
3000a7a6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7aa:	40be      	lsls	r6, r7
    return scr_base[scr_id] + reg;
3000a7ac:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
3000a7b0:	58f0      	ldr	r0, [r6, r3]
3000a7b2:	e7d7      	b.n	3000a764 <scr_get+0x48>

3000a7b4 <scr_is_locked>:
    const int scr_shift[] = {
3000a7b4:	f24e 42d0 	movw	r2, #58576	; 0xe4d0
/*
 * Check whether the SCR signal is locked - read only or manually
 * locked by SW.
 */
bool scr_is_locked(scr_signal_t scr_signal)
{
3000a7b8:	460b      	mov	r3, r1
3000a7ba:	b4f0      	push	{r4, r5, r6, r7}
3000a7bc:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000a7c0:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
3000a7c2:	f3c1 2607 	ubfx	r6, r1, #8, #8
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7c6:	a904      	add	r1, sp, #16
    const addr_t scr_base[] = {
3000a7c8:	f102 070c 	add.w	r7, r2, #12
3000a7cc:	4605      	mov	r5, r0
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7ce:	eb01 0686 	add.w	r6, r1, r6, lsl #2
    const int scr_shift[] = {
3000a7d2:	ac01      	add	r4, sp, #4
3000a7d4:	ca07      	ldmia	r2, {r0, r1, r2}
3000a7d6:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
3000a7da:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7de:	f856 cc0c 	ldr.w	r12, [r6, #-12]
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
3000a7e2:	0c2f      	lsrs	r7, r5, #16
    const addr_t scr_base[] = {
3000a7e4:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    uint32_t val = (uint32_t)(scr_signal >> 32) & 0xff;
3000a7e8:	b2db      	uxtb	r3, r3
    return reg << scr_shift[_scr_id(scr_signal)];
3000a7ea:	fa07 f70c 	lsl.w	r7, r7, r12
    return scr_base[scr_id] + reg;
3000a7ee:	f856 2c0c 	ldr.w	r2, [r6, #-12]
    uint32_t start_bit = _scr_start_bit(scr_signal);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));

    bool locked;

    switch (_scr_type(scr_signal)) {
3000a7f2:	3b01      	subs	r3, #1
    return (uint32_t)(scr_signal >> 8) & 0xff;
3000a7f4:	f3c5 2507 	ubfx	r5, r5, #8, #8
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
3000a7f8:	58b8      	ldr	r0, [r7, r2]
3000a7fa:	2b03      	cmp	r3, #3
3000a7fc:	d81f      	bhi.n	3000a83e <scr_is_locked+0x8a>
3000a7fe:	e8df f003 	tbb	[r15, r3]
3000a802:	1102      	.short	0x1102
3000a804:	060d      	.short	0x060d
        case R16W16:
            locked = start_bit >= 16;
            break;

        case RO:
            locked = true;
3000a806:	2001      	movs	r0, #1
            locked = false;
            break;
    }

    return locked;
}
3000a808:	b004      	add	sp, #16
3000a80a:	bcf0      	pop	{r4, r5, r6, r7}
3000a80c:	4770      	bx	r14
            locked = start_bit >= 16;
3000a80e:	2d0f      	cmp	r5, #15
3000a810:	bf94      	ite	ls
3000a812:	2000      	movls	r0, #0
3000a814:	2001      	movhi	r0, #1
}
3000a816:	b004      	add	sp, #16
3000a818:	bcf0      	pop	{r4, r5, r6, r7}
3000a81a:	4770      	bx	r14
            locked = val & (1ul << 31);
3000a81c:	0fc0      	lsrs	r0, r0, #31
}
3000a81e:	b004      	add	sp, #16
3000a820:	bcf0      	pop	{r4, r5, r6, r7}
3000a822:	4770      	bx	r14
                locked = val & (1ul << (start_bit + 16));
3000a824:	2301      	movs	r3, #1
            if (start_bit < 16)
3000a826:	2d0f      	cmp	r5, #15
                locked = val & (1ul << (start_bit + 16));
3000a828:	bf98      	it	ls
3000a82a:	3510      	addls	r5, #16
                locked = val & (1ul << start_bit);
3000a82c:	fa03 f505 	lsl.w	r5, r3, r5
3000a830:	4205      	tst	r5, r0
3000a832:	bf14      	ite	ne
3000a834:	4618      	movne	r0, r3
3000a836:	2000      	moveq	r0, #0
}
3000a838:	b004      	add	sp, #16
3000a83a:	bcf0      	pop	{r4, r5, r6, r7}
3000a83c:	4770      	bx	r14
            locked = false;
3000a83e:	2000      	movs	r0, #0
}
3000a840:	b004      	add	sp, #16
3000a842:	bcf0      	pop	{r4, r5, r6, r7}
3000a844:	4770      	bx	r14
3000a846:	bf00      	nop

3000a848 <scr_set>:
{
3000a848:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000a84c:	468a      	mov	r10, r1
    const int scr_shift[] = {
3000a84e:	f24e 41d0 	movw	r1, #58576	; 0xe4d0
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
3000a852:	f3ca 2607 	ubfx	r6, r10, #8, #8
3000a856:	b085      	sub	sp, #20
    const int scr_shift[] = {
3000a858:	f2c3 0101 	movt	r1, #12289	; 0x3001
    return reg << scr_shift[_scr_id(scr_signal)];
3000a85c:	00b6      	lsls	r6, r6, #2
3000a85e:	ab04      	add	r3, sp, #16
3000a860:	4433      	add	r3, r6
3000a862:	4605      	mov	r5, r0
    const addr_t scr_base[] = {
3000a864:	f101 070c 	add.w	r7, r1, #12
3000a868:	4691      	mov	r9, r2
    const int scr_shift[] = {
3000a86a:	ac01      	add	r4, sp, #4
3000a86c:	c907      	ldmia	r1, {r0, r1, r2}
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
3000a86e:	ea4f 4815 	mov.w	r8, r5, lsr #16
    const int scr_shift[] = {
3000a872:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
3000a876:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a87a:	f853 cc0c 	ldr.w	r12, [r3, #-12]
    const addr_t scr_base[] = {
3000a87e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
3000a882:	fa08 f80c 	lsl.w	r8, r8, r12
    return scr_base[scr_id] + reg;
3000a886:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
3000a88a:	f858 b003 	ldr.w	r11, [r8, r3]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000a88e:	f3ef 8300 	mrs	r3, CPSR
3000a892:	061b      	lsls	r3, r3, #24
3000a894:	d529      	bpl.n	3000a8ea <scr_set+0xa2>
    if (!scr_is_locked(scr_signal)) {
3000a896:	4628      	mov	r0, r5
3000a898:	4651      	mov	r1, r10
3000a89a:	f7ff ff8b 	bl	3000a7b4 <scr_is_locked>
    spin_lock_saved_state_t state = 0;
3000a89e:	4684      	mov	r12, r0
3000a8a0:	bb50      	cbnz	r0, 3000a8f8 <scr_set+0xb0>
    return (uint32_t)scr_signal & 0xff;
3000a8a2:	b2ea      	uxtb	r2, r5
        val &= ~(BIT_MASK(_scr_width(scr_signal)) << start_bit);
3000a8a4:	2a1f      	cmp	r2, #31
3000a8a6:	bf94      	ite	ls
3000a8a8:	2301      	movls	r3, #1
3000a8aa:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
    return (uint32_t)(scr_signal >> 8) & 0xff;
3000a8ae:	f3c5 2507 	ubfx	r5, r5, #8, #8
3000a8b2:	bf9c      	itt	ls
3000a8b4:	4093      	lslls	r3, r2
3000a8b6:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
    return scr_base[scr_id] + reg;
3000a8ba:	aa04      	add	r2, sp, #16
3000a8bc:	40ab      	lsls	r3, r5
3000a8be:	4416      	add	r6, r2
3000a8c0:	ea2b 0b03 	bic.w	r11, r11, r3
    const addr_t scr_base[] = {
3000a8c4:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
        val |= value << start_bit;
3000a8c8:	fa09 f905 	lsl.w	r9, r9, r5
3000a8cc:	ea49 050b 	orr.w	r5, r9, r11
3000a8d0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return scr_base[scr_id] + reg;
3000a8d4:	f856 3c0c 	ldr.w	r3, [r6, #-12]
        ret = true;
3000a8d8:	2001      	movs	r0, #1
}

static inline void
_scr_write_reg(enum scr_id scr_id, uint32_t reg, uint32_t val)
{
    writel(val, _ioaddr(_scr_reg_paddr(scr_id, reg)));
3000a8da:	f848 5003 	str.w	r5, [r8, r3]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
3000a8de:	f1bc 0f00 	cmp.w	r12, #0
3000a8e2:	d118      	bne.n	3000a916 <scr_set+0xce>
}
3000a8e4:	b005      	add	sp, #20
3000a8e6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    __asm__ volatile("cpsid i");
3000a8ea:	b672      	cpsid	i
    if (!scr_is_locked(scr_signal)) {
3000a8ec:	4628      	mov	r0, r5
3000a8ee:	4651      	mov	r1, r10
3000a8f0:	f7ff ff60 	bl	3000a7b4 <scr_is_locked>
3000a8f4:	b160      	cbz	r0, 3000a910 <scr_set+0xc8>
    __asm__ volatile("cpsie i");
3000a8f6:	b662      	cpsie	i
        dprintf(CRITICAL, "Cannot set SCR signal %llx\n", scr_signal);
3000a8f8:	f24e 40e8 	movw	r0, #58600	; 0xe4e8
3000a8fc:	462a      	mov	r2, r5
3000a8fe:	4653      	mov	r3, r10
3000a900:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000a904:	f00b f954 	bl	30015bb0 <_printf>
3000a908:	2000      	movs	r0, #0
}
3000a90a:	b005      	add	sp, #20
3000a90c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
3000a910:	f04f 0c01 	mov.w	r12, #1
3000a914:	e7c5      	b.n	3000a8a2 <scr_set+0x5a>
3000a916:	b662      	cpsie	i
        ret = true;
3000a918:	2001      	movs	r0, #1
3000a91a:	e7e3      	b.n	3000a8e4 <scr_set+0x9c>

3000a91c <cospi_capture_set>:
    reg |= (csda & COSPI_REG_DELAY_CSDA_MASK) << COSPI_REG_DELAY_CSDA_LSB;
    ospi_writel(reg, cospi->apb_base + COSPI_REG_DELAY);
}

static void cospi_capture_set(struct spi_nor *nor)
{
3000a91c:	b430      	push	{r4, r5}
    u32 reg;
    struct cospi_pdata *cospi = nor->priv_data;

    if (nor->dtr_en) {
3000a91e:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
    struct cospi_pdata *cospi = nor->priv_data;
3000a922:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
    if (nor->dtr_en) {
3000a924:	b3b3      	cbz	r3, 3000a994 <cospi_capture_set+0x78>
        cospi->master_delay = 2;
3000a926:	2302      	movs	r3, #2
3000a928:	2103      	movs	r1, #3
3000a92a:	f882 30b6 	strb.w	r3, [r2, #182]	; 0xb6
    }
    else {
        cospi->master_delay = 0;
    }
    cospi->capture_delay = cospi->master_delay +
3000a92e:	f882 10b7 	strb.w	r1, [r2, #183]	; 0xb7
                            COSPI_READCAPTURE_DELAY_DEFAULT;

    if (nor->phy_en) {
3000a932:	f890 3028 	ldrb.w	r3, [r0, #40]	; 0x28
3000a936:	b113      	cbz	r3, 3000a93e <cospi_capture_set+0x22>
        cospi->master_delay = 0;
3000a938:	2300      	movs	r3, #0
3000a93a:	f8a2 30b6 	strh.w	r3, [r2, #182]	; 0xb6
        cospi->capture_delay = 0;
    }

    ospi_writel(((nor->status_dummy + g_dummy) & COSPI_REG_FLASH_STATUS_DUMMY_MASK) <<
3000a93e:	6b43      	ldr	r3, [r0, #52]	; 0x34
3000a940:	f247 54ac 	movw	r4, #30124	; 0x75ac
3000a944:	6851      	ldr	r1, [r2, #4]
3000a946:	f2c3 0402 	movt	r4, #12290	; 0x3002
                  COSPI_REG_FLASH_STATUS_DUMMY_LSB,
                cospi->apb_base + COSPI_REG_FLASH_STATUS);

    reg = ospi_readl(cospi->apb_base + COSPI_REG_READCAPTURE);

    if (cospi->rclk_loopback)
3000a94a:	f892 50b5 	ldrb.w	r5, [r2, #181]	; 0xb5
    ospi_writel(((nor->status_dummy + g_dummy) & COSPI_REG_FLASH_STATUS_DUMMY_MASK) <<
3000a94e:	6820      	ldr	r0, [r4, #0]
3000a950:	4403      	add	r3, r0
3000a952:	041b      	lsls	r3, r3, #16
3000a954:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
3000a958:	f8c1 30b0 	str.w	r3, [r1, #176]	; 0xb0
    reg = ospi_readl(cospi->apb_base + COSPI_REG_READCAPTURE);
3000a95c:	690b      	ldr	r3, [r1, #16]
    if (cospi->rclk_loopback)
3000a95e:	b1ed      	cbz	r5, 3000a99c <cospi_capture_set+0x80>
        reg &= ~(1 << COSPI_REG_READCAPTURE_BYPASS_LSB);
3000a960:	f023 0301 	bic.w	r3, r3, #1
    else
        reg |= (1 << COSPI_REG_READCAPTURE_BYPASS_LSB);

    if (cospi->dqs_en)
3000a964:	f892 00b4 	ldrb.w	r0, [r2, #180]	; 0xb4
3000a968:	b9f0      	cbnz	r0, 3000a9a8 <cospi_capture_set+0x8c>
        reg |= (1 << COSPI_REG_READCAPTURE_DQSEN_LSB);
    else
        reg &= ~(1 << COSPI_REG_READCAPTURE_DQSEN_LSB);
3000a96a:	f423 7380 	bic.w	r3, r3, #256	; 0x100

    reg &=
        ~(COSPI_REG_READCAPTURE_DELAY_MASK << COSPI_REG_READCAPTURE_DELAY_LSB);

    reg |= ((cospi->capture_delay & COSPI_REG_READCAPTURE_DELAY_MASK)
            << COSPI_REG_READCAPTURE_DELAY_LSB);
3000a96e:	f892 00b7 	ldrb.w	r0, [r2, #183]	; 0xb7
    reg |= ((cospi->capture_delay & COSPI_REG_READCAPTURE_DELAY_MASK)
3000a972:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
            << COSPI_REG_READCAPTURE_DELAY_LSB);
3000a976:	0040      	lsls	r0, r0, #1

    reg &=
        ~(COSPI_REG_READCAPTURE_MASTER_DELAY_MASK << COSPI_REG_READCAPTURE_MASTER_DELAY_LSB);

    reg |= ((cospi->master_delay & COSPI_REG_READCAPTURE_MASTER_DELAY_MASK)
            << COSPI_REG_READCAPTURE_MASTER_DELAY_LSB);
3000a978:	f892 20b6 	ldrb.w	r2, [r2, #182]	; 0xb6
    reg |= ((cospi->capture_delay & COSPI_REG_READCAPTURE_DELAY_MASK)
3000a97c:	f023 031e 	bic.w	r3, r3, #30
            << COSPI_REG_READCAPTURE_DELAY_LSB);
3000a980:	f000 001e 	and.w	r0, r0, #30
            << COSPI_REG_READCAPTURE_MASTER_DELAY_LSB);
3000a984:	0412      	lsls	r2, r2, #16
    reg &=
3000a986:	4303      	orrs	r3, r0
            << COSPI_REG_READCAPTURE_MASTER_DELAY_LSB);
3000a988:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
    reg |= ((cospi->master_delay & COSPI_REG_READCAPTURE_MASTER_DELAY_MASK)
3000a98c:	4313      	orrs	r3, r2

    ospi_writel(reg, cospi->apb_base + COSPI_REG_READCAPTURE);
}
3000a98e:	bc30      	pop	{r4, r5}
    ospi_writel(reg, cospi->apb_base + COSPI_REG_READCAPTURE);
3000a990:	610b      	str	r3, [r1, #16]
}
3000a992:	4770      	bx	r14
        cospi->master_delay = 0;
3000a994:	f882 30b6 	strb.w	r3, [r2, #182]	; 0xb6
3000a998:	2101      	movs	r1, #1
3000a99a:	e7c8      	b.n	3000a92e <cospi_capture_set+0x12>
        reg |= (1 << COSPI_REG_READCAPTURE_BYPASS_LSB);
3000a99c:	f043 0301 	orr.w	r3, r3, #1
    if (cospi->dqs_en)
3000a9a0:	f892 00b4 	ldrb.w	r0, [r2, #180]	; 0xb4
3000a9a4:	2800      	cmp	r0, #0
3000a9a6:	d0e0      	beq.n	3000a96a <cospi_capture_set+0x4e>
        reg |= (1 << COSPI_REG_READCAPTURE_DQSEN_LSB);
3000a9a8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
3000a9ac:	e7df      	b.n	3000a96e <cospi_capture_set+0x52>
3000a9ae:	bf00      	nop

3000a9b0 <cospi_cancel>:

int cospi_cancel(struct spi_nor *nor)
{
    dprintf(INFO, "cospi_cancel in.\n");

    nor->cancel_flag = true;
3000a9b0:	2201      	movs	r2, #1
{
3000a9b2:	b538      	push	{r3, r4, r5, r14}

    u32 reg;
    struct cospi_pdata *cospi = nor->priv_data;

    if (!nor->data_present)
3000a9b4:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
    nor->cancel_flag = true;
3000a9b8:	f880 2058 	strb.w	r2, [r0, #88]	; 0x58
    if (!nor->data_present)
3000a9bc:	b36b      	cbz	r3, 3000aa1a <cospi_cancel+0x6a>
        return 0;

    switch (nor->data_cmd.type) {
3000a9be:	6e02      	ldr	r2, [r0, #96]	; 0x60
    struct cospi_pdata *cospi = nor->priv_data;
3000a9c0:	6fc4      	ldr	r4, [r0, #124]	; 0x7c
    switch (nor->data_cmd.type) {
3000a9c2:	2a01      	cmp	r2, #1
3000a9c4:	d02b      	beq.n	3000aa1e <cospi_cancel+0x6e>
3000a9c6:	2a02      	cmp	r2, #2
3000a9c8:	d127      	bne.n	3000aa1a <cospi_cancel+0x6a>
            }
            udelay(1);
            cospi_dma_enable(cospi, 0);
        }

        ospi_writel1(COSPI_REG_INDIRECTWR_CANCEL_MASK,
3000a9ca:	6861      	ldr	r1, [r4, #4]
3000a9cc:	f24e 5004 	movw	r0, #58628	; 0xe504
3000a9d0:	670a      	str	r2, [r1, #112]	; 0x70
3000a9d2:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000a9d6:	3170      	adds	r1, #112	; 0x70
3000a9d8:	680b      	ldr	r3, [r1, #0]
3000a9da:	f00b f8e9 	bl	30015bb0 <_printf>
                    cospi->apb_base + COSPI_REG_INDIRECTWR);

        /* Clear indirect completion status */
        reg = ospi_readl1(cospi->apb_base + COSPI_REG_INDIRECTWR);
3000a9de:	6863      	ldr	r3, [r4, #4]
3000a9e0:	f24e 5024 	movw	r0, #58660	; 0xe524
3000a9e4:	f103 0170 	add.w	r1, r3, #112	; 0x70
3000a9e8:	6f1d      	ldr	r5, [r3, #112]	; 0x70
3000a9ea:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000a9ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
3000a9f0:	f00b f8de 	bl	30015bb0 <_printf>
        if (reg & COSPI_REG_INDIRECTWR_DONE_MASK)
            ospi_writel1(COSPI_REG_INDIRECTWR_DONE_MASK,
3000a9f4:	f24e 5004 	movw	r0, #58628	; 0xe504
        if (reg & COSPI_REG_INDIRECTWR_DONE_MASK)
3000a9f8:	06ab      	lsls	r3, r5, #26
            ospi_writel1(COSPI_REG_INDIRECTWR_DONE_MASK,
3000a9fa:	bf48      	it	mi
3000a9fc:	2220      	movmi	r2, #32
3000a9fe:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000aa02:	bf49      	itett	mi
3000aa04:	6863      	ldrmi	r3, [r4, #4]
3000aa06:	6861      	ldrpl	r1, [r4, #4]
3000aa08:	f103 0170 	addmi.w	r1, r3, #112	; 0x70
3000aa0c:	671a      	strmi	r2, [r3, #112]	; 0x70
3000aa0e:	bf58      	it	pl
3000aa10:	3170      	addpl	r1, #112	; 0x70
3000aa12:	2220      	movs	r2, #32
3000aa14:	680b      	ldr	r3, [r1, #0]
3000aa16:	f00b f8cb 	bl	30015bb0 <_printf>
        break;
    }

    dprintf(INFO, "cospi_cancel out.\n");
    return 0;
}
3000aa1a:	2000      	movs	r0, #0
3000aa1c:	bd38      	pop	{r3, r4, r5, r15}
        ospi_writel(COSPI_REG_INDIRECTRD_CANCEL_MASK,
3000aa1e:	6863      	ldr	r3, [r4, #4]
3000aa20:	2202      	movs	r2, #2
}
3000aa22:	2000      	movs	r0, #0
        ospi_writel(COSPI_REG_INDIRECTRD_CANCEL_MASK,
3000aa24:	661a      	str	r2, [r3, #96]	; 0x60
        reg = ospi_readl(cospi->apb_base + COSPI_REG_INDIRECTRD);
3000aa26:	6e1a      	ldr	r2, [r3, #96]	; 0x60
        if (reg & COSPI_REG_INDIRECTRD_DONE_MASK)
3000aa28:	0692      	lsls	r2, r2, #26
            ospi_writel(COSPI_REG_INDIRECTRD_DONE_MASK,
3000aa2a:	bf44      	itt	mi
3000aa2c:	2220      	movmi	r2, #32
3000aa2e:	661a      	strmi	r2, [r3, #96]	; 0x60
}
3000aa30:	bd38      	pop	{r3, r4, r5, r15}
3000aa32:	bf00      	nop

3000aa34 <cospi_wait_idle>:
{
3000aa34:	b570      	push	{r4, r5, r6, r14}
3000aa36:	4605      	mov	r5, r0
    timeout = current_time() + COSPI_TIMEOUT_MS;
3000aa38:	f7f5 ff78 	bl	3000092c <current_time>
    unsigned int count = 0;
3000aa3c:	2400      	movs	r4, #0
    timeout = current_time() + COSPI_TIMEOUT_MS;
3000aa3e:	f500 767a 	add.w	r6, r0, #1000	; 0x3e8
3000aa42:	e009      	b.n	3000aa58 <cospi_wait_idle+0x24>
        if (count >= idle_latency_cycles)
3000aa44:	2c03      	cmp	r4, #3
3000aa46:	d81c      	bhi.n	3000aa82 <cospi_wait_idle+0x4e>
        if (current_time() > timeout) {
3000aa48:	f7f5 ff70 	bl	3000092c <current_time>
3000aa4c:	42b0      	cmp	r0, r6
        udelay(1);
3000aa4e:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout) {
3000aa52:	d80d      	bhi.n	3000aa70 <cospi_wait_idle+0x3c>
        udelay(1);
3000aa54:	f009 fbcc 	bl	300141f0 <spin>
    reg = readl(cospi->apb_base + COSPI_REG_CONFIG);
3000aa58:	686b      	ldr	r3, [r5, #4]
            count++;
3000aa5a:	3401      	adds	r4, #1
    reg = readl(cospi->apb_base + COSPI_REG_CONFIG);
3000aa5c:	681b      	ldr	r3, [r3, #0]
        if (cospi_idle_status(cospi))
3000aa5e:	2b00      	cmp	r3, #0
3000aa60:	dbf0      	blt.n	3000aa44 <cospi_wait_idle+0x10>
        if (current_time() > timeout) {
3000aa62:	f7f5 ff63 	bl	3000092c <current_time>
            count = 0;
3000aa66:	2400      	movs	r4, #0
        if (current_time() > timeout) {
3000aa68:	42b0      	cmp	r0, r6
        udelay(1);
3000aa6a:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout) {
3000aa6e:	d9f1      	bls.n	3000aa54 <cospi_wait_idle+0x20>
            dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000aa70:	f24e 607c 	movw	r0, #59004	; 0xe67c
3000aa74:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000aa78:	f00b f89a 	bl	30015bb0 <_printf>
            return -1;
3000aa7c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000aa80:	bd70      	pop	{r4, r5, r6, r15}
            return 0;
3000aa82:	2000      	movs	r0, #0
}
3000aa84:	bd70      	pop	{r4, r5, r6, r15}
3000aa86:	bf00      	nop

3000aa88 <cospi_unlock>:
}

void cospi_unlock(struct spi_nor *nor)
{
    struct cospi_pdata *cospi = nor->priv_data;
    mutex_release(&cospi->bus_mutex);
3000aa88:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
3000aa8a:	3010      	adds	r0, #16
3000aa8c:	f006 bffa 	b.w	30011a84 <mutex_release>

3000aa90 <cospi_early_init>:
}



static void cospi_early_init(uint level)
{
3000aa90:	b510      	push	{r4, r14}
    struct cospi_pdata *cospi = &s_cospi;

    memset(cospi, 0, sizeof(struct cospi_pdata));
3000aa92:	f247 54b0 	movw	r4, #30128	; 0x75b0
{
3000aa96:	b082      	sub	sp, #8
    memset(cospi, 0, sizeof(struct cospi_pdata));
3000aa98:	22d0      	movs	r2, #208	; 0xd0
3000aa9a:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000aa9e:	2100      	movs	r1, #0
3000aaa0:	4620      	mov	r0, r4
3000aaa2:	f009 ef66 	blx	30014970 <memset>

    mutex_init(&cospi->bus_mutex);
3000aaa6:	f104 0010 	add.w	r0, r4, #16
3000aaaa:	f006 ff85 	bl	300119b8 <mutex_init>

    event_init(&cospi->dma_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000aaae:	2201      	movs	r2, #1
3000aab0:	2100      	movs	r1, #0
3000aab2:	f104 002c 	add.w	r0, r4, #44	; 0x2c
3000aab6:	f006 fefd 	bl	300118b4 <event_init>
    event_init(&cospi->complete_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000aaba:	2201      	movs	r2, #1
3000aabc:	2100      	movs	r1, #0
3000aabe:	f104 0048 	add.w	r0, r4, #72	; 0x48
3000aac2:	f006 fef7 	bl	300118b4 <event_init>
    event_init(&cospi->xfer_start_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000aac6:	2201      	movs	r2, #1
3000aac8:	2100      	movs	r1, #0
3000aaca:	f104 0064 	add.w	r0, r4, #100	; 0x64
3000aace:	f006 fef1 	bl	300118b4 <event_init>
    event_init(&cospi->xfer_done_event, false, EVENT_FLAG_AUTOUNSIGNAL);
3000aad2:	2201      	movs	r2, #1
3000aad4:	2100      	movs	r1, #0
3000aad6:	f104 0080 	add.w	r0, r4, #128	; 0x80
3000aada:	f006 feeb 	bl	300118b4 <event_init>
    dprintf(INFO, "creat cospi thread!\n");
    thread_t *thread =
3000aade:	f44f 5380 	mov.w	r3, #4096	; 0x1000
3000aae2:	f64a 71fd 	movw	r1, #45053	; 0xaffd
3000aae6:	f24e 50e4 	movw	r0, #58852	; 0xe5e4
3000aaea:	4622      	mov	r2, r4
3000aaec:	f2c3 0100 	movt	r1, #12288	; 0x3000
3000aaf0:	9300      	str	r3, [sp, #0]
3000aaf2:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000aaf6:	2318      	movs	r3, #24
3000aaf8:	f007 f9ca 	bl	30011e90 <thread_create>
3000aafc:	4604      	mov	r4, r0
        thread_create("cospi_thread", cospi_data_thread, (void *)cospi,
                      HIGH_PRIORITY, DEFAULT_STACK_SIZE);
    thread_detach(thread);
3000aafe:	f007 fce1 	bl	300124c4 <thread_detach>
    thread_resume(thread);
3000ab02:	4620      	mov	r0, r4
}
3000ab04:	b002      	add	sp, #8
3000ab06:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    thread_resume(thread);
3000ab0a:	f007 ba15 	b.w	30011f38 <thread_resume>
3000ab0e:	bf00      	nop

3000ab10 <cospi_wait_for_bit.constprop.16>:
static int cospi_wait_for_bit(addr_t reg, const u32 mask, bool clear, u32 time)
3000ab10:	b570      	push	{r4, r5, r6, r14}
3000ab12:	4606      	mov	r6, r0
3000ab14:	460d      	mov	r5, r1
3000ab16:	4614      	mov	r4, r2
    timeout = current_time() + time;
3000ab18:	f7f5 ff08 	bl	3000092c <current_time>
        val = readl(reg);
3000ab1c:	6833      	ldr	r3, [r6, #0]
        if (val == mask)
3000ab1e:	422b      	tst	r3, r5
    timeout = current_time() + time;
3000ab20:	4404      	add	r4, r0
        if (val == mask)
3000ab22:	d105      	bne.n	3000ab30 <cospi_wait_for_bit.constprop.16+0x20>
3000ab24:	e00d      	b.n	3000ab42 <cospi_wait_for_bit.constprop.16+0x32>
        udelay(1);
3000ab26:	f009 fb63 	bl	300141f0 <spin>
        val = readl(reg);
3000ab2a:	6833      	ldr	r3, [r6, #0]
        if (val == mask)
3000ab2c:	422b      	tst	r3, r5
3000ab2e:	d008      	beq.n	3000ab42 <cospi_wait_for_bit.constprop.16+0x32>
        if (current_time() > timeout)
3000ab30:	f7f5 fefc 	bl	3000092c <current_time>
3000ab34:	4284      	cmp	r4, r0
        udelay(1);
3000ab36:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000ab3a:	d2f4      	bcs.n	3000ab26 <cospi_wait_for_bit.constprop.16+0x16>
            return -ETIMEDOUT;
3000ab3c:	f06f 0073 	mvn.w	r0, #115	; 0x73
}
3000ab40:	bd70      	pop	{r4, r5, r6, r15}
            return 0;
3000ab42:	2000      	movs	r0, #0
}
3000ab44:	bd70      	pop	{r4, r5, r6, r15}
3000ab46:	bf00      	nop

3000ab48 <cospi_exec_flash_cmd>:
{
3000ab48:	b538      	push	{r3, r4, r5, r14}
3000ab4a:	460b      	mov	r3, r1
    reg |= COSPI_REG_CMDCTRL_EXECUTE_MASK;
3000ab4c:	f041 0501 	orr.w	r5, r1, #1
{
3000ab50:	4604      	mov	r4, r0
    ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL,
3000ab52:	2264      	movs	r2, #100	; 0x64
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ab54:	6840      	ldr	r0, [r0, #4]
    ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL,
3000ab56:	2102      	movs	r1, #2
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ab58:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ab5c:	f8c0 5090 	str.w	r5, [r0, #144]	; 0x90
    ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL,
3000ab60:	3090      	adds	r0, #144	; 0x90
3000ab62:	f7ff ffd5 	bl	3000ab10 <cospi_wait_for_bit.constprop.16>
    if (ret) {
3000ab66:	b920      	cbnz	r0, 3000ab72 <cospi_exec_flash_cmd+0x2a>
    return cospi_wait_idle(cospi);
3000ab68:	4620      	mov	r0, r4
}
3000ab6a:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return cospi_wait_idle(cospi);
3000ab6e:	f7ff bf61 	b.w	3000aa34 <cospi_wait_idle>
3000ab72:	4605      	mov	r5, r0
        dprintf(CRITICAL, "Flash command execution timed out.\n");
3000ab74:	f24e 50f4 	movw	r0, #58868	; 0xe5f4
3000ab78:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000ab7c:	f00b f818 	bl	30015bb0 <_printf>
}
3000ab80:	4628      	mov	r0, r5
3000ab82:	bd38      	pop	{r3, r4, r5, r15}

3000ab84 <cospi_command_read>:
{
3000ab84:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    struct cospi_pdata *cospi = nor->priv_data;
3000ab88:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
3000ab8a:	b083      	sub	sp, #12
    if (cospi_wait_idle(cospi)) {
3000ab8c:	4628      	mov	r0, r5
{
3000ab8e:	4688      	mov	r8, r1
3000ab90:	4614      	mov	r4, r2
3000ab92:	461f      	mov	r7, r3
    addr_t reg_base = cospi->apb_base;
3000ab94:	686e      	ldr	r6, [r5, #4]
    if (cospi_wait_idle(cospi)) {
3000ab96:	f7ff ff4d 	bl	3000aa34 <cospi_wait_idle>
3000ab9a:	2800      	cmp	r0, #0
3000ab9c:	f040 80cb 	bne.w	3000ad36 <cospi_command_read+0x1b2>
    if (!len || len > COSPI_STIG_DATA_LEN_MAX || !buf) {
3000aba0:	1e78      	subs	r0, r7, #1
3000aba2:	2c00      	cmp	r4, #0
3000aba4:	bf18      	it	ne
3000aba6:	f5b0 7f00 	cmpne.w	r0, #512	; 0x200
3000abaa:	f080 80b9 	bcs.w	3000ad20 <cospi_command_read+0x19c>
    cospi_inst_width_set(cospi, cmd->inst_width);
3000abae:	f8d5 c004 	ldr.w	r12, [r5, #4]
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000abb2:	f898 200a 	ldrb.w	r2, [r8, #10]
    reg = ospi_readl(cospi->apb_base + COSPI_REG_RD_INSTR);
3000abb6:	f8dc 3004 	ldr.w	r3, [r12, #4]
    reg &= ~(COSPI_REG_RD_INSTR_TYPE_INST_MASK
3000abba:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000abbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    ospi_writel(reg, cospi->apb_base + COSPI_REG_RD_INSTR);
3000abc2:	f8cc 3004 	str.w	r3, [r12, #4]
    reg = cmd->opcode << COSPI_REG_CMDCTRL_OPCODE_LSB;
3000abc6:	f898 2008 	ldrb.w	r2, [r8, #8]
    if (cmd->addr_bytes) {
3000abca:	f898 300d 	ldrb.w	r3, [r8, #13]
    reg = cmd->opcode << COSPI_REG_CMDCTRL_OPCODE_LSB;
3000abce:	0611      	lsls	r1, r2, #24
    if (cmd->addr_bytes) {
3000abd0:	2b00      	cmp	r3, #0
3000abd2:	d15c      	bne.n	3000ac8e <cospi_command_read+0x10a>
    reg |= ((cmd->dummy + g_dummy) & COSPI_REG_CMDCTRL_WR_DUMMY_MASK)
3000abd4:	f247 53ac 	movw	r3, #30124	; 0x75ac
3000abd8:	f898 2009 	ldrb.w	r2, [r8, #9]
3000abdc:	f2c3 0302 	movt	r3, #12290	; 0x3002
    if (len <= 8) {
3000abe0:	2f08      	cmp	r7, #8
    reg |= ((cmd->dummy + g_dummy) & COSPI_REG_CMDCTRL_WR_DUMMY_MASK)
3000abe2:	681b      	ldr	r3, [r3, #0]
3000abe4:	441a      	add	r2, r3
           << COSPI_REG_CMDCTRL_WR_DUMMY_LSB;
3000abe6:	ea4f 12c2 	mov.w	r2, r2, lsl #7
3000abea:	f402 62f0 	and.w	r2, r2, #1920	; 0x780
    reg |= ((cmd->dummy + g_dummy) & COSPI_REG_CMDCTRL_WR_DUMMY_MASK)
3000abee:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
3000abf2:	ea42 0201 	orr.w	r2, r2, r1
3000abf6:	9201      	str	r2, [sp, #4]
    if (len <= 8) {
3000abf8:	d956      	bls.n	3000aca8 <cospi_command_read+0x124>
        while (len > mem_bank_len) {
3000abfa:	2f10      	cmp	r7, #16
3000abfc:	bf98      	it	ls
3000abfe:	2100      	movls	r1, #0
        reg |= COSPI_REG_CMDCTRL_MEMBANK_EN_MASK;
3000ac00:	f042 0004 	orr.w	r0, r2, #4
        while (len > mem_bank_len) {
3000ac04:	d906      	bls.n	3000ac14 <cospi_command_read+0x90>
    unsigned int mem_bank_len = 16;
3000ac06:	2110      	movs	r1, #16
    unsigned int index = 0;
3000ac08:	2300      	movs	r3, #0
            index++;
3000ac0a:	3301      	adds	r3, #1
            mem_bank_len *= (1U << index);
3000ac0c:	4099      	lsls	r1, r3
        while (len > mem_bank_len) {
3000ac0e:	428f      	cmp	r7, r1
3000ac10:	d8fb      	bhi.n	3000ac0a <cospi_command_read+0x86>
3000ac12:	0419      	lsls	r1, r3, #16
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ac14:	f8cc 0090 	str.w	r0, [r12, #144]	; 0x90
    reg |= COSPI_REG_CMDCTRL_MEM_EXECUTE_MASK;
3000ac18:	f042 0305 	orr.w	r3, r2, #5
    ospi_writel(ext_reg, cospi->apb_base + COSPI_REG_CMDCTRL_MEM);
3000ac1c:	f8cc 108c 	str.w	r1, [r12, #140]	; 0x8c
    ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL,
3000ac20:	f10c 0090 	add.w	r0, r12, #144	; 0x90
3000ac24:	2264      	movs	r2, #100	; 0x64
3000ac26:	2102      	movs	r1, #2
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ac28:	f8cc 3090 	str.w	r3, [r12, #144]	; 0x90
    ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL,
3000ac2c:	f7ff ff70 	bl	3000ab10 <cospi_wait_for_bit.constprop.16>
    if (ret) {
3000ac30:	4681      	mov	r9, r0
3000ac32:	2800      	cmp	r0, #0
3000ac34:	d16d      	bne.n	3000ad12 <cospi_command_read+0x18e>
3000ac36:	4427      	add	r7, r4
3000ac38:	f107 38ff 	add.w	r8, r7, #4294967295	; 0xffffffff
3000ac3c:	4607      	mov	r7, r0
3000ac3e:	3c01      	subs	r4, #1
        ospi_writel(tmp_reg, cospi->apb_base + COSPI_REG_CMDCTRL_MEM);
3000ac40:	6868      	ldr	r0, [r5, #4]
        tmp_reg |= COSPI_REG_CMDCTRL_MEM_EXECUTE_MASK;
3000ac42:	f047 0301 	orr.w	r3, r7, #1
        ospi_writel(tmp_reg, cospi->apb_base + COSPI_REG_CMDCTRL_MEM);
3000ac46:	f8c0 708c 	str.w	r7, [r0, #140]	; 0x8c
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL_MEM,
3000ac4a:	220a      	movs	r2, #10
        ospi_writel(tmp_reg, cospi->apb_base + COSPI_REG_CMDCTRL_MEM);
3000ac4c:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_CMDCTRL_MEM,
3000ac50:	2102      	movs	r1, #2
3000ac52:	308c      	adds	r0, #140	; 0x8c
3000ac54:	f7ff ff5c 	bl	3000ab10 <cospi_wait_for_bit.constprop.16>
3000ac58:	f507 1780 	add.w	r7, r7, #1048576	; 0x100000
        if (ret) {
3000ac5c:	4681      	mov	r9, r0
3000ac5e:	2800      	cmp	r0, #0
3000ac60:	d149      	bne.n	3000acf6 <cospi_command_read+0x172>
        *(buf + i) = readb(cospi->apb_base + COSPI_REG_CTDCTRL_MEM_DATA);
3000ac62:	686b      	ldr	r3, [r5, #4]
3000ac64:	f893 308d 	ldrb.w	r3, [r3, #141]	; 0x8d
3000ac68:	f804 3f01 	strb.w	r3, [r4, #1]!
    for (i = 0; i < len; i++) {
3000ac6c:	45a0      	cmp	r8, r4
3000ac6e:	d1e7      	bne.n	3000ac40 <cospi_command_read+0xbc>
    ospi_writel(0, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ac70:	686b      	ldr	r3, [r5, #4]
    return cospi_wait_idle(cospi);
3000ac72:	4628      	mov	r0, r5
    ospi_writel(0, cospi->apb_base + COSPI_REG_CMDCTRL);
3000ac74:	f8c3 9090 	str.w	r9, [r3, #144]	; 0x90
    return cospi_wait_idle(cospi);
3000ac78:	f7ff fedc 	bl	3000aa34 <cospi_wait_idle>
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATALOWER);
3000ac7c:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATAUPPER);
3000ac80:	f8d6 30a4 	ldr.w	r3, [r6, #164]	; 0xa4
    return cospi_wait_idle(cospi);
3000ac84:	4681      	mov	r9, r0
}
3000ac86:	4648      	mov	r0, r9
3000ac88:	b003      	add	sp, #12
3000ac8a:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        reg |= ((cmd->addr_bytes - 1) & COSPI_REG_CMDCTRL_ADD_BYTES_MASK)
3000ac8e:	3b01      	subs	r3, #1
        reg |= (0x1 << COSPI_REG_CMDCTRL_ADDR_EN_LSB);
3000ac90:	f441 2200 	orr.w	r2, r1, #524288	; 0x80000
               << COSPI_REG_CMDCTRL_ADD_BYTES_LSB;
3000ac94:	041b      	lsls	r3, r3, #16
3000ac96:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
        reg |= ((cmd->addr_bytes - 1) & COSPI_REG_CMDCTRL_ADD_BYTES_MASK)
3000ac9a:	ea43 0102 	orr.w	r1, r3, r2
        ospi_writel(cmd->addr, cospi->apb_base + COSPI_REG_CMDADDRESS);
3000ac9e:	f8d8 3010 	ldr.w	r3, [r8, #16]
3000aca2:	f8cc 3094 	str.w	r3, [r12, #148]	; 0x94
3000aca6:	e795      	b.n	3000abd4 <cospi_command_read+0x50>
                << COSPI_REG_CMDCTRL_RD_BYTES_LSB);
3000aca8:	0500      	lsls	r0, r0, #20
3000acaa:	f400 00e0 	and.w	r0, r0, #7340032	; 0x700000
        reg |= (((len - 1) & COSPI_REG_CMDCTRL_RD_BYTES_MASK)
3000acae:	4302      	orrs	r2, r0
        status = cospi_exec_flash_cmd(cospi, reg);
3000acb0:	4611      	mov	r1, r2
3000acb2:	4628      	mov	r0, r5
        reg |= (((len - 1) & COSPI_REG_CMDCTRL_RD_BYTES_MASK)
3000acb4:	9201      	str	r2, [sp, #4]
        status = cospi_exec_flash_cmd(cospi, reg);
3000acb6:	f7ff ff47 	bl	3000ab48 <cospi_exec_flash_cmd>
        if (status)
3000acba:	4681      	mov	r9, r0
3000acbc:	2800      	cmp	r0, #0
3000acbe:	d1e2      	bne.n	3000ac86 <cospi_command_read+0x102>
        read_len = (len > 4) ? 4 : len;
3000acc0:	2f04      	cmp	r7, #4
3000acc2:	46b8      	mov	r8, r7
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATALOWER);
3000acc4:	ad02      	add	r5, sp, #8
        read_len = (len > 4) ? 4 : len;
3000acc6:	bf28      	it	cs
3000acc8:	f04f 0804 	movcs.w	r8, #4
        memcpy(buf, &reg, read_len);
3000accc:	4620      	mov	r0, r4
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATALOWER);
3000acce:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
        memcpy(buf, &reg, read_len);
3000acd2:	4642      	mov	r2, r8
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATALOWER);
3000acd4:	f845 3d04 	str.w	r3, [r5, #-4]!
        memcpy(buf, &reg, read_len);
3000acd8:	4629      	mov	r1, r5
3000acda:	f009 edc4 	blx	30014864 <memcpy>
        if (len > 4) {
3000acde:	2f04      	cmp	r7, #4
3000ace0:	d9d1      	bls.n	3000ac86 <cospi_command_read+0x102>
            reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATAUPPER);
3000ace2:	f8d6 30a4 	ldr.w	r3, [r6, #164]	; 0xa4
            memcpy(buf, &reg, read_len);
3000ace6:	1f3a      	subs	r2, r7, #4
3000ace8:	4629      	mov	r1, r5
3000acea:	eb04 0008 	add.w	r0, r4, r8
            reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATAUPPER);
3000acee:	9301      	str	r3, [sp, #4]
            memcpy(buf, &reg, read_len);
3000acf0:	f009 edb8 	blx	30014864 <memcpy>
3000acf4:	e7c7      	b.n	3000ac86 <cospi_command_read+0x102>
            dprintf(CRITICAL, "Membank request timed out.\n");
3000acf6:	f24e 5064 	movw	r0, #58724	; 0xe564
3000acfa:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000acfe:	f00a ff57 	bl	30015bb0 <_printf>
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATALOWER);
3000ad02:	f8d6 30a0 	ldr.w	r3, [r6, #160]	; 0xa0
}
3000ad06:	4648      	mov	r0, r9
        reg = ospi_readl(reg_base + COSPI_REG_CMDREADDATAUPPER);
3000ad08:	f8d6 30a4 	ldr.w	r3, [r6, #164]	; 0xa4
}
3000ad0c:	b003      	add	sp, #12
3000ad0e:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        dprintf(CRITICAL, "Flash command execution timed out.\n");
3000ad12:	f24e 50f4 	movw	r0, #58868	; 0xe5f4
3000ad16:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000ad1a:	f00a ff49 	bl	30015bb0 <_printf>
3000ad1e:	e7f0      	b.n	3000ad02 <cospi_command_read+0x17e>
        dprintf(CRITICAL, "Invalid input argument, len %d rxbuf 0x%p\n", len, buf);
3000ad20:	f24e 5038 	movw	r0, #58680	; 0xe538
3000ad24:	4622      	mov	r2, r4
3000ad26:	4639      	mov	r1, r7
3000ad28:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000ad2c:	f00a ff40 	bl	30015bb0 <_printf>
        return -EINVAL;
3000ad30:	f06f 0915 	mvn.w	r9, #21
3000ad34:	e7a7      	b.n	3000ac86 <cospi_command_read+0x102>
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000ad36:	f24e 607c 	movw	r0, #59004	; 0xe67c
        return -1;
3000ad3a:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000ad3e:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000ad42:	f00a ff35 	bl	30015bb0 <_printf>
        return -1;
3000ad46:	e79e      	b.n	3000ac86 <cospi_command_read+0x102>

3000ad48 <cospi_command_write>:
{
3000ad48:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    struct cospi_pdata *cospi = nor->priv_data;
3000ad4c:	6fc7      	ldr	r7, [r0, #124]	; 0x7c
{
3000ad4e:	b083      	sub	sp, #12
    if (cospi_wait_idle(cospi)) {
3000ad50:	4638      	mov	r0, r7
{
3000ad52:	460e      	mov	r6, r1
3000ad54:	4690      	mov	r8, r2
3000ad56:	461c      	mov	r4, r3
    if (cospi_wait_idle(cospi)) {
3000ad58:	f7ff fe6c 	bl	3000aa34 <cospi_wait_idle>
3000ad5c:	2800      	cmp	r0, #0
3000ad5e:	d14b      	bne.n	3000adf8 <cospi_command_write+0xb0>
    if (len > 4 || (len && !buf)) {
3000ad60:	2c04      	cmp	r4, #4
3000ad62:	d82b      	bhi.n	3000adbc <cospi_command_write+0x74>
3000ad64:	fab8 f088 	clz	r0, r8
3000ad68:	0940      	lsrs	r0, r0, #5
3000ad6a:	2c00      	cmp	r4, #0
3000ad6c:	bf08      	it	eq
3000ad6e:	2000      	moveq	r0, #0
3000ad70:	bb20      	cbnz	r0, 3000adbc <cospi_command_write+0x74>
    cospi_inst_width_set(cospi, cmd->inst_width);
3000ad72:	f8d7 9004 	ldr.w	r9, [r7, #4]
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000ad76:	7ab2      	ldrb	r2, [r6, #10]
    reg = ospi_readl(cospi->apb_base + COSPI_REG_RD_INSTR);
3000ad78:	f8d9 3004 	ldr.w	r3, [r9, #4]
    reg &= ~(COSPI_REG_RD_INSTR_TYPE_INST_MASK
3000ad7c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000ad80:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    ospi_writel(reg, cospi->apb_base + COSPI_REG_RD_INSTR);
3000ad84:	f8c9 3004 	str.w	r3, [r9, #4]
    reg = cmd->opcode << COSPI_REG_CMDCTRL_OPCODE_LSB;
3000ad88:	7a35      	ldrb	r5, [r6, #8]
    if (cmd->addr_bytes) {
3000ad8a:	7b73      	ldrb	r3, [r6, #13]
    reg = cmd->opcode << COSPI_REG_CMDCTRL_OPCODE_LSB;
3000ad8c:	062d      	lsls	r5, r5, #24
    if (cmd->addr_bytes) {
3000ad8e:	b14b      	cbz	r3, 3000ada4 <cospi_command_write+0x5c>
        reg |= ((cmd->addr_bytes - 1) & COSPI_REG_CMDCTRL_ADD_BYTES_MASK)
3000ad90:	3b01      	subs	r3, #1
        reg |= (0x1 << COSPI_REG_CMDCTRL_ADDR_EN_LSB);
3000ad92:	f445 2500 	orr.w	r5, r5, #524288	; 0x80000
               << COSPI_REG_CMDCTRL_ADD_BYTES_LSB;
3000ad96:	041b      	lsls	r3, r3, #16
3000ad98:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
        reg |= ((cmd->addr_bytes - 1) & COSPI_REG_CMDCTRL_ADD_BYTES_MASK)
3000ad9c:	431d      	orrs	r5, r3
        ospi_writel(cmd->addr, cospi->apb_base + COSPI_REG_CMDADDRESS);
3000ad9e:	6933      	ldr	r3, [r6, #16]
3000ada0:	f8c9 3094 	str.w	r3, [r9, #148]	; 0x94
    if (len) {
3000ada4:	b9b4      	cbnz	r4, 3000add4 <cospi_command_write+0x8c>
           << COSPI_REG_CMDCTRL_WR_DUMMY_LSB;
3000ada6:	7a71      	ldrb	r1, [r6, #9]
    ret = cospi_exec_flash_cmd(cospi, reg);
3000ada8:	4638      	mov	r0, r7
           << COSPI_REG_CMDCTRL_WR_DUMMY_LSB;
3000adaa:	01c9      	lsls	r1, r1, #7
3000adac:	f401 61f0 	and.w	r1, r1, #1920	; 0x780
    ret = cospi_exec_flash_cmd(cospi, reg);
3000adb0:	4329      	orrs	r1, r5
}
3000adb2:	b003      	add	sp, #12
3000adb4:	e8bd 43f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r14}
    ret = cospi_exec_flash_cmd(cospi, reg);
3000adb8:	f7ff bec6 	b.w	3000ab48 <cospi_exec_flash_cmd>
        dprintf(CRITICAL, "Invalid input argument, len %d buf 0x%p\n", len, buf);
3000adbc:	f24e 5080 	movw	r0, #58752	; 0xe580
3000adc0:	4642      	mov	r2, r8
3000adc2:	4621      	mov	r1, r4
3000adc4:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000adc8:	f00a fef2 	bl	30015bb0 <_printf>
        return EINVAL;
3000adcc:	2016      	movs	r0, #22
}
3000adce:	b003      	add	sp, #12
3000add0:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        data = 0;
3000add4:	f04f 0c00 	mov.w	r12, #0
3000add8:	a802      	add	r0, sp, #8
        memcpy(&data, buf, len);
3000adda:	4641      	mov	r1, r8
        reg |= ((len - 1) & COSPI_REG_CMDCTRL_WR_BYTES_MASK)
3000addc:	1e63      	subs	r3, r4, #1
        data = 0;
3000adde:	f840 cd04 	str.w	r12, [r0, #-4]!
        memcpy(&data, buf, len);
3000ade2:	4622      	mov	r2, r4
        reg |= ((len - 1) & COSPI_REG_CMDCTRL_WR_BYTES_MASK)
3000ade4:	ea45 3503 	orr.w	r5, r5, r3, lsl #12
        memcpy(&data, buf, len);
3000ade8:	f009 ed3c 	blx	30014864 <memcpy>
        ospi_writel(data, cospi->apb_base + COSPI_REG_CMDWRITEDATALOWER);
3000adec:	9b01      	ldr	r3, [sp, #4]
        reg |= ((len - 1) & COSPI_REG_CMDCTRL_WR_BYTES_MASK)
3000adee:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
        ospi_writel(data, cospi->apb_base + COSPI_REG_CMDWRITEDATALOWER);
3000adf2:	f8c9 30a8 	str.w	r3, [r9, #168]	; 0xa8
3000adf6:	e7d6      	b.n	3000ada6 <cospi_command_write+0x5e>
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000adf8:	f24e 607c 	movw	r0, #59004	; 0xe67c
3000adfc:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000ae00:	f00a fed6 	bl	30015bb0 <_printf>
        return -1;
3000ae04:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000ae08:	e7e1      	b.n	3000adce <cospi_command_write+0x86>
3000ae0a:	bf00      	nop

3000ae0c <cospi_xfer>:
{
3000ae0c:	b5f0      	push	{r4, r5, r6, r7, r14}
    ASSERT(IS_ALIGNED(buf, 4));
3000ae0e:	0794      	lsls	r4, r2, #30
{
3000ae10:	b08b      	sub	sp, #44	; 0x2c
    ASSERT(IS_ALIGNED(buf, 4));
3000ae12:	f040 8091 	bne.w	3000af38 <cospi_xfer+0x12c>
    ASSERT(IS_ALIGNED(size, 4));
3000ae16:	f013 0703 	ands.w	r7, r3, #3
3000ae1a:	f040 809f 	bne.w	3000af5c <cospi_xfer+0x150>
3000ae1e:	460d      	mov	r5, r1
3000ae20:	4604      	mov	r4, r0
    if (cmd->type == SPI_NOR_OPS_ERASE) {
3000ae22:	6849      	ldr	r1, [r1, #4]
    struct cospi_pdata *cospi = nor->priv_data;
3000ae24:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
    nor->cancel_flag = false;
3000ae26:	f880 7058 	strb.w	r7, [r0, #88]	; 0x58
    if (cmd->type == SPI_NOR_OPS_ERASE) {
3000ae2a:	2903      	cmp	r1, #3
3000ae2c:	d067      	beq.n	3000aefe <cospi_xfer+0xf2>
    if (cmd->type == SPI_NOR_OPS_READ || cmd->type == SPI_NOR_OPS_WRITE) {
3000ae2e:	3901      	subs	r1, #1
3000ae30:	2901      	cmp	r1, #1
3000ae32:	d918      	bls.n	3000ae66 <cospi_xfer+0x5a>
3000ae34:	6873      	ldr	r3, [r6, #4]
    event_signal(&cospi->xfer_start_event, false);
3000ae36:	2100      	movs	r1, #0
3000ae38:	f106 0064 	add.w	r0, r6, #100	; 0x64
    ospi_readl(cospi->apb_base + COSPI_REG_FLASH_STATUS);
3000ae3c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
    event_signal(&cospi->xfer_start_event, false);
3000ae40:	f006 fd74 	bl	3001192c <event_signal>
    if (nor->async_mode) {
3000ae44:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
3000ae48:	b11b      	cbz	r3, 3000ae52 <cospi_xfer+0x46>
        ret = 0;
3000ae4a:	2300      	movs	r3, #0
}
3000ae4c:	4618      	mov	r0, r3
3000ae4e:	b00b      	add	sp, #44	; 0x2c
3000ae50:	bdf0      	pop	{r4, r5, r6, r7, r15}
3000ae52:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000ae56:	f106 0080 	add.w	r0, r6, #128	; 0x80
3000ae5a:	f006 fd41 	bl	300118e0 <event_wait_timeout>
        ret = nor->data_error;
3000ae5e:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
3000ae60:	4618      	mov	r0, r3
3000ae62:	b00b      	add	sp, #44	; 0x2c
3000ae64:	bdf0      	pop	{r4, r5, r6, r7, r15}
        nor->data_present = 1;
3000ae66:	2001      	movs	r0, #1
3000ae68:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
        memcpy(&nor->data_cmd, cmd, sizeof(struct spi_nor_cmd));
3000ae6c:	6828      	ldr	r0, [r5, #0]
3000ae6e:	f8d5 e004 	ldr.w	r14, [r5, #4]
3000ae72:	f8d5 c008 	ldr.w	r12, [r5, #8]
3000ae76:	68ef      	ldr	r7, [r5, #12]
3000ae78:	66a7      	str	r7, [r4, #104]	; 0x68
3000ae7a:	65e0      	str	r0, [r4, #92]	; 0x5c
3000ae7c:	f8c4 e060 	str.w	r14, [r4, #96]	; 0x60
3000ae80:	f8c4 c064 	str.w	r12, [r4, #100]	; 0x64
3000ae84:	6928      	ldr	r0, [r5, #16]
3000ae86:	66e0      	str	r0, [r4, #108]	; 0x6c
        if (cmd->type == SPI_NOR_OPS_WRITE) {
3000ae88:	6869      	ldr	r1, [r5, #4]
        nor->data_cmd.size = size;
3000ae8a:	e9c4 231c 	strd	r2, r3, [r4, #112]	; 0x70
    if (cospi->addr_bytes != cmd->addr_bytes) {
3000ae8e:	7b6b      	ldrb	r3, [r5, #13]
        if (cmd->type == SPI_NOR_OPS_WRITE) {
3000ae90:	2902      	cmp	r1, #2
    if (cospi->addr_bytes != cmd->addr_bytes) {
3000ae92:	f896 20b8 	ldrb.w	r2, [r6, #184]	; 0xb8
        if (cmd->type == SPI_NOR_OPS_WRITE) {
3000ae96:	d07d      	beq.n	3000af94 <cospi_xfer+0x188>
    if (cospi->addr_bytes != cmd->addr_bytes) {
3000ae98:	429a      	cmp	r2, r3
3000ae9a:	d00f      	beq.n	3000aebc <cospi_xfer+0xb0>
        cospi->addr_bytes = cmd->addr_bytes;
3000ae9c:	f886 30b8 	strb.w	r3, [r6, #184]	; 0xb8
        cospi_addr_bytes_set(nor);
3000aea0:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    if (cospi->addr_bytes > 1)
3000aea2:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
3000aea6:	2a01      	cmp	r2, #1
        reg |= ((cospi->addr_bytes - 1) << COSPI_REG_SIZE_ADDRESS_LSB);
3000aea8:	bf88      	it	hi
3000aeaa:	f102 32ff 	addhi.w	r2, r2, #4294967295	; 0xffffffff
    reg = ospi_readl(cospi->apb_base + COSPI_REG_SIZE);
3000aeae:	6859      	ldr	r1, [r3, #4]
3000aeb0:	694b      	ldr	r3, [r1, #20]
    reg &= ~(COSPI_REG_SIZE_ADDRESS_MASK << COSPI_REG_SIZE_ADDRESS_LSB);
3000aeb2:	f023 030f 	bic.w	r3, r3, #15
        reg |= ((cospi->addr_bytes - 1) << COSPI_REG_SIZE_ADDRESS_LSB);
3000aeb6:	bf88      	it	hi
3000aeb8:	4313      	orrhi	r3, r2
    ospi_writel(reg, cospi->apb_base + COSPI_REG_SIZE);
3000aeba:	614b      	str	r3, [r1, #20]
    if (nor->dtr_en) {
3000aebc:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
3000aec0:	2b00      	cmp	r3, #0
3000aec2:	d15d      	bne.n	3000af80 <cospi_xfer+0x174>
3000aec4:	7aeb      	ldrb	r3, [r5, #11]
3000aec6:	031b      	lsls	r3, r3, #12
3000aec8:	7aaa      	ldrb	r2, [r5, #10]
3000aeca:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
3000aece:	7b2b      	ldrb	r3, [r5, #12]
3000aed0:	041f      	lsls	r7, r3, #16
3000aed2:	f247 50ac 	movw	r0, #30124	; 0x75ac
    reg |= cmd->ddr_en << COSPI_REG_RD_INSTR_DDR_EN;
3000aed6:	7869      	ldrb	r1, [r5, #1]
3000aed8:	f2c3 0002 	movt	r0, #12290	; 0x3002
    reg = cmd->opcode << COSPI_REG_RD_INSTR_OPCODE_LSB;
3000aedc:	7a2b      	ldrb	r3, [r5, #8]
3000aede:	ea43 2381 	orr.w	r3, r3, r1, lsl #10
    if (nor->global_read_dummy)
3000aee2:	6b21      	ldr	r1, [r4, #48]	; 0x30
3000aee4:	433b      	orrs	r3, r7
3000aee6:	6800      	ldr	r0, [r0, #0]
    reg |= cmd->ddr_en << COSPI_REG_RD_INSTR_DDR_EN;
3000aee8:	4313      	orrs	r3, r2
    if (nor->global_read_dummy)
3000aeea:	2900      	cmp	r1, #0
3000aeec:	d078      	beq.n	3000afe0 <cospi_xfer+0x1d4>
        reg |= ((nor->global_read_dummy + g_dummy) & COSPI_REG_RD_INSTR_DUMMY_MASK)
3000aeee:	180a      	adds	r2, r1, r0
               << COSPI_REG_RD_INSTR_DUMMY_LSB;
3000aef0:	0612      	lsls	r2, r2, #24
3000aef2:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
        reg |= ((nor->global_read_dummy + g_dummy) & COSPI_REG_RD_INSTR_DUMMY_MASK)
3000aef6:	431a      	orrs	r2, r3
3000aef8:	6873      	ldr	r3, [r6, #4]
    ospi_writel(reg, cospi->apb_base + COSPI_REG_RD_INSTR);
3000aefa:	605a      	str	r2, [r3, #4]
3000aefc:	e79b      	b.n	3000ae36 <cospi_xfer+0x2a>
    struct spi_nor_cmd write_enable_cmd = {
3000aefe:	f04f 0c06 	mov.w	r12, #6
    ret = cospi_command_write(nor, &write_enable_cmd, NULL, 0);
3000af02:	463b      	mov	r3, r7
3000af04:	463a      	mov	r2, r7
3000af06:	a903      	add	r1, sp, #12
    struct spi_nor_cmd write_enable_cmd = {
3000af08:	e9cd 7704 	strd	r7, r7, [r13, #16]
3000af0c:	7aae      	ldrb	r6, [r5, #10]
3000af0e:	9703      	str	r7, [sp, #12]
3000af10:	e9cd 7706 	strd	r7, r7, [r13, #24]
3000af14:	e9cd 7708 	strd	r7, r7, [r13, #32]
3000af18:	f88d c014 	strb.w	r12, [r13, #20]
3000af1c:	f88d 6016 	strb.w	r6, [r13, #22]
    ret = cospi_command_write(nor, &write_enable_cmd, NULL, 0);
3000af20:	f7ff ff12 	bl	3000ad48 <cospi_command_write>
    if (ret)
3000af24:	4603      	mov	r3, r0
3000af26:	2800      	cmp	r0, #0
3000af28:	d190      	bne.n	3000ae4c <cospi_xfer+0x40>
    return cospi_command_write(nor, cmd, NULL, 0);
3000af2a:	461a      	mov	r2, r3
3000af2c:	4629      	mov	r1, r5
3000af2e:	4620      	mov	r0, r4
3000af30:	f7ff ff0a 	bl	3000ad48 <cospi_command_write>
3000af34:	4603      	mov	r3, r0
        goto xfer_out;
3000af36:	e789      	b.n	3000ae4c <cospi_xfer+0x40>
    ASSERT(IS_ALIGNED(buf, 4));
3000af38:	f24e 63cc 	movw	r3, #59084	; 0xe6cc
3000af3c:	f24e 6298 	movw	r2, #59032	; 0xe698
3000af40:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000af44:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000af48:	4670      	mov	r0, r14
3000af4a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000af4e:	9300      	str	r3, [sp, #0]
3000af50:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000af54:	f44f 63b0 	mov.w	r3, #1408	; 0x580
3000af58:	f009 f95c 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(size, 4));
3000af5c:	f24e 63e0 	movw	r3, #59104	; 0xe6e0
3000af60:	f24e 6298 	movw	r2, #59032	; 0xe698
3000af64:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000af68:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000af6c:	4670      	mov	r0, r14
3000af6e:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000af72:	9300      	str	r3, [sp, #0]
3000af74:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000af78:	f240 5381 	movw	r3, #1409	; 0x581
3000af7c:	f009 f94a 	bl	30014214 <_panic>
        cmd->inst_width = SPI_NOR_OCTAL_LANS;
3000af80:	f240 3103 	movw	r1, #771	; 0x303
        cmd->addr_width = SPI_NOR_OCTAL_LANS;
3000af84:	2303      	movs	r3, #3
3000af86:	f44f 524c 	mov.w	r2, #13056	; 0x3300
3000af8a:	f44f 3740 	mov.w	r7, #196608	; 0x30000
        cmd->inst_width = SPI_NOR_OCTAL_LANS;
3000af8e:	8169      	strh	r1, [r5, #10]
        cmd->addr_width = SPI_NOR_OCTAL_LANS;
3000af90:	732b      	strb	r3, [r5, #12]
3000af92:	e79e      	b.n	3000aed2 <cospi_xfer+0xc6>
    if (cospi->addr_bytes != cmd->addr_bytes) {
3000af94:	429a      	cmp	r2, r3
3000af96:	d00f      	beq.n	3000afb8 <cospi_xfer+0x1ac>
        cospi->addr_bytes = cmd->addr_bytes;
3000af98:	f886 30b8 	strb.w	r3, [r6, #184]	; 0xb8
        cospi_addr_bytes_set(nor);
3000af9c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
    if (cospi->addr_bytes > 1)
3000af9e:	f893 20b8 	ldrb.w	r2, [r3, #184]	; 0xb8
3000afa2:	2a01      	cmp	r2, #1
        reg |= ((cospi->addr_bytes - 1) << COSPI_REG_SIZE_ADDRESS_LSB);
3000afa4:	bf88      	it	hi
3000afa6:	f102 32ff 	addhi.w	r2, r2, #4294967295	; 0xffffffff
    reg = ospi_readl(cospi->apb_base + COSPI_REG_SIZE);
3000afaa:	6859      	ldr	r1, [r3, #4]
3000afac:	694b      	ldr	r3, [r1, #20]
    reg &= ~(COSPI_REG_SIZE_ADDRESS_MASK << COSPI_REG_SIZE_ADDRESS_LSB);
3000afae:	f023 030f 	bic.w	r3, r3, #15
        reg |= ((cospi->addr_bytes - 1) << COSPI_REG_SIZE_ADDRESS_LSB);
3000afb2:	bf88      	it	hi
3000afb4:	4313      	orrhi	r3, r2
    ospi_writel(reg, cospi->apb_base + COSPI_REG_SIZE);
3000afb6:	614b      	str	r3, [r1, #20]
    cospi_inst_width_set(cospi, cmd->inst_width);
3000afb8:	6873      	ldr	r3, [r6, #4]
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000afba:	7aa8      	ldrb	r0, [r5, #10]
    if (nor->dtr_en) {
3000afbc:	f894 1029 	ldrb.w	r1, [r4, #41]	; 0x29
    reg = ospi_readl(cospi->apb_base + COSPI_REG_RD_INSTR);
3000afc0:	685a      	ldr	r2, [r3, #4]
    reg &= ~(COSPI_REG_RD_INSTR_TYPE_INST_MASK
3000afc2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    reg |= (uint32_t)inst_width << COSPI_REG_RD_INSTR_TYPE_INST_LSB;
3000afc6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
    ospi_writel(reg, cospi->apb_base + COSPI_REG_RD_INSTR);
3000afca:	605a      	str	r2, [r3, #4]
    if (nor->dtr_en) {
3000afcc:	b979      	cbnz	r1, 3000afee <cospi_xfer+0x1e2>
3000afce:	7b2a      	ldrb	r2, [r5, #12]
3000afd0:	0412      	lsls	r2, r2, #16
3000afd2:	7ae9      	ldrb	r1, [r5, #11]
3000afd4:	ea42 3101 	orr.w	r1, r2, r1, lsl #12
    reg = cmd->opcode << COSPI_REG_WR_INSTR_OPCODE_LSB;
3000afd8:	7a2a      	ldrb	r2, [r5, #8]
    reg |= (cmd->data_width << COSPI_REG_WR_INSTR_TYPE_DATA_LSB);
3000afda:	430a      	orrs	r2, r1
    ospi_writel(reg, cospi->apb_base + COSPI_REG_WR_INSTR);
3000afdc:	609a      	str	r2, [r3, #8]
3000afde:	e72a      	b.n	3000ae36 <cospi_xfer+0x2a>
        reg |= ((cmd->dummy + g_dummy) & COSPI_REG_RD_INSTR_DUMMY_MASK)
3000afe0:	7a6a      	ldrb	r2, [r5, #9]
3000afe2:	4402      	add	r2, r0
            << COSPI_REG_RD_INSTR_DUMMY_LSB;
3000afe4:	0612      	lsls	r2, r2, #24
3000afe6:	f002 52f8 	and.w	r2, r2, #520093696	; 0x1f000000
        reg |= ((cmd->dummy + g_dummy) & COSPI_REG_RD_INSTR_DUMMY_MASK)
3000afea:	431a      	orrs	r2, r3
3000afec:	e784      	b.n	3000aef8 <cospi_xfer+0xec>
        cmd->addr_width = SPI_NOR_OCTAL_LANS;
3000afee:	2203      	movs	r2, #3
        cmd->data_width = SPI_NOR_OCTAL_LANS;
3000aff0:	f44f 314c 	mov.w	r1, #208896	; 0x33000
        cmd->addr_width = SPI_NOR_OCTAL_LANS;
3000aff4:	72ea      	strb	r2, [r5, #11]
        cmd->data_width = SPI_NOR_OCTAL_LANS;
3000aff6:	732a      	strb	r2, [r5, #12]
3000aff8:	e7ee      	b.n	3000afd8 <cospi_xfer+0x1cc>
3000affa:	bf00      	nop

3000affc <cospi_data_thread>:
{
3000affc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000b000:	4603      	mov	r3, r0
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
3000b002:	2100      	movs	r1, #0
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
3000b004:	f24e 54ac 	movw	r4, #58796	; 0xe5ac
{
3000b008:	b089      	sub	sp, #36	; 0x24
3000b00a:	f100 0264 	add.w	r2, r0, #100	; 0x64
3000b00e:	3380      	adds	r3, #128	; 0x80
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
3000b010:	f6cf 71ff 	movt	r1, #65535	; 0xffff
{
3000b014:	9005      	str	r0, [sp, #20]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
3000b016:	f2c3 0401 	movt	r4, #12289	; 0x3001
3000b01a:	9204      	str	r2, [sp, #16]
3000b01c:	9307      	str	r3, [sp, #28]
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
3000b01e:	9103      	str	r1, [sp, #12]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
3000b020:	9406      	str	r4, [sp, #24]
3000b022:	9804      	ldr	r0, [sp, #16]
3000b024:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000b028:	f006 fc5a 	bl	300118e0 <event_wait_timeout>
        nor = cospi->priv;
3000b02c:	9b05      	ldr	r3, [sp, #20]
3000b02e:	f8d3 80cc 	ldr.w	r8, [r3, #204]	; 0xcc
    struct cospi_pdata *cospi = nor->priv_data;
3000b032:	f8d8 207c 	ldr.w	r2, [r8, #124]	; 0x7c
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
3000b036:	f892 30ba 	ldrb.w	r3, [r2, #186]	; 0xba
3000b03a:	f892 20bb 	ldrb.w	r2, [r2, #187]	; 0xbb
3000b03e:	fb13 f302 	smulbb	r3, r3, r2
    uint32_t remaining = cmd->size;
3000b042:	f8d8 1074 	ldr.w	r1, [r8, #116]	; 0x74
    uint8_t *xfer_buf = (uint8_t *)cmd->buf;
3000b046:	f8d8 2070 	ldr.w	r2, [r8, #112]	; 0x70
    uint32_t remaining = cmd->size;
3000b04a:	9100      	str	r1, [sp, #0]
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
3000b04c:	01db      	lsls	r3, r3, #7
    uint8_t *xfer_buf = (uint8_t *)cmd->buf;
3000b04e:	9201      	str	r2, [sp, #4]
    const uint32_t max_xfer_length = cospi->fifo_depth * cospi->fifo_width * 128;
3000b050:	9302      	str	r3, [sp, #8]
    while(remaining) {
3000b052:	2900      	cmp	r1, #0
3000b054:	f000 813c 	beq.w	3000b2d0 <cospi_data_thread+0x2d4>
    int ret = 0;
3000b058:	2000      	movs	r0, #0
3000b05a:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
        if (nor->async_mode && nor->cancel_flag) {
3000b05e:	b121      	cbz	r1, 3000b06a <cospi_data_thread+0x6e>
3000b060:	f898 3058 	ldrb.w	r3, [r8, #88]	; 0x58
3000b064:	2b00      	cmp	r3, #0
3000b066:	f040 80fa 	bne.w	3000b25e <cospi_data_thread+0x262>
        xfer_len = MIN(remaining, max_xfer_length);
3000b06a:	9a02      	ldr	r2, [sp, #8]
3000b06c:	9c00      	ldr	r4, [sp, #0]
        switch (cmd->type) {
3000b06e:	f8d8 3060 	ldr.w	r3, [r8, #96]	; 0x60
        xfer_len = MIN(remaining, max_xfer_length);
3000b072:	42a2      	cmp	r2, r4
3000b074:	bf28      	it	cs
3000b076:	4622      	movcs	r2, r4
        switch (cmd->type) {
3000b078:	2b02      	cmp	r3, #2
        xfer_len = MIN(remaining, max_xfer_length);
3000b07a:	4692      	mov	r10, r2
3000b07c:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
        switch (cmd->type) {
3000b080:	d01d      	beq.n	3000b0be <cospi_data_thread+0xc2>
3000b082:	2b03      	cmp	r3, #3
3000b084:	d004      	beq.n	3000b090 <cospi_data_thread+0x94>
3000b086:	2b01      	cmp	r3, #1
            ret = -1;
3000b088:	bf18      	it	ne
3000b08a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
        switch (cmd->type) {
3000b08e:	d069      	beq.n	3000b164 <cospi_data_thread+0x168>
        xfer_buf += xfer_len;
3000b090:	9b01      	ldr	r3, [sp, #4]
        nor->data_cmd.addr += xfer_len;
3000b092:	4452      	add	r2, r10
3000b094:	f8c8 206c 	str.w	r2, [r8, #108]	; 0x6c
        xfer_buf += xfer_len;
3000b098:	4453      	add	r3, r10
3000b09a:	9301      	str	r3, [sp, #4]
    while(remaining) {
3000b09c:	9b00      	ldr	r3, [sp, #0]
3000b09e:	ebb3 030a 	subs.w	r3, r3, r10
3000b0a2:	9300      	str	r3, [sp, #0]
3000b0a4:	d1db      	bne.n	3000b05e <cospi_data_thread+0x62>
    nor->data_present = 0;
3000b0a6:	2300      	movs	r3, #0
3000b0a8:	f888 3050 	strb.w	r3, [r8, #80]	; 0x50
        if (nor->async_mode) {
3000b0ac:	2900      	cmp	r1, #0
3000b0ae:	f040 80db 	bne.w	3000b268 <cospi_data_thread+0x26c>
            nor->data_error = ret;
3000b0b2:	f8c8 0054 	str.w	r0, [r8, #84]	; 0x54
            event_signal(&cospi->xfer_done_event, false);
3000b0b6:	9807      	ldr	r0, [sp, #28]
3000b0b8:	f006 fc38 	bl	3001192c <event_signal>
3000b0bc:	e7b1      	b.n	3000b022 <cospi_data_thread+0x26>
    if (buf == NULL || size == 0)
3000b0be:	9e01      	ldr	r6, [sp, #4]
3000b0c0:	f1ba 0f00 	cmp.w	r10, #0
3000b0c4:	bf18      	it	ne
3000b0c6:	2e00      	cmpne	r6, #0
3000b0c8:	f000 80c7 	beq.w	3000b25a <cospi_data_thread+0x25e>
    struct cospi_pdata *cospi = nor->priv_data;
3000b0cc:	f8d8 907c 	ldr.w	r9, [r8, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTWR_START_MASK,
3000b0d0:	2101      	movs	r1, #1
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
3000b0d2:	f8d8 503c 	ldr.w	r5, [r8, #60]	; 0x3c
        udelay(1);
3000b0d6:	4608      	mov	r0, r1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
3000b0d8:	f8d9 30bc 	ldr.w	r3, [r9, #188]	; 0xbc
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
3000b0dc:	1e6c      	subs	r4, r5, #1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
3000b0de:	f8d9 7008 	ldr.w	r7, [r9, #8]
        nor->page_size * 2 - (cmd->addr & (nor->page_size - 1));
3000b0e2:	4014      	ands	r4, r2
    u32 addr_page_bonduary_size =
3000b0e4:	ebc4 0445 	rsb	r4, r4, r5, lsl #1
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
3000b0e8:	441f      	add	r7, r3
    cospi_indirect_trigger(cospi, cmd->addr, size, INDIRECT_WRITE_FLAG);
3000b0ea:	f8d9 3004 	ldr.w	r3, [r9, #4]
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTWRSTARTADDR);
3000b0ee:	679a      	str	r2, [r3, #120]	; 0x78
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTWRBYTES);
3000b0f0:	f8c3 a07c 	str.w	r10, [r3, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTWR_START_MASK,
3000b0f4:	6719      	str	r1, [r3, #112]	; 0x70
        udelay(1);
3000b0f6:	f009 f87b 	bl	300141f0 <spin>
    arch_invalidate_cache_range(ahb_trigger_address, cospi->trigger_range_size);
3000b0fa:	f8d9 10c0 	ldr.w	r1, [r9, #192]	; 0xc0
3000b0fe:	4638      	mov	r0, r7
3000b100:	f7f6 ed08 	blx	30001b14 <arch_invalidate_cache_range>
        if (addr_page_bonduary_size) {
3000b104:	2c00      	cmp	r4, #0
3000b106:	f000 80e0 	beq.w	3000b2ca <cospi_data_thread+0x2ce>
            write_bytes = MIN(remaining, addr_page_bonduary_size);
3000b10a:	4635      	mov	r5, r6
3000b10c:	4554      	cmp	r4, r10
3000b10e:	bf28      	it	cs
3000b110:	4654      	movcs	r4, r10
3000b112:	4656      	mov	r6, r10
                DIV_ROUND_UP(write_bytes, cospi->fifo_width));
3000b114:	f899 30bb 	ldrb.w	r3, [r9, #187]	; 0xbb
3000b118:	1e5a      	subs	r2, r3, #1
3000b11a:	4422      	add	r2, r4
3000b11c:	fbb2 f2f3 	udiv	r2, r2, r3
    while (len--)
3000b120:	1e53      	subs	r3, r2, #1
3000b122:	b152      	cbz	r2, 3000b13a <cospi_data_thread+0x13e>
3000b124:	462a      	mov	r2, r5
3000b126:	eba7 0c05 	sub.w	r12, r7, r5
3000b12a:	eb02 010c 	add.w	r1, r2, r12
        writel(*data++, addr++);
3000b12e:	f852 0b04 	ldr.w	r0, [r2], #4
    while (len--)
3000b132:	3b01      	subs	r3, #1
        writel(*data++, addr++);
3000b134:	6008      	str	r0, [r1, #0]
    while (len--)
3000b136:	1c59      	adds	r1, r3, #1
3000b138:	d1f7      	bne.n	3000b12a <cospi_data_thread+0x12e>
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
3000b13a:	f8d9 0004 	ldr.w	r0, [r9, #4]
3000b13e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
3000b142:	9903      	ldr	r1, [sp, #12]
        write_buf += write_bytes;
3000b144:	4425      	add	r5, r4
        ret = cospi_wait_for_bit(cospi->apb_base + COSPI_REG_SDRAMLEVEL,
3000b146:	302c      	adds	r0, #44	; 0x2c
3000b148:	f7ff fce2 	bl	3000ab10 <cospi_wait_for_bit.constprop.16>
        if (ret) {
3000b14c:	2800      	cmp	r0, #0
3000b14e:	f040 80a1 	bne.w	3000b294 <cospi_data_thread+0x298>
    while (remaining) {
3000b152:	1b36      	subs	r6, r6, r4
3000b154:	f000 809b 	beq.w	3000b28e <cospi_data_thread+0x292>
            write_bytes = MIN(remaining, nor->page_size);
3000b158:	f8d8 403c 	ldr.w	r4, [r8, #60]	; 0x3c
3000b15c:	42b4      	cmp	r4, r6
3000b15e:	bf28      	it	cs
3000b160:	4634      	movcs	r4, r6
3000b162:	e7d7      	b.n	3000b114 <cospi_data_thread+0x118>
    if (buf == NULL || size == 0)
3000b164:	9b01      	ldr	r3, [sp, #4]
3000b166:	f1ba 0f00 	cmp.w	r10, #0
3000b16a:	bf18      	it	ne
3000b16c:	2b00      	cmpne	r3, #0
3000b16e:	d074      	beq.n	3000b25a <cospi_data_thread+0x25e>
    if (cmd->queue_mode_en)
3000b170:	f898 305e 	ldrb.w	r3, [r8, #94]	; 0x5e
        trgger_size = size / 2;
3000b174:	ea4f 075a 	mov.w	r7, r10, lsr #1
    if (cmd->queue_mode_en)
3000b178:	b903      	cbnz	r3, 3000b17c <cospi_data_thread+0x180>
3000b17a:	4657      	mov	r7, r10
            ret = cospi_indirect_read(nor, &nor->data_cmd, xfer_buf, xfer_len);
3000b17c:	f8d8 b07c 	ldr.w	r11, [r8, #124]	; 0x7c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
3000b180:	2601      	movs	r6, #1
        udelay(1);
3000b182:	4630      	mov	r0, r6
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
3000b184:	e9db 1501 	ldrd	r1, r5, [r11, #4]
3000b188:	f8db 40bc 	ldr.w	r4, [r11, #188]	; 0xbc
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTRDSTARTADDR);
3000b18c:	668a      	str	r2, [r1, #104]	; 0x68
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTRDBYTES);
3000b18e:	66cf      	str	r7, [r1, #108]	; 0x6c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
3000b190:	660e      	str	r6, [r1, #96]	; 0x60
        udelay(1);
3000b192:	f009 f82d 	bl	300141f0 <spin>
    if (cmd->queue_mode_en) {
3000b196:	f898 205e 	ldrb.w	r2, [r8, #94]	; 0x5e
3000b19a:	2a00      	cmp	r2, #0
3000b19c:	f040 8089 	bne.w	3000b2b2 <cospi_data_thread+0x2b6>
    s64 remaining = size;
3000b1a0:	4656      	mov	r6, r10
    addr_t ahb_trigger_address = cospi->ahb_base + cospi->trigger_address;
3000b1a2:	eb05 0904 	add.w	r9, r5, r4
3000b1a6:	9c01      	ldr	r4, [sp, #4]
    s64 remaining = size;
3000b1a8:	2700      	movs	r7, #0
    timeout = current_time() + COSPI_READ_TIMEOUT_MS;
3000b1aa:	f7f5 fbbf 	bl	3000092c <current_time>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
3000b1ae:	f8db 2004 	ldr.w	r2, [r11, #4]
3000b1b2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
3000b1b4:	b29b      	uxth	r3, r3
    timeout = current_time() + COSPI_READ_TIMEOUT_MS;
3000b1b6:	f100 050a 	add.w	r5, r0, #10
        if (val)
3000b1ba:	b13b      	cbz	r3, 3000b1cc <cospi_data_thread+0x1d0>
3000b1bc:	e019      	b.n	3000b1f2 <cospi_data_thread+0x1f6>
        udelay(1);
3000b1be:	f009 f817 	bl	300141f0 <spin>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
3000b1c2:	f8db 2004 	ldr.w	r2, [r11, #4]
3000b1c6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
3000b1c8:	b29b      	uxth	r3, r3
        if (val)
3000b1ca:	b993      	cbnz	r3, 3000b1f2 <cospi_data_thread+0x1f6>
        if (current_time() > timeout)
3000b1cc:	f7f5 fbae 	bl	3000092c <current_time>
3000b1d0:	4285      	cmp	r5, r0
        udelay(1);
3000b1d2:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000b1d6:	d2f2      	bcs.n	3000b1be <cospi_data_thread+0x1c2>
3000b1d8:	f10b 0048 	add.w	r0, r11, #72	; 0x48
3000b1dc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000b1e0:	f006 fb7e 	bl	300118e0 <event_wait_timeout>
    return nor->data_error;
3000b1e4:	f8d8 0054 	ldr.w	r0, [r8, #84]	; 0x54
3000b1e8:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
3000b1ec:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
3000b1f0:	e74e      	b.n	3000b090 <cospi_data_thread+0x94>
3000b1f2:	f89b 10bb 	ldrb.w	r1, [r11, #187]	; 0xbb
3000b1f6:	e002      	b.n	3000b1fe <cospi_data_thread+0x202>
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
3000b1f8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
3000b1fa:	b29b      	uxth	r3, r3
        while (words_need_read) {
3000b1fc:	b34b      	cbz	r3, 3000b252 <cospi_data_thread+0x256>
            words_need_read = MIN(words_need_read,
3000b1fe:	f8db 50c0 	ldr.w	r5, [r11, #192]	; 0xc0
3000b202:	fbb5 f5f1 	udiv	r5, r5, r1
3000b206:	429d      	cmp	r5, r3
3000b208:	bf28      	it	cs
3000b20a:	461d      	movcs	r5, r3
            if (words_need_read) {
3000b20c:	2d00      	cmp	r5, #0
3000b20e:	d0f3      	beq.n	3000b1f8 <cospi_data_thread+0x1fc>
                arch_invalidate_cache_range(ahb_trigger_address,
3000b210:	4648      	mov	r0, r9
3000b212:	4629      	mov	r1, r5
3000b214:	f7f6 ec7e 	blx	30001b14 <arch_invalidate_cache_range>
    while (len--)
3000b218:	4623      	mov	r3, r4
3000b21a:	1e6a      	subs	r2, r5, #1
3000b21c:	eba9 0004 	sub.w	r0, r9, r4
3000b220:	1819      	adds	r1, r3, r0
3000b222:	3a01      	subs	r2, #1
        *data++ = readl(addr++);
3000b224:	6809      	ldr	r1, [r1, #0]
3000b226:	f843 1b04 	str.w	r1, [r3], #4
    while (len--)
3000b22a:	1c51      	adds	r1, r2, #1
3000b22c:	d1f8      	bne.n	3000b220 <cospi_data_thread+0x224>
                read_buf += words_need_read * cospi->fifo_width;
3000b22e:	f89b 10bb 	ldrb.w	r1, [r11, #187]	; 0xbb
3000b232:	fb05 f301 	mul.w	r3, r5, r1
                remaining -= words_need_read * cospi->fifo_width;
3000b236:	1af6      	subs	r6, r6, r3
3000b238:	f167 0700 	sbc.w	r7, r7, #0
                if (remaining < 0)
3000b23c:	2e00      	cmp	r6, #0
                read_buf += words_need_read * cospi->fifo_width;
3000b23e:	441c      	add	r4, r3
                if (remaining < 0)
3000b240:	f177 0300 	sbcs.w	r3, r7, #0
3000b244:	dbc8      	blt.n	3000b1d8 <cospi_data_thread+0x1dc>
3000b246:	f8db 2004 	ldr.w	r2, [r11, #4]
    u32 reg = ospi_readl(cospi->apb_base + COSPI_REG_SDRAMLEVEL);
3000b24a:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    return reg & COSPI_REG_SDRAMLEVEL_RD_MASK;
3000b24c:	b29b      	uxth	r3, r3
        while (words_need_read) {
3000b24e:	2b00      	cmp	r3, #0
3000b250:	d1d5      	bne.n	3000b1fe <cospi_data_thread+0x202>
    while (remaining > 0) {
3000b252:	ea56 0307 	orrs.w	r3, r6, r7
3000b256:	d1a8      	bne.n	3000b1aa <cospi_data_thread+0x1ae>
3000b258:	e7be      	b.n	3000b1d8 <cospi_data_thread+0x1dc>
        return EINVAL;
3000b25a:	2016      	movs	r0, #22
3000b25c:	e718      	b.n	3000b090 <cospi_data_thread+0x94>
    nor->data_present = 0;
3000b25e:	2300      	movs	r3, #0
3000b260:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000b264:	f888 3050 	strb.w	r3, [r8, #80]	; 0x50
            handle = nor->parent;
3000b268:	f8d8 2078 	ldr.w	r2, [r8, #120]	; 0x78
            if (handle && handle->event_handle) {
3000b26c:	2a00      	cmp	r2, #0
3000b26e:	f43f aed8 	beq.w	3000b022 <cospi_data_thread+0x26>
3000b272:	6a54      	ldr	r4, [r2, #36]	; 0x24
3000b274:	2c00      	cmp	r4, #0
3000b276:	f43f aed4 	beq.w	3000b022 <cospi_data_thread+0x26>
                    ret ? SPI_NOR_OPT_FAILED : SPI_NOR_OPT_COMPLETE;
3000b27a:	1c03      	adds	r3, r0, #0
                handle->opt_type = nor->data_cmd.type;
3000b27c:	f8d8 0060 	ldr.w	r0, [r8, #96]	; 0x60
                    ret ? SPI_NOR_OPT_FAILED : SPI_NOR_OPT_COMPLETE;
3000b280:	bf18      	it	ne
3000b282:	2301      	movne	r3, #1
                handle->event_handle(handle->opt_type, handle->opt_result);
3000b284:	4619      	mov	r1, r3
                handle->opt_result =
3000b286:	e9c2 0307 	strd	r0, r3, [r2, #28]
                handle->event_handle(handle->opt_type, handle->opt_result);
3000b28a:	47a0      	blx	r4
3000b28c:	e6c9      	b.n	3000b022 <cospi_data_thread+0x26>
3000b28e:	f109 0048 	add.w	r0, r9, #72	; 0x48
3000b292:	e7a3      	b.n	3000b1dc <cospi_data_thread+0x1e0>
            ret = ospi_readl(cospi->apb_base + 0xb0);
3000b294:	f8d9 3004 	ldr.w	r3, [r9, #4]
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
3000b298:	9806      	ldr	r0, [sp, #24]
            ret = ospi_readl(cospi->apb_base + 0xb0);
3000b29a:	f8d3 10b0 	ldr.w	r1, [r3, #176]	; 0xb0
            dprintf(CRITICAL, "Indirect write timeout, ret = 0x%x, sram level 0x%08x.\n",
3000b29e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
3000b2a0:	f00a fc86 	bl	30015bb0 <_printf>
3000b2a4:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
3000b2a8:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
            return -1;
3000b2ac:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000b2b0:	e6ee      	b.n	3000b090 <cospi_data_thread+0x94>
        cospi_indirect_trigger(cospi, cmd->addr + trgger_size, trgger_size,
3000b2b2:	f8d8 206c 	ldr.w	r2, [r8, #108]	; 0x6c
        udelay(1);
3000b2b6:	4630      	mov	r0, r6
        cospi_indirect_trigger(cospi, cmd->addr + trgger_size, trgger_size,
3000b2b8:	f8db 1004 	ldr.w	r1, [r11, #4]
3000b2bc:	443a      	add	r2, r7
        ospi_writel(addr, cospi->apb_base + COSPI_REG_INDIRECTRDSTARTADDR);
3000b2be:	668a      	str	r2, [r1, #104]	; 0x68
        ospi_writel(size, cospi->apb_base + COSPI_REG_INDIRECTRDBYTES);
3000b2c0:	66cf      	str	r7, [r1, #108]	; 0x6c
        ospi_writel(COSPI_REG_INDIRECTRD_START_MASK,
3000b2c2:	660e      	str	r6, [r1, #96]	; 0x60
        udelay(1);
3000b2c4:	f008 ff94 	bl	300141f0 <spin>
3000b2c8:	e76a      	b.n	3000b1a0 <cospi_data_thread+0x1a4>
        if (addr_page_bonduary_size) {
3000b2ca:	9d01      	ldr	r5, [sp, #4]
3000b2cc:	4656      	mov	r6, r10
3000b2ce:	e743      	b.n	3000b158 <cospi_data_thread+0x15c>
    while(remaining) {
3000b2d0:	9800      	ldr	r0, [sp, #0]
3000b2d2:	f898 102c 	ldrb.w	r1, [r8, #44]	; 0x2c
3000b2d6:	e6e6      	b.n	3000b0a6 <cospi_data_thread+0xaa>

3000b2d8 <cospi_irq_handle>:
{
3000b2d8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    status = readl(cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b2da:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
{
3000b2dc:	4605      	mov	r5, r0
    status = readl(cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b2de:	685b      	ldr	r3, [r3, #4]
3000b2e0:	6c1c      	ldr	r4, [r3, #64]	; 0x40
    writel(status, cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b2e2:	641c      	str	r4, [r3, #64]	; 0x40
    if (status & COSPI_REG_IRQ_ECC_ERR)
3000b2e4:	0326      	lsls	r6, r4, #12
3000b2e6:	d451      	bmi.n	3000b38c <cospi_irq_handle+0xb4>
    if (status & COSPI_REG_IRQSTATUS_INDIRECT_DONE_MASK) {
3000b2e8:	0764      	lsls	r4, r4, #29
3000b2ea:	d401      	bmi.n	3000b2f0 <cospi_irq_handle+0x18>
}
3000b2ec:	2000      	movs	r0, #0
3000b2ee:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        cospi_tx_complete(nor, 0);
3000b2f0:	6fec      	ldr	r4, [r5, #124]	; 0x7c
    ret = ospi_readl(cospi->apb_base + COSPI_REG_INDIRECTWR);
3000b2f2:	6862      	ldr	r2, [r4, #4]
3000b2f4:	f102 0170 	add.w	r1, r2, #112	; 0x70
3000b2f8:	6f13      	ldr	r3, [r2, #112]	; 0x70
    if (!ret)
3000b2fa:	b1eb      	cbz	r3, 3000b338 <cospi_irq_handle+0x60>
3000b2fc:	2364      	movs	r3, #100	; 0x64
3000b2fe:	e001      	b.n	3000b304 <cospi_irq_handle+0x2c>
    while (count < times) {
3000b300:	3b01      	subs	r3, #1
3000b302:	d04a      	beq.n	3000b39a <cospi_irq_handle+0xc2>
        val = readl(reg);
3000b304:	680a      	ldr	r2, [r1, #0]
        if (val == mask) {
3000b306:	0690      	lsls	r0, r2, #26
3000b308:	d5fa      	bpl.n	3000b300 <cospi_irq_handle+0x28>
    ret = cospi_wait_for_bit_times(cospi->apb_base + COSPI_REG_INDIRECTWR,
3000b30a:	2700      	movs	r7, #0
    ospi_writel(COSPI_REG_INDIRECTWR_DONE_MASK,
3000b30c:	2320      	movs	r3, #32
    cospi_wait_idle(cospi);
3000b30e:	4620      	mov	r0, r4
    ospi_writel(COSPI_REG_INDIRECTWR_DONE_MASK,
3000b310:	600b      	str	r3, [r1, #0]
    cospi_wait_idle(cospi);
3000b312:	f7ff fb8f 	bl	3000aa34 <cospi_wait_idle>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b316:	6863      	ldr	r3, [r4, #4]
    cospi_wait_idle(cospi);
3000b318:	4620      	mov	r0, r4
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b31a:	681e      	ldr	r6, [r3, #0]
    cospi_wait_idle(cospi);
3000b31c:	f7ff fb8a 	bl	3000aa34 <cospi_wait_idle>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b320:	6863      	ldr	r3, [r4, #4]
    event_signal(&cospi->complete_event, true);
3000b322:	f104 0048 	add.w	r0, r4, #72	; 0x48
3000b326:	2101      	movs	r1, #1
    reg &= ~COSPI_REG_CONFIG_DMA_MASK;
3000b328:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b32c:	601e      	str	r6, [r3, #0]
    nor->data_error = ret;
3000b32e:	656f      	str	r7, [r5, #84]	; 0x54
    event_signal(&cospi->complete_event, true);
3000b330:	f006 fafc 	bl	3001192c <event_signal>
3000b334:	6fec      	ldr	r4, [r5, #124]	; 0x7c
3000b336:	6862      	ldr	r2, [r4, #4]
    ret = ospi_readl(cospi->apb_base + COSPI_REG_INDIRECTRD);
3000b338:	6e10      	ldr	r0, [r2, #96]	; 0x60
3000b33a:	3260      	adds	r2, #96	; 0x60
    if (!ret)
3000b33c:	2800      	cmp	r0, #0
3000b33e:	d0d5      	beq.n	3000b2ec <cospi_irq_handle+0x14>
    sram_full = ret & COSPI_REG_INDIRECTRD_SRAM_FULL_MASK;
3000b340:	2364      	movs	r3, #100	; 0x64
3000b342:	f000 0008 	and.w	r0, r0, #8
3000b346:	e001      	b.n	3000b34c <cospi_irq_handle+0x74>
    while (count < times) {
3000b348:	3b01      	subs	r3, #1
3000b34a:	d02b      	beq.n	3000b3a4 <cospi_irq_handle+0xcc>
        val = readl(reg);
3000b34c:	6811      	ldr	r1, [r2, #0]
        if (val == mask) {
3000b34e:	0689      	lsls	r1, r1, #26
3000b350:	d5fa      	bpl.n	3000b348 <cospi_irq_handle+0x70>
    ret = cospi_wait_for_bit_times(cospi->apb_base + COSPI_REG_INDIRECTRD,
3000b352:	2700      	movs	r7, #0
    ospi_writel(COSPI_REG_INDIRECTRD_DONE_MASK | sram_full,
3000b354:	f040 0020 	orr.w	r0, r0, #32
    if (nor->data_cmd.queue_mode_en) {
3000b358:	f895 105e 	ldrb.w	r1, [r5, #94]	; 0x5e
    ospi_writel(COSPI_REG_INDIRECTRD_DONE_MASK | sram_full,
3000b35c:	6010      	str	r0, [r2, #0]
    if (nor->data_cmd.queue_mode_en) {
3000b35e:	b109      	cbz	r1, 3000b364 <cospi_irq_handle+0x8c>
        ospi_writel(COSPI_REG_INDIRECTRD_DONE_MASK,
3000b360:	2320      	movs	r3, #32
3000b362:	6013      	str	r3, [r2, #0]
    cospi_wait_idle(cospi);
3000b364:	4620      	mov	r0, r4
3000b366:	f7ff fb65 	bl	3000aa34 <cospi_wait_idle>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b36a:	6863      	ldr	r3, [r4, #4]
    cospi_wait_idle(cospi);
3000b36c:	4620      	mov	r0, r4
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b36e:	681e      	ldr	r6, [r3, #0]
    cospi_wait_idle(cospi);
3000b370:	f7ff fb60 	bl	3000aa34 <cospi_wait_idle>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b374:	6863      	ldr	r3, [r4, #4]
    event_signal(&cospi->complete_event, true);
3000b376:	f104 0048 	add.w	r0, r4, #72	; 0x48
3000b37a:	2101      	movs	r1, #1
    reg &= ~COSPI_REG_CONFIG_DMA_MASK;
3000b37c:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b380:	601e      	str	r6, [r3, #0]
    nor->data_error = ret;
3000b382:	656f      	str	r7, [r5, #84]	; 0x54
    event_signal(&cospi->complete_event, true);
3000b384:	f006 fad2 	bl	3001192c <event_signal>
}
3000b388:	2000      	movs	r0, #0
3000b38a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "ospi ecc error detected!\n");
3000b38c:	f24e 6018 	movw	r0, #58904	; 0xe618
3000b390:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000b394:	f00a fc0c 	bl	30015bb0 <_printf>
3000b398:	e7a6      	b.n	3000b2e8 <cospi_irq_handle+0x10>
        ospi_writel(COSPI_REG_INDIRECTWR_CANCEL_MASK,
3000b39a:	2302      	movs	r3, #2
    ret = cospi_wait_for_bit_times(cospi->apb_base + COSPI_REG_INDIRECTWR,
3000b39c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        ospi_writel(COSPI_REG_INDIRECTWR_CANCEL_MASK,
3000b3a0:	600b      	str	r3, [r1, #0]
3000b3a2:	e7b3      	b.n	3000b30c <cospi_irq_handle+0x34>
        ospi_writel(COSPI_REG_INDIRECTRD_CANCEL_MASK,
3000b3a4:	2302      	movs	r3, #2
    ret = cospi_wait_for_bit_times(cospi->apb_base + COSPI_REG_INDIRECTRD,
3000b3a6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        ospi_writel(COSPI_REG_INDIRECTRD_CANCEL_MASK,
3000b3aa:	6013      	str	r3, [r2, #0]
3000b3ac:	e7d2      	b.n	3000b354 <cospi_irq_handle+0x7c>
3000b3ae:	bf00      	nop

3000b3b0 <cospi_phy_training>:
{
3000b3b0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct cospi_pdata *cospi = nor->priv_data;
3000b3b4:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
{
3000b3b6:	4607      	mov	r7, r0
    cospi_wait_idle(cospi);
3000b3b8:	4628      	mov	r0, r5
{
3000b3ba:	b083      	sub	sp, #12
3000b3bc:	4689      	mov	r9, r1
    cospi_wait_idle(cospi);
3000b3be:	f7ff fb39 	bl	3000aa34 <cospi_wait_idle>
    if (nor->dtr_en || nor->ddr_training) {
3000b3c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    udelay(1);
3000b3c4:	2001      	movs	r0, #1
    ospi_writel(COSPI_REG_PHYCONFIG_RX_BYPASS,
3000b3c6:	f04f 5600 	mov.w	r6, #536870912	; 0x20000000
    if (nor->dtr_en || nor->ddr_training) {
3000b3ca:	f013 2fff 	tst.w	r3, #4278255360	; 0xff00ff00
        ospi_writel(0x4, cospi->apb_base + 0x110);
3000b3ce:	bf14      	ite	ne
3000b3d0:	2204      	movne	r2, #4
        ospi_writel(0xc, cospi->apb_base + 0x110);
3000b3d2:	220c      	moveq	r2, #12
3000b3d4:	686b      	ldr	r3, [r5, #4]
3000b3d6:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    udelay(1);
3000b3da:	f008 ff09 	bl	300141f0 <spin>
    struct cospi_pdata *cospi = nor->priv_data;
3000b3de:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
    ospi_writel(0, cospi->apb_base + COSPI_REG_READCAPTURE);
3000b3e0:	686a      	ldr	r2, [r5, #4]
3000b3e2:	2300      	movs	r3, #0
        nor->phy_en = true;
3000b3e4:	2101      	movs	r1, #1
        cospi->phy_mode = COSPI_PHY_MASTER_DLL;
3000b3e6:	2002      	movs	r0, #2
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b3e8:	6865      	ldr	r5, [r4, #4]
    ospi_writel(0, cospi->apb_base + COSPI_REG_READCAPTURE);
3000b3ea:	6113      	str	r3, [r2, #16]
    ospi_writel(COSPI_REG_PHYCONFIG_RX_BYPASS,
3000b3ec:	f8c2 60b4 	str.w	r6, [r2, #180]	; 0xb4
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b3f0:	682d      	ldr	r5, [r5, #0]
        nor->phy_en = true;
3000b3f2:	f887 1028 	strb.w	r1, [r7, #40]	; 0x28
        cospi->capture_delay = 0;
3000b3f6:	f884 30b7 	strb.w	r3, [r4, #183]	; 0xb7
        if (nor->dtr_en) {
3000b3fa:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
        cospi->phy_mode = COSPI_PHY_MASTER_DLL;
3000b3fe:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4
        if (nor->dtr_en) {
3000b402:	2b00      	cmp	r3, #0
3000b404:	f000 8091 	beq.w	3000b52a <cospi_phy_training+0x17a>
            if (cospi->ref_clk_hz / 2 >= 130000000)
3000b408:	f644 03ff 	movw	r3, #18687	; 0x48ff
3000b40c:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
3000b410:	f6c0 737f 	movt	r3, #3967	; 0xf7f
            cospi->dqs_en = 1;
3000b414:	f884 10b4 	strb.w	r1, [r4, #180]	; 0xb4
    if (cospi_wait_idle(cospi)) {
3000b418:	4620      	mov	r0, r4
            if (cospi->ref_clk_hz / 2 >= 130000000)
3000b41a:	429a      	cmp	r2, r3
                g_dummy = 1;
3000b41c:	f247 52ac 	movw	r2, #30124	; 0x75ac
3000b420:	bf8c      	ite	hi
3000b422:	2301      	movhi	r3, #1
                g_dummy = 0;
3000b424:	2300      	movls	r3, #0
3000b426:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000b42a:	9201      	str	r2, [sp, #4]
3000b42c:	6013      	str	r3, [r2, #0]
    if (cospi_wait_idle(cospi)) {
3000b42e:	f7ff fb01 	bl	3000aa34 <cospi_wait_idle>
3000b432:	2800      	cmp	r0, #0
3000b434:	d17e      	bne.n	3000b534 <cospi_phy_training+0x184>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b436:	6863      	ldr	r3, [r4, #4]
        reg |= COSPI_REG_CONFIG_ENABLE_PHY_MASK;
3000b438:	f045 0508 	orr.w	r5, r5, #8
    udelay(1);
3000b43c:	2001      	movs	r0, #1
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b43e:	601d      	str	r5, [r3, #0]
    udelay(1);
3000b440:	f008 fed6 	bl	300141f0 <spin>
    cospi_phy_config(nor);
3000b444:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
    switch (cospi->phy_mode) {
3000b446:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
3000b44a:	2b01      	cmp	r3, #1
3000b44c:	d07d      	beq.n	3000b54a <cospi_phy_training+0x19a>
3000b44e:	2b02      	cmp	r3, #2
3000b450:	f000 8082 	beq.w	3000b558 <cospi_phy_training+0x1a8>
    cospi_capture_set(nor);
3000b454:	4638      	mov	r0, r7
3000b456:	f7ff fa61 	bl	3000a91c <cospi_capture_set>
    struct cospi_pdata *cospi = nor->priv_data;
3000b45a:	6ffd      	ldr	r5, [r7, #124]	; 0x7c
    if (cospi->phy_mode == COSPI_PHY_NONE)
3000b45c:	f8d5 40c4 	ldr.w	r4, [r5, #196]	; 0xc4
3000b460:	2c00      	cmp	r4, #0
3000b462:	d05e      	beq.n	3000b522 <cospi_phy_training+0x172>
    if (cospi->phy_mode == COSPI_PHY_BYPASS_DLL) {
3000b464:	2c01      	cmp	r4, #1
3000b466:	f897 2029 	ldrb.w	r2, [r7, #41]	; 0x29
3000b46a:	f000 80af 	beq.w	3000b5cc <cospi_phy_training+0x21c>
        if (nor->dtr_en) {
3000b46e:	2a00      	cmp	r2, #0
3000b470:	bf0c      	ite	eq
3000b472:	f44f 187c 	moveq.w	r8, #4128768	; 0x3f0000
3000b476:	f44f 18f8 	movne.w	r8, #2031616	; 0x1f0000
3000b47a:	f04f 0b00 	mov.w	r11, #0
    bool train_ok = 0;
3000b47e:	465e      	mov	r6, r11
    u8 rx_delay_start = 0;
3000b480:	f8cd b000 	str.w	r11, [r13]
3000b484:	e00a      	b.n	3000b49c <cospi_phy_training+0xec>
            if (train_ok == 0) {
3000b486:	b90e      	cbnz	r6, 3000b48c <cospi_phy_training+0xdc>
3000b488:	9400      	str	r4, [sp, #0]
                train_ok = 1;
3000b48a:	2601      	movs	r6, #1
3000b48c:	f10b 0b01 	add.w	r11, r11, #1
3000b490:	3401      	adds	r4, #1
    for (rx_delay = 0; rx_delay <= 0x7f; rx_delay++) {
3000b492:	f1bb 0f80 	cmp.w	r11, #128	; 0x80
3000b496:	b2e4      	uxtb	r4, r4
3000b498:	f000 80b4 	beq.w	3000b604 <cospi_phy_training+0x254>
        udelay(1);
3000b49c:	2001      	movs	r0, #1
              (tx_delay << COSPI_REG_PHYCONFIG_TX_DELAY_LSB) |
3000b49e:	ea48 040b 	orr.w	r4, r8, r11
        reg = (COSPI_REG_PHYCONFIG_RST & ~COSPI_REG_PHYCONFIG_RESYNC) |
3000b4a2:	f044 4a80 	orr.w	r10, r4, #1073741824	; 0x40000000
        udelay(1);
3000b4a6:	f008 fea3 	bl	300141f0 <spin>
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b4aa:	686a      	ldr	r2, [r5, #4]
        udelay(1);
3000b4ac:	2001      	movs	r0, #1
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b4ae:	f8c2 a0b4 	str.w	r10, [r2, #180]	; 0xb4
        reg |= COSPI_REG_PHYCONFIG_RESYNC;
3000b4b2:	f044 4440 	orr.w	r4, r4, #3221225472	; 0xc0000000
        udelay(1);
3000b4b6:	f008 fe9b 	bl	300141f0 <spin>
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b4ba:	686a      	ldr	r2, [r5, #4]
3000b4bc:	f8c2 40b4 	str.w	r4, [r2, #180]	; 0xb4
        udelay(1);
3000b4c0:	2001      	movs	r0, #1
3000b4c2:	f008 fe95 	bl	300141f0 <spin>
        if (check_callback(nor) == 0) {
3000b4c6:	4638      	mov	r0, r7
3000b4c8:	fa5f f48b 	uxtb.w	r4, r11
3000b4cc:	47c8      	blx	r9
3000b4ce:	2800      	cmp	r0, #0
3000b4d0:	d0d9      	beq.n	3000b486 <cospi_phy_training+0xd6>
            if (train_ok && (rx_delay > (rx_delay_start + 10)))
3000b4d2:	9b00      	ldr	r3, [sp, #0]
3000b4d4:	f103 020a 	add.w	r2, r3, #10
3000b4d8:	2e00      	cmp	r6, #0
3000b4da:	d0d7      	beq.n	3000b48c <cospi_phy_training+0xdc>
                train_ok = 0;
3000b4dc:	2600      	movs	r6, #0
            if (train_ok && (rx_delay > (rx_delay_start + 10)))
3000b4de:	4593      	cmp	r11, r2
3000b4e0:	4659      	mov	r1, r11
3000b4e2:	ddd3      	ble.n	3000b48c <cospi_phy_training+0xdc>
        rx_delay = (rx_delay_start + rx_delay) / 2;
3000b4e4:	9b00      	ldr	r3, [sp, #0]
        ret = 0;
3000b4e6:	2400      	movs	r4, #0
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b4e8:	686a      	ldr	r2, [r5, #4]
        rx_delay = (rx_delay_start + rx_delay) / 2;
3000b4ea:	440b      	add	r3, r1
3000b4ec:	469a      	mov	r10, r3
        cospi->phy_training_succ = true;
3000b4ee:	2301      	movs	r3, #1
        udelay(1);
3000b4f0:	4618      	mov	r0, r3
        cospi->phy_training_succ = true;
3000b4f2:	f885 30c8 	strb.w	r3, [r5, #200]	; 0xc8
            (tx_delay << COSPI_REG_PHYCONFIG_TX_DELAY_LSB) |
3000b4f6:	ea48 086a 	orr.w	r8, r8, r10, asr #1
        reg = (COSPI_REG_PHYCONFIG_RST & ~COSPI_REG_PHYCONFIG_RESYNC) |
3000b4fa:	f048 4180 	orr.w	r1, r8, #1073741824	; 0x40000000
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b4fe:	f8c2 10b4 	str.w	r1, [r2, #180]	; 0xb4
        udelay(1);
3000b502:	f008 fe75 	bl	300141f0 <spin>
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b506:	686a      	ldr	r2, [r5, #4]
        dprintf(CRITICAL, "ospi phy training pass!\n");
3000b508:	f24e 6034 	movw	r0, #58932	; 0xe634
        reg |= COSPI_REG_PHYCONFIG_RESYNC;
3000b50c:	f048 4340 	orr.w	r3, r8, #3221225472	; 0xc0000000
        dprintf(CRITICAL, "ospi phy training pass!\n");
3000b510:	f2c3 0001 	movt	r0, #12289	; 0x3001
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b514:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
        dprintf(CRITICAL, "ospi phy training pass!\n");
3000b518:	f00a fb4a 	bl	30015bb0 <_printf>
    cospi_wait_idle(cospi);
3000b51c:	4628      	mov	r0, r5
3000b51e:	f7ff fa89 	bl	3000aa34 <cospi_wait_idle>
}
3000b522:	4620      	mov	r0, r4
3000b524:	b003      	add	sp, #12
3000b526:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (cospi->ref_clk_hz / 2 >= 130000000)
3000b52a:	f644 03ff 	movw	r3, #18687	; 0x48ff
            cospi->dqs_en = nor->dqs_en;
3000b52e:	f897 102a 	ldrb.w	r1, [r7, #42]	; 0x2a
3000b532:	e76b      	b.n	3000b40c <cospi_phy_training+0x5c>
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000b534:	f24e 607c 	movw	r0, #59004	; 0xe67c
3000b538:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000b53c:	f00a fb38 	bl	30015bb0 <_printf>
    cospi_phy_config(nor);
3000b540:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
    switch (cospi->phy_mode) {
3000b542:	f8d4 30c4 	ldr.w	r3, [r4, #196]	; 0xc4
3000b546:	2b01      	cmp	r3, #1
3000b548:	d181      	bne.n	3000b44e <cospi_phy_training+0x9e>
        ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYMASTERCTL);
3000b54a:	6862      	ldr	r2, [r4, #4]
3000b54c:	2304      	movs	r3, #4
3000b54e:	f2c0 0380 	movt	r3, #128	; 0x80
3000b552:	f8c2 30b8 	str.w	r3, [r2, #184]	; 0xb8
3000b556:	e77d      	b.n	3000b454 <cospi_phy_training+0xa4>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b558:	6863      	ldr	r3, [r4, #4]
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYMASTERCTL);
3000b55a:	2104      	movs	r1, #4
    udelay(1);
3000b55c:	2001      	movs	r0, #1
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b55e:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
    reg &= ~COSPI_REG_PHYCONFIG_RST;
3000b562:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b566:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYMASTERCTL);
3000b56a:	f8c3 10b8 	str.w	r1, [r3, #184]	; 0xb8
    udelay(1);
3000b56e:	f008 fe3f 	bl	300141f0 <spin>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b572:	6865      	ldr	r5, [r4, #4]
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYDLLOBS);
3000b574:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYDLLOBS);
3000b578:	f105 01bc 	add.w	r1, r5, #188	; 0xbc
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b57c:	f8d5 20b4 	ldr.w	r2, [r5, #180]	; 0xb4
    reg |= COSPI_REG_PHYCONFIG_RST;
3000b580:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b584:	f8c5 20b4 	str.w	r2, [r5, #180]	; 0xb4
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYDLLOBS);
3000b588:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYDLLOBS);
3000b58c:	f8d5 20bc 	ldr.w	r2, [r5, #188]	; 0xbc
3000b590:	e001      	b.n	3000b596 <cospi_phy_training+0x1e6>
    while (count < times) {
3000b592:	3b01      	subs	r3, #1
3000b594:	d002      	beq.n	3000b59c <cospi_phy_training+0x1ec>
        val = readl(reg);
3000b596:	680a      	ldr	r2, [r1, #0]
        if (val == mask) {
3000b598:	0412      	lsls	r2, r2, #16
3000b59a:	d5fa      	bpl.n	3000b592 <cospi_phy_training+0x1e2>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_PHYDLLOBS);
3000b59c:	f8d5 30bc 	ldr.w	r3, [r5, #188]	; 0xbc
    udelay(1);
3000b5a0:	2001      	movs	r0, #1
3000b5a2:	f008 fe25 	bl	300141f0 <spin>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b5a6:	2320      	movs	r3, #32
3000b5a8:	6862      	ldr	r2, [r4, #4]
3000b5aa:	f2c6 0320 	movt	r3, #24608	; 0x6020
    udelay(10);
3000b5ae:	200a      	movs	r0, #10
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b5b0:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
    udelay(10);
3000b5b4:	f008 fe1c 	bl	300141f0 <spin>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b5b8:	2320      	movs	r3, #32
3000b5ba:	6862      	ldr	r2, [r4, #4]
3000b5bc:	f2cc 0320 	movt	r3, #49184	; 0xc020
    udelay(10);
3000b5c0:	200a      	movs	r0, #10
    ospi_writel(reg, cospi->apb_base + COSPI_REG_PHYCONFIG);
3000b5c2:	f8c2 30b4 	str.w	r3, [r2, #180]	; 0xb4
    udelay(10);
3000b5c6:	f008 fe13 	bl	300141f0 <spin>
3000b5ca:	e743      	b.n	3000b454 <cospi_phy_training+0xa4>
        ref_clock_per = 1000000 / (cospi->ref_clk_hz / 1000000);
3000b5cc:	f64d 6083 	movw	r0, #56963	; 0xde83
3000b5d0:	f244 2340 	movw	r3, #16960	; 0x4240
3000b5d4:	f8d5 10ac 	ldr.w	r1, [r5, #172]	; 0xac
3000b5d8:	f2c4 301b 	movt	r0, #17179	; 0x431b
            tx_delay = ref_clock_per / 4 / 164;
3000b5dc:	f640 487d 	movw	r8, #3197	; 0xc7d
        ref_clock_per = 1000000 / (cospi->ref_clk_hz / 1000000);
3000b5e0:	f2c0 030f 	movt	r3, #15
            tx_delay = ref_clock_per / 4 / 164;
3000b5e4:	f2cc 78ce 	movt	r8, #51150	; 0xc7ce
        ref_clock_per = 1000000 / (cospi->ref_clk_hz / 1000000);
3000b5e8:	fba0 0101 	umull	r0, r1, r0, r1
3000b5ec:	0c89      	lsrs	r1, r1, #18
3000b5ee:	fbb3 f3f1 	udiv	r3, r3, r1
        if (nor->dtr_en) {
3000b5f2:	2a00      	cmp	r2, #0
3000b5f4:	d03f      	beq.n	3000b676 <cospi_phy_training+0x2c6>
            tx_delay = ref_clock_per / 4 / 164;
3000b5f6:	fba8 2303 	umull	r2, r3, r8, r3
3000b5fa:	ea4f 18c3 	mov.w	r8, r3, lsl #7
3000b5fe:	f408 087f 	and.w	r8, r8, #16711680	; 0xff0000
3000b602:	e73a      	b.n	3000b47a <cospi_phy_training+0xca>
    if (train_ok) {
3000b604:	2e00      	cmp	r6, #0
3000b606:	d13d      	bne.n	3000b684 <cospi_phy_training+0x2d4>
    struct cospi_pdata *cospi = nor->priv_data;
3000b608:	6ffc      	ldr	r4, [r7, #124]	; 0x7c
        if (nor->dtr_en)
3000b60a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b60e:	6862      	ldr	r2, [r4, #4]
3000b610:	f8d2 8000 	ldr.w	r8, [r2]
        nor->phy_en = false;
3000b614:	f887 6028 	strb.w	r6, [r7, #40]	; 0x28
        cospi->phy_mode = COSPI_PHY_NONE;
3000b618:	f8c4 60c4 	str.w	r6, [r4, #196]	; 0xc4
        cospi->dqs_en = 0;
3000b61c:	f884 60b4 	strb.w	r6, [r4, #180]	; 0xb4
        cospi->rclk_loopback = 0;
3000b620:	f884 60b5 	strb.w	r6, [r4, #181]	; 0xb5
        if (nor->dtr_en)
3000b624:	b1e3      	cbz	r3, 3000b660 <cospi_phy_training+0x2b0>
            cospi->master_delay = 2;
3000b626:	2302      	movs	r3, #2
3000b628:	2203      	movs	r2, #3
3000b62a:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
        g_dummy = 0;
3000b62e:	2300      	movs	r3, #0
    if (cospi_wait_idle(cospi)) {
3000b630:	4620      	mov	r0, r4
        cospi->capture_delay = cospi->master_delay +
3000b632:	f884 20b7 	strb.w	r2, [r4, #183]	; 0xb7
        g_dummy = 0;
3000b636:	9a01      	ldr	r2, [sp, #4]
3000b638:	6013      	str	r3, [r2, #0]
    if (cospi_wait_idle(cospi)) {
3000b63a:	f7ff f9fb 	bl	3000aa34 <cospi_wait_idle>
3000b63e:	b998      	cbnz	r0, 3000b668 <cospi_phy_training+0x2b8>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b640:	6862      	ldr	r2, [r4, #4]
        reg &= ~COSPI_REG_CONFIG_ENABLE_PHY_MASK;
3000b642:	f028 0308 	bic.w	r3, r8, #8
    udelay(1);
3000b646:	2001      	movs	r0, #1
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b648:	6013      	str	r3, [r2, #0]
    udelay(1);
3000b64a:	f008 fdd1 	bl	300141f0 <spin>
        dprintf(CRITICAL, "ospi phy training failed, exit phy mode!\n");
3000b64e:	f24e 6050 	movw	r0, #58960	; 0xe650
        ret = -1;
3000b652:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "ospi phy training failed, exit phy mode!\n");
3000b656:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000b65a:	f00a faa9 	bl	30015bb0 <_printf>
3000b65e:	e75d      	b.n	3000b51c <cospi_phy_training+0x16c>
            cospi->master_delay = 0;
3000b660:	f884 60b6 	strb.w	r6, [r4, #182]	; 0xb6
3000b664:	2201      	movs	r2, #1
3000b666:	e7e2      	b.n	3000b62e <cospi_phy_training+0x27e>
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000b668:	f24e 607c 	movw	r0, #59004	; 0xe67c
3000b66c:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000b670:	f00a fa9e 	bl	30015bb0 <_printf>
3000b674:	e7eb      	b.n	3000b64e <cospi_phy_training+0x29e>
            tx_delay = ref_clock_per / 2 / 164;
3000b676:	fba8 2303 	umull	r2, r3, r8, r3
3000b67a:	ea4f 2803 	mov.w	r8, r3, lsl #8
3000b67e:	f408 087f 	and.w	r8, r8, #16711680	; 0xff0000
3000b682:	e6fa      	b.n	3000b47a <cospi_phy_training+0xca>
3000b684:	4621      	mov	r1, r4
3000b686:	e72d      	b.n	3000b4e4 <cospi_phy_training+0x134>

3000b688 <cospi_baudrate_set>:
{
3000b688:	b538      	push	{r3, r4, r5, r14}
    struct cospi_pdata *cospi = nor->priv_data;
3000b68a:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
    cospi_wait_idle(cospi);
3000b68c:	4628      	mov	r0, r5
    div = DIV_ROUND_UP(cospi->ref_clk_hz, 2 * cospi->sclk) - 1;
3000b68e:	e9d5 342b 	ldrd	r3, r4, [r5, #172]	; 0xac
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b692:	6869      	ldr	r1, [r5, #4]
    div = DIV_ROUND_UP(cospi->ref_clk_hz, 2 * cospi->sclk) - 1;
3000b694:	0062      	lsls	r2, r4, #1
3000b696:	1e5c      	subs	r4, r3, #1
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b698:	680b      	ldr	r3, [r1, #0]
    div = DIV_ROUND_UP(cospi->ref_clk_hz, 2 * cospi->sclk) - 1;
3000b69a:	4414      	add	r4, r2
3000b69c:	fbb4 f4f2 	udiv	r4, r4, r2
    reg &= ~(COSPI_REG_CONFIG_BAUD_MASK << COSPI_REG_CONFIG_BAUD_LSB);
3000b6a0:	f423 03f0 	bic.w	r3, r3, #7864320	; 0x780000
    div = DIV_ROUND_UP(cospi->ref_clk_hz, 2 * cospi->sclk) - 1;
3000b6a4:	3c01      	subs	r4, #1
    reg |= (div & COSPI_REG_CONFIG_BAUD_MASK) << COSPI_REG_CONFIG_BAUD_LSB;
3000b6a6:	04e4      	lsls	r4, r4, #19
3000b6a8:	f404 04f0 	and.w	r4, r4, #7864320	; 0x780000
3000b6ac:	431c      	orrs	r4, r3
    cospi_wait_idle(cospi);
3000b6ae:	f7ff f9c1 	bl	3000aa34 <cospi_wait_idle>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b6b2:	686b      	ldr	r3, [r5, #4]
3000b6b4:	601c      	str	r4, [r3, #0]
}
3000b6b6:	bd38      	pop	{r3, r4, r5, r15}

3000b6b8 <cospi_lock>:
{
3000b6b8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000b6ba:	4604      	mov	r4, r0
status_t mutex_acquire_timeout(mutex_t *, lk_time_t); /* try to acquire the mutex with a timeout value */
status_t mutex_release(mutex_t *);

static inline status_t mutex_acquire(mutex_t *m)
{
    return mutex_acquire_timeout(m, INFINITE_TIME);
3000b6bc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    mutex_acquire(&cospi->bus_mutex);
3000b6c0:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
3000b6c2:	3010      	adds	r0, #16
3000b6c4:	f006 f9b2 	bl	30011a2c <mutex_acquire_timeout>
    size_changed = ((cospi->block_power_index != log2_uint(nor->block_size)) ||
3000b6c8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    struct cospi_pdata *cospi = nor->priv_data;
3000b6ca:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
    size_changed = ((cospi->block_power_index != log2_uint(nor->block_size)) ||
3000b6cc:	f895 20a6 	ldrb.w	r2, [r5, #166]	; 0xa6
    return ((val - 1) & val) == 0;
}

static inline __ALWAYS_INLINE uint log2_uint(uint val)
{
    if (val == 0)
3000b6d0:	b11b      	cbz	r3, 3000b6da <cospi_lock+0x22>
        return 0; // undefined

    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
3000b6d2:	fab3 f383 	clz	r3, r3
3000b6d6:	f1c3 031f 	rsb	r3, r3, #31
3000b6da:	6be1      	ldr	r1, [r4, #60]	; 0x3c
3000b6dc:	429a      	cmp	r2, r3
3000b6de:	d07c      	beq.n	3000b7da <cospi_lock+0x122>
    cospi->addr_bytes = 0;
3000b6e0:	2000      	movs	r0, #0
    reg |= (cospi->page_size << COSPI_REG_SIZE_PAGE_LSB);
3000b6e2:	010a      	lsls	r2, r1, #4
    cospi->block_power_index = log2_uint(nor->block_size);
3000b6e4:	f885 30a6 	strb.w	r3, [r5, #166]	; 0xa6
    reg |= (cospi->page_size << COSPI_REG_SIZE_PAGE_LSB);
3000b6e8:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
    ospi_writel(reg, cospi->apb_base + COSPI_REG_SIZE);
3000b6ec:	686b      	ldr	r3, [r5, #4]
    cospi->page_size = nor->page_size;
3000b6ee:	f8c5 10a8 	str.w	r1, [r5, #168]	; 0xa8
    ospi_writel(reg, cospi->apb_base + COSPI_REG_SIZE);
3000b6f2:	615a      	str	r2, [r3, #20]
    cospi->addr_bytes = 0;
3000b6f4:	f885 00b8 	strb.w	r0, [r5, #184]	; 0xb8
    if (cospi->current_cs != nor->cs) {
3000b6f8:	f894 6020 	ldrb.w	r6, [r4, #32]
3000b6fc:	f895 30a5 	ldrb.w	r3, [r5, #165]	; 0xa5
3000b700:	42b3      	cmp	r3, r6
3000b702:	d069      	beq.n	3000b7d8 <cospi_lock+0x120>
    cospi_wait_idle(cospi);
3000b704:	4628      	mov	r0, r5
3000b706:	f7ff f995 	bl	3000aa34 <cospi_wait_idle>
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b70a:	686a      	ldr	r2, [r5, #4]
    if (cospi->cs_decoded) {
3000b70c:	f895 10a4 	ldrb.w	r1, [r5, #164]	; 0xa4
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b710:	6813      	ldr	r3, [r2, #0]
    if (cospi->cs_decoded) {
3000b712:	2900      	cmp	r1, #0
3000b714:	d15d      	bne.n	3000b7d2 <cospi_lock+0x11a>
        cs = ~(1 << cs);
3000b716:	2101      	movs	r1, #1
        reg &= ~COSPI_REG_CONFIG_DECODE_MASK;
3000b718:	f423 7300 	bic.w	r3, r3, #512	; 0x200
        cs = ~(1 << cs);
3000b71c:	fa01 f606 	lsl.w	r6, r1, r6
3000b720:	43f6      	mvns	r6, r6
3000b722:	b2f6      	uxtb	r6, r6
    reg &= ~COSPI_REG_CONFIG_DTR_ENABLE_MASK;
3000b724:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    reg |= (nor->dtr_en << COSPI_REG_CONFIG_DTR_ENABLE_LSB);
3000b728:	f894 1029 	ldrb.w	r1, [r4, #41]	; 0x29
           << COSPI_REG_CONFIG_CHIPSELECT_LSB;
3000b72c:	02b6      	lsls	r6, r6, #10
    reg |= (nor->dtr_en << COSPI_REG_CONFIG_DTR_ENABLE_LSB);
3000b72e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    reg &=
3000b732:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
        cospi_baudrate_set(nor);
3000b736:	4620      	mov	r0, r4
           << COSPI_REG_CONFIG_CHIPSELECT_LSB;
3000b738:	f406 5670 	and.w	r6, r6, #15360	; 0x3c00
    reg |= (cs & COSPI_REG_CONFIG_CHIPSELECT_MASK)
3000b73c:	431e      	orrs	r6, r3
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b73e:	6016      	str	r6, [r2, #0]
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b740:	f64d 6683 	movw	r6, #56963	; 0xde83
        cospi_baudrate_set(nor);
3000b744:	f7ff ffa0 	bl	3000b688 <cospi_baudrate_set>
    struct cospi_pdata *cospi = nor->priv_data;
3000b748:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b74a:	f644 5ed3 	movw	r14, #19923	; 0x4dd3
        cospi_capture_set(nor);
3000b74e:	4620      	mov	r0, r4
    csda = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csda_ns);
3000b750:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b752:	f2c1 0e62 	movt	r14, #4194	; 0x1062
3000b756:	f8d1 20ac 	ldr.w	r2, [r1, #172]	; 0xac
3000b75a:	f2c4 361b 	movt	r6, #17179	; 0x431b
    ospi_writel(reg, cospi->apb_base + COSPI_REG_DELAY);
3000b75e:	684d      	ldr	r5, [r1, #4]
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b760:	fbae 1202 	umull	r1, r2, r14, r2
    cseot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cseot_ns);
3000b764:	e9d4 1710 	ldrd	r1, r7, [r4, #64]	; 0x40
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b768:	ea4f 1e92 	mov.w	r14, r2, lsr #6
    csdads = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csdads_ns);
3000b76c:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    csda = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csda_ns);
3000b76e:	fb03 fc0e 	mul.w	r12, r3, r14
    cseot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cseot_ns);
3000b772:	fb07 f40e 	mul.w	r4, r7, r14
    csdads = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csdads_ns);
3000b776:	fb02 f20e 	mul.w	r2, r2, r14
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b77a:	fb01 f10e 	mul.w	r1, r1, r14
    csda = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csda_ns);
3000b77e:	f50c 2774 	add.w	r7, r12, #999424	; 0xf4000
3000b782:	f507 7710 	add.w	r7, r7, #576	; 0x240
    cseot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cseot_ns);
3000b786:	f504 2474 	add.w	r4, r4, #999424	; 0xf4000
    csdads = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csdads_ns);
3000b78a:	f502 2374 	add.w	r3, r2, #999424	; 0xf4000
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b78e:	f501 2174 	add.w	r1, r1, #999424	; 0xf4000
    cseot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cseot_ns);
3000b792:	f504 7410 	add.w	r4, r4, #576	; 0x240
    csda = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csda_ns);
3000b796:	fba6 2707 	umull	r2, r7, r6, r7
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b79a:	f501 7110 	add.w	r1, r1, #576	; 0x240
    csdads = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csdads_ns);
3000b79e:	f503 7310 	add.w	r3, r3, #576	; 0x240
    cseot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cseot_ns);
3000b7a2:	fba6 2404 	umull	r2, r4, r6, r4
    cssot = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->cssot_ns);
3000b7a6:	fba6 2101 	umull	r2, r1, r6, r1
    csdads = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csdads_ns);
3000b7aa:	fba6 2303 	umull	r2, r3, r6, r3
    csda = OSPI_NS_2_TICKS(cospi->ref_clk_hz, nor->csda_ns);
3000b7ae:	0cbf      	lsrs	r7, r7, #18
    reg = (cssot & COSPI_REG_DELAY_CSSOT_MASK) << COSPI_REG_DELAY_CSSOT_LSB;
3000b7b0:	f3c1 4187 	ubfx	r1, r1, #18, #8
    reg |= (cseot & COSPI_REG_DELAY_CSEOT_MASK) << COSPI_REG_DELAY_CSEOT_LSB;
3000b7b4:	0aa4      	lsrs	r4, r4, #10
3000b7b6:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
3000b7ba:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
    reg |= (csdads & COSPI_REG_DELAY_CSDADS_MASK) << COSPI_REG_DELAY_CSDADS_LSB;
3000b7be:	089b      	lsrs	r3, r3, #2
3000b7c0:	4321      	orrs	r1, r4
3000b7c2:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    reg |= (csda & COSPI_REG_DELAY_CSDA_MASK) << COSPI_REG_DELAY_CSDA_LSB;
3000b7c6:	430b      	orrs	r3, r1
    ospi_writel(reg, cospi->apb_base + COSPI_REG_DELAY);
3000b7c8:	60eb      	str	r3, [r5, #12]
}
3000b7ca:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
        cospi_capture_set(nor);
3000b7ce:	f7ff b8a5 	b.w	3000a91c <cospi_capture_set>
        reg |= COSPI_REG_CONFIG_DECODE_MASK;
3000b7d2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
3000b7d6:	e7a5      	b.n	3000b724 <cospi_lock+0x6c>
}
3000b7d8:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    size_changed = ((cospi->block_power_index != log2_uint(nor->block_size)) ||
3000b7da:	f8d5 20a8 	ldr.w	r2, [r5, #168]	; 0xa8
3000b7de:	428a      	cmp	r2, r1
3000b7e0:	f47f af7e 	bne.w	3000b6e0 <cospi_lock+0x28>
3000b7e4:	e788      	b.n	3000b6f8 <cospi_lock+0x40>
3000b7e6:	bf00      	nop

3000b7e8 <spi_nor_host_init>:
{
3000b7e8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000b7ea:	4605      	mov	r5, r0
    nor->priv_data = cospi;
3000b7ec:	f247 54b0 	movw	r4, #30128	; 0x75b0
    g_dummy = 0;
3000b7f0:	2300      	movs	r3, #0
    nor->priv_data = cospi;
3000b7f2:	f2c3 0402 	movt	r4, #12290	; 0x3002
    cospi->capture_delay = COSPI_READCAPTURE_DELAY_DEFAULT;
3000b7f6:	2201      	movs	r2, #1
    cospi->current_cs = 0xff;
3000b7f8:	f04f 0cff 	mov.w	r12, #255	; 0xff
    nor->priv_data = cospi;
3000b7fc:	67c4      	str	r4, [r0, #124]	; 0x7c
    cospi->sram_size_nbit = 8;
3000b7fe:	2708      	movs	r7, #8
    cospi->priv = nor;
3000b800:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
    cospi->id = config_data->id;
3000b804:	7901      	ldrb	r1, [r0, #4]
3000b806:	7021      	strb	r1, [r4, #0]
    cospi->fifo_depth = 1 << (cospi->sram_size_nbit - 1);
3000b808:	2680      	movs	r6, #128	; 0x80
    cospi->irq = config_data->irq;
3000b80a:	69a9      	ldr	r1, [r5, #24]
    nor->async_mode = 0;
3000b80c:	f880 302c 	strb.w	r3, [r0, #44]	; 0x2c
    cospi->fifo_width = 4;
3000b810:	2004      	movs	r0, #4
    cospi->irq = config_data->irq;
3000b812:	60e1      	str	r1, [r4, #12]
    cospi->ref_clk_hz = config_data->clk;
3000b814:	68a9      	ldr	r1, [r5, #8]
    nor->phy_en = false;
3000b816:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
    cospi->ref_clk_hz = config_data->clk;
3000b81a:	f8c4 10ac 	str.w	r1, [r4, #172]	; 0xac
    cospi->sclk = config_data->bus_clk;
3000b81e:	68e9      	ldr	r1, [r5, #12]
    cospi->capture_delay = COSPI_READCAPTURE_DELAY_DEFAULT;
3000b820:	f884 20b7 	strb.w	r2, [r4, #183]	; 0xb7
    g_dummy = 0;
3000b824:	f247 52ac 	movw	r2, #30124	; 0x75ac
    cospi->fifo_width = 4;
3000b828:	f884 00bb 	strb.w	r0, [r4, #187]	; 0xbb
    g_dummy = 0;
3000b82c:	f2c3 0202 	movt	r2, #12290	; 0x3002
    cospi->current_cs = 0xff;
3000b830:	f884 c0a5 	strb.w	r12, [r4, #165]	; 0xa5
    if (cospi_wait_idle(cospi)) {
3000b834:	4620      	mov	r0, r4
    cospi->sram_size_nbit = 8;
3000b836:	f884 70b9 	strb.w	r7, [r4, #185]	; 0xb9
    cospi->fifo_depth = 1 << (cospi->sram_size_nbit - 1);
3000b83a:	f884 60ba 	strb.w	r6, [r4, #186]	; 0xba
    cospi->sclk = config_data->bus_clk;
3000b83e:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
    cospi->ahb_base = (addr_t)_ioaddr(config_data->ahb_base);
3000b842:	6969      	ldr	r1, [r5, #20]
3000b844:	60a1      	str	r1, [r4, #8]
    cospi->apb_base = (addr_t)_ioaddr(config_data->apb_base);
3000b846:	6929      	ldr	r1, [r5, #16]
3000b848:	6061      	str	r1, [r4, #4]
    cospi->block_power_index = 0;
3000b84a:	f884 30a6 	strb.w	r3, [r4, #166]	; 0xa6
    cospi->page_size = 0;
3000b84e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    g_dummy = 0;
3000b852:	6013      	str	r3, [r2, #0]
    if (cospi_wait_idle(cospi)) {
3000b854:	f7ff f8ee 	bl	3000aa34 <cospi_wait_idle>
3000b858:	2800      	cmp	r0, #0
3000b85a:	f040 8093 	bne.w	3000b984 <spi_nor_host_init+0x19c>
3000b85e:	4606      	mov	r6, r0
    ospi_writel(7, cospi->apb_base + COSPI_REG_INDIRECTTRIGGER_RANGE);
3000b860:	2207      	movs	r2, #7
    ospi_writel(0, cospi->apb_base + 0x110);
3000b862:	6863      	ldr	r3, [r4, #4]
    cospi->trigger_range_size = 1 << (7 + 2);
3000b864:	f44f 7700 	mov.w	r7, #512	; 0x200
    ospi_writel(0, cospi->apb_base + 0x110);
3000b868:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
    cospi->trigger_address = 0x4000000 - cospi->trigger_range_size;
3000b86c:	f44f 407e 	mov.w	r0, #65024	; 0xfe00
    ospi_writel(0, cospi->apb_base + COSPI_REG_CONFIG);
3000b870:	601e      	str	r6, [r3, #0]
    cospi->trigger_address = 0x4000000 - cospi->trigger_range_size;
3000b872:	f2c0 30ff 	movt	r0, #1023	; 0x3ff
    ospi_writel(0, cospi->apb_base + COSPI_REG_IRQMASK);
3000b876:	645e      	str	r6, [r3, #68]	; 0x44
    ospi_writel(0, cospi->apb_base + COSPI_REG_REMAP);
3000b878:	625e      	str	r6, [r3, #36]	; 0x24
    ospi_writel(7, cospi->apb_base + COSPI_REG_INDIRECTTRIGGER_RANGE);
3000b87a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    nor->page_size = MIN(nor->page_size, cospi->fifo_depth * cospi->fifo_width);
3000b87e:	f894 10bb 	ldrb.w	r1, [r4, #187]	; 0xbb
3000b882:	f894 20ba 	ldrb.w	r2, [r4, #186]	; 0xba
3000b886:	fb12 f201 	smulbb	r2, r2, r1
    nor->page_size = MIN(nor->page_size, cospi->trigger_range_size);
3000b88a:	6be9      	ldr	r1, [r5, #60]	; 0x3c
    cospi->trigger_range_size = 1 << (7 + 2);
3000b88c:	f8c4 70c0 	str.w	r7, [r4, #192]	; 0xc0
    nor->page_size = MIN(nor->page_size, cospi->trigger_range_size);
3000b890:	42ba      	cmp	r2, r7
3000b892:	bf28      	it	cs
3000b894:	463a      	movcs	r2, r7
3000b896:	428a      	cmp	r2, r1
3000b898:	bf28      	it	cs
3000b89a:	460a      	movcs	r2, r1
    register_int_handler(cospi->irq, &cospi_irq_handle, (void *)nor);
3000b89c:	f24b 21d9 	movw	r1, #45785	; 0xb2d9
3000b8a0:	f2c3 0100 	movt	r1, #12288	; 0x3000
    nor->page_size = MIN(nor->page_size, cospi->trigger_range_size);
3000b8a4:	63ea      	str	r2, [r5, #60]	; 0x3c
    cospi->trigger_address = 0x4000000 - cospi->trigger_range_size;
3000b8a6:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    ospi_writel(cospi->trigger_address,
3000b8aa:	61d8      	str	r0, [r3, #28]
    ospi_writel(cospi->fifo_depth, cospi->apb_base + COSPI_REG_SRAMPARTITION);
3000b8ac:	f894 20ba 	ldrb.w	r2, [r4, #186]	; 0xba
3000b8b0:	619a      	str	r2, [r3, #24]
    ospi_writel(cospi->fifo_depth * cospi->fifo_width / 2,
3000b8b2:	f894 20bb 	ldrb.w	r2, [r4, #187]	; 0xbb
3000b8b6:	f894 00ba 	ldrb.w	r0, [r4, #186]	; 0xba
3000b8ba:	fb10 f002 	smulbb	r0, r0, r2
    register_int_handler(cospi->irq, &cospi_irq_handle, (void *)nor);
3000b8be:	462a      	mov	r2, r5
    ospi_writel(cospi->fifo_depth * cospi->fifo_width / 2,
3000b8c0:	1040      	asrs	r0, r0, #1
3000b8c2:	6658      	str	r0, [r3, #100]	; 0x64
    ospi_writel(cospi->fifo_depth * cospi->fifo_width / 4,
3000b8c4:	f894 70bb 	ldrb.w	r7, [r4, #187]	; 0xbb
3000b8c8:	f894 00ba 	ldrb.w	r0, [r4, #186]	; 0xba
3000b8cc:	fb10 f007 	smulbb	r0, r0, r7
    nor->host_ops.reg_read = cospi_command_read;
3000b8d0:	f64a 3785 	movw	r7, #43909	; 0xab85
3000b8d4:	f2c3 0700 	movt	r7, #12288	; 0x3000
    ospi_writel(cospi->fifo_depth * cospi->fifo_width / 4,
3000b8d8:	1080      	asrs	r0, r0, #2
3000b8da:	6758      	str	r0, [r3, #116]	; 0x74
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b8dc:	6818      	ldr	r0, [r3, #0]
    reg |= COSPI_REG_CONFIG_ENB_DIR_ACC_CTRL;
3000b8de:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b8e2:	6018      	str	r0, [r3, #0]
    register_int_handler(cospi->irq, &cospi_irq_handle, (void *)nor);
3000b8e4:	68e0      	ldr	r0, [r4, #12]
3000b8e6:	f7f4 fee3 	bl	300006b0 <register_int_handler>
    unmask_interrupt(cospi->irq);
3000b8ea:	68e0      	ldr	r0, [r4, #12]
3000b8ec:	f7f4 ff32 	bl	30000754 <unmask_interrupt>
    writel(COSPI_IRQ_STATUS_MASK, cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b8f0:	f64f 72ff 	movw	r2, #65535	; 0xffff
    writel(COSPI_IRQ_MASK_RD, cospi->apb_base + COSPI_REG_IRQMASK);
3000b8f4:	f241 0044 	movw	r0, #4164	; 0x1044
    writel(COSPI_IRQ_STATUS_MASK, cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b8f8:	f2c0 0209 	movt	r2, #9
    writel(COSPI_IRQ_MASK_WR, cospi->apb_base + COSPI_REG_IRQMASK);
3000b8fc:	2146      	movs	r1, #70	; 0x46
    nor->host_ops.training = cospi_phy_training;
3000b8fe:	f24b 3cb1 	movw	r12, #46001	; 0xb3b1
    writel(COSPI_IRQ_STATUS_MASK, cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b902:	6863      	ldr	r3, [r4, #4]
    nor->host_ops.training = cospi_phy_training;
3000b904:	f2c3 0c00 	movt	r12, #12288	; 0x3000
    writel(COSPI_IRQ_STATUS_MASK, cospi->apb_base + COSPI_REG_IRQSTATUS);
3000b908:	641a      	str	r2, [r3, #64]	; 0x40
    writel(COSPI_IRQ_MASK_RD, cospi->apb_base + COSPI_REG_IRQMASK);
3000b90a:	6458      	str	r0, [r3, #68]	; 0x44
    nor->host_ops.reg_write = cospi_command_write;
3000b90c:	f64a 5049 	movw	r0, #44361	; 0xad49
    writel(COSPI_IRQ_MASK_WR, cospi->apb_base + COSPI_REG_IRQMASK);
3000b910:	6459      	str	r1, [r3, #68]	; 0x44
    nor->host_ops.transfer = cospi_xfer;
3000b912:	f64a 610d 	movw	r1, #44557	; 0xae0d
    nor->host_ops.reg_write = cospi_command_write;
3000b916:	f2c3 0000 	movt	r0, #12288	; 0x3000
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b91a:	681a      	ldr	r2, [r3, #0]
    nor->host_ops.transfer = cospi_xfer;
3000b91c:	f2c3 0100 	movt	r1, #12288	; 0x3000
    nor->host_ops.reg_read = cospi_command_read;
3000b920:	f8c5 7088 	str.w	r7, [r5, #136]	; 0x88
    nor->host_ops.cancel = cospi_cancel;
3000b924:	f64a 17b1 	movw	r7, #43441	; 0xa9b1
    nor->host_ops.reg_write = cospi_command_write;
3000b928:	f8c5 0084 	str.w	r0, [r5, #132]	; 0x84
    nor->host_ops.lock = cospi_lock;
3000b92c:	f24b 60b9 	movw	r0, #46777	; 0xb6b9
    nor->host_ops.transfer = cospi_xfer;
3000b930:	f8c5 108c 	str.w	r1, [r5, #140]	; 0x8c
    nor->host_ops.unlock = cospi_unlock;
3000b934:	f64a 2189 	movw	r1, #43657	; 0xaa89
        reg |= COSPI_REG_CONFIG_ENABLE_MASK;
3000b938:	f042 0201 	orr.w	r2, r2, #1
    nor->host_ops.lock = cospi_lock;
3000b93c:	f2c3 0000 	movt	r0, #12288	; 0x3000
    nor->host_ops.unlock = cospi_unlock;
3000b940:	f2c3 0100 	movt	r1, #12288	; 0x3000
    nor->host_ops.lock = cospi_lock;
3000b944:	f8c5 0098 	str.w	r0, [r5, #152]	; 0x98
    nor->host_ops.cancel = cospi_cancel;
3000b948:	f2c3 0700 	movt	r7, #12288	; 0x3000
    nor->host_ops.unlock = cospi_unlock;
3000b94c:	f8c5 109c 	str.w	r1, [r5, #156]	; 0x9c
    udelay(1000);
3000b950:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    nor->host_ops.cancel = cospi_cancel;
3000b954:	e9c5 c724 	strd	r12, r7, [r5, #144]	; 0x90
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b958:	601a      	str	r2, [r3, #0]
    reg = ospi_readl(cospi->apb_base + COSPI_REG_CONFIG);
3000b95a:	681d      	ldr	r5, [r3, #0]
    reg |= COSPI_REG_CONFIG_RESET_SELECT_MASK;
3000b95c:	f045 0140 	orr.w	r1, r5, #64	; 0x40
    reg |= COSPI_REG_CONFIG_RESET_PIN_MASK;
3000b960:	f045 0260 	orr.w	r2, r5, #96	; 0x60
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b964:	6019      	str	r1, [r3, #0]
3000b966:	f025 0520 	bic.w	r5, r5, #32
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b96a:	601a      	str	r2, [r3, #0]
    reg &= ~COSPI_REG_CONFIG_RESET_PIN_MASK;
3000b96c:	f045 0540 	orr.w	r5, r5, #64	; 0x40
    udelay(1000);
3000b970:	f008 fc3e 	bl	300141f0 <spin>
    ospi_writel(reg, cospi->apb_base + COSPI_REG_CONFIG);
3000b974:	6863      	ldr	r3, [r4, #4]
3000b976:	601d      	str	r5, [r3, #0]
    udelay(1000);
3000b978:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
3000b97c:	f008 fc38 	bl	300141f0 <spin>
}
3000b980:	4630      	mov	r0, r6
3000b982:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000b984:	f24e 607c 	movw	r0, #59004	; 0xe67c
        return -1;
3000b988:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "Wait ospi idle time out!\n");
3000b98c:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000b990:	f00a f90e 	bl	30015bb0 <_printf>
        return -1;
3000b994:	e7f4      	b.n	3000b980 <spi_nor_host_init+0x198>
3000b996:	bf00      	nop

3000b998 <timer_drv_cntr_set>:
 ** \param [in] val        Set value for sub counter.
 *****************************************************************************/
void timer_drv_cntr_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                        uint32_t val)
{
    if (val == 0) {
3000b998:	b94a      	cbnz	r2, 3000b9ae <timer_drv_cntr_set+0x16>
    timer->cnt_config |= (1 << sub_timer);
3000b99a:	6a42      	ldr	r2, [r0, #36]	; 0x24
3000b99c:	2301      	movs	r3, #1
3000b99e:	fa03 f101 	lsl.w	r1, r3, r1
3000b9a2:	430a      	orrs	r2, r1
3000b9a4:	6242      	str	r2, [r0, #36]	; 0x24
        while (timer->cnt_config & (1 << sub_timer));
3000b9a6:	6a43      	ldr	r3, [r0, #36]	; 0x24
3000b9a8:	4219      	tst	r1, r3
3000b9aa:	d1fc      	bne.n	3000b9a6 <timer_drv_cntr_set+0xe>
3000b9ac:	4770      	bx	r14
        timer_drv_cntr_reset(timer, sub_timer, true);
    }
    else {
        if (sub_timer == TIMER_DRV_G0) {
3000b9ae:	b161      	cbz	r1, 3000b9ca <timer_drv_cntr_set+0x32>
            timer->cnt_g0_init = val;
        }
        else if (sub_timer == TIMER_DRV_G1) {
3000b9b0:	2901      	cmp	r1, #1
3000b9b2:	d00d      	beq.n	3000b9d0 <timer_drv_cntr_set+0x38>
            timer->cnt_g1_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_A) {
3000b9b4:	2902      	cmp	r1, #2
3000b9b6:	d00e      	beq.n	3000b9d6 <timer_drv_cntr_set+0x3e>
            timer->cnt_local_a_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_B) {
3000b9b8:	2903      	cmp	r1, #3
3000b9ba:	d00f      	beq.n	3000b9dc <timer_drv_cntr_set+0x44>
            timer->cnt_local_b_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_C) {
3000b9bc:	2904      	cmp	r1, #4
3000b9be:	d010      	beq.n	3000b9e2 <timer_drv_cntr_set+0x4a>
            timer->cnt_local_c_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_D) {
3000b9c0:	2905      	cmp	r1, #5
            timer->cnt_local_d_init = val;
3000b9c2:	bf08      	it	eq
3000b9c4:	f8c0 20c4 	streq.w	r2, [r0, #196]	; 0xc4
        }
    }
}
3000b9c8:	4770      	bx	r14
            timer->cnt_g0_init = val;
3000b9ca:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
3000b9ce:	4770      	bx	r14
            timer->cnt_g1_init = val;
3000b9d0:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
3000b9d4:	4770      	bx	r14
            timer->cnt_local_a_init = val;
3000b9d6:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
3000b9da:	4770      	bx	r14
            timer->cnt_local_b_init = val;
3000b9dc:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
3000b9e0:	4770      	bx	r14
            timer->cnt_local_c_init = val;
3000b9e2:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
3000b9e6:	4770      	bx	r14

3000b9e8 <timer_drv_cntr_get>:
 *****************************************************************************/
uint32_t timer_drv_cntr_get(sdrv_timer_t *timer, timer_drv_sub_t sub_timer)
{
    uint32_t val = 0;

    if (sub_timer == TIMER_DRV_G0) {
3000b9e8:	b161      	cbz	r1, 3000ba04 <timer_drv_cntr_get+0x1c>
        val = timer->cnt_g0;
    }
    else if (sub_timer == TIMER_DRV_G1) {
3000b9ea:	2901      	cmp	r1, #1
3000b9ec:	d00c      	beq.n	3000ba08 <timer_drv_cntr_get+0x20>
        val = timer->cnt_g1;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
3000b9ee:	2902      	cmp	r1, #2
3000b9f0:	d00e      	beq.n	3000ba10 <timer_drv_cntr_get+0x28>
        val = timer->cnt_local_a;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
3000b9f2:	2903      	cmp	r1, #3
3000b9f4:	d00a      	beq.n	3000ba0c <timer_drv_cntr_get+0x24>
        val = timer->cnt_local_b;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
3000b9f6:	2904      	cmp	r1, #4
3000b9f8:	d00c      	beq.n	3000ba14 <timer_drv_cntr_get+0x2c>
        val = timer->cnt_local_c;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
3000b9fa:	2905      	cmp	r1, #5
        val = timer->cnt_local_d;
3000b9fc:	bf0c      	ite	eq
3000b9fe:	6d40      	ldreq	r0, [r0, #84]	; 0x54
    uint32_t val = 0;
3000ba00:	2000      	movne	r0, #0
    }

    return val;
}
3000ba02:	4770      	bx	r14
        val = timer->cnt_g0;
3000ba04:	6c00      	ldr	r0, [r0, #64]	; 0x40
3000ba06:	4770      	bx	r14
        val = timer->cnt_g1;
3000ba08:	6c40      	ldr	r0, [r0, #68]	; 0x44
3000ba0a:	4770      	bx	r14
        val = timer->cnt_local_b;
3000ba0c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
3000ba0e:	4770      	bx	r14
        val = timer->cnt_local_a;
3000ba10:	6c80      	ldr	r0, [r0, #72]	; 0x48
3000ba12:	4770      	bx	r14
        val = timer->cnt_local_c;
3000ba14:	6d00      	ldr	r0, [r0, #80]	; 0x50
3000ba16:	4770      	bx	r14

3000ba18 <timer_drv_ovf_set>:
 ** \param [in] val        Set sub counter overflow value.
 *****************************************************************************/
void timer_drv_ovf_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                       uint32_t val)
{
    if (sub_timer == TIMER_DRV_G0) {
3000ba18:	b159      	cbz	r1, 3000ba32 <timer_drv_ovf_set+0x1a>
        timer->cnt_g0_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_G1) {
3000ba1a:	2901      	cmp	r1, #1
3000ba1c:	d00b      	beq.n	3000ba36 <timer_drv_ovf_set+0x1e>
        timer->cnt_g1_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
3000ba1e:	2902      	cmp	r1, #2
3000ba20:	d00d      	beq.n	3000ba3e <timer_drv_ovf_set+0x26>
        timer->cnt_local_a_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
3000ba22:	2903      	cmp	r1, #3
3000ba24:	d009      	beq.n	3000ba3a <timer_drv_ovf_set+0x22>
        timer->cnt_local_b_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
3000ba26:	2904      	cmp	r1, #4
3000ba28:	d00b      	beq.n	3000ba42 <timer_drv_ovf_set+0x2a>
        timer->cnt_local_c_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
3000ba2a:	2905      	cmp	r1, #5
        timer->cnt_local_d_ovf = val;
3000ba2c:	bf08      	it	eq
3000ba2e:	63c2      	streq	r2, [r0, #60]	; 0x3c
    }
}
3000ba30:	4770      	bx	r14
        timer->cnt_g0_ovf = val;
3000ba32:	6282      	str	r2, [r0, #40]	; 0x28
3000ba34:	4770      	bx	r14
        timer->cnt_g1_ovf = val;
3000ba36:	62c2      	str	r2, [r0, #44]	; 0x2c
3000ba38:	4770      	bx	r14
        timer->cnt_local_b_ovf = val;
3000ba3a:	6342      	str	r2, [r0, #52]	; 0x34
3000ba3c:	4770      	bx	r14
        timer->cnt_local_a_ovf = val;
3000ba3e:	6302      	str	r2, [r0, #48]	; 0x30
3000ba40:	4770      	bx	r14
        timer->cnt_local_c_ovf = val;
3000ba42:	6382      	str	r2, [r0, #56]	; 0x38
3000ba44:	4770      	bx	r14
3000ba46:	bf00      	nop

3000ba48 <timer_drv_cascade_set>:
 ** \param [in] cascade    G1 cascaded G0 or not.
 *****************************************************************************/
void timer_drv_cascade_set(sdrv_timer_t *timer, bool cascade)
{
    if (cascade) {
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
3000ba48:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if (cascade) {
3000ba4a:	b919      	cbnz	r1, 3000ba54 <timer_drv_cascade_set+0xc>
    }
    else {
        timer->cnt_config &= (~BM_CNT_CONFIG_CASCADE_MODE);
3000ba4c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
3000ba50:	6243      	str	r3, [r0, #36]	; 0x24
    }
}
3000ba52:	4770      	bx	r14
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
3000ba54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
3000ba58:	6243      	str	r3, [r0, #36]	; 0x24
3000ba5a:	4770      	bx	r14

3000ba5c <timer_drv_clk_init>:
 **                                     11 - Low power clock, typically from low speed on chip RCOSC
 *****************************************************************************/
void timer_drv_clk_init(sdrv_timer_t *timer, uint32_t clk_sel,
                        uint32_t clk_div)
{
    u32 value = timer->tim_clk_config;
3000ba5c:	6a03      	ldr	r3, [r0, #32]

    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
3000ba5e:	0409      	lsls	r1, r1, #16
              FV_TIM_CLK_CONFIG_DIV_NUM(clk_div));
3000ba60:	b292      	uxth	r2, r2
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
3000ba62:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
3000ba66:	4311      	orrs	r1, r2
    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
3000ba68:	0c9a      	lsrs	r2, r3, #18
3000ba6a:	0492      	lsls	r2, r2, #18
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
3000ba6c:	4311      	orrs	r1, r2

    timer->tim_clk_config = value;
3000ba6e:	6201      	str	r1, [r0, #32]
}
3000ba70:	4770      	bx	r14
3000ba72:	bf00      	nop

3000ba74 <timer_drv_int_sta_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sta_en |= (1 << offset);
3000ba74:	2301      	movs	r3, #1
3000ba76:	fa03 f101 	lsl.w	r1, r3, r1
3000ba7a:	6843      	ldr	r3, [r0, #4]
3000ba7c:	4319      	orrs	r1, r3
3000ba7e:	6041      	str	r1, [r0, #4]
}
3000ba80:	4770      	bx	r14
3000ba82:	bf00      	nop

3000ba84 <timer_drv_int_sta_disable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_disable(sdrv_timer_t *timer,
                               timer_drv_int_src_t offset)
{
    timer->int_sta_en &= ~(1 << offset);
3000ba84:	2301      	movs	r3, #1
3000ba86:	fa03 f101 	lsl.w	r1, r3, r1
3000ba8a:	6843      	ldr	r3, [r0, #4]
3000ba8c:	ea23 0101 	bic.w	r1, r3, r1
3000ba90:	6041      	str	r1, [r0, #4]
}
3000ba92:	4770      	bx	r14

3000ba94 <timer_drv_int_sig_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sig_en |= (1 << offset);
3000ba94:	2301      	movs	r3, #1
3000ba96:	fa03 f101 	lsl.w	r1, r3, r1
3000ba9a:	6883      	ldr	r3, [r0, #8]
3000ba9c:	4319      	orrs	r1, r3
3000ba9e:	6081      	str	r1, [r0, #8]
}
3000baa0:	4770      	bx	r14
3000baa2:	bf00      	nop

3000baa4 <timer_drv_int_sig_disable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_disable(sdrv_timer_t *timer,
                               timer_drv_int_src_t offset)
{
    timer->int_sig_en &= ~(1 << offset);
3000baa4:	2301      	movs	r3, #1
3000baa6:	fa03 f101 	lsl.w	r1, r3, r1
3000baaa:	6883      	ldr	r3, [r0, #8]
3000baac:	ea23 0101 	bic.w	r1, r3, r1
3000bab0:	6081      	str	r1, [r0, #8]
}
3000bab2:	4770      	bx	r14

3000bab4 <timer_drv_ovf_irq_handle>:
 ** \param [in] drv_context
 *****************************************************************************/
enum handler_return timer_drv_ovf_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
3000bab4:	6803      	ldr	r3, [r0, #0]
3000bab6:	f413 7f80 	tst.w	r3, #256	; 0x100
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
3000baba:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
3000babc:	d006      	beq.n	3000bacc <timer_drv_ovf_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
3000babe:	f443 7380 	orr.w	r3, r3, #256	; 0x100
3000bac2:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
3000bac4:	b171      	cbz	r1, 3000bae4 <timer_drv_ovf_irq_handle+0x30>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
3000bac6:	688b      	ldr	r3, [r1, #8]
3000bac8:	b153      	cbz	r3, 3000bae0 <timer_drv_ovf_irq_handle+0x2c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
            return drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1]();
3000baca:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CNT_G1_OVF) {
3000bacc:	059b      	lsls	r3, r3, #22
3000bace:	d507      	bpl.n	3000bae0 <timer_drv_ovf_irq_handle+0x2c>
        timer->int_sta |= BM_INT_STA_CNT_G1_OVF;
3000bad0:	6803      	ldr	r3, [r0, #0]
3000bad2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
3000bad6:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
3000bad8:	b181      	cbz	r1, 3000bafc <timer_drv_ovf_irq_handle+0x48>
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
3000bada:	68cb      	ldr	r3, [r1, #12]
3000badc:	2b00      	cmp	r3, #0
3000bade:	d1f4      	bne.n	3000baca <timer_drv_ovf_irq_handle+0x16>
        }
    }

    return INT_RESCHEDULE;
}
3000bae0:	2001      	movs	r0, #1
3000bae2:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
3000bae4:	6843      	ldr	r3, [r0, #4]
3000bae6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
3000baea:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000baec:	6883      	ldr	r3, [r0, #8]
3000baee:	f423 7380 	bic.w	r3, r3, #256	; 0x100
3000baf2:	6083      	str	r3, [r0, #8]
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
3000baf4:	688b      	ldr	r3, [r1, #8]
3000baf6:	2b00      	cmp	r3, #0
3000baf8:	d1e7      	bne.n	3000baca <timer_drv_ovf_irq_handle+0x16>
3000bafa:	e7f1      	b.n	3000bae0 <timer_drv_ovf_irq_handle+0x2c>
    timer->int_sta_en &= ~(1 << offset);
3000bafc:	6843      	ldr	r3, [r0, #4]
3000bafe:	f423 7300 	bic.w	r3, r3, #512	; 0x200
3000bb02:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000bb04:	6883      	ldr	r3, [r0, #8]
3000bb06:	f423 7300 	bic.w	r3, r3, #512	; 0x200
3000bb0a:	6083      	str	r3, [r0, #8]
3000bb0c:	e7e5      	b.n	3000bada <timer_drv_ovf_irq_handle+0x26>
3000bb0e:	bf00      	nop

3000bb10 <timer_drv_func_irq_handle>:
 *****************************************************************************/
enum handler_return timer_drv_func_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    //Func A
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
3000bb10:	6803      	ldr	r3, [r0, #0]
3000bb12:	f413 6f80 	tst.w	r3, #1024	; 0x400
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
3000bb16:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
3000bb18:	d006      	beq.n	3000bb28 <timer_drv_func_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
3000bb1a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
3000bb1e:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
3000bb20:	b1e1      	cbz	r1, 3000bb5c <timer_drv_func_irq_handle+0x4c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb22:	690b      	ldr	r3, [r1, #16]
3000bb24:	b1c3      	cbz	r3, 3000bb58 <timer_drv_func_irq_handle+0x48>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D]();
3000bb26:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
3000bb28:	f013 0f10 	tst.w	r3, #16
        timer->int_sta |= BM_INT_STA_CMP_A;
3000bb2c:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
3000bb2e:	d005      	beq.n	3000bb3c <timer_drv_func_irq_handle+0x2c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb30:	6a0a      	ldr	r2, [r1, #32]
        timer->int_sta |= BM_INT_STA_CMP_A;
3000bb32:	f043 0310 	orr.w	r3, r3, #16
3000bb36:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb38:	b172      	cbz	r2, 3000bb58 <timer_drv_func_irq_handle+0x48>
    }
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;

        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
3000bb3a:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
3000bb3c:	f013 0f01 	tst.w	r3, #1
        timer->int_sta |= BM_INT_STA_CPT_A;
3000bb40:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
3000bb42:	d117      	bne.n	3000bb74 <timer_drv_func_irq_handle+0x64>
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
3000bb44:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
3000bb48:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
3000bb4a:	d01a      	beq.n	3000bb82 <timer_drv_func_irq_handle+0x72>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb4c:	6c0a      	ldr	r2, [r1, #64]	; 0x40
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
3000bb4e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
3000bb52:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb54:	2a00      	cmp	r2, #0
3000bb56:	d1f0      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
        }
    }

    return INT_NO_RESCHEDULE;
}
3000bb58:	2000      	movs	r0, #0
3000bb5a:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
3000bb5c:	6843      	ldr	r3, [r0, #4]
3000bb5e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
3000bb62:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000bb64:	6883      	ldr	r3, [r0, #8]
3000bb66:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
3000bb6a:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb6c:	690b      	ldr	r3, [r1, #16]
3000bb6e:	2b00      	cmp	r3, #0
3000bb70:	d1d9      	bne.n	3000bb26 <timer_drv_func_irq_handle+0x16>
3000bb72:	e7f1      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb74:	6b0a      	ldr	r2, [r1, #48]	; 0x30
        timer->int_sta |= BM_INT_STA_CPT_A;
3000bb76:	f043 0301 	orr.w	r3, r3, #1
3000bb7a:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bb7c:	2a00      	cmp	r2, #0
3000bb7e:	d0eb      	beq.n	3000bb58 <timer_drv_func_irq_handle+0x48>
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
3000bb80:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
3000bb82:	f413 3f80 	tst.w	r3, #65536	; 0x10000
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
3000bb86:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
3000bb88:	d10b      	bne.n	3000bba2 <timer_drv_func_irq_handle+0x92>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
3000bb8a:	f413 6f00 	tst.w	r3, #2048	; 0x800
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
3000bb8e:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
3000bb90:	d00e      	beq.n	3000bbb0 <timer_drv_func_irq_handle+0xa0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
3000bb92:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
3000bb96:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
3000bb98:	b301      	cbz	r1, 3000bbdc <timer_drv_func_irq_handle+0xcc>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bb9a:	694b      	ldr	r3, [r1, #20]
3000bb9c:	2b00      	cmp	r3, #0
3000bb9e:	d1c2      	bne.n	3000bb26 <timer_drv_func_irq_handle+0x16>
3000bba0:	e7da      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bba2:	6d0a      	ldr	r2, [r1, #80]	; 0x50
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
3000bba4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
3000bba8:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
3000bbaa:	2a00      	cmp	r2, #0
3000bbac:	d1c5      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bbae:	e7d3      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
3000bbb0:	f013 0f20 	tst.w	r3, #32
        timer->int_sta |= BM_INT_STA_CMP_B;
3000bbb4:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
3000bbb6:	d006      	beq.n	3000bbc6 <timer_drv_func_irq_handle+0xb6>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbb8:	6a4a      	ldr	r2, [r1, #36]	; 0x24
        timer->int_sta |= BM_INT_STA_CMP_B;
3000bbba:	f043 0320 	orr.w	r3, r3, #32
3000bbbe:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbc0:	2a00      	cmp	r2, #0
3000bbc2:	d1ba      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bbc4:	e7c8      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
3000bbc6:	f013 0f02 	tst.w	r3, #2
        timer->int_sta |= BM_INT_STA_CPT_B;
3000bbca:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
3000bbcc:	d00f      	beq.n	3000bbee <timer_drv_func_irq_handle+0xde>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbce:	6b4a      	ldr	r2, [r1, #52]	; 0x34
        timer->int_sta |= BM_INT_STA_CPT_B;
3000bbd0:	f043 0302 	orr.w	r3, r3, #2
3000bbd4:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbd6:	2a00      	cmp	r2, #0
3000bbd8:	d1af      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bbda:	e7bd      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
3000bbdc:	6843      	ldr	r3, [r0, #4]
3000bbde:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
3000bbe2:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000bbe4:	6883      	ldr	r3, [r0, #8]
3000bbe6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
3000bbea:	6083      	str	r3, [r0, #8]
3000bbec:	e7d5      	b.n	3000bb9a <timer_drv_func_irq_handle+0x8a>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
3000bbee:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
3000bbf2:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
3000bbf4:	d006      	beq.n	3000bc04 <timer_drv_func_irq_handle+0xf4>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbf6:	6c4a      	ldr	r2, [r1, #68]	; 0x44
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
3000bbf8:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
3000bbfc:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bbfe:	2a00      	cmp	r2, #0
3000bc00:	d19b      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bc02:	e7a9      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
3000bc04:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
3000bc08:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
3000bc0a:	d006      	beq.n	3000bc1a <timer_drv_func_irq_handle+0x10a>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bc0c:	6d4a      	ldr	r2, [r1, #84]	; 0x54
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
3000bc0e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
3000bc12:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
3000bc14:	2a00      	cmp	r2, #0
3000bc16:	d190      	bne.n	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bc18:	e79e      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
3000bc1a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
3000bc1e:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
3000bc20:	d008      	beq.n	3000bc34 <timer_drv_func_irq_handle+0x124>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
3000bc22:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
3000bc26:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
3000bc28:	b1e1      	cbz	r1, 3000bc64 <timer_drv_func_irq_handle+0x154>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc2a:	698b      	ldr	r3, [r1, #24]
3000bc2c:	2b00      	cmp	r3, #0
3000bc2e:	f47f af7a 	bne.w	3000bb26 <timer_drv_func_irq_handle+0x16>
3000bc32:	e791      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
3000bc34:	f013 0f40 	tst.w	r3, #64	; 0x40
        timer->int_sta |= BM_INT_STA_CMP_C;
3000bc38:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
3000bc3a:	d007      	beq.n	3000bc4c <timer_drv_func_irq_handle+0x13c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc3c:	6a8a      	ldr	r2, [r1, #40]	; 0x28
        timer->int_sta |= BM_INT_STA_CMP_C;
3000bc3e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
3000bc42:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc44:	2a00      	cmp	r2, #0
3000bc46:	f47f af78 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bc4a:	e785      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
3000bc4c:	f013 0f04 	tst.w	r3, #4
        timer->int_sta |= BM_INT_STA_CPT_C;
3000bc50:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
3000bc52:	d010      	beq.n	3000bc76 <timer_drv_func_irq_handle+0x166>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc54:	6b8a      	ldr	r2, [r1, #56]	; 0x38
        timer->int_sta |= BM_INT_STA_CPT_C;
3000bc56:	f043 0304 	orr.w	r3, r3, #4
3000bc5a:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc5c:	2a00      	cmp	r2, #0
3000bc5e:	f47f af6c 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bc62:	e779      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
3000bc64:	6843      	ldr	r3, [r0, #4]
3000bc66:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
3000bc6a:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000bc6c:	6883      	ldr	r3, [r0, #8]
3000bc6e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
3000bc72:	6083      	str	r3, [r0, #8]
3000bc74:	e7d9      	b.n	3000bc2a <timer_drv_func_irq_handle+0x11a>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
3000bc76:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
3000bc7a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
3000bc7c:	d007      	beq.n	3000bc8e <timer_drv_func_irq_handle+0x17e>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc7e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
3000bc80:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
3000bc84:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc86:	2a00      	cmp	r2, #0
3000bc88:	f47f af57 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bc8c:	e764      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
3000bc8e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
3000bc92:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
3000bc94:	d007      	beq.n	3000bca6 <timer_drv_func_irq_handle+0x196>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc96:	6d8a      	ldr	r2, [r1, #88]	; 0x58
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
3000bc98:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
3000bc9c:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
3000bc9e:	2a00      	cmp	r2, #0
3000bca0:	f47f af4b 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bca4:	e758      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
3000bca6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
3000bcaa:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
3000bcac:	d010      	beq.n	3000bcd0 <timer_drv_func_irq_handle+0x1c0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
3000bcae:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
3000bcb2:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
3000bcb4:	b939      	cbnz	r1, 3000bcc6 <timer_drv_func_irq_handle+0x1b6>
    timer->int_sta_en &= ~(1 << offset);
3000bcb6:	6843      	ldr	r3, [r0, #4]
3000bcb8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
3000bcbc:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
3000bcbe:	6883      	ldr	r3, [r0, #8]
3000bcc0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
3000bcc4:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bcc6:	69cb      	ldr	r3, [r1, #28]
3000bcc8:	2b00      	cmp	r3, #0
3000bcca:	f47f af2c 	bne.w	3000bb26 <timer_drv_func_irq_handle+0x16>
3000bcce:	e743      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
3000bcd0:	f013 0f80 	tst.w	r3, #128	; 0x80
        timer->int_sta |= BM_INT_STA_CMP_D;
3000bcd4:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
3000bcd6:	d007      	beq.n	3000bce8 <timer_drv_func_irq_handle+0x1d8>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bcd8:	6aca      	ldr	r2, [r1, #44]	; 0x2c
        timer->int_sta |= BM_INT_STA_CMP_D;
3000bcda:	f043 0380 	orr.w	r3, r3, #128	; 0x80
3000bcde:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bce0:	2a00      	cmp	r2, #0
3000bce2:	f47f af2a 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bce6:	e737      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
3000bce8:	f013 0f08 	tst.w	r3, #8
        timer->int_sta |= BM_INT_STA_CPT_D;
3000bcec:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
3000bcee:	d007      	beq.n	3000bd00 <timer_drv_func_irq_handle+0x1f0>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bcf0:	6bca      	ldr	r2, [r1, #60]	; 0x3c
        timer->int_sta |= BM_INT_STA_CPT_D;
3000bcf2:	f043 0308 	orr.w	r3, r3, #8
3000bcf6:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bcf8:	2a00      	cmp	r2, #0
3000bcfa:	f47f af1e 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bcfe:	e72b      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
3000bd00:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
3000bd04:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
3000bd06:	d007      	beq.n	3000bd18 <timer_drv_func_irq_handle+0x208>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bd08:	6cca      	ldr	r2, [r1, #76]	; 0x4c
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
3000bd0a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
3000bd0e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bd10:	2a00      	cmp	r2, #0
3000bd12:	f47f af12 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bd16:	e71f      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
3000bd18:	031b      	lsls	r3, r3, #12
3000bd1a:	f57f af1d 	bpl.w	3000bb58 <timer_drv_func_irq_handle+0x48>
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
3000bd1e:	6803      	ldr	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bd20:	6dca      	ldr	r2, [r1, #92]	; 0x5c
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
3000bd22:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
3000bd26:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
3000bd28:	2a00      	cmp	r2, #0
3000bd2a:	f47f af06 	bne.w	3000bb3a <timer_drv_func_irq_handle+0x2a>
3000bd2e:	e713      	b.n	3000bb58 <timer_drv_func_irq_handle+0x48>

3000bd30 <timer_drv_int_sta_clear>:
 ** \param [in] drv_context
 *****************************************************************************/
void timer_drv_int_sta_clear(sdrv_timer_t *timer,
                             timer_drv_int_src_t offset)
{
    timer->int_sta |= (1 << offset);
3000bd30:	2301      	movs	r3, #1
3000bd32:	fa03 f101 	lsl.w	r1, r3, r1
3000bd36:	6803      	ldr	r3, [r0, #0]
3000bd38:	4319      	orrs	r1, r3
3000bd3a:	6001      	str	r1, [r0, #0]
}
3000bd3c:	4770      	bx	r14
3000bd3e:	bf00      	nop

3000bd40 <uart_drv_init>:
 **
 ** \param [in] dev         Pointer to device information descriptor
 *****************************************************************************/
void uart_drv_init(DW_APB_UART_uart_TypeDef *dev,
                   uart_drv_context_t *context, uart_drv_cfg_t *cfg)
{
3000bd40:	b5f0      	push	{r4, r5, r6, r7, r14}
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
3000bd42:	e9d2 3400 	ldrd	r3, r4, [r2]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd46:	f644 55d3 	movw	r5, #19923	; 0x4dd3
    dev->LCR.DLAB = 1;  //divisor latch access bit
3000bd4a:	68c7      	ldr	r7, [r0, #12]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd4c:	f2c1 0562 	movt	r5, #4194	; 0x1062
{
3000bd50:	b083      	sub	sp, #12
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
3000bd52:	0124      	lsls	r4, r4, #4
    dev->LCR.DLAB = 1;  //divisor latch access bit
3000bd54:	f047 0780 	orr.w	r7, r7, #128	; 0x80
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
3000bd58:	fbb3 f6f4 	udiv	r6, r3, r4
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd5c:	fba5 c404 	umull	r12, r4, r5, r4
    dev->LCR.DLAB = 1;  //divisor latch access bit
3000bd60:	60c7      	str	r7, [r0, #12]
    dev->DLL.DLL = divisor & 0xff;
3000bd62:	6807      	ldr	r7, [r0, #0]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd64:	09a4      	lsrs	r4, r4, #6
3000bd66:	fbb3 f3f4 	udiv	r3, r3, r4
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
3000bd6a:	b2b4      	uxth	r4, r6
    dev->DLL.DLL = divisor & 0xff;
3000bd6c:	b2f6      	uxtb	r6, r6
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd6e:	ebc4 1c44 	rsb	r12, r4, r4, lsl #5
    dev->DLL.DLL = divisor & 0xff;
3000bd72:	f366 0707 	bfi	r7, r6, #0, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd76:	eb04 068c 	add.w	r6, r4, r12, lsl #2
    dev->DLL.DLL = divisor & 0xff;
3000bd7a:	6007      	str	r7, [r0, #0]
    dev->DLH.DLH = (divisor >> 8) & 0xff;
3000bd7c:	0a24      	lsrs	r4, r4, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
3000bd7e:	eba3 03c6 	sub.w	r3, r3, r6, lsl #3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
3000bd82:	6846      	ldr	r6, [r0, #4]
    frac = frac *16/1000;
3000bd84:	b29b      	uxth	r3, r3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
3000bd86:	f364 0607 	bfi	r6, r4, #0, #8
    frac = frac *16/1000;
3000bd8a:	011b      	lsls	r3, r3, #4
    dev->DLH.DLH = (divisor >> 8) & 0xff;
3000bd8c:	6046      	str	r6, [r0, #4]
    frac = frac *16/1000;
3000bd8e:	fba5 4303 	umull	r4, r3, r5, r3
    dev->DLF.DLF = frac;
3000bd92:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
3000bd96:	f3c3 1383 	ubfx	r3, r3, #6, #4
3000bd9a:	f363 0403 	bfi	r4, r3, #0, #4
3000bd9e:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
    dev->LCR.DLAB = 0;
3000bda2:	68c3      	ldr	r3, [r0, #12]
3000bda4:	f36f 13c7 	bfc	r3, #7, #1
3000bda8:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.data_bits) {
3000bdaa:	6893      	ldr	r3, [r2, #8]
3000bdac:	2b03      	cmp	r3, #3
3000bdae:	f200 8091 	bhi.w	3000bed4 <uart_drv_init+0x194>
            dev->LCR.DLS = cfg->port_cfg.data_bits;
3000bdb2:	68c4      	ldr	r4, [r0, #12]
3000bdb4:	f363 0401 	bfi	r4, r3, #0, #2
3000bdb8:	60c4      	str	r4, [r0, #12]
    switch (cfg->port_cfg.stop_bits) {
3000bdba:	68d3      	ldr	r3, [r2, #12]
3000bdbc:	2b01      	cmp	r3, #1
3000bdbe:	d06c      	beq.n	3000be9a <uart_drv_init+0x15a>
3000bdc0:	d343      	bcc.n	3000be4a <uart_drv_init+0x10a>
3000bdc2:	2b02      	cmp	r3, #2
3000bdc4:	f040 8097 	bne.w	3000bef6 <uart_drv_init+0x1b6>
            if (dev->LCR.DLS == 0)
3000bdc8:	68c3      	ldr	r3, [r0, #12]
3000bdca:	079b      	lsls	r3, r3, #30
3000bdcc:	f000 80b5 	beq.w	3000bf3a <uart_drv_init+0x1fa>
            dev->LCR.STOP = 1;
3000bdd0:	68c3      	ldr	r3, [r0, #12]
3000bdd2:	f043 0304 	orr.w	r3, r3, #4
3000bdd6:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
3000bdd8:	6913      	ldr	r3, [r2, #16]
3000bdda:	2b01      	cmp	r3, #1
3000bddc:	d03c      	beq.n	3000be58 <uart_drv_init+0x118>
3000bdde:	d370      	bcc.n	3000bec2 <uart_drv_init+0x182>
3000bde0:	2b02      	cmp	r3, #2
3000bde2:	f040 8099 	bne.w	3000bf18 <uart_drv_init+0x1d8>
            dev->LCR.PEN = 0;
3000bde6:	68c3      	ldr	r3, [r0, #12]
3000bde8:	f36f 03c3 	bfc	r3, #3, #1
3000bdec:	60c3      	str	r3, [r0, #12]
    if (cfg->port_cfg.loopback_enable) {
3000bdee:	7d13      	ldrb	r3, [r2, #20]
3000bdf0:	b11b      	cbz	r3, 3000bdfa <uart_drv_init+0xba>
 ** \param [out]
 *****************************************************************************/
void uart_drv_loopback(DW_APB_UART_uart_TypeDef *dev, bool enable)
{
    if (enable) {
        dev->MCR.LOOPBACK = 1;
3000bdf2:	6903      	ldr	r3, [r0, #16]
3000bdf4:	f043 0310 	orr.w	r3, r3, #16
3000bdf8:	6103      	str	r3, [r0, #16]
    if (cfg->fifo_cfg.fifo_enable) {
3000bdfa:	7e13      	ldrb	r3, [r2, #24]
3000bdfc:	2b00      	cmp	r3, #0
3000bdfe:	d134      	bne.n	3000be6a <uart_drv_init+0x12a>
        context->fcr_shadow.FIFOE = 0;
3000be00:	790a      	ldrb	r2, [r1, #4]
3000be02:	f363 0200 	bfi	r2, r3, #0, #1
3000be06:	710a      	strb	r2, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
3000be08:	684a      	ldr	r2, [r1, #4]
3000be0a:	6082      	str	r2, [r0, #8]
        context->fifo_enable = false;
3000be0c:	700b      	strb	r3, [r1, #0]
    context->tx_str_cbk = NULL;
3000be0e:	2300      	movs	r3, #0
3000be10:	610b      	str	r3, [r1, #16]
    context->rx_str_cbk = NULL;
3000be12:	e9c1 3302 	strd	r3, r3, [r1, #8]
    context->tx_shadow.len_rest = 0;
3000be16:	e9c1 3305 	strd	r3, r3, [r1, #20]
    context->rx_shadow.len_rest = 0;
3000be1a:	e9c1 3307 	strd	r3, r3, [r1, #28]
    dev->IER.ERBFI = 1;   //received data available interrupt
3000be1e:	6842      	ldr	r2, [r0, #4]
3000be20:	f042 0201 	orr.w	r2, r2, #1
3000be24:	6042      	str	r2, [r0, #4]
        dev->IER.ETBEI = 0;
3000be26:	6842      	ldr	r2, [r0, #4]
3000be28:	f363 0241 	bfi	r2, r3, #1, #1
3000be2c:	6042      	str	r2, [r0, #4]
    dev->IER.ELSI = 1;      //receiver line status interrupt
3000be2e:	6842      	ldr	r2, [r0, #4]
3000be30:	f042 0204 	orr.w	r2, r2, #4
3000be34:	6042      	str	r2, [r0, #4]
    dev->IER.EDSSI = 0;     //modem status interrupt
3000be36:	6842      	ldr	r2, [r0, #4]
3000be38:	f363 02c3 	bfi	r2, r3, #3, #1
3000be3c:	6042      	str	r2, [r0, #4]
    dev->IER.PTIME = 0;     //programmable THRE interrupt mode
3000be3e:	6842      	ldr	r2, [r0, #4]
3000be40:	f363 12c7 	bfi	r2, r3, #7, #1
3000be44:	6042      	str	r2, [r0, #4]
}
3000be46:	b003      	add	sp, #12
3000be48:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dev->LCR.STOP = 0;
3000be4a:	68c3      	ldr	r3, [r0, #12]
3000be4c:	f36f 0382 	bfc	r3, #2, #1
3000be50:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
3000be52:	6913      	ldr	r3, [r2, #16]
3000be54:	2b01      	cmp	r3, #1
3000be56:	d1c2      	bne.n	3000bdde <uart_drv_init+0x9e>
            dev->LCR.EPS = 1;
3000be58:	68c3      	ldr	r3, [r0, #12]
3000be5a:	f043 0310 	orr.w	r3, r3, #16
3000be5e:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
3000be60:	68c3      	ldr	r3, [r0, #12]
3000be62:	f043 0308 	orr.w	r3, r3, #8
3000be66:	60c3      	str	r3, [r0, #12]
3000be68:	e7c1      	b.n	3000bdee <uart_drv_init+0xae>
        context->fcr_shadow.RFIFOR = 1; //reset fifo
3000be6a:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
3000be6c:	69d5      	ldr	r5, [r2, #28]
        context->fcr_shadow.TET =
3000be6e:	6a12      	ldr	r2, [r2, #32]
        context->fcr_shadow.XFIFOR = 1;
3000be70:	f043 0306 	orr.w	r3, r3, #6
        context->fifo_enable = true;
3000be74:	2401      	movs	r4, #1
        context->fcr_shadow.XFIFOR = 1;
3000be76:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
3000be78:	684b      	ldr	r3, [r1, #4]
3000be7a:	6083      	str	r3, [r0, #8]
        context->fcr_shadow.RFIFOR = 0;
3000be7c:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
3000be7e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
3000be82:	f365 1387 	bfi	r3, r5, #6, #2
        context->fcr_shadow.TET =
3000be86:	f362 1305 	bfi	r3, r2, #4, #2
        context->fcr_shadow.FIFOE = 1;
3000be8a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
3000be8e:	4323      	orrs	r3, r4
3000be90:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
3000be92:	684b      	ldr	r3, [r1, #4]
3000be94:	6083      	str	r3, [r0, #8]
        context->fifo_enable = true;
3000be96:	700c      	strb	r4, [r1, #0]
3000be98:	e7b9      	b.n	3000be0e <uart_drv_init+0xce>
            if (dev->LCR.DLS != 0)
3000be9a:	68c3      	ldr	r3, [r0, #12]
3000be9c:	079c      	lsls	r4, r3, #30
3000be9e:	d097      	beq.n	3000bdd0 <uart_drv_init+0x90>
                ASSERT(0);
3000bea0:	f641 2300 	movw	r3, #6656	; 0x1a00
3000bea4:	f24e 62fc 	movw	r2, #59132	; 0xe6fc
3000bea8:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000beac:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000beb0:	4670      	mov	r0, r14
3000beb2:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000beb6:	9300      	str	r3, [sp, #0]
3000beb8:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000bebc:	2352      	movs	r3, #82	; 0x52
3000bebe:	f008 f9a9 	bl	30014214 <_panic>
            dev->LCR.EPS = 0;
3000bec2:	68c3      	ldr	r3, [r0, #12]
3000bec4:	f36f 1304 	bfc	r3, #4, #1
3000bec8:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
3000beca:	68c3      	ldr	r3, [r0, #12]
3000becc:	f043 0308 	orr.w	r3, r3, #8
3000bed0:	60c3      	str	r3, [r0, #12]
3000bed2:	e78c      	b.n	3000bdee <uart_drv_init+0xae>
            ASSERT(0); /* no other bits*/
3000bed4:	f641 2300 	movw	r3, #6656	; 0x1a00
3000bed8:	f24e 62fc 	movw	r2, #59132	; 0xe6fc
3000bedc:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000bee0:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000bee4:	4670      	mov	r0, r14
3000bee6:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000beea:	9300      	str	r3, [sp, #0]
3000beec:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000bef0:	2346      	movs	r3, #70	; 0x46
3000bef2:	f008 f98f 	bl	30014214 <_panic>
            ASSERT(0);
3000bef6:	f641 2300 	movw	r3, #6656	; 0x1a00
3000befa:	f24e 62fc 	movw	r2, #59132	; 0xe6fc
3000befe:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000bf02:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000bf06:	4670      	mov	r0, r14
3000bf08:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000bf0c:	9300      	str	r3, [sp, #0]
3000bf0e:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000bf12:	235f      	movs	r3, #95	; 0x5f
3000bf14:	f008 f97e 	bl	30014214 <_panic>
            ASSERT(0);
3000bf18:	f641 2300 	movw	r3, #6656	; 0x1a00
3000bf1c:	f24e 62fc 	movw	r2, #59132	; 0xe6fc
3000bf20:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000bf24:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000bf28:	4670      	mov	r0, r14
3000bf2a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000bf2e:	9300      	str	r3, [sp, #0]
3000bf30:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000bf34:	2374      	movs	r3, #116	; 0x74
3000bf36:	f008 f96d 	bl	30014214 <_panic>
                ASSERT(0);
3000bf3a:	f641 2300 	movw	r3, #6656	; 0x1a00
3000bf3e:	f24e 62fc 	movw	r2, #59132	; 0xe6fc
3000bf42:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000bf46:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000bf4a:	4670      	mov	r0, r14
3000bf4c:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000bf50:	9300      	str	r3, [sp, #0]
3000bf52:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000bf56:	2359      	movs	r3, #89	; 0x59
3000bf58:	f008 f95c 	bl	30014214 <_panic>

3000bf5c <uart_drv_putc>:
        if (context->fifo_enable) {
3000bf5c:	780b      	ldrb	r3, [r1, #0]
3000bf5e:	b123      	cbz	r3, 3000bf6a <uart_drv_putc+0xe>
            while (dev->USR.TFNF != 1); //wait transmit fifo is not full
3000bf60:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
3000bf62:	0799      	lsls	r1, r3, #30
3000bf64:	d5fc      	bpl.n	3000bf60 <uart_drv_putc+0x4>
        writeb(data, &dev->THR);
3000bf66:	7002      	strb	r2, [r0, #0]
}
3000bf68:	4770      	bx	r14
            while (dev->LSR.THRE != 1); //wait transmit holding register empty
3000bf6a:	6943      	ldr	r3, [r0, #20]
3000bf6c:	069b      	lsls	r3, r3, #26
3000bf6e:	d4fa      	bmi.n	3000bf66 <uart_drv_putc+0xa>
3000bf70:	6943      	ldr	r3, [r0, #20]
3000bf72:	069b      	lsls	r3, r3, #26
3000bf74:	d5f9      	bpl.n	3000bf6a <uart_drv_putc+0xe>
3000bf76:	e7f6      	b.n	3000bf66 <uart_drv_putc+0xa>

3000bf78 <uart_drv_int_cbk_register>:
void uart_drv_int_cbk_register(uart_drv_context_t *context,
                               uart_drv_int_src_t int_src,
                               uart_drv_int_callback cbk)

{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
3000bf78:	b129      	cbz	r1, 3000bf86 <uart_drv_int_cbk_register+0xe>
        context->rx_char_cbk = cbk;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
3000bf7a:	2901      	cmp	r1, #1
3000bf7c:	d005      	beq.n	3000bf8a <uart_drv_int_cbk_register+0x12>
        context->rx_str_cbk = cbk;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
3000bf7e:	2902      	cmp	r1, #2
        context->tx_str_cbk = cbk;
3000bf80:	bf08      	it	eq
3000bf82:	6102      	streq	r2, [r0, #16]
    }
}
3000bf84:	4770      	bx	r14
        context->rx_char_cbk = cbk;
3000bf86:	6082      	str	r2, [r0, #8]
3000bf88:	4770      	bx	r14
        context->rx_str_cbk = cbk;
3000bf8a:	60c2      	str	r2, [r0, #12]
3000bf8c:	4770      	bx	r14
3000bf8e:	bf00      	nop

3000bf90 <uart_drv_int_src_enable>:

void uart_drv_int_src_enable(DW_APB_UART_uart_TypeDef *dev,
                             uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
3000bf90:	b141      	cbz	r1, 3000bfa4 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
3000bf92:	2901      	cmp	r1, #1
3000bf94:	d006      	beq.n	3000bfa4 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
3000bf96:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 1;
3000bf98:	bf02      	ittt	eq
3000bf9a:	6843      	ldreq	r3, [r0, #4]
3000bf9c:	f043 0302 	orreq.w	r3, r3, #2
3000bfa0:	6043      	streq	r3, [r0, #4]
    }
}
3000bfa2:	4770      	bx	r14
        dev->IER.ERBFI = 1;
3000bfa4:	6843      	ldr	r3, [r0, #4]
3000bfa6:	f043 0301 	orr.w	r3, r3, #1
3000bfaa:	6043      	str	r3, [r0, #4]
3000bfac:	4770      	bx	r14
3000bfae:	bf00      	nop

3000bfb0 <uart_drv_int_src_disable>:

void uart_drv_int_src_disable(DW_APB_UART_uart_TypeDef *dev,
                              uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
3000bfb0:	b141      	cbz	r1, 3000bfc4 <uart_drv_int_src_disable+0x14>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
3000bfb2:	2901      	cmp	r1, #1
3000bfb4:	d00b      	beq.n	3000bfce <uart_drv_int_src_disable+0x1e>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
3000bfb6:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 0;
3000bfb8:	bf02      	ittt	eq
3000bfba:	6843      	ldreq	r3, [r0, #4]
3000bfbc:	f36f 0341 	bfceq	r3, #1, #1
3000bfc0:	6043      	streq	r3, [r0, #4]
    }
}
3000bfc2:	4770      	bx	r14
        dev->IER.ERBFI = 0;
3000bfc4:	6843      	ldr	r3, [r0, #4]
3000bfc6:	f361 0300 	bfi	r3, r1, #0, #1
3000bfca:	6043      	str	r3, [r0, #4]
3000bfcc:	4770      	bx	r14
        dev->IER.ERBFI = 0;
3000bfce:	6843      	ldr	r3, [r0, #4]
3000bfd0:	f36f 0300 	bfc	r3, #0, #1
3000bfd4:	6043      	str	r3, [r0, #4]
3000bfd6:	4770      	bx	r14

3000bfd8 <uart_drv_irq_handle>:
enum handler_return uart_drv_irq_handle(DW_APB_UART_uart_TypeDef *dev,
                                        uart_drv_context_t *context)
{
    bool resched = true;
    char data = 0;
    IIR_Type IIR = dev->IIR;        //interrupt identification register
3000bfd8:	6883      	ldr	r3, [r0, #8]
{
3000bfda:	b570      	push	{r4, r5, r6, r14}
3000bfdc:	460c      	mov	r4, r1
    LSR_Type LSR = dev->LSR;        //line status register

    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
3000bfde:	b2db      	uxtb	r3, r3
{
3000bfe0:	4605      	mov	r5, r0
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
3000bfe2:	f003 020d 	and.w	r2, r3, #13
    LSR_Type LSR = dev->LSR;        //line status register
3000bfe6:	6941      	ldr	r1, [r0, #20]
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
3000bfe8:	2a04      	cmp	r2, #4
3000bfea:	d13a      	bne.n	3000c062 <uart_drv_irq_handle+0x8a>
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
        //rx irq
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
                || LSR.ADDR_RCVD == UART_DRV_LSR_RX_ADDR_IND) {
3000bfec:	f240 1301 	movw	r3, #257	; 0x101
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
3000bff0:	420b      	tst	r3, r1
3000bff2:	d034      	beq.n	3000c05e <uart_drv_irq_handle+0x86>
            if (context->fifo_enable) {
3000bff4:	7826      	ldrb	r6, [r4, #0]
3000bff6:	68e2      	ldr	r2, [r4, #12]
3000bff8:	2e00      	cmp	r6, #0
3000bffa:	d163      	bne.n	3000c0c4 <uart_drv_irq_handle+0xec>
                    }
                }
                else
#endif
                {
                    data = dev->RBR.RBR8;
3000bffc:	6800      	ldr	r0, [r0, #0]
3000bffe:	b2c0      	uxtb	r0, r0
                }

                //asynchronous receive
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
3000c000:	2a00      	cmp	r2, #0
3000c002:	d079      	beq.n	3000c0f8 <uart_drv_irq_handle+0x120>
3000c004:	6a23      	ldr	r3, [r4, #32]
3000c006:	2b00      	cmp	r3, #0
3000c008:	d076      	beq.n	3000c0f8 <uart_drv_irq_handle+0x120>
    *context->rx_shadow.rx_ptr = data;
3000c00a:	69e3      	ldr	r3, [r4, #28]
3000c00c:	7018      	strb	r0, [r3, #0]
    context->rx_shadow.len_rest -= 1;
3000c00e:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
3000c012:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
3000c014:	3b01      	subs	r3, #1
3000c016:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
3000c01a:	b96b      	cbnz	r3, 3000c038 <uart_drv_irq_handle+0x60>
        dev->IER.ERBFI = 0;
3000c01c:	686a      	ldr	r2, [r5, #4]
3000c01e:	f363 0200 	bfi	r2, r3, #0, #1
3000c022:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
3000c024:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
3000c026:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
3000c028:	f363 1205 	bfi	r2, r3, #4, #2
3000c02c:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
3000c02e:	6862      	ldr	r2, [r4, #4]
3000c030:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
3000c032:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
3000c034:	4788      	blx	r1
3000c036:	6a23      	ldr	r3, [r4, #32]
                    uart_drv_async_rx_char(dev, context, data);

                    if (context->rx_shadow.len_rest) {
3000c038:	fab3 f083 	clz	r0, r3
3000c03c:	0940      	lsrs	r0, r0, #5
            }
        }
    }

    return resched ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
}
3000c03e:	bd70      	pop	{r4, r5, r6, r15}
            if (context->tx_shadow.len_rest && dev->LSR.THRE) {
3000c040:	2b00      	cmp	r3, #0
3000c042:	d065      	beq.n	3000c110 <uart_drv_irq_handle+0x138>
3000c044:	6943      	ldr	r3, [r0, #20]
3000c046:	069b      	lsls	r3, r3, #26
3000c048:	d509      	bpl.n	3000c05e <uart_drv_irq_handle+0x86>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
3000c04a:	6963      	ldr	r3, [r4, #20]
3000c04c:	1c5a      	adds	r2, r3, #1
3000c04e:	6162      	str	r2, [r4, #20]
3000c050:	781b      	ldrb	r3, [r3, #0]
3000c052:	7003      	strb	r3, [r0, #0]
                context->tx_shadow.len_rest -= 1;
3000c054:	69a3      	ldr	r3, [r4, #24]
3000c056:	3b01      	subs	r3, #1
3000c058:	61a3      	str	r3, [r4, #24]
        if (context->tx_shadow.len_rest == 0) {
3000c05a:	2b00      	cmp	r3, #0
3000c05c:	d058      	beq.n	3000c110 <uart_drv_irq_handle+0x138>
3000c05e:	2001      	movs	r0, #1
}
3000c060:	bd70      	pop	{r4, r5, r6, r15}
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
3000c062:	f003 030f 	and.w	r3, r3, #15
    else if (IIR.IID == UART_DRV_IID_RX_CHAR_TIMEOUT) {
3000c066:	2b0c      	cmp	r3, #12
3000c068:	d043      	beq.n	3000c0f2 <uart_drv_irq_handle+0x11a>
    else if (IIR.IID == UART_DRV_IID_THR_EMPTY) {
3000c06a:	2b02      	cmp	r3, #2
3000c06c:	d1f7      	bne.n	3000c05e <uart_drv_irq_handle+0x86>
3000c06e:	69a3      	ldr	r3, [r4, #24]
        if (context->fifo_enable) {
3000c070:	7822      	ldrb	r2, [r4, #0]
3000c072:	2a00      	cmp	r2, #0
3000c074:	d0e4      	beq.n	3000c040 <uart_drv_irq_handle+0x68>
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
3000c076:	b953      	cbnz	r3, 3000c08e <uart_drv_irq_handle+0xb6>
3000c078:	e04a      	b.n	3000c110 <uart_drv_irq_handle+0x138>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
3000c07a:	6963      	ldr	r3, [r4, #20]
3000c07c:	1c5a      	adds	r2, r3, #1
3000c07e:	6162      	str	r2, [r4, #20]
3000c080:	781b      	ldrb	r3, [r3, #0]
3000c082:	702b      	strb	r3, [r5, #0]
                context->tx_shadow.len_rest -= 1;
3000c084:	69a3      	ldr	r3, [r4, #24]
3000c086:	3b01      	subs	r3, #1
3000c088:	61a3      	str	r3, [r4, #24]
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
3000c08a:	2b00      	cmp	r3, #0
3000c08c:	d040      	beq.n	3000c110 <uart_drv_irq_handle+0x138>
3000c08e:	6feb      	ldr	r3, [r5, #124]	; 0x7c
3000c090:	079a      	lsls	r2, r3, #30
3000c092:	d5e4      	bpl.n	3000c05e <uart_drv_irq_handle+0x86>
3000c094:	e7f1      	b.n	3000c07a <uart_drv_irq_handle+0xa2>
    *context->rx_shadow.rx_ptr = data;
3000c096:	69e2      	ldr	r2, [r4, #28]
3000c098:	7013      	strb	r3, [r2, #0]
    context->rx_shadow.len_rest -= 1;
3000c09a:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
3000c09e:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
3000c0a0:	3b01      	subs	r3, #1
3000c0a2:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
3000c0a6:	b963      	cbnz	r3, 3000c0c2 <uart_drv_irq_handle+0xea>
        dev->IER.ERBFI = 0;
3000c0a8:	686a      	ldr	r2, [r5, #4]
3000c0aa:	f363 0200 	bfi	r2, r3, #0, #1
3000c0ae:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
3000c0b0:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
3000c0b2:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
3000c0b4:	f363 1205 	bfi	r2, r3, #4, #2
3000c0b8:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
3000c0ba:	6862      	ldr	r2, [r4, #4]
3000c0bc:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
3000c0be:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
3000c0c0:	4788      	blx	r1
3000c0c2:	68e2      	ldr	r2, [r4, #12]
                while (dev->USR.RFNE) {
3000c0c4:	6feb      	ldr	r3, [r5, #124]	; 0x7c
3000c0c6:	0719      	lsls	r1, r3, #28
3000c0c8:	d50e      	bpl.n	3000c0e8 <uart_drv_irq_handle+0x110>
                        data = dev->RBR.RBR8;
3000c0ca:	682b      	ldr	r3, [r5, #0]
3000c0cc:	b2db      	uxtb	r3, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
3000c0ce:	b11a      	cbz	r2, 3000c0d8 <uart_drv_irq_handle+0x100>
3000c0d0:	6a21      	ldr	r1, [r4, #32]
        context->rx_str_cbk(data);
3000c0d2:	4618      	mov	r0, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
3000c0d4:	2900      	cmp	r1, #0
3000c0d6:	d1de      	bne.n	3000c096 <uart_drv_irq_handle+0xbe>
                             || (context->rx_char_cbk(data) != 1)) {
3000c0d8:	4618      	mov	r0, r3
                    else if ((context->rx_char_cbk == NULL)
3000c0da:	68a3      	ldr	r3, [r4, #8]
3000c0dc:	b31b      	cbz	r3, 3000c126 <uart_drv_irq_handle+0x14e>
                             || (context->rx_char_cbk(data) != 1)) {
3000c0de:	4798      	blx	r3
3000c0e0:	2801      	cmp	r0, #1
3000c0e2:	d0ee      	beq.n	3000c0c2 <uart_drv_irq_handle+0xea>
3000c0e4:	68e2      	ldr	r2, [r4, #12]
                        resched = false;
3000c0e6:	2600      	movs	r6, #0
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
3000c0e8:	b182      	cbz	r2, 3000c10c <uart_drv_irq_handle+0x134>
3000c0ea:	6a23      	ldr	r3, [r4, #32]
3000c0ec:	b173      	cbz	r3, 3000c10c <uart_drv_irq_handle+0x134>
3000c0ee:	2000      	movs	r0, #0
}
3000c0f0:	bd70      	pop	{r4, r5, r6, r15}
        data = dev->RBR.RBR8;
3000c0f2:	6803      	ldr	r3, [r0, #0]
3000c0f4:	2001      	movs	r0, #1
}
3000c0f6:	bd70      	pop	{r4, r5, r6, r15}
                else if ((context->rx_char_cbk == NULL)
3000c0f8:	68a3      	ldr	r3, [r4, #8]
3000c0fa:	2b00      	cmp	r3, #0
3000c0fc:	d0f7      	beq.n	3000c0ee <uart_drv_irq_handle+0x116>
                         || (context->rx_char_cbk(data) != 1)) {
3000c0fe:	4798      	blx	r3
3000c100:	f1a0 0001 	sub.w	r0, r0, #1
3000c104:	fab0 f080 	clz	r0, r0
3000c108:	0940      	lsrs	r0, r0, #5
}
3000c10a:	bd70      	pop	{r4, r5, r6, r15}
3000c10c:	4630      	mov	r0, r6
3000c10e:	bd70      	pop	{r4, r5, r6, r15}
        dev->IER.ETBEI = 0;
3000c110:	686b      	ldr	r3, [r5, #4]
3000c112:	f36f 0341 	bfc	r3, #1, #1
3000c116:	606b      	str	r3, [r5, #4]
            if (context->tx_str_cbk) {
3000c118:	6923      	ldr	r3, [r4, #16]
3000c11a:	2b00      	cmp	r3, #0
3000c11c:	d09f      	beq.n	3000c05e <uart_drv_irq_handle+0x86>
                context->tx_str_cbk(true);
3000c11e:	2001      	movs	r0, #1
3000c120:	4798      	blx	r3
3000c122:	2001      	movs	r0, #1
}
3000c124:	bd70      	pop	{r4, r5, r6, r15}
                        resched = false;
3000c126:	461e      	mov	r6, r3
3000c128:	e7de      	b.n	3000c0e8 <uart_drv_irq_handle+0x110>
3000c12a:	bf00      	nop

3000c12c <dw_usbc_dataoutstagecb.isra.12>:
    }

    uc->do_resched = true;
}

static void dw_usbc_dataoutstagecb(int instance, DW_USB_EP *ep)
3000c12c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
3000c130:	460e      	mov	r6, r1
{
    DW_USB_Context *uc = &g_usbc[instance];
    usbc_transfer_t *t = 0;

    if (uc->ep_out[ep->num].transfer) {
3000c132:	eb00 0340 	add.w	r3, r0, r0, lsl #1
3000c136:	f249 6580 	movw	r5, #38528	; 0x9680
3000c13a:	7809      	ldrb	r1, [r1, #0]
3000c13c:	eb03 1303 	add.w	r3, r3, r3, lsl #4
static void dw_usbc_dataoutstagecb(int instance, DW_USB_EP *ep)
3000c140:	4604      	mov	r4, r0
    if (uc->ep_out[ep->num].transfer) {
3000c142:	f2c3 0502 	movt	r5, #12290	; 0x3002
3000c146:	eb00 0843 	add.w	r8, r0, r3, lsl #1
3000c14a:	4441      	add	r1, r8
3000c14c:	eb05 01c1 	add.w	r1, r5, r1, lsl #3
3000c150:	f8d1 92fc 	ldr.w	r9, [r1, #764]	; 0x2fc
3000c154:	f1b9 0f00 	cmp.w	r9, #0
3000c158:	d01e      	beq.n	3000c198 <dw_usbc_dataoutstagecb.isra.12+0x6c>
        // completing a transfer
        t = uc->ep_out[ep->num].transfer;
        arch_invalidate_cache_range((addr_t)(t->buf), ROUNDUP(ep->xfer_count,
3000c15a:	6811      	ldr	r1, [r2, #0]
3000c15c:	4617      	mov	r7, r2
3000c15e:	f8d9 0008 	ldr.w	r0, [r9, #8]
3000c162:	311f      	adds	r1, #31
3000c164:	f021 011f 	bic.w	r1, r1, #31
3000c168:	f7f5 ecd4 	blx	30001b14 <arch_invalidate_cache_range>
                                    CACHE_LINE));
        uc->ep_out[ep->num].transfer = 0;
3000c16c:	7833      	ldrb	r3, [r6, #0]
3000c16e:	2200      	movs	r2, #0
3000c170:	4443      	add	r3, r8
        LTRACEF("completing transfer %p\n", t);
        t->bufpos = ep->xfer_count;
        t->result = 0;

        if (t->callback) {
3000c172:	f8d9 8000 	ldr.w	r8, [r9]
        uc->ep_out[ep->num].transfer = 0;
3000c176:	335f      	adds	r3, #95	; 0x5f
3000c178:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
3000c17c:	605a      	str	r2, [r3, #4]
        t->bufpos = ep->xfer_count;
3000c17e:	683b      	ldr	r3, [r7, #0]
3000c180:	f8c9 3010 	str.w	r3, [r9, #16]
        t->result = 0;
3000c184:	f8c9 2004 	str.w	r2, [r9, #4]
        if (t->callback) {
3000c188:	f1b8 0f00 	cmp.w	r8, #0
3000c18c:	d004      	beq.n	3000c198 <dw_usbc_dataoutstagecb.isra.12+0x6c>
            t->callback(ep->num | 0x80, t);
3000c18e:	7830      	ldrb	r0, [r6, #0]
3000c190:	4649      	mov	r1, r9
3000c192:	f040 0080 	orr.w	r0, r0, #128	; 0x80
3000c196:	47c0      	blx	r8
        }
    }

    uc->do_resched = true;
3000c198:	f44f 704e 	mov.w	r0, #824	; 0x338
3000c19c:	2301      	movs	r3, #1
3000c19e:	fb00 5004 	mla	r0, r0, r4, r5
3000c1a2:	f880 32b4 	strb.w	r3, [r0, #692]	; 0x2b4
}
3000c1a6:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
3000c1aa:	bf00      	nop

3000c1ac <dw_usbc_wakeup.part.17>:
void dw_usbc_wakeup(int instance)
3000c1ac:	b508      	push	{r3, r14}
        ret = dw_usb_ll_wakeup(uc->io_base);
3000c1ae:	f44f 734e 	mov.w	r3, #824	; 0x338
3000c1b2:	f249 6280 	movw	r2, #38528	; 0x9680
3000c1b6:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000c1ba:	fb03 f000 	mul.w	r0, r3, r0
3000c1be:	5810      	ldr	r0, [r2, r0]
3000c1c0:	f001 fa3a 	bl	3000d638 <dw_usb_ll_wakeup>
        if (ret) {
3000c1c4:	b900      	cbnz	r0, 3000c1c8 <dw_usbc_wakeup.part.17+0x1c>
}
3000c1c6:	bd08      	pop	{r3, r15}
3000c1c8:	4601      	mov	r1, r0
            printf("wakeup failed --> %d\n", ret);
3000c1ca:	f24e 7078 	movw	r0, #59256	; 0xe778
3000c1ce:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000c1d2:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
            printf("wakeup failed --> %d\n", ret);
3000c1d6:	f009 bceb 	b.w	30015bb0 <_printf>
3000c1da:	bf00      	nop

3000c1dc <dw_usbc_ep_trans>:
{
3000c1dc:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    if (ep->xfer_len > ep->maxpacket) {
3000c1e0:	68cd      	ldr	r5, [r1, #12]
{
3000c1e2:	460c      	mov	r4, r1
    ep->xfer_len = len;
3000c1e4:	618b      	str	r3, [r1, #24]
{
3000c1e6:	4617      	mov	r7, r2
3000c1e8:	4606      	mov	r6, r0
    if (ep->xfer_len > ep->maxpacket) {
3000c1ea:	429d      	cmp	r5, r3
    ep->xfer_buff = pBuf;
3000c1ec:	614a      	str	r2, [r1, #20]
        ep->xfer_len -= len;
3000c1ee:	bf3c      	itt	cc
3000c1f0:	1b5b      	subcc	r3, r3, r5
3000c1f2:	618b      	strcc	r3, [r1, #24]
    if (ep->xfer_len > ep->maxpacket) {
3000c1f4:	d308      	bcc.n	3000c208 <dw_usbc_ep_trans+0x2c>
        ep->xfer_len = 0;
3000c1f6:	2100      	movs	r1, #0
        if (ep->is_in == 0) { //out packet need align with mps
3000c1f8:	7862      	ldrb	r2, [r4, #1]
        ep->xfer_len = 0;
3000c1fa:	61a1      	str	r1, [r4, #24]
        if (ep->is_in == 0) { //out packet need align with mps
3000c1fc:	2a00      	cmp	r2, #0
3000c1fe:	d179      	bne.n	3000c2f4 <dw_usbc_ep_trans+0x118>
            len = ROUNDUP(len, ep->maxpacket);
3000c200:	3b01      	subs	r3, #1
3000c202:	442b      	add	r3, r5
3000c204:	426d      	negs	r5, r5
3000c206:	401d      	ands	r5, r3
    trbd_t *trbd = ep->trbd;
3000c208:	f8d4 8004 	ldr.w	r8, [r4, #4]
    memset(trbd->trb, 0, sizeof(trb_t));
3000c20c:	2100      	movs	r1, #0
        paddr = p2ap(0);
3000c20e:	4638      	mov	r0, r7
    memset(trbd->trb, 0, sizeof(trb_t));
3000c210:	f8d8 3000 	ldr.w	r3, [r8]
3000c214:	6019      	str	r1, [r3, #0]
3000c216:	6059      	str	r1, [r3, #4]
3000c218:	6099      	str	r1, [r3, #8]
3000c21a:	60d9      	str	r1, [r3, #12]
    trbd->orig_size = size;
3000c21c:	f8c8 5008 	str.w	r5, [r8, #8]
    if (buf == 0) {
3000c220:	2f00      	cmp	r7, #0
3000c222:	f000 808e 	beq.w	3000c342 <dw_usbc_ep_trans+0x166>
        paddr = p2ap(v2p(buf));
3000c226:	f003 fd05 	bl	3000fc34 <p2ap>
        arch_clean_cache_range((addr_t)buf, ROUNDUP(size, CACHE_LINE));
3000c22a:	f105 011f 	add.w	r1, r5, #31
3000c22e:	f021 011f 	bic.w	r1, r1, #31
        paddr = p2ap(v2p(buf));
3000c232:	4681      	mov	r9, r0
        arch_clean_cache_range((addr_t)buf, ROUNDUP(size, CACHE_LINE));
3000c234:	4638      	mov	r0, r7
3000c236:	f7f5 ec6a 	blx	30001b0c <arch_clean_cache_range>
    trbd->trb->bp_l = (uint32_t)(paddr & 0xffffffff);
3000c23a:	f8d8 3000 	ldr.w	r3, [r8]
    trbd->trb->trb3.lst = 1;
3000c23e:	7b1a      	ldrb	r2, [r3, #12]
    trbd->trb->bp_h = (uint32_t)((paddr >> 32) & 0xffffffff);
3000c240:	2100      	movs	r1, #0
    trbd->trb->trb3.chn = 0;
3000c242:	f042 0202 	orr.w	r2, r2, #2
    trbd->trb->bp_l = (uint32_t)(paddr & 0xffffffff);
3000c246:	f8c3 9000 	str.w	r9, [r3]
    trbd->trb->trb3.csp = 0;
3000c24a:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    trbd->trb->trb2.bufsize = size;
3000c24e:	6898      	ldr	r0, [r3, #8]
    trbd->trb->trb3.csp = 0;
3000c250:	f361 02c3 	bfi	r2, r1, #3, #1
    trbd->trb->bp_h = (uint32_t)((paddr >> 32) & 0xffffffff);
3000c254:	6059      	str	r1, [r3, #4]
    trbd->trb->trb3.csp = 0;
3000c256:	731a      	strb	r2, [r3, #12]
    trbd->trb->trb2.bufsize = size;
3000c258:	f365 0017 	bfi	r0, r5, #0, #24
        if (uc->ep0stage == EP0_SETUP_PHASE) {
3000c25c:	f249 6580 	movw	r5, #38528	; 0x9680
    trbd->trb->trb2.bufsize = size;
3000c260:	6098      	str	r0, [r3, #8]
    if (ep->num == 0) {
3000c262:	7822      	ldrb	r2, [r4, #0]
3000c264:	b36a      	cbz	r2, 3000c2c2 <dw_usbc_ep_trans+0xe6>
3000c266:	f2c3 0502 	movt	r5, #12290	; 0x3002
    if (((ep_type_t)ep->type == USB_ISOC)) {
3000c26a:	78e2      	ldrb	r2, [r4, #3]
3000c26c:	2a01      	cmp	r2, #1
3000c26e:	bf14      	ite	ne
3000c270:	2201      	movne	r2, #1
3000c272:	2206      	moveq	r2, #6
    trbd->trb->trb3.trbctl = gettrbctl(instance, ep);
3000c274:	8999      	ldrh	r1, [r3, #12]
    arch_clean_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000c276:	4618      	mov	r0, r3
    trbd->trb->trb3.trbctl = gettrbctl(instance, ep);
3000c278:	f362 1109 	bfi	r1, r2, #4, #6
    trbd->trb->trb3.isp_imi = 1;
3000c27c:	f3c1 2207 	ubfx	r2, r1, #8, #8
    trbd->trb->trb3.trbctl = gettrbctl(instance, ep);
3000c280:	8199      	strh	r1, [r3, #12]
    trbd->trb->trb3.ioc = 1;
3000c282:	f042 020c 	orr.w	r2, r2, #12
    arch_clean_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000c286:	2120      	movs	r1, #32
    trbd->trb->trb3.ioc = 1;
3000c288:	735a      	strb	r2, [r3, #13]
    trbd->trb->trb3.sid = 0;
3000c28a:	68df      	ldr	r7, [r3, #12]
3000c28c:	f36f 379d 	bfc	r7, #14, #16
3000c290:	60df      	str	r7, [r3, #12]
    trbd->trb->trb3.hwo = 1;
3000c292:	b2fa      	uxtb	r2, r7
3000c294:	f042 0201 	orr.w	r2, r2, #1
3000c298:	731a      	strb	r2, [r3, #12]
    arch_clean_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000c29a:	f7f5 ec38 	blx	30001b0c <arch_clean_cache_range>
    if (!ep->is_busy) {
3000c29e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
3000c2a2:	b34b      	cbz	r3, 3000c2f8 <dw_usbc_ep_trans+0x11c>
    return epnum * 2 + is_in;
3000c2a4:	7820      	ldrb	r0, [r4, #0]
3000c2a6:	7861      	ldrb	r1, [r4, #1]
    dw_usb_ll_ep_update_transfer(uc->io_base, p_num, ep->res_id);
3000c2a8:	f44f 734e 	mov.w	r3, #824	; 0x338
3000c2ac:	eb01 0140 	add.w	r1, r1, r0, lsl #1
3000c2b0:	6a62      	ldr	r2, [r4, #36]	; 0x24
3000c2b2:	fb03 f606 	mul.w	r6, r3, r6
3000c2b6:	59a8      	ldr	r0, [r5, r6]
3000c2b8:	f001 fa24 	bl	3000d704 <dw_usb_ll_ep_update_transfer>
}
3000c2bc:	2000      	movs	r0, #0
3000c2be:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        if (uc->ep0stage == EP0_SETUP_PHASE) {
3000c2c2:	f44f 724e 	mov.w	r2, #824	; 0x338
3000c2c6:	f2c3 0502 	movt	r5, #12290	; 0x3002
3000c2ca:	fb02 5206 	mla	r2, r2, r6, r5
3000c2ce:	f8d2 1290 	ldr.w	r1, [r2, #656]	; 0x290
3000c2d2:	2901      	cmp	r1, #1
3000c2d4:	bf08      	it	eq
3000c2d6:	2202      	moveq	r2, #2
3000c2d8:	d0cc      	beq.n	3000c274 <dw_usbc_ep_trans+0x98>
        else if (uc->ep0stage == EP0_DATA_PHASE) {
3000c2da:	2902      	cmp	r1, #2
3000c2dc:	bf08      	it	eq
3000c2de:	2205      	moveq	r2, #5
3000c2e0:	d0c8      	beq.n	3000c274 <dw_usbc_ep_trans+0x98>
        else if (uc->ep0stage == EP0_STATUS_PHASE) {
3000c2e2:	2903      	cmp	r1, #3
3000c2e4:	d1c1      	bne.n	3000c26a <dw_usbc_ep_trans+0x8e>
            if (uc->three_stage_setup) {
3000c2e6:	f892 2295 	ldrb.w	r2, [r2, #661]	; 0x295
3000c2ea:	2a00      	cmp	r2, #0
3000c2ec:	bf0c      	ite	eq
3000c2ee:	2203      	moveq	r2, #3
3000c2f0:	2204      	movne	r2, #4
3000c2f2:	e7bf      	b.n	3000c274 <dw_usbc_ep_trans+0x98>
3000c2f4:	461d      	mov	r5, r3
3000c2f6:	e787      	b.n	3000c208 <dw_usbc_ep_trans+0x2c>
    param1 = (uint32_t)(trbd->paddr & 0xffffffff);
3000c2f8:	6861      	ldr	r1, [r4, #4]
    needs_wakeup = (uc->link_state == DW_LINK_STATE_U1 ||
3000c2fa:	f44f 724e 	mov.w	r2, #824	; 0x338
    return epnum * 2 + is_in;
3000c2fe:	7823      	ldrb	r3, [r4, #0]
3000c300:	7867      	ldrb	r7, [r4, #1]
    needs_wakeup = (uc->link_state == DW_LINK_STATE_U1 ||
3000c302:	fb02 5206 	mla	r2, r2, r6, r5
    param1 = (uint32_t)(trbd->paddr & 0xffffffff);
3000c306:	f8d1 8004 	ldr.w	r8, [r1, #4]
    return epnum * 2 + is_in;
3000c30a:	eb07 0743 	add.w	r7, r7, r3, lsl #1
                    uc->link_state == DW_LINK_STATE_U2 ||
3000c30e:	f8d2 22b0 	ldr.w	r2, [r2, #688]	; 0x2b0
3000c312:	3a01      	subs	r2, #1
    if (needs_wakeup) {
3000c314:	2a02      	cmp	r2, #2
3000c316:	d802      	bhi.n	3000c31e <dw_usbc_ep_trans+0x142>
3000c318:	4630      	mov	r0, r6
3000c31a:	f7ff ff47 	bl	3000c1ac <dw_usbc_wakeup.part.17>
    dw_usb_ll_ep_start_transfer(uc->io_base, p_num, param0, param1);
3000c31e:	f44f 704e 	mov.w	r0, #824	; 0x338
3000c322:	4643      	mov	r3, r8
3000c324:	2200      	movs	r2, #0
3000c326:	4639      	mov	r1, r7
3000c328:	fb00 f606 	mul.w	r6, r0, r6
3000c32c:	59a8      	ldr	r0, [r5, r6]
3000c32e:	f001 f9db 	bl	3000d6e8 <dw_usb_ll_ep_start_transfer>
    ep->res_id = dw_usb_ll_get_ep_transfer_index(uc->io_base, p_num);
3000c332:	59a8      	ldr	r0, [r5, r6]
3000c334:	4639      	mov	r1, r7
3000c336:	f001 f941 	bl	3000d5bc <dw_usb_ll_get_ep_transfer_index>
3000c33a:	6260      	str	r0, [r4, #36]	; 0x24
}
3000c33c:	2000      	movs	r0, #0
3000c33e:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        paddr = p2ap(0);
3000c342:	f003 fc77 	bl	3000fc34 <p2ap>
3000c346:	4681      	mov	r9, r0
3000c348:	e777      	b.n	3000c23a <dw_usbc_ep_trans+0x5e>
3000c34a:	bf00      	nop

3000c34c <create_trb.isra.7.constprop.21>:
static trbd_t *create_trb(int instance, DW_USB_EP *ep, int num)
3000c34c:	b510      	push	{r4, r14}
    return malloc(size);
3000c34e:	200c      	movs	r0, #12
3000c350:	f008 f9ca 	bl	300146e8 <malloc>
    if (!trbd) {
3000c354:	4604      	mov	r4, r0
3000c356:	b178      	cbz	r0, 3000c378 <create_trb.isra.7.constprop.21+0x2c>
    void *p = memalign(boundary,  tmp);
3000c358:	2120      	movs	r1, #32
3000c35a:	4608      	mov	r0, r1
3000c35c:	f008 f9da 	bl	30014714 <memalign>
    trbd->trb = (trb_t *)usbmemalign(TRB_ALIGN, sizeof(trb_t) * num) ;
3000c360:	6020      	str	r0, [r4, #0]
    void *p = memalign(boundary,  tmp);
3000c362:	4603      	mov	r3, r0
    if (!trbd->trb) {
3000c364:	b150      	cbz	r0, 3000c37c <create_trb.isra.7.constprop.21+0x30>
    memset(trbd->trb, 0, sizeof(trb_t)*num);
3000c366:	2200      	movs	r2, #0
    trbd->orig_size = 0;
3000c368:	60a2      	str	r2, [r4, #8]
    memset(trbd->trb, 0, sizeof(trb_t)*num);
3000c36a:	6002      	str	r2, [r0, #0]
3000c36c:	6042      	str	r2, [r0, #4]
3000c36e:	6082      	str	r2, [r0, #8]
3000c370:	60c2      	str	r2, [r0, #12]
    trbd->paddr = p2ap(v2p(trbd->trb));
3000c372:	f003 fc5f 	bl	3000fc34 <p2ap>
3000c376:	6060      	str	r0, [r4, #4]
}
3000c378:	4620      	mov	r0, r4
3000c37a:	bd10      	pop	{r4, r15}
        free(trbd);
3000c37c:	4620      	mov	r0, r4
        return NULL;
3000c37e:	461c      	mov	r4, r3
        free(trbd);
3000c380:	f008 fa04 	bl	3001478c <free>
3000c384:	e7f8      	b.n	3000c378 <create_trb.isra.7.constprop.21+0x2c>
3000c386:	bf00      	nop

3000c388 <dw_usbc_setup_endpoint>:
{
3000c388:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000c38c:	f44f 7a4e 	mov.w	r10, #824	; 0x338
3000c390:	eb01 0181 	add.w	r1, r1, r1, lsl #2
3000c394:	4607      	mov	r7, r0
3000c396:	b089      	sub	sp, #36	; 0x24
3000c398:	fb0a fa00 	mul.w	r10, r10, r0
3000c39c:	f89d 804c 	ldrb.w	r8, [r13, #76]	; 0x4c
3000c3a0:	f89d 9050 	ldrb.w	r9, [r13, #80]	; 0x50
        ep = &uc->IN_ep[ept];
3000c3a4:	f249 6680 	movw	r6, #38528	; 0x9680
3000c3a8:	eb0a 01c1 	add.w	r1, r10, r1, lsl #3
    if (dir == USB_IN) {
3000c3ac:	2a00      	cmp	r2, #0
3000c3ae:	f040 8098 	bne.w	3000c4e2 <dw_usbc_setup_endpoint+0x15a>
        ep = &uc->IN_ep[ept];
3000c3b2:	310c      	adds	r1, #12
3000c3b4:	f2c3 0602 	movt	r6, #12290	; 0x3002
3000c3b8:	1874      	adds	r4, r6, r1
    ep->type = type;
3000c3ba:	9912      	ldr	r1, [sp, #72]	; 0x48
    ep->is_in = (dir == USB_IN);
3000c3bc:	fab2 f282 	clz	r2, r2
3000c3c0:	f894 c000 	ldrb.w	r12, [r4]
    ep->maxpacket = width;
3000c3c4:	60e3      	str	r3, [r4, #12]
    ep->is_in = (dir == USB_IN);
3000c3c6:	0952      	lsrs	r2, r2, #5
3000c3c8:	4615      	mov	r5, r2
    ep->type = type;
3000c3ca:	b2c8      	uxtb	r0, r1
    ep->is_in = (dir == USB_IN);
3000c3cc:	7062      	strb	r2, [r4, #1]
3000c3ce:	ea4f 014c 	mov.w	r1, r12, lsl #1
    if (ep->num == 0 && ep->is_in == 0
3000c3d2:	f8b4 e000 	ldrh.w	r14, [r4]
    ep->type = type;
3000c3d6:	70e0      	strb	r0, [r4, #3]
    if (ep->num == 0 && ep->is_in == 0
3000c3d8:	f1be 0f00 	cmp.w	r14, #0
3000c3dc:	d105      	bne.n	3000c3ea <dw_usbc_setup_endpoint+0x62>
            && !ep->is_enabled) { //only ep0out do this
3000c3de:	f894 e020 	ldrb.w	r14, [r4, #32]
3000c3e2:	f1be 0f00 	cmp.w	r14, #0
3000c3e6:	f000 8096 	beq.w	3000c516 <dw_usbc_setup_endpoint+0x18e>
    uint32_t param0 = 0, param1 = 0, param2 = 0;
3000c3ea:	f04f 0e00 	mov.w	r14, #0
    return epnum * 2 + is_in;
3000c3ee:	4429      	add	r1, r5
    uint32_t param0 = 0, param1 = 0, param2 = 0;
3000c3f0:	f8cd e014 	str.w	r14, [r13, #20]
    RMWREG32(&param0, 1, 2, ep->type);
3000c3f4:	9a05      	ldr	r2, [sp, #20]
    uint32_t param0 = 0, param1 = 0, param2 = 0;
3000c3f6:	f8cd e018 	str.w	r14, [r13, #24]
3000c3fa:	f8cd e01c 	str.w	r14, [r13, #28]
    RMWREG32(&param0, 1, 2, ep->type);
3000c3fe:	f022 0206 	bic.w	r2, r2, #6
3000c402:	ea42 0240 	orr.w	r2, r2, r0, lsl #1
3000c406:	9205      	str	r2, [sp, #20]
    RMWREG32(&param0, 3, 11, ep->maxpacket);
3000c408:	9a05      	ldr	r2, [sp, #20]
3000c40a:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
3000c40e:	f022 0238 	bic.w	r2, r2, #56	; 0x38
3000c412:	ea42 02c3 	orr.w	r2, r2, r3, lsl #3
3000c416:	9205      	str	r2, [sp, #20]
        RMWREG32(&param0, 30, 2, 2);
3000c418:	9b05      	ldr	r3, [sp, #20]
    if (modify) {
3000c41a:	f1b8 0f00 	cmp.w	r8, #0
3000c41e:	d050      	beq.n	3000c4c2 <dw_usbc_setup_endpoint+0x13a>
        RMWREG32(&param0, 30, 2, 2);
3000c420:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
3000c424:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
3000c428:	9305      	str	r3, [sp, #20]
        RMWREG32(&param0, 17, 5, ep->num);
3000c42a:	9a05      	ldr	r2, [sp, #20]
    if (ep->is_in) {
3000c42c:	b125      	cbz	r5, 3000c438 <dw_usbc_setup_endpoint+0xb0>
        RMWREG32(&param0, 17, 5, ep->num);
3000c42e:	f422 1278 	bic.w	r2, r2, #4063232	; 0x3e0000
3000c432:	ea42 424c 	orr.w	r2, r2, r12, lsl #17
3000c436:	9205      	str	r2, [sp, #20]
    RMWREG32(&param1, 8, 1, 1);
3000c438:	9b06      	ldr	r3, [sp, #24]
    if (ep->num == 0 || ep->type == USB_ISOC) {
3000c43a:	f1bc 0f00 	cmp.w	r12, #0
3000c43e:	bf18      	it	ne
3000c440:	2801      	cmpne	r0, #1
    RMWREG32(&param1, 8, 1, 1);
3000c442:	f443 7380 	orr.w	r3, r3, #256	; 0x100
3000c446:	9306      	str	r3, [sp, #24]
        RMWREG32(&param1, 10, 1, 1);
3000c448:	bf02      	ittt	eq
3000c44a:	9b06      	ldreq	r3, [sp, #24]
3000c44c:	f443 6380 	orreq.w	r3, r3, #1024	; 0x400
3000c450:	9306      	streq	r3, [sp, #24]
    if (ep->type != USB_CTRL) {
3000c452:	b118      	cbz	r0, 3000c45c <dw_usbc_setup_endpoint+0xd4>
        RMWREG32(&param1, 9, 1, 1);
3000c454:	9b06      	ldr	r3, [sp, #24]
3000c456:	f443 7300 	orr.w	r3, r3, #512	; 0x200
3000c45a:	9306      	str	r3, [sp, #24]
    RMWREG32(&param1, 25, 5, ((ep->num << 1) | ep->is_in));
3000c45c:	9b06      	ldr	r3, [sp, #24]
3000c45e:	ea45 054c 	orr.w	r5, r5, r12, lsl #1
    dw_usb_ll_set_ep_config(uc->io_base, p_num, param0, param1, param2);
3000c462:	f8cd e000 	str.w	r14, [r13]
3000c466:	f44f 704e 	mov.w	r0, #824	; 0x338
    RMWREG32(&param1, 25, 5, ((ep->num << 1) | ep->is_in));
3000c46a:	f023 5c78 	bic.w	r12, r3, #1040187392	; 0x3e000000
3000c46e:	ea4c 6545 	orr.w	r5, r12, r5, lsl #25
    dw_usb_ll_set_ep_config(uc->io_base, p_num, param0, param1, param2);
3000c472:	fb00 f307 	mul.w	r3, r0, r7
    RMWREG32(&param1, 25, 5, ((ep->num << 1) | ep->is_in));
3000c476:	9506      	str	r5, [sp, #24]
    RMWREG32(&param1, 16, 8, 0);
3000c478:	9d06      	ldr	r5, [sp, #24]
    dw_usb_ll_set_ep_config(uc->io_base, p_num, param0, param1, param2);
3000c47a:	eb06 0803 	add.w	r8, r6, r3
3000c47e:	58f0      	ldr	r0, [r6, r3]
    RMWREG32(&param1, 16, 8, 0);
3000c480:	f425 057f 	bic.w	r5, r5, #16711680	; 0xff0000
    dw_usb_ll_set_ep_config(uc->io_base, p_num, param0, param1, param2);
3000c484:	462b      	mov	r3, r5
    RMWREG32(&param1, 16, 8, 0);
3000c486:	9506      	str	r5, [sp, #24]
    dw_usb_ll_set_ep_config(uc->io_base, p_num, param0, param1, param2);
3000c488:	f001 f87c 	bl	3000d584 <dw_usb_ll_set_ep_config>
    if (ep->num == 0) {
3000c48c:	7823      	ldrb	r3, [r4, #0]
3000c48e:	bb9b      	cbnz	r3, 3000c4f8 <dw_usbc_setup_endpoint+0x170>
        ep->trbd = uc->ep0_trbd;
3000c490:	f8d8 329c 	ldr.w	r3, [r8, #668]	; 0x29c
3000c494:	6063      	str	r3, [r4, #4]
    if (!ep->is_enabled) {
3000c496:	f894 5020 	ldrb.w	r5, [r4, #32]
    return NO_ERROR;
3000c49a:	2000      	movs	r0, #0
    if (!ep->is_enabled) {
3000c49c:	b975      	cbnz	r5, 3000c4bc <dw_usbc_setup_endpoint+0x134>
    dw_usb_ll_ep_open(uc->io_base, p_num);
3000c49e:	f44f 734e 	mov.w	r3, #824	; 0x338
    return epnum * 2 + is_in;
3000c4a2:	7821      	ldrb	r1, [r4, #0]
    dw_usb_ll_ep_open(uc->io_base, p_num);
3000c4a4:	fb03 f707 	mul.w	r7, r3, r7
    return epnum * 2 + is_in;
3000c4a8:	7863      	ldrb	r3, [r4, #1]
    dw_usb_ll_ep_open(uc->io_base, p_num);
3000c4aa:	eb03 0141 	add.w	r1, r3, r1, lsl #1
3000c4ae:	59f0      	ldr	r0, [r6, r7]
3000c4b0:	f001 f980 	bl	3000d7b4 <dw_usb_ll_ep_open>
    ep->is_enabled = true;
3000c4b4:	2301      	movs	r3, #1
    return NO_ERROR;
3000c4b6:	4628      	mov	r0, r5
    ep->is_enabled = true;
3000c4b8:	f884 3020 	strb.w	r3, [r4, #32]
}
3000c4bc:	b009      	add	sp, #36	; 0x24
3000c4be:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    else if (restore) {
3000c4c2:	f1b9 0f00 	cmp.w	r9, #0
3000c4c6:	d012      	beq.n	3000c4ee <dw_usbc_setup_endpoint+0x166>
        RMWREG32(&param0, 30, 2, 1);
3000c4c8:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
3000c4cc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
3000c4d0:	9305      	str	r3, [sp, #20]
        RMWREG32(&param2, 30, 2, 1);
3000c4d2:	9b07      	ldr	r3, [sp, #28]
3000c4d4:	f023 4e40 	bic.w	r14, r3, #3221225472	; 0xc0000000
3000c4d8:	f04e 4e80 	orr.w	r14, r14, #1073741824	; 0x40000000
3000c4dc:	f8cd e01c 	str.w	r14, [r13, #28]
3000c4e0:	e7a3      	b.n	3000c42a <dw_usbc_setup_endpoint+0xa2>
        ep = &uc->OUT_ep[ept];
3000c4e2:	f501 71a6 	add.w	r1, r1, #332	; 0x14c
3000c4e6:	f2c3 0602 	movt	r6, #12290	; 0x3002
3000c4ea:	1874      	adds	r4, r6, r1
3000c4ec:	e765      	b.n	3000c3ba <dw_usbc_setup_endpoint+0x32>
        RMWREG32(&param0, 30, 2, 0);
3000c4ee:	46ce      	mov	r14, r9
3000c4f0:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
3000c4f4:	9305      	str	r3, [sp, #20]
3000c4f6:	e798      	b.n	3000c42a <dw_usbc_setup_endpoint+0xa2>
        ep->trbd = create_trb(instance, ep, 1);
3000c4f8:	f7ff ff28 	bl	3000c34c <create_trb.isra.7.constprop.21>
3000c4fc:	6060      	str	r0, [r4, #4]
        if (!ep->trbd) {
3000c4fe:	2800      	cmp	r0, #0
3000c500:	d1c9      	bne.n	3000c496 <dw_usbc_setup_endpoint+0x10e>
            dprintf(CRITICAL, "malloc ep%d trbd fail\n", ep->num);
3000c502:	f24e 7060 	movw	r0, #59232	; 0xe760
3000c506:	7821      	ldrb	r1, [r4, #0]
3000c508:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000c50c:	f009 fb50 	bl	30015bb0 <_printf>
            return ERR_NO_MEMORY;
3000c510:	f06f 0004 	mvn.w	r0, #4
3000c514:	e7d2      	b.n	3000c4bc <dw_usbc_setup_endpoint+0x134>
    dw_usb_ll_set_ep_new_config(uc->io_base, p_num);
3000c516:	f44f 734e 	mov.w	r3, #824	; 0x338
3000c51a:	4411      	add	r1, r2
3000c51c:	eb06 050a 	add.w	r5, r6, r10
3000c520:	fb03 f307 	mul.w	r3, r3, r7
    dw_usb_ll_set_ep_xfer_config(uc->io_base, p_num, param0);
3000c524:	eb06 0b03 	add.w	r11, r6, r3
    dw_usb_ll_set_ep_new_config(uc->io_base, p_num);
3000c528:	58f0      	ldr	r0, [r6, r3]
3000c52a:	f001 f909 	bl	3000d740 <dw_usb_ll_set_ep_new_config>
3000c52e:	4b13      	ldr	r3, [pc, #76]	; (3000c57c <dw_usbc_setup_endpoint+0x1f4>)
3000c530:	4453      	add	r3, r10
3000c532:	9303      	str	r3, [sp, #12]
    return epnum * 2 + is_in;
3000c534:	f04f 0a02 	mov.w	r10, #2
3000c538:	f895 014c 	ldrb.w	r0, [r5, #332]	; 0x14c
3000c53c:	f895 114d 	ldrb.w	r1, [r5, #333]	; 0x14d
    dw_usb_ll_set_ep_xfer_config(uc->io_base, p_num, param0);
3000c540:	2201      	movs	r2, #1
3000c542:	fb0a 1100 	mla	r1, r10, r0, r1
3000c546:	f8db 0000 	ldr.w	r0, [r11]
3000c54a:	3528      	adds	r5, #40	; 0x28
3000c54c:	f001 f828 	bl	3000d5a0 <dw_usb_ll_set_ep_xfer_config>
    return epnum * 2 + is_in;
3000c550:	f815 0c1c 	ldrb.w	r0, [r5, #-28]
3000c554:	f815 1c1b 	ldrb.w	r1, [r5, #-27]
    dw_usb_ll_set_ep_xfer_config(uc->io_base, p_num, param0);
3000c558:	2201      	movs	r2, #1
3000c55a:	fb0a 1100 	mla	r1, r10, r0, r1
3000c55e:	f8db 0000 	ldr.w	r0, [r11]
3000c562:	f001 f81d 	bl	3000d5a0 <dw_usb_ll_set_ep_xfer_config>
        for (i = 0; i < NUM_EP; i++) {
3000c566:	9b03      	ldr	r3, [sp, #12]
3000c568:	42ab      	cmp	r3, r5
3000c56a:	d1e3      	bne.n	3000c534 <dw_usbc_setup_endpoint+0x1ac>
3000c56c:	f894 c000 	ldrb.w	r12, [r4]
3000c570:	68e3      	ldr	r3, [r4, #12]
3000c572:	ea4f 014c 	mov.w	r1, r12, lsl #1
3000c576:	7865      	ldrb	r5, [r4, #1]
3000c578:	78e0      	ldrb	r0, [r4, #3]
3000c57a:	e736      	b.n	3000c3ea <dw_usbc_setup_endpoint+0x62>
3000c57c:	300297c0 	.word	0x300297c0

3000c580 <dw_usbc_ep0_send>:
{
3000c580:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ep->ack_ep0_in = true;
3000c582:	f44f 754e 	mov.w	r5, #824	; 0x338
3000c586:	f249 6680 	movw	r6, #38528	; 0x9680
3000c58a:	2701      	movs	r7, #1
3000c58c:	f2c3 0602 	movt	r6, #12290	; 0x3002
3000c590:	fb05 f500 	mul.w	r5, r5, r0
    ept->xfer_count = 0;
3000c594:	f04f 0e00 	mov.w	r14, #0
    ep->ack_ep0_in = true;
3000c598:	1974      	adds	r4, r6, r5
    if (uc->three_stage_setup) {
3000c59a:	f894 c295 	ldrb.w	r12, [r4, #661]	; 0x295
    DW_USB_EP *ept = &uc->IN_ep[0];
3000c59e:	350c      	adds	r5, #12
    ep->ack_ep0_in = true;
3000c5a0:	f884 72b8 	strb.w	r7, [r4, #696]	; 0x2b8
    DW_USB_EP *ept = &uc->IN_ep[0];
3000c5a4:	4435      	add	r5, r6
    ept->xfer_count = 0;
3000c5a6:	f8c4 e028 	str.w	r14, [r4, #40]	; 0x28
    if (uc->three_stage_setup) {
3000c5aa:	f1bc 0f00 	cmp.w	r12, #0
3000c5ae:	d004      	beq.n	3000c5ba <dw_usbc_ep0_send+0x3a>
        if (direction != ept->is_in) {
3000c5b0:	f894 7294 	ldrb.w	r7, [r4, #660]	; 0x294
3000c5b4:	7b64      	ldrb	r4, [r4, #13]
3000c5b6:	42a7      	cmp	r7, r4
3000c5b8:	d114      	bne.n	3000c5e4 <dw_usbc_ep0_send+0x64>
    if (maxlen != 0) {
3000c5ba:	b97b      	cbnz	r3, 3000c5dc <dw_usbc_ep0_send+0x5c>
        size = len;
3000c5bc:	4613      	mov	r3, r2
3000c5be:	460a      	mov	r2, r1
    dw_usbc_ep_trans(instance, ept, (uint8_t *)buf, size);
3000c5c0:	4629      	mov	r1, r5
3000c5c2:	4604      	mov	r4, r0
3000c5c4:	f7ff fe0a 	bl	3000c1dc <dw_usbc_ep_trans>
    if (ept->num == 0) {
3000c5c8:	f44f 704e 	mov.w	r0, #824	; 0x338
3000c5cc:	fb00 6404 	mla	r4, r0, r4, r6
3000c5d0:	7b23      	ldrb	r3, [r4, #12]
3000c5d2:	b913      	cbnz	r3, 3000c5da <dw_usbc_ep0_send+0x5a>
        uc->ep0_next_event = DW_EP0_COMPLETE;
3000c5d4:	2301      	movs	r3, #1
3000c5d6:	f8c4 3298 	str.w	r3, [r4, #664]	; 0x298
}
3000c5da:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        size = MIN(len, maxlen);
3000c5dc:	4293      	cmp	r3, r2
3000c5de:	bf28      	it	cs
3000c5e0:	4613      	movcs	r3, r2
3000c5e2:	e7ec      	b.n	3000c5be <dw_usbc_ep0_send+0x3e>
            dprintf(CRITICAL, "direction error, expect %d, get %d\n", direction,
3000c5e4:	f24e 703c 	movw	r0, #59196	; 0xe73c
3000c5e8:	4622      	mov	r2, r4
3000c5ea:	4639      	mov	r1, r7
3000c5ec:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000c5f0:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            dprintf(CRITICAL, "direction error, expect %d, get %d\n", direction,
3000c5f4:	f009 badc 	b.w	30015bb0 <_printf>

3000c5f8 <dw_usbc_ep0_recv>:
{
3000c5f8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ep->ack_ep0_in = true;
3000c5fa:	f249 6580 	movw	r5, #38528	; 0x9680
3000c5fe:	f44f 744e 	mov.w	r4, #824	; 0x338
3000c602:	2701      	movs	r7, #1
3000c604:	f2c3 0502 	movt	r5, #12290	; 0x3002
    ept->xfer_count = 0;
3000c608:	2600      	movs	r6, #0
    ep->ack_ep0_in = true;
3000c60a:	fb04 5400 	mla	r4, r4, r0, r5
    if (uc->three_stage_setup) {
3000c60e:	f894 3295 	ldrb.w	r3, [r4, #661]	; 0x295
    ep->ack_ep0_in = true;
3000c612:	f884 72f8 	strb.w	r7, [r4, #760]	; 0x2f8
    ept->xfer_count = 0;
3000c616:	f8c4 6168 	str.w	r6, [r4, #360]	; 0x168
    if (uc->three_stage_setup) {
3000c61a:	b12b      	cbz	r3, 3000c628 <dw_usbc_ep0_recv+0x30>
        if (direction != ept->is_in) {
3000c61c:	f894 3294 	ldrb.w	r3, [r4, #660]	; 0x294
3000c620:	f894 414d 	ldrb.w	r4, [r4, #333]	; 0x14d
3000c624:	42a3      	cmp	r3, r4
3000c626:	d113      	bne.n	3000c650 <dw_usbc_ep0_recv+0x58>
3000c628:	4604      	mov	r4, r0
    DW_USB_EP *ept = &uc->OUT_ep[0];
3000c62a:	f44f 764e 	mov.w	r6, #824	; 0x338
3000c62e:	4613      	mov	r3, r2
3000c630:	460a      	mov	r2, r1
3000c632:	fb06 f404 	mul.w	r4, r6, r4
3000c636:	f504 71a6 	add.w	r1, r4, #332	; 0x14c
    dw_usbc_ep_trans(instance, ept, (void *)buf, len);
3000c63a:	4429      	add	r1, r5
3000c63c:	f7ff fdce 	bl	3000c1dc <dw_usbc_ep_trans>
    if (ept->num == 0) {
3000c640:	4425      	add	r5, r4
3000c642:	f895 314c 	ldrb.w	r3, [r5, #332]	; 0x14c
3000c646:	b913      	cbnz	r3, 3000c64e <dw_usbc_ep0_recv+0x56>
        uc->ep0_next_event = DW_EP0_COMPLETE;
3000c648:	2301      	movs	r3, #1
3000c64a:	f8c5 3298 	str.w	r3, [r5, #664]	; 0x298
}
3000c64e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            dprintf(CRITICAL, "direction error, expect %d, get %d\n", direction,
3000c650:	f24e 703c 	movw	r0, #59196	; 0xe73c
3000c654:	4622      	mov	r2, r4
3000c656:	4619      	mov	r1, r3
3000c658:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000c65c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            dprintf(CRITICAL, "direction error, expect %d, get %d\n", direction,
3000c660:	f009 baa6 	b.w	30015bb0 <_printf>

3000c664 <usbc_init>:
    dw_usb_ll_unmask_irq(uc->io_base);
    return;
}

void usbc_init(usb_t *usb)
{
3000c664:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint32_t i = 0;
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000c668:	f8d0 508c 	ldr.w	r5, [r0, #140]	; 0x8c
    int instance = usb->priv.instance_id;
    uc->io_base = (vaddr_t)usb->priv.usb_vaddr;
3000c66c:	f44f 724e 	mov.w	r2, #824	; 0x338
{
3000c670:	4606      	mov	r6, r0
    uc->io_base = (vaddr_t)usb->priv.usb_vaddr;
3000c672:	f249 6480 	movw	r4, #38528	; 0x9680
3000c676:	e9d0 032e 	ldrd	r0, r3, [r0, #184]	; 0xb8
3000c67a:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000c67e:	fb02 f205 	mul.w	r2, r2, r5
    uc->phy_base = (vaddr_t)usb->priv.usb_phy_vaddr;
3000c682:	f8d6 10b4 	ldr.w	r1, [r6, #180]	; 0xb4
    ASSERT(usb->priv.max_eps <= NUM_EP);
3000c686:	2b08      	cmp	r3, #8
    uc->io_base = (vaddr_t)usb->priv.usb_vaddr;
3000c688:	eb04 0802 	add.w	r8, r4, r2
3000c68c:	50a0      	str	r0, [r4, r2]
{
3000c68e:	b087      	sub	sp, #28
    uc->phy_base = (vaddr_t)usb->priv.usb_phy_vaddr;
3000c690:	f8c8 1004 	str.w	r1, [r8, #4]
    ASSERT(usb->priv.max_eps <= NUM_EP);
3000c694:	f200 80fe 	bhi.w	3000c894 <usbc_init+0x230>
    /* power on or rest*/
    dw_usb_dev_ll_por_srst(uc->io_base, uc->phy_base);
3000c698:	f000 fe2a 	bl	3000d2f0 <dw_usb_dev_ll_por_srst>

    /*prepare ep?*/
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c69c:	f8d6 70bc 	ldr.w	r7, [r6, #188]	; 0xbc
3000c6a0:	b3a7      	cbz	r7, 3000c70c <usbc_init+0xa8>
3000c6a2:	2100      	movs	r1, #0
3000c6a4:	4643      	mov	r3, r8
3000c6a6:	4642      	mov	r2, r8
        uc->IN_ep[i].is_in = 1;
        uc->IN_ep[i].num = i;
        uc->IN_ep[i].type = USB_CTRL;
3000c6a8:	4608      	mov	r0, r1
        uc->IN_ep[i].is_in = 1;
3000c6aa:	f04f 0801 	mov.w	r8, #1
        uc->IN_ep[i].maxpacket =  1024;
3000c6ae:	f44f 6e80 	mov.w	r14, #1024	; 0x400
        uc->IN_ep[i].bsz = 16;
3000c6b2:	f04f 0c10 	mov.w	r12, #16
        uc->IN_ep[i].num = i;
3000c6b6:	7311      	strb	r1, [r2, #12]
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6b8:	3101      	adds	r1, #1
        uc->IN_ep[i].is_in = 1;
3000c6ba:	f882 800d 	strb.w	r8, [r2, #13]
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6be:	42b9      	cmp	r1, r7
        uc->IN_ep[i].type = USB_CTRL;
3000c6c0:	73d0      	strb	r0, [r2, #15]
        uc->IN_ep[i].bsz = 16;
3000c6c2:	e9c2 ec06 	strd	r14, r12, [r2, #24]
        uc->IN_ep[i].xfer_buff = 0;
        uc->IN_ep[i].xfer_len = 0;
3000c6c6:	e9c2 0008 	strd	r0, r0, [r2, #32]
        uc->IN_ep[i].trbd = 0;
        uc->IN_ep[i].evtbd = 0;
3000c6ca:	e9c2 0004 	strd	r0, r0, [r2, #16]
3000c6ce:	f102 0228 	add.w	r2, r2, #40	; 0x28
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6d2:	d1f0      	bne.n	3000c6b6 <usbc_init+0x52>
    }

    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6d4:	2000      	movs	r0, #0
        uc->OUT_ep[i].is_in = 0;
        uc->OUT_ep[i].num = i;
        uc->OUT_ep[i].type = USB_CTRL;
        uc->OUT_ep[i].maxpacket = 1024;
3000c6d6:	f44f 6c80 	mov.w	r12, #1024	; 0x400
        uc->OUT_ep[i].is_in = 0;
3000c6da:	4602      	mov	r2, r0
        uc->OUT_ep[i].bsz = 16;
3000c6dc:	2710      	movs	r7, #16
        uc->OUT_ep[i].num = i;
3000c6de:	f883 014c 	strb.w	r0, [r3, #332]	; 0x14c
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6e2:	3001      	adds	r0, #1
        uc->OUT_ep[i].is_in = 0;
3000c6e4:	f883 214d 	strb.w	r2, [r3, #333]	; 0x14d
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c6e8:	4288      	cmp	r0, r1
        uc->OUT_ep[i].type = USB_CTRL;
3000c6ea:	f883 214f 	strb.w	r2, [r3, #335]	; 0x14f
3000c6ee:	f103 0328 	add.w	r3, r3, #40	; 0x28
        uc->OUT_ep[i].maxpacket = 1024;
3000c6f2:	f8c3 c130 	str.w	r12, [r3, #304]	; 0x130
        uc->OUT_ep[i].bsz = 16;
3000c6f6:	f8c3 7134 	str.w	r7, [r3, #308]	; 0x134
        uc->OUT_ep[i].xfer_buff = 0;
3000c6fa:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
        uc->OUT_ep[i].xfer_len = 0;
3000c6fe:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
        uc->OUT_ep[i].trbd = 0;
3000c702:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
        uc->OUT_ep[i].evtbd = 0;
3000c706:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
    for (i = 0; i < usb->priv.max_eps; i++) {
3000c70a:	d1e8      	bne.n	3000c6de <usbc_init+0x7a>
3000c70c:	f44f 784e 	mov.w	r8, #824	; 0x338
    return epnum * 2 + is_in;
3000c710:	f04f 0902 	mov.w	r9, #2
    ep->is_enabled = false;
3000c714:	f04f 0a00 	mov.w	r10, #0
3000c718:	fb08 f805 	mul.w	r8, r8, r5
    }

    dw_usbc_ep_close(instance, &uc->OUT_ep[0]);
3000c71c:	f508 77a6 	add.w	r7, r8, #332	; 0x14c
    return epnum * 2 + is_in;
3000c720:	5de1      	ldrb	r1, [r4, r7]
    dw_usb_ll_ep_close(uc->io_base, p_num);
3000c722:	eb04 0208 	add.w	r2, r4, r8
3000c726:	f854 0008 	ldr.w	r0, [r4, r8]
    dw_usbc_ep_close(instance, &uc->OUT_ep[0]);
3000c72a:	eb04 0b07 	add.w	r11, r4, r7
    return epnum * 2 + is_in;
3000c72e:	f89b 3001 	ldrb.w	r3, [r11, #1]
    dw_usb_ll_ep_close(uc->io_base, p_num);
3000c732:	fb09 3101 	mla	r1, r9, r1, r3
3000c736:	9205      	str	r2, [sp, #20]
3000c738:	f001 f84a 	bl	3000d7d0 <dw_usb_ll_ep_close>
    ep->is_enabled = false;
3000c73c:	f88b a020 	strb.w	r10, [r11, #32]
    dw_usbc_ep_close(instance, &uc->IN_ep[0]);
3000c740:	f108 010c 	add.w	r1, r8, #12
3000c744:	1863      	adds	r3, r4, r1
    return epnum * 2 + is_in;
3000c746:	5c60      	ldrb	r0, [r4, r1]
3000c748:	7859      	ldrb	r1, [r3, #1]
    dw_usb_ll_ep_close(uc->io_base, p_num);
3000c74a:	fb09 1100 	mla	r1, r9, r0, r1
3000c74e:	f854 0008 	ldr.w	r0, [r4, r8]
    return epnum * 2 + is_in;
3000c752:	9304      	str	r3, [sp, #16]
    dw_usb_ll_ep_close(uc->io_base, p_num);
3000c754:	f001 f83c 	bl	3000d7d0 <dw_usb_ll_ep_close>
    uc->Setup = &setup_buff[instance][0];
3000c758:	f649 5100 	movw	r1, #40192	; 0x9d00
    return malloc(size);
3000c75c:	2010      	movs	r0, #16
    ep->is_enabled = false;
3000c75e:	9b04      	ldr	r3, [sp, #16]
    uc->Setup = &setup_buff[instance][0];
3000c760:	f2c3 0102 	movt	r1, #12290	; 0x3002
3000c764:	9a05      	ldr	r2, [sp, #20]
3000c766:	eb01 2185 	add.w	r1, r1, r5, lsl #10
    ep->is_enabled = false;
3000c76a:	f883 a020 	strb.w	r10, [r3, #32]
    uc->Setup = &setup_buff[instance][0];
3000c76e:	f8c2 12a8 	str.w	r1, [r2, #680]	; 0x2a8
    return epnum * 2 + is_in;
3000c772:	5de2      	ldrb	r2, [r4, r7]
3000c774:	f89b 3001 	ldrb.w	r3, [r11, #1]
3000c778:	fb19 3902 	smlabb	r9, r9, r2, r3
    return malloc(size);
3000c77c:	f007 ffb4 	bl	300146e8 <malloc>
    if (!evtbd) {
3000c780:	4607      	mov	r7, r0
3000c782:	2800      	cmp	r0, #0
3000c784:	d06a      	beq.n	3000c85c <usbc_init+0x1f8>
    evtbd->evtb = (void *)&event_buff[instance][0];
3000c786:	f247 6380 	movw	r3, #30336	; 0x7680
    evtbd->size = EVT_BUFF_SIZE;
3000c78a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    memset(evtbd->evtb, 0, evtbd->size);
3000c78e:	460a      	mov	r2, r1
    evtbd->evtb = (void *)&event_buff[instance][0];
3000c790:	f2c3 0302 	movt	r3, #12290	; 0x3002
    evtbd->lpos = 0;
3000c794:	f8c0 a008 	str.w	r10, [r0, #8]
    evtbd->evtb = (void *)&event_buff[instance][0];
3000c798:	eb03 3305 	add.w	r3, r3, r5, lsl #12
    evtbd->size = EVT_BUFF_SIZE;
3000c79c:	81b9      	strh	r1, [r7, #12]
    memset(evtbd->evtb, 0, evtbd->size);
3000c79e:	4618      	mov	r0, r3
    evtbd->evtb = (void *)&event_buff[instance][0];
3000c7a0:	603b      	str	r3, [r7, #0]
    memset(evtbd->evtb, 0, evtbd->size);
3000c7a2:	4651      	mov	r1, r10
3000c7a4:	f008 e8e4 	blx	30014970 <memset>
    evtbd->paddr = p2ap(v2p(evtbd->evtb));
3000c7a8:	f003 fa44 	bl	3000fc34 <p2ap>
    arch_clean_cache_range((addr_t)evtbd->evtb, evtbd->size);
3000c7ac:	89b9      	ldrh	r1, [r7, #12]
    ep->evtbd = create_evtb(instance, ep);
3000c7ae:	f8cb 7008 	str.w	r7, [r11, #8]
    evtbd->paddr = p2ap(v2p(evtbd->evtb));
3000c7b2:	6078      	str	r0, [r7, #4]
    arch_clean_cache_range((addr_t)evtbd->evtb, evtbd->size);
3000c7b4:	6838      	ldr	r0, [r7, #0]
3000c7b6:	f7f5 e9aa 	blx	30001b0c <arch_clean_cache_range>
    dw_usb_ll_set_ep_event_buffer(uc->io_base, p_num, adr_l, adr_h, size);
3000c7ba:	687a      	ldr	r2, [r7, #4]
3000c7bc:	f854 0008 	ldr.w	r0, [r4, r8]
3000c7c0:	89bf      	ldrh	r7, [r7, #12]
3000c7c2:	4653      	mov	r3, r10
3000c7c4:	4649      	mov	r1, r9
3000c7c6:	9700      	str	r7, [sp, #0]
3000c7c8:	f000 ffc8 	bl	3000d75c <dw_usb_ll_set_ep_event_buffer>
    dw_usbc_set_ep_event_buffer(instance, &uc->OUT_ep[0]);
    uc->ep0_trbd = create_trb(instance, &uc->OUT_ep[0], 1);
3000c7cc:	f7ff fdbe 	bl	3000c34c <create_trb.isra.7.constprop.21>
3000c7d0:	f44f 794e 	mov.w	r9, #824	; 0x338
3000c7d4:	fb09 fa05 	mul.w	r10, r9, r5
3000c7d8:	eb04 080a 	add.w	r8, r4, r10
3000c7dc:	f8c8 029c 	str.w	r0, [r8, #668]	; 0x29c

    if (!uc->ep0_trbd) {
3000c7e0:	2800      	cmp	r0, #0
3000c7e2:	d04e      	beq.n	3000c882 <usbc_init+0x21e>

    //config ep0
    uc->IN_ep[0].maxpacket = usb->priv.ep0_mps;
    uc->OUT_ep[0].maxpacket = usb->priv.ep0_mps;
    //dw_usbc_resetcb(instance);
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, uc->OUT_ep[0].maxpacket,
3000c7e4:	2700      	movs	r7, #0
3000c7e6:	2201      	movs	r2, #1
    uc->IN_ep[0].maxpacket = usb->priv.ep0_mps;
3000c7e8:	f8d6 c0c0 	ldr.w	r12, [r6, #192]	; 0xc0
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, uc->OUT_ep[0].maxpacket,
3000c7ec:	4639      	mov	r1, r7
3000c7ee:	9702      	str	r7, [sp, #8]
3000c7f0:	4663      	mov	r3, r12
3000c7f2:	9701      	str	r7, [sp, #4]
3000c7f4:	4628      	mov	r0, r5
3000c7f6:	9700      	str	r7, [sp, #0]
    uc->IN_ep[0].maxpacket = usb->priv.ep0_mps;
3000c7f8:	f8c8 c018 	str.w	r12, [r8, #24]
    uc->OUT_ep[0].maxpacket = usb->priv.ep0_mps;
3000c7fc:	f8c8 c158 	str.w	r12, [r8, #344]	; 0x158
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, uc->OUT_ep[0].maxpacket,
3000c800:	f7ff fdc2 	bl	3000c388 <dw_usbc_setup_endpoint>
                           USB_CTRL, false, false);
    dw_usbc_setup_endpoint(instance, 0, USB_IN, uc->IN_ep[0].maxpacket,
3000c804:	f8d8 3018 	ldr.w	r3, [r8, #24]
3000c808:	463a      	mov	r2, r7
3000c80a:	4639      	mov	r1, r7
3000c80c:	9702      	str	r7, [sp, #8]
3000c80e:	4628      	mov	r0, r5
3000c810:	e9cd 7700 	strd	r7, r7, [r13]
3000c814:	f7ff fdb8 	bl	3000c388 <dw_usbc_setup_endpoint>
                           USB_CTRL, false, false);
    /* setup EP0 to receive SETUP packets */
    uc->ep0stage = EP0_SETUP_PHASE;
3000c818:	f04f 0c01 	mov.w	r12, #1
    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000c81c:	463b      	mov	r3, r7
3000c81e:	2208      	movs	r2, #8
3000c820:	f8d8 12a8 	ldr.w	r1, [r8, #680]	; 0x2a8
3000c824:	4628      	mov	r0, r5
    uc->ep0stage = EP0_SETUP_PHASE;
3000c826:	f8c8 c290 	str.w	r12, [r8, #656]	; 0x290
    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000c82a:	f7ff fee5 	bl	3000c5f8 <dw_usbc_ep0_recv>
    dw_usb_ll_enable_irq(uc->io_base);
3000c82e:	f854 000a 	ldr.w	r0, [r4, r10]
3000c832:	f000 fddb 	bl	3000d3ec <dw_usb_ll_enable_irq>
}

void usbc_set_address(usb_t *usb, uint8_t address)
{
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
    dw_usb_ll_set_address(uc->io_base, address);
3000c836:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
3000c83a:	4639      	mov	r1, r7
3000c83c:	fb09 f303 	mul.w	r3, r9, r3
3000c840:	58e0      	ldr	r0, [r4, r3]
3000c842:	f000 ffd3 	bl	3000d7ec <dw_usb_ll_set_address>
    dump_registers(uc->io_base, "init");
3000c846:	f854 000a 	ldr.w	r0, [r4, r10]
3000c84a:	f64e 0118 	movw	r1, #59416	; 0xe818
3000c84e:	f2c3 0101 	movt	r1, #12289	; 0x3001
}
3000c852:	b007      	add	sp, #28
3000c854:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    dump_registers(uc->io_base, "init");
3000c858:	f000 bd48 	b.w	3000d2ec <dump_registers>
        printf("no free memory %s\n", __func__);
3000c85c:	f24e 7130 	movw	r1, #59184	; 0xe730
3000c860:	f24e 70d8 	movw	r0, #59352	; 0xe7d8
3000c864:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000c868:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000c86c:	f009 f9a0 	bl	30015bb0 <_printf>
    ep->evtbd = create_evtb(instance, ep);
3000c870:	f8cb 7008 	str.w	r7, [r11, #8]
        dprintf(CRITICAL, "create evtb fail\n");
3000c874:	f24e 70ec 	movw	r0, #59372	; 0xe7ec
3000c878:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000c87c:	f009 f998 	bl	30015bb0 <_printf>
3000c880:	e7a4      	b.n	3000c7cc <usbc_init+0x168>
        dprintf(CRITICAL, "malloc ep0_trbd fail\n");
3000c882:	f64e 0000 	movw	r0, #59392	; 0xe800
3000c886:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000c88a:	b007      	add	sp, #28
3000c88c:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
        dprintf(CRITICAL, "malloc ep0_trbd fail\n");
3000c890:	f009 b98e 	b.w	30015bb0 <_printf>
    ASSERT(usb->priv.max_eps <= NUM_EP);
3000c894:	f24e 73bc 	movw	r3, #59324	; 0xe7bc
3000c898:	f24e 7290 	movw	r2, #59280	; 0xe790
3000c89c:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000c8a0:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000c8a4:	4670      	mov	r0, r14
3000c8a6:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000c8aa:	9300      	str	r3, [sp, #0]
3000c8ac:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000c8b0:	f240 43d6 	movw	r3, #1238	; 0x4d6
3000c8b4:	f007 fcae 	bl	30014214 <_panic>

3000c8b8 <usbc_queue_rx>:
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000c8b8:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8bc:	f001 017f 	and.w	r1, r1, #127	; 0x7f
{
3000c8c0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ept->xfer_count = 0;
3000c8c2:	f44f 764e 	mov.w	r6, #824	; 0x338
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8c6:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    ept->xfer_count = 0;
3000c8ca:	eb01 0581 	add.w	r5, r1, r1, lsl #2
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8ce:	eb03 1403 	add.w	r4, r3, r3, lsl #4
    ept->xfer_count = 0;
3000c8d2:	fb06 f600 	mul.w	r6, r6, r0
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8d6:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    ept->xfer_count = 0;
3000c8da:	00ed      	lsls	r5, r5, #3
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8dc:	440c      	add	r4, r1
3000c8de:	f249 6180 	movw	r1, #38528	; 0x9680
    ept->xfer_count = 0;
3000c8e2:	19af      	adds	r7, r5, r6
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8e4:	f2c3 0102 	movt	r1, #12290	; 0x3002
    DW_USB_EP *ept = &uc->OUT_ep[ep & 0x7f];
3000c8e8:	f505 75a6 	add.w	r5, r5, #332	; 0x14c
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8ec:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
    ept->xfer_count = 0;
3000c8f0:	440f      	add	r7, r1
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c8f2:	68d3      	ldr	r3, [r2, #12]
    DW_USB_EP *ept = &uc->OUT_ep[ep & 0x7f];
3000c8f4:	4435      	add	r5, r6
    ept->xfer_count = 0;
3000c8f6:	2600      	movs	r6, #0
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c8f8:	4429      	add	r1, r5
    uc->ep_out[ep & 0x7f].transfer = transfer;
3000c8fa:	f8c4 22fc 	str.w	r2, [r4, #764]	; 0x2fc
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c8fe:	6892      	ldr	r2, [r2, #8]
    ept->xfer_count = 0;
3000c900:	f8c7 6168 	str.w	r6, [r7, #360]	; 0x168
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c904:	f7ff fc6a 	bl	3000c1dc <dw_usbc_ep_trans>
}
3000c908:	4630      	mov	r0, r6
3000c90a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

3000c90c <usbc_queue_tx>:
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000c90c:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c910:	f001 017f 	and.w	r1, r1, #127	; 0x7f
{
3000c914:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ept->xfer_count = 0;
3000c916:	f44f 764e 	mov.w	r6, #824	; 0x338
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c91a:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    ept->xfer_count = 0;
3000c91e:	eb01 0581 	add.w	r5, r1, r1, lsl #2
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c922:	eb03 1403 	add.w	r4, r3, r3, lsl #4
    ept->xfer_count = 0;
3000c926:	fb06 f600 	mul.w	r6, r6, r0
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c92a:	eb00 0444 	add.w	r4, r0, r4, lsl #1
    ept->xfer_count = 0;
3000c92e:	00ed      	lsls	r5, r5, #3
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c930:	440c      	add	r4, r1
3000c932:	f249 6180 	movw	r1, #38528	; 0x9680
    ept->xfer_count = 0;
3000c936:	19af      	adds	r7, r5, r6
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c938:	f2c3 0102 	movt	r1, #12290	; 0x3002
    DW_USB_EP *ept = &uc->IN_ep[ep & 0x7f];
3000c93c:	350c      	adds	r5, #12
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c93e:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
    ept->xfer_count = 0;
3000c942:	440f      	add	r7, r1
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c944:	68d3      	ldr	r3, [r2, #12]
    DW_USB_EP *ept = &uc->IN_ep[ep & 0x7f];
3000c946:	4435      	add	r5, r6
    ept->xfer_count = 0;
3000c948:	2600      	movs	r6, #0
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c94a:	4429      	add	r1, r5
    uc->ep_in[ep & 0x7f].transfer = transfer;
3000c94c:	f8c4 22bc 	str.w	r2, [r4, #700]	; 0x2bc
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c950:	6892      	ldr	r2, [r2, #8]
    ept->xfer_count = 0;
3000c952:	62be      	str	r6, [r7, #40]	; 0x28
    dw_usbc_ep_trans(usb->priv.instance_id, ept, transfer->buf,
3000c954:	f7ff fc42 	bl	3000c1dc <dw_usbc_ep_trans>
}
3000c958:	4630      	mov	r0, r6
3000c95a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

3000c95c <usbc_set_active>:
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000c95c:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
{
3000c960:	b570      	push	{r4, r5, r6, r14}
    dw_usb_ll_runstop(uc->io_base, active);
3000c962:	f44f 744e 	mov.w	r4, #824	; 0x338
3000c966:	f249 6580 	movw	r5, #38528	; 0x9680
3000c96a:	f2c3 0502 	movt	r5, #12290	; 0x3002
3000c96e:	fb04 f403 	mul.w	r4, r4, r3
3000c972:	192e      	adds	r6, r5, r4
3000c974:	5928      	ldr	r0, [r5, r4]
3000c976:	f000 fd61 	bl	3000d43c <dw_usb_ll_runstop>
    RMWREG32(uc->phy_base + 0x1001c, 0, 1, 1);
3000c97a:	6873      	ldr	r3, [r6, #4]
    dump_registers(uc->io_base, "run");
3000c97c:	f64e 311c 	movw	r1, #60188	; 0xeb1c
    RMWREG32(uc->phy_base + 0x1001c, 0, 1, 1);
3000c980:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
    dump_registers(uc->io_base, "run");
3000c984:	f2c3 0101 	movt	r1, #12289	; 0x3001
    RMWREG32(uc->phy_base + 0x1001c, 0, 1, 1);
3000c988:	69da      	ldr	r2, [r3, #28]
3000c98a:	f042 0201 	orr.w	r2, r2, #1
3000c98e:	61da      	str	r2, [r3, #28]
    dump_registers(uc->io_base, "run");
3000c990:	5928      	ldr	r0, [r5, r4]
3000c992:	f000 fcab 	bl	3000d2ec <dump_registers>
}
3000c996:	2000      	movs	r0, #0
3000c998:	bd70      	pop	{r4, r5, r6, r15}
3000c99a:	bf00      	nop

3000c99c <usbc_set_address>:
    dw_usb_ll_set_address(uc->io_base, address);
3000c99c:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
3000c9a0:	f44f 734e 	mov.w	r3, #824	; 0x338
3000c9a4:	f249 6280 	movw	r2, #38528	; 0x9680
3000c9a8:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000c9ac:	fb03 f300 	mul.w	r3, r3, r0
3000c9b0:	58d0      	ldr	r0, [r2, r3]
3000c9b2:	f000 bf1b 	b.w	3000d7ec <dw_usb_ll_set_address>
3000c9b6:	bf00      	nop

3000c9b8 <usbc_ep0_ack>:
    ep->ack_ep0_in = false;
    DW_USB_EP *ept = &uc->IN_ep[0];
    ept->xfer_count = 0;
    dw_usbc_ep_trans(instance, ept, 0, 0);
#endif
}
3000c9b8:	4770      	bx	r14
3000c9ba:	bf00      	nop

3000c9bc <usbc_ep0_stall>:

void usbc_ep0_stall(usb_t *usb)
{
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000c9bc:	f8d0 208c 	ldr.w	r2, [r0, #140]	; 0x8c
    dw_usbc_set_ep_stall(usb->priv.instance_id, &uc->OUT_ep[0]);
3000c9c0:	f44f 704e 	mov.w	r0, #824	; 0x338
3000c9c4:	f249 6380 	movw	r3, #38528	; 0x9680
3000c9c8:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000c9cc:	fb00 f002 	mul.w	r0, r0, r2
{
3000c9d0:	b430      	push	{r4, r5}
    ep->is_stall = 1;
3000c9d2:	2401      	movs	r4, #1
    dw_usbc_set_ep_stall(usb->priv.instance_id, &uc->OUT_ep[0]);
3000c9d4:	f500 72a6 	add.w	r2, r0, #332	; 0x14c
    return epnum * 2 + is_in;
3000c9d8:	5c9d      	ldrb	r5, [r3, r2]
    dw_usbc_set_ep_stall(usb->priv.instance_id, &uc->OUT_ep[0]);
3000c9da:	441a      	add	r2, r3
    return epnum * 2 + is_in;
3000c9dc:	7851      	ldrb	r1, [r2, #1]
    dw_usb_ll_set_ep_stall(uc->io_base, p_num);
3000c9de:	eb01 0145 	add.w	r1, r1, r5, lsl #1
    ep->is_stall = 1;
3000c9e2:	7094      	strb	r4, [r2, #2]
    dw_usb_ll_set_ep_stall(uc->io_base, p_num);
3000c9e4:	5818      	ldr	r0, [r3, r0]
}
3000c9e6:	bc30      	pop	{r4, r5}
    dw_usb_ll_set_ep_stall(uc->io_base, p_num);
3000c9e8:	f000 be62 	b.w	3000d6b0 <dw_usb_ll_set_ep_stall>

3000c9ec <usbc_irq>:
{
3000c9ec:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    int instance = usb->priv.instance_id;
3000c9f0:	f8d0 b08c 	ldr.w	r11, [r0, #140]	; 0x8c
        uc->do_resched = false;
3000c9f4:	f249 6a80 	movw	r10, #38528	; 0x9680
3000c9f8:	f44f 734e 	mov.w	r3, #824	; 0x338
3000c9fc:	f2c3 0a02 	movt	r10, #12290	; 0x3002
3000ca00:	2200      	movs	r2, #0
{
3000ca02:	b091      	sub	sp, #68	; 0x44
        uc->do_resched = false;
3000ca04:	fb03 a30b 	mla	r3, r3, r11, r10
{
3000ca08:	9005      	str	r0, [sp, #20]
        uc->do_resched = false;
3000ca0a:	f883 22b4 	strb.w	r2, [r3, #692]	; 0x2b4
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000ca0e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000ca12:	061e      	lsls	r6, r3, #24
3000ca14:	bf44      	itt	mi
3000ca16:	465c      	movmi	r4, r11
    spin_lock_saved_state_t state = 0;
3000ca18:	9206      	strmi	r2, [sp, #24]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000ca1a:	d404      	bmi.n	3000ca26 <usbc_irq+0x3a>
    __asm__ volatile("cpsid i");
3000ca1c:	b672      	cpsid	i
    CF;
3000ca1e:	f8d0 408c 	ldr.w	r4, [r0, #140]	; 0x8c
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
3000ca22:	2301      	movs	r3, #1
3000ca24:	9306      	str	r3, [sp, #24]
    *lock = 1;
3000ca26:	f44f 734e 	mov.w	r3, #824	; 0x338
3000ca2a:	2001      	movs	r0, #1
    evtbd_t *evtbd = ep->evtbd;
3000ca2c:	fb03 f504 	mul.w	r5, r3, r4
3000ca30:	fb03 a30b 	mla	r3, r3, r11, r10
3000ca34:	eb0a 0205 	add.w	r2, r10, r5
    return epnum * 2 + is_in;
3000ca38:	f892 614c 	ldrb.w	r6, [r2, #332]	; 0x14c
3000ca3c:	f892 114d 	ldrb.w	r1, [r2, #333]	; 0x14d
    return dw_usb_ll_get_ep_event_count(uc->io_base, p_num);
3000ca40:	eb01 0146 	add.w	r1, r1, r6, lsl #1
3000ca44:	f8c3 028c 	str.w	r0, [r3, #652]	; 0x28c
3000ca48:	f85a 0005 	ldr.w	r0, [r10, r5]
    evtbd_t *evtbd = ep->evtbd;
3000ca4c:	f8d2 8154 	ldr.w	r8, [r2, #340]	; 0x154
    return dw_usb_ll_get_ep_event_count(uc->io_base, p_num);
3000ca50:	f000 fe9e 	bl	3000d790 <dw_usb_ll_get_ep_event_count>
    if (eventcount == 0) {
3000ca54:	4607      	mov	r7, r0
3000ca56:	b9d8      	cbnz	r0, 3000ca90 <usbc_irq+0xa4>
    uint32_t evt = dw_usb_ll_get_ncr_evt(uc->io_base);
3000ca58:	f44f 744e 	mov.w	r4, #824	; 0x338
3000ca5c:	fb04 f40b 	mul.w	r4, r4, r11
3000ca60:	f85a 0004 	ldr.w	r0, [r10, r4]
3000ca64:	f000 fed8 	bl	3000d818 <dw_usb_ll_get_ncr_evt>
    if (evt & 0x7Fu) {
3000ca68:	0643      	lsls	r3, r0, #25
3000ca6a:	d003      	beq.n	3000ca74 <usbc_irq+0x88>
        dw_usb_ll_clr_ncr_evt(uc->io_base);
3000ca6c:	f85a 0004 	ldr.w	r0, [r10, r4]
3000ca70:	f000 fed6 	bl	3000d820 <dw_usb_ll_clr_ncr_evt>
    *lock = 0;
3000ca74:	f44f 734e 	mov.w	r3, #824	; 0x338
3000ca78:	2200      	movs	r2, #0
3000ca7a:	fb03 a30b 	mla	r3, r3, r11, r10
3000ca7e:	f8c3 228c 	str.w	r2, [r3, #652]	; 0x28c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
3000ca82:	9b06      	ldr	r3, [sp, #24]
3000ca84:	b103      	cbz	r3, 3000ca88 <usbc_irq+0x9c>
    __asm__ volatile("cpsie i");
3000ca86:	b662      	cpsie	i
}
3000ca88:	2001      	movs	r0, #1
3000ca8a:	b011      	add	sp, #68	; 0x44
3000ca8c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    dw_usb_ll_mask_irq(uc->io_base);
3000ca90:	f85a 0005 	ldr.w	r0, [r10, r5]
3000ca94:	f000 fcc2 	bl	3000d41c <dw_usb_ll_mask_irq>
    addr_t start = ROUNDDOWN((addr_t)evtbd->evtb + evtbd->lpos, CACHE_LINE);
3000ca98:	f8d8 3008 	ldr.w	r3, [r8, #8]
3000ca9c:	f8d8 1000 	ldr.w	r1, [r8]
3000caa0:	18ca      	adds	r2, r1, r3
    if ((evtbd->lpos + eventcount) > EVT_BUFF_SIZE) {
3000caa2:	443b      	add	r3, r7
3000caa4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    addr_t start = ROUNDDOWN((addr_t)evtbd->evtb + evtbd->lpos, CACHE_LINE);
3000caa8:	f022 001f 	bic.w	r0, r2, #31
    if ((evtbd->lpos + eventcount) > EVT_BUFF_SIZE) {
3000caac:	dc7a      	bgt.n	3000cba4 <usbc_irq+0x1b8>
        len = ROUNDUP(end - start, CACHE_LINE);
3000caae:	f107 011f 	add.w	r1, r7, #31
3000cab2:	4411      	add	r1, r2
3000cab4:	1a09      	subs	r1, r1, r0
        arch_invalidate_cache_range(start, len);
3000cab6:	f021 011f 	bic.w	r1, r1, #31
3000caba:	f7f5 e82c 	blx	30001b14 <arch_invalidate_cache_range>
            printf("get unknown event %d on ep:%d, in:%d \n", evt.evtnum, ep->num,
3000cabe:	f8cd b024 	str.w	r11, [r13, #36]	; 0x24
3000cac2:	f44f 734e 	mov.w	r3, #824	; 0x338
3000cac6:	f8cd a010 	str.w	r10, [r13, #16]
3000caca:	fb03 f204 	mul.w	r2, r3, r4
    DW_USB_EP *ep = &uc->OUT_ep[0];
3000cace:	f502 73a6 	add.w	r3, r2, #332	; 0x14c
3000cad2:	9207      	str	r2, [sp, #28]
3000cad4:	4453      	add	r3, r10
            printf("get unknown event %d on ep:%d, in:%d \n", evt.evtnum, ep->num,
3000cad6:	eb0a 0902 	add.w	r9, r10, r2
    DW_USB_EP *ep = &uc->OUT_ep[0];
3000cada:	9308      	str	r3, [sp, #32]
3000cadc:	e037      	b.n	3000cb4e <usbc_irq+0x162>
3000cade:	9807      	ldr	r0, [sp, #28]
            DW_USB_EP *ept = ((evt->depevt.phy_epnum % 2) == 0 ?
3000cae0:	f3c1 0144 	ubfx	r1, r1, #1, #5
    switch (evt.evt) {
3000cae4:	881d      	ldrh	r5, [r3, #0]
3000cae6:	f3c5 1583 	ubfx	r5, r5, #6, #4
3000caea:	104c      	asrs	r4, r1, #1
                              & (uc->OUT_ep[evt->depevt.phy_epnum / 2]) :
3000caec:	07c9      	lsls	r1, r1, #31
3000caee:	9904      	ldr	r1, [sp, #16]
3000caf0:	eb04 0484 	add.w	r4, r4, r4, lsl #2
3000caf4:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
3000caf8:	bf54      	ite	pl
3000cafa:	f504 74a6 	addpl.w	r4, r4, #332	; 0x14c
3000cafe:	340c      	addmi	r4, #12
3000cb00:	440c      	add	r4, r1
3000cb02:	6819      	ldr	r1, [r3, #0]
    switch (evt.evt) {
3000cb04:	2d01      	cmp	r5, #1
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000cb06:	9b05      	ldr	r3, [sp, #20]
3000cb08:	f8d3 608c 	ldr.w	r6, [r3, #140]	; 0x8c
    switch (evt.evt) {
3000cb0c:	f000 816f 	beq.w	3000cdee <usbc_irq+0x402>
3000cb10:	2d03      	cmp	r5, #3
3000cb12:	d103      	bne.n	3000cb1c <usbc_irq+0x130>
            if (ep->num == 0) { //control ep
3000cb14:	7823      	ldrb	r3, [r4, #0]
3000cb16:	2b00      	cmp	r3, #0
3000cb18:	f000 81cf 	beq.w	3000ceba <usbc_irq+0x4ce>
        evtbd->lpos = (evtbd->lpos + 4) % EVT_BUFF_SIZE;
3000cb1c:	3204      	adds	r2, #4
    return epnum * 2 + is_in;
3000cb1e:	f899 014c 	ldrb.w	r0, [r9, #332]	; 0x14c
        evtbd->lpos = (evtbd->lpos + 4) % EVT_BUFF_SIZE;
3000cb22:	4253      	negs	r3, r2
    return epnum * 2 + is_in;
3000cb24:	f899 114d 	ldrb.w	r1, [r9, #333]	; 0x14d
        evtbd->lpos = (evtbd->lpos + 4) % EVT_BUFF_SIZE;
3000cb28:	f3c3 030b 	ubfx	r3, r3, #0, #12
3000cb2c:	f3c2 020b 	ubfx	r2, r2, #0, #12
3000cb30:	bf58      	it	pl
3000cb32:	425a      	negpl	r2, r3
        eventcount -= 4;
3000cb34:	3f04      	subs	r7, #4
        evtbd->lpos = (evtbd->lpos + 4) % EVT_BUFF_SIZE;
3000cb36:	f8c8 2008 	str.w	r2, [r8, #8]
    return  dw_usb_ll_clear_ep_event(uc->io_base,  p_num, size);
3000cb3a:	eb01 0140 	add.w	r1, r1, r0, lsl #1
3000cb3e:	f8d9 0000 	ldr.w	r0, [r9]
3000cb42:	2204      	movs	r2, #4
3000cb44:	f000 fe2e 	bl	3000d7a4 <dw_usb_ll_clear_ep_event>
    while (eventcount) {
3000cb48:	2f00      	cmp	r7, #0
3000cb4a:	f000 8147 	beq.w	3000cddc <usbc_irq+0x3f0>
        evt = (evt_t *)(evtbd->evtb + evtbd->lpos);
3000cb4e:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000cb52:	f8d8 3000 	ldr.w	r3, [r8]
        if (evt->devt.evttype == 0) { //ep special event
3000cb56:	5c99      	ldrb	r1, [r3, r2]
3000cb58:	07c8      	lsls	r0, r1, #31
        evt = (evt_t *)(evtbd->evtb + evtbd->lpos);
3000cb5a:	4413      	add	r3, r2
        if (evt->devt.evttype == 0) { //ep special event
3000cb5c:	d5bf      	bpl.n	3000cade <usbc_irq+0xf2>
        else if (evt->devt.devspec_evt == 0) {   //dev special event
3000cb5e:	f011 0ffe 	tst.w	r1, #254	; 0xfe
3000cb62:	d1db      	bne.n	3000cb1c <usbc_irq+0x130>
3000cb64:	785d      	ldrb	r5, [r3, #1]
3000cb66:	885b      	ldrh	r3, [r3, #2]
3000cb68:	f3c3 0608 	ubfx	r6, r3, #0, #9
    args.usb = usb;
3000cb6c:	9b05      	ldr	r3, [sp, #20]
3000cb6e:	f005 051f 	and.w	r5, r5, #31
3000cb72:	930f      	str	r3, [sp, #60]	; 0x3c
    int instance = usb->priv.instance_id;
3000cb74:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
    switch (evt.evtnum) {
3000cb78:	2d10      	cmp	r5, #16
3000cb7a:	f200 828f 	bhi.w	3000d09c <usbc_irq+0x6b0>
3000cb7e:	e8df f015 	tbh	[r15, r5, lsl #1]
3000cb82:	0117      	.short	0x0117
3000cb84:	003c007a 	.word	0x003c007a
3000cb88:	02470023 	.word	0x02470023
3000cb8c:	0233023d 	.word	0x0233023d
3000cb90:	026f0229 	.word	0x026f0229
3000cb94:	025b0265 	.word	0x025b0265
3000cb98:	02830251 	.word	0x02830251
3000cb9c:	0279028d 	.word	0x0279028d
3000cba0:	0214028d 	.word	0x0214028d
        end = (addr_t)(evtbd->evtb + EVT_BUFF_SIZE);
3000cba4:	f501 5180 	add.w	r1, r1, #4096	; 0x1000
        arch_invalidate_cache_range(start, len);
3000cba8:	1a09      	subs	r1, r1, r0
3000cbaa:	f7f4 efb4 	blx	30001b14 <arch_invalidate_cache_range>
        len = ROUNDUP(evtbd->lpos + eventcount - EVT_BUFF_SIZE, CACHE_LINE);
3000cbae:	f8d8 1008 	ldr.w	r1, [r8, #8]
        arch_invalidate_cache_range(start, len);
3000cbb2:	f8d8 0000 	ldr.w	r0, [r8]
        len = ROUNDUP(evtbd->lpos + eventcount - EVT_BUFF_SIZE, CACHE_LINE);
3000cbb6:	f46f 657e 	mvn.w	r5, #4064	; 0xfe0
3000cbba:	4439      	add	r1, r7
3000cbbc:	4429      	add	r1, r5
        arch_invalidate_cache_range(start, len);
3000cbbe:	f021 011f 	bic.w	r1, r1, #31
3000cbc2:	f7f4 efa8 	blx	30001b14 <arch_invalidate_cache_range>
3000cbc6:	e77a      	b.n	3000cabe <usbc_irq+0xd2>
            printf("linksts change\n");
3000cbc8:	f64e 2038 	movw	r0, #59960	; 0xea38
    enum dw_link_state next = evtinfo & DW_LINK_STATE_MASK;
3000cbcc:	f006 060f 	and.w	r6, r6, #15
            printf("linksts change\n");
3000cbd0:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cbd4:	f008 ffec 	bl	30015bb0 <_printf>
    uc->link_state = next;
3000cbd8:	9b04      	ldr	r3, [sp, #16]
3000cbda:	f44f 724e 	mov.w	r2, #824	; 0x338
    printf("U%d\n", next);
3000cbde:	f64e 2048 	movw	r0, #59976	; 0xea48
3000cbe2:	4631      	mov	r1, r6
3000cbe4:	f2c3 0001 	movt	r0, #12289	; 0x3001
    uc->link_state = next;
3000cbe8:	fb02 3404 	mla	r4, r2, r4, r3
3000cbec:	f8c4 62b0 	str.w	r6, [r4, #688]	; 0x2b0
    printf("U%d\n", next);
3000cbf0:	f008 ffde 	bl	30015bb0 <_printf>
3000cbf4:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000cbf8:	e790      	b.n	3000cb1c <usbc_irq+0x130>
    int speed = dw_usb_ll_get_cur_speed(uc->io_base);
3000cbfa:	f44f 734e 	mov.w	r3, #824	; 0x338
            printf("conndone\n");
3000cbfe:	f64e 2050 	movw	r0, #59984	; 0xea50
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc02:	2500      	movs	r5, #0
            printf("conndone\n");
3000cc04:	f2c3 0001 	movt	r0, #12289	; 0x3001
    int speed = dw_usb_ll_get_cur_speed(uc->io_base);
3000cc08:	fb03 fa04 	mul.w	r10, r3, r4
            printf("conndone\n");
3000cc0c:	f008 ffd0 	bl	30015bb0 <_printf>
    int speed = dw_usb_ll_get_cur_speed(uc->io_base);
3000cc10:	9b04      	ldr	r3, [sp, #16]
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc12:	2601      	movs	r6, #1
    int speed = dw_usb_ll_get_cur_speed(uc->io_base);
3000cc14:	eb03 0b0a 	add.w	r11, r3, r10
3000cc18:	f853 000a 	ldr.w	r0, [r3, r10]
3000cc1c:	f000 fdf6 	bl	3000d80c <dw_usb_ll_get_cur_speed>
    RMWREG32(uc->io_base + 0xc704, 24, 5, 0);
3000cc20:	9904      	ldr	r1, [sp, #16]
3000cc22:	f24c 7e04 	movw	r14, #50948	; 0xc704
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc26:	4632      	mov	r2, r6
    RMWREG32(uc->io_base + 0xc704, 24, 5, 0);
3000cc28:	f851 c00a 	ldr.w	r12, [r1, r10]
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc2c:	4629      	mov	r1, r5
    RMWREG32(uc->io_base + 0xc704, 24, 5, 0);
3000cc2e:	f85e 300c 	ldr.w	r3, [r14, r12]
3000cc32:	f023 53f8 	bic.w	r3, r3, #520093696	; 0x1f000000
3000cc36:	f84e 300c 	str.w	r3, [r14, r12]
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc3a:	2340      	movs	r3, #64	; 0x40
3000cc3c:	9502      	str	r5, [sp, #8]
3000cc3e:	e9cd 5600 	strd	r5, r6, [r13]
    uc->speed = speed;
3000cc42:	f8cb 02a4 	str.w	r0, [r11, #676]	; 0x2a4
    dw_usbc_setup_endpoint(instance, 0, USB_OUT, width, USB_CTRL, true, false);
3000cc46:	4620      	mov	r0, r4
3000cc48:	f7ff fb9e 	bl	3000c388 <dw_usbc_setup_endpoint>
    dw_usbc_setup_endpoint(instance, 0, USB_IN, width, USB_CTRL, true, false);
3000cc4c:	462a      	mov	r2, r5
3000cc4e:	4629      	mov	r1, r5
3000cc50:	2340      	movs	r3, #64	; 0x40
3000cc52:	e9cd 6501 	strd	r6, r5, [r13, #4]
3000cc56:	4620      	mov	r0, r4
3000cc58:	9500      	str	r5, [sp, #0]
3000cc5a:	f7ff fb95 	bl	3000c388 <dw_usbc_setup_endpoint>
    dump_registers(uc->io_base, "connectdone");
3000cc5e:	9b04      	ldr	r3, [sp, #16]
3000cc60:	f64e 215c 	movw	r1, #59996	; 0xea5c
3000cc64:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000cc68:	f853 000a 	ldr.w	r0, [r3, r10]
3000cc6c:	f000 fb3e 	bl	3000d2ec <dump_registers>
    uc->do_resched = true;
3000cc70:	f88b 62b4 	strb.w	r6, [r11, #692]	; 0x2b4
3000cc74:	e7be      	b.n	3000cbf4 <usbc_irq+0x208>
            printf("get dev evt usb reset on ep:%d, in: %d\n", ep->num, ep->is_in);
3000cc76:	f64e 2068 	movw	r0, #60008	; 0xea68
    for (uint i = 0; i < NUM_EP; i++) {
3000cc7a:	2600      	movs	r6, #0
            printf("get dev evt usb reset on ep:%d, in: %d\n", ep->num, ep->is_in);
3000cc7c:	9b08      	ldr	r3, [sp, #32]
3000cc7e:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cc82:	785a      	ldrb	r2, [r3, #1]
3000cc84:	7819      	ldrb	r1, [r3, #0]
3000cc86:	f008 ff93 	bl	30015bb0 <_printf>
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000cc8a:	9b05      	ldr	r3, [sp, #20]
    RMWREG32(uc->io_base + 0xc704, 1, 4, 0);
3000cc8c:	f44f 724e 	mov.w	r2, #824	; 0x338
3000cc90:	f24c 7104 	movw	r1, #50948	; 0xc704
3000cc94:	e9cd 870b 	strd	r8, r7, [r13, #44]	; 0x2c
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000cc98:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
3000cc9c:	930a      	str	r3, [sp, #40]	; 0x28
    RMWREG32(uc->io_base + 0xc704, 1, 4, 0);
3000cc9e:	fb02 f503 	mul.w	r5, r2, r3
        ep = &uc->IN_ep[i];
3000cca2:	9a04      	ldr	r2, [sp, #16]
3000cca4:	f105 030c 	add.w	r3, r5, #12
3000cca8:	18d4      	adds	r4, r2, r3
    RMWREG32(uc->io_base + 0xc704, 1, 4, 0);
3000ccaa:	4613      	mov	r3, r2
3000ccac:	5952      	ldr	r2, [r2, r5]
3000ccae:	441d      	add	r5, r3
        ep = &uc->IN_ep[i];
3000ccb0:	940d      	str	r4, [sp, #52]	; 0x34
3000ccb2:	46ab      	mov	r11, r5
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000ccb4:	46aa      	mov	r10, r5
    RMWREG32(uc->io_base + 0xc704, 1, 4, 0);
3000ccb6:	588b      	ldr	r3, [r1, r2]
3000ccb8:	f023 031e 	bic.w	r3, r3, #30
3000ccbc:	508b      	str	r3, [r1, r2]
3000ccbe:	e045      	b.n	3000cd4c <usbc_irq+0x360>
        if (ep->res_id != 0 && i >= 1) {
3000ccc0:	2e00      	cmp	r6, #0
3000ccc2:	f000 82e2 	beq.w	3000d28a <usbc_irq+0x89e>
    return epnum * 2 + is_in;
3000ccc6:	f894 3141 	ldrb.w	r3, [r4, #321]	; 0x141
3000ccca:	f894 1140 	ldrb.w	r1, [r4, #320]	; 0x140
    dw_usb_ll_ep_end_transfer(uc->io_base, p_num, ep->res_id);
3000ccce:	f8d4 2164 	ldr.w	r2, [r4, #356]	; 0x164
3000ccd2:	eb03 0141 	add.w	r1, r3, r1, lsl #1
3000ccd6:	f8da 0000 	ldr.w	r0, [r10]
3000ccda:	f000 fd21 	bl	3000d720 <dw_usb_ll_ep_end_transfer>
    ep->res_id = 0;
3000ccde:	2300      	movs	r3, #0
3000cce0:	f8c4 3164 	str.w	r3, [r4, #356]	; 0x164
        if (ep->res_id != 0 && i >= 1) {
3000cce4:	f8db 3030 	ldr.w	r3, [r11, #48]	; 0x30
3000cce8:	b153      	cbz	r3, 3000cd00 <usbc_irq+0x314>
    return epnum * 2 + is_in;
3000ccea:	7863      	ldrb	r3, [r4, #1]
3000ccec:	7821      	ldrb	r1, [r4, #0]
    dw_usb_ll_ep_end_transfer(uc->io_base, p_num, ep->res_id);
3000ccee:	6a62      	ldr	r2, [r4, #36]	; 0x24
3000ccf0:	eb03 0141 	add.w	r1, r3, r1, lsl #1
3000ccf4:	f8da 0000 	ldr.w	r0, [r10]
3000ccf8:	f000 fd12 	bl	3000d720 <dw_usb_ll_ep_end_transfer>
    ep->res_id = 0;
3000ccfc:	2300      	movs	r3, #0
3000ccfe:	6263      	str	r3, [r4, #36]	; 0x24
    ep->is_stall = 0;
3000cd00:	f04f 0800 	mov.w	r8, #0
    return epnum * 2 + is_in;
3000cd04:	2702      	movs	r7, #2
3000cd06:	f894 c140 	ldrb.w	r12, [r4, #320]	; 0x140
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000cd0a:	4642      	mov	r2, r8
    ep->is_stall = 0;
3000cd0c:	f884 8142 	strb.w	r8, [r4, #322]	; 0x142
    return epnum * 2 + is_in;
3000cd10:	f894 1141 	ldrb.w	r1, [r4, #321]	; 0x141
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000cd14:	f8da 0000 	ldr.w	r0, [r10]
3000cd18:	fb07 110c 	mla	r1, r7, r12, r1
3000cd1c:	f000 fcd6 	bl	3000d6cc <dw_usb_ll_clear_ep_stall>
    return epnum * 2 + is_in;
3000cd20:	f894 c000 	ldrb.w	r12, [r4]
    ep->is_stall = 0;
3000cd24:	f884 8002 	strb.w	r8, [r4, #2]
    return epnum * 2 + is_in;
3000cd28:	7861      	ldrb	r1, [r4, #1]
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000cd2a:	f8da 0000 	ldr.w	r0, [r10]
3000cd2e:	4642      	mov	r2, r8
3000cd30:	fb07 110c 	mla	r1, r7, r12, r1
3000cd34:	f000 fcca 	bl	3000d6cc <dw_usb_ll_clear_ep_stall>
    for (uint i = 0; i < NUM_EP; i++) {
3000cd38:	3601      	adds	r6, #1
3000cd3a:	2e08      	cmp	r6, #8
3000cd3c:	f105 0508 	add.w	r5, r5, #8
3000cd40:	f104 0428 	add.w	r4, r4, #40	; 0x28
3000cd44:	f10b 0b28 	add.w	r11, r11, #40	; 0x28
3000cd48:	f000 810d 	beq.w	3000cf66 <usbc_irq+0x57a>
        if (uc->ep_in[i].transfer) {
3000cd4c:	f8d5 12bc 	ldr.w	r1, [r5, #700]	; 0x2bc
3000cd50:	b149      	cbz	r1, 3000cd66 <usbc_irq+0x37a>
                if (t->callback) {
3000cd52:	680b      	ldr	r3, [r1, #0]
            uc->ep_in[i].transfer = NULL;
3000cd54:	2000      	movs	r0, #0
                t->result = ERR_CANCELLED;
3000cd56:	f06f 0219 	mvn.w	r2, #25
            uc->ep_in[i].transfer = NULL;
3000cd5a:	f8c5 02bc 	str.w	r0, [r5, #700]	; 0x2bc
                t->result = ERR_CANCELLED;
3000cd5e:	604a      	str	r2, [r1, #4]
                if (t->callback) {
3000cd60:	b10b      	cbz	r3, 3000cd66 <usbc_irq+0x37a>
                    t->callback(i, t);
3000cd62:	4630      	mov	r0, r6
3000cd64:	4798      	blx	r3
        if (uc->ep_out[i].transfer) {
3000cd66:	f8d5 12fc 	ldr.w	r1, [r5, #764]	; 0x2fc
3000cd6a:	b149      	cbz	r1, 3000cd80 <usbc_irq+0x394>
                if (t->callback) {
3000cd6c:	680b      	ldr	r3, [r1, #0]
            uc->ep_out[i].transfer = NULL;
3000cd6e:	2000      	movs	r0, #0
                t->result = ERR_CANCELLED;
3000cd70:	f06f 0219 	mvn.w	r2, #25
            uc->ep_out[i].transfer = NULL;
3000cd74:	f8c5 02fc 	str.w	r0, [r5, #764]	; 0x2fc
                t->result = ERR_CANCELLED;
3000cd78:	604a      	str	r2, [r1, #4]
                if (t->callback) {
3000cd7a:	b10b      	cbz	r3, 3000cd80 <usbc_irq+0x394>
                    t->callback(i, t);
3000cd7c:	4630      	mov	r0, r6
3000cd7e:	4798      	blx	r3
        if (ep->res_id != 0 && i >= 1) {
3000cd80:	f8db 3170 	ldr.w	r3, [r11, #368]	; 0x170
3000cd84:	2b00      	cmp	r3, #0
3000cd86:	d19b      	bne.n	3000ccc0 <usbc_irq+0x2d4>
        if (ep->res_id != 0 && i >= 1) {
3000cd88:	f8db 3030 	ldr.w	r3, [r11, #48]	; 0x30
        ep = &uc->IN_ep[i];
3000cd8c:	4620      	mov	r0, r4
        if (ep->res_id != 0 && i >= 1) {
3000cd8e:	2b00      	cmp	r3, #0
3000cd90:	d05b      	beq.n	3000ce4a <usbc_irq+0x45e>
3000cd92:	2e00      	cmp	r6, #0
3000cd94:	d1a9      	bne.n	3000ccea <usbc_irq+0x2fe>
    ep->is_stall = 0;
3000cd96:	2300      	movs	r3, #0
    return epnum * 2 + is_in;
3000cd98:	f890 c000 	ldrb.w	r12, [r0]
3000cd9c:	7841      	ldrb	r1, [r0, #1]
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000cd9e:	461a      	mov	r2, r3
    ep->is_stall = 0;
3000cda0:	7083      	strb	r3, [r0, #2]
    dw_usb_ll_clear_ep_stall(uc->io_base, p_num, param0);
3000cda2:	eb01 014c 	add.w	r1, r1, r12, lsl #1
3000cda6:	f8da 0000 	ldr.w	r0, [r10]
3000cdaa:	f000 fc8f 	bl	3000d6cc <dw_usb_ll_clear_ep_stall>
3000cdae:	e7c3      	b.n	3000cd38 <usbc_irq+0x34c>
            printf("get dev evt disconnect detect on ep:%d, in: %d\n", ep->num,
3000cdb0:	9b08      	ldr	r3, [sp, #32]
3000cdb2:	f64e 2090 	movw	r0, #60048	; 0xea90
3000cdb6:	785a      	ldrb	r2, [r3, #1]
3000cdb8:	7819      	ldrb	r1, [r3, #0]
3000cdba:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cdbe:	f008 fef7 	bl	30015bb0 <_printf>
    dw_usb_ll_disconnect_evt(uc->io_base);
3000cdc2:	f44f 734e 	mov.w	r3, #824	; 0x338
3000cdc6:	fb03 f404 	mul.w	r4, r3, r4
3000cdca:	9b04      	ldr	r3, [sp, #16]
3000cdcc:	5918      	ldr	r0, [r3, r4]
3000cdce:	f000 fc23 	bl	3000d618 <dw_usb_ll_disconnect_evt>
            hal_usbc_callback(USB_CB_DISCONNECT, &args);
3000cdd2:	2003      	movs	r0, #3
3000cdd4:	a90e      	add	r1, sp, #56	; 0x38
3000cdd6:	f003 fe0f 	bl	300109f8 <hal_usbc_callback>
3000cdda:	e70b      	b.n	3000cbf4 <usbc_irq+0x208>
    dw_usb_ll_unmask_irq(uc->io_base);
3000cddc:	f8d9 0000 	ldr.w	r0, [r9]
3000cde0:	f8dd b024 	ldr.w	r11, [r13, #36]	; 0x24
3000cde4:	f8dd a010 	ldr.w	r10, [r13, #16]
3000cde8:	f000 fb20 	bl	3000d42c <dw_usb_ll_unmask_irq>
3000cdec:	e634      	b.n	3000ca58 <usbc_irq+0x6c>
3000cdee:	f8d4 b004 	ldr.w	r11, [r4, #4]
            ep->res_id = 0;
3000cdf2:	2300      	movs	r3, #0
            if (ep->num == 0) { //control ep
3000cdf4:	f894 a000 	ldrb.w	r10, [r4]
            ep->res_id = 0;
3000cdf8:	6263      	str	r3, [r4, #36]	; 0x24
3000cdfa:	f8db 0000 	ldr.w	r0, [r11]
            if (ep->num == 0) { //control ep
3000cdfe:	f1ba 0f00 	cmp.w	r10, #0
3000ce02:	f000 8088 	beq.w	3000cf16 <usbc_irq+0x52a>
                if (ep->is_in == 0) { //out
3000ce06:	7863      	ldrb	r3, [r4, #1]
                    arch_invalidate_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000ce08:	2120      	movs	r1, #32
                if (ep->is_in == 0) { //out
3000ce0a:	bb13      	cbnz	r3, 3000ce52 <usbc_irq+0x466>
                    arch_invalidate_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000ce0c:	f7f4 ee82 	blx	30001b14 <arch_invalidate_cache_range>
                                                            trbd->trb->trb2.bufsize);
3000ce10:	f8db 3000 	ldr.w	r3, [r11]
    return orig_size - remain_size;
3000ce14:	f8db 1008 	ldr.w	r1, [r11, #8]
                    ep->xfer_count += count;
3000ce18:	69e0      	ldr	r0, [r4, #28]
                                                            trbd->trb->trb2.bufsize);
3000ce1a:	689b      	ldr	r3, [r3, #8]
                    ep->xfer_buff += count;
3000ce1c:	6962      	ldr	r2, [r4, #20]
                                                            trbd->trb->trb2.bufsize);
3000ce1e:	f3c3 0317 	ubfx	r3, r3, #0, #24
    return orig_size - remain_size;
3000ce22:	1ac9      	subs	r1, r1, r3
                    if ((ep->xfer_len == 0) || (count < ep->maxpacket)) {
3000ce24:	69a3      	ldr	r3, [r4, #24]
                    ep->xfer_count += count;
3000ce26:	4408      	add	r0, r1
                    ep->xfer_buff += count;
3000ce28:	440a      	add	r2, r1
                    ep->xfer_count += count;
3000ce2a:	61e0      	str	r0, [r4, #28]
                    ep->xfer_buff += count;
3000ce2c:	6162      	str	r2, [r4, #20]
                    if ((ep->xfer_len == 0) || (count < ep->maxpacket)) {
3000ce2e:	b11b      	cbz	r3, 3000ce38 <usbc_irq+0x44c>
3000ce30:	68e0      	ldr	r0, [r4, #12]
3000ce32:	4281      	cmp	r1, r0
3000ce34:	f080 8090 	bcs.w	3000cf58 <usbc_irq+0x56c>
                        dw_usbc_dataoutstagecb(instance, ep);
3000ce38:	4630      	mov	r0, r6
3000ce3a:	f104 021c 	add.w	r2, r4, #28
3000ce3e:	4621      	mov	r1, r4
3000ce40:	f7ff f974 	bl	3000c12c <dw_usbc_dataoutstagecb.isra.12>
3000ce44:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000ce48:	e668      	b.n	3000cb1c <usbc_irq+0x130>
        if (i == 0) {
3000ce4a:	2e00      	cmp	r6, #0
3000ce4c:	f47f af58 	bne.w	3000cd00 <usbc_irq+0x314>
3000ce50:	e7a1      	b.n	3000cd96 <usbc_irq+0x3aa>
                    arch_invalidate_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000ce52:	f7f4 ee60 	blx	30001b14 <arch_invalidate_cache_range>
                                                       trbd->trb->trb2.bufsize);
3000ce56:	f8db 3000 	ldr.w	r3, [r11]
    return orig_size - remain_size;
3000ce5a:	f8db 2008 	ldr.w	r2, [r11, #8]
                    ep->xfer_count += count;
3000ce5e:	69e0      	ldr	r0, [r4, #28]
                                                       trbd->trb->trb2.bufsize);
3000ce60:	689b      	ldr	r3, [r3, #8]
                    ep->xfer_buff += count;
3000ce62:	6961      	ldr	r1, [r4, #20]
                                                       trbd->trb->trb2.bufsize);
3000ce64:	f3c3 0317 	ubfx	r3, r3, #0, #24
    return orig_size - remain_size;
3000ce68:	1ad2      	subs	r2, r2, r3
                    if (ep->xfer_len == 0) {
3000ce6a:	69a3      	ldr	r3, [r4, #24]
                    ep->xfer_count += count;
3000ce6c:	4410      	add	r0, r2
                    ep->xfer_buff += count;
3000ce6e:	440a      	add	r2, r1
                    ep->xfer_count += count;
3000ce70:	61e0      	str	r0, [r4, #28]
                    ep->xfer_buff += count;
3000ce72:	6162      	str	r2, [r4, #20]
                    if (ep->xfer_len == 0) {
3000ce74:	2b00      	cmp	r3, #0
3000ce76:	d16f      	bne.n	3000cf58 <usbc_irq+0x56c>
    if (uc->ep_in[ep->num].transfer) {
3000ce78:	eb06 0246 	add.w	r2, r6, r6, lsl #1
3000ce7c:	7821      	ldrb	r1, [r4, #0]
3000ce7e:	eb02 1202 	add.w	r2, r2, r2, lsl #4
3000ce82:	eb06 0242 	add.w	r2, r6, r2, lsl #1
3000ce86:	440a      	add	r2, r1
3000ce88:	9904      	ldr	r1, [sp, #16]
3000ce8a:	3257      	adds	r2, #87	; 0x57
3000ce8c:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
3000ce90:	6851      	ldr	r1, [r2, #4]
3000ce92:	b139      	cbz	r1, 3000cea4 <usbc_irq+0x4b8>
        if (t->callback) {
3000ce94:	680d      	ldr	r5, [r1, #0]
        uc->ep_in[ep->num].transfer = 0;
3000ce96:	6053      	str	r3, [r2, #4]
        t->bufpos = ep->xfer_count;
3000ce98:	69e2      	ldr	r2, [r4, #28]
3000ce9a:	610a      	str	r2, [r1, #16]
        t->result = 0;
3000ce9c:	604b      	str	r3, [r1, #4]
        if (t->callback) {
3000ce9e:	b10d      	cbz	r5, 3000cea4 <usbc_irq+0x4b8>
            t->callback(ep->num, t);
3000cea0:	7820      	ldrb	r0, [r4, #0]
3000cea2:	47a8      	blx	r5
    uc->do_resched = true;
3000cea4:	9b04      	ldr	r3, [sp, #16]
3000cea6:	f44f 724e 	mov.w	r2, #824	; 0x338
3000ceaa:	fb02 3606 	mla	r6, r2, r6, r3
3000ceae:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000ceb2:	2301      	movs	r3, #1
3000ceb4:	f886 32b4 	strb.w	r3, [r6, #692]	; 0x2b4
3000ceb8:	e630      	b.n	3000cb1c <usbc_irq+0x130>
    switch (evt.evtstatus) {
3000ceba:	f3c1 3103 	ubfx	r1, r1, #12, #4
3000cebe:	2901      	cmp	r1, #1
3000cec0:	f000 80f7 	beq.w	3000d0b2 <usbc_irq+0x6c6>
3000cec4:	2902      	cmp	r1, #2
3000cec6:	f47f ae29 	bne.w	3000cb1c <usbc_irq+0x130>
            if (uc->ep0_next_event != DW_EP0_NRDY_STATUS) {
3000ceca:	9904      	ldr	r1, [sp, #16]
3000cecc:	f44f 704e 	mov.w	r0, #824	; 0x338
3000ced0:	fb00 1106 	mla	r1, r0, r6, r1
3000ced4:	f8d1 0298 	ldr.w	r0, [r1, #664]	; 0x298
3000ced8:	2803      	cmp	r0, #3
3000ceda:	f47f ae1f 	bne.w	3000cb1c <usbc_irq+0x130>
            uc->ep0_expect_in = !uc->ep0_expect_in;
3000cede:	f891 2294 	ldrb.w	r2, [r1, #660]	; 0x294
            uc->ep0stage = EP0_STATUS_PHASE;
3000cee2:	f8c1 0290 	str.w	r0, [r1, #656]	; 0x290
            uc->ep0_expect_in = !uc->ep0_expect_in;
3000cee6:	f082 0201 	eor.w	r2, r2, #1
3000ceea:	f881 2294 	strb.w	r2, [r1, #660]	; 0x294
                dw_usbc_ep0_send(instance, uc->Setup, 0, 0);
3000ceee:	f8d1 12a8 	ldr.w	r1, [r1, #680]	; 0x2a8
            if (uc->ep0_expect_in) {
3000cef2:	2a00      	cmp	r2, #0
3000cef4:	f000 81d3 	beq.w	3000d29e <usbc_irq+0x8b2>
                dw_usbc_ep0_send(instance, uc->Setup, 0, 0);
3000cef8:	461a      	mov	r2, r3
3000cefa:	4630      	mov	r0, r6
3000cefc:	f7ff fb40 	bl	3000c580 <dw_usbc_ep0_send>
            uc->ep0_next_event = DW_EP0_COMPLETE;
3000cf00:	9b04      	ldr	r3, [sp, #16]
3000cf02:	f44f 724e 	mov.w	r2, #824	; 0x338
3000cf06:	fb02 3606 	mla	r6, r2, r6, r3
3000cf0a:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000cf0e:	2301      	movs	r3, #1
3000cf10:	f8c6 3298 	str.w	r3, [r6, #664]	; 0x298
3000cf14:	e602      	b.n	3000cb1c <usbc_irq+0x130>
                arch_invalidate_cache_range((addr_t)trbd->trb, ROUNDUP(sizeof(trb_t),
3000cf16:	2120      	movs	r1, #32
3000cf18:	f7f4 edfc 	blx	30001b14 <arch_invalidate_cache_range>
                if (uc->ep0stage == EP0_SETUP_PHASE) {
3000cf1c:	9b04      	ldr	r3, [sp, #16]
3000cf1e:	f44f 724e 	mov.w	r2, #824	; 0x338
3000cf22:	fb02 3106 	mla	r1, r2, r6, r3
3000cf26:	f8d1 3290 	ldr.w	r3, [r1, #656]	; 0x290
3000cf2a:	2b01      	cmp	r3, #1
3000cf2c:	f000 8130 	beq.w	3000d190 <usbc_irq+0x7a4>
                else if (uc->ep0stage == EP0_DATA_PHASE) {
3000cf30:	2b02      	cmp	r3, #2
3000cf32:	f000 8103 	beq.w	3000d13c <usbc_irq+0x750>
                else if (uc->ep0stage == EP0_STATUS_PHASE) {
3000cf36:	2b03      	cmp	r3, #3
3000cf38:	f47f ae5c 	bne.w	3000cbf4 <usbc_irq+0x208>
                    uc->ep0stage = EP0_SETUP_PHASE;
3000cf3c:	f8c1 5290 	str.w	r5, [r1, #656]	; 0x290
                    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000cf40:	2208      	movs	r2, #8
                    uc->three_stage_setup = false;
3000cf42:	f881 a295 	strb.w	r10, [r1, #661]	; 0x295
                    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000cf46:	4630      	mov	r0, r6
3000cf48:	f8d1 12a8 	ldr.w	r1, [r1, #680]	; 0x2a8
3000cf4c:	4653      	mov	r3, r10
3000cf4e:	f7ff fb53 	bl	3000c5f8 <dw_usbc_ep0_recv>
3000cf52:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000cf56:	e5e1      	b.n	3000cb1c <usbc_irq+0x130>
                        dw_usbc_ep_trans(instance, ep, ep->xfer_buff, ep->xfer_len);
3000cf58:	4621      	mov	r1, r4
3000cf5a:	4630      	mov	r0, r6
3000cf5c:	f7ff f93e 	bl	3000c1dc <dw_usbc_ep_trans>
3000cf60:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000cf64:	e5da      	b.n	3000cb1c <usbc_irq+0x130>
    dw_usb_ll_set_address(uc->io_base, address);
3000cf66:	9b05      	ldr	r3, [sp, #20]
3000cf68:	f44f 754e 	mov.w	r5, #824	; 0x338
3000cf6c:	9c04      	ldr	r4, [sp, #16]
3000cf6e:	2100      	movs	r1, #0
3000cf70:	e9dd 870b 	ldrd	r8, r7, [r13, #44]	; 0x2c
3000cf74:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
3000cf78:	fb05 f303 	mul.w	r3, r5, r3
3000cf7c:	58e0      	ldr	r0, [r4, r3]
3000cf7e:	f000 fc35 	bl	3000d7ec <dw_usb_ll_set_address>
    dump_registers(uc->io_base, "reset");
3000cf82:	9b0a      	ldr	r3, [sp, #40]	; 0x28
3000cf84:	4622      	mov	r2, r4
3000cf86:	f64e 21ec 	movw	r1, #60140	; 0xeaec
3000cf8a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000cf8e:	fb05 f303 	mul.w	r3, r5, r3
3000cf92:	441c      	add	r4, r3
3000cf94:	58d0      	ldr	r0, [r2, r3]
3000cf96:	f000 f9a9 	bl	3000d2ec <dump_registers>
    uc->do_resched = true;
3000cf9a:	2301      	movs	r3, #1
            hal_usbc_callback(USB_CB_RESET, &args);
3000cf9c:	2000      	movs	r0, #0
3000cf9e:	a90e      	add	r1, sp, #56	; 0x38
    uc->do_resched = true;
3000cfa0:	f884 32b4 	strb.w	r3, [r4, #692]	; 0x2b4
            hal_usbc_callback(USB_CB_RESET, &args);
3000cfa4:	f003 fd28 	bl	300109f8 <hal_usbc_callback>
3000cfa8:	e624      	b.n	3000cbf4 <usbc_irq+0x208>
            printf("get dev ecc error on ep:%d, in:%d\n", ep->num, ep->is_in);
3000cfaa:	9b08      	ldr	r3, [sp, #32]
3000cfac:	f64e 0040 	movw	r0, #59456	; 0xe840
3000cfb0:	785a      	ldrb	r2, [r3, #1]
3000cfb2:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cfb6:	7819      	ldrb	r1, [r3, #0]
3000cfb8:	f008 fdfa 	bl	30015bb0 <_printf>
            printf("get unknown event %d on ep:%d, in:%d \n", evt.evtnum, ep->num,
3000cfbc:	f64e 20f4 	movw	r0, #60148	; 0xeaf4
3000cfc0:	4629      	mov	r1, r5
3000cfc2:	f899 314d 	ldrb.w	r3, [r9, #333]	; 0x14d
3000cfc6:	f899 214c 	ldrb.w	r2, [r9, #332]	; 0x14c
3000cfca:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cfce:	f008 fdef 	bl	30015bb0 <_printf>
3000cfd2:	e60f      	b.n	3000cbf4 <usbc_irq+0x208>
            printf("get dev evt sof on ep:%d, in: %d\n", ep->num, ep->is_in);
3000cfd4:	9b08      	ldr	r3, [sp, #32]
3000cfd6:	f64e 108c 	movw	r0, #59788	; 0xe98c
3000cfda:	785a      	ldrb	r2, [r3, #1]
3000cfdc:	7819      	ldrb	r1, [r3, #0]
3000cfde:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cfe2:	f008 fde5 	bl	30015bb0 <_printf>
3000cfe6:	e7e9      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt usb suspend entry on ep:%d, in: %d\n", ep->num,
3000cfe8:	9b08      	ldr	r3, [sp, #32]
3000cfea:	f64e 10b0 	movw	r0, #59824	; 0xe9b0
3000cfee:	785a      	ldrb	r2, [r3, #1]
3000cff0:	7819      	ldrb	r1, [r3, #0]
3000cff2:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000cff6:	f008 fddb 	bl	30015bb0 <_printf>
3000cffa:	e7df      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt hibernate request on ep:%d, in: %d\n", ep->num,
3000cffc:	9b08      	ldr	r3, [sp, #32]
3000cffe:	f64e 10e0 	movw	r0, #59872	; 0xe9e0
3000d002:	785a      	ldrb	r2, [r3, #1]
3000d004:	7819      	ldrb	r1, [r3, #0]
3000d006:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d00a:	f008 fdd1 	bl	30015bb0 <_printf>
3000d00e:	e7d5      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt wakeup on ep:%d, in: %d\n", ep->num, ep->is_in);
3000d010:	9b08      	ldr	r3, [sp, #32]
3000d012:	f64e 2010 	movw	r0, #59920	; 0xea10
3000d016:	785a      	ldrb	r2, [r3, #1]
3000d018:	7819      	ldrb	r1, [r3, #0]
3000d01a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d01e:	f008 fdc7 	bl	30015bb0 <_printf>
3000d022:	e7cb      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt buffer overflow on ep:%d, in:%d\n", ep->num,
3000d024:	9b08      	ldr	r3, [sp, #32]
3000d026:	f64e 00d0 	movw	r0, #59600	; 0xe8d0
3000d02a:	785a      	ldrb	r2, [r3, #1]
3000d02c:	7819      	ldrb	r1, [r3, #0]
3000d02e:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d032:	f008 fdbd 	bl	30015bb0 <_printf>
3000d036:	e7c1      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt generic cmd complete on ep:%d, in:%d\n", ep->num,
3000d038:	9b08      	ldr	r3, [sp, #32]
3000d03a:	f64e 1000 	movw	r0, #59648	; 0xe900
3000d03e:	785a      	ldrb	r2, [r3, #1]
3000d040:	7819      	ldrb	r1, [r3, #0]
3000d042:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d046:	f008 fdb3 	bl	30015bb0 <_printf>
3000d04a:	e7b7      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt erratic error on ep:%d, in:%d \n", ep->num, ep->is_in);
3000d04c:	9b08      	ldr	r3, [sp, #32]
3000d04e:	f64e 1034 	movw	r0, #59700	; 0xe934
3000d052:	785a      	ldrb	r2, [r3, #1]
3000d054:	7819      	ldrb	r1, [r3, #0]
3000d056:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d05a:	f008 fda9 	bl	30015bb0 <_printf>
3000d05e:	e7ad      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev evt L1 suspend on ep:%d, in: %d\n", ep->num, ep->is_in);
3000d060:	9b08      	ldr	r3, [sp, #32]
3000d062:	f64e 1060 	movw	r0, #59744	; 0xe960
3000d066:	785a      	ldrb	r2, [r3, #1]
3000d068:	7819      	ldrb	r1, [r3, #0]
3000d06a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d06e:	f008 fd9f 	bl	30015bb0 <_printf>
3000d072:	e7a3      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev L1 resume event on ep:%d, in:%d\n", ep->num, ep->is_in);
3000d074:	9b08      	ldr	r3, [sp, #32]
3000d076:	f64e 0064 	movw	r0, #59492	; 0xe864
3000d07a:	785a      	ldrb	r2, [r3, #1]
3000d07c:	7819      	ldrb	r1, [r3, #0]
3000d07e:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d082:	f008 fd95 	bl	30015bb0 <_printf>
3000d086:	e799      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev vendor dev test lmp received event on ep:%d, in:%d \n",
3000d088:	9b08      	ldr	r3, [sp, #32]
3000d08a:	f64e 0090 	movw	r0, #59536	; 0xe890
3000d08e:	785a      	ldrb	r2, [r3, #1]
3000d090:	7819      	ldrb	r1, [r3, #0]
3000d092:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d096:	f008 fd8b 	bl	30015bb0 <_printf>
3000d09a:	e78f      	b.n	3000cfbc <usbc_irq+0x5d0>
            printf("get dev unknown event %d on ep:%d, in:%d \n", evt.evtnum, ep->num,
3000d09c:	f64e 20c0 	movw	r0, #60096	; 0xeac0
3000d0a0:	4629      	mov	r1, r5
3000d0a2:	9a08      	ldr	r2, [sp, #32]
3000d0a4:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d0a8:	7853      	ldrb	r3, [r2, #1]
3000d0aa:	7812      	ldrb	r2, [r2, #0]
3000d0ac:	f008 fd80 	bl	30015bb0 <_printf>
3000d0b0:	e784      	b.n	3000cfbc <usbc_irq+0x5d0>
            if (uc->ep0_expect_in != ep->is_in) {
3000d0b2:	f44f 734e 	mov.w	r3, #824	; 0x338
3000d0b6:	7860      	ldrb	r0, [r4, #1]
3000d0b8:	9c04      	ldr	r4, [sp, #16]
3000d0ba:	fb03 f306 	mul.w	r3, r3, r6
3000d0be:	18e1      	adds	r1, r4, r3
3000d0c0:	f891 1294 	ldrb.w	r1, [r1, #660]	; 0x294
3000d0c4:	4281      	cmp	r1, r0
3000d0c6:	f43f ad29 	beq.w	3000cb1c <usbc_irq+0x130>
                ep = uc->ep0_expect_in ? &uc->IN_ep[0] : &uc->OUT_ep[0];
3000d0ca:	2900      	cmp	r1, #0
3000d0cc:	f000 80d7 	beq.w	3000d27e <usbc_irq+0x892>
3000d0d0:	330c      	adds	r3, #12
3000d0d2:	eb04 0a03 	add.w	r10, r4, r3
                dprintf(CRITICAL, "Wrong direction for Data phase\n");
3000d0d6:	f64e 0020 	movw	r0, #59424	; 0xe820
    ep->res_id = 0;
3000d0da:	2500      	movs	r5, #0
                dprintf(CRITICAL, "Wrong direction for Data phase\n");
3000d0dc:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d0e0:	f008 fd66 	bl	30015bb0 <_printf>
    dw_usb_ll_ep_end_transfer(uc->io_base, p_num, ep->res_id);
3000d0e4:	9804      	ldr	r0, [sp, #16]
3000d0e6:	f44f 734e 	mov.w	r3, #824	; 0x338
    return epnum * 2 + is_in;
3000d0ea:	f89a 2001 	ldrb.w	r2, [r10, #1]
3000d0ee:	f89a 1000 	ldrb.w	r1, [r10]
    dw_usb_ll_ep_end_transfer(uc->io_base, p_num, ep->res_id);
3000d0f2:	eb02 0141 	add.w	r1, r2, r1, lsl #1
3000d0f6:	fb03 f306 	mul.w	r3, r3, r6
3000d0fa:	f8da 2024 	ldr.w	r2, [r10, #36]	; 0x24
3000d0fe:	18c4      	adds	r4, r0, r3
3000d100:	58c0      	ldr	r0, [r0, r3]
3000d102:	f000 fb0d 	bl	3000d720 <dw_usb_ll_ep_end_transfer>
                usbc_ep0_stall(usb);
3000d106:	9805      	ldr	r0, [sp, #20]
    ep->res_id = 0;
3000d108:	f8ca 5024 	str.w	r5, [r10, #36]	; 0x24
                usbc_ep0_stall(usb);
3000d10c:	f7ff fc56 	bl	3000c9bc <usbc_ep0_stall>
                if (uc->OUT_ep[0].is_stall) { //stall
3000d110:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
3000d114:	2b00      	cmp	r3, #0
3000d116:	f43f ad6d 	beq.w	3000cbf4 <usbc_irq+0x208>
                    uc->ep0stage = EP0_SETUP_PHASE;
3000d11a:	2101      	movs	r1, #1
                    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d11c:	2208      	movs	r2, #8
3000d11e:	4630      	mov	r0, r6
3000d120:	462b      	mov	r3, r5
                    uc->ep0stage = EP0_SETUP_PHASE;
3000d122:	f8c4 1290 	str.w	r1, [r4, #656]	; 0x290
                    uc->OUT_ep[0].is_stall = 0;
3000d126:	f884 514e 	strb.w	r5, [r4, #334]	; 0x14e
                    uc->three_stage_setup = false;
3000d12a:	f884 5295 	strb.w	r5, [r4, #661]	; 0x295
                    dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d12e:	f8d4 12a8 	ldr.w	r1, [r4, #680]	; 0x2a8
3000d132:	f7ff fa61 	bl	3000c5f8 <dw_usbc_ep0_recv>
3000d136:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000d13a:	e4ef      	b.n	3000cb1c <usbc_irq+0x130>
                    if (ep->is_in == 0) { /*data out*/
3000d13c:	7863      	ldrb	r3, [r4, #1]
3000d13e:	2b00      	cmp	r3, #0
3000d140:	d16b      	bne.n	3000d21a <usbc_irq+0x82e>
                                          trbd->trb->trb2.bufsize);
3000d142:	f8db 3000 	ldr.w	r3, [r11]
    return orig_size - remain_size;
3000d146:	f8db 1008 	ldr.w	r1, [r11, #8]
                        ep->xfer_count += count;
3000d14a:	69e0      	ldr	r0, [r4, #28]
                                          trbd->trb->trb2.bufsize);
3000d14c:	689b      	ldr	r3, [r3, #8]
                        ep->xfer_buff += count;
3000d14e:	6962      	ldr	r2, [r4, #20]
                                          trbd->trb->trb2.bufsize);
3000d150:	f3c3 0317 	ubfx	r3, r3, #0, #24
    return orig_size - remain_size;
3000d154:	1ac9      	subs	r1, r1, r3
                        if ((ep->xfer_len == 0) || (count < ep->maxpacket)) {
3000d156:	69a3      	ldr	r3, [r4, #24]
                        ep->xfer_count += count;
3000d158:	4408      	add	r0, r1
                        ep->xfer_buff += count;
3000d15a:	440a      	add	r2, r1
                        ep->xfer_count += count;
3000d15c:	61e0      	str	r0, [r4, #28]
                        ep->xfer_buff += count;
3000d15e:	6162      	str	r2, [r4, #20]
                        if ((ep->xfer_len == 0) || (count < ep->maxpacket)) {
3000d160:	b11b      	cbz	r3, 3000d16a <usbc_irq+0x77e>
3000d162:	68e0      	ldr	r0, [r4, #12]
3000d164:	4281      	cmp	r1, r0
3000d166:	f4bf aef7 	bcs.w	3000cf58 <usbc_irq+0x56c>
                            uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d16a:	9b04      	ldr	r3, [sp, #16]
3000d16c:	f44f 724e 	mov.w	r2, #824	; 0x338
3000d170:	2503      	movs	r5, #3
                            dw_usbc_dataoutstagecb(instance, ep);
3000d172:	4630      	mov	r0, r6
3000d174:	4621      	mov	r1, r4
                            uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d176:	fb02 3306 	mla	r3, r2, r6, r3
                            dw_usbc_dataoutstagecb(instance, ep);
3000d17a:	f104 021c 	add.w	r2, r4, #28
                            uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d17e:	f8c3 5298 	str.w	r5, [r3, #664]	; 0x298
                            uc->ep0stage = EP0_STATUS_PHASE;
3000d182:	f8c3 5290 	str.w	r5, [r3, #656]	; 0x290
                            dw_usbc_dataoutstagecb(instance, ep);
3000d186:	f7fe ffd1 	bl	3000c12c <dw_usbc_dataoutstagecb.isra.12>
3000d18a:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000d18e:	e4c5      	b.n	3000cb1c <usbc_irq+0x130>
3000d190:	930a      	str	r3, [sp, #40]	; 0x28
    arch_invalidate_cache_range((addr_t)uc->Setup, ROUNDUP(8, CACHE_LINE));
3000d192:	4610      	mov	r0, r2
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000d194:	9b05      	ldr	r3, [sp, #20]
    arch_invalidate_cache_range((addr_t)uc->Setup, ROUNDUP(8, CACHE_LINE));
3000d196:	2120      	movs	r1, #32
3000d198:	9a04      	ldr	r2, [sp, #16]
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];
3000d19a:	f8d3 408c 	ldr.w	r4, [r3, #140]	; 0x8c
    arch_invalidate_cache_range((addr_t)uc->Setup, ROUNDUP(8, CACHE_LINE));
3000d19e:	fb00 2504 	mla	r5, r0, r4, r2
3000d1a2:	f8d5 02a8 	ldr.w	r0, [r5, #680]	; 0x2a8
3000d1a6:	f7f4 ecb6 	blx	30001b14 <arch_invalidate_cache_range>
    args.setup = (struct usb_setup *)uc->Setup;
3000d1aa:	f8d5 22a8 	ldr.w	r2, [r5, #680]	; 0x2a8
    args.usb = usb;
3000d1ae:	9b05      	ldr	r3, [sp, #20]
    args.setup = (struct usb_setup *)uc->Setup;
3000d1b0:	e9cd 230e 	strd	r2, r3, [r13, #56]	; 0x38
    if (!args.setup->length) {
3000d1b4:	88d1      	ldrh	r1, [r2, #6]
3000d1b6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
3000d1b8:	2900      	cmp	r1, #0
3000d1ba:	d068      	beq.n	3000d28e <usbc_irq+0x8a2>
        uc->three_stage_setup = true;
3000d1bc:	f885 3295 	strb.w	r3, [r5, #661]	; 0x295
        uc->ep0stage = EP0_DATA_PHASE;
3000d1c0:	2102      	movs	r1, #2
        uc->ep0_expect_in = !!(args.setup->request_type & DIR_IN);
3000d1c2:	7813      	ldrb	r3, [r2, #0]
3000d1c4:	09db      	lsrs	r3, r3, #7
        uc->ep0stage = EP0_DATA_PHASE;
3000d1c6:	f8c5 1290 	str.w	r1, [r5, #656]	; 0x290
        uc->ep0_expect_in = !!(args.setup->request_type & DIR_IN);
3000d1ca:	f885 3294 	strb.w	r3, [r5, #660]	; 0x294
        uc->ep0_next_event = DW_EP0_NRDY_DATA;
3000d1ce:	f8c5 1298 	str.w	r1, [r5, #664]	; 0x298
    hal_usbc_callback(USB_CB_SETUP_MSG, &args);
3000d1d2:	2006      	movs	r0, #6
3000d1d4:	a90e      	add	r1, sp, #56	; 0x38
3000d1d6:	f003 fc0f 	bl	300109f8 <hal_usbc_callback>
    uc->do_resched = true;
3000d1da:	9b04      	ldr	r3, [sp, #16]
3000d1dc:	f44f 714e 	mov.w	r1, #824	; 0x338
3000d1e0:	2501      	movs	r5, #1
3000d1e2:	fb01 3404 	mla	r4, r1, r4, r3
                    if (uc->OUT_ep[0].is_stall) { //stall
3000d1e6:	fb01 3106 	mla	r1, r1, r6, r3
3000d1ea:	f891 314e 	ldrb.w	r3, [r1, #334]	; 0x14e
    uc->do_resched = true;
3000d1ee:	f884 52b4 	strb.w	r5, [r4, #692]	; 0x2b4
                    if (uc->OUT_ep[0].is_stall) { //stall
3000d1f2:	2b00      	cmp	r3, #0
3000d1f4:	f43f acfe 	beq.w	3000cbf4 <usbc_irq+0x208>
                        uc->OUT_ep[0].is_stall = 0;
3000d1f8:	2400      	movs	r4, #0
                        dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d1fa:	2208      	movs	r2, #8
                        uc->ep0stage = EP0_SETUP_PHASE;
3000d1fc:	f8c1 5290 	str.w	r5, [r1, #656]	; 0x290
                        dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d200:	4630      	mov	r0, r6
                        uc->OUT_ep[0].is_stall = 0;
3000d202:	f881 414e 	strb.w	r4, [r1, #334]	; 0x14e
                        dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d206:	4623      	mov	r3, r4
                        uc->three_stage_setup = false;
3000d208:	f881 4295 	strb.w	r4, [r1, #661]	; 0x295
                        dw_usbc_ep0_recv(instance, uc->Setup, 8, NULL);
3000d20c:	f8d1 12a8 	ldr.w	r1, [r1, #680]	; 0x2a8
3000d210:	f7ff f9f2 	bl	3000c5f8 <dw_usbc_ep0_recv>
3000d214:	f8d8 2008 	ldr.w	r2, [r8, #8]
3000d218:	e480      	b.n	3000cb1c <usbc_irq+0x130>
                                                           trbd->trb->trb2.bufsize);
3000d21a:	f8db 2000 	ldr.w	r2, [r11]
    return orig_size - remain_size;
3000d21e:	f8db 3008 	ldr.w	r3, [r11, #8]
                        ep->xfer_count += count;
3000d222:	69e0      	ldr	r0, [r4, #28]
                                                           trbd->trb->trb2.bufsize);
3000d224:	6895      	ldr	r5, [r2, #8]
                        ep->xfer_buff += count;
3000d226:	6962      	ldr	r2, [r4, #20]
                                                           trbd->trb->trb2.bufsize);
3000d228:	f3c5 0517 	ubfx	r5, r5, #0, #24
    return orig_size - remain_size;
3000d22c:	1b5b      	subs	r3, r3, r5
                        ep->xfer_count += count;
3000d22e:	18c5      	adds	r5, r0, r3
                        if (ep->xfer_len == 0) {
3000d230:	69a0      	ldr	r0, [r4, #24]
                        ep->xfer_buff += count;
3000d232:	4413      	add	r3, r2
                        ep->xfer_count += count;
3000d234:	61e5      	str	r5, [r4, #28]
                        ep->xfer_buff += count;
3000d236:	6163      	str	r3, [r4, #20]
                        if (ep->xfer_len == 0) {
3000d238:	2800      	cmp	r0, #0
3000d23a:	f47f acdb 	bne.w	3000cbf4 <usbc_irq+0x208>
                            uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d23e:	2203      	movs	r2, #3
    if (uc->ep_in[ep->num].transfer) {
3000d240:	eb06 0346 	add.w	r3, r6, r6, lsl #1
                            uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d244:	f8c1 2298 	str.w	r2, [r1, #664]	; 0x298
    if (uc->ep_in[ep->num].transfer) {
3000d248:	eb03 1303 	add.w	r3, r3, r3, lsl #4
                            uc->ep0stage = EP0_STATUS_PHASE;
3000d24c:	f8c1 2290 	str.w	r2, [r1, #656]	; 0x290
    if (uc->ep_in[ep->num].transfer) {
3000d250:	7822      	ldrb	r2, [r4, #0]
3000d252:	eb06 0343 	add.w	r3, r6, r3, lsl #1
3000d256:	4413      	add	r3, r2
3000d258:	9a04      	ldr	r2, [sp, #16]
3000d25a:	3357      	adds	r3, #87	; 0x57
3000d25c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
3000d260:	6859      	ldr	r1, [r3, #4]
3000d262:	2900      	cmp	r1, #0
3000d264:	f43f ae1e 	beq.w	3000cea4 <usbc_irq+0x4b8>
        if (t->callback) {
3000d268:	680a      	ldr	r2, [r1, #0]
        uc->ep_in[ep->num].transfer = 0;
3000d26a:	6058      	str	r0, [r3, #4]
        t->bufpos = ep->xfer_count;
3000d26c:	69e3      	ldr	r3, [r4, #28]
3000d26e:	610b      	str	r3, [r1, #16]
        t->result = 0;
3000d270:	6048      	str	r0, [r1, #4]
        if (t->callback) {
3000d272:	2a00      	cmp	r2, #0
3000d274:	f43f ae16 	beq.w	3000cea4 <usbc_irq+0x4b8>
            t->callback(ep->num, t);
3000d278:	7820      	ldrb	r0, [r4, #0]
3000d27a:	4790      	blx	r2
3000d27c:	e612      	b.n	3000cea4 <usbc_irq+0x4b8>
                ep = uc->ep0_expect_in ? &uc->IN_ep[0] : &uc->OUT_ep[0];
3000d27e:	9a04      	ldr	r2, [sp, #16]
3000d280:	f503 73a6 	add.w	r3, r3, #332	; 0x14c
3000d284:	eb02 0a03 	add.w	r10, r2, r3
3000d288:	e725      	b.n	3000d0d6 <usbc_irq+0x6ea>
        ep = &uc->IN_ep[i];
3000d28a:	980d      	ldr	r0, [sp, #52]	; 0x34
3000d28c:	e583      	b.n	3000cd96 <usbc_irq+0x3aa>
        uc->three_stage_setup = false;
3000d28e:	f885 1295 	strb.w	r1, [r5, #661]	; 0x295
        uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d292:	2303      	movs	r3, #3
        uc->ep0_expect_in = false;
3000d294:	f885 1294 	strb.w	r1, [r5, #660]	; 0x294
        uc->ep0_next_event = DW_EP0_NRDY_STATUS;
3000d298:	f8c5 3298 	str.w	r3, [r5, #664]	; 0x298
3000d29c:	e799      	b.n	3000d1d2 <usbc_irq+0x7e6>
                dw_usbc_ep0_recv(instance, uc->Setup, 0, 0);
3000d29e:	4613      	mov	r3, r2
3000d2a0:	4630      	mov	r0, r6
3000d2a2:	f7ff f9a9 	bl	3000c5f8 <dw_usbc_ep0_recv>
3000d2a6:	e62b      	b.n	3000cf00 <usbc_irq+0x514>

3000d2a8 <usbc_is_highspeed>:

bool usbc_is_highspeed(usb_t *usb)
{
    DW_USB_Context *uc = &g_usbc[usb->priv.instance_id];

    if (uc->speed == 0) {
3000d2a8:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
3000d2ac:	f249 6280 	movw	r2, #38528	; 0x9680
3000d2b0:	f44f 714e 	mov.w	r1, #824	; 0x338
3000d2b4:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000d2b8:	fb01 2303 	mla	r3, r1, r3, r2
3000d2bc:	f8d3 02a4 	ldr.w	r0, [r3, #676]	; 0x2a4
        return true;
    }
    else {
        return false;
    }
}
3000d2c0:	fab0 f080 	clz	r0, r0
3000d2c4:	0940      	lsrs	r0, r0, #5
3000d2c6:	4770      	bx	r14

3000d2c8 <usbc_setup_endpoint>:

status_t usbc_setup_endpoint(usb_t *usb, ep_t ep, ep_dir_t dir, uint width,
                             ep_type_t type)
{
3000d2c8:	b530      	push	{r4, r5, r14}
    return dw_usbc_setup_endpoint(usb->priv.instance_id,  ep,  dir,  width,
3000d2ca:	2400      	movs	r4, #0
{
3000d2cc:	b085      	sub	sp, #20
    return dw_usbc_setup_endpoint(usb->priv.instance_id,  ep,  dir,  width,
3000d2ce:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
3000d2d2:	e9cd 4401 	strd	r4, r4, [r13, #4]
{
3000d2d6:	9d08      	ldr	r5, [sp, #32]
    return dw_usbc_setup_endpoint(usb->priv.instance_id,  ep,  dir,  width,
3000d2d8:	9500      	str	r5, [sp, #0]
3000d2da:	f7ff f855 	bl	3000c388 <dw_usbc_setup_endpoint>
                                  type, false, false);
}
3000d2de:	b005      	add	sp, #20
3000d2e0:	bd30      	pop	{r4, r5, r15}
3000d2e2:	bf00      	nop

3000d2e4 <usbc_ep0_send>:

void usbc_ep0_send(usb_t *usb, const void *buf, size_t len, size_t maxlen)
{
    dw_usbc_ep0_send(usb->priv.instance_id, buf, len, maxlen);
3000d2e4:	f8d0 008c 	ldr.w	r0, [r0, #140]	; 0x8c
3000d2e8:	f7ff b94a 	b.w	3000c580 <dw_usbc_ep0_send>

3000d2ec <dump_registers>:
		printf("0x%x:0x%08x\n",usbregs[i],readl(iobase+usbregs[i]));
}
#else
void dump_registers(vaddr_t iobase,const char *pre)
{
}
3000d2ec:	4770      	bx	r14
3000d2ee:	bf00      	nop

3000d2f0 <dw_usb_dev_ll_por_srst>:
	} while (--retrycount);
	return -ETIMEDOUT;
}

bool dw_usb_dev_ll_por_srst(vaddr_t iobase, vaddr_t phybase)
{
3000d2f0:	b5f0      	push	{r4, r5, r6, r7, r14}
	uint32_t v;
	int ret=0;

	/*config usb phy*/
	v=readl(phybase+U3PHY_NCR_CTRL_0);
3000d2f2:	f501 3780 	add.w	r7, r1, #65536	; 0x10000

	v=readl(phybase+U3PHY_NCR_CTRL_3);
	v |=BIT_U3PHY_NCR_CTRL_3_IDPULLUP0;
	writel(v,phybase+U3PHY_NCR_CTRL_3);
	/*controller NCR*/
	writel(0x1f, iobase+U3DRD_NCR_INTEN);
3000d2f6:	211f      	movs	r1, #31
3000d2f8:	f500 4250 	add.w	r2, r0, #53248	; 0xd000
{
3000d2fc:	4605      	mov	r5, r0
3000d2fe:	b083      	sub	sp, #12
	v=readl(phybase+U3PHY_NCR_CTRL_0);
3000d300:	683b      	ldr	r3, [r7, #0]

	v=readl(phybase+U3PHY_NCR_CTRL_0);
	v |= (BIT_U3PHY_NCR_CTRL_0_PHY_RESET);
	writel(v,phybase+U3PHY_NCR_CTRL_0);

	spin(100);
3000d302:	2064      	movs	r0, #100	; 0x64
	v=readl(phybase+U3PHY_NCR_CTRL_0);
	v &=~(BIT_U3PHY_NCR_CTRL_0_PHY_RESET);
	writel(v,phybase+U3PHY_NCR_CTRL_0);
	/**/
	//do soft reset
	writel(1<<DCTL_CSFTRST_FIELD_OFFSET,iobase+U3DRD_DWC_USB3_DCTL);
3000d304:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
	v &=~(BIT_U3PHY_NCR_CTRL_0_REF_USE_PAD);
3000d308:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
	writel(v,phybase+U3PHY_NCR_CTRL_0);
3000d30c:	603b      	str	r3, [r7, #0]
	v=readl(phybase+U3PHY_NCR_CTRL_3);
3000d30e:	68fb      	ldr	r3, [r7, #12]
	v |=BIT_U3PHY_NCR_CTRL_3_IDPULLUP0;
3000d310:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	writel(v,phybase+U3PHY_NCR_CTRL_3);
3000d314:	60fb      	str	r3, [r7, #12]
	writel(0x1f, iobase+U3DRD_NCR_INTEN);
3000d316:	6011      	str	r1, [r2, #0]
	v=readl(phybase+U3PHY_NCR_CTRL_0);
3000d318:	683b      	ldr	r3, [r7, #0]
	v |= (BIT_U3PHY_NCR_CTRL_0_PHY_RESET);
3000d31a:	f043 0301 	orr.w	r3, r3, #1
	writel(v,phybase+U3PHY_NCR_CTRL_0);
3000d31e:	603b      	str	r3, [r7, #0]
	spin(100);
3000d320:	f006 ff66 	bl	300141f0 <spin>
	v=readl(phybase+U3PHY_NCR_CTRL_0);
3000d324:	683b      	ldr	r3, [r7, #0]
	writel(1<<DCTL_CSFTRST_FIELD_OFFSET,iobase+U3DRD_DWC_USB3_DCTL);
3000d326:	f24c 7204 	movw	r2, #50948	; 0xc704
3000d32a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
	v &=~(BIT_U3PHY_NCR_CTRL_0_PHY_RESET);
3000d32e:	f023 0301 	bic.w	r3, r3, #1
	writel(1<<DCTL_CSFTRST_FIELD_OFFSET,iobase+U3DRD_DWC_USB3_DCTL);
3000d332:	18ae      	adds	r6, r5, r2
	writel(v,phybase+U3PHY_NCR_CTRL_0);
3000d334:	603b      	str	r3, [r7, #0]
	v &=~(BIT_U3PHY_NCR_CTRL_0_PHY_RESET);
3000d336:	9301      	str	r3, [sp, #4]
	writel(1<<DCTL_CSFTRST_FIELD_OFFSET,iobase+U3DRD_DWC_USB3_DCTL);
3000d338:	50a9      	str	r1, [r5, r2]
3000d33a:	e003      	b.n	3000d344 <dw_usb_dev_ll_por_srst+0x54>
		spin(1);
3000d33c:	f006 ff58 	bl	300141f0 <spin>
	} while (--retrycount);
3000d340:	3c01      	subs	r4, #1
3000d342:	d04f      	beq.n	3000d3e4 <dw_usb_dev_ll_por_srst+0xf4>
		v= readl(reg);
3000d344:	6833      	ldr	r3, [r6, #0]
		spin(1);
3000d346:	2001      	movs	r0, #1
		if (((v>>start) & ((1<<width)-1)) == value)
3000d348:	005b      	lsls	r3, r3, #1
3000d34a:	d4f7      	bmi.n	3000d33c <dw_usb_dev_ll_por_srst+0x4c>
	ret=reg_poll_value(iobase+U3DRD_DWC_USB3_DCTL,DCTL_CSFTRST_FIELD_OFFSET,DCTL_CSFTRST_FIELD_SIZE,0,RESET_TIMEOUT);
	if (ret)
		return false;
	/*gsbuscfg0,1*/
	/*gtxthrcfg,grxthrcfg*/
	v=readl(iobase+U3DRD_DWC_USB3_GRXTHRCFG);
3000d34c:	f24c 120c 	movw	r2, #49420	; 0xc10c
	/*gsnpsid*/
	//v=readl(iobase+U3DRD_DWC_USB3_GSNPSID);
	//printf("usb controller version 0x%x\n",v);
	/*guid. optional*/
	/*gusb2phycfg*/
	v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d350:	f505 4042 	add.w	r0, r5, #49664	; 0xc200
	RMWREG32(&v,GUSB2PHYCFG_ULPIAUTORES_FIELD_OFFSET,GUSB2PHYCFG_ULPIAUTORES_FIELD_SIZE,GUSB2PHYCFG_ULPIAUTORES); //disable ulpiautoresume
	RMWREG32(&v,GUSB2PHYCFG_PHYIF_FIELD_OFFSET,GUSB2PHYCFG_PHYIF_FIELD_SIZE,GUSB2PHYCFG_PHYIF); //PHYIF 16bit
	RMWREG32(&v,GUSB2PHYCFG_USBTRDTIM_FIELD_OFFSET,GUSB2PHYCFG_USBTRDTIM_FIELD_SIZE,GUSB2PHYCFG_USBTRDTIM); //UTMI 16bit
	writel(v, iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
	/*gusb3pipectl*/
	v=readl(iobase + U3DRD_DWC_USB3_GUSB3PIPECTL);
3000d354:	f24c 26c0 	movw	r6, #49856	; 0xc2c0
	/*grxfifosiz0*/
	/*gevntadrn*/
	/*gevntsizn*/
	/*gevntcountn*/
	/*gctl*/
	v=readl(iobase+U3DRD_DWC_USB3_GCTL);
3000d358:	f24c 1410 	movw	r4, #49424	; 0xc110
	RMWREG32(&v, GCTL_DSBLCLKGTNG_FIELD_OFFSET, GCTL_DSBLCLKGTNG_FIELD_SIZE, 0);//remove clk gating
	RMWREG32(&v, GCTL_DISSCRAMBLE_FIELD_OFFSET, GCTL_DISSCRAMBLE_FIELD_SIZE, 0);//DW_GCTL_DISSCRAMBLE;
	RMWREG32(&v,GCTL_PRTCAPDIR_FIELD_OFFSET,GCTL_PRTCAPDIR_FIELD_SIZE,GCTL_PRTCAPDIR);//dev MODE
	writel(v, iobase+U3DRD_DWC_USB3_GCTL);
	/*dcfg*/
	v=readl(iobase+U3DRD_DWC_USB3_DCFG);
3000d35c:	f505 4147 	add.w	r1, r5, #50944	; 0xc700
	v=readl(iobase+U3DRD_DWC_USB3_GRXTHRCFG);
3000d360:	58ab      	ldr	r3, [r5, r2]
	v &= ~(1 << GRXTHRCFG_USBRXPKTCNTSEL_FIELD_OFFSET);
3000d362:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
	writel(v, iobase+U3DRD_DWC_USB3_GRXTHRCFG);
3000d366:	50ab      	str	r3, [r5, r2]
	RMWREG32(&v,DCFG_DEVSPD_FIELD_OFFSET,DCFG_DEVSPD_FIELD_SIZE,DCFG_DEVSPD);//despd,hs
	//RMWREG32(&v,17,5,9);//nump
	writel(v, iobase+U3DRD_DWC_USB3_DCFG);
	/*guctl2*/
	v = readl(iobase+U3DRD_DWC_USB3_GUCTL2);
3000d368:	f24c 129c 	movw	r2, #49564	; 0xc19c
	v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d36c:	6803      	ldr	r3, [r0, #0]
3000d36e:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,GUSB2PHYCFG_PHYSEL_FIELD_OFFSET,GUSB2PHYCFG_PHYSEL_FIELD_SIZE,GUSB2PHYCFG_PHYSEL);//hs
3000d370:	9b01      	ldr	r3, [sp, #4]
3000d372:	f023 0380 	bic.w	r3, r3, #128	; 0x80
3000d376:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,GUSB2PHYCFG_ULPIAUTORES_FIELD_OFFSET,GUSB2PHYCFG_ULPIAUTORES_FIELD_SIZE,GUSB2PHYCFG_ULPIAUTORES); //disable ulpiautoresume
3000d378:	9b01      	ldr	r3, [sp, #4]
3000d37a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
3000d37e:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,GUSB2PHYCFG_PHYIF_FIELD_OFFSET,GUSB2PHYCFG_PHYIF_FIELD_SIZE,GUSB2PHYCFG_PHYIF); //PHYIF 16bit
3000d380:	9b01      	ldr	r3, [sp, #4]
3000d382:	f043 0308 	orr.w	r3, r3, #8
3000d386:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,GUSB2PHYCFG_USBTRDTIM_FIELD_OFFSET,GUSB2PHYCFG_USBTRDTIM_FIELD_SIZE,GUSB2PHYCFG_USBTRDTIM); //UTMI 16bit
3000d388:	9b01      	ldr	r3, [sp, #4]
3000d38a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
3000d38e:	f443 53a0 	orr.w	r3, r3, #5120	; 0x1400
3000d392:	9301      	str	r3, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d394:	6003      	str	r3, [r0, #0]
	v |=     (1 << GUCTL2_RST_ACTBITLATER_FIELD_OFFSET);
	writel(v,iobase+U3DRD_DWC_USB3_GUCTL2);
	/*dctl,runstop*/

	return true;
3000d396:	2001      	movs	r0, #1
	v=readl(iobase + U3DRD_DWC_USB3_GUSB3PIPECTL);
3000d398:	59ab      	ldr	r3, [r5, r6]
	v |= 1<<GUSB3PIPECTL_SUSPENDENABLE_FIELD_OFFSET;
3000d39a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	writel(v, iobase+U3DRD_DWC_USB3_GUSB3PIPECTL);
3000d39e:	51ab      	str	r3, [r5, r6]
	v=readl(iobase+U3DRD_DWC_USB3_GCTL);
3000d3a0:	592b      	ldr	r3, [r5, r4]
3000d3a2:	9301      	str	r3, [sp, #4]
	RMWREG32(&v, GCTL_SCALEDOWN_FIELD_OFFSET, GCTL_SCALEDOWN_FIELD_SIZE, 0);//remove scale down
3000d3a4:	9b01      	ldr	r3, [sp, #4]
3000d3a6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
3000d3aa:	9301      	str	r3, [sp, #4]
	RMWREG32(&v, GCTL_DSBLCLKGTNG_FIELD_OFFSET, GCTL_DSBLCLKGTNG_FIELD_SIZE, 0);//remove clk gating
3000d3ac:	9b01      	ldr	r3, [sp, #4]
3000d3ae:	f023 0301 	bic.w	r3, r3, #1
3000d3b2:	9301      	str	r3, [sp, #4]
	RMWREG32(&v, GCTL_DISSCRAMBLE_FIELD_OFFSET, GCTL_DISSCRAMBLE_FIELD_SIZE, 0);//DW_GCTL_DISSCRAMBLE;
3000d3b4:	9b01      	ldr	r3, [sp, #4]
3000d3b6:	f023 0308 	bic.w	r3, r3, #8
3000d3ba:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,GCTL_PRTCAPDIR_FIELD_OFFSET,GCTL_PRTCAPDIR_FIELD_SIZE,GCTL_PRTCAPDIR);//dev MODE
3000d3bc:	9b01      	ldr	r3, [sp, #4]
3000d3be:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
3000d3c2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
3000d3c6:	9301      	str	r3, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_GCTL);
3000d3c8:	512b      	str	r3, [r5, r4]
	v=readl(iobase+U3DRD_DWC_USB3_DCFG);
3000d3ca:	680b      	ldr	r3, [r1, #0]
3000d3cc:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,DCFG_DEVSPD_FIELD_OFFSET,DCFG_DEVSPD_FIELD_SIZE,DCFG_DEVSPD);//despd,hs
3000d3ce:	9b01      	ldr	r3, [sp, #4]
3000d3d0:	f023 0307 	bic.w	r3, r3, #7
3000d3d4:	9301      	str	r3, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_DCFG);
3000d3d6:	600b      	str	r3, [r1, #0]
	v = readl(iobase+U3DRD_DWC_USB3_GUCTL2);
3000d3d8:	58ab      	ldr	r3, [r5, r2]
	v |=     (1 << GUCTL2_RST_ACTBITLATER_FIELD_OFFSET);
3000d3da:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
	writel(v,iobase+U3DRD_DWC_USB3_GUCTL2);
3000d3de:	50ab      	str	r3, [r5, r2]
}
3000d3e0:	b003      	add	sp, #12
3000d3e2:	bdf0      	pop	{r4, r5, r6, r7, r15}
		return false;
3000d3e4:	4620      	mov	r0, r4
}
3000d3e6:	b003      	add	sp, #12
3000d3e8:	bdf0      	pop	{r4, r5, r6, r7, r15}
3000d3ea:	bf00      	nop

3000d3ec <dw_usb_ll_enable_irq>:

void dw_usb_ll_enable_irq(vaddr_t iobase)
{
	uint32_t v;
	/*devten*/
	v=0;
3000d3ec:	2300      	movs	r3, #0
{
3000d3ee:	b082      	sub	sp, #8
	RMWREG32(&v,DEVTEN_ULSTCNGEN_FIELD_OFFSET,DEVTEN_ULSTCNGEN_FIELD_SIZE,1);//usb link state change
	RMWREG32(&v,DEVTEN_CONNECTDONEEVTEN_FIELD_OFFSET,DEVTEN_CONNECTDONEEVTEN_FIELD_SIZE,1);//connect done
	RMWREG32(&v,DEVTEN_USBRSTEVTEN_FIELD_OFFSET,DEVTEN_USBRSTEVTEN_FIELD_SIZE,1);//usb reset
	RMWREG32(&v,DEVTEN_DISSCONNEVTEN_FIELD_OFFSET,DEVTEN_DISSCONNEVTEN_FIELD_SIZE,1);//usb disconnect
	writel(v, iobase+U3DRD_DWC_USB3_DEVTEN);
3000d3f0:	f24c 7208 	movw	r2, #50952	; 0xc708
	v=0;
3000d3f4:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,DEVTEN_ULSTCNGEN_FIELD_OFFSET,DEVTEN_ULSTCNGEN_FIELD_SIZE,1);//usb link state change
3000d3f6:	9b01      	ldr	r3, [sp, #4]
3000d3f8:	f043 0308 	orr.w	r3, r3, #8
3000d3fc:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,DEVTEN_CONNECTDONEEVTEN_FIELD_OFFSET,DEVTEN_CONNECTDONEEVTEN_FIELD_SIZE,1);//connect done
3000d3fe:	9b01      	ldr	r3, [sp, #4]
3000d400:	f043 0304 	orr.w	r3, r3, #4
3000d404:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,DEVTEN_USBRSTEVTEN_FIELD_OFFSET,DEVTEN_USBRSTEVTEN_FIELD_SIZE,1);//usb reset
3000d406:	9b01      	ldr	r3, [sp, #4]
3000d408:	f043 0302 	orr.w	r3, r3, #2
3000d40c:	9301      	str	r3, [sp, #4]
	RMWREG32(&v,DEVTEN_DISSCONNEVTEN_FIELD_OFFSET,DEVTEN_DISSCONNEVTEN_FIELD_SIZE,1);//usb disconnect
3000d40e:	9b01      	ldr	r3, [sp, #4]
3000d410:	f043 0301 	orr.w	r3, r3, #1
3000d414:	9301      	str	r3, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_DEVTEN);
3000d416:	5083      	str	r3, [r0, r2]
}
3000d418:	b002      	add	sp, #8
3000d41a:	4770      	bx	r14

3000d41c <dw_usb_ll_mask_irq>:
	writel(0, iobase+U3DRD_DWC_USB3_DEVTEN);
}

void dw_usb_ll_mask_irq(vaddr_t iobase)
{
	RMWREG32(iobase+U3DRD_DWC_USB3_GEVNTSIZ, GEVNTSIZ_EVNTINTRPTMASK_FIELD_OFFSET,GEVNTSIZ_EVNTINTRPTMASK_FIELD_SIZE,1);
3000d41c:	f24c 4208 	movw	r2, #50184	; 0xc408
3000d420:	5883      	ldr	r3, [r0, r2]
3000d422:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
3000d426:	5083      	str	r3, [r0, r2]
}
3000d428:	4770      	bx	r14
3000d42a:	bf00      	nop

3000d42c <dw_usb_ll_unmask_irq>:

void dw_usb_ll_unmask_irq(vaddr_t iobase)
{
	RMWREG32(iobase+U3DRD_DWC_USB3_GEVNTSIZ, GEVNTSIZ_EVNTINTRPTMASK_FIELD_OFFSET,GEVNTSIZ_EVNTINTRPTMASK_FIELD_SIZE,0);
3000d42c:	f24c 4208 	movw	r2, #50184	; 0xc408
3000d430:	5883      	ldr	r3, [r0, r2]
3000d432:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
3000d436:	5083      	str	r3, [r0, r2]
}
3000d438:	4770      	bx	r14
3000d43a:	bf00      	nop

3000d43c <dw_usb_ll_runstop>:

bool dw_usb_ll_runstop(vaddr_t iobase, bool enable)
{
3000d43c:	b570      	push	{r4, r5, r6, r14}
	uint32_t reg,timeout=500;

	RMWREG32(iobase+U3DRD_DWC_USB3_DCTL,DCTL_RUN_STOP_FIELD_OFFSET,DCTL_RUN_STOP_FIELD_SIZE,enable);
3000d43e:	f24c 7404 	movw	r4, #50948	; 0xc704
	do {
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d442:	f24c 760c 	movw	r6, #50956	; 0xc70c
3000d446:	f081 0201 	eor.w	r2, r1, #1
3000d44a:	1985      	adds	r5, r0, r6
	RMWREG32(iobase+U3DRD_DWC_USB3_DCTL,DCTL_RUN_STOP_FIELD_OFFSET,DCTL_RUN_STOP_FIELD_SIZE,enable);
3000d44c:	5903      	ldr	r3, [r0, r4]
3000d44e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
3000d452:	ea43 71c1 	orr.w	r1, r3, r1, lsl #31
3000d456:	5101      	str	r1, [r0, r4]
		reg &= (1<<DSTS_DEVCTRLHLT_FIELD_OFFSET);
3000d458:	f240 14f3 	movw	r4, #499	; 0x1f3
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d45c:	5983      	ldr	r3, [r0, r6]
		reg &= (1<<DSTS_DEVCTRLHLT_FIELD_OFFSET);
3000d45e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
3000d462:	e004      	b.n	3000d46e <dw_usb_ll_runstop+0x32>
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d464:	682b      	ldr	r3, [r5, #0]
	} while (--timeout && !(!enable ^ !reg));
3000d466:	3c01      	subs	r4, #1
		reg &= (1<<DSTS_DEVCTRLHLT_FIELD_OFFSET);
3000d468:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
	} while (--timeout && !(!enable ^ !reg));
3000d46c:	d006      	beq.n	3000d47c <dw_usb_ll_runstop+0x40>
3000d46e:	fab3 f383 	clz	r3, r3
3000d472:	095b      	lsrs	r3, r3, #5
3000d474:	4293      	cmp	r3, r2
3000d476:	d0f5      	beq.n	3000d464 <dw_usb_ll_runstop+0x28>

	if (!timeout) {
		printf("start timeout\n");
		return false;
	}
	return true;
3000d478:	2001      	movs	r0, #1
}
3000d47a:	bd70      	pop	{r4, r5, r6, r15}
		printf("start timeout\n");
3000d47c:	f64e 3020 	movw	r0, #60192	; 0xeb20
3000d480:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d484:	f008 fb94 	bl	30015bb0 <_printf>
		return false;
3000d488:	4620      	mov	r0, r4
}
3000d48a:	bd70      	pop	{r4, r5, r6, r15}

3000d48c <dw_usb_ll_set_ep_cmd>:

bool dw_usb_ll_set_ep_cmd(vaddr_t iobase, int cmdnum, int p_epnum,uint32_t cmdvalue,uint32_t param0,uint32_t param1, uint32_t param2)
{
3000d48c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000d490:	4693      	mov	r11, r2
	uint32_t v,saved_config=0;
	int ret;
	/*set gusb2phycfg 6,8 to 0*/
	v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d492:	f500 4842 	add.w	r8, r0, #49664	; 0xc200
{
3000d496:	4689      	mov	r9, r1
3000d498:	b083      	sub	sp, #12
	v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d49a:	f8d8 2000 	ldr.w	r2, [r8]
{
3000d49e:	9d0c      	ldr	r5, [sp, #48]	; 0x30
3000d4a0:	e9dd 410d 	ldrd	r4, r1, [r13, #52]	; 0x34
	if (v & (1<<GUSB2PHYCFG_SUSPENDUSB20_FIELD_OFFSET)) {
3000d4a4:	0656      	lsls	r6, r2, #25
3000d4a6:	d437      	bmi.n	3000d518 <dw_usb_ll_set_ep_cmd+0x8c>
		saved_config |= 1<<GUSB2PHYCFG_SUSPENDUSB20_FIELD_OFFSET;
		v &= ~(1<<GUSB2PHYCFG_SUSPENDUSB20_FIELD_OFFSET);
	}

	if (v & (1<<GUSB2PHYCFG_ENBLSLPM_FIELD_OFFSET)) {
3000d4a8:	f412 7a80 	ands.w	r10, r2, #256	; 0x100
3000d4ac:	d15c      	bne.n	3000d568 <dw_usb_ll_set_ep_cmd+0xdc>

	writel(param0, iobase+U3DRD_DWC_USB3_DEPCMDPAR0+p_epnum*0x10);
	writel(param1, iobase+U3DRD_DWC_USB3_DEPCMDPAR1+p_epnum*0x10);
	writel(param2, iobase+U3DRD_DWC_USB3_DEPCMDPAR2+p_epnum*0x10);

	v=cmdvalue;
3000d4ae:	9301      	str	r3, [sp, #4]
	writel(param0, iobase+U3DRD_DWC_USB3_DEPCMDPAR0+p_epnum*0x10);
3000d4b0:	eb00 160b 	add.w	r6, r0, r11, lsl #4
	writel(param1, iobase+U3DRD_DWC_USB3_DEPCMDPAR1+p_epnum*0x10);
3000d4b4:	f64c 0204 	movw	r2, #51204	; 0xc804
	writel(param2, iobase+U3DRD_DWC_USB3_DEPCMDPAR2+p_epnum*0x10);
3000d4b8:	f506 4348 	add.w	r3, r6, #51200	; 0xc800
	writel(param0, iobase+U3DRD_DWC_USB3_DEPCMDPAR0+p_epnum*0x10);
3000d4bc:	f64c 0008 	movw	r0, #51208	; 0xc808
	RMWREG32(&v, DEPCMD_CMDTYP_FIELD_OFFSET, DEPCMD_CMDTYP_FIELD_SIZE, cmdnum);// set cmdtype
	if (cmdnum != 7) //update
3000d4c0:	f1b9 0f07 	cmp.w	r9, #7
		RMWREG32(&v, DEPCMD_CMDACT_FIELD_OFFSET, DEPCMD_CMDACT_FIELD_SIZE, 1);// set cmdact
	writel(v, iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d4c4:	f64c 070c 	movw	r7, #51212	; 0xc80c
	writel(param0, iobase+U3DRD_DWC_USB3_DEPCMDPAR0+p_epnum*0x10);
3000d4c8:	5035      	str	r5, [r6, r0]
	writel(v, iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d4ca:	eb06 0507 	add.w	r5, r6, r7
	writel(param1, iobase+U3DRD_DWC_USB3_DEPCMDPAR1+p_epnum*0x10);
3000d4ce:	50b4      	str	r4, [r6, r2]
	writel(v, iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d4d0:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
	writel(param2, iobase+U3DRD_DWC_USB3_DEPCMDPAR2+p_epnum*0x10);
3000d4d4:	6019      	str	r1, [r3, #0]
	RMWREG32(&v, DEPCMD_CMDTYP_FIELD_OFFSET, DEPCMD_CMDTYP_FIELD_SIZE, cmdnum);// set cmdtype
3000d4d6:	9b01      	ldr	r3, [sp, #4]
3000d4d8:	f023 030f 	bic.w	r3, r3, #15
3000d4dc:	ea43 0309 	orr.w	r3, r3, r9
3000d4e0:	9301      	str	r3, [sp, #4]
		RMWREG32(&v, DEPCMD_CMDACT_FIELD_OFFSET, DEPCMD_CMDACT_FIELD_SIZE, 1);// set cmdact
3000d4e2:	bf1e      	ittt	ne
3000d4e4:	9b01      	ldrne	r3, [sp, #4]
3000d4e6:	f443 6380 	orrne.w	r3, r3, #1024	; 0x400
3000d4ea:	9301      	strne	r3, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d4ec:	51f3      	str	r3, [r6, r7]
3000d4ee:	e003      	b.n	3000d4f8 <dw_usb_ll_set_ep_cmd+0x6c>
		spin(1);
3000d4f0:	f006 fe7e 	bl	300141f0 <spin>
	} while (--retrycount);
3000d4f4:	3c01      	subs	r4, #1
3000d4f6:	d01b      	beq.n	3000d530 <dw_usb_ll_set_ep_cmd+0xa4>
		v= readl(reg);
3000d4f8:	682b      	ldr	r3, [r5, #0]
		spin(1);
3000d4fa:	2001      	movs	r0, #1
		if (((v>>start) & ((1<<width)-1)) == value)
3000d4fc:	055b      	lsls	r3, r3, #21
3000d4fe:	d4f7      	bmi.n	3000d4f0 <dw_usb_ll_set_ep_cmd+0x64>
	ret=reg_poll_value(iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10,DEPCMD_CMDACT_FIELD_OFFSET,DEPCMD_CMDACT_FIELD_SIZE,0,CMDACT_TIMEOUT);
	if (!ret) {
		v= readl(iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d500:	59f3      	ldr	r3, [r6, r7]
3000d502:	9301      	str	r3, [sp, #4]
		ret=DW_GET_CMD_STATUS(v);
	}

	/*set gusb2phycfg 6,8 to 1*/
	if (saved_config) {
3000d504:	f1ba 0f00 	cmp.w	r10, #0
3000d508:	d123      	bne.n	3000d552 <dw_usb_ll_set_ep_cmd+0xc6>
	}
	if (ret != 0) {
		printf("ep %d cmd %d status %d\n",p_epnum,cmdnum,ret);
		return false;
	}
	return true;
3000d50a:	2001      	movs	r0, #1
		ret=DW_GET_CMD_STATUS(v);
3000d50c:	f3c3 3303 	ubfx	r3, r3, #12, #4
	if (ret != 0) {
3000d510:	b99b      	cbnz	r3, 3000d53a <dw_usb_ll_set_ep_cmd+0xae>
}
3000d512:	b003      	add	sp, #12
3000d514:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
		v &= ~(1<<GUSB2PHYCFG_SUSPENDUSB20_FIELD_OFFSET);
3000d518:	f022 0640 	bic.w	r6, r2, #64	; 0x40
	if (v & (1<<GUSB2PHYCFG_ENBLSLPM_FIELD_OFFSET)) {
3000d51c:	05d2      	lsls	r2, r2, #23
3000d51e:	bf48      	it	mi
3000d520:	f44f 7aa0 	movmi.w	r10, #320	; 0x140
3000d524:	d51d      	bpl.n	3000d562 <dw_usb_ll_set_ep_cmd+0xd6>
		v &= ~(1<<GUSB2PHYCFG_ENBLSLPM_FIELD_OFFSET);
3000d526:	f426 7680 	bic.w	r6, r6, #256	; 0x100
		writel(v, iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d52a:	f8c8 6000 	str.w	r6, [r8]
3000d52e:	e7be      	b.n	3000d4ae <dw_usb_ll_set_ep_cmd+0x22>
	return -ETIMEDOUT;
3000d530:	f06f 0373 	mvn.w	r3, #115	; 0x73
	if (saved_config) {
3000d534:	f1ba 0f00 	cmp.w	r10, #0
3000d538:	d11a      	bne.n	3000d570 <dw_usb_ll_set_ep_cmd+0xe4>
		printf("ep %d cmd %d status %d\n",p_epnum,cmdnum,ret);
3000d53a:	f64e 3030 	movw	r0, #60208	; 0xeb30
3000d53e:	464a      	mov	r2, r9
3000d540:	4659      	mov	r1, r11
3000d542:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d546:	f008 fb33 	bl	30015bb0 <_printf>
		return false;
3000d54a:	2000      	movs	r0, #0
}
3000d54c:	b003      	add	sp, #12
3000d54e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
		v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d552:	f8d8 2000 	ldr.w	r2, [r8]
		v |= saved_config;
3000d556:	ea42 020a 	orr.w	r2, r2, r10
3000d55a:	9201      	str	r2, [sp, #4]
		writel(v, iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d55c:	f8c8 2000 	str.w	r2, [r8]
3000d560:	e7d3      	b.n	3000d50a <dw_usb_ll_set_ep_cmd+0x7e>
		saved_config |= 1<<GUSB2PHYCFG_SUSPENDUSB20_FIELD_OFFSET;
3000d562:	f04f 0a40 	mov.w	r10, #64	; 0x40
3000d566:	e7e0      	b.n	3000d52a <dw_usb_ll_set_ep_cmd+0x9e>
	if (v & (1<<GUSB2PHYCFG_ENBLSLPM_FIELD_OFFSET)) {
3000d568:	4616      	mov	r6, r2
3000d56a:	f44f 7a80 	mov.w	r10, #256	; 0x100
3000d56e:	e7da      	b.n	3000d526 <dw_usb_ll_set_ep_cmd+0x9a>
		v=readl(iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d570:	f8d8 2000 	ldr.w	r2, [r8]
	return -ETIMEDOUT;
3000d574:	f06f 0373 	mvn.w	r3, #115	; 0x73
		v |= saved_config;
3000d578:	ea4a 0202 	orr.w	r2, r10, r2
		writel(v, iobase+U3DRD_DWC_USB3_GUSB2PHYCFG);
3000d57c:	f8c8 2000 	str.w	r2, [r8]
3000d580:	e7db      	b.n	3000d53a <dw_usb_ll_set_ep_cmd+0xae>
3000d582:	bf00      	nop

3000d584 <dw_usb_ll_set_ep_config>:

bool dw_usb_ll_set_ep_config(vaddr_t iobase, int p_epnum, uint32_t param0,uint32_t param1, uint32_t param2)
{
3000d584:	b510      	push	{r4, r14}
3000d586:	b084      	sub	sp, #16
	/*depcmd*/
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_CONFIG,p_epnum,0,param0,param1,param2);
3000d588:	9200      	str	r2, [sp, #0]
3000d58a:	460a      	mov	r2, r1
{
3000d58c:	9c06      	ldr	r4, [sp, #24]
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_CONFIG,p_epnum,0,param0,param1,param2);
3000d58e:	2101      	movs	r1, #1
3000d590:	9301      	str	r3, [sp, #4]
3000d592:	2300      	movs	r3, #0
3000d594:	9402      	str	r4, [sp, #8]
3000d596:	f7ff ff79 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d59a:	b004      	add	sp, #16
3000d59c:	bd10      	pop	{r4, r15}
3000d59e:	bf00      	nop

3000d5a0 <dw_usb_ll_set_ep_xfer_config>:

bool dw_usb_ll_set_ep_xfer_config(vaddr_t iobase, int p_epnum, uint32_t param0)
{
3000d5a0:	b510      	push	{r4, r14}
	/*depcmd*/
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_XFER,p_epnum,0,param0,0,0);
3000d5a2:	2400      	movs	r4, #0
{
3000d5a4:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_XFER,p_epnum,0,param0,0,0);
3000d5a6:	4623      	mov	r3, r4
3000d5a8:	9200      	str	r2, [sp, #0]
3000d5aa:	460a      	mov	r2, r1
3000d5ac:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d5b0:	2102      	movs	r1, #2
3000d5b2:	f7ff ff6b 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d5b6:	b004      	add	sp, #16
3000d5b8:	bd10      	pop	{r4, r15}
3000d5ba:	bf00      	nop

3000d5bc <dw_usb_ll_get_ep_transfer_index>:

u32 dw_usb_ll_get_ep_transfer_index(vaddr_t iobase, int p_epnum)
{
	u32         res_id,v;

	v=readl(iobase+U3DRD_DWC_USB3_DEPCMD+p_epnum*0x10);
3000d5bc:	f500 4048 	add.w	r0, r0, #51200	; 0xc800
3000d5c0:	0109      	lsls	r1, r1, #4
3000d5c2:	300c      	adds	r0, #12
3000d5c4:	5808      	ldr	r0, [r1, r0]
	res_id =DW_GET_XFER_RES_ID(v);
	return res_id;
}
3000d5c6:	f3c0 4006 	ubfx	r0, r0, #16, #7
3000d5ca:	4770      	bx	r14

3000d5cc <dw_usb_ll_set_link_state>:

int dw_usb_ll_set_link_state(vaddr_t iobase, enum dw_link_state state)
{
3000d5cc:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
	int     retries = 10000;
	u32     reg;

	while (--retries) {
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d5ce:	f24c 730c 	movw	r3, #50956	; 0xc70c
{
3000d5d2:	4607      	mov	r7, r0
3000d5d4:	460e      	mov	r6, r1
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d5d6:	18c5      	adds	r5, r0, r3
3000d5d8:	58c3      	ldr	r3, [r0, r3]
		if (reg & DW_DSTS_DCNRD)
3000d5da:	009a      	lsls	r2, r3, #2
3000d5dc:	d50d      	bpl.n	3000d5fa <dw_usb_ll_set_link_state+0x2e>
			spin(5);
3000d5de:	2005      	movs	r0, #5
3000d5e0:	f242 740e 	movw	r4, #9998	; 0x270e
3000d5e4:	f006 fe04 	bl	300141f0 <spin>
3000d5e8:	e003      	b.n	3000d5f2 <dw_usb_ll_set_link_state+0x26>
3000d5ea:	f006 fe01 	bl	300141f0 <spin>
	while (--retries) {
3000d5ee:	3c01      	subs	r4, #1
3000d5f0:	d00f      	beq.n	3000d612 <dw_usb_ll_set_link_state+0x46>
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d5f2:	682b      	ldr	r3, [r5, #0]
			spin(5);
3000d5f4:	2005      	movs	r0, #5
		if (reg & DW_DSTS_DCNRD)
3000d5f6:	009b      	lsls	r3, r3, #2
3000d5f8:	d4f7      	bmi.n	3000d5ea <dw_usb_ll_set_link_state+0x1e>
	}

	if (retries <= 0)
		return -1;

	reg = readl(iobase+U3DRD_DWC_USB3_DCTL);
3000d5fa:	f24c 7204 	movw	r2, #50948	; 0xc704
	reg &= ~DW_DCTL_ULSTCHNGREQ_MASK;

	/* set requested state */
	reg |= DW_DCTL_ULSTCHNGREQ(state);
3000d5fe:	0176      	lsls	r6, r6, #5
	writel(reg, iobase+U3DRD_DWC_USB3_DCTL);
	return 0;
3000d600:	2000      	movs	r0, #0
	reg |= DW_DCTL_ULSTCHNGREQ(state);
3000d602:	f406 76f0 	and.w	r6, r6, #480	; 0x1e0
	reg = readl(iobase+U3DRD_DWC_USB3_DCTL);
3000d606:	58bb      	ldr	r3, [r7, r2]
	reg &= ~DW_DCTL_ULSTCHNGREQ_MASK;
3000d608:	f423 73f0 	bic.w	r3, r3, #480	; 0x1e0
	reg |= DW_DCTL_ULSTCHNGREQ(state);
3000d60c:	431e      	orrs	r6, r3
	writel(reg, iobase+U3DRD_DWC_USB3_DCTL);
3000d60e:	50be      	str	r6, [r7, r2]
}
3000d610:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
		return -1;
3000d612:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000d616:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

3000d618 <dw_usb_ll_disconnect_evt>:

int dw_usb_ll_disconnect_evt(vaddr_t iobase)
{
3000d618:	4601      	mov	r1, r0
	u32 reg = 0;
	reg = readl(iobase + U3DRD_DWC_USB3_DCTL);
3000d61a:	f24c 7204 	movw	r2, #50948	; 0xc704
{
3000d61e:	b410      	push	{r4}
	reg = readl(iobase + U3DRD_DWC_USB3_DCTL);
3000d620:	588b      	ldr	r3, [r1, r2]
	writel(reg, iobase + U3DRD_DWC_USB3_DCTL);

	reg &= ~BIT_U3DRD_DWC_USB3_DCTL_INITU2ENA;
	writel(reg, iobase + U3DRD_DWC_USB3_DCTL);
	return 0;
}
3000d622:	2000      	movs	r0, #0
	reg &= ~BIT_U3DRD_DWC_USB3_DCTL_INITU1ENA;
3000d624:	f423 6480 	bic.w	r4, r3, #1024	; 0x400
	reg &= ~BIT_U3DRD_DWC_USB3_DCTL_INITU2ENA;
3000d628:	f423 53a0 	bic.w	r3, r3, #5120	; 0x1400
	writel(reg, iobase + U3DRD_DWC_USB3_DCTL);
3000d62c:	508c      	str	r4, [r1, r2]
	writel(reg, iobase + U3DRD_DWC_USB3_DCTL);
3000d62e:	508b      	str	r3, [r1, r2]
}
3000d630:	f85d 4b04 	ldr.w	r4, [r13], #4
3000d634:	4770      	bx	r14
3000d636:	bf00      	nop

3000d638 <dw_usb_ll_wakeup>:

int dw_usb_ll_wakeup(vaddr_t iobase)
{
3000d638:	b538      	push	{r3, r4, r5, r14}
	int         ret;
	u32         reg;
	u8          link_state;
	u8          speed;

	reg = readl(iobase + U3DRD_DWC_USB3_DSTS);
3000d63a:	f24c 730c 	movw	r3, #50956	; 0xc70c
3000d63e:	18c4      	adds	r4, r0, r3
3000d640:	58c1      	ldr	r1, [r0, r3]

	speed = DW_GET_CONNDONE_SPEED(reg);
3000d642:	f001 0307 	and.w	r3, r1, #7
	if ((speed == USB_SPEED_SS) ||
3000d646:	3b04      	subs	r3, #4
3000d648:	2b01      	cmp	r3, #1
3000d64a:	d914      	bls.n	3000d676 <dw_usb_ll_wakeup+0x3e>
	        (speed == USB_SPEED_SSPLUS)) {
		return 0;
	}

	link_state = DW_DSTS_USBLNKST(reg);
3000d64c:	f3c1 4183 	ubfx	r1, r1, #18, #4

	switch (link_state) {
3000d650:	2903      	cmp	r1, #3
3000d652:	d001      	beq.n	3000d658 <dw_usb_ll_wakeup+0x20>
3000d654:	2905      	cmp	r1, #5
3000d656:	d119      	bne.n	3000d68c <dw_usb_ll_wakeup+0x54>
			    "can't wakeup from %d",
			    link_state);
			return -1;
	}

	ret = dw_usb_ll_set_link_state(iobase, DW_LINK_STATE_RECOV);
3000d658:	2108      	movs	r1, #8
3000d65a:	f7ff ffb7 	bl	3000d5cc <dw_usb_ll_set_link_state>
	if (ret < 0) {
3000d65e:	1e05      	subs	r5, r0, #0
3000d660:	bfa8      	it	ge
3000d662:	f644 6320 	movwge	r3, #20000	; 0x4e20
3000d666:	da02      	bge.n	3000d66e <dw_usb_ll_wakeup+0x36>
3000d668:	e008      	b.n	3000d67c <dw_usb_ll_wakeup+0x44>
	}

	/* poll until Link State changes to ON */
	retries = 20000;

	while (retries--) {
3000d66a:	3b01      	subs	r3, #1
3000d66c:	d017      	beq.n	3000d69e <dw_usb_ll_wakeup+0x66>
		reg = readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d66e:	6822      	ldr	r2, [r4, #0]

		/* in HS, means ON */
		if (DW_DSTS_USBLNKST(reg) == DW_LINK_STATE_U0)
3000d670:	f412 1f70 	tst.w	r2, #3932160	; 0x3c0000
3000d674:	d1f9      	bne.n	3000d66a <dw_usb_ll_wakeup+0x32>
		return 0;
3000d676:	2500      	movs	r5, #0
	if (DW_DSTS_USBLNKST(reg) != DW_LINK_STATE_U0) {
		printf("failed to send remote wakeup\n");
		return -1;
	}
	return 0;
}
3000d678:	4628      	mov	r0, r5
3000d67a:	bd38      	pop	{r3, r4, r5, r15}
		printf("failed to put link in Recovery\n");
3000d67c:	f64e 3060 	movw	r0, #60256	; 0xeb60
3000d680:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d684:	f008 fa94 	bl	30015bb0 <_printf>
}
3000d688:	4628      	mov	r0, r5
3000d68a:	bd38      	pop	{r3, r4, r5, r15}
			printf(
3000d68c:	f64e 3048 	movw	r0, #60232	; 0xeb48
			return -1;
3000d690:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
			printf(
3000d694:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d698:	f008 fa8a 	bl	30015bb0 <_printf>
			return -1;
3000d69c:	e7ec      	b.n	3000d678 <dw_usb_ll_wakeup+0x40>
		printf("failed to send remote wakeup\n");
3000d69e:	f64e 3080 	movw	r0, #60288	; 0xeb80
		return -1;
3000d6a2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
		printf("failed to send remote wakeup\n");
3000d6a6:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000d6aa:	f008 fa81 	bl	30015bb0 <_printf>
		return -1;
3000d6ae:	e7e3      	b.n	3000d678 <dw_usb_ll_wakeup+0x40>

3000d6b0 <dw_usb_ll_set_ep_stall>:

bool dw_usb_ll_set_ep_stall(vaddr_t iobase, int p_epnum)
{
3000d6b0:	b510      	push	{r4, r14}
	/*depcmd*/
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_STALL,p_epnum,0,0,0,0);
3000d6b2:	2400      	movs	r4, #0
{
3000d6b4:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_STALL,p_epnum,0,0,0,0);
3000d6b6:	460a      	mov	r2, r1
3000d6b8:	4623      	mov	r3, r4
3000d6ba:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d6be:	2104      	movs	r1, #4
3000d6c0:	9400      	str	r4, [sp, #0]
3000d6c2:	f7ff fee3 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d6c6:	b004      	add	sp, #16
3000d6c8:	bd10      	pop	{r4, r15}
3000d6ca:	bf00      	nop

3000d6cc <dw_usb_ll_clear_ep_stall>:

bool dw_usb_ll_clear_ep_stall(vaddr_t iobase, int p_epnum, uint32_t param0)
{
3000d6cc:	b510      	push	{r4, r14}
	/*depcmd*/
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_CLEAR_STALL,p_epnum,0,param0,0,0);
3000d6ce:	2400      	movs	r4, #0
{
3000d6d0:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_CLEAR_STALL,p_epnum,0,param0,0,0);
3000d6d2:	4623      	mov	r3, r4
3000d6d4:	9200      	str	r2, [sp, #0]
3000d6d6:	460a      	mov	r2, r1
3000d6d8:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d6dc:	2105      	movs	r1, #5
3000d6de:	f7ff fed5 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d6e2:	b004      	add	sp, #16
3000d6e4:	bd10      	pop	{r4, r15}
3000d6e6:	bf00      	nop

3000d6e8 <dw_usb_ll_ep_start_transfer>:

bool dw_usb_ll_ep_start_transfer(vaddr_t iobase, int p_epnum, uint32_t param0,uint32_t param1)
{
3000d6e8:	b510      	push	{r4, r14}
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_START_TRANS,p_epnum,0,param0,param1,0);
3000d6ea:	2400      	movs	r4, #0
{
3000d6ec:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_START_TRANS,p_epnum,0,param0,param1,0);
3000d6ee:	9200      	str	r2, [sp, #0]
3000d6f0:	460a      	mov	r2, r1
3000d6f2:	9301      	str	r3, [sp, #4]
3000d6f4:	2106      	movs	r1, #6
3000d6f6:	9402      	str	r4, [sp, #8]
3000d6f8:	4623      	mov	r3, r4
3000d6fa:	f7ff fec7 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d6fe:	b004      	add	sp, #16
3000d700:	bd10      	pop	{r4, r15}
3000d702:	bf00      	nop

3000d704 <dw_usb_ll_ep_update_transfer>:
bool dw_usb_ll_ep_update_transfer(vaddr_t iobase, int p_epnum, int res_id)
{
3000d704:	b510      	push	{r4, r14}
	/*can send no response update*/
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_UPDATE_TRANS,p_epnum,res_id<<16,0,0,0);
3000d706:	2400      	movs	r4, #0
{
3000d708:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_UPDATE_TRANS,p_epnum,res_id<<16,0,0,0);
3000d70a:	0413      	lsls	r3, r2, #16
3000d70c:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d710:	460a      	mov	r2, r1
3000d712:	9400      	str	r4, [sp, #0]
3000d714:	2107      	movs	r1, #7
3000d716:	f7ff feb9 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d71a:	b004      	add	sp, #16
3000d71c:	bd10      	pop	{r4, r15}
3000d71e:	bf00      	nop

3000d720 <dw_usb_ll_ep_end_transfer>:
bool dw_usb_ll_ep_end_transfer(vaddr_t iobase, int p_epnum,int res_id)
{
3000d720:	b510      	push	{r4, r14}
	v |= res_id <<DEPCMD_COMMANDPARAM_FIELD_OFFSET;
	/*forceRM*/
	v |= 1<<DEPCMD_HIPRI_FORCERM_FIELD_OFFSET;
	/*cmdioc 8*/
	v |= 1<<DEPCMD_CMDIOC_FIELD_OFFSET;
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_END_TRANS,p_epnum,v,0,0,0);
3000d722:	2400      	movs	r4, #0
{
3000d724:	b084      	sub	sp, #16
	v |= res_id <<DEPCMD_COMMANDPARAM_FIELD_OFFSET;
3000d726:	0413      	lsls	r3, r2, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_END_TRANS,p_epnum,v,0,0,0);
3000d728:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d72c:	460a      	mov	r2, r1
3000d72e:	9400      	str	r4, [sp, #0]
3000d730:	f443 6310 	orr.w	r3, r3, #2304	; 0x900
3000d734:	2108      	movs	r1, #8
3000d736:	f7ff fea9 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d73a:	b004      	add	sp, #16
3000d73c:	bd10      	pop	{r4, r15}
3000d73e:	bf00      	nop

3000d740 <dw_usb_ll_set_ep_new_config>:

bool dw_usb_ll_set_ep_new_config(vaddr_t iobase, int p_epnum)
{
3000d740:	b510      	push	{r4, r14}
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_NEW_CONFIG,0,0,0,0,0);
3000d742:	2400      	movs	r4, #0
{
3000d744:	b084      	sub	sp, #16
	return dw_usb_ll_set_ep_cmd(iobase,EPCMD_SET_NEW_CONFIG,0,0,0,0,0);
3000d746:	2109      	movs	r1, #9
3000d748:	4623      	mov	r3, r4
3000d74a:	e9cd 4401 	strd	r4, r4, [r13, #4]
3000d74e:	4622      	mov	r2, r4
3000d750:	9400      	str	r4, [sp, #0]
3000d752:	f7ff fe9b 	bl	3000d48c <dw_usb_ll_set_ep_cmd>
}
3000d756:	b004      	add	sp, #16
3000d758:	bd10      	pop	{r4, r15}
3000d75a:	bf00      	nop

3000d75c <dw_usb_ll_set_ep_event_buffer>:
{
	return true;
}

bool dw_usb_ll_set_ep_event_buffer(vaddr_t iobase, int p_epnum, uint32_t adr_l,uint32_t adr_h,uint16_t size)
{
3000d75c:	b470      	push	{r4, r5, r6}
3000d75e:	f8bd 600c 	ldrh.w	r6, [r13, #12]
	//gevntadrlo
	writel(adr_l, iobase+U3DRD_DWC_USB3_GEVNTADRLO+p_epnum*0x10);
	//gevntadrhi
	writel(adr_h, iobase+U3DRD_DWC_USB3_GEVNTADRHI+p_epnum*0x10);
	//gevntsiz
	RMWREG32(iobase+U3DRD_DWC_USB3_GEVNTSIZ+p_epnum*0x10, GEVNTSIZ_EVENTSIZ_FIELD_OFFSET,GEVNTSIZ_EVENTSIZ_FIELD_SIZE,size);
3000d762:	f24c 4408 	movw	r4, #50184	; 0xc408
	writel(adr_l, iobase+U3DRD_DWC_USB3_GEVNTADRLO+p_epnum*0x10);
3000d766:	eb00 1101 	add.w	r1, r0, r1, lsl #4
	writel(adr_h, iobase+U3DRD_DWC_USB3_GEVNTADRHI+p_epnum*0x10);
3000d76a:	f24c 4004 	movw	r0, #50180	; 0xc404
	writel(adr_l, iobase+U3DRD_DWC_USB3_GEVNTADRLO+p_epnum*0x10);
3000d76e:	f501 4544 	add.w	r5, r1, #50176	; 0xc400
3000d772:	602a      	str	r2, [r5, #0]
	//gevntcount
	writel(0, iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10);
3000d774:	2500      	movs	r5, #0
	writel(adr_h, iobase+U3DRD_DWC_USB3_GEVNTADRHI+p_epnum*0x10);
3000d776:	500b      	str	r3, [r1, r0]
	writel(0, iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10);
3000d778:	f24c 420c 	movw	r2, #50188	; 0xc40c
	RMWREG32(iobase+U3DRD_DWC_USB3_GEVNTSIZ+p_epnum*0x10, GEVNTSIZ_EVENTSIZ_FIELD_OFFSET,GEVNTSIZ_EVENTSIZ_FIELD_SIZE,size);
3000d77c:	590b      	ldr	r3, [r1, r4]
	return true;
}
3000d77e:	2001      	movs	r0, #1
	RMWREG32(iobase+U3DRD_DWC_USB3_GEVNTSIZ+p_epnum*0x10, GEVNTSIZ_EVENTSIZ_FIELD_OFFSET,GEVNTSIZ_EVENTSIZ_FIELD_SIZE,size);
3000d780:	0c1b      	lsrs	r3, r3, #16
3000d782:	041b      	lsls	r3, r3, #16
3000d784:	4333      	orrs	r3, r6
3000d786:	510b      	str	r3, [r1, r4]
	writel(0, iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10);
3000d788:	508d      	str	r5, [r1, r2]
}
3000d78a:	bc70      	pop	{r4, r5, r6}
3000d78c:	4770      	bx	r14
3000d78e:	bf00      	nop

3000d790 <dw_usb_ll_get_ep_event_count>:

uint16_t dw_usb_ll_get_ep_event_count(vaddr_t iobase, int p_epnum)
{
	uint16_t v=0;
	v=(readl(iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10) & 0xfffc);
3000d790:	f500 4344 	add.w	r3, r0, #50176	; 0xc400
3000d794:	0109      	lsls	r1, r1, #4
	return v;
}
3000d796:	f64f 70fc 	movw	r0, #65532	; 0xfffc
	v=(readl(iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10) & 0xfffc);
3000d79a:	330c      	adds	r3, #12
3000d79c:	58cb      	ldr	r3, [r1, r3]
}
3000d79e:	4018      	ands	r0, r3
3000d7a0:	4770      	bx	r14
3000d7a2:	bf00      	nop

3000d7a4 <dw_usb_ll_clear_ep_event>:

bool dw_usb_ll_clear_ep_event(vaddr_t iobase, int p_epnum,uint16_t size)
{
	//gevntcount, clear size bytes
	writel(size, iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10);
3000d7a4:	f500 4344 	add.w	r3, r0, #50176	; 0xc400
3000d7a8:	330c      	adds	r3, #12
	return true;
}
3000d7aa:	2001      	movs	r0, #1
	writel(size, iobase+U3DRD_DWC_USB3_GEVNTCOUNT+p_epnum*0x10);
3000d7ac:	0109      	lsls	r1, r1, #4
3000d7ae:	50ca      	str	r2, [r1, r3]
}
3000d7b0:	4770      	bx	r14
3000d7b2:	bf00      	nop

3000d7b4 <dw_usb_ll_ep_open>:

bool dw_usb_ll_ep_open(vaddr_t iobase, int p_epnum)
{
3000d7b4:	b430      	push	{r4, r5}
	uint32_t v;
	/*dalepena*/
	v=readl(iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7b6:	f24c 7220 	movw	r2, #50976	; 0xc720
{
3000d7ba:	4604      	mov	r4, r0
	v |= 1 << p_epnum;
3000d7bc:	2301      	movs	r3, #1
	writel(v, iobase+U3DRD_DWC_USB3_DALEPENA);
	return true;
}
3000d7be:	4618      	mov	r0, r3
	v=readl(iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7c0:	58a5      	ldr	r5, [r4, r2]
	v |= 1 << p_epnum;
3000d7c2:	fa03 f101 	lsl.w	r1, r3, r1
3000d7c6:	4329      	orrs	r1, r5
	writel(v, iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7c8:	50a1      	str	r1, [r4, r2]
}
3000d7ca:	bc30      	pop	{r4, r5}
3000d7cc:	4770      	bx	r14
3000d7ce:	bf00      	nop

3000d7d0 <dw_usb_ll_ep_close>:

bool dw_usb_ll_ep_close(vaddr_t iobase, int p_epnum)
{
3000d7d0:	b430      	push	{r4, r5}
3000d7d2:	4605      	mov	r5, r0
	uint32_t v;
	/*dalepena*/
	v=readl(iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7d4:	f24c 7420 	movw	r4, #50976	; 0xc720
	v &= ~(1 << p_epnum);
3000d7d8:	2301      	movs	r3, #1
	writel(v, iobase+U3DRD_DWC_USB3_DALEPENA);
	return true;
}
3000d7da:	4618      	mov	r0, r3
	v=readl(iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7dc:	592a      	ldr	r2, [r5, r4]
	v &= ~(1 << p_epnum);
3000d7de:	fa03 f101 	lsl.w	r1, r3, r1
3000d7e2:	ea22 0101 	bic.w	r1, r2, r1
	writel(v, iobase+U3DRD_DWC_USB3_DALEPENA);
3000d7e6:	5129      	str	r1, [r5, r4]
}
3000d7e8:	bc30      	pop	{r4, r5}
3000d7ea:	4770      	bx	r14

3000d7ec <dw_usb_ll_set_address>:

bool dw_usb_ll_set_address(vaddr_t iobase, uint8_t addr)
{
	uint32_t v;

	v=readl(iobase + U3DRD_DWC_USB3_DCFG);
3000d7ec:	f500 4247 	add.w	r2, r0, #50944	; 0xc700
	RMWREG32(&v, DCFG_DEVADDR_FIELD_OFFSET, DCFG_DEVADDR_FIELD_SIZE, addr);
	writel(v, iobase+U3DRD_DWC_USB3_DCFG);
	return true;
}
3000d7f0:	2001      	movs	r0, #1
{
3000d7f2:	b082      	sub	sp, #8
	v=readl(iobase + U3DRD_DWC_USB3_DCFG);
3000d7f4:	6813      	ldr	r3, [r2, #0]
3000d7f6:	9301      	str	r3, [sp, #4]
	RMWREG32(&v, DCFG_DEVADDR_FIELD_OFFSET, DCFG_DEVADDR_FIELD_SIZE, addr);
3000d7f8:	9b01      	ldr	r3, [sp, #4]
3000d7fa:	f423 737e 	bic.w	r3, r3, #1016	; 0x3f8
3000d7fe:	ea43 01c1 	orr.w	r1, r3, r1, lsl #3
3000d802:	9101      	str	r1, [sp, #4]
	writel(v, iobase+U3DRD_DWC_USB3_DCFG);
3000d804:	6011      	str	r1, [r2, #0]
}
3000d806:	b002      	add	sp, #8
3000d808:	4770      	bx	r14
3000d80a:	bf00      	nop

3000d80c <dw_usb_ll_get_cur_speed>:

int dw_usb_ll_get_cur_speed(vaddr_t iobase)
{
	int speed;
	uint32_t v=readl(iobase+U3DRD_DWC_USB3_DSTS);
3000d80c:	f24c 730c 	movw	r3, #50956	; 0xc70c
3000d810:	58c0      	ldr	r0, [r0, r3]
	speed = DW_GET_CONNDONE_SPEED(v);
	return speed;
}
3000d812:	f000 0007 	and.w	r0, r0, #7
3000d816:	4770      	bx	r14

3000d818 <dw_usb_ll_get_ncr_evt>:

uint32_t dw_usb_ll_get_ncr_evt(vaddr_t iobase)
{
	return readl(iobase + U3DRD_NCR_INTR);
3000d818:	f24d 0380 	movw	r3, #53376	; 0xd080
3000d81c:	58c0      	ldr	r0, [r0, r3]
}
3000d81e:	4770      	bx	r14

3000d820 <dw_usb_ll_clr_ncr_evt>:

void dw_usb_ll_clr_ncr_evt(vaddr_t iobase)
{
	uint32_t v = readl(iobase + U3DRD_NCR_INTR);
3000d820:	f24d 0280 	movw	r2, #53376	; 0xd080
3000d824:	5883      	ldr	r3, [r0, r2]
	if (v)
3000d826:	b113      	cbz	r3, 3000d82e <dw_usb_ll_clr_ncr_evt+0xe>
		writel(v & 0x7Fu, iobase + U3DRD_NCR_INTR);
3000d828:	f003 037f 	and.w	r3, r3, #127	; 0x7f
3000d82c:	5083      	str	r3, [r0, r2]
}
3000d82e:	4770      	bx	r14

3000d830 <wdg_unlock>:
//!
//! \return None.
//
//*****************************************************************************
static bool wdg_unlock(wdg_reg_type_t *base,uint32_t unlock_mask)
{
3000d830:	b410      	push	{r4}
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000d832:	2400      	movs	r4, #0
{
3000d834:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000d836:	4622      	mov	r2, r4
3000d838:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000d83c:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000d840:	42a0      	cmp	r0, r4
3000d842:	bf18      	it	ne
3000d844:	4290      	cmpne	r0, r2
3000d846:	d007      	beq.n	3000d858 <wdg_unlock+0x28>
3000d848:	2200      	movs	r2, #0
3000d84a:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000d84e:	4290      	cmp	r0, r2
3000d850:	bf18      	it	ne
3000d852:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000d856:	d107      	bne.n	3000d868 <wdg_unlock+0x38>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_unlock:lock_mask:%d\n",unlock_mask);

    base->wdg_lock &=~unlock_mask;
3000d858:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    return true;
3000d85a:	2001      	movs	r0, #1
    base->wdg_lock &=~unlock_mask;
3000d85c:	ea22 0101 	bic.w	r1, r2, r1
3000d860:	6459      	str	r1, [r3, #68]	; 0x44
}
3000d862:	f85d 4b04 	ldr.w	r4, [r13], #4
3000d866:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000d868:	2000      	movs	r0, #0
3000d86a:	4602      	mov	r2, r0
3000d86c:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000d870:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000d874:	4283      	cmp	r3, r0
3000d876:	bf18      	it	ne
3000d878:	4293      	cmpne	r3, r2
3000d87a:	d0ed      	beq.n	3000d858 <wdg_unlock+0x28>
3000d87c:	2000      	movs	r0, #0
3000d87e:	4602      	mov	r2, r0
3000d880:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000d884:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000d888:	4283      	cmp	r3, r0
3000d88a:	bf18      	it	ne
3000d88c:	4293      	cmpne	r3, r2
3000d88e:	bf18      	it	ne
3000d890:	2000      	movne	r0, #0
3000d892:	d0e1      	beq.n	3000d858 <wdg_unlock+0x28>
3000d894:	e7e5      	b.n	3000d862 <wdg_unlock+0x32>
3000d896:	bf00      	nop

3000d898 <wdg_addr_to_number>:
static uint32_t wdg_addr_to_number(wdg_reg_type_t *base)
{
    uint32_t wdg_number = wdg_really_num1;

    // Check the arguments.
    ASSERT_PARAMETER(base);
3000d898:	2300      	movs	r3, #0
3000d89a:	461a      	mov	r2, r3
3000d89c:	f2cf 031c 	movt	r3, #61468	; 0xf01c
3000d8a0:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000d8a4:	4298      	cmp	r0, r3
3000d8a6:	bf18      	it	ne
3000d8a8:	4290      	cmpne	r0, r2
3000d8aa:	d02b      	beq.n	3000d904 <wdg_addr_to_number+0x6c>
3000d8ac:	2300      	movs	r3, #0
3000d8ae:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000d8b2:	4298      	cmp	r0, r3
3000d8b4:	bf18      	it	ne
3000d8b6:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000d8ba:	d127      	bne.n	3000d90c <wdg_addr_to_number+0x74>

    if(WDG1_BASE == base){
        wdg_number = wdg_really_num1;
    }else if(WDG2_BASE == base){
3000d8bc:	2300      	movs	r3, #0
3000d8be:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000d8c2:	4298      	cmp	r0, r3
3000d8c4:	d03a      	beq.n	3000d93c <wdg_addr_to_number+0xa4>
        wdg_number = wdg_really_num2;
    }else if(WDG3_BASE == base){
3000d8c6:	f110 6f76 	cmn.w	r0, #257949696	; 0xf600000
3000d8ca:	d035      	beq.n	3000d938 <wdg_addr_to_number+0xa0>
        wdg_number = wdg_really_num3;
    }else if(WDG4_BASE == base){
3000d8cc:	2300      	movs	r3, #0
3000d8ce:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000d8d2:	4298      	cmp	r0, r3
3000d8d4:	d034      	beq.n	3000d940 <wdg_addr_to_number+0xa8>
        wdg_number = wdg_really_num4;
    }else if(WDG5_BASE == base){
3000d8d6:	2300      	movs	r3, #0
3000d8d8:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
3000d8dc:	4298      	cmp	r0, r3
3000d8de:	d031      	beq.n	3000d944 <wdg_addr_to_number+0xac>
        wdg_number = wdg_really_num5;
    }else if(WDG6_BASE == base){
3000d8e0:	2300      	movs	r3, #0
3000d8e2:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000d8e6:	4298      	cmp	r0, r3
3000d8e8:	d02e      	beq.n	3000d948 <wdg_addr_to_number+0xb0>
        wdg_number = wdg_really_num6;
    }else if(WDG7_BASE == base){
3000d8ea:	2300      	movs	r3, #0
3000d8ec:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
3000d8f0:	4298      	cmp	r0, r3
3000d8f2:	d02b      	beq.n	3000d94c <wdg_addr_to_number+0xb4>
        wdg_number = wdg_really_num7;
    }else if(WDG8_BASE == base){
3000d8f4:	2300      	movs	r3, #0
3000d8f6:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
        wdg_number = wdg_really_num8;
3000d8fa:	4298      	cmp	r0, r3
3000d8fc:	bf14      	ite	ne
3000d8fe:	2001      	movne	r0, #1
3000d900:	2008      	moveq	r0, #8
3000d902:	4770      	bx	r14
    if(WDG1_BASE == base){
3000d904:	4298      	cmp	r0, r3
3000d906:	d1d9      	bne.n	3000d8bc <wdg_addr_to_number+0x24>
    }else{
        wdg_number = wdg_really_num1;
3000d908:	2001      	movs	r0, #1
3000d90a:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000d90c:	2200      	movs	r2, #0
3000d90e:	4613      	mov	r3, r2
3000d910:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000d914:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000d918:	4290      	cmp	r0, r2
3000d91a:	bf18      	it	ne
3000d91c:	4298      	cmpne	r0, r3
3000d91e:	d0cd      	beq.n	3000d8bc <wdg_addr_to_number+0x24>
3000d920:	2200      	movs	r2, #0
3000d922:	4613      	mov	r3, r2
3000d924:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000d928:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000d92c:	4290      	cmp	r0, r2
3000d92e:	bf18      	it	ne
3000d930:	4298      	cmpne	r0, r3
3000d932:	d0c3      	beq.n	3000d8bc <wdg_addr_to_number+0x24>
3000d934:	2000      	movs	r0, #0
3000d936:	4770      	bx	r14
        wdg_number = wdg_really_num3;
3000d938:	2003      	movs	r0, #3
3000d93a:	4770      	bx	r14
        wdg_number = wdg_really_num2;
3000d93c:	2002      	movs	r0, #2
3000d93e:	4770      	bx	r14
        wdg_number = wdg_really_num4;
3000d940:	2004      	movs	r0, #4
3000d942:	4770      	bx	r14
        wdg_number = wdg_really_num5;
3000d944:	2005      	movs	r0, #5
3000d946:	4770      	bx	r14
        wdg_number = wdg_really_num6;
3000d948:	2006      	movs	r0, #6
3000d94a:	4770      	bx	r14
        wdg_number = wdg_really_num7;
3000d94c:	2007      	movs	r0, #7
    }

    return wdg_number;
}
3000d94e:	4770      	bx	r14

3000d950 <wdg_get_default_config>:
    if(!wdg_config){
3000d950:	2800      	cmp	r0, #0
3000d952:	d044      	beq.n	3000d9de <wdg_get_default_config+0x8e>
    wdg_config->wdg_ctrl_config.clockSource = wdg_main_clk;
3000d954:	2300      	movs	r3, #0
    wdg_config->wdg_ctrl_config.enableSoftRest = true;
3000d956:	2201      	movs	r2, #1
{
3000d958:	b430      	push	{r4, r5}
    wdg_config->refresh_wind_limit = DEFAULT_WATCHOUT_WIN_LOW_LIMIT;
3000d95a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    wdg_config->wdg_ctrl_config.prescaler = 11999U;
3000d95e:	f642 65df 	movw	r5, #11999	; 0x2edf
    wdg_config->wdg_ctrl_config.clockSource = wdg_main_clk;
3000d962:	6043      	str	r3, [r0, #4]
    wdg_config->wdg_timeout = DEFAULT_WATCHOUT_TIMEOUT_TIME;
3000d964:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    wdg_config->wdg_ctrl_config.prescaler = 11999U;
3000d968:	81c5      	strh	r5, [r0, #14]
    wdg_config->wdg_timeout = DEFAULT_WATCHOUT_TIMEOUT_TIME;
3000d96a:	6104      	str	r4, [r0, #16]
    wdg_config->wdg_ctrl_config.enableAutostart = false;
3000d96c:	7243      	strb	r3, [r0, #9]
    wdg_config->wdg_ctrl_config.enableDebugmode = false;
3000d96e:	7283      	strb	r3, [r0, #10]
    wdg_config->wdg_ctrl_config.enableSelftest = false;
3000d970:	7303      	strb	r3, [r0, #12]
    wdg_config->wdg_ctrl_config.enableWdg = false;
3000d972:	7043      	strb	r3, [r0, #1]
    wdg_config->wdg_refresh_config.enableRefreshTrig = false;
3000d974:	7583      	strb	r3, [r0, #22]
    wdg_config->wdg_refresh_config.enableSeqRefresh = false;
3000d976:	7543      	strb	r3, [r0, #21]
    wdg_config->wdg_reset_cfg.enableSysReset = false;
3000d978:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
    wdg_config->wdg_reset_cfg.enableWdgResetEn = false;
3000d97c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    wdg_config->wdg_reset_cfg.plusRstWind = 0x0U;
3000d980:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    wdg_config->wdg_reset_cfg.SysRstMode = 0x0U;
3000d984:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
    wdg_config->wdg_reset_cfg.wdgResetCnt = 0x0U;
3000d988:	8403      	strh	r3, [r0, #32]
    wdg_config->wdg_ext_reset_cfg.plusRstWind = 0x0U;
3000d98a:	f880 302a 	strb.w	r3, [r0, #42]	; 0x2a
    wdg_config->wdg_ext_reset_cfg.SysExtRstMode = 0x0U;
3000d98e:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
    wdg_config->wdg_ext_reset_cfg.wdgResetCnt = 0x0U;
3000d992:	84c3      	strh	r3, [r0, #38]	; 0x26
    wdg_config->wdg_int_cfg.ill_seq_refr_int_clr = false;
3000d994:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    wdg_config->wdg_int_cfg.ill_seq_refr_int_en = false;
3000d998:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
    wdg_config->wdg_int_cfg.ill_win_refr_int_clr = false;
3000d99c:	f880 3033 	strb.w	r3, [r0, #51]	; 0x33
    wdg_config->wdg_int_cfg.ill_win_refr_int_en = false;
3000d9a0:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    wdg_config->wdg_lock_cfg.clk_src_lock = false;
3000d9a4:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    wdg_config->wdg_ctrl_config.enableSoftRest = true;
3000d9a8:	7002      	strb	r2, [r0, #0]
    wdg_config->wdg_ctrl_config.enableSrcSelect = 0x1U;
3000d9aa:	72c2      	strb	r2, [r0, #11]
    wdg_config->wdg_ctrl_config.terminalCountSrc = 0x1U;
3000d9ac:	7202      	strb	r2, [r0, #8]
    wdg_config->wdg_refresh_config.wdgModeSelect = wdg_mechanism_mode1;
3000d9ae:	7502      	strb	r2, [r0, #20]
    wdg_config->wdg_ext_reset_cfg.enableSysExtReset = true;
3000d9b0:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
    wdg_config->wdg_int_cfg.overflow_int_clr = true;
3000d9b4:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
    wdg_config->wdg_int_cfg.overflow_int_en = true;
3000d9b8:	f880 2032 	strb.w	r2, [r0, #50]	; 0x32
    wdg_config->refresh_seq_delta = DEFAULT_WATCHOUT_SEQ_DELTA;
3000d9bc:	e9c0 1106 	strd	r1, r1, [r0, #24]
    wdg_config->wdg_tsw = DEFAULT_WATCHOUT_TIMESTAMP;
3000d9c0:	62c1      	str	r1, [r0, #44]	; 0x2c
    wdg_config->wdg_lock_cfg.ctl_lock = false;
3000d9c2:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
    wdg_config->wdg_lock_cfg.ext_rst_lock = false;
3000d9c6:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
    wdg_config->wdg_lock_cfg.int_lock = false;
3000d9ca:	f880 303b 	strb.w	r3, [r0, #59]	; 0x3b
    wdg_config->wdg_lock_cfg.rst_lock = false;
3000d9ce:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
    wdg_config->wdg_lock_cfg.wrc_lock = false;
3000d9d2:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    wdg_config->wdg_lock_cfg.wtc_lock = false;
3000d9d6:	f880 3037 	strb.w	r3, [r0, #55]	; 0x37
}
3000d9da:	bc30      	pop	{r4, r5}
3000d9dc:	4770      	bx	r14
3000d9de:	4770      	bx	r14

3000d9e0 <wdg_set_timeout>:
{
3000d9e0:	b570      	push	{r4, r5, r6, r14}
    ASSERT_PARAMETER(base);
3000d9e2:	2400      	movs	r4, #0
3000d9e4:	4622      	mov	r2, r4
3000d9e6:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000d9ea:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000d9ee:	42a0      	cmp	r0, r4
3000d9f0:	bf18      	it	ne
3000d9f2:	4290      	cmpne	r0, r2
3000d9f4:	d01d      	beq.n	3000da32 <wdg_set_timeout+0x52>
3000d9f6:	2200      	movs	r2, #0
3000d9f8:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000d9fc:	4290      	cmp	r0, r2
3000d9fe:	bf18      	it	ne
3000da00:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000da04:	d015      	beq.n	3000da32 <wdg_set_timeout+0x52>
3000da06:	2200      	movs	r2, #0
3000da08:	4613      	mov	r3, r2
3000da0a:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000da0e:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000da12:	4290      	cmp	r0, r2
3000da14:	bf18      	it	ne
3000da16:	4298      	cmpne	r0, r3
3000da18:	d00b      	beq.n	3000da32 <wdg_set_timeout+0x52>
3000da1a:	2200      	movs	r2, #0
3000da1c:	4613      	mov	r3, r2
3000da1e:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000da22:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000da26:	4290      	cmp	r0, r2
3000da28:	bf18      	it	ne
3000da2a:	4298      	cmpne	r0, r3
3000da2c:	bf18      	it	ne
3000da2e:	2000      	movne	r0, #0
3000da30:	d123      	bne.n	3000da7a <wdg_set_timeout+0x9a>
3000da32:	4604      	mov	r4, r0
3000da34:	460d      	mov	r5, r1
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000da36:	6800      	ldr	r0, [r0, #0]
    freq = g_clk_select[clk_mask];
3000da38:	f64e 31a0 	movw	r1, #60320	; 0xeba0
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000da3c:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    freq = g_clk_select[clk_mask];
3000da40:	f2c3 0101 	movt	r1, #12289	; 0x3001
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000da44:	6822      	ldr	r2, [r4, #0]
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000da46:	f3c0 0082 	ubfx	r0, r0, #2, #3
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000da4a:	f2c1 0662 	movt	r6, #4194	; 0x1062
3000da4e:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000da52:	0c12      	lsrs	r2, r2, #16
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
3000da54:	2102      	movs	r1, #2
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000da56:	3201      	adds	r2, #1
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
3000da58:	4620      	mov	r0, r4
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000da5a:	fbb3 f3f2 	udiv	r3, r3, r2
3000da5e:	fba6 2303 	umull	r2, r3, r6, r3
3000da62:	099b      	lsrs	r3, r3, #6
3000da64:	fb05 f503 	mul.w	r5, r5, r3
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
3000da68:	f7ff fee2 	bl	3000d830 <wdg_unlock>
    base->wdg_wtc &= ~WDG_WTC_MASK;
3000da6c:	2300      	movs	r3, #0
    return true;
3000da6e:	2001      	movs	r0, #1
    base->wdg_wtc &= ~WDG_WTC_MASK;
3000da70:	6862      	ldr	r2, [r4, #4]
3000da72:	6063      	str	r3, [r4, #4]
    base->wdg_wtc |= wtcon;
3000da74:	6863      	ldr	r3, [r4, #4]
3000da76:	432b      	orrs	r3, r5
3000da78:	6063      	str	r3, [r4, #4]
}
3000da7a:	bd70      	pop	{r4, r5, r6, r15}

3000da7c <wdg_set_window_limit>:
{
3000da7c:	b470      	push	{r4, r5, r6}
    ASSERT_PARAMETER(base);
3000da7e:	2400      	movs	r4, #0
{
3000da80:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000da82:	4622      	mov	r2, r4
3000da84:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000da88:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000da8c:	42a0      	cmp	r0, r4
3000da8e:	bf18      	it	ne
3000da90:	4290      	cmpne	r0, r2
3000da92:	d007      	beq.n	3000daa4 <wdg_set_window_limit+0x28>
3000da94:	2200      	movs	r2, #0
3000da96:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000da9a:	4290      	cmp	r0, r2
3000da9c:	bf18      	it	ne
3000da9e:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000daa2:	d11f      	bne.n	3000dae4 <wdg_set_window_limit+0x68>
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000daa4:	681d      	ldr	r5, [r3, #0]
    freq = g_clk_select[clk_mask];
3000daa6:	f64e 34a0 	movw	r4, #60320	; 0xeba0
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000daaa:	6818      	ldr	r0, [r3, #0]
    freq = g_clk_select[clk_mask];
3000daac:	f2c3 0401 	movt	r4, #12289	; 0x3001
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000dab0:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000dab4:	f3c5 0582 	ubfx	r5, r5, #2, #3
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000dab8:	f2c1 0662 	movt	r6, #4194	; 0x1062
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000dabc:	0c00      	lsrs	r0, r0, #16
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000dabe:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000dac2:	3001      	adds	r0, #1
    base->wdg_wrc_val &= 0x00000000U;
3000dac4:	68dd      	ldr	r5, [r3, #12]
3000dac6:	2400      	movs	r4, #0
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000dac8:	fbb2 f2f0 	udiv	r2, r2, r0
    base->wdg_wrc_val &= 0x00000000U;
3000dacc:	60dc      	str	r4, [r3, #12]
    return true;
3000dace:	2001      	movs	r0, #1
    base->wdg_wrc_val |= wincon;
3000dad0:	68dc      	ldr	r4, [r3, #12]
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000dad2:	fba6 5202 	umull	r5, r2, r6, r2
3000dad6:	0992      	lsrs	r2, r2, #6
3000dad8:	fb01 f102 	mul.w	r1, r1, r2
    base->wdg_wrc_val |= wincon;
3000dadc:	4321      	orrs	r1, r4
3000dade:	60d9      	str	r1, [r3, #12]
}
3000dae0:	bc70      	pop	{r4, r5, r6}
3000dae2:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000dae4:	2000      	movs	r0, #0
3000dae6:	4602      	mov	r2, r0
3000dae8:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000daec:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000daf0:	4283      	cmp	r3, r0
3000daf2:	bf18      	it	ne
3000daf4:	4293      	cmpne	r3, r2
3000daf6:	d0d5      	beq.n	3000daa4 <wdg_set_window_limit+0x28>
3000daf8:	2000      	movs	r0, #0
3000dafa:	4602      	mov	r2, r0
3000dafc:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000db00:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000db04:	4283      	cmp	r3, r0
3000db06:	bf18      	it	ne
3000db08:	4293      	cmpne	r3, r2
3000db0a:	bf18      	it	ne
3000db0c:	2000      	movne	r0, #0
3000db0e:	d0c9      	beq.n	3000daa4 <wdg_set_window_limit+0x28>
3000db10:	e7e6      	b.n	3000dae0 <wdg_set_window_limit+0x64>
3000db12:	bf00      	nop

3000db14 <wdg_set_seq_delta>:
{
3000db14:	b470      	push	{r4, r5, r6}
    ASSERT_PARAMETER(base);
3000db16:	2400      	movs	r4, #0
{
3000db18:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000db1a:	4622      	mov	r2, r4
3000db1c:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000db20:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000db24:	42a0      	cmp	r0, r4
3000db26:	bf18      	it	ne
3000db28:	4290      	cmpne	r0, r2
3000db2a:	d007      	beq.n	3000db3c <wdg_set_seq_delta+0x28>
3000db2c:	2200      	movs	r2, #0
3000db2e:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000db32:	4290      	cmp	r0, r2
3000db34:	bf18      	it	ne
3000db36:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000db3a:	d11f      	bne.n	3000db7c <wdg_set_seq_delta+0x68>
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000db3c:	681d      	ldr	r5, [r3, #0]
    freq = g_clk_select[clk_mask];
3000db3e:	f64e 34a0 	movw	r4, #60320	; 0xeba0
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000db42:	6818      	ldr	r0, [r3, #0]
    freq = g_clk_select[clk_mask];
3000db44:	f2c3 0401 	movt	r4, #12289	; 0x3001
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000db48:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
3000db4c:	f3c5 0582 	ubfx	r5, r5, #2, #3
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000db50:	f2c1 0662 	movt	r6, #4194	; 0x1062
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000db54:	0c00      	lsrs	r0, r0, #16
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000db56:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
3000db5a:	3001      	adds	r0, #1
    base->wdg_wrc_seq &= 0x00000000U;
3000db5c:	691d      	ldr	r5, [r3, #16]
3000db5e:	2400      	movs	r4, #0
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000db60:	fbb2 f2f0 	udiv	r2, r2, r0
    base->wdg_wrc_seq &= 0x00000000U;
3000db64:	611c      	str	r4, [r3, #16]
    return true;
3000db66:	2001      	movs	r0, #1
    base->wdg_wrc_seq |= seqcon;
3000db68:	691c      	ldr	r4, [r3, #16]
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
3000db6a:	fba6 5202 	umull	r5, r2, r6, r2
3000db6e:	0992      	lsrs	r2, r2, #6
3000db70:	fb01 f102 	mul.w	r1, r1, r2
    base->wdg_wrc_seq |= seqcon;
3000db74:	4321      	orrs	r1, r4
3000db76:	6119      	str	r1, [r3, #16]
}
3000db78:	bc70      	pop	{r4, r5, r6}
3000db7a:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000db7c:	2000      	movs	r0, #0
3000db7e:	4602      	mov	r2, r0
3000db80:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000db84:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000db88:	4283      	cmp	r3, r0
3000db8a:	bf18      	it	ne
3000db8c:	4293      	cmpne	r3, r2
3000db8e:	d0d5      	beq.n	3000db3c <wdg_set_seq_delta+0x28>
3000db90:	2000      	movs	r0, #0
3000db92:	4602      	mov	r2, r0
3000db94:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000db98:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000db9c:	4283      	cmp	r3, r0
3000db9e:	bf18      	it	ne
3000dba0:	4293      	cmpne	r3, r2
3000dba2:	bf18      	it	ne
3000dba4:	2000      	movne	r0, #0
3000dba6:	d0c9      	beq.n	3000db3c <wdg_set_seq_delta+0x28>
3000dba8:	e7e6      	b.n	3000db78 <wdg_set_seq_delta+0x64>
3000dbaa:	bf00      	nop

3000dbac <wdg_refesh_mechanism_select>:
{
3000dbac:	b410      	push	{r4}
    ASSERT_PARAMETER(base);
3000dbae:	2400      	movs	r4, #0
{
3000dbb0:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000dbb2:	4622      	mov	r2, r4
3000dbb4:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000dbb8:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000dbbc:	42a0      	cmp	r0, r4
3000dbbe:	bf18      	it	ne
3000dbc0:	4290      	cmpne	r0, r2
3000dbc2:	d007      	beq.n	3000dbd4 <wdg_refesh_mechanism_select+0x28>
3000dbc4:	2200      	movs	r2, #0
3000dbc6:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000dbca:	4290      	cmp	r0, r2
3000dbcc:	bf18      	it	ne
3000dbce:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000dbd2:	d10d      	bne.n	3000dbf0 <wdg_refesh_mechanism_select+0x44>
    if(wdg_config->wdg_refresh_config.wdgModeSelect > wdg_mechanism_mode_max){
3000dbd4:	7d08      	ldrb	r0, [r1, #20]
3000dbd6:	2803      	cmp	r0, #3
3000dbd8:	d81e      	bhi.n	3000dc18 <wdg_refesh_mechanism_select+0x6c>
    switch (wdg_config->wdg_refresh_config.wdgModeSelect) {
3000dbda:	2802      	cmp	r0, #2
3000dbdc:	d020      	beq.n	3000dc20 <wdg_refesh_mechanism_select+0x74>
3000dbde:	2803      	cmp	r0, #3
3000dbe0:	d035      	beq.n	3000dc4e <wdg_refesh_mechanism_select+0xa2>
3000dbe2:	2801      	cmp	r0, #1
    return true;
3000dbe4:	bf18      	it	ne
3000dbe6:	2001      	movne	r0, #1
    switch (wdg_config->wdg_refresh_config.wdgModeSelect) {
3000dbe8:	d026      	beq.n	3000dc38 <wdg_refesh_mechanism_select+0x8c>
}
3000dbea:	f85d 4b04 	ldr.w	r4, [r13], #4
3000dbee:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000dbf0:	2000      	movs	r0, #0
3000dbf2:	4602      	mov	r2, r0
3000dbf4:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000dbf8:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000dbfc:	4283      	cmp	r3, r0
3000dbfe:	bf18      	it	ne
3000dc00:	4293      	cmpne	r3, r2
3000dc02:	d0e7      	beq.n	3000dbd4 <wdg_refesh_mechanism_select+0x28>
3000dc04:	2000      	movs	r0, #0
3000dc06:	4602      	mov	r2, r0
3000dc08:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000dc0c:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000dc10:	4283      	cmp	r3, r0
3000dc12:	bf18      	it	ne
3000dc14:	4293      	cmpne	r3, r2
3000dc16:	d0dd      	beq.n	3000dbd4 <wdg_refesh_mechanism_select+0x28>
}
3000dc18:	f85d 4b04 	ldr.w	r4, [r13], #4
    ASSERT_PARAMETER(base);
3000dc1c:	2000      	movs	r0, #0
}
3000dc1e:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc20:	689a      	ldr	r2, [r3, #8]
    return true;
3000dc22:	2001      	movs	r0, #1
}
3000dc24:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc28:	f022 0203 	bic.w	r2, r2, #3
3000dc2c:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= WDG_WRC_CTRL_MODEM1_MASK;
3000dc2e:	689a      	ldr	r2, [r3, #8]
3000dc30:	f042 0202 	orr.w	r2, r2, #2
3000dc34:	609a      	str	r2, [r3, #8]
}
3000dc36:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc38:	689a      	ldr	r2, [r3, #8]
}
3000dc3a:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc3e:	f022 0203 	bic.w	r2, r2, #3
3000dc42:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= WDG_WRC_CTRL_MODEM0_MASK;
3000dc44:	689a      	ldr	r2, [r3, #8]
3000dc46:	f042 0201 	orr.w	r2, r2, #1
3000dc4a:	609a      	str	r2, [r3, #8]
}
3000dc4c:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc4e:	689a      	ldr	r2, [r3, #8]
    return true;
3000dc50:	2001      	movs	r0, #1
}
3000dc52:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc56:	f022 0203 	bic.w	r2, r2, #3
3000dc5a:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= (WDG_WRC_CTRL_SEQ_REFR_MASK);
3000dc5c:	689a      	ldr	r2, [r3, #8]
3000dc5e:	f042 0204 	orr.w	r2, r2, #4
3000dc62:	609a      	str	r2, [r3, #8]
}
3000dc64:	4770      	bx	r14
3000dc66:	bf00      	nop

3000dc68 <wdg_get_refesh_mechanism>:
    ASSERT_PARAMETER(base);
3000dc68:	2200      	movs	r2, #0
3000dc6a:	4613      	mov	r3, r2
3000dc6c:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000dc70:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000dc74:	4290      	cmp	r0, r2
3000dc76:	bf18      	it	ne
3000dc78:	4298      	cmpne	r0, r3
3000dc7a:	d007      	beq.n	3000dc8c <wdg_get_refesh_mechanism+0x24>
3000dc7c:	2300      	movs	r3, #0
3000dc7e:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000dc82:	4298      	cmp	r0, r3
3000dc84:	bf18      	it	ne
3000dc86:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000dc8a:	d108      	bne.n	3000dc9e <wdg_get_refesh_mechanism+0x36>
    refresh_mechanism = base->wdg_wrc_ctl & (WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
3000dc8c:	6883      	ldr	r3, [r0, #8]
    if((WDG_WRC_CTRL_MODEM1_MASK & refresh_mechanism) == WDG_WRC_CTRL_MODEM1_MASK){
3000dc8e:	079a      	lsls	r2, r3, #30
3000dc90:	d41b      	bmi.n	3000dcca <wdg_get_refesh_mechanism+0x62>
        return wdg_mechanism_mode3;
3000dc92:	f013 0f01 	tst.w	r3, #1
3000dc96:	bf14      	ite	ne
3000dc98:	2001      	movne	r0, #1
3000dc9a:	2003      	moveq	r0, #3
3000dc9c:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000dc9e:	2200      	movs	r2, #0
3000dca0:	4613      	mov	r3, r2
3000dca2:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000dca6:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000dcaa:	4290      	cmp	r0, r2
3000dcac:	bf18      	it	ne
3000dcae:	4298      	cmpne	r0, r3
3000dcb0:	d0ec      	beq.n	3000dc8c <wdg_get_refesh_mechanism+0x24>
3000dcb2:	2200      	movs	r2, #0
3000dcb4:	4613      	mov	r3, r2
3000dcb6:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000dcba:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000dcbe:	4290      	cmp	r0, r2
3000dcc0:	bf18      	it	ne
3000dcc2:	4298      	cmpne	r0, r3
3000dcc4:	d0e2      	beq.n	3000dc8c <wdg_get_refesh_mechanism+0x24>
3000dcc6:	2000      	movs	r0, #0
3000dcc8:	4770      	bx	r14
        return wdg_mechanism_mode2;
3000dcca:	2002      	movs	r0, #2
}
3000dccc:	4770      	bx	r14
3000dcce:	bf00      	nop

3000dcd0 <wdg_init>:
{
3000dcd0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ASSERT_PARAMETER(base);
3000dcd2:	2500      	movs	r5, #0
3000dcd4:	462b      	mov	r3, r5
3000dcd6:	f2cf 051c 	movt	r5, #61468	; 0xf01c
3000dcda:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000dcde:	42a8      	cmp	r0, r5
3000dce0:	bf18      	it	ne
3000dce2:	4298      	cmpne	r0, r3
3000dce4:	bf14      	ite	ne
3000dce6:	2501      	movne	r5, #1
3000dce8:	2500      	moveq	r5, #0
3000dcea:	d008      	beq.n	3000dcfe <wdg_init+0x2e>
3000dcec:	2300      	movs	r3, #0
3000dcee:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000dcf2:	4298      	cmp	r0, r3
3000dcf4:	bf18      	it	ne
3000dcf6:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000dcfa:	f040 8085 	bne.w	3000de08 <wdg_init+0x138>
3000dcfe:	460e      	mov	r6, r1
    wdg_unlock(base,unlock_mask);
3000dd00:	217f      	movs	r1, #127	; 0x7f
3000dd02:	4604      	mov	r4, r0
3000dd04:	f7ff fd94 	bl	3000d830 <wdg_unlock>
    base->wdg_ctrl = 0x0U;
3000dd08:	2200      	movs	r2, #0
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_SRC(wdg_config->wdg_ctrl_config.enableSrcSelect)|WDG_CTRL_WTC_SRC(wdg_config->wdg_ctrl_config.terminalCountSrc);
3000dd0a:	2364      	movs	r3, #100	; 0x64
    base->wdg_ctrl = 0x0U;
3000dd0c:	6022      	str	r2, [r4, #0]
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_SRC(wdg_config->wdg_ctrl_config.enableSrcSelect)|WDG_CTRL_WTC_SRC(wdg_config->wdg_ctrl_config.terminalCountSrc);
3000dd0e:	7af2      	ldrb	r2, [r6, #11]
3000dd10:	7a31      	ldrb	r1, [r6, #8]
3000dd12:	0212      	lsls	r2, r2, #8
3000dd14:	0149      	lsls	r1, r1, #5
3000dd16:	f001 0120 	and.w	r1, r1, #32
3000dd1a:	f402 7280 	and.w	r2, r2, #256	; 0x100
3000dd1e:	430a      	orrs	r2, r1
3000dd20:	6821      	ldr	r1, [r4, #0]
3000dd22:	430a      	orrs	r2, r1
3000dd24:	6022      	str	r2, [r4, #0]
3000dd26:	e002      	b.n	3000dd2e <wdg_init+0x5e>
    }while (--retrycount);
3000dd28:	3b01      	subs	r3, #1
3000dd2a:	f000 8083 	beq.w	3000de34 <wdg_init+0x164>
                    v= base->wdg_ctrl;
3000dd2e:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
3000dd30:	0552      	lsls	r2, r2, #21
3000dd32:	d4f9      	bmi.n	3000dd28 <wdg_init+0x58>
    ASSERT_PARAMETER(base);
3000dd34:	b18d      	cbz	r5, 3000dd5a <wdg_init+0x8a>
3000dd36:	2300      	movs	r3, #0
3000dd38:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000dd3c:	429c      	cmp	r4, r3
3000dd3e:	bf18      	it	ne
3000dd40:	f114 6f76 	cmnne.w	r4, #257949696	; 0xf600000
3000dd44:	d009      	beq.n	3000dd5a <wdg_init+0x8a>
3000dd46:	2200      	movs	r2, #0
3000dd48:	4613      	mov	r3, r2
3000dd4a:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000dd4e:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000dd52:	4294      	cmp	r4, r2
3000dd54:	bf18      	it	ne
3000dd56:	429c      	cmpne	r4, r3
3000dd58:	d16e      	bne.n	3000de38 <wdg_init+0x168>
    if((wdg_config->wdg_ctrl_config.clockSource !=wdg_main_clk)
3000dd5a:	6873      	ldr	r3, [r6, #4]
3000dd5c:	2b04      	cmp	r3, #4
3000dd5e:	d816      	bhi.n	3000dd8e <wdg_init+0xbe>
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
3000dd60:	2101      	movs	r1, #1
3000dd62:	4620      	mov	r0, r4
3000dd64:	f7ff fd64 	bl	3000d830 <wdg_unlock>
    base->wdg_ctrl &=~WDG_CTRL_CLK_SRC_MASK;
3000dd68:	6822      	ldr	r2, [r4, #0]
    base->wdg_ctrl |=WDG_CTRL_CLK_SRC(wdg_config->wdg_ctrl_config.clockSource);
3000dd6a:	6873      	ldr	r3, [r6, #4]
    base->wdg_ctrl |= WDG_CTRL_PRE_DIV_NUM(wdg_config->wdg_ctrl_config.prescaler);
3000dd6c:	89f1      	ldrh	r1, [r6, #14]
    base->wdg_ctrl &=~WDG_CTRL_CLK_SRC_MASK;
3000dd6e:	f022 021c 	bic.w	r2, r2, #28
3000dd72:	6022      	str	r2, [r4, #0]
    base->wdg_ctrl |=WDG_CTRL_CLK_SRC(wdg_config->wdg_ctrl_config.clockSource);
3000dd74:	009b      	lsls	r3, r3, #2
3000dd76:	6822      	ldr	r2, [r4, #0]
3000dd78:	f003 031c 	and.w	r3, r3, #28
3000dd7c:	4313      	orrs	r3, r2
3000dd7e:	6023      	str	r3, [r4, #0]
    base->wdg_ctrl &= ~WDG_CTRL_PRE_DIV_NUM_MASK;
3000dd80:	6823      	ldr	r3, [r4, #0]
3000dd82:	b29b      	uxth	r3, r3
3000dd84:	6023      	str	r3, [r4, #0]
    base->wdg_ctrl |= WDG_CTRL_PRE_DIV_NUM(wdg_config->wdg_ctrl_config.prescaler);
3000dd86:	6823      	ldr	r3, [r4, #0]
3000dd88:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3000dd8c:	6023      	str	r3, [r4, #0]
    wdg_set_timeout(base,wdg_config->wdg_timeout);
3000dd8e:	6931      	ldr	r1, [r6, #16]
3000dd90:	4620      	mov	r0, r4
3000dd92:	f7ff fe25 	bl	3000d9e0 <wdg_set_timeout>
    wdg_refesh_mechanism_select(base,wdg_config);
3000dd96:	4631      	mov	r1, r6
3000dd98:	4620      	mov	r0, r4
3000dd9a:	f7ff ff07 	bl	3000dbac <wdg_refesh_mechanism_select>
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
3000dd9e:	68e3      	ldr	r3, [r4, #12]
                                |WDG_INT_ILL_SEQ_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_seq_refr_int_en)
3000dda0:	f896 c031 	ldrb.w	r12, [r6, #49]	; 0x31
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
3000dda4:	69b3      	ldr	r3, [r6, #24]
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
3000dda6:	2200      	movs	r2, #0
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
3000dda8:	f896 7030 	ldrb.w	r7, [r6, #48]	; 0x30
                                |WDG_INT_OVERFLOW_INT_EN(wdg_config->wdg_int_cfg.overflow_int_en)
3000ddac:	f896 5032 	ldrb.w	r5, [r6, #50]	; 0x32
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
3000ddb0:	60e2      	str	r2, [r4, #12]
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
3000ddb2:	68e1      	ldr	r1, [r4, #12]
3000ddb4:	4319      	orrs	r1, r3
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
3000ddb6:	69f3      	ldr	r3, [r6, #28]
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
3000ddb8:	60e1      	str	r1, [r4, #12]
    base->wdg_wrc_seq &= ~WDG_WRC_SEQ_MASK;
3000ddba:	6921      	ldr	r1, [r4, #16]
3000ddbc:	6122      	str	r2, [r4, #16]
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
3000ddbe:	6920      	ldr	r0, [r4, #16]
3000ddc0:	4318      	orrs	r0, r3
    base->wdg_tsw |= wdg_config->wdg_tsw;
3000ddc2:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
3000ddc4:	6120      	str	r0, [r4, #16]
                                |WDG_INT_ILL_SEQ_REFE_INT_CLR(wdg_config->wdg_int_cfg.ill_seq_refr_int_clr)
3000ddc6:	f896 0034 	ldrb.w	r0, [r6, #52]	; 0x34
    base->wdg_tsw &= 0x00000000;
3000ddca:	6a21      	ldr	r1, [r4, #32]
3000ddcc:	6222      	str	r2, [r4, #32]
    base->wdg_tsw |= wdg_config->wdg_tsw;
3000ddce:	6a21      	ldr	r1, [r4, #32]
3000ddd0:	4319      	orrs	r1, r3
3000ddd2:	6221      	str	r1, [r4, #32]
                                |WDG_INT_OVERFLOW_INT_CLR(wdg_config->wdg_int_cfg.overflow_int_clr);
3000ddd4:	f896 1035 	ldrb.w	r1, [r6, #53]	; 0x35
    base->wdg_int &= 0x00000000;
3000ddd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
3000ddda:	6262      	str	r2, [r4, #36]	; 0x24
                                |WDG_INT_ILL_WIN_REFE_INT_CLR(wdg_config->wdg_int_cfg.ill_win_refr_int_clr)
3000dddc:	f896 2033 	ldrb.w	r2, [r6, #51]	; 0x33
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
3000dde0:	6a63      	ldr	r3, [r4, #36]	; 0x24
3000dde2:	ea43 034c 	orr.w	r3, r3, r12, lsl #1
3000dde6:	433b      	orrs	r3, r7
3000dde8:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
3000ddec:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    base->wdg_ctrl |= WDG_CTRL_AUTO_RESTART(wdg_config->wdg_ctrl_config.enableAutostart);
3000ddf0:	7a72      	ldrb	r2, [r6, #9]
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
3000ddf2:	ea43 13c0 	orr.w	r3, r3, r0, lsl #7
    return true;
3000ddf6:	2001      	movs	r0, #1
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
3000ddf8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
3000ddfc:	6263      	str	r3, [r4, #36]	; 0x24
    base->wdg_ctrl |= WDG_CTRL_AUTO_RESTART(wdg_config->wdg_ctrl_config.enableAutostart);
3000ddfe:	6823      	ldr	r3, [r4, #0]
3000de00:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
3000de04:	6023      	str	r3, [r4, #0]
}
3000de06:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    ASSERT_PARAMETER(base);
3000de08:	2200      	movs	r2, #0
3000de0a:	4613      	mov	r3, r2
3000de0c:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000de10:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000de14:	4290      	cmp	r0, r2
3000de16:	bf18      	it	ne
3000de18:	4298      	cmpne	r0, r3
3000de1a:	f43f af70 	beq.w	3000dcfe <wdg_init+0x2e>
3000de1e:	2200      	movs	r2, #0
3000de20:	4613      	mov	r3, r2
3000de22:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000de26:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000de2a:	4290      	cmp	r0, r2
3000de2c:	bf18      	it	ne
3000de2e:	4298      	cmpne	r0, r3
3000de30:	f43f af65 	beq.w	3000dcfe <wdg_init+0x2e>
3000de34:	2000      	movs	r0, #0
}
3000de36:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    ASSERT_PARAMETER(base);
3000de38:	2200      	movs	r2, #0
3000de3a:	4613      	mov	r3, r2
3000de3c:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000de40:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000de44:	4294      	cmp	r4, r2
3000de46:	bf18      	it	ne
3000de48:	429c      	cmpne	r4, r3
3000de4a:	d086      	beq.n	3000dd5a <wdg_init+0x8a>
3000de4c:	e79f      	b.n	3000dd8e <wdg_init+0xbe>
3000de4e:	bf00      	nop

3000de50 <wdg_deInit>:
    ASSERT_PARAMETER(base);
3000de50:	2200      	movs	r2, #0
3000de52:	4613      	mov	r3, r2
3000de54:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000de58:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000de5c:	4290      	cmp	r0, r2
3000de5e:	bf18      	it	ne
3000de60:	4298      	cmpne	r0, r3
3000de62:	d01d      	beq.n	3000dea0 <wdg_deInit+0x50>
3000de64:	2300      	movs	r3, #0
3000de66:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000de6a:	4298      	cmp	r0, r3
3000de6c:	bf18      	it	ne
3000de6e:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000de72:	d015      	beq.n	3000dea0 <wdg_deInit+0x50>
3000de74:	2200      	movs	r2, #0
3000de76:	4613      	mov	r3, r2
3000de78:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000de7c:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000de80:	4290      	cmp	r0, r2
3000de82:	bf18      	it	ne
3000de84:	4298      	cmpne	r0, r3
3000de86:	d00b      	beq.n	3000dea0 <wdg_deInit+0x50>
3000de88:	2200      	movs	r2, #0
3000de8a:	4613      	mov	r3, r2
3000de8c:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000de90:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000de94:	4290      	cmp	r0, r2
3000de96:	bf18      	it	ne
3000de98:	4298      	cmpne	r0, r3
3000de9a:	d001      	beq.n	3000dea0 <wdg_deInit+0x50>
3000de9c:	2000      	movs	r0, #0
}
3000de9e:	4770      	bx	r14
{
3000dea0:	b510      	push	{r4, r14}
3000dea2:	4604      	mov	r4, r0
    wdg_unlock(base,unlock_mask);
3000dea4:	217f      	movs	r1, #127	; 0x7f
3000dea6:	f7ff fcc3 	bl	3000d830 <wdg_unlock>
    base->wdg_rst_ctl &= 0xffff0000;
3000deaa:	2200      	movs	r2, #0
    return true;
3000deac:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= 0xffff0000;
3000deae:	f6cf 72ff 	movt	r2, #65535	; 0xffff
3000deb2:	6963      	ldr	r3, [r4, #20]
3000deb4:	4013      	ands	r3, r2
3000deb6:	6163      	str	r3, [r4, #20]
    base->wdg_ext_rst_ctl &= 0xffff0000;
3000deb8:	69a3      	ldr	r3, [r4, #24]
3000deba:	4013      	ands	r3, r2
3000debc:	61a3      	str	r3, [r4, #24]
}
3000debe:	bd10      	pop	{r4, r15}

3000dec0 <wdg_set_testmode_config>:
    ASSERT_PARAMETER(base);
3000dec0:	2200      	movs	r2, #0
3000dec2:	4613      	mov	r3, r2
3000dec4:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000dec8:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000decc:	4290      	cmp	r0, r2
3000dece:	bf18      	it	ne
3000ded0:	4298      	cmpne	r0, r3
3000ded2:	d01d      	beq.n	3000df10 <wdg_set_testmode_config+0x50>
3000ded4:	2300      	movs	r3, #0
3000ded6:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000deda:	4298      	cmp	r0, r3
3000dedc:	bf18      	it	ne
3000dede:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000dee2:	d015      	beq.n	3000df10 <wdg_set_testmode_config+0x50>
3000dee4:	2200      	movs	r2, #0
3000dee6:	4613      	mov	r3, r2
3000dee8:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000deec:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000def0:	4290      	cmp	r0, r2
3000def2:	bf18      	it	ne
3000def4:	4298      	cmpne	r0, r3
3000def6:	d00b      	beq.n	3000df10 <wdg_set_testmode_config+0x50>
3000def8:	2200      	movs	r2, #0
3000defa:	4613      	mov	r3, r2
3000defc:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000df00:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000df04:	4290      	cmp	r0, r2
3000df06:	bf18      	it	ne
3000df08:	4298      	cmpne	r0, r3
3000df0a:	d001      	beq.n	3000df10 <wdg_set_testmode_config+0x50>
3000df0c:	2000      	movs	r0, #0
}
3000df0e:	4770      	bx	r14
{
3000df10:	b570      	push	{r4, r5, r6, r14}
3000df12:	4604      	mov	r4, r0
3000df14:	460d      	mov	r5, r1
    wdg_unlock(base,unlock_mask);
3000df16:	217f      	movs	r1, #127	; 0x7f
    base->wdg_wtc &= ~WDG_WTC_MASK;
3000df18:	2600      	movs	r6, #0
    wdg_unlock(base,unlock_mask);
3000df1a:	f7ff fc89 	bl	3000d830 <wdg_unlock>
    base->wdg_rst_ctl &= 0xffff0000;
3000df1e:	2100      	movs	r1, #0
3000df20:	6962      	ldr	r2, [r4, #20]
3000df22:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    base->wdg_ctrl |= WDG_CTRL_SELFTEST_TRIG(wdg_config->wdg_ctrl_config.enableSelftest);
3000df26:	7b2d      	ldrb	r5, [r5, #12]
    base->wdg_wtc |= 0xffffffff;
3000df28:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    return true;
3000df2c:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= 0xffff0000;
3000df2e:	400a      	ands	r2, r1
3000df30:	6162      	str	r2, [r4, #20]
    base->wdg_ext_rst_ctl &= 0xffff0000;
3000df32:	69a2      	ldr	r2, [r4, #24]
3000df34:	400a      	ands	r2, r1
3000df36:	61a2      	str	r2, [r4, #24]
    base->wdg_wtc &= ~WDG_WTC_MASK;
3000df38:	6862      	ldr	r2, [r4, #4]
3000df3a:	6066      	str	r6, [r4, #4]
    base->wdg_wtc |= 0xffffffff;
3000df3c:	6862      	ldr	r2, [r4, #4]
3000df3e:	6063      	str	r3, [r4, #4]
    base->wdg_ctrl |= WDG_CTRL_SELFTEST_TRIG(wdg_config->wdg_ctrl_config.enableSelftest);
3000df40:	6823      	ldr	r3, [r4, #0]
3000df42:	ea43 2345 	orr.w	r3, r3, r5, lsl #9
3000df46:	6023      	str	r3, [r4, #0]
}
3000df48:	bd70      	pop	{r4, r5, r6, r15}
3000df4a:	bf00      	nop

3000df4c <wdg_enable>:
    ASSERT_PARAMETER(base);
3000df4c:	2200      	movs	r2, #0
3000df4e:	4613      	mov	r3, r2
3000df50:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000df54:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000df58:	4290      	cmp	r0, r2
3000df5a:	bf18      	it	ne
3000df5c:	4298      	cmpne	r0, r3
3000df5e:	d007      	beq.n	3000df70 <wdg_enable+0x24>
3000df60:	2300      	movs	r3, #0
3000df62:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000df66:	4298      	cmp	r0, r3
3000df68:	bf18      	it	ne
3000df6a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000df6e:	d11e      	bne.n	3000dfae <wdg_enable+0x62>
{
3000df70:	b510      	push	{r4, r14}
3000df72:	4604      	mov	r4, r0
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
3000df74:	2101      	movs	r1, #1
3000df76:	f7ff fc5b 	bl	3000d830 <wdg_unlock>
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_MASK;
3000df7a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
3000df7e:	6822      	ldr	r2, [r4, #0]
3000df80:	f042 0202 	orr.w	r2, r2, #2
3000df84:	6022      	str	r2, [r4, #0]
3000df86:	e001      	b.n	3000df8c <wdg_enable+0x40>
    }while (--retrycount);
3000df88:	3b01      	subs	r3, #1
3000df8a:	d026      	beq.n	3000dfda <wdg_enable+0x8e>
                    v= base->wdg_ctrl;
3000df8c:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
3000df8e:	0551      	lsls	r1, r2, #21
3000df90:	d5fa      	bpl.n	3000df88 <wdg_enable+0x3c>
    base->wdg_ctrl |= WDG_CTRL_SOFT_RST(1);
3000df92:	6822      	ldr	r2, [r4, #0]
3000df94:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
3000df98:	f042 0201 	orr.w	r2, r2, #1
3000df9c:	6022      	str	r2, [r4, #0]
3000df9e:	e001      	b.n	3000dfa4 <wdg_enable+0x58>
    }while (--retrycount);
3000dfa0:	3b01      	subs	r3, #1
3000dfa2:	d01a      	beq.n	3000dfda <wdg_enable+0x8e>
                    v= base->wdg_ctrl;
3000dfa4:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
3000dfa6:	07d2      	lsls	r2, r2, #31
3000dfa8:	d4fa      	bmi.n	3000dfa0 <wdg_enable+0x54>
    return true;
3000dfaa:	2001      	movs	r0, #1
}
3000dfac:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
3000dfae:	2200      	movs	r2, #0
3000dfb0:	4613      	mov	r3, r2
3000dfb2:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000dfb6:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000dfba:	4290      	cmp	r0, r2
3000dfbc:	bf18      	it	ne
3000dfbe:	4298      	cmpne	r0, r3
3000dfc0:	d0d6      	beq.n	3000df70 <wdg_enable+0x24>
3000dfc2:	2200      	movs	r2, #0
3000dfc4:	4613      	mov	r3, r2
3000dfc6:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000dfca:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000dfce:	4290      	cmp	r0, r2
3000dfd0:	bf18      	it	ne
3000dfd2:	4298      	cmpne	r0, r3
3000dfd4:	d0cc      	beq.n	3000df70 <wdg_enable+0x24>
3000dfd6:	2000      	movs	r0, #0
}
3000dfd8:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000dfda:	2000      	movs	r0, #0
}
3000dfdc:	bd10      	pop	{r4, r15}
3000dfde:	bf00      	nop

3000dfe0 <wdg_disable>:
    ASSERT_PARAMETER(base);
3000dfe0:	2200      	movs	r2, #0
3000dfe2:	4613      	mov	r3, r2
3000dfe4:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000dfe8:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000dfec:	4290      	cmp	r0, r2
3000dfee:	bf18      	it	ne
3000dff0:	4298      	cmpne	r0, r3
3000dff2:	d007      	beq.n	3000e004 <wdg_disable+0x24>
3000dff4:	2300      	movs	r3, #0
3000dff6:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000dffa:	4298      	cmp	r0, r3
3000dffc:	bf18      	it	ne
3000dffe:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e002:	d115      	bne.n	3000e030 <wdg_disable+0x50>
{
3000e004:	b510      	push	{r4, r14}
3000e006:	4604      	mov	r4, r0
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
3000e008:	2101      	movs	r1, #1
3000e00a:	f7ff fc11 	bl	3000d830 <wdg_unlock>
    base->wdg_ctrl |= WDG_CTRL_SOFT_RST(1);
3000e00e:	2364      	movs	r3, #100	; 0x64
3000e010:	6822      	ldr	r2, [r4, #0]
3000e012:	f042 0201 	orr.w	r2, r2, #1
3000e016:	6022      	str	r2, [r4, #0]
3000e018:	e001      	b.n	3000e01e <wdg_disable+0x3e>
    }while (--retrycount);
3000e01a:	3b01      	subs	r3, #1
3000e01c:	d01e      	beq.n	3000e05c <wdg_disable+0x7c>
                    v= base->wdg_ctrl;
3000e01e:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
3000e020:	07d2      	lsls	r2, r2, #31
3000e022:	d4fa      	bmi.n	3000e01a <wdg_disable+0x3a>
    base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_MASK;
3000e024:	6823      	ldr	r3, [r4, #0]
    return true;
3000e026:	2001      	movs	r0, #1
    base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_MASK;
3000e028:	f023 0302 	bic.w	r3, r3, #2
3000e02c:	6023      	str	r3, [r4, #0]
}
3000e02e:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
3000e030:	2200      	movs	r2, #0
3000e032:	4613      	mov	r3, r2
3000e034:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e038:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e03c:	4290      	cmp	r0, r2
3000e03e:	bf18      	it	ne
3000e040:	4298      	cmpne	r0, r3
3000e042:	d0df      	beq.n	3000e004 <wdg_disable+0x24>
3000e044:	2200      	movs	r2, #0
3000e046:	4613      	mov	r3, r2
3000e048:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e04c:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e050:	4290      	cmp	r0, r2
3000e052:	bf18      	it	ne
3000e054:	4298      	cmpne	r0, r3
3000e056:	d0d5      	beq.n	3000e004 <wdg_disable+0x24>
3000e058:	2000      	movs	r0, #0
}
3000e05a:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000e05c:	2000      	movs	r0, #0
}
3000e05e:	bd10      	pop	{r4, r15}

3000e060 <wdg_enable_Interrupts>:
    ASSERT_PARAMETER(base);
3000e060:	2200      	movs	r2, #0
{
3000e062:	b538      	push	{r3, r4, r5, r14}
    ASSERT_PARAMETER(base);
3000e064:	4613      	mov	r3, r2
3000e066:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e06a:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e06e:	4290      	cmp	r0, r2
3000e070:	bf18      	it	ne
3000e072:	4298      	cmpne	r0, r3
3000e074:	d007      	beq.n	3000e086 <wdg_enable_Interrupts+0x26>
3000e076:	2300      	movs	r3, #0
3000e078:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e07c:	4298      	cmp	r0, r3
3000e07e:	bf18      	it	ne
3000e080:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e084:	d110      	bne.n	3000e0a8 <wdg_enable_Interrupts+0x48>
3000e086:	4604      	mov	r4, r0
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e088:	f7ff fdee 	bl	3000dc68 <wdg_get_refesh_mechanism>
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
3000e08c:	2120      	movs	r1, #32
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e08e:	4605      	mov	r5, r0
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
3000e090:	4620      	mov	r0, r4
3000e092:	f7ff fbcd 	bl	3000d830 <wdg_unlock>
    switch (refresh_mechanism) {
3000e096:	2d02      	cmp	r5, #2
3000e098:	d029      	beq.n	3000e0ee <wdg_enable_Interrupts+0x8e>
3000e09a:	2d03      	cmp	r5, #3
3000e09c:	d01b      	beq.n	3000e0d6 <wdg_enable_Interrupts+0x76>
3000e09e:	2d01      	cmp	r5, #1
    return true;
3000e0a0:	bf18      	it	ne
3000e0a2:	2001      	movne	r0, #1
    switch (refresh_mechanism) {
3000e0a4:	d01d      	beq.n	3000e0e2 <wdg_enable_Interrupts+0x82>
}
3000e0a6:	bd38      	pop	{r3, r4, r5, r15}
    ASSERT_PARAMETER(base);
3000e0a8:	2200      	movs	r2, #0
3000e0aa:	4613      	mov	r3, r2
3000e0ac:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e0b0:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e0b4:	4290      	cmp	r0, r2
3000e0b6:	bf18      	it	ne
3000e0b8:	4298      	cmpne	r0, r3
3000e0ba:	d0e4      	beq.n	3000e086 <wdg_enable_Interrupts+0x26>
3000e0bc:	2200      	movs	r2, #0
3000e0be:	4613      	mov	r3, r2
3000e0c0:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e0c4:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e0c8:	4290      	cmp	r0, r2
3000e0ca:	bf18      	it	ne
3000e0cc:	4298      	cmpne	r0, r3
3000e0ce:	bf18      	it	ne
3000e0d0:	2000      	movne	r0, #0
3000e0d2:	d0d8      	beq.n	3000e086 <wdg_enable_Interrupts+0x26>
3000e0d4:	e7e7      	b.n	3000e0a6 <wdg_enable_Interrupts+0x46>
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
3000e0d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e0d8:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
3000e0da:	f043 0302 	orr.w	r3, r3, #2
3000e0de:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e0e0:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int |= WDG_INT_OVERFLOW_INT_EN_MASK;
3000e0e2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e0e4:	4628      	mov	r0, r5
            base->wdg_int |= WDG_INT_OVERFLOW_INT_EN_MASK;
3000e0e6:	f043 0304 	orr.w	r3, r3, #4
3000e0ea:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e0ec:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
3000e0ee:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e0f0:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
3000e0f2:	4303      	orrs	r3, r0
3000e0f4:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e0f6:	bd38      	pop	{r3, r4, r5, r15}

3000e0f8 <wdg_disable_Interrupts>:
    ASSERT_PARAMETER(base);
3000e0f8:	2200      	movs	r2, #0
{
3000e0fa:	b538      	push	{r3, r4, r5, r14}
    ASSERT_PARAMETER(base);
3000e0fc:	4613      	mov	r3, r2
3000e0fe:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e102:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e106:	4290      	cmp	r0, r2
3000e108:	bf18      	it	ne
3000e10a:	4298      	cmpne	r0, r3
3000e10c:	d007      	beq.n	3000e11e <wdg_disable_Interrupts+0x26>
3000e10e:	2300      	movs	r3, #0
3000e110:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e114:	4298      	cmp	r0, r3
3000e116:	bf18      	it	ne
3000e118:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e11c:	d110      	bne.n	3000e140 <wdg_disable_Interrupts+0x48>
3000e11e:	4604      	mov	r4, r0
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e120:	f7ff fda2 	bl	3000dc68 <wdg_get_refesh_mechanism>
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
3000e124:	2120      	movs	r1, #32
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e126:	4605      	mov	r5, r0
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
3000e128:	4620      	mov	r0, r4
3000e12a:	f7ff fb81 	bl	3000d830 <wdg_unlock>
    switch (refresh_mechanism) {
3000e12e:	2d02      	cmp	r5, #2
3000e130:	d029      	beq.n	3000e186 <wdg_disable_Interrupts+0x8e>
3000e132:	2d03      	cmp	r5, #3
3000e134:	d01b      	beq.n	3000e16e <wdg_disable_Interrupts+0x76>
3000e136:	2d01      	cmp	r5, #1
    return true;
3000e138:	bf18      	it	ne
3000e13a:	2001      	movne	r0, #1
    switch (refresh_mechanism) {
3000e13c:	d01d      	beq.n	3000e17a <wdg_disable_Interrupts+0x82>
}
3000e13e:	bd38      	pop	{r3, r4, r5, r15}
    ASSERT_PARAMETER(base);
3000e140:	2200      	movs	r2, #0
3000e142:	4613      	mov	r3, r2
3000e144:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e148:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e14c:	4290      	cmp	r0, r2
3000e14e:	bf18      	it	ne
3000e150:	4298      	cmpne	r0, r3
3000e152:	d0e4      	beq.n	3000e11e <wdg_disable_Interrupts+0x26>
3000e154:	2200      	movs	r2, #0
3000e156:	4613      	mov	r3, r2
3000e158:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e15c:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e160:	4290      	cmp	r0, r2
3000e162:	bf18      	it	ne
3000e164:	4298      	cmpne	r0, r3
3000e166:	bf18      	it	ne
3000e168:	2000      	movne	r0, #0
3000e16a:	d0d8      	beq.n	3000e11e <wdg_disable_Interrupts+0x26>
3000e16c:	e7e7      	b.n	3000e13e <wdg_disable_Interrupts+0x46>
            base->wdg_int &= ~WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
3000e16e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e170:	2001      	movs	r0, #1
            base->wdg_int &= ~WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
3000e172:	f023 0302 	bic.w	r3, r3, #2
3000e176:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e178:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int &= ~WDG_INT_OVERFLOW_INT_EN_MASK;
3000e17a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e17c:	4628      	mov	r0, r5
            base->wdg_int &= ~WDG_INT_OVERFLOW_INT_EN_MASK;
3000e17e:	f023 0304 	bic.w	r3, r3, #4
3000e182:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e184:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int &= ~WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
3000e186:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
3000e188:	2001      	movs	r0, #1
            base->wdg_int &= ~WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
3000e18a:	f023 0301 	bic.w	r3, r3, #1
3000e18e:	6263      	str	r3, [r4, #36]	; 0x24
}
3000e190:	bd38      	pop	{r3, r4, r5, r15}
3000e192:	bf00      	nop

3000e194 <wdg_get_status_flag>:
    ASSERT_PARAMETER(base);
3000e194:	2100      	movs	r1, #0
{
3000e196:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e198:	460a      	mov	r2, r1
3000e19a:	f2cf 011c 	movt	r1, #61468	; 0xf01c
3000e19e:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e1a2:	4288      	cmp	r0, r1
3000e1a4:	bf18      	it	ne
3000e1a6:	4290      	cmpne	r0, r2
3000e1a8:	d01d      	beq.n	3000e1e6 <wdg_get_status_flag+0x52>
3000e1aa:	2200      	movs	r2, #0
3000e1ac:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e1b0:	4290      	cmp	r0, r2
3000e1b2:	bf18      	it	ne
3000e1b4:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e1b8:	d015      	beq.n	3000e1e6 <wdg_get_status_flag+0x52>
3000e1ba:	2100      	movs	r1, #0
3000e1bc:	460a      	mov	r2, r1
3000e1be:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
3000e1c2:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e1c6:	4288      	cmp	r0, r1
3000e1c8:	bf18      	it	ne
3000e1ca:	4290      	cmpne	r0, r2
3000e1cc:	d00b      	beq.n	3000e1e6 <wdg_get_status_flag+0x52>
3000e1ce:	2100      	movs	r1, #0
3000e1d0:	460a      	mov	r2, r1
3000e1d2:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
3000e1d6:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e1da:	4288      	cmp	r0, r1
3000e1dc:	bf18      	it	ne
3000e1de:	4290      	cmpne	r0, r2
3000e1e0:	d001      	beq.n	3000e1e6 <wdg_get_status_flag+0x52>
3000e1e2:	2000      	movs	r0, #0
}
3000e1e4:	4770      	bx	r14
    status_flag |= (base->wdg_ctrl & WDG_CTRL_WDG_EN_STA_MASK);
3000e1e6:	6818      	ldr	r0, [r3, #0]
    status_flag |= (base->wdg_int & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
3000e1e8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    temp_test =base->wdg_int;
3000e1ea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    status_flag |= (base->wdg_ctrl & WDG_CTRL_WDG_EN_STA_MASK);
3000e1ec:	f400 6080 	and.w	r0, r0, #1024	; 0x400
    status_flag |= (base->wdg_int & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
3000e1f0:	f002 0238 	and.w	r2, r2, #56	; 0x38
3000e1f4:	4310      	orrs	r0, r2
    return status_flag;
3000e1f6:	4770      	bx	r14

3000e1f8 <wdg_clear_status_flag>:
{
3000e1f8:	b410      	push	{r4}
    ASSERT_PARAMETER(base);
3000e1fa:	2400      	movs	r4, #0
{
3000e1fc:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e1fe:	4622      	mov	r2, r4
3000e200:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000e204:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e208:	42a0      	cmp	r0, r4
3000e20a:	bf18      	it	ne
3000e20c:	4290      	cmpne	r0, r2
3000e20e:	d007      	beq.n	3000e220 <wdg_clear_status_flag+0x28>
3000e210:	2200      	movs	r2, #0
3000e212:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e216:	4290      	cmp	r0, r2
3000e218:	bf18      	it	ne
3000e21a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e21e:	d10f      	bne.n	3000e240 <wdg_clear_status_flag+0x48>
    return true;
3000e220:	2001      	movs	r0, #1
    if(mask & WDG_CTRL_WDG_EN_STA_MASK){
3000e222:	054a      	lsls	r2, r1, #21
    base->wdg_int &= ~(mask & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
3000e224:	f001 0138 	and.w	r1, r1, #56	; 0x38
        base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_STA_MASK;
3000e228:	bf42      	ittt	mi
3000e22a:	681a      	ldrmi	r2, [r3, #0]
3000e22c:	f422 6280 	bicmi.w	r2, r2, #1024	; 0x400
3000e230:	601a      	strmi	r2, [r3, #0]
    base->wdg_int &= ~(mask & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
3000e232:	6a5a      	ldr	r2, [r3, #36]	; 0x24
3000e234:	ea22 0101 	bic.w	r1, r2, r1
3000e238:	6259      	str	r1, [r3, #36]	; 0x24
}
3000e23a:	f85d 4b04 	ldr.w	r4, [r13], #4
3000e23e:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000e240:	2000      	movs	r0, #0
3000e242:	4602      	mov	r2, r0
3000e244:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000e248:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e24c:	4283      	cmp	r3, r0
3000e24e:	bf18      	it	ne
3000e250:	4293      	cmpne	r3, r2
3000e252:	d0e5      	beq.n	3000e220 <wdg_clear_status_flag+0x28>
3000e254:	2000      	movs	r0, #0
3000e256:	4602      	mov	r2, r0
3000e258:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000e25c:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e260:	4283      	cmp	r3, r0
3000e262:	bf18      	it	ne
3000e264:	4293      	cmpne	r3, r2
3000e266:	bf18      	it	ne
3000e268:	2000      	movne	r0, #0
3000e26a:	d0d9      	beq.n	3000e220 <wdg_clear_status_flag+0x28>
3000e26c:	e7e5      	b.n	3000e23a <wdg_clear_status_flag+0x42>
3000e26e:	bf00      	nop

3000e270 <wdg_refresh>:
//*****************************************************************************
bool wdg_refresh(wdg_reg_type_t *base)
{
    uint32_t refresh_mechanism = wdg_mechanism_mode1;
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e270:	2200      	movs	r2, #0
{
3000e272:	b508      	push	{r3, r14}
    ASSERT_PARAMETER(base);
3000e274:	4613      	mov	r3, r2
3000e276:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e27a:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e27e:	4290      	cmp	r0, r2
3000e280:	bf18      	it	ne
3000e282:	4298      	cmpne	r0, r3
3000e284:	d01b      	beq.n	3000e2be <wdg_refresh+0x4e>
3000e286:	2300      	movs	r3, #0
3000e288:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e28c:	4298      	cmp	r0, r3
3000e28e:	bf18      	it	ne
3000e290:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e294:	d013      	beq.n	3000e2be <wdg_refresh+0x4e>
3000e296:	2200      	movs	r2, #0
3000e298:	4613      	mov	r3, r2
3000e29a:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e29e:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e2a2:	4290      	cmp	r0, r2
3000e2a4:	bf18      	it	ne
3000e2a6:	4298      	cmpne	r0, r3
3000e2a8:	d009      	beq.n	3000e2be <wdg_refresh+0x4e>
3000e2aa:	2200      	movs	r2, #0
3000e2ac:	4613      	mov	r3, r2
3000e2ae:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e2b2:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e2b6:	4290      	cmp	r0, r2
3000e2b8:	bf18      	it	ne
3000e2ba:	4298      	cmpne	r0, r3
3000e2bc:	d116      	bne.n	3000e2ec <wdg_refresh+0x7c>
3000e2be:	4601      	mov	r1, r0

    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e2c0:	f7ff fcd2 	bl	3000dc68 <wdg_get_refesh_mechanism>

    if(refresh_mechanism > wdg_mechanism_mode_max){
3000e2c4:	2803      	cmp	r0, #3
3000e2c6:	d811      	bhi.n	3000e2ec <wdg_refresh+0x7c>
        return false;
    }

    //LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "refresh_mechanism after:%d\n",refresh_mechanism);

    switch (refresh_mechanism) {
3000e2c8:	b198      	cbz	r0, 3000e2f2 <wdg_refresh+0x82>
3000e2ca:	2802      	cmp	r0, #2
3000e2cc:	d914      	bls.n	3000e2f8 <wdg_refresh+0x88>
3000e2ce:	2803      	cmp	r0, #3
3000e2d0:	d10f      	bne.n	3000e2f2 <wdg_refresh+0x82>
        }
        case wdg_mechanism_mode3:
        {
            // 3.read wdg_cnt and record it as tsr ref WatchdogMechanism3UpdataWdtCnt func
            // 4.write tsr to wdg_tsw. refesh will happen if the condition was right.
            uint32_t wdg_number = wdg_addr_to_number(base);
3000e2d2:	4608      	mov	r0, r1
3000e2d4:	f7ff fae0 	bl	3000d898 <wdg_addr_to_number>
            //LTRACEF("watchdog mode set err wdg_number:%d,g_tsr[%d]:0x%x\n",wdg_number,wdg_number,g_tsr[wdg_number]);
            base->wdg_tsw = g_tsr[wdg_number];
3000e2d8:	f24a 5200 	movw	r2, #42240	; 0xa500
            LTRACEF("watchdog mode set err refresh_mode:%d\n",refresh_mechanism);
            break;
        }
    }

    return true;
3000e2dc:	2301      	movs	r3, #1
            base->wdg_tsw = g_tsr[wdg_number];
3000e2de:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000e2e2:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
}
3000e2e6:	4618      	mov	r0, r3
            base->wdg_tsw = g_tsr[wdg_number];
3000e2e8:	620a      	str	r2, [r1, #32]
}
3000e2ea:	bd08      	pop	{r3, r15}
    ASSERT_PARAMETER(base);
3000e2ec:	2300      	movs	r3, #0
}
3000e2ee:	4618      	mov	r0, r3
3000e2f0:	bd08      	pop	{r3, r15}
    return true;
3000e2f2:	2301      	movs	r3, #1
}
3000e2f4:	4618      	mov	r0, r3
3000e2f6:	bd08      	pop	{r3, r15}
            base->wdg_wrc_ctl |=WDG_WRC_CTRL_REFR_TRIG_MASK;
3000e2f8:	688a      	ldr	r2, [r1, #8]
    return true;
3000e2fa:	2301      	movs	r3, #1
}
3000e2fc:	4618      	mov	r0, r3
            base->wdg_wrc_ctl |=WDG_WRC_CTRL_REFR_TRIG_MASK;
3000e2fe:	f042 0208 	orr.w	r2, r2, #8
3000e302:	608a      	str	r2, [r1, #8]
}
3000e304:	bd08      	pop	{r3, r15}
3000e306:	bf00      	nop

3000e308 <wdg_set_reset_cnt>:
//!
//! \return true or false
//
//*****************************************************************************
bool wdg_set_reset_cnt(wdg_reg_type_t *base,uint32_t rst_delay)
{
3000e308:	b410      	push	{r4}
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e30a:	2400      	movs	r4, #0
{
3000e30c:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e30e:	4622      	mov	r2, r4
3000e310:	f2cf 041c 	movt	r4, #61468	; 0xf01c
3000e314:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e318:	42a0      	cmp	r0, r4
3000e31a:	bf18      	it	ne
3000e31c:	4290      	cmpne	r0, r2
3000e31e:	d007      	beq.n	3000e330 <wdg_set_reset_cnt+0x28>
3000e320:	2200      	movs	r2, #0
3000e322:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e326:	4290      	cmp	r0, r2
3000e328:	bf18      	it	ne
3000e32a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e32e:	d107      	bne.n	3000e340 <wdg_set_reset_cnt+0x38>

    //base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
    base->wdg_rst_ctl |=WDG_RST_CTRL_RST_CNT(rst_delay);
3000e330:	695a      	ldr	r2, [r3, #20]
3000e332:	b289      	uxth	r1, r1

    return true;
3000e334:	2001      	movs	r0, #1
    base->wdg_rst_ctl |=WDG_RST_CTRL_RST_CNT(rst_delay);
3000e336:	4311      	orrs	r1, r2
3000e338:	6159      	str	r1, [r3, #20]
}
3000e33a:	f85d 4b04 	ldr.w	r4, [r13], #4
3000e33e:	4770      	bx	r14
    ASSERT_PARAMETER(base);
3000e340:	2000      	movs	r0, #0
3000e342:	4602      	mov	r2, r0
3000e344:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
3000e348:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e34c:	4283      	cmp	r3, r0
3000e34e:	bf18      	it	ne
3000e350:	4293      	cmpne	r3, r2
3000e352:	d0ed      	beq.n	3000e330 <wdg_set_reset_cnt+0x28>
3000e354:	2000      	movs	r0, #0
3000e356:	4602      	mov	r2, r0
3000e358:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
3000e35c:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e360:	4283      	cmp	r3, r0
3000e362:	bf18      	it	ne
3000e364:	4293      	cmpne	r3, r2
3000e366:	bf18      	it	ne
3000e368:	2000      	movne	r0, #0
3000e36a:	d0e1      	beq.n	3000e330 <wdg_set_reset_cnt+0x28>
3000e36c:	e7e5      	b.n	3000e33a <wdg_set_reset_cnt+0x32>
3000e36e:	bf00      	nop

3000e370 <wdg_get_reset_cnt>:
uint32_t wdg_get_reset_cnt(wdg_reg_type_t *base)
{
    uint32_t reset_cnt = 0U;

    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e370:	2200      	movs	r2, #0
3000e372:	4613      	mov	r3, r2
3000e374:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e378:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e37c:	4290      	cmp	r0, r2
3000e37e:	bf18      	it	ne
3000e380:	4298      	cmpne	r0, r3
3000e382:	d01d      	beq.n	3000e3c0 <wdg_get_reset_cnt+0x50>
3000e384:	2300      	movs	r3, #0
3000e386:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e38a:	4298      	cmp	r0, r3
3000e38c:	bf18      	it	ne
3000e38e:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e392:	d015      	beq.n	3000e3c0 <wdg_get_reset_cnt+0x50>
3000e394:	2200      	movs	r2, #0
3000e396:	4613      	mov	r3, r2
3000e398:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e39c:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e3a0:	4290      	cmp	r0, r2
3000e3a2:	bf18      	it	ne
3000e3a4:	4298      	cmpne	r0, r3
3000e3a6:	d00b      	beq.n	3000e3c0 <wdg_get_reset_cnt+0x50>
3000e3a8:	2200      	movs	r2, #0
3000e3aa:	4613      	mov	r3, r2
3000e3ac:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e3b0:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e3b4:	4290      	cmp	r0, r2
3000e3b6:	bf18      	it	ne
3000e3b8:	4298      	cmpne	r0, r3
3000e3ba:	d001      	beq.n	3000e3c0 <wdg_get_reset_cnt+0x50>
3000e3bc:	2000      	movs	r0, #0

    reset_cnt |= (base->wdg_rst_ctl & WDG_RST_CTRL_RST_CNT_MASK);

    return reset_cnt;
}
3000e3be:	4770      	bx	r14
    reset_cnt |= (base->wdg_rst_ctl & WDG_RST_CTRL_RST_CNT_MASK);
3000e3c0:	6940      	ldr	r0, [r0, #20]
3000e3c2:	b280      	uxth	r0, r0
    return reset_cnt;
3000e3c4:	4770      	bx	r14
3000e3c6:	bf00      	nop

3000e3c8 <wdg_clear_reset_cnt>:
//
//*****************************************************************************
bool wdg_clear_reset_cnt(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e3c8:	2100      	movs	r1, #0
{
3000e3ca:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e3cc:	460a      	mov	r2, r1
3000e3ce:	f2cf 011c 	movt	r1, #61468	; 0xf01c
3000e3d2:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e3d6:	4288      	cmp	r0, r1
3000e3d8:	bf18      	it	ne
3000e3da:	4290      	cmpne	r0, r2
3000e3dc:	d01d      	beq.n	3000e41a <wdg_clear_reset_cnt+0x52>
3000e3de:	2200      	movs	r2, #0
3000e3e0:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e3e4:	4290      	cmp	r0, r2
3000e3e6:	bf18      	it	ne
3000e3e8:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e3ec:	d015      	beq.n	3000e41a <wdg_clear_reset_cnt+0x52>
3000e3ee:	2100      	movs	r1, #0
3000e3f0:	460a      	mov	r2, r1
3000e3f2:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
3000e3f6:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e3fa:	4288      	cmp	r0, r1
3000e3fc:	bf18      	it	ne
3000e3fe:	4290      	cmpne	r0, r2
3000e400:	d00b      	beq.n	3000e41a <wdg_clear_reset_cnt+0x52>
3000e402:	2100      	movs	r1, #0
3000e404:	460a      	mov	r2, r1
3000e406:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
3000e40a:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e40e:	4288      	cmp	r0, r1
3000e410:	bf18      	it	ne
3000e412:	4290      	cmpne	r0, r2
3000e414:	d001      	beq.n	3000e41a <wdg_clear_reset_cnt+0x52>
3000e416:	2000      	movs	r0, #0

    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;

    return true;
}
3000e418:	4770      	bx	r14
    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
3000e41a:	695a      	ldr	r2, [r3, #20]
    return true;
3000e41c:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
3000e41e:	0c12      	lsrs	r2, r2, #16
3000e420:	0412      	lsls	r2, r2, #16
3000e422:	615a      	str	r2, [r3, #20]
    return true;
3000e424:	4770      	bx	r14
3000e426:	bf00      	nop

3000e428 <wdg_get_ext_reset_cnt>:
uint32_t wdg_get_ext_reset_cnt(wdg_reg_type_t *base)
{
    uint32_t ext_reset_cnt = 0U;

    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e428:	2200      	movs	r2, #0
3000e42a:	4613      	mov	r3, r2
3000e42c:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e430:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e434:	4290      	cmp	r0, r2
3000e436:	bf18      	it	ne
3000e438:	4298      	cmpne	r0, r3
3000e43a:	d01d      	beq.n	3000e478 <wdg_get_ext_reset_cnt+0x50>
3000e43c:	2300      	movs	r3, #0
3000e43e:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e442:	4298      	cmp	r0, r3
3000e444:	bf18      	it	ne
3000e446:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e44a:	d015      	beq.n	3000e478 <wdg_get_ext_reset_cnt+0x50>
3000e44c:	2200      	movs	r2, #0
3000e44e:	4613      	mov	r3, r2
3000e450:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e454:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e458:	4290      	cmp	r0, r2
3000e45a:	bf18      	it	ne
3000e45c:	4298      	cmpne	r0, r3
3000e45e:	d00b      	beq.n	3000e478 <wdg_get_ext_reset_cnt+0x50>
3000e460:	2200      	movs	r2, #0
3000e462:	4613      	mov	r3, r2
3000e464:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e468:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e46c:	4290      	cmp	r0, r2
3000e46e:	bf18      	it	ne
3000e470:	4298      	cmpne	r0, r3
3000e472:	d001      	beq.n	3000e478 <wdg_get_ext_reset_cnt+0x50>
3000e474:	2000      	movs	r0, #0

    ext_reset_cnt |= (base->wdg_ext_rst_ctl & WDG_EXT_RST_CTRL_RST_CNT_MASK);

    return ext_reset_cnt;
}
3000e476:	4770      	bx	r14
    ext_reset_cnt |= (base->wdg_ext_rst_ctl & WDG_EXT_RST_CTRL_RST_CNT_MASK);
3000e478:	6980      	ldr	r0, [r0, #24]
3000e47a:	b280      	uxth	r0, r0
    return ext_reset_cnt;
3000e47c:	4770      	bx	r14
3000e47e:	bf00      	nop

3000e480 <wdg_clear_ext_reset_cnt>:
//
//*****************************************************************************
bool wdg_clear_ext_reset_cnt(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e480:	2100      	movs	r1, #0
{
3000e482:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e484:	460a      	mov	r2, r1
3000e486:	f2cf 011c 	movt	r1, #61468	; 0xf01c
3000e48a:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e48e:	4288      	cmp	r0, r1
3000e490:	bf18      	it	ne
3000e492:	4290      	cmpne	r0, r2
3000e494:	d01d      	beq.n	3000e4d2 <wdg_clear_ext_reset_cnt+0x52>
3000e496:	2200      	movs	r2, #0
3000e498:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e49c:	4290      	cmp	r0, r2
3000e49e:	bf18      	it	ne
3000e4a0:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e4a4:	d015      	beq.n	3000e4d2 <wdg_clear_ext_reset_cnt+0x52>
3000e4a6:	2100      	movs	r1, #0
3000e4a8:	460a      	mov	r2, r1
3000e4aa:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
3000e4ae:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e4b2:	4288      	cmp	r0, r1
3000e4b4:	bf18      	it	ne
3000e4b6:	4290      	cmpne	r0, r2
3000e4b8:	d00b      	beq.n	3000e4d2 <wdg_clear_ext_reset_cnt+0x52>
3000e4ba:	2100      	movs	r1, #0
3000e4bc:	460a      	mov	r2, r1
3000e4be:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
3000e4c2:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e4c6:	4288      	cmp	r0, r1
3000e4c8:	bf18      	it	ne
3000e4ca:	4290      	cmpne	r0, r2
3000e4cc:	d001      	beq.n	3000e4d2 <wdg_clear_ext_reset_cnt+0x52>
3000e4ce:	2000      	movs	r0, #0

    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;

    return true;
}
3000e4d0:	4770      	bx	r14
    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;
3000e4d2:	699a      	ldr	r2, [r3, #24]
    return true;
3000e4d4:	2001      	movs	r0, #1
    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;
3000e4d6:	0c12      	lsrs	r2, r2, #16
3000e4d8:	0412      	lsls	r2, r2, #16
3000e4da:	619a      	str	r2, [r3, #24]
    return true;
3000e4dc:	4770      	bx	r14
3000e4de:	bf00      	nop

3000e4e0 <wdg_Int_register>:
//!
//! \return true or false.
//
//*****************************************************************************
bool wdg_Int_register(void *handle,wdg_reg_type_t *base,int_handler call_func,bool overflow_int)
{
3000e4e0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    uint32_t refresh_mechanism = 0;
    uint32_t wdg_int_num = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e4e4:	2500      	movs	r5, #0
{
3000e4e6:	4606      	mov	r6, r0
    ASSERT_PARAMETER(base);
3000e4e8:	462c      	mov	r4, r5
3000e4ea:	f2cf 051c 	movt	r5, #61468	; 0xf01c
{
3000e4ee:	4617      	mov	r7, r2
    ASSERT_PARAMETER(base);
3000e4f0:	f2cf 041d 	movt	r4, #61469	; 0xf01d
{
3000e4f4:	4698      	mov	r8, r3
    ASSERT_PARAMETER(base);
3000e4f6:	42a9      	cmp	r1, r5
3000e4f8:	bf18      	it	ne
3000e4fa:	42a1      	cmpne	r1, r4
3000e4fc:	d007      	beq.n	3000e50e <wdg_Int_register+0x2e>
3000e4fe:	2200      	movs	r2, #0
3000e500:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e504:	4291      	cmp	r1, r2
3000e506:	bf18      	it	ne
3000e508:	f111 6f76 	cmnne.w	r1, #257949696	; 0xf600000
3000e50c:	d13b      	bne.n	3000e586 <wdg_Int_register+0xa6>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "wdg_Int_register:\n");
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e50e:	4608      	mov	r0, r1
3000e510:	f7ff fbaa 	bl	3000dc68 <wdg_get_refesh_mechanism>
    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog  refresh_mechanism:%d\n",refresh_mechanism);
    if(WDG1_BASE == base){
3000e514:	2200      	movs	r2, #0
3000e516:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e51a:	4291      	cmp	r1, r2
3000e51c:	d024      	beq.n	3000e568 <wdg_Int_register+0x88>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }else if(WDG2_BASE == base){
3000e51e:	2200      	movs	r2, #0
3000e520:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e524:	4291      	cmp	r1, r2
        if(overflow_int){
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
3000e526:	bf08      	it	eq
3000e528:	2437      	moveq	r4, #55	; 0x37
    }else if(WDG2_BASE == base){
3000e52a:	d021      	beq.n	3000e570 <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG2_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
        }
    }else if(WDG3_BASE == base){
3000e52c:	f111 6f76 	cmn.w	r1, #257949696	; 0xf600000
3000e530:	d041      	beq.n	3000e5b6 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
        }
    }else if(WDG4_BASE == base){
3000e532:	2300      	movs	r3, #0
3000e534:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e538:	4299      	cmp	r1, r3
3000e53a:	d03c      	beq.n	3000e5b6 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG4_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG4_OVFLOW_INT_NUM;
        }
    }else if(WDG5_BASE == base){
3000e53c:	2300      	movs	r3, #0
3000e53e:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
3000e542:	4299      	cmp	r1, r3
3000e544:	d037      	beq.n	3000e5b6 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG5_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG5_OVFLOW_INT_NUM;
        }
    }else if(WDG6_BASE == base){
3000e546:	2300      	movs	r3, #0
3000e548:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e54c:	4299      	cmp	r1, r3
3000e54e:	d032      	beq.n	3000e5b6 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG6_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG6_OVFLOW_INT_NUM;
        }
    }else if(WDG7_BASE == base){
3000e550:	2300      	movs	r3, #0
3000e552:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
3000e556:	4299      	cmp	r1, r3
        if(overflow_int){
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
3000e558:	bf08      	it	eq
3000e55a:	243b      	moveq	r4, #59	; 0x3b
    }else if(WDG7_BASE == base){
3000e55c:	d008      	beq.n	3000e570 <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG7_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
        }
    }else if(WDG8_BASE == base){
3000e55e:	2300      	movs	r3, #0
3000e560:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e564:	4299      	cmp	r1, r3
3000e566:	d038      	beq.n	3000e5da <wdg_Int_register+0xfa>
            wdg_int_num = WDG8_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
        }
    }else{
        if(overflow_int){
3000e568:	f1b8 0f00 	cmp.w	r8, #0
3000e56c:	d02e      	beq.n	3000e5cc <wdg_Int_register+0xec>
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
3000e56e:	24dc      	movs	r4, #220	; 0xdc
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_int_num:%d\n",wdg_int_num);
    register_int_handler(wdg_int_num,call_func,handle);
3000e570:	4632      	mov	r2, r6
3000e572:	4639      	mov	r1, r7
3000e574:	4620      	mov	r0, r4
3000e576:	f7f2 f89b 	bl	300006b0 <register_int_handler>
    unmask_interrupt(wdg_int_num);
3000e57a:	4620      	mov	r0, r4
3000e57c:	f7f2 f8ea 	bl	30000754 <unmask_interrupt>
    return true;
3000e580:	2001      	movs	r0, #1
}
3000e582:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    ASSERT_PARAMETER(base);
3000e586:	2200      	movs	r2, #0
3000e588:	4613      	mov	r3, r2
3000e58a:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e58e:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e592:	4291      	cmp	r1, r2
3000e594:	bf18      	it	ne
3000e596:	4299      	cmpne	r1, r3
3000e598:	d0b9      	beq.n	3000e50e <wdg_Int_register+0x2e>
3000e59a:	2200      	movs	r2, #0
3000e59c:	4613      	mov	r3, r2
3000e59e:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e5a2:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e5a6:	4291      	cmp	r1, r2
3000e5a8:	bf18      	it	ne
3000e5aa:	4299      	cmpne	r1, r3
3000e5ac:	d113      	bne.n	3000e5d6 <wdg_Int_register+0xf6>
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e5ae:	4608      	mov	r0, r1
3000e5b0:	f7ff fb5a 	bl	3000dc68 <wdg_get_refesh_mechanism>
3000e5b4:	e7ba      	b.n	3000e52c <wdg_Int_register+0x4c>
        if(overflow_int){
3000e5b6:	f1b8 0f00 	cmp.w	r8, #0
3000e5ba:	d001      	beq.n	3000e5c0 <wdg_Int_register+0xe0>
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
3000e5bc:	24de      	movs	r4, #222	; 0xde
3000e5be:	e7d7      	b.n	3000e570 <wdg_Int_register+0x90>
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
3000e5c0:	f010 0f03 	tst.w	r0, #3
3000e5c4:	bf0c      	ite	eq
3000e5c6:	24de      	moveq	r4, #222	; 0xde
3000e5c8:	24dd      	movne	r4, #221	; 0xdd
3000e5ca:	e7d1      	b.n	3000e570 <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
3000e5cc:	0783      	lsls	r3, r0, #30
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
3000e5ce:	bf18      	it	ne
3000e5d0:	24db      	movne	r4, #219	; 0xdb
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
3000e5d2:	d1cd      	bne.n	3000e570 <wdg_Int_register+0x90>
3000e5d4:	e7cb      	b.n	3000e56e <wdg_Int_register+0x8e>
    ASSERT_PARAMETER(base);
3000e5d6:	2000      	movs	r0, #0
3000e5d8:	e7d3      	b.n	3000e582 <wdg_Int_register+0xa2>
        if(overflow_int){
3000e5da:	f1b8 0f00 	cmp.w	r8, #0
3000e5de:	d105      	bne.n	3000e5ec <wdg_Int_register+0x10c>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
3000e5e0:	f010 0f03 	tst.w	r0, #3
3000e5e4:	bf14      	ite	ne
3000e5e6:	24df      	movne	r4, #223	; 0xdf
3000e5e8:	24e0      	moveq	r4, #224	; 0xe0
3000e5ea:	e7c1      	b.n	3000e570 <wdg_Int_register+0x90>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
3000e5ec:	24e0      	movs	r4, #224	; 0xe0
3000e5ee:	e7bf      	b.n	3000e570 <wdg_Int_register+0x90>

3000e5f0 <wdg_int_unregister>:
bool wdg_int_unregister(wdg_reg_type_t *base,bool overflow_int)
{
    uint32_t refresh_mechanism = 0;
    uint32_t wdg_int_num = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e5f0:	2200      	movs	r2, #0
3000e5f2:	4613      	mov	r3, r2
3000e5f4:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e5f8:	f2cf 031d 	movt	r3, #61469	; 0xf01d
{
3000e5fc:	b510      	push	{r4, r14}
3000e5fe:	4604      	mov	r4, r0
    ASSERT_PARAMETER(base);
3000e600:	4290      	cmp	r0, r2
3000e602:	bf18      	it	ne
3000e604:	4298      	cmpne	r0, r3
3000e606:	d007      	beq.n	3000e618 <wdg_int_unregister+0x28>
3000e608:	2300      	movs	r3, #0
3000e60a:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e60e:	4298      	cmp	r0, r3
3000e610:	bf18      	it	ne
3000e612:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e616:	d132      	bne.n	3000e67e <wdg_int_unregister+0x8e>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "wdg_int_unregister:\n");
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e618:	4620      	mov	r0, r4
3000e61a:	f7ff fb25 	bl	3000dc68 <wdg_get_refesh_mechanism>
    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog refresh_mechanism:%d\n",refresh_mechanism);

    if(WDG1_BASE ==base){
3000e61e:	2300      	movs	r3, #0
3000e620:	f2cf 031c 	movt	r3, #61468	; 0xf01c
3000e624:	429c      	cmp	r4, r3
3000e626:	d047      	beq.n	3000e6b8 <wdg_int_unregister+0xc8>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }else if(WDG2_BASE ==base){
3000e628:	2300      	movs	r3, #0
3000e62a:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e62e:	429c      	cmp	r4, r3
        if(overflow_int){
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
3000e630:	bf08      	it	eq
3000e632:	2037      	moveq	r0, #55	; 0x37
    }else if(WDG2_BASE ==base){
3000e634:	d01f      	beq.n	3000e676 <wdg_int_unregister+0x86>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG2_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
        }
    }else if(WDG3_BASE ==base){
3000e636:	f114 6f76 	cmn.w	r4, #257949696	; 0xf600000
3000e63a:	d037      	beq.n	3000e6ac <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
        }
    }else if(WDG4_BASE ==base){
3000e63c:	2300      	movs	r3, #0
3000e63e:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e642:	429c      	cmp	r4, r3
3000e644:	d032      	beq.n	3000e6ac <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG4_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG4_OVFLOW_INT_NUM;
        }
    }else if(WDG5_BASE ==base){
3000e646:	2300      	movs	r3, #0
3000e648:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
3000e64c:	429c      	cmp	r4, r3
3000e64e:	d02d      	beq.n	3000e6ac <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG5_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG5_OVFLOW_INT_NUM;
        }
    }else if(WDG6_BASE ==base){
3000e650:	2300      	movs	r3, #0
3000e652:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e656:	429c      	cmp	r4, r3
3000e658:	d028      	beq.n	3000e6ac <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG6_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG6_OVFLOW_INT_NUM;
        }
    }else if(WDG7_BASE ==base){
3000e65a:	2300      	movs	r3, #0
3000e65c:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
3000e660:	429c      	cmp	r4, r3
        if(overflow_int){
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
3000e662:	bf08      	it	eq
3000e664:	203b      	moveq	r0, #59	; 0x3b
    }else if(WDG7_BASE ==base){
3000e666:	d006      	beq.n	3000e676 <wdg_int_unregister+0x86>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG7_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
        }
    }else if(WDG8_BASE ==base){
3000e668:	2300      	movs	r3, #0
3000e66a:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e66e:	429c      	cmp	r4, r3
    uint32_t wdg_int_num = 0;
3000e670:	bf18      	it	ne
3000e672:	2000      	movne	r0, #0
    }else if(WDG8_BASE ==base){
3000e674:	d03a      	beq.n	3000e6ec <wdg_int_unregister+0xfc>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
        }
    }

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_int_num:%d\n",wdg_int_num);
    mask_interrupt(wdg_int_num);
3000e676:	f7f2 f845 	bl	30000704 <mask_interrupt>
    return true;
3000e67a:	2001      	movs	r0, #1
}
3000e67c:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
3000e67e:	2200      	movs	r2, #0
3000e680:	4613      	mov	r3, r2
3000e682:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e686:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e68a:	4290      	cmp	r0, r2
3000e68c:	bf18      	it	ne
3000e68e:	4298      	cmpne	r0, r3
3000e690:	d0c2      	beq.n	3000e618 <wdg_int_unregister+0x28>
3000e692:	2200      	movs	r2, #0
3000e694:	4613      	mov	r3, r2
3000e696:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e69a:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e69e:	4290      	cmp	r0, r2
3000e6a0:	bf18      	it	ne
3000e6a2:	4298      	cmpne	r0, r3
3000e6a4:	d120      	bne.n	3000e6e8 <wdg_int_unregister+0xf8>
    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e6a6:	f7ff fadf 	bl	3000dc68 <wdg_get_refesh_mechanism>
3000e6aa:	e7c4      	b.n	3000e636 <wdg_int_unregister+0x46>
        if(overflow_int){
3000e6ac:	b151      	cbz	r1, 3000e6c4 <wdg_int_unregister+0xd4>
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
3000e6ae:	20de      	movs	r0, #222	; 0xde
    mask_interrupt(wdg_int_num);
3000e6b0:	f7f2 f828 	bl	30000704 <mask_interrupt>
    return true;
3000e6b4:	2001      	movs	r0, #1
3000e6b6:	e7e1      	b.n	3000e67c <wdg_int_unregister+0x8c>
        if(overflow_int){
3000e6b8:	b169      	cbz	r1, 3000e6d6 <wdg_int_unregister+0xe6>
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
3000e6ba:	20dc      	movs	r0, #220	; 0xdc
    mask_interrupt(wdg_int_num);
3000e6bc:	f7f2 f822 	bl	30000704 <mask_interrupt>
    return true;
3000e6c0:	2001      	movs	r0, #1
3000e6c2:	e7db      	b.n	3000e67c <wdg_int_unregister+0x8c>
            wdg_int_num = WDG3_ILL_WIN_REFR_INT_NUM;
3000e6c4:	f010 0f02 	tst.w	r0, #2
3000e6c8:	bf0c      	ite	eq
3000e6ca:	20de      	moveq	r0, #222	; 0xde
3000e6cc:	20dd      	movne	r0, #221	; 0xdd
    mask_interrupt(wdg_int_num);
3000e6ce:	f7f2 f819 	bl	30000704 <mask_interrupt>
    return true;
3000e6d2:	2001      	movs	r0, #1
3000e6d4:	e7d2      	b.n	3000e67c <wdg_int_unregister+0x8c>
            wdg_int_num = WDG1_ILL_WIN_REFR_INT_NUM;
3000e6d6:	f010 0f02 	tst.w	r0, #2
3000e6da:	bf0c      	ite	eq
3000e6dc:	20dc      	moveq	r0, #220	; 0xdc
3000e6de:	20db      	movne	r0, #219	; 0xdb
    mask_interrupt(wdg_int_num);
3000e6e0:	f7f2 f810 	bl	30000704 <mask_interrupt>
    return true;
3000e6e4:	2001      	movs	r0, #1
3000e6e6:	e7c9      	b.n	3000e67c <wdg_int_unregister+0x8c>
    ASSERT_PARAMETER(base);
3000e6e8:	2000      	movs	r0, #0
}
3000e6ea:	bd10      	pop	{r4, r15}
        if(overflow_int){
3000e6ec:	b929      	cbnz	r1, 3000e6fa <wdg_int_unregister+0x10a>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
3000e6ee:	f010 0f02 	tst.w	r0, #2
3000e6f2:	bf14      	ite	ne
3000e6f4:	20df      	movne	r0, #223	; 0xdf
3000e6f6:	20e0      	moveq	r0, #224	; 0xe0
3000e6f8:	e7bd      	b.n	3000e676 <wdg_int_unregister+0x86>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
3000e6fa:	20e0      	movs	r0, #224	; 0xe0
3000e6fc:	e7bb      	b.n	3000e676 <wdg_int_unregister+0x86>
3000e6fe:	bf00      	nop

3000e700 <wdg_int_clear>:
//*****************************************************************************
bool wdg_int_clear(wdg_reg_type_t *base)
{
    uint32_t refresh_mechanism = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e700:	2200      	movs	r2, #0
{
3000e702:	b508      	push	{r3, r14}
    ASSERT_PARAMETER(base);
3000e704:	4613      	mov	r3, r2
3000e706:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e70a:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e70e:	4290      	cmp	r0, r2
3000e710:	bf18      	it	ne
3000e712:	4298      	cmpne	r0, r3
3000e714:	d007      	beq.n	3000e726 <wdg_int_clear+0x26>
3000e716:	2300      	movs	r3, #0
3000e718:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e71c:	4298      	cmp	r0, r3
3000e71e:	bf18      	it	ne
3000e720:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e724:	d10a      	bne.n	3000e73c <wdg_int_clear+0x3c>
3000e726:	4601      	mov	r1, r0

    refresh_mechanism = wdg_get_refesh_mechanism(base);
3000e728:	f7ff fa9e 	bl	3000dc68 <wdg_get_refesh_mechanism>

    switch (refresh_mechanism) {
3000e72c:	2802      	cmp	r0, #2
3000e72e:	d025      	beq.n	3000e77c <wdg_int_clear+0x7c>
3000e730:	2803      	cmp	r0, #3
3000e732:	d018      	beq.n	3000e766 <wdg_int_clear+0x66>
3000e734:	2801      	cmp	r0, #1
3000e736:	d01c      	beq.n	3000e772 <wdg_int_clear+0x72>
            break;
        }
        default:
        {
            LTRACEF("watchdog int enable err refresh_mechanism:%d\n",refresh_mechanism);
            return false;
3000e738:	2000      	movs	r0, #0
        }
    }
    return true;
}
3000e73a:	bd08      	pop	{r3, r15}
    ASSERT_PARAMETER(base);
3000e73c:	2200      	movs	r2, #0
3000e73e:	4613      	mov	r3, r2
3000e740:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e744:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e748:	4290      	cmp	r0, r2
3000e74a:	bf18      	it	ne
3000e74c:	4298      	cmpne	r0, r3
3000e74e:	d0ea      	beq.n	3000e726 <wdg_int_clear+0x26>
3000e750:	2200      	movs	r2, #0
3000e752:	4613      	mov	r3, r2
3000e754:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e758:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e75c:	4290      	cmp	r0, r2
3000e75e:	bf18      	it	ne
3000e760:	4298      	cmpne	r0, r3
3000e762:	d0e0      	beq.n	3000e726 <wdg_int_clear+0x26>
3000e764:	e7e8      	b.n	3000e738 <wdg_int_clear+0x38>
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_CLR_MASK;
3000e766:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    return true;
3000e768:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_CLR_MASK;
3000e76a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
3000e76e:	624b      	str	r3, [r1, #36]	; 0x24
}
3000e770:	bd08      	pop	{r3, r15}
            base->wdg_int |= WDG_INT_OVERFLOW_INT_CLR_MASK;
3000e772:	6a4b      	ldr	r3, [r1, #36]	; 0x24
3000e774:	f443 7380 	orr.w	r3, r3, #256	; 0x100
3000e778:	624b      	str	r3, [r1, #36]	; 0x24
}
3000e77a:	bd08      	pop	{r3, r15}
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_CLR_MASK;
3000e77c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    return true;
3000e77e:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_CLR_MASK;
3000e780:	f043 0340 	orr.w	r3, r3, #64	; 0x40
3000e784:	624b      	str	r3, [r1, #36]	; 0x24
}
3000e786:	bd08      	pop	{r3, r15}

3000e788 <wdg_halt_enable>:
//
//*****************************************************************************
bool wdg_halt_enable(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e788:	2100      	movs	r1, #0
{
3000e78a:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e78c:	460a      	mov	r2, r1
3000e78e:	f2cf 011c 	movt	r1, #61468	; 0xf01c
3000e792:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e796:	4288      	cmp	r0, r1
3000e798:	bf18      	it	ne
3000e79a:	4290      	cmpne	r0, r2
3000e79c:	d01d      	beq.n	3000e7da <wdg_halt_enable+0x52>
3000e79e:	2200      	movs	r2, #0
3000e7a0:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e7a4:	4290      	cmp	r0, r2
3000e7a6:	bf18      	it	ne
3000e7a8:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e7ac:	d015      	beq.n	3000e7da <wdg_halt_enable+0x52>
3000e7ae:	2100      	movs	r1, #0
3000e7b0:	460a      	mov	r2, r1
3000e7b2:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
3000e7b6:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e7ba:	4288      	cmp	r0, r1
3000e7bc:	bf18      	it	ne
3000e7be:	4290      	cmpne	r0, r2
3000e7c0:	d00b      	beq.n	3000e7da <wdg_halt_enable+0x52>
3000e7c2:	2100      	movs	r1, #0
3000e7c4:	460a      	mov	r2, r1
3000e7c6:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
3000e7ca:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e7ce:	4288      	cmp	r0, r1
3000e7d0:	bf18      	it	ne
3000e7d2:	4290      	cmpne	r0, r2
3000e7d4:	d001      	beq.n	3000e7da <wdg_halt_enable+0x52>
3000e7d6:	2000      	movs	r0, #0
    // Enable timer stalling.
    //
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;

    return true;
}
3000e7d8:	4770      	bx	r14
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;
3000e7da:	681a      	ldr	r2, [r3, #0]
    return true;
3000e7dc:	2001      	movs	r0, #1
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;
3000e7de:	f042 0280 	orr.w	r2, r2, #128	; 0x80
3000e7e2:	601a      	str	r2, [r3, #0]
    return true;
3000e7e4:	4770      	bx	r14
3000e7e6:	bf00      	nop

3000e7e8 <wdg_halt_disable>:
//
//*****************************************************************************
bool wdg_halt_disable(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
3000e7e8:	2100      	movs	r1, #0
{
3000e7ea:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
3000e7ec:	460a      	mov	r2, r1
3000e7ee:	f2cf 011c 	movt	r1, #61468	; 0xf01c
3000e7f2:	f2cf 021d 	movt	r2, #61469	; 0xf01d
3000e7f6:	4288      	cmp	r0, r1
3000e7f8:	bf18      	it	ne
3000e7fa:	4290      	cmpne	r0, r2
3000e7fc:	d01d      	beq.n	3000e83a <wdg_halt_disable+0x52>
3000e7fe:	2200      	movs	r2, #0
3000e800:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
3000e804:	4290      	cmp	r0, r2
3000e806:	bf18      	it	ne
3000e808:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e80c:	d015      	beq.n	3000e83a <wdg_halt_disable+0x52>
3000e80e:	2100      	movs	r1, #0
3000e810:	460a      	mov	r2, r1
3000e812:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
3000e816:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
3000e81a:	4288      	cmp	r0, r1
3000e81c:	bf18      	it	ne
3000e81e:	4290      	cmpne	r0, r2
3000e820:	d00b      	beq.n	3000e83a <wdg_halt_disable+0x52>
3000e822:	2100      	movs	r1, #0
3000e824:	460a      	mov	r2, r1
3000e826:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
3000e82a:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
3000e82e:	4288      	cmp	r0, r1
3000e830:	bf18      	it	ne
3000e832:	4290      	cmpne	r0, r2
3000e834:	d001      	beq.n	3000e83a <wdg_halt_disable+0x52>
3000e836:	2000      	movs	r0, #0
    // Disable timer stalling.
    //
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);

    return true;
}
3000e838:	4770      	bx	r14
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);
3000e83a:	681a      	ldr	r2, [r3, #0]
    return true;
3000e83c:	2001      	movs	r0, #1
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);
3000e83e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
3000e842:	601a      	str	r2, [r3, #0]
    return true;
3000e844:	4770      	bx	r14
3000e846:	bf00      	nop

3000e848 <wdg_get_cnt>:

uint32_t wdg_get_cnt(wdg_reg_type_t *base)
{
    ASSERT_PARAMETER(base);
3000e848:	2200      	movs	r2, #0
3000e84a:	4613      	mov	r3, r2
3000e84c:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e850:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e854:	4290      	cmp	r0, r2
3000e856:	bf18      	it	ne
3000e858:	4298      	cmpne	r0, r3
3000e85a:	d01d      	beq.n	3000e898 <wdg_get_cnt+0x50>
3000e85c:	2300      	movs	r3, #0
3000e85e:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e862:	4298      	cmp	r0, r3
3000e864:	bf18      	it	ne
3000e866:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e86a:	d015      	beq.n	3000e898 <wdg_get_cnt+0x50>
3000e86c:	2200      	movs	r2, #0
3000e86e:	4613      	mov	r3, r2
3000e870:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e874:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e878:	4290      	cmp	r0, r2
3000e87a:	bf18      	it	ne
3000e87c:	4298      	cmpne	r0, r3
3000e87e:	d00b      	beq.n	3000e898 <wdg_get_cnt+0x50>
3000e880:	2200      	movs	r2, #0
3000e882:	4613      	mov	r3, r2
3000e884:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e888:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e88c:	4290      	cmp	r0, r2
3000e88e:	bf18      	it	ne
3000e890:	4298      	cmpne	r0, r3
3000e892:	d001      	beq.n	3000e898 <wdg_get_cnt+0x50>
3000e894:	2000      	movs	r0, #0
    return base->wdg_cnt;
}
3000e896:	4770      	bx	r14
    return base->wdg_cnt;
3000e898:	69c0      	ldr	r0, [r0, #28]
3000e89a:	4770      	bx	r14

3000e89c <wdg_set_reset>:
bool wdg_set_reset(wdg_reg_type_t *base,const wdg_config_t* wdg_config)
{
    uint32_t unlock_mask = WDG_LOCK_RST_LOCK_MASK
                            |WDG_LOCK_EXT_RST_LOCK_MASK;

    ASSERT_PARAMETER(base);
3000e89c:	2200      	movs	r2, #0
{
3000e89e:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ASSERT_PARAMETER(base);
3000e8a0:	4613      	mov	r3, r2
3000e8a2:	f2cf 021c 	movt	r2, #61468	; 0xf01c
3000e8a6:	f2cf 031d 	movt	r3, #61469	; 0xf01d
3000e8aa:	4290      	cmp	r0, r2
3000e8ac:	bf18      	it	ne
3000e8ae:	4298      	cmpne	r0, r3
3000e8b0:	d01d      	beq.n	3000e8ee <wdg_set_reset+0x52>
3000e8b2:	2300      	movs	r3, #0
3000e8b4:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
3000e8b8:	4298      	cmp	r0, r3
3000e8ba:	bf18      	it	ne
3000e8bc:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
3000e8c0:	d015      	beq.n	3000e8ee <wdg_set_reset+0x52>
3000e8c2:	2200      	movs	r2, #0
3000e8c4:	4613      	mov	r3, r2
3000e8c6:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
3000e8ca:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
3000e8ce:	4290      	cmp	r0, r2
3000e8d0:	bf18      	it	ne
3000e8d2:	4298      	cmpne	r0, r3
3000e8d4:	d00b      	beq.n	3000e8ee <wdg_set_reset+0x52>
3000e8d6:	2200      	movs	r2, #0
3000e8d8:	4613      	mov	r3, r2
3000e8da:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
3000e8de:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
3000e8e2:	4290      	cmp	r0, r2
3000e8e4:	bf18      	it	ne
3000e8e6:	4298      	cmpne	r0, r3
3000e8e8:	bf18      	it	ne
3000e8ea:	2000      	movne	r0, #0
3000e8ec:	d134      	bne.n	3000e958 <wdg_set_reset+0xbc>
3000e8ee:	4604      	mov	r4, r0
3000e8f0:	460d      	mov	r5, r1
    wdg_unlock(base,unlock_mask);
3000e8f2:	2118      	movs	r1, #24
3000e8f4:	f7fe ff9c 	bl	3000d830 <wdg_unlock>

    wdg_set_reset_cnt(base,0xf);
3000e8f8:	210f      	movs	r1, #15
3000e8fa:	4620      	mov	r0, r4
3000e8fc:	f7ff fd04 	bl	3000e308 <wdg_set_reset_cnt>
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e900:	6963      	ldr	r3, [r4, #20]
                                        |WDG_RST_CTRL_INT_RST_EN(wdg_config->wdg_reset_cfg.enableSysReset)
3000e902:	f895 1022 	ldrb.w	r1, [r5, #34]	; 0x22
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e906:	8c2a      	ldrh	r2, [r5, #32]
                                        |WDG_RST_CTRL_RST_WIN(wdg_config->wdg_reset_cfg.plusRstWind);

    //set ext reset ctrl clear reset mode,not need ext reset mode,if need reset pmic so need config
    base->wdg_ext_rst_ctl &= 0x00000000;
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
                                        |WDG_EXT_RST_CTRL_INT_RST_EN(wdg_config->wdg_ext_reset_cfg.enableSysExtReset)
3000e908:	f895 7028 	ldrb.w	r7, [r5, #40]	; 0x28
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
3000e90c:	8cee      	ldrh	r6, [r5, #38]	; 0x26
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
                                        |WDG_EXT_RST_CTRL_RST_WIN(wdg_config->wdg_ext_reset_cfg.plusRstWind);

    return true;
3000e90e:	2001      	movs	r0, #1
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e910:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
3000e914:	4313      	orrs	r3, r2
                                        |WDG_RST_CTRL_WDG_RST_EN(wdg_config->wdg_reset_cfg.enableWdgResetEn)
3000e916:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
3000e91a:	f895 2023 	ldrb.w	r2, [r5, #35]	; 0x23
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e91e:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
3000e922:	0452      	lsls	r2, r2, #17
                                        |WDG_RST_CTRL_RST_WIN(wdg_config->wdg_reset_cfg.plusRstWind);
3000e924:	f895 1025 	ldrb.w	r1, [r5, #37]	; 0x25
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
3000e928:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e92c:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
3000e930:	4313      	orrs	r3, r2
    base->wdg_ext_rst_ctl &= 0x00000000;
3000e932:	2200      	movs	r2, #0
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
3000e934:	6163      	str	r3, [r4, #20]
    base->wdg_ext_rst_ctl &= 0x00000000;
3000e936:	69a3      	ldr	r3, [r4, #24]
3000e938:	61a2      	str	r2, [r4, #24]
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
3000e93a:	f895 2029 	ldrb.w	r2, [r5, #41]	; 0x29
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
3000e93e:	69a3      	ldr	r3, [r4, #24]
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
3000e940:	0452      	lsls	r2, r2, #17
                                        |WDG_EXT_RST_CTRL_RST_WIN(wdg_config->wdg_ext_reset_cfg.plusRstWind);
3000e942:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
3000e946:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
3000e94a:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
3000e94e:	4333      	orrs	r3, r6
3000e950:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
3000e954:	4313      	orrs	r3, r2
3000e956:	61a3      	str	r3, [r4, #24]
}
3000e958:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
3000e95a:	bf00      	nop

3000e95c <mbox_init>:

#endif //if defined(CONFIG_SUPPORT_DCF) && (CONFIG_SUPPORT_DCF == 1)

static void *mbox_handle;
void mbox_init(void)
{
3000e95c:	b510      	push	{r4, r14}
    hal_mb_cfg_t hal_cfg;

    hal_mb_create_handle(&mbox_handle, RES_MB_MB_MEM);
3000e95e:	f24a 5424 	movw	r4, #42276	; 0xa524
3000e962:	f44f 5180 	mov.w	r1, #4096	; 0x1000
3000e966:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000e96a:	4620      	mov	r0, r4
{
3000e96c:	b090      	sub	sp, #64	; 0x40
    hal_mb_create_handle(&mbox_handle, RES_MB_MB_MEM);
3000e96e:	f6c1 0102 	movt	r1, #6146	; 0x1802
3000e972:	f000 fa09 	bl	3000ed88 <hal_mb_create_handle>
    if (mbox_handle != NULL) {
3000e976:	6820      	ldr	r0, [r4, #0]
3000e978:	b110      	cbz	r0, 3000e980 <mbox_init+0x24>
        hal_mb_init(mbox_handle, &hal_cfg);
3000e97a:	a901      	add	r1, sp, #4
3000e97c:	f000 fa02 	bl	3000ed84 <hal_mb_init>
    }
}
3000e980:	b010      	add	sp, #64	; 0x40
3000e982:	bd10      	pop	{r4, r15}

3000e984 <dcf_init>:
}

static bool dcf_inited;

void dcf_init(void)
{
3000e984:	b510      	push	{r4, r14}
    if (dcf_inited)
3000e986:	f24a 5420 	movw	r4, #42272	; 0xa520
3000e98a:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000e98e:	7823      	ldrb	r3, [r4, #0]
3000e990:	b103      	cbz	r3, 3000e994 <dcf_init+0x10>
    rpmsg_rtos_init();
#endif

#endif
    dcf_inited = true;
}
3000e992:	bd10      	pop	{r4, r15}
    mbox_init();
3000e994:	f7ff ffe2 	bl	3000e95c <mbox_init>
    dcf_inited = true;
3000e998:	2301      	movs	r3, #1
3000e99a:	7023      	strb	r3, [r4, #0]
}
3000e99c:	bd10      	pop	{r4, r15}
3000e99e:	bf00      	nop

3000e9a0 <sysd_sem_handler>:
        return 0;
    }
}

static enum handler_return sysd_sem_handler(void *arg)
{
3000e9a0:	b510      	push	{r4, r14}

    sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, false);
3000e9a2:	f24a 5428 	movw	r4, #42280	; 0xa528
3000e9a6:	2200      	movs	r2, #0
3000e9a8:	2102      	movs	r1, #2
3000e9aa:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000e9ae:	6ba0      	ldr	r0, [r4, #56]	; 0x38
3000e9b0:	f004 f838 	bl	30012a24 <sem_enable_intr>
    event_signal(&sem_handle.evt, false);
3000e9b4:	4620      	mov	r0, r4
3000e9b6:	2100      	movs	r1, #0
3000e9b8:	f002 ffb8 	bl	3001192c <event_signal>

    return INT_RESCHEDULE;
}
3000e9bc:	2001      	movs	r0, #1
3000e9be:	bd10      	pop	{r4, r15}

3000e9c0 <sysd_worker>:
        }
    }
}

static void sysd_worker(enum sem sem)
{
3000e9c0:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}

    sem_handle.sem = sem;
3000e9c4:	f24a 5628 	movw	r6, #42280	; 0xa528
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
3000e9c8:	2800      	cmp	r0, #0
{
3000e9ca:	4603      	mov	r3, r0
    sem_handle.sem = sem;
3000e9cc:	f2c3 0602 	movt	r6, #12290	; 0x3002
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
3000e9d0:	bf0c      	ite	eq
3000e9d2:	252e      	moveq	r5, #46	; 0x2e
3000e9d4:	252f      	movne	r5, #47	; 0x2f

    event_init(&sem_handle.evt,false,1);
3000e9d6:	2100      	movs	r1, #0
3000e9d8:	4630      	mov	r0, r6
3000e9da:	2201      	movs	r2, #1
    mutex_init(&sem_handle.lock);

    mutex_acquire(&sem_handle.lock);

    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000e9dc:	460c      	mov	r4, r1
    sem_handle.sem = sem;
3000e9de:	63b3      	str	r3, [r6, #56]	; 0x38
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
3000e9e0:	87b5      	strh	r5, [r6, #60]	; 0x3c
    event_init(&sem_handle.evt,false,1);
3000e9e2:	f002 ff67 	bl	300118b4 <event_init>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000e9e6:	f240 153f 	movw	r5, #319	; 0x13f
    mutex_init(&sem_handle.lock);
3000e9ea:	f106 001c 	add.w	r0, r6, #28
3000e9ee:	f002 ffe3 	bl	300119b8 <mutex_init>
3000e9f2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000e9f6:	f106 001c 	add.w	r0, r6, #28
3000e9fa:	f003 f817 	bl	30011a2c <mutex_acquire_timeout>
    {
        sem_map_signal(sem_handle.sem, s,SEM_INTR_CPU,false);
3000e9fe:	4621      	mov	r1, r4
3000ea00:	2300      	movs	r3, #0
3000ea02:	2202      	movs	r2, #2
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000ea04:	3401      	adds	r4, #1
        sem_map_signal(sem_handle.sem, s,SEM_INTR_CPU,false);
3000ea06:	6bb0      	ldr	r0, [r6, #56]	; 0x38
3000ea08:	f004 f82e 	bl	30012a68 <sem_map_signal>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000ea0c:	42ac      	cmp	r4, r5
3000ea0e:	d1f6      	bne.n	3000e9fe <sysd_worker+0x3e>
    }

    register_int_handler(sem_handle.irq, sysd_sem_handler, NULL);
3000ea10:	f64e 11a1 	movw	r1, #59809	; 0xe9a1
3000ea14:	2200      	movs	r2, #0
3000ea16:	8fb0      	ldrh	r0, [r6, #60]	; 0x3c
3000ea18:	f24a 5928 	movw	r9, #42280	; 0xa528
3000ea1c:	f2c3 0100 	movt	r1, #12288	; 0x3000
3000ea20:	f7f1 fe46 	bl	300006b0 <register_int_handler>
    unmask_interrupt(sem_handle.irq);
3000ea24:	8fb0      	ldrh	r0, [r6, #60]	; 0x3c
3000ea26:	f7f1 fe95 	bl	30000754 <unmask_interrupt>


    sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, true);
3000ea2a:	2201      	movs	r2, #1
3000ea2c:	2102      	movs	r1, #2
3000ea2e:	f2c3 0902 	movt	r9, #12290	; 0x3002
3000ea32:	6bb0      	ldr	r0, [r6, #56]	; 0x38
3000ea34:	f24a 5868 	movw	r8, #42344	; 0xa568
3000ea38:	f003 fff4 	bl	30012a24 <sem_enable_intr>

    mutex_release(&sem_handle.lock);
3000ea3c:	f109 001c 	add.w	r0, r9, #28
3000ea40:	f003 f820 	bl	30011a84 <mutex_release>
3000ea44:	f109 0a1c 	add.w	r10, r9, #28
3000ea48:	f2c3 0802 	movt	r8, #12290	; 0x3002
3000ea4c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000ea50:	4648      	mov	r0, r9
3000ea52:	f002 ff45 	bl	300118e0 <event_wait_timeout>
3000ea56:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3000ea5a:	4650      	mov	r0, r10
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000ea5c:	2500      	movs	r5, #0
3000ea5e:	f002 ffe5 	bl	30011a2c <mutex_acquire_timeout>
3000ea62:	f240 173f 	movw	r7, #319	; 0x13f
3000ea66:	e002      	b.n	3000ea6e <sysd_worker+0xae>
3000ea68:	3501      	adds	r5, #1
3000ea6a:	42bd      	cmp	r5, r7
3000ea6c:	d017      	beq.n	3000ea9e <sysd_worker+0xde>
        if (sem_signal_status(sem_handle.sem, s))
3000ea6e:	6bb0      	ldr	r0, [r6, #56]	; 0x38
3000ea70:	4629      	mov	r1, r5
3000ea72:	f003 ffe7 	bl	30012a44 <sem_signal_status>
3000ea76:	2800      	cmp	r0, #0
3000ea78:	d0f6      	beq.n	3000ea68 <sysd_worker+0xa8>
    sysd_handler_t* sysd = total_signals[signal].head;
3000ea7a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
3000ea7e:	eb08 0383 	add.w	r3, r8, r3, lsl #2
3000ea82:	685c      	ldr	r4, [r3, #4]
    while(sysd)
3000ea84:	2c00      	cmp	r4, #0
3000ea86:	d0ef      	beq.n	3000ea68 <sysd_worker+0xa8>
        if(sysd->evt_cb)
3000ea88:	68a3      	ldr	r3, [r4, #8]
            sysd->evt_cb(signal,sysd->args);
3000ea8a:	4628      	mov	r0, r5
        if(sysd->evt_cb)
3000ea8c:	b10b      	cbz	r3, 3000ea92 <sysd_worker+0xd2>
            sysd->evt_cb(signal,sysd->args);
3000ea8e:	68e1      	ldr	r1, [r4, #12]
3000ea90:	4798      	blx	r3
        sysd = sysd->next;
3000ea92:	6824      	ldr	r4, [r4, #0]
    while(sysd)
3000ea94:	2c00      	cmp	r4, #0
3000ea96:	d1f7      	bne.n	3000ea88 <sysd_worker+0xc8>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
3000ea98:	3501      	adds	r5, #1
3000ea9a:	42bd      	cmp	r5, r7
3000ea9c:	d1e7      	bne.n	3000ea6e <sysd_worker+0xae>
        event_wait(&sem_handle.evt);

        mutex_acquire(&sem_handle.lock);

        sysd_dispatcher();
        sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, true);
3000ea9e:	6bb0      	ldr	r0, [r6, #56]	; 0x38
3000eaa0:	2201      	movs	r2, #1
3000eaa2:	2102      	movs	r1, #2
3000eaa4:	f003 ffbe 	bl	30012a24 <sem_enable_intr>

        mutex_release(&sem_handle.lock);
3000eaa8:	4650      	mov	r0, r10
3000eaaa:	f002 ffeb 	bl	30011a84 <mutex_release>
3000eaae:	e7cd      	b.n	3000ea4c <sysd_worker+0x8c>

3000eab0 <sysd_start>:
    }
}

void sysd_start(enum sem sem)
{
3000eab0:	b500      	push	{r14}
    thread_t* sysd = thread_create("sysd",(thread_start_routine)sysd_worker,(void*)sem,THREAD_PRI_SYSDIAG,SYSD_WORKER_STACK_SZ);
3000eab2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
{
3000eab6:	b083      	sub	sp, #12
    thread_t* sysd = thread_create("sysd",(thread_start_routine)sysd_worker,(void*)sem,THREAD_PRI_SYSDIAG,SYSD_WORKER_STACK_SZ);
3000eab8:	4602      	mov	r2, r0
3000eaba:	f64e 11c1 	movw	r1, #59841	; 0xe9c1
3000eabe:	f64e 30b4 	movw	r0, #60340	; 0xebb4
3000eac2:	f2c3 0100 	movt	r1, #12288	; 0x3000
3000eac6:	9300      	str	r3, [sp, #0]
3000eac8:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000eacc:	2310      	movs	r3, #16
3000eace:	f003 f9df 	bl	30011e90 <thread_create>
    thread_detach_and_resume(sysd);
}
3000ead2:	b003      	add	sp, #12
3000ead4:	f85d eb04 	ldr.w	r14, [r13], #4
    thread_detach_and_resume(sysd);
3000ead8:	f003 bd44 	b.w	30012564 <thread_detach_and_resume>

3000eadc <hal_clock_get_instance>:
//!
//! \return clkgen hanle
//
//*****************************************************************************
static clkgen_instance_t *hal_clock_get_instance(void)
{
3000eadc:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000eade:	f3ef 8000 	mrs	r0, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000eae2:	f010 0080 	ands.w	r0, r0, #128	; 0x80
3000eae6:	d129      	bne.n	3000eb3c <hal_clock_get_instance+0x60>
    __asm__ volatile("cpsid i");
3000eae8:	b672      	cpsid	i
    *statep = state;
3000eaea:	f24b 4284 	movw	r2, #46212	; 0xb484
3000eaee:	2101      	movs	r1, #1
    *lock = 1;
3000eaf0:	f24b 435c 	movw	r3, #46172	; 0xb45c
    *statep = state;
3000eaf4:	f2c3 0202 	movt	r2, #12290	; 0x3002
    //spin_lock_saved_state_t states;
    spin_lock_irqsave(&clkgen_spin_lock, spin_lock_states);

    if (g_ClkgenInstance.occupied != 1) {
3000eaf8:	f24b 4460 	movw	r4, #46176	; 0xb460
    *lock = 1;
3000eafc:	f2c3 0302 	movt	r3, #12290	; 0x3002
    *statep = state;
3000eb00:	6011      	str	r1, [r2, #0]
3000eb02:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000eb06:	7f22      	ldrb	r2, [r4, #28]
    *lock = 1;
3000eb08:	6019      	str	r1, [r3, #0]
3000eb0a:	428a      	cmp	r2, r1
3000eb0c:	d02c      	beq.n	3000eb68 <hal_clock_get_instance+0x8c>
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
3000eb0e:	f24b 4060 	movw	r0, #46176	; 0xb460
3000eb12:	2220      	movs	r2, #32
3000eb14:	2100      	movs	r1, #0
3000eb16:	f2c3 0002 	movt	r0, #12290	; 0x3002
3000eb1a:	f005 ef2a 	blx	30014970 <memset>
    *controllerTable = &s_ClkgenDrvInterface;
3000eb1e:	f64e 433c 	movw	r3, #60476	; 0xec3c
        /* get clkgen driver API table */
        hal_clock_get_controller_interface(&(g_ClkgenInstance.controllerTable));

        if (g_ClkgenInstance.controllerTable) {
            g_ClkgenInstance.occupied = 1;
3000eb22:	2201      	movs	r2, #1
    *controllerTable = &s_ClkgenDrvInterface;
3000eb24:	f2c3 0301 	movt	r3, #12289	; 0x3001
            //sec clkgen
            g_ClkgenInstance.controllerTable->get_default_config(&
3000eb28:	4811      	ldr	r0, [pc, #68]	; (3000eb70 <hal_clock_get_instance+0x94>)
    *controllerTable = &s_ClkgenDrvInterface;
3000eb2a:	6223      	str	r3, [r4, #32]
            g_ClkgenInstance.occupied = 1;
3000eb2c:	7722      	strb	r2, [r4, #28]
            g_ClkgenInstance.controllerTable->get_default_config(&
3000eb2e:	f7f7 fe93 	bl	30006858 <clkgen_get_default_config>
                    (g_ClkgenInstance.def_cfg));
        }

        //spin_unlock_irqrestore(&clkgen_spin_lock, states);
        LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "hal_clock_get_instance is ok \n");
        return &g_ClkgenInstance;
3000eb32:	f24b 4060 	movw	r0, #46176	; 0xb460
3000eb36:	f2c3 0002 	movt	r0, #12290	; 0x3002

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_get_instance is failed \n");
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
    return NULL;
}
3000eb3a:	bd10      	pop	{r4, r15}
    *statep = state;
3000eb3c:	f24b 4284 	movw	r2, #46212	; 0xb484
3000eb40:	2000      	movs	r0, #0
    *lock = 1;
3000eb42:	2101      	movs	r1, #1
    *statep = state;
3000eb44:	f2c3 0202 	movt	r2, #12290	; 0x3002
    *lock = 1;
3000eb48:	f24b 435c 	movw	r3, #46172	; 0xb45c
    if (g_ClkgenInstance.occupied != 1) {
3000eb4c:	f24b 4460 	movw	r4, #46176	; 0xb460
    *statep = state;
3000eb50:	6010      	str	r0, [r2, #0]
    *lock = 1;
3000eb52:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000eb56:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000eb5a:	7f22      	ldrb	r2, [r4, #28]
3000eb5c:	6019      	str	r1, [r3, #0]
3000eb5e:	428a      	cmp	r2, r1
    *lock = 0;
3000eb60:	bf08      	it	eq
3000eb62:	6018      	streq	r0, [r3, #0]
3000eb64:	d1d3      	bne.n	3000eb0e <hal_clock_get_instance+0x32>
3000eb66:	e7e8      	b.n	3000eb3a <hal_clock_get_instance+0x5e>
3000eb68:	6018      	str	r0, [r3, #0]
    __asm__ volatile("cpsie i");
3000eb6a:	b662      	cpsie	i
}
3000eb6c:	bd10      	pop	{r4, r15}
3000eb6e:	bf00      	nop
3000eb70:	3002b47d 	.word	0x3002b47d

3000eb74 <hal_clock_release_handle.part.2>:
//
//*****************************************************************************
bool hal_clock_release_handle(void *handle)
{
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((handle != NULL));
3000eb74:	f64e 430c 	movw	r3, #60428	; 0xec0c
3000eb78:	f64e 32d0 	movw	r2, #60368	; 0xebd0
bool hal_clock_release_handle(void *handle)
3000eb7c:	b500      	push	{r14}
    ASSERT((handle != NULL));
3000eb7e:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000eb82:	f24a 011c 	movw	r1, #40988	; 0xa01c
bool hal_clock_release_handle(void *handle)
3000eb86:	b083      	sub	sp, #12
    ASSERT((handle != NULL));
3000eb88:	4670      	mov	r0, r14
3000eb8a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000eb8e:	9300      	str	r3, [sp, #0]
3000eb90:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000eb94:	23b9      	movs	r3, #185	; 0xb9
3000eb96:	f005 fb3d 	bl	30014214 <_panic>
3000eb9a:	bf00      	nop

3000eb9c <hal_clock_release_instance>:
    ASSERT((clkgenInstance != NULL));
3000eb9c:	b178      	cbz	r0, 3000ebbe <hal_clock_release_instance+0x22>
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
3000eb9e:	f24b 4284 	movw	r2, #46212	; 0xb484
3000eba2:	f24b 435c 	movw	r3, #46172	; 0xb45c
3000eba6:	f2c3 0202 	movt	r2, #12290	; 0x3002
    clkgenInstance->occupied = 0;
3000ebaa:	2100      	movs	r1, #0
3000ebac:	f2c3 0302 	movt	r3, #12290	; 0x3002
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
3000ebb0:	6812      	ldr	r2, [r2, #0]
3000ebb2:	6019      	str	r1, [r3, #0]
    clkgenInstance->occupied = 0;
3000ebb4:	7701      	strb	r1, [r0, #28]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
3000ebb6:	07d3      	lsls	r3, r2, #31
3000ebb8:	d500      	bpl.n	3000ebbc <hal_clock_release_instance+0x20>
3000ebba:	b662      	cpsie	i
3000ebbc:	4770      	bx	r14
    ASSERT((clkgenInstance != NULL));
3000ebbe:	f64e 4320 	movw	r3, #60448	; 0xec20
3000ebc2:	f64e 32d0 	movw	r2, #60368	; 0xebd0
{
3000ebc6:	b500      	push	{r14}
    ASSERT((clkgenInstance != NULL));
3000ebc8:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000ebcc:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000ebd0:	b083      	sub	sp, #12
3000ebd2:	4670      	mov	r0, r14
    ASSERT((clkgenInstance != NULL));
3000ebd4:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000ebd8:	9300      	str	r3, [sp, #0]
3000ebda:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000ebde:	2387      	movs	r3, #135	; 0x87
3000ebe0:	f005 fb18 	bl	30014214 <_panic>

3000ebe4 <hal_clock_creat_handle>:
{
3000ebe4:	b510      	push	{r4, r14}
3000ebe6:	b082      	sub	sp, #8
    ASSERT((handle != NULL));
3000ebe8:	b138      	cbz	r0, 3000ebfa <hal_clock_creat_handle+0x16>
3000ebea:	4604      	mov	r4, r0
    clkgenInstance = hal_clock_get_instance();
3000ebec:	f7ff ff76 	bl	3000eadc <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
3000ebf0:	b108      	cbz	r0, 3000ebf6 <hal_clock_creat_handle+0x12>
    *handle = clkgenInstance;
3000ebf2:	6020      	str	r0, [r4, #0]
    return true;
3000ebf4:	2001      	movs	r0, #1
}
3000ebf6:	b002      	add	sp, #8
3000ebf8:	bd10      	pop	{r4, r15}
    ASSERT((handle != NULL));
3000ebfa:	f64e 430c 	movw	r3, #60428	; 0xec0c
3000ebfe:	f64e 32d0 	movw	r2, #60368	; 0xebd0
3000ec02:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000ec06:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000ec0a:	4670      	mov	r0, r14
3000ec0c:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000ec10:	9300      	str	r3, [sp, #0]
3000ec12:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000ec16:	239b      	movs	r3, #155	; 0x9b
3000ec18:	f005 fafc 	bl	30014214 <_panic>

3000ec1c <hal_clock_release_handle>:
{
3000ec1c:	b508      	push	{r3, r14}
    ASSERT((handle != NULL));
3000ec1e:	b118      	cbz	r0, 3000ec28 <hal_clock_release_handle+0xc>
    l_clkgenInstance = (clkgen_instance_t *)handle;
    hal_clock_release_instance(l_clkgenInstance);
3000ec20:	f7ff ffbc 	bl	3000eb9c <hal_clock_release_instance>
    // mutex_destroy(&l_clkgenInstance->clkgenMutex);
    return true;
}
3000ec24:	2001      	movs	r0, #1
3000ec26:	bd08      	pop	{r3, r15}
3000ec28:	f7ff ffa4 	bl	3000eb74 <hal_clock_release_handle.part.2>

3000ec2c <hal_clock_enable>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_clock_enable(void *g_handle, uint32_t res_glb_idx)
{
3000ec2c:	b510      	push	{r4, r14}
    int ret = -1;
    int32_t gating_idx = -1;
3000ec2e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
3000ec32:	b084      	sub	sp, #16
    int32_t gating_idx = -1;
3000ec34:	9302      	str	r3, [sp, #8]
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((g_handle != NULL));
3000ec36:	b1c0      	cbz	r0, 3000ec6a <hal_clock_enable+0x3e>
3000ec38:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &gating_idx);
3000ec3a:	aa02      	add	r2, sp, #8
3000ec3c:	4608      	mov	r0, r1
3000ec3e:	a903      	add	r1, sp, #12
3000ec40:	f000 ffd4 	bl	3000fbec <res_get_info_by_id>

    if (ret == -1) {
3000ec44:	3001      	adds	r0, #1
3000ec46:	d00d      	beq.n	3000ec64 <hal_clock_enable+0x38>
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    //enable clk gating
    if ((gating_idx >= DEFAULT_LPGATING_IDX_START) && (gating_idx != -1)
3000ec48:	9902      	ldr	r1, [sp, #8]
3000ec4a:	29ff      	cmp	r1, #255	; 0xff
3000ec4c:	dd0a      	ble.n	3000ec64 <hal_clock_enable+0x38>
            && l_clkgenInstance->controllerTable->gating_enable) {
3000ec4e:	6a23      	ldr	r3, [r4, #32]
3000ec50:	689b      	ldr	r3, [r3, #8]
3000ec52:	b1e3      	cbz	r3, 3000ec8e <hal_clock_enable+0x62>
        if (l_clkgenInstance->controllerTable->gating_enable(clkgen_base_addr,
3000ec54:	2201      	movs	r2, #1
3000ec56:	f5a1 7180 	sub.w	r1, r1, #256	; 0x100
3000ec5a:	9803      	ldr	r0, [sp, #12]
3000ec5c:	b289      	uxth	r1, r1
3000ec5e:	4798      	blx	r3
        }
    }

    LTRACEF("hal_clock_enable res_glb_idx:0x%x enable failed\n", res_glb_idx);
    return false;
}
3000ec60:	b004      	add	sp, #16
3000ec62:	bd10      	pop	{r4, r15}
        return false;
3000ec64:	2000      	movs	r0, #0
}
3000ec66:	b004      	add	sp, #16
3000ec68:	bd10      	pop	{r4, r15}
    ASSERT((g_handle != NULL));
3000ec6a:	f64e 33bc 	movw	r3, #60348	; 0xebbc
3000ec6e:	f64e 32d0 	movw	r2, #60368	; 0xebd0
3000ec72:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000ec76:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000ec7a:	4670      	mov	r0, r14
3000ec7c:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000ec80:	9300      	str	r3, [sp, #0]
3000ec82:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000ec86:	f44f 732e 	mov.w	r3, #696	; 0x2b8
3000ec8a:	f005 fac3 	bl	30014214 <_panic>
        return false;
3000ec8e:	4618      	mov	r0, r3
3000ec90:	e7e9      	b.n	3000ec66 <hal_clock_enable+0x3a>
3000ec92:	bf00      	nop

3000ec94 <hal_clock_ipclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_ipclk_set(void *g_handle, uint32_t res_glb_idx,
                         clkgen_app_ip_cfg_t *ip_cfg)
{
3000ec94:	b530      	push	{r4, r5, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t ip_slice_idx = -1;
3000ec96:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
3000ec9a:	b085      	sub	sp, #20
    int32_t ip_slice_idx = -1;
3000ec9c:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
3000ec9e:	b1d0      	cbz	r0, 3000ecd6 <hal_clock_ipclk_set+0x42>
3000eca0:	4615      	mov	r5, r2
3000eca2:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &ip_slice_idx);
3000eca4:	4608      	mov	r0, r1
3000eca6:	aa03      	add	r2, sp, #12
3000eca8:	a902      	add	r1, sp, #8
3000ecaa:	f000 ff9f 	bl	3000fbec <res_get_info_by_id>

    if (ret == -1) {
3000ecae:	3001      	adds	r0, #1
3000ecb0:	d00e      	beq.n	3000ecd0 <hal_clock_ipclk_set+0x3c>
        return false;
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
3000ecb2:	9903      	ldr	r1, [sp, #12]
3000ecb4:	2900      	cmp	r1, #0
3000ecb6:	db0b      	blt.n	3000ecd0 <hal_clock_ipclk_set+0x3c>
            && l_clkgenInstance->controllerTable->ip_slice_set) {
3000ecb8:	6a23      	ldr	r3, [r4, #32]
3000ecba:	68dc      	ldr	r4, [r3, #12]
3000ecbc:	b1ec      	cbz	r4, 3000ecfa <hal_clock_ipclk_set+0x66>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->ip_slice_set(clkgen_base_addr,
3000ecbe:	88ab      	ldrh	r3, [r5, #4]
3000ecc0:	782a      	ldrb	r2, [r5, #0]
3000ecc2:	9802      	ldr	r0, [sp, #8]
3000ecc4:	892d      	ldrh	r5, [r5, #8]
3000ecc6:	9500      	str	r5, [sp, #0]
3000ecc8:	b2c9      	uxtb	r1, r1
3000ecca:	47a0      	blx	r4
    }

    LTRACEF("hal_clock_ipclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, ip_slice_idx);
    return false;
}
3000eccc:	b005      	add	sp, #20
3000ecce:	bd30      	pop	{r4, r5, r15}
        return false;
3000ecd0:	2000      	movs	r0, #0
}
3000ecd2:	b005      	add	sp, #20
3000ecd4:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
3000ecd6:	f64e 33bc 	movw	r3, #60348	; 0xebbc
3000ecda:	f64e 32d0 	movw	r2, #60368	; 0xebd0
3000ecde:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000ece2:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000ece6:	4670      	mov	r0, r14
3000ece8:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000ecec:	9300      	str	r3, [sp, #0]
3000ecee:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000ecf2:	f240 3315 	movw	r3, #789	; 0x315
3000ecf6:	f005 fa8d 	bl	30014214 <_panic>
        return false;
3000ecfa:	4620      	mov	r0, r4
3000ecfc:	e7e6      	b.n	3000eccc <hal_clock_ipclk_set+0x38>
3000ecfe:	bf00      	nop

3000ed00 <hal_arm_gic_create_handle>:


bool hal_arm_gic_create_handle(void **phandle, uint32_t res_glb_idx)
{
    return true;
}
3000ed00:	2001      	movs	r0, #1
3000ed02:	4770      	bx	r14

3000ed04 <hal_arm_gic_release_handle>:

bool hal_arm_gic_release_handle(void *handle)
{
    return true;
}
3000ed04:	2001      	movs	r0, #1
3000ed06:	4770      	bx	r14

3000ed08 <hal_arm_gic_init>:

bool hal_arm_gic_init(void *handle)
{
3000ed08:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000ed0a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000ed0e:	061b      	lsls	r3, r3, #24
3000ed10:	d40d      	bmi.n	3000ed2e <hal_arm_gic_init+0x26>
    __asm__ volatile("cpsid i");
3000ed12:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    static bool initialized = false;

    spin_lock_irqsave(&init_lock,state);

    if(false == initialized)
3000ed14:	f24b 4488 	movw	r4, #46216	; 0xb488
3000ed18:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000ed1c:	7823      	ldrb	r3, [r4, #0]
3000ed1e:	b91b      	cbnz	r3, 3000ed28 <hal_arm_gic_init+0x20>
    {
        arm_gic_init();
3000ed20:	f7f8 fe4a 	bl	300079b8 <arm_gic_init>
        initialized = true;
3000ed24:	2301      	movs	r3, #1
3000ed26:	7023      	strb	r3, [r4, #0]
    __asm__ volatile("cpsie i");
3000ed28:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&init_lock,state);

    return true;
}
3000ed2a:	2001      	movs	r0, #1
3000ed2c:	bd10      	pop	{r4, r15}
    if(false == initialized)
3000ed2e:	f24b 4488 	movw	r4, #46216	; 0xb488
3000ed32:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000ed36:	7823      	ldrb	r3, [r4, #0]
3000ed38:	2b00      	cmp	r3, #0
3000ed3a:	d1f6      	bne.n	3000ed2a <hal_arm_gic_init+0x22>
        arm_gic_init();
3000ed3c:	f7f8 fe3c 	bl	300079b8 <arm_gic_init>
        initialized = true;
3000ed40:	2301      	movs	r3, #1
3000ed42:	7023      	strb	r3, [r4, #0]
    return true;
3000ed44:	e7f1      	b.n	3000ed2a <hal_arm_gic_init+0x22>
3000ed46:	bf00      	nop

3000ed48 <hal_arm_gic_enable_interrupt>:
    arm_gic_igroup_init();
    return true;
}

bool hal_arm_gic_enable_interrupt(void *handle, uint32_t irq_number)
{
3000ed48:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_unmask_interrupt(irq_number) == 0 ? true : false );
3000ed4a:	4608      	mov	r0, r1
3000ed4c:	f7f8 fee6 	bl	30007b1c <arm_gic_unmask_interrupt>

    return ret;

}
3000ed50:	fab0 f080 	clz	r0, r0
3000ed54:	0940      	lsrs	r0, r0, #5
3000ed56:	bd08      	pop	{r3, r15}

3000ed58 <hal_arm_gic_disable_interrupt>:

bool hal_arm_gic_disable_interrupt(void *handle, uint32_t irq_number)
{
3000ed58:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_mask_interrupt(irq_number) == 0 ? true : false );
3000ed5a:	4608      	mov	r0, r1
3000ed5c:	f7f8 febe 	bl	30007adc <arm_gic_mask_interrupt>

    return ret;
}
3000ed60:	fab0 f080 	clz	r0, r0
3000ed64:	0940      	lsrs	r0, r0, #5
3000ed66:	bd08      	pop	{r3, r15}

3000ed68 <hal_arm_gic_register_interrupt>:
bool hal_arm_gic_register_interrupt(void *handle,
    uint32_t irq_number,
    uint8_t priority,
    int_handler irq_handler,
    void* arg)
{
3000ed68:	b538      	push	{r3, r4, r5, r14}
3000ed6a:	460c      	mov	r4, r1
3000ed6c:	4615      	mov	r5, r2
    arm_gic_register_int_handler(irq_number, irq_handler, arg);
3000ed6e:	4619      	mov	r1, r3
3000ed70:	4620      	mov	r0, r4
3000ed72:	9a04      	ldr	r2, [sp, #16]
3000ed74:	f7f8 fdf4 	bl	30007960 <arm_gic_register_int_handler>
    arm_gic_set_priority(irq_number, priority);
3000ed78:	4629      	mov	r1, r5
3000ed7a:	4620      	mov	r0, r4
3000ed7c:	f7f8 fe8a 	bl	30007a94 <arm_gic_set_priority>

    return true;
}
3000ed80:	2001      	movs	r0, #1
3000ed82:	bd38      	pop	{r3, r4, r5, r15}

3000ed84 <hal_mb_init>:
}

void hal_mb_init(void *cl, hal_mb_cfg_t *cfg)
{
    return;
}
3000ed84:	4770      	bx	r14
3000ed86:	bf00      	nop

3000ed88 <hal_mb_create_handle>:
}

bool hal_mb_create_handle(void **handle, uint32_t res_glb_idx)
{
    return false;
}
3000ed88:	2000      	movs	r0, #0
3000ed8a:	4770      	bx	r14

3000ed8c <hal_mmc_creat_handle>:
    }
    return NULL;
}

bool hal_mmc_creat_handle(void **handle, uint32_t mmc_res_glb_idx)
{
3000ed8c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
3000ed90:	460c      	mov	r4, r1
3000ed92:	b084      	sub	sp, #16
3000ed94:	4606      	mov	r6, r0
    int32_t apb_offset;
    struct mmc_priv_res *priv_res;
    struct mmc_handle *p_handle;
    spin_lock_saved_state_t states;

    res_id = res_get_info_by_id(mmc_res_glb_idx, &apb_paddr, &apb_offset);
3000ed96:	aa03      	add	r2, sp, #12
3000ed98:	4608      	mov	r0, r1
3000ed9a:	a902      	add	r1, sp, #8
3000ed9c:	f000 ff26 	bl	3000fbec <res_get_info_by_id>
    if (res_id < 0) {
3000eda0:	2800      	cmp	r0, #0
3000eda2:	db13      	blt.n	3000edcc <hal_mmc_creat_handle+0x40>
        if (res[i].res_glb_idx == idx)
3000eda4:	f245 1368 	movw	r3, #20840	; 0x5168
3000eda8:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000edac:	685a      	ldr	r2, [r3, #4]
3000edae:	4294      	cmp	r4, r2
3000edb0:	d012      	beq.n	3000edd8 <hal_mmc_creat_handle+0x4c>
3000edb2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
3000edb4:	4294      	cmp	r4, r2
3000edb6:	d074      	beq.n	3000eea2 <hal_mmc_creat_handle+0x116>
3000edb8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
3000edba:	4294      	cmp	r4, r2
3000edbc:	d074      	beq.n	3000eea8 <hal_mmc_creat_handle+0x11c>
3000edbe:	6fda      	ldr	r2, [r3, #124]	; 0x7c
3000edc0:	4294      	cmp	r4, r2
3000edc2:	d074      	beq.n	3000eeae <hal_mmc_creat_handle+0x122>
            ret = true;
        }
        spin_unlock_irqrestore(&mmc_spin_lock, states);
    }
    else {
        ret = false;
3000edc4:	2000      	movs	r0, #0
    }

    return ret;
}
3000edc6:	b004      	add	sp, #16
3000edc8:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        *handle = NULL;
3000edcc:	2300      	movs	r3, #0
        return false;
3000edce:	4618      	mov	r0, r3
        *handle = NULL;
3000edd0:	6033      	str	r3, [r6, #0]
}
3000edd2:	b004      	add	sp, #16
3000edd4:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        if (res[i].res_glb_idx == idx)
3000edd8:	461c      	mov	r4, r3
        p_handle = &s_mmc_handle[priv_res->slot];
3000edda:	7825      	ldrb	r5, [r4, #0]
3000eddc:	f64b 58e0 	movw	r8, #48608	; 0xbde0
3000ede0:	eb05 0785 	add.w	r7, r5, r5, lsl #2
3000ede4:	f2c3 0802 	movt	r8, #12290	; 0x3002
3000ede8:	eb08 07c7 	add.w	r7, r8, r7, lsl #3
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000edec:	f3ef 8000 	mrs	r0, CPSR
3000edf0:	f010 0080 	ands.w	r0, r0, #128	; 0x80
3000edf4:	d026      	beq.n	3000ee44 <hal_mmc_creat_handle+0xb8>
        if (p_handle->apb_base) {
3000edf6:	eb05 0985 	add.w	r9, r5, r5, lsl #2
3000edfa:	ea4f 09c9 	mov.w	r9, r9, lsl #3
3000edfe:	f858 3009 	ldr.w	r3, [r8, r9]
3000ee02:	2b00      	cmp	r3, #0
3000ee04:	d1de      	bne.n	3000edc4 <hal_mmc_creat_handle+0x38>
            memset(p_handle, 0, sizeof(struct mmc_handle));
3000ee06:	4619      	mov	r1, r3
3000ee08:	2228      	movs	r2, #40	; 0x28
3000ee0a:	9301      	str	r3, [sp, #4]
3000ee0c:	4638      	mov	r0, r7
3000ee0e:	f005 edb0 	blx	30014970 <memset>
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee12:	f24b 62a0 	movw	r2, #46752	; 0xb6a0
3000ee16:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee1a:	9b01      	ldr	r3, [sp, #4]
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee1c:	f2c3 0202 	movt	r2, #12290	; 0x3002
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee20:	4619      	mov	r1, r3
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee22:	eb05 0580 	add.w	r5, r5, r0, lsl #2
            p_handle->apb_base = apb_paddr;
3000ee26:	9b02      	ldr	r3, [sp, #8]
            p_handle->priv_res = priv_res;
3000ee28:	60bc      	str	r4, [r7, #8]
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee2a:	eb02 1505 	add.w	r5, r2, r5, lsl #4
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee2e:	4628      	mov	r0, r5
3000ee30:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee34:	627d      	str	r5, [r7, #36]	; 0x24
            p_handle->apb_base = apb_paddr;
3000ee36:	f848 3009 	str.w	r3, [r8, r9]
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee3a:	f005 ed9a 	blx	30014970 <memset>
            *handle = p_handle;
3000ee3e:	6037      	str	r7, [r6, #0]
            ret = true;
3000ee40:	2001      	movs	r0, #1
3000ee42:	e7c0      	b.n	3000edc6 <hal_mmc_creat_handle+0x3a>
    __asm__ volatile("cpsid i");
3000ee44:	b672      	cpsid	i
        if (p_handle->apb_base) {
3000ee46:	eb05 0585 	add.w	r5, r5, r5, lsl #2
3000ee4a:	00ed      	lsls	r5, r5, #3
3000ee4c:	eb08 0905 	add.w	r9, r8, r5
3000ee50:	f858 a005 	ldr.w	r10, [r8, r5]
3000ee54:	f1ba 0f00 	cmp.w	r10, #0
3000ee58:	d11f      	bne.n	3000ee9a <hal_mmc_creat_handle+0x10e>
            memset(p_handle, 0, sizeof(struct mmc_handle));
3000ee5a:	2228      	movs	r2, #40	; 0x28
3000ee5c:	4651      	mov	r1, r10
3000ee5e:	4638      	mov	r0, r7
3000ee60:	f005 ed86 	blx	30014970 <memset>
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee64:	f894 c000 	ldrb.w	r12, [r4]
3000ee68:	f24b 63a0 	movw	r3, #46752	; 0xb6a0
3000ee6c:	ebcc 02cc 	rsb	r2, r12, r12, lsl #3
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee70:	4651      	mov	r1, r10
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee72:	f2c3 0302 	movt	r3, #12290	; 0x3002
            p_handle->priv_res = priv_res;
3000ee76:	f8c9 4008 	str.w	r4, [r9, #8]
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee7a:	eb0c 0c82 	add.w	r12, r12, r2, lsl #2
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee7e:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee82:	eb03 130c 	add.w	r3, r3, r12, lsl #4
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee86:	4618      	mov	r0, r3
            p_handle->priv_data = &s_mmc_dev[priv_res->slot];
3000ee88:	f8c9 3024 	str.w	r3, [r9, #36]	; 0x24
            p_handle->apb_base = apb_paddr;
3000ee8c:	9b02      	ldr	r3, [sp, #8]
3000ee8e:	f848 3005 	str.w	r3, [r8, r5]
            memset(p_handle->priv_data, 0, sizeof(struct mmc_device));
3000ee92:	f005 ed6e 	blx	30014970 <memset>
            *handle = p_handle;
3000ee96:	6037      	str	r7, [r6, #0]
            ret = true;
3000ee98:	2001      	movs	r0, #1
    __asm__ volatile("cpsie i");
3000ee9a:	b662      	cpsie	i
}
3000ee9c:	b004      	add	sp, #16
3000ee9e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        if (res[i].res_glb_idx == idx)
3000eea2:	f103 0428 	add.w	r4, r3, #40	; 0x28
3000eea6:	e798      	b.n	3000edda <hal_mmc_creat_handle+0x4e>
3000eea8:	f103 0450 	add.w	r4, r3, #80	; 0x50
3000eeac:	e795      	b.n	3000edda <hal_mmc_creat_handle+0x4e>
3000eeae:	f103 0478 	add.w	r4, r3, #120	; 0x78
3000eeb2:	e792      	b.n	3000edda <hal_mmc_creat_handle+0x4e>

3000eeb4 <hal_mmc_release_handle>:

bool hal_mmc_release_handle(void **handle)
{
3000eeb4:	b530      	push	{r4, r5, r14}
3000eeb6:	b083      	sub	sp, #12
    ASSERT(handle);
3000eeb8:	b1d8      	cbz	r0, 3000eef2 <hal_mmc_release_handle+0x3e>
    struct mmc_handle *mmc = *handle;
3000eeba:	6802      	ldr	r2, [r0, #0]
3000eebc:	4605      	mov	r5, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000eebe:	f3ef 8300 	mrs	r3, CPSR
3000eec2:	f013 0480 	ands.w	r4, r3, #128	; 0x80
3000eec6:	d10a      	bne.n	3000eede <hal_mmc_release_handle+0x2a>
    __asm__ volatile("cpsid i");
3000eec8:	b672      	cpsid	i
    spin_lock_saved_state_t states;

    spin_lock_irqsave(&mmc_spin_lock, states);
    mmc->apb_base = 0;
    mask_interrupt(mmc->priv_res->int_irq);
3000eeca:	6893      	ldr	r3, [r2, #8]
    mmc->apb_base = 0;
3000eecc:	6014      	str	r4, [r2, #0]
    mask_interrupt(mmc->priv_res->int_irq);
3000eece:	6898      	ldr	r0, [r3, #8]
3000eed0:	f7f1 fc18 	bl	30000704 <mask_interrupt>
    *handle = NULL;
3000eed4:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
3000eed6:	b662      	cpsie	i
    spin_unlock_irqrestore(&mmc_spin_lock, states);

    return true;
}
3000eed8:	2001      	movs	r0, #1
3000eeda:	b003      	add	sp, #12
3000eedc:	bd30      	pop	{r4, r5, r15}
    mask_interrupt(mmc->priv_res->int_irq);
3000eede:	6893      	ldr	r3, [r2, #8]
    mmc->apb_base = 0;
3000eee0:	2400      	movs	r4, #0
3000eee2:	6014      	str	r4, [r2, #0]
    mask_interrupt(mmc->priv_res->int_irq);
3000eee4:	6898      	ldr	r0, [r3, #8]
3000eee6:	f7f1 fc0d 	bl	30000704 <mask_interrupt>
    *handle = NULL;
3000eeea:	602c      	str	r4, [r5, #0]
}
3000eeec:	2001      	movs	r0, #1
3000eeee:	b003      	add	sp, #12
3000eef0:	bd30      	pop	{r4, r5, r15}
    ASSERT(handle);
3000eef2:	f24a 0354 	movw	r3, #41044	; 0xa054
3000eef6:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000eefa:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000eefe:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000ef02:	4670      	mov	r0, r14
3000ef04:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000ef08:	9300      	str	r3, [sp, #0]
3000ef0a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000ef0e:	2378      	movs	r3, #120	; 0x78
3000ef10:	f005 f980 	bl	30014214 <_panic>

3000ef14 <hal_mmc_init>:

int hal_mmc_init(void *handle)
{
3000ef14:	b530      	push	{r4, r5, r14}
3000ef16:	b083      	sub	sp, #12
    ASSERT(handle);
3000ef18:	2800      	cmp	r0, #0
3000ef1a:	d051      	beq.n	3000efc0 <hal_mmc_init+0xac>
    struct mmc_handle *mmc = handle;
    struct mmc_device *dev = mmc->priv_data;
    struct mmc_config_data *mmc_cfg = &dev->config;

    mmc_cfg->slot = mmc->priv_res->slot;
3000ef1c:	6882      	ldr	r2, [r0, #8]
3000ef1e:	4605      	mov	r5, r0
    struct mmc_device *dev = mmc->priv_data;
3000ef20:	6a44      	ldr	r4, [r0, #36]	; 0x24
    mmc_cfg->slot = mmc->priv_res->slot;
3000ef22:	7813      	ldrb	r3, [r2, #0]
3000ef24:	f884 31b0 	strb.w	r3, [r4, #432]	; 0x1b0
    mmc_cfg->bus_width = mmc->config->bus_width;
    mmc_cfg->voltage = mmc->config->voltage;
    mmc_cfg->hs200_support = mmc->config->hs200_support;
    mmc_cfg->hs400_support = mmc->config->hs400_support;

    if (mmc_platform_init(dev)) {
3000ef28:	4620      	mov	r0, r4
    mmc_cfg->max_clk_rate = mmc->config->max_clk_rate;
3000ef2a:	686b      	ldr	r3, [r5, #4]
    mmc_cfg->irq = mmc->priv_res->int_irq;
3000ef2c:	6892      	ldr	r2, [r2, #8]
    mmc_cfg->sdhc_base = mmc->apb_base;
3000ef2e:	6829      	ldr	r1, [r5, #0]
    mmc_cfg->irq = mmc->priv_res->int_irq;
3000ef30:	f8c4 21b8 	str.w	r2, [r4, #440]	; 0x1b8
    mmc_cfg->max_clk_rate = mmc->config->max_clk_rate;
3000ef34:	681a      	ldr	r2, [r3, #0]
    mmc_cfg->sdhc_base = mmc->apb_base;
3000ef36:	f8c4 11b4 	str.w	r1, [r4, #436]	; 0x1b4
    mmc_cfg->bus_width = mmc->config->bus_width;
3000ef3a:	8899      	ldrh	r1, [r3, #4]
    mmc_cfg->max_clk_rate = mmc->config->max_clk_rate;
3000ef3c:	f8c4 21c0 	str.w	r2, [r4, #448]	; 0x1c0
    mmc_cfg->voltage = mmc->config->voltage;
3000ef40:	689a      	ldr	r2, [r3, #8]
3000ef42:	f8c4 21c4 	str.w	r2, [r4, #452]	; 0x1c4
    mmc_cfg->bus_width = mmc->config->bus_width;
3000ef46:	f8a4 11bc 	strh.w	r1, [r4, #444]	; 0x1bc
    mmc_cfg->hs200_support = mmc->config->hs200_support;
3000ef4a:	7b1a      	ldrb	r2, [r3, #12]
3000ef4c:	f884 21c8 	strb.w	r2, [r4, #456]	; 0x1c8
    mmc_cfg->hs400_support = mmc->config->hs400_support;
3000ef50:	7b5b      	ldrb	r3, [r3, #13]
3000ef52:	f884 31c9 	strb.w	r3, [r4, #457]	; 0x1c9
    if (mmc_platform_init(dev)) {
3000ef56:	f000 fc51 	bl	3000f7fc <mmc_platform_init>
3000ef5a:	2800      	cmp	r0, #0
3000ef5c:	d141      	bne.n	3000efe2 <hal_mmc_init+0xce>
        dprintf(CRITICAL, "platform init failed!\n");
        return -1;
    }

    dev->host.parent = mmc;
3000ef5e:	f8c4 50e0 	str.w	r5, [r4, #224]	; 0xe0

    if (!mmc->async_mode && mmc->event_handle) {
3000ef62:	7d2b      	ldrb	r3, [r5, #20]
3000ef64:	b1c3      	cbz	r3, 3000ef98 <hal_mmc_init+0x84>
    }
    dev->host.async_mode = mmc->async_mode;

    mmc->block_size = MMC_BLOCK_SIZE;

    if (dev->card.type < MMC_TYPE_MMCHC) {
3000ef66:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
    mmc->block_size = MMC_BLOCK_SIZE;
3000ef6a:	f44f 7100 	mov.w	r1, #512	; 0x200
    dev->host.async_mode = mmc->async_mode;
3000ef6e:	60e3      	str	r3, [r4, #12]
    mmc->block_size = MMC_BLOCK_SIZE;
3000ef70:	60e9      	str	r1, [r5, #12]
    if (dev->card.type < MMC_TYPE_MMCHC) {
3000ef72:	2a02      	cmp	r2, #2
    }
    else {
        dprintf(INFO, "\n mmc card erase_size %d, erase_mult %d\n",
                dev->card.csd.erase_grp_size, dev->card.csd.erase_grp_mult);
        mmc->erase_grp_size = (dev->card.csd.erase_grp_size + 1) *
                              (dev->card.csd.erase_grp_mult + 1) *
3000ef74:	bf85      	ittet	hi
3000ef76:	f8d4 217c 	ldrhi.w	r2, [r4, #380]	; 0x17c
3000ef7a:	f8d4 3180 	ldrhi.w	r3, [r4, #384]	; 0x180
            dev->card.ssr.au_size * dev->card.ssr.num_aus * MMC_BLOCK_SIZE;
3000ef7e:	f8d4 219c 	ldrls.w	r2, [r4, #412]	; 0x19c
                              (dev->card.csd.erase_grp_mult + 1) *
3000ef82:	3201      	addhi	r2, #1
            dev->card.ssr.au_size * dev->card.ssr.num_aus * MMC_BLOCK_SIZE;
3000ef84:	bf94      	ite	ls
3000ef86:	f8d4 31a0 	ldrls.w	r3, [r4, #416]	; 0x1a0
                              (dev->card.csd.erase_grp_mult + 1) *
3000ef8a:	3301      	addhi	r3, #1
3000ef8c:	fb03 f302 	mul.w	r3, r3, r2
3000ef90:	025b      	lsls	r3, r3, #9
        mmc->erase_grp_size = (dev->card.csd.erase_grp_size + 1) *
3000ef92:	612b      	str	r3, [r5, #16]
                              MMC_BLOCK_SIZE;
    }

    return 0;
}
3000ef94:	b003      	add	sp, #12
3000ef96:	bd30      	pop	{r4, r5, r15}
    if (!mmc->async_mode && mmc->event_handle) {
3000ef98:	6a2a      	ldr	r2, [r5, #32]
3000ef9a:	2a00      	cmp	r2, #0
3000ef9c:	d0e3      	beq.n	3000ef66 <hal_mmc_init+0x52>
        dprintf(CRITICAL,
3000ef9e:	f64e 524c 	movw	r2, #60748	; 0xed4c
3000efa2:	f64e 5158 	movw	r1, #60760	; 0xed58
3000efa6:	f64e 5060 	movw	r0, #60768	; 0xed60
3000efaa:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000efae:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000efb2:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000efb6:	f006 fdfb 	bl	30015bb0 <_printf>
        return -1;
3000efba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000efbe:	e7e9      	b.n	3000ef94 <hal_mmc_init+0x80>
    ASSERT(handle);
3000efc0:	f24a 0354 	movw	r3, #41044	; 0xa054
3000efc4:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000efc8:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000efcc:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000efd0:	4670      	mov	r0, r14
3000efd2:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000efd6:	9300      	str	r3, [sp, #0]
3000efd8:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000efdc:	2387      	movs	r3, #135	; 0x87
3000efde:	f005 f919 	bl	30014214 <_panic>
        dprintf(CRITICAL, "platform init failed!\n");
3000efe2:	f64e 5034 	movw	r0, #60724	; 0xed34
3000efe6:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000efea:	f006 fde1 	bl	30015bb0 <_printf>
        return -1;
3000efee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000eff2:	e7cf      	b.n	3000ef94 <hal_mmc_init+0x80>

3000eff4 <hal_mmc_read>:
    return  (void *)((input + boundary) & ~(boundary - 1));
}

int hal_mmc_read(void *handle, mmc_address_t src, uint8_t *dst,
                 mmc_length_t length)
{
3000eff4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000eff8:	b089      	sub	sp, #36	; 0x24
3000effa:	9e12      	ldr	r6, [sp, #72]	; 0x48
3000effc:	e9dd ab14 	ldrd	r10, r11, [r13, #80]	; 0x50
    LTRACEF("handle %p, src %lld, dst %p, len %lld\n", handle, src, dst,
            length);
    ASSERT(handle);
3000f000:	2800      	cmp	r0, #0
3000f002:	d066      	beq.n	3000f0d2 <hal_mmc_read+0xde>
3000f004:	4699      	mov	r9, r3
    ASSERT(IS_ALIGNED(src, MMC_BLOCK_SIZE));
3000f006:	f3c2 0308 	ubfx	r3, r2, #0, #9
3000f00a:	4690      	mov	r8, r2
3000f00c:	2b00      	cmp	r3, #0
3000f00e:	d171      	bne.n	3000f0f4 <hal_mmc_read+0x100>
    ASSERT(IS_ALIGNED(length, MMC_BLOCK_SIZE));
3000f010:	f3ca 0308 	ubfx	r3, r10, #0, #9
3000f014:	2b00      	cmp	r3, #0
3000f016:	d17e      	bne.n	3000f116 <hal_mmc_read+0x122>

    struct mmc_handle *mmc = handle;
    struct mmc_device *dev = mmc->priv_data;
3000f018:	6a43      	ldr	r3, [r0, #36]	; 0x24
3000f01a:	9302      	str	r3, [sp, #8]
    uint32_t read_len;
    uint8_t *buf = dst;
    uint8_t use_local_buf = 0;
    mmc_length_t max_read_length = MMC_MAX_XFER_SIZE;

    if (!IS_ALIGNED(dst, CACHE_LINE)) {
3000f01c:	f016 031f 	ands.w	r3, r6, #31
3000f020:	d14b      	bne.n	3000f0ba <hal_mmc_read+0xc6>
    uint8_t use_local_buf = 0;
3000f022:	9303      	str	r3, [sp, #12]
    mmc_length_t max_read_length = MMC_MAX_XFER_SIZE;
3000f024:	2400      	movs	r4, #0
3000f026:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
3000f02a:	e9cd 3404 	strd	r3, r4, [r13, #16]
        max_read_length = MMC_LOCAL_BUF_SIZE;
        use_local_buf = 1;
    }

    while (remaining) {
3000f02e:	ea5a 030b 	orrs.w	r3, r10, r11
        if (use_local_buf)
            buf = local_buf;
3000f032:	bf1f      	itttt	ne
3000f034:	f24b 43a0 	movwne	r3, #46240	; 0xb4a0
    while (remaining) {
3000f038:	4637      	movne	r7, r6
            buf = local_buf;
3000f03a:	f2c3 0302 	movtne	r3, #12290	; 0x3002
3000f03e:	9306      	strne	r3, [sp, #24]
    while (remaining) {
3000f040:	d119      	bne.n	3000f076 <hal_mmc_read+0x82>
3000f042:	e042      	b.n	3000f0ca <hal_mmc_read+0xd6>
        if (mmc_sdhci_read(dev, buf, src / MMC_BLOCK_SIZE,
                            read_len / MMC_BLOCK_SIZE)) {
            return -1;
        }

        if (buf != dst)
3000f044:	42be      	cmp	r6, r7
3000f046:	eb07 0304 	add.w	r3, r7, r4
            memcpy(dst, buf, read_len);
        else
            buf += read_len;
3000f04a:	bf08      	it	eq
3000f04c:	461e      	moveq	r6, r3
        if (buf != dst)
3000f04e:	d006      	beq.n	3000f05e <hal_mmc_read+0x6a>
            memcpy(dst, buf, read_len);
3000f050:	4638      	mov	r0, r7
3000f052:	4622      	mov	r2, r4
3000f054:	9307      	str	r3, [sp, #28]
3000f056:	4631      	mov	r1, r6
3000f058:	f005 ec04 	blx	30014864 <memcpy>
3000f05c:	9b07      	ldr	r3, [sp, #28]

        remaining -= read_len;
        dst += read_len;
3000f05e:	461f      	mov	r7, r3
        remaining -= read_len;
3000f060:	ebba 0a04 	subs.w	r10, r10, r4
3000f064:	eb6b 0b05 	sbc.w	r11, r11, r5
        src += read_len;
3000f068:	eb18 0804 	adds.w	r8, r8, r4
3000f06c:	eb49 0905 	adc.w	r9, r9, r5
    while (remaining) {
3000f070:	ea5a 030b 	orrs.w	r3, r10, r11
3000f074:	d029      	beq.n	3000f0ca <hal_mmc_read+0xd6>
            buf = local_buf;
3000f076:	9b06      	ldr	r3, [sp, #24]
        read_len = MIN(remaining, max_read_length);
3000f078:	4654      	mov	r4, r10
            buf = local_buf;
3000f07a:	9a03      	ldr	r2, [sp, #12]
        read_len = MIN(remaining, max_read_length);
3000f07c:	465d      	mov	r5, r11
        if (mmc_sdhci_read(dev, buf, src / MMC_BLOCK_SIZE,
3000f07e:	9802      	ldr	r0, [sp, #8]
            buf = local_buf;
3000f080:	2a00      	cmp	r2, #0
3000f082:	bf18      	it	ne
3000f084:	461e      	movne	r6, r3
        read_len = MIN(remaining, max_read_length);
3000f086:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
        if (mmc_sdhci_read(dev, buf, src / MMC_BLOCK_SIZE,
3000f08a:	4631      	mov	r1, r6
        read_len = MIN(remaining, max_read_length);
3000f08c:	455b      	cmp	r3, r11
3000f08e:	bf08      	it	eq
3000f090:	4552      	cmpeq	r2, r10
3000f092:	bf3c      	itt	cc
3000f094:	4614      	movcc	r4, r2
3000f096:	461d      	movcc	r5, r3
        if (mmc_sdhci_read(dev, buf, src / MMC_BLOCK_SIZE,
3000f098:	ea4f 2258 	mov.w	r2, r8, lsr #9
3000f09c:	0a63      	lsrs	r3, r4, #9
3000f09e:	ea42 52c9 	orr.w	r2, r2, r9, lsl #23
3000f0a2:	9300      	str	r3, [sp, #0]
3000f0a4:	ea4f 2359 	mov.w	r3, r9, lsr #9
3000f0a8:	f7fa fd40 	bl	30009b2c <mmc_sdhci_read>
3000f0ac:	2800      	cmp	r0, #0
3000f0ae:	d0c9      	beq.n	3000f044 <hal_mmc_read+0x50>
            return -1;
3000f0b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
    return 0;
}
3000f0b4:	b009      	add	sp, #36	; 0x24
3000f0b6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        max_read_length = MMC_LOCAL_BUF_SIZE;
3000f0ba:	f44f 7300 	mov.w	r3, #512	; 0x200
3000f0be:	2400      	movs	r4, #0
3000f0c0:	e9cd 3404 	strd	r3, r4, [r13, #16]
        use_local_buf = 1;
3000f0c4:	2301      	movs	r3, #1
3000f0c6:	9303      	str	r3, [sp, #12]
3000f0c8:	e7b1      	b.n	3000f02e <hal_mmc_read+0x3a>
    return 0;
3000f0ca:	2000      	movs	r0, #0
}
3000f0cc:	b009      	add	sp, #36	; 0x24
3000f0ce:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ASSERT(handle);
3000f0d2:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f0d6:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f0da:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f0de:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f0e2:	4670      	mov	r0, r14
3000f0e4:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f0e8:	9300      	str	r3, [sp, #0]
3000f0ea:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f0ee:	23c2      	movs	r3, #194	; 0xc2
3000f0f0:	f005 f890 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(src, MMC_BLOCK_SIZE));
3000f0f4:	f64e 539c 	movw	r3, #60828	; 0xed9c
3000f0f8:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f0fc:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f100:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f104:	4670      	mov	r0, r14
3000f106:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f10a:	9300      	str	r3, [sp, #0]
3000f10c:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f110:	23c3      	movs	r3, #195	; 0xc3
3000f112:	f005 f87f 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(length, MMC_BLOCK_SIZE));
3000f116:	f64e 53bc 	movw	r3, #60860	; 0xedbc
3000f11a:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f11e:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f122:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f126:	4670      	mov	r0, r14
3000f128:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f12c:	9300      	str	r3, [sp, #0]
3000f12e:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f132:	23c4      	movs	r3, #196	; 0xc4
3000f134:	f005 f86e 	bl	30014214 <_panic>

3000f138 <hal_mmc_write>:

int hal_mmc_write(void *handle, mmc_address_t dst, const uint8_t *src_buf,
                  mmc_length_t length)
{
3000f138:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000f13c:	b089      	sub	sp, #36	; 0x24
3000f13e:	f8dd a048 	ldr.w	r10, [r13, #72]	; 0x48
3000f142:	e9dd 4514 	ldrd	r4, r5, [r13, #80]	; 0x50
    LTRACEF("handle %p, dst %lld, len %lld, buf %p\n", handle, dst, length,
            src_buf);
    ASSERT(handle);
3000f146:	2800      	cmp	r0, #0
3000f148:	d05a      	beq.n	3000f200 <hal_mmc_write+0xc8>
3000f14a:	461f      	mov	r7, r3
    ASSERT(IS_ALIGNED(dst, MMC_BLOCK_SIZE));
3000f14c:	f3c2 0308 	ubfx	r3, r2, #0, #9
3000f150:	4616      	mov	r6, r2
3000f152:	2b00      	cmp	r3, #0
3000f154:	d165      	bne.n	3000f222 <hal_mmc_write+0xea>
    ASSERT(IS_ALIGNED(length, MMC_BLOCK_SIZE));
3000f156:	f3c4 0308 	ubfx	r3, r4, #0, #9
3000f15a:	2b00      	cmp	r3, #0
3000f15c:	d172      	bne.n	3000f244 <hal_mmc_write+0x10c>

    struct mmc_handle *mmc = handle;
    struct mmc_device *dev = mmc->priv_data;
3000f15e:	6a43      	ldr	r3, [r0, #36]	; 0x24
3000f160:	9303      	str	r3, [sp, #12]
    uint32_t write_len;
    uint8_t *buf;
    uint8_t use_local_buf = 0;
    mmc_length_t max_write_length = MMC_MAX_XFER_SIZE;

    if (!IS_ALIGNED(src_buf, CACHE_LINE)) {
3000f162:	f01a 031f 	ands.w	r3, r10, #31
3000f166:	d13a      	bne.n	3000f1de <hal_mmc_write+0xa6>
    uint8_t use_local_buf = 0;
3000f168:	9306      	str	r3, [sp, #24]
    mmc_length_t max_write_length = MMC_MAX_XFER_SIZE;
3000f16a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
3000f16e:	2300      	movs	r3, #0
3000f170:	e9cd 2304 	strd	r2, r3, [r13, #16]
        max_write_length = MMC_LOCAL_BUF_SIZE;
        use_local_buf = 1;
    }

    while (remaining) {
3000f174:	ea54 0305 	orrs.w	r3, r4, r5
3000f178:	d039      	beq.n	3000f1ee <hal_mmc_write+0xb6>
        buf = (uint8_t *)src_buf;
        write_len = MIN(remaining, max_write_length);

        if (use_local_buf) {
            buf = local_buf;
            memcpy(buf, src_buf, write_len);
3000f17a:	f24b 43a0 	movw	r3, #46240	; 0xb4a0
3000f17e:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000f182:	9307      	str	r3, [sp, #28]
3000f184:	e016      	b.n	3000f1b4 <hal_mmc_write+0x7c>
        }

        if (mmc_sdhci_write(dev, buf, dst / MMC_BLOCK_SIZE,
3000f186:	ea4f 235b 	mov.w	r3, r11, lsr #9
3000f18a:	9803      	ldr	r0, [sp, #12]
3000f18c:	0a72      	lsrs	r2, r6, #9
3000f18e:	9300      	str	r3, [sp, #0]
3000f190:	ea42 52c7 	orr.w	r2, r2, r7, lsl #23
3000f194:	0a7b      	lsrs	r3, r7, #9
3000f196:	f7fa fd3b 	bl	30009c10 <mmc_sdhci_write>
3000f19a:	bb60      	cbnz	r0, 3000f1f6 <hal_mmc_write+0xbe>
                            write_len / MMC_BLOCK_SIZE)) {
            return -1;
        }
        remaining -= write_len;
3000f19c:	ebb4 0408 	subs.w	r4, r4, r8
3000f1a0:	eb65 0509 	sbc.w	r5, r5, r9
        src_buf += write_len;
        dst += write_len;
3000f1a4:	eb16 0608 	adds.w	r6, r6, r8
3000f1a8:	eb47 0709 	adc.w	r7, r7, r9
    while (remaining) {
3000f1ac:	ea54 0305 	orrs.w	r3, r4, r5
        src_buf += write_len;
3000f1b0:	44da      	add	r10, r11
    while (remaining) {
3000f1b2:	d01c      	beq.n	3000f1ee <hal_mmc_write+0xb6>
        write_len = MIN(remaining, max_write_length);
3000f1b4:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
3000f1b8:	46a9      	mov	r9, r5
3000f1ba:	46a0      	mov	r8, r4
3000f1bc:	4651      	mov	r1, r10
3000f1be:	42ab      	cmp	r3, r5
3000f1c0:	bf08      	it	eq
3000f1c2:	42a2      	cmpeq	r2, r4
3000f1c4:	bf3c      	itt	cc
3000f1c6:	4699      	movcc	r9, r3
3000f1c8:	4690      	movcc	r8, r2
        if (use_local_buf) {
3000f1ca:	9b06      	ldr	r3, [sp, #24]
        write_len = MIN(remaining, max_write_length);
3000f1cc:	46c3      	mov	r11, r8
        if (use_local_buf) {
3000f1ce:	2b00      	cmp	r3, #0
3000f1d0:	d0d9      	beq.n	3000f186 <hal_mmc_write+0x4e>
            memcpy(buf, src_buf, write_len);
3000f1d2:	9807      	ldr	r0, [sp, #28]
3000f1d4:	4642      	mov	r2, r8
3000f1d6:	f005 eb46 	blx	30014864 <memcpy>
            buf = local_buf;
3000f1da:	9907      	ldr	r1, [sp, #28]
3000f1dc:	e7d3      	b.n	3000f186 <hal_mmc_write+0x4e>
        max_write_length = MMC_LOCAL_BUF_SIZE;
3000f1de:	2300      	movs	r3, #0
3000f1e0:	f44f 7200 	mov.w	r2, #512	; 0x200
3000f1e4:	e9cd 2304 	strd	r2, r3, [r13, #16]
        use_local_buf = 1;
3000f1e8:	2301      	movs	r3, #1
3000f1ea:	9306      	str	r3, [sp, #24]
3000f1ec:	e7c2      	b.n	3000f174 <hal_mmc_write+0x3c>
    }
    return 0;
3000f1ee:	2000      	movs	r0, #0
}
3000f1f0:	b009      	add	sp, #36	; 0x24
3000f1f2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            return -1;
3000f1f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000f1fa:	b009      	add	sp, #36	; 0x24
3000f1fc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ASSERT(handle);
3000f200:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f204:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f208:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f20c:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f210:	4670      	mov	r0, r14
3000f212:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f216:	9300      	str	r3, [sp, #0]
3000f218:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f21c:	23ee      	movs	r3, #238	; 0xee
3000f21e:	f004 fff9 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(dst, MMC_BLOCK_SIZE));
3000f222:	f64e 6304 	movw	r3, #60932	; 0xee04
3000f226:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f22a:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f22e:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f232:	4670      	mov	r0, r14
3000f234:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f238:	9300      	str	r3, [sp, #0]
3000f23a:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f23e:	23ef      	movs	r3, #239	; 0xef
3000f240:	f004 ffe8 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(length, MMC_BLOCK_SIZE));
3000f244:	f64e 53bc 	movw	r3, #60860	; 0xedbc
3000f248:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f24c:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f250:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f254:	4670      	mov	r0, r14
3000f256:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f25a:	9300      	str	r3, [sp, #0]
3000f25c:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f260:	23f0      	movs	r3, #240	; 0xf0
3000f262:	f004 ffd7 	bl	30014214 <_panic>
3000f266:	bf00      	nop

3000f268 <hal_mmc_erase>:

/* The erase length must multiple the device erase group unit size */
int hal_mmc_erase(void *handle, mmc_address_t dst, mmc_length_t length)
{
3000f268:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000f26c:	469b      	mov	r11, r3
3000f26e:	b085      	sub	sp, #20
3000f270:	4677      	mov	r7, r14
3000f272:	e9dd 340e 	ldrd	r3, r4, [r13, #56]	; 0x38
3000f276:	e9cd 3402 	strd	r3, r4, [r13, #8]
    LTRACEF("handle %p, dst %lld, len %lld\n", handle, dst, length);
    ASSERT(handle);
3000f27a:	2800      	cmp	r0, #0
3000f27c:	d044      	beq.n	3000f308 <hal_mmc_erase+0xa0>
    struct mmc_handle *mmc = handle;
    /* The erase address and size need erase group size aligned */
    ASSERT(DIV_ROUND_UP(dst, mmc->erase_grp_size) == dst / mmc->erase_grp_size);
3000f27e:	6904      	ldr	r4, [r0, #16]
3000f280:	f112 38ff 	adds.w	r8, r2, #4294967295	; 0xffffffff
3000f284:	f04f 0500 	mov.w	r5, #0
3000f288:	f14b 39ff 	adc.w	r9, r11, #4294967295	; 0xffffffff
3000f28c:	4606      	mov	r6, r0
3000f28e:	eb18 0004 	adds.w	r0, r8, r4
3000f292:	4692      	mov	r10, r2
3000f294:	eb49 0105 	adc.w	r1, r9, r5
3000f298:	4622      	mov	r2, r4
3000f29a:	462b      	mov	r3, r5
3000f29c:	f00a fdc0 	bl	30019e20 <__aeabi_uldivmod>
3000f2a0:	4622      	mov	r2, r4
3000f2a2:	462b      	mov	r3, r5
3000f2a4:	4680      	mov	r8, r0
3000f2a6:	4689      	mov	r9, r1
3000f2a8:	4650      	mov	r0, r10
3000f2aa:	4659      	mov	r1, r11
3000f2ac:	f00a fdb8 	bl	30019e20 <__aeabi_uldivmod>
3000f2b0:	4589      	cmp	r9, r1
3000f2b2:	bf08      	it	eq
3000f2b4:	4580      	cmpeq	r8, r0
3000f2b6:	d139      	bne.n	3000f32c <hal_mmc_erase+0xc4>
    ASSERT(DIV_ROUND_UP(length, mmc->erase_grp_size) ==
3000f2b8:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
3000f2bc:	f112 32ff 	adds.w	r2, r2, #4294967295	; 0xffffffff
3000f2c0:	4690      	mov	r8, r2
3000f2c2:	f143 33ff 	adc.w	r3, r3, #4294967295	; 0xffffffff
3000f2c6:	4699      	mov	r9, r3
3000f2c8:	eb18 0004 	adds.w	r0, r8, r4
3000f2cc:	4622      	mov	r2, r4
3000f2ce:	eb49 0105 	adc.w	r1, r9, r5
3000f2d2:	462b      	mov	r3, r5
3000f2d4:	f00a fda4 	bl	30019e20 <__aeabi_uldivmod>
3000f2d8:	4622      	mov	r2, r4
3000f2da:	462b      	mov	r3, r5
3000f2dc:	4680      	mov	r8, r0
3000f2de:	4689      	mov	r9, r1
3000f2e0:	e9dd 0102 	ldrd	r0, r1, [r13, #8]
3000f2e4:	f00a fd9c 	bl	30019e20 <__aeabi_uldivmod>
3000f2e8:	4589      	cmp	r9, r1
3000f2ea:	bf08      	it	eq
3000f2ec:	4580      	cmpeq	r8, r0
3000f2ee:	d12f      	bne.n	3000f350 <hal_mmc_erase+0xe8>
                 length / mmc->erase_grp_size);

    struct mmc_device *dev = mmc->priv_data;

    return mmc_sdhci_erase(dev, dst / MMC_BLOCK_SIZE, length);
3000f2f0:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
3000f2f4:	ea4f 215a 	mov.w	r1, r10, lsr #9
3000f2f8:	6a70      	ldr	r0, [r6, #36]	; 0x24
3000f2fa:	ea41 51cb 	orr.w	r1, r1, r11, lsl #23
}
3000f2fe:	b005      	add	sp, #20
3000f300:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    return mmc_sdhci_erase(dev, dst / MMC_BLOCK_SIZE, length);
3000f304:	f7fa bcf2 	b.w	30009cec <mmc_sdhci_erase>
    ASSERT(handle);
3000f308:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f30c:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f310:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f314:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f318:	4670      	mov	r0, r14
3000f31a:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f31e:	9300      	str	r3, [sp, #0]
3000f320:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f324:	f240 1317 	movw	r3, #279	; 0x117
3000f328:	f004 ff74 	bl	30014214 <_panic>
    ASSERT(DIV_ROUND_UP(dst, mmc->erase_grp_size) == dst / mmc->erase_grp_size);
3000f32c:	f64e 43a4 	movw	r3, #60580	; 0xeca4
3000f330:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f334:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f338:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f33c:	4638      	mov	r0, r7
3000f33e:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f342:	9300      	str	r3, [sp, #0]
3000f344:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f348:	f44f 738d 	mov.w	r3, #282	; 0x11a
3000f34c:	f004 ff62 	bl	30014214 <_panic>
    ASSERT(DIV_ROUND_UP(length, mmc->erase_grp_size) ==
3000f350:	f64e 43e8 	movw	r3, #60648	; 0xece8
3000f354:	f64e 52e0 	movw	r2, #60896	; 0xede0
3000f358:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f35c:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f360:	4638      	mov	r0, r7
3000f362:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f366:	9300      	str	r3, [sp, #0]
3000f368:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f36c:	f44f 738e 	mov.w	r3, #284	; 0x11c
3000f370:	f004 ff50 	bl	30014214 <_panic>

3000f374 <hal_mmc_get_capacity>:
    return mmc_sdhci_cancel(dev);
}

mmc_length_t hal_mmc_get_capacity(void *handle)
{
    ASSERT(handle);
3000f374:	b148      	cbz	r0, 3000f38a <hal_mmc_get_capacity+0x16>
    struct mmc_handle *mmc = handle;
    struct mmc_device *dev = mmc->priv_data;
3000f376:	6a43      	ldr	r3, [r0, #36]	; 0x24

    if (dev) {
3000f378:	b113      	cbz	r3, 3000f380 <hal_mmc_get_capacity+0xc>
        return dev->card.capacity;
3000f37a:	e9d3 013e 	ldrd	r0, r1, [r3, #248]	; 0xf8
3000f37e:	4770      	bx	r14
    }
    else {
        return -1;
3000f380:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000f384:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    }
}
3000f388:	4770      	bx	r14
    ASSERT(handle);
3000f38a:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f38e:	f64e 52e0 	movw	r2, #60896	; 0xede0
{
3000f392:	b500      	push	{r14}
    ASSERT(handle);
3000f394:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f398:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000f39c:	b083      	sub	sp, #12
3000f39e:	4670      	mov	r0, r14
    ASSERT(handle);
3000f3a0:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f3a4:	9300      	str	r3, [sp, #0]
3000f3a6:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f3aa:	f44f 7398 	mov.w	r3, #304	; 0x130
3000f3ae:	f004 ff31 	bl	30014214 <_panic>
3000f3b2:	bf00      	nop

3000f3b4 <hal_mmc_get_block_size>:

uint32_t hal_mmc_get_block_size(void *handle)
{
    ASSERT(handle);
3000f3b4:	b108      	cbz	r0, 3000f3ba <hal_mmc_get_block_size+0x6>
        return mmc->block_size;
    }
    else {
        return -1;
    }
}
3000f3b6:	68c0      	ldr	r0, [r0, #12]
3000f3b8:	4770      	bx	r14
    ASSERT(handle);
3000f3ba:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f3be:	f64e 52e0 	movw	r2, #60896	; 0xede0
{
3000f3c2:	b500      	push	{r14}
    ASSERT(handle);
3000f3c4:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f3c8:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000f3cc:	b083      	sub	sp, #12
3000f3ce:	4670      	mov	r0, r14
    ASSERT(handle);
3000f3d0:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f3d4:	9300      	str	r3, [sp, #0]
3000f3d6:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f3da:	f44f 739f 	mov.w	r3, #318	; 0x13e
3000f3de:	f004 ff19 	bl	30014214 <_panic>
3000f3e2:	bf00      	nop

3000f3e4 <hal_mmc_get_erase_grp_size>:

uint32_t hal_mmc_get_erase_grp_size(void *handle)
{
    ASSERT(handle);
3000f3e4:	b108      	cbz	r0, 3000f3ea <hal_mmc_get_erase_grp_size+0x6>
        return mmc->erase_grp_size;
    }
    else {
        return -1;
    }
}
3000f3e6:	6900      	ldr	r0, [r0, #16]
3000f3e8:	4770      	bx	r14
    ASSERT(handle);
3000f3ea:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f3ee:	f64e 52e0 	movw	r2, #60896	; 0xede0
{
3000f3f2:	b500      	push	{r14}
    ASSERT(handle);
3000f3f4:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f3f8:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000f3fc:	b083      	sub	sp, #12
3000f3fe:	4670      	mov	r0, r14
    ASSERT(handle);
3000f400:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f404:	9300      	str	r3, [sp, #0]
3000f406:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f40a:	f240 134b 	movw	r3, #331	; 0x14b
3000f40e:	f004 ff01 	bl	30014214 <_panic>
3000f412:	bf00      	nop

3000f414 <hal_mmc_switch_part>:

int hal_mmc_switch_part(void *handle, enum part_access_type part_no)
{
    LTRACEF("handle %p, part_no %d\n", handle, part_no);
    ASSERT(handle);
3000f414:	b110      	cbz	r0, 3000f41c <hal_mmc_switch_part+0x8>
    struct mmc_handle *mmc = handle;
    struct mmc_device *dev = mmc->priv_data;

    return mmc_sdhci_switch_part(dev, part_no);
3000f416:	6a40      	ldr	r0, [r0, #36]	; 0x24
3000f418:	f7fa bdfa 	b.w	3000a010 <mmc_sdhci_switch_part>
    ASSERT(handle);
3000f41c:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f420:	f64e 52e0 	movw	r2, #60896	; 0xede0
{
3000f424:	b500      	push	{r14}
    ASSERT(handle);
3000f426:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f42a:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000f42e:	b083      	sub	sp, #12
3000f430:	4670      	mov	r0, r14
    ASSERT(handle);
3000f432:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f436:	9300      	str	r3, [sp, #0]
3000f438:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f43c:	f240 1359 	movw	r3, #345	; 0x159
3000f440:	f004 fee8 	bl	30014214 <_panic>

3000f444 <mshc_clkgen_config.isra.4>:
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
    }
    return ret;
}

static int mshc_clkgen_config(struct sdhci_host *host, unsigned int freq)
3000f444:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
{
    int ret = 0;
    void *mmc_ckgen_handle;
    clkgen_app_ip_cfg_t ip_cfg;
    ip_cfg.clk_src_select_num = 4;
3000f448:	2304      	movs	r3, #4
static int mshc_clkgen_config(struct sdhci_host *host, unsigned int freq)
3000f44a:	b084      	sub	sp, #16
3000f44c:	4606      	mov	r6, r0
    uint32_t pre_div, post_div;
    uint32_t clock_div_succ = 0;
    uint32_t freq_bias = mshc_base_freq;
    uint32_t curr_freq_bias;

    if (!hal_clock_creat_handle(&mmc_ckgen_handle)) {
3000f44e:	4668      	mov	r0, r13
    ip_cfg.clk_src_select_num = 4;
3000f450:	f88d 3004 	strb.w	r3, [r13, #4]
static int mshc_clkgen_config(struct sdhci_host *host, unsigned int freq)
3000f454:	460c      	mov	r4, r1
    if (!hal_clock_creat_handle(&mmc_ckgen_handle)) {
3000f456:	f7ff fbc5 	bl	3000ebe4 <hal_clock_creat_handle>
3000f45a:	2800      	cmp	r0, #0
3000f45c:	f000 8085 	beq.w	3000f56a <mshc_clkgen_config.isra.4+0x126>
        printf("%s: clkgen creat handle failed\n", __FUNCTION__);
        return -1;
    }

    clock_div = DIV_ROUND_UP(mshc_base_freq, freq);
3000f460:	f248 33ff 	movw	r3, #33791	; 0x83ff
3000f464:	f04f 0c00 	mov.w	r12, #0
    uint32_t freq_bias = mshc_base_freq;
3000f468:	f44f 4704 	mov.w	r7, #33792	; 0x8400
    clock_div = DIV_ROUND_UP(mshc_base_freq, freq);
3000f46c:	f2c1 73d7 	movt	r3, #6103	; 0x17d7
3000f470:	f8dd 9008 	ldr.w	r9, [r13, #8]
3000f474:	4423      	add	r3, r4
3000f476:	f8dd 800c 	ldr.w	r8, [r13, #12]
    uint32_t clock_div_succ = 0;
3000f47a:	46e6      	mov	r14, r12
    clock_div = DIV_ROUND_UP(mshc_base_freq, freq);
3000f47c:	fbb3 f1f4 	udiv	r1, r3, r4

    for (int i = 0; i <= CLKGEN_PRE_DIV_NUM_MAX; i++) {
3000f480:	4662      	mov	r2, r12
    uint32_t freq_bias = mshc_base_freq;
3000f482:	f2c1 77d7 	movt	r7, #6103	; 0x17d7
        pre_div = i;
3000f486:	4615      	mov	r5, r2
        post_div = DIV_ROUND_UP(clock_div, i + 1) - 1;
3000f488:	3201      	adds	r2, #1
3000f48a:	194b      	adds	r3, r1, r5
3000f48c:	fbb3 f3f2 	udiv	r3, r3, r2
                ip_cfg.post_div = post_div;
                clock_div_succ = 1;
                break;
            }

            curr_freq_bias = abs((pre_div + 1) * (post_div + 1) - clock_div);
3000f490:	fb03 f402 	mul.w	r4, r3, r2
        post_div = DIV_ROUND_UP(clock_div, i + 1) - 1;
3000f494:	3b01      	subs	r3, #1
        if (post_div <= CLKGEN_POST_DIV_NUM_MAX) {
3000f496:	2b3f      	cmp	r3, #63	; 0x3f
            curr_freq_bias = abs((pre_div + 1) * (post_div + 1) - clock_div);
3000f498:	eba4 0401 	sub.w	r4, r4, r1
        if (post_div <= CLKGEN_POST_DIV_NUM_MAX) {
3000f49c:	d812      	bhi.n	3000f4c4 <mshc_clkgen_config.isra.4+0x80>
            if (0 == clock_div % (pre_div + 1)) {
3000f49e:	fbb1 faf2 	udiv	r10, r1, r2
static inline uint32_t abs(int a) { return (a > 0) ? a : -a; }
3000f4a2:	2c00      	cmp	r4, #0
3000f4a4:	bfb8      	it	lt
3000f4a6:	4264      	neglt	r4, r4
            if (0 == clock_div % (pre_div + 1)) {
3000f4a8:	fb02 1a1a 	mls	r10, r2, r10, r1
3000f4ac:	f1ba 0f00 	cmp.w	r10, #0
3000f4b0:	d04b      	beq.n	3000f54a <mshc_clkgen_config.isra.4+0x106>
            if (curr_freq_bias < freq_bias) {
3000f4b2:	42bc      	cmp	r4, r7
3000f4b4:	bf3f      	itttt	cc
3000f4b6:	4698      	movcc	r8, r3
        pre_div = i;
3000f4b8:	46a9      	movcc	r9, r5
            if (curr_freq_bias < freq_bias) {
3000f4ba:	4627      	movcc	r7, r4
3000f4bc:	4684      	movcc	r12, r0
                freq_bias = curr_freq_bias;
                ip_cfg.pre_div = pre_div;
                ip_cfg.post_div = post_div;
                clock_div_succ = 1;
3000f4be:	bf38      	it	cc
3000f4c0:	f04f 0e01 	movcc.w	r14, #1
    for (int i = 0; i <= CLKGEN_PRE_DIV_NUM_MAX; i++) {
3000f4c4:	2a08      	cmp	r2, #8
3000f4c6:	d1de      	bne.n	3000f486 <mshc_clkgen_config.isra.4+0x42>
3000f4c8:	f1bc 0f00 	cmp.w	r12, #0
3000f4cc:	d15a      	bne.n	3000f584 <mshc_clkgen_config.isra.4+0x140>
            }
        }
    }

    if (0 == clock_div_succ) {
3000f4ce:	f1be 0f00 	cmp.w	r14, #0
3000f4d2:	d02d      	beq.n	3000f530 <mshc_clkgen_config.isra.4+0xec>
                __FUNCTION__);
        ret = -1;
        goto clkgen_release_handle;
    }

    if (!hal_clock_ipclk_set(mmc_ckgen_handle,
3000f4d4:	6833      	ldr	r3, [r6, #0]
3000f4d6:	f245 1468 	movw	r4, #20840	; 0x5168
3000f4da:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000f4de:	9800      	ldr	r0, [sp, #0]
3000f4e0:	aa01      	add	r2, sp, #4
3000f4e2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
3000f4e6:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
3000f4ea:	6959      	ldr	r1, [r3, #20]
3000f4ec:	f7ff fbd2 	bl	3000ec94 <hal_clock_ipclk_set>
3000f4f0:	b188      	cbz	r0, 3000f516 <mshc_clkgen_config.isra.4+0xd2>
        ret = -1;
        goto clkgen_release_handle;
    }

    /*enable mmc host clock*/
    if (!hal_clock_enable(mmc_ckgen_handle,
3000f4f2:	6833      	ldr	r3, [r6, #0]
3000f4f4:	9800      	ldr	r0, [sp, #0]
3000f4f6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
3000f4fa:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
3000f4fe:	69a1      	ldr	r1, [r4, #24]
    int ret = 0;
3000f500:	2400      	movs	r4, #0
    if (!hal_clock_enable(mmc_ckgen_handle,
3000f502:	f7ff fb93 	bl	3000ec2c <hal_clock_enable>
3000f506:	b318      	cbz	r0, 3000f550 <mshc_clkgen_config.isra.4+0x10c>
        goto clkgen_release_handle;
    }

clkgen_release_handle:
    /*release clock handle*/
    hal_clock_release_handle(mmc_ckgen_handle);
3000f508:	9800      	ldr	r0, [sp, #0]
3000f50a:	f7ff fb87 	bl	3000ec1c <hal_clock_release_handle>

    return ret;
}
3000f50e:	4620      	mov	r0, r4
3000f510:	b004      	add	sp, #16
3000f512:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        dprintf(CRITICAL, "%s: clkgen set ip clock failed\n", __FUNCTION__);
3000f516:	f64e 6124 	movw	r1, #60964	; 0xee24
3000f51a:	f64e 60a8 	movw	r0, #61096	; 0xeea8
3000f51e:	f2c3 0101 	movt	r1, #12289	; 0x3001
        ret = -1;
3000f522:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "%s: clkgen set ip clock failed\n", __FUNCTION__);
3000f526:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f52a:	f006 fb41 	bl	30015bb0 <_printf>
3000f52e:	e7eb      	b.n	3000f508 <mshc_clkgen_config.isra.4+0xc4>
        dprintf(CRITICAL, "%s: calculate the clock div failed!\n",
3000f530:	f64e 6124 	movw	r1, #60964	; 0xee24
3000f534:	f64e 6080 	movw	r0, #61056	; 0xee80
3000f538:	f2c3 0101 	movt	r1, #12289	; 0x3001
        ret = -1;
3000f53c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "%s: calculate the clock div failed!\n",
3000f540:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f544:	f006 fb34 	bl	30015bb0 <_printf>
3000f548:	e7de      	b.n	3000f508 <mshc_clkgen_config.isra.4+0xc4>
                ip_cfg.post_div = post_div;
3000f54a:	e9cd 5302 	strd	r5, r3, [r13, #8]
3000f54e:	e7c1      	b.n	3000f4d4 <mshc_clkgen_config.isra.4+0x90>
        dprintf(CRITICAL, "%s: clkgen enable ip clock failed\n", __FUNCTION__);
3000f550:	f64e 6124 	movw	r1, #60964	; 0xee24
3000f554:	f64e 60c8 	movw	r0, #61128	; 0xeec8
3000f558:	f2c3 0101 	movt	r1, #12289	; 0x3001
        ret = -1;
3000f55c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "%s: clkgen enable ip clock failed\n", __FUNCTION__);
3000f560:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f564:	f006 fb24 	bl	30015bb0 <_printf>
3000f568:	e7ce      	b.n	3000f508 <mshc_clkgen_config.isra.4+0xc4>
        printf("%s: clkgen creat handle failed\n", __FUNCTION__);
3000f56a:	f64e 6124 	movw	r1, #60964	; 0xee24
3000f56e:	f64e 6060 	movw	r0, #61024	; 0xee60
3000f572:	f2c3 0101 	movt	r1, #12289	; 0x3001
        return -1;
3000f576:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        printf("%s: clkgen creat handle failed\n", __FUNCTION__);
3000f57a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f57e:	f006 fb17 	bl	30015bb0 <_printf>
3000f582:	e7c4      	b.n	3000f50e <mshc_clkgen_config.isra.4+0xca>
3000f584:	e9cd 9802 	strd	r9, r8, [r13, #8]
3000f588:	e7a1      	b.n	3000f4ce <mshc_clkgen_config.isra.4+0x8a>
3000f58a:	bf00      	nop

3000f58c <mshc_set_uhs_mode>:
    if (mshc_phy_init(host))
        dprintf(CRITICAL, "mshc: phy init failed!\n");
}

static void mshc_set_uhs_mode(struct sdhci_host *host, uint32_t mode)
{
3000f58c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000f58e:	4604      	mov	r4, r0
3000f590:	460d      	mov	r5, r1
    sdhci_set_uhs_mode(host, mode);
3000f592:	f7f8 fc7f 	bl	30007e94 <sdhci_set_uhs_mode>
    if (mode > SDHCI_EMMC_HS200_MODE)
        ddr_mode = 1;

    /* set mshc ddr mode in scr */

    scr_write_signal(g_mmc_priv_res[host->slot].ddr_mode_scr_signal, ddr_mode);
3000f596:	f245 1368 	movw	r3, #20840	; 0x5168
3000f59a:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000f59e:	6822      	ldr	r2, [r4, #0]
3000f5a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
3000f5a4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    handle = hal_scr_create_handle(signal);
3000f5a8:	e9d3 0108 	ldrd	r0, r1, [r3, #32]
3000f5ac:	f000 fc22 	bl	3000fdf4 <hal_scr_create_handle>
3000f5b0:	4606      	mov	r6, r0
3000f5b2:	460f      	mov	r7, r1
    if (handle) {
3000f5b4:	ea56 0307 	orrs.w	r3, r6, r7
3000f5b8:	d00e      	beq.n	3000f5d8 <mshc_set_uhs_mode+0x4c>
        ret = hal_scr_set(handle, val);
3000f5ba:	2d03      	cmp	r5, #3
3000f5bc:	bf94      	ite	ls
3000f5be:	2200      	movls	r2, #0
3000f5c0:	2201      	movhi	r2, #1
3000f5c2:	f000 fc49 	bl	3000fe58 <hal_scr_set>
        if (!ret)
3000f5c6:	2800      	cmp	r0, #0
3000f5c8:	d052      	beq.n	3000f670 <mshc_set_uhs_mode+0xe4>
        hal_scr_delete_handle(handle);
3000f5ca:	4630      	mov	r0, r6
3000f5cc:	4639      	mov	r1, r7
3000f5ce:	f000 fc13 	bl	3000fdf8 <hal_scr_delete_handle>

    if (mode == SDHCI_EMMC_HS400_MODE) {
3000f5d2:	2d07      	cmp	r5, #7
3000f5d4:	d008      	beq.n	3000f5e8 <mshc_set_uhs_mode+0x5c>
        if (mshc_phy_dll_config(host))
            dprintf(CRITICAL, "mshc phy dll config failed!\n");
    }

    return;
}
3000f5d6:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "mshc: failed to create scr handle!\n");
3000f5d8:	f64e 7048 	movw	r0, #61256	; 0xef48
3000f5dc:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f5e0:	f006 fae6 	bl	30015bb0 <_printf>
    if (mode == SDHCI_EMMC_HS400_MODE) {
3000f5e4:	2d07      	cmp	r5, #7
3000f5e6:	d1f6      	bne.n	3000f5d6 <mshc_set_uhs_mode+0x4a>
    REG_WRITE8(host, 0, DWC_MSHC_DLL_CTRL);
3000f5e8:	2200      	movs	r2, #0
    REG_WRITE8(host, 0x20, DWC_MSHC_DLL_CNFG1);
3000f5ea:	2620      	movs	r6, #32
    REG_WRITE8(host, 0, DWC_MSHC_DLL_CTRL);
3000f5ec:	6863      	ldr	r3, [r4, #4]
    REG_WRITE8(host, 0x60, DWC_MSHC_DLLDL_CNFG);
3000f5ee:	2560      	movs	r5, #96	; 0x60
    REG_WRITE8(host, 0, DWC_MSHC_DLL_CTRL);
3000f5f0:	f883 2324 	strb.w	r2, [r3, #804]	; 0x324
    REG_WRITE8(host, 0x1, DWC_MSHC_DLL_CTRL);
3000f5f4:	2001      	movs	r0, #1
    clk_ctrl = REG_READ16(host, SDHCI_CLK_CTRL_REG);
3000f5f6:	6861      	ldr	r1, [r4, #4]
3000f5f8:	8d8b      	ldrh	r3, [r1, #44]	; 0x2c
    clk_ctrl &= ~SDHCI_CLK_EN;
3000f5fa:	f023 0304 	bic.w	r3, r3, #4
3000f5fe:	041b      	lsls	r3, r3, #16
3000f600:	0c1b      	lsrs	r3, r3, #16
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f602:	858b      	strh	r3, [r1, #44]	; 0x2c
    clk_ctrl |= SDHCI_CLK_EN;
3000f604:	f043 0304 	orr.w	r3, r3, #4
    REG_WRITE8(host, 0x20, DWC_MSHC_DLL_CNFG1);
3000f608:	f881 6325 	strb.w	r6, [r1, #805]	; 0x325
    REG_WRITE8(host, 0, DWC_MSHC_DLL_CNFG2);
3000f60c:	6861      	ldr	r1, [r4, #4]
3000f60e:	f881 2326 	strb.w	r2, [r1, #806]	; 0x326
    REG_WRITE8(host, 0x60, DWC_MSHC_DLLDL_CNFG);
3000f612:	6861      	ldr	r1, [r4, #4]
3000f614:	f881 5328 	strb.w	r5, [r1, #808]	; 0x328
    REG_WRITE8(host, 0, DWC_MSHC_DLL_OFFSET);
3000f618:	6861      	ldr	r1, [r4, #4]
3000f61a:	f881 2329 	strb.w	r2, [r1, #809]	; 0x329
    REG_WRITE16(host, 0, DWC_MSHC_DLLLBT_CNFG);
3000f61e:	6861      	ldr	r1, [r4, #4]
3000f620:	f8a1 232c 	strh.w	r2, [r1, #812]	; 0x32c
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f624:	858b      	strh	r3, [r1, #44]	; 0x2c
    REG_WRITE8(host, 0x1, DWC_MSHC_DLL_CTRL);
3000f626:	f881 0324 	strb.w	r0, [r1, #804]	; 0x324
    timeout = current_time() + ms;
3000f62a:	f7f1 f97f 	bl	3000092c <current_time>
        val = REG_READ16(host, reg);
3000f62e:	6863      	ldr	r3, [r4, #4]
3000f630:	f203 322e 	addw	r2, r3, #814	; 0x32e
3000f634:	f8b3 332e 	ldrh.w	r3, [r3, #814]	; 0x32e
    timeout = current_time() + ms;
3000f638:	f100 0596 	add.w	r5, r0, #150	; 0x96
        if (val == mask)
3000f63c:	07d8      	lsls	r0, r3, #31
3000f63e:	d41e      	bmi.n	3000f67e <mshc_set_uhs_mode+0xf2>
3000f640:	e008      	b.n	3000f654 <mshc_set_uhs_mode+0xc8>
        spin(1);
3000f642:	f004 fdd5 	bl	300141f0 <spin>
        val = REG_READ16(host, reg);
3000f646:	6863      	ldr	r3, [r4, #4]
3000f648:	f203 322e 	addw	r2, r3, #814	; 0x32e
3000f64c:	f8b3 332e 	ldrh.w	r3, [r3, #814]	; 0x32e
        if (val == mask)
3000f650:	07d9      	lsls	r1, r3, #31
3000f652:	d414      	bmi.n	3000f67e <mshc_set_uhs_mode+0xf2>
        if (current_time() > timeout)
3000f654:	f7f1 f96a 	bl	3000092c <current_time>
3000f658:	4285      	cmp	r5, r0
        spin(1);
3000f65a:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000f65e:	d2f0      	bcs.n	3000f642 <mshc_set_uhs_mode+0xb6>
            dprintf(CRITICAL, "mshc phy dll config failed!\n");
3000f660:	f64e 706c 	movw	r0, #61292	; 0xef6c
3000f664:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000f668:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            dprintf(CRITICAL, "mshc phy dll config failed!\n");
3000f66c:	f006 baa0 	b.w	30015bb0 <_printf>
            dprintf(CRITICAL, "mshc: failed to set scr!\n");
3000f670:	f64e 702c 	movw	r0, #61228	; 0xef2c
3000f674:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f678:	f006 fa9a 	bl	30015bb0 <_printf>
3000f67c:	e7a5      	b.n	3000f5ca <mshc_set_uhs_mode+0x3e>
        ret = REG_READ8(host, DWC_MSHC_DLL_STATUS) & ERROR_STS;
3000f67e:	7813      	ldrb	r3, [r2, #0]
        if (mshc_phy_dll_config(host))
3000f680:	079b      	lsls	r3, r3, #30
3000f682:	d4ed      	bmi.n	3000f660 <mshc_set_uhs_mode+0xd4>
}
3000f684:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
3000f686:	bf00      	nop

3000f688 <mshc_init>:
{
3000f688:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
3000f68a:	4604      	mov	r4, r0
    REG_WRITE32(host, 0, DWC_MSHC_PHY_CNFG);
3000f68c:	2000      	movs	r0, #0
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_DAT, DWC_MSHC_CMDPAD_CNFG);
3000f68e:	f240 4649 	movw	r6, #1097	; 0x449
    vender_base = REG_READ16(host, SDHCI_VENDOR_BASE_REG) & 0xFFF;
3000f692:	6863      	ldr	r3, [r4, #4]
3000f694:	f8b3 10e8 	ldrh.w	r1, [r3, #232]	; 0xe8
    card_is_emmc = !host->card_type;
3000f698:	6f65      	ldr	r5, [r4, #116]	; 0x74
    reg = REG_READ16(host, vender_base + SDHCI_VENDER_EMMC_CTRL_REG);
3000f69a:	f3c1 010b 	ubfx	r1, r1, #0, #12
3000f69e:	f103 072c 	add.w	r7, r3, #44	; 0x2c
3000f6a2:	5bca      	ldrh	r2, [r1, r7]
    reg &= ~SDHCI_IS_EMMC_CARD_MASK;
3000f6a4:	f022 0201 	bic.w	r2, r2, #1
3000f6a8:	0412      	lsls	r2, r2, #16
3000f6aa:	0c12      	lsrs	r2, r2, #16
    reg |= card_is_emmc;
3000f6ac:	4285      	cmp	r5, r0
3000f6ae:	bf08      	it	eq
3000f6b0:	f042 0201 	orreq.w	r2, r2, #1
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_STB, DWC_MSHC_STBPAD_CNFG);
3000f6b4:	f240 4551 	movw	r5, #1105	; 0x451
    REG_WRITE16(host, reg, vender_base + SDHCI_VENDER_EMMC_CTRL_REG);
3000f6b8:	53ca      	strh	r2, [r1, r7]
    REG_WRITE8(host, 1, DWC_MSHC_COMMDL_CNFG);
3000f6ba:	2101      	movs	r1, #1
    REG_WRITE32(host, 0, DWC_MSHC_PHY_CNFG);
3000f6bc:	f8c3 0300 	str.w	r0, [r3, #768]	; 0x300
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_CLK, DWC_MSHC_CLKPAD_CNFG);
3000f6c0:	f44f 6788 	mov.w	r7, #1088	; 0x440
    REG_WRITE16(host, 0, SDHCI_CLK_CTRL_REG);
3000f6c4:	8598      	strh	r0, [r3, #44]	; 0x2c
    clk_ctrl = REG_READ16(host, SDHCI_CLK_CTRL_REG);
3000f6c6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    clk_ctrl &= ~SDHCI_CLK_EN;
3000f6c8:	f022 0204 	bic.w	r2, r2, #4
3000f6cc:	0412      	lsls	r2, r2, #16
3000f6ce:	0c12      	lsrs	r2, r2, #16
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f6d0:	859a      	strh	r2, [r3, #44]	; 0x2c
    REG_WRITE8(host, 8, DWC_MSHC_SMPLDL_CNFG);
3000f6d2:	2208      	movs	r2, #8
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_DAT, DWC_MSHC_CMDPAD_CNFG);
3000f6d4:	f8a3 6304 	strh.w	r6, [r3, #772]	; 0x304
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_DAT, DWC_MSHC_DATPAD_CNFG);
3000f6d8:	f8a3 6306 	strh.w	r6, [r3, #774]	; 0x306
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_CLK, DWC_MSHC_CLKPAD_CNFG);
3000f6dc:	f8a3 7308 	strh.w	r7, [r3, #776]	; 0x308
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_STB, DWC_MSHC_STBPAD_CNFG);
3000f6e0:	f8a3 530a 	strh.w	r5, [r3, #778]	; 0x30a
        REG_WRITE16(host, DWC_MSHC_PHY_PAD_EMMC_DAT, DWC_MSHC_RSTNPAD_CNFG);
3000f6e4:	f8a3 630c 	strh.w	r6, [r3, #780]	; 0x30c
    REG_WRITE8(host, 1, DWC_MSHC_COMMDL_CNFG);
3000f6e8:	f883 131c 	strb.w	r1, [r3, #796]	; 0x31c
    REG_WRITE8(host, 0, DWC_MSHC_SDCLKDL_CNFG);
3000f6ec:	6863      	ldr	r3, [r4, #4]
3000f6ee:	f883 031d 	strb.w	r0, [r3, #797]	; 0x31d
    REG_WRITE8(host, 8, DWC_MSHC_SMPLDL_CNFG);
3000f6f2:	6863      	ldr	r3, [r4, #4]
3000f6f4:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    REG_WRITE8(host, 8, DWC_MSHC_ATDL_CNFG);
3000f6f8:	6863      	ldr	r3, [r4, #4]
3000f6fa:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    timeout = current_time() + ms;
3000f6fe:	f7f1 f915 	bl	3000092c <current_time>
        val = REG_READ16(host, reg);
3000f702:	6863      	ldr	r3, [r4, #4]
3000f704:	f503 7240 	add.w	r2, r3, #768	; 0x300
3000f708:	f8b3 3300 	ldrh.w	r3, [r3, #768]	; 0x300
        if (val == mask)
3000f70c:	0799      	lsls	r1, r3, #30
3000f70e:	d419      	bmi.n	3000f744 <mshc_init+0xbc>
3000f710:	f100 0596 	add.w	r5, r0, #150	; 0x96
3000f714:	e008      	b.n	3000f728 <mshc_init+0xa0>
        spin(1);
3000f716:	f004 fd6b 	bl	300141f0 <spin>
        val = REG_READ16(host, reg);
3000f71a:	6863      	ldr	r3, [r4, #4]
3000f71c:	f503 7240 	add.w	r2, r3, #768	; 0x300
3000f720:	f8b3 3300 	ldrh.w	r3, [r3, #768]	; 0x300
        if (val == mask)
3000f724:	079b      	lsls	r3, r3, #30
3000f726:	d40d      	bmi.n	3000f744 <mshc_init+0xbc>
        if (current_time() > timeout)
3000f728:	f7f1 f900 	bl	3000092c <current_time>
3000f72c:	4285      	cmp	r5, r0
        spin(1);
3000f72e:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000f732:	d2f0      	bcs.n	3000f716 <mshc_init+0x8e>
        dprintf(CRITICAL, "mshc: phy init failed!\n");
3000f734:	f64e 60ec 	movw	r0, #61164	; 0xeeec
3000f738:	f2c3 0001 	movt	r0, #12289	; 0x3001
}
3000f73c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
        dprintf(CRITICAL, "mshc: phy init failed!\n");
3000f740:	f006 ba36 	b.w	30015bb0 <_printf>
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
3000f744:	2301      	movs	r3, #1
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
3000f746:	f44f 0109 	mov.w	r1, #8978432	; 0x890000
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
3000f74a:	f2c0 0389 	movt	r3, #137	; 0x89
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
3000f74e:	6011      	str	r1, [r2, #0]
        REG_WRITE32(host, reg, DWC_MSHC_PHY_CNFG);
3000f750:	6013      	str	r3, [r2, #0]
}
3000f752:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

3000f754 <mshc_set_clk>:
{
3000f754:	b538      	push	{r3, r4, r5, r14}
    if (mshc_clkgen_config(host, MIN(clock, host->max_clk_rate) * 2))
3000f756:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f758:	2500      	movs	r5, #0
3000f75a:	6842      	ldr	r2, [r0, #4]
{
3000f75c:	4604      	mov	r4, r0
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f75e:	8595      	strh	r5, [r2, #44]	; 0x2c
    if (mshc_clkgen_config(host, MIN(clock, host->max_clk_rate) * 2))
3000f760:	4299      	cmp	r1, r3
3000f762:	bf28      	it	cs
3000f764:	4619      	movcs	r1, r3
3000f766:	0049      	lsls	r1, r1, #1
3000f768:	f7ff fe6c 	bl	3000f444 <mshc_clkgen_config.isra.4>
3000f76c:	b108      	cbz	r0, 3000f772 <mshc_set_clk+0x1e>
        dprintf(CRITICAL, "Error: sdhci clock wait stable timeout!");
3000f76e:	2001      	movs	r0, #1
}
3000f770:	bd38      	pop	{r3, r4, r5, r15}
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f772:	6863      	ldr	r3, [r4, #4]
3000f774:	2201      	movs	r2, #1
3000f776:	859a      	strh	r2, [r3, #44]	; 0x2c
    timeout = current_time() + ms;
3000f778:	f7f1 f8d8 	bl	3000092c <current_time>
        val = REG_READ16(host, reg);
3000f77c:	6863      	ldr	r3, [r4, #4]
3000f77e:	f103 022c 	add.w	r2, r3, #44	; 0x2c
3000f782:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        if (val == mask)
3000f784:	079b      	lsls	r3, r3, #30
    timeout = current_time() + ms;
3000f786:	f100 0596 	add.w	r5, r0, #150	; 0x96
        if (val == mask)
3000f78a:	d415      	bmi.n	3000f7b8 <mshc_set_clk+0x64>
3000f78c:	e007      	b.n	3000f79e <mshc_set_clk+0x4a>
        spin(1);
3000f78e:	f004 fd2f 	bl	300141f0 <spin>
        val = REG_READ16(host, reg);
3000f792:	6863      	ldr	r3, [r4, #4]
3000f794:	f103 022c 	add.w	r2, r3, #44	; 0x2c
3000f798:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        if (val == mask)
3000f79a:	0798      	lsls	r0, r3, #30
3000f79c:	d40c      	bmi.n	3000f7b8 <mshc_set_clk+0x64>
        if (current_time() > timeout)
3000f79e:	f7f1 f8c5 	bl	3000092c <current_time>
3000f7a2:	4285      	cmp	r5, r0
        spin(1);
3000f7a4:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000f7a8:	d2f1      	bcs.n	3000f78e <mshc_set_clk+0x3a>
        dprintf(CRITICAL, "Error: sdhci clock wait stable timeout!");
3000f7aa:	f64e 7004 	movw	r0, #61188	; 0xef04
3000f7ae:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f7b2:	f006 f9fd 	bl	30015bb0 <_printf>
3000f7b6:	e7da      	b.n	3000f76e <mshc_set_clk+0x1a>
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f7b8:	2309      	movs	r3, #9
3000f7ba:	8013      	strh	r3, [r2, #0]
    timeout = current_time() + ms;
3000f7bc:	f7f1 f8b6 	bl	3000092c <current_time>
        val = REG_READ16(host, reg);
3000f7c0:	6863      	ldr	r3, [r4, #4]
3000f7c2:	f103 022c 	add.w	r2, r3, #44	; 0x2c
3000f7c6:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        if (val == mask)
3000f7c8:	079b      	lsls	r3, r3, #30
    timeout = current_time() + ms;
3000f7ca:	f100 0596 	add.w	r5, r0, #150	; 0x96
        if (val == mask)
3000f7ce:	d508      	bpl.n	3000f7e2 <mshc_set_clk+0x8e>
3000f7d0:	e00e      	b.n	3000f7f0 <mshc_set_clk+0x9c>
        spin(1);
3000f7d2:	f004 fd0d 	bl	300141f0 <spin>
        val = REG_READ16(host, reg);
3000f7d6:	6863      	ldr	r3, [r4, #4]
3000f7d8:	f103 022c 	add.w	r2, r3, #44	; 0x2c
3000f7dc:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
        if (val == mask)
3000f7de:	0799      	lsls	r1, r3, #30
3000f7e0:	d406      	bmi.n	3000f7f0 <mshc_set_clk+0x9c>
        if (current_time() > timeout)
3000f7e2:	f7f1 f8a3 	bl	3000092c <current_time>
3000f7e6:	4285      	cmp	r5, r0
        spin(1);
3000f7e8:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout)
3000f7ec:	d2f1      	bcs.n	3000f7d2 <mshc_set_clk+0x7e>
3000f7ee:	e7dc      	b.n	3000f7aa <mshc_set_clk+0x56>
    clk_ctrl = REG_READ16(host, SDHCI_CLK_CTRL_REG);
3000f7f0:	8813      	ldrh	r3, [r2, #0]
    return 0;
3000f7f2:	2000      	movs	r0, #0
    clk_ctrl |= SDHCI_CLK_EN;
3000f7f4:	f043 0304 	orr.w	r3, r3, #4
    REG_WRITE16(host, clk_ctrl, SDHCI_CLK_CTRL_REG);
3000f7f8:	8013      	strh	r3, [r2, #0]
}
3000f7fa:	bd38      	pop	{r3, r4, r5, r15}

3000f7fc <mmc_platform_init>:

    return ret;
}

int mmc_platform_init(struct mmc_device *dev)
{
3000f7fc:	b570      	push	{r4, r5, r6, r14}
    struct sdhci_host *host;

    host = &dev->host;
    host->ops = &sdhci_dwcmshc_ops;

    if (!model_reset(g_mmc_priv_res[dev->config.slot].rst_idx)) {
3000f7fe:	f890 21b0 	ldrb.w	r2, [r0, #432]	; 0x1b0
3000f802:	f245 1368 	movw	r3, #20840	; 0x5168
3000f806:	eb02 0282 	add.w	r2, r2, r2, lsl #2
{
3000f80a:	4604      	mov	r4, r0
    if (!model_reset(g_mmc_priv_res[dev->config.slot].rst_idx)) {
3000f80c:	f2c3 0302 	movt	r3, #12290	; 0x3002
    host->ops = &sdhci_dwcmshc_ops;
3000f810:	f245 2008 	movw	r0, #21000	; 0x5208
    if (!model_reset(g_mmc_priv_res[dev->config.slot].rst_idx)) {
3000f814:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
3000f818:	f64b 6580 	movw	r5, #48768	; 0xbe80
    host->ops = &sdhci_dwcmshc_ops;
3000f81c:	f2c3 0002 	movt	r0, #12290	; 0x3002
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
3000f820:	f44f 6180 	mov.w	r1, #1024	; 0x400
3000f824:	f2c3 0502 	movt	r5, #12290	; 0x3002
    host->ops = &sdhci_dwcmshc_ops;
3000f828:	f8c4 00e4 	str.w	r0, [r4, #228]	; 0xe4
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
3000f82c:	f2c8 1196 	movt	r1, #33174	; 0x8196
    if (!model_reset(g_mmc_priv_res[dev->config.slot].rst_idx)) {
3000f830:	691e      	ldr	r6, [r3, #16]
    ret = hal_rstgen_creat_handle(&g_handle, RES_GLOBAL_RST_SEC_RST_EN);
3000f832:	4628      	mov	r0, r5
3000f834:	f000 fa22 	bl	3000fc7c <hal_rstgen_creat_handle>
    if (!ret) {
3000f838:	b960      	cbnz	r0, 3000f854 <mmc_platform_init+0x58>
        dprintf(CRITICAL, "reset mshc failed!\n");
        return -1;
    }

    /* Init the ref clock: 400Khz */
    if (mshc_clkgen_config(host, 400000 * 2))
3000f83a:	f44f 5154 	mov.w	r1, #13568	; 0x3500
3000f83e:	4620      	mov	r0, r4
3000f840:	f2c0 010c 	movt	r1, #12
3000f844:	f7ff fdfe 	bl	3000f444 <mshc_clkgen_config.isra.4>
3000f848:	bb50      	cbnz	r0, 3000f8a0 <mmc_platform_init+0xa4>
        return -1;

    if (mmc_sdhci_init(dev)) {
3000f84a:	4620      	mov	r0, r4
3000f84c:	f7f9 fb94 	bl	30008f78 <mmc_sdhci_init>
3000f850:	b9e8      	cbnz	r0, 3000f88e <mmc_platform_init+0x92>
        dprintf(CRITICAL, "mmc init failed!\n");
        return -1;
    }

    return 0;
}
3000f852:	bd70      	pop	{r4, r5, r6, r15}
    ret = hal_rstgen_init(g_handle);
3000f854:	6828      	ldr	r0, [r5, #0]
3000f856:	f000 fa93 	bl	3000fd80 <hal_rstgen_init>
    if (ret) {
3000f85a:	b958      	cbnz	r0, 3000f874 <mmc_platform_init+0x78>
    ret &= hal_rstgen_release_handle(g_handle);
3000f85c:	6828      	ldr	r0, [r5, #0]
3000f85e:	f000 fa83 	bl	3000fd68 <hal_rstgen_release_handle>
        dprintf(CRITICAL, "reset mshc failed!\n");
3000f862:	f64e 6038 	movw	r0, #60984	; 0xee38
3000f866:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f86a:	f006 f9a1 	bl	30015bb0 <_printf>
        return -1;
3000f86e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000f872:	bd70      	pop	{r4, r5, r6, r15}
        ret = hal_rstgen_module_reset(g_handle, res_id);
3000f874:	6828      	ldr	r0, [r5, #0]
3000f876:	4631      	mov	r1, r6
3000f878:	f000 fa9c 	bl	3000fdb4 <hal_rstgen_module_reset>
3000f87c:	4606      	mov	r6, r0
    ret &= hal_rstgen_release_handle(g_handle);
3000f87e:	6828      	ldr	r0, [r5, #0]
3000f880:	f000 fa72 	bl	3000fd68 <hal_rstgen_release_handle>
    if (!model_reset(g_mmc_priv_res[dev->config.slot].rst_idx)) {
3000f884:	4030      	ands	r0, r6
3000f886:	f010 0fff 	tst.w	r0, #255	; 0xff
3000f88a:	d1d6      	bne.n	3000f83a <mmc_platform_init+0x3e>
3000f88c:	e7e9      	b.n	3000f862 <mmc_platform_init+0x66>
        dprintf(CRITICAL, "mmc init failed!\n");
3000f88e:	f64e 604c 	movw	r0, #61004	; 0xee4c
3000f892:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f896:	f006 f98b 	bl	30015bb0 <_printf>
        return -1;
3000f89a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000f89e:	bd70      	pop	{r4, r5, r6, r15}
        return -1;
3000f8a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000f8a4:	bd70      	pop	{r4, r5, r6, r15}
3000f8a6:	bf00      	nop

3000f8a8 <hal_port_creat_handle>:
spin_lock_t port_spin_lock = SPIN_LOCK_INITIAL_VALUE;

static struct port_handle s_port_handle;

bool hal_port_creat_handle(void **handle, uint32_t port_res_glb_idx)
{
3000f8a8:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct port_handle *p_handle;
    int8_t ret = 0;
    paddr_t phy_addr = 0;
3000f8aa:	2400      	movs	r4, #0
{
3000f8ac:	b085      	sub	sp, #20
3000f8ae:	4606      	mov	r6, r0
    paddr_t dio_phy_addr = 0;
    int32_t dio_real_idx = 0;
    spin_lock_saved_state_t states;
    LTRACEF("+hal_port_creat_handle \n");

    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
3000f8b0:	aa01      	add	r2, sp, #4
    int32_t real_idx = 0;
3000f8b2:	e9cd 4400 	strd	r4, r4, [r13]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
3000f8b6:	4608      	mov	r0, r1
    int32_t dio_real_idx = 0;
3000f8b8:	e9cd 4402 	strd	r4, r4, [r13, #8]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
3000f8bc:	4669      	mov	r1, r13
3000f8be:	f000 f995 	bl	3000fbec <res_get_info_by_id>

    if (ret != -1) {
3000f8c2:	b240      	sxtb	r0, r0
3000f8c4:	3001      	adds	r0, #1
3000f8c6:	d046      	beq.n	3000f956 <hal_port_creat_handle+0xae>
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
        return false;
    }

    /* To get GPIO base address for Port */
    ret = res_get_info_by_id(g_gpio_res.res_id[0], &dio_phy_addr, &dio_real_idx);
3000f8c8:	f64f 3300 	movw	r3, #64256	; 0xfb00
3000f8cc:	aa03      	add	r2, sp, #12
3000f8ce:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f8d2:	a902      	add	r1, sp, #8
3000f8d4:	6858      	ldr	r0, [r3, #4]
3000f8d6:	f000 f989 	bl	3000fbec <res_get_info_by_id>

    if (ret != -1) {
3000f8da:	b240      	sxtb	r0, r0
3000f8dc:	3001      	adds	r0, #1
3000f8de:	d043      	beq.n	3000f968 <hal_port_creat_handle+0xc0>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000f8e0:	f3ef 8300 	mrs	r3, CPSR
3000f8e4:	f013 0580 	ands.w	r5, r3, #128	; 0x80
3000f8e8:	d11b      	bne.n	3000f922 <hal_port_creat_handle+0x7a>
    __asm__ volatile("cpsid i");
3000f8ea:	b672      	cpsid	i

#endif

    p_handle = &s_port_handle;
    spin_lock_irqsave(&port_spin_lock, states);
    p_handle->phy_addr = phy_addr;
3000f8ec:	f64b 6388 	movw	r3, #48776	; 0xbe88
    *lock = 1;
3000f8f0:	f64b 6784 	movw	r7, #48772	; 0xbe84
3000f8f4:	9a00      	ldr	r2, [sp, #0]
3000f8f6:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000f8fa:	2401      	movs	r4, #1
3000f8fc:	f2c3 0702 	movt	r7, #12290	; 0x3002
3000f900:	601a      	str	r2, [r3, #0]
    p_handle->real_idx = real_idx;
    p_handle->dio_phy_addr = dio_phy_addr;
    p_handle->dio_real_idx = dio_real_idx;
    *handle = p_handle;
    Port_SetHandle((void *)p_handle);
3000f902:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
3000f904:	9a01      	ldr	r2, [sp, #4]
3000f906:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
3000f908:	9a02      	ldr	r2, [sp, #8]
3000f90a:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
3000f90c:	9a03      	ldr	r2, [sp, #12]
3000f90e:	60da      	str	r2, [r3, #12]
3000f910:	603c      	str	r4, [r7, #0]
    *handle = p_handle;
3000f912:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
3000f914:	f7fa fdfc 	bl	3000a510 <Port_SetHandle>
    *lock = 0;
3000f918:	603d      	str	r5, [r7, #0]
    __asm__ volatile("cpsie i");
3000f91a:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);


    LTRACEF("-hal_port_creat_handle finished\n");

    return true;
3000f91c:	4620      	mov	r0, r4
}
3000f91e:	b005      	add	sp, #20
3000f920:	bdf0      	pop	{r4, r5, r6, r7, r15}
    p_handle->phy_addr = phy_addr;
3000f922:	f64b 6388 	movw	r3, #48776	; 0xbe88
    *lock = 1;
3000f926:	f64b 6784 	movw	r7, #48772	; 0xbe84
3000f92a:	9a00      	ldr	r2, [sp, #0]
3000f92c:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000f930:	2501      	movs	r5, #1
3000f932:	f2c3 0702 	movt	r7, #12290	; 0x3002
3000f936:	601a      	str	r2, [r3, #0]
    Port_SetHandle((void *)p_handle);
3000f938:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
3000f93a:	9a01      	ldr	r2, [sp, #4]
3000f93c:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
3000f93e:	9a02      	ldr	r2, [sp, #8]
3000f940:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
3000f942:	9a03      	ldr	r2, [sp, #12]
3000f944:	603d      	str	r5, [r7, #0]
3000f946:	60da      	str	r2, [r3, #12]
    *handle = p_handle;
3000f948:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
3000f94a:	f7fa fde1 	bl	3000a510 <Port_SetHandle>
    *lock = 0;
3000f94e:	603c      	str	r4, [r7, #0]
    return true;
3000f950:	4628      	mov	r0, r5
}
3000f952:	b005      	add	sp, #20
3000f954:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
3000f956:	f24f 7034 	movw	r0, #63284	; 0xf734
3000f95a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f95e:	f006 f927 	bl	30015bb0 <_printf>
        return false;
3000f962:	4620      	mov	r0, r4
}
3000f964:	b005      	add	sp, #20
3000f966:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for dio failed! 03\n");
3000f968:	f24f 7074 	movw	r0, #63348	; 0xf774
3000f96c:	f2c3 0001 	movt	r0, #12289	; 0x3001
3000f970:	f006 f91e 	bl	30015bb0 <_printf>
        return false;
3000f974:	4620      	mov	r0, r4
}
3000f976:	b005      	add	sp, #20
3000f978:	bdf0      	pop	{r4, r5, r6, r7, r15}
3000f97a:	bf00      	nop

3000f97c <hal_port_release_handle>:

bool hal_port_release_handle(void **handle)
{
3000f97c:	b510      	push	{r4, r14}
3000f97e:	b082      	sub	sp, #8
    ASSERT(handle);
3000f980:	b310      	cbz	r0, 3000f9c8 <hal_port_release_handle+0x4c>
    struct port_handle *port = *handle;
3000f982:	6802      	ldr	r2, [r0, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000f984:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000f988:	f013 0380 	ands.w	r3, r3, #128	; 0x80
3000f98c:	d10e      	bne.n	3000f9ac <hal_port_release_handle+0x30>
    __asm__ volatile("cpsid i");
3000f98e:	b672      	cpsid	i
    *lock = 0;
3000f990:	f64b 6184 	movw	r1, #48772	; 0xbe84
    spin_lock_saved_state_t states;

    spin_lock_irqsave(&port_spin_lock, states);
    port->phy_addr = 0;
    port->real_idx = -1;
3000f994:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
3000f998:	f2c3 0102 	movt	r1, #12290	; 0x3002
3000f99c:	e9c2 3400 	strd	r3, r4, [r2]
    *handle = NULL;
3000f9a0:	6003      	str	r3, [r0, #0]
3000f9a2:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
3000f9a4:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);

    return true;
}
3000f9a6:	2001      	movs	r0, #1
3000f9a8:	b002      	add	sp, #8
3000f9aa:	bd10      	pop	{r4, r15}
3000f9ac:	f64b 6384 	movw	r3, #48772	; 0xbe84
    port->phy_addr = 0;
3000f9b0:	2100      	movs	r1, #0
    port->real_idx = -1;
3000f9b2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
3000f9b6:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000f9ba:	e9c2 1400 	strd	r1, r4, [r2]
    *handle = NULL;
3000f9be:	6001      	str	r1, [r0, #0]
}
3000f9c0:	2001      	movs	r0, #1
3000f9c2:	6019      	str	r1, [r3, #0]
3000f9c4:	b002      	add	sp, #8
3000f9c6:	bd10      	pop	{r4, r15}
    ASSERT(handle);
3000f9c8:	f24a 0354 	movw	r3, #41044	; 0xa054
3000f9cc:	f24f 72b4 	movw	r2, #63412	; 0xf7b4
3000f9d0:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000f9d4:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f9d8:	4670      	mov	r0, r14
3000f9da:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000f9de:	9300      	str	r3, [sp, #0]
3000f9e0:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000f9e4:	2374      	movs	r3, #116	; 0x74
3000f9e6:	f004 fc15 	bl	30014214 <_panic>
3000f9ea:	bf00      	nop

3000f9ec <hal_port_init>:

    return true;
}

int hal_port_init(void *handle)
{
3000f9ec:	b500      	push	{r14}
3000f9ee:	b085      	sub	sp, #20
    ASSERT(handle);
3000f9f0:	b160      	cbz	r0, 3000fa0c <hal_port_init+0x20>

    Port_ConfigType port_config;

#if NOT_USE_SYS_CFG
    port_config = (Port_ConfigType){&Port_kConfiguration[0]};
3000f9f2:	f64e 738c 	movw	r3, #61324	; 0xef8c
3000f9f6:	a804      	add	r0, sp, #16
3000f9f8:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000f9fc:	f840 3d04 	str.w	r3, [r0, #-4]!
        port_config = (Port_ConfigType){(Port_n_ConfigType*)(void*)addr_config};
    }
#endif

    LTRACEF("hal_port_init \n");
    Port_Init(&port_config);
3000fa00:	f7fa fbb6 	bl	3000a170 <Port_Init>

    return true;
}
3000fa04:	2001      	movs	r0, #1
3000fa06:	b005      	add	sp, #20
3000fa08:	f85d fb04 	ldr.w	r15, [r13], #4
    ASSERT(handle);
3000fa0c:	f24a 0354 	movw	r3, #41044	; 0xa054
3000fa10:	f24f 72b4 	movw	r2, #63412	; 0xf7b4
3000fa14:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000fa18:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fa1c:	4670      	mov	r0, r14
3000fa1e:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000fa22:	9300      	str	r3, [sp, #0]
3000fa24:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000fa28:	2395      	movs	r3, #149	; 0x95
3000fa2a:	f004 fbf3 	bl	30014214 <_panic>
3000fa2e:	bf00      	nop

3000fa30 <hal_port_set_pin_mode>:
    return true;
}

int hal_port_set_pin_mode(void *handle, const Port_PinType pin,
                          const Port_PinModeType mode)
{
3000fa30:	b510      	push	{r4, r14}
3000fa32:	b084      	sub	sp, #16
3000fa34:	ac02      	add	r4, sp, #8
3000fa36:	e884 000c 	stmia.w	r4, {r2, r3}
    ASSERT(handle);
3000fa3a:	b138      	cbz	r0, 3000fa4c <hal_port_set_pin_mode+0x1c>
    Port_SetPinMode(pin, mode);
3000fa3c:	4608      	mov	r0, r1
3000fa3e:	e894 0006 	ldmia.w	r4, {r1, r2}
3000fa42:	f7fa fcf7 	bl	3000a434 <Port_SetPinMode>

    return true;
}
3000fa46:	2001      	movs	r0, #1
3000fa48:	b004      	add	sp, #16
3000fa4a:	bd10      	pop	{r4, r15}
    ASSERT(handle);
3000fa4c:	f24a 0354 	movw	r3, #41044	; 0xa054
3000fa50:	f24f 72b4 	movw	r2, #63412	; 0xf7b4
3000fa54:	f24a 011c 	movw	r1, #40988	; 0xa01c
3000fa58:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fa5c:	4670      	mov	r0, r14
3000fa5e:	f2c3 0201 	movt	r2, #12289	; 0x3001
3000fa62:	9300      	str	r3, [sp, #0]
3000fa64:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000fa68:	23f6      	movs	r3, #246	; 0xf6
3000fa6a:	f004 fbd3 	bl	30014214 <_panic>
3000fa6e:	bf00      	nop

3000fa70 <parse_paddr_ppc>:
    return -1;
}

/* Parse address for peripheral type resources */
int32_t parse_paddr_ppc(uint32_t ppc_index, uint32_t slot_index, addr_t * paddr)
{
3000fa70:	b5f0      	push	{r4, r5, r6, r7, r14}
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
3000fa72:	f24f 74ec 	movw	r4, #63468	; 0xf7ec
{
3000fa76:	4607      	mov	r7, r0
3000fa78:	468c      	mov	r12, r1
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
3000fa7a:	f2c3 0401 	movt	r4, #12289	; 0x3001
{
3000fa7e:	4696      	mov	r14, r2
                                APBMUX5_IP_BASE, APBMUX6_IP_BASE, APBMUX7_IP_BASE, APBMUX8_IP_BASE,
                                APB_DDR_CFG_BASE, APB_SMMU_BASE, APB_CE2_REG_BASE, APB_SCR4K_SID_BASE,
                                APB_SCR4K_SSID_BASE, APB_CSSYS_BASE};
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
3000fa80:	f104 0538 	add.w	r5, r4, #56	; 0x38
{
3000fa84:	b09d      	sub	sp, #116	; 0x74
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
3000fa86:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3000fa88:	466e      	mov	r6, r13
3000fa8a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3000fa8c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3000fa8e:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3000fa90:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
3000fa92:	c60f      	stmia	r6!, {r0, r1, r2, r3}
3000fa94:	e894 0003 	ldmia.w	r4, {r0, r1}
                                APBMUX5_IP_SIZE, APBMUX6_IP_SIZE, APBMUX7_IP_SIZE, APBMUX8_IP_SIZE,
                                APB_DDR_CFG_SIZE, APB_SMMU_SIZE, APB_CE2_REG_SIZE, APB_SCR4K_SID_SIZE,
                                APB_SCR4K_SSID_SIZE, APB_CSSYS_SIZE};

    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
3000fa98:	ab1c      	add	r3, sp, #112	; 0x70
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
3000fa9a:	e886 0003 	stmia.w	r6, {r0, r1}
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
3000fa9e:	eb03 0687 	add.w	r6, r3, r7, lsl #2
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
3000faa2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3000faa4:	ac0e      	add	r4, sp, #56	; 0x38
3000faa6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3000faa8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3000faaa:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3000faac:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
3000faae:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3000fab0:	e895 0003 	ldmia.w	r5, {r0, r1}
3000fab4:	e884 0003 	stmia.w	r4, {r0, r1}

    return 0;
}
3000fab8:	2000      	movs	r0, #0
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
3000faba:	f856 2c38 	ldr.w	r2, [r6, #-56]
3000fabe:	f856 3c70 	ldr.w	r3, [r6, #-112]
3000fac2:	fb02 330c 	mla	r3, r2, r12, r3
3000fac6:	f8ce 3000 	str.w	r3, [r14]
}
3000faca:	b01d      	add	sp, #116	; 0x74
3000facc:	bdf0      	pop	{r4, r5, r6, r7, r15}
3000face:	bf00      	nop

3000fad0 <parse_paddr_rpc>:

/* Parse address and index for register level resources */
int32_t parse_paddr_rpc(uint32_t rpc_index, uint32_t slot_index, addr_t * paddr, int32_t * index)
{
3000fad0:	b410      	push	{r4}
    if (slot_index >= 2046) {
3000fad2:	f240 74fd 	movw	r4, #2045	; 0x7fd
3000fad6:	42a1      	cmp	r1, r4
3000fad8:	d824      	bhi.n	3000fb24 <parse_paddr_rpc+0x54>
        return -1;
    }

    uint32_t addr_offset = 0;

    if (slot_index >= IOMUXC_INDEX) {
3000fada:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
3000fade:	d213      	bcs.n	3000fb08 <parse_paddr_rpc+0x38>
        *index = slot_index - IOMUXC_INDEX;
        addr_offset = 5;
    }
    else if (slot_index >= RSTGEN_INDEX) {
3000fae0:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
3000fae4:	d32b      	bcc.n	3000fb3e <parse_paddr_rpc+0x6e>
        *index = slot_index - RSTGEN_INDEX;
        addr_offset = 4;
3000fae6:	2404      	movs	r4, #4
        *index = slot_index - RSTGEN_INDEX;
3000fae8:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
3000faec:	6019      	str	r1, [r3, #0]
    }
    else {
        *index = slot_index;
    }

    switch (rpc_index) {
3000faee:	2801      	cmp	r0, #1
3000faf0:	d010      	beq.n	3000fb14 <parse_paddr_rpc+0x44>
3000faf2:	d31c      	bcc.n	3000fb2e <parse_paddr_rpc+0x5e>
3000faf4:	2802      	cmp	r0, #2
3000faf6:	d115      	bne.n	3000fb24 <parse_paddr_rpc+0x54>
        default:
            return -1;
        break;
    }

    return 0;
3000faf8:	2000      	movs	r0, #0
            *paddr = APB_RPC_SAF_BASE + addr_offset * RPC_ADDR_OFFSET;
3000fafa:	f504 647c 	add.w	r4, r4, #4032	; 0xfc0
3000fafe:	0524      	lsls	r4, r4, #20
3000fb00:	6014      	str	r4, [r2, #0]
}
3000fb02:	f85d 4b04 	ldr.w	r4, [r13], #4
3000fb06:	4770      	bx	r14
        *index = slot_index - IOMUXC_INDEX;
3000fb08:	f5a1 61a0 	sub.w	r1, r1, #1280	; 0x500
        addr_offset = 5;
3000fb0c:	2405      	movs	r4, #5
    switch (rpc_index) {
3000fb0e:	2801      	cmp	r0, #1
        *index = slot_index - IOMUXC_INDEX;
3000fb10:	6019      	str	r1, [r3, #0]
    switch (rpc_index) {
3000fb12:	d1ee      	bne.n	3000faf2 <parse_paddr_rpc+0x22>
    return 0;
3000fb14:	2000      	movs	r0, #0
            *paddr = APB_RPC_SEC_BASE + addr_offset * RPC_ADDR_OFFSET;
3000fb16:	f504 6478 	add.w	r4, r4, #3968	; 0xf80
3000fb1a:	0524      	lsls	r4, r4, #20
3000fb1c:	6014      	str	r4, [r2, #0]
}
3000fb1e:	f85d 4b04 	ldr.w	r4, [r13], #4
3000fb22:	4770      	bx	r14
3000fb24:	f85d 4b04 	ldr.w	r4, [r13], #4
            return -1;
3000fb28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
3000fb2c:	4770      	bx	r14
    return 0;
3000fb2e:	2000      	movs	r0, #0
            *paddr = APB_RPC_SOC_BASE + addr_offset * RPC_ADDR_OFFSET;
3000fb30:	f504 6476 	add.w	r4, r4, #3936	; 0xf60
3000fb34:	0524      	lsls	r4, r4, #20
3000fb36:	6014      	str	r4, [r2, #0]
}
3000fb38:	f85d 4b04 	ldr.w	r4, [r13], #4
3000fb3c:	4770      	bx	r14
    else if (slot_index >= SCR_INDEX) {
3000fb3e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
        addr_offset = 2;
3000fb42:	bf26      	itte	cs
3000fb44:	2402      	movcs	r4, #2
        *index = slot_index - SCR_INDEX;
3000fb46:	f5a1 7100 	subcs.w	r1, r1, #512	; 0x200
    uint32_t addr_offset = 0;
3000fb4a:	2400      	movcc	r4, #0
        *index = slot_index;
3000fb4c:	6019      	str	r1, [r3, #0]
3000fb4e:	e7ce      	b.n	3000faee <parse_paddr_rpc+0x1e>

3000fb50 <res_parse_info>:

/* Parse resource ID to acquire base address and index of resource */
int32_t res_parse_info(uint32_t res_id, addr_t * paddr, int32_t * index)
{
3000fb50:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t rapc_type;
    uint32_t rapc_index;
    uint32_t slot_index;
    int32_t res = 0;

    *index = -1;
3000fb52:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

    rapc_type = res_id >> 30;
3000fb56:	0f85      	lsrs	r5, r0, #30
{
3000fb58:	4613      	mov	r3, r2
    rapc_index = (res_id >> 24) & 0x3F;
    slot_index = res_id & 0xFFF;

    switch (rapc_type) {
3000fb5a:	2d01      	cmp	r5, #1
    *index = -1;
3000fb5c:	6014      	str	r4, [r2, #0]
    rapc_index = (res_id >> 24) & 0x3F;
3000fb5e:	f3c0 6605 	ubfx	r6, r0, #24, #6
    slot_index = res_id & 0xFFF;
3000fb62:	f3c0 070b 	ubfx	r7, r0, #0, #12
    switch (rapc_type) {
3000fb66:	d02e      	beq.n	3000fbc6 <res_parse_info+0x76>
3000fb68:	d30c      	bcc.n	3000fb84 <res_parse_info+0x34>
3000fb6a:	2d02      	cmp	r5, #2
3000fb6c:	d002      	beq.n	3000fb74 <res_parse_info+0x24>
        case 0: //MPC
            if (rapc_index >= MPC_MAX_NUM) {
                return -1;
3000fb6e:	4620      	mov	r0, r4
        default:
            return -1;
    }

    return res;
}
3000fb70:	bcf0      	pop	{r4, r5, r6, r7}
3000fb72:	4770      	bx	r14
            if (rapc_index >= PPC_MAX_NUM) {
3000fb74:	2e0d      	cmp	r6, #13
3000fb76:	d8fa      	bhi.n	3000fb6e <res_parse_info+0x1e>
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
3000fb78:	460a      	mov	r2, r1
3000fb7a:	4630      	mov	r0, r6
3000fb7c:	4639      	mov	r1, r7
}
3000fb7e:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
3000fb80:	f7ff bfa6 	b.w	3000fad0 <parse_paddr_rpc>
            if (rapc_index >= MPC_MAX_NUM) {
3000fb84:	2e1a      	cmp	r6, #26
3000fb86:	d8f2      	bhi.n	3000fb6e <res_parse_info+0x1e>
    uint32_t cat_id = (res_id >> 17) & 0x7F;
3000fb88:	f3c0 4246 	ubfx	r2, r0, #17, #7
    if (cat_id >= MPC_CATEGORY_MAX) {
3000fb8c:	2a0d      	cmp	r2, #13
3000fb8e:	d8ee      	bhi.n	3000fb6e <res_parse_info+0x1e>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
3000fb90:	f245 2320 	movw	r3, #21024	; 0x5220
3000fb94:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000fb98:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
3000fb9c:	6816      	ldr	r6, [r2, #0]
3000fb9e:	2e00      	cmp	r6, #0
3000fba0:	dde5      	ble.n	3000fb6e <res_parse_info+0x1e>
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
3000fba2:	6853      	ldr	r3, [r2, #4]
3000fba4:	4298      	cmp	r0, r3
3000fba6:	bf1c      	itt	ne
3000fba8:	4614      	movne	r4, r2
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
3000fbaa:	2300      	movne	r3, #0
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
3000fbac:	d103      	bne.n	3000fbb6 <res_parse_info+0x66>
3000fbae:	e015      	b.n	3000fbdc <res_parse_info+0x8c>
3000fbb0:	6865      	ldr	r5, [r4, #4]
3000fbb2:	42a8      	cmp	r0, r5
3000fbb4:	d013      	beq.n	3000fbde <res_parse_info+0x8e>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
3000fbb6:	3301      	adds	r3, #1
3000fbb8:	42b3      	cmp	r3, r6
3000fbba:	f104 0408 	add.w	r4, r4, #8
3000fbbe:	d1f7      	bne.n	3000fbb0 <res_parse_info+0x60>
                return -1;
3000fbc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000fbc4:	e7d4      	b.n	3000fb70 <res_parse_info+0x20>
            if (rapc_index >= PPC_MAX_NUM) {
3000fbc6:	2e0d      	cmp	r6, #13
3000fbc8:	d8d1      	bhi.n	3000fb6e <res_parse_info+0x1e>
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
3000fbca:	460a      	mov	r2, r1
            *index = (res_id >> 12) & 0x1F;
3000fbcc:	f3c0 3004 	ubfx	r0, r0, #12, #5
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
3000fbd0:	4639      	mov	r1, r7
            *index = (res_id >> 12) & 0x1F;
3000fbd2:	6018      	str	r0, [r3, #0]
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
3000fbd4:	4630      	mov	r0, r6
}
3000fbd6:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
3000fbd8:	f7ff bf4a 	b.w	3000fa70 <parse_paddr_ppc>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
3000fbdc:	2300      	movs	r3, #0
            return 0;
3000fbde:	2000      	movs	r0, #0
            *paddr = mem_info_init[cat_id]->mem_info[i].paddr;
3000fbe0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
3000fbe4:	689b      	ldr	r3, [r3, #8]
3000fbe6:	600b      	str	r3, [r1, #0]
3000fbe8:	e7c2      	b.n	3000fb70 <res_parse_info+0x20>
3000fbea:	bf00      	nop

3000fbec <res_get_info_by_id>:

/* Get resource info by ID. */
const int32_t res_get_info_by_id(uint32_t res_id, addr_t * paddr, int32_t * index)
{
3000fbec:	b470      	push	{r4, r5, r6}
    uint32_t cat_id = (res_id >> 17) & 0x7F;
3000fbee:	f3c0 4446 	ubfx	r4, r0, #17, #7

    if (cat_id >= (sizeof(g_res_cat) / sizeof(g_res_cat[0]))) {
3000fbf2:	2c4d      	cmp	r4, #77	; 0x4d
3000fbf4:	d817      	bhi.n	3000fc26 <res_get_info_by_id+0x3a>
        return -1;
    }

    if (NULL != g_res_cat[cat_id]) { //check avaibility of resource
3000fbf6:	f64f 7310 	movw	r3, #65296	; 0xff10
3000fbfa:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fbfe:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
3000fc02:	b184      	cbz	r4, 3000fc26 <res_get_info_by_id+0x3a>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
3000fc04:	6826      	ldr	r6, [r4, #0]
3000fc06:	2e00      	cmp	r6, #0
3000fc08:	dd0d      	ble.n	3000fc26 <res_get_info_by_id+0x3a>
            if (g_res_cat[cat_id]->res_id[i] == res_id)
3000fc0a:	6863      	ldr	r3, [r4, #4]
3000fc0c:	4298      	cmp	r0, r3
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
3000fc0e:	bf1c      	itt	ne
3000fc10:	2300      	movne	r3, #0
3000fc12:	3404      	addne	r4, #4
            if (g_res_cat[cat_id]->res_id[i] == res_id)
3000fc14:	d104      	bne.n	3000fc20 <res_get_info_by_id+0x34>
3000fc16:	e00a      	b.n	3000fc2e <res_get_info_by_id+0x42>
3000fc18:	f854 5f04 	ldr.w	r5, [r4, #4]!
3000fc1c:	4285      	cmp	r5, r0
3000fc1e:	d006      	beq.n	3000fc2e <res_get_info_by_id+0x42>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
3000fc20:	3301      	adds	r3, #1
3000fc22:	42b3      	cmp	r3, r6
3000fc24:	d1f8      	bne.n	3000fc18 <res_get_info_by_id+0x2c>
                return res_parse_info(res_id, paddr, index);
        }
    }

    return -1;
}
3000fc26:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3000fc2a:	bc70      	pop	{r4, r5, r6}
3000fc2c:	4770      	bx	r14
3000fc2e:	bc70      	pop	{r4, r5, r6}
                return res_parse_info(res_id, paddr, index);
3000fc30:	f7ff bf8e 	b.w	3000fb50 <res_parse_info>

3000fc34 <p2ap>:
    addrmap_def
};

/* Transform address from r core to a core */
paddr_t p2ap(paddr_t pa)
{
3000fc34:	f44f 0296 	mov.w	r2, #4915200	; 0x4b0000
    int i = 0;
    struct addr_map *addr;
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
3000fc38:	2300      	movs	r3, #0
{
3000fc3a:	b430      	push	{r4, r5}
3000fc3c:	f64f 045c 	movw	r4, #63580	; 0xf85c
        addr = &addrmap_tab[i];
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
3000fc40:	4290      	cmp	r0, r2
3000fc42:	f2c3 0401 	movt	r4, #12289	; 0x3001
3000fc46:	4621      	mov	r1, r4
3000fc48:	eba0 0502 	sub.w	r5, r0, r2
3000fc4c:	d302      	bcc.n	3000fc54 <p2ap+0x20>
3000fc4e:	684a      	ldr	r2, [r1, #4]
3000fc50:	4295      	cmp	r5, r2
3000fc52:	d30b      	bcc.n	3000fc6c <p2ap+0x38>
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
3000fc54:	3301      	adds	r3, #1
3000fc56:	2b03      	cmp	r3, #3
3000fc58:	d00e      	beq.n	3000fc78 <p2ap+0x44>
3000fc5a:	f851 2f0c 	ldr.w	r2, [r1, #12]!
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
3000fc5e:	4290      	cmp	r0, r2
3000fc60:	eba0 0502 	sub.w	r5, r0, r2
3000fc64:	d3f6      	bcc.n	3000fc54 <p2ap+0x20>
3000fc66:	684a      	ldr	r2, [r1, #4]
3000fc68:	4295      	cmp	r5, r2
3000fc6a:	d2f3      	bcs.n	3000fc54 <p2ap+0x20>
            return (pa - addr->src + addr->dst);
3000fc6c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
3000fc70:	eb04 0383 	add.w	r3, r4, r3, lsl #2
3000fc74:	6898      	ldr	r0, [r3, #8]
3000fc76:	4428      	add	r0, r5
        }
    }
    return pa;
}
3000fc78:	bc30      	pop	{r4, r5}
3000fc7a:	4770      	bx	r14

3000fc7c <hal_rstgen_creat_handle>:
//! \return rstgen handle
//
//*****************************************************************************
bool hal_rstgen_creat_handle(void **handle,
                             uint32_t global_rst_res_idx)
{
3000fc7c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    int32_t idx = -1;
3000fc80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
3000fc84:	b083      	sub	sp, #12
    int32_t idx = -1;
3000fc86:	9301      	str	r3, [sp, #4]
    rstgen_instance_t  *instance = NULL;

    if (handle == NULL) {
3000fc88:	b398      	cbz	r0, 3000fcf2 <hal_rstgen_creat_handle+0x76>
        LTRACEF("hal_get_resource paramenter error handle:%p\n", handle);
        return false;
    }

    if (rstgen_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
3000fc8a:	f64b 65dc 	movw	r5, #48860	; 0xbedc
3000fc8e:	f2c3 0502 	movt	r5, #12290	; 0x3002
3000fc92:	682b      	ldr	r3, [r5, #0]
3000fc94:	b10b      	cbz	r3, 3000fc9a <hal_rstgen_creat_handle+0x1e>
    *lock = SPIN_LOCK_INITIAL_VALUE;
3000fc96:	2300      	movs	r3, #0
3000fc98:	602b      	str	r3, [r5, #0]
3000fc9a:	4607      	mov	r7, r0
3000fc9c:	4689      	mov	r9, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000fc9e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000fca2:	f013 0680 	ands.w	r6, r3, #128	; 0x80
3000fca6:	d128      	bne.n	3000fcfa <hal_rstgen_creat_handle+0x7e>
    __asm__ volatile("cpsid i");
3000fca8:	b672      	cpsid	i
    if (g_RstgenInstance.occupied != 1) {
3000fcaa:	f64b 6498 	movw	r4, #48792	; 0xbe98
    *lock = 1;
3000fcae:	f04f 0801 	mov.w	r8, #1
3000fcb2:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000fcb6:	f894 3020 	ldrb.w	r3, [r4, #32]
3000fcba:	4543      	cmp	r3, r8
3000fcbc:	d04d      	beq.n	3000fd5a <hal_rstgen_creat_handle+0xde>
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
3000fcbe:	2240      	movs	r2, #64	; 0x40
3000fcc0:	4631      	mov	r1, r6
3000fcc2:	4620      	mov	r0, r4
3000fcc4:	f004 ee54 	blx	30014970 <memset>
            g_RstgenInstance.occupied = 1;
3000fcc8:	f884 8020 	strb.w	r8, [r4, #32]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
3000fccc:	f884 8033 	strb.w	r8, [r4, #51]	; 0x33
    *controllerTable = &s_RstgenDrvInterface;
3000fcd0:	f240 3358 	movw	r3, #856	; 0x358
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
3000fcd4:	f884 8034 	strb.w	r8, [r4, #52]	; 0x34
    *controllerTable = &s_RstgenDrvInterface;
3000fcd8:	f2c3 0302 	movt	r3, #12290	; 0x3002
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
3000fcdc:	f884 8035 	strb.w	r8, [r4, #53]	; 0x35
    *lock = 0;
3000fce0:	602e      	str	r6, [r5, #0]
    *controllerTable = &s_RstgenDrvInterface;
3000fce2:	6423      	str	r3, [r4, #64]	; 0x40
    __asm__ volatile("cpsie i");
3000fce4:	b662      	cpsie	i

    if (instance == NULL) {
        return false;
    }

    if (res_get_info_by_id(global_rst_res_idx,
3000fce6:	491e      	ldr	r1, [pc, #120]	; (3000fd60 <hal_rstgen_creat_handle+0xe4>)
3000fce8:	4648      	mov	r0, r9
3000fcea:	aa01      	add	r2, sp, #4
3000fcec:	f7ff ff7e 	bl	3000fbec <res_get_info_by_id>
3000fcf0:	b1b0      	cbz	r0, 3000fd20 <hal_rstgen_creat_handle+0xa4>
        return false;
3000fcf2:	2000      	movs	r0, #0

    mutex_init(&instance->rstgenMutex);

    *handle = instance;
    return true;
}
3000fcf4:	b003      	add	sp, #12
3000fcf6:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    if (g_RstgenInstance.occupied != 1) {
3000fcfa:	f64b 6498 	movw	r4, #48792	; 0xbe98
    *lock = 1;
3000fcfe:	2601      	movs	r6, #1
3000fd00:	f2c3 0402 	movt	r4, #12290	; 0x3002
3000fd04:	f894 3020 	ldrb.w	r3, [r4, #32]
3000fd08:	42b3      	cmp	r3, r6
    *lock = 0;
3000fd0a:	bf04      	itt	eq
3000fd0c:	2300      	moveq	r3, #0
3000fd0e:	602b      	streq	r3, [r5, #0]
3000fd10:	d10e      	bne.n	3000fd30 <hal_rstgen_creat_handle+0xb4>
    if (res_get_info_by_id(global_rst_res_idx,
3000fd12:	4648      	mov	r0, r9
3000fd14:	aa01      	add	r2, sp, #4
3000fd16:	4912      	ldr	r1, [pc, #72]	; (3000fd60 <hal_rstgen_creat_handle+0xe4>)
3000fd18:	f7ff ff68 	bl	3000fbec <res_get_info_by_id>
3000fd1c:	2800      	cmp	r0, #0
3000fd1e:	d1e8      	bne.n	3000fcf2 <hal_rstgen_creat_handle+0x76>
    mutex_init(&instance->rstgenMutex);
3000fd20:	4810      	ldr	r0, [pc, #64]	; (3000fd64 <hal_rstgen_creat_handle+0xe8>)
3000fd22:	f001 fe49 	bl	300119b8 <mutex_init>
    *handle = instance;
3000fd26:	603c      	str	r4, [r7, #0]
    return true;
3000fd28:	2001      	movs	r0, #1
}
3000fd2a:	b003      	add	sp, #12
3000fd2c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
3000fd30:	2240      	movs	r2, #64	; 0x40
3000fd32:	2100      	movs	r1, #0
3000fd34:	4620      	mov	r0, r4
3000fd36:	f004 ee1c 	blx	30014970 <memset>
    *controllerTable = &s_RstgenDrvInterface;
3000fd3a:	f240 3358 	movw	r3, #856	; 0x358
3000fd3e:	2200      	movs	r2, #0
3000fd40:	f2c3 0302 	movt	r3, #12290	; 0x3002
            g_RstgenInstance.occupied = 1;
3000fd44:	f884 6020 	strb.w	r6, [r4, #32]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
3000fd48:	f884 6033 	strb.w	r6, [r4, #51]	; 0x33
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
3000fd4c:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
3000fd50:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    *controllerTable = &s_RstgenDrvInterface;
3000fd54:	6423      	str	r3, [r4, #64]	; 0x40
3000fd56:	602a      	str	r2, [r5, #0]
3000fd58:	e7db      	b.n	3000fd12 <hal_rstgen_creat_handle+0x96>
3000fd5a:	602e      	str	r6, [r5, #0]
3000fd5c:	e7c2      	b.n	3000fce4 <hal_rstgen_creat_handle+0x68>
3000fd5e:	bf00      	nop
3000fd60:	3002bebc 	.word	0x3002bebc
3000fd64:	3002be9c 	.word	0x3002be9c

3000fd68 <hal_rstgen_release_handle>:
//*****************************************************************************
bool hal_rstgen_release_handle(void *handle)
{
    rstgen_instance_t *instance = NULL;

    if (handle == NULL) {
3000fd68:	b148      	cbz	r0, 3000fd7e <hal_rstgen_release_handle+0x16>
{
3000fd6a:	b508      	push	{r3, r14}
                handle);
        return false;
    }

    instance = (rstgen_instance_t *)handle;
    instance->occupied = 0;
3000fd6c:	2200      	movs	r2, #0
3000fd6e:	4603      	mov	r3, r0
    mutex_destroy(&instance->rstgenMutex);
3000fd70:	3004      	adds	r0, #4
    instance->occupied = 0;
3000fd72:	f883 2020 	strb.w	r2, [r3, #32]
    mutex_destroy(&instance->rstgenMutex);
3000fd76:	f001 fe35 	bl	300119e4 <mutex_destroy>
    return true;
3000fd7a:	2001      	movs	r0, #1
}
3000fd7c:	bd08      	pop	{r3, r15}
3000fd7e:	4770      	bx	r14

3000fd80 <hal_rstgen_init>:
}
#else
bool hal_rstgen_init(void *handle)
{
    return true;
}
3000fd80:	2001      	movs	r0, #1
3000fd82:	4770      	bx	r14

3000fd84 <hal_rstgen_core_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_core_reset(void *handle, uint32_t res_glb_idx)
{
3000fd84:	b510      	push	{r4, r14}
3000fd86:	4604      	mov	r4, r0
3000fd88:	b082      	sub	sp, #8
    paddr_t phy_addr;
    int32_t core_idx;
    vaddr_t base;
    bool ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &core_idx)) {
3000fd8a:	4608      	mov	r0, r1
3000fd8c:	aa01      	add	r2, sp, #4
3000fd8e:	4669      	mov	r1, r13
3000fd90:	f7ff ff2c 	bl	3000fbec <res_get_info_by_id>
3000fd94:	b948      	cbnz	r0, 3000fdaa <hal_rstgen_core_reset+0x26>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((core_idx > 0) && instance->controllerTable->core_reset) {
3000fd96:	9901      	ldr	r1, [sp, #4]
3000fd98:	2900      	cmp	r1, #0
3000fd9a:	dd04      	ble.n	3000fda6 <hal_rstgen_core_reset+0x22>
3000fd9c:	6c23      	ldr	r3, [r4, #64]	; 0x40
3000fd9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
3000fda0:	b133      	cbz	r3, 3000fdb0 <hal_rstgen_core_reset+0x2c>
        ret = instance->controllerTable->core_reset(
3000fda2:	9800      	ldr	r0, [sp, #0]
3000fda4:	4798      	blx	r3
                  (vaddr_t)base, (uint32_t)core_idx);
    }

    return ret;
}
3000fda6:	b002      	add	sp, #8
3000fda8:	bd10      	pop	{r4, r15}
        return ret;
3000fdaa:	2000      	movs	r0, #0
}
3000fdac:	b002      	add	sp, #8
3000fdae:	bd10      	pop	{r4, r15}
        return ret;
3000fdb0:	4618      	mov	r0, r3
3000fdb2:	e7f8      	b.n	3000fda6 <hal_rstgen_core_reset+0x22>

3000fdb4 <hal_rstgen_module_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_module_reset(void *handle, uint32_t res_glb_idx)
{
3000fdb4:	b530      	push	{r4, r5, r14}
3000fdb6:	4604      	mov	r4, r0
3000fdb8:	b083      	sub	sp, #12
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    bool        ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
3000fdba:	4608      	mov	r0, r1
3000fdbc:	aa01      	add	r2, sp, #4
3000fdbe:	4669      	mov	r1, r13
3000fdc0:	f7ff ff14 	bl	3000fbec <res_get_info_by_id>
3000fdc4:	b988      	cbnz	r0, 3000fdea <hal_rstgen_module_reset+0x36>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_ctl) {
3000fdc6:	9901      	ldr	r1, [sp, #4]
3000fdc8:	2900      	cmp	r1, #0
3000fdca:	dd0c      	ble.n	3000fde6 <hal_rstgen_module_reset+0x32>
3000fdcc:	6c23      	ldr	r3, [r4, #64]	; 0x40
3000fdce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
3000fdd0:	b173      	cbz	r3, 3000fdf0 <hal_rstgen_module_reset+0x3c>
    base = (vaddr_t)_ioaddr(phy_addr);
3000fdd2:	9d00      	ldr	r5, [sp, #0]
        ret = instance->controllerTable->module_ctl(
3000fdd4:	4602      	mov	r2, r0
3000fdd6:	4628      	mov	r0, r5
3000fdd8:	4798      	blx	r3
                  base, (uint32_t)module_idx, false);
        ret = instance->controllerTable->module_ctl(
3000fdda:	6c23      	ldr	r3, [r4, #64]	; 0x40
3000fddc:	4628      	mov	r0, r5
3000fdde:	2201      	movs	r2, #1
3000fde0:	9901      	ldr	r1, [sp, #4]
3000fde2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
3000fde4:	4798      	blx	r3
                  base, (uint32_t)module_idx, true);
    }

    return ret;
}
3000fde6:	b003      	add	sp, #12
3000fde8:	bd30      	pop	{r4, r5, r15}
        return ret;
3000fdea:	2000      	movs	r0, #0
}
3000fdec:	b003      	add	sp, #12
3000fdee:	bd30      	pop	{r4, r5, r15}
        return ret;
3000fdf0:	4618      	mov	r0, r3
3000fdf2:	e7f8      	b.n	3000fde6 <hal_rstgen_module_reset+0x32>

3000fdf4 <hal_scr_create_handle>:

    return (scr_handle_t)0;
    #else
    return (scr_handle_t)scr_signal;
    #endif
}
3000fdf4:	4770      	bx	r14
3000fdf6:	bf00      	nop

3000fdf8 <hal_scr_delete_handle>:

void hal_scr_delete_handle(scr_handle_t handle)
{
    ASSERT(handle);
3000fdf8:	ea50 0301 	orrs.w	r3, r0, r1
3000fdfc:	d000      	beq.n	3000fe00 <hal_scr_delete_handle+0x8>
3000fdfe:	4770      	bx	r14
3000fe00:	f24a 0354 	movw	r3, #41044	; 0xa054
3000fe04:	f240 3294 	movw	r2, #916	; 0x394
{
3000fe08:	b500      	push	{r14}
    ASSERT(handle);
3000fe0a:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fe0e:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000fe12:	b083      	sub	sp, #12
3000fe14:	4670      	mov	r0, r14
    ASSERT(handle);
3000fe16:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000fe1a:	9300      	str	r3, [sp, #0]
3000fe1c:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000fe20:	2357      	movs	r3, #87	; 0x57
3000fe22:	f004 f9f7 	bl	30014214 <_panic>
3000fe26:	bf00      	nop

3000fe28 <hal_scr_get>:
}

uint32_t hal_scr_get(scr_handle_t handle)
{
    ASSERT(handle);
3000fe28:	ea50 0301 	orrs.w	r3, r0, r1
3000fe2c:	d001      	beq.n	3000fe32 <hal_scr_get+0xa>
    return scr_get((scr_signal_t)handle);
3000fe2e:	f7fa bc75 	b.w	3000a71c <scr_get>
    ASSERT(handle);
3000fe32:	f24a 0354 	movw	r3, #41044	; 0xa054
3000fe36:	f240 3294 	movw	r2, #916	; 0x394
{
3000fe3a:	b500      	push	{r14}
    ASSERT(handle);
3000fe3c:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fe40:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000fe44:	b083      	sub	sp, #12
3000fe46:	4670      	mov	r0, r14
    ASSERT(handle);
3000fe48:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000fe4c:	9300      	str	r3, [sp, #0]
3000fe4e:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000fe52:	235c      	movs	r3, #92	; 0x5c
3000fe54:	f004 f9de 	bl	30014214 <_panic>

3000fe58 <hal_scr_set>:
}

bool hal_scr_set(scr_handle_t handle, uint32_t value)
{
    ASSERT(handle);
3000fe58:	ea50 0301 	orrs.w	r3, r0, r1
3000fe5c:	d001      	beq.n	3000fe62 <hal_scr_set+0xa>
    return scr_set((scr_signal_t)handle, value);
3000fe5e:	f7fa bcf3 	b.w	3000a848 <scr_set>
    ASSERT(handle);
3000fe62:	f24a 0354 	movw	r3, #41044	; 0xa054
3000fe66:	f240 3294 	movw	r2, #916	; 0x394
{
3000fe6a:	b500      	push	{r14}
    ASSERT(handle);
3000fe6c:	f2c3 0301 	movt	r3, #12289	; 0x3001
3000fe70:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
3000fe74:	b083      	sub	sp, #12
3000fe76:	4670      	mov	r0, r14
    ASSERT(handle);
3000fe78:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000fe7c:	9300      	str	r3, [sp, #0]
3000fe7e:	f2c3 0101 	movt	r1, #12289	; 0x3001
3000fe82:	2362      	movs	r3, #98	; 0x62
3000fe84:	f004 f9c6 	bl	30014214 <_panic>

3000fe88 <hal_spi_nor_creat_handle>:
    }
    return -1;
}

bool hal_spi_nor_creat_handle(void **handle, uint32_t spi_nor_res_glb_idx)
{
3000fe88:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
3000fe8c:	460c      	mov	r4, r1
3000fe8e:	b085      	sub	sp, #20
3000fe90:	4680      	mov	r8, r0
    addr_t ahb_paddr;
    int32_t apb_offset;
    int32_t ahb_offset;
    spin_lock_saved_state_t states;

    res_id = res_get_info_by_id(spi_nor_res_glb_idx, &apb_paddr, &apb_offset);
3000fe92:	aa02      	add	r2, sp, #8
3000fe94:	4608      	mov	r0, r1
3000fe96:	4669      	mov	r1, r13
3000fe98:	f7ff fea8 	bl	3000fbec <res_get_info_by_id>
    if (res_id < 0) {
3000fe9c:	2800      	cmp	r0, #0
3000fe9e:	db4d      	blt.n	3000ff3c <hal_spi_nor_creat_handle+0xb4>
        if (res[i].res_reg_glb_idx == idx)
3000fea0:	f245 2358 	movw	r3, #21080	; 0x5258
3000fea4:	f2c3 0302 	movt	r3, #12290	; 0x3002
3000fea8:	689a      	ldr	r2, [r3, #8]
3000feaa:	4294      	cmp	r4, r2
3000feac:	d060      	beq.n	3000ff70 <hal_spi_nor_creat_handle+0xe8>
3000feae:	6a1a      	ldr	r2, [r3, #32]
3000feb0:	4294      	cmp	r4, r2
3000feb2:	d060      	beq.n	3000ff76 <hal_spi_nor_creat_handle+0xee>
    return -1;
3000feb4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    dprintf(INFO, "res_id = %d, apb_paddr = 0x%lx, apb_offset = 0x%x \n",
            res_id, apb_paddr, apb_offset);

    slot = get_priv_res(s_spi_nor_priv_res, spi_nor_res_glb_idx);

    res_id = res_get_info_by_id(s_spi_nor_priv_res[slot].res_glb_idx,
3000feb8:	eb05 0445 	add.w	r4, r5, r5, lsl #1
3000febc:	aa03      	add	r2, sp, #12
3000febe:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
3000fec2:	a901      	add	r1, sp, #4
3000fec4:	68e0      	ldr	r0, [r4, #12]
3000fec6:	f7ff fe91 	bl	3000fbec <res_get_info_by_id>
                                &ahb_paddr, &ahb_offset);
    if (res_id < 0) {
3000feca:	2800      	cmp	r0, #0
3000fecc:	db36      	blt.n	3000ff3c <hal_spi_nor_creat_handle+0xb4>
        return false;
    }
    dprintf(INFO, "res_id = %d, ahb_paddr = 0x%lx, ahb_offset = 0x%x \n",
            res_id, ahb_paddr, ahb_offset);

    p_handle = &s_spi_nor_handle[slot];
3000fece:	f24c 1720 	movw	r7, #49440	; 0xc120
3000fed2:	eb05 0985 	add.w	r9, r5, r5, lsl #2
3000fed6:	f2c3 0702 	movt	r7, #12290	; 0x3002
3000feda:	eb05 0649 	add.w	r6, r5, r9, lsl #1
3000fede:	00b6      	lsls	r6, r6, #2
3000fee0:	19bb      	adds	r3, r7, r6
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000fee2:	f3ef 8000 	mrs	r0, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000fee6:	f010 0080 	ands.w	r0, r0, #128	; 0x80
3000feea:	d12e      	bne.n	3000ff4a <hal_spi_nor_creat_handle+0xc2>
    __asm__ volatile("cpsid i");
3000feec:	b672      	cpsid	i
    spin_lock_irqsave(&spi_nor_spin_lock, states);
    if (p_handle->apb_base) {
3000feee:	f8d3 b008 	ldr.w	r11, [r3, #8]
    *lock = 1;
3000fef2:	f24c 1a78 	movw	r10, #49528	; 0xc178
3000fef6:	f2c3 0a02 	movt	r10, #12290	; 0x3002
3000fefa:	f1bb 0f00 	cmp.w	r11, #0
3000fefe:	d134      	bne.n	3000ff6a <hal_spi_nor_creat_handle+0xe2>
        ret = false;
    }
    else {
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff00:	222c      	movs	r2, #44	; 0x2c
3000ff02:	4659      	mov	r1, r11
3000ff04:	4618      	mov	r0, r3
        p_handle->id = slot + 1;
3000ff06:	3501      	adds	r5, #1
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff08:	f004 ed32 	blx	30014970 <memset>
        p_handle->apb_base = apb_paddr;
        p_handle->ahb_base = ahb_paddr;
        p_handle->irq = s_spi_nor_priv_res[slot].irq;
3000ff0c:	6864      	ldr	r4, [r4, #4]
        p_handle->apb_base = apb_paddr;
3000ff0e:	9900      	ldr	r1, [sp, #0]
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff10:	f64b 72e0 	movw	r2, #49120	; 0xbfe0
        p_handle->id = slot + 1;
3000ff14:	51bd      	str	r5, [r7, r6]
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff16:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000ff1a:	eb02 1249 	add.w	r2, r2, r9, lsl #5
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff1e:	4603      	mov	r3, r0
        *handle = p_handle;
        ret = true;
3000ff20:	2001      	movs	r0, #1
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff22:	629a      	str	r2, [r3, #40]	; 0x28
        p_handle->ahb_base = ahb_paddr;
3000ff24:	9a01      	ldr	r2, [sp, #4]
        p_handle->irq = s_spi_nor_priv_res[slot].irq;
3000ff26:	605c      	str	r4, [r3, #4]
        p_handle->apb_base = apb_paddr;
3000ff28:	6099      	str	r1, [r3, #8]
        p_handle->ahb_base = ahb_paddr;
3000ff2a:	60da      	str	r2, [r3, #12]
        *handle = p_handle;
3000ff2c:	f8c8 3000 	str.w	r3, [r8]
    *lock = 0;
3000ff30:	f8ca b000 	str.w	r11, [r10]
    __asm__ volatile("cpsie i");
3000ff34:	b662      	cpsie	i
    }
    spin_unlock_irqrestore(&spi_nor_spin_lock, states);

    return ret;
}
3000ff36:	b005      	add	sp, #20
3000ff38:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *handle = NULL;
3000ff3c:	2300      	movs	r3, #0
        return false;
3000ff3e:	4618      	mov	r0, r3
        *handle = NULL;
3000ff40:	f8c8 3000 	str.w	r3, [r8]
}
3000ff44:	b005      	add	sp, #20
3000ff46:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (p_handle->apb_base) {
3000ff4a:	f8d3 b008 	ldr.w	r11, [r3, #8]
    *lock = 1;
3000ff4e:	f24c 1a78 	movw	r10, #49528	; 0xc178
3000ff52:	f2c3 0a02 	movt	r10, #12290	; 0x3002
3000ff56:	f1bb 0f00 	cmp.w	r11, #0
3000ff5a:	d00f      	beq.n	3000ff7c <hal_spi_nor_creat_handle+0xf4>
    *lock = 0;
3000ff5c:	2300      	movs	r3, #0
        ret = false;
3000ff5e:	4618      	mov	r0, r3
3000ff60:	f8ca 3000 	str.w	r3, [r10]
}
3000ff64:	b005      	add	sp, #20
3000ff66:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
3000ff6a:	f8ca 0000 	str.w	r0, [r10]
3000ff6e:	e7e1      	b.n	3000ff34 <hal_spi_nor_creat_handle+0xac>
        if (res[i].res_reg_glb_idx == idx)
3000ff70:	461a      	mov	r2, r3
            return res[i].slot;
3000ff72:	6815      	ldr	r5, [r2, #0]
3000ff74:	e7a0      	b.n	3000feb8 <hal_spi_nor_creat_handle+0x30>
        if (res[i].res_reg_glb_idx == idx)
3000ff76:	f103 0218 	add.w	r2, r3, #24
3000ff7a:	e7fa      	b.n	3000ff72 <hal_spi_nor_creat_handle+0xea>
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff7c:	222c      	movs	r2, #44	; 0x2c
3000ff7e:	4659      	mov	r1, r11
3000ff80:	4618      	mov	r0, r3
        p_handle->id = slot + 1;
3000ff82:	3501      	adds	r5, #1
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff84:	f004 ecf4 	blx	30014970 <memset>
        p_handle->irq = s_spi_nor_priv_res[slot].irq;
3000ff88:	6861      	ldr	r1, [r4, #4]
        p_handle->ahb_base = ahb_paddr;
3000ff8a:	9c01      	ldr	r4, [sp, #4]
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff8c:	f64b 72e0 	movw	r2, #49120	; 0xbfe0
        p_handle->id = slot + 1;
3000ff90:	51bd      	str	r5, [r7, r6]
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff92:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000ff96:	eb02 1249 	add.w	r2, r2, r9, lsl #5
        memset(p_handle, 0, sizeof(struct spi_nor_handle));
3000ff9a:	4603      	mov	r3, r0
        ret = true;
3000ff9c:	2001      	movs	r0, #1
        p_handle->priv_data = &s_spi_nor_dev[slot];
3000ff9e:	629a      	str	r2, [r3, #40]	; 0x28
        p_handle->apb_base = apb_paddr;
3000ffa0:	9a00      	ldr	r2, [sp, #0]
        p_handle->irq = s_spi_nor_priv_res[slot].irq;
3000ffa2:	6059      	str	r1, [r3, #4]
        p_handle->ahb_base = ahb_paddr;
3000ffa4:	e9c3 2402 	strd	r2, r4, [r3, #8]
        *handle = p_handle;
3000ffa8:	f8c8 3000 	str.w	r3, [r8]
3000ffac:	f8ca b000 	str.w	r11, [r10]
3000ffb0:	e7c8      	b.n	3000ff44 <hal_spi_nor_creat_handle+0xbc>
3000ffb2:	bf00      	nop

3000ffb4 <hal_spi_nor_release_handle>:

bool hal_spi_nor_release_handle(void **handle)
{
3000ffb4:	b530      	push	{r4, r5, r14}
3000ffb6:	b083      	sub	sp, #12
    ASSERT(handle);
3000ffb8:	b328      	cbz	r0, 30010006 <hal_spi_nor_release_handle+0x52>
    struct spi_nor_handle *spi_nor = *handle;
3000ffba:	6805      	ldr	r5, [r0, #0]
3000ffbc:	4604      	mov	r4, r0
    struct spi_nor *dev = spi_nor->priv_data;
    spin_lock_saved_state_t states;

    spi_nor_deinit(dev);
3000ffbe:	6aa8      	ldr	r0, [r5, #40]	; 0x28
3000ffc0:	f002 ffbc 	bl	30012f3c <spi_nor_deinit>
    if (spi_nor->irq)
3000ffc4:	6868      	ldr	r0, [r5, #4]
3000ffc6:	b9d8      	cbnz	r0, 30010000 <hal_spi_nor_release_handle+0x4c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3000ffc8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3000ffcc:	f013 0380 	ands.w	r3, r3, #128	; 0x80
3000ffd0:	d10b      	bne.n	3000ffea <hal_spi_nor_release_handle+0x36>
    __asm__ volatile("cpsid i");
3000ffd2:	b672      	cpsid	i
        mask_interrupt(spi_nor->irq);

    spin_lock_irqsave(&spi_nor_spin_lock, states);
    spi_nor->apb_base = 0;
3000ffd4:	60ab      	str	r3, [r5, #8]
    *lock = 0;
3000ffd6:	f24c 1278 	movw	r2, #49528	; 0xc178
    *handle = NULL;
3000ffda:	6023      	str	r3, [r4, #0]
3000ffdc:	f2c3 0202 	movt	r2, #12290	; 0x3002
3000ffe0:	6013      	str	r3, [r2, #0]
    __asm__ volatile("cpsie i");
3000ffe2:	b662      	cpsie	i
    spin_unlock_irqrestore(&spi_nor_spin_lock, states);

    return true;
}
3000ffe4:	2001      	movs	r0, #1
3000ffe6:	b003      	add	sp, #12
3000ffe8:	bd30      	pop	{r4, r5, r15}
3000ffea:	f24c 1378 	movw	r3, #49528	; 0xc178
    spi_nor->apb_base = 0;
3000ffee:	2200      	movs	r2, #0
}
3000fff0:	2001      	movs	r0, #1
3000fff2:	f2c3 0302 	movt	r3, #12290	; 0x3002
    spi_nor->apb_base = 0;
3000fff6:	60aa      	str	r2, [r5, #8]
    *handle = NULL;
3000fff8:	6022      	str	r2, [r4, #0]
3000fffa:	601a      	str	r2, [r3, #0]
}
3000fffc:	b003      	add	sp, #12
3000fffe:	bd30      	pop	{r4, r5, r15}
        mask_interrupt(spi_nor->irq);
30010000:	f7f0 fb80 	bl	30000704 <mask_interrupt>
30010004:	e7e0      	b.n	3000ffc8 <hal_spi_nor_release_handle+0x14>
    ASSERT(handle);
30010006:	f24a 0354 	movw	r3, #41044	; 0xa054
3001000a:	f240 4220 	movw	r2, #1056	; 0x420
3001000e:	f24a 011c 	movw	r1, #40988	; 0xa01c
30010012:	f2c3 0301 	movt	r3, #12289	; 0x3001
30010016:	4670      	mov	r0, r14
30010018:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001001c:	9300      	str	r3, [sp, #0]
3001001e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010022:	23b7      	movs	r3, #183	; 0xb7
30010024:	f004 f8f6 	bl	30014214 <_panic>

30010028 <hal_spi_nor_init>:

    return ref_clock;
}

int hal_spi_nor_init(void *handle)
{
30010028:	b570      	push	{r4, r5, r6, r14}
3001002a:	b082      	sub	sp, #8
    ASSERT(handle);
3001002c:	2800      	cmp	r0, #0
3001002e:	d036      	beq.n	3001009e <hal_spi_nor_init+0x76>
30010030:	4605      	mov	r5, r0
    spi_nor_cfg->bus_clk = spi_nor->config->bus_clk;
    spi_nor_cfg->id = spi_nor->id;
    spi_nor_cfg->apb_base = spi_nor->apb_base;
    spi_nor_cfg->ahb_base = spi_nor->ahb_base;
    spi_nor_cfg->irq = spi_nor->irq;
    spi_nor_cfg->clk = 300000000;
30010032:	f44f 4223 	mov.w	r2, #41728	; 0xa300
    spi_nor_cfg->octal_ddr_en = spi_nor->config->octal_ddr_en;
30010036:	6903      	ldr	r3, [r0, #16]
30010038:	7a19      	ldrb	r1, [r3, #8]
    struct spi_nor *dev = spi_nor->priv_data;
3001003a:	6a84      	ldr	r4, [r0, #40]	; 0x28
    spi_nor_cfg->clk = 300000000;
3001003c:	f2c1 12e1 	movt	r2, #4577	; 0x11e1
    spi_nor_cfg->octal_ddr_en = spi_nor->config->octal_ddr_en;
30010040:	7721      	strb	r1, [r4, #28]
    spi_nor_cfg->cs = spi_nor->config->cs;
30010042:	7819      	ldrb	r1, [r3, #0]
30010044:	7161      	strb	r1, [r4, #5]

    if (spi_nor_init(dev)) {
30010046:	4620      	mov	r0, r4
    spi_nor_cfg->id = spi_nor->id;
30010048:	682e      	ldr	r6, [r5, #0]
    spi_nor_cfg->bus_clk = spi_nor->config->bus_clk;
3001004a:	6859      	ldr	r1, [r3, #4]
    spi_nor_cfg->id = spi_nor->id;
3001004c:	7126      	strb	r6, [r4, #4]
    spi_nor_cfg->apb_base = spi_nor->apb_base;
3001004e:	68ab      	ldr	r3, [r5, #8]
    spi_nor_cfg->bus_clk = spi_nor->config->bus_clk;
30010050:	60e1      	str	r1, [r4, #12]
    spi_nor_cfg->ahb_base = spi_nor->ahb_base;
30010052:	68e9      	ldr	r1, [r5, #12]
    spi_nor_cfg->apb_base = spi_nor->apb_base;
30010054:	6123      	str	r3, [r4, #16]
    spi_nor_cfg->irq = spi_nor->irq;
30010056:	686b      	ldr	r3, [r5, #4]
30010058:	e9c4 1305 	strd	r1, r3, [r4, #20]
    spi_nor_cfg->clk = 300000000;
3001005c:	60a2      	str	r2, [r4, #8]
    if (spi_nor_init(dev)) {
3001005e:	f002 fe7f 	bl	30012d60 <spi_nor_init>
30010062:	bb68      	cbnz	r0, 300100c0 <hal_spi_nor_init+0x98>
        dprintf(CRITICAL, "norflash init failed!\n");
        return -1;
    }

    dev->parent = spi_nor;
30010064:	67a5      	str	r5, [r4, #120]	; 0x78

    if (!spi_nor->async_mode && spi_nor->event_handle) {
30010066:	7e2b      	ldrb	r3, [r5, #24]
30010068:	b12b      	cbz	r3, 30010076 <hal_spi_nor_init+0x4e>
                spi_nor->event_handle ? "not null" : "null");
        return -1;
    }
    dev->async_mode = spi_nor->async_mode;

    spi_nor->block_size = dev->block_size;
3001006a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    dev->async_mode = spi_nor->async_mode;
3001006c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    spi_nor->block_size = dev->block_size;
30010070:	616a      	str	r2, [r5, #20]

    return 0;
}
30010072:	b002      	add	sp, #8
30010074:	bd70      	pop	{r4, r5, r6, r15}
    if (!spi_nor->async_mode && spi_nor->event_handle) {
30010076:	6a6a      	ldr	r2, [r5, #36]	; 0x24
30010078:	2a00      	cmp	r2, #0
3001007a:	d0f6      	beq.n	3001006a <hal_spi_nor_init+0x42>
        dprintf(CRITICAL,
3001007c:	f64e 524c 	movw	r2, #60748	; 0xed4c
30010080:	f64e 5158 	movw	r1, #60760	; 0xed58
30010084:	f64e 5060 	movw	r0, #60768	; 0xed60
30010088:	f2c3 0201 	movt	r2, #12289	; 0x3001
3001008c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010090:	f2c3 0001 	movt	r0, #12289	; 0x3001
30010094:	f005 fd8c 	bl	30015bb0 <_printf>
        return -1;
30010098:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3001009c:	e7e9      	b.n	30010072 <hal_spi_nor_init+0x4a>
    ASSERT(handle);
3001009e:	f24a 0354 	movw	r3, #41044	; 0xa054
300100a2:	f240 4220 	movw	r2, #1056	; 0x420
300100a6:	f24a 011c 	movw	r1, #40988	; 0xa01c
300100aa:	f2c3 0301 	movt	r3, #12289	; 0x3001
300100ae:	4670      	mov	r0, r14
300100b0:	f2c3 0202 	movt	r2, #12290	; 0x3002
300100b4:	9300      	str	r3, [sp, #0]
300100b6:	f2c3 0101 	movt	r1, #12289	; 0x3001
300100ba:	23de      	movs	r3, #222	; 0xde
300100bc:	f004 f8aa 	bl	30014214 <_panic>
        dprintf(CRITICAL, "norflash init failed!\n");
300100c0:	f240 4008 	movw	r0, #1032	; 0x408
300100c4:	f2c3 0002 	movt	r0, #12290	; 0x3002
300100c8:	f005 fd72 	bl	30015bb0 <_printf>
        return -1;
300100cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
300100d0:	e7cf      	b.n	30010072 <hal_spi_nor_init+0x4a>
300100d2:	bf00      	nop

300100d4 <hal_spi_nor_read>:

inline int hal_spi_nor_read(void *handle, spi_nor_address_t src, uint8_t *dst,
                            spi_nor_length_t length)
{
300100d4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300100d8:	4699      	mov	r9, r3
300100da:	b089      	sub	sp, #36	; 0x24
300100dc:	e9dd 3414 	ldrd	r3, r4, [r13, #80]	; 0x50
300100e0:	f8dd a048 	ldr.w	r10, [r13, #72]	; 0x48
300100e4:	e9cd 3404 	strd	r3, r4, [r13, #16]
    LTRACEF("handle %p, src %lld, dst %p, len %lld\n", handle, src, dst,
            length);
    ASSERT(handle);
300100e8:	2800      	cmp	r0, #0
300100ea:	d07c      	beq.n	300101e6 <hal_spi_nor_read+0x112>
300100ec:	4690      	mov	r8, r2
    struct spi_nor_handle *spi_nor = handle;
    struct spi_nor *dev = spi_nor->priv_data;
    uint32_t read_len;

    /* the memory address not aligned with cache line size */
    if (!IS_ALIGNED(dst, CACHE_LINE)) {
300100ee:	f01a 0f1f 	tst.w	r10, #31
    struct spi_nor *dev = spi_nor->priv_data;
300100f2:	f8d0 b028 	ldr.w	r11, [r0, #40]	; 0x28
    if (!IS_ALIGNED(dst, CACHE_LINE)) {
300100f6:	d141      	bne.n	3001017c <hal_spi_nor_read+0xa8>
        length -= read_len;
        dst += read_len;
        src += read_len;
    }

    if (length) {
300100f8:	e9dd 3404 	ldrd	r3, r4, [r13, #16]
300100fc:	4323      	orrs	r3, r4
300100fe:	d038      	beq.n	30010172 <hal_spi_nor_read+0x9e>
        read_len = ROUNDDOWN(length, CACHE_LINE);
30010100:	e9dd 3404 	ldrd	r3, r4, [r13, #16]
30010104:	461e      	mov	r6, r3
        if (read_len) {
30010106:	f033 011f 	bics.w	r1, r3, #31
3001010a:	d11b      	bne.n	30010144 <hal_spi_nor_read+0x70>
        }
    }

    if (length) {
        read_len = length;
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
3001010c:	f64b 67e0 	movw	r7, #48864	; 0xbee0
30010110:	1cf4      	adds	r4, r6, #3
30010112:	2100      	movs	r1, #0
30010114:	f024 0403 	bic.w	r4, r4, #3
30010118:	4642      	mov	r2, r8
3001011a:	f2c3 0702 	movt	r7, #12290	; 0x3002
3001011e:	464b      	mov	r3, r9
30010120:	4658      	mov	r0, r11
30010122:	9402      	str	r4, [sp, #8]
30010124:	9700      	str	r7, [sp, #0]
30010126:	9103      	str	r1, [sp, #12]
30010128:	f002 fcfc 	bl	30012b24 <spi_nor_read>
3001012c:	4605      	mov	r5, r0
3001012e:	2800      	cmp	r0, #0
30010130:	d172      	bne.n	30010218 <hal_spi_nor_read+0x144>
            return -1;
        memcpy(dst, local_buf, read_len);
30010132:	4632      	mov	r2, r6
30010134:	4639      	mov	r1, r7
30010136:	4650      	mov	r0, r10
30010138:	f004 eb94 	blx	30014864 <memcpy>
        length -= read_len;
    }

    assert(!length);
    return 0;
}
3001013c:	4628      	mov	r0, r5
3001013e:	b009      	add	sp, #36	; 0x24
30010140:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (spi_nor_read(dev, src, dst, read_len))
30010144:	460e      	mov	r6, r1
30010146:	2700      	movs	r7, #0
30010148:	f8cd a000 	str.w	r10, [r13]
3001014c:	4658      	mov	r0, r11
3001014e:	e9cd 6702 	strd	r6, r7, [r13, #8]
30010152:	4642      	mov	r2, r8
30010154:	9107      	str	r1, [sp, #28]
30010156:	464b      	mov	r3, r9
30010158:	f002 fce4 	bl	30012b24 <spi_nor_read>
3001015c:	2800      	cmp	r0, #0
3001015e:	d15b      	bne.n	30010218 <hal_spi_nor_read+0x144>
            length -= read_len;
30010160:	e9dd 4504 	ldrd	r4, r5, [r13, #16]
    if (length) {
30010164:	9907      	ldr	r1, [sp, #28]
            length -= read_len;
30010166:	1ba4      	subs	r4, r4, r6
30010168:	eb65 0507 	sbc.w	r5, r5, r7
    if (length) {
3001016c:	ea54 0305 	orrs.w	r3, r4, r5
30010170:	d14b      	bne.n	3001020a <hal_spi_nor_read+0x136>
    return 0;
30010172:	2500      	movs	r5, #0
}
30010174:	4628      	mov	r0, r5
30010176:	b009      	add	sp, #36	; 0x24
30010178:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        read_len = MIN(read_len, length);
3001017c:	2700      	movs	r7, #0
        read_len = ROUNDUP((addr_t)dst, CACHE_LINE) - (addr_t)dst;
3001017e:	f10a 031f 	add.w	r3, r10, #31
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
30010182:	f64b 61e0 	movw	r1, #48864	; 0xbee0
        read_len = ROUNDUP((addr_t)dst, CACHE_LINE) - (addr_t)dst;
30010186:	f023 031f 	bic.w	r3, r3, #31
        read_len = MIN(read_len, length);
3001018a:	eba3 060a 	sub.w	r6, r3, r10
3001018e:	e9dd 3404 	ldrd	r3, r4, [r13, #16]
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
30010192:	f2c3 0102 	movt	r1, #12290	; 0x3002
30010196:	2200      	movs	r2, #0
30010198:	4658      	mov	r0, r11
3001019a:	9100      	str	r1, [sp, #0]
        read_len = MIN(read_len, length);
3001019c:	42bc      	cmp	r4, r7
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
3001019e:	9203      	str	r2, [sp, #12]
        read_len = MIN(read_len, length);
300101a0:	bf08      	it	eq
300101a2:	42b3      	cmpeq	r3, r6
300101a4:	bf38      	it	cc
300101a6:	461e      	movcc	r6, r3
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
300101a8:	4642      	mov	r2, r8
300101aa:	9107      	str	r1, [sp, #28]
300101ac:	f106 0303 	add.w	r3, r6, #3
        read_len = MIN(read_len, length);
300101b0:	bf38      	it	cc
300101b2:	4627      	movcc	r7, r4
        if (spi_nor_read(dev, src, local_buf, ROUNDUP(read_len, 4)))
300101b4:	f023 0303 	bic.w	r3, r3, #3
300101b8:	9302      	str	r3, [sp, #8]
300101ba:	464b      	mov	r3, r9
300101bc:	f002 fcb2 	bl	30012b24 <spi_nor_read>
300101c0:	9907      	ldr	r1, [sp, #28]
300101c2:	bb48      	cbnz	r0, 30010218 <hal_spi_nor_read+0x144>
        length -= read_len;
300101c4:	e9dd 3404 	ldrd	r3, r4, [r13, #16]
        memcpy(dst, local_buf, read_len);
300101c8:	4650      	mov	r0, r10
300101ca:	4632      	mov	r2, r6
        dst += read_len;
300101cc:	44b2      	add	r10, r6
        length -= read_len;
300101ce:	1b9b      	subs	r3, r3, r6
300101d0:	eb64 0407 	sbc.w	r4, r4, r7
300101d4:	e9cd 3404 	strd	r3, r4, [r13, #16]
        memcpy(dst, local_buf, read_len);
300101d8:	f004 eb44 	blx	30014864 <memcpy>
        src += read_len;
300101dc:	eb18 0806 	adds.w	r8, r8, r6
300101e0:	eb49 0907 	adc.w	r9, r9, r7
300101e4:	e788      	b.n	300100f8 <hal_spi_nor_read+0x24>
    ASSERT(handle);
300101e6:	f24a 0354 	movw	r3, #41044	; 0xa054
300101ea:	f240 4220 	movw	r2, #1056	; 0x420
300101ee:	f24a 011c 	movw	r1, #40988	; 0xa01c
300101f2:	f2c3 0301 	movt	r3, #12289	; 0x3001
300101f6:	4670      	mov	r0, r14
300101f8:	f2c3 0202 	movt	r2, #12290	; 0x3002
300101fc:	9300      	str	r3, [sp, #0]
300101fe:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010202:	f44f 7383 	mov.w	r3, #262	; 0x106
30010206:	f004 f805 	bl	30014214 <_panic>
            src += read_len;
3001020a:	eb18 0806 	adds.w	r8, r8, r6
            dst += read_len;
3001020e:	448a      	add	r10, r1
30010210:	4626      	mov	r6, r4
            src += read_len;
30010212:	eb49 0907 	adc.w	r9, r9, r7
30010216:	e779      	b.n	3001010c <hal_spi_nor_read+0x38>
            return -1;
30010218:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
3001021c:	e7aa      	b.n	30010174 <hal_spi_nor_read+0xa0>
3001021e:	bf00      	nop

30010220 <hal_spi_nor_write>:

inline int hal_spi_nor_write(void *handle, spi_nor_address_t dst,
                             const uint8_t *src_buf, spi_nor_length_t length)
{
30010220:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30010224:	b08d      	sub	sp, #52	; 0x34
30010226:	e9cd 2304 	strd	r2, r3, [r13, #16]
3001022a:	9f16      	ldr	r7, [sp, #88]	; 0x58
3001022c:	e9dd ab18 	ldrd	r10, r11, [r13, #96]	; 0x60
    LTRACEF("handle %p, dst %lld, len %lld, buf %p\n", handle, dst, length,
            src_buf);
    ASSERT(handle);
30010230:	2800      	cmp	r0, #0
30010232:	d05a      	beq.n	300102ea <hal_spi_nor_write+0xca>

    struct spi_nor_handle *spi_nor = handle;
    struct spi_nor *dev = spi_nor->priv_data;
30010234:	6a83      	ldr	r3, [r0, #40]	; 0x28
    uint8_t *buf = (uint8_t *)src_buf;
    uint8_t use_local_buf = 0;
    spi_nor_length_t max_write_length = length;
    spi_nor_length_t remaining = length;

    if (!IS_ALIGNED(src_buf, CACHE_LINE)) {
30010236:	f017 091f 	ands.w	r9, r7, #31
    struct spi_nor *dev = spi_nor->priv_data;
3001023a:	461a      	mov	r2, r3
    if (!IS_ALIGNED(src_buf, CACHE_LINE)) {
3001023c:	d144      	bne.n	300102c8 <hal_spi_nor_write+0xa8>
    uint8_t use_local_buf = 0;
3001023e:	f8cd 9028 	str.w	r9, [r13, #40]	; 0x28
30010242:	e9cd ab08 	strd	r10, r11, [r13, #32]
        max_write_length = SPINOR_LOCAL_BUF_SIZE;
        use_local_buf = 1;
    }

    while (remaining) {
30010246:	ea5a 030b 	orrs.w	r3, r10, r11
3001024a:	d045      	beq.n	300102d8 <hal_spi_nor_write+0xb8>
        write_len = MIN(remaining, max_write_length);

        if (use_local_buf) {
            buf = local_buf;
            memcpy(buf, src_buf, write_len);
3001024c:	f64b 69e0 	movw	r9, #48864	; 0xbee0
    while (remaining) {
30010250:	463e      	mov	r6, r7
            memcpy(buf, src_buf, write_len);
30010252:	f2c3 0902 	movt	r9, #12290	; 0x3002
30010256:	f8cd 902c 	str.w	r9, [r13, #44]	; 0x2c
3001025a:	4691      	mov	r9, r2
3001025c:	e021      	b.n	300102a2 <hal_spi_nor_write+0x82>
3001025e:	4622      	mov	r2, r4
30010260:	2300      	movs	r3, #0
        }

        if (spi_nor_write(dev, dst, buf, write_len))
30010262:	e9dd 4504 	ldrd	r4, r5, [r13, #16]
30010266:	4648      	mov	r0, r9
30010268:	e9cd 2306 	strd	r2, r3, [r13, #24]
3001026c:	e9cd 2302 	strd	r2, r3, [r13, #8]
30010270:	4622      	mov	r2, r4
30010272:	9700      	str	r7, [sp, #0]
30010274:	462b      	mov	r3, r5
30010276:	f002 fd27 	bl	30012cc8 <spi_nor_write>
3001027a:	2800      	cmp	r0, #0
3001027c:	d130      	bne.n	300102e0 <hal_spi_nor_write+0xc0>
            return -1;

        remaining -= write_len;
3001027e:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
        src_buf += write_len;
30010282:	4446      	add	r6, r8
        remaining -= write_len;
30010284:	ebba 0002 	subs.w	r0, r10, r2
30010288:	4682      	mov	r10, r0
3001028a:	eb6b 0103 	sbc.w	r1, r11, r3
3001028e:	468b      	mov	r11, r1
        dst += write_len;
30010290:	1912      	adds	r2, r2, r4
30010292:	4614      	mov	r4, r2
30010294:	416b      	adcs	r3, r5
30010296:	461d      	mov	r5, r3
    while (remaining) {
30010298:	ea5a 030b 	orrs.w	r3, r10, r11
        dst += write_len;
3001029c:	e9cd 4504 	strd	r4, r5, [r13, #16]
    while (remaining) {
300102a0:	d01a      	beq.n	300102d8 <hal_spi_nor_write+0xb8>
        write_len = MIN(remaining, max_write_length);
300102a2:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
300102a6:	4614      	mov	r4, r2
300102a8:	459b      	cmp	r11, r3
        if (use_local_buf) {
300102aa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        write_len = MIN(remaining, max_write_length);
300102ac:	bf08      	it	eq
300102ae:	4592      	cmpeq	r10, r2
300102b0:	bf38      	it	cc
300102b2:	4654      	movcc	r4, r10
300102b4:	46a0      	mov	r8, r4
        if (use_local_buf) {
300102b6:	2b00      	cmp	r3, #0
300102b8:	d0d1      	beq.n	3001025e <hal_spi_nor_write+0x3e>
            memcpy(buf, src_buf, write_len);
300102ba:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
300102bc:	4622      	mov	r2, r4
300102be:	4631      	mov	r1, r6
300102c0:	4638      	mov	r0, r7
300102c2:	f004 ead0 	blx	30014864 <memcpy>
300102c6:	e7ca      	b.n	3001025e <hal_spi_nor_write+0x3e>
        max_write_length = SPINOR_LOCAL_BUF_SIZE;
300102c8:	f44f 7380 	mov.w	r3, #256	; 0x100
300102cc:	2400      	movs	r4, #0
300102ce:	e9cd 3408 	strd	r3, r4, [r13, #32]
        use_local_buf = 1;
300102d2:	2301      	movs	r3, #1
300102d4:	930a      	str	r3, [sp, #40]	; 0x28
300102d6:	e7b6      	b.n	30010246 <hal_spi_nor_write+0x26>
    }

    return 0;
300102d8:	2000      	movs	r0, #0
}
300102da:	b00d      	add	sp, #52	; 0x34
300102dc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            return -1;
300102e0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
300102e4:	b00d      	add	sp, #52	; 0x34
300102e6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ASSERT(handle);
300102ea:	f24a 0354 	movw	r3, #41044	; 0xa054
300102ee:	f240 4220 	movw	r2, #1056	; 0x420
300102f2:	f24a 011c 	movw	r1, #40988	; 0xa01c
300102f6:	f2c3 0301 	movt	r3, #12289	; 0x3001
300102fa:	4670      	mov	r0, r14
300102fc:	f2c3 0202 	movt	r2, #12290	; 0x3002
30010300:	9300      	str	r3, [sp, #0]
30010302:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010306:	f44f 739b 	mov.w	r3, #310	; 0x136
3001030a:	f003 ff83 	bl	30014214 <_panic>
3001030e:	bf00      	nop

30010310 <hal_spi_nor_erase>:

/* The erase address and length must aligned with block size */
int hal_spi_nor_erase(void *handle, spi_nor_address_t dst,
                      spi_nor_length_t length)
{
30010310:	b530      	push	{r4, r5, r14}
30010312:	b083      	sub	sp, #12
30010314:	9d06      	ldr	r5, [sp, #24]
    LTRACEF("handle %p, dst %lld, len %lld\n", handle, dst, length);
    ASSERT(handle);
30010316:	b158      	cbz	r0, 30010330 <hal_spi_nor_erase+0x20>
    struct spi_nor_handle *spi_nor = handle;
    ASSERT(IS_ALIGNED(dst, spi_nor->block_size));
30010318:	6941      	ldr	r1, [r0, #20]
3001031a:	3901      	subs	r1, #1
3001031c:	4211      	tst	r1, r2
3001031e:	d119      	bne.n	30010354 <hal_spi_nor_erase+0x44>
    ASSERT(IS_ALIGNED(length, spi_nor->block_size));
30010320:	4229      	tst	r1, r5
30010322:	d129      	bne.n	30010378 <hal_spi_nor_erase+0x68>

    struct spi_nor *dev = spi_nor->priv_data;

    return spi_nor_erase(dev, dst, length);
30010324:	6a80      	ldr	r0, [r0, #40]	; 0x28
}
30010326:	b003      	add	sp, #12
30010328:	e8bd 4030 	ldmia.w	r13!, {r4, r5, r14}
    return spi_nor_erase(dev, dst, length);
3001032c:	f002 bc76 	b.w	30012c1c <spi_nor_erase>
    ASSERT(handle);
30010330:	f24a 0354 	movw	r3, #41044	; 0xa054
30010334:	f240 4220 	movw	r2, #1056	; 0x420
30010338:	f24a 011c 	movw	r1, #40988	; 0xa01c
3001033c:	f2c3 0301 	movt	r3, #12289	; 0x3001
30010340:	4670      	mov	r0, r14
30010342:	f2c3 0202 	movt	r2, #12290	; 0x3002
30010346:	9300      	str	r3, [sp, #0]
30010348:	f2c3 0101 	movt	r1, #12289	; 0x3001
3001034c:	f240 135d 	movw	r3, #349	; 0x15d
30010350:	f003 ff60 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(dst, spi_nor->block_size));
30010354:	f240 33b8 	movw	r3, #952	; 0x3b8
30010358:	f240 4220 	movw	r2, #1056	; 0x420
3001035c:	f24a 011c 	movw	r1, #40988	; 0xa01c
30010360:	f2c3 0302 	movt	r3, #12290	; 0x3002
30010364:	4670      	mov	r0, r14
30010366:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001036a:	9300      	str	r3, [sp, #0]
3001036c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010370:	f240 135f 	movw	r3, #351	; 0x15f
30010374:	f003 ff4e 	bl	30014214 <_panic>
    ASSERT(IS_ALIGNED(length, spi_nor->block_size));
30010378:	f240 33e0 	movw	r3, #992	; 0x3e0
3001037c:	f240 4220 	movw	r2, #1056	; 0x420
30010380:	f24a 011c 	movw	r1, #40988	; 0xa01c
30010384:	f2c3 0302 	movt	r3, #12290	; 0x3002
30010388:	4670      	mov	r0, r14
3001038a:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001038e:	9300      	str	r3, [sp, #0]
30010390:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010394:	f44f 73b0 	mov.w	r3, #352	; 0x160
30010398:	f003 ff3c 	bl	30014214 <_panic>

3001039c <hal_spi_nor_get_capacity>:
    return spi_nor_cancel(dev);
}

spi_nor_length_t hal_spi_nor_get_capacity(void *handle)
{
    ASSERT(handle);
3001039c:	b110      	cbz	r0, 300103a4 <hal_spi_nor_get_capacity+0x8>
    struct spi_nor_handle *spi_nor = handle;
    struct spi_nor *dev = spi_nor->priv_data;

    return spi_nor_get_capacity(dev);
3001039e:	6a80      	ldr	r0, [r0, #40]	; 0x28
300103a0:	f002 bdce 	b.w	30012f40 <spi_nor_get_capacity>
    ASSERT(handle);
300103a4:	f24a 0354 	movw	r3, #41044	; 0xa054
300103a8:	f240 4220 	movw	r2, #1056	; 0x420
{
300103ac:	b500      	push	{r14}
    ASSERT(handle);
300103ae:	f2c3 0301 	movt	r3, #12289	; 0x3001
300103b2:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
300103b6:	b083      	sub	sp, #12
300103b8:	4670      	mov	r0, r14
    ASSERT(handle);
300103ba:	f2c3 0202 	movt	r2, #12290	; 0x3002
300103be:	9300      	str	r3, [sp, #0]
300103c0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300103c4:	f44f 73ba 	mov.w	r3, #372	; 0x174
300103c8:	f003 ff24 	bl	30014214 <_panic>

300103cc <hal_spi_nor_get_flash_id>:
}

spi_nor_length_t hal_spi_nor_get_flash_id(void *handle)
{
    ASSERT(handle);
300103cc:	b110      	cbz	r0, 300103d4 <hal_spi_nor_get_flash_id+0x8>
    struct spi_nor_handle *spi_nor = handle;
    struct spi_nor *dev = spi_nor->priv_data;

    return spi_nor_get_flash_id(dev);
300103ce:	6a80      	ldr	r0, [r0, #40]	; 0x28
300103d0:	f002 bdba 	b.w	30012f48 <spi_nor_get_flash_id>
    ASSERT(handle);
300103d4:	f24a 0354 	movw	r3, #41044	; 0xa054
300103d8:	f240 4220 	movw	r2, #1056	; 0x420
{
300103dc:	b500      	push	{r14}
    ASSERT(handle);
300103de:	f2c3 0301 	movt	r3, #12289	; 0x3001
300103e2:	f24a 011c 	movw	r1, #40988	; 0xa01c
{
300103e6:	b083      	sub	sp, #12
300103e8:	4670      	mov	r0, r14
    ASSERT(handle);
300103ea:	f2c3 0202 	movt	r2, #12290	; 0x3002
300103ee:	9300      	str	r3, [sp, #0]
300103f0:	f2c3 0101 	movt	r1, #12289	; 0x3001
300103f4:	f240 137d 	movw	r3, #381	; 0x17d
300103f8:	f003 ff0c 	bl	30014214 <_panic>

300103fc <hal_timer_func_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_timer_func_irq_handle(void *arg)
{
    timer_instance_t *instance = (timer_instance_t *)arg;

    if (instance == NULL)
300103fc:	b120      	cbz	r0, 30010408 <hal_timer_func_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return timer_drv_func_irq_handle(instance->timer,
300103fe:	f100 0118 	add.w	r1, r0, #24
30010402:	6940      	ldr	r0, [r0, #20]
30010404:	f7fb bb84 	b.w	3000bb10 <timer_drv_func_irq_handle>
                                     &(instance->drv_context));
}
30010408:	4770      	bx	r14
3001040a:	bf00      	nop

3001040c <hal_timer_ovf_irq_handle>:
    if (instance == NULL)
3001040c:	b120      	cbz	r0, 30010418 <hal_timer_ovf_irq_handle+0xc>
    return timer_drv_ovf_irq_handle(instance->timer, &(instance->drv_context));
3001040e:	f100 0118 	add.w	r1, r0, #24
30010412:	6940      	ldr	r0, [r0, #20]
30010414:	f7fb bb4e 	b.w	3000bab4 <timer_drv_ovf_irq_handle>
}
30010418:	4770      	bx	r14
3001041a:	bf00      	nop

3001041c <hal_timer_creat_handle>:
{
3001041c:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
30010420:	f24c 553c 	movw	r5, #50492	; 0xc53c
{
30010424:	b082      	sub	sp, #8
30010426:	4606      	mov	r6, r0
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
30010428:	f2c3 0502 	movt	r5, #12290	; 0x3002
3001042c:	682b      	ldr	r3, [r5, #0]
3001042e:	b10b      	cbz	r3, 30010434 <hal_timer_creat_handle+0x18>
    *lock = SPIN_LOCK_INITIAL_VALUE;
30010430:	2300      	movs	r3, #0
30010432:	602b      	str	r3, [r5, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30010434:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30010438:	f013 0480 	ands.w	r4, r3, #128	; 0x80
3001043c:	d161      	bne.n	30010502 <hal_timer_creat_handle+0xe6>
    __asm__ volatile("cpsid i");
3001043e:	b672      	cpsid	i
    *lock = 1;
30010440:	2701      	movs	r7, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
30010442:	4608      	mov	r0, r1
30010444:	4669      	mov	r1, r13
30010446:	aa01      	add	r2, sp, #4
30010448:	602f      	str	r7, [r5, #0]
3001044a:	f7ff fbcf 	bl	3000fbec <res_get_info_by_id>
3001044e:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30010450:	bfa8      	it	ge
30010452:	46be      	movge	r14, r7
30010454:	db67      	blt.n	30010526 <hal_timer_creat_handle+0x10a>
30010456:	f24c 1c7c 	movw	r12, #49532	; 0xc17c
            if (!g_timer_instance[index].occupied
3001045a:	f04f 0800 	mov.w	r8, #0
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
3001045e:	9c00      	ldr	r4, [sp, #0]
30010460:	f2c3 0c02 	movt	r12, #12290	; 0x3002
30010464:	4667      	mov	r7, r12
            if (!g_timer_instance[index].occupied
30010466:	f2cf 0818 	movt	r8, #61464	; 0xf018
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
3001046a:	2000      	movs	r0, #0
            if (!g_timer_instance[index].occupied
3001046c:	783b      	ldrb	r3, [r7, #0]
3001046e:	bbbb      	cbnz	r3, 300104e0 <hal_timer_creat_handle+0xc4>
30010470:	4a30      	ldr	r2, [pc, #192]	; (30010534 <hal_timer_creat_handle+0x118>)
30010472:	4641      	mov	r1, r8
        if (timer_addr2irq_table[i].addr == addr) {
30010474:	428c      	cmp	r4, r1
30010476:	f102 020c 	add.w	r2, r2, #12
3001047a:	d007      	beq.n	3001048c <hal_timer_creat_handle+0x70>
    for (i = 0; i < DEFAULT_TIMER_MAX_NUM; i++) {
3001047c:	3301      	adds	r3, #1
3001047e:	2b08      	cmp	r3, #8
30010480:	d02e      	beq.n	300104e0 <hal_timer_creat_handle+0xc4>
30010482:	f852 1c0c 	ldr.w	r1, [r2, #-12]
30010486:	320c      	adds	r2, #12
        if (timer_addr2irq_table[i].addr == addr) {
30010488:	428c      	cmp	r4, r1
3001048a:	d1f7      	bne.n	3001047c <hal_timer_creat_handle+0x60>
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
3001048c:	f240 424c 	movw	r2, #1100	; 0x44c
30010490:	eb03 0343 	add.w	r3, r3, r3, lsl #1
                g_timer_instance[index].occupied = true;
30010494:	ea4f 1800 	mov.w	r8, r0, lsl #4
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
30010498:	f2c3 0202 	movt	r2, #12290	; 0x3002
                g_timer_instance[index].occupied = true;
3001049c:	eba8 0700 	sub.w	r7, r8, r0
300104a0:	f04f 0b01 	mov.w	r11, #1
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
300104a4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *lock = 0;
300104a8:	2200      	movs	r2, #0
                g_timer_instance[index].occupied = true;
300104aa:	00ff      	lsls	r7, r7, #3
300104ac:	eb0c 0907 	add.w	r9, r12, r7
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
300104b0:	6859      	ldr	r1, [r3, #4]
300104b2:	f8c9 1004 	str.w	r1, [r9, #4]
            *fun_irq_num = timer_addr2irq_table[i].fun_irq_num;
300104b6:	6899      	ldr	r1, [r3, #8]
                g_timer_instance[index].timer = (sdrv_timer_t *)(phy_addr);
300104b8:	f8c9 4014 	str.w	r4, [r9, #20]
                g_timer_instance[index].fun_irq_num = fun_irq_num;
300104bc:	f8c9 1008 	str.w	r1, [r9, #8]
                g_timer_instance[index].occupied = true;
300104c0:	f80c b007 	strb.w	r11, [r12, r7]
300104c4:	602a      	str	r2, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300104c6:	f1be 0f00 	cmp.w	r14, #0
300104ca:	d000      	beq.n	300104ce <hal_timer_creat_handle+0xb2>
    __asm__ volatile("cpsie i");
300104cc:	b662      	cpsie	i
                *instance = &g_timer_instance[index];
300104ce:	eba8 0300 	sub.w	r3, r8, r0
    return true;
300104d2:	2001      	movs	r0, #1
                *instance = &g_timer_instance[index];
300104d4:	eb0c 03c3 	add.w	r3, r12, r3, lsl #3
    *handle = instance;
300104d8:	6033      	str	r3, [r6, #0]
}
300104da:	b002      	add	sp, #8
300104dc:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
        for (index = 0; index < DEFAULT_TIMER_MAX_NUM; index++) {
300104e0:	3001      	adds	r0, #1
300104e2:	2808      	cmp	r0, #8
300104e4:	f107 0778 	add.w	r7, r7, #120	; 0x78
300104e8:	d1c0      	bne.n	3001046c <hal_timer_creat_handle+0x50>
    *lock = 0;
300104ea:	2300      	movs	r3, #0
300104ec:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300104ee:	f1be 0f00 	cmp.w	r14, #0
300104f2:	d000      	beq.n	300104f6 <hal_timer_creat_handle+0xda>
300104f4:	b662      	cpsie	i
        *handle = NULL;
300104f6:	2300      	movs	r3, #0
        return false;
300104f8:	4618      	mov	r0, r3
        *handle = NULL;
300104fa:	6033      	str	r3, [r6, #0]
}
300104fc:	b002      	add	sp, #8
300104fe:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
    *lock = 1;
30010502:	2301      	movs	r3, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
30010504:	4608      	mov	r0, r1
30010506:	4669      	mov	r1, r13
30010508:	aa01      	add	r2, sp, #4
3001050a:	602b      	str	r3, [r5, #0]
3001050c:	f7ff fb6e 	bl	3000fbec <res_get_info_by_id>
30010510:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
30010512:	bfa8      	it	ge
30010514:	f04f 0e00 	movge.w	r14, #0
30010518:	da9d      	bge.n	30010456 <hal_timer_creat_handle+0x3a>
    *lock = 0;
3001051a:	2300      	movs	r3, #0
3001051c:	602b      	str	r3, [r5, #0]
        *handle = NULL;
3001051e:	2300      	movs	r3, #0
        return false;
30010520:	4618      	mov	r0, r3
        *handle = NULL;
30010522:	6033      	str	r3, [r6, #0]
30010524:	e7ea      	b.n	300104fc <hal_timer_creat_handle+0xe0>
30010526:	602c      	str	r4, [r5, #0]
30010528:	b662      	cpsie	i
3001052a:	2300      	movs	r3, #0
        return false;
3001052c:	4618      	mov	r0, r3
        *handle = NULL;
3001052e:	6033      	str	r3, [r6, #0]
30010530:	e7e4      	b.n	300104fc <hal_timer_creat_handle+0xe0>
30010532:	bf00      	nop
30010534:	30020458 	.word	0x30020458

30010538 <hal_timer_global_init>:
{
30010538:	b570      	push	{r4, r5, r6, r14}
3001053a:	460c      	mov	r4, r1
3001053c:	4605      	mov	r5, r0
    sdrv_timer_t *timer = instance->timer;
3001053e:	6946      	ldr	r6, [r0, #20]
    timer_drv_clk_init(timer, cfg->clk_sel, cfg->clk_div);
30010540:	688a      	ldr	r2, [r1, #8]
30010542:	4630      	mov	r0, r6
30010544:	6809      	ldr	r1, [r1, #0]
30010546:	f7fb fa89 	bl	3000ba5c <timer_drv_clk_init>
    timer_drv_cascade_set(timer, cfg->cascade);
3001054a:	4630      	mov	r0, r6
3001054c:	7b21      	ldrb	r1, [r4, #12]
3001054e:	f7fb fa7b 	bl	3000ba48 <timer_drv_cascade_set>
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
30010552:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
30010556:	f644 51d3 	movw	r1, #19923	; 0x4dd3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
3001055a:	f64d 6083 	movw	r0, #56963	; 0xde83
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
3001055e:	3301      	adds	r3, #1
30010560:	f2c1 0162 	movt	r1, #4194	; 0x1062
30010564:	fbb2 f3f3 	udiv	r3, r2, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
30010568:	f2c4 301b 	movt	r0, #17179	; 0x431b
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
3001056c:	fba1 2103 	umull	r2, r1, r1, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
30010570:	fba0 2303 	umull	r2, r3, r0, r3
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
30010574:	0989      	lsrs	r1, r1, #6
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
30010576:	0c9b      	lsrs	r3, r3, #18
30010578:	e9c5 1303 	strd	r1, r3, [r5, #12]
}
3001057c:	bd70      	pop	{r4, r5, r6, r15}
3001057e:	bf00      	nop

30010580 <hal_timer_ovf_init>:
{
30010580:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
30010582:	4615      	mov	r5, r2
30010584:	460e      	mov	r6, r1
    sdrv_timer_t *timer = instance->timer;
30010586:	6947      	ldr	r7, [r0, #20]
{
30010588:	4604      	mov	r4, r0
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
3001058a:	6892      	ldr	r2, [r2, #8]
3001058c:	4638      	mov	r0, r7
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
3001058e:	4434      	add	r4, r6
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
30010590:	f7fb fa42 	bl	3000ba18 <timer_drv_ovf_set>
    timer_drv_cntr_set(timer, (timer_drv_sub_t)sub_cntr, cfg->cnt_val);
30010594:	4638      	mov	r0, r7
30010596:	4631      	mov	r1, r6
30010598:	686a      	ldr	r2, [r5, #4]
3001059a:	f7fb f9fd 	bl	3000b998 <timer_drv_cntr_set>
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
3001059e:	782b      	ldrb	r3, [r5, #0]
300105a0:	7623      	strb	r3, [r4, #24]
}
300105a2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

300105a4 <hal_timer_int_src_enable>:
    if (handle == NULL)
300105a4:	b158      	cbz	r0, 300105be <hal_timer_int_src_enable+0x1a>
{
300105a6:	b538      	push	{r3, r4, r5, r14}
300105a8:	4604      	mov	r4, r0
300105aa:	460d      	mov	r5, r1
    timer_drv_int_sta_enable(instance->timer, int_src);
300105ac:	6940      	ldr	r0, [r0, #20]
300105ae:	f7fb fa61 	bl	3000ba74 <timer_drv_int_sta_enable>
    timer_drv_int_sig_enable(instance->timer, int_src);
300105b2:	4629      	mov	r1, r5
300105b4:	6960      	ldr	r0, [r4, #20]
}
300105b6:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_enable(instance->timer, int_src);
300105ba:	f7fb ba6b 	b.w	3000ba94 <timer_drv_int_sig_enable>
300105be:	4770      	bx	r14

300105c0 <hal_timer_int_src_disable>:
    if (handle == NULL)
300105c0:	b158      	cbz	r0, 300105da <hal_timer_int_src_disable+0x1a>
{
300105c2:	b538      	push	{r3, r4, r5, r14}
300105c4:	4604      	mov	r4, r0
300105c6:	460d      	mov	r5, r1
    timer_drv_int_sta_disable(instance->timer, int_src);
300105c8:	6940      	ldr	r0, [r0, #20]
300105ca:	f7fb fa5b 	bl	3000ba84 <timer_drv_int_sta_disable>
    timer_drv_int_sig_disable(instance->timer, int_src);
300105ce:	4629      	mov	r1, r5
300105d0:	6960      	ldr	r0, [r4, #20]
}
300105d2:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_disable(instance->timer, int_src);
300105d6:	f7fb ba65 	b.w	3000baa4 <timer_drv_int_sig_disable>
300105da:	4770      	bx	r14

300105dc <hal_timer_int_cbk_register>:

void hal_timer_int_cbk_register(void *handle, hal_timer_int_src_t int_src,
                                hal_timer_int_cbk cbk)
{
    if (handle == NULL)
300105dc:	2800      	cmp	r0, #0
300105de:	d047      	beq.n	30010670 <hal_timer_int_cbk_register+0x94>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;

    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
            && (int_src <= HAL_TIMER_CNT_G1_OVF_INT_SRC)) {
300105e0:	f1a1 0308 	sub.w	r3, r1, #8
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
300105e4:	2b01      	cmp	r3, #1
{
300105e6:	b510      	push	{r4, r14}
300105e8:	4604      	mov	r4, r0
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
300105ea:	d917      	bls.n	3001061c <hal_timer_int_cbk_register+0x40>
                                 handle);
            unmask_interrupt(instance->ovf_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
             && (int_src <= HAL_TIMER_CNT_LD_OVF_INT_SRC)) {
300105ec:	f1a1 030a 	sub.w	r3, r1, #10
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
300105f0:	2b03      	cmp	r3, #3
300105f2:	d90d      	bls.n	30010610 <hal_timer_int_cbk_register+0x34>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CPT_A_INT_SRC)
300105f4:	2903      	cmp	r1, #3
300105f6:	d934      	bls.n	30010662 <hal_timer_int_cbk_register+0x86>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
             && (int_src <= HAL_TIMER_CMP_D_INT_SRC)) {
300105f8:	1f0b      	subs	r3, r1, #4
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
300105fa:	2b03      	cmp	r3, #3
300105fc:	d91f      	bls.n	3001063e <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_UNDERRUN_INT_SRC)) {
300105fe:	f1a1 0310 	sub.w	r3, r1, #16
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
30010602:	2b03      	cmp	r3, #3
30010604:	d91b      	bls.n	3001063e <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_OVERRUN_INT_SRC)) {
30010606:	f1a1 0314 	sub.w	r3, r1, #20
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
3001060a:	2b03      	cmp	r3, #3
3001060c:	d805      	bhi.n	3001061a <hal_timer_int_cbk_register+0x3e>
        instance->drv_context.local_overrun_cbk[int_src -
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
3001060e:	3102      	adds	r1, #2

        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
30010610:	68a0      	ldr	r0, [r4, #8]
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
30010612:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
30010616:	1c43      	adds	r3, r0, #1
30010618:	d117      	bne.n	3001064a <hal_timer_int_cbk_register+0x6e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
}
3001061a:	bd10      	pop	{r4, r15}
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
3001061c:	6840      	ldr	r0, [r0, #4]
                                                     HAL_TIMER_CNT_G0_OVF_INT_SRC] = cbk;
3001061e:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
30010622:	1c43      	adds	r3, r0, #1
30010624:	d0f9      	beq.n	3001061a <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->ovf_irq_num, hal_timer_ovf_irq_handle,
30010626:	f240 410d 	movw	r1, #1037	; 0x40d
3001062a:	4622      	mov	r2, r4
3001062c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010630:	f7f0 f83e 	bl	300006b0 <register_int_handler>
            unmask_interrupt(instance->ovf_irq_num);
30010634:	6860      	ldr	r0, [r4, #4]
}
30010636:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->ovf_irq_num);
3001063a:	f7f0 b88b 	b.w	30000754 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
3001063e:	68a0      	ldr	r0, [r4, #8]
                        HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC] = cbk;
30010640:	310a      	adds	r1, #10
30010642:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
30010646:	1c42      	adds	r2, r0, #1
30010648:	d0e7      	beq.n	3001061a <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
3001064a:	f240 31fd 	movw	r1, #1021	; 0x3fd
3001064e:	4622      	mov	r2, r4
30010650:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010654:	f7f0 f82c 	bl	300006b0 <register_int_handler>
            unmask_interrupt(instance->fun_irq_num);
30010658:	68a0      	ldr	r0, [r4, #8]
}
3001065a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->fun_irq_num);
3001065e:	f7f0 b879 	b.w	30000754 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
30010662:	6880      	ldr	r0, [r0, #8]
        instance->drv_context.local_cpt_cbk[int_src - HAL_TIMER_CPT_A_INT_SRC] =
30010664:	3112      	adds	r1, #18
30010666:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
3001066a:	1c41      	adds	r1, r0, #1
3001066c:	d1ed      	bne.n	3001064a <hal_timer_int_cbk_register+0x6e>
}
3001066e:	bd10      	pop	{r4, r15}
30010670:	4770      	bx	r14
30010672:	bf00      	nop

30010674 <hal_timer_int_sta_clear>:
 ** \param [in]    handle    Pointer to the hanld create
 ** \param [in]    offset    Offset of the interrupt status flag
 *****************************************************************************/
void hal_timer_int_sta_clear(void *handle, hal_timer_int_src_t int_src)
{
    if (handle == NULL)
30010674:	b110      	cbz	r0, 3001067c <hal_timer_int_sta_clear+0x8>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;
    timer_drv_int_sta_clear(instance->timer, int_src);
30010676:	6940      	ldr	r0, [r0, #20]
30010678:	f7fb bb5a 	b.w	3000bd30 <timer_drv_int_sta_clear>
}
3001067c:	4770      	bx	r14
3001067e:	bf00      	nop

30010680 <hal_timer_glb_cntr_get>:
{
    uint32_t g0_val, g1_val, g0_new;
    spin_lock_saved_state_t state;
    timer_instance_t *instance = (timer_instance_t *)handle;

    if (handle == NULL)
30010680:	b318      	cbz	r0, 300106ca <hal_timer_glb_cntr_get+0x4a>
{
30010682:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30010684:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30010688:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
3001068a:	bf48      	it	mi
3001068c:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3001068e:	d519      	bpl.n	300106c4 <hal_timer_glb_cntr_get+0x44>
30010690:	4604      	mov	r4, r0
        return 0;

    arch_interrupt_save(&state, SPIN_LOCK_FLAG_INTERRUPTS);

    g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
30010692:	2100      	movs	r1, #0
30010694:	6940      	ldr	r0, [r0, #20]
30010696:	f7fb f9a7 	bl	3000b9e8 <timer_drv_cntr_get>
3001069a:	4605      	mov	r5, r0
3001069c:	e000      	b.n	300106a0 <hal_timer_glb_cntr_get+0x20>
3001069e:	4605      	mov	r5, r0
    do {
        g0_val = g0_new;
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
300106a0:	6960      	ldr	r0, [r4, #20]
300106a2:	2101      	movs	r1, #1
300106a4:	f7fb f9a0 	bl	3000b9e8 <timer_drv_cntr_get>
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
300106a8:	2100      	movs	r1, #0
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
300106aa:	4606      	mov	r6, r0
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
300106ac:	6960      	ldr	r0, [r4, #20]
300106ae:	f7fb f99b 	bl	3000b9e8 <timer_drv_cntr_get>
    } while (g0_val > g0_new);
300106b2:	4285      	cmp	r5, r0
300106b4:	d8f3      	bhi.n	3001069e <hal_timer_glb_cntr_get+0x1e>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300106b6:	b107      	cbz	r7, 300106ba <hal_timer_glb_cntr_get+0x3a>
    __asm__ volatile("cpsie i");
300106b8:	b662      	cpsie	i

    arch_interrupt_restore(state, SPIN_LOCK_FLAG_INTERRUPTS);

    return ((uint64_t)g0_val | (((uint64_t)g1_val) << 32U));
300106ba:	2300      	movs	r3, #0
300106bc:	4631      	mov	r1, r6
300106be:	ea43 0005 	orr.w	r0, r3, r5
}
300106c2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
300106c4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
300106c6:	2701      	movs	r7, #1
300106c8:	e7e2      	b.n	30010690 <hal_timer_glb_cntr_get+0x10>
        return 0;
300106ca:	2000      	movs	r0, #0
300106cc:	2100      	movs	r1, #0
}
300106ce:	4770      	bx	r14

300106d0 <hal_uart_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_uart_irq_handle(void *arg)
{
    uart_instance_t *instance = (uart_instance_t *)arg;

    if (instance == NULL)
300106d0:	b120      	cbz	r0, 300106dc <hal_uart_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return uart_drv_irq_handle(instance->uartc, &(instance->drv_context));
300106d2:	f100 0110 	add.w	r1, r0, #16
300106d6:	68c0      	ldr	r0, [r0, #12]
300106d8:	f7fb bc7e 	b.w	3000bfd8 <uart_drv_irq_handle>
}
300106dc:	4770      	bx	r14
300106de:	bf00      	nop

300106e0 <hal_uart_creat_handle>:
{
300106e0:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
300106e4:	4605      	mov	r5, r0
300106e6:	b083      	sub	sp, #12
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300106e8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300106ec:	f013 0480 	ands.w	r4, r3, #128	; 0x80
300106f0:	d16a      	bne.n	300107c8 <hal_uart_creat_handle+0xe8>
    __asm__ volatile("cpsid i");
300106f2:	b672      	cpsid	i
    *lock = 1;
300106f4:	f64c 0780 	movw	r7, #51328	; 0xc880
300106f8:	2601      	movs	r6, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
300106fa:	4608      	mov	r0, r1
300106fc:	f2c3 0702 	movt	r7, #12290	; 0x3002
30010700:	4669      	mov	r1, r13
30010702:	aa01      	add	r2, sp, #4
30010704:	603e      	str	r6, [r7, #0]
30010706:	f7ff fa71 	bl	3000fbec <res_get_info_by_id>
3001070a:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
3001070c:	bfa8      	it	ge
3001070e:	46b0      	movge	r8, r6
30010710:	db6d      	blt.n	300107ee <hal_uart_creat_handle+0x10e>
30010712:	f24c 5e40 	movw	r14, #50496	; 0xc540
            if (!g_uart_instance[index].occupied
30010716:	f04f 0900 	mov.w	r9, #0
3001071a:	f240 40ac 	movw	r0, #1196	; 0x4ac
3001071e:	f2c3 0e02 	movt	r14, #12290	; 0x3002
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
30010722:	9e00      	ldr	r6, [sp, #0]
30010724:	4674      	mov	r4, r14
            if (!g_uart_instance[index].occupied
30010726:	f2cf 090f 	movt	r9, #61455	; 0xf00f
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
3001072a:	f04f 0c00 	mov.w	r12, #0
3001072e:	f2c3 0002 	movt	r0, #12290	; 0x3002
            if (!g_uart_instance[index].occupied
30010732:	7822      	ldrb	r2, [r4, #0]
30010734:	bbaa      	cbnz	r2, 300107a2 <hal_uart_creat_handle+0xc2>
30010736:	4649      	mov	r1, r9
30010738:	e004      	b.n	30010744 <hal_uart_creat_handle+0x64>
3001073a:	461a      	mov	r2, r3
    for (i = 0; i < DEFAULT_UART_MAX_NUM; i++) {
3001073c:	2b10      	cmp	r3, #16
3001073e:	d030      	beq.n	300107a2 <hal_uart_creat_handle+0xc2>
30010740:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
        if (uart_addr2irq_table[i].addr == addr) {
30010744:	428e      	cmp	r6, r1
30010746:	f102 0301 	add.w	r3, r2, #1
3001074a:	d1f6      	bne.n	3001073a <hal_uart_creat_handle+0x5a>
            *irq_num = uart_addr2irq_table[i].irq_num;
3001074c:	f240 49ac 	movw	r9, #1196	; 0x4ac
                g_uart_instance[index].occupied = true;
30010750:	ea4f 004c 	mov.w	r0, r12, lsl #1
30010754:	eb00 010c 	add.w	r1, r0, r12
30010758:	2401      	movs	r4, #1
            *irq_num = uart_addr2irq_table[i].irq_num;
3001075a:	f2c3 0902 	movt	r9, #12290	; 0x3002
                g_uart_instance[index].occupied = true;
3001075e:	eb0c 0181 	add.w	r1, r12, r1, lsl #2
            *phy_num = i + 1;
30010762:	9301      	str	r3, [sp, #4]
            *irq_num = uart_addr2irq_table[i].irq_num;
30010764:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
                g_uart_instance[index].occupied = true;
30010768:	0089      	lsls	r1, r1, #2
3001076a:	eb0e 0901 	add.w	r9, r14, r1
            *irq_num = uart_addr2irq_table[i].irq_num;
3001076e:	6852      	ldr	r2, [r2, #4]
30010770:	f8c9 2008 	str.w	r2, [r9, #8]
    *lock = 0;
30010774:	2200      	movs	r2, #0
                g_uart_instance[index].occupied = true;
30010776:	f80e 4001 	strb.w	r4, [r14, r1]
                g_uart_instance[index].uartc = (DW_APB_UART_uart_TypeDef *)(phy_addr);
3001077a:	f8c9 600c 	str.w	r6, [r9, #12]
                g_uart_instance[index].phy_num = phy_num;
3001077e:	f8c9 3004 	str.w	r3, [r9, #4]
30010782:	603a      	str	r2, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30010784:	f1b8 0f00 	cmp.w	r8, #0
30010788:	d000      	beq.n	3001078c <hal_uart_creat_handle+0xac>
    __asm__ volatile("cpsie i");
3001078a:	b662      	cpsie	i
                *instance = &g_uart_instance[index];
3001078c:	eb00 030c 	add.w	r3, r0, r12
    return true;
30010790:	2001      	movs	r0, #1
                *instance = &g_uart_instance[index];
30010792:	eb0c 0383 	add.w	r3, r12, r3, lsl #2
30010796:	eb0e 0383 	add.w	r3, r14, r3, lsl #2
    *handle = instance;
3001079a:	602b      	str	r3, [r5, #0]
}
3001079c:	b003      	add	sp, #12
3001079e:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        for (index = 0; index < DEFAULT_UART_MAX_NUM; index++) {
300107a2:	f10c 0c01 	add.w	r12, r12, #1
300107a6:	f1bc 0f10 	cmp.w	r12, #16
300107aa:	f104 0434 	add.w	r4, r4, #52	; 0x34
300107ae:	d1c0      	bne.n	30010732 <hal_uart_creat_handle+0x52>
    *lock = 0;
300107b0:	2300      	movs	r3, #0
300107b2:	603b      	str	r3, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300107b4:	f1b8 0f00 	cmp.w	r8, #0
300107b8:	d000      	beq.n	300107bc <hal_uart_creat_handle+0xdc>
300107ba:	b662      	cpsie	i
        *handle = NULL;
300107bc:	2300      	movs	r3, #0
        return false;
300107be:	4618      	mov	r0, r3
        *handle = NULL;
300107c0:	602b      	str	r3, [r5, #0]
}
300107c2:	b003      	add	sp, #12
300107c4:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    *lock = 1;
300107c8:	f64c 0780 	movw	r7, #51328	; 0xc880
300107cc:	2301      	movs	r3, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
300107ce:	4608      	mov	r0, r1
300107d0:	f2c3 0702 	movt	r7, #12290	; 0x3002
300107d4:	4669      	mov	r1, r13
300107d6:	aa01      	add	r2, sp, #4
300107d8:	603b      	str	r3, [r7, #0]
300107da:	f7ff fa07 	bl	3000fbec <res_get_info_by_id>
300107de:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
300107e0:	bfa8      	it	ge
300107e2:	f04f 0800 	movge.w	r8, #0
300107e6:	da94      	bge.n	30010712 <hal_uart_creat_handle+0x32>
    *lock = 0;
300107e8:	2300      	movs	r3, #0
300107ea:	603b      	str	r3, [r7, #0]
300107ec:	e7e6      	b.n	300107bc <hal_uart_creat_handle+0xdc>
300107ee:	603c      	str	r4, [r7, #0]
300107f0:	b662      	cpsie	i
300107f2:	e7e3      	b.n	300107bc <hal_uart_creat_handle+0xdc>

300107f4 <hal_uart_init>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   cfg         pointer of the hal confuration
 *****************************************************************************/
void hal_uart_init(void *handle, hal_uart_cfg_t *cfg)
{
    if (handle == NULL)
300107f4:	b1f0      	cbz	r0, 30010834 <hal_uart_init+0x40>
{
300107f6:	b530      	push	{r4, r5, r14}
300107f8:	b08b      	sub	sp, #44	; 0x2c
    if ((hal_cfg == NULL) || (drv_cfg == NULL))
300107fa:	b199      	cbz	r1, 30010824 <hal_uart_init+0x30>
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
300107fc:	680d      	ldr	r5, [r1, #0]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
300107fe:	7d0a      	ldrb	r2, [r1, #20]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
30010800:	684c      	ldr	r4, [r1, #4]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
30010802:	7e0b      	ldrb	r3, [r1, #24]
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
30010804:	9501      	str	r5, [sp, #4]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
30010806:	9402      	str	r4, [sp, #8]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
30010808:	688d      	ldr	r5, [r1, #8]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
3001080a:	68cc      	ldr	r4, [r1, #12]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
3001080c:	9503      	str	r5, [sp, #12]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
3001080e:	9404      	str	r4, [sp, #16]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
30010810:	690d      	ldr	r5, [r1, #16]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
30010812:	e9d1 4107 	ldrd	r4, r1, [r1, #28]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
30010816:	9505      	str	r5, [sp, #20]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
30010818:	e9cd 4108 	strd	r4, r1, [r13, #32]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
3001081c:	f88d 2018 	strb.w	r2, [r13, #24]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
30010820:	f88d 301c 	strb.w	r3, [r13, #28]
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_cfg_t drv_cfg;
    hal_uart_cfg_copy_to_drv(cfg, &drv_cfg);
    uart_drv_init(instance->uartc, &(instance->drv_context), &drv_cfg);
30010824:	f100 0110 	add.w	r1, r0, #16
30010828:	68c0      	ldr	r0, [r0, #12]
3001082a:	aa01      	add	r2, sp, #4
3001082c:	f7fb fa88 	bl	3000bd40 <uart_drv_init>
}
30010830:	b00b      	add	sp, #44	; 0x2c
30010832:	bd30      	pop	{r4, r5, r15}
30010834:	4770      	bx	r14
30010836:	bf00      	nop

30010838 <hal_uart_putc>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   data        Character to put
 *****************************************************************************/
void hal_uart_putc(void *handle, char data)
{
    if (handle == NULL)
30010838:	b128      	cbz	r0, 30010846 <hal_uart_putc+0xe>
        uart_drv_rs485_driver_set(instance->uartc, true);
        uart_drv_rs485_receiver_set(instance->uartc, false);
    }

#endif
    uart_drv_putc(instance->uartc, &(instance->drv_context), data);
3001083a:	460a      	mov	r2, r1
3001083c:	f100 0110 	add.w	r1, r0, #16
30010840:	68c0      	ldr	r0, [r0, #12]
30010842:	f7fb bb8b 	b.w	3000bf5c <uart_drv_putc>
        uart_drv_rs485_driver_set(instance->uartc, false);
        uart_drv_rs485_receiver_set(instance->uartc, true);
    }

#endif
}
30010846:	4770      	bx	r14

30010848 <hal_uart_int_cbk_register>:
 ** \param [in]   cbk
 *****************************************************************************/
void hal_uart_int_cbk_register(void *handle, hal_uart_int_src_t int_src,
                               hal_uart_int_callback cbk)
{
    if (handle == NULL)
30010848:	b1a0      	cbz	r0, 30010874 <hal_uart_int_cbk_register+0x2c>
{
3001084a:	b510      	push	{r4, r14}
3001084c:	4604      	mov	r4, r0
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_int_cbk_register(&(instance->drv_context), int_src, cbk);
3001084e:	3010      	adds	r0, #16
30010850:	f7fb fb92 	bl	3000bf78 <uart_drv_int_cbk_register>

    if (instance->irq_num != UART_HAL_INVALID_IRQ_NUM) {
30010854:	68a0      	ldr	r0, [r4, #8]
30010856:	1c43      	adds	r3, r0, #1
30010858:	d00b      	beq.n	30010872 <hal_uart_int_cbk_register+0x2a>
        register_int_handler(instance->irq_num, hal_uart_irq_handle, handle);
3001085a:	f240 61d1 	movw	r1, #1745	; 0x6d1
3001085e:	4622      	mov	r2, r4
30010860:	f2c3 0101 	movt	r1, #12289	; 0x3001
30010864:	f7ef ff24 	bl	300006b0 <register_int_handler>
        unmask_interrupt(instance->irq_num);
30010868:	68a0      	ldr	r0, [r4, #8]
    }
}
3001086a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        unmask_interrupt(instance->irq_num);
3001086e:	f7ef bf71 	b.w	30000754 <unmask_interrupt>
}
30010872:	bd10      	pop	{r4, r15}
30010874:	4770      	bx	r14
30010876:	bf00      	nop

30010878 <hal_uart_int_src_enable>:
    unmask_interrupt(instance->irq_num);
}

void hal_uart_int_src_enable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
30010878:	b108      	cbz	r0, 3001087e <hal_uart_int_src_enable+0x6>
        return;

    uart_drv_int_src_enable(handle, int_src);
3001087a:	f7fb bb89 	b.w	3000bf90 <uart_drv_int_src_enable>
}
3001087e:	4770      	bx	r14

30010880 <hal_uart_int_src_disable>:

void hal_uart_int_src_disable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
30010880:	b108      	cbz	r0, 30010886 <hal_uart_int_src_disable+0x6>
        return;

    uart_drv_int_src_disable(handle, int_src);
30010882:	f7fb bb95 	b.w	3000bfb0 <uart_drv_int_src_disable>
}
30010886:	4770      	bx	r14

30010888 <hal_usb_append_interface>:

/* returns the interface number assigned */
static int hal_usb_append_interface(hal_usb_descriptor *desc,
                                    const uint8_t *int_descr, size_t len)
{
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(len, CACHE_LINE));
30010888:	f102 031f 	add.w	r3, r2, #31
{
3001088c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30010890:	4604      	mov	r4, r0
30010892:	460e      	mov	r6, r1
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(len, CACHE_LINE));
30010894:	2020      	movs	r0, #32
30010896:	f023 011f 	bic.w	r1, r3, #31
{
3001089a:	4615      	mov	r5, r2
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(len, CACHE_LINE));
3001089c:	f003 ff3a 	bl	30014714 <memalign>
    int interface_num;
    // create a temporary copy of the interface
    memcpy(ptr, int_descr, len);
300108a0:	4631      	mov	r1, r6
300108a2:	462a      	mov	r2, r5
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(len, CACHE_LINE));
300108a4:	4607      	mov	r7, r0
    memcpy(ptr, int_descr, len);
300108a6:	f003 efde 	blx	30014864 <memcpy>
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(desc->len + len, CACHE_LINE));
300108aa:	6861      	ldr	r1, [r4, #4]
300108ac:	2020      	movs	r0, #32
    return ((uint8_t *)desc->desc)[4];
300108ae:	6823      	ldr	r3, [r4, #0]
300108b0:	791e      	ldrb	r6, [r3, #4]
    // find the last interface used
    interface_num = hal_usb_get_current_iface_num(desc);  // current interface
    // patch our interface descriptor with the new id
    ptr[2] = interface_num;
300108b2:	70be      	strb	r6, [r7, #2]
    uint8_t *ptr = memalign(CACHE_LINE, ROUNDUP(desc->len + len, CACHE_LINE));
300108b4:	311f      	adds	r1, #31
300108b6:	4429      	add	r1, r5
300108b8:	f021 011f 	bic.w	r1, r1, #31
300108bc:	f003 ff2a 	bl	30014714 <memalign>
    if (ptr == NULL) {
300108c0:	4680      	mov	r8, r0
300108c2:	b300      	cbz	r0, 30010906 <hal_usb_append_interface+0x7e>
    memcpy(ptr, desc->desc, desc->len);
300108c4:	6862      	ldr	r2, [r4, #4]
300108c6:	6821      	ldr	r1, [r4, #0]
300108c8:	f003 efcc 	blx	30014864 <memcpy>
    memcpy(ptr + desc->len, dat, len);
300108cc:	6860      	ldr	r0, [r4, #4]
300108ce:	462a      	mov	r2, r5
300108d0:	4639      	mov	r1, r7
300108d2:	4440      	add	r0, r8
300108d4:	f003 efc6 	blx	30014864 <memcpy>
    if ((desc->flags & USB_DESC_FLAG_STATIC) == 0) {
300108d8:	68a3      	ldr	r3, [r4, #8]
300108da:	07da      	lsls	r2, r3, #31
300108dc:	d516      	bpl.n	3001090c <hal_usb_append_interface+0x84>
    desc->len += len;
300108de:	6862      	ldr	r2, [r4, #4]
    desc->flags &= ~USB_DESC_FLAG_STATIC;
300108e0:	f023 0301 	bic.w	r3, r3, #1
    desc->desc = ptr;
300108e4:	f8c4 8000 	str.w	r8, [r4]
    desc->flags &= ~USB_DESC_FLAG_STATIC;
300108e8:	60a3      	str	r3, [r4, #8]
    desc->len += len;
300108ea:	442a      	add	r2, r5
300108ec:	6062      	str	r2, [r4, #4]
    // append it to our config descriptor
    hal_append_desc_data(desc, ptr, len);
    free(ptr);
300108ee:	4638      	mov	r0, r7
300108f0:	f003 ff4c 	bl	3001478c <free>
    // patch the total length of the config descriptor and set the number of interfaces
    ((uint16_t *)desc->desc)[1] += len;
300108f4:	6823      	ldr	r3, [r4, #0]
300108f6:	885a      	ldrh	r2, [r3, #2]
    interface_num++;
    ((uint8_t *)desc->desc)[4] = interface_num;
300108f8:	1c71      	adds	r1, r6, #1
    return interface_num - 1;
}
300108fa:	4630      	mov	r0, r6
    ((uint16_t *)desc->desc)[1] += len;
300108fc:	4415      	add	r5, r2
    ((uint8_t *)desc->desc)[4] = interface_num;
300108fe:	7119      	strb	r1, [r3, #4]
    ((uint16_t *)desc->desc)[1] += len;
30010900:	805d      	strh	r5, [r3, #2]
}
30010902:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        desc->desc = NULL;
30010906:	8020      	strh	r0, [r4, #0]
30010908:	8060      	strh	r0, [r4, #2]
3001090a:	e7f0      	b.n	300108ee <hal_usb_append_interface+0x66>
        free(desc->desc);
3001090c:	6820      	ldr	r0, [r4, #0]
3001090e:	f003 ff3d 	bl	3001478c <free>
30010912:	68a3      	ldr	r3, [r4, #8]
30010914:	e7e3      	b.n	300108de <hal_usb_append_interface+0x56>
30010916:	bf00      	nop

30010918 <hal_usb_append_interface_highspeed>:

int hal_usb_append_interface_highspeed(usb_t *usb,
                                       const uint8_t *int_descr, size_t len)
{
    return hal_usb_append_interface(&usb->config->highspeed.config, int_descr,
30010918:	68c0      	ldr	r0, [r0, #12]
3001091a:	303c      	adds	r0, #60	; 0x3c
3001091c:	f7ff bfb4 	b.w	30010888 <hal_usb_append_interface>

30010920 <hal_usb_append_interface_lowspeed>:
}

int hal_usb_append_interface_lowspeed(usb_t *usb, const uint8_t *int_descr,
                                      size_t len)
{
    return hal_usb_append_interface(&usb->config->lowspeed.config, int_descr,
30010920:	68c0      	ldr	r0, [r0, #12]
30010922:	3018      	adds	r0, #24
30010924:	f7ff bfb0 	b.w	30010888 <hal_usb_append_interface>

30010928 <hal_set_usb_id>:
    desc->len = datalen;
}

void hal_set_usb_id(usb_t *usb, uint16_t vendor, uint16_t product,
                    uint16_t version)
{
30010928:	b410      	push	{r4}
    // patch the current configuration to with the vendor/product id
    ((uint16_t *)usb->config->lowspeed.device.desc)[4] = vendor;
3001092a:	68c4      	ldr	r4, [r0, #12]
3001092c:	6820      	ldr	r0, [r4, #0]
3001092e:	8101      	strh	r1, [r0, #8]
    ((uint16_t *)usb->config->lowspeed.device.desc)[5] = product;
30010930:	8142      	strh	r2, [r0, #10]
    ((uint16_t *)usb->config->lowspeed.device.desc)[6] = version;
30010932:	8183      	strh	r3, [r0, #12]
    ((uint16_t *)usb->config->highspeed.device.desc)[4] = vendor;
30010934:	6a60      	ldr	r0, [r4, #36]	; 0x24
30010936:	8101      	strh	r1, [r0, #8]
    ((uint16_t *)usb->config->highspeed.device.desc)[5] = product;
30010938:	8142      	strh	r2, [r0, #10]
    ((uint16_t *)usb->config->highspeed.device.desc)[6] = version;
3001093a:	8183      	strh	r3, [r0, #12]
}
3001093c:	f85d 4b04 	ldr.w	r4, [r13], #4
30010940:	4770      	bx	r14
30010942:	bf00      	nop

30010944 <hal_usb_add_string>:

status_t hal_usb_add_string(usb_t *usb, const char *string, uint8_t id)
{
30010944:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30010948:	4606      	mov	r6, r0
    uint i;
    size_t len = strlen(string);
3001094a:	4608      	mov	r0, r1
{
3001094c:	460c      	mov	r4, r1
3001094e:	4615      	mov	r5, r2
    size_t len = strlen(string);
30010950:	f005 f9ee 	bl	30015d30 <strlen>
30010954:	4680      	mov	r8, r0
    uint16_t *strbuf = memalign(CACHE_LINE, ROUNDUP(len * 2 + 2, CACHE_LINE));
30010956:	1c47      	adds	r7, r0, #1
30010958:	2020      	movs	r0, #32
3001095a:	007f      	lsls	r7, r7, #1
3001095c:	f107 011f 	add.w	r1, r7, #31
30010960:	f021 011f 	bic.w	r1, r1, #31
30010964:	f003 fed6 	bl	30014714 <memalign>

    if (!strbuf) {
30010968:	b350      	cbz	r0, 300109c0 <hal_usb_add_string+0x7c>
        return ERR_NO_MEMORY;
    }

    /* build the usb string descriptor */
    strbuf[0] = 0x300 | (len * 2 + 2);
3001096a:	f447 7340 	orr.w	r3, r7, #768	; 0x300
3001096e:	8003      	strh	r3, [r0, #0]

    for (i = 0; i < len; i++) {
30010970:	f1b8 0f00 	cmp.w	r8, #0
30010974:	d009      	beq.n	3001098a <hal_usb_add_string+0x46>
30010976:	4603      	mov	r3, r0
30010978:	1e61      	subs	r1, r4, #1
3001097a:	eb01 0408 	add.w	r4, r1, r8
        strbuf[i + 1] = (uint16_t)string[i];
3001097e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
30010982:	f823 2f02 	strh.w	r2, [r3, #2]!
    for (i = 0; i < len; i++) {
30010986:	42a1      	cmp	r1, r4
30010988:	d1f9      	bne.n	3001097e <hal_usb_add_string+0x3a>
3001098a:	4632      	mov	r2, r6
    }

    /* find a slot to put it */
    for (i = 0; i < MAX_STRINGS; i++) {
3001098c:	2300      	movs	r3, #0
        if (usb->strings[i].id == 0) {
3001098e:	f892 1024 	ldrb.w	r1, [r2, #36]	; 0x24
30010992:	320e      	adds	r2, #14
30010994:	b149      	cbz	r1, 300109aa <hal_usb_add_string+0x66>
    for (i = 0; i < MAX_STRINGS; i++) {
30010996:	3301      	adds	r3, #1
30010998:	2b08      	cmp	r3, #8
3001099a:	d1f8      	bne.n	3001098e <hal_usb_add_string+0x4a>
            return NO_ERROR;
        }
    }

    /* couldn't find a spot */
    free(strbuf);
3001099c:	f003 fef6 	bl	3001478c <free>
    return ERR_NO_MEMORY;
300109a0:	f06f 0104 	mvn.w	r1, #4
}
300109a4:	4608      	mov	r0, r1
300109a6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            usb->strings[i].string.desc = strbuf;
300109aa:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
300109ae:	eb06 0343 	add.w	r3, r6, r3, lsl #1
300109b2:	6198      	str	r0, [r3, #24]
}
300109b4:	4608      	mov	r0, r1
            usb->strings[i].string.len = len * 2 + 2;
300109b6:	61df      	str	r7, [r3, #28]
            usb->strings[i].id = id;
300109b8:	f883 5024 	strb.w	r5, [r3, #36]	; 0x24
}
300109bc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return ERR_NO_MEMORY;
300109c0:	f06f 0104 	mvn.w	r1, #4
300109c4:	e7ee      	b.n	300109a4 <hal_usb_add_string+0x60>
300109c6:	bf00      	nop

300109c8 <hal_usb_register_callback>:
    }
}

status_t hal_usb_register_callback(usb_t *usb, usb_callback_t cb,
                                   void *cookie)
{
300109c8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
300109ca:	4605      	mov	r5, r0
    DEBUG_ASSERT(cb);
    usb_callback_container_t *c = malloc(sizeof(usb_callback_container_t));
300109cc:	2010      	movs	r0, #16
{
300109ce:	460f      	mov	r7, r1
300109d0:	4616      	mov	r6, r2
    usb_callback_container_t *c = malloc(sizeof(usb_callback_container_t));
300109d2:	f003 fe89 	bl	300146e8 <malloc>

    if (!c) {
300109d6:	b158      	cbz	r0, 300109f0 <hal_usb_register_callback+0x28>

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
    item->prev = list->prev;
300109d8:	462c      	mov	r4, r5
300109da:	4603      	mov	r3, r0
    }

    c->cb = cb;
    c->cookie = cookie;
    list_add_tail(&usb->cb_list, &c->node);
    return NO_ERROR;
300109dc:	2000      	movs	r0, #0
    c->cookie = cookie;
300109de:	e9c3 7602 	strd	r7, r6, [r3, #8]
300109e2:	f854 2f10 	ldr.w	r2, [r4, #16]!
    item->next = list;
300109e6:	e9c3 2400 	strd	r2, r4, [r3]
    list->prev->next = item;
300109ea:	6053      	str	r3, [r2, #4]
    list->prev = item;
300109ec:	612b      	str	r3, [r5, #16]
}
300109ee:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return ERR_NO_MEMORY;
300109f0:	f06f 0004 	mvn.w	r0, #4
}
300109f4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
300109f6:	bf00      	nop

300109f8 <hal_usbc_callback>:
{
    LTRACEF("op %d, args %p\n", op, args);
    usb_t *usb = args->usb;

    /* start looking for specific things to handle */
    if (op == USB_CB_SETUP_MSG) {
300109f8:	2806      	cmp	r0, #6
{
300109fa:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
300109fe:	460d      	mov	r5, r1
30010a00:	b082      	sub	sp, #8
    usb_t *usb = args->usb;
30010a02:	684e      	ldr	r6, [r1, #4]
    if (op == USB_CB_SETUP_MSG) {
30010a04:	d032      	beq.n	30010a6c <hal_usbc_callback+0x74>
30010a06:	4680      	mov	r8, r0
30010a08:	f106 0710 	add.w	r7, r6, #16
30010a0c:	6974      	ldr	r4, [r6, #20]

        if (!setup_handled) {
            hal_usb_do_callbacks(op, args);
        }
    }
    else if (op == USB_CB_RESET) {
30010a0e:	b9f8      	cbnz	r0, 30010a50 <hal_usbc_callback+0x58>
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a10:	42a7      	cmp	r7, r4
        LTRACEF("USB_CB_RESET\n");
        hal_usb_do_callbacks(op, args);
        usb->active_config = 0;
30010a12:	bf08      	it	eq
30010a14:	7270      	strbeq	r0, [r6, #9]
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a16:	d017      	beq.n	30010a48 <hal_usbc_callback+0x50>
        c->cb(c->cookie, op, args);
30010a18:	68a3      	ldr	r3, [r4, #8]
30010a1a:	462a      	mov	r2, r5
30010a1c:	68e0      	ldr	r0, [r4, #12]
30010a1e:	2100      	movs	r1, #0
30010a20:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a22:	6864      	ldr	r4, [r4, #4]
30010a24:	42bc      	cmp	r4, r7
30010a26:	d1f7      	bne.n	30010a18 <hal_usbc_callback+0x20>
30010a28:	686b      	ldr	r3, [r5, #4]
        usb->active_config = 0;
30010a2a:	2200      	movs	r2, #0
30010a2c:	f103 0710 	add.w	r7, r3, #16
30010a30:	695c      	ldr	r4, [r3, #20]
30010a32:	7272      	strb	r2, [r6, #9]
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a34:	42a7      	cmp	r7, r4
30010a36:	d007      	beq.n	30010a48 <hal_usbc_callback+0x50>
        c->cb(c->cookie, op, args);
30010a38:	68a3      	ldr	r3, [r4, #8]
30010a3a:	462a      	mov	r2, r5
30010a3c:	68e0      	ldr	r0, [r4, #12]
30010a3e:	2105      	movs	r1, #5
30010a40:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a42:	6864      	ldr	r4, [r4, #4]
30010a44:	42bc      	cmp	r4, r7
30010a46:	d1f7      	bne.n	30010a38 <hal_usbc_callback+0x40>
        // other non setup messages, pass them down to anyone else
        hal_usb_do_callbacks(op, args);
    }

    return NO_ERROR;
}
30010a48:	2000      	movs	r0, #0
30010a4a:	b002      	add	sp, #8
30010a4c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a50:	42a7      	cmp	r7, r4
30010a52:	d0f9      	beq.n	30010a48 <hal_usbc_callback+0x50>
        c->cb(c->cookie, op, args);
30010a54:	68a3      	ldr	r3, [r4, #8]
30010a56:	462a      	mov	r2, r5
30010a58:	68e0      	ldr	r0, [r4, #12]
30010a5a:	4641      	mov	r1, r8
30010a5c:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a5e:	6864      	ldr	r4, [r4, #4]
30010a60:	42bc      	cmp	r4, r7
30010a62:	d1f7      	bne.n	30010a54 <hal_usbc_callback+0x5c>
}
30010a64:	2000      	movs	r0, #0
30010a66:	b002      	add	sp, #8
30010a68:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        const struct usb_setup *setup = args->setup;
30010a6c:	680c      	ldr	r4, [r1, #0]
        if ((setup->request_type & TYPE_MASK) == TYPE_STANDARD) {
30010a6e:	7823      	ldrb	r3, [r4, #0]
30010a70:	f013 0f60 	tst.w	r3, #96	; 0x60
30010a74:	d00f      	beq.n	30010a96 <hal_usbc_callback+0x9e>
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a76:	6974      	ldr	r4, [r6, #20]
30010a78:	3610      	adds	r6, #16
30010a7a:	42b4      	cmp	r4, r6
30010a7c:	d0e4      	beq.n	30010a48 <hal_usbc_callback+0x50>
        c->cb(c->cookie, op, args);
30010a7e:	68a3      	ldr	r3, [r4, #8]
30010a80:	462a      	mov	r2, r5
30010a82:	68e0      	ldr	r0, [r4, #12]
30010a84:	2106      	movs	r1, #6
30010a86:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010a88:	6864      	ldr	r4, [r4, #4]
30010a8a:	42b4      	cmp	r4, r6
30010a8c:	d1f7      	bne.n	30010a7e <hal_usbc_callback+0x86>
}
30010a8e:	2000      	movs	r0, #0
30010a90:	b002      	add	sp, #8
30010a92:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            switch (setup->request) {
30010a96:	7862      	ldrb	r2, [r4, #1]
30010a98:	2a0b      	cmp	r2, #11
30010a9a:	d8ec      	bhi.n	30010a76 <hal_usbc_callback+0x7e>
30010a9c:	a101      	add	r1, pc, #4	; (adr r1, 30010aa4 <hal_usbc_callback+0xac>)
30010a9e:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
30010aa2:	bf00      	nop
30010aa4:	30010b4b 	.word	0x30010b4b
30010aa8:	30010b43 	.word	0x30010b43
30010aac:	30010a77 	.word	0x30010a77
30010ab0:	30010b43 	.word	0x30010b43
30010ab4:	30010a77 	.word	0x30010a77
30010ab8:	30010b31 	.word	0x30010b31
30010abc:	30010aeb 	.word	0x30010aeb
30010ac0:	30010ae3 	.word	0x30010ae3
30010ac4:	30010bbd 	.word	0x30010bbd
30010ac8:	30010b7b 	.word	0x30010b7b
30010acc:	30010b65 	.word	0x30010b65
30010ad0:	30010b5b 	.word	0x30010b5b
                        switch (setup->value) {
30010ad4:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
30010ad8:	f000 809c 	beq.w	30010c14 <hal_usbc_callback+0x21c>
30010adc:	f5b3 6f20 	cmp.w	r3, #2560	; 0xa00
30010ae0:	d1b2      	bne.n	30010a48 <hal_usbc_callback+0x50>
                                usbc_ep0_stall(usb);
30010ae2:	4630      	mov	r0, r6
30010ae4:	f7fb ff6a 	bl	3000c9bc <usbc_ep0_stall>
                                break;
30010ae8:	e7ae      	b.n	30010a48 <hal_usbc_callback+0x50>
                    if ((setup->request_type & RECIP_MASK) == RECIP_DEVICE) {
30010aea:	06db      	lsls	r3, r3, #27
30010aec:	d1c3      	bne.n	30010a76 <hal_usbc_callback+0x7e>
                        if (usbc_is_highspeed(usb)) {
30010aee:	4630      	mov	r0, r6
30010af0:	f7fc fbda 	bl	3000d2a8 <usbc_is_highspeed>
                            speed = &usb->config->highspeed;
30010af4:	68f5      	ldr	r5, [r6, #12]
30010af6:	f105 0124 	add.w	r1, r5, #36	; 0x24
                        if (usbc_is_highspeed(usb)) {
30010afa:	b900      	cbnz	r0, 30010afe <hal_usbc_callback+0x106>
                            speed = &usb->config->lowspeed;
30010afc:	4629      	mov	r1, r5
                        switch (setup->value) {
30010afe:	8863      	ldrh	r3, [r4, #2]
30010b00:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
30010b04:	d2e6      	bcs.n	30010ad4 <hal_usbc_callback+0xdc>
30010b06:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
30010b0a:	d876      	bhi.n	30010bfa <hal_usbc_callback+0x202>
30010b0c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
30010b10:	f000 808e 	beq.w	30010c30 <hal_usbc_callback+0x238>
30010b14:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
30010b18:	f000 8083 	beq.w	30010c22 <hal_usbc_callback+0x22a>
30010b1c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
30010b20:	d192      	bne.n	30010a48 <hal_usbc_callback+0x50>
                                usbc_ep0_send(usb, speed->device.desc,
30010b22:	684a      	ldr	r2, [r1, #4]
30010b24:	88e3      	ldrh	r3, [r4, #6]
30010b26:	6809      	ldr	r1, [r1, #0]
30010b28:	4630      	mov	r0, r6
30010b2a:	f7fc fbdb 	bl	3000d2e4 <usbc_ep0_send>
                                break;
30010b2e:	e78b      	b.n	30010a48 <hal_usbc_callback+0x50>
                    usbc_ep0_ack(usb);
30010b30:	4630      	mov	r0, r6
30010b32:	f7fb ff41 	bl	3000c9b8 <usbc_ep0_ack>
                    usbc_set_address(usb, setup->value);
30010b36:	8861      	ldrh	r1, [r4, #2]
30010b38:	4630      	mov	r0, r6
30010b3a:	b2c9      	uxtb	r1, r1
30010b3c:	f7fb ff2e 	bl	3000c99c <usbc_set_address>
30010b40:	e782      	b.n	30010a48 <hal_usbc_callback+0x50>
                    usbc_ep0_ack(usb);
30010b42:	4630      	mov	r0, r6
30010b44:	f7fb ff38 	bl	3000c9b8 <usbc_ep0_ack>
30010b48:	e77e      	b.n	30010a48 <hal_usbc_callback+0x50>
                    usbc_ep0_send(usb, &i, 2, setup->length);
30010b4a:	88e3      	ldrh	r3, [r4, #6]
30010b4c:	4630      	mov	r0, r6
30010b4e:	4941      	ldr	r1, [pc, #260]	; (30010c54 <hal_usbc_callback+0x25c>)
30010b50:	2202      	movs	r2, #2
30010b52:	f7fc fbc7 	bl	3000d2e4 <usbc_ep0_send>
30010b56:	686e      	ldr	r6, [r5, #4]
30010b58:	e78d      	b.n	30010a76 <hal_usbc_callback+0x7e>
                    usbc_ep0_ack(usb);
30010b5a:	4630      	mov	r0, r6
30010b5c:	f7fb ff2c 	bl	3000c9b8 <usbc_ep0_ack>
30010b60:	686e      	ldr	r6, [r5, #4]
30010b62:	e788      	b.n	30010a76 <hal_usbc_callback+0x7e>
                    usbc_ep0_send(usb, &i, 1, setup->length);
30010b64:	f645 0100 	movw	r1, #22528	; 0x5800
30010b68:	4630      	mov	r0, r6
30010b6a:	88e3      	ldrh	r3, [r4, #6]
30010b6c:	2201      	movs	r2, #1
30010b6e:	f2c3 0102 	movt	r1, #12290	; 0x3002
30010b72:	f7fc fbb7 	bl	3000d2e4 <usbc_ep0_send>
30010b76:	686e      	ldr	r6, [r5, #4]
30010b78:	e77d      	b.n	30010a76 <hal_usbc_callback+0x7e>
                    usbc_ep0_ack(usb);
30010b7a:	4630      	mov	r0, r6
30010b7c:	f7fb ff1c 	bl	3000c9b8 <usbc_ep0_ack>
                    hal_usb_set_active_config(usb, setup->value);
30010b80:	8863      	ldrh	r3, [r4, #2]
    if (config != usb->active_config) {
30010b82:	7a72      	ldrb	r2, [r6, #9]
    args.usb = usb;
30010b84:	9601      	str	r6, [sp, #4]
                    hal_usb_set_active_config(usb, setup->value);
30010b86:	b2db      	uxtb	r3, r3
    if (config != usb->active_config) {
30010b88:	429a      	cmp	r2, r3
30010b8a:	d0e4      	beq.n	30010b56 <hal_usbc_callback+0x15e>
        usb->active_config = config;
30010b8c:	7273      	strb	r3, [r6, #9]
        if (usb->active_config != 0) {
30010b8e:	b1f3      	cbz	r3, 30010bce <hal_usbc_callback+0x1d6>
            printf("usb online\n");
30010b90:	f240 502c 	movw	r0, #1324	; 0x52c
30010b94:	f2c3 0002 	movt	r0, #12290	; 0x3002
30010b98:	f005 f80a 	bl	30015bb0 <_printf>
    usb_t *usb = args->usb;
30010b9c:	9b01      	ldr	r3, [sp, #4]
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010b9e:	f103 0710 	add.w	r7, r3, #16
30010ba2:	695c      	ldr	r4, [r3, #20]
30010ba4:	42a7      	cmp	r7, r4
30010ba6:	d0d6      	beq.n	30010b56 <hal_usbc_callback+0x15e>
30010ba8:	466e      	mov	r6, r13
        c->cb(c->cookie, op, args);
30010baa:	68a3      	ldr	r3, [r4, #8]
30010bac:	4632      	mov	r2, r6
30010bae:	68e0      	ldr	r0, [r4, #12]
30010bb0:	2104      	movs	r1, #4
30010bb2:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010bb4:	6864      	ldr	r4, [r4, #4]
30010bb6:	42bc      	cmp	r4, r7
30010bb8:	d1f7      	bne.n	30010baa <hal_usbc_callback+0x1b2>
30010bba:	e7cc      	b.n	30010b56 <hal_usbc_callback+0x15e>
                    usbc_ep0_send(usb, &usb->active_config, 1, setup->length);
30010bbc:	4630      	mov	r0, r6
30010bbe:	f106 0109 	add.w	r1, r6, #9
30010bc2:	88e3      	ldrh	r3, [r4, #6]
30010bc4:	2201      	movs	r2, #1
30010bc6:	f7fc fb8d 	bl	3000d2e4 <usbc_ep0_send>
30010bca:	686e      	ldr	r6, [r5, #4]
30010bcc:	e753      	b.n	30010a76 <hal_usbc_callback+0x7e>
            printf("usb offline\n");
30010bce:	f240 5038 	movw	r0, #1336	; 0x538
30010bd2:	f2c3 0002 	movt	r0, #12290	; 0x3002
30010bd6:	f004 ffeb 	bl	30015bb0 <_printf>
    usb_t *usb = args->usb;
30010bda:	9b01      	ldr	r3, [sp, #4]
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010bdc:	f103 0710 	add.w	r7, r3, #16
30010be0:	695c      	ldr	r4, [r3, #20]
30010be2:	42bc      	cmp	r4, r7
30010be4:	d0b7      	beq.n	30010b56 <hal_usbc_callback+0x15e>
30010be6:	466e      	mov	r6, r13
        c->cb(c->cookie, op, args);
30010be8:	68a3      	ldr	r3, [r4, #8]
30010bea:	4632      	mov	r2, r6
30010bec:	68e0      	ldr	r0, [r4, #12]
30010bee:	2105      	movs	r1, #5
30010bf0:	4798      	blx	r3
    list_for_every_entry(&usb->cb_list, c, usb_callback_container_t, node) {
30010bf2:	6864      	ldr	r4, [r4, #4]
30010bf4:	42bc      	cmp	r4, r7
30010bf6:	d1f7      	bne.n	30010be8 <hal_usbc_callback+0x1f0>
30010bf8:	e7ad      	b.n	30010b56 <hal_usbc_callback+0x15e>
30010bfa:	4631      	mov	r1, r6
                                uint8_t id = setup->value & 0xff;
30010bfc:	b2db      	uxtb	r3, r3
                                for (i = 0; i < MAX_STRINGS; i++) {
30010bfe:	2200      	movs	r2, #0
                                    if (usb->strings[i].id == id) {
30010c00:	f891 0024 	ldrb.w	r0, [r1, #36]	; 0x24
30010c04:	4298      	cmp	r0, r3
30010c06:	f101 010e 	add.w	r1, r1, #14
30010c0a:	d018      	beq.n	30010c3e <hal_usbc_callback+0x246>
                                for (i = 0; i < MAX_STRINGS; i++) {
30010c0c:	3201      	adds	r2, #1
30010c0e:	2a08      	cmp	r2, #8
30010c10:	d1f6      	bne.n	30010c00 <hal_usbc_callback+0x208>
30010c12:	e766      	b.n	30010ae2 <hal_usbc_callback+0xea>
                                usbc_ep0_send(usb, speed->device_qual.desc,
30010c14:	690a      	ldr	r2, [r1, #16]
30010c16:	88e3      	ldrh	r3, [r4, #6]
30010c18:	68c9      	ldr	r1, [r1, #12]
30010c1a:	4630      	mov	r0, r6
30010c1c:	f7fc fb62 	bl	3000d2e4 <usbc_ep0_send>
                                break;
30010c20:	e712      	b.n	30010a48 <hal_usbc_callback+0x50>
                                usbc_ep0_send(usb, usb->config->langid.desc,
30010c22:	88e3      	ldrh	r3, [r4, #6]
30010c24:	6cea      	ldr	r2, [r5, #76]	; 0x4c
30010c26:	6ca9      	ldr	r1, [r5, #72]	; 0x48
30010c28:	4630      	mov	r0, r6
30010c2a:	f7fc fb5b 	bl	3000d2e4 <usbc_ep0_send>
                                break;
30010c2e:	e70b      	b.n	30010a48 <hal_usbc_callback+0x50>
                                usbc_ep0_send(usb, speed->config.desc,
30010c30:	69ca      	ldr	r2, [r1, #28]
30010c32:	88e3      	ldrh	r3, [r4, #6]
30010c34:	6989      	ldr	r1, [r1, #24]
30010c36:	4630      	mov	r0, r6
30010c38:	f7fc fb54 	bl	3000d2e4 <usbc_ep0_send>
                                break;
30010c3c:	e704      	b.n	30010a48 <hal_usbc_callback+0x50>
                                        usbc_ep0_send(usb, usb->strings[i].string.desc,
30010c3e:	210e      	movs	r1, #14
30010c40:	4630      	mov	r0, r6
30010c42:	88e3      	ldrh	r3, [r4, #6]
30010c44:	fb01 6602 	mla	r6, r1, r2, r6
30010c48:	69f2      	ldr	r2, [r6, #28]
30010c4a:	69b1      	ldr	r1, [r6, #24]
30010c4c:	f7fc fb4a 	bl	3000d2e4 <usbc_ep0_send>
30010c50:	e6fa      	b.n	30010a48 <hal_usbc_callback+0x50>
30010c52:	bf00      	nop
30010c54:	30025802 	.word	0x30025802

30010c58 <hal_usb_irq>:

enum handler_return hal_usb_irq(void *args)
{
    return usbc_irq(args);
30010c58:	f7fb bec8 	b.w	3000c9ec <usbc_irq>

30010c5c <hal_usb_setup>:

status_t hal_usb_setup(usb_t *usb, hal_usb_config *config)
{
    DEBUG_ASSERT(config);
    DEBUG_ASSERT(usb->active == false);
    usb->config = config;
30010c5c:	60c1      	str	r1, [r0, #12]
    return NO_ERROR;
}
30010c5e:	2000      	movs	r0, #0
30010c60:	4770      	bx	r14
30010c62:	bf00      	nop

30010c64 <hal_usb_start>:

status_t hal_usb_start(usb_t *usb)
{
30010c64:	b510      	push	{r4, r14}
    DEBUG_ASSERT(usb->config);
    DEBUG_ASSERT(usb->active == false);
    // go online
    usbc_set_active(usb, true);
30010c66:	2101      	movs	r1, #1
{
30010c68:	4604      	mov	r4, r0
    usbc_set_active(usb, true);
30010c6a:	f7fb fe77 	bl	3000c95c <usbc_set_active>
    usb->active = true;
30010c6e:	2301      	movs	r3, #1
    return NO_ERROR;
}
30010c70:	2000      	movs	r0, #0
    usb->active = true;
30010c72:	7223      	strb	r3, [r4, #8]
}
30010c74:	bd10      	pop	{r4, r15}
30010c76:	bf00      	nop

30010c78 <hal_usb_stop>:

status_t hal_usb_stop(usb_t *usb)
{
30010c78:	b510      	push	{r4, r14}
    DEBUG_ASSERT(usb->active == true);
    usb->active = false;
30010c7a:	2400      	movs	r4, #0
    usbc_set_active(usb, false);
30010c7c:	4621      	mov	r1, r4
    usb->active = false;
30010c7e:	7204      	strb	r4, [r0, #8]
    usbc_set_active(usb, false);
30010c80:	f7fb fe6c 	bl	3000c95c <usbc_set_active>
    return NO_ERROR;
}
30010c84:	4620      	mov	r0, r4
30010c86:	bd10      	pop	{r4, r15}

30010c88 <hal_usb_init>:

void hal_usb_init(usb_t *usb)
{
    usbc_init(usb);
30010c88:	f7fb bcec 	b.w	3000c664 <usbc_init>

30010c8c <hal_usb_read>:
}

status_t hal_usb_read(usb_t *usb, ep_t ep, usbc_transfer_t *transfer)
{
    return usbc_queue_rx(usb, ep, transfer);
30010c8c:	f7fb be14 	b.w	3000c8b8 <usbc_queue_rx>

30010c90 <hal_usb_write>:
}


status_t hal_usb_write(usb_t *usb, ep_t ep, usbc_transfer_t *transfer)
{
    return usbc_queue_tx(usb, ep, transfer);
30010c90:	f7fb be3c 	b.w	3000c90c <usbc_queue_tx>

30010c94 <hal_usb_creat_handle>:
}

int32_t hal_usb_creat_handle(usb_t *usb, uint32_t global_base_id,
                             uint32_t global_phy_id)
{
30010c94:	b538      	push	{r3, r4, r5, r14}
30010c96:	4604      	mov	r4, r0
30010c98:	4615      	mov	r5, r2
    int32_t ret;
    ret = res_get_info_by_id(global_base_id, &usb->priv.usb_paddr,
30010c9a:	4608      	mov	r0, r1
30010c9c:	f104 028c 	add.w	r2, r4, #140	; 0x8c
30010ca0:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
30010ca4:	f7fe ffa2 	bl	3000fbec <res_get_info_by_id>
                             &usb->priv.instance_id);

    if (ret < 0) {
30010ca8:	2800      	cmp	r0, #0
30010caa:	db17      	blt.n	30010cdc <hal_usb_creat_handle+0x48>
        return ret;
    }

    ret = res_get_info_by_id(global_phy_id, &usb->priv.usb_phy_paddr,
30010cac:	4628      	mov	r0, r5
30010cae:	f104 0290 	add.w	r2, r4, #144	; 0x90
30010cb2:	f104 01ac 	add.w	r1, r4, #172	; 0xac
30010cb6:	f7fe ff99 	bl	3000fbec <res_get_info_by_id>
                             &usb->priv.instance_phy_id);

    if (ret < 0) {
30010cba:	2800      	cmp	r0, #0
30010cbc:	db0e      	blt.n	30010cdc <hal_usb_creat_handle+0x48>
        return ret;
    }

    usb->priv.usb_vaddr  = (vaddr_t)_ioaddr(usb->priv.usb_paddr);
    usb->priv.usb_phy_vaddr = (vaddr_t)_ioaddr(usb->priv.usb_phy_paddr);
    usb->priv.irq_num = usb_irq[usb->priv.instance_id];
30010cbe:	f245 2388 	movw	r3, #21128	; 0x5288
    return 0;
30010cc2:	2000      	movs	r0, #0
    usb->priv.irq_num = usb_irq[usb->priv.instance_id];
30010cc4:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
30010cc8:	f2c3 0302 	movt	r3, #12290	; 0x3002
    usb->priv.usb_phy_vaddr = (vaddr_t)_ioaddr(usb->priv.usb_phy_paddr);
30010ccc:	e9d4 212b 	ldrd	r2, r1, [r4, #172]	; 0xac
30010cd0:	e9c4 212d 	strd	r2, r1, [r4, #180]	; 0xb4
    usb->priv.irq_num = usb_irq[usb->priv.instance_id];
30010cd4:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
30010cd8:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
}
30010cdc:	bd38      	pop	{r3, r4, r5, r15}
30010cde:	bf00      	nop

30010ce0 <hal_usb_release_handle>:

int32_t hal_usb_release_handle(usb_t *usb)
{
30010ce0:	4602      	mov	r2, r0
    usb->priv.usb_vaddr = 0;
30010ce2:	2300      	movs	r3, #0
    usb->priv.usb_phy_vaddr = 0;
    usb->priv.irq_num = 0;
    return 0;
}
30010ce4:	4618      	mov	r0, r3
    usb->priv.usb_phy_vaddr = 0;
30010ce6:	e9c2 332d 	strd	r3, r3, [r2, #180]	; 0xb4
    usb->priv.irq_num = 0;
30010cea:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
30010cee:	4770      	bx	r14

30010cf0 <hal_usb_is_highspeed>:

bool hal_usb_is_highspeed(usb_t *usb)
{
    return usbc_is_highspeed(usb);
30010cf0:	f7fc bada 	b.w	3000d2a8 <usbc_is_highspeed>

30010cf4 <hal_usb_setup_endpoint>:
}

status_t hal_usb_setup_endpoint(usb_t *usb, ep_t ep, ep_dir_t dir,
                                uint width, ep_type_t type)
{
    return usbc_setup_endpoint(usb, ep, dir, width, type);
30010cf4:	f7fc bae8 	b.w	3000d2c8 <usbc_setup_endpoint>

30010cf8 <usb_read_complete>:
    dprintf(INFO, "%s E\n", __func__);
    return 0;
}

static status_t usb_read_complete(ep_t ep, usbc_transfer_t *t)
{
30010cf8:	b510      	push	{r4, r14}
    fastboot_t *fb = (fastboot_t *)t->extra;
    fb->priv.usb_read_status = t->result;

    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010cfa:	e9d1 4203 	ldrd	r4, r2, [r1, #12]
    fastboot_t *fb = (fastboot_t *)t->extra;
30010cfe:	6948      	ldr	r0, [r1, #20]
    fb->priv.usb_read_status = t->result;
30010d00:	6849      	ldr	r1, [r1, #4]
    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010d02:	fab2 f382 	clz	r3, r2
    fb->priv.usb_read_status = t->result;
30010d06:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010d0a:	095b      	lsrs	r3, r3, #5
30010d0c:	42a2      	cmp	r2, r4
30010d0e:	bf88      	it	hi
30010d10:	f043 0301 	orrhi.w	r3, r3, #1
30010d14:	b11b      	cbz	r3, 30010d1e <usb_read_complete+0x26>
        fb->priv.usb_read_status = ERR_IO;
30010d16:	f06f 0313 	mvn.w	r3, #19
30010d1a:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    }

    fb->priv.actual_read_len = t->bufpos;
30010d1e:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
    event_signal(&fb->priv.usb_read_done, false);
30010d22:	2100      	movs	r1, #0
30010d24:	3060      	adds	r0, #96	; 0x60
30010d26:	f000 fe01 	bl	3001192c <event_signal>
    return NO_ERROR;
}
30010d2a:	2000      	movs	r0, #0
30010d2c:	bd10      	pop	{r4, r15}
30010d2e:	bf00      	nop

30010d30 <usb_write_complete>:
    fb->state = STATE_ERROR;
    return -1;
}

static status_t usb_write_complete(ep_t ep, usbc_transfer_t *t)
{
30010d30:	b510      	push	{r4, r14}
    fastboot_t *fb = (fastboot_t *)t->extra;
    fb->priv.usb_write_status = t->result;
    fb->priv.actual_write_len = t->bufpos;

    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010d32:	e9d1 4203 	ldrd	r4, r2, [r1, #12]
    fastboot_t *fb = (fastboot_t *)t->extra;
30010d36:	6948      	ldr	r0, [r1, #20]
    fb->priv.usb_write_status = t->result;
30010d38:	6849      	ldr	r1, [r1, #4]
    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010d3a:	fab2 f382 	clz	r3, r2
    fb->priv.actual_write_len = t->bufpos;
30010d3e:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
    fb->priv.usb_write_status = t->result;
30010d42:	67c1      	str	r1, [r0, #124]	; 0x7c
    if (t->bufpos > t->buflen || t->bufpos == 0) {
30010d44:	095b      	lsrs	r3, r3, #5
30010d46:	42a2      	cmp	r2, r4
30010d48:	bf88      	it	hi
30010d4a:	f043 0301 	orrhi.w	r3, r3, #1
30010d4e:	b113      	cbz	r3, 30010d56 <usb_write_complete+0x26>
        fb->priv.usb_write_status = -1;
30010d50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
30010d54:	67c3      	str	r3, [r0, #124]	; 0x7c
    }

    event_signal(&fb->priv.usb_write_done, false);
30010d56:	2100      	movs	r1, #0
30010d58:	3044      	adds	r0, #68	; 0x44
30010d5a:	f000 fde7 	bl	3001192c <event_signal>
    return NO_ERROR;
}
30010d5e:	2000      	movs	r0, #0
30010d60:	bd10      	pop	{r4, r15}
30010d62:	bf00      	nop

30010d64 <fastboot_usb_cb>:
    int mps = 64;
    fastboot_t *fb = (fastboot_t *)cookie;
    dprintf(INFO, "%s cookie %p, op %u, args %p\n", __func__, cookie, op,
            args);

    if (op == USB_CB_ONLINE) {
30010d64:	2904      	cmp	r1, #4
{
30010d66:	b5f0      	push	{r4, r5, r6, r7, r14}
30010d68:	4604      	mov	r4, r0
30010d6a:	b083      	sub	sp, #12
    if (op == USB_CB_ONLINE) {
30010d6c:	d00b      	beq.n	30010d86 <fastboot_usb_cb+0x22>

        if (fb->cb.online) {
            fb->cb.online(cookie);
        }
    }
    else if (op == USB_CB_DISCONNECT) {
30010d6e:	2903      	cmp	r1, #3
30010d70:	d002      	beq.n	30010d78 <fastboot_usb_cb+0x14>
            fb->cb.offline(cookie);
        }
    }

    return NO_ERROR;
}
30010d72:	2000      	movs	r0, #0
30010d74:	b003      	add	sp, #12
30010d76:	bdf0      	pop	{r4, r5, r6, r7, r15}
        if (fb->cb.offline) {
30010d78:	6883      	ldr	r3, [r0, #8]
30010d7a:	2b00      	cmp	r3, #0
30010d7c:	d0f9      	beq.n	30010d72 <fastboot_usb_cb+0xe>
            fb->cb.offline(cookie);
30010d7e:	4798      	blx	r3
}
30010d80:	2000      	movs	r0, #0
30010d82:	b003      	add	sp, #12
30010d84:	bdf0      	pop	{r4, r5, r6, r7, r15}
        hal_usb_setup_endpoint(&fb->usb, fb->priv.write_ep, USB_IN, mps, USB_BULK);
30010d86:	2602      	movs	r6, #2
        if (hal_usb_is_highspeed(&fb->usb)) {
30010d88:	f100 0594 	add.w	r5, r0, #148	; 0x94
30010d8c:	4628      	mov	r0, r5
30010d8e:	f7ff ffaf 	bl	30010cf0 <hal_usb_is_highspeed>
        hal_usb_setup_endpoint(&fb->usb, fb->priv.write_ep, USB_IN, mps, USB_BULK);
30010d92:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
30010d96:	9600      	str	r6, [sp, #0]
30010d98:	2200      	movs	r2, #0
        if (hal_usb_is_highspeed(&fb->usb)) {
30010d9a:	4290      	cmp	r0, r2
30010d9c:	bf14      	ite	ne
30010d9e:	f44f 7700 	movne.w	r7, #512	; 0x200
30010da2:	2740      	moveq	r7, #64	; 0x40
        hal_usb_setup_endpoint(&fb->usb, fb->priv.write_ep, USB_IN, mps, USB_BULK);
30010da4:	463b      	mov	r3, r7
30010da6:	4628      	mov	r0, r5
30010da8:	f7ff ffa4 	bl	30010cf4 <hal_usb_setup_endpoint>
        hal_usb_setup_endpoint(&fb->usb, fb->priv.read_ep, USB_OUT, mps, USB_BULK);
30010dac:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
30010db0:	463b      	mov	r3, r7
30010db2:	4628      	mov	r0, r5
30010db4:	9600      	str	r6, [sp, #0]
30010db6:	2201      	movs	r2, #1
30010db8:	f7ff ff9c 	bl	30010cf4 <hal_usb_setup_endpoint>
        if (fb->cb.online) {
30010dbc:	6863      	ldr	r3, [r4, #4]
30010dbe:	2b00      	cmp	r3, #0
30010dc0:	d0d7      	beq.n	30010d72 <fastboot_usb_cb+0xe>
            fb->cb.online(cookie);
30010dc2:	4620      	mov	r0, r4
30010dc4:	4798      	blx	r3
}
30010dc6:	2000      	movs	r0, #0
30010dc8:	b003      	add	sp, #12
30010dca:	bdf0      	pop	{r4, r5, r6, r7, r15}

30010dcc <fastboot_register_cmd>:
{
30010dcc:	b570      	push	{r4, r5, r6, r14}
30010dce:	4605      	mov	r5, r0
    cmd = malloc(sizeof(*cmd));
30010dd0:	2010      	movs	r0, #16
{
30010dd2:	460e      	mov	r6, r1
    cmd = malloc(sizeof(*cmd));
30010dd4:	f003 fc88 	bl	300146e8 <malloc>
    if (cmd) {
30010dd8:	b168      	cbz	r0, 30010df6 <fastboot_register_cmd+0x2a>
        cmd->prefix = prefix;
30010dda:	6045      	str	r5, [r0, #4]
30010ddc:	4604      	mov	r4, r0
        cmd->prefix_len = strlen(prefix);
30010dde:	4628      	mov	r0, r5
30010de0:	f004 ffa6 	bl	30015d30 <strlen>
        cmd->handle = handle;
30010de4:	60e6      	str	r6, [r4, #12]
        cmd->next = cmdlist;
30010de6:	f64c 0384 	movw	r3, #51332	; 0xc884
30010dea:	f2c3 0302 	movt	r3, #12290	; 0x3002
30010dee:	681a      	ldr	r2, [r3, #0]
30010df0:	6022      	str	r2, [r4, #0]
        cmdlist = cmd;
30010df2:	601c      	str	r4, [r3, #0]
        cmd->prefix_len = strlen(prefix);
30010df4:	60a0      	str	r0, [r4, #8]
}
30010df6:	bd70      	pop	{r4, r5, r6, r15}

30010df8 <fastboot_register_var>:
{
30010df8:	b538      	push	{r3, r4, r5, r14}
30010dfa:	4605      	mov	r5, r0
    var = malloc(sizeof(*var));
30010dfc:	200c      	movs	r0, #12
{
30010dfe:	460c      	mov	r4, r1
    var = malloc(sizeof(*var));
30010e00:	f003 fc72 	bl	300146e8 <malloc>
    if (var) {
30010e04:	b140      	cbz	r0, 30010e18 <fastboot_register_var+0x20>
        var->value = value;
30010e06:	e9c0 5401 	strd	r5, r4, [r0, #4]
        var->next = varlist;
30010e0a:	f64c 23a0 	movw	r3, #51872	; 0xcaa0
30010e0e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30010e12:	681a      	ldr	r2, [r3, #0]
30010e14:	6002      	str	r2, [r0, #0]
        varlist = var;
30010e16:	6018      	str	r0, [r3, #0]
}
30010e18:	bd38      	pop	{r3, r4, r5, r15}
30010e1a:	bf00      	nop

30010e1c <fastboot_ack>:
{
30010e1c:	b570      	push	{r4, r5, r6, r14}
30010e1e:	4616      	mov	r6, r2
30010e20:	b09a      	sub	sp, #104	; 0x68
    if (fb->state != STATE_COMMAND) {
30010e22:	6802      	ldr	r2, [r0, #0]
30010e24:	2a01      	cmp	r2, #1
30010e26:	d11f      	bne.n	30010e68 <fastboot_ack+0x4c>
30010e28:	4605      	mov	r5, r0
        reason = "";
30010e2a:	f64a 70bc 	movw	r0, #44988	; 0xafbc
30010e2e:	f2c3 0001 	movt	r0, #12289	; 0x3001
    snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
30010e32:	f240 527c 	movw	r2, #1404	; 0x57c
30010e36:	f10d 0427 	add.w	r4, r13, #39	; 0x27
        reason = "";
30010e3a:	2e00      	cmp	r6, #0
30010e3c:	bf08      	it	eq
30010e3e:	4606      	moveq	r6, r0
    snprintf((char *)response, MAX_RSP_SIZE, "%s%s", code, reason);
30010e40:	460b      	mov	r3, r1
30010e42:	f024 041f 	bic.w	r4, r4, #31
30010e46:	2140      	movs	r1, #64	; 0x40
30010e48:	f2c3 0202 	movt	r2, #12290	; 0x3002
30010e4c:	9600      	str	r6, [sp, #0]
30010e4e:	4620      	mov	r0, r4
30010e50:	f004 fe3e 	bl	30015ad0 <snprintf>
    fb->state = STATE_COMPLETE;
30010e54:	2302      	movs	r3, #2
    fb->usb_write((void *)fb, response, strlen((const char *)response));
30010e56:	4620      	mov	r0, r4
    fb->state = STATE_COMPLETE;
30010e58:	602b      	str	r3, [r5, #0]
    fb->usb_write((void *)fb, response, strlen((const char *)response));
30010e5a:	f004 ff69 	bl	30015d30 <strlen>
30010e5e:	69ab      	ldr	r3, [r5, #24]
30010e60:	4621      	mov	r1, r4
30010e62:	4602      	mov	r2, r0
30010e64:	4628      	mov	r0, r5
30010e66:	4798      	blx	r3
}
30010e68:	b01a      	add	sp, #104	; 0x68
30010e6a:	bd70      	pop	{r4, r5, r6, r15}

30010e6c <fastboot_info>:
    if (fb->state != STATE_COMMAND || reason == NULL) {
30010e6c:	fab1 f281 	clz	r2, r1
{
30010e70:	b530      	push	{r4, r5, r14}
    if (fb->state != STATE_COMMAND || reason == NULL) {
30010e72:	6805      	ldr	r5, [r0, #0]
30010e74:	0952      	lsrs	r2, r2, #5
{
30010e76:	b099      	sub	sp, #100	; 0x64
    if (fb->state != STATE_COMMAND || reason == NULL) {
30010e78:	2d01      	cmp	r5, #1
30010e7a:	bf18      	it	ne
30010e7c:	f042 0201 	orrne.w	r2, r2, #1
30010e80:	b10a      	cbz	r2, 30010e86 <fastboot_info+0x1a>
}
30010e82:	b019      	add	sp, #100	; 0x64
30010e84:	bd30      	pop	{r4, r5, r15}
    snprintf((char *)response, MAX_RSP_SIZE, "INFO%s", reason);
30010e86:	f240 52e0 	movw	r2, #1504	; 0x5e0
30010e8a:	f10d 041f 	add.w	r4, r13, #31
30010e8e:	460b      	mov	r3, r1
30010e90:	f024 041f 	bic.w	r4, r4, #31
30010e94:	4605      	mov	r5, r0
30010e96:	f2c3 0202 	movt	r2, #12290	; 0x3002
30010e9a:	2140      	movs	r1, #64	; 0x40
30010e9c:	4620      	mov	r0, r4
30010e9e:	f004 fe17 	bl	30015ad0 <snprintf>
    fb->usb_write((void *)fb, response, strlen((const char *)response));
30010ea2:	4620      	mov	r0, r4
30010ea4:	f004 ff44 	bl	30015d30 <strlen>
30010ea8:	69ab      	ldr	r3, [r5, #24]
30010eaa:	4621      	mov	r1, r4
30010eac:	4602      	mov	r2, r0
30010eae:	4628      	mov	r0, r5
30010eb0:	4798      	blx	r3
}
30010eb2:	b019      	add	sp, #100	; 0x64
30010eb4:	bd30      	pop	{r4, r5, r15}
30010eb6:	bf00      	nop

30010eb8 <fastboot_fail>:
    fastboot_ack(fb, "FAIL", reason);
30010eb8:	460a      	mov	r2, r1
30010eba:	f240 5184 	movw	r1, #1412	; 0x584
{
30010ebe:	b508      	push	{r3, r14}
    fastboot_ack(fb, "FAIL", reason);
30010ec0:	f2c3 0102 	movt	r1, #12290	; 0x3002
30010ec4:	f7ff ffaa 	bl	30010e1c <fastboot_ack>
}
30010ec8:	bd08      	pop	{r3, r15}
30010eca:	bf00      	nop

30010ecc <fastboot_handler>:
{
30010ecc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30010ed0:	f64c 06a0 	movw	r6, #51360	; 0xc8a0
30010ed4:	f64c 0884 	movw	r8, #51332	; 0xc884
    dprintf(ALWAYS, "fastboot: processing commands\n");
30010ed8:	f240 538c 	movw	r3, #1420	; 0x58c
30010edc:	f2c3 0602 	movt	r6, #12290	; 0x3002
                fastboot_fail(fb, "unknown reason");
30010ee0:	f240 5ac0 	movw	r10, #1472	; 0x5c0
{
30010ee4:	b083      	sub	sp, #12
30010ee6:	f100 0228 	add.w	r2, r0, #40	; 0x28
30010eea:	4604      	mov	r4, r0
    dprintf(ALWAYS, "fastboot: processing commands\n");
30010eec:	f2c3 0302 	movt	r3, #12290	; 0x3002
        memset(fb_cmd_buf, 0, MAX_RSP_SIZE);
30010ef0:	4635      	mov	r5, r6
30010ef2:	f2c3 0802 	movt	r8, #12290	; 0x3002
30010ef6:	9200      	str	r2, [sp, #0]
                fastboot_fail(fb, "unknown reason");
30010ef8:	f2c3 0a02 	movt	r10, #12290	; 0x3002
    dprintf(ALWAYS, "fastboot: processing commands\n");
30010efc:	9301      	str	r3, [sp, #4]
30010efe:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        fastboot_fail(fb, "unknown command");
30010f02:	f240 59d0 	movw	r9, #1488	; 0x5d0
30010f06:	9800      	ldr	r0, [sp, #0]
30010f08:	f2c3 0902 	movt	r9, #12290	; 0x3002
30010f0c:	f000 fce8 	bl	300118e0 <event_wait_timeout>
    dprintf(ALWAYS, "fastboot: processing commands\n");
30010f10:	9801      	ldr	r0, [sp, #4]
30010f12:	f004 fe4d 	bl	30015bb0 <_printf>
30010f16:	6823      	ldr	r3, [r4, #0]
    while (fb->state != STATE_ERROR) {
30010f18:	2b03      	cmp	r3, #3
30010f1a:	d02f      	beq.n	30010f7c <fastboot_handler+0xb0>
        memset(fb_cmd_buf, 0, MAX_RSP_SIZE);
30010f1c:	2240      	movs	r2, #64	; 0x40
30010f1e:	2100      	movs	r1, #0
30010f20:	4628      	mov	r0, r5
30010f22:	f003 ed26 	blx	30014970 <memset>
        arch_clean_invalidate_cache_range((addr_t)fb_cmd_buf, MAX_RSP_SIZE);
30010f26:	2140      	movs	r1, #64	; 0x40
30010f28:	4628      	mov	r0, r5
30010f2a:	f7f0 edf2 	blx	30001b10 <arch_clean_invalidate_cache_range>
        r = fb->usb_read((void *)fb, fb_cmd_buf, MAX_RSP_SIZE);
30010f2e:	6963      	ldr	r3, [r4, #20]
30010f30:	2240      	movs	r2, #64	; 0x40
30010f32:	4629      	mov	r1, r5
30010f34:	4620      	mov	r0, r4
30010f36:	4798      	blx	r3
        if (r < 0) {
30010f38:	2800      	cmp	r0, #0
30010f3a:	db1f      	blt.n	30010f7c <fastboot_handler+0xb0>
        for (cmd = cmdlist; cmd; cmd = cmd->next) {
30010f3c:	f8d8 7000 	ldr.w	r7, [r8]
        fb_cmd_buf[r] = 0;
30010f40:	2200      	movs	r2, #0
        fb->state = STATE_COMMAND;
30010f42:	2301      	movs	r3, #1
        fb_cmd_buf[r] = 0;
30010f44:	5432      	strb	r2, [r6, r0]
        fb->state = STATE_COMMAND;
30010f46:	6023      	str	r3, [r4, #0]
        for (cmd = cmdlist; cmd; cmd = cmd->next) {
30010f48:	b327      	cbz	r7, 30010f94 <fastboot_handler+0xc8>
            if (memcmp(fb_cmd_buf, cmd->prefix, cmd->prefix_len)) {
30010f4a:	f8d7 b008 	ldr.w	r11, [r7, #8]
30010f4e:	4628      	mov	r0, r5
30010f50:	6879      	ldr	r1, [r7, #4]
30010f52:	465a      	mov	r2, r11
30010f54:	f004 fe4e 	bl	30015bf4 <memcmp>
30010f58:	b9c8      	cbnz	r0, 30010f8e <fastboot_handler+0xc2>
            cmd->handle(fb, (const char *)fb_cmd_buf + cmd->prefix_len,
30010f5a:	6a63      	ldr	r3, [r4, #36]	; 0x24
30010f5c:	eb06 010b 	add.w	r1, r6, r11
30010f60:	68ff      	ldr	r7, [r7, #12]
30010f62:	4620      	mov	r0, r4
30010f64:	69e2      	ldr	r2, [r4, #28]
30010f66:	47b8      	blx	r7
            if (fb->state == STATE_COMMAND) {
30010f68:	6823      	ldr	r3, [r4, #0]
30010f6a:	2b01      	cmp	r3, #1
30010f6c:	d1d4      	bne.n	30010f18 <fastboot_handler+0x4c>
                fastboot_fail(fb, "unknown reason");
30010f6e:	4651      	mov	r1, r10
30010f70:	4620      	mov	r0, r4
30010f72:	f7ff ffa1 	bl	30010eb8 <fastboot_fail>
30010f76:	6823      	ldr	r3, [r4, #0]
    while (fb->state != STATE_ERROR) {
30010f78:	2b03      	cmp	r3, #3
30010f7a:	d1cf      	bne.n	30010f1c <fastboot_handler+0x50>
    fb->state = STATE_OFFLINE;
30010f7c:	2300      	movs	r3, #0
    dprintf(ALWAYS, "fastboot: oops!\n");
30010f7e:	f240 50ac 	movw	r0, #1452	; 0x5ac
30010f82:	f2c3 0002 	movt	r0, #12290	; 0x3002
    fb->state = STATE_OFFLINE;
30010f86:	6023      	str	r3, [r4, #0]
    dprintf(ALWAYS, "fastboot: oops!\n");
30010f88:	f004 fe12 	bl	30015bb0 <_printf>
30010f8c:	e7b7      	b.n	30010efe <fastboot_handler+0x32>
        for (cmd = cmdlist; cmd; cmd = cmd->next) {
30010f8e:	683f      	ldr	r7, [r7, #0]
30010f90:	2f00      	cmp	r7, #0
30010f92:	d1da      	bne.n	30010f4a <fastboot_handler+0x7e>
        fastboot_fail(fb, "unknown command");
30010f94:	4649      	mov	r1, r9
30010f96:	4620      	mov	r0, r4
30010f98:	f7ff ff8e 	bl	30010eb8 <fastboot_fail>
30010f9c:	6823      	ldr	r3, [r4, #0]
30010f9e:	e7bb      	b.n	30010f18 <fastboot_handler+0x4c>

30010fa0 <fastboot_okay>:
    fastboot_ack(fb, "OKAY", info);
30010fa0:	460a      	mov	r2, r1
30010fa2:	f240 51e8 	movw	r1, #1512	; 0x5e8
{
30010fa6:	b508      	push	{r3, r14}
    fastboot_ack(fb, "OKAY", info);
30010fa8:	f2c3 0102 	movt	r1, #12290	; 0x3002
30010fac:	f7ff ff36 	bl	30010e1c <fastboot_ack>
}
30010fb0:	bd08      	pop	{r3, r15}
30010fb2:	bf00      	nop

30010fb4 <cmd_getvar>:
{
30010fb4:	b570      	push	{r4, r5, r6, r14}
30010fb6:	4606      	mov	r6, r0
30010fb8:	b0c0      	sub	sp, #256	; 0x100
    if (!strncmp("all", arg, strlen(arg))) {
30010fba:	4608      	mov	r0, r1
{
30010fbc:	460d      	mov	r5, r1
    if (!strncmp("all", arg, strlen(arg))) {
30010fbe:	f004 feb7 	bl	30015d30 <strlen>
30010fc2:	4629      	mov	r1, r5
30010fc4:	4602      	mov	r2, r0
30010fc6:	f64b 20fc 	movw	r0, #47868	; 0xbafc
30010fca:	f2c3 0001 	movt	r0, #12289	; 0x3001
30010fce:	f004 fec9 	bl	30015d64 <strncmp>
30010fd2:	b1a0      	cbz	r0, 30010ffe <cmd_getvar+0x4a>
    for (var = varlist; var; var = var->next) {
30010fd4:	f64c 23a0 	movw	r3, #51872	; 0xcaa0
30010fd8:	f2c3 0302 	movt	r3, #12290	; 0x3002
30010fdc:	681c      	ldr	r4, [r3, #0]
30010fde:	b914      	cbnz	r4, 30010fe6 <cmd_getvar+0x32>
30010fe0:	e036      	b.n	30011050 <cmd_getvar+0x9c>
30010fe2:	6824      	ldr	r4, [r4, #0]
30010fe4:	b3a4      	cbz	r4, 30011050 <cmd_getvar+0x9c>
        if (!strcmp(var->name, arg)) {
30010fe6:	6860      	ldr	r0, [r4, #4]
30010fe8:	4629      	mov	r1, r5
30010fea:	f004 fe2f 	bl	30015c4c <strcmp>
30010fee:	2800      	cmp	r0, #0
30010ff0:	d1f7      	bne.n	30010fe2 <cmd_getvar+0x2e>
            fastboot_okay(fb, var->value);
30010ff2:	68a1      	ldr	r1, [r4, #8]
30010ff4:	4630      	mov	r0, r6
30010ff6:	f7ff ffd3 	bl	30010fa0 <fastboot_okay>
}
30010ffa:	b040      	add	sp, #256	; 0x100
30010ffc:	bd70      	pop	{r4, r5, r6, r15}
    memset((void *) getvar_all, '\0', sizeof(getvar_all));
30010ffe:	4601      	mov	r1, r0
30011000:	f44f 7280 	mov.w	r2, #256	; 0x100
30011004:	4668      	mov	r0, r13
30011006:	f003 ecb4 	blx	30014970 <memset>
    for (var = varlist; var; var = var->next) {
3001100a:	f64c 23a0 	movw	r3, #51872	; 0xcaa0
3001100e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30011012:	681c      	ldr	r4, [r3, #0]
30011014:	b1e4      	cbz	r4, 30011050 <cmd_getvar+0x9c>
        strlcat((char *) getvar_all, ":", sizeof(getvar_all));
30011016:	f241 155c 	movw	r5, #4444	; 0x115c
3001101a:	f2c3 0502 	movt	r5, #12290	; 0x3002
        strlcpy((char *) getvar_all, var->name, sizeof(getvar_all));
3001101e:	6861      	ldr	r1, [r4, #4]
30011020:	f44f 7280 	mov.w	r2, #256	; 0x100
30011024:	4668      	mov	r0, r13
30011026:	f004 fe61 	bl	30015cec <strlcpy>
        strlcat((char *) getvar_all, ":", sizeof(getvar_all));
3001102a:	f44f 7280 	mov.w	r2, #256	; 0x100
3001102e:	4629      	mov	r1, r5
30011030:	4668      	mov	r0, r13
30011032:	f004 fe29 	bl	30015c88 <strlcat>
        strlcat((char *) getvar_all, var->value, sizeof(getvar_all));
30011036:	68a1      	ldr	r1, [r4, #8]
30011038:	f44f 7280 	mov.w	r2, #256	; 0x100
3001103c:	4668      	mov	r0, r13
3001103e:	f004 fe23 	bl	30015c88 <strlcat>
        fastboot_info(fb, getvar_all);
30011042:	4669      	mov	r1, r13
30011044:	4630      	mov	r0, r6
30011046:	f7ff ff11 	bl	30010e6c <fastboot_info>
    for (var = varlist; var; var = var->next) {
3001104a:	6824      	ldr	r4, [r4, #0]
3001104c:	2c00      	cmp	r4, #0
3001104e:	d1e6      	bne.n	3001101e <cmd_getvar+0x6a>
    fastboot_okay(fb, "");
30011050:	f64a 71bc 	movw	r1, #44988	; 0xafbc
30011054:	4630      	mov	r0, r6
30011056:	f2c3 0101 	movt	r1, #12289	; 0x3001
3001105a:	f7ff ffa1 	bl	30010fa0 <fastboot_okay>
}
3001105e:	b040      	add	sp, #256	; 0x100
30011060:	bd70      	pop	{r4, r5, r6, r15}
30011062:	bf00      	nop

30011064 <cmd_download>:
{
30011064:	b570      	push	{r4, r5, r6, r14}
    unsigned long len = strtoul(arg, &tmp, 16);
30011066:	2210      	movs	r2, #16
{
30011068:	b09a      	sub	sp, #104	; 0x68
3001106a:	4604      	mov	r4, r0
    unsigned long len = strtoul(arg, &tmp, 16);
3001106c:	4608      	mov	r0, r1
3001106e:	a901      	add	r1, sp, #4
30011070:	f003 fdb8 	bl	30014be4 <strtoul>
    fb->priv.download_size = 0;
30011074:	2200      	movs	r2, #0
    if (len > fb->priv.download_max) {
30011076:	6a23      	ldr	r3, [r4, #32]
    fb->priv.download_size = 0;
30011078:	6262      	str	r2, [r4, #36]	; 0x24
    if (len > fb->priv.download_max) {
3001107a:	4283      	cmp	r3, r0
3001107c:	d208      	bcs.n	30011090 <cmd_download+0x2c>
        fastboot_fail(fb, "data too large");
3001107e:	f240 5154 	movw	r1, #1364	; 0x554
30011082:	4620      	mov	r0, r4
30011084:	f2c3 0102 	movt	r1, #12290	; 0x3002
30011088:	f7ff ff16 	bl	30010eb8 <fastboot_fail>
}
3001108c:	b01a      	add	sp, #104	; 0x68
3001108e:	bd70      	pop	{r4, r5, r6, r15}
    snprintf((char *)response, MAX_RSP_SIZE, "DATA%08x", len);
30011090:	f240 5264 	movw	r2, #1380	; 0x564
30011094:	f10d 0527 	add.w	r5, r13, #39	; 0x27
30011098:	4603      	mov	r3, r0
3001109a:	f025 051f 	bic.w	r5, r5, #31
3001109e:	2140      	movs	r1, #64	; 0x40
300110a0:	f2c3 0202 	movt	r2, #12290	; 0x3002
300110a4:	4606      	mov	r6, r0
300110a6:	4628      	mov	r0, r5
300110a8:	f004 fd12 	bl	30015ad0 <snprintf>
    if (fb->usb_write((void *)fb, response,
300110ac:	4628      	mov	r0, r5
300110ae:	f004 fe3f 	bl	30015d30 <strlen>
300110b2:	69a3      	ldr	r3, [r4, #24]
300110b4:	4629      	mov	r1, r5
300110b6:	4602      	mov	r2, r0
300110b8:	4620      	mov	r0, r4
300110ba:	4798      	blx	r3
300110bc:	2800      	cmp	r0, #0
300110be:	dbe5      	blt.n	3001108c <cmd_download+0x28>
    arch_invalidate_cache_range((addr_t)fb->priv.download_base, ROUNDUP(len,
300110c0:	69e0      	ldr	r0, [r4, #28]
300110c2:	f106 011f 	add.w	r1, r6, #31
300110c6:	f021 011f 	bic.w	r1, r1, #31
300110ca:	f7f0 ed24 	blx	30001b14 <arch_invalidate_cache_range>
    r = fb->usb_read((void *)fb, fb->priv.download_base, len);
300110ce:	6963      	ldr	r3, [r4, #20]
300110d0:	4632      	mov	r2, r6
300110d2:	4620      	mov	r0, r4
300110d4:	69e1      	ldr	r1, [r4, #28]
300110d6:	4798      	blx	r3
    if ((r < 0) || ((unsigned) r != len)) {
300110d8:	1b83      	subs	r3, r0, r6
300110da:	bf18      	it	ne
300110dc:	2301      	movne	r3, #1
300110de:	ea53 73d0 	orrs.w	r3, r3, r0, lsr #31
300110e2:	d003      	beq.n	300110ec <cmd_download+0x88>
        fb->state = STATE_ERROR;
300110e4:	2303      	movs	r3, #3
300110e6:	6023      	str	r3, [r4, #0]
}
300110e8:	b01a      	add	sp, #104	; 0x68
300110ea:	bd70      	pop	{r4, r5, r6, r15}
    fastboot_okay(fb, "");
300110ec:	f64a 71bc 	movw	r1, #44988	; 0xafbc
300110f0:	4620      	mov	r0, r4
    fb->priv.download_size = len;
300110f2:	6266      	str	r6, [r4, #36]	; 0x24
    fastboot_okay(fb, "");
300110f4:	f2c3 0101 	movt	r1, #12289	; 0x3001
300110f8:	f7ff ff52 	bl	30010fa0 <fastboot_okay>
300110fc:	e7c6      	b.n	3001108c <cmd_download+0x28>
300110fe:	bf00      	nop

30011100 <fastboot_online>:
{
30011100:	b508      	push	{r3, r14}
    event_signal(&fb->priv.usb_online, 0);
30011102:	2100      	movs	r1, #0
30011104:	3028      	adds	r0, #40	; 0x28
30011106:	f000 fc11 	bl	3001192c <event_signal>
}
3001110a:	2000      	movs	r0, #0
3001110c:	bd08      	pop	{r3, r15}
3001110e:	bf00      	nop

30011110 <fastboot_offline>:
}
30011110:	2000      	movs	r0, #0
30011112:	4770      	bx	r14

30011114 <fastboot_usb_read>:
{
30011114:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30011118:	4692      	mov	r10, r2
3001111a:	b089      	sub	sp, #36	; 0x24
    if (fb->state == STATE_ERROR) {
3001111c:	6802      	ldr	r2, [r0, #0]
{
3001111e:	4604      	mov	r4, r0
30011120:	9101      	str	r1, [sp, #4]
    if (fb->state == STATE_ERROR) {
30011122:	2a03      	cmp	r2, #3
30011124:	d041      	beq.n	300111aa <fastboot_usb_read+0x96>
    while (len > 0) {
30011126:	f1ba 0f00 	cmp.w	r10, #0
3001112a:	d05b      	beq.n	300111e4 <fastboot_usb_read+0xd0>
3001112c:	f640 49f9 	movw	r9, #3321	; 0xcf9
        event_wait(&fb->priv.usb_read_done);
30011130:	f100 0360 	add.w	r3, r0, #96	; 0x60
    int count = 0;
30011134:	2700      	movs	r7, #0
30011136:	f2c3 0901 	movt	r9, #12289	; 0x3001
        event_wait(&fb->priv.usb_read_done);
3001113a:	9300      	str	r3, [sp, #0]
3001113c:	464b      	mov	r3, r9
        rx.result   = 0;
3001113e:	46b8      	mov	r8, r7
        event_wait(&fb->priv.usb_read_done);
30011140:	4656      	mov	r6, r10
30011142:	4681      	mov	r9, r0
30011144:	46ba      	mov	r10, r7
30011146:	461c      	mov	r4, r3
30011148:	f100 0b94 	add.w	r11, r0, #148	; 0x94
3001114c:	460f      	mov	r7, r1
3001114e:	e00e      	b.n	3001116e <fastboot_usb_read+0x5a>
30011150:	f000 fbc6 	bl	300118e0 <event_wait_timeout>
        if (fb->priv.usb_read_status < 0) {
30011154:	f8d9 2080 	ldr.w	r2, [r9, #128]	; 0x80
30011158:	2a00      	cmp	r2, #0
3001115a:	db3b      	blt.n	300111d4 <fastboot_usb_read+0xc0>
        count += fb->priv.actual_read_len;
3001115c:	f8d9 2084 	ldr.w	r2, [r9, #132]	; 0x84
        if (fb->priv.actual_read_len != xfer) {
30011160:	42aa      	cmp	r2, r5
        count += fb->priv.actual_read_len;
30011162:	4492      	add	r10, r2
        buf   += fb->priv.actual_read_len;
30011164:	4417      	add	r7, r2
        len   -= fb->priv.actual_read_len;
30011166:	eba6 0602 	sub.w	r6, r6, r2
        if (fb->priv.actual_read_len != xfer) {
3001116a:	d126      	bne.n	300111ba <fastboot_usb_read+0xa6>
    while (len > 0) {
3001116c:	b32e      	cbz	r6, 300111ba <fastboot_usb_read+0xa6>
        xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
3001116e:	4635      	mov	r5, r6
30011170:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
30011174:	bf28      	it	cs
30011176:	f44f 4500 	movcs.w	r5, #32768	; 0x8000
        r = hal_usb_read(&fb->usb, fb->priv.read_ep, &rx);
3001117a:	aa02      	add	r2, sp, #8
3001117c:	f8d9 108c 	ldr.w	r1, [r9, #140]	; 0x8c
30011180:	4658      	mov	r0, r11
        rx.buf      = buf;
30011182:	9704      	str	r7, [sp, #16]
        rx.result   = 0;
30011184:	e9cd 4802 	strd	r4, r8, [r13, #8]
        rx.extra    = (void *)fb;
30011188:	e9cd 8906 	strd	r8, r9, [r13, #24]
        rx.buflen   = xfer;
3001118c:	9505      	str	r5, [sp, #20]
        r = hal_usb_read(&fb->usb, fb->priv.read_ep, &rx);
3001118e:	f7ff fd7d 	bl	30010c8c <hal_usb_read>
30011192:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        if (r < 0) {
30011196:	2800      	cmp	r0, #0
30011198:	9800      	ldr	r0, [sp, #0]
3001119a:	dad9      	bge.n	30011150 <fastboot_usb_read+0x3c>
            dprintf(ALWAYS, "usb_read() queue failed\n");
3001119c:	f240 50f0 	movw	r0, #1520	; 0x5f0
300111a0:	464c      	mov	r4, r9
300111a2:	f2c3 0002 	movt	r0, #12290	; 0x3002
300111a6:	f004 fd03 	bl	30015bb0 <_printf>
    fb->state = STATE_ERROR;
300111aa:	2303      	movs	r3, #3
    return -1;
300111ac:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
}
300111b0:	4638      	mov	r0, r7
    fb->state = STATE_ERROR;
300111b2:	6023      	str	r3, [r4, #0]
}
300111b4:	b009      	add	sp, #36	; 0x24
300111b6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
300111ba:	4657      	mov	r7, r10
300111bc:	f10a 031f 	add.w	r3, r10, #31
300111c0:	f023 0a1f 	bic.w	r10, r3, #31
    arch_invalidate_cache_range((addr_t)_buf, ROUNDUP(count, CACHE_LINE));
300111c4:	9801      	ldr	r0, [sp, #4]
300111c6:	4651      	mov	r1, r10
300111c8:	f7f0 eca4 	blx	30001b14 <arch_invalidate_cache_range>
}
300111cc:	4638      	mov	r0, r7
300111ce:	b009      	add	sp, #36	; 0x24
300111d0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            dprintf(ALWAYS, "usb_read() transaction failed\n");
300111d4:	f240 600c 	movw	r0, #1548	; 0x60c
300111d8:	464c      	mov	r4, r9
300111da:	f2c3 0002 	movt	r0, #12290	; 0x3002
300111de:	f004 fce7 	bl	30015bb0 <_printf>
            goto oops;
300111e2:	e7e2      	b.n	300111aa <fastboot_usb_read+0x96>
    int count = 0;
300111e4:	4657      	mov	r7, r10
300111e6:	e7ed      	b.n	300111c4 <fastboot_usb_read+0xb0>

300111e8 <fastboot_usb_write>:
{
300111e8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300111ec:	4692      	mov	r10, r2
300111ee:	b089      	sub	sp, #36	; 0x24
    if (fb->state == STATE_ERROR) {
300111f0:	6802      	ldr	r2, [r0, #0]
{
300111f2:	4604      	mov	r4, r0
    if (fb->state == STATE_ERROR) {
300111f4:	2a03      	cmp	r2, #3
300111f6:	d03c      	beq.n	30011272 <fastboot_usb_write+0x8a>
    while (len > 0) {
300111f8:	f1ba 0f00 	cmp.w	r10, #0
300111fc:	d04c      	beq.n	30011298 <fastboot_usb_write+0xb0>
    int count = 0;
300111fe:	2700      	movs	r7, #0
        event_wait(&fb->priv.usb_write_done);
30011200:	f100 0344 	add.w	r3, r0, #68	; 0x44
30011204:	f640 5931 	movw	r9, #3377	; 0xd31
30011208:	460d      	mov	r5, r1
        tx.result   = 0;
3001120a:	46b8      	mov	r8, r7
3001120c:	f2c3 0901 	movt	r9, #12289	; 0x3001
        event_wait(&fb->priv.usb_write_done);
30011210:	9301      	str	r3, [sp, #4]
30011212:	f100 0b94 	add.w	r11, r0, #148	; 0x94
30011216:	e00f      	b.n	30011238 <fastboot_usb_write+0x50>
30011218:	f000 fb62 	bl	300118e0 <event_wait_timeout>
        if (fb->priv.usb_write_status < 0) {
3001121c:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
3001121e:	2a00      	cmp	r2, #0
30011220:	db2f      	blt.n	30011282 <fastboot_usb_write+0x9a>
        count += fb->priv.actual_write_len;
30011222:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
        if (fb->priv.actual_write_len != xfer) { break; }
30011226:	42b2      	cmp	r2, r6
        count += fb->priv.actual_write_len;
30011228:	4417      	add	r7, r2
        buf   += fb->priv.actual_write_len;
3001122a:	4415      	add	r5, r2
        len   -= fb->priv.actual_write_len;
3001122c:	ebaa 0a02 	sub.w	r10, r10, r2
        if (fb->priv.actual_write_len != xfer) { break; }
30011230:	d123      	bne.n	3001127a <fastboot_usb_write+0x92>
    while (len > 0) {
30011232:	f1ba 0f00 	cmp.w	r10, #0
30011236:	d020      	beq.n	3001127a <fastboot_usb_write+0x92>
        xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
30011238:	4656      	mov	r6, r10
3001123a:	f5ba 4f00 	cmp.w	r10, #32768	; 0x8000
3001123e:	bf28      	it	cs
30011240:	f44f 4600 	movcs.w	r6, #32768	; 0x8000
        r = hal_usb_write(&fb->usb, fb->priv.write_ep, &tx);
30011244:	aa02      	add	r2, sp, #8
30011246:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
3001124a:	4658      	mov	r0, r11
        tx.buf      = buf;
3001124c:	9504      	str	r5, [sp, #16]
        tx.result   = 0;
3001124e:	e9cd 9802 	strd	r9, r8, [r13, #8]
        tx.extra    = (void *)fb;
30011252:	e9cd 8406 	strd	r8, r4, [r13, #24]
        tx.buflen   = xfer;
30011256:	9605      	str	r6, [sp, #20]
        r = hal_usb_write(&fb->usb, fb->priv.write_ep, &tx);
30011258:	f7ff fd1a 	bl	30010c90 <hal_usb_write>
3001125c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        if (r < 0) {
30011260:	2800      	cmp	r0, #0
30011262:	9801      	ldr	r0, [sp, #4]
30011264:	dad8      	bge.n	30011218 <fastboot_usb_write+0x30>
            dprintf(ALWAYS, "usb_write() queue failed\n");
30011266:	f240 602c 	movw	r0, #1580	; 0x62c
3001126a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001126e:	f004 fc9f 	bl	30015bb0 <_printf>
    fb->state = STATE_ERROR;
30011272:	2303      	movs	r3, #3
    return -1;
30011274:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
    fb->state = STATE_ERROR;
30011278:	6023      	str	r3, [r4, #0]
}
3001127a:	4638      	mov	r0, r7
3001127c:	b009      	add	sp, #36	; 0x24
3001127e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            dprintf(ALWAYS, "usb_write() transaction failed\n");
30011282:	f240 6048 	movw	r0, #1608	; 0x648
    return -1;
30011286:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
            dprintf(ALWAYS, "usb_write() transaction failed\n");
3001128a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001128e:	f004 fc8f 	bl	30015bb0 <_printf>
    fb->state = STATE_ERROR;
30011292:	2303      	movs	r3, #3
30011294:	6023      	str	r3, [r4, #0]
30011296:	e7f0      	b.n	3001127a <fastboot_usb_write+0x92>
    int count = 0;
30011298:	4657      	mov	r7, r10
3001129a:	e7ee      	b.n	3001127a <fastboot_usb_write+0x92>

3001129c <fastboot_init>:


void fastboot_init(void *args)
{
3001129c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    fastboot_t *fb = (fastboot_t *)args;
    usb_t *usb = &fb->usb;
    fb->state = STATE_OFFLINE;
    fb->priv.read_ep = ENDPOINT_OUT_ADDR;
    fb->priv.write_ep = ENDPOINT_IN_ADDR;
    usb->priv.max_eps = 8;
3001129e:	2208      	movs	r2, #8
{
300112a0:	4604      	mov	r4, r0
    fb->priv.read_ep = ENDPOINT_OUT_ADDR;
300112a2:	2601      	movs	r6, #1
    usb->priv.ep0_mps = 512;
300112a4:	f44f 7300 	mov.w	r3, #512	; 0x200
    fb->state = STATE_OFFLINE;
300112a8:	2700      	movs	r7, #0
    event_init(&fb->priv.usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112aa:	3028      	adds	r0, #40	; 0x28
    usb->priv.ep0_mps = 512;
300112ac:	f8c0 312c 	str.w	r3, [r0, #300]	; 0x12c
    event_init(&fb->priv.usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112b0:	4639      	mov	r1, r7
    usb->priv.max_eps = 8;
300112b2:	f8c0 2128 	str.w	r2, [r0, #296]	; 0x128
    event_init(&fb->priv.usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112b6:	4632      	mov	r2, r6
    fb->state = STATE_OFFLINE;
300112b8:	6027      	str	r7, [r4, #0]
    usb_t *usb = &fb->usb;
300112ba:	f104 0594 	add.w	r5, r4, #148	; 0x94
    fb->priv.write_ep = ENDPOINT_IN_ADDR;
300112be:	e9c4 6623 	strd	r6, r6, [r4, #140]	; 0x8c
    event_init(&fb->priv.usb_online, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112c2:	f000 faf7 	bl	300118b4 <event_init>
    event_init(&fb->priv.usb_write_done, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112c6:	4632      	mov	r2, r6
300112c8:	4639      	mov	r1, r7
300112ca:	f104 0044 	add.w	r0, r4, #68	; 0x44
300112ce:	f000 faf1 	bl	300118b4 <event_init>
    event_init(&fb->priv.usb_read_done, 0, EVENT_FLAG_AUTOUNSIGNAL);
300112d2:	4632      	mov	r2, r6
300112d4:	4639      	mov	r1, r7
300112d6:	f104 0060 	add.w	r0, r4, #96	; 0x60
300112da:	f000 faeb 	bl	300118b4 <event_init>
    list_initialize(&usb->cb_list);
    hal_usb_creat_handle(usb, usb->global_base_id, usb->global_phys_id);
300112de:	e9d4 1225 	ldrd	r1, r2, [r4, #148]	; 0x94
300112e2:	4628      	mov	r0, r5
    list_initialize(&usb->cb_list);
300112e4:	f104 03a4 	add.w	r3, r4, #164	; 0xa4
    hal_usb_setup(usb, &config);
    hal_usb_add_string(usb, usb->priv.manufacturer, 1);
    hal_usb_add_string(usb, usb->priv.product, 2);
    hal_usb_add_string(usb, usb->priv.serialno, 3);
    hal_usb_add_string(usb, usb->priv.cfg, 4);
    hal_usb_append_interface_lowspeed(usb, fs_if_descriptor,
300112e8:	f645 0704 	movw	r7, #22532	; 0x5804
    list->prev = list->next = list;
300112ec:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
300112f0:	f2c3 0702 	movt	r7, #12290	; 0x3002
300112f4:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
    hal_usb_creat_handle(usb, usb->global_base_id, usb->global_phys_id);
300112f8:	f7ff fccc 	bl	30010c94 <hal_usb_creat_handle>
    hal_usb_init(usb);
300112fc:	4628      	mov	r0, r5
300112fe:	f7ff fcc3 	bl	30010c88 <hal_usb_init>
    hal_usb_setup(usb, &config);
30011302:	f245 2194 	movw	r1, #21140	; 0x5294
30011306:	4628      	mov	r0, r5
30011308:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001130c:	f7ff fca6 	bl	30010c5c <hal_usb_setup>
    hal_usb_add_string(usb, usb->priv.manufacturer, 1);
30011310:	4632      	mov	r2, r6
30011312:	f8d4 1130 	ldr.w	r1, [r4, #304]	; 0x130
30011316:	4628      	mov	r0, r5
30011318:	f7ff fb14 	bl	30010944 <hal_usb_add_string>
    hal_usb_add_string(usb, usb->priv.product, 2);
3001131c:	f8d4 1134 	ldr.w	r1, [r4, #308]	; 0x134
30011320:	4628      	mov	r0, r5
30011322:	2202      	movs	r2, #2
30011324:	f7ff fb0e 	bl	30010944 <hal_usb_add_string>
    hal_usb_add_string(usb, usb->priv.serialno, 3);
30011328:	f8d4 1138 	ldr.w	r1, [r4, #312]	; 0x138
3001132c:	4628      	mov	r0, r5
3001132e:	2203      	movs	r2, #3
30011330:	f7ff fb08 	bl	30010944 <hal_usb_add_string>
    hal_usb_add_string(usb, usb->priv.cfg, 4);
30011334:	f8d4 113c 	ldr.w	r1, [r4, #316]	; 0x13c
30011338:	4628      	mov	r0, r5
3001133a:	2204      	movs	r2, #4
3001133c:	f7ff fb02 	bl	30010944 <hal_usb_add_string>
    hal_usb_append_interface_lowspeed(usb, fs_if_descriptor,
30011340:	4639      	mov	r1, r7
30011342:	4628      	mov	r0, r5
30011344:	2217      	movs	r2, #23
30011346:	f7ff faeb 	bl	30010920 <hal_usb_append_interface_lowspeed>
                                      sizeof(fs_if_descriptor));
    hal_usb_append_interface_highspeed(usb, hs_if_descriptor,
3001134a:	4628      	mov	r0, r5
3001134c:	2217      	movs	r2, #23
3001134e:	f107 0118 	add.w	r1, r7, #24
30011352:	f7ff fae1 	bl	30010918 <hal_usb_append_interface_highspeed>
                                       sizeof(hs_if_descriptor));
    hal_usb_register_callback(usb, fastboot_usb_cb, (void *)fb);
30011356:	f640 5165 	movw	r1, #3429	; 0xd65
3001135a:	4622      	mov	r2, r4
3001135c:	4628      	mov	r0, r5
3001135e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30011362:	f7ff fb31 	bl	300109c8 <hal_usb_register_callback>
    hal_winusb_init(usb, usb->priv.vendor_id, usb->priv.product_id,
30011366:	f8b4 312c 	ldrh.w	r3, [r4, #300]	; 0x12c
3001136a:	4628      	mov	r0, r5
3001136c:	f8b4 212a 	ldrh.w	r2, [r4, #298]	; 0x12a
30011370:	f8b4 1128 	ldrh.w	r1, [r4, #296]	; 0x128
30011374:	f000 f876 	bl	30011464 <hal_winusb_init>
                    usb->priv.version_id);
    register_int_handler(usb->priv.irq_num, &hal_usb_irq, (void *)usb);
30011378:	f640 4159 	movw	r1, #3161	; 0xc59
3001137c:	462a      	mov	r2, r5
3001137e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30011382:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
30011386:	f7ef f993 	bl	300006b0 <register_int_handler>
    unmask_interrupt(usb->priv.irq_num);
3001138a:	f8d4 011c 	ldr.w	r0, [r4, #284]	; 0x11c
3001138e:	f7ef f9e1 	bl	30000754 <unmask_interrupt>
    hal_usb_start(usb);
30011392:	4628      	mov	r0, r5
}
30011394:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    hal_usb_start(usb);
30011398:	f7ff bc64 	b.w	30010c64 <hal_usb_start>

3001139c <fastboot_stop>:

void fastboot_stop(void *args)
{
3001139c:	b510      	push	{r4, r14}
    fastboot_t *fb = (fastboot_t *)args;
    mask_interrupt(fb->usb.priv.irq_num);
    hal_usb_stop(&fb->usb);
3001139e:	f100 0494 	add.w	r4, r0, #148	; 0x94
    mask_interrupt(fb->usb.priv.irq_num);
300113a2:	f8d0 011c 	ldr.w	r0, [r0, #284]	; 0x11c
300113a6:	f7ef f9ad 	bl	30000704 <mask_interrupt>
    hal_usb_stop(&fb->usb);
300113aa:	4620      	mov	r0, r4
300113ac:	f7ff fc64 	bl	30010c78 <hal_usb_stop>
    hal_usb_release_handle(&fb->usb);
300113b0:	4620      	mov	r0, r4
}
300113b2:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_usb_release_handle(&fb->usb);
300113b6:	f7ff bc93 	b.w	30010ce0 <hal_usb_release_handle>
300113ba:	bf00      	nop

300113bc <winusb_dev_event_cb>:
                                    const struct hal_usb_callback_args *args)
{
    usb_t *usb = args->usb;
    dprintf(INFO, "%s op:%d\n", __FUNCTION__, op);

    if (op == USB_CB_SETUP_MSG) {
300113bc:	2906      	cmp	r1, #6
300113be:	d001      	beq.n	300113c4 <winusb_dev_event_cb+0x8>
                    setup->index, setup->length);
        }
    }

    return NO_ERROR;
}
300113c0:	2000      	movs	r0, #0
300113c2:	4770      	bx	r14
{
300113c4:	b530      	push	{r4, r5, r14}
        const struct usb_setup *setup = args->setup;
300113c6:	6814      	ldr	r4, [r2, #0]
        if (((setup->request_type & TYPE_MASK) == TYPE_VENDOR)
300113c8:	7823      	ldrb	r3, [r4, #0]
300113ca:	f003 017f 	and.w	r1, r3, #127	; 0x7f
300113ce:	2940      	cmp	r1, #64	; 0x40
    usb_t *usb = args->usb;
300113d0:	6850      	ldr	r0, [r2, #4]
{
300113d2:	b085      	sub	sp, #20
        if (((setup->request_type & TYPE_MASK) == TYPE_VENDOR)
300113d4:	d025      	beq.n	30011422 <winusb_dev_event_cb+0x66>
        else if (((setup->request_type & TYPE_MASK) == TYPE_VENDOR)
300113d6:	2941      	cmp	r1, #65	; 0x41
300113d8:	d101      	bne.n	300113de <winusb_dev_event_cb+0x22>
                 && ((setup->request_type & DIR_MASK) == DIR_IN)
300113da:	061a      	lsls	r2, r3, #24
300113dc:	d432      	bmi.n	30011444 <winusb_dev_event_cb+0x88>
        else if (((setup->request_type & TYPE_MASK) != TYPE_STANDARD)
300113de:	f013 0f60 	tst.w	r3, #96	; 0x60
300113e2:	d107      	bne.n	300113f4 <winusb_dev_event_cb+0x38>
                     && !IS_VALID_USB_STD_REQUEST(setup->request))) {
300113e4:	7863      	ldrb	r3, [r4, #1]
                 || ((setup->request_type & TYPE_MASK) == TYPE_STANDARD
300113e6:	2b03      	cmp	r3, #3
300113e8:	bf18      	it	ne
300113ea:	2b01      	cmpne	r3, #1
300113ec:	d916      	bls.n	3001141c <winusb_dev_event_cb+0x60>
                     && !IS_VALID_USB_STD_REQUEST(setup->request))) {
300113ee:	3b05      	subs	r3, #5
300113f0:	2b06      	cmp	r3, #6
300113f2:	d913      	bls.n	3001141c <winusb_dev_event_cb+0x60>
            usbc_ep0_stall(usb);
300113f4:	f7fb fae2 	bl	3000c9bc <usbc_ep0_stall>
            dprintf(CRITICAL,
300113f8:	f240 616c 	movw	r1, #1644	; 0x66c
300113fc:	f240 6080 	movw	r0, #1664	; 0x680
30011400:	88e5      	ldrh	r5, [r4, #6]
30011402:	7863      	ldrb	r3, [r4, #1]
30011404:	7822      	ldrb	r2, [r4, #0]
30011406:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001140a:	9502      	str	r5, [sp, #8]
3001140c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011410:	88a5      	ldrh	r5, [r4, #4]
30011412:	9501      	str	r5, [sp, #4]
30011414:	8864      	ldrh	r4, [r4, #2]
30011416:	9400      	str	r4, [sp, #0]
30011418:	f004 fbca 	bl	30015bb0 <_printf>
}
3001141c:	2000      	movs	r0, #0
3001141e:	b005      	add	sp, #20
30011420:	bd30      	pop	{r4, r5, r15}
                && ((setup->request_type & DIR_MASK) == DIR_IN)
30011422:	0619      	lsls	r1, r3, #24
30011424:	d5db      	bpl.n	300113de <winusb_dev_event_cb+0x22>
                && (setup->request == 0x01)
30011426:	7862      	ldrb	r2, [r4, #1]
30011428:	2a01      	cmp	r2, #1
3001142a:	d1d8      	bne.n	300113de <winusb_dev_event_cb+0x22>
                && (setup->index == EXTENDED_COMPATIBILITY_ID)) {
3001142c:	88a2      	ldrh	r2, [r4, #4]
3001142e:	2a04      	cmp	r2, #4
30011430:	d1d5      	bne.n	300113de <winusb_dev_event_cb+0x22>
            usbc_ep0_send(usb, (void *)&ext_comp_desc,
30011432:	f645 0148 	movw	r1, #22600	; 0x5848
30011436:	88e3      	ldrh	r3, [r4, #6]
30011438:	2228      	movs	r2, #40	; 0x28
3001143a:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001143e:	f7fb ff51 	bl	3000d2e4 <usbc_ep0_send>
            dprintf(INFO, "%s: Get windows OS feature descriptor.\n",
30011442:	e7eb      	b.n	3001141c <winusb_dev_event_cb+0x60>
                 && (setup->request == 0x01)
30011444:	7862      	ldrb	r2, [r4, #1]
30011446:	2a01      	cmp	r2, #1
30011448:	d1c9      	bne.n	300113de <winusb_dev_event_cb+0x22>
                 && ((setup->index == EXTENDED_PROPERTIES_ID)
3001144a:	88a2      	ldrh	r2, [r4, #4]
3001144c:	2a00      	cmp	r2, #0
3001144e:	bf18      	it	ne
30011450:	2a05      	cmpne	r2, #5
30011452:	d1c4      	bne.n	300113de <winusb_dev_event_cb+0x22>
            usbc_ep0_send(usb, (void *)&ext_prop_desc,
30011454:	88e3      	ldrh	r3, [r4, #6]
30011456:	4902      	ldr	r1, [pc, #8]	; (30011460 <winusb_dev_event_cb+0xa4>)
30011458:	2244      	movs	r2, #68	; 0x44
3001145a:	f7fb ff43 	bl	3000d2e4 <usbc_ep0_send>
            dprintf(INFO, "%s: Get windows extended properties descriptor.\n",
3001145e:	e7dd      	b.n	3001141c <winusb_dev_event_cb+0x60>
30011460:	30025870 	.word	0x30025870

30011464 <hal_winusb_init>:

void hal_winusb_init(usb_t *usb, uint16_t vid, uint16_t pid, uint16_t ver)
{
30011464:	b510      	push	{r4, r14}
30011466:	4604      	mov	r4, r0
    hal_set_usb_id(usb, vid, pid, ver);
30011468:	f7ff fa5e 	bl	30010928 <hal_set_usb_id>
    hal_usb_add_string(usb, (const char *)usb_str_os, 238);
3001146c:	f245 21e8 	movw	r1, #21224	; 0x52e8
30011470:	4620      	mov	r0, r4
30011472:	22ee      	movs	r2, #238	; 0xee
30011474:	f2c3 0102 	movt	r1, #12290	; 0x3002
30011478:	f7ff fa64 	bl	30010944 <hal_usb_add_string>
    hal_usb_register_callback(usb, winusb_dev_event_cb, NULL);
3001147c:	f241 31bd 	movw	r1, #5053	; 0x13bd
30011480:	4620      	mov	r0, r4
30011482:	f2c3 0101 	movt	r1, #12289	; 0x3001
30011486:	2200      	movs	r2, #0
}
30011488:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_usb_register_callback(usb, winusb_dev_event_cb, NULL);
3001148c:	f7ff ba9c 	b.w	300109c8 <hal_usb_register_callback>

30011490 <hal_wdg_creat_handle>:
//!
//! \return watchdog handle
//
//*****************************************************************************
bool hal_wdg_creat_handle(void **handle,uint32_t wdg_res_glb_idx)
{
30011490:	b5f0      	push	{r4, r5, r6, r7, r14}
    wdg_instance_t  *wdgInstance = NULL;

    if(wdg_spin_lock !=SPIN_LOCK_INITIAL_VALUE){
30011492:	f64c 6544 	movw	r5, #52804	; 0xce44
{
30011496:	b083      	sub	sp, #12
30011498:	4606      	mov	r6, r0
    if(wdg_spin_lock !=SPIN_LOCK_INITIAL_VALUE){
3001149a:	f2c3 0502 	movt	r5, #12290	; 0x3002
3001149e:	682b      	ldr	r3, [r5, #0]
300114a0:	b10b      	cbz	r3, 300114a6 <hal_wdg_creat_handle+0x16>
    *lock = SPIN_LOCK_INITIAL_VALUE;
300114a2:	2300      	movs	r3, #0
300114a4:	602b      	str	r3, [r5, #0]
    paddr_t phy_addr = 0;
300114a6:	2700      	movs	r7, #0
    int32_t wdg_really_num = 0;
300114a8:	aa02      	add	r2, sp, #8
    ret = res_get_info_by_id(wdg_res_glb_idx,&phy_addr,&wdg_really_num);
300114aa:	4608      	mov	r0, r1
300114ac:	4669      	mov	r1, r13
    int32_t wdg_really_num = 0;
300114ae:	f842 7d04 	str.w	r7, [r2, #-4]!
    paddr_t phy_addr = 0;
300114b2:	9700      	str	r7, [sp, #0]
    ret = res_get_info_by_id(wdg_res_glb_idx,&phy_addr,&wdg_really_num);
300114b4:	f7fe fb9a 	bl	3000fbec <res_get_info_by_id>
    if(ret == -1){
300114b8:	b240      	sxtb	r0, r0
300114ba:	3001      	adds	r0, #1
300114bc:	d01d      	beq.n	300114fa <hal_wdg_creat_handle+0x6a>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300114be:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300114c2:	061b      	lsls	r3, r3, #24
300114c4:	d516      	bpl.n	300114f4 <hal_wdg_creat_handle+0x64>
300114c6:	f64c 20a4 	movw	r0, #51876	; 0xcaa4
    *lock = 1;
300114ca:	2101      	movs	r1, #1
300114cc:	2300      	movs	r3, #0
300114ce:	f2c3 0002 	movt	r0, #12290	; 0x3002
300114d2:	6029      	str	r1, [r5, #0]
300114d4:	4602      	mov	r2, r0
        if (g_WdgInstance[i].occupied != 1)
300114d6:	f892 1060 	ldrb.w	r1, [r2, #96]	; 0x60
300114da:	2901      	cmp	r1, #1
300114dc:	f102 0274 	add.w	r2, r2, #116	; 0x74
300114e0:	d10e      	bne.n	30011500 <hal_wdg_creat_handle+0x70>
300114e2:	3301      	adds	r3, #1
    for (i=0; i < wdg_really_num_max; i++)
300114e4:	2b08      	cmp	r3, #8
300114e6:	d1f6      	bne.n	300114d6 <hal_wdg_creat_handle+0x46>
    *lock = 0;
300114e8:	2000      	movs	r0, #0
300114ea:	6028      	str	r0, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300114ec:	b12f      	cbz	r7, 300114fa <hal_wdg_creat_handle+0x6a>
    __asm__ volatile("cpsie i");
300114ee:	b662      	cpsie	i
    mutex_init(&wdgInstance->wdgMutex);
#endif

    *handle = wdgInstance;
    return true;
}
300114f0:	b003      	add	sp, #12
300114f2:	bdf0      	pop	{r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
300114f4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
300114f6:	2701      	movs	r7, #1
300114f8:	e7e5      	b.n	300114c6 <hal_wdg_creat_handle+0x36>
        return false;
300114fa:	2000      	movs	r0, #0
}
300114fc:	b003      	add	sp, #12
300114fe:	bdf0      	pop	{r4, r5, r6, r7, r15}
            memset(buffer,0,sizeof(wdg_instance_t));
30011500:	2100      	movs	r1, #0
            uint8_t *buffer = (uint8_t *)&g_WdgInstance[i];
30011502:	ebc3 04c3 	rsb	r4, r3, r3, lsl #3
            memset(buffer,0,sizeof(wdg_instance_t));
30011506:	2274      	movs	r2, #116	; 0x74
            uint8_t *buffer = (uint8_t *)&g_WdgInstance[i];
30011508:	eb03 0384 	add.w	r3, r3, r4, lsl #2
3001150c:	eb00 0483 	add.w	r4, r0, r3, lsl #2
            memset(buffer,0,sizeof(wdg_instance_t));
30011510:	4620      	mov	r0, r4
30011512:	f003 ea2e 	blx	30014970 <memset>
    *controllerTable = &s_WdgDrvInterface;
30011516:	f240 7328 	movw	r3, #1832	; 0x728
                g_WdgInstance[i].occupied = 1;
3001151a:	2201      	movs	r2, #1
    *controllerTable = &s_WdgDrvInterface;
3001151c:	f2c3 0302 	movt	r3, #12290	; 0x3002
                g_WdgInstance[i].controllerTable->get_default_config(&(g_WdgInstance[i].wdg_cfg));
30011520:	4620      	mov	r0, r4
    *controllerTable = &s_WdgDrvInterface;
30011522:	65e3      	str	r3, [r4, #92]	; 0x5c
                g_WdgInstance[i].occupied = 1;
30011524:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
                g_WdgInstance[i].controllerTable->get_default_config(&(g_WdgInstance[i].wdg_cfg));
30011528:	f7fc fa12 	bl	3000d950 <wdg_get_default_config>
                g_WdgInstance[i].wdg_res.wdg_really_num = wdg_really_num;
3001152c:	9a01      	ldr	r2, [sp, #4]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
3001152e:	f240 63cc 	movw	r3, #1740	; 0x6cc
    *lock = 0;
30011532:	2100      	movs	r1, #0
30011534:	f102 0c02 	add.w	r12, r2, #2
                g_WdgInstance[i].wdg_res.wdg_phy_addr = phy_addr;
30011538:	9800      	ldr	r0, [sp, #0]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
3001153a:	f2c3 0302 	movt	r3, #12290	; 0x3002
                g_WdgInstance[i].wdg_res.wdg_really_num = wdg_really_num;
3001153e:	e9c4 2019 	strd	r2, r0, [r4, #100]	; 0x64
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
30011542:	eb03 03cc 	add.w	r3, r3, r12, lsl #3
30011546:	6029      	str	r1, [r5, #0]
30011548:	7a1a      	ldrb	r2, [r3, #8]
                g_WdgInstance[i].wdg_cfg.wdg_ext_reset_cfg.enableSysExtReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableExtReset;
3001154a:	7a5b      	ldrb	r3, [r3, #9]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
3001154c:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
                g_WdgInstance[i].wdg_cfg.wdg_ext_reset_cfg.enableSysExtReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableExtReset;
30011550:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011554:	b107      	cbz	r7, 30011558 <hal_wdg_creat_handle+0xc8>
    __asm__ volatile("cpsie i");
30011556:	b662      	cpsie	i
    *handle = wdgInstance;
30011558:	6034      	str	r4, [r6, #0]
    return true;
3001155a:	2001      	movs	r0, #1
}
3001155c:	b003      	add	sp, #12
3001155e:	bdf0      	pop	{r4, r5, r6, r7, r15}

30011560 <hal_wdg_release_handle>:
//*****************************************************************************
bool hal_wdg_release_handle(void *handle)
{
    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
30011560:	4603      	mov	r3, r0
30011562:	b120      	cbz	r0, 3001156e <hal_wdg_release_handle+0xe>

    l_wdgInstance = (wdg_instance_t *)handle;
    l_wdgInstance->occupied = 0;
30011564:	2200      	movs	r2, #0

#if 0
    mutex_destroy(&l_wdgInstance->wdgMutex);
#endif

    return true;
30011566:	2001      	movs	r0, #1
    l_wdgInstance->occupied = 0;
30011568:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
    return true;
3001156c:	4770      	bx	r14
}
3001156e:	4770      	bx	r14

30011570 <hal_wdg_init>:
{
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;
    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
30011570:	b1d0      	cbz	r0, 300115a8 <hal_wdg_init+0x38>
{
30011572:	b538      	push	{r3, r4, r5, r14}

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited){
30011574:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
30011578:	b9a3      	cbnz	r3, 300115a4 <hal_wdg_init+0x34>
#if 0
    l_wdgInstance->wdg_cfg.wdg_ctrl_config.clockSource = wdg_app_cfg->clocksource;
    l_wdgInstance->wdg_cfg.wdg_ctrl_config.prescaler = wdg_app_cfg->divisor;
#endif

    if(l_wdgInstance->controllerTable->init){
3001157a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    l_wdgInstance->wdg_cfg.wdg_refresh_config.wdgModeSelect = wdg_app_cfg->workMode;
3001157c:	680a      	ldr	r2, [r1, #0]
3001157e:	7502      	strb	r2, [r0, #20]
    if(l_wdgInstance->controllerTable->init){
30011580:	699b      	ldr	r3, [r3, #24]
    l_wdgInstance->wdg_cfg.refresh_seq_delta = wdg_app_cfg->seqDeltaValue;
30011582:	68ca      	ldr	r2, [r1, #12]
    l_wdgInstance->wdg_cfg.refresh_wind_limit = wdg_app_cfg->windowLimitValue;
30011584:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    l_wdgInstance->wdg_cfg.refresh_seq_delta = wdg_app_cfg->seqDeltaValue;
30011588:	e9c0 4206 	strd	r4, r2, [r0, #24]
    l_wdgInstance->wdg_cfg.wdg_timeout = wdg_app_cfg->timeoutValue;
3001158c:	6105      	str	r5, [r0, #16]
    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);
3001158e:	6e82      	ldr	r2, [r0, #104]	; 0x68
    if(l_wdgInstance->controllerTable->init){
30011590:	b143      	cbz	r3, 300115a4 <hal_wdg_init+0x34>
30011592:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->init((wdg_reg_type_t *)wdg_base_addr,&(l_wdgInstance->wdg_cfg));
30011594:	4610      	mov	r0, r2
30011596:	4621      	mov	r1, r4
30011598:	4798      	blx	r3
    }

    if(!ret){
3001159a:	b118      	cbz	r0, 300115a4 <hal_wdg_init+0x34>
        LTRACEF("hal_wdg_init failed\n");
        return false;
    }

    l_wdgInstance->wdg_inited = true;
3001159c:	2301      	movs	r3, #1
3001159e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70

    return true;
}
300115a2:	bd38      	pop	{r3, r4, r5, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
300115a4:	2000      	movs	r0, #0
}
300115a6:	bd38      	pop	{r3, r4, r5, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
300115a8:	2000      	movs	r0, #0
}
300115aa:	4770      	bx	r14

300115ac <hal_wdg_deinit>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
300115ac:	b338      	cbz	r0, 300115fe <hal_wdg_deinit+0x52>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited == false){
300115ae:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
300115b2:	b323      	cbz	r3, 300115fe <hal_wdg_deinit+0x52>
        LTRACEF("hal_wdg_init has not inited\n");
        return false;
    }

    if(l_wdgInstance->controllerTable->deinit){
300115b4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
300115b6:	69db      	ldr	r3, [r3, #28]
300115b8:	b30b      	cbz	r3, 300115fe <hal_wdg_deinit+0x52>
{
300115ba:	b510      	push	{r4, r14}
300115bc:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->deinit((wdg_reg_type_t *)wdg_base_addr);
300115be:	6e80      	ldr	r0, [r0, #104]	; 0x68
300115c0:	4798      	blx	r3
    }

    if(!ret){
300115c2:	b188      	cbz	r0, 300115e8 <hal_wdg_deinit+0x3c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300115c4:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300115c8:	f013 0380 	ands.w	r3, r3, #128	; 0x80
300115cc:	d10e      	bne.n	300115ec <hal_wdg_deinit+0x40>
    __asm__ volatile("cpsid i");
300115ce:	b672      	cpsid	i
    wdgInstance->occupied = 0;
300115d0:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    *lock = 0;
300115d4:	f64c 6244 	movw	r2, #52804	; 0xce44
300115d8:	f2c3 0202 	movt	r2, #12290	; 0x3002
300115dc:	6013      	str	r3, [r2, #0]
    __asm__ volatile("cpsie i");
300115de:	b662      	cpsie	i
    }

    //release wdg instance
    hal_wdg_release_instance(l_wdgInstance);

    l_wdgInstance->wdg_inited = false;
300115e0:	2300      	movs	r3, #0
300115e2:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70

    return true;
}
300115e6:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
300115e8:	2000      	movs	r0, #0
}
300115ea:	bd10      	pop	{r4, r15}
300115ec:	f64c 6344 	movw	r3, #52804	; 0xce44
    wdgInstance->occupied = 0;
300115f0:	2200      	movs	r2, #0
300115f2:	f2c3 0302 	movt	r3, #12290	; 0x3002
300115f6:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
300115fa:	601a      	str	r2, [r3, #0]
300115fc:	e7f0      	b.n	300115e0 <hal_wdg_deinit+0x34>
    HAL_WDG_ASSERT_PARAMETER(handle);
300115fe:	2000      	movs	r0, #0
}
30011600:	4770      	bx	r14
30011602:	bf00      	nop

30011604 <hal_wdg_enable>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
30011604:	b198      	cbz	r0, 3001162e <hal_wdg_enable+0x2a>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if((l_wdgInstance->wdg_inited == false) || (l_wdgInstance->wdg_enabled == true)){
30011606:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
3001160a:	b183      	cbz	r3, 3001162e <hal_wdg_enable+0x2a>
3001160c:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
30011610:	b96b      	cbnz	r3, 3001162e <hal_wdg_enable+0x2a>
        LTRACEF("hal_wdg_init has not inited or enable wdg_inited:%d  wdg_enabled:%d\n",l_wdgInstance->wdg_inited,l_wdgInstance->wdg_enabled);
        return false;
    }

    if(l_wdgInstance->controllerTable->enable){
30011612:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
30011614:	6a5b      	ldr	r3, [r3, #36]	; 0x24
30011616:	b153      	cbz	r3, 3001162e <hal_wdg_enable+0x2a>
{
30011618:	b510      	push	{r4, r14}
3001161a:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->enable((wdg_reg_type_t *)wdg_base_addr);
3001161c:	6e80      	ldr	r0, [r0, #104]	; 0x68
3001161e:	4798      	blx	r3
    }

    if(!ret){
30011620:	b118      	cbz	r0, 3001162a <hal_wdg_enable+0x26>
        LTRACEF("hal_wdg_enable failed\n");
        return false;
    }

    l_wdgInstance->wdg_enabled = true;
30011622:	2301      	movs	r3, #1
30011624:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71

    return true;
}
30011628:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
3001162a:	2000      	movs	r0, #0
}
3001162c:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
3001162e:	2000      	movs	r0, #0
}
30011630:	4770      	bx	r14
30011632:	bf00      	nop

30011634 <hal_wdg_enable_interrupts>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
30011634:	b138      	cbz	r0, 30011646 <hal_wdg_enable_interrupts+0x12>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited == false){
30011636:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
3001163a:	b123      	cbz	r3, 30011646 <hal_wdg_enable_interrupts+0x12>
        LTRACEF("hal_wdg_enable_interrupts has not inited wdg_inited:%d\n",l_wdgInstance->wdg_inited);
        return false;
    }

    if(l_wdgInstance->controllerTable->enable_interrupts){
3001163c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
3001163e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
30011640:	b10b      	cbz	r3, 30011646 <hal_wdg_enable_interrupts+0x12>
        ret = l_wdgInstance->controllerTable->enable_interrupts((wdg_reg_type_t *)wdg_base_addr);
30011642:	6e80      	ldr	r0, [r0, #104]	; 0x68
30011644:	4718      	bx	r3
        LTRACEF("hal_wdg_enable_interrupts failed\n");
        return false;
    }

    return true;
}
30011646:	2000      	movs	r0, #0
30011648:	4770      	bx	r14
3001164a:	bf00      	nop

3001164c <hal_wdg_set_timeout>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
3001164c:	b138      	cbz	r0, 3001165e <hal_wdg_set_timeout+0x12>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(!l_wdgInstance->wdg_inited){
3001164e:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
30011652:	b123      	cbz	r3, 3001165e <hal_wdg_set_timeout+0x12>
        LTRACEF("hal_wdg_set_timeout does not inited\n");
        return false;
    }

    if(l_wdgInstance->controllerTable->set_timeout){
30011654:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
30011656:	685b      	ldr	r3, [r3, #4]
30011658:	b10b      	cbz	r3, 3001165e <hal_wdg_set_timeout+0x12>
        ret = l_wdgInstance->controllerTable->set_timeout((wdg_reg_type_t *)wdg_base_addr,timeout_ms);
3001165a:	6e80      	ldr	r0, [r0, #104]	; 0x68
3001165c:	4718      	bx	r3
        LTRACEF("hal_wdg_set_timeout failed\n");
        return false;
    }

    return true;
}
3001165e:	2000      	movs	r0, #0
30011660:	4770      	bx	r14
30011662:	bf00      	nop

30011664 <threadload>:

    return 0;
}

static enum handler_return threadload(struct timer *t, lk_time_t now, void *arg)
{
30011664:	e92d 4df0 	stmdb	r13!, {r4, r5, r6, r7, r8, r10, r11, r14}
    for (uint i = 0; i < SMP_MAX_CPUS; i++) {
        /* dont display time for inactiv cpus */
        if (!mp_is_cpu_active(i))
            continue;

        lk_bigtime_t idle_time = thread_stats[i].idle_time;
30011668:	f24d 1558 	movw	r5, #53592	; 0xd158
{
3001166c:	b088      	sub	sp, #32
        lk_bigtime_t idle_time = thread_stats[i].idle_time;
3001166e:	f2c3 0502 	movt	r5, #12290	; 0x3002
30011672:	e9d5 3400 	ldrd	r3, r4, [r5]
30011676:	e9cd 3406 	strd	r3, r4, [r13, #24]
3001167a:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}

static inline enum handler_return mp_mbx_reschedule_irq(void) { return 0; }

// only one cpu exists in UP and if you're calling these functions, it's active...
static inline int mp_is_cpu_active(uint cpu) { return 1; }
static inline int mp_is_cpu_idle(uint cpu) { return (get_current_thread()->flags & THREAD_FLAG_IDLE) != 0; }
3001167e:	6a1b      	ldr	r3, [r3, #32]

        /* if the cpu is currently idle, add the time since it went idle up until now to the idle counter */
        bool is_idle = !!mp_is_cpu_idle(i);
        if (is_idle) {
30011680:	06db      	lsls	r3, r3, #27
30011682:	f100 808a 	bmi.w	3001179a <threadload+0x136>
            idle_time += current_time_hires() - thread_stats[i].last_idle_timestamp;
        }

        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
30011686:	f64c 6848 	movw	r8, #52808	; 0xce48
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
3001168a:	2300      	movs	r3, #0
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
3001168c:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
30011690:	f2c3 0802 	movt	r8, #12290	; 0x3002
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
30011694:	f244 2240 	movw	r2, #16960	; 0x4240
        uint busypercent = (busy_time * 10000) / (1000000);

        printf("cpu %u LOAD: "
30011698:	f64c 6450 	movw	r4, #52816	; 0xce50
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
3001169c:	f2c0 020f 	movt	r2, #15
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
300116a0:	e9d8 6700 	ldrd	r6, r7, [r8]
        printf("cpu %u LOAD: "
300116a4:	f2c3 0402 	movt	r4, #12290	; 0x3002
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
300116a8:	1b80      	subs	r0, r0, r6
300116aa:	eb61 0107 	sbc.w	r1, r1, r7
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
300116ae:	428b      	cmp	r3, r1
300116b0:	bf08      	it	eq
300116b2:	4282      	cmpeq	r2, r0
300116b4:	bf38      	it	cc
300116b6:	4610      	movcc	r0, r2
300116b8:	f244 2240 	movw	r2, #16960	; 0x4240
300116bc:	bf38      	it	cc
300116be:	4619      	movcc	r1, r3
300116c0:	f2c0 020f 	movt	r2, #15
300116c4:	2300      	movs	r3, #0
300116c6:	1a16      	subs	r6, r2, r0
300116c8:	eb63 0701 	sbc.w	r7, r3, r1
        uint busypercent = (busy_time * 10000) / (1000000);
300116cc:	00b0      	lsls	r0, r6, #2
300116ce:	ea4f 0c87 	mov.w	r12, r7, lsl #2
300116d2:	eb10 0a06 	adds.w	r10, r0, r6
300116d6:	ea4c 7196 	orr.w	r1, r12, r6, lsr #30
300116da:	eb41 0b07 	adc.w	r11, r1, r7
300116de:	ea4f 0eca 	mov.w	r14, r10, lsl #3
300116e2:	ea4f 0ccb 	mov.w	r12, r11, lsl #3
300116e6:	ea4c 7c5a 	orr.w	r12, r12, r10, lsr #29
300116ea:	ebbe 0a06 	subs.w	r10, r14, r6
300116ee:	eb6c 0b07 	sbc.w	r11, r12, r7
300116f2:	ea4f 1e0a 	mov.w	r14, r10, lsl #4
300116f6:	ea4f 1c0b 	mov.w	r12, r11, lsl #4
300116fa:	eb1e 0006 	adds.w	r0, r14, r6
300116fe:	ea4c 7c1a 	orr.w	r12, r12, r10, lsr #28
30011702:	eb4c 0107 	adc.w	r1, r12, r7
30011706:	0107      	lsls	r7, r0, #4
30011708:	010e      	lsls	r6, r1, #4
3001170a:	ea46 7610 	orr.w	r6, r6, r0, lsr #28
3001170e:	4631      	mov	r1, r6
30011710:	4638      	mov	r0, r7
30011712:	f008 fb85 	bl	30019e20 <__aeabi_uldivmod>
        printf("cpu %u LOAD: "
30011716:	f248 521f 	movw	r2, #34079	; 0x851f
3001171a:	6aa7      	ldr	r7, [r4, #40]	; 0x28
3001171c:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
30011720:	6aae      	ldr	r6, [r5, #40]	; 0x28
30011722:	2100      	movs	r1, #0
30011724:	eba6 0e07 	sub.w	r14, r6, r7
30011728:	6a6f      	ldr	r7, [r5, #36]	; 0x24
3001172a:	6a66      	ldr	r6, [r4, #36]	; 0x24
        uint busypercent = (busy_time * 10000) / (1000000);
3001172c:	4684      	mov	r12, r0
        printf("cpu %u LOAD: "
3001172e:	f640 00d0 	movw	r0, #2256	; 0x8d0
30011732:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011736:	fba2 320c 	umull	r3, r2, r2, r12
3001173a:	0952      	lsrs	r2, r2, #5
3001173c:	eb02 0382 	add.w	r3, r2, r2, lsl #2
30011740:	eb03 0383 	add.w	r3, r3, r3, lsl #2
30011744:	ebac 0383 	sub.w	r3, r12, r3, lsl #2
30011748:	eba7 0c06 	sub.w	r12, r7, r6
3001174c:	6a26      	ldr	r6, [r4, #32]
3001174e:	f8cd e010 	str.w	r14, [r13, #16]
30011752:	6a2f      	ldr	r7, [r5, #32]
30011754:	1bbe      	subs	r6, r7, r6
30011756:	e9d5 7e05 	ldrd	r7, r14, [r5, #20]
3001175a:	69a5      	ldr	r5, [r4, #24]
3001175c:	ebae 0e05 	sub.w	r14, r14, r5
30011760:	6965      	ldr	r5, [r4, #20]
30011762:	f8cd c00c 	str.w	r12, [r13, #12]
30011766:	e9cd e601 	strd	r14, r6, [r13, #4]
3001176a:	1b7d      	subs	r5, r7, r5
3001176c:	9500      	str	r5, [sp, #0]
#endif
               thread_stats[i].interrupts - old_stats[i].interrupts,
               thread_stats[i].timer_ints - old_stats[i].timer_ints,
               thread_stats[i].timers - old_stats[i].timers);

        old_stats[i] = thread_stats[i];
3001176e:	f24d 1558 	movw	r5, #53592	; 0xd158
        printf("cpu %u LOAD: "
30011772:	f004 fa1d 	bl	30015bb0 <_printf>
        last_idle_time[i] = idle_time;
30011776:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
3001177a:	e9c8 2300 	strd	r2, r3, [r8]
        old_stats[i] = thread_stats[i];
3001177e:	f2c3 0502 	movt	r5, #12290	; 0x3002
30011782:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
30011784:	c40f      	stmia	r4!, {r0, r1, r2, r3}
30011786:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
30011788:	c40f      	stmia	r4!, {r0, r1, r2, r3}
3001178a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
3001178e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    }

    return INT_NO_RESCHEDULE;
}
30011792:	2000      	movs	r0, #0
30011794:	b008      	add	sp, #32
30011796:	e8bd 8df0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r10, r11, r15}
            idle_time += current_time_hires() - thread_stats[i].last_idle_timestamp;
3001179a:	f7ef f8b9 	bl	30000910 <current_time_hires>
3001179e:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
300117a2:	e9dd ab06 	ldrd	r10, r11, [r13, #24]
300117a6:	ebba 0a02 	subs.w	r10, r10, r2
300117aa:	eb6b 0b03 	sbc.w	r11, r11, r3
300117ae:	eb1a 0300 	adds.w	r3, r10, r0
300117b2:	eb4b 0401 	adc.w	r4, r11, r1
300117b6:	e9cd 3406 	strd	r3, r4, [r13, #24]
300117ba:	e764      	b.n	30011686 <threadload+0x22>

300117bc <cmd_threadstats>:
{
300117bc:	e92d 4818 	stmdb	r13!, {r3, r4, r11, r14}
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
300117c0:	f24d 1458 	movw	r4, #53592	; 0xd158
        printf("thread stats (cpu %d):\n", i);
300117c4:	f240 70b4 	movw	r0, #1972	; 0x7b4
300117c8:	2100      	movs	r1, #0
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
300117ca:	f2c3 0402 	movt	r4, #12290	; 0x3002
        printf("thread stats (cpu %d):\n", i);
300117ce:	f2c3 0002 	movt	r0, #12290	; 0x3002
300117d2:	f004 f9ed 	bl	30015bb0 <_printf>
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
300117d6:	f240 70cc 	movw	r0, #1996	; 0x7cc
300117da:	e9d4 2300 	ldrd	r2, r3, [r4]
300117de:	f2c3 0002 	movt	r0, #12290	; 0x3002
300117e2:	f004 f9e5 	bl	30015bb0 <_printf>
        printf("\ttotal busy time: %lld\n", current_time_hires() - thread_stats[i].idle_time);
300117e6:	f7ef f893 	bl	30000910 <current_time_hires>
300117ea:	e9d4 bc00 	ldrd	r11, r12, [r4]
300117ee:	ebb0 020b 	subs.w	r2, r0, r11
300117f2:	f240 70e4 	movw	r0, #2020	; 0x7e4
300117f6:	eb61 030c 	sbc.w	r3, r1, r12
300117fa:	f2c3 0002 	movt	r0, #12290	; 0x3002
300117fe:	f004 f9d7 	bl	30015bb0 <_printf>
        printf("\treschedules: %lu\n", thread_stats[i].reschedules);
30011802:	6921      	ldr	r1, [r4, #16]
30011804:	f240 70fc 	movw	r0, #2044	; 0x7fc
30011808:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001180c:	f004 f9d0 	bl	30015bb0 <_printf>
        printf("\tcontext_switches: %lu\n", thread_stats[i].context_switches);
30011810:	6961      	ldr	r1, [r4, #20]
30011812:	f640 0010 	movw	r0, #2064	; 0x810
30011816:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001181a:	f004 f9c9 	bl	30015bb0 <_printf>
        printf("\tpreempts: %lu\n", thread_stats[i].preempts);
3001181e:	69a1      	ldr	r1, [r4, #24]
30011820:	f640 0028 	movw	r0, #2088	; 0x828
30011824:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011828:	f004 f9c2 	bl	30015bb0 <_printf>
        printf("\tyields: %lu\n", thread_stats[i].yields);
3001182c:	69e1      	ldr	r1, [r4, #28]
3001182e:	f640 0038 	movw	r0, #2104	; 0x838
30011832:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011836:	f004 f9bb 	bl	30015bb0 <_printf>
        printf("\tinterrupts: %lu\n", thread_stats[i].interrupts);
3001183a:	6a21      	ldr	r1, [r4, #32]
3001183c:	f640 0048 	movw	r0, #2120	; 0x848
30011840:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011844:	f004 f9b4 	bl	30015bb0 <_printf>
        printf("\ttimer interrupts: %lu\n", thread_stats[i].timer_ints);
30011848:	6a61      	ldr	r1, [r4, #36]	; 0x24
3001184a:	f640 005c 	movw	r0, #2140	; 0x85c
3001184e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011852:	f004 f9ad 	bl	30015bb0 <_printf>
        printf("\ttimers: %lu\n", thread_stats[i].timers);
30011856:	6aa1      	ldr	r1, [r4, #40]	; 0x28
30011858:	f640 0074 	movw	r0, #2164	; 0x874
3001185c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011860:	f004 f9a6 	bl	30015bb0 <_printf>
}
30011864:	2000      	movs	r0, #0
30011866:	e8bd 8818 	ldmia.w	r13!, {r3, r4, r11, r15}
3001186a:	bf00      	nop

3001186c <cmd_threadload>:

static int cmd_threadload(int argc, const cmd_args *argv)
{
3001186c:	b538      	push	{r3, r4, r5, r14}
    static bool showthreadload = false;
    static timer_t tltimer;

    if (showthreadload == false) {
        // start the display
        timer_initialize(&tltimer);
3001186e:	f64c 6084 	movw	r0, #52868	; 0xce84
    if (showthreadload == false) {
30011872:	f64c 6480 	movw	r4, #52864	; 0xce80
30011876:	f2c3 0402 	movt	r4, #12290	; 0x3002
3001187a:	7825      	ldrb	r5, [r4, #0]
        timer_initialize(&tltimer);
3001187c:	f2c3 0002 	movt	r0, #12290	; 0x3002
    if (showthreadload == false) {
30011880:	b12d      	cbz	r5, 3001188e <cmd_threadload+0x22>
        timer_set_periodic(&tltimer, 1000, &threadload, NULL);
        showthreadload = true;
    } else {
        timer_cancel(&tltimer);
30011882:	f001 f845 	bl	30012910 <timer_cancel>
        showthreadload = false;
30011886:	2300      	movs	r3, #0
    }

    return 0;
}
30011888:	2000      	movs	r0, #0
        showthreadload = false;
3001188a:	7023      	strb	r3, [r4, #0]
}
3001188c:	bd38      	pop	{r3, r4, r5, r15}
        timer_initialize(&tltimer);
3001188e:	f001 f815 	bl	300128bc <timer_initialize>
        timer_set_periodic(&tltimer, 1000, &threadload, NULL);
30011892:	f241 6265 	movw	r2, #5733	; 0x1665
30011896:	f64c 6084 	movw	r0, #52868	; 0xce84
3001189a:	462b      	mov	r3, r5
3001189c:	f2c3 0201 	movt	r2, #12289	; 0x3001
300118a0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
300118a4:	f2c3 0002 	movt	r0, #12290	; 0x3002
300118a8:	f001 f824 	bl	300128f4 <timer_set_periodic>
        showthreadload = true;
300118ac:	2301      	movs	r3, #1
}
300118ae:	2000      	movs	r0, #0
        showthreadload = true;
300118b0:	7023      	strb	r3, [r4, #0]
}
300118b2:	bd38      	pop	{r3, r4, r5, r15}

300118b4 <event_init>:
 * @param e        Event object to initialize
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
300118b4:	b470      	push	{r4, r5, r6}
    *e = (event_t)EVENT_INITIAL_VALUE(*e, initial, flags);
300118b6:	f646 6574 	movw	r5, #28276	; 0x6e74
300118ba:	f646 1474 	movw	r4, #26996	; 0x6974
300118be:	f2c6 5576 	movt	r5, #25974	; 0x6576
300118c2:	2600      	movs	r6, #0
300118c4:	f2c7 7461 	movt	r4, #30561	; 0x7761
300118c8:	6005      	str	r5, [r0, #0]
300118ca:	f100 0310 	add.w	r3, r0, #16
300118ce:	60c4      	str	r4, [r0, #12]
300118d0:	6186      	str	r6, [r0, #24]
300118d2:	7101      	strb	r1, [r0, #4]
300118d4:	6082      	str	r2, [r0, #8]
300118d6:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
300118da:	bc70      	pop	{r4, r5, r6}
300118dc:	4770      	bx	r14
300118de:	bf00      	nop

300118e0 <event_wait_timeout>:
 *
 * @return  0 on success, ERR_TIMED_OUT on timeout,
 *         other values on other errors.
 */
status_t event_wait_timeout(event_t *e, lk_time_t timeout)
{
300118e0:	b538      	push	{r3, r4, r5, r14}
300118e2:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300118e4:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300118e8:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
300118ea:	bf48      	it	mi
300118ec:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300118ee:	d401      	bmi.n	300118f4 <event_wait_timeout+0x14>
    __asm__ volatile("cpsid i");
300118f0:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
300118f2:	2501      	movs	r5, #1
    *lock = 1;
300118f4:	f24d 1450 	movw	r4, #53584	; 0xd150
300118f8:	2001      	movs	r0, #1
300118fa:	f2c3 0402 	movt	r4, #12290	; 0x3002

    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    THREAD_LOCK(state);

    if (e->signaled) {
300118fe:	7913      	ldrb	r3, [r2, #4]
30011900:	6020      	str	r0, [r4, #0]
30011902:	b16b      	cbz	r3, 30011920 <event_wait_timeout+0x40>
        /* signaled, we're going to fall through */
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
30011904:	6893      	ldr	r3, [r2, #8]
30011906:	4003      	ands	r3, r0
    status_t ret = NO_ERROR;
30011908:	bf08      	it	eq
3001190a:	4618      	moveq	r0, r3
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
3001190c:	d104      	bne.n	30011918 <event_wait_timeout+0x38>
    *lock = 0;
3001190e:	2300      	movs	r3, #0
30011910:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011912:	b105      	cbz	r5, 30011916 <event_wait_timeout+0x36>
    __asm__ volatile("cpsie i");
30011914:	b662      	cpsie	i
    }

    THREAD_UNLOCK(state);

    return ret;
}
30011916:	bd38      	pop	{r3, r4, r5, r15}
            e->signaled = false;
30011918:	2300      	movs	r3, #0
    status_t ret = NO_ERROR;
3001191a:	4618      	mov	r0, r3
            e->signaled = false;
3001191c:	7113      	strb	r3, [r2, #4]
3001191e:	e7f6      	b.n	3001190e <event_wait_timeout+0x2e>
        ret = wait_queue_block(&e->wait, timeout);
30011920:	f102 000c 	add.w	r0, r2, #12
30011924:	f000 fc50 	bl	300121c8 <wait_queue_block>
30011928:	e7f1      	b.n	3001190e <event_wait_timeout+0x2e>
3001192a:	bf00      	nop

3001192c <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
3001192c:	b570      	push	{r4, r5, r6, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3001192e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011932:	f013 0380 	ands.w	r3, r3, #128	; 0x80
30011936:	d118      	bne.n	3001196a <event_signal+0x3e>
    __asm__ volatile("cpsid i");
30011938:	b672      	cpsid	i
    *lock = 1;
3001193a:	f24d 1450 	movw	r4, #53584	; 0xd150
3001193e:	2601      	movs	r6, #1
30011940:	f2c3 0402 	movt	r4, #12290	; 0x3002
    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    THREAD_LOCK(state);

    if (!e->signaled) {
30011944:	7905      	ldrb	r5, [r0, #4]
30011946:	6026      	str	r6, [r4, #0]
30011948:	bb25      	cbnz	r5, 30011994 <event_signal+0x68>
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
3001194a:	6882      	ldr	r2, [r0, #8]
3001194c:	4605      	mov	r5, r0
3001194e:	300c      	adds	r0, #12
30011950:	f012 0201 	ands.w	r2, r2, #1
30011954:	d116      	bne.n	30011984 <event_signal+0x58>
                 */
                e->signaled = true;
            }
        } else {
            /* release all threads and remain signaled */
            e->signaled = true;
30011956:	2301      	movs	r3, #1
30011958:	712b      	strb	r3, [r5, #4]
            wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
3001195a:	f000 fd31 	bl	300123c0 <wait_queue_wake_all>
    *lock = 0;
3001195e:	2300      	movs	r3, #0
30011960:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011962:	b16e      	cbz	r6, 30011980 <event_signal+0x54>
    __asm__ volatile("cpsie i");
30011964:	b662      	cpsie	i
    }

    THREAD_UNLOCK(state);

    return NO_ERROR;
}
30011966:	2000      	movs	r0, #0
30011968:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 1;
3001196a:	f24d 1450 	movw	r4, #53584	; 0xd150
3001196e:	2301      	movs	r3, #1
30011970:	f2c3 0402 	movt	r4, #12290	; 0x3002
    if (!e->signaled) {
30011974:	7906      	ldrb	r6, [r0, #4]
30011976:	6023      	str	r3, [r4, #0]
30011978:	2e00      	cmp	r6, #0
3001197a:	d0e6      	beq.n	3001194a <event_signal+0x1e>
    *lock = 0;
3001197c:	2300      	movs	r3, #0
3001197e:	6023      	str	r3, [r4, #0]
}
30011980:	2000      	movs	r0, #0
30011982:	bd70      	pop	{r4, r5, r6, r15}
            if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
30011984:	2200      	movs	r2, #0
30011986:	f000 fcaf 	bl	300122e8 <wait_queue_wake_one>
3001198a:	2800      	cmp	r0, #0
                e->signaled = true;
3001198c:	bfdc      	itt	le
3001198e:	2301      	movle	r3, #1
30011990:	712b      	strble	r3, [r5, #4]
30011992:	e7e4      	b.n	3001195e <event_signal+0x32>
30011994:	6023      	str	r3, [r4, #0]
30011996:	e7e5      	b.n	30011964 <event_signal+0x38>

30011998 <event_unsignal>:
 * @param e  Event object
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_unsignal(event_t *e)
{
30011998:	4602      	mov	r2, r0
    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    e->signaled = false;
3001199a:	2300      	movs	r3, #0

    return NO_ERROR;
}
3001199c:	4618      	mov	r0, r3
    e->signaled = false;
3001199e:	7113      	strb	r3, [r2, #4]
}
300119a0:	4770      	bx	r14
300119a2:	bf00      	nop

300119a4 <kernel_init>:
#include <kernel/timer.h>
#include <kernel/mp.h>
#include <kernel/port.h>

void kernel_init(void)
{
300119a4:	b508      	push	{r3, r14}
    dprintf(SPEW, "initializing mp\n");
    mp_init();

    // initialize the threading system
    dprintf(SPEW, "initializing threads\n");
    thread_init();
300119a6:	f000 fbef 	bl	30012188 <thread_init>

    // initialize kernel timers
    dprintf(SPEW, "initializing timers\n");
    timer_init();
300119aa:	f001 f805 	bl	300129b8 <timer_init>

    // initialize ports
    dprintf(SPEW, "initializing ports\n");
    port_init();
}
300119ae:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    port_init();
300119b2:	f001 b80f 	b.w	300129d4 <port_init>
300119b6:	bf00      	nop

300119b8 <mutex_init>:

/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
300119b8:	b410      	push	{r4}
    *m = (mutex_t)MUTEX_INITIAL_VALUE(*m);
300119ba:	f646 1174 	movw	r1, #26996	; 0x6974
300119be:	f247 4478 	movw	r4, #29816	; 0x7478
300119c2:	f6c6 5475 	movt	r4, #28021	; 0x6d75
300119c6:	2300      	movs	r3, #0
300119c8:	f100 0210 	add.w	r2, r0, #16
300119cc:	6004      	str	r4, [r0, #0]
300119ce:	f2c7 7161 	movt	r1, #30561	; 0x7761
300119d2:	6142      	str	r2, [r0, #20]
300119d4:	e9c0 1203 	strd	r1, r2, [r0, #12]
300119d8:	e9c0 3301 	strd	r3, r3, [r0, #4]
300119dc:	6183      	str	r3, [r0, #24]
}
300119de:	f85d 4b04 	ldr.w	r4, [r13], #4
300119e2:	4770      	bx	r14

300119e4 <mutex_destroy>:
 *
 * This function frees any resources that were allocated
 * in mutex_init().  The mutex_t object itself is not freed.
 */
void mutex_destroy(mutex_t *m)
{
300119e4:	b538      	push	{r3, r4, r5, r14}
300119e6:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300119e8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300119ec:	f013 0480 	ands.w	r4, r3, #128	; 0x80
300119f0:	f100 000c 	add.w	r0, r0, #12
300119f4:	d10d      	bne.n	30011a12 <mutex_destroy+0x2e>
    __asm__ volatile("cpsid i");
300119f6:	b672      	cpsid	i
    *lock = 1;
300119f8:	f24d 1550 	movw	r5, #53584	; 0xd150
300119fc:	2101      	movs	r1, #1
              get_current_thread(), get_current_thread()->name, m, m->holder, m->holder->name);
#endif

    THREAD_LOCK(state);
    m->magic = 0;
    m->count = 0;
300119fe:	6094      	str	r4, [r2, #8]
30011a00:	f2c3 0502 	movt	r5, #12290	; 0x3002
30011a04:	6029      	str	r1, [r5, #0]
    m->magic = 0;
30011a06:	6014      	str	r4, [r2, #0]
    wait_queue_destroy(&m->wait, true);
30011a08:	f000 fdf8 	bl	300125fc <wait_queue_destroy>
    *lock = 0;
30011a0c:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
30011a0e:	b662      	cpsie	i
    THREAD_UNLOCK(state);
}
30011a10:	bd38      	pop	{r3, r4, r5, r15}
    *lock = 1;
30011a12:	f24d 1450 	movw	r4, #53584	; 0xd150
    m->magic = 0;
30011a16:	2500      	movs	r5, #0
30011a18:	2101      	movs	r1, #1
30011a1a:	f2c3 0402 	movt	r4, #12290	; 0x3002
    m->count = 0;
30011a1e:	6095      	str	r5, [r2, #8]
30011a20:	6021      	str	r1, [r4, #0]
    m->magic = 0;
30011a22:	6015      	str	r5, [r2, #0]
    wait_queue_destroy(&m->wait, true);
30011a24:	f000 fdea 	bl	300125fc <wait_queue_destroy>
    *lock = 0;
30011a28:	6025      	str	r5, [r4, #0]
}
30011a2a:	bd38      	pop	{r3, r4, r5, r15}

30011a2c <mutex_acquire_timeout>:
 *
 * @return  NO_ERROR on success, ERR_TIMED_OUT on timeout,
 * other values on error
 */
status_t mutex_acquire_timeout(mutex_t *m, lk_time_t timeout)
{
30011a2c:	b570      	push	{r4, r5, r6, r14}
30011a2e:	4605      	mov	r5, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011a30:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011a34:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
30011a36:	bf48      	it	mi
30011a38:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011a3a:	d401      	bmi.n	30011a40 <mutex_acquire_timeout+0x14>
    __asm__ volatile("cpsid i");
30011a3c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30011a3e:	2601      	movs	r6, #1
#endif

    THREAD_LOCK(state);

    status_t ret = NO_ERROR;
    if (unlikely(++m->count > 1)) {
30011a40:	68ab      	ldr	r3, [r5, #8]
    *lock = 1;
30011a42:	2201      	movs	r2, #1
30011a44:	f24d 1450 	movw	r4, #53584	; 0xd150
30011a48:	3301      	adds	r3, #1
30011a4a:	f2c3 0402 	movt	r4, #12290	; 0x3002
30011a4e:	60ab      	str	r3, [r5, #8]
30011a50:	4293      	cmp	r3, r2
30011a52:	6022      	str	r2, [r4, #0]
    status_t ret = NO_ERROR;
30011a54:	bfd8      	it	le
30011a56:	2000      	movle	r0, #0
    if (unlikely(++m->count > 1)) {
30011a58:	dc07      	bgt.n	30011a6a <mutex_acquire_timeout+0x3e>
30011a5a:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
             */
            goto err;
        }
    }

    m->holder = get_current_thread();
30011a5e:	606b      	str	r3, [r5, #4]
    *lock = 0;
30011a60:	2300      	movs	r3, #0
30011a62:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011a64:	b106      	cbz	r6, 30011a68 <mutex_acquire_timeout+0x3c>
    __asm__ volatile("cpsie i");
30011a66:	b662      	cpsie	i

err:
    THREAD_UNLOCK(state);
    return ret;
}
30011a68:	bd70      	pop	{r4, r5, r6, r15}
        ret = wait_queue_block(&m->wait, timeout);
30011a6a:	f105 000c 	add.w	r0, r5, #12
30011a6e:	f000 fbab 	bl	300121c8 <wait_queue_block>
        if (unlikely(ret < NO_ERROR)) {
30011a72:	2800      	cmp	r0, #0
30011a74:	daf1      	bge.n	30011a5a <mutex_acquire_timeout+0x2e>
            if (likely(ret == ERR_TIMED_OUT)) {
30011a76:	f110 0f0d 	cmn.w	r0, #13
30011a7a:	d1f1      	bne.n	30011a60 <mutex_acquire_timeout+0x34>
                m->count--;
30011a7c:	68ab      	ldr	r3, [r5, #8]
30011a7e:	3b01      	subs	r3, #1
30011a80:	60ab      	str	r3, [r5, #8]
30011a82:	e7ed      	b.n	30011a60 <mutex_acquire_timeout+0x34>

30011a84 <mutex_release>:

/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
30011a84:	b538      	push	{r3, r4, r5, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011a86:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011a8a:	f012 0480 	ands.w	r4, r2, #128	; 0x80
30011a8e:	d110      	bne.n	30011ab2 <mutex_release+0x2e>
    __asm__ volatile("cpsid i");
30011a90:	b672      	cpsid	i

    THREAD_LOCK(state);

    m->holder = 0;

    if (unlikely(--m->count >= 1)) {
30011a92:	6883      	ldr	r3, [r0, #8]
    *lock = 1;
30011a94:	f24d 1550 	movw	r5, #53584	; 0xd150
30011a98:	2101      	movs	r1, #1
30011a9a:	f2c3 0502 	movt	r5, #12290	; 0x3002
30011a9e:	3b01      	subs	r3, #1
30011aa0:	6029      	str	r1, [r5, #0]
30011aa2:	2b00      	cmp	r3, #0
30011aa4:	e9c0 4301 	strd	r4, r3, [r0, #4]
30011aa8:	dc13      	bgt.n	30011ad2 <mutex_release+0x4e>
    *lock = 0;
30011aaa:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
30011aac:	b662      	cpsie	i
        wait_queue_wake_one(&m->wait, true, NO_ERROR);
    }

    THREAD_UNLOCK(state);
    return NO_ERROR;
}
30011aae:	2000      	movs	r0, #0
30011ab0:	bd38      	pop	{r3, r4, r5, r15}
    if (unlikely(--m->count >= 1)) {
30011ab2:	6883      	ldr	r3, [r0, #8]
    m->holder = 0;
30011ab4:	2500      	movs	r5, #0
    *lock = 1;
30011ab6:	f24d 1450 	movw	r4, #53584	; 0xd150
30011aba:	2101      	movs	r1, #1
    if (unlikely(--m->count >= 1)) {
30011abc:	3b01      	subs	r3, #1
30011abe:	f2c3 0402 	movt	r4, #12290	; 0x3002
30011ac2:	6083      	str	r3, [r0, #8]
30011ac4:	42ab      	cmp	r3, r5
30011ac6:	6021      	str	r1, [r4, #0]
    m->holder = 0;
30011ac8:	6045      	str	r5, [r0, #4]
    if (unlikely(--m->count >= 1)) {
30011aca:	dc07      	bgt.n	30011adc <mutex_release+0x58>
    *lock = 0;
30011acc:	6025      	str	r5, [r4, #0]
}
30011ace:	2000      	movs	r0, #0
30011ad0:	bd38      	pop	{r3, r4, r5, r15}
        wait_queue_wake_one(&m->wait, true, NO_ERROR);
30011ad2:	4622      	mov	r2, r4
30011ad4:	300c      	adds	r0, #12
30011ad6:	f000 fc07 	bl	300122e8 <wait_queue_wake_one>
30011ada:	e7e6      	b.n	30011aaa <mutex_release+0x26>
30011adc:	462a      	mov	r2, r5
30011ade:	300c      	adds	r0, #12
30011ae0:	f000 fc02 	bl	300122e8 <wait_queue_wake_one>
30011ae4:	e7f2      	b.n	30011acc <mutex_release+0x48>
30011ae6:	bf00      	nop

30011ae8 <init_thread_struct>:
    list_add_tail(&run_queue[t->priority], &t->queue_node);
    run_queue_bitmap |= (1<<t->priority);
}

static void init_thread_struct(thread_t *t, const char *name)
{
30011ae8:	b510      	push	{r4, r14}
    memset(t, 0, sizeof(thread_t));
30011aea:	f44f 72c4 	mov.w	r2, #392	; 0x188
{
30011aee:	460c      	mov	r4, r1
    memset(t, 0, sizeof(thread_t));
30011af0:	2100      	movs	r1, #0
30011af2:	f002 ef3e 	blx	30014970 <memset>
    t->magic = THREAD_MAGIC;
30011af6:	f247 2264 	movw	r2, #29284	; 0x7264
    thread_set_pinned_cpu(t, -1);
    strlcpy(t->name, name, sizeof(t->name));
30011afa:	4621      	mov	r1, r4
    t->magic = THREAD_MAGIC;
30011afc:	f2c7 4268 	movt	r2, #29800	; 0x7468
}
30011b00:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    memset(t, 0, sizeof(thread_t));
30011b04:	4603      	mov	r3, r0
    strlcpy(t->name, name, sizeof(t->name));
30011b06:	f500 70b2 	add.w	r0, r0, #356	; 0x164
    t->magic = THREAD_MAGIC;
30011b0a:	601a      	str	r2, [r3, #0]
    strlcpy(t->name, name, sizeof(t->name));
30011b0c:	2220      	movs	r2, #32
30011b0e:	f004 b8ed 	b.w	30015cec <strlcpy>
30011b12:	bf00      	nop

30011b14 <thread_resched>:
 *
 * This is probably not the function you're looking for. See
 * thread_yield() instead.
 */
void thread_resched(void)
{
30011b14:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30011b18:	b083      	sub	sp, #12
30011b1a:	ee1d 6f90 	mrc	15, 0, r6, cr13, cr0, {4}

    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));
    DEBUG_ASSERT(current_thread->state != THREAD_RUNNING);

    THREAD_STATS_INC(reschedules);
30011b1e:	f24d 1858 	movw	r8, #53592	; 0xd158
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
30011b22:	f24d 1544 	movw	r5, #53572	; 0xd144
    THREAD_STATS_INC(reschedules);
30011b26:	f2c3 0802 	movt	r8, #12290	; 0x3002
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
30011b2a:	f2c3 0502 	movt	r5, #12290	; 0x3002
    THREAD_STATS_INC(reschedules);
30011b2e:	f8d8 3010 	ldr.w	r3, [r8, #16]
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
30011b32:	682c      	ldr	r4, [r5, #0]
    THREAD_STATS_INC(reschedules);
30011b34:	3301      	adds	r3, #1
30011b36:	f8c8 3010 	str.w	r3, [r8, #16]
    while (local_run_queue_bitmap) {
30011b3a:	b33c      	cbz	r4, 30011b8c <thread_resched+0x78>
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
30011b3c:	f24d 0c44 	movw	r12, #53316	; 0xd044
        uint next_queue = sizeof(run_queue_bitmap) * 8 - 1 - __builtin_clz(local_run_queue_bitmap);
30011b40:	fab4 f384 	clz	r3, r4
30011b44:	f1c3 031f 	rsb	r3, r3, #31
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
30011b48:	f2c3 0c02 	movt	r12, #12290	; 0x3002
30011b4c:	ea4f 0ac3 	mov.w	r10, r3, lsl #3
30011b50:	eb0c 000a 	add.w	r0, r12, r10
30011b54:	6842      	ldr	r2, [r0, #4]
30011b56:	4290      	cmp	r0, r2
30011b58:	f1a2 070c 	sub.w	r7, r2, #12
30011b5c:	f040 8081 	bne.w	30011c62 <thread_resched+0x14e>
30011b60:	4622      	mov	r2, r4
        local_run_queue_bitmap &= ~(1<<next_queue);
30011b62:	f04f 0901 	mov.w	r9, #1
30011b66:	e00d      	b.n	30011b84 <thread_resched+0x70>
        uint next_queue = sizeof(run_queue_bitmap) * 8 - 1 - __builtin_clz(local_run_queue_bitmap);
30011b68:	fab2 f382 	clz	r3, r2
30011b6c:	f1c3 031f 	rsb	r3, r3, #31
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
30011b70:	ea4f 0ac3 	mov.w	r10, r3, lsl #3
30011b74:	eb0c 010a 	add.w	r1, r12, r10
30011b78:	4608      	mov	r0, r1
30011b7a:	6849      	ldr	r1, [r1, #4]
30011b7c:	4288      	cmp	r0, r1
30011b7e:	f1a1 070c 	sub.w	r7, r1, #12
30011b82:	d16e      	bne.n	30011c62 <thread_resched+0x14e>
        local_run_queue_bitmap &= ~(1<<next_queue);
30011b84:	fa09 f303 	lsl.w	r3, r9, r3
    while (local_run_queue_bitmap) {
30011b88:	439a      	bics	r2, r3
30011b8a:	d1ed      	bne.n	30011b68 <thread_resched+0x54>
    return idle_thread(cpu);
30011b8c:	f64c 67a0 	movw	r7, #52896	; 0xcea0
30011b90:	f2c3 0702 	movt	r7, #12290	; 0x3002

    newthread = get_top_thread(cpu, true);

    DEBUG_ASSERT(newthread);

    newthread->state = THREAD_RUNNING;
30011b94:	2302      	movs	r3, #2

    oldthread = current_thread;

    if (newthread == oldthread)
30011b96:	42be      	cmp	r6, r7
    newthread->state = THREAD_RUNNING;
30011b98:	61bb      	str	r3, [r7, #24]
    if (newthread == oldthread)
30011b9a:	d039      	beq.n	30011c10 <thread_resched+0xfc>
        return;

    /* set up quantum for the new thread if it was consumed */
    if (newthread->remaining_quantum <= 0) {
30011b9c:	69fb      	ldr	r3, [r7, #28]
30011b9e:	46f1      	mov	r9, r14
30011ba0:	2b00      	cmp	r3, #0
        newthread->remaining_quantum = 5; // XXX make this smarter
30011ba2:	bfdc      	itt	le
30011ba4:	2305      	movle	r3, #5
30011ba6:	61fb      	strle	r3, [r7, #28]
        mp_set_cpu_non_realtime(cpu);
    }
#endif

#if THREAD_STATS
    THREAD_STATS_INC(context_switches);
30011ba8:	f8d8 3014 	ldr.w	r3, [r8, #20]
    return !!(t->flags & THREAD_FLAG_IDLE);
30011bac:	6a32      	ldr	r2, [r6, #32]
    THREAD_STATS_INC(context_switches);
30011bae:	3301      	adds	r3, #1

    if (thread_is_idle(oldthread)) {
30011bb0:	06d1      	lsls	r1, r2, #27
    THREAD_STATS_INC(context_switches);
30011bb2:	f8c8 3014 	str.w	r3, [r8, #20]
    if (thread_is_idle(oldthread)) {
30011bb6:	d443      	bmi.n	30011c40 <thread_resched+0x12c>
        lk_bigtime_t now = current_time_hires();
        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;
    }
    if (thread_is_idle(newthread)) {
30011bb8:	6a3b      	ldr	r3, [r7, #32]
30011bba:	06da      	lsls	r2, r3, #27
30011bbc:	d434      	bmi.n	30011c28 <thread_resched+0x114>
30011bbe:	6a32      	ldr	r2, [r6, #32]
#endif

    KEVLOG_THREAD_SWITCH(oldthread, newthread);

#if PLATFORM_HAS_DYNAMIC_TIMER
    if (thread_is_real_time_or_idle(newthread)) {
30011bc0:	f013 0318 	ands.w	r3, r3, #24
30011bc4:	f002 0218 	and.w	r2, r2, #24
30011bc8:	d125      	bne.n	30011c16 <thread_resched+0x102>
                    cpu, oldthread, oldthread->name, newthread, newthread->name);
#endif
            timer_cancel(&preempt_timer[cpu]);
        }
    }
    else if (thread_is_real_time_or_idle(oldthread)) {
30011bca:	2a00      	cmp	r2, #0
30011bcc:	d167      	bne.n	30011c9e <thread_resched+0x18a>
30011bce:	ee0d 7f90 	mcr	15, 0, r7, cr13, cr0, {4}
30011bd2:	f3bf 8f6f 	isb	sy
            newthread->priority, newthread->flags);
#endif

#if THREAD_STACK_BOUNDS_CHECK
    /* check that the old thread has not blown its stack just before pushing its context */
    if (oldthread->flags & THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) {
30011bd6:	6a33      	ldr	r3, [r6, #32]
30011bd8:	069b      	lsls	r3, r3, #26
30011bda:	d559      	bpl.n	30011c90 <thread_resched+0x17c>
30011bdc:	f8d6 4140 	ldr.w	r4, [r6, #320]	; 0x140
30011be0:	4623      	mov	r3, r4
30011be2:	f504 7080 	add.w	r0, r4, #256	; 0x100
30011be6:	e001      	b.n	30011bec <thread_resched+0xd8>
        STATIC_ASSERT((THREAD_STACK_PADDING_SIZE % sizeof(uint32_t)) == 0);
        uint32_t *s = (uint32_t *)oldthread->stack;
        for (size_t i = 0; i < THREAD_STACK_PADDING_SIZE / sizeof(uint32_t); i++) {
30011be8:	4298      	cmp	r0, r3
30011bea:	d051      	beq.n	30011c90 <thread_resched+0x17c>
            if (unlikely(s[i] != STACK_DEBUG_WORD)) {
30011bec:	461a      	mov	r2, r3
30011bee:	3304      	adds	r3, #4
30011bf0:	6811      	ldr	r1, [r2, #0]
30011bf2:	f1b1 3f99 	cmp.w	r1, #2576980377	; 0x99999999
30011bf6:	d0f7      	beq.n	30011be8 <thread_resched+0xd4>
                /* NOTE: will probably blow the stack harder here, but hopefully enough
                 * state exists to at least get some sort of debugging done.
                 */
                panic("stack overrun at %p: thread %p (%s), stack %p\n", &s[i],
30011bf8:	f640 1158 	movw	r1, #2392	; 0x958
30011bfc:	f506 73b2 	add.w	r3, r6, #356	; 0x164
30011c00:	9401      	str	r4, [sp, #4]
30011c02:	4648      	mov	r0, r9
30011c04:	9300      	str	r3, [sp, #0]
30011c06:	f2c3 0102 	movt	r1, #12290	; 0x3002
30011c0a:	4633      	mov	r3, r6
30011c0c:	f002 fb02 	bl	30014214 <_panic>
    }
#endif

    /* do the low level context switch */
    arch_context_switch(oldthread, newthread);
}
30011c10:	b003      	add	sp, #12
30011c12:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (!thread_is_real_time_or_idle(oldthread)) {
30011c16:	2a00      	cmp	r2, #0
30011c18:	d1d9      	bne.n	30011bce <thread_resched+0xba>
            timer_cancel(&preempt_timer[cpu]);
30011c1a:	f24d 0028 	movw	r0, #53288	; 0xd028
30011c1e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011c22:	f000 fe75 	bl	30012910 <timer_cancel>
30011c26:	e7d2      	b.n	30011bce <thread_resched+0xba>
        thread_stats[cpu].last_idle_timestamp = current_time_hires();
30011c28:	f7ee fe72 	bl	30000910 <current_time_hires>
30011c2c:	6a3b      	ldr	r3, [r7, #32]
30011c2e:	6a32      	ldr	r2, [r6, #32]
    if (thread_is_real_time_or_idle(newthread)) {
30011c30:	f013 0318 	ands.w	r3, r3, #24
30011c34:	f002 0218 	and.w	r2, r2, #24
        thread_stats[cpu].last_idle_timestamp = current_time_hires();
30011c38:	e9c8 0102 	strd	r0, r1, [r8, #8]
    if (thread_is_real_time_or_idle(newthread)) {
30011c3c:	d0c5      	beq.n	30011bca <thread_resched+0xb6>
30011c3e:	e7ea      	b.n	30011c16 <thread_resched+0x102>
        lk_bigtime_t now = current_time_hires();
30011c40:	f7ee fe66 	bl	30000910 <current_time_hires>
        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;
30011c44:	e9d8 2300 	ldrd	r2, r3, [r8]
30011c48:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
30011c4c:	1b12      	subs	r2, r2, r4
30011c4e:	eb63 0305 	sbc.w	r3, r3, r5
30011c52:	1812      	adds	r2, r2, r0
30011c54:	414b      	adcs	r3, r1
30011c56:	e9c8 2300 	strd	r2, r3, [r8]
    if (thread_is_idle(newthread)) {
30011c5a:	6a3b      	ldr	r3, [r7, #32]
30011c5c:	06da      	lsls	r2, r3, #27
30011c5e:	d5ae      	bpl.n	30011bbe <thread_resched+0xaa>
30011c60:	e7e2      	b.n	30011c28 <thread_resched+0x114>

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
    item->next->prev = item->prev;
30011c62:	693a      	ldr	r2, [r7, #16]
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
    return (list->next == list) ? true : false;
30011c64:	44d4      	add	r12, r10
    item->next->prev = item->prev;
30011c66:	68f9      	ldr	r1, [r7, #12]
    item->prev = item->next = 0;
30011c68:	f04f 0900 	mov.w	r9, #0
    item->next->prev = item->prev;
30011c6c:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
30011c6e:	68f9      	ldr	r1, [r7, #12]
30011c70:	604a      	str	r2, [r1, #4]
    item->prev = item->next = 0;
30011c72:	f8c7 9010 	str.w	r9, [r7, #16]
                    if (list_is_empty(&run_queue[next_queue]))
30011c76:	f8dc 2004 	ldr.w	r2, [r12, #4]
30011c7a:	f8c7 900c 	str.w	r9, [r7, #12]
30011c7e:	4282      	cmp	r2, r0
30011c80:	d188      	bne.n	30011b94 <thread_resched+0x80>
                        run_queue_bitmap &= ~(1<<next_queue);
30011c82:	2201      	movs	r2, #1
30011c84:	fa02 f303 	lsl.w	r3, r2, r3
30011c88:	ea24 0403 	bic.w	r4, r4, r3
30011c8c:	602c      	str	r4, [r5, #0]
30011c8e:	e781      	b.n	30011b94 <thread_resched+0x80>
    arch_context_switch(oldthread, newthread);
30011c90:	4639      	mov	r1, r7
30011c92:	4630      	mov	r0, r6
}
30011c94:	b003      	add	sp, #12
30011c96:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    arch_context_switch(oldthread, newthread);
30011c9a:	f7ef bdff 	b.w	3000189c <arch_context_switch>
        timer_set_periodic(&preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);
30011c9e:	f641 5221 	movw	r2, #7457	; 0x1d21
30011ca2:	f24d 0028 	movw	r0, #53288	; 0xd028
30011ca6:	f2c3 0201 	movt	r2, #12289	; 0x3001
30011caa:	210a      	movs	r1, #10
30011cac:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011cb0:	f000 fe20 	bl	300128f4 <timer_set_periodic>
30011cb4:	e78b      	b.n	30011bce <thread_resched+0xba>
30011cb6:	bf00      	nop

30011cb8 <thread_sleep_handler>:
    }
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, lk_time_t now, void *arg)
{
30011cb8:	b4f0      	push	{r4, r5, r6, r7}
30011cba:	b082      	sub	sp, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011cbc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011cc0:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
30011cc2:	bf48      	it	mi
30011cc4:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011cc6:	d401      	bmi.n	30011ccc <thread_sleep_handler+0x14>
    __asm__ volatile("cpsid i");
30011cc8:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30011cca:	2601      	movs	r6, #1
    list_add_head(&run_queue[t->priority], &t->queue_node);
30011ccc:	6951      	ldr	r1, [r2, #20]
    item->next = list->next;
30011cce:	f24d 0344 	movw	r3, #53316	; 0xd044
    run_queue_bitmap |= (1<<t->priority);
30011cd2:	f24d 1044 	movw	r0, #53572	; 0xd144
30011cd6:	f2c3 0302 	movt	r3, #12290	; 0x3002
    DEBUG_ASSERT(t->magic == THREAD_MAGIC);
    DEBUG_ASSERT(t->state == THREAD_SLEEPING);

    THREAD_LOCK(state);

    t->state = THREAD_READY;
30011cda:	2701      	movs	r7, #1
    run_queue_bitmap |= (1<<t->priority);
30011cdc:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011ce0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
30011ce4:	fa07 f101 	lsl.w	r1, r7, r1
    list_add_head(&run_queue[t->priority], &t->queue_node);
30011ce8:	f102 040c 	add.w	r4, r2, #12
30011cec:	685d      	ldr	r5, [r3, #4]
30011cee:	9501      	str	r5, [sp, #4]
    run_queue_bitmap |= (1<<t->priority);
30011cf0:	6805      	ldr	r5, [r0, #0]
30011cf2:	4329      	orrs	r1, r5
30011cf4:	9d01      	ldr	r5, [sp, #4]
30011cf6:	6115      	str	r5, [r2, #16]
    list->next->prev = item;
30011cf8:	685d      	ldr	r5, [r3, #4]
30011cfa:	6001      	str	r1, [r0, #0]
    item->prev = list;
30011cfc:	60d3      	str	r3, [r2, #12]
    t->state = THREAD_READY;
30011cfe:	6197      	str	r7, [r2, #24]
    list->next->prev = item;
30011d00:	602c      	str	r4, [r5, #0]
    list->next = item;
30011d02:	605c      	str	r4, [r3, #4]
30011d04:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    *lock = 0;
30011d08:	f24d 1350 	movw	r3, #53584	; 0xd150
30011d0c:	2200      	movs	r2, #0
30011d0e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30011d12:	601a      	str	r2, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011d14:	b106      	cbz	r6, 30011d18 <thread_sleep_handler+0x60>
    __asm__ volatile("cpsie i");
30011d16:	b662      	cpsie	i
    thread_mp_reschedule(get_current_thread(), t);

    THREAD_UNLOCK(state);

    return INT_RESCHEDULE;
}
30011d18:	2001      	movs	r0, #1
30011d1a:	b002      	add	sp, #8
30011d1c:	bcf0      	pop	{r4, r5, r6, r7}
30011d1e:	4770      	bx	r14

30011d20 <thread_timer_tick>:
30011d20:	ee1d 2f90 	mrc	15, 0, r2, cr13, cr0, {4}
    if (thread_is_idle(current_thread))
30011d24:	6a13      	ldr	r3, [r2, #32]
30011d26:	f013 0010 	ands.w	r0, r3, #16
30011d2a:	d117      	bne.n	30011d5c <thread_timer_tick+0x3c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011d2c:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011d30:	f011 0180 	ands.w	r1, r1, #128	; 0x80
30011d34:	d114      	bne.n	30011d60 <thread_timer_tick+0x40>
    __asm__ volatile("cpsid i");
30011d36:	b672      	cpsid	i
    *lock = 0;
30011d38:	f24d 1350 	movw	r3, #53584	; 0xd150
30011d3c:	f2c3 0302 	movt	r3, #12290	; 0x3002
30011d40:	6019      	str	r1, [r3, #0]
    __asm__ volatile("cpsie i");
30011d42:	b662      	cpsie	i
30011d44:	6a13      	ldr	r3, [r2, #32]
    if (thread_is_real_time_or_idle(current_thread))
30011d46:	f013 0f18 	tst.w	r3, #24
30011d4a:	d107      	bne.n	30011d5c <thread_timer_tick+0x3c>
    current_thread->remaining_quantum--;
30011d4c:	69d3      	ldr	r3, [r2, #28]
30011d4e:	3b01      	subs	r3, #1
    if (current_thread->remaining_quantum <= 0) {
30011d50:	2b00      	cmp	r3, #0
30011d52:	bfcc      	ite	gt
30011d54:	2000      	movgt	r0, #0
30011d56:	2001      	movle	r0, #1
    current_thread->remaining_quantum--;
30011d58:	61d3      	str	r3, [r2, #28]
}
30011d5a:	4770      	bx	r14
        return INT_NO_RESCHEDULE;
30011d5c:	2000      	movs	r0, #0
30011d5e:	4770      	bx	r14
30011d60:	f24d 1150 	movw	r1, #53584	; 0xd150
30011d64:	f2c3 0102 	movt	r1, #12290	; 0x3002
30011d68:	6008      	str	r0, [r1, #0]
30011d6a:	e7ec      	b.n	30011d46 <thread_timer_tick+0x26>

30011d6c <thread_create_etc>:
{
30011d6c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
30011d70:	4691      	mov	r9, r2
30011d72:	b083      	sub	sp, #12
30011d74:	4698      	mov	r8, r3
30011d76:	4604      	mov	r4, r0
    unsigned int flags = 0;
30011d78:	2700      	movs	r7, #0
{
30011d7a:	e9dd 560b 	ldrd	r5, r6, [r13, #44]	; 0x2c
    if (!t) {
30011d7e:	2800      	cmp	r0, #0
30011d80:	d05b      	beq.n	30011e3a <thread_create_etc+0xce>
    init_thread_struct(t, name);
30011d82:	4620      	mov	r0, r4
30011d84:	f7ff feb0 	bl	30011ae8 <init_thread_struct>
 * @defgroup  wait  Wait Queue
 * @{
 */
void wait_queue_init(wait_queue_t *wait)
{
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30011d88:	f646 1174 	movw	r1, #26996	; 0x6974
    t->state = THREAD_SUSPENDED;
30011d8c:	2300      	movs	r3, #0
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30011d8e:	f504 72ac 	add.w	r2, r4, #344	; 0x158
    t->priority = priority;
30011d92:	980a      	ldr	r0, [sp, #40]	; 0x28
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30011d94:	f2c7 7161 	movt	r1, #30561	; 0x7761
    t->entry = entry;
30011d98:	f8c4 9148 	str.w	r9, [r4, #328]	; 0x148
    t->arg = arg;
30011d9c:	f8c4 814c 	str.w	r8, [r4, #332]	; 0x14c
    t->priority = priority;
30011da0:	6160      	str	r0, [r4, #20]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30011da2:	f8c4 1154 	str.w	r1, [r4, #340]	; 0x154
    t->state = THREAD_SUSPENDED;
30011da6:	61a3      	str	r3, [r4, #24]
    t->wait_queue_block_ret = NO_ERROR;
30011da8:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
    t->retcode = 0;
30011dac:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30011db0:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
30011db4:	f8c4 2158 	str.w	r2, [r4, #344]	; 0x158
30011db8:	f8c4 215c 	str.w	r2, [r4, #348]	; 0x15c
    if (!stack) {
30011dbc:	2d00      	cmp	r5, #0
30011dbe:	d048      	beq.n	30011e52 <thread_create_etc+0xe6>
        t->stack = stack;
30011dc0:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
        memset(t->stack, STACK_DEBUG_BYTE, stack_size);
30011dc4:	4628      	mov	r0, r5
30011dc6:	4632      	mov	r2, r6
30011dc8:	2199      	movs	r1, #153	; 0x99
30011dca:	f002 edd2 	blx	30014970 <memset>
    t->stack_size = stack_size;
30011dce:	f8c4 6144 	str.w	r6, [r4, #324]	; 0x144
    t->flags = flags;
30011dd2:	6227      	str	r7, [r4, #32]
30011dd4:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    arch_thread_initialize(t);
30011dd8:	4620      	mov	r0, r4
30011dda:	f7ef fd43 	bl	30001864 <arch_thread_initialize>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011dde:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011de2:	f013 0380 	ands.w	r3, r3, #128	; 0x80
30011de6:	f104 0104 	add.w	r1, r4, #4
30011dea:	d113      	bne.n	30011e14 <thread_create_etc+0xa8>
    __asm__ volatile("cpsid i");
30011dec:	b672      	cpsid	i
    item->next = list->next;
30011dee:	f24d 1248 	movw	r2, #53576	; 0xd148
    *lock = 0;
30011df2:	f24d 1050 	movw	r0, #53584	; 0xd150
30011df6:	f2c3 0202 	movt	r2, #12290	; 0x3002
30011dfa:	f2c3 0002 	movt	r0, #12290	; 0x3002
30011dfe:	6855      	ldr	r5, [r2, #4]
    item->prev = list;
30011e00:	e9c4 2501 	strd	r2, r5, [r4, #4]
    list->next->prev = item;
30011e04:	6029      	str	r1, [r5, #0]
    list->next = item;
30011e06:	6051      	str	r1, [r2, #4]
30011e08:	6003      	str	r3, [r0, #0]
    __asm__ volatile("cpsie i");
30011e0a:	b662      	cpsie	i
30011e0c:	4620      	mov	r0, r4
}
30011e0e:	b003      	add	sp, #12
30011e10:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    item->next = list->next;
30011e14:	f24d 1348 	movw	r3, #53576	; 0xd148
30011e18:	f24d 1250 	movw	r2, #53584	; 0xd150
30011e1c:	f2c3 0302 	movt	r3, #12290	; 0x3002
30011e20:	2600      	movs	r6, #0
30011e22:	f2c3 0202 	movt	r2, #12290	; 0x3002
30011e26:	4620      	mov	r0, r4
30011e28:	685d      	ldr	r5, [r3, #4]
    item->prev = list;
30011e2a:	e9c4 3501 	strd	r3, r5, [r4, #4]
    list->next->prev = item;
30011e2e:	6029      	str	r1, [r5, #0]
    list->next = item;
30011e30:	6059      	str	r1, [r3, #4]
30011e32:	6016      	str	r6, [r2, #0]
30011e34:	b003      	add	sp, #12
30011e36:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        t = malloc(sizeof(thread_t));
30011e3a:	f44f 70c4 	mov.w	r0, #392	; 0x188
        flags |= THREAD_FLAG_FREE_STRUCT;
30011e3e:	2704      	movs	r7, #4
30011e40:	9101      	str	r1, [sp, #4]
        t = malloc(sizeof(thread_t));
30011e42:	f002 fc51 	bl	300146e8 <malloc>
        if (!t)
30011e46:	9901      	ldr	r1, [sp, #4]
30011e48:	4604      	mov	r4, r0
30011e4a:	2800      	cmp	r0, #0
30011e4c:	d199      	bne.n	30011d82 <thread_create_etc+0x16>
            return NULL;
30011e4e:	2000      	movs	r0, #0
30011e50:	e7dd      	b.n	30011e0e <thread_create_etc+0xa2>
        stack_size += THREAD_STACK_PADDING_SIZE;
30011e52:	f506 7980 	add.w	r9, r6, #256	; 0x100
        t->stack = malloc(stack_size);
30011e56:	4648      	mov	r0, r9
30011e58:	f002 fc46 	bl	300146e8 <malloc>
30011e5c:	f8c4 0140 	str.w	r0, [r4, #320]	; 0x140
30011e60:	4680      	mov	r8, r0
        if (!t->stack) {
30011e62:	b170      	cbz	r0, 30011e82 <thread_create_etc+0x116>
        memset(t->stack, STACK_DEBUG_BYTE, THREAD_STACK_PADDING_SIZE);
30011e64:	f44f 7280 	mov.w	r2, #256	; 0x100
30011e68:	2199      	movs	r1, #153	; 0x99
30011e6a:	f002 ed82 	blx	30014970 <memset>
        memset(t->stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,
30011e6e:	4632      	mov	r2, r6
30011e70:	2199      	movs	r1, #153	; 0x99
30011e72:	f508 7080 	add.w	r0, r8, #256	; 0x100
        stack_size += THREAD_STACK_PADDING_SIZE;
30011e76:	464e      	mov	r6, r9
        flags |= THREAD_FLAG_FREE_STACK;
30011e78:	f047 0722 	orr.w	r7, r7, #34	; 0x22
        memset(t->stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,
30011e7c:	f002 ed78 	blx	30014970 <memset>
30011e80:	e7a5      	b.n	30011dce <thread_create_etc+0x62>
            if (flags & THREAD_FLAG_FREE_STRUCT)
30011e82:	2f00      	cmp	r7, #0
30011e84:	d0e3      	beq.n	30011e4e <thread_create_etc+0xe2>
                free(t);
30011e86:	4620      	mov	r0, r4
30011e88:	f002 fc80 	bl	3001478c <free>
            return NULL;
30011e8c:	4628      	mov	r0, r5
30011e8e:	e7be      	b.n	30011e0e <thread_create_etc+0xa2>

30011e90 <thread_create>:
{
30011e90:	b530      	push	{r4, r5, r14}
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
30011e92:	2400      	movs	r4, #0
{
30011e94:	b085      	sub	sp, #20
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
30011e96:	9300      	str	r3, [sp, #0]
30011e98:	4613      	mov	r3, r2
{
30011e9a:	9d08      	ldr	r5, [sp, #32]
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
30011e9c:	460a      	mov	r2, r1
30011e9e:	9401      	str	r4, [sp, #4]
30011ea0:	4601      	mov	r1, r0
30011ea2:	9502      	str	r5, [sp, #8]
30011ea4:	4620      	mov	r0, r4
30011ea6:	f7ff ff61 	bl	30011d6c <thread_create_etc>
}
30011eaa:	b005      	add	sp, #20
30011eac:	bd30      	pop	{r4, r5, r15}
30011eae:	bf00      	nop

30011eb0 <thread_yield>:
{
30011eb0:	b5f0      	push	{r4, r5, r6, r7, r14}
30011eb2:	b083      	sub	sp, #12
30011eb4:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011eb8:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011ebc:	0610      	lsls	r0, r2, #24
    spin_lock_saved_state_t state = 0;
30011ebe:	bf48      	it	mi
30011ec0:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011ec2:	d401      	bmi.n	30011ec8 <thread_yield+0x18>
    __asm__ volatile("cpsid i");
30011ec4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30011ec6:	2601      	movs	r6, #1
    THREAD_STATS_INC(yields);
30011ec8:	f24d 1158 	movw	r1, #53592	; 0xd158
    *lock = 1;
30011ecc:	2201      	movs	r2, #1
30011ece:	f24d 1450 	movw	r4, #53584	; 0xd150
30011ed2:	f2c3 0102 	movt	r1, #12290	; 0x3002
    current_thread->remaining_quantum = 0;
30011ed6:	2500      	movs	r5, #0
30011ed8:	f2c3 0402 	movt	r4, #12290	; 0x3002
    THREAD_STATS_INC(yields);
30011edc:	69c8      	ldr	r0, [r1, #28]
30011ede:	6022      	str	r2, [r4, #0]
30011ee0:	4410      	add	r0, r2
30011ee2:	61c8      	str	r0, [r1, #28]
    return !!(t->flags & THREAD_FLAG_IDLE);
30011ee4:	6a19      	ldr	r1, [r3, #32]
    current_thread->remaining_quantum = 0;
30011ee6:	e9c3 2506 	strd	r2, r5, [r3, #24]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
30011eea:	06c9      	lsls	r1, r1, #27
30011eec:	d41c      	bmi.n	30011f28 <thread_yield+0x78>
    item->prev = list->prev;
30011eee:	f24d 0144 	movw	r1, #53316	; 0xd044
    run_queue_bitmap |= (1<<t->priority);
30011ef2:	f24d 1744 	movw	r7, #53572	; 0xd144
    list_add_tail(&run_queue[t->priority], &t->queue_node);
30011ef6:	6958      	ldr	r0, [r3, #20]
30011ef8:	f2c3 0102 	movt	r1, #12290	; 0x3002
    run_queue_bitmap |= (1<<t->priority);
30011efc:	f2c3 0702 	movt	r7, #12290	; 0x3002
30011f00:	4082      	lsls	r2, r0
30011f02:	f851 5030 	ldr.w	r5, [r1, r0, lsl #3]
    list_add_tail(&run_queue[t->priority], &t->queue_node);
30011f06:	f103 0c0c 	add.w	r12, r3, #12
30011f0a:	9501      	str	r5, [sp, #4]
    run_queue_bitmap |= (1<<t->priority);
30011f0c:	683d      	ldr	r5, [r7, #0]
30011f0e:	432a      	orrs	r2, r5
30011f10:	9d01      	ldr	r5, [sp, #4]
30011f12:	60dd      	str	r5, [r3, #12]
    list_add_tail(&run_queue[t->priority], &t->queue_node);
30011f14:	eb01 05c0 	add.w	r5, r1, r0, lsl #3
    run_queue_bitmap |= (1<<t->priority);
30011f18:	603a      	str	r2, [r7, #0]
    list->prev->next = item;
30011f1a:	f851 2030 	ldr.w	r2, [r1, r0, lsl #3]
    item->next = list;
30011f1e:	611d      	str	r5, [r3, #16]
    list->prev->next = item;
30011f20:	f8c2 c004 	str.w	r12, [r2, #4]
    list->prev = item;
30011f24:	f841 c030 	str.w	r12, [r1, r0, lsl #3]
    thread_resched();
30011f28:	f7ff fdf4 	bl	30011b14 <thread_resched>
    *lock = 0;
30011f2c:	2300      	movs	r3, #0
30011f2e:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011f30:	b106      	cbz	r6, 30011f34 <thread_yield+0x84>
    __asm__ volatile("cpsie i");
30011f32:	b662      	cpsie	i
}
30011f34:	b003      	add	sp, #12
30011f36:	bdf0      	pop	{r4, r5, r6, r7, r15}

30011f38 <thread_resume>:
{
30011f38:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011f3a:	f3ef 8200 	mrs	r2, CPSR
30011f3e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011f42:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
30011f44:	bf48      	it	mi
30011f46:	f04f 0c00 	movmi.w	r12, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011f4a:	d402      	bmi.n	30011f52 <thread_resume+0x1a>
    __asm__ volatile("cpsid i");
30011f4c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30011f4e:	f04f 0c01 	mov.w	r12, #1
    *lock = 1;
30011f52:	f24d 1350 	movw	r3, #53584	; 0xd150
30011f56:	2601      	movs	r6, #1
    if (t->state == THREAD_SUSPENDED) {
30011f58:	6981      	ldr	r1, [r0, #24]
30011f5a:	f2c3 0302 	movt	r3, #12290	; 0x3002
30011f5e:	601e      	str	r6, [r3, #0]
30011f60:	bb49      	cbnz	r1, 30011fb6 <thread_resume+0x7e>
    list_add_head(&run_queue[t->priority], &t->queue_node);
30011f62:	6944      	ldr	r4, [r0, #20]
    run_queue_bitmap |= (1<<t->priority);
30011f64:	f24d 1744 	movw	r7, #53572	; 0xd144
    item->next = list->next;
30011f68:	f24d 0144 	movw	r1, #53316	; 0xd044
30011f6c:	f2c3 0702 	movt	r7, #12290	; 0x3002
30011f70:	f2c3 0102 	movt	r1, #12290	; 0x3002
30011f74:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
30011f78:	683d      	ldr	r5, [r7, #0]
        if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
30011f7a:	f082 0280 	eor.w	r2, r2, #128	; 0x80
    run_queue_bitmap |= (1<<t->priority);
30011f7e:	fa06 f404 	lsl.w	r4, r6, r4
30011f82:	432c      	orrs	r4, r5
30011f84:	684d      	ldr	r5, [r1, #4]
        if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
30011f86:	f3c2 12c0 	ubfx	r2, r2, #7, #1
30011f8a:	6105      	str	r5, [r0, #16]
    list_add_head(&run_queue[t->priority], &t->queue_node);
30011f8c:	f100 050c 	add.w	r5, r0, #12
        t->state = THREAD_READY;
30011f90:	6186      	str	r6, [r0, #24]
    list->next->prev = item;
30011f92:	684e      	ldr	r6, [r1, #4]
    run_queue_bitmap |= (1<<t->priority);
30011f94:	603c      	str	r4, [r7, #0]
    item->prev = list;
30011f96:	60c1      	str	r1, [r0, #12]
    list->next->prev = item;
30011f98:	6035      	str	r5, [r6, #0]
    list->next = item;
30011f9a:	604d      	str	r5, [r1, #4]
30011f9c:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    *lock = 0;
30011fa0:	2100      	movs	r1, #0
30011fa2:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30011fa4:	f1bc 0f00 	cmp.w	r12, #0
30011fa8:	d000      	beq.n	30011fac <thread_resume+0x74>
    __asm__ volatile("cpsie i");
30011faa:	b662      	cpsie	i
    if (resched)
30011fac:	b10a      	cbz	r2, 30011fb2 <thread_resume+0x7a>
        thread_yield();
30011fae:	f7ff ff7f 	bl	30011eb0 <thread_yield>
}
30011fb2:	2000      	movs	r0, #0
30011fb4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    bool resched = false;
30011fb6:	2200      	movs	r2, #0
30011fb8:	e7f0      	b.n	30011f9c <thread_resume+0x64>
30011fba:	bf00      	nop

30011fbc <thread_preempt>:
{
30011fbc:	b5f0      	push	{r4, r5, r6, r7, r14}
30011fbe:	b083      	sub	sp, #12
30011fc0:	ee1d 2f90 	mrc	15, 0, r2, cr13, cr0, {4}
    return !!(t->flags & THREAD_FLAG_IDLE);
30011fc4:	6a13      	ldr	r3, [r2, #32]
    if (!thread_is_idle(current_thread))
30011fc6:	f013 0410 	ands.w	r4, r3, #16
        THREAD_STATS_INC(preempts); /* only track when a meaningful preempt happens */
30011fca:	bf01      	itttt	eq
30011fcc:	f24d 1158 	movweq	r1, #53592	; 0xd158
30011fd0:	f2c3 0102 	movteq	r1, #12290	; 0x3002
30011fd4:	6988      	ldreq	r0, [r1, #24]
30011fd6:	3001      	addeq	r0, #1
30011fd8:	bf08      	it	eq
30011fda:	6188      	streq	r0, [r1, #24]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30011fdc:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30011fe0:	f011 0180 	ands.w	r1, r1, #128	; 0x80
30011fe4:	d132      	bne.n	3001204c <thread_preempt+0x90>
    __asm__ volatile("cpsid i");
30011fe6:	b672      	cpsid	i
    return !!(t->flags & THREAD_FLAG_IDLE);
30011fe8:	6a10      	ldr	r0, [r2, #32]
    *lock = 1;
30011fea:	f24d 1550 	movw	r5, #53584	; 0xd150
30011fee:	2401      	movs	r4, #1
30011ff0:	f2c3 0502 	movt	r5, #12290	; 0x3002
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
30011ff4:	06c3      	lsls	r3, r0, #27
    current_thread->state = THREAD_READY;
30011ff6:	6194      	str	r4, [r2, #24]
30011ff8:	602c      	str	r4, [r5, #0]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
30011ffa:	d442      	bmi.n	30012082 <thread_preempt+0xc6>
30011ffc:	f24d 1744 	movw	r7, #53572	; 0xd144
30012000:	2301      	movs	r3, #1
        if (current_thread->remaining_quantum > 0)
30012002:	69d0      	ldr	r0, [r2, #28]
30012004:	f2c3 0702 	movt	r7, #12290	; 0x3002
30012008:	f8d2 c014 	ldr.w	r12, [r2, #20]
3001200c:	f24d 0144 	movw	r1, #53316	; 0xd044
30012010:	2800      	cmp	r0, #0
30012012:	683e      	ldr	r6, [r7, #0]
30012014:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012018:	fa03 f30c 	lsl.w	r3, r3, r12
3001201c:	ea43 0306 	orr.w	r3, r3, r6
30012020:	f102 0e0c 	add.w	r14, r2, #12
30012024:	eb01 06cc 	add.w	r6, r1, r12, lsl #3
30012028:	dd1f      	ble.n	3001206a <thread_preempt+0xae>
    item->next = list->next;
3001202a:	6871      	ldr	r1, [r6, #4]
3001202c:	6111      	str	r1, [r2, #16]
    list->next->prev = item;
3001202e:	6871      	ldr	r1, [r6, #4]
    run_queue_bitmap |= (1<<t->priority);
30012030:	603b      	str	r3, [r7, #0]
    item->prev = list;
30012032:	60d6      	str	r6, [r2, #12]
    list->next->prev = item;
30012034:	f8c1 e000 	str.w	r14, [r1]
    list->next = item;
30012038:	f8c6 e004 	str.w	r14, [r6, #4]
    thread_resched();
3001203c:	f7ff fd6a 	bl	30011b14 <thread_resched>
    *lock = 0;
30012040:	2300      	movs	r3, #0
30012042:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30012044:	b104      	cbz	r4, 30012048 <thread_preempt+0x8c>
    __asm__ volatile("cpsie i");
30012046:	b662      	cpsie	i
}
30012048:	b003      	add	sp, #12
3001204a:	bdf0      	pop	{r4, r5, r6, r7, r15}
    *lock = 1;
3001204c:	f24d 1550 	movw	r5, #53584	; 0xd150
30012050:	2101      	movs	r1, #1
30012052:	f2c3 0502 	movt	r5, #12290	; 0x3002
    current_thread->state = THREAD_READY;
30012056:	6191      	str	r1, [r2, #24]
30012058:	6029      	str	r1, [r5, #0]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
3001205a:	2c00      	cmp	r4, #0
3001205c:	d0ce      	beq.n	30011ffc <thread_preempt+0x40>
    thread_resched();
3001205e:	f7ff fd59 	bl	30011b14 <thread_resched>
    *lock = 0;
30012062:	2300      	movs	r3, #0
30012064:	602b      	str	r3, [r5, #0]
}
30012066:	b003      	add	sp, #12
30012068:	bdf0      	pop	{r4, r5, r6, r7, r15}
    item->prev = list->prev;
3001206a:	f851 003c 	ldr.w	r0, [r1, r12, lsl #3]
3001206e:	60d0      	str	r0, [r2, #12]
    list->prev->next = item;
30012070:	f851 003c 	ldr.w	r0, [r1, r12, lsl #3]
    run_queue_bitmap |= (1<<t->priority);
30012074:	603b      	str	r3, [r7, #0]
    item->next = list;
30012076:	6116      	str	r6, [r2, #16]
    list->prev->next = item;
30012078:	f8c0 e004 	str.w	r14, [r0, #4]
    list->prev = item;
3001207c:	f841 e03c 	str.w	r14, [r1, r12, lsl #3]
30012080:	e7dc      	b.n	3001203c <thread_preempt+0x80>
30012082:	9101      	str	r1, [sp, #4]
    thread_resched();
30012084:	f7ff fd46 	bl	30011b14 <thread_resched>
30012088:	9901      	ldr	r1, [sp, #4]
3001208a:	6029      	str	r1, [r5, #0]
3001208c:	e7db      	b.n	30012046 <thread_preempt+0x8a>
3001208e:	bf00      	nop

30012090 <thread_sleep>:
{
30012090:	b5f0      	push	{r4, r5, r6, r7, r14}
30012092:	4607      	mov	r7, r0
30012094:	b089      	sub	sp, #36	; 0x24
30012096:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    timer_initialize(&timer);
3001209a:	a801      	add	r0, sp, #4
3001209c:	f000 fc0e 	bl	300128bc <timer_initialize>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300120a0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300120a4:	f013 0480 	ands.w	r4, r3, #128	; 0x80
300120a8:	d119      	bne.n	300120de <thread_sleep+0x4e>
    __asm__ volatile("cpsid i");
300120aa:	b672      	cpsid	i
    *lock = 1;
300120ac:	f24d 1650 	movw	r6, #53584	; 0xd150
300120b0:	f04f 0c01 	mov.w	r12, #1
    timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
300120b4:	f641 42b9 	movw	r2, #7353	; 0x1cb9
300120b8:	f2c3 0602 	movt	r6, #12290	; 0x3002
300120bc:	4639      	mov	r1, r7
300120be:	a801      	add	r0, sp, #4
300120c0:	462b      	mov	r3, r5
300120c2:	f2c3 0201 	movt	r2, #12289	; 0x3001
300120c6:	f8c6 c000 	str.w	r12, [r6]
300120ca:	f000 fc05 	bl	300128d8 <timer_set_oneshot>
    current_thread->state = THREAD_SLEEPING;
300120ce:	2304      	movs	r3, #4
300120d0:	61ab      	str	r3, [r5, #24]
    thread_resched();
300120d2:	f7ff fd1f 	bl	30011b14 <thread_resched>
    *lock = 0;
300120d6:	6034      	str	r4, [r6, #0]
    __asm__ volatile("cpsie i");
300120d8:	b662      	cpsie	i
}
300120da:	b009      	add	sp, #36	; 0x24
300120dc:	bdf0      	pop	{r4, r5, r6, r7, r15}
    *lock = 1;
300120de:	f24d 1450 	movw	r4, #53584	; 0xd150
300120e2:	2601      	movs	r6, #1
    timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
300120e4:	f641 42b9 	movw	r2, #7353	; 0x1cb9
300120e8:	f2c3 0402 	movt	r4, #12290	; 0x3002
300120ec:	4639      	mov	r1, r7
300120ee:	a801      	add	r0, sp, #4
300120f0:	462b      	mov	r3, r5
300120f2:	f2c3 0201 	movt	r2, #12289	; 0x3001
300120f6:	6026      	str	r6, [r4, #0]
300120f8:	f000 fbee 	bl	300128d8 <timer_set_oneshot>
    current_thread->state = THREAD_SLEEPING;
300120fc:	2304      	movs	r3, #4
300120fe:	61ab      	str	r3, [r5, #24]
    thread_resched();
30012100:	f7ff fd08 	bl	30011b14 <thread_resched>
    *lock = 0;
30012104:	2300      	movs	r3, #0
30012106:	6023      	str	r3, [r4, #0]
}
30012108:	b009      	add	sp, #36	; 0x24
3001210a:	bdf0      	pop	{r4, r5, r6, r7, r15}

3001210c <thread_init_early>:
{
3001210c:	f24d 0344 	movw	r3, #53316	; 0xd044
30012110:	f2c3 0302 	movt	r3, #12290	; 0x3002
30012114:	f503 7280 	add.w	r2, r3, #256	; 0x100
30012118:	b570      	push	{r4, r5, r6, r14}
    list->prev = list->next = list;
3001211a:	e9c3 3300 	strd	r3, r3, [r3]
3001211e:	3308      	adds	r3, #8
    for (i=0; i < NUM_PRIORITIES; i++)
30012120:	4293      	cmp	r3, r2
30012122:	d1fa      	bne.n	3001211a <thread_init_early+0xe>
30012124:	f24d 1548 	movw	r5, #53576	; 0xd148
    init_thread_struct(t, "bootstrap");
30012128:	f64c 64a0 	movw	r4, #52896	; 0xcea0
3001212c:	f2c3 0402 	movt	r4, #12290	; 0x3002
30012130:	f640 114c 	movw	r1, #2380	; 0x94c
30012134:	f2c3 0502 	movt	r5, #12290	; 0x3002
30012138:	4620      	mov	r0, r4
3001213a:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001213e:	e9c5 5500 	strd	r5, r5, [r5]
30012142:	f7ff fcd1 	bl	30011ae8 <init_thread_struct>
    t->priority = HIGHEST_PRIORITY;
30012146:	211f      	movs	r1, #31
    t->state = THREAD_RUNNING;
30012148:	2302      	movs	r3, #2
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
3001214a:	f646 1274 	movw	r2, #26996	; 0x6974
    t->flags = THREAD_FLAG_DETACHED;
3001214e:	2601      	movs	r6, #1
    t->priority = HIGHEST_PRIORITY;
30012150:	6161      	str	r1, [r4, #20]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30012152:	f2c7 7261 	movt	r2, #30561	; 0x7761
    t->state = THREAD_RUNNING;
30012156:	61a3      	str	r3, [r4, #24]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
30012158:	f504 71ac 	add.w	r1, r4, #344	; 0x158
    item->prev = list;
3001215c:	4623      	mov	r3, r4
3001215e:	2000      	movs	r0, #0
30012160:	f8c4 2154 	str.w	r2, [r4, #340]	; 0x154
    item->next = list->next;
30012164:	686a      	ldr	r2, [r5, #4]
    item->prev = list;
30012166:	f843 5f04 	str.w	r5, [r3, #4]!
    t->flags = THREAD_FLAG_DETACHED;
3001216a:	6226      	str	r6, [r4, #32]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
3001216c:	f8c4 0160 	str.w	r0, [r4, #352]	; 0x160
30012170:	f8c4 1158 	str.w	r1, [r4, #344]	; 0x158
30012174:	f8c4 115c 	str.w	r1, [r4, #348]	; 0x15c
    item->next = list->next;
30012178:	60a2      	str	r2, [r4, #8]
    list->next->prev = item;
3001217a:	6013      	str	r3, [r2, #0]
    list->next = item;
3001217c:	606b      	str	r3, [r5, #4]
3001217e:	ee0d 4f90 	mcr	15, 0, r4, cr13, cr0, {4}
30012182:	f3bf 8f6f 	isb	sy
}
30012186:	bd70      	pop	{r4, r5, r6, r15}

30012188 <thread_init>:
        timer_initialize(&preempt_timer[i]);
30012188:	f24d 0028 	movw	r0, #53288	; 0xd028
3001218c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012190:	f000 bb94 	b.w	300128bc <timer_initialize>

30012194 <thread_become_idle>:
{
30012194:	b508      	push	{r3, r14}
30012196:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
3001219a:	ee1d 0f90 	mrc	15, 0, r0, cr13, cr0, {4}
    strlcpy(current_thread->name, name, sizeof(current_thread->name));
3001219e:	f640 1120 	movw	r1, #2336	; 0x920
300121a2:	2220      	movs	r2, #32
300121a4:	f2c3 0102 	movt	r1, #12290	; 0x3002
300121a8:	f500 70b2 	add.w	r0, r0, #356	; 0x164
300121ac:	f003 fd9e 	bl	30015cec <strlcpy>
    t->flags |= THREAD_FLAG_IDLE;
300121b0:	6a23      	ldr	r3, [r4, #32]
    t->priority = IDLE_PRIORITY;
300121b2:	2200      	movs	r2, #0
    t->flags |= THREAD_FLAG_IDLE;
300121b4:	f043 0310 	orr.w	r3, r3, #16
    t->priority = IDLE_PRIORITY;
300121b8:	6162      	str	r2, [r4, #20]
    t->flags |= THREAD_FLAG_IDLE;
300121ba:	6223      	str	r3, [r4, #32]
300121bc:	b662      	cpsie	i
    thread_yield();
300121be:	f7ff fe77 	bl	30011eb0 <thread_yield>
        arch_idle();
300121c2:	f7ee edae 	blx	30000d20 <arch_idle>
300121c6:	e7fc      	b.n	300121c2 <thread_become_idle+0x2e>

300121c8 <wait_queue_block>:
 *
 * @return ERR_TIMED_OUT on timeout, else returns the return
 * value specified when the queue was woken by wait_queue_wake_one().
 */
status_t wait_queue_block(wait_queue_t *wait, lk_time_t timeout)
{
300121c8:	b5f0      	push	{r4, r5, r6, r7, r14}
300121ca:	b089      	sub	sp, #36	; 0x24
300121cc:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(current_thread->state == THREAD_RUNNING);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (timeout == 0)
300121d0:	b359      	cbz	r1, 3001222a <wait_queue_block+0x62>
    item->prev = list->prev;
300121d2:	4605      	mov	r5, r0
        return ERR_TIMED_OUT;

    list_add_tail(&wait->list, &current_thread->queue_node);
300121d4:	f104 030c 	add.w	r3, r4, #12
    wait->count++;
300121d8:	68c2      	ldr	r2, [r0, #12]
300121da:	460e      	mov	r6, r1
    current_thread->state = THREAD_BLOCKED;
300121dc:	2703      	movs	r7, #3
300121de:	f855 1f04 	ldr.w	r1, [r5, #4]!
    wait->count++;
300121e2:	3201      	adds	r2, #1
300121e4:	60e1      	str	r1, [r4, #12]
    current_thread->blocking_wait_queue = wait;
    current_thread->wait_queue_block_ret = NO_ERROR;
300121e6:	2100      	movs	r1, #0
    item->next = list;
300121e8:	6125      	str	r5, [r4, #16]
    list->prev->next = item;
300121ea:	6845      	ldr	r5, [r0, #4]
300121ec:	606b      	str	r3, [r5, #4]
    list->prev = item;
300121ee:	6043      	str	r3, [r0, #4]

    /* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
    if (timeout != INFINITE_TIME) {
300121f0:	1c73      	adds	r3, r6, #1
    wait->count++;
300121f2:	60c2      	str	r2, [r0, #12]
    current_thread->blocking_wait_queue = wait;
300121f4:	6260      	str	r0, [r4, #36]	; 0x24
    current_thread->state = THREAD_BLOCKED;
300121f6:	61a7      	str	r7, [r4, #24]
    current_thread->wait_queue_block_ret = NO_ERROR;
300121f8:	62a1      	str	r1, [r4, #40]	; 0x28
    if (timeout != INFINITE_TIME) {
300121fa:	d104      	bne.n	30012206 <wait_queue_block+0x3e>
        timer_initialize(&timer);
        timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
    }

    thread_resched();
300121fc:	f7ff fc8a 	bl	30011b14 <thread_resched>
    /* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
    if (timeout != INFINITE_TIME) {
        timer_cancel(&timer);
    }

    return current_thread->wait_queue_block_ret;
30012200:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
30012202:	b009      	add	sp, #36	; 0x24
30012204:	bdf0      	pop	{r4, r5, r6, r7, r15}
        timer_initialize(&timer);
30012206:	a801      	add	r0, sp, #4
30012208:	f000 fb58 	bl	300128bc <timer_initialize>
        timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
3001220c:	f242 6289 	movw	r2, #9865	; 0x2689
30012210:	4623      	mov	r3, r4
30012212:	a801      	add	r0, sp, #4
30012214:	4631      	mov	r1, r6
30012216:	f2c3 0201 	movt	r2, #12289	; 0x3001
3001221a:	f000 fb5d 	bl	300128d8 <timer_set_oneshot>
    thread_resched();
3001221e:	f7ff fc79 	bl	30011b14 <thread_resched>
        timer_cancel(&timer);
30012222:	a801      	add	r0, sp, #4
30012224:	f000 fb74 	bl	30012910 <timer_cancel>
30012228:	e7ea      	b.n	30012200 <wait_queue_block+0x38>
        return ERR_TIMED_OUT;
3001222a:	f06f 000c 	mvn.w	r0, #12
3001222e:	e7e8      	b.n	30012202 <wait_queue_block+0x3a>

30012230 <thread_join>:
{
30012230:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30012232:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30012236:	f013 0380 	ands.w	r3, r3, #128	; 0x80
3001223a:	d12b      	bne.n	30012294 <thread_join+0x64>
    __asm__ volatile("cpsid i");
3001223c:	b672      	cpsid	i
    if (t->flags & THREAD_FLAG_DETACHED) {
3001223e:	6a04      	ldr	r4, [r0, #32]
    *lock = 1;
30012240:	f24d 1650 	movw	r6, #53584	; 0xd150
30012244:	2701      	movs	r7, #1
30012246:	f2c3 0602 	movt	r6, #12290	; 0x3002
3001224a:	07e4      	lsls	r4, r4, #31
3001224c:	6037      	str	r7, [r6, #0]
3001224e:	d446      	bmi.n	300122de <thread_join+0xae>
    if (t->state != THREAD_DEATH) {
30012250:	6983      	ldr	r3, [r0, #24]
30012252:	460d      	mov	r5, r1
30012254:	4604      	mov	r4, r0
30012256:	2b05      	cmp	r3, #5
30012258:	d12f      	bne.n	300122ba <thread_join+0x8a>
    if (retcode)
3001225a:	b115      	cbz	r5, 30012262 <thread_join+0x32>
        *retcode = t->retcode;
3001225c:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
30012260:	602b      	str	r3, [r5, #0]
    item->next->prev = item->prev;
30012262:	6861      	ldr	r1, [r4, #4]
    item->prev = item->next = 0;
30012264:	2300      	movs	r3, #0
    item->next->prev = item->prev;
30012266:	68a2      	ldr	r2, [r4, #8]
30012268:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
3001226a:	6861      	ldr	r1, [r4, #4]
3001226c:	604a      	str	r2, [r1, #4]
    t->magic = 0;
3001226e:	6023      	str	r3, [r4, #0]
    item->prev = item->next = 0;
30012270:	e9c4 3301 	strd	r3, r3, [r4, #4]
    *lock = 0;
30012274:	6033      	str	r3, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30012276:	b107      	cbz	r7, 3001227a <thread_join+0x4a>
    __asm__ volatile("cpsie i");
30012278:	b662      	cpsie	i
    if (t->flags & THREAD_FLAG_FREE_STACK && t->stack)
3001227a:	6a23      	ldr	r3, [r4, #32]
3001227c:	079a      	lsls	r2, r3, #30
3001227e:	d505      	bpl.n	3001228c <thread_join+0x5c>
30012280:	f8d4 0140 	ldr.w	r0, [r4, #320]	; 0x140
30012284:	b110      	cbz	r0, 3001228c <thread_join+0x5c>
        free(t->stack);
30012286:	f002 fa81 	bl	3001478c <free>
3001228a:	6a23      	ldr	r3, [r4, #32]
    if (t->flags & THREAD_FLAG_FREE_STRUCT)
3001228c:	f013 0004 	ands.w	r0, r3, #4
30012290:	d120      	bne.n	300122d4 <thread_join+0xa4>
}
30012292:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (t->flags & THREAD_FLAG_DETACHED) {
30012294:	6a07      	ldr	r7, [r0, #32]
    *lock = 1;
30012296:	f24d 1650 	movw	r6, #53584	; 0xd150
3001229a:	2301      	movs	r3, #1
3001229c:	f2c3 0602 	movt	r6, #12290	; 0x3002
300122a0:	401f      	ands	r7, r3
300122a2:	6033      	str	r3, [r6, #0]
    *lock = 0;
300122a4:	bf1e      	ittt	ne
300122a6:	2300      	movne	r3, #0
        return ERR_THREAD_DETACHED;
300122a8:	f06f 0021 	mvnne.w	r0, #33	; 0x21
300122ac:	6033      	strne	r3, [r6, #0]
    if (t->flags & THREAD_FLAG_DETACHED) {
300122ae:	d1f0      	bne.n	30012292 <thread_join+0x62>
    if (t->state != THREAD_DEATH) {
300122b0:	6983      	ldr	r3, [r0, #24]
300122b2:	460d      	mov	r5, r1
300122b4:	4604      	mov	r4, r0
300122b6:	2b05      	cmp	r3, #5
300122b8:	d0cf      	beq.n	3001225a <thread_join+0x2a>
        status_t err = wait_queue_block(&t->retcode_wait_queue, timeout);
300122ba:	4611      	mov	r1, r2
300122bc:	f500 70aa 	add.w	r0, r0, #340	; 0x154
300122c0:	f7ff ff82 	bl	300121c8 <wait_queue_block>
        if (err < 0) {
300122c4:	2800      	cmp	r0, #0
300122c6:	dac8      	bge.n	3001225a <thread_join+0x2a>
300122c8:	2300      	movs	r3, #0
300122ca:	6033      	str	r3, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300122cc:	2f00      	cmp	r7, #0
300122ce:	d0e0      	beq.n	30012292 <thread_join+0x62>
300122d0:	b662      	cpsie	i
}
300122d2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        free(t);
300122d4:	4620      	mov	r0, r4
300122d6:	f002 fa59 	bl	3001478c <free>
    return NO_ERROR;
300122da:	2000      	movs	r0, #0
}
300122dc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    *lock = 0;
300122de:	6033      	str	r3, [r6, #0]
300122e0:	b662      	cpsie	i
        return ERR_THREAD_DETACHED;
300122e2:	f06f 0021 	mvn.w	r0, #33	; 0x21
}
300122e6:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

300122e8 <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
300122e8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
300122ea:	4696      	mov	r14, r2
300122ec:	ee1d cf90 	mrc	15, 0, r12, cr13, cr0, {4}
    if (list->next != list) {
300122f0:	6883      	ldr	r3, [r0, #8]

    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    t = list_remove_head_type(&wait->list, thread_t, queue_node);
300122f2:	1d02      	adds	r2, r0, #4
300122f4:	4293      	cmp	r3, r2
300122f6:	d048      	beq.n	3001238a <wait_queue_wake_one+0xa2>
    item->next->prev = item->prev;
300122f8:	685d      	ldr	r5, [r3, #4]
    item->prev = item->next = 0;
300122fa:	2200      	movs	r2, #0
    item->next->prev = item->prev;
300122fc:	681e      	ldr	r6, [r3, #0]
    item->prev = item->next = 0;
300122fe:	461c      	mov	r4, r3
    item->next->prev = item->prev;
30012300:	602e      	str	r6, [r5, #0]
    if (t) {
30012302:	2b0c      	cmp	r3, #12
    item->prev->next = item->next;
30012304:	681e      	ldr	r6, [r3, #0]
30012306:	6075      	str	r5, [r6, #4]
    item->prev = item->next = 0;
30012308:	605a      	str	r2, [r3, #4]
3001230a:	f844 290c 	str.w	r2, [r4], #-12
3001230e:	d03c      	beq.n	3001238a <wait_queue_wake_one+0xa2>
        wait->count--;
30012310:	68c5      	ldr	r5, [r0, #12]
30012312:	f24d 1644 	movw	r6, #53572	; 0xd144
30012316:	f2c3 0602 	movt	r6, #12290	; 0x3002
3001231a:	1e6f      	subs	r7, r5, #1
        DEBUG_ASSERT(t->state == THREAD_BLOCKED);
        t->state = THREAD_READY;
3001231c:	2501      	movs	r5, #1
        wait->count--;
3001231e:	60c7      	str	r7, [r0, #12]
        t->wait_queue_block_ret = wait_queue_error;
        t->blocking_wait_queue = NULL;
30012320:	e9c4 2e09 	strd	r2, r14, [r4, #36]	; 0x24
30012324:	6837      	ldr	r7, [r6, #0]
        t->state = THREAD_READY;
30012326:	61a5      	str	r5, [r4, #24]

        /* if we're instructed to reschedule, stick the current thread on the head
         * of the run queue first, so that the newly awakened thread gets a chance to run
         * before the current one, but the current one doesn't get unnecessarilly punished.
         */
        if (reschedule) {
30012328:	b1e1      	cbz	r1, 30012364 <wait_queue_wake_one+0x7c>
    return !!(t->flags & THREAD_FLAG_IDLE);
3001232a:	f8dc 2020 	ldr.w	r2, [r12, #32]
            current_thread->state = THREAD_READY;
3001232e:	f8cc 5018 	str.w	r5, [r12, #24]
            if (!thread_is_idle(current_thread))
30012332:	06d2      	lsls	r2, r2, #27
30012334:	bf44      	itt	mi
30012336:	f24d 0244 	movwmi	r2, #53316	; 0xd044
3001233a:	f2c3 0202 	movtmi	r2, #12290	; 0x3002
3001233e:	d526      	bpl.n	3001238e <wait_queue_wake_one+0xa6>
    list_add_head(&run_queue[t->priority], &t->queue_node);
30012340:	6961      	ldr	r1, [r4, #20]
    run_queue_bitmap |= (1<<t->priority);
30012342:	2501      	movs	r5, #1
    item->next = list->next;
30012344:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
30012348:	fa05 f101 	lsl.w	r1, r5, r1
3001234c:	4339      	orrs	r1, r7
3001234e:	6850      	ldr	r0, [r2, #4]
30012350:	6120      	str	r0, [r4, #16]
    list->next->prev = item;
30012352:	6850      	ldr	r0, [r2, #4]
    item->prev = list;
30012354:	60e2      	str	r2, [r4, #12]
    list->next->prev = item;
30012356:	6003      	str	r3, [r0, #0]
    list->next = item;
30012358:	6053      	str	r3, [r2, #4]
3001235a:	6031      	str	r1, [r6, #0]
                insert_in_run_queue_head(current_thread);
        }
        insert_in_run_queue_head(t);
        thread_mp_reschedule(current_thread, t);
        if (reschedule) {
            thread_resched();
3001235c:	f7ff fbda 	bl	30011b14 <thread_resched>
        }
        ret = 1;
30012360:	4628      	mov	r0, r5

    }

    return ret;
}
30012362:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
30012364:	6960      	ldr	r0, [r4, #20]
    item->next = list->next;
30012366:	f24d 0244 	movw	r2, #53316	; 0xd044
3001236a:	f2c3 0202 	movt	r2, #12290	; 0x3002
    run_queue_bitmap |= (1<<t->priority);
3001236e:	fa05 f100 	lsl.w	r1, r5, r0
30012372:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
        ret = 1;
30012376:	4628      	mov	r0, r5
    run_queue_bitmap |= (1<<t->priority);
30012378:	4339      	orrs	r1, r7
3001237a:	6855      	ldr	r5, [r2, #4]
3001237c:	6125      	str	r5, [r4, #16]
    list->next->prev = item;
3001237e:	6855      	ldr	r5, [r2, #4]
30012380:	6031      	str	r1, [r6, #0]
    item->prev = list;
30012382:	60e2      	str	r2, [r4, #12]
    list->next->prev = item;
30012384:	602b      	str	r3, [r5, #0]
    list->next = item;
30012386:	6053      	str	r3, [r2, #4]
}
30012388:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    int ret = 0;
3001238a:	2000      	movs	r0, #0
}
3001238c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
3001238e:	f8dc 0014 	ldr.w	r0, [r12, #20]
    item->next = list->next;
30012392:	f24d 0244 	movw	r2, #53316	; 0xd044
30012396:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001239a:	f10c 0e0c 	add.w	r14, r12, #12
3001239e:	eb02 01c0 	add.w	r1, r2, r0, lsl #3
    run_queue_bitmap |= (1<<t->priority);
300123a2:	fa05 f000 	lsl.w	r0, r5, r0
300123a6:	4307      	orrs	r7, r0
300123a8:	6848      	ldr	r0, [r1, #4]
300123aa:	f8cc 0010 	str.w	r0, [r12, #16]
    list->next->prev = item;
300123ae:	6848      	ldr	r0, [r1, #4]
    item->prev = list;
300123b0:	f8cc 100c 	str.w	r1, [r12, #12]
    list->next->prev = item;
300123b4:	f8c0 e000 	str.w	r14, [r0]
    list->next = item;
300123b8:	f8c1 e004 	str.w	r14, [r1, #4]
300123bc:	e7c0      	b.n	30012340 <wait_queue_wake_one+0x58>
300123be:	bf00      	nop

300123c0 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
300123c0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300123c4:	b083      	sub	sp, #12
300123c6:	9101      	str	r1, [sp, #4]
300123c8:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}

    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (reschedule && wait->count > 0) {
300123cc:	b139      	cbz	r1, 300123de <wait_queue_wake_all+0x1e>
300123ce:	68c1      	ldr	r1, [r0, #12]
300123d0:	2900      	cmp	r1, #0
300123d2:	dd04      	ble.n	300123de <wait_queue_wake_all+0x1e>
    return !!(t->flags & THREAD_FLAG_IDLE);
300123d4:	6a1c      	ldr	r4, [r3, #32]
        /* if we're instructed to reschedule, stick the current thread on the head
         * of the run queue first, so that the newly awakened threads get a chance to run
         * before the current one, but the current one doesn't get unnecessarilly punished.
         */
        current_thread->state = THREAD_READY;
300123d6:	2101      	movs	r1, #1
300123d8:	6199      	str	r1, [r3, #24]
        if (!thread_is_idle(current_thread))
300123da:	06e4      	lsls	r4, r4, #27
300123dc:	d55a      	bpl.n	30012494 <wait_queue_wake_all+0xd4>
    if (list->next != list) {
300123de:	6881      	ldr	r1, [r0, #8]
            insert_in_run_queue_head(current_thread);
    }

    /* pop all the threads off the wait queue into the run queue */
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
300123e0:	f100 0e04 	add.w	r14, r0, #4
300123e4:	458e      	cmp	r14, r1
300123e6:	d050      	beq.n	3001248a <wait_queue_wake_all+0xca>
    item->next->prev = item->prev;
300123e8:	684e      	ldr	r6, [r1, #4]
    item->prev = item->next = 0;
300123ea:	2400      	movs	r4, #0
    item->next->prev = item->prev;
300123ec:	680d      	ldr	r5, [r1, #0]
    item->prev = item->next = 0;
300123ee:	460b      	mov	r3, r1
    item->next->prev = item->prev;
300123f0:	6035      	str	r5, [r6, #0]
300123f2:	290c      	cmp	r1, #12
    item->prev->next = item->next;
300123f4:	680d      	ldr	r5, [r1, #0]
300123f6:	606e      	str	r6, [r5, #4]
    item->prev = item->next = 0;
300123f8:	604c      	str	r4, [r1, #4]
300123fa:	f843 490c 	str.w	r4, [r3], #-12
300123fe:	d044      	beq.n	3001248a <wait_queue_wake_all+0xca>
30012400:	f24d 1b44 	movw	r11, #53572	; 0xd144
30012404:	f24d 0c44 	movw	r12, #53316	; 0xd044
30012408:	68c1      	ldr	r1, [r0, #12]
3001240a:	f2c3 0b02 	movt	r11, #12290	; 0x3002
        wait->count--;
        DEBUG_ASSERT(t->state == THREAD_BLOCKED);
        t->state = THREAD_READY;
        t->wait_queue_block_ret = wait_queue_error;
        t->blocking_wait_queue = NULL;
3001240e:	4625      	mov	r5, r4
30012410:	f2c3 0c02 	movt	r12, #12290	; 0x3002
        t->state = THREAD_READY;
30012414:	2701      	movs	r7, #1
30012416:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
3001241a:	f8db 6000 	ldr.w	r6, [r11]
3001241e:	9200      	str	r2, [sp, #0]
    list_add_head(&run_queue[t->priority], &t->queue_node);
30012420:	f8d3 9014 	ldr.w	r9, [r3, #20]
30012424:	f103 0a0c 	add.w	r10, r3, #12
        t->wait_queue_block_ret = wait_queue_error;
30012428:	9a00      	ldr	r2, [sp, #0]
3001242a:	629a      	str	r2, [r3, #40]	; 0x28
        t->state = THREAD_READY;
3001242c:	619f      	str	r7, [r3, #24]
    item->next = list->next;
3001242e:	eb0c 01c9 	add.w	r1, r12, r9, lsl #3
        t->blocking_wait_queue = NULL;
30012432:	625d      	str	r5, [r3, #36]	; 0x24
    run_queue_bitmap |= (1<<t->priority);
30012434:	fa07 f909 	lsl.w	r9, r7, r9
30012438:	684a      	ldr	r2, [r1, #4]
3001243a:	ea46 0609 	orr.w	r6, r6, r9
3001243e:	611a      	str	r2, [r3, #16]
30012440:	eba8 0904 	sub.w	r9, r8, r4
    item->prev = list;
30012444:	60d9      	str	r1, [r3, #12]

        insert_in_run_queue_head(t);
        mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
        ret++;
30012446:	3401      	adds	r4, #1
    list->next->prev = item;
30012448:	684b      	ldr	r3, [r1, #4]
3001244a:	f8c3 a000 	str.w	r10, [r3]
    list->next = item;
3001244e:	f8c1 a004 	str.w	r10, [r1, #4]
    if (list->next != list) {
30012452:	6881      	ldr	r1, [r0, #8]
    item->prev = item->next = 0;
30012454:	460b      	mov	r3, r1
    if (list->next != list) {
30012456:	4571      	cmp	r1, r14
30012458:	d00b      	beq.n	30012472 <wait_queue_wake_all+0xb2>
    item->next->prev = item->prev;
3001245a:	e9d1 2a00 	ldrd	r2, r10, [r1]
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
3001245e:	290c      	cmp	r1, #12
30012460:	f8ca 2000 	str.w	r2, [r10]
    item->prev->next = item->next;
30012464:	680a      	ldr	r2, [r1, #0]
30012466:	f8c2 a004 	str.w	r10, [r2, #4]
    item->prev = item->next = 0;
3001246a:	604d      	str	r5, [r1, #4]
3001246c:	f843 590c 	str.w	r5, [r3], #-12
30012470:	d1d6      	bne.n	30012420 <wait_queue_wake_all+0x60>

    DEBUG_ASSERT(wait->count == 0);

    if (ret > 0) {
        mp_reschedule(mp_reschedule_target, 0);
        if (reschedule) {
30012472:	9b01      	ldr	r3, [sp, #4]
30012474:	f8c0 900c 	str.w	r9, [r0, #12]
30012478:	f8cb 6000 	str.w	r6, [r11]
3001247c:	b133      	cbz	r3, 3001248c <wait_queue_wake_all+0xcc>
            thread_resched();
3001247e:	f7ff fb49 	bl	30011b14 <thread_resched>
        }
    }

    return ret;
}
30012482:	4620      	mov	r0, r4
30012484:	b003      	add	sp, #12
30012486:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
3001248a:	2400      	movs	r4, #0
}
3001248c:	4620      	mov	r0, r4
3001248e:	b003      	add	sp, #12
30012490:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
30012494:	695f      	ldr	r7, [r3, #20]
    run_queue_bitmap |= (1<<t->priority);
30012496:	f24d 1644 	movw	r6, #53572	; 0xd144
    item->next = list->next;
3001249a:	f24d 0c44 	movw	r12, #53316	; 0xd044
3001249e:	f2c3 0602 	movt	r6, #12290	; 0x3002
300124a2:	f2c3 0c02 	movt	r12, #12290	; 0x3002
300124a6:	eb0c 04c7 	add.w	r4, r12, r7, lsl #3
300124aa:	6835      	ldr	r5, [r6, #0]
300124ac:	40b9      	lsls	r1, r7
300124ae:	4329      	orrs	r1, r5
300124b0:	6865      	ldr	r5, [r4, #4]
    list_add_head(&run_queue[t->priority], &t->queue_node);
300124b2:	f103 070c 	add.w	r7, r3, #12
300124b6:	611d      	str	r5, [r3, #16]
    list->next->prev = item;
300124b8:	6865      	ldr	r5, [r4, #4]
    run_queue_bitmap |= (1<<t->priority);
300124ba:	6031      	str	r1, [r6, #0]
    item->prev = list;
300124bc:	60dc      	str	r4, [r3, #12]
    list->next->prev = item;
300124be:	602f      	str	r7, [r5, #0]
    list->next = item;
300124c0:	6067      	str	r7, [r4, #4]
300124c2:	e78c      	b.n	300123de <wait_queue_wake_all+0x1e>

300124c4 <thread_detach>:
{
300124c4:	b570      	push	{r4, r5, r6, r14}
300124c6:	4604      	mov	r4, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300124c8:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300124cc:	f011 0580 	ands.w	r5, r1, #128	; 0x80
300124d0:	f500 70aa 	add.w	r0, r0, #340	; 0x154
300124d4:	d116      	bne.n	30012504 <thread_detach+0x40>
    __asm__ volatile("cpsid i");
300124d6:	b672      	cpsid	i
    *lock = 1;
300124d8:	f24d 1650 	movw	r6, #53584	; 0xd150
300124dc:	2301      	movs	r3, #1
    wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
300124de:	4629      	mov	r1, r5
300124e0:	f2c3 0602 	movt	r6, #12290	; 0x3002
300124e4:	f06f 0221 	mvn.w	r2, #33	; 0x21
300124e8:	6033      	str	r3, [r6, #0]
300124ea:	f7ff ff69 	bl	300123c0 <wait_queue_wake_all>
    if (t->state == THREAD_DEATH) {
300124ee:	69a3      	ldr	r3, [r4, #24]
300124f0:	2b05      	cmp	r3, #5
300124f2:	d01d      	beq.n	30012530 <thread_detach+0x6c>
        t->flags |= THREAD_FLAG_DETACHED;
300124f4:	6a23      	ldr	r3, [r4, #32]
    *lock = 0;
300124f6:	6035      	str	r5, [r6, #0]
300124f8:	f043 0301 	orr.w	r3, r3, #1
300124fc:	6223      	str	r3, [r4, #32]
    __asm__ volatile("cpsie i");
300124fe:	b662      	cpsie	i
}
30012500:	2000      	movs	r0, #0
30012502:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 1;
30012504:	f24d 1550 	movw	r5, #53584	; 0xd150
30012508:	2301      	movs	r3, #1
3001250a:	f2c3 0502 	movt	r5, #12290	; 0x3002
    wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
3001250e:	2100      	movs	r1, #0
30012510:	f06f 0221 	mvn.w	r2, #33	; 0x21
30012514:	602b      	str	r3, [r5, #0]
30012516:	f7ff ff53 	bl	300123c0 <wait_queue_wake_all>
    if (t->state == THREAD_DEATH) {
3001251a:	69a3      	ldr	r3, [r4, #24]
3001251c:	2b05      	cmp	r3, #5
3001251e:	d014      	beq.n	3001254a <thread_detach+0x86>
        t->flags |= THREAD_FLAG_DETACHED;
30012520:	6a23      	ldr	r3, [r4, #32]
    *lock = 0;
30012522:	2200      	movs	r2, #0
}
30012524:	2000      	movs	r0, #0
30012526:	602a      	str	r2, [r5, #0]
        t->flags |= THREAD_FLAG_DETACHED;
30012528:	f043 0301 	orr.w	r3, r3, #1
3001252c:	6223      	str	r3, [r4, #32]
}
3001252e:	bd70      	pop	{r4, r5, r6, r15}
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
30012530:	6a23      	ldr	r3, [r4, #32]
30012532:	6035      	str	r5, [r6, #0]
30012534:	f023 0301 	bic.w	r3, r3, #1
30012538:	6223      	str	r3, [r4, #32]
3001253a:	b662      	cpsie	i
        return thread_join(t, NULL, 0);
3001253c:	2200      	movs	r2, #0
3001253e:	4620      	mov	r0, r4
30012540:	4611      	mov	r1, r2
}
30012542:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        return thread_join(t, NULL, 0);
30012546:	f7ff be73 	b.w	30012230 <thread_join>
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
3001254a:	6a23      	ldr	r3, [r4, #32]
3001254c:	2200      	movs	r2, #0
        return thread_join(t, NULL, 0);
3001254e:	4620      	mov	r0, r4
30012550:	602a      	str	r2, [r5, #0]
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
30012552:	f023 0301 	bic.w	r3, r3, #1
        return thread_join(t, NULL, 0);
30012556:	2200      	movs	r2, #0
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
30012558:	6223      	str	r3, [r4, #32]
        return thread_join(t, NULL, 0);
3001255a:	4611      	mov	r1, r2
}
3001255c:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        return thread_join(t, NULL, 0);
30012560:	f7ff be66 	b.w	30012230 <thread_join>

30012564 <thread_detach_and_resume>:
{
30012564:	b510      	push	{r4, r14}
30012566:	4604      	mov	r4, r0
    err = thread_detach(t);
30012568:	f7ff ffac 	bl	300124c4 <thread_detach>
    if (err < 0)
3001256c:	2800      	cmp	r0, #0
3001256e:	db04      	blt.n	3001257a <thread_detach_and_resume+0x16>
    return thread_resume(t);
30012570:	4620      	mov	r0, r4
}
30012572:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    return thread_resume(t);
30012576:	f7ff bcdf 	b.w	30011f38 <thread_resume>
}
3001257a:	bd10      	pop	{r4, r15}

3001257c <thread_exit>:
{
3001257c:	b508      	push	{r3, r14}
3001257e:	4675      	mov	r5, r14
30012580:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30012584:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30012588:	0619      	lsls	r1, r3, #24
3001258a:	d400      	bmi.n	3001258e <thread_exit+0x12>
    __asm__ volatile("cpsid i");
3001258c:	b672      	cpsid	i
    *lock = 1;
3001258e:	f24d 1250 	movw	r2, #53584	; 0xd150
30012592:	2601      	movs	r6, #1
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
30012594:	6a23      	ldr	r3, [r4, #32]
30012596:	f2c3 0202 	movt	r2, #12290	; 0x3002
    current_thread->retcode = retcode;
3001259a:	f8c4 0150 	str.w	r0, [r4, #336]	; 0x150
    current_thread->state = THREAD_DEATH;
3001259e:	2105      	movs	r1, #5
300125a0:	6016      	str	r6, [r2, #0]
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
300125a2:	ea13 0206 	ands.w	r2, r3, r6
    current_thread->state = THREAD_DEATH;
300125a6:	61a1      	str	r1, [r4, #24]
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
300125a8:	d022      	beq.n	300125f0 <thread_exit+0x74>
    item->next->prev = item->prev;
300125aa:	6860      	ldr	r0, [r4, #4]
    item->prev = item->next = 0;
300125ac:	2200      	movs	r2, #0
    item->next->prev = item->prev;
300125ae:	68a1      	ldr	r1, [r4, #8]
300125b0:	6008      	str	r0, [r1, #0]
    item->prev->next = item->next;
300125b2:	6860      	ldr	r0, [r4, #4]
300125b4:	6041      	str	r1, [r0, #4]
    item->prev = item->next = 0;
300125b6:	e9c4 2201 	strd	r2, r2, [r4, #4]
        current_thread->magic = 0;
300125ba:	6022      	str	r2, [r4, #0]
        if (current_thread->flags & THREAD_FLAG_FREE_STACK && current_thread->stack) {
300125bc:	079a      	lsls	r2, r3, #30
300125be:	d508      	bpl.n	300125d2 <thread_exit+0x56>
300125c0:	f8d4 0140 	ldr.w	r0, [r4, #320]	; 0x140
300125c4:	b128      	cbz	r0, 300125d2 <thread_exit+0x56>
            heap_delayed_free(current_thread->stack);
300125c6:	f002 f8e3 	bl	30014790 <heap_delayed_free>
            current_thread->flags &= ~THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK;
300125ca:	6a23      	ldr	r3, [r4, #32]
300125cc:	f023 0320 	bic.w	r3, r3, #32
300125d0:	6223      	str	r3, [r4, #32]
        if (current_thread->flags & THREAD_FLAG_FREE_STRUCT)
300125d2:	075b      	lsls	r3, r3, #29
300125d4:	d408      	bmi.n	300125e8 <thread_exit+0x6c>
    thread_resched();
300125d6:	f7ff fa9d 	bl	30011b14 <thread_resched>
    panic("somehow fell through thread_exit()\n");
300125da:	f640 1128 	movw	r1, #2344	; 0x928
300125de:	4628      	mov	r0, r5
300125e0:	f2c3 0102 	movt	r1, #12290	; 0x3002
300125e4:	f001 fe16 	bl	30014214 <_panic>
            heap_delayed_free(current_thread);
300125e8:	4620      	mov	r0, r4
300125ea:	f002 f8d1 	bl	30014790 <heap_delayed_free>
300125ee:	e7f2      	b.n	300125d6 <thread_exit+0x5a>
        wait_queue_wake_all(&current_thread->retcode_wait_queue, false, 0);
300125f0:	4611      	mov	r1, r2
300125f2:	f504 70aa 	add.w	r0, r4, #340	; 0x154
300125f6:	f7ff fee3 	bl	300123c0 <wait_queue_wake_all>
300125fa:	e7ec      	b.n	300125d6 <thread_exit+0x5a>

300125fc <wait_queue_destroy>:
 * @brief  Free all resources allocated in wait_queue_init()
 *
 * If any threads were waiting on this queue, they are all woken.
 */
void wait_queue_destroy(wait_queue_t *wait, bool reschedule)
{
300125fc:	b510      	push	{r4, r14}
300125fe:	4604      	mov	r4, r0
    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
30012600:	f06f 020a 	mvn.w	r2, #10
30012604:	f7ff fedc 	bl	300123c0 <wait_queue_wake_all>
    wait->magic = 0;
30012608:	2300      	movs	r3, #0
3001260a:	6023      	str	r3, [r4, #0]
}
3001260c:	bd10      	pop	{r4, r15}
3001260e:	bf00      	nop

30012610 <thread_unblock_from_wait_queue>:
{
    DEBUG_ASSERT(t->magic == THREAD_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (t->state != THREAD_BLOCKED)
30012610:	6983      	ldr	r3, [r0, #24]
30012612:	2b03      	cmp	r3, #3
30012614:	d135      	bne.n	30012682 <thread_unblock_from_wait_queue+0x72>
{
30012616:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    DEBUG_ASSERT(t->blocking_wait_queue != NULL);
    DEBUG_ASSERT(t->blocking_wait_queue->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(list_in_list(&t->queue_node));

    list_delete(&t->queue_node);
    t->blocking_wait_queue->count--;
3001261a:	6a47      	ldr	r7, [r0, #36]	; 0x24
    item->next = list->next;
3001261c:	f24d 0344 	movw	r3, #53316	; 0xd044
    list_add_head(&run_queue[t->priority], &t->queue_node);
30012620:	6942      	ldr	r2, [r0, #20]
    run_queue_bitmap |= (1<<t->priority);
30012622:	f24d 1644 	movw	r6, #53572	; 0xd144
    item->next->prev = item->prev;
30012626:	f8d0 8010 	ldr.w	r8, [r0, #16]
    item->next = list->next;
3001262a:	f2c3 0302 	movt	r3, #12290	; 0x3002
    t->blocking_wait_queue->count--;
3001262e:	68fc      	ldr	r4, [r7, #12]
    run_queue_bitmap |= (1<<t->priority);
30012630:	f2c3 0602 	movt	r6, #12290	; 0x3002
    t->blocking_wait_queue = NULL;
    t->state = THREAD_READY;
30012634:	f04f 0c01 	mov.w	r12, #1
30012638:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    t->blocking_wait_queue->count--;
3001263c:	1e65      	subs	r5, r4, #1
    item->next->prev = item->prev;
3001263e:	68c4      	ldr	r4, [r0, #12]
30012640:	f8c8 4000 	str.w	r4, [r8]
    item->prev = item->next = 0;
30012644:	2400      	movs	r4, #0
    run_queue_bitmap |= (1<<t->priority);
30012646:	fa0c fe02 	lsl.w	r14, r12, r2
    item->prev->next = item->next;
3001264a:	68c2      	ldr	r2, [r0, #12]
3001264c:	f8c2 8004 	str.w	r8, [r2, #4]
    item->prev = item->next = 0;
30012650:	6104      	str	r4, [r0, #16]
    item->next = list->next;
30012652:	f8d3 8004 	ldr.w	r8, [r3, #4]
    t->blocking_wait_queue->count--;
30012656:	60fd      	str	r5, [r7, #12]
    list_delete(&t->queue_node);
30012658:	f100 070c 	add.w	r7, r0, #12
    run_queue_bitmap |= (1<<t->priority);
3001265c:	6835      	ldr	r5, [r6, #0]
3001265e:	f8c0 8010 	str.w	r8, [r0, #16]
30012662:	ea4e 0205 	orr.w	r2, r14, r5
    list->next->prev = item;
30012666:	685d      	ldr	r5, [r3, #4]
30012668:	6032      	str	r2, [r6, #0]
    item->prev = list;
3001266a:	60c3      	str	r3, [r0, #12]
    t->wait_queue_block_ret = wait_queue_error;
3001266c:	e9c0 4109 	strd	r4, r1, [r0, #36]	; 0x24
    t->state = THREAD_READY;
30012670:	f8c0 c018 	str.w	r12, [r0, #24]
    list->next->prev = item;
30012674:	602f      	str	r7, [r5, #0]
    list->next = item;
30012676:	605f      	str	r7, [r3, #4]
30012678:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    insert_in_run_queue_head(t);
    thread_mp_reschedule(get_current_thread(), t);

    return NO_ERROR;
3001267c:	4620      	mov	r0, r4
}
3001267e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return ERR_NOT_BLOCKED;
30012682:	f06f 000b 	mvn.w	r0, #11
}
30012686:	4770      	bx	r14

30012688 <wait_queue_timeout_handler>:
{
30012688:	b510      	push	{r4, r14}
3001268a:	f24d 1450 	movw	r4, #53584	; 0xd150
3001268e:	2301      	movs	r3, #1
    if (thread_unblock_from_wait_queue(thread, ERR_TIMED_OUT) >= NO_ERROR) {
30012690:	4610      	mov	r0, r2
30012692:	f2c3 0402 	movt	r4, #12290	; 0x3002
30012696:	f06f 010c 	mvn.w	r1, #12
3001269a:	6023      	str	r3, [r4, #0]
3001269c:	f7ff ffb8 	bl	30012610 <thread_unblock_from_wait_queue>
    *lock = 0;
300126a0:	2300      	movs	r3, #0
300126a2:	6023      	str	r3, [r4, #0]
}
300126a4:	4298      	cmp	r0, r3
300126a6:	bfb4      	ite	lt
300126a8:	2000      	movlt	r0, #0
300126aa:	2001      	movge	r0, #1
300126ac:	bd10      	pop	{r4, r15}
300126ae:	bf00      	nop

300126b0 <insert_timer_in_queue.constprop.2>:
void timer_initialize(timer_t *timer)
{
    *timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
}

static void insert_timer_in_queue(uint cpu, timer_t *timer)
300126b0:	b430      	push	{r4, r5}

    DEBUG_ASSERT(arch_ints_disabled());

    LTRACEF("timer %p, cpu %u, scheduled %u, periodic %u\n", timer, cpu, timer->scheduled_time, timer->periodic_time);

    list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
300126b2:	f24d 14a0 	movw	r4, #53664	; 0xd1a0
300126b6:	f2c3 0402 	movt	r4, #12290	; 0x3002
300126ba:	6863      	ldr	r3, [r4, #4]
300126bc:	4619      	mov	r1, r3
300126be:	42a3      	cmp	r3, r4
300126c0:	d010      	beq.n	300126e4 <insert_timer_in_queue.constprop.2+0x34>
        if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
300126c2:	68c5      	ldr	r5, [r0, #12]
300126c4:	3b04      	subs	r3, #4
300126c6:	68da      	ldr	r2, [r3, #12]
300126c8:	1b52      	subs	r2, r2, r5
300126ca:	2a00      	cmp	r2, #0
300126cc:	dd04      	ble.n	300126d8 <insert_timer_in_queue.constprop.2+0x28>
300126ce:	e011      	b.n	300126f4 <insert_timer_in_queue.constprop.2+0x44>
300126d0:	68da      	ldr	r2, [r3, #12]
300126d2:	1b52      	subs	r2, r2, r5
300126d4:	2a00      	cmp	r2, #0
300126d6:	dc0d      	bgt.n	300126f4 <insert_timer_in_queue.constprop.2+0x44>
    list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
300126d8:	689b      	ldr	r3, [r3, #8]
300126da:	4619      	mov	r1, r3
300126dc:	42a1      	cmp	r1, r4
300126de:	f1a3 0304 	sub.w	r3, r3, #4
300126e2:	d1f5      	bne.n	300126d0 <insert_timer_in_queue.constprop.2+0x20>
    item->prev = list->prev;
300126e4:	6823      	ldr	r3, [r4, #0]
            return;
        }
    }

    /* walked off the end of the list */
    list_add_tail(&timers[cpu].timer_queue, &timer->node);
300126e6:	1d02      	adds	r2, r0, #4
300126e8:	e9c0 3401 	strd	r3, r4, [r0, #4]
    list->prev = item;
300126ec:	6022      	str	r2, [r4, #0]
    list->prev->next = item;
300126ee:	605a      	str	r2, [r3, #4]
}
300126f0:	bc30      	pop	{r4, r5}
300126f2:	4770      	bx	r14
    item->prev = list->prev;
300126f4:	685c      	ldr	r4, [r3, #4]
            list_add_before(&entry->node, &timer->node);
300126f6:	1d02      	adds	r2, r0, #4
300126f8:	6044      	str	r4, [r0, #4]
    list->prev->next = item;
300126fa:	685c      	ldr	r4, [r3, #4]
    item->next = list;
300126fc:	6081      	str	r1, [r0, #8]
    list->prev->next = item;
300126fe:	6062      	str	r2, [r4, #4]
    list->prev = item;
30012700:	605a      	str	r2, [r3, #4]
}
30012702:	bc30      	pop	{r4, r5}
30012704:	4770      	bx	r14
30012706:	bf00      	nop

30012708 <timer_tick>:
    spin_unlock_irqrestore(&timer_lock, state);
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, lk_time_t now)
{
30012708:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    timer_t *timer;
    enum handler_return ret = INT_NO_RESCHEDULE;

    DEBUG_ASSERT(arch_ints_disabled());

    THREAD_STATS_INC(timer_ints);
3001270c:	f24d 1558 	movw	r5, #53592	; 0xd158
    *lock = 1;
30012710:	2201      	movs	r2, #1
30012712:	f24d 1488 	movw	r4, #53640	; 0xd188
30012716:	f2c3 0502 	movt	r5, #12290	; 0x3002
    enum handler_return ret = INT_NO_RESCHEDULE;
3001271a:	2700      	movs	r7, #0
3001271c:	f24d 16a0 	movw	r6, #53664	; 0xd1a0
30012720:	f2c3 0402 	movt	r4, #12290	; 0x3002
    THREAD_STATS_INC(timer_ints);
30012724:	6a6b      	ldr	r3, [r5, #36]	; 0x24
{
30012726:	b083      	sub	sp, #12
30012728:	4688      	mov	r8, r1
3001272a:	f2c3 0602 	movt	r6, #12290	; 0x3002
3001272e:	4693      	mov	r11, r2
    THREAD_STATS_INC(timer_ints);
30012730:	4413      	add	r3, r2
30012732:	6022      	str	r2, [r4, #0]
    item->prev = item->next = 0;
30012734:	46ba      	mov	r10, r7
30012736:	626b      	str	r3, [r5, #36]	; 0x24
    if (list->next != list) {
30012738:	6873      	ldr	r3, [r6, #4]
3001273a:	42b3      	cmp	r3, r6

    spin_lock(&timer_lock);

    for (;;) {
        /* see if there's an event to process */
        timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
3001273c:	f1a3 0904 	sub.w	r9, r3, #4
30012740:	d002      	beq.n	30012748 <timer_tick+0x40>
30012742:	b10b      	cbz	r3, 30012748 <timer_tick+0x40>
        if (likely(timer == 0))
30012744:	2b04      	cmp	r3, #4
30012746:	d105      	bne.n	30012754 <timer_tick+0x4c>
    *lock = 0;
30012748:	2300      	movs	r3, #0
    if (thread_timer_tick() == INT_RESCHEDULE)
        ret = INT_RESCHEDULE;
#endif

    return ret;
}
3001274a:	4638      	mov	r0, r7
3001274c:	6023      	str	r3, [r4, #0]
3001274e:	b003      	add	sp, #12
30012750:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (likely(TIME_LT(now, timer->scheduled_time)))
30012754:	f8d9 200c 	ldr.w	r2, [r9, #12]
30012758:	eba8 0302 	sub.w	r3, r8, r2
3001275c:	2b00      	cmp	r3, #0
3001275e:	da09      	bge.n	30012774 <timer_tick+0x6c>
        platform_set_oneshot_timer(timer_tick, NULL, delay);
30012760:	f242 7009 	movw	r0, #9993	; 0x2709
30012764:	eba2 0208 	sub.w	r2, r2, r8
30012768:	2100      	movs	r1, #0
3001276a:	f2c3 0001 	movt	r0, #12289	; 0x3001
3001276e:	f7ee f88d 	bl	3000088c <platform_set_oneshot_timer>
30012772:	e7e9      	b.n	30012748 <timer_tick+0x40>
        THREAD_STATS_INC(timers);
30012774:	6aab      	ldr	r3, [r5, #40]	; 0x28
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
30012776:	4641      	mov	r1, r8
    item->next->prev = item->prev;
30012778:	f8d9 2008 	ldr.w	r2, [r9, #8]
3001277c:	4648      	mov	r0, r9
        THREAD_STATS_INC(timers);
3001277e:	f103 0c01 	add.w	r12, r3, #1
30012782:	f8d9 3004 	ldr.w	r3, [r9, #4]
30012786:	6013      	str	r3, [r2, #0]
    item->prev->next = item->next;
30012788:	f8d9 3004 	ldr.w	r3, [r9, #4]
3001278c:	605a      	str	r2, [r3, #4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
3001278e:	f8d9 3014 	ldr.w	r3, [r9, #20]
30012792:	9300      	str	r3, [sp, #0]
        bool periodic = timer->periodic_time > 0;
30012794:	f8d9 3010 	ldr.w	r3, [r9, #16]
    item->prev = item->next = 0;
30012798:	e9c9 aa01 	strd	r10, r10, [r9, #4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
3001279c:	f8d9 2018 	ldr.w	r2, [r9, #24]
        bool periodic = timer->periodic_time > 0;
300127a0:	9301      	str	r3, [sp, #4]
300127a2:	f8c4 a000 	str.w	r10, [r4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
300127a6:	9b00      	ldr	r3, [sp, #0]
        THREAD_STATS_INC(timers);
300127a8:	f8c5 c028 	str.w	r12, [r5, #40]	; 0x28
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
300127ac:	4798      	blx	r3
        if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
300127ae:	9b01      	ldr	r3, [sp, #4]
    *lock = 1;
300127b0:	f8c4 b000 	str.w	r11, [r4]
            ret = INT_RESCHEDULE;
300127b4:	2801      	cmp	r0, #1
300127b6:	bf08      	it	eq
300127b8:	2701      	moveq	r7, #1
        if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
300127ba:	2b00      	cmp	r3, #0
300127bc:	d0bc      	beq.n	30012738 <timer_tick+0x30>
    if (item->prev == 0 && item->next == 0)
300127be:	f8d9 3004 	ldr.w	r3, [r9, #4]
300127c2:	2b00      	cmp	r3, #0
300127c4:	d1b8      	bne.n	30012738 <timer_tick+0x30>
300127c6:	f8d9 3008 	ldr.w	r3, [r9, #8]
300127ca:	2b00      	cmp	r3, #0
300127cc:	d1b4      	bne.n	30012738 <timer_tick+0x30>
300127ce:	f8d9 3010 	ldr.w	r3, [r9, #16]
300127d2:	2b00      	cmp	r3, #0
300127d4:	d0b0      	beq.n	30012738 <timer_tick+0x30>
            insert_timer_in_queue(cpu, timer);
300127d6:	4648      	mov	r0, r9
            timer->scheduled_time = now + timer->periodic_time;
300127d8:	4443      	add	r3, r8
300127da:	f8c9 300c 	str.w	r3, [r9, #12]
            insert_timer_in_queue(cpu, timer);
300127de:	f7ff ff67 	bl	300126b0 <insert_timer_in_queue.constprop.2>
300127e2:	e7a9      	b.n	30012738 <timer_tick+0x30>

300127e4 <timer_set>:
{
300127e4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
300127e8:	460e      	mov	r6, r1
300127ea:	4604      	mov	r4, r0
300127ec:	6841      	ldr	r1, [r0, #4]
300127ee:	2900      	cmp	r1, #0
300127f0:	d15c      	bne.n	300128ac <timer_set+0xc8>
300127f2:	6887      	ldr	r7, [r0, #8]
300127f4:	2f00      	cmp	r7, #0
300127f6:	d159      	bne.n	300128ac <timer_set+0xc8>
300127f8:	461d      	mov	r5, r3
300127fa:	4690      	mov	r8, r2
    now = current_time();
300127fc:	f7ee f896 	bl	3000092c <current_time>
    timer->arg = arg;
30012800:	9b06      	ldr	r3, [sp, #24]
    timer->callback = callback;
30012802:	e9c4 8504 	strd	r8, r5, [r4, #16]
    timer->arg = arg;
30012806:	61a3      	str	r3, [r4, #24]
    timer->scheduled_time = now + delay;
30012808:	4430      	add	r0, r6
3001280a:	60e0      	str	r0, [r4, #12]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3001280c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30012810:	f013 0880 	ands.w	r8, r3, #128	; 0x80
30012814:	d11e      	bne.n	30012854 <timer_set+0x70>
    __asm__ volatile("cpsid i");
30012816:	b672      	cpsid	i
    *lock = 1;
30012818:	f24d 1588 	movw	r5, #53640	; 0xd188
3001281c:	2701      	movs	r7, #1
    insert_timer_in_queue(cpu, timer);
3001281e:	4620      	mov	r0, r4
30012820:	f2c3 0502 	movt	r5, #12290	; 0x3002
30012824:	602f      	str	r7, [r5, #0]
30012826:	f7ff ff43 	bl	300126b0 <insert_timer_in_queue.constprop.2>
    if (list->next != list) {
3001282a:	f24d 13a0 	movw	r3, #53664	; 0xd1a0
3001282e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30012832:	685a      	ldr	r2, [r3, #4]
30012834:	1ad3      	subs	r3, r2, r3
30012836:	bf18      	it	ne
30012838:	2301      	movne	r3, #1
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
3001283a:	2a00      	cmp	r2, #0
3001283c:	bf08      	it	eq
3001283e:	2300      	moveq	r3, #0
30012840:	b36b      	cbz	r3, 3001289e <timer_set+0xba>
30012842:	3a04      	subs	r2, #4
30012844:	4294      	cmp	r4, r2
    *lock = 0;
30012846:	bf18      	it	ne
30012848:	f8c5 8000 	strne.w	r8, [r5]
3001284c:	d01a      	beq.n	30012884 <timer_set+0xa0>
    __asm__ volatile("cpsie i");
3001284e:	b662      	cpsie	i
}
30012850:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    *lock = 1;
30012854:	f24d 1588 	movw	r5, #53640	; 0xd188
30012858:	2301      	movs	r3, #1
    insert_timer_in_queue(cpu, timer);
3001285a:	4620      	mov	r0, r4
3001285c:	f2c3 0502 	movt	r5, #12290	; 0x3002
30012860:	602b      	str	r3, [r5, #0]
30012862:	f7ff ff25 	bl	300126b0 <insert_timer_in_queue.constprop.2>
30012866:	f24d 13a0 	movw	r3, #53664	; 0xd1a0
3001286a:	f2c3 0302 	movt	r3, #12290	; 0x3002
3001286e:	685a      	ldr	r2, [r3, #4]
30012870:	1ad3      	subs	r3, r2, r3
30012872:	bf18      	it	ne
30012874:	2301      	movne	r3, #1
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
30012876:	2a00      	cmp	r2, #0
30012878:	bf08      	it	eq
3001287a:	2300      	moveq	r3, #0
3001287c:	b98b      	cbnz	r3, 300128a2 <timer_set+0xbe>
    *lock = 0;
3001287e:	602b      	str	r3, [r5, #0]
}
30012880:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        platform_set_oneshot_timer(timer_tick, NULL, delay);
30012884:	f242 7009 	movw	r0, #9993	; 0x2709
30012888:	4632      	mov	r2, r6
3001288a:	2100      	movs	r1, #0
3001288c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30012890:	f7ed fffc 	bl	3000088c <platform_set_oneshot_timer>
30012894:	2300      	movs	r3, #0
30012896:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30012898:	2f00      	cmp	r7, #0
3001289a:	d1d8      	bne.n	3001284e <timer_set+0x6a>
3001289c:	e7f0      	b.n	30012880 <timer_set+0x9c>
    *lock = 0;
3001289e:	602b      	str	r3, [r5, #0]
300128a0:	e7d5      	b.n	3001284e <timer_set+0x6a>
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
300128a2:	3a04      	subs	r2, #4
300128a4:	4294      	cmp	r4, r2
300128a6:	d0ed      	beq.n	30012884 <timer_set+0xa0>
300128a8:	602f      	str	r7, [r5, #0]
300128aa:	e7e9      	b.n	30012880 <timer_set+0x9c>
        panic("timer %p already in list\n", timer);
300128ac:	f640 1188 	movw	r1, #2440	; 0x988
300128b0:	4622      	mov	r2, r4
300128b2:	4670      	mov	r0, r14
300128b4:	f2c3 0102 	movt	r1, #12290	; 0x3002
300128b8:	f001 fcac 	bl	30014214 <_panic>

300128bc <timer_initialize>:
    *timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
300128bc:	f646 5272 	movw	r2, #28018	; 0x6d72
300128c0:	2300      	movs	r3, #0
300128c2:	f2c7 4269 	movt	r2, #29801	; 0x7469
300128c6:	e9c0 3302 	strd	r3, r3, [r0, #8]
300128ca:	e9c0 2300 	strd	r2, r3, [r0]
300128ce:	e9c0 3304 	strd	r3, r3, [r0, #16]
300128d2:	6183      	str	r3, [r0, #24]
}
300128d4:	4770      	bx	r14
300128d6:	bf00      	nop

300128d8 <timer_set_oneshot>:
{
300128d8:	b500      	push	{r14}
300128da:	b083      	sub	sp, #12
    timer_set(timer, delay, 0, callback, arg);
300128dc:	2900      	cmp	r1, #0
300128de:	bf08      	it	eq
300128e0:	2101      	moveq	r1, #1
300128e2:	9300      	str	r3, [sp, #0]
300128e4:	4613      	mov	r3, r2
300128e6:	2200      	movs	r2, #0
300128e8:	f7ff ff7c 	bl	300127e4 <timer_set>
}
300128ec:	b003      	add	sp, #12
300128ee:	f85d fb04 	ldr.w	r15, [r13], #4
300128f2:	bf00      	nop

300128f4 <timer_set_periodic>:
{
300128f4:	b510      	push	{r4, r14}
300128f6:	b082      	sub	sp, #8
        period = 1;
300128f8:	2900      	cmp	r1, #0
300128fa:	bf14      	ite	ne
300128fc:	460c      	movne	r4, r1
300128fe:	2401      	moveq	r4, #1
    timer_set(timer, period, period, callback, arg);
30012900:	9300      	str	r3, [sp, #0]
30012902:	4621      	mov	r1, r4
30012904:	4613      	mov	r3, r2
30012906:	4622      	mov	r2, r4
30012908:	f7ff ff6c 	bl	300127e4 <timer_set>
}
3001290c:	b002      	add	sp, #8
3001290e:	bd10      	pop	{r4, r15}

30012910 <timer_cancel>:
{
30012910:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30012912:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30012916:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
30012918:	bf48      	it	mi
3001291a:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3001291c:	d401      	bmi.n	30012922 <timer_cancel+0x12>
    __asm__ volatile("cpsid i");
3001291e:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30012920:	2701      	movs	r7, #1
30012922:	f24d 12a0 	movw	r2, #53664	; 0xd1a0
    *lock = 1;
30012926:	f24d 1588 	movw	r5, #53640	; 0xd188
3001292a:	2101      	movs	r1, #1
3001292c:	f2c3 0202 	movt	r2, #12290	; 0x3002
30012930:	e9d0 6401 	ldrd	r6, r4, [r0, #4]
30012934:	f2c3 0502 	movt	r5, #12290	; 0x3002
30012938:	6853      	ldr	r3, [r2, #4]
3001293a:	6029      	str	r1, [r5, #0]
    timer_t *oldhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
3001293c:	4293      	cmp	r3, r2
3001293e:	bf18      	it	ne
30012940:	2b00      	cmpne	r3, #0
30012942:	bf0b      	itete	eq
30012944:	2100      	moveq	r1, #0
30012946:	2101      	movne	r1, #1
30012948:	468c      	moveq	r12, r1
3001294a:	f1a3 0c04 	subne.w	r12, r3, #4
    if (item->prev == 0 && item->next == 0)
3001294e:	b37e      	cbz	r6, 300129b0 <timer_cancel+0xa0>
    item->next->prev = item->prev;
30012950:	6026      	str	r6, [r4, #0]
    item->prev = item->next = 0;
30012952:	2100      	movs	r1, #0
    item->prev->next = item->next;
30012954:	6843      	ldr	r3, [r0, #4]
30012956:	605c      	str	r4, [r3, #4]
    item->prev = item->next = 0;
30012958:	6041      	str	r1, [r0, #4]
3001295a:	6853      	ldr	r3, [r2, #4]
3001295c:	6081      	str	r1, [r0, #8]
3001295e:	4293      	cmp	r3, r2
30012960:	bf18      	it	ne
30012962:	428b      	cmpne	r3, r1
30012964:	bf14      	ite	ne
30012966:	2101      	movne	r1, #1
30012968:	2100      	moveq	r1, #0
    timer->periodic_time = 0;
3001296a:	2600      	movs	r6, #0
    timer->callback = NULL;
3001296c:	e9c0 6604 	strd	r6, r6, [r0, #16]
    timer->arg = NULL;
30012970:	6186      	str	r6, [r0, #24]
    timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
30012972:	b1a9      	cbz	r1, 300129a0 <timer_cancel+0x90>
    if (newhead == NULL) {
30012974:	2b04      	cmp	r3, #4
30012976:	d013      	beq.n	300129a0 <timer_cancel+0x90>
    timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
30012978:	1f1c      	subs	r4, r3, #4
    } else if (newhead != oldhead) {
3001297a:	45a4      	cmp	r12, r4
3001297c:	d012      	beq.n	300129a4 <timer_cancel+0x94>
        lk_time_t now = current_time();
3001297e:	f7ed ffd5 	bl	3000092c <current_time>
        if (TIME_LT(newhead->scheduled_time, now))
30012982:	68e2      	ldr	r2, [r4, #12]
        platform_set_oneshot_timer(timer_tick, NULL, delay);
30012984:	4631      	mov	r1, r6
        if (TIME_LT(newhead->scheduled_time, now))
30012986:	1a12      	subs	r2, r2, r0
        platform_set_oneshot_timer(timer_tick, NULL, delay);
30012988:	f242 7009 	movw	r0, #9993	; 0x2709
3001298c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
30012990:	f2c3 0001 	movt	r0, #12289	; 0x3001
30012994:	f7ed ff7a 	bl	3000088c <platform_set_oneshot_timer>
    *lock = 0;
30012998:	2300      	movs	r3, #0
3001299a:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
3001299c:	b937      	cbnz	r7, 300129ac <timer_cancel+0x9c>
}
3001299e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        platform_stop_timer();
300129a0:	f7ed ffa6 	bl	300008f0 <platform_stop_timer>
    *lock = 0;
300129a4:	2300      	movs	r3, #0
300129a6:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300129a8:	2f00      	cmp	r7, #0
300129aa:	d0f8      	beq.n	3001299e <timer_cancel+0x8e>
    __asm__ volatile("cpsie i");
300129ac:	b662      	cpsie	i
}
300129ae:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (item->prev == 0 && item->next == 0)
300129b0:	2c00      	cmp	r4, #0
300129b2:	d1cd      	bne.n	30012950 <timer_cancel+0x40>
300129b4:	e7d9      	b.n	3001296a <timer_cancel+0x5a>
300129b6:	bf00      	nop

300129b8 <timer_init>:

void timer_init(void)
{
    timer_lock = SPIN_LOCK_INITIAL_VALUE;
300129b8:	f24d 1288 	movw	r2, #53640	; 0xd188
    list->prev = list->next = list;
300129bc:	f24d 13a0 	movw	r3, #53664	; 0xd1a0
300129c0:	2100      	movs	r1, #0
300129c2:	f2c3 0202 	movt	r2, #12290	; 0x3002
300129c6:	f2c3 0302 	movt	r3, #12290	; 0x3002
300129ca:	6011      	str	r1, [r2, #0]
300129cc:	e9c3 3300 	strd	r3, r3, [r3]
    }
#if !PLATFORM_HAS_DYNAMIC_TIMER
    /* register for a periodic timer tick */
    platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
#endif
}
300129d0:	4770      	bx	r14
300129d2:	bf00      	nop

300129d4 <port_init>:
300129d4:	f24d 13c0 	movw	r3, #53696	; 0xd1c0
300129d8:	f2c3 0302 	movt	r3, #12290	; 0x3002
300129dc:	e9c3 3300 	strd	r3, r3, [r3]

// must be called before any use of ports.
void port_init(void)
{
    list_initialize(&write_port_list);
}
300129e0:	4770      	bx	r14
300129e2:	bf00      	nop

300129e4 <platform_mpu_r5_common>:
{
#if ARM_WITH_MPU
    extern addr_t _nocacheable_start;
    extern addr_t _nocacheable_end;

    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
300129e4:	f645 4200 	movw	r2, #23552	; 0x5c00
300129e8:	f645 0100 	movw	r1, #22528	; 0x5800
300129ec:	f2c3 0202 	movt	r2, #12290	; 0x3002
300129f0:	f2c3 0102 	movt	r1, #12290	; 0x3002
300129f4:	1a52      	subs	r2, r2, r1
300129f6:	2a00      	cmp	r2, #0
{
300129f8:	b538      	push	{r3, r4, r5, r14}
300129fa:	4604      	mov	r4, r0
300129fc:	f100 0501 	add.w	r5, r0, #1
    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
30012a00:	dd06      	ble.n	30012a10 <platform_mpu_r5_common+0x2c>
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
30012a02:	2303      	movs	r3, #3
30012a04:	1092      	asrs	r2, r2, #2
30012a06:	f7ee ff55 	bl	300018b4 <mpu_add_region>
30012a0a:	1ca3      	adds	r3, r4, #2
30012a0c:	462c      	mov	r4, r5
30012a0e:	461d      	mov	r5, r3
                       &_nocacheable_end - &_nocacheable_start, MPU_REGION_NORMAL_NONCACHEABLE);
    }

    mpu_add_region(region++, APB_CKGEN_SEC_BASE, 0x04000000, MPU_REGION_DEVICE);
30012a10:	4620      	mov	r0, r4
30012a12:	2301      	movs	r3, #1
30012a14:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
30012a18:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
30012a1c:	f7ee ff4a 	bl	300018b4 <mpu_add_region>

#endif
    return region;
}
30012a20:	4628      	mov	r0, r5
30012a22:	bd38      	pop	{r3, r4, r5, r15}

30012a24 <sem_enable_intr>:
    sem_write_reg(sem, reg, _val);
}

void sem_enable_intr(enum sem sem, enum sem_intr intr,
                     bool enable)
{
30012a24:	b410      	push	{r4}
    sem_write_reg(sem, INT_ENALE_OVRD,
                  1 << (intr + INT_ENABLE_OVRD_EN) |
30012a26:	2401      	movs	r4, #1
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
30012a28:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
30012a2c:	3032      	adds	r0, #50	; 0x32
                  (uint32_t)enable << (intr + INT_ENABLE_OVRD_VAL));
30012a2e:	f101 0308 	add.w	r3, r1, #8
                  1 << (intr + INT_ENABLE_OVRD_EN) |
30012a32:	408c      	lsls	r4, r1
                  (uint32_t)enable << (intr + INT_ENABLE_OVRD_VAL));
30012a34:	409a      	lsls	r2, r3
    sem_write_reg(sem, INT_ENALE_OVRD,
30012a36:	4322      	orrs	r2, r4
}
30012a38:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
30012a3c:	0400      	lsls	r0, r0, #16
30012a3e:	6082      	str	r2, [r0, #8]
}
30012a40:	4770      	bx	r14
30012a42:	bf00      	nop

30012a44 <sem_signal_status>:
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a44:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
30012a48:	3032      	adds	r0, #50	; 0x32
 * Check input signal status.
 */
bool sem_signal_status(enum sem sem, enum sem_signal signal)
{
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
    return !!(val & (1 << (signal % 32)));
30012a4a:	2301      	movs	r3, #1
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
30012a4c:	094a      	lsrs	r2, r1, #5
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a4e:	0400      	lsls	r0, r0, #16
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
30012a50:	3220      	adds	r2, #32
    return !!(val & (1 << (signal % 32)));
30012a52:	f001 011f 	and.w	r1, r1, #31
30012a56:	fa03 f101 	lsl.w	r1, r3, r1
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a5a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    return !!(val & (1 << (signal % 32)));
30012a5e:	4211      	tst	r1, r2
}
30012a60:	bf14      	ite	ne
30012a62:	4618      	movne	r0, r3
30012a64:	2000      	moveq	r0, #0
30012a66:	4770      	bx	r14

30012a68 <sem_map_signal>:
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a68:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
 * This function is used to enable or disable the mapping from
 * input signals to SEM output interrupts.
 */
void sem_map_signal(enum sem sem, enum sem_signal signal,
                    enum sem_intr intr, bool enable)
{
30012a6c:	b430      	push	{r4, r5}
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a6e:	3032      	adds	r0, #50	; 0x32
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
                   1 << (signal % 32), enable << (signal % 32));
30012a70:	2501      	movs	r5, #1
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
30012a72:	1c94      	adds	r4, r2, #2
30012a74:	094a      	lsrs	r2, r1, #5
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a76:	0400      	lsls	r0, r0, #16
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
30012a78:	eb02 1244 	add.w	r2, r2, r4, lsl #5
                   1 << (signal % 32), enable << (signal % 32));
30012a7c:	f001 011f 	and.w	r1, r1, #31
30012a80:	408b      	lsls	r3, r1
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
30012a82:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
                   1 << (signal % 32), enable << (signal % 32));
30012a86:	fa05 f101 	lsl.w	r1, r5, r1
    _val &= ~mask;
30012a8a:	ea24 0101 	bic.w	r1, r4, r1
    _val |= val;
30012a8e:	430b      	orrs	r3, r1
}
30012a90:	bc30      	pop	{r4, r5}
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
30012a92:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
30012a96:	4770      	bx	r14

30012a98 <waite_idle>:
    *status = reg[0];
    return 0;
}

static int waite_idle(struct spi_nor *nor)
{
30012a98:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30012a9c:	4606      	mov	r6, r0
30012a9e:	b088      	sub	sp, #32
    int ret = 0;
    u8 flash_status;
    lk_time_t timeout = current_time() + 1000;
30012aa0:	f7ed ff44 	bl	3000092c <current_time>
    u8 reg[2] = {0};
30012aa4:	2400      	movs	r4, #0
    struct spi_nor_cmd read_cmd = {
30012aa6:	2705      	movs	r7, #5
    lk_time_t timeout = current_time() + 1000;
30012aa8:	f500 787a 	add.w	r8, r0, #1000	; 0x3e8
30012aac:	e00b      	b.n	30012ac6 <waite_idle+0x2e>
    *status = reg[0];
30012aae:	f89d 3000 	ldrb.w	r3, [r13]
            dprintf(CRITICAL, "spi_nor get flash status failed, ret: %d!\n",
                    ret);
            break;
        }
        dprintf(INFO, "flash_status = 0x%x \n", flash_status);
        if (!(flash_status & BIT(0)))
30012ab2:	07db      	lsls	r3, r3, #31
30012ab4:	d523      	bpl.n	30012afe <waite_idle+0x66>
            break;
        if (current_time() > timeout) {
30012ab6:	f7ed ff39 	bl	3000092c <current_time>
30012aba:	4540      	cmp	r0, r8
            ret = -ETIMEDOUT;
            dprintf(CRITICAL, "wait flash idle timeout, ret = %d!\n", ret);
            break;
        }
        udelay(1);
30012abc:	f04f 0001 	mov.w	r0, #1
        if (current_time() > timeout) {
30012ac0:	d821      	bhi.n	30012b06 <waite_idle+0x6e>
        udelay(1);
30012ac2:	f001 fb95 	bl	300141f0 <spin>
    struct spi_nor_cmd read_cmd = {
30012ac6:	9403      	str	r4, [sp, #12]
    ret = nor->host_ops.reg_read(nor, &read_cmd, reg, 2);
30012ac8:	2302      	movs	r3, #2
30012aca:	f8d6 5088 	ldr.w	r5, [r6, #136]	; 0x88
30012ace:	466a      	mov	r2, r13
    u8 reg[2] = {0};
30012ad0:	f8ad 4000 	strh.w	r4, [r13]
    ret = nor->host_ops.reg_read(nor, &read_cmd, reg, 2);
30012ad4:	a901      	add	r1, sp, #4
    struct spi_nor_cmd read_cmd = {
30012ad6:	9401      	str	r4, [sp, #4]
    ret = nor->host_ops.reg_read(nor, &read_cmd, reg, 2);
30012ad8:	4630      	mov	r0, r6
    struct spi_nor_cmd read_cmd = {
30012ada:	9402      	str	r4, [sp, #8]
30012adc:	e9cd 4404 	strd	r4, r4, [r13, #16]
30012ae0:	e9cd 4406 	strd	r4, r4, [r13, #24]
30012ae4:	f88d 700c 	strb.w	r7, [r13, #12]
    ret = nor->host_ops.reg_read(nor, &read_cmd, reg, 2);
30012ae8:	47a8      	blx	r5
    if (ret)
30012aea:	4605      	mov	r5, r0
30012aec:	2800      	cmp	r0, #0
30012aee:	d0de      	beq.n	30012aae <waite_idle+0x16>
            dprintf(CRITICAL, "spi_nor get flash status failed, ret: %d!\n",
30012af0:	f640 3000 	movw	r0, #2816	; 0xb00
30012af4:	4629      	mov	r1, r5
30012af6:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012afa:	f003 f859 	bl	30015bb0 <_printf>
    }

    return ret;
}
30012afe:	4628      	mov	r0, r5
30012b00:	b008      	add	sp, #32
30012b02:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            dprintf(CRITICAL, "wait flash idle timeout, ret = %d!\n", ret);
30012b06:	f640 302c 	movw	r0, #2860	; 0xb2c
30012b0a:	f06f 0173 	mvn.w	r1, #115	; 0x73
30012b0e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012b12:	f003 f84d 	bl	30015bb0 <_printf>
30012b16:	f06f 0573 	mvn.w	r5, #115	; 0x73
}
30012b1a:	4628      	mov	r0, r5
30012b1c:	b008      	add	sp, #32
30012b1e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
30012b22:	bf00      	nop

30012b24 <spi_nor_read>:
    return info;
}

int spi_nor_read(struct spi_nor *nor, uint64_t src, uint8_t *dst,
                 uint64_t length)
{
30012b24:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret;
    struct spi_nor_cmd read_cmd = {
        .use_dma = 1,
        .type = SPI_NOR_OPS_READ,
        .opcode = GET_PROTO_OPCODE(nor->info->read_proto),
30012b26:	f8d0 6080 	ldr.w	r6, [r0, #128]	; 0x80
{
30012b2a:	b089      	sub	sp, #36	; 0x24
    struct spi_nor_cmd read_cmd = {
30012b2c:	2100      	movs	r1, #0
30012b2e:	2501      	movs	r5, #1
{
30012b30:	4604      	mov	r4, r0
        .opcode = GET_PROTO_OPCODE(nor->info->read_proto),
30012b32:	68f3      	ldr	r3, [r6, #12]
    struct spi_nor_cmd read_cmd = {
30012b34:	9103      	str	r1, [sp, #12]
        .dummy = nor->info->read_dummy,
        .inst_width = SNOR_GET_INST_LANS(nor->info->read_proto),
30012b36:	f3c3 2e03 	ubfx	r14, r3, #8, #4
        .opcode = GET_PROTO_OPCODE(nor->info->read_proto),
30012b3a:	0e1f      	lsrs	r7, r3, #24
    struct spi_nor_cmd read_cmd = {
30012b3c:	e9cd 1104 	strd	r1, r1, [r13, #16]
        .addr_width = SNOR_GET_ADDR_LANS(nor->info->read_proto),
30012b40:	f3c3 1c03 	ubfx	r12, r3, #4, #4
    struct spi_nor_cmd read_cmd = {
30012b44:	f88d 700c 	strb.w	r7, [r13, #12]
        .data_width = SNOR_GET_DATA_LANS(nor->info->read_proto),
30012b48:	f003 070f 	and.w	r7, r3, #15
    struct spi_nor_cmd read_cmd = {
30012b4c:	9101      	str	r1, [sp, #4]
        .addr_bytes = SNOR_GET_ADDR_BYTES(nor->info->read_proto),
30012b4e:	f3c3 3303 	ubfx	r3, r3, #12, #4
    struct spi_nor_cmd read_cmd = {
30012b52:	9106      	str	r1, [sp, #24]
30012b54:	9107      	str	r1, [sp, #28]
30012b56:	7e31      	ldrb	r1, [r6, #24]
30012b58:	9205      	str	r2, [sp, #20]
30012b5a:	f88d 100d 	strb.w	r1, [r13, #13]
        .addr = src,
    };

    nor->host_ops.lock(nor);
30012b5e:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
    struct spi_nor_cmd read_cmd = {
30012b62:	f88d e00e 	strb.w	r14, [r13, #14]
30012b66:	f88d c00f 	strb.w	r12, [r13, #15]
30012b6a:	f88d 7010 	strb.w	r7, [r13, #16]
30012b6e:	f88d 3011 	strb.w	r3, [r13, #17]
30012b72:	f88d 5004 	strb.w	r5, [r13, #4]
30012b76:	9502      	str	r5, [sp, #8]
{
30012b78:	9e10      	ldr	r6, [sp, #64]	; 0x40
    nor->host_ops.lock(nor);
30012b7a:	4790      	blx	r2

    /* wait for flash idle */
    ret = waite_idle(nor);
30012b7c:	4620      	mov	r0, r4
30012b7e:	f7ff ff8b 	bl	30012a98 <waite_idle>

    if (ret)
30012b82:	b978      	cbnz	r0, 30012ba4 <spi_nor_read+0x80>
        goto read_out;

    ret = nor->host_ops.transfer(nor, &read_cmd, (u8 *)dst, length);
30012b84:	4633      	mov	r3, r6
30012b86:	a901      	add	r1, sp, #4
30012b88:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
30012b8c:	4620      	mov	r0, r4
30012b8e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30012b90:	47a8      	blx	r5
read_out:
    nor->host_ops.unlock(nor);
30012b92:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    ret = nor->host_ops.transfer(nor, &read_cmd, (u8 *)dst, length);
30012b96:	4605      	mov	r5, r0
    nor->host_ops.unlock(nor);
30012b98:	4620      	mov	r0, r4
30012b9a:	4798      	blx	r3

    if (ret)
30012b9c:	b93d      	cbnz	r5, 30012bae <spi_nor_read+0x8a>
        dprintf(CRITICAL, "spi_nor read data failed, ret: %d!\n", ret);

    return ret;
}
30012b9e:	4628      	mov	r0, r5
30012ba0:	b009      	add	sp, #36	; 0x24
30012ba2:	bdf0      	pop	{r4, r5, r6, r7, r15}
    nor->host_ops.unlock(nor);
30012ba4:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
30012ba8:	4605      	mov	r5, r0
30012baa:	4620      	mov	r0, r4
30012bac:	4798      	blx	r3
        dprintf(CRITICAL, "spi_nor read data failed, ret: %d!\n", ret);
30012bae:	f640 2064 	movw	r0, #2660	; 0xa64
30012bb2:	4629      	mov	r1, r5
30012bb4:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012bb8:	f002 fffa 	bl	30015bb0 <_printf>
}
30012bbc:	4628      	mov	r0, r5
30012bbe:	b009      	add	sp, #36	; 0x24
30012bc0:	bdf0      	pop	{r4, r5, r6, r7, r15}
30012bc2:	bf00      	nop

30012bc4 <training_data_check>:

static int training_data_check(struct spi_nor *nor)
{
30012bc4:	b5d0      	push	{r4, r6, r7, r14}
    uint32_t addr = 0 + nor->block_size;

    if (spi_nor_read(nor, addr, training_buf, 32)) {
30012bc6:	f24d 14e0 	movw	r4, #53728	; 0xd1e0
{
30012bca:	b084      	sub	sp, #16
    if (spi_nor_read(nor, addr, training_buf, 32)) {
30012bcc:	2620      	movs	r6, #32
30012bce:	2700      	movs	r7, #0
30012bd0:	6b82      	ldr	r2, [r0, #56]	; 0x38
30012bd2:	f2c3 0402 	movt	r4, #12290	; 0x3002
30012bd6:	e9cd 6702 	strd	r6, r7, [r13, #8]
30012bda:	2300      	movs	r3, #0
30012bdc:	9400      	str	r4, [sp, #0]
30012bde:	f7ff ffa1 	bl	30012b24 <spi_nor_read>
30012be2:	b968      	cbnz	r0, 30012c00 <training_data_check+0x3c>
        dprintf(CRITICAL, "%s: read taining data error\n", __FUNCTION__);
        return -1;
    };

    if(memcmp(training_buf, training_pattern, 32))
30012be4:	f245 31e0 	movw	r1, #21472	; 0x53e0
30012be8:	4620      	mov	r0, r4
30012bea:	2220      	movs	r2, #32
30012bec:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012bf0:	f003 f800 	bl	30015bf4 <memcmp>
30012bf4:	3000      	adds	r0, #0
30012bf6:	bf18      	it	ne
30012bf8:	2001      	movne	r0, #1
30012bfa:	4240      	negs	r0, r0
        return -1;

    return 0;
}
30012bfc:	b004      	add	sp, #16
30012bfe:	bdd0      	pop	{r4, r6, r7, r15}
        dprintf(CRITICAL, "%s: read taining data error\n", __FUNCTION__);
30012c00:	f640 11a4 	movw	r1, #2468	; 0x9a4
30012c04:	f640 20e0 	movw	r0, #2784	; 0xae0
30012c08:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012c0c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012c10:	f002 ffce 	bl	30015bb0 <_printf>
30012c14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30012c18:	e7f0      	b.n	30012bfc <training_data_check+0x38>
30012c1a:	bf00      	nop

30012c1c <spi_nor_erase>:
{
    int ret = 0;
    uint64_t remaining = length;
    struct spi_nor_cmd erase_cmd = {
        .type = SPI_NOR_OPS_ERASE,
        .opcode = GET_PROTO_OPCODE(nor->info->erase_proto),
30012c1c:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    struct spi_nor_cmd erase_cmd = {
30012c20:	2100      	movs	r1, #0
{
30012c22:	b5f0      	push	{r4, r5, r6, r7, r14}
        .opcode = GET_PROTO_OPCODE(nor->info->erase_proto),
30012c24:	695b      	ldr	r3, [r3, #20]
{
30012c26:	b089      	sub	sp, #36	; 0x24
    struct spi_nor_cmd erase_cmd = {
30012c28:	2503      	movs	r5, #3
{
30012c2a:	4604      	mov	r4, r0
    struct spi_nor_cmd erase_cmd = {
30012c2c:	9205      	str	r2, [sp, #20]
        .inst_width = SNOR_GET_INST_LANS(nor->info->erase_proto),
30012c2e:	f3c3 2603 	ubfx	r6, r3, #8, #4
        .opcode = GET_PROTO_OPCODE(nor->info->erase_proto),
30012c32:	0e1f      	lsrs	r7, r3, #24
    struct spi_nor_cmd erase_cmd = {
30012c34:	e9cd 1103 	strd	r1, r1, [r13, #12]
        .addr_width = SNOR_GET_ADDR_LANS(nor->info->erase_proto),
30012c38:	f3c3 1203 	ubfx	r2, r3, #4, #4
    struct spi_nor_cmd erase_cmd = {
30012c3c:	f88d 700c 	strb.w	r7, [r13, #12]
        .addr_bytes = SNOR_GET_ADDR_BYTES(nor->info->erase_proto),
30012c40:	f3c3 3303 	ubfx	r3, r3, #12, #4
    struct spi_nor_cmd erase_cmd = {
30012c44:	f88d 600e 	strb.w	r6, [r13, #14]
{
30012c48:	e9dd 670e 	ldrd	r6, r7, [r13, #56]	; 0x38
    struct spi_nor_cmd erase_cmd = {
30012c4c:	f88d 3011 	strb.w	r3, [r13, #17]
30012c50:	9101      	str	r1, [sp, #4]
        .addr = dst,
    };

    nor->host_ops.lock(nor);
30012c52:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    struct spi_nor_cmd erase_cmd = {
30012c56:	9106      	str	r1, [sp, #24]
30012c58:	9107      	str	r1, [sp, #28]
30012c5a:	f88d 200f 	strb.w	r2, [r13, #15]
30012c5e:	9502      	str	r5, [sp, #8]
    nor->host_ops.lock(nor);
30012c60:	4798      	blx	r3

    while (remaining) {
30012c62:	ea56 0307 	orrs.w	r3, r6, r7
30012c66:	d110      	bne.n	30012c8a <spi_nor_erase+0x6e>
30012c68:	e026      	b.n	30012cb8 <spi_nor_erase+0x9c>
        ret = waite_idle(nor);

        if (ret)
            break;

        ret = nor->host_ops.transfer(nor, &erase_cmd, NULL, 0);
30012c6a:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
30012c6e:	4620      	mov	r0, r4
30012c70:	47a8      	blx	r5

        if (ret)
30012c72:	4605      	mov	r5, r0
30012c74:	b990      	cbnz	r0, 30012c9c <spi_nor_erase+0x80>
            break;

        erase_cmd.addr += nor->block_size;
30012c76:	6ba2      	ldr	r2, [r4, #56]	; 0x38
30012c78:	9b05      	ldr	r3, [sp, #20]
        remaining -= nor->block_size;
30012c7a:	1ab6      	subs	r6, r6, r2
        erase_cmd.addr += nor->block_size;
30012c7c:	4413      	add	r3, r2
        remaining -= nor->block_size;
30012c7e:	f167 0700 	sbc.w	r7, r7, #0
        erase_cmd.addr += nor->block_size;
30012c82:	9305      	str	r3, [sp, #20]
    while (remaining) {
30012c84:	ea56 0307 	orrs.w	r3, r6, r7
30012c88:	d016      	beq.n	30012cb8 <spi_nor_erase+0x9c>
        ret = waite_idle(nor);
30012c8a:	4620      	mov	r0, r4
30012c8c:	f7ff ff04 	bl	30012a98 <waite_idle>
        ret = nor->host_ops.transfer(nor, &erase_cmd, NULL, 0);
30012c90:	a901      	add	r1, sp, #4
        if (ret)
30012c92:	4605      	mov	r5, r0
        ret = nor->host_ops.transfer(nor, &erase_cmd, NULL, 0);
30012c94:	4603      	mov	r3, r0
30012c96:	4602      	mov	r2, r0
        if (ret)
30012c98:	2800      	cmp	r0, #0
30012c9a:	d0e6      	beq.n	30012c6a <spi_nor_erase+0x4e>
    }

    nor->host_ops.unlock(nor);
30012c9c:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
30012ca0:	4620      	mov	r0, r4
30012ca2:	4798      	blx	r3

    if (ret) {
        dprintf(CRITICAL, "spi_nor erase failed, ret: %d!\n", ret);
30012ca4:	f640 10c8 	movw	r0, #2504	; 0x9c8
30012ca8:	4629      	mov	r1, r5
30012caa:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012cae:	f002 ff7f 	bl	30015bb0 <_printf>
    }

    return ret;
}
30012cb2:	4628      	mov	r0, r5
30012cb4:	b009      	add	sp, #36	; 0x24
30012cb6:	bdf0      	pop	{r4, r5, r6, r7, r15}
    nor->host_ops.unlock(nor);
30012cb8:	4620      	mov	r0, r4
30012cba:	2500      	movs	r5, #0
30012cbc:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
30012cc0:	4798      	blx	r3
}
30012cc2:	4628      	mov	r0, r5
30012cc4:	b009      	add	sp, #36	; 0x24
30012cc6:	bdf0      	pop	{r4, r5, r6, r7, r15}

30012cc8 <spi_nor_write>:
{
    int ret = 0;
    struct spi_nor_cmd write_cmd = {
        .use_dma = 1,
        .type = SPI_NOR_OPS_WRITE,
        .opcode = GET_PROTO_OPCODE(nor->info->write_proto),
30012cc8:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    struct spi_nor_cmd write_cmd = {
30012ccc:	2100      	movs	r1, #0
{
30012cce:	b5f0      	push	{r4, r5, r6, r7, r14}
        .opcode = GET_PROTO_OPCODE(nor->info->write_proto),
30012cd0:	691b      	ldr	r3, [r3, #16]
{
30012cd2:	b089      	sub	sp, #36	; 0x24
    struct spi_nor_cmd write_cmd = {
30012cd4:	2601      	movs	r6, #1
30012cd6:	2502      	movs	r5, #2
30012cd8:	e9cd 1204 	strd	r1, r2, [r13, #16]
        .dummy = 0,
        .inst_width = SNOR_GET_INST_LANS(nor->info->write_proto),
30012cdc:	f3c3 2c03 	ubfx	r12, r3, #8, #4
    struct spi_nor_cmd write_cmd = {
30012ce0:	9103      	str	r1, [sp, #12]
        .opcode = GET_PROTO_OPCODE(nor->info->write_proto),
30012ce2:	0e1a      	lsrs	r2, r3, #24
{
30012ce4:	4604      	mov	r4, r0
        .addr_width = SNOR_GET_ADDR_LANS(nor->info->write_proto),
30012ce6:	f3c3 1703 	ubfx	r7, r3, #4, #4
    struct spi_nor_cmd write_cmd = {
30012cea:	f88d 200c 	strb.w	r2, [r13, #12]
        .data_width = SNOR_GET_DATA_LANS(nor->info->write_proto),
30012cee:	f003 020f 	and.w	r2, r3, #15
    struct spi_nor_cmd write_cmd = {
30012cf2:	9101      	str	r1, [sp, #4]
        .addr_bytes = SNOR_GET_ADDR_BYTES(nor->info->write_proto),
30012cf4:	f3c3 3303 	ubfx	r3, r3, #12, #4
    struct spi_nor_cmd write_cmd = {
30012cf8:	f88d 2010 	strb.w	r2, [r13, #16]
30012cfc:	f88d 6004 	strb.w	r6, [r13, #4]
        .addr = dst,
    };

    nor->host_ops.lock(nor);
30012d00:	f8d0 2098 	ldr.w	r2, [r0, #152]	; 0x98
    struct spi_nor_cmd write_cmd = {
30012d04:	9106      	str	r1, [sp, #24]
30012d06:	9107      	str	r1, [sp, #28]
30012d08:	f88d c00e 	strb.w	r12, [r13, #14]
30012d0c:	f88d 700f 	strb.w	r7, [r13, #15]
30012d10:	f88d 3011 	strb.w	r3, [r13, #17]
30012d14:	9502      	str	r5, [sp, #8]
{
30012d16:	9e10      	ldr	r6, [sp, #64]	; 0x40
    nor->host_ops.lock(nor);
30012d18:	4790      	blx	r2

    /* wait for flash idle */
    ret = waite_idle(nor);
30012d1a:	4620      	mov	r0, r4
30012d1c:	f7ff febc 	bl	30012a98 <waite_idle>
    if (ret)
30012d20:	b978      	cbnz	r0, 30012d42 <spi_nor_write+0x7a>
        goto write_out;

    ret = nor->host_ops.transfer(nor, &write_cmd, (void *)src_buf, length);
30012d22:	4633      	mov	r3, r6
30012d24:	a901      	add	r1, sp, #4
30012d26:	f8d4 508c 	ldr.w	r5, [r4, #140]	; 0x8c
30012d2a:	4620      	mov	r0, r4
30012d2c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30012d2e:	47a8      	blx	r5

write_out:
    nor->host_ops.unlock(nor);
30012d30:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
    ret = nor->host_ops.transfer(nor, &write_cmd, (void *)src_buf, length);
30012d34:	4605      	mov	r5, r0
    nor->host_ops.unlock(nor);
30012d36:	4620      	mov	r0, r4
30012d38:	4798      	blx	r3
    if (ret) {
30012d3a:	b93d      	cbnz	r5, 30012d4c <spi_nor_write+0x84>
        dprintf(CRITICAL, "spi_nor write array failed, ret: %d!\n", ret);
    }
    return ret;
}
30012d3c:	4628      	mov	r0, r5
30012d3e:	b009      	add	sp, #36	; 0x24
30012d40:	bdf0      	pop	{r4, r5, r6, r7, r15}
    nor->host_ops.unlock(nor);
30012d42:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
30012d46:	4605      	mov	r5, r0
30012d48:	4620      	mov	r0, r4
30012d4a:	4798      	blx	r3
        dprintf(CRITICAL, "spi_nor write array failed, ret: %d!\n", ret);
30012d4c:	f640 2088 	movw	r0, #2696	; 0xa88
30012d50:	4629      	mov	r1, r5
30012d52:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012d56:	f002 ff2b 	bl	30015bb0 <_printf>
}
30012d5a:	4628      	mov	r0, r5
30012d5c:	b009      	add	sp, #36	; 0x24
30012d5e:	bdf0      	pop	{r4, r5, r6, r7, r15}

30012d60 <spi_nor_init>:
{
30012d60:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    nor->id = devid;
30012d64:	f24d 16c8 	movw	r6, #53704	; 0xd1c8
    nor->cssot_ns = 30;
30012d68:	231e      	movs	r3, #30
    nor->id = devid;
30012d6a:	f2c3 0602 	movt	r6, #12290	; 0x3002
    nor->cseot_ns = 30;
30012d6e:	e9c0 3310 	strd	r3, r3, [r0, #64]	; 0x40
{
30012d72:	b08d      	sub	sp, #52	; 0x34
    nor->id = devid;
30012d74:	6006      	str	r6, [r0, #0]
{
30012d76:	4605      	mov	r5, r0
    nor->csda_ns = 30;
30012d78:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
    if (spi_nor_host_init(nor)) {
30012d7c:	f7f8 fd34 	bl	3000b7e8 <spi_nor_host_init>
30012d80:	2800      	cmp	r0, #0
30012d82:	f040 80ab 	bne.w	30012edc <spi_nor_init+0x17c>
30012d86:	4604      	mov	r4, r0
    struct spi_nor_cmd read_cmd = {
30012d88:	239f      	movs	r3, #159	; 0x9f
    nor->host_ops.lock(nor);
30012d8a:	4628      	mov	r0, r5
    struct spi_nor_cmd read_cmd = {
30012d8c:	e9cd 4406 	strd	r4, r4, [r13, #24]
30012d90:	9405      	str	r4, [sp, #20]
30012d92:	f88d 301c 	strb.w	r3, [r13, #28]
30012d96:	e9cd 4408 	strd	r4, r4, [r13, #32]
    nor->host_ops.lock(nor);
30012d9a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
    struct spi_nor_cmd read_cmd = {
30012d9e:	e9cd 440a 	strd	r4, r4, [r13, #40]	; 0x28
    nor->host_ops.lock(nor);
30012da2:	4798      	blx	r3
    nor->host_ops.reg_read(nor, &read_cmd, (u8 *)buf, 8);
30012da4:	4632      	mov	r2, r6
30012da6:	2308      	movs	r3, #8
30012da8:	a905      	add	r1, sp, #20
30012daa:	f8d5 7088 	ldr.w	r7, [r5, #136]	; 0x88
30012dae:	4628      	mov	r0, r5
30012db0:	47b8      	blx	r7
    nor->host_ops.unlock(nor);
30012db2:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
30012db6:	4628      	mov	r0, r5
30012db8:	4798      	blx	r3
30012dba:	f245 22fc 	movw	r2, #21244	; 0x52fc
    for (u32 i = 0; i < ARRAY_NUMS(spi_nor_ids); i++) {
30012dbe:	4620      	mov	r0, r4
30012dc0:	f2c3 0202 	movt	r2, #12290	; 0x3002
30012dc4:	4613      	mov	r3, r2
            if (!memcmp(info->flash_id, buf, 2)) {
30012dc6:	791c      	ldrb	r4, [r3, #4]
30012dc8:	7831      	ldrb	r1, [r6, #0]
            info = &spi_nor_ids[i];
30012dca:	469c      	mov	r12, r3
            if (!memcmp(info->flash_id, buf, 2)) {
30012dcc:	428c      	cmp	r4, r1
30012dce:	d026      	beq.n	30012e1e <spi_nor_init+0xbe>
    for (u32 i = 0; i < ARRAY_NUMS(spi_nor_ids); i++) {
30012dd0:	3001      	adds	r0, #1
30012dd2:	2806      	cmp	r0, #6
30012dd4:	f103 0324 	add.w	r3, r3, #36	; 0x24
30012dd8:	d1f5      	bne.n	30012dc6 <spi_nor_init+0x66>
30012dda:	2005      	movs	r0, #5
30012ddc:	2128      	movs	r1, #40	; 0x28
30012dde:	f8d2 40d4 	ldr.w	r4, [r2, #212]	; 0xd4
    nor->info = flash_id_read(nor, devid);
30012de2:	f8c5 c080 	str.w	r12, [r5, #128]	; 0x80
    nor->size = nor->info->size;
30012de6:	626c      	str	r4, [r5, #36]	; 0x24
    nor->block_size = nor->info->sector_size;
30012de8:	4401      	add	r1, r0
    if (training_data_check(nor)) {
30012dea:	4628      	mov	r0, r5
    nor->block_size = nor->info->sector_size;
30012dec:	eb02 0281 	add.w	r2, r2, r1, lsl #2
30012df0:	8b56      	ldrh	r6, [r2, #26]
    nor->page_size = nor->info->page_size;
30012df2:	8b93      	ldrh	r3, [r2, #28]
30012df4:	e9c5 630e 	strd	r6, r3, [r5, #56]	; 0x38
    if (training_data_check(nor)) {
30012df8:	f7ff fee4 	bl	30012bc4 <training_data_check>
30012dfc:	2800      	cmp	r0, #0
30012dfe:	d148      	bne.n	30012e92 <spi_nor_init+0x132>
    ret = nor->host_ops.training(nor, training_data_check);
30012e00:	f642 31c5 	movw	r1, #11205	; 0x2bc5
30012e04:	4628      	mov	r0, r5
30012e06:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
30012e0a:	f2c3 0101 	movt	r1, #12289	; 0x3001
30012e0e:	4798      	blx	r3
    ret = waite_idle(nor);
30012e10:	4628      	mov	r0, r5
30012e12:	f7ff fe41 	bl	30012a98 <waite_idle>
    if (ret)
30012e16:	b188      	cbz	r0, 30012e3c <spi_nor_init+0xdc>
}
30012e18:	b00d      	add	sp, #52	; 0x34
30012e1a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (!memcmp(info->flash_id, buf, 2)) {
30012e1e:	795c      	ldrb	r4, [r3, #5]
30012e20:	7871      	ldrb	r1, [r6, #1]
30012e22:	428c      	cmp	r4, r1
30012e24:	d1d4      	bne.n	30012dd0 <spi_nor_init+0x70>
                info->size = 1 << buf[SPINOR_ID_CAPACITY_OFFSET];
30012e26:	78b7      	ldrb	r7, [r6, #2]
30012e28:	2401      	movs	r4, #1
30012e2a:	00c1      	lsls	r1, r0, #3
30012e2c:	180e      	adds	r6, r1, r0
30012e2e:	40bc      	lsls	r4, r7
30012e30:	eb02 0686 	add.w	r6, r2, r6, lsl #2
30012e34:	6234      	str	r4, [r6, #32]
    nor->info = flash_id_read(nor, devid);
30012e36:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
30012e3a:	e7d4      	b.n	30012de6 <spi_nor_init+0x86>
    if (spi_nor_read(nor, training_addr, training_buf, 32)) {
30012e3c:	f24d 14e0 	movw	r4, #53728	; 0xd1e0
30012e40:	f04f 0820 	mov.w	r8, #32
30012e44:	f04f 0900 	mov.w	r9, #0
30012e48:	f2c3 0402 	movt	r4, #12290	; 0x3002
30012e4c:	4628      	mov	r0, r5
30012e4e:	2300      	movs	r3, #0
30012e50:	4632      	mov	r2, r6
30012e52:	f245 35e0 	movw	r5, #21472	; 0x53e0
30012e56:	9400      	str	r4, [sp, #0]
30012e58:	f2c3 0502 	movt	r5, #12290	; 0x3002
30012e5c:	e9cd 8902 	strd	r8, r9, [r13, #8]
30012e60:	f7ff fe60 	bl	30012b24 <spi_nor_read>
    for (i = 0; i < 32; i++, p2++, p3++) {
30012e64:	4603      	mov	r3, r0
    if (spi_nor_read(nor, training_addr, training_buf, 32)) {
30012e66:	b118      	cbz	r0, 30012e70 <spi_nor_init+0x110>
30012e68:	e041      	b.n	30012eee <spi_nor_init+0x18e>
    for (i = 0; i < 32; i++, p2++, p3++) {
30012e6a:	3301      	adds	r3, #1
30012e6c:	2b20      	cmp	r3, #32
30012e6e:	d0d3      	beq.n	30012e18 <spi_nor_init+0xb8>
        if (*p2 != *p3) {
30012e70:	f815 2b01 	ldrb.w	r2, [r5], #1
30012e74:	f814 1b01 	ldrb.w	r1, [r4], #1
30012e78:	428a      	cmp	r2, r1
30012e7a:	d0f6      	beq.n	30012e6a <spi_nor_init+0x10a>
            dprintf(CRITICAL, "\n spi_nor training data error: 0x%x - 0x%x : i=%d\n",
30012e7c:	f640 2030 	movw	r0, #2608	; 0xa30
30012e80:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012e84:	f002 fe94 	bl	30015bb0 <_printf>
            ret = -1;
30012e88:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
30012e8c:	b00d      	add	sp, #52	; 0x34
30012e8e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (spi_nor_erase(nor, training_addr, nor->block_size)) {
30012e92:	2100      	movs	r1, #0
30012e94:	fa1f f886 	uxth.w	r8, r6
30012e98:	f04f 0900 	mov.w	r9, #0
30012e9c:	4628      	mov	r0, r5
30012e9e:	9101      	str	r1, [sp, #4]
30012ea0:	4642      	mov	r2, r8
30012ea2:	6ba9      	ldr	r1, [r5, #56]	; 0x38
30012ea4:	464b      	mov	r3, r9
30012ea6:	9100      	str	r1, [sp, #0]
30012ea8:	f7ff feb8 	bl	30012c1c <spi_nor_erase>
30012eac:	bbc8      	cbnz	r0, 30012f22 <spi_nor_init+0x1c2>
        if (spi_nor_write(nor, training_addr, training_pattern, 32)) {
30012eae:	f245 31e0 	movw	r1, #21472	; 0x53e0
30012eb2:	f04f 0a20 	mov.w	r10, #32
30012eb6:	f04f 0b00 	mov.w	r11, #0
30012eba:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012ebe:	4642      	mov	r2, r8
30012ec0:	464b      	mov	r3, r9
30012ec2:	9100      	str	r1, [sp, #0]
30012ec4:	4628      	mov	r0, r5
30012ec6:	e9cd ab02 	strd	r10, r11, [r13, #8]
30012eca:	f7ff fefd 	bl	30012cc8 <spi_nor_write>
30012ece:	b9d8      	cbnz	r0, 30012f08 <spi_nor_init+0x1a8>
        ret = waite_idle(nor);
30012ed0:	4628      	mov	r0, r5
30012ed2:	f7ff fde1 	bl	30012a98 <waite_idle>
    if (ret) {
30012ed6:	2800      	cmp	r0, #0
30012ed8:	d092      	beq.n	30012e00 <spi_nor_init+0xa0>
30012eda:	e79d      	b.n	30012e18 <spi_nor_init+0xb8>
        dprintf(CRITICAL, "spi_nor init controller failed\n");
30012edc:	f640 10e8 	movw	r0, #2536	; 0x9e8
30012ee0:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012ee4:	f002 fe64 	bl	30015bb0 <_printf>
        ret = -1;
30012ee8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        goto init_out;
30012eec:	e794      	b.n	30012e18 <spi_nor_init+0xb8>
        dprintf(CRITICAL, "%s: read taining data error\n", __FUNCTION__);
30012eee:	f640 11b8 	movw	r1, #2488	; 0x9b8
30012ef2:	f640 20e0 	movw	r0, #2784	; 0xae0
30012ef6:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012efa:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012efe:	f002 fe57 	bl	30015bb0 <_printf>
        ret = -1;
30012f02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        goto init_out;
30012f06:	e787      	b.n	30012e18 <spi_nor_init+0xb8>
            dprintf(CRITICAL, "%s: write error\n", __FUNCTION__);
30012f08:	f640 11b8 	movw	r1, #2488	; 0x9b8
30012f0c:	f640 201c 	movw	r0, #2588	; 0xa1c
30012f10:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012f14:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012f18:	f002 fe4a 	bl	30015bb0 <_printf>
            ret = -1;
30012f1c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            goto init_out;
30012f20:	e77a      	b.n	30012e18 <spi_nor_init+0xb8>
            dprintf(CRITICAL, "%s: erase error\n", __FUNCTION__);
30012f22:	f640 11b8 	movw	r1, #2488	; 0x9b8
30012f26:	f640 2008 	movw	r0, #2568	; 0xa08
30012f2a:	f2c3 0102 	movt	r1, #12290	; 0x3002
30012f2e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30012f32:	f002 fe3d 	bl	30015bb0 <_printf>
            ret = -1;
30012f36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
            goto init_out;
30012f3a:	e76d      	b.n	30012e18 <spi_nor_init+0xb8>

30012f3c <spi_nor_deinit>:

void spi_nor_deinit(struct spi_nor *nor) { return; }
30012f3c:	4770      	bx	r14
30012f3e:	bf00      	nop

30012f40 <spi_nor_get_capacity>:
    return nor->host_ops.cancel(nor);
}

inline uint64_t spi_nor_get_capacity(struct spi_nor *nor)
{
    return nor ? nor->size : 0;
30012f40:	b100      	cbz	r0, 30012f44 <spi_nor_get_capacity+0x4>
30012f42:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
30012f44:	2100      	movs	r1, #0
30012f46:	4770      	bx	r14

30012f48 <spi_nor_get_flash_id>:

inline uint64_t spi_nor_get_flash_id(struct spi_nor *nor)
{
    uint64_t flash_id = nor ? *(uint64_t *)&nor->id[0] : 0;
30012f48:	b118      	cbz	r0, 30012f52 <spi_nor_get_flash_id+0xa>
30012f4a:	6803      	ldr	r3, [r0, #0]
30012f4c:	e9d3 0100 	ldrd	r0, r1, [r3]
30012f50:	4770      	bx	r14
30012f52:	2000      	movs	r0, #0
30012f54:	2100      	movs	r1, #0
    return flash_id;
}
30012f56:	4770      	bx	r14

30012f58 <crc32>:
unsigned long ZEXPORT crc32(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0UL;
30012f58:	2900      	cmp	r1, #0
30012f5a:	d079      	beq.n	30013050 <crc32+0xf8>
        else
            return crc32_big(crc, buf, len);
    }
#endif /* BYFOUR */
    crc = crc ^ 0xffffffffUL;
    while (len >= 8) {
30012f5c:	2a07      	cmp	r2, #7
{
30012f5e:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    crc = crc ^ 0xffffffffUL;
30012f62:	ea6f 0000 	mvn.w	r0, r0
    while (len >= 8) {
30012f66:	d960      	bls.n	3001302a <crc32+0xd2>
30012f68:	f640 3450 	movw	r4, #2896	; 0xb50
30012f6c:	f1a2 0e08 	sub.w	r14, r2, #8
30012f70:	f101 0308 	add.w	r3, r1, #8
30012f74:	ea4f 0ede 	mov.w	r14, r14, lsr #3
30012f78:	f2c3 0402 	movt	r4, #12290	; 0x3002
30012f7c:	eb01 0cce 	add.w	r12, r1, r14, lsl #3
30012f80:	f10c 0c10 	add.w	r12, r12, #16
        DO8;
30012f84:	f813 5c08 	ldrb.w	r5, [r3, #-8]
30012f88:	4045      	eors	r5, r0
30012f8a:	f813 bc07 	ldrb.w	r11, [r3, #-7]
30012f8e:	f813 ac06 	ldrb.w	r10, [r3, #-6]
30012f92:	b2ed      	uxtb	r5, r5
30012f94:	f813 9c05 	ldrb.w	r9, [r3, #-5]
30012f98:	f813 8c04 	ldrb.w	r8, [r3, #-4]
30012f9c:	f813 7c03 	ldrb.w	r7, [r3, #-3]
30012fa0:	f813 6c02 	ldrb.w	r6, [r3, #-2]
30012fa4:	3308      	adds	r3, #8
30012fa6:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
30012faa:	ea85 2010 	eor.w	r0, r5, r0, lsr #8
30012fae:	f813 5c09 	ldrb.w	r5, [r3, #-9]
30012fb2:	ea8b 0b00 	eor.w	r11, r11, r0
    while (len >= 8) {
30012fb6:	459c      	cmp	r12, r3
        DO8;
30012fb8:	fa5f fb8b 	uxtb.w	r11, r11
30012fbc:	f854 b02b 	ldr.w	r11, [r4, r11, lsl #2]
30012fc0:	ea8b 2010 	eor.w	r0, r11, r0, lsr #8
30012fc4:	ea8a 0a00 	eor.w	r10, r10, r0
30012fc8:	fa5f fa8a 	uxtb.w	r10, r10
30012fcc:	f854 a02a 	ldr.w	r10, [r4, r10, lsl #2]
30012fd0:	ea8a 2010 	eor.w	r0, r10, r0, lsr #8
30012fd4:	ea89 0900 	eor.w	r9, r9, r0
30012fd8:	fa5f f989 	uxtb.w	r9, r9
30012fdc:	f854 9029 	ldr.w	r9, [r4, r9, lsl #2]
30012fe0:	ea89 2910 	eor.w	r9, r9, r0, lsr #8
30012fe4:	ea88 0009 	eor.w	r0, r8, r9
30012fe8:	b2c0      	uxtb	r0, r0
30012fea:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
30012fee:	ea80 2819 	eor.w	r8, r0, r9, lsr #8
30012ff2:	ea87 0708 	eor.w	r7, r7, r8
30012ff6:	b2ff      	uxtb	r7, r7
30012ff8:	f854 7027 	ldr.w	r7, [r4, r7, lsl #2]
30012ffc:	ea87 2718 	eor.w	r7, r7, r8, lsr #8
30013000:	ea86 0607 	eor.w	r6, r6, r7
30013004:	b2f6      	uxtb	r6, r6
30013006:	f854 0026 	ldr.w	r0, [r4, r6, lsl #2]
3001300a:	ea80 2017 	eor.w	r0, r0, r7, lsr #8
3001300e:	ea85 0500 	eor.w	r5, r5, r0
30013012:	b2ed      	uxtb	r5, r5
30013014:	f854 5025 	ldr.w	r5, [r4, r5, lsl #2]
30013018:	ea85 2010 	eor.w	r0, r5, r0, lsr #8
    while (len >= 8) {
3001301c:	d1b2      	bne.n	30012f84 <crc32+0x2c>
3001301e:	f10e 0e01 	add.w	r14, r14, #1
30013022:	f002 0207 	and.w	r2, r2, #7
30013026:	eb01 01ce 	add.w	r1, r1, r14, lsl #3
        len -= 8;
    }
    if (len) do {
3001302a:	b172      	cbz	r2, 3001304a <crc32+0xf2>
3001302c:	f640 3450 	movw	r4, #2896	; 0xb50
30013030:	440a      	add	r2, r1
30013032:	f2c3 0402 	movt	r4, #12290	; 0x3002
        DO1;
30013036:	f811 3b01 	ldrb.w	r3, [r1], #1
3001303a:	4043      	eors	r3, r0
    } while (--len);
3001303c:	4291      	cmp	r1, r2
        DO1;
3001303e:	b2db      	uxtb	r3, r3
30013040:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
30013044:	ea83 2010 	eor.w	r0, r3, r0, lsr #8
    } while (--len);
30013048:	d1f5      	bne.n	30013036 <crc32+0xde>
    return crc ^ 0xffffffffUL;
3001304a:	43c0      	mvns	r0, r0
}
3001304c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (buf == Z_NULL) return 0UL;
30013050:	4608      	mov	r0, r1
}
30013052:	4770      	bx	r14

30013054 <novm_init_helper>:
}

static void novm_init_helper(struct novm_arena *n, const char *name,
                             uintptr_t arena_start, uintptr_t arena_size,
                             char *default_map, size_t default_map_size)
{
30013054:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
30013058:	4690      	mov	r8, r2
    uintptr_t start = ROUNDUP(arena_start, PAGE_SIZE);
3001305a:	f44f 4270 	mov.w	r2, #61440	; 0xf000
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
3001305e:	eb08 0603 	add.w	r6, r8, r3
    uintptr_t start = ROUNDUP(arena_start, PAGE_SIZE);
30013062:	f6cf 72ff 	movt	r2, #65535	; 0xffff
30013066:	f608 74ff 	addw	r4, r8, #4095	; 0xfff
3001306a:	4014      	ands	r4, r2
{
3001306c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
3001306e:	4016      	ands	r6, r2
{
30013070:	f8dd a028 	ldr.w	r10, [r13, #40]	; 0x28
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
30013074:	1b36      	subs	r6, r6, r4
{
30013076:	468b      	mov	r11, r1
30013078:	4681      	mov	r9, r0

    mutex_init(&n->lock);

    size_t map_size = size >> PAGE_SIZE_SHIFT;
3001307a:	0b35      	lsrs	r5, r6, #12
    mutex_init(&n->lock);
3001307c:	f7fe fc9c 	bl	300119b8 <mutex_init>
    char *map = default_map;
    if (map == NULL || default_map_size < map_size) {
30013080:	42bd      	cmp	r5, r7
30013082:	bf94      	ite	ls
30013084:	2700      	movls	r7, #0
30013086:	2701      	movhi	r7, #1
30013088:	eba4 0308 	sub.w	r3, r4, r8
3001308c:	f1ba 0f00 	cmp.w	r10, #0
30013090:	bf08      	it	eq
30013092:	2701      	moveq	r7, #1
30013094:	b31f      	cbz	r7, 300130de <novm_init_helper+0x8a>
        // allocate the map out of the arena itself
        map = (char *)arena_start;
30013096:	46c2      	mov	r10, r8

        // Grab enough map for 16Mbyte of arena each time around the loop.
        while (start - arena_start < map_size) {
30013098:	429d      	cmp	r5, r3
3001309a:	d908      	bls.n	300130ae <novm_init_helper+0x5a>
            start += PAGE_SIZE;
3001309c:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
            size -= PAGE_SIZE;
            map_size--;
300130a0:	3d01      	subs	r5, #1
        while (start - arena_start < map_size) {
300130a2:	eba4 0308 	sub.w	r3, r4, r8
300130a6:	429d      	cmp	r5, r3
            size -= PAGE_SIZE;
300130a8:	f5a6 5680 	sub.w	r6, r6, #4096	; 0x1000
        while (start - arena_start < map_size) {
300130ac:	d8f6      	bhi.n	3001309c <novm_init_helper+0x48>
        }

        if ((char *)start - (map + ROUNDUP(map_size, 4)) >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
300130ae:	1cea      	adds	r2, r5, #3
300130b0:	f022 0203 	bic.w	r2, r2, #3
300130b4:	4442      	add	r2, r8
300130b6:	1aa3      	subs	r3, r4, r2
300130b8:	2b3f      	cmp	r3, #63	; 0x3f
300130ba:	dd01      	ble.n	300130c0 <novm_init_helper+0x6c>
            n->unaligned_area = map + ROUNDUP(map_size, 4);
            n->unaligned_size = (char *)start - (map + ROUNDUP(map_size, 4));
300130bc:	e9c9 230c 	strd	r2, r3, [r9, #48]	; 0x30
        }
    } else if (start - arena_start >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
        n->unaligned_area = (char *)arena_start;
        n->unaligned_size = start - arena_start;
    }
    n->name = name;
300130c0:	f8c9 b01c 	str.w	r11, [r9, #28]
    n->map = map;
    memset(n->map, 0, map_size);
300130c4:	4650      	mov	r0, r10
    n->map = map;
300130c6:	f8c9 a024 	str.w	r10, [r9, #36]	; 0x24
    memset(n->map, 0, map_size);
300130ca:	462a      	mov	r2, r5
300130cc:	2100      	movs	r1, #0
300130ce:	f001 ec50 	blx	30014970 <memset>
    n->pages = map_size;
300130d2:	f8c9 5020 	str.w	r5, [r9, #32]
    n->base = (char *)start;
    n->size = size;
300130d6:	e9c9 460a 	strd	r4, r6, [r9, #40]	; 0x28
}
300130da:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
    } else if (start - arena_start >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
300130de:	2b3f      	cmp	r3, #63	; 0x3f
        n->unaligned_size = start - arena_start;
300130e0:	bf88      	it	hi
300130e2:	e9c9 830c 	strdhi	r8, r3, [r9, #48]	; 0x30
300130e6:	e7eb      	b.n	300130c0 <novm_init_helper+0x6c>

300130e8 <novm_init>:
    }
    panic("novm_add_arena: too many arenas added, bump NOVM_MAX_ARENAS!\n");
}

static void novm_init(uint level)
{
300130e8:	b530      	push	{r4, r5, r14}
    static char mem_allocation_map[DEFAULT_MAP_SIZE];
    novm_init_helper(&arena[0], "main", MEM_START, MEM_SIZE, mem_allocation_map, DEFAULT_MAP_SIZE);
300130ea:	f64e 02cc 	movw	r2, #59596	; 0xe8cc
300130ee:	f24d 2438 	movw	r4, #53816	; 0xd238
{
300130f2:	b083      	sub	sp, #12
    novm_init_helper(&arena[0], "main", MEM_START, MEM_SIZE, mem_allocation_map, DEFAULT_MAP_SIZE);
300130f4:	f2c3 0202 	movt	r2, #12290	; 0x3002
300130f8:	f44f 65c0 	mov.w	r5, #1536	; 0x600
300130fc:	f2c3 0402 	movt	r4, #12290	; 0x3002
30013100:	f640 7150 	movw	r1, #3920	; 0xf50
30013104:	f1c2 5341 	rsb	r3, r2, #809500672	; 0x30400000
30013108:	f24d 2000 	movw	r0, #53760	; 0xd200
3001310c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
30013110:	9400      	str	r4, [sp, #0]
30013112:	f2c3 0102 	movt	r1, #12290	; 0x3002
30013116:	9501      	str	r5, [sp, #4]
30013118:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001311c:	f7ff ff9a 	bl	30013054 <novm_init_helper>
}
30013120:	b003      	add	sp, #12
30013122:	bd30      	pop	{r4, r5, r15}

30013124 <novm_alloc_helper>:

LK_INIT_HOOK(novm, &novm_init, LK_INIT_LEVEL_PLATFORM_EARLY - 1);

void *novm_alloc_helper(struct novm_arena *n, size_t pages)
{
    if (pages == 0 || pages > n->pages)
30013124:	b3c9      	cbz	r1, 3001319a <novm_alloc_helper+0x76>
30013126:	6a03      	ldr	r3, [r0, #32]
{
30013128:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
3001312c:	4680      	mov	r8, r0
    if (pages == 0 || pages > n->pages)
3001312e:	428b      	cmp	r3, r1
        return NULL;
30013130:	bf38      	it	cc
30013132:	2000      	movcc	r0, #0
    if (pages == 0 || pages > n->pages)
30013134:	d325      	bcc.n	30013182 <novm_alloc_helper+0x5e>
30013136:	460e      	mov	r6, r1
30013138:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3001313c:	f7fe fc76 	bl	30011a2c <mutex_acquire_timeout>

    mutex_acquire(&n->lock);
    for (size_t i = 0; i <= n->pages - pages; i++) {
        bool found = true;
        for (size_t j = 0; j < pages; j++) {
            if (n->map[i + j] != 0) {
30013140:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    for (size_t i = 0; i <= n->pages - pages; i++) {
30013144:	2700      	movs	r7, #0
30013146:	eba3 0c06 	sub.w	r12, r3, r6
3001314a:	eb05 0e06 	add.w	r14, r5, r6
            if (n->map[i + j] != 0) {
3001314e:	19e8      	adds	r0, r5, r7
30013150:	5deb      	ldrb	r3, [r5, r7]
30013152:	b9c3      	cbnz	r3, 30013186 <novm_alloc_helper+0x62>
30013154:	1c7b      	adds	r3, r7, #1
30013156:	442b      	add	r3, r5
30013158:	eb0e 0207 	add.w	r2, r14, r7
3001315c:	e002      	b.n	30013164 <novm_alloc_helper+0x40>
3001315e:	f813 4b01 	ldrb.w	r4, [r3], #1
30013162:	b98c      	cbnz	r4, 30013188 <novm_alloc_helper+0x64>
        for (size_t j = 0; j < pages; j++) {
30013164:	4293      	cmp	r3, r2
30013166:	eba3 0105 	sub.w	r1, r3, r5
3001316a:	d1f8      	bne.n	3001315e <novm_alloc_helper+0x3a>
                found = false;
                break;
            }
        }
        if (found) {
            memset(n->map + i, 1, pages);
3001316c:	4632      	mov	r2, r6
3001316e:	2101      	movs	r1, #1
30013170:	f001 ebfe 	blx	30014970 <memset>
            mutex_release(&n->lock);
30013174:	4640      	mov	r0, r8
30013176:	f7fe fc85 	bl	30011a84 <mutex_release>
            return n->base + (i << PAGE_SIZE_SHIFT);
3001317a:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
3001317e:	eb00 3007 	add.w	r0, r0, r7, lsl #12
        }
    }
    mutex_release(&n->lock);

    return NULL;
}
30013182:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            if (n->map[i + j] != 0) {
30013186:	4639      	mov	r1, r7
    for (size_t i = 0; i <= n->pages - pages; i++) {
30013188:	1c4f      	adds	r7, r1, #1
3001318a:	4567      	cmp	r7, r12
3001318c:	d9df      	bls.n	3001314e <novm_alloc_helper+0x2a>
    mutex_release(&n->lock);
3001318e:	4640      	mov	r0, r8
30013190:	f7fe fc78 	bl	30011a84 <mutex_release>
    return NULL;
30013194:	2000      	movs	r0, #0
}
30013196:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return NULL;
3001319a:	4608      	mov	r0, r1
}
3001319c:	4770      	bx	r14
3001319e:	bf00      	nop

300131a0 <novm_alloc_unaligned>:
    if (arena[0].unaligned_area != NULL) {
300131a0:	f24d 2300 	movw	r3, #53760	; 0xd200
300131a4:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
300131a8:	b410      	push	{r4}
300131aa:	4604      	mov	r4, r0
    if (arena[0].unaligned_area != NULL) {
300131ac:	6b18      	ldr	r0, [r3, #48]	; 0x30
300131ae:	b138      	cbz	r0, 300131c0 <novm_alloc_unaligned+0x20>
        *size_return = arena[0].unaligned_size;
300131b0:	6b59      	ldr	r1, [r3, #52]	; 0x34
        arena[0].unaligned_area = NULL;
300131b2:	2200      	movs	r2, #0
        *size_return = arena[0].unaligned_size;
300131b4:	6021      	str	r1, [r4, #0]
        arena[0].unaligned_size = 0;
300131b6:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
}
300131ba:	f85d 4b04 	ldr.w	r4, [r13], #4
300131be:	4770      	bx	r14
    *size_return = PAGE_SIZE;
300131c0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    LTRACEF("pages %zu\n", pages);

    /* allocate from any arena */
    for (uint i = 0; i < NOVM_MAX_ARENAS; i++) {
        if (arena_bitmap & (1U << i)) {
            void *result = novm_alloc_helper(&arena[i], pages);
300131c4:	4618      	mov	r0, r3
300131c6:	2101      	movs	r1, #1
    *size_return = PAGE_SIZE;
300131c8:	6022      	str	r2, [r4, #0]
}
300131ca:	f85d 4b04 	ldr.w	r4, [r13], #4
            void *result = novm_alloc_helper(&arena[i], pages);
300131ce:	f7ff bfa9 	b.w	30013124 <novm_alloc_helper>
300131d2:	bf00      	nop

300131d4 <novm_alloc_pages>:
{
300131d4:	4603      	mov	r3, r0
        if (arena_bitmap & (1U << i)) {
300131d6:	f011 0101 	ands.w	r1, r1, #1
300131da:	d006      	beq.n	300131ea <novm_alloc_pages+0x16>
            void *result = novm_alloc_helper(&arena[i], pages);
300131dc:	f24d 2000 	movw	r0, #53760	; 0xd200
300131e0:	4619      	mov	r1, r3
300131e2:	f2c3 0002 	movt	r0, #12290	; 0x3002
300131e6:	f7ff bf9d 	b.w	30013124 <novm_alloc_helper>
                return result;
        }
    }

    return NULL;
}
300131ea:	4608      	mov	r0, r1
300131ec:	4770      	bx	r14
300131ee:	bf00      	nop

300131f0 <bio_default_read_block>:
}

static ssize_t bio_default_read_block(struct bdev *dev, void *buf, bnum_t block, uint count)
{
    return ERR_NOT_SUPPORTED;
}
300131f0:	f06f 0017 	mvn.w	r0, #23
300131f4:	4770      	bx	r14
300131f6:	bf00      	nop

300131f8 <bio_default_read>:
{
300131f8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300131fc:	4604      	mov	r4, r0
300131fe:	b083      	sub	sp, #12
30013200:	461e      	mov	r6, r3
30013202:	4615      	mov	r5, r2
30013204:	af00      	add	r7, sp, #0
30013206:	4689      	mov	r9, r1
30013208:	4631      	mov	r1, r6
3001320a:	e9c7 5600 	strd	r5, r6, [r7]
3001320e:	4610      	mov	r0, r2
    STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
30013210:	69a5      	ldr	r5, [r4, #24]
30013212:	2300      	movs	r3, #0
30013214:	462a      	mov	r2, r5
30013216:	f105 061f 	add.w	r6, r5, #31
3001321a:	f026 061f 	bic.w	r6, r6, #31
3001321e:	3620      	adds	r6, #32
30013220:	ebad 0d06 	sub.w	r13, r13, r6
30013224:	f006 fdac 	bl	30019d80 <__aeabi_ldivmod>
{
30013228:	f8d7 8030 	ldr.w	r8, [r7, #48]	; 0x30
    STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
3001322c:	f10d 0b1f 	add.w	r11, r13, #31
30013230:	f02b 0b1f 	bic.w	r11, r11, #31
    if ((offset % dev->block_size) != 0) {
30013234:	4313      	orrs	r3, r2
30013236:	d051      	beq.n	300132dc <bio_default_read+0xe4>
    return len;
}

uint bio_trim_block_range(const bdev_t *dev, bnum_t block, uint count)
{
    if (block > dev->block_count)
30013238:	6a23      	ldr	r3, [r4, #32]
3001323a:	4606      	mov	r6, r0
3001323c:	4298      	cmp	r0, r3
3001323e:	f240 808f 	bls.w	30013360 <bio_default_read+0x168>
30013242:	2300      	movs	r3, #0
        } else if ((size_t)err != dev->block_size) {
30013244:	429d      	cmp	r5, r3
30013246:	d142      	bne.n	300132ce <bio_default_read+0xd6>
        size_t block_offset = offset % dev->block_size;
30013248:	e9d7 0100 	ldrd	r0, r1, [r7]
3001324c:	462a      	mov	r2, r5
3001324e:	2300      	movs	r3, #0
        block++;
30013250:	f106 0a01 	add.w	r10, r6, #1
        size_t block_offset = offset % dev->block_size;
30013254:	f006 fd94 	bl	30019d80 <__aeabi_ldivmod>
        memcpy(buf, temp + block_offset, tocopy);
30013258:	4648      	mov	r0, r9
        size_t tocopy = MIN(dev->block_size - block_offset, len);
3001325a:	1aad      	subs	r5, r5, r2
3001325c:	4545      	cmp	r5, r8
3001325e:	bf28      	it	cs
30013260:	4645      	movcs	r5, r8
        memcpy(buf, temp + block_offset, tocopy);
30013262:	eb0b 0102 	add.w	r1, r11, r2
30013266:	462a      	mov	r2, r5
        len -= tocopy;
30013268:	eba8 0805 	sub.w	r8, r8, r5
        memcpy(buf, temp + block_offset, tocopy);
3001326c:	f001 eafa 	blx	30014864 <memcpy>
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_READS) &&
30013270:	6b23      	ldr	r3, [r4, #48]	; 0x30
        buf += tocopy;
30013272:	44a9      	add	r9, r5
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_READS) &&
30013274:	07db      	lsls	r3, r3, #31
30013276:	d536      	bpl.n	300132e6 <bio_default_read+0xee>
30013278:	f019 0f1f 	tst.w	r9, #31
3001327c:	d033      	beq.n	300132e6 <bio_default_read+0xee>
        while (len >= dev->block_size) {
3001327e:	69a2      	ldr	r2, [r4, #24]
30013280:	4590      	cmp	r8, r2
30013282:	d21e      	bcs.n	300132c2 <bio_default_read+0xca>
30013284:	e04b      	b.n	3001331e <bio_default_read+0x126>
        return 0;
    if (count == 0)
        return 0;
    if (block + count > dev->block_count)
30013286:	f10a 0101 	add.w	r1, r10, #1
3001328a:	428b      	cmp	r3, r1
3001328c:	bf28      	it	cs
3001328e:	2301      	movcs	r3, #1
30013290:	d375      	bcc.n	3001337e <bio_default_read+0x186>
    /* range check */
    count = bio_trim_block_range(dev, block, count);
    if (count == 0)
        return 0;

    return dev->read_block(dev, buf, block, count);
30013292:	4652      	mov	r2, r10
30013294:	4659      	mov	r1, r11
30013296:	6ba6      	ldr	r6, [r4, #56]	; 0x38
30013298:	4620      	mov	r0, r4
3001329a:	47b0      	blx	r6
            if (err < 0) {
3001329c:	2800      	cmp	r0, #0
3001329e:	f2c0 8083 	blt.w	300133a8 <bio_default_read+0x1b0>
300132a2:	69a2      	ldr	r2, [r4, #24]
            } else if ((size_t)err != dev->block_size) {
300132a4:	4282      	cmp	r2, r0
300132a6:	d112      	bne.n	300132ce <bio_default_read+0xd6>
            memcpy(buf, temp, dev->block_size);
300132a8:	4648      	mov	r0, r9
300132aa:	4659      	mov	r1, r11
300132ac:	f001 eada 	blx	30014864 <memcpy>
            buf += dev->block_size;
300132b0:	69a2      	ldr	r2, [r4, #24]
            block++;
300132b2:	f10a 0a01 	add.w	r10, r10, #1
            len -= dev->block_size;
300132b6:	eba8 0802 	sub.w	r8, r8, r2
        while (len >= dev->block_size) {
300132ba:	4542      	cmp	r2, r8
            buf += dev->block_size;
300132bc:	4491      	add	r9, r2
            bytes_read += dev->block_size;
300132be:	4415      	add	r5, r2
        while (len >= dev->block_size) {
300132c0:	d82d      	bhi.n	3001331e <bio_default_read+0x126>
    if (block > dev->block_count)
300132c2:	6a23      	ldr	r3, [r4, #32]
300132c4:	459a      	cmp	r10, r3
300132c6:	d9de      	bls.n	30013286 <bio_default_read+0x8e>
300132c8:	2000      	movs	r0, #0
            } else if ((size_t)err != dev->block_size) {
300132ca:	4282      	cmp	r2, r0
300132cc:	d0ec      	beq.n	300132a8 <bio_default_read+0xb0>
            err = ERR_IO;
300132ce:	f06f 0513 	mvn.w	r5, #19
}
300132d2:	4628      	mov	r0, r5
300132d4:	370c      	adds	r7, #12
300132d6:	46bd      	mov	r13, r7
300132d8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_READS) &&
300132dc:	6b23      	ldr	r3, [r4, #48]	; 0x30
300132de:	4682      	mov	r10, r0
    ssize_t bytes_read = 0;
300132e0:	2500      	movs	r5, #0
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_READS) &&
300132e2:	07db      	lsls	r3, r3, #31
300132e4:	d4c8      	bmi.n	30013278 <bio_default_read+0x80>
    if (block > dev->block_count)
300132e6:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    if (count == 0)
300132ea:	fa38 f202 	lsrs.w	r2, r8, r2
300132ee:	603a      	str	r2, [r7, #0]
300132f0:	bf0c      	ite	eq
300132f2:	2201      	moveq	r2, #1
300132f4:	2200      	movne	r2, #0
300132f6:	459a      	cmp	r10, r3
300132f8:	bf88      	it	hi
300132fa:	f042 0201 	orrhi.w	r2, r2, #1
300132fe:	2a00      	cmp	r2, #0
30013300:	d042      	beq.n	30013388 <bio_default_read+0x190>
30013302:	2300      	movs	r3, #0
        return 0;
30013304:	4618      	mov	r0, r3
        } else if ((size_t)err != dev->block_size * num_blocks) {
30013306:	69a2      	ldr	r2, [r4, #24]
30013308:	683e      	ldr	r6, [r7, #0]
3001330a:	4631      	mov	r1, r6
3001330c:	fb02 f101 	mul.w	r1, r2, r1
30013310:	4299      	cmp	r1, r3
30013312:	d1dc      	bne.n	300132ce <bio_default_read+0xd6>
        buf += err;
30013314:	4499      	add	r9, r3
        len -= err;
30013316:	eba8 0803 	sub.w	r8, r8, r3
        bytes_read += err;
3001331a:	4405      	add	r5, r0
        block += num_blocks;
3001331c:	44b2      	add	r10, r6
    if (len > 0) {
3001331e:	f1b8 0f00 	cmp.w	r8, #0
30013322:	d0d6      	beq.n	300132d2 <bio_default_read+0xda>
    if (block > dev->block_count)
30013324:	6a23      	ldr	r3, [r4, #32]
30013326:	459a      	cmp	r10, r3
30013328:	d844      	bhi.n	300133b4 <bio_default_read+0x1bc>
    if (block + count > dev->block_count)
3001332a:	f10a 0101 	add.w	r1, r10, #1
3001332e:	428b      	cmp	r3, r1
30013330:	bf28      	it	cs
30013332:	2301      	movcs	r3, #1
30013334:	d346      	bcc.n	300133c4 <bio_default_read+0x1cc>
    return dev->read_block(dev, buf, block, count);
30013336:	4652      	mov	r2, r10
30013338:	4659      	mov	r1, r11
3001333a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
3001333c:	4620      	mov	r0, r4
3001333e:	47b0      	blx	r6
        if (err < 0) {
30013340:	2800      	cmp	r0, #0
30013342:	db31      	blt.n	300133a8 <bio_default_read+0x1b0>
30013344:	69a2      	ldr	r2, [r4, #24]
        } else if ((size_t)err != dev->block_size) {
30013346:	4282      	cmp	r2, r0
30013348:	d1c1      	bne.n	300132ce <bio_default_read+0xd6>
        memcpy(buf, temp, len);
3001334a:	4659      	mov	r1, r11
3001334c:	4648      	mov	r0, r9
3001334e:	4642      	mov	r2, r8
        bytes_read += len;
30013350:	4445      	add	r5, r8
        memcpy(buf, temp, len);
30013352:	f001 ea88 	blx	30014864 <memcpy>
}
30013356:	4628      	mov	r0, r5
30013358:	370c      	adds	r7, #12
3001335a:	46bd      	mov	r13, r7
3001335c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (block + count > dev->block_count)
30013360:	1c42      	adds	r2, r0, #1
30013362:	4293      	cmp	r3, r2
30013364:	bf28      	it	cs
30013366:	2301      	movcs	r3, #1
30013368:	d328      	bcc.n	300133bc <bio_default_read+0x1c4>
    return dev->read_block(dev, buf, block, count);
3001336a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
3001336c:	4632      	mov	r2, r6
3001336e:	4659      	mov	r1, r11
30013370:	4620      	mov	r0, r4
30013372:	47a8      	blx	r5
        if (err < 0) {
30013374:	1e05      	subs	r5, r0, #0
30013376:	dbac      	blt.n	300132d2 <bio_default_read+0xda>
30013378:	462b      	mov	r3, r5
3001337a:	69a5      	ldr	r5, [r4, #24]
3001337c:	e762      	b.n	30013244 <bio_default_read+0x4c>
    if (count == 0)
3001337e:	ebb3 030a 	subs.w	r3, r3, r10
30013382:	d186      	bne.n	30013292 <bio_default_read+0x9a>
30013384:	4618      	mov	r0, r3
30013386:	e78d      	b.n	300132a4 <bio_default_read+0xac>
    if (block + count > dev->block_count)
30013388:	683a      	ldr	r2, [r7, #0]
3001338a:	4452      	add	r2, r10
3001338c:	4293      	cmp	r3, r2
3001338e:	d213      	bcs.n	300133b8 <bio_default_read+0x1c0>
    if (count == 0)
30013390:	ebb3 030a 	subs.w	r3, r3, r10
30013394:	d0b6      	beq.n	30013304 <bio_default_read+0x10c>
    return dev->read_block(dev, buf, block, count);
30013396:	4652      	mov	r2, r10
30013398:	4649      	mov	r1, r9
3001339a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
3001339c:	4620      	mov	r0, r4
3001339e:	47b0      	blx	r6
        if (err < 0) {
300133a0:	2800      	cmp	r0, #0
300133a2:	bfa8      	it	ge
300133a4:	4603      	movge	r3, r0
300133a6:	daae      	bge.n	30013306 <bio_default_read+0x10e>
err:
300133a8:	4605      	mov	r5, r0
}
300133aa:	370c      	adds	r7, #12
300133ac:	4628      	mov	r0, r5
300133ae:	46bd      	mov	r13, r7
300133b0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (block > dev->block_count)
300133b4:	2000      	movs	r0, #0
300133b6:	e7c6      	b.n	30013346 <bio_default_read+0x14e>
    if (block + count > dev->block_count)
300133b8:	683b      	ldr	r3, [r7, #0]
300133ba:	e7ec      	b.n	30013396 <bio_default_read+0x19e>
    if (count == 0)
300133bc:	1a1b      	subs	r3, r3, r0
300133be:	f43f af41 	beq.w	30013244 <bio_default_read+0x4c>
300133c2:	e7d2      	b.n	3001336a <bio_default_read+0x172>
300133c4:	ebb3 030a 	subs.w	r3, r3, r10
300133c8:	d1b5      	bne.n	30013336 <bio_default_read+0x13e>
300133ca:	4618      	mov	r0, r3
300133cc:	e7bb      	b.n	30013346 <bio_default_read+0x14e>
300133ce:	bf00      	nop

300133d0 <bio_default_write>:
{
300133d0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300133d4:	4604      	mov	r4, r0
300133d6:	b083      	sub	sp, #12
300133d8:	461e      	mov	r6, r3
300133da:	4615      	mov	r5, r2
300133dc:	af00      	add	r7, sp, #0
300133de:	4688      	mov	r8, r1
300133e0:	4631      	mov	r1, r6
300133e2:	e9c7 5600 	strd	r5, r6, [r7]
300133e6:	4610      	mov	r0, r2
    STACKBUF_DMA_ALIGN(temp, dev->block_size); // temporary buffer for partial block transfers
300133e8:	69a5      	ldr	r5, [r4, #24]
300133ea:	2300      	movs	r3, #0
300133ec:	462a      	mov	r2, r5
300133ee:	f105 061f 	add.w	r6, r5, #31
300133f2:	f026 061f 	bic.w	r6, r6, #31
300133f6:	3620      	adds	r6, #32
300133f8:	ebad 0d06 	sub.w	r13, r13, r6
300133fc:	f006 fcc0 	bl	30019d80 <__aeabi_ldivmod>
30013400:	f10d 091f 	add.w	r9, r13, #31
30013404:	f029 091f 	bic.w	r9, r9, #31
    if ((offset % dev->block_size) != 0) {
30013408:	4313      	orrs	r3, r2
3001340a:	d078      	beq.n	300134fe <bio_default_write+0x12e>
    if (block > dev->block_count)
3001340c:	6a23      	ldr	r3, [r4, #32]
3001340e:	4606      	mov	r6, r0
30013410:	4298      	cmp	r0, r3
30013412:	f240 80cd 	bls.w	300135b0 <bio_default_write+0x1e0>
30013416:	2300      	movs	r3, #0
        } else if ((size_t)err != dev->block_size) {
30013418:	429d      	cmp	r5, r3
3001341a:	f040 80df 	bne.w	300135dc <bio_default_write+0x20c>
        size_t block_offset = offset % dev->block_size;
3001341e:	e9d7 0100 	ldrd	r0, r1, [r7]
30013422:	462a      	mov	r2, r5
30013424:	2300      	movs	r3, #0
30013426:	f006 fcab 	bl	30019d80 <__aeabi_ldivmod>
        size_t tocopy = MIN(dev->block_size - block_offset, len);
3001342a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        memcpy(temp + block_offset, buf, tocopy);
3001342c:	4641      	mov	r1, r8
        size_t tocopy = MIN(dev->block_size - block_offset, len);
3001342e:	eba5 0a02 	sub.w	r10, r5, r2
30013432:	459a      	cmp	r10, r3
30013434:	bf28      	it	cs
30013436:	469a      	movcs	r10, r3
        memcpy(temp + block_offset, buf, tocopy);
30013438:	eb09 0002 	add.w	r0, r9, r2
3001343c:	4652      	mov	r2, r10
3001343e:	f001 ea12 	blx	30014864 <memcpy>
    if (block > dev->block_count)
30013442:	6a23      	ldr	r3, [r4, #32]
30013444:	429e      	cmp	r6, r3
30013446:	f200 80d0 	bhi.w	300135ea <bio_default_write+0x21a>
    if (block + count > dev->block_count)
3001344a:	1c72      	adds	r2, r6, #1
3001344c:	4293      	cmp	r3, r2
3001344e:	bf28      	it	cs
30013450:	2301      	movcs	r3, #1
30013452:	f0c0 80f3 	bcc.w	3001363c <bio_default_write+0x26c>
    /* range check */
    count = bio_trim_block_range(dev, block, count);
    if (count == 0)
        return 0;

    return dev->write_block(dev, buf, block, count);
30013456:	6c25      	ldr	r5, [r4, #64]	; 0x40
30013458:	4632      	mov	r2, r6
3001345a:	4649      	mov	r1, r9
3001345c:	4620      	mov	r0, r4
3001345e:	47a8      	blx	r5
        if (err < 0) {
30013460:	1e05      	subs	r5, r0, #0
30013462:	f2c0 80a0 	blt.w	300135a6 <bio_default_write+0x1d6>
30013466:	462b      	mov	r3, r5
30013468:	69a5      	ldr	r5, [r4, #24]
        } else if ((size_t)err != dev->block_size) {
3001346a:	42ab      	cmp	r3, r5
3001346c:	f040 80b6 	bne.w	300135dc <bio_default_write+0x20c>
        len -= tocopy;
30013470:	6b3b      	ldr	r3, [r7, #48]	; 0x30
        buf += tocopy;
30013472:	44d0      	add	r8, r10
        bytes_written += tocopy;
30013474:	4655      	mov	r5, r10
        len -= tocopy;
30013476:	eba3 030a 	sub.w	r3, r3, r10
        block++;
3001347a:	f106 0a01 	add.w	r10, r6, #1
        len -= tocopy;
3001347e:	633b      	str	r3, [r7, #48]	; 0x30
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_WRITES) &&
30013480:	6b23      	ldr	r3, [r4, #48]	; 0x30
30013482:	079b      	lsls	r3, r3, #30
30013484:	d540      	bpl.n	30013508 <bio_default_write+0x138>
30013486:	f018 0f1f 	tst.w	r8, #31
3001348a:	d03d      	beq.n	30013508 <bio_default_write+0x138>
        while (len >= dev->block_size) {
3001348c:	69a2      	ldr	r2, [r4, #24]
3001348e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
30013490:	4616      	mov	r6, r2
30013492:	4293      	cmp	r3, r2
30013494:	f0c0 80cb 	bcc.w	3001362e <bio_default_write+0x25e>
30013498:	6a26      	ldr	r6, [r4, #32]
            memcpy(temp, buf, dev->block_size);
3001349a:	4641      	mov	r1, r8
3001349c:	4648      	mov	r0, r9
3001349e:	f001 e9e2 	blx	30014864 <memcpy>
    if (block > dev->block_count)
300134a2:	45b2      	cmp	r10, r6
300134a4:	d824      	bhi.n	300134f0 <bio_default_write+0x120>
300134a6:	f10a 0b01 	add.w	r11, r10, #1
    if (block + count > dev->block_count)
300134aa:	45b3      	cmp	r11, r6
300134ac:	f8c7 b000 	str.w	r11, [r7]
300134b0:	bf98      	it	ls
300134b2:	2301      	movls	r3, #1
300134b4:	f200 808b 	bhi.w	300135ce <bio_default_write+0x1fe>
    return dev->write_block(dev, buf, block, count);
300134b8:	4652      	mov	r2, r10
300134ba:	4649      	mov	r1, r9
300134bc:	6c26      	ldr	r6, [r4, #64]	; 0x40
300134be:	4620      	mov	r0, r4
300134c0:	47b0      	blx	r6
            if (err < 0) {
300134c2:	2800      	cmp	r0, #0
300134c4:	f2c0 80a3 	blt.w	3001360e <bio_default_write+0x23e>
            } else if ((size_t)err != dev->block_size) {
300134c8:	69a6      	ldr	r6, [r4, #24]
300134ca:	4632      	mov	r2, r6
300134cc:	4286      	cmp	r6, r0
300134ce:	f040 8085 	bne.w	300135dc <bio_default_write+0x20c>
            len -= dev->block_size;
300134d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
            buf += dev->block_size;
300134d4:	44b0      	add	r8, r6
            bytes_written += dev->block_size;
300134d6:	4435      	add	r5, r6
            len -= dev->block_size;
300134d8:	1b9b      	subs	r3, r3, r6
        while (len >= dev->block_size) {
300134da:	429e      	cmp	r6, r3
            len -= dev->block_size;
300134dc:	633b      	str	r3, [r7, #48]	; 0x30
        while (len >= dev->block_size) {
300134de:	d830      	bhi.n	30013542 <bio_default_write+0x172>
300134e0:	6a26      	ldr	r6, [r4, #32]
300134e2:	46da      	mov	r10, r11
            memcpy(temp, buf, dev->block_size);
300134e4:	4641      	mov	r1, r8
300134e6:	4648      	mov	r0, r9
300134e8:	f001 e9bc 	blx	30014864 <memcpy>
    if (block > dev->block_count)
300134ec:	45b2      	cmp	r10, r6
300134ee:	d9da      	bls.n	300134a6 <bio_default_write+0xd6>
            } else if ((size_t)err != dev->block_size) {
300134f0:	69a2      	ldr	r2, [r4, #24]
300134f2:	2a00      	cmp	r2, #0
300134f4:	d172      	bne.n	300135dc <bio_default_write+0x20c>
300134f6:	f10a 0b01 	add.w	r11, r10, #1
300134fa:	46da      	mov	r10, r11
300134fc:	e7f2      	b.n	300134e4 <bio_default_write+0x114>
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_WRITES) &&
300134fe:	6b23      	ldr	r3, [r4, #48]	; 0x30
30013500:	4682      	mov	r10, r0
    ssize_t bytes_written = 0;
30013502:	2500      	movs	r5, #0
        (dev->flags & BIO_FLAG_CACHE_ALIGNED_WRITES) &&
30013504:	079b      	lsls	r3, r3, #30
30013506:	d4be      	bmi.n	30013486 <bio_default_write+0xb6>
    if (count == 0)
30013508:	6b39      	ldr	r1, [r7, #48]	; 0x30
    if (block > dev->block_count)
3001350a:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    if (count == 0)
3001350e:	fa31 fb02 	lsrs.w	r11, r1, r2
30013512:	bf0c      	ite	eq
30013514:	2201      	moveq	r2, #1
30013516:	2200      	movne	r2, #0
30013518:	459a      	cmp	r10, r3
3001351a:	bf88      	it	hi
3001351c:	f042 0201 	orrhi.w	r2, r2, #1
30013520:	2a00      	cmp	r2, #0
30013522:	d064      	beq.n	300135ee <bio_default_write+0x21e>
30013524:	2300      	movs	r3, #0
        return 0;
30013526:	4618      	mov	r0, r3
        } else if ((size_t)err != dev->block_size * block_count) {
30013528:	69a6      	ldr	r6, [r4, #24]
3001352a:	fb06 f20b 	mul.w	r2, r6, r11
3001352e:	429a      	cmp	r2, r3
30013530:	d154      	bne.n	300135dc <bio_default_write+0x20c>
        len -= err;
30013532:	6b3a      	ldr	r2, [r7, #48]	; 0x30
        buf += err;
30013534:	4498      	add	r8, r3
        bytes_written += err;
30013536:	4405      	add	r5, r0
        len -= err;
30013538:	1ad3      	subs	r3, r2, r3
3001353a:	633b      	str	r3, [r7, #48]	; 0x30
        block += block_count;
3001353c:	eb0a 030b 	add.w	r3, r10, r11
30013540:	603b      	str	r3, [r7, #0]
    if (len > 0) {
30013542:	6b3b      	ldr	r3, [r7, #48]	; 0x30
30013544:	2b00      	cmp	r3, #0
30013546:	d02e      	beq.n	300135a6 <bio_default_write+0x1d6>
    if (block > dev->block_count)
30013548:	683a      	ldr	r2, [r7, #0]
3001354a:	6a23      	ldr	r3, [r4, #32]
3001354c:	4611      	mov	r1, r2
3001354e:	429a      	cmp	r2, r3
30013550:	d863      	bhi.n	3001361a <bio_default_write+0x24a>
    if (block + count > dev->block_count)
30013552:	3201      	adds	r2, #1
30013554:	4293      	cmp	r3, r2
30013556:	bf28      	it	cs
30013558:	2301      	movcs	r3, #1
3001355a:	d373      	bcc.n	30013644 <bio_default_write+0x274>
    return dev->read_block(dev, buf, block, count);
3001355c:	683a      	ldr	r2, [r7, #0]
3001355e:	4649      	mov	r1, r9
30013560:	6ba6      	ldr	r6, [r4, #56]	; 0x38
30013562:	4620      	mov	r0, r4
30013564:	47b0      	blx	r6
        if (err < 0) {
30013566:	2800      	cmp	r0, #0
30013568:	db51      	blt.n	3001360e <bio_default_write+0x23e>
3001356a:	69a6      	ldr	r6, [r4, #24]
        } else if ((size_t)err != dev->block_size) {
3001356c:	4286      	cmp	r6, r0
3001356e:	d135      	bne.n	300135dc <bio_default_write+0x20c>
        memcpy(temp, buf, len);
30013570:	6b3a      	ldr	r2, [r7, #48]	; 0x30
30013572:	4641      	mov	r1, r8
30013574:	4648      	mov	r0, r9
30013576:	f001 e976 	blx	30014864 <memcpy>
    if (block > dev->block_count)
3001357a:	6a23      	ldr	r3, [r4, #32]
3001357c:	683a      	ldr	r2, [r7, #0]
3001357e:	429a      	cmp	r2, r3
30013580:	d850      	bhi.n	30013624 <bio_default_write+0x254>
    if (block + count > dev->block_count)
30013582:	683a      	ldr	r2, [r7, #0]
30013584:	3201      	adds	r2, #1
30013586:	4293      	cmp	r3, r2
30013588:	bf28      	it	cs
3001358a:	2301      	movcs	r3, #1
3001358c:	d347      	bcc.n	3001361e <bio_default_write+0x24e>
    return dev->write_block(dev, buf, block, count);
3001358e:	683a      	ldr	r2, [r7, #0]
30013590:	4649      	mov	r1, r9
30013592:	6c26      	ldr	r6, [r4, #64]	; 0x40
30013594:	4620      	mov	r0, r4
30013596:	47b0      	blx	r6
        if (err < 0) {
30013598:	2800      	cmp	r0, #0
3001359a:	db38      	blt.n	3001360e <bio_default_write+0x23e>
        } else if ((size_t)err != dev->block_size) {
3001359c:	69a3      	ldr	r3, [r4, #24]
3001359e:	4283      	cmp	r3, r0
300135a0:	d11c      	bne.n	300135dc <bio_default_write+0x20c>
        bytes_written += len;
300135a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
300135a4:	441d      	add	r5, r3
}
300135a6:	4628      	mov	r0, r5
300135a8:	370c      	adds	r7, #12
300135aa:	46bd      	mov	r13, r7
300135ac:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (block + count > dev->block_count)
300135b0:	1c42      	adds	r2, r0, #1
300135b2:	4293      	cmp	r3, r2
300135b4:	bf28      	it	cs
300135b6:	2301      	movcs	r3, #1
300135b8:	d33c      	bcc.n	30013634 <bio_default_write+0x264>
    return dev->read_block(dev, buf, block, count);
300135ba:	6ba5      	ldr	r5, [r4, #56]	; 0x38
300135bc:	4632      	mov	r2, r6
300135be:	4649      	mov	r1, r9
300135c0:	4620      	mov	r0, r4
300135c2:	47a8      	blx	r5
        if (err < 0) {
300135c4:	1e05      	subs	r5, r0, #0
300135c6:	dbee      	blt.n	300135a6 <bio_default_write+0x1d6>
300135c8:	462b      	mov	r3, r5
300135ca:	69a5      	ldr	r5, [r4, #24]
300135cc:	e724      	b.n	30013418 <bio_default_write+0x48>
    if (count == 0)
300135ce:	ebb6 030a 	subs.w	r3, r6, r10
300135d2:	f47f af71 	bne.w	300134b8 <bio_default_write+0xe8>
            } else if ((size_t)err != dev->block_size) {
300135d6:	69a2      	ldr	r2, [r4, #24]
300135d8:	2a00      	cmp	r2, #0
300135da:	d081      	beq.n	300134e0 <bio_default_write+0x110>
            err = ERR_IO;
300135dc:	f06f 0513 	mvn.w	r5, #19
}
300135e0:	4628      	mov	r0, r5
300135e2:	370c      	adds	r7, #12
300135e4:	46bd      	mov	r13, r7
300135e6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (block > dev->block_count)
300135ea:	2300      	movs	r3, #0
300135ec:	e73d      	b.n	3001346a <bio_default_write+0x9a>
    if (block + count > dev->block_count)
300135ee:	eb0a 020b 	add.w	r2, r10, r11
300135f2:	4293      	cmp	r3, r2
300135f4:	d219      	bcs.n	3001362a <bio_default_write+0x25a>
    if (count == 0)
300135f6:	ebb3 030a 	subs.w	r3, r3, r10
300135fa:	d094      	beq.n	30013526 <bio_default_write+0x156>
    return dev->write_block(dev, buf, block, count);
300135fc:	4652      	mov	r2, r10
300135fe:	4641      	mov	r1, r8
30013600:	6c26      	ldr	r6, [r4, #64]	; 0x40
30013602:	4620      	mov	r0, r4
30013604:	47b0      	blx	r6
        if (err < 0) {
30013606:	2800      	cmp	r0, #0
30013608:	bfa8      	it	ge
3001360a:	4603      	movge	r3, r0
3001360c:	da8c      	bge.n	30013528 <bio_default_write+0x158>
err:
3001360e:	4605      	mov	r5, r0
}
30013610:	370c      	adds	r7, #12
30013612:	4628      	mov	r0, r5
30013614:	46bd      	mov	r13, r7
30013616:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (block > dev->block_count)
3001361a:	2000      	movs	r0, #0
3001361c:	e7a6      	b.n	3001356c <bio_default_write+0x19c>
    if (count == 0)
3001361e:	683a      	ldr	r2, [r7, #0]
30013620:	1a9b      	subs	r3, r3, r2
30013622:	d1b4      	bne.n	3001358e <bio_default_write+0x1be>
        } else if ((size_t)err != dev->block_size) {
30013624:	2e00      	cmp	r6, #0
30013626:	d0bc      	beq.n	300135a2 <bio_default_write+0x1d2>
30013628:	e7d8      	b.n	300135dc <bio_default_write+0x20c>
    if (block + count > dev->block_count)
3001362a:	465b      	mov	r3, r11
3001362c:	e7e6      	b.n	300135fc <bio_default_write+0x22c>
        while (len >= dev->block_size) {
3001362e:	f8c7 a000 	str.w	r10, [r7]
30013632:	e786      	b.n	30013542 <bio_default_write+0x172>
    if (count == 0)
30013634:	1a1b      	subs	r3, r3, r0
30013636:	f43f aeef 	beq.w	30013418 <bio_default_write+0x48>
3001363a:	e7be      	b.n	300135ba <bio_default_write+0x1ea>
    if (count == 0)
3001363c:	1b9b      	subs	r3, r3, r6
3001363e:	f43f af14 	beq.w	3001346a <bio_default_write+0x9a>
30013642:	e708      	b.n	30013456 <bio_default_write+0x86>
    if (count == 0)
30013644:	1a5b      	subs	r3, r3, r1
30013646:	d189      	bne.n	3001355c <bio_default_write+0x18c>
30013648:	4618      	mov	r0, r3
3001364a:	e78f      	b.n	3001356c <bio_default_write+0x19c>

3001364c <bdev_dec_ref>:
{
3001364c:	b538      	push	{r3, r4, r5, r14}
    int old;
    int temp;
    int test;

    do {
        __asm__ volatile(
3001364e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    int oldval = atomic_add(&dev->ref, -1);
30013652:	f100 0308 	add.w	r3, r0, #8
30013656:	e853 4f00 	ldrex	r4, [r3]
3001365a:	18a5      	adds	r5, r4, r2
3001365c:	e843 5100 	strex	r1, r5, [r3]
            "strex	%[test], %[temp], [%[ptr]]\n"
            : [old]"=&r" (old), [temp]"=&r" (temp), [test]"=&r" (test)
            : [ptr]"r" (ptr), [val]"r" (val)
            : "memory", "cc");

    } while (test != 0);
30013660:	2900      	cmp	r1, #0
30013662:	d1f8      	bne.n	30013656 <bdev_dec_ref+0xa>
    if (oldval == 1) {
30013664:	2c01      	cmp	r4, #1
30013666:	d000      	beq.n	3001366a <bdev_dec_ref+0x1e>
}
30013668:	bd38      	pop	{r3, r4, r5, r15}
3001366a:	4604      	mov	r4, r0
        TRACEF("last ref, removing (%s)\n", dev->name);
3001366c:	f640 7160 	movw	r1, #3936	; 0xf60
30013670:	f640 7070 	movw	r0, #3952	; 0xf70
30013674:	f2c3 0102 	movt	r1, #12290	; 0x3002
30013678:	f44f 729e 	mov.w	r2, #316	; 0x13c
3001367c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30013680:	68e3      	ldr	r3, [r4, #12]
30013682:	f002 fa95 	bl	30015bb0 <_printf>
        if (dev->close)
30013686:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
30013688:	b10b      	cbz	r3, 3001368e <bdev_dec_ref+0x42>
            dev->close(dev);
3001368a:	4620      	mov	r0, r4
3001368c:	4798      	blx	r3
        free(dev->name);
3001368e:	68e0      	ldr	r0, [r4, #12]
}
30013690:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
        free(dev->name);
30013694:	f001 b87a 	b.w	3001478c <free>

30013698 <bio_default_write_block>:
30013698:	f06f 0017 	mvn.w	r0, #23
3001369c:	4770      	bx	r14
3001369e:	bf00      	nop

300136a0 <bio_write.part.2>:
ssize_t bio_write(bdev_t *dev, const void *buf, off_t offset, size_t len)
300136a0:	e92d 03f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9}
    if (offset >= dev->total_size)
300136a4:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
ssize_t bio_write(bdev_t *dev, const void *buf, off_t offset, size_t len)
300136a8:	4614      	mov	r4, r2
300136aa:	9a06      	ldr	r2, [sp, #24]
300136ac:	461d      	mov	r5, r3
    if (offset >= dev->total_size)
300136ae:	42b4      	cmp	r4, r6
300136b0:	41bb      	sbcs	r3, r7
300136b2:	bfac      	ite	ge
300136b4:	2301      	movge	r3, #1
300136b6:	2300      	movlt	r3, #0
    if (len == 0)
300136b8:	2a00      	cmp	r2, #0
300136ba:	bf08      	it	eq
300136bc:	2301      	moveq	r3, #1
300136be:	b11b      	cbz	r3, 300136c8 <bio_write.part.2+0x28>
}
300136c0:	2000      	movs	r0, #0
300136c2:	e8bd 03f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9}
300136c6:	4770      	bx	r14
    if (offset + len > dev->total_size)
300136c8:	eb14 0802 	adds.w	r8, r4, r2
300136cc:	f145 0900 	adc.w	r9, r5, #0
300136d0:	4546      	cmp	r6, r8
300136d2:	eb77 0309 	sbcs.w	r3, r7, r9
300136d6:	da01      	bge.n	300136dc <bio_write.part.2+0x3c>
    if (len == 0)
300136d8:	1b32      	subs	r2, r6, r4
300136da:	d0f1      	beq.n	300136c0 <bio_write.part.2+0x20>
    return dev->write(dev, buf, offset, len);
300136dc:	9206      	str	r2, [sp, #24]
300136de:	4622      	mov	r2, r4
300136e0:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
300136e2:	462b      	mov	r3, r5
300136e4:	46a4      	mov	r12, r4
}
300136e6:	e8bd 03f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9}
    return dev->write(dev, buf, offset, len);
300136ea:	4760      	bx	r12

300136ec <bio_default_erase>:
{
300136ec:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300136f0:	4699      	mov	r9, r3
300136f2:	b083      	sub	sp, #12
    STACKBUF_DMA_ALIGN(erase_buf, dev->block_size);
300136f4:	6984      	ldr	r4, [r0, #24]
{
300136f6:	af02      	add	r7, sp, #8
    memset(erase_buf, dev->erase_byte, dev->block_size);
300136f8:	f890 102c 	ldrb.w	r1, [r0, #44]	; 0x2c
{
300136fc:	4606      	mov	r6, r0
    STACKBUF_DMA_ALIGN(erase_buf, dev->block_size);
300136fe:	f104 031f 	add.w	r3, r4, #31
{
30013702:	4690      	mov	r8, r2
    STACKBUF_DMA_ALIGN(erase_buf, dev->block_size);
30013704:	f023 031f 	bic.w	r3, r3, #31
{
30013708:	6abd      	ldr	r5, [r7, #40]	; 0x28
    STACKBUF_DMA_ALIGN(erase_buf, dev->block_size);
3001370a:	3320      	adds	r3, #32
    memset(erase_buf, dev->erase_byte, dev->block_size);
3001370c:	4622      	mov	r2, r4
    STACKBUF_DMA_ALIGN(erase_buf, dev->block_size);
3001370e:	ebad 0d03 	sub.w	r13, r13, r3
30013712:	f10d 0a27 	add.w	r10, r13, #39	; 0x27
30013716:	f02a 0a1f 	bic.w	r10, r10, #31
    memset(erase_buf, dev->erase_byte, dev->block_size);
3001371a:	4650      	mov	r0, r10
3001371c:	f001 e928 	blx	30014970 <memset>
    while (remaining > 0) {
30013720:	b35d      	cbz	r5, 3001377a <bio_default_erase+0x8e>
    ssize_t erased = 0;
30013722:	f04f 0b00 	mov.w	r11, #0
30013726:	e001      	b.n	3001372c <bio_default_erase+0x40>
        if ((size_t)written < towrite)
30013728:	b9e4      	cbnz	r4, 30013764 <bio_default_erase+0x78>
3001372a:	69b4      	ldr	r4, [r6, #24]
3001372c:	4642      	mov	r2, r8
        size_t towrite = MIN(remaining, dev->block_size);
3001372e:	42ac      	cmp	r4, r5
30013730:	bf28      	it	cs
30013732:	462c      	movcs	r4, r5
    if (offset < 0)
30013734:	f1b8 0f00 	cmp.w	r8, #0
30013738:	464b      	mov	r3, r9
3001373a:	f179 0c00 	sbcs.w	r12, r9, #0
3001373e:	4651      	mov	r1, r10
30013740:	4630      	mov	r0, r6
30013742:	dbf1      	blt.n	30013728 <bio_default_erase+0x3c>
30013744:	9400      	str	r4, [sp, #0]
30013746:	f7ff ffab 	bl	300136a0 <bio_write.part.2>
        if (written < 0)
3001374a:	2800      	cmp	r0, #0
3001374c:	eba5 0500 	sub.w	r5, r5, r0
30013750:	4483      	add	r11, r0
30013752:	db0c      	blt.n	3001376e <bio_default_erase+0x82>
30013754:	eb18 0800 	adds.w	r8, r8, r0
30013758:	eb49 79e0 	adc.w	r9, r9, r0, asr #31
        if ((size_t)written < towrite)
3001375c:	4284      	cmp	r4, r0
3001375e:	d801      	bhi.n	30013764 <bio_default_erase+0x78>
    while (remaining > 0) {
30013760:	2d00      	cmp	r5, #0
30013762:	d1e2      	bne.n	3001372a <bio_default_erase+0x3e>
}
30013764:	4658      	mov	r0, r11
30013766:	3704      	adds	r7, #4
30013768:	46bd      	mov	r13, r7
3001376a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
3001376e:	4683      	mov	r11, r0
30013770:	3704      	adds	r7, #4
30013772:	4658      	mov	r0, r11
30013774:	46bd      	mov	r13, r7
30013776:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ssize_t erased = 0;
3001377a:	46ab      	mov	r11, r5
3001377c:	e7f2      	b.n	30013764 <bio_default_erase+0x78>
3001377e:	bf00      	nop

30013780 <bio_open>:
{
30013780:	b570      	push	{r4, r5, r6, r14}
30013782:	f245 4500 	movw	r5, #21504	; 0x5400
30013786:	4606      	mov	r6, r0
30013788:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3001378c:	f2c3 0502 	movt	r5, #12290	; 0x3002
30013790:	f105 0008 	add.w	r0, r5, #8
30013794:	f7fe f94a 	bl	30011a2c <mutex_acquire_timeout>
    list_for_every_entry(&bdevs.list, entry, bdev_t, node) {
30013798:	686c      	ldr	r4, [r5, #4]
3001379a:	42ac      	cmp	r4, r5
3001379c:	d103      	bne.n	300137a6 <bio_open+0x26>
3001379e:	e017      	b.n	300137d0 <bio_open+0x50>
300137a0:	6864      	ldr	r4, [r4, #4]
300137a2:	42ac      	cmp	r4, r5
300137a4:	d014      	beq.n	300137d0 <bio_open+0x50>
        if (!strcmp(entry->name, name)) {
300137a6:	68e0      	ldr	r0, [r4, #12]
300137a8:	4631      	mov	r1, r6
300137aa:	f002 fa4f 	bl	30015c4c <strcmp>
300137ae:	2800      	cmp	r0, #0
300137b0:	d1f6      	bne.n	300137a0 <bio_open+0x20>
        __asm__ volatile(
300137b2:	2301      	movs	r3, #1
    atomic_add(&dev->ref, 1);
300137b4:	f104 0208 	add.w	r2, r4, #8
300137b8:	e852 0f00 	ldrex	r0, [r2]
300137bc:	18c5      	adds	r5, r0, r3
300137be:	e842 5100 	strex	r1, r5, [r2]
    } while (test != 0);
300137c2:	2900      	cmp	r1, #0
300137c4:	d1f8      	bne.n	300137b8 <bio_open+0x38>
    mutex_release(&bdevs.lock);
300137c6:	4805      	ldr	r0, [pc, #20]	; (300137dc <bio_open+0x5c>)
300137c8:	f7fe f95c 	bl	30011a84 <mutex_release>
}
300137cc:	4620      	mov	r0, r4
300137ce:	bd70      	pop	{r4, r5, r6, r15}
    mutex_release(&bdevs.lock);
300137d0:	4802      	ldr	r0, [pc, #8]	; (300137dc <bio_open+0x5c>)
    bdev_t *bdev = NULL;
300137d2:	2400      	movs	r4, #0
    mutex_release(&bdevs.lock);
300137d4:	f7fe f956 	bl	30011a84 <mutex_release>
}
300137d8:	4620      	mov	r0, r4
300137da:	bd70      	pop	{r4, r5, r6, r15}
300137dc:	30025408 	.word	0x30025408

300137e0 <bio_close>:
    bdev_dec_ref(dev);
300137e0:	f7ff bf34 	b.w	3001364c <bdev_dec_ref>

300137e4 <bio_read>:
    if (offset < 0)
300137e4:	2a00      	cmp	r2, #0
{
300137e6:	e92d 03f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9}
300137ea:	9d06      	ldr	r5, [sp, #24]
    if (offset < 0)
300137ec:	f173 0400 	sbcs.w	r4, r3, #0
300137f0:	db0b      	blt.n	3001380a <bio_read+0x26>
    if (offset >= dev->total_size)
300137f2:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
300137f6:	42b2      	cmp	r2, r6
300137f8:	eb73 0407 	sbcs.w	r4, r3, r7
300137fc:	bfac      	ite	ge
300137fe:	2401      	movge	r4, #1
30013800:	2400      	movlt	r4, #0
    if (len == 0)
30013802:	2d00      	cmp	r5, #0
30013804:	bf08      	it	eq
30013806:	2401      	moveq	r4, #1
30013808:	b11c      	cbz	r4, 30013812 <bio_read+0x2e>
}
3001380a:	2000      	movs	r0, #0
3001380c:	e8bd 03f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9}
30013810:	4770      	bx	r14
    if (offset + len > dev->total_size)
30013812:	eb12 0805 	adds.w	r8, r2, r5
30013816:	f143 0900 	adc.w	r9, r3, #0
3001381a:	4546      	cmp	r6, r8
3001381c:	eb77 0409 	sbcs.w	r4, r7, r9
30013820:	da01      	bge.n	30013826 <bio_read+0x42>
    if (len == 0)
30013822:	1ab5      	subs	r5, r6, r2
30013824:	d0f1      	beq.n	3001380a <bio_read+0x26>
    return dev->read(dev, buf, offset, len);
30013826:	9506      	str	r5, [sp, #24]
30013828:	6b44      	ldr	r4, [r0, #52]	; 0x34
3001382a:	46a4      	mov	r12, r4
}
3001382c:	e8bd 03f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9}
    return dev->read(dev, buf, offset, len);
30013830:	4760      	bx	r12
30013832:	bf00      	nop

30013834 <bio_write>:
    if (offset < 0)
30013834:	2a00      	cmp	r2, #0
30013836:	f173 0c00 	sbcs.w	r12, r3, #0
3001383a:	db01      	blt.n	30013840 <bio_write+0xc>
3001383c:	f7ff bf30 	b.w	300136a0 <bio_write.part.2>
}
30013840:	2000      	movs	r0, #0
30013842:	4770      	bx	r14

30013844 <bio_write_block>:
{
30013844:	b430      	push	{r4, r5}
30013846:	4605      	mov	r5, r0
    if (count == 0)
30013848:	fab3 f083 	clz	r0, r3
3001384c:	0940      	lsrs	r0, r0, #5
    if (block > dev->block_count)
3001384e:	6a2c      	ldr	r4, [r5, #32]
    if (count == 0)
30013850:	42a2      	cmp	r2, r4
30013852:	bf88      	it	hi
30013854:	f040 0001 	orrhi.w	r0, r0, #1
30013858:	b110      	cbz	r0, 30013860 <bio_write_block+0x1c>
}
3001385a:	2000      	movs	r0, #0
3001385c:	bc30      	pop	{r4, r5}
3001385e:	4770      	bx	r14
    if (block + count > dev->block_count)
30013860:	18d0      	adds	r0, r2, r3
30013862:	4284      	cmp	r4, r0
30013864:	d201      	bcs.n	3001386a <bio_write_block+0x26>
    if (count == 0)
30013866:	1aa3      	subs	r3, r4, r2
30013868:	d0f7      	beq.n	3001385a <bio_write_block+0x16>
    return dev->write_block(dev, buf, block, count);
3001386a:	6c2c      	ldr	r4, [r5, #64]	; 0x40
3001386c:	4628      	mov	r0, r5
3001386e:	46a4      	mov	r12, r4
}
30013870:	bc30      	pop	{r4, r5}
    return dev->write_block(dev, buf, block, count);
30013872:	4760      	bx	r12

30013874 <bio_erase>:

ssize_t bio_erase(bdev_t *dev, off_t offset, size_t len)
{
30013874:	4601      	mov	r1, r0
    if (offset < 0)
30013876:	2a00      	cmp	r2, #0
30013878:	f173 0000 	sbcs.w	r0, r3, #0
{
3001387c:	e92d 03d0 	stmdb	r13!, {r4, r6, r7, r8, r9}
30013880:	9c05      	ldr	r4, [sp, #20]
    if (offset < 0)
30013882:	db0b      	blt.n	3001389c <bio_erase+0x28>
    if (offset >= dev->total_size)
30013884:	e9d1 6704 	ldrd	r6, r7, [r1, #16]
30013888:	42b2      	cmp	r2, r6
3001388a:	eb73 0007 	sbcs.w	r0, r3, r7
3001388e:	bfac      	ite	ge
30013890:	2001      	movge	r0, #1
30013892:	2000      	movlt	r0, #0
    if (len == 0)
30013894:	2c00      	cmp	r4, #0
30013896:	bf08      	it	eq
30013898:	2001      	moveq	r0, #1
3001389a:	b118      	cbz	r0, 300138a4 <bio_erase+0x30>
    len = bio_trim_range(dev, offset, len);
    if (len == 0)
        return 0;

    return dev->erase(dev, offset, len);
}
3001389c:	2000      	movs	r0, #0
3001389e:	e8bd 03d0 	ldmia.w	r13!, {r4, r6, r7, r8, r9}
300138a2:	4770      	bx	r14
    if (offset + len > dev->total_size)
300138a4:	eb12 0804 	adds.w	r8, r2, r4
300138a8:	f143 0900 	adc.w	r9, r3, #0
300138ac:	4546      	cmp	r6, r8
300138ae:	eb77 0009 	sbcs.w	r0, r7, r9
300138b2:	da01      	bge.n	300138b8 <bio_erase+0x44>
    if (len == 0)
300138b4:	1ab4      	subs	r4, r6, r2
300138b6:	d0f1      	beq.n	3001389c <bio_erase+0x28>
    return dev->erase(dev, offset, len);
300138b8:	9405      	str	r4, [sp, #20]
300138ba:	4608      	mov	r0, r1
}
300138bc:	e8bd 03d0 	ldmia.w	r13!, {r4, r6, r7, r8, r9}
    return dev->erase(dev, offset, len);
300138c0:	6c49      	ldr	r1, [r1, #68]	; 0x44
300138c2:	4708      	bx	r1

300138c4 <bio_initialize_bdev>:
                         size_t block_size,
                         bnum_t block_count,
                         size_t geometry_count,
                         const bio_erase_geometry_info_t *geometry,
                         const uint32_t flags)
{
300138c4:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
300138c8:	4604      	mov	r4, r0
    item->prev = item->next = 0;
300138ca:	2500      	movs	r5, #0

    // Block size must be finite powers of 2
    DEBUG_ASSERT(block_size && ispow2(block_size));

    list_clear_node(&dev->node);
    dev->name = strdup(name);
300138cc:	4608      	mov	r0, r1
{
300138ce:	4617      	mov	r7, r2
300138d0:	6065      	str	r5, [r4, #4]
300138d2:	461e      	mov	r6, r3
300138d4:	6025      	str	r5, [r4, #0]
    dev->name = strdup(name);
300138d6:	f002 f9c7 	bl	30015c68 <strdup>
    dev->block_size = block_size;
300138da:	61a7      	str	r7, [r4, #24]
    dev->block_count = block_count;
300138dc:	6226      	str	r6, [r4, #32]
    dev->name = strdup(name);
300138de:	60e0      	str	r0, [r4, #12]
    if (val == 0)
300138e0:	b11f      	cbz	r7, 300138ea <bio_initialize_bdev+0x26>
    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
300138e2:	fab7 f887 	clz	r8, r7
300138e6:	f1c8 071f 	rsb	r7, r8, #31
    dev->block_shift = log2_uint(block_size);
    dev->total_size = (off_t)block_count << dev->block_shift;
300138ea:	f1a7 0320 	sub.w	r3, r7, #32
    dev->geometry_count = geometry_count;
300138ee:	9908      	ldr	r1, [sp, #32]
    dev->total_size = (off_t)block_count << dev->block_shift;
300138f0:	f1c7 0220 	rsb	r2, r7, #32
300138f4:	fa06 f303 	lsl.w	r3, r6, r3
300138f8:	fa26 f202 	lsr.w	r2, r6, r2
    dev->geometry_count = geometry_count;
300138fc:	6261      	str	r1, [r4, #36]	; 0x24
    dev->total_size = (off_t)block_count << dev->block_shift;
300138fe:	431a      	orrs	r2, r3
    dev->geometry = geometry;
30013900:	9909      	ldr	r1, [sp, #36]	; 0x24
        }
    }
#endif

    /* set up the default hooks, the sub driver should override the block operations at least */
    dev->read = bio_default_read;
30013902:	f243 19f9 	movw	r9, #12793	; 0x31f9
    dev->total_size = (off_t)block_count << dev->block_shift;
30013906:	fa06 f307 	lsl.w	r3, r6, r7
    dev->block_shift = log2_uint(block_size);
3001390a:	61e7      	str	r7, [r4, #28]
    dev->read_block = bio_default_read_block;
3001390c:	f243 16f1 	movw	r6, #12785	; 0x31f1
    dev->write = bio_default_write;
30013910:	f243 35d1 	movw	r5, #13265	; 0x33d1
    dev->write_block = bio_default_write_block;
30013914:	f243 6799 	movw	r7, #13977	; 0x3699
    dev->geometry = geometry;
30013918:	62a1      	str	r1, [r4, #40]	; 0x28
    dev->erase = bio_default_erase;
3001391a:	f243 60ed 	movw	r0, #14061	; 0x36ed
    dev->flags = flags;
3001391e:	990a      	ldr	r1, [sp, #40]	; 0x28
    dev->read = bio_default_read;
30013920:	f2c3 0901 	movt	r9, #12289	; 0x3001
    dev->read_block = bio_default_read_block;
30013924:	f2c3 0601 	movt	r6, #12289	; 0x3001
    dev->write = bio_default_write;
30013928:	f2c3 0501 	movt	r5, #12289	; 0x3001
    dev->write_block = bio_default_write_block;
3001392c:	f2c3 0701 	movt	r7, #12289	; 0x3001
    dev->flags = flags;
30013930:	6321      	str	r1, [r4, #48]	; 0x30
    dev->erase = bio_default_erase;
30013932:	f2c3 0001 	movt	r0, #12289	; 0x3001
    dev->total_size = (off_t)block_count << dev->block_shift;
30013936:	e9c4 3204 	strd	r3, r2, [r4, #16]
3001393a:	2100      	movs	r1, #0
    dev->read_block = bio_default_read_block;
3001393c:	e9c4 960d 	strd	r9, r6, [r4, #52]	; 0x34
    dev->write_block = bio_default_write_block;
30013940:	e9c4 570f 	strd	r5, r7, [r4, #60]	; 0x3c
    dev->erase = bio_default_erase;
30013944:	6460      	str	r0, [r4, #68]	; 0x44
    dev->erase_byte = 0;
30013946:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
    dev->ref = 0;
3001394a:	60a1      	str	r1, [r4, #8]
    dev->close = NULL;
3001394c:	64e1      	str	r1, [r4, #76]	; 0x4c
}
3001394e:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
30013952:	bf00      	nop

30013954 <bio_register_device>:

void bio_register_device(bdev_t *dev)
{
30013954:	b538      	push	{r3, r4, r5, r14}
        __asm__ volatile(
30013956:	2201      	movs	r2, #1
30013958:	4605      	mov	r5, r0
    atomic_add(&dev->ref, 1);
3001395a:	f100 0308 	add.w	r3, r0, #8
3001395e:	e853 0f00 	ldrex	r0, [r3]
30013962:	1884      	adds	r4, r0, r2
30013964:	e843 4100 	strex	r1, r4, [r3]
    } while (test != 0);
30013968:	2900      	cmp	r1, #0
3001396a:	d1f8      	bne.n	3001395e <bio_register_device+0xa>
3001396c:	f245 4400 	movw	r4, #21504	; 0x5400
30013970:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
30013974:	f2c3 0402 	movt	r4, #12290	; 0x3002
30013978:	f104 0008 	add.w	r0, r4, #8
3001397c:	f7fe f856 	bl	30011a2c <mutex_acquire_timeout>
    item->next = list;
30013980:	606c      	str	r4, [r5, #4]
    item->prev = list->prev;
30013982:	6823      	ldr	r3, [r4, #0]
    list->prev = item;
30013984:	4620      	mov	r0, r4
    item->prev = list->prev;
30013986:	602b      	str	r3, [r5, #0]
    list->prev->next = item;
30013988:	6823      	ldr	r3, [r4, #0]
3001398a:	605d      	str	r5, [r3, #4]
    list->prev = item;
3001398c:	f840 5b08 	str.w	r5, [r0], #8
    bdev_inc_ref(dev);

    mutex_acquire(&bdevs.lock);
    list_add_tail(&bdevs.list, &dev->node);
    mutex_release(&bdevs.lock);
}
30013990:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    mutex_release(&bdevs.lock);
30013994:	f7fe b876 	b.w	30011a84 <mutex_release>

30013998 <mem_bdev_write_block>:
{
    mem_bdev_t *mem = (mem_bdev_t *)bdev;

    LTRACEF("bdev %s, buf %p, block %u, count %u\n", bdev->name, buf, block, count);

    memcpy((uint8_t *)mem->ptr + block * BLOCKSIZE, buf, count * BLOCKSIZE);
30013998:	6d00      	ldr	r0, [r0, #80]	; 0x50
{
3001399a:	b510      	push	{r4, r14}
    memcpy((uint8_t *)mem->ptr + block * BLOCKSIZE, buf, count * BLOCKSIZE);
3001399c:	025c      	lsls	r4, r3, #9
3001399e:	eb00 2042 	add.w	r0, r0, r2, lsl #9
300139a2:	4622      	mov	r2, r4
300139a4:	f000 ef5e 	blx	30014864 <memcpy>

    return count * BLOCKSIZE;
}
300139a8:	4620      	mov	r0, r4
300139aa:	bd10      	pop	{r4, r15}

300139ac <mem_bdev_write>:
    memcpy((uint8_t *)mem->ptr + offset, buf, len);
300139ac:	6d00      	ldr	r0, [r0, #80]	; 0x50
{
300139ae:	b508      	push	{r3, r14}
    memcpy((uint8_t *)mem->ptr + offset, buf, len);
300139b0:	4410      	add	r0, r2
300139b2:	9a02      	ldr	r2, [sp, #8]
300139b4:	f000 ef56 	blx	30014864 <memcpy>
}
300139b8:	9802      	ldr	r0, [sp, #8]
300139ba:	bd08      	pop	{r3, r15}

300139bc <mem_bdev_read_block>:
{
300139bc:	b538      	push	{r3, r4, r5, r14}
    memcpy(buf, (uint8_t *)mem->ptr + block * BLOCKSIZE, count * BLOCKSIZE);
300139be:	6d04      	ldr	r4, [r0, #80]	; 0x50
300139c0:	025d      	lsls	r5, r3, #9
{
300139c2:	4608      	mov	r0, r1
    memcpy(buf, (uint8_t *)mem->ptr + block * BLOCKSIZE, count * BLOCKSIZE);
300139c4:	eb04 2142 	add.w	r1, r4, r2, lsl #9
300139c8:	462a      	mov	r2, r5
300139ca:	f000 ef4c 	blx	30014864 <memcpy>
}
300139ce:	4628      	mov	r0, r5
300139d0:	bd38      	pop	{r3, r4, r5, r15}
300139d2:	bf00      	nop

300139d4 <mem_bdev_read>:
{
300139d4:	b508      	push	{r3, r14}
    memcpy(buf, (uint8_t *)mem->ptr + offset, len);
300139d6:	6d03      	ldr	r3, [r0, #80]	; 0x50
300139d8:	4608      	mov	r0, r1
300139da:	1899      	adds	r1, r3, r2
300139dc:	9a02      	ldr	r2, [sp, #8]
300139de:	f000 ef42 	blx	30014864 <memcpy>
}
300139e2:	9802      	ldr	r0, [sp, #8]
300139e4:	bd08      	pop	{r3, r15}
300139e6:	bf00      	nop

300139e8 <create_membdev>:

int create_membdev(const char *name, void *ptr, size_t len)
{
300139e8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
300139ec:	4606      	mov	r6, r0
300139ee:	b084      	sub	sp, #16
    mem_bdev_t *mem = malloc(sizeof(mem_bdev_t));
300139f0:	2058      	movs	r0, #88	; 0x58
{
300139f2:	4690      	mov	r8, r2
300139f4:	460f      	mov	r7, r1
    mem_bdev_t *mem = malloc(sizeof(mem_bdev_t));
300139f6:	f000 fe77 	bl	300146e8 <malloc>

    /* set up the base device */
    bio_initialize_bdev(&mem->dev, name, BLOCKSIZE, len / BLOCKSIZE, 0, NULL,
300139fa:	2500      	movs	r5, #0
300139fc:	ea4f 2358 	mov.w	r3, r8, lsr #9
30013a00:	4631      	mov	r1, r6
30013a02:	f44f 7200 	mov.w	r2, #512	; 0x200
30013a06:	e9cd 5501 	strd	r5, r5, [r13, #4]
                        BIO_FLAGS_NONE);

    /* our bits */
    mem->ptr = ptr;
    mem->dev.read = mem_bdev_read;
30013a0a:	f643 16d5 	movw	r6, #14805	; 0x39d5
    bio_initialize_bdev(&mem->dev, name, BLOCKSIZE, len / BLOCKSIZE, 0, NULL,
30013a0e:	9500      	str	r5, [sp, #0]
    mem->dev.read = mem_bdev_read;
30013a10:	f2c3 0601 	movt	r6, #12289	; 0x3001
    mem_bdev_t *mem = malloc(sizeof(mem_bdev_t));
30013a14:	4604      	mov	r4, r0
    bio_initialize_bdev(&mem->dev, name, BLOCKSIZE, len / BLOCKSIZE, 0, NULL,
30013a16:	f7ff ff55 	bl	300138c4 <bio_initialize_bdev>
    mem->dev.read_block = mem_bdev_read_block;
30013a1a:	f643 11bd 	movw	r1, #14781	; 0x39bd
    mem->dev.write = mem_bdev_write;
30013a1e:	f643 12ad 	movw	r2, #14765	; 0x39ad
    mem->dev.write_block = mem_bdev_write_block;
30013a22:	f643 1399 	movw	r3, #14745	; 0x3999
    mem->dev.read_block = mem_bdev_read_block;
30013a26:	f2c3 0101 	movt	r1, #12289	; 0x3001
    mem->dev.write = mem_bdev_write;
30013a2a:	f2c3 0201 	movt	r2, #12289	; 0x3001

    /* register it */
    bio_register_device(&mem->dev);
30013a2e:	4620      	mov	r0, r4
    mem->dev.write_block = mem_bdev_write_block;
30013a30:	f2c3 0301 	movt	r3, #12289	; 0x3001
    mem->ptr = ptr;
30013a34:	6527      	str	r7, [r4, #80]	; 0x50
    mem->dev.read_block = mem_bdev_read_block;
30013a36:	e9c4 610d 	strd	r6, r1, [r4, #52]	; 0x34
    mem->dev.write_block = mem_bdev_write_block;
30013a3a:	e9c4 230f 	strd	r2, r3, [r4, #60]	; 0x3c
    bio_register_device(&mem->dev);
30013a3e:	f7ff ff89 	bl	30013954 <bio_register_device>

    return 0;
}
30013a42:	4628      	mov	r0, r5
30013a44:	b004      	add	sp, #16
30013a46:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
30013a4a:	bf00      	nop

30013a4c <cmd_echo>:
    return cmd_help_impl(CMD_AVAIL_PANIC);
}

static int cmd_echo(int argc, const cmd_args *argv)
{
    if (argc > 1)
30013a4c:	2801      	cmp	r0, #1
        echo = argv[1].b;
30013a4e:	bfc4      	itt	gt
30013a50:	f891 2024 	ldrbgt.w	r2, [r1, #36]	; 0x24
30013a54:	f245 4324 	movwgt	r3, #21540	; 0x5424
    return NO_ERROR;
}
30013a58:	f04f 0000 	mov.w	r0, #0
        echo = argv[1].b;
30013a5c:	bfc4      	itt	gt
30013a5e:	f2c3 0302 	movtgt	r3, #12290	; 0x3002
30013a62:	701a      	strbgt	r2, [r3, #0]
}
30013a64:	4770      	bx	r14
30013a66:	bf00      	nop

30013a68 <cmd_help_impl>:
{
30013a68:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30013a6c:	4607      	mov	r7, r0
    printf("command list:\n");
30013a6e:	f640 70c0 	movw	r0, #4032	; 0xfc0
30013a72:	f2c3 0002 	movt	r0, #12290	; 0x3002
30013a76:	f002 f89b 	bl	30015bb0 <_printf>
    for (block = command_list; block != NULL; block = block->next) {
30013a7a:	f64d 033c 	movw	r3, #55356	; 0xd83c
30013a7e:	f2c3 0302 	movt	r3, #12290	; 0x3002
30013a82:	681e      	ldr	r6, [r3, #0]
30013a84:	b1de      	cbz	r6, 30013abe <cmd_help_impl+0x56>
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
30013a86:	f640 78d0 	movw	r8, #4048	; 0xfd0
30013a8a:	f2c3 0802 	movt	r8, #12290	; 0x3002
        const cmd *curr_cmd = block->list;
30013a8e:	e9d6 1401 	ldrd	r1, r4, [r6, #4]
        for (i = 0; i < block->count; i++) {
30013a92:	b189      	cbz	r1, 30013ab8 <cmd_help_impl+0x50>
30013a94:	2500      	movs	r5, #0
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
30013a96:	7b23      	ldrb	r3, [r4, #12]
30013a98:	421f      	tst	r7, r3
        for (i = 0; i < block->count; i++) {
30013a9a:	f105 0501 	add.w	r5, r5, #1
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
30013a9e:	d007      	beq.n	30013ab0 <cmd_help_impl+0x48>
            if (curr_cmd[i].help_str)
30013aa0:	6863      	ldr	r3, [r4, #4]
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
30013aa2:	4640      	mov	r0, r8
30013aa4:	461a      	mov	r2, r3
            if (curr_cmd[i].help_str)
30013aa6:	b11b      	cbz	r3, 30013ab0 <cmd_help_impl+0x48>
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
30013aa8:	6821      	ldr	r1, [r4, #0]
30013aaa:	f002 f881 	bl	30015bb0 <_printf>
30013aae:	6871      	ldr	r1, [r6, #4]
        for (i = 0; i < block->count; i++) {
30013ab0:	42a9      	cmp	r1, r5
30013ab2:	f104 0410 	add.w	r4, r4, #16
30013ab6:	d8ee      	bhi.n	30013a96 <cmd_help_impl+0x2e>
    for (block = command_list; block != NULL; block = block->next) {
30013ab8:	6836      	ldr	r6, [r6, #0]
30013aba:	2e00      	cmp	r6, #0
30013abc:	d1e7      	bne.n	30013a8e <cmd_help_impl+0x26>
}
30013abe:	2000      	movs	r0, #0
30013ac0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

30013ac4 <cmd_help_panic>:
    return cmd_help_impl(CMD_AVAIL_PANIC);
30013ac4:	2002      	movs	r0, #2
30013ac6:	f7ff bfcf 	b.w	30013a68 <cmd_help_impl>
30013aca:	bf00      	nop

30013acc <cmd_help>:
    return cmd_help_impl(CMD_AVAIL_NORMAL);
30013acc:	2001      	movs	r0, #1
30013ace:	f7ff bfcb 	b.w	30013a68 <cmd_help_impl>
30013ad2:	bf00      	nop

30013ad4 <read_debug_line>:
{
30013ad4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    return ptrprev(history_next);
30013ad8:	f64d 094c 	movw	r9, #55372	; 0xd84c
    char *buffer = debug_buffer;
30013adc:	f64d 0344 	movw	r3, #55364	; 0xd844
    return ptrprev(history_next);
30013ae0:	f2c3 0902 	movt	r9, #12290	; 0x3002
    int escape_level = 0;
30013ae4:	2600      	movs	r6, #0
    char *buffer = debug_buffer;
30013ae6:	f2c3 0302 	movt	r3, #12290	; 0x3002
                        if (echo) {
30013aea:	f245 4724 	movw	r7, #21540	; 0x5424
                            fputs("\b \b", stdout); // wipe out a character
30013aee:	f241 0a00 	movw	r10, #4096	; 0x1000
    return (ptr - 1) % HISTORY_LEN;
30013af2:	f8d9 2000 	ldr.w	r2, [r9]
{
30013af6:	b083      	sub	sp, #12
    char *buffer = debug_buffer;
30013af8:	f8d3 8000 	ldr.w	r8, [r3]
    int pos = 0;
30013afc:	4634      	mov	r4, r6
                            fputs("\b \b", stdout); // wipe out a character
30013afe:	f8df b210 	ldr.w	r11, [r15, #528]	; 30013d10 <read_debug_line+0x23c>
    return (ptr - 1) % HISTORY_LEN;
30013b02:	3a01      	subs	r2, #1
30013b04:	f002 020f 	and.w	r2, r2, #15
                        if (echo) {
30013b08:	f2c3 0702 	movt	r7, #12290	; 0x3002
{
30013b0c:	9000      	str	r0, [sp, #0]
                            fputs("\b \b", stdout); // wipe out a character
30013b0e:	f2c3 0a02 	movt	r10, #12290	; 0x3002
    return (ptr - 1) % HISTORY_LEN;
30013b12:	9201      	str	r2, [sp, #4]
        if ((c = getchar()) < 0)
30013b14:	f002 f838 	bl	30015b88 <getchar>
30013b18:	1e05      	subs	r5, r0, #0
30013b1a:	dbfb      	blt.n	30013b14 <read_debug_line+0x40>
        if (escape_level == 0) {
30013b1c:	2e00      	cmp	r6, #0
30013b1e:	d143      	bne.n	30013ba8 <read_debug_line+0xd4>
            switch (c) {
30013b20:	2d0d      	cmp	r5, #13
30013b22:	f000 8085 	beq.w	30013c30 <read_debug_line+0x15c>
30013b26:	dd09      	ble.n	30013b3c <read_debug_line+0x68>
30013b28:	2d1b      	cmp	r5, #27
30013b2a:	f000 8096 	beq.w	30013c5a <read_debug_line+0x186>
30013b2e:	2d7f      	cmp	r5, #127	; 0x7f
30013b30:	d108      	bne.n	30013b44 <read_debug_line+0x70>
                    if (pos > 0) {
30013b32:	2c00      	cmp	r4, #0
30013b34:	f040 80b6 	bne.w	30013ca4 <read_debug_line+0x1d0>
30013b38:	4626      	mov	r6, r4
30013b3a:	e7eb      	b.n	30013b14 <read_debug_line+0x40>
            switch (c) {
30013b3c:	2d08      	cmp	r5, #8
30013b3e:	d0f8      	beq.n	30013b32 <read_debug_line+0x5e>
30013b40:	2d0a      	cmp	r5, #10
30013b42:	d075      	beq.n	30013c30 <read_debug_line+0x15c>
                    buffer[pos++] = c;
30013b44:	f808 5004 	strb.w	r5, [r8, r4]
                    if (echo)
30013b48:	783b      	ldrb	r3, [r7, #0]
                    buffer[pos++] = c;
30013b4a:	3401      	adds	r4, #1
                    if (echo)
30013b4c:	2b00      	cmp	r3, #0
30013b4e:	f040 80b4 	bne.w	30013cba <read_debug_line+0x1e6>
        if (pos == (LINE_LEN - 1)) {
30013b52:	2c7f      	cmp	r4, #127	; 0x7f
30013b54:	d1de      	bne.n	30013b14 <read_debug_line+0x40>
            fputs("\nerror: line too long\n", stdout);
30013b56:	f241 0004 	movw	r0, #4100	; 0x1004
30013b5a:	2216      	movs	r2, #22
30013b5c:	4b6c      	ldr	r3, [pc, #432]	; (30013d10 <read_debug_line+0x23c>)
30013b5e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30013b62:	2101      	movs	r1, #1
    char *buffer = debug_buffer;
30013b64:	4645      	mov	r5, r8
            fputs("\nerror: line too long\n", stdout);
30013b66:	f001 fff7 	bl	30015b58 <fwrite>
            pos = 0;
30013b6a:	2400      	movs	r4, #0
    buffer[pos] = 0;
30013b6c:	2300      	movs	r3, #0
30013b6e:	702b      	strb	r3, [r5, #0]
    if (line[0] == 0)
30013b70:	f898 3000 	ldrb.w	r3, [r8]
30013b74:	b18b      	cbz	r3, 30013b9a <read_debug_line+0xc6>
    return history + line * LINE_LEN;
30013b76:	f64d 0348 	movw	r3, #55368	; 0xd848
    if (strcmp(line, history_line(last)) == 0)
30013b7a:	4640      	mov	r0, r8
    uint last = ptrprev(history_next);
30013b7c:	f8d9 6000 	ldr.w	r6, [r9]
    return history + line * LINE_LEN;
30013b80:	f2c3 0302 	movt	r3, #12290	; 0x3002
    return (ptr - 1) % HISTORY_LEN;
30013b84:	1e71      	subs	r1, r6, #1
    return history + line * LINE_LEN;
30013b86:	681d      	ldr	r5, [r3, #0]
    return (ptr - 1) % HISTORY_LEN;
30013b88:	f001 010f 	and.w	r1, r1, #15
    if (strcmp(line, history_line(last)) == 0)
30013b8c:	eb05 11c1 	add.w	r1, r5, r1, lsl #7
30013b90:	f002 f85c 	bl	30015c4c <strcmp>
30013b94:	2800      	cmp	r0, #0
30013b96:	f040 8097 	bne.w	30013cc8 <read_debug_line+0x1f4>
    *outbuffer = buffer;
30013b9a:	9b00      	ldr	r3, [sp, #0]
}
30013b9c:	4620      	mov	r0, r4
    *outbuffer = buffer;
30013b9e:	f8c3 8000 	str.w	r8, [r3]
}
30013ba2:	b003      	add	sp, #12
30013ba4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        } else if (escape_level == 1) {
30013ba8:	2e01      	cmp	r6, #1
30013baa:	d04e      	beq.n	30013c4a <read_debug_line+0x176>
            switch (c) {
30013bac:	f1a5 0341 	sub.w	r3, r5, #65	; 0x41
30013bb0:	2b03      	cmp	r3, #3
30013bb2:	f200 80ab 	bhi.w	30013d0c <read_debug_line+0x238>
30013bb6:	e8df f003 	tbb	[r15, r3]
30013bba:	0808      	.short	0x0808
30013bbc:	5565      	.short	0x5565
                            fputs("\b \b", stdout); // wipe out a character
30013bbe:	465b      	mov	r3, r11
30013bc0:	2203      	movs	r2, #3
30013bc2:	2101      	movs	r1, #1
30013bc4:	4650      	mov	r0, r10
30013bc6:	f001 ffc7 	bl	30015b58 <fwrite>
                    while (pos > 0) {
30013bca:	b12c      	cbz	r4, 30013bd8 <read_debug_line+0x104>
                        pos--;
30013bcc:	3c01      	subs	r4, #1
                        if (echo) {
30013bce:	783b      	ldrb	r3, [r7, #0]
30013bd0:	2b00      	cmp	r3, #0
30013bd2:	d1f4      	bne.n	30013bbe <read_debug_line+0xea>
                    while (pos > 0) {
30013bd4:	2c00      	cmp	r4, #0
30013bd6:	d1f9      	bne.n	30013bcc <read_debug_line+0xf8>
30013bd8:	f8d9 3000 	ldr.w	r3, [r9]
                    if (c == 65)
30013bdc:	2d41      	cmp	r5, #65	; 0x41
30013bde:	f000 8081 	beq.w	30013ce4 <read_debug_line+0x210>
    return (ptr + 1) % HISTORY_LEN;
30013be2:	9a01      	ldr	r2, [sp, #4]
30013be4:	1c51      	adds	r1, r2, #1
30013be6:	f001 010f 	and.w	r1, r1, #15
    if (i == history_next)
30013bea:	4299      	cmp	r1, r3
    return history + line * LINE_LEN;
30013bec:	bf17      	itett	ne
30013bee:	f64d 0348 	movwne	r3, #55368	; 0xd848
        return ""; // can't let the cursor hit the head
30013bf2:	f64a 71bc 	movweq	r1, #44988	; 0xafbc
    return history + line * LINE_LEN;
30013bf6:	9101      	strne	r1, [sp, #4]
30013bf8:	f2c3 0302 	movtne	r3, #12290	; 0x3002
        return ""; // can't let the cursor hit the head
30013bfc:	bf0e      	itee	eq
30013bfe:	f2c3 0101 	movteq	r1, #12289	; 0x3001
    return history + line * LINE_LEN;
30013c02:	681b      	ldrne	r3, [r3, #0]
30013c04:	eb03 11c1 	addne.w	r1, r3, r1, lsl #7
                        strlcpy(buffer, next_history(&history_cursor), LINE_LEN);
30013c08:	2280      	movs	r2, #128	; 0x80
30013c0a:	4640      	mov	r0, r8
30013c0c:	f002 f86e 	bl	30015cec <strlcpy>
                    pos = strlen(buffer);
30013c10:	4640      	mov	r0, r8
30013c12:	f002 f88d 	bl	30015d30 <strlen>
                    if (echo)
30013c16:	783e      	ldrb	r6, [r7, #0]
                    pos = strlen(buffer);
30013c18:	4604      	mov	r4, r0
                    if (echo)
30013c1a:	2e00      	cmp	r6, #0
30013c1c:	d099      	beq.n	30013b52 <read_debug_line+0x7e>
                        fputs(buffer, stdout);
30013c1e:	4659      	mov	r1, r11
30013c20:	4640      	mov	r0, r8
30013c22:	f001 ff8d 	bl	30015b40 <fputs>
            escape_level = 0;
30013c26:	2600      	movs	r6, #0
        if (pos == (LINE_LEN - 1)) {
30013c28:	2c7f      	cmp	r4, #127	; 0x7f
30013c2a:	f47f af73 	bne.w	30013b14 <read_debug_line+0x40>
30013c2e:	e792      	b.n	30013b56 <read_debug_line+0x82>
                    if (echo)
30013c30:	f245 4324 	movw	r3, #21540	; 0x5424
30013c34:	eb08 0504 	add.w	r5, r8, r4
30013c38:	f2c3 0302 	movt	r3, #12290	; 0x3002
30013c3c:	781b      	ldrb	r3, [r3, #0]
30013c3e:	2b00      	cmp	r3, #0
30013c40:	d094      	beq.n	30013b6c <read_debug_line+0x98>
                        putchar('\n');
30013c42:	200a      	movs	r0, #10
30013c44:	f001 ff6c 	bl	30015b20 <putchar>
30013c48:	e790      	b.n	30013b6c <read_debug_line+0x98>
                escape_level = 0;
30013c4a:	2d5b      	cmp	r5, #91	; 0x5b
30013c4c:	bf0c      	ite	eq
30013c4e:	2602      	moveq	r6, #2
30013c50:	2600      	movne	r6, #0
        if (pos == (LINE_LEN - 1)) {
30013c52:	2c7f      	cmp	r4, #127	; 0x7f
30013c54:	f47f af5e 	bne.w	30013b14 <read_debug_line+0x40>
30013c58:	e77d      	b.n	30013b56 <read_debug_line+0x82>
                    escape_level++;
30013c5a:	2601      	movs	r6, #1
        if (pos == (LINE_LEN - 1)) {
30013c5c:	2c7f      	cmp	r4, #127	; 0x7f
30013c5e:	f47f af59 	bne.w	30013b14 <read_debug_line+0x40>
30013c62:	e778      	b.n	30013b56 <read_debug_line+0x82>
                    if (pos > 0) {
30013c64:	2c00      	cmp	r4, #0
30013c66:	f43f af67 	beq.w	30013b38 <read_debug_line+0x64>
                        pos--;
30013c6a:	3c01      	subs	r4, #1
                        if (echo) {
30013c6c:	783e      	ldrb	r6, [r7, #0]
30013c6e:	2e00      	cmp	r6, #0
30013c70:	f43f af6f 	beq.w	30013b52 <read_debug_line+0x7e>
                            fputs("\b \b", stdout); // wipe out a character
30013c74:	465b      	mov	r3, r11
30013c76:	2203      	movs	r2, #3
30013c78:	2101      	movs	r1, #1
30013c7a:	4650      	mov	r0, r10
30013c7c:	f001 ff6c 	bl	30015b58 <fwrite>
            escape_level = 0;
30013c80:	2600      	movs	r6, #0
30013c82:	e766      	b.n	30013b52 <read_debug_line+0x7e>
                    buffer[pos++] = ' ';
30013c84:	2020      	movs	r0, #32
30013c86:	1c63      	adds	r3, r4, #1
                    if (echo)
30013c88:	783e      	ldrb	r6, [r7, #0]
                    buffer[pos++] = ' ';
30013c8a:	f808 0004 	strb.w	r0, [r8, r4]
30013c8e:	461c      	mov	r4, r3
                    if (echo)
30013c90:	2e00      	cmp	r6, #0
30013c92:	f43f af5e 	beq.w	30013b52 <read_debug_line+0x7e>
                        putchar(' ');
30013c96:	f001 ff43 	bl	30015b20 <putchar>
            escape_level = 0;
30013c9a:	2600      	movs	r6, #0
        if (pos == (LINE_LEN - 1)) {
30013c9c:	2c7f      	cmp	r4, #127	; 0x7f
30013c9e:	f47f af39 	bne.w	30013b14 <read_debug_line+0x40>
30013ca2:	e758      	b.n	30013b56 <read_debug_line+0x82>
                        fputs("\b \b", stdout); // wipe out a character
30013ca4:	465b      	mov	r3, r11
30013ca6:	2203      	movs	r2, #3
30013ca8:	2101      	movs	r1, #1
30013caa:	4650      	mov	r0, r10
                        pos--;
30013cac:	3c01      	subs	r4, #1
                        fputs("\b \b", stdout); // wipe out a character
30013cae:	f001 ff53 	bl	30015b58 <fwrite>
        if (pos == (LINE_LEN - 1)) {
30013cb2:	2c7f      	cmp	r4, #127	; 0x7f
30013cb4:	f47f af2e 	bne.w	30013b14 <read_debug_line+0x40>
30013cb8:	e74d      	b.n	30013b56 <read_debug_line+0x82>
                        putchar(c);
30013cba:	4628      	mov	r0, r5
30013cbc:	f001 ff30 	bl	30015b20 <putchar>
        if (pos == (LINE_LEN - 1)) {
30013cc0:	2c7f      	cmp	r4, #127	; 0x7f
30013cc2:	f47f af27 	bne.w	30013b14 <read_debug_line+0x40>
30013cc6:	e746      	b.n	30013b56 <read_debug_line+0x82>
    strlcpy(history_line(history_next), line, LINE_LEN);
30013cc8:	2280      	movs	r2, #128	; 0x80
30013cca:	eb05 10c6 	add.w	r0, r5, r6, lsl #7
30013cce:	4641      	mov	r1, r8
30013cd0:	f002 f80c 	bl	30015cec <strlcpy>
    return (ptr + 1) % HISTORY_LEN;
30013cd4:	f8d9 3000 	ldr.w	r3, [r9]
30013cd8:	3301      	adds	r3, #1
30013cda:	f003 030f 	and.w	r3, r3, #15
    history_next = ptrnext(history_next);
30013cde:	f8c9 3000 	str.w	r3, [r9]
30013ce2:	e75a      	b.n	30013b9a <read_debug_line+0xc6>
    return history + line * LINE_LEN;
30013ce4:	9c01      	ldr	r4, [sp, #4]
30013ce6:	f64d 0248 	movw	r2, #55368	; 0xd848
30013cea:	f2c3 0202 	movt	r2, #12290	; 0x3002
    if (*cursor == history_next)
30013cee:	429c      	cmp	r4, r3
    return history + line * LINE_LEN;
30013cf0:	6812      	ldr	r2, [r2, #0]
30013cf2:	eb02 11c4 	add.w	r1, r2, r4, lsl #7
    if (*cursor == history_next)
30013cf6:	d087      	beq.n	30013c08 <read_debug_line+0x134>
    return (ptr - 1) % HISTORY_LEN;
30013cf8:	1e63      	subs	r3, r4, #1
30013cfa:	f003 030f 	and.w	r3, r3, #15
    if (history_line(i)[0] == '\0')
30013cfe:	01d8      	lsls	r0, r3, #7
30013d00:	5c12      	ldrb	r2, [r2, r0]
    *cursor = i;
30013d02:	2a00      	cmp	r2, #0
30013d04:	bf18      	it	ne
30013d06:	461c      	movne	r4, r3
30013d08:	9401      	str	r4, [sp, #4]
30013d0a:	e77d      	b.n	30013c08 <read_debug_line+0x134>
            escape_level = 0;
30013d0c:	2600      	movs	r6, #0
30013d0e:	e720      	b.n	30013b52 <read_debug_line+0x7e>
30013d10:	30025434 	.word	0x30025434

30013d14 <match_command>:
    for (block = command_list; block != NULL; block = block->next) {
30013d14:	f64d 033c 	movw	r3, #55356	; 0xd83c
30013d18:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30013d1c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    for (block = command_list; block != NULL; block = block->next) {
30013d20:	f8d3 9000 	ldr.w	r9, [r3]
30013d24:	f1b9 0f00 	cmp.w	r9, #0
30013d28:	d019      	beq.n	30013d5e <match_command+0x4a>
30013d2a:	4680      	mov	r8, r0
30013d2c:	460f      	mov	r7, r1
        const cmd *curr_cmd = block->list;
30013d2e:	e9d9 6401 	ldrd	r6, r4, [r9, #4]
        for (i = 0; i < block->count; i++) {
30013d32:	b17e      	cbz	r6, 30013d54 <match_command+0x40>
30013d34:	2500      	movs	r5, #0
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
30013d36:	7b23      	ldrb	r3, [r4, #12]
            if (strcmp(command, curr_cmd[i].cmd_str) == 0) {
30013d38:	4640      	mov	r0, r8
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
30013d3a:	421f      	tst	r7, r3
30013d3c:	46a2      	mov	r10, r4
        for (i = 0; i < block->count; i++) {
30013d3e:	f105 0501 	add.w	r5, r5, #1
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
30013d42:	d003      	beq.n	30013d4c <match_command+0x38>
            if (strcmp(command, curr_cmd[i].cmd_str) == 0) {
30013d44:	6821      	ldr	r1, [r4, #0]
30013d46:	f001 ff81 	bl	30015c4c <strcmp>
30013d4a:	b148      	cbz	r0, 30013d60 <match_command+0x4c>
        for (i = 0; i < block->count; i++) {
30013d4c:	42b5      	cmp	r5, r6
30013d4e:	f104 0410 	add.w	r4, r4, #16
30013d52:	d1f0      	bne.n	30013d36 <match_command+0x22>
    for (block = command_list; block != NULL; block = block->next) {
30013d54:	f8d9 9000 	ldr.w	r9, [r9]
30013d58:	f1b9 0f00 	cmp.w	r9, #0
30013d5c:	d1e7      	bne.n	30013d2e <match_command+0x1a>
    return NULL;
30013d5e:	46ca      	mov	r10, r9
}
30013d60:	4650      	mov	r0, r10
30013d62:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
30013d66:	bf00      	nop

30013d68 <convert_args>:
    for (i = 0; i < argc; i++) {
30013d68:	2800      	cmp	r0, #0
30013d6a:	dd44      	ble.n	30013df6 <convert_args+0x8e>
30013d6c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
{
30013d70:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
30013d74:	f640 77f4 	movw	r7, #4084	; 0xff4
30013d78:	f240 56cc 	movw	r6, #1484	; 0x5cc
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
30013d7c:	f64e 5858 	movw	r8, #60760	; 0xed58
30013d80:	460c      	mov	r4, r1
30013d82:	eb01 0980 	add.w	r9, r1, r0, lsl #2
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
30013d86:	f2c3 0702 	movt	r7, #12290	; 0x3002
30013d8a:	f2c3 0602 	movt	r6, #12290	; 0x3002
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
30013d8e:	f2c3 0801 	movt	r8, #12289	; 0x3001
        unsigned long u = atoul(argv[i].str);
30013d92:	6820      	ldr	r0, [r4, #0]
30013d94:	f000 fe94 	bl	30014ac0 <atoul>
30013d98:	4603      	mov	r3, r0
        argv[i].i = atol(argv[i].str);
30013d9a:	6820      	ldr	r0, [r4, #0]
        argv[i].p = (void *)u;
30013d9c:	e9c4 3301 	strd	r3, r3, [r4, #4]
        argv[i].i = atol(argv[i].str);
30013da0:	f000 fe44 	bl	30014a2c <atol>
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
30013da4:	6825      	ldr	r5, [r4, #0]
30013da6:	4639      	mov	r1, r7
        argv[i].i = atol(argv[i].str);
30013da8:	60e0      	str	r0, [r4, #12]
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
30013daa:	4628      	mov	r0, r5
30013dac:	f001 ff4e 	bl	30015c4c <strcmp>
30013db0:	4631      	mov	r1, r6
30013db2:	b1b8      	cbz	r0, 30013de4 <convert_args+0x7c>
30013db4:	4628      	mov	r0, r5
30013db6:	f001 ff49 	bl	30015c4c <strcmp>
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
30013dba:	4641      	mov	r1, r8
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
30013dbc:	b190      	cbz	r0, 30013de4 <convert_args+0x7c>
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
30013dbe:	4628      	mov	r0, r5
30013dc0:	f001 ff44 	bl	30015c4c <strcmp>
30013dc4:	f640 71fc 	movw	r1, #4092	; 0xffc
30013dc8:	f2c3 0102 	movt	r1, #12290	; 0x3002
30013dcc:	b118      	cbz	r0, 30013dd6 <convert_args+0x6e>
30013dce:	4628      	mov	r0, r5
30013dd0:	f001 ff3c 	bl	30015c4c <strcmp>
30013dd4:	b948      	cbnz	r0, 30013dea <convert_args+0x82>
            argv[i].b = false;
30013dd6:	2300      	movs	r3, #0
30013dd8:	7423      	strb	r3, [r4, #16]
30013dda:	3414      	adds	r4, #20
    for (i = 0; i < argc; i++) {
30013ddc:	454c      	cmp	r4, r9
30013dde:	d1d8      	bne.n	30013d92 <convert_args+0x2a>
}
30013de0:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            argv[i].b = true;
30013de4:	2301      	movs	r3, #1
30013de6:	7423      	strb	r3, [r4, #16]
30013de8:	e7f7      	b.n	30013dda <convert_args+0x72>
            argv[i].b = (argv[i].u == 0) ? false : true;
30013dea:	6863      	ldr	r3, [r4, #4]
30013dec:	3300      	adds	r3, #0
30013dee:	bf18      	it	ne
30013df0:	2301      	movne	r3, #1
30013df2:	7423      	strb	r3, [r4, #16]
30013df4:	e7f1      	b.n	30013dda <convert_args+0x72>
30013df6:	4770      	bx	r14

30013df8 <command_loop>:
{
30013df8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30013dfc:	b08b      	sub	sp, #44	; 0x2c
30013dfe:	9005      	str	r0, [sp, #20]
    args = (cmd_args *) malloc (MAX_NUM_ARGS * sizeof(cmd_args));
30013e00:	f44f 70a0 	mov.w	r0, #320	; 0x140
{
30013e04:	9106      	str	r1, [sp, #24]
30013e06:	9204      	str	r2, [sp, #16]
30013e08:	9302      	str	r3, [sp, #8]
    args = (cmd_args *) malloc (MAX_NUM_ARGS * sizeof(cmd_args));
30013e0a:	f000 fc6d 	bl	300146e8 <malloc>
    if (unlikely(args == NULL)) {
30013e0e:	2800      	cmp	r0, #0
30013e10:	f000 816e 	beq.w	300140f0 <command_loop+0x2f8>
30013e14:	4680      	mov	r8, r0
    outbuf = malloc(outbuflen);
30013e16:	f44f 6080 	mov.w	r0, #1024	; 0x400
30013e1a:	f000 fc65 	bl	300146e8 <malloc>
    if (unlikely(outbuf == NULL)) {
30013e1e:	4607      	mov	r7, r0
30013e20:	2800      	cmp	r0, #0
30013e22:	f000 8162 	beq.w	300140ea <command_loop+0x2f2>
                fputs("] ", stdout);
30013e26:	f640 73dc 	movw	r3, #4060	; 0xfdc
        abort_script = false;
30013e2a:	f64d 0238 	movw	r2, #55352	; 0xd838
    continuebuffer = NULL;
30013e2e:	f04f 0a00 	mov.w	r10, #0
                fputs("] ", stdout);
30013e32:	f2c3 0302 	movt	r3, #12290	; 0x3002
    continuebuffer = NULL;
30013e36:	46d3      	mov	r11, r10
        abort_script = false;
30013e38:	f2c3 0202 	movt	r2, #12290	; 0x3002
                fputs("] ", stdout);
30013e3c:	9307      	str	r3, [sp, #28]
        abort_script = false;
30013e3e:	9203      	str	r2, [sp, #12]
    continuebuffer = NULL;
30013e40:	f8cd 8000 	str.w	r8, [r13]
        if (continuebuffer == NULL) {
30013e44:	f1bb 0f00 	cmp.w	r11, #0
30013e48:	f000 8082 	beq.w	30013f50 <command_loop+0x158>
            buffer = continuebuffer;
30013e4c:	f8cd b024 	str.w	r11, [r13, #36]	; 0x24
    outpos = 0;
30013e50:	2500      	movs	r5, #0
    continuebuffer = NULL;
30013e52:	4639      	mov	r1, r7
    arg = 0;
30013e54:	462e      	mov	r6, r5
    inpos = 0;
30013e56:	462c      	mov	r4, r5
                    buffer[outpos] = 0;
30013e58:	46a9      	mov	r9, r5
30013e5a:	46b8      	mov	r8, r7
30013e5c:	f89b a000 	ldrb.w	r10, [r11]
                if (c == '\0')
30013e60:	f1ba 0f00 	cmp.w	r10, #0
30013e64:	d03c      	beq.n	30013ee0 <command_loop+0xe8>
                if (isspace(c))
30013e66:	4650      	mov	r0, r10
30013e68:	eb08 0705 	add.w	r7, r8, r5
30013e6c:	f000 ff3c 	bl	30014ce8 <isspace>
30013e70:	2800      	cmp	r0, #0
30013e72:	d13e      	bne.n	30013ef2 <command_loop+0xfa>
                else if (c == ';')
30013e74:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
30013e78:	f000 80fb 	beq.w	30014072 <command_loop+0x27a>
                if (c == '"') {
30013e7c:	f1ba 0f22 	cmp.w	r10, #34	; 0x22
        char c = inbuffer[inpos];
30013e80:	eb0b 0004 	add.w	r0, r11, r4
30013e84:	eb08 0705 	add.w	r7, r8, r5
                args[arg].str = &buffer[outpos];
30013e88:	eb06 0286 	add.w	r2, r6, r6, lsl #2
                if (c == '"') {
30013e8c:	d041      	beq.n	30013f12 <command_loop+0x11a>
                } else if (c == '$') {
30013e8e:	f1ba 0f24 	cmp.w	r10, #36	; 0x24
30013e92:	d06c      	beq.n	30013f6e <command_loop+0x176>
                    args[arg].str = &buffer[outpos];
30013e94:	9b00      	ldr	r3, [sp, #0]
30013e96:	46ba      	mov	r10, r7
30013e98:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
30013e9c:	7807      	ldrb	r7, [r0, #0]
        char c = inbuffer[inpos];
30013e9e:	9001      	str	r0, [sp, #4]
                if (isspace(c) || c == ';') {
30013ea0:	4638      	mov	r0, r7
                if (c == '\0') {
30013ea2:	2f00      	cmp	r7, #0
30013ea4:	d04d      	beq.n	30013f42 <command_loop+0x14a>
                if (isspace(c) || c == ';') {
30013ea6:	f000 ff1f 	bl	30014ce8 <isspace>
30013eaa:	f1a7 033b 	sub.w	r3, r7, #59	; 0x3b
30013eae:	fab3 f383 	clz	r3, r3
30013eb2:	3501      	adds	r5, #1
30013eb4:	095b      	lsrs	r3, r3, #5
30013eb6:	2800      	cmp	r0, #0
30013eb8:	bf0c      	ite	eq
30013eba:	4618      	moveq	r0, r3
30013ebc:	2001      	movne	r0, #1
30013ebe:	2800      	cmp	r0, #0
30013ec0:	f000 80cc 	beq.w	3001405c <command_loop+0x264>
                    buffer[outpos] = 0;
30013ec4:	f88a 9000 	strb.w	r9, [r10]
                    arg++;
30013ec8:	3601      	adds	r6, #1
                    if (arg == arg_count)
30013eca:	2e10      	cmp	r6, #16
30013ecc:	f000 8115 	beq.w	300140fa <command_loop+0x302>
30013ed0:	9b01      	ldr	r3, [sp, #4]
30013ed2:	eb08 0105 	add.w	r1, r8, r5
30013ed6:	f893 a000 	ldrb.w	r10, [r3]
                if (c == '\0')
30013eda:	f1ba 0f00 	cmp.w	r10, #0
30013ede:	d1c2      	bne.n	30013e66 <command_loop+0x6e>
30013ee0:	4647      	mov	r7, r8
    *continuebuffer = NULL;
30013ee2:	46d3      	mov	r11, r10
30013ee4:	e07a      	b.n	30013fdc <command_loop+0x1e4>
                    inpos++; // consume the space
30013ee6:	3401      	adds	r4, #1
30013ee8:	f81b a004 	ldrb.w	r10, [r11, r4]
                if (c == '\0')
30013eec:	f1ba 0f00 	cmp.w	r10, #0
30013ef0:	d0f6      	beq.n	30013ee0 <command_loop+0xe8>
                } else if (!isspace(c)) {
30013ef2:	4650      	mov	r0, r10
                if (c == ';') {
30013ef4:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
30013ef8:	d06b      	beq.n	30013fd2 <command_loop+0x1da>
                } else if (!isspace(c)) {
30013efa:	f000 fef5 	bl	30014ce8 <isspace>
30013efe:	4639      	mov	r1, r7
30013f00:	2800      	cmp	r0, #0
30013f02:	d1f0      	bne.n	30013ee6 <command_loop+0xee>
                if (c == '"') {
30013f04:	f1ba 0f22 	cmp.w	r10, #34	; 0x22
        char c = inbuffer[inpos];
30013f08:	eb0b 0004 	add.w	r0, r11, r4
                args[arg].str = &buffer[outpos];
30013f0c:	eb06 0286 	add.w	r2, r6, r6, lsl #2
                if (c == '"') {
30013f10:	d1bd      	bne.n	30013e8e <command_loop+0x96>
                args[arg].str = &buffer[outpos];
30013f12:	9b00      	ldr	r3, [sp, #0]
                inpos++; // consume the quote
30013f14:	3401      	adds	r4, #1
                args[arg].str = &buffer[outpos];
30013f16:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
30013f1a:	46ba      	mov	r10, r7
30013f1c:	f81b 2004 	ldrb.w	r2, [r11, r4]
30013f20:	1c6b      	adds	r3, r5, #1
                if (c == '\0') {
30013f22:	b172      	cbz	r2, 30013f42 <command_loop+0x14a>
                if (c == '"') {
30013f24:	2a22      	cmp	r2, #34	; 0x22
30013f26:	eb08 0c03 	add.w	r12, r8, r3
30013f2a:	f000 8089 	beq.w	30014040 <command_loop+0x248>
30013f2e:	461d      	mov	r5, r3
                inpos++;
30013f30:	3401      	adds	r4, #1
                buffer[outpos] = c;
30013f32:	f88a 2000 	strb.w	r2, [r10]
30013f36:	1c6b      	adds	r3, r5, #1
                inpos++;
30013f38:	46e2      	mov	r10, r12
30013f3a:	f81b 2004 	ldrb.w	r2, [r11, r4]
                if (c == '\0') {
30013f3e:	2a00      	cmp	r2, #0
30013f40:	d1f0      	bne.n	30013f24 <command_loop+0x12c>
    buffer[outpos] = 0;
30013f42:	2200      	movs	r2, #0
30013f44:	4647      	mov	r7, r8
30013f46:	4693      	mov	r11, r2
                    arg++;
30013f48:	3601      	adds	r6, #1
    buffer[outpos] = 0;
30013f4a:	f88a 2000 	strb.w	r2, [r10]
30013f4e:	e04a      	b.n	30013fe6 <command_loop+0x1ee>
            if (showprompt)
30013f50:	9b04      	ldr	r3, [sp, #16]
30013f52:	2b00      	cmp	r3, #0
30013f54:	f040 8096 	bne.w	30014084 <command_loop+0x28c>
            int len = get_line(&buffer, get_line_cookie);
30013f58:	9906      	ldr	r1, [sp, #24]
30013f5a:	a809      	add	r0, sp, #36	; 0x24
30013f5c:	9b05      	ldr	r3, [sp, #20]
30013f5e:	4798      	blx	r3
            if (len < 0)
30013f60:	2800      	cmp	r0, #0
30013f62:	f2c0 80d3 	blt.w	3001410c <command_loop+0x314>
            if (len == 0)
30013f66:	d0f3      	beq.n	30013f50 <command_loop+0x158>
30013f68:	f8dd b024 	ldr.w	r11, [r13, #36]	; 0x24
30013f6c:	e770      	b.n	30013e50 <command_loop+0x58>
                args[arg].str = &buffer[outpos];
30013f6e:	9b00      	ldr	r3, [sp, #0]
                inpos++; // consume the dollar sign
30013f70:	3401      	adds	r4, #1
                args[arg].str = &buffer[outpos];
30013f72:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
30013f76:	eb0b 0204 	add.w	r2, r11, r4
30013f7a:	463b      	mov	r3, r7
30013f7c:	462f      	mov	r7, r5
30013f7e:	4615      	mov	r5, r2
30013f80:	f81b a004 	ldrb.w	r10, [r11, r4]
                if (c == '\0' || isspace(c) || c == ';') {
30013f84:	4650      	mov	r0, r10
30013f86:	f1ba 0f00 	cmp.w	r10, #0
30013f8a:	d00d      	beq.n	30013fa8 <command_loop+0x1b0>
30013f8c:	9301      	str	r3, [sp, #4]
30013f8e:	f000 feab 	bl	30014ce8 <isspace>
30013f92:	9b01      	ldr	r3, [sp, #4]
30013f94:	3000      	adds	r0, #0
30013f96:	bf18      	it	ne
30013f98:	2001      	movne	r0, #1
30013f9a:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
30013f9e:	bf08      	it	eq
30013fa0:	f040 0001 	orreq.w	r0, r0, #1
30013fa4:	2800      	cmp	r0, #0
30013fa6:	d067      	beq.n	30014078 <command_loop+0x280>
30013fa8:	462a      	mov	r2, r5
                    arg++;
30013faa:	3601      	adds	r6, #1
30013fac:	463d      	mov	r5, r7
                    if (arg == arg_count)
30013fae:	2e10      	cmp	r6, #16
30013fb0:	461f      	mov	r7, r3
                        buffer[outpos++] = '0';
30013fb2:	f105 0101 	add.w	r1, r5, #1
30013fb6:	f04f 0330 	mov.w	r3, #48	; 0x30
                        buffer[outpos++] = 0;
30013fba:	f105 0502 	add.w	r5, r5, #2
                        buffer[outpos++] = '0';
30013fbe:	703b      	strb	r3, [r7, #0]
                        buffer[outpos++] = 0;
30013fc0:	f808 9001 	strb.w	r9, [r8, r1]
                    if (arg == arg_count)
30013fc4:	f000 8099 	beq.w	300140fa <command_loop+0x302>
30013fc8:	f892 a000 	ldrb.w	r10, [r2]
30013fcc:	eb08 0105 	add.w	r1, r8, r5
30013fd0:	e746      	b.n	30013e60 <command_loop+0x68>
30013fd2:	463a      	mov	r2, r7
30013fd4:	4647      	mov	r7, r8
30013fd6:	4611      	mov	r1, r2
                inpos++; // consume the ';'
30013fd8:	3401      	adds	r4, #1
                *continuebuffer = &inbuffer[inpos];
30013fda:	44a3      	add	r11, r4
    buffer[outpos] = 0;
30013fdc:	2200      	movs	r2, #0
30013fde:	700a      	strb	r2, [r1, #0]
        } else if (argc == 0) {
30013fe0:	2e00      	cmp	r6, #0
30013fe2:	f43f af2f 	beq.w	30013e44 <command_loop+0x4c>
        convert_args(argc, args);
30013fe6:	9c00      	ldr	r4, [sp, #0]
30013fe8:	4630      	mov	r0, r6
30013fea:	4621      	mov	r1, r4
30013fec:	f7ff febc 	bl	30013d68 <convert_args>
        const cmd *command = match_command(args[0].str, CMD_AVAIL_NORMAL);
30013ff0:	2101      	movs	r1, #1
30013ff2:	6820      	ldr	r0, [r4, #0]
30013ff4:	f7ff fe8e 	bl	30013d14 <match_command>
        if (!command) {
30013ff8:	4604      	mov	r4, r0
30013ffa:	2800      	cmp	r0, #0
30013ffc:	d06a      	beq.n	300140d4 <command_loop+0x2dc>
        if (!locked)
30013ffe:	9b02      	ldr	r3, [sp, #8]
30014000:	2b00      	cmp	r3, #0
30014002:	d046      	beq.n	30014092 <command_loop+0x29a>
        lastresult = command->cmd_callback(argc, args);
30014004:	f8dd 8000 	ldr.w	r8, [r13]
        abort_script = false;
30014008:	2500      	movs	r5, #0
        lastresult = command->cmd_callback(argc, args);
3001400a:	68a2      	ldr	r2, [r4, #8]
3001400c:	4641      	mov	r1, r8
        abort_script = false;
3001400e:	9c03      	ldr	r4, [sp, #12]
        lastresult = command->cmd_callback(argc, args);
30014010:	4630      	mov	r0, r6
        abort_script = false;
30014012:	7025      	strb	r5, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
30014014:	4790      	blx	r2
30014016:	f64d 0250 	movw	r2, #55376	; 0xd850
        if (abort_script)
3001401a:	7821      	ldrb	r1, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
3001401c:	f2c3 0202 	movt	r2, #12290	; 0x3002
30014020:	6010      	str	r0, [r2, #0]
        if (abort_script)
30014022:	2900      	cmp	r1, #0
30014024:	f43f af0e 	beq.w	30013e44 <command_loop+0x4c>
        abort_script = false;
30014028:	9b03      	ldr	r3, [sp, #12]
3001402a:	701d      	strb	r5, [r3, #0]
    free(outbuf);
3001402c:	4638      	mov	r0, r7
3001402e:	f000 fbad 	bl	3001478c <free>
    free(args);
30014032:	4640      	mov	r0, r8
30014034:	f000 fbaa 	bl	3001478c <free>
    return NO_ERROR;
30014038:	2000      	movs	r0, #0
}
3001403a:	b00b      	add	sp, #44	; 0x2c
3001403c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                    buffer[outpos] = 0;
30014040:	f88a 9000 	strb.w	r9, [r10]
                    arg++;
30014044:	3601      	adds	r6, #1
                    if (arg == arg_count)
30014046:	2e10      	cmp	r6, #16
30014048:	d063      	beq.n	30014112 <command_loop+0x31a>
                buffer[outpos] = c;
3001404a:	f88c 2000 	strb.w	r2, [r12]
3001404e:	3502      	adds	r5, #2
                inpos++;
30014050:	3401      	adds	r4, #1
30014052:	f81b a004 	ldrb.w	r10, [r11, r4]
30014056:	eb08 0105 	add.w	r1, r8, r5
3001405a:	e701      	b.n	30013e60 <command_loop+0x68>
                    buffer[outpos] = c;
3001405c:	f88a 7000 	strb.w	r7, [r10]
                    inpos++;
30014060:	3401      	adds	r4, #1
30014062:	eb0b 0304 	add.w	r3, r11, r4
30014066:	f81b 7004 	ldrb.w	r7, [r11, r4]
3001406a:	eb08 0a05 	add.w	r10, r8, r5
3001406e:	9301      	str	r3, [sp, #4]
30014070:	e716      	b.n	30013ea0 <command_loop+0xa8>
30014072:	4647      	mov	r7, r8
30014074:	1979      	adds	r1, r7, r5
30014076:	e7af      	b.n	30013fd8 <command_loop+0x1e0>
                    inpos++;
30014078:	3401      	adds	r4, #1
3001407a:	f81b a004 	ldrb.w	r10, [r11, r4]
3001407e:	eb0b 0504 	add.w	r5, r11, r4
30014082:	e77f      	b.n	30013f84 <command_loop+0x18c>
                fputs("] ", stdout);
30014084:	4b24      	ldr	r3, [pc, #144]	; (30014118 <command_loop+0x320>)
30014086:	2202      	movs	r2, #2
30014088:	9807      	ldr	r0, [sp, #28]
3001408a:	2101      	movs	r1, #1
3001408c:	f001 fd64 	bl	30015b58 <fwrite>
30014090:	e762      	b.n	30013f58 <command_loop+0x160>
            mutex_acquire(command_lock);
30014092:	f64d 0540 	movw	r5, #55360	; 0xd840
30014096:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3001409a:	f2c3 0502 	movt	r5, #12290	; 0x3002
3001409e:	6828      	ldr	r0, [r5, #0]
300140a0:	f7fd fcc4 	bl	30011a2c <mutex_acquire_timeout>
        lastresult = command->cmd_callback(argc, args);
300140a4:	f8dd 8000 	ldr.w	r8, [r13]
300140a8:	68a2      	ldr	r2, [r4, #8]
300140aa:	4630      	mov	r0, r6
        abort_script = false;
300140ac:	9c03      	ldr	r4, [sp, #12]
        lastresult = command->cmd_callback(argc, args);
300140ae:	4641      	mov	r1, r8
        abort_script = false;
300140b0:	9e02      	ldr	r6, [sp, #8]
300140b2:	7026      	strb	r6, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
300140b4:	4790      	blx	r2
300140b6:	f64d 0250 	movw	r2, #55376	; 0xd850
        if (abort_script)
300140ba:	7821      	ldrb	r1, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
300140bc:	f2c3 0202 	movt	r2, #12290	; 0x3002
300140c0:	6010      	str	r0, [r2, #0]
            mutex_release(command_lock);
300140c2:	6828      	ldr	r0, [r5, #0]
        if (abort_script)
300140c4:	b119      	cbz	r1, 300140ce <command_loop+0x2d6>
        abort_script = false;
300140c6:	7026      	strb	r6, [r4, #0]
            mutex_release(command_lock);
300140c8:	f7fd fcdc 	bl	30011a84 <mutex_release>
300140cc:	e7ae      	b.n	3001402c <command_loop+0x234>
300140ce:	f7fd fcd9 	bl	30011a84 <mutex_release>
300140d2:	e6b7      	b.n	30013e44 <command_loop+0x4c>
            if (showprompt)
300140d4:	9b04      	ldr	r3, [sp, #16]
300140d6:	2b00      	cmp	r3, #0
300140d8:	f43f aeb4 	beq.w	30013e44 <command_loop+0x4c>
                printf("command not found\n");
300140dc:	f640 70e0 	movw	r0, #4064	; 0xfe0
300140e0:	f2c3 0002 	movt	r0, #12290	; 0x3002
300140e4:	f001 fd64 	bl	30015bb0 <_printf>
300140e8:	e6ac      	b.n	30013e44 <command_loop+0x4c>
        free(args);
300140ea:	4640      	mov	r0, r8
300140ec:	f000 fb4e 	bl	3001478c <free>
    return ERR_NO_MEMORY;
300140f0:	f06f 0004 	mvn.w	r0, #4
}
300140f4:	b00b      	add	sp, #44	; 0x2c
300140f6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
300140fa:	4647      	mov	r7, r8
300140fc:	eb08 0c05 	add.w	r12, r8, r5
    buffer[outpos] = 0;
30014100:	2300      	movs	r3, #0
30014102:	2610      	movs	r6, #16
30014104:	469b      	mov	r11, r3
30014106:	f88c 3000 	strb.w	r3, [r12]
3001410a:	e76c      	b.n	30013fe6 <command_loop+0x1ee>
3001410c:	f8dd 8000 	ldr.w	r8, [r13]
30014110:	e78c      	b.n	3001402c <command_loop+0x234>
30014112:	4647      	mov	r7, r8
30014114:	e7f4      	b.n	30014100 <command_loop+0x308>
30014116:	bf00      	nop
30014118:	30025434 	.word	0x30025434

3001411c <console_init>:
{
3001411c:	b570      	push	{r4, r5, r6, r14}
    command_lock = calloc(sizeof(mutex_t), 1);
3001411e:	2101      	movs	r1, #1
30014120:	201c      	movs	r0, #28
30014122:	f000 fb13 	bl	3001474c <calloc>
30014126:	f64d 0340 	movw	r3, #55360	; 0xd840
    for (block = __commands_start; block != __commands_end; block++) {
3001412a:	f245 4458 	movw	r4, #21592	; 0x5458
    command_lock = calloc(sizeof(mutex_t), 1);
3001412e:	f2c3 0302 	movt	r3, #12290	; 0x3002
    for (block = __commands_start; block != __commands_end; block++) {
30014132:	f2c3 0402 	movt	r4, #12290	; 0x3002
    command_lock = calloc(sizeof(mutex_t), 1);
30014136:	6018      	str	r0, [r3, #0]
    mutex_init(command_lock);
30014138:	f7fd fc3e 	bl	300119b8 <mutex_init>
    for (block = __commands_start; block != __commands_end; block++) {
3001413c:	f245 43ac 	movw	r3, #21676	; 0x54ac
30014140:	f2c3 0302 	movt	r3, #12290	; 0x3002
30014144:	429c      	cmp	r4, r3
30014146:	d027      	beq.n	30014198 <console_init+0x7c>
30014148:	f64d 053c 	movw	r5, #55356	; 0xd83c
3001414c:	f104 020c 	add.w	r2, r4, #12
30014150:	1a9b      	subs	r3, r3, r2
30014152:	4622      	mov	r2, r4
30014154:	f2c3 0502 	movt	r5, #12290	; 0x3002
30014158:	089b      	lsrs	r3, r3, #2
3001415a:	6828      	ldr	r0, [r5, #0]
3001415c:	eb03 0183 	add.w	r1, r3, r3, lsl #2
30014160:	eb01 1141 	add.w	r1, r1, r1, lsl #5
30014164:	eb03 0141 	add.w	r1, r3, r1, lsl #1
30014168:	eb01 1141 	add.w	r1, r1, r1, lsl #5
3001416c:	ebc1 31c1 	rsb	r1, r1, r1, lsl #15
30014170:	eb03 0341 	add.w	r3, r3, r1, lsl #1
30014174:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
30014178:	1c4e      	adds	r6, r1, #1
3001417a:	eb06 0646 	add.w	r6, r6, r6, lsl #1
3001417e:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    block->next = command_list;
30014182:	4613      	mov	r3, r2
30014184:	f843 0b0c 	str.w	r0, [r3], #12
    for (block = __commands_start; block != __commands_end; block++) {
30014188:	42b3      	cmp	r3, r6
3001418a:	4610      	mov	r0, r2
3001418c:	461a      	mov	r2, r3
3001418e:	d1f8      	bne.n	30014182 <console_init+0x66>
30014190:	230c      	movs	r3, #12
30014192:	fb03 4101 	mla	r1, r3, r1, r4
30014196:	6029      	str	r1, [r5, #0]
    history = calloc(1, HISTORY_LEN * LINE_LEN);
30014198:	f44f 6100 	mov.w	r1, #2048	; 0x800
3001419c:	2001      	movs	r0, #1
3001419e:	f000 fad5 	bl	3001474c <calloc>
300141a2:	f64d 0348 	movw	r3, #55368	; 0xd848
    history_next = 0;
300141a6:	f64d 024c 	movw	r2, #55372	; 0xd84c
300141aa:	2100      	movs	r1, #0
    history = calloc(1, HISTORY_LEN * LINE_LEN);
300141ac:	f2c3 0302 	movt	r3, #12290	; 0x3002
    history_next = 0;
300141b0:	f2c3 0202 	movt	r2, #12290	; 0x3002
300141b4:	6011      	str	r1, [r2, #0]
    history = calloc(1, HISTORY_LEN * LINE_LEN);
300141b6:	6018      	str	r0, [r3, #0]
}
300141b8:	4608      	mov	r0, r1
300141ba:	bd70      	pop	{r4, r5, r6, r15}

300141bc <console_start>:
{
300141bc:	b538      	push	{r3, r4, r5, r14}
    debug_buffer = malloc(LINE_LEN);
300141be:	2080      	movs	r0, #128	; 0x80
300141c0:	f64d 0544 	movw	r5, #55364	; 0xd844
300141c4:	f000 fa90 	bl	300146e8 <malloc>
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
300141c8:	f643 24d5 	movw	r4, #15061	; 0x3ad5
    debug_buffer = malloc(LINE_LEN);
300141cc:	f2c3 0502 	movt	r5, #12290	; 0x3002
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
300141d0:	f2c3 0401 	movt	r4, #12289	; 0x3001
    debug_buffer = malloc(LINE_LEN);
300141d4:	6028      	str	r0, [r5, #0]
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
300141d6:	2300      	movs	r3, #0
300141d8:	2201      	movs	r2, #1
300141da:	4619      	mov	r1, r3
300141dc:	4620      	mov	r0, r4
300141de:	f7ff fe0b 	bl	30013df8 <command_loop>
300141e2:	2800      	cmp	r0, #0
300141e4:	d0f7      	beq.n	300141d6 <console_start+0x1a>
    free (debug_buffer);
300141e6:	6828      	ldr	r0, [r5, #0]
}
300141e8:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    free (debug_buffer);
300141ec:	f000 bace 	b.w	3001478c <free>

300141f0 <spin>:
#include <platform.h>
#include <platform/debug.h>
#include <kernel/spinlock.h>

void spin(uint32_t usecs)
{
300141f0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
300141f2:	4604      	mov	r4, r0
    lk_bigtime_t start = current_time_hires();
300141f4:	f7ec fb8c 	bl	30000910 <current_time_hires>
300141f8:	2500      	movs	r5, #0
300141fa:	4606      	mov	r6, r0
300141fc:	460f      	mov	r7, r1

    while ((current_time_hires() - start) < usecs)
300141fe:	f7ec fb87 	bl	30000910 <current_time_hires>
30014202:	1b82      	subs	r2, r0, r6
30014204:	eb61 0307 	sbc.w	r3, r1, r7
30014208:	42ab      	cmp	r3, r5
3001420a:	bf08      	it	eq
3001420c:	42a2      	cmpeq	r2, r4
3001420e:	d3f6      	bcc.n	300141fe <spin+0xe>
        ;
}
30014210:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
30014212:	bf00      	nop

30014214 <_panic>:

void _panic(void *caller, const char *fmt, ...)
{
30014214:	b40e      	push	{r1, r2, r3}
30014216:	b500      	push	{r14}
    printf("panic (caller %p): ", caller);
30014218:	4601      	mov	r1, r0
{
3001421a:	b082      	sub	sp, #8
    printf("panic (caller %p): ", caller);
3001421c:	f241 0038 	movw	r0, #4152	; 0x1038
{
30014220:	ac03      	add	r4, sp, #12
    printf("panic (caller %p): ", caller);
30014222:	f2c3 0002 	movt	r0, #12290	; 0x3002
{
30014226:	f854 5b04 	ldr.w	r5, [r4], #4
    printf("panic (caller %p): ", caller);
3001422a:	f001 fcc1 	bl	30015bb0 <_printf>

    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
3001422e:	4621      	mov	r1, r4
30014230:	4628      	mov	r0, r5
    va_start(ap, fmt);
30014232:	9401      	str	r4, [sp, #4]
    vprintf(fmt, ap);
30014234:	f001 fcd2 	bl	30015bdc <_vprintf>
    va_end(ap);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
30014238:	2109      	movs	r1, #9
3001423a:	2000      	movs	r0, #0
3001423c:	f7ec f964 	bl	30000508 <platform_halt>

30014240 <hexdump>:

    return &panic_fd;
}

void hexdump(const void *ptr, size_t len)
{
30014240:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30014244:	b089      	sub	sp, #36	; 0x24
    addr_t address = (addr_t)ptr;
    size_t count;

    for (count = 0 ; count < len; count += 16) {
30014246:	9102      	str	r1, [sp, #8]
30014248:	2900      	cmp	r1, #0
3001424a:	d06d      	beq.n	30014328 <hexdump+0xe8>
            uint8_t  cbuf[16];
        } u;
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
        size_t i;

        printf("0x%08lx: ", address);
3001424c:	f241 034c 	movw	r3, #4172	; 0x104c
        for (i = 0; i < s / 4; i++) {
            u.buf[i] = ((const uint32_t *)address)[i];
            printf("%08x ", u.buf[i]);
30014250:	f241 0858 	movw	r8, #4184	; 0x1058
        }
        for (; i < 4; i++) {
            printf("         ");
30014254:	f241 0760 	movw	r7, #4192	; 0x1060
        printf("0x%08lx: ", address);
30014258:	f2c3 0302 	movt	r3, #12290	; 0x3002
3001425c:	4606      	mov	r6, r0
            printf("%08x ", u.buf[i]);
3001425e:	f2c3 0802 	movt	r8, #12290	; 0x3002
        printf("0x%08lx: ", address);
30014262:	9303      	str	r3, [sp, #12]
            printf("         ");
30014264:	f2c3 0702 	movt	r7, #12290	; 0x3002
    for (count = 0 ; count < len; count += 16) {
30014268:	2300      	movs	r3, #0
3001426a:	9301      	str	r3, [sp, #4]
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
3001426c:	e9dd 2301 	ldrd	r2, r3, [r13, #4]
        printf("0x%08lx: ", address);
30014270:	4631      	mov	r1, r6
30014272:	9803      	ldr	r0, [sp, #12]
30014274:	f10d 0910 	add.w	r9, r13, #16
        for (i = 0; i < s / 4; i++) {
30014278:	46b2      	mov	r10, r6
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
3001427a:	1a9c      	subs	r4, r3, r2
3001427c:	2c10      	cmp	r4, #16
3001427e:	bf28      	it	cs
30014280:	2410      	movcs	r4, #16
        printf("0x%08lx: ", address);
30014282:	f001 fc95 	bl	30015bb0 <_printf>
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
30014286:	3403      	adds	r4, #3
30014288:	f024 0503 	bic.w	r5, r4, #3
        for (i = 0; i < s / 4; i++) {
3001428c:	08a4      	lsrs	r4, r4, #2
3001428e:	eb06 0b84 	add.w	r11, r6, r4, lsl #2
            u.buf[i] = ((const uint32_t *)address)[i];
30014292:	f85a 3b04 	ldr.w	r3, [r10], #4
            printf("%08x ", u.buf[i]);
30014296:	4640      	mov	r0, r8
            u.buf[i] = ((const uint32_t *)address)[i];
30014298:	f849 3b04 	str.w	r3, [r9], #4
            printf("%08x ", u.buf[i]);
3001429c:	4619      	mov	r1, r3
3001429e:	f001 fc87 	bl	30015bb0 <_printf>
        for (i = 0; i < s / 4; i++) {
300142a2:	45d3      	cmp	r11, r10
300142a4:	d1f5      	bne.n	30014292 <hexdump+0x52>
        for (; i < 4; i++) {
300142a6:	2c04      	cmp	r4, #4
300142a8:	d005      	beq.n	300142b6 <hexdump+0x76>
            printf("         ");
300142aa:	4638      	mov	r0, r7
        for (; i < 4; i++) {
300142ac:	3401      	adds	r4, #1
            printf("         ");
300142ae:	f001 fc7f 	bl	30015bb0 <_printf>
        for (; i < 4; i++) {
300142b2:	2c04      	cmp	r4, #4
300142b4:	d1f9      	bne.n	300142aa <hexdump+0x6a>
        }
        printf("|");
300142b6:	f241 006c 	movw	r0, #4204	; 0x106c
        for (i=0; i < 16; i++) {
            char c = u.cbuf[i];
            if (i < s && isprint(c)) {
                printf("%c", c);
            } else {
                printf(".");
300142ba:	f241 0474 	movw	r4, #4212	; 0x1074
                printf("%c", c);
300142be:	f241 0b70 	movw	r11, #4208	; 0x1070
        printf("|");
300142c2:	f2c3 0002 	movt	r0, #12290	; 0x3002
300142c6:	f001 fc73 	bl	30015bb0 <_printf>
                printf(".");
300142ca:	f2c3 0402 	movt	r4, #12290	; 0x3002
        for (i=0; i < 16; i++) {
300142ce:	f04f 0a00 	mov.w	r10, #0
                printf("%c", c);
300142d2:	f2c3 0b02 	movt	r11, #12290	; 0x3002
300142d6:	e007      	b.n	300142e8 <hexdump+0xa8>
                printf(".");
300142d8:	4620      	mov	r0, r4
        for (i=0; i < 16; i++) {
300142da:	f10a 0a01 	add.w	r10, r10, #1
                printf(".");
300142de:	f001 fc67 	bl	30015bb0 <_printf>
        for (i=0; i < 16; i++) {
300142e2:	f1ba 0f10 	cmp.w	r10, #16
300142e6:	d012      	beq.n	3001430e <hexdump+0xce>
            if (i < s && isprint(c)) {
300142e8:	4555      	cmp	r5, r10
300142ea:	d9f5      	bls.n	300142d8 <hexdump+0x98>
300142ec:	ab04      	add	r3, sp, #16
300142ee:	f813 900a 	ldrb.w	r9, [r3, r10]
300142f2:	4648      	mov	r0, r9
300142f4:	f000 fd10 	bl	30014d18 <isprint>
300142f8:	2800      	cmp	r0, #0
300142fa:	d0ed      	beq.n	300142d8 <hexdump+0x98>
                printf("%c", c);
300142fc:	4649      	mov	r1, r9
300142fe:	4658      	mov	r0, r11
        for (i=0; i < 16; i++) {
30014300:	f10a 0a01 	add.w	r10, r10, #1
                printf("%c", c);
30014304:	f001 fc54 	bl	30015bb0 <_printf>
        for (i=0; i < 16; i++) {
30014308:	f1ba 0f10 	cmp.w	r10, #16
3001430c:	d1ec      	bne.n	300142e8 <hexdump+0xa8>
    for (count = 0 ; count < len; count += 16) {
3001430e:	9c01      	ldr	r4, [sp, #4]
            }
        }
        printf("|\n");
30014310:	f241 0078 	movw	r0, #4216	; 0x1078
30014314:	f2c3 0002 	movt	r0, #12290	; 0x3002
    for (count = 0 ; count < len; count += 16) {
30014318:	3410      	adds	r4, #16
        address += 16;
3001431a:	3610      	adds	r6, #16
    for (count = 0 ; count < len; count += 16) {
3001431c:	9401      	str	r4, [sp, #4]
        printf("|\n");
3001431e:	f001 fc47 	bl	30015bb0 <_printf>
    for (count = 0 ; count < len; count += 16) {
30014322:	9b02      	ldr	r3, [sp, #8]
30014324:	42a3      	cmp	r3, r4
30014326:	d8a1      	bhi.n	3001426c <hexdump+0x2c>
    }
}
30014328:	b009      	add	sp, #36	; 0x24
3001432a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
3001432e:	bf00      	nop

30014330 <hexdump8_ex>:

void hexdump8_ex(const void *ptr, size_t len, uint64_t disp_addr)
{
30014330:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30014334:	4616      	mov	r6, r2
    addr_t address = (addr_t)ptr;
    size_t count;
    size_t i;
    const char *addr_fmt = ((disp_addr + len) > 0xFFFFFFFF)
30014336:	1852      	adds	r2, r2, r1
{
30014338:	461f      	mov	r7, r3
    const char *addr_fmt = ((disp_addr + len) > 0xFFFFFFFF)
3001433a:	f143 0300 	adc.w	r3, r3, #0
                           ? "0x%016llx: "
                           : "0x%08llx: ";
3001433e:	f241 047c 	movw	r4, #4220	; 0x107c
30014342:	2b01      	cmp	r3, #1
30014344:	f2c3 0402 	movt	r4, #12290	; 0x3002
30014348:	f241 0388 	movw	r3, #4232	; 0x1088
3001434c:	bf08      	it	eq
3001434e:	2a00      	cmpeq	r2, #0
30014350:	f2c3 0302 	movt	r3, #12290	; 0x3002
30014354:	bf28      	it	cs
30014356:	4623      	movcs	r3, r4
{
30014358:	b087      	sub	sp, #28
                           : "0x%08llx: ";
3001435a:	9301      	str	r3, [sp, #4]

    for (count = 0 ; count < len; count += 16) {
3001435c:	2900      	cmp	r1, #0
3001435e:	d055      	beq.n	3001440c <hexdump8_ex+0xdc>
        for (i=0; i < MIN(len - count, 16); i++) {
            printf("%02hhx ", *(const uint8_t *)(address + i));
        }

        for (; i < 16; i++) {
            printf("   ");
30014360:	f241 099c 	movw	r9, #4252	; 0x109c
            printf("%02hhx ", *(const uint8_t *)(address + i));
30014364:	f241 0894 	movw	r8, #4244	; 0x1094
        }

        printf("|");
30014368:	f241 036c 	movw	r3, #4204	; 0x106c
3001436c:	468a      	mov	r10, r1
3001436e:	e9cd 6702 	strd	r6, r7, [r13, #8]
30014372:	f2c3 0302 	movt	r3, #12290	; 0x3002
            printf("   ");
30014376:	f2c3 0902 	movt	r9, #12290	; 0x3002
    for (count = 0 ; count < len; count += 16) {
3001437a:	2700      	movs	r7, #0
            printf("%02hhx ", *(const uint8_t *)(address + i));
3001437c:	f2c3 0802 	movt	r8, #12290	; 0x3002
30014380:	9005      	str	r0, [sp, #20]
        printf("|");
30014382:	9304      	str	r3, [sp, #16]
        printf(addr_fmt, disp_addr + count);
30014384:	9801      	ldr	r0, [sp, #4]
        for (i=0; i < MIN(len - count, 16); i++) {
30014386:	ebaa 0307 	sub.w	r3, r10, r7
3001438a:	461c      	mov	r4, r3
3001438c:	9300      	str	r3, [sp, #0]
        printf(addr_fmt, disp_addr + count);
3001438e:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30014392:	19d2      	adds	r2, r2, r7
30014394:	f143 0300 	adc.w	r3, r3, #0
        for (i=0; i < MIN(len - count, 16); i++) {
30014398:	2c10      	cmp	r4, #16
3001439a:	bf28      	it	cs
3001439c:	2410      	movcs	r4, #16
        printf(addr_fmt, disp_addr + count);
3001439e:	f001 fc07 	bl	30015bb0 <_printf>
300143a2:	9b05      	ldr	r3, [sp, #20]
        for (i=0; i < MIN(len - count, 16); i++) {
300143a4:	45ba      	cmp	r10, r7
300143a6:	eb03 0507 	add.w	r5, r3, r7
300143aa:	d035      	beq.n	30014418 <hexdump8_ex+0xe8>
300143ac:	46ab      	mov	r11, r5
300143ae:	192e      	adds	r6, r5, r4
            printf("%02hhx ", *(const uint8_t *)(address + i));
300143b0:	f81b 1b01 	ldrb.w	r1, [r11], #1
300143b4:	4640      	mov	r0, r8
300143b6:	f001 fbfb 	bl	30015bb0 <_printf>
        for (i=0; i < MIN(len - count, 16); i++) {
300143ba:	455e      	cmp	r6, r11
300143bc:	d1f8      	bne.n	300143b0 <hexdump8_ex+0x80>
        for (; i < 16; i++) {
300143be:	9b00      	ldr	r3, [sp, #0]
300143c0:	2b0f      	cmp	r3, #15
300143c2:	d826      	bhi.n	30014412 <hexdump8_ex+0xe2>
            printf("   ");
300143c4:	4648      	mov	r0, r9
        for (; i < 16; i++) {
300143c6:	3401      	adds	r4, #1
            printf("   ");
300143c8:	f001 fbf2 	bl	30015bb0 <_printf>
        for (; i < 16; i++) {
300143cc:	2c10      	cmp	r4, #16
300143ce:	d1f9      	bne.n	300143c4 <hexdump8_ex+0x94>
        printf("|");
300143d0:	9804      	ldr	r0, [sp, #16]

        for (i=0; i < MIN(len - count, 16); i++) {
            char c = ((const char *)address)[i];
            printf("%c", isprint(c) ? c : '.');
300143d2:	f241 0470 	movw	r4, #4208	; 0x1070
        printf("|");
300143d6:	f001 fbeb 	bl	30015bb0 <_printf>
            printf("%c", isprint(c) ? c : '.');
300143da:	f2c3 0402 	movt	r4, #12290	; 0x3002
300143de:	f815 bb01 	ldrb.w	r11, [r5], #1
300143e2:	4658      	mov	r0, r11
300143e4:	f000 fc98 	bl	30014d18 <isprint>
300143e8:	2800      	cmp	r0, #0
300143ea:	bf14      	ite	ne
300143ec:	4659      	movne	r1, r11
300143ee:	212e      	moveq	r1, #46	; 0x2e
300143f0:	4620      	mov	r0, r4
300143f2:	f001 fbdd 	bl	30015bb0 <_printf>
        for (i=0; i < MIN(len - count, 16); i++) {
300143f6:	42ae      	cmp	r6, r5
300143f8:	d1f1      	bne.n	300143de <hexdump8_ex+0xae>
        }

        printf("\n");
300143fa:	f24b 5084 	movw	r0, #46468	; 0xb584
    for (count = 0 ; count < len; count += 16) {
300143fe:	3710      	adds	r7, #16
        printf("\n");
30014400:	f2c3 0001 	movt	r0, #12289	; 0x3001
30014404:	f001 fbd4 	bl	30015bb0 <_printf>
    for (count = 0 ; count < len; count += 16) {
30014408:	45ba      	cmp	r10, r7
3001440a:	d8bb      	bhi.n	30014384 <hexdump8_ex+0x54>
        address += 16;
    }
}
3001440c:	b007      	add	sp, #28
3001440e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30014412:	f105 0610 	add.w	r6, r5, #16
30014416:	e7db      	b.n	300143d0 <hexdump8_ex+0xa0>
        for (i=0; i < MIN(len - count, 16); i++) {
30014418:	2400      	movs	r4, #0
3001441a:	462e      	mov	r6, r5
3001441c:	e7d2      	b.n	300143c4 <hexdump8_ex+0x94>
3001441e:	bf00      	nop

30014420 <fastboot_common_init>:

    dprintf(ALWAYS, "%s vid:0x%0x pid:0x%0x\n", __func__, *vid, *pid);
}

fastboot_t *fastboot_common_init(void *addr, uint32_t sz)
{
30014420:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30014424:	4607      	mov	r7, r0
30014426:	b088      	sub	sp, #32
30014428:	460d      	mov	r5, r1
    thread_t *thr;
    fastboot_t *fb;
    uint16_t vid = 0, pid = 0;

    fb = calloc(1, sizeof(fastboot_t));
3001442a:	2001      	movs	r0, #1
3001442c:	f44f 71ac 	mov.w	r1, #344	; 0x158
30014430:	4676      	mov	r6, r14
30014432:	f000 f98b 	bl	3001474c <calloc>
    ASSERT(fb != NULL);
30014436:	2800      	cmp	r0, #0
30014438:	f000 80dd 	beq.w	300145f6 <fastboot_common_init+0x1d6>
3001443c:	4604      	mov	r4, r0
    v = fuse_read(SD_VID_INDEX);
3001443e:	2010      	movs	r0, #16
30014440:	f7f3 f9ce 	bl	300077e0 <fuse_read>
    *pid = v & 0xFFFFU;
30014444:	b286      	uxth	r6, r0
30014446:	4633      	mov	r3, r6
    *vid = (v >> 16) & 0xFFFFU;
30014448:	0c02      	lsrs	r2, r0, #16
    if (*pid == 0)
3001444a:	2e00      	cmp	r6, #0
3001444c:	f000 80ca 	beq.w	300145e4 <fastboot_common_init+0x1c4>
30014450:	fa1f f882 	uxth.w	r8, r2
    if (*vid == 0)
30014454:	b912      	cbnz	r2, 3001445c <fastboot_common_init+0x3c>
30014456:	f641 08d1 	movw	r8, #6353	; 0x18d1
3001445a:	4642      	mov	r2, r8
    dprintf(ALWAYS, "%s vid:0x%0x pid:0x%0x\n", __func__, *vid, *pid);
3001445c:	f241 01b0 	movw	r1, #4272	; 0x10b0
30014460:	f241 1000 	movw	r0, #4352	; 0x1100
30014464:	f2c3 0102 	movt	r1, #12290	; 0x3002
30014468:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001446c:	f001 fba0 	bl	30015bb0 <_printf>
    get_vid_pid(&vid, &pid);

    fb->priv.download_base = (void *)addr;
    fb->priv.download_max  = sz;

    fb->usb.global_base_id    = RES_USB_USB1;
30014470:	f241 0c11 	movw	r12, #4113	; 0x1011
    fb->usb.global_phys_id    = RES_USBPHY_USBPHY1;
30014474:	f241 0112 	movw	r1, #4114	; 0x1012
    fb->usb.priv.vendor_id    = vid;
    fb->usb.priv.product_id   = pid;
    fb->usb.priv.version_id   = SD_VERSION_ID;
    fb->usb.priv.manufacturer = manufacturer;
30014478:	f241 1278 	movw	r2, #4472	; 0x1178
    fb->usb.priv.product      = product;
3001447c:	f241 1384 	movw	r3, #4484	; 0x1184
    fb->usb.global_base_id    = RES_USB_USB1;
30014480:	f2c4 4c6a 	movt	r12, #17514	; 0x446a
    fb->usb.global_phys_id    = RES_USBPHY_USBPHY1;
30014484:	f2c4 4168 	movt	r1, #17512	; 0x4468
    fb->usb.priv.manufacturer = manufacturer;
30014488:	f2c3 0202 	movt	r2, #12290	; 0x3002
    fb->usb.priv.version_id   = SD_VERSION_ID;
3001448c:	f44f 7e80 	mov.w	r14, #256	; 0x100
    fb->usb.priv.product      = product;
30014490:	f2c3 0302 	movt	r3, #12290	; 0x3002
    fb->usb.global_phys_id    = RES_USBPHY_USBPHY1;
30014494:	e9c4 c125 	strd	r12, r1, [r4, #148]	; 0x94
    serial_fuse[0] = fuse_read(SD_UUID_INDEX);
30014498:	2008      	movs	r0, #8
    fb->usb.priv.manufacturer = manufacturer;
3001449a:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
    fb->usb.priv.product      = product;
3001449e:	f8c4 3134 	str.w	r3, [r4, #308]	; 0x134
    fb->usb.priv.version_id   = SD_VERSION_ID;
300144a2:	f8a4 e12c 	strh.w	r14, [r4, #300]	; 0x12c
    fb->priv.download_base = (void *)addr;
300144a6:	61e7      	str	r7, [r4, #28]
    fb->priv.download_max  = sz;
300144a8:	6225      	str	r5, [r4, #32]
    snprintf(serialno, sizeof(serialno), "%02X%02X%02X%02X%02X%02X%02X%02X",
300144aa:	f64d 0554 	movw	r5, #55380	; 0xd854
    fb->usb.priv.vendor_id    = vid;
300144ae:	f8a4 8128 	strh.w	r8, [r4, #296]	; 0x128
    snprintf(serialno, sizeof(serialno), "%02X%02X%02X%02X%02X%02X%02X%02X",
300144b2:	f2c3 0502 	movt	r5, #12290	; 0x3002
    fb->usb.priv.product_id   = pid;
300144b6:	f8a4 612a 	strh.w	r6, [r4, #298]	; 0x12a
    serial_fuse[0] = fuse_read(SD_UUID_INDEX);
300144ba:	f7f3 f991 	bl	300077e0 <fuse_read>
300144be:	4606      	mov	r6, r0
    serial_fuse[1] = fuse_read(SD_UUID_INDEX + 1);
300144c0:	2009      	movs	r0, #9
300144c2:	f7f3 f98d 	bl	300077e0 <fuse_read>
    snprintf(serialno, sizeof(serialno), "%02X%02X%02X%02X%02X%02X%02X%02X",
300144c6:	f3c6 2707 	ubfx	r7, r6, #8, #8
300144ca:	ea4f 6e16 	mov.w	r14, r6, lsr #24
300144ce:	f3c6 4c07 	ubfx	r12, r6, #16, #8
300144d2:	f8cd e008 	str.w	r14, [r13, #8]
300144d6:	e9cd 7c00 	strd	r7, r12, [r13]
    fb->usb.priv.serialno     = get_serialno();
    fb->usb.priv.cfg          = cfg_str;

    fb->fb_init    = fastboot_init;
    fb->fb_stop    = fastboot_stop;
    fb->cb.online  = fastboot_online;
300144da:	f241 1701 	movw	r7, #4353	; 0x1101
300144de:	f2c3 0701 	movt	r7, #12289	; 0x3001
    snprintf(serialno, sizeof(serialno), "%02X%02X%02X%02X%02X%02X%02X%02X",
300144e2:	0e02      	lsrs	r2, r0, #24
300144e4:	f3c0 4307 	ubfx	r3, r0, #16, #8
300144e8:	f3c0 2807 	ubfx	r8, r0, #8, #8
300144ec:	9206      	str	r2, [sp, #24]
300144ee:	b2c1      	uxtb	r1, r0
300144f0:	f241 1218 	movw	r2, #4376	; 0x1118
300144f4:	4628      	mov	r0, r5
300144f6:	9305      	str	r3, [sp, #20]
300144f8:	f2c3 0202 	movt	r2, #12290	; 0x3002
300144fc:	f8cd 8010 	str.w	r8, [r13, #16]
30014500:	b2f3      	uxtb	r3, r6
30014502:	9103      	str	r1, [sp, #12]
30014504:	2111      	movs	r1, #17
30014506:	f001 fae3 	bl	30015ad0 <snprintf>
    dprintf(ALWAYS, "%s serial:%s\n", __func__, serialno);
3001450a:	f241 01a0 	movw	r1, #4256	; 0x10a0
3001450e:	f241 103c 	movw	r0, #4412	; 0x113c
30014512:	462a      	mov	r2, r5
30014514:	f2c3 0102 	movt	r1, #12290	; 0x3002
    fb->usb.priv.cfg          = cfg_str;
30014518:	f241 08bc 	movw	r8, #4284	; 0x10bc
    dprintf(ALWAYS, "%s serial:%s\n", __func__, serialno);
3001451c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30014520:	f001 fb46 	bl	30015bb0 <_printf>
    fb->cb.offline = fastboot_offline;
30014524:	f241 1611 	movw	r6, #4369	; 0x1111
    fb->fb_init    = fastboot_init;
30014528:	f241 2e9d 	movw	r14, #4765	; 0x129d
    fb->fb_stop    = fastboot_stop;
3001452c:	f241 3c9d 	movw	r12, #5021	; 0x139d
    fb->usb_read   = fastboot_usb_read;
30014530:	f241 1215 	movw	r2, #4373	; 0x1115
    fb->usb_write  = fastboot_usb_write;
30014534:	f241 13e9 	movw	r3, #4585	; 0x11e9
    fb->fb_init    = fastboot_init;
30014538:	f2c3 0e01 	movt	r14, #12289	; 0x3001
    fb->fb_stop    = fastboot_stop;
3001453c:	f2c3 0c01 	movt	r12, #12289	; 0x3001
    fb->usb_read   = fastboot_usb_read;
30014540:	f2c3 0201 	movt	r2, #12289	; 0x3001
    fb->usb_write  = fastboot_usb_write;
30014544:	f2c3 0301 	movt	r3, #12289	; 0x3001
    fb->usb.priv.cfg          = cfg_str;
30014548:	f2c3 0802 	movt	r8, #12290	; 0x3002

    fastboot_register_cmd("getvar:", cmd_getvar);
3001454c:	f640 71b5 	movw	r1, #4021	; 0xfb5
    fb->cb.offline = fastboot_offline;
30014550:	f2c3 0601 	movt	r6, #12289	; 0x3001
    fastboot_register_cmd("getvar:", cmd_getvar);
30014554:	f241 104c 	movw	r0, #4428	; 0x114c
30014558:	f2c3 0101 	movt	r1, #12289	; 0x3001
    fb->fb_stop    = fastboot_stop;
3001455c:	e9c4 ec03 	strd	r14, r12, [r4, #12]
    fastboot_register_cmd("getvar:", cmd_getvar);
30014560:	f2c3 0002 	movt	r0, #12290	; 0x3002
    fb->usb_write  = fastboot_usb_write;
30014564:	e9c4 2305 	strd	r2, r3, [r4, #20]
    fb->usb.priv.serialno     = get_serialno();
30014568:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
    fb->usb.priv.cfg          = cfg_str;
3001456c:	f8c4 813c 	str.w	r8, [r4, #316]	; 0x13c
    fb->cb.offline = fastboot_offline;
30014570:	e9c4 7601 	strd	r7, r6, [r4, #4]
    fastboot_register_cmd("getvar:", cmd_getvar);
30014574:	f7fc fc2a 	bl	30010dcc <fastboot_register_cmd>
    fastboot_register_cmd("download:", cmd_download);
30014578:	f241 0165 	movw	r1, #4197	; 0x1065
3001457c:	f241 1054 	movw	r0, #4436	; 0x1154
30014580:	f2c3 0101 	movt	r1, #12289	; 0x3001
30014584:	f2c3 0002 	movt	r0, #12290	; 0x3002
30014588:	f7fc fc20 	bl	30010dcc <fastboot_register_cmd>

    fastboot_register_var("version", "0.5");
3001458c:	f241 1160 	movw	r1, #4448	; 0x1160
30014590:	f24b 702c 	movw	r0, #46892	; 0xb72c
30014594:	f2c3 0102 	movt	r1, #12290	; 0x3002
30014598:	f2c3 0001 	movt	r0, #12289	; 0x3001
3001459c:	f7fc fc2c 	bl	30010df8 <fastboot_register_var>
    fastboot_register_var("name", "fastboot");
300145a0:	f241 1164 	movw	r1, #4452	; 0x1164
300145a4:	f241 1070 	movw	r0, #4464	; 0x1170
300145a8:	f2c3 0102 	movt	r1, #12290	; 0x3002
300145ac:	f2c3 0002 	movt	r0, #12290	; 0x3002
300145b0:	f7fc fc22 	bl	30010df8 <fastboot_register_var>

    fb->fb_init(fb);
300145b4:	68e3      	ldr	r3, [r4, #12]
300145b6:	4620      	mov	r0, r4
300145b8:	4798      	blx	r3

    thr = thread_create("fastboot", fastboot_handler, (void *)fb,
300145ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
300145be:	f640 61cd 	movw	r1, #3789	; 0xecd
300145c2:	f241 1064 	movw	r0, #4452	; 0x1164
300145c6:	9300      	str	r3, [sp, #0]
300145c8:	f2c3 0101 	movt	r1, #12289	; 0x3001
300145cc:	2310      	movs	r3, #16
300145ce:	4622      	mov	r2, r4
300145d0:	f2c3 0002 	movt	r0, #12290	; 0x3002
300145d4:	f7fd fc5c 	bl	30011e90 <thread_create>
                        DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
    thread_resume(thr);
300145d8:	f7fd fcae 	bl	30011f38 <thread_resume>
    return fb;
}
300145dc:	4620      	mov	r0, r4
300145de:	b008      	add	sp, #32
300145e0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    if (*pid == 0)
300145e4:	f44f 439a 	mov.w	r3, #19712	; 0x4d00
300145e8:	fa1f f882 	uxth.w	r8, r2
        *pid = SD_PRODUCT_ID;
300145ec:	461e      	mov	r6, r3
    if (*vid == 0)
300145ee:	2a00      	cmp	r2, #0
300145f0:	f43f af31 	beq.w	30014456 <fastboot_common_init+0x36>
300145f4:	e732      	b.n	3001445c <fastboot_common_init+0x3c>
    ASSERT(fb != NULL);
300145f6:	f241 03f4 	movw	r3, #4340	; 0x10f4
300145fa:	f241 02c0 	movw	r2, #4288	; 0x10c0
300145fe:	f24a 011c 	movw	r1, #40988	; 0xa01c
30014602:	f2c3 0302 	movt	r3, #12290	; 0x3002
30014606:	4630      	mov	r0, r6
30014608:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001460c:	9300      	str	r3, [sp, #0]
3001460e:	f2c3 0101 	movt	r1, #12289	; 0x3001
30014612:	2363      	movs	r3, #99	; 0x63
30014614:	f7ff fdfe 	bl	30014214 <_panic>

30014618 <fastboot_common_okay>:

void fastboot_common_okay(fastboot_t *fb, const char *reason)
{
    if (fb) {
30014618:	b108      	cbz	r0, 3001461e <fastboot_common_okay+0x6>
        fastboot_okay(fb, reason);
3001461a:	f7fc bcc1 	b.w	30010fa0 <fastboot_okay>
    }
}
3001461e:	4770      	bx	r14

30014620 <fastboot_common_fail>:

void fastboot_common_fail(fastboot_t *fb, const char *reason)
{
    if (fb) {
30014620:	b108      	cbz	r0, 30014626 <fastboot_common_fail+0x6>
        fastboot_fail(fb, reason);
30014622:	f7fc bc49 	b.w	30010eb8 <fastboot_fail>
    }
}
30014626:	4770      	bx	r14

30014628 <heap_free_delayed_list>:
#else
#error need to select valid heap implementation or provide wrapper
#endif

static void heap_free_delayed_list(void)
{
30014628:	b5f0      	push	{r4, r5, r6, r7, r14}
3001462a:	b083      	sub	sp, #12
    list->prev = list->next = list;
3001462c:	466c      	mov	r4, r13
3001462e:	e9cd 4400 	strd	r4, r4, [r13]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30014632:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30014636:	f013 0280 	ands.w	r2, r3, #128	; 0x80
3001463a:	d137      	bne.n	300146ac <heap_free_delayed_list+0x84>
    __asm__ volatile("cpsid i");
3001463c:	b672      	cpsid	i
    if (list->next != list) {
3001463e:	f245 4128 	movw	r1, #21544	; 0x5428
    *lock = 1;
30014642:	f64d 0668 	movw	r6, #55400	; 0xd868
30014646:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001464a:	2701      	movs	r7, #1
3001464c:	f2c3 0602 	movt	r6, #12290	; 0x3002
30014650:	684b      	ldr	r3, [r1, #4]
30014652:	6037      	str	r7, [r6, #0]
30014654:	428b      	cmp	r3, r1
    *lock = 0;
30014656:	bf08      	it	eq
30014658:	6032      	streq	r2, [r6, #0]
3001465a:	d013      	beq.n	30014684 <heap_free_delayed_list+0x5c>
    item->prev = item->next = 0;
3001465c:	2500      	movs	r5, #0
3001465e:	e000      	b.n	30014662 <heap_free_delayed_list+0x3a>
    if (list->next != list) {
30014660:	4613      	mov	r3, r2
    item->next->prev = item->prev;
30014662:	e9d3 0200 	ldrd	r0, r2, [r3]
30014666:	6010      	str	r0, [r2, #0]
    item->prev->next = item->next;
30014668:	6818      	ldr	r0, [r3, #0]
3001466a:	6042      	str	r2, [r0, #4]
    item->prev = item->next = 0;
3001466c:	605d      	str	r5, [r3, #4]
    item->next = list->next;
3001466e:	9a01      	ldr	r2, [sp, #4]
30014670:	605a      	str	r2, [r3, #4]
    if (list->next != list) {
30014672:	684a      	ldr	r2, [r1, #4]
    list->next->prev = item;
30014674:	9801      	ldr	r0, [sp, #4]
    item->prev = list;
30014676:	601c      	str	r4, [r3, #0]
    if (list->next != list) {
30014678:	428a      	cmp	r2, r1
    list->next->prev = item;
3001467a:	6003      	str	r3, [r0, #0]
    list->next = item;
3001467c:	9301      	str	r3, [sp, #4]
    if (list->next != list) {
3001467e:	d1ef      	bne.n	30014660 <heap_free_delayed_list+0x38>
30014680:	6035      	str	r5, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30014682:	b10f      	cbz	r7, 30014688 <heap_free_delayed_list+0x60>
    __asm__ volatile("cpsie i");
30014684:	b662      	cpsie	i
30014686:	9b01      	ldr	r3, [sp, #4]
30014688:	42a3      	cmp	r3, r4
3001468a:	d00d      	beq.n	300146a8 <heap_free_delayed_list+0x80>
    item->prev = item->next = 0;
3001468c:	2500      	movs	r5, #0
    item->next->prev = item->prev;
3001468e:	6819      	ldr	r1, [r3, #0]
    }
    spin_unlock_irqrestore(&delayed_free_lock, state);

    while ((node = list_remove_head(&list))) {
        LTRACEF("freeing node %p\n", node);
        HEAP_FREE(node);
30014690:	4618      	mov	r0, r3
30014692:	685a      	ldr	r2, [r3, #4]
30014694:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
30014696:	6819      	ldr	r1, [r3, #0]
30014698:	604a      	str	r2, [r1, #4]
    item->prev = item->next = 0;
3001469a:	e9c3 5500 	strd	r5, r5, [r3]
3001469e:	f005 f877 	bl	30019790 <miniheap_free>
    if (list->next != list) {
300146a2:	9b01      	ldr	r3, [sp, #4]
300146a4:	42a3      	cmp	r3, r4
300146a6:	d1f2      	bne.n	3001468e <heap_free_delayed_list+0x66>
    }
}
300146a8:	b003      	add	sp, #12
300146aa:	bdf0      	pop	{r4, r5, r6, r7, r15}
300146ac:	f245 4128 	movw	r1, #21544	; 0x5428
    *lock = 1;
300146b0:	f64d 0668 	movw	r6, #55400	; 0xd868
300146b4:	f2c3 0102 	movt	r1, #12290	; 0x3002
300146b8:	2201      	movs	r2, #1
300146ba:	f2c3 0602 	movt	r6, #12290	; 0x3002
300146be:	684b      	ldr	r3, [r1, #4]
300146c0:	6032      	str	r2, [r6, #0]
300146c2:	428b      	cmp	r3, r1
    *lock = 0;
300146c4:	bf04      	itt	eq
300146c6:	2300      	moveq	r3, #0
300146c8:	6033      	streq	r3, [r6, #0]
300146ca:	d0ed      	beq.n	300146a8 <heap_free_delayed_list+0x80>
    spin_lock_saved_state_t state = 0;
300146cc:	2700      	movs	r7, #0
300146ce:	e7c5      	b.n	3001465c <heap_free_delayed_list+0x34>

300146d0 <heap_init>:

void heap_init(void)
{
300146d0:	b500      	push	{r14}
300146d2:	b083      	sub	sp, #12
    void *ptr = page_first_alloc(&len);
300146d4:	a801      	add	r0, sp, #4
300146d6:	f000 f88b 	bl	300147f0 <page_first_alloc>
    miniheap_init(ptr, len);
300146da:	9901      	ldr	r1, [sp, #4]
300146dc:	f005 f860 	bl	300197a0 <miniheap_init>
    HEAP_INIT();
}
300146e0:	b003      	add	sp, #12
300146e2:	f85d fb04 	ldr.w	r15, [r13], #4
300146e6:	bf00      	nop

300146e8 <malloc>:
    return (list->next == list) ? true : false;
300146e8:	f245 4328 	movw	r3, #21544	; 0x5428
300146ec:	f2c3 0302 	movt	r3, #12290	; 0x3002
void *malloc(size_t size)
{
    LTRACEF("size %zd\n", size);

    // deal with the pending free list
    if (unlikely(!list_is_empty(&delayed_free_list))) {
300146f0:	685a      	ldr	r2, [r3, #4]
300146f2:	429a      	cmp	r2, r3
300146f4:	d102      	bne.n	300146fc <malloc+0x14>
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
300146f6:	2100      	movs	r1, #0
300146f8:	f004 bf70 	b.w	300195dc <miniheap_alloc>
{
300146fc:	b500      	push	{r14}
300146fe:	b083      	sub	sp, #12
30014700:	9001      	str	r0, [sp, #4]
        heap_free_delayed_list();
30014702:	f7ff ff91 	bl	30014628 <heap_free_delayed_list>
30014706:	9801      	ldr	r0, [sp, #4]
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
30014708:	2100      	movs	r1, #0

    void *ptr = HEAP_MALLOC(size);
    if (heap_trace)
        printf("caller %p malloc %zu -> %p\n", __GET_CALLER(), size, ptr);
    return ptr;
}
3001470a:	b003      	add	sp, #12
3001470c:	f85d eb04 	ldr.w	r14, [r13], #4
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
30014710:	f004 bf64 	b.w	300195dc <miniheap_alloc>

30014714 <memalign>:
30014714:	f245 4328 	movw	r3, #21544	; 0x5428
30014718:	f2c3 0302 	movt	r3, #12290	; 0x3002

void *memalign(size_t boundary, size_t size)
{
3001471c:	b510      	push	{r4, r14}
    LTRACEF("boundary %zu, size %zd\n", boundary, size);

    // deal with the pending free list
    if (unlikely(!list_is_empty(&delayed_free_list))) {
3001471e:	685a      	ldr	r2, [r3, #4]
{
30014720:	b082      	sub	sp, #8
30014722:	460c      	mov	r4, r1
    if (unlikely(!list_is_empty(&delayed_free_list))) {
30014724:	429a      	cmp	r2, r3
30014726:	d106      	bne.n	30014736 <memalign+0x22>
static inline void *HEAP_MEMALIGN(size_t boundary, size_t s) { return miniheap_alloc(s, boundary); }
30014728:	4601      	mov	r1, r0
3001472a:	4620      	mov	r0, r4

    void *ptr = HEAP_MEMALIGN(boundary, size);
    if (heap_trace)
        printf("caller %p memalign %zu, %zu -> %p\n", __GET_CALLER(), boundary, size, ptr);
    return ptr;
}
3001472c:	b002      	add	sp, #8
3001472e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
static inline void *HEAP_MEMALIGN(size_t boundary, size_t s) { return miniheap_alloc(s, boundary); }
30014732:	f004 bf53 	b.w	300195dc <miniheap_alloc>
30014736:	9001      	str	r0, [sp, #4]
        heap_free_delayed_list();
30014738:	f7ff ff76 	bl	30014628 <heap_free_delayed_list>
3001473c:	9801      	ldr	r0, [sp, #4]
static inline void *HEAP_MEMALIGN(size_t boundary, size_t s) { return miniheap_alloc(s, boundary); }
3001473e:	4601      	mov	r1, r0
30014740:	4620      	mov	r0, r4
}
30014742:	b002      	add	sp, #8
30014744:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
static inline void *HEAP_MEMALIGN(size_t boundary, size_t s) { return miniheap_alloc(s, boundary); }
30014748:	f004 bf48 	b.w	300195dc <miniheap_alloc>

3001474c <calloc>:
3001474c:	f245 4328 	movw	r3, #21544	; 0x5428
30014750:	f2c3 0302 	movt	r3, #12290	; 0x3002

void *calloc(size_t count, size_t size)
{
30014754:	b530      	push	{r4, r5, r14}
    LTRACEF("count %zu, size %zd\n", count, size);

    // deal with the pending free list
    if (unlikely(!list_is_empty(&delayed_free_list))) {
30014756:	685a      	ldr	r2, [r3, #4]
{
30014758:	b083      	sub	sp, #12
    if (unlikely(!list_is_empty(&delayed_free_list))) {
3001475a:	429a      	cmp	r2, r3
3001475c:	d10e      	bne.n	3001477c <calloc+0x30>
    size_t realsize = n * s;
3001475e:	fb01 f400 	mul.w	r4, r1, r0
    void *ptr = miniheap_alloc(realsize, 0);
30014762:	2100      	movs	r1, #0
30014764:	4620      	mov	r0, r4
30014766:	f004 ff39 	bl	300195dc <miniheap_alloc>
    if (likely(ptr))
3001476a:	4605      	mov	r5, r0
3001476c:	b118      	cbz	r0, 30014776 <calloc+0x2a>
        memset(ptr, 0, realsize);
3001476e:	4622      	mov	r2, r4
30014770:	2100      	movs	r1, #0
30014772:	f000 e8fe 	blx	30014970 <memset>

    void *ptr = HEAP_CALLOC(count, size);
    if (heap_trace)
        printf("caller %p calloc %zu, %zu -> %p\n", __GET_CALLER(), count, size, ptr);
    return ptr;
}
30014776:	4628      	mov	r0, r5
30014778:	b003      	add	sp, #12
3001477a:	bd30      	pop	{r4, r5, r15}
3001477c:	e9cd 0100 	strd	r0, r1, [r13]
        heap_free_delayed_list();
30014780:	f7ff ff52 	bl	30014628 <heap_free_delayed_list>
30014784:	e9dd 0100 	ldrd	r0, r1, [r13]
30014788:	e7e9      	b.n	3001475e <calloc+0x12>
3001478a:	bf00      	nop

3001478c <free>:
{
    LTRACEF("ptr %p\n", ptr);
    if (heap_trace)
        printf("caller %p free %p\n", __GET_CALLER(), ptr);

    HEAP_FREE(ptr);
3001478c:	f005 b800 	b.w	30019790 <miniheap_free>

30014790 <heap_delayed_free>:
}

/* critical section time delayed free */
void heap_delayed_free(void *ptr)
{
30014790:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30014792:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30014796:	f013 0380 	ands.w	r3, r3, #128	; 0x80
3001479a:	d113      	bne.n	300147c4 <heap_delayed_free+0x34>
    __asm__ volatile("cpsid i");
3001479c:	b672      	cpsid	i
    item->next = list->next;
3001479e:	f245 4228 	movw	r2, #21544	; 0x5428
    *lock = 0;
300147a2:	f64d 0168 	movw	r1, #55400	; 0xd868
300147a6:	f2c3 0202 	movt	r2, #12290	; 0x3002
300147aa:	f2c3 0102 	movt	r1, #12290	; 0x3002
300147ae:	6854      	ldr	r4, [r2, #4]
300147b0:	6044      	str	r4, [r0, #4]
    list->next->prev = item;
300147b2:	6854      	ldr	r4, [r2, #4]
    item->prev = list;
300147b4:	6002      	str	r2, [r0, #0]
    list->next->prev = item;
300147b6:	6020      	str	r0, [r4, #0]
    list->next = item;
300147b8:	6050      	str	r0, [r2, #4]
300147ba:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
300147bc:	b662      	cpsie	i

    spin_lock_saved_state_t state;
    spin_lock_irqsave(&delayed_free_lock, state);
    list_add_head(&delayed_free_list, node);
    spin_unlock_irqrestore(&delayed_free_lock, state);
}
300147be:	f85d 4b04 	ldr.w	r4, [r13], #4
300147c2:	4770      	bx	r14
    item->next = list->next;
300147c4:	f245 4328 	movw	r3, #21544	; 0x5428
300147c8:	f64d 0268 	movw	r2, #55400	; 0xd868
300147cc:	f2c3 0302 	movt	r3, #12290	; 0x3002
300147d0:	2100      	movs	r1, #0
300147d2:	f2c3 0202 	movt	r2, #12290	; 0x3002
300147d6:	685c      	ldr	r4, [r3, #4]
300147d8:	6044      	str	r4, [r0, #4]
    list->next->prev = item;
300147da:	685c      	ldr	r4, [r3, #4]
    item->prev = list;
300147dc:	6003      	str	r3, [r0, #0]
    list->next->prev = item;
300147de:	6020      	str	r0, [r4, #0]
    list->next = item;
300147e0:	6058      	str	r0, [r3, #4]
300147e2:	6011      	str	r1, [r2, #0]
300147e4:	f85d 4b04 	ldr.w	r4, [r13], #4
300147e8:	4770      	bx	r14
300147ea:	bf00      	nop

300147ec <page_alloc>:
{
#if WITH_KERNEL_VM
    void *result = pmm_alloc_kpages(pages, NULL);
    return result;
#else
    void *result = novm_alloc_pages(pages, arena);
300147ec:	f7fe bcf2 	b.w	300131d4 <novm_alloc_pages>

300147f0 <page_first_alloc>:
{
#if WITH_KERNEL_VM
    *size_return = PAGE_SIZE;
    return page_alloc(1, PAGE_ALLOC_ANY_ARENA);
#else
    return novm_alloc_unaligned(size_return);
300147f0:	f7fe bcd6 	b.w	300131a0 <novm_alloc_unaligned>

300147f4 <avb_htobe32>:
uint32_t avb_htobe32(uint32_t in) {
  union {
    uint32_t word;
    uint8_t bytes[4];
  } ret;
  ret.bytes[0] = (in >> 24) & 0xff;
300147f4:	2300      	movs	r3, #0
300147f6:	0e02      	lsrs	r2, r0, #24
300147f8:	f362 0307 	bfi	r3, r2, #0, #8
  ret.bytes[1] = (in >> 16) & 0xff;
300147fc:	0c02      	lsrs	r2, r0, #16
300147fe:	f362 230f 	bfi	r3, r2, #8, #8
  ret.bytes[2] = (in >> 8) & 0xff;
30014802:	0a02      	lsrs	r2, r0, #8
30014804:	f362 4317 	bfi	r3, r2, #16, #8
  ret.bytes[3] = in & 0xff;
30014808:	f360 631f 	bfi	r3, r0, #24, #8
  return ret.word;
}
3001480c:	4618      	mov	r0, r3
3001480e:	4770      	bx	r14

30014810 <avb_htobe64>:

/* Converts a 64-bit unsigned integer from host to big-endian byte order. */
uint64_t avb_htobe64(uint64_t in) {
30014810:	460b      	mov	r3, r1
  union {
    uint64_t word;
    uint8_t bytes[8];
  } ret;
  ret.bytes[0] = (in >> 56) & 0xff;
30014812:	2200      	movs	r2, #0
uint64_t avb_htobe64(uint64_t in) {
30014814:	b430      	push	{r4, r5}
  ret.bytes[1] = (in >> 48) & 0xff;
  ret.bytes[2] = (in >> 40) & 0xff;
  ret.bytes[3] = (in >> 32) & 0xff;
  ret.bytes[4] = (in >> 24) & 0xff;
30014816:	4611      	mov	r1, r2
30014818:	0e04      	lsrs	r4, r0, #24
3001481a:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
  ret.bytes[5] = (in >> 16) & 0xff;
3001481e:	0c05      	lsrs	r5, r0, #16
  ret.bytes[4] = (in >> 24) & 0xff;
30014820:	f364 0107 	bfi	r1, r4, #0, #8
  ret.bytes[5] = (in >> 16) & 0xff;
30014824:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  ret.bytes[0] = (in >> 56) & 0xff;
30014828:	0e1c      	lsrs	r4, r3, #24
3001482a:	f364 0207 	bfi	r2, r4, #0, #8
  ret.bytes[5] = (in >> 16) & 0xff;
3001482e:	f365 210f 	bfi	r1, r5, #8, #8
  ret.bytes[1] = (in >> 48) & 0xff;
30014832:	0c1d      	lsrs	r5, r3, #16
  ret.bytes[6] = (in >> 8) & 0xff;
30014834:	0a04      	lsrs	r4, r0, #8
  ret.bytes[1] = (in >> 48) & 0xff;
30014836:	f365 220f 	bfi	r2, r5, #8, #8
  ret.bytes[2] = (in >> 40) & 0xff;
3001483a:	0a1d      	lsrs	r5, r3, #8
  ret.bytes[6] = (in >> 8) & 0xff;
3001483c:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
  ret.bytes[2] = (in >> 40) & 0xff;
30014840:	f365 4217 	bfi	r2, r5, #16, #8
  ret.bytes[6] = (in >> 8) & 0xff;
30014844:	f364 4117 	bfi	r1, r4, #16, #8
  ret.bytes[3] = (in >> 32) & 0xff;
30014848:	f363 621f 	bfi	r2, r3, #24, #8
  ret.bytes[7] = in & 0xff;
3001484c:	f360 611f 	bfi	r1, r0, #24, #8
  return ret.word;
}
30014850:	bc30      	pop	{r4, r5}
30014852:	4610      	mov	r0, r2
30014854:	4770      	bx	r14
30014856:	bf00      	nop

30014858 <bcopy>:
.align 2

/* void bcopy(const void *src, void *dest, size_t n); */
FUNCTION(bcopy)
    // swap args for bcopy
    mov     r12, r0
30014858:	e1a0c000 	mov	r12, r0
    mov     r0, r1
3001485c:	e1a00001 	mov	r0, r1
    mov     r1, r12
30014860:	e1a0100c 	mov	r1, r12

30014864 <memcpy>:

/* void *memcpy(void *dest, const void *src, size_t n); */
FUNCTION(memmove)
FUNCTION(memcpy)
    // check for zero length copy or the same pointer
    cmp     r2, #0
30014864:	e3520000 	cmp	r2, #0
    cmpne   r1, r0
30014868:	11510000 	cmpne	r1, r0
    bxeq    lr
3001486c:	012fff1e 	bxeq	r14

    // save a few registers for use and the return code (input dst)
    stmfd   sp!, {r0, r4, r5, lr}
30014870:	e92d4031 	push	{r0, r4, r5, r14}

    // check for forwards overlap (src > dst, distance < len)
    subs    r3, r0, r1
30014874:	e0503001 	subs	r3, r0, r1
    cmphi   r2, r3
30014878:	81520003 	cmphi	r2, r3
    bhi     .L_forwardoverlap
3001487c:	8a000030 	bhi	30014944 <memcpy+0xe0>

    // check for a short copy len.
    // 20 bytes is enough so that if a 16 byte alignment needs to happen there is at least a 
    //   wordwise copy worth of work to be done.
    cmp     r2, #(16+4)
30014880:	e3520014 	cmp	r2, #20
    blo     .L_bytewise
30014884:	3a000019 	bcc	300148f0 <memcpy+0x8c>

    // see if they are similarly aligned on 4 byte boundaries
    eor     r3, r0, r1
30014888:	e0203001 	eor	r3, r0, r1
    tst     r3, #3
3001488c:	e3130003 	tst	r3, #3
    bne     .L_bytewise     // dissimilarly aligned, nothing we can do (for now)
30014890:	1a000016 	bne	300148f0 <memcpy+0x8c>

    // check for 16 byte alignment on dst.
    // this will also catch src being not 4 byte aligned, since it is similarly 4 byte 
    //   aligned with dst at this point.
    tst     r0, #15
30014894:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
30014898:	1a00001a 	bne	30014908 <memcpy+0xa4>

    // check to see if we have at least 32 bytes of data to copy.
    // if not, just revert to wordwise copy
    cmp     r2, #32
3001489c:	e3520020 	cmp	r2, #32
    blo     .L_wordwise
300148a0:	3a00000b 	bcc	300148d4 <memcpy+0x70>
.L_bigcopy:
    // copy 32 bytes at a time. src & dst need to be at least 4 byte aligned, 
    // and we need at least 32 bytes remaining to copy

    // save r6-r7 for use in the big copy
    stmfd   sp!, {r6-r11}
300148a4:	e92d0fc0 	push	{r6, r7, r8, r9, r10, r11}

    sub     r2, r2, #32     // subtract an extra 32 to the len so we can avoid an extra compare
300148a8:	e2422020 	sub	r2, r2, #32

.L_bigcopy_loop:
    pld     [r1, #64]
300148ac:	f5d1f040 	pld	[r1, #64]	; 0x40
    ldmia   r1!, {r4-r11}
300148b0:	e8b10ff0 	ldm	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
    subs    r2, r2, #32
300148b4:	e2522020 	subs	r2, r2, #32
    stmia   r0!, {r4-r11}
300148b8:	e8a00ff0 	stmia	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
    bhs     .L_bigcopy_loop
300148bc:	2afffffa 	bcs	300148ac <memcpy+0x48>

    // restore r6-r7
    ldmfd   sp!, {r6-r11}
300148c0:	e8bd0fc0 	pop	{r6, r7, r8, r9, r10, r11}

    // see if we are done
    adds    r2, r2, #32
300148c4:	e2922020 	adds	r2, r2, #32
    beq     .L_done
300148c8:	0a00000c 	beq	30014900 <memcpy+0x9c>

    // less then 4 bytes left?
    cmp     r2, #4
300148cc:	e3520004 	cmp	r2, #4
    blo     .L_bytewise
300148d0:	3a000006 	bcc	300148f0 <memcpy+0x8c>

.L_wordwise:
    // copy 4 bytes at a time.
    // src & dst are guaranteed to be word aligned, and at least 4 bytes are left to copy.
    subs    r2, r2, #4
300148d4:	e2522004 	subs	r2, r2, #4

.L_wordwise_loop:
    ldr     r3, [r1], #4
300148d8:	e4913004 	ldr	r3, [r1], #4
    subs    r2, r2, #4
300148dc:	e2522004 	subs	r2, r2, #4
    str     r3, [r0], #4
300148e0:	e4803004 	str	r3, [r0], #4
    bhs     .L_wordwise_loop
300148e4:	2afffffb 	bcs	300148d8 <memcpy+0x74>

    // correct the remaining len and test for completion
    adds    r2, r2, #4  
300148e8:	e2922004 	adds	r2, r2, #4
    beq     .L_done
300148ec:	0a000003 	beq	30014900 <memcpy+0x9c>

.L_bytewise:
    // simple bytewise copy
    ldrb    r3, [r1], #1
300148f0:	e4d13001 	ldrb	r3, [r1], #1
    subs    r2, r2, #1
300148f4:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #1
300148f8:	e4c03001 	strb	r3, [r0], #1
    bhi     .L_bytewise
300148fc:	8afffffb 	bhi	300148f0 <memcpy+0x8c>
.L_done:
    // load dst for return and restore r4,r5
#if ARM_ARCH_LEVEL >= 5
    ldmfd   sp!, {r0, r4, r5, pc}
#else
    ldmfd   sp!, {r0, r4, r5, lr}
30014900:	e8bd4031 	pop	{r0, r4, r5, r14}
    bx      lr
30014904:	e12fff1e 	bx	r14
.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will copy up to 15 bytes to get it aligned.
    // src is guaranteed to be similarly word aligned with dst.

    // set the condition flags based on the alignment.
    lsl     r12, r0, #28
30014908:	e1a0ce00 	lsl	r12, r0, #28
    rsb     r12, r12, #0
3001490c:	e26cc000 	rsb	r12, r12, #0
    msr     CPSR_f, r12             // move into NZCV fields in CPSR
30014910:	e128f00c 	msr	CPSR_f, r12

    // move as many bytes as necessary to get the dst aligned
    ldrvsb  r3, [r1], #1            // V set
30014914:	64d13001 	ldrbvs	r3, [r1], #1
    ldrcsh  r4, [r1], #2            // C set
30014918:	20d140b2 	ldrhcs	r4, [r1], #2
    ldreq   r5, [r1], #4            // Z set
3001491c:	04915004 	ldreq	r5, [r1], #4

    strvsb  r3, [r0], #1
30014920:	64c03001 	strbvs	r3, [r0], #1
    strcsh  r4, [r0], #2
30014924:	20c040b2 	strhcs	r4, [r0], #2
    streq   r5, [r0], #4
30014928:	04805004 	streq	r5, [r0], #4

    ldmmiia r1!, {r3-r4}            // N set
3001492c:	48b10018 	ldmmi	r1!, {r3, r4}
    stmmiia r0!, {r3-r4}
30014930:	48a00018 	stmiami	r0!, {r3, r4}

    // fix the remaining len
    sub     r2, r2, r12, lsr #28
30014934:	e0422e2c 	sub	r2, r2, r12, lsr #28

    // test to see what we should do now
    cmp     r2, #32
30014938:	e3520020 	cmp	r2, #32
    bhs     .L_bigcopy
3001493c:	2affffd8 	bcs	300148a4 <memcpy+0x40>
    b       .L_wordwise
30014940:	eaffffe3 	b	300148d4 <memcpy+0x70>

    // src and dest overlap 'forwards' or dst > src
.L_forwardoverlap:

    // do a bytewise reverse copy for now
    add     r1, r1, r2
30014944:	e0811002 	add	r1, r1, r2
    add     r0, r0, r2
30014948:	e0800002 	add	r0, r0, r2
    sub     r1, r1, #1
3001494c:	e2411001 	sub	r1, r1, #1
    sub     r0, r0, #1
30014950:	e2400001 	sub	r0, r0, #1

.L_bytewisereverse:
    // simple bytewise reverse copy
    ldrb    r3, [r1], #-1
30014954:	e4513001 	ldrb	r3, [r1], #-1
    subs    r2, r2, #1
30014958:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #-1
3001495c:	e4403001 	strb	r3, [r0], #-1
    bhi     .L_bytewisereverse
30014960:	8afffffb 	bhi	30014954 <memcpy+0xf0>

    b       .L_done
30014964:	eaffffe5 	b	30014900 <memcpy+0x9c>

30014968 <bzero>:
.text
.align 2

/* void bzero(void *s, size_t n); */
FUNCTION(bzero)
    mov     r2, r1
30014968:	e1a02001 	mov	r2, r1
    mov     r1, #0
3001496c:	e3a01000 	mov	r1, #0

30014970 <memset>:

/* void *memset(void *s, int c, size_t n); */
FUNCTION(memset)
    // check for zero length
    cmp     r2, #0
30014970:	e3520000 	cmp	r2, #0
    bxeq    lr
30014974:	012fff1e 	bxeq	r14

    // save the original pointer
    mov     r12, r0
30014978:	e1a0c000 	mov	r12, r0

    // short memsets aren't worth optimizing
    cmp     r2, #(32 + 16)
3001497c:	e3520030 	cmp	r2, #48	; 0x30
    blt     .L_bytewise
30014980:	ba000010 	blt	300149c8 <memset+0x58>

    // fill a 32 bit register with the 8 bit value
    and     r1, r1, #0xff
30014984:	e20110ff 	and	r1, r1, #255	; 0xff
    orr     r1, r1, r1, lsl #8
30014988:	e1811401 	orr	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
3001498c:	e1811801 	orr	r1, r1, r1, lsl #16

    // check for 16 byte alignment
    tst     r0, #15
30014990:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
30014994:	1a000010 	bne	300149dc <memset+0x6c>

.L_bigset:
    // dump some registers to make space for our values
    stmfd   sp!, { r4-r5 }
30014998:	e92d0030 	push	{r4, r5}

    // fill a bunch of registers with the set value
    mov     r3, r1
3001499c:	e1a03001 	mov	r3, r1
    mov     r4, r1
300149a0:	e1a04001 	mov	r4, r1
    mov     r5, r1
300149a4:	e1a05001 	mov	r5, r1

    // prepare the count register so we can avoid an extra compare
    sub     r2, r2, #32
300149a8:	e2422020 	sub	r2, r2, #32

    // 32 bytes at a time
.L_bigset_loop:
    stmia   r0!, { r1, r3, r4, r5 }
300149ac:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    subs    r2, r2, #32
300149b0:	e2522020 	subs	r2, r2, #32
    stmia   r0!, { r1, r3, r4, r5 }
300149b4:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    bge     .L_bigset_loop
300149b8:	aafffffb 	bge	300149ac <memset+0x3c>

    // restore our dumped registers
    ldmfd   sp!, { r4-r5 }
300149bc:	e8bd0030 	pop	{r4, r5}

    // see if we're done
    adds    r2, r2, #32
300149c0:	e2922020 	adds	r2, r2, #32
    beq     .L_done
300149c4:	0a000002 	beq	300149d4 <memset+0x64>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
300149c8:	e2522001 	subs	r2, r2, #1
    strb    r1, [r0], #1
300149cc:	e4c01001 	strb	r1, [r0], #1
    bgt     .L_bytewise
300149d0:	cafffffc 	bgt	300149c8 <memset+0x58>

.L_done:
    // restore the base pointer as return value
    mov     r0, r12
300149d4:	e1a0000c 	mov	r0, r12
    bx      lr
300149d8:	e12fff1e 	bx	r14

.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will set up to 15 bytes to get it aligned.

    // set the condition flags based on the alignment.
    lsl     r3, r0, #28
300149dc:	e1a03e00 	lsl	r3, r0, #28
    rsb     r3, r3, #0
300149e0:	e2633000 	rsb	r3, r3, #0
    msr     CPSR_f, r3             // move into NZCV fields in CPSR
300149e4:	e128f003 	msr	CPSR_f, r3

    // move as many bytes as necessary to get the dst aligned
    strvsb  r1, [r0], #1            // V set
300149e8:	64c01001 	strbvs	r1, [r0], #1
    strcsh  r1, [r0], #2            // C set
300149ec:	20c010b2 	strhcs	r1, [r0], #2
    streq   r1, [r0], #4            // Z set
300149f0:	04801004 	streq	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
300149f4:	44801004 	strmi	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
300149f8:	44801004 	strmi	r1, [r0], #4

    // fix the remaining len
    sub     r2, r2, r3, lsr #28
300149fc:	e0422e23 	sub	r2, r2, r3, lsr #28

    // do the large memset
    b       .L_bigset
30014a00:	eaffffe4 	b	30014998 <memset+0x28>

30014a04 <hexval>:

#define LONG_IS_INT 1

static int hexval(char c)
{
    if (c >= '0' && c <= '9')
30014a04:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
30014a08:	b2da      	uxtb	r2, r3
30014a0a:	2a09      	cmp	r2, #9
30014a0c:	d90c      	bls.n	30014a28 <hexval+0x24>
        return c - '0';
    else if (c >= 'a' && c <= 'f')
30014a0e:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
30014a12:	2b05      	cmp	r3, #5
30014a14:	d906      	bls.n	30014a24 <hexval+0x20>
        return c - 'a' + 10;
    else if (c >= 'A' && c <= 'F')
30014a16:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
30014a1a:	2b05      	cmp	r3, #5
        return c - 'A' + 10;
30014a1c:	bf94      	ite	ls
30014a1e:	3837      	subls	r0, #55	; 0x37

    return 0;
30014a20:	2000      	movhi	r0, #0
}
30014a22:	4770      	bx	r14
        return c - 'a' + 10;
30014a24:	3857      	subs	r0, #87	; 0x57
30014a26:	4770      	bx	r14
        return c - '0';
30014a28:	4618      	mov	r0, r3
30014a2a:	4770      	bx	r14

30014a2c <atol>:
    return atoul(num);
#endif
}

long atol(const char *num)
{
30014a2c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    long value = 0;
    int neg = 0;

    if (num[0] == '0' && num[1] == 'x') {
30014a2e:	7802      	ldrb	r2, [r0, #0]
30014a30:	2a30      	cmp	r2, #48	; 0x30
30014a32:	d028      	beq.n	30014a86 <atol+0x5a>
        num += 2;
        while (*num && isxdigit(*num))
            value = value * 16 + hexval(*num++);
    } else {
        // decimal
        if (num[0] == '-') {
30014a34:	2a2d      	cmp	r2, #45	; 0x2d
30014a36:	d01b      	beq.n	30014a70 <atol+0x44>
            neg = 1;
            num++;
        }
        while (*num && isdigit(*num))
30014a38:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
30014a3c:	b2db      	uxtb	r3, r3
30014a3e:	2b09      	cmp	r3, #9
30014a40:	d83a      	bhi.n	30014ab8 <atol+0x8c>
    int neg = 0;
30014a42:	2600      	movs	r6, #0
30014a44:	7843      	ldrb	r3, [r0, #1]
30014a46:	2400      	movs	r4, #0
30014a48:	3001      	adds	r0, #1
30014a4a:	e001      	b.n	30014a50 <atol+0x24>
        while (*num && isdigit(*num))
30014a4c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
            value = value * 10 + *num++  - '0';
30014a50:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        while (*num && isdigit(*num))
30014a54:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
30014a58:	2d09      	cmp	r5, #9
            value = value * 10 + *num++  - '0';
30014a5a:	eb02 0144 	add.w	r1, r2, r4, lsl #1
30014a5e:	461a      	mov	r2, r3
30014a60:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
        while (*num && isdigit(*num))
30014a64:	d9f2      	bls.n	30014a4c <atol+0x20>
    }

    if (neg)
30014a66:	b10e      	cbz	r6, 30014a6c <atol+0x40>
30014a68:	f1c1 0430 	rsb	r4, r1, #48	; 0x30
        value = -value;

    return value;
}
30014a6c:	4620      	mov	r0, r4
30014a6e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        while (*num && isdigit(*num))
30014a70:	7842      	ldrb	r2, [r0, #1]
30014a72:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
30014a76:	2b09      	cmp	r3, #9
            num++;
30014a78:	f100 0101 	add.w	r1, r0, #1
        while (*num && isdigit(*num))
30014a7c:	d81c      	bhi.n	30014ab8 <atol+0x8c>
30014a7e:	7883      	ldrb	r3, [r0, #2]
            neg = 1;
30014a80:	2601      	movs	r6, #1
            num++;
30014a82:	4608      	mov	r0, r1
30014a84:	e7df      	b.n	30014a46 <atol+0x1a>
    if (num[0] == '0' && num[1] == 'x') {
30014a86:	7843      	ldrb	r3, [r0, #1]
30014a88:	2b78      	cmp	r3, #120	; 0x78
    int neg = 0;
30014a8a:	bf18      	it	ne
30014a8c:	2600      	movne	r6, #0
    if (num[0] == '0' && num[1] == 'x') {
30014a8e:	d1da      	bne.n	30014a46 <atol+0x1a>
        while (*num && isxdigit(*num))
30014a90:	7885      	ldrb	r5, [r0, #2]
    long value = 0;
30014a92:	2400      	movs	r4, #0
        num += 2;
30014a94:	1c86      	adds	r6, r0, #2
        while (*num && isxdigit(*num))
30014a96:	b945      	cbnz	r5, 30014aaa <atol+0x7e>
30014a98:	e00e      	b.n	30014ab8 <atol+0x8c>
            value = value * 16 + hexval(*num++);
30014a9a:	4628      	mov	r0, r5
30014a9c:	f7ff ffb2 	bl	30014a04 <hexval>
        while (*num && isxdigit(*num))
30014aa0:	f816 5f01 	ldrb.w	r5, [r6, #1]!
            value = value * 16 + hexval(*num++);
30014aa4:	183c      	adds	r4, r7, r0
        while (*num && isxdigit(*num))
30014aa6:	2d00      	cmp	r5, #0
30014aa8:	d0e0      	beq.n	30014a6c <atol+0x40>
30014aaa:	4628      	mov	r0, r5
            value = value * 16 + hexval(*num++);
30014aac:	0127      	lsls	r7, r4, #4
        while (*num && isxdigit(*num))
30014aae:	f000 f925 	bl	30014cfc <isxdigit>
30014ab2:	2800      	cmp	r0, #0
30014ab4:	d1f1      	bne.n	30014a9a <atol+0x6e>
30014ab6:	e7d9      	b.n	30014a6c <atol+0x40>
    long value = 0;
30014ab8:	2400      	movs	r4, #0
}
30014aba:	4620      	mov	r0, r4
30014abc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
30014abe:	bf00      	nop

30014ac0 <atoul>:

unsigned long atoul(const char *num)
{
30014ac0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    unsigned long value = 0;
    if (num[0] == '0' && num[1] == 'x') {
30014ac2:	7803      	ldrb	r3, [r0, #0]
30014ac4:	2b30      	cmp	r3, #48	; 0x30
30014ac6:	d017      	beq.n	30014af8 <atoul+0x38>
        num += 2;
        while (*num && isxdigit(*num))
            value = value * 16 + hexval(*num++);
    } else {
        // decimal
        while (*num && isdigit(*num))
30014ac8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
30014acc:	b2d2      	uxtb	r2, r2
30014ace:	2a09      	cmp	r2, #9
30014ad0:	d829      	bhi.n	30014b26 <atoul+0x66>
30014ad2:	7842      	ldrb	r2, [r0, #1]
    unsigned long value = 0;
30014ad4:	2400      	movs	r4, #0
30014ad6:	3001      	adds	r0, #1
30014ad8:	e001      	b.n	30014ade <atoul+0x1e>
        while (*num && isdigit(*num))
30014ada:	f810 2f01 	ldrb.w	r2, [r0, #1]!
            value = value * 10 + *num++  - '0';
30014ade:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        while (*num && isdigit(*num))
30014ae2:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
30014ae6:	2909      	cmp	r1, #9
            value = value * 10 + *num++  - '0';
30014ae8:	eb03 0444 	add.w	r4, r3, r4, lsl #1
30014aec:	4613      	mov	r3, r2
30014aee:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
        while (*num && isdigit(*num))
30014af2:	d9f2      	bls.n	30014ada <atoul+0x1a>
    }

    return value;
}
30014af4:	4620      	mov	r0, r4
30014af6:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (num[0] == '0' && num[1] == 'x') {
30014af8:	7842      	ldrb	r2, [r0, #1]
30014afa:	2a78      	cmp	r2, #120	; 0x78
30014afc:	d1ea      	bne.n	30014ad4 <atoul+0x14>
        while (*num && isxdigit(*num))
30014afe:	7885      	ldrb	r5, [r0, #2]
    unsigned long value = 0;
30014b00:	2400      	movs	r4, #0
        num += 2;
30014b02:	1c86      	adds	r6, r0, #2
        while (*num && isxdigit(*num))
30014b04:	b945      	cbnz	r5, 30014b18 <atoul+0x58>
30014b06:	e00e      	b.n	30014b26 <atoul+0x66>
            value = value * 16 + hexval(*num++);
30014b08:	4628      	mov	r0, r5
30014b0a:	f7ff ff7b 	bl	30014a04 <hexval>
        while (*num && isxdigit(*num))
30014b0e:	f816 5f01 	ldrb.w	r5, [r6, #1]!
            value = value * 16 + hexval(*num++);
30014b12:	19c4      	adds	r4, r0, r7
        while (*num && isxdigit(*num))
30014b14:	2d00      	cmp	r5, #0
30014b16:	d0ed      	beq.n	30014af4 <atoul+0x34>
30014b18:	4628      	mov	r0, r5
            value = value * 16 + hexval(*num++);
30014b1a:	0127      	lsls	r7, r4, #4
        while (*num && isxdigit(*num))
30014b1c:	f000 f8ee 	bl	30014cfc <isxdigit>
30014b20:	2800      	cmp	r0, #0
30014b22:	d1f1      	bne.n	30014b08 <atoul+0x48>
30014b24:	e7e6      	b.n	30014af4 <atoul+0x34>
        while (*num && isdigit(*num))
30014b26:	2400      	movs	r4, #0
}
30014b28:	4620      	mov	r0, r4
30014b2a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

30014b2c <atoull>:

unsigned long long atoull(const char *num)
{
30014b2c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    unsigned long long value = 0;
    if (num[0] == '0' && num[1] == 'x') {
30014b30:	f890 c000 	ldrb.w	r12, [r0]
30014b34:	f1bc 0f30 	cmp.w	r12, #48	; 0x30
30014b38:	d02c      	beq.n	30014b94 <atoull+0x68>
        num += 2;
        while (*num && isxdigit(*num))
            value = value * 16 + hexval(*num++);
    } else {
        // decimal
        while (*num && isdigit(*num))
30014b3a:	f1ac 0330 	sub.w	r3, r12, #48	; 0x30
30014b3e:	b2db      	uxtb	r3, r3
30014b40:	2b09      	cmp	r3, #9
30014b42:	d849      	bhi.n	30014bd8 <atoull+0xac>
30014b44:	7841      	ldrb	r1, [r0, #1]
    unsigned long long value = 0;
30014b46:	2600      	movs	r6, #0
30014b48:	3001      	adds	r0, #1
30014b4a:	2700      	movs	r7, #0
30014b4c:	e001      	b.n	30014b52 <atoull+0x26>
        while (*num && isdigit(*num))
30014b4e:	f810 1f01 	ldrb.w	r1, [r0, #1]!
            value = value * 10 + *num++  - '0';
30014b52:	00bc      	lsls	r4, r7, #2
30014b54:	00b2      	lsls	r2, r6, #2
30014b56:	ea44 7396 	orr.w	r3, r4, r6, lsr #30
30014b5a:	eb12 0806 	adds.w	r8, r2, r6
30014b5e:	eb43 0907 	adc.w	r9, r3, r7
30014b62:	fa5f f48c 	uxtb.w	r4, r12
30014b66:	2500      	movs	r5, #0
30014b68:	eb18 0208 	adds.w	r2, r8, r8
30014b6c:	eb49 0309 	adc.w	r3, r9, r9
30014b70:	eb12 0804 	adds.w	r8, r2, r4
30014b74:	eb43 0905 	adc.w	r9, r3, r5
        while (*num && isdigit(*num))
30014b78:	f1a1 0e30 	sub.w	r14, r1, #48	; 0x30
30014b7c:	468c      	mov	r12, r1
            value = value * 10 + *num++  - '0';
30014b7e:	f1b8 0630 	subs.w	r6, r8, #48	; 0x30
30014b82:	f149 37ff 	adc.w	r7, r9, #4294967295	; 0xffffffff
        while (*num && isdigit(*num))
30014b86:	f1be 0f09 	cmp.w	r14, #9
30014b8a:	d9e0      	bls.n	30014b4e <atoull+0x22>
    }

    return value;
}
30014b8c:	4630      	mov	r0, r6
30014b8e:	4639      	mov	r1, r7
30014b90:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    if (num[0] == '0' && num[1] == 'x') {
30014b94:	7841      	ldrb	r1, [r0, #1]
30014b96:	2978      	cmp	r1, #120	; 0x78
30014b98:	d1d5      	bne.n	30014b46 <atoull+0x1a>
        while (*num && isxdigit(*num))
30014b9a:	f890 8002 	ldrb.w	r8, [r0, #2]
    unsigned long long value = 0;
30014b9e:	2600      	movs	r6, #0
30014ba0:	2700      	movs	r7, #0
        num += 2;
30014ba2:	f100 0902 	add.w	r9, r0, #2
        while (*num && isxdigit(*num))
30014ba6:	f1b8 0f00 	cmp.w	r8, #0
30014baa:	d10b      	bne.n	30014bc4 <atoull+0x98>
30014bac:	e7ee      	b.n	30014b8c <atoull+0x60>
            value = value * 16 + hexval(*num++);
30014bae:	4640      	mov	r0, r8
30014bb0:	f7ff ff28 	bl	30014a04 <hexval>
        while (*num && isxdigit(*num))
30014bb4:	f819 8f01 	ldrb.w	r8, [r9, #1]!
            value = value * 16 + hexval(*num++);
30014bb8:	1826      	adds	r6, r4, r0
30014bba:	eb45 77e0 	adc.w	r7, r5, r0, asr #31
        while (*num && isxdigit(*num))
30014bbe:	f1b8 0f00 	cmp.w	r8, #0
30014bc2:	d0e3      	beq.n	30014b8c <atoull+0x60>
30014bc4:	4640      	mov	r0, r8
            value = value * 16 + hexval(*num++);
30014bc6:	013d      	lsls	r5, r7, #4
        while (*num && isxdigit(*num))
30014bc8:	f000 f898 	bl	30014cfc <isxdigit>
            value = value * 16 + hexval(*num++);
30014bcc:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
30014bd0:	0134      	lsls	r4, r6, #4
        while (*num && isxdigit(*num))
30014bd2:	2800      	cmp	r0, #0
30014bd4:	d1eb      	bne.n	30014bae <atoull+0x82>
30014bd6:	e7d9      	b.n	30014b8c <atoull+0x60>
        while (*num && isdigit(*num))
30014bd8:	2600      	movs	r6, #0
30014bda:	2700      	movs	r7, #0
}
30014bdc:	4630      	mov	r0, r6
30014bde:	4639      	mov	r1, r7
30014be0:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}

30014be4 <strtoul>:
unsigned long strtoul(const char *nptr, char **endptr, int base)
{
    int neg = 0;
    unsigned long ret = 0;

    if (base < 0 || base == 1 || base > 36) {
30014be4:	2a24      	cmp	r2, #36	; 0x24
{
30014be6:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    if (base < 0 || base == 1 || base > 36) {
30014bea:	bf94      	ite	ls
30014bec:	2700      	movls	r7, #0
30014bee:	2701      	movhi	r7, #1
30014bf0:	2a01      	cmp	r2, #1
30014bf2:	bf08      	it	eq
30014bf4:	f047 0701 	orreq.w	r7, r7, #1
30014bf8:	b13f      	cbz	r7, 30014c0a <strtoul+0x26>
        errno = EINVAL;
30014bfa:	f000 f893 	bl	30014d24 <__geterrno>
30014bfe:	2216      	movs	r2, #22
        return 0;
30014c00:	2300      	movs	r3, #0
        errno = EINVAL;
30014c02:	6002      	str	r2, [r0, #0]
    if (neg && ret != ULONG_MAX) {
        ret = -ret;
    }

    return ret;
}
30014c04:	4618      	mov	r0, r3
30014c06:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
30014c0a:	4616      	mov	r6, r2
30014c0c:	4689      	mov	r9, r1
30014c0e:	4680      	mov	r8, r0
    while (isspace(*nptr)) {
30014c10:	f898 4000 	ldrb.w	r4, [r8]
30014c14:	4620      	mov	r0, r4
30014c16:	4645      	mov	r5, r8
30014c18:	f108 0801 	add.w	r8, r8, #1
30014c1c:	f000 f864 	bl	30014ce8 <isspace>
30014c20:	2800      	cmp	r0, #0
30014c22:	d1f5      	bne.n	30014c10 <strtoul+0x2c>
    if (*nptr == '+') {
30014c24:	2c2b      	cmp	r4, #43	; 0x2b
30014c26:	d04f      	beq.n	30014cc8 <strtoul+0xe4>
    } else if (*nptr == '-') {
30014c28:	2c2d      	cmp	r4, #45	; 0x2d
30014c2a:	bf02      	ittt	eq
30014c2c:	786c      	ldrbeq	r4, [r5, #1]
        nptr++;
30014c2e:	2701      	moveq	r7, #1
30014c30:	4645      	moveq	r5, r8
    if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
30014c32:	f036 0310 	bics.w	r3, r6, #16
30014c36:	d041      	beq.n	30014cbc <strtoul+0xd8>
        base = 10;
30014c38:	2300      	movs	r3, #0
            errno = ERANGE;
30014c3a:	f04f 0822 	mov.w	r8, #34	; 0x22
        if (c >= 'A' && c <= 'Z') {
30014c3e:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
30014c42:	2a19      	cmp	r2, #25
            v = c - 'A' + 10;
30014c44:	bf98      	it	ls
30014c46:	3c37      	subls	r4, #55	; 0x37
        if (c >= 'A' && c <= 'Z') {
30014c48:	d909      	bls.n	30014c5e <strtoul+0x7a>
        } else if (c >= 'a' && c <= 'z') {
30014c4a:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
30014c4e:	2a19      	cmp	r2, #25
            v = c - 'a' + 10;
30014c50:	bf98      	it	ls
30014c52:	3c57      	subls	r4, #87	; 0x57
        } else if (c >= 'a' && c <= 'z') {
30014c54:	d903      	bls.n	30014c5e <strtoul+0x7a>
        } else if (c >= '0' && c <= '9') {
30014c56:	3c30      	subs	r4, #48	; 0x30
30014c58:	b2e2      	uxtb	r2, r4
30014c5a:	2a09      	cmp	r2, #9
30014c5c:	d81b      	bhi.n	30014c96 <strtoul+0xb2>
        if (v < 0 || v >= base) {
30014c5e:	42b4      	cmp	r4, r6
30014c60:	d219      	bcs.n	30014c96 <strtoul+0xb2>
        new_ret = ret * base;
30014c62:	fb06 f203 	mul.w	r2, r6, r3
        if (new_ret / base != ret ||
30014c66:	fbb2 f1f6 	udiv	r1, r2, r6
30014c6a:	4299      	cmp	r1, r3
30014c6c:	d10a      	bne.n	30014c84 <strtoul+0xa0>
30014c6e:	1914      	adds	r4, r2, r4
30014c70:	bf2c      	ite	cs
30014c72:	2201      	movcs	r2, #1
30014c74:	2200      	movcc	r2, #0
                new_ret + v < new_ret ||
30014c76:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
30014c7a:	bf14      	ite	ne
30014c7c:	4613      	movne	r3, r2
30014c7e:	f042 0301 	orreq.w	r3, r2, #1
30014c82:	b1cb      	cbz	r3, 30014cb8 <strtoul+0xd4>
            errno = ERANGE;
30014c84:	f000 f84e 	bl	30014d24 <__geterrno>
            ret = ULONG_MAX;
30014c88:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            errno = ERANGE;
30014c8c:	f8c0 8000 	str.w	r8, [r0]
30014c90:	f815 4f01 	ldrb.w	r4, [r5, #1]!
    for (;;) {
30014c94:	e7d3      	b.n	30014c3e <strtoul+0x5a>
            if (endptr) {
30014c96:	f1b9 0f00 	cmp.w	r9, #0
30014c9a:	d001      	beq.n	30014ca0 <strtoul+0xbc>
                *endptr = (char *) nptr;
30014c9c:	f8c9 5000 	str.w	r5, [r9]
    if (neg && ret != ULONG_MAX) {
30014ca0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
30014ca4:	bf0c      	ite	eq
30014ca6:	2700      	moveq	r7, #0
30014ca8:	f007 0701 	andne.w	r7, r7, #1
30014cac:	2f00      	cmp	r7, #0
30014cae:	d0a9      	beq.n	30014c04 <strtoul+0x20>
        ret = -ret;
30014cb0:	425b      	negs	r3, r3
}
30014cb2:	4618      	mov	r0, r3
30014cb4:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
30014cb8:	4623      	mov	r3, r4
30014cba:	e7e9      	b.n	30014c90 <strtoul+0xac>
    if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
30014cbc:	2c30      	cmp	r4, #48	; 0x30
30014cbe:	d006      	beq.n	30014cce <strtoul+0xea>
        base = 10;
30014cc0:	2e00      	cmp	r6, #0
30014cc2:	bf08      	it	eq
30014cc4:	260a      	moveq	r6, #10
30014cc6:	e7b7      	b.n	30014c38 <strtoul+0x54>
30014cc8:	786c      	ldrb	r4, [r5, #1]
        nptr++;
30014cca:	4645      	mov	r5, r8
30014ccc:	e7b1      	b.n	30014c32 <strtoul+0x4e>
    if ((base == 0 || base == 16) && nptr[0] == '0' && nptr[1] == 'x') {
30014cce:	786b      	ldrb	r3, [r5, #1]
30014cd0:	2b78      	cmp	r3, #120	; 0x78
30014cd2:	d005      	beq.n	30014ce0 <strtoul+0xfc>
    } else if (base == 0 && nptr[0] == '0') {
30014cd4:	2e00      	cmp	r6, #0
30014cd6:	d1af      	bne.n	30014c38 <strtoul+0x54>
        nptr++;
30014cd8:	461c      	mov	r4, r3
30014cda:	3501      	adds	r5, #1
        base = 8;
30014cdc:	2608      	movs	r6, #8
        nptr++;
30014cde:	e7ab      	b.n	30014c38 <strtoul+0x54>
30014ce0:	78ac      	ldrb	r4, [r5, #2]
        base = 16;
30014ce2:	2610      	movs	r6, #16
        nptr += 2;
30014ce4:	3502      	adds	r5, #2
30014ce6:	e7a7      	b.n	30014c38 <strtoul+0x54>

30014ce8 <isspace>:
    return (c == ' ' || c == '\t');
}

int isspace(int c)
{
    return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
30014ce8:	2820      	cmp	r0, #32
30014cea:	d005      	beq.n	30014cf8 <isspace+0x10>
30014cec:	3809      	subs	r0, #9
30014cee:	2804      	cmp	r0, #4
30014cf0:	bf8c      	ite	hi
30014cf2:	2000      	movhi	r0, #0
30014cf4:	2001      	movls	r0, #1
30014cf6:	4770      	bx	r14
30014cf8:	2001      	movs	r0, #1
}
30014cfa:	4770      	bx	r14

30014cfc <isxdigit>:
    return isalpha(c) || isdigit(c);
}

int isxdigit(int c)
{
    return isdigit(c) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));
30014cfc:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
30014d00:	2b09      	cmp	r3, #9
30014d02:	d907      	bls.n	30014d14 <isxdigit+0x18>
30014d04:	f020 0020 	bic.w	r0, r0, #32
30014d08:	3841      	subs	r0, #65	; 0x41
30014d0a:	2805      	cmp	r0, #5
30014d0c:	bf8c      	ite	hi
30014d0e:	2000      	movhi	r0, #0
30014d10:	2001      	movls	r0, #1
30014d12:	4770      	bx	r14
30014d14:	2001      	movs	r0, #1
}
30014d16:	4770      	bx	r14

30014d18 <isprint>:
    return ((c < ' ') || (c == 0x7f));
}

int isprint(int c)
{
    return ((c >= 0x20) && (c < 0x7f));
30014d18:	3820      	subs	r0, #32
}
30014d1a:	285e      	cmp	r0, #94	; 0x5e
30014d1c:	bf8c      	ite	hi
30014d1e:	2000      	movhi	r0, #0
30014d20:	2001      	movls	r0, #1
30014d22:	4770      	bx	r14

30014d24 <__geterrno>:
static int _errno;

int *__geterrno(void)
{
    return &_errno;
}
30014d24:	f64d 006c 	movw	r0, #55404	; 0xd86c
30014d28:	f2c3 0002 	movt	r0, #12290	; 0x3002
30014d2c:	4770      	bx	r14
30014d2e:	bf00      	nop

30014d30 <_vsnprintf_output>:
static int _vsnprintf_output(const char *str, size_t len, void *state)
{
    struct _output_args *args = state;

    size_t count = 0;
    while (count < len) {
30014d30:	b191      	cbz	r1, 30014d58 <_vsnprintf_output+0x28>
{
30014d32:	b4f0      	push	{r4, r5, r6, r7}
30014d34:	1847      	adds	r7, r0, r1
        if (args->pos < args->len) {
30014d36:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
            args->outstr[args->pos++] = *str;
        }

        str++;
30014d3a:	3001      	adds	r0, #1
        if (args->pos < args->len) {
30014d3c:	42ac      	cmp	r4, r5
            args->outstr[args->pos++] = *str;
30014d3e:	f104 0601 	add.w	r6, r4, #1
30014d42:	bf3f      	itttt	cc
30014d44:	6815      	ldrcc	r5, [r2, #0]
30014d46:	6096      	strcc	r6, [r2, #8]
30014d48:	f810 6c01 	ldrbcc.w	r6, [r0, #-1]
30014d4c:	552e      	strbcc	r6, [r5, r4]
    while (count < len) {
30014d4e:	42b8      	cmp	r0, r7
30014d50:	d1f1      	bne.n	30014d36 <_vsnprintf_output+0x6>
        count++;
    }

    return count;
}
30014d52:	4608      	mov	r0, r1
30014d54:	bcf0      	pop	{r4, r5, r6, r7}
30014d56:	4770      	bx	r14
30014d58:	4608      	mov	r0, r1
30014d5a:	4770      	bx	r14

30014d5c <longlong_to_string>:
#define LEFTFORMATFLAG 0x00000800
#define LEADZEROFLAG   0x00001000
#define BLANKPOSFLAG   0x00002000

__NO_INLINE static char *longlong_to_string(char *buf, unsigned long long n, size_t len, uint flag, char *signchar)
{
30014d5c:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
30014d60:	f8dd 902c 	ldr.w	r9, [r13, #44]	; 0x2c
30014d64:	4680      	mov	r8, r0
30014d66:	4614      	mov	r4, r2
30014d68:	461d      	mov	r5, r3
30014d6a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    size_t pos = len;
    int negative = 0;

    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
30014d6c:	f419 6a80 	ands.w	r10, r9, #1024	; 0x400
30014d70:	d006      	beq.n	30014d80 <longlong_to_string+0x24>
30014d72:	2a00      	cmp	r2, #0
30014d74:	f175 0300 	sbcs.w	r3, r5, #0
    int negative = 0;
30014d78:	bfa8      	it	ge
30014d7a:	f04f 0a00 	movge.w	r10, #0
    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
30014d7e:	db44      	blt.n	30014e0a <longlong_to_string+0xae>
    }

    buf[--pos] = 0;

    /* only do the math if the number is >= 10 */
    while (n >= 10) {
30014d80:	2d00      	cmp	r5, #0
    buf[--pos] = 0;
30014d82:	f04f 0300 	mov.w	r3, #0
30014d86:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    while (n >= 10) {
30014d8a:	bf08      	it	eq
30014d8c:	2c0a      	cmpeq	r4, #10
    buf[--pos] = 0;
30014d8e:	f808 3007 	strb.w	r3, [r8, r7]
30014d92:	eb08 0b07 	add.w	r11, r8, r7
    while (n >= 10) {
30014d96:	d316      	bcc.n	30014dc6 <longlong_to_string+0x6a>
        int digit = n % 10;
30014d98:	4620      	mov	r0, r4
30014d9a:	4629      	mov	r1, r5
30014d9c:	220a      	movs	r2, #10
30014d9e:	2300      	movs	r3, #0
30014da0:	f005 f83e 	bl	30019e20 <__aeabi_uldivmod>

        n /= 10;
30014da4:	4620      	mov	r0, r4
30014da6:	4629      	mov	r1, r5
30014da8:	2300      	movs	r3, #0

        buf[--pos] = digit + '0';
30014daa:	3f01      	subs	r7, #1
        int digit = n % 10;
30014dac:	4616      	mov	r6, r2
        n /= 10;
30014dae:	220a      	movs	r2, #10
30014db0:	f005 f836 	bl	30019e20 <__aeabi_uldivmod>
        buf[--pos] = digit + '0';
30014db4:	3630      	adds	r6, #48	; 0x30
30014db6:	f80b 6d01 	strb.w	r6, [r11, #-1]!
        n /= 10;
30014dba:	4604      	mov	r4, r0
    while (n >= 10) {
30014dbc:	2900      	cmp	r1, #0
        n /= 10;
30014dbe:	460d      	mov	r5, r1
    while (n >= 10) {
30014dc0:	bf08      	it	eq
30014dc2:	280a      	cmpeq	r0, #10
30014dc4:	d2e8      	bcs.n	30014d98 <longlong_to_string+0x3c>
    }
    buf[--pos] = n + '0';
30014dc6:	3f01      	subs	r7, #1
30014dc8:	3430      	adds	r4, #48	; 0x30
30014dca:	eb08 0007 	add.w	r0, r8, r7
30014dce:	f808 4007 	strb.w	r4, [r8, r7]

    if (negative)
30014dd2:	f1ba 0f00 	cmp.w	r10, #0
30014dd6:	d113      	bne.n	30014e00 <longlong_to_string+0xa4>
        *signchar = '-';
    else if ((flag & SHOWSIGNFLAG))
30014dd8:	f419 7f00 	tst.w	r9, #512	; 0x200
30014ddc:	d10b      	bne.n	30014df6 <longlong_to_string+0x9a>
        *signchar = '+';
    else if ((flag & BLANKPOSFLAG))
30014dde:	f419 5f00 	tst.w	r9, #8192	; 0x2000
        *signchar = ' ';
30014de2:	bf1b      	ittet	ne
30014de4:	2320      	movne	r3, #32
30014de6:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
    else
        *signchar = '\0';
30014de8:	9b0c      	ldreq	r3, [sp, #48]	; 0x30
        *signchar = ' ';
30014dea:	7013      	strbne	r3, [r2, #0]
        *signchar = '\0';
30014dec:	bf08      	it	eq
30014dee:	f883 a000 	strbeq.w	r10, [r3]

    return &buf[pos];
}
30014df2:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '+';
30014df6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
30014df8:	232b      	movs	r3, #43	; 0x2b
30014dfa:	7013      	strb	r3, [r2, #0]
}
30014dfc:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '-';
30014e00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
30014e02:	232d      	movs	r3, #45	; 0x2d
30014e04:	7013      	strb	r3, [r2, #0]
}
30014e06:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        negative = 1;
30014e0a:	f04f 0a01 	mov.w	r10, #1
        n = -n;
30014e0e:	4254      	negs	r4, r2
30014e10:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
30014e14:	e7b4      	b.n	30014d80 <longlong_to_string+0x24>
30014e16:	bf00      	nop

30014e18 <exponent_to_string>:
__NO_INLINE static size_t exponent_to_string(char *buf, int32_t exponent)
{
    size_t pos = 0;

    /* handle sign */
    if (exponent < 0) {
30014e18:	2900      	cmp	r1, #0
        OUT('-');
30014e1a:	bfba      	itte	lt
30014e1c:	232d      	movlt	r3, #45	; 0x2d
        exponent = -exponent;
30014e1e:	4249      	neglt	r1, r1
    }
    else {
        OUT('+');
30014e20:	232b      	movge	r3, #43	; 0x2b
    }

    /* see how far we need to bump into the string to print from the right */
    if (exponent >= 1000) pos += 4;
30014e22:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
{
30014e26:	b4f0      	push	{r4, r5, r6, r7}
        OUT('+');
30014e28:	7003      	strb	r3, [r0, #0]
{
30014e2a:	4605      	mov	r5, r0
    if (exponent >= 1000) pos += 4;
30014e2c:	bfa8      	it	ge
30014e2e:	2005      	movge	r0, #5
30014e30:	da03      	bge.n	30014e3a <exponent_to_string+0x22>
    else if (exponent >= 100) pos += 3;
30014e32:	2963      	cmp	r1, #99	; 0x63
30014e34:	bfc8      	it	gt
30014e36:	2004      	movgt	r0, #4
30014e38:	dd1a      	ble.n	30014e70 <exponent_to_string+0x58>
    else pos++;

    /* print decimal string, from the right */
    uint i = pos;
    do {
        uint digit = (uint32_t)exponent % 10;
30014e3a:	f64c 47cd 	movw	r7, #52429	; 0xcccd

        buf[--i] = digit + '0';

        exponent /= 10;
30014e3e:	f246 6667 	movw	r6, #26215	; 0x6667
30014e42:	4405      	add	r5, r0
        uint digit = (uint32_t)exponent % 10;
30014e44:	f6cc 47cc 	movt	r7, #52428	; 0xcccc
        exponent /= 10;
30014e48:	f2c6 6666 	movt	r6, #26214	; 0x6666
        uint digit = (uint32_t)exponent % 10;
30014e4c:	fba7 2301 	umull	r2, r3, r7, r1
        exponent /= 10;
30014e50:	fb86 2401 	smull	r2, r4, r6, r1
        uint digit = (uint32_t)exponent % 10;
30014e54:	08db      	lsrs	r3, r3, #3
        exponent /= 10;
30014e56:	17ca      	asrs	r2, r1, #31
        uint digit = (uint32_t)exponent % 10;
30014e58:	eb03 0383 	add.w	r3, r3, r3, lsl #2
30014e5c:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
        buf[--i] = digit + '0';
30014e60:	3130      	adds	r1, #48	; 0x30
30014e62:	f805 1d01 	strb.w	r1, [r5, #-1]!
    }
    while (exponent != 0);
30014e66:	ebd2 01a4 	rsbs	r1, r2, r4, asr #2
30014e6a:	d1ef      	bne.n	30014e4c <exponent_to_string+0x34>

    /* return number of characters printed */
    return pos;
}
30014e6c:	bcf0      	pop	{r4, r5, r6, r7}
30014e6e:	4770      	bx	r14
    else pos++;
30014e70:	2909      	cmp	r1, #9
30014e72:	bfcc      	ite	gt
30014e74:	2003      	movgt	r0, #3
30014e76:	2002      	movle	r0, #2
30014e78:	e7df      	b.n	30014e3a <exponent_to_string+0x22>
30014e7a:	bf00      	nop

30014e7c <double_to_hexstring.isra.0>:

    buf[pos] = 0;
    return buf;
}

__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
30014e7c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30014e80:	ec57 6b10 	vmov	r6, r7, d0
30014e84:	4605      	mov	r5, r0
{
    size_t pos = 0;
    union double_int u = { d };

    uint32_t exponent = (u.i >> 52) & 0x7ff;
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
30014e86:	f64f 79ff 	movw	r9, #65535	; 0xffff
__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
30014e8a:	b085      	sub	sp, #20
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
30014e8c:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
30014e90:	f401 7180 	and.w	r1, r1, #256	; 0x100
    bool neg = !!(u.i & (1ULL << 63));

    /* start constructing the string */
    if (neg) {
30014e94:	2e00      	cmp	r6, #0
30014e96:	f177 0300 	sbcs.w	r3, r7, #0
        OUT('-');
30014e9a:	bfb8      	it	lt
30014e9c:	222d      	movlt	r2, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
30014e9e:	f3c7 500a 	ubfx	r0, r7, #20, #11
        OUT('-');
30014ea2:	bfb6      	itet	lt
30014ea4:	2301      	movlt	r3, #1
    size_t pos = 0;
30014ea6:	2300      	movge	r3, #0
        OUT('-');
30014ea8:	702a      	strblt	r2, [r5, #0]
    }

    /* look for special cases */
    if (exponent == 0x7ff) {
30014eaa:	f240 72ff 	movw	r2, #2047	; 0x7ff
30014eae:	4290      	cmp	r0, r2
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
30014eb0:	f2c0 090f 	movt	r9, #15
30014eb4:	ea06 0a08 	and.w	r10, r6, r8
30014eb8:	9101      	str	r1, [sp, #4]
30014eba:	ea07 0b09 	and.w	r11, r7, r9
    if (exponent == 0x7ff) {
30014ebe:	f000 8097 	beq.w	30014ff0 <double_to_hexstring.isra.0+0x174>
            /* NaN */
            if (flag & CAPSFLAG) OUTSTR("NAN");
            else OUTSTR("nan");
        }
    }
    else if (exponent == 0) {
30014ec2:	b9f0      	cbnz	r0, 30014f02 <double_to_hexstring.isra.0+0x86>
        if (fraction == 0) {
30014ec4:	ea5a 020b 	orrs.w	r2, r10, r11
            /* zero */
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
30014ec8:	9a01      	ldr	r2, [sp, #4]
        if (fraction == 0) {
30014eca:	f000 80d5 	beq.w	30015078 <double_to_hexstring.isra.0+0x1fc>
            else OUTSTR("0x0p+0");
        }
        else {
            /* denormalized */
            /* XXX does not handle */
            if (flag & CAPSFLAG) OUTSTR("DEN");
30014ece:	2a00      	cmp	r2, #0
30014ed0:	f040 810f 	bne.w	300150f2 <double_to_hexstring.isra.0+0x276>
            else OUTSTR("den");
30014ed4:	2064      	movs	r0, #100	; 0x64
30014ed6:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("DEN");
30014ed8:	2265      	movs	r2, #101	; 0x65
            else OUTSTR("den");
30014eda:	3301      	adds	r3, #1
30014edc:	4c95      	ldr	r4, [pc, #596]	; (30015134 <double_to_hexstring.isra.0+0x2b8>)
30014ede:	f801 0b01 	strb.w	r0, [r1], #1
30014ee2:	b13a      	cbz	r2, 30014ef4 <double_to_hexstring.isra.0+0x78>
30014ee4:	4610      	mov	r0, r2
30014ee6:	3301      	adds	r3, #1
30014ee8:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30014eec:	f801 0b01 	strb.w	r0, [r1], #1
30014ef0:	2a00      	cmp	r2, #0
30014ef2:	d1f7      	bne.n	30014ee4 <double_to_hexstring.isra.0+0x68>
        /* handle the exponent */
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
        pos += exponent_to_string(&buf[pos], exponent_signed);
    }

    buf[pos] = 0;
30014ef4:	2200      	movs	r2, #0
30014ef6:	442b      	add	r3, r5
    return buf;
}
30014ef8:	4628      	mov	r0, r5
    buf[pos] = 0;
30014efa:	701a      	strb	r2, [r3, #0]
}
30014efc:	b005      	add	sp, #20
30014efe:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        int exponent_signed = exponent - 1023;
30014f02:	f2a0 32ff 	subw	r2, r0, #1023	; 0x3ff
30014f06:	9203      	str	r2, [sp, #12]
        if (flag & CAPSFLAG) OUTSTR("0X1");
30014f08:	9a01      	ldr	r2, [sp, #4]
30014f0a:	2a00      	cmp	r2, #0
30014f0c:	f000 809e 	beq.w	3001504c <double_to_hexstring.isra.0+0x1d0>
30014f10:	2030      	movs	r0, #48	; 0x30
30014f12:	18e9      	adds	r1, r5, r3
30014f14:	2258      	movs	r2, #88	; 0x58
30014f16:	3301      	adds	r3, #1
30014f18:	4c87      	ldr	r4, [pc, #540]	; (30015138 <double_to_hexstring.isra.0+0x2bc>)
30014f1a:	f801 0b01 	strb.w	r0, [r1], #1
30014f1e:	b13a      	cbz	r2, 30014f30 <double_to_hexstring.isra.0+0xb4>
30014f20:	4610      	mov	r0, r2
30014f22:	3301      	adds	r3, #1
30014f24:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30014f28:	f801 0b01 	strb.w	r0, [r1], #1
30014f2c:	2a00      	cmp	r2, #0
30014f2e:	d1f7      	bne.n	30014f20 <double_to_hexstring.isra.0+0xa4>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
30014f30:	f241 12e4 	movw	r2, #4580	; 0x11e4
30014f34:	f2c3 0202 	movt	r2, #12290	; 0x3002
30014f38:	9202      	str	r2, [sp, #8]
        bool output_dot = false;
30014f3a:	f04f 0900 	mov.w	r9, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
30014f3e:	2130      	movs	r1, #48	; 0x30
        int zero_count = 0;
30014f40:	464e      	mov	r6, r9
                    OUT('0');
30014f42:	468c      	mov	r12, r1
30014f44:	e002      	b.n	30014f4c <double_to_hexstring.isra.0+0xd0>
        for (int i = 52 - 4; i >= 0; i -= 4) {
30014f46:	3904      	subs	r1, #4
30014f48:	1d0a      	adds	r2, r1, #4
30014f4a:	d045      	beq.n	30014fd8 <double_to_hexstring.isra.0+0x15c>
            uint digit = (fraction >> i) & 0xf;
30014f4c:	f1c1 0420 	rsb	r4, r1, #32
30014f50:	fa0b f404 	lsl.w	r4, r11, r4
30014f54:	fa2a f201 	lsr.w	r2, r10, r1
30014f58:	f1a1 0020 	sub.w	r0, r1, #32
30014f5c:	4322      	orrs	r2, r4
30014f5e:	fa2b f000 	lsr.w	r0, r11, r0
30014f62:	4302      	orrs	r2, r0
            if (digit == 0) {
30014f64:	f012 020f 	ands.w	r2, r2, #15
30014f68:	f103 0401 	add.w	r4, r3, #1
30014f6c:	eb05 0004 	add.w	r0, r5, r4
30014f70:	eb05 0e03 	add.w	r14, r5, r3
                zero_count++;
30014f74:	bf08      	it	eq
30014f76:	3601      	addeq	r6, #1
            if (digit == 0) {
30014f78:	d0e5      	beq.n	30014f46 <double_to_hexstring.isra.0+0xca>
30014f7a:	1c9f      	adds	r7, r3, #2
30014f7c:	eb05 0807 	add.w	r8, r5, r7
                if (!output_dot) {
30014f80:	f1b9 0f00 	cmp.w	r9, #0
30014f84:	d10c      	bne.n	30014fa0 <double_to_hexstring.isra.0+0x124>
30014f86:	f103 0903 	add.w	r9, r3, #3
                    OUT('.');
30014f8a:	f04f 032e 	mov.w	r3, #46	; 0x2e
30014f8e:	f88e 3000 	strb.w	r3, [r14]
30014f92:	4623      	mov	r3, r4
30014f94:	4686      	mov	r14, r0
30014f96:	463c      	mov	r4, r7
30014f98:	4640      	mov	r0, r8
30014f9a:	464f      	mov	r7, r9
30014f9c:	eb05 0809 	add.w	r8, r5, r9
                while (zero_count > 0) {
30014fa0:	2e00      	cmp	r6, #0
30014fa2:	d079      	beq.n	30015098 <double_to_hexstring.isra.0+0x21c>
30014fa4:	19ac      	adds	r4, r5, r6
30014fa6:	441c      	add	r4, r3
30014fa8:	18e8      	adds	r0, r5, r3
                    OUT('0');
30014faa:	f800 cb01 	strb.w	r12, [r0], #1
                while (zero_count > 0) {
30014fae:	4284      	cmp	r4, r0
30014fb0:	d1fb      	bne.n	30014faa <double_to_hexstring.isra.0+0x12e>
30014fb2:	441e      	add	r6, r3
30014fb4:	19a8      	adds	r0, r5, r6
30014fb6:	1c73      	adds	r3, r6, #1
30014fb8:	9000      	str	r0, [sp, #0]
30014fba:	1cb4      	adds	r4, r6, #2
30014fbc:	eb05 0e03 	add.w	r14, r5, r3
30014fc0:	1928      	adds	r0, r5, r4
                buf[pos++] = table[digit];
30014fc2:	9f02      	ldr	r7, [sp, #8]
        for (int i = 52 - 4; i >= 0; i -= 4) {
30014fc4:	3904      	subs	r1, #4
                buf[pos++] = table[digit];
30014fc6:	5cba      	ldrb	r2, [r7, r2]
30014fc8:	9f00      	ldr	r7, [sp, #0]
30014fca:	703a      	strb	r2, [r7, #0]
        for (int i = 52 - 4; i >= 0; i -= 4) {
30014fcc:	1d0a      	adds	r2, r1, #4
                buf[pos++] = table[digit];
30014fce:	f04f 0901 	mov.w	r9, #1
30014fd2:	f04f 0600 	mov.w	r6, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
30014fd6:	d1b9      	bne.n	30014f4c <double_to_hexstring.isra.0+0xd0>
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
30014fd8:	9b01      	ldr	r3, [sp, #4]
        pos += exponent_to_string(&buf[pos], exponent_signed);
30014fda:	9903      	ldr	r1, [sp, #12]
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
30014fdc:	2b00      	cmp	r3, #0
30014fde:	bf0c      	ite	eq
30014fe0:	2370      	moveq	r3, #112	; 0x70
30014fe2:	2350      	movne	r3, #80	; 0x50
30014fe4:	f88e 3000 	strb.w	r3, [r14]
        pos += exponent_to_string(&buf[pos], exponent_signed);
30014fe8:	f7ff ff16 	bl	30014e18 <exponent_to_string>
30014fec:	1903      	adds	r3, r0, r4
30014fee:	e781      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
        if (fraction == 0) {
30014ff0:	ea5a 020b 	orrs.w	r2, r10, r11
30014ff4:	d114      	bne.n	30015020 <double_to_hexstring.isra.0+0x1a4>
            if (flag & CAPSFLAG) OUTSTR("INF");
30014ff6:	2900      	cmp	r1, #0
30014ff8:	d155      	bne.n	300150a6 <double_to_hexstring.isra.0+0x22a>
            else OUTSTR("inf");
30014ffa:	2069      	movs	r0, #105	; 0x69
30014ffc:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("INF");
30014ffe:	226e      	movs	r2, #110	; 0x6e
            else OUTSTR("inf");
30015000:	3301      	adds	r3, #1
30015002:	4c4e      	ldr	r4, [pc, #312]	; (3001513c <double_to_hexstring.isra.0+0x2c0>)
30015004:	f801 0b01 	strb.w	r0, [r1], #1
30015008:	2a00      	cmp	r2, #0
3001500a:	f43f af73 	beq.w	30014ef4 <double_to_hexstring.isra.0+0x78>
3001500e:	4610      	mov	r0, r2
30015010:	3301      	adds	r3, #1
30015012:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30015016:	f801 0b01 	strb.w	r0, [r1], #1
3001501a:	2a00      	cmp	r2, #0
3001501c:	d1f7      	bne.n	3001500e <double_to_hexstring.isra.0+0x192>
3001501e:	e769      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
30015020:	9a01      	ldr	r2, [sp, #4]
30015022:	2a00      	cmp	r2, #0
30015024:	d152      	bne.n	300150cc <double_to_hexstring.isra.0+0x250>
            else OUTSTR("nan");
30015026:	206e      	movs	r0, #110	; 0x6e
30015028:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("NAN");
3001502a:	2261      	movs	r2, #97	; 0x61
            else OUTSTR("nan");
3001502c:	3301      	adds	r3, #1
3001502e:	4c44      	ldr	r4, [pc, #272]	; (30015140 <double_to_hexstring.isra.0+0x2c4>)
30015030:	f801 0b01 	strb.w	r0, [r1], #1
30015034:	2a00      	cmp	r2, #0
30015036:	f43f af5d 	beq.w	30014ef4 <double_to_hexstring.isra.0+0x78>
3001503a:	4610      	mov	r0, r2
3001503c:	3301      	adds	r3, #1
3001503e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30015042:	f801 0b01 	strb.w	r0, [r1], #1
30015046:	2a00      	cmp	r2, #0
30015048:	d1f7      	bne.n	3001503a <double_to_hexstring.isra.0+0x1be>
3001504a:	e753      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
        else OUTSTR("0x1");
3001504c:	2030      	movs	r0, #48	; 0x30
3001504e:	18e9      	adds	r1, r5, r3
        if (flag & CAPSFLAG) OUTSTR("0X1");
30015050:	2278      	movs	r2, #120	; 0x78
        else OUTSTR("0x1");
30015052:	3301      	adds	r3, #1
30015054:	4c3b      	ldr	r4, [pc, #236]	; (30015144 <double_to_hexstring.isra.0+0x2c8>)
30015056:	f801 0b01 	strb.w	r0, [r1], #1
3001505a:	b13a      	cbz	r2, 3001506c <double_to_hexstring.isra.0+0x1f0>
3001505c:	4610      	mov	r0, r2
3001505e:	3301      	adds	r3, #1
30015060:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30015064:	f801 0b01 	strb.w	r0, [r1], #1
30015068:	2a00      	cmp	r2, #0
3001506a:	d1f7      	bne.n	3001505c <double_to_hexstring.isra.0+0x1e0>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
3001506c:	f241 12d4 	movw	r2, #4564	; 0x11d4
30015070:	f2c3 0202 	movt	r2, #12290	; 0x3002
30015074:	9202      	str	r2, [sp, #8]
30015076:	e760      	b.n	30014f3a <double_to_hexstring.isra.0+0xbe>
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
30015078:	2a00      	cmp	r2, #0
3001507a:	d14d      	bne.n	30015118 <double_to_hexstring.isra.0+0x29c>
3001507c:	4c32      	ldr	r4, [pc, #200]	; (30015148 <double_to_hexstring.isra.0+0x2cc>)
3001507e:	18e9      	adds	r1, r5, r3
30015080:	2278      	movs	r2, #120	; 0x78
            else OUTSTR("0x0p+0");
30015082:	2030      	movs	r0, #48	; 0x30
30015084:	e002      	b.n	3001508c <double_to_hexstring.isra.0+0x210>
30015086:	4610      	mov	r0, r2
30015088:	f814 2f01 	ldrb.w	r2, [r4, #1]!
3001508c:	f801 0b01 	strb.w	r0, [r1], #1
30015090:	3301      	adds	r3, #1
30015092:	2a00      	cmp	r2, #0
30015094:	d1f7      	bne.n	30015086 <double_to_hexstring.isra.0+0x20a>
30015096:	e72d      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
                while (zero_count > 0) {
30015098:	f8cd e000 	str.w	r14, [r13]
3001509c:	4623      	mov	r3, r4
3001509e:	4686      	mov	r14, r0
300150a0:	463c      	mov	r4, r7
300150a2:	4640      	mov	r0, r8
300150a4:	e78d      	b.n	30014fc2 <double_to_hexstring.isra.0+0x146>
            if (flag & CAPSFLAG) OUTSTR("INF");
300150a6:	2049      	movs	r0, #73	; 0x49
300150a8:	18e9      	adds	r1, r5, r3
300150aa:	224e      	movs	r2, #78	; 0x4e
300150ac:	3301      	adds	r3, #1
300150ae:	4c27      	ldr	r4, [pc, #156]	; (3001514c <double_to_hexstring.isra.0+0x2d0>)
300150b0:	f801 0b01 	strb.w	r0, [r1], #1
300150b4:	2a00      	cmp	r2, #0
300150b6:	f43f af1d 	beq.w	30014ef4 <double_to_hexstring.isra.0+0x78>
300150ba:	4610      	mov	r0, r2
300150bc:	3301      	adds	r3, #1
300150be:	f814 2f01 	ldrb.w	r2, [r4, #1]!
300150c2:	f801 0b01 	strb.w	r0, [r1], #1
300150c6:	2a00      	cmp	r2, #0
300150c8:	d1f7      	bne.n	300150ba <double_to_hexstring.isra.0+0x23e>
300150ca:	e713      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
300150cc:	204e      	movs	r0, #78	; 0x4e
300150ce:	18e9      	adds	r1, r5, r3
300150d0:	2241      	movs	r2, #65	; 0x41
300150d2:	3301      	adds	r3, #1
300150d4:	4c1e      	ldr	r4, [pc, #120]	; (30015150 <double_to_hexstring.isra.0+0x2d4>)
300150d6:	f801 0b01 	strb.w	r0, [r1], #1
300150da:	2a00      	cmp	r2, #0
300150dc:	f43f af0a 	beq.w	30014ef4 <double_to_hexstring.isra.0+0x78>
300150e0:	4610      	mov	r0, r2
300150e2:	3301      	adds	r3, #1
300150e4:	f814 2f01 	ldrb.w	r2, [r4, #1]!
300150e8:	f801 0b01 	strb.w	r0, [r1], #1
300150ec:	2a00      	cmp	r2, #0
300150ee:	d1f7      	bne.n	300150e0 <double_to_hexstring.isra.0+0x264>
300150f0:	e700      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("DEN");
300150f2:	2044      	movs	r0, #68	; 0x44
300150f4:	18e9      	adds	r1, r5, r3
300150f6:	2245      	movs	r2, #69	; 0x45
300150f8:	3301      	adds	r3, #1
300150fa:	4c16      	ldr	r4, [pc, #88]	; (30015154 <double_to_hexstring.isra.0+0x2d8>)
300150fc:	f801 0b01 	strb.w	r0, [r1], #1
30015100:	2a00      	cmp	r2, #0
30015102:	f43f aef7 	beq.w	30014ef4 <double_to_hexstring.isra.0+0x78>
30015106:	4610      	mov	r0, r2
30015108:	3301      	adds	r3, #1
3001510a:	f814 2f01 	ldrb.w	r2, [r4, #1]!
3001510e:	f801 0b01 	strb.w	r0, [r1], #1
30015112:	2a00      	cmp	r2, #0
30015114:	d1f7      	bne.n	30015106 <double_to_hexstring.isra.0+0x28a>
30015116:	e6ed      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
30015118:	4c0f      	ldr	r4, [pc, #60]	; (30015158 <double_to_hexstring.isra.0+0x2dc>)
3001511a:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
3001511c:	2258      	movs	r2, #88	; 0x58
3001511e:	2030      	movs	r0, #48	; 0x30
30015120:	e002      	b.n	30015128 <double_to_hexstring.isra.0+0x2ac>
30015122:	4610      	mov	r0, r2
30015124:	f814 2f01 	ldrb.w	r2, [r4, #1]!
30015128:	f801 0b01 	strb.w	r0, [r1], #1
3001512c:	3301      	adds	r3, #1
3001512e:	2a00      	cmp	r2, #0
30015130:	d1f7      	bne.n	30015122 <double_to_hexstring.isra.0+0x2a6>
30015132:	e6df      	b.n	30014ef4 <double_to_hexstring.isra.0+0x78>
30015134:	300211b1 	.word	0x300211b1
30015138:	300211bd 	.word	0x300211bd
3001513c:	30021191 	.word	0x30021191
30015140:	30021199 	.word	0x30021199
30015144:	300211b9 	.word	0x300211b9
30015148:	300211a1 	.word	0x300211a1
3001514c:	30021195 	.word	0x30021195
30015150:	3002119d 	.word	0x3002119d
30015154:	300211b5 	.word	0x300211b5
30015158:	300211a9 	.word	0x300211a9

3001515c <longlong_to_hexstring.constprop.1>:
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
3001515c:	e92d 08f0 	stmdb	r13!, {r4, r5, r6, r7, r11}
30015160:	9905      	ldr	r1, [sp, #20]
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
30015162:	f241 17e4 	movw	r7, #4580	; 0x11e4
    buf[--pos] = 0;
30015166:	2500      	movs	r5, #0
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
30015168:	f2c3 0702 	movt	r7, #12290	; 0x3002
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
3001516c:	4693      	mov	r11, r2
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
3001516e:	f411 7f80 	tst.w	r1, #256	; 0x100
30015172:	f241 11d4 	movw	r1, #4564	; 0x11d4
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
30015176:	469c      	mov	r12, r3
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
30015178:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001517c:	bf08      	it	eq
3001517e:	460f      	moveq	r7, r1
30015180:	f100 041e 	add.w	r4, r0, #30
    buf[--pos] = 0;
30015184:	77c5      	strb	r5, [r0, #31]
        u /= 16;
30015186:	ea4f 111b 	mov.w	r1, r11, lsr #4
3001518a:	ea41 710c 	orr.w	r1, r1, r12, lsl #28
3001518e:	ea4f 161c 	mov.w	r6, r12, lsr #4
30015192:	46b4      	mov	r12, r6
        unsigned int digit = u % 16;
30015194:	f00b 020f 	and.w	r2, r11, #15
        u /= 16;
30015198:	468b      	mov	r11, r1
        buf[--pos] = table[digit];
3001519a:	5cbd      	ldrb	r5, [r7, r2]
3001519c:	4620      	mov	r0, r4
    while (u != 0);
3001519e:	ea5b 030c 	orrs.w	r3, r11, r12
        buf[--pos] = table[digit];
300151a2:	f804 5901 	strb.w	r5, [r4], #-1
    while (u != 0);
300151a6:	d1ee      	bne.n	30015186 <longlong_to_hexstring.constprop.1+0x2a>
}
300151a8:	e8bd 08f0 	ldmia.w	r13!, {r4, r5, r6, r7, r11}
300151ac:	4770      	bx	r14
300151ae:	bf00      	nop

300151b0 <double_to_string.constprop.2>:
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
300151b0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300151b4:	ec57 6b10 	vmov	r6, r7, d0
300151b8:	4604      	mov	r4, r0
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
300151ba:	f64f 7bff 	movw	r11, #65535	; 0xffff
300151be:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
300151c2:	f2c0 0b0f 	movt	r11, #15
    uint32_t exponent = (u.i >> 52) & 0x7ff;
300151c6:	ee10 8a10 	vmov	r8, s0
    if (neg) {
300151ca:	2e00      	cmp	r6, #0
300151cc:	f177 0000 	sbcs.w	r0, r7, #0
        OUT('-');
300151d0:	bfb8      	it	lt
300151d2:	202d      	movlt	r0, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
300151d4:	f3c7 550a 	ubfx	r5, r7, #20, #11
300151d8:	46b9      	mov	r9, r7
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
300151da:	ea0b 0307 	and.w	r3, r11, r7
        OUT('-');
300151de:	bfb8      	it	lt
300151e0:	7020      	strblt	r0, [r4, #0]
    if (exponent == 0x7ff) {
300151e2:	f240 70ff 	movw	r0, #2047	; 0x7ff
        OUT('-');
300151e6:	bfba      	itte	lt
300151e8:	f04f 0c01 	movlt.w	r12, #1
        d = -d;
300151ec:	f087 4700 	eorlt.w	r7, r7, #2147483648	; 0x80000000
    size_t pos = 0;
300151f0:	f04f 0c00 	movge.w	r12, #0
    if (exponent == 0x7ff) {
300151f4:	4285      	cmp	r5, r0
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
300151f6:	b089      	sub	sp, #36	; 0x24
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
300151f8:	ea0a 0206 	and.w	r2, r10, r6
    if (exponent == 0x7ff) {
300151fc:	d033      	beq.n	30015266 <double_to_string.constprop.2+0xb6>
    else if (exponent == 0) {
300151fe:	b9f5      	cbnz	r5, 3001523e <double_to_string.constprop.2+0x8e>
        if (fraction == 0) {
30015200:	4313      	orrs	r3, r2
30015202:	d059      	beq.n	300152b8 <double_to_string.constprop.2+0x108>
            if (flag & CAPSFLAG) OUTSTR("DEN");
30015204:	05cb      	lsls	r3, r1, #23
30015206:	f100 80ce 	bmi.w	300153a6 <double_to_string.constprop.2+0x1f6>
            else OUTSTR("den");
3001520a:	2164      	movs	r1, #100	; 0x64
3001520c:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("DEN");
30015210:	2365      	movs	r3, #101	; 0x65
            else OUTSTR("den");
30015212:	f10c 0c01 	add.w	r12, r12, #1
30015216:	488c      	ldr	r0, [pc, #560]	; (30015448 <double_to_string.constprop.2+0x298>)
30015218:	f802 1b01 	strb.w	r1, [r2], #1
3001521c:	b143      	cbz	r3, 30015230 <double_to_string.constprop.2+0x80>
3001521e:	4619      	mov	r1, r3
30015220:	f10c 0c01 	add.w	r12, r12, #1
30015224:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015228:	f802 1b01 	strb.w	r1, [r2], #1
3001522c:	2b00      	cmp	r3, #0
3001522e:	d1f6      	bne.n	3001521e <double_to_string.constprop.2+0x6e>
    buf[pos] = 0;
30015230:	2300      	movs	r3, #0
30015232:	4620      	mov	r0, r4
30015234:	f804 300c 	strb.w	r3, [r4, r12]
}
30015238:	b009      	add	sp, #36	; 0x24
3001523a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (exponent_signed < -52 || exponent_signed > 52) {
3001523e:	f2a5 30cb 	subw	r0, r5, #971	; 0x3cb
30015242:	2868      	cmp	r0, #104	; 0x68
30015244:	d948      	bls.n	300152d8 <double_to_string.constprop.2+0x128>
30015246:	4881      	ldr	r0, [pc, #516]	; (3001544c <double_to_string.constprop.2+0x29c>)
30015248:	eb04 020c 	add.w	r2, r4, r12
3001524c:	2372      	movs	r3, #114	; 0x72
            OUTSTR("<range>");
3001524e:	213c      	movs	r1, #60	; 0x3c
30015250:	e002      	b.n	30015258 <double_to_string.constprop.2+0xa8>
30015252:	4619      	mov	r1, r3
30015254:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015258:	f802 1b01 	strb.w	r1, [r2], #1
3001525c:	f10c 0c01 	add.w	r12, r12, #1
30015260:	2b00      	cmp	r3, #0
30015262:	d1f6      	bne.n	30015252 <double_to_string.constprop.2+0xa2>
30015264:	e7e4      	b.n	30015230 <double_to_string.constprop.2+0x80>
        if (fraction == 0) {
30015266:	4313      	orrs	r3, r2
30015268:	f401 7180 	and.w	r1, r1, #256	; 0x100
3001526c:	d112      	bne.n	30015294 <double_to_string.constprop.2+0xe4>
            if (flag & CAPSFLAG) OUTSTR("INF");
3001526e:	2900      	cmp	r1, #0
30015270:	f040 8089 	bne.w	30015386 <double_to_string.constprop.2+0x1d6>
30015274:	4876      	ldr	r0, [pc, #472]	; (30015450 <double_to_string.constprop.2+0x2a0>)
30015276:	eb04 020c 	add.w	r2, r4, r12
3001527a:	236e      	movs	r3, #110	; 0x6e
            else OUTSTR("inf");
3001527c:	2169      	movs	r1, #105	; 0x69
3001527e:	e002      	b.n	30015286 <double_to_string.constprop.2+0xd6>
30015280:	4619      	mov	r1, r3
30015282:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015286:	f802 1b01 	strb.w	r1, [r2], #1
3001528a:	f10c 0c01 	add.w	r12, r12, #1
3001528e:	2b00      	cmp	r3, #0
30015290:	d1f6      	bne.n	30015280 <double_to_string.constprop.2+0xd0>
30015292:	e7cd      	b.n	30015230 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("NAN");
30015294:	2900      	cmp	r1, #0
30015296:	d166      	bne.n	30015366 <double_to_string.constprop.2+0x1b6>
30015298:	486e      	ldr	r0, [pc, #440]	; (30015454 <double_to_string.constprop.2+0x2a4>)
3001529a:	eb04 020c 	add.w	r2, r4, r12
3001529e:	2361      	movs	r3, #97	; 0x61
            else OUTSTR("nan");
300152a0:	216e      	movs	r1, #110	; 0x6e
300152a2:	e002      	b.n	300152aa <double_to_string.constprop.2+0xfa>
300152a4:	4619      	mov	r1, r3
300152a6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
300152aa:	f802 1b01 	strb.w	r1, [r2], #1
300152ae:	f10c 0c01 	add.w	r12, r12, #1
300152b2:	2b00      	cmp	r3, #0
300152b4:	d1f6      	bne.n	300152a4 <double_to_string.constprop.2+0xf4>
300152b6:	e7bb      	b.n	30015230 <double_to_string.constprop.2+0x80>
300152b8:	4867      	ldr	r0, [pc, #412]	; (30015458 <double_to_string.constprop.2+0x2a8>)
300152ba:	eb04 020c 	add.w	r2, r4, r12
        if (fraction == 0) {
300152be:	232e      	movs	r3, #46	; 0x2e
            OUTSTR("0.000000");
300152c0:	2130      	movs	r1, #48	; 0x30
300152c2:	e002      	b.n	300152ca <double_to_string.constprop.2+0x11a>
300152c4:	4619      	mov	r1, r3
300152c6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
300152ca:	f802 1b01 	strb.w	r1, [r2], #1
300152ce:	f10c 0c01 	add.w	r12, r12, #1
300152d2:	2b00      	cmp	r3, #0
300152d4:	d1f6      	bne.n	300152c4 <double_to_string.constprop.2+0x114>
300152d6:	e7ab      	b.n	30015230 <double_to_string.constprop.2+0x80>
            OUTREV(0);
300152d8:	2000      	movs	r0, #0
300152da:	46a2      	mov	r10, r4
                OUTREV('0');
300152dc:	f04f 0c30 	mov.w	r12, #48	; 0x30
300152e0:	f104 0e18 	add.w	r14, r4, #24
            OUTREV(0);
300152e4:	f80a 0f1f 	strb.w	r0, [r10, #31]!
300152e8:	4650      	mov	r0, r10
                OUTREV('0');
300152ea:	f800 cd01 	strb.w	r12, [r0, #-1]!
            for (int i = 0; i <= 6; i++)
300152ee:	4570      	cmp	r0, r14
300152f0:	d1fb      	bne.n	300152ea <double_to_string.constprop.2+0x13a>
        int exponent_signed = exponent - 1023;
300152f2:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
            if (exponent_signed >= 0) {
300152f6:	2d00      	cmp	r5, #0
                OUTREV('0');
300152f8:	bfbc      	itt	lt
300152fa:	2517      	movlt	r5, #23
300152fc:	f884 c017 	strblt.w	r12, [r4, #23]
            if (exponent_signed >= 0) {
30015300:	da67      	bge.n	300153d2 <double_to_string.constprop.2+0x222>
            uint32_t frac = ((d - u) * 1000000) + .5;
30015302:	ed9f 6b4f 	vldr	d6, [r15, #316]	; 30015440 <double_to_string.constprop.2+0x290>
30015306:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
3001530a:	ec47 6b15 	vmov	d5, r6, r7
            buf[decimal_spot] = '.';
3001530e:	232e      	movs	r3, #46	; 0x2e
30015310:	7623      	strb	r3, [r4, #24]
            uint32_t frac = ((d - u) * 1000000) + .5;
30015312:	ee05 7b06 	vmla.f64	d7, d5, d6
30015316:	eefc 7bc7 	vcvt.u32.f64	s15, d7
3001531a:	ee17 3a90 	vmov	r3, s15
            while (frac != 0) {
3001531e:	b18b      	cbz	r3, 30015344 <double_to_string.constprop.2+0x194>
                uint digit = frac % 10;
30015320:	f64c 40cd 	movw	r0, #52429	; 0xcccd
30015324:	f6cc 40cc 	movt	r0, #52428	; 0xcccc
30015328:	fba0 1203 	umull	r1, r2, r0, r3
3001532c:	08d2      	lsrs	r2, r2, #3
3001532e:	eb02 0182 	add.w	r1, r2, r2, lsl #2
30015332:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
                buf[--i] = digit + '0';
30015336:	f103 0130 	add.w	r1, r3, #48	; 0x30
            while (frac != 0) {
3001533a:	4613      	mov	r3, r2
                buf[--i] = digit + '0';
3001533c:	f80a 1d01 	strb.w	r1, [r10, #-1]!
            while (frac != 0) {
30015340:	2a00      	cmp	r2, #0
30015342:	d1f1      	bne.n	30015328 <double_to_string.constprop.2+0x178>
            if (neg)
30015344:	f1b8 0f00 	cmp.w	r8, #0
30015348:	f179 0300 	sbcs.w	r3, r9, #0
3001534c:	bfa8      	it	ge
3001534e:	1960      	addge	r0, r4, r5
30015350:	f6bf af72 	bge.w	30015238 <double_to_string.constprop.2+0x88>
                OUTREV('-');
30015354:	4620      	mov	r0, r4
30015356:	2d00      	cmp	r5, #0
30015358:	f43f af6e 	beq.w	30015238 <double_to_string.constprop.2+0x88>
3001535c:	232d      	movs	r3, #45	; 0x2d
3001535e:	3d01      	subs	r5, #1
30015360:	1960      	adds	r0, r4, r5
30015362:	5563      	strb	r3, [r4, r5]
30015364:	e768      	b.n	30015238 <double_to_string.constprop.2+0x88>
30015366:	483d      	ldr	r0, [pc, #244]	; (3001545c <double_to_string.constprop.2+0x2ac>)
30015368:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("NAN");
3001536c:	2341      	movs	r3, #65	; 0x41
3001536e:	214e      	movs	r1, #78	; 0x4e
30015370:	e002      	b.n	30015378 <double_to_string.constprop.2+0x1c8>
30015372:	4619      	mov	r1, r3
30015374:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015378:	f802 1b01 	strb.w	r1, [r2], #1
3001537c:	f10c 0c01 	add.w	r12, r12, #1
30015380:	2b00      	cmp	r3, #0
30015382:	d1f6      	bne.n	30015372 <double_to_string.constprop.2+0x1c2>
30015384:	e754      	b.n	30015230 <double_to_string.constprop.2+0x80>
30015386:	4836      	ldr	r0, [pc, #216]	; (30015460 <double_to_string.constprop.2+0x2b0>)
30015388:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("INF");
3001538c:	234e      	movs	r3, #78	; 0x4e
3001538e:	2149      	movs	r1, #73	; 0x49
30015390:	e002      	b.n	30015398 <double_to_string.constprop.2+0x1e8>
30015392:	4619      	mov	r1, r3
30015394:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015398:	f802 1b01 	strb.w	r1, [r2], #1
3001539c:	f10c 0c01 	add.w	r12, r12, #1
300153a0:	2b00      	cmp	r3, #0
300153a2:	d1f6      	bne.n	30015392 <double_to_string.constprop.2+0x1e2>
300153a4:	e744      	b.n	30015230 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("DEN");
300153a6:	2144      	movs	r1, #68	; 0x44
300153a8:	eb04 020c 	add.w	r2, r4, r12
300153ac:	2345      	movs	r3, #69	; 0x45
300153ae:	f10c 0c01 	add.w	r12, r12, #1
300153b2:	482c      	ldr	r0, [pc, #176]	; (30015464 <double_to_string.constprop.2+0x2b4>)
300153b4:	f802 1b01 	strb.w	r1, [r2], #1
300153b8:	2b00      	cmp	r3, #0
300153ba:	f43f af39 	beq.w	30015230 <double_to_string.constprop.2+0x80>
300153be:	4619      	mov	r1, r3
300153c0:	f10c 0c01 	add.w	r12, r12, #1
300153c4:	f810 3f01 	ldrb.w	r3, [r0, #1]!
300153c8:	f802 1b01 	strb.w	r1, [r2], #1
300153cc:	2b00      	cmp	r3, #0
300153ce:	d1f6      	bne.n	300153be <double_to_string.constprop.2+0x20e>
300153d0:	e72e      	b.n	30015230 <double_to_string.constprop.2+0x80>
                u |= (1ULL<<52);
300153d2:	4693      	mov	r11, r2
300153d4:	f443 1c80 	orr.w	r12, r3, #1048576	; 0x100000
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
300153d8:	f04f 0e19 	mov.w	r14, #25
                u >>= (52 - exponent_signed);
300153dc:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
300153e0:	e9cd bc04 	strd	r11, r12, [r13, #16]
300153e4:	f1c5 0020 	rsb	r0, r5, #32
300153e8:	9b05      	ldr	r3, [sp, #20]
300153ea:	fa0c f000 	lsl.w	r0, r12, r0
300153ee:	fa22 fb05 	lsr.w	r11, r2, r5
300153f2:	f1a5 0220 	sub.w	r2, r5, #32
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
300153f6:	f10d 0c20 	add.w	r12, r13, #32
                u >>= (52 - exponent_signed);
300153fa:	fa23 f202 	lsr.w	r2, r3, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
300153fe:	9101      	str	r1, [sp, #4]
                u >>= (52 - exponent_signed);
30015400:	ea4b 0b00 	orr.w	r11, r11, r0
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
30015404:	2000      	movs	r0, #0
                u >>= (52 - exponent_signed);
30015406:	ea4b 0b02 	orr.w	r11, r11, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
3001540a:	465a      	mov	r2, r11
                u >>= (52 - exponent_signed);
3001540c:	40eb      	lsrs	r3, r5
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
3001540e:	f80c 0d01 	strb.w	r0, [r12, #-1]!
30015412:	4620      	mov	r0, r4
30015414:	f8cd c008 	str.w	r12, [r13, #8]
                u >>= (52 - exponent_signed);
30015418:	461d      	mov	r5, r3
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
3001541a:	f8cd e000 	str.w	r14, [r13]
3001541e:	f7ff fc9d 	bl	30014d5c <longlong_to_string>
30015422:	4629      	mov	r1, r5
                pos = s - buf;
30015424:	1b05      	subs	r5, r0, r4
30015426:	4658      	mov	r0, r11
30015428:	f004 fc74 	bl	30019d14 <__aeabi_ul2d>
3001542c:	ec47 6b17 	vmov	d7, r6, r7
30015430:	ec41 0b16 	vmov	d6, r0, r1
30015434:	ee37 7b46 	vsub.f64	d7, d7, d6
30015438:	ec57 6b17 	vmov	r6, r7, d7
3001543c:	e761      	b.n	30015302 <double_to_string.constprop.2+0x152>
3001543e:	bf00      	nop
30015440:	00000000 	.word	0x00000000
30015444:	412e8480 	.word	0x412e8480
30015448:	300211b1 	.word	0x300211b1
3001544c:	300211cd 	.word	0x300211cd
30015450:	30021191 	.word	0x30021191
30015454:	30021199 	.word	0x30021199
30015458:	300211c1 	.word	0x300211c1
3001545c:	3002119d 	.word	0x3002119d
30015460:	30021195 	.word	0x30021195
30015464:	300211b5 	.word	0x300211b5

30015468 <_printf_engine>:
#include <kernel/spinlock.h>
static spin_lock_t printf_lock=SPIN_LOCK_INITIAL_VALUE;
#endif

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
30015468:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
                OUTPUT_CHAR(uc);
                break;
            case 's':
                s = va_arg(ap, const char *);
                if (s == 0)
                    s = "<null>";
3001546c:	f241 1488 	movw	r4, #4488	; 0x1188
{
30015470:	b093      	sub	sp, #76	; 0x4c
30015472:	4607      	mov	r7, r0
                    s = "<null>";
30015474:	f2c3 0402 	movt	r4, #12290	; 0x3002
    size_t chars_written = 0;
30015478:	2600      	movs	r6, #0
{
3001547a:	4688      	mov	r8, r1
3001547c:	4610      	mov	r0, r2
3001547e:	469b      	mov	r11, r3
                    s = "<null>";
30015480:	9406      	str	r4, [sp, #24]
        signchar = '\0';
30015482:	f04f 0300 	mov.w	r3, #0
        while ((c = *fmt++) != 0) {
30015486:	1c44      	adds	r4, r0, #1
30015488:	7801      	ldrb	r1, [r0, #0]
        signchar = '\0';
3001548a:	f88d 3027 	strb.w	r3, [r13, #39]	; 0x27
        while ((c = *fmt++) != 0) {
3001548e:	b149      	cbz	r1, 300154a4 <_printf_engine+0x3c>
            if (c == '%')
30015490:	2925      	cmp	r1, #37	; 0x25
30015492:	d102      	bne.n	3001549a <_printf_engine+0x32>
30015494:	e010      	b.n	300154b8 <_printf_engine+0x50>
30015496:	2b25      	cmp	r3, #37	; 0x25
30015498:	d00f      	beq.n	300154ba <_printf_engine+0x52>
3001549a:	1a21      	subs	r1, r4, r0
        while ((c = *fmt++) != 0) {
3001549c:	f814 3b01 	ldrb.w	r3, [r4], #1
300154a0:	2b00      	cmp	r3, #0
300154a2:	d1f8      	bne.n	30015496 <_printf_engine+0x2e>
        OUTPUT_STRING(s, string_len);
300154a4:	4642      	mov	r2, r8
300154a6:	47b8      	blx	r7
300154a8:	f1b0 0c00 	subs.w	r12, r0, #0
300154ac:	f280 80d0 	bge.w	30015650 <_printf_engine+0x1e8>
exit:
#if WITH_SMP
    spin_unlock_irqrestore(&printf_lock, sstate);
#endif
    return (err < 0) ? err : (int)chars_written;
}
300154b0:	4660      	mov	r0, r12
300154b2:	b013      	add	sp, #76	; 0x4c
300154b4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        string_len = 0;
300154b8:	2100      	movs	r1, #0
        OUTPUT_STRING(s, string_len);
300154ba:	4642      	mov	r2, r8
300154bc:	47b8      	blx	r7
300154be:	f1b0 0c00 	subs.w	r12, r0, #0
300154c2:	dbf5      	blt.n	300154b0 <_printf_engine+0x48>
        format_num = 0;
300154c4:	2500      	movs	r5, #0
        OUTPUT_STRING(s, string_len);
300154c6:	4466      	add	r6, r12
        flags = 0;
300154c8:	46aa      	mov	r10, r5
        c = *fmt++;
300154ca:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c == 0)
300154ce:	2b00      	cmp	r3, #0
300154d0:	f000 80bf 	beq.w	30015652 <_printf_engine+0x1ea>
        switch (c) {
300154d4:	f1a3 0220 	sub.w	r2, r3, #32
300154d8:	2a5a      	cmp	r2, #90	; 0x5a
300154da:	f200 821d 	bhi.w	30015918 <_printf_engine+0x4b0>
300154de:	a101      	add	r1, pc, #4	; (adr r1, 300154e4 <_printf_engine+0x7c>)
300154e0:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
300154e4:	30015809 	.word	0x30015809
300154e8:	30015919 	.word	0x30015919
300154ec:	30015919 	.word	0x30015919
300154f0:	30015837 	.word	0x30015837
300154f4:	30015919 	.word	0x30015919
300154f8:	30015815 	.word	0x30015815
300154fc:	30015919 	.word	0x30015919
30015500:	30015919 	.word	0x30015919
30015504:	30015919 	.word	0x30015919
30015508:	30015919 	.word	0x30015919
3001550c:	30015919 	.word	0x30015919
30015510:	30015831 	.word	0x30015831
30015514:	30015919 	.word	0x30015919
30015518:	3001583d 	.word	0x3001583d
3001551c:	300154cb 	.word	0x300154cb
30015520:	30015919 	.word	0x30015919
30015524:	30015843 	.word	0x30015843
30015528:	30015843 	.word	0x30015843
3001552c:	30015843 	.word	0x30015843
30015530:	30015843 	.word	0x30015843
30015534:	30015843 	.word	0x30015843
30015538:	30015843 	.word	0x30015843
3001553c:	30015843 	.word	0x30015843
30015540:	30015843 	.word	0x30015843
30015544:	30015843 	.word	0x30015843
30015548:	30015843 	.word	0x30015843
3001554c:	30015919 	.word	0x30015919
30015550:	30015919 	.word	0x30015919
30015554:	30015919 	.word	0x30015919
30015558:	30015919 	.word	0x30015919
3001555c:	30015919 	.word	0x30015919
30015560:	30015919 	.word	0x30015919
30015564:	30015919 	.word	0x30015919
30015568:	300157a3 	.word	0x300157a3
3001556c:	30015919 	.word	0x30015919
30015570:	30015919 	.word	0x30015919
30015574:	30015919 	.word	0x30015919
30015578:	30015919 	.word	0x30015919
3001557c:	30015741 	.word	0x30015741
30015580:	30015919 	.word	0x30015919
30015584:	30015919 	.word	0x30015919
30015588:	30015919 	.word	0x30015919
3001558c:	30015919 	.word	0x30015919
30015590:	30015919 	.word	0x30015919
30015594:	30015919 	.word	0x30015919
30015598:	30015919 	.word	0x30015919
3001559c:	30015919 	.word	0x30015919
300155a0:	30015919 	.word	0x30015919
300155a4:	30015919 	.word	0x30015919
300155a8:	30015919 	.word	0x30015919
300155ac:	30015919 	.word	0x30015919
300155b0:	30015919 	.word	0x30015919
300155b4:	30015919 	.word	0x30015919
300155b8:	30015919 	.word	0x30015919
300155bc:	30015919 	.word	0x30015919
300155c0:	30015919 	.word	0x30015919
300155c4:	300158ef 	.word	0x300158ef
300155c8:	30015919 	.word	0x30015919
300155cc:	30015919 	.word	0x30015919
300155d0:	30015919 	.word	0x30015919
300155d4:	30015919 	.word	0x30015919
300155d8:	30015919 	.word	0x30015919
300155dc:	30015919 	.word	0x30015919
300155e0:	30015919 	.word	0x30015919
300155e4:	30015919 	.word	0x30015919
300155e8:	300157a7 	.word	0x300157a7
300155ec:	30015919 	.word	0x30015919
300155f0:	3001585d 	.word	0x3001585d
300155f4:	3001587f 	.word	0x3001587f
300155f8:	30015919 	.word	0x30015919
300155fc:	30015745 	.word	0x30015745
30015600:	30015919 	.word	0x30015919
30015604:	300158bd 	.word	0x300158bd
30015608:	3001587f 	.word	0x3001587f
3001560c:	300158fd 	.word	0x300158fd
30015610:	30015919 	.word	0x30015919
30015614:	30015903 	.word	0x30015903
30015618:	30015919 	.word	0x30015919
3001561c:	300157c9 	.word	0x300157c9
30015620:	30015919 	.word	0x30015919
30015624:	3001565d 	.word	0x3001565d
30015628:	30015919 	.word	0x30015919
3001562c:	30015919 	.word	0x30015919
30015630:	300158a1 	.word	0x300158a1
30015634:	30015913 	.word	0x30015913
30015638:	300158cd 	.word	0x300158cd
3001563c:	30015919 	.word	0x30015919
30015640:	30015919 	.word	0x30015919
30015644:	30015661 	.word	0x30015661
30015648:	30015919 	.word	0x30015919
3001564c:	3001580f 	.word	0x3001580f
        OUTPUT_STRING(s, string_len);
30015650:	4466      	add	r6, r12
    return (err < 0) ? err : (int)chars_written;
30015652:	46b4      	mov	r12, r6
}
30015654:	4660      	mov	r0, r12
30015656:	b013      	add	sp, #76	; 0x4c
30015658:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= LONGFLAG | ALTFLAG;
3001565c:	f04a 0a81 	orr.w	r10, r10, #129	; 0x81
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
30015660:	f01a 0f02 	tst.w	r10, #2
30015664:	f000 80be 	beq.w	300157e4 <_printf_engine+0x37c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015668:	f10b 0307 	add.w	r3, r11, #7
3001566c:	f023 0307 	bic.w	r3, r3, #7
30015670:	f103 0b08 	add.w	r11, r3, #8
30015674:	e9d3 2300 	ldrd	r2, r3, [r3]
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
30015678:	f8cd a000 	str.w	r10, [r13]
3001567c:	a80a      	add	r0, sp, #40	; 0x28
3001567e:	f7ff fd6d 	bl	3001515c <longlong_to_hexstring.constprop.1>
                if (flags & ALTFLAG) {
30015682:	f01a 0f80 	tst.w	r10, #128	; 0x80
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
30015686:	9005      	str	r0, [sp, #20]
30015688:	4681      	mov	r9, r0
                if (flags & ALTFLAG) {
3001568a:	f000 81b1 	beq.w	300159f0 <_printf_engine+0x588>
                    OUTPUT_CHAR('0');
3001568e:	2330      	movs	r3, #48	; 0x30
30015690:	4642      	mov	r2, r8
30015692:	2101      	movs	r1, #1
30015694:	a809      	add	r0, sp, #36	; 0x24
30015696:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
3001569a:	47b8      	blx	r7
3001569c:	f1b0 0c00 	subs.w	r12, r0, #0
300156a0:	f6ff af06 	blt.w	300154b0 <_printf_engine+0x48>
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
300156a4:	4642      	mov	r2, r8
300156a6:	f41a 7f80 	tst.w	r10, #256	; 0x100
300156aa:	bf0c      	ite	eq
300156ac:	2378      	moveq	r3, #120	; 0x78
300156ae:	2358      	movne	r3, #88	; 0x58
300156b0:	2101      	movs	r1, #1
300156b2:	a809      	add	r0, sp, #36	; 0x24
300156b4:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                    OUTPUT_CHAR('0');
300156b8:	4466      	add	r6, r12
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
300156ba:	47b8      	blx	r7
300156bc:	f1b0 0c00 	subs.w	r12, r0, #0
300156c0:	f6ff aef6 	blt.w	300154b0 <_printf_engine+0x48>
300156c4:	4648      	mov	r0, r9
300156c6:	4466      	add	r6, r12
300156c8:	f000 fb32 	bl	30015d30 <strlen>
        if (flags & LEFTFORMATFLAG) {
300156cc:	f41a 6f00 	tst.w	r10, #2048	; 0x800
300156d0:	4681      	mov	r9, r0
300156d2:	d14a      	bne.n	3001576a <_printf_engine+0x302>
300156d4:	f40a 5380 	and.w	r3, r10, #4096	; 0x1000
300156d8:	461a      	mov	r2, r3
300156da:	9307      	str	r3, [sp, #28]
            if (signchar != '\0' && format_num > 0)
300156dc:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
300156e0:	b18b      	cbz	r3, 30015706 <_printf_engine+0x29e>
300156e2:	2d00      	cmp	r5, #0
300156e4:	f000 8143 	beq.w	3001596e <_printf_engine+0x506>
                format_num--;
300156e8:	3d01      	subs	r5, #1
            if (flags & LEADZEROFLAG && signchar != '\0')
300156ea:	2a00      	cmp	r2, #0
300156ec:	f000 81d4 	beq.w	30015a98 <_printf_engine+0x630>
                OUTPUT_CHAR(signchar);
300156f0:	4642      	mov	r2, r8
300156f2:	2101      	movs	r1, #1
300156f4:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
300156f8:	a809      	add	r0, sp, #36	; 0x24
300156fa:	47b8      	blx	r7
300156fc:	f1b0 0c00 	subs.w	r12, r0, #0
30015700:	f6ff aed6 	blt.w	300154b0 <_printf_engine+0x48>
30015704:	4466      	add	r6, r12
            for (; format_num > string_len; format_num--)
30015706:	454d      	cmp	r5, r9
30015708:	f240 811f 	bls.w	3001594a <_printf_engine+0x4e2>
3001570c:	9b07      	ldr	r3, [sp, #28]
3001570e:	2b00      	cmp	r3, #0
30015710:	bf14      	ite	ne
30015712:	f04f 0a30 	movne.w	r10, #48	; 0x30
30015716:	f04f 0a20 	moveq.w	r10, #32
3001571a:	e002      	b.n	30015722 <_printf_engine+0x2ba>
3001571c:	454d      	cmp	r5, r9
3001571e:	f000 8114 	beq.w	3001594a <_printf_engine+0x4e2>
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
30015722:	4642      	mov	r2, r8
30015724:	2101      	movs	r1, #1
30015726:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
3001572a:	a809      	add	r0, sp, #36	; 0x24
3001572c:	47b8      	blx	r7
            for (; format_num > string_len; format_num--)
3001572e:	3d01      	subs	r5, #1
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
30015730:	2800      	cmp	r0, #0
30015732:	4406      	add	r6, r0
30015734:	daf2      	bge.n	3001571c <_printf_engine+0x2b4>
30015736:	4684      	mov	r12, r0
}
30015738:	4660      	mov	r0, r12
3001573a:	b013      	add	sp, #76	; 0x4c
3001573c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= CAPSFLAG;
30015740:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
30015744:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
30015746:	f10b 0b07 	add.w	r11, r11, #7
3001574a:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
3001574e:	a80a      	add	r0, sp, #40	; 0x28
30015750:	ed9b 0b00 	vldr	d0, [r11]
30015754:	f7ff fd2c 	bl	300151b0 <double_to_string.constprop.2>
                double d = va_arg(ap, double);
30015758:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
3001575c:	9005      	str	r0, [sp, #20]
3001575e:	f000 fae7 	bl	30015d30 <strlen>
30015762:	4681      	mov	r9, r0
        if (flags & LEFTFORMATFLAG) {
30015764:	f41a 6f00 	tst.w	r10, #2048	; 0x800
30015768:	d0b4      	beq.n	300156d4 <_printf_engine+0x26c>
            OUTPUT_STRING(s, string_len);
3001576a:	4649      	mov	r1, r9
3001576c:	4642      	mov	r2, r8
3001576e:	9805      	ldr	r0, [sp, #20]
30015770:	47b8      	blx	r7
30015772:	f1b0 0c00 	subs.w	r12, r0, #0
30015776:	f6ff ae9b 	blt.w	300154b0 <_printf_engine+0x48>
3001577a:	46e1      	mov	r9, r12
            for (; format_num > written; format_num--)
3001577c:	45ac      	cmp	r12, r5
            OUTPUT_STRING(s, string_len);
3001577e:	4466      	add	r6, r12
            for (; format_num > written; format_num--)
30015780:	d22e      	bcs.n	300157e0 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
30015782:	f04f 0a20 	mov.w	r10, #32
30015786:	e001      	b.n	3001578c <_printf_engine+0x324>
            for (; format_num > written; format_num--)
30015788:	45a9      	cmp	r9, r5
3001578a:	d029      	beq.n	300157e0 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
3001578c:	4642      	mov	r2, r8
3001578e:	2101      	movs	r1, #1
30015790:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
30015794:	a809      	add	r0, sp, #36	; 0x24
30015796:	47b8      	blx	r7
            for (; format_num > written; format_num--)
30015798:	3d01      	subs	r5, #1
                OUTPUT_CHAR(' ');
3001579a:	2800      	cmp	r0, #0
3001579c:	4406      	add	r6, r0
3001579e:	daf3      	bge.n	30015788 <_printf_engine+0x320>
300157a0:	e7c9      	b.n	30015736 <_printf_engine+0x2ce>
                flags |= CAPSFLAG;
300157a2:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
300157a6:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
300157a8:	f10b 0b07 	add.w	r11, r11, #7
300157ac:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
300157b0:	a80a      	add	r0, sp, #40	; 0x28
300157b2:	ed9b 0b00 	vldr	d0, [r11]
300157b6:	f7ff fb61 	bl	30014e7c <double_to_hexstring.isra.0>
                double d = va_arg(ap, double);
300157ba:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
300157be:	9005      	str	r0, [sp, #20]
300157c0:	f000 fab6 	bl	30015d30 <strlen>
300157c4:	4681      	mov	r9, r0
                goto _output_string;
300157c6:	e7cd      	b.n	30015764 <_printf_engine+0x2fc>
                if (flags & LONGLONGFLAG)
300157c8:	f01a 0f02 	tst.w	r10, #2
                ptr = va_arg(ap, void *);
300157cc:	f8db 3000 	ldr.w	r3, [r11]
300157d0:	f10b 0204 	add.w	r2, r11, #4
                if (flags & LONGLONGFLAG)
300157d4:	f000 80f7 	beq.w	300159c6 <_printf_engine+0x55e>
                    *(long long *)ptr = chars_written;
300157d8:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
300157da:	4693      	mov	r11, r2
                    *(long long *)ptr = chars_written;
300157dc:	2200      	movs	r2, #0
300157de:	605a      	str	r2, [r3, #4]
                ptr = va_arg(ap, void *);
300157e0:	4620      	mov	r0, r4
300157e2:	e64e      	b.n	30015482 <_printf_engine+0x1a>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
300157e4:	f01a 0f01 	tst.w	r10, #1
300157e8:	f040 80bb 	bne.w	30015962 <_printf_engine+0x4fa>
300157ec:	f01a 0f08 	tst.w	r10, #8
300157f0:	f040 8102 	bne.w	300159f8 <_printf_engine+0x590>
300157f4:	f01a 0f04 	tst.w	r10, #4
300157f8:	f000 8115 	beq.w	30015a26 <_printf_engine+0x5be>
300157fc:	f8bb 2000 	ldrh.w	r2, [r11]
30015800:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
30015802:	f10b 0b04 	add.w	r11, r11, #4
30015806:	e737      	b.n	30015678 <_printf_engine+0x210>
                flags |= BLANKPOSFLAG;
30015808:	f44a 5a00 	orr.w	r10, r10, #8192	; 0x2000
                goto next_format;
3001580c:	e65d      	b.n	300154ca <_printf_engine+0x62>
                flags |= SIZETFLAG;
3001580e:	f04a 0a10 	orr.w	r10, r10, #16
                goto next_format;
30015812:	e65a      	b.n	300154ca <_printf_engine+0x62>
                OUTPUT_CHAR('%');
30015814:	2325      	movs	r3, #37	; 0x25
30015816:	4642      	mov	r2, r8
30015818:	2101      	movs	r1, #1
3001581a:	a809      	add	r0, sp, #36	; 0x24
3001581c:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
30015820:	47b8      	blx	r7
30015822:	f1b0 0c00 	subs.w	r12, r0, #0
30015826:	f6ff ae43 	blt.w	300154b0 <_printf_engine+0x48>
                OUTPUT_CHAR(c);
3001582a:	4466      	add	r6, r12
                ptr = va_arg(ap, void *);
3001582c:	4620      	mov	r0, r4
3001582e:	e628      	b.n	30015482 <_printf_engine+0x1a>
                flags |= SHOWSIGNFLAG;
30015830:	f44a 7a00 	orr.w	r10, r10, #512	; 0x200
                goto next_format;
30015834:	e649      	b.n	300154ca <_printf_engine+0x62>
                flags |= ALTFLAG;
30015836:	f04a 0a80 	orr.w	r10, r10, #128	; 0x80
                goto next_format;
3001583a:	e646      	b.n	300154ca <_printf_engine+0x62>
                flags |= LEFTFORMATFLAG;
3001583c:	f44a 6a00 	orr.w	r10, r10, #2048	; 0x800
                goto next_format;
30015840:	e643      	b.n	300154ca <_printf_engine+0x62>
                if (c == '0' && format_num == 0)
30015842:	2b30      	cmp	r3, #48	; 0x30
30015844:	bf08      	it	eq
30015846:	2d00      	cmpeq	r5, #0
                format_num *= 10;
30015848:	eb05 0585 	add.w	r5, r5, r5, lsl #2
                format_num += c - '0';
3001584c:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
                    flags |= LEADZEROFLAG;
30015850:	bf08      	it	eq
30015852:	f44a 5a80 	orreq.w	r10, r10, #4096	; 0x1000
                format_num += c - '0';
30015856:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                goto next_format;
3001585a:	e636      	b.n	300154ca <_printf_engine+0x62>
                uc = va_arg(ap, unsigned int);
3001585c:	f8db 3000 	ldr.w	r3, [r11]
                OUTPUT_CHAR(uc);
30015860:	4642      	mov	r2, r8
30015862:	2101      	movs	r1, #1
30015864:	a809      	add	r0, sp, #36	; 0x24
                uc = va_arg(ap, unsigned int);
30015866:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                OUTPUT_CHAR(uc);
3001586a:	47b8      	blx	r7
3001586c:	f1b0 0c00 	subs.w	r12, r0, #0
30015870:	f6ff ae1e 	blt.w	300154b0 <_printf_engine+0x48>
                uc = va_arg(ap, unsigned int);
30015874:	f10b 0b04 	add.w	r11, r11, #4
                ptr = va_arg(ap, void *);
30015878:	4620      	mov	r0, r4
                OUTPUT_CHAR(uc);
3001587a:	4466      	add	r6, r12
3001587c:	e601      	b.n	30015482 <_printf_engine+0x1a>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
3001587e:	f01a 0f02 	tst.w	r10, #2
30015882:	d17f      	bne.n	30015984 <_printf_engine+0x51c>
30015884:	f01a 0f01 	tst.w	r10, #1
30015888:	f040 80bc 	bne.w	30015a04 <_printf_engine+0x59c>
3001588c:	f01a 0f08 	tst.w	r10, #8
30015890:	f000 80ed 	beq.w	30015a6e <_printf_engine+0x606>
30015894:	f99b 2000 	ldrsb.w	r2, [r11]
                    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
30015898:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
3001589c:	17d3      	asrs	r3, r2, #31
3001589e:	e079      	b.n	30015994 <_printf_engine+0x52c>
                s = va_arg(ap, const char *);
300158a0:	f8db 0000 	ldr.w	r0, [r11]
300158a4:	f10b 0b04 	add.w	r11, r11, #4
300158a8:	9005      	str	r0, [sp, #20]
                if (s == 0)
300158aa:	2800      	cmp	r0, #0
300158ac:	f000 80b6 	beq.w	30015a1c <_printf_engine+0x5b4>
300158b0:	f000 fa3e 	bl	30015d30 <strlen>
300158b4:	4681      	mov	r9, r0
                flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
300158b6:	f42a 5a80 	bic.w	r10, r10, #4096	; 0x1000
                goto _output_string;
300158ba:	e753      	b.n	30015764 <_printf_engine+0x2fc>
                if (flags & HALFFLAG)
300158bc:	f01a 0f04 	tst.w	r10, #4
                    flags |= HALFHALFFLAG;
300158c0:	bf18      	it	ne
300158c2:	f04a 0a08 	orrne.w	r10, r10, #8
                flags |= HALFFLAG;
300158c6:	f04a 0a04 	orr.w	r10, r10, #4
                goto next_format;
300158ca:	e5fe      	b.n	300154ca <_printf_engine+0x62>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
300158cc:	f01a 0f02 	tst.w	r10, #2
300158d0:	d170      	bne.n	300159b4 <_printf_engine+0x54c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
300158d2:	f01a 0f01 	tst.w	r10, #1
300158d6:	f040 809b 	bne.w	30015a10 <_printf_engine+0x5a8>
300158da:	f01a 0f08 	tst.w	r10, #8
300158de:	f000 80bd 	beq.w	30015a5c <_printf_engine+0x5f4>
300158e2:	f89b 2000 	ldrb.w	r2, [r11]
300158e6:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
300158e8:	f10b 0b04 	add.w	r11, r11, #4
300158ec:	e054      	b.n	30015998 <_printf_engine+0x530>
                flags |= CAPSFLAG;
300158ee:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
300158f2:	f01a 0f02 	tst.w	r10, #2
300158f6:	f43f af75 	beq.w	300157e4 <_printf_engine+0x37c>
300158fa:	e6b5      	b.n	30015668 <_printf_engine+0x200>
                flags |= INTMAXFLAG;
300158fc:	f04a 0a20 	orr.w	r10, r10, #32
                goto next_format;
30015900:	e5e3      	b.n	300154ca <_printf_engine+0x62>
                if (flags & LONGFLAG)
30015902:	f01a 0f01 	tst.w	r10, #1
                    flags |= LONGLONGFLAG;
30015906:	bf18      	it	ne
30015908:	f04a 0a02 	orrne.w	r10, r10, #2
                flags |= LONGFLAG;
3001590c:	f04a 0a01 	orr.w	r10, r10, #1
                goto next_format;
30015910:	e5db      	b.n	300154ca <_printf_engine+0x62>
                flags |= PTRDIFFFLAG;
30015912:	f04a 0a40 	orr.w	r10, r10, #64	; 0x40
                goto next_format;
30015916:	e5d8      	b.n	300154ca <_printf_engine+0x62>
                OUTPUT_CHAR('%');
30015918:	2525      	movs	r5, #37	; 0x25
3001591a:	4642      	mov	r2, r8
3001591c:	9305      	str	r3, [sp, #20]
3001591e:	2101      	movs	r1, #1
30015920:	f88d 5024 	strb.w	r5, [r13, #36]	; 0x24
30015924:	a809      	add	r0, sp, #36	; 0x24
30015926:	47b8      	blx	r7
30015928:	1e05      	subs	r5, r0, #0
3001592a:	f2c0 80b3 	blt.w	30015a94 <_printf_engine+0x62c>
                OUTPUT_CHAR(c);
3001592e:	9b05      	ldr	r3, [sp, #20]
30015930:	4642      	mov	r2, r8
30015932:	2101      	movs	r1, #1
30015934:	a809      	add	r0, sp, #36	; 0x24
30015936:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
3001593a:	47b8      	blx	r7
3001593c:	f1b0 0c00 	subs.w	r12, r0, #0
30015940:	f6ff adb6 	blt.w	300154b0 <_printf_engine+0x48>
                OUTPUT_CHAR('%');
30015944:	442e      	add	r6, r5
                OUTPUT_CHAR(c);
30015946:	4466      	add	r6, r12
30015948:	e770      	b.n	3001582c <_printf_engine+0x3c4>
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
3001594a:	9b07      	ldr	r3, [sp, #28]
3001594c:	2b00      	cmp	r3, #0
3001594e:	d075      	beq.n	30015a3c <_printf_engine+0x5d4>
            OUTPUT_STRING(s, string_len);
30015950:	4649      	mov	r1, r9
30015952:	4642      	mov	r2, r8
30015954:	9805      	ldr	r0, [sp, #20]
30015956:	47b8      	blx	r7
30015958:	f1b0 0c00 	subs.w	r12, r0, #0
3001595c:	f6ff ada8 	blt.w	300154b0 <_printf_engine+0x48>
30015960:	e763      	b.n	3001582a <_printf_engine+0x3c2>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015962:	f8db 2000 	ldr.w	r2, [r11]
30015966:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
30015968:	f10b 0b04 	add.w	r11, r11, #4
3001596c:	e684      	b.n	30015678 <_printf_engine+0x210>
            if (flags & LEADZEROFLAG && signchar != '\0')
3001596e:	9a07      	ldr	r2, [sp, #28]
30015970:	2a00      	cmp	r2, #0
30015972:	f47f aebd 	bne.w	300156f0 <_printf_engine+0x288>
30015976:	e065      	b.n	30015a44 <_printf_engine+0x5dc>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015978:	f01a 0f10 	tst.w	r10, #16
3001597c:	d142      	bne.n	30015a04 <_printf_engine+0x59c>
3001597e:	f01a 0f20 	tst.w	r10, #32
30015982:	d03f      	beq.n	30015a04 <_printf_engine+0x59c>
                    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
30015984:	f10b 0307 	add.w	r3, r11, #7
30015988:	f023 0307 	bic.w	r3, r3, #7
3001598c:	f103 0b08 	add.w	r11, r3, #8
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015990:	e9d3 2300 	ldrd	r2, r3, [r3]
                flags |= SIGNEDFLAG;
30015994:	f44a 6a80 	orr.w	r10, r10, #1024	; 0x400
                s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
30015998:	2120      	movs	r1, #32
3001599a:	f10d 0027 	add.w	r0, r13, #39	; 0x27
3001599e:	9100      	str	r1, [sp, #0]
300159a0:	e9cd a001 	strd	r10, r0, [r13, #4]
300159a4:	a80a      	add	r0, sp, #40	; 0x28
300159a6:	f7ff f9d9 	bl	30014d5c <longlong_to_string>
300159aa:	9005      	str	r0, [sp, #20]
300159ac:	f000 f9c0 	bl	30015d30 <strlen>
300159b0:	4681      	mov	r9, r0
                goto _output_string;
300159b2:	e6d7      	b.n	30015764 <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
300159b4:	f10b 0307 	add.w	r3, r11, #7
300159b8:	f023 0307 	bic.w	r3, r3, #7
300159bc:	f103 0b08 	add.w	r11, r3, #8
300159c0:	e9d3 2300 	ldrd	r2, r3, [r3]
300159c4:	e7e8      	b.n	30015998 <_printf_engine+0x530>
                else if (flags & LONGFLAG)
300159c6:	f01a 0f01 	tst.w	r10, #1
300159ca:	d10d      	bne.n	300159e8 <_printf_engine+0x580>
                else if (flags & HALFHALFFLAG)
300159cc:	f01a 0f08 	tst.w	r10, #8
                ptr = va_arg(ap, void *);
300159d0:	bf1c      	itt	ne
300159d2:	4693      	movne	r11, r2
                    *(signed char *)ptr = chars_written;
300159d4:	701e      	strbne	r6, [r3, #0]
                else if (flags & HALFHALFFLAG)
300159d6:	f47f af03 	bne.w	300157e0 <_printf_engine+0x378>
                else if (flags & HALFFLAG)
300159da:	f01a 0f04 	tst.w	r10, #4
                ptr = va_arg(ap, void *);
300159de:	bf1c      	itt	ne
300159e0:	4693      	movne	r11, r2
                    *(short *)ptr = chars_written;
300159e2:	801e      	strhne	r6, [r3, #0]
                else if (flags & HALFFLAG)
300159e4:	f47f aefc 	bne.w	300157e0 <_printf_engine+0x378>
                    *(int *)ptr = chars_written;
300159e8:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
300159ea:	4693      	mov	r11, r2
300159ec:	4620      	mov	r0, r4
300159ee:	e548      	b.n	30015482 <_printf_engine+0x1a>
300159f0:	f000 f99e 	bl	30015d30 <strlen>
300159f4:	4681      	mov	r9, r0
300159f6:	e6b5      	b.n	30015764 <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
300159f8:	f89b 2000 	ldrb.w	r2, [r11]
300159fc:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
300159fe:	f10b 0b04 	add.w	r11, r11, #4
30015a02:	e639      	b.n	30015678 <_printf_engine+0x210>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015a04:	f8db 2000 	ldr.w	r2, [r11]
                    va_arg(ap, int);
30015a08:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015a0c:	17d3      	asrs	r3, r2, #31
30015a0e:	e7c1      	b.n	30015994 <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015a10:	f8db 2000 	ldr.w	r2, [r11]
30015a14:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
30015a16:	f10b 0b04 	add.w	r11, r11, #4
30015a1a:	e7bd      	b.n	30015998 <_printf_engine+0x530>
                    s = "<null>";
30015a1c:	9b06      	ldr	r3, [sp, #24]
30015a1e:	f04f 0906 	mov.w	r9, #6
30015a22:	9305      	str	r3, [sp, #20]
30015a24:	e747      	b.n	300158b6 <_printf_engine+0x44e>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015a26:	f01a 0f10 	tst.w	r10, #16
30015a2a:	d19a      	bne.n	30015962 <_printf_engine+0x4fa>
30015a2c:	f01a 0f20 	tst.w	r10, #32
30015a30:	f47f ae1a 	bne.w	30015668 <_printf_engine+0x200>
30015a34:	f85b 2b04 	ldr.w	r2, [r11], #4
30015a38:	2300      	movs	r3, #0
30015a3a:	e61d      	b.n	30015678 <_printf_engine+0x210>
30015a3c:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
30015a40:	2b00      	cmp	r3, #0
30015a42:	d085      	beq.n	30015950 <_printf_engine+0x4e8>
                OUTPUT_CHAR(signchar);
30015a44:	4642      	mov	r2, r8
30015a46:	2101      	movs	r1, #1
30015a48:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
30015a4c:	a809      	add	r0, sp, #36	; 0x24
30015a4e:	47b8      	blx	r7
30015a50:	f1b0 0c00 	subs.w	r12, r0, #0
30015a54:	f6ff ad2c 	blt.w	300154b0 <_printf_engine+0x48>
30015a58:	4466      	add	r6, r12
30015a5a:	e779      	b.n	30015950 <_printf_engine+0x4e8>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015a5c:	f01a 0f04 	tst.w	r10, #4
30015a60:	d00e      	beq.n	30015a80 <_printf_engine+0x618>
30015a62:	f8bb 2000 	ldrh.w	r2, [r11]
30015a66:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
30015a68:	f10b 0b04 	add.w	r11, r11, #4
30015a6c:	e794      	b.n	30015998 <_printf_engine+0x530>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015a6e:	f01a 0f04 	tst.w	r10, #4
30015a72:	d081      	beq.n	30015978 <_printf_engine+0x510>
30015a74:	f9bb 2000 	ldrsh.w	r2, [r11]
                    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
30015a78:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
30015a7c:	17d3      	asrs	r3, r2, #31
30015a7e:	e789      	b.n	30015994 <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
30015a80:	f01a 0f10 	tst.w	r10, #16
30015a84:	d1c4      	bne.n	30015a10 <_printf_engine+0x5a8>
30015a86:	f01a 0f20 	tst.w	r10, #32
30015a8a:	d193      	bne.n	300159b4 <_printf_engine+0x54c>
30015a8c:	f85b 2b04 	ldr.w	r2, [r11], #4
30015a90:	2300      	movs	r3, #0
30015a92:	e781      	b.n	30015998 <_printf_engine+0x530>
                OUTPUT_CHAR('%');
30015a94:	46ac      	mov	r12, r5
30015a96:	e50b      	b.n	300154b0 <_printf_engine+0x48>
            for (; format_num > string_len; format_num--)
30015a98:	454d      	cmp	r5, r9
30015a9a:	f63f ae37 	bhi.w	3001570c <_printf_engine+0x2a4>
30015a9e:	e7cf      	b.n	30015a40 <_printf_engine+0x5d8>

30015aa0 <vsnprintf>:
{
30015aa0:	b570      	push	{r4, r5, r6, r14}
30015aa2:	4604      	mov	r4, r0
30015aa4:	b084      	sub	sp, #16
30015aa6:	460d      	mov	r5, r1
    args.pos = 0;
30015aa8:	2600      	movs	r6, #0
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
30015aaa:	f644 5031 	movw	r0, #19761	; 0x4d31
30015aae:	a901      	add	r1, sp, #4
    args.len = len;
30015ab0:	e9cd 4501 	strd	r4, r5, [r13, #4]
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
30015ab4:	f2c3 0001 	movt	r0, #12289	; 0x3001
    args.pos = 0;
30015ab8:	9603      	str	r6, [sp, #12]
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
30015aba:	f7ff fcd5 	bl	30015468 <_printf_engine>
    if (args.pos >= len)
30015abe:	9b03      	ldr	r3, [sp, #12]
30015ac0:	42ab      	cmp	r3, r5
        str[len-1] = '\0';
30015ac2:	bf26      	itte	cs
30015ac4:	1964      	addcs	r4, r4, r5
30015ac6:	f804 6c01 	strbcs.w	r6, [r4, #-1]
        str[wlen] = '\0';
30015aca:	5426      	strbcc	r6, [r4, r0]
}
30015acc:	b004      	add	sp, #16
30015ace:	bd70      	pop	{r4, r5, r6, r15}

30015ad0 <snprintf>:
{
30015ad0:	b40c      	push	{r2, r3}
30015ad2:	b510      	push	{r4, r14}
30015ad4:	b082      	sub	sp, #8
30015ad6:	ac04      	add	r4, sp, #16
30015ad8:	f854 2b04 	ldr.w	r2, [r4], #4
    va_start(ap, fmt);
30015adc:	9401      	str	r4, [sp, #4]
    err = vsnprintf(str, len, fmt, ap);
30015ade:	4623      	mov	r3, r4
30015ae0:	f7ff ffde 	bl	30015aa0 <vsnprintf>
}
30015ae4:	b002      	add	sp, #8
30015ae6:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
30015aea:	b002      	add	sp, #8
30015aec:	4770      	bx	r14
30015aee:	bf00      	nop

30015af0 <sprintf>:
{
30015af0:	b40e      	push	{r1, r2, r3}
30015af2:	b510      	push	{r4, r14}
30015af4:	b083      	sub	sp, #12
30015af6:	ac05      	add	r4, sp, #20
    return vsnprintf(str, INT_MAX, fmt, ap);
30015af8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
30015afc:	f854 2b04 	ldr.w	r2, [r4], #4
    va_start(ap, fmt);
30015b00:	9401      	str	r4, [sp, #4]
    return vsnprintf(str, INT_MAX, fmt, ap);
30015b02:	4623      	mov	r3, r4
30015b04:	f7ff ffcc 	bl	30015aa0 <vsnprintf>
}
30015b08:	b003      	add	sp, #12
30015b0a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
30015b0e:	b003      	add	sp, #12
30015b10:	4770      	bx	r14
30015b12:	bf00      	nop

30015b14 <_fprintf_output_func>:

static int _fprintf_output_func(const char *str, size_t len, void *state)
{
    FILE *fp = (FILE *)state;

    return io_write(fp->io, str, len);
30015b14:	6813      	ldr	r3, [r2, #0]
30015b16:	460a      	mov	r2, r1
30015b18:	4601      	mov	r1, r0
30015b1a:	4618      	mov	r0, r3
30015b1c:	f003 beb4 	b.w	30019888 <io_write>

30015b20 <putchar>:
    return io_write(fp->io, (char *)&c, 1);
30015b20:	f245 4330 	movw	r3, #21552	; 0x5430
30015b24:	2201      	movs	r2, #1
{
30015b26:	b500      	push	{r14}
    return io_write(fp->io, (char *)&c, 1);
30015b28:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30015b2c:	b083      	sub	sp, #12
    unsigned char c = _c;
30015b2e:	a902      	add	r1, sp, #8
30015b30:	f801 0d01 	strb.w	r0, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
30015b34:	6858      	ldr	r0, [r3, #4]
30015b36:	f003 fea7 	bl	30019888 <io_write>
}
30015b3a:	b003      	add	sp, #12
30015b3c:	f85d fb04 	ldr.w	r15, [r13], #4

30015b40 <fputs>:
{
30015b40:	b538      	push	{r3, r4, r5, r14}
30015b42:	460c      	mov	r4, r1
30015b44:	4605      	mov	r5, r0
    size_t len = strlen(s);
30015b46:	f000 f8f3 	bl	30015d30 <strlen>
    return io_write(fp->io, s, len);
30015b4a:	4629      	mov	r1, r5
30015b4c:	4602      	mov	r2, r0
30015b4e:	6820      	ldr	r0, [r4, #0]
}
30015b50:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return io_write(fp->io, s, len);
30015b54:	f003 be98 	b.w	30019888 <io_write>

30015b58 <fwrite>:
    if (size == 0 || count == 0)
30015b58:	2a00      	cmp	r2, #0
30015b5a:	bf18      	it	ne
30015b5c:	2900      	cmpne	r1, #0
30015b5e:	d006      	beq.n	30015b6e <fwrite+0x16>
30015b60:	681b      	ldr	r3, [r3, #0]
    if (likely(size == 1)) {
30015b62:	2901      	cmp	r1, #1
30015b64:	d105      	bne.n	30015b72 <fwrite+0x1a>
        return io_write(fp->io, ptr, count);
30015b66:	4601      	mov	r1, r0
30015b68:	4618      	mov	r0, r3
30015b6a:	f003 be8d 	b.w	30019888 <io_write>
        return 0;
30015b6e:	2000      	movs	r0, #0
}
30015b70:	4770      	bx	r14
{
30015b72:	b510      	push	{r4, r14}
30015b74:	460c      	mov	r4, r1
30015b76:	4601      	mov	r1, r0
    bytes_written = io_write(fp->io, ptr, size * count);
30015b78:	4618      	mov	r0, r3
30015b7a:	fb02 f204 	mul.w	r2, r2, r4
30015b7e:	f003 fe83 	bl	30019888 <io_write>
    return bytes_written / size;
30015b82:	fbb0 f0f4 	udiv	r0, r0, r4
}
30015b86:	bd10      	pop	{r4, r15}

30015b88 <getchar>:
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
30015b88:	f245 4330 	movw	r3, #21552	; 0x5430
30015b8c:	2201      	movs	r2, #1
30015b8e:	f2c3 0302 	movt	r3, #12290	; 0x3002
{
30015b92:	b500      	push	{r14}
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
30015b94:	6818      	ldr	r0, [r3, #0]
{
30015b96:	b083      	sub	sp, #12
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
30015b98:	f10d 0107 	add.w	r1, r13, #7
30015b9c:	f003 fe7c 	bl	30019898 <io_read>
    return (ret > 0) ? c : ret;
30015ba0:	2800      	cmp	r0, #0
30015ba2:	bfc8      	it	gt
30015ba4:	f89d 0007 	ldrbgt.w	r0, [r13, #7]
}
30015ba8:	b003      	add	sp, #12
30015baa:	f85d fb04 	ldr.w	r15, [r13], #4
30015bae:	bf00      	nop

30015bb0 <_printf>:
    va_end(ap);
    return err;
}

int _printf(const char *fmt, ...)
{
30015bb0:	b40f      	push	{r0, r1, r2, r3}
30015bb2:	b510      	push	{r4, r14}
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
30015bb4:	f645 3015 	movw	r0, #23317	; 0x5b15
{
30015bb8:	b082      	sub	sp, #8
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
30015bba:	4907      	ldr	r1, [pc, #28]	; (30015bd8 <_printf+0x28>)
{
30015bbc:	ac04      	add	r4, sp, #16
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
30015bbe:	f2c3 0001 	movt	r0, #12289	; 0x3001
{
30015bc2:	f854 2b04 	ldr.w	r2, [r4], #4
    va_list ap;
    int err;

    va_start(ap, fmt);
30015bc6:	9401      	str	r4, [sp, #4]
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
30015bc8:	4623      	mov	r3, r4
30015bca:	f7ff fc4d 	bl	30015468 <_printf_engine>
    err = vfprintf(stdout, fmt, ap);
    va_end(ap);

    return err;
}
30015bce:	b002      	add	sp, #8
30015bd0:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
30015bd4:	b004      	add	sp, #16
30015bd6:	4770      	bx	r14
30015bd8:	30025434 	.word	0x30025434

30015bdc <_vprintf>:
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
30015bdc:	4602      	mov	r2, r0
30015bde:	f645 3015 	movw	r0, #23317	; 0x5b15
30015be2:	460b      	mov	r3, r1
30015be4:	f2c3 0001 	movt	r0, #12289	; 0x3001
30015be8:	4901      	ldr	r1, [pc, #4]	; (30015bf0 <_vprintf+0x14>)
30015bea:	f7ff bc3d 	b.w	30015468 <_printf_engine>
30015bee:	bf00      	nop
30015bf0:	30025434 	.word	0x30025434

30015bf4 <memcmp>:
memcmp(const void *cs, const void *ct, size_t count)
{
    const unsigned char *su1, *su2;
    signed char res = 0;

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
30015bf4:	b1ca      	cbz	r2, 30015c2a <memcmp+0x36>
{
30015bf6:	b410      	push	{r4}
        if ((res = *su1 - *su2) != 0)
30015bf8:	780c      	ldrb	r4, [r1, #0]
30015bfa:	7803      	ldrb	r3, [r0, #0]
30015bfc:	1b1b      	subs	r3, r3, r4
30015bfe:	b25b      	sxtb	r3, r3
30015c00:	b9ab      	cbnz	r3, 30015c2e <memcmp+0x3a>
30015c02:	3a01      	subs	r2, #1
30015c04:	188b      	adds	r3, r1, r2
30015c06:	e006      	b.n	30015c16 <memcmp+0x22>
30015c08:	f810 2f01 	ldrb.w	r2, [r0, #1]!
30015c0c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
30015c10:	1b12      	subs	r2, r2, r4
30015c12:	b252      	sxtb	r2, r2
30015c14:	b92a      	cbnz	r2, 30015c22 <memcmp+0x2e>
    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
30015c16:	4299      	cmp	r1, r3
30015c18:	d1f6      	bne.n	30015c08 <memcmp+0x14>
30015c1a:	2000      	movs	r0, #0
            break;
    return res;
}
30015c1c:	f85d 4b04 	ldr.w	r4, [r13], #4
30015c20:	4770      	bx	r14
30015c22:	f85d 4b04 	ldr.w	r4, [r13], #4
30015c26:	4610      	mov	r0, r2
30015c28:	4770      	bx	r14
    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
30015c2a:	4610      	mov	r0, r2
}
30015c2c:	4770      	bx	r14
30015c2e:	4618      	mov	r0, r3
30015c30:	e7f4      	b.n	30015c1c <memcmp+0x28>
30015c32:	bf00      	nop

30015c34 <strchr>:
#include <sys/types.h>

char *
strchr(const char *s, int c)
{
    for (; *s != (char) c; ++s)
30015c34:	b2c9      	uxtb	r1, r1
30015c36:	7803      	ldrb	r3, [r0, #0]
30015c38:	428b      	cmp	r3, r1
30015c3a:	d006      	beq.n	30015c4a <strchr+0x16>
        if (*s == '\0')
30015c3c:	b123      	cbz	r3, 30015c48 <strchr+0x14>
    for (; *s != (char) c; ++s)
30015c3e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
30015c42:	428b      	cmp	r3, r1
30015c44:	d1fa      	bne.n	30015c3c <strchr+0x8>
30015c46:	4770      	bx	r14
            return NULL;
30015c48:	4618      	mov	r0, r3
    return (char *) s;
}
30015c4a:	4770      	bx	r14

30015c4c <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
30015c4c:	1e42      	subs	r2, r0, #1
30015c4e:	e000      	b.n	30015c52 <strcmp+0x6>
    signed char __res;

    while (1) {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
30015c50:	b148      	cbz	r0, 30015c66 <strcmp+0x1a>
30015c52:	f812 0f01 	ldrb.w	r0, [r2, #1]!
30015c56:	f811 3b01 	ldrb.w	r3, [r1], #1
30015c5a:	1ac3      	subs	r3, r0, r3
30015c5c:	b25b      	sxtb	r3, r3
30015c5e:	2b00      	cmp	r3, #0
30015c60:	d0f6      	beq.n	30015c50 <strcmp+0x4>
30015c62:	4618      	mov	r0, r3
            break;
    }

    return __res;
}
30015c64:	4770      	bx	r14
30015c66:	4770      	bx	r14

30015c68 <strdup>:
#include <stdlib.h>
#include <string.h>

char *
strdup(const char *str)
{
30015c68:	b570      	push	{r4, r5, r6, r14}
30015c6a:	4606      	mov	r6, r0
    size_t len;
    char *copy;

    len = strlen(str) + 1;
30015c6c:	f000 f860 	bl	30015d30 <strlen>
30015c70:	1c44      	adds	r4, r0, #1
    copy = malloc(len);
30015c72:	4620      	mov	r0, r4
30015c74:	f7fe fd38 	bl	300146e8 <malloc>
    if (copy == NULL)
30015c78:	4605      	mov	r5, r0
30015c7a:	b118      	cbz	r0, 30015c84 <strdup+0x1c>
        return NULL;
    memcpy(copy, str, len);
30015c7c:	4622      	mov	r2, r4
30015c7e:	4631      	mov	r1, r6
30015c80:	f7fe edf0 	blx	30014864 <memcpy>
    return copy;
}
30015c84:	4628      	mov	r0, r5
30015c86:	bd70      	pop	{r4, r5, r6, r15}

30015c88 <strlcat>:
#include <string.h>
#include <sys/types.h>

size_t
strlcat(char *dst, char const *src, size_t s)
{
30015c88:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
30015c8c:	460f      	mov	r7, r1
    size_t i;
    size_t j= strnlen(dst, s);
30015c8e:	4611      	mov	r1, r2
{
30015c90:	4615      	mov	r5, r2
30015c92:	4606      	mov	r6, r0
    size_t j= strnlen(dst, s);
30015c94:	f000 f886 	bl	30015da4 <strnlen>
30015c98:	4680      	mov	r8, r0

    if (!s) {
30015c9a:	b1e5      	cbz	r5, 30015cd6 <strlcat+0x4e>
        return j+strlen(src);
    }

    dst+= j;

    for (i= 0; ((i< s-1) && src[i]); i++) {
30015c9c:	1e6a      	subs	r2, r5, #1
    dst+= j;
30015c9e:	eb06 0100 	add.w	r1, r6, r0
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015ca2:	d01e      	beq.n	30015ce2 <strlcat+0x5a>
30015ca4:	783b      	ldrb	r3, [r7, #0]
30015ca6:	b1f3      	cbz	r3, 30015ce6 <strlcat+0x5e>
30015ca8:	460d      	mov	r5, r1
30015caa:	1c7e      	adds	r6, r7, #1
30015cac:	2400      	movs	r4, #0
30015cae:	e002      	b.n	30015cb6 <strlcat+0x2e>
30015cb0:	f816 3b01 	ldrb.w	r3, [r6], #1
30015cb4:	b133      	cbz	r3, 30015cc4 <strlcat+0x3c>
        dst[i]= src[i];
30015cb6:	f805 3b01 	strb.w	r3, [r5], #1
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015cba:	3401      	adds	r4, #1
30015cbc:	4637      	mov	r7, r6
30015cbe:	4294      	cmp	r4, r2
30015cc0:	4629      	mov	r1, r5
30015cc2:	d1f5      	bne.n	30015cb0 <strlcat+0x28>
    }

    dst[i]= 0;
30015cc4:	2300      	movs	r3, #0

    return j + i + strlen(src+i);
30015cc6:	4638      	mov	r0, r7
    dst[i]= 0;
30015cc8:	700b      	strb	r3, [r1, #0]
    return j + i + strlen(src+i);
30015cca:	f000 f831 	bl	30015d30 <strlen>
30015cce:	4420      	add	r0, r4
30015cd0:	4440      	add	r0, r8
}
30015cd2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return j+strlen(src);
30015cd6:	4638      	mov	r0, r7
30015cd8:	f000 f82a 	bl	30015d30 <strlen>
30015cdc:	4440      	add	r0, r8
}
30015cde:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015ce2:	4614      	mov	r4, r2
30015ce4:	e7ee      	b.n	30015cc4 <strlcat+0x3c>
30015ce6:	461c      	mov	r4, r3
30015ce8:	e7ec      	b.n	30015cc4 <strlcat+0x3c>
30015cea:	bf00      	nop

30015cec <strlcpy>:
size_t
strlcpy(char *dst, char const *src, size_t s)
{
    size_t i= 0;

    if (!s) {
30015cec:	b1da      	cbz	r2, 30015d26 <strlcpy+0x3a>
        return strlen(src);
    }

    for (i= 0; ((i< s-1) && src[i]); i++) {
30015cee:	3a01      	subs	r2, #1
{
30015cf0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
30015cf2:	4607      	mov	r7, r0
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015cf4:	d01a      	beq.n	30015d2c <strlcpy+0x40>
30015cf6:	780b      	ldrb	r3, [r1, #0]
30015cf8:	461c      	mov	r4, r3
30015cfa:	b16b      	cbz	r3, 30015d18 <strlcpy+0x2c>
30015cfc:	4605      	mov	r5, r0
30015cfe:	1c4e      	adds	r6, r1, #1
30015d00:	2400      	movs	r4, #0
30015d02:	e002      	b.n	30015d0a <strlcpy+0x1e>
30015d04:	f816 3b01 	ldrb.w	r3, [r6], #1
30015d08:	b133      	cbz	r3, 30015d18 <strlcpy+0x2c>
        dst[i]= src[i];
30015d0a:	f805 3b01 	strb.w	r3, [r5], #1
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015d0e:	3401      	adds	r4, #1
30015d10:	4631      	mov	r1, r6
30015d12:	4294      	cmp	r4, r2
30015d14:	462f      	mov	r7, r5
30015d16:	d1f5      	bne.n	30015d04 <strlcpy+0x18>
    }

    dst[i]= 0;
30015d18:	2300      	movs	r3, #0

    return i + strlen(src+i);
30015d1a:	4608      	mov	r0, r1
    dst[i]= 0;
30015d1c:	703b      	strb	r3, [r7, #0]
    return i + strlen(src+i);
30015d1e:	f000 f807 	bl	30015d30 <strlen>
}
30015d22:	4420      	add	r0, r4
30015d24:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return strlen(src);
30015d26:	4608      	mov	r0, r1
30015d28:	f000 b802 	b.w	30015d30 <strlen>
    for (i= 0; ((i< s-1) && src[i]); i++) {
30015d2c:	4614      	mov	r4, r2
30015d2e:	e7f3      	b.n	30015d18 <strlcpy+0x2c>

30015d30 <strlen>:
strlen(char const *s)
{
    size_t i;

    i= 0;
    while (s[i]) {
30015d30:	7803      	ldrb	r3, [r0, #0]
30015d32:	b13b      	cbz	r3, 30015d44 <strlen+0x14>
30015d34:	4603      	mov	r3, r0
    i= 0;
30015d36:	2000      	movs	r0, #0
        i+= 1;
30015d38:	3001      	adds	r0, #1
    while (s[i]) {
30015d3a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
30015d3e:	2a00      	cmp	r2, #0
30015d40:	d1fa      	bne.n	30015d38 <strlen+0x8>
30015d42:	4770      	bx	r14
    i= 0;
30015d44:	4618      	mov	r0, r3
    }

    return i;
}
30015d46:	4770      	bx	r14

30015d48 <strncpy>:
#include <string.h>
#include <sys/types.h>

char *
strncpy(char *dest, char const *src, size_t count)
{
30015d48:	b410      	push	{r4}
30015d4a:	440a      	add	r2, r1
30015d4c:	1e44      	subs	r4, r0, #1
    char *tmp = dest;

    while (count-- && (*dest++ = *src++) != '\0')
30015d4e:	e004      	b.n	30015d5a <strncpy+0x12>
30015d50:	f811 3b01 	ldrb.w	r3, [r1], #1
30015d54:	f804 3f01 	strb.w	r3, [r4, #1]!
30015d58:	b10b      	cbz	r3, 30015d5e <strncpy+0x16>
30015d5a:	4291      	cmp	r1, r2
30015d5c:	d1f8      	bne.n	30015d50 <strncpy+0x8>
        ;

    return tmp;
}
30015d5e:	f85d 4b04 	ldr.w	r4, [r13], #4
30015d62:	4770      	bx	r14

30015d64 <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
    signed char __res = 0;

    while (count > 0) {
30015d64:	b1e2      	cbz	r2, 30015da0 <strncmp+0x3c>
{
30015d66:	b430      	push	{r4, r5}
        if ((__res = *cs - *ct++) != 0 || !*cs++)
30015d68:	7805      	ldrb	r5, [r0, #0]
30015d6a:	780b      	ldrb	r3, [r1, #0]
30015d6c:	1aeb      	subs	r3, r5, r3
30015d6e:	1c4c      	adds	r4, r1, #1
30015d70:	b25b      	sxtb	r3, r3
30015d72:	b97b      	cbnz	r3, 30015d94 <strncmp+0x30>
30015d74:	b15d      	cbz	r5, 30015d8e <strncmp+0x2a>
30015d76:	4411      	add	r1, r2
30015d78:	e007      	b.n	30015d8a <strncmp+0x26>
30015d7a:	f810 2f01 	ldrb.w	r2, [r0, #1]!
30015d7e:	f814 3b01 	ldrb.w	r3, [r4], #1
30015d82:	1ad3      	subs	r3, r2, r3
30015d84:	b25b      	sxtb	r3, r3
30015d86:	b92b      	cbnz	r3, 30015d94 <strncmp+0x30>
30015d88:	b13a      	cbz	r2, 30015d9a <strncmp+0x36>
    while (count > 0) {
30015d8a:	42a1      	cmp	r1, r4
30015d8c:	d1f5      	bne.n	30015d7a <strncmp+0x16>
30015d8e:	2000      	movs	r0, #0
            break;
        count--;
    }

    return __res;
}
30015d90:	bc30      	pop	{r4, r5}
30015d92:	4770      	bx	r14
30015d94:	4618      	mov	r0, r3
30015d96:	bc30      	pop	{r4, r5}
30015d98:	4770      	bx	r14
30015d9a:	4610      	mov	r0, r2
30015d9c:	bc30      	pop	{r4, r5}
30015d9e:	4770      	bx	r14
    while (count > 0) {
30015da0:	4610      	mov	r0, r2
}
30015da2:	4770      	bx	r14

30015da4 <strnlen>:
size_t
strnlen(char const *s, size_t count)
{
    const char *sc;

    for (sc = s; count-- && *sc != '\0'; ++sc)
30015da4:	b1d1      	cbz	r1, 30015ddc <strnlen+0x38>
30015da6:	7803      	ldrb	r3, [r0, #0]
30015da8:	b1d3      	cbz	r3, 30015de0 <strnlen+0x3c>
30015daa:	1c43      	adds	r3, r0, #1
30015dac:	4401      	add	r1, r0
30015dae:	4299      	cmp	r1, r3
30015db0:	f103 0201 	add.w	r2, r3, #1
30015db4:	d016      	beq.n	30015de4 <strnlen+0x40>
{
30015db6:	b410      	push	{r4}
    for (sc = s; count-- && *sc != '\0'; ++sc)
30015db8:	781c      	ldrb	r4, [r3, #0]
30015dba:	b13c      	cbz	r4, 30015dcc <strnlen+0x28>
30015dbc:	4613      	mov	r3, r2
30015dbe:	4291      	cmp	r1, r2
30015dc0:	f102 0201 	add.w	r2, r2, #1
30015dc4:	d006      	beq.n	30015dd4 <strnlen+0x30>
30015dc6:	781c      	ldrb	r4, [r3, #0]
30015dc8:	2c00      	cmp	r4, #0
30015dca:	d1f7      	bne.n	30015dbc <strnlen+0x18>
        ;
    return sc - s;
}
30015dcc:	f85d 4b04 	ldr.w	r4, [r13], #4
30015dd0:	1a18      	subs	r0, r3, r0
30015dd2:	4770      	bx	r14
30015dd4:	f85d 4b04 	ldr.w	r4, [r13], #4
30015dd8:	1a08      	subs	r0, r1, r0
30015dda:	4770      	bx	r14
    for (sc = s; count-- && *sc != '\0'; ++sc)
30015ddc:	4608      	mov	r0, r1
30015dde:	4770      	bx	r14
30015de0:	4618      	mov	r0, r3
    return sc - s;
30015de2:	4770      	bx	r14
30015de4:	1a08      	subs	r0, r1, r0
}
30015de6:	4770      	bx	r14

30015de8 <strrchr>:
#include <string.h>
#include <sys/types.h>

char *
strrchr(char const *s, int c)
{
30015de8:	4603      	mov	r3, r0
    char const *last= c?0:s;


    while (*s) {
30015dea:	7802      	ldrb	r2, [r0, #0]
    char const *last= c?0:s;
30015dec:	2900      	cmp	r1, #0
30015dee:	bf18      	it	ne
30015df0:	2000      	movne	r0, #0
    while (*s) {
30015df2:	b132      	cbz	r2, 30015e02 <strrchr+0x1a>
        if (*s== c) {
30015df4:	428a      	cmp	r2, r1
30015df6:	bf08      	it	eq
30015df8:	4618      	moveq	r0, r3
    while (*s) {
30015dfa:	f813 2f01 	ldrb.w	r2, [r3, #1]!
30015dfe:	2a00      	cmp	r2, #0
30015e00:	d1f8      	bne.n	30015df4 <strrchr+0xc>

        s+= 1;
    }

    return (char *)last;
}
30015e02:	4770      	bx	r14

30015e04 <strstr>:
#include <string.h>
#include <sys/types.h>

char *
strstr(char const *s1, char const *s2)
{
30015e04:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
30015e06:	4604      	mov	r4, r0
    int l1, l2;

    l2 = strlen(s2);
30015e08:	4608      	mov	r0, r1
{
30015e0a:	460f      	mov	r7, r1
    l2 = strlen(s2);
30015e0c:	f7ff ff90 	bl	30015d30 <strlen>
    if (!l2)
30015e10:	b1a0      	cbz	r0, 30015e3c <strstr+0x38>
30015e12:	4606      	mov	r6, r0
        return (char *)s1;
    l1 = strlen(s1);
30015e14:	4620      	mov	r0, r4
30015e16:	f7ff ff8b 	bl	30015d30 <strlen>
30015e1a:	4605      	mov	r5, r0
    while (l1 >= l2) {
30015e1c:	4286      	cmp	r6, r0
30015e1e:	dd05      	ble.n	30015e2c <strstr+0x28>
        l1--;
        if (!memcmp(s1,s2,l2))
            return (char *)s1;
        s1++;
    }
    return NULL;
30015e20:	2000      	movs	r0, #0
}
30015e22:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    while (l1 >= l2) {
30015e24:	42ae      	cmp	r6, r5
        s1++;
30015e26:	f104 0401 	add.w	r4, r4, #1
    while (l1 >= l2) {
30015e2a:	dcf9      	bgt.n	30015e20 <strstr+0x1c>
        if (!memcmp(s1,s2,l2))
30015e2c:	4632      	mov	r2, r6
30015e2e:	4639      	mov	r1, r7
30015e30:	4620      	mov	r0, r4
        l1--;
30015e32:	3d01      	subs	r5, #1
        if (!memcmp(s1,s2,l2))
30015e34:	f7ff fede 	bl	30015bf4 <memcmp>
30015e38:	2800      	cmp	r0, #0
30015e3a:	d1f3      	bne.n	30015e24 <strstr+0x20>
30015e3c:	4620      	mov	r0, r4
}
30015e3e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

30015e40 <MD5Transform>:
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void
MD5Transform(__u32 buf[4], __u32 const in[16])
{
30015e40:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30015e44:	4605      	mov	r5, r0
30015e46:	b08d      	sub	sp, #52	; 0x34
	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];

	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
30015e48:	680e      	ldr	r6, [r1, #0]
30015e4a:	f24a 4378 	movw	r3, #42104	; 0xa478
30015e4e:	9509      	str	r5, [sp, #36]	; 0x24
30015e50:	f2cd 736a 	movt	r3, #55146	; 0xd76a
30015e54:	9600      	str	r6, [sp, #0]
30015e56:	4433      	add	r3, r6
30015e58:	9e09      	ldr	r6, [sp, #36]	; 0x24
30015e5a:	f24b 7456 	movw	r4, #46934	; 0xb756
	b = buf[1];
30015e5e:	f8d0 b004 	ldr.w	r11, [r0, #4]
30015e62:	f6ce 04c7 	movt	r4, #59591	; 0xe8c7
	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
30015e66:	6880      	ldr	r0, [r0, #8]
30015e68:	f247 02db 	movw	r2, #28891	; 0x70db
30015e6c:	68ed      	ldr	r5, [r5, #12]
30015e6e:	f2c2 4220 	movt	r2, #9248	; 0x2420
30015e72:	f640 77af 	movw	r7, #4015	; 0xfaf
30015e76:	4045      	eors	r5, r0
30015e78:	68f0      	ldr	r0, [r6, #12]
30015e7a:	ea05 050b 	and.w	r5, r5, r11
30015e7e:	f2cf 577c 	movt	r7, #62844	; 0xf57c
30015e82:	4045      	eors	r5, r0
30015e84:	6830      	ldr	r0, [r6, #0]
30015e86:	4403      	add	r3, r0
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
30015e88:	68b0      	ldr	r0, [r6, #8]
	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
30015e8a:	441d      	add	r5, r3
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
30015e8c:	684b      	ldr	r3, [r1, #4]
	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
30015e8e:	eb0b 6575 	add.w	r5, r11, r5, ror #25
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
30015e92:	ea8b 0e00 	eor.w	r14, r11, r0
30015e96:	ea0e 0e05 	and.w	r14, r14, r5
30015e9a:	ea8e 0e00 	eor.w	r14, r14, r0
30015e9e:	68f0      	ldr	r0, [r6, #12]
30015ea0:	441c      	add	r4, r3
30015ea2:	9301      	str	r3, [sp, #4]
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
30015ea4:	ea8b 0c05 	eor.w	r12, r11, r5
30015ea8:	f64c 63ee 	movw	r3, #52974	; 0xceee
30015eac:	4404      	add	r4, r0
30015eae:	68b0      	ldr	r0, [r6, #8]
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
30015eb0:	44a6      	add	r14, r4
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
30015eb2:	688c      	ldr	r4, [r1, #8]
30015eb4:	f2cc 13bd 	movt	r3, #49597	; 0xc1bd
30015eb8:	9402      	str	r4, [sp, #8]
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
30015eba:	eb05 5e3e 	add.w	r14, r5, r14, ror #20
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
30015ebe:	ea0c 0c0e 	and.w	r12, r12, r14
30015ec2:	4422      	add	r2, r4
30015ec4:	4402      	add	r2, r0
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
30015ec6:	6908      	ldr	r0, [r1, #16]
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
30015ec8:	ea8c 0c0b 	eor.w	r12, r12, r11
30015ecc:	9004      	str	r0, [sp, #16]
30015ece:	4494      	add	r12, r2
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
30015ed0:	68ca      	ldr	r2, [r1, #12]
30015ed2:	4407      	add	r7, r0
30015ed4:	4616      	mov	r6, r2
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
30015ed6:	eb0e 3cfc 	add.w	r12, r14, r12, ror #15
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
30015eda:	ea85 020e 	eor.w	r2, r5, r14
30015ede:	ea02 020c 	and.w	r2, r2, r12
30015ee2:	4433      	add	r3, r6
30015ee4:	445b      	add	r3, r11
30015ee6:	406a      	eors	r2, r5
30015ee8:	441a      	add	r2, r3
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
30015eea:	ea8e 040c 	eor.w	r4, r14, r12
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
30015eee:	eb0c 22b2 	add.w	r2, r12, r2, ror #10
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
30015ef2:	4014      	ands	r4, r2
30015ef4:	443d      	add	r5, r7
30015ef6:	9603      	str	r6, [sp, #12]
30015ef8:	ea84 030e 	eor.w	r3, r4, r14
30015efc:	f24c 662a 	movw	r6, #50730	; 0xc62a
30015f00:	442b      	add	r3, r5
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
30015f02:	694d      	ldr	r5, [r1, #20]
30015f04:	f2c4 7687 	movt	r6, #18311	; 0x4787
30015f08:	462c      	mov	r4, r5
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
30015f0a:	eb02 6373 	add.w	r3, r2, r3, ror #25
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
30015f0e:	ea8c 0502 	eor.w	r5, r12, r2
30015f12:	4426      	add	r6, r4
30015f14:	940a      	str	r4, [sp, #40]	; 0x28
30015f16:	401d      	ands	r5, r3
30015f18:	44b6      	add	r14, r6
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
30015f1a:	6988      	ldr	r0, [r1, #24]
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
30015f1c:	ea85 040c 	eor.w	r4, r5, r12
30015f20:	f244 6613 	movw	r6, #17939	; 0x4613
30015f24:	4474      	add	r4, r14
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
30015f26:	ea82 0503 	eor.w	r5, r2, r3
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
30015f2a:	eb03 5434 	add.w	r4, r3, r4, ror #20
30015f2e:	f6ca 0630 	movt	r6, #43056	; 0xa830
30015f32:	4406      	add	r6, r0
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
30015f34:	4025      	ands	r5, r4
30015f36:	44b4      	add	r12, r6
30015f38:	ea85 0702 	eor.w	r7, r5, r2
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
30015f3c:	69cd      	ldr	r5, [r1, #28]
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
30015f3e:	4467      	add	r7, r12
30015f40:	f249 5c01 	movw	r12, #38145	; 0x9501
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
30015f44:	462e      	mov	r6, r5
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
30015f46:	eb04 37f7 	add.w	r7, r4, r7, ror #15
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
30015f4a:	ea83 0504 	eor.w	r5, r3, r4
30015f4e:	f6cf 5c46 	movt	r12, #64838	; 0xfd46
30015f52:	44b4      	add	r12, r6
30015f54:	9605      	str	r6, [sp, #20]
30015f56:	403d      	ands	r5, r7
30015f58:	4462      	add	r2, r12
30015f5a:	f649 0cd8 	movw	r12, #39128	; 0x98d8
30015f5e:	ea85 0603 	eor.w	r6, r5, r3
	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
30015f62:	6a0d      	ldr	r5, [r1, #32]
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
30015f64:	4416      	add	r6, r2
30015f66:	f6c6 1c80 	movt	r12, #27008	; 0x6980
30015f6a:	eb07 26b6 	add.w	r6, r7, r6, ror #10
	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
30015f6e:	ea84 0207 	eor.w	r2, r4, r7
30015f72:	44ac      	add	r12, r5
30015f74:	9506      	str	r5, [sp, #24]
30015f76:	4032      	ands	r2, r6
30015f78:	4463      	add	r3, r12
30015f7a:	f24f 7caf 	movw	r12, #63407	; 0xf7af
30015f7e:	ea82 0504 	eor.w	r5, r2, r4
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
30015f82:	6a4a      	ldr	r2, [r1, #36]	; 0x24
	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
30015f84:	441d      	add	r5, r3
30015f86:	f6c8 3c44 	movt	r12, #35652	; 0x8b44
30015f8a:	eb06 6575 	add.w	r5, r6, r5, ror #25
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
30015f8e:	ea87 0306 	eor.w	r3, r7, r6
30015f92:	4494      	add	r12, r2
30015f94:	402b      	ands	r3, r5
30015f96:	4464      	add	r4, r12
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
30015f98:	f8d1 c028 	ldr.w	r12, [r1, #40]	; 0x28
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
30015f9c:	ea83 0a07 	eor.w	r10, r3, r7
30015fa0:	9207      	str	r2, [sp, #28]
30015fa2:	44a2      	add	r10, r4
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
30015fa4:	ea86 0305 	eor.w	r3, r6, r5
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
30015fa8:	eb05 5a3a 	add.w	r10, r5, r10, ror #20
30015fac:	f5ac 4224 	sub.w	r2, r12, #41984	; 0xa400
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
30015fb0:	ea03 030a 	and.w	r3, r3, r10
30015fb4:	3a4f      	subs	r2, #79	; 0x4f
30015fb6:	4417      	add	r7, r2
30015fb8:	f24d 74be 	movw	r4, #55230	; 0xd7be
30015fbc:	ea83 0806 	eor.w	r8, r3, r6
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
30015fc0:	6aca      	ldr	r2, [r1, #44]	; 0x2c
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
30015fc2:	44b8      	add	r8, r7
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
30015fc4:	ea85 030a 	eor.w	r3, r5, r10
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
30015fc8:	eb0a 38f8 	add.w	r8, r10, r8, ror #15
30015fcc:	f6c8 145c 	movt	r4, #35164	; 0x895c
30015fd0:	4414      	add	r4, r2
30015fd2:	9208      	str	r2, [sp, #32]
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
30015fd4:	ea03 0308 	and.w	r3, r3, r8
30015fd8:	4426      	add	r6, r4
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
30015fda:	f8d1 9030 	ldr.w	r9, [r1, #48]	; 0x30
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
30015fde:	ea83 0205 	eor.w	r2, r3, r5
30015fe2:	f241 1722 	movw	r7, #4386	; 0x1122
30015fe6:	4432      	add	r2, r6
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
30015fe8:	ea8a 0408 	eor.w	r4, r10, r8
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
30015fec:	eb08 22b2 	add.w	r2, r8, r2, ror #10
30015ff0:	f6c6 3790 	movt	r7, #27536	; 0x6b90
30015ff4:	444f      	add	r7, r9
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
30015ff6:	4014      	ands	r4, r2
30015ff8:	443d      	add	r5, r7
	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
30015ffa:	f8d1 e034 	ldr.w	r14, [r1, #52]	; 0x34
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
30015ffe:	ea84 030a 	eor.w	r3, r4, r10
30016002:	f247 1693 	movw	r6, #29075	; 0x7193
30016006:	442b      	add	r3, r5
30016008:	f6cf 5698 	movt	r6, #64920	; 0xfd98
3001600c:	eb02 6373 	add.w	r3, r2, r3, ror #25
	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
30016010:	ea88 0502 	eor.w	r5, r8, r2
30016014:	4476      	add	r6, r14
30016016:	401d      	ands	r5, r3
30016018:	44b2      	add	r10, r6
3001601a:	f244 368e 	movw	r6, #17294	; 0x438e
3001601e:	ea85 0408 	eor.w	r4, r5, r8
30016022:	4454      	add	r4, r10
	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
30016024:	f8d1 a038 	ldr.w	r10, [r1, #56]	; 0x38
30016028:	ea82 0503 	eor.w	r5, r2, r3
	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
3001602c:	eb03 5434 	add.w	r4, r3, r4, ror #20
30016030:	f2ca 6679 	movt	r6, #42617	; 0xa679
30016034:	4456      	add	r6, r10
	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
30016036:	4025      	ands	r5, r4
30016038:	44b0      	add	r8, r6
3001603a:	ea85 0702 	eor.w	r7, r5, r2
3001603e:	f640 0521 	movw	r5, #2081	; 0x821
30016042:	4447      	add	r7, r8
	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
30016044:	f8d1 803c 	ldr.w	r8, [r1, #60]	; 0x3c
30016048:	f6c4 15b4 	movt	r5, #18868	; 0x49b4
	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
3001604c:	eb04 37f7 	add.w	r7, r4, r7, ror #15
	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
30016050:	ea83 0104 	eor.w	r1, r3, r4
30016054:	4445      	add	r5, r8
30016056:	4039      	ands	r1, r7
30016058:	442a      	add	r2, r5
3001605a:	f242 5562 	movw	r5, #9570	; 0x2562
3001605e:	ea81 0603 	eor.w	r6, r1, r3
30016062:	4416      	add	r6, r2
30016064:	f24b 3140 	movw	r1, #45888	; 0xb340
30016068:	f2cf 651e 	movt	r5, #63006	; 0xf61e
3001606c:	eb07 26b6 	add.w	r6, r7, r6, ror #10

	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
30016070:	ea87 0206 	eor.w	r2, r7, r6
30016074:	f2cc 0140 	movt	r1, #49216	; 0xc040
30016078:	920b      	str	r2, [sp, #44]	; 0x2c
3001607a:	4401      	add	r1, r0
3001607c:	9a01      	ldr	r2, [sp, #4]
3001607e:	4415      	add	r5, r2
30016080:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
30016082:	442b      	add	r3, r5
30016084:	900b      	str	r0, [sp, #44]	; 0x2c
30016086:	9808      	ldr	r0, [sp, #32]
30016088:	4022      	ands	r2, r4
3001608a:	407a      	eors	r2, r7
3001608c:	18d5      	adds	r5, r2, r3
3001608e:	f24c 72aa 	movw	r2, #51114	; 0xc7aa
30016092:	440c      	add	r4, r1
30016094:	f645 2151 	movw	r1, #23121	; 0x5a51
30016098:	eb06 65f5 	add.w	r5, r6, r5, ror #27
	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
3001609c:	ea86 0305 	eor.w	r3, r6, r5
300160a0:	403b      	ands	r3, r7
300160a2:	4073      	eors	r3, r6
300160a4:	441c      	add	r4, r3
300160a6:	f2c2 615e 	movt	r1, #9822	; 0x265e
300160aa:	eb05 54f4 	add.w	r4, r5, r4, ror #23
	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
300160ae:	ea85 0304 	eor.w	r3, r5, r4
300160b2:	4401      	add	r1, r0
300160b4:	4033      	ands	r3, r6
300160b6:	406b      	eors	r3, r5
300160b8:	440f      	add	r7, r1
300160ba:	19d9      	adds	r1, r3, r7
300160bc:	9f00      	ldr	r7, [sp, #0]
300160be:	f6ce 12b6 	movt	r2, #59830	; 0xe9b6
300160c2:	980a      	ldr	r0, [sp, #40]	; 0x28
300160c4:	eb04 41b1 	add.w	r1, r4, r1, ror #18
	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
300160c8:	ea84 0301 	eor.w	r3, r4, r1
300160cc:	443a      	add	r2, r7
300160ce:	402b      	ands	r3, r5
300160d0:	f241 4753 	movw	r7, #5203	; 0x1453
300160d4:	4416      	add	r6, r2
300160d6:	ea83 0204 	eor.w	r2, r3, r4
300160da:	f241 035d 	movw	r3, #4189	; 0x105d
300160de:	4432      	add	r2, r6
300160e0:	f2cd 632f 	movt	r3, #54831	; 0xd62f
300160e4:	eb01 3232 	add.w	r2, r1, r2, ror #12
	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
300160e8:	ea81 0602 	eor.w	r6, r1, r2
300160ec:	4403      	add	r3, r0
300160ee:	4026      	ands	r6, r4
300160f0:	404e      	eors	r6, r1
300160f2:	441d      	add	r5, r3
300160f4:	1973      	adds	r3, r6, r5
300160f6:	f64f 36c8 	movw	r6, #64456	; 0xfbc8
300160fa:	f2c0 2744 	movt	r7, #580	; 0x244
300160fe:	eb02 63f3 	add.w	r3, r2, r3, ror #27
	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
30016102:	ea82 0503 	eor.w	r5, r2, r3
30016106:	4467      	add	r7, r12
30016108:	400d      	ands	r5, r1
3001610a:	4055      	eors	r5, r2
3001610c:	443c      	add	r4, r7
3001610e:	f24e 6781 	movw	r7, #59009	; 0xe681
30016112:	442c      	add	r4, r5
30016114:	f6cd 07a1 	movt	r7, #55457	; 0xd8a1
30016118:	eb03 54f4 	add.w	r4, r3, r4, ror #23
	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
3001611c:	ea83 0504 	eor.w	r5, r3, r4
30016120:	4447      	add	r7, r8
30016122:	4015      	ands	r5, r2
30016124:	405d      	eors	r5, r3
30016126:	4439      	add	r1, r7
30016128:	186f      	adds	r7, r5, r1
3001612a:	9d04      	ldr	r5, [sp, #16]
3001612c:	f2ce 76d3 	movt	r6, #59347	; 0xe7d3
30016130:	9807      	ldr	r0, [sp, #28]
30016132:	eb04 47b7 	add.w	r7, r4, r7, ror #18
	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
30016136:	ea84 0107 	eor.w	r1, r4, r7
3001613a:	442e      	add	r6, r5
3001613c:	4019      	ands	r1, r3
3001613e:	f64c 55e6 	movw	r5, #52710	; 0xcde6
30016142:	4432      	add	r2, r6
30016144:	ea81 0604 	eor.w	r6, r1, r4
30016148:	4416      	add	r6, r2
3001614a:	f240 71d6 	movw	r1, #2006	; 0x7d6
3001614e:	f2c2 15e1 	movt	r5, #8673	; 0x21e1
30016152:	eb07 3636 	add.w	r6, r7, r6, ror #12
	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
30016156:	ea87 0206 	eor.w	r2, r7, r6
3001615a:	4405      	add	r5, r0
3001615c:	4022      	ands	r2, r4
3001615e:	407a      	eors	r2, r7
30016160:	442b      	add	r3, r5
30016162:	18d5      	adds	r5, r2, r3
30016164:	9803      	ldr	r0, [sp, #12]
30016166:	f2cc 3137 	movt	r1, #49975	; 0xc337
3001616a:	eb06 65f5 	add.w	r5, r6, r5, ror #27
	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
3001616e:	ea86 0305 	eor.w	r3, r6, r5
30016172:	4451      	add	r1, r10
30016174:	403b      	ands	r3, r7
30016176:	4073      	eors	r3, r6
30016178:	f241 42ed 	movw	r2, #5357	; 0x14ed
3001617c:	440c      	add	r4, r1
3001617e:	f640 5187 	movw	r1, #3463	; 0xd87
30016182:	441c      	add	r4, r3
30016184:	f2cf 41d5 	movt	r1, #62677	; 0xf4d5
30016188:	eb05 54f4 	add.w	r4, r5, r4, ror #23
	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
3001618c:	ea85 0304 	eor.w	r3, r5, r4
30016190:	4401      	add	r1, r0
30016192:	4033      	ands	r3, r6
30016194:	406b      	eors	r3, r5
30016196:	440f      	add	r7, r1
30016198:	19d9      	adds	r1, r3, r7
3001619a:	9f06      	ldr	r7, [sp, #24]
3001619c:	f2c4 525a 	movt	r2, #17754	; 0x455a
300161a0:	9805      	ldr	r0, [sp, #20]
300161a2:	eb04 41b1 	add.w	r1, r4, r1, ror #18
	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
300161a6:	ea84 0301 	eor.w	r3, r4, r1
300161aa:	443a      	add	r2, r7
300161ac:	402b      	ands	r3, r5
300161ae:	f24a 37f8 	movw	r7, #41976	; 0xa3f8
300161b2:	4416      	add	r6, r2
300161b4:	ea83 0204 	eor.w	r2, r3, r4
300161b8:	f64e 1305 	movw	r3, #59653	; 0xe905
300161bc:	4432      	add	r2, r6
300161be:	f6ca 13e3 	movt	r3, #43491	; 0xa9e3
300161c2:	eb01 3232 	add.w	r2, r1, r2, ror #12
	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
300161c6:	ea81 0602 	eor.w	r6, r1, r2
300161ca:	4473      	add	r3, r14
300161cc:	4026      	ands	r6, r4
300161ce:	404e      	eors	r6, r1
300161d0:	441d      	add	r5, r3
300161d2:	1973      	adds	r3, r6, r5
300161d4:	9e02      	ldr	r6, [sp, #8]
300161d6:	f6cf 47ef 	movt	r7, #64751	; 0xfcef
300161da:	eb02 63f3 	add.w	r3, r2, r3, ror #27
	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
300161de:	ea82 0503 	eor.w	r5, r2, r3
300161e2:	4437      	add	r7, r6
300161e4:	400d      	ands	r5, r1
300161e6:	4055      	eors	r5, r2
300161e8:	f644 468a 	movw	r6, #19594	; 0x4c8a
300161ec:	443c      	add	r4, r7
300161ee:	f240 27d9 	movw	r7, #729	; 0x2d9
300161f2:	442c      	add	r4, r5
300161f4:	f2c6 776f 	movt	r7, #26479	; 0x676f
300161f8:	eb03 54f4 	add.w	r4, r3, r4, ror #23
	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
300161fc:	ea83 0504 	eor.w	r5, r3, r4
30016200:	4407      	add	r7, r0
30016202:	4015      	ands	r5, r2
30016204:	405d      	eors	r5, r3
30016206:	4439      	add	r1, r7
30016208:	4429      	add	r1, r5
3001620a:	980a      	ldr	r0, [sp, #40]	; 0x28
3001620c:	f6c8 562a 	movt	r6, #36138	; 0x8d2a
30016210:	eb04 41b1 	add.w	r1, r4, r1, ror #18
	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
30016214:	ea84 0701 	eor.w	r7, r4, r1
30016218:	444e      	add	r6, r9
3001621a:	ea07 0503 	and.w	r5, r7, r3
3001621e:	4432      	add	r2, r6
30016220:	f24f 6681 	movw	r6, #63105	; 0xf681
30016224:	4065      	eors	r5, r4
30016226:	4415      	add	r5, r2
30016228:	f5a0 22b8 	sub.w	r2, r0, #376832	; 0x5c000
3001622c:	eb01 3535 	add.w	r5, r1, r5, ror #12
30016230:	f2a2 62be 	subw	r2, r2, #1726	; 0x6be

	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
30016234:	406f      	eors	r7, r5
30016236:	4413      	add	r3, r2
30016238:	9a06      	ldr	r2, [sp, #24]
3001623a:	443b      	add	r3, r7
3001623c:	f2c8 7671 	movt	r6, #34673	; 0x8771
30016240:	eb05 7333 	add.w	r3, r5, r3, ror #28
	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
30016244:	ea81 0705 	eor.w	r7, r1, r5
30016248:	4416      	add	r6, r2
3001624a:	405f      	eors	r7, r3
3001624c:	f246 1222 	movw	r2, #24866	; 0x6122
30016250:	4434      	add	r4, r6
30016252:	443c      	add	r4, r7
30016254:	9f08      	ldr	r7, [sp, #32]
30016256:	f6c6 529d 	movt	r2, #28061	; 0x6d9d
3001625a:	eb03 5474 	add.w	r4, r3, r4, ror #21
	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
3001625e:	ea85 0603 	eor.w	r6, r5, r3
30016262:	443a      	add	r2, r7
30016264:	4066      	eors	r6, r4
30016266:	4411      	add	r1, r2
30016268:	4431      	add	r1, r6
3001626a:	f643 060c 	movw	r6, #14348	; 0x380c
	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
3001626e:	ea83 0704 	eor.w	r7, r3, r4
30016272:	f6cf 56e5 	movt	r6, #64997	; 0xfde5
	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
30016276:	eb04 4131 	add.w	r1, r4, r1, ror #16
3001627a:	4456      	add	r6, r10
3001627c:	4435      	add	r5, r6
	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
3001627e:	ea87 0601 	eor.w	r6, r7, r1
30016282:	f64e 2744 	movw	r7, #59972	; 0xea44
30016286:	442e      	add	r6, r5
30016288:	9d01      	ldr	r5, [sp, #4]
3001628a:	f2ca 47be 	movt	r7, #42174	; 0xa4be
3001628e:	eb01 2676 	add.w	r6, r1, r6, ror #9
	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
30016292:	ea84 0201 	eor.w	r2, r4, r1
30016296:	442f      	add	r7, r5
30016298:	4072      	eors	r2, r6
3001629a:	9d04      	ldr	r5, [sp, #16]
3001629c:	443b      	add	r3, r7
3001629e:	f64c 77a9 	movw	r7, #53161	; 0xcfa9
300162a2:	4413      	add	r3, r2
300162a4:	f6c4 37de 	movt	r7, #19422	; 0x4bde
300162a8:	eb06 7333 	add.w	r3, r6, r3, ror #28
	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
300162ac:	ea81 0206 	eor.w	r2, r1, r6
300162b0:	442f      	add	r7, r5
300162b2:	443c      	add	r4, r7
300162b4:	ea82 0703 	eor.w	r7, r2, r3
300162b8:	f644 3260 	movw	r2, #19296	; 0x4b60
300162bc:	4427      	add	r7, r4
300162be:	9c05      	ldr	r4, [sp, #20]
300162c0:	f2cf 62bb 	movt	r2, #63163	; 0xf6bb
300162c4:	eb03 5777 	add.w	r7, r3, r7, ror #21
	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
300162c8:	ea86 0503 	eor.w	r5, r6, r3
300162cc:	4422      	add	r2, r4
300162ce:	f64b 4470 	movw	r4, #48240	; 0xbc70
300162d2:	4411      	add	r1, r2
300162d4:	ea85 0207 	eor.w	r2, r5, r7
300162d8:	440a      	add	r2, r1
300162da:	f6cb 64bf 	movt	r4, #48831	; 0xbebf
300162de:	eb07 4232 	add.w	r2, r7, r2, ror #16
	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
300162e2:	ea83 0507 	eor.w	r5, r3, r7
300162e6:	f647 61c6 	movw	r1, #32454	; 0x7ec6
300162ea:	4464      	add	r4, r12
300162ec:	4426      	add	r6, r4
300162ee:	ea85 0402 	eor.w	r4, r5, r2
300162f2:	4434      	add	r4, r6
300162f4:	f6c2 019b 	movt	r1, #10395	; 0x289b
300162f8:	eb02 2474 	add.w	r4, r2, r4, ror #9
	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
300162fc:	ea87 0502 	eor.w	r5, r7, r2
30016300:	4471      	add	r1, r14
30016302:	440b      	add	r3, r1
30016304:	9900      	ldr	r1, [sp, #0]
30016306:	ea85 0604 	eor.w	r6, r5, r4
3001630a:	f242 75fa 	movw	r5, #10234	; 0x27fa
3001630e:	441e      	add	r6, r3
30016310:	f6ce 25a1 	movt	r5, #60065	; 0xeaa1
30016314:	eb04 7636 	add.w	r6, r4, r6, ror #28
	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
30016318:	ea82 0304 	eor.w	r3, r2, r4
3001631c:	440d      	add	r5, r1
3001631e:	442f      	add	r7, r5
30016320:	ea83 0506 	eor.w	r5, r3, r6
30016324:	f243 0385 	movw	r3, #12421	; 0x3085
30016328:	443d      	add	r5, r7
3001632a:	9f03      	ldr	r7, [sp, #12]
3001632c:	f2cd 43ef 	movt	r3, #54511	; 0xd4ef
30016330:	eb06 5575 	add.w	r5, r6, r5, ror #21
	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
30016334:	ea84 0106 	eor.w	r1, r4, r6
30016338:	443b      	add	r3, r7
3001633a:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
3001633c:	4413      	add	r3, r2
3001633e:	ea81 0205 	eor.w	r2, r1, r5
30016342:	441a      	add	r2, r3
30016344:	f641 5305 	movw	r3, #7429	; 0x1d05
	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
30016348:	ea86 0105 	eor.w	r1, r6, r5
3001634c:	f2c0 4388 	movt	r3, #1160	; 0x488
	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
30016350:	eb05 4232 	add.w	r2, r5, r2, ror #16
30016354:	443b      	add	r3, r7
	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
30016356:	4051      	eors	r1, r2
30016358:	441c      	add	r4, r3
3001635a:	9b07      	ldr	r3, [sp, #28]
3001635c:	440c      	add	r4, r1
3001635e:	f24d 0139 	movw	r1, #53305	; 0xd039
	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
30016362:	ea85 0702 	eor.w	r7, r5, r2
30016366:	f6cd 11d4 	movt	r1, #55764	; 0xd9d4
	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
3001636a:	eb02 2474 	add.w	r4, r2, r4, ror #9
3001636e:	4419      	add	r1, r3
30016370:	f649 13e5 	movw	r3, #39397	; 0x99e5
30016374:	440e      	add	r6, r1
	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
30016376:	ea87 0104 	eor.w	r1, r7, r4
3001637a:	4431      	add	r1, r6
3001637c:	f2ce 63db 	movt	r3, #59099	; 0xe6db
30016380:	eb04 7131 	add.w	r1, r4, r1, ror #28
	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
30016384:	ea82 0704 	eor.w	r7, r2, r4
30016388:	444b      	add	r3, r9
3001638a:	442b      	add	r3, r5
3001638c:	ea87 0501 	eor.w	r5, r7, r1
30016390:	441d      	add	r5, r3
30016392:	f647 43f8 	movw	r3, #31992	; 0x7cf8
	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
30016396:	ea84 0601 	eor.w	r6, r4, r1
3001639a:	f6c1 73a2 	movt	r3, #8098	; 0x1fa2
	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
3001639e:	eb01 5575 	add.w	r5, r1, r5, ror #21
300163a2:	4443      	add	r3, r8
	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
300163a4:	406e      	eors	r6, r5
300163a6:	9f02      	ldr	r7, [sp, #8]
300163a8:	441a      	add	r2, r3
300163aa:	f245 6365 	movw	r3, #22117	; 0x5665
300163ae:	4432      	add	r2, r6
300163b0:	f2cc 43ac 	movt	r3, #50348	; 0xc4ac
300163b4:	eb05 4232 	add.w	r2, r5, r2, ror #16
	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
300163b8:	ea81 0605 	eor.w	r6, r1, r5
300163bc:	443b      	add	r3, r7
300163be:	f242 2744 	movw	r7, #8772	; 0x2244
300163c2:	441c      	add	r4, r3
300163c4:	ea86 0302 	eor.w	r3, r6, r2
300163c8:	4423      	add	r3, r4
300163ca:	9c00      	ldr	r4, [sp, #0]
300163cc:	f2cf 4729 	movt	r7, #62505	; 0xf429
300163d0:	f64f 7697 	movw	r6, #65431	; 0xff97
300163d4:	eb02 2373 	add.w	r3, r2, r3, ror #9
300163d8:	4427      	add	r7, r4

	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
300163da:	ea63 0405 	orn	r4, r3, r5
300163de:	4054      	eors	r4, r2
300163e0:	4439      	add	r1, r7
300163e2:	4421      	add	r1, r4
300163e4:	9c05      	ldr	r4, [sp, #20]
300163e6:	f2c4 362a 	movt	r6, #17194	; 0x432a
300163ea:	f242 37a7 	movw	r7, #9127	; 0x23a7
300163ee:	eb03 61b1 	add.w	r1, r3, r1, ror #26
300163f2:	4426      	add	r6, r4
	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
300163f4:	ea61 0402 	orn	r4, r1, r2
300163f8:	405c      	eors	r4, r3
300163fa:	4435      	add	r5, r6
300163fc:	4425      	add	r5, r4
300163fe:	f24a 0439 	movw	r4, #41017	; 0xa039
30016402:	f6ca 3794 	movt	r7, #43924	; 0xab94
30016406:	eb01 55b5 	add.w	r5, r1, r5, ror #22
3001640a:	4457      	add	r7, r10
	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
3001640c:	ea65 0603 	orn	r6, r5, r3
30016410:	404e      	eors	r6, r1
30016412:	443a      	add	r2, r7
30016414:	4432      	add	r2, r6
30016416:	f645 17c3 	movw	r7, #22979	; 0x59c3
3001641a:	f6cf 4493 	movt	r4, #64659	; 0xfc93
3001641e:	eb05 4272 	add.w	r2, r5, r2, ror #17
	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
30016422:	ea62 0601 	orn	r6, r2, r1
30016426:	4404      	add	r4, r0
30016428:	441c      	add	r4, r3
3001642a:	ea86 0305 	eor.w	r3, r6, r5
3001642e:	4423      	add	r3, r4
30016430:	9803      	ldr	r0, [sp, #12]
30016432:	f2c6 575b 	movt	r7, #25947	; 0x655b
30016436:	eb02 23f3 	add.w	r3, r2, r3, ror #11
3001643a:	f64c 4692 	movw	r6, #52370	; 0xcc92
3001643e:	444f      	add	r7, r9
	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
30016440:	ea63 0905 	orn	r9, r3, r5
30016444:	ea89 0902 	eor.w	r9, r9, r2
30016448:	4439      	add	r1, r7
3001644a:	4449      	add	r1, r9
3001644c:	f6c8 760c 	movt	r6, #36620	; 0x8f0c
30016450:	eb03 61b1 	add.w	r1, r3, r1, ror #26
	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
30016454:	ea61 0402 	orn	r4, r1, r2
30016458:	4406      	add	r6, r0
3001645a:	4435      	add	r5, r6
3001645c:	405c      	eors	r4, r3
3001645e:	442c      	add	r4, r5
30016460:	9e01      	ldr	r6, [sp, #4]
30016462:	f5ac 1c80 	sub.w	r12, r12, #1048576	; 0x100000
30016466:	eb01 54b4 	add.w	r4, r1, r4, ror #22
	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
3001646a:	ea64 0503 	orn	r5, r4, r3
3001646e:	f647 694f 	movw	r9, #32335	; 0x7e4f
30016472:	f6ac 3c83 	subw	r12, r12, #2947	; 0xb83
30016476:	4494      	add	r12, r2
30016478:	ea85 0201 	eor.w	r2, r5, r1
3001647c:	f645 55d1 	movw	r5, #24017	; 0x5dd1
30016480:	4462      	add	r2, r12
30016482:	f2c8 5584 	movt	r5, #34180	; 0x8584
30016486:	eb04 4272 	add.w	r2, r4, r2, ror #17
3001648a:	4435      	add	r5, r6
	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
3001648c:	ea62 0601 	orn	r6, r2, r1
30016490:	4066      	eors	r6, r4
30016492:	442b      	add	r3, r5
30016494:	4433      	add	r3, r6
30016496:	9e06      	ldr	r6, [sp, #24]
30016498:	f6c6 79a8 	movt	r9, #28584	; 0x6fa8
3001649c:	f244 3714 	movw	r7, #17172	; 0x4314
300164a0:	eb02 23f3 	add.w	r3, r2, r3, ror #11
	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
300164a4:	ea63 0504 	orn	r5, r3, r4
300164a8:	44b1      	add	r9, r6
300164aa:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
300164ac:	4489      	add	r9, r1
300164ae:	ea85 0102 	eor.w	r1, r5, r2
300164b2:	f24e 65e0 	movw	r5, #59104	; 0xe6e0
300164b6:	4449      	add	r1, r9
300164b8:	f6cf 652c 	movt	r5, #65068	; 0xfe2c
300164bc:	eb03 61b1 	add.w	r1, r3, r1, ror #26
300164c0:	4445      	add	r5, r8
	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
300164c2:	ea61 0c02 	orn	r12, r1, r2
300164c6:	ea8c 0c03 	eor.w	r12, r12, r3
300164ca:	442c      	add	r4, r5
300164cc:	4464      	add	r4, r12
300164ce:	9804      	ldr	r0, [sp, #16]
300164d0:	f2ca 3701 	movt	r7, #41729	; 0xa301
300164d4:	eb01 54b4 	add.w	r4, r1, r4, ror #22
300164d8:	4437      	add	r7, r6
	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
300164da:	ea64 0503 	orn	r5, r4, r3
300164de:	404d      	eors	r5, r1
300164e0:	f241 16a1 	movw	r6, #4513	; 0x11a1
300164e4:	443a      	add	r2, r7
300164e6:	442a      	add	r2, r5
300164e8:	f647 6982 	movw	r9, #32386	; 0x7e82
300164ec:	f6c4 6608 	movt	r6, #19976	; 0x4e08
300164f0:	eb04 4272 	add.w	r2, r4, r2, ror #17
300164f4:	4476      	add	r6, r14
	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
300164f6:	ea62 0701 	orn	r7, r2, r1
300164fa:	4067      	eors	r7, r4
300164fc:	4433      	add	r3, r6
300164fe:	443b      	add	r3, r7
30016500:	9e08      	ldr	r6, [sp, #32]
30016502:	f2cf 7953 	movt	r9, #63315	; 0xf753
30016506:	eb02 23f3 	add.w	r3, r2, r3, ror #11
3001650a:	4481      	add	r9, r0
	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
3001650c:	ea63 0504 	orn	r5, r3, r4
30016510:	4055      	eors	r5, r2
30016512:	f24f 2c35 	movw	r12, #62005	; 0xf235
30016516:	4449      	add	r1, r9
30016518:	4429      	add	r1, r5
3001651a:	f24d 27bb 	movw	r7, #53947	; 0xd2bb
3001651e:	f6cb 5c3a 	movt	r12, #48442	; 0xbd3a
30016522:	eb03 61b1 	add.w	r1, r3, r1, ror #26
30016526:	9d02      	ldr	r5, [sp, #8]
30016528:	44b4      	add	r12, r6
	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
3001652a:	ea61 0602 	orn	r6, r1, r2
3001652e:	405e      	eors	r6, r3
30016530:	4464      	add	r4, r12
30016532:	4434      	add	r4, r6
	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

	buf[0] += a;
30016534:	9e09      	ldr	r6, [sp, #36]	; 0x24
30016536:	f6c2 27d7 	movt	r7, #10967	; 0x2ad7
	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
3001653a:	eb01 54b4 	add.w	r4, r1, r4, ror #22
3001653e:	9807      	ldr	r0, [sp, #28]
30016540:	442f      	add	r7, r5
	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
30016542:	ea64 0503 	orn	r5, r4, r3
30016546:	443a      	add	r2, r7
30016548:	ea85 0701 	eor.w	r7, r5, r1
	buf[0] += a;
3001654c:	6835      	ldr	r5, [r6, #0]
	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
3001654e:	443a      	add	r2, r7
30016550:	f24d 3791 	movw	r7, #54161	; 0xd391
30016554:	eb04 4272 	add.w	r2, r4, r2, ror #17
30016558:	f6ce 3786 	movt	r7, #60294	; 0xeb86
	buf[0] += a;
3001655c:	440d      	add	r5, r1
3001655e:	4407      	add	r7, r0
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
30016560:	68f0      	ldr	r0, [r6, #12]
	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
30016562:	ea62 0101 	orn	r1, r2, r1
30016566:	443b      	add	r3, r7
	buf[0] += a;
30016568:	6035      	str	r5, [r6, #0]
	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
3001656a:	4061      	eors	r1, r4
3001656c:	4419      	add	r1, r3
	buf[3] += d;
3001656e:	4404      	add	r4, r0
	buf[2] += c;
30016570:	68b0      	ldr	r0, [r6, #8]
	buf[1] += b;
30016572:	eb0b 0302 	add.w	r3, r11, r2
30016576:	eb03 23f1 	add.w	r3, r3, r1, ror #11
	buf[2] += c;
3001657a:	4402      	add	r2, r0
	buf[1] += b;
3001657c:	6073      	str	r3, [r6, #4]
	buf[2] += c;
3001657e:	e9c6 2402 	strd	r2, r4, [r6, #8]
}
30016582:	b00d      	add	sp, #52	; 0x34
30016584:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

30016588 <md5>:
 * Calculate and store in 'output' the MD5 digest of 'len' bytes at
 * 'input'. 'output' must have enough space to hold 16 bytes.
 */
void
md5 (const unsigned char *input, const int len, unsigned char output[16])
{
30016588:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
	ctx->buf[3] = 0x10325476;
3001658c:	f245 4376 	movw	r3, #21622	; 0x5476
	ctx->buf[0] = 0x67452301;
30016590:	f242 3601 	movw	r6, #8961	; 0x2301
	ctx->buf[1] = 0xefcdab89;
30016594:	f64a 3589 	movw	r5, #43913	; 0xab89
{
30016598:	4691      	mov	r9, r2
	ctx->buf[2] = 0x98badcfe;
3001659a:	f64d 42fe 	movw	r2, #56574	; 0xdcfe
{
3001659e:	b099      	sub	sp, #100	; 0x64
	while (len >= 64) {
300165a0:	293f      	cmp	r1, #63	; 0x3f
	ctx->buf[0] = 0x67452301;
300165a2:	f2c6 7645 	movt	r6, #26437	; 0x6745
	ctx->bits[1] += len >> 29;
300165a6:	ea4f 7751 	mov.w	r7, r1, lsr #29
	ctx->buf[2] = 0x98badcfe;
300165aa:	f6c9 02ba 	movt	r2, #39098	; 0x98ba
	if ((ctx->bits[0] = t + ((__u32) len << 3)) < t)
300165ae:	ea4f 04c1 	mov.w	r4, r1, lsl #3
	ctx->buf[1] = 0xefcdab89;
300165b2:	f6ce 75cd 	movt	r5, #61389	; 0xefcd
	ctx->bits[1] += len >> 29;
300165b6:	9707      	str	r7, [sp, #28]
	ctx->buf[3] = 0x10325476;
300165b8:	f2c1 0332 	movt	r3, #4146	; 0x1032
	ctx->buf[1] = 0xefcdab89;
300165bc:	e9cd 6502 	strd	r6, r5, [r13, #8]
{
300165c0:	4682      	mov	r10, r0
	ctx->buf[3] = 0x10325476;
300165c2:	e9cd 2304 	strd	r2, r3, [r13, #16]
300165c6:	bf98      	it	ls
300165c8:	af08      	addls	r7, sp, #32
	if ((ctx->bits[0] = t + ((__u32) len << 3)) < t)
300165ca:	9406      	str	r4, [sp, #24]
300165cc:	bf9c      	itt	ls
300165ce:	460a      	movls	r2, r1
300165d0:	ae02      	addls	r6, sp, #8
	while (len >= 64) {
300165d2:	d92f      	bls.n	30016634 <md5+0xac>
300165d4:	f1a1 0340 	sub.w	r3, r1, #64	; 0x40
300165d8:	f100 0880 	add.w	r8, r0, #128	; 0x80
300165dc:	ea4f 1b93 	mov.w	r11, r3, lsr #6
300165e0:	f100 0e40 	add.w	r14, r0, #64	; 0x40
300165e4:	eb08 188b 	add.w	r8, r8, r11, lsl #6
300165e8:	af08      	add	r7, sp, #32
300165ea:	9301      	str	r3, [sp, #4]
300165ec:	ae02      	add	r6, sp, #8
		memmove(ctx->in, buf, 64);
300165ee:	46bc      	mov	r12, r7
300165f0:	f1ae 0440 	sub.w	r4, r14, #64	; 0x40
300165f4:	6820      	ldr	r0, [r4, #0]
300165f6:	3410      	adds	r4, #16
300165f8:	f854 1c0c 	ldr.w	r1, [r4, #-12]
300165fc:	4665      	mov	r5, r12
300165fe:	f854 2c08 	ldr.w	r2, [r4, #-8]
30016602:	f10c 0c10 	add.w	r12, r12, #16
30016606:	f854 3c04 	ldr.w	r3, [r4, #-4]
3001660a:	4574      	cmp	r4, r14
3001660c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
3001660e:	d1f1      	bne.n	300165f4 <md5+0x6c>
		MD5Transform(ctx->buf, (__u32 *) ctx->in);
30016610:	4639      	mov	r1, r7
30016612:	4630      	mov	r0, r6
30016614:	f7ff fc14 	bl	30015e40 <MD5Transform>
30016618:	f104 0e40 	add.w	r14, r4, #64	; 0x40
	while (len >= 64) {
3001661c:	45c6      	cmp	r14, r8
3001661e:	d1e6      	bne.n	300165ee <md5+0x66>
30016620:	9c06      	ldr	r4, [sp, #24]
30016622:	f10b 0301 	add.w	r3, r11, #1
30016626:	ebcb 6b8b 	rsb	r11, r11, r11, lsl #26
3001662a:	eb0a 1a83 	add.w	r10, r10, r3, lsl #6
3001662e:	9b01      	ldr	r3, [sp, #4]
30016630:	eb03 128b 	add.w	r2, r3, r11, lsl #6
	memmove(ctx->in, buf, len);
30016634:	4651      	mov	r1, r10
	count = (ctx->bits[0] >> 3) & 0x3F;
30016636:	f3c4 04c5 	ubfx	r4, r4, #3, #6
	memmove(ctx->in, buf, len);
3001663a:	4638      	mov	r0, r7
3001663c:	f7fe e912 	blx	30014864 <memcpy>
	*p++ = 0x80;
30016640:	2180      	movs	r1, #128	; 0x80
	count = 64 - 1 - count;
30016642:	f1c4 023f 	rsb	r2, r4, #63	; 0x3f
	if (count < 8) {
30016646:	2a07      	cmp	r2, #7
	*p++ = 0x80;
30016648:	5539      	strb	r1, [r7, r4]
	p = ctx->in + count;
3001664a:	eb07 0004 	add.w	r0, r7, r4
	*p++ = 0x80;
3001664e:	f100 0001 	add.w	r0, r0, #1
	if (count < 8) {
30016652:	d81f      	bhi.n	30016694 <md5+0x10c>
		memset(p, 0, count);
30016654:	2100      	movs	r1, #0
30016656:	f7fe e98c 	blx	30014970 <memset>
		MD5Transform(ctx->buf, (__u32 *) ctx->in);
3001665a:	4639      	mov	r1, r7
3001665c:	4630      	mov	r0, r6
3001665e:	f7ff fbef 	bl	30015e40 <MD5Transform>
		memset(ctx->in, 0, 56);
30016662:	2238      	movs	r2, #56	; 0x38
30016664:	2100      	movs	r1, #0
30016666:	4638      	mov	r0, r7
30016668:	f7fe e982 	blx	30014970 <memset>
	ctx->in32[15] = ctx->bits[1];
3001666c:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
	MD5Transform(ctx->buf, (__u32 *) ctx->in);
30016670:	4639      	mov	r1, r7
	ctx->in32[15] = ctx->bits[1];
30016672:	e9cd 2316 	strd	r2, r3, [r13, #88]	; 0x58
	MD5Transform(ctx->buf, (__u32 *) ctx->in);
30016676:	4630      	mov	r0, r6
30016678:	f7ff fbe2 	bl	30015e40 <MD5Transform>
	memmove(digest, ctx->buf, 16);
3001667c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
3001667e:	f8c9 0000 	str.w	r0, [r9]
30016682:	f8c9 1004 	str.w	r1, [r9, #4]
30016686:	f8c9 2008 	str.w	r2, [r9, #8]
3001668a:	f8c9 300c 	str.w	r3, [r9, #12]
	struct MD5Context context;

	MD5Init(&context);
	MD5Update(&context, input, len);
	MD5Final(output, &context);
}
3001668e:	b019      	add	sp, #100	; 0x64
30016690:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
		memset(p, 0, count - 8);
30016694:	2100      	movs	r1, #0
30016696:	f1c4 0237 	rsb	r2, r4, #55	; 0x37
3001669a:	f7fe e96a 	blx	30014970 <memset>
3001669e:	e7e5      	b.n	3001666c <md5+0xe4>

300166a0 <write_gpt_partition_array>:
write_gpt_partition_array(partition_device_t *part_dev, uint8_t *header,
                          unsigned char *partition_array_start,
                          uint32_t array_size,
                          uint32_t block_size,
                          uint64_t parent_lba)
{
300166a0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    unsigned long long partition_entry_lba;
    unsigned long long partition_entry_array_start_location;
    storage_device_t *storage = part_dev->storage;

    partition_entry_lba =
        GET_LLWORD_FROM_BYTE(&header[PARTITION_ENTRIES_OFFSET]) + parent_lba;
300166a4:	f8d1 a048 	ldr.w	r10, [r1, #72]	; 0x48
{
300166a8:	b085      	sub	sp, #20
    partition_entry_array_start_location = partition_entry_lba * block_size;
300166aa:	2600      	movs	r6, #0

    ret = storage->write(storage, partition_entry_array_start_location +
300166ac:	9302      	str	r3, [sp, #8]
{
300166ae:	e9dd 8910 	ldrd	r8, r9, [r13, #64]	; 0x40
300166b2:	f8dd c038 	ldr.w	r12, [r13, #56]	; 0x38
        GET_LLWORD_FROM_BYTE(&header[PARTITION_ENTRIES_OFFSET]) + parent_lba;
300166b6:	f8d1 b04c 	ldr.w	r11, [r1, #76]	; 0x4c
    partition_entry_lba =
300166ba:	eb1a 0408 	adds.w	r4, r10, r8
    ret = storage->write(storage, partition_entry_array_start_location +
300166be:	9200      	str	r2, [sp, #0]
300166c0:	9603      	str	r6, [sp, #12]
    partition_entry_lba =
300166c2:	eb4b 0509 	adc.w	r5, r11, r9
    partition_entry_array_start_location = partition_entry_lba * block_size;
300166c6:	fba4 890c 	umull	r8, r9, r4, r12
    ret = storage->write(storage, partition_entry_array_start_location +
300166ca:	e9d0 6702 	ldrd	r6, r7, [r0, #8]
    storage_device_t *storage = part_dev->storage;
300166ce:	6801      	ldr	r1, [r0, #0]
    partition_entry_array_start_location = partition_entry_lba * block_size;
300166d0:	fb0c 9905 	mla	r9, r12, r5, r9
    ret = storage->write(storage, partition_entry_array_start_location +
300166d4:	68cc      	ldr	r4, [r1, #12]
300166d6:	eb18 0206 	adds.w	r2, r8, r6
300166da:	4608      	mov	r0, r1
300166dc:	eb49 0307 	adc.w	r3, r9, r7
300166e0:	47a0      	blx	r4
                         part_dev->gpt_offset,
                         (uint8_t *)partition_array_start, array_size);

    if (ret) {
300166e2:	4604      	mov	r4, r0
300166e4:	b128      	cbz	r0, 300166f2 <write_gpt_partition_array+0x52>
        dprintf(CRITICAL,
300166e6:	f641 40f8 	movw	r0, #7416	; 0x1cf8
300166ea:	f2c3 0002 	movt	r0, #12290	; 0x3002
300166ee:	f7ff fa5f 	bl	30015bb0 <_printf>
        goto end;
    }

end:
    return ret;
}
300166f2:	4620      	mov	r0, r4
300166f4:	b005      	add	sp, #20
300166f6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
300166fa:	bf00      	nop

300166fc <mbr_fill_name>:
/*
 * Fill name for android partition found.
 */
static void
mbr_fill_name(struct partition_entry *partition_ent, unsigned int type)
{
300166fc:	b538      	push	{r3, r4, r5, r14}
    memset(partition_ent->name, 0, MAX_GPT_NAME_SIZE);
300166fe:	2248      	movs	r2, #72	; 0x48
30016700:	f100 0338 	add.w	r3, r0, #56	; 0x38
{
30016704:	460c      	mov	r4, r1
30016706:	4605      	mov	r5, r0
    memset(partition_ent->name, 0, MAX_GPT_NAME_SIZE);
30016708:	2100      	movs	r1, #0
3001670a:	4618      	mov	r0, r3
3001670c:	f7fe e930 	blx	30014970 <memset>

    switch (type) {
30016710:	f1a4 0146 	sub.w	r1, r4, #70	; 0x46
    memset(partition_ent->name, 0, MAX_GPT_NAME_SIZE);
30016714:	4603      	mov	r3, r0
    switch (type) {
30016716:	291d      	cmp	r1, #29
30016718:	d816      	bhi.n	30016748 <mbr_fill_name+0x4c>
3001671a:	e8df f001 	tbb	[r15, r1]
3001671e:	281f      	.short	0x281f
30016720:	1515152f 	.word	0x1515152f
30016724:	15151515 	.word	0x15151515
30016728:	15151515 	.word	0x15151515
3001672c:	15151515 	.word	0x15151515
30016730:	15151515 	.word	0x15151515
30016734:	15150f15 	.word	0x15150f15
30016738:	16151538 	.word	0x16151538
        case MBR_MISC_TYPE:
            strcpy((char *)partition_ent->name, "msic");
            break;

        case MBR_SSD_TYPE:
            strcpy((char *)partition_ent->name, "ssd");
3001673c:	f241 2340 	movw	r3, #4672	; 0x1240
30016740:	f2c3 0302 	movt	r3, #12290	; 0x3002
30016744:	6818      	ldr	r0, [r3, #0]
30016746:	63a8      	str	r0, [r5, #56]	; 0x38
            break;
    };
}
30016748:	bd38      	pop	{r3, r4, r5, r15}
            strcpy((char *)partition_ent->name, "msic");
3001674a:	f241 2238 	movw	r2, #4664	; 0x1238
3001674e:	f2c3 0202 	movt	r2, #12290	; 0x3002
30016752:	7911      	ldrb	r1, [r2, #4]
30016754:	6810      	ldr	r0, [r2, #0]
30016756:	63a8      	str	r0, [r5, #56]	; 0x38
30016758:	7119      	strb	r1, [r3, #4]
}
3001675a:	bd38      	pop	{r3, r4, r5, r15}
            strcpy((char *)partition_ent->name, "tz");
3001675c:	f241 2228 	movw	r2, #4648	; 0x1228
30016760:	f2c3 0202 	movt	r2, #12290	; 0x3002
30016764:	8811      	ldrh	r1, [r2, #0]
30016766:	7892      	ldrb	r2, [r2, #2]
30016768:	8729      	strh	r1, [r5, #56]	; 0x38
3001676a:	7082      	strb	r2, [r0, #2]
}
3001676c:	bd38      	pop	{r3, r4, r5, r15}
            strcpy((char *)partition_ent->name, "rpm");
3001676e:	f241 2324 	movw	r3, #4644	; 0x1224
30016772:	f2c3 0302 	movt	r3, #12290	; 0x3002
30016776:	6818      	ldr	r0, [r3, #0]
30016778:	63a8      	str	r0, [r5, #56]	; 0x38
}
3001677a:	bd38      	pop	{r3, r4, r5, r15}
            strcpy((char *)partition_ent->name, "boot");
3001677c:	f241 1268 	movw	r2, #4456	; 0x1168
30016780:	f2c3 0202 	movt	r2, #12290	; 0x3002
30016784:	7911      	ldrb	r1, [r2, #4]
30016786:	6810      	ldr	r0, [r2, #0]
30016788:	63a8      	str	r0, [r5, #56]	; 0x38
3001678a:	7119      	strb	r1, [r3, #4]
}
3001678c:	bd38      	pop	{r3, r4, r5, r15}
            strcpy((char *)partition_ent->name, "recovery");
3001678e:	f241 222c 	movw	r2, #4652	; 0x122c
30016792:	f2c3 0202 	movt	r2, #12290	; 0x3002
30016796:	ca03      	ldmia	r2!, {r0, r1}
30016798:	7812      	ldrb	r2, [r2, #0]
3001679a:	63a8      	str	r0, [r5, #56]	; 0x38
3001679c:	721a      	strb	r2, [r3, #8]
3001679e:	6059      	str	r1, [r3, #4]
}
300167a0:	bd38      	pop	{r3, r4, r5, r15}
300167a2:	bf00      	nop

300167a4 <ptdev_verify_mbr_signature.part.0>:
                a, b, s, retry, priority, partition_entries[i].name);
    }
}

static unsigned int
ptdev_verify_mbr_signature(unsigned size, unsigned char *buffer)
300167a4:	b508      	push	{r3, r14}
    if ((TABLE_SIGNATURE + 1) > size) {
        return 1;
    }

    /* Check to see if signature exists */
    if ((buffer[TABLE_SIGNATURE] != MMC_MBR_SIGNATURE_BYTE_0) ||
300167a6:	f890 31fe 	ldrb.w	r3, [r0, #510]	; 0x1fe
300167aa:	2b55      	cmp	r3, #85	; 0x55
300167ac:	d105      	bne.n	300167ba <ptdev_verify_mbr_signature.part.0+0x16>
300167ae:	f890 31ff 	ldrb.w	r3, [r0, #511]	; 0x1ff
300167b2:	2baa      	cmp	r3, #170	; 0xaa
            (buffer[TABLE_SIGNATURE + 1] != MMC_MBR_SIGNATURE_BYTE_1)) {
        dprintf(CRITICAL, "MBR signature does not match.\n");
        return 1;
    }

    return 0;
300167b4:	bf08      	it	eq
300167b6:	2000      	moveq	r0, #0
    if ((buffer[TABLE_SIGNATURE] != MMC_MBR_SIGNATURE_BYTE_0) ||
300167b8:	d006      	beq.n	300167c8 <ptdev_verify_mbr_signature.part.0+0x24>
        dprintf(CRITICAL, "MBR signature does not match.\n");
300167ba:	f241 7058 	movw	r0, #5976	; 0x1758
300167be:	f2c3 0002 	movt	r0, #12290	; 0x3002
300167c2:	f7ff f9f5 	bl	30015bb0 <_printf>
        return 1;
300167c6:	2001      	movs	r0, #1
}
300167c8:	bd08      	pop	{r3, r15}
300167ca:	bf00      	nop

300167cc <ptdev_parse_gpt_header.isra.2>:
/*
 * Parse the gpt header and get the required header fields
 * Return 0 on valid signature
 */
static unsigned int
ptdev_parse_gpt_header(partition_device_t *part_dev, unsigned char *buffer,
300167cc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300167d0:	469a      	mov	r10, r3
300167d2:	b085      	sub	sp, #20
    uint32_t crc_val_org = 0;
    unsigned long long last_usable_lba = 0;
    unsigned long long partition_0 = 0;
    unsigned long long current_lba = 0;
    storage_device_t *storage = part_dev->storage;
    uint32_t block_size = storage->get_block_size(storage);
300167d4:	6a03      	ldr	r3, [r0, #32]
ptdev_parse_gpt_header(partition_device_t *part_dev, unsigned char *buffer,
300167d6:	4606      	mov	r6, r0
300167d8:	468b      	mov	r11, r1
300167da:	4614      	mov	r4, r2
300167dc:	9f11      	ldr	r7, [sp, #68]	; 0x44
300167de:	f89d 9048 	ldrb.w	r9, [r13, #72]	; 0x48
300167e2:	f89d 5054 	ldrb.w	r5, [r13, #84]	; 0x54
    uint32_t block_size = storage->get_block_size(storage);
300167e6:	4798      	blx	r3
300167e8:	4680      	mov	r8, r0
        (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) / block_size;
    /* Get the density of the mmc device */
    uint64_t device_capacity;
    uint8_t *entry_buffer_p = NULL;

    if (!parent_entry) {
300167ea:	2f00      	cmp	r7, #0
300167ec:	f040 809d 	bne.w	3001692a <ptdev_parse_gpt_header.isra.2+0x15e>
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
300167f0:	69b3      	ldr	r3, [r6, #24]
300167f2:	4630      	mov	r0, r6
300167f4:	4798      	blx	r3
300167f6:	e9db 2300 	ldrd	r2, r3, [r11]
300167fa:	1a82      	subs	r2, r0, r2
300167fc:	4616      	mov	r6, r2
300167fe:	eb61 0303 	sbc.w	r3, r1, r3
30016802:	461f      	mov	r7, r3
        device_capacity = (parent_entry->last_lba -
                           parent_entry->first_lba + 1) * block_size;
    }

    /* Check GPT Signature */
    if (((uint32_t *) buffer)[0] != GPT_SIGNATURE_2 ||
30016804:	6822      	ldr	r2, [r4, #0]
30016806:	f244 6345 	movw	r3, #17989	; 0x4645
3001680a:	f2c2 0349 	movt	r3, #8265	; 0x2049
3001680e:	429a      	cmp	r2, r3
30016810:	d106      	bne.n	30016820 <ptdev_parse_gpt_header.isra.2+0x54>
30016812:	6862      	ldr	r2, [r4, #4]
30016814:	f244 1350 	movw	r3, #16720	; 0x4150
30016818:	f2c5 4352 	movt	r3, #21586	; 0x5452
3001681c:	429a      	cmp	r2, r3
3001681e:	d009      	beq.n	30016834 <ptdev_parse_gpt_header.isra.2+0x68>
            ((uint32_t *) buffer)[1] != GPT_SIGNATURE_1) {
        dprintf(CRITICAL, "GPT: (WARNING) signature invalid\n");
30016820:	f241 209c 	movw	r0, #4764	; 0x129c
30016824:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016828:	f7ff f9c2 	bl	30015bb0 <_printf>
        return 1;
3001682c:	2001      	movs	r0, #1
        free(entry_buffer_p);
        entry_buffer_p = NULL;
    }

    return ret;
}
3001682e:	b005      	add	sp, #20
30016830:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    *header_size = GET_LWORD_FROM_BYTE(&buffer[HEADER_SIZE_OFFSET]);
30016834:	68e3      	ldr	r3, [r4, #12]
30016836:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
30016838:	6013      	str	r3, [r2, #0]
    if (*header_size < GPT_HEADER_SIZE) {
3001683a:	2b5b      	cmp	r3, #91	; 0x5b
3001683c:	f240 8084 	bls.w	30016948 <ptdev_parse_gpt_header.isra.2+0x17c>
    if (*header_size > block_size) {
30016840:	4598      	cmp	r8, r3
30016842:	f0c0 8089 	bcc.w	30016958 <ptdev_parse_gpt_header.isra.2+0x18c>
    crc_val_org = GET_LWORD_FROM_BYTE(&buffer[HEADER_CRC_OFFSET]);
30016846:	6923      	ldr	r3, [r4, #16]
    PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016848:	f04f 0b00 	mov.w	r11, #0
    crc_val_org = GET_LWORD_FROM_BYTE(&buffer[HEADER_CRC_OFFSET]);
3001684c:	9300      	str	r3, [sp, #0]
    crc_val  = crc32(0, buffer, *header_size);
3001684e:	4621      	mov	r1, r4
30016850:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
30016852:	4658      	mov	r0, r11
    PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016854:	f884 b010 	strb.w	r11, [r4, #16]
30016858:	f884 b011 	strb.w	r11, [r4, #17]
3001685c:	f884 b012 	strb.w	r11, [r4, #18]
30016860:	f884 b013 	strb.w	r11, [r4, #19]
    crc_val  = crc32(0, buffer, *header_size);
30016864:	681a      	ldr	r2, [r3, #0]
30016866:	f7fc fb77 	bl	30012f58 <crc32>
    if (crc_val != crc_val_org) {
3001686a:	9b00      	ldr	r3, [sp, #0]
    crc_val  = crc32(0, buffer, *header_size);
3001686c:	4601      	mov	r1, r0
    if (crc_val != crc_val_org) {
3001686e:	4283      	cmp	r3, r0
30016870:	d17a      	bne.n	30016968 <ptdev_parse_gpt_header.isra.2+0x19c>
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30016872:	6aa2      	ldr	r2, [r4, #40]	; 0x28
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016874:	0a19      	lsrs	r1, r3, #8
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30016876:	9200      	str	r2, [sp, #0]
    current_lba =
30016878:	69a2      	ldr	r2, [r4, #24]
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
3001687a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
3001687c:	7423      	strb	r3, [r4, #16]
    current_lba =
3001687e:	9202      	str	r2, [sp, #8]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016880:	0c1a      	lsrs	r2, r3, #16
        GET_LLWORD_FROM_BYTE(&buffer[FIRST_USABLE_LBA_OFFSET]);
30016882:	9001      	str	r0, [sp, #4]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016884:	0e1b      	lsrs	r3, r3, #24
30016886:	74a2      	strb	r2, [r4, #18]
30016888:	74e3      	strb	r3, [r4, #19]
    *first_usable_lba =
3001688a:	e9dd 2300 	ldrd	r2, r3, [r13]
    current_lba =
3001688e:	69e0      	ldr	r0, [r4, #28]
        PUT_LONG(&buffer[HEADER_CRC_OFFSET], crc_val);
30016890:	7461      	strb	r1, [r4, #17]
    *first_usable_lba =
30016892:	e9ca 2300 	strd	r2, r3, [r10]
    *max_partition_count =
30016896:	9a10      	ldr	r2, [sp, #64]	; 0x40
        GET_LWORD_FROM_BYTE(&buffer[PARTITION_COUNT_OFFSET]);
30016898:	6d23      	ldr	r3, [r4, #80]	; 0x50
    *max_partition_count =
3001689a:	6013      	str	r3, [r2, #0]
    *partition_entry_size =
3001689c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
        GET_LWORD_FROM_BYTE(&buffer[PENTRY_SIZE_OFFSET]);
3001689e:	f8d4 a054 	ldr.w	r10, [r4, #84]	; 0x54
    current_lba =
300168a2:	9003      	str	r0, [sp, #12]
    *partition_entry_size =
300168a4:	f8c3 a000 	str.w	r10, [r3]
    if (!secondary_gpt) {
300168a8:	f1b9 0f00 	cmp.w	r9, #0
300168ac:	d165      	bne.n	3001697a <ptdev_parse_gpt_header.isra.2+0x1ae>
        if (current_lba != GPT_LBA) {
300168ae:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
300168b2:	2b00      	cmp	r3, #0
300168b4:	bf08      	it	eq
300168b6:	2a01      	cmpeq	r2, #1
300168b8:	d17b      	bne.n	300169b2 <ptdev_parse_gpt_header.isra.2+0x1e6>
300168ba:	4630      	mov	r0, r6
300168bc:	4639      	mov	r1, r7
300168be:	4642      	mov	r2, r8
300168c0:	464b      	mov	r3, r9
300168c2:	f003 faad 	bl	30019e20 <__aeabi_uldivmod>
300168c6:	46cb      	mov	r11, r9
300168c8:	4606      	mov	r6, r0
300168ca:	460f      	mov	r7, r1
    if (*first_usable_lba > (device_capacity / block_size)) {
300168cc:	e9dd 2300 	ldrd	r2, r3, [r13]
300168d0:	429f      	cmp	r7, r3
300168d2:	bf08      	it	eq
300168d4:	4296      	cmpeq	r6, r2
300168d6:	d374      	bcc.n	300169c2 <ptdev_parse_gpt_header.isra.2+0x1f6>
    last_usable_lba =
300168d8:	6b61      	ldr	r1, [r4, #52]	; 0x34
300168da:	6b20      	ldr	r0, [r4, #48]	; 0x30
    if (last_usable_lba > (device_capacity / block_size)) {
300168dc:	428f      	cmp	r7, r1
300168de:	bf08      	it	eq
300168e0:	4286      	cmpeq	r6, r0
300168e2:	d37e      	bcc.n	300169e2 <ptdev_parse_gpt_header.isra.2+0x216>
    if (*partition_entry_size != PARTITION_ENTRY_SIZE) {
300168e4:	f1ba 0f80 	cmp.w	r10, #128	; 0x80
300168e8:	d173      	bne.n	300169d2 <ptdev_parse_gpt_header.isra.2+0x206>
    if ((*max_partition_count) > (MIN_PARTITION_ARRAY_SIZE /
300168ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
300168ec:	6819      	ldr	r1, [r3, #0]
300168ee:	2980      	cmp	r1, #128	; 0x80
300168f0:	d87f      	bhi.n	300169f2 <ptdev_parse_gpt_header.isra.2+0x226>
    return ret;
300168f2:	4628      	mov	r0, r5
    if (check_lba) {
300168f4:	2d00      	cmp	r5, #0
300168f6:	d09a      	beq.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        partition_0 = GET_LLWORD_FROM_BYTE(&buffer[PARTITION_ENTRIES_OFFSET]);
300168f8:	6ca0      	ldr	r0, [r4, #72]	; 0x48
300168fa:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
        if (!secondary_gpt) {
300168fc:	f1b9 0f00 	cmp.w	r9, #0
30016900:	d17f      	bne.n	30016a02 <ptdev_parse_gpt_header.isra.2+0x236>
            if (partition_0 != 0x2) {
30016902:	2900      	cmp	r1, #0
30016904:	bf08      	it	eq
30016906:	2802      	cmpeq	r0, #2
30016908:	f040 8090 	bne.w	30016a2c <ptdev_parse_gpt_header.isra.2+0x260>
        *partition_entries_offset = partition_0  * block_size;
3001690c:	fb00 fb0b 	mul.w	r11, r0, r11
30016910:	fba0 2308 	umull	r2, r3, r0, r8
30016914:	fb08 b801 	mla	r8, r8, r1, r11
30016918:	9913      	ldr	r1, [sp, #76]	; 0x4c
    return ret;
3001691a:	2000      	movs	r0, #0
        *partition_entries_offset = partition_0  * block_size;
3001691c:	4443      	add	r3, r8
3001691e:	e9c1 2300 	strd	r2, r3, [r1]
        *crc_entries_array = crc_val_org;
30016922:	9a14      	ldr	r2, [sp, #80]	; 0x50
        crc_val_org = GET_LWORD_FROM_BYTE(&buffer[PARTITION_CRC_OFFSET]);
30016924:	6da3      	ldr	r3, [r4, #88]	; 0x58
        *crc_entries_array = crc_val_org;
30016926:	6013      	str	r3, [r2, #0]
30016928:	e781      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
                           parent_entry->first_lba + 1) * block_size;
3001692a:	e9d7 230a 	ldrd	r2, r3, [r7, #40]	; 0x28
3001692e:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
30016932:	1c56      	adds	r6, r2, #1
30016934:	f143 0700 	adc.w	r7, r3, #0
30016938:	1a32      	subs	r2, r6, r0
3001693a:	eb67 0301 	sbc.w	r3, r7, r1
        device_capacity = (parent_entry->last_lba -
3001693e:	fba2 6708 	umull	r6, r7, r2, r8
30016942:	fb08 7703 	mla	r7, r8, r3, r7
30016946:	e75d      	b.n	30016804 <ptdev_parse_gpt_header.isra.2+0x38>
        dprintf(CRITICAL, "GPT Header size is too small\n");
30016948:	f24c 5064 	movw	r0, #50532	; 0xc564
3001694c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30016950:	f7ff f92e 	bl	30015bb0 <_printf>
        return 1;
30016954:	2001      	movs	r0, #1
30016956:	e76a      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL, "GPT Header size is too large\n");
30016958:	f24c 5084 	movw	r0, #50564	; 0xc584
3001695c:	f2c3 0001 	movt	r0, #12289	; 0x3001
30016960:	f7ff f926 	bl	30015bb0 <_printf>
        return 1;
30016964:	2001      	movs	r0, #1
30016966:	e762      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL,
30016968:	f241 20c0 	movw	r0, #4800	; 0x12c0
3001696c:	461a      	mov	r2, r3
3001696e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016972:	f7ff f91d 	bl	30015bb0 <_printf>
        return 1;
30016976:	2001      	movs	r0, #1
30016978:	e759      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
3001697a:	4630      	mov	r0, r6
3001697c:	4639      	mov	r1, r7
3001697e:	4642      	mov	r2, r8
30016980:	465b      	mov	r3, r11
30016982:	f003 fa4d 	bl	30019e20 <__aeabi_uldivmod>
30016986:	4606      	mov	r6, r0
30016988:	460f      	mov	r7, r1
        if (check_lba && (current_lba != ((device_capacity / block_size) - 1))) {
3001698a:	2d00      	cmp	r5, #0
3001698c:	d09e      	beq.n	300168cc <ptdev_parse_gpt_header.isra.2+0x100>
3001698e:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30016992:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
30016996:	f141 31ff 	adc.w	r1, r1, #4294967295	; 0xffffffff
3001699a:	428b      	cmp	r3, r1
3001699c:	bf08      	it	eq
3001699e:	4282      	cmpeq	r2, r0
300169a0:	d094      	beq.n	300168cc <ptdev_parse_gpt_header.isra.2+0x100>
            dprintf(CRITICAL, "Secondary GPT first usable LBA mismatch\n");
300169a2:	f241 3000 	movw	r0, #4864	; 0x1300
300169a6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300169aa:	f7ff f901 	bl	30015bb0 <_printf>
            return 1;
300169ae:	2001      	movs	r0, #1
300169b0:	e73d      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
            dprintf(CRITICAL, "Primary GPT first usable LBA mismatch\n");
300169b2:	f24c 50dc 	movw	r0, #50652	; 0xc5dc
300169b6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300169ba:	f7ff f8f9 	bl	30015bb0 <_printf>
            return 1;
300169be:	2001      	movs	r0, #1
300169c0:	e735      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL, "Invalid first_usable_lba\n");
300169c2:	f241 302c 	movw	r0, #4908	; 0x132c
300169c6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300169ca:	f7ff f8f1 	bl	30015bb0 <_printf>
        return 1;
300169ce:	2001      	movs	r0, #1
300169d0:	e72d      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL, "Invalid parition entry size\n");
300169d2:	f24c 6004 	movw	r0, #50692	; 0xc604
300169d6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300169da:	f7ff f8e9 	bl	30015bb0 <_printf>
        return 1;
300169de:	2001      	movs	r0, #1
300169e0:	e725      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL, "Invalid last_usable_lba\n");
300169e2:	f241 3048 	movw	r0, #4936	; 0x1348
300169e6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300169ea:	f7ff f8e1 	bl	30015bb0 <_printf>
        return 1;
300169ee:	2001      	movs	r0, #1
300169f0:	e71d      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
        dprintf(CRITICAL, "Invalid maximum partition count\n");
300169f2:	f24c 6024 	movw	r0, #50724	; 0xc624
300169f6:	f2c3 0001 	movt	r0, #12289	; 0x3001
300169fa:	f7ff f8d9 	bl	30015bb0 <_printf>
        return 1;
300169fe:	2001      	movs	r0, #1
30016a00:	e715      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
    uint32_t blocks_for_entries =
30016a02:	f44f 4580 	mov.w	r5, #16384	; 0x4000
30016a06:	fbb5 f5f8 	udiv	r5, r5, r8
                                (blocks_for_entries + GPT_HEADER_BLOCKS))) {
30016a0a:	3501      	adds	r5, #1
            if (partition_0 != ((device_capacity / block_size) -
30016a0c:	1b72      	subs	r2, r6, r5
30016a0e:	f167 0300 	sbc.w	r3, r7, #0
30016a12:	4299      	cmp	r1, r3
30016a14:	bf08      	it	eq
30016a16:	4290      	cmpeq	r0, r2
30016a18:	f43f af78 	beq.w	3001690c <ptdev_parse_gpt_header.isra.2+0x140>
                dprintf(CRITICAL, "BackupGPT starting LBA mismatch\n");
30016a1c:	f241 3064 	movw	r0, #4964	; 0x1364
30016a20:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016a24:	f7ff f8c4 	bl	30015bb0 <_printf>
                return 1;
30016a28:	2001      	movs	r0, #1
30016a2a:	e700      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>
                dprintf(CRITICAL, "PrimaryGPT starting LBA mismatch\n");
30016a2c:	f24c 6048 	movw	r0, #50760	; 0xc648
30016a30:	f2c3 0001 	movt	r0, #12289	; 0x3001
30016a34:	f7ff f8bc 	bl	30015bb0 <_printf>
                return 1;
30016a38:	2001      	movs	r0, #1
30016a3a:	e6f8      	b.n	3001682e <ptdev_parse_gpt_header.isra.2+0x62>

30016a3c <restore_gpt>:
{
30016a3c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30016a40:	b0af      	sub	sp, #188	; 0xbc
30016a42:	910e      	str	r1, [sp, #56]	; 0x38
    if (!part_dev || !part_dev->storage) {
30016a44:	2800      	cmp	r0, #0
30016a46:	f000 8089 	beq.w	30016b5c <restore_gpt+0x120>
30016a4a:	f8d0 b000 	ldr.w	r11, [r0]
30016a4e:	4605      	mov	r5, r0
30016a50:	f1bb 0f00 	cmp.w	r11, #0
30016a54:	f000 8082 	beq.w	30016b5c <restore_gpt+0x120>
    block_size = storage->get_block_size(storage);
30016a58:	f8db 3020 	ldr.w	r3, [r11, #32]
30016a5c:	4658      	mov	r0, r11
30016a5e:	4674      	mov	r4, r14
30016a60:	4692      	mov	r10, r2
30016a62:	4798      	blx	r3
    erase_grp_sz = storage->get_erase_group_size(storage);
30016a64:	f8db 301c 	ldr.w	r3, [r11, #28]
    block_size = storage->get_block_size(storage);
30016a68:	4607      	mov	r7, r0
    erase_grp_sz = storage->get_erase_group_size(storage);
30016a6a:	4658      	mov	r0, r11
30016a6c:	4798      	blx	r3
30016a6e:	900f      	str	r0, [sp, #60]	; 0x3c
    if (!parent_entry) {
30016a70:	f1ba 0f00 	cmp.w	r10, #0
30016a74:	f040 8084 	bne.w	30016b80 <restore_gpt+0x144>
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
30016a78:	f8db 3018 	ldr.w	r3, [r11, #24]
30016a7c:	4658      	mov	r0, r11
30016a7e:	4798      	blx	r3
30016a80:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
30016a84:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
30016a88:	46b8      	mov	r8, r7
30016a8a:	f04f 0900 	mov.w	r9, #0
30016a8e:	e9cd 8908 	strd	r8, r9, [r13, #32]
30016a92:	1a82      	subs	r2, r0, r2
30016a94:	4610      	mov	r0, r2
30016a96:	eb61 0303 	sbc.w	r3, r1, r3
30016a9a:	4619      	mov	r1, r3
    card_size_sec = (device_capacity) / block_size;
30016a9c:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
30016aa0:	f003 f9be 	bl	30019e20 <__aeabi_uldivmod>
30016aa4:	4602      	mov	r2, r0
30016aa6:	460b      	mov	r3, r1
30016aa8:	e9cd 230c 	strd	r2, r3, [r13, #48]	; 0x30
    ASSERT (card_size_sec > 0);
30016aac:	4313      	orrs	r3, r2
30016aae:	f000 8244 	beq.w	30016f3a <restore_gpt+0x4fe>
    header_buf = memalign(block_size, block_size);
30016ab2:	4639      	mov	r1, r7
30016ab4:	4638      	mov	r0, r7
30016ab6:	f7fd fe2d 	bl	30014714 <memalign>
    entries_buf = memalign(block_size, block_size);
30016aba:	4639      	mov	r1, r7
    header_buf = memalign(block_size, block_size);
30016abc:	4604      	mov	r4, r0
    entries_buf = memalign(block_size, block_size);
30016abe:	4638      	mov	r0, r7
30016ac0:	f7fd fe28 	bl	30014714 <memalign>
    if (!header_buf || !entries_buf)
30016ac4:	4681      	mov	r9, r0
30016ac6:	fab0 f380 	clz	r3, r0
30016aca:	095b      	lsrs	r3, r3, #5
30016acc:	2c00      	cmp	r4, #0
30016ace:	bf08      	it	eq
30016ad0:	2301      	moveq	r3, #1
30016ad2:	b18b      	cbz	r3, 30016af8 <restore_gpt+0xbc>
    if (header_buf)
30016ad4:	b114      	cbz	r4, 30016adc <restore_gpt+0xa0>
        free(header_buf);
30016ad6:	4620      	mov	r0, r4
30016ad8:	f7fd fe58 	bl	3001478c <free>
    uint32_t ret = 1;
30016adc:	f04f 0801 	mov.w	r8, #1
    if (entries_buf)
30016ae0:	f1b9 0f00 	cmp.w	r9, #0
30016ae4:	d004      	beq.n	30016af0 <restore_gpt+0xb4>
        free(entries_buf);
30016ae6:	4648      	mov	r0, r9
    uint32_t ret = 1;
30016ae8:	f04f 0801 	mov.w	r8, #1
        free(entries_buf);
30016aec:	f7fd fe4e 	bl	3001478c <free>
}
30016af0:	4640      	mov	r0, r8
30016af2:	b02f      	add	sp, #188	; 0xbc
30016af4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (SEC2PRI == dir) {
30016af8:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30016afa:	2a01      	cmp	r2, #1
30016afc:	f000 822f 	beq.w	30016f5e <restore_gpt+0x522>
        ptn_src_header = cur_gpt_offset + block_size;
30016b00:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
    uint8_t *mbr_buf = NULL;
30016b04:	9316      	str	r3, [sp, #88]	; 0x58
        ptn_src_header = cur_gpt_offset + block_size;
30016b06:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30016b0a:	1812      	adds	r2, r2, r0
30016b0c:	414b      	adcs	r3, r1
    ret = storage->read(storage, ptn_src_header, header_buf, block_size);
30016b0e:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30016b12:	e9cd 0102 	strd	r0, r1, [r13, #8]
30016b16:	4658      	mov	r0, r11
30016b18:	9400      	str	r4, [sp, #0]
30016b1a:	f8db 1008 	ldr.w	r1, [r11, #8]
30016b1e:	4788      	blx	r1
    if (ret) {
30016b20:	4680      	mov	r8, r0
30016b22:	2800      	cmp	r0, #0
30016b24:	d053      	beq.n	30016bce <restore_gpt+0x192>
        ERROR("fail to read src gpt header!\n");
30016b26:	f241 11f4 	movw	r1, #4596	; 0x11f4
30016b2a:	f641 2030 	movw	r0, #6704	; 0x1a30
30016b2e:	f2c3 0102 	movt	r1, #12290	; 0x3002
30016b32:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
30016b36:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016b3a:	f7ff f839 	bl	30015bb0 <_printf>
        free(header_buf);
30016b3e:	4620      	mov	r0, r4
30016b40:	f7fd fe24 	bl	3001478c <free>
        free(entries_buf);
30016b44:	4648      	mov	r0, r9
30016b46:	f7fd fe21 	bl	3001478c <free>
    if (mbr_buf)
30016b4a:	9816      	ldr	r0, [sp, #88]	; 0x58
30016b4c:	2800      	cmp	r0, #0
30016b4e:	d0cf      	beq.n	30016af0 <restore_gpt+0xb4>
        free(mbr_buf);
30016b50:	f7fd fe1c 	bl	3001478c <free>
}
30016b54:	4640      	mov	r0, r8
30016b56:	b02f      	add	sp, #188	; 0xbc
30016b58:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ERROR("partition device error!\n");
30016b5c:	f241 11f4 	movw	r1, #4596	; 0x11f4
30016b60:	f641 1094 	movw	r0, #6548	; 0x1994
30016b64:	f44f 72cc 	mov.w	r2, #408	; 0x198
30016b68:	f2c3 0102 	movt	r1, #12290	; 0x3002
    uint32_t ret = 1;
30016b6c:	f04f 0801 	mov.w	r8, #1
        ERROR("partition device error!\n");
30016b70:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016b74:	f7ff f81c 	bl	30015bb0 <_printf>
}
30016b78:	4640      	mov	r0, r8
30016b7a:	b02f      	add	sp, #188	; 0xbc
30016b7c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                           parent_entry->first_lba + 1) * block_size;
30016b80:	e9da 230a 	ldrd	r2, r3, [r10, #40]	; 0x28
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30016b84:	f8da 6024 	ldr.w	r6, [r10, #36]	; 0x24
                           parent_entry->first_lba + 1) * block_size;
30016b88:	1c50      	adds	r0, r2, #1
30016b8a:	f143 0100 	adc.w	r1, r3, #0
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30016b8e:	f8da 3020 	ldr.w	r3, [r10, #32]
30016b92:	fba3 8907 	umull	r8, r9, r3, r7
                           parent_entry->first_lba + 1) * block_size;
30016b96:	e9da 2308 	ldrd	r2, r3, [r10, #32]
30016b9a:	1a82      	subs	r2, r0, r2
30016b9c:	eb61 0303 	sbc.w	r3, r1, r3
        device_capacity = (parent_entry->last_lba -
30016ba0:	fba2 0107 	umull	r0, r1, r2, r7
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30016ba4:	fb07 9906 	mla	r9, r7, r6, r9
        device_capacity = (parent_entry->last_lba -
30016ba8:	fb07 1103 	mla	r1, r7, r3, r1
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30016bac:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
30016bb0:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
30016bb4:	463a      	mov	r2, r7
30016bb6:	2300      	movs	r3, #0
30016bb8:	e9cd 2308 	strd	r2, r3, [r13, #32]
30016bbc:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30016bc0:	eb12 0208 	adds.w	r2, r2, r8
30016bc4:	eb43 0309 	adc.w	r3, r3, r9
30016bc8:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
30016bcc:	e766      	b.n	30016a9c <restore_gpt+0x60>
    ret = ptdev_parse_gpt_header(part_dev, header_buf, &first_usable_lba,
30016bce:	9b0e      	ldr	r3, [sp, #56]	; 0x38
30016bd0:	aa27      	add	r2, sp, #156	; 0x9c
30016bd2:	6828      	ldr	r0, [r5, #0]
30016bd4:	f10d 0cb0 	add.w	r12, r13, #176	; 0xb0
30016bd8:	f003 0e01 	and.w	r14, r3, #1
30016bdc:	2301      	movs	r3, #1
30016bde:	f105 0108 	add.w	r1, r5, #8
30016be2:	9206      	str	r2, [sp, #24]
30016be4:	ad29      	add	r5, sp, #164	; 0xa4
30016be6:	9307      	str	r3, [sp, #28]
30016be8:	aa28      	add	r2, sp, #160	; 0xa0
30016bea:	f8cd a00c 	str.w	r10, [r13, #12]
30016bee:	ab26      	add	r3, sp, #152	; 0x98
30016bf0:	9201      	str	r2, [sp, #4]
30016bf2:	4622      	mov	r2, r4
30016bf4:	9302      	str	r3, [sp, #8]
30016bf6:	ab2a      	add	r3, sp, #168	; 0xa8
30016bf8:	f8cd c014 	str.w	r12, [r13, #20]
30016bfc:	f8cd e010 	str.w	r14, [r13, #16]
30016c00:	9500      	str	r5, [sp, #0]
30016c02:	f7ff fde3 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
    if (ret) {
30016c06:	4680      	mov	r8, r0
30016c08:	2800      	cmp	r0, #0
30016c0a:	f040 81de 	bne.w	30016fca <restore_gpt+0x58e>
    entries_cnt_per_block = block_size / partition_entry_size;
30016c0e:	9b29      	ldr	r3, [sp, #164]	; 0xa4
    blocks_to_read = round_up(max_partition_count,
30016c10:	2100      	movs	r1, #0
30016c12:	9a26      	ldr	r2, [sp, #152]	; 0x98
30016c14:	2600      	movs	r6, #0
30016c16:	4610      	mov	r0, r2
30016c18:	42b1      	cmp	r1, r6
    entries_cnt_per_block = block_size / partition_entry_size;
30016c1a:	fbb7 f3f3 	udiv	r3, r7, r3
    blocks_to_read = round_up(max_partition_count,
30016c1e:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30016c22:	461d      	mov	r5, r3
30016c24:	bf08      	it	eq
30016c26:	429a      	cmpeq	r2, r3
30016c28:	bf34      	ite	cc
30016c2a:	2201      	movcc	r2, #1
30016c2c:	2200      	movcs	r2, #0
30016c2e:	2b00      	cmp	r3, #0
30016c30:	bf14      	ite	ne
30016c32:	4613      	movne	r3, r2
30016c34:	2301      	moveq	r3, #1
30016c36:	2b00      	cmp	r3, #0
30016c38:	f040 81c3 	bne.w	30016fc2 <restore_gpt+0x586>
    mod = size % aligned;
30016c3c:	462a      	mov	r2, r5
30016c3e:	4633      	mov	r3, r6
30016c40:	e9cd 5612 	strd	r5, r6, [r13, #72]	; 0x48
30016c44:	4605      	mov	r5, r0
30016c46:	460e      	mov	r6, r1
30016c48:	f003 f8ea 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30016c4c:	ea52 0103 	orrs.w	r1, r2, r3
30016c50:	f040 81c8 	bne.w	30016fe4 <restore_gpt+0x5a8>
30016c54:	e9dd 2312 	ldrd	r2, r3, [r13, #72]	; 0x48
30016c58:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
30016c5c:	f003 f8e0 	bl	30019e20 <__aeabi_uldivmod>
30016c60:	9014      	str	r0, [sp, #80]	; 0x50
30016c62:	9012      	str	r0, [sp, #72]	; 0x48
    current_header_lba =
30016c64:	6a23      	ldr	r3, [r4, #32]
30016c66:	9317      	str	r3, [sp, #92]	; 0x5c
    if (SEC2PRI == dir) {
30016c68:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    backup_header_lba =
30016c6a:	f8d4 a018 	ldr.w	r10, [r4, #24]
30016c6e:	f8d4 c01c 	ldr.w	r12, [r4, #28]
    if (SEC2PRI == dir) {
30016c72:	2b01      	cmp	r3, #1
    current_header_lba =
30016c74:	6a62      	ldr	r2, [r4, #36]	; 0x24
    if (SEC2PRI == dir) {
30016c76:	f000 81dd 	beq.w	30017034 <restore_gpt+0x5f8>
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016c7a:	e9dd 560c 	ldrd	r5, r6, [r13, #48]	; 0x30
        gpt_size = (GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30016c7e:	9b12      	ldr	r3, [sp, #72]	; 0x48
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016c80:	f115 35ff 	adds.w	r5, r5, #4294967295	; 0xffffffff
30016c84:	4628      	mov	r0, r5
30016c86:	f146 36ff 	adc.w	r6, r6, #4294967295	; 0xffffffff
30016c8a:	4631      	mov	r1, r6
        gpt_size = (GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30016c8c:	f103 0e01 	add.w	r14, r3, #1
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016c90:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
30016c94:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
30016c98:	4633      	mov	r3, r6
        gpt_size = (GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30016c9a:	fb07 f10e 	mul.w	r1, r7, r14
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016c9e:	fb00 f303 	mul.w	r3, r0, r3
30016ca2:	980c      	ldr	r0, [sp, #48]	; 0x30
30016ca4:	fa5f fe82 	uxtb.w	r14, r2
        gpt_size = (GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30016ca8:	9121      	str	r1, [sp, #132]	; 0x84
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016caa:	fba0 5605 	umull	r5, r6, r0, r5
30016cae:	980d      	ldr	r0, [sp, #52]	; 0x34
30016cb0:	e9cd 5610 	strd	r5, r6, [r13, #64]	; 0x40
30016cb4:	9d08      	ldr	r5, [sp, #32]
30016cb6:	9e11      	ldr	r6, [sp, #68]	; 0x44
30016cb8:	fb05 3300 	mla	r3, r5, r0, r3
30016cbc:	4433      	add	r3, r6
30016cbe:	e9dd 560a 	ldrd	r5, r6, [r13, #40]	; 0x28
30016cc2:	9311      	str	r3, [sp, #68]	; 0x44
        ptn_erase = ptn_dst_header - blocks_to_read * block_size;
30016cc4:	1bcb      	subs	r3, r1, r7
        ptn_dst_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016cc6:	e9dd 0110 	ldrd	r0, r1, [r13, #64]	; 0x40
30016cca:	182d      	adds	r5, r5, r0
30016ccc:	4628      	mov	r0, r5
30016cce:	414e      	adcs	r6, r1
30016cd0:	4631      	mov	r1, r6
30016cd2:	e9cd 5610 	strd	r5, r6, [r13, #64]	; 0x40
30016cd6:	e9cd 0124 	strd	r0, r1, [r13, #144]	; 0x90
        entries_start_lba = card_size_sec - 1 - blocks_to_read;
30016cda:	e9dd 560c 	ldrd	r5, r6, [r13, #48]	; 0x30
30016cde:	9914      	ldr	r1, [sp, #80]	; 0x50
30016ce0:	1a6d      	subs	r5, r5, r1
30016ce2:	4628      	mov	r0, r5
30016ce4:	f166 0600 	sbc.w	r6, r6, #0
30016ce8:	4631      	mov	r1, r6
        ptn_erase = ptn_dst_header - blocks_to_read * block_size;
30016cea:	e9dd 5610 	ldrd	r5, r6, [r13, #64]	; 0x40
30016cee:	1aed      	subs	r5, r5, r3
30016cf0:	b2c3      	uxtb	r3, r0
30016cf2:	f166 0600 	sbc.w	r6, r6, #0
30016cf6:	9314      	str	r3, [sp, #80]	; 0x50
30016cf8:	f3c0 2307 	ubfx	r3, r0, #8, #8
30016cfc:	e9cd 5622 	strd	r5, r6, [r13, #136]	; 0x88
30016d00:	930c      	str	r3, [sp, #48]	; 0x30
30016d02:	f3c0 4307 	ubfx	r3, r0, #16, #8
        ptn_dst_entries = ptn_erase;
30016d06:	e9cd 5610 	strd	r5, r6, [r13, #64]	; 0x40
30016d0a:	931b      	str	r3, [sp, #108]	; 0x6c
30016d0c:	0e03      	lsrs	r3, r0, #24
30016d0e:	931c      	str	r3, [sp, #112]	; 0x70
30016d10:	b2cb      	uxtb	r3, r1
30016d12:	931d      	str	r3, [sp, #116]	; 0x74
30016d14:	f3c1 2307 	ubfx	r3, r1, #8, #8
30016d18:	931e      	str	r3, [sp, #120]	; 0x78
30016d1a:	f3c1 4307 	ubfx	r3, r1, #16, #8
30016d1e:	931f      	str	r3, [sp, #124]	; 0x7c
30016d20:	0e0b      	lsrs	r3, r1, #24
30016d22:	9917      	ldr	r1, [sp, #92]	; 0x5c
30016d24:	f3c1 2507 	ubfx	r5, r1, #8, #8
30016d28:	b2ce      	uxtb	r6, r1
30016d2a:	f3c1 4007 	ubfx	r0, r1, #16, #8
30016d2e:	0e09      	lsrs	r1, r1, #24
30016d30:	911a      	str	r1, [sp, #104]	; 0x68
30016d32:	f3c2 2107 	ubfx	r1, r2, #8, #8
30016d36:	9119      	str	r1, [sp, #100]	; 0x64
30016d38:	f3c2 4107 	ubfx	r1, r2, #16, #8
30016d3c:	0e12      	lsrs	r2, r2, #24
30016d3e:	9118      	str	r1, [sp, #96]	; 0x60
30016d40:	9217      	str	r2, [sp, #92]	; 0x5c
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d42:	9a1a      	ldr	r2, [sp, #104]	; 0x68
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d44:	ea4f 211a 	mov.w	r1, r10, lsr #8
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d48:	76e2      	strb	r2, [r4, #27]
30016d4a:	9a19      	ldr	r2, [sp, #100]	; 0x64
30016d4c:	7762      	strb	r2, [r4, #29]
30016d4e:	9a18      	ldr	r2, [sp, #96]	; 0x60
30016d50:	77a2      	strb	r2, [r4, #30]
30016d52:	9a17      	ldr	r2, [sp, #92]	; 0x5c
30016d54:	77e2      	strb	r2, [r4, #31]
    PUT_LONG_LONG(header_buf + PARTITION_ENTRIES_OFFSET, entries_start_lba);
30016d56:	9a14      	ldr	r2, [sp, #80]	; 0x50
30016d58:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
30016d5c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
30016d5e:	f884 2049 	strb.w	r2, [r4, #73]	; 0x49
30016d62:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
30016d64:	f884 204a 	strb.w	r2, [r4, #74]	; 0x4a
30016d68:	9a1c      	ldr	r2, [sp, #112]	; 0x70
30016d6a:	f884 204b 	strb.w	r2, [r4, #75]	; 0x4b
30016d6e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d70:	9120      	str	r1, [sp, #128]	; 0x80
30016d72:	ea4f 411c 	mov.w	r1, r12, lsr #16
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d76:	7626      	strb	r6, [r4, #24]
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d78:	ea4f 461a 	mov.w	r6, r10, lsr #16
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d7c:	7665      	strb	r5, [r4, #25]
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d7e:	ea4f 651a 	mov.w	r5, r10, lsr #24
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d82:	76a0      	strb	r0, [r4, #26]
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d84:	ea4f 201c 	mov.w	r0, r12, lsr #8
    PUT_LONG_LONG(header_buf + PRIMARY_HEADER_OFFSET, current_header_lba);
30016d88:	f884 e01c 	strb.w	r14, [r4, #28]
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016d8c:	ea4f 6e1c 	mov.w	r14, r12, lsr #24
    PUT_LONG_LONG(header_buf + PARTITION_ENTRIES_OFFSET, entries_start_lba);
30016d90:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
30016d94:	9a1e      	ldr	r2, [sp, #120]	; 0x78
30016d96:	f884 204d 	strb.w	r2, [r4, #77]	; 0x4d
30016d9a:	f884 304f 	strb.w	r3, [r4, #79]	; 0x4f
30016d9e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016da0:	9b20      	ldr	r3, [sp, #128]	; 0x80
30016da2:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
30016da6:	f884 a020 	strb.w	r10, [r4, #32]
30016daa:	f884 c024 	strb.w	r12, [r4, #36]	; 0x24
    PUT_LONG_LONG(header_buf + PARTITION_ENTRIES_OFFSET, entries_start_lba);
30016dae:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e
    PUT_LONG_LONG(header_buf + BACKUP_HEADER_OFFSET, backup_header_lba);
30016db2:	f884 6022 	strb.w	r6, [r4, #34]	; 0x22
30016db6:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
30016dba:	f884 0025 	strb.w	r0, [r4, #37]	; 0x25
30016dbe:	f884 1026 	strb.w	r1, [r4, #38]	; 0x26
30016dc2:	f884 e027 	strb.w	r14, [r4, #39]	; 0x27
    if (storage->need_erase && storage->need_erase(storage)) {
30016dc6:	f8db 3024 	ldr.w	r3, [r11, #36]	; 0x24
30016dca:	2b00      	cmp	r3, #0
30016dcc:	d058      	beq.n	30016e80 <restore_gpt+0x444>
30016dce:	4658      	mov	r0, r11
30016dd0:	4798      	blx	r3
30016dd2:	2800      	cmp	r0, #0
30016dd4:	d054      	beq.n	30016e80 <restore_gpt+0x444>
        if (storage->erase(storage,
30016dd6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
30016dd8:	2100      	movs	r1, #0
    if (aligned == 0 || size < aligned)
30016dda:	e9dd 5622 	ldrd	r5, r6, [r13, #136]	; 0x88
30016dde:	460a      	mov	r2, r1
30016de0:	4618      	mov	r0, r3
30016de2:	fab3 fa83 	clz	r10, r3
30016de6:	4619      	mov	r1, r3
30016de8:	4296      	cmp	r6, r2
30016dea:	bf08      	it	eq
30016dec:	429d      	cmpeq	r5, r3
30016dee:	f8db 3010 	ldr.w	r3, [r11, #16]
30016df2:	ea4f 1a5a 	mov.w	r10, r10, lsr #5
30016df6:	930f      	str	r3, [sp, #60]	; 0x3c
30016df8:	bf28      	it	cs
30016dfa:	4653      	movcs	r3, r10
30016dfc:	e9cd 120c 	strd	r1, r2, [r13, #48]	; 0x30
30016e00:	bf38      	it	cc
30016e02:	f04a 0301 	orrcc.w	r3, r10, #1
30016e06:	2b00      	cmp	r3, #0
30016e08:	f000 80f8 	beq.w	30016ffc <restore_gpt+0x5c0>
        return 0;
30016e0c:	2200      	movs	r2, #0
30016e0e:	2300      	movs	r3, #0
30016e10:	e9cd 2314 	strd	r2, r3, [r13, #80]	; 0x50
30016e14:	9b21      	ldr	r3, [sp, #132]	; 0x84
30016e16:	2100      	movs	r1, #0
30016e18:	4618      	mov	r0, r3
    if (aligned == 0 || size < aligned)
30016e1a:	e9dd 230c 	ldrd	r2, r3, [r13, #48]	; 0x30
30016e1e:	4299      	cmp	r1, r3
30016e20:	bf08      	it	eq
30016e22:	4290      	cmpeq	r0, r2
30016e24:	bf2c      	ite	cs
30016e26:	4655      	movcs	r5, r10
30016e28:	f04a 0501 	orrcc.w	r5, r10, #1
30016e2c:	b98d      	cbnz	r5, 30016e52 <restore_gpt+0x416>
    mod = size % aligned;
30016e2e:	4615      	mov	r5, r2
30016e30:	461e      	mov	r6, r3
30016e32:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
30016e36:	f002 fff3 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30016e3a:	ea52 0103 	orrs.w	r1, r2, r3
30016e3e:	d008      	beq.n	30016e52 <restore_gpt+0x416>
30016e40:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
30016e44:	182d      	adds	r5, r5, r0
30016e46:	414e      	adcs	r6, r1
30016e48:	1aa8      	subs	r0, r5, r2
30016e4a:	eb66 0103 	sbc.w	r1, r6, r3
30016e4e:	e9cd 010c 	strd	r0, r1, [r13, #48]	; 0x30
30016e52:	e9dd 230c 	ldrd	r2, r3, [r13, #48]	; 0x30
30016e56:	4658      	mov	r0, r11
30016e58:	e9cd 2300 	strd	r2, r3, [r13]
30016e5c:	990f      	ldr	r1, [sp, #60]	; 0x3c
30016e5e:	e9dd 2314 	ldrd	r2, r3, [r13, #80]	; 0x50
30016e62:	4788      	blx	r1
30016e64:	b160      	cbz	r0, 30016e80 <restore_gpt+0x444>
            ERROR("erase gpt header fail!\n");
30016e66:	f241 11f4 	movw	r1, #4596	; 0x11f4
30016e6a:	f641 2098 	movw	r0, #6808	; 0x1a98
30016e6e:	f240 12ff 	movw	r2, #511	; 0x1ff
30016e72:	f2c3 0102 	movt	r1, #12290	; 0x3002
30016e76:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016e7a:	f7fe fe99 	bl	30015bb0 <_printf>
            goto end;
30016e7e:	e65e      	b.n	30016b3e <restore_gpt+0x102>
    partition_entries_offset += cur_gpt_offset;
30016e80:	e9dd 232c 	ldrd	r2, r3, [r13, #176]	; 0xb0
30016e84:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30016e88:	1880      	adds	r0, r0, r2
30016e8a:	4602      	mov	r2, r0
30016e8c:	4159      	adcs	r1, r3
30016e8e:	460b      	mov	r3, r1
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30016e90:	9912      	ldr	r1, [sp, #72]	; 0x48
    partition_entries_offset += cur_gpt_offset;
30016e92:	e9cd 232c 	strd	r2, r3, [r13, #176]	; 0xb0
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30016e96:	2900      	cmp	r1, #0
30016e98:	f000 8167 	beq.w	3001716a <restore_gpt+0x72e>
30016e9c:	2500      	movs	r5, #0
30016e9e:	462e      	mov	r6, r5
30016ea0:	464d      	mov	r5, r9
30016ea2:	960f      	str	r6, [sp, #60]	; 0x3c
30016ea4:	e023      	b.n	30016eee <restore_gpt+0x4b2>
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30016ea6:	4640      	mov	r0, r8
30016ea8:	463a      	mov	r2, r7
30016eaa:	4629      	mov	r1, r5
30016eac:	f7fc f854 	bl	30012f58 <crc32>
        ret = storage->write(storage, ptn_dst_entries + (i * block_size), entries_buf,
30016eb0:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
30016eb4:	e9cd 2302 	strd	r2, r3, [r13, #8]
30016eb8:	e9dd 9a10 	ldrd	r9, r10, [r13, #64]	; 0x40
30016ebc:	e9dd 230c 	ldrd	r2, r3, [r13, #48]	; 0x30
30016ec0:	9500      	str	r5, [sp, #0]
30016ec2:	f8db 100c 	ldr.w	r1, [r11, #12]
30016ec6:	eb12 0209 	adds.w	r2, r2, r9
30016eca:	eb43 030a 	adc.w	r3, r3, r10
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30016ece:	4680      	mov	r8, r0
        ret = storage->write(storage, ptn_dst_entries + (i * block_size), entries_buf,
30016ed0:	4658      	mov	r0, r11
30016ed2:	4788      	blx	r1
        if (ret) {
30016ed4:	2800      	cmp	r0, #0
30016ed6:	f040 80d7 	bne.w	30017088 <restore_gpt+0x64c>
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30016eda:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
30016edc:	443e      	add	r6, r7
30016ede:	9a12      	ldr	r2, [sp, #72]	; 0x48
30016ee0:	3301      	adds	r3, #1
30016ee2:	4293      	cmp	r3, r2
30016ee4:	930f      	str	r3, [sp, #60]	; 0x3c
30016ee6:	f000 80df 	beq.w	300170a8 <restore_gpt+0x66c>
30016eea:	e9dd 232c 	ldrd	r2, r3, [r13, #176]	; 0xb0
        ret = storage->read(storage, partition_entries_offset + (i * block_size),
30016eee:	2100      	movs	r1, #0
30016ef0:	46b1      	mov	r9, r6
30016ef2:	9500      	str	r5, [sp, #0]
30016ef4:	468a      	mov	r10, r1
30016ef6:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30016efa:	e9cd 9a0c 	strd	r9, r10, [r13, #48]	; 0x30
30016efe:	eb16 0902 	adds.w	r9, r6, r2
30016f02:	e9cd 0102 	strd	r0, r1, [r13, #8]
30016f06:	eb4a 0a03 	adc.w	r10, r10, r3
30016f0a:	4658      	mov	r0, r11
30016f0c:	464a      	mov	r2, r9
30016f0e:	f8db 1008 	ldr.w	r1, [r11, #8]
30016f12:	4653      	mov	r3, r10
30016f14:	4788      	blx	r1
        if (ret) {
30016f16:	2800      	cmp	r0, #0
30016f18:	d0c5      	beq.n	30016ea6 <restore_gpt+0x46a>
30016f1a:	4603      	mov	r3, r0
            ERROR("fail to read partition entries\n");
30016f1c:	f241 11f4 	movw	r1, #4596	; 0x11f4
30016f20:	f641 20c4 	movw	r0, #6852	; 0x1ac4
30016f24:	f2c3 0102 	movt	r1, #12290	; 0x3002
30016f28:	f240 220d 	movw	r2, #525	; 0x20d
30016f2c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016f30:	46a9      	mov	r9, r5
        ret = storage->read(storage, partition_entries_offset + (i * block_size),
30016f32:	4698      	mov	r8, r3
            ERROR("fail to read partition entries\n");
30016f34:	f7fe fe3c 	bl	30015bb0 <_printf>
            goto end;
30016f38:	e601      	b.n	30016b3e <restore_gpt+0x102>
    ASSERT (card_size_sec > 0);
30016f3a:	f641 13f0 	movw	r3, #6640	; 0x19f0
30016f3e:	f641 12c0 	movw	r2, #6592	; 0x19c0
30016f42:	f24a 011c 	movw	r1, #40988	; 0xa01c
30016f46:	f2c3 0302 	movt	r3, #12290	; 0x3002
30016f4a:	4620      	mov	r0, r4
30016f4c:	f2c3 0202 	movt	r2, #12290	; 0x3002
30016f50:	9300      	str	r3, [sp, #0]
30016f52:	f2c3 0101 	movt	r1, #12289	; 0x3001
30016f56:	f44f 73d7 	mov.w	r3, #430	; 0x1ae
30016f5a:	f7fd f95b 	bl	30014214 <_panic>
        mbr_buf = memalign(block_size, block_size);
30016f5e:	4639      	mov	r1, r7
30016f60:	4638      	mov	r0, r7
30016f62:	f7fd fbd7 	bl	30014714 <memalign>
        if (!mbr_buf)
30016f66:	9016      	str	r0, [sp, #88]	; 0x58
30016f68:	4603      	mov	r3, r0
30016f6a:	2800      	cmp	r0, #0
30016f6c:	f000 8100 	beq.w	30017170 <restore_gpt+0x734>
        ret = storage->read(storage, cur_gpt_offset, mbr_buf, block_size);
30016f70:	e9dd 1208 	ldrd	r1, r2, [r13, #32]
30016f74:	4658      	mov	r0, r11
30016f76:	e9cd 1202 	strd	r1, r2, [r13, #8]
30016f7a:	9300      	str	r3, [sp, #0]
30016f7c:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30016f80:	f8db 1008 	ldr.w	r1, [r11, #8]
30016f84:	4788      	blx	r1
        if (ret) {
30016f86:	4680      	mov	r8, r0
30016f88:	2800      	cmp	r0, #0
30016f8a:	d143      	bne.n	30017014 <restore_gpt+0x5d8>
        ptn_src_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30016f8c:	e9dd 010c 	ldrd	r0, r1, [r13, #48]	; 0x30
30016f90:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
30016f94:	f141 31ff 	adc.w	r1, r1, #4294967295	; 0xffffffff
30016f98:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30016f9c:	9a10      	ldr	r2, [sp, #64]	; 0x40
30016f9e:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30016fa2:	fb02 f601 	mul.w	r6, r2, r1
30016fa6:	fba2 2300 	umull	r2, r3, r2, r0
30016faa:	4601      	mov	r1, r0
30016fac:	9811      	ldr	r0, [sp, #68]	; 0x44
30016fae:	fb01 6100 	mla	r1, r1, r0, r6
30016fb2:	440b      	add	r3, r1
30016fb4:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30016fb8:	1880      	adds	r0, r0, r2
30016fba:	4602      	mov	r2, r0
30016fbc:	4159      	adcs	r1, r3
30016fbe:	460b      	mov	r3, r1
30016fc0:	e5a5      	b.n	30016b0e <restore_gpt+0xd2>
    if (aligned == 0 || size < aligned)
30016fc2:	2301      	movs	r3, #1
30016fc4:	9312      	str	r3, [sp, #72]	; 0x48
30016fc6:	9314      	str	r3, [sp, #80]	; 0x50
30016fc8:	e64c      	b.n	30016c64 <restore_gpt+0x228>
        ERROR("fail to parse src gpt header!\n");
30016fca:	f241 11f4 	movw	r1, #4596	; 0x11f4
30016fce:	f641 2064 	movw	r0, #6756	; 0x1a64
30016fd2:	f44f 72ec 	mov.w	r2, #472	; 0x1d8
30016fd6:	f2c3 0102 	movt	r1, #12290	; 0x3002
30016fda:	f2c3 0002 	movt	r0, #12290	; 0x3002
30016fde:	f7fe fde7 	bl	30015bb0 <_printf>
        goto end;
30016fe2:	e5ac      	b.n	30016b3e <restore_gpt+0x102>
30016fe4:	4628      	mov	r0, r5
30016fe6:	4631      	mov	r1, r6
30016fe8:	e9dd 5612 	ldrd	r5, r6, [r13, #72]	; 0x48
30016fec:	1940      	adds	r0, r0, r5
30016fee:	4171      	adcs	r1, r6
30016ff0:	1a80      	subs	r0, r0, r2
30016ff2:	eb61 0103 	sbc.w	r1, r1, r3
30016ff6:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30016ffa:	e62b      	b.n	30016c54 <restore_gpt+0x218>
    mod = size % aligned;
30016ffc:	4613      	mov	r3, r2
30016ffe:	4631      	mov	r1, r6
30017000:	4602      	mov	r2, r0
30017002:	4628      	mov	r0, r5
30017004:	f002 ff0c 	bl	30019e20 <__aeabi_uldivmod>
    size -= mod;
30017008:	1aa8      	subs	r0, r5, r2
3001700a:	eb66 0103 	sbc.w	r1, r6, r3
3001700e:	e9cd 0114 	strd	r0, r1, [r13, #80]	; 0x50
30017012:	e6ff      	b.n	30016e14 <restore_gpt+0x3d8>
            ERROR("fail to read mbr block\n");
30017014:	f241 11f4 	movw	r1, #4596	; 0x11f4
30017018:	f641 2004 	movw	r0, #6660	; 0x1a04
3001701c:	f240 12bf 	movw	r2, #447	; 0x1bf
30017020:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017024:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017028:	f7fe fdc2 	bl	30015bb0 <_printf>
        free(header_buf);
3001702c:	4620      	mov	r0, r4
3001702e:	f7fd fbad 	bl	3001478c <free>
30017032:	e587      	b.n	30016b44 <restore_gpt+0x108>
        gpt_size = (1 + GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30017034:	9b12      	ldr	r3, [sp, #72]	; 0x48
        ptn_dst_header += block_size;
30017036:	e9dd 560a 	ldrd	r5, r6, [r13, #40]	; 0x28
        ptn_erase = ptn_dst_header;
3001703a:	e9cd 5622 	strd	r5, r6, [r13, #136]	; 0x88
        gpt_size = (1 + GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
3001703e:	f103 0e02 	add.w	r14, r3, #2
        ptn_dst_header += block_size;
30017042:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
30017046:	18a8      	adds	r0, r5, r2
        gpt_size = (1 + GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
30017048:	fb07 f20e 	mul.w	r2, r7, r14
        ptn_dst_header += block_size;
3001704c:	eb46 0103 	adc.w	r1, r6, r3
        ptn_dst_entries = ptn_dst_header + block_size;
30017050:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
30017054:	2300      	movs	r3, #0
        ptn_dst_header += block_size;
30017056:	e9cd 0124 	strd	r0, r1, [r13, #144]	; 0x90
3001705a:	469e      	mov	r14, r3
        gpt_size = (1 + GPT_HEADER_BLOCKS + blocks_to_read) * block_size;
3001705c:	9221      	str	r2, [sp, #132]	; 0x84
        ptn_dst_entries = ptn_dst_header + block_size;
3001705e:	1940      	adds	r0, r0, r5
30017060:	f04f 0202 	mov.w	r2, #2
30017064:	4171      	adcs	r1, r6
30017066:	e9cd 331e 	strd	r3, r3, [r13, #120]	; 0x78
3001706a:	461d      	mov	r5, r3
3001706c:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30017070:	4618      	mov	r0, r3
30017072:	e9cd 331c 	strd	r3, r3, [r13, #112]	; 0x70
30017076:	931b      	str	r3, [sp, #108]	; 0x6c
30017078:	930c      	str	r3, [sp, #48]	; 0x30
3001707a:	e9cd 3317 	strd	r3, r3, [r13, #92]	; 0x5c
3001707e:	9319      	str	r3, [sp, #100]	; 0x64
30017080:	931a      	str	r3, [sp, #104]	; 0x68
30017082:	9214      	str	r2, [sp, #80]	; 0x50
30017084:	9e0e      	ldr	r6, [sp, #56]	; 0x38
30017086:	e65c      	b.n	30016d42 <restore_gpt+0x306>
30017088:	4603      	mov	r3, r0
            ERROR("fail to restore partition entries\n");
3001708a:	f241 11f4 	movw	r1, #4596	; 0x11f4
3001708e:	f641 20f8 	movw	r0, #6904	; 0x1af8
30017092:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017096:	f240 2217 	movw	r2, #535	; 0x217
3001709a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001709e:	46a9      	mov	r9, r5
        ret = storage->write(storage, ptn_dst_entries + (i * block_size), entries_buf,
300170a0:	4698      	mov	r8, r3
            ERROR("fail to restore partition entries\n");
300170a2:	f7fe fd85 	bl	30015bb0 <_printf>
            goto end;
300170a6:	e54a      	b.n	30016b3e <restore_gpt+0x102>
300170a8:	46a9      	mov	r9, r5
    if (crc_entries != crc32_val) {
300170aa:	9b27      	ldr	r3, [sp, #156]	; 0x9c
300170ac:	4543      	cmp	r3, r8
300170ae:	d00e      	beq.n	300170ce <restore_gpt+0x692>
        ERROR("fail to check partition entries crc32\n");
300170b0:	f241 11f4 	movw	r1, #4596	; 0x11f4
300170b4:	f641 3030 	movw	r0, #6960	; 0x1b30
300170b8:	f240 221d 	movw	r2, #541	; 0x21d
300170bc:	f2c3 0102 	movt	r1, #12290	; 0x3002
        ret = 1;
300170c0:	f04f 0801 	mov.w	r8, #1
        ERROR("fail to check partition entries crc32\n");
300170c4:	f2c3 0002 	movt	r0, #12290	; 0x3002
300170c8:	f7fe fd72 	bl	30015bb0 <_printf>
        goto end;
300170cc:	e537      	b.n	30016b3e <restore_gpt+0x102>
    PUT_LONG(header_buf + HEADER_CRC_OFFSET, crc32_val);
300170ce:	2300      	movs	r3, #0
    PUT_LONG(header_buf + PARTITION_CRC_OFFSET, crc32_val);
300170d0:	ea4f 2018 	mov.w	r0, r8, lsr #8
300170d4:	ea4f 4118 	mov.w	r1, r8, lsr #16
300170d8:	f884 8058 	strb.w	r8, [r4, #88]	; 0x58
300170dc:	ea4f 6218 	mov.w	r2, r8, lsr #24
300170e0:	f884 0059 	strb.w	r0, [r4, #89]	; 0x59
    crc32_val = crc32(0, header_buf, header_size);
300170e4:	4618      	mov	r0, r3
    PUT_LONG(header_buf + PARTITION_CRC_OFFSET, crc32_val);
300170e6:	f884 105a 	strb.w	r1, [r4, #90]	; 0x5a
    crc32_val = crc32(0, header_buf, header_size);
300170ea:	4621      	mov	r1, r4
    PUT_LONG(header_buf + PARTITION_CRC_OFFSET, crc32_val);
300170ec:	f884 205b 	strb.w	r2, [r4, #91]	; 0x5b
    PUT_LONG(header_buf + HEADER_CRC_OFFSET, crc32_val);
300170f0:	7423      	strb	r3, [r4, #16]
    crc32_val = crc32(0, header_buf, header_size);
300170f2:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    PUT_LONG(header_buf + HEADER_CRC_OFFSET, crc32_val);
300170f4:	7463      	strb	r3, [r4, #17]
300170f6:	74a3      	strb	r3, [r4, #18]
300170f8:	74e3      	strb	r3, [r4, #19]
    crc32_val = crc32(0, header_buf, header_size);
300170fa:	f7fb ff2d 	bl	30012f58 <crc32>
    ret = storage->write(storage, ptn_dst_header, header_buf, block_size);
300170fe:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
30017102:	e9cd 2302 	strd	r2, r3, [r13, #8]
30017106:	e9dd 2324 	ldrd	r2, r3, [r13, #144]	; 0x90
    crc32_val = crc32(0, header_buf, header_size);
3001710a:	4606      	mov	r6, r0
    ret = storage->write(storage, ptn_dst_header, header_buf, block_size);
3001710c:	4658      	mov	r0, r11
    PUT_LONG(header_buf + HEADER_CRC_OFFSET, crc32_val);
3001710e:	7426      	strb	r6, [r4, #16]
30017110:	0c31      	lsrs	r1, r6, #16
    ret = storage->write(storage, ptn_dst_header, header_buf, block_size);
30017112:	9400      	str	r4, [sp, #0]
    PUT_LONG(header_buf + HEADER_CRC_OFFSET, crc32_val);
30017114:	0a35      	lsrs	r5, r6, #8
30017116:	74a1      	strb	r1, [r4, #18]
30017118:	0e36      	lsrs	r6, r6, #24
3001711a:	7465      	strb	r5, [r4, #17]
3001711c:	74e6      	strb	r6, [r4, #19]
    ret = storage->write(storage, ptn_dst_header, header_buf, block_size);
3001711e:	f8db 100c 	ldr.w	r1, [r11, #12]
30017122:	4788      	blx	r1
    if (ret) {
30017124:	4680      	mov	r8, r0
30017126:	bb38      	cbnz	r0, 30017178 <restore_gpt+0x73c>
    if (SEC2PRI == dir) {
30017128:	9b0e      	ldr	r3, [sp, #56]	; 0x38
3001712a:	2b01      	cmp	r3, #1
3001712c:	f47f ad07 	bne.w	30016b3e <restore_gpt+0x102>
        ret = storage->write(storage, cur_gpt_offset, mbr_buf, block_size);
30017130:	e9dd 2308 	ldrd	r2, r3, [r13, #32]
30017134:	4658      	mov	r0, r11
30017136:	e9cd 2302 	strd	r2, r3, [r13, #8]
3001713a:	9b16      	ldr	r3, [sp, #88]	; 0x58
3001713c:	9300      	str	r3, [sp, #0]
3001713e:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30017142:	f8db 100c 	ldr.w	r1, [r11, #12]
30017146:	4788      	blx	r1
        if (ret) {
30017148:	4680      	mov	r8, r0
3001714a:	2800      	cmp	r0, #0
3001714c:	f43f acf7 	beq.w	30016b3e <restore_gpt+0x102>
            ERROR("fail to restore the mbr\n");
30017150:	f241 11f4 	movw	r1, #4596	; 0x11f4
30017154:	f641 30a4 	movw	r0, #7076	; 0x1ba4
30017158:	f240 2235 	movw	r2, #565	; 0x235
3001715c:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017160:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017164:	f7fe fd24 	bl	30015bb0 <_printf>
            goto end;
30017168:	e4e9      	b.n	30016b3e <restore_gpt+0x102>
    crc32_val = 0;
3001716a:	f8dd 8048 	ldr.w	r8, [r13, #72]	; 0x48
3001716e:	e79c      	b.n	300170aa <restore_gpt+0x66e>
        free(header_buf);
30017170:	4620      	mov	r0, r4
30017172:	f7fd fb0b 	bl	3001478c <free>
30017176:	e4b6      	b.n	30016ae6 <restore_gpt+0xaa>
        ERROR("fail to restore partition header\n");
30017178:	f241 11f4 	movw	r1, #4596	; 0x11f4
3001717c:	f641 306c 	movw	r0, #7020	; 0x1b6c
30017180:	f44f 720b 	mov.w	r2, #556	; 0x22c
30017184:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017188:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001718c:	f7fe fd10 	bl	30015bb0 <_printf>
        goto end;
30017190:	e4d5      	b.n	30016b3e <restore_gpt+0x102>
30017192:	bf00      	nop

30017194 <ptdev_read_gpt>:
{
30017194:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint32_t crc_entries = 0;
30017198:	2300      	movs	r3, #0
{
3001719a:	f5ad 7d1b 	sub.w	r13, r13, #620	; 0x26c
3001719e:	4606      	mov	r6, r0
    uint64_t partition_entries_offset = 0;
300171a0:	461d      	mov	r5, r3
{
300171a2:	920e      	str	r2, [sp, #56]	; 0x38
    struct partition_entry *partition_entries = part_dev->partition_entries;
300171a4:	6902      	ldr	r2, [r0, #16]
{
300171a6:	9020      	str	r0, [sp, #128]	; 0x80
    struct partition_entry *partition_entries = part_dev->partition_entries;
300171a8:	9217      	str	r2, [sp, #92]	; 0x5c
    unsigned partition_count = part_dev->count;
300171aa:	6942      	ldr	r2, [r0, #20]
    storage_device_t *storage = part_dev->storage;
300171ac:	6800      	ldr	r0, [r0, #0]
300171ae:	f8cd e0ac 	str.w	r14, [r13, #172]	; 0xac
    if (!parent_entry) {
300171b2:	9124      	str	r1, [sp, #144]	; 0x90
    unsigned partition_count = part_dev->count;
300171b4:	9228      	str	r2, [sp, #160]	; 0xa0
    storage_device_t *storage = part_dev->storage;
300171b6:	901e      	str	r0, [sp, #120]	; 0x78
    uint32_t crc_entries = 0;
300171b8:	9330      	str	r3, [sp, #192]	; 0xc0
    unsigned int max_partition_count = 0;
300171ba:	9332      	str	r3, [sp, #200]	; 0xc8
    uint64_t partition_entries_offset = 0;
300171bc:	e9cd 333a 	strd	r3, r3, [r13, #232]	; 0xe8
    if (!parent_entry) {
300171c0:	2900      	cmp	r1, #0
300171c2:	f040 81ef 	bne.w	300175a4 <ptdev_read_gpt+0x410>
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
300171c6:	6983      	ldr	r3, [r0, #24]
300171c8:	4798      	blx	r3
300171ca:	e9d6 2302 	ldrd	r2, r3, [r6, #8]
300171ce:	e9cd 2322 	strd	r2, r3, [r13, #136]	; 0x88
        lba_offset = 0;
300171d2:	e9cd 551c 	strd	r5, r5, [r13, #112]	; 0x70
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
300171d6:	1a82      	subs	r2, r0, r2
300171d8:	eb61 0303 	sbc.w	r3, r1, r3
300171dc:	e9cd 231a 	strd	r2, r3, [r13, #104]	; 0x68
    gpt_header_ptr = (uint8_t *)memalign(block_size, ROUNDUP(block_size,
300171e0:	9a0e      	ldr	r2, [sp, #56]	; 0x38
300171e2:	4610      	mov	r0, r2
300171e4:	4251      	negs	r1, r2
300171e6:	0053      	lsls	r3, r2, #1
300171e8:	3b01      	subs	r3, #1
300171ea:	4019      	ands	r1, r3
300171ec:	f7fd fa92 	bl	30014714 <memalign>
    if (!gpt_header_ptr) {
300171f0:	901f      	str	r0, [sp, #124]	; 0x7c
300171f2:	2800      	cmp	r0, #0
300171f4:	f000 841e 	beq.w	30017a34 <ptdev_read_gpt+0x8a0>
    ret = storage->read(storage, block_size + cur_gpt_offset, (uint8_t *)data,
300171f8:	9b0e      	ldr	r3, [sp, #56]	; 0x38
300171fa:	2600      	movs	r6, #0
300171fc:	991e      	ldr	r1, [sp, #120]	; 0x78
300171fe:	461d      	mov	r5, r3
30017200:	e9dd 2322 	ldrd	r2, r3, [r13, #136]	; 0x88
30017204:	4608      	mov	r0, r1
30017206:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
30017208:	e9cd 5602 	strd	r5, r6, [r13, #8]
3001720c:	1952      	adds	r2, r2, r5
3001720e:	9400      	str	r4, [sp, #0]
30017210:	4173      	adcs	r3, r6
30017212:	6889      	ldr	r1, [r1, #8]
30017214:	e9cd 5614 	strd	r5, r6, [r13, #80]	; 0x50
30017218:	4788      	blx	r1
    if (ret) {
3001721a:	4605      	mov	r5, r0
3001721c:	2800      	cmp	r0, #0
3001721e:	f040 81b3 	bne.w	30017588 <ptdev_read_gpt+0x3f4>
30017222:	9b20      	ldr	r3, [sp, #128]	; 0x80
    ret = ptdev_parse_gpt_header(part_dev, data, &first_usable_lba,
30017224:	2401      	movs	r4, #1
30017226:	9e24      	ldr	r6, [sp, #144]	; 0x90
30017228:	aa3a      	add	r2, sp, #232	; 0xe8
3001722a:	f103 0108 	add.w	r1, r3, #8
3001722e:	6818      	ldr	r0, [r3, #0]
30017230:	ab30      	add	r3, sp, #192	; 0xc0
30017232:	9407      	str	r4, [sp, #28]
30017234:	ac31      	add	r4, sp, #196	; 0xc4
30017236:	9603      	str	r6, [sp, #12]
30017238:	ae32      	add	r6, sp, #200	; 0xc8
3001723a:	9401      	str	r4, [sp, #4]
3001723c:	ac33      	add	r4, sp, #204	; 0xcc
3001723e:	9306      	str	r3, [sp, #24]
30017240:	ab38      	add	r3, sp, #224	; 0xe0
30017242:	e9cd 5204 	strd	r5, r2, [r13, #16]
30017246:	9602      	str	r6, [sp, #8]
30017248:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
3001724a:	9400      	str	r4, [sp, #0]
3001724c:	912c      	str	r1, [sp, #176]	; 0xb0
3001724e:	f7ff fabd 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
    if (ret) {
30017252:	2800      	cmp	r0, #0
30017254:	f040 8290 	bne.w	30017778 <ptdev_read_gpt+0x5e4>
    bool re_parse_gpt = false;
30017258:	902d      	str	r0, [sp, #180]	; 0xb4
        entries_buffer = memalign(block_size, block_size);
3001725a:	980e      	ldr	r0, [sp, #56]	; 0x38
3001725c:	4601      	mov	r1, r0
3001725e:	f7fd fa59 	bl	30014714 <memalign>
    if (!entries_buffer) {
30017262:	9016      	str	r0, [sp, #88]	; 0x58
30017264:	2800      	cmp	r0, #0
30017266:	f000 8327 	beq.w	300178b8 <ptdev_read_gpt+0x724>
    blocks_to_read = round_up(max_partition_count,
3001726a:	e9dd 4332 	ldrd	r4, r3, [r13, #200]	; 0xc8
3001726e:	f04f 0b00 	mov.w	r11, #0
    entries_cnt_per_block = block_size / partition_entry_size;
30017272:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    blocks_to_read = round_up(max_partition_count,
30017274:	f04f 0900 	mov.w	r9, #0
30017278:	e9dd 673a 	ldrd	r6, r7, [r13, #232]	; 0xe8
3001727c:	46a2      	mov	r10, r4
    entries_cnt_per_block = block_size / partition_entry_size;
3001727e:	fbb2 f3f3 	udiv	r3, r2, r3
30017282:	e9dd 1222 	ldrd	r1, r2, [r13, #136]	; 0x88
30017286:	1989      	adds	r1, r1, r6
30017288:	460e      	mov	r6, r1
3001728a:	417a      	adcs	r2, r7
3001728c:	4617      	mov	r7, r2
    if (aligned == 0 || size < aligned)
3001728e:	45cb      	cmp	r11, r9
30017290:	9319      	str	r3, [sp, #100]	; 0x64
30017292:	bf08      	it	eq
30017294:	429c      	cmpeq	r4, r3
    blocks_to_read = round_up(max_partition_count,
30017296:	461a      	mov	r2, r3
30017298:	4698      	mov	r8, r3
3001729a:	bf34      	ite	cc
3001729c:	2301      	movcc	r3, #1
3001729e:	2300      	movcs	r3, #0
300172a0:	2a00      	cmp	r2, #0
300172a2:	bf08      	it	eq
300172a4:	2301      	moveq	r3, #1
300172a6:	2b00      	cmp	r3, #0
300172a8:	f040 81a0 	bne.w	300175ec <ptdev_read_gpt+0x458>
    mod = size % aligned;
300172ac:	464b      	mov	r3, r9
300172ae:	4620      	mov	r0, r4
300172b0:	4659      	mov	r1, r11
300172b2:	f002 fdb5 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
300172b6:	ea52 0103 	orrs.w	r1, r2, r3
300172ba:	d008      	beq.n	300172ce <ptdev_read_gpt+0x13a>
300172bc:	eb14 0408 	adds.w	r4, r4, r8
300172c0:	eb4b 0509 	adc.w	r5, r11, r9
300172c4:	1aa4      	subs	r4, r4, r2
300172c6:	46a2      	mov	r10, r4
300172c8:	eb65 0503 	sbc.w	r5, r5, r3
300172cc:	46ab      	mov	r11, r5
                              entries_cnt_per_block) / entries_cnt_per_block;
300172ce:	4642      	mov	r2, r8
300172d0:	464b      	mov	r3, r9
300172d2:	4650      	mov	r0, r10
300172d4:	4659      	mov	r1, r11
300172d6:	f002 fda3 	bl	30019e20 <__aeabi_uldivmod>
    partition_entries_offset += cur_gpt_offset;
300172da:	e9cd 673a 	strd	r6, r7, [r13, #232]	; 0xe8
    for (i = 0; i < blocks_to_read; i++) {
300172de:	902a      	str	r0, [sp, #168]	; 0xa8
300172e0:	2800      	cmp	r0, #0
300172e2:	f000 829a 	beq.w	3001781a <ptdev_read_gpt+0x686>
        ASSERT(partition_count < NUM_PARTITIONS);
300172e6:	9a28      	ldr	r2, [sp, #160]	; 0xa0
300172e8:	2a7f      	cmp	r2, #127	; 0x7f
300172ea:	f200 82ab 	bhi.w	30017844 <ptdev_read_gpt+0x6b0>
300172ee:	2300      	movs	r3, #0
                dprintf(CRITICAL, "Partition entry(%d), lba not valid\n", j);
300172f0:	f241 41b8 	movw	r1, #5304	; 0x14b8
              & PART_ATT_READONLY_VAL);
}

static bool ptdev_sub_part_exist(struct partition_entry *partition_entries)
{
    return !memcmp(sub_part_guid, partition_entries->type_guid,
300172f4:	f641 30d0 	movw	r0, #7120	; 0x1bd0
                    dprintf(CRITICAL, "parse sub partition fail!\n");
300172f8:	f241 5514 	movw	r5, #5396	; 0x1514
                dprintf(CRITICAL, "Partition entry(%d), lba not valid\n", j);
300172fc:	f2c3 0102 	movt	r1, #12290	; 0x3002
    return !memcmp(sub_part_guid, partition_entries->type_guid,
30017300:	f2c3 0002 	movt	r0, #12290	; 0x3002
    valid_entry_finish = false;
30017304:	461c      	mov	r4, r3
                    dprintf(CRITICAL, "parse sub partition fail!\n");
30017306:	f2c3 0502 	movt	r5, #12290	; 0x3002
        ASSERT(partition_count < NUM_PARTITIONS);
3001730a:	9321      	str	r3, [sp, #132]	; 0x84
    for (i = 0; i < blocks_to_read; i++) {
3001730c:	9327      	str	r3, [sp, #156]	; 0x9c
    crc_val = 0;
3001730e:	9325      	str	r3, [sp, #148]	; 0x94
                dprintf(CRITICAL, "Partition entry(%d), lba not valid\n", j);
30017310:	9126      	str	r1, [sp, #152]	; 0x98
    return !memcmp(sub_part_guid, partition_entries->type_guid,
30017312:	902e      	str	r0, [sp, #184]	; 0xb8
                    dprintf(CRITICAL, "parse sub partition fail!\n");
30017314:	952f      	str	r5, [sp, #188]	; 0xbc
        ASSERT(partition_count < NUM_PARTITIONS);
30017316:	9218      	str	r2, [sp, #96]	; 0x60
        ret = storage->read(storage, partition_entries_offset + (i * block_size),
30017318:	e9dd 2314 	ldrd	r2, r3, [r13, #80]	; 0x50
3001731c:	e9cd 2302 	strd	r2, r3, [r13, #8]
30017320:	9b16      	ldr	r3, [sp, #88]	; 0x58
30017322:	991e      	ldr	r1, [sp, #120]	; 0x78
30017324:	9300      	str	r3, [sp, #0]
30017326:	4608      	mov	r0, r1
30017328:	9b21      	ldr	r3, [sp, #132]	; 0x84
3001732a:	6889      	ldr	r1, [r1, #8]
3001732c:	18f2      	adds	r2, r6, r3
3001732e:	f147 0300 	adc.w	r3, r7, #0
30017332:	4788      	blx	r1
        if (ret) {
30017334:	4680      	mov	r8, r0
30017336:	2800      	cmp	r0, #0
30017338:	f040 8296 	bne.w	30017868 <ptdev_read_gpt+0x6d4>
        crc_val = crc32(crc_val, data, block_size);
3001733c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
3001733e:	9825      	ldr	r0, [sp, #148]	; 0x94
30017340:	9916      	ldr	r1, [sp, #88]	; 0x58
30017342:	f7fb fe09 	bl	30012f58 <crc32>
        for (j = 0; j < entries_cnt_per_block && !valid_entry_finish; j++) {
30017346:	9a19      	ldr	r2, [sp, #100]	; 0x64
30017348:	f084 0301 	eor.w	r3, r4, #1
3001734c:	2a00      	cmp	r2, #0
3001734e:	bf08      	it	eq
30017350:	2300      	moveq	r3, #0
30017352:	9329      	str	r3, [sp, #164]	; 0xa4
        crc_val = crc32(crc_val, data, block_size);
30017354:	9025      	str	r0, [sp, #148]	; 0x94
        for (j = 0; j < entries_cnt_per_block && !valid_entry_finish; j++) {
30017356:	2b00      	cmp	r3, #0
30017358:	f000 8254 	beq.w	30017804 <ptdev_read_gpt+0x670>
3001735c:	f8cd 8034 	str.w	r8, [r13, #52]	; 0x34
                   &data[(j * partition_entry_size)],
30017360:	9d33      	ldr	r5, [sp, #204]	; 0xcc
            memcpy(&(current_entry->type_guid),
30017362:	ae50      	add	r6, sp, #320	; 0x140
                   &data[(j * partition_entry_size)],
30017364:	9f0d      	ldr	r7, [sp, #52]	; 0x34
30017366:	9b16      	ldr	r3, [sp, #88]	; 0x58
30017368:	fb05 f507 	mul.w	r5, r5, r7
3001736c:	195c      	adds	r4, r3, r5
            memcpy(&(current_entry->type_guid),
3001736e:	68e3      	ldr	r3, [r4, #12]
30017370:	6820      	ldr	r0, [r4, #0]
30017372:	6861      	ldr	r1, [r4, #4]
30017374:	68a2      	ldr	r2, [r4, #8]
30017376:	c60f      	stmia	r6!, {r0, r1, r2, r3}
            if (current_entry->type_guid[0] == 0x00
30017378:	f8bd 3140 	ldrh.w	r3, [r13, #320]	; 0x140
3001737c:	2b00      	cmp	r3, #0
3001737e:	f000 81f9 	beq.w	30017774 <ptdev_read_gpt+0x5e0>
            if (partition_entries) {
30017382:	9e17      	ldr	r6, [sp, #92]	; 0x5c
30017384:	2e00      	cmp	r6, #0
30017386:	f000 8136 	beq.w	300175f6 <ptdev_read_gpt+0x462>
                current_entry = &partition_entries[partition_count];
3001738a:	9a18      	ldr	r2, [sp, #96]	; 0x60
                memcpy(&(current_entry->type_guid), &(pt_entry.type_guid),
3001738c:	ac50      	add	r4, sp, #320	; 0x140
                current_entry = &partition_entries[partition_count];
3001738e:	eb02 05c2 	add.w	r5, r2, r2, lsl #3
                memcpy(&(current_entry->type_guid), &(pt_entry.type_guid),
30017392:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
                current_entry = &partition_entries[partition_count];
30017394:	012d      	lsls	r5, r5, #4
                memcpy(&(current_entry->type_guid), &(pt_entry.type_guid),
30017396:	5170      	str	r0, [r6, r5]
                current_entry = &partition_entries[partition_count];
30017398:	1970      	adds	r0, r6, r5
3001739a:	9d33      	ldr	r5, [sp, #204]	; 0xcc
                memcpy(&(current_entry->type_guid), &(pt_entry.type_guid),
3001739c:	60c3      	str	r3, [r0, #12]
3001739e:	9b16      	ldr	r3, [sp, #88]	; 0x58
300173a0:	fb05 f507 	mul.w	r5, r5, r7
                current_entry = &partition_entries[partition_count];
300173a4:	9008      	str	r0, [sp, #32]
                memcpy(&(current_entry->type_guid), &(pt_entry.type_guid),
300173a6:	6041      	str	r1, [r0, #4]
300173a8:	195c      	adds	r4, r3, r5
300173aa:	6082      	str	r2, [r0, #8]
                   &data[(j * partition_entry_size) + UNIQUE_GUID_OFFSET],
300173ac:	9a16      	ldr	r2, [sp, #88]	; 0x58
300173ae:	f105 0310 	add.w	r3, r5, #16
            memcpy(&(current_entry->unique_partition_guid),
300173b2:	9908      	ldr	r1, [sp, #32]
                   &data[(j * partition_entry_size) + UNIQUE_GUID_OFFSET],
300173b4:	4413      	add	r3, r2
            memcpy(&(current_entry->unique_partition_guid),
300173b6:	681d      	ldr	r5, [r3, #0]
300173b8:	6858      	ldr	r0, [r3, #4]
300173ba:	f8d3 c008 	ldr.w	r12, [r3, #8]
300173be:	68db      	ldr	r3, [r3, #12]
300173c0:	61cb      	str	r3, [r1, #28]
300173c2:	610d      	str	r5, [r1, #16]
300173c4:	6148      	str	r0, [r1, #20]
300173c6:	f8c1 c018 	str.w	r12, [r1, #24]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + FIRST_LBA_OFFSET]);
300173ca:	f894 8021 	ldrb.w	r8, [r4, #33]	; 0x21
300173ce:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
300173d2:	ea4f 6718 	mov.w	r7, r8, lsr #24
300173d6:	ea4f 4b10 	mov.w	r11, r0, lsr #16
300173da:	ea4f 2608 	mov.w	r6, r8, lsl #8
300173de:	f894 8023 	ldrb.w	r8, [r4, #35]	; 0x23
300173e2:	ea4f 4a00 	mov.w	r10, r0, lsl #16
300173e6:	ea4b 0307 	orr.w	r3, r11, r7
300173ea:	f04f 0b00 	mov.w	r11, #0
300173ee:	ea4a 0206 	orr.w	r2, r10, r6
300173f2:	ea4b 0703 	orr.w	r7, r11, r3
300173f6:	f894 a020 	ldrb.w	r10, [r4, #32]
300173fa:	ea4f 2118 	mov.w	r1, r8, lsr #8
300173fe:	f894 b024 	ldrb.w	r11, [r4, #36]	; 0x24
30017402:	ea4a 0602 	orr.w	r6, r10, r2
30017406:	f894 2025 	ldrb.w	r2, [r4, #37]	; 0x25
3001740a:	ea47 0901 	orr.w	r9, r7, r1
3001740e:	2100      	movs	r1, #0
30017410:	ea4f 6008 	mov.w	r0, r8, lsl #24
30017414:	f04f 0a00 	mov.w	r10, #0
30017418:	ea46 0800 	orr.w	r8, r6, r0
3001741c:	464e      	mov	r6, r9
3001741e:	f894 0026 	ldrb.w	r0, [r4, #38]	; 0x26
30017422:	ea48 050a 	orr.w	r5, r8, r10
30017426:	0403      	lsls	r3, r0, #16
30017428:	f894 0027 	ldrb.w	r0, [r4, #39]	; 0x27
3001742c:	e9cd 010a 	strd	r0, r1, [r13, #40]	; 0x28
30017430:	ea46 060b 	orr.w	r6, r6, r11
30017434:	4637      	mov	r7, r6
30017436:	ea4f 2902 	mov.w	r9, r2, lsl #8
3001743a:	ea45 000a 	orr.w	r0, r5, r10
3001743e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
30017440:	ea47 0109 	orr.w	r1, r7, r9
30017444:	4652      	mov	r2, r10
30017446:	4606      	mov	r6, r0
30017448:	460f      	mov	r7, r1
3001744a:	4316      	orrs	r6, r2
3001744c:	ea4f 6905 	mov.w	r9, r5, lsl #24
30017450:	431f      	orrs	r7, r3
30017452:	ea46 000a 	orr.w	r0, r6, r10
30017456:	4680      	mov	r8, r0
30017458:	ea47 0109 	orr.w	r1, r7, r9
3001745c:	4689      	mov	r9, r1
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
3001745e:	2700      	movs	r7, #0
            current_entry->first_lba =
30017460:	9d08      	ldr	r5, [sp, #32]
30017462:	e9c5 8908 	strd	r8, r9, [r5, #32]
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
30017466:	f894 002b 	ldrb.w	r0, [r4, #43]	; 0x2b
            current_entry->first_lba =
3001746a:	e9cd 8912 	strd	r8, r9, [r13, #72]	; 0x48
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
3001746e:	f894 8029 	ldrb.w	r8, [r4, #41]	; 0x29
30017472:	ea4f 6118 	mov.w	r1, r8, lsr #24
30017476:	f894 602a 	ldrb.w	r6, [r4, #42]	; 0x2a
3001747a:	0432      	lsls	r2, r6, #16
3001747c:	910b      	str	r1, [sp, #44]	; 0x2c
3001747e:	ea4f 2108 	mov.w	r1, r8, lsl #8
30017482:	0c33      	lsrs	r3, r6, #16
30017484:	f894 6028 	ldrb.w	r6, [r4, #40]	; 0x28
30017488:	910a      	str	r1, [sp, #40]	; 0x28
3001748a:	2100      	movs	r1, #0
3001748c:	e9cd 0110 	strd	r0, r1, [r13, #64]	; 0x40
30017490:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
30017494:	4310      	orrs	r0, r2
30017496:	ea40 0806 	orr.w	r8, r0, r6
3001749a:	9e10      	ldr	r6, [sp, #64]	; 0x40
3001749c:	4319      	orrs	r1, r3
3001749e:	4640      	mov	r0, r8
300174a0:	ea41 0907 	orr.w	r9, r1, r7
300174a4:	4649      	mov	r1, r9
300174a6:	f894 802d 	ldrb.w	r8, [r4, #45]	; 0x2d
300174aa:	0a33      	lsrs	r3, r6, #8
300174ac:	0632      	lsls	r2, r6, #24
300174ae:	4310      	orrs	r0, r2
300174b0:	4319      	orrs	r1, r3
300174b2:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
300174b6:	e9cd a30a 	strd	r10, r3, [r13, #40]	; 0x28
300174ba:	ea4f 2708 	mov.w	r7, r8, lsl #8
300174be:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
300174c2:	f894 802e 	ldrb.w	r8, [r4, #46]	; 0x2e
300174c6:	f8cd a028 	str.w	r10, [r13, #40]	; 0x28
300174ca:	4302      	orrs	r2, r0
300174cc:	4650      	mov	r0, r10
300174ce:	430b      	orrs	r3, r1
300174d0:	ea4f 4108 	mov.w	r1, r8, lsl #16
300174d4:	ea42 080a 	orr.w	r8, r2, r10
300174d8:	4646      	mov	r6, r8
300174da:	ea43 0907 	orr.w	r9, r3, r7
300174de:	f894 802f 	ldrb.w	r8, [r4, #47]	; 0x2f
300174e2:	4632      	mov	r2, r6
300174e4:	ea4f 6308 	mov.w	r3, r8, lsl #24
300174e8:	4302      	orrs	r2, r0
300174ea:	930b      	str	r3, [sp, #44]	; 0x2c
300174ec:	464b      	mov	r3, r9
            if ((current_entry->first_lba) < first_usable_lba
300174ee:	e9dd 8912 	ldrd	r8, r9, [r13, #72]	; 0x48
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
300174f2:	430b      	orrs	r3, r1
            if ((current_entry->first_lba) < first_usable_lba
300174f4:	e9dd 0138 	ldrd	r0, r1, [r13, #224]	; 0xe0
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
300174f8:	e9dd 670a 	ldrd	r6, r7, [r13, #40]	; 0x28
            if ((current_entry->first_lba) < first_usable_lba
300174fc:	4589      	cmp	r9, r1
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) + LAST_LBA_OFFSET]);
300174fe:	ea46 0602 	orr.w	r6, r6, r2
30017502:	ea47 0703 	orr.w	r7, r7, r3
            if ((current_entry->first_lba) < first_usable_lba
30017506:	bf08      	it	eq
30017508:	4580      	cmpeq	r8, r0
            current_entry->last_lba =
3001750a:	e9c5 670a 	strd	r6, r7, [r5, #40]	; 0x28
            if ((current_entry->first_lba) < first_usable_lba
3001750e:	d31d      	bcc.n	3001754c <ptdev_read_gpt+0x3b8>
                    ( device_capacity / block_size -
30017510:	e9dd 2314 	ldrd	r2, r3, [r13, #80]	; 0x50
30017514:	e9dd 011a 	ldrd	r0, r1, [r13, #104]	; 0x68
30017518:	f002 fc82 	bl	30019e20 <__aeabi_uldivmod>
    uint32_t blocks_for_entries =
3001751c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
3001751e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
30017522:	fbb3 f3f2 	udiv	r3, r3, r2
                      (blocks_for_entries + GPT_HEADER_BLOCKS + 1))
30017526:	3302      	adds	r3, #2
                    ( device_capacity / block_size -
30017528:	ebb0 0a03 	subs.w	r10, r0, r3
3001752c:	f161 0b00 	sbc.w	r11, r1, #0
                    || (current_entry->last_lba) >
30017530:	45bb      	cmp	r11, r7
30017532:	bf08      	it	eq
30017534:	45b2      	cmpeq	r10, r6
30017536:	bf34      	ite	cc
30017538:	2501      	movcc	r5, #1
3001753a:	2500      	movcs	r5, #0
                    || current_entry->first_lba >
3001753c:	454f      	cmp	r7, r9
3001753e:	bf08      	it	eq
30017540:	4546      	cmpeq	r6, r8
30017542:	bf38      	it	cc
30017544:	f045 0501 	orrcc.w	r5, r5, #1
30017548:	2d00      	cmp	r5, #0
3001754a:	d057      	beq.n	300175fc <ptdev_read_gpt+0x468>
                dprintf(CRITICAL, "Partition entry(%d), lba not valid\n", j);
3001754c:	990d      	ldr	r1, [sp, #52]	; 0x34
3001754e:	9826      	ldr	r0, [sp, #152]	; 0x98
30017550:	f7fe fb2e 	bl	30015bb0 <_printf>
        for (j = 0; j < entries_cnt_per_block && !valid_entry_finish; j++) {
30017554:	9b0d      	ldr	r3, [sp, #52]	; 0x34
30017556:	9a19      	ldr	r2, [sp, #100]	; 0x64
30017558:	3301      	adds	r3, #1
3001755a:	429a      	cmp	r2, r3
3001755c:	930d      	str	r3, [sp, #52]	; 0x34
3001755e:	f63f aeff 	bhi.w	30017360 <ptdev_read_gpt+0x1cc>
30017562:	2400      	movs	r4, #0
    for (i = 0; i < blocks_to_read; i++) {
30017564:	9b27      	ldr	r3, [sp, #156]	; 0x9c
30017566:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
30017568:	3301      	adds	r3, #1
3001756a:	4293      	cmp	r3, r2
3001756c:	9327      	str	r3, [sp, #156]	; 0x9c
3001756e:	f080 8156 	bcs.w	3001781e <ptdev_read_gpt+0x68a>
30017572:	9b21      	ldr	r3, [sp, #132]	; 0x84
30017574:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30017576:	4413      	add	r3, r2
30017578:	9321      	str	r3, [sp, #132]	; 0x84
        ASSERT(partition_count < NUM_PARTITIONS);
3001757a:	9b18      	ldr	r3, [sp, #96]	; 0x60
3001757c:	2b7f      	cmp	r3, #127	; 0x7f
3001757e:	f200 8161 	bhi.w	30017844 <ptdev_read_gpt+0x6b0>
30017582:	e9dd 673a 	ldrd	r6, r7, [r13, #232]	; 0xe8
30017586:	e6c7      	b.n	30017318 <ptdev_read_gpt+0x184>
        dprintf(CRITICAL, "GPT: Could not read primary gpt from boot device\n");
30017588:	f241 30bc 	movw	r0, #5052	; 0x13bc
3001758c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017590:	f7fe fb0e 	bl	30015bb0 <_printf>
        free(gpt_header_ptr);
30017594:	4620      	mov	r0, r4
30017596:	f7fd f8f9 	bl	3001478c <free>
}
3001759a:	4628      	mov	r0, r5
3001759c:	f50d 7d1b 	add.w	r13, r13, #620	; 0x26c
300175a0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                           parent_entry->first_lba + 1) * block_size;
300175a4:	9924      	ldr	r1, [sp, #144]	; 0x90
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175a6:	9e0e      	ldr	r6, [sp, #56]	; 0x38
                           parent_entry->first_lba + 1) * block_size;
300175a8:	e9d1 230a 	ldrd	r2, r3, [r1, #40]	; 0x28
        lba_offset = parent_entry->first_lba;
300175ac:	e9d1 8908 	ldrd	r8, r9, [r1, #32]
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175b0:	9920      	ldr	r1, [sp, #128]	; 0x80
                           parent_entry->first_lba + 1) * block_size;
300175b2:	f112 0a01 	adds.w	r10, r2, #1
        lba_offset = parent_entry->first_lba;
300175b6:	e9cd 891c 	strd	r8, r9, [r13, #112]	; 0x70
                           parent_entry->first_lba + 1) * block_size;
300175ba:	f143 0b00 	adc.w	r11, r3, #0
300175be:	ebba 0208 	subs.w	r2, r10, r8
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175c2:	e9d1 4502 	ldrd	r4, r5, [r1, #8]
                           parent_entry->first_lba + 1) * block_size;
300175c6:	eb6b 0309 	sbc.w	r3, r11, r9
        device_capacity = (parent_entry->last_lba -
300175ca:	fba2 ab06 	umull	r10, r11, r2, r6
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175ce:	fba6 0108 	umull	r0, r1, r6, r8
        device_capacity = (parent_entry->last_lba -
300175d2:	fb06 b303 	mla	r3, r6, r3, r11
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175d6:	fb06 1109 	mla	r1, r6, r9, r1
        device_capacity = (parent_entry->last_lba -
300175da:	e9cd ab1a 	strd	r10, r11, [r13, #104]	; 0x68
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175de:	1902      	adds	r2, r0, r4
        device_capacity = (parent_entry->last_lba -
300175e0:	931b      	str	r3, [sp, #108]	; 0x6c
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
300175e2:	eb41 0305 	adc.w	r3, r1, r5
300175e6:	e9cd 2322 	strd	r2, r3, [r13, #136]	; 0x88
300175ea:	e5f9      	b.n	300171e0 <ptdev_read_gpt+0x4c>
    partition_entries_offset += cur_gpt_offset;
300175ec:	e9cd 673a 	strd	r6, r7, [r13, #232]	; 0xe8
    blocks_to_read = round_up(max_partition_count,
300175f0:	2301      	movs	r3, #1
300175f2:	932a      	str	r3, [sp, #168]	; 0xa8
300175f4:	e677      	b.n	300172e6 <ptdev_read_gpt+0x152>
            current_entry = &pt_entry;
300175f6:	ab50      	add	r3, sp, #320	; 0x140
300175f8:	9308      	str	r3, [sp, #32]
300175fa:	e6d7      	b.n	300173ac <ptdev_read_gpt+0x218>
            current_entry->last_lba += lba_offset;
300175fc:	e9dd 231c 	ldrd	r2, r3, [r13, #112]	; 0x70
30017600:	eb12 0806 	adds.w	r8, r2, r6
30017604:	eb43 0907 	adc.w	r9, r3, r7
            current_entry->first_lba += lba_offset;
30017608:	e9dd 6712 	ldrd	r6, r7, [r13, #72]	; 0x48
3001760c:	18b6      	adds	r6, r6, r2
3001760e:	46b2      	mov	r10, r6
30017610:	415f      	adcs	r7, r3
30017612:	46bb      	mov	r11, r7
            current_entry->size = current_entry->last_lba - current_entry->first_lba +
30017614:	f118 0001 	adds.w	r0, r8, #1
            current_entry->first_lba += lba_offset;
30017618:	9a08      	ldr	r2, [sp, #32]
            current_entry->size = current_entry->last_lba - current_entry->first_lba +
3001761a:	f149 0100 	adc.w	r1, r9, #0
            current_entry->first_lba += lba_offset;
3001761e:	e9c2 ab08 	strd	r10, r11, [r2, #32]
            current_entry->size = current_entry->last_lba - current_entry->first_lba +
30017622:	1b80      	subs	r0, r0, r6
30017624:	4606      	mov	r6, r0
30017626:	eb61 0107 	sbc.w	r1, r1, r7
3001762a:	460f      	mov	r7, r1
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
3001762c:	ab3e      	add	r3, sp, #248	; 0xf8
            current_entry->last_lba += lba_offset;
3001762e:	e9c2 890a 	strd	r8, r9, [r2, #40]	; 0x28
            current_entry->size = current_entry->last_lba - current_entry->first_lba +
30017632:	e9c2 6722 	strd	r6, r7, [r2, #136]	; 0x88
                GET_LLWORD_FROM_BYTE(&data[(j * partition_entry_size) +
30017636:	2200      	movs	r2, #0
30017638:	f894 6031 	ldrb.w	r6, [r4, #49]	; 0x31
3001763c:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
30017640:	ea4f 2a06 	mov.w	r10, r6, lsl #8
30017644:	f894 1033 	ldrb.w	r1, [r4, #51]	; 0x33
30017648:	ea4f 4800 	mov.w	r8, r0, lsl #16
3001764c:	e9cd 120a 	strd	r1, r2, [r13, #40]	; 0x28
30017650:	ea4f 4910 	mov.w	r9, r0, lsr #16
30017654:	ea4a 0008 	orr.w	r0, r10, r8
30017658:	f894 8030 	ldrb.w	r8, [r4, #48]	; 0x30
3001765c:	ea4f 6b16 	mov.w	r11, r6, lsr #24
30017660:	ea40 0608 	orr.w	r6, r0, r8
30017664:	f894 8035 	ldrb.w	r8, [r4, #53]	; 0x35
30017668:	980a      	ldr	r0, [sp, #40]	; 0x28
3001766a:	ea4b 0109 	orr.w	r1, r11, r9
3001766e:	f04f 0900 	mov.w	r9, #0
30017672:	ea41 0709 	orr.w	r7, r1, r9
30017676:	ea4f 2b10 	mov.w	r11, r0, lsr #8
3001767a:	ea4f 6a00 	mov.w	r10, r0, lsl #24
3001767e:	ea47 020b 	orr.w	r2, r7, r11
30017682:	f894 7034 	ldrb.w	r7, [r4, #52]	; 0x34
30017686:	ea46 010a 	orr.w	r1, r6, r10
3001768a:	4608      	mov	r0, r1
3001768c:	ea47 0902 	orr.w	r9, r7, r2
30017690:	464f      	mov	r7, r9
30017692:	ea4f 2b08 	mov.w	r11, r8, lsl #8
30017696:	ea45 0800 	orr.w	r8, r5, r0
3001769a:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
3001769e:	ea47 070b 	orr.w	r7, r7, r11
300176a2:	ea4f 4900 	mov.w	r9, r0, lsl #16
300176a6:	f894 0037 	ldrb.w	r0, [r4, #55]	; 0x37
300176aa:	ea48 0605 	orr.w	r6, r8, r5
300176ae:	ea46 0105 	orr.w	r1, r6, r5
300176b2:	ea47 0209 	orr.w	r2, r7, r9
300176b6:	460e      	mov	r6, r1
300176b8:	ea4f 6b00 	mov.w	r11, r0, lsl #24
300176bc:	4617      	mov	r7, r2
300176be:	432e      	orrs	r6, r5
300176c0:	ea47 070b 	orr.w	r7, r7, r11
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
300176c4:	4618      	mov	r0, r3
300176c6:	f104 0138 	add.w	r1, r4, #56	; 0x38
            current_entry->attribute_flag =
300176ca:	9c08      	ldr	r4, [sp, #32]
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
300176cc:	2248      	movs	r2, #72	; 0x48
            current_entry->attribute_flag =
300176ce:	e9c4 670c 	strd	r6, r7, [r4, #48]	; 0x30
            memcpy(UTF16_name, &data[(j * partition_entry_size) +
300176d2:	f7fd e8c8 	blx	30014864 <memcpy>
300176d6:	f104 0237 	add.w	r2, r4, #55	; 0x37
300176da:	4603      	mov	r3, r0
                current_entry->name[n] = UTF16_name[n * 2];
300176dc:	f813 1015 	ldrb.w	r1, [r3, r5, lsl #1]
300176e0:	f802 1f01 	strb.w	r1, [r2, #1]!
            for (n = 0; n < MAX_GPT_NAME_SIZE / 2; n++) {
300176e4:	3501      	adds	r5, #1
300176e6:	2d24      	cmp	r5, #36	; 0x24
300176e8:	d1f8      	bne.n	300176dc <ptdev_read_gpt+0x548>
            if (parent_entry) {
300176ea:	9d24      	ldr	r5, [sp, #144]	; 0x90
300176ec:	b32d      	cbz	r5, 3001773a <ptdev_read_gpt+0x5a6>
                        current_entry->name);
300176ee:	9b08      	ldr	r3, [sp, #32]
                char name[MAX_GPT_NAME_SIZE * 2 + 1] = {0};
300176f0:	2291      	movs	r2, #145	; 0x91
300176f2:	2100      	movs	r1, #0
300176f4:	a874      	add	r0, sp, #464	; 0x1d0
                        current_entry->name);
300176f6:	f103 0438 	add.w	r4, r3, #56	; 0x38
                char name[MAX_GPT_NAME_SIZE * 2 + 1] = {0};
300176fa:	f7fd e93a 	blx	30014970 <memset>
                sprintf(name, "%s%s%s", parent_name, partition_separator,
300176fe:	f241 43dc 	movw	r3, #5340	; 0x14dc
30017702:	f241 41e0 	movw	r1, #5344	; 0x14e0
30017706:	f2c3 0302 	movt	r3, #12290	; 0x3002
3001770a:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001770e:	f105 0238 	add.w	r2, r5, #56	; 0x38
30017712:	9400      	str	r4, [sp, #0]
30017714:	a874      	add	r0, sp, #464	; 0x1d0
30017716:	f7fe f9eb 	bl	30015af0 <sprintf>
                if (strlen(name) >= MAX_GPT_NAME_SIZE)
3001771a:	a874      	add	r0, sp, #464	; 0x1d0
3001771c:	f7fe fb08 	bl	30015d30 <strlen>
30017720:	2847      	cmp	r0, #71	; 0x47
30017722:	d905      	bls.n	30017730 <ptdev_read_gpt+0x59c>
                    dprintf(CRITICAL, "parent or sub partiton name is too long.\n");
30017724:	f241 40e8 	movw	r0, #5352	; 0x14e8
30017728:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001772c:	f7fe fa40 	bl	30015bb0 <_printf>
                strncpy((char *)current_entry->name,
30017730:	4620      	mov	r0, r4
30017732:	a974      	add	r1, sp, #464	; 0x1d0
30017734:	2248      	movs	r2, #72	; 0x48
30017736:	f7fe fb07 	bl	30015d48 <strncpy>
            partition_count++;
3001773a:	9b18      	ldr	r3, [sp, #96]	; 0x60
            part_dev->count = partition_count;
3001773c:	9a20      	ldr	r2, [sp, #128]	; 0x80
            partition_count++;
3001773e:	3301      	adds	r3, #1
30017740:	9318      	str	r3, [sp, #96]	; 0x60
            part_dev->count = partition_count;
30017742:	6153      	str	r3, [r2, #20]
            if (!partition_entries
30017744:	9b17      	ldr	r3, [sp, #92]	; 0x5c
30017746:	2b00      	cmp	r3, #0
30017748:	f47f af04 	bne.w	30017554 <ptdev_read_gpt+0x3c0>
    return !memcmp(sub_part_guid, partition_entries->type_guid,
3001774c:	9908      	ldr	r1, [sp, #32]
3001774e:	2210      	movs	r2, #16
30017750:	982e      	ldr	r0, [sp, #184]	; 0xb8
30017752:	f7fe fa4f 	bl	30015bf4 <memcmp>
                    && ptdev_sub_part_exist(current_entry)) {
30017756:	2800      	cmp	r0, #0
30017758:	f47f aefc 	bne.w	30017554 <ptdev_read_gpt+0x3c0>
                if (ptdev_read_gpt(part_dev, current_entry, block_size)) {
3001775c:	9908      	ldr	r1, [sp, #32]
3001775e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30017760:	9820      	ldr	r0, [sp, #128]	; 0x80
30017762:	f7ff fd17 	bl	30017194 <ptdev_read_gpt>
30017766:	2800      	cmp	r0, #0
30017768:	f040 8186 	bne.w	30017a78 <ptdev_read_gpt+0x8e4>
                    partition_count = part_dev->count;
3001776c:	9b20      	ldr	r3, [sp, #128]	; 0x80
3001776e:	695b      	ldr	r3, [r3, #20]
30017770:	9318      	str	r3, [sp, #96]	; 0x60
30017772:	e6ef      	b.n	30017554 <ptdev_read_gpt+0x3c0>
                valid_entry_finish = true;
30017774:	9c29      	ldr	r4, [sp, #164]	; 0xa4
30017776:	e6f5      	b.n	30017564 <ptdev_read_gpt+0x3d0>
    uint8_t *entries_buffer = NULL;
30017778:	9516      	str	r5, [sp, #88]	; 0x58
        dprintf(CRITICAL, "GPT: (WARNING) Primary header invalid\n");
3001777a:	f241 30f0 	movw	r0, #5104	; 0x13f0
3001777e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017782:	f7fe fa15 	bl	30015bb0 <_printf>
        part_dev->count = partition_count_reset;
30017786:	9b20      	ldr	r3, [sp, #128]	; 0x80
        card_size_sec = (device_capacity) / block_size;
30017788:	e9dd 011a 	ldrd	r0, r1, [r13, #104]	; 0x68
        part_dev->count = partition_count_reset;
3001778c:	461a      	mov	r2, r3
3001778e:	9b28      	ldr	r3, [sp, #160]	; 0xa0
30017790:	6153      	str	r3, [r2, #20]
        card_size_sec = (device_capacity) / block_size;
30017792:	e9dd 2314 	ldrd	r2, r3, [r13, #80]	; 0x50
30017796:	f002 fb43 	bl	30019e20 <__aeabi_uldivmod>
        ASSERT (card_size_sec > 0);
3001779a:	ea50 0301 	orrs.w	r3, r0, r1
3001779e:	f000 8159 	beq.w	30017a54 <ptdev_read_gpt+0x8c0>
        ret = storage->read(storage, (backup_header_lba * block_size) + cur_gpt_offset,
300177a2:	e9dd 2314 	ldrd	r2, r3, [r13, #80]	; 0x50
        backup_header_lba = card_size_sec - 1;
300177a6:	f110 34ff 	adds.w	r4, r0, #4294967295	; 0xffffffff
        ret = storage->read(storage, (backup_header_lba * block_size) + cur_gpt_offset,
300177aa:	e9cd 2302 	strd	r2, r3, [r13, #8]
        backup_header_lba = card_size_sec - 1;
300177ae:	f141 35ff 	adc.w	r5, r1, #4294967295	; 0xffffffff
        ret = storage->read(storage, (backup_header_lba * block_size) + cur_gpt_offset,
300177b2:	990e      	ldr	r1, [sp, #56]	; 0x38
300177b4:	9f1e      	ldr	r7, [sp, #120]	; 0x78
300177b6:	9e1f      	ldr	r6, [sp, #124]	; 0x7c
300177b8:	4638      	mov	r0, r7
300177ba:	fba4 2301 	umull	r2, r3, r4, r1
300177be:	9600      	str	r6, [sp, #0]
300177c0:	fb01 3305 	mla	r3, r1, r5, r3
300177c4:	e9dd 4522 	ldrd	r4, r5, [r13, #136]	; 0x88
300177c8:	68b9      	ldr	r1, [r7, #8]
300177ca:	18a4      	adds	r4, r4, r2
300177cc:	4622      	mov	r2, r4
300177ce:	415d      	adcs	r5, r3
300177d0:	462b      	mov	r3, r5
300177d2:	4788      	blx	r1
        if (ret) {
300177d4:	4605      	mov	r5, r0
300177d6:	2800      	cmp	r0, #0
300177d8:	d04e      	beq.n	30017878 <ptdev_read_gpt+0x6e4>
            dprintf(CRITICAL,
300177da:	f241 4018 	movw	r0, #5144	; 0x1418
300177de:	f2c3 0002 	movt	r0, #12290	; 0x3002
300177e2:	f7fe f9e5 	bl	30015bb0 <_printf>
        free(gpt_header_ptr);
300177e6:	981f      	ldr	r0, [sp, #124]	; 0x7c
300177e8:	f7fc ffd0 	bl	3001478c <free>
    if (entries_buffer) {
300177ec:	9b16      	ldr	r3, [sp, #88]	; 0x58
300177ee:	2b00      	cmp	r3, #0
300177f0:	f43f aed3 	beq.w	3001759a <ptdev_read_gpt+0x406>
        free(entries_buffer);
300177f4:	9816      	ldr	r0, [sp, #88]	; 0x58
300177f6:	f7fc ffc9 	bl	3001478c <free>
}
300177fa:	4628      	mov	r0, r5
300177fc:	f50d 7d1b 	add.w	r13, r13, #620	; 0x26c
30017800:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (i = 0; i < blocks_to_read; i++) {
30017804:	9b27      	ldr	r3, [sp, #156]	; 0x9c
30017806:	9a2a      	ldr	r2, [sp, #168]	; 0xa8
30017808:	3301      	adds	r3, #1
3001780a:	429a      	cmp	r2, r3
3001780c:	9327      	str	r3, [sp, #156]	; 0x9c
3001780e:	d906      	bls.n	3001781e <ptdev_read_gpt+0x68a>
30017810:	9b21      	ldr	r3, [sp, #132]	; 0x84
30017812:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30017814:	4413      	add	r3, r2
30017816:	9321      	str	r3, [sp, #132]	; 0x84
30017818:	e6b3      	b.n	30017582 <ptdev_read_gpt+0x3ee>
    crc_val = 0;
3001781a:	9b2a      	ldr	r3, [sp, #168]	; 0xa8
3001781c:	9325      	str	r3, [sp, #148]	; 0x94
    if (crc_val != crc_entries) {
3001781e:	9a30      	ldr	r2, [sp, #192]	; 0xc0
30017820:	9925      	ldr	r1, [sp, #148]	; 0x94
30017822:	428a      	cmp	r2, r1
30017824:	d053      	beq.n	300178ce <ptdev_read_gpt+0x73a>
        dprintf(CRITICAL,
30017826:	f241 5030 	movw	r0, #5424	; 0x1530
3001782a:	2501      	movs	r5, #1
3001782c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017830:	f7fe f9be 	bl	30015bb0 <_printf>
        if (!re_parse_gpt) {
30017834:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
30017836:	2b00      	cmp	r3, #0
30017838:	f000 80ef 	beq.w	30017a1a <ptdev_read_gpt+0x886>
        free(gpt_header_ptr);
3001783c:	981f      	ldr	r0, [sp, #124]	; 0x7c
3001783e:	f7fc ffa5 	bl	3001478c <free>
30017842:	e7d7      	b.n	300177f4 <ptdev_read_gpt+0x660>
        ASSERT(partition_count < NUM_PARTITIONS);
30017844:	f24c 63b8 	movw	r3, #50872	; 0xc6b8
30017848:	f641 12c0 	movw	r2, #6592	; 0x19c0
3001784c:	f24a 011c 	movw	r1, #40988	; 0xa01c
30017850:	f2c3 0301 	movt	r3, #12289	; 0x3001
30017854:	982b      	ldr	r0, [sp, #172]	; 0xac
30017856:	f2c3 0202 	movt	r2, #12290	; 0x3002
3001785a:	9300      	str	r3, [sp, #0]
3001785c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30017860:	f240 333e 	movw	r3, #830	; 0x33e
30017864:	f7fc fcd6 	bl	30014214 <_panic>
            dprintf(CRITICAL, "GPT: read partition entries fail\n");
30017868:	f241 4094 	movw	r0, #5268	; 0x1494
3001786c:	4645      	mov	r5, r8
3001786e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017872:	f7fe f99d 	bl	30015bb0 <_printf>
            goto end;
30017876:	e7e1      	b.n	3001783c <ptdev_read_gpt+0x6a8>
        ret = ptdev_parse_gpt_header(part_dev, data, &first_usable_lba,
30017878:	9a20      	ldr	r2, [sp, #128]	; 0x80
3001787a:	a930      	add	r1, sp, #192	; 0xc0
3001787c:	9d24      	ldr	r5, [sp, #144]	; 0x90
3001787e:	2401      	movs	r4, #1
30017880:	ab38      	add	r3, sp, #224	; 0xe0
30017882:	6810      	ldr	r0, [r2, #0]
30017884:	9503      	str	r5, [sp, #12]
30017886:	ad32      	add	r5, sp, #200	; 0xc8
30017888:	9106      	str	r1, [sp, #24]
3001788a:	a93a      	add	r1, sp, #232	; 0xe8
3001788c:	9502      	str	r5, [sp, #8]
3001788e:	ad31      	add	r5, sp, #196	; 0xc4
30017890:	9105      	str	r1, [sp, #20]
30017892:	9501      	str	r5, [sp, #4]
30017894:	ad33      	add	r5, sp, #204	; 0xcc
30017896:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
30017898:	9500      	str	r5, [sp, #0]
3001789a:	992c      	ldr	r1, [sp, #176]	; 0xb0
3001789c:	9407      	str	r4, [sp, #28]
3001789e:	9404      	str	r4, [sp, #16]
300178a0:	f7fe ff94 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
        if (ret) {
300178a4:	4605      	mov	r5, r0
300178a6:	2800      	cmp	r0, #0
300178a8:	f040 80cd 	bne.w	30017a46 <ptdev_read_gpt+0x8b2>
    if (!entries_buffer)
300178ac:	9b16      	ldr	r3, [sp, #88]	; 0x58
        re_parse_gpt = true;
300178ae:	942d      	str	r4, [sp, #180]	; 0xb4
    if (!entries_buffer)
300178b0:	2b00      	cmp	r3, #0
300178b2:	f47f acda 	bne.w	3001726a <ptdev_read_gpt+0xd6>
300178b6:	e4d0      	b.n	3001725a <ptdev_read_gpt+0xc6>
        dprintf(CRITICAL, "GPT: Allocate memory fail\n");
300178b8:	f241 4078 	movw	r0, #5240	; 0x1478
        free(gpt_header_ptr);
300178bc:	2501      	movs	r5, #1
        dprintf(CRITICAL, "GPT: Allocate memory fail\n");
300178be:	f2c3 0002 	movt	r0, #12290	; 0x3002
300178c2:	f7fe f975 	bl	30015bb0 <_printf>
        free(gpt_header_ptr);
300178c6:	981f      	ldr	r0, [sp, #124]	; 0x7c
300178c8:	f7fc ff60 	bl	3001478c <free>
300178cc:	e665      	b.n	3001759a <ptdev_read_gpt+0x406>
    if (re_parse_gpt) {
300178ce:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
300178d0:	2b00      	cmp	r3, #0
300178d2:	f040 8085 	bne.w	300179e0 <ptdev_read_gpt+0x84c>
    if (!part_dev || !part_dev->storage) {
300178d6:	9b20      	ldr	r3, [sp, #128]	; 0x80
300178d8:	f8d3 8000 	ldr.w	r8, [r3]
300178dc:	f1b8 0f00 	cmp.w	r8, #0
300178e0:	f000 815d 	beq.w	30017b9e <ptdev_read_gpt+0xa0a>
    block_size = storage->get_block_size(storage);
300178e4:	f8d8 3020 	ldr.w	r3, [r8, #32]
300178e8:	4640      	mov	r0, r8
300178ea:	4798      	blx	r3
    if (!parent_entry) {
300178ec:	9d24      	ldr	r5, [sp, #144]	; 0x90
    block_size = storage->get_block_size(storage);
300178ee:	4604      	mov	r4, r0
    if (!parent_entry) {
300178f0:	2d00      	cmp	r5, #0
300178f2:	f040 8168 	bne.w	30017bc6 <ptdev_read_gpt+0xa32>
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
300178f6:	f8d8 3018 	ldr.w	r3, [r8, #24]
300178fa:	4640      	mov	r0, r8
300178fc:	4798      	blx	r3
300178fe:	9b20      	ldr	r3, [sp, #128]	; 0x80
30017900:	950d      	str	r5, [sp, #52]	; 0x34
30017902:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
30017906:	e9cd 2308 	strd	r2, r3, [r13, #32]
3001790a:	1a82      	subs	r2, r0, r2
3001790c:	4610      	mov	r0, r2
3001790e:	eb61 0303 	sbc.w	r3, r1, r3
30017912:	4619      	mov	r1, r3
    card_size_sec = (device_capacity) / block_size;
30017914:	2300      	movs	r3, #0
30017916:	4622      	mov	r2, r4
30017918:	f002 fa82 	bl	30019e20 <__aeabi_uldivmod>
3001791c:	4606      	mov	r6, r0
3001791e:	460f      	mov	r7, r1
    ASSERT (card_size_sec > 0);
30017920:	ea56 0307 	orrs.w	r3, r6, r7
30017924:	f000 81ba 	beq.w	30017c9c <ptdev_read_gpt+0xb08>
    header_buf = memalign(block_size, block_size);
30017928:	4621      	mov	r1, r4
3001792a:	4620      	mov	r0, r4
3001792c:	f7fc fef2 	bl	30014714 <memalign>
    entries_buf = memalign(block_size, block_size);
30017930:	4621      	mov	r1, r4
    header_buf = memalign(block_size, block_size);
30017932:	4682      	mov	r10, r0
    entries_buf = memalign(block_size, block_size);
30017934:	4620      	mov	r0, r4
30017936:	f7fc feed 	bl	30014714 <memalign>
    if (!header_buf || !entries_buf) {
3001793a:	4681      	mov	r9, r0
3001793c:	2800      	cmp	r0, #0
3001793e:	bf18      	it	ne
30017940:	f1ba 0f00 	cmpne.w	r10, #0
30017944:	f000 8197 	beq.w	30017c76 <ptdev_read_gpt+0xae2>
    ptn_src_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30017948:	9d0d      	ldr	r5, [sp, #52]	; 0x34
3001794a:	f116 32ff 	adds.w	r2, r6, #4294967295	; 0xffffffff
3001794e:	4629      	mov	r1, r5
30017950:	f147 33ff 	adc.w	r3, r7, #4294967295	; 0xffffffff
    ret = storage->read(storage, ptn_src_header, header_buf, block_size);
30017954:	9503      	str	r5, [sp, #12]
30017956:	4640      	mov	r0, r8
    ptn_src_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30017958:	fb02 f101 	mul.w	r1, r2, r1
    ret = storage->read(storage, ptn_src_header, header_buf, block_size);
3001795c:	e9dd 5608 	ldrd	r5, r6, [r13, #32]
    ptn_src_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
30017960:	fb04 1103 	mla	r1, r4, r3, r1
30017964:	fba2 2304 	umull	r2, r3, r2, r4
    ret = storage->read(storage, ptn_src_header, header_buf, block_size);
30017968:	9402      	str	r4, [sp, #8]
    ptn_src_header = (card_size_sec - 1) * block_size + cur_gpt_offset;
3001796a:	440b      	add	r3, r1
    ret = storage->read(storage, ptn_src_header, header_buf, block_size);
3001796c:	f8cd a000 	str.w	r10, [r13]
30017970:	18ad      	adds	r5, r5, r2
30017972:	f8d8 1008 	ldr.w	r1, [r8, #8]
30017976:	415e      	adcs	r6, r3
30017978:	462a      	mov	r2, r5
3001797a:	4633      	mov	r3, r6
3001797c:	4788      	blx	r1
    if (ret) {
3001797e:	2800      	cmp	r0, #0
30017980:	d07e      	beq.n	30017a80 <ptdev_read_gpt+0x8ec>
        ERROR("fail to read src gpt header!\n");
30017982:	f241 2100 	movw	r1, #4608	; 0x1200
30017986:	f641 2030 	movw	r0, #6704	; 0x1a30
3001798a:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001798e:	f240 227d 	movw	r2, #637	; 0x27d
30017992:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017996:	f7fe f90b 	bl	30015bb0 <_printf>
        free(header_buf);
3001799a:	4650      	mov	r0, r10
3001799c:	f7fc fef6 	bl	3001478c <free>
        free(entries_buf);
300179a0:	4648      	mov	r0, r9
300179a2:	f7fc fef3 	bl	3001478c <free>
            dprintf(ALWAYS, "secnodary gpt error!\n");
300179a6:	f241 604c 	movw	r0, #5708	; 0x164c
300179aa:	f2c3 0002 	movt	r0, #12290	; 0x3002
300179ae:	f7fe f8ff 	bl	30015bb0 <_printf>
            if (restore_gpt(part_dev, PRI2SEC, parent_entry)) {
300179b2:	9a24      	ldr	r2, [sp, #144]	; 0x90
300179b4:	9820      	ldr	r0, [sp, #128]	; 0x80
300179b6:	2100      	movs	r1, #0
300179b8:	f7ff f840 	bl	30016a3c <restore_gpt>
300179bc:	4605      	mov	r5, r0
300179be:	2800      	cmp	r0, #0
300179c0:	f000 80fa 	beq.w	30017bb8 <ptdev_read_gpt+0xa24>
                ERROR("fail to restore secondary gpt!\n");
300179c4:	f241 2114 	movw	r1, #4628	; 0x1214
300179c8:	f241 6064 	movw	r0, #5732	; 0x1664
300179cc:	f240 32d3 	movw	r2, #979	; 0x3d3
300179d0:	f2c3 0102 	movt	r1, #12290	; 0x3002
300179d4:	2500      	movs	r5, #0
300179d6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300179da:	f7fe f8e9 	bl	30015bb0 <_printf>
300179de:	e72d      	b.n	3001783c <ptdev_read_gpt+0x6a8>
        dprintf(ALWAYS, "restore primary gpt!\n");
300179e0:	f241 50b4 	movw	r0, #5556	; 0x15b4
300179e4:	f2c3 0002 	movt	r0, #12290	; 0x3002
300179e8:	f7fe f8e2 	bl	30015bb0 <_printf>
        ret = restore_gpt(part_dev, SEC2PRI, parent_entry);
300179ec:	9a24      	ldr	r2, [sp, #144]	; 0x90
300179ee:	9820      	ldr	r0, [sp, #128]	; 0x80
300179f0:	2101      	movs	r1, #1
300179f2:	f7ff f823 	bl	30016a3c <restore_gpt>
        if (ret)
300179f6:	4605      	mov	r5, r0
300179f8:	2800      	cmp	r0, #0
300179fa:	f43f af1f 	beq.w	3001783c <ptdev_read_gpt+0x6a8>
            ERROR("fail to restore primary gpt!\n");
300179fe:	f241 2114 	movw	r1, #4628	; 0x1214
30017a02:	f241 50cc 	movw	r0, #5580	; 0x15cc
30017a06:	f240 32cb 	movw	r2, #971	; 0x3cb
30017a0a:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017a0e:	2500      	movs	r5, #0
30017a10:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017a14:	f7fe f8cc 	bl	30015bb0 <_printf>
30017a18:	e710      	b.n	3001783c <ptdev_read_gpt+0x6a8>
            ERROR("re-parse gpt from secondary gpt!\n");
30017a1a:	f241 2114 	movw	r1, #4628	; 0x1214
30017a1e:	f241 507c 	movw	r0, #5500	; 0x157c
30017a22:	f240 32ba 	movw	r2, #954	; 0x3ba
30017a26:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017a2a:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017a2e:	f7fe f8bf 	bl	30015bb0 <_printf>
            goto re_parse_gpt;
30017a32:	e6a8      	b.n	30017786 <ptdev_read_gpt+0x5f2>
        dprintf(CRITICAL, "Failed to Allocate memory to read partition table\n");
30017a34:	f241 3088 	movw	r0, #5000	; 0x1388
30017a38:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
30017a3c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017a40:	f7fe f8b6 	bl	30015bb0 <_printf>
30017a44:	e5a9      	b.n	3001759a <ptdev_read_gpt+0x406>
            dprintf(CRITICAL, "GPT: Primary and backup signatures invalid\n");
30017a46:	f241 404c 	movw	r0, #5196	; 0x144c
30017a4a:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017a4e:	f7fe f8af 	bl	30015bb0 <_printf>
            goto end;
30017a52:	e6c8      	b.n	300177e6 <ptdev_read_gpt+0x652>
        ASSERT (card_size_sec > 0);
30017a54:	f641 13f0 	movw	r3, #6640	; 0x19f0
30017a58:	f641 12c0 	movw	r2, #6592	; 0x19c0
30017a5c:	f24a 011c 	movw	r1, #40988	; 0xa01c
30017a60:	f2c3 0302 	movt	r3, #12290	; 0x3002
30017a64:	982b      	ldr	r0, [sp, #172]	; 0xac
30017a66:	f2c3 0202 	movt	r2, #12290	; 0x3002
30017a6a:	9300      	str	r3, [sp, #0]
30017a6c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30017a70:	f240 3313 	movw	r3, #787	; 0x313
30017a74:	f7fc fbce 	bl	30014214 <_panic>
                    dprintf(CRITICAL, "parse sub partition fail!\n");
30017a78:	982f      	ldr	r0, [sp, #188]	; 0xbc
30017a7a:	f7fe f899 	bl	30015bb0 <_printf>
30017a7e:	e569      	b.n	30017554 <ptdev_read_gpt+0x3c0>
    ret = ptdev_parse_gpt_header(part_dev, header_buf, &first_usable_lba,
30017a80:	9b20      	ldr	r3, [sp, #128]	; 0x80
30017a82:	2501      	movs	r5, #1
30017a84:	f50d 7ee8 	add.w	r14, r13, #464	; 0x1d0
30017a88:	f10d 0cd8 	add.w	r12, r13, #216	; 0xd8
30017a8c:	aa35      	add	r2, sp, #212	; 0xd4
30017a8e:	af34      	add	r7, sp, #208	; 0xd0
30017a90:	6818      	ldr	r0, [r3, #0]
30017a92:	ae37      	add	r6, sp, #220	; 0xdc
30017a94:	9b24      	ldr	r3, [sp, #144]	; 0x90
30017a96:	9303      	str	r3, [sp, #12]
30017a98:	ab3c      	add	r3, sp, #240	; 0xf0
30017a9a:	e9cd e205 	strd	r14, r2, [r13, #20]
30017a9e:	4652      	mov	r2, r10
30017aa0:	992c      	ldr	r1, [sp, #176]	; 0xb0
30017aa2:	9507      	str	r5, [sp, #28]
30017aa4:	9504      	str	r5, [sp, #16]
30017aa6:	e9cd c701 	strd	r12, r7, [r13, #4]
30017aaa:	9600      	str	r6, [sp, #0]
30017aac:	f7fe fe8e 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
    if (ret) {
30017ab0:	4683      	mov	r11, r0
30017ab2:	2800      	cmp	r0, #0
30017ab4:	f040 80d2 	bne.w	30017c5c <ptdev_read_gpt+0xac8>
    entries_cnt_per_block = block_size / partition_entry_size;
30017ab8:	6831      	ldr	r1, [r6, #0]
30017aba:	ab74      	add	r3, sp, #464	; 0x1d0
    blocks_to_read = round_up(max_partition_count,
30017abc:	683e      	ldr	r6, [r7, #0]
30017abe:	4630      	mov	r0, r6
    entries_cnt_per_block = block_size / partition_entry_size;
30017ac0:	fbb4 fcf1 	udiv	r12, r4, r1
30017ac4:	e9d3 2300 	ldrd	r2, r3, [r3]
    blocks_to_read = round_up(max_partition_count,
30017ac8:	2100      	movs	r1, #0
30017aca:	e9dd 6708 	ldrd	r6, r7, [r13, #32]
    if (aligned == 0 || size < aligned)
30017ace:	e9cd 0108 	strd	r0, r1, [r13, #32]
30017ad2:	18b6      	adds	r6, r6, r2
30017ad4:	415f      	adcs	r7, r3
30017ad6:	460b      	mov	r3, r1
30017ad8:	e9cd 670a 	strd	r6, r7, [r13, #40]	; 0x28
30017adc:	2700      	movs	r7, #0
30017ade:	4666      	mov	r6, r12
30017ae0:	42b9      	cmp	r1, r7
30017ae2:	bf08      	it	eq
30017ae4:	4560      	cmpeq	r0, r12
30017ae6:	bf34      	ite	cc
30017ae8:	2301      	movcc	r3, #1
30017aea:	2300      	movcs	r3, #0
30017aec:	e9cd 670e 	strd	r6, r7, [r13, #56]	; 0x38
30017af0:	f1bc 0f00 	cmp.w	r12, #0
30017af4:	bf14      	ite	ne
30017af6:	4619      	movne	r1, r3
30017af8:	2101      	moveq	r1, #1
30017afa:	2900      	cmp	r1, #0
30017afc:	f040 8083 	bne.w	30017c06 <ptdev_read_gpt+0xa72>
    mod = size % aligned;
30017b00:	4662      	mov	r2, r12
30017b02:	463b      	mov	r3, r7
30017b04:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30017b08:	f002 f98a 	bl	30019e20 <__aeabi_uldivmod>
    size += mod ? aligned - mod : 0;
30017b0c:	ea52 0103 	orrs.w	r1, r2, r3
30017b10:	d008      	beq.n	30017b24 <ptdev_read_gpt+0x990>
30017b12:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30017b16:	1980      	adds	r0, r0, r6
30017b18:	4179      	adcs	r1, r7
30017b1a:	1a86      	subs	r6, r0, r2
30017b1c:	eb61 0703 	sbc.w	r7, r1, r3
30017b20:	e9cd 6708 	strd	r6, r7, [r13, #32]
                              entries_cnt_per_block) / entries_cnt_per_block;
30017b24:	e9dd 230e 	ldrd	r2, r3, [r13, #56]	; 0x38
30017b28:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30017b2c:	f002 f978 	bl	30019e20 <__aeabi_uldivmod>
    partition_entries_offset += cur_gpt_offset;
30017b30:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30017b34:	a974      	add	r1, sp, #464	; 0x1d0
30017b36:	e9c1 2300 	strd	r2, r3, [r1]
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30017b3a:	4605      	mov	r5, r0
30017b3c:	2800      	cmp	r0, #0
30017b3e:	d069      	beq.n	30017c14 <ptdev_read_gpt+0xa80>
    blocks_to_read = round_up(max_partition_count,
30017b40:	2600      	movs	r6, #0
30017b42:	4637      	mov	r7, r6
30017b44:	e00e      	b.n	30017b64 <ptdev_read_gpt+0x9d0>
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30017b46:	4658      	mov	r0, r11
30017b48:	4622      	mov	r2, r4
30017b4a:	4649      	mov	r1, r9
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30017b4c:	3601      	adds	r6, #1
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30017b4e:	f7fb fa03 	bl	30012f58 <crc32>
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30017b52:	42ae      	cmp	r6, r5
30017b54:	4427      	add	r7, r4
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30017b56:	4683      	mov	r11, r0
    for (uint32_t i = 0; i < blocks_to_read; i++) {
30017b58:	d25b      	bcs.n	30017c12 <ptdev_read_gpt+0xa7e>
30017b5a:	ab74      	add	r3, sp, #464	; 0x1d0
30017b5c:	e9d3 2300 	ldrd	r2, r3, [r3]
30017b60:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
        ret = storage->read(storage, partition_entries_offset + (i * block_size),
30017b64:	9b0d      	ldr	r3, [sp, #52]	; 0x34
30017b66:	4640      	mov	r0, r8
30017b68:	9303      	str	r3, [sp, #12]
30017b6a:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30017b6e:	9402      	str	r4, [sp, #8]
30017b70:	f8cd 9000 	str.w	r9, [r13]
30017b74:	19d2      	adds	r2, r2, r7
30017b76:	f8d8 1008 	ldr.w	r1, [r8, #8]
30017b7a:	f143 0300 	adc.w	r3, r3, #0
30017b7e:	4788      	blx	r1
        if (ret) {
30017b80:	2800      	cmp	r0, #0
30017b82:	d0e0      	beq.n	30017b46 <ptdev_read_gpt+0x9b2>
            ERROR("fail to read partition entries\n");
30017b84:	f241 2100 	movw	r1, #4608	; 0x1200
30017b88:	f641 20c4 	movw	r0, #6852	; 0x1ac4
30017b8c:	f240 2299 	movw	r2, #665	; 0x299
30017b90:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017b94:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017b98:	f7fe f80a 	bl	30015bb0 <_printf>
30017b9c:	e6fd      	b.n	3001799a <ptdev_read_gpt+0x806>
        ERROR("partition device error!\n");
30017b9e:	f241 2100 	movw	r1, #4608	; 0x1200
30017ba2:	f641 1094 	movw	r0, #6548	; 0x1994
30017ba6:	f240 2259 	movw	r2, #601	; 0x259
30017baa:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017bae:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017bb2:	f7fd fffd 	bl	30015bb0 <_printf>
30017bb6:	e6f6      	b.n	300179a6 <ptdev_read_gpt+0x812>
                dprintf(ALWAYS, "restore secondary gpt successfully!\n");
30017bb8:	f241 6098 	movw	r0, #5784	; 0x1698
30017bbc:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017bc0:	f7fd fff6 	bl	30015bb0 <_printf>
30017bc4:	e63a      	b.n	3001783c <ptdev_read_gpt+0x6a8>
                           parent_entry->first_lba + 1) * block_size;
30017bc6:	9924      	ldr	r1, [sp, #144]	; 0x90
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30017bc8:	982d      	ldr	r0, [sp, #180]	; 0xb4
30017bca:	900d      	str	r0, [sp, #52]	; 0x34
                           parent_entry->first_lba + 1) * block_size;
30017bcc:	e9d1 230a 	ldrd	r2, r3, [r1, #40]	; 0x28
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30017bd0:	e9d1 ab08 	ldrd	r10, r11, [r1, #32]
                           parent_entry->first_lba + 1) * block_size;
30017bd4:	1c50      	adds	r0, r2, #1
30017bd6:	f143 0100 	adc.w	r1, r3, #0
30017bda:	ebb0 020a 	subs.w	r2, r0, r10
30017bde:	eb61 030b 	sbc.w	r3, r1, r11
        device_capacity = (parent_entry->last_lba -
30017be2:	fba2 0104 	umull	r0, r1, r2, r4
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30017be6:	fbaa 6704 	umull	r6, r7, r10, r4
        device_capacity = (parent_entry->last_lba -
30017bea:	fb04 1103 	mla	r1, r4, r3, r1
        cur_gpt_offset = parent_entry->first_lba * block_size + part_dev->gpt_offset;
30017bee:	9b20      	ldr	r3, [sp, #128]	; 0x80
30017bf0:	fb04 770b 	mla	r7, r4, r11, r7
30017bf4:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
30017bf8:	eb16 0902 	adds.w	r9, r6, r2
30017bfc:	eb47 0a03 	adc.w	r10, r7, r3
30017c00:	e9cd 9a08 	strd	r9, r10, [r13, #32]
30017c04:	e686      	b.n	30017914 <ptdev_read_gpt+0x780>
    partition_entries_offset += cur_gpt_offset;
30017c06:	e9dd 230a 	ldrd	r2, r3, [r13, #40]	; 0x28
30017c0a:	a974      	add	r1, sp, #464	; 0x1d0
30017c0c:	e9c1 2300 	strd	r2, r3, [r1]
30017c10:	e796      	b.n	30017b40 <ptdev_read_gpt+0x9ac>
        crc32_val = crc32(crc32_val, entries_buf, block_size);
30017c12:	4605      	mov	r5, r0
    if (crc_entries != crc32_val) {
30017c14:	9b35      	ldr	r3, [sp, #212]	; 0xd4
30017c16:	429d      	cmp	r5, r3
30017c18:	d012      	beq.n	30017c40 <ptdev_read_gpt+0xaac>
        ERROR("fail to check partition entries crc32\n");
30017c1a:	f241 2100 	movw	r1, #4608	; 0x1200
30017c1e:	f641 3030 	movw	r0, #6960	; 0x1b30
30017c22:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017c26:	f240 22a2 	movw	r2, #674	; 0x2a2
30017c2a:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017c2e:	f7fd ffbf 	bl	30015bb0 <_printf>
        free(header_buf);
30017c32:	4650      	mov	r0, r10
30017c34:	f7fc fdaa 	bl	3001478c <free>
        free(entries_buf);
30017c38:	4648      	mov	r0, r9
30017c3a:	f7fc fda7 	bl	3001478c <free>
30017c3e:	e6b2      	b.n	300179a6 <ptdev_read_gpt+0x812>
        free(header_buf);
30017c40:	4650      	mov	r0, r10
            dprintf(ALWAYS, "check secondary gpt ok!\n");
30017c42:	2500      	movs	r5, #0
        free(header_buf);
30017c44:	f7fc fda2 	bl	3001478c <free>
        free(entries_buf);
30017c48:	4648      	mov	r0, r9
30017c4a:	f7fc fd9f 	bl	3001478c <free>
            dprintf(ALWAYS, "check secondary gpt ok!\n");
30017c4e:	f241 6030 	movw	r0, #5680	; 0x1630
30017c52:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017c56:	f7fd ffab 	bl	30015bb0 <_printf>
30017c5a:	e5ef      	b.n	3001783c <ptdev_read_gpt+0x6a8>
        ERROR("fail to parse src gpt header!\n");
30017c5c:	f241 2100 	movw	r1, #4608	; 0x1200
30017c60:	f641 2064 	movw	r0, #6756	; 0x1a64
30017c64:	f44f 7222 	mov.w	r2, #648	; 0x288
30017c68:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017c6c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017c70:	f7fd ff9e 	bl	30015bb0 <_printf>
30017c74:	e691      	b.n	3001799a <ptdev_read_gpt+0x806>
        ERROR("fail to allocate memory!\n");
30017c76:	f241 2100 	movw	r1, #4608	; 0x1200
30017c7a:	f241 6000 	movw	r0, #5632	; 0x1600
30017c7e:	f2c3 0102 	movt	r1, #12290	; 0x3002
30017c82:	f44f 721d 	mov.w	r2, #628	; 0x274
30017c86:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017c8a:	f7fd ff91 	bl	30015bb0 <_printf>
    if (header_buf)
30017c8e:	f1ba 0f00 	cmp.w	r10, #0
30017c92:	d115      	bne.n	30017cc0 <ptdev_read_gpt+0xb2c>
    if (entries_buf)
30017c94:	f1b9 0f00 	cmp.w	r9, #0
30017c98:	d1ce      	bne.n	30017c38 <ptdev_read_gpt+0xaa4>
30017c9a:	e684      	b.n	300179a6 <ptdev_read_gpt+0x812>
    ASSERT (card_size_sec > 0);
30017c9c:	f641 13f0 	movw	r3, #6640	; 0x19f0
30017ca0:	f641 12c0 	movw	r2, #6592	; 0x19c0
30017ca4:	f24a 011c 	movw	r1, #40988	; 0xa01c
30017ca8:	f2c3 0302 	movt	r3, #12290	; 0x3002
30017cac:	982b      	ldr	r0, [sp, #172]	; 0xac
30017cae:	f2c3 0202 	movt	r2, #12290	; 0x3002
30017cb2:	9300      	str	r3, [sp, #0]
30017cb4:	f2c3 0101 	movt	r1, #12289	; 0x3001
30017cb8:	f240 236e 	movw	r3, #622	; 0x26e
30017cbc:	f7fc faaa 	bl	30014214 <_panic>
        free(header_buf);
30017cc0:	4650      	mov	r0, r10
30017cc2:	f7fc fd63 	bl	3001478c <free>
    if (entries_buf)
30017cc6:	f1b9 0f00 	cmp.w	r9, #0
30017cca:	d1b5      	bne.n	30017c38 <ptdev_read_gpt+0xaa4>
30017ccc:	e66b      	b.n	300179a6 <ptdev_read_gpt+0x812>
30017cce:	bf00      	nop

30017cd0 <ptdev_get_partition_count>:
    if (!part_dev) {
30017cd0:	b108      	cbz	r0, 30017cd6 <ptdev_get_partition_count+0x6>
    return part_dev->count;
30017cd2:	6940      	ldr	r0, [r0, #20]
}
30017cd4:	4770      	bx	r14
{
30017cd6:	b510      	push	{r4, r14}
30017cd8:	4604      	mov	r4, r0
        dprintf(CRITICAL, "Invalid partition dev\n");
30017cda:	f241 2084 	movw	r0, #4740	; 0x1284
30017cde:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017ce2:	f7fd ff65 	bl	30015bb0 <_printf>
        return 0;
30017ce6:	4620      	mov	r0, r4
}
30017ce8:	bd10      	pop	{r4, r15}
30017cea:	bf00      	nop

30017cec <ptdev_get_partition_entries>:
    if (!part_dev) {
30017cec:	b108      	cbz	r0, 30017cf2 <ptdev_get_partition_entries+0x6>
    return part_dev->partition_entries;
30017cee:	6900      	ldr	r0, [r0, #16]
}
30017cf0:	4770      	bx	r14
{
30017cf2:	b510      	push	{r4, r14}
30017cf4:	4604      	mov	r4, r0
        dprintf(CRITICAL, "Invalid partition dev\n");
30017cf6:	f241 2084 	movw	r0, #4740	; 0x1284
30017cfa:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017cfe:	f7fd ff57 	bl	30015bb0 <_printf>
        return NULL;
30017d02:	4620      	mov	r0, r4
}
30017d04:	bd10      	pop	{r4, r15}
30017d06:	bf00      	nop

30017d08 <ptdev_read_table>:
{
30017d08:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
30017d0c:	b083      	sub	sp, #12
    if ((!part_dev) || (!part_dev->storage)) {
30017d0e:	2800      	cmp	r0, #0
30017d10:	d074      	beq.n	30017dfc <ptdev_read_table+0xf4>
30017d12:	4604      	mov	r4, r0
30017d14:	6800      	ldr	r0, [r0, #0]
30017d16:	2800      	cmp	r0, #0
30017d18:	d070      	beq.n	30017dfc <ptdev_read_table+0xf4>
    block_size = storage->get_block_size(storage);
30017d1a:	6a03      	ldr	r3, [r0, #32]
30017d1c:	46f1      	mov	r9, r14
30017d1e:	4798      	blx	r3
30017d20:	4607      	mov	r7, r0
    if (part_dev->partition_entries) {
30017d22:	6920      	ldr	r0, [r4, #16]
30017d24:	b108      	cbz	r0, 30017d2a <ptdev_read_table+0x22>
        free(part_dev->partition_entries);
30017d26:	f7fc fd31 	bl	3001478c <free>
    storage_device_t *storage = part_dev->storage;
30017d2a:	6823      	ldr	r3, [r4, #0]
    part_dev->count = 0;
30017d2c:	2600      	movs	r6, #0
    block_size = storage->get_block_size(storage);
30017d2e:	4618      	mov	r0, r3
    part_dev->gpt_partitions_exist = true;
30017d30:	2501      	movs	r5, #1
    part_dev->count = 0;
30017d32:	6166      	str	r6, [r4, #20]
    block_size = storage->get_block_size(storage);
30017d34:	6a1b      	ldr	r3, [r3, #32]
    part_dev->partition_entries = NULL;
30017d36:	6126      	str	r6, [r4, #16]
    block_size = storage->get_block_size(storage);
30017d38:	4798      	blx	r3
    part_dev->gpt_partitions_exist = true;
30017d3a:	77a5      	strb	r5, [r4, #30]
        if (ptdev_read_gpt(part_dev, NULL, block_size)) {
30017d3c:	4631      	mov	r1, r6
30017d3e:	4602      	mov	r2, r0
30017d40:	4620      	mov	r0, r4
30017d42:	f7ff fa27 	bl	30017194 <ptdev_read_gpt>
30017d46:	4680      	mov	r8, r0
30017d48:	2800      	cmp	r0, #0
30017d4a:	d145      	bne.n	30017dd8 <ptdev_read_table+0xd0>
    count = part_dev->count;
30017d4c:	6960      	ldr	r0, [r4, #20]
    part_dev->gpt_partitions_exist = false;
30017d4e:	f884 801e 	strb.w	r8, [r4, #30]
    part_dev->count = 0;
30017d52:	f8c4 8014 	str.w	r8, [r4, #20]
    if (!partition_count) {
30017d56:	2800      	cmp	r0, #0
30017d58:	d046      	beq.n	30017de8 <ptdev_read_table+0xe0>
    part_dev->partition_entries = (struct partition_entry *) calloc(
30017d5a:	2190      	movs	r1, #144	; 0x90
30017d5c:	2880      	cmp	r0, #128	; 0x80
30017d5e:	bf28      	it	cs
30017d60:	2080      	movcs	r0, #128	; 0x80
30017d62:	f7fc fcf3 	bl	3001474c <calloc>
30017d66:	6120      	str	r0, [r4, #16]
    ASSERT(part_dev->partition_entries);
30017d68:	2800      	cmp	r0, #0
30017d6a:	d05b      	beq.n	30017e24 <ptdev_read_table+0x11c>
    part_dev->gpt_partitions_exist = true;
30017d6c:	77a5      	strb	r5, [r4, #30]
        ret = ptdev_read_gpt(part_dev, NULL, block_size);
30017d6e:	4641      	mov	r1, r8
30017d70:	463a      	mov	r2, r7
30017d72:	4620      	mov	r0, r4
30017d74:	f7ff fa0e 	bl	30017194 <ptdev_read_gpt>
        if (ret) {
30017d78:	2800      	cmp	r0, #0
30017d7a:	d149      	bne.n	30017e10 <ptdev_read_table+0x108>
    partition_entries = part_dev->partition_entries;
30017d7c:	e9d4 5604 	ldrd	r5, r6, [r4, #16]
    for (unsigned i = 0; i < partition_count; i++) {
30017d80:	b31e      	cbz	r6, 30017dca <ptdev_read_table+0xc2>
    return !memcmp(sub_part_guid, partition_entries->type_guid,
30017d82:	f641 38d0 	movw	r8, #7120	; 0x1bd0
30017d86:	eb06 06c6 	add.w	r6, r6, r6, lsl #3
                dprintf(CRITICAL, "read extral partition table failed\n");
30017d8a:	f241 7934 	movw	r9, #5940	; 0x1734
    return !memcmp(sub_part_guid, partition_entries->type_guid,
30017d8e:	f2c3 0802 	movt	r8, #12290	; 0x3002
30017d92:	eb05 1606 	add.w	r6, r5, r6, lsl #4
                dprintf(CRITICAL, "read extral partition table failed\n");
30017d96:	f2c3 0902 	movt	r9, #12290	; 0x3002
30017d9a:	e002      	b.n	30017da2 <ptdev_read_table+0x9a>
30017d9c:	3590      	adds	r5, #144	; 0x90
    for (unsigned i = 0; i < partition_count; i++) {
30017d9e:	42ae      	cmp	r6, r5
30017da0:	d013      	beq.n	30017dca <ptdev_read_table+0xc2>
    return !memcmp(sub_part_guid, partition_entries->type_guid,
30017da2:	2210      	movs	r2, #16
30017da4:	4629      	mov	r1, r5
30017da6:	4640      	mov	r0, r8
30017da8:	f7fd ff24 	bl	30015bf4 <memcmp>
        if (ptdev_sub_part_exist(partition_entries + i)) {
30017dac:	2800      	cmp	r0, #0
30017dae:	d1f5      	bne.n	30017d9c <ptdev_read_table+0x94>
            if (ptdev_read_gpt(part_dev, &partition_entries[i], block_size)) {
30017db0:	463a      	mov	r2, r7
30017db2:	4629      	mov	r1, r5
30017db4:	4620      	mov	r0, r4
30017db6:	f7ff f9ed 	bl	30017194 <ptdev_read_gpt>
30017dba:	2800      	cmp	r0, #0
30017dbc:	d0ee      	beq.n	30017d9c <ptdev_read_table+0x94>
                dprintf(CRITICAL, "read extral partition table failed\n");
30017dbe:	4648      	mov	r0, r9
30017dc0:	3590      	adds	r5, #144	; 0x90
30017dc2:	f7fd fef5 	bl	30015bb0 <_printf>
    for (unsigned i = 0; i < partition_count; i++) {
30017dc6:	42ae      	cmp	r6, r5
30017dc8:	d1eb      	bne.n	30017da2 <ptdev_read_table+0x9a>
    ptdev_scan_for_multislot(part_dev);
30017dca:	4620      	mov	r0, r4
30017dcc:	f000 fe86 	bl	30018adc <ptdev_scan_for_multislot>
    return 0;
30017dd0:	2000      	movs	r0, #0
}
30017dd2:	b003      	add	sp, #12
30017dd4:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
            dprintf(CRITICAL, "read gpt fail!\n");
30017dd8:	f241 60d4 	movw	r0, #5844	; 0x16d4
30017ddc:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017de0:	f7fd fee6 	bl	30015bb0 <_printf>
    part_dev->count = 0;
30017de4:	6166      	str	r6, [r4, #20]
    part_dev->gpt_partitions_exist = false;
30017de6:	77a6      	strb	r6, [r4, #30]
        dprintf(CRITICAL, "get partition count fail!\n");
30017de8:	f241 60e4 	movw	r0, #5860	; 0x16e4
30017dec:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017df0:	f7fd fede 	bl	30015bb0 <_printf>
        return 1;
30017df4:	2001      	movs	r0, #1
}
30017df6:	b003      	add	sp, #12
30017df8:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        dprintf(CRITICAL, "Invalide partition\n");
30017dfc:	f241 60c0 	movw	r0, #5824	; 0x16c0
30017e00:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017e04:	f7fd fed4 	bl	30015bb0 <_printf>
        return 1;
30017e08:	2001      	movs	r0, #1
}
30017e0a:	b003      	add	sp, #12
30017e0c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
            dprintf(CRITICAL, "Boot: GPT read failed!\n");
30017e10:	f241 701c 	movw	r0, #5916	; 0x171c
30017e14:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017e18:	f7fd feca 	bl	30015bb0 <_printf>
            return 1;
30017e1c:	4628      	mov	r0, r5
}
30017e1e:	b003      	add	sp, #12
30017e20:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    ASSERT(part_dev->partition_entries);
30017e24:	f241 7300 	movw	r3, #5888	; 0x1700
30017e28:	f641 12c0 	movw	r2, #6592	; 0x19c0
30017e2c:	f24a 011c 	movw	r1, #40988	; 0xa01c
30017e30:	f2c3 0302 	movt	r3, #12290	; 0x3002
30017e34:	4648      	mov	r0, r9
30017e36:	f2c3 0202 	movt	r2, #12290	; 0x3002
30017e3a:	9300      	str	r3, [sp, #0]
30017e3c:	f2c3 0101 	movt	r1, #12289	; 0x3001
30017e40:	23b5      	movs	r3, #181	; 0xb5
30017e42:	f7fc f9e7 	bl	30014214 <_panic>
30017e46:	bf00      	nop

30017e48 <ptdev_get_index>:
{
30017e48:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30017e4c:	4607      	mov	r7, r0
30017e4e:	b083      	sub	sp, #12
    unsigned int input_string_length = strlen(name);
30017e50:	4608      	mov	r0, r1
{
30017e52:	4688      	mov	r8, r1
    unsigned int input_string_length = strlen(name);
30017e54:	f7fd ff6c 	bl	30015d30 <strlen>
    if ((!part_dev) || (!part_dev->partition_entries) || (!name)) {
30017e58:	2f00      	cmp	r7, #0
30017e5a:	d03b      	beq.n	30017ed4 <ptdev_get_index+0x8c>
30017e5c:	693c      	ldr	r4, [r7, #16]
30017e5e:	2c00      	cmp	r4, #0
30017e60:	d038      	beq.n	30017ed4 <ptdev_get_index+0x8c>
    partition_count = part_dev->count;
30017e62:	f8d7 9014 	ldr.w	r9, [r7, #20]
    for (n = 0; n < partition_count; n++) {
30017e66:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
30017e6a:	2b7f      	cmp	r3, #127	; 0x7f
30017e6c:	d832      	bhi.n	30017ed4 <ptdev_get_index+0x8c>
                    suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);
30017e6e:	f245 4b3c 	movw	r11, #21564	; 0x543c
30017e72:	4606      	mov	r6, r0
30017e74:	3438      	adds	r4, #56	; 0x38
    for (n = 0; n < partition_count; n++) {
30017e76:	2500      	movs	r5, #0
                    suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);
30017e78:	f2c3 0b02 	movt	r11, #12290	; 0x3002
30017e7c:	e004      	b.n	30017e88 <ptdev_get_index+0x40>
    for (n = 0; n < partition_count; n++) {
30017e7e:	3501      	adds	r5, #1
30017e80:	45a9      	cmp	r9, r5
30017e82:	f104 0490 	add.w	r4, r4, #144	; 0x90
30017e86:	d025      	beq.n	30017ed4 <ptdev_get_index+0x8c>
        if (!strncmp((const char *)name, (const char *)partition_entries[n].name,
30017e88:	4632      	mov	r2, r6
30017e8a:	4621      	mov	r1, r4
30017e8c:	4640      	mov	r0, r8
30017e8e:	eb04 0a06 	add.w	r10, r4, r6
30017e92:	f7fd ff67 	bl	30015d64 <strncmp>
30017e96:	2800      	cmp	r0, #0
30017e98:	d1f1      	bne.n	30017e7e <ptdev_get_index+0x36>
            if (ptdev_multislot_is_supported(part_dev)) {
30017e9a:	4638      	mov	r0, r7
            if (*curr_suffix == '\0')
30017e9c:	5da3      	ldrb	r3, [r4, r6]
30017e9e:	b1ab      	cbz	r3, 30017ecc <ptdev_get_index+0x84>
            if (ptdev_multislot_is_supported(part_dev)) {
30017ea0:	f000 fef8 	bl	30018c94 <ptdev_multislot_is_supported>
30017ea4:	2800      	cmp	r0, #0
30017ea6:	d0ea      	beq.n	30017e7e <ptdev_get_index+0x36>
                curr_slot = ptdev_find_active_slot(part_dev);
30017ea8:	4638      	mov	r0, r7
30017eaa:	f000 fea3 	bl	30018bf4 <ptdev_find_active_slot>
                if (curr_slot != INVALID) {
30017eae:	1c43      	adds	r3, r0, #1
30017eb0:	d010      	beq.n	30017ed4 <ptdev_get_index+0x8c>
                    suffix_curr_actv_slot = SUFFIX_SLOT(curr_slot);
30017eb2:	f85b 1020 	ldr.w	r1, [r11, r0, lsl #2]
                    if (!strncmp((const char *)curr_suffix, suffix_curr_actv_slot,
30017eb6:	9101      	str	r1, [sp, #4]
30017eb8:	4608      	mov	r0, r1
30017eba:	f7fd ff39 	bl	30015d30 <strlen>
30017ebe:	9901      	ldr	r1, [sp, #4]
30017ec0:	4602      	mov	r2, r0
30017ec2:	4650      	mov	r0, r10
30017ec4:	f7fd ff4e 	bl	30015d64 <strncmp>
30017ec8:	2800      	cmp	r0, #0
30017eca:	d1d8      	bne.n	30017e7e <ptdev_get_index+0x36>
}
30017ecc:	4628      	mov	r0, r5
30017ece:	b003      	add	sp, #12
30017ed0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return INVALID_PTN;
30017ed4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
}
30017ed8:	4628      	mov	r0, r5
30017eda:	b003      	add	sp, #12
30017edc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

30017ee0 <ptdev_get_size>:
    if ((!part_dev) || (!part_dev->partition_entries) || (!name)
30017ee0:	b308      	cbz	r0, 30017f26 <ptdev_get_size+0x46>
{
30017ee2:	b538      	push	{r3, r4, r5, r14}
    if ((!part_dev) || (!part_dev->partition_entries) || (!name)
30017ee4:	6903      	ldr	r3, [r0, #16]
30017ee6:	4604      	mov	r4, r0
30017ee8:	2900      	cmp	r1, #0
30017eea:	bf18      	it	ne
30017eec:	2b00      	cmpne	r3, #0
30017eee:	d017      	beq.n	30017f20 <ptdev_get_size+0x40>
            || (!part_dev->storage) ) {
30017ef0:	6802      	ldr	r2, [r0, #0]
30017ef2:	b1aa      	cbz	r2, 30017f20 <ptdev_get_size+0x40>
    index = ptdev_get_index(part_dev, name);
30017ef4:	f7ff ffa8 	bl	30017e48 <ptdev_get_index>
    storage = part_dev->storage;
30017ef8:	6823      	ldr	r3, [r4, #0]
    index = ptdev_get_index(part_dev, name);
30017efa:	4605      	mov	r5, r0
    block_size = storage->get_block_size(storage);
30017efc:	4618      	mov	r0, r3
30017efe:	6a1b      	ldr	r3, [r3, #32]
30017f00:	4798      	blx	r3
    if (index == (unsigned)INVALID_PTN)
30017f02:	1c6b      	adds	r3, r5, #1
    block_size = storage->get_block_size(storage);
30017f04:	4602      	mov	r2, r0
    if (index == (unsigned)INVALID_PTN)
30017f06:	d00b      	beq.n	30017f20 <ptdev_get_size+0x40>
        return partition_entries[index].size * block_size;
30017f08:	6923      	ldr	r3, [r4, #16]
30017f0a:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
30017f0e:	eb03 1505 	add.w	r5, r3, r5, lsl #4
30017f12:	e9d5 0422 	ldrd	r0, r4, [r5, #136]	; 0x88
30017f16:	fba0 0102 	umull	r0, r1, r0, r2
30017f1a:	fb02 1104 	mla	r1, r2, r4, r1
}
30017f1e:	bd38      	pop	{r3, r4, r5, r15}
        return 0;
30017f20:	2000      	movs	r0, #0
30017f22:	2100      	movs	r1, #0
}
30017f24:	bd38      	pop	{r3, r4, r5, r15}
        return 0;
30017f26:	2000      	movs	r0, #0
30017f28:	2100      	movs	r1, #0
}
30017f2a:	4770      	bx	r14

30017f2c <ptdev_get_offset>:
    if ((!part_dev) || (!part_dev->partition_entries) || (!name)
30017f2c:	b328      	cbz	r0, 30017f7a <ptdev_get_offset+0x4e>
{
30017f2e:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if ((!part_dev) || (!part_dev->partition_entries) || (!name)
30017f30:	6903      	ldr	r3, [r0, #16]
30017f32:	4604      	mov	r4, r0
30017f34:	2900      	cmp	r1, #0
30017f36:	bf18      	it	ne
30017f38:	2b00      	cmpne	r3, #0
30017f3a:	d01b      	beq.n	30017f74 <ptdev_get_offset+0x48>
            || (!part_dev->storage)) {
30017f3c:	6802      	ldr	r2, [r0, #0]
30017f3e:	b1ca      	cbz	r2, 30017f74 <ptdev_get_offset+0x48>
    index = ptdev_get_index(part_dev, name);
30017f40:	f7ff ff82 	bl	30017e48 <ptdev_get_index>
    storage = part_dev->storage;
30017f44:	6823      	ldr	r3, [r4, #0]
    index = ptdev_get_index(part_dev, name);
30017f46:	4605      	mov	r5, r0
    block_size = storage->get_block_size(storage);
30017f48:	4618      	mov	r0, r3
30017f4a:	6a1b      	ldr	r3, [r3, #32]
30017f4c:	4798      	blx	r3
    if (index == (unsigned)INVALID_PTN)
30017f4e:	1c6b      	adds	r3, r5, #1
30017f50:	d010      	beq.n	30017f74 <ptdev_get_offset+0x48>
        return partition_entries[index].first_lba * block_size +
30017f52:	6923      	ldr	r3, [r4, #16]
30017f54:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
30017f58:	e9d4 6702 	ldrd	r6, r7, [r4, #8]
30017f5c:	eb03 1505 	add.w	r5, r3, r5, lsl #4
30017f60:	e9d5 2108 	ldrd	r2, r1, [r5, #32]
30017f64:	fba2 2300 	umull	r2, r3, r2, r0
30017f68:	fb00 3301 	mla	r3, r0, r1, r3
30017f6c:	1990      	adds	r0, r2, r6
30017f6e:	eb43 0107 	adc.w	r1, r3, r7
}
30017f72:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return 0;
30017f74:	2000      	movs	r0, #0
30017f76:	2100      	movs	r1, #0
}
30017f78:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return 0;
30017f7a:	2000      	movs	r0, #0
30017f7c:	2100      	movs	r1, #0
}
30017f7e:	4770      	bx	r14

30017f80 <ptdev_dump>:
    if ((!part_dev) || (!part_dev->partition_entries)) {
30017f80:	2800      	cmp	r0, #0
30017f82:	d02f      	beq.n	30017fe4 <ptdev_dump+0x64>
{
30017f84:	e92d 4d70 	stmdb	r13!, {r4, r5, r6, r8, r10, r11, r14}
    if ((!part_dev) || (!part_dev->partition_entries)) {
30017f88:	6904      	ldr	r4, [r0, #16]
{
30017f8a:	b089      	sub	sp, #36	; 0x24
    if ((!part_dev) || (!part_dev->partition_entries)) {
30017f8c:	b30c      	cbz	r4, 30017fd2 <ptdev_dump+0x52>
    partition_count = part_dev->count;
30017f8e:	6946      	ldr	r6, [r0, #20]
    for (i = 0; i < partition_count; i++) {
30017f90:	b1e6      	cbz	r6, 30017fcc <ptdev_dump+0x4c>
        dprintf(CRITICAL,
30017f92:	f241 2844 	movw	r8, #4676	; 0x1244
30017f96:	3438      	adds	r4, #56	; 0x38
    for (i = 0; i < partition_count; i++) {
30017f98:	2500      	movs	r5, #0
        dprintf(CRITICAL,
30017f9a:	f2c3 0802 	movt	r8, #12290	; 0x3002
30017f9e:	e954 0104 	ldrd	r0, r1, [r4, #-16]
30017fa2:	4622      	mov	r2, r4
30017fa4:	e9cd 0106 	strd	r0, r1, [r13, #24]
30017fa8:	4629      	mov	r1, r5
30017faa:	e954 ab06 	ldrd	r10, r11, [r4, #-24]
    for (i = 0; i < partition_count; i++) {
30017fae:	3501      	adds	r5, #1
        dprintf(CRITICAL,
30017fb0:	e9cd ab04 	strd	r10, r11, [r13, #16]
30017fb4:	4640      	mov	r0, r8
30017fb6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
30017fb8:	3490      	adds	r4, #144	; 0x90
30017fba:	9302      	str	r3, [sp, #8]
30017fbc:	e954 ab10 	ldrd	r10, r11, [r4, #-64]	; 0x40
30017fc0:	e9cd ab00 	strd	r10, r11, [r13]
30017fc4:	f7fd fdf4 	bl	30015bb0 <_printf>
    for (i = 0; i < partition_count; i++) {
30017fc8:	42ae      	cmp	r6, r5
30017fca:	d1e8      	bne.n	30017f9e <ptdev_dump+0x1e>
}
30017fcc:	b009      	add	sp, #36	; 0x24
30017fce:	e8bd 8d70 	ldmia.w	r13!, {r4, r5, r6, r8, r10, r11, r15}
        dprintf(CRITICAL, "Invalid partition dev\n");
30017fd2:	f241 2084 	movw	r0, #4740	; 0x1284
30017fd6:	f2c3 0002 	movt	r0, #12290	; 0x3002
}
30017fda:	b009      	add	sp, #36	; 0x24
30017fdc:	e8bd 4d70 	ldmia.w	r13!, {r4, r5, r6, r8, r10, r11, r14}
        dprintf(CRITICAL, "Invalid partition dev\n");
30017fe0:	f7fd bde6 	b.w	30015bb0 <_printf>
30017fe4:	f241 2084 	movw	r0, #4740	; 0x1284
30017fe8:	f2c3 0002 	movt	r0, #12290	; 0x3002
30017fec:	f7fd bde0 	b.w	30015bb0 <_printf>

30017ff0 <write_gpt>:
{
30017ff0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    storage_device_t *storage = part_dev->storage;
30017ff4:	4682      	mov	r10, r0
{
30017ff6:	b0ad      	sub	sp, #180	; 0xb4
30017ff8:	468b      	mov	r11, r1
30017ffa:	f89d 10dc 	ldrb.w	r1, [r13, #220]	; 0xdc
30017ffe:	9113      	str	r1, [sp, #76]	; 0x4c
    unsigned int max_partition_count = 0;
30018000:	f04f 0c00 	mov.w	r12, #0
    primary_gpt_header = (gptImage + block_size);
30018004:	9936      	ldr	r1, [sp, #216]	; 0xd8
    ret = ptdev_parse_gpt_header(part_dev, primary_gpt_header,
30018006:	af28      	add	r7, sp, #160	; 0xa0
30018008:	ae27      	add	r6, sp, #156	; 0x9c
3001800a:	ad29      	add	r5, sp, #164	; 0xa4
{
3001800c:	9008      	str	r0, [sp, #32]
    primary_gpt_header = (gptImage + block_size);
3001800e:	185c      	adds	r4, r3, r1
    storage_device_t *storage = part_dev->storage;
30018010:	f85a 0b08 	ldr.w	r0, [r10], #8
{
30018014:	9312      	str	r3, [sp, #72]	; 0x48
    ret = ptdev_parse_gpt_header(part_dev, primary_gpt_header,
30018016:	4651      	mov	r1, r10
{
30018018:	921b      	str	r2, [sp, #108]	; 0x6c
    ret = ptdev_parse_gpt_header(part_dev, primary_gpt_header,
3001801a:	ab2a      	add	r3, sp, #168	; 0xa8
3001801c:	f8cd b00c 	str.w	r11, [r13, #12]
30018020:	4622      	mov	r2, r4
30018022:	e9cd cc06 	strd	r12, r12, [r13, #24]
30018026:	e9cd cc04 	strd	r12, r12, [r13, #16]
3001802a:	e9cd 6701 	strd	r6, r7, [r13, #4]
3001802e:	9500      	str	r5, [sp, #0]
    storage_device_t *storage = part_dev->storage;
30018030:	9009      	str	r0, [sp, #36]	; 0x24
    unsigned int max_partition_count = 0;
30018032:	f8cd c0a0 	str.w	r12, [r13, #160]	; 0xa0
    ret = ptdev_parse_gpt_header(part_dev, primary_gpt_header,
30018036:	f7fe fbc9 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
    if (ret) {
3001803a:	2800      	cmp	r0, #0
3001803c:	f040 8230 	bne.w	300184a0 <write_gpt+0x4b0>
    if (parent_entry) {
30018040:	f1bb 0f00 	cmp.w	r11, #0
30018044:	f040 824b 	bne.w	300184de <write_gpt+0x4ee>
        device_capacity = storage->get_capacity(storage) - part_dev->gpt_offset;
30018048:	9809      	ldr	r0, [sp, #36]	; 0x24
3001804a:	6983      	ldr	r3, [r0, #24]
3001804c:	4798      	blx	r3
3001804e:	9b08      	ldr	r3, [sp, #32]
30018050:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
30018054:	1a82      	subs	r2, r0, r2
30018056:	eb61 0303 	sbc.w	r3, r1, r3
3001805a:	e9cd 230a 	strd	r2, r3, [r13, #40]	; 0x28
    ret =
3001805e:	9702      	str	r7, [sp, #8]
30018060:	2000      	movs	r0, #0
    partition_entry_array_size = partition_entry_size * max_partition_count;
30018062:	9a28      	ldr	r2, [sp, #160]	; 0xa0
    ret =
30018064:	f04f 0c01 	mov.w	r12, #1
    partition_entry_array_size = partition_entry_size * max_partition_count;
30018068:	9f29      	ldr	r7, [sp, #164]	; 0xa4
    ret =
3001806a:	ab2a      	add	r3, sp, #168	; 0xa8
3001806c:	e9cd 5600 	strd	r5, r6, [r13]
30018070:	4651      	mov	r1, r10
    secondary_gpt_header = offset + block_size + primary_gpt_header;
30018072:	9d36      	ldr	r5, [sp, #216]	; 0xd8
    partition_entry_array_size = partition_entry_size * max_partition_count;
30018074:	fb02 f207 	mul.w	r2, r2, r7
    ret =
30018078:	9007      	str	r0, [sp, #28]
3001807a:	e9cd 0005 	strd	r0, r0, [r13, #20]
3001807e:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
30018082:	9808      	ldr	r0, [sp, #32]
30018084:	bf38      	it	cc
30018086:	f44f 4280 	movcc.w	r2, #16384	; 0x4000
3001808a:	f8cd b00c 	str.w	r11, [r13, #12]
3001808e:	920c      	str	r2, [sp, #48]	; 0x30
    secondary_gpt_header = offset + block_size + primary_gpt_header;
30018090:	eb05 0242 	add.w	r2, r5, r2, lsl #1
    ret =
30018094:	6800      	ldr	r0, [r0, #0]
    secondary_gpt_header = offset + block_size + primary_gpt_header;
30018096:	18a5      	adds	r5, r4, r2
30018098:	921e      	str	r2, [sp, #120]	; 0x78
    ret =
3001809a:	462a      	mov	r2, r5
3001809c:	f8cd c010 	str.w	r12, [r13, #16]
300180a0:	f7fe fb94 	bl	300167cc <ptdev_parse_gpt_header.isra.2>
    if (ret) {
300180a4:	4680      	mov	r8, r0
300180a6:	2800      	cmp	r0, #0
300180a8:	f040 81f0 	bne.w	3001848c <write_gpt+0x49c>
    card_size_sec = (density) / block_size;
300180ac:	9b36      	ldr	r3, [sp, #216]	; 0xd8
300180ae:	2200      	movs	r2, #0
300180b0:	4619      	mov	r1, r3
300180b2:	4613      	mov	r3, r2
300180b4:	460a      	mov	r2, r1
    unsigned ptn_entries_blocks = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) /
300180b6:	f44f 4680 	mov.w	r6, #16384	; 0x4000
    card_size_sec = (density) / block_size;
300180ba:	e9dd 010a 	ldrd	r0, r1, [r13, #40]	; 0x28
300180be:	e9cd 2310 	strd	r2, r3, [r13, #64]	; 0x40
300180c2:	f001 fead 	bl	30019e20 <__aeabi_uldivmod>
    patch_gpt(part_dev, gptImage, device_capacity, partition_entry_array_size,
300180c6:	9b28      	ldr	r3, [sp, #160]	; 0xa0
    unsigned ptn_entries_blocks = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) /
300180c8:	9f36      	ldr	r7, [sp, #216]	; 0xd8
    patch_gpt(part_dev, gptImage, device_capacity, partition_entry_array_size,
300180ca:	931f      	str	r3, [sp, #124]	; 0x7c
300180cc:	9b29      	ldr	r3, [sp, #164]	; 0xa4
300180ce:	9320      	str	r3, [sp, #128]	; 0x80
    unsigned ptn_entries_blocks = (NUM_PARTITIONS * PARTITION_ENTRY_SIZE) /
300180d0:	fbb6 f6f7 	udiv	r6, r6, r7
    card_size_sec = (density) / block_size;
300180d4:	4681      	mov	r9, r0
    if (card_size_sec == 0) {
300180d6:	ea50 0301 	orrs.w	r3, r0, r1
    card_size_sec = (density) / block_size;
300180da:	468a      	mov	r10, r1
    if (card_size_sec == 0) {
300180dc:	f000 81eb 	beq.w	300184b6 <write_gpt+0x4c6>
300180e0:	f119 32ff 	adds.w	r2, r9, #4294967295	; 0xffffffff
300180e4:	fa5f fc80 	uxtb.w	r12, r0
300180e8:	f3c2 4007 	ubfx	r0, r2, #16, #8
300180ec:	f14a 33ff 	adc.w	r3, r10, #4294967295	; 0xffffffff
300180f0:	9015      	str	r0, [sp, #84]	; 0x54
300180f2:	0e10      	lsrs	r0, r2, #24
300180f4:	f10c 31ff 	add.w	r1, r12, #4294967295	; 0xffffffff
300180f8:	9016      	str	r0, [sp, #88]	; 0x58
300180fa:	b2d8      	uxtb	r0, r3
300180fc:	b2c9      	uxtb	r1, r1
300180fe:	9017      	str	r0, [sp, #92]	; 0x5c
30018100:	f3c3 2007 	ubfx	r0, r3, #8, #8
30018104:	9114      	str	r1, [sp, #80]	; 0x50
30018106:	f3c2 2707 	ubfx	r7, r2, #8, #8
3001810a:	9018      	str	r0, [sp, #96]	; 0x60
3001810c:	f3c3 4007 	ubfx	r0, r3, #16, #8
30018110:	0e1b      	lsrs	r3, r3, #24
30018112:	9019      	str	r0, [sp, #100]	; 0x64
30018114:	931a      	str	r3, [sp, #104]	; 0x68
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018116:	46c8      	mov	r8, r9
30018118:	f106 0e02 	add.w	r14, r6, #2
3001811c:	ebb8 020e 	subs.w	r2, r8, r14
30018120:	ebac 0c06 	sub.w	r12, r12, r6
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018124:	f106 0601 	add.w	r6, r6, #1
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018128:	f16a 0300 	sbc.w	r3, r10, #0
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
3001812c:	ebb8 0806 	subs.w	r8, r8, r6
30018130:	f16a 0900 	sbc.w	r9, r10, #0
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018134:	fa5f fc8c 	uxtb.w	r12, r12
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018138:	e9cd 890e 	strd	r8, r9, [r13, #56]	; 0x38
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
3001813c:	f3c3 2907 	ubfx	r9, r3, #8, #8
30018140:	f1ac 0002 	sub.w	r0, r12, #2
30018144:	f8cd 9070 	str.w	r9, [r13, #112]	; 0x70
30018148:	f3c3 4907 	ubfx	r9, r3, #16, #8
3001814c:	b2c1      	uxtb	r1, r0
3001814e:	f8cd 9074 	str.w	r9, [r13, #116]	; 0x74
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018152:	f10c 30ff 	add.w	r0, r12, #4294967295	; 0xffffffff
30018156:	e9dd 890e 	ldrd	r8, r9, [r13, #56]	; 0x38
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
3001815a:	f3c2 2607 	ubfx	r6, r2, #8, #8
3001815e:	f3c2 4c07 	ubfx	r12, r2, #16, #8
30018162:	ea4f 6e12 	mov.w	r14, r2, lsr #24
30018166:	fa5f fa83 	uxtb.w	r10, r3
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
3001816a:	9021      	str	r0, [sp, #132]	; 0x84
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
3001816c:	0e1a      	lsrs	r2, r3, #24
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
3001816e:	9819      	ldr	r0, [sp, #100]	; 0x64
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018170:	4643      	mov	r3, r8
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018172:	920d      	str	r2, [sp, #52]	; 0x34
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018174:	4642      	mov	r2, r8
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
30018176:	f884 7021 	strb.w	r7, [r4, #33]	; 0x21
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
3001817a:	0c1b      	lsrs	r3, r3, #16
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
3001817c:	f884 0026 	strb.w	r0, [r4, #38]	; 0x26
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018180:	0a12      	lsrs	r2, r2, #8
30018182:	9323      	str	r3, [sp, #140]	; 0x8c
30018184:	4643      	mov	r3, r8
30018186:	9222      	str	r2, [sp, #136]	; 0x88
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
30018188:	9a15      	ldr	r2, [sp, #84]	; 0x54
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
3001818a:	0e1b      	lsrs	r3, r3, #24
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
3001818c:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018190:	9324      	str	r3, [sp, #144]	; 0x90
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
30018192:	9b14      	ldr	r3, [sp, #80]	; 0x50
30018194:	f884 3020 	strb.w	r3, [r4, #32]
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018198:	464b      	mov	r3, r9
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
3001819a:	910a      	str	r1, [sp, #40]	; 0x28
3001819c:	f884 1030 	strb.w	r1, [r4, #48]	; 0x30
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181a0:	121b      	asrs	r3, r3, #8
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181a2:	f884 6031 	strb.w	r6, [r4, #49]	; 0x31
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181a6:	9325      	str	r3, [sp, #148]	; 0x94
    PUT_LONG_LONG(primary_gpt_header + BACKUP_HEADER_OFFSET,
300181a8:	9b16      	ldr	r3, [sp, #88]	; 0x58
300181aa:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
300181ae:	9b17      	ldr	r3, [sp, #92]	; 0x5c
300181b0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
300181b4:	9b18      	ldr	r3, [sp, #96]	; 0x60
300181b6:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
300181ba:	9b1a      	ldr	r3, [sp, #104]	; 0x68
300181bc:	f884 3027 	strb.w	r3, [r4, #39]	; 0x27
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181c0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
300181c2:	f884 c032 	strb.w	r12, [r4, #50]	; 0x32
300181c6:	f884 e033 	strb.w	r14, [r4, #51]	; 0x33
300181ca:	f884 a034 	strb.w	r10, [r4, #52]	; 0x34
300181ce:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181d2:	e9dd 890e 	ldrd	r8, r9, [r13, #56]	; 0x38
300181d6:	46a0      	mov	r8, r4
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181d8:	981d      	ldr	r0, [sp, #116]	; 0x74
300181da:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181dc:	990a      	ldr	r1, [sp, #40]	; 0x28
    PUT_LONG_LONG(primary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181de:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
300181e2:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181e6:	f885 1030 	strb.w	r1, [r5, #48]	; 0x30
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181ea:	4649      	mov	r1, r9
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181ec:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
300181f0:	9b14      	ldr	r3, [sp, #80]	; 0x50
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
300181f2:	f885 2037 	strb.w	r2, [r5, #55]	; 0x37
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
300181f6:	762b      	strb	r3, [r5, #24]
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181f8:	140b      	asrs	r3, r1, #16
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
300181fa:	9a15      	ldr	r2, [sp, #84]	; 0x54
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
300181fc:	0e09      	lsrs	r1, r1, #24
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
300181fe:	766f      	strb	r7, [r5, #25]
    last_partition_entry = (unsigned long long *)
30018200:	9f36      	ldr	r7, [sp, #216]	; 0xd8
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
30018202:	76aa      	strb	r2, [r5, #26]
30018204:	9a16      	ldr	r2, [sp, #88]	; 0x58
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018206:	f885 0036 	strb.w	r0, [r5, #54]	; 0x36
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
3001820a:	9114      	str	r1, [sp, #80]	; 0x50
    last_partition_entry = (unsigned long long *)
3001820c:	19e1      	adds	r1, r4, r7
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
3001820e:	9819      	ldr	r0, [sp, #100]	; 0x64
    int total_part = 0;
30018210:	2700      	movs	r7, #0
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
30018212:	76ea      	strb	r2, [r5, #27]
30018214:	9a17      	ldr	r2, [sp, #92]	; 0x5c
30018216:	772a      	strb	r2, [r5, #28]
30018218:	77a8      	strb	r0, [r5, #30]
3001821a:	9a18      	ldr	r2, [sp, #96]	; 0x60
3001821c:	981a      	ldr	r0, [sp, #104]	; 0x68
    last_partition_entry = (unsigned long long *)
3001821e:	910e      	str	r1, [sp, #56]	; 0x38
30018220:	3108      	adds	r1, #8
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
30018222:	776a      	strb	r2, [r5, #29]
    PUT_LONG_LONG(secondary_gpt_header + LAST_USABLE_LBA_OFFSET,
30018224:	f885 6031 	strb.w	r6, [r5, #49]	; 0x31
30018228:	f885 c032 	strb.w	r12, [r5, #50]	; 0x32
3001822c:	f885 e033 	strb.w	r14, [r5, #51]	; 0x33
30018230:	f885 a034 	strb.w	r10, [r5, #52]	; 0x34
    PUT_LONG_LONG(secondary_gpt_header + PRIMARY_HEADER_OFFSET,
30018234:	77e8      	strb	r0, [r5, #31]
    PUT_LONG_LONG(secondary_gpt_header + PARTITION_ENTRIES_OFFSET,
30018236:	9821      	ldr	r0, [sp, #132]	; 0x84
30018238:	9a22      	ldr	r2, [sp, #136]	; 0x88
3001823a:	f885 2049 	strb.w	r2, [r5, #73]	; 0x49
3001823e:	9a23      	ldr	r2, [sp, #140]	; 0x8c
30018240:	f885 204a 	strb.w	r2, [r5, #74]	; 0x4a
30018244:	9a24      	ldr	r2, [sp, #144]	; 0x90
30018246:	f885 204b 	strb.w	r2, [r5, #75]	; 0x4b
3001824a:	f885 304e 	strb.w	r3, [r5, #78]	; 0x4e
3001824e:	9a25      	ldr	r2, [sp, #148]	; 0x94
30018250:	9b14      	ldr	r3, [sp, #80]	; 0x50
30018252:	f885 0048 	strb.w	r0, [r5, #72]	; 0x48
30018256:	f885 904c 	strb.w	r9, [r5, #76]	; 0x4c
3001825a:	f885 204d 	strb.w	r2, [r5, #77]	; 0x4d
3001825e:	f885 304f 	strb.w	r3, [r5, #79]	; 0x4f
30018262:	462b      	mov	r3, r5
30018264:	f8dd 9024 	ldr.w	r9, [r13, #36]	; 0x24
30018268:	980a      	ldr	r0, [sp, #40]	; 0x28
3001826a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
3001826c:	e001      	b.n	30018272 <write_gpt+0x282>
        total_part++;
3001826e:	3701      	adds	r7, #1
30018270:	3180      	adds	r1, #128	; 0x80
    while (*last_partition_entry != 0 ||
30018272:	e951 4502 	ldrd	r4, r5, [r1, #-8]
30018276:	432c      	orrs	r4, r5
30018278:	d1f9      	bne.n	3001826e <write_gpt+0x27e>
3001827a:	e9d1 4500 	ldrd	r4, r5, [r1]
3001827e:	432c      	orrs	r4, r5
30018280:	d1f5      	bne.n	3001826e <write_gpt+0x27e>
30018282:	461d      	mov	r5, r3
30018284:	4644      	mov	r4, r8
    if (last_part_extend) {
30018286:	9b13      	ldr	r3, [sp, #76]	; 0x4c
30018288:	f8cd 9024 	str.w	r9, [r13, #36]	; 0x24
3001828c:	4691      	mov	r9, r2
3001828e:	b333      	cbz	r3, 300182de <write_gpt+0x2ee>
            (total_part - 1) * PARTITION_ENTRY_SIZE + PARTITION_ENTRY_LAST_LBA;
30018290:	9b36      	ldr	r3, [sp, #216]	; 0xd8
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset,
30018292:	900a      	str	r0, [sp, #40]	; 0x28
30018294:	9a1c      	ldr	r2, [sp, #112]	; 0x70
            (total_part - 1) * PARTITION_ENTRY_SIZE + PARTITION_ENTRY_LAST_LBA;
30018296:	eb03 17c7 	add.w	r7, r3, r7, lsl #7
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset +
3001829a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset,
3001829c:	3f58      	subs	r7, #88	; 0x58
3001829e:	55e0      	strb	r0, [r4, r7]
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset +
300182a0:	eb03 0807 	add.w	r8, r3, r7
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset,
300182a4:	19e3      	adds	r3, r4, r7
300182a6:	981d      	ldr	r0, [sp, #116]	; 0x74
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset +
300182a8:	eb04 0108 	add.w	r1, r4, r8
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset,
300182ac:	705e      	strb	r6, [r3, #1]
300182ae:	f883 c002 	strb.w	r12, [r3, #2]
300182b2:	f883 e003 	strb.w	r14, [r3, #3]
300182b6:	f883 a004 	strb.w	r10, [r3, #4]
300182ba:	715a      	strb	r2, [r3, #5]
300182bc:	7198      	strb	r0, [r3, #6]
300182be:	f883 9007 	strb.w	r9, [r3, #7]
        PUT_LONG_LONG(primary_gpt_header + block_size + last_part_offset +
300182c2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
300182c4:	f804 3008 	strb.w	r3, [r4, r8]
300182c8:	704e      	strb	r6, [r1, #1]
300182ca:	f881 c002 	strb.w	r12, [r1, #2]
300182ce:	f881 e003 	strb.w	r14, [r1, #3]
300182d2:	f881 a004 	strb.w	r10, [r1, #4]
300182d6:	714a      	strb	r2, [r1, #5]
300182d8:	7188      	strb	r0, [r1, #6]
300182da:	f881 9007 	strb.w	r9, [r1, #7]
    crc_value = crc32(0, partition_entry_array_start,
300182de:	e9dd 371f 	ldrd	r3, r7, [r13, #124]	; 0x7c
300182e2:	2000      	movs	r0, #0
300182e4:	f8dd 8038 	ldr.w	r8, [r13, #56]	; 0x38
    PUT_LONG(primary_gpt_header + HEADER_CRC_OFFSET, 0);
300182e8:	4606      	mov	r6, r0
    crc_value = crc32(0, partition_entry_array_start,
300182ea:	4641      	mov	r1, r8
300182ec:	fb07 f703 	mul.w	r7, r7, r3
300182f0:	463a      	mov	r2, r7
300182f2:	f7fa fe31 	bl	30012f58 <crc32>
    crc_value = crc32(0, partition_entry_array_start + array_size,
300182f6:	990c      	ldr	r1, [sp, #48]	; 0x30
300182f8:	4643      	mov	r3, r8
300182fa:	463a      	mov	r2, r7
300182fc:	1859      	adds	r1, r3, r1
    PUT_LONG(primary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
300182fe:	ea4f 2c10 	mov.w	r12, r0, lsr #8
30018302:	0e03      	lsrs	r3, r0, #24
30018304:	f884 c059 	strb.w	r12, [r4, #89]	; 0x59
30018308:	0c07      	lsrs	r7, r0, #16
3001830a:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
    crc_value = crc32(0, partition_entry_array_start + array_size,
3001830e:	4630      	mov	r0, r6
    PUT_LONG(primary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
30018310:	f884 705a 	strb.w	r7, [r4, #90]	; 0x5a
30018314:	f884 305b 	strb.w	r3, [r4, #91]	; 0x5b
    crc_value = crc32(0, partition_entry_array_start + array_size,
30018318:	f7fa fe1e 	bl	30012f58 <crc32>
    crc_value = crc32(0, primary_gpt_header, GPT_HEADER_SIZE);
3001831c:	225c      	movs	r2, #92	; 0x5c
    crc_value = crc32(0, partition_entry_array_start + array_size,
3001831e:	4603      	mov	r3, r0
    crc_value = crc32(0, primary_gpt_header, GPT_HEADER_SIZE);
30018320:	4630      	mov	r0, r6
    PUT_LONG(secondary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
30018322:	f885 3058 	strb.w	r3, [r5, #88]	; 0x58
30018326:	0a1f      	lsrs	r7, r3, #8
30018328:	0c19      	lsrs	r1, r3, #16
3001832a:	f885 7059 	strb.w	r7, [r5, #89]	; 0x59
3001832e:	0e1b      	lsrs	r3, r3, #24
30018330:	f885 105a 	strb.w	r1, [r5, #90]	; 0x5a
    crc_value = crc32(0, primary_gpt_header, GPT_HEADER_SIZE);
30018334:	4621      	mov	r1, r4
    PUT_LONG(secondary_gpt_header + PARTITION_CRC_OFFSET, crc_value);
30018336:	f885 305b 	strb.w	r3, [r5, #91]	; 0x5b
    PUT_LONG(primary_gpt_header + HEADER_CRC_OFFSET, 0);
3001833a:	7426      	strb	r6, [r4, #16]
3001833c:	7466      	strb	r6, [r4, #17]
3001833e:	74a6      	strb	r6, [r4, #18]
30018340:	74e6      	strb	r6, [r4, #19]
    crc_value = crc32(0, primary_gpt_header, GPT_HEADER_SIZE);
30018342:	f7fa fe09 	bl	30012f58 <crc32>
    crc_value = crc32(0, secondary_gpt_header, GPT_HEADER_SIZE);
30018346:	225c      	movs	r2, #92	; 0x5c
    crc_value = crc32(0, primary_gpt_header, GPT_HEADER_SIZE);
30018348:	4603      	mov	r3, r0
    crc_value = crc32(0, secondary_gpt_header, GPT_HEADER_SIZE);
3001834a:	4630      	mov	r0, r6
    PUT_LONG(primary_gpt_header + HEADER_CRC_OFFSET, crc_value);
3001834c:	7423      	strb	r3, [r4, #16]
3001834e:	0c19      	lsrs	r1, r3, #16
30018350:	0a1f      	lsrs	r7, r3, #8
30018352:	74a1      	strb	r1, [r4, #18]
30018354:	0e1b      	lsrs	r3, r3, #24
30018356:	7467      	strb	r7, [r4, #17]
    crc_value = crc32(0, secondary_gpt_header, GPT_HEADER_SIZE);
30018358:	4629      	mov	r1, r5
    PUT_LONG(primary_gpt_header + HEADER_CRC_OFFSET, crc_value);
3001835a:	74e3      	strb	r3, [r4, #19]
    PUT_LONG(secondary_gpt_header + HEADER_CRC_OFFSET, 0);
3001835c:	742e      	strb	r6, [r5, #16]
3001835e:	746e      	strb	r6, [r5, #17]
30018360:	74ae      	strb	r6, [r5, #18]
30018362:	74ee      	strb	r6, [r5, #19]
    crc_value = crc32(0, secondary_gpt_header, GPT_HEADER_SIZE);
30018364:	f7fa fdf8 	bl	30012f58 <crc32>
    PUT_LONG(secondary_gpt_header + HEADER_CRC_OFFSET, crc_value);
30018368:	0a01      	lsrs	r1, r0, #8
3001836a:	0c02      	lsrs	r2, r0, #16
3001836c:	7428      	strb	r0, [r5, #16]
3001836e:	0e03      	lsrs	r3, r0, #24
30018370:	7469      	strb	r1, [r5, #17]
30018372:	74aa      	strb	r2, [r5, #18]
30018374:	74eb      	strb	r3, [r5, #19]
    if (parent_entry) {
30018376:	f1bb 0f00 	cmp.w	r11, #0
3001837a:	f000 80dc 	beq.w	30018536 <write_gpt+0x546>
        partition_offset = parent_entry->first_lba * block_size;
3001837e:	e9db ab08 	ldrd	r10, r11, [r11, #32]
30018382:	9b36      	ldr	r3, [sp, #216]	; 0xd8
30018384:	fbaa 6703 	umull	r6, r7, r10, r3
30018388:	fb03 770b 	mla	r7, r3, r11, r7
    ret = storage->write(storage, partition_offset + part_dev->gpt_offset,
3001838c:	9b08      	ldr	r3, [sp, #32]
3001838e:	9909      	ldr	r1, [sp, #36]	; 0x24
30018390:	4608      	mov	r0, r1
30018392:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
30018396:	e9dd 2310 	ldrd	r2, r3, [r13, #64]	; 0x40
3001839a:	e9cd 2302 	strd	r2, r3, [r13, #8]
3001839e:	eb18 0206 	adds.w	r2, r8, r6
300183a2:	9b12      	ldr	r3, [sp, #72]	; 0x48
300183a4:	9300      	str	r3, [sp, #0]
300183a6:	eb49 0307 	adc.w	r3, r9, r7
300183aa:	68c9      	ldr	r1, [r1, #12]
300183ac:	4788      	blx	r1
    if (ret) {
300183ae:	4680      	mov	r8, r0
300183b0:	2800      	cmp	r0, #0
300183b2:	f040 80c5 	bne.w	30018540 <write_gpt+0x550>
    ret = storage->write(storage,
300183b6:	9b08      	ldr	r3, [sp, #32]
300183b8:	e9dd 8910 	ldrd	r8, r9, [r13, #64]	; 0x40
300183bc:	9909      	ldr	r1, [sp, #36]	; 0x24
300183be:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
300183c2:	4608      	mov	r0, r1
300183c4:	e9cd 8902 	strd	r8, r9, [r13, #8]
300183c8:	9400      	str	r4, [sp, #0]
300183ca:	eb18 0802 	adds.w	r8, r8, r2
300183ce:	68c9      	ldr	r1, [r1, #12]
300183d0:	eb49 0903 	adc.w	r9, r9, r3
300183d4:	eb18 0206 	adds.w	r2, r8, r6
300183d8:	eb49 0307 	adc.w	r3, r9, r7
300183dc:	4788      	blx	r1
    if (ret) {
300183de:	4680      	mov	r8, r0
300183e0:	2800      	cmp	r0, #0
300183e2:	f040 80b4 	bne.w	3001854e <write_gpt+0x55e>
    backup_header_lba = GET_LLWORD_FROM_BYTE
300183e6:	6a26      	ldr	r6, [r4, #32]
    ret = storage->write(storage,
300183e8:	e9dd 2310 	ldrd	r2, r3, [r13, #64]	; 0x40
300183ec:	e9cd 2302 	strd	r2, r3, [r13, #8]
    secondary_header_location = (backup_header_lba + parent_lba) * block_size;
300183f0:	eb16 020a 	adds.w	r2, r6, r10
300183f4:	9e36      	ldr	r6, [sp, #216]	; 0xd8
    ret = storage->write(storage,
300183f6:	9909      	ldr	r1, [sp, #36]	; 0x24
300183f8:	9500      	str	r5, [sp, #0]
300183fa:	4608      	mov	r0, r1
    backup_header_lba = GET_LLWORD_FROM_BYTE
300183fc:	6a67      	ldr	r7, [r4, #36]	; 0x24
    ret = storage->write(storage,
300183fe:	f8d1 c00c 	ldr.w	r12, [r1, #12]
    secondary_header_location = (backup_header_lba + parent_lba) * block_size;
30018402:	9936      	ldr	r1, [sp, #216]	; 0xd8
30018404:	eb47 030b 	adc.w	r3, r7, r11
30018408:	fba2 6706 	umull	r6, r7, r2, r6
3001840c:	fb01 7703 	mla	r7, r1, r3, r7
    ret = storage->write(storage,
30018410:	9b08      	ldr	r3, [sp, #32]
30018412:	e9d3 8902 	ldrd	r8, r9, [r3, #8]
30018416:	eb18 0206 	adds.w	r2, r8, r6
3001841a:	eb49 0307 	adc.w	r3, r9, r7
3001841e:	47e0      	blx	r12
    if (ret) {
30018420:	4680      	mov	r8, r0
30018422:	2800      	cmp	r0, #0
30018424:	d173      	bne.n	3001850e <write_gpt+0x51e>
    ret = write_gpt_partition_array(part_dev, primary_gpt_header,
30018426:	9b36      	ldr	r3, [sp, #216]	; 0xd8
30018428:	4621      	mov	r1, r4
3001842a:	9300      	str	r3, [sp, #0]
3001842c:	e9cd ab02 	strd	r10, r11, [r13, #8]
30018430:	9a0e      	ldr	r2, [sp, #56]	; 0x38
30018432:	9b0c      	ldr	r3, [sp, #48]	; 0x30
30018434:	9808      	ldr	r0, [sp, #32]
30018436:	f7fe f933 	bl	300166a0 <write_gpt_partition_array>
    if (ret) {
3001843a:	4680      	mov	r8, r0
3001843c:	2800      	cmp	r0, #0
3001843e:	d170      	bne.n	30018522 <write_gpt+0x532>
    partition_entry_array_start = primary_gpt_header + block_size +
30018440:	9a1e      	ldr	r2, [sp, #120]	; 0x78
30018442:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ret = write_gpt_partition_array(part_dev, secondary_gpt_header,
30018444:	9936      	ldr	r1, [sp, #216]	; 0xd8
30018446:	9100      	str	r1, [sp, #0]
    partition_entry_array_start = primary_gpt_header + block_size +
30018448:	1ad2      	subs	r2, r2, r3
    ret = write_gpt_partition_array(part_dev, secondary_gpt_header,
3001844a:	e9cd ab02 	strd	r10, r11, [r13, #8]
3001844e:	4422      	add	r2, r4
30018450:	9808      	ldr	r0, [sp, #32]
30018452:	4629      	mov	r1, r5
30018454:	f7fe f924 	bl	300166a0 <write_gpt_partition_array>
    if (ret) {
30018458:	4680      	mov	r8, r0
3001845a:	2800      	cmp	r0, #0
3001845c:	d161      	bne.n	30018522 <write_gpt+0x532>
    part_dev->count = 0;
3001845e:	9d08      	ldr	r5, [sp, #32]
30018460:	462a      	mov	r2, r5
30018462:	6150      	str	r0, [r2, #20]
    ptdev_read_table(part_dev);
30018464:	4628      	mov	r0, r5
30018466:	f7ff fc4f 	bl	30017d08 <ptdev_read_table>
    ptdev_dump(part_dev);
3001846a:	4628      	mov	r0, r5
3001846c:	f7ff fd88 	bl	30017f80 <ptdev_dump>
    dprintf(CRITICAL, "GPT: Partition Table written\n");
30018470:	f641 40d8 	movw	r0, #7384	; 0x1cd8
30018474:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018478:	f7fd fb9a 	bl	30015bb0 <_printf>
    memset(primary_gpt_header, 0x00, size - block_size);
3001847c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
3001847e:	9a36      	ldr	r2, [sp, #216]	; 0xd8
30018480:	4620      	mov	r0, r4
30018482:	4641      	mov	r1, r8
30018484:	1a9a      	subs	r2, r3, r2
30018486:	f7fc ea74 	blx	30014970 <memset>
    return ret;
3001848a:	e005      	b.n	30018498 <write_gpt+0x4a8>
        dprintf(CRITICAL,
3001848c:	f641 4014 	movw	r0, #7188	; 0x1c14
30018490:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018494:	f7fd fb8c 	bl	30015bb0 <_printf>
}
30018498:	4640      	mov	r0, r8
3001849a:	b02d      	add	sp, #180	; 0xb4
3001849c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
300184a0:	4680      	mov	r8, r0
        dprintf(CRITICAL,
300184a2:	f641 30e0 	movw	r0, #7136	; 0x1be0
300184a6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300184aa:	f7fd fb81 	bl	30015bb0 <_printf>
}
300184ae:	4640      	mov	r0, r8
300184b0:	b02d      	add	sp, #180	; 0xb4
300184b2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (card_size_sec == 0) {
300184b6:	23fe      	movs	r3, #254	; 0xfe
300184b8:	227f      	movs	r2, #127	; 0x7f
300184ba:	f8cd 8068 	str.w	r8, [r13, #104]	; 0x68
300184be:	27ff      	movs	r7, #255	; 0xff
300184c0:	e9cd 3214 	strd	r3, r2, [r13, #80]	; 0x50
        card_size_sec = 4 * 1024 * 1024 * 2 - 1;
300184c4:	f64f 72ff 	movw	r2, #65535	; 0xffff
300184c8:	2300      	movs	r3, #0
300184ca:	f2c0 027f 	movt	r2, #127	; 0x7f
    if (card_size_sec == 0) {
300184ce:	e9cd 8818 	strd	r8, r8, [r13, #96]	; 0x60
300184d2:	46bc      	mov	r12, r7
300184d4:	e9cd 8816 	strd	r8, r8, [r13, #88]	; 0x58
        card_size_sec = 4 * 1024 * 1024 * 2 - 1;
300184d8:	4691      	mov	r9, r2
300184da:	469a      	mov	r10, r3
300184dc:	e61b      	b.n	30018116 <write_gpt+0x126>
                           parent_entry->first_lba + 1) * block_size;
300184de:	e9db 230a 	ldrd	r2, r3, [r11, #40]	; 0x28
300184e2:	e9db 0108 	ldrd	r0, r1, [r11, #32]
300184e6:	f112 0801 	adds.w	r8, r2, #1
300184ea:	f143 0900 	adc.w	r9, r3, #0
        device_capacity = (parent_entry->last_lba -
300184ee:	9b36      	ldr	r3, [sp, #216]	; 0xd8
                           parent_entry->first_lba + 1) * block_size;
300184f0:	ebb8 0800 	subs.w	r8, r8, r0
300184f4:	eb69 0901 	sbc.w	r9, r9, r1
        device_capacity = (parent_entry->last_lba -
300184f8:	fba8 2303 	umull	r2, r3, r8, r3
300184fc:	4611      	mov	r1, r2
300184fe:	461a      	mov	r2, r3
30018500:	9b36      	ldr	r3, [sp, #216]	; 0xd8
30018502:	e9cd 120a 	strd	r1, r2, [r13, #40]	; 0x28
30018506:	fb03 2309 	mla	r3, r3, r9, r2
3001850a:	930b      	str	r3, [sp, #44]	; 0x2c
3001850c:	e5a7      	b.n	3001805e <write_gpt+0x6e>
        dprintf(CRITICAL, "Failed to write GPT backup header\n");
3001850e:	f641 4080 	movw	r0, #7296	; 0x1c80
30018512:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018516:	f7fd fb4b 	bl	30015bb0 <_printf>
}
3001851a:	4640      	mov	r0, r8
3001851c:	b02d      	add	sp, #180	; 0xb4
3001851e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL,
30018522:	f641 40a4 	movw	r0, #7332	; 0x1ca4
30018526:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001852a:	f7fd fb41 	bl	30015bb0 <_printf>
}
3001852e:	4640      	mov	r0, r8
30018530:	b02d      	add	sp, #180	; 0xb4
30018532:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    uint64_t partition_offset = 0;
30018536:	2600      	movs	r6, #0
30018538:	2700      	movs	r7, #0
    uint64_t parent_lba = 0;
3001853a:	46b2      	mov	r10, r6
3001853c:	46bb      	mov	r11, r7
3001853e:	e725      	b.n	3001838c <write_gpt+0x39c>
        dprintf(CRITICAL, "Failed to write Protective MBR\n");
30018540:	f641 4044 	movw	r0, #7236	; 0x1c44
30018544:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018548:	f7fd fb32 	bl	30015bb0 <_printf>
        goto end;
3001854c:	e7a4      	b.n	30018498 <write_gpt+0x4a8>
        dprintf(CRITICAL, "Failed to write GPT header\n");
3001854e:	f641 4064 	movw	r0, #7268	; 0x1c64
30018552:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018556:	f7fd fb2b 	bl	30015bb0 <_printf>
        goto end;
3001855a:	e79d      	b.n	30018498 <write_gpt+0x4a8>

3001855c <ptdev_write_table>:
{
3001855c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30018560:	b0af      	sub	sp, #188	; 0xbc
30018562:	f89d 80e0 	ldrb.w	r8, [r13, #224]	; 0xe0
    if (ptable == NULL) {
30018566:	2b00      	cmp	r3, #0
30018568:	f000 80ad 	beq.w	300186c6 <ptdev_write_table+0x16a>
3001856c:	4604      	mov	r4, r0
    if ((!part_dev) || (!part_dev->storage)) {
3001856e:	b1c0      	cbz	r0, 300185a2 <ptdev_write_table+0x46>
30018570:	6805      	ldr	r5, [r0, #0]
30018572:	b1b5      	cbz	r5, 300185a2 <ptdev_write_table+0x46>
30018574:	461e      	mov	r6, r3
30018576:	4617      	mov	r7, r2
    partition_entries = part_dev->partition_entries;
30018578:	6903      	ldr	r3, [r0, #16]
3001857a:	468a      	mov	r10, r1
3001857c:	9305      	str	r3, [sp, #20]
    int index = INVALID_PTN;
3001857e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
    if (name) {
30018582:	2900      	cmp	r1, #0
30018584:	f040 8090 	bne.w	300186a8 <ptdev_write_table+0x14c>
    block_size = storage->get_block_size(storage);
30018588:	6a2b      	ldr	r3, [r5, #32]
3001858a:	4628      	mov	r0, r5
3001858c:	4798      	blx	r3
    if ((TABLE_SIGNATURE + 1) > size) {
3001858e:	f5b7 7fff 	cmp.w	r7, #510	; 0x1fe
30018592:	bf98      	it	ls
30018594:	2501      	movls	r5, #1
    block_size = storage->get_block_size(storage);
30018596:	4683      	mov	r11, r0
    if ((TABLE_SIGNATURE + 1) > size) {
30018598:	d80e      	bhi.n	300185b8 <ptdev_write_table+0x5c>
}
3001859a:	4628      	mov	r0, r5
3001859c:	b02f      	add	sp, #188	; 0xbc
3001859e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "Write Invalide partition\n");
300185a2:	f241 7090 	movw	r0, #6032	; 0x1790
        return 1;
300185a6:	2501      	movs	r5, #1
        dprintf(CRITICAL, "Write Invalide partition\n");
300185a8:	f2c3 0002 	movt	r0, #12290	; 0x3002
300185ac:	f7fd fb00 	bl	30015bb0 <_printf>
}
300185b0:	4628      	mov	r0, r5
300185b2:	b02f      	add	sp, #188	; 0xbc
300185b4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
300185b8:	4630      	mov	r0, r6
300185ba:	f7fe f8f3 	bl	300167a4 <ptdev_verify_mbr_signature.part.0>
    if (!ret) {
300185be:	4605      	mov	r5, r0
300185c0:	2800      	cmp	r0, #0
300185c2:	d1ea      	bne.n	3001859a <ptdev_write_table+0x3e>
        else if (MBR_PROTECTED_TYPE == mbr_partition_type) {
300185c4:	f896 31c2 	ldrb.w	r3, [r6, #450]	; 0x1c2
300185c8:	2bee      	cmp	r3, #238	; 0xee
300185ca:	f000 8087 	beq.w	300186dc <ptdev_write_table+0x180>
    storage_device_t *storage = part_dev->storage;
300185ce:	6825      	ldr	r5, [r4, #0]
300185d0:	4630      	mov	r0, r6
300185d2:	f7fe f8e7 	bl	300167a4 <ptdev_verify_mbr_signature.part.0>
    if (ret) {
300185d6:	2800      	cmp	r0, #0
300185d8:	f040 80c1 	bne.w	3001875e <ptdev_write_table+0x202>
    device_capacity = storage->get_capacity(storage);
300185dc:	69ab      	ldr	r3, [r5, #24]
300185de:	4628      	mov	r0, r5
300185e0:	4798      	blx	r3
    ret = storage->erase(storage, part_dev->gpt_offset,
300185e2:	e9d4 8902 	ldrd	r8, r9, [r4, #8]
300185e6:	4642      	mov	r2, r8
300185e8:	464b      	mov	r3, r9
300185ea:	ebb0 0808 	subs.w	r8, r0, r8
300185ee:	4628      	mov	r0, r5
300185f0:	eb61 0909 	sbc.w	r9, r1, r9
300185f4:	e9cd 8900 	strd	r8, r9, [r13]
300185f8:	6929      	ldr	r1, [r5, #16]
300185fa:	4788      	blx	r1
    if (ret) {
300185fc:	4605      	mov	r5, r0
300185fe:	2800      	cmp	r0, #0
30018600:	f040 808e 	bne.w	30018720 <ptdev_write_table+0x1c4>
    ret = write_mbr_in_blocks(part_dev, size, mbrImage, block_size);
30018604:	f8d4 9000 	ldr.w	r9, [r4]
    ret = storage->write(storage, part_dev->gpt_offset, (uint8_t *)mbrImage,
30018608:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
3001860c:	4648      	mov	r0, r9
3001860e:	e9cd b502 	strd	r11, r5, [r13, #8]
30018612:	9600      	str	r6, [sp, #0]
30018614:	f8d9 100c 	ldr.w	r1, [r9, #12]
30018618:	4788      	blx	r1
    if (ret) {
3001861a:	4680      	mov	r8, r0
3001861c:	2800      	cmp	r0, #0
3001861e:	f040 80a0 	bne.w	30018762 <ptdev_write_table+0x206>
        if (MBR_EBR_TYPE == dtype) {
30018622:	f896 31c2 	ldrb.w	r3, [r6, #450]	; 0x1c2
30018626:	2b05      	cmp	r3, #5
30018628:	f000 8189 	beq.w	3001893e <ptdev_write_table+0x3e2>
3001862c:	f896 31d2 	ldrb.w	r3, [r6, #466]	; 0x1d2
30018630:	2b05      	cmp	r3, #5
30018632:	f000 81ce 	beq.w	300189d2 <ptdev_write_table+0x476>
30018636:	f896 31e2 	ldrb.w	r3, [r6, #482]	; 0x1e2
3001863a:	2b05      	cmp	r3, #5
3001863c:	f000 81c0 	beq.w	300189c0 <ptdev_write_table+0x464>
30018640:	f896 31f2 	ldrb.w	r3, [r6, #498]	; 0x1f2
30018644:	2b05      	cmp	r3, #5
30018646:	f000 81cd 	beq.w	300189e4 <ptdev_write_table+0x488>
    buffer = memalign(block_size, ROUNDUP(block_size, block_size));
3001864a:	ea4f 034b 	mov.w	r3, r11, lsl #1
3001864e:	3b01      	subs	r3, #1
30018650:	4658      	mov	r0, r11
30018652:	f1cb 0100 	rsb	r1, r11, #0
    storage_device_t *storage = part_dev->storage;
30018656:	f8d4 8000 	ldr.w	r8, [r4]
    buffer = memalign(block_size, ROUNDUP(block_size, block_size));
3001865a:	4019      	ands	r1, r3
    struct partition_entry *partition_entries = part_dev->partition_entries;
3001865c:	e9d4 3704 	ldrd	r3, r7, [r4, #16]
30018660:	9305      	str	r3, [sp, #20]
    buffer = memalign(block_size, ROUNDUP(block_size, block_size));
30018662:	f7fc f857 	bl	30014714 <memalign>
    if (!buffer) {
30018666:	4606      	mov	r6, r0
30018668:	2800      	cmp	r0, #0
3001866a:	f000 81ce 	beq.w	30018a0a <ptdev_write_table+0x4ae>
    ret = storage->read(storage, part_dev->gpt_offset, (uint8_t *)buffer,
3001866e:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
30018672:	4640      	mov	r0, r8
30018674:	e9cd b502 	strd	r11, r5, [r13, #8]
30018678:	9600      	str	r6, [sp, #0]
3001867a:	f8d8 1008 	ldr.w	r1, [r8, #8]
3001867e:	4788      	blx	r1
    if (ret) {
30018680:	4681      	mov	r9, r0
30018682:	2800      	cmp	r0, #0
30018684:	d17b      	bne.n	3001877e <ptdev_write_table+0x222>
        free(buffer);
30018686:	4630      	mov	r0, r6
    if ((TABLE_SIGNATURE + 1) > size) {
30018688:	f5bb 7fff 	cmp.w	r11, #510	; 0x1fe
3001868c:	f200 8081 	bhi.w	30018792 <ptdev_write_table+0x236>
30018690:	f04f 0901 	mov.w	r9, #1
        free(buffer);
30018694:	f7fc f87a 	bl	3001478c <free>
        dprintf(CRITICAL, "Failed to re-read mbr partition.\n");
30018698:	f641 00b8 	movw	r0, #6328	; 0x18b8
3001869c:	464d      	mov	r5, r9
3001869e:	f2c3 0002 	movt	r0, #12290	; 0x3002
300186a2:	f7fd fa85 	bl	30015bb0 <_printf>
300186a6:	e778      	b.n	3001859a <ptdev_write_table+0x3e>
        index = ptdev_get_index(part_dev, name);
300186a8:	f7ff fbce 	bl	30017e48 <ptdev_get_index>
300186ac:	4681      	mov	r9, r0
        if (index == INVALID_PTN) {
300186ae:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
300186b2:	f47f af69 	bne.w	30018588 <ptdev_write_table+0x2c>
            dprintf(CRITICAL,
300186b6:	f241 70ac 	movw	r0, #6060	; 0x17ac
            return 1;
300186ba:	2501      	movs	r5, #1
            dprintf(CRITICAL,
300186bc:	f2c3 0002 	movt	r0, #12290	; 0x3002
300186c0:	f7fd fa76 	bl	30015bb0 <_printf>
            return 1;
300186c4:	e769      	b.n	3001859a <ptdev_write_table+0x3e>
        dprintf(CRITICAL, "NULL partition table\n");
300186c6:	f241 7078 	movw	r0, #6008	; 0x1778
        return 1;
300186ca:	2501      	movs	r5, #1
        dprintf(CRITICAL, "NULL partition table\n");
300186cc:	f2c3 0002 	movt	r0, #12290	; 0x3002
300186d0:	f7fd fa6e 	bl	30015bb0 <_printf>
}
300186d4:	4628      	mov	r0, r5
300186d6:	b02f      	add	sp, #188	; 0xbc
300186d8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (index == INVALID_PTN) {
300186dc:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
300186e0:	d02d      	beq.n	3001873e <ptdev_write_table+0x1e2>
                if (!part_dev->partition_entries) {
300186e2:	6923      	ldr	r3, [r4, #16]
300186e4:	b31b      	cbz	r3, 3001872e <ptdev_write_table+0x1d2>
                dprintf(CRITICAL, "Re-Flash the extral partition table %s\n", name);
300186e6:	f641 1020 	movw	r0, #6432	; 0x1920
300186ea:	4651      	mov	r1, r10
300186ec:	f2c3 0002 	movt	r0, #12290	; 0x3002
300186f0:	f7fd fa5e 	bl	30015bb0 <_printf>
                ret = write_gpt(part_dev, &partition_entries[index], size, ptable,
300186f4:	9a05      	ldr	r2, [sp, #20]
300186f6:	f8cd 8004 	str.w	r8, [r13, #4]
300186fa:	eb09 09c9 	add.w	r9, r9, r9, lsl #3
300186fe:	4633      	mov	r3, r6
30018700:	4620      	mov	r0, r4
30018702:	f8cd b000 	str.w	r11, [r13]
30018706:	eb02 1109 	add.w	r1, r2, r9, lsl #4
3001870a:	463a      	mov	r2, r7
3001870c:	f7ff fc70 	bl	30017ff0 <write_gpt>
30018710:	4605      	mov	r5, r0
            dprintf(CRITICAL, "Re-Flash all the partitions\n");
30018712:	f641 1048 	movw	r0, #6472	; 0x1948
30018716:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001871a:	f7fd fa49 	bl	30015bb0 <_printf>
    return ret;
3001871e:	e73c      	b.n	3001859a <ptdev_write_table+0x3e>
        dprintf(CRITICAL, "Failed to erase the eMMC card\n");
30018720:	f241 70e8 	movw	r0, #6120	; 0x17e8
30018724:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018728:	f7fd fa42 	bl	30015bb0 <_printf>
3001872c:	e735      	b.n	3001859a <ptdev_write_table+0x3e>
                    dprintf(CRITICAL, "Write Invalide extral partition\n");
3001872e:	f641 00fc 	movw	r0, #6396	; 0x18fc
                    break;
30018732:	2501      	movs	r5, #1
                    dprintf(CRITICAL, "Write Invalide extral partition\n");
30018734:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018738:	f7fd fa3a 	bl	30015bb0 <_printf>
                    break;
3001873c:	e72d      	b.n	3001859a <ptdev_write_table+0x3e>
                dprintf(CRITICAL, "Re-Flash the global partitions\n");
3001873e:	f641 00dc 	movw	r0, #6364	; 0x18dc
30018742:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018746:	f7fd fa33 	bl	30015bb0 <_printf>
                ret = write_gpt(part_dev, NULL, size, ptable, block_size,
3001874a:	4629      	mov	r1, r5
3001874c:	e9cd b800 	strd	r11, r8, [r13]
30018750:	4633      	mov	r3, r6
30018752:	463a      	mov	r2, r7
30018754:	4620      	mov	r0, r4
30018756:	f7ff fc4b 	bl	30017ff0 <write_gpt>
3001875a:	4605      	mov	r5, r0
3001875c:	e7d9      	b.n	30018712 <ptdev_write_table+0x1b6>
3001875e:	4605      	mov	r5, r0
30018760:	e71b      	b.n	3001859a <ptdev_write_table+0x3e>
        dprintf(CRITICAL, "Failed to write mbr partition\n");
30018762:	f641 0008 	movw	r0, #6152	; 0x1808
30018766:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001876a:	f7fd fa21 	bl	30015bb0 <_printf>
        dprintf(CRITICAL, "Failed to write MBR block to boot device.\n");
3001876e:	f641 1068 	movw	r0, #6504	; 0x1968
30018772:	4645      	mov	r5, r8
30018774:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018778:	f7fd fa1a 	bl	30015bb0 <_printf>
3001877c:	e70d      	b.n	3001859a <ptdev_write_table+0x3e>
        dprintf(CRITICAL, "Could not read partition from boot device\n");
3001877e:	f641 008c 	movw	r0, #6284	; 0x188c
30018782:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018786:	f7fd fa13 	bl	30015bb0 <_printf>
        free(buffer);
3001878a:	4630      	mov	r0, r6
3001878c:	f7fb fffe 	bl	3001478c <free>
30018790:	e782      	b.n	30018698 <ptdev_write_table+0x13c>
30018792:	f7fe f807 	bl	300167a4 <ptdev_verify_mbr_signature.part.0>
30018796:	4605      	mov	r5, r0
    ret = ptdev_verify_mbr_signature(block_size, buffer);
30018798:	4681      	mov	r9, r0
    if (ret) {
3001879a:	2800      	cmp	r0, #0
3001879c:	d1f5      	bne.n	3001878a <ptdev_write_table+0x22e>
3001879e:	1d3a      	adds	r2, r7, #4
            GET_LWORD_FROM_BYTE(&buffer[idx +
300187a0:	f8cd b01c 	str.w	r11, [r13, #28]
300187a4:	eb07 03c7 	add.w	r3, r7, r7, lsl #3
300187a8:	9206      	str	r2, [sp, #24]
300187aa:	46b1      	mov	r9, r6
300187ac:	9a05      	ldr	r2, [sp, #20]
300187ae:	46ba      	mov	r10, r7
300187b0:	f8cd 8020 	str.w	r8, [r13, #32]
300187b4:	46a0      	mov	r8, r4
300187b6:	eb02 1303 	add.w	r3, r2, r3, lsl #4
300187ba:	469b      	mov	r11, r3
        dtype = buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_TYPE];
300187bc:	f899 41c2 	ldrb.w	r4, [r9, #450]	; 0x1c2
        mbr_fill_name(&partition_entries[partition_count],
300187c0:	4658      	mov	r0, r11
        if (dtype == MBR_PROTECTED_TYPE) {
300187c2:	2cee      	cmp	r4, #238	; 0xee
        mbr_fill_name(&partition_entries[partition_count],
300187c4:	4621      	mov	r1, r4
        partition_count++;
300187c6:	f10a 0a01 	add.w	r10, r10, #1
        if (dtype == MBR_PROTECTED_TYPE) {
300187ca:	f000 8114 	beq.w	300189f6 <ptdev_write_table+0x49a>
        current_entry = partition_entries ? &partition_entries[partition_count] :
300187ce:	9b05      	ldr	r3, [sp, #20]
300187d0:	f109 0910 	add.w	r9, r9, #16
300187d4:	2b00      	cmp	r3, #0
300187d6:	bf18      	it	ne
300187d8:	46dc      	movne	r12, r11
300187da:	ab0a      	add	r3, sp, #40	; 0x28
300187dc:	bf08      	it	eq
300187de:	469c      	moveq	r12, r3
            buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_STATUS];
300187e0:	2300      	movs	r3, #0
300187e2:	f10b 0b90 	add.w	r11, r11, #144	; 0x90
        current_entry->dtype = dtype;
300187e6:	f8cc 4080 	str.w	r4, [r12, #128]	; 0x80
            buffer[idx + i * TABLE_ENTRY_SIZE + OFFSET_STATUS];
300187ea:	f899 21ae 	ldrb.w	r2, [r9, #430]	; 0x1ae
300187ee:	e9cc 230c 	strd	r2, r3, [r12, #48]	; 0x30
            GET_LWORD_FROM_BYTE(&buffer[idx +
300187f2:	f899 31b8 	ldrb.w	r3, [r9, #440]	; 0x1b8
300187f6:	041b      	lsls	r3, r3, #16
300187f8:	f899 21b7 	ldrb.w	r2, [r9, #439]	; 0x1b7
300187fc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
30018800:	f899 71b6 	ldrb.w	r7, [r9, #438]	; 0x1b6
30018804:	433b      	orrs	r3, r7
30018806:	f899 71b9 	ldrb.w	r7, [r9, #441]	; 0x1b9
3001880a:	ea43 6707 	orr.w	r7, r3, r7, lsl #24
3001880e:	2300      	movs	r3, #0
30018810:	e9cc 7308 	strd	r7, r3, [r12, #32]
            GET_LWORD_FROM_BYTE(&buffer[idx +
30018814:	f899 31bc 	ldrb.w	r3, [r9, #444]	; 0x1bc
30018818:	041b      	lsls	r3, r3, #16
3001881a:	f899 21bb 	ldrb.w	r2, [r9, #443]	; 0x1bb
3001881e:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
30018822:	f899 31ba 	ldrb.w	r3, [r9, #442]	; 0x1ba
30018826:	4313      	orrs	r3, r2
30018828:	f899 21bd 	ldrb.w	r2, [r9, #445]	; 0x1bd
3001882c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
30018830:	2200      	movs	r2, #0
30018832:	f8cc 3088 	str.w	r3, [r12, #136]	; 0x88
30018836:	f8cc 208c 	str.w	r2, [r12, #140]	; 0x8c
        mbr_fill_name(&partition_entries[partition_count],
3001883a:	f7fd ff5f 	bl	300166fc <mbr_fill_name>
        if (partition_count == NUM_PARTITIONS)
3001883e:	f1ba 0f80 	cmp.w	r10, #128	; 0x80
30018842:	f000 80e0 	beq.w	30018a06 <ptdev_write_table+0x4aa>
    for (i = 0; i < 4; i++) {
30018846:	9b06      	ldr	r3, [sp, #24]
30018848:	459a      	cmp	r10, r3
3001884a:	d1b7      	bne.n	300187bc <ptdev_write_table+0x260>
3001884c:	9706      	str	r7, [sp, #24]
3001884e:	463b      	mov	r3, r7
30018850:	f8dd b01c 	ldr.w	r11, [r13, #28]
30018854:	4657      	mov	r7, r10
30018856:	46a2      	mov	r10, r4
30018858:	4644      	mov	r4, r8
3001885a:	f8dd 8020 	ldr.w	r8, [r13, #32]
    if (dtype != MBR_EBR_TYPE) {
3001885e:	f1ba 0f05 	cmp.w	r10, #5
    part_dev->count = partition_count;
30018862:	6167      	str	r7, [r4, #20]
    if (dtype != MBR_EBR_TYPE) {
30018864:	d162      	bne.n	3001892c <ptdev_write_table+0x3d0>
                        (EBR_first_sec * block_size) + part_dev->gpt_offset,
30018866:	fb03 fc0b 	mul.w	r12, r3, r11
    ret = storage->read(storage,
3001886a:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
3001886e:	2300      	movs	r3, #0
30018870:	f8cd b008 	str.w	r11, [r13, #8]
30018874:	4640      	mov	r0, r8
30018876:	9303      	str	r3, [sp, #12]
30018878:	eb11 090c 	adds.w	r9, r1, r12
3001887c:	9600      	str	r6, [sp, #0]
3001887e:	f142 0a00 	adc.w	r10, r2, #0
30018882:	4653      	mov	r3, r10
30018884:	464a      	mov	r2, r9
30018886:	f8d8 1008 	ldr.w	r1, [r8, #8]
3001888a:	4788      	blx	r1
    if (ret)
3001888c:	2800      	cmp	r0, #0
3001888e:	d154      	bne.n	3001893a <ptdev_write_table+0x3de>
30018890:	e9dd 3905 	ldrd	r3, r9, [r13, #20]
30018894:	f04f 0a90 	mov.w	r10, #144	; 0x90
30018898:	e9cd 3508 	strd	r3, r5, [r13, #32]
                                                      OFFSET_FIRST_SEC]) +
3001889c:	9007      	str	r0, [sp, #28]
3001889e:	fb0a 3a07 	mla	r10, r10, r7, r3
300188a2:	4623      	mov	r3, r4
300188a4:	465c      	mov	r4, r11
300188a6:	9305      	str	r3, [sp, #20]
300188a8:	e019      	b.n	300188de <ptdev_write_table+0x382>
        dfirstsec =
300188aa:	f8d6 31d6 	ldr.w	r3, [r6, #470]	; 0x1d6
        ret = storage->read(storage, ((EBR_first_sec + dfirstsec) * block_size) +
300188ae:	9a06      	ldr	r2, [sp, #24]
300188b0:	eb02 0903 	add.w	r9, r2, r3
        if (dfirstsec == 0) {
300188b4:	2b00      	cmp	r3, #0
300188b6:	d037      	beq.n	30018928 <ptdev_write_table+0x3cc>
        ret = storage->read(storage, ((EBR_first_sec + dfirstsec) * block_size) +
300188b8:	9a05      	ldr	r2, [sp, #20]
300188ba:	2500      	movs	r5, #0
300188bc:	fb09 f304 	mul.w	r3, r9, r4
300188c0:	e9d2 1202 	ldrd	r1, r2, [r2, #8]
300188c4:	9402      	str	r4, [sp, #8]
300188c6:	9503      	str	r5, [sp, #12]
300188c8:	eb11 0b03 	adds.w	r11, r1, r3
300188cc:	9600      	str	r6, [sp, #0]
300188ce:	f142 0c00 	adc.w	r12, r2, #0
300188d2:	4663      	mov	r3, r12
300188d4:	465a      	mov	r2, r11
300188d6:	f8d8 1008 	ldr.w	r1, [r8, #8]
300188da:	4788      	blx	r1
        if (ret)
300188dc:	bb68      	cbnz	r0, 3001893a <ptdev_write_table+0x3de>
300188de:	4630      	mov	r0, r6
        partition_count++;
300188e0:	3701      	adds	r7, #1
300188e2:	f7fd ff5f 	bl	300167a4 <ptdev_verify_mbr_signature.part.0>
        if (ret) {
300188e6:	b9f8      	cbnz	r0, 30018928 <ptdev_write_table+0x3cc>
        current_entry = partition_entries ? &partition_entries[partition_count] :
300188e8:	9b08      	ldr	r3, [sp, #32]
            buffer[TABLE_ENTRY_0 + OFFSET_STATUS];
300188ea:	2200      	movs	r2, #0
300188ec:	f896 11be 	ldrb.w	r1, [r6, #446]	; 0x1be
                                                      OFFSET_FIRST_SEC]) +
300188f0:	9d07      	ldr	r5, [sp, #28]
        mbr_fill_name(&(partition_entries[partition_count]),
300188f2:	4650      	mov	r0, r10
        current_entry = partition_entries ? &partition_entries[partition_count] :
300188f4:	2b00      	cmp	r3, #0
300188f6:	ab0a      	add	r3, sp, #40	; 0x28
300188f8:	bf18      	it	ne
300188fa:	4653      	movne	r3, r10
300188fc:	f10a 0a90 	add.w	r10, r10, #144	; 0x90
            buffer[TABLE_ENTRY_0 + OFFSET_STATUS];
30018900:	e9c3 120c 	strd	r1, r2, [r3, #48]	; 0x30
            buffer[TABLE_ENTRY_0 + OFFSET_TYPE];
30018904:	f896 11c2 	ldrb.w	r1, [r6, #450]	; 0x1c2
        current_entry->dtype =
30018908:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
            GET_LWORD_FROM_BYTE(&buffer[TABLE_ENTRY_0 +
3001890c:	f8d6 21c6 	ldr.w	r2, [r6, #454]	; 0x1c6
                                                      OFFSET_FIRST_SEC]) +
30018910:	625d      	str	r5, [r3, #36]	; 0x24
30018912:	444a      	add	r2, r9
30018914:	621a      	str	r2, [r3, #32]
            GET_LWORD_FROM_BYTE(&buffer[TABLE_ENTRY_0 + OFFSET_SIZE]);
30018916:	f8d6 21ca 	ldr.w	r2, [r6, #458]	; 0x1ca
3001891a:	e9c3 2522 	strd	r2, r5, [r3, #136]	; 0x88
        mbr_fill_name(&(partition_entries[partition_count]),
3001891e:	f7fd feed 	bl	300166fc <mbr_fill_name>
        ret = storage->read(storage, ((EBR_first_sec + dfirstsec) * block_size) +
30018922:	4640      	mov	r0, r8
        if (partition_count == NUM_PARTITIONS)
30018924:	2f80      	cmp	r7, #128	; 0x80
30018926:	d1c0      	bne.n	300188aa <ptdev_write_table+0x34e>
30018928:	9d09      	ldr	r5, [sp, #36]	; 0x24
3001892a:	9c05      	ldr	r4, [sp, #20]
        free(buffer);
3001892c:	4630      	mov	r0, r6
3001892e:	f7fb ff2d 	bl	3001478c <free>
    ptdev_dump(part_dev);
30018932:	4620      	mov	r0, r4
30018934:	f7ff fb24 	bl	30017f80 <ptdev_dump>
30018938:	e62f      	b.n	3001859a <ptdev_write_table+0x3e>
3001893a:	4681      	mov	r9, r0
3001893c:	e725      	b.n	3001878a <ptdev_write_table+0x22e>
        if (MBR_EBR_TYPE == dtype) {
3001893e:	f240 13c9 	movw	r3, #457	; 0x1c9
30018942:	f44f 70e4 	mov.w	r0, #456	; 0x1c8
30018946:	f240 11c7 	movw	r1, #455	; 0x1c7
3001894a:	f44f 72e3 	mov.w	r2, #454	; 0x1c6
        GET_LWORD_FROM_BYTE(&mbrImage
3001894e:	f816 a000 	ldrb.w	r10, [r6, r0]
30018952:	ea4f 4a0a 	mov.w	r10, r10, lsl #16
    lastAddress = mbrImage + size;
30018956:	4437      	add	r7, r6
        GET_LWORD_FROM_BYTE(&mbrImage
30018958:	5cf3      	ldrb	r3, [r6, r3]
3001895a:	5c71      	ldrb	r1, [r6, r1]
3001895c:	5cb2      	ldrb	r2, [r6, r2]
3001895e:	ea4a 2a01 	orr.w	r10, r10, r1, lsl #8
    ebrImage = mbrImage + block_size;
30018962:	445e      	add	r6, r11
    while (ebrImage < lastAddress) {
30018964:	42be      	cmp	r6, r7
        GET_LWORD_FROM_BYTE(&mbrImage
30018966:	ea4a 0a02 	orr.w	r10, r10, r2
    ebrSectorOffset =
3001896a:	ea4a 6a03 	orr.w	r10, r10, r3, lsl #24
3001896e:	bf3e      	ittt	cc
30018970:	463b      	movcc	r3, r7
30018972:	465f      	movcc	r7, r11
30018974:	469b      	movcc	r11, r3
    while (ebrImage < lastAddress) {
30018976:	d305      	bcc.n	30018984 <ptdev_write_table+0x428>
30018978:	e667      	b.n	3001864a <ptdev_write_table+0xee>
        dfirstsec =
3001897a:	f8d6 81d6 	ldr.w	r8, [r6, #470]	; 0x1d6
        ebrImage += block_size;
3001897e:	443e      	add	r6, r7
    while (ebrImage < lastAddress) {
30018980:	45b3      	cmp	r11, r6
30018982:	d91b      	bls.n	300189bc <ptdev_write_table+0x460>
            storage->write(storage, (ebrSectorOffset + dfirstsec) * block_size +
30018984:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
30018988:	eb0a 0108 	add.w	r1, r10, r8
3001898c:	e9cd 7502 	strd	r7, r5, [r13, #8]
30018990:	4648      	mov	r0, r9
30018992:	fb07 f101 	mul.w	r1, r7, r1
30018996:	9600      	str	r6, [sp, #0]
30018998:	1852      	adds	r2, r2, r1
3001899a:	f8d9 100c 	ldr.w	r1, [r9, #12]
3001899e:	f143 0300 	adc.w	r3, r3, #0
300189a2:	4788      	blx	r1
        if (ret) {
300189a4:	2800      	cmp	r0, #0
300189a6:	d0e8      	beq.n	3001897a <ptdev_write_table+0x41e>
300189a8:	4603      	mov	r3, r0
            dprintf(CRITICAL,
300189aa:	f641 0028 	movw	r0, #6184	; 0x1828
300189ae:	4641      	mov	r1, r8
300189b0:	f2c3 0002 	movt	r0, #12290	; 0x3002
        ret =
300189b4:	4698      	mov	r8, r3
            dprintf(CRITICAL,
300189b6:	f7fd f8fb 	bl	30015bb0 <_printf>
300189ba:	e6d8      	b.n	3001876e <ptdev_write_table+0x212>
300189bc:	46bb      	mov	r11, r7
300189be:	e644      	b.n	3001864a <ptdev_write_table+0xee>
        if (MBR_EBR_TYPE == dtype) {
300189c0:	f240 13e9 	movw	r3, #489	; 0x1e9
300189c4:	f44f 70f4 	mov.w	r0, #488	; 0x1e8
300189c8:	f240 11e7 	movw	r1, #487	; 0x1e7
300189cc:	f44f 72f3 	mov.w	r2, #486	; 0x1e6
300189d0:	e7bd      	b.n	3001894e <ptdev_write_table+0x3f2>
300189d2:	f240 13d9 	movw	r3, #473	; 0x1d9
300189d6:	f44f 70ec 	mov.w	r0, #472	; 0x1d8
300189da:	f240 11d7 	movw	r1, #471	; 0x1d7
300189de:	f44f 72eb 	mov.w	r2, #470	; 0x1d6
300189e2:	e7b4      	b.n	3001894e <ptdev_write_table+0x3f2>
300189e4:	f240 13f9 	movw	r3, #505	; 0x1f9
300189e8:	f44f 70fc 	mov.w	r0, #504	; 0x1f8
300189ec:	f240 11f7 	movw	r1, #503	; 0x1f7
300189f0:	f44f 72fb 	mov.w	r2, #502	; 0x1f6
300189f4:	e7ab      	b.n	3001894e <ptdev_write_table+0x3f2>
            part_dev->gpt_partitions_exist = true;
300189f6:	2301      	movs	r3, #1
        free(buffer);
300189f8:	4630      	mov	r0, r6
300189fa:	4644      	mov	r4, r8
            part_dev->gpt_partitions_exist = true;
300189fc:	f888 301e 	strb.w	r3, [r8, #30]
        free(buffer);
30018a00:	f7fb fec4 	bl	3001478c <free>
30018a04:	e795      	b.n	30018932 <ptdev_write_table+0x3d6>
30018a06:	4644      	mov	r4, r8
30018a08:	e790      	b.n	3001892c <ptdev_write_table+0x3d0>
        dprintf(CRITICAL,
30018a0a:	f641 0054 	movw	r0, #6228	; 0x1854
    return ret;
30018a0e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
        dprintf(CRITICAL,
30018a12:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018a16:	f7fd f8cb 	bl	30015bb0 <_printf>
30018a1a:	e63d      	b.n	30018698 <ptdev_write_table+0x13c>

30018a1c <ptdev_setup>:
}

partition_device_t *ptdev_setup(storage_device_t *storage,
                                uint64_t gpt_offset)
{
    if (!storage) {
30018a1c:	b158      	cbz	r0, 30018a36 <ptdev_setup+0x1a>
{
30018a1e:	b5d0      	push	{r4, r6, r7, r14}
        return NULL;
    }

    partition_device_t *part_dev = calloc(1, sizeof(partition_device_t));
30018a20:	2120      	movs	r1, #32
30018a22:	4604      	mov	r4, r0
30018a24:	2001      	movs	r0, #1
30018a26:	4616      	mov	r6, r2
30018a28:	461f      	mov	r7, r3
30018a2a:	f7fb fe8f 	bl	3001474c <calloc>
    part_dev->storage = storage;
30018a2e:	6004      	str	r4, [r0, #0]
    part_dev->gpt_offset = gpt_offset;
30018a30:	e9c0 6702 	strd	r6, r7, [r0, #8]

    return part_dev;
}
30018a34:	bdd0      	pop	{r4, r6, r7, r15}
30018a36:	4770      	bx	r14

30018a38 <ptdev_activate_slot>:
    struct partition_entry *partition_entries;
    int count;
    char *pname;
    char *suffix_str = NULL;

    if ((!part_dev) || (!part_dev->partition_entries)) {
30018a38:	2800      	cmp	r0, #0
30018a3a:	d049      	beq.n	30018ad0 <ptdev_activate_slot+0x98>
30018a3c:	6902      	ldr	r2, [r0, #16]
{
30018a3e:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    if ((!part_dev) || (!part_dev->partition_entries)) {
30018a42:	2a00      	cmp	r2, #0
30018a44:	d03c      	beq.n	30018ac0 <ptdev_activate_slot+0x88>
30018a46:	460e      	mov	r6, r1
        dprintf(CRITICAL, "Invalide partition dev\n");
        return;
    }

    if ( (slot != SLOT_A) && (slot != SLOT_B)) {
30018a48:	2901      	cmp	r1, #1
30018a4a:	d907      	bls.n	30018a5c <ptdev_activate_slot+0x24>
        dprintf(CRITICAL, "ERROR: slot= %d  wrong slot number\n", slot);
30018a4c:	f641 5064 	movw	r0, #7524	; 0x1d64
30018a50:	f2c3 0002 	movt	r0, #12290	; 0x3002
                                                    PART_ATT_MAX_RETRY_COUNT_VAL);
        }
    }

    return;
}
30018a54:	e8bd 43f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        dprintf(CRITICAL, "ERROR: slot= %d  wrong slot number\n", slot);
30018a58:	f7fd b8aa 	b.w	30015bb0 <_printf>
    count = part_dev->count;
30018a5c:	6945      	ldr	r5, [r0, #20]
    partition_entries = ptdev_get_partition_entries(part_dev);
30018a5e:	f7ff f945 	bl	30017cec <ptdev_get_partition_entries>
    for (int i = 0; i < count; i++) {
30018a62:	2d00      	cmp	r5, #0
30018a64:	dd23      	ble.n	30018aae <ptdev_activate_slot+0x76>
            suffix_str = strstr(pname, SUFFIX_SLOT(j));
30018a66:	f245 473c 	movw	r7, #21564	; 0x543c
30018a6a:	eb05 05c5 	add.w	r5, r5, r5, lsl #3
30018a6e:	f2c3 0702 	movt	r7, #12290	; 0x3002
30018a72:	eb00 1505 	add.w	r5, r0, r5, lsl #4
30018a76:	3538      	adds	r5, #56	; 0x38
30018a78:	f8d7 9000 	ldr.w	r9, [r7]
30018a7c:	f100 0438 	add.w	r4, r0, #56	; 0x38
30018a80:	f8d7 8004 	ldr.w	r8, [r7, #4]
30018a84:	4649      	mov	r1, r9
30018a86:	4620      	mov	r0, r4
30018a88:	f7fd f9bc 	bl	30015e04 <strstr>
30018a8c:	4641      	mov	r1, r8
            if (suffix_str)
30018a8e:	b980      	cbnz	r0, 30018ab2 <ptdev_activate_slot+0x7a>
            suffix_str = strstr(pname, SUFFIX_SLOT(j));
30018a90:	4620      	mov	r0, r4
30018a92:	f7fd f9b7 	bl	30015e04 <strstr>
            if (suffix_str)
30018a96:	b960      	cbnz	r0, 30018ab2 <ptdev_activate_slot+0x7a>
            CLR_BIT(partition_entries[i].attribute_flag, PART_ATT_SUCCESS_BIT);
30018a98:	e954 2302 	ldrd	r2, r3, [r4, #-8]
30018a9c:	f423 0140 	bic.w	r1, r3, #12582912	; 0xc00000
            partition_entries[i].attribute_flag |= (PART_ATT_PRIORITY_VAL |
30018aa0:	f441 13f8 	orr.w	r3, r1, #2031616	; 0x1f0000
30018aa4:	e944 2302 	strd	r2, r3, [r4, #-8]
30018aa8:	3490      	adds	r4, #144	; 0x90
    for (int i = 0; i < count; i++) {
30018aaa:	42a5      	cmp	r5, r4
30018aac:	d1ea      	bne.n	30018a84 <ptdev_activate_slot+0x4c>
}
30018aae:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            if (!strcmp(suffix_str, SUFFIX_SLOT(slot))) {
30018ab2:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
30018ab6:	f7fd f8c9 	bl	30015c4c <strcmp>
30018aba:	2800      	cmp	r0, #0
30018abc:	d0ec      	beq.n	30018a98 <ptdev_activate_slot+0x60>
30018abe:	e7f3      	b.n	30018aa8 <ptdev_activate_slot+0x70>
        dprintf(CRITICAL, "Invalide partition dev\n");
30018ac0:	f641 50b4 	movw	r0, #7604	; 0x1db4
30018ac4:	f2c3 0002 	movt	r0, #12290	; 0x3002
}
30018ac8:	e8bd 43f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        dprintf(CRITICAL, "Invalide partition dev\n");
30018acc:	f7fd b870 	b.w	30015bb0 <_printf>
30018ad0:	f641 50b4 	movw	r0, #7604	; 0x1db4
30018ad4:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018ad8:	f7fd b86a 	b.w	30015bb0 <_printf>

30018adc <ptdev_scan_for_multislot>:
    Function scan boot partition to find SLOT_A/SLOT_B suffix.
    If found than make multislot_boot flag true and
    scans another partition.
*/
bool ptdev_scan_for_multislot(partition_device_t *part_dev)
{
30018adc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30018ae0:	b087      	sub	sp, #28
    int j, len, count;
    char *tmp1, *tmp2;
    int partition_count;
    struct partition_entry *partition_entries;

    if ((!part_dev) || (!part_dev->partition_entries)) {
30018ae2:	9005      	str	r0, [sp, #20]
30018ae4:	2800      	cmp	r0, #0
30018ae6:	d069      	beq.n	30018bbc <ptdev_scan_for_multislot+0xe0>
30018ae8:	6903      	ldr	r3, [r0, #16]
30018aea:	2b00      	cmp	r3, #0
30018aec:	d066      	beq.n	30018bbc <ptdev_scan_for_multislot+0xe0>
        dprintf(CRITICAL, "Invalide partition dev\n");
        return 0;
    }

    partition_count = ptdev_get_partition_count(part_dev);
30018aee:	f7ff f8ef 	bl	30017cd0 <ptdev_get_partition_count>
    partition_entries = ptdev_get_partition_entries(part_dev);
30018af2:	9d05      	ldr	r5, [sp, #20]
    partition_count = ptdev_get_partition_count(part_dev);
30018af4:	4604      	mov	r4, r0
    partition_entries = ptdev_get_partition_entries(part_dev);
30018af6:	4628      	mov	r0, r5
30018af8:	f7ff f8f8 	bl	30017cec <ptdev_get_partition_entries>

    /* Intialize all slot specific variables */
    part_dev->multislot_support = false;
30018afc:	2300      	movs	r3, #0
    part_dev->active_slot = INVALID;
30018afe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    part_dev->attributes_updated = false;

    if (partition_count > NUM_PARTITIONS) {
30018b02:	2c80      	cmp	r4, #128	; 0x80
    part_dev->multislot_support = false;
30018b04:	776b      	strb	r3, [r5, #29]
    part_dev->attributes_updated = false;
30018b06:	772b      	strb	r3, [r5, #28]
    part_dev->active_slot = INVALID;
30018b08:	61aa      	str	r2, [r5, #24]
    if (partition_count > NUM_PARTITIONS) {
30018b0a:	dc67      	bgt.n	30018bdc <ptdev_scan_for_multislot+0x100>
        dprintf(CRITICAL, "ERROR: partition_count more than supported.\n");
        return part_dev->multislot_support;
    }

    int scan_nr = partition_count > MAX_NR_SCAN_FOR_SLOT ? MAX_NR_SCAN_FOR_SLOT
30018b0c:	46a0      	mov	r8, r4
30018b0e:	2c10      	cmp	r4, #16
30018b10:	bfa8      	it	ge
30018b12:	f04f 0810 	movge.w	r8, #16
                  : partition_count;

    for (int m = 0; m < scan_nr; m++) {
30018b16:	2c00      	cmp	r4, #0
30018b18:	dd56      	ble.n	30018bc8 <ptdev_scan_for_multislot+0xec>
                tmp1 = tmp1 + len - 2;
                tmp2 = (char *)(partition_entries[x].name + len - 2);
                count = 0;

                for (j = 0; j < AB_SUPPORTED_SLOTS; j++) {
                    if (!strcmp(tmp1, suffix_slot[j]) || !strcmp(tmp2, suffix_slot[j]))
30018b1a:	f245 423c 	movw	r2, #21564	; 0x543c
30018b1e:	f100 0138 	add.w	r1, r0, #56	; 0x38
    for (int m = 0; m < scan_nr; m++) {
30018b22:	9303      	str	r3, [sp, #12]
                    if (!strcmp(tmp1, suffix_slot[j]) || !strcmp(tmp2, suffix_slot[j]))
30018b24:	f2c3 0202 	movt	r2, #12290	; 0x3002
30018b28:	9102      	str	r1, [sp, #8]
30018b2a:	e9d2 9a00 	ldrd	r9, r10, [r2]
        for (int x = m + 1; x < scan_nr; x++) {
30018b2e:	9b03      	ldr	r3, [sp, #12]
        len = strlen(tmp1);
30018b30:	9c02      	ldr	r4, [sp, #8]
30018b32:	4620      	mov	r0, r4
        for (int x = m + 1; x < scan_nr; x++) {
30018b34:	1c5d      	adds	r5, r3, #1
        tmp1 = (char *)partition_entries[m].name;
30018b36:	4626      	mov	r6, r4
        for (int x = m + 1; x < scan_nr; x++) {
30018b38:	9504      	str	r5, [sp, #16]
        len = strlen(tmp1);
30018b3a:	f7fd f8f9 	bl	30015d30 <strlen>
        for (int x = m + 1; x < scan_nr; x++) {
30018b3e:	45a8      	cmp	r8, r5
30018b40:	dd42      	ble.n	30018bc8 <ptdev_scan_for_multislot+0xec>
30018b42:	3490      	adds	r4, #144	; 0x90
30018b44:	1e87      	subs	r7, r0, #2
30018b46:	9402      	str	r4, [sp, #8]
30018b48:	e004      	b.n	30018b54 <ptdev_scan_for_multislot+0x78>
30018b4a:	3501      	adds	r5, #1
30018b4c:	45a8      	cmp	r8, r5
30018b4e:	f104 0490 	add.w	r4, r4, #144	; 0x90
30018b52:	d040      	beq.n	30018bd6 <ptdev_scan_for_multislot+0xfa>
            if (!strncmp((const char *)tmp1, (char *)partition_entries[x].name,
30018b54:	463a      	mov	r2, r7
30018b56:	4621      	mov	r1, r4
30018b58:	4630      	mov	r0, r6
30018b5a:	f7fd f903 	bl	30015d64 <strncmp>
30018b5e:	4683      	mov	r11, r0
30018b60:	2800      	cmp	r0, #0
30018b62:	d1f2      	bne.n	30018b4a <ptdev_scan_for_multislot+0x6e>
30018b64:	193b      	adds	r3, r7, r4
                    if (!strcmp(tmp1, suffix_slot[j]) || !strcmp(tmp2, suffix_slot[j]))
30018b66:	4649      	mov	r1, r9
                tmp1 = tmp1 + len - 2;
30018b68:	443e      	add	r6, r7
30018b6a:	9301      	str	r3, [sp, #4]
                    if (!strcmp(tmp1, suffix_slot[j]) || !strcmp(tmp2, suffix_slot[j]))
30018b6c:	4630      	mov	r0, r6
30018b6e:	f7fd f86d 	bl	30015c4c <strcmp>
30018b72:	4649      	mov	r1, r9
30018b74:	b360      	cbz	r0, 30018bd0 <ptdev_scan_for_multislot+0xf4>
30018b76:	1938      	adds	r0, r7, r4
30018b78:	f7fd f868 	bl	30015c4c <strcmp>
                        count++;
30018b7c:	2800      	cmp	r0, #0
30018b7e:	bf08      	it	eq
30018b80:	f04f 0b01 	moveq.w	r11, #1
                    if (!strcmp(tmp1, suffix_slot[j]) || !strcmp(tmp2, suffix_slot[j]))
30018b84:	4651      	mov	r1, r10
30018b86:	4630      	mov	r0, r6
30018b88:	f7fd f860 	bl	30015c4c <strcmp>
30018b8c:	4651      	mov	r1, r10
30018b8e:	b120      	cbz	r0, 30018b9a <ptdev_scan_for_multislot+0xbe>
30018b90:	1938      	adds	r0, r7, r4
30018b92:	f7fd f85b 	bl	30015c4c <strcmp>
30018b96:	2800      	cmp	r0, #0
30018b98:	d1d7      	bne.n	30018b4a <ptdev_scan_for_multislot+0x6e>
                }

                /* Break out of loop if all slot index are found*/
                if (count == AB_SUPPORTED_SLOTS) {
30018b9a:	f1bb 0f01 	cmp.w	r11, #1
30018b9e:	d1d4      	bne.n	30018b4a <ptdev_scan_for_multislot+0x6e>
                    part_dev->multislot_support = true;
                    boot_slot_index[0] = m;
30018ba0:	f64d 0270 	movw	r2, #55408	; 0xd870
                    boot_slot_index[1] = x;
30018ba4:	4658      	mov	r0, r11
                    part_dev->multislot_support = true;
30018ba6:	9b05      	ldr	r3, [sp, #20]
                    boot_slot_index[0] = m;
30018ba8:	f2c3 0202 	movt	r2, #12290	; 0x3002
                    part_dev->multislot_support = true;
30018bac:	f883 b01d 	strb.w	r11, [r3, #29]
                    boot_slot_index[0] = m;
30018bb0:	9b03      	ldr	r3, [sp, #12]
                    boot_slot_index[1] = x;
30018bb2:	e9c2 3500 	strd	r3, r5, [r2]
        if (part_dev->multislot_support)
            break;
    }

    return part_dev->multislot_support;
}
30018bb6:	b007      	add	sp, #28
30018bb8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL, "Invalide partition dev\n");
30018bbc:	f641 50b4 	movw	r0, #7604	; 0x1db4
30018bc0:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018bc4:	f7fc fff4 	bl	30015bb0 <_printf>
        for (int x = m + 1; x < scan_nr; x++) {
30018bc8:	2000      	movs	r0, #0
}
30018bca:	b007      	add	sp, #28
30018bcc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                        count++;
30018bd0:	f04f 0b01 	mov.w	r11, #1
30018bd4:	e7d6      	b.n	30018b84 <ptdev_scan_for_multislot+0xa8>
30018bd6:	9b04      	ldr	r3, [sp, #16]
30018bd8:	9303      	str	r3, [sp, #12]
30018bda:	e7a8      	b.n	30018b2e <ptdev_scan_for_multislot+0x52>
        dprintf(CRITICAL, "ERROR: partition_count more than supported.\n");
30018bdc:	f641 5028 	movw	r0, #7464	; 0x1d28
30018be0:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018be4:	f7fc ffe4 	bl	30015bb0 <_printf>
        return part_dev->multislot_support;
30018be8:	9b05      	ldr	r3, [sp, #20]
30018bea:	7f58      	ldrb	r0, [r3, #29]
}
30018bec:	b007      	add	sp, #28
30018bee:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30018bf2:	bf00      	nop

30018bf4 <ptdev_find_active_slot>:
    This function returns the most priority and active slot,
    also you need to update the global state seperately.

*/
int ptdev_find_active_slot(partition_device_t *part_dev)
{
30018bf4:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    int i, count = 0;
    bool current_active_bit;
    unsigned boot_priority;
    struct partition_entry *partition_entries;

    if ((!part_dev) || (!part_dev->partition_entries)) {
30018bf8:	4607      	mov	r7, r0
30018bfa:	b3a0      	cbz	r0, 30018c66 <ptdev_find_active_slot+0x72>
30018bfc:	6903      	ldr	r3, [r0, #16]
30018bfe:	b393      	cbz	r3, 30018c66 <ptdev_find_active_slot+0x72>
        dprintf(CRITICAL, "Invalide partition dev\n");
        goto out;
    }

    partition_entries = ptdev_get_partition_entries(part_dev);
30018c00:	f7ff f874 	bl	30017cec <ptdev_get_partition_entries>
#ifdef AB_DEBUG
    dprintf(INFO, "ptdev_find_active_slot() called\n");
#endif

    /* Return current active slot if already found */
    if (part_dev->active_slot != INVALID)
30018c04:	69be      	ldr	r6, [r7, #24]
30018c06:	1c73      	adds	r3, r6, #1
30018c08:	d134      	bne.n	30018c74 <ptdev_find_active_slot+0x80>
30018c0a:	f64d 0c70 	movw	r12, #55408	; 0xd870
        goto out;

    for (boot_priority = (MAX_PRIORITY - 1);
30018c0e:	2203      	movs	r2, #3
    int i, count = 0;
30018c10:	2100      	movs	r1, #0
30018c12:	f2c3 0c02 	movt	r12, #12290	; 0x3002
30018c16:	e002      	b.n	30018c1e <ptdev_find_active_slot+0x2a>
            }
        }

        /* All slots are zeroed, this is first bootup */
        /* Marking and trying SLOT 0 as default */
        if (count == AB_SUPPORTED_SLOTS) {
30018c18:	2902      	cmp	r1, #2
30018c1a:	d02e      	beq.n	30018c7a <ptdev_find_active_slot+0x86>
            boot_priority >= 0; boot_priority--) {
30018c1c:	3a01      	subs	r2, #1
        for (i = 0; i < AB_SUPPORTED_SLOTS; i++) {
30018c1e:	2600      	movs	r6, #0
    return ((partition_entries[index].attribute_flag
30018c20:	f85c 3026 	ldr.w	r3, [r12, r6, lsl #2]
    return !!(partition_entries[index].attribute_flag & PART_ATT_ACTIVE_VAL);
30018c24:	f04f 0800 	mov.w	r8, #0
    return ((partition_entries[index].attribute_flag
30018c28:	eb03 03c3 	add.w	r3, r3, r3, lsl #3
30018c2c:	eb00 1303 	add.w	r3, r0, r3, lsl #4
30018c30:	e9d3 450c 	ldrd	r4, r5, [r3, #48]	; 0x30
    return !!(partition_entries[index].attribute_flag & PART_ATT_ACTIVE_VAL);
30018c34:	f405 2980 	and.w	r9, r5, #262144	; 0x40000
             & PART_ATT_PRIORITY_VAL) >> PART_ATT_PRIORITY_BIT);
30018c38:	f3c5 4301 	ubfx	r3, r5, #16, #2
                    !current_active_bit) {
30018c3c:	ea48 0409 	orr.w	r4, r8, r9
            if ( !current_priority &&
30018c40:	2b00      	cmp	r3, #0
30018c42:	bf08      	it	eq
30018c44:	f1b9 0f00 	cmpeq.w	r9, #0
                count ++;
30018c48:	bf08      	it	eq
30018c4a:	3101      	addeq	r1, #1
            if ( !current_priority &&
30018c4c:	d007      	beq.n	30018c5e <ptdev_find_active_slot+0x6a>
            if (boot_priority == current_priority) {
30018c4e:	1ad3      	subs	r3, r2, r3
30018c50:	fab3 f383 	clz	r3, r3
30018c54:	095b      	lsrs	r3, r3, #5
                if (current_active_bit) {
30018c56:	2c00      	cmp	r4, #0
30018c58:	bf08      	it	eq
30018c5a:	2300      	moveq	r3, #0
30018c5c:	b9c3      	cbnz	r3, 30018c90 <ptdev_find_active_slot+0x9c>
        for (i = 0; i < AB_SUPPORTED_SLOTS; i++) {
30018c5e:	2e01      	cmp	r6, #1
30018c60:	d0da      	beq.n	30018c18 <ptdev_find_active_slot+0x24>
30018c62:	2601      	movs	r6, #1
30018c64:	e7dc      	b.n	30018c20 <ptdev_find_active_slot+0x2c>
        dprintf(CRITICAL, "Invalide partition dev\n");
30018c66:	f641 50b4 	movw	r0, #7604	; 0x1db4
30018c6a:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018c6e:	f7fc ff9f 	bl	30015bb0 <_printf>
30018c72:	69be      	ldr	r6, [r7, #24]
        }
    }

out:
    return part_dev->active_slot;
}
30018c74:	4630      	mov	r0, r6
30018c76:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            ptdev_activate_slot(part_dev, SLOT_A);
30018c7a:	4638      	mov	r0, r7
30018c7c:	2100      	movs	r1, #0
30018c7e:	f7ff fedb 	bl	30018a38 <ptdev_activate_slot>
            part_dev->attributes_updated = true;
30018c82:	773e      	strb	r6, [r7, #28]
            part_dev->active_slot = SLOT_A;
30018c84:	2300      	movs	r3, #0
            goto out;
30018c86:	461e      	mov	r6, r3
            part_dev->active_slot = SLOT_A;
30018c88:	61bb      	str	r3, [r7, #24]
}
30018c8a:	4630      	mov	r0, r6
30018c8c:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
                    part_dev->active_slot = i;
30018c90:	61be      	str	r6, [r7, #24]
                    goto out;
30018c92:	e7ef      	b.n	30018c74 <ptdev_find_active_slot+0x80>

30018c94 <ptdev_multislot_is_supported>:
}

/* Function to find if multislot is supported */
bool ptdev_multislot_is_supported(partition_device_t *part_dev)
{
    if (!part_dev) {
30018c94:	b108      	cbz	r0, 30018c9a <ptdev_multislot_is_supported+0x6>
        dprintf(CRITICAL, "Invalide partition dev\n");
        return false;
    }

    return part_dev->multislot_support;
30018c96:	7f40      	ldrb	r0, [r0, #29]
}
30018c98:	4770      	bx	r14
{
30018c9a:	b510      	push	{r4, r14}
30018c9c:	4604      	mov	r4, r0
        dprintf(CRITICAL, "Invalide partition dev\n");
30018c9e:	f641 50b4 	movw	r0, #7604	; 0x1db4
30018ca2:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018ca6:	f7fc ff83 	bl	30015bb0 <_printf>
        return false;
30018caa:	4620      	mov	r0, r4
}
30018cac:	bd10      	pop	{r4, r15}
30018cae:	bf00      	nop

30018cb0 <setup_storage_dev>:
                                    uint32_t res_idex, void *config)
{
    storage_device_t *storage;
    int ret;

    if (type > MEMDISK || type < MMC) {
30018cb0:	2802      	cmp	r0, #2
{
30018cb2:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (type > MEMDISK || type < MMC) {
30018cb4:	f200 80be 	bhi.w	30018e34 <setup_storage_dev+0x184>
30018cb8:	4605      	mov	r5, r0
30018cba:	460e      	mov	r6, r1
        dprintf(CRITICAL, "Bad storage type\n");
        return NULL;
    }

    storage = calloc(1, sizeof(storage_device_t));
30018cbc:	2001      	movs	r0, #1
30018cbe:	2130      	movs	r1, #48	; 0x30
30018cc0:	4617      	mov	r7, r2
30018cc2:	f7fb fd43 	bl	3001474c <calloc>

    if (!storage) {
30018cc6:	4604      	mov	r4, r0
30018cc8:	2800      	cmp	r0, #0
30018cca:	f000 80c0 	beq.w	30018e4e <setup_storage_dev+0x19e>
        dprintf(CRITICAL, "alloc memory for storage dev failed\n");
        return NULL;
    }

    switch (type) {
30018cce:	2d01      	cmp	r5, #1
30018cd0:	d072      	beq.n	30018db8 <setup_storage_dev+0x108>
30018cd2:	2d02      	cmp	r5, #2
30018cd4:	d037      	beq.n	30018d46 <setup_storage_dev+0x96>
        case MMC:
            storage->init = &mmc_init;
30018cd6:	f249 03d1 	movw	r3, #37073	; 0x90d1
            storage->read = &mmc_read;
            storage->write = &mmc_write;
            storage->erase = &mmc_erase;
30018cda:	f249 15c1 	movw	r5, #37313	; 0x91c1
            storage->init = &mmc_init;
30018cde:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->read = &mmc_read;
30018ce2:	f249 1e6d 	movw	r14, #37229	; 0x916d
            storage->erase = &mmc_erase;
30018ce6:	f2c3 0501 	movt	r5, #12289	; 0x3001
            storage->init = &mmc_init;
30018cea:	6043      	str	r3, [r0, #4]
            storage->switch_part = &mmc_switch_part;
30018cec:	f249 13a5 	movw	r3, #37285	; 0x91a5
            storage->write = &mmc_write;
30018cf0:	f249 1c89 	movw	r12, #37257	; 0x9189
            storage->switch_part = &mmc_switch_part;
30018cf4:	f2c3 0301 	movt	r3, #12289	; 0x3001

        default:
            break;
    }

    ret = storage->init(storage, res_idex, config);
30018cf8:	463a      	mov	r2, r7
30018cfa:	4631      	mov	r1, r6
            storage->get_capacity = &mmc_get_capacity;
30018cfc:	f249 37a5 	movw	r7, #37797	; 0x93a5
            storage->get_erase_group_size = &mmc_get_erase_group_size;
30018d00:	f249 36b5 	movw	r6, #37813	; 0x93b5
            storage->erase = &mmc_erase;
30018d04:	6105      	str	r5, [r0, #16]
            storage->get_block_size = &mmc_get_block_size;
30018d06:	f249 154d 	movw	r5, #37197	; 0x914d
            storage->switch_part = &mmc_switch_part;
30018d0a:	6143      	str	r3, [r0, #20]
            storage->release = &mmc_release;
30018d0c:	f249 132d 	movw	r3, #37165	; 0x912d
            storage->read = &mmc_read;
30018d10:	f2c3 0e01 	movt	r14, #12289	; 0x3001
            storage->write = &mmc_write;
30018d14:	f2c3 0c01 	movt	r12, #12289	; 0x3001
            storage->get_capacity = &mmc_get_capacity;
30018d18:	f2c3 0701 	movt	r7, #12289	; 0x3001
            storage->get_erase_group_size = &mmc_get_erase_group_size;
30018d1c:	f2c3 0601 	movt	r6, #12289	; 0x3001
            storage->get_block_size = &mmc_get_block_size;
30018d20:	f2c3 0501 	movt	r5, #12289	; 0x3001
            storage->read = &mmc_read;
30018d24:	f8c0 e008 	str.w	r14, [r0, #8]
            storage->release = &mmc_release;
30018d28:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->write = &mmc_write;
30018d2c:	f8c0 c00c 	str.w	r12, [r0, #12]
            storage->get_erase_group_size = &mmc_get_erase_group_size;
30018d30:	e9c0 7606 	strd	r7, r6, [r0, #24]
            storage->get_block_size = &mmc_get_block_size;
30018d34:	6205      	str	r5, [r0, #32]
            storage->release = &mmc_release;
30018d36:	62c3      	str	r3, [r0, #44]	; 0x2c
    ret = storage->init(storage, res_idex, config);
30018d38:	f000 f9ca 	bl	300190d0 <mmc_init>

    if (ret) {
30018d3c:	2800      	cmp	r0, #0
30018d3e:	f040 8081 	bne.w	30018e44 <setup_storage_dev+0x194>
        free(storage);
        return NULL;
    }

    return storage;
}
30018d42:	4620      	mov	r0, r4
30018d44:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            storage->read = &memdisk_read;
30018d46:	f648 65b5 	movw	r5, #36533	; 0x8eb5
            storage->write = &memdisk_write;
30018d4a:	f648 63d5 	movw	r3, #36565	; 0x8ed5
            storage->read = &memdisk_read;
30018d4e:	f2c3 0501 	movt	r5, #12289	; 0x3001
    ret = storage->init(storage, res_idex, config);
30018d52:	4631      	mov	r1, r6
            storage->write = &memdisk_write;
30018d54:	f2c3 0301 	movt	r3, #12289	; 0x3001
    ret = storage->init(storage, res_idex, config);
30018d58:	463a      	mov	r2, r7
            storage->init = &memdisk_init;
30018d5a:	f648 6c5d 	movw	r12, #36445	; 0x8e5d
            storage->read = &memdisk_read;
30018d5e:	6085      	str	r5, [r0, #8]
            storage->erase = &memdisk_erase;
30018d60:	f648 770d 	movw	r7, #36621	; 0x8f0d
            storage->write = &memdisk_write;
30018d64:	60c3      	str	r3, [r0, #12]
            storage->get_capacity = &memdisk_get_capacity;
30018d66:	f648 762d 	movw	r6, #36653	; 0x8f2d
            storage->get_block_size = &memdisk_get_block_size;
30018d6a:	f648 7541 	movw	r5, #36673	; 0x8f41
            storage->release = &memdisk_release;
30018d6e:	f648 7351 	movw	r3, #36689	; 0x8f51
            storage->init = &memdisk_init;
30018d72:	f2c3 0c01 	movt	r12, #12289	; 0x3001
            storage->release = &memdisk_release;
30018d76:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->erase = &memdisk_erase;
30018d7a:	f2c3 0701 	movt	r7, #12289	; 0x3001
            storage->get_capacity = &memdisk_get_capacity;
30018d7e:	f2c3 0601 	movt	r6, #12289	; 0x3001
            storage->init = &memdisk_init;
30018d82:	f8c0 c004 	str.w	r12, [r0, #4]
            storage->get_block_size = &memdisk_get_block_size;
30018d86:	f2c3 0501 	movt	r5, #12289	; 0x3001
            storage->erase = &memdisk_erase;
30018d8a:	6107      	str	r7, [r0, #16]
            storage->get_capacity = &memdisk_get_capacity;
30018d8c:	6186      	str	r6, [r0, #24]
            storage->get_block_size = &memdisk_get_block_size;
30018d8e:	6205      	str	r5, [r0, #32]
            storage->release = &memdisk_release;
30018d90:	62c3      	str	r3, [r0, #44]	; 0x2c
    ret = storage->init(storage, res_idex, config);
30018d92:	f000 f863 	bl	30018e5c <memdisk_init>
        dprintf(CRITICAL, "%s init failed\n",
30018d96:	f641 6124 	movw	r1, #7716	; 0x1e24
30018d9a:	f2c3 0102 	movt	r1, #12290	; 0x3002
    if (ret) {
30018d9e:	2800      	cmp	r0, #0
30018da0:	d0cf      	beq.n	30018d42 <setup_storage_dev+0x92>
        dprintf(CRITICAL, "%s init failed\n",
30018da2:	f641 6070 	movw	r0, #7792	; 0x1e70
30018da6:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018daa:	f7fc ff01 	bl	30015bb0 <_printf>
        free(storage);
30018dae:	4620      	mov	r0, r4
30018db0:	f7fb fcec 	bl	3001478c <free>
        return NULL;
30018db4:	2400      	movs	r4, #0
30018db6:	e7c4      	b.n	30018d42 <setup_storage_dev+0x92>
            storage->init = &ospi_init;
30018db8:	f249 35c1 	movw	r5, #37825	; 0x93c1
            storage->read = &ospi_read;
30018dbc:	f249 4335 	movw	r3, #37941	; 0x9435
            storage->init = &ospi_init;
30018dc0:	f2c3 0501 	movt	r5, #12289	; 0x3001
    ret = storage->init(storage, res_idex, config);
30018dc4:	4631      	mov	r1, r6
            storage->read = &ospi_read;
30018dc6:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->erase = &ospi_erase;
30018dca:	f249 466d 	movw	r6, #37997	; 0x946d
            storage->write = &ospi_write;
30018dce:	f249 4c51 	movw	r12, #37969	; 0x9451
            storage->init = &ospi_init;
30018dd2:	6045      	str	r5, [r0, #4]
            storage->need_erase = &ospi_need_erase;
30018dd4:	f249 4589 	movw	r5, #38025	; 0x9489
            storage->read = &ospi_read;
30018dd8:	6083      	str	r3, [r0, #8]
            storage->get_storage_id = &ospi_get_id;
30018dda:	f249 43a9 	movw	r3, #38057	; 0x94a9
            storage->erase = &ospi_erase;
30018dde:	f2c3 0601 	movt	r6, #12289	; 0x3001
            storage->need_erase = &ospi_need_erase;
30018de2:	f2c3 0501 	movt	r5, #12289	; 0x3001
    ret = storage->init(storage, res_idex, config);
30018de6:	463a      	mov	r2, r7
            storage->get_storage_id = &ospi_get_id;
30018de8:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->get_capacity = &ospi_get_capacity;
30018dec:	f249 478d 	movw	r7, #38029	; 0x948d
            storage->write = &ospi_write;
30018df0:	f2c3 0c01 	movt	r12, #12289	; 0x3001
            storage->erase = &ospi_erase;
30018df4:	6106      	str	r6, [r0, #16]
            storage->get_block_size = &ospi_get_block_size;
30018df6:	f249 462d 	movw	r6, #37933	; 0x942d
            storage->need_erase = &ospi_need_erase;
30018dfa:	6245      	str	r5, [r0, #36]	; 0x24
            storage->get_erase_group_size = &ospi_get_erase_group_size;
30018dfc:	f249 5511 	movw	r5, #38161	; 0x9511
            storage->get_storage_id = &ospi_get_id;
30018e00:	6283      	str	r3, [r0, #40]	; 0x28
            storage->release = &ospi_release;
30018e02:	f249 430d 	movw	r3, #37901	; 0x940d
            storage->get_capacity = &ospi_get_capacity;
30018e06:	f2c3 0701 	movt	r7, #12289	; 0x3001
            storage->get_block_size = &ospi_get_block_size;
30018e0a:	f2c3 0601 	movt	r6, #12289	; 0x3001
            storage->get_erase_group_size = &ospi_get_erase_group_size;
30018e0e:	f2c3 0501 	movt	r5, #12289	; 0x3001
            storage->write = &ospi_write;
30018e12:	f8c0 c00c 	str.w	r12, [r0, #12]
            storage->release = &ospi_release;
30018e16:	f2c3 0301 	movt	r3, #12289	; 0x3001
            storage->get_capacity = &ospi_get_capacity;
30018e1a:	6187      	str	r7, [r0, #24]
            storage->get_erase_group_size = &ospi_get_erase_group_size;
30018e1c:	e9c0 5607 	strd	r5, r6, [r0, #28]
            storage->release = &ospi_release;
30018e20:	62c3      	str	r3, [r0, #44]	; 0x2c
    ret = storage->init(storage, res_idex, config);
30018e22:	f000 facd 	bl	300193c0 <ospi_init>
    if (ret) {
30018e26:	2800      	cmp	r0, #0
30018e28:	d08b      	beq.n	30018d42 <setup_storage_dev+0x92>
        dprintf(CRITICAL, "%s init failed\n",
30018e2a:	f641 6128 	movw	r1, #7720	; 0x1e28
30018e2e:	f2c3 0102 	movt	r1, #12290	; 0x3002
30018e32:	e7b6      	b.n	30018da2 <setup_storage_dev+0xf2>
        dprintf(CRITICAL, "Bad storage type\n");
30018e34:	f641 6034 	movw	r0, #7732	; 0x1e34
        return NULL;
30018e38:	2400      	movs	r4, #0
        dprintf(CRITICAL, "Bad storage type\n");
30018e3a:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018e3e:	f7fc feb7 	bl	30015bb0 <_printf>
        return NULL;
30018e42:	e77e      	b.n	30018d42 <setup_storage_dev+0x92>
        dprintf(CRITICAL, "%s init failed\n",
30018e44:	f641 6130 	movw	r1, #7728	; 0x1e30
30018e48:	f2c3 0102 	movt	r1, #12290	; 0x3002
30018e4c:	e7a9      	b.n	30018da2 <setup_storage_dev+0xf2>
        dprintf(CRITICAL, "alloc memory for storage dev failed\n");
30018e4e:	f641 6048 	movw	r0, #7752	; 0x1e48
30018e52:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018e56:	f7fc feab 	bl	30015bb0 <_printf>
        return NULL;
30018e5a:	e772      	b.n	30018d42 <setup_storage_dev+0x92>

30018e5c <memdisk_init>:
                 void *config)
{
    size_t len;
    void *ptr;

    bdev_t *memdisk_dev = storage_dev->priv;
30018e5c:	6803      	ldr	r3, [r0, #0]
{
30018e5e:	b5f0      	push	{r4, r5, r6, r7, r14}
30018e60:	b083      	sub	sp, #12

    if (!memdisk_dev) {
30018e62:	b18b      	cbz	r3, 30018e88 <memdisk_init+0x2c>
        memdisk_dev = bio_open(memdisk_name);
        storage_dev->priv = memdisk_dev;
    }

    if (memdisk_dev) {
        printf("\t%s, size %lld, bsize %zd, ref %d\n",
30018e64:	689a      	ldr	r2, [r3, #8]
30018e66:	f641 6080 	movw	r0, #7808	; 0x1e80
30018e6a:	e9d3 6704 	ldrd	r6, r7, [r3, #16]
30018e6e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30018e72:	68d9      	ldr	r1, [r3, #12]
30018e74:	9201      	str	r2, [sp, #4]
30018e76:	4632      	mov	r2, r6
30018e78:	699c      	ldr	r4, [r3, #24]
30018e7a:	463b      	mov	r3, r7
30018e7c:	9400      	str	r4, [sp, #0]
30018e7e:	f7fc fe97 	bl	30015bb0 <_printf>
               memdisk_dev->name, memdisk_dev->total_size, memdisk_dev->block_size,
               memdisk_dev->ref);
    }

    return 0;
}
30018e82:	2000      	movs	r0, #0
30018e84:	b003      	add	sp, #12
30018e86:	bdf0      	pop	{r4, r5, r6, r7, r15}
        create_membdev(memdisk_name, ptr, len);
30018e88:	f245 4544 	movw	r5, #21572	; 0x5444
30018e8c:	4604      	mov	r4, r0
30018e8e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
30018e92:	f2c3 0502 	movt	r5, #12290	; 0x3002
30018e96:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
30018e9a:	6828      	ldr	r0, [r5, #0]
30018e9c:	f7fa fda4 	bl	300139e8 <create_membdev>
        memdisk_dev = bio_open(memdisk_name);
30018ea0:	6828      	ldr	r0, [r5, #0]
30018ea2:	f7fa fc6d 	bl	30013780 <bio_open>
        storage_dev->priv = memdisk_dev;
30018ea6:	6020      	str	r0, [r4, #0]
        memdisk_dev = bio_open(memdisk_name);
30018ea8:	4603      	mov	r3, r0
    if (memdisk_dev) {
30018eaa:	2800      	cmp	r0, #0
30018eac:	d1da      	bne.n	30018e64 <memdisk_init+0x8>
}
30018eae:	2000      	movs	r0, #0
30018eb0:	b003      	add	sp, #12
30018eb2:	bdf0      	pop	{r4, r5, r6, r7, r15}

30018eb4 <memdisk_read>:

int memdisk_read(storage_device_t *storage_dev, uint64_t src, uint8_t *dst,
                 uint64_t size)
{
30018eb4:	b500      	push	{r14}
    if (storage_dev->priv) {
30018eb6:	6800      	ldr	r0, [r0, #0]
{
30018eb8:	b083      	sub	sp, #12
30018eba:	9906      	ldr	r1, [sp, #24]
    if (storage_dev->priv) {
30018ebc:	b138      	cbz	r0, 30018ece <memdisk_read+0x1a>
        bio_read(storage_dev->priv, dst, src, size);
30018ebe:	9100      	str	r1, [sp, #0]
30018ec0:	9904      	ldr	r1, [sp, #16]
30018ec2:	f7fa fc8f 	bl	300137e4 <bio_read>
        return 0;
30018ec6:	2000      	movs	r0, #0
    }
    else {
        return -1;
    }
}
30018ec8:	b003      	add	sp, #12
30018eca:	f85d fb04 	ldr.w	r15, [r13], #4
        return -1;
30018ece:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30018ed2:	e7f9      	b.n	30018ec8 <memdisk_read+0x14>

30018ed4 <memdisk_write>:

int memdisk_write(storage_device_t *storage_dev, uint64_t dst,
                  const uint8_t *buf, uint64_t data_len)
{
    if (storage_dev->priv) {
30018ed4:	6800      	ldr	r0, [r0, #0]
{
30018ed6:	b4f0      	push	{r4, r5, r6, r7}
30018ed8:	9904      	ldr	r1, [sp, #16]
30018eda:	e9dd 4506 	ldrd	r4, r5, [r13, #24]
    if (storage_dev->priv) {
30018ede:	b190      	cbz	r0, 30018f06 <memdisk_write+0x32>
        if (data_len / 512) {
30018ee0:	2d00      	cmp	r5, #0
30018ee2:	bf08      	it	eq
30018ee4:	f5b4 7f00 	cmpeq.w	r4, #512	; 0x200
30018ee8:	d203      	bcs.n	30018ef2 <memdisk_write+0x1e>
            return bio_write_block(storage_dev->priv, buf, dst / 512, data_len / 512);
        }
        else {
            return bio_write(storage_dev->priv, buf, dst, data_len);
30018eea:	9404      	str	r4, [sp, #16]
        arch_clean_cache_range((addr_t)buf, data_len);
    }
    else {
        return 0;
    }
}
30018eec:	bcf0      	pop	{r4, r5, r6, r7}
            return bio_write(storage_dev->priv, buf, dst, data_len);
30018eee:	f7fa bca1 	b.w	30013834 <bio_write>
30018ef2:	461f      	mov	r7, r3
            return bio_write_block(storage_dev->priv, buf, dst / 512, data_len / 512);
30018ef4:	0a52      	lsrs	r2, r2, #9
30018ef6:	0a63      	lsrs	r3, r4, #9
30018ef8:	ea42 52c7 	orr.w	r2, r2, r7, lsl #23
30018efc:	ea43 53c5 	orr.w	r3, r3, r5, lsl #23
}
30018f00:	bcf0      	pop	{r4, r5, r6, r7}
            return bio_write_block(storage_dev->priv, buf, dst / 512, data_len / 512);
30018f02:	f7fa bc9f 	b.w	30013844 <bio_write_block>
}
30018f06:	bcf0      	pop	{r4, r5, r6, r7}
30018f08:	4770      	bx	r14
30018f0a:	bf00      	nop

30018f0c <memdisk_erase>:

int memdisk_erase(storage_device_t *storage_dev, uint64_t dst,
                  uint64_t len)
{
30018f0c:	b500      	push	{r14}
    if (storage_dev->priv) {
30018f0e:	6800      	ldr	r0, [r0, #0]
{
30018f10:	b083      	sub	sp, #12
30018f12:	9904      	ldr	r1, [sp, #16]
    if (storage_dev->priv) {
30018f14:	b130      	cbz	r0, 30018f24 <memdisk_erase+0x18>
        bio_erase(storage_dev->priv, dst, len);
30018f16:	9100      	str	r1, [sp, #0]
30018f18:	f7fa fcac 	bl	30013874 <bio_erase>
        return 0;
30018f1c:	2000      	movs	r0, #0
    }

    return -1;
}
30018f1e:	b003      	add	sp, #12
30018f20:	f85d fb04 	ldr.w	r15, [r13], #4
    return -1;
30018f24:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30018f28:	e7f9      	b.n	30018f1e <memdisk_erase+0x12>
30018f2a:	bf00      	nop

30018f2c <memdisk_get_capacity>:

uint64_t memdisk_get_capacity(storage_device_t *storage_dev)
{
    if (storage_dev->priv) {
30018f2c:	6803      	ldr	r3, [r0, #0]
30018f2e:	b11b      	cbz	r3, 30018f38 <memdisk_get_capacity+0xc>
        return MEMDISK_SIZE;
30018f30:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
30018f34:	2100      	movs	r1, #0
    }
    else {
        return 0;
    }
}
30018f36:	4770      	bx	r14
        return 0;
30018f38:	2000      	movs	r0, #0
30018f3a:	2100      	movs	r1, #0
30018f3c:	4770      	bx	r14
30018f3e:	bf00      	nop

30018f40 <memdisk_get_block_size>:

uint32_t memdisk_get_block_size(storage_device_t *storage_dev)
{
    if (storage_dev->priv) {
30018f40:	6803      	ldr	r3, [r0, #0]
30018f42:	2b00      	cmp	r3, #0
        return 512;
    }
    else {
        return 0;
    }
}
30018f44:	bf14      	ite	ne
30018f46:	f44f 7000 	movne.w	r0, #512	; 0x200
30018f4a:	2000      	moveq	r0, #0
30018f4c:	4770      	bx	r14
30018f4e:	bf00      	nop

30018f50 <memdisk_release>:

int memdisk_release(storage_device_t *storage_dev)
{
    if (storage_dev->priv) {
30018f50:	6800      	ldr	r0, [r0, #0]
30018f52:	b120      	cbz	r0, 30018f5e <memdisk_release+0xe>
{
30018f54:	b508      	push	{r3, r14}
        bio_close(storage_dev->priv);
30018f56:	f7fa fc43 	bl	300137e0 <bio_close>
    }

    return 0;
}
30018f5a:	2000      	movs	r0, #0
30018f5c:	bd08      	pop	{r3, r15}
30018f5e:	2000      	movs	r0, #0
30018f60:	4770      	bx	r14
30018f62:	bf00      	nop

30018f64 <mmc_write_zero.isra.0>:
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
    return -1;
}

/* if the size < erase group size, we write zero in mmc instead of erase */
static int mmc_write_zero(storage_device_t *storage_dev, uint64_t dst,
30018f64:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30018f68:	b08b      	sub	sp, #44	; 0x2c
30018f6a:	9914      	ldr	r1, [sp, #80]	; 0x50

    zero_size = blz * count;
    zero_buf_size = blz * count;

    if (!count)
        return 0;
30018f6c:	468a      	mov	r10, r1
    if (!count)
30018f6e:	2900      	cmp	r1, #0
30018f70:	d078      	beq.n	30019064 <mmc_write_zero.isra.0+0x100>
30018f72:	461d      	mov	r5, r3
30018f74:	4680      	mov	r8, r0
    zero_size = blz * count;
30018f76:	9b15      	ldr	r3, [sp, #84]	; 0x54
30018f78:	4614      	mov	r4, r2
30018f7a:	f04f 0a00 	mov.w	r10, #0
30018f7e:	fb01 f303 	mul.w	r3, r1, r3

    if (zero_buf_size > ZERO_ERASE_SIZE_DEFAULT)
30018f82:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    zero_size = blz * count;
30018f86:	9309      	str	r3, [sp, #36]	; 0x24
    if (zero_buf_size > ZERO_ERASE_SIZE_DEFAULT)
30018f88:	d92d      	bls.n	30018fe6 <mmc_write_zero.isra.0+0x82>
    if (aligned == 0 || size < aligned)
30018f8a:	9b15      	ldr	r3, [sp, #84]	; 0x54
30018f8c:	3b01      	subs	r3, #1
30018f8e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
30018f92:	d26b      	bcs.n	3001906c <mmc_write_zero.isra.0+0x108>
    mod = size % aligned;
30018f94:	f44f 3680 	mov.w	r6, #65536	; 0x10000
30018f98:	2700      	movs	r7, #0
30018f9a:	4653      	mov	r3, r10
30018f9c:	4630      	mov	r0, r6
30018f9e:	9a15      	ldr	r2, [sp, #84]	; 0x54
30018fa0:	4639      	mov	r1, r7
30018fa2:	f000 ff3d 	bl	30019e20 <__aeabi_uldivmod>
    size -= mod;
30018fa6:	1ab6      	subs	r6, r6, r2
30018fa8:	46b2      	mov	r10, r6
30018faa:	eb67 0703 	sbc.w	r7, r7, r3
30018fae:	e9cd 6706 	strd	r6, r7, [r13, #24]
        zero_buf_size = round_down(ZERO_ERASE_SIZE_DEFAULT, (uint64_t)blz);

    zero = (uint8_t *)memalign(blz,  zero_buf_size);
30018fb2:	9815      	ldr	r0, [sp, #84]	; 0x54
30018fb4:	4651      	mov	r1, r10
30018fb6:	f7fb fbad 	bl	30014714 <memalign>

    if (!zero) {
30018fba:	4683      	mov	r11, r0
30018fbc:	2800      	cmp	r0, #0
30018fbe:	d05a      	beq.n	30019076 <mmc_write_zero.isra.0+0x112>
        dprintf(CRITICAL, "%s malloc failure\n", __func__);
        goto end;
    }

    memset((void *)zero, 0x0, zero_buf_size);
30018fc0:	4652      	mov	r2, r10
30018fc2:	2100      	movs	r1, #0
30018fc4:	f7fb ecd4 	blx	30014970 <memset>

    for (uint32_t i = 0; i < zero_size / zero_buf_size; i++) {
30018fc8:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
30018fcc:	9809      	ldr	r0, [sp, #36]	; 0x24
30018fce:	2100      	movs	r1, #0
30018fd0:	f000 ff26 	bl	30019e20 <__aeabi_uldivmod>
30018fd4:	4602      	mov	r2, r0
30018fd6:	460b      	mov	r3, r1
30018fd8:	e9cd 2304 	strd	r2, r3, [r13, #16]
30018fdc:	4313      	orrs	r3, r2
30018fde:	d114      	bne.n	3001900a <mmc_write_zero.isra.0+0xa6>
    int ret = -1;
30018fe0:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
30018fe4:	e05c      	b.n	300190a0 <mmc_write_zero.isra.0+0x13c>
    zero = (uint8_t *)memalign(blz,  zero_buf_size);
30018fe6:	9909      	ldr	r1, [sp, #36]	; 0x24
30018fe8:	9815      	ldr	r0, [sp, #84]	; 0x54
30018fea:	f7fb fb93 	bl	30014714 <memalign>
    if (!zero) {
30018fee:	4683      	mov	r11, r0
30018ff0:	2800      	cmp	r0, #0
30018ff2:	d040      	beq.n	30019076 <mmc_write_zero.isra.0+0x112>
    memset((void *)zero, 0x0, zero_buf_size);
30018ff4:	9e09      	ldr	r6, [sp, #36]	; 0x24
30018ff6:	4651      	mov	r1, r10
30018ff8:	4632      	mov	r2, r6
30018ffa:	f7fb ecba 	blx	30014970 <memset>
    for (uint32_t i = 0; i < zero_size / zero_buf_size; i++) {
30018ffe:	2201      	movs	r2, #1
    memset((void *)zero, 0x0, zero_buf_size);
30019000:	e9cd 6a06 	strd	r6, r10, [r13, #24]
    for (uint32_t i = 0; i < zero_size / zero_buf_size; i++) {
30019004:	2300      	movs	r3, #0
30019006:	e9cd 2304 	strd	r2, r3, [r13, #16]
3001900a:	46c2      	mov	r10, r8
3001900c:	f04f 0900 	mov.w	r9, #0
30019010:	e9dd 6706 	ldrd	r6, r7, [r13, #24]
30019014:	46d8      	mov	r8, r11
30019016:	e005      	b.n	30019024 <mmc_write_zero.isra.0+0xc0>
30019018:	e9dd bc04 	ldrd	r11, r12, [r13, #16]
3001901c:	4563      	cmp	r3, r12
3001901e:	bf08      	it	eq
30019020:	45d9      	cmpeq	r9, r11
30019022:	d238      	bcs.n	30019096 <mmc_write_zero.isra.0+0x132>
        ret = hal_mmc_write(storage_dev->priv, dst, zero, zero_buf_size);
30019024:	f8da 0000 	ldr.w	r0, [r10]
30019028:	462b      	mov	r3, r5
3001902a:	4622      	mov	r2, r4
    for (uint32_t i = 0; i < zero_size / zero_buf_size; i++) {
3001902c:	f109 0901 	add.w	r9, r9, #1
        ret = hal_mmc_write(storage_dev->priv, dst, zero, zero_buf_size);
30019030:	e9cd 6702 	strd	r6, r7, [r13, #8]
30019034:	f8cd 8000 	str.w	r8, [r13]
30019038:	f7f6 f87e 	bl	3000f138 <hal_mmc_write>
    for (uint32_t i = 0; i < zero_size / zero_buf_size; i++) {
3001903c:	2300      	movs	r3, #0
        dst += zero_buf_size;
3001903e:	19a4      	adds	r4, r4, r6
30019040:	417d      	adcs	r5, r7

        if (ret) {
30019042:	2800      	cmp	r0, #0
30019044:	d0e8      	beq.n	30019018 <mmc_write_zero.isra.0+0xb4>
30019046:	4682      	mov	r10, r0
            dprintf(CRITICAL, "%s write failure\n", __func__);
30019048:	f641 61b4 	movw	r1, #7860	; 0x1eb4
3001904c:	f641 708c 	movw	r0, #8076	; 0x1f8c
30019050:	f2c3 0102 	movt	r1, #12290	; 0x3002
30019054:	46c3      	mov	r11, r8
30019056:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001905a:	f7fc fda9 	bl	30015bb0 <_printf>
        ret = hal_mmc_write(storage_dev->priv, dst, zero, zero_size % zero_buf_size);

end:

    if (zero)
        free(zero);
3001905e:	4658      	mov	r0, r11
30019060:	f7fb fb94 	bl	3001478c <free>

    return ret;
}
30019064:	4650      	mov	r0, r10
30019066:	b00b      	add	sp, #44	; 0x2c
30019068:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return 0;
3001906c:	2200      	movs	r2, #0
3001906e:	2300      	movs	r3, #0
30019070:	e9cd 2306 	strd	r2, r3, [r13, #24]
30019074:	e79d      	b.n	30018fb2 <mmc_write_zero.isra.0+0x4e>
        dprintf(CRITICAL, "%s malloc failure\n", __func__);
30019076:	f641 61b4 	movw	r1, #7860	; 0x1eb4
3001907a:	f641 7078 	movw	r0, #8056	; 0x1f78
3001907e:	f2c3 0102 	movt	r1, #12290	; 0x3002
    int ret = -1;
30019082:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "%s malloc failure\n", __func__);
30019086:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001908a:	f7fc fd91 	bl	30015bb0 <_printf>
}
3001908e:	4650      	mov	r0, r10
30019090:	b00b      	add	sp, #44	; 0x2c
30019092:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30019096:	e9cd 6706 	strd	r6, r7, [r13, #24]
3001909a:	46c3      	mov	r11, r8
3001909c:	46d0      	mov	r8, r10
3001909e:	4682      	mov	r10, r0
    if (zero_size % zero_buf_size)
300190a0:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
300190a4:	2100      	movs	r1, #0
300190a6:	9809      	ldr	r0, [sp, #36]	; 0x24
300190a8:	f000 feba 	bl	30019e20 <__aeabi_uldivmod>
300190ac:	4616      	mov	r6, r2
300190ae:	461f      	mov	r7, r3
300190b0:	ea56 0307 	orrs.w	r3, r6, r7
300190b4:	d0d3      	beq.n	3001905e <mmc_write_zero.isra.0+0xfa>
        ret = hal_mmc_write(storage_dev->priv, dst, zero, zero_size % zero_buf_size);
300190b6:	f8d8 0000 	ldr.w	r0, [r8]
300190ba:	4622      	mov	r2, r4
300190bc:	e9cd 6702 	strd	r6, r7, [r13, #8]
300190c0:	462b      	mov	r3, r5
300190c2:	f8cd b000 	str.w	r11, [r13]
300190c6:	f7f6 f837 	bl	3000f138 <hal_mmc_write>
300190ca:	4682      	mov	r10, r0
300190cc:	e7c7      	b.n	3001905e <mmc_write_zero.isra.0+0xfa>
300190ce:	bf00      	nop

300190d0 <mmc_init>:
{
300190d0:	b570      	push	{r4, r5, r6, r14}
300190d2:	4606      	mov	r6, r0
300190d4:	b082      	sub	sp, #8
300190d6:	4615      	mov	r5, r2
    ret = hal_mmc_creat_handle(&handle, res_idex);
300190d8:	a801      	add	r0, sp, #4
300190da:	f7f5 fe57 	bl	3000ed8c <hal_mmc_creat_handle>
    if (!ret) {
300190de:	b178      	cbz	r0, 30019100 <mmc_init+0x30>
    mmc_dev_handle = handle;
300190e0:	9c01      	ldr	r4, [sp, #4]
    printf("mmc_dev_handle  %p\n", mmc_dev_handle);
300190e2:	f641 7030 	movw	r0, #7984	; 0x1f30
    mmc_dev_handle->config = config;
300190e6:	6065      	str	r5, [r4, #4]
    printf("mmc_dev_handle  %p\n", mmc_dev_handle);
300190e8:	4621      	mov	r1, r4
300190ea:	f2c3 0002 	movt	r0, #12290	; 0x3002
300190ee:	f7fc fd5f 	bl	30015bb0 <_printf>
    ret = hal_mmc_init(mmc_dev_handle);
300190f2:	4620      	mov	r0, r4
300190f4:	f7f5 ff0e 	bl	3000ef14 <hal_mmc_init>
    if (ret) {
300190f8:	b958      	cbnz	r0, 30019112 <mmc_init+0x42>
    storage_dev->priv = mmc_dev_handle;
300190fa:	6034      	str	r4, [r6, #0]
}
300190fc:	b002      	add	sp, #8
300190fe:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "mmc create handle failed\n");
30019100:	f641 7014 	movw	r0, #7956	; 0x1f14
30019104:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019108:	f7fc fd52 	bl	30015bb0 <_printf>
        return -1;
3001910c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30019110:	e7f4      	b.n	300190fc <mmc_init+0x2c>
        dprintf(CRITICAL, "mmc hal init failed\n");
30019112:	f641 7044 	movw	r0, #8004	; 0x1f44
30019116:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001911a:	f7fc fd49 	bl	30015bb0 <_printf>
        hal_mmc_release_handle(handle);
3001911e:	9801      	ldr	r0, [sp, #4]
30019120:	f7f5 fec8 	bl	3000eeb4 <hal_mmc_release_handle>
        return -1;
30019124:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30019128:	e7e8      	b.n	300190fc <mmc_init+0x2c>
3001912a:	bf00      	nop

3001912c <mmc_release>:
{
3001912c:	b508      	push	{r3, r14}
    if (storage_dev->priv)
3001912e:	6803      	ldr	r3, [r0, #0]
30019130:	b113      	cbz	r3, 30019138 <mmc_release+0xc>
        return hal_mmc_release_handle(&(storage_dev->priv));
30019132:	f7f5 febf 	bl	3000eeb4 <hal_mmc_release_handle>
}
30019136:	bd08      	pop	{r3, r15}
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
30019138:	f641 705c 	movw	r0, #8028	; 0x1f5c
3001913c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019140:	f7fc fd36 	bl	30015bb0 <_printf>
    return -1;
30019144:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
30019148:	bd08      	pop	{r3, r15}
3001914a:	bf00      	nop

3001914c <mmc_get_block_size>:
{
3001914c:	b510      	push	{r4, r14}
    if (storage_dev->priv) {
3001914e:	6804      	ldr	r4, [r0, #0]
30019150:	b124      	cbz	r4, 3001915c <mmc_get_block_size+0x10>
        return  hal_mmc_get_block_size(storage_dev->priv);
30019152:	4620      	mov	r0, r4
}
30019154:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        return  hal_mmc_get_block_size(storage_dev->priv);
30019158:	f7f6 b92c 	b.w	3000f3b4 <hal_mmc_get_block_size>
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
3001915c:	f641 705c 	movw	r0, #8028	; 0x1f5c
30019160:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019164:	f7fc fd24 	bl	30015bb0 <_printf>
}
30019168:	4620      	mov	r0, r4
3001916a:	bd10      	pop	{r4, r15}

3001916c <mmc_read>:
    if (storage_dev->priv)
3001916c:	6800      	ldr	r0, [r0, #0]
3001916e:	b108      	cbz	r0, 30019174 <mmc_read+0x8>
        return hal_mmc_read(storage_dev->priv, src, dst, size);
30019170:	f7f5 bf40 	b.w	3000eff4 <hal_mmc_read>
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
30019174:	f641 705c 	movw	r0, #8028	; 0x1f5c
{
30019178:	b510      	push	{r4, r14}
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
3001917a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001917e:	f7fc fd17 	bl	30015bb0 <_printf>
}
30019182:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30019186:	bd10      	pop	{r4, r15}

30019188 <mmc_write>:
    if (storage_dev->priv)
30019188:	6800      	ldr	r0, [r0, #0]
3001918a:	b108      	cbz	r0, 30019190 <mmc_write+0x8>
        return hal_mmc_write(storage_dev->priv, dst, buf, data_len);
3001918c:	f7f5 bfd4 	b.w	3000f138 <hal_mmc_write>
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
30019190:	f641 705c 	movw	r0, #8028	; 0x1f5c
{
30019194:	b510      	push	{r4, r14}
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
30019196:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001919a:	f7fc fd09 	bl	30015bb0 <_printf>
}
3001919e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
300191a2:	bd10      	pop	{r4, r15}

300191a4 <mmc_switch_part>:
    if (storage_dev->priv)
300191a4:	6800      	ldr	r0, [r0, #0]
300191a6:	b108      	cbz	r0, 300191ac <mmc_switch_part+0x8>
        return hal_mmc_switch_part(storage_dev->priv, part_no);
300191a8:	f7f6 b934 	b.w	3000f414 <hal_mmc_switch_part>
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
300191ac:	f641 705c 	movw	r0, #8028	; 0x1f5c
{
300191b0:	b508      	push	{r3, r14}
    dprintf(CRITICAL, "Do mmc hal init firstly\n");
300191b2:	f2c3 0002 	movt	r0, #12290	; 0x3002
300191b6:	f7fc fcfb 	bl	30015bb0 <_printf>
}
300191ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
300191be:	bd08      	pop	{r3, r15}

300191c0 <mmc_erase>:

int mmc_erase(storage_device_t *storage_dev, uint64_t dst, uint64_t len)
{
300191c0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
300191c4:	469b      	mov	r11, r3
300191c6:	b08d      	sub	sp, #52	; 0x34
300191c8:	9007      	str	r0, [sp, #28]
    int ret = 0;
    uint32_t blz = 0;
    uint64_t count = 0;
    uint32_t erase_grp_sz = 0;

    if (!storage_dev->priv) {
300191ca:	6800      	ldr	r0, [r0, #0]
300191cc:	2800      	cmp	r0, #0
300191ce:	f000 80e0 	beq.w	30019392 <mmc_erase+0x1d2>
300191d2:	4692      	mov	r10, r2
        dprintf(CRITICAL, "Do mmc hal init firstly\n");
        return -1;
    }

    blz = hal_mmc_get_block_size(storage_dev->priv);
300191d4:	f7f6 f8ee 	bl	3000f3b4 <hal_mmc_get_block_size>
    erase_grp_sz = hal_mmc_get_erase_grp_size(storage_dev->priv);
300191d8:	9b07      	ldr	r3, [sp, #28]

    dprintf(INFO, "erase grp:%u dst:%llu, len:%llu\n", erase_grp_sz, dst, len);

    if (dst % blz || len % blz || erase_grp_sz % blz || !len) {
300191da:	2500      	movs	r5, #0
    blz = hal_mmc_get_block_size(storage_dev->priv);
300191dc:	4604      	mov	r4, r0
    erase_grp_sz = hal_mmc_get_erase_grp_size(storage_dev->priv);
300191de:	6818      	ldr	r0, [r3, #0]
300191e0:	f7f6 f900 	bl	3000f3e4 <hal_mmc_get_erase_grp_size>
    if (dst % blz || len % blz || erase_grp_sz % blz || !len) {
300191e4:	4622      	mov	r2, r4
300191e6:	462b      	mov	r3, r5
300191e8:	4659      	mov	r1, r11
    erase_grp_sz = hal_mmc_get_erase_grp_size(storage_dev->priv);
300191ea:	4680      	mov	r8, r0
    if (dst % blz || len % blz || erase_grp_sz % blz || !len) {
300191ec:	4650      	mov	r0, r10
300191ee:	f000 fe17 	bl	30019e20 <__aeabi_uldivmod>
300191f2:	4313      	orrs	r3, r2
300191f4:	f040 80b7 	bne.w	30019366 <mmc_erase+0x1a6>
300191f8:	4622      	mov	r2, r4
300191fa:	462b      	mov	r3, r5
300191fc:	e9dd 0116 	ldrd	r0, r1, [r13, #88]	; 0x58
30019200:	f000 fe0e 	bl	30019e20 <__aeabi_uldivmod>
30019204:	4313      	orrs	r3, r2
30019206:	f040 80ae 	bne.w	30019366 <mmc_erase+0x1a6>
3001920a:	fbb8 f3f4 	udiv	r3, r8, r4
3001920e:	e9dd 2116 	ldrd	r2, r1, [r13, #88]	; 0x58
30019212:	430a      	orrs	r2, r1
30019214:	bf0c      	ite	eq
30019216:	2201      	moveq	r2, #1
30019218:	462a      	movne	r2, r5
3001921a:	fb04 8313 	mls	r3, r4, r3, r8
3001921e:	42ab      	cmp	r3, r5
30019220:	bf0c      	ite	eq
30019222:	4613      	moveq	r3, r2
30019224:	2301      	movne	r3, #1
30019226:	2b00      	cmp	r3, #0
30019228:	f040 809d 	bne.w	30019366 <mmc_erase+0x1a6>
    if (aligned == 0 || size < aligned)
3001922c:	e9dd 6716 	ldrd	r6, r7, [r13, #88]	; 0x58
30019230:	f04f 0900 	mov.w	r9, #0
30019234:	ea48 0309 	orr.w	r3, r8, r9
30019238:	930a      	str	r3, [sp, #40]	; 0x28
3001923a:	e043      	b.n	300192c4 <mmc_erase+0x104>
3001923c:	e9cd 8904 	strd	r8, r9, [r13, #16]
30019240:	45cb      	cmp	r11, r9
30019242:	bf08      	it	eq
30019244:	45c2      	cmpeq	r10, r8
30019246:	bf34      	ite	cc
30019248:	f04f 0c01 	movcc.w	r12, #1
3001924c:	f04f 0c00 	movcs.w	r12, #0
    size += mod ? aligned - mod : 0;
30019250:	eb18 000a 	adds.w	r0, r8, r10
30019254:	eb49 010b 	adc.w	r1, r9, r11
30019258:	e9cd 0108 	strd	r0, r1, [r13, #32]
    if (aligned == 0 || size < aligned)
3001925c:	990a      	ldr	r1, [sp, #40]	; 0x28
3001925e:	2900      	cmp	r1, #0
30019260:	bf08      	it	eq
30019262:	f04f 0c01 	moveq.w	r12, #1
30019266:	f1bc 0f00 	cmp.w	r12, #0
3001926a:	d106      	bne.n	3001927a <mmc_erase+0xba>
    size += mod ? aligned - mod : 0;
3001926c:	e9dd 0108 	ldrd	r0, r1, [r13, #32]
30019270:	1a80      	subs	r0, r0, r2
30019272:	eb61 0103 	sbc.w	r1, r1, r3
30019276:	e9cd 0104 	strd	r0, r1, [r13, #16]
            dprintf(INFO, "%s %d dst:%llu, len:%llu\n", __func__, __LINE__, dst,
                    count * blz);
            break;
        }
        else if (dst % erase_grp_sz) {
            count = (round_up(dst,  erase_grp_sz) - dst) / blz;
3001927a:	e9dd 0104 	ldrd	r0, r1, [r13, #16]
3001927e:	4622      	mov	r2, r4
30019280:	2300      	movs	r3, #0
30019282:	ebb0 000a 	subs.w	r0, r0, r10
30019286:	eb61 010b 	sbc.w	r1, r1, r11
3001928a:	f000 fdc9 	bl	30019e20 <__aeabi_uldivmod>
            ret |= mmc_write_zero(storage_dev, dst, count, blz);
3001928e:	4652      	mov	r2, r10
30019290:	9401      	str	r4, [sp, #4]
30019292:	465b      	mov	r3, r11
30019294:	9004      	str	r0, [sp, #16]
30019296:	9000      	str	r0, [sp, #0]
30019298:	9807      	ldr	r0, [sp, #28]
            count = (round_up(dst,  erase_grp_sz) - dst) / blz;
3001929a:	9108      	str	r1, [sp, #32]
            ret |= mmc_write_zero(storage_dev, dst, count, blz);
3001929c:	f7ff fe62 	bl	30018f64 <mmc_write_zero.isra.0>
            len -= count * blz;
300192a0:	9b04      	ldr	r3, [sp, #16]
300192a2:	9908      	ldr	r1, [sp, #32]
300192a4:	fba4 2303 	umull	r2, r3, r4, r3
300192a8:	1ab6      	subs	r6, r6, r2
300192aa:	fb04 3301 	mla	r3, r4, r1, r3
300192ae:	eb67 0703 	sbc.w	r7, r7, r3
            dst += count * blz;
300192b2:	eb1a 0a02 	adds.w	r10, r10, r2
300192b6:	eb4b 0b03 	adc.w	r11, r11, r3
    while (len) {
300192ba:	ea56 0307 	orrs.w	r3, r6, r7
            ret |= mmc_write_zero(storage_dev, dst, count, blz);
300192be:	ea45 0500 	orr.w	r5, r5, r0
    while (len) {
300192c2:	d038      	beq.n	30019336 <mmc_erase+0x176>
        else if (dst % erase_grp_sz) {
300192c4:	4650      	mov	r0, r10
        if (len < erase_grp_sz) {
300192c6:	454f      	cmp	r7, r9
        else if (dst % erase_grp_sz) {
300192c8:	4659      	mov	r1, r11
        if (len < erase_grp_sz) {
300192ca:	bf08      	it	eq
300192cc:	4546      	cmpeq	r6, r8
        else if (dst % erase_grp_sz) {
300192ce:	4642      	mov	r2, r8
300192d0:	464b      	mov	r3, r9
        if (len < erase_grp_sz) {
300192d2:	d334      	bcc.n	3001933e <mmc_erase+0x17e>
        else if (dst % erase_grp_sz) {
300192d4:	f000 fda4 	bl	30019e20 <__aeabi_uldivmod>
300192d8:	ea52 0103 	orrs.w	r1, r2, r3
300192dc:	d1ae      	bne.n	3001923c <mmc_erase+0x7c>
300192de:	4630      	mov	r0, r6
300192e0:	4639      	mov	r1, r7
300192e2:	4642      	mov	r2, r8
300192e4:	464b      	mov	r3, r9
300192e6:	f000 fd9b 	bl	30019e20 <__aeabi_uldivmod>
300192ea:	9208      	str	r2, [sp, #32]
300192ec:	930b      	str	r3, [sp, #44]	; 0x2c
            dprintf(INFO, "%s %d dst:%llu, len:%llu\n", __func__, __LINE__, dst,
                    count * blz);
        }
        else {
            count = len / erase_grp_sz;
            ret |= hal_mmc_erase(storage_dev->priv, dst, count * erase_grp_sz);
300192ee:	fba0 2308 	umull	r2, r3, r0, r8
300192f2:	fb00 f609 	mul.w	r6, r0, r9
300192f6:	e9cd 2304 	strd	r2, r3, [r13, #16]
300192fa:	4652      	mov	r2, r10
300192fc:	fb01 6108 	mla	r1, r1, r8, r6
30019300:	9e05      	ldr	r6, [sp, #20]
30019302:	465b      	mov	r3, r11
30019304:	9807      	ldr	r0, [sp, #28]
30019306:	4431      	add	r1, r6
30019308:	9105      	str	r1, [sp, #20]
3001930a:	e9dd 6704 	ldrd	r6, r7, [r13, #16]
3001930e:	6800      	ldr	r0, [r0, #0]
30019310:	e9cd 6700 	strd	r6, r7, [r13]
30019314:	f7f5 ffa8 	bl	3000f268 <hal_mmc_erase>

            dst += count * erase_grp_sz;
30019318:	e9dd 2304 	ldrd	r2, r3, [r13, #16]
3001931c:	9e08      	ldr	r6, [sp, #32]
3001931e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
30019320:	eb12 020a 	adds.w	r2, r2, r10
30019324:	4692      	mov	r10, r2
30019326:	eb43 030b 	adc.w	r3, r3, r11
3001932a:	469b      	mov	r11, r3
    while (len) {
3001932c:	ea56 0307 	orrs.w	r3, r6, r7
            ret |= hal_mmc_erase(storage_dev->priv, dst, count * erase_grp_sz);
30019330:	ea45 0500 	orr.w	r5, r5, r0
    while (len) {
30019334:	d1c6      	bne.n	300192c4 <mmc_erase+0x104>
                    count * erase_grp_sz);
        }
    }

    return ret;
}
30019336:	4628      	mov	r0, r5
30019338:	b00d      	add	sp, #52	; 0x34
3001933a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            count = len / blz;
3001933e:	4622      	mov	r2, r4
30019340:	4630      	mov	r0, r6
30019342:	4639      	mov	r1, r7
30019344:	2300      	movs	r3, #0
30019346:	e9cd 6716 	strd	r6, r7, [r13, #88]	; 0x58
            ret |=  mmc_write_zero(storage_dev, dst, count, blz);
3001934a:	9401      	str	r4, [sp, #4]
            count = len / blz;
3001934c:	f000 fd68 	bl	30019e20 <__aeabi_uldivmod>
            ret |=  mmc_write_zero(storage_dev, dst, count, blz);
30019350:	4652      	mov	r2, r10
30019352:	465b      	mov	r3, r11
30019354:	9000      	str	r0, [sp, #0]
30019356:	9807      	ldr	r0, [sp, #28]
30019358:	f7ff fe04 	bl	30018f64 <mmc_write_zero.isra.0>
3001935c:	4305      	orrs	r5, r0
}
3001935e:	4628      	mov	r0, r5
30019360:	b00d      	add	sp, #52	; 0x34
30019362:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(CRITICAL,
30019366:	9402      	str	r4, [sp, #8]
30019368:	f641 61c4 	movw	r1, #7876	; 0x1ec4
3001936c:	e9dd 4516 	ldrd	r4, r5, [r13, #88]	; 0x58
30019370:	f641 60d0 	movw	r0, #7888	; 0x1ed0
30019374:	e9cd 4500 	strd	r4, r5, [r13]
30019378:	4652      	mov	r2, r10
3001937a:	465b      	mov	r3, r11
3001937c:	f2c3 0102 	movt	r1, #12290	; 0x3002
30019380:	f8cd 800c 	str.w	r8, [r13, #12]
30019384:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019388:	f7fc fc12 	bl	30015bb0 <_printf>
        return -1;
3001938c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
30019390:	e7d1      	b.n	30019336 <mmc_erase+0x176>
        dprintf(CRITICAL, "Do mmc hal init firstly\n");
30019392:	f641 705c 	movw	r0, #8028	; 0x1f5c
        return -1;
30019396:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "Do mmc hal init firstly\n");
3001939a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001939e:	f7fc fc07 	bl	30015bb0 <_printf>
        return -1;
300193a2:	e7c8      	b.n	30019336 <mmc_erase+0x176>

300193a4 <mmc_get_capacity>:

uint64_t mmc_get_capacity(storage_device_t *storage_dev)
{
    if (storage_dev->priv)
300193a4:	6800      	ldr	r0, [r0, #0]
300193a6:	b108      	cbz	r0, 300193ac <mmc_get_capacity+0x8>
        return hal_mmc_get_capacity(storage_dev->priv);
300193a8:	f7f5 bfe4 	b.w	3000f374 <hal_mmc_get_capacity>

    return 0;
}
300193ac:	2000      	movs	r0, #0
300193ae:	2100      	movs	r1, #0
300193b0:	4770      	bx	r14
300193b2:	bf00      	nop

300193b4 <mmc_get_erase_group_size>:

uint32_t mmc_get_erase_group_size(storage_device_t *storage_dev)
{
    if (storage_dev->priv) {
300193b4:	6800      	ldr	r0, [r0, #0]
300193b6:	b108      	cbz	r0, 300193bc <mmc_get_erase_group_size+0x8>
        return hal_mmc_get_erase_grp_size(storage_dev->priv);
300193b8:	f7f6 b814 	b.w	3000f3e4 <hal_mmc_get_erase_grp_size>
    }
    else {
        return 0;
    }
}
300193bc:	4770      	bx	r14
300193be:	bf00      	nop

300193c0 <ospi_init>:

static uint32_t virtual_block_size = 512;

int ospi_init(storage_device_t *storage_dev, uint32_t res_idx,
              void *config)
{
300193c0:	b570      	push	{r4, r5, r6, r14}
300193c2:	4606      	mov	r6, r0
300193c4:	b082      	sub	sp, #8
300193c6:	4615      	mov	r5, r2
    int ret = 0;
    void *handle;
    struct  spi_nor_handle *ospi_dev_handle;

    ret = hal_spi_nor_creat_handle(&handle, res_idx);
300193c8:	a801      	add	r0, sp, #4
300193ca:	f7f6 fd5d 	bl	3000fe88 <hal_spi_nor_creat_handle>

    if (!ret) {
300193ce:	b140      	cbz	r0, 300193e2 <ospi_init+0x22>
        dprintf(CRITICAL, "ospi create handle failed\n");
        return -1;
    }

    ospi_dev_handle = handle;
300193d0:	9c01      	ldr	r4, [sp, #4]
    ospi_dev_handle->config = config;
300193d2:	6125      	str	r5, [r4, #16]

    ret = hal_spi_nor_init(ospi_dev_handle);
300193d4:	4620      	mov	r0, r4
300193d6:	f7f6 fe27 	bl	30010028 <hal_spi_nor_init>

    if (ret) {
300193da:	b958      	cbnz	r0, 300193f4 <ospi_init+0x34>
        hal_spi_nor_release_handle(&handle);
        ospi_dev_handle = NULL;
        return -1;
    }

    storage_dev->priv = ospi_dev_handle;
300193dc:	6034      	str	r4, [r6, #0]

    return 0;
}
300193de:	b002      	add	sp, #8
300193e0:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "ospi create handle failed\n");
300193e2:	f641 70c4 	movw	r0, #8132	; 0x1fc4
300193e6:	f2c3 0002 	movt	r0, #12290	; 0x3002
300193ea:	f7fc fbe1 	bl	30015bb0 <_printf>
        return -1;
300193ee:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
300193f2:	e7f4      	b.n	300193de <ospi_init+0x1e>
        dprintf(CRITICAL, "ospi hal init failed\n");
300193f4:	f641 70e0 	movw	r0, #8160	; 0x1fe0
300193f8:	f2c3 0002 	movt	r0, #12290	; 0x3002
300193fc:	f7fc fbd8 	bl	30015bb0 <_printf>
        hal_spi_nor_release_handle(&handle);
30019400:	a801      	add	r0, sp, #4
30019402:	f7f6 fdd7 	bl	3000ffb4 <hal_spi_nor_release_handle>
        return -1;
30019406:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3001940a:	e7e8      	b.n	300193de <ospi_init+0x1e>

3001940c <ospi_release>:

int ospi_release(storage_device_t *storage_dev)
{
3001940c:	b508      	push	{r3, r14}
    if (storage_dev->priv)
3001940e:	6803      	ldr	r3, [r0, #0]
30019410:	b113      	cbz	r3, 30019418 <ospi_release+0xc>
        return hal_spi_nor_release_handle(&(storage_dev->priv));
30019412:	f7f6 fdcf 	bl	3000ffb4 <hal_spi_nor_release_handle>

    dprintf(CRITICAL, "Do opsi hal init firstly\n");
    return -1;
}
30019416:	bd08      	pop	{r3, r15}
    dprintf(CRITICAL, "Do opsi hal init firstly\n");
30019418:	f242 0014 	movw	r0, #8212	; 0x2014
3001941c:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019420:	f7fc fbc6 	bl	30015bb0 <_printf>
    return -1;
30019424:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
30019428:	bd08      	pop	{r3, r15}
3001942a:	bf00      	nop

3001942c <ospi_get_block_size>:

uint32_t ospi_get_block_size(storage_device_t *storage_dev)
{
    dprintf(INFO, "return virtual block size\n");
    return virtual_block_size;
}
3001942c:	f44f 7000 	mov.w	r0, #512	; 0x200
30019430:	4770      	bx	r14
30019432:	bf00      	nop

30019434 <ospi_read>:

int ospi_read(storage_device_t *storage_dev, uint64_t src, uint8_t *dst,
              uint64_t size)
{
    if (storage_dev->priv)
30019434:	6800      	ldr	r0, [r0, #0]
30019436:	b108      	cbz	r0, 3001943c <ospi_read+0x8>
        return hal_spi_nor_read(storage_dev->priv, src, dst, size);
30019438:	f7f6 be4c 	b.w	300100d4 <hal_spi_nor_read>

    dprintf(CRITICAL, "Do ospi hal init firstly\n");
3001943c:	f641 70f8 	movw	r0, #8184	; 0x1ff8
{
30019440:	b510      	push	{r4, r14}
    dprintf(CRITICAL, "Do ospi hal init firstly\n");
30019442:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019446:	f7fc fbb3 	bl	30015bb0 <_printf>
    return -1;
}
3001944a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3001944e:	bd10      	pop	{r4, r15}

30019450 <ospi_write>:

int ospi_write(storage_device_t *storage_dev, uint64_t dst,
               const uint8_t *buf, uint64_t data_len)
{
    if (storage_dev->priv) {
30019450:	6800      	ldr	r0, [r0, #0]
30019452:	b108      	cbz	r0, 30019458 <ospi_write+0x8>
        return hal_spi_nor_write(storage_dev->priv, dst, buf, data_len);
30019454:	f7f6 bee4 	b.w	30010220 <hal_spi_nor_write>
    }

    dprintf(CRITICAL, "Do ospi hal init firstly\n");
30019458:	f641 70f8 	movw	r0, #8184	; 0x1ff8
{
3001945c:	b510      	push	{r4, r14}
    dprintf(CRITICAL, "Do ospi hal init firstly\n");
3001945e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019462:	f7fc fba5 	bl	30015bb0 <_printf>
    return -1;
}
30019466:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
3001946a:	bd10      	pop	{r4, r15}

3001946c <ospi_erase>:

int ospi_erase(storage_device_t *storage_dev, uint64_t dst, uint64_t len)
{
    if (storage_dev->priv) {
3001946c:	6800      	ldr	r0, [r0, #0]
3001946e:	b108      	cbz	r0, 30019474 <ospi_erase+0x8>
        return hal_spi_nor_erase(storage_dev->priv, dst, len);
30019470:	f7f6 bf4e 	b.w	30010310 <hal_spi_nor_erase>
    }

    dprintf(CRITICAL, "Do ospi hal init firstly\n");
30019474:	f641 70f8 	movw	r0, #8184	; 0x1ff8
{
30019478:	b510      	push	{r4, r14}
    dprintf(CRITICAL, "Do ospi hal init firstly\n");
3001947a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001947e:	f7fc fb97 	bl	30015bb0 <_printf>
    return -1;
}
30019482:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
30019486:	bd10      	pop	{r4, r15}

30019488 <ospi_need_erase>:

bool ospi_need_erase(storage_device_t *storage_dev)
{
    return true;
}
30019488:	2001      	movs	r0, #1
3001948a:	4770      	bx	r14

3001948c <ospi_get_capacity>:

uint64_t ospi_get_capacity(storage_device_t *storage_dev)
{
    if (storage_dev->priv)
3001948c:	6800      	ldr	r0, [r0, #0]
3001948e:	b108      	cbz	r0, 30019494 <ospi_get_capacity+0x8>
        return hal_spi_nor_get_capacity(storage_dev->priv);
30019490:	f7f6 bf84 	b.w	3001039c <hal_spi_nor_get_capacity>

    dprintf(CRITICAL, "Do ospi hal init firstly\n");
30019494:	f641 70f8 	movw	r0, #8184	; 0x1ff8
{
30019498:	b508      	push	{r3, r14}
    dprintf(CRITICAL, "Do ospi hal init firstly\n");
3001949a:	f2c3 0002 	movt	r0, #12290	; 0x3002
3001949e:	f7fc fb87 	bl	30015bb0 <_printf>
    return 0;
}
300194a2:	2000      	movs	r0, #0
300194a4:	2100      	movs	r1, #0
300194a6:	bd08      	pop	{r3, r15}

300194a8 <ospi_get_id>:

bool ospi_get_id (storage_device_t *storage_dev, uint8_t *buf, uint32_t len)
{
    spi_nor_length_t flash_id;

    if (!buf || len == 0) {
300194a8:	fab2 f382 	clz	r3, r2
{
300194ac:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if (!buf || len == 0) {
300194b0:	095b      	lsrs	r3, r3, #5
{
300194b2:	b082      	sub	sp, #8
    if (!buf || len == 0) {
300194b4:	2900      	cmp	r1, #0
300194b6:	bf14      	ite	ne
300194b8:	461c      	movne	r4, r3
300194ba:	2401      	moveq	r4, #1
300194bc:	b9ec      	cbnz	r4, 300194fa <ospi_get_id+0x52>
        return 1;
    }

    memset(&flash_id, 0x0, sizeof(spi_nor_length_t));

    if (storage_dev->priv) {
300194be:	6800      	ldr	r0, [r0, #0]
    memset(&flash_id, 0x0, sizeof(spi_nor_length_t));
300194c0:	2600      	movs	r6, #0
300194c2:	2700      	movs	r7, #0
300194c4:	e9cd 6700 	strd	r6, r7, [r13]
    if (storage_dev->priv) {
300194c8:	b190      	cbz	r0, 300194f0 <ospi_get_id+0x48>
300194ca:	460d      	mov	r5, r1
300194cc:	4690      	mov	r8, r2
        flash_id = hal_spi_nor_get_flash_id(storage_dev->priv);
300194ce:	f7f6 ff7d 	bl	300103cc <hal_spi_nor_get_flash_id>
        memcpy(buf, &flash_id, MIN(len, sizeof(flash_id)));
300194d2:	4642      	mov	r2, r8
        flash_id = hal_spi_nor_get_flash_id(storage_dev->priv);
300194d4:	ab02      	add	r3, sp, #8
        memcpy(buf, &flash_id, MIN(len, sizeof(flash_id)));
300194d6:	2a08      	cmp	r2, #8
300194d8:	bf28      	it	cs
300194da:	2208      	movcs	r2, #8
        flash_id = hal_spi_nor_get_flash_id(storage_dev->priv);
300194dc:	e963 0102 	strd	r0, r1, [r3, #-8]!
        memcpy(buf, &flash_id, MIN(len, sizeof(flash_id)));
300194e0:	4628      	mov	r0, r5
300194e2:	4619      	mov	r1, r3
300194e4:	f7fb e9be 	blx	30014864 <memcpy>
        return 0;
    }

    return 1;
}
300194e8:	4620      	mov	r0, r4
300194ea:	b002      	add	sp, #8
300194ec:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    return 1;
300194f0:	2401      	movs	r4, #1
}
300194f2:	4620      	mov	r0, r4
300194f4:	b002      	add	sp, #8
300194f6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(CRITICAL, "Fail to get flash id, bad params\n\n");
300194fa:	f641 70a0 	movw	r0, #8096	; 0x1fa0
300194fe:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019502:	f7fc fb55 	bl	30015bb0 <_printf>
}
30019506:	4620      	mov	r0, r4
30019508:	b002      	add	sp, #8
3001950a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
3001950e:	bf00      	nop

30019510 <ospi_get_erase_group_size>:

uint32_t ospi_get_erase_group_size(storage_device_t *storage_dev)
{
    struct  spi_nor_handle *dev_handle = storage_dev->priv;
30019510:	6800      	ldr	r0, [r0, #0]

    if (storage_dev->priv)
30019512:	b100      	cbz	r0, 30019516 <ospi_get_erase_group_size+0x6>
        return dev_handle->block_size;
30019514:	6940      	ldr	r0, [r0, #20]
    else
        return 0;
}
30019516:	4770      	bx	r14

30019518 <heap_insert_free_chunk>:
}

// try to insert this free chunk into the free list, consuming the chunk by merging it with
// nearby ones if possible. Returns base of whatever chunk it became in the list.
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
{
30019518:	b538      	push	{r3, r4, r5, r14}
3001951a:	f64d 0578 	movw	r5, #55416	; 0xd878
3001951e:	4604      	mov	r4, r0
30019520:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
30019524:	f2c3 0502 	movt	r5, #12290	; 0x3002
30019528:	f105 0010 	add.w	r0, r5, #16
3001952c:	f7f8 fa7e 	bl	30011a2c <mutex_acquire_timeout>
    struct free_heap_chunk *next_chunk;
    struct free_heap_chunk *last_chunk;

    mutex_acquire(&theheap.lock);

    theheap.remaining += chunk->len;
30019530:	68a0      	ldr	r0, [r4, #8]
30019532:	68a9      	ldr	r1, [r5, #8]

    // walk through the list, finding the node to insert before
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
30019534:	f105 0248 	add.w	r2, r5, #72	; 0x48
30019538:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    theheap.remaining += chunk->len;
3001953a:	4401      	add	r1, r0
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
3001953c:	4293      	cmp	r3, r2
    theheap.remaining += chunk->len;
3001953e:	60a9      	str	r1, [r5, #8]
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
30019540:	d103      	bne.n	3001954a <heap_insert_free_chunk+0x32>
30019542:	e01d      	b.n	30019580 <heap_insert_free_chunk+0x68>
30019544:	685b      	ldr	r3, [r3, #4]
30019546:	4293      	cmp	r3, r2
30019548:	d01a      	beq.n	30019580 <heap_insert_free_chunk+0x68>
        if (chunk < next_chunk) {
3001954a:	429c      	cmp	r4, r3
3001954c:	d2fa      	bcs.n	30019544 <heap_insert_free_chunk+0x2c>
    item->prev = list->prev;
3001954e:	6819      	ldr	r1, [r3, #0]
30019550:	6021      	str	r1, [r4, #0]
    list->prev->next = item;
30019552:	6819      	ldr	r1, [r3, #0]
    item->next = list;
30019554:	6063      	str	r3, [r4, #4]
    list->prev->next = item;
30019556:	604c      	str	r4, [r1, #4]
    list->prev = item;
30019558:	601c      	str	r4, [r3, #0]
    // walked off the end of the list, add it at the tail
    list_add_tail(&theheap.free_list, &chunk->node);

    // try to merge with the previous chunk
try_merge:
    last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
3001955a:	6821      	ldr	r1, [r4, #0]
3001955c:	2900      	cmp	r1, #0
3001955e:	bf18      	it	ne
30019560:	4291      	cmpne	r1, r2
30019562:	d004      	beq.n	3001956e <heap_insert_free_chunk+0x56>
    if (last_chunk) {
        if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
30019564:	688a      	ldr	r2, [r1, #8]
30019566:	188d      	adds	r5, r1, r2
30019568:	42ac      	cmp	r4, r5
3001956a:	d017      	beq.n	3001959c <heap_insert_free_chunk+0x84>
            chunk = last_chunk;
        }
    }

    // try to merge with the next chunk
    if (next_chunk) {
3001956c:	b11b      	cbz	r3, 30019576 <heap_insert_free_chunk+0x5e>
        if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
3001956e:	68a2      	ldr	r2, [r4, #8]
30019570:	18a1      	adds	r1, r4, r2
30019572:	428b      	cmp	r3, r1
30019574:	d01f      	beq.n	300195b6 <heap_insert_free_chunk+0x9e>
            // remove them from the list
            list_delete(&next_chunk->node);
        }
    }

    mutex_release(&theheap.lock);
30019576:	4818      	ldr	r0, [pc, #96]	; (300195d8 <heap_insert_free_chunk+0xc0>)
30019578:	f7f8 fa84 	bl	30011a84 <mutex_release>

    return chunk;
}
3001957c:	4620      	mov	r0, r4
3001957e:	bd38      	pop	{r3, r4, r5, r15}
    item->prev = list->prev;
30019580:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    item->next = list;
30019582:	e9c4 1200 	strd	r1, r2, [r4]
    list->prev->next = item;
30019586:	6ca9      	ldr	r1, [r5, #72]	; 0x48
30019588:	604c      	str	r4, [r1, #4]
    list->prev = item;
3001958a:	64ac      	str	r4, [r5, #72]	; 0x48
    last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
3001958c:	6821      	ldr	r1, [r4, #0]
3001958e:	2900      	cmp	r1, #0
30019590:	bf18      	it	ne
30019592:	4291      	cmpne	r1, r2
30019594:	d1e6      	bne.n	30019564 <heap_insert_free_chunk+0x4c>
    if (next_chunk) {
30019596:	2b00      	cmp	r3, #0
30019598:	d1e9      	bne.n	3001956e <heap_insert_free_chunk+0x56>
3001959a:	e7ec      	b.n	30019576 <heap_insert_free_chunk+0x5e>
    item->next->prev = item->prev;
3001959c:	6865      	ldr	r5, [r4, #4]
            last_chunk->len += chunk->len;
3001959e:	4410      	add	r0, r2
    item->prev = item->next = 0;
300195a0:	2200      	movs	r2, #0
300195a2:	6088      	str	r0, [r1, #8]
    item->next->prev = item->prev;
300195a4:	6029      	str	r1, [r5, #0]
    item->prev->next = item->next;
300195a6:	6820      	ldr	r0, [r4, #0]
300195a8:	6045      	str	r5, [r0, #4]
    item->prev = item->next = 0;
300195aa:	e9c4 2200 	strd	r2, r2, [r4]
300195ae:	460c      	mov	r4, r1
    if (next_chunk) {
300195b0:	2b00      	cmp	r3, #0
300195b2:	d1dc      	bne.n	3001956e <heap_insert_free_chunk+0x56>
300195b4:	e7df      	b.n	30019576 <heap_insert_free_chunk+0x5e>
            chunk->len += next_chunk->len;
300195b6:	6899      	ldr	r1, [r3, #8]
300195b8:	2000      	movs	r0, #0
    item->next->prev = item->prev;
300195ba:	685d      	ldr	r5, [r3, #4]
300195bc:	440a      	add	r2, r1
300195be:	6819      	ldr	r1, [r3, #0]
300195c0:	60a2      	str	r2, [r4, #8]
300195c2:	6029      	str	r1, [r5, #0]
    item->prev->next = item->next;
300195c4:	681a      	ldr	r2, [r3, #0]
300195c6:	6055      	str	r5, [r2, #4]
    item->prev = item->next = 0;
300195c8:	e9c3 0000 	strd	r0, r0, [r3]
    mutex_release(&theheap.lock);
300195cc:	4802      	ldr	r0, [pc, #8]	; (300195d8 <heap_insert_free_chunk+0xc0>)
300195ce:	f7f8 fa59 	bl	30011a84 <mutex_release>
}
300195d2:	4620      	mov	r0, r4
300195d4:	bd38      	pop	{r3, r4, r5, r15}
300195d6:	bf00      	nop
300195d8:	3002d888 	.word	0x3002d888

300195dc <miniheap_alloc>:

    return chunk;
}

void *miniheap_alloc(size_t size, unsigned int alignment)
{
300195dc:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
#endif

    LTRACEF("size %zd, align %d\n", size, alignment);

    // alignment must be power of 2
    if (alignment & (alignment - 1))
300195e0:	1e4b      	subs	r3, r1, #1
300195e2:	420b      	tst	r3, r1
300195e4:	f040 80c0 	bne.w	30019768 <miniheap_alloc+0x18c>
300195e8:	4688      	mov	r8, r1
        return NULL;

    // we always put a size field + base pointer + magic in front of the allocation
    size += sizeof(struct alloc_struct_begin);
300195ea:	f100 0408 	add.w	r4, r0, #8
    // in the spot
    if (size < sizeof(struct free_heap_chunk))
        size = sizeof(struct free_heap_chunk);

    // round up size to a multiple of native pointer size
    size = ROUNDUP(size, sizeof(void *));
300195ee:	4620      	mov	r0, r4
300195f0:	2c0c      	cmp	r4, #12
300195f2:	bf38      	it	cc
300195f4:	200c      	movcc	r0, #12
300195f6:	1cc4      	adds	r4, r0, #3
300195f8:	f024 0403 	bic.w	r4, r4, #3

    // deal with nonzero alignments
    if (alignment > 0) {
300195fc:	2900      	cmp	r1, #0
300195fe:	f040 80ad 	bne.w	3001975c <miniheap_alloc+0x180>
30019602:	f64d 0778 	movw	r7, #55416	; 0xd878
30019606:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3001960a:	f2c3 0702 	movt	r7, #12290	; 0x3002
3001960e:	f107 002c 	add.w	r0, r7, #44	; 0x2c
30019612:	f7f8 fa0b 	bl	30011a2c <mutex_acquire_timeout>
30019616:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
3001961a:	f107 0010 	add.w	r0, r7, #16
3001961e:	f7f8 fa05 	bl	30011a2c <mutex_acquire_timeout>
    mutex_acquire(&theheap.lock);

    // walk through the list
    ptr = NULL;
    struct free_heap_chunk *chunk;
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
30019622:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
30019624:	f107 0648 	add.w	r6, r7, #72	; 0x48
    mutex_release(&theheap.lock);
}

static ssize_t heap_grow(size_t size)
{
    size = ROUNDUP(size, PAGE_SIZE);
30019628:	f604 79ff 	addw	r9, r4, #4095	; 0xfff
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
3001962c:	42b3      	cmp	r3, r6
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
3001962e:	ea4f 3519 	mov.w	r5, r9, lsr #12
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
30019632:	d009      	beq.n	30019648 <miniheap_alloc+0x6c>
        if (chunk->len >= size) {
30019634:	689a      	ldr	r2, [r3, #8]
30019636:	42a2      	cmp	r2, r4
30019638:	d303      	bcc.n	30019642 <miniheap_alloc+0x66>
3001963a:	e045      	b.n	300196c8 <miniheap_alloc+0xec>
3001963c:	689a      	ldr	r2, [r3, #8]
3001963e:	4294      	cmp	r4, r2
30019640:	d942      	bls.n	300196c8 <miniheap_alloc+0xec>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
30019642:	685b      	ldr	r3, [r3, #4]
30019644:	42b3      	cmp	r3, r6
30019646:	d1f9      	bne.n	3001963c <miniheap_alloc+0x60>
    mutex_release(&theheap.lock);
30019648:	484f      	ldr	r0, [pc, #316]	; (30019788 <miniheap_alloc+0x1ac>)
    size = ROUNDUP(size, PAGE_SIZE);
3001964a:	f429 697f 	bic.w	r9, r9, #4080	; 0xff0
    mutex_release(&theheap.lock);
3001964e:	f7f8 fa19 	bl	30011a84 <mutex_release>
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
30019652:	4628      	mov	r0, r5
30019654:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    size = ROUNDUP(size, PAGE_SIZE);
30019658:	f029 090f 	bic.w	r9, r9, #15
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
3001965c:	f7fb f8c6 	bl	300147ec <page_alloc>
    if (!ptr) {
30019660:	4605      	mov	r5, r0
30019662:	2800      	cmp	r0, #0
30019664:	f000 8082 	beq.w	3001976c <miniheap_alloc+0x190>
    chunk->len = len;
30019668:	f8c0 9008 	str.w	r9, [r0, #8]
        return ERR_NO_MEMORY;
    }

    LTRACEF("growing heap by 0x%zx bytes, new ptr %p\n", size, ptr);

    heap_insert_free_chunk(heap_create_free_chunk(ptr, size, true));
3001966c:	f7ff ff54 	bl	30019518 <heap_insert_free_chunk>

    /* change the heap start and end variables */
    if ((uintptr_t)ptr < (uintptr_t)theheap.base || theheap.base == 0)
30019670:	683b      	ldr	r3, [r7, #0]
30019672:	429d      	cmp	r5, r3
30019674:	bf2c      	ite	cs
30019676:	2200      	movcs	r2, #0
30019678:	2201      	movcc	r2, #1
3001967a:	2b00      	cmp	r3, #0
3001967c:	bf08      	it	eq
3001967e:	2201      	moveq	r2, #1
30019680:	b10a      	cbz	r2, 30019686 <miniheap_alloc+0xaa>
        theheap.base = ptr;
30019682:	603d      	str	r5, [r7, #0]
    if ((uintptr_t)ptr < (uintptr_t)theheap.base || theheap.base == 0)
30019684:	462b      	mov	r3, r5

    uintptr_t endptr = (uintptr_t)ptr + size;
    if (endptr > (uintptr_t)theheap.base + theheap.len) {
30019686:	687a      	ldr	r2, [r7, #4]
    uintptr_t endptr = (uintptr_t)ptr + size;
30019688:	444d      	add	r5, r9
    if (endptr > (uintptr_t)theheap.base + theheap.len) {
3001968a:	441a      	add	r2, r3
3001968c:	4295      	cmp	r5, r2
        theheap.len = (uintptr_t)endptr - (uintptr_t)theheap.base;
3001968e:	bf84      	itt	hi
30019690:	1aed      	subhi	r5, r5, r3
30019692:	607d      	strhi	r5, [r7, #4]
        if (err >= 0) {
30019694:	f1b9 0f00 	cmp.w	r9, #0
30019698:	db14      	blt.n	300196c4 <miniheap_alloc+0xe8>
3001969a:	483b      	ldr	r0, [pc, #236]	; (30019788 <miniheap_alloc+0x1ac>)
3001969c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
300196a0:	f7f8 f9c4 	bl	30011a2c <mutex_acquire_timeout>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
300196a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
300196a6:	42b3      	cmp	r3, r6
300196a8:	d009      	beq.n	300196be <miniheap_alloc+0xe2>
        if (chunk->len >= size) {
300196aa:	689a      	ldr	r2, [r3, #8]
300196ac:	4294      	cmp	r4, r2
300196ae:	d803      	bhi.n	300196b8 <miniheap_alloc+0xdc>
300196b0:	e00a      	b.n	300196c8 <miniheap_alloc+0xec>
300196b2:	689a      	ldr	r2, [r3, #8]
300196b4:	42a2      	cmp	r2, r4
300196b6:	d207      	bcs.n	300196c8 <miniheap_alloc+0xec>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
300196b8:	685b      	ldr	r3, [r3, #4]
300196ba:	42b3      	cmp	r3, r6
300196bc:	d1f9      	bne.n	300196b2 <miniheap_alloc+0xd6>
    mutex_release(&theheap.lock);
300196be:	4832      	ldr	r0, [pc, #200]	; (30019788 <miniheap_alloc+0x1ac>)
300196c0:	f7f8 f9e0 	bl	30011a84 <mutex_release>
    ptr = NULL;
300196c4:	2500      	movs	r5, #0
300196c6:	e02f      	b.n	30019728 <miniheap_alloc+0x14c>
            struct list_node *next_node = list_next(&theheap.free_list, &chunk->node);
300196c8:	6859      	ldr	r1, [r3, #4]
300196ca:	f104 0c0c 	add.w	r12, r4, #12
300196ce:	681d      	ldr	r5, [r3, #0]
300196d0:	2000      	movs	r0, #0
    if (item->next != list)
300196d2:	42b1      	cmp	r1, r6
300196d4:	d02e      	beq.n	30019734 <miniheap_alloc+0x158>
    item->next->prev = item->prev;
300196d6:	600d      	str	r5, [r1, #0]
            if (chunk->len > size + sizeof(struct free_heap_chunk)) {
300196d8:	4562      	cmp	r2, r12
    item->prev->next = item->next;
300196da:	681d      	ldr	r5, [r3, #0]
300196dc:	6069      	str	r1, [r5, #4]
    item->prev = item->next = 0;
300196de:	e9c3 0000 	strd	r0, r0, [r3]
300196e2:	d92e      	bls.n	30019742 <miniheap_alloc+0x166>
                struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
300196e4:	1918      	adds	r0, r3, r4
    item->prev = list->prev;
300196e6:	680d      	ldr	r5, [r1, #0]
300196e8:	1b12      	subs	r2, r2, r4
    chunk->len = len;
300196ea:	6082      	str	r2, [r0, #8]
                chunk->len -= chunk->len - size;
300196ec:	609c      	str	r4, [r3, #8]
300196ee:	511d      	str	r5, [r3, r4]
    list->prev->next = item;
300196f0:	680a      	ldr	r2, [r1, #0]
    item->next = list;
300196f2:	6041      	str	r1, [r0, #4]
    list->prev->next = item;
300196f4:	6050      	str	r0, [r2, #4]
    list->prev = item;
300196f6:	6008      	str	r0, [r1, #0]
            ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
300196f8:	f103 0508 	add.w	r5, r3, #8
            if (alignment > 0) {
300196fc:	f1b8 0f00 	cmp.w	r8, #0
30019700:	d006      	beq.n	30019710 <miniheap_alloc+0x134>
                ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
30019702:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
30019706:	4415      	add	r5, r2
30019708:	f1c8 0800 	rsb	r8, r8, #0
3001970c:	ea05 0508 	and.w	r5, r5, r8
            if (theheap.remaining < theheap.low_watermark) {
30019710:	e9d7 2102 	ldrd	r2, r1, [r7, #8]
    mutex_release(&theheap.lock);
30019714:	481c      	ldr	r0, [pc, #112]	; (30019788 <miniheap_alloc+0x1ac>)
            as->size = size;
30019716:	e945 3402 	strd	r3, r4, [r5, #-8]
            theheap.remaining -= size;
3001971a:	1b12      	subs	r2, r2, r4
            if (theheap.remaining < theheap.low_watermark) {
3001971c:	428a      	cmp	r2, r1
            theheap.remaining -= size;
3001971e:	60ba      	str	r2, [r7, #8]
                theheap.low_watermark = theheap.remaining;
30019720:	bf38      	it	cc
30019722:	60fa      	strcc	r2, [r7, #12]
    mutex_release(&theheap.lock);
30019724:	f7f8 f9ae 	bl	30011a84 <mutex_release>
    mutex_release(&theheap.retry_lock);
30019728:	4818      	ldr	r0, [pc, #96]	; (3001978c <miniheap_alloc+0x1b0>)
3001972a:	f7f8 f9ab 	bl	30011a84 <mutex_release>
}
3001972e:	4628      	mov	r0, r5
30019730:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    item->next->prev = item->prev;
30019734:	64bd      	str	r5, [r7, #72]	; 0x48
            if (chunk->len > size + sizeof(struct free_heap_chunk)) {
30019736:	4562      	cmp	r2, r12
    item->prev->next = item->next;
30019738:	6819      	ldr	r1, [r3, #0]
3001973a:	604e      	str	r6, [r1, #4]
    item->prev = item->next = 0;
3001973c:	e9c3 0000 	strd	r0, r0, [r3]
30019740:	d801      	bhi.n	30019746 <miniheap_alloc+0x16a>
30019742:	689c      	ldr	r4, [r3, #8]
30019744:	e7d8      	b.n	300196f8 <miniheap_alloc+0x11c>
                struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
30019746:	1919      	adds	r1, r3, r4
    item->prev = list->prev;
30019748:	6cb8      	ldr	r0, [r7, #72]	; 0x48
3001974a:	1b12      	subs	r2, r2, r4
    chunk->len = len;
3001974c:	608a      	str	r2, [r1, #8]
                chunk->len -= chunk->len - size;
3001974e:	609c      	str	r4, [r3, #8]
30019750:	5118      	str	r0, [r3, r4]
    item->next = list;
30019752:	604e      	str	r6, [r1, #4]
    list->prev->next = item;
30019754:	6cba      	ldr	r2, [r7, #72]	; 0x48
30019756:	6051      	str	r1, [r2, #4]
    list->prev = item;
30019758:	64b9      	str	r1, [r7, #72]	; 0x48
3001975a:	e7cd      	b.n	300196f8 <miniheap_alloc+0x11c>
3001975c:	2910      	cmp	r1, #16
3001975e:	bf38      	it	cc
30019760:	f04f 0810 	movcc.w	r8, #16
        size += alignment;
30019764:	4444      	add	r4, r8
30019766:	e74c      	b.n	30019602 <miniheap_alloc+0x26>
        return NULL;
30019768:	2500      	movs	r5, #0
3001976a:	e7e0      	b.n	3001972e <miniheap_alloc+0x152>
        TRACEF("failed to grow kernel heap by 0x%zx bytes\n", size);
3001976c:	f242 0130 	movw	r1, #8240	; 0x2030
30019770:	f242 003c 	movw	r0, #8252	; 0x203c
30019774:	464b      	mov	r3, r9
30019776:	f2c3 0102 	movt	r1, #12290	; 0x3002
3001977a:	f44f 72fb 	mov.w	r2, #502	; 0x1f6
3001977e:	f2c3 0002 	movt	r0, #12290	; 0x3002
30019782:	f7fc fa15 	bl	30015bb0 <_printf>
30019786:	e7cf      	b.n	30019728 <miniheap_alloc+0x14c>
30019788:	3002d888 	.word	0x3002d888
3001978c:	3002d8a4 	.word	0x3002d8a4

30019790 <miniheap_free>:
    if (!ptr)
30019790:	b128      	cbz	r0, 3001979e <miniheap_free+0xe>
    chunk->len = len;
30019792:	e950 3202 	ldrd	r3, r2, [r0, #-8]
30019796:	609a      	str	r2, [r3, #8]
    heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size, true));
30019798:	4618      	mov	r0, r3
3001979a:	f7ff bebd 	b.w	30019518 <heap_insert_free_chunk>
}
3001979e:	4770      	bx	r14

300197a0 <miniheap_init>:

    return size;
}

void miniheap_init(void *ptr, size_t len)
{
300197a0:	b570      	push	{r4, r5, r6, r14}
    LTRACEF("ptr %p, len %zu\n", ptr, len);

    // create a mutex
    mutex_init(&theheap.lock);
300197a2:	f64d 0478 	movw	r4, #55416	; 0xd878
{
300197a6:	4606      	mov	r6, r0
300197a8:	460d      	mov	r5, r1
    mutex_init(&theheap.lock);
300197aa:	f2c3 0402 	movt	r4, #12290	; 0x3002
300197ae:	f104 0010 	add.w	r0, r4, #16
300197b2:	f7f8 f901 	bl	300119b8 <mutex_init>
    mutex_init(&theheap.retry_lock);
300197b6:	f104 002c 	add.w	r0, r4, #44	; 0x2c
300197ba:	f7f8 f8fd 	bl	300119b8 <mutex_init>
    list_initialize(&theheap.free_list);

    // set the heap range
    theheap.base = ptr;
    theheap.len = len;
    theheap.remaining = 0; // will get set by heap_insert_free_chunk()
300197be:	2300      	movs	r3, #0
    theheap.len = len;
300197c0:	e9c4 6500 	strd	r6, r5, [r4]
    list->prev = list->next = list;
300197c4:	f104 0248 	add.w	r2, r4, #72	; 0x48
    theheap.low_watermark = 0;
300197c8:	e9c4 3302 	strd	r3, r3, [r4, #8]
300197cc:	e9c4 2212 	strd	r2, r2, [r4, #72]	; 0x48

    // if passed a default range, use it
    if (len > 0)
300197d0:	b905      	cbnz	r5, 300197d4 <miniheap_init+0x34>
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
}
300197d2:	bd70      	pop	{r4, r5, r6, r15}
    chunk->len = len;
300197d4:	60b5      	str	r5, [r6, #8]
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
300197d6:	4630      	mov	r0, r6
}
300197d8:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
300197dc:	f7ff be9c 	b.w	30019518 <heap_insert_free_chunk>

300197e0 <__debug_stdio_write>:
    spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
}

static ssize_t __debug_stdio_write(io_handle_t *io, const char *s,
                                   size_t len)
{
300197e0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    return (list->next == list) ? true : false;
300197e4:	f245 4750 	movw	r7, #21584	; 0x5450
300197e8:	460c      	mov	r4, r1
300197ea:	4616      	mov	r6, r2
300197ec:	f2c3 0702 	movt	r7, #12290	; 0x3002
300197f0:	687d      	ldr	r5, [r7, #4]
    if (!list_is_empty(&print_callbacks)) {
300197f2:	42bd      	cmp	r5, r7
300197f4:	d013      	beq.n	3001981e <__debug_stdio_write+0x3e>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300197f6:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300197fa:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
300197fc:	bf48      	it	mi
300197fe:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30019802:	d52b      	bpl.n	3001985c <__debug_stdio_write+0x7c>
            if (cb->print)
30019804:	68ab      	ldr	r3, [r5, #8]
                cb->print(cb, str, len);
30019806:	4628      	mov	r0, r5
30019808:	4632      	mov	r2, r6
3001980a:	4621      	mov	r1, r4
            if (cb->print)
3001980c:	b103      	cbz	r3, 30019810 <__debug_stdio_write+0x30>
                cb->print(cb, str, len);
3001980e:	4798      	blx	r3
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
30019810:	686d      	ldr	r5, [r5, #4]
30019812:	42bd      	cmp	r5, r7
30019814:	d1f6      	bne.n	30019804 <__debug_stdio_write+0x24>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30019816:	f1b8 0f00 	cmp.w	r8, #0
3001981a:	d000      	beq.n	3001981e <__debug_stdio_write+0x3e>
    __asm__ volatile("cpsie i");
3001981c:	b662      	cpsie	i
    for (i = 0; i < len; i++) {
3001981e:	b1d6      	cbz	r6, 30019856 <__debug_stdio_write+0x76>
30019820:	f64e 05c8 	movw	r5, #59592	; 0xe8c8
30019824:	1e77      	subs	r7, r6, #1
30019826:	f64d 08c8 	movw	r8, #55496	; 0xd8c8
3001982a:	4427      	add	r7, r4
3001982c:	f2c3 0502 	movt	r5, #12290	; 0x3002
30019830:	3c01      	subs	r4, #1
30019832:	f2c3 0802 	movt	r8, #12290	; 0x3002
        platform_dputc(str[i]);
30019836:	f814 0f01 	ldrb.w	r0, [r4, #1]!
3001983a:	f7e6 fea9 	bl	30000590 <platform_dputc>
        log_buf[log_buf_index++] = str[i];
3001983e:	682b      	ldr	r3, [r5, #0]
    for (i = 0; i < len; i++) {
30019840:	42a7      	cmp	r7, r4
        log_buf[log_buf_index++] = str[i];
30019842:	f103 0201 	add.w	r2, r3, #1
        log_buf_index %= MAX_LOG_BUF_LEN;
30019846:	f3c2 010b 	ubfx	r1, r2, #0, #12
        log_buf[log_buf_index++] = str[i];
3001984a:	602a      	str	r2, [r5, #0]
3001984c:	7822      	ldrb	r2, [r4, #0]
        log_buf_index %= MAX_LOG_BUF_LEN;
3001984e:	6029      	str	r1, [r5, #0]
        log_buf[log_buf_index++] = str[i];
30019850:	f808 2003 	strb.w	r2, [r8, r3]
    for (i = 0; i < len; i++) {
30019854:	d1ef      	bne.n	30019836 <__debug_stdio_write+0x56>
    out_count(s, len);
    return len;
}
30019856:	4630      	mov	r0, r6
30019858:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    __asm__ volatile("cpsid i");
3001985c:	b672      	cpsid	i
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
3001985e:	687d      	ldr	r5, [r7, #4]
30019860:	42bd      	cmp	r5, r7
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30019862:	bf18      	it	ne
30019864:	f04f 0801 	movne.w	r8, #1
30019868:	d1cc      	bne.n	30019804 <__debug_stdio_write+0x24>
3001986a:	e7d7      	b.n	3001981c <__debug_stdio_write+0x3c>

3001986c <__debug_stdio_read>:

static ssize_t __debug_stdio_read(io_handle_t *io, char *s, size_t len)
{
    if (len == 0)
3001986c:	b90a      	cbnz	r2, 30019872 <__debug_stdio_read+0x6>
        return 0;
3001986e:	4610      	mov	r0, r2
    if (err < 0)
        return err;

    return 1;
#endif
}
30019870:	4770      	bx	r14
{
30019872:	b508      	push	{r3, r14}
30019874:	4608      	mov	r0, r1
    int err = platform_dgetc(s, true);
30019876:	2101      	movs	r1, #1
30019878:	f7e6 fe8c 	bl	30000594 <platform_dgetc>
    return 1;
3001987c:	ea10 0020 	ands.w	r0, r0, r0, asr #32
30019880:	bf38      	it	cc
30019882:	2001      	movcc	r0, #1
}
30019884:	bd08      	pop	{r3, r15}
30019886:	bf00      	nop

30019888 <io_write>:

ssize_t io_write(io_handle_t *io, const char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->write)
30019888:	6843      	ldr	r3, [r0, #4]
3001988a:	681b      	ldr	r3, [r3, #0]
3001988c:	b103      	cbz	r3, 30019890 <io_write+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->write(io, buf, len);
3001988e:	4718      	bx	r3
}
30019890:	f06f 0017 	mvn.w	r0, #23
30019894:	4770      	bx	r14
30019896:	bf00      	nop

30019898 <io_read>:

ssize_t io_read(io_handle_t *io, char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->read)
30019898:	6843      	ldr	r3, [r0, #4]
3001989a:	685b      	ldr	r3, [r3, #4]
3001989c:	b103      	cbz	r3, 300198a0 <io_read+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->read(io, buf, len);
3001989e:	4718      	bx	r3
}
300198a0:	f06f 0017 	mvn.w	r0, #23
300198a4:	4770      	bx	r14
300198a6:	bf00      	nop

300198a8 <cbuf_initialize>:

#define INC_POINTER(cbuf, ptr, inc) \
    modpow2(((ptr) + (inc)), (cbuf)->len_pow2)

void cbuf_initialize(cbuf_t *cbuf, size_t len)
{
300198a8:	b570      	push	{r4, r5, r6, r14}
300198aa:	4604      	mov	r4, r0
    cbuf_initialize_etc(cbuf, len, malloc(len));
300198ac:	4608      	mov	r0, r1
{
300198ae:	460d      	mov	r5, r1
    cbuf_initialize_etc(cbuf, len, malloc(len));
300198b0:	f7fa ff1a 	bl	300146e8 <malloc>
{
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(len > 0);
    DEBUG_ASSERT(ispow2(len));

    cbuf->head = 0;
300198b4:	2300      	movs	r3, #0
    cbuf->tail = 0;
300198b6:	e9c4 3300 	strd	r3, r3, [r4]
    cbuf_initialize_etc(cbuf, len, malloc(len));
300198ba:	4606      	mov	r6, r0
    if (val == 0)
300198bc:	b11d      	cbz	r5, 300198c6 <cbuf_initialize+0x1e>
    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
300198be:	fab5 f585 	clz	r5, r5
300198c2:	f1c5 051f 	rsb	r5, r5, #31
    cbuf->len_pow2 = log2_uint(len);
    cbuf->buf = buf;
    event_init(&cbuf->event, false, 0);
300198c6:	2200      	movs	r2, #0
300198c8:	f104 0010 	add.w	r0, r4, #16
    cbuf->len_pow2 = log2_uint(len);
300198cc:	60a5      	str	r5, [r4, #8]
    event_init(&cbuf->event, false, 0);
300198ce:	4611      	mov	r1, r2
    cbuf->buf = buf;
300198d0:	60e6      	str	r6, [r4, #12]
    event_init(&cbuf->event, false, 0);
300198d2:	f7f7 ffef 	bl	300118b4 <event_init>
    *lock = SPIN_LOCK_INITIAL_VALUE;
300198d6:	2300      	movs	r3, #0
300198d8:	62e3      	str	r3, [r4, #44]	; 0x2c
}
300198da:	bd70      	pop	{r4, r5, r6, r15}

300198dc <cbuf_space_avail>:

    memset(cbuf, 0, sizeof(cbuf_t));
}

size_t cbuf_space_avail(cbuf_t *cbuf)
{
300198dc:	b430      	push	{r4, r5}
}

static inline __ALWAYS_INLINE uint valpow2(uint valp2)
{
    return 1U << valp2;
300198de:	2201      	movs	r2, #1
    return val >> divp2;
}

static inline __ALWAYS_INLINE uint modpow2(uint val, uint modp2)
{
    return val & ((1UL << modp2) - 1);
300198e0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
300198e4:	6884      	ldr	r4, [r0, #8]
300198e6:	e9d0 3500 	ldrd	r3, r5, [r0]
    return 1U << valp2;
300198ea:	fa02 f004 	lsl.w	r0, r2, r4
300198ee:	1b5b      	subs	r3, r3, r5
    return val & ((1UL << modp2) - 1);
300198f0:	fa01 f204 	lsl.w	r2, r1, r4
    return valpow2(cbuf->len_pow2) - consumed - 1;
300198f4:	4408      	add	r0, r1
300198f6:	ea23 0302 	bic.w	r3, r3, r2
}
300198fa:	1ac0      	subs	r0, r0, r3
300198fc:	bc30      	pop	{r4, r5}
300198fe:	4770      	bx	r14

30019900 <cbuf_write_char>:
    spin_unlock_irqrestore(&cbuf->lock, state);
    return ret;
}

size_t cbuf_write_char(cbuf_t *cbuf, char c, bool canreschedule)
{
30019900:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
30019902:	4604      	mov	r4, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
30019904:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
30019908:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
3001990a:	bf48      	it	mi
3001990c:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3001990e:	d401      	bmi.n	30019914 <cbuf_write_char+0x14>
    __asm__ volatile("cpsid i");
30019910:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30019912:	2701      	movs	r7, #1
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
30019914:	6820      	ldr	r0, [r4, #0]
30019916:	f04f 3cff 	mov.w	r12, #4294967295	; 0xffffffff
3001991a:	68a3      	ldr	r3, [r4, #8]
    *lock = 1;
3001991c:	2601      	movs	r6, #1
3001991e:	6865      	ldr	r5, [r4, #4]
30019920:	fa0c fe03 	lsl.w	r14, r12, r3
30019924:	1b45      	subs	r5, r0, r5
30019926:	ea25 050e 	bic.w	r5, r5, r14
    return 1U << valp2;
3001992a:	fa06 f303 	lsl.w	r3, r6, r3
3001992e:	62e6      	str	r6, [r4, #44]	; 0x2c
    return valpow2(cbuf->len_pow2) - consumed - 1;
30019930:	1b5b      	subs	r3, r3, r5

    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    size_t ret = 0;
    if (cbuf_space_avail(cbuf) > 0) {
30019932:	42b3      	cmp	r3, r6
    size_t ret = 0;
30019934:	bf08      	it	eq
30019936:	2000      	moveq	r0, #0
    if (cbuf_space_avail(cbuf) > 0) {
30019938:	d014      	beq.n	30019964 <cbuf_write_char+0x64>
        cbuf->buf[cbuf->head] = c;
3001993a:	68e3      	ldr	r3, [r4, #12]
3001993c:	5419      	strb	r1, [r3, r0]

        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
3001993e:	6820      	ldr	r0, [r4, #0]
    return val & ((1UL << modp2) - 1);
30019940:	68a3      	ldr	r3, [r4, #8]
        ret = 1;

        if (cbuf->head != cbuf->tail)
30019942:	6861      	ldr	r1, [r4, #4]
30019944:	fa0c fc03 	lsl.w	r12, r12, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
30019948:	1983      	adds	r3, r0, r6
3001994a:	ea23 030c 	bic.w	r3, r3, r12
        if (cbuf->head != cbuf->tail)
3001994e:	4299      	cmp	r1, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
30019950:	6023      	str	r3, [r4, #0]
        ret = 1;
30019952:	bf08      	it	eq
30019954:	4630      	moveq	r0, r6
        if (cbuf->head != cbuf->tail)
30019956:	d005      	beq.n	30019964 <cbuf_write_char+0x64>
            event_signal(&cbuf->event, canreschedule);
30019958:	4611      	mov	r1, r2
3001995a:	f104 0010 	add.w	r0, r4, #16
3001995e:	f7f7 ffe5 	bl	3001192c <event_signal>
        ret = 1;
30019962:	4630      	mov	r0, r6
    *lock = 0;
30019964:	2300      	movs	r3, #0
30019966:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
30019968:	b107      	cbz	r7, 3001996c <cbuf_write_char+0x6c>
    __asm__ volatile("cpsie i");
3001996a:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&cbuf->lock, state);

    return ret;
}
3001996c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
3001996e:	bf00      	nop

30019970 <cbuf_read_char>:

size_t cbuf_read_char(cbuf_t *cbuf, char *c, bool block)
{
30019970:	b570      	push	{r4, r5, r6, r14}
30019972:	4604      	mov	r4, r0
30019974:	460e      	mov	r6, r1
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(c);

retry:
    if (block)
30019976:	4615      	mov	r5, r2
30019978:	bb42      	cbnz	r2, 300199cc <cbuf_read_char+0x5c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
3001997a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
3001997e:	f013 0380 	ands.w	r3, r3, #128	; 0x80
30019982:	d12e      	bne.n	300199e2 <cbuf_read_char+0x72>
    __asm__ volatile("cpsid i");
30019984:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    // see if there's data available
    size_t ret = 0;
    if (cbuf->tail != cbuf->head) {
30019986:	e9d4 0100 	ldrd	r0, r1, [r4]
    *lock = 1;
3001998a:	2201      	movs	r2, #1
3001998c:	62e2      	str	r2, [r4, #44]	; 0x2c
3001998e:	4281      	cmp	r1, r0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
30019990:	bf18      	it	ne
30019992:	4615      	movne	r5, r2
30019994:	d015      	beq.n	300199c2 <cbuf_read_char+0x52>

        *c = cbuf->buf[cbuf->tail];
30019996:	68e2      	ldr	r2, [r4, #12]
30019998:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
3001999c:	5c52      	ldrb	r2, [r2, r1]
3001999e:	7032      	strb	r2, [r6, #0]
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
300199a0:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
300199a4:	fa03 f101 	lsl.w	r1, r3, r1
300199a8:	1c53      	adds	r3, r2, #1

        if (cbuf->tail == cbuf->head) {
300199aa:	6822      	ldr	r2, [r4, #0]
300199ac:	ea23 0301 	bic.w	r3, r3, r1
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
300199b0:	6063      	str	r3, [r4, #4]
        if (cbuf->tail == cbuf->head) {
300199b2:	429a      	cmp	r2, r3
300199b4:	d022      	beq.n	300199fc <cbuf_read_char+0x8c>
    *lock = 0;
300199b6:	2300      	movs	r3, #0
300199b8:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300199ba:	b1ed      	cbz	r5, 300199f8 <cbuf_read_char+0x88>
    __asm__ volatile("cpsie i");
300199bc:	b662      	cpsie	i
300199be:	2001      	movs	r0, #1

    if (block && ret == 0)
        goto retry;

    return ret;
}
300199c0:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 0;
300199c2:	62e3      	str	r3, [r4, #44]	; 0x2c
300199c4:	b662      	cpsie	i
300199c6:	4628      	mov	r0, r5
    if (block && ret == 0)
300199c8:	2d00      	cmp	r5, #0
300199ca:	d0f9      	beq.n	300199c0 <cbuf_read_char+0x50>
300199cc:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
300199d0:	f104 0010 	add.w	r0, r4, #16
300199d4:	f7f7 ff84 	bl	300118e0 <event_wait_timeout>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
300199d8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
300199dc:	f013 0380 	ands.w	r3, r3, #128	; 0x80
300199e0:	d0d0      	beq.n	30019984 <cbuf_read_char+0x14>
    if (cbuf->tail != cbuf->head) {
300199e2:	e9d4 3100 	ldrd	r3, r1, [r4]
    *lock = 1;
300199e6:	2201      	movs	r2, #1
300199e8:	62e2      	str	r2, [r4, #44]	; 0x2c
300199ea:	4299      	cmp	r1, r3
    *lock = 0;
300199ec:	bf04      	itt	eq
300199ee:	2300      	moveq	r3, #0
300199f0:	62e3      	streq	r3, [r4, #44]	; 0x2c
300199f2:	d0e8      	beq.n	300199c6 <cbuf_read_char+0x56>
    spin_lock_saved_state_t state = 0;
300199f4:	2500      	movs	r5, #0
300199f6:	e7ce      	b.n	30019996 <cbuf_read_char+0x26>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
300199f8:	2001      	movs	r0, #1
}
300199fa:	bd70      	pop	{r4, r5, r6, r15}
            event_unsignal(&cbuf->event);
300199fc:	f104 0010 	add.w	r0, r4, #16
30019a00:	f7f7 ffca 	bl	30011998 <event_unsignal>
30019a04:	e7d7      	b.n	300199b6 <cbuf_read_char+0x46>
30019a06:	bf00      	nop

30019a08 <__aeabi_drsub>:
30019a08:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
30019a0c:	e002      	b.n	30019a14 <__adddf3>
30019a0e:	bf00      	nop

30019a10 <__aeabi_dsub>:
30019a10:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

30019a14 <__adddf3>:
30019a14:	b530      	push	{r4, r5, r14}
30019a16:	ea4f 0441 	mov.w	r4, r1, lsl #1
30019a1a:	ea4f 0543 	mov.w	r5, r3, lsl #1
30019a1e:	ea94 0f05 	teq	r4, r5
30019a22:	bf08      	it	eq
30019a24:	ea90 0f02 	teqeq	r0, r2
30019a28:	bf1f      	itttt	ne
30019a2a:	ea54 0c00 	orrsne.w	r12, r4, r0
30019a2e:	ea55 0c02 	orrsne.w	r12, r5, r2
30019a32:	ea7f 5c64 	mvnsne.w	r12, r4, asr #21
30019a36:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
30019a3a:	f000 80e2 	beq.w	30019c02 <__adddf3+0x1ee>
30019a3e:	ea4f 5454 	mov.w	r4, r4, lsr #21
30019a42:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
30019a46:	bfb8      	it	lt
30019a48:	426d      	neglt	r5, r5
30019a4a:	dd0c      	ble.n	30019a66 <__adddf3+0x52>
30019a4c:	442c      	add	r4, r5
30019a4e:	ea80 0202 	eor.w	r2, r0, r2
30019a52:	ea81 0303 	eor.w	r3, r1, r3
30019a56:	ea82 0000 	eor.w	r0, r2, r0
30019a5a:	ea83 0101 	eor.w	r1, r3, r1
30019a5e:	ea80 0202 	eor.w	r2, r0, r2
30019a62:	ea81 0303 	eor.w	r3, r1, r3
30019a66:	2d36      	cmp	r5, #54	; 0x36
30019a68:	bf88      	it	hi
30019a6a:	bd30      	pophi	{r4, r5, r15}
30019a6c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
30019a70:	ea4f 3101 	mov.w	r1, r1, lsl #12
30019a74:	f44f 1c80 	mov.w	r12, #1048576	; 0x100000
30019a78:	ea4c 3111 	orr.w	r1, r12, r1, lsr #12
30019a7c:	d002      	beq.n	30019a84 <__adddf3+0x70>
30019a7e:	4240      	negs	r0, r0
30019a80:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
30019a84:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
30019a88:	ea4f 3303 	mov.w	r3, r3, lsl #12
30019a8c:	ea4c 3313 	orr.w	r3, r12, r3, lsr #12
30019a90:	d002      	beq.n	30019a98 <__adddf3+0x84>
30019a92:	4252      	negs	r2, r2
30019a94:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
30019a98:	ea94 0f05 	teq	r4, r5
30019a9c:	f000 80a7 	beq.w	30019bee <__adddf3+0x1da>
30019aa0:	f1a4 0401 	sub.w	r4, r4, #1
30019aa4:	f1d5 0e20 	rsbs	r14, r5, #32
30019aa8:	db0d      	blt.n	30019ac6 <__adddf3+0xb2>
30019aaa:	fa02 fc0e 	lsl.w	r12, r2, r14
30019aae:	fa22 f205 	lsr.w	r2, r2, r5
30019ab2:	1880      	adds	r0, r0, r2
30019ab4:	f141 0100 	adc.w	r1, r1, #0
30019ab8:	fa03 f20e 	lsl.w	r2, r3, r14
30019abc:	1880      	adds	r0, r0, r2
30019abe:	fa43 f305 	asr.w	r3, r3, r5
30019ac2:	4159      	adcs	r1, r3
30019ac4:	e00e      	b.n	30019ae4 <__adddf3+0xd0>
30019ac6:	f1a5 0520 	sub.w	r5, r5, #32
30019aca:	f10e 0e20 	add.w	r14, r14, #32
30019ace:	2a01      	cmp	r2, #1
30019ad0:	fa03 fc0e 	lsl.w	r12, r3, r14
30019ad4:	bf28      	it	cs
30019ad6:	f04c 0c02 	orrcs.w	r12, r12, #2
30019ada:	fa43 f305 	asr.w	r3, r3, r5
30019ade:	18c0      	adds	r0, r0, r3
30019ae0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
30019ae4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
30019ae8:	d507      	bpl.n	30019afa <__adddf3+0xe6>
30019aea:	f04f 0e00 	mov.w	r14, #0
30019aee:	f1dc 0c00 	rsbs	r12, r12, #0
30019af2:	eb7e 0000 	sbcs.w	r0, r14, r0
30019af6:	eb6e 0101 	sbc.w	r1, r14, r1
30019afa:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
30019afe:	d31b      	bcc.n	30019b38 <__adddf3+0x124>
30019b00:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
30019b04:	d30c      	bcc.n	30019b20 <__adddf3+0x10c>
30019b06:	0849      	lsrs	r1, r1, #1
30019b08:	ea5f 0030 	movs.w	r0, r0, rrx
30019b0c:	ea4f 0c3c 	mov.w	r12, r12, rrx
30019b10:	f104 0401 	add.w	r4, r4, #1
30019b14:	ea4f 5244 	mov.w	r2, r4, lsl #21
30019b18:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
30019b1c:	f080 809a 	bcs.w	30019c54 <__adddf3+0x240>
30019b20:	f1bc 4f00 	cmp.w	r12, #2147483648	; 0x80000000
30019b24:	bf08      	it	eq
30019b26:	ea5f 0c50 	movseq.w	r12, r0, lsr #1
30019b2a:	f150 0000 	adcs.w	r0, r0, #0
30019b2e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
30019b32:	ea41 0105 	orr.w	r1, r1, r5
30019b36:	bd30      	pop	{r4, r5, r15}
30019b38:	ea5f 0c4c 	movs.w	r12, r12, lsl #1
30019b3c:	4140      	adcs	r0, r0
30019b3e:	eb41 0101 	adc.w	r1, r1, r1
30019b42:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
30019b46:	f1a4 0401 	sub.w	r4, r4, #1
30019b4a:	d1e9      	bne.n	30019b20 <__adddf3+0x10c>
30019b4c:	f091 0f00 	teq	r1, #0
30019b50:	bf04      	itt	eq
30019b52:	4601      	moveq	r1, r0
30019b54:	2000      	moveq	r0, #0
30019b56:	fab1 f381 	clz	r3, r1
30019b5a:	bf08      	it	eq
30019b5c:	3320      	addeq	r3, #32
30019b5e:	f1a3 030b 	sub.w	r3, r3, #11
30019b62:	f1b3 0220 	subs.w	r2, r3, #32
30019b66:	da0c      	bge.n	30019b82 <__adddf3+0x16e>
30019b68:	320c      	adds	r2, #12
30019b6a:	dd08      	ble.n	30019b7e <__adddf3+0x16a>
30019b6c:	f102 0c14 	add.w	r12, r2, #20
30019b70:	f1c2 020c 	rsb	r2, r2, #12
30019b74:	fa01 f00c 	lsl.w	r0, r1, r12
30019b78:	fa21 f102 	lsr.w	r1, r1, r2
30019b7c:	e00c      	b.n	30019b98 <__adddf3+0x184>
30019b7e:	f102 0214 	add.w	r2, r2, #20
30019b82:	bfd8      	it	le
30019b84:	f1c2 0c20 	rsble	r12, r2, #32
30019b88:	fa01 f102 	lsl.w	r1, r1, r2
30019b8c:	fa20 fc0c 	lsr.w	r12, r0, r12
30019b90:	bfdc      	itt	le
30019b92:	ea41 010c 	orrle.w	r1, r1, r12
30019b96:	4090      	lslle	r0, r2
30019b98:	1ae4      	subs	r4, r4, r3
30019b9a:	bfa2      	ittt	ge
30019b9c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
30019ba0:	4329      	orrge	r1, r5
30019ba2:	bd30      	popge	{r4, r5, r15}
30019ba4:	ea6f 0404 	mvn.w	r4, r4
30019ba8:	3c1f      	subs	r4, #31
30019baa:	da1c      	bge.n	30019be6 <__adddf3+0x1d2>
30019bac:	340c      	adds	r4, #12
30019bae:	dc0e      	bgt.n	30019bce <__adddf3+0x1ba>
30019bb0:	f104 0414 	add.w	r4, r4, #20
30019bb4:	f1c4 0220 	rsb	r2, r4, #32
30019bb8:	fa20 f004 	lsr.w	r0, r0, r4
30019bbc:	fa01 f302 	lsl.w	r3, r1, r2
30019bc0:	ea40 0003 	orr.w	r0, r0, r3
30019bc4:	fa21 f304 	lsr.w	r3, r1, r4
30019bc8:	ea45 0103 	orr.w	r1, r5, r3
30019bcc:	bd30      	pop	{r4, r5, r15}
30019bce:	f1c4 040c 	rsb	r4, r4, #12
30019bd2:	f1c4 0220 	rsb	r2, r4, #32
30019bd6:	fa20 f002 	lsr.w	r0, r0, r2
30019bda:	fa01 f304 	lsl.w	r3, r1, r4
30019bde:	ea40 0003 	orr.w	r0, r0, r3
30019be2:	4629      	mov	r1, r5
30019be4:	bd30      	pop	{r4, r5, r15}
30019be6:	fa21 f004 	lsr.w	r0, r1, r4
30019bea:	4629      	mov	r1, r5
30019bec:	bd30      	pop	{r4, r5, r15}
30019bee:	f094 0f00 	teq	r4, #0
30019bf2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
30019bf6:	bf06      	itte	eq
30019bf8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
30019bfc:	3401      	addeq	r4, #1
30019bfe:	3d01      	subne	r5, #1
30019c00:	e74e      	b.n	30019aa0 <__adddf3+0x8c>
30019c02:	ea7f 5c64 	mvns.w	r12, r4, asr #21
30019c06:	bf18      	it	ne
30019c08:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
30019c0c:	d029      	beq.n	30019c62 <__adddf3+0x24e>
30019c0e:	ea94 0f05 	teq	r4, r5
30019c12:	bf08      	it	eq
30019c14:	ea90 0f02 	teqeq	r0, r2
30019c18:	d005      	beq.n	30019c26 <__adddf3+0x212>
30019c1a:	ea54 0c00 	orrs.w	r12, r4, r0
30019c1e:	bf04      	itt	eq
30019c20:	4619      	moveq	r1, r3
30019c22:	4610      	moveq	r0, r2
30019c24:	bd30      	pop	{r4, r5, r15}
30019c26:	ea91 0f03 	teq	r1, r3
30019c2a:	bf1e      	ittt	ne
30019c2c:	2100      	movne	r1, #0
30019c2e:	2000      	movne	r0, #0
30019c30:	bd30      	popne	{r4, r5, r15}
30019c32:	ea5f 5c54 	movs.w	r12, r4, lsr #21
30019c36:	d105      	bne.n	30019c44 <__adddf3+0x230>
30019c38:	0040      	lsls	r0, r0, #1
30019c3a:	4149      	adcs	r1, r1
30019c3c:	bf28      	it	cs
30019c3e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
30019c42:	bd30      	pop	{r4, r5, r15}
30019c44:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
30019c48:	bf3c      	itt	cc
30019c4a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
30019c4e:	bd30      	popcc	{r4, r5, r15}
30019c50:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
30019c54:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
30019c58:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
30019c5c:	f04f 0000 	mov.w	r0, #0
30019c60:	bd30      	pop	{r4, r5, r15}
30019c62:	ea7f 5c64 	mvns.w	r12, r4, asr #21
30019c66:	bf1a      	itte	ne
30019c68:	4619      	movne	r1, r3
30019c6a:	4610      	movne	r0, r2
30019c6c:	ea7f 5c65 	mvnseq.w	r12, r5, asr #21
30019c70:	bf1c      	itt	ne
30019c72:	460b      	movne	r3, r1
30019c74:	4602      	movne	r2, r0
30019c76:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
30019c7a:	bf06      	itte	eq
30019c7c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
30019c80:	ea91 0f03 	teqeq	r1, r3
30019c84:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
30019c88:	bd30      	pop	{r4, r5, r15}
30019c8a:	bf00      	nop

30019c8c <__aeabi_ui2d>:
30019c8c:	f090 0f00 	teq	r0, #0
30019c90:	bf04      	itt	eq
30019c92:	2100      	moveq	r1, #0
30019c94:	4770      	bxeq	r14
30019c96:	b530      	push	{r4, r5, r14}
30019c98:	f44f 6480 	mov.w	r4, #1024	; 0x400
30019c9c:	f104 0432 	add.w	r4, r4, #50	; 0x32
30019ca0:	f04f 0500 	mov.w	r5, #0
30019ca4:	f04f 0100 	mov.w	r1, #0
30019ca8:	e750      	b.n	30019b4c <__adddf3+0x138>
30019caa:	bf00      	nop

30019cac <__aeabi_i2d>:
30019cac:	f090 0f00 	teq	r0, #0
30019cb0:	bf04      	itt	eq
30019cb2:	2100      	moveq	r1, #0
30019cb4:	4770      	bxeq	r14
30019cb6:	b530      	push	{r4, r5, r14}
30019cb8:	f44f 6480 	mov.w	r4, #1024	; 0x400
30019cbc:	f104 0432 	add.w	r4, r4, #50	; 0x32
30019cc0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
30019cc4:	bf48      	it	mi
30019cc6:	4240      	negmi	r0, r0
30019cc8:	f04f 0100 	mov.w	r1, #0
30019ccc:	e73e      	b.n	30019b4c <__adddf3+0x138>
30019cce:	bf00      	nop

30019cd0 <__aeabi_f2d>:
30019cd0:	0042      	lsls	r2, r0, #1
30019cd2:	ea4f 01e2 	mov.w	r1, r2, asr #3
30019cd6:	ea4f 0131 	mov.w	r1, r1, rrx
30019cda:	ea4f 7002 	mov.w	r0, r2, lsl #28
30019cde:	bf1f      	itttt	ne
30019ce0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
30019ce4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
30019ce8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
30019cec:	4770      	bxne	r14
30019cee:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
30019cf2:	bf08      	it	eq
30019cf4:	4770      	bxeq	r14
30019cf6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
30019cfa:	bf04      	itt	eq
30019cfc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
30019d00:	4770      	bxeq	r14
30019d02:	b530      	push	{r4, r5, r14}
30019d04:	f44f 7460 	mov.w	r4, #896	; 0x380
30019d08:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
30019d0c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
30019d10:	e71c      	b.n	30019b4c <__adddf3+0x138>
30019d12:	bf00      	nop

30019d14 <__aeabi_ul2d>:
30019d14:	ea50 0201 	orrs.w	r2, r0, r1
30019d18:	bf08      	it	eq
30019d1a:	4770      	bxeq	r14
30019d1c:	b530      	push	{r4, r5, r14}
30019d1e:	f04f 0500 	mov.w	r5, #0
30019d22:	e00a      	b.n	30019d3a <__aeabi_l2d+0x16>

30019d24 <__aeabi_l2d>:
30019d24:	ea50 0201 	orrs.w	r2, r0, r1
30019d28:	bf08      	it	eq
30019d2a:	4770      	bxeq	r14
30019d2c:	b530      	push	{r4, r5, r14}
30019d2e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
30019d32:	d502      	bpl.n	30019d3a <__aeabi_l2d+0x16>
30019d34:	4240      	negs	r0, r0
30019d36:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
30019d3a:	f44f 6480 	mov.w	r4, #1024	; 0x400
30019d3e:	f104 0432 	add.w	r4, r4, #50	; 0x32
30019d42:	ea5f 5c91 	movs.w	r12, r1, lsr #22
30019d46:	f43f aed8 	beq.w	30019afa <__adddf3+0xe6>
30019d4a:	f04f 0203 	mov.w	r2, #3
30019d4e:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
30019d52:	bf18      	it	ne
30019d54:	3203      	addne	r2, #3
30019d56:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
30019d5a:	bf18      	it	ne
30019d5c:	3203      	addne	r2, #3
30019d5e:	eb02 02dc 	add.w	r2, r2, r12, lsr #3
30019d62:	f1c2 0320 	rsb	r3, r2, #32
30019d66:	fa00 fc03 	lsl.w	r12, r0, r3
30019d6a:	fa20 f002 	lsr.w	r0, r0, r2
30019d6e:	fa01 fe03 	lsl.w	r14, r1, r3
30019d72:	ea40 000e 	orr.w	r0, r0, r14
30019d76:	fa21 f102 	lsr.w	r1, r1, r2
30019d7a:	4414      	add	r4, r2
30019d7c:	e6bd      	b.n	30019afa <__adddf3+0xe6>
30019d7e:	bf00      	nop

30019d80 <__aeabi_ldivmod>:
30019d80:	b97b      	cbnz	r3, 30019da2 <__aeabi_ldivmod+0x22>
30019d82:	b972      	cbnz	r2, 30019da2 <__aeabi_ldivmod+0x22>
30019d84:	2900      	cmp	r1, #0
30019d86:	bfbe      	ittt	lt
30019d88:	2000      	movlt	r0, #0
30019d8a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
30019d8e:	e006      	blt.n	30019d9e <__aeabi_ldivmod+0x1e>
30019d90:	bf08      	it	eq
30019d92:	2800      	cmpeq	r0, #0
30019d94:	bf1c      	itt	ne
30019d96:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
30019d9a:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
30019d9e:	f000 b8f9 	b.w	30019f94 <__aeabi_idiv0>
30019da2:	f1ad 0c08 	sub.w	r12, r13, #8
30019da6:	e96d ce04 	strd	r12, r14, [r13, #-16]!
30019daa:	2900      	cmp	r1, #0
30019dac:	db09      	blt.n	30019dc2 <__aeabi_ldivmod+0x42>
30019dae:	2b00      	cmp	r3, #0
30019db0:	db1a      	blt.n	30019de8 <__aeabi_ldivmod+0x68>
30019db2:	f000 f84d 	bl	30019e50 <__udivmoddi4>
30019db6:	f8dd e004 	ldr.w	r14, [r13, #4]
30019dba:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30019dbe:	b004      	add	sp, #16
30019dc0:	4770      	bx	r14
30019dc2:	4240      	negs	r0, r0
30019dc4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
30019dc8:	2b00      	cmp	r3, #0
30019dca:	db1b      	blt.n	30019e04 <__aeabi_ldivmod+0x84>
30019dcc:	f000 f840 	bl	30019e50 <__udivmoddi4>
30019dd0:	f8dd e004 	ldr.w	r14, [r13, #4]
30019dd4:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30019dd8:	b004      	add	sp, #16
30019dda:	4240      	negs	r0, r0
30019ddc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
30019de0:	4252      	negs	r2, r2
30019de2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
30019de6:	4770      	bx	r14
30019de8:	4252      	negs	r2, r2
30019dea:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
30019dee:	f000 f82f 	bl	30019e50 <__udivmoddi4>
30019df2:	f8dd e004 	ldr.w	r14, [r13, #4]
30019df6:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30019dfa:	b004      	add	sp, #16
30019dfc:	4240      	negs	r0, r0
30019dfe:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
30019e02:	4770      	bx	r14
30019e04:	4252      	negs	r2, r2
30019e06:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
30019e0a:	f000 f821 	bl	30019e50 <__udivmoddi4>
30019e0e:	f8dd e004 	ldr.w	r14, [r13, #4]
30019e12:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30019e16:	b004      	add	sp, #16
30019e18:	4252      	negs	r2, r2
30019e1a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
30019e1e:	4770      	bx	r14

30019e20 <__aeabi_uldivmod>:
30019e20:	b953      	cbnz	r3, 30019e38 <__aeabi_uldivmod+0x18>
30019e22:	b94a      	cbnz	r2, 30019e38 <__aeabi_uldivmod+0x18>
30019e24:	2900      	cmp	r1, #0
30019e26:	bf08      	it	eq
30019e28:	2800      	cmpeq	r0, #0
30019e2a:	bf1c      	itt	ne
30019e2c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
30019e30:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
30019e34:	f000 b8ae 	b.w	30019f94 <__aeabi_idiv0>
30019e38:	f1ad 0c08 	sub.w	r12, r13, #8
30019e3c:	e96d ce04 	strd	r12, r14, [r13, #-16]!
30019e40:	f000 f806 	bl	30019e50 <__udivmoddi4>
30019e44:	f8dd e004 	ldr.w	r14, [r13, #4]
30019e48:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
30019e4c:	b004      	add	sp, #16
30019e4e:	4770      	bx	r14

30019e50 <__udivmoddi4>:
30019e50:	4299      	cmp	r1, r3
30019e52:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
30019e56:	bf08      	it	eq
30019e58:	4290      	cmpeq	r0, r2
30019e5a:	b083      	sub	sp, #12
30019e5c:	4682      	mov	r10, r0
30019e5e:	468b      	mov	r11, r1
30019e60:	f8dd 8030 	ldr.w	r8, [r13, #48]	; 0x30
30019e64:	d37c      	bcc.n	30019f60 <__udivmoddi4+0x110>
30019e66:	4610      	mov	r0, r2
30019e68:	4619      	mov	r1, r3
30019e6a:	fab3 f283 	clz	r2, r3
30019e6e:	2b00      	cmp	r3, #0
30019e70:	f000 8084 	beq.w	30019f7c <__udivmoddi4+0x12c>
30019e74:	fabb f38b 	clz	r3, r11
30019e78:	f1bb 0f00 	cmp.w	r11, #0
30019e7c:	d07a      	beq.n	30019f74 <__udivmoddi4+0x124>
30019e7e:	1ad3      	subs	r3, r2, r3
30019e80:	f1a3 0e20 	sub.w	r14, r3, #32
30019e84:	fa01 f703 	lsl.w	r7, r1, r3
30019e88:	fa00 f20e 	lsl.w	r2, r0, r14
30019e8c:	f1c3 0c20 	rsb	r12, r3, #32
30019e90:	4317      	orrs	r7, r2
30019e92:	fa20 f20c 	lsr.w	r2, r0, r12
30019e96:	4317      	orrs	r7, r2
30019e98:	fa00 f603 	lsl.w	r6, r0, r3
30019e9c:	45bb      	cmp	r11, r7
30019e9e:	bf08      	it	eq
30019ea0:	45b2      	cmpeq	r10, r6
30019ea2:	d362      	bcc.n	30019f6a <__udivmoddi4+0x11a>
30019ea4:	ebba 0a06 	subs.w	r10, r10, r6
30019ea8:	f04f 0201 	mov.w	r2, #1
30019eac:	eb6b 0b07 	sbc.w	r11, r11, r7
30019eb0:	fa02 f10e 	lsl.w	r1, r2, r14
30019eb4:	fa22 f90c 	lsr.w	r9, r2, r12
30019eb8:	409a      	lsls	r2, r3
30019eba:	ea41 0109 	orr.w	r1, r1, r9
30019ebe:	9200      	str	r2, [sp, #0]
30019ec0:	9101      	str	r1, [sp, #4]
30019ec2:	2b00      	cmp	r3, #0
30019ec4:	d042      	beq.n	30019f4c <__udivmoddi4+0xfc>
30019ec6:	087f      	lsrs	r7, r7, #1
30019ec8:	ea4f 0636 	mov.w	r6, r6, rrx
30019ecc:	461a      	mov	r2, r3
30019ece:	e00c      	b.n	30019eea <__udivmoddi4+0x9a>
30019ed0:	ebba 0006 	subs.w	r0, r10, r6
30019ed4:	eb6b 0107 	sbc.w	r1, r11, r7
30019ed8:	1804      	adds	r4, r0, r0
30019eda:	eb41 0501 	adc.w	r5, r1, r1
30019ede:	f114 0a01 	adds.w	r10, r4, #1
30019ee2:	f145 0b00 	adc.w	r11, r5, #0
30019ee6:	3a01      	subs	r2, #1
30019ee8:	d009      	beq.n	30019efe <__udivmoddi4+0xae>
30019eea:	45bb      	cmp	r11, r7
30019eec:	bf08      	it	eq
30019eee:	45b2      	cmpeq	r10, r6
30019ef0:	d2ee      	bcs.n	30019ed0 <__udivmoddi4+0x80>
30019ef2:	eb1a 0a0a 	adds.w	r10, r10, r10
30019ef6:	eb4b 0b0b 	adc.w	r11, r11, r11
30019efa:	3a01      	subs	r2, #1
30019efc:	d1f5      	bne.n	30019eea <__udivmoddi4+0x9a>
30019efe:	fa0b fc0c 	lsl.w	r12, r11, r12
30019f02:	e9dd 0100 	ldrd	r0, r1, [r13]
30019f06:	fa2a f203 	lsr.w	r2, r10, r3
30019f0a:	fa2b fe0e 	lsr.w	r14, r11, r14
30019f0e:	ea42 020c 	orr.w	r2, r2, r12
30019f12:	eb10 000a 	adds.w	r0, r0, r10
30019f16:	fa2b f903 	lsr.w	r9, r11, r3
30019f1a:	ea42 0a0e 	orr.w	r10, r2, r14
30019f1e:	f1a3 0c20 	sub.w	r12, r3, #32
30019f22:	f1c3 0220 	rsb	r2, r3, #32
30019f26:	fa09 f703 	lsl.w	r7, r9, r3
30019f2a:	fa0a fc0c 	lsl.w	r12, r10, r12
30019f2e:	ea47 070c 	orr.w	r7, r7, r12
30019f32:	fa2a f202 	lsr.w	r2, r10, r2
30019f36:	fa0a f603 	lsl.w	r6, r10, r3
30019f3a:	eb41 010b 	adc.w	r1, r1, r11
30019f3e:	4317      	orrs	r7, r2
30019f40:	1b80      	subs	r0, r0, r6
30019f42:	46cb      	mov	r11, r9
30019f44:	eb61 0107 	sbc.w	r1, r1, r7
30019f48:	e9cd 0100 	strd	r0, r1, [r13]
30019f4c:	f1b8 0f00 	cmp.w	r8, #0
30019f50:	d001      	beq.n	30019f56 <__udivmoddi4+0x106>
30019f52:	e9c8 ab00 	strd	r10, r11, [r8]
30019f56:	e9dd 0100 	ldrd	r0, r1, [r13]
30019f5a:	b003      	add	sp, #12
30019f5c:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
30019f60:	2300      	movs	r3, #0
30019f62:	2400      	movs	r4, #0
30019f64:	e9cd 3400 	strd	r3, r4, [r13]
30019f68:	e7f0      	b.n	30019f4c <__udivmoddi4+0xfc>
30019f6a:	2100      	movs	r1, #0
30019f6c:	2200      	movs	r2, #0
30019f6e:	e9cd 1200 	strd	r1, r2, [r13]
30019f72:	e7a6      	b.n	30019ec2 <__udivmoddi4+0x72>
30019f74:	faba f38a 	clz	r3, r10
30019f78:	3320      	adds	r3, #32
30019f7a:	e780      	b.n	30019e7e <__udivmoddi4+0x2e>
30019f7c:	fab0 f380 	clz	r3, r0
30019f80:	f103 0220 	add.w	r2, r3, #32
30019f84:	fabb f38b 	clz	r3, r11
30019f88:	f1bb 0f00 	cmp.w	r11, #0
30019f8c:	f47f af77 	bne.w	30019e7e <__udivmoddi4+0x2e>
30019f90:	e7f0      	b.n	30019f74 <__udivmoddi4+0x124>
30019f92:	bf00      	nop

30019f94 <__aeabi_idiv0>:
30019f94:	4770      	bx	r14
30019f96:	bf00      	nop

30019f98 <__arm_context_switch_from_thumb>:
30019f98:	4778      	bx	r15
30019f9a:	46c0      	nop			; (mov r8, r8)
30019f9c:	eaff9a69 	b	30000948 <arm_context_switch>

30019fa0 <__thread_preempt_from_arm>:
30019fa0:	e51ff004 	ldr	r15, [pc, #-4]	; 30019fa4 <__thread_preempt_from_arm+0x4>
30019fa4:	30011fbd 	.word	0x30011fbd
