
lk_customize/build-ssystem_d9_ref/lk.elf:     file format elf32-littlearm


Disassembly of section .text:

00140000 <_start>:

.section ".text.boot"
.globl _start
_start:
#if WITH_NO_PHYS_RELOCATION
    ldr  pc,  =platform_reset
  140000:	e59ff018 	ldr	r15, [pc, #24]	; 140020 <_start+0x20>
    ldr  pc,  =arm_undefined
  140004:	e59ff018 	ldr	r15, [pc, #24]	; 140024 <_start+0x24>
    ldr  pc,  =arm_syscall
  140008:	e59ff018 	ldr	r15, [pc, #24]	; 140028 <_start+0x28>
    ldr  pc,  =arm_prefetch_abort
  14000c:	e59ff018 	ldr	r15, [pc, #24]	; 14002c <_start+0x2c>
    ldr  pc,  =arm_data_abort
  140010:	e59ff018 	ldr	r15, [pc, #24]	; 140030 <_start+0x30>
    ldr  pc,  =arm_reserved
  140014:	e59ff018 	ldr	r15, [pc, #24]	; 140034 <_start+0x34>
    ldr  pc,  =arm_irq
  140018:	e59ff018 	ldr	r15, [pc, #24]	; 140038 <_start+0x38>
    ldr  pc,  =arm_fiq
  14001c:	e59ff018 	ldr	r15, [pc, #24]	; 14003c <_start+0x3c>
    ldr  pc,  =platform_reset
  140020:	00140040 	.word	0x00140040
    ldr  pc,  =arm_undefined
  140024:	00140d6c 	.word	0x00140d6c
    ldr  pc,  =arm_syscall
  140028:	00140dc4 	.word	0x00140dc4
    ldr  pc,  =arm_prefetch_abort
  14002c:	00140e1c 	.word	0x00140e1c
    ldr  pc,  =arm_data_abort
  140030:	00140e78 	.word	0x00140e78
    ldr  pc,  =arm_reserved
  140034:	00140ed4 	.word	0x00140ed4
    ldr  pc,  =arm_irq
  140038:	00140ed8 	.word	0x00140ed8
    ldr  pc,  =arm_fiq
  14003c:	00140f5c 	.word	0x00140f5c

00140040 <arm_reset>:
    /* Fall through for the weak symbol */

.globl arm_reset
arm_reset:
#ifdef LOCKSTEP_SCR_ADDR
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  140040:	e59f017c 	ldr	r0, [pc, #380]	; 1401c4 <arm_reset+0x184>
    ldr     r1, [r0, #0]
  140044:	e5901000 	ldr	r1, [r0]
    bic     r1, #(0x3<<LOCKSTEP_SCR_BIT)
  140048:	e3c11003 	bic	r1, r1, #3
    str     r1, [r0, #0]
  14004c:	e5801000 	str	r1, [r0]
#endif
    mov     r0, #0    /* initialize general registers */
  140050:	e3a00000 	mov	r0, #0
    mov     r1, #0
  140054:	e3a01000 	mov	r1, #0
    mov     r2, #0
  140058:	e3a02000 	mov	r2, #0
    mov     r3, #0
  14005c:	e3a03000 	mov	r3, #0
    mov     r4, #0
  140060:	e3a04000 	mov	r4, #0
    mov     r5, #0
  140064:	e3a05000 	mov	r5, #0
    mov     r6, #0
  140068:	e3a06000 	mov	r6, #0
    mov     r7, #0
  14006c:	e3a07000 	mov	r7, #0
    mov     r8, #0
  140070:	e3a08000 	mov	r8, #0
    mov     r9, #0
  140074:	e3a09000 	mov	r9, #0
    mov     r10, #0
  140078:	e3a0a000 	mov	r10, #0
    mov     r11, #0
  14007c:	e3a0b000 	mov	r11, #0
    mov     r12, #0
  140080:	e3a0c000 	mov	r12, #0
    mov     sp, r0
  140084:	e1a0d000 	mov	r13, r0
    mov     lr, #0
  140088:	e3a0e000 	mov	r14, #0
    mrs     r4, cpsr	/* save the CPSR */
  14008c:	e10f4000 	mrs	r4, CPSR
    msr spsr_fsxc, r4	/*load spsr with value from cpsr*/
  140090:	e16ff004 	msr	SPSR_fsxc, r4

    /* at this point we're running at our final location in virtual memory (if enabled) */
.Lstack_setup:
    /* set up the stack for irq, fiq, abort, undefined, system/user, and lastly supervisor mode */
    mov     r12, #0
  140094:	e3a0c000 	mov	r12, #0

    cpsid   i,#0x12       /* irq */
  140098:	f10e0092 	cpsid	i,#18
    mov     sp, r12
  14009c:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
  1400a0:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
  1400a4:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x11       /* fiq */
  1400a8:	f10e0091 	cpsid	i,#17
    mov     r8, #0            /* r8/r9/r10/r11/r12 fiq dedicated registers */
  1400ac:	e3a08000 	mov	r8, #0
    mov     r9, #0
  1400b0:	e3a09000 	mov	r9, #0
    mov     r10, #0
  1400b4:	e3a0a000 	mov	r10, #0
    mov     r11, #0
  1400b8:	e3a0b000 	mov	r11, #0
    mov     r12, #0
  1400bc:	e3a0c000 	mov	r12, #0
    mov     sp, r12
  1400c0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
  1400c4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
  1400c8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x17       /* abort */
  1400cc:	f10e0097 	cpsid	i,#23
    mov     sp, r12
  1400d0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
  1400d4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
  1400d8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x1b       /* undefined */
  1400dc:	f10e009b 	cpsid	i,#27
    mov     sp, r12
  1400e0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
  1400e4:	e3a0e000 	mov	r14, #0
    msr     spsr_fsxc, r4 /*load spsr with value from cpsr*/
  1400e8:	e16ff004 	msr	SPSR_fsxc, r4
    cpsid   i,#0x1f       /* system */
  1400ec:	f10e009f 	cpsid	i,#31
    mov     sp, r12
  1400f0:	e1a0d00c 	mov	r13, r12
    mov     lr, #0
  1400f4:	e3a0e000 	mov	r14, #0
    cpsid   i,#0x13       /* supervisor */
  1400f8:	f10e0093 	cpsid	i,#19
    ldr     r12, =abort_stack
  1400fc:	e59fc0c4 	ldr	r12, [pc, #196]	; 1401c8 <arm_reset+0x188>
    add     r12, #ARCH_DEFAULT_STACK_SIZE
  140100:	e28cca01 	add	r12, r12, #4096	; 0x1000
    mov     sp, r12
  140104:	e1a0d00c 	mov	r13, r12

    /* stay in supervisor mode from now on out */

#if defined(ARM_WITH_VFP)
    ldr     r0, =0x00F00000
  140108:	e3a0060f 	mov	r0, #15728640	; 0xf00000
    mcr     p15, 0, r0, c1, c0, 2	/* Enable coprocessor access in CPACR */
  14010c:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
    ldr     r2, =0x40000000
  140110:	e3a02101 	mov	r2, #1073741824	; 0x40000000
    vmsr    fpexc, r2	/* Enable FPU access so that VFP registers can be initialized */
  140114:	eee82a10 	vmsr	fpexc, r2
    vmov    D0, r5, r6	/* r5/6 is 0 now */
  140118:	ec465b10 	vmov	d0, r5, r6
    vmov    D1, r5, r6
  14011c:	ec465b11 	vmov	d1, r5, r6
    vmov    D2, r5, r6
  140120:	ec465b12 	vmov	d2, r5, r6
    vmov    D3, r5, r6
  140124:	ec465b13 	vmov	d3, r5, r6
    vmov    D4, r5, r6
  140128:	ec465b14 	vmov	d4, r5, r6
    vmov    D5, r5, r6
  14012c:	ec465b15 	vmov	d5, r5, r6
    vmov    D6, r5, r6
  140130:	ec465b16 	vmov	d6, r5, r6
    vmov    D7, r5, r6
  140134:	ec465b17 	vmov	d7, r5, r6
    vmov    D8, r5, r6
  140138:	ec465b18 	vmov	d8, r5, r6
    vmov    D9, r5, r6
  14013c:	ec465b19 	vmov	d9, r5, r6
    vmov    D10, r5, r6
  140140:	ec465b1a 	vmov	d10, r5, r6
    vmov    D11, r5, r6
  140144:	ec465b1b 	vmov	d11, r5, r6
    vmov    D12, r5, r6
  140148:	ec465b1c 	vmov	d12, r5, r6
    vmov    D13, r5, r6
  14014c:	ec465b1d 	vmov	d13, r5, r6
    vmov    D14, r5, r6
  140150:	ec465b1e 	vmov	d14, r5, r6
    vmov    D15, r5, r6
  140154:	ec465b1f 	vmov	d15, r5, r6
#endif

    /* do some early cpu setup */
    mrc     p15, 0, r12, c1, c0, 0
  140158:	ee11cf10 	mrc	15, 0, r12, cr1, cr0, {0}
    /* i/d cache disable, mmu disabled */
    bic     r12, #(1<<12)
  14015c:	e3ccca01 	bic	r12, r12, #4096	; 0x1000
    bic     r12, #(1<<2 | 1<<0)
  140160:	e3ccc005 	bic	r12, r12, #5
#if WITH_KERNEL_VM
    /* enable caches so atomics and spinlocks work */
    orr     r12, r12, #(1<<12)
    orr     r12, r12, #(1<<2)
#endif // WITH_KERNEL_VM
    mcr     p15, 0, r12, c1, c0, 0
  140164:	ee01cf10 	mcr	15, 0, r12, cr1, cr0, {0}

    /* enable LLPP Normal AXI region */
    mrc     p15, 0, r12, c15, c0, 1
  140168:	ee1fcf30 	mrc	15, 0, r12, cr15, cr0, {1}
    orr     r12, r12, #1
  14016c:	e38cc001 	orr	r12, r12, #1
    mcr     p15, 0, r12, c15, c0, 1
  140170:	ee0fcf30 	mcr	15, 0, r12, cr15, cr0, {1}

    /* calculate the physical offset from our eventual virtual location */
.Lphys_offset:
    ldr     r4, =.Lphys_offset
  140174:	e59f4050 	ldr	r4, [pc, #80]	; 1401cc <arm_reset+0x18c>
    adr     r11, .Lphys_offset
  140178:	e24fb00c 	sub	r11, r15, #12
    sub     r11, r11, r4
  14017c:	e04bb004 	sub	r11, r11, r4
    /* set up the mmu */
    bl      .Lmmu_setup
#endif // WITH_KERNEL_VM

    /* copy the initialized data segment out of rom if necessary */
    ldr     r4, =__data_start_rom
  140180:	e59f4048 	ldr	r4, [pc, #72]	; 1401d0 <arm_reset+0x190>
    ldr     r5, =__data_start
  140184:	e59f5048 	ldr	r5, [pc, #72]	; 1401d4 <arm_reset+0x194>
    ldr     r6, =__data_end
  140188:	e59f6048 	ldr	r6, [pc, #72]	; 1401d8 <arm_reset+0x198>

    cmp     r4, r5
  14018c:	e1540005 	cmp	r4, r5
    beq     .L__do_bss
  140190:	0a000003 	beq	1401a4 <arm_reset+0x164>

.L__copy_loop:
    cmp     r5, r6
  140194:	e1550006 	cmp	r5, r6
    ldrlt   r7, [r4], #4
  140198:	b4947004 	ldrlt	r7, [r4], #4
    strlt   r7, [r5], #4
  14019c:	b4857004 	strlt	r7, [r5], #4
    blt     .L__copy_loop
  1401a0:	bafffffb 	blt	140194 <arm_reset+0x154>

.L__do_bss:
    /* clear out the bss */
    ldr     r4, =__bss_start
  1401a4:	e59f4030 	ldr	r4, [pc, #48]	; 1401dc <arm_reset+0x19c>
    ldr     r5, =_end
  1401a8:	e59f5030 	ldr	r5, [pc, #48]	; 1401e0 <arm_reset+0x1a0>
    mov     r6, #0
  1401ac:	e3a06000 	mov	r6, #0
.L__bss_loop:
    cmp     r4, r5
  1401b0:	e1540005 	cmp	r4, r5
    strlt   r6, [r4], #4
  1401b4:	b4846004 	strlt	r6, [r4], #4
    blt     .L__bss_loop
  1401b8:	bafffffc 	blt	1401b0 <arm_reset+0x170>

    bl      lk_main
  1401bc:	fa0006ec 	blx	141d74 <lk_main>
    b       .
  1401c0:	eafffffe 	b	1401c0 <arm_reset+0x180>
    ldr     r0, =(LOCKSTEP_SCR_ADDR)
  1401c4:	f82ad000 	.word	0xf82ad000
    ldr     r12, =abort_stack
  1401c8:	00161160 	.word	0x00161160
    ldr     r4, =.Lphys_offset
  1401cc:	00140174 	.word	0x00140174
    ldr     r4, =__data_start_rom
  1401d0:	00158a08 	.word	0x00158a08
    ldr     r5, =__data_start
  1401d4:	00158a08 	.word	0x00158a08
    ldr     r6, =__data_end
  1401d8:	001610e8 	.word	0x001610e8
    ldr     r4, =__bss_start
  1401dc:	00161100 	.word	0x00161100
    ldr     r5, =_end
  1401e0:	00166764 	.word	0x00166764

001401e4 <target_early_init>:

static void uart_port_config(void)
{
    void *g_handle;
    bool ret;
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
  1401e4:	f247 43c8 	movw	r3, #29896	; 0x74c8
  1401e8:	f2c0 0315 	movt	r3, #21
    return ret;
}

#endif
void target_early_init(void)
{
  1401ec:	b500      	push	{r14}
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
  1401ee:	6859      	ldr	r1, [r3, #4]
{
  1401f0:	b083      	sub	sp, #12
    ret = hal_port_creat_handle(&g_handle, g_iomuxc_res.res_id[0]);
  1401f2:	a801      	add	r0, sp, #4
  1401f4:	f00d ffe6 	bl	14e1c4 <hal_port_creat_handle>
    if (!ret) {
  1401f8:	b1b8      	cbz	r0, 14022a <target_early_init+0x46>
    hal_port_set_pin_mode(g_handle, PortConf_PIN_GPIO_C6, uart10_tx);
  1401fa:	f644 3334 	movw	r3, #19252	; 0x4b34
  1401fe:	2136      	movs	r1, #54	; 0x36
  140200:	9801      	ldr	r0, [sp, #4]
  140202:	f2c0 0315 	movt	r3, #21
  140206:	cb0c      	ldmia	r3, {r2, r3}
  140208:	f00e f87e 	bl	14e308 <hal_port_set_pin_mode>
    hal_port_set_pin_mode(g_handle, PortConf_PIN_GPIO_C7, uart10_rx);
  14020c:	f644 3334 	movw	r3, #19252	; 0x4b34
  140210:	2137      	movs	r1, #55	; 0x37
  140212:	f2c0 0315 	movt	r3, #21
  140216:	9801      	ldr	r0, [sp, #4]
  140218:	cb0c      	ldmia	r3, {r2, r3}
  14021a:	f00e f875 	bl	14e308 <hal_port_set_pin_mode>
    hal_port_release_handle(&g_handle);
  14021e:	a801      	add	r0, sp, #4
  140220:	f00e f83a 	bl	14e298 <hal_port_release_handle>
        change_voltage(800, 850, 850);
    else
        change_voltage(720, 850, 850);

#endif
}
  140224:	b003      	add	sp, #12
  140226:	f85d fb04 	ldr.w	r15, [r13], #4
        printf("create prot hal failed.\n");
  14022a:	f644 3018 	movw	r0, #19224	; 0x4b18
  14022e:	f2c0 0015 	movt	r0, #21
  140232:	f013 ff61 	bl	1540f8 <_printf>
}
  140236:	b003      	add	sp, #12
  140238:	f85d fb04 	ldr.w	r15, [r13], #4

0014023c <target_init>:

void target_init(void)
{
}
  14023c:	4770      	bx	r14
  14023e:	bf00      	nop

00140240 <target_quiesce>:
  140240:	4770      	bx	r14
  140242:	bf00      	nop
  140244:	0000      	movs	r0, r0
	...

00140248 <platform_cpu_reset>:
 * Remap core vector, and reset the core.
 */
void platform_cpu_reset(addr_t img_base)
{
    /* base address must be 4 KB aligned */
    ASSERT((img_base & 0xFFF) == 0);
  140248:	f3c0 030b 	ubfx	r3, r0, #0, #12
{
  14024c:	b5f0      	push	{r4, r5, r6, r7, r14}
  14024e:	4674      	mov	r4, r14
  140250:	b085      	sub	sp, #20
    ASSERT((img_base & 0xFFF) == 0);
  140252:	2b00      	cmp	r3, #0
  140254:	d14e      	bne.n	1402f4 <platform_cpu_reset+0xac>
    dprintf(INFO, "Remapping ARM vector to 0x%lx!\n", img_base);
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  140256:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  14025a:	f644 5250 	movw	r2, #19792	; 0x4d50
  14025e:	f6cf 0341 	movt	r3, #63553	; 0xf841
  140262:	4605      	mov	r5, r0
  140264:	f2c5 2245 	movt	r2, #21061	; 0x5245
    /* Enable R5 remapping to vector base. The remap config doesn't
     * take effect until REMAP module detects R5 core reset.
     */
    scr_handle_t handle;
    handle = hal_scr_create_handle(
  140268:	2014      	movs	r0, #20
  14026a:	f240 1103 	movw	r1, #259	; 0x103
    writel(REMAP_DONE, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  14026e:	601a      	str	r2, [r3, #0]
    handle = hal_scr_create_handle(
  140270:	f2c0 4030 	movt	r0, #1072	; 0x430
  140274:	f00e fa4c 	bl	14e710 <hal_scr_create_handle>
  140278:	4606      	mov	r6, r0
  14027a:	460f      	mov	r7, r1
                        SCR_SEC__L31__remap_cr5_sec_ar_addr_offset_19_0);
    ASSERT(handle);
  14027c:	ea56 0307 	orrs.w	r3, r6, r7
  140280:	d06b      	beq.n	14035a <platform_cpu_reset+0x112>
    hal_scr_set(handle, img_base >> 12);
  140282:	0b2a      	lsrs	r2, r5, #12
  140284:	f00e fa76 	bl	14e774 <hal_scr_set>
    hal_scr_delete_handle(handle);
  140288:	4630      	mov	r0, r6
  14028a:	4639      	mov	r1, r7
  14028c:	f00e fa42 	bl	14e714 <hal_scr_delete_handle>
    handle = hal_scr_create_handle(
  140290:	a13b      	add	r1, pc, #236	; (adr r1, 140380 <platform_cpu_reset+0x138>)
  140292:	e9d1 0100 	ldrd	r0, r1, [r1]
  140296:	f00e fa3b 	bl	14e710 <hal_scr_create_handle>
  14029a:	4606      	mov	r6, r0
  14029c:	460f      	mov	r7, r1
                        SCR_SEC__L31__remap_cr5_sec_ar_remap_ovrd_en);
    ASSERT(handle);
  14029e:	ea56 0307 	orrs.w	r3, r6, r7
  1402a2:	d049      	beq.n	140338 <platform_cpu_reset+0xf0>
    hal_scr_set(handle, 1);
  1402a4:	2201      	movs	r2, #1
  1402a6:	f00e fa65 	bl	14e774 <hal_scr_set>
    hal_scr_delete_handle(handle);
  1402aa:	4630      	mov	r0, r6
  1402ac:	4639      	mov	r1, r7
  1402ae:	f00e fa31 	bl	14e714 <hal_scr_delete_handle>
    /* ROMC Stick Reg
     *
     * [0]: ROMC_STICKY_REMAP_EN. This bit is AND'ed with
     *      SCR remap_en bit, to enable remapping.
     */
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
  1402b2:	2334      	movs	r3, #52	; 0x34
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  1402b4:	f44f 6180 	mov.w	r1, #1024	; 0x400
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
  1402b8:	f2cf 036f 	movt	r3, #61551	; 0xf06f
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  1402bc:	a803      	add	r0, sp, #12
  1402be:	f2c8 1196 	movt	r1, #33174	; 0x8196
    RMWREG32(_ioaddr(ROMC_STICKY_REG), 0, 1, 1);
  1402c2:	681a      	ldr	r2, [r3, #0]
  1402c4:	f042 0201 	orr.w	r2, r2, #1
  1402c8:	601a      	str	r2, [r3, #0]
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  1402ca:	f00e f967 	bl	14e59c <hal_rstgen_creat_handle>
    ASSERT(ret);
  1402ce:	b310      	cbz	r0, 140316 <platform_cpu_reset+0xce>
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
  1402d0:	f44f 4350 	mov.w	r3, #53248	; 0xd000
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  1402d4:	f240 4104 	movw	r1, #1028	; 0x404
  1402d8:	9803      	ldr	r0, [sp, #12]
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
  1402da:	f6cf 032a 	movt	r3, #63530	; 0xf82a
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  1402de:	f2c8 1196 	movt	r1, #33174	; 0x8196
    writel(readl(LOCKSTEP_SCR_ADDR)|(0x3 << LOCKSTEP_SCR_BIT), LOCKSTEP_SCR_ADDR);
  1402e2:	681a      	ldr	r2, [r3, #0]
  1402e4:	f042 0203 	orr.w	r2, r2, #3
  1402e8:	601a      	str	r2, [r3, #0]
    hal_rstgen_core_reset(handle, RES_CORE_RST_SEC_CR5_SEC_SW);
  1402ea:	f00e f9d9 	bl	14e6a0 <hal_rstgen_core_reset>
        arch_idle();
  1402ee:	f000 ed34 	blx	140d58 <arch_idle>
  1402f2:	e7fc      	b.n	1402ee <platform_cpu_reset+0xa6>
    ASSERT((img_base & 0xFFF) == 0);
  1402f4:	f644 338c 	movw	r3, #19340	; 0x4b8c
  1402f8:	f644 323c 	movw	r2, #19260	; 0x4b3c
  1402fc:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140300:	f2c0 0315 	movt	r3, #21
  140304:	4670      	mov	r0, r14
  140306:	f2c0 0215 	movt	r2, #21
  14030a:	9300      	str	r3, [sp, #0]
  14030c:	f2c0 0115 	movt	r1, #21
  140310:	2353      	movs	r3, #83	; 0x53
  140312:	f012 fccf 	bl	152cb4 <_panic>
    ASSERT(ret);
  140316:	f644 33ac 	movw	r3, #19372	; 0x4bac
  14031a:	f644 323c 	movw	r2, #19260	; 0x4b3c
  14031e:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140322:	f2c0 0315 	movt	r3, #21
  140326:	4620      	mov	r0, r4
  140328:	f2c0 0215 	movt	r2, #21
  14032c:	9300      	str	r3, [sp, #0]
  14032e:	f2c0 0115 	movt	r1, #21
  140332:	2337      	movs	r3, #55	; 0x37
  140334:	f012 fcbe 	bl	152cb4 <_panic>
    ASSERT(handle);
  140338:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14033c:	f644 323c 	movw	r2, #19260	; 0x4b3c
  140340:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140344:	f2c0 0315 	movt	r3, #21
  140348:	4620      	mov	r0, r4
  14034a:	f2c0 0215 	movt	r2, #21
  14034e:	9300      	str	r3, [sp, #0]
  140350:	f2c0 0115 	movt	r1, #21
  140354:	2361      	movs	r3, #97	; 0x61
  140356:	f012 fcad 	bl	152cb4 <_panic>
    ASSERT(handle);
  14035a:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14035e:	f644 323c 	movw	r2, #19260	; 0x4b3c
  140362:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140366:	f2c0 0315 	movt	r3, #21
  14036a:	4620      	mov	r0, r4
  14036c:	f2c0 0215 	movt	r2, #21
  140370:	9300      	str	r3, [sp, #0]
  140372:	f2c0 0115 	movt	r1, #21
  140376:	235c      	movs	r3, #92	; 0x5c
  140378:	f012 fc9c 	bl	152cb4 <_panic>
  14037c:	f3af 8000 	nop.w
  140380:	04301401 	.word	0x04301401
  140384:	00000103 	.word	0x00000103

00140388 <platform_early_init>:
__WEAK void os_platform_early_init(void)
{
}

void platform_early_init(void)
{
  140388:	b570      	push	{r4, r5, r6, r14}
  14038a:	4676      	mov	r6, r14
  14038c:	b084      	sub	sp, #16
    uart_init_early();
  14038e:	f000 f955 	bl	14063c <uart_init_early>
    if (readl(_ioaddr(RSTGEN_REMAP_STATUS_REG)) != REMAP_DONE) {
  140392:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
  140396:	f644 5250 	movw	r2, #19792	; 0x4d50
  14039a:	f6cf 0341 	movt	r3, #63553	; 0xf841
  14039e:	f2c5 2245 	movt	r2, #21061	; 0x5245
  1403a2:	6819      	ldr	r1, [r3, #0]
  1403a4:	4291      	cmp	r1, r2
  1403a6:	d16a      	bne.n	14047e <platform_early_init+0xf6>
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1403a8:	2400      	movs	r4, #0
    vuart_init();
#endif

    platform_remap();
    /* Enable TCM internal access. */
    tcm_enable(R5_SEC_TCMA_BASE, R5_SEC_TCMB_BASE, true);
  1403aa:	f44f 0196 	mov.w	r1, #4915200	; 0x4b0000
  1403ae:	f44f 0098 	mov.w	r0, #4980736	; 0x4c0000
  1403b2:	2201      	movs	r2, #1
        writel(0, _ioaddr(RSTGEN_REMAP_STATUS_REG));
  1403b4:	601c      	str	r4, [r3, #0]
    tcm_enable(R5_SEC_TCMA_BASE, R5_SEC_TCMB_BASE, true);
  1403b6:	f001 fb59 	bl	141a6c <tcm_enable>
    /* Copy code and data into TCM. */
    platform_earlycopy();
  1403ba:	f007 faf9 	bl	1479b0 <platform_earlycopy>
    ret = hal_rstgen_creat_handle(&handle, RES_GLOBAL_RST_SEC_RST_EN);
  1403be:	f44f 6180 	mov.w	r1, #1024	; 0x400
  1403c2:	a803      	add	r0, sp, #12
  1403c4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  1403c8:	f00e f8e8 	bl	14e59c <hal_rstgen_creat_handle>
    ASSERT(ret);
  1403cc:	b3a8      	cbz	r0, 14043a <platform_early_init+0xb2>
    hal_rstgen_module_reset(handle, RES_MODULE_RST_SEC_GIC2);
  1403ce:	9803      	ldr	r0, [sp, #12]
  1403d0:	f240 4153 	movw	r1, #1107	; 0x453
  1403d4:	f2c8 1196 	movt	r1, #33174	; 0x8196
  1403d8:	f00e f97a 	bl	14e6d0 <hal_rstgen_module_reset>
    hal_rstgen_release_handle(handle);
  1403dc:	9803      	ldr	r0, [sp, #12]
  1403de:	f00e f953 	bl	14e688 <hal_rstgen_release_handle>
    /* Release GIC from reset and initialize GIC. Clocks of GIC
     * 1~3 are enabled by default.
     */
    gic_reset();
    arm_gic_init_early();
  1403e2:	f000 f9f9 	bl	1407d8 <arm_gic_init_early>
#if ARM_WITH_VFP
    arm_fpu_set_enable(true);
  1403e6:	2001      	movs	r0, #1
  1403e8:	f001 f9c2 	bl	141770 <arm_fpu_set_enable>
#endif
#if SDRV_TIMER
    timer_init_early();
  1403ec:	f000 fa32 	bl	140854 <timer_init_early>
    mpu_enable(false);
  1403f0:	4620      	mov	r0, r4
  1403f2:	f001 fafd 	bl	1419f0 <mpu_enable>
    region = init_shm_domain_area(region);
  1403f6:	4620      	mov	r0, r4
  1403f8:	f00c f804 	bl	14c404 <init_shm_domain_area>
    region = platform_mpu_r5_common(region);
  1403fc:	f010 f9f6 	bl	1507ec <platform_mpu_r5_common>
    mpu_add_region(region++, CE2_VCE1_BASE, 0x2000, MPU_REGION_NORMAL_NONCACHEABLE);   /*CE2_VCE1 8K*/
  140400:	2303      	movs	r3, #3
  140402:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  140406:	f44f 01a4 	mov.w	r1, #5373952	; 0x520000
    region = platform_mpu_r5_common(region);
  14040a:	4604      	mov	r4, r0
    mpu_add_region(region++, SAF_SEC_MEMBASE + SAF_SEC_MEMSIZE - 0x4000, 0x4000, MPU_REGION_NORMAL_NONCACHEABLE);  /*HSM share-mem with safety*/
  14040c:	1c85      	adds	r5, r0, #2
    mpu_add_region(region++, CE2_VCE1_BASE, 0x2000, MPU_REGION_NORMAL_NONCACHEABLE);   /*CE2_VCE1 8K*/
  14040e:	f001 fa6d 	bl	1418ec <mpu_add_region>
    mpu_add_region(region++, SAF_SEC_MEMBASE + SAF_SEC_MEMSIZE - 0x4000, 0x4000, MPU_REGION_NORMAL_NONCACHEABLE);  /*HSM share-mem with safety*/
  140412:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  140416:	1c60      	adds	r0, r4, #1
  140418:	2303      	movs	r3, #3
  14041a:	f2c3 51bf 	movt	r1, #13759	; 0x35bf
  14041e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  140422:	f001 fa63 	bl	1418ec <mpu_add_region>
    ASSERT(region <= 16);
  140426:	2d10      	cmp	r5, #16
  140428:	dc18      	bgt.n	14045c <platform_early_init+0xd4>
    if (region != 0) {
  14042a:	b115      	cbz	r5, 140432 <platform_early_init+0xaa>
        mpu_enable(true);
  14042c:	2001      	movs	r0, #1
  14042e:	f001 fadf 	bl	1419f0 <mpu_enable>
#else
#error "No timer defined for R5 platform"
#endif
    platform_mpu_init();
    os_platform_early_init();
  140432:	f001 ff09 	bl	142248 <os_platform_early_init>
}
  140436:	b004      	add	sp, #16
  140438:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT(ret);
  14043a:	f644 33ac 	movw	r3, #19372	; 0x4bac
  14043e:	f644 323c 	movw	r2, #19260	; 0x4b3c
  140442:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140446:	f2c0 0315 	movt	r3, #21
  14044a:	4630      	mov	r0, r6
  14044c:	f2c0 0215 	movt	r2, #21
  140450:	9300      	str	r3, [sp, #0]
  140452:	f2c0 0115 	movt	r1, #21
  140456:	2348      	movs	r3, #72	; 0x48
  140458:	f012 fc2c 	bl	152cb4 <_panic>
    ASSERT(region <= 16);
  14045c:	f644 33b0 	movw	r3, #19376	; 0x4bb0
  140460:	f644 323c 	movw	r2, #19260	; 0x4b3c
  140464:	f644 316c 	movw	r1, #19308	; 0x4b6c
  140468:	f2c0 0315 	movt	r3, #21
  14046c:	4630      	mov	r0, r6
  14046e:	f2c0 0215 	movt	r2, #21
  140472:	9300      	str	r3, [sp, #0]
  140474:	f2c0 0115 	movt	r1, #21
  140478:	2391      	movs	r3, #145	; 0x91
  14047a:	f012 fc1b 	bl	152cb4 <_panic>
        platform_cpu_reset(MEMBASE);
  14047e:	f44f 10a0 	mov.w	r0, #1310720	; 0x140000
  140482:	f7ff fee1 	bl	140248 <platform_cpu_reset>
  140486:	bf00      	nop

00140488 <platform_init>:

void platform_init(void)
{
  140488:	b508      	push	{r3, r14}
    uart_init();
  14048a:	f000 f8bd 	bl	140608 <uart_init>

#if ENABLE_SD_DMA
    hal_dma_init();
#endif
    sysd_start(SEM2);
  14048e:	2001      	movs	r0, #1
  140490:	f00c fe82 	bl	14d198 <sysd_start>
    dcf_init();
}
  140494:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    dcf_init();
  140498:	f00c b852 	b.w	14c540 <dcf_init>

0014049c <_dputc>:
#endif

#define RSTGEN_BOOT_REASON_REG (APB_RSTGEN_SEC_BASE + RSTGEN_GENERAL_REG(4))

void _dputc(char c)
{
  14049c:	b538      	push	{r3, r4, r5, r14}
  14049e:	4604      	mov	r4, r0
    int port = uart_get_current_port();
  1404a0:	f000 f91e 	bl	1406e0 <uart_get_current_port>
        vuart_putc(c);
    }

#endif

    if (c == '\n') {
  1404a4:	2c0a      	cmp	r4, #10
    int port = uart_get_current_port();
  1404a6:	4605      	mov	r5, r0
    if (c == '\n') {
  1404a8:	d005      	beq.n	1404b6 <_dputc+0x1a>
        uart_putc(port, '\r');
    }

    uart_putc(port, c);
  1404aa:	4621      	mov	r1, r4
  1404ac:	4628      	mov	r0, r5
}
  1404ae:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  1404b2:	f000 b8ed 	b.w	140690 <uart_putc>
        uart_putc(port, '\r');
  1404b6:	210d      	movs	r1, #13
  1404b8:	f000 f8ea 	bl	140690 <uart_putc>
    uart_putc(port, c);
  1404bc:	4621      	mov	r1, r4
  1404be:	4628      	mov	r0, r5
}
  1404c0:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    uart_putc(port, c);
  1404c4:	f000 b8e4 	b.w	140690 <uart_putc>

001404c8 <dgetc>:

int dgetc(char *c, bool wait)
{
  1404c8:	b538      	push	{r3, r4, r5, r14}
  1404ca:	460c      	mov	r4, r1
  1404cc:	4605      	mov	r5, r0
    int _c;
    int port = uart_get_current_port();
  1404ce:	f000 f907 	bl	1406e0 <uart_get_current_port>
        return -1;
    }

#else

    if ((_c = uart_getc(port, wait)) < 0) {
  1404d2:	4621      	mov	r1, r4
  1404d4:	f000 f8e6 	bl	1406a4 <uart_getc>
  1404d8:	2800      	cmp	r0, #0
        return -1;
  1404da:	bfb2      	itee	lt
  1404dc:	f04f 30ff 	movlt.w	r0, #4294967295	; 0xffffffff
    }

#endif
    *c = _c;
  1404e0:	7028      	strbge	r0, [r5, #0]
    return 0;
  1404e2:	2000      	movge	r0, #0
}
  1404e4:	bd38      	pop	{r3, r4, r5, r15}
  1404e6:	bf00      	nop

001404e8 <get_bootreason>:
    return;
}
platform_halt_reason get_bootreason(void)
{
    platform_halt_reason reason;
    uint32_t v = readl(_ioaddr(RSTGEN_BOOT_REASON_REG));
  1404e8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  1404ec:	f6cf 0341 	movt	r3, #63553	; 0xf841
  1404f0:	6818      	ldr	r0, [r3, #0]
    reason = v & 0xf;
    return reason;
}
  1404f2:	f000 000f 	and.w	r0, r0, #15
  1404f6:	4770      	bx	r14

001404f8 <config_wakeupsrc>:

void config_wakeupsrc(int wksrc, unsigned long data)
{
    RMWREG32(_ioaddr(RSTGEN_BOOT_REASON_REG), 4, 28,
  1404f8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  1404fc:	f64f 73f0 	movw	r3, #65520	; 0xfff0
  140500:	f6cf 0241 	movt	r2, #63553	; 0xf841
  140504:	f6c0 73ff 	movt	r3, #4095	; 0xfff
  140508:	ea03 1101 	and.w	r1, r3, r1, lsl #4
  14050c:	6813      	ldr	r3, [r2, #0]
  14050e:	f000 000f 	and.w	r0, r0, #15
  140512:	4301      	orrs	r1, r0
  140514:	f003 030f 	and.w	r3, r3, #15
  140518:	ea43 1101 	orr.w	r1, r3, r1, lsl #4
  14051c:	6011      	str	r1, [r2, #0]
             (wksrc & 0xf) | ((data & 0xffffff) << 4));
    return;
}
  14051e:	4770      	bx	r14

00140520 <get_wakeupsrc>:

void get_wakeupsrc(int *wksrc, unsigned long *data)
{
    uint32_t v = readl(_ioaddr(RSTGEN_BOOT_REASON_REG));
  140520:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  140524:	f6cf 0341 	movt	r3, #63553	; 0xf841
  140528:	681b      	ldr	r3, [r3, #0]

    if (wksrc) {
  14052a:	b110      	cbz	r0, 140532 <get_wakeupsrc+0x12>
        *wksrc = (v >> 4) & 0xf;
  14052c:	f3c3 1203 	ubfx	r2, r3, #4, #4
  140530:	6002      	str	r2, [r0, #0]
    }

    if (data) {
  140532:	b109      	cbz	r1, 140538 <get_wakeupsrc+0x18>
        *data = (v >> 8) & 0xffffff;
  140534:	0a1b      	lsrs	r3, r3, #8
  140536:	600b      	str	r3, [r1, #0]
    }

    return;
}
  140538:	4770      	bx	r14
  14053a:	bf00      	nop

0014053c <platform_halt>:

void platform_halt(platform_halt_action suggested_action,
                   platform_halt_reason reason)
{
  14053c:	b500      	push	{r14}
    void *watchdog_handle = NULL;
  14053e:	2300      	movs	r3, #0
{
  140540:	b089      	sub	sp, #36	; 0x24
    void *watchdog_handle = NULL;
  140542:	9301      	str	r3, [sp, #4]
    bool ret;
    wdg_app_config_t wdg_app_cfg;

    switch (suggested_action) {
  140544:	b380      	cbz	r0, 1405a8 <platform_halt+0x6c>
  140546:	2802      	cmp	r0, #2
  140548:	d901      	bls.n	14054e <platform_halt+0x12>
    __asm__ volatile("cpsie i");
}

static inline void arch_disable_ints(void)
{
    __asm__ volatile("cpsid i");
  14054a:	b672      	cpsid	i
    CF;
  14054c:	e7fe      	b.n	14054c <platform_halt+0x10>
  14054e:	460c      	mov	r4, r1

            break;

        case HALT_ACTION_REBOOT:
        case HALT_ACTION_SHUTDOWN:
            hal_wdg_creat_handle(&watchdog_handle, RES_WATCHDOG_WDT3);
  140550:	f243 0120 	movw	r1, #12320	; 0x3020
  140554:	a801      	add	r0, sp, #4
  140556:	f2c4 213a 	movt	r1, #16954	; 0x423a
  14055a:	f00e fb69 	bl	14ec30 <hal_wdg_creat_handle>

            if (watchdog_handle) {
  14055e:	9801      	ldr	r0, [sp, #4]
  140560:	b320      	cbz	r0, 1405ac <platform_halt+0x70>
                wdg_app_cfg.workMode = wdg_mode1;
  140562:	2301      	movs	r3, #1
  140564:	a908      	add	r1, sp, #32
  140566:	f841 3d18 	str.w	r3, [r1, #-24]!
                ret = hal_wdg_init(watchdog_handle, &wdg_app_cfg);
  14056a:	f00e fbd1 	bl	14ed10 <hal_wdg_init>

                if (ret) {
  14056e:	2800      	cmp	r0, #0
  140570:	d0eb      	beq.n	14054a <platform_halt+0xe>
                    hal_wdg_set_timeout(watchdog_handle, 100);
  140572:	2164      	movs	r1, #100	; 0x64
    return readl(_ioaddr(SDRV_GENERAL_REG(reg)));
}

static inline void sdrv_common_reg_set_u32(uint32_t value, uint32_t reg)
{
    writel(value, _ioaddr(SDRV_GENERAL_REG(reg)));
  140574:	2506      	movs	r5, #6
  140576:	9801      	ldr	r0, [sp, #4]
  140578:	f00e fc38 	bl	14edec <hal_wdg_set_timeout>
                    hal_wdg_enable_interrupts(watchdog_handle);
  14057c:	9801      	ldr	r0, [sp, #4]
  14057e:	f00e fc29 	bl	14edd4 <hal_wdg_enable_interrupts>
    RMWREG32(_ioaddr(RSTGEN_BOOT_REASON_REG), 0, 4, reason);
  140582:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  140586:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  14058a:	f6cf 0241 	movt	r2, #63553	; 0xf841
                    /* set boot reason */
                    config_bootreason(reason);
                    /* clean up system status notice reg */
                    sdrv_common_reg_set_u32(SDRV_REG_STATUS, 0);
                    hal_wdg_enable(watchdog_handle);
  14058e:	9801      	ldr	r0, [sp, #4]
  140590:	f6cf 0141 	movt	r1, #63553	; 0xf841
    RMWREG32(_ioaddr(RSTGEN_BOOT_REASON_REG), 0, 4, reason);
  140594:	6813      	ldr	r3, [r2, #0]
  140596:	f023 030f 	bic.w	r3, r3, #15
  14059a:	4323      	orrs	r3, r4
  14059c:	6013      	str	r3, [r2, #0]
  14059e:	600d      	str	r5, [r1, #0]
                    hal_wdg_enable(watchdog_handle);
  1405a0:	f00e fc00 	bl	14eda4 <hal_wdg_enable>
    __asm__ volatile("cpsid i");
  1405a4:	b672      	cpsid	i
    CF;
  1405a6:	e7fe      	b.n	1405a6 <platform_halt+0x6a>
    __asm__ volatile("cpsid i");
  1405a8:	b672      	cpsid	i
    CF;
  1405aa:	e7fe      	b.n	1405aa <platform_halt+0x6e>

                    for (;;);
                }
            }
            else {
                hal_wdg_deinit(watchdog_handle);
  1405ac:	f00e fbce 	bl	14ed4c <hal_wdg_deinit>
                hal_wdg_release_handle(watchdog_handle);
  1405b0:	9801      	ldr	r0, [sp, #4]
  1405b2:	f00e fba5 	bl	14ed00 <hal_wdg_release_handle>
                printf("reboot/power off failed\n");
  1405b6:	f644 30c0 	movw	r0, #19392	; 0x4bc0
  1405ba:	f2c0 0015 	movt	r0, #21
  1405be:	f013 fd9b 	bl	1540f8 <_printf>
  1405c2:	e7c2      	b.n	14054a <platform_halt+0xe>

001405c4 <platform_dputc>:
    PANIC_UNIMPLEMENTED;
}

void platform_dputc(char c)
{
    _dputc(c);
  1405c4:	f7ff bf6a 	b.w	14049c <_dputc>

001405c8 <platform_dgetc>:
}

int platform_dgetc(char *c, bool wait)
{
    return dgetc(c, wait);
  1405c8:	f7ff bf7e 	b.w	1404c8 <dgetc>

001405cc <save_char>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
static int save_char(uint8_t data)
{
  1405cc:	b538      	push	{r3, r4, r5, r14}
  1405ce:	4605      	mov	r5, r0
#if CONSOLE_HAS_INPUT_BUFFER
    cbuf_write_char(&console_input_cbuf, c, false);
#else

    if (cbuf_space_avail(&uart_rx_buf) == 0) {  //uart_rx_buf no space
  1405d0:	f241 1004 	movw	r0, #4356	; 0x1104
  1405d4:	f2c0 0016 	movt	r0, #22
  1405d8:	f011 fe58 	bl	15228c <cbuf_space_avail>
  1405dc:	b148      	cbz	r0, 1405f2 <save_char+0x26>
        hal_uart_int_src_disable(uart_handle,
                                 UART_HAL_RX_CHAR_INT_SRC); //disable the receive data interrupt
        return 0;
    }

    cbuf_write_char(&uart_rx_buf, data, false);
  1405de:	f241 1004 	movw	r0, #4356	; 0x1104
  1405e2:	4629      	mov	r1, r5
  1405e4:	2200      	movs	r2, #0
  1405e6:	f2c0 0016 	movt	r0, #22
  1405ea:	f011 fefb 	bl	1523e4 <cbuf_write_char>
    //dprintf(PLATFORM_UART_DEBUG_LEVEL, "%c", data);
#endif
    return 1;
  1405ee:	2001      	movs	r0, #1
}
  1405f0:	bd38      	pop	{r3, r4, r5, r15}
        hal_uart_int_src_disable(uart_handle,
  1405f2:	f241 1300 	movw	r3, #4352	; 0x1100
  1405f6:	4604      	mov	r4, r0
  1405f8:	4601      	mov	r1, r0
  1405fa:	f2c0 0316 	movt	r3, #22
  1405fe:	6818      	ldr	r0, [r3, #0]
  140600:	f00e fb12 	bl	14ec28 <hal_uart_int_src_disable>
  140604:	4620      	mov	r0, r4
}
  140606:	bd38      	pop	{r3, r4, r5, r15}

00140608 <uart_init>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init(void)
{
  140608:	b510      	push	{r4, r14}
    val &= ~1ul;
    writel(val, addr);
    /************ above will be change with the iomux hal ************/
#endif

    if (uart_handle != NULL) {
  14060a:	f241 1400 	movw	r4, #4352	; 0x1100
  14060e:	f2c0 0416 	movt	r4, #22
  140612:	6823      	ldr	r3, [r4, #0]
  140614:	b183      	cbz	r3, 140638 <uart_init+0x30>
        // create circular buffer to hold received data
        cbuf_initialize(&uart_rx_buf, RXBUF_SIZE);
  140616:	f241 1004 	movw	r0, #4356	; 0x1104
  14061a:	2110      	movs	r1, #16
  14061c:	f2c0 0016 	movt	r0, #22
  140620:	f011 fe1a 	bl	152258 <cbuf_initialize>
        hal_uart_int_cbk_register(uart_handle, UART_HAL_RX_CHAR_INT_SRC,
  140624:	f240 52cd 	movw	r2, #1485	; 0x5cd
  140628:	6820      	ldr	r0, [r4, #0]
  14062a:	f2c0 0214 	movt	r2, #20
  14062e:	2100      	movs	r1, #0
                                  save_char);
        dprintf(PLATFORM_UART_DEBUG_LEVEL, "Platform UART inited!\r\n");
    }
}
  140630:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        hal_uart_int_cbk_register(uart_handle, UART_HAL_RX_CHAR_INT_SRC,
  140634:	f00e badc 	b.w	14ebf0 <hal_uart_int_cbk_register>
}
  140638:	bd10      	pop	{r4, r15}
  14063a:	bf00      	nop

0014063c <uart_init_early>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
void uart_init_early(void)
{
  14063c:	b530      	push	{r4, r5, r14}
    val = readl(addr);
    val &= ~1ul;
    writel(val, addr);
    /************ above will be change with the iomux hal ************/
#endif
    hal_uart_creat_handle(&uart_handle, DEBUG_COM);
  14063e:	f241 1400 	movw	r4, #4352	; 0x1100
  140642:	f24a 010d 	movw	r1, #40973	; 0xa00d
  140646:	f2c0 0416 	movt	r4, #22
  14064a:	4620      	mov	r0, r4
{
  14064c:	b08b      	sub	sp, #44	; 0x2c
    hal_uart_creat_handle(&uart_handle, DEBUG_COM);
  14064e:	f2c4 1142 	movt	r1, #16706	; 0x4142
  140652:	f00e fa19 	bl	14ea88 <hal_uart_creat_handle>

    if (uart_handle != NULL) {
  140656:	6820      	ldr	r0, [r4, #0]
  140658:	b1b8      	cbz	r0, 14068a <uart_init_early+0x4e>
        instance = (uart_instance_t *)uart_handle;
        hal_cfg.port_cfg.sclk = UART_SCLK;
  14065a:	f44f 4207 	mov.w	r2, #34560	; 0x8700
        hal_cfg.port_cfg.baud = UART_BAUD;
  14065e:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  140662:	2300      	movs	r3, #0
        hal_cfg.port_cfg.sclk = UART_SCLK;
  140664:	f2c0 3293 	movt	r2, #915	; 0x393
        hal_cfg.port_cfg.data_bits = UART_HAL_CHAR_8BITS;
  140668:	2503      	movs	r5, #3
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  14066a:	2402      	movs	r4, #2
        hal_cfg.port_cfg.sclk = UART_SCLK;
  14066c:	9201      	str	r2, [sp, #4]
        hal_cfg.port_cfg.loopback_enable = false;
        hal_cfg.fifo_cfg.fifo_enable = true;
  14066e:	2201      	movs	r2, #1
        hal_cfg.port_cfg.baud = UART_BAUD;
  140670:	9102      	str	r1, [sp, #8]
        hal_cfg.nine_bits_cfg.nine_bits_enable = false;
#endif
#ifdef UART_DRV_SUPPORT_DMA
        hal_cfg.dma_cfg.dma_enable = false;
#endif
        hal_uart_init(uart_handle, &hal_cfg);
  140672:	a901      	add	r1, sp, #4
        hal_cfg.port_cfg.stop_bits = UART_HAL_STOP_1BIT;
  140674:	e9cd 5303 	strd	r5, r3, [r13, #12]
        hal_cfg.port_cfg.loopback_enable = false;
  140678:	f88d 3018 	strb.w	r3, [r13, #24]
        hal_cfg.fifo_cfg.tx_trigger = UART_HAL_TX_FIFO_EMPTY;
  14067c:	e9cd 3308 	strd	r3, r3, [r13, #32]
        hal_cfg.port_cfg.parity = UART_HAL_NO_PARITY;
  140680:	9405      	str	r4, [sp, #20]
        hal_cfg.fifo_cfg.fifo_enable = true;
  140682:	f88d 201c 	strb.w	r2, [r13, #28]
        hal_uart_init(uart_handle, &hal_cfg);
  140686:	f00e fa89 	bl	14eb9c <hal_uart_init>
        uart_platform_cfg_printf(instance, &hal_cfg);
    }
}
  14068a:	b00b      	add	sp, #44	; 0x2c
  14068c:	bd30      	pop	{r4, r5, r15}
  14068e:	bf00      	nop

00140690 <uart_putc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_putc(int port, char data)
{
  140690:	b508      	push	{r3, r14}
    hal_uart_putc(uart_handle, data);
  140692:	f241 1300 	movw	r3, #4352	; 0x1100
  140696:	f2c0 0316 	movt	r3, #22
  14069a:	6818      	ldr	r0, [r3, #0]
  14069c:	f00e faa0 	bl	14ebe0 <hal_uart_putc>
    return 1;
}
  1406a0:	2001      	movs	r0, #1
  1406a2:	bd08      	pop	{r3, r15}

001406a4 <uart_getc>:
 **
 ** \param [in]
 ** \param [out]
 *****************************************************************************/
int uart_getc(int port, bool wait)
{
  1406a4:	b510      	push	{r4, r14}
    cbuf_t *rxbuf = &uart_rx_buf;
    char c;

    if (!uart_handle)
  1406a6:	f241 1400 	movw	r4, #4352	; 0x1100
{
  1406aa:	b082      	sub	sp, #8
    if (!uart_handle)
  1406ac:	f2c0 0416 	movt	r4, #22
  1406b0:	6823      	ldr	r3, [r4, #0]
  1406b2:	b193      	cbz	r3, 1406da <uart_getc+0x36>
        return -1;

    if (cbuf_read_char(rxbuf, &c, wait) == 1) {
  1406b4:	f241 1004 	movw	r0, #4356	; 0x1104
  1406b8:	460a      	mov	r2, r1
  1406ba:	f2c0 0016 	movt	r0, #22
  1406be:	f10d 0107 	add.w	r1, r13, #7
  1406c2:	f011 fec7 	bl	152454 <cbuf_read_char>
  1406c6:	2801      	cmp	r0, #1
  1406c8:	d107      	bne.n	1406da <uart_getc+0x36>
        hal_uart_int_src_enable(uart_handle, UART_HAL_RX_CHAR_INT_SRC);
  1406ca:	6820      	ldr	r0, [r4, #0]
  1406cc:	2100      	movs	r1, #0
  1406ce:	f00e faa7 	bl	14ec20 <hal_uart_int_src_enable>
        return c;
  1406d2:	f89d 0007 	ldrb.w	r0, [r13, #7]
    }

    return -1;
}
  1406d6:	b002      	add	sp, #8
  1406d8:	bd10      	pop	{r4, r15}
        return -1;
  1406da:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1406de:	e7fa      	b.n	1406d6 <uart_getc+0x32>

001406e0 <uart_get_current_port>:
}

int uart_get_current_port(void)
{
    return 0;
}
  1406e0:	2000      	movs	r0, #0
  1406e2:	4770      	bx	r14

001406e4 <register_int_handler>:
#include <arm_gic_hal.h>

#define INTERRUPT_DEBUG_LEVEL ALWAYS

void register_int_handler(unsigned int vector, int_handler handler, void *arg)
{
  1406e4:	b570      	push	{r4, r5, r6, r14}
    void* gic_handle = NULL;
  1406e6:	2400      	movs	r4, #0
{
  1406e8:	b084      	sub	sp, #16
  1406ea:	460e      	mov	r6, r1
    void* gic_handle = NULL;
  1406ec:	ab04      	add	r3, sp, #16
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1406ee:	f44f 5180 	mov.w	r1, #4096	; 0x1000
{
  1406f2:	4605      	mov	r5, r0
    void* gic_handle = NULL;
  1406f4:	f843 4d04 	str.w	r4, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1406f8:	f6c0 610a 	movt	r1, #3594	; 0xe0a
  1406fc:	4618      	mov	r0, r3
{
  1406fe:	4614      	mov	r4, r2
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  140700:	f00d f9d2 	bl	14daa8 <hal_arm_gic_create_handle>
  140704:	b158      	cbz	r0, 14071e <register_int_handler+0x3a>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_register_interrupt(gic_handle, vector, GIC_INTERRUPT_PRI_LOWEST, handler, arg);
  140706:	4633      	mov	r3, r6
  140708:	4629      	mov	r1, r5
  14070a:	9803      	ldr	r0, [sp, #12]
  14070c:	221e      	movs	r2, #30
  14070e:	9400      	str	r4, [sp, #0]
  140710:	f00d f9fe 	bl	14db10 <hal_arm_gic_register_interrupt>
        hal_arm_gic_release_handle(gic_handle);
  140714:	9803      	ldr	r0, [sp, #12]
  140716:	f00d f9c9 	bl	14daac <hal_arm_gic_release_handle>
    }

    return;
}
  14071a:	b004      	add	sp, #16
  14071c:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
  14071e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  140722:	f644 30dc 	movw	r0, #19420	; 0x4bdc
  140726:	f6c0 610a 	movt	r1, #3594	; 0xe0a
  14072a:	f2c0 0015 	movt	r0, #21
  14072e:	f013 fce3 	bl	1540f8 <_printf>
}
  140732:	b004      	add	sp, #16
  140734:	bd70      	pop	{r4, r5, r6, r15}
  140736:	bf00      	nop

00140738 <mask_interrupt>:

status_t mask_interrupt(unsigned int vector)
{
  140738:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
  14073a:	2200      	movs	r2, #0
{
  14073c:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  14073e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  140742:	ab02      	add	r3, sp, #8
{
  140744:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  140746:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
  14074a:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  14074e:	4618      	mov	r0, r3
  140750:	f00d f9aa 	bl	14daa8 <hal_arm_gic_create_handle>
  140754:	b150      	cbz	r0, 14076c <mask_interrupt+0x34>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_disable_interrupt(gic_handle, vector);
  140756:	9801      	ldr	r0, [sp, #4]
  140758:	4621      	mov	r1, r4
  14075a:	f00d f9d1 	bl	14db00 <hal_arm_gic_disable_interrupt>
  14075e:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
  140760:	9801      	ldr	r0, [sp, #4]
  140762:	f00d f9a3 	bl	14daac <hal_arm_gic_release_handle>
    }

    return ret;
}
  140766:	4620      	mov	r0, r4
  140768:	b002      	add	sp, #8
  14076a:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
  14076c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  140770:	f644 30dc 	movw	r0, #19420	; 0x4bdc
  140774:	f6c0 610a 	movt	r1, #3594	; 0xe0a
        ret = -1;
  140778:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_DEBUG_LEVEL,
  14077c:	f2c0 0015 	movt	r0, #21
  140780:	f013 fcba 	bl	1540f8 <_printf>
  140784:	e7ef      	b.n	140766 <mask_interrupt+0x2e>
  140786:	bf00      	nop

00140788 <unmask_interrupt>:
status_t unmask_interrupt(unsigned int vector)
{
  140788:	b510      	push	{r4, r14}
    void* gic_handle = NULL;
  14078a:	2200      	movs	r2, #0
{
  14078c:	b082      	sub	sp, #8
    status_t ret = -1;
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  14078e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  140792:	ab02      	add	r3, sp, #8
{
  140794:	4604      	mov	r4, r0
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  140796:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
  14079a:	f843 2d04 	str.w	r2, [r3, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  14079e:	4618      	mov	r0, r3
  1407a0:	f00d f982 	bl	14daa8 <hal_arm_gic_create_handle>
  1407a4:	b150      	cbz	r0, 1407bc <unmask_interrupt+0x34>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        ret = hal_arm_gic_enable_interrupt(gic_handle, vector);
  1407a6:	9801      	ldr	r0, [sp, #4]
  1407a8:	4621      	mov	r1, r4
  1407aa:	f00d f9a1 	bl	14daf0 <hal_arm_gic_enable_interrupt>
  1407ae:	4604      	mov	r4, r0
        hal_arm_gic_release_handle(gic_handle);
  1407b0:	9801      	ldr	r0, [sp, #4]
  1407b2:	f00d f97b 	bl	14daac <hal_arm_gic_release_handle>
    }

    return ret;
}
  1407b6:	4620      	mov	r0, r4
  1407b8:	b002      	add	sp, #8
  1407ba:	bd10      	pop	{r4, r15}
        dprintf(INTERRUPT_DEBUG_LEVEL,
  1407bc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  1407c0:	f644 30dc 	movw	r0, #19420	; 0x4bdc
  1407c4:	f6c0 610a 	movt	r1, #3594	; 0xe0a
        ret = -1;
  1407c8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(INTERRUPT_DEBUG_LEVEL,
  1407cc:	f2c0 0015 	movt	r0, #21
  1407d0:	f013 fc92 	bl	1540f8 <_printf>
  1407d4:	e7ef      	b.n	1407b6 <unmask_interrupt+0x2e>
  1407d6:	bf00      	nop

001407d8 <arm_gic_init_early>:

void arm_gic_init_early(void)
{
  1407d8:	b500      	push	{r14}
    void* gic_handle = NULL;
  1407da:	2300      	movs	r3, #0
{
  1407dc:	b083      	sub	sp, #12

    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1407de:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    void* gic_handle = NULL;
  1407e2:	a802      	add	r0, sp, #8
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1407e4:	f6c0 610a 	movt	r1, #3594	; 0xe0a
    void* gic_handle = NULL;
  1407e8:	f840 3d04 	str.w	r3, [r0, #-4]!
    if(false == hal_arm_gic_create_handle(&gic_handle,GIC_RES_ID) )
  1407ec:	f00d f95c 	bl	14daa8 <hal_arm_gic_create_handle>
  1407f0:	b140      	cbz	r0, 140804 <arm_gic_init_early+0x2c>
        dprintf(INTERRUPT_DEBUG_LEVEL,
                "Create GIC handle fail. RES id:0x%x\n",GIC_RES_ID);
    }
    else
    {
        hal_arm_gic_init(gic_handle);
  1407f2:	9801      	ldr	r0, [sp, #4]
  1407f4:	f00d f95c 	bl	14dab0 <hal_arm_gic_init>
        hal_arm_gic_release_handle(gic_handle);
  1407f8:	9801      	ldr	r0, [sp, #4]
  1407fa:	f00d f957 	bl	14daac <hal_arm_gic_release_handle>
    }

    return;
}
  1407fe:	b003      	add	sp, #12
  140800:	f85d fb04 	ldr.w	r15, [r13], #4
        dprintf(INTERRUPT_DEBUG_LEVEL,
  140804:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  140808:	f644 30dc 	movw	r0, #19420	; 0x4bdc
  14080c:	f6c0 610a 	movt	r1, #3594	; 0xe0a
  140810:	f2c0 0015 	movt	r0, #21
  140814:	f013 fc70 	bl	1540f8 <_printf>
}
  140818:	b003      	add	sp, #12
  14081a:	f85d fb04 	ldr.w	r15, [r13], #4
  14081e:	bf00      	nop

00140820 <platform_tick>:
    return (lk_bigtime_t)us;
}

lk_time_t current_time(void)
{
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  140820:	f241 1240 	movw	r2, #4416	; 0x1140
}

static enum handler_return platform_tick(void)
{
    //dprintf(TIMER_DEBUG_LEVEL, "Timer tick!\n");
    return timer_context.callback(timer_context.arg, current_time());
  140824:	f241 1334 	movw	r3, #4404	; 0x1134
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  140828:	f2c0 0216 	movt	r2, #22
{
  14082c:	b570      	push	{r4, r5, r6, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  14082e:	6814      	ldr	r4, [r2, #0]
    return timer_context.callback(timer_context.arg, current_time());
  140830:	f2c0 0316 	movt	r3, #22
    return hal_timer_glb_cntr_get(timer_handle);
  140834:	4620      	mov	r0, r4
    return timer_context.callback(timer_context.arg, current_time());
  140836:	e9d3 6501 	ldrd	r6, r5, [r3, #4]
    return hal_timer_glb_cntr_get(timer_handle);
  14083a:	f00e f8f5 	bl	14ea28 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
  14083e:	68e2      	ldr	r2, [r4, #12]
  140840:	2300      	movs	r3, #0
  140842:	f014 f877 	bl	154934 <__aeabi_uldivmod>
    return timer_context.callback(timer_context.arg, current_time());
  140846:	462b      	mov	r3, r5
  140848:	4601      	mov	r1, r0
  14084a:	4630      	mov	r0, r6
}
  14084c:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    return timer_context.callback(timer_context.arg, current_time());
  140850:	4718      	bx	r3
  140852:	bf00      	nop

00140854 <timer_init_early>:
{
  140854:	b5f0      	push	{r4, r5, r6, r7, r14}
    hal_timer_creat_handle(&timer_handle, SYS_TIMER);
  140856:	f241 1440 	movw	r4, #4416	; 0x1140
  14085a:	f243 010b 	movw	r1, #12299	; 0x300b
  14085e:	f2c0 0416 	movt	r4, #22
  140862:	4620      	mov	r0, r4
{
  140864:	b089      	sub	sp, #36	; 0x24
    hal_timer_creat_handle(&timer_handle, SYS_TIMER);
  140866:	f2c4 213e 	movt	r1, #16958	; 0x423e
  14086a:	f00d ffab 	bl	14e7c4 <hal_timer_creat_handle>
    if (timer_handle != NULL) {
  14086e:	6820      	ldr	r0, [r4, #0]
  140870:	b320      	cbz	r0, 1408bc <timer_init_early+0x68>
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
  140872:	f44f 5258 	mov.w	r2, #13824	; 0x3600
        glb_cfg.cascade = true;
  140876:	2501      	movs	r5, #1
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  140878:	2302      	movs	r3, #2
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
  14087a:	f2c0 126e 	movt	r2, #366	; 0x16e
        ovf_cfg.periodic = true;
  14087e:	ae08      	add	r6, sp, #32
        glb_cfg.clk_frq = SYS_TIMER_LF_CLK_FREQ;
  140880:	9205      	str	r2, [sp, #20]
        hal_timer_global_init(timer_handle, &glb_cfg);
  140882:	a904      	add	r1, sp, #16
        glb_cfg.clk_sel = HAL_TIMER_SEL_LF_CLK;
  140884:	9304      	str	r3, [sp, #16]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  140886:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        glb_cfg.clk_div = 2;
  14088a:	9306      	str	r3, [sp, #24]
        glb_cfg.cascade = true;
  14088c:	f88d 501c 	strb.w	r5, [r13, #28]
        hal_timer_global_init(timer_handle, &glb_cfg);
  140890:	f00e f826 	bl	14e8e0 <hal_timer_global_init>
        ovf_cfg.periodic = true;
  140894:	f806 5d1c 	strb.w	r5, [r6, #-28]!
        ovf_cfg.cnt_val = 0;
  140898:	2300      	movs	r3, #0
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G0, &ovf_cfg);
  14089a:	4619      	mov	r1, r3
  14089c:	4632      	mov	r2, r6
  14089e:	6820      	ldr	r0, [r4, #0]
        ovf_cfg.cnt_val = 0;
  1408a0:	9302      	str	r3, [sp, #8]
        ovf_cfg.ovf_val = 0xFFFFFFFF;
  1408a2:	9703      	str	r7, [sp, #12]
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G0, &ovf_cfg);
  1408a4:	f00e f840 	bl	14e928 <hal_timer_ovf_init>
        hal_timer_ovf_init(timer_handle, HAL_TIMER_G1, &ovf_cfg);
  1408a8:	4632      	mov	r2, r6
  1408aa:	4629      	mov	r1, r5
  1408ac:	6820      	ldr	r0, [r4, #0]
  1408ae:	f00e f83b 	bl	14e928 <hal_timer_ovf_init>
        timer_context.inited = true;
  1408b2:	f241 1334 	movw	r3, #4404	; 0x1134
  1408b6:	f2c0 0316 	movt	r3, #22
  1408ba:	701d      	strb	r5, [r3, #0]
}
  1408bc:	b009      	add	sp, #36	; 0x24
  1408be:	bdf0      	pop	{r4, r5, r6, r7, r15}

001408c0 <platform_set_oneshot_timer>:
{
  1408c0:	b5f0      	push	{r4, r5, r6, r7, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  1408c2:	f241 1440 	movw	r4, #4416	; 0x1140
{
  1408c6:	b085      	sub	sp, #20
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  1408c8:	f2c0 0416 	movt	r4, #22
  1408cc:	6825      	ldr	r5, [r4, #0]
    if ((!timer_handle) || (!timer_context.inited)) {
  1408ce:	b335      	cbz	r5, 14091e <platform_set_oneshot_timer+0x5e>
  1408d0:	f241 1334 	movw	r3, #4404	; 0x1134
  1408d4:	f2c0 0316 	movt	r3, #22
  1408d8:	781e      	ldrb	r6, [r3, #0]
  1408da:	b306      	cbz	r6, 14091e <platform_set_oneshot_timer+0x5e>
    ovf_cfg.ovf_val = interval * instance->cnt_per_ms;
  1408dc:	f8d5 c00c 	ldr.w	r12, [r5, #12]
  1408e0:	4616      	mov	r6, r2
  1408e2:	4607      	mov	r7, r0
    ovf_cfg.periodic = isperiodic;
  1408e4:	aa04      	add	r2, sp, #16
    timer_context.arg = arg;
  1408e6:	6059      	str	r1, [r3, #4]
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1408e8:	4628      	mov	r0, r5
    ovf_cfg.ovf_val = interval * instance->cnt_per_ms;
  1408ea:	fb06 f60c 	mul.w	r6, r6, r12
    ovf_cfg.cnt_val = 0;
  1408ee:	2500      	movs	r5, #0
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1408f0:	2102      	movs	r1, #2
    timer_context.callback = callback;
  1408f2:	609f      	str	r7, [r3, #8]
    ovf_cfg.periodic = isperiodic;
  1408f4:	f802 5d0c 	strb.w	r5, [r2, #-12]!
    ovf_cfg.cnt_val = 0;
  1408f8:	e9cd 5602 	strd	r5, r6, [r13, #8]
    hal_timer_ovf_init(timer_handle, HAL_TIMER_LOCAL_A, &ovf_cfg);
  1408fc:	f00e f814 	bl	14e928 <hal_timer_ovf_init>
    hal_timer_int_cbk_register(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC,
  140900:	f640 0221 	movw	r2, #2081	; 0x821
  140904:	210a      	movs	r1, #10
  140906:	6820      	ldr	r0, [r4, #0]
  140908:	f2c0 0214 	movt	r2, #20
  14090c:	f00e f83a 	bl	14e984 <hal_timer_int_cbk_register>
    hal_timer_int_src_enable(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  140910:	6820      	ldr	r0, [r4, #0]
  140912:	210a      	movs	r1, #10
  140914:	f00e f81a 	bl	14e94c <hal_timer_int_src_enable>
    return NO_ERROR;
  140918:	4628      	mov	r0, r5
}
  14091a:	b005      	add	sp, #20
  14091c:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return ERR_NOT_VALID;
  14091e:	f06f 0006 	mvn.w	r0, #6
    return platform_timer_set(timer_handle, callback, arg, interval, false);
  140922:	e7fa      	b.n	14091a <platform_set_oneshot_timer+0x5a>

00140924 <platform_stop_timer>:
{
  140924:	b510      	push	{r4, r14}
    hal_timer_int_src_disable(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  140926:	f241 1440 	movw	r4, #4416	; 0x1140
  14092a:	210a      	movs	r1, #10
  14092c:	f2c0 0416 	movt	r4, #22
  140930:	6820      	ldr	r0, [r4, #0]
  140932:	f00e f819 	bl	14e968 <hal_timer_int_src_disable>
    hal_timer_int_sta_clear(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  140936:	6820      	ldr	r0, [r4, #0]
  140938:	210a      	movs	r1, #10
}
  14093a:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    hal_timer_int_sta_clear(timer_handle, HAL_TIMER_CNT_LA_OVF_INT_SRC);
  14093e:	f00e b86d 	b.w	14ea1c <hal_timer_int_sta_clear>
  140942:	bf00      	nop

00140944 <current_time_hires>:
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  140944:	f241 1340 	movw	r3, #4416	; 0x1140
  140948:	f2c0 0316 	movt	r3, #22
{
  14094c:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  14094e:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(timer_handle);
  140950:	4620      	mov	r0, r4
  140952:	f00e f869 	bl	14ea28 <hal_timer_glb_cntr_get>
    lk_bigtime_t us = timer_current_stamp() / instance->cnt_per_us;
  140956:	2300      	movs	r3, #0
  140958:	6922      	ldr	r2, [r4, #16]
  14095a:	f013 ffeb 	bl	154934 <__aeabi_uldivmod>
}
  14095e:	bd10      	pop	{r4, r15}

00140960 <current_time>:
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  140960:	f241 1340 	movw	r3, #4416	; 0x1140
  140964:	f2c0 0316 	movt	r3, #22
{
  140968:	b510      	push	{r4, r14}
    timer_instance_t *instance = (timer_instance_t *)timer_handle;
  14096a:	681c      	ldr	r4, [r3, #0]
    return hal_timer_glb_cntr_get(timer_handle);
  14096c:	4620      	mov	r0, r4
  14096e:	f00e f85b 	bl	14ea28 <hal_timer_glb_cntr_get>
    lk_time_t ms = timer_current_stamp() / instance->cnt_per_ms;
  140972:	2300      	movs	r3, #0
  140974:	68e2      	ldr	r2, [r4, #12]
  140976:	f013 ffdd 	bl	154934 <__aeabi_uldivmod>
}
  14097a:	bd10      	pop	{r4, r15}

0014097c <dcf_get_this_proc>:
#endif

int dcf_get_this_proc(void)
{
    return DP_CR5_SEC;
}
  14097c:	2001      	movs	r0, #1
  14097e:	4770      	bx	r14

00140980 <arm_context_switch>:
     */
/* arm_context_switch(addr_t *old_sp, addr_t new_sp) */
FUNCTION(arm_context_switch)
    /* save non callee trashed supervisor registers */
    /* spsr and user mode registers are saved and restored in the iframe by exceptions.S */
    push    { r4-r11, lr }
  140980:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    /* save old sp */
    str     sp, [r0]
  140984:	e580d000 	str	r13, [r0]

    /* clear any exlusive locks that the old thread holds */
#if ARM_ARCH_LEVEL >= 7
    /* can clear it directly */
    clrex
  140988:	f57ff01f 	clrex
    ldr     r0, =strex_spot
    strex   r3, r2, [r0]
#endif

    /* load new regs */
    mov     sp, r1
  14098c:	e1a0d001 	mov	r13, r1
    pop     { r4-r11, lr }
  140990:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r14}
    bx      lr
  140994:	e12fff1e 	bx	r14

00140998 <arm_save_mode_regs>:
#endif

.text

FUNCTION(arm_save_mode_regs)
    mrs     r1, cpsr
  140998:	e10f1000 	mrs	r1, CPSR

    stmia   r0, { r13, r14 }^ /* usr */
  14099c:	e8c06000 	stmia	r0, {r13, r14}^
    add     r0, #8
  1409a0:	e2800008 	add	r0, r0, #8

    cps     #0x11   /* fiq */
  1409a4:	f1020011 	cps	#17
    str     r13, [r0], #4
  1409a8:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409ac:	e480e004 	str	r14, [r0], #4

    cps     #0x12   /* irq */
  1409b0:	f1020012 	cps	#18
    str     r13, [r0], #4
  1409b4:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409b8:	e480e004 	str	r14, [r0], #4

    cps     #0x13   /* svc */
  1409bc:	f1020013 	cps	#19
    str     r13, [r0], #4
  1409c0:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409c4:	e480e004 	str	r14, [r0], #4

    cps     #0x17   /* abt */
  1409c8:	f1020017 	cps	#23
    str     r13, [r0], #4
  1409cc:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409d0:	e480e004 	str	r14, [r0], #4

    cps     #0x1b   /* und */
  1409d4:	f102001b 	cps	#27
    str     r13, [r0], #4
  1409d8:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409dc:	e480e004 	str	r14, [r0], #4

    cps     #0x1f   /* sys */
  1409e0:	f102001f 	cps	#31
    str     r13, [r0], #4
  1409e4:	e480d004 	str	r13, [r0], #4
    str     r14, [r0], #4
  1409e8:	e480e004 	str	r14, [r0], #4

    msr     cpsr_c, r1
  1409ec:	e121f001 	msr	CPSR_c, r1

    bx      lr
  1409f0:	e12fff1e 	bx	r14

001409f4 <arm_chain_load>:

/* void arm_chain_load(paddr_t entry, ulong arg0, ulong arg1, ulong arg2, ulong arg3) __NO_RETURN; */
/* shut down the system, branching into the secondary system */
FUNCTION(arm_chain_load)
    /* shuffle the args around */
    mov     r4, r0      /* r4 = entry point */
  1409f4:	e1a04000 	mov	r4, r0
    mov     r0, r1
  1409f8:	e1a00001 	mov	r0, r1
    mov     r1, r2
  1409fc:	e1a01002 	mov	r1, r2
    mov     r2, r3
  140a00:	e1a02003 	mov	r2, r3
    ldr     r3, [sp]
  140a04:	e59d3000 	ldr	r3, [r13]
    isb

#endif // WITH_KERNEL_VM

    /* call the entry point */
    bx      r4
  140a08:	e12fff14 	bx	r4

00140a0c <arch_disable_cache>:

#elif ARM_ISA_ARMV7

/* void arch_disable_cache(uint flags) */
FUNCTION(arch_disable_cache)
    stmfd   sp!, {r4-r11, lr}
  140a0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r14}

    mov     r7, r0                      // save flags
  140a10:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  140a14:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  140a18:	f10c01c0 	cpsid	aif

.Ldcache_disable:
    tst     r7, #DCACHE
  140a1c:	e3170002 	tst	r7, #2
    beq     .Licache_disable
  140a20:	0a000007 	beq	140a44 <arch_disable_cache+0x38>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  140a24:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already disabled?
  140a28:	e3100004 	tst	r0, #4
    beq     .Ldcache_already_disabled
  140a2c:	0a000003 	beq	140a40 <arch_disable_cache+0x34>

    bic     r0, #(1<<2)
  140a30:	e3c00004 	bic	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // disable dcache
  140a34:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

    // flush and invalidate the dcache
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
    bl      flush_invalidate_cache_v7
  140a38:	eb000021 	bl	140ac4 <flush_invalidate_cache_v7>

    b       .Ldcache_disable_L2
  140a3c:	ea000000 	b	140a44 <arch_disable_cache+0x38>

.Ldcache_already_disabled:
    // make sure all of the caches are invalidated
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  140a40:	eb000044 	bl	140b58 <invalidate_cache_v7>
    bic     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // disable L2 dcache
#endif

.Licache_disable:
    tst     r7, #ICACHE
  140a44:	e3170001 	tst	r7, #1
    beq     .Ldone_disable
  140a48:	0a000002 	beq	140a58 <arch_disable_cache+0x4c>

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  140a4c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    bic     r0, #(1<<12)
  140a50:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // disable icache
  140a54:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_disable:
    // make sure the icache is always invalidated
    mov     r0, #0
  140a58:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  140a5c:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    msr     cpsr, r8
  140a60:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r11, pc}
  140a64:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r15}

00140a68 <arch_enable_cache>:

/* void arch_enable_cache(uint flags) */
FUNCTION(arch_enable_cache)
    stmfd   sp!, {r4-r12, lr}
  140a68:	e92d5ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}

    mov     r7, r0                      // save flags
  140a6c:	e1a07000 	mov	r7, r0

    mrs     r8, cpsr                    // save the old interrupt state
  140a70:	e10f8000 	mrs	r8, CPSR
    cpsid   iaf                         // interrupts disabled
  140a74:	f10c01c0 	cpsid	aif

.Ldcache_enable:
    tst     r7, #DCACHE
  140a78:	e3170002 	tst	r7, #2
    beq     .Licache_enable
  140a7c:	0a000006 	beq	140a9c <arch_enable_cache+0x34>
    mrc     p15, 0, r0, c1, c0, 0       // cr1
  140a80:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    tst     r0, #(1<<2)                 // is the dcache already enabled?
  140a84:	e3100004 	tst	r0, #4
    bne     .Licache_enable
  140a88:	1a000003 	bne	140a9c <arch_enable_cache+0x34>

    // invalidate L1 and L2
    // NOTE: trashes a bunch of registers, can't be spilling stuff to the stack
#if !ARM_WITH_NO_DCACHE_INVALIDATE_ON_BOOT
    bl      invalidate_cache_v7
  140a8c:	eb000031 	bl	140b58 <invalidate_cache_v7>
    mrc     p15, 0, r0, c1, c0, 1       // aux cr1
    orr     r0, #(1<<1)
    mcr     p15, 0, r0, c1, c0, 1       // enable L2 dcache
#endif

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  140a90:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<2)
  140a94:	e3800004 	orr	r0, r0, #4
    mcr     p15, 0, r0, c1, c0, 0       // enable dcache
  140a98:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Licache_enable:
    tst     r7, #ICACHE
  140a9c:	e3170001 	tst	r7, #1
    beq     .Ldone_enable
  140aa0:	0a000004 	beq	140ab8 <arch_enable_cache+0x50>

    mov     r0, #0
  140aa4:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  140aa8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    mrc     p15, 0, r0, c1, c0, 0       // cr1
  140aac:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
    orr     r0, #(1<<12)
  140ab0:	e3800a01 	orr	r0, r0, #4096	; 0x1000
    mcr     p15, 0, r0, c1, c0, 0       // enable icache
  140ab4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

.Ldone_enable:
    isb
  140ab8:	f57ff06f 	isb	sy
    msr     cpsr, r8
  140abc:	e129f008 	msr	CPSR_fc, r8
    ldmfd   sp!, {r4-r12, pc}
  140ac0:	e8bd9ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, r12, r15}

00140ac4 <flush_invalidate_cache_v7>:

// flush & invalidate cache routine, trashes r0-r6, r9-r11
flush_invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  140ac4:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  140ac8:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  140acc:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  140ad0:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished
  140ad4:	0a00001a 	beq	140b44 <flush_invalidate_cache_v7+0x80>
    MOV     R10, #0
  140ad8:	e3a0a000 	mov	r10, #0
.Loop1:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  140adc:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  140ae0:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  140ae4:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  140ae8:	e3510002 	cmp	r1, #2
    BLT     .Lskip                      // no cache or only instruction cache at this level
  140aec:	ba000011 	blt	140b38 <flush_invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  140af0:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  140af4:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  140af8:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  140afc:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  140b00:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  140b04:	e59f4160 	ldr	r4, [pc, #352]	; 140c6c <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  140b08:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  140b0c:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  140b10:	e59f6158 	ldr	r6, [pc, #344]	; 140c70 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  140b14:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  140b18:	e1a09004 	mov	r9, r4
.Loop3:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  140b1c:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  140b20:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c14, 2     // clean & invalidate by set/way
  140b24:	ee07bf5e 	mcr	15, 0, r11, cr7, cr14, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  140b28:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3
  140b2c:	aafffffa 	bge	140b1c <flush_invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  140b30:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2
  140b34:	aafffff7 	bge	140b18 <flush_invalidate_cache_v7+0x54>
.Lskip:
    ADD     R10, R10, #2                    // increment the cache number
  140b38:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  140b3c:	e153000a 	cmp	r3, r10
    BGT     .Loop1
  140b40:	caffffe5 	bgt	140adc <flush_invalidate_cache_v7+0x18>

.Lfinished:
    mov     r10, #0
  140b44:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  140b48:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    dsb
  140b4c:	f57ff04f 	dsb	sy
    isb
  140b50:	f57ff06f 	isb	sy

    bx      lr
  140b54:	e12fff1e 	bx	r14

00140b58 <invalidate_cache_v7>:

// invalidate cache routine, trashes r0-r6, r9-r11
invalidate_cache_v7:
    /* from ARMv7 manual, B2-17 */
    dmb
  140b58:	f57ff05f 	dmb	sy
    MRC     p15, 1, R0, c0, c0, 1       // Read CLIDR
  140b5c:	ee300f30 	mrc	15, 1, r0, cr0, cr0, {1}
    ANDS    R3, R0, #0x7000000
  140b60:	e2103407 	ands	r3, r0, #117440512	; 0x7000000
    MOV     R3, R3, LSR #23             // Cache level value (naturally aligned)
  140b64:	e1a03ba3 	lsr	r3, r3, #23
    BEQ     .Lfinished_invalidate
  140b68:	0a00001a 	beq	140bd8 <invalidate_cache_v7+0x80>
    MOV     R10, #0
  140b6c:	e3a0a000 	mov	r10, #0
.Loop1_invalidate:
    ADD     R2, R10, R10, LSR #1        // Work out 3xcachelevel
  140b70:	e08a20aa 	add	r2, r10, r10, lsr #1
    MOV     R1, R0, LSR R2              // bottom 3 bits are the Cache type for this level
  140b74:	e1a01230 	lsr	r1, r0, r2
    AND     R1, R1, #7                  // get those 3 bits alone
  140b78:	e2011007 	and	r1, r1, #7
    CMP     R1, #2
  140b7c:	e3510002 	cmp	r1, #2
    BLT     .Lskip_invalidate           // no cache or only instruction cache at this level
  140b80:	ba000011 	blt	140bcc <invalidate_cache_v7+0x74>
    MCR     p15, 2, R10, c0, c0, 0      // write the Cache Size selection register
  140b84:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb                                 // ISB to sync the change to the CacheSizeID reg
  140b88:	f57ff06f 	isb	sy
    MRC     p15, 1, R1, c0, c0, 0       // reads current Cache Size ID register
  140b8c:	ee301f10 	mrc	15, 1, r1, cr0, cr0, {0}
    AND     R2, R1, #0x7                // extract the line length field
  140b90:	e2012007 	and	r2, r1, #7
    ADD     R2, R2, #4                  // add 4 for the line length offset (log2 16 bytes)
  140b94:	e2822004 	add	r2, r2, #4
    LDR     R4, =0x3FF
  140b98:	e59f40cc 	ldr	r4, [pc, #204]	; 140c6c <arch_sync_cache_range_asm+0x14>
    ANDS    R4, R4, R1, LSR #3          // R4 is the max number on the way size (right aligned)
  140b9c:	e01441a1 	ands	r4, r4, r1, lsr #3
    CLZ     R5, R4                      // R5 is the bit position of the way size increment
  140ba0:	e16f5f14 	clz	r5, r4
    LDR     R6, =0x00007FFF
  140ba4:	e59f60c4 	ldr	r6, [pc, #196]	; 140c70 <arch_sync_cache_range_asm+0x18>
    ANDS    R6, R6, R1, LSR #13         // R6 is the max number of the index size (right aligned)
  140ba8:	e01666a1 	ands	r6, r6, r1, lsr #13
.Loop2_invalidate:
    MOV     R9, R4                      // R9 working copy of the max way size (right aligned)
  140bac:	e1a09004 	mov	r9, r4
.Loop3_invalidate:
    ORR     R11, R10, R9, LSL R5        // factor in the way number and cache number into R11
  140bb0:	e18ab519 	orr	r11, r10, r9, lsl r5
    ORR     R11, R11, R6, LSL R2        // factor in the index number
  140bb4:	e18bb216 	orr	r11, r11, r6, lsl r2
    MCR     p15, 0, R11, c7, c6, 2      // invalidate by set/way
  140bb8:	ee07bf56 	mcr	15, 0, r11, cr7, cr6, {2}
    SUBS    R9, R9, #1                  // decrement the way number
  140bbc:	e2599001 	subs	r9, r9, #1
    BGE     .Loop3_invalidate
  140bc0:	aafffffa 	bge	140bb0 <invalidate_cache_v7+0x58>
    SUBS    R6, R6, #1                  // decrement the index
  140bc4:	e2566001 	subs	r6, r6, #1
    BGE     .Loop2_invalidate
  140bc8:	aafffff7 	bge	140bac <invalidate_cache_v7+0x54>
.Lskip_invalidate:
    ADD     R10, R10, #2                // increment the cache number
  140bcc:	e28aa002 	add	r10, r10, #2
    CMP     R3, R10
  140bd0:	e153000a 	cmp	r3, r10
    BGT     .Loop1_invalidate
  140bd4:	caffffe5 	bgt	140b70 <invalidate_cache_v7+0x18>

.Lfinished_invalidate:
    dsb
  140bd8:	f57ff04f 	dsb	sy
    mov     r10, #0
  140bdc:	e3a0a000 	mov	r10, #0
    mcr     p15, 2, r10, c0, c0, 0      // select cache level 0
  140be0:	ee40af10 	mcr	15, 2, r10, cr0, cr0, {0}
    isb
  140be4:	f57ff06f 	isb	sy

    bx      lr
  140be8:	e12fff1e 	bx	r14

00140bec <arch_clean_cache_range_asm>:
/* shared cache flush routines */

    /* void arch_flush_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  140bec:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  140bf0:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  140bf4:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c10, 1      // clean cache to PoC by MVA
  140bf8:	ee070f3a 	mcr	15, 0, r0, cr7, cr10, {1}
    add     r0, #CACHE_LINE
  140bfc:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  140c00:	e1500002 	cmp	r0, r2
    blo     0b
  140c04:	3afffffb 	bcc	140bf8 <arch_clean_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  140c08:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_range
#else
    bx      lr
  140c0c:	e12fff1e 	bx	r14

00140c10 <arch_clean_invalidate_cache_range_asm>:
#endif

    /* void arch_flush_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_clean_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  140c10:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  140c14:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  140c18:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c14, 1      // clean & invalidate dcache to PoC by MVA
  140c1c:	ee070f3e 	mcr	15, 0, r0, cr7, cr14, {1}
    add     r0, r0, #CACHE_LINE
  140c20:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  140c24:	e1500002 	cmp	r0, r2
    blo     0b
  140c28:	3afffffb 	bcc	140c1c <arch_clean_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  140c2c:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_clean_invalidate_range
#else
    bx      lr
  140c30:	e12fff1e 	bx	r14

00140c34 <arch_invalidate_cache_range_asm>:
#endif

    /* void arch_invalidate_cache_range(addr_t start, size_t len); */
FUNCTION(arch_invalidate_cache_range_asm)
#if ARM_WITH_CP15
    mov     r3, r0                      // save the start address
  140c34:	e1a03000 	mov	r3, r0
    add     r2, r0, r1                  // calculate the end address
  140c38:	e0802001 	add	r2, r0, r1
    bic     r0, #(CACHE_LINE-1)         // align the start with a cache line
  140c3c:	e3c0001f 	bic	r0, r0, #31
0:
    mcr     p15, 0, r0, c7, c6, 1       // invalidate dcache to PoC by MVA
  140c40:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
    add     r0, r0, #CACHE_LINE
  140c44:	e2800020 	add	r0, r0, #32
    cmp     r0, r2
  140c48:	e1500002 	cmp	r0, r2
    blo     0b
  140c4c:	3afffffb 	bcc	140c40 <arch_invalidate_cache_range_asm+0xc>

#if ARM_ISA_ARMV7
    dsb
  140c50:	f57ff04f 	dsb	sy
#endif
#if WITH_DEV_CACHE_PL310
    mov     r0, r3                      // put the start address back
    b       pl310_invalidate_range
#else
    bx      lr
  140c54:	e12fff1e 	bx	r14

00140c58 <arch_sync_cache_range_asm>:
#endif

    /* void arch_sync_cache_range(addr_t start, size_t len); */
FUNCTION(arch_sync_cache_range_asm)
    push    { r14 }
  140c58:	e52de004 	push	{r14}		; (str r14, [r13, #-4]!)
    bl      arch_clean_cache_range_asm
  140c5c:	ebffffe2 	bl	140bec <arch_clean_cache_range_asm>

    mov     r0, #0
  140c60:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c7, c5, 0       // invalidate icache to PoU
  140c64:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}

    pop     { pc }
  140c68:	e49df004 	pop	{r15}		; (ldr r15, [r13], #4)
    LDR     R4, =0x3FF
  140c6c:	000003ff 	.word	0x000003ff
    LDR     R6, =0x00007FFF
  140c70:	00007fff 	.word	0x00007fff

00140c74 <_arch_enable_ints>:

.text

/* void _arch_enable_ints(void); */
FUNCTION(_arch_enable_ints)
    mrs     r0, cpsr
  140c74:	e10f0000 	mrs	r0, CPSR
    bic     r0, r0, #(1<<7)     /* clear the I bit */
  140c78:	e3c00080 	bic	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  140c7c:	e121f000 	msr	CPSR_c, r0
    bx      lr
  140c80:	e12fff1e 	bx	r14

00140c84 <_arch_disable_ints>:

/* void _arch_disable_ints(void); */
FUNCTION(_arch_disable_ints)
    mrs     r0, cpsr
  140c84:	e10f0000 	mrs	r0, CPSR
    orr     r0, r0, #(1<<7)
  140c88:	e3800080 	orr	r0, r0, #128	; 0x80
    msr     cpsr_c, r0
  140c8c:	e121f000 	msr	CPSR_c, r0
    bx      lr
  140c90:	e12fff1e 	bx	r14

00140c94 <_atomic_swap>:

/* int _atomic_swap(int *ptr, int val); */
FUNCTION(_atomic_swap)
.L_loop_swap:
    ldrex   r12, [r0]
  140c94:	e190cf9f 	ldrex	r12, [r0]
    strex   r2, r1, [r0]
  140c98:	e1802f91 	strex	r2, r1, [r0]
    cmp     r2, #0
  140c9c:	e3520000 	cmp	r2, #0
    bne     .L_loop_swap
  140ca0:	1afffffb 	bne	140c94 <_atomic_swap>

    /* save old value */
    mov     r0, r12
  140ca4:	e1a0000c 	mov	r0, r12
    bx      lr
  140ca8:	e12fff1e 	bx	r14

00140cac <_atomic_add>:

/* int _atomic_add(int *ptr, int val); */
FUNCTION(_atomic_add)
    /* use load/store exclusive */
.L_loop_add:
    ldrex   r12, [r0]
  140cac:	e190cf9f 	ldrex	r12, [r0]
    add     r2, r12, r1
  140cb0:	e08c2001 	add	r2, r12, r1
    strex   r3, r2, [r0]
  140cb4:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  140cb8:	e3530000 	cmp	r3, #0
    bne     .L_loop_add
  140cbc:	1afffffa 	bne	140cac <_atomic_add>

    /* save old value */
    mov     r0, r12
  140cc0:	e1a0000c 	mov	r0, r12
    bx      lr
  140cc4:	e12fff1e 	bx	r14

00140cc8 <_atomic_and>:

/* int _atomic_and(int *ptr, int val); */
FUNCTION(_atomic_and)
    /* use load/store exclusive */
.L_loop_and:
    ldrex   r12, [r0]
  140cc8:	e190cf9f 	ldrex	r12, [r0]
    and     r2, r12, r1
  140ccc:	e00c2001 	and	r2, r12, r1
    strex   r3, r2, [r0]
  140cd0:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  140cd4:	e3530000 	cmp	r3, #0
    bne     .L_loop_and
  140cd8:	1afffffa 	bne	140cc8 <_atomic_and>

    /* save old value */
    mov     r0, r12
  140cdc:	e1a0000c 	mov	r0, r12
    bx      lr
  140ce0:	e12fff1e 	bx	r14

00140ce4 <_atomic_or>:

/* int _atomic_or(int *ptr, int val); */
FUNCTION(_atomic_or)
    /* use load/store exclusive */
.L_loop_or:
    ldrex   r12, [r0]
  140ce4:	e190cf9f 	ldrex	r12, [r0]
    orr     r2, r12, r1
  140ce8:	e18c2001 	orr	r2, r12, r1
    strex   r3, r2, [r0]
  140cec:	e1803f92 	strex	r3, r2, [r0]
    cmp     r3, #0
  140cf0:	e3530000 	cmp	r3, #0
    bne     .L_loop_or
  140cf4:	1afffffa 	bne	140ce4 <_atomic_or>

    /* save old value */
    mov     r0, r12
  140cf8:	e1a0000c 	mov	r0, r12
    bx      lr
  140cfc:	e12fff1e 	bx	r14

00140d00 <arch_spin_trylock>:

FUNCTION(arch_spin_trylock)
    mov     r2, r0
  140d00:	e1a02000 	mov	r2, r0
    mov     r1, #1
  140d04:	e3a01001 	mov	r1, #1
    ldrex   r0, [r2]
  140d08:	e1920f9f 	ldrex	r0, [r2]
    cmp     r0, #0
  140d0c:	e3500000 	cmp	r0, #0
    strexeq r0, r1, [r2]
  140d10:	01820f91 	strexeq	r0, r1, [r2]
    dmb
  140d14:	f57ff05f 	dmb	sy
    bx      lr
  140d18:	e12fff1e 	bx	r14

00140d1c <arch_spin_lock>:

FUNCTION(arch_spin_lock)
    mov     r1, #1
  140d1c:	e3a01001 	mov	r1, #1
1:
    ldrex   r2, [r0]
  140d20:	e1902f9f 	ldrex	r2, [r0]
    cmp     r2, #0
  140d24:	e3520000 	cmp	r2, #0
    wfene
  140d28:	1320f002 	wfene
    strexeq r2, r1, [r0]
  140d2c:	01802f91 	strexeq	r2, r1, [r0]
    cmpeq   r2, #0
  140d30:	03520000 	cmpeq	r2, #0
    bne     1b
  140d34:	1afffff9 	bne	140d20 <arch_spin_lock+0x4>
    dmb
  140d38:	f57ff05f 	dmb	sy
    bx      lr
  140d3c:	e12fff1e 	bx	r14

00140d40 <arch_spin_unlock>:

FUNCTION(arch_spin_unlock)
    mov     r1, #0
  140d40:	e3a01000 	mov	r1, #0
    dmb
  140d44:	f57ff05f 	dmb	sy
    str     r1, [r0]
  140d48:	e5801000 	str	r1, [r0]
    dsb
  140d4c:	f57ff04f 	dsb	sy
    sev
  140d50:	e320f004 	sev
    bx      lr
  140d54:	e12fff1e 	bx	r14

00140d58 <arch_idle>:

/* void arch_idle(); */
FUNCTION(arch_idle)
#if ARM_ARCH_LEVEL >= 7
    wfi
  140d58:	e320f003 	wfi
    mov     r0, #0
    mcr     p15, 0, r0, c7, c0, #4
#else
#error unknown cpu
#endif
    bx      lr
  140d5c:	e12fff1e 	bx	r14

00140d60 <arm_invalidate_tlb>:

/* void arm_invalidate_tlb(void) */
FUNCTION(arm_invalidate_tlb)
    mov     r0, #0
  140d60:	e3a00000 	mov	r0, #0
    mcr     p15, 0, r0, c8, c7, 0
  140d64:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
    bx      lr
  140d68:	e12fff1e 	bx	r14

00140d6c <arm_undefined>:
    /* return to whence we came from */
    rfeia   sp!
.endm

FUNCTION(arm_undefined)
    save
  140d6c:	f96d0513 	srsdb	r13!, #19
  140d70:	f10e0093 	cpsid	i,#19
  140d74:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  140d78:	e24dd008 	sub	r13, r13, #8
  140d7c:	e8cd6000 	stmia	r13, {r13, r14}^
  140d80:	eef80a10 	vmrs	r0, fpexc
  140d84:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140d88:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140d8c:	eee80a10 	vmsr	fpexc, r0
  140d90:	e1a0000d 	mov	r0, r13
  140d94:	e31d0004 	tst	r13, #4
  140d98:	024dd004 	subeq	r13, r13, #4
  140d9c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_undefined_handler
  140da0:	fa00018b 	blx	1413d4 <arm_undefined_handler>

    restore
  140da4:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140da8:	e1a0d000 	mov	r13, r0
  140dac:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140db0:	eee80a10 	vmsr	fpexc, r0
  140db4:	e8dd6000 	ldm	r13, {r13, r14}^
  140db8:	e28dd008 	add	r13, r13, #8
  140dbc:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  140dc0:	f8bd0a00 	rfeia	r13!

00140dc4 <arm_syscall>:

#ifndef WITH_LIB_SYSCALL
FUNCTION(arm_syscall)
    saveall
  140dc4:	f96d0513 	srsdb	r13!, #19
  140dc8:	f10e0093 	cpsid	i,#19
  140dcc:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140dd0:	e24dd008 	sub	r13, r13, #8
  140dd4:	e8cd6000 	stmia	r13, {r13, r14}^
  140dd8:	eef80a10 	vmrs	r0, fpexc
  140ddc:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140de0:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140de4:	eee80a10 	vmsr	fpexc, r0
  140de8:	e1a0000d 	mov	r0, r13
  140dec:	e31d0004 	tst	r13, #4
  140df0:	024dd004 	subeq	r13, r13, #4
  140df4:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_syscall_handler
  140df8:	fa000171 	blx	1413c4 <arm_syscall_handler>

    restoreall
  140dfc:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140e00:	e1a0d000 	mov	r13, r0
  140e04:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140e08:	eee80a10 	vmsr	fpexc, r0
  140e0c:	e8dd6000 	ldm	r13, {r13, r14}^
  140e10:	e28dd008 	add	r13, r13, #8
  140e14:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140e18:	f8bd0a00 	rfeia	r13!

00140e1c <arm_prefetch_abort>:
#endif

FUNCTION(arm_prefetch_abort)
    saveall_offset #4
  140e1c:	e24ee004 	sub	r14, r14, #4
  140e20:	f96d0513 	srsdb	r13!, #19
  140e24:	f10e0093 	cpsid	i,#19
  140e28:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140e2c:	e24dd008 	sub	r13, r13, #8
  140e30:	e8cd6000 	stmia	r13, {r13, r14}^
  140e34:	eef80a10 	vmrs	r0, fpexc
  140e38:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140e3c:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140e40:	eee80a10 	vmsr	fpexc, r0
  140e44:	e1a0000d 	mov	r0, r13
  140e48:	e31d0004 	tst	r13, #4
  140e4c:	024dd004 	subeq	r13, r13, #4
  140e50:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_prefetch_abort_handler
  140e54:	fa000209 	blx	141680 <arm_prefetch_abort_handler>

    restoreall
  140e58:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140e5c:	e1a0d000 	mov	r13, r0
  140e60:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140e64:	eee80a10 	vmsr	fpexc, r0
  140e68:	e8dd6000 	ldm	r13, {r13, r14}^
  140e6c:	e28dd008 	add	r13, r13, #8
  140e70:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140e74:	f8bd0a00 	rfeia	r13!

00140e78 <arm_data_abort>:

FUNCTION(arm_data_abort)
    saveall_offset #8
  140e78:	e24ee008 	sub	r14, r14, #8
  140e7c:	f96d0513 	srsdb	r13!, #19
  140e80:	f10e0093 	cpsid	i,#19
  140e84:	e92d5fff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140e88:	e24dd008 	sub	r13, r13, #8
  140e8c:	e8cd6000 	stmia	r13, {r13, r14}^
  140e90:	eef80a10 	vmrs	r0, fpexc
  140e94:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140e98:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140e9c:	eee80a10 	vmsr	fpexc, r0
  140ea0:	e1a0000d 	mov	r0, r13
  140ea4:	e31d0004 	tst	r13, #4
  140ea8:	024dd004 	subeq	r13, r13, #4
  140eac:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl      arm_data_abort_handler
  140eb0:	fa000183 	blx	1414c4 <arm_data_abort_handler>

    restoreall
  140eb4:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140eb8:	e1a0d000 	mov	r13, r0
  140ebc:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140ec0:	eee80a10 	vmsr	fpexc, r0
  140ec4:	e8dd6000 	ldm	r13, {r13, r14}^
  140ec8:	e28dd008 	add	r13, r13, #8
  140ecc:	e8bd5fff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r14}
  140ed0:	f8bd0a00 	rfeia	r13!

00140ed4 <arm_reserved>:

FUNCTION(arm_reserved)
    b   .
  140ed4:	eafffffe 	b	140ed4 <arm_reserved>

00140ed8 <arm_irq>:
    /* read the cycle count */
    mrc     p15, 0, sp, c9, c13, 0
    str     sp, [pc, #__irq_cycle_count - . - 8]
#endif

    save_offset    #4
  140ed8:	e24ee004 	sub	r14, r14, #4
  140edc:	f96d0513 	srsdb	r13!, #19
  140ee0:	f10e0093 	cpsid	i,#19
  140ee4:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  140ee8:	e24dd008 	sub	r13, r13, #8
  140eec:	e8cd6000 	stmia	r13, {r13, r14}^
  140ef0:	eef80a10 	vmrs	r0, fpexc
  140ef4:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140ef8:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140efc:	eee80a10 	vmsr	fpexc, r0
  140f00:	e1a0000d 	mov	r0, r13
  140f04:	e31d0004 	tst	r13, #4
  140f08:	024dd004 	subeq	r13, r13, #4
  140f0c:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)

    /* r0 now holds pointer to iframe */

    /* track that we're inside an irq handler */
    LOADCONST(r2, __arm_in_handler)
  140f10:	e30920fc 	movw	r2, #37116	; 0x90fc
  140f14:	e3402015 	movt	r2, #21
    mov     r1, #1
  140f18:	e3a01001 	mov	r1, #1
    str     r1, [r2]
  140f1c:	e5821000 	str	r1, [r2]

    /* call into higher level code */
    bl  platform_irq
  140f20:	fa001d4b 	blx	148454 <platform_irq>

    /* clear the irq handler status */
    LOADCONST(r1, __arm_in_handler)
  140f24:	e30910fc 	movw	r1, #37116	; 0x90fc
  140f28:	e3401015 	movt	r1, #21
    mov     r2, #0
  140f2c:	e3a02000 	mov	r2, #0
    str     r2, [r1]
  140f30:	e5812000 	str	r2, [r1]

    /* reschedule if the handler returns nonzero */
    cmp     r0, #0
  140f34:	e3500000 	cmp	r0, #0
    blne    thread_preempt
  140f38:	1b004ee6 	blne	154ad8 <__thread_preempt_from_arm>

    restore
  140f3c:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140f40:	e1a0d000 	mov	r13, r0
  140f44:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140f48:	eee80a10 	vmsr	fpexc, r0
  140f4c:	e8dd6000 	ldm	r13, {r13, r14}^
  140f50:	e28dd008 	add	r13, r13, #8
  140f54:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  140f58:	f8bd0a00 	rfeia	r13!

00140f5c <arm_fiq>:

FUNCTION(arm_fiq)
    save_offset #4
  140f5c:	e24ee004 	sub	r14, r14, #4
  140f60:	f96d0513 	srsdb	r13!, #19
  140f64:	f10e0093 	cpsid	i,#19
  140f68:	e92d500f 	push	{r0, r1, r2, r3, r12, r14}
  140f6c:	e24dd008 	sub	r13, r13, #8
  140f70:	e8cd6000 	stmia	r13, {r13, r14}^
  140f74:	eef80a10 	vmrs	r0, fpexc
  140f78:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
  140f7c:	e3c00101 	bic	r0, r0, #1073741824	; 0x40000000
  140f80:	eee80a10 	vmsr	fpexc, r0
  140f84:	e1a0000d 	mov	r0, r13
  140f88:	e31d0004 	tst	r13, #4
  140f8c:	024dd004 	subeq	r13, r13, #4
  140f90:	e52d0004 	push	{r0}		; (str r0, [r13, #-4]!)
    /* r0 now holds pointer to iframe */

    bl  platform_fiq
  140f94:	fa001d4a 	blx	1484c4 <platform_fiq>

    restore
  140f98:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140f9c:	e1a0d000 	mov	r13, r0
  140fa0:	e49d0004 	pop	{r0}		; (ldr r0, [r13], #4)
  140fa4:	eee80a10 	vmsr	fpexc, r0
  140fa8:	e8dd6000 	ldm	r13, {r13, r14}^
  140fac:	e28dd008 	add	r13, r13, #8
  140fb0:	e8bd500f 	pop	{r0, r1, r2, r3, r12, r14}
  140fb4:	f8bd0a00 	rfeia	r13!

00140fb8 <arch_copy_to_user>:
#include <arch/asm_macros.h>
#include <err.h>

/* status_t arch_copy_to_user(user_addr_t udest, const void *ksrc, size_t len) */
FUNCTION(arch_copy_to_user)
	cmp	r2, #0
  140fb8:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_done
  140fbc:	0a000003 	beq	140fd0 <arch_copy_to_user+0x18>
.Larch_copy_to_user_loop:
	ldrb	r3, [r1], #1
  140fc0:	e4d13001 	ldrb	r3, [r1], #1

	set_fault_handler	.Larch_copy_to_user_fault
	strbt	r3, [r0], #1
  140fc4:	e4e03001 	strbt	r3, [r0], #1

	subs	r2, r2, #1
  140fc8:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_to_user_loop
  140fcc:	8afffffb 	bhi	140fc0 <arch_copy_to_user+0x8>
.Larch_copy_to_user_done:
	mov	r0, #0
  140fd0:	e3a00000 	mov	r0, #0
	bx	lr
  140fd4:	e12fff1e 	bx	r14

00140fd8 <arch_copy_from_user>:

/* status_t arch_copy_from_user(void *kdest, user_addr_t usrc, size_t len) */
FUNCTION(arch_copy_from_user)
	cmp	r2, #0
  140fd8:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_from_user_done
  140fdc:	0a000003 	beq	140ff0 <arch_copy_from_user+0x18>
.Larch_copy_from_user_loop:
	set_fault_handler	.Larch_copy_from_user_fault
	ldrbt	r3, [r1], #1
  140fe0:	e4f13001 	ldrbt	r3, [r1], #1

	strb	r3, [r0], #1
  140fe4:	e4c03001 	strb	r3, [r0], #1
	subs	r2, r2, #1
  140fe8:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_loop
  140fec:	8afffffb 	bhi	140fe0 <arch_copy_from_user+0x8>
.Larch_copy_from_user_done:
	mov	r0, #0
  140ff0:	e3a00000 	mov	r0, #0
	bx	lr
  140ff4:	e12fff1e 	bx	r14

00140ff8 <arch_strlcpy_from_user>:

/* ssize_t arch_strlcpy_from_user(char *kdst, user_addr_t usrc, size_t len) */
FUNCTION(arch_strlcpy_from_user)
	mov	ip, r1
  140ff8:	e1a0c001 	mov	r12, r1
.Larch_strlcpy_from_user_loop:
	set_fault_handler	.Larch_strlcpy_from_user_fault
	ldrbt	r3, [r1]
  140ffc:	e4f13000 	ldrbt	r3, [r1], #0

	cmp	r3, #0
  141000:	e3530000 	cmp	r3, #0
	addne	r1, r1, #1
  141004:	12811001 	addne	r1, r1, #1

	cmp	r2, #0
  141008:	e3520000 	cmp	r2, #0
	beq	.Larch_strlcpy_from_user_dst_full
  14100c:	0a000002 	beq	14101c <arch_strlcpy_from_user+0x24>
	subs	r2, r2, #1
  141010:	e2522001 	subs	r2, r2, #1
	streqb	r2, [r0], #1
  141014:	04c02001 	strbeq	r2, [r0], #1
	strneb	r3, [r0], #1
  141018:	14c03001 	strbne	r3, [r0], #1
.Larch_strlcpy_from_user_dst_full:
	cmp	r3, #0
  14101c:	e3530000 	cmp	r3, #0
	bne	.Larch_strlcpy_from_user_loop
  141020:	1afffff5 	bne	140ffc <arch_strlcpy_from_user+0x4>

	sub	r0, r1, ip
  141024:	e041000c 	sub	r0, r1, r12
	bx	lr
  141028:	e12fff1e 	bx	r14

.Larch_strlcpy_from_user_fault:
	cmp	r2, #0
  14102c:	e3520000 	cmp	r2, #0
	beq	.Larch_copy_to_user_fault
  141030:	0a000003 	beq	141044 <arch_strlcpy_from_user+0x4c>
.Larch_copy_from_user_fault:
	mov	r1, #0
  141034:	e3a01000 	mov	r1, #0
	strb	r1, [r0], #1
  141038:	e4c01001 	strb	r1, [r0], #1
	subs	r2, r2, #1
  14103c:	e2522001 	subs	r2, r2, #1
	bhi	.Larch_copy_from_user_fault
  141040:	8afffffb 	bhi	141034 <arch_strlcpy_from_user+0x3c>
.Larch_copy_to_user_fault:
	mov	r0, #ERR_FAULT
  141044:	e3e00027 	mvn	r0, #39	; 0x27
	bx	lr
  141048:	e12fff1e 	bx	r14

0014104c <dump_mode_regs>:

extern struct fault_handler_table_entry __fault_handler_table_start[];
extern struct fault_handler_table_entry __fault_handler_table_end[];

static void dump_mode_regs(uint32_t spsr, uint32_t svc_r13, uint32_t svc_r14)
{
  14104c:	b570      	push	{r4, r5, r6, r14}
  14104e:	4604      	mov	r4, r0
  141050:	b090      	sub	sp, #64	; 0x40
    struct arm_mode_regs regs;
    arm_save_mode_regs(&regs);
  141052:	a802      	add	r0, sp, #8
{
  141054:	4615      	mov	r5, r2

    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  141056:	f004 041f 	and.w	r4, r4, #31
{
  14105a:	460e      	mov	r6, r1
    arm_save_mode_regs(&regs);
  14105c:	f7ff ec9c 	blx	140998 <arm_save_mode_regs>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  141060:	9b03      	ldr	r3, [sp, #12]
  141062:	2c10      	cmp	r4, #16
  141064:	f644 6288 	movw	r2, #20104	; 0x4e88
  141068:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14106c:	9300      	str	r3, [sp, #0]
  14106e:	f2c0 0215 	movt	r2, #21
  141072:	9b02      	ldr	r3, [sp, #8]
  141074:	f2c0 0015 	movt	r0, #21
  141078:	f000 80d8 	beq.w	14122c <dump_mode_regs+0x1e0>
  14107c:	2120      	movs	r1, #32
  14107e:	f013 f83b 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  141082:	9b05      	ldr	r3, [sp, #20]
  141084:	f644 62a8 	movw	r2, #20136	; 0x4ea8
  141088:	2c11      	cmp	r4, #17
  14108a:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14108e:	f2c0 0215 	movt	r2, #21
  141092:	9300      	str	r3, [sp, #0]
  141094:	f2c0 0015 	movt	r0, #21
  141098:	9b04      	ldr	r3, [sp, #16]
  14109a:	d158      	bne.n	14114e <dump_mode_regs+0x102>
  14109c:	212a      	movs	r1, #42	; 0x2a
  14109e:	f013 f82b 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  1410a2:	9b07      	ldr	r3, [sp, #28]
  1410a4:	f644 62ac 	movw	r2, #20140	; 0x4eac
  1410a8:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1410ac:	9300      	str	r3, [sp, #0]
  1410ae:	f2c0 0215 	movt	r2, #21
  1410b2:	9b06      	ldr	r3, [sp, #24]
  1410b4:	2120      	movs	r1, #32
  1410b6:	f2c0 0015 	movt	r0, #21
  1410ba:	f013 f81d 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  1410be:	9b09      	ldr	r3, [sp, #36]	; 0x24
  1410c0:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  1410c4:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1410c8:	9300      	str	r3, [sp, #0]
  1410ca:	f2c0 0215 	movt	r2, #21
  1410ce:	9b08      	ldr	r3, [sp, #32]
  1410d0:	2161      	movs	r1, #97	; 0x61
  1410d2:	f2c0 0015 	movt	r0, #21
  1410d6:	f013 f80f 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  1410da:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  1410de:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1410e2:	f2c0 0215 	movt	r2, #21
  1410e6:	9500      	str	r5, [sp, #0]
  1410e8:	f2c0 0015 	movt	r0, #21
  1410ec:	4633      	mov	r3, r6
  1410ee:	2120      	movs	r1, #32
  1410f0:	f013 f802 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  1410f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1410f6:	f644 62b4 	movw	r2, #20148	; 0x4eb4
  1410fa:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1410fe:	f2c0 0215 	movt	r2, #21
  141102:	9300      	str	r3, [sp, #0]
  141104:	f2c0 0015 	movt	r0, #21
  141108:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  14110a:	2120      	movs	r1, #32
  14110c:	f012 fff4 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  141110:	2c1f      	cmp	r4, #31
  141112:	d159      	bne.n	1411c8 <dump_mode_regs+0x17c>
  141114:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  141116:	f644 62b8 	movw	r2, #20152	; 0x4eb8
  14111a:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14111e:	f2c0 0215 	movt	r2, #21
  141122:	9300      	str	r3, [sp, #0]
  141124:	f2c0 0015 	movt	r0, #21
  141128:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  14112a:	212a      	movs	r1, #42	; 0x2a
  14112c:	f012 ffe4 	bl	1540f8 <_printf>
            break;
        case CPSR_MODE_UND:
            stack = regs.und_r13;
            break;
        case CPSR_MODE_SYS:
            stack = regs.sys_r13;
  141130:	9e0e      	ldr	r6, [sp, #56]	; 0x38
            break;
        default:
            stack = 0;
    }

    if (stack != 0) {
  141132:	b156      	cbz	r6, 14114a <dump_mode_regs+0xfe>
        dprintf(CRITICAL, "bottom of stack at 0x%08x:\n", (unsigned int)stack);
  141134:	f644 60bc 	movw	r0, #20156	; 0x4ebc
  141138:	4631      	mov	r1, r6
  14113a:	f2c0 0015 	movt	r0, #21
  14113e:	f012 ffdb 	bl	1540f8 <_printf>
        hexdump((void *)stack, 128);
  141142:	4630      	mov	r0, r6
  141144:	2180      	movs	r1, #128	; 0x80
  141146:	f011 fdcb 	bl	152ce0 <hexdump>
    }
}
  14114a:	b010      	add	sp, #64	; 0x40
  14114c:	bd70      	pop	{r4, r5, r6, r15}
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  14114e:	2120      	movs	r1, #32
  141150:	f012 ffd2 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  141154:	9b07      	ldr	r3, [sp, #28]
  141156:	f644 62ac 	movw	r2, #20140	; 0x4eac
  14115a:	2c12      	cmp	r4, #18
  14115c:	f644 608c 	movw	r0, #20108	; 0x4e8c
  141160:	f2c0 0215 	movt	r2, #21
  141164:	9300      	str	r3, [sp, #0]
  141166:	f2c0 0015 	movt	r0, #21
  14116a:	9b06      	ldr	r3, [sp, #24]
  14116c:	f040 8096 	bne.w	14129c <dump_mode_regs+0x250>
  141170:	212a      	movs	r1, #42	; 0x2a
  141172:	f012 ffc1 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  141176:	9b09      	ldr	r3, [sp, #36]	; 0x24
  141178:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  14117c:	f644 608c 	movw	r0, #20108	; 0x4e8c
  141180:	9300      	str	r3, [sp, #0]
  141182:	f2c0 0215 	movt	r2, #21
  141186:	9b08      	ldr	r3, [sp, #32]
  141188:	2161      	movs	r1, #97	; 0x61
  14118a:	f2c0 0015 	movt	r0, #21
  14118e:	f012 ffb3 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  141192:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  141196:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14119a:	f2c0 0215 	movt	r2, #21
  14119e:	4633      	mov	r3, r6
  1411a0:	2120      	movs	r1, #32
  1411a2:	9500      	str	r5, [sp, #0]
  1411a4:	f2c0 0015 	movt	r0, #21
  1411a8:	f012 ffa6 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  1411ac:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1411ae:	f644 62b4 	movw	r2, #20148	; 0x4eb4
  1411b2:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1411b6:	9300      	str	r3, [sp, #0]
  1411b8:	f2c0 0215 	movt	r2, #21
  1411bc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1411be:	f2c0 0015 	movt	r0, #21
  1411c2:	2120      	movs	r1, #32
  1411c4:	f012 ff98 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1411c8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  1411ca:	f644 62b8 	movw	r2, #20152	; 0x4eb8
  1411ce:	f644 608c 	movw	r0, #20108	; 0x4e8c
    switch (spsr & CPSR_MODE_MASK) {
  1411d2:	3c11      	subs	r4, #17
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1411d4:	9300      	str	r3, [sp, #0]
  1411d6:	f2c0 0215 	movt	r2, #21
  1411da:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  1411dc:	f2c0 0015 	movt	r0, #21
  1411e0:	2120      	movs	r1, #32
  1411e2:	f012 ff89 	bl	1540f8 <_printf>
    switch (spsr & CPSR_MODE_MASK) {
  1411e6:	2c0e      	cmp	r4, #14
  1411e8:	d8af      	bhi.n	14114a <dump_mode_regs+0xfe>
  1411ea:	a301      	add	r3, pc, #4	; (adr r3, 1411f0 <dump_mode_regs+0x1a4>)
  1411ec:	f853 f024 	ldr.w	r15, [r3, r4, lsl #2]
  1411f0:	00141299 	.word	0x00141299
  1411f4:	00141295 	.word	0x00141295
  1411f8:	00141133 	.word	0x00141133
  1411fc:	0014114b 	.word	0x0014114b
  141200:	0014114b 	.word	0x0014114b
  141204:	0014114b 	.word	0x0014114b
  141208:	0014114b 	.word	0x0014114b
  14120c:	0014114b 	.word	0x0014114b
  141210:	0014114b 	.word	0x0014114b
  141214:	0014114b 	.word	0x0014114b
  141218:	00141291 	.word	0x00141291
  14121c:	0014114b 	.word	0x0014114b
  141220:	0014114b 	.word	0x0014114b
  141224:	0014114b 	.word	0x0014114b
  141228:	00141131 	.word	0x00141131
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_USR) ? '*' : ' ', "usr", regs.usr_r13, regs.usr_r14);
  14122c:	212a      	movs	r1, #42	; 0x2a
  14122e:	f012 ff63 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_FIQ) ? '*' : ' ', "fiq", regs.fiq_r13, regs.fiq_r14);
  141232:	9b05      	ldr	r3, [sp, #20]
  141234:	f644 62a8 	movw	r2, #20136	; 0x4ea8
  141238:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14123c:	9300      	str	r3, [sp, #0]
  14123e:	f2c0 0215 	movt	r2, #21
  141242:	9b04      	ldr	r3, [sp, #16]
  141244:	f2c0 0015 	movt	r0, #21
  141248:	2120      	movs	r1, #32
  14124a:	e728      	b.n	14109e <dump_mode_regs+0x52>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  14124c:	2120      	movs	r1, #32
  14124e:	f012 ff53 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  141252:	2c1b      	cmp	r4, #27
  141254:	f47f af4e 	bne.w	1410f4 <dump_mode_regs+0xa8>
  141258:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  14125a:	f644 62b4 	movw	r2, #20148	; 0x4eb4
  14125e:	f644 608c 	movw	r0, #20108	; 0x4e8c
  141262:	f2c0 0215 	movt	r2, #21
  141266:	9300      	str	r3, [sp, #0]
  141268:	212a      	movs	r1, #42	; 0x2a
  14126a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  14126c:	f2c0 0015 	movt	r0, #21
  141270:	f012 ff42 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  141274:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  141276:	f644 62b8 	movw	r2, #20152	; 0x4eb8
  14127a:	f644 608c 	movw	r0, #20108	; 0x4e8c
  14127e:	9300      	str	r3, [sp, #0]
  141280:	f2c0 0215 	movt	r2, #21
  141284:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  141286:	f2c0 0015 	movt	r0, #21
  14128a:	2120      	movs	r1, #32
  14128c:	f012 ff34 	bl	1540f8 <_printf>
            stack = regs.und_r13;
  141290:	9e0c      	ldr	r6, [sp, #48]	; 0x30
            break;
  141292:	e74e      	b.n	141132 <dump_mode_regs+0xe6>
            stack = regs.irq_r13;
  141294:	9e06      	ldr	r6, [sp, #24]
            break;
  141296:	e74c      	b.n	141132 <dump_mode_regs+0xe6>
            stack = regs.fiq_r13;
  141298:	9e04      	ldr	r6, [sp, #16]
            break;
  14129a:	e74a      	b.n	141132 <dump_mode_regs+0xe6>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_IRQ) ? '*' : ' ', "irq", regs.irq_r13, regs.irq_r14);
  14129c:	2120      	movs	r1, #32
  14129e:	f012 ff2b 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", 'a', "svc", regs.svc_r13, regs.svc_r14);
  1412a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  1412a4:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  1412a8:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1412ac:	9300      	str	r3, [sp, #0]
  1412ae:	f2c0 0215 	movt	r2, #21
  1412b2:	9b08      	ldr	r3, [sp, #32]
  1412b4:	f2c0 0015 	movt	r0, #21
  1412b8:	2161      	movs	r1, #97	; 0x61
  1412ba:	f012 ff1d 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SVC) ? '*' : ' ', "svc", svc_r13, svc_r14);
  1412be:	f644 62b0 	movw	r2, #20144	; 0x4eb0
  1412c2:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1412c6:	2c13      	cmp	r4, #19
  1412c8:	9500      	str	r5, [sp, #0]
  1412ca:	f2c0 0215 	movt	r2, #21
  1412ce:	4633      	mov	r3, r6
  1412d0:	f2c0 0015 	movt	r0, #21
  1412d4:	d1ba      	bne.n	14124c <dump_mode_regs+0x200>
  1412d6:	212a      	movs	r1, #42	; 0x2a
  1412d8:	f012 ff0e 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_UND) ? '*' : ' ', "und", regs.und_r13, regs.und_r14);
  1412dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1412de:	f644 62b4 	movw	r2, #20148	; 0x4eb4
  1412e2:	f644 608c 	movw	r0, #20108	; 0x4e8c
  1412e6:	9300      	str	r3, [sp, #0]
  1412e8:	f2c0 0215 	movt	r2, #21
  1412ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1412ee:	2120      	movs	r1, #32
  1412f0:	f2c0 0015 	movt	r0, #21
  1412f4:	f012 ff00 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "%c%s r13 0x%08x r14 0x%08x\n", ((spsr & CPSR_MODE_MASK) == CPSR_MODE_SYS) ? '*' : ' ', "sys", regs.sys_r13, regs.sys_r14);
  1412f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  1412fa:	f644 62b8 	movw	r2, #20152	; 0x4eb8
  1412fe:	f644 608c 	movw	r0, #20108	; 0x4e8c
  141302:	9300      	str	r3, [sp, #0]
  141304:	f2c0 0215 	movt	r2, #21
  141308:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  14130a:	2120      	movs	r1, #32
  14130c:	f2c0 0015 	movt	r0, #21
  141310:	f012 fef2 	bl	1540f8 <_printf>
  141314:	e70d      	b.n	141132 <dump_mode_regs+0xe6>
  141316:	bf00      	nop

00141318 <exception_die>:

    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
}

static void exception_die(struct arm_fault_frame *frame, const char *msg)
{
  141318:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  14131a:	f644 60d8 	movw	r0, #20184	; 0x4ed8
{
  14131e:	b500      	push	{r14}
    dprintf(CRITICAL, "%s", msg);
  141320:	f2c0 0015 	movt	r0, #21
{
  141324:	b083      	sub	sp, #12
    dprintf(CRITICAL, "%s", msg);
  141326:	f012 fee7 	bl	1540f8 <_printf>

GEN_CP15_REG_FUNCS(fcseidr, 0, c13, c0, 0);
GEN_CP15_REG_FUNCS(contextidr, 0, c13, c0, 1);
GEN_CP15_REG_FUNCS(tpidrurw, 0, c13, c0, 2);
GEN_CP15_REG_FUNCS(tpidruro, 0, c13, c0, 3);
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  14132a:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    dprintf(CRITICAL, "current_thread %p, name %s\n",
  14132e:	f501 72b2 	add.w	r2, r1, #356	; 0x164
  141332:	b919      	cbnz	r1, 14133c <exception_die+0x24>
  141334:	f246 2288 	movw	r2, #25224	; 0x6288
  141338:	f2c0 0215 	movt	r2, #21
  14133c:	f644 60dc 	movw	r0, #20188	; 0x4edc
  141340:	f2c0 0015 	movt	r0, #21
  141344:	f012 fed8 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r[0], frame->r[1], frame->r[2], frame->r[3]);
  141348:	69a5      	ldr	r5, [r4, #24]
  14134a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  14134e:	f644 60f8 	movw	r0, #20216	; 0x4ef8
  141352:	68e1      	ldr	r1, [r4, #12]
  141354:	f2c0 0015 	movt	r0, #21
  141358:	9500      	str	r5, [sp, #0]
  14135a:	f012 fecd 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r4  0x%08x r5  0x%08x r6  0x%08x r7  0x%08x\n", frame->r[4], frame->r[5], frame->r[6], frame->r[7]);
  14135e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
  141360:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  141364:	f644 7028 	movw	r0, #20264	; 0x4f28
  141368:	69e1      	ldr	r1, [r4, #28]
  14136a:	f2c0 0015 	movt	r0, #21
  14136e:	9500      	str	r5, [sp, #0]
  141370:	f012 fec2 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r8  0x%08x r9  0x%08x r10 0x%08x r11 0x%08x\n", frame->r[8], frame->r[9], frame->r[10], frame->r[11]);
  141374:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  141376:	e9d4 230c 	ldrd	r2, r3, [r4, #48]	; 0x30
  14137a:	f644 7058 	movw	r0, #20312	; 0x4f58
  14137e:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  141380:	f2c0 0015 	movt	r0, #21
  141384:	9500      	str	r5, [sp, #0]
  141386:	f012 feb7 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r[12], frame->usp, frame->ulr, frame->pc);
  14138a:	6c65      	ldr	r5, [r4, #68]	; 0x44
  14138c:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  141390:	f644 7088 	movw	r0, #20360	; 0x4f88
  141394:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  141396:	f2c0 0015 	movt	r0, #21
  14139a:	9500      	str	r5, [sp, #0]
  14139c:	f012 feac 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  1413a0:	6ca1      	ldr	r1, [r4, #72]	; 0x48
  1413a2:	f644 70b8 	movw	r0, #20408	; 0x4fb8
  1413a6:	f2c0 0015 	movt	r0, #21
  1413aa:	f012 fea5 	bl	1540f8 <_printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  1413ae:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  1413b0:	6c22      	ldr	r2, [r4, #64]	; 0x40
  1413b2:	f104 014c 	add.w	r1, r4, #76	; 0x4c
  1413b6:	f7ff fe49 	bl	14104c <dump_mode_regs>
    dump_fault_frame(frame);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  1413ba:	2109      	movs	r1, #9
  1413bc:	2000      	movs	r0, #0
  1413be:	f7ff f8bd 	bl	14053c <platform_halt>
  1413c2:	bf00      	nop

001413c4 <arm_syscall_handler>:
    for (;;);
}

__WEAK void arm_syscall_handler(struct arm_fault_frame *frame)
{
    exception_die(frame, "unhandled syscall, halting\n");
  1413c4:	f644 6150 	movw	r1, #20048	; 0x4e50
{
  1413c8:	b508      	push	{r3, r14}
    exception_die(frame, "unhandled syscall, halting\n");
  1413ca:	f2c0 0115 	movt	r1, #21
  1413ce:	f7ff ffa3 	bl	141318 <exception_die>
  1413d2:	bf00      	nop

001413d4 <arm_undefined_handler>:
}

void arm_undefined_handler(struct arm_iframe *frame)
{
  1413d4:	e9d0 3209 	ldrd	r3, r2, [r0, #36]	; 0x24
  1413d8:	b510      	push	{r4, r14}
    /* look at the undefined instruction, figure out if it's something we can handle */
    bool in_thumb = frame->spsr & (1<<5);
    if (in_thumb) {
  1413da:	0692      	lsls	r2, r2, #26
{
  1413dc:	b082      	sub	sp, #8
    if (in_thumb) {
  1413de:	d524      	bpl.n	14142a <arm_undefined_handler+0x56>
        if (opcode & 0x0000e800) {
            /* swap the 16bit words */
            opcode = (opcode >> 16) | (opcode << 16);
        }

        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1413e0:	f44f 6120 	mov.w	r1, #2560	; 0xa00
        frame->pc -= 2;
  1413e4:	1e9a      	subs	r2, r3, #2
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1413e6:	f6ce 4100 	movt	r1, #60416	; 0xec00
        frame->pc -= 2;
  1413ea:	6242      	str	r2, [r0, #36]	; 0x24
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1413ec:	f44f 6260 	mov.w	r2, #3584	; 0xe00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  1413f0:	f853 3c02 	ldr.w	r3, [r3, #-2]
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  1413f4:	f6ce 4200 	movt	r2, #60416	; 0xec00
        if (opcode & 0x0000e800) {
  1413f8:	f413 4f68 	tst.w	r3, #59392	; 0xe800
            opcode = (opcode >> 16) | (opcode << 16);
  1413fc:	bf18      	it	ne
  1413fe:	ea4f 4333 	movne.w	r3, r3, ror #16
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  141402:	401a      	ands	r2, r3
  141404:	428a      	cmp	r2, r1
  141406:	d00b      	beq.n	141420 <arm_undefined_handler+0x4c>
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  141408:	f003 426f 	and.w	r2, r3, #4009754624	; 0xef000000
        if (((opcode & 0xec000e00) == 0xec000a00) || // vfp
  14140c:	f1b2 4f6f 	cmp.w	r2, #4009754624	; 0xef000000
  141410:	d006      	beq.n	141420 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf9000000)) { // VLD
  141412:	2200      	movs	r2, #0
  141414:	f6cf 7210 	movt	r2, #65296	; 0xff10
  141418:	401a      	ands	r2, r3
                ((opcode & 0xef000000) == 0xef000000) || // advanced simd data processing
  14141a:	f1b2 4f79 	cmp.w	r2, #4177526784	; 0xf9000000
  14141e:	d11f      	bne.n	141460 <arm_undefined_handler+0x8c>

#if ARM_WITH_VFP
fpu:
    arm_fpu_undefined_instruction(frame);
#endif
}
  141420:	b002      	add	sp, #8
  141422:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    arm_fpu_undefined_instruction(frame);
  141426:	f000 b9ab 	b.w	141780 <arm_fpu_undefined_instruction>
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  14142a:	f44f 6260 	mov.w	r2, #3584	; 0xe00
        frame->pc -= 4;
  14142e:	1f1c      	subs	r4, r3, #4
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  141430:	f44f 6120 	mov.w	r1, #2560	; 0xa00
  141434:	f6c0 4200 	movt	r2, #3072	; 0xc00
        frame->pc -= 4;
  141438:	6244      	str	r4, [r0, #36]	; 0x24
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  14143a:	f6c0 4100 	movt	r1, #3072	; 0xc00
    __UNUSED uint32_t opcode = *(uint32_t *)frame->pc;
  14143e:	f853 3c04 	ldr.w	r3, [r3, #-4]
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  141442:	401a      	ands	r2, r3
  141444:	428a      	cmp	r2, r1
  141446:	d0eb      	beq.n	141420 <arm_undefined_handler+0x4c>
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  141448:	f003 427e 	and.w	r2, r3, #4261412864	; 0xfe000000
        if (((opcode & 0x0c000e00) == 0x0c000a00) || // vfp
  14144c:	f1b2 4f72 	cmp.w	r2, #4060086272	; 0xf2000000
  141450:	d0e6      	beq.n	141420 <arm_undefined_handler+0x4c>
                ((opcode & 0xff100000) == 0xf4000000)) { // VLD
  141452:	2200      	movs	r2, #0
  141454:	f6cf 7210 	movt	r2, #65296	; 0xff10
  141458:	401a      	ands	r2, r3
                ((opcode & 0xfe000000) == 0xf2000000) || // advanced simd data processing
  14145a:	f1b2 4f74 	cmp.w	r2, #4093640704	; 0xf4000000
  14145e:	d0df      	beq.n	141420 <arm_undefined_handler+0x4c>
  141460:	4604      	mov	r4, r0
    dprintf(CRITICAL, "%s", msg);
  141462:	f644 616c 	movw	r1, #20076	; 0x4e6c
  141466:	f644 60d8 	movw	r0, #20184	; 0x4ed8
  14146a:	f2c0 0115 	movt	r1, #21
  14146e:	f2c0 0015 	movt	r0, #21
  141472:	f012 fe41 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r0  0x%08x r1  0x%08x r2  0x%08x r3  0x%08x\n", frame->r0, frame->r1, frame->r2, frame->r3);
  141476:	69a3      	ldr	r3, [r4, #24]
  141478:	9300      	str	r3, [sp, #0]
  14147a:	f644 60f8 	movw	r0, #20216	; 0x4ef8
  14147e:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
  141482:	f2c0 0015 	movt	r0, #21
  141486:	68e1      	ldr	r1, [r4, #12]
  141488:	f012 fe36 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "r12 0x%08x usp 0x%08x ulr 0x%08x pc  0x%08x\n", frame->r12, frame->usp, frame->ulr, frame->pc);
  14148c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  14148e:	9300      	str	r3, [sp, #0]
  141490:	f644 7088 	movw	r0, #20360	; 0x4f88
  141494:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  141498:	f2c0 0015 	movt	r0, #21
  14149c:	69e1      	ldr	r1, [r4, #28]
  14149e:	f012 fe2b 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "spsr 0x%08x\n", frame->spsr);
  1414a2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  1414a4:	f644 70b8 	movw	r0, #20408	; 0x4fb8
  1414a8:	f2c0 0015 	movt	r0, #21
  1414ac:	f012 fe24 	bl	1540f8 <_printf>
    dump_mode_regs(frame->spsr, (uintptr_t)(frame + 1), frame->lr);
  1414b0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  1414b2:	6a22      	ldr	r2, [r4, #32]
  1414b4:	f104 012c 	add.w	r1, r4, #44	; 0x2c
  1414b8:	f7ff fdc8 	bl	14104c <dump_mode_regs>
    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  1414bc:	2109      	movs	r1, #9
  1414be:	2000      	movs	r0, #0
  1414c0:	f7ff f83c 	bl	14053c <platform_halt>

001414c4 <arm_data_abort_handler>:

void arm_data_abort_handler(struct arm_fault_frame *frame)
{
  1414c4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
GEN_CP15_REG_FUNCS(dfsr, 0, c5, c0, 0);
  1414c6:	ee15 5f10 	mrc	15, 0, r5, cr5, cr0, {0}
GEN_CP15_REG_FUNCS(dfar, 0, c6, c0, 0);
  1414ca:	ee16 6f10 	mrc	15, 0, r6, cr6, cr0, {0}
    uint32_t fsr = arm_read_dfsr();
    uint32_t far = arm_read_dfar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1414ce:	f644 3300 	movw	r3, #19200	; 0x4b00
  1414d2:	f644 3218 	movw	r2, #19224	; 0x4b18
  1414d6:	f2c0 0315 	movt	r3, #21
  1414da:	f2c0 0215 	movt	r2, #21
  1414de:	4293      	cmp	r3, r2
  1414e0:	d216      	bcs.n	141510 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1414e2:	6c47      	ldr	r7, [r0, #68]	; 0x44
  1414e4:	6819      	ldr	r1, [r3, #0]
  1414e6:	42b9      	cmp	r1, r7
  1414e8:	bf1f      	itttt	ne
  1414ea:	43dc      	mvnne	r4, r3
  1414ec:	18a4      	addne	r4, r4, r2
  1414ee:	f024 0407 	bicne.w	r4, r4, #7
  1414f2:	18e4      	addne	r4, r4, r3
  1414f4:	d00a      	beq.n	14150c <arm_data_abort_handler+0x48>
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  1414f6:	42a3      	cmp	r3, r4
  1414f8:	f103 0208 	add.w	r2, r3, #8
  1414fc:	d008      	beq.n	141510 <arm_data_abort_handler+0x4c>
        if (fault_handler->pc == frame->pc) {
  1414fe:	6811      	ldr	r1, [r2, #0]
  141500:	4613      	mov	r3, r2
  141502:	42b9      	cmp	r1, r7
  141504:	d1f7      	bne.n	1414f6 <arm_data_abort_handler+0x32>
            frame->pc = fault_handler->fault_handler;
  141506:	6853      	ldr	r3, [r2, #4]
  141508:	6443      	str	r3, [r0, #68]	; 0x44

    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);

    exception_die(frame, "halting\n");
}
  14150a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    for (fault_handler = __fault_handler_table_start; fault_handler < __fault_handler_table_end; fault_handler++) {
  14150c:	461a      	mov	r2, r3
  14150e:	e7fa      	b.n	141506 <arm_data_abort_handler+0x42>
  141510:	4604      	mov	r4, r0
    dprintf(CRITICAL, "\n\ncpu %u data abort, ", arch_curr_cpu_num());
  141512:	f644 4014 	movw	r0, #19476	; 0x4c14
  141516:	2100      	movs	r1, #0
  141518:	f2c0 0015 	movt	r0, #21
  14151c:	f012 fdec 	bl	1540f8 <_printf>
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  141520:	09ab      	lsrs	r3, r5, #6
  141522:	f005 020f 	and.w	r2, r5, #15
  141526:	f003 0310 	and.w	r3, r3, #16
  14152a:	4313      	orrs	r3, r2
    switch (fault_status) {
  14152c:	3b01      	subs	r3, #1
    bool write = !!BIT(fsr, 11);
  14152e:	f405 6200 	and.w	r2, r5, #2048	; 0x800
    switch (fault_status) {
  141532:	2b15      	cmp	r3, #21
  141534:	d80c      	bhi.n	141550 <arm_data_abort_handler+0x8c>
  141536:	e8df f003 	tbb	[r15, r3]
  14153a:	8990      	.short	0x8990
  14153c:	77650b77 	.word	0x77650b77
  141540:	0b4a5365 	.word	0x0b4a5365
  141544:	0b380b4a 	.word	0x0b380b4a
  141548:	0b0b0b38 	.word	0x0b0b0b38
  14154c:	260b0b0b 	.word	0x260b0b0b
            dprintf(CRITICAL, "unhandled fault\n");
  141550:	f644 5008 	movw	r0, #19720	; 0x4d08
  141554:	f2c0 0015 	movt	r0, #21
  141558:	f012 fdce 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "DFAR 0x%x (fault address)\n", far);
  14155c:	f644 501c 	movw	r0, #19740	; 0x4d1c
  141560:	4631      	mov	r1, r6
  141562:	f2c0 0015 	movt	r0, #21
  141566:	f012 fdc7 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "DFSR 0x%x (fault status register)\n", fsr);
  14156a:	f644 5038 	movw	r0, #19768	; 0x4d38
  14156e:	4629      	mov	r1, r5
  141570:	f2c0 0015 	movt	r0, #21
  141574:	f012 fdc0 	bl	1540f8 <_printf>
    exception_die(frame, "halting\n");
  141578:	f644 515c 	movw	r1, #19804	; 0x4d5c
  14157c:	4620      	mov	r0, r4
  14157e:	f2c0 0115 	movt	r1, #21
  141582:	f7ff fec9 	bl	141318 <exception_die>
            dprintf(CRITICAL, "asynchronous external abort on %s\n", write ? "write" : "read");
  141586:	f644 4104 	movw	r1, #19460	; 0x4c04
  14158a:	f644 430c 	movw	r3, #19468	; 0x4c0c
  14158e:	f2c0 0315 	movt	r3, #21
  141592:	f644 40e4 	movw	r0, #19684	; 0x4ce4
  141596:	f2c0 0115 	movt	r1, #21
  14159a:	f2c0 0015 	movt	r0, #21
  14159e:	2a00      	cmp	r2, #0
  1415a0:	bf08      	it	eq
  1415a2:	4619      	moveq	r1, r3
  1415a4:	f012 fda8 	bl	1540f8 <_printf>
            break;
  1415a8:	e7d8      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "permission fault on %s\n", write ? "write" : "read");
  1415aa:	f644 4104 	movw	r1, #19460	; 0x4c04
  1415ae:	f644 430c 	movw	r3, #19468	; 0x4c0c
  1415b2:	f2c0 0315 	movt	r3, #21
  1415b6:	f644 4098 	movw	r0, #19608	; 0x4c98
  1415ba:	f2c0 0115 	movt	r1, #21
  1415be:	f2c0 0015 	movt	r0, #21
  1415c2:	2a00      	cmp	r2, #0
  1415c4:	bf08      	it	eq
  1415c6:	4619      	moveq	r1, r3
  1415c8:	f012 fd96 	bl	1540f8 <_printf>
            break;
  1415cc:	e7c6      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  1415ce:	f644 407c 	movw	r0, #19580	; 0x4c7c
  1415d2:	f3c5 1103 	ubfx	r1, r5, #4, #4
  1415d6:	f2c0 0015 	movt	r0, #21
  1415da:	f012 fd8d 	bl	1540f8 <_printf>
            break;
  1415de:	e7bd      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "synchronous external abort on %s\n", write ? "write" : "read");
  1415e0:	f644 4104 	movw	r1, #19460	; 0x4c04
  1415e4:	f644 430c 	movw	r3, #19468	; 0x4c0c
  1415e8:	f2c0 0315 	movt	r3, #21
  1415ec:	f644 40c0 	movw	r0, #19648	; 0x4cc0
  1415f0:	f2c0 0115 	movt	r1, #21
  1415f4:	f2c0 0015 	movt	r0, #21
  1415f8:	2a00      	cmp	r2, #0
  1415fa:	bf08      	it	eq
  1415fc:	4619      	moveq	r1, r3
  1415fe:	f012 fd7b 	bl	1540f8 <_printf>
            break;
  141602:	e7ab      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "translation fault on %s\n", write ? "write" : "read");
  141604:	f644 4104 	movw	r1, #19460	; 0x4c04
  141608:	f644 430c 	movw	r3, #19468	; 0x4c0c
  14160c:	f2c0 0315 	movt	r3, #21
  141610:	f644 4044 	movw	r0, #19524	; 0x4c44
  141614:	f2c0 0115 	movt	r1, #21
  141618:	f2c0 0015 	movt	r0, #21
  14161c:	2a00      	cmp	r2, #0
  14161e:	bf08      	it	eq
  141620:	4619      	moveq	r1, r3
  141622:	f012 fd69 	bl	1540f8 <_printf>
            break;
  141626:	e799      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "access flag fault on %s\n", write ? "write" : "read");
  141628:	f644 4104 	movw	r1, #19460	; 0x4c04
  14162c:	f644 430c 	movw	r3, #19468	; 0x4c0c
  141630:	f2c0 0315 	movt	r3, #21
  141634:	f644 4060 	movw	r0, #19552	; 0x4c60
  141638:	f2c0 0115 	movt	r1, #21
  14163c:	f2c0 0015 	movt	r0, #21
  141640:	2a00      	cmp	r2, #0
  141642:	bf08      	it	eq
  141644:	4619      	moveq	r1, r3
  141646:	f012 fd57 	bl	1540f8 <_printf>
            break;
  14164a:	e787      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "debug event\n");
  14164c:	f644 40b0 	movw	r0, #19632	; 0x4cb0
  141650:	f2c0 0015 	movt	r0, #21
  141654:	f012 fd50 	bl	1540f8 <_printf>
            break;
  141658:	e780      	b.n	14155c <arm_data_abort_handler+0x98>
            dprintf(CRITICAL, "alignment fault on %s\n", write ? "write" : "read");
  14165a:	f644 4104 	movw	r1, #19460	; 0x4c04
  14165e:	f644 430c 	movw	r3, #19468	; 0x4c0c
  141662:	f2c0 0315 	movt	r3, #21
  141666:	f644 402c 	movw	r0, #19500	; 0x4c2c
  14166a:	f2c0 0115 	movt	r1, #21
  14166e:	f2c0 0015 	movt	r0, #21
  141672:	2a00      	cmp	r2, #0
  141674:	bf08      	it	eq
  141676:	4619      	moveq	r1, r3
  141678:	f012 fd3e 	bl	1540f8 <_printf>
            break;
  14167c:	e76e      	b.n	14155c <arm_data_abort_handler+0x98>
  14167e:	bf00      	nop

00141680 <arm_prefetch_abort_handler>:

void arm_prefetch_abort_handler(struct arm_fault_frame *frame)
{
  141680:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  141682:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(ifsr, 0, c5, c0, 1);
  141684:	ee15 5f30 	mrc	15, 0, r5, cr5, cr0, {1}
GEN_CP15_REG_FUNCS(ifar, 0, c6, c0, 2);
  141688:	ee16 7f50 	mrc	15, 0, r7, cr6, cr0, {2}
    uint32_t fsr = arm_read_ifsr();
    uint32_t far = arm_read_ifar();

    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);

    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
  14168c:	f644 5068 	movw	r0, #19816	; 0x4d68
    uint32_t fault_status = (BIT(fsr, 10) ? (1<<4) : 0) |  BITS(fsr, 3, 0);
  141690:	09ab      	lsrs	r3, r5, #6
  141692:	f003 0310 	and.w	r3, r3, #16
  141696:	f005 040f 	and.w	r4, r5, #15
  14169a:	431c      	orrs	r4, r3
    dprintf(CRITICAL, "\n\ncpu %u prefetch abort, ", arch_curr_cpu_num());
  14169c:	2100      	movs	r1, #0
  14169e:	f2c0 0015 	movt	r0, #21
  1416a2:	f012 fd29 	bl	1540f8 <_printf>

    /* decode the fault status (from table B3-23) */
    switch (fault_status) {
  1416a6:	1e63      	subs	r3, r4, #1
  1416a8:	2b15      	cmp	r3, #21
  1416aa:	d85a      	bhi.n	141762 <arm_prefetch_abort_handler+0xe2>
  1416ac:	e8df f003 	tbb	[r15, r3]
  1416b0:	59342d26 	.word	0x59342d26
  1416b4:	423b343b 	.word	0x423b343b
  1416b8:	59495949 	.word	0x59495949
  1416bc:	59525952 	.word	0x59525952
  1416c0:	59595959 	.word	0x59595959
  1416c4:	0b59      	.short	0x0b59
            break;
        case 0b01000: // synchronous external abort
            dprintf(CRITICAL, "synchronous external abort\n");
            break;
        case 0b10110: // asynchronous external abort
            dprintf(CRITICAL, "asynchronous external abort\n");
  1416c6:	f644 50f0 	movw	r0, #19952	; 0x4df0
  1416ca:	f2c0 0015 	movt	r0, #21
  1416ce:	f012 fd13 	bl	1540f8 <_printf>
        default:
            dprintf(CRITICAL, "unhandled fault\n");
            ;
    }

    dprintf(CRITICAL, "IFAR 0x%x (fault address)\n", far);
  1416d2:	f644 6010 	movw	r0, #19984	; 0x4e10
  1416d6:	4639      	mov	r1, r7
  1416d8:	f2c0 0015 	movt	r0, #21
  1416dc:	f012 fd0c 	bl	1540f8 <_printf>
    dprintf(CRITICAL, "IFSR 0x%x (fault status register)\n", fsr);
  1416e0:	f644 602c 	movw	r0, #20012	; 0x4e2c
  1416e4:	4629      	mov	r1, r5
  1416e6:	f2c0 0015 	movt	r0, #21
  1416ea:	f012 fd05 	bl	1540f8 <_printf>

    exception_die(frame, "halting\n");
  1416ee:	f644 515c 	movw	r1, #19804	; 0x4d5c
  1416f2:	4630      	mov	r0, r6
  1416f4:	f2c0 0115 	movt	r1, #21
  1416f8:	f7ff fe0e 	bl	141318 <exception_die>
            dprintf(CRITICAL, "alignment fault\n");
  1416fc:	f644 5084 	movw	r0, #19844	; 0x4d84
  141700:	f2c0 0015 	movt	r0, #21
  141704:	f012 fcf8 	bl	1540f8 <_printf>
            break;
  141708:	e7e3      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "debug event\n");
  14170a:	f644 40b0 	movw	r0, #19632	; 0x4cb0
  14170e:	f2c0 0015 	movt	r0, #21
  141712:	f012 fcf1 	bl	1540f8 <_printf>
            break;
  141716:	e7dc      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "access flag fault\n");
  141718:	f644 50ac 	movw	r0, #19884	; 0x4dac
  14171c:	f2c0 0015 	movt	r0, #21
  141720:	f012 fcea 	bl	1540f8 <_printf>
            break;
  141724:	e7d5      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "translation fault\n");
  141726:	f644 5098 	movw	r0, #19864	; 0x4d98
  14172a:	f2c0 0015 	movt	r0, #21
  14172e:	f012 fce3 	bl	1540f8 <_printf>
            break;
  141732:	e7ce      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "synchronous external abort\n");
  141734:	f644 50d4 	movw	r0, #19924	; 0x4dd4
  141738:	f2c0 0015 	movt	r0, #21
  14173c:	f012 fcdc 	bl	1540f8 <_printf>
            break;
  141740:	e7c7      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "domain fault, domain %lu\n", BITS_SHIFT(fsr, 7, 4));
  141742:	f644 407c 	movw	r0, #19580	; 0x4c7c
  141746:	f3c5 1103 	ubfx	r1, r5, #4, #4
  14174a:	f2c0 0015 	movt	r0, #21
  14174e:	f012 fcd3 	bl	1540f8 <_printf>
            break;
  141752:	e7be      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "permission fault\n");
  141754:	f644 50c0 	movw	r0, #19904	; 0x4dc0
  141758:	f2c0 0015 	movt	r0, #21
  14175c:	f012 fccc 	bl	1540f8 <_printf>
            break;
  141760:	e7b7      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>
            dprintf(CRITICAL, "unhandled fault\n");
  141762:	f644 5008 	movw	r0, #19720	; 0x4d08
  141766:	f2c0 0015 	movt	r0, #21
  14176a:	f012 fcc5 	bl	1540f8 <_printf>
  14176e:	e7b0      	b.n	1416d2 <arm_prefetch_abort_handler+0x52>

00141770 <arm_fpu_set_enable>:
}

void arm_fpu_set_enable(bool enable)
{
    /* set enable bit in fpexc */
    write_fpexc(enable ? (1<<30) : 0);
  141770:	2800      	cmp	r0, #0
  141772:	bf14      	ite	ne
  141774:	f04f 4380 	movne.w	r3, #1073741824	; 0x40000000
  141778:	2300      	moveq	r3, #0
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  14177a:	eee8 3a10 	vmsr	fpexc, r3
}
  14177e:	4770      	bx	r14

00141780 <arm_fpu_undefined_instruction>:

#if ARM_WITH_VFP
void arm_fpu_undefined_instruction(struct arm_iframe *frame)
{
  141780:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  141782:	4606      	mov	r6, r0
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  141784:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    return (ipsr & IPSR_ISR_Msk);
#else
    /* set by the interrupt glue to track that the cpu is inside a handler */
    extern bool __arm_in_handler;

    return __arm_in_handler;
  141788:	f249 04fc 	movw	r4, #37116	; 0x90fc
  14178c:	f2c0 0415 	movt	r4, #21
    thread_t *t = get_current_thread();

    if (unlikely(arch_in_int_handler())) {
  141790:	7823      	ldrb	r3, [r4, #0]
  141792:	b9b3      	cbnz	r3, 1417c2 <arm_fpu_undefined_instruction+0x42>
    }
false_alarm:

    LTRACEF("enabling fpu on thread %p\n", t);

    t->arch.fpused = true;
  141794:	2301      	movs	r3, #1
  141796:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34

            arm_fpu_set_enable(false);
        }
    }

    if (newthread) {
  14179a:	b16d      	cbz	r5, 1417b8 <arm_fpu_undefined_instruction+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  14179c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  1417a0:	eee8 3a10 	vmsr	fpexc, r3
        if (newthread->arch.fpused) {
            // load the new state
            arm_fpu_set_enable(true);
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
  1417a4:	6bab      	ldr	r3, [r5, #56]	; 0x38
  1417a6:	eee1 3a10 	vmsr	fpscr, r3

            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
  1417aa:	f105 0340 	add.w	r3, r5, #64	; 0x40
  1417ae:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  1417b2:	6beb      	ldr	r3, [r5, #60]	; 0x3c
  1417b4:	eee8 3a10 	vmsr	fpexc, r3
    frame->fpexc |= (1<<30);
  1417b8:	6833      	ldr	r3, [r6, #0]
  1417ba:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  1417be:	6033      	str	r3, [r6, #0]
}
  1417c0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(CRITICAL, "floating point code while some cpu is in irq context. pc 0x%x\n", frame->pc);
  1417c2:	f644 70c8 	movw	r0, #20424	; 0x4fc8
  1417c6:	4677      	mov	r7, r14
  1417c8:	6a71      	ldr	r1, [r6, #36]	; 0x24
  1417ca:	f2c0 0015 	movt	r0, #21
  1417ce:	f012 fc93 	bl	1540f8 <_printf>
        for (i = 0; i < 1000; i++) {
  1417d2:	2100      	movs	r1, #0
  1417d4:	7823      	ldrb	r3, [r4, #0]
            if (!arch_in_int_handler()) {
  1417d6:	b15b      	cbz	r3, 1417f0 <arm_fpu_undefined_instruction+0x70>
        for (i = 0; i < 1000; i++) {
  1417d8:	3101      	adds	r1, #1
  1417da:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
  1417de:	d1fa      	bne.n	1417d6 <arm_fpu_undefined_instruction+0x56>
        panic("floating point code in irq context. pc 0x%x\n", frame->pc);
  1417e0:	f245 013c 	movw	r1, #20540	; 0x503c
  1417e4:	4638      	mov	r0, r7
  1417e6:	6a72      	ldr	r2, [r6, #36]	; 0x24
  1417e8:	f2c0 0115 	movt	r1, #21
  1417ec:	f011 fa62 	bl	152cb4 <_panic>
                dprintf(CRITICAL, "arch_in_int_handler status cleared after %d reads\n", i);
  1417f0:	f245 0008 	movw	r0, #20488	; 0x5008
  1417f4:	f2c0 0015 	movt	r0, #21
  1417f8:	f012 fc7e 	bl	1540f8 <_printf>
                goto false_alarm;
  1417fc:	e7ca      	b.n	141794 <arm_fpu_undefined_instruction+0x14>
  1417fe:	bf00      	nop

00141800 <arm_fpu_thread_initialize>:
{
  141800:	b510      	push	{r4, r14}
    memset(t->arch.fpregs, 0, sizeof(t->arch.fpregs));
  141802:	f44f 7280 	mov.w	r2, #256	; 0x100
{
  141806:	4604      	mov	r4, r0
    memset(t->arch.fpregs, 0, sizeof(t->arch.fpregs));
  141808:	2100      	movs	r1, #0
  14180a:	3040      	adds	r0, #64	; 0x40
  14180c:	f011 ec36 	blx	15307c <memset>
    t->arch.fpscr = 0;
  141810:	2300      	movs	r3, #0
  141812:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    t->arch.fpused = false;
  141816:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    t->arch.fpscr = 0;
  14181a:	e9c4 320e 	strd	r3, r2, [r4, #56]	; 0x38
}
  14181e:	bd10      	pop	{r4, r15}

00141820 <arm_fpu_thread_swap>:
    if (oldthread) {
  141820:	b110      	cbz	r0, 141828 <arm_fpu_thread_swap+0x8>
        if (oldthread->arch.fpused) {
  141822:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
  141826:	b933      	cbnz	r3, 141836 <arm_fpu_thread_swap+0x16>
    if (newthread) {
  141828:	b121      	cbz	r1, 141834 <arm_fpu_thread_swap+0x14>
        if (newthread->arch.fpused) {
  14182a:	f891 3034 	ldrb.w	r3, [r1, #52]	; 0x34
  14182e:	b99b      	cbnz	r3, 141858 <arm_fpu_thread_swap+0x38>
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  141830:	eee8 3a10 	vmsr	fpexc, r3
            write_fpexc(newthread->arch.fpexc);
        } else {
            arm_fpu_set_enable(false);
        }
    }
}
  141834:	4770      	bx	r14
    __asm__("mrc  p10, 7, %0, c8, c0, 0" : "=r" (val));
  141836:	eef8 2a10 	vmrs	r2, fpexc
            oldthread->arch.fpexc = fpexc;
  14183a:	63c2      	str	r2, [r0, #60]	; 0x3c
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  14183c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  141840:	eee8 3a10 	vmsr	fpexc, r3
            __asm__ volatile("vmrs  %0, fpscr" : "=r" (oldthread->arch.fpscr));
  141844:	eef1 3a10 	vmrs	r3, fpscr
  141848:	6383      	str	r3, [r0, #56]	; 0x38
            __asm__ volatile("vstm   %0, { d0-d15 }" :: "r" (&oldthread->arch.fpregs[0]));
  14184a:	3040      	adds	r0, #64	; 0x40
  14184c:	ec80 0b20 	vstmia	r0, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  141850:	2300      	movs	r3, #0
  141852:	eee8 3a10 	vmsr	fpexc, r3
  141856:	e7e7      	b.n	141828 <arm_fpu_thread_swap+0x8>
  141858:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  14185c:	eee8 3a10 	vmsr	fpexc, r3
            __asm__ volatile("vmsr  fpscr, %0" :: "r" (newthread->arch.fpscr));
  141860:	6b8b      	ldr	r3, [r1, #56]	; 0x38
  141862:	eee1 3a10 	vmsr	fpscr, r3
            __asm__ volatile("vldm   %0, { d0-d15 }" :: "r" (&newthread->arch.fpregs[0]));
  141866:	f101 0340 	add.w	r3, r1, #64	; 0x40
  14186a:	ec93 0b20 	vldmia	r3, {d0-d15}
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r" (val));
  14186e:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
  141870:	eee8 3a10 	vmsr	fpexc, r3
  141874:	4770      	bx	r14
  141876:	bf00      	nop

00141878 <initial_thread_func>:

extern void arm_context_switch(addr_t *old_sp, addr_t new_sp);

static void initial_thread_func(void) __NO_RETURN;
static void initial_thread_func(void)
{
  141878:	b508      	push	{r3, r14}
    return 0;
}

static inline void arch_spin_unlock(spin_lock_t *lock)
{
    *lock = 0;
  14187a:	f246 53c0 	movw	r3, #26048	; 0x65c0
  14187e:	2200      	movs	r2, #0
  141880:	f2c0 0316 	movt	r3, #22
  141884:	601a      	str	r2, [r3, #0]
    __asm__ volatile("cpsie i");
  141886:	b662      	cpsie	i
  141888:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    /* release the thread lock that was implicitly held across the reschedule */
    spin_unlock(&thread_lock);
    arch_enable_ints();

    thread_t *ct = get_current_thread();
    ret = ct->entry(ct->arg);
  14188c:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
  141890:	f8d3 014c 	ldr.w	r0, [r3, #332]	; 0x14c
  141894:	4790      	blx	r2

//  dprintf("initial_thread_func: thread %p exiting with %d\n", current_thread, ret);

    thread_exit(ret);
  141896:	f00e fa41 	bl	14fd1c <thread_exit>
  14189a:	bf00      	nop

0014189c <arch_thread_initialize>:
}

void arch_thread_initialize(thread_t *t)
{
  14189c:	b570      	push	{r4, r5, r6, r14}
    // create a default stack frame on the stack
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
  14189e:	f8d0 3144 	ldr.w	r3, [r0, #324]	; 0x144
{
  1418a2:	4605      	mov	r5, r0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
  1418a4:	f8d0 4140 	ldr.w	r4, [r0, #320]	; 0x140

    struct context_switch_frame *frame = (struct context_switch_frame *)(stack_top);
    frame--;

    // fill it in
    memset(frame, 0, sizeof(*frame));
  1418a8:	2224      	movs	r2, #36	; 0x24
  1418aa:	2100      	movs	r1, #0
    vaddr_t stack_top = (vaddr_t)t->stack + t->stack_size;
  1418ac:	441c      	add	r4, r3
    stack_top = ROUNDDOWN(stack_top, 8);
  1418ae:	f024 0407 	bic.w	r4, r4, #7
    frame--;
  1418b2:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
    memset(frame, 0, sizeof(*frame));
  1418b6:	4630      	mov	r0, r6
  1418b8:	f011 ebe0 	blx	15307c <memset>
    frame->lr = (vaddr_t)&initial_thread_func;
  1418bc:	f641 0379 	movw	r3, #6265	; 0x1879

    // set the stack pointer
    t->arch.sp = (vaddr_t)frame;

#if ARM_WITH_VFP
    arm_fpu_thread_initialize(t);
  1418c0:	4628      	mov	r0, r5
    frame->lr = (vaddr_t)&initial_thread_func;
  1418c2:	f2c0 0314 	movt	r3, #20
  1418c6:	f844 3c04 	str.w	r3, [r4, #-4]
    t->arch.sp = (vaddr_t)frame;
  1418ca:	632e      	str	r6, [r5, #48]	; 0x30
#endif
}
  1418cc:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    arm_fpu_thread_initialize(t);
  1418d0:	f7ff bf96 	b.w	141800 <arm_fpu_thread_initialize>

001418d4 <arch_context_switch>:

void arch_context_switch(thread_t *oldthread, thread_t *newthread)
{
  1418d4:	b538      	push	{r3, r4, r5, r14}
  1418d6:	460c      	mov	r4, r1
  1418d8:	4605      	mov	r5, r0
//  TRACEF("arch_context_switch: cpu %u old %p (%s), new %p (%s)\n", arch_curr_cpu_num(), oldthread, oldthread->name, newthread, newthread->name);
#if ARM_WITH_VFP
    arm_fpu_thread_swap(oldthread, newthread);
  1418da:	f7ff ffa1 	bl	141820 <arm_fpu_thread_swap>
#endif

    arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
  1418de:	f105 0030 	add.w	r0, r5, #48	; 0x30
  1418e2:	6b21      	ldr	r1, [r4, #48]	; 0x30
}
  1418e4:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    arm_context_switch(&oldthread->arch.sp, newthread->arch.sp);
  1418e8:	f013 b8e6 	b.w	154ab8 <__arm_context_switch_from_thumb>

001418ec <mpu_add_region>:
}
#endif
void mpu_add_region(int region, uint32_t base, uint32_t size,
                    mpu_region_type_e type)
{
    ASSERT(region >= 0 && region < mpu_region_nr());
  1418ec:	2800      	cmp	r0, #0
{
  1418ee:	b510      	push	{r4, r14}
  1418f0:	b082      	sub	sp, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
  1418f2:	db39      	blt.n	141968 <mpu_add_region+0x7c>

GEN_CP15_REG_FUNCS(l2ctlr, 1, c9, c0, 2);
GEN_CP15_REG_FUNCS(l2ectlr, 1, c9, c0, 3);

/* mpu registers (using unified memory regions) */
GEN_CP15_REG_FUNCS(mpuir, 0, c0, c0, 4);
  1418f4:	ee10 4f90 	mrc	15, 0, r4, cr0, cr0, {4}
    return (int)BITS_SHIFT(val, 15, 8);   /* 0, 12 or 16 */
  1418f8:	f3c4 2407 	ubfx	r4, r4, #8, #8
    ASSERT(region >= 0 && region < mpu_region_nr());
  1418fc:	42a0      	cmp	r0, r4
  1418fe:	da33      	bge.n	141968 <mpu_add_region+0x7c>
    ASSERT((size & (size - 1)) == 0 &&
  141900:	1e54      	subs	r4, r2, #1
  141902:	4214      	tst	r4, r2
  141904:	bf14      	ite	ne
  141906:	2401      	movne	r4, #1
  141908:	2400      	moveq	r4, #0
  14190a:	2a1f      	cmp	r2, #31
  14190c:	bf98      	it	ls
  14190e:	f044 0401 	orrls.w	r4, r4, #1
  141912:	bbd4      	cbnz	r4, 14198a <mpu_add_region+0x9e>
           size >= 32ull &&
           size <= 4ull * 1024 * 1024 * 1024);
    ASSERT(base % size == 0);
  141914:	fbb1 f4f2 	udiv	r4, r1, r2
  141918:	fb02 1414 	mls	r4, r2, r4, r1
  14191c:	2c00      	cmp	r4, #0
  14191e:	d145      	bne.n	1419ac <mpu_add_region+0xc0>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  141920:	2b04      	cmp	r3, #4
  141922:	d854      	bhi.n	1419ce <mpu_add_region+0xe2>
    return sizeof(val) * 8 - 1 - __builtin_clzll(val);
  141924:	fab2 f282 	clz	r2, r2
  141928:	3220      	adds	r2, #32
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
GEN_CP15_REG_FUNCS(rgnr, 0, c6, c2, 0);
  14192a:	ee06 0f12 	mcr	15, 0, r0, cr6, cr2, {0}
  14192e:	f3bf 8f6f 	isb	sy
    /* Calculate size field of RSR register.
     *  pow(2, sz + 1) = size
     */
    uint32_t sz = (uint32_t)log2ull(size) - 1;
    arm_write_rgnr(region);
    arm_write_rbar(base & MPU_RBAR_MASK);
  141932:	f021 011f 	bic.w	r1, r1, #31
GEN_CP15_REG_FUNCS(rbar, 0, c6, c1, 0);
  141936:	ee06 1f11 	mcr	15, 0, r1, cr6, cr1, {0}
  14193a:	f3bf 8f6f 	isb	sy
    arm_write_racr(g_racr_config[type]);
  14193e:	f245 016c 	movw	r1, #20588	; 0x506c
  141942:	f2c0 0115 	movt	r1, #21
GEN_CP15_REG_FUNCS(racr, 0, c6, c1, 4);
  141946:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  14194a:	ee06 3f91 	mcr	15, 0, r3, cr6, cr1, {4}
  14194e:	f3bf 8f6f 	isb	sy
    uint32_t sz = (uint32_t)log2ull(size) - 1;
  141952:	f1c2 033e 	rsb	r3, r2, #62	; 0x3e
    /* TODO - support sub regions? */
    arm_write_rsr((sz << RSR_SIZE_SHIFT) | RSR_EN);
  141956:	005b      	lsls	r3, r3, #1
  141958:	f043 0301 	orr.w	r3, r3, #1
GEN_CP15_REG_FUNCS(rsr, 0, c6, c1, 2);
  14195c:	ee06 3f51 	mcr	15, 0, r3, cr6, cr1, {2}
  141960:	f3bf 8f6f 	isb	sy
    if (type != MPU_REGION_NORMAL) {
        add_region(base, size);
    }

#endif
}
  141964:	b002      	add	sp, #8
  141966:	bd10      	pop	{r4, r15}
    ASSERT(region >= 0 && region < mpu_region_nr());
  141968:	f245 0398 	movw	r3, #20632	; 0x5098
  14196c:	f245 0280 	movw	r2, #20608	; 0x5080
  141970:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141974:	f2c0 0315 	movt	r3, #21
  141978:	4670      	mov	r0, r14
  14197a:	f2c0 0215 	movt	r2, #21
  14197e:	9300      	str	r3, [sp, #0]
  141980:	f2c0 0115 	movt	r1, #21
  141984:	2394      	movs	r3, #148	; 0x94
  141986:	f011 f995 	bl	152cb4 <_panic>
    ASSERT((size & (size - 1)) == 0 &&
  14198a:	f245 03c0 	movw	r3, #20672	; 0x50c0
  14198e:	f245 0280 	movw	r2, #20608	; 0x5080
  141992:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141996:	f2c0 0315 	movt	r3, #21
  14199a:	4670      	mov	r0, r14
  14199c:	f2c0 0215 	movt	r2, #21
  1419a0:	9300      	str	r3, [sp, #0]
  1419a2:	f2c0 0115 	movt	r1, #21
  1419a6:	2397      	movs	r3, #151	; 0x97
  1419a8:	f011 f984 	bl	152cb4 <_panic>
    ASSERT(base % size == 0);
  1419ac:	f245 1310 	movw	r3, #20752	; 0x5110
  1419b0:	f245 0280 	movw	r2, #20608	; 0x5080
  1419b4:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1419b8:	f2c0 0315 	movt	r3, #21
  1419bc:	4670      	mov	r0, r14
  1419be:	f2c0 0215 	movt	r2, #21
  1419c2:	9300      	str	r3, [sp, #0]
  1419c4:	f2c0 0115 	movt	r1, #21
  1419c8:	2398      	movs	r3, #152	; 0x98
  1419ca:	f011 f973 	bl	152cb4 <_panic>
    ASSERT(type >= MPU_REGION_STRONGORDERED && type < MPU_REGION_MAX);
  1419ce:	f245 1324 	movw	r3, #20772	; 0x5124
  1419d2:	f245 0280 	movw	r2, #20608	; 0x5080
  1419d6:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1419da:	f2c0 0315 	movt	r3, #21
  1419de:	4670      	mov	r0, r14
  1419e0:	f2c0 0215 	movt	r2, #21
  1419e4:	9300      	str	r3, [sp, #0]
  1419e6:	f2c0 0115 	movt	r1, #21
  1419ea:	2399      	movs	r3, #153	; 0x99
  1419ec:	f011 f962 	bl	152cb4 <_panic>

001419f0 <mpu_enable>:
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
  1419f0:	ee11 3f10 	mrc	15, 0, r3, cr1, cr0, {0}
 */
void mpu_enable(bool enable)
{
    uint32_t val = arm_read_sctlr();

    if (enable)
  1419f4:	b930      	cbnz	r0, 141a04 <mpu_enable+0x14>
         */
    {
        val |= SCTLR_BR | SCTLR_M;
    }
    else {
        val &= ~SCTLR_M;
  1419f6:	f023 0301 	bic.w	r3, r3, #1
  1419fa:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  1419fe:	f3bf 8f6f 	isb	sy
    }

    arm_write_sctlr(val);
}
  141a02:	4770      	bx	r14
        val |= SCTLR_BR | SCTLR_M;
  141a04:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  141a08:	f043 0301 	orr.w	r3, r3, #1
  141a0c:	ee01 3f10 	mcr	15, 0, r3, cr1, cr0, {0}
  141a10:	f3bf 8f6f 	isb	sy
}
  141a14:	4770      	bx	r14
  141a16:	bf00      	nop

00141a18 <tcm_get_size>:
/**
 * @brief Get TCM size in bytes.
 */
void tcm_get_size(size_t *atcm_size, size_t *btcm_size)
{
    ASSERT(atcm_size && btcm_size);
  141a18:	2900      	cmp	r1, #0
  141a1a:	bf18      	it	ne
  141a1c:	2800      	cmpne	r0, #0
{
  141a1e:	b510      	push	{r4, r14}
  141a20:	b082      	sub	sp, #8
    ASSERT(atcm_size && btcm_size);
  141a22:	d012      	beq.n	141a4a <tcm_get_size+0x32>
GEN_CP15_REG_FUNCS(pmxevcntr, 0, c9, c13, 2);

/* TCM registers */
GEN_CP15_REG_FUNCS(tcmtr, 0, c0, c0, 2);
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
GEN_CP15_REG_FUNCS(atcmrgn, 0, c9, c1, 1);
  141a24:	ee19 3f31 	mrc	15, 0, r3, cr9, cr1, {1}
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
  141a28:	ee19 2f11 	mrc	15, 0, r2, cr9, cr1, {0}

    uint32_t asize = BITS_SHIFT(arm_read_atcmrgn(), 6, 2);
    uint32_t bsize = BITS_SHIFT(arm_read_btcmrgn(), 6, 2);

    *atcm_size = 1 << (asize + 9);
  141a2c:	2401      	movs	r4, #1
    uint32_t asize = BITS_SHIFT(arm_read_atcmrgn(), 6, 2);
  141a2e:	f3c3 0384 	ubfx	r3, r3, #2, #5
    uint32_t bsize = BITS_SHIFT(arm_read_btcmrgn(), 6, 2);
  141a32:	f3c2 0284 	ubfx	r2, r2, #2, #5
    *atcm_size = 1 << (asize + 9);
  141a36:	3309      	adds	r3, #9
    *btcm_size = 1 << (bsize + 9);
  141a38:	3209      	adds	r2, #9
    *atcm_size = 1 << (asize + 9);
  141a3a:	fa04 f303 	lsl.w	r3, r4, r3
    *btcm_size = 1 << (bsize + 9);
  141a3e:	fa04 f202 	lsl.w	r2, r4, r2
    *atcm_size = 1 << (asize + 9);
  141a42:	6003      	str	r3, [r0, #0]
    *btcm_size = 1 << (bsize + 9);
  141a44:	600a      	str	r2, [r1, #0]
}
  141a46:	b002      	add	sp, #8
  141a48:	bd10      	pop	{r4, r15}
    ASSERT(atcm_size && btcm_size);
  141a4a:	f245 13c0 	movw	r3, #20928	; 0x51c0
  141a4e:	f245 12a8 	movw	r2, #20904	; 0x51a8
  141a52:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141a56:	f2c0 0315 	movt	r3, #21
  141a5a:	4670      	mov	r0, r14
  141a5c:	f2c0 0215 	movt	r2, #21
  141a60:	9300      	str	r3, [sp, #0]
  141a62:	f2c0 0115 	movt	r1, #21
  141a66:	232d      	movs	r3, #45	; 0x2d
  141a68:	f011 f924 	bl	152cb4 <_panic>

00141a6c <tcm_enable>:

/**
 * @brief Enable the TCM.
 */
void tcm_enable(uint32_t atcm_base, uint32_t btcm_base, bool enable_ecc)
{
  141a6c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  141a70:	4677      	mov	r7, r14
  141a72:	b084      	sub	sp, #16
  141a74:	4604      	mov	r4, r0
  141a76:	460d      	mov	r5, r1
  141a78:	4690      	mov	r8, r2
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  141a7a:	ee11 6f30 	mrc	15, 0, r6, cr1, cr0, {1}
    size_t      atcm_size, btcm_size;
    uint32_t    actlr = arm_read_actlr();

    /* Disable ECC by default */
    actlr &= ~(ATCMPCEN | B0TCMPCEN | B1TCMPCEN);
  141a7e:	f026 6660 	bic.w	r6, r6, #234881024	; 0xe000000
  141a82:	ee01 6f30 	mcr	15, 0, r6, cr1, cr0, {1}
  141a86:	f3bf 8f6f 	isb	sy
    arm_write_actlr(actlr);

    /* Get TCM size. */
    tcm_get_size(&atcm_size, &btcm_size);
  141a8a:	a903      	add	r1, sp, #12
  141a8c:	a802      	add	r0, sp, #8
  141a8e:	f7ff ffc3 	bl	141a18 <tcm_get_size>

    /* Update TCM base address. */
    if (atcm_size != 0) {
  141a92:	9b02      	ldr	r3, [sp, #8]
  141a94:	b143      	cbz	r3, 141aa8 <tcm_enable+0x3c>
        ASSERT(IS_ALIGNED(atcm_base, atcm_size));
  141a96:	3b01      	subs	r3, #1
  141a98:	4223      	tst	r3, r4
  141a9a:	d130      	bne.n	141afe <tcm_enable+0x92>
        arm_write_atcmrgn(atcm_base | 1);
  141a9c:	f044 0301 	orr.w	r3, r4, #1
GEN_CP15_REG_FUNCS(atcmrgn, 0, c9, c1, 1);
  141aa0:	ee09 3f31 	mcr	15, 0, r3, cr9, cr1, {1}
  141aa4:	f3bf 8f6f 	isb	sy
    }

    if (btcm_size != 0) {
  141aa8:	9b03      	ldr	r3, [sp, #12]
  141aaa:	b143      	cbz	r3, 141abe <tcm_enable+0x52>
        ASSERT(IS_ALIGNED(btcm_base, btcm_size));
  141aac:	3b01      	subs	r3, #1
  141aae:	422b      	tst	r3, r5
  141ab0:	d136      	bne.n	141b20 <tcm_enable+0xb4>
        arm_write_btcmrgn(btcm_base | 1);
  141ab2:	f045 0301 	orr.w	r3, r5, #1
GEN_CP15_REG_FUNCS(btcmrgn, 0, c9, c1, 0);
  141ab6:	ee09 3f11 	mcr	15, 0, r3, cr9, cr1, {0}
  141aba:	f3bf 8f6f 	isb	sy
    }

    if (enable_ecc) {
  141abe:	f1b8 0f00 	cmp.w	r8, #0
  141ac2:	d019      	beq.n	141af8 <tcm_enable+0x8c>
    for (addr = base; addr < base + size; addr += 8) {
  141ac4:	9a02      	ldr	r2, [sp, #8]
  141ac6:	4422      	add	r2, r4
  141ac8:	42a2      	cmp	r2, r4
  141aca:	d905      	bls.n	141ad8 <tcm_enable+0x6c>
        __asm__ volatile(
  141acc:	2300      	movs	r3, #0
  141ace:	e9c4 3300 	strd	r3, r3, [r4]
    for (addr = base; addr < base + size; addr += 8) {
  141ad2:	3408      	adds	r4, #8
  141ad4:	42a2      	cmp	r2, r4
  141ad6:	d8fa      	bhi.n	141ace <tcm_enable+0x62>
  141ad8:	9a03      	ldr	r2, [sp, #12]
  141ada:	442a      	add	r2, r5
  141adc:	42aa      	cmp	r2, r5
  141ade:	d905      	bls.n	141aec <tcm_enable+0x80>
        __asm__ volatile(
  141ae0:	2300      	movs	r3, #0
  141ae2:	e9c5 3300 	strd	r3, r3, [r5]
    for (addr = base; addr < base + size; addr += 8) {
  141ae6:	3508      	adds	r5, #8
  141ae8:	42aa      	cmp	r2, r5
  141aea:	d8fa      	bhi.n	141ae2 <tcm_enable+0x76>
         */
        tcm_clear(atcm_base, atcm_size);
        tcm_clear(btcm_base, btcm_size);

        /* Enable ECC.  */
        actlr |= ATCMPCEN | B0TCMPCEN | B1TCMPCEN;
  141aec:	f046 6660 	orr.w	r6, r6, #234881024	; 0xe000000
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  141af0:	ee01 6f30 	mcr	15, 0, r6, cr1, cr0, {1}
  141af4:	f3bf 8f6f 	isb	sy
        arm_write_actlr(actlr);
    }
}
  141af8:	b004      	add	sp, #16
  141afa:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        ASSERT(IS_ALIGNED(atcm_base, atcm_size));
  141afe:	f245 1360 	movw	r3, #20832	; 0x5160
  141b02:	f245 12a8 	movw	r2, #20904	; 0x51a8
  141b06:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141b0a:	f2c0 0315 	movt	r3, #21
  141b0e:	4638      	mov	r0, r7
  141b10:	f2c0 0215 	movt	r2, #21
  141b14:	9300      	str	r3, [sp, #0]
  141b16:	f2c0 0115 	movt	r1, #21
  141b1a:	2347      	movs	r3, #71	; 0x47
  141b1c:	f011 f8ca 	bl	152cb4 <_panic>
        ASSERT(IS_ALIGNED(btcm_base, btcm_size));
  141b20:	f245 1384 	movw	r3, #20868	; 0x5184
  141b24:	f245 12a8 	movw	r2, #20904	; 0x51a8
  141b28:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141b2c:	f2c0 0315 	movt	r3, #21
  141b30:	4638      	mov	r0, r7
  141b32:	f2c0 0215 	movt	r2, #21
  141b36:	9300      	str	r3, [sp, #0]
  141b38:	f2c0 0115 	movt	r1, #21
  141b3c:	234c      	movs	r3, #76	; 0x4c
  141b3e:	f011 f8b9 	bl	152cb4 <_panic>
  141b42:	bf00      	nop

00141b44 <arch_clean_cache_range>:
        if(!aligncheck(start, len)) \
            panic("ASSERT FAILED at aligncheck in %s (%p:%d, caller %p)\n", __func__, (void*)start, len, __GET_CALLER());   \
        _f##_asm(start, len);   \
    }

CACHE_OPS(arch_clean_cache_range)
  141b44:	eafffc28 	b	140bec <arch_clean_cache_range_asm>

00141b48 <arch_invalidate_cache_range>:
CACHE_OPS(arch_clean_invalidate_cache_range)
CACHE_OPS(arch_invalidate_cache_range)
  141b48:	eafffc39 	b	140c34 <arch_invalidate_cache_range_asm>

00141b4c <arch_early_init>:
CACHE_OPS(arch_sync_cache_range)

void arch_early_init(void)
{
  141b4c:	e92d4010 	push	{r4, r14}
    /* turn off the cache */
    arch_disable_cache(UCACHE);
  141b50:	e3a00003 	mov	r0, #3
  141b54:	ebfffbac 	bl	140a0c <arch_disable_cache>
GEN_CP15_REG_FUNCS(sctlr, 0, c1, c0, 0);
  141b58:	ee112f10 	mrc	15, 0, r2, cr1, cr0, {0}
    sctlr |= (1 << 11); /* enable program flow prediction */
    sctlr &= ~(1 << 14); /* random cache/tlb replacement */
    sctlr &= ~(1 << 25); /* E bit set to 0 on exception */
    sctlr &= ~(1 << 30); /* no thumb exceptions */
    sctlr |= (1 << 22); /* enable unaligned access */
    sctlr &= ~(1 << 1); /* disable alignment abort */
  141b5c:	e30b3bfd 	movw	r3, #48125	; 0xbbfd
  141b60:	e34b3dff 	movt	r3, #48639	; 0xbdff
  141b64:	e0033002 	and	r3, r3, r2
  141b68:	e3833501 	orr	r3, r3, #4194304	; 0x400000
  141b6c:	e3833b02 	orr	r3, r3, #2048	; 0x800
  141b70:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
  141b74:	f57ff06f 	isb	sy
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  141b78:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
  141b7c:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
  141b80:	f57ff06f 	isb	sy
#endif // ARM_CPU_CORTEX_A7
    arm_write_actlr(actlr);
#if ENABLE_CYCLE_COUNTER && ARM_ISA_ARMV7
    /* enable the cycle count register */
    uint32_t en;
    __asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r"(en));
  141b84:	ee193f1c 	mrc	15, 0, r3, cr9, cr12, {0}
    en &= ~(1 << 3); /* cycle count every cycle */
  141b88:	e3c33008 	bic	r3, r3, #8
    en |= 1; /* enable all performance counters */
  141b8c:	e3833001 	orr	r3, r3, #1
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r"(en));
  141b90:	ee093f1c 	mcr	15, 0, r3, cr9, cr12, {0}
    /* enable cycle counter */
    en = (1 << 31);
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r"(en));
  141b94:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
  141b98:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
GEN_CP15_REG_FUNCS(cpacr, 0, c1, c0, 2);
  141b9c:	ee113f50 	mrc	15, 0, r3, cr1, cr0, {2}
#endif
#if ARM_WITH_VFP
    /* enable cp10 and cp11 */
    uint32_t val = arm_read_cpacr();
    val |= (3 << 22) | (3 << 20);
  141ba0:	e383360f 	orr	r3, r3, #15728640	; 0xf00000
  141ba4:	ee013f50 	mcr	15, 0, r3, cr1, cr0, {2}
  141ba8:	f57ff06f 	isb	sy
    arm_write_cpacr(val);
    /* set enable bit in fpexc */
    __asm__ volatile("mrc  p10, 7, %0, c8, c0, 0" : "=r"(val));
  141bac:	eef83a10 	vmrs	r3, fpexc
    val |= (1 << 30);
  141bb0:	e3833101 	orr	r3, r3, #1073741824	; 0x40000000
    __asm__ volatile("mcr  p10, 7, %0, c8, c0, 0" :: "r"(val));
  141bb4:	eee83a10 	vmsr	fpexc, r3
    /* make sure the fpu starts off disabled */
    arm_fpu_set_enable(false);
  141bb8:	e3a00000 	mov	r0, #0
  141bbc:	fafffeeb 	blx	141770 <arm_fpu_set_enable>
    arch_enable_cache(UCACHE);
  141bc0:	e3a00003 	mov	r0, #3
}
  141bc4:	e8bd4010 	pop	{r4, r14}
    arch_enable_cache(UCACHE);
  141bc8:	eafffba6 	b	140a68 <arch_enable_cache>

00141bcc <arch_init>:
}
  141bcc:	e12fff1e 	bx	r14

00141bd0 <arch_chain_load>:
}
#endif

void arch_chain_load(void *entry, ulong arg0, ulong arg1, ulong arg2,
                     ulong arg3)
{
  141bd0:	e92d4080 	push	{r7, r14}
  141bd4:	e1a04000 	mov	r4, r0
  141bd8:	e24dd008 	sub	r13, r13, #8
  141bdc:	e1a05001 	mov	r5, r1
  141be0:	e1a06002 	mov	r6, r2
  141be4:	e1a07003 	mov	r7, r3
  141be8:	e59d8010 	ldr	r8, [r13, #16]
    __asm__ volatile("cpsid i");
  141bec:	f10c0080 	cpsid	i
    /* we are going to shut down the system, start by disabling interrupts */
    arch_disable_ints();
    /* give target and platform a chance to put hardware into a suitable
     * state for chain loading.
     */
    target_quiesce();
  141bf0:	fafff992 	blx	140240 <target_quiesce>
    platform_quiesce();
  141bf4:	fa003afb 	blx	1507e8 <platform_quiesce>
    /* for non vm case, just branch directly into it */
    entry_pa = (paddr_t)entry;
    loader_pa = (paddr_t)&arm_chain_load;
#endif
    LTRACEF("disabling instruction/data cache\n");
    arch_disable_cache(UCACHE);
  141bf8:	e3a00003 	mov	r0, #3
  141bfc:	ebfffb82 	bl	140a0c <arch_disable_cache>
    __asm__ volatile("mrc	p15, 0, %0, c9, c12, 0" : "=r"(en));
  141c00:	ee190f1c 	mrc	15, 0, r0, cr9, cr12, {0}
    en &= ~1; /* disable all performance counters */
  141c04:	e3c00001 	bic	r0, r0, #1
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 0" :: "r"(en));
  141c08:	ee090f1c 	mcr	15, 0, r0, cr9, cr12, {0}
    __asm__ volatile("mcr	p15, 0, %0, c9, c12, 1" :: "r"(en));
  141c0c:	e3a03000 	mov	r3, #0
  141c10:	ee093f3c 	mcr	15, 0, r3, cr9, cr12, {1}
GEN_CP15_REG_FUNCS(actlr, 0, c1, c0, 1);
  141c14:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
  141c18:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
  141c1c:	f57ff06f 	isb	sy
    arch_quiesce();
    LTRACEF("branching to physical address of loader\n");
    /* branch to the physical address version of the chain loader routine */
    void (*loader)(paddr_t entry, ulong, ulong, ulong,
                   ulong) __NO_RETURN = (void *)loader_pa;
    loader(entry_pa, arg0, arg1, arg2, arg3);
  141c20:	e58d8000 	str	r8, [r13]
  141c24:	e1a03007 	mov	r3, r7
  141c28:	e1a02006 	mov	r2, r6
  141c2c:	e1a01005 	mov	r1, r5
  141c30:	e1a00004 	mov	r0, r4
  141c34:	ebfffb6e 	bl	1409f4 <arm_chain_load>

00141c38 <lk_init_level>:

extern const struct lk_init_struct __lk_init[];
extern const struct lk_init_struct __lk_init_end[];

void lk_init_level(enum lk_init_flags required_flag, uint start_level, uint stop_level)
{
  141c38:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  141c3c:	b083      	sub	sp, #12
    LTRACEF("flags %#x, start_level %#x, stop_level %#x\n",
            required_flag, start_level, stop_level);

    ASSERT(start_level > 0);
  141c3e:	2900      	cmp	r1, #0
  141c40:	d051      	beq.n	141ce6 <lk_init_level+0xae>
  141c42:	f648 187c 	movw	r8, #35196	; 0x897c
  141c46:	f648 16fc 	movw	r6, #35324	; 0x89fc
  141c4a:	f2c0 0815 	movt	r8, #21
  141c4e:	4691      	mov	r9, r2
  141c50:	f2c0 0615 	movt	r6, #21
  141c54:	4683      	mov	r11, r0
        /* search for the lowest uncalled hook to call */
        LTRACEF("last %p, last_called_level %#x\n", last, last_called_level);

        const struct lk_init_struct *found = NULL;
        bool seen_last = false;
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  141c56:	45b0      	cmp	r8, r6
  141c58:	468a      	mov	r10, r1
    uint last_called_level = start_level - 1;
  141c5a:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
    const struct lk_init_struct *last = NULL;
  141c5e:	f04f 0500 	mov.w	r5, #0
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  141c62:	d03b      	beq.n	141cdc <lk_init_level+0xa4>
  141c64:	f648 137c 	movw	r3, #35196	; 0x897c
        bool seen_last = false;
  141c68:	2400      	movs	r4, #0
        const struct lk_init_struct *found = NULL;
  141c6a:	4621      	mov	r1, r4
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  141c6c:	f2c0 0315 	movt	r3, #21
  141c70:	e002      	b.n	141c78 <lk_init_level+0x40>
  141c72:	3310      	adds	r3, #16
  141c74:	42b3      	cmp	r3, r6
  141c76:	d029      	beq.n	141ccc <lk_init_level+0x94>

            if (ptr == last)
                seen_last = true;

            /* reject the easy ones */
            if (!(ptr->flags & required_flag))
  141c78:	6858      	ldr	r0, [r3, #4]
                seen_last = true;
  141c7a:	429d      	cmp	r5, r3
  141c7c:	bf08      	it	eq
  141c7e:	2401      	moveq	r4, #1
            if (!(ptr->flags & required_flag))
  141c80:	ea1b 0f00 	tst.w	r11, r0
  141c84:	d0f5      	beq.n	141c72 <lk_init_level+0x3a>
                continue;
            if (ptr->level > stop_level)
  141c86:	6818      	ldr	r0, [r3, #0]
                continue;
            if (ptr->level < last_called_level)
  141c88:	4548      	cmp	r0, r9
  141c8a:	bf98      	it	ls
  141c8c:	4282      	cmpls	r2, r0
  141c8e:	d8f0      	bhi.n	141c72 <lk_init_level+0x3a>
                continue;
            if (found && found->level <= ptr->level)
  141c90:	b111      	cbz	r1, 141c98 <lk_init_level+0x60>
  141c92:	680f      	ldr	r7, [r1, #0]
  141c94:	42b8      	cmp	r0, r7
  141c96:	d2ec      	bcs.n	141c72 <lk_init_level+0x3a>
                continue;

            /* keep the lowest one we haven't called yet */
            if (ptr->level >= start_level && ptr->level > last_called_level) {
  141c98:	4282      	cmp	r2, r0
  141c9a:	bf34      	ite	cc
  141c9c:	f04f 0c01 	movcc.w	r12, #1
  141ca0:	f04f 0c00 	movcs.w	r12, #0
  141ca4:	4550      	cmp	r0, r10
  141ca6:	bf38      	it	cc
  141ca8:	f04f 0c00 	movcc.w	r12, #0
  141cac:	f1bc 0f00 	cmp.w	r12, #0
  141cb0:	d117      	bne.n	141ce2 <lk_init_level+0xaa>

            /* if we're at the same level as the last one we called and we've
             * already passed over it this time around, we can mark this one
             * and early terminate the loop.
             */
            if (ptr->level == last_called_level && ptr != last && seen_last) {
  141cb2:	4282      	cmp	r2, r0
  141cb4:	d1dd      	bne.n	141c72 <lk_init_level+0x3a>
  141cb6:	429d      	cmp	r5, r3
  141cb8:	bf0c      	ite	eq
  141cba:	f04f 0c00 	moveq.w	r12, #0
  141cbe:	f004 0c01 	andne.w	r12, r4, #1
  141cc2:	f1bc 0f00 	cmp.w	r12, #0
  141cc6:	d0d4      	beq.n	141c72 <lk_init_level+0x3a>
  141cc8:	461d      	mov	r5, r3
  141cca:	e002      	b.n	141cd2 <lk_init_level+0x9a>
                found = ptr;
                break;
            }
        }

        if (!found)
  141ccc:	b131      	cbz	r1, 141cdc <lk_init_level+0xa4>
  141cce:	6808      	ldr	r0, [r1, #0]
  141cd0:	460d      	mov	r5, r1
        if (found->level >= EARLIEST_TRACE_LEVEL && (required_flag & TRACE_INIT_FLAGS)) {
            printf("INIT: cpu %d, calling hook %p (%s) at level %#x, flags %#x\n",
                   arch_curr_cpu_num(), found->hook, found->name, found->level, found->flags);
        }
#endif
        found->hook(found->level);
  141cd2:	68ab      	ldr	r3, [r5, #8]
  141cd4:	4798      	blx	r3
        last_called_level = found->level;
  141cd6:	682a      	ldr	r2, [r5, #0]
        for (const struct lk_init_struct *ptr = __lk_init; ptr != __lk_init_end; ptr++) {
  141cd8:	45b0      	cmp	r8, r6
  141cda:	d1c3      	bne.n	141c64 <lk_init_level+0x2c>
        last = found;
    }
}
  141cdc:	b003      	add	sp, #12
  141cde:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  141ce2:	4619      	mov	r1, r3
  141ce4:	e7c5      	b.n	141c72 <lk_init_level+0x3a>
    ASSERT(start_level > 0);
  141ce6:	f245 13e8 	movw	r3, #20968	; 0x51e8
  141cea:	f245 12d8 	movw	r2, #20952	; 0x51d8
  141cee:	f644 316c 	movw	r1, #19308	; 0x4b6c
  141cf2:	f2c0 0315 	movt	r3, #21
  141cf6:	4670      	mov	r0, r14
  141cf8:	f2c0 0215 	movt	r2, #21
  141cfc:	9300      	str	r3, [sp, #0]
  141cfe:	f2c0 0115 	movt	r1, #21
  141d02:	2334      	movs	r3, #52	; 0x34
  141d04:	f010 ffd6 	bl	152cb4 <_panic>

00141d08 <bootstrap2>:

void lk_init_level(enum lk_init_flags flags, uint start_level, uint stop_level);

static inline void lk_primary_cpu_init_level(uint start_level, uint stop_level)
{
    lk_init_level(LK_INIT_FLAG_PRIMARY_CPU, start_level, stop_level);
  141d08:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141d0c:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
    // become the idle thread and enable interrupts to start the scheduler
    thread_become_idle();
}

static int bootstrap2(void *arg)
{
  141d10:	b508      	push	{r3, r14}
  141d12:	2001      	movs	r0, #1
  141d14:	f2c0 0207 	movt	r2, #7
  141d18:	f7ff ff8e 	bl	141c38 <lk_init_level>
    dprintf(SPEW, "top of bootstrap2()\n");

    lk_primary_cpu_init_level(LK_INIT_LEVEL_THREADING, LK_INIT_LEVEL_ARCH - 1);
    arch_init();
  141d1c:	f7ff ef56 	blx	141bcc <arch_init>
  141d20:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141d24:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  141d28:	2001      	movs	r0, #1
  141d2a:	f2c0 0208 	movt	r2, #8
  141d2e:	f7ff ff83 	bl	141c38 <lk_init_level>

    // initialize the rest of the platform
    dprintf(SPEW, "initializing platform\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH, LK_INIT_LEVEL_PLATFORM - 1);
    platform_init();
  141d32:	f7fe fba9 	bl	140488 <platform_init>
  141d36:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141d3a:	f44f 2110 	mov.w	r1, #589824	; 0x90000
  141d3e:	2001      	movs	r0, #1
  141d40:	f2c0 0209 	movt	r2, #9
  141d44:	f7ff ff78 	bl	141c38 <lk_init_level>

    // initialize the target
    dprintf(SPEW, "initializing target\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM, LK_INIT_LEVEL_TARGET - 1);
    target_init();
  141d48:	f7fe fa78 	bl	14023c <target_init>
  141d4c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141d50:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
  141d54:	2001      	movs	r0, #1
  141d56:	f2c0 020a 	movt	r2, #10
  141d5a:	f7ff ff6d 	bl	141c38 <lk_init_level>

    dprintf(SPEW, "calling apps_init()\n");
    lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET, LK_INIT_LEVEL_APPS - 1);
    apps_init();
  141d5e:	f000 f885 	bl	141e6c <apps_init>
  141d62:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  141d66:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
  141d6a:	2001      	movs	r0, #1
  141d6c:	f7ff ff64 	bl	141c38 <lk_init_level>

    lk_primary_cpu_init_level(LK_INIT_LEVEL_APPS, LK_INIT_LEVEL_LAST);

    return 0;
}
  141d70:	2000      	movs	r0, #0
  141d72:	bd08      	pop	{r3, r15}

00141d74 <lk_main>:
    lk_boot_args[0] = arg0;
  141d74:	f242 1460 	movw	r4, #8544	; 0x2160
  141d78:	f2c0 0416 	movt	r4, #22
{
  141d7c:	b500      	push	{r14}
    lk_boot_args[3] = arg3;
  141d7e:	e9c4 2302 	strd	r2, r3, [r4, #8]
{
  141d82:	b083      	sub	sp, #12
    lk_boot_args[1] = arg1;
  141d84:	e9c4 0100 	strd	r0, r1, [r4]
    thread_init_early();
  141d88:	f00d fd90 	bl	14f8ac <thread_init_early>
  141d8c:	2101      	movs	r1, #1
  141d8e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141d92:	4608      	mov	r0, r1
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  141d94:	f241 04e8 	movw	r4, #4328	; 0x10e8
  141d98:	f7ff ff4e 	bl	141c38 <lk_init_level>
    arch_early_init();
  141d9c:	f7ff eed6 	blx	141b4c <arch_early_init>
  141da0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141da4:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  141da8:	2001      	movs	r0, #1
  141daa:	f2c0 0201 	movt	r2, #1
  141dae:	f7ff ff43 	bl	141c38 <lk_init_level>
    platform_early_init();
  141db2:	f7fe fae9 	bl	140388 <platform_early_init>
  141db6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141dba:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  141dbe:	2001      	movs	r0, #1
  141dc0:	f2c0 0202 	movt	r2, #2
  141dc4:	f7ff ff38 	bl	141c38 <lk_init_level>
    target_early_init();
  141dc8:	f7fe fa0c 	bl	1401e4 <target_early_init>
  141dcc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141dd0:	f44f 3140 	mov.w	r1, #196608	; 0x30000
  141dd4:	2001      	movs	r0, #1
  141dd6:	f2c0 0203 	movt	r2, #3
  141dda:	f7ff ff2d 	bl	141c38 <lk_init_level>
    heap_init();
  141dde:	f011 f84b 	bl	152e78 <heap_init>
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  141de2:	f241 03e8 	movw	r3, #4328	; 0x10e8
  141de6:	f2c0 0416 	movt	r4, #22
  141dea:	f2c0 0316 	movt	r3, #22
  141dee:	429c      	cmp	r4, r3
  141df0:	d00a      	beq.n	141e08 <lk_main+0x94>
  141df2:	1d25      	adds	r5, r4, #4
  141df4:	1b5d      	subs	r5, r3, r5
  141df6:	f025 0503 	bic.w	r5, r5, #3
  141dfa:	3504      	adds	r5, #4
  141dfc:	4425      	add	r5, r4
        (*ctor)();
  141dfe:	f854 3b04 	ldr.w	r3, [r4], #4
  141e02:	4798      	blx	r3
    for (ctor = __ctor_list; ctor != __ctor_end; ctor++)
  141e04:	42ac      	cmp	r4, r5
  141e06:	d1fa      	bne.n	141dfe <lk_main+0x8a>
  141e08:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141e0c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  141e10:	2001      	movs	r0, #1
  141e12:	f2c0 0205 	movt	r2, #5
  141e16:	f7ff ff0f 	bl	141c38 <lk_init_level>
    kernel_init();
  141e1a:	f00d f993 	bl	14f144 <kernel_init>
  141e1e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  141e22:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
  141e26:	2001      	movs	r0, #1
  141e28:	f2c0 0206 	movt	r2, #6
  141e2c:	f7ff ff04 	bl	141c38 <lk_init_level>
    thread_t *t = thread_create("bootstrap2", &bootstrap2, NULL, DEFAULT_PRIORITY, DEFAULT_STACK_SIZE);
  141e30:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  141e34:	f641 5109 	movw	r1, #7433	; 0x1d09
  141e38:	f245 10f8 	movw	r0, #20984	; 0x51f8
  141e3c:	2200      	movs	r2, #0
  141e3e:	f2c0 0114 	movt	r1, #20
  141e42:	9300      	str	r3, [sp, #0]
  141e44:	f2c0 0015 	movt	r0, #21
  141e48:	2310      	movs	r3, #16
  141e4a:	f00d fbf1 	bl	14f630 <thread_create>
  141e4e:	4604      	mov	r4, r0
    thread_detach(t);
  141e50:	f00d ff08 	bl	14fc64 <thread_detach>
    thread_resume(t);
  141e54:	4620      	mov	r0, r4
  141e56:	f00d fc3f 	bl	14f6d8 <thread_resume>
    thread_become_idle();
  141e5a:	f00d fd6b 	bl	14f934 <thread_become_idle>
  141e5e:	bf00      	nop

00141e60 <app_thread_entry>:
        }
    }
}

static int app_thread_entry(void *arg)
{
  141e60:	b508      	push	{r3, r14}
    const struct app_descriptor *app = (const struct app_descriptor *)arg;

    app->entry(app, NULL);
  141e62:	6883      	ldr	r3, [r0, #8]
  141e64:	2100      	movs	r1, #0
  141e66:	4798      	blx	r3

    return 0;
}
  141e68:	2000      	movs	r0, #0
  141e6a:	bd08      	pop	{r3, r15}

00141e6c <apps_init>:
{
  141e6c:	b5f0      	push	{r4, r5, r6, r7, r14}
    for (app = __apps_start; app != __apps_end; app++) {
  141e6e:	f648 132c 	movw	r3, #35116	; 0x892c
  141e72:	f648 157c 	movw	r5, #35196	; 0x897c
  141e76:	f2c0 0315 	movt	r3, #21
  141e7a:	f2c0 0515 	movt	r5, #21
  141e7e:	42ab      	cmp	r3, r5
{
  141e80:	b083      	sub	sp, #12
    for (app = __apps_start; app != __apps_end; app++) {
  141e82:	d041      	beq.n	141f08 <apps_init+0x9c>
  141e84:	461c      	mov	r4, r3
  141e86:	f103 0214 	add.w	r2, r3, #20
  141e8a:	1aaa      	subs	r2, r5, r2
  141e8c:	f64c 45cd 	movw	r5, #52429	; 0xcccd
  141e90:	0892      	lsrs	r2, r2, #2
  141e92:	f6c0 45cc 	movt	r5, #3276	; 0xccc
  141e96:	fb05 f502 	mul.w	r5, r5, r2
  141e9a:	f025 4540 	bic.w	r5, r5, #3221225472	; 0xc0000000
  141e9e:	3501      	adds	r5, #1
  141ea0:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  141ea4:	eb03 0585 	add.w	r5, r3, r5, lsl #2
        if (app->init)
  141ea8:	6863      	ldr	r3, [r4, #4]
            app->init(app);
  141eaa:	4620      	mov	r0, r4
    for (app = __apps_start; app != __apps_end; app++) {
  141eac:	3414      	adds	r4, #20
        if (app->init)
  141eae:	b103      	cbz	r3, 141eb2 <apps_init+0x46>
            app->init(app);
  141eb0:	4798      	blx	r3
    for (app = __apps_start; app != __apps_end; app++) {
  141eb2:	42ac      	cmp	r4, r5
  141eb4:	d1f8      	bne.n	141ea8 <apps_init+0x3c>
    for (app = __apps_start; app != __apps_end; app++) {
  141eb6:	f648 152c 	movw	r5, #35116	; 0x892c
static void start_app(const struct app_descriptor *app)
{
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;

    dprintf(INFO, "starting app %s\n", app->name);
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  141eba:	f641 6661 	movw	r6, #7777	; 0x1e61
    for (app = __apps_start; app != __apps_end; app++) {
  141ebe:	f2c0 0515 	movt	r5, #21
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  141ec2:	f2c0 0614 	movt	r6, #20
  141ec6:	e002      	b.n	141ece <apps_init+0x62>
    for (app = __apps_start; app != __apps_end; app++) {
  141ec8:	3514      	adds	r5, #20
  141eca:	42a5      	cmp	r5, r4
  141ecc:	d01c      	beq.n	141f08 <apps_init+0x9c>
        if (app->entry && (app->flags & APP_FLAG_DONT_START_ON_BOOT) == 0) {
  141ece:	68ab      	ldr	r3, [r5, #8]
  141ed0:	2b00      	cmp	r3, #0
  141ed2:	d0f9      	beq.n	141ec8 <apps_init+0x5c>
  141ed4:	68eb      	ldr	r3, [r5, #12]
  141ed6:	07da      	lsls	r2, r3, #31
  141ed8:	d4f6      	bmi.n	141ec8 <apps_init+0x5c>
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  141eda:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  141ede:	f013 0f02 	tst.w	r3, #2
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  141ee2:	6828      	ldr	r0, [r5, #0]
  141ee4:	f04f 0310 	mov.w	r3, #16
  141ee8:	4631      	mov	r1, r6
    uint32_t stack_size = (app->flags & APP_FLAG_CUSTOM_STACK_SIZE) ? app->stack_size : DEFAULT_STACK_SIZE;
  141eea:	bf18      	it	ne
  141eec:	692a      	ldrne	r2, [r5, #16]
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  141eee:	9200      	str	r2, [sp, #0]
  141ef0:	462a      	mov	r2, r5
  141ef2:	f00d fb9d 	bl	14f630 <thread_create>
    for (app = __apps_start; app != __apps_end; app++) {
  141ef6:	3514      	adds	r5, #20
    thread_t *t = thread_create(app->name, &app_thread_entry, (void *)app, DEFAULT_PRIORITY, stack_size);
  141ef8:	4607      	mov	r7, r0
    thread_detach(t);
  141efa:	f00d feb3 	bl	14fc64 <thread_detach>
    thread_resume(t);
  141efe:	4638      	mov	r0, r7
  141f00:	f00d fbea 	bl	14f6d8 <thread_resume>
    for (app = __apps_start; app != __apps_end; app++) {
  141f04:	42a5      	cmp	r5, r4
  141f06:	d1e2      	bne.n	141ece <apps_init+0x62>
}
  141f08:	b003      	add	sp, #12
  141f0a:	bdf0      	pop	{r4, r5, r6, r7, r15}

00141f0c <shell_entry>:
    console_init();
}

static void shell_entry(const struct app_descriptor *app, void *args)
{
    console_start();
  141f0c:	f010 bea6 	b.w	152c5c <console_start>

00141f10 <shell_init>:
    console_init();
  141f10:	f010 be54 	b.w	152bbc <console_init>

00141f14 <fw_init>:
#include <ppc.h>
#include <res.h>

int cfg_obtain(uint32_t* cfg_count, firewall_cfg_t** fw_cfg, bool* cfg_debug)
{
    if (fw_cfg_count != (sizeof(fw_init_cfg) / sizeof(firewall_cfg_t))) {
  141f14:	f249 1300 	movw	r3, #37120	; 0x9100
  141f18:	f640 02f3 	movw	r2, #2291	; 0x8f3
  141f1c:	f2c0 0315 	movt	r3, #21

    return 0;
}

int fw_init(void)
{
  141f20:	b530      	push	{r4, r5, r14}
    if (fw_cfg_count != (sizeof(fw_init_cfg) / sizeof(firewall_cfg_t))) {
  141f22:	681d      	ldr	r5, [r3, #0]
{
  141f24:	b083      	sub	sp, #12
    int ret = 0;
    uint32_t cfg_count = 0;
    firewall_cfg_t* fw_cfg = NULL;
    bool cfg_debug = false;
    void* firewall_handle = NULL;
  141f26:	2100      	movs	r1, #0
    if (fw_cfg_count != (sizeof(fw_init_cfg) / sizeof(firewall_cfg_t))) {
  141f28:	4295      	cmp	r5, r2
    void* firewall_handle = NULL;
  141f2a:	9101      	str	r1, [sp, #4]
    if (fw_cfg_count != (sizeof(fw_init_cfg) / sizeof(firewall_cfg_t))) {
  141f2c:	d11a      	bne.n	141f64 <fw_init+0x50>
    *cfg_debug = (0 == fw_cfg_debug) ? false : true;
  141f2e:	f249 1304 	movw	r3, #37124	; 0x9104

    if (0 != cfg_obtain(&cfg_count, &fw_cfg, &cfg_debug)) {
        return -1;
    }

    hal_firewall_creat_handle(&firewall_handle, 0);
  141f32:	a801      	add	r0, sp, #4
    *cfg_debug = (0 == fw_cfg_debug) ? false : true;
  141f34:	f2c0 0315 	movt	r3, #21
  141f38:	681c      	ldr	r4, [r3, #0]
  141f3a:	3400      	adds	r4, #0
  141f3c:	bf18      	it	ne
  141f3e:	2401      	movne	r4, #1
    hal_firewall_creat_handle(&firewall_handle, 0);
  141f40:	f00b fd64 	bl	14da0c <hal_firewall_creat_handle>

    ret = hal_firewall_init(firewall_handle, cfg_count, fw_cfg, cfg_debug);
  141f44:	f249 1208 	movw	r2, #37128	; 0x9108
  141f48:	4623      	mov	r3, r4
  141f4a:	4629      	mov	r1, r5
  141f4c:	f2c0 0215 	movt	r2, #21
  141f50:	9801      	ldr	r0, [sp, #4]
  141f52:	f00b fd83 	bl	14da5c <hal_firewall_init>
  141f56:	4604      	mov	r4, r0

    hal_firewall_delete_handle(firewall_handle);
  141f58:	9801      	ldr	r0, [sp, #4]
  141f5a:	f00b fd77 	bl	14da4c <hal_firewall_delete_handle>

    return ret;
}
  141f5e:	4620      	mov	r0, r4
  141f60:	b003      	add	sp, #12
  141f62:	bd30      	pop	{r4, r5, r15}
        dprintf(CRITICAL, "fw config info not consistent, count: %d, arrary size: %d.\n",
  141f64:	f245 201c 	movw	r0, #21020	; 0x521c
  141f68:	4629      	mov	r1, r5
        return -1;
  141f6a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "fw config info not consistent, count: %d, arrary size: %d.\n",
  141f6e:	f2c0 0015 	movt	r0, #21
  141f72:	f012 f8c1 	bl	1540f8 <_printf>
}
  141f76:	4620      	mov	r0, r4
  141f78:	b003      	add	sp, #12
  141f7a:	bd30      	pop	{r4, r5, r15}

00141f7c <firewall_disable>:

void firewall_disable(void)
{
  141f7c:	b510      	push	{r4, r14}
    void *firewall_handle = NULL;
  141f7e:	2400      	movs	r4, #0
{
  141f80:	b082      	sub	sp, #8
    hal_firewall_creat_handle(&firewall_handle, 0);
  141f82:	4621      	mov	r1, r4
    void *firewall_handle = NULL;
  141f84:	a802      	add	r0, sp, #8
  141f86:	f840 4d04 	str.w	r4, [r0, #-4]!
    hal_firewall_creat_handle(&firewall_handle, 0);
  141f8a:	f00b fd3f 	bl	14da0c <hal_firewall_creat_handle>
    hal_firewall_enable(firewall_handle, false);
  141f8e:	9801      	ldr	r0, [sp, #4]
  141f90:	4621      	mov	r1, r4
  141f92:	f00b fd71 	bl	14da78 <hal_firewall_enable>
    hal_firewall_delete_handle(firewall_handle);
  141f96:	9801      	ldr	r0, [sp, #4]
  141f98:	f00b fd58 	bl	14da4c <hal_firewall_delete_handle>
}
  141f9c:	b002      	add	sp, #8
  141f9e:	bd10      	pop	{r4, r15}

00141fa0 <rid_config_init>:

void rid_config_init(void)
{
  141fa0:	b500      	push	{r14}
    void *firewall_handle = NULL;
  141fa2:	2300      	movs	r3, #0
{
  141fa4:	b083      	sub	sp, #12
    hal_firewall_creat_handle(&firewall_handle, 0);
  141fa6:	4619      	mov	r1, r3
    void *firewall_handle = NULL;
  141fa8:	a802      	add	r0, sp, #8
  141faa:	f840 3d04 	str.w	r3, [r0, #-4]!
    hal_firewall_creat_handle(&firewall_handle, 0);
  141fae:	f00b fd2d 	bl	14da0c <hal_firewall_creat_handle>
    hal_rid_init(firewall_handle, rid_cfg_count, rid_init_cfg);
  141fb2:	f24e 1394 	movw	r3, #57748	; 0xe194
  141fb6:	f24e 1298 	movw	r2, #57752	; 0xe198
  141fba:	f2c0 0315 	movt	r3, #21
  141fbe:	9801      	ldr	r0, [sp, #4]
  141fc0:	f2c0 0215 	movt	r2, #21
  141fc4:	6819      	ldr	r1, [r3, #0]
  141fc6:	f00b fd61 	bl	14da8c <hal_rid_init>
    hal_firewall_delete_handle(firewall_handle);
  141fca:	9801      	ldr	r0, [sp, #4]
  141fcc:	f00b fd3e 	bl	14da4c <hal_firewall_delete_handle>
}
  141fd0:	b003      	add	sp, #12
  141fd2:	f85d fb04 	ldr.w	r15, [r13], #4
  141fd6:	bf00      	nop

00141fd8 <poweroff_cmd>:
    platform_halt(action, reason);
    return 0;
}

static int poweroff_cmd(int argc, const cmd_args *argv)
{
  141fd8:	b508      	push	{r3, r14}
    platform_halt(HALT_ACTION_SHUTDOWN, HALT_REASON_POR);
  141fda:	2101      	movs	r1, #1
  141fdc:	2002      	movs	r0, #2
  141fde:	f7fe faad 	bl	14053c <platform_halt>
  141fe2:	bf00      	nop

00141fe4 <reboot_cmd>:
    if (argc == 2) {
  141fe4:	2802      	cmp	r0, #2
{
  141fe6:	b510      	push	{r4, r14}
    platform_halt_action action = HALT_ACTION_REBOOT;
  141fe8:	bf1c      	itt	ne
  141fea:	2001      	movne	r0, #1
    platform_halt_reason reason = HALT_REASON_SW_RESET;
  141fec:	2407      	movne	r4, #7
    if (argc == 2) {
  141fee:	d117      	bne.n	142020 <reboot_cmd+0x3c>
        if (!strcmp(argv[1].str, reason_fastboot)) {
  141ff0:	694c      	ldr	r4, [r1, #20]
  141ff2:	f245 21bc 	movw	r1, #21180	; 0x52bc
  141ff6:	4620      	mov	r0, r4
  141ff8:	f2c0 0115 	movt	r1, #21
  141ffc:	f012 f8be 	bl	15417c <strcmp>
        if (!strcmp(argv[1].str, reason_shutdown)) {
  142000:	f245 21c8 	movw	r1, #21192	; 0x52c8
  142004:	f2c0 0115 	movt	r1, #21
        if (!strcmp(argv[1].str, reason_fastboot)) {
  142008:	2800      	cmp	r0, #0
        if (!strcmp(argv[1].str, reason_shutdown)) {
  14200a:	4620      	mov	r0, r4
            reason = HALT_REASON_SW_UPDATE;
  14200c:	bf0c      	ite	eq
  14200e:	240a      	moveq	r4, #10
  142010:	2407      	movne	r4, #7
        if (!strcmp(argv[1].str, reason_shutdown)) {
  142012:	f012 f8b3 	bl	15417c <strcmp>
  142016:	2800      	cmp	r0, #0
            action = HALT_ACTION_SHUTDOWN;
  142018:	bf0a      	itet	eq
  14201a:	2401      	moveq	r4, #1
  14201c:	2001      	movne	r0, #1
  14201e:	2002      	moveq	r0, #2
    platform_halt(action, reason);
  142020:	4621      	mov	r1, r4
  142022:	f7fe fa8b 	bl	14053c <platform_halt>
  142026:	bf00      	nop

00142028 <sem_config>:

    return 0;
}

void sem_config(uint level)
{
  142028:	b530      	push	{r4, r5, r14}
  14202a:	b083      	sub	sp, #12
    uint32_t pin = boot_get_pin();
  14202c:	f010 f8a2 	bl	152174 <boot_get_pin>
    if (pin >= 9 && pin <= 13) {
  142030:	3809      	subs	r0, #9
  142032:	2804      	cmp	r0, #4
  142034:	d82f      	bhi.n	142096 <sem_config+0x6e>
        platform_halt_reason reason;
        addr_t saf_rstgen = _ioaddr(APB_RSTGEN_SAF_BASE);
        /* Sem global reset enable */
        writel(0xa, saf_rstgen);
        /* Release sem module reset */
        writel(2, saf_rstgen + 0x49000);
  142036:	f44f 4310 	mov.w	r3, #36864	; 0x9000
        writel(0xa, saf_rstgen);
  14203a:	2100      	movs	r1, #0
        writel(2, saf_rstgen + 0x49000);
  14203c:	f6cf 4344 	movt	r3, #64580	; 0xfc44
        writel(0xa, saf_rstgen);
  142040:	250a      	movs	r5, #10
  142042:	f6cf 4140 	movt	r1, #64576	; 0xfc40
        writel(2, saf_rstgen + 0x49000);
  142046:	2402      	movs	r4, #2
        writel(3, saf_rstgen + 0x49000);
  142048:	2003      	movs	r0, #3
        writel(0xa, saf_rstgen);
  14204a:	600d      	str	r5, [r1, #0]

        /* Waiting for sem module release done */
        while (!(readl(saf_rstgen + 0x49000) & 0x40000000));
  14204c:	461a      	mov	r2, r3
        writel(2, saf_rstgen + 0x49000);
  14204e:	601c      	str	r4, [r3, #0]
        writel(3, saf_rstgen + 0x49000);
  142050:	6018      	str	r0, [r3, #0]
        while (!(readl(saf_rstgen + 0x49000) & 0x40000000));
  142052:	6813      	ldr	r3, [r2, #0]
  142054:	005b      	lsls	r3, r3, #1
  142056:	d5fc      	bpl.n	142052 <sem_config+0x2a>

        /* wdt1 ~ wdt6 overflow event */
        addr_t sem_base = _ioaddr(APB_SEM1_BASE);
        writel(0x49248, sem_base + 0x2a4);
  142058:	f44f 7229 	mov.w	r2, #676	; 0x2a4
  14205c:	f249 2148 	movw	r1, #37448	; 0x9248
        /* overflow int enable */
        writel(0x808, sem_base + 0x8);
  142060:	2308      	movs	r3, #8
        writel(0x49248, sem_base + 0x2a4);
  142062:	f2cf 0232 	movt	r2, #61490	; 0xf032
        writel(0x808, sem_base + 0x8);
  142066:	f2cf 0332 	movt	r3, #61490	; 0xf032
  14206a:	f640 0008 	movw	r0, #2056	; 0x808
        writel(0x49248, sem_base + 0x2a4);
  14206e:	f2c0 0104 	movt	r1, #4
  142072:	6011      	str	r1, [r2, #0]
        writel(0x808, sem_base + 0x8);
  142074:	6018      	str	r0, [r3, #0]
        reason = get_bootreason();
  142076:	f7fe fa37 	bl	1404e8 <get_bootreason>
        get_wakeupsrc(&wksrc, &data);
  14207a:	a901      	add	r1, sp, #4
        reason = get_bootreason();
  14207c:	4604      	mov	r4, r0
        get_wakeupsrc(&wksrc, &data);
  14207e:	4668      	mov	r0, r13
  142080:	f7fe fa4e 	bl	140520 <get_wakeupsrc>
        printf("get reboot reason %d, wakeupsrc %d, data %ld\n", reason, wksrc,
  142084:	f245 20d4 	movw	r0, #21204	; 0x52d4
  142088:	4621      	mov	r1, r4
  14208a:	f2c0 0015 	movt	r0, #21
  14208e:	e9dd 2300 	ldrd	r2, r3, [r13]
  142092:	f012 f831 	bl	1540f8 <_printf>

            default:
                break;
        }
    }
}
  142096:	b003      	add	sp, #12
  142098:	bd30      	pop	{r4, r5, r15}
  14209a:	bf00      	nop

0014209c <setwksrc_cmd>:
    if (argc < 2) {
  14209c:	2801      	cmp	r0, #1
{
  14209e:	b508      	push	{r3, r14}
    if (argc < 2) {
  1420a0:	dd06      	ble.n	1420b0 <setwksrc_cmd+0x14>
  1420a2:	460b      	mov	r3, r1
    config_wakeupsrc(wksrc, sec);
  1420a4:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  1420a6:	6a18      	ldr	r0, [r3, #32]
  1420a8:	f7fe fa26 	bl	1404f8 <config_wakeupsrc>
}
  1420ac:	2000      	movs	r0, #0
  1420ae:	bd08      	pop	{r3, r15}
        printf("set wakeup source: src(bit 0:rtc0, bit 1:rtc1, bit 2:ext 0; bit 3:ext 1) param(delay seconds for rtc)\n");
  1420b0:	f245 3004 	movw	r0, #21252	; 0x5304
  1420b4:	f2c0 0015 	movt	r0, #21
  1420b8:	f012 f81e 	bl	1540f8 <_printf>
}
  1420bc:	2000      	movs	r0, #0
  1420be:	bd08      	pop	{r3, r15}

001420c0 <ce_key_ctrl>:
        LTRACEF("phy_addr_temp = 0x%x, data = 0x%x\n", (uint32_t)(phy_addr_temp + (0x1c << 10)), data);
    }
}

int ce_key_ctrl(void)
{
  1420c0:	b570      	push	{r4, r5, r6, r14}

    int ret = 0;
    paddr_t phy_addr = 0;
  1420c2:	2400      	movs	r4, #0
{
  1420c4:	b082      	sub	sp, #8
    int32_t resid = 0;
    int32_t offset_index = 0;

    resid = RES_SCR_L16_SEC_CE2_KEY_PERCTRL_SCR_KEY_ENABLE_15_0;
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  1420c6:	f44f 7020 	mov.w	r0, #640	; 0x280
    int32_t offset_index = 0;
  1420ca:	aa02      	add	r2, sp, #8
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  1420cc:	4669      	mov	r1, r13
  1420ce:	f2c8 1098 	movt	r0, #33176	; 0x8198
    int32_t offset_index = 0;
  1420d2:	f842 4d04 	str.w	r4, [r2, #-4]!
    paddr_t phy_addr = 0;
  1420d6:	9400      	str	r4, [sp, #0]
    ret = res_get_info_by_id(resid, &phy_addr, &offset_index);
  1420d8:	f00c f9f4 	bl	14e4c4 <res_get_info_by_id>

    if (ret == -1) {
  1420dc:	1c43      	adds	r3, r0, #1
  1420de:	d01e      	beq.n	14211e <ce_key_ctrl+0x5e>
    phy_addr_temp = phy_addr + (offset_index << 12);
  1420e0:	9a01      	ldr	r2, [sp, #4]
    writel(data, phy_addr_temp);
  1420e2:	2613      	movs	r6, #19
    phy_addr_temp = phy_addr + (offset_index << 12);
  1420e4:	9900      	ldr	r1, [sp, #0]
    writel(data, phy_addr_temp + (0x4 << 10));
  1420e6:	2521      	movs	r5, #33	; 0x21
    phy_addr_temp = phy_addr + (offset_index << 12);
  1420e8:	0312      	lsls	r2, r2, #12
  1420ea:	1853      	adds	r3, r2, r1
    writel(data, phy_addr_temp);
  1420ec:	5056      	str	r6, [r2, r1]
    writel(data, phy_addr_temp + (0x4 << 10));
  1420ee:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
    writel(data, phy_addr_temp + (0x8 << 10));
  1420f2:	f503 5100 	add.w	r1, r3, #8192	; 0x2000
    writel(data, phy_addr_temp + (0x4 << 10));
  1420f6:	6015      	str	r5, [r2, #0]
    writel(data, phy_addr_temp + (0x8 << 10));
  1420f8:	25c3      	movs	r5, #195	; 0xc3
    writel(data, phy_addr_temp + (0xc << 10));
  1420fa:	f503 5240 	add.w	r2, r3, #12288	; 0x3000
    writel(data, phy_addr_temp + (0x8 << 10));
  1420fe:	600d      	str	r5, [r1, #0]
    writel(data, phy_addr_temp + (0xc << 10));
  142100:	f240 3101 	movw	r1, #769	; 0x301
    writel(data, phy_addr_temp + (0x10 << 10));
  142104:	f503 4580 	add.w	r5, r3, #16384	; 0x4000
    writel(data, phy_addr_temp + (0xc << 10));
  142108:	6011      	str	r1, [r2, #0]
    writel(data, phy_addr_temp + (0x14 << 10));
  14210a:	f503 41a0 	add.w	r1, r3, #20480	; 0x5000
    writel(data, phy_addr_temp + (0x10 << 10));
  14210e:	602c      	str	r4, [r5, #0]
    writel(data, phy_addr_temp + (0x18 << 10));
  142110:	f503 42c0 	add.w	r2, r3, #24576	; 0x6000
    writel(data, phy_addr_temp + (0x14 << 10));
  142114:	600c      	str	r4, [r1, #0]
    writel(data, phy_addr_temp + (0x1c << 10));
  142116:	f503 43e0 	add.w	r3, r3, #28672	; 0x7000
    writel(data, phy_addr_temp + (0x18 << 10));
  14211a:	6014      	str	r4, [r2, #0]
    writel(data, phy_addr_temp + (0x1c << 10));
  14211c:	601c      	str	r4, [r3, #0]
    else {
        L16_ce2key_enable_init(phy_addr, offset_index);
    }

    return ret;
}
  14211e:	b002      	add	sp, #8
  142120:	bd70      	pop	{r4, r5, r6, r15}
  142122:	bf00      	nop

00142124 <scr_init>:
#endif
}
/* hardcode scr init end */

int scr_init(void)
{
  142124:	b510      	push	{r4, r14}
    int ret = 0;

    //ce key setting
    ret = ce_key_ctrl();
  142126:	f7ff ffcb 	bl	1420c0 <ce_key_ctrl>
    if (ret) {
  14212a:	4604      	mov	r4, r0
  14212c:	b9c8      	cbnz	r0, 142162 <scr_init+0x3e>
    uint32_t rval = readl(SCR_SEC_BASE + (266 << 12));
  14212e:	f44f 4120 	mov.w	r1, #40960	; 0xa000
    rval = readl(SCR_SEC_BASE + (270 << 12));
  142132:	f44f 4260 	mov.w	r2, #57344	; 0xe000
    uint32_t rval = readl(SCR_SEC_BASE + (266 << 12));
  142136:	f6cf 0130 	movt	r1, #63536	; 0xf830
    rval = readl(SCR_SEC_BASE + (274 << 12));
  14213a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    rval = readl(SCR_SEC_BASE + (270 << 12));
  14213e:	f6cf 0230 	movt	r2, #63536	; 0xf830
    rval = readl(SCR_SEC_BASE + (274 << 12));
  142142:	f6cf 0331 	movt	r3, #63537	; 0xf831
    uint32_t rval = readl(SCR_SEC_BASE + (266 << 12));
  142146:	6808      	ldr	r0, [r1, #0]
    rval = (rval & (~0xF0000)) | 0xF0000;
  142148:	f440 2070 	orr.w	r0, r0, #983040	; 0xf0000
    writel(rval, SCR_SEC_BASE + (266 << 12));
  14214c:	6008      	str	r0, [r1, #0]

    // other setting
    src_init_hc();

    return ret;
}
  14214e:	4620      	mov	r0, r4
    rval = readl(SCR_SEC_BASE + (270 << 12));
  142150:	6811      	ldr	r1, [r2, #0]
    rval = (rval & (~0x3)) | 0x3;
  142152:	f041 0103 	orr.w	r1, r1, #3
    writel(rval, SCR_SEC_BASE + (270 << 12));
  142156:	6011      	str	r1, [r2, #0]
    rval = readl(SCR_SEC_BASE + (274 << 12));
  142158:	681a      	ldr	r2, [r3, #0]
    rval = (rval & (~0xF)) | 0xF;
  14215a:	f042 020f 	orr.w	r2, r2, #15
    writel(rval, SCR_SEC_BASE + (274 << 12));
  14215e:	601a      	str	r2, [r3, #0]
}
  142160:	bd10      	pop	{r4, r15}
        dprintf(CRITICAL, "ce_key_ctrl fail.\n");
  142162:	f245 4028 	movw	r0, #21544	; 0x5428
  142166:	f2c0 0015 	movt	r0, #21
  14216a:	f011 ffc5 	bl	1540f8 <_printf>
}
  14216e:	4620      	mov	r0, r4
  142170:	bd10      	pop	{r4, r15}
  142172:	bf00      	nop

00142174 <ssystem_main>:
    return ret;
}

static void _ssystem_main(void)
{
    hal_trng_init(NULL,NULL);
  142174:	2100      	movs	r1, #0
    target_quiesce();
}

int ssystem_main(int argc, const cmd_args *argv)
{
  142176:	b508      	push	{r3, r14}
    hal_trng_init(NULL,NULL);
  142178:	4608      	mov	r0, r1
  14217a:	f00b fb1d 	bl	14d7b8 <hal_trng_init>
    target_quiesce();
  14217e:	f7fe f85f 	bl	140240 <target_quiesce>
    _ssystem_main();
    return 0;
}
  142182:	2000      	movs	r0, #0
  142184:	bd08      	pop	{r3, r15}
  142186:	bf00      	nop

00142188 <ssystem_entry>:
    hal_trng_init(NULL,NULL);
  142188:	2100      	movs	r1, #0

status_t ssystem_server_init(void);

static void ssystem_entry(const struct app_descriptor *app, void *args)
{
  14218a:	b508      	push	{r3, r14}
    hal_trng_init(NULL,NULL);
  14218c:	4608      	mov	r0, r1
  14218e:	f00b fb13 	bl	14d7b8 <hal_trng_init>
    target_quiesce();
  142192:	f7fe f855 	bl	140240 <target_quiesce>
    /* earlier start rpc service before other part init */
    _ssystem_main();
    ssystem_server_init();
}
  142196:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    ssystem_server_init();
  14219a:	f000 b955 	b.w	142448 <ssystem_server_init>
  14219e:	bf00      	nop

001421a0 <image_descrypt>:
    uint8_t iv[] = {
  1421a0:	f245 435c 	movw	r3, #21596	; 0x545c
  1421a4:	f2c0 0315 	movt	r3, #21
{
  1421a8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    uint8_t key[] = {
  1421ac:	f103 0610 	add.w	r6, r3, #16
{
  1421b0:	4680      	mov	r8, r0
  1421b2:	b090      	sub	sp, #64	; 0x40
  1421b4:	4689      	mov	r9, r1
    uint8_t iv[] = {
  1421b6:	ad08      	add	r5, sp, #32
{
  1421b8:	4617      	mov	r7, r2
    uint8_t key[] = {
  1421ba:	ac0c      	add	r4, sp, #48	; 0x30
    uint8_t iv[] = {
  1421bc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  1421be:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    uint8_t key[] = {
  1421c2:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
    void *crypto_handle = 0;
  1421c6:	f04f 0a00 	mov.w	r10, #0
    result = hal_aes_init(crypto_handle, SD_FCT_CBC, OPERATION_DEC,
  1421ca:	2610      	movs	r6, #16
    uint8_t key[] = {
  1421cc:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    hal_crypto_creat_handle(&crypto_handle, VCE_ID_GENERAL_SUPPORT_PKA);
  1421d0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  1421d4:	a807      	add	r0, sp, #28
    void *crypto_handle = 0;
  1421d6:	f8cd a01c 	str.w	r10, [r13, #28]
    hal_crypto_creat_handle(&crypto_handle, VCE_ID_GENERAL_SUPPORT_PKA);
  1421da:	f2c0 5112 	movt	r1, #1298	; 0x512
  1421de:	f00b fa69 	bl	14d6b4 <hal_crypto_creat_handle>
    result = hal_aes_init(crypto_handle, SD_FCT_CBC, OPERATION_DEC,
  1421e2:	2201      	movs	r2, #1
  1421e4:	9400      	str	r4, [sp, #0]
  1421e6:	4611      	mov	r1, r2
  1421e8:	9807      	ldr	r0, [sp, #28]
  1421ea:	2303      	movs	r3, #3
  1421ec:	9503      	str	r5, [sp, #12]
  1421ee:	f8cd a004 	str.w	r10, [r13, #4]
  1421f2:	9604      	str	r6, [sp, #16]
  1421f4:	9602      	str	r6, [sp, #8]
  1421f6:	f00b fae3 	bl	14d7c0 <hal_aes_init>
    if (result) {
  1421fa:	4604      	mov	r4, r0
  1421fc:	b948      	cbnz	r0, 142212 <image_descrypt+0x72>
    result = hal_aes_final(crypto_handle, src, size, 0, dst, size);
  1421fe:	4623      	mov	r3, r4
  142200:	463a      	mov	r2, r7
  142202:	9807      	ldr	r0, [sp, #28]
  142204:	4641      	mov	r1, r8
  142206:	9701      	str	r7, [sp, #4]
  142208:	f8cd 9000 	str.w	r9, [r13]
  14220c:	f00b fb84 	bl	14d918 <hal_aes_final>
  142210:	4604      	mov	r4, r0
    hal_crypto_delete_handle(crypto_handle);
  142212:	9807      	ldr	r0, [sp, #28]
  142214:	f00b fac8 	bl	14d7a8 <hal_crypto_delete_handle>
}
  142218:	4620      	mov	r0, r4
  14221a:	b010      	add	sp, #64	; 0x40
  14221c:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}

00142220 <system_config_init>:
{
  142220:	b510      	push	{r4, r14}
    int ret = scr_init();
  142222:	f7ff ff7f 	bl	142124 <scr_init>
    if (ret) {
  142226:	b930      	cbnz	r0, 142236 <system_config_init+0x16>
  142228:	4604      	mov	r4, r0
    firewall_disable();
  14222a:	f7ff fea7 	bl	141f7c <firewall_disable>
    rid_config_init();
  14222e:	f7ff feb7 	bl	141fa0 <rid_config_init>
}
  142232:	4620      	mov	r0, r4
  142234:	bd10      	pop	{r4, r15}
        dprintf(CRITICAL, "scr init fail.\n");
  142236:	f245 501c 	movw	r0, #21788	; 0x551c
        return -1;
  14223a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        dprintf(CRITICAL, "scr init fail.\n");
  14223e:	f2c0 0015 	movt	r0, #21
  142242:	f011 ff59 	bl	1540f8 <_printf>
        return -1;
  142246:	e7f4      	b.n	142232 <system_config_init+0x12>

00142248 <os_platform_early_init>:

static void setup_uart_clk(void)
{
    void *handle = NULL;
    bool ret = false;
    clkgen_app_ip_cfg_t clk = {4, 0, 1};
  142248:	4b3d      	ldr	r3, [pc, #244]	; (142340 <os_platform_early_init+0xf8>)
    ASSERT(ret);
    hal_clock_release_handle(handle);
}

void os_platform_early_init(void)
{
  14224a:	b570      	push	{r4, r5, r6, r14}
  14224c:	b088      	sub	sp, #32
    clkgen_app_ip_cfg_t clk = {4, 0, 1};
  14224e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    void *handle = NULL;
  142252:	2500      	movs	r5, #0
    clkgen_app_ip_cfg_t clk = {4, 0, 1};
  142254:	ac04      	add	r4, sp, #16
  142256:	4676      	mov	r6, r14
  142258:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    void *handle = NULL;
  14225c:	9503      	str	r5, [sp, #12]
    ret = hal_clock_creat_handle(&handle);
  14225e:	a803      	add	r0, sp, #12
  142260:	f00b f9cc 	bl	14d5fc <hal_clock_creat_handle>
    ASSERT(ret);
  142264:	2800      	cmp	r0, #0
  142266:	d038      	beq.n	1422da <os_platform_early_init+0x92>
    ret = hal_clock_ipclk_set(handle, RES_IP_SLICE_SEC_UART_SEC0, &clk);
  142268:	2107      	movs	r1, #7
  14226a:	4622      	mov	r2, r4
  14226c:	9803      	ldr	r0, [sp, #12]
  14226e:	f2c8 119a 	movt	r1, #33178	; 0x819a
  142272:	f00b f9e7 	bl	14d644 <hal_clock_ipclk_set>
    ASSERT(ret);
  142276:	2800      	cmp	r0, #0
  142278:	d040      	beq.n	1422fc <os_platform_early_init+0xb4>
    ret = hal_clock_ipclk_set(handle, RES_IP_SLICE_SEC_UART_SEC1, &clk);
  14227a:	2108      	movs	r1, #8
  14227c:	4622      	mov	r2, r4
  14227e:	9803      	ldr	r0, [sp, #12]
  142280:	f2c8 119a 	movt	r1, #33178	; 0x819a
  142284:	f00b f9de 	bl	14d644 <hal_clock_ipclk_set>
    ASSERT(ret);
  142288:	2800      	cmp	r0, #0
  14228a:	d048      	beq.n	14231e <os_platform_early_init+0xd6>
    hal_clock_release_handle(handle);
  14228c:	9803      	ldr	r0, [sp, #12]
  14228e:	f00b f9d1 	bl	14d634 <hal_clock_release_handle>
    mem_image_entry_t info;
    addr_t seeker_base = DIL_IMAGES_MEMBASE;

    setup_uart_clk();

    system_config_init();
  142292:	f7ff ffc5 	bl	142220 <system_config_init>

    if (mem_image_seek(seeker_base, "hsm_fw", &info)) {
  142296:	f245 41cc 	movw	r1, #21708	; 0x54cc
  14229a:	2000      	movs	r0, #0
  14229c:	4622      	mov	r2, r4
  14229e:	f2c0 0115 	movt	r1, #21
  1422a2:	f2c3 0081 	movt	r0, #12417	; 0x3081
  1422a6:	f00f fb87 	bl	1519b8 <mem_image_seek>
  1422aa:	b970      	cbnz	r0, 1422ca <os_platform_early_init+0x82>
        dprintf(CRITICAL, "can't find hsm image!\n");
    } else {
        if (image_descrypt((uint8_t *)(unsigned int)info.base, (uint8_t *)R5_SEC_TCMB_BASE,
  1422ac:	9a06      	ldr	r2, [sp, #24]
  1422ae:	f44f 0196 	mov.w	r1, #4915200	; 0x4b0000
  1422b2:	9804      	ldr	r0, [sp, #16]
  1422b4:	f7ff ff74 	bl	1421a0 <image_descrypt>
  1422b8:	b128      	cbz	r0, 1422c6 <os_platform_early_init+0x7e>
                           info.sz)) {
            dprintf(CRITICAL, "decrypt hsm fail!\n");
  1422ba:	f245 40ec 	movw	r0, #21740	; 0x54ec
  1422be:	f2c0 0015 	movt	r0, #21
  1422c2:	f011 ff19 	bl	1540f8 <_printf>
        dprintf(CRITICAL, "decrypt sdpe fail!\n");

    boot_mp(SDPE_MEMBASE);
#endif
#endif
}
  1422c6:	b008      	add	sp, #32
  1422c8:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(CRITICAL, "can't find hsm image!\n");
  1422ca:	f245 40d4 	movw	r0, #21716	; 0x54d4
  1422ce:	f2c0 0015 	movt	r0, #21
  1422d2:	f011 ff11 	bl	1540f8 <_printf>
}
  1422d6:	b008      	add	sp, #32
  1422d8:	bd70      	pop	{r4, r5, r6, r15}
    ASSERT(ret);
  1422da:	f644 33ac 	movw	r3, #19372	; 0x4bac
  1422de:	f245 4298 	movw	r2, #21656	; 0x5498
  1422e2:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1422e6:	f2c0 0315 	movt	r3, #21
  1422ea:	4630      	mov	r0, r6
  1422ec:	f2c0 0215 	movt	r2, #21
  1422f0:	9300      	str	r3, [sp, #0]
  1422f2:	f2c0 0115 	movt	r1, #21
  1422f6:	23a4      	movs	r3, #164	; 0xa4
  1422f8:	f010 fcdc 	bl	152cb4 <_panic>
    ASSERT(ret);
  1422fc:	f644 33ac 	movw	r3, #19372	; 0x4bac
  142300:	f245 4298 	movw	r2, #21656	; 0x5498
  142304:	f644 316c 	movw	r1, #19308	; 0x4b6c
  142308:	f2c0 0315 	movt	r3, #21
  14230c:	4630      	mov	r0, r6
  14230e:	f2c0 0215 	movt	r2, #21
  142312:	9300      	str	r3, [sp, #0]
  142314:	f2c0 0115 	movt	r1, #21
  142318:	23a6      	movs	r3, #166	; 0xa6
  14231a:	f010 fccb 	bl	152cb4 <_panic>
    ASSERT(ret);
  14231e:	f644 33ac 	movw	r3, #19372	; 0x4bac
  142322:	f245 4298 	movw	r2, #21656	; 0x5498
  142326:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14232a:	f2c0 0315 	movt	r3, #21
  14232e:	4630      	mov	r0, r6
  142330:	f2c0 0215 	movt	r2, #21
  142334:	9300      	str	r3, [sp, #0]
  142336:	f2c0 0115 	movt	r1, #21
  14233a:	23a8      	movs	r3, #168	; 0xa8
  14233c:	f010 fcba 	bl	152cb4 <_panic>
  142340:	0015547c 	.word	0x0015547c

00142344 <ssystem_process_task>:
};

static struct hsm_head_table *hsm_head = (struct hsm_head_table *)HSM_HEAD_BEGIN;
static struct ssystem_server_info ssystem_server;
int ssystem_process_task(void *token)
{
  142344:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    struct ssystem_server_info *s = token;
    char send_buf[DCF_MSG_MAX_DLEN] = {0,};
  142348:	2278      	movs	r2, #120	; 0x78
{
  14234a:	b09e      	sub	sp, #120	; 0x78
    char send_buf[DCF_MSG_MAX_DLEN] = {0,};
  14234c:	2100      	movs	r1, #0
{
  14234e:	4605      	mov	r5, r0
    char send_buf[DCF_MSG_MAX_DLEN] = {0,};
  142350:	4668      	mov	r0, r13
  142352:	f010 ee94 	blx	15307c <memset>
    struct ssystem_hsm_cmd *hsm_cmd_msg = (struct ssystem_hsm_cmd *) send_buf;
    size_t len = DCF_MSG_MAX_DLEN;
    u32 count = 0;
    int ret = 0;

    if (hsm_head->hsm_header_num == HSM_HEAD_MAGIC) {
  142356:	2340      	movs	r3, #64	; 0x40
  142358:	f646 1230 	movw	r2, #26928	; 0x6930
  14235c:	f2c0 034b 	movt	r3, #75	; 0x4b
  142360:	f2c6 1270 	movt	r2, #24944	; 0x6170
  142364:	6819      	ldr	r1, [r3, #0]
  142366:	4291      	cmp	r1, r2
  142368:	d106      	bne.n	142378 <ssystem_process_task+0x34>
        hsm_head->hsm_init((uint32_t *)hsm_share_mem_table, 1);    /*hsm_init*/
  14236a:	f245 5058 	movw	r0, #21848	; 0x5558
  14236e:	2101      	movs	r1, #1
  142370:	685b      	ldr	r3, [r3, #4]
  142372:	f2c0 0015 	movt	r0, #21
  142376:	4798      	blx	r3
        if (cmd_msg->op == COMM_MSG_CCM_DROP) {
            printf("ssystem: command=DROP\n");
            continue;
        }

        if (hsm_cmd_msg->cmd == HSM_MAIN_CMD) {
  142378:	f241 2634 	movw	r6, #4660	; 0x1234
            if (hsm_head->hsm_header_num == HSM_HEAD_MAGIC) {
  14237c:	2740      	movs	r7, #64	; 0x40
  14237e:	f646 1830 	movw	r8, #26928	; 0x6930
        if (hsm_cmd_msg->cmd == HSM_MAIN_CMD) {
  142382:	f6cf 76ff 	movt	r6, #65535	; 0xffff
            if (hsm_head->hsm_header_num == HSM_HEAD_MAGIC) {
  142386:	f2c0 074b 	movt	r7, #75	; 0x4b
  14238a:	f2c6 1870 	movt	r8, #24944	; 0x6170
        ret = posix_read(s->dcf_fd, send_buf, len);
  14238e:	2278      	movs	r2, #120	; 0x78
  142390:	4669      	mov	r1, r13
  142392:	68a8      	ldr	r0, [r5, #8]
  142394:	f00a f9ac 	bl	14c6f0 <dcf_read>
        if (ret <= 0) {
  142398:	1e04      	subs	r4, r0, #0
  14239a:	dd3e      	ble.n	14241a <ssystem_process_task+0xd6>
        if (cmd_msg->op == COMM_MSG_CCM_ECHO) {
  14239c:	f89d 3000 	ldrb.w	r3, [r13]
  1423a0:	2ba5      	cmp	r3, #165	; 0xa5
  1423a2:	d022      	beq.n	1423ea <ssystem_process_task+0xa6>
        if (cmd_msg->op == COMM_MSG_CCM_DROP) {
  1423a4:	2baa      	cmp	r3, #170	; 0xaa
  1423a6:	d031      	beq.n	14240c <ssystem_process_task+0xc8>
        if (hsm_cmd_msg->cmd == HSM_MAIN_CMD) {
  1423a8:	9b00      	ldr	r3, [sp, #0]
  1423aa:	42b3      	cmp	r3, r6
  1423ac:	d1ef      	bne.n	14238e <ssystem_process_task+0x4a>
            if (hsm_head->hsm_header_num == HSM_HEAD_MAGIC) {
  1423ae:	683b      	ldr	r3, [r7, #0]
  1423b0:	4543      	cmp	r3, r8
  1423b2:	d1ec      	bne.n	14238e <ssystem_process_task+0x4a>
                hsm_head->hsm_main(0, (void *)(hsm_cmd_msg->data));
  1423b4:	68bb      	ldr	r3, [r7, #8]
  1423b6:	a901      	add	r1, sp, #4
  1423b8:	2000      	movs	r0, #0
  1423ba:	4798      	blx	r3
                memcpy((void *)(hsm_cmd_msg->data), (hsm_head->response_pack_addr), hsm_head->response_pack_size);
  1423bc:	e9d7 2103 	ldrd	r2, r1, [r7, #12]
  1423c0:	a801      	add	r0, sp, #4
  1423c2:	f010 edd6 	blx	152f70 <memcpy>
                ret = posix_write(s->dcf_fd, send_buf, len);
  1423c6:	2278      	movs	r2, #120	; 0x78
  1423c8:	68a8      	ldr	r0, [r5, #8]
  1423ca:	4669      	mov	r1, r13
  1423cc:	f00a f9d2 	bl	14c774 <dcf_write>
                if (ret < 0) {
  1423d0:	1e02      	subs	r2, r0, #0
  1423d2:	dadc      	bge.n	14238e <ssystem_process_task+0x4a>
                    printf("%s: hsm service write failure %d\n", __func__, ret);
  1423d4:	f245 512c 	movw	r1, #21804	; 0x552c
  1423d8:	f245 50a8 	movw	r0, #21928	; 0x55a8
  1423dc:	f2c0 0115 	movt	r1, #21
  1423e0:	f2c0 0015 	movt	r0, #21
  1423e4:	f011 fe88 	bl	1540f8 <_printf>
  1423e8:	e7d1      	b.n	14238e <ssystem_process_task+0x4a>
            printf("ssystem: command=ECHO\n");
  1423ea:	f245 5078 	movw	r0, #21880	; 0x5578
  1423ee:	f2c0 0015 	movt	r0, #21
  1423f2:	f011 fe81 	bl	1540f8 <_printf>
            ret = posix_write(s->dcf_fd, send_buf, ret);
  1423f6:	4622      	mov	r2, r4
  1423f8:	68a8      	ldr	r0, [r5, #8]
  1423fa:	4669      	mov	r1, r13
  1423fc:	f00a f9ba 	bl	14c774 <dcf_write>
            if (ret < 0) {
  142400:	1e02      	subs	r2, r0, #0
  142402:	db16      	blt.n	142432 <ssystem_process_task+0xee>
  142404:	f89d 3000 	ldrb.w	r3, [r13]
        if (cmd_msg->op == COMM_MSG_CCM_DROP) {
  142408:	2baa      	cmp	r3, #170	; 0xaa
  14240a:	d1cd      	bne.n	1423a8 <ssystem_process_task+0x64>
            printf("ssystem: command=DROP\n");
  14240c:	f245 5090 	movw	r0, #21904	; 0x5590
  142410:	f2c0 0015 	movt	r0, #21
  142414:	f011 fe70 	bl	1540f8 <_printf>
            continue;
  142418:	e7b9      	b.n	14238e <ssystem_process_task+0x4a>
            printf("%s: read failure %d\n", __func__, ret);
  14241a:	f245 512c 	movw	r1, #21804	; 0x552c
  14241e:	f245 5060 	movw	r0, #21856	; 0x5560
  142422:	4622      	mov	r2, r4
  142424:	f2c0 0115 	movt	r1, #21
  142428:	f2c0 0015 	movt	r0, #21
  14242c:	f011 fe64 	bl	1540f8 <_printf>
            continue;
  142430:	e7ad      	b.n	14238e <ssystem_process_task+0x4a>
                printf("%s: read failure %d\n", __func__, ret);
  142432:	f245 512c 	movw	r1, #21804	; 0x552c
  142436:	f245 5060 	movw	r0, #21856	; 0x5560
  14243a:	f2c0 0115 	movt	r1, #21
  14243e:	f2c0 0015 	movt	r0, #21
  142442:	f011 fe59 	bl	1540f8 <_printf>
                continue;
  142446:	e7a2      	b.n	14238e <ssystem_process_task+0x4a>

00142448 <ssystem_server_init>:

void start_rpmsg_service(void);
void rpmsg_net_init_hook(void);

void ssystem_server_init(void)
{
  142448:	b510      	push	{r4, r14}
    rpmsg_net_init_hook();

#if CONFIG_SSYSTEM_SERVER
    struct ssystem_server_info *s = &ssystem_server;

    if (s->binitialized)
  14244a:	f242 1470 	movw	r4, #8560	; 0x2170
{
  14244e:	b082      	sub	sp, #8
    start_rpmsg_service();
  142450:	f00a fbfa 	bl	14cc48 <start_rpmsg_service>
    if (s->binitialized)
  142454:	f2c0 0416 	movt	r4, #22
    rpmsg_net_init_hook();
  142458:	f00b feb2 	bl	14e1c0 <rpmsg_net_init_hook>
    if (s->binitialized)
  14245c:	7823      	ldrb	r3, [r4, #0]
  14245e:	b10b      	cbz	r3, 142464 <ssystem_server_init+0x1c>
    s->main_thread = thread_create("ssystemd", ssystem_process_task, s, HIGH_PRIORITY, SSYSTEMD_STACK_SZ);
    thread_detach_and_resume(s->main_thread);

    s->binitialized = true;
#endif
}
  142460:	b002      	add	sp, #8
  142462:	bd10      	pop	{r4, r15}
    s->dcf_fd = posix_open(DEV_SSYSTEM, O_RDWR);
  142464:	f245 50cc 	movw	r0, #21964	; 0x55cc
  142468:	2102      	movs	r1, #2
  14246a:	f2c0 0015 	movt	r0, #21
  14246e:	f00a f8a5 	bl	14c5bc <dcf_open>
  142472:	60a0      	str	r0, [r4, #8]
    if (s->dcf_fd < 0) {
  142474:	2800      	cmp	r0, #0
  142476:	db15      	blt.n	1424a4 <ssystem_server_init+0x5c>
    s->main_thread = thread_create("ssystemd", ssystem_process_task, s, HIGH_PRIORITY, SSYSTEMD_STACK_SZ);
  142478:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  14247c:	f242 3145 	movw	r1, #9029	; 0x2345
  142480:	f245 50e8 	movw	r0, #21992	; 0x55e8
  142484:	f2c0 0114 	movt	r1, #20
  142488:	9300      	str	r3, [sp, #0]
  14248a:	4622      	mov	r2, r4
  14248c:	2318      	movs	r3, #24
  14248e:	f2c0 0015 	movt	r0, #21
  142492:	f00d f8cd 	bl	14f630 <thread_create>
  142496:	6060      	str	r0, [r4, #4]
    thread_detach_and_resume(s->main_thread);
  142498:	f00d fc34 	bl	14fd04 <thread_detach_and_resume>
    s->binitialized = true;
  14249c:	2301      	movs	r3, #1
  14249e:	7023      	strb	r3, [r4, #0]
}
  1424a0:	b002      	add	sp, #8
  1424a2:	bd10      	pop	{r4, r15}
        printf("%s: failed", __func__);
  1424a4:	f245 5144 	movw	r1, #21828	; 0x5544
  1424a8:	f245 50dc 	movw	r0, #21980	; 0x55dc
  1424ac:	f2c0 0115 	movt	r1, #21
  1424b0:	f2c0 0015 	movt	r0, #21
}
  1424b4:	b002      	add	sp, #8
  1424b6:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        printf("%s: failed", __func__);
  1424ba:	f011 be1d 	b.w	1540f8 <_printf>
  1424be:	bf00      	nop

001424c0 <clkgen_get_default_config>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_get_default_config(clkgen_default_cfg_t *def_cfg)
{
  1424c0:	4603      	mov	r3, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_get_default_config start...............\n");
    def_cfg->src_sel_mask = 2;
    def_cfg->safety_mode = true;
  1424c2:	2201      	movs	r2, #1
    def_cfg->src_sel_mask = 2;
  1424c4:	2102      	movs	r1, #2
  1424c6:	7001      	strb	r1, [r0, #0]
    return true;
}
  1424c8:	4610      	mov	r0, r2
    def_cfg->safety_mode = true;
  1424ca:	705a      	strb	r2, [r3, #1]
}
  1424cc:	4770      	bx	r14
  1424ce:	bf00      	nop

001424d0 <clkgen_fsrefclk_sel>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_fsrefclk_sel(vaddr_t base, uint32_t scr_idx,
                         uint32_t src_sel_mask, bool safety_mode)
{
  1424d0:	b410      	push	{r4}
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if ((base != SCR_SAF_BASE)
            && (base != SCR_SEC_BASE)) {
  1424d2:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
    if ((base != SCR_SAF_BASE)
  1424d6:	f114 6ffc 	cmn.w	r4, #132120576	; 0x7e00000
        LTRACEF("base paramenter error \n");
        return false;
  1424da:	bf18      	it	ne
  1424dc:	2200      	movne	r2, #0
    if ((base != SCR_SAF_BASE)
  1424de:	d110      	bne.n	142502 <clkgen_fsrefclk_sel+0x32>
    }

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "clkgen_fsrefclk_sel scr_idx:0x%x,src_sel_mask:0x%x,safety_mode:0x%x\n",
                  scr_idx, src_sel_mask, safety_mode);
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  1424e0:	3180      	adds	r1, #128	; 0x80
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
                              CLKGEN_FSREFCLK_FS_XTAL_EN(1)));
    writel(reg_write, scr_base_addr);
    //select clk src:xtal_saf = 0x0U,xtal_ap = 0x1U,rc_24m = 0x2U,
    reg_read = readl(scr_base_addr);
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  1424e2:	f002 0203 	and.w	r2, r2, #3
    scr_base_addr = base + CLKGEN_FSREFCLK_OFF(scr_idx);
  1424e6:	0309      	lsls	r1, r1, #12
    reg_read = readl(scr_base_addr);
  1424e8:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read & (~(CLKGEN_FSREFCLK_FS_RC_EN(1) |
  1424ea:	f024 0418 	bic.w	r4, r4, #24
    writel(reg_write, scr_base_addr);
  1424ee:	500c      	str	r4, [r1, r0]
    reg_read = readl(scr_base_addr);
  1424f0:	580c      	ldr	r4, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_SCR_SEL(src_sel_mask);
  1424f2:	4322      	orrs	r2, r4
    writel(reg_write, scr_base_addr);
  1424f4:	500a      	str	r2, [r1, r0]

    //enable safety mode
    if (safety_mode) {
  1424f6:	b943      	cbnz	r3, 14250a <clkgen_fsrefclk_sel+0x3a>
                                CLKGEN_FSREFCLK_FS_XTAL_EN(1));
        writel(reg_write, scr_base_addr);
    }

    //enable xtal cg gate
    reg_read = readl(scr_base_addr);
  1424f8:	580b      	ldr	r3, [r1, r0]
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
    writel(reg_write, scr_base_addr);
    return true;
  1424fa:	2201      	movs	r2, #1
    reg_write = reg_read | CLKGEN_FSREFCLK_XTAL_CG_EN(1);
  1424fc:	f043 0304 	orr.w	r3, r3, #4
    writel(reg_write, scr_base_addr);
  142500:	500b      	str	r3, [r1, r0]
}
  142502:	f85d 4b04 	ldr.w	r4, [r13], #4
  142506:	4610      	mov	r0, r2
  142508:	4770      	bx	r14
        reg_read = readl(scr_base_addr);
  14250a:	580b      	ldr	r3, [r1, r0]
        reg_write = reg_read | (CLKGEN_FSREFCLK_FS_RC_EN(1) |
  14250c:	f043 0318 	orr.w	r3, r3, #24
        writel(reg_write, scr_base_addr);
  142510:	500b      	str	r3, [r1, r0]
  142512:	e7f1      	b.n	1424f8 <clkgen_fsrefclk_sel+0x28>

00142514 <clkgen_gating_enable>:
//! \return Returns \b true if the rstgen is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool clkgen_gating_enable(vaddr_t base, uint16_t gating_idx, bool enable)
{
  142514:	4603      	mov	r3, r0
    vaddr_t gating_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  142516:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  14251a:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  14251e:	d004      	beq.n	14252a <clkgen_gating_enable+0x16>
  142520:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  142524:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  142528:	d117      	bne.n	14255a <clkgen_gating_enable+0x46>
    gating_base_addr = base + CLKGEN_LP_GATING_EN_OFF(gating_idx);
  14252a:	0309      	lsls	r1, r1, #12
  14252c:	f501 1180 	add.w	r1, r1, #1048576	; 0x100000
{
  142530:	b410      	push	{r4}
    //unlock gating register
    reg_read = readl(gating_base_addr);
  142532:	58c8      	ldr	r0, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_GATING_LOCK_MASK));
  142534:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
    writel(reg_write, gating_base_addr);
  142538:	50c8      	str	r0, [r1, r3]
    //set sw disable
    reg_read = readl(gating_base_addr);
  14253a:	58cc      	ldr	r4, [r1, r3]

    if (enable) {
  14253c:	b932      	cbnz	r2, 14254c <clkgen_gating_enable+0x38>
    else {
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
        writel(reg_write, gating_base_addr);
    }

    return true;
  14253e:	2001      	movs	r0, #1
        reg_write = reg_read | CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK;
  142540:	f044 0202 	orr.w	r2, r4, #2
}
  142544:	f85d 4b04 	ldr.w	r4, [r13], #4
        writel(reg_write, gating_base_addr);
  142548:	50ca      	str	r2, [r1, r3]
}
  14254a:	4770      	bx	r14
    return true;
  14254c:	4610      	mov	r0, r2
        reg_write = reg_read & (~(CLKGEN_LP_GATING_EN_SW_GATING_DIS_MASK));
  14254e:	f024 0402 	bic.w	r4, r4, #2
        writel(reg_write, gating_base_addr);
  142552:	50cc      	str	r4, [r1, r3]
}
  142554:	f85d 4b04 	ldr.w	r4, [r13], #4
  142558:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  14255a:	2000      	movs	r0, #0
}
  14255c:	4770      	bx	r14
  14255e:	bf00      	nop

00142560 <clkgen_ip_slice_set>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_ip_slice_set(vaddr_t base, uint8_t ip_slice_idx,
                         uint8_t clk_src_sel, uint16_t pre_div, uint16_t post_div)
{
  142560:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  142564:	f8bd 7018 	ldrh.w	r7, [r13, #24]
    bool ret = false;
    vaddr_t ip_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  142568:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  14256c:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  142570:	d004      	beq.n	14257c <clkgen_ip_slice_set+0x1c>
  142572:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  142576:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  14257a:	d152      	bne.n	142622 <clkgen_ip_slice_set+0xc2>
    ip_slice_base_addr = base + CLKGEN_IP_SLICE_CTL_OFF(ip_slice_idx);
  14257c:	030e      	lsls	r6, r1, #12
  14257e:	1834      	adds	r4, r6, r0
    //clear pre_en
    reg_read = readl(ip_slice_base_addr);
  142580:	5831      	ldr	r1, [r6, r0]

    if ((reg_read & CLKGEN_IP_SLICE_CTL_CG_EN_MASK) != 0) {
  142582:	07cd      	lsls	r5, r1, #31
  142584:	d50d      	bpl.n	1425a2 <clkgen_ip_slice_set+0x42>
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
        writel(reg_write, ip_slice_base_addr);
  142586:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_IP_SLICE_CTL_CG_EN_MASK);
  142588:	f021 0101 	bic.w	r1, r1, #1
        writel(reg_write, ip_slice_base_addr);
  14258c:	5031      	str	r1, [r6, r0]
  14258e:	e001      	b.n	142594 <clkgen_ip_slice_set+0x34>
    } while (--retrycount);
  142590:	3d01      	subs	r5, #1
  142592:	d006      	beq.n	1425a2 <clkgen_ip_slice_set+0x42>
        v = readl(reg);
  142594:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142596:	00c9      	lsls	r1, r1, #3
  142598:	d5fa      	bpl.n	142590 <clkgen_ip_slice_set+0x30>
    RMWREG32(reg, start, width, setvalue);
  14259a:	5831      	ldr	r1, [r6, r0]
  14259c:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  1425a0:	5031      	str	r1, [r6, r0]
        reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                       1, 1, 0, 100);
    }

    //select clk src
    reg_read = readl(ip_slice_base_addr);
  1425a2:	5835      	ldr	r5, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
                CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL(clk_src_sel);
  1425a4:	0051      	lsls	r1, r2, #1
  1425a6:	f001 010e 	and.w	r1, r1, #14
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_CLK_SRC_SEL_MASK)) |
  1425aa:	f025 020e 	bic.w	r2, r5, #14
  1425ae:	4311      	orrs	r1, r2
    writel(reg_write, ip_slice_base_addr);
    //set pre_en
    reg_read = readl(ip_slice_base_addr);
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
    writel(reg_write, ip_slice_base_addr);
  1425b0:	2264      	movs	r2, #100	; 0x64
    writel(reg_write, ip_slice_base_addr);
  1425b2:	5031      	str	r1, [r6, r0]
    reg_read = readl(ip_slice_base_addr);
  1425b4:	5831      	ldr	r1, [r6, r0]
    reg_write = reg_read | CLKGEN_IP_SLICE_CTL_CG_EN_MASK;
  1425b6:	f041 0101 	orr.w	r1, r1, #1
    writel(reg_write, ip_slice_base_addr);
  1425ba:	5031      	str	r1, [r6, r0]
  1425bc:	e001      	b.n	1425c2 <clkgen_ip_slice_set+0x62>
    } while (--retrycount);
  1425be:	3a01      	subs	r2, #1
  1425c0:	d006      	beq.n	1425d0 <clkgen_ip_slice_set+0x70>
        v = readl(reg);
  1425c2:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1425c4:	00e9      	lsls	r1, r5, #3
  1425c6:	d5fa      	bpl.n	1425be <clkgen_ip_slice_set+0x5e>
    RMWREG32(reg, start, width, setvalue);
  1425c8:	5832      	ldr	r2, [r6, r0]
  1425ca:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  1425ce:	5032      	str	r2, [r6, r0]
    reg_poll_clear(ip_slice_base_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                   1, 1, 0, 100);
    //set pre_div
    reg_read = readl(ip_slice_base_addr);
  1425d0:	5832      	ldr	r2, [r6, r0]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM(pre_div);
  1425d2:	011b      	lsls	r3, r3, #4
  1425d4:	4680      	mov	r8, r0
  1425d6:	f003 0370 	and.w	r3, r3, #112	; 0x70
    writel(reg_write, ip_slice_base_addr);
  1425da:	2564      	movs	r5, #100	; 0x64
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_PRE_DIV_NUM_MASK)) |
  1425dc:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  1425e0:	4313      	orrs	r3, r2
    writel(reg_write, ip_slice_base_addr);
  1425e2:	5033      	str	r3, [r6, r0]
  1425e4:	e003      	b.n	1425ee <clkgen_ip_slice_set+0x8e>
        spin(1);
  1425e6:	f010 fb53 	bl	152c90 <spin>
    } while (--retrycount);
  1425ea:	3d01      	subs	r5, #1
  1425ec:	d003      	beq.n	1425f6 <clkgen_ip_slice_set+0x96>
        v = readl(reg);
  1425ee:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1425f0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1425f2:	005b      	lsls	r3, r3, #1
  1425f4:	d4f7      	bmi.n	1425e6 <clkgen_ip_slice_set+0x86>
    //wait pre_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
    //set post_div
    reg_read = readl(ip_slice_base_addr);
  1425f6:	f856 3008 	ldr.w	r3, [r6, r8]
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  1425fa:	02bf      	lsls	r7, r7, #10
    writel(reg_write, ip_slice_base_addr);
  1425fc:	2564      	movs	r5, #100	; 0x64
                CLKGEN_IP_SLICE_CTL_POST_DIV_NUM(post_div);
  1425fe:	b2bf      	uxth	r7, r7
    reg_write = (reg_read & (~CLKGEN_IP_SLICE_CTL_POST_DIV_NUM_MASK)) |
  142600:	f423 437c 	bic.w	r3, r3, #64512	; 0xfc00
  142604:	431f      	orrs	r7, r3
    writel(reg_write, ip_slice_base_addr);
  142606:	f846 7008 	str.w	r7, [r6, r8]
  14260a:	e003      	b.n	142614 <clkgen_ip_slice_set+0xb4>
        spin(1);
  14260c:	f010 fb40 	bl	152c90 <spin>
    } while (--retrycount);
  142610:	3d01      	subs	r5, #1
  142612:	d006      	beq.n	142622 <clkgen_ip_slice_set+0xc2>
        v = readl(reg);
  142614:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142616:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142618:	2b00      	cmp	r3, #0
  14261a:	dbf7      	blt.n	14260c <clkgen_ip_slice_set+0xac>
            return true;
  14261c:	2001      	movs	r0, #1
    //wait post_upd_ack is 0
    ret = reg_poll_value(ip_slice_base_addr,
                         CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    return ret;
}
  14261e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    CLKGEN_ASSERT_PARAMETER(base);
  142622:	2000      	movs	r0, #0
}
  142624:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00142628 <clkgen_ip_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

    // Check the arguments.
    if (ctl) {
  142628:	b112      	cbz	r2, 142630 <clkgen_ip_ctl_get+0x8>
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  14262a:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  14262c:	580b      	ldr	r3, [r1, r0]
  14262e:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  142630:	2001      	movs	r0, #1
  142632:	4770      	bx	r14

00142634 <clkgen_ip_ctl_set>:
{
    bool ret = true;
    vaddr_t slice_addr;
    clkgen_ip_ctl v;

    if (ctl) {
  142634:	2a00      	cmp	r2, #0
  142636:	d051      	beq.n	1426dc <clkgen_ip_ctl_set+0xa8>
{
  142638:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        slice_addr = base + CLKGEN_IP_SLICE_CTL_OFF(slice_idx);
  14263c:	030e      	lsls	r6, r1, #12
  14263e:	1834      	adds	r4, r6, r0
        //clear pre_en
        v.val = readl(slice_addr);
  142640:	5837      	ldr	r7, [r6, r0]

        if (v.cg_en != 0) {
  142642:	07fb      	lsls	r3, r7, #31
  142644:	d50d      	bpl.n	142662 <clkgen_ip_ctl_set+0x2e>
            v.cg_en = 0;
            writel(v.val, slice_addr);
  142646:	2364      	movs	r3, #100	; 0x64
            v.cg_en = 0;
  142648:	f36f 0700 	bfc	r7, #0, #1
            writel(v.val, slice_addr);
  14264c:	5037      	str	r7, [r6, r0]
  14264e:	e001      	b.n	142654 <clkgen_ip_ctl_set+0x20>
    } while (--retrycount);
  142650:	3b01      	subs	r3, #1
  142652:	d006      	beq.n	142662 <clkgen_ip_ctl_set+0x2e>
        v = readl(reg);
  142654:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142656:	00cd      	lsls	r5, r1, #3
  142658:	d5fa      	bpl.n	142650 <clkgen_ip_ctl_set+0x1c>
    RMWREG32(reg, start, width, setvalue);
  14265a:	5833      	ldr	r3, [r6, r0]
  14265c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  142660:	5033      	str	r3, [r6, r0]
            ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                                  1, 1, 0, 100);
        }

        //select clk src
        v.src_sel = ctl->src_sel;
  142662:	7813      	ldrb	r3, [r2, #0]
  142664:	f3c3 0342 	ubfx	r3, r3, #1, #3
  142668:	f363 0743 	bfi	r7, r3, #1, #3
        writel(v.val, slice_addr);
        //set pre_en
        v.cg_en = ctl->cg_en;
        writel(v.val, slice_addr);
  14266c:	2364      	movs	r3, #100	; 0x64
        writel(v.val, slice_addr);
  14266e:	5037      	str	r7, [r6, r0]
        v.cg_en = ctl->cg_en;
  142670:	7811      	ldrb	r1, [r2, #0]
  142672:	f3c1 0100 	ubfx	r1, r1, #0, #1
  142676:	f361 0700 	bfi	r7, r1, #0, #1
        writel(v.val, slice_addr);
  14267a:	5037      	str	r7, [r6, r0]
  14267c:	e001      	b.n	142682 <clkgen_ip_ctl_set+0x4e>
    } while (--retrycount);
  14267e:	3b01      	subs	r3, #1
  142680:	d006      	beq.n	142690 <clkgen_ip_ctl_set+0x5c>
        v = readl(reg);
  142682:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142684:	00e9      	lsls	r1, r5, #3
  142686:	d5fa      	bpl.n	14267e <clkgen_ip_ctl_set+0x4a>
    RMWREG32(reg, start, width, setvalue);
  142688:	5833      	ldr	r3, [r6, r0]
  14268a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  14268e:	5033      	str	r3, [r6, r0]
        ret |= reg_poll_clear(slice_addr, CLKGEN_IP_SLICE_CTL_CG_EN_STATUS_SHIFT,
                              1, 1, 0, 100);
        //set pre_div
        v.pre_div_num = ctl->pre_div_num;
  142690:	7813      	ldrb	r3, [r2, #0]
  142692:	4691      	mov	r9, r2
  142694:	4680      	mov	r8, r0
  142696:	f3c3 1302 	ubfx	r3, r3, #4, #3
        writel(v.val, slice_addr);
  14269a:	2564      	movs	r5, #100	; 0x64
        v.pre_div_num = ctl->pre_div_num;
  14269c:	f363 1706 	bfi	r7, r3, #4, #3
        writel(v.val, slice_addr);
  1426a0:	5037      	str	r7, [r6, r0]
  1426a2:	e003      	b.n	1426ac <clkgen_ip_ctl_set+0x78>
        spin(1);
  1426a4:	f010 faf4 	bl	152c90 <spin>
    } while (--retrycount);
  1426a8:	3d01      	subs	r5, #1
  1426aa:	d003      	beq.n	1426b4 <clkgen_ip_ctl_set+0x80>
        v = readl(reg);
  1426ac:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1426ae:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1426b0:	005b      	lsls	r3, r3, #1
  1426b2:	d4f7      	bmi.n	1426a4 <clkgen_ip_ctl_set+0x70>
        //wait pre_upd_ack is 0
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_PRE_BUSY_SHIFT, 1, 0, 100);
        //set post_div
        v.post_div_num = ctl->post_div_num;
  1426b4:	f899 3001 	ldrb.w	r3, [r9, #1]
        writel(v.val, slice_addr);
  1426b8:	2564      	movs	r5, #100	; 0x64
        v.post_div_num = ctl->post_div_num;
  1426ba:	089b      	lsrs	r3, r3, #2
  1426bc:	f363 278f 	bfi	r7, r3, #10, #6
        writel(v.val, slice_addr);
  1426c0:	f846 7008 	str.w	r7, [r6, r8]
  1426c4:	e003      	b.n	1426ce <clkgen_ip_ctl_set+0x9a>
        spin(1);
  1426c6:	f010 fae3 	bl	152c90 <spin>
    } while (--retrycount);
  1426ca:	3d01      	subs	r5, #1
  1426cc:	d008      	beq.n	1426e0 <clkgen_ip_ctl_set+0xac>
        v = readl(reg);
  1426ce:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1426d0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1426d2:	2b00      	cmp	r3, #0
  1426d4:	dbf7      	blt.n	1426c6 <clkgen_ip_ctl_set+0x92>
    bool ret = true;
  1426d6:	2001      	movs	r0, #1
        ret = reg_poll_value(slice_addr,
                             CLKGEN_IP_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  1426d8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    bool ret = true;
  1426dc:	2001      	movs	r0, #1
}
  1426de:	4770      	bx	r14
    return false;
  1426e0:	4628      	mov	r0, r5
  1426e2:	e7f9      	b.n	1426d8 <clkgen_ip_ctl_set+0xa4>

001426e4 <clkgen_bus_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_bus_slice_switch(vaddr_t base,
                             clkgen_bus_slice_drv_t *bus_clk_cfg)
{
  1426e4:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    vaddr_t bus_gasket_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1426e8:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  1426ec:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  1426f0:	d007      	beq.n	142702 <clkgen_bus_slice_switch+0x1e>
  1426f2:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  1426f6:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  1426fa:	bf18      	it	ne
  1426fc:	2000      	movne	r0, #0
  1426fe:	f040 808a 	bne.w	142816 <clkgen_bus_slice_switch+0x132>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  142702:	680b      	ldr	r3, [r1, #0]
  142704:	4688      	mov	r8, r1
  142706:	4606      	mov	r6, r0
  142708:	3340      	adds	r3, #64	; 0x40
  14270a:	035f      	lsls	r7, r3, #13
                              bus_clk_cfg->bus_slice_idx);
    bus_gasket_slice_base_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(
  14270c:	f507 5380 	add.w	r3, r7, #4096	; 0x1000
  142710:	eb03 0900 	add.w	r9, r3, r0
                                     bus_clk_cfg->bus_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(bus_slice_base_addr);
  142714:	583a      	ldr	r2, [r7, r0]
    bus_slice_base_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(
  142716:	183c      	adds	r4, r7, r0
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
        (a_b_sel == bus_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(bus_slice_base_addr);
  142718:	5839      	ldr	r1, [r7, r0]
    if (/*(bus_clk_cfg->clk_a_b_switch == bus_clk_a_b_sel_b) &&*/
  14271a:	0595      	lsls	r5, r2, #22
  14271c:	d47d      	bmi.n	14281a <clkgen_bus_slice_switch+0x136>

        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK) != 0) {
  14271e:	03c8      	lsls	r0, r1, #15
  142720:	d50d      	bpl.n	14273e <clkgen_bus_slice_switch+0x5a>
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, bus_slice_base_addr);
  142722:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK);
  142724:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
            writel(reg_write, bus_slice_base_addr);
  142728:	51b9      	str	r1, [r7, r6]
  14272a:	e001      	b.n	142730 <clkgen_bus_slice_switch+0x4c>
    } while (--retrycount);
  14272c:	3a01      	subs	r2, #1
  14272e:	d006      	beq.n	14273e <clkgen_bus_slice_switch+0x5a>
        v = readl(reg);
  142730:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142732:	0109      	lsls	r1, r1, #4
  142734:	d5fa      	bpl.n	14272c <clkgen_bus_slice_switch+0x48>
    RMWREG32(reg, start, width, setvalue);
  142736:	59ba      	ldr	r2, [r7, r6]
  142738:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  14273c:	51ba      	str	r2, [r7, r6]
                    & (~(CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM_MASK
                         | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM_MASK));
        reg_write = reg_write
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  14273e:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  142742:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  142746:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  142748:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  14274c:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  14274e:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  142752:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  142756:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  14275a:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  14275c:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  142760:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  142762:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  142764:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  142766:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  142768:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  14276c:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  142770:	4302      	orrs	r2, r0
        reg_write = reg_read
  142772:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  142776:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  142778:	519a      	str	r2, [r3, r6]
  14277a:	e003      	b.n	142784 <clkgen_bus_slice_switch+0xa0>
        spin(1);
  14277c:	f010 fa88 	bl	152c90 <spin>
    } while (--retrycount);
  142780:	3d01      	subs	r5, #1
  142782:	d004      	beq.n	14278e <clkgen_bus_slice_switch+0xaa>
        v = readl(reg);
  142784:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  142788:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  14278a:	0f1b      	lsrs	r3, r3, #28
  14278c:	d1f6      	bne.n	14277c <clkgen_bus_slice_switch+0x98>
        ret = reg_poll_value(bus_gasket_slice_base_addr,
                             CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  14278e:	f898 2006 	ldrb.w	r2, [r8, #6]
        reg_read = readl(bus_slice_base_addr);
  142792:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B(bus_clk_cfg->clk_src_sel_b)
  142794:	0452      	lsls	r2, r2, #17
  142796:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  14279a:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  14279e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  1427a2:	431a      	orrs	r2, r3
                    | CLKGEN_BUS_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, bus_slice_base_addr);
  1427a4:	2364      	movs	r3, #100	; 0x64
  1427a6:	51ba      	str	r2, [r7, r6]
  1427a8:	e001      	b.n	1427ae <clkgen_bus_slice_switch+0xca>
    } while (--retrycount);
  1427aa:	3b01      	subs	r3, #1
  1427ac:	d006      	beq.n	1427bc <clkgen_bus_slice_switch+0xd8>
        v = readl(reg);
  1427ae:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1427b0:	0112      	lsls	r2, r2, #4
  1427b2:	d5fa      	bpl.n	1427aa <clkgen_bus_slice_switch+0xc6>
    RMWREG32(reg, start, width, setvalue);
  1427b4:	59bb      	ldr	r3, [r7, r6]
  1427b6:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  1427ba:	51bb      	str	r3, [r7, r6]
        reg_poll_clear(bus_slice_base_addr,
                       CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
  1427bc:	59ba      	ldr	r2, [r7, r6]
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  1427be:	f898 3008 	ldrb.w	r3, [r8, #8]
        writel(reg_write, bus_slice_base_addr);
  1427c2:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B(bus_clk_cfg->pre_div_b);
  1427c4:	051b      	lsls	r3, r3, #20
  1427c6:	f403 03e0 	and.w	r3, r3, #7340032	; 0x700000
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_B_MASK))
  1427ca:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
  1427ce:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1427d0:	51bb      	str	r3, [r7, r6]
  1427d2:	e003      	b.n	1427dc <clkgen_bus_slice_switch+0xf8>
        spin(1);
  1427d4:	f010 fa5c 	bl	152c90 <spin>
    } while (--retrycount);
  1427d8:	3d01      	subs	r5, #1
  1427da:	d003      	beq.n	1427e4 <clkgen_bus_slice_switch+0x100>
        v = readl(reg);
  1427dc:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1427de:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1427e0:	009b      	lsls	r3, r3, #2
  1427e2:	d4f7      	bmi.n	1427d4 <clkgen_bus_slice_switch+0xf0>
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(bus_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1427e4:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  1427e8:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  1427ea:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1427ec:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1427ee:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1427f2:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1427f4:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1427f6:	51bb      	str	r3, [r7, r6]
  1427f8:	e004      	b.n	142804 <clkgen_bus_slice_switch+0x120>
        spin(1);
  1427fa:	f010 fa49 	bl	152c90 <spin>
    } while (--retrycount);
  1427fe:	3d01      	subs	r5, #1
  142800:	f000 808a 	beq.w	142918 <clkgen_bus_slice_switch+0x234>
        v = readl(reg);
  142804:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142806:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142808:	2b00      	cmp	r3, #0
  14280a:	dbf6      	blt.n	1427fa <clkgen_bus_slice_switch+0x116>
            return true;
  14280c:	2001      	movs	r0, #1
        ret = reg_poll_value(bus_slice_base_addr,
                             CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(bus_slice_base_addr);
  14280e:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read | CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK;
  142810:	f443 7300 	orr.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  142814:	51bb      	str	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
        writel(reg_write, bus_slice_base_addr);
    }

    return ret;
}
  142816:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        if ((reg_read & CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK) != 0) {
  14281a:	07c8      	lsls	r0, r1, #31
  14281c:	d50d      	bpl.n	14283a <clkgen_bus_slice_switch+0x156>
            writel(reg_write, bus_slice_base_addr);
  14281e:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_CG_EN_A_MASK);
  142820:	f021 0101 	bic.w	r1, r1, #1
            writel(reg_write, bus_slice_base_addr);
  142824:	51b9      	str	r1, [r7, r6]
  142826:	e001      	b.n	14282c <clkgen_bus_slice_switch+0x148>
    } while (--retrycount);
  142828:	3a01      	subs	r2, #1
  14282a:	d006      	beq.n	14283a <clkgen_bus_slice_switch+0x156>
        v = readl(reg);
  14282c:	6821      	ldr	r1, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  14282e:	00c9      	lsls	r1, r1, #3
  142830:	d5fa      	bpl.n	142828 <clkgen_bus_slice_switch+0x144>
    RMWREG32(reg, start, width, setvalue);
  142832:	59ba      	ldr	r2, [r7, r6]
  142834:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  142838:	51ba      	str	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  14283a:	f898 200a 	ldrb.w	r2, [r8, #10]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  14283e:	f898 100b 	ldrb.w	r1, [r8, #11]
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  142842:	0252      	lsls	r2, r2, #9
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  142844:	f898 500d 	ldrb.w	r5, [r8, #13]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  142848:	0189      	lsls	r1, r1, #6
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  14284a:	f898 000c 	ldrb.w	r0, [r8, #12]
                    | CLKGEN_BUS_SLICE_GASKET_N_DIV_NUM(bus_clk_cfg->gasket_cfg.n_div_num)
  14284e:	f401 71e0 	and.w	r1, r1, #448	; 0x1c0
                    | CLKGEN_BUS_SLICE_GASKET_M_DIV_NUM(bus_clk_cfg->gasket_cfg.m_div_num)
  142852:	f402 6260 	and.w	r2, r2, #3584	; 0xe00
        reg_write = reg_write
  142856:	430a      	orrs	r2, r1
                    | CLKGEN_BUS_SLICE_GASKET_Q_DIV_NUM(bus_clk_cfg->gasket_cfg.q_div_num);
  142858:	f005 0107 	and.w	r1, r5, #7
        reg_write = reg_write
  14285c:	430a      	orrs	r2, r1
        reg_read = readl(bus_gasket_slice_base_addr);
  14285e:	5999      	ldr	r1, [r3, r6]
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  142860:	00c0      	lsls	r0, r0, #3
        writel(reg_write, bus_gasket_slice_base_addr);
  142862:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_GASKET_P_DIV_NUM(bus_clk_cfg->gasket_cfg.p_div_num)
  142864:	f000 0038 	and.w	r0, r0, #56	; 0x38
        reg_write = reg_read
  142868:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
        reg_write = reg_write
  14286c:	4302      	orrs	r2, r0
        reg_write = reg_read
  14286e:	f021 010f 	bic.w	r1, r1, #15
        reg_write = reg_write
  142872:	430a      	orrs	r2, r1
        writel(reg_write, bus_gasket_slice_base_addr);
  142874:	519a      	str	r2, [r3, r6]
  142876:	e003      	b.n	142880 <clkgen_bus_slice_switch+0x19c>
        spin(1);
  142878:	f010 fa0a 	bl	152c90 <spin>
    } while (--retrycount);
  14287c:	3d01      	subs	r5, #1
  14287e:	d004      	beq.n	14288a <clkgen_bus_slice_switch+0x1a6>
        v = readl(reg);
  142880:	f8d9 3000 	ldr.w	r3, [r9]
        spin(1);
  142884:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142886:	0f1b      	lsrs	r3, r3, #28
  142888:	d1f6      	bne.n	142878 <clkgen_bus_slice_switch+0x194>
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  14288a:	f898 2005 	ldrb.w	r2, [r8, #5]
        reg_read = readl(bus_slice_base_addr);
  14288e:	59bb      	ldr	r3, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A(bus_clk_cfg->clk_src_sel_a)
  142890:	0052      	lsls	r2, r2, #1
  142892:	f002 020e 	and.w	r2, r2, #14
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  142896:	f023 030e 	bic.w	r3, r3, #14
  14289a:	f042 0201 	orr.w	r2, r2, #1
  14289e:	431a      	orrs	r2, r3
        writel(reg_write, bus_slice_base_addr);
  1428a0:	2364      	movs	r3, #100	; 0x64
  1428a2:	51ba      	str	r2, [r7, r6]
  1428a4:	e001      	b.n	1428aa <clkgen_bus_slice_switch+0x1c6>
    } while (--retrycount);
  1428a6:	3b01      	subs	r3, #1
  1428a8:	d006      	beq.n	1428b8 <clkgen_bus_slice_switch+0x1d4>
        v = readl(reg);
  1428aa:	6822      	ldr	r2, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1428ac:	00d2      	lsls	r2, r2, #3
  1428ae:	d5fa      	bpl.n	1428a6 <clkgen_bus_slice_switch+0x1c2>
    RMWREG32(reg, start, width, setvalue);
  1428b0:	59bb      	ldr	r3, [r7, r6]
  1428b2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  1428b6:	51bb      	str	r3, [r7, r6]
        reg_read = readl(bus_slice_base_addr);
  1428b8:	59ba      	ldr	r2, [r7, r6]
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  1428ba:	f898 3007 	ldrb.w	r3, [r8, #7]
        writel(reg_write, bus_slice_base_addr);
  1428be:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A(bus_clk_cfg->pre_div_a);
  1428c0:	011b      	lsls	r3, r3, #4
  1428c2:	f003 0370 	and.w	r3, r3, #112	; 0x70
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_PRE_DIV_NUM_A_MASK))
  1428c6:	f022 0270 	bic.w	r2, r2, #112	; 0x70
  1428ca:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1428cc:	51bb      	str	r3, [r7, r6]
  1428ce:	e003      	b.n	1428d8 <clkgen_bus_slice_switch+0x1f4>
        spin(1);
  1428d0:	f010 f9de 	bl	152c90 <spin>
    } while (--retrycount);
  1428d4:	3d01      	subs	r5, #1
  1428d6:	d003      	beq.n	1428e0 <clkgen_bus_slice_switch+0x1fc>
        v = readl(reg);
  1428d8:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1428da:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1428dc:	005b      	lsls	r3, r3, #1
  1428de:	d4f7      	bmi.n	1428d0 <clkgen_bus_slice_switch+0x1ec>
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1428e0:	f898 3009 	ldrb.w	r3, [r8, #9]
        reg_read = readl(bus_slice_base_addr);
  1428e4:	59ba      	ldr	r2, [r7, r6]
        writel(reg_write, bus_slice_base_addr);
  1428e6:	2564      	movs	r5, #100	; 0x64
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1428e8:	029b      	lsls	r3, r3, #10
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1428ea:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
                    | CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM(bus_clk_cfg->post_div);
  1428ee:	b29b      	uxth	r3, r3
        reg_write = (reg_read & (~CLKGEN_BUS_SLICE_CTL_POST_DIV_NUM_MASK))
  1428f0:	4313      	orrs	r3, r2
        writel(reg_write, bus_slice_base_addr);
  1428f2:	51bb      	str	r3, [r7, r6]
  1428f4:	e003      	b.n	1428fe <clkgen_bus_slice_switch+0x21a>
        spin(1);
  1428f6:	f010 f9cb 	bl	152c90 <spin>
    } while (--retrycount);
  1428fa:	3d01      	subs	r5, #1
  1428fc:	d00a      	beq.n	142914 <clkgen_bus_slice_switch+0x230>
        v = readl(reg);
  1428fe:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142900:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142902:	2b00      	cmp	r3, #0
  142904:	dbf7      	blt.n	1428f6 <clkgen_bus_slice_switch+0x212>
            return true;
  142906:	2001      	movs	r0, #1
        reg_read = readl(bus_slice_base_addr);
  142908:	59bb      	ldr	r3, [r7, r6]
        reg_write = reg_read & (~CLKGEN_BUS_SLICE_CTL_A_B_SEL_MASK);
  14290a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
        writel(reg_write, bus_slice_base_addr);
  14290e:	51bb      	str	r3, [r7, r6]
}
  142910:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    return false;
  142914:	4628      	mov	r0, r5
  142916:	e7f7      	b.n	142908 <clkgen_bus_slice_switch+0x224>
  142918:	4628      	mov	r0, r5
  14291a:	e778      	b.n	14280e <clkgen_bus_slice_switch+0x12a>

0014291c <clkgen_bus_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  14291c:	b17a      	cbz	r2, 14293e <clkgen_bus_ctl_get+0x22>
{
  14291e:	b410      	push	{r4}
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  142920:	f101 0440 	add.w	r4, r1, #64	; 0x40
  142924:	0364      	lsls	r4, r4, #13
        ctl->val = readl(slice_addr);
  142926:	5824      	ldr	r4, [r4, r0]
  142928:	6014      	str	r4, [r2, #0]
    }

    if (gasket) {
  14292a:	b123      	cbz	r3, 142936 <clkgen_bus_ctl_get+0x1a>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  14292c:	0349      	lsls	r1, r1, #13
  14292e:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  142932:	580a      	ldr	r2, [r1, r0]
  142934:	601a      	str	r2, [r3, #0]
    }

    return ret;
}
  142936:	f85d 4b04 	ldr.w	r4, [r13], #4
  14293a:	2001      	movs	r0, #1
  14293c:	4770      	bx	r14
    if (gasket) {
  14293e:	b123      	cbz	r3, 14294a <clkgen_bus_ctl_get+0x2e>
        slice_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142940:	0349      	lsls	r1, r1, #13
  142942:	f501 2101 	add.w	r1, r1, #528384	; 0x81000
        gasket->val = readl(slice_addr);
  142946:	580a      	ldr	r2, [r1, r0]
  142948:	601a      	str	r2, [r3, #0]
}
  14294a:	2001      	movs	r0, #1
  14294c:	4770      	bx	r14
  14294e:	bf00      	nop

00142950 <clkgen_bus_ctl_set>:
                        const clkgen_bus_gasket *gasket)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  142950:	2a00      	cmp	r2, #0
  142952:	f000 80ec 	beq.w	142b2e <clkgen_bus_ctl_set+0x1de>
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  142956:	3140      	adds	r1, #64	; 0x40
{
  142958:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14295c:	4691      	mov	r9, r2
        slice_addr = base + CLKGEN_BUS_SLICE_CTL_OFF(slice_idx);
  14295e:	ea4f 3841 	mov.w	r8, r1, lsl #13
  142962:	4607      	mov	r7, r0
  142964:	00c9      	lsls	r1, r1, #3
  142966:	eb08 0500 	add.w	r5, r8, r0
        clkgen_bus_ctl v;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        v.val = readl(slice_addr);
  14296a:	f858 6000 	ldr.w	r6, [r8, r0]

        if (v.a_b_sel == 0) {
  14296e:	f3c6 2207 	ubfx	r2, r6, #8, #8
  142972:	f012 0202 	ands.w	r2, r2, #2
  142976:	d16e      	bne.n	142a56 <clkgen_bus_ctl_set+0x106>
            //set pre_en_b to 0x0,disable the clock
            if (v.cg_en_b != 0) {
  142978:	03f4      	lsls	r4, r6, #15
  14297a:	f100 80ec 	bmi.w	142b56 <clkgen_bus_ctl_set+0x206>
                reg_poll_clear(slice_addr, CLKGEN_BUS_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1,
                               0, 100);
            }

            //set m/n/p/q div
            if (gasket) {
  14297e:	b31b      	cbz	r3, 1429c8 <clkgen_bus_ctl_set+0x78>
                vaddr_t g_addr;
                clkgen_bus_gasket g;
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142980:	3104      	adds	r1, #4
                g.val = readl(g_addr);
                g.m_div_num = gasket->m_div_num;
                g.n_div_num = gasket->n_div_num;
                g.p_div_num = gasket->p_div_num;
  142982:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  142984:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  142986:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142988:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  14298a:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  14298e:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  142992:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  142994:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  142998:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  14299c:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  1429a0:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  1429a4:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  1429a8:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  1429ac:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  1429ae:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  1429b2:	51cb      	str	r3, [r1, r7]
  1429b4:	e003      	b.n	1429be <clkgen_bus_ctl_set+0x6e>
        spin(1);
  1429b6:	f010 f96b 	bl	152c90 <spin>
    } while (--retrycount);
  1429ba:	3c01      	subs	r4, #1
  1429bc:	d004      	beq.n	1429c8 <clkgen_bus_ctl_set+0x78>
        v = readl(reg);
  1429be:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  1429c2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1429c4:	0f1b      	lsrs	r3, r3, #28
  1429c6:	d1f6      	bne.n	1429b6 <clkgen_bus_ctl_set+0x66>
                ret = reg_poll_value(g_addr,
                                     CLKGEN_BUS_SLICE_GASKET_DIV_Q_BUSY_SHIFT, 4, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            v.src_sel_b = ctl->src_sel_a;
  1429c8:	f899 3000 	ldrb.w	r3, [r9]
  1429cc:	f3c3 0242 	ubfx	r2, r3, #1, #3
  1429d0:	f362 4653 	bfi	r6, r2, #17, #3
            v.cg_en_b = ctl->cg_en_a;
  1429d4:	f3c3 0200 	ubfx	r2, r3, #0, #1
  1429d8:	f362 4610 	bfi	r6, r2, #16, #1

            if (v.cg_en_b != 0) {
  1429dc:	03f1      	lsls	r1, r6, #15
  1429de:	d511      	bpl.n	142a04 <clkgen_bus_ctl_set+0xb4>
                writel(v.val, slice_addr);
  1429e0:	f848 6007 	str.w	r6, [r8, r7]
  1429e4:	2364      	movs	r3, #100	; 0x64
  1429e6:	e002      	b.n	1429ee <clkgen_bus_ctl_set+0x9e>
    } while (--retrycount);
  1429e8:	3b01      	subs	r3, #1
  1429ea:	f000 80cb 	beq.w	142b84 <clkgen_bus_ctl_set+0x234>
        v = readl(reg);
  1429ee:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  1429f0:	0112      	lsls	r2, r2, #4
  1429f2:	d5f9      	bpl.n	1429e8 <clkgen_bus_ctl_set+0x98>
    RMWREG32(reg, start, width, setvalue);
  1429f4:	f858 3007 	ldr.w	r3, [r8, r7]
  1429f8:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
  1429fc:	f848 3007 	str.w	r3, [r8, r7]
  142a00:	f899 3000 	ldrb.w	r3, [r9]
                               0, 100);
            }

            //set pre_div_num_b,check pre_upd_ack_b bit 1 means update not finished yes,0 means update finished.
            v.pre_div_num_b = ctl->pre_div_num_a;
            writel(v.val, slice_addr);
  142a04:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_b = ctl->pre_div_num_a;
  142a06:	f3c3 1302 	ubfx	r3, r3, #4, #3
  142a0a:	f363 5616 	bfi	r6, r3, #20, #3
            writel(v.val, slice_addr);
  142a0e:	f848 6007 	str.w	r6, [r8, r7]
  142a12:	e003      	b.n	142a1c <clkgen_bus_ctl_set+0xcc>
        spin(1);
  142a14:	f010 f93c 	bl	152c90 <spin>
    } while (--retrycount);
  142a18:	3c01      	subs	r4, #1
  142a1a:	d003      	beq.n	142a24 <clkgen_bus_ctl_set+0xd4>
        v = readl(reg);
  142a1c:	682b      	ldr	r3, [r5, #0]
        spin(1);
  142a1e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142a20:	009b      	lsls	r3, r3, #2
  142a22:	d4f7      	bmi.n	142a14 <clkgen_bus_ctl_set+0xc4>
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_PRE_BUSY_B_SHIFT, 1, 0, 100);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            v.post_div_num = ctl->post_div_num;
  142a24:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  142a28:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  142a2a:	089b      	lsrs	r3, r3, #2
  142a2c:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  142a30:	f848 6007 	str.w	r6, [r8, r7]
  142a34:	e004      	b.n	142a40 <clkgen_bus_ctl_set+0xf0>
        spin(1);
  142a36:	f010 f92b 	bl	152c90 <spin>
    } while (--retrycount);
  142a3a:	3c01      	subs	r4, #1
  142a3c:	f000 809e 	beq.w	142b7c <clkgen_bus_ctl_set+0x22c>
        v = readl(reg);
  142a40:	682b      	ldr	r3, [r5, #0]
        spin(1);
  142a42:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142a44:	2b00      	cmp	r3, #0
  142a46:	dbf6      	blt.n	142a36 <clkgen_bus_ctl_set+0xe6>
            return true;
  142a48:	2001      	movs	r0, #1
            ret = reg_poll_value(slice_addr,
                                 CLKGEN_BUS_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
            //invert pre_a_b_sel
            v.a_b_sel = 1;
  142a4a:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(v.val, slice_addr);
  142a4e:	f848 6007 	str.w	r6, [r8, r7]
            writel(v.val, slice_addr);
        }
    }

    return ret;
}
  142a52:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            if (v.cg_en_a != 0) {
  142a56:	07f4      	lsls	r4, r6, #31
  142a58:	d46b      	bmi.n	142b32 <clkgen_bus_ctl_set+0x1e2>
            if (gasket) {
  142a5a:	b31b      	cbz	r3, 142aa4 <clkgen_bus_ctl_set+0x154>
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142a5c:	3104      	adds	r1, #4
                g.p_div_num = gasket->p_div_num;
  142a5e:	781a      	ldrb	r2, [r3, #0]
                g.m_div_num = gasket->m_div_num;
  142a60:	785c      	ldrb	r4, [r3, #1]
                g.n_div_num = gasket->n_div_num;
  142a62:	8818      	ldrh	r0, [r3, #0]
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142a64:	0289      	lsls	r1, r1, #10
                g.m_div_num = gasket->m_div_num;
  142a66:	f3c4 0442 	ubfx	r4, r4, #1, #3
                g.n_div_num = gasket->n_div_num;
  142a6a:	f3c0 1082 	ubfx	r0, r0, #6, #3
                g.val = readl(g_addr);
  142a6e:	59cb      	ldr	r3, [r1, r7]
                g.p_div_num = gasket->p_div_num;
  142a70:	f3c2 0cc2 	ubfx	r12, r2, #3, #3
                g.q_div_num = gasket->q_div_num;
  142a74:	f3c2 0202 	ubfx	r2, r2, #0, #3
                g.m_div_num = gasket->m_div_num;
  142a78:	f364 234b 	bfi	r3, r4, #9, #3
                g.n_div_num = gasket->n_div_num;
  142a7c:	f360 1388 	bfi	r3, r0, #6, #3
                g.p_div_num = gasket->p_div_num;
  142a80:	f36c 03c5 	bfi	r3, r12, #3, #3
                g.q_div_num = gasket->q_div_num;
  142a84:	f362 0302 	bfi	r3, r2, #0, #3
                writel(g.val, g_addr);
  142a88:	2464      	movs	r4, #100	; 0x64
                g_addr = base + CLKGEN_BUS_SLICE_GASKET_OFF(slice_idx);
  142a8a:	eb01 0a07 	add.w	r10, r1, r7
                writel(g.val, g_addr);
  142a8e:	51cb      	str	r3, [r1, r7]
  142a90:	e003      	b.n	142a9a <clkgen_bus_ctl_set+0x14a>
        spin(1);
  142a92:	f010 f8fd 	bl	152c90 <spin>
    } while (--retrycount);
  142a96:	3c01      	subs	r4, #1
  142a98:	d004      	beq.n	142aa4 <clkgen_bus_ctl_set+0x154>
        v = readl(reg);
  142a9a:	f8da 3000 	ldr.w	r3, [r10]
        spin(1);
  142a9e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142aa0:	0f1b      	lsrs	r3, r3, #28
  142aa2:	d1f6      	bne.n	142a92 <clkgen_bus_ctl_set+0x142>
            v.src_sel_a = ctl->src_sel_a;
  142aa4:	f899 3000 	ldrb.w	r3, [r9]
  142aa8:	f3c3 0242 	ubfx	r2, r3, #1, #3
  142aac:	f362 0643 	bfi	r6, r2, #1, #3
            v.cg_en_a = ctl->cg_en_a;
  142ab0:	f3c3 0200 	ubfx	r2, r3, #0, #1
  142ab4:	f362 0600 	bfi	r6, r2, #0, #1
            if (v.cg_en_a != 0) {
  142ab8:	07f1      	lsls	r1, r6, #31
  142aba:	d510      	bpl.n	142ade <clkgen_bus_ctl_set+0x18e>
                writel(v.val, slice_addr);
  142abc:	f848 6007 	str.w	r6, [r8, r7]
  142ac0:	2364      	movs	r3, #100	; 0x64
  142ac2:	e001      	b.n	142ac8 <clkgen_bus_ctl_set+0x178>
    } while (--retrycount);
  142ac4:	3b01      	subs	r3, #1
  142ac6:	d060      	beq.n	142b8a <clkgen_bus_ctl_set+0x23a>
        v = readl(reg);
  142ac8:	682a      	ldr	r2, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142aca:	00d2      	lsls	r2, r2, #3
  142acc:	d5fa      	bpl.n	142ac4 <clkgen_bus_ctl_set+0x174>
    RMWREG32(reg, start, width, setvalue);
  142ace:	f858 3007 	ldr.w	r3, [r8, r7]
  142ad2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  142ad6:	f848 3007 	str.w	r3, [r8, r7]
  142ada:	f899 3000 	ldrb.w	r3, [r9]
            writel(v.val, slice_addr);
  142ade:	2464      	movs	r4, #100	; 0x64
            v.pre_div_num_a = ctl->pre_div_num_a;
  142ae0:	f3c3 1302 	ubfx	r3, r3, #4, #3
  142ae4:	f363 1606 	bfi	r6, r3, #4, #3
            writel(v.val, slice_addr);
  142ae8:	f848 6007 	str.w	r6, [r8, r7]
  142aec:	e003      	b.n	142af6 <clkgen_bus_ctl_set+0x1a6>
        spin(1);
  142aee:	f010 f8cf 	bl	152c90 <spin>
    } while (--retrycount);
  142af2:	3c01      	subs	r4, #1
  142af4:	d003      	beq.n	142afe <clkgen_bus_ctl_set+0x1ae>
        v = readl(reg);
  142af6:	682b      	ldr	r3, [r5, #0]
        spin(1);
  142af8:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142afa:	005b      	lsls	r3, r3, #1
  142afc:	d4f7      	bmi.n	142aee <clkgen_bus_ctl_set+0x19e>
            v.post_div_num = ctl->post_div_num;
  142afe:	f899 3001 	ldrb.w	r3, [r9, #1]
            writel(v.val, slice_addr);
  142b02:	2464      	movs	r4, #100	; 0x64
            v.post_div_num = ctl->post_div_num;
  142b04:	089b      	lsrs	r3, r3, #2
  142b06:	f363 268f 	bfi	r6, r3, #10, #6
            writel(v.val, slice_addr);
  142b0a:	f848 6007 	str.w	r6, [r8, r7]
  142b0e:	e003      	b.n	142b18 <clkgen_bus_ctl_set+0x1c8>
        spin(1);
  142b10:	f010 f8be 	bl	152c90 <spin>
    } while (--retrycount);
  142b14:	3c01      	subs	r4, #1
  142b16:	d033      	beq.n	142b80 <clkgen_bus_ctl_set+0x230>
        v = readl(reg);
  142b18:	682b      	ldr	r3, [r5, #0]
        spin(1);
  142b1a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142b1c:	2b00      	cmp	r3, #0
  142b1e:	dbf7      	blt.n	142b10 <clkgen_bus_ctl_set+0x1c0>
            return true;
  142b20:	2001      	movs	r0, #1
            v.a_b_sel = 0;
  142b22:	f36f 2649 	bfc	r6, #9, #1
            writel(v.val, slice_addr);
  142b26:	f848 6007 	str.w	r6, [r8, r7]
}
  142b2a:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    bool ret = true;
  142b2e:	2001      	movs	r0, #1
}
  142b30:	4770      	bx	r14
                writel(v.val, slice_addr);
  142b32:	2264      	movs	r2, #100	; 0x64
                v.cg_en_a = 0;
  142b34:	f36f 0600 	bfc	r6, #0, #1
                writel(v.val, slice_addr);
  142b38:	f848 6000 	str.w	r6, [r8, r0]
  142b3c:	e001      	b.n	142b42 <clkgen_bus_ctl_set+0x1f2>
    } while (--retrycount);
  142b3e:	3a01      	subs	r2, #1
  142b40:	d08b      	beq.n	142a5a <clkgen_bus_ctl_set+0x10a>
        v = readl(reg);
  142b42:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142b44:	00c0      	lsls	r0, r0, #3
  142b46:	d5fa      	bpl.n	142b3e <clkgen_bus_ctl_set+0x1ee>
    RMWREG32(reg, start, width, setvalue);
  142b48:	f858 2007 	ldr.w	r2, [r8, r7]
  142b4c:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  142b50:	f848 2007 	str.w	r2, [r8, r7]
  142b54:	e781      	b.n	142a5a <clkgen_bus_ctl_set+0x10a>
                v.cg_en_b = 0;
  142b56:	f362 4610 	bfi	r6, r2, #16, #1
                writel(v.val, slice_addr);
  142b5a:	2264      	movs	r2, #100	; 0x64
  142b5c:	f848 6000 	str.w	r6, [r8, r0]
  142b60:	e002      	b.n	142b68 <clkgen_bus_ctl_set+0x218>
    } while (--retrycount);
  142b62:	3a01      	subs	r2, #1
  142b64:	f43f af0b 	beq.w	14297e <clkgen_bus_ctl_set+0x2e>
        v = readl(reg);
  142b68:	6828      	ldr	r0, [r5, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142b6a:	0100      	lsls	r0, r0, #4
  142b6c:	d5f9      	bpl.n	142b62 <clkgen_bus_ctl_set+0x212>
    RMWREG32(reg, start, width, setvalue);
  142b6e:	f858 2007 	ldr.w	r2, [r8, r7]
  142b72:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  142b76:	f848 2007 	str.w	r2, [r8, r7]
  142b7a:	e700      	b.n	14297e <clkgen_bus_ctl_set+0x2e>
    return false;
  142b7c:	4620      	mov	r0, r4
  142b7e:	e764      	b.n	142a4a <clkgen_bus_ctl_set+0xfa>
  142b80:	4620      	mov	r0, r4
  142b82:	e7ce      	b.n	142b22 <clkgen_bus_ctl_set+0x1d2>
  142b84:	f899 3000 	ldrb.w	r3, [r9]
  142b88:	e73c      	b.n	142a04 <clkgen_bus_ctl_set+0xb4>
  142b8a:	f899 3000 	ldrb.w	r3, [r9]
  142b8e:	e7a6      	b.n	142ade <clkgen_bus_ctl_set+0x18e>

00142b90 <clkgen_core_slice_switch>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_core_slice_switch(vaddr_t base,
                              clkgen_core_slice_drv_t *core_clk_cfg)
{
  142b90:	b538      	push	{r3, r4, r5, r14}
    vaddr_t core_slice_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    uint8_t a_b_sel = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  142b92:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  142b96:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  142b9a:	d005      	beq.n	142ba8 <clkgen_core_slice_switch+0x18>
  142b9c:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  142ba0:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  142ba4:	f040 8084 	bne.w	142cb0 <clkgen_core_slice_switch+0x120>
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "start..............\n");
    core_slice_base_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(
  142ba8:	680b      	ldr	r3, [r1, #0]
  142baa:	33c0      	adds	r3, #192	; 0xc0
  142bac:	031b      	lsls	r3, r3, #12
  142bae:	181c      	adds	r4, r3, r0
                               core_clk_cfg->core_slice_idx);
    //read pre_a_b_sel,if it is 0x0,current selected path is a
    reg_read = readl(core_slice_base_addr);
  142bb0:	581a      	ldr	r2, [r3, r0]
    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "a_b_sel:%d\n", a_b_sel);

    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
        (a_b_sel == core_clk_a_b_sel_a)) {
        //set pre_en_b to 0x0,disable the clock
        reg_read = readl(core_slice_base_addr);
  142bb2:	581d      	ldr	r5, [r3, r0]
    if (/*(core_clk_cfg->clk_a_b_switch == core_clk_a_b_sel_b) &&*/
  142bb4:	0592      	lsls	r2, r2, #22
  142bb6:	d43d      	bmi.n	142c34 <clkgen_core_slice_switch+0xa4>

        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK) != 0) {
  142bb8:	03ea      	lsls	r2, r5, #15
  142bba:	d50d      	bpl.n	142bd8 <clkgen_core_slice_switch+0x48>
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
            writel(reg_write, core_slice_base_addr);
  142bbc:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK);
  142bbe:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
            writel(reg_write, core_slice_base_addr);
  142bc2:	501d      	str	r5, [r3, r0]
  142bc4:	e001      	b.n	142bca <clkgen_core_slice_switch+0x3a>
    } while (--retrycount);
  142bc6:	3a01      	subs	r2, #1
  142bc8:	d006      	beq.n	142bd8 <clkgen_core_slice_switch+0x48>
        v = readl(reg);
  142bca:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142bcc:	012d      	lsls	r5, r5, #4
  142bce:	d5fa      	bpl.n	142bc6 <clkgen_core_slice_switch+0x36>
    RMWREG32(reg, start, width, setvalue);
  142bd0:	581a      	ldr	r2, [r3, r0]
  142bd2:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  142bd6:	501a      	str	r2, [r3, r0]
        }

        //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  142bd8:	798d      	ldrb	r5, [r1, #6]
        reg_read = readl(core_slice_base_addr);
  142bda:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B(core_clk_cfg->clk_src_sel_b)
  142bdc:	046d      	lsls	r5, r5, #17
  142bde:	f405 2560 	and.w	r5, r5, #917504	; 0xe0000
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_B_MASK))
  142be2:	f422 2260 	bic.w	r2, r2, #917504	; 0xe0000
  142be6:	f445 3580 	orr.w	r5, r5, #65536	; 0x10000
  142bea:	4315      	orrs	r5, r2
                    | CLKGEN_CORE_SLICE_CTL_CG_EN_B_MASK;
        writel(reg_write, core_slice_base_addr);
  142bec:	2264      	movs	r2, #100	; 0x64
  142bee:	501d      	str	r5, [r3, r0]
  142bf0:	e001      	b.n	142bf6 <clkgen_core_slice_switch+0x66>
    } while (--retrycount);
  142bf2:	3a01      	subs	r2, #1
  142bf4:	d006      	beq.n	142c04 <clkgen_core_slice_switch+0x74>
        v = readl(reg);
  142bf6:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142bf8:	012d      	lsls	r5, r5, #4
  142bfa:	d5fa      	bpl.n	142bf2 <clkgen_core_slice_switch+0x62>
    RMWREG32(reg, start, width, setvalue);
  142bfc:	581a      	ldr	r2, [r3, r0]
  142bfe:	f022 6200 	bic.w	r2, r2, #134217728	; 0x8000000
  142c02:	501a      	str	r2, [r3, r0]
        reg_poll_clear(core_slice_base_addr,
                       CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1, 1, 0, 100);
        //invert pre_a_b_sel
        reg_read = readl(core_slice_base_addr);
  142c04:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
        //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
        reg_read = readl(core_slice_base_addr);
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
        writel(reg_write, core_slice_base_addr);
  142c06:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read | CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK;
  142c08:	f442 7200 	orr.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  142c0c:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c0e:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  142c10:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c12:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  142c14:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c18:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  142c1a:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  142c1c:	501a      	str	r2, [r3, r0]
  142c1e:	e003      	b.n	142c28 <clkgen_core_slice_switch+0x98>
        spin(1);
  142c20:	f010 f836 	bl	152c90 <spin>
    } while (--retrycount);
  142c24:	3d01      	subs	r5, #1
  142c26:	d043      	beq.n	142cb0 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  142c28:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142c2a:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142c2c:	2b00      	cmp	r3, #0
  142c2e:	dbf7      	blt.n	142c20 <clkgen_core_slice_switch+0x90>
            return true;
  142c30:	2001      	movs	r0, #1
        ret = reg_poll_value(core_slice_base_addr,
                             CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
    }

    return ret;
}
  142c32:	bd38      	pop	{r3, r4, r5, r15}
        if ((reg_read & CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK) != 0) {
  142c34:	07ea      	lsls	r2, r5, #31
  142c36:	d50d      	bpl.n	142c54 <clkgen_core_slice_switch+0xc4>
            writel(reg_write, core_slice_base_addr);
  142c38:	2264      	movs	r2, #100	; 0x64
            reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_CG_EN_A_MASK);
  142c3a:	f025 0501 	bic.w	r5, r5, #1
            writel(reg_write, core_slice_base_addr);
  142c3e:	501d      	str	r5, [r3, r0]
  142c40:	e001      	b.n	142c46 <clkgen_core_slice_switch+0xb6>
    } while (--retrycount);
  142c42:	3a01      	subs	r2, #1
  142c44:	d006      	beq.n	142c54 <clkgen_core_slice_switch+0xc4>
        v = readl(reg);
  142c46:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142c48:	00ed      	lsls	r5, r5, #3
  142c4a:	d5fa      	bpl.n	142c42 <clkgen_core_slice_switch+0xb2>
    RMWREG32(reg, start, width, setvalue);
  142c4c:	581a      	ldr	r2, [r3, r0]
  142c4e:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  142c52:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  142c54:	794d      	ldrb	r5, [r1, #5]
        reg_read = readl(core_slice_base_addr);
  142c56:	581a      	ldr	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A(core_clk_cfg->clk_src_sel_a)
  142c58:	006d      	lsls	r5, r5, #1
  142c5a:	f005 050e 	and.w	r5, r5, #14
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_CLK_SRC_SEL_A_MASK))
  142c5e:	f022 020e 	bic.w	r2, r2, #14
  142c62:	f045 0501 	orr.w	r5, r5, #1
  142c66:	4315      	orrs	r5, r2
        writel(reg_write, core_slice_base_addr);
  142c68:	2264      	movs	r2, #100	; 0x64
  142c6a:	501d      	str	r5, [r3, r0]
  142c6c:	e001      	b.n	142c72 <clkgen_core_slice_switch+0xe2>
    } while (--retrycount);
  142c6e:	3a01      	subs	r2, #1
  142c70:	d006      	beq.n	142c80 <clkgen_core_slice_switch+0xf0>
        v = readl(reg);
  142c72:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142c74:	00ed      	lsls	r5, r5, #3
  142c76:	d5fa      	bpl.n	142c6e <clkgen_core_slice_switch+0xde>
    RMWREG32(reg, start, width, setvalue);
  142c78:	581a      	ldr	r2, [r3, r0]
  142c7a:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
  142c7e:	501a      	str	r2, [r3, r0]
        reg_read = readl(core_slice_base_addr);
  142c80:	581a      	ldr	r2, [r3, r0]
        writel(reg_write, core_slice_base_addr);
  142c82:	2564      	movs	r5, #100	; 0x64
        reg_write = reg_read & (~CLKGEN_CORE_SLICE_CTL_A_B_SEL_MASK);
  142c84:	f422 7200 	bic.w	r2, r2, #512	; 0x200
        writel(reg_write, core_slice_base_addr);
  142c88:	501a      	str	r2, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c8a:	79ca      	ldrb	r2, [r1, #7]
        reg_read = readl(core_slice_base_addr);
  142c8c:	5819      	ldr	r1, [r3, r0]
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c8e:	0292      	lsls	r2, r2, #10
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  142c90:	f421 417c 	bic.w	r1, r1, #64512	; 0xfc00
                    | CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM(core_clk_cfg->post_div);
  142c94:	b292      	uxth	r2, r2
        reg_write = (reg_read & (~CLKGEN_CORE_SLICE_CTL_POST_DIV_NUM_MASK))
  142c96:	430a      	orrs	r2, r1
        writel(reg_write, core_slice_base_addr);
  142c98:	501a      	str	r2, [r3, r0]
  142c9a:	e003      	b.n	142ca4 <clkgen_core_slice_switch+0x114>
        spin(1);
  142c9c:	f00f fff8 	bl	152c90 <spin>
    } while (--retrycount);
  142ca0:	3d01      	subs	r5, #1
  142ca2:	d005      	beq.n	142cb0 <clkgen_core_slice_switch+0x120>
        v = readl(reg);
  142ca4:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142ca6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142ca8:	2b00      	cmp	r3, #0
  142caa:	dbf7      	blt.n	142c9c <clkgen_core_slice_switch+0x10c>
            return true;
  142cac:	2001      	movs	r0, #1
  142cae:	e7c0      	b.n	142c32 <clkgen_core_slice_switch+0xa2>
    CLKGEN_ASSERT_PARAMETER(base);
  142cb0:	2000      	movs	r0, #0
}
  142cb2:	bd38      	pop	{r3, r4, r5, r15}

00142cb4 <clkgen_core_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  142cb4:	b11a      	cbz	r2, 142cbe <clkgen_core_ctl_get+0xa>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  142cb6:	31c0      	adds	r1, #192	; 0xc0
  142cb8:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  142cba:	580b      	ldr	r3, [r1, r0]
  142cbc:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  142cbe:	2001      	movs	r0, #1
  142cc0:	4770      	bx	r14
  142cc2:	bf00      	nop

00142cc4 <clkgen_core_ctl_set>:
                         const clkgen_core_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  142cc4:	2a00      	cmp	r2, #0
  142cc6:	f000 8081 	beq.w	142dcc <clkgen_core_ctl_set+0x108>
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  142cca:	f101 03c0 	add.w	r3, r1, #192	; 0xc0
{
  142cce:	b570      	push	{r4, r5, r6, r14}
        slice_addr = base + CLKGEN_CORE_SLICE_CTL_OFF(slice_idx);
  142cd0:	031b      	lsls	r3, r3, #12
  142cd2:	181c      	adds	r4, r3, r0
        clkgen_core_ctl c;
        //read pre_a_b_sel,if it is 0x0,current selected path is a
        c.val = readl(slice_addr);
  142cd4:	581e      	ldr	r6, [r3, r0]

        if (c.a_b_sel == 0) {
  142cd6:	f3c6 2107 	ubfx	r1, r6, #8, #8
  142cda:	f011 0102 	ands.w	r1, r1, #2
  142cde:	d13a      	bne.n	142d56 <clkgen_core_ctl_set+0x92>
            //set pre_en_b to 0x0,disable the clock
            if (c.cg_en_b != 0) {
  142ce0:	03f5      	lsls	r5, r6, #15
  142ce2:	d50d      	bpl.n	142d00 <clkgen_core_ctl_set+0x3c>
                c.cg_en_b = 0;
  142ce4:	f361 4610 	bfi	r6, r1, #16, #1
                writel(c.val, slice_addr);
  142ce8:	2164      	movs	r1, #100	; 0x64
  142cea:	501e      	str	r6, [r3, r0]
  142cec:	e001      	b.n	142cf2 <clkgen_core_ctl_set+0x2e>
    } while (--retrycount);
  142cee:	3901      	subs	r1, #1
  142cf0:	d006      	beq.n	142d00 <clkgen_core_ctl_set+0x3c>
        v = readl(reg);
  142cf2:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142cf4:	012d      	lsls	r5, r5, #4
  142cf6:	d5fa      	bpl.n	142cee <clkgen_core_ctl_set+0x2a>
    RMWREG32(reg, start, width, setvalue);
  142cf8:	5819      	ldr	r1, [r3, r0]
  142cfa:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  142cfe:	5019      	str	r1, [r3, r0]
                reg_poll_clear(slice_addr, CLKGEN_CORE_SLICE_CTL_CG_EN_B_STATUS_SHIFT, 1,
                               1, 0, 100);
            }

            //change the clock source by set pre_mux_sel_b,then set pre_en_b to 0x1
            c.src_sel_b = ctl->src_sel_a;
  142d00:	7811      	ldrb	r1, [r2, #0]
  142d02:	f3c1 0542 	ubfx	r5, r1, #1, #3
  142d06:	f365 4653 	bfi	r6, r5, #17, #3
            c.cg_en_b = ctl->cg_en_a;
  142d0a:	f3c1 0100 	ubfx	r1, r1, #0, #1
  142d0e:	f361 4610 	bfi	r6, r1, #16, #1
            writel(c.val, slice_addr);

            if (c.cg_en_b)
  142d12:	03f1      	lsls	r1, r6, #15
            writel(c.val, slice_addr);
  142d14:	501e      	str	r6, [r3, r0]
            if (c.cg_en_b)
  142d16:	d50a      	bpl.n	142d2e <clkgen_core_ctl_set+0x6a>
  142d18:	2164      	movs	r1, #100	; 0x64
  142d1a:	e001      	b.n	142d20 <clkgen_core_ctl_set+0x5c>
    } while (--retrycount);
  142d1c:	3901      	subs	r1, #1
  142d1e:	d006      	beq.n	142d2e <clkgen_core_ctl_set+0x6a>
        v = readl(reg);
  142d20:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142d22:	012d      	lsls	r5, r5, #4
  142d24:	d5fa      	bpl.n	142d1c <clkgen_core_ctl_set+0x58>
    RMWREG32(reg, start, width, setvalue);
  142d26:	5819      	ldr	r1, [r3, r0]
  142d28:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
  142d2c:	5019      	str	r1, [r3, r0]
            //invert pre_a_b_sel
            c.a_b_sel = 1;
            writel(c.val, slice_addr);
            //set post div num,check post upd ack bit 1 means update not finished yes,0 means update finished.
            c.post_div_num = ctl->post_div_num;
            writel(c.val, slice_addr);
  142d2e:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 1;
  142d30:	f446 7600 	orr.w	r6, r6, #512	; 0x200
            writel(c.val, slice_addr);
  142d34:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  142d36:	7852      	ldrb	r2, [r2, #1]
  142d38:	0892      	lsrs	r2, r2, #2
  142d3a:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  142d3e:	501e      	str	r6, [r3, r0]
  142d40:	e003      	b.n	142d4a <clkgen_core_ctl_set+0x86>
        spin(1);
  142d42:	f00f ffa5 	bl	152c90 <spin>
    } while (--retrycount);
  142d46:	3d01      	subs	r5, #1
  142d48:	d042      	beq.n	142dd0 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  142d4a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142d4c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142d4e:	2b00      	cmp	r3, #0
  142d50:	dbf7      	blt.n	142d42 <clkgen_core_ctl_set+0x7e>
            return true;
  142d52:	2001      	movs	r0, #1
                                 CLKGEN_CORE_SLICE_CTL_POST_BUSY_SHIFT, 1, 0, 100);
        }
    }

    return ret;
}
  142d54:	bd70      	pop	{r4, r5, r6, r15}
            if (c.cg_en_a != 0) {
  142d56:	07f1      	lsls	r1, r6, #31
  142d58:	d50d      	bpl.n	142d76 <clkgen_core_ctl_set+0xb2>
                writel(c.val, slice_addr);
  142d5a:	2164      	movs	r1, #100	; 0x64
                c.cg_en_a = 0;
  142d5c:	f36f 0600 	bfc	r6, #0, #1
                writel(c.val, slice_addr);
  142d60:	501e      	str	r6, [r3, r0]
  142d62:	e001      	b.n	142d68 <clkgen_core_ctl_set+0xa4>
    } while (--retrycount);
  142d64:	3901      	subs	r1, #1
  142d66:	d006      	beq.n	142d76 <clkgen_core_ctl_set+0xb2>
        v = readl(reg);
  142d68:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142d6a:	00ed      	lsls	r5, r5, #3
  142d6c:	d5fa      	bpl.n	142d64 <clkgen_core_ctl_set+0xa0>
    RMWREG32(reg, start, width, setvalue);
  142d6e:	5819      	ldr	r1, [r3, r0]
  142d70:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  142d74:	5019      	str	r1, [r3, r0]
            c.src_sel_a = ctl->src_sel_a;
  142d76:	7811      	ldrb	r1, [r2, #0]
  142d78:	f3c1 0542 	ubfx	r5, r1, #1, #3
  142d7c:	f365 0643 	bfi	r6, r5, #1, #3
            c.cg_en_a = ctl->cg_en_a;
  142d80:	f3c1 0100 	ubfx	r1, r1, #0, #1
  142d84:	f361 0600 	bfi	r6, r1, #0, #1
            if (c.cg_en_a)
  142d88:	07f1      	lsls	r1, r6, #31
            writel(c.val, slice_addr);
  142d8a:	501e      	str	r6, [r3, r0]
            if (c.cg_en_a)
  142d8c:	d50a      	bpl.n	142da4 <clkgen_core_ctl_set+0xe0>
  142d8e:	2164      	movs	r1, #100	; 0x64
  142d90:	e001      	b.n	142d96 <clkgen_core_ctl_set+0xd2>
    } while (--retrycount);
  142d92:	3901      	subs	r1, #1
  142d94:	d006      	beq.n	142da4 <clkgen_core_ctl_set+0xe0>
        v = readl(reg);
  142d96:	6825      	ldr	r5, [r4, #0]
        if (((v >> start) & ((1 << width) - 1)) == pollvalue)
  142d98:	00ed      	lsls	r5, r5, #3
  142d9a:	d5fa      	bpl.n	142d92 <clkgen_core_ctl_set+0xce>
    RMWREG32(reg, start, width, setvalue);
  142d9c:	5819      	ldr	r1, [r3, r0]
  142d9e:	f021 5180 	bic.w	r1, r1, #268435456	; 0x10000000
  142da2:	5019      	str	r1, [r3, r0]
            writel(c.val, slice_addr);
  142da4:	2564      	movs	r5, #100	; 0x64
            c.a_b_sel = 0;
  142da6:	f36f 2649 	bfc	r6, #9, #1
            writel(c.val, slice_addr);
  142daa:	501e      	str	r6, [r3, r0]
            c.post_div_num = ctl->post_div_num;
  142dac:	7852      	ldrb	r2, [r2, #1]
  142dae:	0892      	lsrs	r2, r2, #2
  142db0:	f362 268f 	bfi	r6, r2, #10, #6
            writel(c.val, slice_addr);
  142db4:	501e      	str	r6, [r3, r0]
  142db6:	e003      	b.n	142dc0 <clkgen_core_ctl_set+0xfc>
        spin(1);
  142db8:	f00f ff6a 	bl	152c90 <spin>
    } while (--retrycount);
  142dbc:	3d01      	subs	r5, #1
  142dbe:	d007      	beq.n	142dd0 <clkgen_core_ctl_set+0x10c>
        v = readl(reg);
  142dc0:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142dc2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142dc4:	2b00      	cmp	r3, #0
  142dc6:	dbf7      	blt.n	142db8 <clkgen_core_ctl_set+0xf4>
            return true;
  142dc8:	2001      	movs	r0, #1
  142dca:	e7c3      	b.n	142d54 <clkgen_core_ctl_set+0x90>
    bool ret = true;
  142dcc:	2001      	movs	r0, #1
}
  142dce:	4770      	bx	r14
    return false;
  142dd0:	2000      	movs	r0, #0
}
  142dd2:	bd70      	pop	{r4, r5, r6, r15}

00142dd4 <clkgen_mon_ip_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_ip_slice(vaddr_t base, uint16_t ip_slice_idx,
                             clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                             clkgen_slice_mon_ret_type ret_type)
{
  142dd4:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  142dd8:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  142dda:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  142dde:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  142de2:	d006      	beq.n	142df2 <clkgen_mon_ip_slice+0x1e>
  142de4:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  142de8:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  142dec:	bf18      	it	ne
  142dee:	2000      	movne	r0, #0
  142df0:	d162      	bne.n	142eb8 <clkgen_mon_ip_slice+0xe4>
  142df2:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  142df4:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  142df8:	4692      	mov	r10, r2
  142dfa:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  142dfe:	4689      	mov	r9, r1
  142e00:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  142e02:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    ip_slice_mon_base_addr = base + CLKGEN_IP_SLICE_MON_CTL_OFF;
  142e06:	f500 1be4 	add.w	r11, r0, #1867776	; 0x1c8000
    reg_read = readl(mon_ctl_base_addr);
  142e0a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  142e0c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142e10:	6023      	str	r3, [r4, #0]
  142e12:	e003      	b.n	142e1c <clkgen_mon_ip_slice+0x48>
        spin(1);
  142e14:	f00f ff3c 	bl	152c90 <spin>
    } while (--retrycount);
  142e18:	3d01      	subs	r5, #1
  142e1a:	d003      	beq.n	142e24 <clkgen_mon_ip_slice+0x50>
        v = readl(reg);
  142e1c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142e1e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142e20:	015b      	lsls	r3, r3, #5
  142e22:	d5f7      	bpl.n	142e14 <clkgen_mon_ip_slice+0x40>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(ip_slice_mon_base_addr);
  142e24:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read & (~CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL_MASK);
  142e28:	0c09      	lsrs	r1, r1, #16
  142e2a:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_IP_SLICE_MON_CTL_IP_SLICE_MON_SEL(
  142e2c:	ea49 0101 	orr.w	r1, r9, r1
                    ip_slice_idx);
    writel(reg_write, ip_slice_mon_base_addr);
  142e30:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  142e34:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  142e36:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
                    slice_mon_ip_clk); //ip slice
    writel(reg_write, mon_ctl_base_addr);
  142e3a:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  142e3c:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  142e3e:	f1ba 0f00 	cmp.w	r10, #0
  142e42:	d03b      	beq.n	142ebc <clkgen_mon_ip_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  142e44:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  142e48:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  142e4a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  142e4c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  142e50:	0c1b      	lsrs	r3, r3, #16
  142e52:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  142e54:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  142e58:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  142e5a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  142e5c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142e60:	6023      	str	r3, [r4, #0]
  142e62:	e003      	b.n	142e6c <clkgen_mon_ip_slice+0x98>
        spin(1);
  142e64:	f00f ff14 	bl	152c90 <spin>
    } while (--retrycount);
  142e68:	3d01      	subs	r5, #1
  142e6a:	d003      	beq.n	142e74 <clkgen_mon_ip_slice+0xa0>
        v = readl(reg);
  142e6c:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142e6e:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142e70:	0159      	lsls	r1, r3, #5
  142e72:	d4f7      	bmi.n	142e64 <clkgen_mon_ip_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  142e74:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  142e78:	e003      	b.n	142e82 <clkgen_mon_ip_slice+0xae>
        spin(1);
  142e7a:	f00f ff09 	bl	152c90 <spin>
    } while (--retrycount);
  142e7e:	3d01      	subs	r5, #1
  142e80:	d003      	beq.n	142e8a <clkgen_mon_ip_slice+0xb6>
        v = readl(reg);
  142e82:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142e84:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142e86:	011a      	lsls	r2, r3, #4
  142e88:	d5f7      	bpl.n	142e7a <clkgen_mon_ip_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  142e8a:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  142e8c:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  142e90:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  142e94:	6023      	str	r3, [r4, #0]
  142e96:	e003      	b.n	142ea0 <clkgen_mon_ip_slice+0xcc>
        spin(1);
  142e98:	f00f fefa 	bl	152c90 <spin>
    } while (--retrycount);
  142e9c:	3d01      	subs	r5, #1
  142e9e:	d003      	beq.n	142ea8 <clkgen_mon_ip_slice+0xd4>
        v = readl(reg);
  142ea0:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142ea2:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142ea4:	00db      	lsls	r3, r3, #3
  142ea6:	d4f7      	bmi.n	142e98 <clkgen_mon_ip_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  142ea8:	b967      	cbnz	r7, 142ec4 <clkgen_mon_ip_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  142eaa:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  142eae:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  142eb0:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  142eb2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142eb6:	6023      	str	r3, [r4, #0]
    return ret;
}
  142eb8:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  142ebc:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  142ec0:	6023      	str	r3, [r4, #0]
  142ec2:	e7c2      	b.n	142e4a <clkgen_mon_ip_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  142ec4:	2f01      	cmp	r7, #1
  142ec6:	d00e      	beq.n	142ee6 <clkgen_mon_ip_slice+0x112>
    else if (mon_min_freq == ret_type) {
  142ec8:	2f02      	cmp	r7, #2
  142eca:	d008      	beq.n	142ede <clkgen_mon_ip_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  142ecc:	2f03      	cmp	r7, #3
  142ece:	d010      	beq.n	142ef2 <clkgen_mon_ip_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  142ed0:	2f04      	cmp	r7, #4
        ret = 0;
  142ed2:	bf12      	itee	ne
  142ed4:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  142ed6:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  142eda:	6830      	ldreq	r0, [r6, #0]
  142edc:	e7e8      	b.n	142eb0 <clkgen_mon_ip_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  142ede:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  142ee2:	6830      	ldr	r0, [r6, #0]
  142ee4:	e7e4      	b.n	142eb0 <clkgen_mon_ip_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  142ee6:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  142eea:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  142eee:	6830      	ldr	r0, [r6, #0]
  142ef0:	e7de      	b.n	142eb0 <clkgen_mon_ip_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  142ef2:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  142ef6:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  142efa:	6830      	ldr	r0, [r6, #0]
  142efc:	e7d8      	b.n	142eb0 <clkgen_mon_ip_slice+0xdc>
  142efe:	bf00      	nop

00142f00 <clkgen_mon_bus_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_bus_slice(vaddr_t base, uint16_t bus_slice_idx,
                              clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                              clkgen_slice_mon_ret_type ret_type)
{
  142f00:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  142f04:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  142f06:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  142f0a:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  142f0e:	d006      	beq.n	142f1e <clkgen_mon_bus_slice+0x1e>
  142f10:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  142f14:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  142f18:	bf18      	it	ne
  142f1a:	2000      	movne	r0, #0
  142f1c:	d165      	bne.n	142fea <clkgen_mon_bus_slice+0xea>
  142f1e:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  142f20:	f500 14e5 	add.w	r4, r0, #1875968	; 0x1ca000
  142f24:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
  142f28:	4693      	mov	r11, r2
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  142f2a:	f500 1ae4 	add.w	r10, r0, #1867776	; 0x1c8000
  142f2e:	4689      	mov	r9, r1
  142f30:	4606      	mov	r6, r0
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
  142f32:	6823      	ldr	r3, [r4, #0]
    bus_slice_mon_base_addr = base + CLKGEN_BUS_SLICE_MON_CTL_OFF;
  142f34:	f50a 5a80 	add.w	r10, r10, #4096	; 0x1000
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  142f38:	2564      	movs	r5, #100	; 0x64
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  142f3a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142f3e:	6023      	str	r3, [r4, #0]
  142f40:	e003      	b.n	142f4a <clkgen_mon_bus_slice+0x4a>
        spin(1);
  142f42:	f00f fea5 	bl	152c90 <spin>
    } while (--retrycount);
  142f46:	3d01      	subs	r5, #1
  142f48:	d003      	beq.n	142f52 <clkgen_mon_bus_slice+0x52>
        v = readl(reg);
  142f4a:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142f4c:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142f4e:	015b      	lsls	r3, r3, #5
  142f50:	d5f7      	bpl.n	142f42 <clkgen_mon_bus_slice+0x42>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 100);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(bus_slice_mon_base_addr);
  142f52:	f8da 1000 	ldr.w	r1, [r10]
    reg_write = reg_read & (~CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL_MASK);
  142f56:	0c09      	lsrs	r1, r1, #16
  142f58:	0409      	lsls	r1, r1, #16
    reg_write = reg_write | CLKGEN_BUS_SLICE_MON_CTL_BUS_SLICE_MON_SEL(
  142f5a:	ea49 0101 	orr.w	r1, r9, r1
                    bus_slice_idx);
    writel(reg_write, bus_slice_mon_base_addr);
  142f5e:	f8ca 1000 	str.w	r1, [r10]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  142f62:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  142f64:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  142f68:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
                    slice_mon_bus_clk); //bus slice
    writel(reg_write, mon_ctl_base_addr);
  142f6c:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  142f6e:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  142f70:	f1bb 0f00 	cmp.w	r11, #0
  142f74:	d03b      	beq.n	142fee <clkgen_mon_bus_slice+0xee>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  142f76:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  142f7a:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  142f7c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  142f7e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  142f82:	0c1b      	lsrs	r3, r3, #16
  142f84:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  142f86:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  142f8a:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  142f8c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  142f8e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142f92:	6023      	str	r3, [r4, #0]
  142f94:	e003      	b.n	142f9e <clkgen_mon_bus_slice+0x9e>
        spin(1);
  142f96:	f00f fe7b 	bl	152c90 <spin>
    } while (--retrycount);
  142f9a:	3d01      	subs	r5, #1
  142f9c:	d003      	beq.n	142fa6 <clkgen_mon_bus_slice+0xa6>
        v = readl(reg);
  142f9e:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142fa0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142fa2:	0159      	lsls	r1, r3, #5
  142fa4:	d4f7      	bmi.n	142f96 <clkgen_mon_bus_slice+0x96>
    writel(reg_write, mon_ctl_base_addr);
  142fa6:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  142faa:	e003      	b.n	142fb4 <clkgen_mon_bus_slice+0xb4>
        spin(1);
  142fac:	f00f fe70 	bl	152c90 <spin>
    } while (--retrycount);
  142fb0:	3d01      	subs	r5, #1
  142fb2:	d003      	beq.n	142fbc <clkgen_mon_bus_slice+0xbc>
        v = readl(reg);
  142fb4:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142fb6:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142fb8:	011a      	lsls	r2, r3, #4
  142fba:	d5f7      	bpl.n	142fac <clkgen_mon_bus_slice+0xac>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  142fbc:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  142fbe:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  142fc2:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  142fc6:	6023      	str	r3, [r4, #0]
  142fc8:	e003      	b.n	142fd2 <clkgen_mon_bus_slice+0xd2>
        spin(1);
  142fca:	f00f fe61 	bl	152c90 <spin>
    } while (--retrycount);
  142fce:	3d01      	subs	r5, #1
  142fd0:	d003      	beq.n	142fda <clkgen_mon_bus_slice+0xda>
        v = readl(reg);
  142fd2:	6823      	ldr	r3, [r4, #0]
        spin(1);
  142fd4:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  142fd6:	00db      	lsls	r3, r3, #3
  142fd8:	d4f7      	bmi.n	142fca <clkgen_mon_bus_slice+0xca>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  142fda:	b967      	cbnz	r7, 142ff6 <clkgen_mon_bus_slice+0xf6>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  142fdc:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  142fe0:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  142fe2:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  142fe4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  142fe8:	6023      	str	r3, [r4, #0]
    return ret;
}
  142fea:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  142fee:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  142ff2:	6023      	str	r3, [r4, #0]
  142ff4:	e7c2      	b.n	142f7c <clkgen_mon_bus_slice+0x7c>
    else if (mon_avg_freq == ret_type) {
  142ff6:	2f01      	cmp	r7, #1
  142ff8:	d00e      	beq.n	143018 <clkgen_mon_bus_slice+0x118>
    else if (mon_min_freq == ret_type) {
  142ffa:	2f02      	cmp	r7, #2
  142ffc:	d008      	beq.n	143010 <clkgen_mon_bus_slice+0x110>
    else if (mon_max_duty == ret_type) {
  142ffe:	2f03      	cmp	r7, #3
  143000:	d010      	beq.n	143024 <clkgen_mon_bus_slice+0x124>
    else if (mon_min_duty == ret_type) {
  143002:	2f04      	cmp	r7, #4
        ret = 0;
  143004:	bf12      	itee	ne
  143006:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  143008:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  14300c:	6830      	ldreq	r0, [r6, #0]
  14300e:	e7e8      	b.n	142fe2 <clkgen_mon_bus_slice+0xe2>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  143010:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  143014:	6830      	ldr	r0, [r6, #0]
  143016:	e7e4      	b.n	142fe2 <clkgen_mon_bus_slice+0xe2>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  143018:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  14301c:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  143020:	6830      	ldr	r0, [r6, #0]
  143022:	e7de      	b.n	142fe2 <clkgen_mon_bus_slice+0xe2>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  143024:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  143028:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  14302c:	6830      	ldr	r0, [r6, #0]
  14302e:	e7d8      	b.n	142fe2 <clkgen_mon_bus_slice+0xe2>

00143030 <clkgen_mon_core_slice>:
//
//*****************************************************************************
uint32_t clkgen_mon_core_slice(vaddr_t base, uint16_t core_slice_idx,
                               clkgen_slice_mon_ref_clk_type ref_clk_type, uint8_t ref_clk_div,
                               clkgen_slice_mon_ret_type ret_type)
{
  143030:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143034:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    vaddr_t mon_max_duty_base_addr;
    vaddr_t mon_min_duty_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  143036:	f020 6480 	bic.w	r4, r0, #67108864	; 0x4000000
  14303a:	f1b4 4f78 	cmp.w	r4, #4160749568	; 0xf8000000
  14303e:	d006      	beq.n	14304e <clkgen_mon_core_slice+0x1e>
  143040:	f420 1400 	bic.w	r4, r0, #2097152	; 0x200000
  143044:	f1b4 4f76 	cmp.w	r4, #4127195136	; 0xf6000000
  143048:	bf18      	it	ne
  14304a:	2000      	movne	r0, #0
  14304c:	d162      	bne.n	143114 <clkgen_mon_core_slice+0xe4>
  14304e:	4698      	mov	r8, r3
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
    core_slice_mon_base_addr = base + CLKGEN_CORE_SLICE_MON_CTL_OFF;
  143050:	f500 1be5 	add.w	r11, r0, #1875968	; 0x1ca000
  143054:	4692      	mov	r10, r2
    mon_ctl_base_addr = base + CLKGEN_MON_CTL_OFF;
  143056:	f50b 5480 	add.w	r4, r11, #4096	; 0x1000
  14305a:	4689      	mov	r9, r1
  14305c:	4606      	mov	r6, r0
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
    // 1.set mon_clk_dis in clkgen_mon_ctl to 0x1.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
    writel(reg_write, mon_ctl_base_addr);
  14305e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_read = readl(mon_ctl_base_addr);
  143062:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  143064:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  143068:	6023      	str	r3, [r4, #0]
  14306a:	e003      	b.n	143074 <clkgen_mon_core_slice+0x44>
        spin(1);
  14306c:	f00f fe10 	bl	152c90 <spin>
    } while (--retrycount);
  143070:	3d01      	subs	r5, #1
  143072:	d003      	beq.n	14307c <clkgen_mon_core_slice+0x4c>
        v = readl(reg);
  143074:	6823      	ldr	r3, [r4, #0]
        spin(1);
  143076:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  143078:	015b      	lsls	r3, r3, #5
  14307a:	d5f7      	bpl.n	14306c <clkgen_mon_core_slice+0x3c>
    // 2.wait until mon_clk_dis_sta in CKGEN_MON_CTL is equal to 0x1
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_CLK_DIS_STA_SHIFT, 1,
                   1, 1000);
    // 3.set CKGEN_IP/BUS/CORE_SLICE_MON_CTL to proper value.
    reg_read = readl(core_slice_mon_base_addr);
  14307c:	f8db 1000 	ldr.w	r1, [r11]
    reg_write = reg_read &
  143080:	0c09      	lsrs	r1, r1, #16
  143082:	0409      	lsls	r1, r1, #16
                (~CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL_MASK);
    reg_write = reg_write | CLKGEN_CORE_SLICE_MON_CTL_CORE_SLICE_MON_SEL(
  143084:	ea49 0101 	orr.w	r1, r9, r1
                    core_slice_idx);
    writel(reg_write, core_slice_mon_base_addr);
  143088:	f8cb 1000 	str.w	r1, [r11]
    // 4.set mon_sel in CKGEN_MON_CTL to proper value to choose the slice to be monitored.
    reg_read = readl(mon_ctl_base_addr);
  14308c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_SEL_MASK);
  14308e:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
    reg_write = reg_write | CLKGEN_MON_CTL_MON_SEL(
  143092:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
                    slice_mon_core_clk); //core slice
    writel(reg_write, mon_ctl_base_addr);
  143096:	6023      	str	r3, [r4, #0]

    if (slice_mon_ref_clk_24M == ref_clk_type) {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
  143098:	6823      	ldr	r3, [r4, #0]
    if (slice_mon_ref_clk_24M == ref_clk_type) {
  14309a:	f1ba 0f00 	cmp.w	r10, #0
  14309e:	d03b      	beq.n	143118 <clkgen_mon_core_slice+0xe8>
        writel(reg_write, mon_ctl_base_addr);
    }
    else {
        //clk slow select
        reg_read = readl(mon_ctl_base_addr);
        reg_write = reg_read | CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK;
  1430a0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  1430a4:	6023      	str	r3, [r4, #0]
    }

    //set clk clow monitor div number
    reg_read = readl(mon_ctl_base_addr);
  1430a6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
    writel(reg_write, mon_ctl_base_addr);
    // 5.set mon_clk_dis in CKGEN_MON_CTL to 0x0.
    reg_read = readl(mon_ctl_base_addr);
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
    writel(reg_write, mon_ctl_base_addr);
  1430a8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_DIV_NUM_MASK);
  1430ac:	0c1b      	lsrs	r3, r3, #16
  1430ae:	041b      	lsls	r3, r3, #16
    reg_write = reg_write | CLKGEN_MON_CTL_MON_DIV_NUM(ref_clk_div);
  1430b0:	ea48 0303 	orr.w	r3, r8, r3
    writel(reg_write, mon_ctl_base_addr);
  1430b4:	6023      	str	r3, [r4, #0]
    reg_read = readl(mon_ctl_base_addr);
  1430b6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read & (~CLKGEN_MON_CTL_MON_CLK_DIS_MASK);
  1430b8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  1430bc:	6023      	str	r3, [r4, #0]
  1430be:	e003      	b.n	1430c8 <clkgen_mon_core_slice+0x98>
        spin(1);
  1430c0:	f00f fde6 	bl	152c90 <spin>
    } while (--retrycount);
  1430c4:	3d01      	subs	r5, #1
  1430c6:	d003      	beq.n	1430d0 <clkgen_mon_core_slice+0xa0>
        v = readl(reg);
  1430c8:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1430ca:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1430cc:	0159      	lsls	r1, r3, #5
  1430ce:	d4f7      	bmi.n	1430c0 <clkgen_mon_core_slice+0x90>
    writel(reg_write, mon_ctl_base_addr);
  1430d0:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
  1430d4:	e003      	b.n	1430de <clkgen_mon_core_slice+0xae>
        spin(1);
  1430d6:	f00f fddb 	bl	152c90 <spin>
    } while (--retrycount);
  1430da:	3d01      	subs	r5, #1
  1430dc:	d003      	beq.n	1430e6 <clkgen_mon_core_slice+0xb6>
        v = readl(reg);
  1430de:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1430e0:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  1430e2:	011a      	lsls	r2, r3, #4
  1430e4:	d5f7      	bpl.n	1430d6 <clkgen_mon_core_slice+0xa6>
                   0, 1000);
    // 7.wait until freq_rdy_sta  in CKGEN_MON_CTL is equal to 0x1.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_FREQ_RDY_STA_SHIFT, 1, 1,
                   1000);
    // 8.set freq_upd_en in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  1430e6:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
    writel(reg_write, mon_ctl_base_addr);
  1430e8:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    reg_write = reg_read | CLKGEN_MON_CTL_MON_VAL_UPD_EN_MASK;
  1430ec:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    writel(reg_write, mon_ctl_base_addr);
  1430f0:	6023      	str	r3, [r4, #0]
  1430f2:	e003      	b.n	1430fc <clkgen_mon_core_slice+0xcc>
        spin(1);
  1430f4:	f00f fdcc 	bl	152c90 <spin>
    } while (--retrycount);
  1430f8:	3d01      	subs	r5, #1
  1430fa:	d003      	beq.n	143104 <clkgen_mon_core_slice+0xd4>
        v = readl(reg);
  1430fc:	6823      	ldr	r3, [r4, #0]
        spin(1);
  1430fe:	2001      	movs	r0, #1
        if (((v >> start) & ((1 << width) - 1)) == value)
  143100:	00db      	lsls	r3, r3, #3
  143102:	d4f7      	bmi.n	1430f4 <clkgen_mon_core_slice+0xc4>
    // 9.wait until freq_upd_en  in CKGEN_MON_CTL is equal to 0x0.
    reg_poll_value(mon_ctl_base_addr, CLKGEN_MON_CTL_MON_VAL_UPD_EN_SHIFT, 1,
                   0, 1000);

    //10.read CKGEN_MON_AVE_FREQ.
    if (mon_max_freq == ret_type) {
  143104:	b967      	cbnz	r7, 143120 <clkgen_mon_core_slice+0xf0>
    mon_max_freq_base_addr = base + CLKGEN_MON_MAX_FREQ_OFF;
  143106:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
        ret = readl(mon_max_freq_base_addr);
  14310a:	6830      	ldr	r0, [r6, #0]
    else {
        ret = 0;
    }

    // 11.set mon_clk_dis in CKGEN_MON_CTL to 0x1
    reg_read = readl(mon_ctl_base_addr);
  14310c:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_read | CLKGEN_MON_CTL_MON_CLK_DIS_MASK;
  14310e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    writel(reg_write, mon_ctl_base_addr);
  143112:	6023      	str	r3, [r4, #0]
    return ret;
}
  143114:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        reg_write = reg_read & (~CLKGEN_MON_CTL_CLK_SLOW_SRC_MASK);
  143118:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
        writel(reg_write, mon_ctl_base_addr);
  14311c:	6023      	str	r3, [r4, #0]
  14311e:	e7c2      	b.n	1430a6 <clkgen_mon_core_slice+0x76>
    else if (mon_avg_freq == ret_type) {
  143120:	2f01      	cmp	r7, #1
  143122:	d00e      	beq.n	143142 <clkgen_mon_core_slice+0x112>
    else if (mon_min_freq == ret_type) {
  143124:	2f02      	cmp	r7, #2
  143126:	d008      	beq.n	14313a <clkgen_mon_core_slice+0x10a>
    else if (mon_max_duty == ret_type) {
  143128:	2f03      	cmp	r7, #3
  14312a:	d010      	beq.n	14314e <clkgen_mon_core_slice+0x11e>
    else if (mon_min_duty == ret_type) {
  14312c:	2f04      	cmp	r7, #4
        ret = 0;
  14312e:	bf12      	itee	ne
  143130:	2000      	movne	r0, #0
    mon_min_duty_base_addr = base + CLKGEN_MON_MIN_DUTY_OFF;
  143132:	f506 16e8 	addeq.w	r6, r6, #1900544	; 0x1d0000
        ret = readl(mon_min_duty_base_addr);
  143136:	6830      	ldreq	r0, [r6, #0]
  143138:	e7e8      	b.n	14310c <clkgen_mon_core_slice+0xdc>
    mon_min_freq_base_addr = base + CLKGEN_MON_MIN_FREQ_OFF;
  14313a:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
        ret = readl(mon_min_freq_base_addr);
  14313e:	6830      	ldr	r0, [r6, #0]
  143140:	e7e4      	b.n	14310c <clkgen_mon_core_slice+0xdc>
    mon_avg_freq_base_addr = base + CLKGEN_MON_AVE_FREQ_OFF;
  143142:	f506 16e6 	add.w	r6, r6, #1884160	; 0x1cc000
  143146:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_avg_freq_base_addr);
  14314a:	6830      	ldr	r0, [r6, #0]
  14314c:	e7de      	b.n	14310c <clkgen_mon_core_slice+0xdc>
    mon_max_duty_base_addr = base + CLKGEN_MON_MAX_DUTY_OFF;
  14314e:	f506 16e7 	add.w	r6, r6, #1892352	; 0x1ce000
  143152:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
        ret = readl(mon_max_duty_base_addr);
  143156:	6830      	ldr	r0, [r6, #0]
  143158:	e7d8      	b.n	14310c <clkgen_mon_core_slice+0xdc>
  14315a:	bf00      	nop

0014315c <clkgen_uuu_clock_wrapper>:
    vaddr_t uuu_wrapper_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;

    // Check the arguments.
    if (base != CKGEN_SOC_BASE) {
  14315c:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
{
  143160:	b4f0      	push	{r4, r5, r6, r7}
  143162:	f89d 5010 	ldrb.w	r5, [r13, #16]
        LTRACEF("base paramenter error \n");
        return 0;
  143166:	bf18      	it	ne
  143168:	2000      	movne	r0, #0
    if (base != CKGEN_SOC_BASE) {
  14316a:	d001      	beq.n	143170 <clkgen_uuu_clock_wrapper+0x14>
#endif
    }

    ret = true;
    return ret;
}
  14316c:	bcf0      	pop	{r4, r5, r6, r7}
  14316e:	4770      	bx	r14
  143170:	7814      	ldrb	r4, [r2, #0]
  143172:	0324      	lsls	r4, r4, #12
  143174:	7856      	ldrb	r6, [r2, #1]
  143176:	0236      	lsls	r6, r6, #8
  143178:	b2a4      	uxth	r4, r4
  14317a:	7890      	ldrb	r0, [r2, #2]
  14317c:	f406 6670 	and.w	r6, r6, #3840	; 0xf00
  143180:	78d7      	ldrb	r7, [r2, #3]
  143182:	0100      	lsls	r0, r0, #4
  143184:	ea44 0206 	orr.w	r2, r4, r6
    uuu_wrapper_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(
  143188:	0309      	lsls	r1, r1, #12
  14318a:	f007 040f 	and.w	r4, r7, #15
  14318e:	f101 4176 	add.w	r1, r1, #4127195136	; 0xf6000000
  143192:	042d      	lsls	r5, r5, #16
  143194:	4322      	orrs	r2, r4
  143196:	b2c0      	uxtb	r0, r0
  143198:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
  14319c:	f405 2570 	and.w	r5, r5, #983040	; 0xf0000
  1431a0:	4302      	orrs	r2, r0
    if (low_power_mode) {
  1431a2:	b963      	cbnz	r3, 1431be <clkgen_uuu_clock_wrapper+0x62>
        reg_read = readl(uuu_wrapper_base_addr);
  1431a4:	680b      	ldr	r3, [r1, #0]
    return ret;
  1431a6:	2001      	movs	r0, #1
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(
  1431a8:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type << 0);
  1431ac:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  1431ae:	600d      	str	r5, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  1431b0:	680b      	ldr	r3, [r1, #0]
}
  1431b2:	bcf0      	pop	{r4, r5, r6, r7}
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  1431b4:	0c1b      	lsrs	r3, r3, #16
  1431b6:	041b      	lsls	r3, r3, #16
        reg_write |= CLKGEN_UUU_SLICE_M_DIV_NUM(gasket_div->m_div_num)
  1431b8:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  1431ba:	600a      	str	r2, [r1, #0]
}
  1431bc:	4770      	bx	r14
        reg_read = readl(uuu_wrapper_base_addr);
  1431be:	680c      	ldr	r4, [r1, #0]
    return ret;
  1431c0:	4618      	mov	r0, r3
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_M_DIV_NUM_MASK
  1431c2:	0c23      	lsrs	r3, r4, #16
  1431c4:	041b      	lsls	r3, r3, #16
        reg_write |=
  1431c6:	431a      	orrs	r2, r3
        writel(reg_write, uuu_wrapper_base_addr);
  1431c8:	600a      	str	r2, [r1, #0]
        reg_read = readl(uuu_wrapper_base_addr);
  1431ca:	680b      	ldr	r3, [r1, #0]
        reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_SEL(0x3)));
  1431cc:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
        reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_SEL(input_clk_type);
  1431d0:	431d      	orrs	r5, r3
        writel(reg_write, uuu_wrapper_base_addr);
  1431d2:	600d      	str	r5, [r1, #0]
}
  1431d4:	bcf0      	pop	{r4, r5, r6, r7}
  1431d6:	4770      	bx	r14

001431d8 <clkgen_uuu_ctl_get>:
{
    bool ret = true;
    vaddr_t slice_addr;

// Check the arguments.
    if (ctl) {
  1431d8:	b122      	cbz	r2, 1431e4 <clkgen_uuu_ctl_get+0xc>
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  1431da:	f501 71c0 	add.w	r1, r1, #384	; 0x180
  1431de:	0309      	lsls	r1, r1, #12
        ctl->val = readl(slice_addr);
  1431e0:	580b      	ldr	r3, [r1, r0]
  1431e2:	6013      	str	r3, [r2, #0]
    }

    return ret;
}
  1431e4:	2001      	movs	r0, #1
  1431e6:	4770      	bx	r14

001431e8 <clkgen_uuu_ctl_set>:
                        const clkgen_uuu_ctl *ctl)
{
    bool ret = true;
    vaddr_t slice_addr;

    if (ctl) {
  1431e8:	b33a      	cbz	r2, 14323a <clkgen_uuu_ctl_set+0x52>
        clkgen_uuu_ctl c;
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  1431ea:	f501 71c0 	add.w	r1, r1, #384	; 0x180
{
  1431ee:	b470      	push	{r4, r5, r6}
        slice_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  1431f0:	0309      	lsls	r1, r1, #12
        // 1.Program CKGEN_SOC corresponding slice to get proper clk_ckgen frequency. hal process
        //wait#######################
        // 2.Release SS reset(some ss don't have separate SS reset). set reset to 1 release reset,hal process
        //wait#######################
        // 3.Set clk_sel[0] and clk_sel[1]both to 0x0(default of both of them are 0x0)
        c.val = readl(slice_addr);
  1431f2:	580b      	ldr	r3, [r1, r0]
        c.uuu_sel0 = 0;
  1431f4:	f36f 4310 	bfc	r3, #16, #1
        c.uuu_sel1 = 0;
  1431f8:	f36f 4351 	bfc	r3, #17, #1
        writel(c.val, slice_addr);
  1431fc:	500b      	str	r3, [r1, r0]
        // 4.Program PLL_x to enable PLL and get the proper frequency.(see PLL programming guide).
        // call pll func enable pll clock,
        //wait#######################
        // 5.Set Div_m/n/p/q to the proper value before change the clock source from ckgen to PLL.(Div_m/n/p/q can be changed on-the-fly.)
        c.m_div = ctl->m_div;
  1431fe:	7855      	ldrb	r5, [r2, #1]
  143200:	092e      	lsrs	r6, r5, #4
        c.n_div = ctl->n_div;
        c.p_div = ctl->p_div;
  143202:	7814      	ldrb	r4, [r2, #0]
        c.m_div = ctl->m_div;
  143204:	f366 330f 	bfi	r3, r6, #12, #4
        c.n_div = ctl->n_div;
  143208:	f3c5 0503 	ubfx	r5, r5, #0, #4
  14320c:	f365 230b 	bfi	r3, r5, #8, #4
        c.p_div = ctl->p_div;
  143210:	0925      	lsrs	r5, r4, #4
  143212:	f365 1307 	bfi	r3, r5, #4, #4
        c.q_div = ctl->q_div;
  143216:	f3c4 0403 	ubfx	r4, r4, #0, #4
  14321a:	f364 0303 	bfi	r3, r4, #0, #4
        writel(c.val, slice_addr);
  14321e:	500b      	str	r3, [r1, r0]
        // 6.Set clk_sel[0] to 0x1 to set clk_out_1/2/3 source from PLL_x.
        // 7.Set clk_sel[1] to 0x1 to set clk_out_0 source from PLL_x.
        c.uuu_sel0 = ctl->uuu_sel0;
  143220:	7892      	ldrb	r2, [r2, #2]
  143222:	f3c2 0400 	ubfx	r4, r2, #0, #1
  143226:	f364 4310 	bfi	r3, r4, #16, #1
        c.uuu_sel1 = ctl->uuu_sel1;
  14322a:	f3c2 0240 	ubfx	r2, r2, #1, #1
  14322e:	f362 4351 	bfi	r3, r2, #17, #1
        writel(c.val, slice_addr);
    }

    return ret;
}
  143232:	bc70      	pop	{r4, r5, r6}
        writel(c.val, slice_addr);
  143234:	500b      	str	r3, [r1, r0]
}
  143236:	2001      	movs	r0, #1
  143238:	4770      	bx	r14
  14323a:	2001      	movs	r0, #1
  14323c:	4770      	bx	r14
  14323e:	bf00      	nop

00143240 <clkgen_ipslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_ip_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  143240:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  143244:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  143248:	d004      	beq.n	143254 <clkgen_ipslice_debug_enable+0x14>
  14324a:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  14324e:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  143252:	d111      	bne.n	143278 <clkgen_ipslice_debug_enable+0x38>
{
  143254:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_ip_base_addr = base + CLKGEN_IP_SLICE_DBG_CTL_OFF;
  143256:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  14325a:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  14325e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_ip_base_addr);
  143262:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_ip_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  143264:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(0) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  143268:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  14326a:	4329      	orrs	r1, r5
    writel(reg_write, debug_ip_base_addr);
  14326c:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  14326e:	6819      	ldr	r1, [r3, #0]
}
  143270:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  143272:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  143274:	601a      	str	r2, [r3, #0]
}
  143276:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  143278:	2000      	movs	r0, #0
}
  14327a:	4770      	bx	r14

0014327c <clkgen_ipslice_debug_disable>:
{
    vaddr_t debug_crtl_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  14327c:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  143280:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  143284:	d004      	beq.n	143290 <clkgen_ipslice_debug_disable+0x14>
  143286:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  14328a:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  14328e:	d109      	bne.n	1432a4 <clkgen_ipslice_debug_disable+0x28>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  143290:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  143294:	2001      	movs	r0, #1
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  143296:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_crtl_base_addr);
  14329a:	681a      	ldr	r2, [r3, #0]
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  14329c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_crtl_base_addr);
  1432a0:	601a      	str	r2, [r3, #0]
    return true;
  1432a2:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  1432a4:	2000      	movs	r0, #0
}
  1432a6:	4770      	bx	r14

001432a8 <clkgen_busslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_bus_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1432a8:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  1432ac:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  1432b0:	d004      	beq.n	1432bc <clkgen_busslice_debug_enable+0x14>
  1432b2:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  1432b6:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  1432ba:	d113      	bne.n	1432e4 <clkgen_busslice_debug_enable+0x3c>
{
  1432bc:	b430      	push	{r4, r5}
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_bus_base_addr = base + CLKGEN_BUS_SLICE_DBG_CTL_OFF;
  1432be:	f500 14e0 	add.w	r4, r0, #1835008	; 0x1c0000
  1432c2:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  1432c6:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
  1432ca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    reg_read = readl(debug_bus_base_addr);
  1432ce:	6825      	ldr	r5, [r4, #0]
                    slice_idx);
    writel(reg_write, debug_bus_base_addr);
    //select ip/bus/core debug mode
    reg_read = readl(debug_crtl_base_addr);
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  1432d0:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(1) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  1432d4:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  1432d6:	4329      	orrs	r1, r5
    writel(reg_write, debug_bus_base_addr);
  1432d8:	6021      	str	r1, [r4, #0]
    reg_read = readl(debug_crtl_base_addr);
  1432da:	6819      	ldr	r1, [r3, #0]
}
  1432dc:	bc30      	pop	{r4, r5}
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  1432de:	430a      	orrs	r2, r1
    writel(reg_write, debug_crtl_base_addr);
  1432e0:	601a      	str	r2, [r3, #0]
}
  1432e2:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  1432e4:	2000      	movs	r0, #0
}
  1432e6:	4770      	bx	r14

001432e8 <clkgen_busslice_debug_disable>:
  1432e8:	f7ff bfc8 	b.w	14327c <clkgen_ipslice_debug_disable>

001432ec <clkgen_coreslice_debug_enable>:
    vaddr_t debug_crtl_base_addr;
    vaddr_t debug_core_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  1432ec:	f020 6380 	bic.w	r3, r0, #67108864	; 0x4000000
  1432f0:	f1b3 4f78 	cmp.w	r3, #4160749568	; 0xf8000000
  1432f4:	d004      	beq.n	143300 <clkgen_coreslice_debug_enable+0x14>
  1432f6:	f420 1300 	bic.w	r3, r0, #2097152	; 0x200000
  1432fa:	f1b3 4f76 	cmp.w	r3, #4127195136	; 0xf6000000
  1432fe:	d10f      	bne.n	143320 <clkgen_coreslice_debug_enable+0x34>
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
    debug_core_base_addr = base + CLKGEN_CORE_SLICE_DBG_CTL_OFF;
  143300:	f500 13e1 	add.w	r3, r0, #1843200	; 0x1c2000
{
  143304:	b430      	push	{r4, r5}
    reg_read = readl(debug_core_base_addr);
  143306:	681d      	ldr	r5, [r3, #0]
    debug_crtl_base_addr = base + CLKGEN_DBG_CTL_OFF;
  143308:	f503 5480 	add.w	r4, r3, #4096	; 0x1000
    reg_write = reg_read & (~(CLKGEN_DBG_CTL_DBG_DIV_NUM(
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
                             CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1));
    writel(reg_write, debug_crtl_base_addr);
    return true;
  14330c:	2001      	movs	r0, #1
                                  dbg_div) | CLKGEN_DBG_CTL_DBG_SEL(2) | CLKGEN_DBG_CTL_DBG_CLK_DIS(1)));
  14330e:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    reg_write = reg_write | CLKGEN_IP_SLICE_DBG_CTL_IP_SLICE_DBG_SEL(
  143312:	4329      	orrs	r1, r5
    writel(reg_write, debug_core_base_addr);
  143314:	6019      	str	r1, [r3, #0]
    reg_read = readl(debug_crtl_base_addr);
  143316:	6823      	ldr	r3, [r4, #0]
    reg_write = reg_write | (CLKGEN_DBG_CTL_DBG_DIV_NUM(dbg_div) |
  143318:	431a      	orrs	r2, r3
    writel(reg_write, debug_crtl_base_addr);
  14331a:	6022      	str	r2, [r4, #0]
}
  14331c:	bc30      	pop	{r4, r5}
  14331e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  143320:	2000      	movs	r0, #0
}
  143322:	4770      	bx	r14

00143324 <clkgen_coreslice_debug_disable>:
  143324:	f7ff bfaa 	b.w	14327c <clkgen_ipslice_debug_disable>

00143328 <clkgen_uuuslice_debug_enable>:
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_enable(vaddr_t base, uint16_t slice_idx,
                                  uint8_t dbg_div)
{
  143328:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  14332a:	f020 6080 	bic.w	r0, r0, #67108864	; 0x4000000
  14332e:	f1b0 4f78 	cmp.w	r0, #4160749568	; 0xf8000000
  143332:	d004      	beq.n	14333e <clkgen_uuuslice_debug_enable+0x16>
  143334:	f423 1000 	bic.w	r0, r3, #2097152	; 0x200000
  143338:	f1b0 4f76 	cmp.w	r0, #4127195136	; 0xf6000000
  14333c:	d111      	bne.n	143362 <clkgen_uuuslice_debug_enable+0x3a>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  14333e:	0309      	lsls	r1, r1, #12
  143340:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
{
  143344:	b410      	push	{r4}
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
  143346:	58cc      	ldr	r4, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1);
    reg_write = reg_write & (~(CLKGEN_UUU_SLICE_DBG_DIV_NUM(0xF)));
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  143348:	06d2      	lsls	r2, r2, #27
    writel(reg_write, debug_uuu_base_addr);
    return true;
  14334a:	2001      	movs	r0, #1
    reg_write = reg_write | CLKGEN_UUU_SLICE_DBG_DIV_NUM(dbg_div);
  14334c:	f002 42f0 	and.w	r2, r2, #2013265920	; 0x78000000
  143350:	f024 4478 	bic.w	r4, r4, #4160749568	; 0xf8000000
  143354:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
  143358:	4322      	orrs	r2, r4
}
  14335a:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(reg_write, debug_uuu_base_addr);
  14335e:	50ca      	str	r2, [r1, r3]
}
  143360:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  143362:	2000      	movs	r0, #0
}
  143364:	4770      	bx	r14
  143366:	bf00      	nop

00143368 <clkgen_uuuslice_debug_disable>:
//! \return true/false
//! if it is not.
//
//*****************************************************************************
bool clkgen_uuuslice_debug_disable(vaddr_t base, uint16_t slice_idx)
{
  143368:	4603      	mov	r3, r0
    vaddr_t debug_uuu_base_addr;
    uint32_t reg_read = 0;
    uint32_t reg_write = 0;
    // Check the arguments.
    CLKGEN_ASSERT_PARAMETER(base);
  14336a:	f020 6280 	bic.w	r2, r0, #67108864	; 0x4000000
  14336e:	f1b2 4f78 	cmp.w	r2, #4160749568	; 0xf8000000
  143372:	d004      	beq.n	14337e <clkgen_uuuslice_debug_disable+0x16>
  143374:	f420 1200 	bic.w	r2, r0, #2097152	; 0x200000
  143378:	f1b2 4f76 	cmp.w	r2, #4127195136	; 0xf6000000
  14337c:	d108      	bne.n	143390 <clkgen_uuuslice_debug_disable+0x28>
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
    //enable uuu debug mode
    reg_read = readl(debug_uuu_base_addr);
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
    writel(reg_write, debug_uuu_base_addr);
    return true;
  14337e:	2001      	movs	r0, #1
    debug_uuu_base_addr = base + CLKGEN_UUU_SLICE_WRAPPER_OFF(slice_idx);
  143380:	0309      	lsls	r1, r1, #12
  143382:	f501 11c0 	add.w	r1, r1, #1572864	; 0x180000
    reg_read = readl(debug_uuu_base_addr);
  143386:	58ca      	ldr	r2, [r1, r3]
    reg_write = reg_read & (~(CLKGEN_UUU_SLICE_UUU_DBG_GATING_EN(1)));
  143388:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
    writel(reg_write, debug_uuu_base_addr);
  14338c:	50ca      	str	r2, [r1, r3]
    return true;
  14338e:	4770      	bx	r14
    CLKGEN_ASSERT_PARAMETER(base);
  143390:	2000      	movs	r0, #0
}
  143392:	4770      	bx	r14

00143394 <sram_config>:
#include <sram_conf.h>
#include <ce_reg.h>
#include <ce.h>

void sram_config(void)
{
  143394:	b430      	push	{r4, r5}

    value = reg_value(CE4_SRAM_SIZE, 0, CE4_RAM_SIZE_SHIFT, CE4_RAM_SIZE_MASK);
    value = reg_value(CE5_SRAM_SIZE, value, CE5_RAM_SIZE_SHIFT, CE5_RAM_SIZE_MASK);
    value = reg_value(CE6_SRAM_SIZE, value, CE6_RAM_SIZE_SHIFT, CE6_RAM_SIZE_MASK);
    value = reg_value(CE7_SRAM_SIZE, value, CE7_RAM_SIZE_SHIFT, CE7_RAM_SIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  143396:	f248 0008 	movw	r0, #32776	; 0x8008
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  14339a:	f248 0504 	movw	r5, #32772	; 0x8004

    value = reg_value(CE0_SEC_SRAM_SIZE, 0, CE0_RAM_SASIZE_SHIFT, CE0_RAM_SASIZE_MASK);
    value = reg_value(CE1_SEC_SRAM_SIZE, value, CE1_RAM_SASIZE_SHIFT, CE1_RAM_SASIZE_MASK);
    value = reg_value(CE2_SEC_SRAM_SIZE, value, CE2_RAM_SASIZE_SHIFT, CE2_RAM_SASIZE_MASK);
    value = reg_value(CE3_SEC_SRAM_SIZE, value, CE3_RAM_SASIZE_SHIFT, CE3_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  14339e:	f248 010c 	movw	r1, #32780	; 0x800c

    value = reg_value(CE4_SEC_SRAM_SIZE, 0, CE4_RAM_SASIZE_SHIFT, CE4_RAM_SASIZE_MASK);
    value = reg_value(CE5_SEC_SRAM_SIZE, value, CE5_RAM_SASIZE_SHIFT, CE5_RAM_SASIZE_MASK);
    value = reg_value(CE6_SEC_SRAM_SIZE, value, CE6_RAM_SASIZE_SHIFT, CE6_RAM_SASIZE_MASK);
    value = reg_value(CE7_SEC_SRAM_SIZE, value, CE7_RAM_SASIZE_SHIFT, CE7_RAM_SASIZE_MASK);
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  1433a2:	f248 0310 	movw	r3, #32784	; 0x8010
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  1433a6:	f04f 3408 	mov.w	r4, #134744072	; 0x8080808
  1433aa:	f2cf 4500 	movt	r5, #62464	; 0xf400
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  1433ae:	f04f 3204 	mov.w	r2, #67372036	; 0x4040404
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  1433b2:	f2cf 4000 	movt	r0, #62464	; 0xf400
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  1433b6:	f2cf 4100 	movt	r1, #62464	; 0xf400
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE));
  1433ba:	602c      	str	r4, [r5, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  1433bc:	f2cf 4300 	movt	r3, #62464	; 0xf400
    writel(value, _ioaddr(REG_CE_SESRAM_SIZE_CONT));
  1433c0:	6004      	str	r4, [r0, #0]
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE));
  1433c2:	600a      	str	r2, [r1, #0]
}
  1433c4:	bc30      	pop	{r4, r5}
    writel(value, _ioaddr(REG_CE_SESRAM_SASIZE_CONT));
  1433c6:	601a      	str	r2, [r3, #0]
}
  1433c8:	4770      	bx	r14
  1433ca:	bf00      	nop

001433cc <sram_pub_addr>:
{
    addr_t addr_base = 0;
    uint32_t i;
    uint32_t sram_size1, sram_size2 = 0;

    sram_size1 = readl(_ioaddr(REG_CE_SESRAM_SIZE));
  1433cc:	f248 0304 	movw	r3, #32772	; 0x8004

    if (ce_id > 3) {
  1433d0:	2803      	cmp	r0, #3
    sram_size1 = readl(_ioaddr(REG_CE_SESRAM_SIZE));
  1433d2:	f2cf 4300 	movt	r3, #62464	; 0xf400
{
  1433d6:	b430      	push	{r4, r5}
    sram_size1 = readl(_ioaddr(REG_CE_SESRAM_SIZE));
  1433d8:	681d      	ldr	r5, [r3, #0]
    if (ce_id > 3) {
  1433da:	d91e      	bls.n	14341a <sram_pub_addr+0x4e>
        sram_size2 = readl(_ioaddr(REG_CE_SESRAM_SIZE_CONT));
  1433dc:	f248 0308 	movw	r3, #32776	; 0x8008
  1433e0:	f2cf 4300 	movt	r3, #62464	; 0xf400
  1433e4:	681c      	ldr	r4, [r3, #0]
    uint32_t sram_size1, sram_size2 = 0;
  1433e6:	2200      	movs	r2, #0
  1433e8:	4611      	mov	r1, r2
    }

    for (i = 0; i < ce_id; i++) {
        addr_base += i > 3 ? (sram_size2 >> (i % 4) * 8) & 0x7F : (sram_size1 >> i * 8) & 0x7F;
  1433ea:	f002 0303 	and.w	r3, r2, #3
  1433ee:	2a03      	cmp	r2, #3
  1433f0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
  1433f4:	fa24 f303 	lsr.w	r3, r4, r3
  1433f8:	bf98      	it	ls
  1433fa:	00d3      	lslls	r3, r2, #3
    for (i = 0; i < ce_id; i++) {
  1433fc:	f102 0201 	add.w	r2, r2, #1
        addr_base += i > 3 ? (sram_size2 >> (i % 4) * 8) & 0x7F : (sram_size1 >> i * 8) & 0x7F;
  143400:	bf98      	it	ls
  143402:	fa25 f303 	lsrls.w	r3, r5, r3
    for (i = 0; i < ce_id; i++) {
  143406:	4290      	cmp	r0, r2
        addr_base += i > 3 ? (sram_size2 >> (i % 4) * 8) & 0x7F : (sram_size1 >> i * 8) & 0x7F;
  143408:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  14340c:	4419      	add	r1, r3
    for (i = 0; i < ce_id; i++) {
  14340e:	d1ec      	bne.n	1433ea <sram_pub_addr+0x1e>
  143410:	f501 50a4 	add.w	r0, r1, #5248	; 0x1480
    }

    return SRAM_BASE_ADDR + addr_base * 1024;
}
  143414:	bc30      	pop	{r4, r5}
  143416:	0280      	lsls	r0, r0, #10
  143418:	4770      	bx	r14
    for (i = 0; i < ce_id; i++) {
  14341a:	b108      	cbz	r0, 143420 <sram_pub_addr+0x54>
    uint32_t sram_size1, sram_size2 = 0;
  14341c:	2400      	movs	r4, #0
  14341e:	e7e2      	b.n	1433e6 <sram_pub_addr+0x1a>
    for (i = 0; i < ce_id; i++) {
  143420:	f44f 00a4 	mov.w	r0, #5373952	; 0x520000
}
  143424:	bc30      	pop	{r4, r5}
  143426:	4770      	bx	r14

00143428 <sram_sec_addr>:
addr_t sram_sec_addr(uint32_t ce_id)
{
    uint32_t sram_sec_size;

    sram_sec_size = ce_id > 3 ? (readl(_ioaddr(REG_CE_SESRAM_SASIZE_CONT)) >> (ce_id % 4) * 8) & 0x7F
                    : (readl(_ioaddr(REG_CE_SESRAM_SASIZE)) >> ce_id * 8) & 0x7F;
  143428:	2803      	cmp	r0, #3
{
  14342a:	b510      	push	{r4, r14}
                    : (readl(_ioaddr(REG_CE_SESRAM_SASIZE)) >> ce_id * 8) & 0x7F;
  14342c:	d914      	bls.n	143458 <sram_sec_addr+0x30>
    sram_sec_size = ce_id > 3 ? (readl(_ioaddr(REG_CE_SESRAM_SASIZE_CONT)) >> (ce_id % 4) * 8) & 0x7F
  14342e:	f248 0210 	movw	r2, #32784	; 0x8010
  143432:	f000 0403 	and.w	r4, r0, #3
  143436:	f2cf 4200 	movt	r2, #62464	; 0xf400
  14343a:	00e3      	lsls	r3, r4, #3

    if (7 == ce_id) {
  14343c:	2807      	cmp	r0, #7
    sram_sec_size = ce_id > 3 ? (readl(_ioaddr(REG_CE_SESRAM_SASIZE_CONT)) >> (ce_id % 4) * 8) & 0x7F
  14343e:	6814      	ldr	r4, [r2, #0]
  143440:	fa24 f403 	lsr.w	r4, r4, r3
                    : (readl(_ioaddr(REG_CE_SESRAM_SASIZE)) >> ce_id * 8) & 0x7F;
  143444:	f004 047f 	and.w	r4, r4, #127	; 0x7f
        return SRAM_BASE_ADDR + (SRAM_SIZE - sram_sec_size) * 1024;
  143448:	bf02      	ittt	eq
  14344a:	ebc4 5484 	rsbeq	r4, r4, r4, lsl #22
  14344e:	02a4      	lsleq	r4, r4, #10
  143450:	f504 00a6 	addeq.w	r0, r4, #5439488	; 0x530000
    if (7 == ce_id) {
  143454:	d10a      	bne.n	14346c <sram_sec_addr+0x44>
    }

    return sram_pub_addr(ce_id + 1) - sram_sec_size * 1024;
}
  143456:	bd10      	pop	{r4, r15}
                    : (readl(_ioaddr(REG_CE_SESRAM_SASIZE)) >> ce_id * 8) & 0x7F;
  143458:	f248 030c 	movw	r3, #32780	; 0x800c
  14345c:	00c4      	lsls	r4, r0, #3
  14345e:	f2cf 4300 	movt	r3, #62464	; 0xf400
  143462:	681b      	ldr	r3, [r3, #0]
  143464:	fa23 f404 	lsr.w	r4, r3, r4
  143468:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    return sram_pub_addr(ce_id + 1) - sram_sec_size * 1024;
  14346c:	3001      	adds	r0, #1
  14346e:	f7ff ffad 	bl	1433cc <sram_pub_addr>
  143472:	eba0 2084 	sub.w	r0, r0, r4, lsl #10
}
  143476:	bd10      	pop	{r4, r15}

00143478 <sram_addr>:

addr_t sram_addr(ce_addr_type_t addr_type, uint32_t ce_id)
{
    if (SRAM_PUB == addr_type) {
  143478:	b118      	cbz	r0, 143482 <sram_addr+0xa>
        return sram_pub_addr(ce_id);
    }
    else if (SRAM_SEC == addr_type) {
  14347a:	2801      	cmp	r0, #1
  14347c:	d004      	beq.n	143488 <sram_addr+0x10>
        return sram_sec_addr(ce_id);
    }
    else {
        return 0;
    }
}
  14347e:	2000      	movs	r0, #0
  143480:	4770      	bx	r14
        return sram_pub_addr(ce_id);
  143482:	4608      	mov	r0, r1
  143484:	f7ff bfa2 	b.w	1433cc <sram_pub_addr>
        return sram_sec_addr(ce_id);
  143488:	4608      	mov	r0, r1
  14348a:	f7ff bfcd 	b.w	143428 <sram_sec_addr>
  14348e:	bf00      	nop

00143490 <get_sram_base>:

addr_t get_sram_base(uint32_t vce_id)
{
  143490:	2807      	cmp	r0, #7
  143492:	bf9d      	ittte	ls
  143494:	f245 6358 	movwls	r3, #22104	; 0x5658
  143498:	f2c0 0315 	movtls	r3, #21
  14349c:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
  1434a0:	2000      	movhi	r0, #0
        default:
            return 0;
    }

    return addr_base;
}
  1434a2:	4770      	bx	r14

001434a4 <ce_irq_handle>:
    return addr_switch;
}

enum handler_return ce_irq_handle(void* arg)
{
    uint32_t vce_id = *(uint32_t*)arg;
  1434a4:	6803      	ldr	r3, [r0, #0]

    //LTRACEF("ce_irq_handle irq: 0x%x\n", readl(_ioaddr(REG_INTSTAT_CE_(vce_id))));
    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
    //LTRACEF("ce_irq_handle irq after clear: 0x%x\n", readl(_ioaddr(REG_INTSTAT_CE_(vce_id))));

    event_signal(&g_ce_signal[vce_id], false);
  1434a6:	f242 308c 	movw	r0, #9100	; 0x238c
{
  1434aa:	b510      	push	{r4, r14}
    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
  1434ac:	241f      	movs	r4, #31
  1434ae:	031a      	lsls	r2, r3, #12
  1434b0:	f102 4274 	add.w	r2, r2, #4093640704	; 0xf4000000
    event_signal(&g_ce_signal[vce_id], false);
  1434b4:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  1434b8:	2100      	movs	r1, #0
  1434ba:	f2c0 0016 	movt	r0, #22
    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
  1434be:	f8c2 4148 	str.w	r4, [r2, #328]	; 0x148
    event_signal(&g_ce_signal[vce_id], false);
  1434c2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  1434c6:	f00b fe01 	bl	14f0cc <event_signal>
    //LTRACEF("ce_irq_handle vce_id: %d\n", vce_id);

    return 0;
}
  1434ca:	2000      	movs	r0, #0
  1434cc:	bd10      	pop	{r4, r15}
  1434ce:	bf00      	nop

001434d0 <trng_irq_handle>:

enum handler_return trng_irq_handle(void* arg)
{
    event_signal(&g_trng_signal, false);
  1434d0:	f242 406c 	movw	r0, #9324	; 0x246c
  1434d4:	2100      	movs	r1, #0
{
  1434d6:	b508      	push	{r3, r14}
    event_signal(&g_trng_signal, false);
  1434d8:	f2c0 0016 	movt	r0, #22
  1434dc:	f00b fdf6 	bl	14f0cc <event_signal>

    LTRACEF("trng_irq_handle\n");

    return 0;
}
  1434e0:	2000      	movs	r0, #0
  1434e2:	bd08      	pop	{r3, r15}

001434e4 <ce_malloc>:
{
  1434e4:	b4f0      	push	{r4, r5, r6, r7}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1434e6:	f3ef 8300 	mrs	r3, CPSR

static inline void
arch_interrupt_save(spin_lock_saved_state_t *statep, spin_lock_save_flags_t flags)
{
    spin_lock_saved_state_t state = 0;
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1434ea:	061b      	lsls	r3, r3, #24
  1434ec:	d41e      	bmi.n	14352c <ce_malloc+0x48>
    __asm__ volatile("cpsid i");
  1434ee:	b672      	cpsid	i
    *lock = 1;
  1434f0:	f24e 35d0 	movw	r5, #58320	; 0xe3d0
  1434f4:	2701      	movs	r7, #1
  1434f6:	f2c0 0515 	movt	r5, #21
  1434fa:	60ef      	str	r7, [r5, #12]
    for (i = 0; i < inheap.item_num; i++) {
  1434fc:	682e      	ldr	r6, [r5, #0]
  1434fe:	2e00      	cmp	r6, #0
  143500:	d031      	beq.n	143566 <ce_malloc+0x82>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  143502:	2200      	movs	r2, #0
        if ((inheap.mem_node_list[i].size >= size) && (inheap.mem_node_list[i].is_used == 0)) {
  143504:	eb02 0342 	add.w	r3, r2, r2, lsl #1
    for (i = 0; i < inheap.item_num; i++) {
  143508:	1c54      	adds	r4, r2, #1
        if ((inheap.mem_node_list[i].size >= size) && (inheap.mem_node_list[i].is_used == 0)) {
  14350a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
  14350e:	6919      	ldr	r1, [r3, #16]
  143510:	4281      	cmp	r1, r0
  143512:	d301      	bcc.n	143518 <ce_malloc+0x34>
  143514:	6959      	ldr	r1, [r3, #20]
  143516:	b1b1      	cbz	r1, 143546 <ce_malloc+0x62>
    for (i = 0; i < inheap.item_num; i++) {
  143518:	b2e2      	uxtb	r2, r4
  14351a:	42b2      	cmp	r2, r6
  14351c:	d3f2      	bcc.n	143504 <ce_malloc+0x20>
    struct mem_node* return_node = NULL;
  14351e:	2000      	movs	r0, #0
    *lock = 0;
  143520:	2300      	movs	r3, #0
  143522:	60eb      	str	r3, [r5, #12]
static inline void
arch_interrupt_restore(spin_lock_saved_state_t old_state, spin_lock_save_flags_t flags)
{
    if ((flags & SPIN_LOCK_FLAG_FIQ) && (old_state & SPIN_LOCK_STATE_RESTORE_FIQ))
        arch_enable_fiqs();
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  143524:	b107      	cbz	r7, 143528 <ce_malloc+0x44>
    __asm__ volatile("cpsie i");
  143526:	b662      	cpsie	i
}
  143528:	bcf0      	pop	{r4, r5, r6, r7}
  14352a:	4770      	bx	r14
    *lock = 1;
  14352c:	f24e 35d0 	movw	r5, #58320	; 0xe3d0
  143530:	2301      	movs	r3, #1
    spin_lock_saved_state_t state = 0;
  143532:	2700      	movs	r7, #0
    *lock = 1;
  143534:	f2c0 0515 	movt	r5, #21
  143538:	60eb      	str	r3, [r5, #12]
    for (i = 0; i < inheap.item_num; i++) {
  14353a:	682e      	ldr	r6, [r5, #0]
  14353c:	2e00      	cmp	r6, #0
  14353e:	d1e0      	bne.n	143502 <ce_malloc+0x1e>
    *lock = 0;
  143540:	60ee      	str	r6, [r5, #12]
    struct mem_node* return_node = NULL;
  143542:	4630      	mov	r0, r6
  143544:	e7f0      	b.n	143528 <ce_malloc+0x44>
            inheap.used_num++;
  143546:	6869      	ldr	r1, [r5, #4]
            inheap.mem_node_list[i].is_used = 1;
  143548:	2401      	movs	r4, #1
            if (inheap.used_num > inheap.used_num_max) {
  14354a:	68a8      	ldr	r0, [r5, #8]
            inheap.mem_node_list[i].is_used = 1;
  14354c:	615c      	str	r4, [r3, #20]
            inheap.used_num++;
  14354e:	4421      	add	r1, r4
            if (inheap.used_num > inheap.used_num_max) {
  143550:	4281      	cmp	r1, r0
            inheap.used_num++;
  143552:	6069      	str	r1, [r5, #4]
            return_node = &(inheap.mem_node_list[i]);
  143554:	f04f 000c 	mov.w	r0, #12
                inheap.used_num_max = inheap.used_num;
  143558:	bf88      	it	hi
  14355a:	60a9      	strhi	r1, [r5, #8]
            return_node = &(inheap.mem_node_list[i]);
  14355c:	fb00 5202 	mla	r2, r0, r2, r5
  143560:	f102 0010 	add.w	r0, r2, #16
            break;
  143564:	e7dc      	b.n	143520 <ce_malloc+0x3c>
  143566:	60ee      	str	r6, [r5, #12]
    struct mem_node* return_node = NULL;
  143568:	4630      	mov	r0, r6
  14356a:	e7dc      	b.n	143526 <ce_malloc+0x42>

0014356c <ce_free>:
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14356c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  143570:	f013 0280 	ands.w	r2, r3, #128	; 0x80
  143574:	d10e      	bne.n	143594 <ce_free+0x28>
    __asm__ volatile("cpsid i");
  143576:	b672      	cpsid	i
    *lock = 1;
  143578:	f24e 33d0 	movw	r3, #58320	; 0xe3d0
  14357c:	2101      	movs	r1, #1
  14357e:	f2c0 0315 	movt	r3, #21
  143582:	60d9      	str	r1, [r3, #12]
    if ((mem_node != NULL) && (mem_node->is_used == 1)) {
  143584:	b110      	cbz	r0, 14358c <ce_free+0x20>
  143586:	6841      	ldr	r1, [r0, #4]
  143588:	2901      	cmp	r1, #1
  14358a:	d00d      	beq.n	1435a8 <ce_free+0x3c>
    *lock = 0;
  14358c:	2200      	movs	r2, #0
  14358e:	60da      	str	r2, [r3, #12]
    __asm__ volatile("cpsie i");
  143590:	b662      	cpsie	i
}
  143592:	4770      	bx	r14
    *lock = 1;
  143594:	f24e 33d0 	movw	r3, #58320	; 0xe3d0
  143598:	2201      	movs	r2, #1
  14359a:	f2c0 0315 	movt	r3, #21
  14359e:	60da      	str	r2, [r3, #12]
    if ((mem_node != NULL) && (mem_node->is_used == 1)) {
  1435a0:	b948      	cbnz	r0, 1435b6 <ce_free+0x4a>
    *lock = 0;
  1435a2:	2200      	movs	r2, #0
  1435a4:	60da      	str	r2, [r3, #12]
}
  1435a6:	4770      	bx	r14
        inheap.used_num--;
  1435a8:	6859      	ldr	r1, [r3, #4]
        mem_node->is_used = 0;
  1435aa:	6042      	str	r2, [r0, #4]
  1435ac:	60da      	str	r2, [r3, #12]
        inheap.used_num--;
  1435ae:	3901      	subs	r1, #1
  1435b0:	6059      	str	r1, [r3, #4]
  1435b2:	b662      	cpsie	i
}
  1435b4:	4770      	bx	r14
    if ((mem_node != NULL) && (mem_node->is_used == 1)) {
  1435b6:	6842      	ldr	r2, [r0, #4]
  1435b8:	2a01      	cmp	r2, #1
  1435ba:	d1f2      	bne.n	1435a2 <ce_free+0x36>
        inheap.used_num--;
  1435bc:	685a      	ldr	r2, [r3, #4]
        mem_node->is_used = 0;
  1435be:	2100      	movs	r1, #0
  1435c0:	6041      	str	r1, [r0, #4]
        inheap.used_num--;
  1435c2:	3a01      	subs	r2, #1
  1435c4:	60d9      	str	r1, [r3, #12]
  1435c6:	605a      	str	r2, [r3, #4]
  1435c8:	4770      	bx	r14
  1435ca:	bf00      	nop

001435cc <addr_switch_to_ce>:
    if (EXT_MEM == addr_type_s) {
  1435cc:	2903      	cmp	r1, #3
{
  1435ce:	b510      	push	{r4, r14}
  1435d0:	4614      	mov	r4, r2
    if (EXT_MEM == addr_type_s) {
  1435d2:	d009      	beq.n	1435e8 <addr_switch_to_ce+0x1c>
    else if (SRAM_PUB == addr_type_s || SRAM_SEC == addr_type_s) {
  1435d4:	2901      	cmp	r1, #1
  1435d6:	d901      	bls.n	1435dc <addr_switch_to_ce+0x10>
}
  1435d8:	4620      	mov	r0, r4
  1435da:	bd10      	pop	{r4, r15}
        addr_switch = get_sram_base(vce_id);
  1435dc:	f7ff ff58 	bl	143490 <get_sram_base>
        addr_switch = ~addr_switch & addr;
  1435e0:	ea24 0400 	bic.w	r4, r4, r0
}
  1435e4:	4620      	mov	r0, r4
  1435e6:	bd10      	pop	{r4, r15}
        addr_switch = p2ap(addr);
  1435e8:	4610      	mov	r0, r2
}
  1435ea:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        addr_switch = p2ap(addr);
  1435ee:	f00a bf8d 	b.w	14e50c <p2ap>
  1435f2:	bf00      	nop

001435f4 <ce_init>:

int32_t ce_init(uint32_t vce_id)
{
    uint32_t int_base;

    if (vce_id >= VCE_COUNT) {
  1435f4:	2807      	cmp	r0, #7
  1435f6:	d829      	bhi.n	14364c <ce_init+0x58>
{
  1435f8:	b570      	push	{r4, r5, r6, r14}
    }

    int_base = ZONE_VCE0_INT + vce_id;
    g_ce_int_arg[vce_id] = vce_id;

    event_init(&g_ce_signal[vce_id], false, EVENT_FLAG_AUTOUNSIGNAL);
  1435fa:	f242 338c 	movw	r3, #9100	; 0x238c
  1435fe:	4604      	mov	r4, r0
    g_ce_int_arg[vce_id] = vce_id;
  143600:	f242 3584 	movw	r5, #9092	; 0x2384
    event_init(&g_ce_signal[vce_id], false, EVENT_FLAG_AUTOUNSIGNAL);
  143604:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  143608:	f2c0 0316 	movt	r3, #22
    g_ce_int_arg[vce_id] = vce_id;
  14360c:	f2c0 0516 	movt	r5, #22
    event_init(&g_ce_signal[vce_id], false, EVENT_FLAG_AUTOUNSIGNAL);
  143610:	2201      	movs	r2, #1
  143612:	eb03 0080 	add.w	r0, r3, r0, lsl #2
  143616:	2100      	movs	r1, #0
    int_base = ZONE_VCE0_INT + vce_id;
  143618:	f104 06cf 	add.w	r6, r4, #207	; 0xcf
    g_ce_int_arg[vce_id] = vce_id;
  14361c:	552c      	strb	r4, [r5, r4]
    event_init(&g_ce_signal[vce_id], false, EVENT_FLAG_AUTOUNSIGNAL);
  14361e:	f00b fd19 	bl	14f054 <event_init>
    register_int_handler(int_base, &ce_irq_handle, (void*)&g_ce_int_arg[vce_id]);
  143622:	f243 41a5 	movw	r1, #13477	; 0x34a5
  143626:	192a      	adds	r2, r5, r4
  143628:	4630      	mov	r0, r6
  14362a:	f2c0 0114 	movt	r1, #20

    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
  14362e:	0324      	lsls	r4, r4, #12
    register_int_handler(int_base, &ce_irq_handle, (void*)&g_ce_int_arg[vce_id]);
  143630:	f7fd f858 	bl	1406e4 <register_int_handler>
    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143634:	231f      	movs	r3, #31
  143636:	f104 4474 	add.w	r4, r4, #4093640704	; 0xf4000000
    writel(0x1f, _ioaddr(REG_INTEN_CE_(vce_id)));

    //enable interrupt
    unmask_interrupt(int_base);
  14363a:	4630      	mov	r0, r6
    writel(0x1f, _ioaddr(REG_INTCLR_CE_(vce_id)));
  14363c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    writel(0x1f, _ioaddr(REG_INTEN_CE_(vce_id)));
  143640:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
    unmask_interrupt(int_base);
  143644:	f7fd f8a0 	bl	140788 <unmask_interrupt>

    return 0;
  143648:	2000      	movs	r0, #0
}
  14364a:	bd70      	pop	{r4, r5, r6, r15}
        return -1;
  14364c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  143650:	4770      	bx	r14
  143652:	bf00      	nop

00143654 <ce_globle_init>:

int32_t ce_globle_init(void)
{
  143654:	b5f8      	push	{r3, r4, r5, r6, r7, r14}

    if (g_ce_inited) {
  143656:	f242 3480 	movw	r4, #9088	; 0x2380
  14365a:	f2c0 0416 	movt	r4, #22
  14365e:	7825      	ldrb	r5, [r4, #0]
  143660:	2d00      	cmp	r5, #0
  143662:	d141      	bne.n	1436e8 <ce_globle_init+0x94>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  143664:	f24e 33d0 	movw	r3, #58320	; 0xe3d0
    }

    LTRACEF("ce_globle_init enter\n");
    spin_lock_init(&(inheap.lock));

    event_init(&g_trng_signal, false, 0);
  143668:	f242 406c 	movw	r0, #9324	; 0x246c
  14366c:	462a      	mov	r2, r5
  14366e:	f2c0 0315 	movt	r3, #21
  143672:	4629      	mov	r1, r5
  143674:	f2c0 0016 	movt	r0, #22
  143678:	60dd      	str	r5, [r3, #12]
        writel(0xffff, _ioaddr(src_sec_base + i * 0x1000));
  14367a:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    event_init(&g_trng_signal, false, 0);
  14367e:	f00b fce9 	bl	14f054 <event_init>
    register_int_handler(ZONE_TRNG_INT, &trng_irq_handle, (void*)0);
  143682:	f243 41d1 	movw	r1, #13521	; 0x34d1
  143686:	462a      	mov	r2, r5
  143688:	20d7      	movs	r0, #215	; 0xd7
  14368a:	f2c0 0114 	movt	r1, #20
  14368e:	f7fd f829 	bl	1406e4 <register_int_handler>

    sram_config();
  143692:	f7ff fe7f 	bl	143394 <sram_config>
        writel(0xffff, _ioaddr(src_sec_base + i * 0x1000));
  143696:	2100      	movs	r1, #0
  143698:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  14369c:	f64f 73ff 	movw	r3, #65535	; 0xffff
  1436a0:	f6cf 0128 	movt	r1, #63528	; 0xf828
  1436a4:	f6cf 0228 	movt	r2, #63528	; 0xf828
  1436a8:	600b      	str	r3, [r1, #0]
  1436aa:	f6cf 0728 	movt	r7, #63528	; 0xf828
  1436ae:	6013      	str	r3, [r2, #0]
  1436b0:	f44f 5640 	mov.w	r6, #12288	; 0x3000
  1436b4:	f44f 4580 	mov.w	r5, #16384	; 0x4000
  1436b8:	f44f 40a0 	mov.w	r0, #20480	; 0x5000
  1436bc:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
  1436c0:	f44f 42e0 	mov.w	r2, #28672	; 0x7000
  1436c4:	603b      	str	r3, [r7, #0]
  1436c6:	f6cf 0628 	movt	r6, #63528	; 0xf828
  1436ca:	f6cf 0528 	movt	r5, #63528	; 0xf828
  1436ce:	f6cf 0028 	movt	r0, #63528	; 0xf828
  1436d2:	f6cf 0128 	movt	r1, #63528	; 0xf828
    init_vce_key_interface();

    g_ce_inited = true;
  1436d6:	2701      	movs	r7, #1
        writel(0xffff, _ioaddr(src_sec_base + i * 0x1000));
  1436d8:	f6cf 0228 	movt	r2, #63528	; 0xf828
  1436dc:	6033      	str	r3, [r6, #0]
  1436de:	602b      	str	r3, [r5, #0]
  1436e0:	6003      	str	r3, [r0, #0]
  1436e2:	600b      	str	r3, [r1, #0]
  1436e4:	6013      	str	r3, [r2, #0]
    g_ce_inited = true;
  1436e6:	7027      	strb	r7, [r4, #0]

    return 0;
}
  1436e8:	2000      	movs	r0, #0
  1436ea:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

001436ec <clean_cache_block>:

void clean_cache_block(block_t* data, uint32_t ce_id)
{
    if ((data == NULL) || (data->len == 0)) {
  1436ec:	b168      	cbz	r0, 14370a <clean_cache_block+0x1e>
{
  1436ee:	b538      	push	{r3, r4, r5, r14}
    if ((data == NULL) || (data->len == 0)) {
  1436f0:	6843      	ldr	r3, [r0, #4]
  1436f2:	b14b      	cbz	r3, 143708 <clean_cache_block+0x1c>
        return;
    }

    switch (data->addr_type) {
  1436f4:	6882      	ldr	r2, [r0, #8]
  1436f6:	b14a      	cbz	r2, 14370c <clean_cache_block+0x20>
  1436f8:	2a03      	cmp	r2, #3
  1436fa:	d105      	bne.n	143708 <clean_cache_block+0x1c>
        case EXT_MEM:
            arch_clean_cache_range((addr_t)data->addr, data->len);
  1436fc:	6800      	ldr	r0, [r0, #0]
  1436fe:	4619      	mov	r1, r3
            break;

        default:
            return;
    }
}
  143700:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
            arch_clean_cache_range((addr_t)data->addr, data->len);
  143704:	f011 b9e0 	b.w	154ac8 <__arch_clean_cache_range_from_thumb>
}
  143708:	bd38      	pop	{r3, r4, r5, r15}
  14370a:	4770      	bx	r14
  14370c:	4604      	mov	r4, r0
            arch_clean_cache_range(_vaddr((addr_t)data->addr + sram_addr(data->addr_type, ce_id)), data->len);
  14370e:	4610      	mov	r0, r2
  143710:	6825      	ldr	r5, [r4, #0]
  143712:	f7ff feb1 	bl	143478 <sram_addr>
  143716:	6861      	ldr	r1, [r4, #4]
  143718:	4428      	add	r0, r5
}
  14371a:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
            arch_clean_cache_range(_vaddr((addr_t)data->addr + sram_addr(data->addr_type, ce_id)), data->len);
  14371e:	f011 b9d3 	b.w	154ac8 <__arch_clean_cache_range_from_thumb>
  143722:	bf00      	nop

00143724 <invalidate_cache_block>:

void invalidate_cache_block(block_t* data, uint32_t ce_id)
{
    if ((data == NULL) || (data->len == 0)) {
  143724:	b168      	cbz	r0, 143742 <invalidate_cache_block+0x1e>
{
  143726:	b538      	push	{r3, r4, r5, r14}
    if ((data == NULL) || (data->len == 0)) {
  143728:	6843      	ldr	r3, [r0, #4]
  14372a:	b14b      	cbz	r3, 143740 <invalidate_cache_block+0x1c>
        return;
    }

    switch (data->addr_type) {
  14372c:	6882      	ldr	r2, [r0, #8]
  14372e:	b14a      	cbz	r2, 143744 <invalidate_cache_block+0x20>
  143730:	2a03      	cmp	r2, #3
  143732:	d105      	bne.n	143740 <invalidate_cache_block+0x1c>
        case EXT_MEM:
            arch_invalidate_cache_range((addr_t)data->addr, data->len);
  143734:	6800      	ldr	r0, [r0, #0]
  143736:	4619      	mov	r1, r3
            break;

        default:
            return;
    }
}
  143738:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
            arch_invalidate_cache_range((addr_t)data->addr, data->len);
  14373c:	f011 b9c0 	b.w	154ac0 <__arch_invalidate_cache_range_from_thumb>
}
  143740:	bd38      	pop	{r3, r4, r5, r15}
  143742:	4770      	bx	r14
  143744:	4604      	mov	r4, r0
            arch_invalidate_cache_range(_vaddr((addr_t)data->addr + sram_addr(data->addr_type, ce_id)), data->len);
  143746:	4610      	mov	r0, r2
  143748:	6825      	ldr	r5, [r4, #0]
  14374a:	f7ff fe95 	bl	143478 <sram_addr>
  14374e:	6861      	ldr	r1, [r4, #4]
  143750:	4428      	add	r0, r5
}
  143752:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
            arch_invalidate_cache_range(_vaddr((addr_t)data->addr + sram_addr(data->addr_type, ce_id)), data->len);
  143756:	f011 b9b3 	b.w	154ac0 <__arch_invalidate_cache_range_from_thumb>
  14375a:	bf00      	nop

0014375c <flush_cache>:
    arch_clean_cache_range(start, size);
}

void flush_cache(addr_t start, uint32_t size)
{
    arch_invalidate_cache_range(start, size);
  14375c:	f011 b9b0 	b.w	154ac0 <__arch_invalidate_cache_range_from_thumb>

00143760 <sx_hash_internal>:
                                 block_t extra_in,
                                 block_t key,
                                 op_type_t operation_type,
                                 block_t data_in,
                                 block_t data_out)
{
  143760:	b082      	sub	sp, #8
  143762:	2806      	cmp	r0, #6
  143764:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143768:	b09b      	sub	sp, #108	; 0x6c
  14376a:	ac24      	add	r4, sp, #144	; 0x90
  14376c:	9f2a      	ldr	r7, [sp, #168]	; 0xa8
  14376e:	e884 000c 	stmia.w	r4, {r2, r3}
  143772:	d80e      	bhi.n	143792 <sx_hash_internal+0x32>
    hash_reg_config_t reg_config;
    uint32_t hash_len;

    hash_len = hash_get_digest_size(hash_alg);

    if (hash_len > data_out.len) {
  143774:	9a2f      	ldr	r2, [sp, #188]	; 0xbc
  143776:	f245 6378 	movw	r3, #22136	; 0x5678
  14377a:	f2c0 0315 	movt	r3, #21
  14377e:	f853 8020 	ldr.w	r8, [r3, r0, lsl #2]
  143782:	4542      	cmp	r2, r8
  143784:	d207      	bcs.n	143796 <sx_hash_internal+0x36>
        return CRYPTOLIB_INVALID_PARAM_OUTPUT;
  143786:	200e      	movs	r0, #14
            return CRYPTOLIB_INVALID_PARAM_OUTPUT;
        }
    }

    return CRYPTOLIB_SUCCESS;
}
  143788:	b01b      	add	sp, #108	; 0x6c
  14378a:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14378e:	b002      	add	sp, #8
  143790:	4770      	bx	r14
{
  143792:	f04f 0800 	mov.w	r8, #0
    memset((void*)(&reg_config), 0, sizeof(reg_config));
  143796:	2234      	movs	r2, #52	; 0x34
  143798:	4604      	mov	r4, r0
  14379a:	460d      	mov	r5, r1
  14379c:	eb0d 0002 	add.w	r0, r13, r2
  1437a0:	f8dd 90b8 	ldr.w	r9, [r13, #184]	; 0xb8
  1437a4:	2100      	movs	r1, #0
  1437a6:	9e30      	ldr	r6, [sp, #192]	; 0xc0
  1437a8:	f00f ec68 	blx	15307c <memset>
    if (0 == extra_in.len) {
  1437ac:	9a25      	ldr	r2, [sp, #148]	; 0x94
    reg_config.mode = 1UL << hash_alg;
  1437ae:	2301      	movs	r3, #1
  1437b0:	fa03 f404 	lsl.w	r4, r3, r4
  1437b4:	9410      	str	r4, [sp, #64]	; 0x40
    if (0 == extra_in.len) {
  1437b6:	2a00      	cmp	r2, #0
  1437b8:	f040 80d5 	bne.w	143966 <sx_hash_internal+0x206>
    switch (operation_type) {
  1437bc:	2f03      	cmp	r7, #3
  1437be:	f000 80e9 	beq.w	143994 <sx_hash_internal+0x234>
  1437c2:	2f04      	cmp	r7, #4
  1437c4:	d012      	beq.n	1437ec <sx_hash_internal+0x8c>
            reg_config.hmac_en = true;
  1437c6:	2301      	movs	r3, #1
    switch (operation_type) {
  1437c8:	2f02      	cmp	r7, #2
            reg_config.hmac_en = true;
  1437ca:	bf01      	itttt	eq
  1437cc:	f88d 3034 	strbeq.w	r3, [r13, #52]	; 0x34
            reg_config.key_addr = (addr_t)key.addr;
  1437d0:	9927      	ldreq	r1, [sp, #156]	; 0x9c
            reg_config.key_load = true;
  1437d2:	f88d 3035 	strbeq.w	r3, [r13, #53]	; 0x35
            reg_config.padding = 1;
  1437d6:	f88d 303e 	strbeq.w	r3, [r13, #62]	; 0x3e
            reg_config.key_addr_type = key.addr_type;
  1437da:	bf05      	ittet	eq
  1437dc:	9a29      	ldreq	r2, [sp, #164]	; 0xa4
            reg_config.key_len = key.len;
  1437de:	9b28      	ldreq	r3, [sp, #160]	; 0xa0
            reg_config.padding = 1;
  1437e0:	f88d 303e 	strbne.w	r3, [r13, #62]	; 0x3e
            reg_config.key_addr = (addr_t)key.addr;
  1437e4:	9111      	streq	r1, [sp, #68]	; 0x44
            reg_config.key_len = key.len;
  1437e6:	bf08      	it	eq
  1437e8:	e9cd 2313 	strdeq	r2, r3, [r13, #76]	; 0x4c
        reg_config.src_addr = addr_switch_to_ce(ce_id, data_in.addr_type, (addr_t)(data_in.addr));
  1437ec:	9a2b      	ldr	r2, [sp, #172]	; 0xac
  1437ee:	4628      	mov	r0, r5
  1437f0:	992d      	ldr	r1, [sp, #180]	; 0xb4
  1437f2:	f7ff feeb 	bl	1435cc <addr_switch_to_ce>
    reg_config.src_type = switch_addr_type(data_in.addr_type);
  1437f6:	9b2d      	ldr	r3, [sp, #180]	; 0xb4
        reg_config.dst_addr = addr_switch_to_ce(ce_id, data_out.addr_type, (addr_t)data_out.addr);
  1437f8:	4631      	mov	r1, r6
  1437fa:	2b04      	cmp	r3, #4
  1437fc:	bf92      	itee	ls
  1437fe:	f245 6294 	movwls	r2, #22164	; 0x5694
    reg_config.src_type = switch_addr_type(data_in.addr_type);
  143802:	2700      	movhi	r7, #0
  143804:	463b      	movhi	r3, r7
        reg_config.src_addr = addr_switch_to_ce(ce_id, data_in.addr_type, (addr_t)(data_in.addr));
  143806:	9016      	str	r0, [sp, #88]	; 0x58
  143808:	bf98      	it	ls
  14380a:	f2c0 0215 	movtls	r2, #21
        reg_config.dst_addr = addr_switch_to_ce(ce_id, data_out.addr_type, (addr_t)data_out.addr);
  14380e:	4628      	mov	r0, r5
  143810:	bf98      	it	ls
  143812:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
  143816:	464a      	mov	r2, r9
    reg_config.src_type = switch_addr_type(data_in.addr_type);
  143818:	9317      	str	r3, [sp, #92]	; 0x5c
  14381a:	bf9c      	itt	ls
  14381c:	021f      	lslls	r7, r3, #8
  14381e:	f407 67e0 	andls.w	r7, r7, #1792	; 0x700
        reg_config.dst_addr = addr_switch_to_ce(ce_id, data_out.addr_type, (addr_t)data_out.addr);
  143822:	f7ff fed3 	bl	1435cc <addr_switch_to_ce>
  143826:	2e04      	cmp	r6, #4
  143828:	9018      	str	r0, [sp, #96]	; 0x60
  14382a:	f200 80a6 	bhi.w	14397a <sx_hash_internal+0x21a>
    reg_config.dst_type = switch_addr_type(data_out.addr_type);
  14382e:	f245 6394 	movw	r3, #22164	; 0x5694
    if ((EXT_MEM == data_out.addr_type) || ((NULL == data_out.addr))) {
  143832:	2e03      	cmp	r6, #3
    reg_config.dst_type = switch_addr_type(data_out.addr_type);
  143834:	f2c0 0315 	movt	r3, #21
  143838:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
  14383c:	9319      	str	r3, [sp, #100]	; 0x64
    if ((EXT_MEM == data_out.addr_type) || ((NULL == data_out.addr))) {
  14383e:	f040 809c 	bne.w	14397a <sx_hash_internal+0x21a>
        reg_config.dst_addr = CE2_SRAM_PUB_HASH_OUT_ADDR_OFFSET; //base address of public sram
  143842:	f44f 627c 	mov.w	r2, #4032	; 0xfc0
        reg_config.dst_type = switch_addr_type(SRAM_PUB);
  143846:	2301      	movs	r3, #1
  143848:	4692      	mov	r10, r2
        reg_config.dst_addr = CE2_SRAM_PUB_HASH_OUT_ADDR_OFFSET; //base address of public sram
  14384a:	9218      	str	r2, [sp, #96]	; 0x60
        reg_config.dst_type = switch_addr_type(SRAM_PUB);
  14384c:	f2c0 0a01 	movt	r10, #1
  143850:	9319      	str	r3, [sp, #100]	; 0x64
    reg_config.data_len = data_in.len;
  143852:	f8dd b0b0 	ldr.w	r11, [r13, #176]	; 0xb0
    clean_cache_block(&data_in, ce_id);
  143856:	4629      	mov	r1, r5
    reg_config.data_len = data_in.len;
  143858:	f8cd b054 	str.w	r11, [r13, #84]	; 0x54
    clean_cache_block(&data_in, ce_id);
  14385c:	a82b      	add	r0, sp, #172	; 0xac
  14385e:	f7ff ff45 	bl	1436ec <clean_cache_block>
    flush_cache(_ioaddr(get_sram_base(ce_id) + CE2_SRAM_PUB_HASH_OUT_ADDR_OFFSET), hash_len);
  143862:	4628      	mov	r0, r5
  143864:	f7ff fe14 	bl	143490 <get_sram_base>
  143868:	4641      	mov	r1, r8
    if ((EXT_MEM == data_out.addr_type) && (NULL != data_out.addr)) {
  14386a:	f1a6 0603 	sub.w	r6, r6, #3
  14386e:	fab6 f686 	clz	r6, r6
  143872:	0976      	lsrs	r6, r6, #5
    flush_cache(_ioaddr(get_sram_base(ce_id) + CE2_SRAM_PUB_HASH_OUT_ADDR_OFFSET), hash_len);
  143874:	f500 607c 	add.w	r0, r0, #4032	; 0xfc0
  143878:	f7ff ff70 	bl	14375c <flush_cache>
    hash_run(ce_id, reg_config);
  14387c:	f89d 3034 	ldrb.w	r3, [r13, #52]	; 0x34
  143880:	f89d 0035 	ldrb.w	r0, [r13, #53]	; 0x35
  143884:	f89d c03c 	ldrb.w	r12, [r13, #60]	; 0x3c
  143888:	e9dd 2113 	ldrd	r2, r1, [r13, #76]	; 0x4c
#ifndef _SD_SYSDEF_H
#define _SD_SYSDEF_H

inline static uint32_t reg_value(uint32_t val, uint32_t src, uint32_t shift, uint32_t mask)
{
  return (src & ~mask) | ((val << shift) & mask);
  14388c:	061b      	lsls	r3, r3, #24
  14388e:	ea83 40c0 	eor.w	r0, r3, r0, lsl #19
  143892:	f8bd e048 	ldrh.w	r14, [r13, #72]	; 0x48
  143896:	f400 2000 	and.w	r0, r0, #524288	; 0x80000
  14389a:	4058      	eors	r0, r3
  14389c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  14389e:	0412      	lsls	r2, r2, #16
  1438a0:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
  1438a4:	b289      	uxth	r1, r1
  1438a6:	ea80 4383 	eor.w	r3, r0, r3, lsl #18
  1438aa:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  1438ae:	4043      	eors	r3, r0
  1438b0:	ea83 404c 	eor.w	r0, r3, r12, lsl #17
  1438b4:	f89d c03d 	ldrb.w	r12, [r13, #61]	; 0x3d
  1438b8:	f400 3000 	and.w	r0, r0, #131072	; 0x20000
  1438bc:	4058      	eors	r0, r3
  1438be:	ea80 4c0c 	eor.w	r12, r0, r12, lsl #16
  1438c2:	f40c 3c80 	and.w	r12, r12, #65536	; 0x10000
  1438c6:	ea8c 0300 	eor.w	r3, r12, r0
  1438ca:	f89d c03e 	ldrb.w	r12, [r13, #62]	; 0x3e
  1438ce:	ea83 3ccc 	eor.w	r12, r3, r12, lsl #15
  1438d2:	f40c 4c00 	and.w	r12, r12, #32768	; 0x8000
  1438d6:	ea8c 0c03 	eor.w	r12, r12, r3
  1438da:	9b11      	ldr	r3, [sp, #68]	; 0x44
  1438dc:	ea8c 2404 	eor.w	r4, r12, r4, lsl #8
  1438e0:	f404 40fe 	and.w	r0, r4, #32512	; 0x7f00
    writel(value, _ioaddr(REG_HASH_KEYIV_ADDR_CE_(vce_id)));
  1438e4:	032c      	lsls	r4, r5, #12
  1438e6:	f104 4474 	add.w	r4, r4, #4093640704	; 0xf4000000
  1438ea:	ea4e 4303 	orr.w	r3, r14, r3, lsl #16
  1438ee:	f08c 0c01 	eor.w	r12, r12, #1
  1438f2:	6363      	str	r3, [r4, #52]	; 0x34
  1438f4:	4311      	orrs	r1, r2
    hash_run(ce_id, reg_config);
  1438f6:	9b16      	ldr	r3, [sp, #88]	; 0x58
  1438f8:	ea80 020c 	eor.w	r2, r0, r12
    event_wait(&g_ce_signal[vce_id]);
  1438fc:	f242 3c8c 	movw	r12, #9100	; 0x238c
  143900:	ebc5 00c5 	rsb	r0, r5, r5, lsl #3
    writel(value, _ioaddr(REG_HMAC_KEY_CTRL_CE_(vce_id)));
  143904:	63a1      	str	r1, [r4, #56]	; 0x38
    event_wait(&g_ce_signal[vce_id]);
  143906:	f2c0 0c16 	movt	r12, #22
    writel(value, _ioaddr(REG_HASH_CALC_LEN_CE_(vce_id)));
  14390a:	f8c4 b03c 	str.w	r11, [r4, #60]	; 0x3c
    return e->magic == EVENT_MAGIC;
}

static inline status_t event_wait(event_t *e)
{
    return event_wait_timeout(e, INFINITE_TIME);
  14390e:	eb0c 0080 	add.w	r0, r12, r0, lsl #2
    writel(value, _ioaddr(REG_HASH_SRC_ADDR_CE_(vce_id)));
  143912:	6423      	str	r3, [r4, #64]	; 0x40
  143914:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    writel(value, _ioaddr(REG_HASH_SRC_ADDR_H_CE_(vce_id)));
  143918:	6467      	str	r7, [r4, #68]	; 0x44
    writel(value, _ioaddr(REG_HASH_DST_ADDR_CE_(vce_id)));
  14391a:	f8c4 a048 	str.w	r10, [r4, #72]	; 0x48
    writel(value, _ioaddr(REG_HASH_CTRL_CE_(vce_id)));
  14391e:	6322      	str	r2, [r4, #48]	; 0x30
  143920:	f00b fbae 	bl	14f080 <event_wait_timeout>
    uint32_t value_state = readl(_ioaddr(REG_INTCLR_CE_(vce_id)));
  143924:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  143928:	43d3      	mvns	r3, r2
  14392a:	f003 0308 	and.w	r3, r3, #8
  14392e:	4053      	eors	r3, r2
  143930:	f023 0208 	bic.w	r2, r3, #8
    writel(value, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143934:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    writel(value, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143938:	f8c4 2148 	str.w	r2, [r4, #328]	; 0x148
    value_state = readl(_ioaddr(REG_ERRSTAT_CE_(vce_id))) & 0xF;
  14393c:	6863      	ldr	r3, [r4, #4]
    if (0 != value_state) {
  14393e:	071b      	lsls	r3, r3, #28
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143940:	bf1f      	itttt	ne
  143942:	f44f 6200 	movne.w	r2, #2048	; 0x800
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143946:	2300      	movne	r3, #0
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  143948:	f8c4 2148 	strne.w	r2, [r4, #328]	; 0x148
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  14394c:	f8c4 3148 	strne.w	r3, [r4, #328]	; 0x148
    if ((EXT_MEM == data_out.addr_type) && (NULL != data_out.addr)) {
  143950:	f1b9 0f00 	cmp.w	r9, #0
  143954:	bf08      	it	eq
  143956:	2600      	moveq	r6, #0
  143958:	bb06      	cbnz	r6, 14399c <sx_hash_internal+0x23c>
    return CRYPTOLIB_SUCCESS;
  14395a:	2000      	movs	r0, #0
}
  14395c:	b01b      	add	sp, #108	; 0x6c
  14395e:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143962:	b002      	add	sp, #8
  143964:	4770      	bx	r14
        reg_config.iv_addr = (addr_t)extra_in.addr;
  143966:	9a24      	ldr	r2, [sp, #144]	; 0x90
    switch (operation_type) {
  143968:	2f03      	cmp	r7, #3
        reg_config.iv_load = true;
  14396a:	f88d 303c 	strb.w	r3, [r13, #60]	; 0x3c
        reg_config.iv_type = extra_in.addr_type; //switch_addr_type(extra_in.addr_type);
  14396e:	9b26      	ldr	r3, [sp, #152]	; 0x98
        reg_config.iv_addr = (addr_t)extra_in.addr;
  143970:	9212      	str	r2, [sp, #72]	; 0x48
        reg_config.iv_type = extra_in.addr_type; //switch_addr_type(extra_in.addr_type);
  143972:	930e      	str	r3, [sp, #56]	; 0x38
    switch (operation_type) {
  143974:	f47f af25 	bne.w	1437c2 <sx_hash_internal+0x62>
  143978:	e00c      	b.n	143994 <sx_hash_internal+0x234>
    if ((EXT_MEM == data_out.addr_type) || ((NULL == data_out.addr))) {
  14397a:	f1b9 0f00 	cmp.w	r9, #0
  14397e:	f43f af60 	beq.w	143842 <sx_hash_internal+0xe2>
  143982:	9b19      	ldr	r3, [sp, #100]	; 0x64
  143984:	b280      	uxth	r0, r0
  143986:	ea40 4a03 	orr.w	r10, r0, r3, lsl #16
  14398a:	f40a 2ae0 	and.w	r10, r10, #458752	; 0x70000
  14398e:	ea4a 0a00 	orr.w	r10, r10, r0
  143992:	e75e      	b.n	143852 <sx_hash_internal+0xf2>
            reg_config.update = true;
  143994:	2301      	movs	r3, #1
  143996:	f88d 303d 	strb.w	r3, [r13, #61]	; 0x3d
            break;
  14399a:	e727      	b.n	1437ec <sx_hash_internal+0x8c>
    //'compound literals' are not valid in C++
    block_t  blk = BLOCK_T_CONV(array, length, addr_type);
    return blk;
#else
    //'compound literal' (used below) is valid in C99
    return (block_t)BLOCK_T_CONV(array, length, addr_type);
  14399c:	2100      	movs	r1, #0
        ret = memcpy_blk_cache(ce_id, block_t_convert((void*)data_out.addr, hash_len, data_out.addr_type),
  14399e:	aa0a      	add	r2, sp, #40	; 0x28
  1439a0:	f44f 607c 	mov.w	r0, #4032	; 0xfc0
  1439a4:	ab07      	add	r3, sp, #28
  1439a6:	e9cd 8103 	strd	r8, r1, [r13, #12]
  1439aa:	2603      	movs	r6, #3
  1439ac:	f8cd 802c 	str.w	r8, [r13, #44]	; 0x2c
  1439b0:	2401      	movs	r4, #1
  1439b2:	900a      	str	r0, [sp, #40]	; 0x28
  1439b4:	910c      	str	r1, [sp, #48]	; 0x30
  1439b6:	ca07      	ldmia	r2, {r0, r1, r2}
  1439b8:	e9cd 9807 	strd	r9, r8, [r13, #28]
  1439bc:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  1439c0:	9609      	str	r6, [sp, #36]	; 0x24
  1439c2:	4628      	mov	r0, r5
  1439c4:	9405      	str	r4, [sp, #20]
  1439c6:	cb0e      	ldmia	r3, {r1, r2, r3}
  1439c8:	f001 fa1e 	bl	144e08 <memcpy_blk_cache>
        if (ret) {
  1439cc:	2800      	cmp	r0, #0
  1439ce:	d0c4      	beq.n	14395a <sx_hash_internal+0x1fa>
  1439d0:	e6d9      	b.n	143786 <sx_hash_internal+0x26>
  1439d2:	bf00      	nop

001439d4 <hash_get_digest_size>:
    return pad_size;
}

/* Public functions: properties */
uint32_t hash_get_digest_size(hash_alg_t hash_alg)
{
  1439d4:	2806      	cmp	r0, #6
  1439d6:	bf9d      	ittte	ls
  1439d8:	f245 6378 	movwls	r3, #22136	; 0x5678
  1439dc:	f2c0 0315 	movtls	r3, #21
  1439e0:	f853 0020 	ldrls.w	r0, [r3, r0, lsl #2]
  1439e4:	2000      	movhi	r0, #0
            return SM3_DIGESTSIZE;

        default:
            return 0;
    }
}
  1439e6:	4770      	bx	r14

001439e8 <hash_blk>:
    hash_alg_t hash_alg,
    uint32_t ce_id,
    block_t iv,
    block_t data_in,
    block_t data_out)
{
  1439e8:	b082      	sub	sp, #8
  1439ea:	2806      	cmp	r0, #6
  1439ec:	b5f0      	push	{r4, r5, r6, r7, r14}
  1439ee:	b091      	sub	sp, #68	; 0x44
  1439f0:	ac16      	add	r4, sp, #88	; 0x58
  1439f2:	e884 000c 	stmia.w	r4, {r2, r3}
  1439f6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  1439f8:	d819      	bhi.n	143a2e <hash_blk+0x46>
  1439fa:	9c18      	ldr	r4, [sp, #96]	; 0x60
  1439fc:	f245 62c4 	movw	r2, #22212	; 0x56c4
  143a00:	f2c0 0215 	movt	r2, #21
  143a04:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    uint32_t digest_len;
    uint32_t initsize;

    initsize = hash_get_state_size(hash_alg);

    if ((0 != iv.len) && (/*(NULL == iv.addr) || */(initsize != iv.len) || (KEY_INT == iv.addr_type) || (EXT_MEM == iv.addr_type))) {
  143a08:	2b00      	cmp	r3, #0
  143a0a:	d13e      	bne.n	143a8a <hash_blk+0xa2>
        return CRYPTOLIB_INVALID_PARAM;
    }

    if ((0 == data_in.len) /*|| (NULL == data_in.addr)*/) {
  143a0c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  143a0e:	b143      	cbz	r3, 143a22 <hash_blk+0x3a>
        return CRYPTOLIB_INVALID_PARAM;
    }

    digest_len = hash_get_digest_size(hash_alg);

    if ((data_out.len < digest_len) || (NULL == data_out.addr)) {
  143a10:	9a1d      	ldr	r2, [sp, #116]	; 0x74
  143a12:	f245 6378 	movw	r3, #22136	; 0x5678
  143a16:	f2c0 0315 	movt	r3, #21
  143a1a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  143a1e:	429a      	cmp	r2, r3
  143a20:	d20a      	bcs.n	143a38 <hash_blk+0x50>
        return CRYPTOLIB_INVALID_PARAM;
  143a22:	2009      	movs	r0, #9
        return CRYPTOLIB_INVALID_PARAM;
    }

    return sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, 0), OP_FULL_HASH,
                            data_in, data_out);
}
  143a24:	b011      	add	sp, #68	; 0x44
  143a26:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143a2a:	b002      	add	sp, #8
  143a2c:	4770      	bx	r14
    if ((0 != iv.len) && (/*(NULL == iv.addr) || */(initsize != iv.len) || (KEY_INT == iv.addr_type) || (EXT_MEM == iv.addr_type))) {
  143a2e:	2b00      	cmp	r3, #0
  143a30:	d1f7      	bne.n	143a22 <hash_blk+0x3a>
    if ((0 == data_in.len) /*|| (NULL == data_in.addr)*/) {
  143a32:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  143a34:	2b00      	cmp	r3, #0
  143a36:	d0f4      	beq.n	143a22 <hash_blk+0x3a>
    if ((data_out.len < digest_len) || (NULL == data_out.addr)) {
  143a38:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  143a3a:	2b00      	cmp	r3, #0
  143a3c:	d0f1      	beq.n	143a22 <hash_blk+0x3a>
    return sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, 0), OP_FULL_HASH,
  143a3e:	aa1c      	add	r2, sp, #112	; 0x70
  143a40:	460e      	mov	r6, r1
  143a42:	ac19      	add	r4, sp, #100	; 0x64
  143a44:	4605      	mov	r5, r0
  143a46:	ab08      	add	r3, sp, #32
  143a48:	ca07      	ldmia	r2, {r0, r1, r2}
  143a4a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143a4e:	ab05      	add	r3, sp, #20
  143a50:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
  143a54:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143a58:	2400      	movs	r4, #0
  143a5a:	aa10      	add	r2, sp, #64	; 0x40
  143a5c:	2701      	movs	r7, #1
  143a5e:	ab01      	add	r3, sp, #4
  143a60:	940d      	str	r4, [sp, #52]	; 0x34
  143a62:	940e      	str	r4, [sp, #56]	; 0x38
  143a64:	940f      	str	r4, [sp, #60]	; 0x3c
  143a66:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  143a6a:	9c18      	ldr	r4, [sp, #96]	; 0x60
  143a6c:	9704      	str	r7, [sp, #16]
  143a6e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143a72:	9400      	str	r4, [sp, #0]
  143a74:	ab16      	add	r3, sp, #88	; 0x58
  143a76:	4631      	mov	r1, r6
  143a78:	4628      	mov	r0, r5
  143a7a:	cb0c      	ldmia	r3, {r2, r3}
  143a7c:	f7ff fe70 	bl	143760 <sx_hash_internal>
}
  143a80:	b011      	add	sp, #68	; 0x44
  143a82:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143a86:	b002      	add	sp, #8
  143a88:	4770      	bx	r14
    if ((0 != iv.len) && (/*(NULL == iv.addr) || */(initsize != iv.len) || (KEY_INT == iv.addr_type) || (EXT_MEM == iv.addr_type))) {
  143a8a:	1a9b      	subs	r3, r3, r2
  143a8c:	bf18      	it	ne
  143a8e:	2301      	movne	r3, #1
  143a90:	3c02      	subs	r4, #2
  143a92:	2c01      	cmp	r4, #1
  143a94:	bf98      	it	ls
  143a96:	f043 0301 	orrls.w	r3, r3, #1
  143a9a:	2b00      	cmp	r3, #0
  143a9c:	d0b6      	beq.n	143a0c <hash_blk+0x24>
  143a9e:	e7c0      	b.n	143a22 <hash_blk+0x3a>

00143aa0 <hmac_blk>:
    uint32_t ce_id,
    block_t iv,
    block_t key,
    block_t data_in,
    block_t data_out)
{
  143aa0:	b082      	sub	sp, #8
  143aa2:	2806      	cmp	r0, #6
  143aa4:	b5f0      	push	{r4, r5, r6, r7, r14}
  143aa6:	b08d      	sub	sp, #52	; 0x34
  143aa8:	ac12      	add	r4, sp, #72	; 0x48
  143aaa:	e884 000c 	stmia.w	r4, {r2, r3}
  143aae:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  143ab0:	d80f      	bhi.n	143ad2 <hmac_blk+0x32>
  143ab2:	9c14      	ldr	r4, [sp, #80]	; 0x50
  143ab4:	f245 62c4 	movw	r2, #22212	; 0x56c4
  143ab8:	f2c0 0215 	movt	r2, #21
  143abc:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
    uint32_t init_size;
    uint32_t digest_len;

    init_size = hash_get_state_size(hash_alg);

    if ((0 != iv.len) && (/*(NULL == iv.addr) || */(init_size != iv.len) || (KEY_INT == iv.addr_type) || (EXT_MEM == iv.addr_type))) {
  143ac0:	b14b      	cbz	r3, 143ad6 <hmac_blk+0x36>
  143ac2:	1a9b      	subs	r3, r3, r2
  143ac4:	bf18      	it	ne
  143ac6:	2301      	movne	r3, #1
  143ac8:	3c02      	subs	r4, #2
  143aca:	2c01      	cmp	r4, #1
  143acc:	bf98      	it	ls
  143ace:	f043 0301 	orrls.w	r3, r3, #1
  143ad2:	2b00      	cmp	r3, #0
  143ad4:	d136      	bne.n	143b44 <hmac_blk+0xa4>
        return CRYPTOLIB_INVALID_PARAM;
    }

    if ((0 == key.len) /*|| (NULL == key.addr)*/ || (EXT_MEM == key.addr_type)) {
  143ad6:	9b16      	ldr	r3, [sp, #88]	; 0x58
  143ad8:	2b00      	cmp	r3, #0
  143ada:	d033      	beq.n	143b44 <hmac_blk+0xa4>
  143adc:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  143ade:	2b03      	cmp	r3, #3
  143ae0:	d030      	beq.n	143b44 <hmac_blk+0xa4>
        return CRYPTOLIB_INVALID_PARAM;
    }

    if ((0 == data_in.len)/* || (NULL == data_in.addr)*/) {
  143ae2:	9b19      	ldr	r3, [sp, #100]	; 0x64
  143ae4:	b373      	cbz	r3, 143b44 <hmac_blk+0xa4>
  143ae6:	2806      	cmp	r0, #6
  143ae8:	d923      	bls.n	143b32 <hmac_blk+0x92>
        return CRYPTOLIB_INVALID_PARAM;
    }

    digest_len = hash_get_digest_size(hash_alg);

    if ((data_out.len < digest_len) || (NULL == data_out.addr)) {
  143aea:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  143aec:	b353      	cbz	r3, 143b44 <hmac_blk+0xa4>
  143aee:	460e      	mov	r6, r1
        return CRYPTOLIB_INVALID_PARAM;
    }

    return sx_hash_internal(hash_alg, ce_id, iv, key, OP_FULL_HMAC, data_in, data_out);
  143af0:	aa1b      	add	r2, sp, #108	; 0x6c
  143af2:	4605      	mov	r5, r0
  143af4:	ab18      	add	r3, sp, #96	; 0x60
  143af6:	2702      	movs	r7, #2
  143af8:	ac08      	add	r4, sp, #32
  143afa:	ca07      	ldmia	r2, {r0, r1, r2}
  143afc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  143b00:	ac15      	add	r4, sp, #84	; 0x54
  143b02:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  143b06:	ab05      	add	r3, sp, #20
  143b08:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143b0c:	ab01      	add	r3, sp, #4
  143b0e:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
  143b12:	9704      	str	r7, [sp, #16]
  143b14:	9c14      	ldr	r4, [sp, #80]	; 0x50
  143b16:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143b1a:	9400      	str	r4, [sp, #0]
  143b1c:	ab12      	add	r3, sp, #72	; 0x48
  143b1e:	4631      	mov	r1, r6
  143b20:	4628      	mov	r0, r5
  143b22:	cb0c      	ldmia	r3, {r2, r3}
  143b24:	f7ff fe1c 	bl	143760 <sx_hash_internal>
}
  143b28:	b00d      	add	sp, #52	; 0x34
  143b2a:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143b2e:	b002      	add	sp, #8
  143b30:	4770      	bx	r14
    if ((data_out.len < digest_len) || (NULL == data_out.addr)) {
  143b32:	9a1c      	ldr	r2, [sp, #112]	; 0x70
  143b34:	f245 6378 	movw	r3, #22136	; 0x5678
  143b38:	f2c0 0315 	movt	r3, #21
  143b3c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  143b40:	429a      	cmp	r2, r3
  143b42:	d2d2      	bcs.n	143aea <hmac_blk+0x4a>
        return CRYPTOLIB_INVALID_PARAM;
  143b44:	2009      	movs	r0, #9
}
  143b46:	b00d      	add	sp, #52	; 0x34
  143b48:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143b4c:	b002      	add	sp, #8
  143b4e:	4770      	bx	r14

00143b50 <hash_update_blk>:
uint32_t hash_update_blk(
    hash_alg_t hash_alg,
    uint32_t ce_id,
    bool first_part,
    block_t data_in)
{
  143b50:	b082      	sub	sp, #8
  143b52:	b5f0      	push	{r4, r5, r6, r7, r14}
  143b54:	b097      	sub	sp, #92	; 0x5c
  143b56:	931d      	str	r3, [sp, #116]	; 0x74
  143b58:	9c1e      	ldr	r4, [sp, #120]	; 0x78
    uint32_t blocksize;
    block_t iv;

    if ((0 == data_in.len) || (NULL == data_in.addr)) {
  143b5a:	b144      	cbz	r4, 143b6e <hash_update_blk+0x1e>
  143b5c:	2806      	cmp	r0, #6
  143b5e:	bf8c      	ite	hi
  143b60:	2500      	movhi	r5, #0
  143b62:	2501      	movls	r5, #1
  143b64:	2b00      	cmp	r3, #0
  143b66:	bf14      	ite	ne
  143b68:	462b      	movne	r3, r5
  143b6a:	2300      	moveq	r3, #0
  143b6c:	b92b      	cbnz	r3, 143b7a <hash_update_blk+0x2a>
        LTRACEF("hash_update_blk check data_in fail.\n");
        return CRYPTOLIB_INVALID_PARAM;
  143b6e:	2009      	movs	r0, #9
        iv = block_t_convert((uint8_t*)CE2_SRAM_PUB_HASH_MULT_PART_UPDATE_IV_ADDR_OFFSET, hash_get_digest_size(hash_alg), SRAM_PUB);
    }

    return sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, SRAM_PUB), OP_PART_HASH, data_in, block_t_convert((uint8_t*)CE2_SRAM_PUB_HASH_MULT_PART_UPDATE_IV_ADDR_OFFSET, hash_get_digest_size(hash_alg), SRAM_PUB));

}
  143b70:	b017      	add	sp, #92	; 0x5c
  143b72:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143b76:	b002      	add	sp, #8
  143b78:	4770      	bx	r14
    if (0 != (data_in.len & (blocksize - 1))) {
  143b7a:	f245 63a8 	movw	r3, #22184	; 0x56a8
  143b7e:	f2c0 0315 	movt	r3, #21
  143b82:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
  143b86:	3b01      	subs	r3, #1
  143b88:	4023      	ands	r3, r4
  143b8a:	d1f0      	bne.n	143b6e <hash_update_blk+0x1e>
  143b8c:	f245 6578 	movw	r5, #22136	; 0x5678
    if (first_part) {
  143b90:	2a00      	cmp	r2, #0
  143b92:	d138      	bne.n	143c06 <hash_update_blk+0xb6>
        iv = block_t_convert((uint8_t*)CE2_SRAM_PUB_HASH_MULT_PART_UPDATE_IV_ADDR_OFFSET, hash_get_digest_size(hash_alg), SRAM_PUB);
  143b94:	f44f 6378 	mov.w	r3, #3968	; 0xf80
  143b98:	f2c0 0515 	movt	r5, #21
  143b9c:	920f      	str	r2, [sp, #60]	; 0x3c
  143b9e:	930d      	str	r3, [sp, #52]	; 0x34
  143ba0:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
  143ba4:	930e      	str	r3, [sp, #56]	; 0x38
  143ba6:	f44f 6278 	mov.w	r2, #3968	; 0xf80
  143baa:	2300      	movs	r3, #0
  143bac:	468c      	mov	r12, r1
    return sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, SRAM_PUB), OP_PART_HASH, data_in, block_t_convert((uint8_t*)CE2_SRAM_PUB_HASH_MULT_PART_UPDATE_IV_ADDR_OFFSET, hash_get_digest_size(hash_alg), SRAM_PUB));
  143bae:	ae1d      	add	r6, sp, #116	; 0x74
  143bb0:	9213      	str	r2, [sp, #76]	; 0x4c
  143bb2:	aa16      	add	r2, sp, #88	; 0x58
  143bb4:	f855 1020 	ldr.w	r1, [r5, r0, lsl #2]
  143bb8:	4686      	mov	r14, r0
  143bba:	9315      	str	r3, [sp, #84]	; 0x54
  143bbc:	af08      	add	r7, sp, #32
  143bbe:	9114      	str	r1, [sp, #80]	; 0x50
  143bc0:	ad10      	add	r5, sp, #64	; 0x40
  143bc2:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  143bc6:	941e      	str	r4, [sp, #120]	; 0x78
  143bc8:	ac05      	add	r4, sp, #20
  143bca:	e887 0007 	stmia.w	r7, {r0, r1, r2}
  143bce:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  143bd2:	e9cd 3310 	strd	r3, r3, [r13, #64]	; 0x40
  143bd6:	ae0d      	add	r6, sp, #52	; 0x34
  143bd8:	9312      	str	r3, [sp, #72]	; 0x48
  143bda:	ab01      	add	r3, sp, #4
  143bdc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  143be0:	2403      	movs	r4, #3
  143be2:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  143be6:	9404      	str	r4, [sp, #16]
  143be8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143bec:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
  143bee:	4661      	mov	r1, r12
  143bf0:	e896 000c 	ldmia.w	r6, {r2, r3}
  143bf4:	4670      	mov	r0, r14
  143bf6:	9400      	str	r4, [sp, #0]
  143bf8:	f7ff fdb2 	bl	143760 <sx_hash_internal>
}
  143bfc:	b017      	add	sp, #92	; 0x5c
  143bfe:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  143c02:	b002      	add	sp, #8
  143c04:	4770      	bx	r14
  143c06:	930d      	str	r3, [sp, #52]	; 0x34
  143c08:	f2c0 0515 	movt	r5, #21
  143c0c:	e9cd 330e 	strd	r3, r3, [r13, #56]	; 0x38
  143c10:	e7c9      	b.n	143ba6 <hash_update_blk+0x56>
  143c12:	bf00      	nop

00143c14 <hash_finish_blk>:
    uint32_t ce_id,
    block_t state,
    block_t data_in,
    block_t data_out,
    uint32_t total_len)
{
  143c14:	b082      	sub	sp, #8
  143c16:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143c1a:	b09f      	sub	sp, #124	; 0x7c
  143c1c:	ac28      	add	r4, sp, #160	; 0xa0
  143c1e:	f8dd a0ac 	ldr.w	r10, [r13, #172]	; 0xac
  143c22:	e884 000c 	stmia.w	r4, {r2, r3}
  143c26:	e9dd 632c 	ldrd	r6, r3, [r13, #176]	; 0xb0
    struct mem_node* mem_n;
    addr_t addr_base;

    block_t padding_blk;

    if (NULL == data_in.addr) {
  143c2a:	f1ba 0f00 	cmp.w	r10, #0
  143c2e:	f000 808f 	beq.w	143d50 <hash_finish_blk+0x13c>
  143c32:	2806      	cmp	r0, #6
  143c34:	f240 8083 	bls.w	143d3e <hash_finish_blk+0x12a>
  143c38:	f44f 6478 	mov.w	r4, #3968	; 0xf80
  143c3c:	2200      	movs	r2, #0
  143c3e:	4617      	mov	r7, r2
  143c40:	9412      	str	r4, [sp, #72]	; 0x48
  143c42:	4634      	mov	r4, r6
  143c44:	e9cd 2213 	strd	r2, r2, [r13, #76]	; 0x4c
  143c48:	4605      	mov	r5, r0
        remain_size = data_in.len;
    }

    addr_base = (addr_t)(data_in.addr);

    mem_n = ce_malloc(SHA512_BLOCKSIZE * 2);
  143c4a:	f44f 7080 	mov.w	r0, #256	; 0x100
  143c4e:	930d      	str	r3, [sp, #52]	; 0x34
  143c50:	4688      	mov	r8, r1
  143c52:	f7ff fc47 	bl	1434e4 <ce_malloc>
    if ((0 == remain_size) && (0 != data_in.len)) {
  143c56:	2c00      	cmp	r4, #0
  143c58:	bf08      	it	eq
  143c5a:	4634      	moveq	r4, r6

    if (mem_n != NULL) {
  143c5c:	4683      	mov	r11, r0
        padding = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  143c5e:	2015      	movs	r0, #21
    if (mem_n != NULL) {
  143c60:	f1bb 0f00 	cmp.w	r11, #0
  143c64:	d075      	beq.n	143d52 <hash_finish_blk+0x13e>
    }

    if ((SRAM_PUB == data_in.addr_type) || (SRAM_SEC == data_in.addr_type)) {
  143c66:	9b0d      	ldr	r3, [sp, #52]	; 0x34
        padding = mem_n->ptr;
  143c68:	f8db 9008 	ldr.w	r9, [r11, #8]
    if ((SRAM_PUB == data_in.addr_type) || (SRAM_SEC == data_in.addr_type)) {
  143c6c:	2b01      	cmp	r3, #1
  143c6e:	f240 80d9 	bls.w	143e24 <hash_finish_blk+0x210>
        addr_base = _vaddr(_paddr((void*)addr_base) + sram_addr(data_in.addr_type, ce_id));
    }

    memcpy((void*)padding, (void*)(addr_base + (data_in.len - remain_size)), remain_size);
  143c72:	4622      	mov	r2, r4
  143c74:	1b36      	subs	r6, r6, r4
  143c76:	4648      	mov	r0, r9
  143c78:	eb06 010a 	add.w	r1, r6, r10
  143c7c:	f00f e978 	blx	152f70 <memcpy>
    data_in.len -= remain_size;

    if (data_in.len > 0) {
  143c80:	2e00      	cmp	r6, #0
  143c82:	f040 80a2 	bne.w	143dca <hash_finish_blk+0x1b6>
  143c86:	ab08      	add	r3, sp, #32
  143c88:	f10d 0a04 	add.w	r10, r13, #4
  143c8c:	930d      	str	r3, [sp, #52]	; 0x34
  143c8e:	ab2e      	add	r3, sp, #184	; 0xb8
  143c90:	9310      	str	r3, [sp, #64]	; 0x40
  143c92:	ab05      	add	r3, sp, #20
  143c94:	930f      	str	r3, [sp, #60]	; 0x3c
  143c96:	ab12      	add	r3, sp, #72	; 0x48
  143c98:	930e      	str	r3, [sp, #56]	; 0x38
  143c9a:	9a31      	ldr	r2, [sp, #196]	; 0xc4
  143c9c:	2303      	movs	r3, #3
  143c9e:	9317      	str	r3, [sp, #92]	; 0x5c
  143ca0:	fa02 f603 	lsl.w	r6, r2, r3
        sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, 0), OP_PART_HASH, data_in, data_out);
    }

    padding_blk = block_t_convert(padding, SHA512_BLOCKSIZE * 2, EXT_MEM);

    if (ALG_MD5 == hash_alg) {
  143ca4:	2d00      	cmp	r5, #0
  143ca6:	d169      	bne.n	143d7c <hash_finish_blk+0x168>
    padding.addr[remain_size] = 0x80;
  143ca8:	2780      	movs	r7, #128	; 0x80
    available = 64 - remain_size - 1;
  143caa:	f1c4 023f 	rsb	r2, r4, #63	; 0x3f
    if (available < start) {
  143cae:	429a      	cmp	r2, r3
        available += 64;
  143cb0:	bf96      	itet	ls
  143cb2:	237c      	movls	r3, #124	; 0x7c
    if (available < start) {
  143cb4:	233c      	movhi	r3, #60	; 0x3c
        available += 64;
  143cb6:	f1c4 027f 	rsbls	r2, r4, #127	; 0x7f
    padding.addr[remain_size] = 0x80;
  143cba:	f809 7004 	strb.w	r7, [r9, r4]
    memset((void*)(padding.addr + (remain_size + 1)), 0, available - start);
  143cbe:	f104 0001 	add.w	r0, r4, #1
  143cc2:	f1a2 0204 	sub.w	r2, r2, #4
  143cc6:	f04f 0100 	mov.w	r1, #0
  143cca:	4448      	add	r0, r9
  143ccc:	9311      	str	r3, [sp, #68]	; 0x44
    pad_size = 64;
  143cce:	bf88      	it	hi
  143cd0:	2740      	movhi	r7, #64	; 0x40
    memset((void*)(padding.addr + (remain_size + 1)), 0, available - start);
  143cd2:	f00f e9d4 	blx	15307c <memset>
  143cd6:	9b11      	ldr	r3, [sp, #68]	; 0x44
  143cd8:	2200      	movs	r2, #0
  143cda:	444b      	add	r3, r9
        padding.addr[pad_size - start + i] = (len_in_bits >> (i * 8)) & 0xFF;
  143cdc:	fa26 f102 	lsr.w	r1, r6, r2
  143ce0:	3208      	adds	r2, #8
  143ce2:	f803 1b01 	strb.w	r1, [r3], #1
    for (i = 0; i < start; i++) {
  143ce6:	2a20      	cmp	r2, #32
  143ce8:	d1f8      	bne.n	143cdc <hash_finish_blk+0xc8>
    }
    else {
        padding_blk.len = sha_padding(hash_alg, remain_size, total_len, padding_blk);
    }

    sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, SRAM_PUB), OP_FINAL_HASH, padding_blk, data_out);
  143cea:	9a10      	ldr	r2, [sp, #64]	; 0x40
  143cec:	ab15      	add	r3, sp, #84	; 0x54
  143cee:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  143cf0:	2400      	movs	r4, #0
  143cf2:	f8cd 9054 	str.w	r9, [r13, #84]	; 0x54
  143cf6:	ca07      	ldmia	r2, {r0, r1, r2}
  143cf8:	9716      	str	r7, [sp, #88]	; 0x58
  143cfa:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  143cfe:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  143d02:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  143d04:	2604      	movs	r6, #4
  143d06:	941b      	str	r4, [sp, #108]	; 0x6c
  143d08:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143d0c:	e9cd 441c 	strd	r4, r4, [r13, #112]	; 0x70
  143d10:	ab1e      	add	r3, sp, #120	; 0x78
  143d12:	e913 0007 	ldmdb	r3, {r0, r1, r2}
  143d16:	9b14      	ldr	r3, [sp, #80]	; 0x50
  143d18:	9604      	str	r6, [sp, #16]
  143d1a:	e88a 0007 	stmia.w	r10, {r0, r1, r2}
  143d1e:	9300      	str	r3, [sp, #0]
  143d20:	4641      	mov	r1, r8
  143d22:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  143d24:	4628      	mov	r0, r5
  143d26:	cb0c      	ldmia	r3, {r2, r3}
  143d28:	f7ff fd1a 	bl	143760 <sx_hash_internal>

    ce_free(mem_n);
  143d2c:	4658      	mov	r0, r11
  143d2e:	f7ff fc1d 	bl	14356c <ce_free>

    return CRYPTOLIB_SUCCESS;
  143d32:	4620      	mov	r0, r4
}
  143d34:	b01f      	add	sp, #124	; 0x7c
  143d36:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143d3a:	b002      	add	sp, #8
  143d3c:	4770      	bx	r14
    if (data_out.len < digest_size) {
  143d3e:	9d2f      	ldr	r5, [sp, #188]	; 0xbc
  143d40:	f245 6278 	movw	r2, #22136	; 0x5678
  143d44:	f2c0 0215 	movt	r2, #21
  143d48:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
  143d4c:	42a5      	cmp	r5, r4
  143d4e:	d205      	bcs.n	143d5c <hash_finish_blk+0x148>
        return CRYPTOLIB_INVALID_PARAM;
  143d50:	2009      	movs	r0, #9
}
  143d52:	b01f      	add	sp, #124	; 0x7c
  143d54:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143d58:	b002      	add	sp, #8
  143d5a:	4770      	bx	r14
  143d5c:	f245 62a8 	movw	r2, #22184	; 0x56a8
  143d60:	f44f 6e78 	mov.w	r14, #3968	; 0xf80
  143d64:	2500      	movs	r5, #0
  143d66:	f2c0 0215 	movt	r2, #21
  143d6a:	9413      	str	r4, [sp, #76]	; 0x4c
  143d6c:	f8cd e048 	str.w	r14, [r13, #72]	; 0x48
  143d70:	f852 7020 	ldr.w	r7, [r2, r0, lsl #2]
  143d74:	9514      	str	r5, [sp, #80]	; 0x50
  143d76:	1e7c      	subs	r4, r7, #1
  143d78:	4034      	ands	r4, r6
  143d7a:	e765      	b.n	143c48 <hash_finish_blk+0x34>
    uint32_t length_field_size = (hash_alg >= ALG_SHA384) ? 16 : 8;
  143d7c:	2d04      	cmp	r5, #4
  143d7e:	bf34      	ite	cc
  143d80:	2308      	movcc	r3, #8
  143d82:	2310      	movcs	r3, #16
    if (padding.len < pad_size) {
  143d84:	f5b7 7f80 	cmp.w	r7, #256	; 0x100
        return 0;
  143d88:	bf88      	it	hi
  143d8a:	2700      	movhi	r7, #0
    if (padding.len < pad_size) {
  143d8c:	d8ad      	bhi.n	143cea <hash_finish_blk+0xd6>
    if (block_size - remain_size < (length_field_size + 1)) {
  143d8e:	1b3a      	subs	r2, r7, r4
  143d90:	3301      	adds	r3, #1
  143d92:	429a      	cmp	r2, r3
    padding.addr[remain_size] = 0x80;
  143d94:	f04f 0380 	mov.w	r3, #128	; 0x80
        pad_size += block_size;
  143d98:	bf38      	it	cc
  143d9a:	007f      	lslcc	r7, r7, #1
    memset((void*)(padding.addr + (remain_size + 1)), 0, pad_size - start - (remain_size + 1));
  143d9c:	1b3a      	subs	r2, r7, r4
    padding.addr[remain_size] = 0x80;
  143d9e:	f809 3004 	strb.w	r3, [r9, r4]
    memset((void*)(padding.addr + (remain_size + 1)), 0, pad_size - start - (remain_size + 1));
  143da2:	1c60      	adds	r0, r4, #1
  143da4:	2100      	movs	r1, #0
  143da6:	3a05      	subs	r2, #5
  143da8:	4448      	add	r0, r9
  143daa:	f00f e968 	blx	15307c <memset>
        padding.addr[pad_size - i] = (len_in_bits >> ((i - 1) * 8)) & 0xFF;
  143dae:	eb09 0307 	add.w	r3, r9, r7
  143db2:	0e30      	lsrs	r0, r6, #24
  143db4:	0c31      	lsrs	r1, r6, #16
  143db6:	f803 6c01 	strb.w	r6, [r3, #-1]
  143dba:	0a32      	lsrs	r2, r6, #8
  143dbc:	f803 0c04 	strb.w	r0, [r3, #-4]
  143dc0:	f803 1c03 	strb.w	r1, [r3, #-3]
  143dc4:	f803 2c02 	strb.w	r2, [r3, #-2]
  143dc8:	e78f      	b.n	143cea <hash_finish_blk+0xd6>
        sx_hash_internal(hash_alg, ce_id, iv, block_t_convert(NULL, 0, 0), OP_PART_HASH, data_in, data_out);
  143dca:	ab2e      	add	r3, sp, #184	; 0xb8
  143dcc:	962c      	str	r6, [sp, #176]	; 0xb0
  143dce:	aa08      	add	r2, sp, #32
  143dd0:	9310      	str	r3, [sp, #64]	; 0x40
  143dd2:	f10d 0cac 	add.w	r12, r13, #172	; 0xac
  143dd6:	920d      	str	r2, [sp, #52]	; 0x34
  143dd8:	f10d 0e60 	add.w	r14, r13, #96	; 0x60
  143ddc:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  143de0:	9e0d      	ldr	r6, [sp, #52]	; 0x34
  143de2:	ab05      	add	r3, sp, #20
  143de4:	f10d 0a04 	add.w	r10, r13, #4
  143de8:	930f      	str	r3, [sp, #60]	; 0x3c
  143dea:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  143dee:	2600      	movs	r6, #0
  143df0:	aa12      	add	r2, sp, #72	; 0x48
  143df2:	920e      	str	r2, [sp, #56]	; 0x38
  143df4:	e89c 0007 	ldmia.w	r12, {r0, r1, r2}
  143df8:	9618      	str	r6, [sp, #96]	; 0x60
  143dfa:	f04f 0c03 	mov.w	r12, #3
  143dfe:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  143e02:	9619      	str	r6, [sp, #100]	; 0x64
  143e04:	961a      	str	r6, [sp, #104]	; 0x68
  143e06:	e89e 0007 	ldmia.w	r14, {r0, r1, r2}
  143e0a:	9e14      	ldr	r6, [sp, #80]	; 0x50
  143e0c:	f8cd c010 	str.w	r12, [r13, #16]
  143e10:	e88a 0007 	stmia.w	r10, {r0, r1, r2}
  143e14:	9a0e      	ldr	r2, [sp, #56]	; 0x38
  143e16:	4641      	mov	r1, r8
  143e18:	4628      	mov	r0, r5
  143e1a:	ca0c      	ldmia	r2, {r2, r3}
  143e1c:	9600      	str	r6, [sp, #0]
  143e1e:	f7ff fc9f 	bl	143760 <sx_hash_internal>
  143e22:	e73a      	b.n	143c9a <hash_finish_blk+0x86>
        addr_base = _vaddr(_paddr((void*)addr_base) + sram_addr(data_in.addr_type, ce_id));
  143e24:	4618      	mov	r0, r3
  143e26:	4641      	mov	r1, r8
  143e28:	f7ff fb26 	bl	143478 <sram_addr>
  143e2c:	4482      	add	r10, r0
  143e2e:	e720      	b.n	143c72 <hash_finish_blk+0x5e>

00143e30 <aes_blk>:
                 block_t xtskey,
                 block_t iv,
                 block_t ctx_ptr,
                 block_t data_in,
                 block_t data_out)
{
  143e30:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  143e34:	b083      	sub	sp, #12
  143e36:	f89d 9034 	ldrb.w	r9, [r13, #52]	; 0x34
  143e3a:	f89d b038 	ldrb.w	r11, [r13, #56]	; 0x38
    uint32_t value;
    uint32_t key_size_conf;

    /* Step 0: input validation */
    uint32_t ret = sx_aes_validate_input(mode, aes_fct, ctx, key, xtskey, iv, ctx_ptr, data_in, data_out, header_len);
  143e3e:	f8dd c074 	ldr.w	r12, [r13, #116]	; 0x74
    if (KEY_INT == data_in.addr_type) {
  143e42:	f1bc 0f02 	cmp.w	r12, #2
  143e46:	f000 812c 	beq.w	1440a2 <aes_blk+0x272>
    uint32_t ret = sx_aes_validate_input(mode, aes_fct, ctx, key, xtskey, iv, ctx_ptr, data_in, data_out, header_len);
  143e4a:	f8dd e080 	ldr.w	r14, [r13, #128]	; 0x80
    if (KEY_INT == data_out.addr_type) {
  143e4e:	f1be 0f02 	cmp.w	r14, #2
        return CRYPTOLIB_INVALID_PARAM_OUTPUT;
  143e52:	bf08      	it	eq
  143e54:	200e      	moveq	r0, #14
    if (KEY_INT == data_out.addr_type) {
  143e56:	f000 8121 	beq.w	14409c <aes_blk+0x26c>
    if (dir != MODE_ENC && dir != MODE_DEC) {
  143e5a:	2a01      	cmp	r2, #1
        return CRYPTOLIB_INVALID_PARAM;
  143e5c:	bf88      	it	hi
  143e5e:	2009      	movhi	r0, #9
    if (dir != MODE_ENC && dir != MODE_DEC) {
  143e60:	f200 811c 	bhi.w	14409c <aes_blk+0x26c>
    uint32_t ret = sx_aes_validate_input(mode, aes_fct, ctx, key, xtskey, iv, ctx_ptr, data_in, data_out, header_len);
  143e64:	9f13      	ldr	r7, [sp, #76]	; 0x4c
  143e66:	4698      	mov	r8, r3
  143e68:	9b10      	ldr	r3, [sp, #64]	; 0x40
  143e6a:	9d16      	ldr	r5, [sp, #88]	; 0x58
  143e6c:	9e19      	ldr	r6, [sp, #100]	; 0x64
    bool valid = len == 16 || (len == 24) || len == 32;
  143e6e:	f023 0408 	bic.w	r4, r3, #8
  143e72:	2b20      	cmp	r3, #32
  143e74:	bf18      	it	ne
  143e76:	2c10      	cmpne	r4, #16
  143e78:	bf0c      	ite	eq
  143e7a:	2401      	moveq	r4, #1
  143e7c:	2400      	movne	r4, #0
    if (fct == FCT_XTS) {
  143e7e:	2807      	cmp	r0, #7
  143e80:	f000 8134 	beq.w	1440ec <aes_blk+0x2bc>
    if (!IsKeyLenValid(fct, key.len, xtskey.len)) {
  143e84:	2f00      	cmp	r7, #0
  143e86:	bf18      	it	ne
  143e88:	2400      	movne	r4, #0
  143e8a:	2c00      	cmp	r4, #0
  143e8c:	f000 8136 	beq.w	1440fc <aes_blk+0x2cc>
    switch (fct) {
  143e90:	2808      	cmp	r0, #8
  143e92:	d80e      	bhi.n	143eb2 <aes_blk+0x82>
  143e94:	e8df f010 	tbh	[r15, r0, lsl #1]
  143e98:	000d011a 	.word	0x000d011a
  143e9c:	000d000d 	.word	0x000d000d
  143ea0:	0113000d 	.word	0x0113000d
  143ea4:	000d0109 	.word	0x000d0109
  143ea8:	0009      	.short	0x0009
            if (ctx == CTX_BEGIN || ctx == CTX_WHOLE) {
  143eaa:	f1b8 0f01 	cmp.w	r8, #1
  143eae:	f240 8109 	bls.w	1440c4 <aes_blk+0x294>
    return len == AES_IV_SIZE;
  143eb2:	f1a5 0510 	sub.w	r5, r5, #16
  143eb6:	fab5 f585 	clz	r5, r5
  143eba:	096d      	lsrs	r5, r5, #5
    if (!IsIVContextLenValid(fct, ctx, iv.len)) {
  143ebc:	2d00      	cmp	r5, #0
  143ebe:	f000 810a 	beq.w	1440d6 <aes_blk+0x2a6>
    if (fct == FCT_ECB || ctx == CTX_WHOLE) {
  143ec2:	f1b8 0f00 	cmp.w	r8, #0
  143ec6:	bf18      	it	ne
  143ec8:	2800      	cmpne	r0, #0
  143eca:	f000 8100 	beq.w	1440ce <aes_blk+0x29e>
    else if (fct == FCT_GCM || fct == FCT_CCM) {
  143ece:	1f43      	subs	r3, r0, #5
  143ed0:	2b01      	cmp	r3, #1
        return len == AES_CTX_xCM_SIZE;
  143ed2:	bf94      	ite	ls
  143ed4:	3e20      	subls	r6, #32
    return len == AES_CTX_SIZE;
  143ed6:	3e10      	subhi	r6, #16
  143ed8:	fab6 f686 	clz	r6, r6
  143edc:	0976      	lsrs	r6, r6, #5
    if (!IsNextContextLenValid(fct, ctx, ctx_ptr.len)) {
  143ede:	2e00      	cmp	r6, #0
  143ee0:	f000 8122 	beq.w	144128 <aes_blk+0x2f8>
    if (ctx == CTX_BEGIN || ctx == CTX_MIDDLE) {
  143ee4:	f028 0302 	bic.w	r3, r8, #2
  143ee8:	461c      	mov	r4, r3
        if (fct != FCT_GCM) {
  143eea:	2806      	cmp	r0, #6
    if (ctx == CTX_BEGIN || ctx == CTX_MIDDLE) {
  143eec:	9301      	str	r3, [sp, #4]
        if (fct != FCT_GCM) {
  143eee:	f1a4 0401 	sub.w	r4, r4, #1
    uint32_t ret = sx_aes_validate_input(mode, aes_fct, ctx, key, xtskey, iv, ctx_ptr, data_in, data_out, header_len);
  143ef2:	9b1c      	ldr	r3, [sp, #112]	; 0x70
        if (fct != FCT_GCM) {
  143ef4:	fab4 f484 	clz	r4, r4
  143ef8:	ea4f 1454 	mov.w	r4, r4, lsr #5
  143efc:	bf08      	it	eq
  143efe:	2400      	moveq	r4, #0
  143f00:	2c00      	cmp	r4, #0
  143f02:	f040 8113 	bne.w	14412c <aes_blk+0x2fc>
    return len > 0;
  143f06:	3300      	adds	r3, #0
  143f08:	bf18      	it	ne
  143f0a:	2301      	movne	r3, #1
    if (!IsPayloadLenValid(fct, ctx, data_in.len, header_len)) {
  143f0c:	2b00      	cmp	r3, #0
  143f0e:	f000 80c8 	beq.w	1440a2 <aes_blk+0x272>
    }
    else {
        value = reg_value((addr_t)key.addr, 0, CE_CIPHER_KEY_ADDR_SHIFT, CE_CIPHER_KEY_ADDR_MASK);
    }

    if (FCT_XTS == aes_fct) {
  143f12:	2807      	cmp	r0, #7
  143f14:	f8bd 303c 	ldrh.w	r3, [r13, #60]	; 0x3c
    writel(value, _ioaddr(REG_CIPHER_HEADER_LEN_CE_(vce_id)));
  143f18:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  143f1a:	ea4f 3401 	mov.w	r4, r1, lsl #12
  143f1e:	4616      	mov	r6, r2
  143f20:	f104 4474 	add.w	r4, r4, #4093640704	; 0xf4000000
  143f24:	f8dd a060 	ldr.w	r10, [r13, #96]	; 0x60
  143f28:	4607      	mov	r7, r0
  143f2a:	6125      	str	r5, [r4, #16]
  143f2c:	bf08      	it	eq
  143f2e:	9d12      	ldreq	r5, [sp, #72]	; 0x48
  143f30:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
  143f32:	bf08      	it	eq
  143f34:	ea43 4305 	orreq.w	r3, r3, r5, lsl #16
  143f38:	460d      	mov	r5, r1
    LTRACEF("value = %d reg= 0x%x\n", value, (REG_CIPHER_KEY_ADDR_CE_(vce_id)));
    writel(value, _ioaddr(REG_CIPHER_KEY_ADDR_CE_(vce_id)));

    LTRACEF("data_in.addr = %p addr_type= 0x%x\n", data_in.addr, data_in.addr_type);

    if (EXT_MEM == data_in.addr_type) {
  143f3a:	f1bc 0f03 	cmp.w	r12, #3
    writel(value, _ioaddr(REG_CIPHER_KEY_ADDR_CE_(vce_id)));
  143f3e:	6163      	str	r3, [r4, #20]
    if (EXT_MEM == data_in.addr_type) {
  143f40:	f000 80e8 	beq.w	144114 <aes_blk+0x2e4>
    else {
        value = reg_value((addr_t)data_in.addr, 0, CE_CIPHER_SRC_ADDR_SHIFT, CE_CIPHER_SRC_ADDR_MASK0);
    }

    LTRACEF("value = %x reg= 0x%x\n", value, (REG_CIPHER_SRC_ADDR_CE_(vce_id)));
    writel(value, _ioaddr(REG_CIPHER_SRC_ADDR_CE_(vce_id)));
  143f44:	61a2      	str	r2, [r4, #24]
  143f46:	f1bc 0f04 	cmp.w	r12, #4
  143f4a:	bf94      	ite	ls
  143f4c:	f245 63e0 	movwls	r3, #22240	; 0x56e0
  143f50:	2300      	movhi	r3, #0
  143f52:	9a1e      	ldr	r2, [sp, #120]	; 0x78
  143f54:	bf9f      	itttt	ls
  143f56:	f2c0 0315 	movtls	r3, #21
  143f5a:	f853 302c 	ldrls.w	r3, [r3, r12, lsl #2]
  143f5e:	021b      	lslls	r3, r3, #8
  143f60:	f403 63e0 	andls.w	r3, r3, #1792	; 0x700

    value = reg_value(switch_addr_type(data_in.addr_type), 0, CE_CIPHER_SRC_TYPE_SHIFT, CE_CIPHER_SRC_TYPE_MASK);
    LTRACEF("value = %x reg= 0x%x\n", value, REG_CIPHER_SRC_ADDR_H_CE_(vce_id));
    writel(value, _ioaddr(REG_CIPHER_SRC_ADDR_H_CE_(vce_id)));

    if (EXT_MEM == data_out.addr_type) {
  143f64:	f1be 0f03 	cmp.w	r14, #3
    writel(value, _ioaddr(REG_CIPHER_SRC_ADDR_H_CE_(vce_id)));
  143f68:	61e3      	str	r3, [r4, #28]
    if (EXT_MEM == data_out.addr_type) {
  143f6a:	f000 80cb 	beq.w	144104 <aes_blk+0x2d4>
    else {
        value = reg_value((addr_t)data_out.addr, 0, CE_CIPHER_DST_ADDR_SHIFT, CE_CIPHER_DST_ADDR_MASK);
    }

    LTRACEF("value = %x reg= 0x%x\n", value, REG_CIPHER_DST_ADDR_CE_(vce_id));
    writel(value, _ioaddr(REG_CIPHER_DST_ADDR_CE_(vce_id)));
  143f6e:	6222      	str	r2, [r4, #32]
  143f70:	f1be 0f04 	cmp.w	r14, #4
  143f74:	bf96      	itet	ls
  143f76:	f245 63e0 	movwls	r3, #22240	; 0x56e0
  143f7a:	2300      	movhi	r3, #0
  143f7c:	f2c0 0315 	movtls	r3, #21
  143f80:	9a1c      	ldr	r2, [sp, #112]	; 0x70
  143f82:	ea4f 79c9 	mov.w	r9, r9, lsl #31
  143f86:	bf9e      	ittt	ls
  143f88:	f853 302e 	ldrls.w	r3, [r3, r14, lsl #2]
  143f8c:	021b      	lslls	r3, r3, #8
  143f8e:	f403 63e0 	andls.w	r3, r3, #1792	; 0x700

    value = reg_value(switch_addr_type(data_out.addr_type), 0, CE_CIPHER_DST_TYPE_SHIFT, CE_CIPHER_DST_TYPE_MASK);
    LTRACEF("value = %x reg= 0x%x\n", value, REG_CIPHER_DST_ADDR_H_CE_(vce_id));
    writel(value, _ioaddr(REG_CIPHER_DST_ADDR_H_CE_(vce_id)));
  143f92:	6263      	str	r3, [r4, #36]	; 0x24
  143f94:	ea4f 430a 	mov.w	r3, r10, lsl #16
    }
    else {
        value = reg_value((addr_t)ctx_ptr.addr, 0, CE_CIPHER_CONTEXT_ADDR_SHIFT, CE_CIPHER_CONTEXT_ADDR_MASK);
    }

    if (FCT_ECB != aes_fct) {
  143f98:	2f00      	cmp	r7, #0
  143f9a:	f000 809e 	beq.w	1440da <aes_blk+0x2aa>
    writel(value, _ioaddr(REG_CIPHER_PAYLOAD_LEN_CE_(vce_id)));

    /* config control register */
    value = reg_value(header_save, 0, CE_CIPHER_CTRL_HEADER_SAVE_SHIFT, CE_CIPHER_CTRL_HEADER_SAVE_MASK);

    if (FCT_XTS == aes_fct) {
  143f9e:	2f07      	cmp	r7, #7
  143fa0:	f8bd a054 	ldrh.w	r10, [r13, #84]	; 0x54
  143fa4:	ea8a 0303 	eor.w	r3, r10, r3
    writel(value, _ioaddr(REG_CIPHER_IV_CONTEXT_ADDR_CE_(vce_id)));
  143fa8:	62a3      	str	r3, [r4, #40]	; 0x28
  143faa:	bf08      	it	eq
  143fac:	9b14      	ldreq	r3, [sp, #80]	; 0x50
    writel(value, _ioaddr(REG_CIPHER_PAYLOAD_LEN_CE_(vce_id)));
  143fae:	62e2      	str	r2, [r4, #44]	; 0x2c
  143fb0:	bf02      	ittt	eq
  143fb2:	ea89 7303 	eoreq.w	r3, r9, r3, lsl #28
  143fb6:	f003 5340 	andeq.w	r3, r3, #805306368	; 0x30000000
  143fba:	ea89 0903 	eoreq.w	r9, r9, r3
  143fbe:	9a11      	ldr	r2, [sp, #68]	; 0x44
        value = reg_value(xtskey.addr_type, value, CE_CIPHER_CTRL_KEY2TYPE_SHIFT, CE_CIPHER_CTRL_KEY2TYPE_MASK);
    }

    value = reg_value(key.addr_type, value, CE_CIPHER_CTRL_KEYTYPE_SHIFT, CE_CIPHER_CTRL_KEYTYPE_MASK);
    value = reg_value(1 << aes_fct, value, CE_CIPHER_CTRL_AESMODE_SHIFT, CE_CIPHER_CTRL_AESMODE_MASK);
  143fc0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  143fc4:	2300      	movs	r3, #0

    if (CTX_BEGIN == ctx || CTX_MIDDLE == ctx) {
        value = reg_value(1, value, CE_CIPHER_CTRL_SAVE_SHIFT, CE_CIPHER_CTRL_SAVE_MASK);
    }

    if (CTX_MIDDLE == ctx || CTX_END == ctx) {
  143fc6:	f1a8 0802 	sub.w	r8, r8, #2
  143fca:	fa00 f707 	lsl.w	r7, r0, r7
  143fce:	ea89 6242 	eor.w	r2, r9, r2, lsl #25
  143fd2:	f002 62c0 	and.w	r2, r2, #100663296	; 0x6000000
  143fd6:	ea82 0909 	eor.w	r9, r2, r9
    if (CTX_BEGIN == ctx || CTX_MIDDLE == ctx) {
  143fda:	9a01      	ldr	r2, [sp, #4]
  143fdc:	f2c0 13ff 	movt	r3, #511	; 0x1ff
  143fe0:	403b      	ands	r3, r7
  143fe2:	ea83 0309 	eor.w	r3, r3, r9
  143fe6:	2a01      	cmp	r2, #1
        value = reg_value(1, value, CE_CIPHER_CTRL_LOAD_SHIFT, CE_CIPHER_CTRL_LOAD_MASK);
    }

    value = reg_value((pre_cal_key || MODE_DEC == mode) ? 1 : 0, value, CE_CIPHER_CTRL_DECKEYCAL_SHIFT, CE_CIPHER_CTRL_DECKEYCAL_MASK);
  143fe8:	f006 0901 	and.w	r9, r6, #1
  143fec:	bf08      	it	eq
  143fee:	f483 5300 	eoreq.w	r3, r3, #8192	; 0x2000

    switch (key.len) {
  143ff2:	9a10      	ldr	r2, [sp, #64]	; 0x40
    if (CTX_MIDDLE == ctx || CTX_END == ctx) {
  143ff4:	f1b8 0f01 	cmp.w	r8, #1
    value = reg_value((pre_cal_key || MODE_DEC == mode) ? 1 : 0, value, CE_CIPHER_CTRL_DECKEYCAL_SHIFT, CE_CIPHER_CTRL_DECKEYCAL_MASK);
  143ff8:	ea4b 0909 	orr.w	r9, r11, r9
  143ffc:	bf98      	it	ls
  143ffe:	f483 5380 	eorls.w	r3, r3, #4096	; 0x1000
  144002:	ea83 29c9 	eor.w	r9, r3, r9, lsl #11
    switch (key.len) {
  144006:	2a18      	cmp	r2, #24
  144008:	f409 6900 	and.w	r9, r9, #2048	; 0x800
  14400c:	ea89 0903 	eor.w	r9, r9, r3
  144010:	d066      	beq.n	1440e0 <aes_blk+0x2b0>
  144012:	2a20      	cmp	r2, #32
  144014:	d067      	beq.n	1440e6 <aes_blk+0x2b6>
  144016:	2a10      	cmp	r2, #16
        case 32:
            key_size_conf = SX_KEY_TYPE_256;
            break;

        default: // Should not arrive, checked in sx_aes_validate_input
            return CRYPTOLIB_UNSUPPORTED_ERR;
  144018:	bf18      	it	ne
  14401a:	2001      	movne	r0, #1
    switch (key.len) {
  14401c:	d13e      	bne.n	14409c <aes_blk+0x26c>
  14401e:	464b      	mov	r3, r9
    value = reg_value(mode, value, CE_CIPHER_CTRL_CIPHERMODE_SHIFT, CE_CIPHER_CTRL_CIPHERMODE_MASK);
    value = reg_value(1, value, CE_CIPHER_CTRL_GO_SHIFT, CE_CIPHER_CTRL_GO_MASK);
    LTRACEF("value = %x reg= 0x%x\n", value, REG_CIPHER_CTRL_CE_(vce_id));

    //clean cache to assure memory is fresh
    clean_cache_block(&key, vce_id);
  144020:	4629      	mov	r1, r5
  144022:	f403 63c0 	and.w	r3, r3, #1536	; 0x600
  144026:	a80f      	add	r0, sp, #60	; 0x3c
  144028:	ea83 0909 	eor.w	r9, r3, r9
  14402c:	f7ff fb5e 	bl	1436ec <clean_cache_block>
    clean_cache_block(&xtskey, vce_id);
  144030:	4629      	mov	r1, r5
  144032:	a812      	add	r0, sp, #72	; 0x48
  144034:	f7ff fb5a 	bl	1436ec <clean_cache_block>
    clean_cache_block(&iv, vce_id);
  144038:	4629      	mov	r1, r5
  14403a:	a815      	add	r0, sp, #84	; 0x54
  14403c:	f7ff fb56 	bl	1436ec <clean_cache_block>
    //some crypto type has head msg in data_in buff
    data_in.len = data_in.len + header_len;
  144040:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  144042:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    clean_cache_block(&data_in, vce_id);
  144044:	4629      	mov	r1, r5
  144046:	ea89 2606 	eor.w	r6, r9, r6, lsl #8
    data_in.len = data_in.len + header_len;
  14404a:	4413      	add	r3, r2
    clean_cache_block(&data_in, vce_id);
  14404c:	a81b      	add	r0, sp, #108	; 0x6c
    data_in.len = data_in.len + header_len;
  14404e:	931c      	str	r3, [sp, #112]	; 0x70
  144050:	f406 7680 	and.w	r6, r6, #256	; 0x100
    clean_cache_block(&data_in, vce_id);
  144054:	f7ff fb4a 	bl	1436ec <clean_cache_block>

    invalidate_cache_block(&data_out, vce_id);
  144058:	4629      	mov	r1, r5
  14405a:	a81e      	add	r0, sp, #120	; 0x78
  14405c:	f089 0901 	eor.w	r9, r9, #1
  144060:	f7ff fb60 	bl	143724 <invalidate_cache_block>
  144064:	ea86 0609 	eor.w	r6, r6, r9
        }
    }

#else
    //wait interrupt
    event_wait(&g_ce_signal[vce_id]);
  144068:	f242 308c 	movw	r0, #9100	; 0x238c
  14406c:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
  144070:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  144074:	f2c0 0016 	movt	r0, #22
    writel(value, _ioaddr(REG_CIPHER_CTRL_CE_(vce_id)));
  144078:	60e6      	str	r6, [r4, #12]
  14407a:	eb00 0085 	add.w	r0, r0, r5, lsl #2
  14407e:	f00a ffff 	bl	14f080 <event_wait_timeout>
    LTRACEF("wait interrupt in cipher end\n");
#endif

    uint32_t value_state = readl(_ioaddr(REG_ERRSTAT_CE_(vce_id))) & 0x3F00;
  144082:	6860      	ldr	r0, [r4, #4]

    if (0 != value_state) {
  144084:	f410 507c 	ands.w	r0, r0, #16128	; 0x3f00
  144088:	d008      	beq.n	14409c <aes_blk+0x26c>
        LTRACEF("CE_(%d) state: %d, error: 0x%x, control value: 0x%x\n", vce_id, (readl(_ioaddr(REG_STAT_CE_(vce_id))) & 0x4), value_state, value);

        //clear err status
        value_state = reg_value(1, 0xFFFFFFFF, CE_CIPHER_INTEGRITY_ERROR_INTSTAT_SHIFT, CE_CIPHER_INTEGRITY_ERROR_INTSTAT_MASK);
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  14408a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
        value_state = reg_value(0, 0xFFFFFFFF, CE_CIPHER_INTEGRITY_ERROR_INTSTAT_SHIFT, CE_CIPHER_INTEGRITY_ERROR_INTSTAT_MASK);
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  14408e:	f46f 6380 	mvn.w	r3, #1024	; 0x400
    }

    return CRYPTOLIB_SUCCESS;
  144092:	2000      	movs	r0, #0
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144094:	f8c4 2148 	str.w	r2, [r4, #328]	; 0x148
        writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144098:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
}
  14409c:	b003      	add	sp, #12
  14409e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_INVALID_PARAM_INPUT;
  1440a2:	200d      	movs	r0, #13
}
  1440a4:	b003      	add	sp, #12
  1440a6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            if (ctx == CTX_BEGIN || ctx == CTX_WHOLE) {
  1440aa:	f1b8 0f01 	cmp.w	r8, #1
  1440ae:	f67f af00 	bls.w	143eb2 <aes_blk+0x82>
            return len == AES_CTX_xCM_SIZE;
  1440b2:	f1a5 0520 	sub.w	r5, r5, #32
  1440b6:	fab5 f585 	clz	r5, r5
  1440ba:	096d      	lsrs	r5, r5, #5
  1440bc:	e6fe      	b.n	143ebc <aes_blk+0x8c>
            if (ctx == CTX_BEGIN || ctx == CTX_WHOLE) {
  1440be:	f1b8 0f01 	cmp.w	r8, #1
  1440c2:	d8f6      	bhi.n	1440b2 <aes_blk+0x282>
                return !len;
  1440c4:	fab5 f585 	clz	r5, r5
  1440c8:	096d      	lsrs	r5, r5, #5
  1440ca:	e6f7      	b.n	143ebc <aes_blk+0x8c>
    if (!IsIVContextLenValid(fct, ctx, iv.len)) {
  1440cc:	b91d      	cbnz	r5, 1440d6 <aes_blk+0x2a6>
        return !len;
  1440ce:	fab6 f686 	clz	r6, r6
  1440d2:	0976      	lsrs	r6, r6, #5
  1440d4:	e703      	b.n	143ede <aes_blk+0xae>
        return CRYPTOLIB_INVALID_PARAM_IV;
  1440d6:	200a      	movs	r0, #10
  1440d8:	e7e0      	b.n	14409c <aes_blk+0x26c>
    writel(value, _ioaddr(REG_CIPHER_IV_CONTEXT_ADDR_CE_(vce_id)));
  1440da:	62a3      	str	r3, [r4, #40]	; 0x28
    writel(value, _ioaddr(REG_CIPHER_PAYLOAD_LEN_CE_(vce_id)));
  1440dc:	62e2      	str	r2, [r4, #44]	; 0x2c
  1440de:	e76e      	b.n	143fbe <aes_blk+0x18e>
  1440e0:	f489 6380 	eor.w	r3, r9, #1024	; 0x400
            break;
  1440e4:	e79c      	b.n	144020 <aes_blk+0x1f0>
  1440e6:	f489 7300 	eor.w	r3, r9, #512	; 0x200
            break;
  1440ea:	e799      	b.n	144020 <aes_blk+0x1f0>
    if (!IsKeyLenValid(fct, key.len, xtskey.len)) {
  1440ec:	42bb      	cmp	r3, r7
  1440ee:	bf14      	ite	ne
  1440f0:	2400      	movne	r4, #0
  1440f2:	f004 0401 	andeq.w	r4, r4, #1
  1440f6:	2c00      	cmp	r4, #0
  1440f8:	f47f aedb 	bne.w	143eb2 <aes_blk+0x82>
        return CRYPTOLIB_INVALID_PARAM_KEY;
  1440fc:	200b      	movs	r0, #11
}
  1440fe:	b003      	add	sp, #12
  144100:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        value = reg_value(addr_switch_to_ce(vce_id, data_out.addr_type, (_paddr((void*)data_out.addr))), 0, CE_CIPHER_DST_ADDR_SHIFT, CE_CIPHER_DST_ADDR_MASK);
  144104:	4671      	mov	r1, r14
  144106:	4628      	mov	r0, r5
  144108:	f7ff fa60 	bl	1435cc <addr_switch_to_ce>
  14410c:	f8dd e080 	ldr.w	r14, [r13, #128]	; 0x80
  144110:	4602      	mov	r2, r0
  144112:	e72c      	b.n	143f6e <aes_blk+0x13e>
        value = reg_value(addr_switch_to_ce(vce_id, data_in.addr_type, (_paddr((void*)data_in.addr))), 0, CE_CIPHER_SRC_ADDR_SHIFT, CE_CIPHER_SRC_ADDR_MASK0);
  144114:	4661      	mov	r1, r12
  144116:	4628      	mov	r0, r5
  144118:	f7ff fa58 	bl	1435cc <addr_switch_to_ce>
  14411c:	f8dd c074 	ldr.w	r12, [r13, #116]	; 0x74
  144120:	f8dd e080 	ldr.w	r14, [r13, #128]	; 0x80
  144124:	4602      	mov	r2, r0
  144126:	e70d      	b.n	143f44 <aes_blk+0x114>
        return CRYPTOLIB_INVALID_PARAM_CTX;
  144128:	200c      	movs	r0, #12
  14412a:	e7b7      	b.n	14409c <aes_blk+0x26c>
            return !((len + header_len) % 16);
  14412c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
  14412e:	4423      	add	r3, r4
  144130:	f013 0f0f 	tst.w	r3, #15
  144134:	bf0c      	ite	eq
  144136:	2301      	moveq	r3, #1
  144138:	2300      	movne	r3, #0
  14413a:	e6e7      	b.n	143f0c <aes_blk+0xdc>

0014413c <pke_set_config>:
void pke_set_config(uint32_t vce_id,
                    uint32_t PtrA,
                    uint32_t PtrB,
                    uint32_t PtrC,
                    uint32_t PtrN)
{
  14413c:	f001 010f 	and.w	r1, r1, #15
  144140:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
  144144:	b410      	push	{r4}
  144146:	f402 6470 	and.w	r4, r2, #3840	; 0xf00
  14414a:	4321      	orrs	r1, r4
  14414c:	9c01      	ldr	r4, [sp, #4]
  14414e:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
  144152:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
  144156:	404b      	eors	r3, r1
  144158:	ea43 6404 	orr.w	r4, r3, r4, lsl #24
    uint32_t value = reg_value(PtrA, 0, CE_PK_OPPTRA_SHIFT, CE_PK_OPPTRA_MASK);
    value = reg_value(PtrB, value, CE_PK_OPPTRB_SHIFT, CE_PK_OPPTRB_MASK);
    value = reg_value(PtrC, value, CE_PK_OPPTRC_SHIFT, CE_PK_OPPTRC_MASK);
    value = reg_value(PtrN, value, CE_PK_OPPTRN_SHIFT, CE_PK_OPPTRN_MASK);

    writel(value, _ioaddr(REG_PK_POINTERREG_CE_(vce_id)));
  14415c:	0300      	lsls	r0, r0, #12
  14415e:	f004 6470 	and.w	r4, r4, #251658240	; 0xf000000
  144162:	405c      	eors	r4, r3
  144164:	f100 4074 	add.w	r0, r0, #4093640704	; 0xf4000000
  144168:	f8c0 4080 	str.w	r4, [r0, #128]	; 0x80
}
  14416c:	f85d 4b04 	ldr.w	r4, [r13], #4
  144170:	4770      	bx	r14
  144172:	bf00      	nop

00144174 <pke_set_command>:
void pke_set_command(uint32_t vce_id,
                     uint32_t op,
                     uint32_t operandsize,
                     uint32_t swap,
                     uint32_t curve_flags)
{
  144174:	b430      	push	{r4, r5}
  144176:	9d02      	ldr	r5, [sp, #8]
    uint32_t value = 0x80000000;  //PK_CALCR2
    uint32_t NumberOfBytes;

    if (operandsize > 0) {
  144178:	b10a      	cbz	r2, 14417e <pke_set_command+0xa>
        NumberOfBytes = operandsize - 1;
  14417a:	3a01      	subs	r2, #1
  14417c:	0212      	lsls	r2, r2, #8
  14417e:	f44f 447f 	mov.w	r4, #65280	; 0xff00
  144182:	f001 017f 	and.w	r1, r1, #127	; 0x7f
  144186:	f2c0 0407 	movt	r4, #7
  14418a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
  14418e:	4014      	ands	r4, r2
  144190:	404c      	eors	r4, r1
  144192:	ea84 7303 	eor.w	r3, r4, r3, lsl #28
  144196:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  14419a:	4063      	eors	r3, r4
#endif
    value = reg_value(swap, value, CE_PK_SWAP_SHIFT, CE_PK_SWAP_MASK);
    //value = reg_value(curve_flags, value, CE_PK_SELCURVE_SHIFT, CE_PK_SELCURVE_MASK);
    value |= curve_flags;

    writel(value, _ioaddr(REG_PK_COMMANDREG_CE_(vce_id)));
  14419c:	0300      	lsls	r0, r0, #12
    value |= curve_flags;
  14419e:	432b      	orrs	r3, r5
    writel(value, _ioaddr(REG_PK_COMMANDREG_CE_(vce_id)));
  1441a0:	f100 4074 	add.w	r0, r0, #4093640704	; 0xf4000000
}
  1441a4:	bc30      	pop	{r4, r5}
    writel(value, _ioaddr(REG_PK_COMMANDREG_CE_(vce_id)));
  1441a6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
}
  1441aa:	4770      	bx	r14

001441ac <pke_start_wait_status>:

    writel(value, _ioaddr(REG_PK_RESULTS_DST_ADDR_H_CE_(vce_id)));
}

uint32_t pke_start_wait_status(uint32_t vce_id)
{
  1441ac:	e92d 48f0 	stmdb	r13!, {r4, r5, r6, r7, r11, r14}
  1441b0:	4604      	mov	r4, r0
    uint32_t res;

#if RSA_PERFORMANCE_TEST
    uint64_t cur_time = current_time_hires();
  1441b2:	f7fc fbc7 	bl	140944 <current_time_hires>
    writel(value, _ioaddr(REG_PKE_CTRL_CE_(vce_id)));
  1441b6:	2301      	movs	r3, #1
  1441b8:	0325      	lsls	r5, r4, #12
  1441ba:	f105 4574 	add.w	r5, r5, #4093640704	; 0xf4000000
    event_wait(&g_ce_signal[vce_id]);
  1441be:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
    writel(value, _ioaddr(REG_PKE_CTRL_CE_(vce_id)));
  1441c2:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
    uint64_t cur_time = current_time_hires();
  1441c6:	4606      	mov	r6, r0
    event_wait(&g_ce_signal[vce_id]);
  1441c8:	f242 308c 	movw	r0, #9100	; 0x238c
    uint64_t cur_time = current_time_hires();
  1441cc:	460f      	mov	r7, r1
    event_wait(&g_ce_signal[vce_id]);
  1441ce:	f2c0 0016 	movt	r0, #22
  1441d2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1441d6:	eb00 0084 	add.w	r0, r0, r4, lsl #2
  1441da:	f00a ff51 	bl	14f080 <event_wait_timeout>
    uint32_t err = readl(_ioaddr(REG_PK_STATUSREG_CE_(vce_id))) & 0x3FF0; //get low 14 bits
  1441de:	f8d5 408c 	ldr.w	r4, [r5, #140]	; 0x8c
  1441e2:	f643 73f0 	movw	r3, #16368	; 0x3ff0
  1441e6:	401c      	ands	r4, r3
    switch (err) {
  1441e8:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
  1441ec:	d040      	beq.n	144270 <pke_start_wait_status+0xc4>
  1441ee:	d81d      	bhi.n	14422c <pke_start_wait_status+0x80>
  1441f0:	2c20      	cmp	r4, #32
            return CRYPTOLIB_PK_POINT_PX_ATINFINITY;
  1441f2:	bf08      	it	eq
  1441f4:	2417      	moveq	r4, #23
    switch (err) {
  1441f6:	d007      	beq.n	144208 <pke_start_wait_status+0x5c>
  1441f8:	d928      	bls.n	14424c <pke_start_wait_status+0xa0>
  1441fa:	2c40      	cmp	r4, #64	; 0x40
            return CRYPTOLIB_PK_COUPLE_NOTVALID;
  1441fc:	bf08      	it	eq
  1441fe:	2416      	moveq	r4, #22
    switch (err) {
  144200:	d002      	beq.n	144208 <pke_start_wait_status+0x5c>
  144202:	2c80      	cmp	r4, #128	; 0x80
            return CRYPTOLIB_PK_N_NOTVALID;
  144204:	bf08      	it	eq
  144206:	2415      	moveq	r4, #21

    pke_start(vce_id);
    res = pke_wait_status(vce_id);

#if RSA_PERFORMANCE_TEST
    time_slice += current_time_hires() - cur_time;
  144208:	f7fc fb9c 	bl	140944 <current_time_hires>
  14420c:	f642 4500 	movw	r5, #11264	; 0x2c00
  144210:	f2c0 0516 	movt	r5, #22
  144214:	e9d5 2300 	ldrd	r2, r3, [r5]
  144218:	1b92      	subs	r2, r2, r6
  14421a:	eb63 0307 	sbc.w	r3, r3, r7
  14421e:	1812      	adds	r2, r2, r0
#endif

    return res;
}
  144220:	4620      	mov	r0, r4
    time_slice += current_time_hires() - cur_time;
  144222:	414b      	adcs	r3, r1
  144224:	e9c5 2300 	strd	r2, r3, [r5]
}
  144228:	e8bd 88f0 	ldmia.w	r13!, {r4, r5, r6, r7, r11, r15}
    switch (err) {
  14422c:	f5b4 6f00 	cmp.w	r4, #2048	; 0x800
            return CRYPTOLIB_PK_NOTINVERTIBLE;
  144230:	bf08      	it	eq
  144232:	2411      	moveq	r4, #17
    switch (err) {
  144234:	d0e8      	beq.n	144208 <pke_start_wait_status+0x5c>
  144236:	d911      	bls.n	14425c <pke_start_wait_status+0xb0>
  144238:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
            return CRYPTOLIB_PK_COMPOSITE;
  14423c:	bf08      	it	eq
  14423e:	2410      	moveq	r4, #16
    switch (err) {
  144240:	d0e2      	beq.n	144208 <pke_start_wait_status+0x5c>
  144242:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
            return CRYPTOLIB_PK_NOTQUADRATICRESIDUE;
  144246:	bf08      	it	eq
  144248:	240f      	moveq	r4, #15
  14424a:	e7dd      	b.n	144208 <pke_start_wait_status+0x5c>
    switch (err) {
  14424c:	2c0f      	cmp	r4, #15
            return CRYPTOLIB_PK_FAIL_ADDRESS;
  14424e:	bf08      	it	eq
  144250:	2419      	moveq	r4, #25
    switch (err) {
  144252:	d0d9      	beq.n	144208 <pke_start_wait_status+0x5c>
  144254:	2c10      	cmp	r4, #16
            return CRYPTOLIB_PK_POINT_PX_NOTONCURVE;
  144256:	bf08      	it	eq
  144258:	2418      	moveq	r4, #24
  14425a:	e7d5      	b.n	144208 <pke_start_wait_status+0x5c>
    switch (err) {
  14425c:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
            return CRYPTOLIB_PK_SIGNATURE_NOTVALID;
  144260:	bf08      	it	eq
  144262:	2413      	moveq	r4, #19
    switch (err) {
  144264:	d0d0      	beq.n	144208 <pke_start_wait_status+0x5c>
  144266:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
            return CRYPTOLIB_PK_PARAM_AB_NOTVALID;
  14426a:	bf08      	it	eq
  14426c:	2412      	moveq	r4, #18
  14426e:	e7cb      	b.n	144208 <pke_start_wait_status+0x5c>
            return CRYPTOLIB_PK_NOTIMPLEMENTED;
  144270:	2414      	movs	r4, #20
  144272:	e7c9      	b.n	144208 <pke_start_wait_status+0x5c>

00144274 <pke_load_curve>:
void pke_load_curve(uint32_t vce_id,
                    block_t curve,
                    uint32_t size,
                    uint32_t byte_swap,
                    uint32_t gen)
{
  144274:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  144278:	b08d      	sub	sp, #52	; 0x34
  14427a:	ac05      	add	r4, sp, #20
  14427c:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    uint32_t i;

    block_t param;
    param.addr  = curve.addr;
    param.len   = size;
    param.addr_type = curve.addr_type;
  144280:	e9dd 9306 	ldrd	r9, r3, [r13, #24]
  144284:	930b      	str	r3, [sp, #44]	; 0x2c
{
  144286:	9e16      	ldr	r6, [sp, #88]	; 0x58
  144288:	f8dd b060 	ldr.w	r11, [r13, #96]	; 0x60

    /* Load ECC parameters */
    for (i = 0; i * size < curve.len; i++) {
  14428c:	f1b9 0f00 	cmp.w	r9, #0
  144290:	d030      	beq.n	1442f4 <pke_load_curve+0x80>
  144292:	468a      	mov	r10, r1
  144294:	4680      	mov	r8, r0
  144296:	2400      	movs	r4, #0
    param.addr  = curve.addr;
  144298:	460d      	mov	r5, r1
        if (gen || (i != 2 && i != 3)) {
            if (!byte_swap) {
                mem2CryptoRAM_rev(vce_id, param, size, i, true);
            }
            else {
                mem2CryptoRAM(vce_id, param, size, i, false);
  14429a:	af09      	add	r7, sp, #36	; 0x24
  14429c:	e010      	b.n	1442c0 <pke_load_curve+0x4c>
                mem2CryptoRAM_rev(vce_id, param, size, i, true);
  14429e:	2301      	movs	r3, #1
  1442a0:	4640      	mov	r0, r8
  1442a2:	960a      	str	r6, [sp, #40]	; 0x28
  1442a4:	e9cd 4301 	strd	r4, r3, [r13, #4]
  1442a8:	9600      	str	r6, [sp, #0]
  1442aa:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  1442ae:	f000 fe19 	bl	144ee4 <mem2CryptoRAM_rev>
            }
        }

        param.addr += param.len;
  1442b2:	4435      	add	r5, r6
  1442b4:	eba5 030a 	sub.w	r3, r5, r10
    for (i = 0; i * size < curve.len; i++) {
  1442b8:	4599      	cmp	r9, r3
  1442ba:	f104 0401 	add.w	r4, r4, #1
  1442be:	d919      	bls.n	1442f4 <pke_load_curve+0x80>
                mem2CryptoRAM(vce_id, param, size, i, false);
  1442c0:	4640      	mov	r0, r8
        if (gen || (i != 2 && i != 3)) {
  1442c2:	1ea3      	subs	r3, r4, #2
  1442c4:	f1bb 0f00 	cmp.w	r11, #0
  1442c8:	d101      	bne.n	1442ce <pke_load_curve+0x5a>
  1442ca:	2b01      	cmp	r3, #1
  1442cc:	d9f1      	bls.n	1442b2 <pke_load_curve+0x3e>
            if (!byte_swap) {
  1442ce:	9b17      	ldr	r3, [sp, #92]	; 0x5c
                mem2CryptoRAM_rev(vce_id, param, size, i, true);
  1442d0:	9509      	str	r5, [sp, #36]	; 0x24
            if (!byte_swap) {
  1442d2:	2b00      	cmp	r3, #0
  1442d4:	d0e3      	beq.n	14429e <pke_load_curve+0x2a>
                mem2CryptoRAM(vce_id, param, size, i, false);
  1442d6:	2300      	movs	r3, #0
        param.addr += param.len;
  1442d8:	4435      	add	r5, r6
                mem2CryptoRAM(vce_id, param, size, i, false);
  1442da:	960a      	str	r6, [sp, #40]	; 0x28
  1442dc:	e9cd 4301 	strd	r4, r3, [r13, #4]
    for (i = 0; i * size < curve.len; i++) {
  1442e0:	3401      	adds	r4, #1
                mem2CryptoRAM(vce_id, param, size, i, false);
  1442e2:	9600      	str	r6, [sp, #0]
  1442e4:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  1442e8:	f000 fef6 	bl	1450d8 <mem2CryptoRAM>
  1442ec:	eba5 030a 	sub.w	r3, r5, r10
    for (i = 0; i * size < curve.len; i++) {
  1442f0:	4599      	cmp	r9, r3
  1442f2:	d8e5      	bhi.n	1442c0 <pke_load_curve+0x4c>
    }
}
  1442f4:	b00d      	add	sp, #52	; 0x34
  1442f6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  1442fa:	bf00      	nop

001442fc <gen_rnd_bytes>:
*/
static void gen_rnd_bytes(uint32_t vce_id,
                          uint8_t* dst,
                          size_t n,
                          uint32_t rem_zeros)
{
  1442fc:	b570      	push	{r4, r5, r6, r14}
  1442fe:	461e      	mov	r6, r3
  144300:	b084      	sub	sp, #16
  144302:	4614      	mov	r4, r2
#if !WITH_SIMULATION_PLATFORM  //rng not work on paladium
    trng_get_rand_blk(vce_id,
  144304:	ab04      	add	r3, sp, #16
  144306:	2203      	movs	r2, #3
{
  144308:	460d      	mov	r5, r1
  14430a:	e9cd 1401 	strd	r1, r4, [r13, #4]
  14430e:	9203      	str	r2, [sp, #12]
    trng_get_rand_blk(vce_id,
  144310:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  144314:	f001 fe50 	bl	145fb8 <trng_get_rand_blk>
                      block_t_convert(dst, n, EXT_MEM));

    if (rem_zeros) {
  144318:	b14e      	cbz	r6, 14432e <gen_rnd_bytes+0x32>
        //Remove zeros (not perfect for entropy)
        for (; n > 0; n--) if (dst[n - 1] == 0x00) {
                dst[n - 1] = 0x01;
  14431a:	2101      	movs	r1, #1
  14431c:	192a      	adds	r2, r5, r4
        for (; n > 0; n--) if (dst[n - 1] == 0x00) {
  14431e:	b12c      	cbz	r4, 14432c <gen_rnd_bytes+0x30>
  144320:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
  144324:	b903      	cbnz	r3, 144328 <gen_rnd_bytes+0x2c>
                dst[n - 1] = 0x01;
  144326:	7011      	strb	r1, [r2, #0]
        for (; n > 0; n--) if (dst[n - 1] == 0x00) {
  144328:	42aa      	cmp	r2, r5
  14432a:	d1f9      	bne.n	144320 <gen_rnd_bytes+0x24>
{
  14432c:	2400      	movs	r4, #0
            }
    }

#endif
    memset(dst, 0x1, n);
  14432e:	4622      	mov	r2, r4
  144330:	4628      	mov	r0, r5
  144332:	2101      	movs	r1, #1
}
  144334:	b004      	add	sp, #16
  144336:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    memset(dst, 0x1, n);
  14433a:	f010 bbb9 	b.w	154ab0 <__memset_from_thumb>
  14433e:	bf00      	nop

00144340 <MGF1>:
                 hash_alg_t hashType,
                 uint8_t* seed,
                 size_t seedLen,
                 uint8_t* mask,
                 size_t maskLen)
{
  144340:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  144344:	4683      	mov	r11, r0
  144346:	b09d      	sub	sp, #116	; 0x74
    uint32_t hashLen;
    uint8_t* hash_in;
    struct mem_node* mem_n;
    uint32_t res = 0;

    mem_n = ce_malloc(68 + 28);
  144348:	2060      	movs	r0, #96	; 0x60
{
  14434a:	468a      	mov	r10, r1
  14434c:	4614      	mov	r4, r2
  14434e:	4699      	mov	r9, r3
  144350:	e9dd 6526 	ldrd	r6, r5, [r13, #152]	; 0x98
    mem_n = ce_malloc(68 + 28);
  144354:	f7ff f8c6 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  144358:	900e      	str	r0, [sp, #56]	; 0x38
  14435a:	2800      	cmp	r0, #0
  14435c:	d064      	beq.n	144428 <MGF1+0xe8>
        hash_in = mem_n->ptr;
  14435e:	6883      	ldr	r3, [r0, #8]
    }
    else {
        return;
    }

    hashLen = hash_get_digest_size(hashType);
  144360:	4650      	mov	r0, r10
        hash_in = mem_n->ptr;
  144362:	461f      	mov	r7, r3
    hashLen = hash_get_digest_size(hashType);
  144364:	f7ff fb36 	bl	1439d4 <hash_get_digest_size>

    memcpy(hash_in, seed, seedLen);
  144368:	464a      	mov	r2, r9
  14436a:	4621      	mov	r1, r4
  14436c:	9709      	str	r7, [sp, #36]	; 0x24
    hashLen = hash_get_digest_size(hashType);
  14436e:	4680      	mov	r8, r0
    memcpy(hash_in, seed, seedLen);
  144370:	4638      	mov	r0, r7
  144372:	f00e edfe 	blx	152f70 <memcpy>

    while (maskLen) {
  144376:	2d00      	cmp	r5, #0
  144378:	d04a      	beq.n	144410 <MGF1+0xd0>
  14437a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    uint32_t c = 0;
  14437c:	2400      	movs	r4, #0
        memcpy(hash_in + seedLen, cnt, 4);
        res = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
                       block_t_convert(hash_in, seedLen + 4, EXT_MEM), block_t_convert(mask, maskLen, EXT_MEM));

        if (CRYPTOLIB_SUCCESS != res) {
            dprintf(CRITICAL, "generate mask hash fail in MGF1.\n");
  14437e:	f245 721c 	movw	r2, #22300	; 0x571c
  144382:	4627      	mov	r7, r4
  144384:	444b      	add	r3, r9
  144386:	9608      	str	r6, [sp, #32]
  144388:	f2c0 0215 	movt	r2, #21
  14438c:	930a      	str	r3, [sp, #40]	; 0x28
  14438e:	f109 0304 	add.w	r3, r9, #4
  144392:	920f      	str	r2, [sp, #60]	; 0x3c
  144394:	f04f 0903 	mov.w	r9, #3
  144398:	930b      	str	r3, [sp, #44]	; 0x2c
  14439a:	ab04      	add	r3, sp, #16
  14439c:	930d      	str	r3, [sp, #52]	; 0x34
  14439e:	ab01      	add	r3, sp, #4
  1443a0:	930c      	str	r3, [sp, #48]	; 0x30
  1443a2:	9808      	ldr	r0, [sp, #32]
        cnt[2] = ((c >> 8)   & 0xFF);
  1443a4:	0a23      	lsrs	r3, r4, #8
  1443a6:	9019      	str	r0, [sp, #100]	; 0x64
        cnt[0] = ((c >> 24)  & 0xFF); // note: modifying cnt content via array_blk[1].addr to make static analyzer happy
  1443a8:	0e21      	lsrs	r1, r4, #24
        cnt[2] = ((c >> 8)   & 0xFF);
  1443aa:	f88d 3046 	strb.w	r3, [r13, #70]	; 0x46
        res = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  1443ae:	ab19      	add	r3, sp, #100	; 0x64
        cnt[1] = ((c >> 16)  & 0xFF);
  1443b0:	0c22      	lsrs	r2, r4, #16
  1443b2:	e9cd 591a 	strd	r5, r9, [r13, #104]	; 0x68
        }

        c++;
        maskLen -= hashLen >= maskLen ? maskLen : hashLen;
        mask += hashLen;
  1443b6:	4440      	add	r0, r8
        cnt[0] = ((c >> 24)  & 0xFF); // note: modifying cnt content via array_blk[1].addr to make static analyzer happy
  1443b8:	f88d 1044 	strb.w	r1, [r13, #68]	; 0x44
        cnt[1] = ((c >> 16)  & 0xFF);
  1443bc:	f88d 2045 	strb.w	r2, [r13, #69]	; 0x45
        mask += hashLen;
  1443c0:	9008      	str	r0, [sp, #32]
        res = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  1443c2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  1443c6:	9b09      	ldr	r3, [sp, #36]	; 0x24
        cnt[3] = ((c)        & 0xFF);
  1443c8:	f88d 4047 	strb.w	r4, [r13, #71]	; 0x47
        cnt[2] = ((c >> 8)   & 0xFF);
  1443cc:	3401      	adds	r4, #1
  1443ce:	9316      	str	r3, [sp, #88]	; 0x58
  1443d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1443d2:	e9cd 3917 	strd	r3, r9, [r13, #92]	; 0x5c
        memcpy(hash_in + seedLen, cnt, 4);
  1443d6:	9e11      	ldr	r6, [sp, #68]	; 0x44
  1443d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  1443da:	601e      	str	r6, [r3, #0]
        res = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  1443dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  1443de:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1443e2:	e9cd 7713 	strd	r7, r7, [r13, #76]	; 0x4c
  1443e6:	ab16      	add	r3, sp, #88	; 0x58
  1443e8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  1443ec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  1443ee:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1443f2:	9700      	str	r7, [sp, #0]
  1443f4:	ab13      	add	r3, sp, #76	; 0x4c
  1443f6:	4659      	mov	r1, r11
  1443f8:	4650      	mov	r0, r10
  1443fa:	cb0c      	ldmia	r3, {r2, r3}
  1443fc:	f7ff faf4 	bl	1439e8 <hash_blk>
        maskLen -= hashLen >= maskLen ? maskLen : hashLen;
  144400:	45a8      	cmp	r8, r5
  144402:	bf94      	ite	ls
  144404:	eba5 0508 	subls.w	r5, r5, r8
  144408:	1b6d      	subhi	r5, r5, r5
        if (CRYPTOLIB_SUCCESS != res) {
  14440a:	b938      	cbnz	r0, 14441c <MGF1+0xdc>
    while (maskLen) {
  14440c:	2d00      	cmp	r5, #0
  14440e:	d1c8      	bne.n	1443a2 <MGF1+0x62>
    }

    ce_free(mem_n);
  144410:	980e      	ldr	r0, [sp, #56]	; 0x38
}
  144412:	b01d      	add	sp, #116	; 0x74
  144414:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    ce_free(mem_n);
  144418:	f7ff b8a8 	b.w	14356c <ce_free>
            dprintf(CRITICAL, "generate mask hash fail in MGF1.\n");
  14441c:	980f      	ldr	r0, [sp, #60]	; 0x3c
  14441e:	f00f fe6b 	bl	1540f8 <_printf>
    while (maskLen) {
  144422:	2d00      	cmp	r5, #0
  144424:	d1bd      	bne.n	1443a2 <MGF1+0x62>
  144426:	e7f3      	b.n	144410 <MGF1+0xd0>
}
  144428:	b01d      	add	sp, #116	; 0x74
  14442a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  14442e:	bf00      	nop

00144430 <getFirstMask>:
    if (n0 & 0x80) {
  144430:	0601      	lsls	r1, r0, #24
  144432:	d40e      	bmi.n	144452 <getFirstMask+0x22>
    else if (n0 & 0x40) {
  144434:	0642      	lsls	r2, r0, #25
  144436:	d40a      	bmi.n	14444e <getFirstMask+0x1e>
    else if (n0 & 0x20) {
  144438:	0683      	lsls	r3, r0, #26
  14443a:	d40e      	bmi.n	14445a <getFirstMask+0x2a>
    else if (n0 & 0x10) {
  14443c:	06c1      	lsls	r1, r0, #27
  14443e:	d40e      	bmi.n	14445e <getFirstMask+0x2e>
    else if (n0 & 0x08) {
  144440:	0702      	lsls	r2, r0, #28
  144442:	d408      	bmi.n	144456 <getFirstMask+0x26>
    else if (n0 & 0x04) {
  144444:	0743      	lsls	r3, r0, #29
  144446:	d40c      	bmi.n	144462 <getFirstMask+0x32>
    else if (n0 & 0x02) {
  144448:	f3c0 0040 	ubfx	r0, r0, #1, #1
  14444c:	4770      	bx	r14
        return 0x3F;
  14444e:	203f      	movs	r0, #63	; 0x3f
  144450:	4770      	bx	r14
        return 0x7F;
  144452:	207f      	movs	r0, #127	; 0x7f
  144454:	4770      	bx	r14
        return 0x07;
  144456:	2007      	movs	r0, #7
  144458:	4770      	bx	r14
        return 0x1F;
  14445a:	201f      	movs	r0, #31
  14445c:	4770      	bx	r14
        return 0x0F;
  14445e:	200f      	movs	r0, #15
  144460:	4770      	bx	r14
        return 0x03;
  144462:	2003      	movs	r0, #3
}
  144464:	4770      	bx	r14
  144466:	bf00      	nop

00144468 <rsa_pad_eme_oaep_encode>:
                                 uint32_t k,
                                 hash_alg_t hashType,
                                 uint8_t* EM,
                                 block_t message,
                                 size_t mLen)
{
  144468:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14446c:	4682      	mov	r10, r0
  14446e:	b099      	sub	sp, #100	; 0x64
    struct mem_node* mem_n_1;
    uint32_t hLen;
    uint32_t status;

    // get lengths
    hLen = hash_get_digest_size(hashType);
  144470:	4610      	mov	r0, r2
{
  144472:	4688      	mov	r8, r1
  144474:	461c      	mov	r4, r3
  144476:	4617      	mov	r7, r2
    hLen = hash_get_digest_size(hashType);
  144478:	f7ff faac 	bl	1439d4 <hash_get_digest_size>

    if (mLen + 2 * hLen + 2 > k) {
  14447c:	9b25      	ldr	r3, [sp, #148]	; 0x94
  14447e:	3302      	adds	r3, #2
  144480:	ea4f 0940 	mov.w	r9, r0, lsl #1
  144484:	444b      	add	r3, r9
  144486:	4543      	cmp	r3, r8
        return CRYPTOLIB_INVALID_PARAM;    // MESSAGE_TOO_LONG;
  144488:	bf88      	it	hi
  14448a:	2609      	movhi	r6, #9
    if (mLen + 2 * hLen + 2 > k) {
  14448c:	f200 8099 	bhi.w	1445c2 <rsa_pad_eme_oaep_encode+0x15a>
  144490:	2203      	movs	r2, #3
    }

    // get label hash -> no label so NULL_blk
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
                      block_t_convert(NULL, 0, 0), block_t_convert(EM + hLen + 1, hLen, EXT_MEM));
  144492:	1c43      	adds	r3, r0, #1
  144494:	2600      	movs	r6, #0
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  144496:	f10d 0c48 	add.w	r12, r13, #72	; 0x48
  14449a:	9217      	str	r2, [sp, #92]	; 0x5c
  14449c:	aa18      	add	r2, sp, #96	; 0x60
                      block_t_convert(NULL, 0, 0), block_t_convert(EM + hLen + 1, hLen, EXT_MEM));
  14449e:	930a      	str	r3, [sp, #40]	; 0x28
  1444a0:	4423      	add	r3, r4
  1444a2:	4619      	mov	r1, r3
  1444a4:	4605      	mov	r5, r0
  1444a6:	9309      	str	r3, [sp, #36]	; 0x24
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  1444a8:	ab04      	add	r3, sp, #16
  1444aa:	9016      	str	r0, [sp, #88]	; 0x58
  1444ac:	f10d 0e3c 	add.w	r14, r13, #60	; 0x3c
  1444b0:	9115      	str	r1, [sp, #84]	; 0x54
  1444b2:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  1444b6:	9612      	str	r6, [sp, #72]	; 0x48
  1444b8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1444bc:	9613      	str	r6, [sp, #76]	; 0x4c
  1444be:	ab01      	add	r3, sp, #4
  1444c0:	9614      	str	r6, [sp, #80]	; 0x50
  1444c2:	e89c 0007 	ldmia.w	r12, {r0, r1, r2}
  1444c6:	e9cd 660f 	strd	r6, r6, [r13, #60]	; 0x3c
  1444ca:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1444ce:	9600      	str	r6, [sp, #0]
  1444d0:	4651      	mov	r1, r10
  1444d2:	9611      	str	r6, [sp, #68]	; 0x44
  1444d4:	4638      	mov	r0, r7
  1444d6:	e89e 000c 	ldmia.w	r14, {r2, r3}
  1444da:	f7ff fa85 	bl	1439e8 <hash_blk>

    if (status != CRYPTOLIB_SUCCESS) {
  1444de:	4606      	mov	r6, r0
  1444e0:	2800      	cmp	r0, #0
  1444e2:	d172      	bne.n	1445ca <rsa_pad_eme_oaep_encode+0x162>
        return CRYPTOLIB_CRYPTO_ERR;
    }

    //Assemply of DB
    gen_rnd_bytes(vce_id, EM + 1, hLen, 0);
  1444e4:	940c      	str	r4, [sp, #48]	; 0x30
  1444e6:	1c62      	adds	r2, r4, #1
    EM[0] = 0x00;
    memset((uint8_t*)(EM + 2 * hLen + 1), 0x00, k - mLen - 2 * hLen - 2); //PS
  1444e8:	9c25      	ldr	r4, [sp, #148]	; 0x94
    gen_rnd_bytes(vce_id, EM + 1, hLen, 0);
  1444ea:	4603      	mov	r3, r0
  1444ec:	4611      	mov	r1, r2
  1444ee:	4650      	mov	r0, r10
  1444f0:	920b      	str	r2, [sp, #44]	; 0x2c
  1444f2:	462a      	mov	r2, r5
  1444f4:	f7ff ff02 	bl	1442fc <gen_rnd_bytes>
    memset((uint8_t*)(EM + 2 * hLen + 1), 0x00, k - mLen - 2 * hLen - 2); //PS
  1444f8:	eba8 0b04 	sub.w	r11, r8, r4
    EM[0] = 0x00;
  1444fc:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    memset((uint8_t*)(EM + 2 * hLen + 1), 0x00, k - mLen - 2 * hLen - 2); //PS
  1444fe:	f1ab 0202 	sub.w	r2, r11, #2
  144502:	f109 0001 	add.w	r0, r9, #1
  144506:	4631      	mov	r1, r6
  144508:	eba2 0209 	sub.w	r2, r2, r9
    EM[0] = 0x00;
  14450c:	7026      	strb	r6, [r4, #0]
    memset((uint8_t*)(EM + 2 * hLen + 1), 0x00, k - mLen - 2 * hLen - 2); //PS
  14450e:	4420      	add	r0, r4
  144510:	f00e edb4 	blx	15307c <memset>
    *((uint8_t*)(EM + k - mLen - 1)) = 0x01; //0x01
  144514:	2301      	movs	r3, #1
    memcpy(EM + k - mLen, message.addr, mLen);
  144516:	9a25      	ldr	r2, [sp, #148]	; 0x94
    *((uint8_t*)(EM + k - mLen - 1)) = 0x01; //0x01
  144518:	44a3      	add	r11, r4
    memcpy(EM + k - mLen, message.addr, mLen);
  14451a:	9922      	ldr	r1, [sp, #136]	; 0x88
  14451c:	4658      	mov	r0, r11
    *((uint8_t*)(EM + k - mLen - 1)) = 0x01; //0x01
  14451e:	f80b 3c01 	strb.w	r3, [r11, #-1]
    memcpy(EM + k - mLen, message.addr, mLen);
  144522:	f00e ed26 	blx	152f70 <memcpy>

    mem_n = ce_malloc(RSA_MAX_SIZE);
  144526:	f44f 7000 	mov.w	r0, #512	; 0x200
  14452a:	f7fe ffdb 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  14452e:	4683      	mov	r11, r0
  144530:	2800      	cmp	r0, #0
  144532:	d04f      	beq.n	1445d4 <rsa_pad_eme_oaep_encode+0x16c>
        dbMask = mem_n->ptr;
  144534:	f8db 9008 	ldr.w	r9, [r11, #8]
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    mem_n_1 = ce_malloc(MAX_DIGESTSIZE);
  144538:	2040      	movs	r0, #64	; 0x40
  14453a:	f7fe ffd3 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  14453e:	900c      	str	r0, [sp, #48]	; 0x30
  144540:	2800      	cmp	r0, #0
  144542:	d049      	beq.n	1445d8 <rsa_pad_eme_oaep_encode+0x170>
        seedMask = mem_n_1->ptr;
  144544:	6881      	ldr	r1, [r0, #8]
    else {
        ce_free(mem_n);
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    MGF1(vce_id, hashType, EM + 1, hLen, dbMask, k - hLen - 1);
  144546:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
        seedMask = mem_n_1->ptr;
  14454a:	910d      	str	r1, [sp, #52]	; 0x34
    MGF1(vce_id, hashType, EM + 1, hLen, dbMask, k - hLen - 1);
  14454c:	eba8 0805 	sub.w	r8, r8, r5
  144550:	462b      	mov	r3, r5
  144552:	4639      	mov	r1, r7
  144554:	f8cd 8004 	str.w	r8, [r13, #4]
  144558:	4650      	mov	r0, r10
  14455a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  14455c:	f8cd 9000 	str.w	r9, [r13]
  144560:	f7ff feee 	bl	144340 <MGF1>
    for (; n > 0; n--) {
  144564:	f1b8 0f00 	cmp.w	r8, #0
  144568:	d00d      	beq.n	144586 <rsa_pad_eme_oaep_encode+0x11e>
  14456a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  14456c:	eb09 0108 	add.w	r1, r9, r8
  144570:	4443      	add	r3, r8
  144572:	441c      	add	r4, r3
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144574:	f811 2d01 	ldrb.w	r2, [r1, #-1]!
  144578:	f814 3d01 	ldrb.w	r3, [r4, #-1]!
    for (; n > 0; n--) {
  14457c:	4549      	cmp	r1, r9
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  14457e:	ea83 0302 	eor.w	r3, r3, r2
  144582:	7023      	strb	r3, [r4, #0]
    for (; n > 0; n--) {
  144584:	d1f6      	bne.n	144574 <rsa_pad_eme_oaep_encode+0x10c>
    mask(EM + 1 + hLen, dbMask, k - hLen - 1);
    MGF1(vce_id, hashType, EM + 1 + hLen, k - hLen - 1, seedMask, hLen);
  144586:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  144588:	4639      	mov	r1, r7
  14458a:	9f09      	ldr	r7, [sp, #36]	; 0x24
  14458c:	4643      	mov	r3, r8
  14458e:	9501      	str	r5, [sp, #4]
  144590:	4650      	mov	r0, r10
  144592:	9400      	str	r4, [sp, #0]
  144594:	463a      	mov	r2, r7
  144596:	f7ff fed3 	bl	144340 <MGF1>
    for (; n > 0; n--) {
  14459a:	b165      	cbz	r5, 1445b6 <rsa_pad_eme_oaep_encode+0x14e>
  14459c:	980b      	ldr	r0, [sp, #44]	; 0x2c
  14459e:	442c      	add	r4, r5
  1445a0:	4639      	mov	r1, r7
  1445a2:	4625      	mov	r5, r4
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  1445a4:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
  1445a8:	f815 2d01 	ldrb.w	r2, [r5, #-1]!
    for (; n > 0; n--) {
  1445ac:	4281      	cmp	r1, r0
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  1445ae:	ea83 0302 	eor.w	r3, r3, r2
  1445b2:	700b      	strb	r3, [r1, #0]
    for (; n > 0; n--) {
  1445b4:	d1f6      	bne.n	1445a4 <rsa_pad_eme_oaep_encode+0x13c>
    mask(EM + 1, seedMask, hLen);

    ce_free(mem_n);
  1445b6:	4658      	mov	r0, r11
  1445b8:	f7fe ffd8 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  1445bc:	980c      	ldr	r0, [sp, #48]	; 0x30
  1445be:	f7fe ffd5 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  1445c2:	4630      	mov	r0, r6
  1445c4:	b019      	add	sp, #100	; 0x64
  1445c6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_CRYPTO_ERR;
  1445ca:	2606      	movs	r6, #6
}
  1445cc:	4630      	mov	r0, r6
  1445ce:	b019      	add	sp, #100	; 0x64
  1445d0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_PK_N_NOTVALID;
  1445d4:	2615      	movs	r6, #21
  1445d6:	e7f4      	b.n	1445c2 <rsa_pad_eme_oaep_encode+0x15a>
        ce_free(mem_n);
  1445d8:	4658      	mov	r0, r11
        return CRYPTOLIB_PK_N_NOTVALID;
  1445da:	2615      	movs	r6, #21
        ce_free(mem_n);
  1445dc:	f7fe ffc6 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  1445e0:	e7ef      	b.n	1445c2 <rsa_pad_eme_oaep_encode+0x15a>
  1445e2:	bf00      	nop

001445e4 <rsa_pad_eme_oaep_decode>:
                                 uint32_t k,
                                 hash_alg_t hashType,
                                 uint8_t* EM,
                                 uint8_t** message,
                                 size_t* mLen)
{
  1445e4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1445e8:	4605      	mov	r5, r0
  1445ea:	b099      	sub	sp, #100	; 0x64
  1445ec:	460e      	mov	r6, r1
  1445ee:	4691      	mov	r9, r2
  1445f0:	900b      	str	r0, [sp, #44]	; 0x2c
    uint8_t* dbMask;
    struct mem_node* mem_n;
    uint8_t* seedMask;
    struct mem_node* mem_n_1;

    mem_n = ce_malloc(RSA_MAX_SIZE);
  1445f2:	f44f 7000 	mov.w	r0, #512	; 0x200
{
  1445f6:	469b      	mov	r11, r3

    if (mem_n != NULL) {
        dbMask = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  1445f8:	2415      	movs	r4, #21
{
  1445fa:	9309      	str	r3, [sp, #36]	; 0x24
    mem_n = ce_malloc(RSA_MAX_SIZE);
  1445fc:	f7fe ff72 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  144600:	2800      	cmp	r0, #0
  144602:	f000 809a 	beq.w	14473a <rsa_pad_eme_oaep_decode+0x156>
  144606:	4682      	mov	r10, r0
    }

    mem_n_1 = ce_malloc(MAX_DIGESTSIZE);
  144608:	2040      	movs	r0, #64	; 0x40
        dbMask = mem_n->ptr;
  14460a:	f8da 7008 	ldr.w	r7, [r10, #8]
    mem_n_1 = ce_malloc(MAX_DIGESTSIZE);
  14460e:	f7fe ff69 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  144612:	900c      	str	r0, [sp, #48]	; 0x30
  144614:	4602      	mov	r2, r0
  144616:	2800      	cmp	r0, #0
  144618:	f000 80a8 	beq.w	14476c <rsa_pad_eme_oaep_decode+0x188>
        seedMask = mem_n_1->ptr;
  14461c:	6892      	ldr	r2, [r2, #8]
  14461e:	1e74      	subs	r4, r6, #1
  144620:	920a      	str	r2, [sp, #40]	; 0x28
    else {
        ce_free(mem_n);
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    hLen = hash_get_digest_size(hashType);
  144622:	4648      	mov	r0, r9
  144624:	940d      	str	r4, [sp, #52]	; 0x34
  144626:	f7ff f9d5 	bl	1439d4 <hash_get_digest_size>

    MGF1(vce_id, hashType, EM + hLen + 1, k - hLen - 1, seedMask, hLen);
  14462a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  14462c:	4649      	mov	r1, r9
  14462e:	f8cd b024 	str.w	r11, [r13, #36]	; 0x24
  144632:	9300      	str	r3, [sp, #0]
    hLen = hash_get_digest_size(hashType);
  144634:	4680      	mov	r8, r0
    MGF1(vce_id, hashType, EM + hLen + 1, k - hLen - 1, seedMask, hLen);
  144636:	4628      	mov	r0, r5
  144638:	f108 0501 	add.w	r5, r8, #1
  14463c:	44ab      	add	r11, r5
  14463e:	465a      	mov	r2, r11
  144640:	eba4 0408 	sub.w	r4, r4, r8
  144644:	f8cd 8004 	str.w	r8, [r13, #4]
  144648:	4623      	mov	r3, r4
  14464a:	f7ff fe79 	bl	144340 <MGF1>
    mask(EM + 1, seedMask, hLen);
  14464e:	9909      	ldr	r1, [sp, #36]	; 0x24
  144650:	1c4a      	adds	r2, r1, #1
    for (; n > 0; n--) {
  144652:	f1b8 0f00 	cmp.w	r8, #0
  144656:	d00c      	beq.n	144672 <rsa_pad_eme_oaep_decode+0x8e>
  144658:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  14465a:	4658      	mov	r0, r11
  14465c:	eb03 0c08 	add.w	r12, r3, r8
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144660:	f810 3d01 	ldrb.w	r3, [r0, #-1]!
  144664:	f81c 1d01 	ldrb.w	r1, [r12, #-1]!
    for (; n > 0; n--) {
  144668:	4290      	cmp	r0, r2
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  14466a:	ea83 0301 	eor.w	r3, r3, r1
  14466e:	7003      	strb	r3, [r0, #0]
    for (; n > 0; n--) {
  144670:	d1f6      	bne.n	144660 <rsa_pad_eme_oaep_decode+0x7c>
    MGF1(vce_id, hashType, EM + 1, hLen, dbMask, k - hLen - 1);
  144672:	e9cd 7400 	strd	r7, r4, [r13]
  144676:	4643      	mov	r3, r8
  144678:	980b      	ldr	r0, [sp, #44]	; 0x2c
  14467a:	4649      	mov	r1, r9
  14467c:	f7ff fe60 	bl	144340 <MGF1>
    for (; n > 0; n--) {
  144680:	b164      	cbz	r4, 14469c <rsa_pad_eme_oaep_decode+0xb8>
  144682:	9b09      	ldr	r3, [sp, #36]	; 0x24
  144684:	1929      	adds	r1, r5, r4
  144686:	443c      	add	r4, r7
  144688:	4419      	add	r1, r3
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  14468a:	f814 2d01 	ldrb.w	r2, [r4, #-1]!
  14468e:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
    for (; n > 0; n--) {
  144692:	42a7      	cmp	r7, r4
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144694:	ea83 0302 	eor.w	r3, r3, r2
  144698:	700b      	strb	r3, [r1, #0]
    for (; n > 0; n--) {
  14469a:	d1f6      	bne.n	14468a <rsa_pad_eme_oaep_decode+0xa6>
    mask(EM + hLen + 1, dbMask, k - hLen - 1);

    *mLen = 0;
  14469c:	2300      	movs	r3, #0
    size_t i = 0;

    for (i = hLen + 1; i < k; i++) {
  14469e:	42b5      	cmp	r5, r6
    *mLen = 0;
  1446a0:	9a23      	ldr	r2, [sp, #140]	; 0x8c
  1446a2:	6013      	str	r3, [r2, #0]
    for (i = hLen + 1; i < k; i++) {
  1446a4:	d20d      	bcs.n	1446c2 <rsa_pad_eme_oaep_decode+0xde>
        if (*(uint8_t*)(EM + i) == 0x01) {
  1446a6:	f89b 3000 	ldrb.w	r3, [r11]
  1446aa:	2b01      	cmp	r3, #1
  1446ac:	bf18      	it	ne
  1446ae:	465b      	movne	r3, r11
  1446b0:	d104      	bne.n	1446bc <rsa_pad_eme_oaep_decode+0xd8>
  1446b2:	e04b      	b.n	14474c <rsa_pad_eme_oaep_decode+0x168>
  1446b4:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  1446b8:	2a01      	cmp	r2, #1
  1446ba:	d047      	beq.n	14474c <rsa_pad_eme_oaep_decode+0x168>
    for (i = hLen + 1; i < k; i++) {
  1446bc:	3501      	adds	r5, #1
  1446be:	42ae      	cmp	r6, r5
  1446c0:	d8f8      	bhi.n	1446b4 <rsa_pad_eme_oaep_decode+0xd0>
  1446c2:	2203      	movs	r2, #3
            *mLen = k - i - 1;
            break;
        }
    }

    status = hash_blk(vce_id, hashType, block_t_convert(NULL, 0, 0),
  1446c4:	ac12      	add	r4, sp, #72	; 0x48
  1446c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  1446c8:	ad04      	add	r5, sp, #16
  1446ca:	9217      	str	r2, [sp, #92]	; 0x5c
  1446cc:	aa18      	add	r2, sp, #96	; 0x60
  1446ce:	9315      	str	r3, [sp, #84]	; 0x54
  1446d0:	2300      	movs	r3, #0
  1446d2:	f8cd 8058 	str.w	r8, [r13, #88]	; 0x58
  1446d6:	af0f      	add	r7, sp, #60	; 0x3c
  1446d8:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  1446dc:	9312      	str	r3, [sp, #72]	; 0x48
  1446de:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1446e2:	9313      	str	r3, [sp, #76]	; 0x4c
  1446e4:	ad01      	add	r5, sp, #4
  1446e6:	9314      	str	r3, [sp, #80]	; 0x50
  1446e8:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
  1446ec:	e9cd 330f 	strd	r3, r3, [r13, #60]	; 0x3c
  1446f0:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1446f4:	9300      	str	r3, [sp, #0]
  1446f6:	4649      	mov	r1, r9
  1446f8:	980b      	ldr	r0, [sp, #44]	; 0x2c
  1446fa:	e897 000c 	ldmia.w	r7, {r2, r3}
  1446fe:	f7ff f973 	bl	1439e8 <hash_blk>
                      block_t_convert(NULL, 0, 0), block_t_convert(seedMask, hLen, EXT_MEM));

    if (status != CRYPTOLIB_SUCCESS) {
  144702:	4604      	mov	r4, r0
  144704:	bb38      	cbnz	r0, 144756 <rsa_pad_eme_oaep_decode+0x172>
        ce_free(mem_n);
        ce_free(mem_n_1);
        return CRYPTOLIB_CRYPTO_ERR;
    }

    int chkLHash = memcmp(seedMask, EM + hLen + 1, hash_get_digest_size(hashType));
  144706:	4648      	mov	r0, r9
  144708:	f7ff f964 	bl	1439d4 <hash_get_digest_size>
  14470c:	4659      	mov	r1, r11
  14470e:	4602      	mov	r2, r0
  144710:	980a      	ldr	r0, [sp, #40]	; 0x28
  144712:	f00f fd13 	bl	15413c <memcmp>
  144716:	4605      	mov	r5, r0

    ce_free(mem_n);
  144718:	4650      	mov	r0, r10
  14471a:	f7fe ff27 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  14471e:	980c      	ldr	r0, [sp, #48]	; 0x30
  144720:	f7fe ff24 	bl	14356c <ce_free>

    if (chkLHash || *mLen == 0 || EM[0]) {
  144724:	b96d      	cbnz	r5, 144742 <rsa_pad_eme_oaep_decode+0x15e>
  144726:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  144728:	681b      	ldr	r3, [r3, #0]
  14472a:	b153      	cbz	r3, 144742 <rsa_pad_eme_oaep_decode+0x15e>
  14472c:	9909      	ldr	r1, [sp, #36]	; 0x24
  14472e:	780a      	ldrb	r2, [r1, #0]
  144730:	b93a      	cbnz	r2, 144742 <rsa_pad_eme_oaep_decode+0x15e>
        return CRYPTOLIB_CRYPTO_ERR;    // DECRYPTION_ERROR;
    }

    *message = (uint8_t*)((EM + k) - *mLen);
  144732:	1af6      	subs	r6, r6, r3
  144734:	9b22      	ldr	r3, [sp, #136]	; 0x88
  144736:	4431      	add	r1, r6
  144738:	6019      	str	r1, [r3, #0]

    return 0;
}
  14473a:	4620      	mov	r0, r4
  14473c:	b019      	add	sp, #100	; 0x64
  14473e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_CRYPTO_ERR;    // DECRYPTION_ERROR;
  144742:	2406      	movs	r4, #6
}
  144744:	4620      	mov	r0, r4
  144746:	b019      	add	sp, #100	; 0x64
  144748:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            *mLen = k - i - 1;
  14474c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
  14474e:	1b5d      	subs	r5, r3, r5
  144750:	9b23      	ldr	r3, [sp, #140]	; 0x8c
  144752:	601d      	str	r5, [r3, #0]
            break;
  144754:	e7b5      	b.n	1446c2 <rsa_pad_eme_oaep_decode+0xde>
        ce_free(mem_n);
  144756:	4650      	mov	r0, r10
        return CRYPTOLIB_CRYPTO_ERR;
  144758:	2406      	movs	r4, #6
        ce_free(mem_n);
  14475a:	f7fe ff07 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  14475e:	980c      	ldr	r0, [sp, #48]	; 0x30
  144760:	f7fe ff04 	bl	14356c <ce_free>
}
  144764:	4620      	mov	r0, r4
  144766:	b019      	add	sp, #100	; 0x64
  144768:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ce_free(mem_n);
  14476c:	4650      	mov	r0, r10
        return CRYPTOLIB_PK_N_NOTVALID;
  14476e:	2415      	movs	r4, #21
        ce_free(mem_n);
  144770:	f7fe fefc 	bl	14356c <ce_free>
}
  144774:	4620      	mov	r0, r4
  144776:	b019      	add	sp, #100	; 0x64
  144778:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

0014477c <rsa_pad_eme_pkcs_encode>:
uint32_t rsa_pad_eme_pkcs_encode(uint32_t vce_id,
                                 uint32_t k,
                                 uint8_t* EM,
                                 block_t message,
                                 size_t mLen)
{
  14477c:	b082      	sub	sp, #8
  14477e:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  144780:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    if (mLen > (size_t)(k - 11)) {
  144782:	f1a1 040b 	sub.w	r4, r1, #11
{
  144786:	9307      	str	r3, [sp, #28]
    if (mLen > (size_t)(k - 11)) {
  144788:	42bc      	cmp	r4, r7
        return CRYPTOLIB_CRYPTO_ERR;    // MESSAGE_TOO_LONG;
  14478a:	bf38      	it	cc
  14478c:	2006      	movcc	r0, #6
    if (mLen > (size_t)(k - 11)) {
  14478e:	d313      	bcc.n	1447b8 <rsa_pad_eme_pkcs_encode+0x3c>
  144790:	4615      	mov	r5, r2
    }

    //Assemply of DB
    gen_rnd_bytes(vce_id, EM + 2, k - mLen - 2, 1); //PS (first written for alignment purpose)
  144792:	1bcc      	subs	r4, r1, r7
  144794:	2301      	movs	r3, #1
  144796:	1ea2      	subs	r2, r4, #2
    EM[0] = 0x00;
  144798:	2600      	movs	r6, #0
    gen_rnd_bytes(vce_id, EM + 2, k - mLen - 2, 1); //PS (first written for alignment purpose)
  14479a:	1ca9      	adds	r1, r5, #2
  14479c:	f7ff fdae 	bl	1442fc <gen_rnd_bytes>
    EM[1] = 0x02;
  1447a0:	2302      	movs	r3, #2
    EM[0] = 0x00;
  1447a2:	702e      	strb	r6, [r5, #0]

    *((uint8_t*)(EM + k - mLen - 1)) = 0x00;
  1447a4:	442c      	add	r4, r5
    EM[1] = 0x02;
  1447a6:	706b      	strb	r3, [r5, #1]
    memcpy(EM + k - mLen, message.addr, mLen);
  1447a8:	463a      	mov	r2, r7
  1447aa:	9907      	ldr	r1, [sp, #28]
  1447ac:	4620      	mov	r0, r4
    *((uint8_t*)(EM + k - mLen - 1)) = 0x00;
  1447ae:	f804 6c01 	strb.w	r6, [r4, #-1]
    memcpy(EM + k - mLen, message.addr, mLen);
  1447b2:	f00e ebde 	blx	152f70 <memcpy>

    return CRYPTOLIB_SUCCESS;
  1447b6:	4630      	mov	r0, r6
}
  1447b8:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
  1447bc:	b002      	add	sp, #8
  1447be:	4770      	bx	r14

001447c0 <rsa_pad_eme_pkcs_decode>:

uint32_t rsa_pad_eme_pkcs_decode(uint32_t k,
                                 uint8_t* EM,
                                 uint8_t** message,
                                 size_t* mLen)
{
  1447c0:	b470      	push	{r4, r5, r6}
    *mLen = 0;
  1447c2:	2400      	movs	r4, #0
    size_t i = 0;

    for (i = 2; i < k; i++) {
  1447c4:	2802      	cmp	r0, #2
    *mLen = 0;
  1447c6:	601c      	str	r4, [r3, #0]
    for (i = 2; i < k; i++) {
  1447c8:	d90a      	bls.n	1447e0 <rsa_pad_eme_pkcs_decode+0x20>
        if (*(uint8_t*)(EM + i) == 0x00) {
  1447ca:	788c      	ldrb	r4, [r1, #2]
  1447cc:	b15c      	cbz	r4, 1447e6 <rsa_pad_eme_pkcs_decode+0x26>
    for (i = 2; i < k; i++) {
  1447ce:	2402      	movs	r4, #2
  1447d0:	1c8d      	adds	r5, r1, #2
  1447d2:	e002      	b.n	1447da <rsa_pad_eme_pkcs_decode+0x1a>
        if (*(uint8_t*)(EM + i) == 0x00) {
  1447d4:	f815 6f01 	ldrb.w	r6, [r5, #1]!
  1447d8:	b136      	cbz	r6, 1447e8 <rsa_pad_eme_pkcs_decode+0x28>
    for (i = 2; i < k; i++) {
  1447da:	3401      	adds	r4, #1
  1447dc:	42a0      	cmp	r0, r4
  1447de:	d1f9      	bne.n	1447d4 <rsa_pad_eme_pkcs_decode+0x14>
    }

    size_t PSLen = k - 3 - *mLen;

    if (*mLen == 0 || EM[0] || EM[1] != 0x02 || PSLen < 8) {
        return CRYPTOLIB_CRYPTO_ERR;    // DECRYPTION_ERROR;
  1447e0:	2006      	movs	r0, #6
    }

    *message = (uint8_t*)((EM + k) - *mLen);

    return CRYPTOLIB_SUCCESS;
}
  1447e2:	bc70      	pop	{r4, r5, r6}
  1447e4:	4770      	bx	r14
    for (i = 2; i < k; i++) {
  1447e6:	2402      	movs	r4, #2
            *mLen = k - i - 1;
  1447e8:	1e45      	subs	r5, r0, #1
  1447ea:	1b2c      	subs	r4, r5, r4
    size_t PSLen = k - 3 - *mLen;
  1447ec:	1b00      	subs	r0, r0, r4
            *mLen = k - i - 1;
  1447ee:	601c      	str	r4, [r3, #0]
    size_t PSLen = k - 3 - *mLen;
  1447f0:	1ec3      	subs	r3, r0, #3
    if (*mLen == 0 || EM[0] || EM[1] != 0x02 || PSLen < 8) {
  1447f2:	2c00      	cmp	r4, #0
  1447f4:	d0f4      	beq.n	1447e0 <rsa_pad_eme_pkcs_decode+0x20>
  1447f6:	780c      	ldrb	r4, [r1, #0]
  1447f8:	2c00      	cmp	r4, #0
  1447fa:	d1f1      	bne.n	1447e0 <rsa_pad_eme_pkcs_decode+0x20>
  1447fc:	2b07      	cmp	r3, #7
  1447fe:	784c      	ldrb	r4, [r1, #1]
  144800:	bf8c      	ite	hi
  144802:	2300      	movhi	r3, #0
  144804:	2301      	movls	r3, #1
  144806:	2c02      	cmp	r4, #2
  144808:	bf18      	it	ne
  14480a:	f043 0301 	orrne.w	r3, r3, #1
  14480e:	2b00      	cmp	r3, #0
  144810:	d1e6      	bne.n	1447e0 <rsa_pad_eme_pkcs_decode+0x20>
    *message = (uint8_t*)((EM + k) - *mLen);
  144812:	4401      	add	r1, r0
}
  144814:	bc70      	pop	{r4, r5, r6}
    *message = (uint8_t*)((EM + k) - *mLen);
  144816:	6011      	str	r1, [r2, #0]
    return CRYPTOLIB_SUCCESS;
  144818:	4618      	mov	r0, r3
}
  14481a:	4770      	bx	r14

0014481c <rsa_pad_emsa_pkcs_encode>:
uint32_t rsa_pad_emsa_pkcs_encode(uint32_t vce_id,
                                  uint32_t emLen,
                                  hash_alg_t hash_type,
                                  uint8_t* EM,
                                  uint8_t* hash)
{
  14481c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    uint8_t hashTypeDer[19] = {0x30, 0x21, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x2, 0x06, 0x05, 0x00, 0x04, 0x20};
  144820:	f245 55f4 	movw	r5, #22004	; 0x55f4
{
  144824:	4616      	mov	r6, r2
  144826:	460f      	mov	r7, r1
    uint8_t hashTypeDer[19] = {0x30, 0x21, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x2, 0x06, 0x05, 0x00, 0x04, 0x20};
  144828:	f2c0 0515 	movt	r5, #21
{
  14482c:	469c      	mov	r12, r3
  14482e:	b087      	sub	sp, #28
    uint8_t hashTypeDer[19] = {0x30, 0x21, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x2, 0x06, 0x05, 0x00, 0x04, 0x20};
  144830:	ac01      	add	r4, sp, #4
  144832:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    size_t tLen;
    size_t hLen;
    size_t dLen = 19;

    switch (hash_type) { //adapt DER encoded hashType
  144834:	3e01      	subs	r6, #1
    uint8_t hashTypeDer[19] = {0x30, 0x21, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x2, 0x06, 0x05, 0x00, 0x04, 0x20};
  144836:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  144838:	682d      	ldr	r5, [r5, #0]
  14483a:	f824 5b02 	strh.w	r5, [r4], #2
  14483e:	0c2b      	lsrs	r3, r5, #16
  144840:	7023      	strb	r3, [r4, #0]
    switch (hash_type) { //adapt DER encoded hashType
  144842:	2e04      	cmp	r6, #4
  144844:	d804      	bhi.n	144850 <rsa_pad_emsa_pkcs_encode+0x34>
  144846:	e8df f006 	tbb	[r15, r6]
  14484a:	5e37      	.short	0x5e37
  14484c:	7a6d      	.short	0x7a6d
  14484e:	07          	.byte	0x07
  14484f:	00          	.byte	0x00
    }

    tLen = hLen + dLen;

    if (emLen < tLen + 11) {
        return CRYPTOLIB_CRYPTO_ERR;    // MESSAGE_TOO_SHORT;
  144850:	2006      	movs	r0, #6
    *(uint8_t*)(EM + emLen - tLen - 1) = 0x00;
    memcpy(EM + emLen - tLen, hashTypeDer, dLen); //HashType
    memcpy(EM + emLen - hLen, hash, hLen); //Hash

    return CRYPTOLIB_SUCCESS;
}
  144852:	b007      	add	sp, #28
  144854:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
            hashTypeDer[18] = 0x40;
  144858:	2240      	movs	r2, #64	; 0x40
            hashTypeDer[1] = 0x51;
  14485a:	2051      	movs	r0, #81	; 0x51
            hashTypeDer[14] = 0x03;
  14485c:	2103      	movs	r1, #3
            hLen = 4 * 16;
  14485e:	4690      	mov	r8, r2
            break;
  144860:	2553      	movs	r5, #83	; 0x53
  144862:	235e      	movs	r3, #94	; 0x5e
            hashTypeDer[18] = 0x40;
  144864:	f88d 2016 	strb.w	r2, [r13, #22]
    size_t dLen = 19;
  144868:	f04f 0913 	mov.w	r9, #19
            hashTypeDer[1] = 0x51;
  14486c:	f88d 0005 	strb.w	r0, [r13, #5]
            hashTypeDer[14] = 0x03;
  144870:	f88d 1012 	strb.w	r1, [r13, #18]
    if (emLen < tLen + 11) {
  144874:	429f      	cmp	r7, r3
  144876:	d3eb      	bcc.n	144850 <rsa_pad_emsa_pkcs_encode+0x34>
  144878:	4664      	mov	r4, r12
    *(uint8_t*)(EM + 1) = 0x01;
  14487a:	2301      	movs	r3, #1
    *EM = 0x00;
  14487c:	2600      	movs	r6, #0
    memset((uint8_t*)(EM + 2), 0xff, emLen - tLen - 3); //PS
  14487e:	1b7d      	subs	r5, r7, r5
    *(uint8_t*)(EM + 1) = 0x01;
  144880:	f88c 3001 	strb.w	r3, [r12, #1]
    memset((uint8_t*)(EM + 2), 0xff, emLen - tLen - 3); //PS
  144884:	1eea      	subs	r2, r5, #3
    *EM = 0x00;
  144886:	f88c 6000 	strb.w	r6, [r12]
    *(uint8_t*)(EM + emLen - tLen - 1) = 0x00;
  14488a:	4425      	add	r5, r4
    memset((uint8_t*)(EM + 2), 0xff, emLen - tLen - 3); //PS
  14488c:	21ff      	movs	r1, #255	; 0xff
  14488e:	1ca0      	adds	r0, r4, #2
  144890:	f00e ebf4 	blx	15307c <memset>
    memcpy(EM + emLen - tLen, hashTypeDer, dLen); //HashType
  144894:	464a      	mov	r2, r9
  144896:	4628      	mov	r0, r5
  144898:	a901      	add	r1, sp, #4
    *(uint8_t*)(EM + emLen - tLen - 1) = 0x00;
  14489a:	f805 6c01 	strb.w	r6, [r5, #-1]
    memcpy(EM + emLen - hLen, hash, hLen); //Hash
  14489e:	eba7 0708 	sub.w	r7, r7, r8
    memcpy(EM + emLen - tLen, hashTypeDer, dLen); //HashType
  1448a2:	f00e eb66 	blx	152f70 <memcpy>
    memcpy(EM + emLen - hLen, hash, hLen); //Hash
  1448a6:	4642      	mov	r2, r8
  1448a8:	990e      	ldr	r1, [sp, #56]	; 0x38
  1448aa:	19e0      	adds	r0, r4, r7
  1448ac:	f00e eb60 	blx	152f70 <memcpy>
    return CRYPTOLIB_SUCCESS;
  1448b0:	4630      	mov	r0, r6
}
  1448b2:	b007      	add	sp, #28
  1448b4:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
            hashTypeDer[3] = 0x09;
  1448b8:	2109      	movs	r1, #9
            hashTypeDer[6] = 0x2b;
  1448ba:	222b      	movs	r2, #43	; 0x2b
            hashTypeDer[5] = 0x05;
  1448bc:	2305      	movs	r3, #5
            hashTypeDer[9] = 0x02;
  1448be:	2502      	movs	r5, #2
            hashTypeDer[7] = 0x0e;
  1448c0:	f04f 0e0e 	mov.w	r14, #14
            hashTypeDer[8] = 0x03;
  1448c4:	2603      	movs	r6, #3
            hashTypeDer[3] = 0x09;
  1448c6:	f88d 1007 	strb.w	r1, [r13, #7]
            hashTypeDer[10] = 0x1a;
  1448ca:	241a      	movs	r4, #26
            hashTypeDer[12] = 0x00;
  1448cc:	2000      	movs	r0, #0
            hashTypeDer[13] = 0x04;
  1448ce:	2104      	movs	r1, #4
            hashTypeDer[6] = 0x2b;
  1448d0:	f88d 200a 	strb.w	r2, [r13, #10]
            hashTypeDer[14] = 0x14;
  1448d4:	2214      	movs	r2, #20
            hashTypeDer[5] = 0x05;
  1448d6:	f88d 3009 	strb.w	r3, [r13, #9]
            hLen = 20;
  1448da:	4690      	mov	r8, r2
            hashTypeDer[11] = 0x05;
  1448dc:	f88d 300f 	strb.w	r3, [r13, #15]
            dLen = 15;
  1448e0:	f04f 090f 	mov.w	r9, #15
            hashTypeDer[9] = 0x02;
  1448e4:	f88d 500d 	strb.w	r5, [r13, #13]
            break;
  1448e8:	232e      	movs	r3, #46	; 0x2e
            hashTypeDer[7] = 0x0e;
  1448ea:	f88d e00b 	strb.w	r14, [r13, #11]
            break;
  1448ee:	2523      	movs	r5, #35	; 0x23
            hashTypeDer[8] = 0x03;
  1448f0:	f88d 600c 	strb.w	r6, [r13, #12]
            hashTypeDer[10] = 0x1a;
  1448f4:	f88d 400e 	strb.w	r4, [r13, #14]
            hashTypeDer[12] = 0x00;
  1448f8:	f88d 0010 	strb.w	r0, [r13, #16]
            hashTypeDer[13] = 0x04;
  1448fc:	f88d 1011 	strb.w	r1, [r13, #17]
            hashTypeDer[14] = 0x14;
  144900:	f88d 2012 	strb.w	r2, [r13, #18]
            break;
  144904:	e7b6      	b.n	144874 <rsa_pad_emsa_pkcs_encode+0x58>
            hashTypeDer[14] = 0x04;
  144906:	2304      	movs	r3, #4
            hashTypeDer[18] = 0x1c;
  144908:	221c      	movs	r2, #28
            hashTypeDer[1] = 0x2d;
  14490a:	212d      	movs	r1, #45	; 0x2d
            break;
  14490c:	252f      	movs	r5, #47	; 0x2f
            hashTypeDer[14] = 0x04;
  14490e:	f88d 3012 	strb.w	r3, [r13, #18]
            hLen = 28;
  144912:	4690      	mov	r8, r2
            hashTypeDer[1] = 0x2d;
  144914:	f88d 1005 	strb.w	r1, [r13, #5]
            break;
  144918:	233a      	movs	r3, #58	; 0x3a
            hashTypeDer[18] = 0x1c;
  14491a:	f88d 2016 	strb.w	r2, [r13, #22]
    size_t dLen = 19;
  14491e:	f04f 0913 	mov.w	r9, #19
            break;
  144922:	e7a7      	b.n	144874 <rsa_pad_emsa_pkcs_encode+0x58>
            hashTypeDer[1] = 0x31;
  144924:	2131      	movs	r1, #49	; 0x31
            hashTypeDer[14] = 0x01;
  144926:	2201      	movs	r2, #1
            break;
  144928:	2533      	movs	r5, #51	; 0x33
  14492a:	233e      	movs	r3, #62	; 0x3e
            hashTypeDer[1] = 0x31;
  14492c:	f88d 1005 	strb.w	r1, [r13, #5]
    size_t dLen = 19;
  144930:	f04f 0913 	mov.w	r9, #19
            hashTypeDer[14] = 0x01;
  144934:	f88d 2012 	strb.w	r2, [r13, #18]
            hLen = 32;
  144938:	f04f 0820 	mov.w	r8, #32
            break;
  14493c:	e79a      	b.n	144874 <rsa_pad_emsa_pkcs_encode+0x58>
            hashTypeDer[14] = 0x02;
  14493e:	2302      	movs	r3, #2
            hashTypeDer[18] = 0x30;
  144940:	2230      	movs	r2, #48	; 0x30
            hashTypeDer[1] = 0x41;
  144942:	2141      	movs	r1, #65	; 0x41
            break;
  144944:	2543      	movs	r5, #67	; 0x43
            hashTypeDer[14] = 0x02;
  144946:	f88d 3012 	strb.w	r3, [r13, #18]
            hLen = 4 * 12;
  14494a:	4690      	mov	r8, r2
            hashTypeDer[1] = 0x41;
  14494c:	f88d 1005 	strb.w	r1, [r13, #5]
            break;
  144950:	234e      	movs	r3, #78	; 0x4e
            hashTypeDer[18] = 0x30;
  144952:	f88d 2016 	strb.w	r2, [r13, #22]
    size_t dLen = 19;
  144956:	f04f 0913 	mov.w	r9, #19
            break;
  14495a:	e78b      	b.n	144874 <rsa_pad_emsa_pkcs_encode+0x58>

0014495c <rsa_pad_emsa_pss_encode>:
                                 hash_alg_t hashType,
                                 uint8_t* EM,
                                 uint8_t* hash,
                                 uint32_t n0,
                                 size_t sLen)
{
  14495c:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  144960:	4681      	mov	r9, r0
  144962:	b099      	sub	sp, #100	; 0x64
    struct mem_node* mem_n;
    uint8_t* tempm;
    struct mem_node* mem_n_1;
    size_t hLen;

    hLen = hash_get_digest_size(hashType);
  144964:	4610      	mov	r0, r2
{
  144966:	4616      	mov	r6, r2
  144968:	4688      	mov	r8, r1
  14496a:	461d      	mov	r5, r3
    hLen = hash_get_digest_size(hashType);
  14496c:	f7ff f832 	bl	1439d4 <hash_get_digest_size>

    if (!hLen) {
  144970:	2800      	cmp	r0, #0
  144972:	f000 80a7 	beq.w	144ac4 <rsa_pad_emsa_pss_encode+0x168>
        return CRYPTOLIB_CRYPTO_ERR;    // HASH_TYPE_ERROR;
    }

    if (emLen < sLen + hLen + 2) {
  144976:	9b24      	ldr	r3, [sp, #144]	; 0x90
  144978:	4604      	mov	r4, r0
  14497a:	18c3      	adds	r3, r0, r3
  14497c:	9308      	str	r3, [sp, #32]
  14497e:	3302      	adds	r3, #2
  144980:	4543      	cmp	r3, r8
  144982:	f200 809f 	bhi.w	144ac4 <rsa_pad_emsa_pss_encode+0x168>
        return CRYPTOLIB_CRYPTO_ERR;    // ENCODING_ERROR;
    }

    mem_n = ce_malloc(RSA_MAX_SIZE);
  144986:	f44f 7000 	mov.w	r0, #512	; 0x200

    if (mem_n != NULL) {
        dbMask = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  14498a:	2715      	movs	r7, #21
    mem_n = ce_malloc(RSA_MAX_SIZE);
  14498c:	f7fe fdaa 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  144990:	4682      	mov	r10, r0
  144992:	2800      	cmp	r0, #0
  144994:	f000 8097 	beq.w	144ac6 <rsa_pad_emsa_pss_encode+0x16a>
        dbMask = mem_n->ptr;
  144998:	f8da 3008 	ldr.w	r3, [r10, #8]
    }

    mem_n_1 = ce_malloc(128);
  14499c:	2080      	movs	r0, #128	; 0x80
        dbMask = mem_n->ptr;
  14499e:	930d      	str	r3, [sp, #52]	; 0x34
    mem_n_1 = ce_malloc(128);
  1449a0:	f7fe fda0 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  1449a4:	4683      	mov	r11, r0
  1449a6:	2800      	cmp	r0, #0
  1449a8:	f000 8099 	beq.w	144ade <rsa_pad_emsa_pss_encode+0x182>
    else {
        ce_free(mem_n);
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    memset(EM, 0x00, emLen - sLen - hLen - 2); //PS
  1449ac:	9b24      	ldr	r3, [sp, #144]	; 0x90
  1449ae:	2100      	movs	r1, #0
  1449b0:	4628      	mov	r0, r5
  1449b2:	f108 37ff 	add.w	r7, r8, #4294967295	; 0xffffffff
  1449b6:	eba8 0303 	sub.w	r3, r8, r3
        tempm = mem_n_1->ptr;
  1449ba:	f8db 8008 	ldr.w	r8, [r11, #8]
    memset(EM, 0x00, emLen - sLen - hLen - 2); //PS
  1449be:	1b1b      	subs	r3, r3, r4
  1449c0:	1e9a      	subs	r2, r3, #2
  1449c2:	9309      	str	r3, [sp, #36]	; 0x24
  1449c4:	920c      	str	r2, [sp, #48]	; 0x30
  1449c6:	f00e eb5a 	blx	15307c <memset>
    gen_rnd_bytes(vce_id, (uint8_t*)(EM + emLen - sLen - hLen - 1), sLen, 0); //Salt
  1449ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
  1449cc:	4648      	mov	r0, r9
    memcpy(tempm, zeros, 8);
    memcpy(tempm + 8, hash, hLen);
    memcpy(tempm + 8 + hLen, (EM + emLen - (sLen + hLen) - 1), sLen);
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
                      block_t_convert(tempm, 8 + hLen + sLen, EXT_MEM),
                      block_t_convert((uint8_t*)(EM + emLen - hLen - 1), hLen, EXT_MEM));
  1449ce:	970a      	str	r7, [sp, #40]	; 0x28
  1449d0:	1b3f      	subs	r7, r7, r4
    gen_rnd_bytes(vce_id, (uint8_t*)(EM + emLen - sLen - hLen - 1), sLen, 0); //Salt
  1449d2:	9a24      	ldr	r2, [sp, #144]	; 0x90
  1449d4:	1e59      	subs	r1, r3, #1
  1449d6:	2300      	movs	r3, #0
  1449d8:	4429      	add	r1, r5
                      block_t_convert((uint8_t*)(EM + emLen - hLen - 1), hLen, EXT_MEM));
  1449da:	970b      	str	r7, [sp, #44]	; 0x2c
    gen_rnd_bytes(vce_id, (uint8_t*)(EM + emLen - sLen - hLen - 1), sLen, 0); //Salt
  1449dc:	f7ff fc8e 	bl	1442fc <gen_rnd_bytes>
    memcpy(tempm, zeros, 8);
  1449e0:	f245 735c 	movw	r3, #22364	; 0x575c
                      block_t_convert((uint8_t*)(EM + emLen - hLen - 1), hLen, EXT_MEM));
  1449e4:	19e8      	adds	r0, r5, r7
    *((uint8_t*)(EM + emLen - sLen - hLen - 2)) = 0x01; //0x01
  1449e6:	2101      	movs	r1, #1
    memcpy(tempm, zeros, 8);
  1449e8:	f2c0 0315 	movt	r3, #21
                      block_t_convert((uint8_t*)(EM + emLen - hLen - 1), hLen, EXT_MEM));
  1449ec:	9009      	str	r0, [sp, #36]	; 0x24
    memcpy(tempm + 8, hash, hLen);
  1449ee:	4622      	mov	r2, r4
    *((uint8_t*)(EM + emLen - sLen - hLen - 2)) = 0x01; //0x01
  1449f0:	980c      	ldr	r0, [sp, #48]	; 0x30
  1449f2:	5429      	strb	r1, [r5, r0]
    memcpy(tempm, zeros, 8);
  1449f4:	cb03      	ldmia	r3!, {r0, r1}
  1449f6:	f8c8 0000 	str.w	r0, [r8]
    memcpy(tempm + 8, hash, hLen);
  1449fa:	f108 0008 	add.w	r0, r8, #8
    memcpy(tempm, zeros, 8);
  1449fe:	f8c8 1004 	str.w	r1, [r8, #4]
    memcpy(tempm + 8, hash, hLen);
  144a02:	9922      	ldr	r1, [sp, #136]	; 0x88
  144a04:	f00e eab4 	blx	152f70 <memcpy>
    memcpy(tempm + 8 + hLen, (EM + emLen - (sLen + hLen) - 1), sLen);
  144a08:	9f0a      	ldr	r7, [sp, #40]	; 0x28
  144a0a:	9b08      	ldr	r3, [sp, #32]
  144a0c:	f104 0008 	add.w	r0, r4, #8
  144a10:	9a24      	ldr	r2, [sp, #144]	; 0x90
  144a12:	4440      	add	r0, r8
  144a14:	1af9      	subs	r1, r7, r3
  144a16:	4429      	add	r1, r5
  144a18:	f00e eaaa 	blx	152f70 <memcpy>
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  144a1c:	9f08      	ldr	r7, [sp, #32]
  144a1e:	2203      	movs	r2, #3
  144a20:	ab12      	add	r3, sp, #72	; 0x48
  144a22:	9809      	ldr	r0, [sp, #36]	; 0x24
  144a24:	3708      	adds	r7, #8
  144a26:	9217      	str	r2, [sp, #92]	; 0x5c
  144a28:	f10d 0c10 	add.w	r12, r13, #16
  144a2c:	e9cd 7213 	strd	r7, r2, [r13, #76]	; 0x4c
  144a30:	aa18      	add	r2, sp, #96	; 0x60
  144a32:	9416      	str	r4, [sp, #88]	; 0x58
  144a34:	f10d 0e3c 	add.w	r14, r13, #60	; 0x3c
  144a38:	9015      	str	r0, [sp, #84]	; 0x54
  144a3a:	2700      	movs	r7, #0
  144a3c:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  144a40:	f8cd 8048 	str.w	r8, [r13, #72]	; 0x48
  144a44:	f10d 0804 	add.w	r8, r13, #4
  144a48:	e88c 0007 	stmia.w	r12, {r0, r1, r2}
  144a4c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  144a50:	e888 0007 	stmia.w	r8, {r0, r1, r2}
  144a54:	970f      	str	r7, [sp, #60]	; 0x3c
  144a56:	4649      	mov	r1, r9
  144a58:	9710      	str	r7, [sp, #64]	; 0x40
  144a5a:	4630      	mov	r0, r6
  144a5c:	9700      	str	r7, [sp, #0]
  144a5e:	9711      	str	r7, [sp, #68]	; 0x44
  144a60:	e89e 000c 	ldmia.w	r14, {r2, r3}
  144a64:	f7fe ffc0 	bl	1439e8 <hash_blk>

    if (status != CRYPTOLIB_SUCCESS) {
  144a68:	4607      	mov	r7, r0
  144a6a:	bb80      	cbnz	r0, 144ace <rsa_pad_emsa_pss_encode+0x172>
        ce_free(mem_n);
        ce_free(mem_n_1);
        return CRYPTOLIB_CRYPTO_ERR;    // ENCODING_ERROR;
    }

    MGF1(vce_id, hashType, EM + emLen - hLen - 1, hLen, dbMask, emLen - hLen - 1);
  144a6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  144a6e:	4631      	mov	r1, r6
  144a70:	9301      	str	r3, [sp, #4]
  144a72:	4623      	mov	r3, r4
  144a74:	9e09      	ldr	r6, [sp, #36]	; 0x24
  144a76:	4648      	mov	r0, r9
  144a78:	9c0d      	ldr	r4, [sp, #52]	; 0x34
  144a7a:	4632      	mov	r2, r6
  144a7c:	9400      	str	r4, [sp, #0]
  144a7e:	f7ff fc5f 	bl	144340 <MGF1>
    for (; n > 0; n--) {
  144a82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  144a84:	b15b      	cbz	r3, 144a9e <rsa_pad_emsa_pss_encode+0x142>
  144a86:	4631      	mov	r1, r6
  144a88:	441c      	add	r4, r3
  144a8a:	4620      	mov	r0, r4
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144a8c:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
  144a90:	f810 2d01 	ldrb.w	r2, [r0, #-1]!
    for (; n > 0; n--) {
  144a94:	428d      	cmp	r5, r1
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144a96:	ea83 0302 	eor.w	r3, r3, r2
  144a9a:	700b      	strb	r3, [r1, #0]
    for (; n > 0; n--) {
  144a9c:	d1f6      	bne.n	144a8c <rsa_pad_emsa_pss_encode+0x130>
    mask(EM, dbMask, emLen - hLen - 1);

    EM[emLen - 1] = 0xBC;
  144a9e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  144aa0:	23bc      	movs	r3, #188	; 0xbc
    EM[0] = EM[0] & getFirstMask(n0);
  144aa2:	9823      	ldr	r0, [sp, #140]	; 0x8c
    EM[emLen - 1] = 0xBC;
  144aa4:	54ab      	strb	r3, [r5, r2]
    EM[0] = EM[0] & getFirstMask(n0);
  144aa6:	f7ff fcc3 	bl	144430 <getFirstMask>
  144aaa:	782b      	ldrb	r3, [r5, #0]
  144aac:	4003      	ands	r3, r0

    ce_free(mem_n);
  144aae:	4650      	mov	r0, r10
    EM[0] = EM[0] & getFirstMask(n0);
  144ab0:	702b      	strb	r3, [r5, #0]
    ce_free(mem_n);
  144ab2:	f7fe fd5b 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  144ab6:	4658      	mov	r0, r11
  144ab8:	f7fe fd58 	bl	14356c <ce_free>
    return 0;
}
  144abc:	4638      	mov	r0, r7
  144abe:	b019      	add	sp, #100	; 0x64
  144ac0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_CRYPTO_ERR;    // HASH_TYPE_ERROR;
  144ac4:	2706      	movs	r7, #6
}
  144ac6:	4638      	mov	r0, r7
  144ac8:	b019      	add	sp, #100	; 0x64
  144aca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        ce_free(mem_n);
  144ace:	4650      	mov	r0, r10
        return CRYPTOLIB_CRYPTO_ERR;    // ENCODING_ERROR;
  144ad0:	2706      	movs	r7, #6
        ce_free(mem_n);
  144ad2:	f7fe fd4b 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  144ad6:	4658      	mov	r0, r11
  144ad8:	f7fe fd48 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;    // ENCODING_ERROR;
  144adc:	e7f3      	b.n	144ac6 <rsa_pad_emsa_pss_encode+0x16a>
        ce_free(mem_n);
  144ade:	4650      	mov	r0, r10
        return CRYPTOLIB_PK_N_NOTVALID;
  144ae0:	2715      	movs	r7, #21
        ce_free(mem_n);
  144ae2:	f7fe fd43 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  144ae6:	e7ee      	b.n	144ac6 <rsa_pad_emsa_pss_encode+0x16a>

00144ae8 <rsa_pad_emsa_pss_decode>:
                                 hash_alg_t hashType,
                                 uint8_t* EM,
                                 uint8_t* hash,
                                 uint32_t sLen,
                                 uint32_t n0)
{
  144ae8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  144aec:	4682      	mov	r10, r0
  144aee:	b097      	sub	sp, #92	; 0x5c
    struct mem_node* mem_n;
    uint8_t* hash_in;
    struct mem_node* mem_n_1;
    size_t hLen;

    hLen = hash_get_digest_size(hashType);
  144af0:	4610      	mov	r0, r2
{
  144af2:	460c      	mov	r4, r1
  144af4:	461d      	mov	r5, r3
  144af6:	4617      	mov	r7, r2
    hLen = hash_get_digest_size(hashType);
  144af8:	f7fe ff6c 	bl	1439d4 <hash_get_digest_size>

    /* 3.  If emLen < hLen + sLen + 2, output "inconsistent" and stop. */
    /* 4.  If the rightmost octet of EM does not have hexadecimal value
        0xbc, output "inconsistent" and stop. */
    if (emLen < hLen + sLen + 2 || EM[emLen - 1] != 0xbc) {
  144afc:	9b21      	ldr	r3, [sp, #132]	; 0x84
  144afe:	eb00 0903 	add.w	r9, r0, r3
  144b02:	f109 0302 	add.w	r3, r9, #2
  144b06:	42a3      	cmp	r3, r4
  144b08:	d856      	bhi.n	144bb8 <rsa_pad_emsa_pss_decode+0xd0>
  144b0a:	192b      	adds	r3, r5, r4
  144b0c:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  144b10:	2bbc      	cmp	r3, #188	; 0xbc
  144b12:	d151      	bne.n	144bb8 <rsa_pad_emsa_pss_decode+0xd0>
  144b14:	4606      	mov	r6, r0
    }

    /* 5.  Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and
        let H be the next hLen octets. */
    maskedDB = EM;
    dbLen = emLen - hLen - 1;
  144b16:	1a24      	subs	r4, r4, r0
  144b18:	f104 38ff 	add.w	r8, r4, #4294967295	; 0xffffffff
  144b1c:	eb00 0108 	add.w	r1, r0, r8

    /* 7.  Let dbMask = MGF(H, emLen - hLen - 1). */
    //This buffer is later reused to store H'

    mlen = emLen - hLen - 1;
    mlen = mlen + ((mlen % hLen) ? hLen - (mlen % hLen) : 0);
  144b20:	fbb8 f3f0 	udiv	r3, r8, r0
  144b24:	fb00 8313 	mls	r3, r0, r3, r8
  144b28:	1ac9      	subs	r1, r1, r3
  144b2a:	2b00      	cmp	r3, #0
  144b2c:	d049      	beq.n	144bc2 <rsa_pad_emsa_pss_decode+0xda>

    if (mlen > RSA_MAX_SIZE) {
  144b2e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  144b32:	d84a      	bhi.n	144bca <rsa_pad_emsa_pss_decode+0xe2>
  144b34:	9109      	str	r1, [sp, #36]	; 0x24
        dprintf(CRITICAL, "size of mask is too big.\n");
        return CRYPTOLIB_CRYPTO_ERR;
    }

    mem_n = ce_malloc(RSA_MAX_SIZE);
  144b36:	f44f 7000 	mov.w	r0, #512	; 0x200
  144b3a:	f7fe fcd3 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  144b3e:	4683      	mov	r11, r0
  144b40:	2800      	cmp	r0, #0
  144b42:	d04d      	beq.n	144be0 <rsa_pad_emsa_pss_decode+0xf8>
        dbMask = mem_n->ptr;
  144b44:	6883      	ldr	r3, [r0, #8]
    H = EM + emLen - hLen - 1;
  144b46:	eb05 0208 	add.w	r2, r5, r8
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    MGF1(vce_id, hashType, H, hLen, dbMask, mlen);
  144b4a:	9909      	ldr	r1, [sp, #36]	; 0x24
  144b4c:	4650      	mov	r0, r10
  144b4e:	e9cd 320a 	strd	r3, r2, [r13, #40]	; 0x28
  144b52:	9300      	str	r3, [sp, #0]
  144b54:	4633      	mov	r3, r6
  144b56:	9101      	str	r1, [sp, #4]
  144b58:	4639      	mov	r1, r7
  144b5a:	f7ff fbf1 	bl	144340 <MGF1>
    for (; n > 0; n--) {
  144b5e:	f1b8 0f00 	cmp.w	r8, #0
  144b62:	d00c      	beq.n	144b7e <rsa_pad_emsa_pss_decode+0x96>
  144b64:	e9dd 310a 	ldrd	r3, r1, [r13, #40]	; 0x28
  144b68:	eb03 0008 	add.w	r0, r3, r8
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144b6c:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
  144b70:	f810 2d01 	ldrb.w	r2, [r0, #-1]!
    for (; n > 0; n--) {
  144b74:	42a9      	cmp	r1, r5
        buff[n - 1] = buff[n - 1] ^ mask[n - 1];
  144b76:	ea83 0302 	eor.w	r3, r3, r2
  144b7a:	700b      	strb	r3, [r1, #0]
    for (; n > 0; n--) {
  144b7c:	d1f6      	bne.n	144b6c <rsa_pad_emsa_pss_decode+0x84>
    mask(maskedDB, dbMask, emLen - hLen - 1);
    //from here maskedDB = RFC's DB
    uint8_t* DB = maskedDB;
    /* 9.  Set the leftmost 8emLen - emBits bits of the leftmost octet in DB
           to zero. */
    DB[0] = DB[0] & getFirstMask(n0);
  144b7e:	9822      	ldr	r0, [sp, #136]	; 0x88
  144b80:	f7ff fc56 	bl	144430 <getFirstMask>

    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero
        or if the octet at position emLen - hLen - sLen - 1 (the leftmost
        position is "position 1") does not have hexadecimal value 0x01,
        output "inconsistent" and stop. */
    for (size_t i = 1; i < (emLen - hLen - sLen - 2); i++) {
  144b84:	9b21      	ldr	r3, [sp, #132]	; 0x84
  144b86:	1ae4      	subs	r4, r4, r3
    DB[0] = DB[0] & getFirstMask(n0);
  144b88:	782b      	ldrb	r3, [r5, #0]
    for (size_t i = 1; i < (emLen - hLen - sLen - 2); i++) {
  144b8a:	f1a4 0c02 	sub.w	r12, r4, #2
  144b8e:	f1bc 0f01 	cmp.w	r12, #1
    DB[0] = DB[0] & getFirstMask(n0);
  144b92:	ea00 0003 	and.w	r0, r0, r3
  144b96:	7028      	strb	r0, [r5, #0]
    for (size_t i = 1; i < (emLen - hLen - sLen - 2); i++) {
  144b98:	d90a      	bls.n	144bb0 <rsa_pad_emsa_pss_decode+0xc8>
        if (*(uint8_t*)(DB + i)) {
  144b9a:	786b      	ldrb	r3, [r5, #1]
  144b9c:	b963      	cbnz	r3, 144bb8 <rsa_pad_emsa_pss_decode+0xd0>
  144b9e:	1eeb      	subs	r3, r5, #3
  144ba0:	441c      	add	r4, r3
  144ba2:	1c6b      	adds	r3, r5, #1
  144ba4:	e002      	b.n	144bac <rsa_pad_emsa_pss_decode+0xc4>
  144ba6:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  144baa:	b92a      	cbnz	r2, 144bb8 <rsa_pad_emsa_pss_decode+0xd0>
    for (size_t i = 1; i < (emLen - hLen - sLen - 2); i++) {
  144bac:	42a3      	cmp	r3, r4
  144bae:	d1fa      	bne.n	144ba6 <rsa_pad_emsa_pss_decode+0xbe>
            return CRYPTOLIB_CRYPTO_ERR; // INCONSISTENT; //Check padding 0x00
        }
    }

    if (*(uint8_t*)(DB + emLen - hLen - sLen - 2) != 0x01) {
  144bb0:	f815 300c 	ldrb.w	r3, [r5, r12]
  144bb4:	2b01      	cmp	r3, #1
  144bb6:	d015      	beq.n	144be4 <rsa_pad_emsa_pss_decode+0xfc>
        return CRYPTOLIB_CRYPTO_ERR;    // INCONSISTENT;
  144bb8:	2506      	movs	r5, #6
    }

    ce_free(mem_n);
    ce_free(mem_n_1);
    return CRYPTOLIB_SUCCESS;
}
  144bba:	4628      	mov	r0, r5
  144bbc:	b017      	add	sp, #92	; 0x5c
  144bbe:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    dbLen = emLen - hLen - 1;
  144bc2:	4641      	mov	r1, r8
    if (mlen > RSA_MAX_SIZE) {
  144bc4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  144bc8:	d9b4      	bls.n	144b34 <rsa_pad_emsa_pss_decode+0x4c>
        dprintf(CRITICAL, "size of mask is too big.\n");
  144bca:	f245 7040 	movw	r0, #22336	; 0x5740
        return CRYPTOLIB_CRYPTO_ERR;
  144bce:	2506      	movs	r5, #6
        dprintf(CRITICAL, "size of mask is too big.\n");
  144bd0:	f2c0 0015 	movt	r0, #21
  144bd4:	f00f fa90 	bl	1540f8 <_printf>
}
  144bd8:	4628      	mov	r0, r5
  144bda:	b017      	add	sp, #92	; 0x5c
  144bdc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_PK_N_NOTVALID;
  144be0:	2515      	movs	r5, #21
  144be2:	e7ea      	b.n	144bba <rsa_pad_emsa_pss_decode+0xd2>
    salt = DB + dbLen - sLen;
  144be4:	9b21      	ldr	r3, [sp, #132]	; 0x84
    mem_n_1 = ce_malloc(128);
  144be6:	2080      	movs	r0, #128	; 0x80
    salt = DB + dbLen - sLen;
  144be8:	eba8 0803 	sub.w	r8, r8, r3
    mem_n_1 = ce_malloc(128);
  144bec:	f7fe fc7a 	bl	1434e4 <ce_malloc>
    salt = DB + dbLen - sLen;
  144bf0:	4445      	add	r5, r8
    if (mem_n_1 != NULL) {
  144bf2:	4604      	mov	r4, r0
  144bf4:	2800      	cmp	r0, #0
  144bf6:	d052      	beq.n	144c9e <rsa_pad_emsa_pss_decode+0x1b6>
    memcpy(hash_in, zeros, 8);
  144bf8:	f245 735c 	movw	r3, #22364	; 0x575c
    memcpy(hash_in + 8, hash, hLen);
  144bfc:	4632      	mov	r2, r6
        hash_in = mem_n_1->ptr;
  144bfe:	f8d0 8008 	ldr.w	r8, [r0, #8]
    memcpy(hash_in, zeros, 8);
  144c02:	f2c0 0315 	movt	r3, #21
  144c06:	cb03      	ldmia	r3!, {r0, r1}
  144c08:	f8c8 0000 	str.w	r0, [r8]
    memcpy(hash_in + 8, hash, hLen);
  144c0c:	f108 0008 	add.w	r0, r8, #8
    memcpy(hash_in, zeros, 8);
  144c10:	f8c8 1004 	str.w	r1, [r8, #4]
    memcpy(hash_in + 8, hash, hLen);
  144c14:	9920      	ldr	r1, [sp, #128]	; 0x80
  144c16:	f00e e9ac 	blx	152f70 <memcpy>
    memcpy(hash_in + 8 + hLen, salt, sLen);
  144c1a:	4629      	mov	r1, r5
  144c1c:	9a21      	ldr	r2, [sp, #132]	; 0x84
  144c1e:	f106 0008 	add.w	r0, r6, #8
  144c22:	2503      	movs	r5, #3
  144c24:	4440      	add	r0, r8
  144c26:	f00e e9a4 	blx	152f70 <memcpy>
  144c2a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    status = hash_blk(hashType, vce_id, block_t_convert(NULL, 0, 0),
  144c2c:	aa16      	add	r2, sp, #88	; 0x58
  144c2e:	9313      	str	r3, [sp, #76]	; 0x4c
  144c30:	f10d 0e40 	add.w	r14, r13, #64	; 0x40
  144c34:	9515      	str	r5, [sp, #84]	; 0x54
  144c36:	f109 0308 	add.w	r3, r9, #8
  144c3a:	9614      	str	r6, [sp, #80]	; 0x50
  144c3c:	f10d 0c10 	add.w	r12, r13, #16
  144c40:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  144c44:	e9cd 8310 	strd	r8, r3, [r13, #64]	; 0x40
  144c48:	f10d 0934 	add.w	r9, r13, #52	; 0x34
  144c4c:	9512      	str	r5, [sp, #72]	; 0x48
  144c4e:	ab01      	add	r3, sp, #4
  144c50:	e88c 0007 	stmia.w	r12, {r0, r1, r2}
  144c54:	2500      	movs	r5, #0
  144c56:	e89e 0007 	ldmia.w	r14, {r0, r1, r2}
  144c5a:	950d      	str	r5, [sp, #52]	; 0x34
  144c5c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  144c60:	950e      	str	r5, [sp, #56]	; 0x38
  144c62:	4651      	mov	r1, r10
  144c64:	9500      	str	r5, [sp, #0]
  144c66:	4638      	mov	r0, r7
  144c68:	e899 000c 	ldmia.w	r9, {r2, r3}
  144c6c:	f7fe febc 	bl	1439e8 <hash_blk>
    if (status != CRYPTOLIB_SUCCESS) {
  144c70:	4605      	mov	r5, r0
  144c72:	b960      	cbnz	r0, 144c8e <rsa_pad_emsa_pss_decode+0x1a6>
    chkLHash = memcmp(H, H_, hLen);
  144c74:	e9dd 100a 	ldrd	r1, r0, [r13, #40]	; 0x28
  144c78:	4632      	mov	r2, r6
  144c7a:	f00f fa5f 	bl	15413c <memcmp>
    if (chkLHash) {
  144c7e:	b930      	cbnz	r0, 144c8e <rsa_pad_emsa_pss_decode+0x1a6>
    ce_free(mem_n);
  144c80:	4658      	mov	r0, r11
  144c82:	f7fe fc73 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  144c86:	4620      	mov	r0, r4
  144c88:	f7fe fc70 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
  144c8c:	e795      	b.n	144bba <rsa_pad_emsa_pss_decode+0xd2>
        ce_free(mem_n);
  144c8e:	4658      	mov	r0, r11
        return CRYPTOLIB_CRYPTO_ERR; // INCONSISTENT;
  144c90:	2506      	movs	r5, #6
        ce_free(mem_n);
  144c92:	f7fe fc6b 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  144c96:	4620      	mov	r0, r4
  144c98:	f7fe fc68 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR; // INCONSISTENT;
  144c9c:	e78d      	b.n	144bba <rsa_pad_emsa_pss_decode+0xd2>
        ce_free(mem_n);
  144c9e:	4658      	mov	r0, r11
        return CRYPTOLIB_PK_N_NOTVALID;
  144ca0:	2515      	movs	r5, #21
        ce_free(mem_n);
  144ca2:	f7fe fc63 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  144ca6:	e788      	b.n	144bba <rsa_pad_emsa_pss_decode+0xd2>

00144ca8 <rsa_pad_zeros>:

void rsa_pad_zeros(uint8_t* EM,
                   size_t emLen,
                   uint8_t* hash,
                   size_t hashLen)
{
  144ca8:	b570      	push	{r4, r5, r6, r14}
  144caa:	461c      	mov	r4, r3
    memset(EM, 0x00, emLen - hashLen);
  144cac:	1acd      	subs	r5, r1, r3
{
  144cae:	4616      	mov	r6, r2
    memset(EM, 0x00, emLen - hashLen);
  144cb0:	2100      	movs	r1, #0
  144cb2:	462a      	mov	r2, r5
  144cb4:	f00e e9e2 	blx	15307c <memset>

    if (hashLen) {
  144cb8:	b904      	cbnz	r4, 144cbc <rsa_pad_zeros+0x14>
        memcpy(EM + emLen - hashLen, hash, hashLen);
    }
}
  144cba:	bd70      	pop	{r4, r5, r6, r15}
        memcpy(EM + emLen - hashLen, hash, hashLen);
  144cbc:	4622      	mov	r2, r4
  144cbe:	4631      	mov	r1, r6
  144cc0:	4428      	add	r0, r5
}
  144cc2:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        memcpy(EM + emLen - hashLen, hash, hashLen);
  144cc6:	f00f bf03 	b.w	154ad0 <__memcpy_from_thumb>
  144cca:	bf00      	nop

00144ccc <cryptodma_config>:
#include <sram_conf.h>

#define LOCAL_TRACE 0 //close local trace 1->0

void cryptodma_config(uint32_t vce_id, block_t dst, block_t src, uint32_t length)
{
  144ccc:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  144cd0:	4680      	mov	r8, r0
  144cd2:	b085      	sub	sp, #20
  144cd4:	ac04      	add	r4, sp, #16
  144cd6:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
  144cd8:	e904 000e 	stmdb	r4, {r1, r2, r3}
    uint32_t value;
    uint32_t transfer_len = dst.len < length ? dst.len : length;
  144cdc:	9b02      	ldr	r3, [sp, #8]
  144cde:	0304      	lsls	r4, r0, #12
  144ce0:	9f0e      	ldr	r7, [sp, #56]	; 0x38
  144ce2:	f104 4474 	add.w	r4, r4, #4093640704	; 0xf4000000
  144ce6:	f8dd 9004 	ldr.w	r9, [r13, #4]
  144cea:	429d      	cmp	r5, r3
  144cec:	9e03      	ldr	r6, [sp, #12]
  144cee:	bf28      	it	cs
  144cf0:	461d      	movcs	r5, r3
  144cf2:	9a0c      	ldr	r2, [sp, #48]	; 0x30

    if (EXT_MEM == src.addr_type) {
  144cf4:	2f03      	cmp	r7, #3
  144cf6:	d026      	beq.n	144d46 <cryptodma_config+0x7a>
        writel(addr_switch_to_ce(vce_id, src.addr_type, (_paddr((void*)src.addr))), _ioaddr((REG_DMA_SRC_ADDR_CE_(vce_id))));
    }
    else {
        writel((addr_t)src.addr, _ioaddr((REG_DMA_SRC_ADDR_CE_(vce_id))));
  144cf8:	6562      	str	r2, [r4, #84]	; 0x54
  144cfa:	2f04      	cmp	r7, #4
  144cfc:	bf88      	it	hi
  144cfe:	2300      	movhi	r3, #0
  144d00:	d925      	bls.n	144d4e <cryptodma_config+0x82>
    }

    //TODO: compatible 64bit address
    value = reg_value(0, 0, CE_DMA_SRC_ADDR_H_SHIFT, CE_DMA_SRC_ADDR_H_MASK);
    value = reg_value(switch_addr_type(src.addr_type), value, CE_DMA_SRC_TYPE_SHIFT, CE_DMA_SRC_TYPE_MASK);
    writel(value, _ioaddr((REG_DMA_SRC_ADDR_H_CE_(vce_id))));
  144d02:	65a3      	str	r3, [r4, #88]	; 0x58

    LTRACEF("value = %x reg= 0x%x\n", value, REG_DMA_SRC_ADDR_H_CE_(vce_id));

    if (EXT_MEM == dst.addr_type) {
  144d04:	2e03      	cmp	r6, #3
  144d06:	d00a      	beq.n	144d1e <cryptodma_config+0x52>
        writel(addr_switch_to_ce(vce_id, dst.addr_type, (_paddr((void*)dst.addr))),  _ioaddr(REG_DMA_DST_ADDR_CE_(vce_id)));
    }
    else {
        writel((addr_t)dst.addr,  _ioaddr(REG_DMA_DST_ADDR_CE_(vce_id)));
  144d08:	f8c4 905c 	str.w	r9, [r4, #92]	; 0x5c
  144d0c:	2e04      	cmp	r6, #4
  144d0e:	bf88      	it	hi
  144d10:	2300      	movhi	r3, #0
  144d12:	d90a      	bls.n	144d2a <cryptodma_config+0x5e>
    }

    //TODO: compatible 64bit address
    value = reg_value(0, 0, CE_DMA_DST_ADDR_H_SHIFT, CE_DMA_DST_ADDR_H_MASK);
    value = reg_value(switch_addr_type(dst.addr_type), value, CE_DMA_DST_TYPE_SHIFT, CE_DMA_DST_TYPE_MASK);
    writel(value,  _ioaddr(REG_DMA_DST_ADDR_H_CE_(vce_id)));
  144d14:	6623      	str	r3, [r4, #96]	; 0x60

    LTRACEF("cryptodma_config transfer_len: %d\n", transfer_len);
    writel(transfer_len, _ioaddr(REG_DMA_LEN_CE_(vce_id)));
  144d16:	6665      	str	r5, [r4, #100]	; 0x64
}
  144d18:	b005      	add	sp, #20
  144d1a:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        writel(addr_switch_to_ce(vce_id, dst.addr_type, (_paddr((void*)dst.addr))),  _ioaddr(REG_DMA_DST_ADDR_CE_(vce_id)));
  144d1e:	464a      	mov	r2, r9
  144d20:	4640      	mov	r0, r8
  144d22:	4631      	mov	r1, r6
  144d24:	f7fe fc52 	bl	1435cc <addr_switch_to_ce>
  144d28:	65e0      	str	r0, [r4, #92]	; 0x5c
  144d2a:	f245 7308 	movw	r3, #22280	; 0x5708
  144d2e:	f2c0 0315 	movt	r3, #21
  144d32:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
  144d36:	021b      	lsls	r3, r3, #8
  144d38:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    writel(value,  _ioaddr(REG_DMA_DST_ADDR_H_CE_(vce_id)));
  144d3c:	6623      	str	r3, [r4, #96]	; 0x60
    writel(transfer_len, _ioaddr(REG_DMA_LEN_CE_(vce_id)));
  144d3e:	6665      	str	r5, [r4, #100]	; 0x64
}
  144d40:	b005      	add	sp, #20
  144d42:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        writel(addr_switch_to_ce(vce_id, src.addr_type, (_paddr((void*)src.addr))), _ioaddr((REG_DMA_SRC_ADDR_CE_(vce_id))));
  144d46:	4639      	mov	r1, r7
  144d48:	f7fe fc40 	bl	1435cc <addr_switch_to_ce>
  144d4c:	6560      	str	r0, [r4, #84]	; 0x54
  144d4e:	f245 7308 	movw	r3, #22280	; 0x5708
  144d52:	f2c0 0315 	movt	r3, #21
  144d56:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
  144d5a:	021b      	lsls	r3, r3, #8
  144d5c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  144d60:	e7cf      	b.n	144d02 <cryptodma_config+0x36>
  144d62:	bf00      	nop

00144d64 <memcpy_blk_common>:
    value_state = reg_value(0, 0x0, CE_DMA_INTEGRITY_ERROR_INTCLR_SHIFT, CE_DMA_INTEGRITY_ERROR_INTCLR_MASK);
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
}

uint32_t memcpy_blk_common(uint32_t vce_id, block_t dst, block_t src, uint32_t length, bool cache_op)
{
  144d64:	b570      	push	{r4, r5, r6, r14}
  144d66:	b088      	sub	sp, #32
  144d68:	ad05      	add	r5, sp, #20
  144d6a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
  144d6c:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  144d70:	f89d 3040 	ldrb.w	r3, [r13, #64]	; 0x40
    uint32_t status;

    if (!length) {
  144d74:	2e00      	cmp	r6, #0
  144d76:	d043      	beq.n	144e00 <memcpy_blk_common+0x9c>
  144d78:	9a06      	ldr	r2, [sp, #24]
  144d7a:	4604      	mov	r4, r0
  144d7c:	4296      	cmp	r6, r2
  144d7e:	bf28      	it	cs
  144d80:	4616      	movcs	r6, r2

    if (dst.len < length) {
        length = dst.len;
    }

    if (cache_op) {
  144d82:	bba3      	cbnz	r3, 144dee <memcpy_blk_common+0x8a>
        clean_cache_block(&src, vce_id);
        invalidate_cache_block(&dst, vce_id);
    }

    cryptodma_config(vce_id, dst, src, length);
  144d84:	ab0c      	add	r3, sp, #48	; 0x30
  144d86:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  144d8a:	9603      	str	r6, [sp, #12]
  144d8c:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  144d90:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  144d94:	4620      	mov	r0, r4
    read_value = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144d96:	0325      	lsls	r5, r4, #12
  144d98:	f105 4574 	add.w	r5, r5, #4093640704	; 0xf4000000
    cryptodma_config(vce_id, dst, src, length);
  144d9c:	f7ff ff96 	bl	144ccc <cryptodma_config>
    event_wait(&g_ce_signal[vce_id]);
  144da0:	f242 308c 	movw	r0, #9100	; 0x238c
  144da4:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  144da8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  144dac:	f2c0 0016 	movt	r0, #22
    read_value = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144db0:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  144db2:	eb00 0084 	add.w	r0, r0, r4, lsl #2
  144db6:	43d3      	mvns	r3, r2
  144db8:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  144dbc:	4053      	eors	r3, r2
  144dbe:	43da      	mvns	r2, r3
  144dc0:	f002 0201 	and.w	r2, r2, #1
  144dc4:	4053      	eors	r3, r2
    writel(value, _ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144dc6:	652b      	str	r3, [r5, #80]	; 0x50
  144dc8:	f00a f95a 	bl	14f080 <event_wait_timeout>
    uint32_t err = readl(_ioaddr(REG_ERRSTAT_CE_(vce_id))) & 0x70000;
  144dcc:	686b      	ldr	r3, [r5, #4]
    if (err) {
  144dce:	f413 23e0 	ands.w	r3, r3, #458752	; 0x70000
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144dd2:	bf1f      	itttt	ne
  144dd4:	f44f 7180 	movne.w	r1, #256	; 0x100
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144dd8:	2200      	movne	r2, #0
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144dda:	f8c5 1148 	strne.w	r1, [r5, #328]	; 0x148
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144dde:	f8c5 2148 	strne.w	r2, [r5, #328]	; 0x148
    uint32_t dma_status = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id))) & 0x200;  //0x300
  144de2:	6d28      	ldr	r0, [r5, #80]	; 0x50
  144de4:	f400 7000 	and.w	r0, r0, #512	; 0x200
    return cryptodma_check_bus_error(vce_id) | cryptodma_check_fifo_empty(vce_id);
  144de8:	4318      	orrs	r0, r3
    cryptodma_wait(vce_id);

    status = cryptodma_check_status(vce_id);

    return status;
}
  144dea:	b008      	add	sp, #32
  144dec:	bd70      	pop	{r4, r5, r6, r15}
        clean_cache_block(&src, vce_id);
  144dee:	4601      	mov	r1, r0
  144df0:	a80c      	add	r0, sp, #48	; 0x30
  144df2:	f7fe fc7b 	bl	1436ec <clean_cache_block>
        invalidate_cache_block(&dst, vce_id);
  144df6:	4621      	mov	r1, r4
  144df8:	4628      	mov	r0, r5
  144dfa:	f7fe fc93 	bl	143724 <invalidate_cache_block>
  144dfe:	e7c1      	b.n	144d84 <memcpy_blk_common+0x20>
        return CRYPTOLIB_INVALID_PARAM;
  144e00:	2009      	movs	r0, #9
}
  144e02:	b008      	add	sp, #32
  144e04:	bd70      	pop	{r4, r5, r6, r15}
  144e06:	bf00      	nop

00144e08 <memcpy_blk_cache>:

uint32_t memcpy_blk_cache(uint32_t vce_id, block_t dst, block_t src, uint32_t length, bool cache_op_src, bool cache_op_dst)
{
  144e08:	b5f0      	push	{r4, r5, r6, r7, r14}
  144e0a:	b089      	sub	sp, #36	; 0x24
  144e0c:	f89d 704c 	ldrb.w	r7, [r13, #76]	; 0x4c
  144e10:	ad05      	add	r5, sp, #20
  144e12:	9e11      	ldr	r6, [sp, #68]	; 0x44
  144e14:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  144e18:	f89d 3048 	ldrb.w	r3, [r13, #72]	; 0x48
    uint32_t status;

    if (!length) {
  144e1c:	2e00      	cmp	r6, #0
  144e1e:	d048      	beq.n	144eb2 <memcpy_blk_cache+0xaa>
  144e20:	9a06      	ldr	r2, [sp, #24]
  144e22:	4604      	mov	r4, r0
  144e24:	4296      	cmp	r6, r2
  144e26:	bf28      	it	cs
  144e28:	4616      	movcs	r6, r2

    if (dst.len < length) {
        length = dst.len;
    }

    if (cache_op_src) {
  144e2a:	2b00      	cmp	r3, #0
  144e2c:	d13a      	bne.n	144ea4 <memcpy_blk_cache+0x9c>
        clean_cache_block(&src, vce_id);
    }

    if (cache_op_dst) {
  144e2e:	bba7      	cbnz	r7, 144e9a <memcpy_blk_cache+0x92>
        invalidate_cache_block(&dst, vce_id);
    }

    cryptodma_config(vce_id, dst, src, length);
  144e30:	ab0e      	add	r3, sp, #56	; 0x38
  144e32:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  144e36:	9603      	str	r6, [sp, #12]
  144e38:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  144e3c:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  144e40:	4620      	mov	r0, r4
    read_value = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144e42:	0325      	lsls	r5, r4, #12
  144e44:	f105 4574 	add.w	r5, r5, #4093640704	; 0xf4000000
    cryptodma_config(vce_id, dst, src, length);
  144e48:	f7ff ff40 	bl	144ccc <cryptodma_config>
    event_wait(&g_ce_signal[vce_id]);
  144e4c:	f242 308c 	movw	r0, #9100	; 0x238c
  144e50:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
  144e54:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  144e58:	f2c0 0016 	movt	r0, #22
    read_value = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144e5c:	6d2a      	ldr	r2, [r5, #80]	; 0x50
  144e5e:	eb00 0084 	add.w	r0, r0, r4, lsl #2
  144e62:	43d3      	mvns	r3, r2
  144e64:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  144e68:	4053      	eors	r3, r2
  144e6a:	43da      	mvns	r2, r3
  144e6c:	f002 0201 	and.w	r2, r2, #1
  144e70:	4053      	eors	r3, r2
    writel(value, _ioaddr(REG_DMA_CTRL_CE_(vce_id)));
  144e72:	652b      	str	r3, [r5, #80]	; 0x50
  144e74:	f00a f904 	bl	14f080 <event_wait_timeout>
    uint32_t err = readl(_ioaddr(REG_ERRSTAT_CE_(vce_id))) & 0x70000;
  144e78:	686b      	ldr	r3, [r5, #4]
    if (err) {
  144e7a:	f413 23e0 	ands.w	r3, r3, #458752	; 0x70000
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144e7e:	bf1f      	itttt	ne
  144e80:	f44f 7180 	movne.w	r1, #256	; 0x100
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144e84:	2200      	movne	r2, #0
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144e86:	f8c5 1148 	strne.w	r1, [r5, #328]	; 0x148
    writel(value_state, _ioaddr(REG_INTCLR_CE_(vce_id)));
  144e8a:	f8c5 2148 	strne.w	r2, [r5, #328]	; 0x148
    uint32_t dma_status = readl(_ioaddr(REG_DMA_CTRL_CE_(vce_id))) & 0x200;  //0x300
  144e8e:	6d28      	ldr	r0, [r5, #80]	; 0x50
  144e90:	f400 7000 	and.w	r0, r0, #512	; 0x200
    return cryptodma_check_bus_error(vce_id) | cryptodma_check_fifo_empty(vce_id);
  144e94:	4318      	orrs	r0, r3
    cryptodma_wait(vce_id);

    status = cryptodma_check_status(vce_id);

    return status;
}
  144e96:	b009      	add	sp, #36	; 0x24
  144e98:	bdf0      	pop	{r4, r5, r6, r7, r15}
        invalidate_cache_block(&dst, vce_id);
  144e9a:	4621      	mov	r1, r4
  144e9c:	4628      	mov	r0, r5
  144e9e:	f7fe fc41 	bl	143724 <invalidate_cache_block>
  144ea2:	e7c5      	b.n	144e30 <memcpy_blk_cache+0x28>
        clean_cache_block(&src, vce_id);
  144ea4:	4601      	mov	r1, r0
  144ea6:	a80e      	add	r0, sp, #56	; 0x38
  144ea8:	f7fe fc20 	bl	1436ec <clean_cache_block>
    if (cache_op_dst) {
  144eac:	2f00      	cmp	r7, #0
  144eae:	d0bf      	beq.n	144e30 <memcpy_blk_cache+0x28>
  144eb0:	e7f3      	b.n	144e9a <memcpy_blk_cache+0x92>
        return CRYPTOLIB_INVALID_PARAM;
  144eb2:	2009      	movs	r0, #9
}
  144eb4:	b009      	add	sp, #36	; 0x24
  144eb6:	bdf0      	pop	{r4, r5, r6, r7, r15}

00144eb8 <memcpy_blk>:

uint32_t memcpy_blk(uint32_t vce_id, block_t dst, block_t src, uint32_t length)
{
  144eb8:	b570      	push	{r4, r5, r6, r14}
  144eba:	4605      	mov	r5, r0
  144ebc:	b08a      	sub	sp, #40	; 0x28
    return memcpy_blk_common(vce_id, dst, src, length, true);
  144ebe:	2601      	movs	r6, #1
{
  144ec0:	ac07      	add	r4, sp, #28
  144ec2:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return memcpy_blk_common(vce_id, dst, src, length, true);
  144ec6:	ab0e      	add	r3, sp, #56	; 0x38
  144ec8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
{
  144ecc:	9b11      	ldr	r3, [sp, #68]	; 0x44
    return memcpy_blk_common(vce_id, dst, src, length, true);
  144ece:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  144ed2:	9604      	str	r6, [sp, #16]
  144ed4:	4628      	mov	r0, r5
  144ed6:	9303      	str	r3, [sp, #12]
  144ed8:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  144edc:	f7ff ff42 	bl	144d64 <memcpy_blk_common>
}
  144ee0:	b00a      	add	sp, #40	; 0x28
  144ee2:	bd70      	pop	{r4, r5, r6, r15}

00144ee4 <mem2CryptoRAM_rev>:

    return CryptoRAM2mem(vce_id, block_t_convert(dst.addr + size, dst.len - size, dst.addr_type), size, offset + 1, true);
}

uint32_t mem2CryptoRAM_rev(uint32_t vce_id, block_t src, uint32_t size, uint32_t offset, bool cache_op)
{
  144ee4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  144ee8:	b090      	sub	sp, #64	; 0x40
  144eea:	f89d 7060 	ldrb.w	r7, [r13, #96]	; 0x60
  144eee:	ac07      	add	r4, sp, #28
  144ef0:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  144ef4:	9d08      	ldr	r5, [sp, #32]
  144ef6:	9c16      	ldr	r4, [sp, #88]	; 0x58
    uint32_t i = 0;
    block_t dst;
    uint8_t* temp_buf;
    struct mem_node* mem_n;

    if (!src.len || !size || (size > RSA_MAX_SIZE)) {
  144ef8:	2d00      	cmp	r5, #0
  144efa:	d03b      	beq.n	144f74 <mem2CryptoRAM_rev+0x90>
  144efc:	1e63      	subs	r3, r4, #1
  144efe:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  144f02:	d237      	bcs.n	144f74 <mem2CryptoRAM_rev+0x90>
  144f04:	4606      	mov	r6, r0
  144f06:	42a5      	cmp	r5, r4
        src.len = size;
    }

    //buffer for bytes order reverse

    mem_n = ce_malloc(RSA_MAX_SIZE);
  144f08:	f44f 7000 	mov.w	r0, #512	; 0x200
  144f0c:	bf28      	it	cs
  144f0e:	4625      	movcs	r5, r4
  144f10:	f7fe fae8 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  144f14:	4680      	mov	r8, r0
  144f16:	b390      	cbz	r0, 144f7e <mem2CryptoRAM_rev+0x9a>
        temp_buf = mem_n->ptr;
  144f18:	f8d0 e008 	ldr.w	r14, [r0, #8]

    //memset(temp_buf, 0, RSA_MAX_SIZE);

    //reverse byte order
    for (i = 0; i < size; i++) {
        temp_buf[i] = src.addr[size - i - 1];
  144f1c:	9807      	ldr	r0, [sp, #28]
  144f1e:	f10e 32ff 	add.w	r2, r14, #4294967295	; 0xffffffff
  144f22:	1903      	adds	r3, r0, r4
  144f24:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
  144f28:	f802 1f01 	strb.w	r1, [r2, #1]!
    for (i = 0; i < size; i++) {
  144f2c:	4283      	cmp	r3, r0
  144f2e:	d1f9      	bne.n	144f24 <mem2CryptoRAM_rev+0x40>
  144f30:	2303      	movs	r3, #3

    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);

    //clean_cache((addr_t)temp_buf, RSA_MAX_SIZE);

    status = memcpy_blk_common(vce_id, dst, block_t_convert(temp_buf, size, EXT_MEM), src.len, cache_op);
  144f32:	aa10      	add	r2, sp, #64	; 0x40
  144f34:	e9cd e40d 	strd	r14, r4, [r13, #52]	; 0x34
  144f38:	f10d 0c28 	add.w	r12, r13, #40	; 0x28
  144f3c:	930f      	str	r3, [sp, #60]	; 0x3c
    dst.addr_type = PKE_INTERNAL;
  144f3e:	f04f 0e04 	mov.w	r14, #4
    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  144f42:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    status = memcpy_blk_common(vce_id, dst, block_t_convert(temp_buf, size, EXT_MEM), src.len, cache_op);
  144f44:	e9cd 5703 	strd	r5, r7, [r13, #12]
  144f48:	e912 0007 	ldmdb	r2, {r0, r1, r2}
    dst.len = size;
  144f4c:	940b      	str	r4, [sp, #44]	; 0x2c
    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  144f4e:	025b      	lsls	r3, r3, #9
    dst.addr_type = PKE_INTERNAL;
  144f50:	f8cd e030 	str.w	r14, [r13, #48]	; 0x30
    status = memcpy_blk_common(vce_id, dst, block_t_convert(temp_buf, size, EXT_MEM), src.len, cache_op);
  144f54:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  144f58:	930a      	str	r3, [sp, #40]	; 0x28
    status = memcpy_blk_common(vce_id, dst, block_t_convert(temp_buf, size, EXT_MEM), src.len, cache_op);
  144f5a:	4630      	mov	r0, r6
  144f5c:	e89c 000e 	ldmia.w	r12, {r1, r2, r3}
  144f60:	f7ff ff00 	bl	144d64 <memcpy_blk_common>
  144f64:	4604      	mov	r4, r0

    ce_free(mem_n);
  144f66:	4640      	mov	r0, r8
  144f68:	f7fe fb00 	bl	14356c <ce_free>
    if (status) {
        return status;
    }

    return status;
}
  144f6c:	4620      	mov	r0, r4
  144f6e:	b010      	add	sp, #64	; 0x40
  144f70:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return CRYPTOLIB_INVALID_PARAM;
  144f74:	2409      	movs	r4, #9
}
  144f76:	4620      	mov	r0, r4
  144f78:	b010      	add	sp, #64	; 0x40
  144f7a:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return CRYPTOLIB_PK_N_NOTVALID;
  144f7e:	2415      	movs	r4, #21
  144f80:	e7f9      	b.n	144f76 <mem2CryptoRAM_rev+0x92>
  144f82:	bf00      	nop

00144f84 <point2CryptoRAM_rev>:
{
  144f84:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  144f88:	b08c      	sub	sp, #48	; 0x30
  144f8a:	ac05      	add	r4, sp, #20
  144f8c:	9d12      	ldr	r5, [sp, #72]	; 0x48
  144f8e:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  144f92:	9e06      	ldr	r6, [sp, #24]
    if (src.len < size * 2) {
  144f94:	ebb6 0f45 	cmp.w	r6, r5, lsl #1
        return CRYPTOLIB_INVALID_PARAM;
  144f98:	bf38      	it	cc
  144f9a:	2009      	movcc	r0, #9
    if (src.len < size * 2) {
  144f9c:	d30c      	bcc.n	144fb8 <point2CryptoRAM_rev+0x34>
    uint32_t status = mem2CryptoRAM_rev(vce_id, src, size, offset, true);
  144f9e:	f04f 0801 	mov.w	r8, #1
  144fa2:	4607      	mov	r7, r0
  144fa4:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  144fa6:	e9cd 5300 	strd	r5, r3, [r13]
  144faa:	f8cd 8008 	str.w	r8, [r13, #8]
  144fae:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  144fb2:	f7ff ff97 	bl	144ee4 <mem2CryptoRAM_rev>
    if (status) {
  144fb6:	b110      	cbz	r0, 144fbe <point2CryptoRAM_rev+0x3a>
}
  144fb8:	b00c      	add	sp, #48	; 0x30
  144fba:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    return mem2CryptoRAM_rev(vce_id, block_t_convert(src.addr + size, src.len - size, src.addr_type), size, offset + 1, true);
  144fbe:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  144fc0:	1b76      	subs	r6, r6, r5
  144fc2:	9a05      	ldr	r2, [sp, #20]
  144fc4:	4638      	mov	r0, r7
  144fc6:	9907      	ldr	r1, [sp, #28]
  144fc8:	4443      	add	r3, r8
  144fca:	960a      	str	r6, [sp, #40]	; 0x28
  144fcc:	442a      	add	r2, r5
  144fce:	9301      	str	r3, [sp, #4]
  144fd0:	ab0c      	add	r3, sp, #48	; 0x30
  144fd2:	f8cd 8008 	str.w	r8, [r13, #8]
  144fd6:	9500      	str	r5, [sp, #0]
  144fd8:	9209      	str	r2, [sp, #36]	; 0x24
  144fda:	910b      	str	r1, [sp, #44]	; 0x2c
  144fdc:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  144fe0:	f7ff ff80 	bl	144ee4 <mem2CryptoRAM_rev>
}
  144fe4:	b00c      	add	sp, #48	; 0x30
  144fe6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  144fea:	bf00      	nop

00144fec <CryptoRAM2mem_rev>:

uint32_t CryptoRAM2mem_rev(uint32_t vce_id, block_t dst, uint32_t size, uint32_t offset, bool cache_op)
{
  144fec:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    //buffer for bytes order reverse

    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);

    src.len = size;
    src.addr_type = PKE_INTERNAL;
  144ff0:	2604      	movs	r6, #4
{
  144ff2:	b090      	sub	sp, #64	; 0x40
  144ff4:	4607      	mov	r7, r0
  144ff6:	ad07      	add	r5, sp, #28

    mem_n = ce_malloc(RSA_MAX_SIZE);
  144ff8:	f44f 7000 	mov.w	r0, #512	; 0x200
{
  144ffc:	f89d 8060 	ldrb.w	r8, [r13, #96]	; 0x60
  145000:	9c17      	ldr	r4, [sp, #92]	; 0x5c
  145002:	e885 000e 	stmia.w	r5, {r1, r2, r3}
    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  145006:	0263      	lsls	r3, r4, #9
{
  145008:	9c16      	ldr	r4, [sp, #88]	; 0x58
    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  14500a:	930a      	str	r3, [sp, #40]	; 0x28
    src.len = size;
  14500c:	e9cd 460b 	strd	r4, r6, [r13, #44]	; 0x2c
    mem_n = ce_malloc(RSA_MAX_SIZE);
  145010:	f7fe fa68 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  145014:	b338      	cbz	r0, 145066 <CryptoRAM2mem_rev+0x7a>
  145016:	f04f 0c03 	mov.w	r12, #3
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    status = memcpy_blk_common(vce_id, block_t_convert(temp_buf, dst.len, EXT_MEM), src, size, cache_op);
  14501a:	ab0a      	add	r3, sp, #40	; 0x28
        temp_buf = mem_n->ptr;
  14501c:	6885      	ldr	r5, [r0, #8]
  14501e:	4606      	mov	r6, r0
  145020:	950d      	str	r5, [sp, #52]	; 0x34
    status = memcpy_blk_common(vce_id, block_t_convert(temp_buf, dst.len, EXT_MEM), src, size, cache_op);
  145022:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145026:	9b08      	ldr	r3, [sp, #32]
  145028:	e9cd 3c0e 	strd	r3, r12, [r13, #56]	; 0x38
  14502c:	ab10      	add	r3, sp, #64	; 0x40
  14502e:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145032:	e9cd 4803 	strd	r4, r8, [r13, #12]
  145036:	4638      	mov	r0, r7
  145038:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  14503c:	f7ff fe92 	bl	144d64 <memcpy_blk_common>

    if (status) {
  145040:	4607      	mov	r7, r0
  145042:	b948      	cbnz	r0, 145058 <CryptoRAM2mem_rev+0x6c>
        ce_free(mem_n);
        return status;
    }

    //reverse byte order
    for (uint32_t i = 0; i < size; i++) {
  145044:	b144      	cbz	r4, 145058 <CryptoRAM2mem_rev+0x6c>
  145046:	9a07      	ldr	r2, [sp, #28]
  145048:	192b      	adds	r3, r5, r4
  14504a:	3a01      	subs	r2, #1
        //LTRACEF("CryptoRAM2mem_rev: temp_buf %d = %x!\n",(size - i - 1),temp_buf[size - i - 1]);
        dst.addr[i] = temp_buf[size - i - 1];
  14504c:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
  145050:	f802 1f01 	strb.w	r1, [r2, #1]!
    for (uint32_t i = 0; i < size; i++) {
  145054:	42ab      	cmp	r3, r5
  145056:	d1f9      	bne.n	14504c <CryptoRAM2mem_rev+0x60>
    }

    ce_free(mem_n);
  145058:	4630      	mov	r0, r6
  14505a:	f7fe fa87 	bl	14356c <ce_free>
    return status;
}
  14505e:	4638      	mov	r0, r7
  145060:	b010      	add	sp, #64	; 0x40
  145062:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return CRYPTOLIB_PK_N_NOTVALID;
  145066:	2715      	movs	r7, #21
}
  145068:	4638      	mov	r0, r7
  14506a:	b010      	add	sp, #64	; 0x40
  14506c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00145070 <CryptoRAM2point_rev>:
{
  145070:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  145074:	b08c      	sub	sp, #48	; 0x30
  145076:	ac05      	add	r4, sp, #20
  145078:	9d12      	ldr	r5, [sp, #72]	; 0x48
  14507a:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  14507e:	9e06      	ldr	r6, [sp, #24]
    if (dst.len < size * 2) {
  145080:	ebb6 0f45 	cmp.w	r6, r5, lsl #1
        return CRYPTOLIB_INVALID_PARAM;
  145084:	bf38      	it	cc
  145086:	2009      	movcc	r0, #9
    if (dst.len < size * 2) {
  145088:	d30c      	bcc.n	1450a4 <CryptoRAM2point_rev+0x34>
    uint32_t status  = CryptoRAM2mem_rev(vce_id, dst, size, offset, true);
  14508a:	f04f 0801 	mov.w	r8, #1
  14508e:	4607      	mov	r7, r0
  145090:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  145092:	e9cd 5300 	strd	r5, r3, [r13]
  145096:	f8cd 8008 	str.w	r8, [r13, #8]
  14509a:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  14509e:	f7ff ffa5 	bl	144fec <CryptoRAM2mem_rev>
    if (status) {
  1450a2:	b110      	cbz	r0, 1450aa <CryptoRAM2point_rev+0x3a>
}
  1450a4:	b00c      	add	sp, #48	; 0x30
  1450a6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    return CryptoRAM2mem_rev(vce_id, block_t_convert(dst.addr + size, dst.len - size, dst.addr_type), size, offset + 1, true);
  1450aa:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  1450ac:	1b76      	subs	r6, r6, r5
  1450ae:	9a05      	ldr	r2, [sp, #20]
  1450b0:	4638      	mov	r0, r7
  1450b2:	9907      	ldr	r1, [sp, #28]
  1450b4:	4443      	add	r3, r8
  1450b6:	960a      	str	r6, [sp, #40]	; 0x28
  1450b8:	442a      	add	r2, r5
  1450ba:	9301      	str	r3, [sp, #4]
  1450bc:	ab0c      	add	r3, sp, #48	; 0x30
  1450be:	f8cd 8008 	str.w	r8, [r13, #8]
  1450c2:	9500      	str	r5, [sp, #0]
  1450c4:	9209      	str	r2, [sp, #36]	; 0x24
  1450c6:	910b      	str	r1, [sp, #44]	; 0x2c
  1450c8:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  1450cc:	f7ff ff8e 	bl	144fec <CryptoRAM2mem_rev>
}
  1450d0:	b00c      	add	sp, #48	; 0x30
  1450d2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  1450d6:	bf00      	nop

001450d8 <mem2CryptoRAM>:

uint32_t mem2CryptoRAM(uint32_t vce_id, block_t src, uint32_t size, uint32_t offset, bool cache_op)
{
  1450d8:	b5f0      	push	{r4, r5, r6, r7, r14}
  1450da:	4607      	mov	r7, r0
  1450dc:	b08f      	sub	sp, #60	; 0x3c
  1450de:	ac07      	add	r4, sp, #28
  1450e0:	f89d 6058 	ldrb.w	r6, [r13, #88]	; 0x58
  1450e4:	e884 000e 	stmia.w	r4, {r1, r2, r3}

    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);

    dst.len = size;
    dst.addr_type = PKE_INTERNAL;
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  1450e8:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
{
  1450ec:	9d15      	ldr	r5, [sp, #84]	; 0x54
    dst.addr_type = PKE_INTERNAL;
  1450ee:	2204      	movs	r2, #4
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  1450f0:	e88d 000b 	stmia.w	r13, {r0, r1, r3}
{
  1450f4:	9b14      	ldr	r3, [sp, #80]	; 0x50
    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  1450f6:	026d      	lsls	r5, r5, #9
    dst.len = size;
  1450f8:	e9cd 320c 	strd	r3, r2, [r13, #48]	; 0x30
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  1450fc:	4638      	mov	r0, r7
  1450fe:	9303      	str	r3, [sp, #12]
  145100:	ab0e      	add	r3, sp, #56	; 0x38
    dst.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  145102:	950b      	str	r5, [sp, #44]	; 0x2c
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  145104:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  145108:	9604      	str	r6, [sp, #16]
  14510a:	f7ff fe2b 	bl	144d64 <memcpy_blk_common>
}
  14510e:	b00f      	add	sp, #60	; 0x3c
  145110:	bdf0      	pop	{r4, r5, r6, r7, r15}
  145112:	bf00      	nop

00145114 <CryptoRAM2mem>:

uint32_t CryptoRAM2mem(uint32_t vce_id, block_t dst, uint32_t size, uint32_t offset, bool cache_op)
{
  145114:	b5f0      	push	{r4, r5, r6, r7, r14}
    block_t src;

    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
    src.len = size;
    src.addr_type = PKE_INTERNAL;
  145116:	f04f 0c04 	mov.w	r12, #4
{
  14511a:	b08f      	sub	sp, #60	; 0x3c
  14511c:	4606      	mov	r6, r0
  14511e:	ac07      	add	r4, sp, #28
  145120:	f89d 7058 	ldrb.w	r7, [r13, #88]	; 0x58
  145124:	9d15      	ldr	r5, [sp, #84]	; 0x54
  145126:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  14512a:	aa0e      	add	r2, sp, #56	; 0x38
{
  14512c:	9b14      	ldr	r3, [sp, #80]	; 0x50
    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  14512e:	026d      	lsls	r5, r5, #9
    src.len = size;
  145130:	e9cd 3c0c 	strd	r3, r12, [r13, #48]	; 0x30
    src.addr = (uint8_t*)(addr_t)BA414EP_ADDR_MEMLOC(offset - 1, 0);
  145134:	950b      	str	r5, [sp, #44]	; 0x2c
    return memcpy_blk_common(vce_id, dst, src, size, cache_op);
  145136:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  14513a:	9303      	str	r3, [sp, #12]
  14513c:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145140:	9704      	str	r7, [sp, #16]
  145142:	4630      	mov	r0, r6
  145144:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  145148:	f7ff fe0c 	bl	144d64 <memcpy_blk_common>
}
  14514c:	b00f      	add	sp, #60	; 0x3c
  14514e:	bdf0      	pop	{r4, r5, r6, r7, r15}

00145150 <rsa_encrypt_blk>:
                         block_t message,
                         block_t n,
                         block_t public_expo,
                         block_t result,
                         hash_alg_t hashType)
{
  145150:	b082      	sub	sp, #8
    struct mem_node* mem_n;
    uint32_t status = CRYPTOLIB_SUCCESS;
    uint32_t size = n.len;

    //Checks that the algoritm is valid for signature
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_OAEP &&
  145152:	2902      	cmp	r1, #2
{
  145154:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  145158:	b08b      	sub	sp, #44	; 0x2c
  14515a:	ac14      	add	r4, sp, #80	; 0x50
  14515c:	e884 000c 	stmia.w	r4, {r2, r3}
            padding_type != ESEC_RSA_PADDING_EME_PKCS) {
        return CRYPTOLIB_INVALID_PARAM;
  145160:	bf88      	it	hi
  145162:	2409      	movhi	r4, #9
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_OAEP &&
  145164:	d818      	bhi.n	145198 <rsa_encrypt_blk+0x48>
    }

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_ENC, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  145166:	2400      	movs	r4, #0
  145168:	460d      	mov	r5, r1
  14516a:	9e18      	ldr	r6, [sp, #96]	; 0x60
  14516c:	4623      	mov	r3, r4
  14516e:	2114      	movs	r1, #20
  145170:	4632      	mov	r2, r6
  145172:	9400      	str	r4, [sp, #0]
  145174:	4607      	mov	r7, r0
  145176:	f8dd 9054 	ldr.w	r9, [r13, #84]	; 0x54
  14517a:	f7fe fffb 	bl	144174 <pke_set_command>
#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_4, (addr_t)(result.addr), result.addr_type);
#endif

    // Location 0 -> Modulus N
    status = mem2CryptoRAM_rev(vce_id, n, size, BA414EP_MEMLOC_0, true);
  14517e:	f04f 0801 	mov.w	r8, #1
  145182:	ab17      	add	r3, sp, #92	; 0x5c
  145184:	e9cd 6400 	strd	r6, r4, [r13]
  145188:	4638      	mov	r0, r7
  14518a:	cb0e      	ldmia	r3, {r1, r2, r3}
  14518c:	f8cd 8008 	str.w	r8, [r13, #8]
  145190:	f7ff fea8 	bl	144ee4 <mem2CryptoRAM_rev>

    if (status) {
  145194:	4604      	mov	r4, r0
  145196:	b128      	cbz	r0, 1451a4 <rsa_encrypt_blk+0x54>
    // Location 4 -> Cipher C optional: pke_set_dst_param, copy result by manual mode
    CryptoRAM2mem(vce_id, result, n.len, BA414EP_MEMLOC_4, true);
#endif
    ce_free(mem_n);
    return status;
}
  145198:	4620      	mov	r0, r4
  14519a:	b00b      	add	sp, #44	; 0x2c
  14519c:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1451a0:	b002      	add	sp, #8
  1451a2:	4770      	bx	r14
    mem_n = ce_malloc(RSA_MAX_SIZE);
  1451a4:	f44f 7000 	mov.w	r0, #512	; 0x200
        return CRYPTOLIB_PK_N_NOTVALID;
  1451a8:	2415      	movs	r4, #21
    mem_n = ce_malloc(RSA_MAX_SIZE);
  1451aa:	f7fe f99b 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  1451ae:	4682      	mov	r10, r0
  1451b0:	2800      	cmp	r0, #0
  1451b2:	d0f1      	beq.n	145198 <rsa_encrypt_blk+0x48>
        msg_padding = mem_n->ptr;
  1451b4:	f8d0 b008 	ldr.w	r11, [r0, #8]
    if (padding_type == ESEC_RSA_PADDING_OAEP) {
  1451b8:	4545      	cmp	r5, r8
  1451ba:	d04e      	beq.n	14525a <rsa_encrypt_blk+0x10a>
    else if (padding_type == ESEC_RSA_PADDING_EME_PKCS) {
  1451bc:	2d02      	cmp	r5, #2
  1451be:	d02b      	beq.n	145218 <rsa_encrypt_blk+0xc8>
        status = mem2CryptoRAM_rev(vce_id, message, size, BA414EP_MEMLOC_5, true);
  1451c0:	2305      	movs	r3, #5
  1451c2:	4638      	mov	r0, r7
  1451c4:	f8cd 8008 	str.w	r8, [r13, #8]
  1451c8:	e9cd 6300 	strd	r6, r3, [r13]
  1451cc:	ab14      	add	r3, sp, #80	; 0x50
  1451ce:	cb0e      	ldmia	r3, {r1, r2, r3}
  1451d0:	f7ff fe88 	bl	144ee4 <mem2CryptoRAM_rev>
        if (status) {
  1451d4:	4604      	mov	r4, r0
  1451d6:	b9d8      	cbnz	r0, 145210 <rsa_encrypt_blk+0xc0>
    status = mem2CryptoRAM_rev(vce_id, public_expo, size, BA414EP_MEMLOC_8, true);
  1451d8:	2408      	movs	r4, #8
  1451da:	ab1a      	add	r3, sp, #104	; 0x68
  1451dc:	2501      	movs	r5, #1
  1451de:	4638      	mov	r0, r7
  1451e0:	9600      	str	r6, [sp, #0]
  1451e2:	cb0e      	ldmia	r3, {r1, r2, r3}
  1451e4:	e9cd 4501 	strd	r4, r5, [r13, #4]
  1451e8:	f7ff fe7c 	bl	144ee4 <mem2CryptoRAM_rev>
    if (status) {
  1451ec:	4604      	mov	r4, r0
  1451ee:	b978      	cbnz	r0, 145210 <rsa_encrypt_blk+0xc0>
    status = pke_start_wait_status(vce_id);
  1451f0:	4638      	mov	r0, r7
  1451f2:	f7fe ffdb 	bl	1441ac <pke_start_wait_status>
    if (status) {
  1451f6:	4604      	mov	r4, r0
  1451f8:	b950      	cbnz	r0, 145210 <rsa_encrypt_blk+0xc0>
    CryptoRAM2mem(vce_id, result, n.len, BA414EP_MEMLOC_4, true);
  1451fa:	f04f 0c04 	mov.w	r12, #4
  1451fe:	ab1d      	add	r3, sp, #116	; 0x74
  145200:	9502      	str	r5, [sp, #8]
  145202:	4638      	mov	r0, r7
  145204:	9600      	str	r6, [sp, #0]
  145206:	cb0e      	ldmia	r3, {r1, r2, r3}
  145208:	f8cd c004 	str.w	r12, [r13, #4]
  14520c:	f7ff ff82 	bl	145114 <CryptoRAM2mem>
    ce_free(mem_n);
  145210:	4650      	mov	r0, r10
  145212:	f7fe f9ab 	bl	14356c <ce_free>
    return status;
  145216:	e7bf      	b.n	145198 <rsa_encrypt_blk+0x48>
        status = rsa_pad_eme_pkcs_encode(vce_id, n.len, msg_padding, message, message.len);
  145218:	f8cd 9008 	str.w	r9, [r13, #8]
  14521c:	a915      	add	r1, sp, #84	; 0x54
  14521e:	9b14      	ldr	r3, [sp, #80]	; 0x50
  145220:	465a      	mov	r2, r11
  145222:	c903      	ldmia	r1, {r0, r1}
  145224:	e88d 0003 	stmia.w	r13, {r0, r1}
  145228:	4631      	mov	r1, r6
  14522a:	4638      	mov	r0, r7
  14522c:	f7ff faa6 	bl	14477c <rsa_pad_eme_pkcs_encode>
        if (status) {
  145230:	4604      	mov	r4, r0
  145232:	2800      	cmp	r0, #0
  145234:	d1ec      	bne.n	145210 <rsa_encrypt_blk+0xc0>
        status = mem2CryptoRAM_rev(vce_id, block_t_convert(msg_padding, n.len, 0), size, BA414EP_MEMLOC_5, true);
  145236:	2505      	movs	r5, #5
  145238:	ab0a      	add	r3, sp, #40	; 0x28
  14523a:	9409      	str	r4, [sp, #36]	; 0x24
  14523c:	4638      	mov	r0, r7
  14523e:	e9cd b607 	strd	r11, r6, [r13, #28]
  145242:	f8cd 8008 	str.w	r8, [r13, #8]
  145246:	9600      	str	r6, [sp, #0]
  145248:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  14524c:	9501      	str	r5, [sp, #4]
  14524e:	f7ff fe49 	bl	144ee4 <mem2CryptoRAM_rev>
        if (status) {
  145252:	4604      	mov	r4, r0
  145254:	2800      	cmp	r0, #0
  145256:	d0bf      	beq.n	1451d8 <rsa_encrypt_blk+0x88>
  145258:	e7da      	b.n	145210 <rsa_encrypt_blk+0xc0>
        status = rsa_pad_eme_oaep_encode(vce_id, n.len, ALG_SHA256, msg_padding, message, message.len);
  14525a:	ab14      	add	r3, sp, #80	; 0x50
  14525c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145260:	f8cd 900c 	str.w	r9, [r13, #12]
  145264:	465b      	mov	r3, r11
  145266:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14526a:	2203      	movs	r2, #3
  14526c:	4631      	mov	r1, r6
  14526e:	4638      	mov	r0, r7
  145270:	f7ff f8fa 	bl	144468 <rsa_pad_eme_oaep_encode>
        if (status) {
  145274:	4604      	mov	r4, r0
  145276:	2800      	cmp	r0, #0
  145278:	d1ca      	bne.n	145210 <rsa_encrypt_blk+0xc0>
        status = mem2CryptoRAM_rev(vce_id, block_t_convert(msg_padding, n.len, 0), size, BA414EP_MEMLOC_5, true);
  14527a:	f04f 0c05 	mov.w	r12, #5
  14527e:	ab04      	add	r3, sp, #16
  145280:	e9cd 6405 	strd	r6, r4, [r13, #20]
  145284:	4638      	mov	r0, r7
  145286:	f8cd b010 	str.w	r11, [r13, #16]
  14528a:	9502      	str	r5, [sp, #8]
  14528c:	9600      	str	r6, [sp, #0]
  14528e:	cb0e      	ldmia	r3, {r1, r2, r3}
  145290:	f8cd c004 	str.w	r12, [r13, #4]
  145294:	f7ff fe26 	bl	144ee4 <mem2CryptoRAM_rev>
        if (status) {
  145298:	4604      	mov	r4, r0
  14529a:	2800      	cmp	r0, #0
  14529c:	d09c      	beq.n	1451d8 <rsa_encrypt_blk+0x88>
  14529e:	e7b7      	b.n	145210 <rsa_encrypt_blk+0xc0>

001452a0 <rsa_decrypt_blk>:
                         block_t private_key,
                         block_t result,
                         uint32_t crt,
                         uint32_t* msg_len,
                         hash_alg_t hashType)
{
  1452a0:	b082      	sub	sp, #8
    }

#endif

    //Checks that the algoritm is valid for signature
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_OAEP &&
  1452a2:	2902      	cmp	r1, #2
{
  1452a4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1452a8:	b08b      	sub	sp, #44	; 0x2c
  1452aa:	ac14      	add	r4, sp, #80	; 0x50
  1452ac:	e884 000c 	stmia.w	r4, {r2, r3}
  1452b0:	9c20      	ldr	r4, [sp, #128]	; 0x80
            padding_type != ESEC_RSA_PADDING_EME_PKCS) {
        return CRYPTOLIB_INVALID_PARAM;
  1452b2:	bf88      	it	hi
  1452b4:	2409      	movhi	r4, #9
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_OAEP &&
  1452b6:	d84b      	bhi.n	145350 <rsa_decrypt_blk+0xb0>
  1452b8:	9105      	str	r1, [sp, #20]
  1452ba:	4605      	mov	r5, r0
  1452bc:	f8dd a074 	ldr.w	r10, [r13, #116]	; 0x74
  1452c0:	9f18      	ldr	r7, [sp, #96]	; 0x60
    }

    if (!crt) {
  1452c2:	2c00      	cmp	r4, #0
  1452c4:	d14a      	bne.n	14535c <rsa_decrypt_blk+0xbc>
        // Set command to enable byte-swap
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_DEC, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1452c6:	4623      	mov	r3, r4
  1452c8:	463a      	mov	r2, r7
  1452ca:	9400      	str	r4, [sp, #0]
  1452cc:	2115      	movs	r1, #21
  1452ce:	f7fe ff51 	bl	144174 <pke_set_command>

        // Location 0 -> Modulus N
        error = mem2CryptoRAM_rev(vce_id, n, size, BA414EP_MEMLOC_0, true);
  1452d2:	f04f 0801 	mov.w	r8, #1
  1452d6:	e9cd 7400 	strd	r7, r4, [r13]
  1452da:	ab17      	add	r3, sp, #92	; 0x5c
  1452dc:	4628      	mov	r0, r5
  1452de:	cb0e      	ldmia	r3, {r1, r2, r3}
  1452e0:	f8cd 8008 	str.w	r8, [r13, #8]
  1452e4:	f7ff fdfe 	bl	144ee4 <mem2CryptoRAM_rev>

        if (error) {
  1452e8:	4604      	mov	r4, r0
  1452ea:	2800      	cmp	r0, #0
  1452ec:	d130      	bne.n	145350 <rsa_decrypt_blk+0xb0>

#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_5, (addr_t)(result.addr), result.addr_type);
#endif
    // Location 4 -> Cipher
    error = mem2CryptoRAM_rev(vce_id, cipher, size, BA414EP_MEMLOC_4, true);
  1452ee:	2304      	movs	r3, #4
  1452f0:	4628      	mov	r0, r5
  1452f2:	f8cd 8008 	str.w	r8, [r13, #8]
  1452f6:	e9cd 7300 	strd	r7, r3, [r13]
  1452fa:	ab14      	add	r3, sp, #80	; 0x50
  1452fc:	cb0e      	ldmia	r3, {r1, r2, r3}
  1452fe:	f7ff fdf1 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  145302:	4604      	mov	r4, r0
  145304:	bb20      	cbnz	r0, 145350 <rsa_decrypt_blk+0xb0>
    }
    else {
        private_key.len = n.len;

        // Location 6 -> Private key
        mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_6, true);
  145306:	2406      	movs	r4, #6
  145308:	ab1a      	add	r3, sp, #104	; 0x68
        private_key.len = n.len;
  14530a:	971b      	str	r7, [sp, #108]	; 0x6c
        mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_6, true);
  14530c:	4628      	mov	r0, r5
  14530e:	f8cd 8008 	str.w	r8, [r13, #8]
  145312:	9700      	str	r7, [sp, #0]
  145314:	cb0e      	ldmia	r3, {r1, r2, r3}
  145316:	9401      	str	r4, [sp, #4]
  145318:	f7ff fde4 	bl	144ee4 <mem2CryptoRAM_rev>
    }

    error |= pke_start_wait_status(vce_id);
  14531c:	4628      	mov	r0, r5
  14531e:	f7fe ff45 	bl	1441ac <pke_start_wait_status>

    if (error) {
  145322:	4604      	mov	r4, r0
  145324:	b9a0      	cbnz	r0, 145350 <rsa_decrypt_blk+0xb0>
    }

#if AUTO_OUTPUT_BY_CE
#else
    // Fetch result optional: pke_set_dst_param, fetch result by manual mode
    CryptoRAM2mem(vce_id, result, result.len, BA414EP_MEMLOC_5, true);
  145326:	2201      	movs	r2, #1
  145328:	ab14      	add	r3, sp, #80	; 0x50
  14532a:	f04f 0c05 	mov.w	r12, #5
  14532e:	4628      	mov	r0, r5
  145330:	9e1e      	ldr	r6, [sp, #120]	; 0x78
  145332:	f843 af24 	str.w	r10, [r3, #36]!
  145336:	9202      	str	r2, [sp, #8]
  145338:	cb0e      	ldmia	r3, {r1, r2, r3}
  14533a:	f8cd c004 	str.w	r12, [r13, #4]
  14533e:	9600      	str	r6, [sp, #0]
  145340:	f7ff fee8 	bl	145114 <CryptoRAM2mem>
#endif

    // Location 5 -> M
    if (padding_type != ESEC_RSA_PADDING_NONE) {
  145344:	9b05      	ldr	r3, [sp, #20]
  145346:	2b00      	cmp	r3, #0
  145348:	f040 80a7 	bne.w	14549a <rsa_decrypt_blk+0x1fa>
        memcpy(result.addr, addr, *msg_len);

        ce_free(mem_n);
    }
    else {
        *msg_len = n.len;
  14534c:	9b21      	ldr	r3, [sp, #132]	; 0x84
  14534e:	601f      	str	r7, [r3, #0]
    }

    return error;
}
  145350:	4620      	mov	r0, r4
  145352:	b00b      	add	sp, #44	; 0x2c
  145354:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  145358:	b002      	add	sp, #8
  14535a:	4770      	bx	r14
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_CRT_DEC, size, BA414EP_BIGEND, BA414EP_SELCUR_NO_ACCELERATOR);
  14535c:	2400      	movs	r4, #0
  14535e:	2301      	movs	r3, #1
  145360:	463a      	mov	r2, r7
  145362:	2113      	movs	r1, #19
  145364:	9400      	str	r4, [sp, #0]
    error = mem2CryptoRAM_rev(vce_id, cipher, size, BA414EP_MEMLOC_4, true);
  145366:	4699      	mov	r9, r3
  145368:	9c1c      	ldr	r4, [sp, #112]	; 0x70
  14536a:	9406      	str	r4, [sp, #24]
  14536c:	4626      	mov	r6, r4
  14536e:	f8dd b068 	ldr.w	r11, [r13, #104]	; 0x68
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_CRT_DEC, size, BA414EP_BIGEND, BA414EP_SELCUR_NO_ACCELERATOR);
  145372:	f7fe feff 	bl	144174 <pke_set_command>
    error = mem2CryptoRAM_rev(vce_id, cipher, size, BA414EP_MEMLOC_4, true);
  145376:	2304      	movs	r3, #4
  145378:	4628      	mov	r0, r5
  14537a:	9700      	str	r7, [sp, #0]
  14537c:	e9cd 3901 	strd	r3, r9, [r13, #4]
  145380:	ab14      	add	r3, sp, #80	; 0x50
  145382:	cb0e      	ldmia	r3, {r1, r2, r3}
  145384:	f7ff fdae 	bl	144ee4 <mem2CryptoRAM_rev>
    if (error) {
  145388:	4604      	mov	r4, r0
  14538a:	2800      	cmp	r0, #0
  14538c:	d1e0      	bne.n	145350 <rsa_decrypt_blk+0xb0>
        uint32_t crtLen = n.len / 2;
  14538e:	fa27 f309 	lsr.w	r3, r7, r9
  145392:	461a      	mov	r2, r3
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_2, true);
  145394:	f10d 0868 	add.w	r8, r13, #104	; 0x68
  145398:	2302      	movs	r3, #2
  14539a:	4628      	mov	r0, r5
  14539c:	f8cd 9008 	str.w	r9, [r13, #8]
  1453a0:	9700      	str	r7, [sp, #0]
        private_key.len = crtLen;
  1453a2:	9207      	str	r2, [sp, #28]
  1453a4:	921b      	str	r2, [sp, #108]	; 0x6c
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_2, true);
  1453a6:	9301      	str	r3, [sp, #4]
  1453a8:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  1453ac:	f7ff fd9a 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  1453b0:	4604      	mov	r4, r0
  1453b2:	2800      	cmp	r0, #0
  1453b4:	d1cc      	bne.n	145350 <rsa_decrypt_blk+0xb0>
        if (!(private_key.addr_type & BLOCK_S_CONST_ADDR)) {
  1453b6:	00f3      	lsls	r3, r6, #3
  1453b8:	d432      	bmi.n	145420 <rsa_decrypt_blk+0x180>
            private_key.addr += crtLen;
  1453ba:	9e07      	ldr	r6, [sp, #28]
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_3, true);
  1453bc:	2403      	movs	r4, #3
  1453be:	f8cd 9008 	str.w	r9, [r13, #8]
  1453c2:	4628      	mov	r0, r5
  1453c4:	9700      	str	r7, [sp, #0]
            private_key.addr += crtLen;
  1453c6:	44b3      	add	r11, r6
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_3, true);
  1453c8:	f8cd b068 	str.w	r11, [r13, #104]	; 0x68
  1453cc:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  1453d0:	9401      	str	r4, [sp, #4]
  1453d2:	f7ff fd87 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  1453d6:	4604      	mov	r4, r0
  1453d8:	2800      	cmp	r0, #0
  1453da:	d1b9      	bne.n	145350 <rsa_decrypt_blk+0xb0>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_10, true);
  1453dc:	240a      	movs	r4, #10
            private_key.addr += crtLen;
  1453de:	44b3      	add	r11, r6
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_10, true);
  1453e0:	f8cd 9008 	str.w	r9, [r13, #8]
  1453e4:	4628      	mov	r0, r5
  1453e6:	f8cd b068 	str.w	r11, [r13, #104]	; 0x68
  1453ea:	9700      	str	r7, [sp, #0]
  1453ec:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  1453f0:	9401      	str	r4, [sp, #4]
  1453f2:	f7ff fd77 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  1453f6:	4604      	mov	r4, r0
  1453f8:	2800      	cmp	r0, #0
  1453fa:	d1a9      	bne.n	145350 <rsa_decrypt_blk+0xb0>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_11, true);
  1453fc:	240b      	movs	r4, #11
            private_key.addr += crtLen;
  1453fe:	44b3      	add	r11, r6
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_11, true);
  145400:	f8cd 9008 	str.w	r9, [r13, #8]
  145404:	4628      	mov	r0, r5
  145406:	f8cd b068 	str.w	r11, [r13, #104]	; 0x68
  14540a:	9700      	str	r7, [sp, #0]
  14540c:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  145410:	9401      	str	r4, [sp, #4]
  145412:	f7ff fd67 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  145416:	4604      	mov	r4, r0
  145418:	2800      	cmp	r0, #0
  14541a:	d199      	bne.n	145350 <rsa_decrypt_blk+0xb0>
            private_key.addr += crtLen;
  14541c:	44b3      	add	r11, r6
  14541e:	e028      	b.n	145472 <rsa_decrypt_blk+0x1d2>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_3, true);
  145420:	2303      	movs	r3, #3
  145422:	4628      	mov	r0, r5
  145424:	f8cd 9008 	str.w	r9, [r13, #8]
  145428:	e9cd 7300 	strd	r7, r3, [r13]
  14542c:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  145430:	f7ff fd58 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  145434:	4604      	mov	r4, r0
  145436:	2800      	cmp	r0, #0
  145438:	d18a      	bne.n	145350 <rsa_decrypt_blk+0xb0>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_10, true);
  14543a:	230a      	movs	r3, #10
  14543c:	4628      	mov	r0, r5
  14543e:	f8cd 9008 	str.w	r9, [r13, #8]
  145442:	e9cd 7300 	strd	r7, r3, [r13]
  145446:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  14544a:	f7ff fd4b 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  14544e:	4604      	mov	r4, r0
  145450:	2800      	cmp	r0, #0
  145452:	f47f af7d 	bne.w	145350 <rsa_decrypt_blk+0xb0>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_11, true);
  145456:	230b      	movs	r3, #11
  145458:	4628      	mov	r0, r5
  14545a:	f8cd 9008 	str.w	r9, [r13, #8]
  14545e:	e9cd 7300 	strd	r7, r3, [r13]
  145462:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  145466:	f7ff fd3d 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  14546a:	4604      	mov	r4, r0
  14546c:	2800      	cmp	r0, #0
  14546e:	f47f af6f 	bne.w	145350 <rsa_decrypt_blk+0xb0>
        error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_12, true);
  145472:	f04f 0c01 	mov.w	r12, #1
  145476:	240c      	movs	r4, #12
  145478:	9b06      	ldr	r3, [sp, #24]
  14547a:	4628      	mov	r0, r5
  14547c:	f8cd b068 	str.w	r11, [r13, #104]	; 0x68
  145480:	931c      	str	r3, [sp, #112]	; 0x70
  145482:	9700      	str	r7, [sp, #0]
  145484:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
  145488:	e9cd 4c01 	strd	r4, r12, [r13, #4]
  14548c:	f7ff fd2a 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  145490:	4604      	mov	r4, r0
  145492:	2800      	cmp	r0, #0
  145494:	f43f af42 	beq.w	14531c <rsa_decrypt_blk+0x7c>
  145498:	e75a      	b.n	145350 <rsa_decrypt_blk+0xb0>
        mem_n = ce_malloc(RSA_MAX_SIZE + 4);
  14549a:	f44f 7001 	mov.w	r0, #516	; 0x204
            return CRYPTOLIB_PK_N_NOTVALID;
  14549e:	2415      	movs	r4, #21
        mem_n = ce_malloc(RSA_MAX_SIZE + 4);
  1454a0:	f7fe f820 	bl	1434e4 <ce_malloc>
        if (mem_n != NULL) {
  1454a4:	4680      	mov	r8, r0
  1454a6:	2800      	cmp	r0, #0
  1454a8:	f43f af52 	beq.w	145350 <rsa_decrypt_blk+0xb0>
            msg_padding = mem_n->ptr;
  1454ac:	6883      	ldr	r3, [r0, #8]
        memcpy(msg_padding, result.addr, *msg_len);
  1454ae:	4651      	mov	r1, r10
  1454b0:	4618      	mov	r0, r3
  1454b2:	9b21      	ldr	r3, [sp, #132]	; 0x84
  1454b4:	681a      	ldr	r2, [r3, #0]
  1454b6:	f00d ed5c 	blx	152f70 <memcpy>
        if (padding_type == ESEC_RSA_PADDING_OAEP) {
  1454ba:	9a05      	ldr	r2, [sp, #20]
  1454bc:	2a01      	cmp	r2, #1
        memcpy(msg_padding, result.addr, *msg_len);
  1454be:	4603      	mov	r3, r0
        if (padding_type == ESEC_RSA_PADDING_OAEP) {
  1454c0:	d010      	beq.n	1454e4 <rsa_decrypt_blk+0x244>
            error |= rsa_pad_eme_pkcs_decode(n.len, msg_padding, &addr, (size_t*)msg_len);
  1454c2:	4601      	mov	r1, r0
  1454c4:	aa09      	add	r2, sp, #36	; 0x24
  1454c6:	9b21      	ldr	r3, [sp, #132]	; 0x84
  1454c8:	4638      	mov	r0, r7
  1454ca:	f7ff f979 	bl	1447c0 <rsa_pad_eme_pkcs_decode>
  1454ce:	4604      	mov	r4, r0
        memcpy(result.addr, addr, *msg_len);
  1454d0:	9b21      	ldr	r3, [sp, #132]	; 0x84
  1454d2:	4650      	mov	r0, r10
  1454d4:	9909      	ldr	r1, [sp, #36]	; 0x24
  1454d6:	681a      	ldr	r2, [r3, #0]
  1454d8:	f00d ed4a 	blx	152f70 <memcpy>
        ce_free(mem_n);
  1454dc:	4640      	mov	r0, r8
  1454de:	f7fe f845 	bl	14356c <ce_free>
  1454e2:	e735      	b.n	145350 <rsa_decrypt_blk+0xb0>
            error |= rsa_pad_eme_oaep_decode(vce_id, n.len, hashType, msg_padding, &addr, (size_t*)msg_len);
  1454e4:	9921      	ldr	r1, [sp, #132]	; 0x84
  1454e6:	aa09      	add	r2, sp, #36	; 0x24
  1454e8:	9101      	str	r1, [sp, #4]
  1454ea:	4628      	mov	r0, r5
  1454ec:	9200      	str	r2, [sp, #0]
  1454ee:	4639      	mov	r1, r7
  1454f0:	9a22      	ldr	r2, [sp, #136]	; 0x88
  1454f2:	f7ff f877 	bl	1445e4 <rsa_pad_eme_oaep_decode>
  1454f6:	4604      	mov	r4, r0
  1454f8:	e7ea      	b.n	1454d0 <rsa_decrypt_blk+0x230>
  1454fa:	bf00      	nop

001454fc <rsa_signature_generation_blk>:
                                      block_t message,
                                      block_t result,
                                      block_t n,
                                      block_t private_key,
                                      uint32_t salt_length)
{
  1454fc:	b082      	sub	sp, #8
  1454fe:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint8_t* msg_padding;
    struct mem_node* mem_n_1;
    block_t hash_block;

    //Checks that the algoritm is valid for signature
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  145502:	1ed4      	subs	r4, r2, #3
{
  145504:	b095      	sub	sp, #84	; 0x54
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  145506:	2a00      	cmp	r2, #0
  145508:	bf18      	it	ne
  14550a:	2c01      	cmpne	r4, #1
  14550c:	bf8c      	ite	hi
  14550e:	2401      	movhi	r4, #1
  145510:	2400      	movls	r4, #0
{
  145512:	931f      	str	r3, [sp, #124]	; 0x7c
            padding_type != ESEC_RSA_PADDING_PSS) {
        return CRYPTOLIB_INVALID_PARAM;
  145514:	bf88      	it	hi
  145516:	2409      	movhi	r4, #9
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  145518:	f200 8094 	bhi.w	145644 <rsa_signature_generation_blk+0x148>
  14551c:	4605      	mov	r5, r0
    }

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  14551e:	2040      	movs	r0, #64	; 0x40
  145520:	460e      	mov	r6, r1
  145522:	4693      	mov	r11, r2
  145524:	f8dd 8098 	ldr.w	r8, [r13, #152]	; 0x98
  145528:	f7fd ffdc 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  14552c:	4607      	mov	r7, r0
  14552e:	2800      	cmp	r0, #0
  145530:	f000 8092 	beq.w	145658 <rsa_signature_generation_blk+0x15c>
  145534:	2240      	movs	r2, #64	; 0x40
  145536:	f04f 0a03 	mov.w	r10, #3
        hash = mem_n->ptr;
  14553a:	f8d0 9008 	ldr.w	r9, [r0, #8]
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    /*Calculate hash of the message*/
    error |= hash_blk(sha_type, vce_id, block_t_convert(NULL, 0, 0), message, block_t_convert(hash, MAX_DIGESTSIZE, EXT_MEM));
  14553e:	ab1f      	add	r3, sp, #124	; 0x7c
  145540:	9212      	str	r2, [sp, #72]	; 0x48
  145542:	aa14      	add	r2, sp, #80	; 0x50
  145544:	f8cd a04c 	str.w	r10, [r13, #76]	; 0x4c
  145548:	f10d 0c10 	add.w	r12, r13, #16
  14554c:	f8cd 9044 	str.w	r9, [r13, #68]	; 0x44
  145550:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  145554:	e88c 0007 	stmia.w	r12, {r0, r1, r2}
  145558:	f10d 0c38 	add.w	r12, r13, #56	; 0x38
  14555c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145560:	e9cd 440e 	strd	r4, r4, [r13, #56]	; 0x38
  145564:	ab01      	add	r3, sp, #4
  145566:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14556a:	9400      	str	r4, [sp, #0]
  14556c:	4629      	mov	r1, r5
  14556e:	9410      	str	r4, [sp, #64]	; 0x40
  145570:	4630      	mov	r0, r6
  145572:	e89c 000c 	ldmia.w	r12, {r2, r3}
  145576:	f7fe fa37 	bl	1439e8 <hash_blk>

    if (error) {
  14557a:	4604      	mov	r4, r0
  14557c:	2800      	cmp	r0, #0
  14557e:	d167      	bne.n	145650 <rsa_signature_generation_blk+0x154>
        return error;
    }

    int padError = 0;

    mem_n_1 = ce_malloc(RSA_MAX_SIZE);
  145580:	f44f 7000 	mov.w	r0, #512	; 0x200
  145584:	f7fd ffae 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  145588:	9009      	str	r0, [sp, #36]	; 0x24
  14558a:	2800      	cmp	r0, #0
  14558c:	f000 8091 	beq.w	1456b2 <rsa_signature_generation_blk+0x1b6>
        msg_padding = mem_n_1->ptr;
  145590:	6884      	ldr	r4, [r0, #8]
    else {
        ce_free(mem_n);
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    if (padding_type == ESEC_RSA_PADDING_EMSA_PKCS) {
  145592:	f1bb 0f03 	cmp.w	r11, #3
  145596:	d07c      	beq.n	145692 <rsa_signature_generation_blk+0x196>
        padError = rsa_pad_emsa_pkcs_encode(vce_id, n.len, sha_type, msg_padding, hash);
        hash_block.addr   = msg_padding;
        hash_block.len    = n.len;
        hash_block.addr_type  = EXT_MEM;
    }
    else if (padding_type == ESEC_RSA_PADDING_PSS) {
  145598:	f1bb 0f04 	cmp.w	r11, #4
  14559c:	d05e      	beq.n	14565c <rsa_signature_generation_blk+0x160>
        hash_block.addr   = msg_padding;
        hash_block.len    = n.len;
        hash_block.addr_type  = EXT_MEM;
    }
    else { //No padding
        rsa_pad_zeros(msg_padding, n.len, hash, hash_get_digest_size(sha_type));
  14559e:	4630      	mov	r0, r6
  1455a0:	f7fe fa18 	bl	1439d4 <hash_get_digest_size>
  1455a4:	464a      	mov	r2, r9
  1455a6:	4641      	mov	r1, r8
  1455a8:	4603      	mov	r3, r0
  1455aa:	4620      	mov	r0, r4
  1455ac:	f7ff fb7c 	bl	144ca8 <rsa_pad_zeros>
        hash_block.addr   = msg_padding;
        hash_block.len    = n.len;
  1455b0:	e9cd 480b 	strd	r4, r8, [r13, #44]	; 0x2c
        hash_block.addr_type  = EXT_MEM;
  1455b4:	f8cd a034 	str.w	r10, [r13, #52]	; 0x34
        ce_free(mem_n_1);
        return padError;
    }

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_SIGN_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1455b8:	2400      	movs	r4, #0
  1455ba:	4642      	mov	r2, r8
  1455bc:	4623      	mov	r3, r4
  1455be:	2116      	movs	r1, #22
  1455c0:	9400      	str	r4, [sp, #0]
  1455c2:	4628      	mov	r0, r5
  1455c4:	f7fe fdd6 	bl	144174 <pke_set_command>

#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_11, (addr_t)(result.addr), result.addr_type);
#endif
    // Location 0 -> N
    error = mem2CryptoRAM_rev(vce_id, n, size, BA414EP_MEMLOC_0, true);
  1455c8:	2601      	movs	r6, #1
  1455ca:	9401      	str	r4, [sp, #4]
  1455cc:	ab25      	add	r3, sp, #148	; 0x94
  1455ce:	f8cd 8098 	str.w	r8, [r13, #152]	; 0x98
  1455d2:	4628      	mov	r0, r5
  1455d4:	f8cd 8000 	str.w	r8, [r13]
  1455d8:	cb0e      	ldmia	r3, {r1, r2, r3}
  1455da:	9602      	str	r6, [sp, #8]
  1455dc:	f7ff fc82 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  1455e0:	4604      	mov	r4, r0
  1455e2:	bb48      	cbnz	r0, 145638 <rsa_signature_generation_blk+0x13c>
    }

    private_key.len = n.len;

    // Location 6 -> Private key
    error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_6, true);
  1455e4:	2406      	movs	r4, #6
  1455e6:	ab28      	add	r3, sp, #160	; 0xa0
    private_key.len = n.len;
  1455e8:	f8cd 80a4 	str.w	r8, [r13, #164]	; 0xa4
    error = mem2CryptoRAM_rev(vce_id, private_key, size, BA414EP_MEMLOC_6, true);
  1455ec:	4628      	mov	r0, r5
  1455ee:	9602      	str	r6, [sp, #8]
  1455f0:	f8cd 8000 	str.w	r8, [r13]
  1455f4:	cb0e      	ldmia	r3, {r1, r2, r3}
  1455f6:	9401      	str	r4, [sp, #4]
  1455f8:	f7ff fc74 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  1455fc:	4604      	mov	r4, r0
  1455fe:	b9d8      	cbnz	r0, 145638 <rsa_signature_generation_blk+0x13c>
        ce_free(mem_n_1);
        return error;
    }

    // Location 12 -> hash
    error = mem2CryptoRAM_rev(vce_id, hash_block, size, BA414EP_MEMLOC_12, true);
  145600:	240c      	movs	r4, #12
  145602:	ab0b      	add	r3, sp, #44	; 0x2c
  145604:	9602      	str	r6, [sp, #8]
  145606:	4628      	mov	r0, r5
  145608:	f8cd 8000 	str.w	r8, [r13]
  14560c:	cb0e      	ldmia	r3, {r1, r2, r3}
  14560e:	9401      	str	r4, [sp, #4]
  145610:	f7ff fc68 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  145614:	4604      	mov	r4, r0
  145616:	b978      	cbnz	r0, 145638 <rsa_signature_generation_blk+0x13c>
        ce_free(mem_n_1);
        return error;
    }

    // Start BA414EP
    error |= pke_start_wait_status(vce_id);
  145618:	4628      	mov	r0, r5
  14561a:	f7fe fdc7 	bl	1441ac <pke_start_wait_status>

    if (error) {
  14561e:	4604      	mov	r4, r0
  145620:	b950      	cbnz	r0, 145638 <rsa_signature_generation_blk+0x13c>
    }

    // Fetch result optional: pke_set_dst_param, fetch result by manual mode
#if AUTO_OUTPUT_BY_CE
#else
    CryptoRAM2mem(vce_id, result, result.len, BA414EP_MEMLOC_11, true);
  145622:	f04f 0c0b 	mov.w	r12, #11
  145626:	ab22      	add	r3, sp, #136	; 0x88
  145628:	9602      	str	r6, [sp, #8]
  14562a:	4628      	mov	r0, r5
  14562c:	9d23      	ldr	r5, [sp, #140]	; 0x8c
  14562e:	cb0e      	ldmia	r3, {r1, r2, r3}
  145630:	e9cd 5c00 	strd	r5, r12, [r13]
  145634:	f7ff fd6e 	bl	145114 <CryptoRAM2mem>
#endif
    ce_free(mem_n);
  145638:	4638      	mov	r0, r7
  14563a:	f7fd ff97 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  14563e:	9809      	ldr	r0, [sp, #36]	; 0x24
  145640:	f7fd ff94 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  145644:	4620      	mov	r0, r4
  145646:	b015      	add	sp, #84	; 0x54
  145648:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14564c:	b002      	add	sp, #8
  14564e:	4770      	bx	r14
        ce_free(mem_n);
  145650:	4638      	mov	r0, r7
  145652:	f7fd ff8b 	bl	14356c <ce_free>
        return error;
  145656:	e7f5      	b.n	145644 <rsa_signature_generation_blk+0x148>
        return CRYPTOLIB_PK_N_NOTVALID;
  145658:	2415      	movs	r4, #21
  14565a:	e7f3      	b.n	145644 <rsa_signature_generation_blk+0x148>
        padError = rsa_pad_emsa_pss_encode(vce_id, n.len, sha_type, msg_padding, hash, n.addr[0],
  14565c:	9b2b      	ldr	r3, [sp, #172]	; 0xac
  14565e:	4632      	mov	r2, r6
  145660:	9302      	str	r3, [sp, #8]
  145662:	4628      	mov	r0, r5
  145664:	9925      	ldr	r1, [sp, #148]	; 0x94
  145666:	4623      	mov	r3, r4
  145668:	7809      	ldrb	r1, [r1, #0]
  14566a:	e9cd 9100 	strd	r9, r1, [r13]
  14566e:	4641      	mov	r1, r8
  145670:	f7ff f974 	bl	14495c <rsa_pad_emsa_pss_encode>
        hash_block.len    = n.len;
  145674:	e9cd 480b 	strd	r4, r8, [r13, #44]	; 0x2c
        hash_block.addr_type  = EXT_MEM;
  145678:	f8cd a034 	str.w	r10, [r13, #52]	; 0x34
        padError = rsa_pad_emsa_pss_encode(vce_id, n.len, sha_type, msg_padding, hash, n.addr[0],
  14567c:	4603      	mov	r3, r0
    if (padError) {
  14567e:	2b00      	cmp	r3, #0
  145680:	d09a      	beq.n	1455b8 <rsa_signature_generation_blk+0xbc>
        ce_free(mem_n);
  145682:	4638      	mov	r0, r7
        return padError;
  145684:	461c      	mov	r4, r3
        ce_free(mem_n);
  145686:	f7fd ff71 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  14568a:	9809      	ldr	r0, [sp, #36]	; 0x24
  14568c:	f7fd ff6e 	bl	14356c <ce_free>
        return padError;
  145690:	e7d8      	b.n	145644 <rsa_signature_generation_blk+0x148>
        padError = rsa_pad_emsa_pkcs_encode(vce_id, n.len, sha_type, msg_padding, hash);
  145692:	4623      	mov	r3, r4
  145694:	4632      	mov	r2, r6
  145696:	f8cd 9000 	str.w	r9, [r13]
  14569a:	4641      	mov	r1, r8
  14569c:	4628      	mov	r0, r5
  14569e:	f7ff f8bd 	bl	14481c <rsa_pad_emsa_pkcs_encode>
        hash_block.len    = n.len;
  1456a2:	e9cd 480b 	strd	r4, r8, [r13, #44]	; 0x2c
        hash_block.addr_type  = EXT_MEM;
  1456a6:	f8cd b034 	str.w	r11, [r13, #52]	; 0x34
        padError = rsa_pad_emsa_pkcs_encode(vce_id, n.len, sha_type, msg_padding, hash);
  1456aa:	4603      	mov	r3, r0
    if (padError) {
  1456ac:	2b00      	cmp	r3, #0
  1456ae:	d083      	beq.n	1455b8 <rsa_signature_generation_blk+0xbc>
  1456b0:	e7e7      	b.n	145682 <rsa_signature_generation_blk+0x186>
        ce_free(mem_n);
  1456b2:	4638      	mov	r0, r7
        return CRYPTOLIB_PK_N_NOTVALID;
  1456b4:	2415      	movs	r4, #21
        ce_free(mem_n);
  1456b6:	f7fd ff59 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  1456ba:	e7c3      	b.n	145644 <rsa_signature_generation_blk+0x148>

001456bc <rsa_signature_verification_blk>:
                                        block_t message,
                                        block_t n,
                                        block_t public_expo,
                                        block_t signature,
                                        uint32_t salt_length)
{
  1456bc:	b082      	sub	sp, #8
  1456be:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint8_t* msg_padding;
    struct mem_node* mem_n_1;
    block_t hash_block;

    //Checks that the algoritm is valid for signature
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  1456c2:	1ed5      	subs	r5, r2, #3
{
  1456c4:	b097      	sub	sp, #92	; 0x5c
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  1456c6:	2a00      	cmp	r2, #0
  1456c8:	bf18      	it	ne
  1456ca:	2d01      	cmpne	r5, #1
{
  1456cc:	9321      	str	r3, [sp, #132]	; 0x84
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  1456ce:	bf8a      	itet	hi
  1456d0:	2501      	movhi	r5, #1
  1456d2:	2500      	movls	r5, #0
            padding_type != ESEC_RSA_PADDING_PSS) {
        return CRYPTOLIB_INVALID_PARAM;
  1456d4:	f04f 0b09 	movhi.w	r11, #9
    if (padding_type != ESEC_RSA_PADDING_NONE && padding_type != ESEC_RSA_PADDING_EMSA_PKCS &&
  1456d8:	f200 8093 	bhi.w	145802 <rsa_signature_verification_blk+0x146>
  1456dc:	9b2b      	ldr	r3, [sp, #172]	; 0xac
  1456de:	4606      	mov	r6, r0
    }

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  1456e0:	2040      	movs	r0, #64	; 0x40
  1456e2:	460f      	mov	r7, r1
  1456e4:	4614      	mov	r4, r2

    if (mem_n != NULL) {
        hash = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  1456e6:	f04f 0b15 	mov.w	r11, #21
  1456ea:	f8dd 9094 	ldr.w	r9, [r13, #148]	; 0x94
  1456ee:	9309      	str	r3, [sp, #36]	; 0x24
    mem_n = ce_malloc(MAX_DIGESTSIZE);
  1456f0:	f7fd fef8 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  1456f4:	4680      	mov	r8, r0
  1456f6:	2800      	cmp	r0, #0
  1456f8:	f000 8083 	beq.w	145802 <rsa_signature_verification_blk+0x146>
        hash = mem_n->ptr;
  1456fc:	f8d8 3008 	ldr.w	r3, [r8, #8]
    }

    hash_block = block_t_convert(hash, hash_get_digest_size(sha_type), EXT_MEM);
  145700:	4638      	mov	r0, r7
        hash = mem_n->ptr;
  145702:	9308      	str	r3, [sp, #32]
    hash_block = block_t_convert(hash, hash_get_digest_size(sha_type), EXT_MEM);
  145704:	f7fe f966 	bl	1439d4 <hash_get_digest_size>
  145708:	2203      	movs	r2, #3

    error = hash_blk(sha_type, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  14570a:	ab21      	add	r3, sp, #132	; 0x84
  14570c:	9908      	ldr	r1, [sp, #32]
  14570e:	f10d 0c10 	add.w	r12, r13, #16
  145712:	910d      	str	r1, [sp, #52]	; 0x34
  145714:	e9cd 020e 	strd	r0, r2, [r13, #56]	; 0x38
  145718:	aa0d      	add	r2, sp, #52	; 0x34
    hash_block = block_t_convert(hash, hash_get_digest_size(sha_type), EXT_MEM);
  14571a:	4682      	mov	r10, r0
    error = hash_blk(sha_type, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  14571c:	ca07      	ldmia	r2, {r0, r1, r2}
  14571e:	e88c 0007 	stmia.w	r12, {r0, r1, r2}
  145722:	f10d 0c40 	add.w	r12, r13, #64	; 0x40
  145726:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  14572a:	e9cd 5510 	strd	r5, r5, [r13, #64]	; 0x40
  14572e:	ab01      	add	r3, sp, #4
  145730:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  145734:	9500      	str	r5, [sp, #0]
  145736:	4631      	mov	r1, r6
  145738:	e89c 000c 	ldmia.w	r12, {r2, r3}
  14573c:	4638      	mov	r0, r7
  14573e:	9512      	str	r5, [sp, #72]	; 0x48
  145740:	f7fe f952 	bl	1439e8 <hash_blk>

    if (error) {
  145744:	4683      	mov	r11, r0
  145746:	2800      	cmp	r0, #0
  145748:	d161      	bne.n	14580e <rsa_signature_verification_blk+0x152>
        return error;
    }

    int padError = 0;

    mem_n_1 = ce_malloc(RSA_MAX_SIZE);
  14574a:	f44f 7000 	mov.w	r0, #512	; 0x200
  14574e:	f7fd fec9 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  145752:	900a      	str	r0, [sp, #40]	; 0x28
  145754:	2800      	cmp	r0, #0
  145756:	f000 80bb 	beq.w	1458d0 <rsa_signature_verification_blk+0x214>
        msg_padding = mem_n_1->ptr;
  14575a:	6883      	ldr	r3, [r0, #8]
    else {
        ce_free(mem_n);
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    if (padding_type == ESEC_RSA_PADDING_EMSA_PKCS) {
  14575c:	2c03      	cmp	r4, #3
        msg_padding = mem_n_1->ptr;
  14575e:	930b      	str	r3, [sp, #44]	; 0x2c
    if (padding_type == ESEC_RSA_PADDING_EMSA_PKCS) {
  145760:	d059      	beq.n	145816 <rsa_signature_verification_blk+0x15a>
        padError = rsa_pad_emsa_pkcs_encode(vce_id, n.len, sha_type, msg_padding, hash_block.addr);
        hash_block = block_t_convert(msg_padding, n.len, 0);
    }
    else if (padding_type == ESEC_RSA_PADDING_NONE) { //No padding
  145762:	2c00      	cmp	r4, #0
  145764:	d073      	beq.n	14584e <rsa_signature_verification_blk+0x192>
        ce_free(mem_n_1);
        return padError;
    }

    // Set command to enable byte-swap
    if (padding_type != ESEC_RSA_PADDING_PSS) {
  145766:	2c04      	cmp	r4, #4
  145768:	d168      	bne.n	14583c <rsa_signature_verification_blk+0x180>
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_SIGN_VERIF, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
    }
    else {
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_ENC, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  14576a:	f8cd b000 	str.w	r11, [r13]
  14576e:	465b      	mov	r3, r11
  145770:	464a      	mov	r2, r9
  145772:	2114      	movs	r1, #20
  145774:	4630      	mov	r0, r6
  145776:	f7fe fcfd 	bl	144174 <pke_set_command>
    }

    // Location 0 -> Modulus N
    error = mem2CryptoRAM_rev(vce_id, n, size, BA414EP_MEMLOC_0, true);
  14577a:	f04f 0c00 	mov.w	r12, #0
  14577e:	ab24      	add	r3, sp, #144	; 0x90
  145780:	2501      	movs	r5, #1
  145782:	4630      	mov	r0, r6
  145784:	f8cd 9000 	str.w	r9, [r13]
  145788:	cb0e      	ldmia	r3, {r1, r2, r3}
  14578a:	e9cd c501 	strd	r12, r5, [r13, #4]
  14578e:	f7ff fba9 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  145792:	4683      	mov	r11, r0
  145794:	bb78      	cbnz	r0, 1457f6 <rsa_signature_verification_blk+0x13a>
        ce_free(mem_n_1);
        return error;
    }

    // Location 8 -> Public exponent
    error = mem2CryptoRAM_rev(vce_id, public_expo, size, BA414EP_MEMLOC_8, true);
  145796:	f04f 0c08 	mov.w	r12, #8
  14579a:	ab27      	add	r3, sp, #156	; 0x9c
  14579c:	9502      	str	r5, [sp, #8]
  14579e:	4630      	mov	r0, r6
  1457a0:	f8cd 9000 	str.w	r9, [r13]
  1457a4:	cb0e      	ldmia	r3, {r1, r2, r3}
  1457a6:	f8cd c004 	str.w	r12, [r13, #4]
  1457aa:	f7ff fb9b 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  1457ae:	4683      	mov	r11, r0
  1457b0:	bb08      	cbnz	r0, 1457f6 <rsa_signature_verification_blk+0x13a>
        ce_free(mem_n);
        ce_free(mem_n_1);
        return error;
    }

    if (padding_type != ESEC_RSA_PADDING_PSS) {
  1457b2:	2c04      	cmp	r4, #4
        // Location 11 -> Signature
        error = mem2CryptoRAM_rev(vce_id, signature, signature.len, BA414EP_MEMLOC_11, true);
  1457b4:	ab2a      	add	r3, sp, #168	; 0xa8
    if (padding_type != ESEC_RSA_PADDING_PSS) {
  1457b6:	d05a      	beq.n	14586e <rsa_signature_verification_blk+0x1b2>
        error = mem2CryptoRAM_rev(vce_id, signature, signature.len, BA414EP_MEMLOC_11, true);
  1457b8:	240b      	movs	r4, #11
  1457ba:	4630      	mov	r0, r6
  1457bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
  1457be:	9502      	str	r5, [sp, #8]
  1457c0:	9200      	str	r2, [sp, #0]
  1457c2:	cb0e      	ldmia	r3, {r1, r2, r3}
  1457c4:	9401      	str	r4, [sp, #4]
  1457c6:	f7ff fb8d 	bl	144ee4 <mem2CryptoRAM_rev>

        if (error) {
  1457ca:	4683      	mov	r11, r0
  1457cc:	b998      	cbnz	r0, 1457f6 <rsa_signature_verification_blk+0x13a>
            ce_free(mem_n_1);
            return error;
        }

        // Location 12 -> Hash
        error = mem2CryptoRAM_rev(vce_id, hash_block, hash_block.len, BA414EP_MEMLOC_12, true);
  1457ce:	9b08      	ldr	r3, [sp, #32]
  1457d0:	240c      	movs	r4, #12
  1457d2:	930d      	str	r3, [sp, #52]	; 0x34
  1457d4:	ab0d      	add	r3, sp, #52	; 0x34
  1457d6:	f8cd a038 	str.w	r10, [r13, #56]	; 0x38
  1457da:	4630      	mov	r0, r6
  1457dc:	9502      	str	r5, [sp, #8]
  1457de:	f8cd a000 	str.w	r10, [r13]
  1457e2:	cb0e      	ldmia	r3, {r1, r2, r3}
  1457e4:	9401      	str	r4, [sp, #4]
  1457e6:	f7ff fb7d 	bl	144ee4 <mem2CryptoRAM_rev>

        if (error) {
  1457ea:	4683      	mov	r11, r0
  1457ec:	b918      	cbnz	r0, 1457f6 <rsa_signature_verification_blk+0x13a>
            return error;
        }
    }

    // Start BA414EP
    error = pke_start_wait_status(vce_id);
  1457ee:	4630      	mov	r0, r6
  1457f0:	f7fe fcdc 	bl	1441ac <pke_start_wait_status>

    if (error) {
  1457f4:	4683      	mov	r11, r0
        CryptoRAM2mem_rev(vce_id, block_t_convert(msg_padding, n.len, 0), n.len, BA414EP_MEMLOC_4, true);
        error = rsa_pad_emsa_pss_decode(vce_id, n.len, sha_type, msg_padding, hash_block.addr,
                                        salt_length, n.addr[0]);
    }

    ce_free(mem_n);
  1457f6:	4640      	mov	r0, r8
  1457f8:	f7fd feb8 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  1457fc:	980a      	ldr	r0, [sp, #40]	; 0x28
  1457fe:	f7fd feb5 	bl	14356c <ce_free>
    return error;
}
  145802:	4658      	mov	r0, r11
  145804:	b017      	add	sp, #92	; 0x5c
  145806:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14580a:	b002      	add	sp, #8
  14580c:	4770      	bx	r14
        ce_free(mem_n);
  14580e:	4640      	mov	r0, r8
  145810:	f7fd feac 	bl	14356c <ce_free>
        return error;
  145814:	e7f5      	b.n	145802 <rsa_signature_verification_blk+0x146>
        padError = rsa_pad_emsa_pkcs_encode(vce_id, n.len, sha_type, msg_padding, hash_block.addr);
  145816:	f8dd a02c 	ldr.w	r10, [r13, #44]	; 0x2c
  14581a:	463a      	mov	r2, r7
  14581c:	9b08      	ldr	r3, [sp, #32]
  14581e:	4649      	mov	r1, r9
  145820:	9300      	str	r3, [sp, #0]
  145822:	4630      	mov	r0, r6
  145824:	4653      	mov	r3, r10
  145826:	f7fe fff9 	bl	14481c <rsa_pad_emsa_pkcs_encode>
        hash_block = block_t_convert(msg_padding, n.len, 0);
  14582a:	e9cd a90d 	strd	r10, r9, [r13, #52]	; 0x34
  14582e:	950f      	str	r5, [sp, #60]	; 0x3c
  145830:	4653      	mov	r3, r10
    if (padError) {
  145832:	4683      	mov	r11, r0
  145834:	2800      	cmp	r0, #0
  145836:	d1de      	bne.n	1457f6 <rsa_signature_verification_blk+0x13a>
        hash_block = block_t_convert(msg_padding, n.len, 0);
  145838:	9308      	str	r3, [sp, #32]
  14583a:	46ca      	mov	r10, r9
        pke_set_command(vce_id, BA414EP_OPTYPE_RSA_SIGN_VERIF, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  14583c:	2000      	movs	r0, #0
  14583e:	464a      	mov	r2, r9
  145840:	4603      	mov	r3, r0
  145842:	2117      	movs	r1, #23
  145844:	9000      	str	r0, [sp, #0]
  145846:	4630      	mov	r0, r6
  145848:	f7fe fc94 	bl	144174 <pke_set_command>
  14584c:	e795      	b.n	14577a <rsa_signature_verification_blk+0xbe>
        rsa_pad_zeros(msg_padding, n.len, hash_block.addr, hash_get_digest_size(sha_type));
  14584e:	4638      	mov	r0, r7
        hash_block = block_t_convert(msg_padding, n.len, 0);
  145850:	46ca      	mov	r10, r9
        rsa_pad_zeros(msg_padding, n.len, hash_block.addr, hash_get_digest_size(sha_type));
  145852:	f7fe f8bf 	bl	1439d4 <hash_get_digest_size>
  145856:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  145858:	9a08      	ldr	r2, [sp, #32]
  14585a:	4649      	mov	r1, r9
  14585c:	4603      	mov	r3, r0
  14585e:	4628      	mov	r0, r5
  145860:	f7ff fa22 	bl	144ca8 <rsa_pad_zeros>
        hash_block = block_t_convert(msg_padding, n.len, 0);
  145864:	9508      	str	r5, [sp, #32]
  145866:	e9cd 590d 	strd	r5, r9, [r13, #52]	; 0x34
  14586a:	940f      	str	r4, [sp, #60]	; 0x3c
  14586c:	e7e6      	b.n	14583c <rsa_signature_verification_blk+0x180>
        error = mem2CryptoRAM_rev(vce_id, signature, signature.len, BA414EP_MEMLOC_5, true);
  14586e:	f04f 0c05 	mov.w	r12, #5
  145872:	4630      	mov	r0, r6
  145874:	9a09      	ldr	r2, [sp, #36]	; 0x24
  145876:	9502      	str	r5, [sp, #8]
  145878:	9200      	str	r2, [sp, #0]
  14587a:	cb0e      	ldmia	r3, {r1, r2, r3}
  14587c:	f8cd c004 	str.w	r12, [r13, #4]
  145880:	f7ff fb30 	bl	144ee4 <mem2CryptoRAM_rev>
        if (error) {
  145884:	4683      	mov	r11, r0
  145886:	2800      	cmp	r0, #0
  145888:	d1b5      	bne.n	1457f6 <rsa_signature_verification_blk+0x13a>
    error = pke_start_wait_status(vce_id);
  14588a:	4630      	mov	r0, r6
  14588c:	f7fe fc8e 	bl	1441ac <pke_start_wait_status>
    if (error) {
  145890:	4683      	mov	r11, r0
  145892:	2800      	cmp	r0, #0
  145894:	d1af      	bne.n	1457f6 <rsa_signature_verification_blk+0x13a>
  145896:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        CryptoRAM2mem_rev(vce_id, block_t_convert(msg_padding, n.len, 0), n.len, BA414EP_MEMLOC_4, true);
  145898:	aa16      	add	r2, sp, #88	; 0x58
  14589a:	e9cd 4501 	strd	r4, r5, [r13, #4]
  14589e:	4630      	mov	r0, r6
  1458a0:	e9cd 9b14 	strd	r9, r11, [r13, #80]	; 0x50
  1458a4:	9313      	str	r3, [sp, #76]	; 0x4c
  1458a6:	f8cd 9000 	str.w	r9, [r13]
  1458aa:	e912 000e 	ldmdb	r2, {r1, r2, r3}
  1458ae:	f7ff fb9d 	bl	144fec <CryptoRAM2mem_rev>
        error = rsa_pad_emsa_pss_decode(vce_id, n.len, sha_type, msg_padding, hash_block.addr,
  1458b2:	9d2d      	ldr	r5, [sp, #180]	; 0xb4
  1458b4:	463a      	mov	r2, r7
                                        salt_length, n.addr[0]);
  1458b6:	9c24      	ldr	r4, [sp, #144]	; 0x90
        error = rsa_pad_emsa_pss_decode(vce_id, n.len, sha_type, msg_padding, hash_block.addr,
  1458b8:	7824      	ldrb	r4, [r4, #0]
  1458ba:	e9cd 5401 	strd	r5, r4, [r13, #4]
  1458be:	4649      	mov	r1, r9
  1458c0:	9c08      	ldr	r4, [sp, #32]
  1458c2:	4630      	mov	r0, r6
  1458c4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1458c6:	9400      	str	r4, [sp, #0]
  1458c8:	f7ff f90e 	bl	144ae8 <rsa_pad_emsa_pss_decode>
  1458cc:	4683      	mov	r11, r0
  1458ce:	e792      	b.n	1457f6 <rsa_signature_verification_blk+0x13a>
        ce_free(mem_n);
  1458d0:	4640      	mov	r0, r8
        return CRYPTOLIB_PK_N_NOTVALID;
  1458d2:	f04f 0b15 	mov.w	r11, #21
        ce_free(mem_n);
  1458d6:	f7fd fe49 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  1458da:	e792      	b.n	145802 <rsa_signature_verification_blk+0x146>

001458dc <rsa_private_key_generation_blk>:
                                        block_t public_expo,
                                        block_t n,
                                        block_t private_key,
                                        uint32_t size,
                                        uint32_t lambda)
{
  1458dc:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    uint32_t error;

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_PK_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1458e0:	2600      	movs	r6, #0
{
  1458e2:	b089      	sub	sp, #36	; 0x24
    //ce will write to this addr auto, do not use this .
#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_6, (addr_t)(private_key.addr), private_key.addr_type);
#endif
    // Location 2 -> P
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  1458e4:	f04f 0801 	mov.w	r8, #1
{
  1458e8:	ac05      	add	r4, sp, #20
  1458ea:	4607      	mov	r7, r0
  1458ec:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  1458f0:	9d1c      	ldr	r5, [sp, #112]	; 0x70
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_PK_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1458f2:	4633      	mov	r3, r6
  1458f4:	9600      	str	r6, [sp, #0]
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  1458f6:	2602      	movs	r6, #2
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_PK_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1458f8:	462a      	mov	r2, r5
  1458fa:	2111      	movs	r1, #17
  1458fc:	f7fe fc3a 	bl	144174 <pke_set_command>
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  145900:	9500      	str	r5, [sp, #0]
  145902:	4638      	mov	r0, r7
  145904:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  145908:	e9cd 6801 	strd	r6, r8, [r13, #4]
  14590c:	f7ff faea 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  145910:	4604      	mov	r4, r0
  145912:	b118      	cbz	r0, 14591c <rsa_private_key_generation_blk+0x40>
    CryptoRAM2mem(vce_id, private_key, size, BA414EP_MEMLOC_6, false);
    //flush_cache((addr_t)private_key.addr, size);
#endif

    return CRYPTOLIB_SUCCESS;
}
  145914:	4620      	mov	r0, r4
  145916:	b009      	add	sp, #36	; 0x24
  145918:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    error = mem2CryptoRAM_rev(vce_id, q, size, BA414EP_MEMLOC_3, true);
  14591c:	2303      	movs	r3, #3
  14591e:	4638      	mov	r0, r7
  145920:	f8cd 8008 	str.w	r8, [r13, #8]
  145924:	e9cd 5300 	strd	r5, r3, [r13]
  145928:	ab10      	add	r3, sp, #64	; 0x40
  14592a:	cb0e      	ldmia	r3, {r1, r2, r3}
  14592c:	f7ff fada 	bl	144ee4 <mem2CryptoRAM_rev>
    if (error) {
  145930:	4604      	mov	r4, r0
  145932:	2800      	cmp	r0, #0
  145934:	d1ee      	bne.n	145914 <rsa_private_key_generation_blk+0x38>
    error = mem2CryptoRAM_rev(vce_id, public_expo, size, BA414EP_MEMLOC_8, true);
  145936:	2408      	movs	r4, #8
  145938:	ab13      	add	r3, sp, #76	; 0x4c
  14593a:	f8cd 8008 	str.w	r8, [r13, #8]
  14593e:	4638      	mov	r0, r7
  145940:	9500      	str	r5, [sp, #0]
  145942:	cb0e      	ldmia	r3, {r1, r2, r3}
  145944:	9401      	str	r4, [sp, #4]
  145946:	f7ff facd 	bl	144ee4 <mem2CryptoRAM_rev>
    if (error) {
  14594a:	4604      	mov	r4, r0
  14594c:	2800      	cmp	r0, #0
  14594e:	d1e1      	bne.n	145914 <rsa_private_key_generation_blk+0x38>
    invalidate_cache_block(&n, vce_id);
  145950:	4639      	mov	r1, r7
  145952:	f10d 0958 	add.w	r9, r13, #88	; 0x58
  145956:	4648      	mov	r0, r9
    invalidate_cache_block(&private_key, vce_id);
  145958:	ae19      	add	r6, sp, #100	; 0x64
    invalidate_cache_block(&n, vce_id);
  14595a:	f7fd fee3 	bl	143724 <invalidate_cache_block>
    invalidate_cache_block(&private_key, vce_id);
  14595e:	4630      	mov	r0, r6
  145960:	4639      	mov	r1, r7
  145962:	f7fd fedf 	bl	143724 <invalidate_cache_block>
    error = pke_start_wait_status(vce_id);
  145966:	4638      	mov	r0, r7
  145968:	f7fe fc20 	bl	1441ac <pke_start_wait_status>
    if (error) {
  14596c:	4604      	mov	r4, r0
  14596e:	2800      	cmp	r0, #0
  145970:	d1d0      	bne.n	145914 <rsa_private_key_generation_blk+0x38>
    if (lambda) {
  145972:	9b1d      	ldr	r3, [sp, #116]	; 0x74
  145974:	b9a3      	cbnz	r3, 1459a0 <rsa_private_key_generation_blk+0xc4>
    CryptoRAM2mem(vce_id, n, size, BA414EP_MEMLOC_0, false);
  145976:	f04f 0800 	mov.w	r8, #0
  14597a:	4638      	mov	r0, r7
  14597c:	9500      	str	r5, [sp, #0]
  14597e:	e9cd 8801 	strd	r8, r8, [r13, #4]
  145982:	e899 000e 	ldmia.w	r9, {r1, r2, r3}
  145986:	f7ff fbc5 	bl	145114 <CryptoRAM2mem>
    CryptoRAM2mem(vce_id, private_key, size, BA414EP_MEMLOC_6, false);
  14598a:	2306      	movs	r3, #6
  14598c:	4638      	mov	r0, r7
  14598e:	f8cd 8008 	str.w	r8, [r13, #8]
  145992:	e9cd 5300 	strd	r5, r3, [r13]
  145996:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  14599a:	f7ff fbbb 	bl	145114 <CryptoRAM2mem>
    return CRYPTOLIB_SUCCESS;
  14599e:	e7b9      	b.n	145914 <rsa_private_key_generation_blk+0x38>
        CryptoRAM2mem(vce_id, private_key, size, BA414EP_MEMLOC_1, true);
  1459a0:	f8cd 8008 	str.w	r8, [r13, #8]
  1459a4:	4638      	mov	r0, r7
  1459a6:	e9cd 5800 	strd	r5, r8, [r13]
  1459aa:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  1459ae:	f7ff fbb1 	bl	145114 <CryptoRAM2mem>
        if (!(private_key.addr_type & BLOCK_S_CONST_ADDR)) {
  1459b2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  1459b4:	00db      	lsls	r3, r3, #3
            private_key.addr += size;
  1459b6:	bf5e      	ittt	pl
  1459b8:	9b19      	ldrpl	r3, [sp, #100]	; 0x64
  1459ba:	195b      	addpl	r3, r3, r5
  1459bc:	9319      	strpl	r3, [sp, #100]	; 0x64
  1459be:	e7da      	b.n	145976 <rsa_private_key_generation_blk+0x9a>

001459c0 <rsa_crt_key_generation_blk>:
                                    block_t d,
                                    block_t dp,
                                    block_t dq,
                                    block_t inv,
                                    uint32_t size)
{
  1459c0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    uint32_t error;

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_CRT_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1459c4:	2600      	movs	r6, #0
{
  1459c6:	b088      	sub	sp, #32
#if AUTO_OUTPUT_BY_CE
    //? location 10 is dp
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_10, (addr_t)(p.addr), p.addr_type);
#endif
    // Location 2 -> P
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  1459c8:	f04f 0801 	mov.w	r8, #1
{
  1459cc:	ac05      	add	r4, sp, #20
  1459ce:	4607      	mov	r7, r0
  1459d0:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  1459d4:	9d1d      	ldr	r5, [sp, #116]	; 0x74
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_CRT_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1459d6:	4633      	mov	r3, r6
  1459d8:	9600      	str	r6, [sp, #0]
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  1459da:	2602      	movs	r6, #2
    pke_set_command(vce_id, BA414EP_OPTYPE_RSA_CRT_GEN, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  1459dc:	462a      	mov	r2, r5
  1459de:	2112      	movs	r1, #18
  1459e0:	f7fe fbc8 	bl	144174 <pke_set_command>
    error = mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_2, true);
  1459e4:	9500      	str	r5, [sp, #0]
  1459e6:	4638      	mov	r0, r7
  1459e8:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  1459ec:	e9cd 6801 	strd	r6, r8, [r13, #4]
  1459f0:	f7ff fa78 	bl	144ee4 <mem2CryptoRAM_rev>

    if (error) {
  1459f4:	4604      	mov	r4, r0
  1459f6:	b118      	cbz	r0, 145a00 <rsa_crt_key_generation_blk+0x40>

    // Result (INV - location 12)
    CryptoRAM2mem(vce_id, inv, size, BA414EP_MEMLOC_12, true);

    return CRYPTOLIB_SUCCESS;
}
  1459f8:	4620      	mov	r0, r4
  1459fa:	b008      	add	sp, #32
  1459fc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    error = mem2CryptoRAM_rev(vce_id, q, size, BA414EP_MEMLOC_3, true);
  145a00:	2303      	movs	r3, #3
  145a02:	4638      	mov	r0, r7
  145a04:	f8cd 8008 	str.w	r8, [r13, #8]
  145a08:	e9cd 5300 	strd	r5, r3, [r13]
  145a0c:	ab0e      	add	r3, sp, #56	; 0x38
  145a0e:	cb0e      	ldmia	r3, {r1, r2, r3}
  145a10:	f7ff fa68 	bl	144ee4 <mem2CryptoRAM_rev>
    if (error) {
  145a14:	4604      	mov	r4, r0
  145a16:	2800      	cmp	r0, #0
  145a18:	d1ee      	bne.n	1459f8 <rsa_crt_key_generation_blk+0x38>
    error = mem2CryptoRAM_rev(vce_id, d, size, BA414EP_MEMLOC_6, true);
  145a1a:	2406      	movs	r4, #6
  145a1c:	ab11      	add	r3, sp, #68	; 0x44
  145a1e:	f8cd 8008 	str.w	r8, [r13, #8]
  145a22:	4638      	mov	r0, r7
  145a24:	9500      	str	r5, [sp, #0]
  145a26:	cb0e      	ldmia	r3, {r1, r2, r3}
  145a28:	9401      	str	r4, [sp, #4]
  145a2a:	f7ff fa5b 	bl	144ee4 <mem2CryptoRAM_rev>
    if (error) {
  145a2e:	4604      	mov	r4, r0
  145a30:	2800      	cmp	r0, #0
  145a32:	d1e1      	bne.n	1459f8 <rsa_crt_key_generation_blk+0x38>
    error = pke_start_wait_status(vce_id);
  145a34:	4638      	mov	r0, r7
  145a36:	f7fe fbb9 	bl	1441ac <pke_start_wait_status>
    if (error) {
  145a3a:	4604      	mov	r4, r0
  145a3c:	2800      	cmp	r0, #0
  145a3e:	d1db      	bne.n	1459f8 <rsa_crt_key_generation_blk+0x38>
    CryptoRAM2mem_rev(vce_id, dp, size, BA414EP_MEMLOC_10, true);
  145a40:	260a      	movs	r6, #10
  145a42:	ab14      	add	r3, sp, #80	; 0x50
  145a44:	f8cd 8008 	str.w	r8, [r13, #8]
  145a48:	4638      	mov	r0, r7
  145a4a:	9500      	str	r5, [sp, #0]
  145a4c:	cb0e      	ldmia	r3, {r1, r2, r3}
  145a4e:	9601      	str	r6, [sp, #4]
    CryptoRAM2mem(vce_id, dq, size, BA414EP_MEMLOC_11, true);
  145a50:	260b      	movs	r6, #11
    CryptoRAM2mem_rev(vce_id, dp, size, BA414EP_MEMLOC_10, true);
  145a52:	f7ff facb 	bl	144fec <CryptoRAM2mem_rev>
    CryptoRAM2mem(vce_id, dq, size, BA414EP_MEMLOC_11, true);
  145a56:	f8cd 8008 	str.w	r8, [r13, #8]
  145a5a:	9500      	str	r5, [sp, #0]
  145a5c:	ab17      	add	r3, sp, #92	; 0x5c
  145a5e:	4638      	mov	r0, r7
  145a60:	cb0e      	ldmia	r3, {r1, r2, r3}
  145a62:	9601      	str	r6, [sp, #4]
    CryptoRAM2mem(vce_id, inv, size, BA414EP_MEMLOC_12, true);
  145a64:	260c      	movs	r6, #12
    CryptoRAM2mem(vce_id, dq, size, BA414EP_MEMLOC_11, true);
  145a66:	f7ff fb55 	bl	145114 <CryptoRAM2mem>
    CryptoRAM2mem(vce_id, inv, size, BA414EP_MEMLOC_12, true);
  145a6a:	f8cd 8008 	str.w	r8, [r13, #8]
  145a6e:	9500      	str	r5, [sp, #0]
  145a70:	ab1a      	add	r3, sp, #104	; 0x68
  145a72:	4638      	mov	r0, r7
  145a74:	cb0e      	ldmia	r3, {r1, r2, r3}
  145a76:	9601      	str	r6, [sp, #4]
  145a78:	f7ff fb4c 	bl	145114 <CryptoRAM2mem>
    return CRYPTOLIB_SUCCESS;
  145a7c:	e7bc      	b.n	1459f8 <rsa_crt_key_generation_blk+0x38>
  145a7e:	bf00      	nop

00145a80 <rsa_key_generation_blk>:
                                uint32_t nbr_of_bytes,
                                block_t exponent,
                                block_t key,
                                bool public,
                                bool lambda)
{
  145a80:	b082      	sub	sp, #8
    uint8_t* pBuff;
    struct mem_node* mem_n_1;
    uint8_t* qBuff;
    struct mem_node* mem_n_2;

    if (nbr_of_bytes > RSA_MAX_SIZE) {
  145a82:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
{
  145a86:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
        return CRYPTOLIB_INVALID_PARAM;
  145a8a:	bf88      	it	hi
  145a8c:	2609      	movhi	r6, #9
{
  145a8e:	b0cb      	sub	sp, #300	; 0x12c
  145a90:	ac54      	add	r4, sp, #336	; 0x150
  145a92:	e884 000c 	stmia.w	r4, {r2, r3}
  145a96:	f89d 3168 	ldrb.w	r3, [r13, #360]	; 0x168
  145a9a:	9318      	str	r3, [sp, #96]	; 0x60
  145a9c:	f89d 316c 	ldrb.w	r3, [r13, #364]	; 0x16c
  145aa0:	9316      	str	r3, [sp, #88]	; 0x58
    if (nbr_of_bytes > RSA_MAX_SIZE) {
  145aa2:	f200 809e 	bhi.w	145be2 <rsa_key_generation_blk+0x162>
  145aa6:	9b55      	ldr	r3, [sp, #340]	; 0x154
  145aa8:	4681      	mov	r9, r0
  145aaa:	931a      	str	r3, [sp, #104]	; 0x68

    // Reserve space for n
    addr_t n_addr = (addr_t)key.addr;
    key.addr += nbr_of_bytes;

    mem_n = ce_malloc(RSA_MAX_SIZE);
  145aac:	f44f 7000 	mov.w	r0, #512	; 0x200
  145ab0:	9b59      	ldr	r3, [sp, #356]	; 0x164
  145ab2:	460c      	mov	r4, r1
  145ab4:	9e57      	ldr	r6, [sp, #348]	; 0x15c
  145ab6:	9319      	str	r3, [sp, #100]	; 0x64
  145ab8:	961f      	str	r6, [sp, #124]	; 0x7c
  145aba:	f7fd fd13 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  145abe:	901b      	str	r0, [sp, #108]	; 0x6c
  145ac0:	4603      	mov	r3, r0
  145ac2:	2800      	cmp	r0, #0
  145ac4:	f000 80d0 	beq.w	145c68 <rsa_key_generation_blk+0x1e8>
        result = mem_n->ptr;
    } else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    mem_n_1 = ce_malloc(RSA_MAX_SIZE / 2);
  145ac8:	f44f 7080 	mov.w	r0, #256	; 0x100

        // Find proper prime numbers
        while (!primeFound) {
            // 1. generate two random numbers
            if (!random1_prime) {
                trng_get_rand_by_fifo(random1 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145acc:	0865      	lsrs	r5, r4, #1
        result = mem_n->ptr;
  145ace:	689f      	ldr	r7, [r3, #8]
    key.addr += nbr_of_bytes;
  145ad0:	4426      	add	r6, r4
                trng_get_rand_by_fifo(random1 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145ad2:	9514      	str	r5, [sp, #80]	; 0x50
    mem_n_1 = ce_malloc(RSA_MAX_SIZE / 2);
  145ad4:	f7fd fd06 	bl	1434e4 <ce_malloc>
    bool random2_prime = false;
  145ad8:	2200      	movs	r2, #0
  145ada:	1e63      	subs	r3, r4, #1
    key.addr += nbr_of_bytes;
  145adc:	961c      	str	r6, [sp, #112]	; 0x70
  145ade:	9315      	str	r3, [sp, #84]	; 0x54
    bool random2_prime = false;
  145ae0:	920f      	str	r2, [sp, #60]	; 0x3c
    mem_n_1 = ce_malloc(RSA_MAX_SIZE / 2);
  145ae2:	901d      	str	r0, [sp, #116]	; 0x74
  145ae4:	4684      	mov	r12, r0
    mem_n_2 = ce_malloc(RSA_MAX_SIZE / 2);
  145ae6:	f44f 7080 	mov.w	r0, #256	; 0x100
        pBuff = mem_n_1->ptr;
  145aea:	f8dc b008 	ldr.w	r11, [r12, #8]
    mem_n_2 = ce_malloc(RSA_MAX_SIZE / 2);
  145aee:	f7fd fcf9 	bl	1434e4 <ce_malloc>
    bool random1_prime = false;
  145af2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
  145af4:	2303      	movs	r3, #3
  145af6:	9213      	str	r2, [sp, #76]	; 0x4c
                trng_get_rand_by_fifo(random1 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145af8:	eb0b 0a05 	add.w	r10, r11, r5
                *(random1 + nbr_of_bytes - 1) |= 0x1;
                *(random1 + nbr_of_bytes / 2) |= 0x1;
            }

            if (!random2_prime) {
                *(random2 + nbr_of_bytes - 1) |= 0x1;
  145afc:	9915      	ldr	r1, [sp, #84]	; 0x54
  145afe:	f8cd b08c 	str.w	r11, [r13, #140]	; 0x8c
  145b02:	9720      	str	r7, [sp, #128]	; 0x80
  145b04:	9424      	str	r4, [sp, #144]	; 0x90
  145b06:	9427      	str	r4, [sp, #156]	; 0x9c
  145b08:	9322      	str	r3, [sp, #136]	; 0x88
  145b0a:	9325      	str	r3, [sp, #148]	; 0x94
  145b0c:	9328      	str	r3, [sp, #160]	; 0xa0
    mem_n_2 = ce_malloc(RSA_MAX_SIZE / 2);
  145b0e:	901e      	str	r0, [sp, #120]	; 0x78
  145b10:	4606      	mov	r6, r0
    trng_init(false);
  145b12:	2000      	movs	r0, #0
        qBuff = mem_n_2->ptr;
  145b14:	68b2      	ldr	r2, [r6, #8]
  145b16:	ae03      	add	r6, sp, #12
  145b18:	9210      	str	r2, [sp, #64]	; 0x40
  145b1a:	9612      	str	r6, [sp, #72]	; 0x48
                *(random2 + nbr_of_bytes - 1) |= 0x1;
  145b1c:	1851      	adds	r1, r2, r1
  145b1e:	9226      	str	r2, [sp, #152]	; 0x98
                trng_get_rand_by_fifo(random2 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145b20:	eb02 0805 	add.w	r8, r2, r5
                *(random2 + nbr_of_bytes - 1) |= 0x1;
  145b24:	9117      	str	r1, [sp, #92]	; 0x5c
    trng_init(false);
  145b26:	f000 fa57 	bl	145fd8 <trng_init>
  145b2a:	f8cd b044 	str.w	r11, [r13, #68]	; 0x44
  145b2e:	46cb      	mov	r11, r9
        memset(pBuff, 0, nbr_of_bytes);
  145b30:	9b11      	ldr	r3, [sp, #68]	; 0x44
  145b32:	4622      	mov	r2, r4
                *(random1 + nbr_of_bytes - 1) |= 0x1;
  145b34:	9d15      	ldr	r5, [sp, #84]	; 0x54
        memset(pBuff, 0, nbr_of_bytes);
  145b36:	2100      	movs	r1, #0
  145b38:	4618      	mov	r0, r3
                *(random1 + nbr_of_bytes - 1) |= 0x1;
  145b3a:	eb03 0905 	add.w	r9, r3, r5
        memset(pBuff, 0, nbr_of_bytes);
  145b3e:	f00d ea9e 	blx	15307c <memset>
        memset(qBuff, 0, nbr_of_bytes);
  145b42:	4622      	mov	r2, r4
  145b44:	2100      	movs	r1, #0
  145b46:	9810      	ldr	r0, [sp, #64]	; 0x40
  145b48:	f00d ea98 	blx	15307c <memset>
        memset(result, 0, nbr_of_bytes);
  145b4c:	4622      	mov	r2, r4
  145b4e:	2100      	movs	r1, #0
  145b50:	4638      	mov	r0, r7
  145b52:	f00d ea94 	blx	15307c <memset>
  145b56:	9e17      	ldr	r6, [sp, #92]	; 0x5c
  145b58:	2503      	movs	r5, #3
  145b5a:	e022      	b.n	145ba2 <rsa_key_generation_blk+0x122>
            if (!random2_prime) {
  145b5c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  145b5e:	2b00      	cmp	r3, #0
  145b60:	d060      	beq.n	145c24 <rsa_key_generation_blk+0x1a4>
  145b62:	e9cd 742f 	strd	r7, r4, [r13, #188]	; 0xbc
                *(random2 + nbr_of_bytes / 2) |= 0x1;
            }

            // 3. calculate modulus result = r1 * r2
            uint32_t status = multiplicate(vce_id, block_t_convert(random1, nbr_of_bytes, EXT_MEM),
  145b66:	ab2f      	add	r3, sp, #188	; 0xbc
  145b68:	9531      	str	r5, [sp, #196]	; 0xc4
  145b6a:	952e      	str	r5, [sp, #184]	; 0xb8
  145b6c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145b70:	9b10      	ldr	r3, [sp, #64]	; 0x40
  145b72:	e9cd 342c 	strd	r3, r4, [r13, #176]	; 0xb0
  145b76:	9b12      	ldr	r3, [sp, #72]	; 0x48
  145b78:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  145b7c:	952b      	str	r5, [sp, #172]	; 0xac
  145b7e:	ab2c      	add	r3, sp, #176	; 0xb0
  145b80:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145b84:	9b11      	ldr	r3, [sp, #68]	; 0x44
  145b86:	e9cd 3429 	strd	r3, r4, [r13, #164]	; 0xa4
  145b8a:	ab29      	add	r3, sp, #164	; 0xa4
  145b8c:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145b90:	4658      	mov	r0, r11
  145b92:	cb0e      	ldmia	r3, {r1, r2, r3}
  145b94:	f001 fcc4 	bl	147520 <multiplicate>
                                           block_t_convert(random2, nbr_of_bytes, EXT_MEM),
                                           block_t_convert(result, nbr_of_bytes, EXT_MEM));

            if (status) {
  145b98:	b9c8      	cbnz	r0, 145bce <rsa_key_generation_blk+0x14e>
                return status;
            }

            status = !(result[0] & 0x80); // MSB == 1 (ensure right size in bits)

            if (!status) {
  145b9a:	f997 3000 	ldrsb.w	r3, [r7]
  145b9e:	2b00      	cmp	r3, #0
  145ba0:	db45      	blt.n	145c2e <rsa_key_generation_blk+0x1ae>
            if (!random1_prime) {
  145ba2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  145ba4:	2b00      	cmp	r3, #0
  145ba6:	d1d9      	bne.n	145b5c <rsa_key_generation_blk+0xdc>
                trng_get_rand_by_fifo(random1 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145ba8:	9914      	ldr	r1, [sp, #80]	; 0x50
  145baa:	4650      	mov	r0, r10
  145bac:	f000 fb9a 	bl	1462e4 <trng_get_rand_by_fifo>
            if (!random2_prime) {
  145bb0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  145bb2:	b1e3      	cbz	r3, 145bee <rsa_key_generation_blk+0x16e>
                *(random1 + nbr_of_bytes - 1) |= 0x1;
  145bb4:	f899 3000 	ldrb.w	r3, [r9]
  145bb8:	f043 0301 	orr.w	r3, r3, #1
  145bbc:	f889 3000 	strb.w	r3, [r9]
                *(random1 + nbr_of_bytes / 2) |= 0x1;
  145bc0:	f89a 3000 	ldrb.w	r3, [r10]
  145bc4:	f043 0301 	orr.w	r3, r3, #1
  145bc8:	f88a 3000 	strb.w	r3, [r10]
  145bcc:	e7c9      	b.n	145b62 <rsa_key_generation_blk+0xe2>
  145bce:	4606      	mov	r6, r0
    }

    key.addr = (uint8_t*)n_addr;
    memcpy_blk(vce_id, block_t_convert(key.addr, d.len, key.addr_type), d, d.len);

    ce_free(mem_n);
  145bd0:	981b      	ldr	r0, [sp, #108]	; 0x6c
  145bd2:	f7fd fccb 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  145bd6:	981d      	ldr	r0, [sp, #116]	; 0x74
  145bd8:	f7fd fcc8 	bl	14356c <ce_free>
    ce_free(mem_n_2);
  145bdc:	981e      	ldr	r0, [sp, #120]	; 0x78
  145bde:	f7fd fcc5 	bl	14356c <ce_free>
    return err;
}
  145be2:	4630      	mov	r0, r6
  145be4:	b04b      	add	sp, #300	; 0x12c
  145be6:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  145bea:	b002      	add	sp, #8
  145bec:	4770      	bx	r14
                trng_get_rand_by_fifo(random2 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145bee:	9914      	ldr	r1, [sp, #80]	; 0x50
  145bf0:	4640      	mov	r0, r8
  145bf2:	f000 fb77 	bl	1462e4 <trng_get_rand_by_fifo>
                *(random1 + nbr_of_bytes - 1) |= 0x1;
  145bf6:	f899 3000 	ldrb.w	r3, [r9]
  145bfa:	f043 0301 	orr.w	r3, r3, #1
  145bfe:	f889 3000 	strb.w	r3, [r9]
                *(random1 + nbr_of_bytes / 2) |= 0x1;
  145c02:	f89a 3000 	ldrb.w	r3, [r10]
  145c06:	f043 0301 	orr.w	r3, r3, #1
  145c0a:	f88a 3000 	strb.w	r3, [r10]
                *(random2 + nbr_of_bytes - 1) |= 0x1;
  145c0e:	7833      	ldrb	r3, [r6, #0]
  145c10:	f043 0301 	orr.w	r3, r3, #1
  145c14:	7033      	strb	r3, [r6, #0]
                *(random2 + nbr_of_bytes / 2) |= 0x1;
  145c16:	f898 3000 	ldrb.w	r3, [r8]
  145c1a:	f043 0301 	orr.w	r3, r3, #1
  145c1e:	f888 3000 	strb.w	r3, [r8]
  145c22:	e79e      	b.n	145b62 <rsa_key_generation_blk+0xe2>
                trng_get_rand_by_fifo(random2 + nbr_of_bytes / 2, nbr_of_bytes / 2);
  145c24:	9914      	ldr	r1, [sp, #80]	; 0x50
  145c26:	4640      	mov	r0, r8
  145c28:	f000 fb5c 	bl	1462e4 <trng_get_rand_by_fifo>
  145c2c:	e7ef      	b.n	145c0e <rsa_key_generation_blk+0x18e>
                if (!random1_prime) {
  145c2e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
  145c30:	4606      	mov	r6, r0
  145c32:	b1db      	cbz	r3, 145c6c <rsa_key_generation_blk+0x1ec>
                if (!random2_prime) {
  145c34:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  145c36:	bb5b      	cbnz	r3, 145c90 <rsa_key_generation_blk+0x210>
  145c38:	2103      	movs	r1, #3
                    err = converge_to_prime(vce_id,
  145c3a:	ab35      	add	r3, sp, #212	; 0xd4
  145c3c:	2202      	movs	r2, #2
  145c3e:	4658      	mov	r0, r11
  145c40:	9d14      	ldr	r5, [sp, #80]	; 0x50
  145c42:	f8cd 80d4 	str.w	r8, [r13, #212]	; 0xd4
  145c46:	e9cd 5136 	strd	r5, r1, [r13, #216]	; 0xd8
  145c4a:	9200      	str	r2, [sp, #0]
  145c4c:	cb0e      	ldmia	r3, {r1, r2, r3}
  145c4e:	f001 fd3f 	bl	1476d0 <converge_to_prime>
                    if (!err) {
  145c52:	fab0 f380 	clz	r3, r0
                if (!status) {
  145c56:	4306      	orrs	r6, r0
                    if (!err) {
  145c58:	ea4f 1353 	mov.w	r3, r3, lsr #5
  145c5c:	930f      	str	r3, [sp, #60]	; 0x3c
                if (!status) {
  145c5e:	d019      	beq.n	145c94 <rsa_key_generation_blk+0x214>
                else if (status != CRYPTOLIB_PK_NOTINVERTIBLE) {
  145c60:	2e11      	cmp	r6, #17
  145c62:	f43f af78 	beq.w	145b56 <rsa_key_generation_blk+0xd6>
  145c66:	e7b3      	b.n	145bd0 <rsa_key_generation_blk+0x150>
        return CRYPTOLIB_PK_N_NOTVALID;
  145c68:	2615      	movs	r6, #21
  145c6a:	e7ba      	b.n	145be2 <rsa_key_generation_blk+0x162>
                    status = converge_to_prime(vce_id,
  145c6c:	2202      	movs	r2, #2
  145c6e:	ab32      	add	r3, sp, #200	; 0xc8
  145c70:	9914      	ldr	r1, [sp, #80]	; 0x50
  145c72:	4658      	mov	r0, r11
  145c74:	f8cd a0c8 	str.w	r10, [r13, #200]	; 0xc8
  145c78:	e9cd 1533 	strd	r1, r5, [r13, #204]	; 0xcc
  145c7c:	9200      	str	r2, [sp, #0]
  145c7e:	cb0e      	ldmia	r3, {r1, r2, r3}
  145c80:	f001 fd26 	bl	1476d0 <converge_to_prime>
                if (!random2_prime) {
  145c84:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
                    if (!status) {
  145c86:	4606      	mov	r6, r0
  145c88:	2800      	cmp	r0, #0
  145c8a:	d16e      	bne.n	145d6a <rsa_key_generation_blk+0x2ea>
                if (!random2_prime) {
  145c8c:	2b00      	cmp	r3, #0
  145c8e:	d070      	beq.n	145d72 <rsa_key_generation_blk+0x2f2>
  145c90:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  145c92:	9313      	str	r3, [sp, #76]	; 0x4c
  145c94:	2503      	movs	r5, #3
                    err = multiplicate(vce_id, block_t_convert(random1, nbr_of_bytes, EXT_MEM),
  145c96:	aa3e      	add	r2, sp, #248	; 0xf8
  145c98:	9b10      	ldr	r3, [sp, #64]	; 0x40
  145c9a:	ae3b      	add	r6, sp, #236	; 0xec
  145c9c:	973e      	str	r7, [sp, #248]	; 0xf8
  145c9e:	f10d 0ce0 	add.w	r12, r13, #224	; 0xe0
  145ca2:	943f      	str	r4, [sp, #252]	; 0xfc
  145ca4:	9540      	str	r5, [sp, #256]	; 0x100
  145ca6:	ca07      	ldmia	r2, {r0, r1, r2}
  145ca8:	e9cd 343b 	strd	r3, r4, [r13, #236]	; 0xec
  145cac:	9b12      	ldr	r3, [sp, #72]	; 0x48
  145cae:	953d      	str	r5, [sp, #244]	; 0xf4
  145cb0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  145cb4:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  145cb8:	9b11      	ldr	r3, [sp, #68]	; 0x44
  145cba:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145cbe:	e9cd 3438 	strd	r3, r4, [r13, #224]	; 0xe0
  145cc2:	4658      	mov	r0, r11
  145cc4:	953a      	str	r5, [sp, #232]	; 0xe8
  145cc6:	e89c 000e 	ldmia.w	r12, {r1, r2, r3}
  145cca:	f001 fc29 	bl	147520 <multiplicate>
                    if (err) {
  145cce:	4606      	mov	r6, r0
  145cd0:	2800      	cmp	r0, #0
  145cd2:	f47f af7d 	bne.w	145bd0 <rsa_key_generation_blk+0x150>
        while (!primeFound) {
  145cd6:	f997 3000 	ldrsb.w	r3, [r7]
  145cda:	2b00      	cmp	r3, #0
  145cdc:	f6bf af3b 	bge.w	145b56 <rsa_key_generation_blk+0xd6>
        err = rsa_private_key_generation_blk(vce_id, p, q, exponent, d,
  145ce0:	9b58      	ldr	r3, [sp, #352]	; 0x160
  145ce2:	aa41      	add	r2, sp, #260	; 0x104
  145ce4:	9d16      	ldr	r5, [sp, #88]	; 0x58
  145ce6:	ae09      	add	r6, sp, #36	; 0x24
  145ce8:	9421      	str	r4, [sp, #132]	; 0x84
  145cea:	1b19      	subs	r1, r3, r4
  145cec:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  145cee:	9341      	str	r3, [sp, #260]	; 0x104
  145cf0:	9b19      	ldr	r3, [sp, #100]	; 0x64
  145cf2:	9343      	str	r3, [sp, #268]	; 0x10c
  145cf4:	ab06      	add	r3, sp, #24
  145cf6:	9142      	str	r1, [sp, #264]	; 0x108
  145cf8:	ca07      	ldmia	r2, {r0, r1, r2}
  145cfa:	e9cd 450c 	strd	r4, r5, [r13, #48]	; 0x30
  145cfe:	e886 0007 	stmia.w	r6, {r0, r1, r2}
  145d02:	9d1a      	ldr	r5, [sp, #104]	; 0x68
  145d04:	aa20      	add	r2, sp, #128	; 0x80
  145d06:	9555      	str	r5, [sp, #340]	; 0x154
  145d08:	ae26      	add	r6, sp, #152	; 0x98
  145d0a:	ca07      	ldmia	r2, {r0, r1, r2}
  145d0c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  145d10:	9d12      	ldr	r5, [sp, #72]	; 0x48
  145d12:	ab54      	add	r3, sp, #336	; 0x150
  145d14:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145d18:	ab23      	add	r3, sp, #140	; 0x8c
  145d1a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  145d1e:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  145d22:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145d26:	4658      	mov	r0, r11
  145d28:	cb0e      	ldmia	r3, {r1, r2, r3}
  145d2a:	f7ff fdd7 	bl	1458dc <rsa_private_key_generation_blk>
  145d2e:	4606      	mov	r6, r0
    while (err == CRYPTOLIB_PK_NOTINVERTIBLE);
  145d30:	2811      	cmp	r0, #17
  145d32:	f43f aefd 	beq.w	145b30 <rsa_key_generation_blk+0xb0>
    if (lambda) {
  145d36:	9b16      	ldr	r3, [sp, #88]	; 0x58
  145d38:	46d9      	mov	r9, r11
  145d3a:	b1eb      	cbz	r3, 145d78 <rsa_key_generation_blk+0x2f8>
        key.addr += 2 * nbr_of_bytes;
  145d3c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  145d3e:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    if (public) {
  145d42:	9a18      	ldr	r2, [sp, #96]	; 0x60
  145d44:	b9da      	cbnz	r2, 145d7e <rsa_key_generation_blk+0x2fe>
  145d46:	9448      	str	r4, [sp, #288]	; 0x120
    memcpy_blk(vce_id, block_t_convert(key.addr, d.len, key.addr_type), d, d.len);
  145d48:	ab20      	add	r3, sp, #128	; 0x80
  145d4a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  145d4e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
  145d50:	9347      	str	r3, [sp, #284]	; 0x11c
  145d52:	9b19      	ldr	r3, [sp, #100]	; 0x64
  145d54:	9349      	str	r3, [sp, #292]	; 0x124
  145d56:	ab4a      	add	r3, sp, #296	; 0x128
  145d58:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145d5c:	9403      	str	r4, [sp, #12]
  145d5e:	4648      	mov	r0, r9
  145d60:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  145d64:	f7ff f8a8 	bl	144eb8 <memcpy_blk>
  145d68:	e732      	b.n	145bd0 <rsa_key_generation_blk+0x150>
                if (!random2_prime) {
  145d6a:	2b00      	cmp	r3, #0
  145d6c:	f47f af78 	bne.w	145c60 <rsa_key_generation_blk+0x1e0>
  145d70:	e762      	b.n	145c38 <rsa_key_generation_blk+0x1b8>
                        random1_prime = true;
  145d72:	2301      	movs	r3, #1
  145d74:	9313      	str	r3, [sp, #76]	; 0x4c
  145d76:	e75f      	b.n	145c38 <rsa_key_generation_blk+0x1b8>
        key.addr += nbr_of_bytes;
  145d78:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  145d7a:	4423      	add	r3, r4
  145d7c:	e7e1      	b.n	145d42 <rsa_key_generation_blk+0x2c2>
        memcpy_blk(vce_id, block_t_convert(key.addr, exponent.len, key.addr_type), exponent, exponent.len); //Copy pub key to key
  145d7e:	aa54      	add	r2, sp, #336	; 0x150
  145d80:	9344      	str	r3, [sp, #272]	; 0x110
  145d82:	af44      	add	r7, sp, #272	; 0x110
  145d84:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  145d86:	ca07      	ldmia	r2, {r0, r1, r2}
  145d88:	9d19      	ldr	r5, [sp, #100]	; 0x64
  145d8a:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  145d8e:	9345      	str	r3, [sp, #276]	; 0x114
  145d90:	4648      	mov	r0, r9
  145d92:	9546      	str	r5, [sp, #280]	; 0x118
  145d94:	9303      	str	r3, [sp, #12]
  145d96:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  145d9a:	f7ff f88d 	bl	144eb8 <memcpy_blk>
  145d9e:	e7d2      	b.n	145d46 <rsa_key_generation_blk+0x2c6>

00145da0 <trng_get_rand.part.0>:

#endif

    LTRACEF("trng_get_rand rng_needs_startup_chk=%d.\n", rng_needs_startup_chk);

    if (rng_needs_startup_chk) {
  145da0:	f642 4308 	movw	r3, #11272	; 0x2c08
uint32_t trng_get_rand(uint32_t vce_id, uint8_t* dst, uint32_t size)
  145da4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (rng_needs_startup_chk) {
  145da8:	461c      	mov	r4, r3
uint32_t trng_get_rand(uint32_t vce_id, uint8_t* dst, uint32_t size)
  145daa:	4692      	mov	r10, r2
    if (rng_needs_startup_chk) {
  145dac:	4622      	mov	r2, r4
uint32_t trng_get_rand(uint32_t vce_id, uint8_t* dst, uint32_t size)
  145dae:	b083      	sub	sp, #12
  145db0:	460b      	mov	r3, r1
    if (rng_needs_startup_chk) {
  145db2:	f2c0 0216 	movt	r2, #22
  145db6:	9200      	str	r2, [sp, #0]
  145db8:	7812      	ldrb	r2, [r2, #0]
  145dba:	b162      	cbz	r2, 145dd6 <trng_get_rand.part.0+0x36>
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  145dbc:	f248 1130 	movw	r1, #33072	; 0x8130
  145dc0:	f2cf 4100 	movt	r1, #62464	; 0xf400
  145dc4:	680a      	ldr	r2, [r1, #0]
  145dc6:	f002 020e 	and.w	r2, r2, #14
    while ((fsm_state == FSM_STATE_RESET) || (fsm_state == FSM_STATE_STARTUP));
  145dca:	2a01      	cmp	r2, #1
  145dcc:	d9fa      	bls.n	145dc4 <trng_get_rand.part.0+0x24>
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  145dce:	6809      	ldr	r1, [r1, #0]
        trng_wait_startup();
        rng_needs_startup_chk = false;
  145dd0:	2200      	movs	r2, #0
  145dd2:	9900      	ldr	r1, [sp, #0]
  145dd4:	700a      	strb	r2, [r1, #0]
    int i = 0;
  145dd6:	2200      	movs	r2, #0
        fsm_state = readl(_ioaddr(REG_TRNG_STATUS_CE_(vce_id))) & 0x1;
  145dd8:	0306      	lsls	r6, r0, #12
  145dda:	f106 4674 	add.w	r6, r6, #4093640704	; 0xf4000000
  145dde:	f506 7480 	add.w	r4, r6, #256	; 0x100
  145de2:	6821      	ldr	r1, [r4, #0]
        i++;
  145de4:	3201      	adds	r2, #1
        if ((!fsm_state) && (0 == i % 200)) {
  145de6:	07cd      	lsls	r5, r1, #31
  145de8:	d41b      	bmi.n	145e22 <trng_get_rand.part.0+0x82>
  145dea:	2ac8      	cmp	r2, #200	; 0xc8
  145dec:	d1f9      	bne.n	145de2 <trng_get_rand.part.0+0x42>
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145dee:	f44f 4001 	mov.w	r0, #33024	; 0x8100

    int trng_ready = trng_wait_ready(vce_id);

    if (0 != trng_ready) {
        trng_soft_reset();
        writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145df2:	f248 0730 	movw	r7, #32816	; 0x8030
    return rng_startup_failed;
}

void trng_set_startup_chk_flag(void)
{
    rng_needs_startup_chk = true;
  145df6:	2501      	movs	r5, #1
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145df8:	f2cf 4000 	movt	r0, #62464	; 0xf400
  145dfc:	9301      	str	r3, [sp, #4]
        writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145dfe:	f2cf 4700 	movt	r7, #62464	; 0xf400
    rng_needs_startup_chk = true;
  145e02:	9b00      	ldr	r3, [sp, #0]
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145e04:	6802      	ldr	r2, [r0, #0]
  145e06:	43d1      	mvns	r1, r2
  145e08:	f401 7180 	and.w	r1, r1, #256	; 0x100
  145e0c:	4051      	eors	r1, r2
  145e0e:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145e12:	6001      	str	r1, [r0, #0]
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145e14:	6002      	str	r2, [r0, #0]
        thread_sleep(1);
  145e16:	4628      	mov	r0, r5
    rng_needs_startup_chk = true;
  145e18:	701d      	strb	r5, [r3, #0]
        writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145e1a:	603d      	str	r5, [r7, #0]
        thread_sleep(1);
  145e1c:	f009 fd08 	bl	14f830 <thread_sleep>
  145e20:	9b01      	ldr	r3, [sp, #4]
    for (uint32_t i = 0; i < size;) {
  145e22:	f1ba 0f00 	cmp.w	r10, #0
  145e26:	d045      	beq.n	145eb4 <trng_get_rand.part.0+0x114>
                total_time++;
  145e28:	f642 470c 	movw	r7, #11276	; 0x2c0c
            if (readl(_ioaddr(REG_CE_TRNG_STATUS)) & 0x100) {
  145e2c:	f248 1830 	movw	r8, #33072	; 0x8130
            writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145e30:	f248 0930 	movw	r9, #32816	; 0x8030
                total_time++;
  145e34:	f2c0 0716 	movt	r7, #22
    for (uint32_t i = 0; i < size;) {
  145e38:	463a      	mov	r2, r7
  145e3a:	f506 7682 	add.w	r6, r6, #260	; 0x104
  145e3e:	461f      	mov	r7, r3
            if (readl(_ioaddr(REG_CE_TRNG_STATUS)) & 0x100) {
  145e40:	f2cf 4800 	movt	r8, #62464	; 0xf400
    for (uint32_t i = 0; i < size;) {
  145e44:	2500      	movs	r5, #0
            writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145e46:	f2cf 4900 	movt	r9, #62464	; 0xf400
    for (uint32_t i = 0; i < size;) {
  145e4a:	4613      	mov	r3, r2
  145e4c:	e005      	b.n	145e5a <trng_get_rand.part.0+0xba>
        rng_value = readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) + (i % 8)));
  145e4e:	f856 200b 	ldr.w	r2, [r6, r11]
        memcpy(dst + i, (void*)(&rng_value), 4);
  145e52:	517a      	str	r2, [r7, r5]
        i = i + 4;
  145e54:	3504      	adds	r5, #4
    for (uint32_t i = 0; i < size;) {
  145e56:	4555      	cmp	r5, r10
  145e58:	d22c      	bcs.n	145eb4 <trng_get_rand.part.0+0x114>
        if (i % 8 == 0) {
  145e5a:	f015 0b07 	ands.w	r11, r5, #7
  145e5e:	d1f6      	bne.n	145e4e <trng_get_rand.part.0+0xae>
    int i = 0;
  145e60:	465a      	mov	r2, r11
        fsm_state = readl(_ioaddr(REG_TRNG_STATUS_CE_(vce_id))) & 0x1;
  145e62:	6821      	ldr	r1, [r4, #0]
        i++;
  145e64:	3201      	adds	r2, #1
        if ((!fsm_state) && (0 == i % 200)) {
  145e66:	07c8      	lsls	r0, r1, #31
  145e68:	d528      	bpl.n	145ebc <trng_get_rand.part.0+0x11c>
            if (readl(_ioaddr(REG_CE_TRNG_STATUS)) & 0x100) {
  145e6a:	f8d8 2000 	ldr.w	r2, [r8]
  145e6e:	05d1      	lsls	r1, r2, #23
                writel(readl(_ioaddr(REG_CE_TRNG_STATUS)) & 0xFFFFFEFF, _ioaddr(REG_CE_TRNG_STATUS));
  145e70:	bf42      	ittt	mi
  145e72:	f8d8 2000 	ldrmi.w	r2, [r8]
  145e76:	f422 7280 	bicmi.w	r2, r2, #256	; 0x100
  145e7a:	f8c8 2000 	strmi.w	r2, [r8]
            writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145e7e:	2201      	movs	r2, #1
  145e80:	f8c9 2000 	str.w	r2, [r9]
            if (!(readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) - 4)) & 0x1)) {
  145e84:	6822      	ldr	r2, [r4, #0]
  145e86:	07d2      	lsls	r2, r2, #31
  145e88:	d4e1      	bmi.n	145e4e <trng_get_rand.part.0+0xae>
                total_time++;
  145e8a:	681a      	ldr	r2, [r3, #0]
                printf("trng status:0x%x, total time:%d\n", readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) - 4)), total_time);
  145e8c:	f245 707c 	movw	r0, #22396	; 0x577c
  145e90:	6821      	ldr	r1, [r4, #0]
  145e92:	f2c0 0015 	movt	r0, #21
                total_time++;
  145e96:	9301      	str	r3, [sp, #4]
  145e98:	f102 0c01 	add.w	r12, r2, #1
                printf("trng status:0x%x, total time:%d\n", readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) - 4)), total_time);
  145e9c:	4662      	mov	r2, r12
                total_time++;
  145e9e:	f8c3 c000 	str.w	r12, [r3]
                printf("trng status:0x%x, total time:%d\n", readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) - 4)), total_time);
  145ea2:	f00e f929 	bl	1540f8 <_printf>
        rng_value = readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) + (i % 8)));
  145ea6:	f856 200b 	ldr.w	r2, [r6, r11]
        memcpy(dst + i, (void*)(&rng_value), 4);
  145eaa:	517a      	str	r2, [r7, r5]
        i = i + 4;
  145eac:	3504      	adds	r5, #4
                printf("trng status:0x%x, total time:%d\n", readl(_ioaddr(REG_TRNG_NUM0_CE_(vce_id) - 4)), total_time);
  145eae:	9b01      	ldr	r3, [sp, #4]
    for (uint32_t i = 0; i < size;) {
  145eb0:	4555      	cmp	r5, r10
  145eb2:	d3d2      	bcc.n	145e5a <trng_get_rand.part.0+0xba>
}
  145eb4:	2000      	movs	r0, #0
  145eb6:	b003      	add	sp, #12
  145eb8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if ((!fsm_state) && (0 == i % 200)) {
  145ebc:	2ac8      	cmp	r2, #200	; 0xc8
  145ebe:	d1d0      	bne.n	145e62 <trng_get_rand.part.0+0xc2>
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145ec0:	f44f 4c01 	mov.w	r12, #33024	; 0x8100
    rng_needs_startup_chk = true;
  145ec4:	f04f 0e01 	mov.w	r14, #1
  145ec8:	9301      	str	r3, [sp, #4]
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145eca:	f2cf 4c00 	movt	r12, #62464	; 0xf400
    rng_needs_startup_chk = true;
  145ece:	9b00      	ldr	r3, [sp, #0]
                thread_sleep(1);
  145ed0:	4670      	mov	r0, r14
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145ed2:	f8dc 2000 	ldr.w	r2, [r12]
  145ed6:	43d1      	mvns	r1, r2
  145ed8:	f401 7180 	and.w	r1, r1, #256	; 0x100
  145edc:	4051      	eors	r1, r2
  145ede:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145ee2:	f8cc 1000 	str.w	r1, [r12]
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145ee6:	f8cc 2000 	str.w	r2, [r12]
    rng_needs_startup_chk = true;
  145eea:	f883 e000 	strb.w	r14, [r3]
                writel(0x1, _ioaddr(REG_CE_TRNG_CTRL));
  145eee:	f8c9 e000 	str.w	r14, [r9]
                thread_sleep(1);
  145ef2:	f009 fc9d 	bl	14f830 <thread_sleep>
  145ef6:	9b01      	ldr	r3, [sp, #4]
  145ef8:	e7b7      	b.n	145e6a <trng_get_rand.part.0+0xca>
  145efa:	bf00      	nop

00145efc <trng_get_rand_by_fifo.part.1>:

    return CRYPTOLIB_UNSUPPORTED_ERR;
}
*/

uint32_t trng_get_rand_by_fifo(uint8_t* dst, uint32_t size)
  145efc:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  145f00:	f04f 0e00 	mov.w	r14, #0
    addr_t baddr;
    uint32_t status;
    uint32_t read_size = 0;

    do {
        status = readl(_ioaddr(REG_CE_TRNG_STATUS));
  145f04:	f248 1530 	movw	r5, #33072	; 0x8130
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145f08:	f44f 4401 	mov.w	r4, #33024	; 0x8100
            for (uint32_t i = 0; i < read_cnt; i++) {
                if (size <= read_size) {
                    return CRYPTOLIB_SUCCESS;
                }

                rng_value = readl(_ioaddr(baddr));
  145f0c:	f248 1680 	movw	r6, #33152	; 0x8180
    uint32_t read_size = 0;
  145f10:	46f4      	mov	r12, r14
        status = readl(_ioaddr(REG_CE_TRNG_STATUS));
  145f12:	f2cf 4500 	movt	r5, #62464	; 0xf400
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145f16:	f2cf 4400 	movt	r4, #62464	; 0xf400
  145f1a:	f642 4708 	movw	r7, #11272	; 0x2c08
                rng_value = readl(_ioaddr(baddr));
  145f1e:	f2cf 4600 	movt	r6, #62464	; 0xf400
  145f22:	f2c0 0716 	movt	r7, #22
  145f26:	f897 9000 	ldrb.w	r9, [r7]
        status = readl(_ioaddr(REG_CE_TRNG_STATUS));
  145f2a:	682b      	ldr	r3, [r5, #0]
        while (0x0 != (status & 0x300)) {
  145f2c:	f413 7f40 	tst.w	r3, #768	; 0x300
  145f30:	d00f      	beq.n	145f52 <trng_get_rand_by_fifo.part.1+0x56>
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145f32:	6823      	ldr	r3, [r4, #0]
  145f34:	43da      	mvns	r2, r3
  145f36:	f402 7280 	and.w	r2, r2, #256	; 0x100
  145f3a:	405a      	eors	r2, r3
  145f3c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145f40:	6022      	str	r2, [r4, #0]
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  145f42:	6023      	str	r3, [r4, #0]
            status = readl(_ioaddr(REG_CE_TRNG_STATUS));
  145f44:	682b      	ldr	r3, [r5, #0]
        while (0x0 != (status & 0x300)) {
  145f46:	f413 7f40 	tst.w	r3, #768	; 0x300
  145f4a:	d1f2      	bne.n	145f32 <trng_get_rand_by_fifo.part.1+0x36>
  145f4c:	f04f 0e01 	mov.w	r14, #1
    rng_needs_startup_chk = true;
  145f50:	46f1      	mov	r9, r14
        if (0x0 != (status & 0x80)) {
  145f52:	061b      	lsls	r3, r3, #24
  145f54:	d407      	bmi.n	145f66 <trng_get_rand_by_fifo.part.1+0x6a>
                read_size += 4;
                dst += 4;
            }
        }
    }
    while (read_size < size);
  145f56:	4561      	cmp	r1, r12
  145f58:	d8e7      	bhi.n	145f2a <trng_get_rand_by_fifo.part.1+0x2e>
  145f5a:	f1be 0f00 	cmp.w	r14, #0
  145f5e:	d11f      	bne.n	145fa0 <trng_get_rand_by_fifo.part.1+0xa4>

    LTRACEF("trng_get_rand_by_fifo fifo is null staus 0x%x.\n", status);

    return CRYPTOLIB_UNSUPPORTED_ERR;
  145f60:	2001      	movs	r0, #1
}
  145f62:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
                if (size <= read_size) {
  145f66:	4561      	cmp	r1, r12
  145f68:	d912      	bls.n	145f90 <trng_get_rand_by_fifo.part.1+0x94>
                rng_value = readl(_ioaddr(baddr));
  145f6a:	6832      	ldr	r2, [r6, #0]
                read_size += 4;
  145f6c:	f10c 0304 	add.w	r3, r12, #4
                memcpy(dst, (void*)(&rng_value), 4);
  145f70:	f840 2b04 	str.w	r2, [r0], #4
  145f74:	f10c 0880 	add.w	r8, r12, #128	; 0x80
  145f78:	eba6 0c0c 	sub.w	r12, r6, r12
  145f7c:	e006      	b.n	145f8c <trng_get_rand_by_fifo.part.1+0x90>
                rng_value = readl(_ioaddr(baddr));
  145f7e:	f85c 2003 	ldr.w	r2, [r12, r3]
                read_size += 4;
  145f82:	3304      	adds	r3, #4
                memcpy(dst, (void*)(&rng_value), 4);
  145f84:	f840 2b04 	str.w	r2, [r0], #4
            for (uint32_t i = 0; i < read_cnt; i++) {
  145f88:	4543      	cmp	r3, r8
  145f8a:	d007      	beq.n	145f9c <trng_get_rand_by_fifo.part.1+0xa0>
                if (size <= read_size) {
  145f8c:	4299      	cmp	r1, r3
  145f8e:	d8f6      	bhi.n	145f7e <trng_get_rand_by_fifo.part.1+0x82>
  145f90:	f1be 0f00 	cmp.w	r14, #0
  145f94:	d107      	bne.n	145fa6 <trng_get_rand_by_fifo.part.1+0xaa>
                    return CRYPTOLIB_SUCCESS;
  145f96:	2000      	movs	r0, #0
}
  145f98:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
                read_size += 4;
  145f9c:	469c      	mov	r12, r3
  145f9e:	e7da      	b.n	145f56 <trng_get_rand_by_fifo.part.1+0x5a>
  145fa0:	f887 9000 	strb.w	r9, [r7]
  145fa4:	e7dc      	b.n	145f60 <trng_get_rand_by_fifo.part.1+0x64>
  145fa6:	f887 9000 	strb.w	r9, [r7]
  145faa:	e7f4      	b.n	145f96 <trng_get_rand_by_fifo.part.1+0x9a>

00145fac <trng_get_rand>:
    if (size % 4) {
  145fac:	0793      	lsls	r3, r2, #30
  145fae:	d101      	bne.n	145fb4 <trng_get_rand+0x8>
  145fb0:	f7ff bef6 	b.w	145da0 <trng_get_rand.part.0>
}
  145fb4:	2009      	movs	r0, #9
  145fb6:	4770      	bx	r14

00145fb8 <trng_get_rand_blk>:
{
  145fb8:	b084      	sub	sp, #16
  145fba:	f10d 0c10 	add.w	r12, r13, #16
  145fbe:	e90c 000e 	stmdb	r12, {r1, r2, r3}
    return trng_get_rand(vce_id, dest.addr, dest.len);
  145fc2:	9a02      	ldr	r2, [sp, #8]
    if (size % 4) {
  145fc4:	0793      	lsls	r3, r2, #30
  145fc6:	d103      	bne.n	145fd0 <trng_get_rand_blk+0x18>
  145fc8:	9901      	ldr	r1, [sp, #4]
}
  145fca:	b004      	add	sp, #16
  145fcc:	f7ff bee8 	b.w	145da0 <trng_get_rand.part.0>
  145fd0:	2009      	movs	r0, #9
  145fd2:	b004      	add	sp, #16
  145fd4:	4770      	bx	r14
  145fd6:	bf00      	nop

00145fd8 <trng_init>:
{
  145fd8:	b5f0      	push	{r4, r5, r6, r7, r14}
  145fda:	b095      	sub	sp, #84	; 0x54
    if (cond_test_en) {
  145fdc:	2800      	cmp	r0, #0
  145fde:	f040 809a 	bne.w	146116 <trng_init+0x13e>
  145fe2:	f642 4508 	movw	r5, #11272	; 0x2c08
  145fe6:	f2c0 0516 	movt	r5, #22
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145fea:	f44f 4301 	mov.w	r3, #33024	; 0x8100
    rng_needs_startup_chk = true;
  145fee:	2701      	movs	r7, #1
        writel(RNG_OFF_TIMER_VAL, _ioaddr(REG_CE_TRNG_SWOFFTMRVAL));
  145ff0:	f248 1640 	movw	r6, #33088	; 0x8140
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  145ff4:	f2cf 4300 	movt	r3, #62464	; 0xf400
    writel(RNG_CLKDIV, _ioaddr(REG_CE_TRNG_CLKDIV));
  145ff8:	f248 1444 	movw	r4, #33092	; 0x8144
    writel(RNG_INIT_WAIT_VAL, _ioaddr(REG_CE_TRNG_INITWAITVAL));
  145ffc:	f248 1034 	movw	r0, #33076	; 0x8134
  146000:	f2cf 4000 	movt	r0, #62464	; 0xf400
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146004:	681a      	ldr	r2, [r3, #0]
        writel(RNG_OFF_TIMER_VAL, _ioaddr(REG_CE_TRNG_SWOFFTMRVAL));
  146006:	f2cf 4600 	movt	r6, #62464	; 0xf400
    writel(RNG_CLKDIV, _ioaddr(REG_CE_TRNG_CLKDIV));
  14600a:	f2cf 4400 	movt	r4, #62464	; 0xf400
  14600e:	43d1      	mvns	r1, r2
  146010:	f401 7180 	and.w	r1, r1, #256	; 0x100
  146014:	4051      	eors	r1, r2
  146016:	f422 7280 	bic.w	r2, r2, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  14601a:	6019      	str	r1, [r3, #0]
        writel(RNG_OFF_TIMER_VAL, _ioaddr(REG_CE_TRNG_SWOFFTMRVAL));
  14601c:	2100      	movs	r1, #0
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  14601e:	601a      	str	r2, [r3, #0]
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  146020:	f248 1230 	movw	r2, #33072	; 0x8130
    rng_needs_startup_chk = true;
  146024:	702f      	strb	r7, [r5, #0]
    writel(RNG_INIT_WAIT_VAL, _ioaddr(REG_CE_TRNG_INITWAITVAL));
  146026:	f44f 7500 	mov.w	r5, #512	; 0x200
        writel(RNG_OFF_TIMER_VAL, _ioaddr(REG_CE_TRNG_SWOFFTMRVAL));
  14602a:	6031      	str	r1, [r6, #0]
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  14602c:	f2cf 4200 	movt	r2, #62464	; 0xf400
    writel(RNG_CLKDIV, _ioaddr(REG_CE_TRNG_CLKDIV));
  146030:	6021      	str	r1, [r4, #0]
    writel(RNG_INIT_WAIT_VAL, _ioaddr(REG_CE_TRNG_INITWAITVAL));
  146032:	6005      	str	r5, [r0, #0]
    value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146034:	6819      	ldr	r1, [r3, #0]
  146036:	f421 2170 	bic.w	r1, r1, #983040	; 0xf0000
  14603a:	f441 2180 	orr.w	r1, r1, #262144	; 0x40000
  14603e:	43c8      	mvns	r0, r1
  146040:	4038      	ands	r0, r7
  146042:	4041      	eors	r1, r0
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  146044:	6019      	str	r1, [r3, #0]
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  146046:	6813      	ldr	r3, [r2, #0]
  146048:	f003 030e 	and.w	r3, r3, #14
    while ((fsm_state == FSM_STATE_RESET) || (fsm_state == FSM_STATE_STARTUP));
  14604c:	2b01      	cmp	r3, #1
  14604e:	d9fa      	bls.n	146046 <trng_init+0x6e>
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  146050:	6810      	ldr	r0, [r2, #0]
    if (trng_status_glb(TRNG_STARTUPFAIL_MASK)) {
  146052:	f410 6080 	ands.w	r0, r0, #1024	; 0x400
  146056:	f040 80ff 	bne.w	146258 <trng_init+0x280>
    key[0] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80));
  14605a:	f248 1380 	movw	r3, #33152	; 0x8180
    key[1] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x84));
  14605e:	f248 1c84 	movw	r12, #33156	; 0x8184
    key[2] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x88));
  146062:	f248 1788 	movw	r7, #33160	; 0x8188
    key[0] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80));
  146066:	f2cf 4300 	movt	r3, #62464	; 0xf400
    key[3] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x8c));
  14606a:	f248 168c 	movw	r6, #33164	; 0x818c
    key[1] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x84));
  14606e:	f2cf 4c00 	movt	r12, #62464	; 0xf400
    key[2] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x88));
  146072:	f2cf 4700 	movt	r7, #62464	; 0xf400
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146076:	f44f 4101 	mov.w	r1, #33024	; 0x8100
    key[3] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x8c));
  14607a:	f2cf 4600 	movt	r6, #62464	; 0xf400
    key[0] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80));
  14607e:	f8d3 e000 	ldr.w	r14, [r3]
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146082:	f2cf 4100 	movt	r1, #62464	; 0xf400
    writel(key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  146086:	f248 1510 	movw	r5, #33040	; 0x8110
    writel(key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  14608a:	f248 1214 	movw	r2, #33044	; 0x8114
    writel(key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  14608e:	f248 1418 	movw	r4, #33048	; 0x8118
    writel(key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  146092:	f248 131c 	movw	r3, #33052	; 0x811c
    writel(key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  146096:	f2cf 4500 	movt	r5, #62464	; 0xf400
    writel(key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  14609a:	f2cf 4200 	movt	r2, #62464	; 0xf400
    writel(key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  14609e:	f2cf 4400 	movt	r4, #62464	; 0xf400
    key[1] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x84));
  1460a2:	f8dc c000 	ldr.w	r12, [r12]
    writel(key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1460a6:	f2cf 4300 	movt	r3, #62464	; 0xf400
    key[2] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x88));
  1460aa:	683f      	ldr	r7, [r7, #0]
    key[3] = readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x8c));
  1460ac:	6836      	ldr	r6, [r6, #0]
    writel(key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  1460ae:	f8c5 e000 	str.w	r14, [r5]
    writel(key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  1460b2:	f8c2 c000 	str.w	r12, [r2]
  1460b6:	f240 72e1 	movw	r2, #2017	; 0x7e1
    writel(key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  1460ba:	6027      	str	r7, [r4, #0]
  1460bc:	f6cf 72f0 	movt	r2, #65520	; 0xfff0
    writel(key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1460c0:	601e      	str	r6, [r3, #0]
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  1460c2:	680b      	ldr	r3, [r1, #0]
  1460c4:	43dc      	mvns	r4, r3
  1460c6:	f404 7480 	and.w	r4, r4, #256	; 0x100
  1460ca:	405c      	eors	r4, r3
  1460cc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  1460d0:	600c      	str	r4, [r1, #0]
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  1460d2:	600b      	str	r3, [r1, #0]
    value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  1460d4:	680c      	ldr	r4, [r1, #0]
  1460d6:	43e3      	mvns	r3, r4
  1460d8:	f003 0301 	and.w	r3, r3, #1
  1460dc:	4063      	eors	r3, r4
  1460de:	f023 031e 	bic.w	r3, r3, #30
  1460e2:	43dc      	mvns	r4, r3
  1460e4:	f004 0420 	and.w	r4, r4, #32
  1460e8:	405c      	eors	r4, r3
  1460ea:	43e3      	mvns	r3, r4
  1460ec:	f003 0380 	and.w	r3, r3, #128	; 0x80
  1460f0:	405c      	eors	r4, r3
  1460f2:	43e3      	mvns	r3, r4
  1460f4:	f403 7300 	and.w	r3, r3, #512	; 0x200
  1460f8:	4063      	eors	r3, r4
  1460fa:	43dc      	mvns	r4, r3
  1460fc:	f404 6480 	and.w	r4, r4, #1024	; 0x400
  146100:	4063      	eors	r3, r4
  146102:	401a      	ands	r2, r3
  146104:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  146108:	43d3      	mvns	r3, r2
  14610a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  14610e:	405a      	eors	r2, r3
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  146110:	600a      	str	r2, [r1, #0]
}
  146112:	b015      	add	sp, #84	; 0x54
  146114:	bdf0      	pop	{r4, r5, r6, r7, r15}
    const uint32_t test_data[16] = {0xE1BCC06B, 0x9199452A, 0x1A7434E1, 0x25199E7F,
  146116:	f245 6408 	movw	r4, #22024	; 0x5608
  14611a:	ad04      	add	r5, sp, #16
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  14611c:	f44f 4601 	mov.w	r6, #33024	; 0x8100
    const uint32_t test_data[16] = {0xE1BCC06B, 0x9199452A, 0x1A7434E1, 0x25199E7F,
  146120:	f2c0 0415 	movt	r4, #21
    writel(test_key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  146124:	f64a 6e28 	movw	r14, #44584	; 0xae28
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146128:	f2cf 4600 	movt	r6, #62464	; 0xf400
    writel(test_key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  14612c:	f248 1718 	movw	r7, #33048	; 0x8118
    writel(test_key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  146130:	f2ca 6ed2 	movt	r14, #42706	; 0xa6d2
    const uint32_t test_data[16] = {0xE1BCC06B, 0x9199452A, 0x1A7434E1, 0x25199E7F,
  146134:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  146136:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  146138:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14613a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  14613c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14613e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  146140:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
    const uint32_t known_answer[4] = {0xA1CAF13F, 0x09AC1F68, 0x30CA0E12, 0xA7E18675};
  146144:	3410      	adds	r4, #16
    const uint32_t test_data[16] = {0xE1BCC06B, 0x9199452A, 0x1A7434E1, 0x25199E7F,
  146146:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    const uint32_t known_answer[4] = {0xA1CAF13F, 0x09AC1F68, 0x30CA0E12, 0xA7E18675};
  14614a:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  14614e:	466d      	mov	r5, r13
    writel(test_key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  146150:	f647 642b 	movw	r4, #32299	; 0x7e2b
    writel(test_key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  146154:	f24f 7cab 	movw	r12, #63403	; 0xf7ab
    writel(test_key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  146158:	f2c1 6415 	movt	r4, #5653	; 0x1615
    const uint32_t known_answer[4] = {0xA1CAF13F, 0x09AC1F68, 0x30CA0E12, 0xA7E18675};
  14615c:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146160:	6833      	ldr	r3, [r6, #0]
    rng_needs_startup_chk = true;
  146162:	f642 4508 	movw	r5, #11272	; 0x2c08
    writel(test_key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  146166:	f248 1010 	movw	r0, #33040	; 0x8110
    rng_needs_startup_chk = true;
  14616a:	f2c0 0516 	movt	r5, #22
  14616e:	43da      	mvns	r2, r3
  146170:	f402 7280 	and.w	r2, r2, #256	; 0x100
  146174:	405a      	eors	r2, r3
  146176:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  14617a:	6032      	str	r2, [r6, #0]
    writel(test_key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  14617c:	f2cf 4000 	movt	r0, #62464	; 0xf400
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  146180:	6033      	str	r3, [r6, #0]
    writel(test_key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  146182:	f248 1114 	movw	r1, #33044	; 0x8114
    read_value = readl(_ioaddr(REG_CE_TRNG_CONTROL));
  146186:	6832      	ldr	r2, [r6, #0]
    writel(test_key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  146188:	f2cf 4100 	movt	r1, #62464	; 0xf400
    writel(test_key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  14618c:	f2cf 4700 	movt	r7, #62464	; 0xf400
  146190:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
  146194:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  146198:	43d3      	mvns	r3, r2
  14619a:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  14619e:	405a      	eors	r2, r3
  1461a0:	43d3      	mvns	r3, r2
  1461a2:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  1461a6:	4053      	eors	r3, r2
  1461a8:	43da      	mvns	r2, r3
  1461aa:	f002 0204 	and.w	r2, r2, #4
  1461ae:	4053      	eors	r3, r2
    rng_needs_startup_chk = true;
  1461b0:	2201      	movs	r2, #1
    writel(test_key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  1461b2:	f6c8 0c15 	movt	r12, #34837	; 0x8815
    rng_needs_startup_chk = true;
  1461b6:	702a      	strb	r2, [r5, #0]
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  1461b8:	f248 1230 	movw	r2, #33072	; 0x8130
    writel(value, _ioaddr(REG_CE_TRNG_CONTROL));
  1461bc:	6033      	str	r3, [r6, #0]
    writel(test_key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1461be:	f248 131c 	movw	r3, #33052	; 0x811c
    writel(test_key[0], _ioaddr(REG_CE_TRNG_KEY0REG));
  1461c2:	6004      	str	r4, [r0, #0]
    writel(test_key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1461c4:	f64c 7609 	movw	r6, #53001	; 0xcf09
        writel(test_data[i], _ioaddr(REG_CE_TRNG_TESTDATA));
  1461c8:	f248 1020 	movw	r0, #33056	; 0x8120
    writel(test_key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1461cc:	f2cf 4300 	movt	r3, #62464	; 0xf400
    writel(test_key[1], _ioaddr(REG_CE_TRNG_KEY1REG));
  1461d0:	f8c1 e000 	str.w	r14, [r1]
    writel(test_key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1461d4:	f6c3 464f 	movt	r6, #15439	; 0x3c4f
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  1461d8:	f2cf 4200 	movt	r2, #62464	; 0xf400
        writel(test_data[i], _ioaddr(REG_CE_TRNG_TESTDATA));
  1461dc:	f2cf 4000 	movt	r0, #62464	; 0xf400
  1461e0:	a903      	add	r1, sp, #12
    writel(test_key[2], _ioaddr(REG_CE_TRNG_KEY2REG));
  1461e2:	f8c7 c000 	str.w	r12, [r7]
  1461e6:	ac13      	add	r4, sp, #76	; 0x4c
    writel(test_key[3], _ioaddr(REG_CE_TRNG_KEY3REG));
  1461e8:	601e      	str	r6, [r3, #0]
    return readl(_ioaddr(REG_CE_TRNG_STATUS)) & bit_mask;
  1461ea:	6813      	ldr	r3, [r2, #0]
        while (trng_status_glb(TRNG_TESTDATABUSY_MASK));
  1461ec:	07db      	lsls	r3, r3, #31
  1461ee:	d4fc      	bmi.n	1461ea <trng_init+0x212>
        writel(test_data[i], _ioaddr(REG_CE_TRNG_TESTDATA));
  1461f0:	f851 3f04 	ldr.w	r3, [r1, #4]!
  1461f4:	6003      	str	r3, [r0, #0]
    for (i = 0; i < sizeof(test_data) / 4; i++) {
  1461f6:	42a1      	cmp	r1, r4
  1461f8:	d1f7      	bne.n	1461ea <trng_init+0x212>
    while (readl(_ioaddr(REG_CE_TRNG_FIFOLEVEL)) < 4);
  1461fa:	f248 1204 	movw	r2, #33028	; 0x8104
  1461fe:	f2cf 4200 	movt	r2, #62464	; 0xf400
  146202:	6813      	ldr	r3, [r2, #0]
  146204:	2b03      	cmp	r3, #3
  146206:	d9fc      	bls.n	146202 <trng_init+0x22a>
    writel(0, _ioaddr(REG_CE_TRNG_CONTROL));
  146208:	f44f 4401 	mov.w	r4, #33024	; 0x8100
        error |= readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80 + i * 0x4)) ^ known_answer[i];
  14620c:	f248 1280 	movw	r2, #33152	; 0x8180
    writel(0, _ioaddr(REG_CE_TRNG_CONTROL));
  146210:	2600      	movs	r6, #0
  146212:	f2cf 4400 	movt	r4, #62464	; 0xf400
        error |= readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80 + i * 0x4)) ^ known_answer[i];
  146216:	f248 1084 	movw	r0, #33156	; 0x8184
  14621a:	f2cf 4200 	movt	r2, #62464	; 0xf400
    writel(0, _ioaddr(REG_CE_TRNG_CONTROL));
  14621e:	6026      	str	r6, [r4, #0]
        error |= readl(_ioaddr(REG_CE_TRNG_CONTROL + 0x80 + i * 0x4)) ^ known_answer[i];
  146220:	f2cf 4000 	movt	r0, #62464	; 0xf400
  146224:	9c00      	ldr	r4, [sp, #0]
  146226:	f248 1388 	movw	r3, #33160	; 0x8188
  14622a:	6812      	ldr	r2, [r2, #0]
  14622c:	f248 118c 	movw	r1, #33164	; 0x818c
  146230:	6800      	ldr	r0, [r0, #0]
  146232:	f2cf 4300 	movt	r3, #62464	; 0xf400
  146236:	4062      	eors	r2, r4
  146238:	9c01      	ldr	r4, [sp, #4]
  14623a:	f2cf 4100 	movt	r1, #62464	; 0xf400
  14623e:	681b      	ldr	r3, [r3, #0]
  146240:	4060      	eors	r0, r4
  146242:	9c02      	ldr	r4, [sp, #8]
  146244:	4302      	orrs	r2, r0
  146246:	6809      	ldr	r1, [r1, #0]
  146248:	9803      	ldr	r0, [sp, #12]
  14624a:	4063      	eors	r3, r4
  14624c:	4313      	orrs	r3, r2
  14624e:	ea81 0200 	eor.w	r2, r1, r0
    if (error) {
  146252:	4313      	orrs	r3, r2
  146254:	f43f aec9 	beq.w	145fea <trng_init+0x12>
        rng_startup_failed = true;
  146258:	f642 4309 	movw	r3, #11273	; 0x2c09
  14625c:	2201      	movs	r2, #1
        return CRYPTOLIB_CRYPTO_ERR;
  14625e:	2006      	movs	r0, #6
        rng_startup_failed = true;
  146260:	f2c0 0316 	movt	r3, #22
  146264:	701a      	strb	r2, [r3, #0]
}
  146266:	b015      	add	sp, #84	; 0x54
  146268:	bdf0      	pop	{r4, r5, r6, r7, r15}
  14626a:	bf00      	nop

0014626c <rng_get_prng>:
{
  14626c:	b5f0      	push	{r4, r5, r6, r7, r14}
    uint32_t rng_value = 0;
  14626e:	2300      	movs	r3, #0
{
  146270:	b083      	sub	sp, #12
        return ret;
  146272:	460e      	mov	r6, r1
    uint32_t rng_value = 0;
  146274:	9301      	str	r3, [sp, #4]
    if (dst == NULL) {
  146276:	b1a1      	cbz	r1, 1462a2 <rng_get_prng+0x36>
    for (i = 0; i < index_max; i++) {
  146278:	0896      	lsrs	r6, r2, #2
    cp_left = size & 0x3;
  14627a:	f002 0c03 	and.w	r12, r2, #3
    for (i = 0; i < index_max; i++) {
  14627e:	d00d      	beq.n	14629c <rng_get_prng+0x30>
        rng_value = readl(_ioaddr(REG_HRNG_NUM_CE_(vce_id)));
  146280:	0305      	lsls	r5, r0, #12
  146282:	00b6      	lsls	r6, r6, #2
  146284:	f105 4574 	add.w	r5, r5, #4093640704	; 0xf4000000
  146288:	f505 758a 	add.w	r5, r5, #276	; 0x114
  14628c:	460b      	mov	r3, r1
  14628e:	1877      	adds	r7, r6, r1
  146290:	682c      	ldr	r4, [r5, #0]
        memcpy(dst + index, (void*)(&rng_value), sizeof(rng_value));
  146292:	f843 4b04 	str.w	r4, [r3], #4
    for (i = 0; i < index_max; i++) {
  146296:	42bb      	cmp	r3, r7
  146298:	d1fa      	bne.n	146290 <rng_get_prng+0x24>
  14629a:	9401      	str	r4, [sp, #4]
    if (cp_left > 0) {
  14629c:	f1bc 0f00 	cmp.w	r12, #0
  1462a0:	d102      	bne.n	1462a8 <rng_get_prng+0x3c>
}
  1462a2:	4630      	mov	r0, r6
  1462a4:	b003      	add	sp, #12
  1462a6:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1462a8:	460b      	mov	r3, r1
        rng_value = readl(_ioaddr(REG_HRNG_NUM_CE_(vce_id)));
  1462aa:	0304      	lsls	r4, r0, #12
  1462ac:	f104 4474 	add.w	r4, r4, #4093640704	; 0xf4000000
  1462b0:	a902      	add	r1, sp, #8
        memcpy(dst + index, (void*)(&rng_value), cp_left);
  1462b2:	4662      	mov	r2, r12
  1462b4:	1998      	adds	r0, r3, r6
        rng_value = readl(_ioaddr(REG_HRNG_NUM_CE_(vce_id)));
  1462b6:	f8d4 3114 	ldr.w	r3, [r4, #276]	; 0x114
        ret = index + cp_left;
  1462ba:	4466      	add	r6, r12
        rng_value = readl(_ioaddr(REG_HRNG_NUM_CE_(vce_id)));
  1462bc:	f841 3d04 	str.w	r3, [r1, #-4]!
        memcpy(dst + index, (void*)(&rng_value), cp_left);
  1462c0:	f00c ee56 	blx	152f70 <memcpy>
}
  1462c4:	4630      	mov	r0, r6
  1462c6:	b003      	add	sp, #12
  1462c8:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1462ca:	bf00      	nop

001462cc <rng_get_trng>:
    if (size % 4) {
  1462cc:	f012 0f03 	tst.w	r2, #3
  1462d0:	d001      	beq.n	1462d6 <rng_get_trng+0xa>
        return 0;
  1462d2:	2000      	movs	r0, #0
}
  1462d4:	4770      	bx	r14
{
  1462d6:	b508      	push	{r3, r14}
  1462d8:	f7ff fd62 	bl	145da0 <trng_get_rand.part.0>
    if (ret) {
  1462dc:	fab0 f080 	clz	r0, r0
  1462e0:	0940      	lsrs	r0, r0, #5
}
  1462e2:	bd08      	pop	{r3, r15}

001462e4 <trng_get_rand_by_fifo>:
    if (!dst) {
  1462e4:	b108      	cbz	r0, 1462ea <trng_get_rand_by_fifo+0x6>
  1462e6:	f7ff be09 	b.w	145efc <trng_get_rand_by_fifo.part.1>
}
  1462ea:	2009      	movs	r0, #9
  1462ec:	4770      	bx	r14
  1462ee:	bf00      	nop

001462f0 <rng_get_rand_less_ref>:

uint32_t rng_get_rand_less_ref(uint32_t vce_id, block_t dst, block_t n)
{
  1462f0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1462f4:	b087      	sub	sp, #28
  1462f6:	a806      	add	r0, sp, #24
  1462f8:	e900 000e 	stmdb	r0, {r1, r2, r3}
  1462fc:	9b11      	ldr	r3, [sp, #68]	; 0x44
  1462fe:	f8dd 9010 	ldr.w	r9, [r13, #16]
    if (dst.len != n.len) {
  146302:	4599      	cmp	r9, r3
  146304:	d163      	bne.n	1463ce <rng_get_rand_less_ref+0xde>
  146306:	9e10      	ldr	r6, [sp, #64]	; 0x40
        return CRYPTOLIB_INVALID_PARAM;
    }

    if (!(n.addr[n.len - 1] & 0x01)) { /*n must be odd*/
  146308:	eb06 0309 	add.w	r3, r6, r9
  14630c:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  146310:	07db      	lsls	r3, r3, #31
  146312:	d55c      	bpl.n	1463ce <rng_get_rand_less_ref+0xde>
  146314:	9d03      	ldr	r5, [sp, #12]

    /*since n is odd, at minimum the
     *least significant byte should be
     *different from 0
    */
    for (; !n.addr[index]; index++);
  146316:	7833      	ldrb	r3, [r6, #0]
  146318:	2b00      	cmp	r3, #0
  14631a:	d15c      	bne.n	1463d6 <rng_get_rand_less_ref+0xe6>
    uint32_t index = 0;
  14631c:	461a      	mov	r2, r3
  14631e:	4631      	mov	r1, r6
    for (; !n.addr[index]; index++);
  146320:	3201      	adds	r2, #1
  146322:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  146326:	2b00      	cmp	r3, #0
  146328:	d0fa      	beq.n	146320 <rng_get_rand_less_ref+0x30>
  14632a:	eba9 0102 	sub.w	r1, r9, r2
  14632e:	18af      	adds	r7, r5, r2
  146330:	9102      	str	r1, [sp, #8]
    uint8_t msb_mask = 0xFF;
  146332:	24ff      	movs	r4, #255	; 0xff

    for (; n.addr[index] & msb_mask; msb_mask <<= 1);
  146334:	0064      	lsls	r4, r4, #1
  146336:	b2e4      	uxtb	r4, r4
  146338:	ea13 0104 	ands.w	r1, r3, r4
  14633c:	d1fa      	bne.n	146334 <rng_get_rand_less_ref+0x44>

    /* Create container for random value from RNG, pointing to the same buffer as
     * dst but referring only to [MSB-1:0] instead of [len-1:0].
     * Force the leading, non-significant bytes to zero.
     */
    memset(dst.addr, 0, index);
  14633e:	4628      	mov	r0, r5
  146340:	43e4      	mvns	r4, r4
  146342:	f106 38ff 	add.w	r8, r6, #4294967295	; 0xffffffff
  146346:	f00c ee9a 	blx	15307c <memset>
  14634a:	f109 36ff 	add.w	r6, r9, #4294967295	; 0xffffffff
  14634e:	1e6b      	subs	r3, r5, #1
  146350:	b264      	sxtb	r4, r4
  146352:	9301      	str	r3, [sp, #4]
  146354:	eb05 0a06 	add.w	r10, r5, r6
    if (!dst) {
  146358:	b11f      	cbz	r7, 146362 <rng_get_rand_less_ref+0x72>
  14635a:	9902      	ldr	r1, [sp, #8]
  14635c:	4638      	mov	r0, r7
  14635e:	f7ff fdcd 	bl	145efc <trng_get_rand_by_fifo.part.1>
         * a highest byte <= 0x06 is only 7/256 without masking.
         * With the masking process (msb_mask = 0xF8, ~msb_mask = 0x07) we
         * significantly increase the chances of immediately finding a suitable
         * random.
         */
        dst.addr[index] &= ~msb_mask; /*Note that dst.addr[index] = rnd.addr[0]*/
  146362:	783b      	ldrb	r3, [r7, #0]
  146364:	4023      	ands	r3, r4
  146366:	703b      	strb	r3, [r7, #0]
        bool gt = false;
        bool eq = true;
        uint32_t leftop = 0;
        uint32_t rightop = 0;

        for (uint32_t i = 0; i < dst.len; i++) {
  146368:	f1b9 0f00 	cmp.w	r9, #0
  14636c:	d0f4      	beq.n	146358 <rng_get_rand_less_ref+0x68>
  14636e:	9901      	ldr	r1, [sp, #4]
  146370:	46c6      	mov	r14, r8
        bool eq = true;
  146372:	2001      	movs	r0, #1
        bool gt = false;
  146374:	f04f 0c00 	mov.w	r12, #0
            leftop = dst.addr[i];
  146378:	f811 2f01 	ldrb.w	r2, [r1, #1]!
            rightop = n.addr[i];

            /* We rephrase rnd > n-2 as rnd >= n-1. Since n is odd, n-1 is obtained
             * by masking 1 bit.
             */
            if (i == dst.len - 1) {
  14637c:	eba1 0b05 	sub.w	r11, r1, r5
  146380:	45b3      	cmp	r11, r6
            rightop = n.addr[i];
  146382:	f81e 3f01 	ldrb.w	r3, [r14, #1]!
  146386:	bf08      	it	eq
  146388:	f003 03fe 	andeq.w	r3, r3, #254	; 0xfe
             * different byte onwards.
             * By muxing the leftop >= rightop check with eq, we ensure that it
             * only has an effect when executed on the first most significant byte
             * that is different between the arrays.
             */
            gt |= (bool)((rightop - leftop) >> 8) & eq;
  14638c:	eba3 0b02 	sub.w	r11, r3, r2
            eq &= (bool)(((rightop ^ leftop) - 1) >> 8);
  146390:	4053      	eors	r3, r2
            gt |= (bool)((rightop - leftop) >> 8) & eq;
  146392:	ea5f 2b1b 	movs.w	r11, r11, lsr #8
  146396:	bf18      	it	ne
  146398:	4602      	movne	r2, r0
            eq &= (bool)(((rightop ^ leftop) - 1) >> 8);
  14639a:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  14639e:	bf08      	it	eq
  1463a0:	2200      	moveq	r2, #0
  1463a2:	0a1b      	lsrs	r3, r3, #8
  1463a4:	bf08      	it	eq
  1463a6:	2000      	moveq	r0, #0
        for (uint32_t i = 0; i < dst.len; i++) {
  1463a8:	458a      	cmp	r10, r1
  1463aa:	ea4c 0c02 	orr.w	r12, r12, r2
  1463ae:	d1e3      	bne.n	146378 <rng_get_rand_less_ref+0x88>
        }

        rnd_invalid = gt | eq;
  1463b0:	ea4c 0000 	orr.w	r0, r12, r0

    }
    while (rnd_invalid);
  1463b4:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
  1463b8:	d1ce      	bne.n	146358 <rng_get_rand_less_ref+0x68>
  1463ba:	4683      	mov	r11, r0

    /* Compute k = rnd + 1 (constant time increment) */
    math_array_incr(dst.addr, dst.len, 1);
  1463bc:	4649      	mov	r1, r9
  1463be:	4628      	mov	r0, r5
  1463c0:	2201      	movs	r2, #1
  1463c2:	f001 f8eb 	bl	14759c <math_array_incr>

    return CRYPTOLIB_SUCCESS;
  1463c6:	4658      	mov	r0, r11
}
  1463c8:	b007      	add	sp, #28
  1463ca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_INVALID_PARAM;
  1463ce:	2009      	movs	r0, #9
}
  1463d0:	b007      	add	sp, #28
  1463d2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (; !n.addr[index]; index++);
  1463d6:	f8cd 9008 	str.w	r9, [r13, #8]
  1463da:	462f      	mov	r7, r5
    uint32_t index = 0;
  1463dc:	2200      	movs	r2, #0
  1463de:	e7a8      	b.n	146332 <rng_get_rand_less_ref+0x42>

001463e0 <rng_get_rand_lt_n_blk>:
 */

uint32_t rng_get_rand_lt_n_blk(uint32_t vce_id,
                               block_t n,
                               block_t dst)
{
  1463e0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1463e4:	b08b      	sub	sp, #44	; 0x2c
  1463e6:	ac03      	add	r4, sp, #12
  1463e8:	f8dd 8054 	ldr.w	r8, [r13, #84]	; 0x54
  1463ec:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  1463f0:	9b04      	ldr	r3, [sp, #16]
    if (dst.len != n.len) {
  1463f2:	4598      	cmp	r8, r3
  1463f4:	d168      	bne.n	1464c8 <rng_get_rand_lt_n_blk+0xe8>
  1463f6:	460e      	mov	r6, r1
        return CRYPTOLIB_INVALID_PARAM;
    }

    if (!(n.addr[n.len - 1] & 0x01)) { /*n must be odd*/
  1463f8:	eb01 0308 	add.w	r3, r1, r8
  1463fc:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  146400:	07db      	lsls	r3, r3, #31
  146402:	d561      	bpl.n	1464c8 <rng_get_rand_lt_n_blk+0xe8>
  146404:	9d14      	ldr	r5, [sp, #80]	; 0x50

    /*since n is odd, at minimum the
     *least significant byte should be
     *different from 0
     */
    for (index = 0; !n.addr[index]; index++);
  146406:	780b      	ldrb	r3, [r1, #0]
  146408:	2b00      	cmp	r3, #0
  14640a:	d161      	bne.n	1464d0 <rng_get_rand_lt_n_blk+0xf0>
  14640c:	461a      	mov	r2, r3
  14640e:	3201      	adds	r2, #1
  146410:	f811 3f01 	ldrb.w	r3, [r1, #1]!
  146414:	2b00      	cmp	r3, #0
  146416:	d0fa      	beq.n	14640e <rng_get_rand_lt_n_blk+0x2e>
  146418:	eb05 0902 	add.w	r9, r5, r2
  14641c:	eba8 0b02 	sub.w	r11, r8, r2

    for (msb_mask = 0xFF; n.addr[index] & msb_mask; msb_mask <<= 1);
  146420:	24ff      	movs	r4, #255	; 0xff
  146422:	0064      	lsls	r4, r4, #1
  146424:	b2e4      	uxtb	r4, r4
  146426:	ea13 0104 	ands.w	r1, r3, r4
  14642a:	d1fa      	bne.n	146422 <rng_get_rand_lt_n_blk+0x42>
  14642c:	4682      	mov	r10, r0
  14642e:	1e73      	subs	r3, r6, #1

    /* Create container for random value from RNG, pointing to the same buffer as
     * dst but referring only to [MSB-1:0] instead of [len-1:0].
     * Force the leading, non-significant bytes to zero.
     */
    memset(dst.addr, 0, index);
  146430:	4628      	mov	r0, r5
  146432:	43e4      	mvns	r4, r4
  146434:	9301      	str	r3, [sp, #4]
  146436:	f108 36ff 	add.w	r6, r8, #4294967295	; 0xffffffff
  14643a:	f00c ee20 	blx	15307c <memset>
  14643e:	1e6b      	subs	r3, r5, #1
  146440:	b264      	sxtb	r4, r4
  146442:	9302      	str	r3, [sp, #8]
  146444:	19af      	adds	r7, r5, r6
    block_t rnd = block_t_convert(dst.addr + index, dst.len - index, dst.addr_type);
  146446:	9b16      	ldr	r3, [sp, #88]	; 0x58
  146448:	e9cd 9b07 	strd	r9, r11, [r13, #28]
  14644c:	9309      	str	r3, [sp, #36]	; 0x24

    do {
        /* Get a random value */
        trng_get_rand_blk(vce_id, rnd);
  14644e:	4650      	mov	r0, r10
  146450:	ab07      	add	r3, sp, #28
  146452:	cb0e      	ldmia	r3, {r1, r2, r3}
  146454:	f7ff fdb0 	bl	145fb8 <trng_get_rand_blk>
         * a highest byte <= 0x06 is only 7/256 without masking.
         * With the masking process (msb_mask = 0xF8, ~msb_mask = 0x07) we
         * significantly increase the chances of immediately finding a suitable
         * random.
         */
        dst.addr[index] &= ~msb_mask; /*Note that dst.addr[index] = rnd.addr[0]*/
  146458:	f899 3000 	ldrb.w	r3, [r9]
  14645c:	4023      	ands	r3, r4
  14645e:	f889 3000 	strb.w	r3, [r9]

        /* Check if rnd > n-2 (constant time comparison) */
        bool gt = false;
        bool eq = true;

        for (uint32_t i = 0; i < dst.len; i++) {
  146462:	f1b8 0f00 	cmp.w	r8, #0
  146466:	d0f2      	beq.n	14644e <rng_get_rand_lt_n_blk+0x6e>
  146468:	e9dd e101 	ldrd	r14, r1, [r13, #4]
        bool eq = true;
  14646c:	2001      	movs	r0, #1
        bool gt = false;
  14646e:	f04f 0c00 	mov.w	r12, #0
            uint32_t leftop = dst.addr[i];
  146472:	f811 2f01 	ldrb.w	r2, [r1, #1]!
            uint32_t rightop = n.addr[i];

            /* We rephrase rnd > n-2 as rnd >= n-1. Since n is odd, n-1 is obtained
             * by masking 1 bit.
             */
            if (i == dst.len - 1) {
  146476:	eba1 0b05 	sub.w	r11, r1, r5
  14647a:	45b3      	cmp	r11, r6
            uint32_t rightop = n.addr[i];
  14647c:	f81e 3f01 	ldrb.w	r3, [r14, #1]!
  146480:	bf08      	it	eq
  146482:	f003 03fe 	andeq.w	r3, r3, #254	; 0xfe
             * different byte onwards.
             * By muxing the leftop >= rightop check with eq, we ensure that it
             * only has an effect when executed on the first most significant byte
             * that is different between the arrays.
             */
            gt |= (bool)((rightop - leftop) >> 8) & eq;
  146486:	eba3 0b02 	sub.w	r11, r3, r2
            eq &= (bool)(((rightop ^ leftop) - 1) >> 8);
  14648a:	4053      	eors	r3, r2
            gt |= (bool)((rightop - leftop) >> 8) & eq;
  14648c:	ea5f 2b1b 	movs.w	r11, r11, lsr #8
  146490:	bf18      	it	ne
  146492:	4602      	movne	r2, r0
            eq &= (bool)(((rightop ^ leftop) - 1) >> 8);
  146494:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
  146498:	bf08      	it	eq
  14649a:	2200      	moveq	r2, #0
  14649c:	0a1b      	lsrs	r3, r3, #8
  14649e:	bf08      	it	eq
  1464a0:	2000      	moveq	r0, #0
        for (uint32_t i = 0; i < dst.len; i++) {
  1464a2:	428f      	cmp	r7, r1
  1464a4:	ea4c 0c02 	orr.w	r12, r12, r2
  1464a8:	d1e3      	bne.n	146472 <rng_get_rand_lt_n_blk+0x92>
        }

        rnd_invalid = gt | eq;
  1464aa:	ea4c 0000 	orr.w	r0, r12, r0

    }
    while (rnd_invalid);
  1464ae:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
  1464b2:	d1cc      	bne.n	14644e <rng_get_rand_lt_n_blk+0x6e>
  1464b4:	4683      	mov	r11, r0

    /* Compute k = rnd + 1 (constant time increment) */
    math_array_incr(dst.addr, dst.len, 1);
  1464b6:	4641      	mov	r1, r8
  1464b8:	4628      	mov	r0, r5
  1464ba:	2201      	movs	r2, #1
  1464bc:	f001 f86e 	bl	14759c <math_array_incr>

    return CRYPTOLIB_SUCCESS;
  1464c0:	4658      	mov	r0, r11
}
  1464c2:	b00b      	add	sp, #44	; 0x2c
  1464c4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return CRYPTOLIB_INVALID_PARAM;
  1464c8:	2009      	movs	r0, #9
}
  1464ca:	b00b      	add	sp, #44	; 0x2c
  1464cc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (index = 0; !n.addr[index]; index++);
  1464d0:	46c3      	mov	r11, r8
  1464d2:	46a9      	mov	r9, r5
  1464d4:	2200      	movs	r2, #0
  1464d6:	e7a3      	b.n	146420 <rng_get_rand_lt_n_blk+0x40>

001464d8 <ecc_curve_bytesize>:

uint32_t ecc_curve_bytesize(const sx_ecc_curve_t* curve)
{
    return curve->bytesize;
}
  1464d8:	6900      	ldr	r0, [r0, #16]
  1464da:	4770      	bx	r14

001464dc <ecc_generate_private_key>:
}

uint32_t ecc_generate_private_key(uint32_t vce_id,
                                  block_t n,
                                  block_t priv)
{
  1464dc:	b430      	push	{r4, r5}
  1464de:	4605      	mov	r5, r0
  1464e0:	b084      	sub	sp, #16
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  1464e2:	4628      	mov	r0, r5
{
  1464e4:	ac01      	add	r4, sp, #4
  1464e6:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  1464ea:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
}
  1464ee:	b004      	add	sp, #16
  1464f0:	bc30      	pop	{r4, r5}
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  1464f2:	f7ff bf75 	b.w	1463e0 <rng_get_rand_lt_n_blk>
  1464f6:	bf00      	nop

001464f8 <ecc_generate_public_key>:
                                 block_t group,
                                 block_t pub,
                                 block_t priv,
                                 uint32_t size,
                                 uint32_t curve_flags)
{
  1464f8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  1464fc:	b088      	sub	sp, #32
  1464fe:	ac05      	add	r4, sp, #20
  146500:	9d16      	ldr	r5, [sp, #88]	; 0x58
  146502:	f8dd 8050 	ldr.w	r8, [r13, #80]	; 0x50
    uint32_t status;

    // Only domain of 5,6 parameters are supported (Weierstrass p/b and Edwards)
    if (pub.len != 2 * size || priv.len != size ||
  146506:	9f11      	ldr	r7, [sp, #68]	; 0x44
  146508:	006e      	lsls	r6, r5, #1
{
  14650a:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    if (pub.len != 2 * size || priv.len != size ||
  14650e:	4545      	cmp	r5, r8
  146510:	bf08      	it	eq
  146512:	42b7      	cmpeq	r7, r6
  146514:	d004      	beq.n	146520 <ecc_generate_public_key+0x28>
            (group.len != 6 * size && group.len != 5 * size)) {
        return CRYPTOLIB_INVALID_PARAM;
  146516:	2409      	movs	r4, #9
#if AUTO_OUTPUT_BY_CE
#else
    CryptoRAM2point_rev(vce_id, pub, size, BA414EP_MEMLOC_6);
#endif
    return CRYPTOLIB_SUCCESS;
}
  146518:	4620      	mov	r0, r4
  14651a:	b008      	add	sp, #32
  14651c:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  146520:	9b06      	ldr	r3, [sp, #24]
            (group.len != 6 * size && group.len != 5 * size)) {
  146522:	442e      	add	r6, r5
    if (pub.len != 2 * size || priv.len != size ||
  146524:	ebb3 0f46 	cmp.w	r3, r6, lsl #1
  146528:	d003      	beq.n	146532 <ecc_generate_public_key+0x3a>
            (group.len != 6 * size && group.len != 5 * size)) {
  14652a:	eb05 0285 	add.w	r2, r5, r5, lsl #2
  14652e:	429a      	cmp	r2, r3
  146530:	d1f1      	bne.n	146516 <ecc_generate_public_key+0x1e>
    pke_load_curve(vce_id, group, size, BA414EP_LITTLEEND, 1);
  146532:	f04f 0900 	mov.w	r9, #0
  146536:	f04f 0a01 	mov.w	r10, #1
    pke_set_command(vce_id, BA414EP_OPTYPE_ECC_POINT_MULT, size, BA414EP_LITTLEEND, curve_flags);
  14653a:	9b17      	ldr	r3, [sp, #92]	; 0x5c
  14653c:	4606      	mov	r6, r0
  14653e:	9300      	str	r3, [sp, #0]
  146540:	462a      	mov	r2, r5
  146542:	464b      	mov	r3, r9
  146544:	2122      	movs	r1, #34	; 0x22
  146546:	f7fd fe15 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, group, size, BA414EP_LITTLEEND, 1);
  14654a:	9500      	str	r5, [sp, #0]
  14654c:	f8cd a008 	str.w	r10, [r13, #8]
  146550:	4630      	mov	r0, r6
  146552:	f8cd 9004 	str.w	r9, [r13, #4]
    mem2CryptoRAM_rev(vce_id, priv, priv.len, BA414EP_MEMLOC_14, true);
  146556:	270e      	movs	r7, #14
    pke_load_curve(vce_id, group, size, BA414EP_LITTLEEND, 1);
  146558:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  14655c:	f7fd fe8a 	bl	144274 <pke_load_curve>
    mem2CryptoRAM_rev(vce_id, priv, priv.len, BA414EP_MEMLOC_14, true);
  146560:	f8cd a008 	str.w	r10, [r13, #8]
  146564:	ab13      	add	r3, sp, #76	; 0x4c
  146566:	f8cd 8000 	str.w	r8, [r13]
  14656a:	4630      	mov	r0, r6
  14656c:	cb0e      	ldmia	r3, {r1, r2, r3}
  14656e:	9701      	str	r7, [sp, #4]
  146570:	f7fe fcb8 	bl	144ee4 <mem2CryptoRAM_rev>
    pke_set_config(vce_id, BA414EP_MEMLOC_2, BA414EP_MEMLOC_14, BA414EP_MEMLOC_6, 0x0);
  146574:	463a      	mov	r2, r7
  146576:	2306      	movs	r3, #6
  146578:	2102      	movs	r1, #2
  14657a:	f8cd 9000 	str.w	r9, [r13]
  14657e:	4630      	mov	r0, r6
  146580:	f7fd fddc 	bl	14413c <pke_set_config>
    status = pke_start_wait_status(vce_id);
  146584:	4630      	mov	r0, r6
  146586:	f7fd fe11 	bl	1441ac <pke_start_wait_status>
    if (status) {
  14658a:	4604      	mov	r4, r0
  14658c:	b940      	cbnz	r0, 1465a0 <ecc_generate_public_key+0xa8>
    CryptoRAM2point_rev(vce_id, pub, size, BA414EP_MEMLOC_6);
  14658e:	2306      	movs	r3, #6
  146590:	4630      	mov	r0, r6
  146592:	e9cd 5300 	strd	r5, r3, [r13]
  146596:	ab10      	add	r3, sp, #64	; 0x40
  146598:	cb0e      	ldmia	r3, {r1, r2, r3}
  14659a:	f7fe fd69 	bl	145070 <CryptoRAM2point_rev>
    return CRYPTOLIB_SUCCESS;
  14659e:	e7bb      	b.n	146518 <ecc_generate_public_key+0x20>
        return CRYPTOLIB_CRYPTO_ERR;
  1465a0:	2406      	movs	r4, #6
  1465a2:	e7b9      	b.n	146518 <ecc_generate_public_key+0x20>

001465a4 <ecc_generate_keypair>:
{
  1465a4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1465a8:	4680      	mov	r8, r0
  1465aa:	b092      	sub	sp, #72	; 0x48
  1465ac:	af1b      	add	r7, sp, #108	; 0x6c
  1465ae:	ad09      	add	r5, sp, #36	; 0x24
  1465b0:	ae1e      	add	r6, sp, #120	; 0x78
  1465b2:	e885 000e 	stmia.w	r5, {r1, r2, r3}
  1465b6:	ac0c      	add	r4, sp, #48	; 0x30
  1465b8:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
  1465bc:	ab0f      	add	r3, sp, #60	; 0x3c
  1465be:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  1465c2:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  1465c6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  1465ca:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  1465ce:	4640      	mov	r0, r8
  1465d0:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  1465d4:	f7ff ff04 	bl	1463e0 <rng_get_rand_lt_n_blk>
    if (status) {
  1465d8:	b990      	cbnz	r0, 146600 <ecc_generate_keypair+0x5c>
    return ecc_generate_public_key(vce_id, group, pub, priv, size, curve_flags);
  1465da:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  1465de:	9c22      	ldr	r4, [sp, #136]	; 0x88
  1465e0:	ab03      	add	r3, sp, #12
  1465e2:	9407      	str	r4, [sp, #28]
  1465e4:	9c21      	ldr	r4, [sp, #132]	; 0x84
  1465e6:	9406      	str	r4, [sp, #24]
  1465e8:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1465ec:	ab18      	add	r3, sp, #96	; 0x60
  1465ee:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  1465f2:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  1465f6:	4640      	mov	r0, r8
  1465f8:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  1465fc:	f7ff ff7c 	bl	1464f8 <ecc_generate_public_key>
}
  146600:	b012      	add	sp, #72	; 0x48
  146602:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  146606:	bf00      	nop

00146608 <ecdsa_generate_digest.isra.0.constprop.1>:
 * @param digest_blk computed digest
 * @return CRYPTOLIB_INVALID_PARAM when there is not enough space in the
 *                                 digest_blk to compute the digest
 *         CRYPTOLIB_SUCCESS otherwise
 */
static uint32_t ecdsa_generate_digest(uint32_t vce_id,
  146608:	b082      	sub	sp, #8
  14660a:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14660e:	460c      	mov	r4, r1
  146610:	b08c      	sub	sp, #48	; 0x30
  146612:	4607      	mov	r7, r0
    uint32_t i = 0;
    uint32_t status;
    uint32_t dgst_local_len;
    uint8_t extra_bits;

    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  146614:	4608      	mov	r0, r1
static uint32_t ecdsa_generate_digest(uint32_t vce_id,
  146616:	a912      	add	r1, sp, #72	; 0x48
  146618:	9e16      	ldr	r6, [sp, #88]	; 0x58
  14661a:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  14661e:	f7ff ff5b 	bl	1464d8 <ecc_curve_bytesize>
    uint32_t curve_order_bitsize = math_array_nbits(
                                       curve->params.addr + curve_bytesize, curve_bytesize);
  146622:	6821      	ldr	r1, [r4, #0]
    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  146624:	4605      	mov	r5, r0
    uint32_t nbits = 8 * length;
  146626:	00c4      	lsls	r4, r0, #3
    for (i = 0; i < length; i++) {
  146628:	b178      	cbz	r0, 14664a <ecdsa_generate_digest.isra.0.constprop.1+0x42>
        if (a[i] == 0) {
  14662a:	180b      	adds	r3, r1, r0
  14662c:	5c0a      	ldrb	r2, [r1, r0]
  14662e:	2a00      	cmp	r2, #0
  146630:	d172      	bne.n	146718 <ecdsa_generate_digest.isra.0.constprop.1+0x110>
  146632:	3901      	subs	r1, #1
  146634:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  146638:	e003      	b.n	146642 <ecdsa_generate_digest.isra.0.constprop.1+0x3a>
  14663a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  14663e:	2a00      	cmp	r2, #0
  146640:	d16a      	bne.n	146718 <ecdsa_generate_digest.isra.0.constprop.1+0x110>
    for (i = 0; i < length; i++) {
  146642:	4299      	cmp	r1, r3
            nbits -= 8;
  146644:	f1a4 0408 	sub.w	r4, r4, #8
    for (i = 0; i < length; i++) {
  146648:	d1f7      	bne.n	14663a <ecdsa_generate_digest.isra.0.constprop.1+0x32>
    uint32_t curve_order_bytesize = (curve_order_bitsize + 7) / 8;
    uint32_t hash_len = hash_get_digest_size(hash_fct);
  14664a:	9815      	ldr	r0, [sp, #84]	; 0x54
  14664c:	f7fd f9c2 	bl	1439d4 <hash_get_digest_size>

    if (digest_blk->len < hash_len) {
  146650:	6873      	ldr	r3, [r6, #4]
    uint32_t hash_len = hash_get_digest_size(hash_fct);
  146652:	4680      	mov	r8, r0
    if (digest_blk->len < hash_len) {
  146654:	4298      	cmp	r0, r3
        return CRYPTOLIB_INVALID_PARAM;
  146656:	bf88      	it	hi
  146658:	2709      	movhi	r7, #9
    if (digest_blk->len < hash_len) {
  14665a:	d857      	bhi.n	14670c <ecdsa_generate_digest.isra.0.constprop.1+0x104>
    }

    /* Call hash fct to get digest. */
    status = hash_blk(hash_fct, vce_id, block_t_convert(NULL, 0, 0), message, *digest_blk);
  14665c:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  146660:	ab04      	add	r3, sp, #16
  146662:	f04f 0c00 	mov.w	r12, #0
  146666:	f10d 0e24 	add.w	r14, r13, #36	; 0x24
  14666a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14666e:	aa12      	add	r2, sp, #72	; 0x48
  146670:	e9cd cc09 	strd	r12, r12, [r13, #36]	; 0x24
  146674:	ab01      	add	r3, sp, #4
  146676:	ca07      	ldmia	r2, {r0, r1, r2}
  146678:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14667c:	f8cd c000 	str.w	r12, [r13]
  146680:	4639      	mov	r1, r7
  146682:	e89e 000c 	ldmia.w	r14, {r2, r3}
  146686:	9815      	ldr	r0, [sp, #84]	; 0x54
  146688:	f8cd c02c 	str.w	r12, [r13, #44]	; 0x2c
  14668c:	f7fd f9ac 	bl	1439e8 <hash_blk>

    if (status) {
  146690:	4607      	mov	r7, r0
  146692:	2800      	cmp	r0, #0
  146694:	d13a      	bne.n	14670c <ecdsa_generate_digest.isra.0.constprop.1+0x104>
    uint32_t curve_order_bytesize = (curve_order_bitsize + 7) / 8;
  146696:	1de3      	adds	r3, r4, #7
  146698:	08db      	lsrs	r3, r3, #3

    /* Define digest size. This only take the most significant bytes when curve
     * is smaller than hash. If it's greater, leading zeroes will be inserted
     * within ecdsa_signature_* functions.
     */
    dgst_local_len = curve_order_bytesize > hash_len ? hash_len : curve_order_bytesize;
  14669a:	4543      	cmp	r3, r8
  14669c:	bf28      	it	cs
  14669e:	4643      	movcs	r3, r8
    /* Bitshift if needed, for curve smaller than digest and with order N not on
     * bytes boundaries.
     */
    extra_bits = (curve_order_bitsize & 0x7);

    if (extra_bits && (hash_len * 8 > curve_order_bitsize)) {
  1466a0:	f014 0207 	ands.w	r2, r4, #7
    digest_blk->len = dgst_local_len;
  1466a4:	6073      	str	r3, [r6, #4]
    if (extra_bits && (hash_len * 8 > curve_order_bitsize)) {
  1466a6:	d01b      	beq.n	1466e0 <ecdsa_generate_digest.isra.0.constprop.1+0xd8>
  1466a8:	ebb4 0fc8 	cmp.w	r4, r8, lsl #3
  1466ac:	d218      	bcs.n	1466e0 <ecdsa_generate_digest.isra.0.constprop.1+0xd8>
        bitshift(digest_blk->addr, dgst_local_len,  8 - extra_bits);
  1466ae:	f1c2 0208 	rsb	r2, r2, #8
  1466b2:	6831      	ldr	r1, [r6, #0]
        for (i = 0; i < len; i++) {
  1466b4:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
        bitshift(digest_blk->addr, dgst_local_len,  8 - extra_bits);
  1466b8:	b2d4      	uxtb	r4, r2
        for (i = 0; i < len; i++) {
  1466ba:	d011      	beq.n	1466e0 <ecdsa_generate_digest.isra.0.constprop.1+0xd8>
  1466bc:	3901      	subs	r1, #1
  1466be:	440b      	add	r3, r1
        prev = 0;
  1466c0:	4684      	mov	r12, r0
  1466c2:	f1c4 0e08 	rsb	r14, r4, #8
            val = ((array[i] >> shift) & 0xFF) | prev;
  1466c6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
  1466ca:	fa42 f004 	asr.w	r0, r2, r4
  1466ce:	ea40 000c 	orr.w	r0, r0, r12
            prev = array[i] << (8 - shift);
  1466d2:	fa02 f20e 	lsl.w	r2, r2, r14
            array[i] = val;
  1466d6:	7008      	strb	r0, [r1, #0]
        for (i = 0; i < len; i++) {
  1466d8:	428b      	cmp	r3, r1
            prev = array[i] << (8 - shift);
  1466da:	fa5f fc82 	uxtb.w	r12, r2
        for (i = 0; i < len; i++) {
  1466de:	d1f2      	bne.n	1466c6 <ecdsa_generate_digest.isra.0.constprop.1+0xbe>
    }

    if (curve_bytesize > hash_len) {//insert 0 to meet key len
  1466e0:	4545      	cmp	r5, r8
  1466e2:	d913      	bls.n	14670c <ecdsa_generate_digest.isra.0.constprop.1+0x104>
  1466e4:	462a      	mov	r2, r5
        for (i = 0; i < hash_len; i++) {
  1466e6:	f1b8 0f00 	cmp.w	r8, #0
  1466ea:	d00a      	beq.n	146702 <ecdsa_generate_digest.isra.0.constprop.1+0xfa>
  1466ec:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
  1466f0:	eba5 0208 	sub.w	r2, r5, r8
            *(digest_blk->addr + curve_bytesize - 1 - i) = *(digest_blk->addr + hash_len - 1 - i);
  1466f4:	6831      	ldr	r1, [r6, #0]
  1466f6:	5cc8      	ldrb	r0, [r1, r3]
  1466f8:	4419      	add	r1, r3
  1466fa:	3b01      	subs	r3, #1
  1466fc:	5488      	strb	r0, [r1, r2]
        for (i = 0; i < hash_len; i++) {
  1466fe:	1c59      	adds	r1, r3, #1
  146700:	d1f8      	bne.n	1466f4 <ecdsa_generate_digest.isra.0.constprop.1+0xec>
        }

        memset(digest_blk->addr, 0, curve_bytesize - hash_len);
  146702:	6830      	ldr	r0, [r6, #0]
  146704:	2100      	movs	r1, #0
  146706:	f00c ecba 	blx	15307c <memset>
        digest_blk->len = curve_bytesize;
  14670a:	6075      	str	r5, [r6, #4]
    }

    return CRYPTOLIB_SUCCESS;
}
  14670c:	4638      	mov	r0, r7
  14670e:	b00c      	add	sp, #48	; 0x30
  146710:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146714:	b002      	add	sp, #8
  146716:	4770      	bx	r14
static uint32_t ecdsa_generate_digest(uint32_t vce_id,
  146718:	2307      	movs	r3, #7
                if (a[i] >> j) {
  14671a:	fa52 f103 	asrs.w	r1, r2, r3
  14671e:	d194      	bne.n	14664a <ecdsa_generate_digest.isra.0.constprop.1+0x42>
            for (j = 7; j > 0; j--) {
  146720:	3b01      	subs	r3, #1
                    nbits--;
  146722:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
            for (j = 7; j > 0; j--) {
  146726:	d1f8      	bne.n	14671a <ecdsa_generate_digest.isra.0.constprop.1+0x112>
  146728:	e78f      	b.n	14664a <ecdsa_generate_digest.isra.0.constprop.1+0x42>
  14672a:	bf00      	nop

0014672c <ecdsa_configure_signature>:
{
  14672c:	b082      	sub	sp, #8
  14672e:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146732:	4605      	mov	r5, r0
  146734:	b084      	sub	sp, #16
  146736:	460c      	mov	r4, r1
    uint32_t size = ecc_curve_bytesize(curve);
  146738:	4608      	mov	r0, r1
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  14673a:	2601      	movs	r6, #1
{
  14673c:	a90a      	add	r1, sp, #40	; 0x28
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  14673e:	f04f 0800 	mov.w	r8, #0
{
  146742:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t size = ecc_curve_bytesize(curve);
  146746:	f7ff fec7 	bl	1464d8 <ecc_curve_bytesize>
    pke_set_command(vce_id, BA414EP_OPTYPE_ECDSA_SIGN_GEN, size, BA414EP_LITTLEEND, curve->pk_flags);
  14674a:	68e3      	ldr	r3, [r4, #12]
  14674c:	2130      	movs	r1, #48	; 0x30
  14674e:	9300      	str	r3, [sp, #0]
  146750:	4643      	mov	r3, r8
    uint32_t size = ecc_curve_bytesize(curve);
  146752:	4607      	mov	r7, r0
    pke_set_command(vce_id, BA414EP_OPTYPE_ECDSA_SIGN_GEN, size, BA414EP_LITTLEEND, curve->pk_flags);
  146754:	4628      	mov	r0, r5
  146756:	463a      	mov	r2, r7
  146758:	f7fd fd0c 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  14675c:	9700      	str	r7, [sp, #0]
  14675e:	4628      	mov	r0, r5
  146760:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  146764:	e9cd 8601 	strd	r8, r6, [r13, #4]
    mem2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_6, true);
  146768:	2406      	movs	r4, #6
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  14676a:	f7fd fd83 	bl	144274 <pke_load_curve>
    mem2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_6, true);
  14676e:	9602      	str	r6, [sp, #8]
  146770:	9700      	str	r7, [sp, #0]
  146772:	ab0d      	add	r3, sp, #52	; 0x34
  146774:	4628      	mov	r0, r5
  146776:	cb0e      	ldmia	r3, {r1, r2, r3}
  146778:	9401      	str	r4, [sp, #4]
  14677a:	f7fe fbb3 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, formatted_digest, formatted_digest.len, BA414EP_MEMLOC_12, true);
  14677e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  146780:	9300      	str	r3, [sp, #0]
  146782:	ab0a      	add	r3, sp, #40	; 0x28
  146784:	220c      	movs	r2, #12
  146786:	4628      	mov	r0, r5
  146788:	e9cd 2601 	strd	r2, r6, [r13, #4]
  14678c:	cb0e      	ldmia	r3, {r1, r2, r3}
  14678e:	f7fe fba9 	bl	144ee4 <mem2CryptoRAM_rev>
}
  146792:	4640      	mov	r0, r8
  146794:	b004      	add	sp, #16
  146796:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  14679a:	b002      	add	sp, #8
  14679c:	4770      	bx	r14
  14679e:	bf00      	nop

001467a0 <ecdsa_attempt_signature>:
{
  1467a0:	b082      	sub	sp, #8
  1467a2:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  1467a6:	4689      	mov	r9, r1
  1467a8:	b088      	sub	sp, #32
  1467aa:	4607      	mov	r7, r0
  1467ac:	a910      	add	r1, sp, #64	; 0x40
    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  1467ae:	2060      	movs	r0, #96	; 0x60
        return CRYPTOLIB_PK_N_NOTVALID;
  1467b0:	2415      	movs	r4, #21
{
  1467b2:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  1467b6:	f7fc fe95 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  1467ba:	b3c0      	cbz	r0, 14682e <ecdsa_attempt_signature+0x8e>
  1467bc:	4606      	mov	r6, r0
    size = ecc_curve_bytesize(curve);
  1467be:	4648      	mov	r0, r9
  1467c0:	f04f 0a03 	mov.w	r10, #3
    status = trng_get_rand_blk(vce_id, rnd);
  1467c4:	ad05      	add	r5, sp, #20
        rnd_buff = mem_n->ptr;
  1467c6:	68b4      	ldr	r4, [r6, #8]
    size = ecc_curve_bytesize(curve);
  1467c8:	f7ff fe86 	bl	1464d8 <ecc_curve_bytesize>
  1467cc:	9405      	str	r4, [sp, #20]
  1467ce:	4680      	mov	r8, r0
    status = trng_get_rand_blk(vce_id, rnd);
  1467d0:	4638      	mov	r0, r7
  1467d2:	e9cd 8a06 	strd	r8, r10, [r13, #24]
  1467d6:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  1467da:	f7ff fbed 	bl	145fb8 <trng_get_rand_blk>
    if (status) {
  1467de:	4604      	mov	r4, r0
  1467e0:	bb10      	cbnz	r0, 146828 <ecdsa_attempt_signature+0x88>
    mem2CryptoRAM_rev(vce_id, rnd, rnd.len, BA414EP_MEMLOC_7, true);
  1467e2:	2201      	movs	r2, #1
  1467e4:	2307      	movs	r3, #7
  1467e6:	f8cd 8000 	str.w	r8, [r13]
  1467ea:	4638      	mov	r0, r7
  1467ec:	e9cd 3201 	strd	r3, r2, [r13, #4]
  1467f0:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  1467f4:	f7fe fb76 	bl	144ee4 <mem2CryptoRAM_rev>
    pke_set_command(vce_id,
  1467f8:	f8d9 200c 	ldr.w	r2, [r9, #12]
  1467fc:	4623      	mov	r3, r4
  1467fe:	9200      	str	r2, [sp, #0]
  146800:	2130      	movs	r1, #48	; 0x30
  146802:	4642      	mov	r2, r8
  146804:	4638      	mov	r0, r7
  146806:	f7fd fcb5 	bl	144174 <pke_set_command>
    status = pke_start_wait_status(vce_id);
  14680a:	4638      	mov	r0, r7
  14680c:	f7fd fcce 	bl	1441ac <pke_start_wait_status>
  146810:	4604      	mov	r4, r0
    if (status & CE_PK_SIGNATURE_NOTVALID_MASK) {
  146812:	0583      	lsls	r3, r0, #22
  146814:	d416      	bmi.n	146844 <ecdsa_attempt_signature+0xa4>
    else if (status) {
  146816:	b980      	cbnz	r0, 14683a <ecdsa_attempt_signature+0x9a>
    CryptoRAM2point_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  146818:	230a      	movs	r3, #10
  14681a:	4638      	mov	r0, r7
  14681c:	e9cd 8300 	strd	r8, r3, [r13]
  146820:	ab10      	add	r3, sp, #64	; 0x40
  146822:	cb0e      	ldmia	r3, {r1, r2, r3}
  146824:	f7fe fc24 	bl	145070 <CryptoRAM2point_rev>
    ce_free(mem_n);
  146828:	4630      	mov	r0, r6
  14682a:	f7fc fe9f 	bl	14356c <ce_free>
}
  14682e:	4620      	mov	r0, r4
  146830:	b008      	add	sp, #32
  146832:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  146836:	b002      	add	sp, #8
  146838:	4770      	bx	r14
        ce_free(mem_n);
  14683a:	4630      	mov	r0, r6
        return CRYPTOLIB_CRYPTO_ERR;
  14683c:	2406      	movs	r4, #6
        ce_free(mem_n);
  14683e:	f7fc fe95 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;
  146842:	e7f4      	b.n	14682e <ecdsa_attempt_signature+0x8e>
        ce_free(mem_n);
  146844:	4630      	mov	r0, r6
        return CRYPTOLIB_INVALID_SIGN_ERR;
  146846:	4654      	mov	r4, r10
        ce_free(mem_n);
  146848:	f7fc fe90 	bl	14356c <ce_free>
        return CRYPTOLIB_INVALID_SIGN_ERR;
  14684c:	e7ef      	b.n	14682e <ecdsa_attempt_signature+0x8e>
  14684e:	bf00      	nop

00146850 <ecdsa_generate_signature_digest>:
{
  146850:	b082      	sub	sp, #8
  146852:	b570      	push	{r4, r5, r6, r14}
  146854:	460e      	mov	r6, r1
  146856:	b084      	sub	sp, #16
    uint32_t status = ecdsa_configure_signature(vce_id, curve, formatted_digest, key);
  146858:	ac0b      	add	r4, sp, #44	; 0x2c
{
  14685a:	4605      	mov	r5, r0
  14685c:	a908      	add	r1, sp, #32
  14685e:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t status = ecdsa_configure_signature(vce_id, curve, formatted_digest, key);
  146862:	ab01      	add	r3, sp, #4
  146864:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
  146868:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  14686a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14686e:	4631      	mov	r1, r6
  146870:	ab08      	add	r3, sp, #32
  146872:	4628      	mov	r0, r5
  146874:	cb0c      	ldmia	r3, {r2, r3}
  146876:	9400      	str	r4, [sp, #0]
  146878:	f7ff ff58 	bl	14672c <ecdsa_configure_signature>
    if (status) {
  14687c:	b950      	cbnz	r0, 146894 <ecdsa_generate_signature_digest+0x44>
  14687e:	ac0e      	add	r4, sp, #56	; 0x38
        status = ecdsa_attempt_signature(vce_id, curve, signature);
  146880:	9b10      	ldr	r3, [sp, #64]	; 0x40
  146882:	4631      	mov	r1, r6
  146884:	9300      	str	r3, [sp, #0]
  146886:	4628      	mov	r0, r5
  146888:	e894 000c 	ldmia.w	r4, {r2, r3}
  14688c:	f7ff ff88 	bl	1467a0 <ecdsa_attempt_signature>
    while ((status == CRYPTOLIB_INVALID_SIGN_ERR) && (ctr < 10));
  146890:	2803      	cmp	r0, #3
  146892:	d0f5      	beq.n	146880 <ecdsa_generate_signature_digest+0x30>
}
  146894:	b004      	add	sp, #16
  146896:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
  14689a:	b002      	add	sp, #8
  14689c:	4770      	bx	r14
  14689e:	bf00      	nop

001468a0 <ecdsa_verify_signature_digest>:
{
  1468a0:	b082      	sub	sp, #8
  1468a2:	b5f0      	push	{r4, r5, r6, r7, r14}
  1468a4:	4604      	mov	r4, r0
  1468a6:	b085      	sub	sp, #20
  1468a8:	460d      	mov	r5, r1
    uint32_t size = ecc_curve_bytesize(curve);
  1468aa:	4608      	mov	r0, r1
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  1468ac:	2701      	movs	r7, #1
{
  1468ae:	a90a      	add	r1, sp, #40	; 0x28
  1468b0:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t size = ecc_curve_bytesize(curve);
  1468b4:	f7ff fe10 	bl	1464d8 <ecc_curve_bytesize>
    pke_set_command(vce_id, BA414EP_OPTYPE_ECDSA_SIGN_VERIF, size, BA414EP_LITTLEEND, curve->pk_flags);
  1468b8:	68eb      	ldr	r3, [r5, #12]
  1468ba:	2131      	movs	r1, #49	; 0x31
  1468bc:	9300      	str	r3, [sp, #0]
  1468be:	2300      	movs	r3, #0
    uint32_t size = ecc_curve_bytesize(curve);
  1468c0:	4606      	mov	r6, r0
    pke_set_command(vce_id, BA414EP_OPTYPE_ECDSA_SIGN_VERIF, size, BA414EP_LITTLEEND, curve->pk_flags);
  1468c2:	4620      	mov	r0, r4
  1468c4:	4632      	mov	r2, r6
  1468c6:	f7fd fc55 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  1468ca:	f04f 0c00 	mov.w	r12, #0
  1468ce:	9600      	str	r6, [sp, #0]
  1468d0:	4620      	mov	r0, r4
  1468d2:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  1468d6:	e9cd c701 	strd	r12, r7, [r13, #4]
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  1468da:	2508      	movs	r5, #8
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  1468dc:	f7fd fcca 	bl	144274 <pke_load_curve>
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  1468e0:	9600      	str	r6, [sp, #0]
  1468e2:	4620      	mov	r0, r4
  1468e4:	ab0d      	add	r3, sp, #52	; 0x34
  1468e6:	cb0e      	ldmia	r3, {r1, r2, r3}
  1468e8:	9501      	str	r5, [sp, #4]
    point2CryptoRAM_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  1468ea:	250a      	movs	r5, #10
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  1468ec:	f7fe fb4a 	bl	144f84 <point2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, formatted_digest, formatted_digest.len, BA414EP_MEMLOC_12, true);
  1468f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1468f2:	9300      	str	r3, [sp, #0]
  1468f4:	ab0a      	add	r3, sp, #40	; 0x28
  1468f6:	220c      	movs	r2, #12
  1468f8:	4620      	mov	r0, r4
  1468fa:	e9cd 2701 	strd	r2, r7, [r13, #4]
  1468fe:	cb0e      	ldmia	r3, {r1, r2, r3}
  146900:	f7fe faf0 	bl	144ee4 <mem2CryptoRAM_rev>
    point2CryptoRAM_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  146904:	9600      	str	r6, [sp, #0]
  146906:	ab10      	add	r3, sp, #64	; 0x40
  146908:	4620      	mov	r0, r4
  14690a:	cb0e      	ldmia	r3, {r1, r2, r3}
  14690c:	9501      	str	r5, [sp, #4]
  14690e:	f7fe fb39 	bl	144f84 <point2CryptoRAM_rev>
    return pke_start_wait_status(vce_id);
  146912:	4620      	mov	r0, r4
}
  146914:	b005      	add	sp, #20
  146916:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  14691a:	b002      	add	sp, #8
    return pke_start_wait_status(vce_id);
  14691c:	f7fd bc46 	b.w	1441ac <pke_start_wait_status>

00146920 <ecdsa_generate_signature>:
                                  const void* curve_info,
                                  block_t message,
                                  block_t key,
                                  block_t signature,
                                  hash_alg_t hash_fct)
{
  146920:	b082      	sub	sp, #8
  146922:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146926:	4688      	mov	r8, r1
  146928:	b08c      	sub	sp, #48	; 0x30
  14692a:	4607      	mov	r7, r0
  14692c:	a912      	add	r1, sp, #72	; 0x48
    uint32_t status;
    const sx_ecc_curve_t* curve;
    uint8_t* digest;
    struct mem_node* mem_n;

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  14692e:	2040      	movs	r0, #64	; 0x40

    if (mem_n != NULL) {
        digest = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  146930:	2515      	movs	r5, #21
{
  146932:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(MAX_DIGESTSIZE);
  146936:	f7fc fdd5 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  14693a:	b358      	cbz	r0, 146994 <ecdsa_generate_signature+0x74>
    }

    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  14693c:	2340      	movs	r3, #64	; 0x40
  14693e:	4604      	mov	r4, r0
  146940:	6880      	ldr	r0, [r0, #8]

    curve = (sx_ecc_curve_t*)curve_info;

    //memset(digest, 0xff, MAX_DIGESTSIZE);

    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  146942:	ae09      	add	r6, sp, #36	; 0x24
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146944:	930a      	str	r3, [sp, #40]	; 0x28
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  146946:	ab12      	add	r3, sp, #72	; 0x48
  146948:	9a14      	ldr	r2, [sp, #80]	; 0x50
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  14694a:	2503      	movs	r5, #3
  14694c:	9009      	str	r0, [sp, #36]	; 0x24
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  14694e:	4641      	mov	r1, r8
  146950:	981b      	ldr	r0, [sp, #108]	; 0x6c
  146952:	e9cd 2000 	strd	r2, r0, [r13]
  146956:	4638      	mov	r0, r7
  146958:	9602      	str	r6, [sp, #8]
  14695a:	cb0c      	ldmia	r3, {r2, r3}
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  14695c:	950b      	str	r5, [sp, #44]	; 0x2c
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  14695e:	f7ff fe53 	bl	146608 <ecdsa_generate_digest.isra.0.constprop.1>

    if (status) {
  146962:	4605      	mov	r5, r0
  146964:	b998      	cbnz	r0, 14698e <ecdsa_generate_signature+0x6e>
        ce_free(mem_n);
        return status;
    }

    status = ecdsa_generate_signature_digest(vce_id, curve, digest_blk, key, signature/*, rng*/);
  146966:	aa18      	add	r2, sp, #96	; 0x60
  146968:	ab15      	add	r3, sp, #84	; 0x54
  14696a:	ad04      	add	r5, sp, #16
  14696c:	ca07      	ldmia	r2, {r0, r1, r2}
  14696e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  146972:	ad01      	add	r5, sp, #4
  146974:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  146978:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  14697a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  14697e:	9300      	str	r3, [sp, #0]
  146980:	4641      	mov	r1, r8
  146982:	e896 000c 	ldmia.w	r6, {r2, r3}
  146986:	4638      	mov	r0, r7
  146988:	f7ff ff62 	bl	146850 <ecdsa_generate_signature_digest>
  14698c:	4605      	mov	r5, r0
    ce_free(mem_n);
  14698e:	4620      	mov	r0, r4
  146990:	f7fc fdec 	bl	14356c <ce_free>
    return status;
}
  146994:	4628      	mov	r0, r5
  146996:	b00c      	add	sp, #48	; 0x30
  146998:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  14699c:	b002      	add	sp, #8
  14699e:	4770      	bx	r14

001469a0 <ecdsa_verify_signature>:
                                const void* curve_info,
                                block_t message,
                                block_t key,
                                block_t signature,
                                hash_alg_t hash_fct)
{
  1469a0:	b082      	sub	sp, #8
  1469a2:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1469a6:	4688      	mov	r8, r1
  1469a8:	b08c      	sub	sp, #48	; 0x30
  1469aa:	4607      	mov	r7, r0
  1469ac:	a912      	add	r1, sp, #72	; 0x48

    const sx_ecc_curve_t* curve = (sx_ecc_curve_t*)curve_info;
    uint8_t* digest;
    struct mem_node* mem_n;

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  1469ae:	2040      	movs	r0, #64	; 0x40

    if (mem_n != NULL) {
        digest = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  1469b0:	2515      	movs	r5, #21
{
  1469b2:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(MAX_DIGESTSIZE);
  1469b6:	f7fc fd95 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  1469ba:	b358      	cbz	r0, 146a14 <ecdsa_verify_signature+0x74>
    }

    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  1469bc:	2340      	movs	r3, #64	; 0x40
  1469be:	4604      	mov	r4, r0
  1469c0:	6880      	ldr	r0, [r0, #8]

    curve = (sx_ecc_curve_t*)curve_info;

    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  1469c2:	ae09      	add	r6, sp, #36	; 0x24
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  1469c4:	930a      	str	r3, [sp, #40]	; 0x28
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  1469c6:	ab12      	add	r3, sp, #72	; 0x48
  1469c8:	9a14      	ldr	r2, [sp, #80]	; 0x50
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  1469ca:	2503      	movs	r5, #3
  1469cc:	9009      	str	r0, [sp, #36]	; 0x24
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  1469ce:	4641      	mov	r1, r8
  1469d0:	981b      	ldr	r0, [sp, #108]	; 0x6c
  1469d2:	e9cd 2000 	strd	r2, r0, [r13]
  1469d6:	4638      	mov	r0, r7
  1469d8:	9602      	str	r6, [sp, #8]
  1469da:	cb0c      	ldmia	r3, {r2, r3}
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  1469dc:	950b      	str	r5, [sp, #44]	; 0x2c
    status = ecdsa_generate_digest(vce_id, curve, message, key, signature, hash_fct, &digest_blk);
  1469de:	f7ff fe13 	bl	146608 <ecdsa_generate_digest.isra.0.constprop.1>

    if (status) {
  1469e2:	4605      	mov	r5, r0
  1469e4:	b998      	cbnz	r0, 146a0e <ecdsa_verify_signature+0x6e>
        LTRACEF("ecdsa_generate_digest result: 0x%x\n", status);
        ce_free(mem_n);
        return status;
    }

    status = ecdsa_verify_signature_digest(vce_id, curve, digest_blk, key, signature);
  1469e6:	aa18      	add	r2, sp, #96	; 0x60
  1469e8:	ab15      	add	r3, sp, #84	; 0x54
  1469ea:	ad04      	add	r5, sp, #16
  1469ec:	ca07      	ldmia	r2, {r0, r1, r2}
  1469ee:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1469f2:	ad01      	add	r5, sp, #4
  1469f4:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  1469f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  1469fa:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1469fe:	9300      	str	r3, [sp, #0]
  146a00:	4641      	mov	r1, r8
  146a02:	e896 000c 	ldmia.w	r6, {r2, r3}
  146a06:	4638      	mov	r0, r7
  146a08:	f7ff ff4a 	bl	1468a0 <ecdsa_verify_signature_digest>
  146a0c:	4605      	mov	r5, r0
    ce_free(mem_n);
  146a0e:	4620      	mov	r0, r4
  146a10:	f7fc fdac 	bl	14356c <ce_free>
    return status;
}
  146a14:	4628      	mov	r0, r5
  146a16:	b00c      	add	sp, #48	; 0x30
  146a18:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146a1c:	b002      	add	sp, #8
  146a1e:	4770      	bx	r14

00146a20 <sm2_configure_signature>:

uint32_t sm2_configure_signature(uint32_t vce_id,
                                 const sx_ecc_curve_t* curve,
                                 block_t formatted_digest,
                                 block_t key)
{
  146a20:	b082      	sub	sp, #8
  146a22:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146a26:	4606      	mov	r6, r0
  146a28:	b084      	sub	sp, #16
  146a2a:	460c      	mov	r4, r1
    uint32_t size = ecc_curve_bytesize(curve);
  146a2c:	4608      	mov	r0, r1

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_GEN, size, BA414EP_LITTLEEND, curve->pk_flags);

    // Load parameters
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146a2e:	2701      	movs	r7, #1
{
  146a30:	a90a      	add	r1, sp, #40	; 0x28
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146a32:	f04f 0800 	mov.w	r8, #0
{
  146a36:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t size = ecc_curve_bytesize(curve);
  146a3a:	f7ff fd4d 	bl	1464d8 <ecc_curve_bytesize>
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_GEN, size, BA414EP_LITTLEEND, curve->pk_flags);
  146a3e:	68e3      	ldr	r3, [r4, #12]
  146a40:	212d      	movs	r1, #45	; 0x2d
  146a42:	9300      	str	r3, [sp, #0]
  146a44:	4643      	mov	r3, r8
    uint32_t size = ecc_curve_bytesize(curve);
  146a46:	4605      	mov	r5, r0
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_GEN, size, BA414EP_LITTLEEND, curve->pk_flags);
  146a48:	4602      	mov	r2, r0
  146a4a:	4630      	mov	r0, r6
  146a4c:	f7fd fb92 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146a50:	9500      	str	r5, [sp, #0]
  146a52:	4630      	mov	r0, r6
  146a54:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  146a58:	e9cd 8701 	strd	r8, r7, [r13, #4]

    /* Load SM2 parameters */
    mem2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_6, true);
  146a5c:	2406      	movs	r4, #6
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146a5e:	f7fd fc09 	bl	144274 <pke_load_curve>
    mem2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_6, true);
  146a62:	9702      	str	r7, [sp, #8]
  146a64:	9500      	str	r5, [sp, #0]
  146a66:	ab0d      	add	r3, sp, #52	; 0x34
  146a68:	4630      	mov	r0, r6
  146a6a:	cb0e      	ldmia	r3, {r1, r2, r3}
  146a6c:	9401      	str	r4, [sp, #4]
  146a6e:	f7fe fa39 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, formatted_digest, size, BA414EP_MEMLOC_12, true);
  146a72:	230c      	movs	r3, #12
  146a74:	9702      	str	r7, [sp, #8]
  146a76:	4630      	mov	r0, r6
  146a78:	e9cd 5300 	strd	r5, r3, [r13]
  146a7c:	ab0a      	add	r3, sp, #40	; 0x28
  146a7e:	cb0e      	ldmia	r3, {r1, r2, r3}
  146a80:	f7fe fa30 	bl	144ee4 <mem2CryptoRAM_rev>

    return CRYPTOLIB_SUCCESS;
}
  146a84:	4640      	mov	r0, r8
  146a86:	b004      	add	sp, #16
  146a88:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146a8c:	b002      	add	sp, #8
  146a8e:	4770      	bx	r14

00146a90 <sm2_attempt_signature>:

uint32_t sm2_attempt_signature(uint32_t vce_id,
                               const sx_ecc_curve_t* curve,
                               block_t signature)
{
  146a90:	b082      	sub	sp, #8
  146a92:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146a96:	4688      	mov	r8, r1
  146a98:	b088      	sub	sp, #32
  146a9a:	4607      	mov	r7, r0
  146a9c:	a90e      	add	r1, sp, #56	; 0x38
    uint32_t size;
    block_t rnd;
    uint8_t* rnd_buff;
    struct mem_node* mem_n;

    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  146a9e:	2060      	movs	r0, #96	; 0x60

    if (mem_n != NULL) {
        rnd_buff = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  146aa0:	2415      	movs	r4, #21
{
  146aa2:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  146aa6:	f7fc fd1d 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  146aaa:	2800      	cmp	r0, #0
  146aac:	d03e      	beq.n	146b2c <sm2_attempt_signature+0x9c>
  146aae:	4606      	mov	r6, r0
    }

    size = ecc_curve_bytesize(curve);
  146ab0:	4640      	mov	r0, r8
        rnd_buff = mem_n->ptr;
  146ab2:	68b4      	ldr	r4, [r6, #8]
    size = ecc_curve_bytesize(curve);
  146ab4:	f7ff fd10 	bl	1464d8 <ecc_curve_bytesize>
  146ab8:	2303      	movs	r3, #3
    rnd = block_t_convert(rnd_buff, size, EXT_MEM);

    //TODO: use trng IP to generate random number after IP work
#if !WITH_SIMULATION_PLATFORM //rng not work on paladium
    status = trng_get_rand(vce_id, rnd_buff, (size % 4) ? (size + 4 - size % 4) : size);
  146aba:	4621      	mov	r1, r4
  146abc:	9405      	str	r4, [sp, #20]
  146abe:	9307      	str	r3, [sp, #28]
    size = ecc_curve_bytesize(curve);
  146ac0:	4605      	mov	r5, r0
    status = trng_get_rand(vce_id, rnd_buff, (size % 4) ? (size + 4 - size % 4) : size);
  146ac2:	0782      	lsls	r2, r0, #30
  146ac4:	bf0c      	ite	eq
  146ac6:	4602      	moveq	r2, r0
  146ac8:	f020 0203 	bicne.w	r2, r0, #3
  146acc:	4638      	mov	r0, r7
  146ace:	bf18      	it	ne
  146ad0:	3204      	addne	r2, #4
  146ad2:	f7ff fa6b 	bl	145fac <trng_get_rand>

    if (status) {
  146ad6:	4604      	mov	r4, r0
  146ad8:	bb28      	cbnz	r0, 146b26 <sm2_attempt_signature+0x96>
    // Fetch the results by PKE config
#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size, 0x1 << BA414EP_MEMLOC_10 | 0x1 << BA414EP_MEMLOC_11, _paddr((void*)signature.addr), signature.addr_type);
#endif

    mem2CryptoRAM_rev(vce_id, rnd, rnd.len, BA414EP_MEMLOC_7, true);
  146ada:	f04f 0e01 	mov.w	r14, #1
  146ade:	ab08      	add	r3, sp, #32
  146ae0:	f04f 0c07 	mov.w	r12, #7
  146ae4:	4638      	mov	r0, r7
  146ae6:	9506      	str	r5, [sp, #24]
  146ae8:	9500      	str	r5, [sp, #0]
  146aea:	e913 000e 	ldmdb	r3, {r1, r2, r3}
  146aee:	e9cd ce01 	strd	r12, r14, [r13, #4]
  146af2:	f7fe f9f7 	bl	144ee4 <mem2CryptoRAM_rev>

    /* SM2 signature generation */
    pke_set_command(vce_id,
  146af6:	f8d8 300c 	ldr.w	r3, [r8, #12]
  146afa:	9300      	str	r3, [sp, #0]
  146afc:	462a      	mov	r2, r5
  146afe:	4623      	mov	r3, r4
  146b00:	212d      	movs	r1, #45	; 0x2d
  146b02:	4638      	mov	r0, r7
  146b04:	f7fd fb36 	bl	144174 <pke_set_command>
                    BA414EP_OPTYPE_SM2_SIGN_GEN,
                    size,
                    BA414EP_LITTLEEND,
                    curve->pk_flags);

    status = pke_start_wait_status(vce_id);
  146b08:	4638      	mov	r0, r7
  146b0a:	f7fd fb4f 	bl	1441ac <pke_start_wait_status>
  146b0e:	4604      	mov	r4, r0

    if (status & CE_PK_SIGNATURE_NOTVALID_MASK) {
  146b10:	0583      	lsls	r3, r0, #22
  146b12:	d416      	bmi.n	146b42 <sm2_attempt_signature+0xb2>
        ce_free(mem_n);
        return CRYPTOLIB_INVALID_SIGN_ERR;
    }
    else if (status) {
  146b14:	b980      	cbnz	r0, 146b38 <sm2_attempt_signature+0xa8>
    }

    // Fetch the results
#if AUTO_OUTPUT_BY_CE
#else
    CryptoRAM2point_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  146b16:	230a      	movs	r3, #10
  146b18:	4638      	mov	r0, r7
  146b1a:	e9cd 5300 	strd	r5, r3, [r13]
  146b1e:	ab0e      	add	r3, sp, #56	; 0x38
  146b20:	cb0e      	ldmia	r3, {r1, r2, r3}
  146b22:	f7fe faa5 	bl	145070 <CryptoRAM2point_rev>
#endif
    ce_free(mem_n);
  146b26:	4630      	mov	r0, r6
  146b28:	f7fc fd20 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  146b2c:	4620      	mov	r0, r4
  146b2e:	b008      	add	sp, #32
  146b30:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146b34:	b002      	add	sp, #8
  146b36:	4770      	bx	r14
        ce_free(mem_n);
  146b38:	4630      	mov	r0, r6
        return CRYPTOLIB_CRYPTO_ERR;
  146b3a:	2406      	movs	r4, #6
        ce_free(mem_n);
  146b3c:	f7fc fd16 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;
  146b40:	e7f4      	b.n	146b2c <sm2_attempt_signature+0x9c>
        ce_free(mem_n);
  146b42:	4630      	mov	r0, r6
        return CRYPTOLIB_INVALID_SIGN_ERR;
  146b44:	2403      	movs	r4, #3
        ce_free(mem_n);
  146b46:	f7fc fd11 	bl	14356c <ce_free>
        return CRYPTOLIB_INVALID_SIGN_ERR;
  146b4a:	e7ef      	b.n	146b2c <sm2_attempt_signature+0x9c>

00146b4c <sm2_generate_signature_digest>:
uint32_t sm2_generate_signature_digest(uint32_t vce_id,
                                       const sx_ecc_curve_t* curve,
                                       block_t formatted_digest,
                                       block_t key,
                                       block_t signature)
{
  146b4c:	b082      	sub	sp, #8
  146b4e:	b570      	push	{r4, r5, r6, r14}
  146b50:	460e      	mov	r6, r1
  146b52:	b084      	sub	sp, #16
    uint32_t ctr = 0;
    uint32_t status = sm2_configure_signature(vce_id, curve, formatted_digest, key);
  146b54:	ac0b      	add	r4, sp, #44	; 0x2c
{
  146b56:	4605      	mov	r5, r0
  146b58:	a908      	add	r1, sp, #32
  146b5a:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t status = sm2_configure_signature(vce_id, curve, formatted_digest, key);
  146b5e:	ab01      	add	r3, sp, #4
  146b60:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
  146b64:	9c0a      	ldr	r4, [sp, #40]	; 0x28
  146b66:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  146b6a:	4631      	mov	r1, r6
  146b6c:	ab08      	add	r3, sp, #32
  146b6e:	4628      	mov	r0, r5
  146b70:	cb0c      	ldmia	r3, {r2, r3}
  146b72:	9400      	str	r4, [sp, #0]
  146b74:	f7ff ff54 	bl	146a20 <sm2_configure_signature>

    if (status) {
  146b78:	b950      	cbnz	r0, 146b90 <sm2_generate_signature_digest+0x44>
  146b7a:	ac0e      	add	r4, sp, #56	; 0x38
        return status;
    }

    do {
        status = sm2_attempt_signature(vce_id, curve, signature/*, rng*/);
  146b7c:	9b10      	ldr	r3, [sp, #64]	; 0x40
  146b7e:	4631      	mov	r1, r6
  146b80:	9300      	str	r3, [sp, #0]
  146b82:	4628      	mov	r0, r5
  146b84:	e894 000c 	ldmia.w	r4, {r2, r3}
  146b88:	f7ff ff82 	bl	146a90 <sm2_attempt_signature>
    }
    while ((status == CRYPTOLIB_INVALID_SIGN_ERR) && (ctr < 10));
  146b8c:	2803      	cmp	r0, #3
  146b8e:	d0f5      	beq.n	146b7c <sm2_generate_signature_digest+0x30>
    if (status) {
        return status;
    }

    return CRYPTOLIB_SUCCESS;
}
  146b90:	b004      	add	sp, #16
  146b92:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
  146b96:	b002      	add	sp, #8
  146b98:	4770      	bx	r14
  146b9a:	bf00      	nop

00146b9c <sm2_verify_signature_digest>:
uint32_t sm2_verify_signature_digest(uint32_t vce_id,
                                     const sx_ecc_curve_t* curve,
                                     block_t formatted_digest,
                                     block_t key,
                                     block_t signature)
{
  146b9c:	b082      	sub	sp, #8
  146b9e:	b5f0      	push	{r4, r5, r6, r7, r14}
  146ba0:	4604      	mov	r4, r0
  146ba2:	b085      	sub	sp, #20
  146ba4:	460d      	mov	r5, r1
    uint32_t size = ecc_curve_bytesize(curve);
  146ba6:	4608      	mov	r0, r1

    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_VERIF, size, BA414EP_LITTLEEND, curve->pk_flags);
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146ba8:	2701      	movs	r7, #1
{
  146baa:	a90a      	add	r1, sp, #40	; 0x28
  146bac:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t size = ecc_curve_bytesize(curve);
  146bb0:	f7ff fc92 	bl	1464d8 <ecc_curve_bytesize>
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_VERIF, size, BA414EP_LITTLEEND, curve->pk_flags);
  146bb4:	68eb      	ldr	r3, [r5, #12]
  146bb6:	212e      	movs	r1, #46	; 0x2e
  146bb8:	9300      	str	r3, [sp, #0]
  146bba:	2300      	movs	r3, #0
    uint32_t size = ecc_curve_bytesize(curve);
  146bbc:	4606      	mov	r6, r0
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_SIGN_VERIF, size, BA414EP_LITTLEEND, curve->pk_flags);
  146bbe:	4620      	mov	r0, r4
  146bc0:	4632      	mov	r2, r6
  146bc2:	f7fd fad7 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146bc6:	f04f 0c00 	mov.w	r12, #0
  146bca:	9600      	str	r6, [sp, #0]
  146bcc:	4620      	mov	r0, r4
  146bce:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  146bd2:	e9cd c701 	strd	r12, r7, [r13, #4]

    /* Load SM2 parameters */
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  146bd6:	2508      	movs	r5, #8
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146bd8:	f7fd fb4c 	bl	144274 <pke_load_curve>
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  146bdc:	9600      	str	r6, [sp, #0]
  146bde:	4620      	mov	r0, r4
  146be0:	ab0d      	add	r3, sp, #52	; 0x34
  146be2:	cb0e      	ldmia	r3, {r1, r2, r3}
  146be4:	9501      	str	r5, [sp, #4]
    mem2CryptoRAM_rev(vce_id, formatted_digest, formatted_digest.len, BA414EP_MEMLOC_12, true);
    point2CryptoRAM_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  146be6:	250a      	movs	r5, #10
    point2CryptoRAM_rev(vce_id, key, size, BA414EP_MEMLOC_8);
  146be8:	f7fe f9cc 	bl	144f84 <point2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, formatted_digest, formatted_digest.len, BA414EP_MEMLOC_12, true);
  146bec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  146bee:	9300      	str	r3, [sp, #0]
  146bf0:	ab0a      	add	r3, sp, #40	; 0x28
  146bf2:	220c      	movs	r2, #12
  146bf4:	4620      	mov	r0, r4
  146bf6:	e9cd 2701 	strd	r2, r7, [r13, #4]
  146bfa:	cb0e      	ldmia	r3, {r1, r2, r3}
  146bfc:	f7fe f972 	bl	144ee4 <mem2CryptoRAM_rev>
    point2CryptoRAM_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  146c00:	9600      	str	r6, [sp, #0]
  146c02:	ab10      	add	r3, sp, #64	; 0x40
  146c04:	4620      	mov	r0, r4
  146c06:	cb0e      	ldmia	r3, {r1, r2, r3}
  146c08:	9501      	str	r5, [sp, #4]
  146c0a:	f7fe f9bb 	bl	144f84 <point2CryptoRAM_rev>

    /* SM2 signature verification */
    return pke_start_wait_status(vce_id);
  146c0e:	4620      	mov	r0, r4
}
  146c10:	b005      	add	sp, #20
  146c12:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
  146c16:	b002      	add	sp, #8
    return pke_start_wait_status(vce_id);
  146c18:	f7fd bac8 	b.w	1441ac <pke_start_wait_status>

00146c1c <sm2_generate_digest>:
uint32_t sm2_generate_digest(uint32_t vce_id,
                             const sx_ecc_curve_t* curve,
                             block_t message,
                             hash_alg_t hash_fct,
                             block_t* digest_blk)
{
  146c1c:	b082      	sub	sp, #8
  146c1e:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146c22:	460c      	mov	r4, r1
  146c24:	b08c      	sub	sp, #48	; 0x30
  146c26:	4607      	mov	r7, r0
    uint32_t i;
    uint32_t status;
    uint32_t dgst_local_len;
    uint8_t extra_bits;

    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  146c28:	4608      	mov	r0, r1
{
  146c2a:	a912      	add	r1, sp, #72	; 0x48
  146c2c:	9e16      	ldr	r6, [sp, #88]	; 0x58
  146c2e:	e881 000c 	stmia.w	r1, {r2, r3}
    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  146c32:	f7ff fc51 	bl	1464d8 <ecc_curve_bytesize>
    uint32_t curve_order_bitsize = math_array_nbits_sm2(
                                       curve->params.addr + curve_bytesize, curve_bytesize);
  146c36:	6821      	ldr	r1, [r4, #0]
    uint32_t curve_bytesize = ecc_curve_bytesize(curve);
  146c38:	4605      	mov	r5, r0
    uint32_t nbits = 8 * length;
  146c3a:	00c4      	lsls	r4, r0, #3
    for (i = 0; i < length; i++) {
  146c3c:	b178      	cbz	r0, 146c5e <sm2_generate_digest+0x42>
        if (a[i] == 0) {
  146c3e:	180b      	adds	r3, r1, r0
  146c40:	5c0a      	ldrb	r2, [r1, r0]
  146c42:	2a00      	cmp	r2, #0
  146c44:	d173      	bne.n	146d2e <sm2_generate_digest+0x112>
  146c46:	3901      	subs	r1, #1
  146c48:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  146c4c:	e003      	b.n	146c56 <sm2_generate_digest+0x3a>
  146c4e:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  146c52:	2a00      	cmp	r2, #0
  146c54:	d16b      	bne.n	146d2e <sm2_generate_digest+0x112>
    for (i = 0; i < length; i++) {
  146c56:	4299      	cmp	r1, r3
            nbits -= 8;
  146c58:	f1a4 0408 	sub.w	r4, r4, #8
    for (i = 0; i < length; i++) {
  146c5c:	d1f7      	bne.n	146c4e <sm2_generate_digest+0x32>
    uint32_t curve_order_bytesize = (curve_order_bitsize + 7) / 8;
    uint32_t hash_len = hash_get_digest_size(hash_fct);
  146c5e:	9815      	ldr	r0, [sp, #84]	; 0x54
  146c60:	f7fc feb8 	bl	1439d4 <hash_get_digest_size>

    if (digest_blk->len < hash_len) {
  146c64:	6873      	ldr	r3, [r6, #4]
    uint32_t hash_len = hash_get_digest_size(hash_fct);
  146c66:	4680      	mov	r8, r0
    if (digest_blk->len < hash_len) {
  146c68:	4283      	cmp	r3, r0
        return CRYPTOLIB_INVALID_PARAM;
  146c6a:	bf38      	it	cc
  146c6c:	2709      	movcc	r7, #9
    if (digest_blk->len < hash_len) {
  146c6e:	d358      	bcc.n	146d22 <sm2_generate_digest+0x106>
    }
    else {
        digest_blk->len = hash_len;
  146c70:	6070      	str	r0, [r6, #4]
    }

    /* Call hash fct to get digest. */
    status = hash_blk(hash_fct, vce_id, block_t_convert(NULL, 0, 0), message, *digest_blk);
  146c72:	ab04      	add	r3, sp, #16
  146c74:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  146c78:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  146c7c:	aa12      	add	r2, sp, #72	; 0x48
  146c7e:	f04f 0c00 	mov.w	r12, #0
  146c82:	f10d 0e24 	add.w	r14, r13, #36	; 0x24
  146c86:	ab01      	add	r3, sp, #4
  146c88:	ca07      	ldmia	r2, {r0, r1, r2}
  146c8a:	e9cd cc09 	strd	r12, r12, [r13, #36]	; 0x24
  146c8e:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  146c92:	f8cd c000 	str.w	r12, [r13]
  146c96:	4639      	mov	r1, r7
  146c98:	e89e 000c 	ldmia.w	r14, {r2, r3}
  146c9c:	9815      	ldr	r0, [sp, #84]	; 0x54
  146c9e:	f8cd c02c 	str.w	r12, [r13, #44]	; 0x2c
  146ca2:	f7fc fea1 	bl	1439e8 <hash_blk>

    if (status) {
  146ca6:	4607      	mov	r7, r0
  146ca8:	2800      	cmp	r0, #0
  146caa:	d13a      	bne.n	146d22 <sm2_generate_digest+0x106>
    uint32_t curve_order_bytesize = (curve_order_bitsize + 7) / 8;
  146cac:	1de3      	adds	r3, r4, #7
  146cae:	08db      	lsrs	r3, r3, #3

    /* Define digest size. This only take the most significant bytes when curve
     * is smaller than hash. If it's greater, leading zeroes will be inserted
     * within sm2_signature_* functions.
     */
    dgst_local_len = curve_order_bytesize > hash_len ? hash_len : curve_order_bytesize;
  146cb0:	4543      	cmp	r3, r8
  146cb2:	bf28      	it	cs
  146cb4:	4643      	movcs	r3, r8
    /* Bitshift if needed, for curve smaller than digest and with order N not on
     * bytes boundaries.
     */
    extra_bits = (curve_order_bitsize & 0x7);

    if (extra_bits && (hash_len * 8 > curve_order_bitsize)) {
  146cb6:	f014 0207 	ands.w	r2, r4, #7
    digest_blk->len = dgst_local_len;
  146cba:	6073      	str	r3, [r6, #4]
    if (extra_bits && (hash_len * 8 > curve_order_bitsize)) {
  146cbc:	d01b      	beq.n	146cf6 <sm2_generate_digest+0xda>
  146cbe:	ebb4 0fc8 	cmp.w	r4, r8, lsl #3
  146cc2:	d218      	bcs.n	146cf6 <sm2_generate_digest+0xda>
        bitshift_sm2(digest_blk->addr, dgst_local_len,  8 - extra_bits);
  146cc4:	f1c2 0208 	rsb	r2, r2, #8
  146cc8:	6831      	ldr	r1, [r6, #0]
        for (i = 0; i < len; i++) {
  146cca:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
        bitshift_sm2(digest_blk->addr, dgst_local_len,  8 - extra_bits);
  146cce:	b2d4      	uxtb	r4, r2
        for (i = 0; i < len; i++) {
  146cd0:	d011      	beq.n	146cf6 <sm2_generate_digest+0xda>
  146cd2:	3901      	subs	r1, #1
  146cd4:	440b      	add	r3, r1
        prev = 0;
  146cd6:	4684      	mov	r12, r0
  146cd8:	f1c4 0e08 	rsb	r14, r4, #8
            val = ((array[i] >> shift) & 0xFF) | prev;
  146cdc:	f811 2f01 	ldrb.w	r2, [r1, #1]!
  146ce0:	fa42 f004 	asr.w	r0, r2, r4
  146ce4:	ea40 000c 	orr.w	r0, r0, r12
            prev = array[i] << (8 - shift);
  146ce8:	fa02 f20e 	lsl.w	r2, r2, r14
            array[i] = val;
  146cec:	7008      	strb	r0, [r1, #0]
        for (i = 0; i < len; i++) {
  146cee:	428b      	cmp	r3, r1
            prev = array[i] << (8 - shift);
  146cf0:	fa5f fc82 	uxtb.w	r12, r2
        for (i = 0; i < len; i++) {
  146cf4:	d1f2      	bne.n	146cdc <sm2_generate_digest+0xc0>
    }

    if (curve_bytesize > hash_len) {//insert 0 to meet key len
  146cf6:	4545      	cmp	r5, r8
  146cf8:	d913      	bls.n	146d22 <sm2_generate_digest+0x106>
  146cfa:	462a      	mov	r2, r5
        for (i = 0; i < hash_len; i++) {
  146cfc:	f1b8 0f00 	cmp.w	r8, #0
  146d00:	d00a      	beq.n	146d18 <sm2_generate_digest+0xfc>
  146d02:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
  146d06:	eba5 0208 	sub.w	r2, r5, r8
            *(digest_blk->addr + curve_bytesize - 1 - i) = *(digest_blk->addr + hash_len - 1 - i);
  146d0a:	6831      	ldr	r1, [r6, #0]
  146d0c:	5cc8      	ldrb	r0, [r1, r3]
  146d0e:	4419      	add	r1, r3
  146d10:	3b01      	subs	r3, #1
  146d12:	5488      	strb	r0, [r1, r2]
        for (i = 0; i < hash_len; i++) {
  146d14:	1c59      	adds	r1, r3, #1
  146d16:	d1f8      	bne.n	146d0a <sm2_generate_digest+0xee>
        }

        memset(digest_blk->addr, 0, curve_bytesize - hash_len);
  146d18:	6830      	ldr	r0, [r6, #0]
  146d1a:	2100      	movs	r1, #0
  146d1c:	f00c e9ae 	blx	15307c <memset>
        digest_blk->len = curve_bytesize;
  146d20:	6075      	str	r5, [r6, #4]
    }

    return CRYPTOLIB_SUCCESS;
}
  146d22:	4638      	mov	r0, r7
  146d24:	b00c      	add	sp, #48	; 0x30
  146d26:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146d2a:	b002      	add	sp, #8
  146d2c:	4770      	bx	r14
{
  146d2e:	2307      	movs	r3, #7
                if (a[i] >> j) {
  146d30:	fa52 f103 	asrs.w	r1, r2, r3
  146d34:	d193      	bne.n	146c5e <sm2_generate_digest+0x42>
            for (j = 7; j > 0; j--) {
  146d36:	3b01      	subs	r3, #1
                    nbits--;
  146d38:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
            for (j = 7; j > 0; j--) {
  146d3c:	d1f8      	bne.n	146d30 <sm2_generate_digest+0x114>
  146d3e:	e78e      	b.n	146c5e <sm2_generate_digest+0x42>

00146d40 <sm2_generate_signature>:
                                const void* curve_info,
                                block_t message,
                                block_t key,
                                block_t signature,
                                hash_alg_t hash_fct)
{
  146d40:	b082      	sub	sp, #8
  146d42:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146d46:	4688      	mov	r8, r1
  146d48:	b08c      	sub	sp, #48	; 0x30
  146d4a:	4607      	mov	r7, r0
  146d4c:	a912      	add	r1, sp, #72	; 0x48
    uint32_t status;
    const sx_ecc_curve_t* curve;
    uint8_t* digest;
    struct mem_node* mem_n;

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  146d4e:	2040      	movs	r0, #64	; 0x40

    if (mem_n != NULL) {
        digest = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  146d50:	2515      	movs	r5, #21
{
  146d52:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(MAX_DIGESTSIZE);
  146d56:	f7fc fbc5 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  146d5a:	b358      	cbz	r0, 146db4 <sm2_generate_signature+0x74>
    }

    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146d5c:	2340      	movs	r3, #64	; 0x40
  146d5e:	4604      	mov	r4, r0
  146d60:	6880      	ldr	r0, [r0, #8]
    curve = (sx_ecc_curve_t*)curve_info;

    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146d62:	ae09      	add	r6, sp, #36	; 0x24
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146d64:	930a      	str	r3, [sp, #40]	; 0x28
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146d66:	ab12      	add	r3, sp, #72	; 0x48
  146d68:	9a14      	ldr	r2, [sp, #80]	; 0x50
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146d6a:	2503      	movs	r5, #3
  146d6c:	9009      	str	r0, [sp, #36]	; 0x24
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146d6e:	4641      	mov	r1, r8
  146d70:	981b      	ldr	r0, [sp, #108]	; 0x6c
  146d72:	e9cd 2000 	strd	r2, r0, [r13]
  146d76:	4638      	mov	r0, r7
  146d78:	9602      	str	r6, [sp, #8]
  146d7a:	cb0c      	ldmia	r3, {r2, r3}
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146d7c:	950b      	str	r5, [sp, #44]	; 0x2c
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146d7e:	f7ff ff4d 	bl	146c1c <sm2_generate_digest>

    if (status) {
  146d82:	4605      	mov	r5, r0
  146d84:	b998      	cbnz	r0, 146dae <sm2_generate_signature+0x6e>
        ce_free(mem_n);
        return status;
    }

    status = sm2_generate_signature_digest(vce_id, curve, digest_blk, key, signature);
  146d86:	aa18      	add	r2, sp, #96	; 0x60
  146d88:	ab15      	add	r3, sp, #84	; 0x54
  146d8a:	ad04      	add	r5, sp, #16
  146d8c:	ca07      	ldmia	r2, {r0, r1, r2}
  146d8e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  146d92:	ad01      	add	r5, sp, #4
  146d94:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  146d98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  146d9a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  146d9e:	9300      	str	r3, [sp, #0]
  146da0:	4641      	mov	r1, r8
  146da2:	e896 000c 	ldmia.w	r6, {r2, r3}
  146da6:	4638      	mov	r0, r7
  146da8:	f7ff fed0 	bl	146b4c <sm2_generate_signature_digest>
  146dac:	4605      	mov	r5, r0
    ce_free(mem_n);
  146dae:	4620      	mov	r0, r4
  146db0:	f7fc fbdc 	bl	14356c <ce_free>
    return status;
}
  146db4:	4628      	mov	r0, r5
  146db6:	b00c      	add	sp, #48	; 0x30
  146db8:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146dbc:	b002      	add	sp, #8
  146dbe:	4770      	bx	r14

00146dc0 <sm2_verify_signature>:
                              const void* curve_info,
                              block_t message,
                              block_t key,
                              block_t signature,
                              hash_alg_t hash_fct)
{
  146dc0:	b082      	sub	sp, #8
  146dc2:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146dc6:	4688      	mov	r8, r1
  146dc8:	b08c      	sub	sp, #48	; 0x30
  146dca:	4607      	mov	r7, r0
  146dcc:	a912      	add	r1, sp, #72	; 0x48
    uint32_t status;
    const sx_ecc_curve_t* curve;
    uint8_t* digest;
    struct mem_node* mem_n;

    mem_n = ce_malloc(MAX_DIGESTSIZE);
  146dce:	2040      	movs	r0, #64	; 0x40

    if (mem_n != NULL) {
        digest = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  146dd0:	2515      	movs	r5, #21
{
  146dd2:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(MAX_DIGESTSIZE);
  146dd6:	f7fc fb85 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  146dda:	b358      	cbz	r0, 146e34 <sm2_verify_signature+0x74>
    }

    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146ddc:	2340      	movs	r3, #64	; 0x40
  146dde:	4604      	mov	r4, r0
  146de0:	6880      	ldr	r0, [r0, #8]

    curve = (sx_ecc_curve_t*)curve_info;

    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146de2:	ae09      	add	r6, sp, #36	; 0x24
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146de4:	930a      	str	r3, [sp, #40]	; 0x28
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146de6:	ab12      	add	r3, sp, #72	; 0x48
  146de8:	9a14      	ldr	r2, [sp, #80]	; 0x50
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146dea:	2503      	movs	r5, #3
  146dec:	9009      	str	r0, [sp, #36]	; 0x24
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146dee:	4641      	mov	r1, r8
  146df0:	981b      	ldr	r0, [sp, #108]	; 0x6c
  146df2:	e9cd 2000 	strd	r2, r0, [r13]
  146df6:	4638      	mov	r0, r7
  146df8:	9602      	str	r6, [sp, #8]
  146dfa:	cb0c      	ldmia	r3, {r2, r3}
    digest_blk = block_t_convert(digest, MAX_DIGESTSIZE, EXT_MEM);
  146dfc:	950b      	str	r5, [sp, #44]	; 0x2c
    status = sm2_generate_digest(vce_id, curve, message, hash_fct, &digest_blk);
  146dfe:	f7ff ff0d 	bl	146c1c <sm2_generate_digest>

    if (status) {
  146e02:	4605      	mov	r5, r0
  146e04:	b998      	cbnz	r0, 146e2e <sm2_verify_signature+0x6e>
        ce_free(mem_n);
        return status;
    }

    status = sm2_verify_signature_digest(vce_id, curve, digest_blk, key, signature);
  146e06:	aa18      	add	r2, sp, #96	; 0x60
  146e08:	ab15      	add	r3, sp, #84	; 0x54
  146e0a:	ad04      	add	r5, sp, #16
  146e0c:	ca07      	ldmia	r2, {r0, r1, r2}
  146e0e:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  146e12:	ad01      	add	r5, sp, #4
  146e14:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  146e18:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
  146e1a:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  146e1e:	9300      	str	r3, [sp, #0]
  146e20:	4641      	mov	r1, r8
  146e22:	e896 000c 	ldmia.w	r6, {r2, r3}
  146e26:	4638      	mov	r0, r7
  146e28:	f7ff feb8 	bl	146b9c <sm2_verify_signature_digest>
  146e2c:	4605      	mov	r5, r0
    ce_free(mem_n);
  146e2e:	4620      	mov	r0, r4
  146e30:	f7fc fb9c 	bl	14356c <ce_free>
    return status;
}
  146e34:	4628      	mov	r0, r5
  146e36:	b00c      	add	sp, #48	; 0x30
  146e38:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  146e3c:	b002      	add	sp, #8
  146e3e:	4770      	bx	r14

00146e40 <sm2_key_exchange>:
                          block_t pointb,
                          block_t cofactor,
                          block_t pointa,
                          block_t two_w,
                          block_t ex_pub_key)
{
  146e40:	b082      	sub	sp, #8
  146e42:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  146e46:	460f      	mov	r7, r1
  146e48:	b089      	sub	sp, #36	; 0x24
  146e4a:	4604      	mov	r4, r0
  146e4c:	a912      	add	r1, sp, #72	; 0x48
    block_t rnd;
    const sx_ecc_curve_t* curve;
    uint8_t* rnd_buff;
    struct mem_node* mem_n;

    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  146e4e:	2060      	movs	r0, #96	; 0x60
{
  146e50:	e881 000c 	stmia.w	r1, {r2, r3}
    mem_n = ce_malloc(ECC_MAX_KEY_SIZE);
  146e54:	f7fc fb46 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  146e58:	2800      	cmp	r0, #0
  146e5a:	f000 8082 	beq.w	146f62 <sm2_key_exchange+0x122>
  146e5e:	4680      	mov	r8, r0
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    curve = (sx_ecc_curve_t*)curve_info;

    size = ecc_curve_bytesize(curve);
  146e60:	4638      	mov	r0, r7
  146e62:	f04f 0b03 	mov.w	r11, #3

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_KEY_EXCAHNGE, size, BA414EP_LITTLEEND, curve->pk_flags);

    // Load parameters
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146e66:	f04f 0901 	mov.w	r9, #1

    /* Load SM2 parameters */
    mem2CryptoRAM_rev(vce_id, prv_key, size, BA414EP_MEMLOC_6, true);
  146e6a:	f04f 0a06 	mov.w	r10, #6
        rnd_buff = mem_n->ptr;
  146e6e:	f8d8 6008 	ldr.w	r6, [r8, #8]
    size = ecc_curve_bytesize(curve);
  146e72:	f7ff fb31 	bl	1464d8 <ecc_curve_bytesize>
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_KEY_EXCAHNGE, size, BA414EP_LITTLEEND, curve->pk_flags);
  146e76:	68fb      	ldr	r3, [r7, #12]
  146e78:	212f      	movs	r1, #47	; 0x2f
  146e7a:	9300      	str	r3, [sp, #0]
  146e7c:	2300      	movs	r3, #0
  146e7e:	9605      	str	r6, [sp, #20]

    //TODO: use trng IP to generate random number after IP work
#if !WITH_SIMULATION_PLATFORM //rng not work on paladium
    status = trng_get_rand_blk(vce_id, rnd);
  146e80:	ae05      	add	r6, sp, #20
  146e82:	f8cd b01c 	str.w	r11, [r13, #28]
    size = ecc_curve_bytesize(curve);
  146e86:	4605      	mov	r5, r0
    pke_set_command(vce_id, BA414EP_OPTYPE_SM2_KEY_EXCAHNGE, size, BA414EP_LITTLEEND, curve->pk_flags);
  146e88:	4620      	mov	r0, r4
  146e8a:	462a      	mov	r2, r5
  146e8c:	9506      	str	r5, [sp, #24]
  146e8e:	f7fd f971 	bl	144174 <pke_set_command>
    pke_load_curve(vce_id, curve->params, size, BA414EP_LITTLEEND, 1);
  146e92:	2300      	movs	r3, #0
  146e94:	4620      	mov	r0, r4
  146e96:	9500      	str	r5, [sp, #0]
  146e98:	e9cd 3901 	strd	r3, r9, [r13, #4]
  146e9c:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  146ea0:	f7fd f9e8 	bl	144274 <pke_load_curve>
    mem2CryptoRAM_rev(vce_id, prv_key, size, BA414EP_MEMLOC_6, true);
  146ea4:	f8cd 9008 	str.w	r9, [r13, #8]
  146ea8:	ab12      	add	r3, sp, #72	; 0x48
  146eaa:	e9cd 5a00 	strd	r5, r10, [r13]
  146eae:	4620      	mov	r0, r4
  146eb0:	cb0e      	ldmia	r3, {r1, r2, r3}
  146eb2:	f7fe f817 	bl	144ee4 <mem2CryptoRAM_rev>
    status = trng_get_rand_blk(vce_id, rnd);
  146eb6:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  146eba:	4620      	mov	r0, r4
  146ebc:	f7ff f87c 	bl	145fb8 <trng_get_rand_blk>

    if (status) {
  146ec0:	4607      	mov	r7, r0
  146ec2:	2800      	cmp	r0, #0
  146ec4:	d144      	bne.n	146f50 <sm2_key_exchange+0x110>

    memcpy(rnd_buff, rnd_const, size);
    /* workaround end!!!!! */
#endif

    mem2CryptoRAM_rev(vce_id, rnd, size, BA414EP_MEMLOC_7, true);
  146ec6:	2307      	movs	r3, #7
  146ec8:	4620      	mov	r0, r4
  146eca:	f8cd 9008 	str.w	r9, [r13, #8]
  146ece:	e9cd 5300 	strd	r5, r3, [r13]
  146ed2:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  146ed6:	f7fe f805 	bl	144ee4 <mem2CryptoRAM_rev>

    point2CryptoRAM_rev(vce_id, pub_key, size, BA414EP_MEMLOC_8);
  146eda:	2608      	movs	r6, #8
  146edc:	ab15      	add	r3, sp, #84	; 0x54
  146ede:	9500      	str	r5, [sp, #0]
  146ee0:	4620      	mov	r0, r4
  146ee2:	cb0e      	ldmia	r3, {r1, r2, r3}
  146ee4:	9601      	str	r6, [sp, #4]
    point2CryptoRAM_rev(vce_id, pointb, size, BA414EP_MEMLOC_10);
  146ee6:	260a      	movs	r6, #10
    point2CryptoRAM_rev(vce_id, pub_key, size, BA414EP_MEMLOC_8);
  146ee8:	f7fe f84c 	bl	144f84 <point2CryptoRAM_rev>
    point2CryptoRAM_rev(vce_id, pointb, size, BA414EP_MEMLOC_10);
  146eec:	9500      	str	r5, [sp, #0]
  146eee:	4620      	mov	r0, r4
  146ef0:	ab18      	add	r3, sp, #96	; 0x60
  146ef2:	cb0e      	ldmia	r3, {r1, r2, r3}
  146ef4:	9601      	str	r6, [sp, #4]
    mem2CryptoRAM_rev(vce_id, cofactor, size, BA414EP_MEMLOC_12, true);
  146ef6:	260c      	movs	r6, #12
    point2CryptoRAM_rev(vce_id, pointb, size, BA414EP_MEMLOC_10);
  146ef8:	f7fe f844 	bl	144f84 <point2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, cofactor, size, BA414EP_MEMLOC_12, true);
  146efc:	f8cd 9008 	str.w	r9, [r13, #8]
  146f00:	9500      	str	r5, [sp, #0]
  146f02:	ab1b      	add	r3, sp, #108	; 0x6c
  146f04:	4620      	mov	r0, r4
  146f06:	cb0e      	ldmia	r3, {r1, r2, r3}
  146f08:	9601      	str	r6, [sp, #4]
    point2CryptoRAM_rev(vce_id, pointa, size, BA414EP_MEMLOC_13);
    mem2CryptoRAM_rev(vce_id, two_w, size, BA414EP_MEMLOC_15, true);
  146f0a:	260f      	movs	r6, #15
    mem2CryptoRAM_rev(vce_id, cofactor, size, BA414EP_MEMLOC_12, true);
  146f0c:	f7fd ffea 	bl	144ee4 <mem2CryptoRAM_rev>
    point2CryptoRAM_rev(vce_id, pointa, size, BA414EP_MEMLOC_13);
  146f10:	220d      	movs	r2, #13
  146f12:	9500      	str	r5, [sp, #0]
  146f14:	ab1e      	add	r3, sp, #120	; 0x78
  146f16:	9201      	str	r2, [sp, #4]
  146f18:	4620      	mov	r0, r4
  146f1a:	cb0e      	ldmia	r3, {r1, r2, r3}
  146f1c:	f7fe f832 	bl	144f84 <point2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, two_w, size, BA414EP_MEMLOC_15, true);
  146f20:	f8cd 9008 	str.w	r9, [r13, #8]
  146f24:	ab21      	add	r3, sp, #132	; 0x84
  146f26:	9500      	str	r5, [sp, #0]
  146f28:	4620      	mov	r0, r4
  146f2a:	cb0e      	ldmia	r3, {r1, r2, r3}
  146f2c:	9601      	str	r6, [sp, #4]
  146f2e:	f7fd ffd9 	bl	144ee4 <mem2CryptoRAM_rev>

    status = pke_start_wait_status(vce_id);
  146f32:	4620      	mov	r0, r4
  146f34:	f7fd f93a 	bl	1441ac <pke_start_wait_status>
  146f38:	4607      	mov	r7, r0

    if (status & CE_PK_SIGNATURE_NOTVALID_MASK) {
  146f3a:	0583      	lsls	r3, r0, #22
  146f3c:	d418      	bmi.n	146f70 <sm2_key_exchange+0x130>
        ce_free(mem_n);
        return CRYPTOLIB_INVALID_SIGN_ERR;
    }
    else if (status) {
  146f3e:	b990      	cbnz	r0, 146f66 <sm2_key_exchange+0x126>
    }

    // Fetch the results
#if AUTO_OUTPUT_BY_CE
#else
    CryptoRAM2point_rev(vce_id, ex_pub_key, size, BA414EP_MEMLOC_13);
  146f40:	220d      	movs	r2, #13
  146f42:	ab24      	add	r3, sp, #144	; 0x90
  146f44:	9500      	str	r5, [sp, #0]
  146f46:	4620      	mov	r0, r4
  146f48:	9201      	str	r2, [sp, #4]
  146f4a:	cb0e      	ldmia	r3, {r1, r2, r3}
  146f4c:	f7fe f890 	bl	145070 <CryptoRAM2point_rev>
#endif
    ce_free(mem_n);
  146f50:	4640      	mov	r0, r8
  146f52:	f7fc fb0b 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  146f56:	4638      	mov	r0, r7
  146f58:	b009      	add	sp, #36	; 0x24
  146f5a:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  146f5e:	b002      	add	sp, #8
  146f60:	4770      	bx	r14
        return CRYPTOLIB_PK_N_NOTVALID;
  146f62:	2715      	movs	r7, #21
  146f64:	e7f7      	b.n	146f56 <sm2_key_exchange+0x116>
        ce_free(mem_n);
  146f66:	4640      	mov	r0, r8
        return CRYPTOLIB_CRYPTO_ERR;
  146f68:	4657      	mov	r7, r10
        ce_free(mem_n);
  146f6a:	f7fc faff 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;
  146f6e:	e7f2      	b.n	146f56 <sm2_key_exchange+0x116>
        ce_free(mem_n);
  146f70:	4640      	mov	r0, r8
        return CRYPTOLIB_INVALID_SIGN_ERR;
  146f72:	465f      	mov	r7, r11
        ce_free(mem_n);
  146f74:	f7fc fafa 	bl	14356c <ce_free>
        return CRYPTOLIB_INVALID_SIGN_ERR;
  146f78:	e7ed      	b.n	146f56 <sm2_key_exchange+0x116>
  146f7a:	bf00      	nop

00146f7c <dsa_generate_private_key>:
#endif

uint32_t dsa_generate_private_key(uint32_t vce_id,
                                  block_t n,
                                  block_t priv)
{
  146f7c:	b430      	push	{r4, r5}
  146f7e:	4605      	mov	r5, r0
  146f80:	b084      	sub	sp, #16
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  146f82:	4628      	mov	r0, r5
{
  146f84:	ac01      	add	r4, sp, #4
  146f86:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  146f8a:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
}
  146f8e:	b004      	add	sp, #16
  146f90:	bc30      	pop	{r4, r5}
    return rng_get_rand_lt_n_blk(vce_id, n, priv);
  146f92:	f7ff ba25 	b.w	1463e0 <rng_get_rand_lt_n_blk>
  146f96:	bf00      	nop

00146f98 <dsa_generate_public_key>:
    uint32_t vce_id,
    block_t p,
    block_t generator,
    block_t priv_key,
    block_t pub_key)
{
  146f98:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  146f9c:	4604      	mov	r4, r0
  146f9e:	b088      	sub	sp, #32

    pke_set_dst_param(vce_id, pub_key.len, 0x1 << BA414EP_MEMLOC_8, (_paddr((void*)pub_key.addr)), pub_key.addr_type);

#endif

    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_KEY_GEN, size_adapt, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  146fa0:	f04f 0800 	mov.w	r8, #0
{
  146fa4:	ad05      	add	r5, sp, #20
    LTRACEF(" dsa_generate_public_key vce_id=%d .\n", vce_id);
  146fa6:	f245 70d0 	movw	r0, #22480	; 0x57d0

    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  146faa:	2701      	movs	r7, #1
{
  146fac:	e885 000e 	stmia.w	r5, {r1, r2, r3}
    LTRACEF(" dsa_generate_public_key vce_id=%d .\n", vce_id);
  146fb0:	f245 71a0 	movw	r1, #22432	; 0x57a0
  146fb4:	4623      	mov	r3, r4
    uint32_t size_adapt = p.len;
  146fb6:	9e06      	ldr	r6, [sp, #24]
    LTRACEF(" dsa_generate_public_key vce_id=%d .\n", vce_id);
  146fb8:	f2c0 0115 	movt	r1, #21
  146fbc:	2238      	movs	r2, #56	; 0x38
  146fbe:	f2c0 0015 	movt	r0, #21
  146fc2:	f00d f899 	bl	1540f8 <_printf>
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_KEY_GEN, size_adapt, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  146fc6:	4643      	mov	r3, r8
  146fc8:	4632      	mov	r2, r6
  146fca:	4620      	mov	r0, r4
  146fcc:	f8cd 8000 	str.w	r8, [r13]
  146fd0:	2118      	movs	r1, #24
  146fd2:	f7fd f8cf 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  146fd6:	e9cd 6800 	strd	r6, r8, [r13]
  146fda:	4620      	mov	r0, r4
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
    mem2CryptoRAM_rev(vce_id, priv_key, size_adapt, BA414EP_MEMLOC_6, true);
  146fdc:	f04f 0806 	mov.w	r8, #6
    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  146fe0:	e895 000e 	ldmia.w	r5, {r1, r2, r3}
  146fe4:	9702      	str	r7, [sp, #8]
  146fe6:	f7fd ff7d 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
  146fea:	2303      	movs	r3, #3
  146fec:	9600      	str	r6, [sp, #0]
  146fee:	4620      	mov	r0, r4
  146ff0:	e9cd 3701 	strd	r3, r7, [r13, #4]
  146ff4:	ab0e      	add	r3, sp, #56	; 0x38
  146ff6:	cb0e      	ldmia	r3, {r1, r2, r3}
  146ff8:	f7fd ff74 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, priv_key, size_adapt, BA414EP_MEMLOC_6, true);
  146ffc:	9600      	str	r6, [sp, #0]
  146ffe:	ab11      	add	r3, sp, #68	; 0x44
  147000:	9702      	str	r7, [sp, #8]
  147002:	4620      	mov	r0, r4
  147004:	cb0e      	ldmia	r3, {r1, r2, r3}
  147006:	f8cd 8004 	str.w	r8, [r13, #4]
  14700a:	f7fd ff6b 	bl	144ee4 <mem2CryptoRAM_rev>

    uint32_t error = pke_start_wait_status(vce_id);
  14700e:	4620      	mov	r0, r4
  147010:	f7fd f8cc 	bl	1441ac <pke_start_wait_status>

    if (error) {
  147014:	4605      	mov	r5, r0
  147016:	b968      	cbnz	r0, 147034 <dsa_generate_public_key+0x9c>
    }

#if AUTO_OUTPUT_BY_CE

#else
    CryptoRAM2mem_rev(vce_id, pub_key, pub_key.len, BA414EP_MEMLOC_8, true);
  147018:	2608      	movs	r6, #8
  14701a:	ab14      	add	r3, sp, #80	; 0x50
  14701c:	9702      	str	r7, [sp, #8]
  14701e:	4620      	mov	r0, r4
  147020:	9c15      	ldr	r4, [sp, #84]	; 0x54
  147022:	cb0e      	ldmia	r3, {r1, r2, r3}
  147024:	e9cd 4600 	strd	r4, r6, [r13]
  147028:	f7fd ffe0 	bl	144fec <CryptoRAM2mem_rev>
#endif

    return CRYPTOLIB_SUCCESS;
}
  14702c:	4628      	mov	r0, r5
  14702e:	b008      	add	sp, #32
  147030:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        LTRACEF("dsa_generate_public_key result: %d\n", error);
  147034:	f245 71a0 	movw	r1, #22432	; 0x57a0
  147038:	f645 0000 	movw	r0, #22528	; 0x5800
  14703c:	462b      	mov	r3, r5
  14703e:	f2c0 0115 	movt	r1, #21
  147042:	224a      	movs	r2, #74	; 0x4a
  147044:	f2c0 0015 	movt	r0, #21
  147048:	f00d f856 	bl	1540f8 <_printf>
        return CRYPTOLIB_CRYPTO_ERR;
  14704c:	4645      	mov	r5, r8
}
  14704e:	4628      	mov	r0, r5
  147050:	b008      	add	sp, #32
  147052:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  147056:	bf00      	nop

00147058 <dsa_generate_signature>:
    block_t q,
    block_t generator,
    block_t priv,
    block_t message,
    block_t signature)
{
  147058:	b082      	sub	sp, #8
  14705a:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14705e:	468b      	mov	r11, r1
  147060:	b097      	sub	sp, #92	; 0x5c
  147062:	4607      	mov	r7, r0
  147064:	a920      	add	r1, sp, #128	; 0x80
    uint32_t hash_len;
    block_t hash_block;
    uint32_t size_adapt;
    uint32_t rnd_len;

    mem_n = ce_malloc(DSA_MAX_SIZE_P);
  147066:	f44f 70c0 	mov.w	r0, #384	; 0x180

    if (mem_n != NULL) {
        k_buff = mem_n->ptr;
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
  14706a:	2515      	movs	r5, #21
{
  14706c:	e881 000c 	stmia.w	r1, {r2, r3}
  147070:	f8dd 8090 	ldr.w	r8, [r13, #144]	; 0x90
    mem_n = ce_malloc(DSA_MAX_SIZE_P);
  147074:	f7fc fa36 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  147078:	2800      	cmp	r0, #0
  14707a:	f000 80c4 	beq.w	147206 <dsa_generate_signature+0x1ae>
  14707e:	4606      	mov	r6, r0
    }

    mem_n_1 = ce_malloc(DSA_MAX_SIZE_P);
  147080:	f44f 70c0 	mov.w	r0, #384	; 0x180
        k_buff = mem_n->ptr;
  147084:	f8d6 a008 	ldr.w	r10, [r6, #8]
    mem_n_1 = ce_malloc(DSA_MAX_SIZE_P);
  147088:	f7fc fa2c 	bl	1434e4 <ce_malloc>

    if (mem_n_1 != NULL) {
  14708c:	4681      	mov	r9, r0
  14708e:	2800      	cmp	r0, #0
  147090:	f000 80cf 	beq.w	147232 <dsa_generate_signature+0x1da>
  147094:	2303      	movs	r3, #3
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    k_blk = block_t_convert(k_buff, q.len, EXT_MEM);
    /* FIPS 186-3 4.6: leftmost bits of hash if q.len is smaller then hash len */
    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  147096:	4658      	mov	r0, r11
  147098:	e9cd a80d 	strd	r10, r8, [r13, #52]	; 0x34
  14709c:	930f      	str	r3, [sp, #60]	; 0x3c
        hash_buff = mem_n_1->ptr;
  14709e:	f8d9 3008 	ldr.w	r3, [r9, #8]
  1470a2:	930a      	str	r3, [sp, #40]	; 0x28
    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  1470a4:	f7fc fc96 	bl	1439d4 <hash_get_digest_size>
  1470a8:	4540      	cmp	r0, r8
  1470aa:	bf88      	it	hi
  1470ac:	f8cd 8024 	strhi.w	r8, [r13, #36]	; 0x24
  1470b0:	f240 80ba 	bls.w	147228 <dsa_generate_signature+0x1d0>
    hash_block = block_t_convert(hash_buff, hash_len, EXT_MEM);

    size_adapt = p.len;
  1470b4:	9c21      	ldr	r4, [sp, #132]	; 0x84
  1470b6:	2303      	movs	r3, #3
  1470b8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  1470ba:	9210      	str	r2, [sp, #64]	; 0x40
        size_adapt += PK_CM_RAND_SIZE;
    }

#endif

    switch (size_adapt) {
  1470bc:	2c80      	cmp	r4, #128	; 0x80
  1470be:	9312      	str	r3, [sp, #72]	; 0x48
  1470c0:	f000 80a7 	beq.w	147212 <dsa_generate_signature+0x1ba>
  1470c4:	f5b4 7f80 	cmp.w	r4, #256	; 0x100
  1470c8:	f040 80a5 	bne.w	147216 <dsa_generate_signature+0x1be>
        case 128:
            rnd_len = 20;
            break;

        case 256:
            if (!memcmp(message.addr + (size_adapt  - 1), "\xf4", 1)) {
  1470cc:	9b2c      	ldr	r3, [sp, #176]	; 0xb0
  1470ce:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
                rnd_len = 28;
            }
            else {
                rnd_len = 32;
  1470d2:	2bf4      	cmp	r3, #244	; 0xf4
  1470d4:	bf0c      	ite	eq
  1470d6:	231c      	moveq	r3, #28
  1470d8:	2320      	movne	r3, #32
            return -1;
    }

#if !WITH_SIMULATION_PLATFORM //rng not work on paladium
    k_blk = block_t_convert(k_buff + (size_adapt - rnd_len), rnd_len, EXT_MEM);
    error = trng_get_rand_blk(vce_id, k_blk);
  1470da:	4638      	mov	r0, r7
    k_blk = block_t_convert(k_buff + (size_adapt - rnd_len), rnd_len, EXT_MEM);
  1470dc:	1ae2      	subs	r2, r4, r3
  1470de:	eb0a 0102 	add.w	r1, r10, r2
  1470e2:	920b      	str	r2, [sp, #44]	; 0x2c
  1470e4:	2203      	movs	r2, #3
  1470e6:	e9cd 130d 	strd	r1, r3, [r13, #52]	; 0x34
    error = trng_get_rand_blk(vce_id, k_blk);
  1470ea:	ab0d      	add	r3, sp, #52	; 0x34
    k_blk = block_t_convert(k_buff + (size_adapt - rnd_len), rnd_len, EXT_MEM);
  1470ec:	920f      	str	r2, [sp, #60]	; 0x3c
    error = trng_get_rand_blk(vce_id, k_blk);
  1470ee:	cb0e      	ldmia	r3, {r1, r2, r3}
  1470f0:	f7fe ff62 	bl	145fb8 <trng_get_rand_blk>

    if (error) {
  1470f4:	4605      	mov	r5, r0
  1470f6:	2800      	cmp	r0, #0
  1470f8:	d17f      	bne.n	1471fa <dsa_generate_signature+0x1a2>

    memcpy(k_buff + (size_adapt - rnd_len), rnd_const, rnd_len);
    /* workaround end!!!!! */
#endif

    error = hash_blk(hash_alg, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  1470fa:	9a09      	ldr	r2, [sp, #36]	; 0x24
  1470fc:	ab2c      	add	r3, sp, #176	; 0xb0
  1470fe:	9211      	str	r2, [sp, #68]	; 0x44
  147100:	aa10      	add	r2, sp, #64	; 0x40
  147102:	f10d 0c10 	add.w	r12, r13, #16
  147106:	ca07      	ldmia	r2, {r0, r1, r2}
  147108:	e88c 0007 	stmia.w	r12, {r0, r1, r2}
  14710c:	f10d 0c4c 	add.w	r12, r13, #76	; 0x4c
  147110:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  147114:	e9cd 5513 	strd	r5, r5, [r13, #76]	; 0x4c
  147118:	ab01      	add	r3, sp, #4
  14711a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14711e:	9500      	str	r5, [sp, #0]
  147120:	4658      	mov	r0, r11
    k_blk = block_t_convert(k_buff, q.len, EXT_MEM);
  147122:	e9cd a80d 	strd	r10, r8, [r13, #52]	; 0x34
    error = hash_blk(hash_alg, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  147126:	4639      	mov	r1, r7
  147128:	e89c 000c 	ldmia.w	r12, {r2, r3}
  14712c:	f7fc fc5c 	bl	1439e8 <hash_blk>

    if (error) {
  147130:	4680      	mov	r8, r0
  147132:	2800      	cmp	r0, #0
  147134:	f040 80a5 	bne.w	147282 <dsa_generate_signature+0x22a>
        ce_free(mem_n_1);
        LTRACEF("dsa_generate_signature hash_blk: %d\n", error);
        return CRYPTOLIB_CRYPTO_ERR;
    }

    if (hash_block.len < size_adapt) {
  147138:	9b09      	ldr	r3, [sp, #36]	; 0x24
  14713a:	42a3      	cmp	r3, r4
  14713c:	d37e      	bcc.n	14723c <dsa_generate_signature+0x1e4>
    // Fetch the results by PKE config 0x1 << BA414EP_MEMLOC_10 | 0x1 << BA414EP_MEMLOC_11
#if AUTO_OUTPUT_BY_CE
    pke_set_dst_param(vce_id, size_adapt * 2, 0x1 << BA414EP_MEMLOC_10 | 0x1 << BA414EP_MEMLOC_11, (_paddr((void*)signature.addr)), signature.addr_type);
#endif
    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_SIGN_GEN, size_adapt, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  14713e:	2500      	movs	r5, #0
    memset(k_buff, 0, size_adapt - rnd_len);
  147140:	4650      	mov	r0, r10
  147142:	4629      	mov	r1, r5

    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  147144:	f04f 0801 	mov.w	r8, #1
    memset(k_buff, 0, size_adapt - rnd_len);
  147148:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    mem2CryptoRAM_rev(vce_id, q, size_adapt, BA414EP_MEMLOC_2, true);
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
    mem2CryptoRAM_rev(vce_id, k_blk, size_adapt, BA414EP_MEMLOC_5, true);
    mem2CryptoRAM_rev(vce_id, priv, size_adapt, BA414EP_MEMLOC_6, true);
  14714a:	f04f 0a06 	mov.w	r10, #6
    memset(k_buff, 0, size_adapt - rnd_len);
  14714e:	f00b ef96 	blx	15307c <memset>
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_SIGN_GEN, size_adapt, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  147152:	462b      	mov	r3, r5
  147154:	9500      	str	r5, [sp, #0]
  147156:	4622      	mov	r2, r4
  147158:	2119      	movs	r1, #25
  14715a:	4638      	mov	r0, r7
  14715c:	f7fd f80a 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  147160:	e9cd 4500 	strd	r4, r5, [r13]
  147164:	f8cd 8008 	str.w	r8, [r13, #8]
  147168:	ab20      	add	r3, sp, #128	; 0x80
  14716a:	4638      	mov	r0, r7
    mem2CryptoRAM_rev(vce_id, q, size_adapt, BA414EP_MEMLOC_2, true);
  14716c:	2502      	movs	r5, #2
    mem2CryptoRAM_rev(vce_id, p, size_adapt, BA414EP_MEMLOC_0, true);
  14716e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147170:	f7fd feb8 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, q, size_adapt, BA414EP_MEMLOC_2, true);
  147174:	f8cd 8008 	str.w	r8, [r13, #8]
  147178:	ab23      	add	r3, sp, #140	; 0x8c
  14717a:	9400      	str	r4, [sp, #0]
  14717c:	4638      	mov	r0, r7
  14717e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147180:	9501      	str	r5, [sp, #4]
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
  147182:	2503      	movs	r5, #3
    mem2CryptoRAM_rev(vce_id, q, size_adapt, BA414EP_MEMLOC_2, true);
  147184:	f7fd feae 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
  147188:	f8cd 8008 	str.w	r8, [r13, #8]
  14718c:	9400      	str	r4, [sp, #0]
  14718e:	ab26      	add	r3, sp, #152	; 0x98
  147190:	4638      	mov	r0, r7
  147192:	cb0e      	ldmia	r3, {r1, r2, r3}
  147194:	9501      	str	r5, [sp, #4]
    mem2CryptoRAM_rev(vce_id, hash_block, size_adapt, BA414EP_MEMLOC_12, true);
  147196:	250c      	movs	r5, #12
    mem2CryptoRAM_rev(vce_id, generator, size_adapt, BA414EP_MEMLOC_3, true);
  147198:	f7fd fea4 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, k_blk, size_adapt, BA414EP_MEMLOC_5, true);
  14719c:	2305      	movs	r3, #5
  14719e:	f8cd 8008 	str.w	r8, [r13, #8]
  1471a2:	4638      	mov	r0, r7
  1471a4:	e9cd 4300 	strd	r4, r3, [r13]
  1471a8:	ab0d      	add	r3, sp, #52	; 0x34
  1471aa:	cb0e      	ldmia	r3, {r1, r2, r3}
  1471ac:	f7fd fe9a 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, priv, size_adapt, BA414EP_MEMLOC_6, true);
  1471b0:	f8cd 8008 	str.w	r8, [r13, #8]
  1471b4:	ab29      	add	r3, sp, #164	; 0xa4
  1471b6:	9400      	str	r4, [sp, #0]
  1471b8:	4638      	mov	r0, r7
  1471ba:	cb0e      	ldmia	r3, {r1, r2, r3}
  1471bc:	f8cd a004 	str.w	r10, [r13, #4]
  1471c0:	f7fd fe90 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, hash_block, size_adapt, BA414EP_MEMLOC_12, true);
  1471c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
  1471c6:	9311      	str	r3, [sp, #68]	; 0x44
  1471c8:	ab10      	add	r3, sp, #64	; 0x40
  1471ca:	f8cd 8008 	str.w	r8, [r13, #8]
  1471ce:	4638      	mov	r0, r7
  1471d0:	9400      	str	r4, [sp, #0]
  1471d2:	cb0e      	ldmia	r3, {r1, r2, r3}
  1471d4:	9501      	str	r5, [sp, #4]
  1471d6:	f7fd fe85 	bl	144ee4 <mem2CryptoRAM_rev>

    error = pke_start_wait_status(vce_id);
  1471da:	4638      	mov	r0, r7
  1471dc:	f7fc ffe6 	bl	1441ac <pke_start_wait_status>

    if (error) {
  1471e0:	4605      	mov	r5, r0
  1471e2:	2800      	cmp	r0, #0
  1471e4:	d139      	bne.n	14725a <dsa_generate_signature+0x202>
    }

    // Result signature
#if AUTO_OUTPUT_BY_CE
#else
    CryptoRAM2point_rev(vce_id, signature, size_adapt, BA414EP_MEMLOC_10);
  1471e6:	f04f 0c0a 	mov.w	r12, #10
  1471ea:	ab2f      	add	r3, sp, #188	; 0xbc
  1471ec:	9400      	str	r4, [sp, #0]
  1471ee:	4638      	mov	r0, r7
  1471f0:	cb0e      	ldmia	r3, {r1, r2, r3}
  1471f2:	f8cd c004 	str.w	r12, [r13, #4]
  1471f6:	f7fd ff3b 	bl	145070 <CryptoRAM2point_rev>
#endif

    ce_free(mem_n);
  1471fa:	4630      	mov	r0, r6
  1471fc:	f7fc f9b6 	bl	14356c <ce_free>
    ce_free(mem_n_1);
  147200:	4648      	mov	r0, r9
  147202:	f7fc f9b3 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  147206:	4628      	mov	r0, r5
  147208:	b017      	add	sp, #92	; 0x5c
  14720a:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14720e:	b002      	add	sp, #8
  147210:	4770      	bx	r14
            rnd_len = 20;
  147212:	2314      	movs	r3, #20
  147214:	e761      	b.n	1470da <dsa_generate_signature+0x82>
            ce_free(mem_n);
  147216:	4630      	mov	r0, r6
            return -1;
  147218:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
            ce_free(mem_n);
  14721c:	f7fc f9a6 	bl	14356c <ce_free>
            ce_free(mem_n_1);
  147220:	4648      	mov	r0, r9
  147222:	f7fc f9a3 	bl	14356c <ce_free>
            return -1;
  147226:	e7ee      	b.n	147206 <dsa_generate_signature+0x1ae>
    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  147228:	4658      	mov	r0, r11
  14722a:	f7fc fbd3 	bl	1439d4 <hash_get_digest_size>
  14722e:	9009      	str	r0, [sp, #36]	; 0x24
  147230:	e740      	b.n	1470b4 <dsa_generate_signature+0x5c>
        ce_free(mem_n);
  147232:	4630      	mov	r0, r6
        return CRYPTOLIB_PK_N_NOTVALID;
  147234:	2515      	movs	r5, #21
        ce_free(mem_n);
  147236:	f7fc f999 	bl	14356c <ce_free>
        return CRYPTOLIB_PK_N_NOTVALID;
  14723a:	e7e4      	b.n	147206 <dsa_generate_signature+0x1ae>
        memcpy(hash_buff + (size_adapt - hash_block.len), hash_buff, hash_block.len);
  14723c:	461a      	mov	r2, r3
  14723e:	1ae5      	subs	r5, r4, r3
  147240:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  147242:	469b      	mov	r11, r3
  147244:	4619      	mov	r1, r3
        memset(hash_buff, 0, size_adapt - hash_block.len);
  147246:	9409      	str	r4, [sp, #36]	; 0x24
        memcpy(hash_buff + (size_adapt - hash_block.len), hash_buff, hash_block.len);
  147248:	1958      	adds	r0, r3, r5
  14724a:	f00b ee92 	blx	152f70 <memcpy>
        memset(hash_buff, 0, size_adapt - hash_block.len);
  14724e:	462a      	mov	r2, r5
  147250:	4641      	mov	r1, r8
  147252:	4658      	mov	r0, r11
  147254:	f00b ef12 	blx	15307c <memset>
  147258:	e771      	b.n	14713e <dsa_generate_signature+0xe6>
        ce_free(mem_n);
  14725a:	4630      	mov	r0, r6
  14725c:	f7fc f986 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  147260:	4648      	mov	r0, r9
  147262:	f7fc f983 	bl	14356c <ce_free>
        LTRACEF("dsa_generate_signature pke_start_wait_status: %d\n", error);
  147266:	f245 71b8 	movw	r1, #22456	; 0x57b8
  14726a:	f645 0058 	movw	r0, #22616	; 0x5858
  14726e:	462b      	mov	r3, r5
  147270:	22ee      	movs	r2, #238	; 0xee
  147272:	f2c0 0115 	movt	r1, #21
        return CRYPTOLIB_CRYPTO_ERR;
  147276:	4655      	mov	r5, r10
        LTRACEF("dsa_generate_signature pke_start_wait_status: %d\n", error);
  147278:	f2c0 0015 	movt	r0, #21
  14727c:	f00c ff3c 	bl	1540f8 <_printf>
        return CRYPTOLIB_CRYPTO_ERR;
  147280:	e7c1      	b.n	147206 <dsa_generate_signature+0x1ae>
        ce_free(mem_n);
  147282:	4630      	mov	r0, r6
        return CRYPTOLIB_CRYPTO_ERR;
  147284:	2506      	movs	r5, #6
        ce_free(mem_n);
  147286:	f7fc f971 	bl	14356c <ce_free>
        ce_free(mem_n_1);
  14728a:	4648      	mov	r0, r9
  14728c:	f7fc f96e 	bl	14356c <ce_free>
        LTRACEF("dsa_generate_signature hash_blk: %d\n", error);
  147290:	f245 71b8 	movw	r1, #22456	; 0x57b8
  147294:	f645 002c 	movw	r0, #22572	; 0x582c
  147298:	4643      	mov	r3, r8
  14729a:	22cf      	movs	r2, #207	; 0xcf
  14729c:	f2c0 0115 	movt	r1, #21
  1472a0:	f2c0 0015 	movt	r0, #21
  1472a4:	f00c ff28 	bl	1540f8 <_printf>
        return CRYPTOLIB_CRYPTO_ERR;
  1472a8:	e7ad      	b.n	147206 <dsa_generate_signature+0x1ae>
  1472aa:	bf00      	nop

001472ac <dsa_verify_signature>:
    block_t q,
    block_t generator,
    block_t pub,
    block_t message,
    block_t signature)
{
  1472ac:	b082      	sub	sp, #8
  1472ae:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1472b2:	468a      	mov	r10, r1
  1472b4:	b08f      	sub	sp, #60	; 0x3c
  1472b6:	4604      	mov	r4, r0
  1472b8:	a918      	add	r1, sp, #96	; 0x60
    /* FIPS 186-3 4.7: leftmost bits of hash if q.len is smaller then hash len */
    uint32_t hash_len;
    block_t hash_block;
    uint32_t size;

    mem_n = ce_malloc(DSA_MAX_SIZE_P);
  1472ba:	f44f 70c0 	mov.w	r0, #384	; 0x180
{
  1472be:	e881 000c 	stmia.w	r1, {r2, r3}
  1472c2:	9f1c      	ldr	r7, [sp, #112]	; 0x70
    mem_n = ce_malloc(DSA_MAX_SIZE_P);
  1472c4:	f7fc f90e 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
  1472c8:	2800      	cmp	r0, #0
  1472ca:	f000 8091 	beq.w	1473f0 <dsa_verify_signature+0x144>
  1472ce:	4681      	mov	r9, r0
    }
    else {
        return CRYPTOLIB_PK_N_NOTVALID;
    }

    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  1472d0:	4650      	mov	r0, r10
        hash_buff = mem_n->ptr;
  1472d2:	f8d9 8008 	ldr.w	r8, [r9, #8]
    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  1472d6:	f7fc fb7d 	bl	1439d4 <hash_get_digest_size>
  1472da:	42b8      	cmp	r0, r7
  1472dc:	f240 8083 	bls.w	1473e6 <dsa_verify_signature+0x13a>
  1472e0:	2203      	movs	r2, #3
    hash_block = block_t_convert(hash_buff, hash_len, EXT_MEM);

    size = p.len;

    error = hash_blk(hash_alg, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  1472e2:	ae08      	add	r6, sp, #32
  1472e4:	f8cd 8020 	str.w	r8, [r13, #32]
  1472e8:	ab24      	add	r3, sp, #144	; 0x90
  1472ea:	e9cd 7209 	strd	r7, r2, [r13, #36]	; 0x24
  1472ee:	ad04      	add	r5, sp, #16
  1472f0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  1472f4:	f10d 0c2c 	add.w	r12, r13, #44	; 0x2c
  1472f8:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1472fc:	ad01      	add	r5, sp, #4
  1472fe:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  147302:	2300      	movs	r3, #0
  147304:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  147308:	930b      	str	r3, [sp, #44]	; 0x2c
  14730a:	4650      	mov	r0, r10
  14730c:	930c      	str	r3, [sp, #48]	; 0x30
  14730e:	4621      	mov	r1, r4
  147310:	9300      	str	r3, [sp, #0]
  147312:	e89c 000c 	ldmia.w	r12, {r2, r3}
    size = p.len;
  147316:	9d19      	ldr	r5, [sp, #100]	; 0x64
    error = hash_blk(hash_alg, vce_id, block_t_convert(NULL, 0, 0), message, hash_block);
  147318:	f7fc fb66 	bl	1439e8 <hash_blk>

    if (error) {
  14731c:	4682      	mov	r10, r0
  14731e:	2800      	cmp	r0, #0
  147320:	d17f      	bne.n	147422 <dsa_verify_signature+0x176>
        ce_free(mem_n);
        return CRYPTOLIB_CRYPTO_ERR;
    }

    if (hash_block.len < size) {
  147322:	42af      	cmp	r7, r5
  147324:	d366      	bcc.n	1473f4 <dsa_verify_signature+0x148>
        memset(hash_buff, 0, size - hash_block.len);
        hash_block.len = size;
    }

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_SIGN_VERIF, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  147326:	f04f 0b00 	mov.w	r11, #0
  14732a:	4620      	mov	r0, r4
  14732c:	465b      	mov	r3, r11
  14732e:	462a      	mov	r2, r5
  147330:	211a      	movs	r1, #26

    mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_0, true);
  147332:	f04f 0801 	mov.w	r8, #1
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_SIGN_VERIF, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  147336:	f8cd b000 	str.w	r11, [r13]
    mem2CryptoRAM_rev(vce_id, q, size, BA414EP_MEMLOC_2, true);
    mem2CryptoRAM_rev(vce_id, generator, size, BA414EP_MEMLOC_3, true);
  14733a:	f04f 0a03 	mov.w	r10, #3
    pke_set_command(vce_id, BA414EP_OPTYPE_DSA_SIGN_VERIF, size, BA414EP_LITTLEEND, BA414EP_SELCUR_NO_ACCELERATOR);
  14733e:	f7fc ff19 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, p, size, BA414EP_MEMLOC_0, true);
  147342:	e9cd 5b00 	strd	r5, r11, [r13]
  147346:	4620      	mov	r0, r4
  147348:	ab18      	add	r3, sp, #96	; 0x60
  14734a:	f8cd 8008 	str.w	r8, [r13, #8]
  14734e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147350:	f7fd fdc8 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, q, size, BA414EP_MEMLOC_2, true);
  147354:	f04f 0c02 	mov.w	r12, #2
  147358:	ab1b      	add	r3, sp, #108	; 0x6c
  14735a:	f8cd 8008 	str.w	r8, [r13, #8]
  14735e:	4620      	mov	r0, r4
  147360:	9500      	str	r5, [sp, #0]
  147362:	cb0e      	ldmia	r3, {r1, r2, r3}
  147364:	f8cd c004 	str.w	r12, [r13, #4]
  147368:	f7fd fdbc 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, generator, size, BA414EP_MEMLOC_3, true);
  14736c:	f8cd 8008 	str.w	r8, [r13, #8]
  147370:	4620      	mov	r0, r4
  147372:	ab1e      	add	r3, sp, #120	; 0x78
  147374:	9500      	str	r5, [sp, #0]
  147376:	cb0e      	ldmia	r3, {r1, r2, r3}
  147378:	f8cd a004 	str.w	r10, [r13, #4]
  14737c:	f7fd fdb2 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, pub, size, BA414EP_MEMLOC_8, true);
  147380:	f04f 0c08 	mov.w	r12, #8
  147384:	4620      	mov	r0, r4
  147386:	ab21      	add	r3, sp, #132	; 0x84
  147388:	f8cd 8008 	str.w	r8, [r13, #8]
  14738c:	9500      	str	r5, [sp, #0]
  14738e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147390:	f8cd c004 	str.w	r12, [r13, #4]
  147394:	f7fd fda6 	bl	144ee4 <mem2CryptoRAM_rev>

    point2CryptoRAM_rev(vce_id, signature, size, BA414EP_MEMLOC_10);
  147398:	f04f 0c0a 	mov.w	r12, #10
  14739c:	4620      	mov	r0, r4
  14739e:	ab27      	add	r3, sp, #156	; 0x9c
  1473a0:	9500      	str	r5, [sp, #0]
  1473a2:	cb0e      	ldmia	r3, {r1, r2, r3}
  1473a4:	f8cd c004 	str.w	r12, [r13, #4]
  1473a8:	f7fd fdec 	bl	144f84 <point2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, hash_block, size, BA414EP_MEMLOC_12, true);
  1473ac:	f04f 0c0c 	mov.w	r12, #12
  1473b0:	f8cd 8008 	str.w	r8, [r13, #8]
  1473b4:	4620      	mov	r0, r4
  1473b6:	9709      	str	r7, [sp, #36]	; 0x24
  1473b8:	9500      	str	r5, [sp, #0]
  1473ba:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
  1473be:	f8cd c004 	str.w	r12, [r13, #4]
  1473c2:	f7fd fd8f 	bl	144ee4 <mem2CryptoRAM_rev>

    error = pke_start_wait_status(vce_id);
  1473c6:	4620      	mov	r0, r4
  1473c8:	f7fc fef0 	bl	1441ac <pke_start_wait_status>
  1473cc:	4604      	mov	r4, r0

    if (error & CE_PK_SIGNATURE_NOTVALID_MASK) {
        ce_free(mem_n);
  1473ce:	4648      	mov	r0, r9
    if (error & CE_PK_SIGNATURE_NOTVALID_MASK) {
  1473d0:	05a3      	lsls	r3, r4, #22
  1473d2:	d41e      	bmi.n	147412 <dsa_verify_signature+0x166>
        return CRYPTOLIB_INVALID_SIGN_ERR;
    }
    else if (error) {
  1473d4:	bb0c      	cbnz	r4, 14741a <dsa_verify_signature+0x16e>
        ce_free(mem_n);
        return CRYPTOLIB_CRYPTO_ERR;
    }

    ce_free(mem_n);
  1473d6:	f7fc f8c9 	bl	14356c <ce_free>
    return CRYPTOLIB_SUCCESS;
}
  1473da:	4620      	mov	r0, r4
  1473dc:	b00f      	add	sp, #60	; 0x3c
  1473de:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1473e2:	b002      	add	sp, #8
  1473e4:	4770      	bx	r14
    hash_len = q.len < hash_get_digest_size(hash_alg) ? q.len : hash_get_digest_size(hash_alg);
  1473e6:	4650      	mov	r0, r10
  1473e8:	f7fc faf4 	bl	1439d4 <hash_get_digest_size>
  1473ec:	4607      	mov	r7, r0
  1473ee:	e777      	b.n	1472e0 <dsa_verify_signature+0x34>
        return CRYPTOLIB_PK_N_NOTVALID;
  1473f0:	2415      	movs	r4, #21
  1473f2:	e7f2      	b.n	1473da <dsa_verify_signature+0x12e>
        memcpy(hash_buff + (size - hash_block.len), hash_buff, hash_block.len);
  1473f4:	463a      	mov	r2, r7
  1473f6:	eba5 0b07 	sub.w	r11, r5, r7
  1473fa:	4641      	mov	r1, r8
  1473fc:	eb08 000b 	add.w	r0, r8, r11
  147400:	f00b edb6 	blx	152f70 <memcpy>
        memset(hash_buff, 0, size - hash_block.len);
  147404:	465a      	mov	r2, r11
  147406:	4651      	mov	r1, r10
  147408:	4640      	mov	r0, r8
  14740a:	462f      	mov	r7, r5
  14740c:	f00b ee36 	blx	15307c <memset>
  147410:	e789      	b.n	147326 <dsa_verify_signature+0x7a>
        return CRYPTOLIB_INVALID_SIGN_ERR;
  147412:	4654      	mov	r4, r10
        ce_free(mem_n);
  147414:	f7fc f8aa 	bl	14356c <ce_free>
        return CRYPTOLIB_INVALID_SIGN_ERR;
  147418:	e7df      	b.n	1473da <dsa_verify_signature+0x12e>
        return CRYPTOLIB_CRYPTO_ERR;
  14741a:	2406      	movs	r4, #6
        ce_free(mem_n);
  14741c:	f7fc f8a6 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;
  147420:	e7db      	b.n	1473da <dsa_verify_signature+0x12e>
        ce_free(mem_n);
  147422:	4648      	mov	r0, r9
        return CRYPTOLIB_CRYPTO_ERR;
  147424:	2406      	movs	r4, #6
        ce_free(mem_n);
  147426:	f7fc f8a1 	bl	14356c <ce_free>
        return CRYPTOLIB_CRYPTO_ERR;
  14742a:	e7d6      	b.n	1473da <dsa_verify_signature+0x12e>

0014742c <modular_reduce>:
uint32_t modular_reduce(uint32_t vce_id,
                        uint32_t op,
                        block_t ptrb,
                        block_t ptrn,
                        block_t ptrc)
{
  14742c:	b082      	sub	sp, #8
  14742e:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    //Set pointer register
    pke_set_config(vce_id, 0, 1, 2, 3);
  147432:	2703      	movs	r7, #3
{
  147434:	b084      	sub	sp, #16
  147436:	4688      	mov	r8, r1
  147438:	a90a      	add	r1, sp, #40	; 0x28
  14743a:	4604      	mov	r4, r0

    // Set command to enable byte-swap
    pke_set_command(vce_id, op, ptrb.len, BA414EP_LITTLEEND, 0);

    /* Load verification parameters */
    mem2CryptoRAM_rev(vce_id, ptrb, ptrb.len, BA414EP_MEMLOC_1, true);
  14743c:	2501      	movs	r5, #1
{
  14743e:	e881 000c 	stmia.w	r1, {r2, r3}
    pke_set_config(vce_id, 0, 1, 2, 3);
  147442:	2100      	movs	r1, #0
  147444:	2302      	movs	r3, #2
  147446:	2201      	movs	r2, #1
  147448:	9700      	str	r7, [sp, #0]
  14744a:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
  14744c:	f7fc fe76 	bl	14413c <pke_set_config>
    pke_set_command(vce_id, op, ptrb.len, BA414EP_LITTLEEND, 0);
  147450:	f04f 0c00 	mov.w	r12, #0
  147454:	4632      	mov	r2, r6
  147456:	4663      	mov	r3, r12
  147458:	4641      	mov	r1, r8
  14745a:	f8cd c000 	str.w	r12, [r13]
  14745e:	4620      	mov	r0, r4
  147460:	f7fc fe88 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, ptrb, ptrb.len, BA414EP_MEMLOC_1, true);
  147464:	9600      	str	r6, [sp, #0]
  147466:	e9cd 5501 	strd	r5, r5, [r13, #4]
  14746a:	ab0a      	add	r3, sp, #40	; 0x28
  14746c:	4620      	mov	r0, r4
  14746e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147470:	f7fd fd38 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, ptrn, ptrn.len, BA414EP_MEMLOC_3, true);
  147474:	9e0e      	ldr	r6, [sp, #56]	; 0x38
  147476:	ab0d      	add	r3, sp, #52	; 0x34
  147478:	e9cd 7501 	strd	r7, r5, [r13, #4]
  14747c:	4620      	mov	r0, r4
  14747e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147480:	9600      	str	r6, [sp, #0]
  147482:	f7fd fd2f 	bl	144ee4 <mem2CryptoRAM_rev>

    uint32_t status = pke_start_wait_status(vce_id);
  147486:	4620      	mov	r0, r4
  147488:	f7fc fe90 	bl	1441ac <pke_start_wait_status>

    if (status) {
  14748c:	4606      	mov	r6, r0
  14748e:	b948      	cbnz	r0, 1474a4 <modular_reduce+0x78>
        return status;
    }

    CryptoRAM2mem_rev(vce_id, ptrc, ptrc.len, BA414EP_MEMLOC_2, true);
  147490:	2702      	movs	r7, #2
  147492:	ab10      	add	r3, sp, #64	; 0x40
  147494:	9502      	str	r5, [sp, #8]
  147496:	4620      	mov	r0, r4
  147498:	9c11      	ldr	r4, [sp, #68]	; 0x44
  14749a:	cb0e      	ldmia	r3, {r1, r2, r3}
  14749c:	e9cd 4700 	strd	r4, r7, [r13]
  1474a0:	f7fd fda4 	bl	144fec <CryptoRAM2mem_rev>

    return status;
}
  1474a4:	4630      	mov	r0, r6
  1474a6:	b004      	add	sp, #16
  1474a8:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
  1474ac:	b002      	add	sp, #8
  1474ae:	4770      	bx	r14

001474b0 <modular_reduce_odd>:
/* C= B mod N */
uint32_t modular_reduce_odd(uint32_t vce_id,
                            block_t ptrb,
                            block_t ptrn,
                            block_t ptrc)
{
  1474b0:	b5f0      	push	{r4, r5, r6, r7, r14}
  1474b2:	4607      	mov	r7, r0
  1474b4:	b08d      	sub	sp, #52	; 0x34
    return modular_reduce(vce_id, BA414EP_OPTYPE_MOD_RED_ODD, ptrb, ptrn, ptrc);
  1474b6:	ae15      	add	r6, sp, #84	; 0x54
{
  1474b8:	ac09      	add	r4, sp, #36	; 0x24
    return modular_reduce(vce_id, BA414EP_OPTYPE_MOD_RED_ODD, ptrb, ptrn, ptrc);
  1474ba:	ad04      	add	r5, sp, #16
{
  1474bc:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return modular_reduce(vce_id, BA414EP_OPTYPE_MOD_RED_ODD, ptrb, ptrn, ptrc);
  1474c0:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  1474c4:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  1474c8:	aa12      	add	r2, sp, #72	; 0x48
  1474ca:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  1474cc:	ab01      	add	r3, sp, #4
  1474ce:	ca07      	ldmia	r2, {r0, r1, r2}
  1474d0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  1474d4:	9500      	str	r5, [sp, #0]
  1474d6:	4638      	mov	r0, r7
  1474d8:	e894 000c 	ldmia.w	r4, {r2, r3}
  1474dc:	2104      	movs	r1, #4
  1474de:	f7ff ffa5 	bl	14742c <modular_reduce>
}
  1474e2:	b00d      	add	sp, #52	; 0x34
  1474e4:	bdf0      	pop	{r4, r5, r6, r7, r15}
  1474e6:	bf00      	nop

001474e8 <modular_inverse_odd>:
/* C= 1 / B mod N */
uint32_t modular_inverse_odd(uint32_t vce_id,
                             block_t ptrb,
                             block_t ptrn,
                             block_t ptrc)
{
  1474e8:	b5f0      	push	{r4, r5, r6, r7, r14}
  1474ea:	4607      	mov	r7, r0
  1474ec:	b08d      	sub	sp, #52	; 0x34
    return modular_inverse(vce_id, BA414EP_OPTYPE_MOD_INV_ODD, ptrb, ptrn, ptrc);
  1474ee:	ae15      	add	r6, sp, #84	; 0x54
{
  1474f0:	ac09      	add	r4, sp, #36	; 0x24
    return modular_inverse(vce_id, BA414EP_OPTYPE_MOD_INV_ODD, ptrb, ptrn, ptrc);
  1474f2:	ad04      	add	r5, sp, #16
{
  1474f4:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    return modular_inverse(vce_id, BA414EP_OPTYPE_MOD_INV_ODD, ptrb, ptrn, ptrc);
  1474f8:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
  1474fc:	e885 0007 	stmia.w	r5, {r0, r1, r2}
  147500:	aa12      	add	r2, sp, #72	; 0x48
  147502:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
  147504:	ab01      	add	r3, sp, #4
  147506:	ca07      	ldmia	r2, {r0, r1, r2}
  147508:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14750c:	9500      	str	r5, [sp, #0]
  14750e:	4638      	mov	r0, r7
  147510:	e894 000c 	ldmia.w	r4, {r2, r3}
  147514:	2106      	movs	r1, #6
  147516:	f7ff ff89 	bl	14742c <modular_reduce>
}
  14751a:	b00d      	add	sp, #52	; 0x34
  14751c:	bdf0      	pop	{r4, r5, r6, r7, r15}
  14751e:	bf00      	nop

00147520 <multiplicate>:
/* C= A * B */
uint32_t multiplicate(uint32_t vce_id,
                      block_t ptra,
                      block_t ptrb,
                      block_t ptrc)
{
  147520:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    //Set pointer register
    pke_set_config(vce_id, 0, 1, 2, 3);
  147524:	2503      	movs	r5, #3
{
  147526:	b088      	sub	sp, #32

    // Set command to enable byte-swap
    pke_set_command(vce_id, BA414EP_OPTYPE_MULT, ptra.len, BA414EP_LITTLEEND, 0);
  147528:	2700      	movs	r7, #0
{
  14752a:	ac05      	add	r4, sp, #20
  14752c:	e884 000e 	stmia.w	r4, {r1, r2, r3}
    pke_set_config(vce_id, 0, 1, 2, 3);
  147530:	2201      	movs	r2, #1
  147532:	2302      	movs	r3, #2

    /* Load verification parameters */
    mem2CryptoRAM_rev(vce_id, ptra, ptra.len, BA414EP_MEMLOC_0, true);
  147534:	4616      	mov	r6, r2
    pke_set_config(vce_id, 0, 1, 2, 3);
  147536:	4639      	mov	r1, r7
  147538:	f8dd 8018 	ldr.w	r8, [r13, #24]
  14753c:	9500      	str	r5, [sp, #0]
{
  14753e:	4605      	mov	r5, r0
    pke_set_config(vce_id, 0, 1, 2, 3);
  147540:	f7fc fdfc 	bl	14413c <pke_set_config>
    pke_set_command(vce_id, BA414EP_OPTYPE_MULT, ptra.len, BA414EP_LITTLEEND, 0);
  147544:	4642      	mov	r2, r8
  147546:	4628      	mov	r0, r5
  147548:	463b      	mov	r3, r7
  14754a:	9700      	str	r7, [sp, #0]
  14754c:	2108      	movs	r1, #8
  14754e:	f7fc fe11 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, ptra, ptra.len, BA414EP_MEMLOC_0, true);
  147552:	e9cd 8700 	strd	r8, r7, [r13]
  147556:	4628      	mov	r0, r5
  147558:	e894 000e 	ldmia.w	r4, {r1, r2, r3}
  14755c:	9602      	str	r6, [sp, #8]
  14755e:	f7fd fcc1 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, ptrb, ptrb.len, BA414EP_MEMLOC_1, true);
  147562:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
  147564:	e9cd 3600 	strd	r3, r6, [r13]
  147568:	ab0e      	add	r3, sp, #56	; 0x38
  14756a:	9602      	str	r6, [sp, #8]
  14756c:	4628      	mov	r0, r5
  14756e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147570:	f7fd fcb8 	bl	144ee4 <mem2CryptoRAM_rev>

    uint32_t status = pke_start_wait_status(vce_id);
  147574:	4628      	mov	r0, r5
  147576:	f7fc fe19 	bl	1441ac <pke_start_wait_status>

    if (status) {
  14757a:	4604      	mov	r4, r0
  14757c:	b948      	cbnz	r0, 147592 <multiplicate+0x72>
        return status;
    }

    CryptoRAM2mem_rev(vce_id, ptrc, ptrc.len, BA414EP_MEMLOC_2, true);
  14757e:	2702      	movs	r7, #2
  147580:	ab11      	add	r3, sp, #68	; 0x44
  147582:	9602      	str	r6, [sp, #8]
  147584:	4628      	mov	r0, r5
  147586:	9d12      	ldr	r5, [sp, #72]	; 0x48
  147588:	cb0e      	ldmia	r3, {r1, r2, r3}
  14758a:	e9cd 5700 	strd	r5, r7, [r13]
  14758e:	f7fd fd2d 	bl	144fec <CryptoRAM2mem_rev>

    return status;
}
  147592:	4620      	mov	r0, r4
  147594:	b008      	add	sp, #32
  147596:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  14759a:	bf00      	nop

0014759c <math_array_incr>:
void math_array_incr(uint8_t* a, const size_t length, int8_t value)
{
    int32_t carry = value;

    /* The LSB are at the end of the array so start there. */
    for (int i = length - 1; i >= 0; i--) {
  14759c:	1e4b      	subs	r3, r1, #1
  14759e:	d409      	bmi.n	1475b4 <math_array_incr+0x18>
  1475a0:	4408      	add	r0, r1
  1475a2:	3b01      	subs	r3, #1
        int32_t byte = a[i];
  1475a4:	f810 1d01 	ldrb.w	r1, [r0, #-1]!
        int32_t sum = byte + carry;
  1475a8:	440a      	add	r2, r1
    for (int i = length - 1; i >= 0; i--) {
  1475aa:	1c59      	adds	r1, r3, #1
        a[i] = (uint8_t)(sum & 0xFF);
  1475ac:	7002      	strb	r2, [r0, #0]
        carry = sum >> 8;
  1475ae:	ea4f 2222 	mov.w	r2, r2, asr #8
    for (int i = length - 1; i >= 0; i--) {
  1475b2:	d1f6      	bne.n	1475a2 <math_array_incr+0x6>
    }
}
  1475b4:	4770      	bx	r14
  1475b6:	bf00      	nop

001475b8 <prime_verify>:

uint32_t prime_verify(uint32_t vce_id,
                      block_t candi_prime,
                      uint32_t iteration,
                      bool* is_prime)
{
  1475b8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1475bc:	b093      	sub	sp, #76	; 0x4c
  1475be:	ac05      	add	r4, sp, #20
  1475c0:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  1475c4:	9d06      	ldr	r5, [sp, #24]
    uint8_t* rand;// working buffer for intermediate steps
    struct mem_node* mem_n;

    if (candi_prime.len > PRIME_MAX_SIZE || candi_prime.len == 0) {
  1475c6:	1e6b      	subs	r3, r5, #1
  1475c8:	2bff      	cmp	r3, #255	; 0xff
        LTRACEF("%s, %d, status: 0x%x\n", __func__, __LINE__, CRYPTOLIB_INVALID_PARAM);
        return CRYPTOLIB_INVALID_PARAM;
  1475ca:	bf88      	it	hi
  1475cc:	2409      	movhi	r4, #9
    if (candi_prime.len > PRIME_MAX_SIZE || candi_prime.len == 0) {
  1475ce:	d872      	bhi.n	1476b6 <prime_verify+0xfe>
  1475d0:	4680      	mov	r8, r0
    }

    uint32_t length = candi_prime.len;

    mem_n = ce_malloc(PRIME_MAX_SIZE);
  1475d2:	f44f 7080 	mov.w	r0, #256	; 0x100
  1475d6:	4689      	mov	r9, r1
  1475d8:	f7fb ff84 	bl	1434e4 <ce_malloc>

    if (mem_n != NULL) {
        rand = mem_n->ptr;
    } else {
        return CRYPTOLIB_PK_N_NOTVALID;
  1475dc:	2415      	movs	r4, #21
    if (mem_n != NULL) {
  1475de:	9004      	str	r0, [sp, #16]
  1475e0:	2800      	cmp	r0, #0
  1475e2:	d068      	beq.n	1476b6 <prime_verify+0xfe>
    }

    for (uint32_t i = 0; i < iteration; i++) {
  1475e4:	9b1c      	ldr	r3, [sp, #112]	; 0x70
        rand = mem_n->ptr;
  1475e6:	f8d0 a008 	ldr.w	r10, [r0, #8]
    for (uint32_t i = 0; i < iteration; i++) {
  1475ea:	2b00      	cmp	r3, #0
  1475ec:	d067      	beq.n	1476be <prime_verify+0x106>
  1475ee:	f04f 0b00 	mov.w	r11, #0
  1475f2:	e006      	b.n	147602 <prime_verify+0x4a>
    *is_prime = (status != CRYPTOLIB_PK_COMPOSITE);
  1475f4:	991d      	ldr	r1, [sp, #116]	; 0x74
            ce_free(mem_n);
            return status;
        }

        /* Return if the prime candidate is composite */
        if (*is_prime == false) {
  1475f6:	2810      	cmp	r0, #16
    *is_prime = (status != CRYPTOLIB_PK_COMPOSITE);
  1475f8:	700b      	strb	r3, [r1, #0]
        if (*is_prime == false) {
  1475fa:	d060      	beq.n	1476be <prime_verify+0x106>
    for (uint32_t i = 0; i < iteration; i++) {
  1475fc:	9b1c      	ldr	r3, [sp, #112]	; 0x70
  1475fe:	455b      	cmp	r3, r11
  147600:	d05d      	beq.n	1476be <prime_verify+0x106>
        math_array_incr((uint8_t*)(candi_prime.addr), length, -2);
  147602:	4629      	mov	r1, r5
  147604:	f06f 0201 	mvn.w	r2, #1
  147608:	4648      	mov	r0, r9
  14760a:	af0f      	add	r7, sp, #60	; 0x3c
  14760c:	f7ff ffc6 	bl	14759c <math_array_incr>
        uint32_t status = rng_get_rand_less_ref(vce_id, // 0 < rand < number-2
  147610:	e9cd 9505 	strd	r9, r5, [r13, #20]
  147614:	f8cd a024 	str.w	r10, [r13, #36]	; 0x24
  147618:	ab05      	add	r3, sp, #20
  14761a:	950a      	str	r5, [sp, #40]	; 0x28
    for (uint32_t i = 0; i < iteration; i++) {
  14761c:	f10b 0b01 	add.w	r11, r11, #1
        uint32_t status = rng_get_rand_less_ref(vce_id, // 0 < rand < number-2
  147620:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  147624:	2303      	movs	r3, #3
  147626:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14762a:	930b      	str	r3, [sp, #44]	; 0x2c
  14762c:	ab09      	add	r3, sp, #36	; 0x24
  14762e:	4640      	mov	r0, r8
  147630:	cb0e      	ldmia	r3, {r1, r2, r3}
  147632:	f7fe fe5d 	bl	1462f0 <rng_get_rand_less_ref>
        math_array_incr(rand, length, 1); // 1 < rand < number-1
  147636:	2201      	movs	r2, #1
  147638:	4629      	mov	r1, r5
        if (status) {
  14763a:	4604      	mov	r4, r0
  14763c:	2800      	cmp	r0, #0
  14763e:	d137      	bne.n	1476b0 <prime_verify+0xf8>
        math_array_incr(rand, length, 1); // 1 < rand < number-1
  147640:	4650      	mov	r0, r10
  147642:	2603      	movs	r6, #3
  147644:	f7ff ffaa 	bl	14759c <math_array_incr>
        math_array_incr((uint8_t*)(candi_prime.addr), length, 2);  // restore prime candidate
  147648:	2202      	movs	r2, #2
  14764a:	4629      	mov	r1, r5
  14764c:	4648      	mov	r0, r9
  14764e:	f7ff ffa5 	bl	14759c <math_array_incr>
  147652:	e9cd a50c 	strd	r10, r5, [r13, #48]	; 0x30
  147656:	960e      	str	r6, [sp, #56]	; 0x38
  147658:	ab05      	add	r3, sp, #20
  14765a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    pke_set_command(vce_id, BA414EP_OPTYPE_MILLER_RABIN, candi_prime.len, BA414EP_LITTLEEND, 0);
  14765e:	9400      	str	r4, [sp, #0]
  147660:	4623      	mov	r3, r4
  147662:	e887 0007 	stmia.w	r7, {r0, r1, r2}
  147666:	462a      	mov	r2, r5
  147668:	2142      	movs	r1, #66	; 0x42
  14766a:	4640      	mov	r0, r8
  14766c:	f7fc fd82 	bl	144174 <pke_set_command>
    mem2CryptoRAM_rev(vce_id, ref_prime, ref_prime.len, BA414EP_MEMLOC_6, true);
  147670:	f04f 0c06 	mov.w	r12, #6
  147674:	2201      	movs	r2, #1
  147676:	ab0c      	add	r3, sp, #48	; 0x30
  147678:	9500      	str	r5, [sp, #0]
  14767a:	4640      	mov	r0, r8
  14767c:	9202      	str	r2, [sp, #8]
  14767e:	cb0e      	ldmia	r3, {r1, r2, r3}
  147680:	f8cd c004 	str.w	r12, [r13, #4]
  147684:	f7fd fc2e 	bl	144ee4 <mem2CryptoRAM_rev>
    mem2CryptoRAM_rev(vce_id, candi_prime, candi_prime.len, BA414EP_MEMLOC_0, true);
  147688:	2301      	movs	r3, #1
  14768a:	9500      	str	r5, [sp, #0]
  14768c:	4640      	mov	r0, r8
  14768e:	e9cd 4301 	strd	r4, r3, [r13, #4]
  147692:	e897 000e 	ldmia.w	r7, {r1, r2, r3}
  147696:	f7fd fc25 	bl	144ee4 <mem2CryptoRAM_rev>
    uint32_t status = pke_start_wait_status(vce_id);
  14769a:	4640      	mov	r0, r8
  14769c:	f7fc fd86 	bl	1441ac <pke_start_wait_status>
  1476a0:	4604      	mov	r4, r0
    if (status && status != CRYPTOLIB_PK_COMPOSITE) {
  1476a2:	f1b0 0310 	subs.w	r3, r0, #16
  1476a6:	bf18      	it	ne
  1476a8:	2301      	movne	r3, #1
  1476aa:	f030 0210 	bics.w	r2, r0, #16
  1476ae:	d0a1      	beq.n	1475f4 <prime_verify+0x3c>
            ce_free(mem_n);
  1476b0:	9804      	ldr	r0, [sp, #16]
  1476b2:	f7fb ff5b 	bl	14356c <ce_free>
        }
    }

    ce_free(mem_n);
    return CRYPTOLIB_SUCCESS;
}
  1476b6:	4620      	mov	r0, r4
  1476b8:	b013      	add	sp, #76	; 0x4c
  1476ba:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    ce_free(mem_n);
  1476be:	9804      	ldr	r0, [sp, #16]
    return CRYPTOLIB_SUCCESS;
  1476c0:	2400      	movs	r4, #0
    ce_free(mem_n);
  1476c2:	f7fb ff53 	bl	14356c <ce_free>
}
  1476c6:	4620      	mov	r0, r4
  1476c8:	b013      	add	sp, #76	; 0x4c
  1476ca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  1476ce:	bf00      	nop

001476d0 <converge_to_prime>:
}

uint32_t converge_to_prime(uint32_t vce_id,
                           block_t candi_number,
                           uint32_t rounds)
{
  1476d0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1476d4:	b0b7      	sub	sp, #220	; 0xdc
  1476d6:	ac0b      	add	r4, sp, #44	; 0x2c
  1476d8:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  1476dc:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    uint32_t mod = 0;
    uint8_t incr = 0;

    /* Make the number odd */
    *(candi_number.addr + candi_number.len - 1) |= 0x01;
  1476de:	1e74      	subs	r4, r6, #1
  1476e0:	5d0b      	ldrb	r3, [r1, r4]
    if (nr_of_bytes > PRIME_MAX_SIZE) {
  1476e2:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
        return CRYPTOLIB_INVALID_PARAM;
  1476e6:	bf88      	it	hi
  1476e8:	f04f 0909 	movhi.w	r9, #9
    *(candi_number.addr + candi_number.len - 1) |= 0x01;
  1476ec:	f043 0301 	orr.w	r3, r3, #1
  1476f0:	550b      	strb	r3, [r1, r4]
    if (nr_of_bytes > PRIME_MAX_SIZE) {
  1476f2:	f200 8083 	bhi.w	1477fc <converge_to_prime+0x12c>
  1476f6:	9006      	str	r0, [sp, #24]
    mem_n = ce_malloc(PRIME_MAX_SIZE);
  1476f8:	f44f 7080 	mov.w	r0, #256	; 0x100
  1476fc:	468a      	mov	r10, r1
  1476fe:	f7fb fef1 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  147702:	4607      	mov	r7, r0
  147704:	2800      	cmp	r0, #0
  147706:	d077      	beq.n	1477f8 <converge_to_prime+0x128>
        tmp = mem_n->ptr;
  147708:	6885      	ldr	r5, [r0, #8]
    memset(tmp, 0, nr_of_bytes - sizeof(prod_first_8_odd_primes));
  14770a:	f1a6 0804 	sub.w	r8, r6, #4
  14770e:	4642      	mov	r2, r8
  147710:	2100      	movs	r1, #0
  147712:	4628      	mov	r0, r5
    tmp[nr_of_bytes - 3] = (prod_first_8_odd_primes & 0x00FF0000) >> 16;
  147714:	f1a6 0b03 	sub.w	r11, r6, #3
    memset(tmp, 0, nr_of_bytes - sizeof(prod_first_8_odd_primes));
  147718:	f00b ecb0 	blx	15307c <memset>
    tmp[nr_of_bytes - 4] = (prod_first_8_odd_primes & 0xFF000000) >> 24;
  14771c:	f04f 0e06 	mov.w	r14, #6
    tmp[nr_of_bytes - 3] = (prod_first_8_odd_primes & 0x00FF0000) >> 16;
  147720:	23a6      	movs	r3, #166	; 0xa6
    tmp[nr_of_bytes - 2] = (prod_first_8_odd_primes & 0x0000FF00) >> 8;
  147722:	1eb1      	subs	r1, r6, #2
  147724:	f04f 0c03 	mov.w	r12, #3
    uint32_t status = modular_reduce_odd(vce_id,
  147728:	aa15      	add	r2, sp, #84	; 0x54
    tmp[nr_of_bytes - 2] = (prod_first_8_odd_primes & 0x0000FF00) >> 8;
  14772a:	9107      	str	r1, [sp, #28]
    uint32_t status = modular_reduce_odd(vce_id,
  14772c:	a903      	add	r1, sp, #12
    tmp[nr_of_bytes - 2] = (prod_first_8_odd_primes & 0x0000FF00) >> 8;
  14772e:	2010      	movs	r0, #16
    uint32_t status = modular_reduce_odd(vce_id,
  147730:	f10d 0948 	add.w	r9, r13, #72	; 0x48
    tmp[nr_of_bytes - 4] = (prod_first_8_odd_primes & 0xFF000000) >> 24;
  147734:	f805 e008 	strb.w	r14, [r5, r8]
    uint32_t status = modular_reduce_odd(vce_id,
  147738:	f10d 0e3c 	add.w	r14, r13, #60	; 0x3c
    tmp[nr_of_bytes - 3] = (prod_first_8_odd_primes & 0x00FF0000) >> 16;
  14773c:	f805 300b 	strb.w	r3, [r5, r11]
    tmp[nr_of_bytes - 1] = (prod_first_8_odd_primes & 0x000000FF);
  147740:	f04f 0343 	mov.w	r3, #67	; 0x43
    uint32_t status = modular_reduce_odd(vce_id,
  147744:	9108      	str	r1, [sp, #32]
    tmp[nr_of_bytes - 2] = (prod_first_8_odd_primes & 0x0000FF00) >> 8;
  147746:	9907      	ldr	r1, [sp, #28]
  147748:	5468      	strb	r0, [r5, r1]
  14774a:	f8cd c05c 	str.w	r12, [r13, #92]	; 0x5c
  14774e:	9515      	str	r5, [sp, #84]	; 0x54
  147750:	9616      	str	r6, [sp, #88]	; 0x58
    uint32_t status = modular_reduce_odd(vce_id,
  147752:	ca07      	ldmia	r2, {r0, r1, r2}
    tmp[nr_of_bytes - 1] = (prod_first_8_odd_primes & 0x000000FF);
  147754:	552b      	strb	r3, [r5, r4]
    uint32_t status = modular_reduce_odd(vce_id,
  147756:	9b08      	ldr	r3, [sp, #32]
  147758:	f8cd c050 	str.w	r12, [r13, #80]	; 0x50
  14775c:	e9cd 5612 	strd	r5, r6, [r13, #72]	; 0x48
  147760:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  147764:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
  147768:	f8cd c044 	str.w	r12, [r13, #68]	; 0x44
  14776c:	e9cd a60f 	strd	r10, r6, [r13, #60]	; 0x3c
  147770:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  147774:	e89e 000e 	ldmia.w	r14, {r1, r2, r3}
  147778:	9806      	ldr	r0, [sp, #24]
  14777a:	f7ff fe99 	bl	1474b0 <modular_reduce_odd>
    if (status) {
  14777e:	4681      	mov	r9, r0
  147780:	2800      	cmp	r0, #0
  147782:	f040 810a 	bne.w	14799a <converge_to_prime+0x2ca>
    *mod = (tmp[nr_of_bytes - 4] << 24) | (tmp[nr_of_bytes - 3] << 16) |
  147786:	f815 300b 	ldrb.w	r3, [r5, r11]
  14778a:	f815 2008 	ldrb.w	r2, [r5, r8]
           (tmp[nr_of_bytes - 2] << 8) | (tmp[nr_of_bytes - 1]);
  14778e:	5d2c      	ldrb	r4, [r5, r4]
    ce_free(mem_n);
  147790:	4638      	mov	r0, r7
         * corresponding modulo by 2.
         */
        incr += 2;
        mod += 2;

        if (mod >= prod_first_8_odd_primes) {
  147792:	f241 0842 	movw	r8, #4162	; 0x1042
    *mod = (tmp[nr_of_bytes - 4] << 24) | (tmp[nr_of_bytes - 3] << 16) |
  147796:	041b      	lsls	r3, r3, #16
            mod -= prod_first_8_odd_primes;
  147798:	f64e 7bbf 	movw	r11, #61375	; 0xefbf
    *mod = (tmp[nr_of_bytes - 4] << 24) | (tmp[nr_of_bytes - 3] << 16) |
  14779c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  1477a0:	f645 02c0 	movw	r2, #22720	; 0x58c0
           (tmp[nr_of_bytes - 2] << 8) | (tmp[nr_of_bytes - 1]);
  1477a4:	431c      	orrs	r4, r3
  1477a6:	9b07      	ldr	r3, [sp, #28]
  1477a8:	f2c0 0215 	movt	r2, #21
  1477ac:	5ceb      	ldrb	r3, [r5, r3]
  1477ae:	4d7e      	ldr	r5, [pc, #504]	; (1479a8 <converge_to_prime+0x2d8>)
  1477b0:	9209      	str	r2, [sp, #36]	; 0x24
  1477b2:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
        if (mod >= prod_first_8_odd_primes) {
  1477b6:	f2c0 68a6 	movt	r8, #1702	; 0x6a6
    ce_free(mem_n);
  1477ba:	f7fb fed7 	bl	14356c <ce_free>
  1477be:	464a      	mov	r2, r9
            mod -= prod_first_8_odd_primes;
  1477c0:	f6cf 1b59 	movt	r11, #63833	; 0xf959
  1477c4:	4879      	ldr	r0, [pc, #484]	; (1479ac <converge_to_prime+0x2dc>)
    ce_free(mem_n);
  1477c6:	2303      	movs	r3, #3
            if ((mod % first_odd_primes[i]) == 0) {
  1477c8:	fbb4 f1f3 	udiv	r1, r4, r3
  1477cc:	fb03 4311 	mls	r3, r3, r1, r4
  1477d0:	b14b      	cbz	r3, 1477e6 <converge_to_prime+0x116>
        for (uint32_t i = 0; i < sizeof(first_odd_primes); i++) {
  1477d2:	4285      	cmp	r5, r0
  1477d4:	d016      	beq.n	147804 <converge_to_prime+0x134>
  1477d6:	f810 3b01 	ldrb.w	r3, [r0], #1
            if ((mod % first_odd_primes[i]) == 0) {
  1477da:	fbb4 f1f3 	udiv	r1, r4, r3
  1477de:	fb03 4311 	mls	r3, r3, r1, r4
  1477e2:	2b00      	cmp	r3, #0
  1477e4:	d1f5      	bne.n	1477d2 <converge_to_prime+0x102>
  1477e6:	3202      	adds	r2, #2
  1477e8:	b2d2      	uxtb	r2, r2
        mod += 2;
  1477ea:	1ca3      	adds	r3, r4, #2
        if (mod >= prod_first_8_odd_primes) {
  1477ec:	4543      	cmp	r3, r8
            mod -= prod_first_8_odd_primes;
  1477ee:	bf88      	it	hi
  1477f0:	eb04 030b 	addhi.w	r3, r4, r11
{
  1477f4:	461c      	mov	r4, r3
  1477f6:	e7e5      	b.n	1477c4 <converge_to_prime+0xf4>
        return CRYPTOLIB_PK_N_NOTVALID;
  1477f8:	f04f 0915 	mov.w	r9, #21
        }
    }

    return CRYPTOLIB_SUCCESS;
}
  1477fc:	4648      	mov	r0, r9
  1477fe:	b037      	add	sp, #220	; 0xdc
  147800:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            math_array_incr(candi_number.addr, candi_number.len, incr);
  147804:	4631      	mov	r1, r6
  147806:	b252      	sxtb	r2, r2
  147808:	4650      	mov	r0, r10
  14780a:	f7ff fec7 	bl	14759c <math_array_incr>
    mem_n = ce_malloc(PRIME_MAX_SIZE);
  14780e:	f44f 7080 	mov.w	r0, #256	; 0x100
  147812:	f7fb fe67 	bl	1434e4 <ce_malloc>
    if (mem_n != NULL) {
  147816:	4607      	mov	r7, r0
  147818:	2800      	cmp	r0, #0
  14781a:	d0ed      	beq.n	1477f8 <converge_to_prime+0x128>
        tmp = mem_n->ptr;
  14781c:	f8d7 9008 	ldr.w	r9, [r7, #8]
    if (nr_of_bytes < prodsize) {
  147820:	2e7f      	cmp	r6, #127	; 0x7f
  147822:	d94e      	bls.n	1478c2 <converge_to_prime+0x1f2>
    else if (nr_of_bytes > prodsize) {
  147824:	2e80      	cmp	r6, #128	; 0x80
  147826:	bf08      	it	eq
  147828:	f8cd a01c 	streq.w	r10, [r13, #28]
  14782c:	d16c      	bne.n	147908 <converge_to_prime+0x238>
  14782e:	2303      	movs	r3, #3
  147830:	f04f 0c80 	mov.w	r12, #128	; 0x80
  147834:	9a09      	ldr	r2, [sp, #36]	; 0x24
    status = modular_inverse_odd(vce_id, block_t_convert(number, prodsize, EXT_MEM),
  147836:	f10d 0ec0 	add.w	r14, r13, #192	; 0xc0
  14783a:	9335      	str	r3, [sp, #212]	; 0xd4
  14783c:	9332      	str	r3, [sp, #200]	; 0xc8
  14783e:	ab36      	add	r3, sp, #216	; 0xd8
  147840:	e9cd 2c30 	strd	r2, r12, [r13, #192]	; 0xc0
  147844:	9a07      	ldr	r2, [sp, #28]
  147846:	f8cd 90cc 	str.w	r9, [r13, #204]	; 0xcc
  14784a:	f10d 09b4 	add.w	r9, r13, #180	; 0xb4
  14784e:	922d      	str	r2, [sp, #180]	; 0xb4
  147850:	f8cd c0d0 	str.w	r12, [r13, #208]	; 0xd0
  147854:	e913 0007 	ldmdb	r3, {r0, r1, r2}
  147858:	9b08      	ldr	r3, [sp, #32]
  14785a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14785e:	2303      	movs	r3, #3
  147860:	e89e 0007 	ldmia.w	r14, {r0, r1, r2}
  147864:	f8cd c0b8 	str.w	r12, [r13, #184]	; 0xb8
  147868:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14786c:	932f      	str	r3, [sp, #188]	; 0xbc
  14786e:	9806      	ldr	r0, [sp, #24]
  147870:	e899 000e 	ldmia.w	r9, {r1, r2, r3}
  147874:	f7ff fe38 	bl	1474e8 <modular_inverse_odd>
    if (status) {
  147878:	4681      	mov	r9, r0
        ce_free(mem_n);
  14787a:	4638      	mov	r0, r7
    if (status) {
  14787c:	f1b9 0f00 	cmp.w	r9, #0
  147880:	d119      	bne.n	1478b6 <converge_to_prime+0x1e6>
    ce_free(mem_n);
  147882:	f7fb fe73 	bl	14356c <ce_free>
            status = prime_verify(vce_id, candi_number, rounds, &prime);
  147886:	9a40      	ldr	r2, [sp, #256]	; 0x100
  147888:	f8cd a02c 	str.w	r10, [r13, #44]	; 0x2c
  14788c:	f10d 033b 	add.w	r3, r13, #59	; 0x3b
  147890:	960c      	str	r6, [sp, #48]	; 0x30
  147892:	e9cd 2300 	strd	r2, r3, [r13]
  147896:	ab0b      	add	r3, sp, #44	; 0x2c
  147898:	9806      	ldr	r0, [sp, #24]
            bool prime = false;
  14789a:	f88d 903b 	strb.w	r9, [r13, #59]	; 0x3b
            status = prime_verify(vce_id, candi_number, rounds, &prime);
  14789e:	cb0e      	ldmia	r3, {r1, r2, r3}
  1478a0:	f7ff fe8a 	bl	1475b8 <prime_verify>
            if (status) {
  1478a4:	4681      	mov	r9, r0
  1478a6:	2800      	cmp	r0, #0
  1478a8:	d1a8      	bne.n	1477fc <converge_to_prime+0x12c>
            if (prime) {
  1478aa:	f89d 303b 	ldrb.w	r3, [r13, #59]	; 0x3b
  1478ae:	2b00      	cmp	r3, #0
  1478b0:	d1a4      	bne.n	1477fc <converge_to_prime+0x12c>
  1478b2:	2202      	movs	r2, #2
  1478b4:	e799      	b.n	1477ea <converge_to_prime+0x11a>
        ce_free(mem_n);
  1478b6:	f7fb fe59 	bl	14356c <ce_free>
}
  1478ba:	4648      	mov	r0, r9
  1478bc:	b037      	add	sp, #220	; 0xdc
  1478be:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        memset(tmp, 0, prodsize - nr_of_bytes);
  1478c2:	2100      	movs	r1, #0
  1478c4:	f1c6 0380 	rsb	r3, r6, #128	; 0x80
  1478c8:	461a      	mov	r2, r3
  1478ca:	4648      	mov	r0, r9
  1478cc:	930a      	str	r3, [sp, #40]	; 0x28
        memcpy_blk(vce_id, block_t_convert(tmp + prodsize - nr_of_bytes, nr_of_bytes, EXT_MEM),
  1478ce:	f8cd 901c 	str.w	r9, [r13, #28]
        memset(tmp, 0, prodsize - nr_of_bytes);
  1478d2:	f00b ebd4 	blx	15307c <memset>
  1478d6:	f04f 0e03 	mov.w	r14, #3
        memcpy_blk(vce_id, block_t_convert(tmp + prodsize - nr_of_bytes, nr_of_bytes, EXT_MEM),
  1478da:	aa1b      	add	r2, sp, #108	; 0x6c
  1478dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  1478de:	f10d 0c60 	add.w	r12, r13, #96	; 0x60
  1478e2:	e9cd a61b 	strd	r10, r6, [r13, #108]	; 0x6c
  1478e6:	f8cd e074 	str.w	r14, [r13, #116]	; 0x74
  1478ea:	444b      	add	r3, r9
  1478ec:	ca07      	ldmia	r2, {r0, r1, r2}
  1478ee:	9318      	str	r3, [sp, #96]	; 0x60
  1478f0:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  1478f4:	9619      	str	r6, [sp, #100]	; 0x64
  1478f6:	9603      	str	r6, [sp, #12]
  1478f8:	f8cd e068 	str.w	r14, [r13, #104]	; 0x68
  1478fc:	9806      	ldr	r0, [sp, #24]
  1478fe:	e89c 000e 	ldmia.w	r12, {r1, r2, r3}
  147902:	f7fd fad9 	bl	144eb8 <memcpy_blk>
  147906:	e792      	b.n	14782e <converge_to_prime+0x15e>
        memset(tmp, 0, nr_of_bytes - prodsize);
  147908:	2100      	movs	r1, #0
  14790a:	f1a6 0380 	sub.w	r3, r6, #128	; 0x80
  14790e:	461a      	mov	r2, r3
  147910:	4648      	mov	r0, r9
  147912:	9307      	str	r3, [sp, #28]
  147914:	f00b ebb2 	blx	15307c <memset>
  147918:	f04f 0e80 	mov.w	r14, #128	; 0x80
        memcpy_blk(vce_id, block_t_convert(tmp + nr_of_bytes - prodsize, prodsize, EXT_MEM),
  14791c:	aa21      	add	r2, sp, #132	; 0x84
  14791e:	9b07      	ldr	r3, [sp, #28]
  147920:	f10d 0c78 	add.w	r12, r13, #120	; 0x78
  147924:	9909      	ldr	r1, [sp, #36]	; 0x24
  147926:	e9cd 1e21 	strd	r1, r14, [r13, #132]	; 0x84
  14792a:	444b      	add	r3, r9
  14792c:	2103      	movs	r1, #3
  14792e:	e9cd 3e1e 	strd	r3, r14, [r13, #120]	; 0x78
  147932:	9307      	str	r3, [sp, #28]
  147934:	2303      	movs	r3, #3
  147936:	9123      	str	r1, [sp, #140]	; 0x8c
  147938:	ca07      	ldmia	r2, {r0, r1, r2}
  14793a:	9320      	str	r3, [sp, #128]	; 0x80
  14793c:	f8cd e00c 	str.w	r14, [r13, #12]
  147940:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  147944:	9806      	ldr	r0, [sp, #24]
  147946:	e89c 000e 	ldmia.w	r12, {r1, r2, r3}
  14794a:	f7fd fab5 	bl	144eb8 <memcpy_blk>
  14794e:	2303      	movs	r3, #3
        status = modular_reduce_odd(vce_id,
  147950:	aa2a      	add	r2, sp, #168	; 0xa8
  147952:	e9cd 962a 	strd	r9, r6, [r13, #168]	; 0xa8
  147956:	f10d 0c9c 	add.w	r12, r13, #156	; 0x9c
  14795a:	932c      	str	r3, [sp, #176]	; 0xb0
  14795c:	f10d 0e90 	add.w	r14, r13, #144	; 0x90
  147960:	ca07      	ldmia	r2, {r0, r1, r2}
  147962:	9329      	str	r3, [sp, #164]	; 0xa4
  147964:	9b08      	ldr	r3, [sp, #32]
  147966:	e9cd 9627 	strd	r9, r6, [r13, #156]	; 0x9c
  14796a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14796e:	2303      	movs	r3, #3
  147970:	e89c 0007 	ldmia.w	r12, {r0, r1, r2}
  147974:	9326      	str	r3, [sp, #152]	; 0x98
  147976:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14797a:	e9cd a624 	strd	r10, r6, [r13, #144]	; 0x90
  14797e:	9806      	ldr	r0, [sp, #24]
  147980:	e89e 000e 	ldmia.w	r14, {r1, r2, r3}
  147984:	f7ff fd94 	bl	1474b0 <modular_reduce_odd>
        if (status) {
  147988:	2800      	cmp	r0, #0
  14798a:	f43f af50 	beq.w	14782e <converge_to_prime+0x15e>
            ce_free(mem_n);
  14798e:	4638      	mov	r0, r7
  147990:	f04f 0906 	mov.w	r9, #6
  147994:	f7fb fdea 	bl	14356c <ce_free>
  147998:	e730      	b.n	1477fc <converge_to_prime+0x12c>
        ce_free(mem_n);
  14799a:	4638      	mov	r0, r7
  14799c:	f7fb fde6 	bl	14356c <ce_free>
}
  1479a0:	4648      	mov	r0, r9
  1479a2:	b037      	add	sp, #220	; 0xdc
  1479a4:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  1479a8:	001558a8 	.word	0x001558a8
  1479ac:	001558a1 	.word	0x001558a1

001479b0 <platform_earlycopy>:

extern struct early_copy_section __earlycopy_start;
extern struct early_copy_section __earlycopy_end;

void platform_earlycopy(void)
{
  1479b0:	b570      	push	{r4, r5, r6, r14}
    struct early_copy_section *p;

    for (p = &__earlycopy_start; p < &__earlycopy_end; p++) {
  1479b2:	f648 14fc 	movw	r4, #35324	; 0x89fc
  1479b6:	f648 2608 	movw	r6, #35336	; 0x8a08
  1479ba:	f2c0 0415 	movt	r4, #21
  1479be:	f2c0 0615 	movt	r6, #21
  1479c2:	42b4      	cmp	r4, r6
  1479c4:	d211      	bcs.n	1479ea <platform_earlycopy+0x3a>
  1479c6:	340c      	adds	r4, #12
        LTRACEF_LEVEL(3, "vma 0x%x, lma 0x%x, size %d\n",
            p->vma, p->lma, p->size);

        memcpy((void *)p->vma, (void *)p->lma, p->size);
  1479c8:	f854 2c08 	ldr.w	r2, [r4, #-8]
  1479cc:	4625      	mov	r5, r4
  1479ce:	f854 1c04 	ldr.w	r1, [r4, #-4]
  1479d2:	f854 0c0c 	ldr.w	r0, [r4, #-12]
  1479d6:	f00b eacc 	blx	152f70 <memcpy>
        arch_clean_cache_range((addr_t)p->vma, p->size);
  1479da:	e954 0103 	ldrd	r0, r1, [r4, #-12]
  1479de:	f7fa e8b2 	blx	141b44 <arch_clean_cache_range>
    for (p = &__earlycopy_start; p < &__earlycopy_end; p++) {
  1479e2:	42b5      	cmp	r5, r6
  1479e4:	f104 040c 	add.w	r4, r4, #12
  1479e8:	d3ee      	bcc.n	1479c8 <platform_earlycopy+0x18>
    }
}
  1479ea:	bd70      	pop	{r4, r5, r6, r15}

001479ec <default_cfg>:

        default:
            return -1;
    }

    uint32_t val = readl(base_addr + ((reg_offset + (bit_offset / 32) * 4) << 10));
  1479ec:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  1479f0:	f6cf 0324 	movt	r3, #63524	; 0xf824
 * check firewall enable efuse?
 * mac global cfg, enable domain check and set secure core as res mgr, then lock this byte
 * resource manager cfg
 */
int default_cfg(void)
{
  1479f4:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t val = readl(base_addr + ((reg_offset + (bit_offset / 32) * 4) << 10));
  1479f6:	681b      	ldr	r3, [r3, #0]
    uint32_t value;

    //check product mode, if true then set to silent action
    prod_mode = scr_bit_get(SCR_BASE_ADDR, SCR_RO, SCR_PROD_ENABLE_RO_START_BIT);

    if (1 == prod_mode) {
  1479f8:	01db      	lsls	r3, r3, #7
  1479fa:	d517      	bpl.n	147a2c <default_cfg+0x40>
    writel((0xFFFF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1360 / 32) * 4) << 10));
  1479fc:	2500      	movs	r5, #0
  1479fe:	f44f 4420 	mov.w	r4, #40960	; 0xa000
    writel((0x3FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147a02:	4628      	mov	r0, r5
    writel((0x7FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147a04:	462a      	mov	r2, r5
    writel((0x3FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147a06:	f44f 4130 	mov.w	r1, #45056	; 0xb000
    writel((0x7FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147a0a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
    writel((0xFFFF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1360 / 32) * 4) << 10));
  147a0e:	f6cf 042a 	movt	r4, #63530	; 0xf82a
  147a12:	f6cf 75ff 	movt	r5, #65535	; 0xffff
    writel((0x3FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147a16:	f6cf 012a 	movt	r1, #63530	; 0xf82a
  147a1a:	f2c0 30ff 	movt	r0, #1023	; 0x3ff
    writel((0x7FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147a1e:	f6cf 032a 	movt	r3, #63530	; 0xf82a
    writel((0xFFFF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1360 / 32) * 4) << 10));
  147a22:	6025      	str	r5, [r4, #0]
    writel((0x7FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147a24:	f2c0 72ff 	movt	r2, #2047	; 0x7ff
    writel((0x3FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147a28:	6008      	str	r0, [r1, #0]
    writel((0x7FF << 16), SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147a2a:	601a      	str	r2, [r3, #0]
        fw_resp_disable();
    }

    // mac global config
    value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  147a2c:	2100      	movs	r1, #0
    value = reg_value(1, value, MAC_GLB_CTL_DOM_CFG_LOCK_SHIFT, MAC_GLB_CTL_DOM_CFG_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_PERCK_DIS_LOCK_SHIFT, MAC_GLB_CTL_PERCK_DIS_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_DOM_PRO_LOCK_SHIFT, MAC_GLB_CTL_DOM_PRO_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_DOM_PRO_EN_SHIFT, MAC_GLB_CTL_DOM_PRO_EN_MASK);
    writel(value, GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a2e:	f44f 4560 	mov.w	r5, #57344	; 0xe000
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a32:	462c      	mov	r4, r5
    value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  147a34:	f2cf 01bc 	movt	r1, #61628	; 0xf0bc
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a38:	f2cf 65ff 	movt	r5, #63231	; 0xf6ff
    writel(value, RPC_BASE_ADDR_SAF + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
#endif

    //res manager master config, set secure core as res manager
    writel(0x2, GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
    writel(0x2, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147a3c:	f24e 0c08 	movw	r12, #57352	; 0xe008
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a40:	f6cf 04ff 	movt	r4, #63743	; 0xf8ff
    value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  147a44:	680b      	ldr	r3, [r1, #0]
    writel(0x2, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147a46:	4667      	mov	r7, r12
    writel(0x2, GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
  147a48:	2008      	movs	r0, #8
    value = reg_value(1, value, MAC_RES_MGR_DID_LOCK_SHIFT, MAC_RES_MGR_DID_LOCK_MASK);
    value = reg_value(0, value, MAC_RES_MGR_DID_SHIFT, MAC_RES_MGR_DID_MASK);
    value = reg_value(1, value, MAC_RES_MGR_DID_EN_SHIFT, MAC_RES_MGR_DID_EN_MASK);
    value = reg_value(1, value, MAC_RES_MGR_RES_MGR_EN_LOCK_SHIFT, MAC_RES_MGR_RES_MGR_EN_LOCK_MASK);
    value = reg_value(1, value, MAC_RES_MGR_RES_MGR_EN_SHIFT, MAC_RES_MGR_RES_MGR_EN_MASK);
    writel(value, GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147a4a:	2604      	movs	r6, #4
  147a4c:	43da      	mvns	r2, r3
  147a4e:	f002 0220 	and.w	r2, r2, #32
  147a52:	4053      	eors	r3, r2
  147a54:	43da      	mvns	r2, r3
  147a56:	f002 0208 	and.w	r2, r2, #8
  147a5a:	405a      	eors	r2, r3
  147a5c:	43d3      	mvns	r3, r2
  147a5e:	f003 0302 	and.w	r3, r3, #2
  147a62:	405a      	eors	r2, r3
  147a64:	43d3      	mvns	r3, r2
  147a66:	f003 0301 	and.w	r3, r3, #1
  147a6a:	4053      	eors	r3, r2
  147a6c:	f648 0287 	movw	r2, #34951	; 0x8887
    writel(0x2, GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
  147a70:	f2cf 00bc 	movt	r0, #61628	; 0xf0bc
    writel(value, GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  147a74:	600b      	str	r3, [r1, #0]
    writel(value, GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147a76:	f2c0 0203 	movt	r2, #3
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a7a:	602b      	str	r3, [r5, #0]
    writel(0x2, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147a7c:	f6cf 07ff 	movt	r7, #63743	; 0xf8ff
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147a80:	6023      	str	r3, [r4, #0]
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147a82:	f24e 0404 	movw	r4, #57348	; 0xe004
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147a86:	4621      	mov	r1, r4
    writel(0x2, GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
  147a88:	2302      	movs	r3, #2
    writel(value, GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147a8a:	f2cf 06bc 	movt	r6, #61628	; 0xf0bc
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147a8e:	f2cf 64ff 	movt	r4, #63231	; 0xf6ff
    writel(0x2, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147a92:	f2cf 6cff 	movt	r12, #63231	; 0xf6ff
    writel(0x2, GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
  147a96:	6003      	str	r3, [r0, #0]
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147a98:	f6cf 01ff 	movt	r1, #63743	; 0xf8ff
    writel(0x2, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147a9c:	f8cc 3000 	str.w	r3, [r12]
#ifdef ENABLE_SAF_FIREWALL
    writel(value, RPC_BASE_ADDR_SAF + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
#endif

    return 0;
}
  147aa0:	2000      	movs	r0, #0
    writel(0x2, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147aa2:	603b      	str	r3, [r7, #0]
    writel(value, GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147aa4:	6032      	str	r2, [r6, #0]
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147aa6:	6022      	str	r2, [r4, #0]
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147aa8:	600a      	str	r2, [r1, #0]
}
  147aaa:	bcf0      	pop	{r4, r5, r6, r7}
  147aac:	4770      	bx	r14
  147aae:	bf00      	nop

00147ab0 <fw_cfg_check>:

/* check step 1:
 * check values of firewall registers with firewall configuration
 */
int fw_cfg_check(uint32_t cfg_count, firewall_cfg_t* fw_cfg)
{
  147ab0:	b508      	push	{r3, r14}
    uint32_t read_val;
    uint32_t value;
    uint32_t prod_mode;

    for (uint32_t i = 0; i < cfg_count; i++) {
  147ab2:	b138      	cbz	r0, 147ac4 <fw_cfg_check+0x14>
  147ab4:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  147ab8:	4408      	add	r0, r1
        read_val = readl(fw_cfg->reg_addr);
  147aba:	f851 3b09 	ldr.w	r3, [r1], #9
    for (uint32_t i = 0; i < cfg_count; i++) {
  147abe:	4288      	cmp	r0, r1
        read_val = readl(fw_cfg->reg_addr);
  147ac0:	681b      	ldr	r3, [r3, #0]
    for (uint32_t i = 0; i < cfg_count; i++) {
  147ac2:	d1fa      	bne.n	147aba <fw_cfg_check+0xa>
    value = reg_value(1, 0x10, MAC_GLB_CTL_DOM_CFG_LOCK_SHIFT, MAC_GLB_CTL_DOM_CFG_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_PERCK_DIS_LOCK_SHIFT, MAC_GLB_CTL_PERCK_DIS_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_DOM_PRO_LOCK_SHIFT, MAC_GLB_CTL_DOM_PRO_LOCK_MASK);
    value = reg_value(1, value, MAC_GLB_CTL_DOM_PRO_EN_SHIFT, MAC_GLB_CTL_DOM_PRO_EN_MASK);

    read_val = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  147ac4:	2100      	movs	r1, #0
  147ac6:	f2cf 01bc 	movt	r1, #61628	; 0xf0bc
  147aca:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147acc:	2b3b      	cmp	r3, #59	; 0x3b
  147ace:	d006      	beq.n	147ade <fw_cfg_check+0x2e>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147ad0:	f645 3014 	movw	r0, #23316	; 0x5b14
  147ad4:	223b      	movs	r2, #59	; 0x3b
  147ad6:	f2c0 0015 	movt	r0, #21
  147ada:	f00c fb0d 	bl	1540f8 <_printf>
                GLB_MAC_BASE_ADDR + MAC_GLB_CTL, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147ade:	f44f 4160 	mov.w	r1, #57344	; 0xe000
  147ae2:	f2cf 61ff 	movt	r1, #63231	; 0xf6ff
  147ae6:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147ae8:	2b3b      	cmp	r3, #59	; 0x3b
  147aea:	d006      	beq.n	147afa <fw_cfg_check+0x4a>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147aec:	f645 3014 	movw	r0, #23316	; 0x5b14
  147af0:	223b      	movs	r2, #59	; 0x3b
  147af2:	f2c0 0015 	movt	r0, #21
  147af6:	f00c faff 	bl	1540f8 <_printf>
                RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  147afa:	f44f 4160 	mov.w	r1, #57344	; 0xe000
  147afe:	f6cf 01ff 	movt	r1, #63743	; 0xf8ff
  147b02:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147b04:	2b3b      	cmp	r3, #59	; 0x3b
  147b06:	d006      	beq.n	147b16 <fw_cfg_check+0x66>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147b08:	f645 3014 	movw	r0, #23316	; 0x5b14
  147b0c:	223b      	movs	r2, #59	; 0x3b
  147b0e:	f2c0 0015 	movt	r0, #21
  147b12:	f00c faf1 	bl	1540f8 <_printf>
    value = reg_value(1, value, MAC_RES_MGR_DID_LOCK_SHIFT, MAC_RES_MGR_DID_LOCK_MASK);
    value = reg_value(0, value, MAC_RES_MGR_DID_SHIFT, MAC_RES_MGR_DID_MASK);
    value = reg_value(1, value, MAC_RES_MGR_DID_EN_SHIFT, MAC_RES_MGR_DID_EN_MASK);
    value = reg_value(1, value, MAC_RES_MGR_RES_MGR_EN_LOCK_SHIFT, MAC_RES_MGR_RES_MGR_EN_LOCK_MASK);
    value = reg_value(1, value, MAC_RES_MGR_RES_MGR_EN_SHIFT, MAC_RES_MGR_RES_MGR_EN_MASK);
    read_val = readl(GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147b16:	2104      	movs	r1, #4

    if (read_val != value) {
  147b18:	f648 0287 	movw	r2, #34951	; 0x8887
    read_val = readl(GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147b1c:	f2cf 01bc 	movt	r1, #61628	; 0xf0bc
    if (read_val != value) {
  147b20:	f2c0 0203 	movt	r2, #3
    read_val = readl(GLB_MAC_BASE_ADDR + MAC_RES_MGR);
  147b24:	680b      	ldr	r3, [r1, #0]
    if (read_val != value) {
  147b26:	4293      	cmp	r3, r2
  147b28:	d005      	beq.n	147b36 <fw_cfg_check+0x86>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147b2a:	f645 3014 	movw	r0, #23316	; 0x5b14
  147b2e:	f2c0 0015 	movt	r0, #21
  147b32:	f00c fae1 	bl	1540f8 <_printf>
                GLB_MAC_BASE_ADDR + MAC_RES_MGR, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b36:	f24e 0104 	movw	r1, #57348	; 0xe004

    if (read_val != value) {
  147b3a:	f648 0287 	movw	r2, #34951	; 0x8887
    read_val = readl(RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b3e:	f2cf 61ff 	movt	r1, #63231	; 0xf6ff
    if (read_val != value) {
  147b42:	f2c0 0203 	movt	r2, #3
    read_val = readl(RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b46:	680b      	ldr	r3, [r1, #0]
    if (read_val != value) {
  147b48:	4293      	cmp	r3, r2
  147b4a:	d005      	beq.n	147b58 <fw_cfg_check+0xa8>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147b4c:	f645 3014 	movw	r0, #23316	; 0x5b14
  147b50:	f2c0 0015 	movt	r0, #21
  147b54:	f00c fad0 	bl	1540f8 <_printf>
                RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b58:	f24e 0104 	movw	r1, #57348	; 0xe004

    if (read_val != value) {
  147b5c:	f648 0287 	movw	r2, #34951	; 0x8887
    read_val = readl(RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b60:	f6cf 01ff 	movt	r1, #63743	; 0xf8ff
    if (read_val != value) {
  147b64:	f2c0 0203 	movt	r2, #3
    read_val = readl(RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR);
  147b68:	680b      	ldr	r3, [r1, #0]
    if (read_val != value) {
  147b6a:	4293      	cmp	r3, r2
  147b6c:	d005      	beq.n	147b7a <fw_cfg_check+0xca>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147b6e:	f645 3014 	movw	r0, #23316	; 0x5b14
  147b72:	f2c0 0015 	movt	r0, #21
  147b76:	f00c fabf 	bl	1540f8 <_printf>
    }
#endif

    //res manager master config, set secure core as res manager
    value = 0x2;
    read_val = readl(GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0);
  147b7a:	2108      	movs	r1, #8
  147b7c:	f2cf 01bc 	movt	r1, #61628	; 0xf0bc
  147b80:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147b82:	2b02      	cmp	r3, #2
  147b84:	d006      	beq.n	147b94 <fw_cfg_check+0xe4>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147b86:	f645 3014 	movw	r0, #23316	; 0x5b14
  147b8a:	2202      	movs	r2, #2
  147b8c:	f2c0 0015 	movt	r0, #21
  147b90:	f00c fab2 	bl	1540f8 <_printf>
                GLB_MAC_BASE_ADDR + MAC_RES_MGR_MA0, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147b94:	f24e 0108 	movw	r1, #57352	; 0xe008
  147b98:	f2cf 61ff 	movt	r1, #63231	; 0xf6ff
  147b9c:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147b9e:	2b02      	cmp	r3, #2
  147ba0:	d006      	beq.n	147bb0 <fw_cfg_check+0x100>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147ba2:	f645 3014 	movw	r0, #23316	; 0x5b14
  147ba6:	2202      	movs	r2, #2
  147ba8:	f2c0 0015 	movt	r0, #21
  147bac:	f00c faa4 	bl	1540f8 <_printf>
                RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0, value, read_val);
    }

    read_val = readl(RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_RES_MGR_MA0);
  147bb0:	f24e 0108 	movw	r1, #57352	; 0xe008
  147bb4:	f6cf 01ff 	movt	r1, #63743	; 0xf8ff
  147bb8:	680b      	ldr	r3, [r1, #0]

    if (read_val != value) {
  147bba:	2b02      	cmp	r3, #2
  147bbc:	d006      	beq.n	147bcc <fw_cfg_check+0x11c>
        dprintf(CRITICAL, "global reg wrong, addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147bbe:	f645 3014 	movw	r0, #23316	; 0x5b14
  147bc2:	2202      	movs	r2, #2
  147bc4:	f2c0 0015 	movt	r0, #21
  147bc8:	f00c fa96 	bl	1540f8 <_printf>
    uint32_t val = readl(base_addr + ((reg_offset + (bit_offset / 32) * 4) << 10));
  147bcc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  147bd0:	f6cf 0324 	movt	r3, #63524	; 0xf824
  147bd4:	681b      	ldr	r3, [r3, #0]
#endif

    //scr register check
    prod_mode = scr_bit_get(SCR_BASE_ADDR, SCR_RO, SCR_PROD_ENABLE_RO_START_BIT);

    if (1 == prod_mode) {
  147bd6:	01db      	lsls	r3, r3, #7
  147bd8:	d523      	bpl.n	147c22 <fw_cfg_check+0x172>
        value = 0xFFFF << 16;
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1360 / 32) * 4) << 10));
  147bda:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  147bde:	f6cf 032a 	movt	r3, #63530	; 0xf82a
  147be2:	681b      	ldr	r3, [r3, #0]

        if (read_val != value) {
  147be4:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
  147be8:	d126      	bne.n	147c38 <fw_cfg_check+0x188>
            dprintf(CRITICAL, "disable fw resp fail, reg offset addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
                    (SCR_L16_OFFSET + (1360 / 32) * 4), value, read_val);
        }

        value = 0x3FF << 16;
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147bea:	f44f 4330 	mov.w	r3, #45056	; 0xb000

        if (read_val != value) {
  147bee:	2200      	movs	r2, #0
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147bf0:	f6cf 032a 	movt	r3, #63530	; 0xf82a
        if (read_val != value) {
  147bf4:	f2c0 32ff 	movt	r2, #1023	; 0x3ff
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1392 / 32) * 4) << 10));
  147bf8:	681b      	ldr	r3, [r3, #0]
        if (read_val != value) {
  147bfa:	4293      	cmp	r3, r2
  147bfc:	d113      	bne.n	147c26 <fw_cfg_check+0x176>
            dprintf(CRITICAL, "disable fw resp fail, reg offset addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
                    (SCR_L16_OFFSET + (1392 / 32) * 4), value, read_val);
        }

        value = 0x7FF << 16;
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147bfe:	f44f 4340 	mov.w	r3, #49152	; 0xc000

        if (read_val != value) {
  147c02:	2200      	movs	r2, #0
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147c04:	f6cf 032a 	movt	r3, #63530	; 0xf82a
        if (read_val != value) {
  147c08:	f2c0 72ff 	movt	r2, #2047	; 0x7ff
        read_val = readl(SCR_BASE_ADDR + ((SCR_L16_OFFSET + (1424 / 32) * 4) << 10));
  147c0c:	681b      	ldr	r3, [r3, #0]
        if (read_val != value) {
  147c0e:	4293      	cmp	r3, r2
  147c10:	d007      	beq.n	147c22 <fw_cfg_check+0x172>
            dprintf(CRITICAL, "disable fw resp fail, reg offset addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147c12:	f645 3050 	movw	r0, #23376	; 0x5b50
  147c16:	f44f 712c 	mov.w	r1, #688	; 0x2b0
  147c1a:	f2c0 0015 	movt	r0, #21
  147c1e:	f00c fa6b 	bl	1540f8 <_printf>
                    (SCR_L16_OFFSET + (1424 / 32) * 4), value, read_val);
        }
    }

    return 0;
}
  147c22:	2000      	movs	r0, #0
  147c24:	bd08      	pop	{r3, r15}
            dprintf(CRITICAL, "disable fw resp fail, reg offset addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147c26:	f645 3050 	movw	r0, #23376	; 0x5b50
  147c2a:	f44f 712b 	mov.w	r1, #684	; 0x2ac
  147c2e:	f2c0 0015 	movt	r0, #21
  147c32:	f00c fa61 	bl	1540f8 <_printf>
  147c36:	e7e2      	b.n	147bfe <fw_cfg_check+0x14e>
            dprintf(CRITICAL, "disable fw resp fail, reg offset addr: 0x%x, value: 0x%x, reg value: 0x%x\n",
  147c38:	2200      	movs	r2, #0
  147c3a:	f645 3050 	movw	r0, #23376	; 0x5b50
  147c3e:	f44f 712a 	mov.w	r1, #680	; 0x2a8
  147c42:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  147c46:	f2c0 0015 	movt	r0, #21
  147c4a:	f00c fa55 	bl	1540f8 <_printf>
  147c4e:	e7cc      	b.n	147bea <fw_cfg_check+0x13a>

00147c50 <format_output>:

static uint32_t did_output = 0x10;
int format_output(uint32_t did, uint32_t ip_type, uint32_t ip_index, uint32_t slot_index, addr_t addr_start, addr_t addr_end)
{
  147c50:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if (did_output != did)  {
  147c54:	f24e 4428 	movw	r4, #58408	; 0xe428
{
  147c58:	460d      	mov	r5, r1
  147c5a:	4617      	mov	r7, r2
    if (did_output != did)  {
  147c5c:	f2c0 0415 	movt	r4, #21
{
  147c60:	4698      	mov	r8, r3
    if (did_output != did)  {
  147c62:	6821      	ldr	r1, [r4, #0]
  147c64:	4281      	cmp	r1, r0
  147c66:	d008      	beq.n	147c7a <format_output+0x2a>
  147c68:	4606      	mov	r6, r0
        dprintf(CRITICAL, "Resources of domain 0x%x as following:\n", did);
  147c6a:	f645 2038 	movw	r0, #23096	; 0x5a38
  147c6e:	4631      	mov	r1, r6
  147c70:	f2c0 0015 	movt	r0, #21
  147c74:	f00c fa40 	bl	1540f8 <_printf>
        did_output = did;
  147c78:	6026      	str	r6, [r4, #0]
    }

    switch (ip_type) {
  147c7a:	2d03      	cmp	r5, #3
  147c7c:	d83d      	bhi.n	147cfa <format_output+0xaa>
  147c7e:	e8df f005 	tbb	[r15, r5]
  147c82:	1a26      	.short	0x1a26
  147c84:	020d      	.short	0x020d
            }

            break;

        case IP_RPC:
            dprintf(CRITICAL, "    RPC %d, register: %d\n", ip_index, slot_index);
  147c86:	f645 20f8 	movw	r0, #23288	; 0x5af8
  147c8a:	4642      	mov	r2, r8
  147c8c:	4639      	mov	r1, r7
  147c8e:	f2c0 0015 	movt	r0, #21
  147c92:	f00c fa31 	bl	1540f8 <_printf>

        default:
            return -1;
    }

    return 0;
  147c96:	2000      	movs	r0, #0
}
  147c98:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            if (addr_end <= 0) {
  147c9c:	9b07      	ldr	r3, [sp, #28]
  147c9e:	bb03      	cbnz	r3, 147ce2 <format_output+0x92>
                dprintf(CRITICAL, "    PPC %d, slot %d\n", ip_index, slot_index);
  147ca0:	f645 20a8 	movw	r0, #23208	; 0x5aa8
  147ca4:	4642      	mov	r2, r8
  147ca6:	4639      	mov	r1, r7
  147ca8:	f2c0 0015 	movt	r0, #21
  147cac:	f00c fa24 	bl	1540f8 <_printf>
  147cb0:	9807      	ldr	r0, [sp, #28]
}
  147cb2:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            dprintf(CRITICAL, "    MPC %d, start address: 0x%lx, end address: 0x%lx\n", ip_index, addr_start, addr_end);
  147cb6:	f645 2070 	movw	r0, #23152	; 0x5a70
  147cba:	4639      	mov	r1, r7
  147cbc:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
  147cc0:	f2c0 0015 	movt	r0, #21
  147cc4:	f00c fa18 	bl	1540f8 <_printf>
    return 0;
  147cc8:	2000      	movs	r0, #0
}
  147cca:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            dprintf(CRITICAL, "    Master %d\n", ip_index);
  147cce:	f645 2060 	movw	r0, #23136	; 0x5a60
  147cd2:	4639      	mov	r1, r7
  147cd4:	f2c0 0015 	movt	r0, #21
  147cd8:	f00c fa0e 	bl	1540f8 <_printf>
    return 0;
  147cdc:	2000      	movs	r0, #0
}
  147cde:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
                dprintf(CRITICAL, "    PPC %d, start address: 0x%lx, end address: 0x%lx\n", ip_index, addr_start, addr_end);
  147ce2:	f645 20c0 	movw	r0, #23232	; 0x5ac0
  147ce6:	4639      	mov	r1, r7
  147ce8:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
  147cec:	f2c0 0015 	movt	r0, #21
  147cf0:	f00c fa02 	bl	1540f8 <_printf>
  147cf4:	2000      	movs	r0, #0
}
  147cf6:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            return -1;
  147cfa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  147cfe:	e7cb      	b.n	147c98 <format_output+0x48>

00147d00 <res_assign_output>:

/*  */
int res_assign_output(void)
{
  147d00:	f44f 7201 	mov.w	r2, #516	; 0x204
    uint32_t i, j, k;
    uint32_t addr_offset;
    addr_t addr_start, addr_end;

    //acquire used domains
    for (uint32_t i = 0; i < DOM_MAX_COUNT; i++) {
  147d04:	2300      	movs	r3, #0
{
  147d06:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint32_t dom_used = 0;
  147d0a:	461c      	mov	r4, r3
{
  147d0c:	b0d7      	sub	sp, #348	; 0x15c
  147d0e:	f2cf 02bc 	movt	r2, #61628	; 0xf0bc
        read_val = readl(GLB_MAC_BASE_ADDR + MAC_DOM_OWN_(i));
  147d12:	6811      	ldr	r1, [r2, #0]

        if (read_val & MAC_DOM_OWN_EN_MASK) {
            dom_id_used[dom_used] = i;
  147d14:	a856      	add	r0, sp, #344	; 0x158
  147d16:	eb00 0084 	add.w	r0, r0, r4, lsl #2
        if (read_val & MAC_DOM_OWN_EN_MASK) {
  147d1a:	07cd      	lsls	r5, r1, #31
            dom_used++;
  147d1c:	bf44      	itt	mi
  147d1e:	3401      	addmi	r4, #1
            dom_id_used[dom_used] = i;
  147d20:	f840 3cac 	strmi.w	r3, [r0, #-172]
    for (uint32_t i = 0; i < DOM_MAX_COUNT; i++) {
  147d24:	3301      	adds	r3, #1
  147d26:	2b10      	cmp	r3, #16
  147d28:	f102 0218 	add.w	r2, r2, #24
  147d2c:	d1f1      	bne.n	147d12 <res_assign_output+0x12>
                                      ROMC2_RANGE_COUNT, OSPI1_RANGE_COUNT, OSPI2_RANGE_COUNT, GIC2_RANGE_COUNT,
                                      GIC3_RANGE_COUNT, GIC4_RANGE_COUNT, GIC5_RANGE_COUNT, PCIE1_RANGE_COUNT,
                                      PCIE2_RANGE_COUNT, DDR_MEM_RANGE_COUNT, RESERVED2, GPU1_RANGE_COUNT,
                                      GPU2_RANGE_COUNT, MU_RANGE_COUNT, IRAM4_RANGE_COUNT, IRAM5_RANGE_COUNT
                                     };
    uint32_t ppc_slots[PPC_COUNT] = {MUX1_SLAVE_SLOT_COUNT, MUX2_SLAVE_SLOT_COUNT, MUX3_SLAVE_SLOT_COUNT, MUX4_SLAVE_SLOT_COUNT,
  147d2e:	4da1      	ldr	r5, [pc, #644]	; (147fb4 <res_assign_output+0x2b4>)
    uint32_t mpc_ranges[MPC_COUNT] = {AXI2AHB_SEC_RANGE_COUNT, ADSP1_RANGE_COUNT, DMA1_RANGE_COUNT,
  147d30:	f645 1140 	movw	r1, #22848	; 0x5940
  147d34:	226c      	movs	r2, #108	; 0x6c
  147d36:	f2c0 0115 	movt	r1, #21
  147d3a:	a83b      	add	r0, sp, #236	; 0xec
  147d3c:	f00b e918 	blx	152f70 <memcpy>
    uint32_t ppc_slots[PPC_COUNT] = {MUX1_SLAVE_SLOT_COUNT, MUX2_SLAVE_SLOT_COUNT, MUX3_SLAVE_SLOT_COUNT, MUX4_SLAVE_SLOT_COUNT,
  147d40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  147d42:	f10d 0b3c 	add.w	r11, r13, #60	; 0x3c
  147d46:	46dc      	mov	r12, r11
                                     MUX5_SLAVE_SLOT_COUNT, MUX6_SLAVE_SLOT_COUNT, MUX7_SLAVE_SLOT_COUNT, MUX8_SLAVE_SLOT_COUNT,
                                     DDR_CFG_SLAVE_SLOT_COUNT, SMMU_SLAVE_SLOT_COUNT, CE2_VIRT_SLOT_COUNT, SCR4K_SID_SLOT_COUNT,
                                     SCR4K_SSID_SLOT_COUNT, CSSYS_SLOT_COUNT
                                    };
    uint32_t ppc_range_enable[PPC_COUNT] = {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0};
  147d48:	ae1d      	add	r6, sp, #116	; 0x74
    uint32_t ppc_slots[PPC_COUNT] = {MUX1_SLAVE_SLOT_COUNT, MUX2_SLAVE_SLOT_COUNT, MUX3_SLAVE_SLOT_COUNT, MUX4_SLAVE_SLOT_COUNT,
  147d4a:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
  147d4e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  147d50:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
  147d54:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  147d56:	e8ac 000f 	stmia.w	r12!, {r0, r1, r2, r3}
  147d5a:	e895 0003 	ldmia.w	r5, {r0, r1}
    uint32_t ppc_range_enable[PPC_COUNT] = {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0};
  147d5e:	f105 0708 	add.w	r7, r5, #8
    uint32_t ppc_slots[PPC_COUNT] = {MUX1_SLAVE_SLOT_COUNT, MUX2_SLAVE_SLOT_COUNT, MUX3_SLAVE_SLOT_COUNT, MUX4_SLAVE_SLOT_COUNT,
  147d62:	e88c 0003 	stmia.w	r12, {r0, r1}
    uint32_t ppc_range_enable[PPC_COUNT] = {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0};
  147d66:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  147d68:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  147d6a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  147d6c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  147d6e:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
  147d70:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  147d72:	e897 0003 	ldmia.w	r7, {r0, r1}
    uint32_t rpc_base_addr[3] = {RPC_BASE_ADDR_CKGEN_SOC, RPC_BASE_ADDR_SEC, RPC_BASE_ADDR_SAF};
  147d76:	f105 0340 	add.w	r3, r5, #64	; 0x40
    uint32_t ppc_range_enable[PPC_COUNT] = {1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0};
  147d7a:	e886 0003 	stmia.w	r6, {r0, r1}

#ifndef ENABLE_SAF_FIREWALL
    uint32_t saf_mpc[] = {2, 4, 6, 12};
  147d7e:	354c      	adds	r5, #76	; 0x4c
    uint32_t rpc_base_addr[3] = {RPC_BASE_ADDR_CKGEN_SOC, RPC_BASE_ADDR_SEC, RPC_BASE_ADDR_SAF};
  147d80:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  147d84:	ab08      	add	r3, sp, #32
  147d86:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    uint32_t saf_mpc[] = {2, 4, 6, 12};
  147d8a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  147d8e:	ad0b      	add	r5, sp, #44	; 0x2c
  147d90:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    uint32_t saf_ppc[] = {0, 6};
#endif

    for (i = 0; i < dom_used; i++) {
  147d94:	2c00      	cmp	r4, #0
  147d96:	f000 8108 	beq.w	147faa <res_assign_output+0x2aa>
  147d9a:	f641 0204 	movw	r2, #6148	; 0x1804
  147d9e:	ab2b      	add	r3, sp, #172	; 0xac
  147da0:	f24f 4104 	movw	r1, #62468	; 0xf404
  147da4:	f2cf 02bc 	movt	r2, #61628	; 0xf0bc
  147da8:	9306      	str	r3, [sp, #24]
  147daa:	f2cf 01bd 	movt	r1, #61629	; 0xf0bd
  147dae:	9204      	str	r2, [sp, #16]
  147db0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  147db4:	9105      	str	r1, [sp, #20]
  147db6:	9307      	str	r3, [sp, #28]
  147db8:	9b06      	ldr	r3, [sp, #24]
    uint32_t dom_used = 0;
  147dba:	f44f 6680 	mov.w	r6, #1024	; 0x400
        //check master
        for (j = 0; j < MAC_MASTER_COUNT; j++) {
  147dbe:	2500      	movs	r5, #0
    uint32_t dom_used = 0;
  147dc0:	f2cf 06bc 	movt	r6, #61628	; 0xf0bc
            read_val = readl(GLB_MAC_BASE_ADDR + MAC_MDA_(j));

            if ((read_val & 0xF) == dom_id_used[i]) {
                format_output(dom_id_used[i], IP_MAC, j, 0, 0, 0);
  147dc4:	462f      	mov	r7, r5
  147dc6:	f853 4b04 	ldr.w	r4, [r3], #4
  147dca:	9306      	str	r3, [sp, #24]
  147dcc:	e002      	b.n	147dd4 <res_assign_output+0xd4>
        for (j = 0; j < MAC_MASTER_COUNT; j++) {
  147dce:	3501      	adds	r5, #1
  147dd0:	2d80      	cmp	r5, #128	; 0x80
  147dd2:	d010      	beq.n	147df6 <res_assign_output+0xf6>
            read_val = readl(GLB_MAC_BASE_ADDR + MAC_MDA_(j));
  147dd4:	6833      	ldr	r3, [r6, #0]
  147dd6:	3608      	adds	r6, #8
            if ((read_val & 0xF) == dom_id_used[i]) {
  147dd8:	f003 030f 	and.w	r3, r3, #15
  147ddc:	42a3      	cmp	r3, r4
  147dde:	d1f6      	bne.n	147dce <res_assign_output+0xce>
                format_output(dom_id_used[i], IP_MAC, j, 0, 0, 0);
  147de0:	2300      	movs	r3, #0
  147de2:	462a      	mov	r2, r5
  147de4:	9701      	str	r7, [sp, #4]
  147de6:	4619      	mov	r1, r3
  147de8:	9700      	str	r7, [sp, #0]
  147dea:	4620      	mov	r0, r4
        for (j = 0; j < MAC_MASTER_COUNT; j++) {
  147dec:	3501      	adds	r5, #1
                format_output(dom_id_used[i], IP_MAC, j, 0, 0, 0);
  147dee:	f7ff ff2f 	bl	147c50 <format_output>
        for (j = 0; j < MAC_MASTER_COUNT; j++) {
  147df2:	2d80      	cmp	r5, #128	; 0x80
  147df4:	d1ee      	bne.n	147dd4 <res_assign_output+0xd4>
            }
        }

        addr_offset = 0;
  147df6:	f04f 0a00 	mov.w	r10, #0
  147dfa:	46a0      	mov	r8, r4

        //check mpc
        for (j = 0; j < MPC_COUNT; j++) {
  147dfc:	4657      	mov	r7, r10
  147dfe:	ab0b      	add	r3, sp, #44	; 0x2c

#ifndef ENABLE_SAF_FIREWALL //bypass safety firewall check
            for (int m = 0; m < 4; m++) {
                if (j == saf_mpc[m]) {
  147e00:	f853 2b04 	ldr.w	r2, [r3], #4
  147e04:	42ba      	cmp	r2, r7
  147e06:	d01b      	beq.n	147e40 <res_assign_output+0x140>
            for (int m = 0; m < 4; m++) {
  147e08:	455b      	cmp	r3, r11
  147e0a:	d1f9      	bne.n	147e00 <res_assign_output+0x100>
                    goto NEXT_MPC;
                }
            }
#endif

            for (k = 0; k < mpc_ranges[j]; k++) {
  147e0c:	ab3b      	add	r3, sp, #236	; 0xec
  147e0e:	f853 4027 	ldr.w	r4, [r3, r7, lsl #2]
  147e12:	b1ac      	cbz	r4, 147e40 <res_assign_output+0x140>
  147e14:	2500      	movs	r5, #0
  147e16:	f1aa 6374 	sub.w	r3, r10, #255852544	; 0xf400000
  147e1a:	f5a3 367c 	sub.w	r6, r3, #258048	; 0x3f000
  147e1e:	f5a3 337a 	sub.w	r3, r3, #256000	; 0x3e800
  147e22:	9303      	str	r3, [sp, #12]
  147e24:	9b04      	ldr	r3, [sp, #16]
  147e26:	eb0a 0903 	add.w	r9, r10, r3
                read_val = readl(MPC_DOM_(k) + addr_offset);
  147e2a:	6833      	ldr	r3, [r6, #0]
  147e2c:	3638      	adds	r6, #56	; 0x38

                if ((read_val >> 4 & 0x1) && ((read_val & 0xF) == dom_id_used[i])) {
  147e2e:	06d8      	lsls	r0, r3, #27
  147e30:	f003 020f 	and.w	r2, r3, #15
  147e34:	d501      	bpl.n	147e3a <res_assign_output+0x13a>
  147e36:	4542      	cmp	r2, r8
  147e38:	d033      	beq.n	147ea2 <res_assign_output+0x1a2>
            for (k = 0; k < mpc_ranges[j]; k++) {
  147e3a:	3501      	adds	r5, #1
  147e3c:	42ac      	cmp	r4, r5
  147e3e:	d1f4      	bne.n	147e2a <res_assign_output+0x12a>
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
                }
            }

NEXT_MPC:
            addr_offset += MPC_ADDR_SIZE;
  147e40:	f50a 5a80 	add.w	r10, r10, #4096	; 0x1000
        for (j = 0; j < MPC_COUNT; j++) {
  147e44:	f5ba 3fd8 	cmp.w	r10, #110592	; 0x1b000
  147e48:	f107 0701 	add.w	r7, r7, #1
  147e4c:	d1d7      	bne.n	147dfe <res_assign_output+0xfe>
        }

        addr_offset = 0;
  147e4e:	f04f 0900 	mov.w	r9, #0
  147e52:	4644      	mov	r4, r8

        //check ppc
        for (j = 0; j < PPC_COUNT; j++) {
  147e54:	46c8      	mov	r8, r9
                    }
                }
            }

NEXT_PPC:
            addr_offset += PPC_ADDR_SIZE;
  147e56:	f509 5300 	add.w	r3, r9, #8192	; 0x2000
        for (j = 0; j < PPC_COUNT; j++) {
  147e5a:	f5b3 3fe0 	cmp.w	r3, #114688	; 0x1c000
            addr_offset += PPC_ADDR_SIZE;
  147e5e:	9303      	str	r3, [sp, #12]
        for (j = 0; j < PPC_COUNT; j++) {
  147e60:	f108 0801 	add.w	r8, r8, #1
  147e64:	d068      	beq.n	147f38 <res_assign_output+0x238>
                if (j == saf_ppc[m]) {
  147e66:	f1b8 0f06 	cmp.w	r8, #6
  147e6a:	d017      	beq.n	147e9c <res_assign_output+0x19c>
            for (k = 0; k < ppc_slots[j]; k++) {
  147e6c:	f85b 7028 	ldr.w	r7, [r11, r8, lsl #2]
  147e70:	b187      	cbz	r7, 147e94 <res_assign_output+0x194>
  147e72:	2600      	movs	r6, #0
  147e74:	f1a9 6574 	sub.w	r5, r9, #255852544	; 0xf400000
                    format_output(dom_id_used[i], IP_PPC, j, k, 0, 0);
  147e78:	46b2      	mov	r10, r6
  147e7a:	f5a5 3508 	sub.w	r5, r5, #139264	; 0x22000
                read_val = readl(PPC_DOM_(k) + addr_offset);
  147e7e:	682b      	ldr	r3, [r5, #0]
  147e80:	3538      	adds	r5, #56	; 0x38
                if ((read_val >> 4 & 0x1) && ((read_val & 0xF) == dom_id_used[i])) {
  147e82:	06d9      	lsls	r1, r3, #27
  147e84:	f003 020f 	and.w	r2, r3, #15
  147e88:	d501      	bpl.n	147e8e <res_assign_output+0x18e>
  147e8a:	42a2      	cmp	r2, r4
  147e8c:	d01d      	beq.n	147eca <res_assign_output+0x1ca>
            for (k = 0; k < ppc_slots[j]; k++) {
  147e8e:	3601      	adds	r6, #1
  147e90:	42be      	cmp	r6, r7
  147e92:	d1f4      	bne.n	147e7e <res_assign_output+0x17e>
            if (ppc_range_enable[j]) {
  147e94:	ab1d      	add	r3, sp, #116	; 0x74
  147e96:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
  147e9a:	bb0b      	cbnz	r3, 147ee0 <res_assign_output+0x1e0>
                for (k = 0; k < 16; k++) {
  147e9c:	f8dd 900c 	ldr.w	r9, [r13, #12]
  147ea0:	e7d9      	b.n	147e56 <res_assign_output+0x156>
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
  147ea2:	462b      	mov	r3, r5
  147ea4:	0128      	lsls	r0, r5, #4
                    read_val = readl(MPC_RGN_START_ADDR_(k) + addr_offset);
  147ea6:	4686      	mov	r14, r0
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
  147ea8:	463a      	mov	r2, r7
                    read_val = readl(MPC_RGN_START_ADDR_(k) + addr_offset);
  147eaa:	9803      	ldr	r0, [sp, #12]
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
  147eac:	2101      	movs	r1, #1
                    read_val = readl(MPC_RGN_START_ADDR_(k) + addr_offset);
  147eae:	f850 c00e 	ldr.w	r12, [r0, r14]
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
  147eb2:	4640      	mov	r0, r8
                    read_val = readl(MPC_RGN_END_ADDR_(k) + addr_offset);
  147eb4:	f859 e00e 	ldr.w	r14, [r9, r14]
                    addr_start = (read_val & 0x3FFFFFFF) << 12;
  147eb8:	ea4f 3c0c 	mov.w	r12, r12, lsl #12
                    addr_end = (read_val & 0x3FFFFFFF) << 12;
  147ebc:	ea4f 3e0e 	mov.w	r14, r14, lsl #12
                    format_output(dom_id_used[i], IP_MPC, j, k, addr_start, addr_end);
  147ec0:	e9cd ce00 	strd	r12, r14, [r13]
  147ec4:	f7ff fec4 	bl	147c50 <format_output>
  147ec8:	e7b7      	b.n	147e3a <res_assign_output+0x13a>
                    format_output(dom_id_used[i], IP_PPC, j, k, 0, 0);
  147eca:	f8cd a004 	str.w	r10, [r13, #4]
  147ece:	4633      	mov	r3, r6
  147ed0:	f8cd a000 	str.w	r10, [r13]
  147ed4:	4642      	mov	r2, r8
  147ed6:	2102      	movs	r1, #2
  147ed8:	4620      	mov	r0, r4
  147eda:	f7ff feb9 	bl	147c50 <format_output>
  147ede:	e7d6      	b.n	147e8e <res_assign_output+0x18e>
  147ee0:	f1a9 6a74 	sub.w	r10, r9, #255852544	; 0xf400000
  147ee4:	9a05      	ldr	r2, [sp, #20]
  147ee6:	ebc7 06c7 	rsb	r6, r7, r7, lsl #3
                for (k = 0; k < 16; k++) {
  147eea:	2500      	movs	r5, #0
  147eec:	f5aa 3308 	sub.w	r3, r10, #139264	; 0x22000
  147ef0:	4491      	add	r9, r2
  147ef2:	f5aa 3a03 	sub.w	r10, r10, #134144	; 0x20c00
  147ef6:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  147efa:	e002      	b.n	147f02 <res_assign_output+0x202>
  147efc:	3501      	adds	r5, #1
  147efe:	2d10      	cmp	r5, #16
  147f00:	d0cc      	beq.n	147e9c <res_assign_output+0x19c>
                    read_val = readl(PPC_DOM_(k + ppc_slots[j]) + addr_offset);
  147f02:	6832      	ldr	r2, [r6, #0]
  147f04:	197b      	adds	r3, r7, r5
  147f06:	3638      	adds	r6, #56	; 0x38
                    if ((read_val >> 4 & 0x1) && ((read_val & 0xF) == dom_id_used[i])) {
  147f08:	f002 010f 	and.w	r1, r2, #15
  147f0c:	06d2      	lsls	r2, r2, #27
  147f0e:	d5f5      	bpl.n	147efc <res_assign_output+0x1fc>
  147f10:	42a1      	cmp	r1, r4
  147f12:	d1f3      	bne.n	147efc <res_assign_output+0x1fc>
                        read_val = readl(PPC_RGN_START_ADDR_(k) + addr_offset);
  147f14:	f85a e035 	ldr.w	r14, [r10, r5, lsl #3]
                        format_output(dom_id_used[i], IP_PPC, j, k + ppc_slots[j], addr_start, addr_end);
  147f18:	4642      	mov	r2, r8
                        read_val = readl(PPC_RGN_END_ADDR_(k) + addr_offset);
  147f1a:	f859 0035 	ldr.w	r0, [r9, r5, lsl #3]
                        format_output(dom_id_used[i], IP_PPC, j, k + ppc_slots[j], addr_start, addr_end);
  147f1e:	2102      	movs	r1, #2
                        addr_start = (read_val & 0x3FFFFFFF) << 12;
  147f20:	ea4f 3e0e 	mov.w	r14, r14, lsl #12
                        addr_end = (read_val & 0x3FFFFFFF) << 12;
  147f24:	ea4f 3c00 	mov.w	r12, r0, lsl #12
                        format_output(dom_id_used[i], IP_PPC, j, k + ppc_slots[j], addr_start, addr_end);
  147f28:	f8cd e000 	str.w	r14, [r13]
  147f2c:	4620      	mov	r0, r4
  147f2e:	f8cd c004 	str.w	r12, [r13, #4]
  147f32:	f7ff fe8d 	bl	147c50 <format_output>
  147f36:	e7e1      	b.n	147efc <res_assign_output+0x1fc>

#ifndef ENABLE_SAF_FIREWALL //bypass safety firewall check
        rpc_count = 2;
#endif

        for (j = 0; j < rpc_count; j++) {
  147f38:	f04f 0800 	mov.w	r8, #0
                        if (0 == (read_val & 0x1)) {
                            continue;
                        }
                    }

                    format_output(dom_id_used[i], IP_RPC, j, k, 0, 0);
  147f3c:	4647      	mov	r7, r8
            for (k = 0; k < (256 * 8 - 2); k++) {
  147f3e:	2500      	movs	r5, #0
  147f40:	ab08      	add	r3, sp, #32
  147f42:	f853 6028 	ldr.w	r6, [r3, r8, lsl #2]
                        read_val = readl(rpc_base_addr[j] + RPC_DOM_PER0_(0));
  147f46:	f506 09ff 	add.w	r9, r6, #8355840	; 0x7f8000
  147f4a:	f509 49c8 	add.w	r9, r9, #25600	; 0x6400
  147f4e:	e004      	b.n	147f5a <res_assign_output+0x25a>
            for (k = 0; k < (256 * 8 - 2); k++) {
  147f50:	f240 73fe 	movw	r3, #2046	; 0x7fe
  147f54:	3501      	adds	r5, #1
  147f56:	429d      	cmp	r5, r3
  147f58:	d01c      	beq.n	147f94 <res_assign_output+0x294>
                read_val = readl(rpc_base_addr[j] + (k << 12));
  147f5a:	f8d6 c000 	ldr.w	r12, [r6]
  147f5e:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
                if (dom_id_used[i] == (read_val & 0xF)) {
  147f62:	f00c 000f 	and.w	r0, r12, #15
  147f66:	42a0      	cmp	r0, r4
  147f68:	d1f2      	bne.n	147f50 <res_assign_output+0x250>
                    format_output(dom_id_used[i], IP_RPC, j, k, 0, 0);
  147f6a:	462b      	mov	r3, r5
  147f6c:	4642      	mov	r2, r8
  147f6e:	2103      	movs	r1, #3
                    if ((dom_id_used[i] == 0) && (((read_val >> 5) & 0x3) == 0)) { //special for domain 0
  147f70:	b93c      	cbnz	r4, 147f82 <res_assign_output+0x282>
  147f72:	f01c 0f60 	tst.w	r12, #96	; 0x60
  147f76:	d104      	bne.n	147f82 <res_assign_output+0x282>
                        read_val = readl(rpc_base_addr[j] + RPC_DOM_PER0_(0));
  147f78:	f8d9 c000 	ldr.w	r12, [r9]
                        if (0 == (read_val & 0x1)) {
  147f7c:	f01c 0f01 	tst.w	r12, #1
  147f80:	d0e6      	beq.n	147f50 <res_assign_output+0x250>
                    format_output(dom_id_used[i], IP_RPC, j, k, 0, 0);
  147f82:	e9cd 7700 	strd	r7, r7, [r13]
            for (k = 0; k < (256 * 8 - 2); k++) {
  147f86:	3501      	adds	r5, #1
                    format_output(dom_id_used[i], IP_RPC, j, k, 0, 0);
  147f88:	f7ff fe62 	bl	147c50 <format_output>
            for (k = 0; k < (256 * 8 - 2); k++) {
  147f8c:	f240 73fe 	movw	r3, #2046	; 0x7fe
  147f90:	429d      	cmp	r5, r3
  147f92:	d1e2      	bne.n	147f5a <res_assign_output+0x25a>
        for (j = 0; j < rpc_count; j++) {
  147f94:	f1b8 0f00 	cmp.w	r8, #0
  147f98:	d102      	bne.n	147fa0 <res_assign_output+0x2a0>
  147f9a:	f04f 0801 	mov.w	r8, #1
  147f9e:	e7ce      	b.n	147f3e <res_assign_output+0x23e>
    for (i = 0; i < dom_used; i++) {
  147fa0:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
  147fa4:	4293      	cmp	r3, r2
  147fa6:	f47f af07 	bne.w	147db8 <res_assign_output+0xb8>
            }
        }
    }

    return 0;
}
  147faa:	2000      	movs	r0, #0
  147fac:	b057      	add	sp, #348	; 0x15c
  147fae:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  147fb2:	bf00      	nop
  147fb4:	001559ac 	.word	0x001559ac

00147fb8 <firewall_init>:

    return 0;
}

int firewall_init(uint32_t cfg_count, firewall_cfg_t* fw_cfg, bool cfg_debug)
{
  147fb8:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
  147fbc:	4688      	mov	r8, r1
  147fbe:	4691      	mov	r9, r2
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  147fc0:	4607      	mov	r7, r0
  147fc2:	b1a0      	cbz	r0, 147fee <firewall_init+0x36>
  147fc4:	460b      	mov	r3, r1
  147fc6:	eb00 06c0 	add.w	r6, r0, r0, lsl #3
  147fca:	440e      	add	r6, r1
  147fcc:	e003      	b.n	147fd6 <firewall_init+0x1e>
            writel(fw_cfg->reg_val, fw_cfg->reg_addr);
  147fce:	6005      	str	r5, [r0, #0]
        fw_cfg++;
  147fd0:	3309      	adds	r3, #9
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  147fd2:	42b3      	cmp	r3, r6
  147fd4:	d00b      	beq.n	147fee <firewall_init+0x36>
  147fd6:	6818      	ldr	r0, [r3, #0]
        if (fw_cfg->overwrite) {
  147fd8:	7a1c      	ldrb	r4, [r3, #8]
  147fda:	685d      	ldr	r5, [r3, #4]
  147fdc:	2c00      	cmp	r4, #0
  147fde:	d1f6      	bne.n	147fce <firewall_init+0x16>
            orig_val = readl(fw_cfg->reg_addr);
  147fe0:	6804      	ldr	r4, [r0, #0]
        fw_cfg++;
  147fe2:	3309      	adds	r3, #9
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  147fe4:	42b3      	cmp	r3, r6
            writel(fw_cfg->reg_val | orig_val, fw_cfg->reg_addr);
  147fe6:	ea44 0405 	orr.w	r4, r4, r5
  147fea:	6004      	str	r4, [r0, #0]
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  147fec:	d1f3      	bne.n	147fd6 <firewall_init+0x1e>
    write_cfg_to_fw(cfg_count, fw_cfg);

    default_cfg();
  147fee:	f7ff fcfd 	bl	1479ec <default_cfg>

    if (cfg_debug) {
  147ff2:	f1b9 0f00 	cmp.w	r9, #0
  147ff6:	d005      	beq.n	148004 <firewall_init+0x4c>
        //check step 1: check register with cfg value
        fw_cfg_check(cfg_count, fw_cfg);
  147ff8:	4641      	mov	r1, r8
  147ffa:	4638      	mov	r0, r7
  147ffc:	f7ff fd58 	bl	147ab0 <fw_cfg_check>

        //check step 2: output config by domain
        res_assign_output();
  148000:	f7ff fe7e 	bl	147d00 <res_assign_output>
    }

    return 0;
}
  148004:	2000      	movs	r0, #0
  148006:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
  14800a:	bf00      	nop

0014800c <firewall_enable>:

void firewall_enable(bool fw_enable)
{
    uint32_t value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  14800c:	2300      	movs	r3, #0
    uint32_t dom_per_en = fw_enable ? 1 : 0;

    value = reg_value(dom_per_en, value, MAC_GLB_CTL_DOM_PRO_EN_SHIFT, MAC_GLB_CTL_DOM_PRO_EN_MASK);

    writel(value, GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  14800e:	f44f 4160 	mov.w	r1, #57344	; 0xe000
    uint32_t value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  148012:	f2cf 03bc 	movt	r3, #61628	; 0xf0bc
{
  148016:	b410      	push	{r4}
    uint32_t value = readl(GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  148018:	681c      	ldr	r4, [r3, #0]
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  14801a:	460a      	mov	r2, r1
  14801c:	f6cf 02ff 	movt	r2, #63743	; 0xf8ff
  148020:	4060      	eors	r0, r4
  148022:	f000 0001 	and.w	r0, r0, #1
  148026:	4060      	eors	r0, r4

#ifdef ENABLE_SAF_FIREWALL
    writel(value, RPC_BASE_ADDR_SAF + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
#endif
}
  148028:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  14802c:	f2cf 61ff 	movt	r1, #63231	; 0xf6ff
    writel(value, GLB_MAC_BASE_ADDR + MAC_GLB_CTL);
  148030:	6018      	str	r0, [r3, #0]
    writel(value, RPC_BASE_ADDR_CKGEN_SOC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  148032:	6008      	str	r0, [r1, #0]
    writel(value, RPC_BASE_ADDR_SEC + RPC_MAC_GLB_CTL_OFFSET + MAC_GLB_CTL);
  148034:	6010      	str	r0, [r2, #0]
}
  148036:	4770      	bx	r14

00148038 <rid_init>:
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  148038:	b1c0      	cbz	r0, 14806c <rid_init+0x34>
  14803a:	eb00 00c0 	add.w	r0, r0, r0, lsl #3

int rid_init(uint32_t cfg_count, firewall_cfg_t * rid_cfg)
{
  14803e:	b410      	push	{r4}
  148040:	4408      	add	r0, r1
  148042:	e003      	b.n	14804c <rid_init+0x14>
            writel(fw_cfg->reg_val, fw_cfg->reg_addr);
  148044:	601c      	str	r4, [r3, #0]
        fw_cfg++;
  148046:	3109      	adds	r1, #9
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  148048:	4281      	cmp	r1, r0
  14804a:	d00b      	beq.n	148064 <rid_init+0x2c>
  14804c:	680b      	ldr	r3, [r1, #0]
        if (fw_cfg->overwrite) {
  14804e:	7a0a      	ldrb	r2, [r1, #8]
  148050:	684c      	ldr	r4, [r1, #4]
  148052:	2a00      	cmp	r2, #0
  148054:	d1f6      	bne.n	148044 <rid_init+0xc>
            orig_val = readl(fw_cfg->reg_addr);
  148056:	681a      	ldr	r2, [r3, #0]
        fw_cfg++;
  148058:	3109      	adds	r1, #9
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  14805a:	4281      	cmp	r1, r0
            writel(fw_cfg->reg_val | orig_val, fw_cfg->reg_addr);
  14805c:	ea42 0204 	orr.w	r2, r2, r4
  148060:	601a      	str	r2, [r3, #0]
    for (uint32_t i = 0; i < fw_cfg_count; i++) {
  148062:	d1f3      	bne.n	14804c <rid_init+0x14>
    return write_cfg_to_fw(cfg_count, rid_cfg);
}
  148064:	f85d 4b04 	ldr.w	r4, [r13], #4
  148068:	2000      	movs	r0, #0
  14806a:	4770      	bx	r14
  14806c:	2000      	movs	r0, #0
  14806e:	4770      	bx	r14

00148070 <fuse_program_raw>:
{
    addr_t b = soc_get_module_base(FUSE_CTRL1);

    DBG("%s: index=%d, v=0x%x\n", __FUNCTION__, index, v);

    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
  148070:	221c      	movs	r2, #28
  148072:	f2cf 0201 	movt	r2, #61441	; 0xf001
{
  148076:	b470      	push	{r4, r5, r6}
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
  148078:	6813      	ldr	r3, [r2, #0]
  14807a:	07dc      	lsls	r4, r3, #31
  14807c:	d4fc      	bmi.n	148078 <fuse_program_raw+0x8>
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  14807e:	2501      	movs	r5, #1
    do {
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  148080:	231c      	movs	r3, #28
  148082:	462c      	mov	r4, r5
  148084:	f2cf 0301 	movt	r3, #61441	; 0xf001
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  148088:	6015      	str	r5, [r2, #0]
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  14808a:	601c      	str	r4, [r3, #0]
    } while (!(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_STATUS));
  14808c:	681a      	ldr	r2, [r3, #0]
  14808e:	0752      	lsls	r2, r2, #29
  148090:	d5fb      	bpl.n	14808a <fuse_program_raw+0x1a>

    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  148092:	2200      	movs	r2, #0
  148094:	f2cf 0201 	movt	r2, #61441	; 0xf001
  148098:	6813      	ldr	r3, [r2, #0]
  14809a:	051b      	lsls	r3, r3, #20
  14809c:	d4fc      	bmi.n	148098 <fuse_program_raw+0x28>

    uint32_t ctrl = readl(b + FUSE_CTRL_OFF);
  14809e:	6813      	ldr	r3, [r2, #0]
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
  1480a0:	2408      	movs	r4, #8
  1480a2:	f2cf 0401 	movt	r4, #61441	; 0xf001

    ctrl &= ~FM_FUSE_CTRL_ADDR;
  1480a6:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  1480aa:	f043 4314 	orr.w	r3, r3, #2483027968	; 0x94000000
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
  1480ae:	6825      	ldr	r5, [r4, #0]
    ctrl |= FV_FUSE_CTRL_ADDR(index) | FV_FUSE_CTRL_PROG_KEY(FUSE_PROG_KEY);
  1480b0:	b2c0      	uxtb	r0, r0
    writel(ctrl, b + FUSE_CTRL_OFF);

    writel(v, b + PROG_DATA_OFF);
  1480b2:	2604      	movs	r6, #4
  1480b4:	f443 03b0 	orr.w	r3, r3, #5767168	; 0x580000
    ctrl |= FV_FUSE_CTRL_ADDR(index) | FV_FUSE_CTRL_PROG_KEY(FUSE_PROG_KEY);
  1480b8:	4303      	orrs	r3, r0

    trig |= BM_FUSE_TRIG_PROG;
    writel(trig, b + FUSE_TRIG_OFF);

    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  1480ba:	2000      	movs	r0, #0
    writel(v, b + PROG_DATA_OFF);
  1480bc:	f2cf 0601 	movt	r6, #61441	; 0xf001
    trig |= BM_FUSE_TRIG_PROG;
  1480c0:	f045 0504 	orr.w	r5, r5, #4
    writel(ctrl, b + FUSE_CTRL_OFF);
  1480c4:	6013      	str	r3, [r2, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  1480c6:	f2cf 0001 	movt	r0, #61441	; 0xf001
    writel(v, b + PROG_DATA_OFF);
  1480ca:	6031      	str	r1, [r6, #0]
    writel(trig, b + FUSE_TRIG_OFF);
  1480cc:	6025      	str	r5, [r4, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  1480ce:	6803      	ldr	r3, [r0, #0]
  1480d0:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  1480d4:	d1fb      	bne.n	1480ce <fuse_program_raw+0x5e>

    uint32_t res = (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_ERROR) ? -1 : 0;
  1480d6:	6800      	ldr	r0, [r0, #0]

    writel(0, b + SEMA_LOCK_OFF);
  1480d8:	221c      	movs	r2, #28
  1480da:	f2cf 0201 	movt	r2, #61441	; 0xf001

    return res;
}
  1480de:	f340 3000 	sbfx	r0, r0, #12, #1
    writel(0, b + SEMA_LOCK_OFF);
  1480e2:	6013      	str	r3, [r2, #0]
}
  1480e4:	bc70      	pop	{r4, r5, r6}
  1480e6:	4770      	bx	r14

001480e8 <fuse_sense>:
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
  1480e8:	221c      	movs	r2, #28
  1480ea:	f2cf 0201 	movt	r2, #61441	; 0xf001
{
  1480ee:	b430      	push	{r4, r5}
    while(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_LOCK);
  1480f0:	6813      	ldr	r3, [r2, #0]
  1480f2:	07dc      	lsls	r4, r3, #31
  1480f4:	d4fc      	bmi.n	1480f0 <fuse_sense+0x8>
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  1480f6:	2501      	movs	r5, #1
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  1480f8:	231c      	movs	r3, #28
  1480fa:	462c      	mov	r4, r5
  1480fc:	f2cf 0301 	movt	r3, #61441	; 0xf001
    writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  148100:	6015      	str	r5, [r2, #0]
        writel(BM_SEMA_LOCK_LOCK, b + SEMA_LOCK_OFF);
  148102:	601c      	str	r4, [r3, #0]
    } while (!(readl(b + SEMA_LOCK_OFF) & BM_SEMA_LOCK_STATUS));
  148104:	681a      	ldr	r2, [r3, #0]
  148106:	0752      	lsls	r2, r2, #29
  148108:	d5fb      	bpl.n	148102 <fuse_sense+0x1a>
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  14810a:	2200      	movs	r2, #0
  14810c:	f2cf 0201 	movt	r2, #61441	; 0xf001
  148110:	6813      	ldr	r3, [r2, #0]
  148112:	051b      	lsls	r3, r3, #20
  148114:	d4fc      	bmi.n	148110 <fuse_sense+0x28>
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
  148116:	2308      	movs	r3, #8
    ctrl |= FV_FUSE_CTRL_ADDR(index);
  148118:	b2c0      	uxtb	r0, r0
    uint32_t ctrl = readl(b + FUSE_CTRL_OFF);
  14811a:	6815      	ldr	r5, [r2, #0]
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
  14811c:	f2cf 0301 	movt	r3, #61441	; 0xf001
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  148120:	2400      	movs	r4, #0
    ctrl &= ~FM_FUSE_CTRL_ADDR;
  148122:	f025 05ff 	bic.w	r5, r5, #255	; 0xff
    ctrl |= FV_FUSE_CTRL_ADDR(index);
  148126:	4328      	orrs	r0, r5
    uint32_t trig = readl(b + FUSE_TRIG_OFF);
  148128:	681d      	ldr	r5, [r3, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  14812a:	f2cf 0401 	movt	r4, #61441	; 0xf001
    writel(ctrl, b + FUSE_CTRL_OFF);
  14812e:	6010      	str	r0, [r2, #0]
    trig |= BM_FUSE_TRIG_READ;
  148130:	f045 0501 	orr.w	r5, r5, #1
    writel(trig, b + FUSE_TRIG_OFF);
  148134:	601d      	str	r5, [r3, #0]
    while (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_BUSY);
  148136:	6823      	ldr	r3, [r4, #0]
  148138:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  14813c:	d1fb      	bne.n	148136 <fuse_sense+0x4e>
    *data = readl(b + READ_FUSE_DATA_OFF);
  14813e:	200c      	movs	r0, #12
    writel(0, b + SEMA_LOCK_OFF);
  148140:	221c      	movs	r2, #28
    *data = readl(b + READ_FUSE_DATA_OFF);
  148142:	f2cf 0001 	movt	r0, #61441	; 0xf001
    writel(0, b + SEMA_LOCK_OFF);
  148146:	f2cf 0201 	movt	r2, #61441	; 0xf001
    *data = readl(b + READ_FUSE_DATA_OFF);
  14814a:	6800      	ldr	r0, [r0, #0]
  14814c:	6008      	str	r0, [r1, #0]
    uint32_t res = (readl(b + FUSE_CTRL_OFF) & BM_FUSE_CTRL_ERROR) ? -1 : 0;
  14814e:	6820      	ldr	r0, [r4, #0]
    writel(0, b + SEMA_LOCK_OFF);
  148150:	6013      	str	r3, [r2, #0]
}
  148152:	f340 3000 	sbfx	r0, r0, #12, #1
  148156:	bc30      	pop	{r4, r5}
  148158:	4770      	bx	r14
  14815a:	bf00      	nop

0014815c <cmd_fuse_sense>:
    return fuse_program(fuse, v);
}

int cmd_fuse_sense(int argc, const cmd_args *argv)
{
    if (argc != 2) {
  14815c:	2802      	cmp	r0, #2
  14815e:	d119      	bne.n	148194 <cmd_fuse_sense+0x38>
  148160:	460b      	mov	r3, r1
{
  148162:	b530      	push	{r4, r5, r14}
        DBG("%s: Opps, invalid paras.\n", __func__);
        return -1;
    }
    uint32_t fuse = argv[1].u;
    uint32_t v = 0;
  148164:	2400      	movs	r4, #0
{
  148166:	b083      	sub	sp, #12
    uint32_t fuse = argv[1].u;
  148168:	699d      	ldr	r5, [r3, #24]
    uint32_t v = 0;
  14816a:	a902      	add	r1, sp, #8
    fuse_sense(fuse, &v);
  14816c:	4628      	mov	r0, r5
    uint32_t v = 0;
  14816e:	f841 4d04 	str.w	r4, [r1, #-4]!
    fuse_sense(fuse, &v);
  148172:	f7ff ffb9 	bl	1480e8 <fuse_sense>
    printf("%s: fuse_%d = 0x%x\n", __func__, fuse, v);
  148176:	f645 319c 	movw	r1, #23452	; 0x5b9c
  14817a:	f645 30cc 	movw	r0, #23500	; 0x5bcc
  14817e:	462a      	mov	r2, r5
  148180:	9b01      	ldr	r3, [sp, #4]
  148182:	f2c0 0115 	movt	r1, #21
  148186:	f2c0 0015 	movt	r0, #21
  14818a:	f00b ffb5 	bl	1540f8 <_printf>

    return 0;
  14818e:	4620      	mov	r0, r4
}
  148190:	b003      	add	sp, #12
  148192:	bd30      	pop	{r4, r5, r15}
        return -1;
  148194:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  148198:	4770      	bx	r14
  14819a:	bf00      	nop

0014819c <fuse_program>:
{
  14819c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14819e:	4605      	mov	r5, r0
        res = fuse_program_raw(index, v);
  1481a0:	f7ff ff66 	bl	148070 <fuse_program_raw>
        if (0 != res) break;
  1481a4:	bb98      	cbnz	r0, 14820e <fuse_program+0x72>
  1481a6:	460c      	mov	r4, r1
    if ((id >= ECC_FUSE_START) && (id <= ECC_FUSE_END)) {
  1481a8:	f1a5 0308 	sub.w	r3, r5, #8
  1481ac:	2b9f      	cmp	r3, #159	; 0x9f
  1481ae:	d828      	bhi.n	148202 <fuse_program+0x66>
    *shift = ((id - ECC_FUSE_START) % 4) * 8;
  1481b0:	f005 0503 	and.w	r5, r5, #3
    uint8_t ecc = 0;
  1481b4:	4601      	mov	r1, r0
    *wd = ECC_VAL_START + (id - ECC_FUSE_START) / 4;
  1481b6:	089b      	lsrs	r3, r3, #2
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
  1481b8:	f645 36e0 	movw	r6, #23520	; 0x5be0
    *shift = ((id - ECC_FUSE_START) % 4) * 8;
  1481bc:	00ef      	lsls	r7, r5, #3
    *wd = ECC_VAL_START + (id - ECC_FUSE_START) / 4;
  1481be:	f103 00c4 	add.w	r0, r3, #196	; 0xc4
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
  1481c2:	2501      	movs	r5, #1
    for (int i =0; i < 32; i++) {
  1481c4:	460b      	mov	r3, r1
        ecc ^= (v & (0x01u << i)) ? ecc_v[i] : 0;
  1481c6:	f2c0 0615 	movt	r6, #21
  1481ca:	fa05 f203 	lsl.w	r2, r5, r3
  1481ce:	4222      	tst	r2, r4
  1481d0:	bf18      	it	ne
  1481d2:	5d9a      	ldrbne	r2, [r3, r6]
    for (int i =0; i < 32; i++) {
  1481d4:	f103 0301 	add.w	r3, r3, #1
  1481d8:	bf18      	it	ne
  1481da:	4051      	eorne	r1, r2
  1481dc:	2b20      	cmp	r3, #32
  1481de:	d1f4      	bne.n	1481ca <fuse_program+0x2e>
            val &= ~(0xffu << ecc_shft);
  1481e0:	22ff      	movs	r2, #255	; 0xff
    return readl(base + FUSE0_OFFSET + index * 4);
  1481e2:	0083      	lsls	r3, r0, #2
  1481e4:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
  1481e8:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
            val |= ecc << ecc_shft;
  1481ec:	40b9      	lsls	r1, r7
            val &= ~(0xffu << ecc_shft);
  1481ee:	fa02 f707 	lsl.w	r7, r2, r7
    return readl(base + FUSE0_OFFSET + index * 4);
  1481f2:	681b      	ldr	r3, [r3, #0]
            val &= ~(0xffu << ecc_shft);
  1481f4:	ea23 0707 	bic.w	r7, r3, r7
            res = fuse_program_raw(ecc_wd, val);
  1481f8:	4339      	orrs	r1, r7
}
  1481fa:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            res = fuse_program_raw(ecc_wd, val);
  1481fe:	f7ff bf37 	b.w	148070 <fuse_program_raw>
               ((id > ECC_FUSE_END) && (id < RED_VAL_START1))) {
  148202:	f1a5 03a8 	sub.w	r3, r5, #168	; 0xa8
    } else if ((id < ECC_FUSE_START) ||
  148206:	2d07      	cmp	r5, #7
  148208:	bf88      	it	hi
  14820a:	2b13      	cmphi	r3, #19
  14820c:	d900      	bls.n	148210 <fuse_program+0x74>
}
  14820e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (id < ECC_FUSE_START) {
  148210:	2d07      	cmp	r5, #7
        pos = RED_VAL_START1 + id;
  148212:	bf94      	ite	ls
  148214:	f105 00bc 	addls.w	r0, r5, #188	; 0xbc
        pos = RED_VAL_START2 + id - (ECC_FUSE_END + 1);
  148218:	f105 0044 	addhi.w	r0, r5, #68	; 0x44
}
  14821c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
                res = fuse_program_raw(red_wd, v);
  148220:	f7ff bf26 	b.w	148070 <fuse_program_raw>

00148224 <cmd_fuse_program>:
{
  148224:	460b      	mov	r3, r1
    if (argc != 3) {
  148226:	2803      	cmp	r0, #3
  148228:	d103      	bne.n	148232 <cmd_fuse_program+0xe>
    return fuse_program(fuse, v);
  14822a:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
  14822c:	6998      	ldr	r0, [r3, #24]
  14822e:	f7ff bfb5 	b.w	14819c <fuse_program>
}
  148232:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  148236:	4770      	bx	r14

00148238 <arm_gic_init_percpu>:
{
#if WITH_LIB_SM
    GICREG(GICC_CTLR) = 0xb; // enable GIC0 and select fiq mode for secure
    GICREG(GICD_IGROUPR(0)) = ~0U; /* GICD_IGROUPR0 is banked */
#else
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148238:	f44f 5200 	mov.w	r2, #8192	; 0x2000
#endif
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14823c:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148240:	2001      	movs	r0, #1
  148242:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  148246:	21ff      	movs	r1, #255	; 0xff
  148248:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
  14824c:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14824e:	6019      	str	r1, [r3, #0]
}
  148250:	4770      	bx	r14
  148252:	bf00      	nop

00148254 <arm_gic_suspend_cpu>:
                   LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_FLAG_SECONDARY_CPUS);

static void arm_gic_suspend_cpu(uint level)
{
    suspend_resume_fiq(false, false);
}
  148254:	4770      	bx	r14
  148256:	bf00      	nop

00148258 <arm_gic_register_int_handler>:
    if (vector >= MAX_INT)
  148258:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
{
  14825c:	b510      	push	{r4, r14}
    if (vector >= MAX_INT)
  14825e:	d21e      	bcs.n	14829e <arm_gic_register_int_handler+0x46>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  148260:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148264:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  148266:	bf48      	it	mi
  148268:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14826a:	d515      	bpl.n	148298 <arm_gic_register_int_handler+0x40>
    if (vector < GIC_MAX_PER_CPU_INT)
  14826c:	281f      	cmp	r0, #31
        return &int_handler_table_per_cpu[vector][cpu];
  14826e:	bf93      	iteet	ls
  148270:	f642 4310 	movwls	r3, #11280	; 0x2c10
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  148274:	f1a0 0320 	subhi.w	r3, r0, #32
  148278:	f642 5010 	movwhi	r0, #11536	; 0x2d10
        return &int_handler_table_per_cpu[vector][cpu];
  14827c:	f2c0 0316 	movtls	r3, #22
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  148280:	bf8a      	itet	hi
  148282:	f2c0 0016 	movthi	r0, #22
        return &int_handler_table_per_cpu[vector][cpu];
  148286:	eb03 00c0 	addls.w	r0, r3, r0, lsl #3
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  14828a:	eb00 00c3 	addhi.w	r0, r0, r3, lsl #3
        h->arg = arg;
  14828e:	e9c0 1200 	strd	r1, r2, [r0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  148292:	b104      	cbz	r4, 148296 <arm_gic_register_int_handler+0x3e>
    __asm__ volatile("cpsie i");
  148294:	b662      	cpsie	i
}
  148296:	bd10      	pop	{r4, r15}
    __asm__ volatile("cpsid i");
  148298:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14829a:	2401      	movs	r4, #1
  14829c:	e7e6      	b.n	14826c <arm_gic_register_int_handler+0x14>
        panic("register_int_handler: vector out of range %d\n", vector);
  14829e:	f645 4138 	movw	r1, #23608	; 0x5c38
  1482a2:	4602      	mov	r2, r0
  1482a4:	4670      	mov	r0, r14
  1482a6:	f2c0 0115 	movt	r1, #21
  1482aa:	f00a fd03 	bl	152cb4 <_panic>
  1482ae:	bf00      	nop

001482b0 <arm_gic_init>:
{
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
}

void arm_gic_init(void)
{
  1482b0:	b410      	push	{r4}
    int i;

    for (i = 0; i < MAX_INT; i+= 32) {
  1482b2:	2100      	movs	r1, #0
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  1482b4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
#if !(WITH_LK_DOMU)
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  1482b8:	f44f 7280 	mov.w	r2, #256	; 0x100
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  1482bc:	114b      	asrs	r3, r1, #5
  1482be:	f503 638c 	add.w	r3, r3, #1120	; 0x460
    for (i = 0; i < MAX_INT; i+= 32) {
  1482c2:	3120      	adds	r1, #32
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  1482c4:	009b      	lsls	r3, r3, #2
  1482c6:	f103 4075 	add.w	r0, r3, #4110417920	; 0xf5000000
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  1482ca:	f2cf 5241 	movt	r2, #62785	; 0xf541
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  1482ce:	f500 0082 	add.w	r0, r0, #4259840	; 0x410000
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  1482d2:	441a      	add	r2, r3
        GICREG(GICD_ICENABLER(i / 32)) = ~0;
  1482d4:	6004      	str	r4, [r0, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
  1482d6:	f5b1 7f90 	cmp.w	r1, #288	; 0x120
        GICREG(GICD_ICPENDR(i / 32)) = ~0;
  1482da:	6014      	str	r4, [r2, #0]
    for (i = 0; i < MAX_INT; i+= 32) {
  1482dc:	d1ec      	bne.n	1482b8 <arm_gic_init+0x8>
    return (GICREG(GICD_TYPER) >> 5) & 0x7;
  1482de:	f241 0304 	movw	r3, #4100	; 0x1004
  1482e2:	f2cf 5341 	movt	r3, #62785	; 0xf541
  1482e6:	681b      	ldr	r3, [r3, #0]
#endif
    }

    if (arm_gic_max_cpu() > 0) {
  1482e8:	f013 0fe0 	tst.w	r3, #224	; 0xe0
  1482ec:	d017      	beq.n	14831e <arm_gic_init+0x6e>
  1482ee:	f645 4468 	movw	r4, #23656	; 0x5c68
  1482f2:	f04f 3001 	mov.w	r0, #16843009	; 0x1010101
        /* Set external interrupts to target cpu 0 */
        for (i = 32; i < MAX_INT; i += 4) {
  1482f6:	2120      	movs	r1, #32
  1482f8:	f2c0 0415 	movt	r4, #21
  1482fc:	2308      	movs	r3, #8
  1482fe:	e001      	b.n	148304 <arm_gic_init+0x54>
  148300:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  148304:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
  148308:	009b      	lsls	r3, r3, #2
        for (i = 32; i < MAX_INT; i += 4) {
  14830a:	3104      	adds	r1, #4
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  14830c:	f2cf 5241 	movt	r2, #62785	; 0xf541
  148310:	441a      	add	r2, r3
        for (i = 32; i < MAX_INT; i += 4) {
  148312:	f5b1 7f8a 	cmp.w	r1, #276	; 0x114
            GICREG(GICD_ITARGETSR(i / 4)) = gicd_itargetsr[i / 4];
  148316:	6010      	str	r0, [r2, #0]
  148318:	ea4f 03a1 	mov.w	r3, r1, asr #2
        for (i = 32; i < MAX_INT; i += 4) {
  14831c:	d1f0      	bne.n	148300 <arm_gic_init+0x50>
        }
    }

    GICREG(GICD_CTLR) = 1; // enable GIC0
  14831e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148322:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  148326:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICD_CTLR) = 1; // enable GIC0
  14832a:	2101      	movs	r1, #1
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14832c:	24ff      	movs	r4, #255	; 0xff
    GICREG(GICD_CTLR) = 1; // enable GIC0
  14832e:	f2cf 5041 	movt	r0, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148332:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICD_CTLR) = 1; // enable GIC0
  148336:	6001      	str	r1, [r0, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  148338:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
  14833c:	6011      	str	r1, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14833e:	601c      	str	r4, [r3, #0]
        u_int reg = i / 32;
        GICREG(GICD_IGROUPR(reg)) = gicd_igroupr[reg];
    }
#endif
    arm_gic_init_percpu(0);
}
  148340:	f85d 4b04 	ldr.w	r4, [r13], #4
  148344:	4770      	bx	r14
  148346:	bf00      	nop

00148348 <arm_gic_resume_cpu>:
{
  148348:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14834a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14834e:	061a      	lsls	r2, r3, #24
    spin_lock_saved_state_t state = 0;
  148350:	bf48      	it	mi
  148352:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148354:	d401      	bmi.n	14835a <arm_gic_resume_cpu+0x12>
    __asm__ volatile("cpsid i");
  148356:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  148358:	2401      	movs	r4, #1
    if (!(GICREG(GICD_CTLR) & 1)) {
  14835a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  14835e:	f2cf 5341 	movt	r3, #62785	; 0xf541
  148362:	681b      	ldr	r3, [r3, #0]
  148364:	07db      	lsls	r3, r3, #31
  148366:	d50e      	bpl.n	148386 <arm_gic_resume_cpu+0x3e>
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148368:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14836c:	f242 0304 	movw	r3, #8196	; 0x2004
    GICREG(GICC_CTLR) = 1; // enable GIC0
  148370:	2001      	movs	r0, #1
  148372:	f2cf 5241 	movt	r2, #62785	; 0xf541
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  148376:	21ff      	movs	r1, #255	; 0xff
  148378:	f2cf 5341 	movt	r3, #62785	; 0xf541
    GICREG(GICC_CTLR) = 1; // enable GIC0
  14837c:	6010      	str	r0, [r2, #0]
    GICREG(GICC_PMR) = 0xFF; // unmask interrupts at all priority levels
  14837e:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  148380:	b104      	cbz	r4, 148384 <arm_gic_resume_cpu+0x3c>
    __asm__ volatile("cpsie i");
  148382:	b662      	cpsie	i
}
  148384:	bd10      	pop	{r4, r15}
        arm_gic_init();
  148386:	f7ff ff93 	bl	1482b0 <arm_gic_init>
  14838a:	e7f9      	b.n	148380 <arm_gic_resume_cpu+0x38>

0014838c <arm_gic_set_priority>:
    return ret;
}


status_t arm_gic_set_priority(u_int irq, uint8_t priority)
{
  14838c:	b430      	push	{r4, r5}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14838e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148392:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  148394:	bf48      	it	mi
  148396:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148398:	d401      	bmi.n	14839e <arm_gic_set_priority+0x12>
    __asm__ volatile("cpsid i");
  14839a:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14839c:	2501      	movs	r5, #1
    regval = GICREG(GICD_IPRIORITYR(reg));
  14839e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  1483a2:	f020 0203 	bic.w	r2, r0, #3
  1483a6:	f2cf 5341 	movt	r3, #62785	; 0xf541
  1483aa:	4413      	add	r3, r2
    u_int mask = 0xff << shift;
  1483ac:	24ff      	movs	r4, #255	; 0xff
    u_int shift = 8 * (irq % 4);
  1483ae:	f000 0003 	and.w	r0, r0, #3
    regval = GICREG(GICD_IPRIORITYR(reg));
  1483b2:	681a      	ldr	r2, [r3, #0]
    u_int shift = 8 * (irq % 4);
  1483b4:	00c0      	lsls	r0, r0, #3
    u_int mask = 0xff << shift;
  1483b6:	4084      	lsls	r4, r0
    regval = (regval & ~mask) | ((uint32_t)priority << shift);
  1483b8:	fa01 f000 	lsl.w	r0, r1, r0
  1483bc:	ea22 0104 	bic.w	r1, r2, r4
  1483c0:	4308      	orrs	r0, r1
    GICREG(GICD_IPRIORITYR(reg)) = regval;
  1483c2:	6018      	str	r0, [r3, #0]
    spin_lock_saved_state_t state;

    spin_lock_save(&gicd_lock, &state, GICD_LOCK_FLAGS);
    __arm_gic_set_priority_locked(irq, priority);
    DSB;
  1483c4:	f3bf 8f4f 	dsb	sy
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1483c8:	b105      	cbz	r5, 1483cc <arm_gic_set_priority+0x40>
    __asm__ volatile("cpsie i");
  1483ca:	b662      	cpsie	i
    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return 0;
}
  1483cc:	2000      	movs	r0, #0
  1483ce:	bc30      	pop	{r4, r5}
  1483d0:	4770      	bx	r14
  1483d2:	bf00      	nop

001483d4 <arm_gic_mask_interrupt>:
    return NO_ERROR;
}

status_t arm_gic_mask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
  1483d4:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
  1483d8:	d219      	bcs.n	14840e <arm_gic_mask_interrupt+0x3a>
{
  1483da:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1483dc:	f3ef 8300 	mrs	r3, CPSR
  1483e0:	f44f 528c 	mov.w	r2, #4480	; 0x1180
  1483e4:	0944      	lsrs	r4, r0, #5
  1483e6:	2101      	movs	r1, #1
  1483e8:	f000 001f 	and.w	r0, r0, #31
  1483ec:	00a4      	lsls	r4, r4, #2
  1483ee:	f2cf 5241 	movt	r2, #62785	; 0xf541
  1483f2:	4081      	lsls	r1, r0
  1483f4:	4422      	add	r2, r4
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1483f6:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, false);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
  1483fa:	bf1c      	itt	ne
  1483fc:	2000      	movne	r0, #0
        GICREG(GICD_ICENABLER(reg)) = mask;
  1483fe:	6011      	strne	r1, [r2, #0]
  148400:	d102      	bne.n	148408 <arm_gic_mask_interrupt+0x34>
    __asm__ volatile("cpsid i");
  148402:	b672      	cpsid	i
  148404:	6011      	str	r1, [r2, #0]
    __asm__ volatile("cpsie i");
  148406:	b662      	cpsie	i
}
  148408:	f85d 4b04 	ldr.w	r4, [r13], #4
  14840c:	4770      	bx	r14
        return ERR_INVALID_ARGS;
  14840e:	f06f 0007 	mvn.w	r0, #7
}
  148412:	4770      	bx	r14

00148414 <arm_gic_unmask_interrupt>:

status_t arm_gic_unmask_interrupt(unsigned int vector)
{
    if (vector >= MAX_INT)
  148414:	f5b0 7f89 	cmp.w	r0, #274	; 0x112
  148418:	d219      	bcs.n	14844e <arm_gic_unmask_interrupt+0x3a>
{
  14841a:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14841c:	f3ef 8300 	mrs	r3, CPSR
  148420:	f44f 5288 	mov.w	r2, #4352	; 0x1100
  148424:	0944      	lsrs	r4, r0, #5
  148426:	2101      	movs	r1, #1
  148428:	f000 001f 	and.w	r0, r0, #31
  14842c:	00a4      	lsls	r4, r4, #2
  14842e:	f2cf 5241 	movt	r2, #62785	; 0xf541
  148432:	4081      	lsls	r1, r0
  148434:	4422      	add	r2, r4
  148436:	f013 0080 	ands.w	r0, r3, #128	; 0x80
    if (arm_gic_interrupt_change_allowed(vector))
        gic_set_enable(vector, true);

    spin_unlock_restore(&gicd_lock, state, GICD_LOCK_FLAGS);

    return NO_ERROR;
  14843a:	bf1c      	itt	ne
  14843c:	2000      	movne	r0, #0
        GICREG(GICD_ISENABLER(reg)) = mask;
  14843e:	6011      	strne	r1, [r2, #0]
  148440:	d102      	bne.n	148448 <arm_gic_unmask_interrupt+0x34>
    __asm__ volatile("cpsid i");
  148442:	b672      	cpsid	i
  148444:	6011      	str	r1, [r2, #0]
    __asm__ volatile("cpsie i");
  148446:	b662      	cpsie	i
}
  148448:	f85d 4b04 	ldr.w	r4, [r13], #4
  14844c:	4770      	bx	r14
        return ERR_INVALID_ARGS;
  14844e:	f06f 0007 	mvn.w	r0, #7
}
  148452:	4770      	bx	r14

00148454 <platform_irq>:

static
enum handler_return __platform_irq(struct iframe *frame)
{
    // get the current vector
    uint32_t iar = GICREG(GICC_IAR);
  148454:	f242 030c 	movw	r3, #8204	; 0x200c
    unsigned int vector = iar & 0x3ff;

    if (vector >= 0x3fe) {
  148458:	f240 31fd 	movw	r1, #1021	; 0x3fd
    uint32_t iar = GICREG(GICC_IAR);
  14845c:	f2cf 5341 	movt	r3, #62785	; 0xf541

    return ret;
}

enum handler_return platform_irq(struct iframe *frame)
{
  148460:	b510      	push	{r4, r14}
    uint32_t iar = GICREG(GICC_IAR);
  148462:	681c      	ldr	r4, [r3, #0]
    unsigned int vector = iar & 0x3ff;
  148464:	f3c4 0209 	ubfx	r2, r4, #0, #10
    if (vector >= 0x3fe) {
  148468:	428a      	cmp	r2, r1
  14846a:	d825      	bhi.n	1484b8 <platform_irq+0x64>
    THREAD_STATS_INC(interrupts);
  14846c:	f246 53c8 	movw	r3, #26056	; 0x65c8
    if (vector < GIC_MAX_PER_CPU_INT)
  148470:	2a1f      	cmp	r2, #31
    THREAD_STATS_INC(interrupts);
  148472:	f2c0 0316 	movt	r3, #22
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  148476:	bf88      	it	hi
  148478:	3a20      	subhi	r2, #32
    THREAD_STATS_INC(interrupts);
  14847a:	6a19      	ldr	r1, [r3, #32]
  14847c:	f101 0101 	add.w	r1, r1, #1
  148480:	6219      	str	r1, [r3, #32]
        return &int_handler_table_per_cpu[vector][cpu];
  148482:	bf95      	itete	ls
  148484:	f642 4310 	movwls	r3, #11280	; 0x2c10
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  148488:	f642 5310 	movwhi	r3, #11536	; 0x2d10
        return &int_handler_table_per_cpu[vector][cpu];
  14848c:	f2c0 0316 	movtls	r3, #22
        return &int_handler_table_shared[vector - GIC_MAX_PER_CPU_INT];
  148490:	f2c0 0316 	movthi	r3, #22
  148494:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    if (handler->handler)
  148498:	681a      	ldr	r2, [r3, #0]
  14849a:	b142      	cbz	r2, 1484ae <platform_irq+0x5a>
        ret = handler->handler(handler->arg);
  14849c:	6858      	ldr	r0, [r3, #4]
  14849e:	4790      	blx	r2
    GICREG(GICC_EOIR) = iar;
  1484a0:	f242 0310 	movw	r3, #8208	; 0x2010
  1484a4:	f2cf 5341 	movt	r3, #62785	; 0xf541
  1484a8:	601c      	str	r4, [r3, #0]
    else
        ret = sm_handle_irq();
#else
    ret = __platform_irq(frame);
#endif
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  1484aa:	b128      	cbz	r0, 1484b8 <platform_irq+0x64>
        ret = INT_RESCHEDULE;

	}
    return ret;
}
  1484ac:	bd10      	pop	{r4, r15}
    GICREG(GICC_EOIR) = iar;
  1484ae:	f242 0310 	movw	r3, #8208	; 0x2010
  1484b2:	f2cf 5341 	movt	r3, #62785	; 0xf541
  1484b6:	601c      	str	r4, [r3, #0]
GEN_CP15_REG_FUNCS(tpidrprw, 0, c13, c0, 4);
  1484b8:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    if (ret == INT_NO_RESCHEDULE && mp_is_cpu_idle(cpu)) {
  1484bc:	6a18      	ldr	r0, [r3, #32]
  1484be:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
  1484c2:	bd10      	pop	{r4, r15}

001484c4 <platform_fiq>:
void platform_fiq(struct iframe *frame)
{
#if WITH_LIB_SM
    sm_handle_fiq();
#else
    PANIC_UNIMPLEMENTED;
  1484c4:	f645 4228 	movw	r2, #23592	; 0x5c28
  1484c8:	f645 517c 	movw	r1, #23932	; 0x5d7c
{
  1484cc:	b508      	push	{r3, r14}
    PANIC_UNIMPLEMENTED;
  1484ce:	4670      	mov	r0, r14
  1484d0:	f2c0 0215 	movt	r2, #21
  1484d4:	f2c0 0115 	movt	r1, #21
  1484d8:	f00a fbec 	bl	152cb4 <_panic>

001484dc <sd_mu_write_rom_msg>:

    return 0;
}

static int sd_mu_write_rom_msg(struct sd_mbox_chan *mlink, u8 *data)
{
  1484dc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}

inline static u32 mb_msg_payload_size(void *data)
{
    sd_msghdr_t *msg = (sd_msghdr_t *)data;

    return msg->dat_len - MB_MSG_HDR_SZ;
  1484e0:	f8b1 b002 	ldrh.w	r11, [r1, #2]
  1484e4:	f1ab 0304 	sub.w	r3, r11, #4
    u32 len;

    ptr = mb_msg_payload_ptr(data);
    len = mb_msg_payload_size(data);

    if (len > 8) {
  1484e8:	2b08      	cmp	r3, #8
    struct sd_mbox_tx_msg *msg = mlink->msg;
  1484ea:	f8d0 a010 	ldr.w	r10, [r0, #16]
{
  1484ee:	b083      	sub	sp, #12
    if (len > 8) {
  1484f0:	d858      	bhi.n	1485a4 <sd_mu_write_rom_msg+0xc8>
    u64 val = 0ULL;
  1484f2:	f04f 0800 	mov.w	r8, #0
  1484f6:	f04f 0900 	mov.w	r9, #0
        dprintf(ALWAYS, "rom msg len %d larger than expected\n", len);
        return ERR_BAD_LEN;
    }

    for (i = 0; i < len; i++) {
  1484fa:	b323      	cbz	r3, 148546 <sd_mu_write_rom_msg+0x6a>
  1484fc:	f10b 5e00 	add.w	r14, r11, #536870912	; 0x20000000
  148500:	f1ae 0e04 	sub.w	r14, r14, #4
  148504:	2300      	movs	r3, #0
  148506:	f101 0c03 	add.w	r12, r1, #3
    u64 val = 0ULL;
  14850a:	f04f 0800 	mov.w	r8, #0
  14850e:	ea4f 0ece 	mov.w	r14, r14, lsl #3
  148512:	f04f 0900 	mov.w	r9, #0
        val |= ((u64) ptr[i] << (i * 8));
  148516:	2700      	movs	r7, #0
  148518:	f81c 6f01 	ldrb.w	r6, [r12, #1]!
  14851c:	f1c3 0220 	rsb	r2, r3, #32
  148520:	e9cd 6700 	strd	r6, r7, [r13]
  148524:	f1a3 0720 	sub.w	r7, r3, #32
  148528:	9e00      	ldr	r6, [sp, #0]
  14852a:	fa26 f202 	lsr.w	r2, r6, r2
  14852e:	fa06 f507 	lsl.w	r5, r6, r7
  148532:	4315      	orrs	r5, r2
  148534:	4632      	mov	r2, r6
  148536:	ea49 0905 	orr.w	r9, r9, r5
  14853a:	409a      	lsls	r2, r3
  14853c:	3308      	adds	r3, #8
    for (i = 0; i < len; i++) {
  14853e:	4573      	cmp	r3, r14
        val |= ((u64) ptr[i] << (i * 8));
  148540:	ea48 0802 	orr.w	r8, r8, r2
    for (i = 0; i < len; i++) {
  148544:	d1e7      	bne.n	148516 <sd_mu_write_rom_msg+0x3a>
    }

    if (msg) {
  148546:	f1ba 0f00 	cmp.w	r10, #0
  14854a:	d035      	beq.n	1485b8 <sd_mu_write_rom_msg+0xdc>
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(len, 2)) / 2)
                   | FV_TMH0_MID(msg->msg_id);
  14854c:	f8da 3004 	ldr.w	r3, [r10, #4]
        u32 reset_check;

        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  148550:	2501      	movs	r5, #1
  148552:	6944      	ldr	r4, [r0, #20]
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(len, 2)) / 2)
  148554:	f1ab 0b03 	sub.w	r11, r11, #3
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148558:	fa05 f203 	lsl.w	r2, r5, r3
        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  14855c:	fa05 f404 	lsl.w	r4, r5, r4
                   | FV_TMH0_MID(msg->msg_id);
  148560:	061b      	lsls	r3, r3, #24
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(len, 2)) / 2)
  148562:	ea43 035b 	orr.w	r3, r3, r11, lsr #1
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148566:	0312      	lsls	r2, r2, #12
        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  148568:	0424      	lsls	r4, r4, #16
  14856a:	f404 047f 	and.w	r4, r4, #16711680	; 0xff0000
  14856e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148572:	b292      	uxth	r2, r2
  148574:	4323      	orrs	r3, r4

        writel(tmh0, msg->tmh);
  148576:	f8da 4014 	ldr.w	r4, [r10, #20]
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  14857a:	4313      	orrs	r3, r2
        writel(tmh0, msg->tmh);
  14857c:	6023      	str	r3, [r4, #0]
        writel((u32)val, msg->tmh + TMH1_OFF);
  14857e:	f8c4 8004 	str.w	r8, [r4, #4]
        writel((u32)(val >> 32), msg->tmh + TMH2_OFF);
  148582:	f8c4 9008 	str.w	r9, [r4, #8]

        reset_check = readl(msg->tmh);
  148586:	6822      	ldr	r2, [r4, #0]
        if (reset_check != tmh0) {
  148588:	4293      	cmp	r3, r2
  14858a:	d108      	bne.n	14859e <sd_mu_write_rom_msg+0xc2>
        }

        /* this is to compatible with default msg,
         * for test only
         */
        memcpy((void *)msg->tx_buf, data, mlink->actual_size);
  14858c:	6982      	ldr	r2, [r0, #24]
  14858e:	f8da 001c 	ldr.w	r0, [r10, #28]
  148592:	f00a ecee 	blx	152f70 <memcpy>

        return 0;
  148596:	2000      	movs	r0, #0
    }

    return ERR_NO_MSG;
}
  148598:	b003      	add	sp, #12
  14859a:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            return ERR_NOT_READY;
  14859e:	f06f 0002 	mvn.w	r0, #2
  1485a2:	e7f9      	b.n	148598 <sd_mu_write_rom_msg+0xbc>
        dprintf(ALWAYS, "rom msg len %d larger than expected\n", len);
  1485a4:	f645 60e0 	movw	r0, #24288	; 0x5ee0
  1485a8:	4619      	mov	r1, r3
  1485aa:	f2c0 0015 	movt	r0, #21
  1485ae:	f00b fda3 	bl	1540f8 <_printf>
        return ERR_BAD_LEN;
  1485b2:	f06f 001f 	mvn.w	r0, #31
  1485b6:	e7ef      	b.n	148598 <sd_mu_write_rom_msg+0xbc>
    return ERR_NO_MSG;
  1485b8:	f06f 0003 	mvn.w	r0, #3
  1485bc:	e7ec      	b.n	148598 <sd_mu_write_rom_msg+0xbc>
  1485be:	bf00      	nop

001485c0 <sd_mu_alloc_msg>:
                                       int prefer, bool priority)
{
    int i;
    struct sd_mbox_tx_msg *msg;

    if (prefer < MB_MAX_MSGS) {
  1485c0:	2903      	cmp	r1, #3
  1485c2:	dc03      	bgt.n	1485cc <sd_mu_alloc_msg+0xc>
        msg = &mbdev->tmsg[prefer];

        if (!msg->used) {
  1485c4:	0149      	lsls	r1, r1, #5
  1485c6:	1843      	adds	r3, r0, r1
  1485c8:	7c1a      	ldrb	r2, [r3, #16]
  1485ca:	b302      	cbz	r2, 14860e <sd_mu_alloc_msg+0x4e>
{
  1485cc:	b570      	push	{r4, r5, r6, r14}
  1485ce:	4602      	mov	r2, r0
  1485d0:	4604      	mov	r4, r0
  1485d2:	2300      	movs	r3, #0
    }

    for (i = 0; i < MB_MAX_MSGS; i++) {
        msg = &mbdev->tmsg[i];

        if (!msg->used) {
  1485d4:	7c11      	ldrb	r1, [r2, #16]
  1485d6:	3220      	adds	r2, #32
  1485d8:	b1f1      	cbz	r1, 148618 <sd_mu_alloc_msg+0x58>
    for (i = 0; i < MB_MAX_MSGS; i++) {
  1485da:	3301      	adds	r3, #1
  1485dc:	2b04      	cmp	r3, #4
  1485de:	d1f9      	bne.n	1485d4 <sd_mu_alloc_msg+0x14>
            msg->used = 1;
            return msg;
        }
    }

    dprintf(0, "mu: all msg used:\n");
  1485e0:	f645 60b0 	movw	r0, #24240	; 0x5eb0
    for (i = 0; i < MB_MAX_MSGS; i++) {
        msg = &mbdev->tmsg[i];

        dprintf(0, "msg[%d]used:%d target:%d\n", i, msg->client, msg->remote);
  1485e4:	f645 66c4 	movw	r6, #24260	; 0x5ec4
    dprintf(0, "mu: all msg used:\n");
  1485e8:	f2c0 0015 	movt	r0, #21
  1485ec:	f00b fd84 	bl	1540f8 <_printf>
    for (i = 0; i < MB_MAX_MSGS; i++) {
  1485f0:	2500      	movs	r5, #0
        dprintf(0, "msg[%d]used:%d target:%d\n", i, msg->client, msg->remote);
  1485f2:	f2c0 0615 	movt	r6, #21
  1485f6:	6a23      	ldr	r3, [r4, #32]
  1485f8:	4629      	mov	r1, r5
  1485fa:	69e2      	ldr	r2, [r4, #28]
    for (i = 0; i < MB_MAX_MSGS; i++) {
  1485fc:	3501      	adds	r5, #1
        dprintf(0, "msg[%d]used:%d target:%d\n", i, msg->client, msg->remote);
  1485fe:	4630      	mov	r0, r6
  148600:	3420      	adds	r4, #32
  148602:	f00b fd79 	bl	1540f8 <_printf>
    for (i = 0; i < MB_MAX_MSGS; i++) {
  148606:	2d04      	cmp	r5, #4
  148608:	d1f5      	bne.n	1485f6 <sd_mu_alloc_msg+0x36>
  14860a:	2000      	movs	r0, #0
    }

    return NULL;
}
  14860c:	bd70      	pop	{r4, r5, r6, r15}
            msg->used = 1;
  14860e:	2201      	movs	r2, #1
        msg = &mbdev->tmsg[prefer];
  148610:	3110      	adds	r1, #16
  148612:	4408      	add	r0, r1
            msg->used = 1;
  148614:	741a      	strb	r2, [r3, #16]
}
  148616:	4770      	bx	r14
            msg->used = 1;
  148618:	2101      	movs	r1, #1
        msg = &mbdev->tmsg[i];
  14861a:	015b      	lsls	r3, r3, #5
            msg->used = 1;
  14861c:	18c2      	adds	r2, r0, r3
        msg = &mbdev->tmsg[i];
  14861e:	3310      	adds	r3, #16
            msg->used = 1;
  148620:	7411      	strb	r1, [r2, #16]
        msg = &mbdev->tmsg[i];
  148622:	4418      	add	r0, r3
}
  148624:	bd70      	pop	{r4, r5, r6, r15}
  148626:	bf00      	nop

00148628 <sd_mbox_send_data>:
    msg->used = 0;
    msg->remote = (u32) - 1;
}

int sd_mbox_send_data(struct sd_mbox_chan *mlink, u8 *data)
{
  148628:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14862a:	4604      	mov	r4, r0
  14862c:	460d      	mov	r5, r1
    struct sd_mbox_device *mbdev = mlink->mbox;
  14862e:	6a87      	ldr	r7, [r0, #40]	; 0x28
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  148630:	f3ef 8300 	mrs	r3, CPSR
  148634:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  148636:	bf48      	it	mi
  148638:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14863a:	d401      	bmi.n	148640 <sd_mbox_send_data+0x18>
    __asm__ volatile("cpsid i");
  14863c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14863e:	2601      	movs	r6, #1
    return msg->priority;
  148640:	782a      	ldrb	r2, [r5, #0]
    /*
     * for safety ROM peer load, we use msg_id 1 according to ROM spec
     */
    prefer_msg = (mlink->protocol == MB_MSG_PROTO_ROM) ? 1 : 0;

    if (!mlink->msg) {
  148642:	6923      	ldr	r3, [r4, #16]
    return msg->protocol;
  148644:	4611      	mov	r1, r2
    *lock = 1;
  148646:	2001      	movs	r0, #1
    return msg->priority;
  148648:	f3c2 12c0 	ubfx	r2, r2, #7, #1
  14864c:	60f8      	str	r0, [r7, #12]
    mlink->protocol = mb_msg_parse_packet_proto(data);
  14864e:	f001 010f 	and.w	r1, r1, #15
    return msg->dat_len;
  148652:	8868      	ldrh	r0, [r5, #2]
    mlink->priority = mb_msg_parse_packet_prio(data);
  148654:	f884 2020 	strb.w	r2, [r4, #32]
  148658:	61a0      	str	r0, [r4, #24]
    return msg->priority;
  14865a:	b2d2      	uxtb	r2, r2

inline static u32 mb_msg_parse_addr(void *data)
{
    sd_msghdr_t *msg = (sd_msghdr_t *)data;

    return msg->addr;
  14865c:	7868      	ldrb	r0, [r5, #1]
    mlink->protocol = mb_msg_parse_packet_proto(data);
  14865e:	61e1      	str	r1, [r4, #28]
  148660:	6320      	str	r0, [r4, #48]	; 0x30
    if (!mlink->msg) {
  148662:	2b00      	cmp	r3, #0
  148664:	d04e      	beq.n	148704 <sd_mbox_send_data+0xdc>
    }

    dprintf(SPEW, "mu: send_data proto: %d length: %d msg: %d\n",
            mlink->protocol, mlink->actual_size, mlink->msg->msg_id);

    if (MB_MSG_PROTO_ROM == mlink->protocol) {
  148666:	f021 0102 	bic.w	r1, r1, #2
  14866a:	2901      	cmp	r1, #1
  14866c:	d034      	beq.n	1486d8 <sd_mbox_send_data+0xb0>
    struct sd_mbox_tx_msg *msg = mlink->msg;
  14866e:	f8d4 c010 	ldr.w	r12, [r4, #16]
        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  148672:	2101      	movs	r1, #1
  148674:	e9d4 0305 	ldrd	r0, r3, [r4, #20]
                   | FV_TMH0_MID(msg->msg_id);
  148678:	f8dc 2004 	ldr.w	r2, [r12, #4]
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(mlink->actual_size, 2)) / 2)
  14867c:	440b      	add	r3, r1
        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  14867e:	fa01 f000 	lsl.w	r0, r1, r0
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148682:	4091      	lsls	r1, r2
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(mlink->actual_size, 2)) / 2)
  148684:	f3c3 034a 	ubfx	r3, r3, #1, #11
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148688:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
  14868c:	0309      	lsls	r1, r1, #12
        tmh0 |= FV_TMH0_MDP(1 << mlink->target);
  14868e:	0400      	lsls	r0, r0, #16
  148690:	f400 007f 	and.w	r0, r0, #16711680	; 0xff0000
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148694:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  148698:	b289      	uxth	r1, r1
        writel(tmh0, msg->tmh);
  14869a:	f8dc 2014 	ldr.w	r2, [r12, #20]
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  14869e:	4303      	orrs	r3, r0
  1486a0:	f8dc 001c 	ldr.w	r0, [r12, #28]
  1486a4:	430b      	orrs	r3, r1
        writel(tmh0, msg->tmh);
  1486a6:	6013      	str	r3, [r2, #0]
        writel(mlink->cl_data, msg->tmh + TMH1_OFF);
  1486a8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
  1486aa:	6051      	str	r1, [r2, #4]
        writel(mlink->dest_addr, msg->tmh + TMH2_OFF);
  1486ac:	6b21      	ldr	r1, [r4, #48]	; 0x30
  1486ae:	6091      	str	r1, [r2, #8]
        reset_check = readl(msg->tmh);
  1486b0:	6812      	ldr	r2, [r2, #0]
        if (reset_check != tmh0) {
  1486b2:	4293      	cmp	r3, r2
  1486b4:	d136      	bne.n	148724 <sd_mbox_send_data+0xfc>
        memcpy((void *)msg->tx_buf, data, mlink->actual_size);
  1486b6:	69a2      	ldr	r2, [r4, #24]
  1486b8:	4629      	mov	r1, r5
  1486ba:	f00a ec5a 	blx	152f70 <memcpy>
        ret = sd_mu_fill_tmh(mlink);
        sd_mu_write_msg(mlink, data);
    }

    if (!ret)
        sd_mu_send_msg(mlink->msg);
  1486be:	6923      	ldr	r3, [r4, #16]
    writel(readl(msg->tmc) | BM_TMC0_TMC0_MSG_SEND, msg->tmc);
  1486c0:	2500      	movs	r5, #0
  1486c2:	699a      	ldr	r2, [r3, #24]
  1486c4:	6813      	ldr	r3, [r2, #0]
  1486c6:	f043 0301 	orr.w	r3, r3, #1
  1486ca:	6013      	str	r3, [r2, #0]
    *lock = 0;
  1486cc:	2300      	movs	r3, #0
  1486ce:	60fb      	str	r3, [r7, #12]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1486d0:	b106      	cbz	r6, 1486d4 <sd_mbox_send_data+0xac>
    __asm__ volatile("cpsie i");
  1486d2:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&mbdev->msg_lock, flags);

    return ret;
}
  1486d4:	4628      	mov	r0, r5
  1486d6:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        ret = sd_mu_write_rom_msg(mlink, data);
  1486d8:	4629      	mov	r1, r5
  1486da:	4620      	mov	r0, r4
  1486dc:	f7ff fefe 	bl	1484dc <sd_mu_write_rom_msg>
    if (!ret)
  1486e0:	4605      	mov	r5, r0
  1486e2:	2800      	cmp	r0, #0
  1486e4:	d0eb      	beq.n	1486be <sd_mbox_send_data+0x96>
  1486e6:	6961      	ldr	r1, [r4, #20]
        dprintf(ALWAYS, "mu: rproc %d unreachable\n", mlink->target);
  1486e8:	f645 6094 	movw	r0, #24212	; 0x5e94
  1486ec:	f2c0 0015 	movt	r0, #21
  1486f0:	f00b fd02 	bl	1540f8 <_printf>
    msg->used = 0;
  1486f4:	2300      	movs	r3, #0
        sd_mu_free_msg(mbdev, mlink->msg);
  1486f6:	6922      	ldr	r2, [r4, #16]
    msg->remote = (u32) - 1;
  1486f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    msg->used = 0;
  1486fc:	7013      	strb	r3, [r2, #0]
    msg->remote = (u32) - 1;
  1486fe:	6111      	str	r1, [r2, #16]
        mlink->msg = NULL;
  148700:	6123      	str	r3, [r4, #16]
  148702:	e7e3      	b.n	1486cc <sd_mbox_send_data+0xa4>
        mlink->msg = sd_mu_alloc_msg(mbdev, prefer_msg, mlink->priority);
  148704:	4638      	mov	r0, r7
  148706:	f1a1 0101 	sub.w	r1, r1, #1
  14870a:	fab1 f181 	clz	r1, r1
  14870e:	0949      	lsrs	r1, r1, #5
  148710:	f7ff ff56 	bl	1485c0 <sd_mu_alloc_msg>
  148714:	6120      	str	r0, [r4, #16]
        if (!mlink->msg) {
  148716:	b160      	cbz	r0, 148732 <sd_mbox_send_data+0x10a>
        mlink->msg->remote = mlink->target;
  148718:	6962      	ldr	r2, [r4, #20]
        mlink->msg->client = mlink->cl_data;
  14871a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  14871c:	e9c0 3203 	strd	r3, r2, [r0, #12]
  148720:	69e1      	ldr	r1, [r4, #28]
  148722:	e7a0      	b.n	148666 <sd_mbox_send_data+0x3e>
        memcpy((void *)msg->tx_buf, data, mlink->actual_size);
  148724:	69a2      	ldr	r2, [r4, #24]
  148726:	4629      	mov	r1, r5
            return ERR_NOT_READY;
  148728:	f06f 0502 	mvn.w	r5, #2
        memcpy((void *)msg->tx_buf, data, mlink->actual_size);
  14872c:	f00a ec20 	blx	152f70 <memcpy>
  148730:	e7d9      	b.n	1486e6 <sd_mbox_send_data+0xbe>
    *lock = 0;
  148732:	60f8      	str	r0, [r7, #12]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  148734:	b11e      	cbz	r6, 14873e <sd_mbox_send_data+0x116>
  148736:	b662      	cpsie	i
            return ERR_NO_MSG;
  148738:	f06f 0503 	mvn.w	r5, #3
  14873c:	e7ca      	b.n	1486d4 <sd_mbox_send_data+0xac>
  14873e:	f06f 0503 	mvn.w	r5, #3
  148742:	e7c7      	b.n	1486d4 <sd_mbox_send_data+0xac>

00148744 <sd_mbox_cancel_lastsend>:

int sd_mbox_cancel_lastsend(struct sd_mbox_chan *mlink)
{
    struct sd_mbox_device *mbdev = mlink->mbox;

    if (mlink->msg) {
  148744:	6902      	ldr	r2, [r0, #16]
{
  148746:	b510      	push	{r4, r14}
    if (mlink->msg) {
  148748:	b19a      	cbz	r2, 148772 <sd_mbox_cancel_lastsend+0x2e>
    writel(readl(msg->tmc) | BM_TMC0_TMC0_MSG_CANCEL, msg->tmc);
  14874a:	6993      	ldr	r3, [r2, #24]
  14874c:	6819      	ldr	r1, [r3, #0]
  14874e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
  148752:	6019      	str	r1, [r3, #0]
    return (!!(readl(msg->tmc) & BM_TMC0_TMC0_MSG_SEND));
  148754:	681b      	ldr	r3, [r3, #0]
        sd_mu_cancel_msg(mlink->msg);
        if (sd_mu_is_msg_sending(mlink->msg))
  148756:	f013 0301 	ands.w	r3, r3, #1
  14875a:	d107      	bne.n	14876c <sd_mbox_cancel_lastsend+0x28>
    msg->remote = (u32) - 1;
  14875c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        /* MU hw trigger tmh0-reset after cancel a msg */
        /* use func sd_mu_check_reset(mlink->msg) to test */
        dprintf(INFO, "mu: lastmsg canceled\n");
        sd_mu_free_msg(mbdev, mlink->msg);
        mlink->msg = NULL;
        return 0;
  148760:	4619      	mov	r1, r3
    msg->used = 0;
  148762:	7013      	strb	r3, [r2, #0]
    msg->remote = (u32) - 1;
  148764:	6114      	str	r4, [r2, #16]
        mlink->msg = NULL;
  148766:	6103      	str	r3, [r0, #16]
    }

    dprintf(CRITICAL, "mu: sd_mbox_cancel_lastsend not be here\n");
    return ERR_NO_MSG;
}
  148768:	4608      	mov	r0, r1
  14876a:	bd10      	pop	{r4, r15}
            return ERR_BUSY;
  14876c:	f06f 0120 	mvn.w	r1, #32
  148770:	e7fa      	b.n	148768 <sd_mbox_cancel_lastsend+0x24>
    dprintf(CRITICAL, "mu: sd_mbox_cancel_lastsend not be here\n");
  148772:	f645 50e4 	movw	r0, #24036	; 0x5de4
  148776:	f2c0 0015 	movt	r0, #21
  14877a:	f00b fcbd 	bl	1540f8 <_printf>
    return ERR_NO_MSG;
  14877e:	f06f 0103 	mvn.w	r1, #3
  148782:	e7f1      	b.n	148768 <sd_mbox_cancel_lastsend+0x24>

00148784 <sd_mbox_last_tx_done>:
    mlink->is_run = false;
}

bool sd_mbox_last_tx_done(struct sd_mbox_chan *mlink)
{
    struct sd_mbox_tx_msg *msg = mlink->msg;
  148784:	6902      	ldr	r2, [r0, #16]
    return (!!(readl(msg->tmc) & BM_TMC0_TMC0_MSG_SEND));
  148786:	6993      	ldr	r3, [r2, #24]
  148788:	681b      	ldr	r3, [r3, #0]
    struct sd_mbox_device *mbdev = mlink->mbox;

    if (!sd_mu_is_msg_sending(mlink->msg)) {
  14878a:	f013 0301 	ands.w	r3, r3, #1
  14878e:	d10a      	bne.n	1487a6 <sd_mbox_last_tx_done+0x22>
{
  148790:	b410      	push	{r4}
  148792:	4601      	mov	r1, r0
    msg->remote = (u32) - 1;
  148794:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    msg->used = 0;
  148798:	7013      	strb	r3, [r2, #0]
        sd_mu_free_msg(mbdev, mlink->msg);
        mlink->msg = NULL;
        return true;
  14879a:	2001      	movs	r0, #1
    msg->remote = (u32) - 1;
  14879c:	6114      	str	r4, [r2, #16]
        mlink->msg = NULL;
  14879e:	610b      	str	r3, [r1, #16]
    }

    return false;
}
  1487a0:	f85d 4b04 	ldr.w	r4, [r13], #4
  1487a4:	4770      	bx	r14
    return false;
  1487a6:	2000      	movs	r0, #0
}
  1487a8:	4770      	bx	r14
  1487aa:	bf00      	nop

001487ac <sd_mbox_request_channel>:
struct sd_mbox_chan *sd_mbox_request_channel(u8 rproc, u32 cl_addr)
{
    struct sd_mbox_chan *mlink;
    int i;

    if (rproc >= MB_MAX_RPROC)
  1487ac:	2807      	cmp	r0, #7
  1487ae:	d82a      	bhi.n	148806 <sd_mbox_request_channel+0x5a>
        return NULL;

    /* TODO: to dynamic allocate channel to remote proc
     * currently use a simple indexing
     */
    spin_lock(&g_mb_ctl->mlink_lock);
  1487b0:	f243 42a0 	movw	r2, #13472	; 0x34a0
    for (i = 0; i < MB_MAX_CHANS; i++) {
  1487b4:	2300      	movs	r3, #0
    spin_lock(&g_mb_ctl->mlink_lock);
  1487b6:	f2c0 0216 	movt	r2, #22
{
  1487ba:	b430      	push	{r4, r5}
    spin_lock(&g_mb_ctl->mlink_lock);
  1487bc:	6815      	ldr	r5, [r2, #0]
    *lock = 1;
  1487be:	2401      	movs	r4, #1
  1487c0:	462a      	mov	r2, r5
  1487c2:	f8c5 4090 	str.w	r4, [r5, #144]	; 0x90
  1487c6:	e002      	b.n	1487ce <sd_mbox_request_channel+0x22>
    for (i = 0; i < MB_MAX_CHANS; i++) {
  1487c8:	3301      	adds	r3, #1
  1487ca:	2b10      	cmp	r3, #16
  1487cc:	d015      	beq.n	1487fa <sd_mbox_request_channel+0x4e>
        mlink = &g_mb_ctl->mlink[i];
        if (mlink->target == 0xff) {
  1487ce:	f8d2 40a8 	ldr.w	r4, [r2, #168]	; 0xa8
  1487d2:	3234      	adds	r2, #52	; 0x34
  1487d4:	2cff      	cmp	r4, #255	; 0xff
  1487d6:	d1f7      	bne.n	1487c8 <sd_mbox_request_channel+0x1c>
    *lock = 0;
  1487d8:	2400      	movs	r4, #0
        mlink = &g_mb_ctl->mlink[i];
  1487da:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  1487de:	eb03 0382 	add.w	r3, r3, r2, lsl #2
  1487e2:	009b      	lsls	r3, r3, #2
            mlink->target = rproc;
  1487e4:	18ea      	adds	r2, r5, r3
        mlink = &g_mb_ctl->mlink[i];
  1487e6:	3394      	adds	r3, #148	; 0x94
            mlink->target = rproc;
  1487e8:	f8c2 00a8 	str.w	r0, [r2, #168]	; 0xa8
        mlink = &g_mb_ctl->mlink[i];
  1487ec:	18e8      	adds	r0, r5, r3
            mlink->cl_data = cl_addr;
  1487ee:	f8c2 10c0 	str.w	r1, [r2, #192]	; 0xc0
  1487f2:	f8c5 4090 	str.w	r4, [r5, #144]	; 0x90
            return mlink;
        }
    }
    spin_unlock(&g_mb_ctl->mlink_lock);
    return NULL;
}
  1487f6:	bc30      	pop	{r4, r5}
  1487f8:	4770      	bx	r14
  1487fa:	2300      	movs	r3, #0
    return NULL;
  1487fc:	4618      	mov	r0, r3
  1487fe:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
}
  148802:	bc30      	pop	{r4, r5}
  148804:	4770      	bx	r14
        return NULL;
  148806:	2000      	movs	r0, #0
}
  148808:	4770      	bx	r14
  14880a:	bf00      	nop

0014880c <sd_mbox_free_channel>:

int sd_mbox_free_channel(struct sd_mbox_chan *mlink)
{
  14880c:	4602      	mov	r2, r0
    spin_lock(&g_mb_ctl->mlink_lock);
  14880e:	f243 43a0 	movw	r3, #13472	; 0x34a0
    *lock = 1;
  148812:	2001      	movs	r0, #1
  148814:	f2c0 0316 	movt	r3, #22
{
  148818:	b510      	push	{r4, r14}
    if (mlink->target < MB_MAX_CHANS) {
  14881a:	6951      	ldr	r1, [r2, #20]
    spin_lock(&g_mb_ctl->mlink_lock);
  14881c:	681c      	ldr	r4, [r3, #0]
  14881e:	f8c4 0090 	str.w	r0, [r4, #144]	; 0x90
    if (mlink->target < MB_MAX_CHANS) {
  148822:	290f      	cmp	r1, #15
  148824:	d807      	bhi.n	148836 <sd_mbox_free_channel+0x2a>
        mlink->target = 0xff;
        mlink->cl_data = 0;
  148826:	2300      	movs	r3, #0
        mlink->target = 0xff;
  148828:	21ff      	movs	r1, #255	; 0xff
        spin_unlock(&g_mb_ctl->mlink_lock);
        return 0;
  14882a:	4618      	mov	r0, r3
        mlink->target = 0xff;
  14882c:	6151      	str	r1, [r2, #20]
        mlink->cl_data = 0;
  14882e:	62d3      	str	r3, [r2, #44]	; 0x2c
    *lock = 0;
  148830:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
    }
    spin_unlock(&g_mb_ctl->mlink_lock);
    printf("mu: bad mchan %d: %s\n", mlink->target, mlink->chan_name);
    return -1;
}
  148834:	bd10      	pop	{r4, r15}
  148836:	2300      	movs	r3, #0
    printf("mu: bad mchan %d: %s\n", mlink->target, mlink->chan_name);
  148838:	f645 6010 	movw	r0, #24080	; 0x5e10
  14883c:	f2c0 0015 	movt	r0, #21
  148840:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  148844:	f00b fc58 	bl	1540f8 <_printf>
    return -1;
  148848:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14884c:	bd10      	pop	{r4, r15}
  14884e:	bf00      	nop

00148850 <sd_mu_echo_test>:
    return __builtin_ffs(x) - 1;
}

/* Only for unit test */
void sd_mu_echo_test(struct sd_mbox_device *mbdev, u32 rproc, u32 msg_id)
{
  148850:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  148854:	460d      	mov	r5, r1
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  148856:	eb02 0342 	add.w	r3, r2, r2, lsl #1
{
  14885a:	4690      	mov	r8, r2
    struct sd_mbox_tx_msg *msg;
    u32 from = mu_get_msg_rmh1(mbdev, rproc, msg_id);
    u32 to = mu_get_msg_rmh2(mbdev, rproc, msg_id);
    u32 len = mu_get_rx_msg_len(mbdev, rproc, msg_id);
    u32 msg_id_tx = msg_id+1;
  14885c:	1c51      	adds	r1, r2, #1
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  14885e:	6802      	ldr	r2, [r0, #0]
  148860:	eb05 0445 	add.w	r4, r5, r5, lsl #1
{
  148864:	4681      	mov	r9, r0

    if (msg_id_tx > 3)
  148866:	2904      	cmp	r1, #4
        msg_id_tx = 0;

    msg = sd_mu_alloc_msg(mbdev, msg_id_tx, 0);
  148868:	bf28      	it	cs
  14886a:	2100      	movcs	r1, #0
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  14886c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    msg = sd_mu_alloc_msg(mbdev, msg_id_tx, 0);
  148870:	2200      	movs	r2, #0
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  148872:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    return readl(rmh);
  148876:	6b1e      	ldr	r6, [r3, #48]	; 0x30
    return readl(rmh);
  148878:	6b5f      	ldr	r7, [r3, #52]	; 0x34
    return GFV_CPU0_MSG0_RMH0_CPU0_MSG0_LEN(readl(rmh)) * 2;
  14887a:	f8d3 a02c 	ldr.w	r10, [r3, #44]	; 0x2c
    msg = sd_mu_alloc_msg(mbdev, msg_id_tx, 0);
  14887e:	f7ff fe9f 	bl	1485c0 <sd_mu_alloc_msg>
    if (msg) {
  148882:	b3a8      	cbz	r0, 1488f0 <sd_mu_echo_test+0xa0>
        u32 tmh0 = FV_TMH0_TXMES_LEN((ALIGN(len, 2)) / 2)
                   | FV_TMH0_MID(msg->msg_id);
        msg->remote = rproc;

        tmh0 |= FV_TMH0_MDP(1 << rproc);
  148884:	2101      	movs	r1, #1
  148886:	4604      	mov	r4, r0
                   | FV_TMH0_MID(msg->msg_id);
  148888:	6840      	ldr	r0, [r0, #4]
    return GFV_CPU0_MSG0_RMH0_CPU0_MSG0_LEN(readl(rmh)) * 2;
  14888a:	f3ca 020a 	ubfx	r2, r10, #0, #11
        tmh0 |= FV_TMH0_MDP(1 << rproc);
  14888e:	fa01 f305 	lsl.w	r3, r1, r5
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  148892:	4081      	lsls	r1, r0
        tmh0 |= FV_TMH0_MDP(1 << rproc);
  148894:	041b      	lsls	r3, r3, #16
    return GFV_CPU0_MSG0_RMH0_CPU0_MSG0_LEN(readl(rmh)) * 2;
  148896:	0052      	lsls	r2, r2, #1
        tmh0 |= FV_TMH0_MDP(1 << rproc);
  148898:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  14889c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    addr_t rxb = mbox->reg_base + MU_RX_BUF_BASE;
  1488a0:	f8d9 c000 	ldr.w	r12, [r9]
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  1488a4:	0309      	lsls	r1, r1, #12
        msg->remote = rproc;
  1488a6:	6125      	str	r5, [r4, #16]
        tmh0 |= BM_TMH0_TXUSE_MB | FV_TMH0_MBM(1 << msg->msg_id);
  1488a8:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
  1488ac:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  1488b0:	b289      	uxth	r1, r1
  1488b2:	430b      	orrs	r3, r1
    addr_t rxb = mbox->reg_base + MU_RX_BUF_BASE;
  1488b4:	f50c 5000 	add.w	r0, r12, #8192	; 0x2000

        writel(tmh0, msg->tmh);
  1488b8:	f8d4 c014 	ldr.w	r12, [r4, #20]
    return (u8 *) rxb + MU_RX_BUF_OFF(remote_proc) +
  1488bc:	eb00 3105 	add.w	r1, r0, r5, lsl #12
        writel(tmh0, msg->tmh);
  1488c0:	f8cc 3000 	str.w	r3, [r12]
        /* use tmh1 to identify source address */
        writel(to, msg->tmh + TMH1_OFF);
        /* use tmh2 to identify destination address */
        writel(from, msg->tmh + TMH2_OFF);
        memcpy((void *)msg->tx_buf, sd_mu_get_read_ptr(mbdev, rproc, msg_id), len);
  1488c4:	eb01 2188 	add.w	r1, r1, r8, lsl #10
  1488c8:	69e0      	ldr	r0, [r4, #28]
        writel(to, msg->tmh + TMH1_OFF);
  1488ca:	f8cc 7004 	str.w	r7, [r12, #4]
        writel(from, msg->tmh + TMH2_OFF);
  1488ce:	f8cc 6008 	str.w	r6, [r12, #8]
        memcpy((void *)msg->tx_buf, sd_mu_get_read_ptr(mbdev, rproc, msg_id), len);
  1488d2:	f00a eb4e 	blx	152f70 <memcpy>
    writel(readl(msg->tmc) | BM_TMC0_TMC0_MSG_SEND, msg->tmc);
  1488d6:	69a2      	ldr	r2, [r4, #24]
  1488d8:	6813      	ldr	r3, [r2, #0]
  1488da:	f043 0301 	orr.w	r3, r3, #1
  1488de:	6013      	str	r3, [r2, #0]
    return (!!(readl(msg->tmc) & BM_TMC0_TMC0_MSG_SEND));
  1488e0:	6813      	ldr	r3, [r2, #0]
        sd_mu_send_msg(msg);

        while(sd_mu_is_msg_sending(msg));
  1488e2:	f013 0301 	ands.w	r3, r3, #1
  1488e6:	d1fb      	bne.n	1488e0 <sd_mu_echo_test+0x90>
    msg->used = 0;
  1488e8:	7023      	strb	r3, [r4, #0]
    msg->remote = (u32) - 1;
  1488ea:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  1488ee:	6122      	str	r2, [r4, #16]
        sd_mu_free_msg(mbdev, msg);
    }
    dprintf(INFO, "mu: mbox echo test done\n");
}
  1488f0:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}

001488f4 <sd_mbox_rx_interrupt>:
    }
}

enum handler_return sd_mbox_rx_interrupt(int irq, chan_rx_cb_t receive_cb)
{
    struct sd_mbox_device *mbdev = g_mb_ctl;
  1488f4:	f243 43a0 	movw	r3, #13472	; 0x34a0
  1488f8:	f2c0 0316 	movt	r3, #22
{
  1488fc:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct sd_mbox_device *mbdev = g_mb_ctl;
  148900:	f8d3 a000 	ldr.w	r10, [r3]
{
  148904:	b085      	sub	sp, #20
    unsigned int state, msg_id;
    u32 remote_proc, mmask;
    spin_lock_saved_state_t flags;

    if (!mbdev) {
  148906:	f1ba 0f00 	cmp.w	r10, #0
  14890a:	f000 8086 	beq.w	148a1a <sd_mbox_rx_interrupt+0x126>
  14890e:	460f      	mov	r7, r1
  148910:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  148912:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148916:	061b      	lsls	r3, r3, #24
  148918:	d567      	bpl.n	1489ea <sd_mbox_rx_interrupt+0xf6>
    return readl(mbox->reg_base + TMS_OFF);
  14891a:	f8da 3000 	ldr.w	r3, [r10]
    *lock = 1;
  14891e:	2101      	movs	r1, #1
  148920:	f8ca 100c 	str.w	r1, [r10, #12]
  148924:	69db      	ldr	r3, [r3, #28]
  148926:	9301      	str	r3, [sp, #4]
    }

    spin_lock_irqsave(&mbdev->msg_lock, flags);

    state = sd_mu_read_tms(mbdev);
    if (!state) {
  148928:	2b00      	cmp	r3, #0
  14892a:	f000 8098 	beq.w	148a5e <sd_mbox_rx_interrupt+0x16a>
    spin_lock_saved_state_t state = 0;
  14892e:	2300      	movs	r3, #0
  148930:	9303      	str	r3, [sp, #12]
  148932:	f04f 0900 	mov.w	r9, #0
            printf("mu: suppose not ROM msg\n");
  148936:	f645 6378 	movw	r3, #24184	; 0x5e78
  14893a:	464e      	mov	r6, r9
    writel(readl(mbox->reg_base + RMC_OFF) | (0x01UL << shift),
  14893c:	f04f 0b01 	mov.w	r11, #1
            printf("mu: suppose not ROM msg\n");
  148940:	f2c0 0315 	movt	r3, #21
  148944:	9302      	str	r3, [sp, #8]
    }

    dprintf(2, "mu: rx intr state: 0x%x\n", state);

    for (remote_proc = 0; remote_proc < MB_MAX_RPROC; remote_proc++) {
        mmask = 0xf & (state >> (4 * remote_proc));
  148946:	9b01      	ldr	r3, [sp, #4]
  148948:	fa23 f509 	lsr.w	r5, r3, r9

        while (mmask) {
  14894c:	f015 050f 	ands.w	r5, r5, #15
  148950:	d067      	beq.n	148a22 <sd_mbox_rx_interrupt+0x12e>
  148952:	0333      	lsls	r3, r6, #12
    return (u8 *) rxb + MU_RX_BUF_OFF(remote_proc) +
  148954:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  148958:	f8da c000 	ldr.w	r12, [r10]
  14895c:	eb06 0846 	add.w	r8, r6, r6, lsl #1
  148960:	9300      	str	r3, [sp, #0]
  148962:	4663      	mov	r3, r12
  148964:	ea4f 1808 	mov.w	r8, r8, lsl #4
  148968:	e00c      	b.n	148984 <sd_mbox_rx_interrupt+0x90>
            receive_cb(remote_proc, from, (void*)(long)to, len);
  14896a:	ea4f 034e 	mov.w	r3, r14, lsl #1
  14896e:	47b8      	blx	r7
  148970:	f8da 3000 	ldr.w	r3, [r10]
    writel(readl(mbox->reg_base + RMC_OFF) | (0x01UL << shift),
  148974:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    u32 shift = remote_proc * 4 + msg_id;
  148976:	444c      	add	r4, r9
    writel(readl(mbox->reg_base + RMC_OFF) | (0x01UL << shift),
  148978:	fa0b f404 	lsl.w	r4, r11, r4
  14897c:	4314      	orrs	r4, r2
  14897e:	625c      	str	r4, [r3, #36]	; 0x24
        while (mmask) {
  148980:	2d00      	cmp	r5, #0
  148982:	d04e      	beq.n	148a22 <sd_mbox_rx_interrupt+0x12e>
    return __builtin_ffs(x) - 1;
  148984:	fa95 f4a5 	rbit	r4, r5
  148988:	2d00      	cmp	r5, #0
            msg_id = ffs(mmask); /* this bit indicates msg id */
            mmask &= (mmask - 1);
  14898a:	f105 31ff 	add.w	r1, r5, #4294967295	; 0xffffffff
    return __builtin_ffs(x) - 1;
  14898e:	fab4 f484 	clz	r4, r4
            receive_cb(remote_proc, from, (void*)(long)to, len);
  148992:	4630      	mov	r0, r6
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  148994:	eb08 0203 	add.w	r2, r8, r3
    return __builtin_ffs(x) - 1;
  148998:	bf08      	it	eq
  14899a:	f04f 34ff 	moveq.w	r4, #4294967295	; 0xffffffff
            mmask &= (mmask - 1);
  14899e:	400d      	ands	r5, r1
    if (receive_cb) {
  1489a0:	2f00      	cmp	r7, #0
  1489a2:	d0e7      	beq.n	148974 <sd_mbox_rx_interrupt+0x80>
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  1489a4:	eb04 0144 	add.w	r1, r4, r4, lsl #1
        if (remote_proc == MASTER_VDSP) {
  1489a8:	2e05      	cmp	r6, #5
    addr_t rmh = mu->reg_base + CPU0_MSG0_RMH1_OFF +
  1489aa:	eb02 0281 	add.w	r2, r2, r1, lsl #2
    return readl(rmh);
  1489ae:	6b11      	ldr	r1, [r2, #48]	; 0x30
    return readl(rmh);
  1489b0:	f8d2 c034 	ldr.w	r12, [r2, #52]	; 0x34
    return GFV_CPU0_MSG0_RMH0_CPU0_MSG0_LEN(readl(rmh)) * 2;
  1489b4:	f8d2 e02c 	ldr.w	r14, [r2, #44]	; 0x2c
            receive_cb(remote_proc, from, (void*)(long)to, len);
  1489b8:	4662      	mov	r2, r12
    return GFV_CPU0_MSG0_RMH0_CPU0_MSG0_LEN(readl(rmh)) * 2;
  1489ba:	f3ce 0e0a 	ubfx	r14, r14, #0, #11
        if (remote_proc == MASTER_VDSP) {
  1489be:	d0d4      	beq.n	14896a <sd_mbox_rx_interrupt+0x76>
    return (u8 *) rxb + MU_RX_BUF_OFF(remote_proc) +
  1489c0:	9a00      	ldr	r2, [sp, #0]
            receive_cb(remote_proc, to, msghdr, msghdr->dat_len);
  1489c2:	4661      	mov	r1, r12
    return (u8 *) rxb + MU_RX_BUF_OFF(remote_proc) +
  1489c4:	4413      	add	r3, r2
        msg_id * MB_BANK_LEN;
  1489c6:	02a2      	lsls	r2, r4, #10
        if (MB_MSG_PROTO_ROM != msghdr->protocol) {
  1489c8:	f813 e002 	ldrb.w	r14, [r3, r2]
  1489cc:	f00e 0e0f 	and.w	r14, r14, #15
  1489d0:	f1be 0f01 	cmp.w	r14, #1
    return (u8 *) rxb + MU_RX_BUF_OFF(remote_proc) +
  1489d4:	4413      	add	r3, r2
            receive_cb(remote_proc, to, msghdr, msghdr->dat_len);
  1489d6:	461a      	mov	r2, r3
        if (MB_MSG_PROTO_ROM != msghdr->protocol) {
  1489d8:	d033      	beq.n	148a42 <sd_mbox_rx_interrupt+0x14e>
        if (to == MB_ADDR_ECHO_TEST) {
  1489da:	f1bc 0f04 	cmp.w	r12, #4
  1489de:	d036      	beq.n	148a4e <sd_mbox_rx_interrupt+0x15a>
            receive_cb(remote_proc, to, msghdr, msghdr->dat_len);
  1489e0:	885b      	ldrh	r3, [r3, #2]
  1489e2:	47b8      	blx	r7
  1489e4:	f8da 3000 	ldr.w	r3, [r10]
  1489e8:	e7c4      	b.n	148974 <sd_mbox_rx_interrupt+0x80>
    __asm__ volatile("cpsid i");
  1489ea:	b672      	cpsid	i
    return readl(mbox->reg_base + TMS_OFF);
  1489ec:	f8da 1000 	ldr.w	r1, [r10]
    *lock = 1;
  1489f0:	2301      	movs	r3, #1
  1489f2:	f8ca 300c 	str.w	r3, [r10, #12]
  1489f6:	69c9      	ldr	r1, [r1, #28]
  1489f8:	9101      	str	r1, [sp, #4]
    if (!state) {
  1489fa:	2900      	cmp	r1, #0
  1489fc:	d198      	bne.n	148930 <sd_mbox_rx_interrupt+0x3c>
    *lock = 0;
  1489fe:	9b01      	ldr	r3, [sp, #4]
  148a00:	f8ca 300c 	str.w	r3, [r10, #12]
    __asm__ volatile("cpsie i");
  148a04:	b662      	cpsie	i
        dprintf(ALWAYS, "%s: spurious interrupt %d\n",
  148a06:	f645 51cc 	movw	r1, #24012	; 0x5dcc
  148a0a:	f645 605c 	movw	r0, #24156	; 0x5e5c
  148a0e:	f2c0 0115 	movt	r1, #21
  148a12:	f2c0 0015 	movt	r0, #21
  148a16:	f00b fb6f 	bl	1540f8 <_printf>
        return INT_NO_RESCHEDULE;
  148a1a:	2000      	movs	r0, #0
        }
    }
    spin_unlock_irqrestore(&mbdev->msg_lock, flags);

    return INT_RESCHEDULE;
}
  148a1c:	b005      	add	sp, #20
  148a1e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (remote_proc = 0; remote_proc < MB_MAX_RPROC; remote_proc++) {
  148a22:	3601      	adds	r6, #1
  148a24:	2e08      	cmp	r6, #8
  148a26:	f109 0904 	add.w	r9, r9, #4
  148a2a:	d18c      	bne.n	148946 <sd_mbox_rx_interrupt+0x52>
  148a2c:	2300      	movs	r3, #0
    return INT_RESCHEDULE;
  148a2e:	2001      	movs	r0, #1
  148a30:	f8ca 300c 	str.w	r3, [r10, #12]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  148a34:	9b03      	ldr	r3, [sp, #12]
  148a36:	b10b      	cbz	r3, 148a3c <sd_mbox_rx_interrupt+0x148>
  148a38:	b662      	cpsie	i
  148a3a:	2001      	movs	r0, #1
}
  148a3c:	b005      	add	sp, #20
  148a3e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            printf("mu: suppose not ROM msg\n");
  148a42:	9802      	ldr	r0, [sp, #8]
  148a44:	f00b fb58 	bl	1540f8 <_printf>
  148a48:	f8da 3000 	ldr.w	r3, [r10]
  148a4c:	e792      	b.n	148974 <sd_mbox_rx_interrupt+0x80>
            sd_mu_echo_test(mbdev, remote_proc, msg_id);
  148a4e:	4622      	mov	r2, r4
  148a50:	4631      	mov	r1, r6
  148a52:	4650      	mov	r0, r10
  148a54:	f7ff fefc 	bl	148850 <sd_mu_echo_test>
  148a58:	f8da 3000 	ldr.w	r3, [r10]
  148a5c:	e78a      	b.n	148974 <sd_mbox_rx_interrupt+0x80>
    *lock = 0;
  148a5e:	f8ca 300c 	str.w	r3, [r10, #12]
  148a62:	e7d0      	b.n	148a06 <sd_mbox_rx_interrupt+0x112>

00148a64 <sd_mbox_probe>:
    writel(val, cpu_mid_reg);
    return 0;
}

int sd_mbox_probe(addr_t phyaddr)
{
  148a64:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct sd_mbox_device *mbdev;
    int i;

    if (g_mb_ctl) {
  148a68:	f243 4aa0 	movw	r10, #13472	; 0x34a0
  148a6c:	f2c0 0a16 	movt	r10, #22
  148a70:	f8da 3000 	ldr.w	r3, [r10]
  148a74:	2b00      	cmp	r3, #0
  148a76:	d14a      	bne.n	148b0e <sd_mbox_probe+0xaa>
        dprintf(INFO, "Opps, no memory\n");
        return -1;
    }
#endif

    mbdev->reg_base = (addr_t)_ioaddr(phyaddr);
  148a78:	f243 48a4 	movw	r8, #13476	; 0x34a4
        mbdev->mlink[i].msg = NULL;
        mbdev->mlink[i].priority = (i == 0) ? true : false;
        mbdev->mlink[i].protocol = 0;
        mbdev->mlink[i].target = 0xff; /* assigned during request channel */
        mbdev->mlink[i].mbox = mbdev;
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148a7c:	f645 6950 	movw	r9, #24144	; 0x5e50
    for (i = 0; i < MB_MAX_CHANS; i++) {
  148a80:	461d      	mov	r5, r3
    mbdev->reg_base = (addr_t)_ioaddr(phyaddr);
  148a82:	f2c0 0816 	movt	r8, #22
  148a86:	f108 0494 	add.w	r4, r8, #148	; 0x94
        mbdev->mlink[i].is_run = 0;
  148a8a:	461f      	mov	r7, r3
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148a8c:	f2c0 0915 	movt	r9, #21
    mbdev->curr_cpu = MASTER_SAF_PLATFORM;
  148a90:	e9c8 0300 	strd	r0, r3, [r8]
        mbdev->mlink[i].target = 0xff; /* assigned during request channel */
  148a94:	f04f 0bff 	mov.w	r11, #255	; 0xff
    *lock = SPIN_LOCK_INITIAL_VALUE;
  148a98:	f8c8 3090 	str.w	r3, [r8, #144]	; 0x90
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148a9c:	462b      	mov	r3, r5
        mbdev->mlink[i].priority = (i == 0) ? true : false;
  148a9e:	fab5 f685 	clz	r6, r5
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148aa2:	4620      	mov	r0, r4
  148aa4:	464a      	mov	r2, r9
        mbdev->mlink[i].is_run = 0;
  148aa6:	f884 7021 	strb.w	r7, [r4, #33]	; 0x21
        mbdev->mlink[i].priority = (i == 0) ? true : false;
  148aaa:	0976      	lsrs	r6, r6, #5
        mbdev->mlink[i].msg = NULL;
  148aac:	6127      	str	r7, [r4, #16]
    for (i = 0; i < MB_MAX_CHANS; i++) {
  148aae:	3501      	adds	r5, #1
        mbdev->mlink[i].protocol = 0;
  148ab0:	61e7      	str	r7, [r4, #28]
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148ab2:	2110      	movs	r1, #16
        mbdev->mlink[i].target = 0xff; /* assigned during request channel */
  148ab4:	f8c4 b014 	str.w	r11, [r4, #20]
  148ab8:	3434      	adds	r4, #52	; 0x34
        mbdev->mlink[i].mbox = mbdev;
  148aba:	f844 8c0c 	str.w	r8, [r4, #-12]
        mbdev->mlink[i].priority = (i == 0) ? true : false;
  148abe:	f804 6c14 	strb.w	r6, [r4, #-20]
        snprintf(mbdev->mlink[i].chan_name, MB_MAX_NAMES, "hwchan%d", i);
  148ac2:	f00b faa9 	bl	154018 <snprintf>
    for (i = 0; i < MB_MAX_CHANS; i++) {
  148ac6:	2d10      	cmp	r5, #16
  148ac8:	d1e8      	bne.n	148a9c <sd_mbox_probe+0x38>

    for (i = 0; i < MB_MAX_MSGS; i++) {
        mbdev->tmsg[i].used = 0;
        mbdev->tmsg[i].msg_id = i;
        mbdev->tmsg[i].client = 0;
        mbdev->tmsg[i].tmh = mbdev->reg_base + TMH0_OFF;
  148aca:	f8d8 5000 	ldr.w	r5, [r8]
  148ace:	f243 43a4 	movw	r3, #13476	; 0x34a4
    for (i = 0; i < MB_MAX_MSGS; i++) {
  148ad2:	2200      	movs	r2, #0
  148ad4:	f2c0 0316 	movt	r3, #22
  148ad8:	f105 000c 	add.w	r0, r5, #12
        mbdev->tmsg[i].used = 0;
  148adc:	4614      	mov	r4, r2
  148ade:	f505 5180 	add.w	r1, r5, #4096	; 0x1000
  148ae2:	f8c8 700c 	str.w	r7, [r8, #12]
        mbdev->tmsg[i].msg_id = i;
  148ae6:	615a      	str	r2, [r3, #20]
    for (i = 0; i < MB_MAX_MSGS; i++) {
  148ae8:	3201      	adds	r2, #1
        mbdev->tmsg[i].tmc = mbdev->reg_base + TMC0_OFF + 4 * i;
  148aea:	e9c3 5009 	strd	r5, r0, [r3, #36]	; 0x24
    for (i = 0; i < MB_MAX_MSGS; i++) {
  148aee:	2a04      	cmp	r2, #4
        mbdev->tmsg[i].tx_buf = mbdev->reg_base + MU_TX_BUF_SIZE +
  148af0:	62d9      	str	r1, [r3, #44]	; 0x2c
  148af2:	f100 0004 	add.w	r0, r0, #4
        mbdev->tmsg[i].used = 0;
  148af6:	741c      	strb	r4, [r3, #16]
  148af8:	f501 6180 	add.w	r1, r1, #1024	; 0x400
        mbdev->tmsg[i].client = 0;
  148afc:	61dc      	str	r4, [r3, #28]
  148afe:	f103 0320 	add.w	r3, r3, #32
    for (i = 0; i < MB_MAX_MSGS; i++) {
  148b02:	d1f0      	bne.n	148ae6 <sd_mbox_probe+0x82>
                          false);                 //6,need to fill all 8 cpus
    sd_mbox_config_master(mbdev, MASTER_TCU,  MASTER_TCU,
                          false);                 //7
#endif

    g_mb_ctl = mbdev;
  148b04:	f8ca 8000 	str.w	r8, [r10]

    dprintf(INFO, "mbc initialized\n");

    return 0;
}
  148b08:	2000      	movs	r0, #0
  148b0a:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        dprintf(ALWAYS, "Semidrive Mailbox already registered\n");
  148b0e:	f645 6028 	movw	r0, #24104	; 0x5e28
  148b12:	f2c0 0015 	movt	r0, #21
  148b16:	f00b faef 	bl	1540f8 <_printf>
}
  148b1a:	2000      	movs	r0, #0
  148b1c:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}

00148b20 <Port_SetPinMode>:

/* Enable / Disable the use of the function */
#if (PORT_SET_PIN_MODE_API == STD_ON)
//AUTOSAR used, zhuming
void Port_SetPinMode(const Port_PinType Pin, const Port_PinModeType Mode)
{
  148b20:	b4f0      	push	{r4, r5, r6, r7}
  148b22:	b082      	sub	sp, #8
  148b24:	ab02      	add	r3, sp, #8
    return value;
}

LOCAL_INLINE vaddr_t getIOPadAddrByPin(uint32_t pin)
{
    if (PortConf_PIN_GPIO_SAF == pin)
  148b26:	28a0      	cmp	r0, #160	; 0xa0
{
  148b28:	e903 0006 	stmdb	r3, {r1, r2}
  148b2c:	9d01      	ldr	r5, [sp, #4]
    if (PortConf_PIN_GPIO_SAF == pin)
  148b2e:	d029      	beq.n	148b84 <Port_SetPinMode+0x64>
        return (APB_IOMUXC_SAF_BASE
                + ((GPIO_SAF_PAD_OFF) << 10));

    if (pin >= PORT_PIN_CNT)
  148b30:	289b      	cmp	r0, #155	; 0x9b
  148b32:	d902      	bls.n	148b3a <Port_SetPinMode+0x1a>
}/* Port_SetPinMode */
  148b34:	b002      	add	sp, #8
  148b36:	bcf0      	pop	{r4, r5, r6, r7}
  148b38:	4770      	bx	r14
  148b3a:	f24e 4130 	movw	r1, #58416	; 0xe430
  148b3e:	0104      	lsls	r4, r0, #4
  148b40:	1823      	adds	r3, r4, r0
        return 0;

    DBG("io_pad_config_reg_offset[%d][0x%x]\n", pin,
        (x9_pins[pin].io_pad_config_reg_offset));

    if (pin < IOMUXC_SAF_PIN_NUM)
  148b42:	282f      	cmp	r0, #47	; 0x2f
  148b44:	ea4f 0383 	mov.w	r3, r3, lsl #2
  148b48:	f2c0 0115 	movt	r1, #21
  148b4c:	5ace      	ldrh	r6, [r1, r3]
  148b4e:	eb01 0203 	add.w	r2, r1, r3
  148b52:	ea4f 2686 	mov.w	r6, r6, lsl #10
  148b56:	d91e      	bls.n	148b96 <Port_SetPinMode+0x76>
    AltNum = (uint32_t)Mode.pin_mux_config & 0x00000007;
  148b58:	f005 0707 	and.w	r7, r5, #7
  148b5c:	8852      	ldrh	r2, [r2, #2]
  148b5e:	0292      	lsls	r2, r2, #10
        return (APB_IOMUXC_SAF_BASE
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
    else {
        return (APB_IOMUXC_SEC_BASE
                + ((x9_pins[pin].io_pad_config_reg_offset) << 10));
  148b60:	f1a6 6cf6 	sub.w	r12, r6, #128974848	; 0x7b00000
    if (pin < IOMUXC_SAF_PIN_NUM)
        return (APB_IOMUXC_SAF_BASE
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
    else {
        return (APB_IOMUXC_SEC_BASE
                + ((x9_pins[pin].pin_mux_config_reg_offset) << 10));
  148b64:	f1a2 62f6 	sub.w	r2, r2, #128974848	; 0x7b00000
        iomux_write(Mode.io_pad_config, IOPadAddr);
  148b68:	9e00      	ldr	r6, [sp, #0]
    uint32_t  val = 0;

    if (pin >= PORT_PIN_CNT)
        return;

    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  148b6a:	00ff      	lsls	r7, r7, #3
    writel(value, vaddr);
  148b6c:	f8cc 6000 	str.w	r6, [r12]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  148b70:	443b      	add	r3, r7
    writel(value, vaddr);
  148b72:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  148b74:	440b      	add	r3, r1
  148b76:	88db      	ldrh	r3, [r3, #6]
  148b78:	2b00      	cmp	r3, #0
  148b7a:	d0db      	beq.n	148b34 <Port_SetPinMode+0x14>
  148b7c:	029b      	lsls	r3, r3, #10
    {
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
                         ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset) << 10);
    }
    else {
        inputSourceSelAddr = APB_IOMUXC_SEC_BASE +
  148b7e:	f1a3 63f6 	sub.w	r3, r3, #128974848	; 0x7b00000
  148b82:	e024      	b.n	148bce <Port_SetPinMode+0xae>
        iomux_write(Mode.io_pad_config, IOPadAddr);
  148b84:	9a00      	ldr	r2, [sp, #0]
    writel(value, vaddr);
  148b86:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
  148b8a:	f6cf 4353 	movt	r3, #64595	; 0xfc53
  148b8e:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  148b90:	b002      	add	sp, #8
  148b92:	bcf0      	pop	{r4, r5, r6, r7}
  148b94:	4770      	bx	r14
    if (IOPadAddr)
  148b96:	f1b6 766c 	subs.w	r6, r6, #61865984	; 0x3b00000
  148b9a:	bf0f      	iteee	eq
  148b9c:	8852      	ldrheq	r2, [r2, #2]
  148b9e:	2344      	movne	r3, #68	; 0x44
        iomux_write(Mode.io_pad_config, IOPadAddr);
  148ba0:	9f00      	ldrne	r7, [sp, #0]
  148ba2:	fb03 1300 	mlane	r3, r3, r0, r1
  148ba6:	bf1c      	itt	ne
  148ba8:	885a      	ldrhne	r2, [r3, #2]
    writel(value, vaddr);
  148baa:	6037      	strne	r7, [r6, #0]
  148bac:	f005 0707 	and.w	r7, r5, #7
  148bb0:	0292      	lsls	r2, r2, #10
  148bb2:	1823      	adds	r3, r4, r0
  148bb4:	00ff      	lsls	r7, r7, #3
    if (PinMuxAddr)
  148bb6:	f1b2 726c 	subs.w	r2, r2, #61865984	; 0x3b00000
  148bba:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  148bbe:	440b      	add	r3, r1
  148bc0:	88db      	ldrh	r3, [r3, #6]
  148bc2:	d10d      	bne.n	148be0 <Port_SetPinMode+0xc0>
  148bc4:	029a      	lsls	r2, r3, #10
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  148bc6:	2b00      	cmp	r3, #0
  148bc8:	d0b4      	beq.n	148b34 <Port_SetPinMode+0x14>
        inputSourceSelAddr = APB_IOMUXC_SAF_BASE +
  148bca:	f1a2 736c 	sub.w	r3, r2, #61865984	; 0x3b00000
                         ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset) << 10);
    }

    //val = x9_pins[pin].alt_funcs[alt].sel_val & ((0x01 << x9_pins[pin].alt_funcs[alt].sel_size) - 1);
    val = x9_pins[pin].alt_funcs[alt].sel_val;
  148bce:	4420      	add	r0, r4
  148bd0:	eb07 0780 	add.w	r7, r7, r0, lsl #2
  148bd4:	4439      	add	r1, r7
  148bd6:	894a      	ldrh	r2, [r1, #10]
    writel(value, vaddr);
  148bd8:	601a      	str	r2, [r3, #0]
}/* Port_SetPinMode */
  148bda:	b002      	add	sp, #8
  148bdc:	bcf0      	pop	{r4, r5, r6, r7}
  148bde:	4770      	bx	r14
    writel(value, vaddr);
  148be0:	6015      	str	r5, [r2, #0]
    if ((x9_pins[pin].alt_funcs[alt].input_source_sel_reg_offset)  == 0) {
  148be2:	2344      	movs	r3, #68	; 0x44
  148be4:	fb03 7300 	mla	r3, r3, r0, r7
  148be8:	440b      	add	r3, r1
  148bea:	88db      	ldrh	r3, [r3, #6]
  148bec:	2b00      	cmp	r3, #0
  148bee:	d0a1      	beq.n	148b34 <Port_SetPinMode+0x14>
    if (pin < IOMUXC_SAF_PIN_NUM)
  148bf0:	282f      	cmp	r0, #47	; 0x2f
  148bf2:	ea4f 2283 	mov.w	r2, r3, lsl #10
  148bf6:	4613      	mov	r3, r2
  148bf8:	d8c1      	bhi.n	148b7e <Port_SetPinMode+0x5e>
  148bfa:	e7e6      	b.n	148bca <Port_SetPinMode+0xaa>

00148bfc <Port_SetHandle>:
    if (handle != NULL) {
  148bfc:	b1a0      	cbz	r0, 148c28 <Port_SetHandle+0x2c>
        g_port_handle.phy_addr = p_handle->phy_addr;
  148bfe:	f643 0378 	movw	r3, #14456	; 0x3878
        run_in_domain = PORT_RUN_IN_SECURE;
  148c02:	f24e 422c 	movw	r2, #58412	; 0xe42c
        g_port_handle.phy_addr = p_handle->phy_addr;
  148c06:	f2c0 0316 	movt	r3, #22
{
  148c0a:	b430      	push	{r4, r5}
        run_in_domain = PORT_RUN_IN_SECURE;
  148c0c:	2101      	movs	r1, #1
  148c0e:	f2c0 0215 	movt	r2, #21
        g_port_handle.real_idx = p_handle->real_idx;
  148c12:	e9d0 4500 	ldrd	r4, r5, [r0]
        g_port_handle.phy_addr = p_handle->phy_addr;
  148c16:	601c      	str	r4, [r3, #0]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  148c18:	e9d0 4002 	ldrd	r4, r0, [r0, #8]
        g_port_handle.dio_phy_addr = p_handle->dio_phy_addr;
  148c1c:	e9c3 5401 	strd	r5, r4, [r3, #4]
        g_port_handle.dio_real_idx = p_handle->dio_real_idx;
  148c20:	60d8      	str	r0, [r3, #12]
        run_in_domain = PORT_RUN_IN_SECURE;
  148c22:	6011      	str	r1, [r2, #0]
}
  148c24:	bc30      	pop	{r4, r5}
  148c26:	4770      	bx	r14
  148c28:	4770      	bx	r14
  148c2a:	bf00      	nop

00148c2c <rstgen_get_default_config>:
//! \return
//
//*****************************************************************************
void rstgen_get_default_config(uint32_t *global_rst_maks)
{
    if (!global_rst_maks) {
  148c2c:	b108      	cbz	r0, 148c32 <rstgen_get_default_config+0x6>
        LTRACEF("config paramenter error !!\n");
        return;
    }

    *global_rst_maks = RSTGEN_GLB_RST_SELF_RST_EN(1)
  148c2e:	2307      	movs	r3, #7
  148c30:	6003      	str	r3, [r0, #0]
                       | RSTGEN_GLB_RST_SEM_RST_EN(1)
                       | RSTGEN_GLB_RST_DBG_RST_EN(1);

    LTRACEF("rstgen_get_default_config global_rst_maks:0x%x\n", *global_rst_maks);
}
  148c32:	4770      	bx	r14

00148c34 <rstgen_init>:
//! \return Returns \b true if the wdg timer is enabled and \b false
//! if it is not.
//
//*****************************************************************************
bool rstgen_init(vaddr_t base, const uint32_t global_rst_maks)
{
  148c34:	b470      	push	{r4, r5, r6}
  148c36:	4604      	mov	r4, r0
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);

    //clear all global register
    reg_write = 0x00000000;
    writel(reg_write, base);
  148c38:	2300      	movs	r3, #0
    reg_read = readl(base);
    reg_write = reg_read | rstgen_global_cfg;
    writel(reg_write, base);

    return true;
}
  148c3a:	2001      	movs	r0, #1
    writel(reg_write, base);
  148c3c:	6023      	str	r3, [r4, #0]
    uint32_t rstgen_global_cfg = RSTGEN_GLB_RST_SELF_RST_EN(global_rst_maks)
  148c3e:	ea01 0200 	and.w	r2, r1, r0
    reg_read = readl(base);
  148c42:	6825      	ldr	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  148c44:	fa01 f300 	lsl.w	r3, r1, r0
    reg_write = reg_read & (~RSTGEN_GLB_RST_LOCK_MASK);
  148c48:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
                                 | RSTGEN_GLB_RST_SEM_RST_EN(global_rst_maks)
  148c4c:	f003 0302 	and.w	r3, r3, #2
    writel(reg_write, base);
  148c50:	6025      	str	r5, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  148c52:	008d      	lsls	r5, r1, #2
    reg_read = readl(base);
  148c54:	6826      	ldr	r6, [r4, #0]
                                 | RSTGEN_GLB_RST_DBG_RST_EN(global_rst_maks)
  148c56:	f005 0504 	and.w	r5, r5, #4
    reg_write = reg_read | rstgen_global_cfg;
  148c5a:	4332      	orrs	r2, r6
  148c5c:	4313      	orrs	r3, r2
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  148c5e:	00ca      	lsls	r2, r1, #3
    reg_write = reg_read | rstgen_global_cfg;
  148c60:	ea43 0105 	orr.w	r1, r3, r5
                                 | RSTGEN_GLB_RST_WDG1_RST_EN(global_rst_maks);
  148c64:	f002 0308 	and.w	r3, r2, #8
    reg_write = reg_read | rstgen_global_cfg;
  148c68:	4319      	orrs	r1, r3
    writel(reg_write, base);
  148c6a:	6021      	str	r1, [r4, #0]
}
  148c6c:	bc70      	pop	{r4, r5, r6}
  148c6e:	4770      	bx	r14

00148c70 <rstgen_global_rst_enable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_enable(vaddr_t base, uint32_t mask)
{
  148c70:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val |= mask;
    writel(val, global_rst_en);

    return true;
}
  148c72:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  148c74:	681a      	ldr	r2, [r3, #0]
  148c76:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  148c7a:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  148c7c:	681a      	ldr	r2, [r3, #0]
    val |= mask;
  148c7e:	4311      	orrs	r1, r2
    writel(val, global_rst_en);
  148c80:	6019      	str	r1, [r3, #0]
}
  148c82:	4770      	bx	r14

00148c84 <rstgen_global_rst_disable>:
//  bit[10:3]: watchdog reset enable
//      safe_ss:    [3] for wdt1
//      sec_ss:     [8:3] for wdt 7~2
//*****************************************************************************
bool rstgen_global_rst_disable(vaddr_t base, uint32_t mask)
{
  148c84:	4603      	mov	r3, r0
    uint32_t val = readl(global_rst_en);
    val &= ~mask;
    writel(val, global_rst_en);

    return true;
}
  148c86:	2001      	movs	r0, #1
    RMWREG32(global_rst_en, RSTGEN_GLB_RST_LOCK_SHIFT, 1, 0);
  148c88:	681a      	ldr	r2, [r3, #0]
  148c8a:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
  148c8e:	601a      	str	r2, [r3, #0]
    uint32_t val = readl(global_rst_en);
  148c90:	681a      	ldr	r2, [r3, #0]
    val &= ~mask;
  148c92:	ea22 0101 	bic.w	r1, r2, r1
    writel(val, global_rst_en);
  148c96:	6019      	str	r1, [r3, #0]
}
  148c98:	4770      	bx	r14
  148c9a:	bf00      	nop

00148c9c <rstgen_sw_self_rst>:
// RSTGEN_SEC: ap.self_rst_trig reset the AP domain (sec & ap)
//
//*****************************************************************************
bool rstgen_sw_self_rst(vaddr_t base, bool release)
{
    vaddr_t sw_self_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_SELF_RST_OFF);
  148c9c:	f500 3288 	add.w	r2, r0, #69632	; 0x11000

    /* Configure rst bit. */
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  148ca0:	2001      	movs	r0, #1
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  148ca2:	6813      	ldr	r3, [r2, #0]
  148ca4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  148ca8:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_self_rst, RSTGEN_SELF_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  148caa:	6813      	ldr	r3, [r2, #0]
  148cac:	f023 0301 	bic.w	r3, r3, #1
  148cb0:	4319      	orrs	r1, r3
  148cb2:	6011      	str	r1, [r2, #0]
}
  148cb4:	4770      	bx	r14
  148cb6:	bf00      	nop

00148cb8 <rstgen_sw_oth_rst>:
// RSTGEN_RTC and RSTGEN_SEC: oth reset has no effect
//
//*****************************************************************************
bool rstgen_sw_oth_rst(vaddr_t base, bool release)
{
    vaddr_t sw_oth_rst = base + SOC_RSTGEN_REG_MAP(RSTGEN_SW_OTH_RST_OFF);
  148cb8:	f500 3290 	add.w	r2, r0, #73728	; 0x12000

    /* Configure rst bit. */
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);

    return true;
}
  148cbc:	2001      	movs	r0, #1
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_LOCK_SHIFT, 1, 0);
  148cbe:	6813      	ldr	r3, [r2, #0]
  148cc0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  148cc4:	6013      	str	r3, [r2, #0]
    RMWREG32(sw_oth_rst, RSTGEN_OTH_RST_SW_GLB_RST_SHIFT, 1, (uint32_t)release);
  148cc6:	6813      	ldr	r3, [r2, #0]
  148cc8:	f023 0301 	bic.w	r3, r3, #1
  148ccc:	4319      	orrs	r1, r3
  148cce:	6011      	str	r1, [r2, #0]
}
  148cd0:	4770      	bx	r14
  148cd2:	bf00      	nop

00148cd4 <rstgen_get_rst_sta>:
uint32_t rstgen_get_rst_sta(vaddr_t base)
{
    vaddr_t rst_sta_addr;
    uint32_t rstgen_rst_sta = 0;

    rst_sta_addr = base + SOC_RSTGEN_REG_MAP(RSTGEN_RST_STA_OFF);
  148cd4:	f500 3098 	add.w	r0, r0, #77824	; 0x13000

    rstgen_rst_sta = readl(rst_sta_addr);
  148cd8:	6800      	ldr	r0, [r0, #0]
    LTRACEF("rstgen_get_rst_sta rst_sta:0x%x\n", rstgen_rst_sta);
    return rstgen_rst_sta;
}
  148cda:	4770      	bx	r14

00148cdc <rstgen_iso_enable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_enable(vaddr_t base, uint32_t iso_idx)
{
  148cdc:	4603      	mov	r3, r0
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  148cde:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_enable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);

    return true;
}
  148ce0:	2001      	movs	r0, #1
    writel(~RSTGEN_ISO_EN_B_MASK, iso_addr);
  148ce2:	f06f 0201 	mvn.w	r2, #1
  148ce6:	50ca      	str	r2, [r1, r3]
}
  148ce8:	4770      	bx	r14
  148cea:	bf00      	nop

00148cec <rstgen_iso_status>:
    uint32_t iso_slice_idx = 0;
    vaddr_t iso_addr;

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  148cec:	0309      	lsls	r1, r1, #12
    LTRACEF("rstgen_iso_status is ok iso_slice_idx:%d\n", iso_slice_idx);
    return readl(iso_addr) & RSTGEN_ISO_EN_B_MASK;
  148cee:	5808      	ldr	r0, [r1, r0]
}
  148cf0:	f000 0001 	and.w	r0, r0, #1
  148cf4:	4770      	bx	r14
  148cf6:	bf00      	nop

00148cf8 <rstgen_iso_disable>:
//!
//! \return true is success else return false
//
//*****************************************************************************
bool rstgen_iso_disable(vaddr_t base, uint32_t iso_idx)
{
  148cf8:	4602      	mov	r2, r0

    iso_slice_idx = iso_idx - (ISO_EN / 4);

    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
    LTRACEF("rstgen_iso_disable is ok iso_slice_idx:%d\n", iso_slice_idx);
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  148cfa:	2301      	movs	r3, #1

    return true;
}
  148cfc:	4618      	mov	r0, r3
    iso_addr = base + SOC_RSTGEN_REG_MAP(ISO_EN + 0x04 * iso_slice_idx);
  148cfe:	0309      	lsls	r1, r1, #12
    writel(RSTGEN_ISO_EN_B_MASK, iso_addr);
  148d00:	508b      	str	r3, [r1, r2]
}
  148d02:	4770      	bx	r14

00148d04 <rstgen_core_reset>:
// sure there's no active bus transaction on the core.
//
//*****************************************************************************
bool rstgen_core_reset(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  148d04:	0849      	lsrs	r1, r1, #1
{
  148d06:	b430      	push	{r4, r5}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  148d08:	034c      	lsls	r4, r1, #13
  148d0a:	f5a4 5480 	sub.w	r4, r4, #4096	; 0x1000
  148d0e:	1825      	adds	r5, r4, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  148d10:	5823      	ldr	r3, [r4, r0]
  148d12:	2b00      	cmp	r3, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  148d14:	bfb8      	it	lt
  148d16:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  148d18:	db17      	blt.n	148d4a <rstgen_core_reset+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  148d1a:	0349      	lsls	r1, r1, #13
  148d1c:	180b      	adds	r3, r1, r0
    }

    /* Release STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, 1);
  148d1e:	580a      	ldr	r2, [r1, r0]
  148d20:	f042 0201 	orr.w	r2, r2, #1
  148d24:	500a      	str	r2, [r1, r0]
    while (!(readl(core_sw_rst) &
  148d26:	681a      	ldr	r2, [r3, #0]
  148d28:	0092      	lsls	r2, r2, #2
  148d2a:	d5fc      	bpl.n	148d26 <rstgen_core_reset+0x22>
                 RSTGEN_CORE_SW_RST_STATIC_RST_B_STA_MASK));

    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  148d2c:	5822      	ldr	r2, [r4, r0]
  148d2e:	f042 0201 	orr.w	r2, r2, #1
  148d32:	5022      	str	r2, [r4, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  148d34:	682a      	ldr	r2, [r5, #0]
  148d36:	0054      	lsls	r4, r2, #1
  148d38:	d5fc      	bpl.n	148d34 <rstgen_core_reset+0x30>
    /* Trigger auto-clear reset. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_AUTO_CLR_SHIFT, 1, 1);
  148d3a:	580a      	ldr	r2, [r1, r0]
  148d3c:	f042 0202 	orr.w	r2, r2, #2
  148d40:	500a      	str	r2, [r1, r0]

    /* Polling reset status */
    while (!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK));
  148d42:	681a      	ldr	r2, [r3, #0]
  148d44:	0052      	lsls	r2, r2, #1
  148d46:	d5fc      	bpl.n	148d42 <rstgen_core_reset+0x3e>

    return true;
  148d48:	2001      	movs	r0, #1
}
  148d4a:	bc30      	pop	{r4, r5}
  148d4c:	4770      	bx	r14
  148d4e:	bf00      	nop

00148d50 <rstgen_core_ctl>:
//
//*****************************************************************************
bool rstgen_core_ctl(vaddr_t base, uint32_t core_idx,
                               bool release)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  148d50:	0849      	lsrs	r1, r1, #1
{
  148d52:	b470      	push	{r4, r5, r6}
    vaddr_t core_rst_en = base + SOC_RSTGEN_REG_MAP(
  148d54:	034b      	lsls	r3, r1, #13
  148d56:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
  148d5a:	181c      	adds	r4, r3, r0
                              RSTGEN_CORE_RST_EN_OFF(core_slice));
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
                              RSTGEN_CORE_SW_RST_OFF(core_slice));

    /* Check the reset lock bit */
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  148d5c:	581d      	ldr	r5, [r3, r0]
  148d5e:	2d00      	cmp	r5, #0
    {
        LTRACEF("core_slice:%d has been locked\n", core_slice);
        return false;
  148d60:	bfb8      	it	lt
  148d62:	2000      	movlt	r0, #0
    if ((readl(core_rst_en) & RSTGEN_CORE_RST_RST_LOCK_MASK))
  148d64:	db17      	blt.n	148d96 <rstgen_core_ctl+0x46>
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  148d66:	0349      	lsls	r1, r1, #13
  148d68:	180d      	adds	r5, r1, r0
    }
    /* Check core SW reset status */
    if (release && (readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  148d6a:	580e      	ldr	r6, [r1, r0]
  148d6c:	b1aa      	cbz	r2, 148d9a <rstgen_core_ctl+0x4a>
  148d6e:	0076      	lsls	r6, r6, #1
  148d70:	d410      	bmi.n	148d94 <rstgen_core_ctl+0x44>
        return true;
    }

    uint32_t sw_rst = release?1:0;
    /* Enable SW core reset. */
    RMWREG32(core_rst_en, RSTGEN_CORE_RST_SW_RST_EN_SHIFT, 1, 1);
  148d72:	581e      	ldr	r6, [r3, r0]
  148d74:	f046 0601 	orr.w	r6, r6, #1
  148d78:	501e      	str	r6, [r3, r0]

    while (!(readl(core_rst_en) & RSTGEN_CORE_RST_SW_RST_EN_STA_MASK));
  148d7a:	6823      	ldr	r3, [r4, #0]
  148d7c:	005b      	lsls	r3, r3, #1
  148d7e:	d5fc      	bpl.n	148d7a <rstgen_core_ctl+0x2a>

    /* STATIC_RST_B. */
    RMWREG32(core_sw_rst, RSTGEN_CORE_SW_RST_STATIC_RST_SHIFT, 1, sw_rst);
  148d80:	580b      	ldr	r3, [r1, r0]
  148d82:	f023 0301 	bic.w	r3, r3, #1
  148d86:	4313      	orrs	r3, r2
  148d88:	500b      	str	r3, [r1, r0]

    /* Wait reset done. */
    while (sw_rst != (readl(core_sw_rst)
  148d8a:	682b      	ldr	r3, [r5, #0]
                            & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK)>>RSTGEN_CORE_SW_RST_CORE_RST_STA_SHIFT);
  148d8c:	f3c3 7380 	ubfx	r3, r3, #30, #1
    while (sw_rst != (readl(core_sw_rst)
  148d90:	4293      	cmp	r3, r2
  148d92:	d1fa      	bne.n	148d8a <rstgen_core_ctl+0x3a>
        return true;
  148d94:	2001      	movs	r0, #1
    return true;
}
  148d96:	bc70      	pop	{r4, r5, r6}
  148d98:	4770      	bx	r14
    if (!release && !(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK))
  148d9a:	0076      	lsls	r6, r6, #1
  148d9c:	d4e9      	bmi.n	148d72 <rstgen_core_ctl+0x22>
        return true;
  148d9e:	2001      	movs	r0, #1
  148da0:	e7f9      	b.n	148d96 <rstgen_core_ctl+0x46>
  148da2:	bf00      	nop

00148da4 <rstgen_module_ctl>:
//*****************************************************************************
bool rstgen_module_ctl(vaddr_t base, uint32_t module_idx,
                         bool release)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  148da4:	0309      	lsls	r1, r1, #12
{
  148da6:	b410      	push	{r4}
                             RSTGEN_MODULE_RST_OFF(module_slice));

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d release:%d\n",
            (uint64_t)base, module_slice, release);

    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  148da8:	580b      	ldr	r3, [r1, r0]
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  148daa:	180c      	adds	r4, r1, r0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  148dac:	2b00      	cmp	r3, #0
    {
        LTRACEF("module_slice:%d has been locked.\n", module_slice);
        return false;
  148dae:	bfb8      	it	lt
  148db0:	2000      	movlt	r0, #0
    if (readl(module_rst) & RSTGEN_MODULE_RST_LOCK_MASK)
  148db2:	db15      	blt.n	148de0 <rstgen_module_ctl+0x3c>
    }

    if (release && (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  148db4:	580b      	ldr	r3, [r1, r0]
  148db6:	b1b2      	cbz	r2, 148de6 <rstgen_module_ctl+0x42>
  148db8:	005b      	lsls	r3, r3, #1
  148dba:	d410      	bmi.n	148dde <rstgen_module_ctl+0x3a>
        LTRACEF("module_slice:%d already in assert status\n", module_slice);
        return true;
    }

    /* Enable module reset. */
    RMWREG32(module_rst, RSTGEN_MODULE_RST_EN_SHIFT, 1, 1);
  148dbc:	580b      	ldr	r3, [r1, r0]
  148dbe:	f043 0302 	orr.w	r3, r3, #2
  148dc2:	500b      	str	r3, [r1, r0]

    while (!(readl(module_rst) & RSTGEN_MODULE_RST_EN_MASK));
  148dc4:	6823      	ldr	r3, [r4, #0]
  148dc6:	079b      	lsls	r3, r3, #30
  148dc8:	d5fc      	bpl.n	148dc4 <rstgen_module_ctl+0x20>

    /* Write RST_N bit. 0 = reset, 1 = release. */
    uint32_t rst_n = release?1:0;
    RMWREG32(module_rst, RSTGEN_MODULE_RST_N_SHIFT, 1, rst_n);
  148dca:	580b      	ldr	r3, [r1, r0]
  148dcc:	f023 0301 	bic.w	r3, r3, #1
  148dd0:	4313      	orrs	r3, r2
  148dd2:	500b      	str	r3, [r1, r0]

    /* Wait module reset done. */
    while (rst_n != (readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK)>>RSTGEN_MODULE_RST_STA_SHIFT);
  148dd4:	6823      	ldr	r3, [r4, #0]
  148dd6:	f3c3 7380 	ubfx	r3, r3, #30, #1
  148dda:	4293      	cmp	r3, r2
  148ddc:	d1fa      	bne.n	148dd4 <rstgen_module_ctl+0x30>
        return true;
  148dde:	2001      	movs	r0, #1

    return true;
}
  148de0:	f85d 4b04 	ldr.w	r4, [r13], #4
  148de4:	4770      	bx	r14
    if (!release && !(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK))
  148de6:	005b      	lsls	r3, r3, #1
  148de8:	d4e8      	bmi.n	148dbc <rstgen_module_ctl+0x18>
        return true;
  148dea:	2001      	movs	r0, #1
  148dec:	e7f8      	b.n	148de0 <rstgen_module_ctl+0x3c>
  148dee:	bf00      	nop

00148df0 <rstgen_module_status>:
// return 0, the module reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_module_status(vaddr_t base, uint32_t module_idx)
{
    uint32_t module_slice = module_idx - (MODULE_RST / 4);;
    vaddr_t module_rst = base + SOC_RSTGEN_REG_MAP(
  148df0:	0309      	lsls	r1, r1, #12

    LTRACEF("rstgen_module_reset base:0x%llx module_idx:%d \n",
            (uint64_t)base, module_slice);

    /* RSTGEN_MODULE_RST_STA, 0 = reset, 1 = release. */
    return !!(readl(module_rst) & RSTGEN_MODULE_RST_STA_MASK);
  148df2:	5808      	ldr	r0, [r1, r0]
}
  148df4:	f3c0 7080 	ubfx	r0, r0, #30, #1
  148df8:	4770      	bx	r14
  148dfa:	bf00      	nop

00148dfc <rstgen_core_status>:
// return 1, the core reset has be released.
// return 0, the core reset hasn't be released.
//*****************************************************************************
uint32_t rstgen_core_status(vaddr_t base, uint32_t core_idx)
{
    uint32_t core_slice = (core_idx / 2) - (CORE_RST_EN / 4);
  148dfc:	0849      	lsrs	r1, r1, #1
    vaddr_t core_sw_rst = base + SOC_RSTGEN_REG_MAP(
  148dfe:	0349      	lsls	r1, r1, #13
                RSTGEN_CORE_SW_RST_OFF(core_slice));
    return !!(readl(core_sw_rst) & RSTGEN_CORE_SW_RST_CORE_RST_STA_MASK);
  148e00:	5808      	ldr	r0, [r1, r0]
}
  148e02:	f3c0 7080 	ubfx	r0, r0, #30, #1
  148e06:	4770      	bx	r14

00148e08 <scr_get>:

/*
 * Get SCR signal value.
 */
uint32_t scr_get(scr_signal_t scr_signal)
{
  148e08:	b4f0      	push	{r4, r5, r6, r7}
  148e0a:	4604      	mov	r4, r0
  148e0c:	b084      	sub	sp, #16
  SCR signal parser helpers.
  -----------------------------------------------------*/

static inline enum scr_id _scr_id(scr_signal_t scr_signal)
{
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  148e0e:	f3c1 2107 	ubfx	r1, r1, #8, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  148e12:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  148e16:	061b      	lsls	r3, r3, #24
  148e18:	ea4f 4610 	mov.w	r6, r0, lsr #16
  148e1c:	d428      	bmi.n	148e70 <scr_get+0x68>
    __asm__ volatile("cpsid i");
  148e1e:	b672      	cpsid	i
    return (uint32_t)scr_signal & 0xff;
}

static inline uint32_t _scr_reg(scr_signal_t scr_signal)
{
    const int scr_shift[] = {
  148e20:	f645 7208 	movw	r2, #24328	; 0x5f08
        [SCR_SEC]    = 10,
        [SCR_HPI]    = 0,
    };

    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
    return reg << scr_shift[_scr_id(scr_signal)];
  148e24:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  148e26:	f2c0 0215 	movt	r2, #21
    return reg << scr_shift[_scr_id(scr_signal)];
  148e2a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  -----------------------------------------------------*/

/* Get physical address of SCR register. */
static inline uint32_t _scr_reg_paddr(enum scr_id scr_id, uint32_t reg)
{
    const addr_t scr_base[] = {
  148e2e:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  148e32:	ad01      	add	r5, sp, #4
  148e34:	ca07      	ldmia	r2, {r0, r1, r2}
  148e36:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  148e3a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148e3e:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  148e42:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148e46:	40be      	lsls	r6, r7
        [SCR_SAFETY] = APB_SCR_SAF_BASE,
        [SCR_SEC]    = APB_SCR_SEC_BASE,
        [SCR_HPI]    = APB_SCR_HPI_BASE,
    };

    return scr_base[scr_id] + reg;
  148e48:	f853 3c0c 	ldr.w	r3, [r3, #-12]
};

static inline uint32_t _scr_read_reg(enum scr_id scr_id, uint32_t reg)
{
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  148e4c:	58f0      	ldr	r0, [r6, r3]
    __asm__ volatile("cpsie i");
  148e4e:	b662      	cpsie	i
    return (uint32_t)(scr_signal >> 8) & 0xff;
  148e50:	f3c4 2307 	ubfx	r3, r4, #8, #8
    return (uint32_t)scr_signal & 0xff;
  148e54:	b2e4      	uxtb	r4, r4
    spin_lock_irqsave(&g_scr_lock, state);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));
    spin_unlock_irqrestore(&g_scr_lock, state);

    return (val >> _scr_start_bit(scr_signal)) &
            BIT_MASK(_scr_width(scr_signal));
  148e56:	2c1f      	cmp	r4, #31
    return (val >> _scr_start_bit(scr_signal)) &
  148e58:	fa20 f003 	lsr.w	r0, r0, r3
            BIT_MASK(_scr_width(scr_signal));
  148e5c:	d805      	bhi.n	148e6a <scr_get+0x62>
  148e5e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  148e62:	fa03 f404 	lsl.w	r4, r3, r4
  148e66:	ea20 0004 	bic.w	r0, r0, r4
}
  148e6a:	b004      	add	sp, #16
  148e6c:	bcf0      	pop	{r4, r5, r6, r7}
  148e6e:	4770      	bx	r14
    const int scr_shift[] = {
  148e70:	f645 7208 	movw	r2, #24328	; 0x5f08
    return reg << scr_shift[_scr_id(scr_signal)];
  148e74:	ab04      	add	r3, sp, #16
    const int scr_shift[] = {
  148e76:	f2c0 0215 	movt	r2, #21
    return reg << scr_shift[_scr_id(scr_signal)];
  148e7a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    const addr_t scr_base[] = {
  148e7e:	f102 070c 	add.w	r7, r2, #12
    const int scr_shift[] = {
  148e82:	ad01      	add	r5, sp, #4
  148e84:	ca07      	ldmia	r2, {r0, r1, r2}
  148e86:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    const addr_t scr_base[] = {
  148e8a:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148e8e:	f853 7c0c 	ldr.w	r7, [r3, #-12]
    const addr_t scr_base[] = {
  148e92:	e885 0007 	stmia.w	r5, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148e96:	40be      	lsls	r6, r7
    return scr_base[scr_id] + reg;
  148e98:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  148e9c:	58f0      	ldr	r0, [r6, r3]
  148e9e:	e7d7      	b.n	148e50 <scr_get+0x48>

00148ea0 <scr_is_locked>:
    const int scr_shift[] = {
  148ea0:	f645 7208 	movw	r2, #24328	; 0x5f08
/*
 * Check whether the SCR signal is locked - read only or manually
 * locked by SW.
 */
bool scr_is_locked(scr_signal_t scr_signal)
{
  148ea4:	460b      	mov	r3, r1
  148ea6:	b4f0      	push	{r4, r5, r6, r7}
  148ea8:	f2c0 0215 	movt	r2, #21
  148eac:	b084      	sub	sp, #16
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  148eae:	f3c1 2607 	ubfx	r6, r1, #8, #8
    return reg << scr_shift[_scr_id(scr_signal)];
  148eb2:	a904      	add	r1, sp, #16
    const addr_t scr_base[] = {
  148eb4:	f102 070c 	add.w	r7, r2, #12
  148eb8:	4605      	mov	r5, r0
    return reg << scr_shift[_scr_id(scr_signal)];
  148eba:	eb01 0686 	add.w	r6, r1, r6, lsl #2
    const int scr_shift[] = {
  148ebe:	ac01      	add	r4, sp, #4
  148ec0:	ca07      	ldmia	r2, {r0, r1, r2}
  148ec2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  148ec6:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148eca:	f856 cc0c 	ldr.w	r12, [r6, #-12]
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  148ece:	0c2f      	lsrs	r7, r5, #16
    const addr_t scr_base[] = {
  148ed0:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    uint32_t val = (uint32_t)(scr_signal >> 32) & 0xff;
  148ed4:	b2db      	uxtb	r3, r3
    return reg << scr_shift[_scr_id(scr_signal)];
  148ed6:	fa07 f70c 	lsl.w	r7, r7, r12
    return scr_base[scr_id] + reg;
  148eda:	f856 2c0c 	ldr.w	r2, [r6, #-12]
    uint32_t start_bit = _scr_start_bit(scr_signal);
    uint32_t val = _scr_read_reg(scr_id, _scr_reg(scr_signal));

    bool locked;

    switch (_scr_type(scr_signal)) {
  148ede:	3b01      	subs	r3, #1
    return (uint32_t)(scr_signal >> 8) & 0xff;
  148ee0:	f3c5 2507 	ubfx	r5, r5, #8, #8
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  148ee4:	58b8      	ldr	r0, [r7, r2]
  148ee6:	2b03      	cmp	r3, #3
  148ee8:	d81f      	bhi.n	148f2a <scr_is_locked+0x8a>
  148eea:	e8df f003 	tbb	[r15, r3]
  148eee:	1102      	.short	0x1102
  148ef0:	060d      	.short	0x060d
        case R16W16:
            locked = start_bit >= 16;
            break;

        case RO:
            locked = true;
  148ef2:	2001      	movs	r0, #1
            locked = false;
            break;
    }

    return locked;
}
  148ef4:	b004      	add	sp, #16
  148ef6:	bcf0      	pop	{r4, r5, r6, r7}
  148ef8:	4770      	bx	r14
            locked = start_bit >= 16;
  148efa:	2d0f      	cmp	r5, #15
  148efc:	bf94      	ite	ls
  148efe:	2000      	movls	r0, #0
  148f00:	2001      	movhi	r0, #1
}
  148f02:	b004      	add	sp, #16
  148f04:	bcf0      	pop	{r4, r5, r6, r7}
  148f06:	4770      	bx	r14
            locked = val & (1ul << 31);
  148f08:	0fc0      	lsrs	r0, r0, #31
}
  148f0a:	b004      	add	sp, #16
  148f0c:	bcf0      	pop	{r4, r5, r6, r7}
  148f0e:	4770      	bx	r14
                locked = val & (1ul << (start_bit + 16));
  148f10:	2301      	movs	r3, #1
            if (start_bit < 16)
  148f12:	2d0f      	cmp	r5, #15
                locked = val & (1ul << (start_bit + 16));
  148f14:	bf98      	it	ls
  148f16:	3510      	addls	r5, #16
                locked = val & (1ul << start_bit);
  148f18:	fa03 f505 	lsl.w	r5, r3, r5
  148f1c:	4205      	tst	r5, r0
  148f1e:	bf14      	ite	ne
  148f20:	4618      	movne	r0, r3
  148f22:	2000      	moveq	r0, #0
}
  148f24:	b004      	add	sp, #16
  148f26:	bcf0      	pop	{r4, r5, r6, r7}
  148f28:	4770      	bx	r14
            locked = false;
  148f2a:	2000      	movs	r0, #0
}
  148f2c:	b004      	add	sp, #16
  148f2e:	bcf0      	pop	{r4, r5, r6, r7}
  148f30:	4770      	bx	r14
  148f32:	bf00      	nop

00148f34 <scr_set>:
{
  148f34:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  148f38:	468a      	mov	r10, r1
    const int scr_shift[] = {
  148f3a:	f645 7108 	movw	r1, #24328	; 0x5f08
    uint32_t val = (uint32_t)(scr_signal >> 40) & 0xff;
  148f3e:	f3ca 2607 	ubfx	r6, r10, #8, #8
  148f42:	b085      	sub	sp, #20
    const int scr_shift[] = {
  148f44:	f2c0 0115 	movt	r1, #21
    return reg << scr_shift[_scr_id(scr_signal)];
  148f48:	00b6      	lsls	r6, r6, #2
  148f4a:	ab04      	add	r3, sp, #16
  148f4c:	4433      	add	r3, r6
  148f4e:	4605      	mov	r5, r0
    const addr_t scr_base[] = {
  148f50:	f101 070c 	add.w	r7, r1, #12
  148f54:	4691      	mov	r9, r2
    const int scr_shift[] = {
  148f56:	ac01      	add	r4, sp, #4
  148f58:	c907      	ldmia	r1, {r0, r1, r2}
    uint32_t reg = (uint32_t)(scr_signal >> 16) & 0xffff;
  148f5a:	ea4f 4815 	mov.w	r8, r5, lsr #16
    const int scr_shift[] = {
  148f5e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    const addr_t scr_base[] = {
  148f62:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148f66:	f853 cc0c 	ldr.w	r12, [r3, #-12]
    const addr_t scr_base[] = {
  148f6a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return reg << scr_shift[_scr_id(scr_signal)];
  148f6e:	fa08 f80c 	lsl.w	r8, r8, r12
    return scr_base[scr_id] + reg;
  148f72:	f853 3c0c 	ldr.w	r3, [r3, #-12]
    return readl(_ioaddr(_scr_reg_paddr(scr_id, reg)));
  148f76:	f858 b003 	ldr.w	r11, [r8, r3]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  148f7a:	f3ef 8300 	mrs	r3, CPSR
  148f7e:	061b      	lsls	r3, r3, #24
  148f80:	d529      	bpl.n	148fd6 <scr_set+0xa2>
    if (!scr_is_locked(scr_signal)) {
  148f82:	4628      	mov	r0, r5
  148f84:	4651      	mov	r1, r10
  148f86:	f7ff ff8b 	bl	148ea0 <scr_is_locked>
    spin_lock_saved_state_t state = 0;
  148f8a:	4684      	mov	r12, r0
  148f8c:	bb50      	cbnz	r0, 148fe4 <scr_set+0xb0>
    return (uint32_t)scr_signal & 0xff;
  148f8e:	b2ea      	uxtb	r2, r5
        val &= ~(BIT_MASK(_scr_width(scr_signal)) << start_bit);
  148f90:	2a1f      	cmp	r2, #31
  148f92:	bf94      	ite	ls
  148f94:	2301      	movls	r3, #1
  148f96:	f04f 33ff 	movhi.w	r3, #4294967295	; 0xffffffff
    return (uint32_t)(scr_signal >> 8) & 0xff;
  148f9a:	f3c5 2507 	ubfx	r5, r5, #8, #8
  148f9e:	bf9c      	itt	ls
  148fa0:	4093      	lslls	r3, r2
  148fa2:	f103 33ff 	addls.w	r3, r3, #4294967295	; 0xffffffff
    return scr_base[scr_id] + reg;
  148fa6:	aa04      	add	r2, sp, #16
  148fa8:	40ab      	lsls	r3, r5
  148faa:	4416      	add	r6, r2
  148fac:	ea2b 0b03 	bic.w	r11, r11, r3
    const addr_t scr_base[] = {
  148fb0:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
        val |= value << start_bit;
  148fb4:	fa09 f905 	lsl.w	r9, r9, r5
  148fb8:	ea49 050b 	orr.w	r5, r9, r11
  148fbc:	e884 0007 	stmia.w	r4, {r0, r1, r2}
    return scr_base[scr_id] + reg;
  148fc0:	f856 3c0c 	ldr.w	r3, [r6, #-12]
        ret = true;
  148fc4:	2001      	movs	r0, #1
}

static inline void
_scr_write_reg(enum scr_id scr_id, uint32_t reg, uint32_t val)
{
    writel(val, _ioaddr(_scr_reg_paddr(scr_id, reg)));
  148fc6:	f848 5003 	str.w	r5, [r8, r3]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  148fca:	f1bc 0f00 	cmp.w	r12, #0
  148fce:	d118      	bne.n	149002 <scr_set+0xce>
}
  148fd0:	b005      	add	sp, #20
  148fd2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    __asm__ volatile("cpsid i");
  148fd6:	b672      	cpsid	i
    if (!scr_is_locked(scr_signal)) {
  148fd8:	4628      	mov	r0, r5
  148fda:	4651      	mov	r1, r10
  148fdc:	f7ff ff60 	bl	148ea0 <scr_is_locked>
  148fe0:	b160      	cbz	r0, 148ffc <scr_set+0xc8>
    __asm__ volatile("cpsie i");
  148fe2:	b662      	cpsie	i
        dprintf(CRITICAL, "Cannot set SCR signal %llx\n", scr_signal);
  148fe4:	f645 7020 	movw	r0, #24352	; 0x5f20
  148fe8:	462a      	mov	r2, r5
  148fea:	4653      	mov	r3, r10
  148fec:	f2c0 0015 	movt	r0, #21
  148ff0:	f00b f882 	bl	1540f8 <_printf>
  148ff4:	2000      	movs	r0, #0
}
  148ff6:	b005      	add	sp, #20
  148ff8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  148ffc:	f04f 0c01 	mov.w	r12, #1
  149000:	e7c5      	b.n	148f8e <scr_set+0x5a>
  149002:	b662      	cpsie	i
        ret = true;
  149004:	2001      	movs	r0, #1
  149006:	e7e3      	b.n	148fd0 <scr_set+0x9c>

00149008 <timer_drv_cntr_set>:
 ** \param [in] val        Set value for sub counter.
 *****************************************************************************/
void timer_drv_cntr_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                        uint32_t val)
{
    if (val == 0) {
  149008:	b94a      	cbnz	r2, 14901e <timer_drv_cntr_set+0x16>
    timer->cnt_config |= (1 << sub_timer);
  14900a:	6a42      	ldr	r2, [r0, #36]	; 0x24
  14900c:	2301      	movs	r3, #1
  14900e:	fa03 f101 	lsl.w	r1, r3, r1
  149012:	430a      	orrs	r2, r1
  149014:	6242      	str	r2, [r0, #36]	; 0x24
        while (timer->cnt_config & (1 << sub_timer));
  149016:	6a43      	ldr	r3, [r0, #36]	; 0x24
  149018:	4219      	tst	r1, r3
  14901a:	d1fc      	bne.n	149016 <timer_drv_cntr_set+0xe>
  14901c:	4770      	bx	r14
        timer_drv_cntr_reset(timer, sub_timer, true);
    }
    else {
        if (sub_timer == TIMER_DRV_G0) {
  14901e:	b161      	cbz	r1, 14903a <timer_drv_cntr_set+0x32>
            timer->cnt_g0_init = val;
        }
        else if (sub_timer == TIMER_DRV_G1) {
  149020:	2901      	cmp	r1, #1
  149022:	d00d      	beq.n	149040 <timer_drv_cntr_set+0x38>
            timer->cnt_g1_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_A) {
  149024:	2902      	cmp	r1, #2
  149026:	d00e      	beq.n	149046 <timer_drv_cntr_set+0x3e>
            timer->cnt_local_a_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_B) {
  149028:	2903      	cmp	r1, #3
  14902a:	d00f      	beq.n	14904c <timer_drv_cntr_set+0x44>
            timer->cnt_local_b_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_C) {
  14902c:	2904      	cmp	r1, #4
  14902e:	d010      	beq.n	149052 <timer_drv_cntr_set+0x4a>
            timer->cnt_local_c_init = val;
        }
        else if (sub_timer == TIMER_DRV_LOCAL_D) {
  149030:	2905      	cmp	r1, #5
            timer->cnt_local_d_init = val;
  149032:	bf08      	it	eq
  149034:	f8c0 20c4 	streq.w	r2, [r0, #196]	; 0xc4
        }
    }
}
  149038:	4770      	bx	r14
            timer->cnt_g0_init = val;
  14903a:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
  14903e:	4770      	bx	r14
            timer->cnt_g1_init = val;
  149040:	f8c0 20b4 	str.w	r2, [r0, #180]	; 0xb4
  149044:	4770      	bx	r14
            timer->cnt_local_a_init = val;
  149046:	f8c0 20b8 	str.w	r2, [r0, #184]	; 0xb8
  14904a:	4770      	bx	r14
            timer->cnt_local_b_init = val;
  14904c:	f8c0 20bc 	str.w	r2, [r0, #188]	; 0xbc
  149050:	4770      	bx	r14
            timer->cnt_local_c_init = val;
  149052:	f8c0 20c0 	str.w	r2, [r0, #192]	; 0xc0
  149056:	4770      	bx	r14

00149058 <timer_drv_cntr_get>:
 *****************************************************************************/
uint32_t timer_drv_cntr_get(sdrv_timer_t *timer, timer_drv_sub_t sub_timer)
{
    uint32_t val = 0;

    if (sub_timer == TIMER_DRV_G0) {
  149058:	b161      	cbz	r1, 149074 <timer_drv_cntr_get+0x1c>
        val = timer->cnt_g0;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  14905a:	2901      	cmp	r1, #1
  14905c:	d00c      	beq.n	149078 <timer_drv_cntr_get+0x20>
        val = timer->cnt_g1;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  14905e:	2902      	cmp	r1, #2
  149060:	d00e      	beq.n	149080 <timer_drv_cntr_get+0x28>
        val = timer->cnt_local_a;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  149062:	2903      	cmp	r1, #3
  149064:	d00a      	beq.n	14907c <timer_drv_cntr_get+0x24>
        val = timer->cnt_local_b;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  149066:	2904      	cmp	r1, #4
  149068:	d00c      	beq.n	149084 <timer_drv_cntr_get+0x2c>
        val = timer->cnt_local_c;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  14906a:	2905      	cmp	r1, #5
        val = timer->cnt_local_d;
  14906c:	bf0c      	ite	eq
  14906e:	6d40      	ldreq	r0, [r0, #84]	; 0x54
    uint32_t val = 0;
  149070:	2000      	movne	r0, #0
    }

    return val;
}
  149072:	4770      	bx	r14
        val = timer->cnt_g0;
  149074:	6c00      	ldr	r0, [r0, #64]	; 0x40
  149076:	4770      	bx	r14
        val = timer->cnt_g1;
  149078:	6c40      	ldr	r0, [r0, #68]	; 0x44
  14907a:	4770      	bx	r14
        val = timer->cnt_local_b;
  14907c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  14907e:	4770      	bx	r14
        val = timer->cnt_local_a;
  149080:	6c80      	ldr	r0, [r0, #72]	; 0x48
  149082:	4770      	bx	r14
        val = timer->cnt_local_c;
  149084:	6d00      	ldr	r0, [r0, #80]	; 0x50
  149086:	4770      	bx	r14

00149088 <timer_drv_ovf_set>:
 ** \param [in] val        Set sub counter overflow value.
 *****************************************************************************/
void timer_drv_ovf_set(sdrv_timer_t *timer, timer_drv_sub_t sub_timer,
                       uint32_t val)
{
    if (sub_timer == TIMER_DRV_G0) {
  149088:	b159      	cbz	r1, 1490a2 <timer_drv_ovf_set+0x1a>
        timer->cnt_g0_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_G1) {
  14908a:	2901      	cmp	r1, #1
  14908c:	d00b      	beq.n	1490a6 <timer_drv_ovf_set+0x1e>
        timer->cnt_g1_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_A) {
  14908e:	2902      	cmp	r1, #2
  149090:	d00d      	beq.n	1490ae <timer_drv_ovf_set+0x26>
        timer->cnt_local_a_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_B) {
  149092:	2903      	cmp	r1, #3
  149094:	d009      	beq.n	1490aa <timer_drv_ovf_set+0x22>
        timer->cnt_local_b_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_C) {
  149096:	2904      	cmp	r1, #4
  149098:	d00b      	beq.n	1490b2 <timer_drv_ovf_set+0x2a>
        timer->cnt_local_c_ovf = val;
    }
    else if (sub_timer == TIMER_DRV_LOCAL_D) {
  14909a:	2905      	cmp	r1, #5
        timer->cnt_local_d_ovf = val;
  14909c:	bf08      	it	eq
  14909e:	63c2      	streq	r2, [r0, #60]	; 0x3c
    }
}
  1490a0:	4770      	bx	r14
        timer->cnt_g0_ovf = val;
  1490a2:	6282      	str	r2, [r0, #40]	; 0x28
  1490a4:	4770      	bx	r14
        timer->cnt_g1_ovf = val;
  1490a6:	62c2      	str	r2, [r0, #44]	; 0x2c
  1490a8:	4770      	bx	r14
        timer->cnt_local_b_ovf = val;
  1490aa:	6342      	str	r2, [r0, #52]	; 0x34
  1490ac:	4770      	bx	r14
        timer->cnt_local_a_ovf = val;
  1490ae:	6302      	str	r2, [r0, #48]	; 0x30
  1490b0:	4770      	bx	r14
        timer->cnt_local_c_ovf = val;
  1490b2:	6382      	str	r2, [r0, #56]	; 0x38
  1490b4:	4770      	bx	r14
  1490b6:	bf00      	nop

001490b8 <timer_drv_cascade_set>:
 ** \param [in] cascade    G1 cascaded G0 or not.
 *****************************************************************************/
void timer_drv_cascade_set(sdrv_timer_t *timer, bool cascade)
{
    if (cascade) {
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  1490b8:	6a43      	ldr	r3, [r0, #36]	; 0x24
    if (cascade) {
  1490ba:	b919      	cbnz	r1, 1490c4 <timer_drv_cascade_set+0xc>
    }
    else {
        timer->cnt_config &= (~BM_CNT_CONFIG_CASCADE_MODE);
  1490bc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  1490c0:	6243      	str	r3, [r0, #36]	; 0x24
    }
}
  1490c2:	4770      	bx	r14
        timer->cnt_config |= BM_CNT_CONFIG_CASCADE_MODE;
  1490c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  1490c8:	6243      	str	r3, [r0, #36]	; 0x24
  1490ca:	4770      	bx	r14

001490cc <timer_drv_clk_init>:
 **                                     11 - Low power clock, typically from low speed on chip RCOSC
 *****************************************************************************/
void timer_drv_clk_init(sdrv_timer_t *timer, uint32_t clk_sel,
                        uint32_t clk_div)
{
    u32 value = timer->tim_clk_config;
  1490cc:	6a03      	ldr	r3, [r0, #32]

    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  1490ce:	0409      	lsls	r1, r1, #16
              FV_TIM_CLK_CONFIG_DIV_NUM(clk_div));
  1490d0:	b292      	uxth	r2, r2
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  1490d2:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
  1490d6:	4311      	orrs	r1, r2
    value &= ~(FM_TIM_CLK_CONFIG_SRC_CLK_SEL | FM_TIM_CLK_CONFIG_DIV_NUM);
  1490d8:	0c9a      	lsrs	r2, r3, #18
  1490da:	0492      	lsls	r2, r2, #18
    value |= (FV_TIM_CLK_CONFIG_SRC_CLK_SEL(clk_sel) |
  1490dc:	4311      	orrs	r1, r2

    timer->tim_clk_config = value;
  1490de:	6201      	str	r1, [r0, #32]
}
  1490e0:	4770      	bx	r14
  1490e2:	bf00      	nop

001490e4 <timer_drv_int_sta_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sta_en |= (1 << offset);
  1490e4:	2301      	movs	r3, #1
  1490e6:	fa03 f101 	lsl.w	r1, r3, r1
  1490ea:	6843      	ldr	r3, [r0, #4]
  1490ec:	4319      	orrs	r1, r3
  1490ee:	6041      	str	r1, [r0, #4]
}
  1490f0:	4770      	bx	r14
  1490f2:	bf00      	nop

001490f4 <timer_drv_int_sta_disable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sta_disable(sdrv_timer_t *timer,
                               timer_drv_int_src_t offset)
{
    timer->int_sta_en &= ~(1 << offset);
  1490f4:	2301      	movs	r3, #1
  1490f6:	fa03 f101 	lsl.w	r1, r3, r1
  1490fa:	6843      	ldr	r3, [r0, #4]
  1490fc:	ea23 0101 	bic.w	r1, r3, r1
  149100:	6041      	str	r1, [r0, #4]
}
  149102:	4770      	bx	r14

00149104 <timer_drv_int_sig_enable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_enable(sdrv_timer_t *timer,
                              timer_drv_int_src_t offset)
{
    timer->int_sig_en |= (1 << offset);
  149104:	2301      	movs	r3, #1
  149106:	fa03 f101 	lsl.w	r1, r3, r1
  14910a:	6883      	ldr	r3, [r0, #8]
  14910c:	4319      	orrs	r1, r3
  14910e:	6081      	str	r1, [r0, #8]
}
  149110:	4770      	bx	r14
  149112:	bf00      	nop

00149114 <timer_drv_int_sig_disable>:
 ** \param [in] offset    intterrupt state bit offset.
 *****************************************************************************/
void timer_drv_int_sig_disable(sdrv_timer_t *timer,
                               timer_drv_int_src_t offset)
{
    timer->int_sig_en &= ~(1 << offset);
  149114:	2301      	movs	r3, #1
  149116:	fa03 f101 	lsl.w	r1, r3, r1
  14911a:	6883      	ldr	r3, [r0, #8]
  14911c:	ea23 0101 	bic.w	r1, r3, r1
  149120:	6081      	str	r1, [r0, #8]
}
  149122:	4770      	bx	r14

00149124 <timer_drv_ovf_irq_handle>:
 ** \param [in] drv_context
 *****************************************************************************/
enum handler_return timer_drv_ovf_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  149124:	6803      	ldr	r3, [r0, #0]
  149126:	f413 7f80 	tst.w	r3, #256	; 0x100
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  14912a:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_G0_OVF) {
  14912c:	d006      	beq.n	14913c <timer_drv_ovf_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_G0_OVF;
  14912e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  149132:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  149134:	b171      	cbz	r1, 149154 <timer_drv_ovf_irq_handle+0x30>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G0_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  149136:	688b      	ldr	r3, [r1, #8]
  149138:	b153      	cbz	r3, 149150 <timer_drv_ovf_irq_handle+0x2c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_G1_OVF_INT_SRC);
        }

        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
            return drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1]();
  14913a:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CNT_G1_OVF) {
  14913c:	059b      	lsls	r3, r3, #22
  14913e:	d507      	bpl.n	149150 <timer_drv_ovf_irq_handle+0x2c>
        timer->int_sta |= BM_INT_STA_CNT_G1_OVF;
  149140:	6803      	ldr	r3, [r0, #0]
  149142:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  149146:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  149148:	b181      	cbz	r1, 14916c <timer_drv_ovf_irq_handle+0x48>
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G1] != NULL) {
  14914a:	68cb      	ldr	r3, [r1, #12]
  14914c:	2b00      	cmp	r3, #0
  14914e:	d1f4      	bne.n	14913a <timer_drv_ovf_irq_handle+0x16>
        }
    }

    return INT_RESCHEDULE;
}
  149150:	2001      	movs	r0, #1
  149152:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  149154:	6843      	ldr	r3, [r0, #4]
  149156:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  14915a:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  14915c:	6883      	ldr	r3, [r0, #8]
  14915e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  149162:	6083      	str	r3, [r0, #8]
        if (drv_context->global_ovf_cbk[TIMER_DRV_OVF_G0] != NULL) {
  149164:	688b      	ldr	r3, [r1, #8]
  149166:	2b00      	cmp	r3, #0
  149168:	d1e7      	bne.n	14913a <timer_drv_ovf_irq_handle+0x16>
  14916a:	e7f1      	b.n	149150 <timer_drv_ovf_irq_handle+0x2c>
    timer->int_sta_en &= ~(1 << offset);
  14916c:	6843      	ldr	r3, [r0, #4]
  14916e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  149172:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  149174:	6883      	ldr	r3, [r0, #8]
  149176:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  14917a:	6083      	str	r3, [r0, #8]
  14917c:	e7e5      	b.n	14914a <timer_drv_ovf_irq_handle+0x26>
  14917e:	bf00      	nop

00149180 <timer_drv_func_irq_handle>:
 *****************************************************************************/
enum handler_return timer_drv_func_irq_handle(sdrv_timer_t *timer,
        timer_drv_context_t *drv_context)
{
    //Func A
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  149180:	6803      	ldr	r3, [r0, #0]
  149182:	f413 6f80 	tst.w	r3, #1024	; 0x400
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  149186:	6803      	ldr	r3, [r0, #0]
    if (timer->int_sta & BM_INT_STA_CNT_LOCAL_A_OVF) {
  149188:	d006      	beq.n	149198 <timer_drv_func_irq_handle+0x18>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_A_OVF;
  14918a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  14918e:	6003      	str	r3, [r0, #0]

        if (!drv_context->periodic) {
  149190:	b1e1      	cbz	r1, 1491cc <timer_drv_func_irq_handle+0x4c>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LA_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  149192:	690b      	ldr	r3, [r1, #16]
  149194:	b1c3      	cbz	r3, 1491c8 <timer_drv_func_irq_handle+0x48>
            timer_drv_int_sta_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
            timer_drv_int_sig_disable(timer, TIMER_DRV_CNT_LD_OVF_INT_SRC);
        }

        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D]();
  149196:	4718      	bx	r3
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  149198:	f013 0f10 	tst.w	r3, #16
        timer->int_sta |= BM_INT_STA_CMP_A;
  14919c:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_A) {
  14919e:	d005      	beq.n	1491ac <timer_drv_func_irq_handle+0x2c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491a0:	6a0a      	ldr	r2, [r1, #32]
        timer->int_sta |= BM_INT_STA_CMP_A;
  1491a2:	f043 0310 	orr.w	r3, r3, #16
  1491a6:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491a8:	b172      	cbz	r2, 1491c8 <timer_drv_func_irq_handle+0x48>
    }
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;

        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  1491aa:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  1491ac:	f013 0f01 	tst.w	r3, #1
        timer->int_sta |= BM_INT_STA_CPT_A;
  1491b0:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_A) {
  1491b2:	d117      	bne.n	1491e4 <timer_drv_func_irq_handle+0x64>
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  1491b4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  1491b8:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_OVERRUN) {
  1491ba:	d01a      	beq.n	1491f2 <timer_drv_func_irq_handle+0x72>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491bc:	6c0a      	ldr	r2, [r1, #64]	; 0x40
        timer->int_sta |= BM_INT_STA_FIFO_A_OVERRUN;
  1491be:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  1491c2:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491c4:	2a00      	cmp	r2, #0
  1491c6:	d1f0      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
        }
    }

    return INT_NO_RESCHEDULE;
}
  1491c8:	2000      	movs	r0, #0
  1491ca:	4770      	bx	r14
    timer->int_sta_en &= ~(1 << offset);
  1491cc:	6843      	ldr	r3, [r0, #4]
  1491ce:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  1491d2:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  1491d4:	6883      	ldr	r3, [r0, #8]
  1491d6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  1491da:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491dc:	690b      	ldr	r3, [r1, #16]
  1491de:	2b00      	cmp	r3, #0
  1491e0:	d1d9      	bne.n	149196 <timer_drv_func_irq_handle+0x16>
  1491e2:	e7f1      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491e4:	6b0a      	ldr	r2, [r1, #48]	; 0x30
        timer->int_sta |= BM_INT_STA_CPT_A;
  1491e6:	f043 0301 	orr.w	r3, r3, #1
  1491ea:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  1491ec:	2a00      	cmp	r2, #0
  1491ee:	d0eb      	beq.n	1491c8 <timer_drv_func_irq_handle+0x48>
            return drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D]();
  1491f0:	4710      	bx	r2
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  1491f2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  1491f6:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_A_UNDERRUN) {
  1491f8:	d10b      	bne.n	149212 <timer_drv_func_irq_handle+0x92>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  1491fa:	f413 6f00 	tst.w	r3, #2048	; 0x800
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  1491fe:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_B_OVF) {
  149200:	d00e      	beq.n	149220 <timer_drv_func_irq_handle+0xa0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_B_OVF;
  149202:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  149206:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  149208:	b301      	cbz	r1, 14924c <timer_drv_func_irq_handle+0xcc>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  14920a:	694b      	ldr	r3, [r1, #20]
  14920c:	2b00      	cmp	r3, #0
  14920e:	d1c2      	bne.n	149196 <timer_drv_func_irq_handle+0x16>
  149210:	e7da      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  149212:	6d0a      	ldr	r2, [r1, #80]	; 0x50
        timer->int_sta  |= BM_INT_STA_FIFO_A_UNDERRUN;
  149214:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  149218:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_A] != NULL) {
  14921a:	2a00      	cmp	r2, #0
  14921c:	d1c5      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
  14921e:	e7d3      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  149220:	f013 0f20 	tst.w	r3, #32
        timer->int_sta |= BM_INT_STA_CMP_B;
  149224:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_B) {
  149226:	d006      	beq.n	149236 <timer_drv_func_irq_handle+0xb6>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  149228:	6a4a      	ldr	r2, [r1, #36]	; 0x24
        timer->int_sta |= BM_INT_STA_CMP_B;
  14922a:	f043 0320 	orr.w	r3, r3, #32
  14922e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  149230:	2a00      	cmp	r2, #0
  149232:	d1ba      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
  149234:	e7c8      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  149236:	f013 0f02 	tst.w	r3, #2
        timer->int_sta |= BM_INT_STA_CPT_B;
  14923a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_B) {
  14923c:	d00f      	beq.n	14925e <timer_drv_func_irq_handle+0xde>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  14923e:	6b4a      	ldr	r2, [r1, #52]	; 0x34
        timer->int_sta |= BM_INT_STA_CPT_B;
  149240:	f043 0302 	orr.w	r3, r3, #2
  149244:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  149246:	2a00      	cmp	r2, #0
  149248:	d1af      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
  14924a:	e7bd      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  14924c:	6843      	ldr	r3, [r0, #4]
  14924e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  149252:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  149254:	6883      	ldr	r3, [r0, #8]
  149256:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  14925a:	6083      	str	r3, [r0, #8]
  14925c:	e7d5      	b.n	14920a <timer_drv_func_irq_handle+0x8a>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  14925e:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  149262:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_OVERRUN) {
  149264:	d006      	beq.n	149274 <timer_drv_func_irq_handle+0xf4>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  149266:	6c4a      	ldr	r2, [r1, #68]	; 0x44
        timer->int_sta |= BM_INT_STA_FIFO_B_OVERRUN;
  149268:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  14926c:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  14926e:	2a00      	cmp	r2, #0
  149270:	d19b      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
  149272:	e7a9      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  149274:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  149278:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_B_UNDERRUN) {
  14927a:	d006      	beq.n	14928a <timer_drv_func_irq_handle+0x10a>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  14927c:	6d4a      	ldr	r2, [r1, #84]	; 0x54
        timer->int_sta  |= BM_INT_STA_FIFO_B_UNDERRUN;
  14927e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  149282:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_B] != NULL) {
  149284:	2a00      	cmp	r2, #0
  149286:	d190      	bne.n	1491aa <timer_drv_func_irq_handle+0x2a>
  149288:	e79e      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  14928a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  14928e:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_C_OVF) {
  149290:	d008      	beq.n	1492a4 <timer_drv_func_irq_handle+0x124>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_C_OVF;
  149292:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  149296:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  149298:	b1e1      	cbz	r1, 1492d4 <timer_drv_func_irq_handle+0x154>
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  14929a:	698b      	ldr	r3, [r1, #24]
  14929c:	2b00      	cmp	r3, #0
  14929e:	f47f af7a 	bne.w	149196 <timer_drv_func_irq_handle+0x16>
  1492a2:	e791      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  1492a4:	f013 0f40 	tst.w	r3, #64	; 0x40
        timer->int_sta |= BM_INT_STA_CMP_C;
  1492a8:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_C) {
  1492aa:	d007      	beq.n	1492bc <timer_drv_func_irq_handle+0x13c>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492ac:	6a8a      	ldr	r2, [r1, #40]	; 0x28
        timer->int_sta |= BM_INT_STA_CMP_C;
  1492ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  1492b2:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492b4:	2a00      	cmp	r2, #0
  1492b6:	f47f af78 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  1492ba:	e785      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  1492bc:	f013 0f04 	tst.w	r3, #4
        timer->int_sta |= BM_INT_STA_CPT_C;
  1492c0:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_C) {
  1492c2:	d010      	beq.n	1492e6 <timer_drv_func_irq_handle+0x166>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492c4:	6b8a      	ldr	r2, [r1, #56]	; 0x38
        timer->int_sta |= BM_INT_STA_CPT_C;
  1492c6:	f043 0304 	orr.w	r3, r3, #4
  1492ca:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492cc:	2a00      	cmp	r2, #0
  1492ce:	f47f af6c 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  1492d2:	e779      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    timer->int_sta_en &= ~(1 << offset);
  1492d4:	6843      	ldr	r3, [r0, #4]
  1492d6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  1492da:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  1492dc:	6883      	ldr	r3, [r0, #8]
  1492de:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  1492e2:	6083      	str	r3, [r0, #8]
  1492e4:	e7d9      	b.n	14929a <timer_drv_func_irq_handle+0x11a>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  1492e6:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  1492ea:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_OVERRUN) {
  1492ec:	d007      	beq.n	1492fe <timer_drv_func_irq_handle+0x17e>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492ee:	6c8a      	ldr	r2, [r1, #72]	; 0x48
        timer->int_sta |= BM_INT_STA_FIFO_C_OVERRUN;
  1492f0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  1492f4:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  1492f6:	2a00      	cmp	r2, #0
  1492f8:	f47f af57 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  1492fc:	e764      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  1492fe:	f413 2f80 	tst.w	r3, #262144	; 0x40000
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  149302:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_C_UNDERRUN) {
  149304:	d007      	beq.n	149316 <timer_drv_func_irq_handle+0x196>
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  149306:	6d8a      	ldr	r2, [r1, #88]	; 0x58
        timer->int_sta |= BM_INT_STA_FIFO_C_UNDERRUN;
  149308:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  14930c:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_C] != NULL) {
  14930e:	2a00      	cmp	r2, #0
  149310:	f47f af4b 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  149314:	e758      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  149316:	f413 5f00 	tst.w	r3, #8192	; 0x2000
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  14931a:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CNT_LOCAL_D_OVF) {
  14931c:	d010      	beq.n	149340 <timer_drv_func_irq_handle+0x1c0>
        timer->int_sta |= BM_INT_STA_CNT_LOCAL_D_OVF;
  14931e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  149322:	6003      	str	r3, [r0, #0]
        if (!drv_context->periodic) {
  149324:	b939      	cbnz	r1, 149336 <timer_drv_func_irq_handle+0x1b6>
    timer->int_sta_en &= ~(1 << offset);
  149326:	6843      	ldr	r3, [r0, #4]
  149328:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  14932c:	6043      	str	r3, [r0, #4]
    timer->int_sig_en &= ~(1 << offset);
  14932e:	6883      	ldr	r3, [r0, #8]
  149330:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  149334:	6083      	str	r3, [r0, #8]
        if (drv_context->local_ovf_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149336:	69cb      	ldr	r3, [r1, #28]
  149338:	2b00      	cmp	r3, #0
  14933a:	f47f af2c 	bne.w	149196 <timer_drv_func_irq_handle+0x16>
  14933e:	e743      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  149340:	f013 0f80 	tst.w	r3, #128	; 0x80
        timer->int_sta |= BM_INT_STA_CMP_D;
  149344:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CMP_D) {
  149346:	d007      	beq.n	149358 <timer_drv_func_irq_handle+0x1d8>
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149348:	6aca      	ldr	r2, [r1, #44]	; 0x2c
        timer->int_sta |= BM_INT_STA_CMP_D;
  14934a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  14934e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cmp_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149350:	2a00      	cmp	r2, #0
  149352:	f47f af2a 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  149356:	e737      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  149358:	f013 0f08 	tst.w	r3, #8
        timer->int_sta |= BM_INT_STA_CPT_D;
  14935c:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_CPT_D) {
  14935e:	d007      	beq.n	149370 <timer_drv_func_irq_handle+0x1f0>
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149360:	6bca      	ldr	r2, [r1, #60]	; 0x3c
        timer->int_sta |= BM_INT_STA_CPT_D;
  149362:	f043 0308 	orr.w	r3, r3, #8
  149366:	6003      	str	r3, [r0, #0]
        if (drv_context->local_cpt_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149368:	2a00      	cmp	r2, #0
  14936a:	f47f af1e 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  14936e:	e72b      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  149370:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  149374:	6803      	ldr	r3, [r0, #0]
    else if (timer->int_sta & BM_INT_STA_FIFO_D_OVERRUN) {
  149376:	d007      	beq.n	149388 <timer_drv_func_irq_handle+0x208>
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149378:	6cca      	ldr	r2, [r1, #76]	; 0x4c
        timer->int_sta |= BM_INT_STA_FIFO_D_OVERRUN;
  14937a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  14937e:	6003      	str	r3, [r0, #0]
        if (drv_context->local_overrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149380:	2a00      	cmp	r2, #0
  149382:	f47f af12 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  149386:	e71f      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>
    else if (timer->int_sta & BM_INT_STA_FIFO_D_UNDERRUN) {
  149388:	031b      	lsls	r3, r3, #12
  14938a:	f57f af1d 	bpl.w	1491c8 <timer_drv_func_irq_handle+0x48>
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  14938e:	6803      	ldr	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149390:	6dca      	ldr	r2, [r1, #92]	; 0x5c
        timer->int_sta |= BM_INT_STA_FIFO_D_UNDERRUN;
  149392:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  149396:	6003      	str	r3, [r0, #0]
        if (drv_context->local_underrun_cbk[TIMER_DRV_FUNC_CH_D] != NULL) {
  149398:	2a00      	cmp	r2, #0
  14939a:	f47f af06 	bne.w	1491aa <timer_drv_func_irq_handle+0x2a>
  14939e:	e713      	b.n	1491c8 <timer_drv_func_irq_handle+0x48>

001493a0 <timer_drv_int_sta_clear>:
 ** \param [in] drv_context
 *****************************************************************************/
void timer_drv_int_sta_clear(sdrv_timer_t *timer,
                             timer_drv_int_src_t offset)
{
    timer->int_sta |= (1 << offset);
  1493a0:	2301      	movs	r3, #1
  1493a2:	fa03 f101 	lsl.w	r1, r3, r1
  1493a6:	6803      	ldr	r3, [r0, #0]
  1493a8:	4319      	orrs	r1, r3
  1493aa:	6001      	str	r1, [r0, #0]
}
  1493ac:	4770      	bx	r14
  1493ae:	bf00      	nop

001493b0 <uart_drv_init>:
 **
 ** \param [in] dev         Pointer to device information descriptor
 *****************************************************************************/
void uart_drv_init(DW_APB_UART_uart_TypeDef *dev,
                   uart_drv_context_t *context, uart_drv_cfg_t *cfg)
{
  1493b0:	b5f0      	push	{r4, r5, r6, r7, r14}
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  1493b2:	e9d2 3400 	ldrd	r3, r4, [r2]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493b6:	f644 55d3 	movw	r5, #19923	; 0x4dd3
    dev->LCR.DLAB = 1;  //divisor latch access bit
  1493ba:	68c7      	ldr	r7, [r0, #12]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493bc:	f2c1 0562 	movt	r5, #4194	; 0x1062
{
  1493c0:	b083      	sub	sp, #12
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  1493c2:	0124      	lsls	r4, r4, #4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  1493c4:	f047 0780 	orr.w	r7, r7, #128	; 0x80
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  1493c8:	fbb3 f6f4 	udiv	r6, r3, r4
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493cc:	fba5 c404 	umull	r12, r4, r5, r4
    dev->LCR.DLAB = 1;  //divisor latch access bit
  1493d0:	60c7      	str	r7, [r0, #12]
    dev->DLL.DLL = divisor & 0xff;
  1493d2:	6807      	ldr	r7, [r0, #0]
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493d4:	09a4      	lsrs	r4, r4, #6
  1493d6:	fbb3 f3f4 	udiv	r3, r3, r4
    divisor = cfg->port_cfg.sclk / ( 16 * cfg->port_cfg.baud);
  1493da:	b2b4      	uxth	r4, r6
    dev->DLL.DLL = divisor & 0xff;
  1493dc:	b2f6      	uxtb	r6, r6
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493de:	ebc4 1c44 	rsb	r12, r4, r4, lsl #5
    dev->DLL.DLL = divisor & 0xff;
  1493e2:	f366 0707 	bfi	r7, r6, #0, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493e6:	eb04 068c 	add.w	r6, r4, r12, lsl #2
    dev->DLL.DLL = divisor & 0xff;
  1493ea:	6007      	str	r7, [r0, #0]
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1493ec:	0a24      	lsrs	r4, r4, #8
    frac = ((cfg->port_cfg.sclk / ((cfg->port_cfg.baud * 16) / 1000)) - (divisor * 1000));
  1493ee:	eba3 03c6 	sub.w	r3, r3, r6, lsl #3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1493f2:	6846      	ldr	r6, [r0, #4]
    frac = frac *16/1000;
  1493f4:	b29b      	uxth	r3, r3
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1493f6:	f364 0607 	bfi	r6, r4, #0, #8
    frac = frac *16/1000;
  1493fa:	011b      	lsls	r3, r3, #4
    dev->DLH.DLH = (divisor >> 8) & 0xff;
  1493fc:	6046      	str	r6, [r0, #4]
    frac = frac *16/1000;
  1493fe:	fba5 4303 	umull	r4, r3, r5, r3
    dev->DLF.DLF = frac;
  149402:	f8d0 40c0 	ldr.w	r4, [r0, #192]	; 0xc0
  149406:	f3c3 1383 	ubfx	r3, r3, #6, #4
  14940a:	f363 0403 	bfi	r4, r3, #0, #4
  14940e:	f8c0 40c0 	str.w	r4, [r0, #192]	; 0xc0
    dev->LCR.DLAB = 0;
  149412:	68c3      	ldr	r3, [r0, #12]
  149414:	f36f 13c7 	bfc	r3, #7, #1
  149418:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.data_bits) {
  14941a:	6893      	ldr	r3, [r2, #8]
  14941c:	2b03      	cmp	r3, #3
  14941e:	f200 8091 	bhi.w	149544 <uart_drv_init+0x194>
            dev->LCR.DLS = cfg->port_cfg.data_bits;
  149422:	68c4      	ldr	r4, [r0, #12]
  149424:	f363 0401 	bfi	r4, r3, #0, #2
  149428:	60c4      	str	r4, [r0, #12]
    switch (cfg->port_cfg.stop_bits) {
  14942a:	68d3      	ldr	r3, [r2, #12]
  14942c:	2b01      	cmp	r3, #1
  14942e:	d06c      	beq.n	14950a <uart_drv_init+0x15a>
  149430:	d343      	bcc.n	1494ba <uart_drv_init+0x10a>
  149432:	2b02      	cmp	r3, #2
  149434:	f040 8097 	bne.w	149566 <uart_drv_init+0x1b6>
            if (dev->LCR.DLS == 0)
  149438:	68c3      	ldr	r3, [r0, #12]
  14943a:	079b      	lsls	r3, r3, #30
  14943c:	f000 80b5 	beq.w	1495aa <uart_drv_init+0x1fa>
            dev->LCR.STOP = 1;
  149440:	68c3      	ldr	r3, [r0, #12]
  149442:	f043 0304 	orr.w	r3, r3, #4
  149446:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  149448:	6913      	ldr	r3, [r2, #16]
  14944a:	2b01      	cmp	r3, #1
  14944c:	d03c      	beq.n	1494c8 <uart_drv_init+0x118>
  14944e:	d370      	bcc.n	149532 <uart_drv_init+0x182>
  149450:	2b02      	cmp	r3, #2
  149452:	f040 8099 	bne.w	149588 <uart_drv_init+0x1d8>
            dev->LCR.PEN = 0;
  149456:	68c3      	ldr	r3, [r0, #12]
  149458:	f36f 03c3 	bfc	r3, #3, #1
  14945c:	60c3      	str	r3, [r0, #12]
    if (cfg->port_cfg.loopback_enable) {
  14945e:	7d13      	ldrb	r3, [r2, #20]
  149460:	b11b      	cbz	r3, 14946a <uart_drv_init+0xba>
 ** \param [out]
 *****************************************************************************/
void uart_drv_loopback(DW_APB_UART_uart_TypeDef *dev, bool enable)
{
    if (enable) {
        dev->MCR.LOOPBACK = 1;
  149462:	6903      	ldr	r3, [r0, #16]
  149464:	f043 0310 	orr.w	r3, r3, #16
  149468:	6103      	str	r3, [r0, #16]
    if (cfg->fifo_cfg.fifo_enable) {
  14946a:	7e13      	ldrb	r3, [r2, #24]
  14946c:	2b00      	cmp	r3, #0
  14946e:	d134      	bne.n	1494da <uart_drv_init+0x12a>
        context->fcr_shadow.FIFOE = 0;
  149470:	790a      	ldrb	r2, [r1, #4]
  149472:	f363 0200 	bfi	r2, r3, #0, #1
  149476:	710a      	strb	r2, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  149478:	684a      	ldr	r2, [r1, #4]
  14947a:	6082      	str	r2, [r0, #8]
        context->fifo_enable = false;
  14947c:	700b      	strb	r3, [r1, #0]
    context->tx_str_cbk = NULL;
  14947e:	2300      	movs	r3, #0
  149480:	610b      	str	r3, [r1, #16]
    context->rx_str_cbk = NULL;
  149482:	e9c1 3302 	strd	r3, r3, [r1, #8]
    context->tx_shadow.len_rest = 0;
  149486:	e9c1 3305 	strd	r3, r3, [r1, #20]
    context->rx_shadow.len_rest = 0;
  14948a:	e9c1 3307 	strd	r3, r3, [r1, #28]
    dev->IER.ERBFI = 1;   //received data available interrupt
  14948e:	6842      	ldr	r2, [r0, #4]
  149490:	f042 0201 	orr.w	r2, r2, #1
  149494:	6042      	str	r2, [r0, #4]
        dev->IER.ETBEI = 0;
  149496:	6842      	ldr	r2, [r0, #4]
  149498:	f363 0241 	bfi	r2, r3, #1, #1
  14949c:	6042      	str	r2, [r0, #4]
    dev->IER.ELSI = 1;      //receiver line status interrupt
  14949e:	6842      	ldr	r2, [r0, #4]
  1494a0:	f042 0204 	orr.w	r2, r2, #4
  1494a4:	6042      	str	r2, [r0, #4]
    dev->IER.EDSSI = 0;     //modem status interrupt
  1494a6:	6842      	ldr	r2, [r0, #4]
  1494a8:	f363 02c3 	bfi	r2, r3, #3, #1
  1494ac:	6042      	str	r2, [r0, #4]
    dev->IER.PTIME = 0;     //programmable THRE interrupt mode
  1494ae:	6842      	ldr	r2, [r0, #4]
  1494b0:	f363 12c7 	bfi	r2, r3, #7, #1
  1494b4:	6042      	str	r2, [r0, #4]
}
  1494b6:	b003      	add	sp, #12
  1494b8:	bdf0      	pop	{r4, r5, r6, r7, r15}
            dev->LCR.STOP = 0;
  1494ba:	68c3      	ldr	r3, [r0, #12]
  1494bc:	f36f 0382 	bfc	r3, #2, #1
  1494c0:	60c3      	str	r3, [r0, #12]
    switch (cfg->port_cfg.parity) {
  1494c2:	6913      	ldr	r3, [r2, #16]
  1494c4:	2b01      	cmp	r3, #1
  1494c6:	d1c2      	bne.n	14944e <uart_drv_init+0x9e>
            dev->LCR.EPS = 1;
  1494c8:	68c3      	ldr	r3, [r0, #12]
  1494ca:	f043 0310 	orr.w	r3, r3, #16
  1494ce:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  1494d0:	68c3      	ldr	r3, [r0, #12]
  1494d2:	f043 0308 	orr.w	r3, r3, #8
  1494d6:	60c3      	str	r3, [r0, #12]
  1494d8:	e7c1      	b.n	14945e <uart_drv_init+0xae>
        context->fcr_shadow.RFIFOR = 1; //reset fifo
  1494da:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  1494dc:	69d5      	ldr	r5, [r2, #28]
        context->fcr_shadow.TET =
  1494de:	6a12      	ldr	r2, [r2, #32]
        context->fcr_shadow.XFIFOR = 1;
  1494e0:	f043 0306 	orr.w	r3, r3, #6
        context->fifo_enable = true;
  1494e4:	2401      	movs	r4, #1
        context->fcr_shadow.XFIFOR = 1;
  1494e6:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  1494e8:	684b      	ldr	r3, [r1, #4]
  1494ea:	6083      	str	r3, [r0, #8]
        context->fcr_shadow.RFIFOR = 0;
  1494ec:	790b      	ldrb	r3, [r1, #4]
        context->fcr_shadow.RT = cfg->fifo_cfg.rx_trigger;  //receive trigger
  1494ee:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
  1494f2:	f365 1387 	bfi	r3, r5, #6, #2
        context->fcr_shadow.TET =
  1494f6:	f362 1305 	bfi	r3, r2, #4, #2
        context->fcr_shadow.FIFOE = 1;
  1494fa:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  1494fe:	4323      	orrs	r3, r4
  149500:	710b      	strb	r3, [r1, #4]
        dev->FCR.v = context->fcr_shadow.v;
  149502:	684b      	ldr	r3, [r1, #4]
  149504:	6083      	str	r3, [r0, #8]
        context->fifo_enable = true;
  149506:	700c      	strb	r4, [r1, #0]
  149508:	e7b9      	b.n	14947e <uart_drv_init+0xce>
            if (dev->LCR.DLS != 0)
  14950a:	68c3      	ldr	r3, [r0, #12]
  14950c:	079c      	lsls	r4, r3, #30
  14950e:	d097      	beq.n	149440 <uart_drv_init+0x90>
                ASSERT(0);
  149510:	f645 7370 	movw	r3, #24432	; 0x5f70
  149514:	f645 723c 	movw	r2, #24380	; 0x5f3c
  149518:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14951c:	f2c0 0315 	movt	r3, #21
  149520:	4670      	mov	r0, r14
  149522:	f2c0 0215 	movt	r2, #21
  149526:	9300      	str	r3, [sp, #0]
  149528:	f2c0 0115 	movt	r1, #21
  14952c:	2352      	movs	r3, #82	; 0x52
  14952e:	f009 fbc1 	bl	152cb4 <_panic>
            dev->LCR.EPS = 0;
  149532:	68c3      	ldr	r3, [r0, #12]
  149534:	f36f 1304 	bfc	r3, #4, #1
  149538:	60c3      	str	r3, [r0, #12]
            dev->LCR.PEN = 1;
  14953a:	68c3      	ldr	r3, [r0, #12]
  14953c:	f043 0308 	orr.w	r3, r3, #8
  149540:	60c3      	str	r3, [r0, #12]
  149542:	e78c      	b.n	14945e <uart_drv_init+0xae>
            ASSERT(0); /* no other bits*/
  149544:	f645 7370 	movw	r3, #24432	; 0x5f70
  149548:	f645 723c 	movw	r2, #24380	; 0x5f3c
  14954c:	f644 316c 	movw	r1, #19308	; 0x4b6c
  149550:	f2c0 0315 	movt	r3, #21
  149554:	4670      	mov	r0, r14
  149556:	f2c0 0215 	movt	r2, #21
  14955a:	9300      	str	r3, [sp, #0]
  14955c:	f2c0 0115 	movt	r1, #21
  149560:	2346      	movs	r3, #70	; 0x46
  149562:	f009 fba7 	bl	152cb4 <_panic>
            ASSERT(0);
  149566:	f645 7370 	movw	r3, #24432	; 0x5f70
  14956a:	f645 723c 	movw	r2, #24380	; 0x5f3c
  14956e:	f644 316c 	movw	r1, #19308	; 0x4b6c
  149572:	f2c0 0315 	movt	r3, #21
  149576:	4670      	mov	r0, r14
  149578:	f2c0 0215 	movt	r2, #21
  14957c:	9300      	str	r3, [sp, #0]
  14957e:	f2c0 0115 	movt	r1, #21
  149582:	235f      	movs	r3, #95	; 0x5f
  149584:	f009 fb96 	bl	152cb4 <_panic>
            ASSERT(0);
  149588:	f645 7370 	movw	r3, #24432	; 0x5f70
  14958c:	f645 723c 	movw	r2, #24380	; 0x5f3c
  149590:	f644 316c 	movw	r1, #19308	; 0x4b6c
  149594:	f2c0 0315 	movt	r3, #21
  149598:	4670      	mov	r0, r14
  14959a:	f2c0 0215 	movt	r2, #21
  14959e:	9300      	str	r3, [sp, #0]
  1495a0:	f2c0 0115 	movt	r1, #21
  1495a4:	2374      	movs	r3, #116	; 0x74
  1495a6:	f009 fb85 	bl	152cb4 <_panic>
                ASSERT(0);
  1495aa:	f645 7370 	movw	r3, #24432	; 0x5f70
  1495ae:	f645 723c 	movw	r2, #24380	; 0x5f3c
  1495b2:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1495b6:	f2c0 0315 	movt	r3, #21
  1495ba:	4670      	mov	r0, r14
  1495bc:	f2c0 0215 	movt	r2, #21
  1495c0:	9300      	str	r3, [sp, #0]
  1495c2:	f2c0 0115 	movt	r1, #21
  1495c6:	2359      	movs	r3, #89	; 0x59
  1495c8:	f009 fb74 	bl	152cb4 <_panic>

001495cc <uart_drv_putc>:
        if (context->fifo_enable) {
  1495cc:	780b      	ldrb	r3, [r1, #0]
  1495ce:	b123      	cbz	r3, 1495da <uart_drv_putc+0xe>
            while (dev->USR.TFNF != 1); //wait transmit fifo is not full
  1495d0:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
  1495d2:	0799      	lsls	r1, r3, #30
  1495d4:	d5fc      	bpl.n	1495d0 <uart_drv_putc+0x4>
        writeb(data, &dev->THR);
  1495d6:	7002      	strb	r2, [r0, #0]
}
  1495d8:	4770      	bx	r14
            while (dev->LSR.THRE != 1); //wait transmit holding register empty
  1495da:	6943      	ldr	r3, [r0, #20]
  1495dc:	069b      	lsls	r3, r3, #26
  1495de:	d4fa      	bmi.n	1495d6 <uart_drv_putc+0xa>
  1495e0:	6943      	ldr	r3, [r0, #20]
  1495e2:	069b      	lsls	r3, r3, #26
  1495e4:	d5f9      	bpl.n	1495da <uart_drv_putc+0xe>
  1495e6:	e7f6      	b.n	1495d6 <uart_drv_putc+0xa>

001495e8 <uart_drv_int_cbk_register>:
void uart_drv_int_cbk_register(uart_drv_context_t *context,
                               uart_drv_int_src_t int_src,
                               uart_drv_int_callback cbk)

{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  1495e8:	b129      	cbz	r1, 1495f6 <uart_drv_int_cbk_register+0xe>
        context->rx_char_cbk = cbk;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  1495ea:	2901      	cmp	r1, #1
  1495ec:	d005      	beq.n	1495fa <uart_drv_int_cbk_register+0x12>
        context->rx_str_cbk = cbk;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  1495ee:	2902      	cmp	r1, #2
        context->tx_str_cbk = cbk;
  1495f0:	bf08      	it	eq
  1495f2:	6102      	streq	r2, [r0, #16]
    }
}
  1495f4:	4770      	bx	r14
        context->rx_char_cbk = cbk;
  1495f6:	6082      	str	r2, [r0, #8]
  1495f8:	4770      	bx	r14
        context->rx_str_cbk = cbk;
  1495fa:	60c2      	str	r2, [r0, #12]
  1495fc:	4770      	bx	r14
  1495fe:	bf00      	nop

00149600 <uart_drv_int_src_enable>:

void uart_drv_int_src_enable(DW_APB_UART_uart_TypeDef *dev,
                             uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  149600:	b141      	cbz	r1, 149614 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  149602:	2901      	cmp	r1, #1
  149604:	d006      	beq.n	149614 <uart_drv_int_src_enable+0x14>
        dev->IER.ERBFI = 1;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  149606:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 1;
  149608:	bf02      	ittt	eq
  14960a:	6843      	ldreq	r3, [r0, #4]
  14960c:	f043 0302 	orreq.w	r3, r3, #2
  149610:	6043      	streq	r3, [r0, #4]
    }
}
  149612:	4770      	bx	r14
        dev->IER.ERBFI = 1;
  149614:	6843      	ldr	r3, [r0, #4]
  149616:	f043 0301 	orr.w	r3, r3, #1
  14961a:	6043      	str	r3, [r0, #4]
  14961c:	4770      	bx	r14
  14961e:	bf00      	nop

00149620 <uart_drv_int_src_disable>:

void uart_drv_int_src_disable(DW_APB_UART_uart_TypeDef *dev,
                              uart_drv_int_src_t int_src)
{
    if (int_src == UART_DRV_RX_CHAR_INT_SRC) {
  149620:	b141      	cbz	r1, 149634 <uart_drv_int_src_disable+0x14>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_RX_STRING_INT_SRC) {
  149622:	2901      	cmp	r1, #1
  149624:	d00b      	beq.n	14963e <uart_drv_int_src_disable+0x1e>
        dev->IER.ERBFI = 0;
    }
    else if (int_src == UART_DRV_TX_EMPTY_INT_SRC) {
  149626:	2902      	cmp	r1, #2
        dev->IER.ETBEI = 0;
  149628:	bf02      	ittt	eq
  14962a:	6843      	ldreq	r3, [r0, #4]
  14962c:	f36f 0341 	bfceq	r3, #1, #1
  149630:	6043      	streq	r3, [r0, #4]
    }
}
  149632:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  149634:	6843      	ldr	r3, [r0, #4]
  149636:	f361 0300 	bfi	r3, r1, #0, #1
  14963a:	6043      	str	r3, [r0, #4]
  14963c:	4770      	bx	r14
        dev->IER.ERBFI = 0;
  14963e:	6843      	ldr	r3, [r0, #4]
  149640:	f36f 0300 	bfc	r3, #0, #1
  149644:	6043      	str	r3, [r0, #4]
  149646:	4770      	bx	r14

00149648 <uart_drv_irq_handle>:
enum handler_return uart_drv_irq_handle(DW_APB_UART_uart_TypeDef *dev,
                                        uart_drv_context_t *context)
{
    bool resched = true;
    char data = 0;
    IIR_Type IIR = dev->IIR;        //interrupt identification register
  149648:	6883      	ldr	r3, [r0, #8]
{
  14964a:	b570      	push	{r4, r5, r6, r14}
  14964c:	460c      	mov	r4, r1
    LSR_Type LSR = dev->LSR;        //line status register

    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  14964e:	b2db      	uxtb	r3, r3
{
  149650:	4605      	mov	r5, r0
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  149652:	f003 020d 	and.w	r2, r3, #13
    LSR_Type LSR = dev->LSR;        //line status register
  149656:	6941      	ldr	r1, [r0, #20]
    if (IIR.IID == UART_DRV_IID_RX_DATA_AVAILABLE
  149658:	2a04      	cmp	r2, #4
  14965a:	d13a      	bne.n	1496d2 <uart_drv_irq_handle+0x8a>
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
        //rx irq
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
                || LSR.ADDR_RCVD == UART_DRV_LSR_RX_ADDR_IND) {
  14965c:	f240 1301 	movw	r3, #257	; 0x101
        if (LSR.DR == UART_DRV_LSR_RX_DATA_READY
  149660:	420b      	tst	r3, r1
  149662:	d034      	beq.n	1496ce <uart_drv_irq_handle+0x86>
            if (context->fifo_enable) {
  149664:	7826      	ldrb	r6, [r4, #0]
  149666:	68e2      	ldr	r2, [r4, #12]
  149668:	2e00      	cmp	r6, #0
  14966a:	d163      	bne.n	149734 <uart_drv_irq_handle+0xec>
                    }
                }
                else
#endif
                {
                    data = dev->RBR.RBR8;
  14966c:	6800      	ldr	r0, [r0, #0]
  14966e:	b2c0      	uxtb	r0, r0
                }

                //asynchronous receive
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  149670:	2a00      	cmp	r2, #0
  149672:	d079      	beq.n	149768 <uart_drv_irq_handle+0x120>
  149674:	6a23      	ldr	r3, [r4, #32]
  149676:	2b00      	cmp	r3, #0
  149678:	d076      	beq.n	149768 <uart_drv_irq_handle+0x120>
    *context->rx_shadow.rx_ptr = data;
  14967a:	69e3      	ldr	r3, [r4, #28]
  14967c:	7018      	strb	r0, [r3, #0]
    context->rx_shadow.len_rest -= 1;
  14967e:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  149682:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  149684:	3b01      	subs	r3, #1
  149686:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  14968a:	b96b      	cbnz	r3, 1496a8 <uart_drv_irq_handle+0x60>
        dev->IER.ERBFI = 0;
  14968c:	686a      	ldr	r2, [r5, #4]
  14968e:	f363 0200 	bfi	r2, r3, #0, #1
  149692:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  149694:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  149696:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  149698:	f363 1205 	bfi	r2, r3, #4, #2
  14969c:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  14969e:	6862      	ldr	r2, [r4, #4]
  1496a0:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  1496a2:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  1496a4:	4788      	blx	r1
  1496a6:	6a23      	ldr	r3, [r4, #32]
                    uart_drv_async_rx_char(dev, context, data);

                    if (context->rx_shadow.len_rest) {
  1496a8:	fab3 f083 	clz	r0, r3
  1496ac:	0940      	lsrs	r0, r0, #5
            }
        }
    }

    return resched ? INT_RESCHEDULE : INT_NO_RESCHEDULE;
}
  1496ae:	bd70      	pop	{r4, r5, r6, r15}
            if (context->tx_shadow.len_rest && dev->LSR.THRE) {
  1496b0:	2b00      	cmp	r3, #0
  1496b2:	d065      	beq.n	149780 <uart_drv_irq_handle+0x138>
  1496b4:	6943      	ldr	r3, [r0, #20]
  1496b6:	069b      	lsls	r3, r3, #26
  1496b8:	d509      	bpl.n	1496ce <uart_drv_irq_handle+0x86>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  1496ba:	6963      	ldr	r3, [r4, #20]
  1496bc:	1c5a      	adds	r2, r3, #1
  1496be:	6162      	str	r2, [r4, #20]
  1496c0:	781b      	ldrb	r3, [r3, #0]
  1496c2:	7003      	strb	r3, [r0, #0]
                context->tx_shadow.len_rest -= 1;
  1496c4:	69a3      	ldr	r3, [r4, #24]
  1496c6:	3b01      	subs	r3, #1
  1496c8:	61a3      	str	r3, [r4, #24]
        if (context->tx_shadow.len_rest == 0) {
  1496ca:	2b00      	cmp	r3, #0
  1496cc:	d058      	beq.n	149780 <uart_drv_irq_handle+0x138>
  1496ce:	2001      	movs	r0, #1
}
  1496d0:	bd70      	pop	{r4, r5, r6, r15}
            || IIR.IID == UART_DRV_IID_RX_LINE_STATUS) {
  1496d2:	f003 030f 	and.w	r3, r3, #15
    else if (IIR.IID == UART_DRV_IID_RX_CHAR_TIMEOUT) {
  1496d6:	2b0c      	cmp	r3, #12
  1496d8:	d043      	beq.n	149762 <uart_drv_irq_handle+0x11a>
    else if (IIR.IID == UART_DRV_IID_THR_EMPTY) {
  1496da:	2b02      	cmp	r3, #2
  1496dc:	d1f7      	bne.n	1496ce <uart_drv_irq_handle+0x86>
  1496de:	69a3      	ldr	r3, [r4, #24]
        if (context->fifo_enable) {
  1496e0:	7822      	ldrb	r2, [r4, #0]
  1496e2:	2a00      	cmp	r2, #0
  1496e4:	d0e4      	beq.n	1496b0 <uart_drv_irq_handle+0x68>
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  1496e6:	b953      	cbnz	r3, 1496fe <uart_drv_irq_handle+0xb6>
  1496e8:	e04a      	b.n	149780 <uart_drv_irq_handle+0x138>
                writeb(*context->tx_shadow.tx_ptr++, &dev->THR);
  1496ea:	6963      	ldr	r3, [r4, #20]
  1496ec:	1c5a      	adds	r2, r3, #1
  1496ee:	6162      	str	r2, [r4, #20]
  1496f0:	781b      	ldrb	r3, [r3, #0]
  1496f2:	702b      	strb	r3, [r5, #0]
                context->tx_shadow.len_rest -= 1;
  1496f4:	69a3      	ldr	r3, [r4, #24]
  1496f6:	3b01      	subs	r3, #1
  1496f8:	61a3      	str	r3, [r4, #24]
            while (context->tx_shadow.len_rest && dev->USR.TFNF) {
  1496fa:	2b00      	cmp	r3, #0
  1496fc:	d040      	beq.n	149780 <uart_drv_irq_handle+0x138>
  1496fe:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  149700:	079a      	lsls	r2, r3, #30
  149702:	d5e4      	bpl.n	1496ce <uart_drv_irq_handle+0x86>
  149704:	e7f1      	b.n	1496ea <uart_drv_irq_handle+0xa2>
    *context->rx_shadow.rx_ptr = data;
  149706:	69e2      	ldr	r2, [r4, #28]
  149708:	7013      	strb	r3, [r2, #0]
    context->rx_shadow.len_rest -= 1;
  14970a:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
    context->rx_shadow.rx_ptr++;
  14970e:	3201      	adds	r2, #1
    context->rx_shadow.len_rest -= 1;
  149710:	3b01      	subs	r3, #1
  149712:	e9c4 2307 	strd	r2, r3, [r4, #28]
    if (context->rx_shadow.len_rest == 0) {
  149716:	b963      	cbnz	r3, 149732 <uart_drv_irq_handle+0xea>
        dev->IER.ERBFI = 0;
  149718:	686a      	ldr	r2, [r5, #4]
  14971a:	f363 0200 	bfi	r2, r3, #0, #1
  14971e:	606a      	str	r2, [r5, #4]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  149720:	7922      	ldrb	r2, [r4, #4]
        context->rx_str_cbk(data);
  149722:	68e1      	ldr	r1, [r4, #12]
        context->fcr_shadow.TET = UART_DRV_RX_FIFO_CHAR_1;
  149724:	f363 1205 	bfi	r2, r3, #4, #2
  149728:	7122      	strb	r2, [r4, #4]
        dev->FCR.v = context->fcr_shadow.v;
  14972a:	6862      	ldr	r2, [r4, #4]
  14972c:	60aa      	str	r2, [r5, #8]
        context->rx_shadow.rx_ptr = NULL;
  14972e:	61e3      	str	r3, [r4, #28]
        context->rx_str_cbk(data);
  149730:	4788      	blx	r1
  149732:	68e2      	ldr	r2, [r4, #12]
                while (dev->USR.RFNE) {
  149734:	6feb      	ldr	r3, [r5, #124]	; 0x7c
  149736:	0719      	lsls	r1, r3, #28
  149738:	d50e      	bpl.n	149758 <uart_drv_irq_handle+0x110>
                        data = dev->RBR.RBR8;
  14973a:	682b      	ldr	r3, [r5, #0]
  14973c:	b2db      	uxtb	r3, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  14973e:	b11a      	cbz	r2, 149748 <uart_drv_irq_handle+0x100>
  149740:	6a21      	ldr	r1, [r4, #32]
        context->rx_str_cbk(data);
  149742:	4618      	mov	r0, r3
                    if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  149744:	2900      	cmp	r1, #0
  149746:	d1de      	bne.n	149706 <uart_drv_irq_handle+0xbe>
                             || (context->rx_char_cbk(data) != 1)) {
  149748:	4618      	mov	r0, r3
                    else if ((context->rx_char_cbk == NULL)
  14974a:	68a3      	ldr	r3, [r4, #8]
  14974c:	b31b      	cbz	r3, 149796 <uart_drv_irq_handle+0x14e>
                             || (context->rx_char_cbk(data) != 1)) {
  14974e:	4798      	blx	r3
  149750:	2801      	cmp	r0, #1
  149752:	d0ee      	beq.n	149732 <uart_drv_irq_handle+0xea>
  149754:	68e2      	ldr	r2, [r4, #12]
                        resched = false;
  149756:	2600      	movs	r6, #0
                if ((context->rx_str_cbk) && (context->rx_shadow.len_rest)) {
  149758:	b182      	cbz	r2, 14977c <uart_drv_irq_handle+0x134>
  14975a:	6a23      	ldr	r3, [r4, #32]
  14975c:	b173      	cbz	r3, 14977c <uart_drv_irq_handle+0x134>
  14975e:	2000      	movs	r0, #0
}
  149760:	bd70      	pop	{r4, r5, r6, r15}
        data = dev->RBR.RBR8;
  149762:	6803      	ldr	r3, [r0, #0]
  149764:	2001      	movs	r0, #1
}
  149766:	bd70      	pop	{r4, r5, r6, r15}
                else if ((context->rx_char_cbk == NULL)
  149768:	68a3      	ldr	r3, [r4, #8]
  14976a:	2b00      	cmp	r3, #0
  14976c:	d0f7      	beq.n	14975e <uart_drv_irq_handle+0x116>
                         || (context->rx_char_cbk(data) != 1)) {
  14976e:	4798      	blx	r3
  149770:	f1a0 0001 	sub.w	r0, r0, #1
  149774:	fab0 f080 	clz	r0, r0
  149778:	0940      	lsrs	r0, r0, #5
}
  14977a:	bd70      	pop	{r4, r5, r6, r15}
  14977c:	4630      	mov	r0, r6
  14977e:	bd70      	pop	{r4, r5, r6, r15}
        dev->IER.ETBEI = 0;
  149780:	686b      	ldr	r3, [r5, #4]
  149782:	f36f 0341 	bfc	r3, #1, #1
  149786:	606b      	str	r3, [r5, #4]
            if (context->tx_str_cbk) {
  149788:	6923      	ldr	r3, [r4, #16]
  14978a:	2b00      	cmp	r3, #0
  14978c:	d09f      	beq.n	1496ce <uart_drv_irq_handle+0x86>
                context->tx_str_cbk(true);
  14978e:	2001      	movs	r0, #1
  149790:	4798      	blx	r3
  149792:	2001      	movs	r0, #1
}
  149794:	bd70      	pop	{r4, r5, r6, r15}
                        resched = false;
  149796:	461e      	mov	r6, r3
  149798:	e7de      	b.n	149758 <uart_drv_irq_handle+0x110>
  14979a:	bf00      	nop

0014979c <wdg_unlock>:
//!
//! \return None.
//
//*****************************************************************************
static bool wdg_unlock(wdg_reg_type_t *base,uint32_t unlock_mask)
{
  14979c:	b410      	push	{r4}
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14979e:	2400      	movs	r4, #0
{
  1497a0:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  1497a2:	4622      	mov	r2, r4
  1497a4:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  1497a8:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  1497ac:	42a0      	cmp	r0, r4
  1497ae:	bf18      	it	ne
  1497b0:	4290      	cmpne	r0, r2
  1497b2:	d007      	beq.n	1497c4 <wdg_unlock+0x28>
  1497b4:	2200      	movs	r2, #0
  1497b6:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  1497ba:	4290      	cmp	r0, r2
  1497bc:	bf18      	it	ne
  1497be:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  1497c2:	d107      	bne.n	1497d4 <wdg_unlock+0x38>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_unlock:lock_mask:%d\n",unlock_mask);

    base->wdg_lock &=~unlock_mask;
  1497c4:	6c5a      	ldr	r2, [r3, #68]	; 0x44

    return true;
  1497c6:	2001      	movs	r0, #1
    base->wdg_lock &=~unlock_mask;
  1497c8:	ea22 0101 	bic.w	r1, r2, r1
  1497cc:	6459      	str	r1, [r3, #68]	; 0x44
}
  1497ce:	f85d 4b04 	ldr.w	r4, [r13], #4
  1497d2:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  1497d4:	2000      	movs	r0, #0
  1497d6:	4602      	mov	r2, r0
  1497d8:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  1497dc:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  1497e0:	4283      	cmp	r3, r0
  1497e2:	bf18      	it	ne
  1497e4:	4293      	cmpne	r3, r2
  1497e6:	d0ed      	beq.n	1497c4 <wdg_unlock+0x28>
  1497e8:	2000      	movs	r0, #0
  1497ea:	4602      	mov	r2, r0
  1497ec:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  1497f0:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  1497f4:	4283      	cmp	r3, r0
  1497f6:	bf18      	it	ne
  1497f8:	4293      	cmpne	r3, r2
  1497fa:	bf18      	it	ne
  1497fc:	2000      	movne	r0, #0
  1497fe:	d0e1      	beq.n	1497c4 <wdg_unlock+0x28>
  149800:	e7e5      	b.n	1497ce <wdg_unlock+0x32>
  149802:	bf00      	nop

00149804 <wdg_addr_to_number>:
static uint32_t wdg_addr_to_number(wdg_reg_type_t *base)
{
    uint32_t wdg_number = wdg_really_num1;

    // Check the arguments.
    ASSERT_PARAMETER(base);
  149804:	2300      	movs	r3, #0
  149806:	461a      	mov	r2, r3
  149808:	f2cf 031c 	movt	r3, #61468	; 0xf01c
  14980c:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  149810:	4298      	cmp	r0, r3
  149812:	bf18      	it	ne
  149814:	4290      	cmpne	r0, r2
  149816:	d02b      	beq.n	149870 <wdg_addr_to_number+0x6c>
  149818:	2300      	movs	r3, #0
  14981a:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14981e:	4298      	cmp	r0, r3
  149820:	bf18      	it	ne
  149822:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149826:	d127      	bne.n	149878 <wdg_addr_to_number+0x74>

    if(WDG1_BASE == base){
        wdg_number = wdg_really_num1;
    }else if(WDG2_BASE == base){
  149828:	2300      	movs	r3, #0
  14982a:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14982e:	4298      	cmp	r0, r3
  149830:	d03a      	beq.n	1498a8 <wdg_addr_to_number+0xa4>
        wdg_number = wdg_really_num2;
    }else if(WDG3_BASE == base){
  149832:	f110 6f76 	cmn.w	r0, #257949696	; 0xf600000
  149836:	d035      	beq.n	1498a4 <wdg_addr_to_number+0xa0>
        wdg_number = wdg_really_num3;
    }else if(WDG4_BASE == base){
  149838:	2300      	movs	r3, #0
  14983a:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14983e:	4298      	cmp	r0, r3
  149840:	d034      	beq.n	1498ac <wdg_addr_to_number+0xa8>
        wdg_number = wdg_really_num4;
    }else if(WDG5_BASE == base){
  149842:	2300      	movs	r3, #0
  149844:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
  149848:	4298      	cmp	r0, r3
  14984a:	d031      	beq.n	1498b0 <wdg_addr_to_number+0xac>
        wdg_number = wdg_really_num5;
    }else if(WDG6_BASE == base){
  14984c:	2300      	movs	r3, #0
  14984e:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149852:	4298      	cmp	r0, r3
  149854:	d02e      	beq.n	1498b4 <wdg_addr_to_number+0xb0>
        wdg_number = wdg_really_num6;
    }else if(WDG7_BASE == base){
  149856:	2300      	movs	r3, #0
  149858:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
  14985c:	4298      	cmp	r0, r3
  14985e:	d02b      	beq.n	1498b8 <wdg_addr_to_number+0xb4>
        wdg_number = wdg_really_num7;
    }else if(WDG8_BASE == base){
  149860:	2300      	movs	r3, #0
  149862:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
        wdg_number = wdg_really_num8;
  149866:	4298      	cmp	r0, r3
  149868:	bf14      	ite	ne
  14986a:	2001      	movne	r0, #1
  14986c:	2008      	moveq	r0, #8
  14986e:	4770      	bx	r14
    if(WDG1_BASE == base){
  149870:	4298      	cmp	r0, r3
  149872:	d1d9      	bne.n	149828 <wdg_addr_to_number+0x24>
    }else{
        wdg_number = wdg_really_num1;
  149874:	2001      	movs	r0, #1
  149876:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149878:	2200      	movs	r2, #0
  14987a:	4613      	mov	r3, r2
  14987c:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149880:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149884:	4290      	cmp	r0, r2
  149886:	bf18      	it	ne
  149888:	4298      	cmpne	r0, r3
  14988a:	d0cd      	beq.n	149828 <wdg_addr_to_number+0x24>
  14988c:	2200      	movs	r2, #0
  14988e:	4613      	mov	r3, r2
  149890:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149894:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149898:	4290      	cmp	r0, r2
  14989a:	bf18      	it	ne
  14989c:	4298      	cmpne	r0, r3
  14989e:	d0c3      	beq.n	149828 <wdg_addr_to_number+0x24>
  1498a0:	2000      	movs	r0, #0
  1498a2:	4770      	bx	r14
        wdg_number = wdg_really_num3;
  1498a4:	2003      	movs	r0, #3
  1498a6:	4770      	bx	r14
        wdg_number = wdg_really_num2;
  1498a8:	2002      	movs	r0, #2
  1498aa:	4770      	bx	r14
        wdg_number = wdg_really_num4;
  1498ac:	2004      	movs	r0, #4
  1498ae:	4770      	bx	r14
        wdg_number = wdg_really_num5;
  1498b0:	2005      	movs	r0, #5
  1498b2:	4770      	bx	r14
        wdg_number = wdg_really_num6;
  1498b4:	2006      	movs	r0, #6
  1498b6:	4770      	bx	r14
        wdg_number = wdg_really_num7;
  1498b8:	2007      	movs	r0, #7
    }

    return wdg_number;
}
  1498ba:	4770      	bx	r14

001498bc <wdg_get_default_config>:
    if(!wdg_config){
  1498bc:	2800      	cmp	r0, #0
  1498be:	d044      	beq.n	14994a <wdg_get_default_config+0x8e>
    wdg_config->wdg_ctrl_config.clockSource = wdg_main_clk;
  1498c0:	2300      	movs	r3, #0
    wdg_config->wdg_ctrl_config.enableSoftRest = true;
  1498c2:	2201      	movs	r2, #1
{
  1498c4:	b430      	push	{r4, r5}
    wdg_config->refresh_wind_limit = DEFAULT_WATCHOUT_WIN_LOW_LIMIT;
  1498c6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    wdg_config->wdg_ctrl_config.prescaler = 11999U;
  1498ca:	f642 65df 	movw	r5, #11999	; 0x2edf
    wdg_config->wdg_ctrl_config.clockSource = wdg_main_clk;
  1498ce:	6043      	str	r3, [r0, #4]
    wdg_config->wdg_timeout = DEFAULT_WATCHOUT_TIMEOUT_TIME;
  1498d0:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    wdg_config->wdg_ctrl_config.prescaler = 11999U;
  1498d4:	81c5      	strh	r5, [r0, #14]
    wdg_config->wdg_timeout = DEFAULT_WATCHOUT_TIMEOUT_TIME;
  1498d6:	6104      	str	r4, [r0, #16]
    wdg_config->wdg_ctrl_config.enableAutostart = false;
  1498d8:	7243      	strb	r3, [r0, #9]
    wdg_config->wdg_ctrl_config.enableDebugmode = false;
  1498da:	7283      	strb	r3, [r0, #10]
    wdg_config->wdg_ctrl_config.enableSelftest = false;
  1498dc:	7303      	strb	r3, [r0, #12]
    wdg_config->wdg_ctrl_config.enableWdg = false;
  1498de:	7043      	strb	r3, [r0, #1]
    wdg_config->wdg_refresh_config.enableRefreshTrig = false;
  1498e0:	7583      	strb	r3, [r0, #22]
    wdg_config->wdg_refresh_config.enableSeqRefresh = false;
  1498e2:	7543      	strb	r3, [r0, #21]
    wdg_config->wdg_reset_cfg.enableSysReset = false;
  1498e4:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22
    wdg_config->wdg_reset_cfg.enableWdgResetEn = false;
  1498e8:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    wdg_config->wdg_reset_cfg.plusRstWind = 0x0U;
  1498ec:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
    wdg_config->wdg_reset_cfg.SysRstMode = 0x0U;
  1498f0:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
    wdg_config->wdg_reset_cfg.wdgResetCnt = 0x0U;
  1498f4:	8403      	strh	r3, [r0, #32]
    wdg_config->wdg_ext_reset_cfg.plusRstWind = 0x0U;
  1498f6:	f880 302a 	strb.w	r3, [r0, #42]	; 0x2a
    wdg_config->wdg_ext_reset_cfg.SysExtRstMode = 0x0U;
  1498fa:	f880 3029 	strb.w	r3, [r0, #41]	; 0x29
    wdg_config->wdg_ext_reset_cfg.wdgResetCnt = 0x0U;
  1498fe:	84c3      	strh	r3, [r0, #38]	; 0x26
    wdg_config->wdg_int_cfg.ill_seq_refr_int_clr = false;
  149900:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    wdg_config->wdg_int_cfg.ill_seq_refr_int_en = false;
  149904:	f880 3031 	strb.w	r3, [r0, #49]	; 0x31
    wdg_config->wdg_int_cfg.ill_win_refr_int_clr = false;
  149908:	f880 3033 	strb.w	r3, [r0, #51]	; 0x33
    wdg_config->wdg_int_cfg.ill_win_refr_int_en = false;
  14990c:	f880 3030 	strb.w	r3, [r0, #48]	; 0x30
    wdg_config->wdg_lock_cfg.clk_src_lock = false;
  149910:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    wdg_config->wdg_ctrl_config.enableSoftRest = true;
  149914:	7002      	strb	r2, [r0, #0]
    wdg_config->wdg_ctrl_config.enableSrcSelect = 0x1U;
  149916:	72c2      	strb	r2, [r0, #11]
    wdg_config->wdg_ctrl_config.terminalCountSrc = 0x1U;
  149918:	7202      	strb	r2, [r0, #8]
    wdg_config->wdg_refresh_config.wdgModeSelect = wdg_mechanism_mode1;
  14991a:	7502      	strb	r2, [r0, #20]
    wdg_config->wdg_ext_reset_cfg.enableSysExtReset = true;
  14991c:	f880 2028 	strb.w	r2, [r0, #40]	; 0x28
    wdg_config->wdg_int_cfg.overflow_int_clr = true;
  149920:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
    wdg_config->wdg_int_cfg.overflow_int_en = true;
  149924:	f880 2032 	strb.w	r2, [r0, #50]	; 0x32
    wdg_config->refresh_seq_delta = DEFAULT_WATCHOUT_SEQ_DELTA;
  149928:	e9c0 1106 	strd	r1, r1, [r0, #24]
    wdg_config->wdg_tsw = DEFAULT_WATCHOUT_TIMESTAMP;
  14992c:	62c1      	str	r1, [r0, #44]	; 0x2c
    wdg_config->wdg_lock_cfg.ctl_lock = false;
  14992e:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
    wdg_config->wdg_lock_cfg.ext_rst_lock = false;
  149932:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
    wdg_config->wdg_lock_cfg.int_lock = false;
  149936:	f880 303b 	strb.w	r3, [r0, #59]	; 0x3b
    wdg_config->wdg_lock_cfg.rst_lock = false;
  14993a:	f880 3039 	strb.w	r3, [r0, #57]	; 0x39
    wdg_config->wdg_lock_cfg.wrc_lock = false;
  14993e:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38
    wdg_config->wdg_lock_cfg.wtc_lock = false;
  149942:	f880 3037 	strb.w	r3, [r0, #55]	; 0x37
}
  149946:	bc30      	pop	{r4, r5}
  149948:	4770      	bx	r14
  14994a:	4770      	bx	r14

0014994c <wdg_set_timeout>:
{
  14994c:	b570      	push	{r4, r5, r6, r14}
    ASSERT_PARAMETER(base);
  14994e:	2400      	movs	r4, #0
  149950:	4622      	mov	r2, r4
  149952:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  149956:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14995a:	42a0      	cmp	r0, r4
  14995c:	bf18      	it	ne
  14995e:	4290      	cmpne	r0, r2
  149960:	d01d      	beq.n	14999e <wdg_set_timeout+0x52>
  149962:	2200      	movs	r2, #0
  149964:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  149968:	4290      	cmp	r0, r2
  14996a:	bf18      	it	ne
  14996c:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149970:	d015      	beq.n	14999e <wdg_set_timeout+0x52>
  149972:	2200      	movs	r2, #0
  149974:	4613      	mov	r3, r2
  149976:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14997a:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14997e:	4290      	cmp	r0, r2
  149980:	bf18      	it	ne
  149982:	4298      	cmpne	r0, r3
  149984:	d00b      	beq.n	14999e <wdg_set_timeout+0x52>
  149986:	2200      	movs	r2, #0
  149988:	4613      	mov	r3, r2
  14998a:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14998e:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149992:	4290      	cmp	r0, r2
  149994:	bf18      	it	ne
  149996:	4298      	cmpne	r0, r3
  149998:	bf18      	it	ne
  14999a:	2000      	movne	r0, #0
  14999c:	d123      	bne.n	1499e6 <wdg_set_timeout+0x9a>
  14999e:	4604      	mov	r4, r0
  1499a0:	460d      	mov	r5, r1
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  1499a2:	6800      	ldr	r0, [r0, #0]
    freq = g_clk_select[clk_mask];
  1499a4:	f645 7174 	movw	r1, #24436	; 0x5f74
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  1499a8:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    freq = g_clk_select[clk_mask];
  1499ac:	f2c0 0115 	movt	r1, #21
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  1499b0:	6822      	ldr	r2, [r4, #0]
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  1499b2:	f3c0 0082 	ubfx	r0, r0, #2, #3
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  1499b6:	f2c1 0662 	movt	r6, #4194	; 0x1062
  1499ba:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  1499be:	0c12      	lsrs	r2, r2, #16
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
  1499c0:	2102      	movs	r1, #2
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  1499c2:	3201      	adds	r2, #1
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
  1499c4:	4620      	mov	r0, r4
    wtcon = timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  1499c6:	fbb3 f3f2 	udiv	r3, r3, r2
  1499ca:	fba6 2303 	umull	r2, r3, r6, r3
  1499ce:	099b      	lsrs	r3, r3, #6
  1499d0:	fb05 f503 	mul.w	r5, r5, r3
    wdg_unlock(base,WDG_LOCK_WTC_LOCK_MASK);
  1499d4:	f7ff fee2 	bl	14979c <wdg_unlock>
    base->wdg_wtc &= ~WDG_WTC_MASK;
  1499d8:	2300      	movs	r3, #0
    return true;
  1499da:	2001      	movs	r0, #1
    base->wdg_wtc &= ~WDG_WTC_MASK;
  1499dc:	6862      	ldr	r2, [r4, #4]
  1499de:	6063      	str	r3, [r4, #4]
    base->wdg_wtc |= wtcon;
  1499e0:	6863      	ldr	r3, [r4, #4]
  1499e2:	432b      	orrs	r3, r5
  1499e4:	6063      	str	r3, [r4, #4]
}
  1499e6:	bd70      	pop	{r4, r5, r6, r15}

001499e8 <wdg_set_window_limit>:
{
  1499e8:	b470      	push	{r4, r5, r6}
    ASSERT_PARAMETER(base);
  1499ea:	2400      	movs	r4, #0
{
  1499ec:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  1499ee:	4622      	mov	r2, r4
  1499f0:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  1499f4:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  1499f8:	42a0      	cmp	r0, r4
  1499fa:	bf18      	it	ne
  1499fc:	4290      	cmpne	r0, r2
  1499fe:	d007      	beq.n	149a10 <wdg_set_window_limit+0x28>
  149a00:	2200      	movs	r2, #0
  149a02:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  149a06:	4290      	cmp	r0, r2
  149a08:	bf18      	it	ne
  149a0a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149a0e:	d11f      	bne.n	149a50 <wdg_set_window_limit+0x68>
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  149a10:	681d      	ldr	r5, [r3, #0]
    freq = g_clk_select[clk_mask];
  149a12:	f645 7474 	movw	r4, #24436	; 0x5f74
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149a16:	6818      	ldr	r0, [r3, #0]
    freq = g_clk_select[clk_mask];
  149a18:	f2c0 0415 	movt	r4, #21
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149a1c:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  149a20:	f3c5 0582 	ubfx	r5, r5, #2, #3
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149a24:	f2c1 0662 	movt	r6, #4194	; 0x1062
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149a28:	0c00      	lsrs	r0, r0, #16
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149a2a:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149a2e:	3001      	adds	r0, #1
    base->wdg_wrc_val &= 0x00000000U;
  149a30:	68dd      	ldr	r5, [r3, #12]
  149a32:	2400      	movs	r4, #0
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149a34:	fbb2 f2f0 	udiv	r2, r2, r0
    base->wdg_wrc_val &= 0x00000000U;
  149a38:	60dc      	str	r4, [r3, #12]
    return true;
  149a3a:	2001      	movs	r0, #1
    base->wdg_wrc_val |= wincon;
  149a3c:	68dc      	ldr	r4, [r3, #12]
    wincon = window_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149a3e:	fba6 5202 	umull	r5, r2, r6, r2
  149a42:	0992      	lsrs	r2, r2, #6
  149a44:	fb01 f102 	mul.w	r1, r1, r2
    base->wdg_wrc_val |= wincon;
  149a48:	4321      	orrs	r1, r4
  149a4a:	60d9      	str	r1, [r3, #12]
}
  149a4c:	bc70      	pop	{r4, r5, r6}
  149a4e:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149a50:	2000      	movs	r0, #0
  149a52:	4602      	mov	r2, r0
  149a54:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  149a58:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  149a5c:	4283      	cmp	r3, r0
  149a5e:	bf18      	it	ne
  149a60:	4293      	cmpne	r3, r2
  149a62:	d0d5      	beq.n	149a10 <wdg_set_window_limit+0x28>
  149a64:	2000      	movs	r0, #0
  149a66:	4602      	mov	r2, r0
  149a68:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  149a6c:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  149a70:	4283      	cmp	r3, r0
  149a72:	bf18      	it	ne
  149a74:	4293      	cmpne	r3, r2
  149a76:	bf18      	it	ne
  149a78:	2000      	movne	r0, #0
  149a7a:	d0c9      	beq.n	149a10 <wdg_set_window_limit+0x28>
  149a7c:	e7e6      	b.n	149a4c <wdg_set_window_limit+0x64>
  149a7e:	bf00      	nop

00149a80 <wdg_set_seq_delta>:
{
  149a80:	b470      	push	{r4, r5, r6}
    ASSERT_PARAMETER(base);
  149a82:	2400      	movs	r4, #0
{
  149a84:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  149a86:	4622      	mov	r2, r4
  149a88:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  149a8c:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  149a90:	42a0      	cmp	r0, r4
  149a92:	bf18      	it	ne
  149a94:	4290      	cmpne	r0, r2
  149a96:	d007      	beq.n	149aa8 <wdg_set_seq_delta+0x28>
  149a98:	2200      	movs	r2, #0
  149a9a:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  149a9e:	4290      	cmp	r0, r2
  149aa0:	bf18      	it	ne
  149aa2:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149aa6:	d11f      	bne.n	149ae8 <wdg_set_seq_delta+0x68>
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  149aa8:	681d      	ldr	r5, [r3, #0]
    freq = g_clk_select[clk_mask];
  149aaa:	f645 7474 	movw	r4, #24436	; 0x5f74
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149aae:	6818      	ldr	r0, [r3, #0]
    freq = g_clk_select[clk_mask];
  149ab0:	f2c0 0415 	movt	r4, #21
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149ab4:	f644 56d3 	movw	r6, #19923	; 0x4dd3
    clk_mask = ((base->wdg_ctrl & WDG_CTRL_CLK_SRC_MASK) >> WDG_CTRL_CLK_SRC_SHIFT);
  149ab8:	f3c5 0582 	ubfx	r5, r5, #2, #3
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149abc:	f2c1 0662 	movt	r6, #4194	; 0x1062
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149ac0:	0c00      	lsrs	r0, r0, #16
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149ac2:	f854 2025 	ldr.w	r2, [r4, r5, lsl #2]
    divisor = ((base->wdg_ctrl & WDG_CTRL_PRE_DIV_NUM_MASK) >> WDG_CTRL_PRE_DIV_NUM_SHIFT) + 1;
  149ac6:	3001      	adds	r0, #1
    base->wdg_wrc_seq &= 0x00000000U;
  149ac8:	691d      	ldr	r5, [r3, #16]
  149aca:	2400      	movs	r4, #0
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149acc:	fbb2 f2f0 	udiv	r2, r2, r0
    base->wdg_wrc_seq &= 0x00000000U;
  149ad0:	611c      	str	r4, [r3, #16]
    return true;
  149ad2:	2001      	movs	r0, #1
    base->wdg_wrc_seq |= seqcon;
  149ad4:	691c      	ldr	r4, [r3, #16]
    seqcon = seq_delta_timeout_ms*((freq / divisor)/1000);//timeout is ms and change to s
  149ad6:	fba6 5202 	umull	r5, r2, r6, r2
  149ada:	0992      	lsrs	r2, r2, #6
  149adc:	fb01 f102 	mul.w	r1, r1, r2
    base->wdg_wrc_seq |= seqcon;
  149ae0:	4321      	orrs	r1, r4
  149ae2:	6119      	str	r1, [r3, #16]
}
  149ae4:	bc70      	pop	{r4, r5, r6}
  149ae6:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149ae8:	2000      	movs	r0, #0
  149aea:	4602      	mov	r2, r0
  149aec:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  149af0:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  149af4:	4283      	cmp	r3, r0
  149af6:	bf18      	it	ne
  149af8:	4293      	cmpne	r3, r2
  149afa:	d0d5      	beq.n	149aa8 <wdg_set_seq_delta+0x28>
  149afc:	2000      	movs	r0, #0
  149afe:	4602      	mov	r2, r0
  149b00:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  149b04:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  149b08:	4283      	cmp	r3, r0
  149b0a:	bf18      	it	ne
  149b0c:	4293      	cmpne	r3, r2
  149b0e:	bf18      	it	ne
  149b10:	2000      	movne	r0, #0
  149b12:	d0c9      	beq.n	149aa8 <wdg_set_seq_delta+0x28>
  149b14:	e7e6      	b.n	149ae4 <wdg_set_seq_delta+0x64>
  149b16:	bf00      	nop

00149b18 <wdg_refesh_mechanism_select>:
{
  149b18:	b410      	push	{r4}
    ASSERT_PARAMETER(base);
  149b1a:	2400      	movs	r4, #0
{
  149b1c:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  149b1e:	4622      	mov	r2, r4
  149b20:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  149b24:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  149b28:	42a0      	cmp	r0, r4
  149b2a:	bf18      	it	ne
  149b2c:	4290      	cmpne	r0, r2
  149b2e:	d007      	beq.n	149b40 <wdg_refesh_mechanism_select+0x28>
  149b30:	2200      	movs	r2, #0
  149b32:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  149b36:	4290      	cmp	r0, r2
  149b38:	bf18      	it	ne
  149b3a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149b3e:	d10d      	bne.n	149b5c <wdg_refesh_mechanism_select+0x44>
    if(wdg_config->wdg_refresh_config.wdgModeSelect > wdg_mechanism_mode_max){
  149b40:	7d08      	ldrb	r0, [r1, #20]
  149b42:	2803      	cmp	r0, #3
  149b44:	d81e      	bhi.n	149b84 <wdg_refesh_mechanism_select+0x6c>
    switch (wdg_config->wdg_refresh_config.wdgModeSelect) {
  149b46:	2802      	cmp	r0, #2
  149b48:	d020      	beq.n	149b8c <wdg_refesh_mechanism_select+0x74>
  149b4a:	2803      	cmp	r0, #3
  149b4c:	d035      	beq.n	149bba <wdg_refesh_mechanism_select+0xa2>
  149b4e:	2801      	cmp	r0, #1
    return true;
  149b50:	bf18      	it	ne
  149b52:	2001      	movne	r0, #1
    switch (wdg_config->wdg_refresh_config.wdgModeSelect) {
  149b54:	d026      	beq.n	149ba4 <wdg_refesh_mechanism_select+0x8c>
}
  149b56:	f85d 4b04 	ldr.w	r4, [r13], #4
  149b5a:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149b5c:	2000      	movs	r0, #0
  149b5e:	4602      	mov	r2, r0
  149b60:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  149b64:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  149b68:	4283      	cmp	r3, r0
  149b6a:	bf18      	it	ne
  149b6c:	4293      	cmpne	r3, r2
  149b6e:	d0e7      	beq.n	149b40 <wdg_refesh_mechanism_select+0x28>
  149b70:	2000      	movs	r0, #0
  149b72:	4602      	mov	r2, r0
  149b74:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  149b78:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  149b7c:	4283      	cmp	r3, r0
  149b7e:	bf18      	it	ne
  149b80:	4293      	cmpne	r3, r2
  149b82:	d0dd      	beq.n	149b40 <wdg_refesh_mechanism_select+0x28>
}
  149b84:	f85d 4b04 	ldr.w	r4, [r13], #4
    ASSERT_PARAMETER(base);
  149b88:	2000      	movs	r0, #0
}
  149b8a:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149b8c:	689a      	ldr	r2, [r3, #8]
    return true;
  149b8e:	2001      	movs	r0, #1
}
  149b90:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149b94:	f022 0203 	bic.w	r2, r2, #3
  149b98:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= WDG_WRC_CTRL_MODEM1_MASK;
  149b9a:	689a      	ldr	r2, [r3, #8]
  149b9c:	f042 0202 	orr.w	r2, r2, #2
  149ba0:	609a      	str	r2, [r3, #8]
}
  149ba2:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149ba4:	689a      	ldr	r2, [r3, #8]
}
  149ba6:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149baa:	f022 0203 	bic.w	r2, r2, #3
  149bae:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= WDG_WRC_CTRL_MODEM0_MASK;
  149bb0:	689a      	ldr	r2, [r3, #8]
  149bb2:	f042 0201 	orr.w	r2, r2, #1
  149bb6:	609a      	str	r2, [r3, #8]
}
  149bb8:	4770      	bx	r14
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149bba:	689a      	ldr	r2, [r3, #8]
    return true;
  149bbc:	2001      	movs	r0, #1
}
  149bbe:	f85d 4b04 	ldr.w	r4, [r13], #4
            base->wdg_wrc_ctl &= ~(WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149bc2:	f022 0203 	bic.w	r2, r2, #3
  149bc6:	609a      	str	r2, [r3, #8]
            base->wdg_wrc_ctl |= (WDG_WRC_CTRL_SEQ_REFR_MASK);
  149bc8:	689a      	ldr	r2, [r3, #8]
  149bca:	f042 0204 	orr.w	r2, r2, #4
  149bce:	609a      	str	r2, [r3, #8]
}
  149bd0:	4770      	bx	r14
  149bd2:	bf00      	nop

00149bd4 <wdg_get_refesh_mechanism>:
    ASSERT_PARAMETER(base);
  149bd4:	2200      	movs	r2, #0
  149bd6:	4613      	mov	r3, r2
  149bd8:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149bdc:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149be0:	4290      	cmp	r0, r2
  149be2:	bf18      	it	ne
  149be4:	4298      	cmpne	r0, r3
  149be6:	d007      	beq.n	149bf8 <wdg_get_refesh_mechanism+0x24>
  149be8:	2300      	movs	r3, #0
  149bea:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149bee:	4298      	cmp	r0, r3
  149bf0:	bf18      	it	ne
  149bf2:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149bf6:	d108      	bne.n	149c0a <wdg_get_refesh_mechanism+0x36>
    refresh_mechanism = base->wdg_wrc_ctl & (WDG_WRC_CTRL_MODEM0_MASK | WDG_WRC_CTRL_MODEM1_MASK);
  149bf8:	6883      	ldr	r3, [r0, #8]
    if((WDG_WRC_CTRL_MODEM1_MASK & refresh_mechanism) == WDG_WRC_CTRL_MODEM1_MASK){
  149bfa:	079a      	lsls	r2, r3, #30
  149bfc:	d41b      	bmi.n	149c36 <wdg_get_refesh_mechanism+0x62>
        return wdg_mechanism_mode3;
  149bfe:	f013 0f01 	tst.w	r3, #1
  149c02:	bf14      	ite	ne
  149c04:	2001      	movne	r0, #1
  149c06:	2003      	moveq	r0, #3
  149c08:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149c0a:	2200      	movs	r2, #0
  149c0c:	4613      	mov	r3, r2
  149c0e:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149c12:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149c16:	4290      	cmp	r0, r2
  149c18:	bf18      	it	ne
  149c1a:	4298      	cmpne	r0, r3
  149c1c:	d0ec      	beq.n	149bf8 <wdg_get_refesh_mechanism+0x24>
  149c1e:	2200      	movs	r2, #0
  149c20:	4613      	mov	r3, r2
  149c22:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149c26:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149c2a:	4290      	cmp	r0, r2
  149c2c:	bf18      	it	ne
  149c2e:	4298      	cmpne	r0, r3
  149c30:	d0e2      	beq.n	149bf8 <wdg_get_refesh_mechanism+0x24>
  149c32:	2000      	movs	r0, #0
  149c34:	4770      	bx	r14
        return wdg_mechanism_mode2;
  149c36:	2002      	movs	r0, #2
}
  149c38:	4770      	bx	r14
  149c3a:	bf00      	nop

00149c3c <wdg_init>:
{
  149c3c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ASSERT_PARAMETER(base);
  149c3e:	2500      	movs	r5, #0
  149c40:	462b      	mov	r3, r5
  149c42:	f2cf 051c 	movt	r5, #61468	; 0xf01c
  149c46:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149c4a:	42a8      	cmp	r0, r5
  149c4c:	bf18      	it	ne
  149c4e:	4298      	cmpne	r0, r3
  149c50:	bf14      	ite	ne
  149c52:	2501      	movne	r5, #1
  149c54:	2500      	moveq	r5, #0
  149c56:	d008      	beq.n	149c6a <wdg_init+0x2e>
  149c58:	2300      	movs	r3, #0
  149c5a:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149c5e:	4298      	cmp	r0, r3
  149c60:	bf18      	it	ne
  149c62:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149c66:	f040 8085 	bne.w	149d74 <wdg_init+0x138>
  149c6a:	460e      	mov	r6, r1
    wdg_unlock(base,unlock_mask);
  149c6c:	217f      	movs	r1, #127	; 0x7f
  149c6e:	4604      	mov	r4, r0
  149c70:	f7ff fd94 	bl	14979c <wdg_unlock>
    base->wdg_ctrl = 0x0U;
  149c74:	2200      	movs	r2, #0
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_SRC(wdg_config->wdg_ctrl_config.enableSrcSelect)|WDG_CTRL_WTC_SRC(wdg_config->wdg_ctrl_config.terminalCountSrc);
  149c76:	2364      	movs	r3, #100	; 0x64
    base->wdg_ctrl = 0x0U;
  149c78:	6022      	str	r2, [r4, #0]
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_SRC(wdg_config->wdg_ctrl_config.enableSrcSelect)|WDG_CTRL_WTC_SRC(wdg_config->wdg_ctrl_config.terminalCountSrc);
  149c7a:	7af2      	ldrb	r2, [r6, #11]
  149c7c:	7a31      	ldrb	r1, [r6, #8]
  149c7e:	0212      	lsls	r2, r2, #8
  149c80:	0149      	lsls	r1, r1, #5
  149c82:	f001 0120 	and.w	r1, r1, #32
  149c86:	f402 7280 	and.w	r2, r2, #256	; 0x100
  149c8a:	430a      	orrs	r2, r1
  149c8c:	6821      	ldr	r1, [r4, #0]
  149c8e:	430a      	orrs	r2, r1
  149c90:	6022      	str	r2, [r4, #0]
  149c92:	e002      	b.n	149c9a <wdg_init+0x5e>
    }while (--retrycount);
  149c94:	3b01      	subs	r3, #1
  149c96:	f000 8083 	beq.w	149da0 <wdg_init+0x164>
                    v= base->wdg_ctrl;
  149c9a:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
  149c9c:	0552      	lsls	r2, r2, #21
  149c9e:	d4f9      	bmi.n	149c94 <wdg_init+0x58>
    ASSERT_PARAMETER(base);
  149ca0:	b18d      	cbz	r5, 149cc6 <wdg_init+0x8a>
  149ca2:	2300      	movs	r3, #0
  149ca4:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149ca8:	429c      	cmp	r4, r3
  149caa:	bf18      	it	ne
  149cac:	f114 6f76 	cmnne.w	r4, #257949696	; 0xf600000
  149cb0:	d009      	beq.n	149cc6 <wdg_init+0x8a>
  149cb2:	2200      	movs	r2, #0
  149cb4:	4613      	mov	r3, r2
  149cb6:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149cba:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149cbe:	4294      	cmp	r4, r2
  149cc0:	bf18      	it	ne
  149cc2:	429c      	cmpne	r4, r3
  149cc4:	d16e      	bne.n	149da4 <wdg_init+0x168>
    if((wdg_config->wdg_ctrl_config.clockSource !=wdg_main_clk)
  149cc6:	6873      	ldr	r3, [r6, #4]
  149cc8:	2b04      	cmp	r3, #4
  149cca:	d816      	bhi.n	149cfa <wdg_init+0xbe>
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
  149ccc:	2101      	movs	r1, #1
  149cce:	4620      	mov	r0, r4
  149cd0:	f7ff fd64 	bl	14979c <wdg_unlock>
    base->wdg_ctrl &=~WDG_CTRL_CLK_SRC_MASK;
  149cd4:	6822      	ldr	r2, [r4, #0]
    base->wdg_ctrl |=WDG_CTRL_CLK_SRC(wdg_config->wdg_ctrl_config.clockSource);
  149cd6:	6873      	ldr	r3, [r6, #4]
    base->wdg_ctrl |= WDG_CTRL_PRE_DIV_NUM(wdg_config->wdg_ctrl_config.prescaler);
  149cd8:	89f1      	ldrh	r1, [r6, #14]
    base->wdg_ctrl &=~WDG_CTRL_CLK_SRC_MASK;
  149cda:	f022 021c 	bic.w	r2, r2, #28
  149cde:	6022      	str	r2, [r4, #0]
    base->wdg_ctrl |=WDG_CTRL_CLK_SRC(wdg_config->wdg_ctrl_config.clockSource);
  149ce0:	009b      	lsls	r3, r3, #2
  149ce2:	6822      	ldr	r2, [r4, #0]
  149ce4:	f003 031c 	and.w	r3, r3, #28
  149ce8:	4313      	orrs	r3, r2
  149cea:	6023      	str	r3, [r4, #0]
    base->wdg_ctrl &= ~WDG_CTRL_PRE_DIV_NUM_MASK;
  149cec:	6823      	ldr	r3, [r4, #0]
  149cee:	b29b      	uxth	r3, r3
  149cf0:	6023      	str	r3, [r4, #0]
    base->wdg_ctrl |= WDG_CTRL_PRE_DIV_NUM(wdg_config->wdg_ctrl_config.prescaler);
  149cf2:	6823      	ldr	r3, [r4, #0]
  149cf4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  149cf8:	6023      	str	r3, [r4, #0]
    wdg_set_timeout(base,wdg_config->wdg_timeout);
  149cfa:	6931      	ldr	r1, [r6, #16]
  149cfc:	4620      	mov	r0, r4
  149cfe:	f7ff fe25 	bl	14994c <wdg_set_timeout>
    wdg_refesh_mechanism_select(base,wdg_config);
  149d02:	4631      	mov	r1, r6
  149d04:	4620      	mov	r0, r4
  149d06:	f7ff ff07 	bl	149b18 <wdg_refesh_mechanism_select>
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
  149d0a:	68e3      	ldr	r3, [r4, #12]
                                |WDG_INT_ILL_SEQ_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_seq_refr_int_en)
  149d0c:	f896 c031 	ldrb.w	r12, [r6, #49]	; 0x31
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
  149d10:	69b3      	ldr	r3, [r6, #24]
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
  149d12:	2200      	movs	r2, #0
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
  149d14:	f896 7030 	ldrb.w	r7, [r6, #48]	; 0x30
                                |WDG_INT_OVERFLOW_INT_EN(wdg_config->wdg_int_cfg.overflow_int_en)
  149d18:	f896 5032 	ldrb.w	r5, [r6, #50]	; 0x32
    base->wdg_wrc_val &= ~WDG_WRC_MASK;
  149d1c:	60e2      	str	r2, [r4, #12]
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
  149d1e:	68e1      	ldr	r1, [r4, #12]
  149d20:	4319      	orrs	r1, r3
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
  149d22:	69f3      	ldr	r3, [r6, #28]
    base->wdg_wrc_val |= wdg_config->refresh_wind_limit;
  149d24:	60e1      	str	r1, [r4, #12]
    base->wdg_wrc_seq &= ~WDG_WRC_SEQ_MASK;
  149d26:	6921      	ldr	r1, [r4, #16]
  149d28:	6122      	str	r2, [r4, #16]
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
  149d2a:	6920      	ldr	r0, [r4, #16]
  149d2c:	4318      	orrs	r0, r3
    base->wdg_tsw |= wdg_config->wdg_tsw;
  149d2e:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    base->wdg_wrc_seq |= wdg_config->refresh_seq_delta;
  149d30:	6120      	str	r0, [r4, #16]
                                |WDG_INT_ILL_SEQ_REFE_INT_CLR(wdg_config->wdg_int_cfg.ill_seq_refr_int_clr)
  149d32:	f896 0034 	ldrb.w	r0, [r6, #52]	; 0x34
    base->wdg_tsw &= 0x00000000;
  149d36:	6a21      	ldr	r1, [r4, #32]
  149d38:	6222      	str	r2, [r4, #32]
    base->wdg_tsw |= wdg_config->wdg_tsw;
  149d3a:	6a21      	ldr	r1, [r4, #32]
  149d3c:	4319      	orrs	r1, r3
  149d3e:	6221      	str	r1, [r4, #32]
                                |WDG_INT_OVERFLOW_INT_CLR(wdg_config->wdg_int_cfg.overflow_int_clr);
  149d40:	f896 1035 	ldrb.w	r1, [r6, #53]	; 0x35
    base->wdg_int &= 0x00000000;
  149d44:	6a63      	ldr	r3, [r4, #36]	; 0x24
  149d46:	6262      	str	r2, [r4, #36]	; 0x24
                                |WDG_INT_ILL_WIN_REFE_INT_CLR(wdg_config->wdg_int_cfg.ill_win_refr_int_clr)
  149d48:	f896 2033 	ldrb.w	r2, [r6, #51]	; 0x33
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
  149d4c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  149d4e:	ea43 034c 	orr.w	r3, r3, r12, lsl #1
  149d52:	433b      	orrs	r3, r7
  149d54:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
  149d58:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    base->wdg_ctrl |= WDG_CTRL_AUTO_RESTART(wdg_config->wdg_ctrl_config.enableAutostart);
  149d5c:	7a72      	ldrb	r2, [r6, #9]
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
  149d5e:	ea43 13c0 	orr.w	r3, r3, r0, lsl #7
    return true;
  149d62:	2001      	movs	r0, #1
    base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN(wdg_config->wdg_int_cfg.ill_win_refr_int_en)
  149d64:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  149d68:	6263      	str	r3, [r4, #36]	; 0x24
    base->wdg_ctrl |= WDG_CTRL_AUTO_RESTART(wdg_config->wdg_ctrl_config.enableAutostart);
  149d6a:	6823      	ldr	r3, [r4, #0]
  149d6c:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
  149d70:	6023      	str	r3, [r4, #0]
}
  149d72:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    ASSERT_PARAMETER(base);
  149d74:	2200      	movs	r2, #0
  149d76:	4613      	mov	r3, r2
  149d78:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149d7c:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149d80:	4290      	cmp	r0, r2
  149d82:	bf18      	it	ne
  149d84:	4298      	cmpne	r0, r3
  149d86:	f43f af70 	beq.w	149c6a <wdg_init+0x2e>
  149d8a:	2200      	movs	r2, #0
  149d8c:	4613      	mov	r3, r2
  149d8e:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149d92:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149d96:	4290      	cmp	r0, r2
  149d98:	bf18      	it	ne
  149d9a:	4298      	cmpne	r0, r3
  149d9c:	f43f af65 	beq.w	149c6a <wdg_init+0x2e>
  149da0:	2000      	movs	r0, #0
}
  149da2:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    ASSERT_PARAMETER(base);
  149da4:	2200      	movs	r2, #0
  149da6:	4613      	mov	r3, r2
  149da8:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149dac:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149db0:	4294      	cmp	r4, r2
  149db2:	bf18      	it	ne
  149db4:	429c      	cmpne	r4, r3
  149db6:	d086      	beq.n	149cc6 <wdg_init+0x8a>
  149db8:	e79f      	b.n	149cfa <wdg_init+0xbe>
  149dba:	bf00      	nop

00149dbc <wdg_deInit>:
    ASSERT_PARAMETER(base);
  149dbc:	2200      	movs	r2, #0
  149dbe:	4613      	mov	r3, r2
  149dc0:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149dc4:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149dc8:	4290      	cmp	r0, r2
  149dca:	bf18      	it	ne
  149dcc:	4298      	cmpne	r0, r3
  149dce:	d01d      	beq.n	149e0c <wdg_deInit+0x50>
  149dd0:	2300      	movs	r3, #0
  149dd2:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149dd6:	4298      	cmp	r0, r3
  149dd8:	bf18      	it	ne
  149dda:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149dde:	d015      	beq.n	149e0c <wdg_deInit+0x50>
  149de0:	2200      	movs	r2, #0
  149de2:	4613      	mov	r3, r2
  149de4:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149de8:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149dec:	4290      	cmp	r0, r2
  149dee:	bf18      	it	ne
  149df0:	4298      	cmpne	r0, r3
  149df2:	d00b      	beq.n	149e0c <wdg_deInit+0x50>
  149df4:	2200      	movs	r2, #0
  149df6:	4613      	mov	r3, r2
  149df8:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149dfc:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149e00:	4290      	cmp	r0, r2
  149e02:	bf18      	it	ne
  149e04:	4298      	cmpne	r0, r3
  149e06:	d001      	beq.n	149e0c <wdg_deInit+0x50>
  149e08:	2000      	movs	r0, #0
}
  149e0a:	4770      	bx	r14
{
  149e0c:	b510      	push	{r4, r14}
  149e0e:	4604      	mov	r4, r0
    wdg_unlock(base,unlock_mask);
  149e10:	217f      	movs	r1, #127	; 0x7f
  149e12:	f7ff fcc3 	bl	14979c <wdg_unlock>
    base->wdg_rst_ctl &= 0xffff0000;
  149e16:	2200      	movs	r2, #0
    return true;
  149e18:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= 0xffff0000;
  149e1a:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  149e1e:	6963      	ldr	r3, [r4, #20]
  149e20:	4013      	ands	r3, r2
  149e22:	6163      	str	r3, [r4, #20]
    base->wdg_ext_rst_ctl &= 0xffff0000;
  149e24:	69a3      	ldr	r3, [r4, #24]
  149e26:	4013      	ands	r3, r2
  149e28:	61a3      	str	r3, [r4, #24]
}
  149e2a:	bd10      	pop	{r4, r15}

00149e2c <wdg_set_testmode_config>:
    ASSERT_PARAMETER(base);
  149e2c:	2200      	movs	r2, #0
  149e2e:	4613      	mov	r3, r2
  149e30:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149e34:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149e38:	4290      	cmp	r0, r2
  149e3a:	bf18      	it	ne
  149e3c:	4298      	cmpne	r0, r3
  149e3e:	d01d      	beq.n	149e7c <wdg_set_testmode_config+0x50>
  149e40:	2300      	movs	r3, #0
  149e42:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149e46:	4298      	cmp	r0, r3
  149e48:	bf18      	it	ne
  149e4a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149e4e:	d015      	beq.n	149e7c <wdg_set_testmode_config+0x50>
  149e50:	2200      	movs	r2, #0
  149e52:	4613      	mov	r3, r2
  149e54:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149e58:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149e5c:	4290      	cmp	r0, r2
  149e5e:	bf18      	it	ne
  149e60:	4298      	cmpne	r0, r3
  149e62:	d00b      	beq.n	149e7c <wdg_set_testmode_config+0x50>
  149e64:	2200      	movs	r2, #0
  149e66:	4613      	mov	r3, r2
  149e68:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149e6c:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149e70:	4290      	cmp	r0, r2
  149e72:	bf18      	it	ne
  149e74:	4298      	cmpne	r0, r3
  149e76:	d001      	beq.n	149e7c <wdg_set_testmode_config+0x50>
  149e78:	2000      	movs	r0, #0
}
  149e7a:	4770      	bx	r14
{
  149e7c:	b570      	push	{r4, r5, r6, r14}
  149e7e:	4604      	mov	r4, r0
  149e80:	460d      	mov	r5, r1
    wdg_unlock(base,unlock_mask);
  149e82:	217f      	movs	r1, #127	; 0x7f
    base->wdg_wtc &= ~WDG_WTC_MASK;
  149e84:	2600      	movs	r6, #0
    wdg_unlock(base,unlock_mask);
  149e86:	f7ff fc89 	bl	14979c <wdg_unlock>
    base->wdg_rst_ctl &= 0xffff0000;
  149e8a:	2100      	movs	r1, #0
  149e8c:	6962      	ldr	r2, [r4, #20]
  149e8e:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    base->wdg_ctrl |= WDG_CTRL_SELFTEST_TRIG(wdg_config->wdg_ctrl_config.enableSelftest);
  149e92:	7b2d      	ldrb	r5, [r5, #12]
    base->wdg_wtc |= 0xffffffff;
  149e94:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    return true;
  149e98:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= 0xffff0000;
  149e9a:	400a      	ands	r2, r1
  149e9c:	6162      	str	r2, [r4, #20]
    base->wdg_ext_rst_ctl &= 0xffff0000;
  149e9e:	69a2      	ldr	r2, [r4, #24]
  149ea0:	400a      	ands	r2, r1
  149ea2:	61a2      	str	r2, [r4, #24]
    base->wdg_wtc &= ~WDG_WTC_MASK;
  149ea4:	6862      	ldr	r2, [r4, #4]
  149ea6:	6066      	str	r6, [r4, #4]
    base->wdg_wtc |= 0xffffffff;
  149ea8:	6862      	ldr	r2, [r4, #4]
  149eaa:	6063      	str	r3, [r4, #4]
    base->wdg_ctrl |= WDG_CTRL_SELFTEST_TRIG(wdg_config->wdg_ctrl_config.enableSelftest);
  149eac:	6823      	ldr	r3, [r4, #0]
  149eae:	ea43 2345 	orr.w	r3, r3, r5, lsl #9
  149eb2:	6023      	str	r3, [r4, #0]
}
  149eb4:	bd70      	pop	{r4, r5, r6, r15}
  149eb6:	bf00      	nop

00149eb8 <wdg_enable>:
    ASSERT_PARAMETER(base);
  149eb8:	2200      	movs	r2, #0
  149eba:	4613      	mov	r3, r2
  149ebc:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149ec0:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149ec4:	4290      	cmp	r0, r2
  149ec6:	bf18      	it	ne
  149ec8:	4298      	cmpne	r0, r3
  149eca:	d007      	beq.n	149edc <wdg_enable+0x24>
  149ecc:	2300      	movs	r3, #0
  149ece:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149ed2:	4298      	cmp	r0, r3
  149ed4:	bf18      	it	ne
  149ed6:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149eda:	d11e      	bne.n	149f1a <wdg_enable+0x62>
{
  149edc:	b510      	push	{r4, r14}
  149ede:	4604      	mov	r4, r0
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
  149ee0:	2101      	movs	r1, #1
  149ee2:	f7ff fc5b 	bl	14979c <wdg_unlock>
    base->wdg_ctrl |= WDG_CTRL_WDG_EN_MASK;
  149ee6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  149eea:	6822      	ldr	r2, [r4, #0]
  149eec:	f042 0202 	orr.w	r2, r2, #2
  149ef0:	6022      	str	r2, [r4, #0]
  149ef2:	e001      	b.n	149ef8 <wdg_enable+0x40>
    }while (--retrycount);
  149ef4:	3b01      	subs	r3, #1
  149ef6:	d026      	beq.n	149f46 <wdg_enable+0x8e>
                    v= base->wdg_ctrl;
  149ef8:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
  149efa:	0551      	lsls	r1, r2, #21
  149efc:	d5fa      	bpl.n	149ef4 <wdg_enable+0x3c>
    base->wdg_ctrl |= WDG_CTRL_SOFT_RST(1);
  149efe:	6822      	ldr	r2, [r4, #0]
  149f00:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  149f04:	f042 0201 	orr.w	r2, r2, #1
  149f08:	6022      	str	r2, [r4, #0]
  149f0a:	e001      	b.n	149f10 <wdg_enable+0x58>
    }while (--retrycount);
  149f0c:	3b01      	subs	r3, #1
  149f0e:	d01a      	beq.n	149f46 <wdg_enable+0x8e>
                    v= base->wdg_ctrl;
  149f10:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
  149f12:	07d2      	lsls	r2, r2, #31
  149f14:	d4fa      	bmi.n	149f0c <wdg_enable+0x54>
    return true;
  149f16:	2001      	movs	r0, #1
}
  149f18:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
  149f1a:	2200      	movs	r2, #0
  149f1c:	4613      	mov	r3, r2
  149f1e:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149f22:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149f26:	4290      	cmp	r0, r2
  149f28:	bf18      	it	ne
  149f2a:	4298      	cmpne	r0, r3
  149f2c:	d0d6      	beq.n	149edc <wdg_enable+0x24>
  149f2e:	2200      	movs	r2, #0
  149f30:	4613      	mov	r3, r2
  149f32:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149f36:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149f3a:	4290      	cmp	r0, r2
  149f3c:	bf18      	it	ne
  149f3e:	4298      	cmpne	r0, r3
  149f40:	d0cc      	beq.n	149edc <wdg_enable+0x24>
  149f42:	2000      	movs	r0, #0
}
  149f44:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149f46:	2000      	movs	r0, #0
}
  149f48:	bd10      	pop	{r4, r15}
  149f4a:	bf00      	nop

00149f4c <wdg_disable>:
    ASSERT_PARAMETER(base);
  149f4c:	2200      	movs	r2, #0
  149f4e:	4613      	mov	r3, r2
  149f50:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149f54:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149f58:	4290      	cmp	r0, r2
  149f5a:	bf18      	it	ne
  149f5c:	4298      	cmpne	r0, r3
  149f5e:	d007      	beq.n	149f70 <wdg_disable+0x24>
  149f60:	2300      	movs	r3, #0
  149f62:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149f66:	4298      	cmp	r0, r3
  149f68:	bf18      	it	ne
  149f6a:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149f6e:	d115      	bne.n	149f9c <wdg_disable+0x50>
{
  149f70:	b510      	push	{r4, r14}
  149f72:	4604      	mov	r4, r0
    wdg_unlock(base,WDG_LOCK_CTL_LOCK_MASK);
  149f74:	2101      	movs	r1, #1
  149f76:	f7ff fc11 	bl	14979c <wdg_unlock>
    base->wdg_ctrl |= WDG_CTRL_SOFT_RST(1);
  149f7a:	2364      	movs	r3, #100	; 0x64
  149f7c:	6822      	ldr	r2, [r4, #0]
  149f7e:	f042 0201 	orr.w	r2, r2, #1
  149f82:	6022      	str	r2, [r4, #0]
  149f84:	e001      	b.n	149f8a <wdg_disable+0x3e>
    }while (--retrycount);
  149f86:	3b01      	subs	r3, #1
  149f88:	d01e      	beq.n	149fc8 <wdg_disable+0x7c>
                    v= base->wdg_ctrl;
  149f8a:	6822      	ldr	r2, [r4, #0]
        if (((v>>start) & ((1<<width)-1)) == value){
  149f8c:	07d2      	lsls	r2, r2, #31
  149f8e:	d4fa      	bmi.n	149f86 <wdg_disable+0x3a>
    base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_MASK;
  149f90:	6823      	ldr	r3, [r4, #0]
    return true;
  149f92:	2001      	movs	r0, #1
    base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_MASK;
  149f94:	f023 0302 	bic.w	r3, r3, #2
  149f98:	6023      	str	r3, [r4, #0]
}
  149f9a:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
  149f9c:	2200      	movs	r2, #0
  149f9e:	4613      	mov	r3, r2
  149fa0:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  149fa4:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  149fa8:	4290      	cmp	r0, r2
  149faa:	bf18      	it	ne
  149fac:	4298      	cmpne	r0, r3
  149fae:	d0df      	beq.n	149f70 <wdg_disable+0x24>
  149fb0:	2200      	movs	r2, #0
  149fb2:	4613      	mov	r3, r2
  149fb4:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  149fb8:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  149fbc:	4290      	cmp	r0, r2
  149fbe:	bf18      	it	ne
  149fc0:	4298      	cmpne	r0, r3
  149fc2:	d0d5      	beq.n	149f70 <wdg_disable+0x24>
  149fc4:	2000      	movs	r0, #0
}
  149fc6:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  149fc8:	2000      	movs	r0, #0
}
  149fca:	bd10      	pop	{r4, r15}

00149fcc <wdg_enable_Interrupts>:
    ASSERT_PARAMETER(base);
  149fcc:	2200      	movs	r2, #0
{
  149fce:	b538      	push	{r3, r4, r5, r14}
    ASSERT_PARAMETER(base);
  149fd0:	4613      	mov	r3, r2
  149fd2:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  149fd6:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  149fda:	4290      	cmp	r0, r2
  149fdc:	bf18      	it	ne
  149fde:	4298      	cmpne	r0, r3
  149fe0:	d007      	beq.n	149ff2 <wdg_enable_Interrupts+0x26>
  149fe2:	2300      	movs	r3, #0
  149fe4:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  149fe8:	4298      	cmp	r0, r3
  149fea:	bf18      	it	ne
  149fec:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  149ff0:	d110      	bne.n	14a014 <wdg_enable_Interrupts+0x48>
  149ff2:	4604      	mov	r4, r0
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  149ff4:	f7ff fdee 	bl	149bd4 <wdg_get_refesh_mechanism>
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
  149ff8:	2120      	movs	r1, #32
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  149ffa:	4605      	mov	r5, r0
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
  149ffc:	4620      	mov	r0, r4
  149ffe:	f7ff fbcd 	bl	14979c <wdg_unlock>
    switch (refresh_mechanism) {
  14a002:	2d02      	cmp	r5, #2
  14a004:	d029      	beq.n	14a05a <wdg_enable_Interrupts+0x8e>
  14a006:	2d03      	cmp	r5, #3
  14a008:	d01b      	beq.n	14a042 <wdg_enable_Interrupts+0x76>
  14a00a:	2d01      	cmp	r5, #1
    return true;
  14a00c:	bf18      	it	ne
  14a00e:	2001      	movne	r0, #1
    switch (refresh_mechanism) {
  14a010:	d01d      	beq.n	14a04e <wdg_enable_Interrupts+0x82>
}
  14a012:	bd38      	pop	{r3, r4, r5, r15}
    ASSERT_PARAMETER(base);
  14a014:	2200      	movs	r2, #0
  14a016:	4613      	mov	r3, r2
  14a018:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a01c:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a020:	4290      	cmp	r0, r2
  14a022:	bf18      	it	ne
  14a024:	4298      	cmpne	r0, r3
  14a026:	d0e4      	beq.n	149ff2 <wdg_enable_Interrupts+0x26>
  14a028:	2200      	movs	r2, #0
  14a02a:	4613      	mov	r3, r2
  14a02c:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a030:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a034:	4290      	cmp	r0, r2
  14a036:	bf18      	it	ne
  14a038:	4298      	cmpne	r0, r3
  14a03a:	bf18      	it	ne
  14a03c:	2000      	movne	r0, #0
  14a03e:	d0d8      	beq.n	149ff2 <wdg_enable_Interrupts+0x26>
  14a040:	e7e7      	b.n	14a012 <wdg_enable_Interrupts+0x46>
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
  14a042:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a044:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
  14a046:	f043 0302 	orr.w	r3, r3, #2
  14a04a:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a04c:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int |= WDG_INT_OVERFLOW_INT_EN_MASK;
  14a04e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a050:	4628      	mov	r0, r5
            base->wdg_int |= WDG_INT_OVERFLOW_INT_EN_MASK;
  14a052:	f043 0304 	orr.w	r3, r3, #4
  14a056:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a058:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
  14a05a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a05c:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
  14a05e:	4303      	orrs	r3, r0
  14a060:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a062:	bd38      	pop	{r3, r4, r5, r15}

0014a064 <wdg_disable_Interrupts>:
    ASSERT_PARAMETER(base);
  14a064:	2200      	movs	r2, #0
{
  14a066:	b538      	push	{r3, r4, r5, r14}
    ASSERT_PARAMETER(base);
  14a068:	4613      	mov	r3, r2
  14a06a:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a06e:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a072:	4290      	cmp	r0, r2
  14a074:	bf18      	it	ne
  14a076:	4298      	cmpne	r0, r3
  14a078:	d007      	beq.n	14a08a <wdg_disable_Interrupts+0x26>
  14a07a:	2300      	movs	r3, #0
  14a07c:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a080:	4298      	cmp	r0, r3
  14a082:	bf18      	it	ne
  14a084:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a088:	d110      	bne.n	14a0ac <wdg_disable_Interrupts+0x48>
  14a08a:	4604      	mov	r4, r0
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a08c:	f7ff fda2 	bl	149bd4 <wdg_get_refesh_mechanism>
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
  14a090:	2120      	movs	r1, #32
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a092:	4605      	mov	r5, r0
    wdg_unlock(base,WDG_LOCK_INT_LOCK_MASK);
  14a094:	4620      	mov	r0, r4
  14a096:	f7ff fb81 	bl	14979c <wdg_unlock>
    switch (refresh_mechanism) {
  14a09a:	2d02      	cmp	r5, #2
  14a09c:	d029      	beq.n	14a0f2 <wdg_disable_Interrupts+0x8e>
  14a09e:	2d03      	cmp	r5, #3
  14a0a0:	d01b      	beq.n	14a0da <wdg_disable_Interrupts+0x76>
  14a0a2:	2d01      	cmp	r5, #1
    return true;
  14a0a4:	bf18      	it	ne
  14a0a6:	2001      	movne	r0, #1
    switch (refresh_mechanism) {
  14a0a8:	d01d      	beq.n	14a0e6 <wdg_disable_Interrupts+0x82>
}
  14a0aa:	bd38      	pop	{r3, r4, r5, r15}
    ASSERT_PARAMETER(base);
  14a0ac:	2200      	movs	r2, #0
  14a0ae:	4613      	mov	r3, r2
  14a0b0:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a0b4:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a0b8:	4290      	cmp	r0, r2
  14a0ba:	bf18      	it	ne
  14a0bc:	4298      	cmpne	r0, r3
  14a0be:	d0e4      	beq.n	14a08a <wdg_disable_Interrupts+0x26>
  14a0c0:	2200      	movs	r2, #0
  14a0c2:	4613      	mov	r3, r2
  14a0c4:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a0c8:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a0cc:	4290      	cmp	r0, r2
  14a0ce:	bf18      	it	ne
  14a0d0:	4298      	cmpne	r0, r3
  14a0d2:	bf18      	it	ne
  14a0d4:	2000      	movne	r0, #0
  14a0d6:	d0d8      	beq.n	14a08a <wdg_disable_Interrupts+0x26>
  14a0d8:	e7e7      	b.n	14a0aa <wdg_disable_Interrupts+0x46>
            base->wdg_int &= ~WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
  14a0da:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a0dc:	2001      	movs	r0, #1
            base->wdg_int &= ~WDG_INT_ILL_SEQ_REFE_INT_EN_MASK;
  14a0de:	f023 0302 	bic.w	r3, r3, #2
  14a0e2:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a0e4:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int &= ~WDG_INT_OVERFLOW_INT_EN_MASK;
  14a0e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a0e8:	4628      	mov	r0, r5
            base->wdg_int &= ~WDG_INT_OVERFLOW_INT_EN_MASK;
  14a0ea:	f023 0304 	bic.w	r3, r3, #4
  14a0ee:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a0f0:	bd38      	pop	{r3, r4, r5, r15}
            base->wdg_int &= ~WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
  14a0f2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    return true;
  14a0f4:	2001      	movs	r0, #1
            base->wdg_int &= ~WDG_INT_ILL_WIN_REFE_INT_EN_MASK;
  14a0f6:	f023 0301 	bic.w	r3, r3, #1
  14a0fa:	6263      	str	r3, [r4, #36]	; 0x24
}
  14a0fc:	bd38      	pop	{r3, r4, r5, r15}
  14a0fe:	bf00      	nop

0014a100 <wdg_get_status_flag>:
    ASSERT_PARAMETER(base);
  14a100:	2100      	movs	r1, #0
{
  14a102:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a104:	460a      	mov	r2, r1
  14a106:	f2cf 011c 	movt	r1, #61468	; 0xf01c
  14a10a:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a10e:	4288      	cmp	r0, r1
  14a110:	bf18      	it	ne
  14a112:	4290      	cmpne	r0, r2
  14a114:	d01d      	beq.n	14a152 <wdg_get_status_flag+0x52>
  14a116:	2200      	movs	r2, #0
  14a118:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a11c:	4290      	cmp	r0, r2
  14a11e:	bf18      	it	ne
  14a120:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a124:	d015      	beq.n	14a152 <wdg_get_status_flag+0x52>
  14a126:	2100      	movs	r1, #0
  14a128:	460a      	mov	r2, r1
  14a12a:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
  14a12e:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a132:	4288      	cmp	r0, r1
  14a134:	bf18      	it	ne
  14a136:	4290      	cmpne	r0, r2
  14a138:	d00b      	beq.n	14a152 <wdg_get_status_flag+0x52>
  14a13a:	2100      	movs	r1, #0
  14a13c:	460a      	mov	r2, r1
  14a13e:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
  14a142:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a146:	4288      	cmp	r0, r1
  14a148:	bf18      	it	ne
  14a14a:	4290      	cmpne	r0, r2
  14a14c:	d001      	beq.n	14a152 <wdg_get_status_flag+0x52>
  14a14e:	2000      	movs	r0, #0
}
  14a150:	4770      	bx	r14
    status_flag |= (base->wdg_ctrl & WDG_CTRL_WDG_EN_STA_MASK);
  14a152:	6818      	ldr	r0, [r3, #0]
    status_flag |= (base->wdg_int & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
  14a154:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    temp_test =base->wdg_int;
  14a156:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    status_flag |= (base->wdg_ctrl & WDG_CTRL_WDG_EN_STA_MASK);
  14a158:	f400 6080 	and.w	r0, r0, #1024	; 0x400
    status_flag |= (base->wdg_int & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
  14a15c:	f002 0238 	and.w	r2, r2, #56	; 0x38
  14a160:	4310      	orrs	r0, r2
    return status_flag;
  14a162:	4770      	bx	r14

0014a164 <wdg_clear_status_flag>:
{
  14a164:	b410      	push	{r4}
    ASSERT_PARAMETER(base);
  14a166:	2400      	movs	r4, #0
{
  14a168:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a16a:	4622      	mov	r2, r4
  14a16c:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  14a170:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a174:	42a0      	cmp	r0, r4
  14a176:	bf18      	it	ne
  14a178:	4290      	cmpne	r0, r2
  14a17a:	d007      	beq.n	14a18c <wdg_clear_status_flag+0x28>
  14a17c:	2200      	movs	r2, #0
  14a17e:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a182:	4290      	cmp	r0, r2
  14a184:	bf18      	it	ne
  14a186:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a18a:	d10f      	bne.n	14a1ac <wdg_clear_status_flag+0x48>
    return true;
  14a18c:	2001      	movs	r0, #1
    if(mask & WDG_CTRL_WDG_EN_STA_MASK){
  14a18e:	054a      	lsls	r2, r1, #21
    base->wdg_int &= ~(mask & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
  14a190:	f001 0138 	and.w	r1, r1, #56	; 0x38
        base->wdg_ctrl &= ~WDG_CTRL_WDG_EN_STA_MASK;
  14a194:	bf42      	ittt	mi
  14a196:	681a      	ldrmi	r2, [r3, #0]
  14a198:	f422 6280 	bicmi.w	r2, r2, #1024	; 0x400
  14a19c:	601a      	strmi	r2, [r3, #0]
    base->wdg_int &= ~(mask & (WDG_INT_ILL_WIN_REFE_INT_STA_MASK | WDG_INT_ILL_SEQ_REFE_INT_STA_MASK | WDG_INT_OVERFLOW_INT_STA_MASK));
  14a19e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  14a1a0:	ea22 0101 	bic.w	r1, r2, r1
  14a1a4:	6259      	str	r1, [r3, #36]	; 0x24
}
  14a1a6:	f85d 4b04 	ldr.w	r4, [r13], #4
  14a1aa:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  14a1ac:	2000      	movs	r0, #0
  14a1ae:	4602      	mov	r2, r0
  14a1b0:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  14a1b4:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a1b8:	4283      	cmp	r3, r0
  14a1ba:	bf18      	it	ne
  14a1bc:	4293      	cmpne	r3, r2
  14a1be:	d0e5      	beq.n	14a18c <wdg_clear_status_flag+0x28>
  14a1c0:	2000      	movs	r0, #0
  14a1c2:	4602      	mov	r2, r0
  14a1c4:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  14a1c8:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a1cc:	4283      	cmp	r3, r0
  14a1ce:	bf18      	it	ne
  14a1d0:	4293      	cmpne	r3, r2
  14a1d2:	bf18      	it	ne
  14a1d4:	2000      	movne	r0, #0
  14a1d6:	d0d9      	beq.n	14a18c <wdg_clear_status_flag+0x28>
  14a1d8:	e7e5      	b.n	14a1a6 <wdg_clear_status_flag+0x42>
  14a1da:	bf00      	nop

0014a1dc <wdg_refresh>:
//*****************************************************************************
bool wdg_refresh(wdg_reg_type_t *base)
{
    uint32_t refresh_mechanism = wdg_mechanism_mode1;
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a1dc:	2200      	movs	r2, #0
{
  14a1de:	b508      	push	{r3, r14}
    ASSERT_PARAMETER(base);
  14a1e0:	4613      	mov	r3, r2
  14a1e2:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a1e6:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a1ea:	4290      	cmp	r0, r2
  14a1ec:	bf18      	it	ne
  14a1ee:	4298      	cmpne	r0, r3
  14a1f0:	d01b      	beq.n	14a22a <wdg_refresh+0x4e>
  14a1f2:	2300      	movs	r3, #0
  14a1f4:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a1f8:	4298      	cmp	r0, r3
  14a1fa:	bf18      	it	ne
  14a1fc:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a200:	d013      	beq.n	14a22a <wdg_refresh+0x4e>
  14a202:	2200      	movs	r2, #0
  14a204:	4613      	mov	r3, r2
  14a206:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a20a:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a20e:	4290      	cmp	r0, r2
  14a210:	bf18      	it	ne
  14a212:	4298      	cmpne	r0, r3
  14a214:	d009      	beq.n	14a22a <wdg_refresh+0x4e>
  14a216:	2200      	movs	r2, #0
  14a218:	4613      	mov	r3, r2
  14a21a:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a21e:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a222:	4290      	cmp	r0, r2
  14a224:	bf18      	it	ne
  14a226:	4298      	cmpne	r0, r3
  14a228:	d116      	bne.n	14a258 <wdg_refresh+0x7c>
  14a22a:	4601      	mov	r1, r0

    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a22c:	f7ff fcd2 	bl	149bd4 <wdg_get_refesh_mechanism>

    if(refresh_mechanism > wdg_mechanism_mode_max){
  14a230:	2803      	cmp	r0, #3
  14a232:	d811      	bhi.n	14a258 <wdg_refresh+0x7c>
        return false;
    }

    //LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "refresh_mechanism after:%d\n",refresh_mechanism);

    switch (refresh_mechanism) {
  14a234:	b198      	cbz	r0, 14a25e <wdg_refresh+0x82>
  14a236:	2802      	cmp	r0, #2
  14a238:	d914      	bls.n	14a264 <wdg_refresh+0x88>
  14a23a:	2803      	cmp	r0, #3
  14a23c:	d10f      	bne.n	14a25e <wdg_refresh+0x82>
        }
        case wdg_mechanism_mode3:
        {
            // 3.read wdg_cnt and record it as tsr ref WatchdogMechanism3UpdataWdtCnt func
            // 4.write tsr to wdg_tsw. refesh will happen if the condition was right.
            uint32_t wdg_number = wdg_addr_to_number(base);
  14a23e:	4608      	mov	r0, r1
  14a240:	f7ff fae0 	bl	149804 <wdg_addr_to_number>
            //LTRACEF("watchdog mode set err wdg_number:%d,g_tsr[%d]:0x%x\n",wdg_number,wdg_number,g_tsr[wdg_number]);
            base->wdg_tsw = g_tsr[wdg_number];
  14a244:	f643 0288 	movw	r2, #14472	; 0x3888
            LTRACEF("watchdog mode set err refresh_mode:%d\n",refresh_mechanism);
            break;
        }
    }

    return true;
  14a248:	2301      	movs	r3, #1
            base->wdg_tsw = g_tsr[wdg_number];
  14a24a:	f2c0 0216 	movt	r2, #22
  14a24e:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
}
  14a252:	4618      	mov	r0, r3
            base->wdg_tsw = g_tsr[wdg_number];
  14a254:	620a      	str	r2, [r1, #32]
}
  14a256:	bd08      	pop	{r3, r15}
    ASSERT_PARAMETER(base);
  14a258:	2300      	movs	r3, #0
}
  14a25a:	4618      	mov	r0, r3
  14a25c:	bd08      	pop	{r3, r15}
    return true;
  14a25e:	2301      	movs	r3, #1
}
  14a260:	4618      	mov	r0, r3
  14a262:	bd08      	pop	{r3, r15}
            base->wdg_wrc_ctl |=WDG_WRC_CTRL_REFR_TRIG_MASK;
  14a264:	688a      	ldr	r2, [r1, #8]
    return true;
  14a266:	2301      	movs	r3, #1
}
  14a268:	4618      	mov	r0, r3
            base->wdg_wrc_ctl |=WDG_WRC_CTRL_REFR_TRIG_MASK;
  14a26a:	f042 0208 	orr.w	r2, r2, #8
  14a26e:	608a      	str	r2, [r1, #8]
}
  14a270:	bd08      	pop	{r3, r15}
  14a272:	bf00      	nop

0014a274 <wdg_set_reset_cnt>:
//!
//! \return true or false
//
//*****************************************************************************
bool wdg_set_reset_cnt(wdg_reg_type_t *base,uint32_t rst_delay)
{
  14a274:	b410      	push	{r4}
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a276:	2400      	movs	r4, #0
{
  14a278:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a27a:	4622      	mov	r2, r4
  14a27c:	f2cf 041c 	movt	r4, #61468	; 0xf01c
  14a280:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a284:	42a0      	cmp	r0, r4
  14a286:	bf18      	it	ne
  14a288:	4290      	cmpne	r0, r2
  14a28a:	d007      	beq.n	14a29c <wdg_set_reset_cnt+0x28>
  14a28c:	2200      	movs	r2, #0
  14a28e:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a292:	4290      	cmp	r0, r2
  14a294:	bf18      	it	ne
  14a296:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a29a:	d107      	bne.n	14a2ac <wdg_set_reset_cnt+0x38>

    //base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
    base->wdg_rst_ctl |=WDG_RST_CTRL_RST_CNT(rst_delay);
  14a29c:	695a      	ldr	r2, [r3, #20]
  14a29e:	b289      	uxth	r1, r1

    return true;
  14a2a0:	2001      	movs	r0, #1
    base->wdg_rst_ctl |=WDG_RST_CTRL_RST_CNT(rst_delay);
  14a2a2:	4311      	orrs	r1, r2
  14a2a4:	6159      	str	r1, [r3, #20]
}
  14a2a6:	f85d 4b04 	ldr.w	r4, [r13], #4
  14a2aa:	4770      	bx	r14
    ASSERT_PARAMETER(base);
  14a2ac:	2000      	movs	r0, #0
  14a2ae:	4602      	mov	r2, r0
  14a2b0:	f2cf 00a2 	movt	r0, #61602	; 0xf0a2
  14a2b4:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a2b8:	4283      	cmp	r3, r0
  14a2ba:	bf18      	it	ne
  14a2bc:	4293      	cmpne	r3, r2
  14a2be:	d0ed      	beq.n	14a29c <wdg_set_reset_cnt+0x28>
  14a2c0:	2000      	movs	r0, #0
  14a2c2:	4602      	mov	r2, r0
  14a2c4:	f2cf 00a4 	movt	r0, #61604	; 0xf0a4
  14a2c8:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a2cc:	4283      	cmp	r3, r0
  14a2ce:	bf18      	it	ne
  14a2d0:	4293      	cmpne	r3, r2
  14a2d2:	bf18      	it	ne
  14a2d4:	2000      	movne	r0, #0
  14a2d6:	d0e1      	beq.n	14a29c <wdg_set_reset_cnt+0x28>
  14a2d8:	e7e5      	b.n	14a2a6 <wdg_set_reset_cnt+0x32>
  14a2da:	bf00      	nop

0014a2dc <wdg_get_reset_cnt>:
uint32_t wdg_get_reset_cnt(wdg_reg_type_t *base)
{
    uint32_t reset_cnt = 0U;

    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a2dc:	2200      	movs	r2, #0
  14a2de:	4613      	mov	r3, r2
  14a2e0:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a2e4:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a2e8:	4290      	cmp	r0, r2
  14a2ea:	bf18      	it	ne
  14a2ec:	4298      	cmpne	r0, r3
  14a2ee:	d01d      	beq.n	14a32c <wdg_get_reset_cnt+0x50>
  14a2f0:	2300      	movs	r3, #0
  14a2f2:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a2f6:	4298      	cmp	r0, r3
  14a2f8:	bf18      	it	ne
  14a2fa:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a2fe:	d015      	beq.n	14a32c <wdg_get_reset_cnt+0x50>
  14a300:	2200      	movs	r2, #0
  14a302:	4613      	mov	r3, r2
  14a304:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a308:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a30c:	4290      	cmp	r0, r2
  14a30e:	bf18      	it	ne
  14a310:	4298      	cmpne	r0, r3
  14a312:	d00b      	beq.n	14a32c <wdg_get_reset_cnt+0x50>
  14a314:	2200      	movs	r2, #0
  14a316:	4613      	mov	r3, r2
  14a318:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a31c:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a320:	4290      	cmp	r0, r2
  14a322:	bf18      	it	ne
  14a324:	4298      	cmpne	r0, r3
  14a326:	d001      	beq.n	14a32c <wdg_get_reset_cnt+0x50>
  14a328:	2000      	movs	r0, #0

    reset_cnt |= (base->wdg_rst_ctl & WDG_RST_CTRL_RST_CNT_MASK);

    return reset_cnt;
}
  14a32a:	4770      	bx	r14
    reset_cnt |= (base->wdg_rst_ctl & WDG_RST_CTRL_RST_CNT_MASK);
  14a32c:	6940      	ldr	r0, [r0, #20]
  14a32e:	b280      	uxth	r0, r0
    return reset_cnt;
  14a330:	4770      	bx	r14
  14a332:	bf00      	nop

0014a334 <wdg_clear_reset_cnt>:
//
//*****************************************************************************
bool wdg_clear_reset_cnt(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a334:	2100      	movs	r1, #0
{
  14a336:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a338:	460a      	mov	r2, r1
  14a33a:	f2cf 011c 	movt	r1, #61468	; 0xf01c
  14a33e:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a342:	4288      	cmp	r0, r1
  14a344:	bf18      	it	ne
  14a346:	4290      	cmpne	r0, r2
  14a348:	d01d      	beq.n	14a386 <wdg_clear_reset_cnt+0x52>
  14a34a:	2200      	movs	r2, #0
  14a34c:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a350:	4290      	cmp	r0, r2
  14a352:	bf18      	it	ne
  14a354:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a358:	d015      	beq.n	14a386 <wdg_clear_reset_cnt+0x52>
  14a35a:	2100      	movs	r1, #0
  14a35c:	460a      	mov	r2, r1
  14a35e:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
  14a362:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a366:	4288      	cmp	r0, r1
  14a368:	bf18      	it	ne
  14a36a:	4290      	cmpne	r0, r2
  14a36c:	d00b      	beq.n	14a386 <wdg_clear_reset_cnt+0x52>
  14a36e:	2100      	movs	r1, #0
  14a370:	460a      	mov	r2, r1
  14a372:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
  14a376:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a37a:	4288      	cmp	r0, r1
  14a37c:	bf18      	it	ne
  14a37e:	4290      	cmpne	r0, r2
  14a380:	d001      	beq.n	14a386 <wdg_clear_reset_cnt+0x52>
  14a382:	2000      	movs	r0, #0

    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;

    return true;
}
  14a384:	4770      	bx	r14
    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
  14a386:	695a      	ldr	r2, [r3, #20]
    return true;
  14a388:	2001      	movs	r0, #1
    base->wdg_rst_ctl &= ~WDG_RST_CTRL_RST_CNT_MASK;
  14a38a:	0c12      	lsrs	r2, r2, #16
  14a38c:	0412      	lsls	r2, r2, #16
  14a38e:	615a      	str	r2, [r3, #20]
    return true;
  14a390:	4770      	bx	r14
  14a392:	bf00      	nop

0014a394 <wdg_get_ext_reset_cnt>:
uint32_t wdg_get_ext_reset_cnt(wdg_reg_type_t *base)
{
    uint32_t ext_reset_cnt = 0U;

    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a394:	2200      	movs	r2, #0
  14a396:	4613      	mov	r3, r2
  14a398:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a39c:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a3a0:	4290      	cmp	r0, r2
  14a3a2:	bf18      	it	ne
  14a3a4:	4298      	cmpne	r0, r3
  14a3a6:	d01d      	beq.n	14a3e4 <wdg_get_ext_reset_cnt+0x50>
  14a3a8:	2300      	movs	r3, #0
  14a3aa:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a3ae:	4298      	cmp	r0, r3
  14a3b0:	bf18      	it	ne
  14a3b2:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a3b6:	d015      	beq.n	14a3e4 <wdg_get_ext_reset_cnt+0x50>
  14a3b8:	2200      	movs	r2, #0
  14a3ba:	4613      	mov	r3, r2
  14a3bc:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a3c0:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a3c4:	4290      	cmp	r0, r2
  14a3c6:	bf18      	it	ne
  14a3c8:	4298      	cmpne	r0, r3
  14a3ca:	d00b      	beq.n	14a3e4 <wdg_get_ext_reset_cnt+0x50>
  14a3cc:	2200      	movs	r2, #0
  14a3ce:	4613      	mov	r3, r2
  14a3d0:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a3d4:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a3d8:	4290      	cmp	r0, r2
  14a3da:	bf18      	it	ne
  14a3dc:	4298      	cmpne	r0, r3
  14a3de:	d001      	beq.n	14a3e4 <wdg_get_ext_reset_cnt+0x50>
  14a3e0:	2000      	movs	r0, #0

    ext_reset_cnt |= (base->wdg_ext_rst_ctl & WDG_EXT_RST_CTRL_RST_CNT_MASK);

    return ext_reset_cnt;
}
  14a3e2:	4770      	bx	r14
    ext_reset_cnt |= (base->wdg_ext_rst_ctl & WDG_EXT_RST_CTRL_RST_CNT_MASK);
  14a3e4:	6980      	ldr	r0, [r0, #24]
  14a3e6:	b280      	uxth	r0, r0
    return ext_reset_cnt;
  14a3e8:	4770      	bx	r14
  14a3ea:	bf00      	nop

0014a3ec <wdg_clear_ext_reset_cnt>:
//
//*****************************************************************************
bool wdg_clear_ext_reset_cnt(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a3ec:	2100      	movs	r1, #0
{
  14a3ee:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a3f0:	460a      	mov	r2, r1
  14a3f2:	f2cf 011c 	movt	r1, #61468	; 0xf01c
  14a3f6:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a3fa:	4288      	cmp	r0, r1
  14a3fc:	bf18      	it	ne
  14a3fe:	4290      	cmpne	r0, r2
  14a400:	d01d      	beq.n	14a43e <wdg_clear_ext_reset_cnt+0x52>
  14a402:	2200      	movs	r2, #0
  14a404:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a408:	4290      	cmp	r0, r2
  14a40a:	bf18      	it	ne
  14a40c:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a410:	d015      	beq.n	14a43e <wdg_clear_ext_reset_cnt+0x52>
  14a412:	2100      	movs	r1, #0
  14a414:	460a      	mov	r2, r1
  14a416:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
  14a41a:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a41e:	4288      	cmp	r0, r1
  14a420:	bf18      	it	ne
  14a422:	4290      	cmpne	r0, r2
  14a424:	d00b      	beq.n	14a43e <wdg_clear_ext_reset_cnt+0x52>
  14a426:	2100      	movs	r1, #0
  14a428:	460a      	mov	r2, r1
  14a42a:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
  14a42e:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a432:	4288      	cmp	r0, r1
  14a434:	bf18      	it	ne
  14a436:	4290      	cmpne	r0, r2
  14a438:	d001      	beq.n	14a43e <wdg_clear_ext_reset_cnt+0x52>
  14a43a:	2000      	movs	r0, #0

    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;

    return true;
}
  14a43c:	4770      	bx	r14
    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;
  14a43e:	699a      	ldr	r2, [r3, #24]
    return true;
  14a440:	2001      	movs	r0, #1
    base->wdg_ext_rst_ctl &= ~WDG_EXT_RST_CTRL_RST_CNT_MASK;
  14a442:	0c12      	lsrs	r2, r2, #16
  14a444:	0412      	lsls	r2, r2, #16
  14a446:	619a      	str	r2, [r3, #24]
    return true;
  14a448:	4770      	bx	r14
  14a44a:	bf00      	nop

0014a44c <wdg_Int_register>:
//!
//! \return true or false.
//
//*****************************************************************************
bool wdg_Int_register(void *handle,wdg_reg_type_t *base,int_handler call_func,bool overflow_int)
{
  14a44c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    uint32_t refresh_mechanism = 0;
    uint32_t wdg_int_num = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a450:	2500      	movs	r5, #0
{
  14a452:	4606      	mov	r6, r0
    ASSERT_PARAMETER(base);
  14a454:	462c      	mov	r4, r5
  14a456:	f2cf 051c 	movt	r5, #61468	; 0xf01c
{
  14a45a:	4617      	mov	r7, r2
    ASSERT_PARAMETER(base);
  14a45c:	f2cf 041d 	movt	r4, #61469	; 0xf01d
{
  14a460:	4698      	mov	r8, r3
    ASSERT_PARAMETER(base);
  14a462:	42a9      	cmp	r1, r5
  14a464:	bf18      	it	ne
  14a466:	42a1      	cmpne	r1, r4
  14a468:	d007      	beq.n	14a47a <wdg_Int_register+0x2e>
  14a46a:	2200      	movs	r2, #0
  14a46c:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a470:	4291      	cmp	r1, r2
  14a472:	bf18      	it	ne
  14a474:	f111 6f76 	cmnne.w	r1, #257949696	; 0xf600000
  14a478:	d13b      	bne.n	14a4f2 <wdg_Int_register+0xa6>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "wdg_Int_register:\n");
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a47a:	4608      	mov	r0, r1
  14a47c:	f7ff fbaa 	bl	149bd4 <wdg_get_refesh_mechanism>
    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog  refresh_mechanism:%d\n",refresh_mechanism);
    if(WDG1_BASE == base){
  14a480:	2200      	movs	r2, #0
  14a482:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a486:	4291      	cmp	r1, r2
  14a488:	d024      	beq.n	14a4d4 <wdg_Int_register+0x88>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }else if(WDG2_BASE == base){
  14a48a:	2200      	movs	r2, #0
  14a48c:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a490:	4291      	cmp	r1, r2
        if(overflow_int){
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
  14a492:	bf08      	it	eq
  14a494:	2437      	moveq	r4, #55	; 0x37
    }else if(WDG2_BASE == base){
  14a496:	d021      	beq.n	14a4dc <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG2_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
        }
    }else if(WDG3_BASE == base){
  14a498:	f111 6f76 	cmn.w	r1, #257949696	; 0xf600000
  14a49c:	d041      	beq.n	14a522 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
        }
    }else if(WDG4_BASE == base){
  14a49e:	2300      	movs	r3, #0
  14a4a0:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a4a4:	4299      	cmp	r1, r3
  14a4a6:	d03c      	beq.n	14a522 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG4_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG4_OVFLOW_INT_NUM;
        }
    }else if(WDG5_BASE == base){
  14a4a8:	2300      	movs	r3, #0
  14a4aa:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
  14a4ae:	4299      	cmp	r1, r3
  14a4b0:	d037      	beq.n	14a522 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG5_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG5_OVFLOW_INT_NUM;
        }
    }else if(WDG6_BASE == base){
  14a4b2:	2300      	movs	r3, #0
  14a4b4:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a4b8:	4299      	cmp	r1, r3
  14a4ba:	d032      	beq.n	14a522 <wdg_Int_register+0xd6>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG6_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG6_OVFLOW_INT_NUM;
        }
    }else if(WDG7_BASE == base){
  14a4bc:	2300      	movs	r3, #0
  14a4be:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
  14a4c2:	4299      	cmp	r1, r3
        if(overflow_int){
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
  14a4c4:	bf08      	it	eq
  14a4c6:	243b      	moveq	r4, #59	; 0x3b
    }else if(WDG7_BASE == base){
  14a4c8:	d008      	beq.n	14a4dc <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
            wdg_int_num = WDG7_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
        }
    }else if(WDG8_BASE == base){
  14a4ca:	2300      	movs	r3, #0
  14a4cc:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a4d0:	4299      	cmp	r1, r3
  14a4d2:	d038      	beq.n	14a546 <wdg_Int_register+0xfa>
            wdg_int_num = WDG8_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
        }
    }else{
        if(overflow_int){
  14a4d4:	f1b8 0f00 	cmp.w	r8, #0
  14a4d8:	d02e      	beq.n	14a538 <wdg_Int_register+0xec>
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
  14a4da:	24dc      	movs	r4, #220	; 0xdc
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_int_num:%d\n",wdg_int_num);
    register_int_handler(wdg_int_num,call_func,handle);
  14a4dc:	4632      	mov	r2, r6
  14a4de:	4639      	mov	r1, r7
  14a4e0:	4620      	mov	r0, r4
  14a4e2:	f7f6 f8ff 	bl	1406e4 <register_int_handler>
    unmask_interrupt(wdg_int_num);
  14a4e6:	4620      	mov	r0, r4
  14a4e8:	f7f6 f94e 	bl	140788 <unmask_interrupt>
    return true;
  14a4ec:	2001      	movs	r0, #1
}
  14a4ee:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    ASSERT_PARAMETER(base);
  14a4f2:	2200      	movs	r2, #0
  14a4f4:	4613      	mov	r3, r2
  14a4f6:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a4fa:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a4fe:	4291      	cmp	r1, r2
  14a500:	bf18      	it	ne
  14a502:	4299      	cmpne	r1, r3
  14a504:	d0b9      	beq.n	14a47a <wdg_Int_register+0x2e>
  14a506:	2200      	movs	r2, #0
  14a508:	4613      	mov	r3, r2
  14a50a:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a50e:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a512:	4291      	cmp	r1, r2
  14a514:	bf18      	it	ne
  14a516:	4299      	cmpne	r1, r3
  14a518:	d113      	bne.n	14a542 <wdg_Int_register+0xf6>
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a51a:	4608      	mov	r0, r1
  14a51c:	f7ff fb5a 	bl	149bd4 <wdg_get_refesh_mechanism>
  14a520:	e7ba      	b.n	14a498 <wdg_Int_register+0x4c>
        if(overflow_int){
  14a522:	f1b8 0f00 	cmp.w	r8, #0
  14a526:	d001      	beq.n	14a52c <wdg_Int_register+0xe0>
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
  14a528:	24de      	movs	r4, #222	; 0xde
  14a52a:	e7d7      	b.n	14a4dc <wdg_Int_register+0x90>
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
  14a52c:	f010 0f03 	tst.w	r0, #3
  14a530:	bf0c      	ite	eq
  14a532:	24de      	moveq	r4, #222	; 0xde
  14a534:	24dd      	movne	r4, #221	; 0xdd
  14a536:	e7d1      	b.n	14a4dc <wdg_Int_register+0x90>
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
  14a538:	0783      	lsls	r3, r0, #30
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
  14a53a:	bf18      	it	ne
  14a53c:	24db      	movne	r4, #219	; 0xdb
        }else if(wdg_mechanism_mode3 & refresh_mechanism){
  14a53e:	d1cd      	bne.n	14a4dc <wdg_Int_register+0x90>
  14a540:	e7cb      	b.n	14a4da <wdg_Int_register+0x8e>
    ASSERT_PARAMETER(base);
  14a542:	2000      	movs	r0, #0
  14a544:	e7d3      	b.n	14a4ee <wdg_Int_register+0xa2>
        if(overflow_int){
  14a546:	f1b8 0f00 	cmp.w	r8, #0
  14a54a:	d105      	bne.n	14a558 <wdg_Int_register+0x10c>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
  14a54c:	f010 0f03 	tst.w	r0, #3
  14a550:	bf14      	ite	ne
  14a552:	24df      	movne	r4, #223	; 0xdf
  14a554:	24e0      	moveq	r4, #224	; 0xe0
  14a556:	e7c1      	b.n	14a4dc <wdg_Int_register+0x90>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
  14a558:	24e0      	movs	r4, #224	; 0xe0
  14a55a:	e7bf      	b.n	14a4dc <wdg_Int_register+0x90>

0014a55c <wdg_int_unregister>:
bool wdg_int_unregister(wdg_reg_type_t *base,bool overflow_int)
{
    uint32_t refresh_mechanism = 0;
    uint32_t wdg_int_num = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a55c:	2200      	movs	r2, #0
  14a55e:	4613      	mov	r3, r2
  14a560:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a564:	f2cf 031d 	movt	r3, #61469	; 0xf01d
{
  14a568:	b510      	push	{r4, r14}
  14a56a:	4604      	mov	r4, r0
    ASSERT_PARAMETER(base);
  14a56c:	4290      	cmp	r0, r2
  14a56e:	bf18      	it	ne
  14a570:	4298      	cmpne	r0, r3
  14a572:	d007      	beq.n	14a584 <wdg_int_unregister+0x28>
  14a574:	2300      	movs	r3, #0
  14a576:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a57a:	4298      	cmp	r0, r3
  14a57c:	bf18      	it	ne
  14a57e:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a582:	d132      	bne.n	14a5ea <wdg_int_unregister+0x8e>

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "wdg_int_unregister:\n");
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a584:	4620      	mov	r0, r4
  14a586:	f7ff fb25 	bl	149bd4 <wdg_get_refesh_mechanism>
    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog refresh_mechanism:%d\n",refresh_mechanism);

    if(WDG1_BASE ==base){
  14a58a:	2300      	movs	r3, #0
  14a58c:	f2cf 031c 	movt	r3, #61468	; 0xf01c
  14a590:	429c      	cmp	r4, r3
  14a592:	d047      	beq.n	14a624 <wdg_int_unregister+0xc8>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG1_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
        }
    }else if(WDG2_BASE ==base){
  14a594:	2300      	movs	r3, #0
  14a596:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a59a:	429c      	cmp	r4, r3
        if(overflow_int){
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
  14a59c:	bf08      	it	eq
  14a59e:	2037      	moveq	r0, #55	; 0x37
    }else if(WDG2_BASE ==base){
  14a5a0:	d01f      	beq.n	14a5e2 <wdg_int_unregister+0x86>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG2_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG2_OVFLOW_INT_NUM;
        }
    }else if(WDG3_BASE ==base){
  14a5a2:	f114 6f76 	cmn.w	r4, #257949696	; 0xf600000
  14a5a6:	d037      	beq.n	14a618 <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG3_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
        }
    }else if(WDG4_BASE ==base){
  14a5a8:	2300      	movs	r3, #0
  14a5aa:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a5ae:	429c      	cmp	r4, r3
  14a5b0:	d032      	beq.n	14a618 <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG4_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG4_OVFLOW_INT_NUM;
        }
    }else if(WDG5_BASE ==base){
  14a5b2:	2300      	movs	r3, #0
  14a5b4:	f2cf 03a2 	movt	r3, #61602	; 0xf0a2
  14a5b8:	429c      	cmp	r4, r3
  14a5ba:	d02d      	beq.n	14a618 <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG5_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG5_OVFLOW_INT_NUM;
        }
    }else if(WDG6_BASE ==base){
  14a5bc:	2300      	movs	r3, #0
  14a5be:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a5c2:	429c      	cmp	r4, r3
  14a5c4:	d028      	beq.n	14a618 <wdg_int_unregister+0xbc>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG6_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG6_OVFLOW_INT_NUM;
        }
    }else if(WDG7_BASE ==base){
  14a5c6:	2300      	movs	r3, #0
  14a5c8:	f2cf 03a4 	movt	r3, #61604	; 0xf0a4
  14a5cc:	429c      	cmp	r4, r3
        if(overflow_int){
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
  14a5ce:	bf08      	it	eq
  14a5d0:	203b      	moveq	r0, #59	; 0x3b
    }else if(WDG7_BASE ==base){
  14a5d2:	d006      	beq.n	14a5e2 <wdg_int_unregister+0x86>
        }else if(wdg_mechanism_mode2 & refresh_mechanism){
            wdg_int_num = WDG7_ILL_SEQ_REFR_INT_NUM;
        }else{
            wdg_int_num = WDG7_OVFLOW_INT_NUM;
        }
    }else if(WDG8_BASE ==base){
  14a5d4:	2300      	movs	r3, #0
  14a5d6:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a5da:	429c      	cmp	r4, r3
    uint32_t wdg_int_num = 0;
  14a5dc:	bf18      	it	ne
  14a5de:	2000      	movne	r0, #0
    }else if(WDG8_BASE ==base){
  14a5e0:	d03a      	beq.n	14a658 <wdg_int_unregister+0xfc>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
        }
    }

    LTRACEF_LEVEL(DEFAULT_WATCHOUT_LOG_LEVEL, "watchdog wdg_int_num:%d\n",wdg_int_num);
    mask_interrupt(wdg_int_num);
  14a5e2:	f7f6 f8a9 	bl	140738 <mask_interrupt>
    return true;
  14a5e6:	2001      	movs	r0, #1
}
  14a5e8:	bd10      	pop	{r4, r15}
    ASSERT_PARAMETER(base);
  14a5ea:	2200      	movs	r2, #0
  14a5ec:	4613      	mov	r3, r2
  14a5ee:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a5f2:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a5f6:	4290      	cmp	r0, r2
  14a5f8:	bf18      	it	ne
  14a5fa:	4298      	cmpne	r0, r3
  14a5fc:	d0c2      	beq.n	14a584 <wdg_int_unregister+0x28>
  14a5fe:	2200      	movs	r2, #0
  14a600:	4613      	mov	r3, r2
  14a602:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a606:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a60a:	4290      	cmp	r0, r2
  14a60c:	bf18      	it	ne
  14a60e:	4298      	cmpne	r0, r3
  14a610:	d120      	bne.n	14a654 <wdg_int_unregister+0xf8>
    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a612:	f7ff fadf 	bl	149bd4 <wdg_get_refesh_mechanism>
  14a616:	e7c4      	b.n	14a5a2 <wdg_int_unregister+0x46>
        if(overflow_int){
  14a618:	b151      	cbz	r1, 14a630 <wdg_int_unregister+0xd4>
            wdg_int_num = WDG3_OVFLOW_INT_NUM;
  14a61a:	20de      	movs	r0, #222	; 0xde
    mask_interrupt(wdg_int_num);
  14a61c:	f7f6 f88c 	bl	140738 <mask_interrupt>
    return true;
  14a620:	2001      	movs	r0, #1
  14a622:	e7e1      	b.n	14a5e8 <wdg_int_unregister+0x8c>
        if(overflow_int){
  14a624:	b169      	cbz	r1, 14a642 <wdg_int_unregister+0xe6>
            wdg_int_num = WDG1_OVFLOW_INT_NUM;
  14a626:	20dc      	movs	r0, #220	; 0xdc
    mask_interrupt(wdg_int_num);
  14a628:	f7f6 f886 	bl	140738 <mask_interrupt>
    return true;
  14a62c:	2001      	movs	r0, #1
  14a62e:	e7db      	b.n	14a5e8 <wdg_int_unregister+0x8c>
            wdg_int_num = WDG3_ILL_WIN_REFR_INT_NUM;
  14a630:	f010 0f02 	tst.w	r0, #2
  14a634:	bf0c      	ite	eq
  14a636:	20de      	moveq	r0, #222	; 0xde
  14a638:	20dd      	movne	r0, #221	; 0xdd
    mask_interrupt(wdg_int_num);
  14a63a:	f7f6 f87d 	bl	140738 <mask_interrupt>
    return true;
  14a63e:	2001      	movs	r0, #1
  14a640:	e7d2      	b.n	14a5e8 <wdg_int_unregister+0x8c>
            wdg_int_num = WDG1_ILL_WIN_REFR_INT_NUM;
  14a642:	f010 0f02 	tst.w	r0, #2
  14a646:	bf0c      	ite	eq
  14a648:	20dc      	moveq	r0, #220	; 0xdc
  14a64a:	20db      	movne	r0, #219	; 0xdb
    mask_interrupt(wdg_int_num);
  14a64c:	f7f6 f874 	bl	140738 <mask_interrupt>
    return true;
  14a650:	2001      	movs	r0, #1
  14a652:	e7c9      	b.n	14a5e8 <wdg_int_unregister+0x8c>
    ASSERT_PARAMETER(base);
  14a654:	2000      	movs	r0, #0
}
  14a656:	bd10      	pop	{r4, r15}
        if(overflow_int){
  14a658:	b929      	cbnz	r1, 14a666 <wdg_int_unregister+0x10a>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
  14a65a:	f010 0f02 	tst.w	r0, #2
  14a65e:	bf14      	ite	ne
  14a660:	20df      	movne	r0, #223	; 0xdf
  14a662:	20e0      	moveq	r0, #224	; 0xe0
  14a664:	e7bd      	b.n	14a5e2 <wdg_int_unregister+0x86>
            wdg_int_num = WDG8_OVFLOW_INT_NUM;
  14a666:	20e0      	movs	r0, #224	; 0xe0
  14a668:	e7bb      	b.n	14a5e2 <wdg_int_unregister+0x86>
  14a66a:	bf00      	nop

0014a66c <wdg_int_clear>:
//*****************************************************************************
bool wdg_int_clear(wdg_reg_type_t *base)
{
    uint32_t refresh_mechanism = 0;
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a66c:	2200      	movs	r2, #0
{
  14a66e:	b508      	push	{r3, r14}
    ASSERT_PARAMETER(base);
  14a670:	4613      	mov	r3, r2
  14a672:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a676:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a67a:	4290      	cmp	r0, r2
  14a67c:	bf18      	it	ne
  14a67e:	4298      	cmpne	r0, r3
  14a680:	d007      	beq.n	14a692 <wdg_int_clear+0x26>
  14a682:	2300      	movs	r3, #0
  14a684:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a688:	4298      	cmp	r0, r3
  14a68a:	bf18      	it	ne
  14a68c:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a690:	d10a      	bne.n	14a6a8 <wdg_int_clear+0x3c>
  14a692:	4601      	mov	r1, r0

    refresh_mechanism = wdg_get_refesh_mechanism(base);
  14a694:	f7ff fa9e 	bl	149bd4 <wdg_get_refesh_mechanism>

    switch (refresh_mechanism) {
  14a698:	2802      	cmp	r0, #2
  14a69a:	d025      	beq.n	14a6e8 <wdg_int_clear+0x7c>
  14a69c:	2803      	cmp	r0, #3
  14a69e:	d018      	beq.n	14a6d2 <wdg_int_clear+0x66>
  14a6a0:	2801      	cmp	r0, #1
  14a6a2:	d01c      	beq.n	14a6de <wdg_int_clear+0x72>
            break;
        }
        default:
        {
            LTRACEF("watchdog int enable err refresh_mechanism:%d\n",refresh_mechanism);
            return false;
  14a6a4:	2000      	movs	r0, #0
        }
    }
    return true;
}
  14a6a6:	bd08      	pop	{r3, r15}
    ASSERT_PARAMETER(base);
  14a6a8:	2200      	movs	r2, #0
  14a6aa:	4613      	mov	r3, r2
  14a6ac:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a6b0:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a6b4:	4290      	cmp	r0, r2
  14a6b6:	bf18      	it	ne
  14a6b8:	4298      	cmpne	r0, r3
  14a6ba:	d0ea      	beq.n	14a692 <wdg_int_clear+0x26>
  14a6bc:	2200      	movs	r2, #0
  14a6be:	4613      	mov	r3, r2
  14a6c0:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a6c4:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a6c8:	4290      	cmp	r0, r2
  14a6ca:	bf18      	it	ne
  14a6cc:	4298      	cmpne	r0, r3
  14a6ce:	d0e0      	beq.n	14a692 <wdg_int_clear+0x26>
  14a6d0:	e7e8      	b.n	14a6a4 <wdg_int_clear+0x38>
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_CLR_MASK;
  14a6d2:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    return true;
  14a6d4:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_SEQ_REFE_INT_CLR_MASK;
  14a6d6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  14a6da:	624b      	str	r3, [r1, #36]	; 0x24
}
  14a6dc:	bd08      	pop	{r3, r15}
            base->wdg_int |= WDG_INT_OVERFLOW_INT_CLR_MASK;
  14a6de:	6a4b      	ldr	r3, [r1, #36]	; 0x24
  14a6e0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  14a6e4:	624b      	str	r3, [r1, #36]	; 0x24
}
  14a6e6:	bd08      	pop	{r3, r15}
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_CLR_MASK;
  14a6e8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
    return true;
  14a6ea:	2001      	movs	r0, #1
            base->wdg_int |= WDG_INT_ILL_WIN_REFE_INT_CLR_MASK;
  14a6ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  14a6f0:	624b      	str	r3, [r1, #36]	; 0x24
}
  14a6f2:	bd08      	pop	{r3, r15}

0014a6f4 <wdg_halt_enable>:
//
//*****************************************************************************
bool wdg_halt_enable(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a6f4:	2100      	movs	r1, #0
{
  14a6f6:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a6f8:	460a      	mov	r2, r1
  14a6fa:	f2cf 011c 	movt	r1, #61468	; 0xf01c
  14a6fe:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a702:	4288      	cmp	r0, r1
  14a704:	bf18      	it	ne
  14a706:	4290      	cmpne	r0, r2
  14a708:	d01d      	beq.n	14a746 <wdg_halt_enable+0x52>
  14a70a:	2200      	movs	r2, #0
  14a70c:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a710:	4290      	cmp	r0, r2
  14a712:	bf18      	it	ne
  14a714:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a718:	d015      	beq.n	14a746 <wdg_halt_enable+0x52>
  14a71a:	2100      	movs	r1, #0
  14a71c:	460a      	mov	r2, r1
  14a71e:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
  14a722:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a726:	4288      	cmp	r0, r1
  14a728:	bf18      	it	ne
  14a72a:	4290      	cmpne	r0, r2
  14a72c:	d00b      	beq.n	14a746 <wdg_halt_enable+0x52>
  14a72e:	2100      	movs	r1, #0
  14a730:	460a      	mov	r2, r1
  14a732:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
  14a736:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a73a:	4288      	cmp	r0, r1
  14a73c:	bf18      	it	ne
  14a73e:	4290      	cmpne	r0, r2
  14a740:	d001      	beq.n	14a746 <wdg_halt_enable+0x52>
  14a742:	2000      	movs	r0, #0
    // Enable timer stalling.
    //
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;

    return true;
}
  14a744:	4770      	bx	r14
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;
  14a746:	681a      	ldr	r2, [r3, #0]
    return true;
  14a748:	2001      	movs	r0, #1
    base->wdg_ctrl |= WDG_CTRL_DBG_HALT_EN_MASK;
  14a74a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  14a74e:	601a      	str	r2, [r3, #0]
    return true;
  14a750:	4770      	bx	r14
  14a752:	bf00      	nop

0014a754 <wdg_halt_disable>:
//
//*****************************************************************************
bool wdg_halt_disable(wdg_reg_type_t *base)
{
    // Check the arguments.
    ASSERT_PARAMETER(base);
  14a754:	2100      	movs	r1, #0
{
  14a756:	4603      	mov	r3, r0
    ASSERT_PARAMETER(base);
  14a758:	460a      	mov	r2, r1
  14a75a:	f2cf 011c 	movt	r1, #61468	; 0xf01c
  14a75e:	f2cf 021d 	movt	r2, #61469	; 0xf01d
  14a762:	4288      	cmp	r0, r1
  14a764:	bf18      	it	ne
  14a766:	4290      	cmpne	r0, r2
  14a768:	d01d      	beq.n	14a7a6 <wdg_halt_disable+0x52>
  14a76a:	2200      	movs	r2, #0
  14a76c:	f2cf 02a1 	movt	r2, #61601	; 0xf0a1
  14a770:	4290      	cmp	r0, r2
  14a772:	bf18      	it	ne
  14a774:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a778:	d015      	beq.n	14a7a6 <wdg_halt_disable+0x52>
  14a77a:	2100      	movs	r1, #0
  14a77c:	460a      	mov	r2, r1
  14a77e:	f2cf 01a2 	movt	r1, #61602	; 0xf0a2
  14a782:	f2cf 02a3 	movt	r2, #61603	; 0xf0a3
  14a786:	4288      	cmp	r0, r1
  14a788:	bf18      	it	ne
  14a78a:	4290      	cmpne	r0, r2
  14a78c:	d00b      	beq.n	14a7a6 <wdg_halt_disable+0x52>
  14a78e:	2100      	movs	r1, #0
  14a790:	460a      	mov	r2, r1
  14a792:	f2cf 01a4 	movt	r1, #61604	; 0xf0a4
  14a796:	f2cf 02a5 	movt	r2, #61605	; 0xf0a5
  14a79a:	4288      	cmp	r0, r1
  14a79c:	bf18      	it	ne
  14a79e:	4290      	cmpne	r0, r2
  14a7a0:	d001      	beq.n	14a7a6 <wdg_halt_disable+0x52>
  14a7a2:	2000      	movs	r0, #0
    // Disable timer stalling.
    //
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);

    return true;
}
  14a7a4:	4770      	bx	r14
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);
  14a7a6:	681a      	ldr	r2, [r3, #0]
    return true;
  14a7a8:	2001      	movs	r0, #1
    base->wdg_ctrl &= ~(WDG_CTRL_DBG_HALT_EN_MASK);
  14a7aa:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  14a7ae:	601a      	str	r2, [r3, #0]
    return true;
  14a7b0:	4770      	bx	r14
  14a7b2:	bf00      	nop

0014a7b4 <wdg_get_cnt>:

uint32_t wdg_get_cnt(wdg_reg_type_t *base)
{
    ASSERT_PARAMETER(base);
  14a7b4:	2200      	movs	r2, #0
  14a7b6:	4613      	mov	r3, r2
  14a7b8:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a7bc:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a7c0:	4290      	cmp	r0, r2
  14a7c2:	bf18      	it	ne
  14a7c4:	4298      	cmpne	r0, r3
  14a7c6:	d01d      	beq.n	14a804 <wdg_get_cnt+0x50>
  14a7c8:	2300      	movs	r3, #0
  14a7ca:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a7ce:	4298      	cmp	r0, r3
  14a7d0:	bf18      	it	ne
  14a7d2:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a7d6:	d015      	beq.n	14a804 <wdg_get_cnt+0x50>
  14a7d8:	2200      	movs	r2, #0
  14a7da:	4613      	mov	r3, r2
  14a7dc:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a7e0:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a7e4:	4290      	cmp	r0, r2
  14a7e6:	bf18      	it	ne
  14a7e8:	4298      	cmpne	r0, r3
  14a7ea:	d00b      	beq.n	14a804 <wdg_get_cnt+0x50>
  14a7ec:	2200      	movs	r2, #0
  14a7ee:	4613      	mov	r3, r2
  14a7f0:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a7f4:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a7f8:	4290      	cmp	r0, r2
  14a7fa:	bf18      	it	ne
  14a7fc:	4298      	cmpne	r0, r3
  14a7fe:	d001      	beq.n	14a804 <wdg_get_cnt+0x50>
  14a800:	2000      	movs	r0, #0
    return base->wdg_cnt;
}
  14a802:	4770      	bx	r14
    return base->wdg_cnt;
  14a804:	69c0      	ldr	r0, [r0, #28]
  14a806:	4770      	bx	r14

0014a808 <wdg_set_reset>:
bool wdg_set_reset(wdg_reg_type_t *base,const wdg_config_t* wdg_config)
{
    uint32_t unlock_mask = WDG_LOCK_RST_LOCK_MASK
                            |WDG_LOCK_EXT_RST_LOCK_MASK;

    ASSERT_PARAMETER(base);
  14a808:	2200      	movs	r2, #0
{
  14a80a:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    ASSERT_PARAMETER(base);
  14a80c:	4613      	mov	r3, r2
  14a80e:	f2cf 021c 	movt	r2, #61468	; 0xf01c
  14a812:	f2cf 031d 	movt	r3, #61469	; 0xf01d
  14a816:	4290      	cmp	r0, r2
  14a818:	bf18      	it	ne
  14a81a:	4298      	cmpne	r0, r3
  14a81c:	d01d      	beq.n	14a85a <wdg_set_reset+0x52>
  14a81e:	2300      	movs	r3, #0
  14a820:	f2cf 03a1 	movt	r3, #61601	; 0xf0a1
  14a824:	4298      	cmp	r0, r3
  14a826:	bf18      	it	ne
  14a828:	f110 6f76 	cmnne.w	r0, #257949696	; 0xf600000
  14a82c:	d015      	beq.n	14a85a <wdg_set_reset+0x52>
  14a82e:	2200      	movs	r2, #0
  14a830:	4613      	mov	r3, r2
  14a832:	f2cf 02a2 	movt	r2, #61602	; 0xf0a2
  14a836:	f2cf 03a3 	movt	r3, #61603	; 0xf0a3
  14a83a:	4290      	cmp	r0, r2
  14a83c:	bf18      	it	ne
  14a83e:	4298      	cmpne	r0, r3
  14a840:	d00b      	beq.n	14a85a <wdg_set_reset+0x52>
  14a842:	2200      	movs	r2, #0
  14a844:	4613      	mov	r3, r2
  14a846:	f2cf 02a4 	movt	r2, #61604	; 0xf0a4
  14a84a:	f2cf 03a5 	movt	r3, #61605	; 0xf0a5
  14a84e:	4290      	cmp	r0, r2
  14a850:	bf18      	it	ne
  14a852:	4298      	cmpne	r0, r3
  14a854:	bf18      	it	ne
  14a856:	2000      	movne	r0, #0
  14a858:	d134      	bne.n	14a8c4 <wdg_set_reset+0xbc>
  14a85a:	4604      	mov	r4, r0
  14a85c:	460d      	mov	r5, r1
    wdg_unlock(base,unlock_mask);
  14a85e:	2118      	movs	r1, #24
  14a860:	f7fe ff9c 	bl	14979c <wdg_unlock>

    wdg_set_reset_cnt(base,0xf);
  14a864:	210f      	movs	r1, #15
  14a866:	4620      	mov	r0, r4
  14a868:	f7ff fd04 	bl	14a274 <wdg_set_reset_cnt>
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a86c:	6963      	ldr	r3, [r4, #20]
                                        |WDG_RST_CTRL_INT_RST_EN(wdg_config->wdg_reset_cfg.enableSysReset)
  14a86e:	f895 1022 	ldrb.w	r1, [r5, #34]	; 0x22
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a872:	8c2a      	ldrh	r2, [r5, #32]
                                        |WDG_RST_CTRL_RST_WIN(wdg_config->wdg_reset_cfg.plusRstWind);

    //set ext reset ctrl clear reset mode,not need ext reset mode,if need reset pmic so need config
    base->wdg_ext_rst_ctl &= 0x00000000;
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
                                        |WDG_EXT_RST_CTRL_INT_RST_EN(wdg_config->wdg_ext_reset_cfg.enableSysExtReset)
  14a874:	f895 7028 	ldrb.w	r7, [r5, #40]	; 0x28
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
  14a878:	8cee      	ldrh	r6, [r5, #38]	; 0x26
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
                                        |WDG_EXT_RST_CTRL_RST_WIN(wdg_config->wdg_ext_reset_cfg.plusRstWind);

    return true;
  14a87a:	2001      	movs	r0, #1
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a87c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
  14a880:	4313      	orrs	r3, r2
                                        |WDG_RST_CTRL_WDG_RST_EN(wdg_config->wdg_reset_cfg.enableWdgResetEn)
  14a882:	f895 1024 	ldrb.w	r1, [r5, #36]	; 0x24
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
  14a886:	f895 2023 	ldrb.w	r2, [r5, #35]	; 0x23
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a88a:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
  14a88e:	0452      	lsls	r2, r2, #17
                                        |WDG_RST_CTRL_RST_WIN(wdg_config->wdg_reset_cfg.plusRstWind);
  14a890:	f895 1025 	ldrb.w	r1, [r5, #37]	; 0x25
                                        |WDG_RST_CTRL_INT_RST_MODE(wdg_config->wdg_reset_cfg.SysRstMode)
  14a894:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a898:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  14a89c:	4313      	orrs	r3, r2
    base->wdg_ext_rst_ctl &= 0x00000000;
  14a89e:	2200      	movs	r2, #0
    base->wdg_rst_ctl |= WDG_RST_CTRL_RST_CNT(wdg_config->wdg_reset_cfg.wdgResetCnt)
  14a8a0:	6163      	str	r3, [r4, #20]
    base->wdg_ext_rst_ctl &= 0x00000000;
  14a8a2:	69a3      	ldr	r3, [r4, #24]
  14a8a4:	61a2      	str	r2, [r4, #24]
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
  14a8a6:	f895 2029 	ldrb.w	r2, [r5, #41]	; 0x29
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
  14a8aa:	69a3      	ldr	r3, [r4, #24]
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
  14a8ac:	0452      	lsls	r2, r2, #17
                                        |WDG_EXT_RST_CTRL_RST_WIN(wdg_config->wdg_ext_reset_cfg.plusRstWind);
  14a8ae:	f895 102a 	ldrb.w	r1, [r5, #42]	; 0x2a
                                        |WDG_EXT_RST_CTRL_INT_RST_MODE(wdg_config->wdg_ext_reset_cfg.SysExtRstMode)
  14a8b2:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
    base->wdg_ext_rst_ctl |= WDG_EXT_RST_CTRL_RST_CNT(wdg_config->wdg_ext_reset_cfg.wdgResetCnt)
  14a8b6:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
  14a8ba:	4333      	orrs	r3, r6
  14a8bc:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  14a8c0:	4313      	orrs	r3, r2
  14a8c2:	61a3      	str	r3, [r4, #24]
}
  14a8c4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  14a8c6:	bf00      	nop

0014a8c8 <sd_ipcc_chan_create_detailed.isra.1>:
    }

    return 0;
}

static sd_ipcc_chan_t *sd_ipcc_chan_create_detailed(int remote, char *name,
  14a8c8:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14a8cc:	4606      	mov	r6, r0
  14a8ce:	b08a      	sub	sp, #40	; 0x28
  14a8d0:	4688      	mov	r8, r1
    sd_ipcc_chan_t *chan;
    rpmsg_cfg_extend_t cfg;
    char thread_name[32];

    cfg.init_flags = flags;
    chan = malloc(sizeof(sd_ipcc_chan_t));
  14a8d2:	2090      	movs	r0, #144	; 0x90
  14a8d4:	2101      	movs	r1, #1
static sd_ipcc_chan_t *sd_ipcc_chan_create_detailed(int remote, char *name,
  14a8d6:	4615      	mov	r5, r2
  14a8d8:	461f      	mov	r7, r3
    chan = malloc(sizeof(sd_ipcc_chan_t));
  14a8da:	f008 faef 	bl	152ebc <calloc>

    if (!chan) {
  14a8de:	4604      	mov	r4, r0
  14a8e0:	2800      	cmp	r0, #0
  14a8e2:	d058      	beq.n	14a996 <sd_ipcc_chan_create_detailed.isra.1+0xce>
        dprintf(0, "%s: NO memory\n", __func__);
        return NULL;
    }
    memset(chan, 0, sizeof(sd_ipcc_chan_t));

    chan->mb_cl = hal_mb_get_client_with_addr((u8)cfg.mbox_src);
  14a8e4:	b2e8      	uxtb	r0, r5
  14a8e6:	f003 f9f5 	bl	14dcd4 <hal_mb_get_client_with_addr>
  14a8ea:	61e0      	str	r0, [r4, #28]
    if (!chan->mb_cl) {
  14a8ec:	2800      	cmp	r0, #0
  14a8ee:	d05d      	beq.n	14a9ac <sd_ipcc_chan_create_detailed.isra.1+0xe4>
        goto fail_out;
    }

    dprintf(SPEW, "ipcc: get mb handle src %d dst %d\n", cfg.mbox_src, cfg.mbox_dst);

    chan->mb_chan = hal_mb_request_channel_with_addr(chan->mb_cl, false,
  14a8f0:	f64a 22a9 	movw	r2, #43689	; 0xaaa9
  14a8f4:	0c29      	lsrs	r1, r5, #16
  14a8f6:	4633      	mov	r3, r6
  14a8f8:	f2c0 0214 	movt	r2, #20
  14a8fc:	9100      	str	r1, [sp, #0]
  14a8fe:	2100      	movs	r1, #0
  14a900:	f003 fa44 	bl	14dd8c <hal_mb_request_channel_with_addr>
  14a904:	6220      	str	r0, [r4, #32]
                                           ipcc_mb_receive_callback,
                                           remote, cfg.mbox_dst);
    if (!chan->mb_chan) {
  14a906:	2800      	cmp	r0, #0
  14a908:	d06e      	beq.n	14a9e8 <sd_ipcc_chan_create_detailed.isra.1+0x120>
        dprintf(0, "%s: request mb channel failed\n", __func__);
        goto fail_out;
    }

    snprintf(chan->ch_name, IPCC_MAX_NAME_SZ, "%s/%d", name, remote);
  14a90a:	f246 0240 	movw	r2, #24640	; 0x6040
  14a90e:	4643      	mov	r3, r8
  14a910:	9600      	str	r6, [sp, #0]
  14a912:	f2c0 0215 	movt	r2, #21
  14a916:	2110      	movs	r1, #16
  14a918:	4620      	mov	r0, r4
  14a91a:	f009 fb7d 	bl	154018 <snprintf>
    chan->myaddr = cfg.mbox_src;
    chan->ch_flags = flags;
    chan->callback = usr_cb;
    chan->rproc = remote;
  14a91e:	61a6      	str	r6, [r4, #24]
    chan->myaddr = cfg.mbox_src;
  14a920:	b2ab      	uxth	r3, r5
  14a922:	e9c4 5304 	strd	r5, r3, [r4, #16]
    chan->callback = usr_cb;
  14a926:	9b10      	ldr	r3, [sp, #64]	; 0x40
  14a928:	6263      	str	r3, [r4, #36]	; 0x24

    if (threaded) {
  14a92a:	b367      	cbz	r7, 14a986 <sd_ipcc_chan_create_detailed.isra.1+0xbe>
        event_init(&chan->mb_rx_event, false, EVENT_FLAG_AUTOUNSIGNAL);
  14a92c:	2201      	movs	r2, #1
  14a92e:	2100      	movs	r1, #0
  14a930:	f104 0054 	add.w	r0, r4, #84	; 0x54
  14a934:	f004 fb8e 	bl	14f054 <event_init>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14a938:	2300      	movs	r3, #0
        spin_lock_init(&chan->queue_lock);
        sd_rpbuf_init_queue(&chan->rx_queue);
  14a93a:	f104 0078 	add.w	r0, r4, #120	; 0x78
  14a93e:	6523      	str	r3, [r4, #80]	; 0x50
  14a940:	f001 fc2e 	bl	14c1a0 <sd_rpbuf_init_queue>

        chan->buf_pool = sd_rpbuf_create_pool(bufsz, bufnum);
  14a944:	e9dd 1011 	ldrd	r1, r0, [r13, #68]	; 0x44
  14a948:	f001 fa9a 	bl	14be80 <sd_rpbuf_create_pool>
  14a94c:	6760      	str	r0, [r4, #116]	; 0x74
        if (!chan->buf_pool) {
  14a94e:	2800      	cmp	r0, #0
  14a950:	d055      	beq.n	14a9fe <sd_ipcc_chan_create_detailed.isra.1+0x136>
            dprintf(CRITICAL, "failed to malloc rx buffers\n");
            goto fail_out;
        }

        snprintf(thread_name, 32, "rx-%s", chan->ch_name);
  14a952:	f246 0268 	movw	r2, #24680	; 0x6068
  14a956:	4623      	mov	r3, r4
  14a958:	2120      	movs	r1, #32
  14a95a:	f2c0 0215 	movt	r2, #21
  14a95e:	a802      	add	r0, sp, #8
  14a960:	f009 fb5a 	bl	154018 <snprintf>
        chan->mb_rx_thread = thread_create(thread_name, ipcc_mb_rx_thread,
  14a964:	f44f 6380 	mov.w	r3, #1024	; 0x400
  14a968:	f64a 211d 	movw	r1, #43549	; 0xaa1d
  14a96c:	a802      	add	r0, sp, #8
  14a96e:	9300      	str	r3, [sp, #0]
  14a970:	f2c0 0114 	movt	r1, #20
  14a974:	2318      	movs	r3, #24
  14a976:	4622      	mov	r2, r4
  14a978:	f004 fe5a 	bl	14f630 <thread_create>
  14a97c:	6720      	str	r0, [r4, #112]	; 0x70
                      (void *)chan, THREAD_PRI_IPCC_RX, CONFIG_CHAN_STACK_SIZE);
        if (!chan->mb_rx_thread) {
  14a97e:	2800      	cmp	r0, #0
  14a980:	d044      	beq.n	14aa0c <sd_ipcc_chan_create_detailed.isra.1+0x144>
            dprintf(CRITICAL, "failed to create thread create\n");
            goto fail_out;
        }
        thread_detach_and_resume(chan->mb_rx_thread);
  14a982:	f005 f9bf 	bl	14fd04 <thread_detach_and_resume>
        dprintf(1, "rx thread prio=%d stack=%d\n", THREAD_PRI_IPCC_RX, CONFIG_CHAN_STACK_SIZE);
    }

    hal_mb_set_user(chan->mb_cl, (void *)chan);
  14a986:	69e0      	ldr	r0, [r4, #28]
  14a988:	4621      	mov	r1, r4
  14a98a:	f003 f987 	bl	14dc9c <hal_mb_set_user>
        hal_mb_put_client(chan->mb_cl);

    free(chan);

    return NULL;
}
  14a98e:	4620      	mov	r0, r4
  14a990:	b00a      	add	sp, #40	; 0x28
  14a992:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(0, "%s: NO memory\n", __func__);
  14a996:	f645 7188 	movw	r1, #24456	; 0x5f88
  14a99a:	f645 70f4 	movw	r0, #24564	; 0x5ff4
  14a99e:	f2c0 0115 	movt	r1, #21
  14a9a2:	f2c0 0015 	movt	r0, #21
  14a9a6:	f009 fba7 	bl	1540f8 <_printf>
  14a9aa:	e7f0      	b.n	14a98e <sd_ipcc_chan_create_detailed.isra.1+0xc6>
        dprintf(0, "%s: get mb handle failed\n", __func__);
  14a9ac:	f645 7188 	movw	r1, #24456	; 0x5f88
  14a9b0:	f246 0004 	movw	r0, #24580	; 0x6004
  14a9b4:	f2c0 0115 	movt	r1, #21
  14a9b8:	f2c0 0015 	movt	r0, #21
  14a9bc:	f009 fb9c 	bl	1540f8 <_printf>
    if (chan->buf_pool)
  14a9c0:	6f60      	ldr	r0, [r4, #116]	; 0x74
  14a9c2:	b108      	cbz	r0, 14a9c8 <sd_ipcc_chan_create_detailed.isra.1+0x100>
        sd_rpbuf_remove_pool(chan->buf_pool);
  14a9c4:	f001 fa82 	bl	14becc <sd_rpbuf_remove_pool>
    if (chan->mb_chan)
  14a9c8:	6a20      	ldr	r0, [r4, #32]
  14a9ca:	b108      	cbz	r0, 14a9d0 <sd_ipcc_chan_create_detailed.isra.1+0x108>
        hal_mb_free_channel(chan->mb_chan);
  14a9cc:	f003 fa34 	bl	14de38 <hal_mb_free_channel>
    if (chan->mb_cl)
  14a9d0:	69e0      	ldr	r0, [r4, #28]
  14a9d2:	b108      	cbz	r0, 14a9d8 <sd_ipcc_chan_create_detailed.isra.1+0x110>
        hal_mb_put_client(chan->mb_cl);
  14a9d4:	f003 fa52 	bl	14de7c <hal_mb_put_client>
    free(chan);
  14a9d8:	4620      	mov	r0, r4
    return NULL;
  14a9da:	2400      	movs	r4, #0
    free(chan);
  14a9dc:	f008 fa8e 	bl	152efc <free>
}
  14a9e0:	4620      	mov	r0, r4
  14a9e2:	b00a      	add	sp, #40	; 0x28
  14a9e4:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(0, "%s: request mb channel failed\n", __func__);
  14a9e8:	f645 7188 	movw	r1, #24456	; 0x5f88
  14a9ec:	f246 0020 	movw	r0, #24608	; 0x6020
  14a9f0:	f2c0 0115 	movt	r1, #21
  14a9f4:	f2c0 0015 	movt	r0, #21
  14a9f8:	f009 fb7e 	bl	1540f8 <_printf>
  14a9fc:	e7e0      	b.n	14a9c0 <sd_ipcc_chan_create_detailed.isra.1+0xf8>
            dprintf(CRITICAL, "failed to malloc rx buffers\n");
  14a9fe:	f246 0048 	movw	r0, #24648	; 0x6048
  14aa02:	f2c0 0015 	movt	r0, #21
  14aa06:	f009 fb77 	bl	1540f8 <_printf>
  14aa0a:	e7d9      	b.n	14a9c0 <sd_ipcc_chan_create_detailed.isra.1+0xf8>
            dprintf(CRITICAL, "failed to create thread create\n");
  14aa0c:	f246 0070 	movw	r0, #24688	; 0x6070
  14aa10:	f2c0 0015 	movt	r0, #21
  14aa14:	f009 fb70 	bl	1540f8 <_printf>
  14aa18:	e7d2      	b.n	14a9c0 <sd_ipcc_chan_create_detailed.isra.1+0xf8>
  14aa1a:	bf00      	nop

0014aa1c <ipcc_mb_rx_thread>:
{
  14aa1c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14aa20:	4604      	mov	r4, r0
    spin_lock_saved_state_t state = 0;
  14aa22:	f04f 0900 	mov.w	r9, #0
  14aa26:	f100 0854 	add.w	r8, r0, #84	; 0x54
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14aa2a:	2701      	movs	r7, #1
  14aa2c:	f100 0678 	add.w	r6, r0, #120	; 0x78
  14aa30:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14aa34:	4640      	mov	r0, r8
  14aa36:	f004 fb23 	bl	14f080 <event_wait_timeout>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14aa3a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14aa3e:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14aa40:	bf48      	it	mi
  14aa42:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14aa44:	d41e      	bmi.n	14aa84 <ipcc_mb_rx_thread+0x68>
  14aa46:	e01b      	b.n	14aa80 <ipcc_mb_rx_thread+0x64>
            ibuf = sd_rpbuf_dequeue(&chan->rx_queue);
  14aa48:	4630      	mov	r0, r6
  14aa4a:	f001 fc11 	bl	14c270 <sd_rpbuf_dequeue>
            if (!ibuf) {
  14aa4e:	4603      	mov	r3, r0
  14aa50:	b328      	cbz	r0, 14aa9e <ipcc_mb_rx_thread+0x82>
            chan->rx_cnt++;
  14aa52:	6b20      	ldr	r0, [r4, #48]	; 0x30
            chan->rx_bytes += ibuf->data_len;
  14aa54:	89da      	ldrh	r2, [r3, #14]
  14aa56:	6aa1      	ldr	r1, [r4, #40]	; 0x28
    *lock = 0;
  14aa58:	f8c4 a050 	str.w	r10, [r4, #80]	; 0x50
            chan->rx_cnt++;
  14aa5c:	3001      	adds	r0, #1
            chan->rx_bytes += ibuf->data_len;
  14aa5e:	4411      	add	r1, r2
            chan->rx_cnt++;
  14aa60:	6320      	str	r0, [r4, #48]	; 0x30
            chan->rx_bytes += ibuf->data_len;
  14aa62:	62a1      	str	r1, [r4, #40]	; 0x28
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14aa64:	b10d      	cbz	r5, 14aa6a <ipcc_mb_rx_thread+0x4e>
    __asm__ volatile("cpsie i");
  14aa66:	b662      	cpsie	i
  14aa68:	89da      	ldrh	r2, [r3, #14]
    if (chan && chan->callback) {
  14aa6a:	6a65      	ldr	r5, [r4, #36]	; 0x24
        chan->callback(chan, mssg, len);
  14aa6c:	4620      	mov	r0, r4
            ipcc_mb_interrupt(chan, ibuf->buffer, ibuf->data_len);
  14aa6e:	6899      	ldr	r1, [r3, #8]
    if (chan && chan->callback) {
  14aa70:	b105      	cbz	r5, 14aa74 <ipcc_mb_rx_thread+0x58>
        chan->callback(chan, mssg, len);
  14aa72:	47a8      	blx	r5
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14aa74:	f3ef 8300 	mrs	r3, CPSR
    spin_lock_saved_state_t state = 0;
  14aa78:	2500      	movs	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14aa7a:	f013 0f80 	tst.w	r3, #128	; 0x80
  14aa7e:	d101      	bne.n	14aa84 <ipcc_mb_rx_thread+0x68>
    __asm__ volatile("cpsid i");
  14aa80:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14aa82:	2501      	movs	r5, #1
    *lock = 1;
  14aa84:	6527      	str	r7, [r4, #80]	; 0x50
        while(!sd_rpbuf_queue_empty(&chan->rx_queue)) {
  14aa86:	4630      	mov	r0, r6
  14aa88:	f001 fc16 	bl	14c2b8 <sd_rpbuf_queue_empty>
  14aa8c:	4682      	mov	r10, r0
  14aa8e:	2800      	cmp	r0, #0
  14aa90:	d0da      	beq.n	14aa48 <ipcc_mb_rx_thread+0x2c>
    *lock = 0;
  14aa92:	f8c4 9050 	str.w	r9, [r4, #80]	; 0x50
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14aa96:	2d00      	cmp	r5, #0
  14aa98:	d0ca      	beq.n	14aa30 <ipcc_mb_rx_thread+0x14>
    __asm__ volatile("cpsie i");
  14aa9a:	b662      	cpsie	i
  14aa9c:	e7c8      	b.n	14aa30 <ipcc_mb_rx_thread+0x14>
    *lock = 0;
  14aa9e:	6520      	str	r0, [r4, #80]	; 0x50
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14aaa0:	2d00      	cmp	r5, #0
  14aaa2:	d1fa      	bne.n	14aa9a <ipcc_mb_rx_thread+0x7e>
  14aaa4:	e7c4      	b.n	14aa30 <ipcc_mb_rx_thread+0x14>
  14aaa6:	bf00      	nop

0014aaa8 <ipcc_mb_receive_callback>:
{
  14aaa8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14aaac:	460f      	mov	r7, r1
  14aaae:	4616      	mov	r6, r2
  14aab0:	4605      	mov	r5, r0
    chan = hal_mb_get_user(cl);
  14aab2:	f003 f903 	bl	14dcbc <hal_mb_get_user>
    if (!chan) {
  14aab6:	2800      	cmp	r0, #0
  14aab8:	d065      	beq.n	14ab86 <ipcc_mb_receive_callback+0xde>
    if (chan->mb_rx_thread) {
  14aaba:	6f03      	ldr	r3, [r0, #112]	; 0x70
  14aabc:	4604      	mov	r4, r0
  14aabe:	2b00      	cmp	r3, #0
  14aac0:	d04c      	beq.n	14ab5c <ipcc_mb_receive_callback+0xb4>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14aac2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14aac6:	f013 0580 	ands.w	r5, r3, #128	; 0x80
  14aaca:	d01e      	beq.n	14ab0a <ipcc_mb_receive_callback+0x62>
    *lock = 1;
  14aacc:	2301      	movs	r3, #1
        ibuf = sd_rpbuf_alloc(chan->buf_pool, SD_RPBUF_F_RX);
  14aace:	4619      	mov	r1, r3
  14aad0:	6503      	str	r3, [r0, #80]	; 0x50
  14aad2:	6f40      	ldr	r0, [r0, #116]	; 0x74
  14aad4:	f001 fa26 	bl	14bf24 <sd_rpbuf_alloc>
        if (!ibuf) {
  14aad8:	4680      	mov	r8, r0
  14aada:	2800      	cmp	r0, #0
  14aadc:	d06b      	beq.n	14abb6 <ipcc_mb_receive_callback+0x10e>
        if (mssg && len)
  14aade:	1c3d      	adds	r5, r7, #0
  14aae0:	bf18      	it	ne
  14aae2:	2501      	movne	r5, #1
  14aae4:	f104 0978 	add.w	r9, r4, #120	; 0x78
  14aae8:	2e00      	cmp	r6, #0
  14aaea:	bf08      	it	eq
  14aaec:	2500      	moveq	r5, #0
  14aaee:	2d00      	cmp	r5, #0
  14aaf0:	d167      	bne.n	14abc2 <ipcc_mb_receive_callback+0x11a>
        sd_rpbuf_enqueue(&chan->rx_queue, ibuf);
  14aaf2:	4641      	mov	r1, r8
  14aaf4:	4648      	mov	r0, r9
  14aaf6:	f001 fb97 	bl	14c228 <sd_rpbuf_enqueue>
    *lock = 0;
  14aafa:	6525      	str	r5, [r4, #80]	; 0x50
        event_signal(&chan->mb_rx_event, false);
  14aafc:	2100      	movs	r1, #0
  14aafe:	f104 0054 	add.w	r0, r4, #84	; 0x54
}
  14ab02:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        event_signal(&chan->mb_rx_event, false);
  14ab06:	f004 bae1 	b.w	14f0cc <event_signal>
    __asm__ volatile("cpsid i");
  14ab0a:	b672      	cpsid	i
    *lock = 1;
  14ab0c:	2301      	movs	r3, #1
        ibuf = sd_rpbuf_alloc(chan->buf_pool, SD_RPBUF_F_RX);
  14ab0e:	4619      	mov	r1, r3
  14ab10:	6503      	str	r3, [r0, #80]	; 0x50
  14ab12:	6f40      	ldr	r0, [r0, #116]	; 0x74
  14ab14:	f001 fa06 	bl	14bf24 <sd_rpbuf_alloc>
        if (!ibuf) {
  14ab18:	4681      	mov	r9, r0
  14ab1a:	2800      	cmp	r0, #0
  14ab1c:	d03d      	beq.n	14ab9a <ipcc_mb_receive_callback+0xf2>
        if (mssg && len)
  14ab1e:	f117 0800 	adds.w	r8, r7, #0
  14ab22:	bf18      	it	ne
  14ab24:	f04f 0801 	movne.w	r8, #1
  14ab28:	f104 0a78 	add.w	r10, r4, #120	; 0x78
  14ab2c:	2e00      	cmp	r6, #0
  14ab2e:	bf08      	it	eq
  14ab30:	f04f 0800 	moveq.w	r8, #0
  14ab34:	f1b8 0f00 	cmp.w	r8, #0
  14ab38:	d01e      	beq.n	14ab78 <ipcc_mb_receive_callback+0xd0>
            sd_rpbuf_push_data(ibuf, mssg, len);
  14ab3a:	4632      	mov	r2, r6
  14ab3c:	4639      	mov	r1, r7
  14ab3e:	f001 faf1 	bl	14c124 <sd_rpbuf_push_data>
        sd_rpbuf_enqueue(&chan->rx_queue, ibuf);
  14ab42:	4649      	mov	r1, r9
  14ab44:	4650      	mov	r0, r10
  14ab46:	f001 fb6f 	bl	14c228 <sd_rpbuf_enqueue>
    *lock = 0;
  14ab4a:	6525      	str	r5, [r4, #80]	; 0x50
    __asm__ volatile("cpsie i");
  14ab4c:	b662      	cpsie	i
        event_signal(&chan->mb_rx_event, false);
  14ab4e:	2100      	movs	r1, #0
  14ab50:	f104 0054 	add.w	r0, r4, #84	; 0x54
}
  14ab54:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        event_signal(&chan->mb_rx_event, false);
  14ab58:	f004 bab8 	b.w	14f0cc <event_signal>
    chan->rx_cnt++;
  14ab5c:	6b02      	ldr	r2, [r0, #48]	; 0x30
    chan->rx_bytes += len;
  14ab5e:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if (chan && chan->callback) {
  14ab60:	6a45      	ldr	r5, [r0, #36]	; 0x24
    chan->rx_cnt++;
  14ab62:	3201      	adds	r2, #1
    chan->rx_bytes += len;
  14ab64:	4433      	add	r3, r6
    chan->rx_cnt++;
  14ab66:	6302      	str	r2, [r0, #48]	; 0x30
    chan->rx_bytes += len;
  14ab68:	6283      	str	r3, [r0, #40]	; 0x28
    if (chan && chan->callback) {
  14ab6a:	b3ad      	cbz	r5, 14abd8 <ipcc_mb_receive_callback+0x130>
        chan->callback(chan, mssg, len);
  14ab6c:	4632      	mov	r2, r6
  14ab6e:	4639      	mov	r1, r7
  14ab70:	462b      	mov	r3, r5
}
  14ab72:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        chan->callback(chan, mssg, len);
  14ab76:	4718      	bx	r3
        sd_rpbuf_enqueue(&chan->rx_queue, ibuf);
  14ab78:	4649      	mov	r1, r9
  14ab7a:	4650      	mov	r0, r10
  14ab7c:	f001 fb54 	bl	14c228 <sd_rpbuf_enqueue>
  14ab80:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
  14ab84:	e7e2      	b.n	14ab4c <ipcc_mb_receive_callback+0xa4>
        dprintf(ALWAYS, "ipcc: no chan (0x%x) found\n", (int)cl->this_addr);
  14ab86:	f645 70a8 	movw	r0, #24488	; 0x5fa8
  14ab8a:	f895 1032 	ldrb.w	r1, [r5, #50]	; 0x32
  14ab8e:	f2c0 0015 	movt	r0, #21
}
  14ab92:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        dprintf(ALWAYS, "ipcc: no chan (0x%x) found\n", (int)cl->this_addr);
  14ab96:	f009 baaf 	b.w	1540f8 <_printf>
            chan->drop_cnt++;
  14ab9a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  14ab9c:	6520      	str	r0, [r4, #80]	; 0x50
  14ab9e:	3301      	adds	r3, #1
  14aba0:	63e3      	str	r3, [r4, #60]	; 0x3c
  14aba2:	b662      	cpsie	i
            dprintf(ALWAYS, "ipcc: %s no enough rxbuf, need flow control\n", chan->ch_name);
  14aba4:	f645 70c4 	movw	r0, #24516	; 0x5fc4
  14aba8:	4621      	mov	r1, r4
  14abaa:	f2c0 0015 	movt	r0, #21
}
  14abae:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
            dprintf(ALWAYS, "ipcc: %s no enough rxbuf, need flow control\n", chan->ch_name);
  14abb2:	f009 baa1 	b.w	1540f8 <_printf>
            chan->drop_cnt++;
  14abb6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  14abb8:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
  14abbc:	3301      	adds	r3, #1
  14abbe:	63e3      	str	r3, [r4, #60]	; 0x3c
  14abc0:	e7f0      	b.n	14aba4 <ipcc_mb_receive_callback+0xfc>
            sd_rpbuf_push_data(ibuf, mssg, len);
  14abc2:	4632      	mov	r2, r6
  14abc4:	4639      	mov	r1, r7
  14abc6:	f001 faad 	bl	14c124 <sd_rpbuf_push_data>
        sd_rpbuf_enqueue(&chan->rx_queue, ibuf);
  14abca:	4641      	mov	r1, r8
  14abcc:	4648      	mov	r0, r9
  14abce:	f001 fb2b 	bl	14c228 <sd_rpbuf_enqueue>
  14abd2:	2300      	movs	r3, #0
  14abd4:	6523      	str	r3, [r4, #80]	; 0x50
  14abd6:	e791      	b.n	14aafc <ipcc_mb_receive_callback+0x54>
}
  14abd8:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}

0014abdc <sd_ipcc_alloc_send_buffer>:
{
  14abdc:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (!len || !idx || *len > HAL_MB_MTU) {
  14abde:	fab2 f382 	clz	r3, r2
  14abe2:	095b      	lsrs	r3, r3, #5
  14abe4:	2900      	cmp	r1, #0
  14abe6:	bf14      	ite	ne
  14abe8:	461c      	movne	r4, r3
  14abea:	2401      	moveq	r4, #1
  14abec:	b9cc      	cbnz	r4, 14ac22 <sd_ipcc_alloc_send_buffer+0x46>
  14abee:	680b      	ldr	r3, [r1, #0]
  14abf0:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
  14abf4:	d815      	bhi.n	14ac22 <sd_ipcc_alloc_send_buffer+0x46>
  14abf6:	460d      	mov	r5, r1
    rpbuf = sd_rpbuf_alloc(chan->buf_pool, SD_RPBUF_F_TX);
  14abf8:	2102      	movs	r1, #2
  14abfa:	6f40      	ldr	r0, [r0, #116]	; 0x74
  14abfc:	4616      	mov	r6, r2
  14abfe:	f001 f991 	bl	14bf24 <sd_rpbuf_alloc>
    if (!rpbuf) {
  14ac02:	b170      	cbz	r0, 14ac22 <sd_ipcc_alloc_send_buffer+0x46>
    *len = MIN(*len, rpbuf->buf_size);
  14ac04:	682b      	ldr	r3, [r5, #0]
  14ac06:	f8b0 c00c 	ldrh.w	r12, [r0, #12]
    *idx = rpbuf->buf_id & 0xffff;
  14ac0a:	8a47      	ldrh	r7, [r0, #18]
    return sd_rpbuf_pop_data(rpbuf, NULL, 0);
  14ac0c:	4622      	mov	r2, r4
  14ac0e:	4621      	mov	r1, r4
    *len = MIN(*len, rpbuf->buf_size);
  14ac10:	4563      	cmp	r3, r12
  14ac12:	bf28      	it	cs
  14ac14:	4663      	movcs	r3, r12
  14ac16:	602b      	str	r3, [r5, #0]
    *idx = rpbuf->buf_id & 0xffff;
  14ac18:	8037      	strh	r7, [r6, #0]
}
  14ac1a:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    return sd_rpbuf_pop_data(rpbuf, NULL, 0);
  14ac1e:	f001 baa3 	b.w	14c168 <sd_rpbuf_pop_data>
}
  14ac22:	2000      	movs	r0, #0
  14ac24:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  14ac26:	bf00      	nop

0014ac28 <sd_ipcc_chan_create_mq>:

sd_ipcc_chan_t *sd_ipcc_chan_create_mq(int remote, char *name,
        int myaddr, int flags, ipcc_usr_cb usr_cb, int queues, int size)
{
  14ac28:	461a      	mov	r2, r3
    return sd_ipcc_chan_create_detailed(remote, name,
  14ac2a:	2301      	movs	r3, #1
  14ac2c:	f7ff be4c 	b.w	14a8c8 <sd_ipcc_chan_create_detailed.isra.1>

0014ac30 <sd_ipcc_chan_create>:
                myaddr, flags, true, usr_cb, queues, size);
}

sd_ipcc_chan_t *sd_ipcc_chan_create(int remote, char *name,
        int myaddr, int flags, ipcc_usr_cb usr_cb)
{
  14ac30:	b530      	push	{r4, r5, r14}
    return sd_ipcc_chan_create_detailed(remote, name,
  14ac32:	2400      	movs	r4, #0
{
  14ac34:	b085      	sub	sp, #20
    return sd_ipcc_chan_create_detailed(remote, name,
  14ac36:	461a      	mov	r2, r3
  14ac38:	4623      	mov	r3, r4
  14ac3a:	9402      	str	r4, [sp, #8]
{
  14ac3c:	9d08      	ldr	r5, [sp, #32]
    return sd_ipcc_chan_create_detailed(remote, name,
  14ac3e:	e9cd 5400 	strd	r5, r4, [r13]
  14ac42:	f7ff fe41 	bl	14a8c8 <sd_ipcc_chan_create_detailed.isra.1>
                myaddr, flags, false, usr_cb, 0, 0);
}
  14ac46:	b005      	add	sp, #20
  14ac48:	bd30      	pop	{r4, r5, r15}
  14ac4a:	bf00      	nop

0014ac4c <sd_ipcc_chan_free>:

void sd_ipcc_chan_free(sd_ipcc_chan_t *chan)
{
  14ac4c:	b510      	push	{r4, r14}
  14ac4e:	4604      	mov	r4, r0
    if (chan->buf_pool)
  14ac50:	6f40      	ldr	r0, [r0, #116]	; 0x74
  14ac52:	b108      	cbz	r0, 14ac58 <sd_ipcc_chan_free+0xc>
        sd_rpbuf_remove_pool(chan->buf_pool);
  14ac54:	f001 f93a 	bl	14becc <sd_rpbuf_remove_pool>

    hal_mb_free_channel(chan->mb_chan);
  14ac58:	6a20      	ldr	r0, [r4, #32]
  14ac5a:	f003 f8ed 	bl	14de38 <hal_mb_free_channel>
    hal_mb_put_client(chan->mb_cl);
  14ac5e:	69e0      	ldr	r0, [r4, #28]
  14ac60:	f003 f90c 	bl	14de7c <hal_mb_put_client>

    memset(chan, 0xcd, sizeof(sd_ipcc_chan_t));
    free(chan);
  14ac64:	4620      	mov	r0, r4
}
  14ac66:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    free(chan);
  14ac6a:	f008 b947 	b.w	152efc <free>
  14ac6e:	bf00      	nop

0014ac70 <sd_ipcc_chan_send_data>:

    return ret;
}

int sd_ipcc_chan_send_data(sd_ipcc_chan_t *chan, u8 *dat, u32 len)
{
  14ac70:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14ac74:	4604      	mov	r4, r0
  14ac76:	4617      	mov	r7, r2
  14ac78:	4688      	mov	r8, r1
     * spend much to print, low speed uart may be timeout
     */
    timeout = 500;
#endif

    chan->tx_start = current_time_hires();
  14ac7a:	f7f5 fe63 	bl	140944 <current_time_hires>

    chan->tx_cnt++;
    chan->tx_bytes += len;

//    spin_lock_irqsave(&chan->tx_lock, flags);
    ret = hal_mb_send_data(chan->mb_chan, dat, len_short, timeout);
  14ac7e:	2364      	movs	r3, #100	; 0x64
  14ac80:	b2ba      	uxth	r2, r7
    chan->tx_cnt++;
  14ac82:	6b66      	ldr	r6, [r4, #52]	; 0x34
    chan->tx_bytes += len;
  14ac84:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
    chan->tx_cnt++;
  14ac86:	3601      	adds	r6, #1
    chan->tx_bytes += len;
  14ac88:	443d      	add	r5, r7
    chan->tx_cnt++;
  14ac8a:	6366      	str	r6, [r4, #52]	; 0x34
    chan->tx_bytes += len;
  14ac8c:	62e5      	str	r5, [r4, #44]	; 0x2c
    chan->tx_start = current_time_hires();
  14ac8e:	e9c4 0110 	strd	r0, r1, [r4, #64]	; 0x40
    ret = hal_mb_send_data(chan->mb_chan, dat, len_short, timeout);
  14ac92:	4641      	mov	r1, r8
  14ac94:	6a20      	ldr	r0, [r4, #32]
  14ac96:	f003 fa0d 	bl	14e0b4 <hal_mb_send_data>
//    spin_unlock_irqrestore(&chan->tx_lock, flags);

    if (ret != NO_ERROR) {
  14ac9a:	4605      	mov	r5, r0
  14ac9c:	b148      	cbz	r0, 14acb2 <sd_ipcc_chan_send_data+0x42>
        chan->err_cnt++;
  14ac9e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        if (ret == ERR_NOT_READY || ret == ERR_TIMED_OUT)
  14aca0:	f110 0f03 	cmn.w	r0, #3
  14aca4:	bf18      	it	ne
  14aca6:	f110 0f0d 	cmnne.w	r0, #13
        chan->err_cnt++;
  14acaa:	f103 0301 	add.w	r3, r3, #1
  14acae:	63a3      	str	r3, [r4, #56]	; 0x38
        if (ret == ERR_NOT_READY || ret == ERR_TIMED_OUT)
  14acb0:	d106      	bne.n	14acc0 <sd_ipcc_chan_send_data+0x50>
            dprintf(INFO, "Fail to send, rproc%d may offline\n", chan->rproc);
        else
            dprintf(0, "Fail to send to %d ret: %d\n", chan->rproc, ret);
    }
    chan->tx_end = current_time_hires();
  14acb2:	f7f5 fe47 	bl	140944 <current_time_hires>
  14acb6:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
    if (chan->tx_end > 500)
        dprintf(0, "%s: tx %d bytes, %d us\n", chan->ch_name, len, timeout);
#endif

    return ret;
}
  14acba:	4628      	mov	r0, r5
  14acbc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            dprintf(0, "Fail to send to %d ret: %d\n", chan->rproc, ret);
  14acc0:	f246 0090 	movw	r0, #24720	; 0x6090
  14acc4:	462a      	mov	r2, r5
  14acc6:	69a1      	ldr	r1, [r4, #24]
  14acc8:	f2c0 0015 	movt	r0, #21
  14accc:	f009 fa14 	bl	1540f8 <_printf>
  14acd0:	e7ef      	b.n	14acb2 <sd_ipcc_chan_send_data+0x42>
  14acd2:	bf00      	nop

0014acd4 <sd_ipcc_chan_send_data_nocopy>:

int sd_ipcc_chan_send_data_nocopy(sd_ipcc_chan_t *chan, u8 *dat, u32 len, u16 mb_buf_idx)
{
  14acd4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14acd8:	4604      	mov	r4, r0
  14acda:	4690      	mov	r8, r2
  14acdc:	461f      	mov	r7, r3
     * spend much to print, low speed uart may be timeout
     */
    timeout = 500;
#endif

    chan->tx_start = current_time_hires();
  14acde:	f7f5 fe31 	bl	140944 <current_time_hires>

    chan->tx_cnt++;
    chan->tx_bytes += len;

//    spin_lock_irqsave(&chan->tx_lock, flags);
    ret = hal_mb_send_data_nocopy(chan->mb_chan, mb_buf_idx, timeout);
  14ace2:	2264      	movs	r2, #100	; 0x64
    chan->tx_bytes += len;
  14ace4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
    chan->tx_cnt++;
  14ace6:	6b65      	ldr	r5, [r4, #52]	; 0x34
    chan->tx_bytes += len;
  14ace8:	4446      	add	r6, r8
    chan->tx_cnt++;
  14acea:	3501      	adds	r5, #1
    chan->tx_bytes += len;
  14acec:	62e6      	str	r6, [r4, #44]	; 0x2c
    chan->tx_cnt++;
  14acee:	6365      	str	r5, [r4, #52]	; 0x34
    chan->tx_start = current_time_hires();
  14acf0:	e9c4 0110 	strd	r0, r1, [r4, #64]	; 0x40
    ret = hal_mb_send_data_nocopy(chan->mb_chan, mb_buf_idx, timeout);
  14acf4:	4639      	mov	r1, r7
  14acf6:	6a20      	ldr	r0, [r4, #32]
  14acf8:	f003 f9ea 	bl	14e0d0 <hal_mb_send_data_nocopy>
//    spin_unlock_irqrestore(&chan->tx_lock, flags);

    if (ret != NO_ERROR) {
  14acfc:	4605      	mov	r5, r0
  14acfe:	b148      	cbz	r0, 14ad14 <sd_ipcc_chan_send_data_nocopy+0x40>
        chan->err_cnt++;
  14ad00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
        if (ret == ERR_NOT_READY || ret == ERR_TIMED_OUT)
  14ad02:	f110 0f03 	cmn.w	r0, #3
  14ad06:	bf18      	it	ne
  14ad08:	f110 0f0d 	cmnne.w	r0, #13
        chan->err_cnt++;
  14ad0c:	f103 0301 	add.w	r3, r3, #1
  14ad10:	63a3      	str	r3, [r4, #56]	; 0x38
        if (ret == ERR_NOT_READY || ret == ERR_TIMED_OUT)
  14ad12:	d106      	bne.n	14ad22 <sd_ipcc_chan_send_data_nocopy+0x4e>
            dprintf(INFO, "Fail to send, rproc%d may offline\n", chan->rproc);
        else
            dprintf(0, "Fail to send to %d ret: %d\n", chan->rproc, ret);
    }
    chan->tx_end = current_time_hires();
  14ad14:	f7f5 fe16 	bl	140944 <current_time_hires>
  14ad18:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48

    dprintf(1, "%s: tx %d bytes, %lld us\n", chan->ch_name, len, chan->tx_end - chan->tx_start);

    return ret;
}
  14ad1c:	4628      	mov	r0, r5
  14ad1e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            dprintf(0, "Fail to send to %d ret: %d\n", chan->rproc, ret);
  14ad22:	f246 0090 	movw	r0, #24720	; 0x6090
  14ad26:	462a      	mov	r2, r5
  14ad28:	69a1      	ldr	r1, [r4, #24]
  14ad2a:	f2c0 0015 	movt	r0, #21
  14ad2e:	f009 f9e3 	bl	1540f8 <_printf>
  14ad32:	e7ef      	b.n	14ad14 <sd_ipcc_chan_send_data_nocopy+0x40>

0014ad34 <sd_ipcc_chan_recv_data>:

void *sd_ipcc_chan_recv_data(sd_ipcc_chan_t *chan, u32 *len, u16 *idx)
{
    return NULL;
}
  14ad34:	2000      	movs	r0, #0
  14ad36:	4770      	bx	r14

0014ad38 <release_rx_buffer>:

    return payload;
}

static void release_rx_buffer(struct rpmsg_dcf_instance *rpmsg_dcf_dev, struct rpmsg_ipcc_msg *rpmsg_msg)
{
  14ad38:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14ad3a:	4605      	mov	r5, r0
    struct rpmsg_hdr_reserved *reserved = NULL;

    /* Get the pointer to the reserved field that contains buffer size and the index */
    reserved = (struct rpmsg_hdr_reserved *)&rpmsg_msg->hdr.reserved;

    mutex_acquire(&rpmsg_dcf_dev->lock);
  14ad3c:	f100 060c 	add.w	r6, r0, #12
{
  14ad40:	460c      	mov	r4, r1
status_t mutex_acquire_timeout(mutex_t *, lk_time_t); /* try to acquire the mutex with a timeout value */
status_t mutex_release(mutex_t *);

static inline status_t mutex_acquire(mutex_t *m)
{
    return mutex_acquire_timeout(m, INFINITE_TIME);
  14ad42:	4630      	mov	r0, r6
  14ad44:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14ad48:	f004 fa40 	bl	14f1cc <mutex_acquire_timeout>

    /* Return used buffer, with total length (header length + buffer size). */
    rpmsg_dcf_dev->chan_ops->recv_free(rpmsg_dcf_dev->tvq, rpmsg_msg,
  14ad4c:	6aef      	ldr	r7, [r5, #44]	; 0x2c
  14ad4e:	8963      	ldrh	r3, [r4, #10]
  14ad50:	6828      	ldr	r0, [r5, #0]
  14ad52:	89a2      	ldrh	r2, [r4, #12]
  14ad54:	4621      	mov	r1, r4
  14ad56:	693c      	ldr	r4, [r7, #16]
  14ad58:	47a0      	blx	r4
                                       (unsigned long)rpmsg_msg->hdr.len,
                                       reserved->idx);

    mutex_release(&rpmsg_dcf_dev->lock);
  14ad5a:	4630      	mov	r0, r6
}
  14ad5c:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    mutex_release(&rpmsg_dcf_dev->lock);
  14ad60:	f004 ba60 	b.w	14f224 <mutex_release>

0014ad64 <rpmsg_dcf_rx_callback>:
{
  14ad64:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct rpmsg_dcf_instance *rpmsg_dcf_dev = (struct rpmsg_dcf_instance *) vq->priv;
  14ad66:	f8d0 5088 	ldr.w	r5, [r0, #136]	; 0x88
{
  14ad6a:	b083      	sub	sp, #12
    ASSERT(rpmsg_dcf_dev != NULL);
  14ad6c:	2d00      	cmp	r5, #0
  14ad6e:	d03b      	beq.n	14ade8 <rpmsg_dcf_rx_callback+0x84>
  14ad70:	460c      	mov	r4, r1
    if (rpmsg_msg)
  14ad72:	2900      	cmp	r1, #0
  14ad74:	d036      	beq.n	14ade4 <rpmsg_dcf_rx_callback+0x80>
  14ad76:	4616      	mov	r6, r2
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ad78:	1d29      	adds	r1, r5, #4
  14ad7a:	68aa      	ldr	r2, [r5, #8]
        ept = rpmsg_dcf_get_endpoint_from_addr(rpmsg_dcf_dev, rpmsg_msg->hdr.dst);
  14ad7c:	6863      	ldr	r3, [r4, #4]
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ad7e:	4291      	cmp	r1, r2
  14ad80:	f1a2 0010 	sub.w	r0, r2, #16
  14ad84:	d00d      	beq.n	14ada2 <rpmsg_dcf_rx_callback+0x3e>
        if (rl_ept->addr == addr)
  14ad86:	f852 2c10 	ldr.w	r2, [r2, #-16]
  14ad8a:	429a      	cmp	r2, r3
  14ad8c:	d104      	bne.n	14ad98 <rpmsg_dcf_rx_callback+0x34>
  14ad8e:	e01e      	b.n	14adce <rpmsg_dcf_rx_callback+0x6a>
  14ad90:	f852 2c10 	ldr.w	r2, [r2, #-16]
  14ad94:	4293      	cmp	r3, r2
  14ad96:	d01a      	beq.n	14adce <rpmsg_dcf_rx_callback+0x6a>
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ad98:	6942      	ldr	r2, [r0, #20]
  14ad9a:	4291      	cmp	r1, r2
  14ad9c:	f1a2 0010 	sub.w	r0, r2, #16
  14ada0:	d1f6      	bne.n	14ad90 <rpmsg_dcf_rx_callback+0x2c>
            dprintf(0, "%s: %d->%d endpoint not found\n", __func__, rpmsg_msg->hdr.src, rpmsg_msg->hdr.dst);
  14ada2:	f246 01ac 	movw	r1, #24748	; 0x60ac
  14ada6:	f246 1030 	movw	r0, #24880	; 0x6130
  14adaa:	f2c0 0115 	movt	r1, #21
  14adae:	6822      	ldr	r2, [r4, #0]
  14adb0:	f2c0 0015 	movt	r0, #21
  14adb4:	f009 f9a0 	bl	1540f8 <_printf>
            rpmsg_dcf_dev->chan_ops->recv_free(rpmsg_dcf_dev->tvq, rpmsg_msg, len, 0);
  14adb8:	6aef      	ldr	r7, [r5, #44]	; 0x2c
  14adba:	4621      	mov	r1, r4
  14adbc:	4632      	mov	r2, r6
  14adbe:	2300      	movs	r3, #0
  14adc0:	6828      	ldr	r0, [r5, #0]
  14adc2:	693c      	ldr	r4, [r7, #16]
  14adc4:	46a4      	mov	r12, r4
}
  14adc6:	b003      	add	sp, #12
  14adc8:	e8bd 40f0 	ldmia.w	r13!, {r4, r5, r6, r7, r14}
            rpmsg_dcf_dev->chan_ops->recv_free(rpmsg_dcf_dev->tvq, rpmsg_msg, len, 0);
  14adcc:	4760      	bx	r12
            cb_ret = ept->rx_cb(rpmsg_msg->data, rpmsg_msg->hdr.len, rpmsg_msg->hdr.src, ept->rx_cb_data);
  14adce:	6847      	ldr	r7, [r0, #4]
  14add0:	89a1      	ldrh	r1, [r4, #12]
  14add2:	6883      	ldr	r3, [r0, #8]
  14add4:	f104 0010 	add.w	r0, r4, #16
  14add8:	6822      	ldr	r2, [r4, #0]
  14adda:	47b8      	blx	r7
        if (cb_ret == DCF_HOLD)
  14addc:	2801      	cmp	r0, #1
  14adde:	d1eb      	bne.n	14adb8 <rpmsg_dcf_rx_callback+0x54>
            rsvd->idx = 0;
  14ade0:	2300      	movs	r3, #0
  14ade2:	8163      	strh	r3, [r4, #10]
}
  14ade4:	b003      	add	sp, #12
  14ade6:	bdf0      	pop	{r4, r5, r6, r7, r15}
    ASSERT(rpmsg_dcf_dev != NULL);
  14ade8:	f246 1318 	movw	r3, #24856	; 0x6118
  14adec:	f246 02e4 	movw	r2, #24804	; 0x60e4
  14adf0:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14adf4:	f2c0 0315 	movt	r3, #21
  14adf8:	4670      	mov	r0, r14
  14adfa:	f2c0 0215 	movt	r2, #21
  14adfe:	9300      	str	r3, [sp, #0]
  14ae00:	f2c0 0115 	movt	r1, #21
  14ae04:	2398      	movs	r3, #152	; 0x98
  14ae06:	f007 ff55 	bl	152cb4 <_panic>
  14ae0a:	bf00      	nop

0014ae0c <recv_free_buffer>:

void *sd_ipcc_chan_recv_data(sd_ipcc_chan_t *chan, u32 *len, u16 *idx);

inline static int sd_ipcc_chan_free_buffer(sd_ipcc_chan_t *chan, void *buffer)
{
    return sd_rpbuf_free_ptr(chan->buf_pool, buffer);
  14ae0c:	6f40      	ldr	r0, [r0, #116]	; 0x74
  14ae0e:	f001 b8cf 	b.w	14bfb0 <sd_rpbuf_free_ptr>
  14ae12:	bf00      	nop

0014ae14 <ipcc_rx_data>:
    return sd_ipcc_chan_recv_data(chan, len, idx);
  14ae14:	f7ff bf8e 	b.w	14ad34 <sd_ipcc_chan_recv_data>

0014ae18 <send_alloc_buffer>:
    return sd_ipcc_alloc_send_buffer(chan, len, idx);
  14ae18:	f7ff bee0 	b.w	14abdc <sd_ipcc_alloc_send_buffer>

0014ae1c <ipcc_send_data_nocopy>:
    status = sd_ipcc_chan_send_data_nocopy(tvq, buffer, len, idx);
  14ae1c:	f7ff bf5a 	b.w	14acd4 <sd_ipcc_chan_send_data_nocopy>

0014ae20 <ipcc_send_data>:
{
  14ae20:	b570      	push	{r4, r5, r6, r14}
  14ae22:	461c      	mov	r4, r3
  14ae24:	4606      	mov	r6, r0
    status = sd_ipcc_chan_send_data(tvq, buffer, len);
  14ae26:	f7ff ff23 	bl	14ac70 <sd_ipcc_chan_send_data>
    if (idx != (uint16_t)-1)
  14ae2a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  14ae2e:	429c      	cmp	r4, r3
    status = sd_ipcc_chan_send_data(tvq, buffer, len);
  14ae30:	4605      	mov	r5, r0
    if (idx != (uint16_t)-1)
  14ae32:	d003      	beq.n	14ae3c <ipcc_send_data+0x1c>
}

inline static int sd_ipcc_chan_free_buffer_id(sd_ipcc_chan_t *chan, unsigned int buf_id)
{
    return sd_rpbuf_free_id(chan->buf_pool, buf_id);
  14ae34:	6f70      	ldr	r0, [r6, #116]	; 0x74
  14ae36:	4621      	mov	r1, r4
  14ae38:	f001 f900 	bl	14c03c <sd_rpbuf_free_id>
}
  14ae3c:	4628      	mov	r0, r5
  14ae3e:	bd70      	pop	{r4, r5, r6, r15}

0014ae40 <rpmsg_dcf_create_ept>:
{
  14ae40:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    if (!rpmsg_dcf_dev)
  14ae44:	4681      	mov	r9, r0
  14ae46:	2800      	cmp	r0, #0
  14ae48:	d05a      	beq.n	14af00 <rpmsg_dcf_create_ept+0xc0>
  14ae4a:	460c      	mov	r4, r1
    mutex_acquire(&rpmsg_dcf_dev->lock);
  14ae4c:	f100 060c 	add.w	r6, r0, #12
  14ae50:	4630      	mov	r0, r6
  14ae52:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14ae56:	4690      	mov	r8, r2
  14ae58:	461f      	mov	r7, r3
  14ae5a:	f004 f9b7 	bl	14f1cc <mutex_acquire_timeout>
        if (addr == DCF_ADDR_ANY)
  14ae5e:	1c62      	adds	r2, r4, #1
  14ae60:	f109 0504 	add.w	r5, r9, #4
  14ae64:	d017      	beq.n	14ae96 <rpmsg_dcf_create_ept+0x56>
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ae66:	f8d9 3008 	ldr.w	r3, [r9, #8]
  14ae6a:	429d      	cmp	r5, r3
  14ae6c:	f1a3 0210 	sub.w	r2, r3, #16
  14ae70:	d105      	bne.n	14ae7e <rpmsg_dcf_create_ept+0x3e>
  14ae72:	e025      	b.n	14aec0 <rpmsg_dcf_create_ept+0x80>
  14ae74:	6953      	ldr	r3, [r2, #20]
  14ae76:	429d      	cmp	r5, r3
  14ae78:	f1a3 0210 	sub.w	r2, r3, #16
  14ae7c:	d020      	beq.n	14aec0 <rpmsg_dcf_create_ept+0x80>
        if (rl_ept->addr == addr)
  14ae7e:	f853 3c10 	ldr.w	r3, [r3, #-16]
  14ae82:	429c      	cmp	r4, r3
  14ae84:	d1f6      	bne.n	14ae74 <rpmsg_dcf_create_ept+0x34>
                mutex_release(&rpmsg_dcf_dev->lock);
  14ae86:	4630      	mov	r0, r6
                return NULL;
  14ae88:	f04f 0a00 	mov.w	r10, #0
                mutex_release(&rpmsg_dcf_dev->lock);
  14ae8c:	f004 f9ca 	bl	14f224 <mutex_release>
}
  14ae90:	4650      	mov	r0, r10
  14ae92:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ae96:	f8d9 0008 	ldr.w	r0, [r9, #8]
            for (i = 1; i < 0xFFFFFFFF; i++)
  14ae9a:	2401      	movs	r4, #1
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14ae9c:	f1a0 0110 	sub.w	r1, r0, #16
  14aea0:	42a8      	cmp	r0, r5
  14aea2:	d00d      	beq.n	14aec0 <rpmsg_dcf_create_ept+0x80>
        if (rl_ept->addr == addr)
  14aea4:	680b      	ldr	r3, [r1, #0]
  14aea6:	42a3      	cmp	r3, r4
  14aea8:	d026      	beq.n	14aef8 <rpmsg_dcf_create_ept+0xb8>
  14aeaa:	460a      	mov	r2, r1
  14aeac:	e003      	b.n	14aeb6 <rpmsg_dcf_create_ept+0x76>
  14aeae:	f853 3c10 	ldr.w	r3, [r3, #-16]
  14aeb2:	42a3      	cmp	r3, r4
  14aeb4:	d020      	beq.n	14aef8 <rpmsg_dcf_create_ept+0xb8>
    list_for_every_entry(&rpmsg_dcf_dev->endpoints, rl_ept,
  14aeb6:	6953      	ldr	r3, [r2, #20]
  14aeb8:	429d      	cmp	r5, r3
  14aeba:	f1a3 0210 	sub.w	r2, r3, #16
  14aebe:	d1f6      	bne.n	14aeae <rpmsg_dcf_create_ept+0x6e>
        rl_ept = malloc(sizeof(struct rpmsg_dcf_endpoint));
  14aec0:	2018      	movs	r0, #24
  14aec2:	f007 ffe5 	bl	152e90 <malloc>
        if (!rl_ept)
  14aec6:	4682      	mov	r10, r0
  14aec8:	b1e0      	cbz	r0, 14af04 <rpmsg_dcf_create_ept+0xc4>
        memset(rl_ept, 0x00, sizeof(struct rpmsg_dcf_endpoint));
  14aeca:	2100      	movs	r1, #0
        list_add_tail(&rpmsg_dcf_dev->endpoints, &rl_ept->node);
  14aecc:	f100 0310 	add.w	r3, r0, #16

#define list_add_after(entry, new_entry) list_add_head(entry, new_entry)

static inline void list_add_tail(struct list_node *list, struct list_node *item)
{
    item->prev = list->prev;
  14aed0:	f8d9 2004 	ldr.w	r2, [r9, #4]
        rl_ept->addr = addr;
  14aed4:	6004      	str	r4, [r0, #0]
    mutex_release(&rpmsg_dcf_dev->lock);
  14aed6:	4630      	mov	r0, r6
        rl_ept->rx_cb = rx_cb;
  14aed8:	f8ca 8004 	str.w	r8, [r10, #4]
        rl_ept->rx_cb_data = rx_cb_data;
  14aedc:	f8ca 7008 	str.w	r7, [r10, #8]
    item->next = list;
  14aee0:	f8ca 5014 	str.w	r5, [r10, #20]
    item->prev = list->prev;
  14aee4:	e9ca 1203 	strd	r1, r2, [r10, #12]
    list->prev->next = item;
  14aee8:	6053      	str	r3, [r2, #4]
    list->prev = item;
  14aeea:	f8c9 3004 	str.w	r3, [r9, #4]
    mutex_release(&rpmsg_dcf_dev->lock);
  14aeee:	f004 f999 	bl	14f224 <mutex_release>
}
  14aef2:	4650      	mov	r0, r10
  14aef4:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            for (i = 1; i < 0xFFFFFFFF; i++)
  14aef8:	3401      	adds	r4, #1
  14aefa:	1c63      	adds	r3, r4, #1
  14aefc:	d1d0      	bne.n	14aea0 <rpmsg_dcf_create_ept+0x60>
  14aefe:	e7c2      	b.n	14ae86 <rpmsg_dcf_create_ept+0x46>
        return NULL;
  14af00:	4682      	mov	r10, r0
  14af02:	e7f6      	b.n	14aef2 <rpmsg_dcf_create_ept+0xb2>
            mutex_release(&rpmsg_dcf_dev->lock);
  14af04:	4630      	mov	r0, r6
  14af06:	f004 f98d 	bl	14f224 <mutex_release>
            return NULL;
  14af0a:	e7f2      	b.n	14aef2 <rpmsg_dcf_create_ept+0xb2>

0014af0c <rpmsg_dcf_destroy_ept>:
{
  14af0c:	b570      	push	{r4, r5, r6, r14}
    if (!rl_ept)
  14af0e:	fab1 f481 	clz	r4, r1
  14af12:	0964      	lsrs	r4, r4, #5
  14af14:	2800      	cmp	r0, #0
  14af16:	bf08      	it	eq
  14af18:	2401      	moveq	r4, #1
  14af1a:	b9b4      	cbnz	r4, 14af4a <rpmsg_dcf_destroy_ept+0x3e>
  14af1c:	460d      	mov	r5, r1
    mutex_acquire(&rpmsg_dcf_dev->lock);
  14af1e:	f100 060c 	add.w	r6, r0, #12
  14af22:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14af26:	4630      	mov	r0, r6
  14af28:	f004 f950 	bl	14f1cc <mutex_acquire_timeout>
    mutex_release(&rpmsg_dcf_dev->lock);
  14af2c:	4630      	mov	r0, r6

#define list_add_before(entry, new_entry) list_add_tail(entry, new_entry)

static inline void list_delete(struct list_node *item)
{
    item->next->prev = item->prev;
  14af2e:	e9d5 2304 	ldrd	r2, r3, [r5, #16]
  14af32:	601a      	str	r2, [r3, #0]
    item->prev->next = item->next;
  14af34:	692a      	ldr	r2, [r5, #16]
  14af36:	6053      	str	r3, [r2, #4]
    item->prev = item->next = 0;
  14af38:	e9c5 4404 	strd	r4, r4, [r5, #16]
  14af3c:	f004 f972 	bl	14f224 <mutex_release>
    free(rl_ept);
  14af40:	4628      	mov	r0, r5
  14af42:	f007 ffdb 	bl	152efc <free>
    return NO_ERROR;
  14af46:	4620      	mov	r0, r4
}
  14af48:	bd70      	pop	{r4, r5, r6, r15}
        return DCF_ERR_PARAM;
  14af4a:	f64e 4075 	movw	r0, #60533	; 0xec75
  14af4e:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14af52:	bd70      	pop	{r4, r5, r6, r15}

0014af54 <rpmsg_dcf_format_message>:
{
  14af54:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14af58:	b083      	sub	sp, #12
    if (!data)
  14af5a:	2800      	cmp	r0, #0
  14af5c:	bf18      	it	ne
  14af5e:	2b00      	cmpne	r3, #0
    uint32_t buff_len = size + sizeof(struct rpmsg_msg_hdr);
  14af60:	9c0c      	ldr	r4, [sp, #48]	; 0x30
{
  14af62:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    uint32_t buff_len = size + sizeof(struct rpmsg_msg_hdr);
  14af64:	f104 0410 	add.w	r4, r4, #16
  14af68:	9401      	str	r4, [sp, #4]
    if (!data)
  14af6a:	d067      	beq.n	14b03c <rpmsg_dcf_format_message+0xe8>
    if (!rpmsg_dcf_dev->link_state)
  14af6c:	6a84      	ldr	r4, [r0, #40]	; 0x28
  14af6e:	2c00      	cmp	r4, #0
  14af70:	d05f      	beq.n	14b032 <rpmsg_dcf_format_message+0xde>
  14af72:	4604      	mov	r4, r0
    mutex_acquire(&rpmsg_dcf_dev->lock);
  14af74:	f100 050c 	add.w	r5, r0, #12
  14af78:	4689      	mov	r9, r1
  14af7a:	4628      	mov	r0, r5
  14af7c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14af80:	4698      	mov	r8, r3
  14af82:	4692      	mov	r10, r2
  14af84:	f004 f922 	bl	14f1cc <mutex_acquire_timeout>
    buffer = rpmsg_dcf_dev->chan_ops->send_alloc(rpmsg_dcf_dev->tvq, &buff_len, &idx);
  14af88:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  14af8a:	f10d 0202 	add.w	r2, r13, #2
  14af8e:	6820      	ldr	r0, [r4, #0]
  14af90:	a901      	add	r1, sp, #4
  14af92:	689b      	ldr	r3, [r3, #8]
  14af94:	4798      	blx	r3
  14af96:	4606      	mov	r6, r0
    mutex_release(&rpmsg_dcf_dev->lock);
  14af98:	4628      	mov	r0, r5
  14af9a:	f004 f943 	bl	14f224 <mutex_release>
    if (!buffer && !timeout)
  14af9e:	2e00      	cmp	r6, #0
  14afa0:	bf08      	it	eq
  14afa2:	2f00      	cmpeq	r7, #0
  14afa4:	d01b      	beq.n	14afde <rpmsg_dcf_format_message+0x8a>
    while (!buffer)
  14afa6:	bb16      	cbnz	r6, 14afee <rpmsg_dcf_format_message+0x9a>
    unsigned long tick_count = 0;
  14afa8:	46b3      	mov	r11, r6
  14afaa:	e000      	b.n	14afae <rpmsg_dcf_format_message+0x5a>
    while (!buffer)
  14afac:	b9fe      	cbnz	r6, 14afee <rpmsg_dcf_format_message+0x9a>
        thread_sleep(DCF_MS_PER_INTERVAL);
  14afae:	2001      	movs	r0, #1
        tick_count += DCF_MS_PER_INTERVAL;
  14afb0:	4483      	add	r11, r0
        thread_sleep(DCF_MS_PER_INTERVAL);
  14afb2:	f004 fc3d 	bl	14f830 <thread_sleep>
  14afb6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14afba:	4628      	mov	r0, r5
  14afbc:	f004 f906 	bl	14f1cc <mutex_acquire_timeout>
        buffer = rpmsg_dcf_dev->chan_ops->send_alloc(rpmsg_dcf_dev->tvq, &buff_len, &idx);
  14afc0:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  14afc2:	f10d 0202 	add.w	r2, r13, #2
  14afc6:	6820      	ldr	r0, [r4, #0]
  14afc8:	a901      	add	r1, sp, #4
  14afca:	68b6      	ldr	r6, [r6, #8]
  14afcc:	47b0      	blx	r6
  14afce:	4606      	mov	r6, r0
        mutex_release(&rpmsg_dcf_dev->lock);
  14afd0:	4628      	mov	r0, r5
  14afd2:	f004 f927 	bl	14f224 <mutex_release>
        if ((tick_count >= timeout) && (!buffer))
  14afd6:	455f      	cmp	r7, r11
  14afd8:	bf98      	it	ls
  14afda:	2e00      	cmpls	r6, #0
  14afdc:	d1e6      	bne.n	14afac <rpmsg_dcf_format_message+0x58>
        return DCF_ERR_NO_MEM;
  14afde:	f64e 4477 	movw	r4, #60535	; 0xec77
  14afe2:	f6cf 74ff 	movt	r4, #65535	; 0xffff
}
  14afe6:	4620      	mov	r0, r4
  14afe8:	b003      	add	sp, #12
  14afea:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    memcpy(rpmsg_msg->data, data, size);
  14afee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  14aff0:	4641      	mov	r1, r8
    rpmsg_msg->hdr.flags = flags;
  14aff2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    memcpy(rpmsg_msg->data, data, size);
  14aff4:	f106 0010 	add.w	r0, r6, #16
    rpmsg_msg->hdr.len = size;
  14aff8:	81b2      	strh	r2, [r6, #12]
    rpmsg_msg->hdr.flags = flags;
  14affa:	81f3      	strh	r3, [r6, #14]
    rpmsg_msg->hdr.dst = dst;
  14affc:	f8c6 a004 	str.w	r10, [r6, #4]
    rpmsg_msg->hdr.src = src;
  14b000:	f8c6 9000 	str.w	r9, [r6]
    memcpy(rpmsg_msg->data, data, size);
  14b004:	f007 efb4 	blx	152f70 <memcpy>
  14b008:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14b00c:	4628      	mov	r0, r5
  14b00e:	f004 f8dd 	bl	14f1cc <mutex_acquire_timeout>
    status = rpmsg_dcf_dev->chan_ops->send_data(rpmsg_dcf_dev->tvq, buffer, buff_len, idx);
  14b012:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  14b014:	f8bd 3002 	ldrh.w	r3, [r13, #2]
  14b018:	6820      	ldr	r0, [r4, #0]
  14b01a:	4631      	mov	r1, r6
  14b01c:	6814      	ldr	r4, [r2, #0]
  14b01e:	9a01      	ldr	r2, [sp, #4]
  14b020:	47a0      	blx	r4
  14b022:	4604      	mov	r4, r0
    mutex_release(&rpmsg_dcf_dev->lock);
  14b024:	4628      	mov	r0, r5
  14b026:	f004 f8fd 	bl	14f224 <mutex_release>
}
  14b02a:	4620      	mov	r0, r4
  14b02c:	b003      	add	sp, #12
  14b02e:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return DCF_NOT_READY;
  14b032:	f64e 4471 	movw	r4, #60529	; 0xec71
  14b036:	f6cf 74ff 	movt	r4, #65535	; 0xffff
  14b03a:	e7d4      	b.n	14afe6 <rpmsg_dcf_format_message+0x92>
        return DCF_ERR_PARAM;
  14b03c:	f64e 4475 	movw	r4, #60533	; 0xec75
  14b040:	f6cf 74ff 	movt	r4, #65535	; 0xffff
  14b044:	e7cf      	b.n	14afe6 <rpmsg_dcf_format_message+0x92>
  14b046:	bf00      	nop

0014b048 <rpmsg_dcf_send>:
{
  14b048:	b570      	push	{r4, r5, r6, r14}
  14b04a:	b084      	sub	sp, #16
  14b04c:	9c08      	ldr	r4, [sp, #32]
    if (!ept)
  14b04e:	b181      	cbz	r1, 14b072 <rpmsg_dcf_send+0x2a>
    if (size > DCF_BUFFER_PAYLOAD_SIZE)
  14b050:	f5b4 7ff6 	cmp.w	r4, #492	; 0x1ec
  14b054:	d808      	bhi.n	14b068 <rpmsg_dcf_send+0x20>
    return rpmsg_dcf_format_message(rpmsg_dcf_dev, ept->addr, dst, data, size, DCF_NO_FLAGS, timeout);
  14b056:	9e09      	ldr	r6, [sp, #36]	; 0x24
  14b058:	2500      	movs	r5, #0
  14b05a:	6809      	ldr	r1, [r1, #0]
  14b05c:	e88d 0070 	stmia.w	r13, {r4, r5, r6}
  14b060:	f7ff ff78 	bl	14af54 <rpmsg_dcf_format_message>
}
  14b064:	b004      	add	sp, #16
  14b066:	bd70      	pop	{r4, r5, r6, r15}
        return DCF_ERR_BUFF_SIZE;
  14b068:	f64e 4076 	movw	r0, #60534	; 0xec76
  14b06c:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14b070:	e7f8      	b.n	14b064 <rpmsg_dcf_send+0x1c>
        return DCF_ERR_PARAM;
  14b072:	f64e 4075 	movw	r0, #60533	; 0xec75
  14b076:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14b07a:	e7f3      	b.n	14b064 <rpmsg_dcf_send+0x1c>

0014b07c <rpmsg_dcf_get_rpbuf>:
    if (!rxbuf)
  14b07c:	2900      	cmp	r1, #0
  14b07e:	bf18      	it	ne
  14b080:	2800      	cmpne	r0, #0
  14b082:	d004      	beq.n	14b08e <rpmsg_dcf_get_rpbuf+0x12>
    return sd_ipcc_find_rpbuf(rpmsg_dcf_dev->tvq, rpmsg_msg);
  14b084:	6803      	ldr	r3, [r0, #0]
}

inline static sd_rpbuf_t *sd_ipcc_find_rpbuf(sd_ipcc_chan_t *chan, void *buffer)
{
    return sd_rpbuf_find_handle(chan->buf_pool, buffer);
  14b086:	3910      	subs	r1, #16
  14b088:	6f58      	ldr	r0, [r3, #116]	; 0x74
  14b08a:	f001 b80b 	b.w	14c0a4 <sd_rpbuf_find_handle>
}
  14b08e:	2000      	movs	r0, #0
  14b090:	4770      	bx	r14
  14b092:	bf00      	nop

0014b094 <rpmsg_dcf_import_buffer>:
    if (rpbuf) {
  14b094:	b181      	cbz	r1, 14b0b8 <rpmsg_dcf_import_buffer+0x24>
        rpmsg_msg = (struct rpmsg_ipcc_msg *) rpbuf->buffer;
  14b096:	6889      	ldr	r1, [r1, #8]
        payload = rpbuf->buffer + offsetof(struct rpmsg_ipcc_msg, data);
  14b098:	f101 0010 	add.w	r0, r1, #16
        if (src != NULL) {
  14b09c:	b142      	cbz	r2, 14b0b0 <rpmsg_dcf_import_buffer+0x1c>
{
  14b09e:	b410      	push	{r4}
            *src = rpmsg_msg->hdr.src;
  14b0a0:	680c      	ldr	r4, [r1, #0]
  14b0a2:	6014      	str	r4, [r2, #0]
        if (len != NULL) {
  14b0a4:	b10b      	cbz	r3, 14b0aa <rpmsg_dcf_import_buffer+0x16>
            *len = rpmsg_msg->hdr.len;
  14b0a6:	898a      	ldrh	r2, [r1, #12]
  14b0a8:	601a      	str	r2, [r3, #0]
}
  14b0aa:	f85d 4b04 	ldr.w	r4, [r13], #4
  14b0ae:	4770      	bx	r14
        if (len != NULL) {
  14b0b0:	b10b      	cbz	r3, 14b0b6 <rpmsg_dcf_import_buffer+0x22>
            *len = rpmsg_msg->hdr.len;
  14b0b2:	898a      	ldrh	r2, [r1, #12]
  14b0b4:	601a      	str	r2, [r3, #0]
}
  14b0b6:	4770      	bx	r14
    void *payload = NULL;
  14b0b8:	4608      	mov	r0, r1
    return payload;
  14b0ba:	4770      	bx	r14

0014b0bc <rpmsg_dcf_copy_payload>:

int rpmsg_dcf_copy_payload(struct rpmsg_dcf_instance *rpmsg_dcf_dev, sd_rpbuf_t *rpbuf, unsigned long *src, char *data, int *len)
{
  14b0bc:	b570      	push	{r4, r5, r6, r14}
  14b0be:	9d04      	ldr	r5, [sp, #16]
    struct rpmsg_ipcc_msg *rpmsg_msg;
    int ret = 0;

    if (!data || !len) {
  14b0c0:	2d00      	cmp	r5, #0
  14b0c2:	bf18      	it	ne
  14b0c4:	2b00      	cmpne	r3, #0
  14b0c6:	d01c      	beq.n	14b102 <rpmsg_dcf_copy_payload+0x46>
        return DCF_ERR_PARAM;
    }

    if (rpbuf) {
  14b0c8:	b301      	cbz	r1, 14b10c <rpmsg_dcf_copy_payload+0x50>
        rpmsg_msg = (struct rpmsg_ipcc_msg *) rpbuf->buffer;
  14b0ca:	688c      	ldr	r4, [r1, #8]
  14b0cc:	4606      	mov	r6, r0

        if (*len >= rpmsg_msg->hdr.len) {
  14b0ce:	6828      	ldr	r0, [r5, #0]
  14b0d0:	89a1      	ldrh	r1, [r4, #12]
  14b0d2:	4288      	cmp	r0, r1
            }

            *len = rpmsg_msg->hdr.len;
            memcpy(data, get_payload(rpbuf), *len);
        } else {
            ret = DCF_ERR_BUFF_SIZE;
  14b0d4:	bfbc      	itt	lt
  14b0d6:	f64e 4576 	movwlt	r5, #60534	; 0xec76
  14b0da:	f6cf 75ff 	movtlt	r5, #65535	; 0xffff
        if (*len >= rpmsg_msg->hdr.len) {
  14b0de:	db0a      	blt.n	14b0f6 <rpmsg_dcf_copy_payload+0x3a>
            if (src != NULL) {
  14b0e0:	b10a      	cbz	r2, 14b0e6 <rpmsg_dcf_copy_payload+0x2a>
                *src = rpmsg_msg->hdr.src;
  14b0e2:	6820      	ldr	r0, [r4, #0]
  14b0e4:	6010      	str	r0, [r2, #0]
            *len = rpmsg_msg->hdr.len;
  14b0e6:	6029      	str	r1, [r5, #0]
            memcpy(data, get_payload(rpbuf), *len);
  14b0e8:	460a      	mov	r2, r1
  14b0ea:	4618      	mov	r0, r3
  14b0ec:	f104 0110 	add.w	r1, r4, #16
  14b0f0:	f007 ef3e 	blx	152f70 <memcpy>
    int ret = 0;
  14b0f4:	2500      	movs	r5, #0
        }

        /* Return used buffers. */
        release_rx_buffer(rpmsg_dcf_dev, rpmsg_msg);
  14b0f6:	4621      	mov	r1, r4
  14b0f8:	4630      	mov	r0, r6
  14b0fa:	f7ff fe1d 	bl	14ad38 <release_rx_buffer>

        return ret;
    }

    return DCF_ERR_NO_BUFF;
}
  14b0fe:	4628      	mov	r0, r5
  14b100:	bd70      	pop	{r4, r5, r6, r15}
        return DCF_ERR_PARAM;
  14b102:	f64e 4575 	movw	r5, #60533	; 0xec75
  14b106:	f6cf 75ff 	movt	r5, #65535	; 0xffff
  14b10a:	e7f8      	b.n	14b0fe <rpmsg_dcf_copy_payload+0x42>
    return DCF_ERR_NO_BUFF;
  14b10c:	f64e 4572 	movw	r5, #60530	; 0xec72
  14b110:	f6cf 75ff 	movt	r5, #65535	; 0xffff
  14b114:	e7f3      	b.n	14b0fe <rpmsg_dcf_copy_payload+0x42>
  14b116:	bf00      	nop

0014b118 <rpmsg_dcf_release_rpbuf>:
{
    if (!rpmsg_dcf_dev)
    {
        return DCF_ERR_PARAM;
    }
    if (!rpbuf)
  14b118:	fab1 f381 	clz	r3, r1
{
  14b11c:	b510      	push	{r4, r14}
    if (!rpbuf)
  14b11e:	095b      	lsrs	r3, r3, #5
  14b120:	2800      	cmp	r0, #0
  14b122:	bf14      	ite	ne
  14b124:	461c      	movne	r4, r3
  14b126:	2401      	moveq	r4, #1
  14b128:	b924      	cbnz	r4, 14b134 <rpmsg_dcf_release_rpbuf+0x1c>
    {
        return DCF_ERR_PARAM;
    }

    release_rx_buffer(rpmsg_dcf_dev, (struct rpmsg_ipcc_msg *) rpbuf->buffer);
  14b12a:	6889      	ldr	r1, [r1, #8]
  14b12c:	f7ff fe04 	bl	14ad38 <release_rx_buffer>

    return NO_ERROR;
  14b130:	4620      	mov	r0, r4
}
  14b132:	bd10      	pop	{r4, r15}
        return DCF_ERR_PARAM;
  14b134:	f64e 4075 	movw	r0, #60533	; 0xec75
  14b138:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14b13c:	bd10      	pop	{r4, r15}
  14b13e:	bf00      	nop

0014b140 <rpmsg_dcf_device_init>:
 mm#mm  #   ## mm#mm    #

 *****************************/
struct rpmsg_dcf_instance *rpmsg_dcf_device_init(int link_id,
                                                   uint32_t init_flags)
{
  14b140:	b5f0      	push	{r4, r5, r6, r7, r14}
  14b142:	4605      	mov	r5, r0
  14b144:	b085      	sub	sp, #20
    const char *vq_names;
    sd_ipcc_chan_t *chan;
    struct rpmsg_dcf_instance *rpmsg_dcf_dev = NULL;

    rpmsg_dcf_dev = malloc(sizeof(struct rpmsg_dcf_instance));
  14b146:	2030      	movs	r0, #48	; 0x30
{
  14b148:	460e      	mov	r6, r1
    rpmsg_dcf_dev = malloc(sizeof(struct rpmsg_dcf_instance));
  14b14a:	f007 fea1 	bl	152e90 <malloc>
    if (!rpmsg_dcf_dev)
  14b14e:	4604      	mov	r4, r0
  14b150:	b350      	cbz	r0, 14b1a8 <rpmsg_dcf_device_init+0x68>
    {
        return NULL;
    }

    memset(rpmsg_dcf_dev, 0, sizeof(struct rpmsg_dcf_instance));
  14b152:	222c      	movs	r2, #44	; 0x2c
  14b154:	2100      	movs	r1, #0
  14b156:	f007 ef92 	blx	15307c <memset>

    /* Initialize names and callbacks*/
    vq_names = "rpmsg-ipcc";
    rpmsg_dcf_dev->chan_ops = &master_chan_ops;
  14b15a:	f246 01c4 	movw	r1, #24772	; 0x60c4
    return sd_ipcc_chan_create_mq(remote, name, IPCC_ADDR_DCF_BASE, flags,
  14b15e:	f64a 5265 	movw	r2, #44389	; 0xad65
    rpmsg_dcf_dev->chan_ops = &master_chan_ops;
  14b162:	f2c0 0115 	movt	r1, #21
    return sd_ipcc_chan_create_mq(remote, name, IPCC_ADDR_DCF_BASE, flags,
  14b166:	f44f 7cf6 	mov.w	r12, #492	; 0x1ec
  14b16a:	f2c0 0214 	movt	r2, #20
  14b16e:	2704      	movs	r7, #4
  14b170:	4628      	mov	r0, r5
    rpmsg_dcf_dev->chan_ops = &master_chan_ops;
  14b172:	62e1      	str	r1, [r4, #44]	; 0x2c
    return sd_ipcc_chan_create_mq(remote, name, IPCC_ADDR_DCF_BASE, flags,
  14b174:	f246 01d8 	movw	r1, #24792	; 0x60d8
  14b178:	9200      	str	r2, [sp, #0]
  14b17a:	4633      	mov	r3, r6
  14b17c:	f8cd c008 	str.w	r12, [r13, #8]
  14b180:	f2c0 0115 	movt	r1, #21
  14b184:	9701      	str	r7, [sp, #4]
  14b186:	2230      	movs	r2, #48	; 0x30
  14b188:	f7ff fd4e 	bl	14ac28 <sd_ipcc_chan_create_mq>

    /* Create one sd_ipcc_chan for TX/RX */
    {
        chan = alloc_notifier(link_id, (char *)vq_names,
                    init_flags, rpmsg_dcf_rx_callback);
        if (chan)
  14b18c:	4605      	mov	r5, r0
  14b18e:	b170      	cbz	r0, 14b1ae <rpmsg_dcf_device_init+0x6e>
            free(rpmsg_dcf_dev);
            return NULL;
        }

        /* sd_ipcc_chan has reference to the RPMsg Lite instance */
       chan->priv = (void *)rpmsg_dcf_dev;
  14b190:	f8c0 4088 	str.w	r4, [r0, #136]	; 0x88
    }

    mutex_init(&rpmsg_dcf_dev->lock);
  14b194:	f104 000c 	add.w	r0, r4, #12
  14b198:	f003 ffde 	bl	14f158 <mutex_init>

    // FIXME - a better way to handle this , tx for master is rx for remote and vice versa.
    rpmsg_dcf_dev->tvq = chan;

    /* Install ISRs */
    rpmsg_dcf_dev->link_state = 1;
  14b19c:	2201      	movs	r2, #1
    rpmsg_dcf_dev->tvq = chan;
  14b19e:	6025      	str	r5, [r4, #0]
    list_initialize(&rpmsg_dcf_dev->endpoints);
  14b1a0:	1d23      	adds	r3, r4, #4
    rpmsg_dcf_dev->link_state = 1;
  14b1a2:	62a2      	str	r2, [r4, #40]	; 0x28
    list->prev = list->next = list;
  14b1a4:	e9c4 3301 	strd	r3, r3, [r4, #4]
     * communication.
     */
//    sd_ipcc_chan_kick(rpmsg_dcf_dev->tvq);

    return rpmsg_dcf_dev;
}
  14b1a8:	4620      	mov	r0, r4
  14b1aa:	b005      	add	sp, #20
  14b1ac:	bdf0      	pop	{r4, r5, r6, r7, r15}
            free(rpmsg_dcf_dev);
  14b1ae:	4620      	mov	r0, r4
            return NULL;
  14b1b0:	462c      	mov	r4, r5
            free(rpmsg_dcf_dev);
  14b1b2:	f007 fea3 	bl	152efc <free>
            return NULL;
  14b1b6:	e7f7      	b.n	14b1a8 <rpmsg_dcf_device_init+0x68>

0014b1b8 <rpmsg_dcf_ns_rx_cb>:
 *
 * @return  DCF_RELEASE, message is always freed
 *
 */
static int rpmsg_dcf_ns_rx_cb(void *payload, int payload_len, unsigned long src, void *priv)
{
  14b1b8:	b510      	push	{r4, r14}
  14b1ba:	b082      	sub	sp, #8
    struct rpmsg_dcf_ns_msg *ns_msg_ptr = payload;
    struct rpmsg_dcf_ns_callback_data *cb_ctxt = priv;
    ASSERT(priv);
  14b1bc:	b15b      	cbz	r3, 14b1d6 <rpmsg_dcf_ns_rx_cb+0x1e>
    ASSERT(cb_ctxt->cb);
  14b1be:	681c      	ldr	r4, [r3, #0]
  14b1c0:	b1d4      	cbz	r4, 14b1f8 <rpmsg_dcf_ns_rx_cb+0x40>

    /* Drop likely bad messages received at nameservice address */
    if (payload_len == sizeof(struct rpmsg_dcf_ns_msg))
  14b1c2:	2928      	cmp	r1, #40	; 0x28
  14b1c4:	d104      	bne.n	14b1d0 <rpmsg_dcf_ns_rx_cb+0x18>
    {
        cb_ctxt->cb(ns_msg_ptr->addr, ns_msg_ptr->name, ns_msg_ptr->flags, cb_ctxt->user_data);
  14b1c6:	6a42      	ldr	r2, [r0, #36]	; 0x24
  14b1c8:	4601      	mov	r1, r0
  14b1ca:	685b      	ldr	r3, [r3, #4]
  14b1cc:	6a00      	ldr	r0, [r0, #32]
  14b1ce:	47a0      	blx	r4
    }

    return DCF_RELEASE;
}
  14b1d0:	2000      	movs	r0, #0
  14b1d2:	b002      	add	sp, #8
  14b1d4:	bd10      	pop	{r4, r15}
    ASSERT(priv);
  14b1d6:	f246 1388 	movw	r3, #24968	; 0x6188
  14b1da:	f246 1250 	movw	r2, #24912	; 0x6150
  14b1de:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14b1e2:	f2c0 0315 	movt	r3, #21
  14b1e6:	4670      	mov	r0, r14
  14b1e8:	f2c0 0215 	movt	r2, #21
  14b1ec:	9300      	str	r3, [sp, #0]
  14b1ee:	f2c0 0115 	movt	r1, #21
  14b1f2:	2357      	movs	r3, #87	; 0x57
  14b1f4:	f007 fd5e 	bl	152cb4 <_panic>
    ASSERT(cb_ctxt->cb);
  14b1f8:	f246 1390 	movw	r3, #24976	; 0x6190
  14b1fc:	f246 1250 	movw	r2, #24912	; 0x6150
  14b200:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14b204:	f2c0 0315 	movt	r3, #21
  14b208:	4670      	mov	r0, r14
  14b20a:	f2c0 0215 	movt	r2, #21
  14b20e:	9300      	str	r3, [sp, #0]
  14b210:	f2c0 0115 	movt	r1, #21
  14b214:	2358      	movs	r3, #88	; 0x58
  14b216:	f007 fd4d 	bl	152cb4 <_panic>
  14b21a:	bf00      	nop

0014b21c <rpmsg_dcf_ns_bind>:

rpmsg_dcf_ns_handle rpmsg_dcf_ns_bind(struct rpmsg_dcf_instance *rpmsg_dcf_dev, rpmsg_dcf_ns_new_ept_cb app_cb, void *user_data)
{
  14b21c:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    struct rpmsg_dcf_ns_context *ns_ctxt;

    if (app_cb == NULL)
  14b220:	b1e1      	cbz	r1, 14b25c <rpmsg_dcf_ns_bind+0x40>
  14b222:	4680      	mov	r8, r0
    }

    {
        struct rpmsg_dcf_ns_callback_data *cb_ctxt;

        cb_ctxt = malloc(sizeof(struct rpmsg_dcf_ns_callback_data));
  14b224:	2008      	movs	r0, #8
  14b226:	460d      	mov	r5, r1
  14b228:	4617      	mov	r7, r2
  14b22a:	f007 fe31 	bl	152e90 <malloc>
        if (cb_ctxt == NULL)
  14b22e:	4604      	mov	r4, r0
  14b230:	b1a0      	cbz	r0, 14b25c <rpmsg_dcf_ns_bind+0x40>
        {
            return NULL;
        }
        ns_ctxt = malloc(sizeof(struct rpmsg_dcf_ns_context));
  14b232:	2008      	movs	r0, #8
  14b234:	f007 fe2c 	bl	152e90 <malloc>
        if (ns_ctxt == NULL)
  14b238:	4606      	mov	r6, r0
  14b23a:	b198      	cbz	r0, 14b264 <rpmsg_dcf_ns_bind+0x48>
        cb_ctxt->user_data = user_data;
        cb_ctxt->cb = app_cb;

        ns_ctxt->cb_ctxt = cb_ctxt;

        ns_ctxt->ept = rpmsg_dcf_create_ept(rpmsg_dcf_dev, DCF_NS_EPT_ADDR, rpmsg_dcf_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  14b23c:	f24b 12b9 	movw	r2, #45497	; 0xb1b9
  14b240:	4640      	mov	r0, r8
        cb_ctxt->user_data = user_data;
  14b242:	6067      	str	r7, [r4, #4]
        ns_ctxt->ept = rpmsg_dcf_create_ept(rpmsg_dcf_dev, DCF_NS_EPT_ADDR, rpmsg_dcf_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  14b244:	f2c0 0214 	movt	r2, #20
        cb_ctxt->cb = app_cb;
  14b248:	6025      	str	r5, [r4, #0]
        ns_ctxt->ept = rpmsg_dcf_create_ept(rpmsg_dcf_dev, DCF_NS_EPT_ADDR, rpmsg_dcf_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  14b24a:	4623      	mov	r3, r4
        ns_ctxt->cb_ctxt = cb_ctxt;
  14b24c:	6074      	str	r4, [r6, #4]
        ns_ctxt->ept = rpmsg_dcf_create_ept(rpmsg_dcf_dev, DCF_NS_EPT_ADDR, rpmsg_dcf_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  14b24e:	2135      	movs	r1, #53	; 0x35
  14b250:	f7ff fdf6 	bl	14ae40 <rpmsg_dcf_create_ept>
  14b254:	6030      	str	r0, [r6, #0]
    }

    return (rpmsg_dcf_ns_handle)ns_ctxt;
}
  14b256:	4630      	mov	r0, r6
  14b258:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return NULL;
  14b25c:	2600      	movs	r6, #0
}
  14b25e:	4630      	mov	r0, r6
  14b260:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            free(cb_ctxt);
  14b264:	4620      	mov	r0, r4
  14b266:	f007 fe49 	bl	152efc <free>
            return NULL;
  14b26a:	e7f4      	b.n	14b256 <rpmsg_dcf_ns_bind+0x3a>

0014b26c <rpmsg_dcf_ns_announce>:

int rpmsg_dcf_ns_announce(struct rpmsg_dcf_instance *rpmsg_dcf_dev,
                      struct rpmsg_dcf_endpoint *new_ept,
                      const char *ept_name,
                      unsigned long flags)
{
  14b26c:	b5f0      	push	{r4, r5, r6, r7, r14}
    if (ept_name == NULL)
    {
        return DCF_ERR_PARAM;
    }

    if (new_ept == NULL)
  14b26e:	fab1 f481 	clz	r4, r1
{
  14b272:	b08f      	sub	sp, #60	; 0x3c
    if (new_ept == NULL)
  14b274:	0964      	lsrs	r4, r4, #5
  14b276:	2a00      	cmp	r2, #0
  14b278:	bf08      	it	eq
  14b27a:	2401      	moveq	r4, #1
  14b27c:	b9d4      	cbnz	r4, 14b2b4 <rpmsg_dcf_ns_announce+0x48>
  14b27e:	460e      	mov	r6, r1
  14b280:	4605      	mov	r5, r0
    {
        return DCF_ERR_PARAM;
    }

    strncpy(ns_msg.name, ept_name, DCF_NS_NAME_SIZE);
  14b282:	4611      	mov	r1, r2
  14b284:	a804      	add	r0, sp, #16
  14b286:	2220      	movs	r2, #32
  14b288:	461f      	mov	r7, r3
  14b28a:	f008 ffb3 	bl	1541f4 <strncpy>
    ns_msg.flags = flags;
    ns_msg.addr = new_ept->addr;

    return rpmsg_dcf_format_message(rpmsg_dcf_dev, new_ept->addr, DCF_NS_EPT_ADDR, (char *)&ns_msg,
  14b28e:	f04f 3eff 	mov.w	r14, #4294967295	; 0xffffffff
  14b292:	f04f 0c28 	mov.w	r12, #40	; 0x28
  14b296:	ab04      	add	r3, sp, #16
    ns_msg.addr = new_ept->addr;
  14b298:	6836      	ldr	r6, [r6, #0]
    return rpmsg_dcf_format_message(rpmsg_dcf_dev, new_ept->addr, DCF_NS_EPT_ADDR, (char *)&ns_msg,
  14b29a:	4628      	mov	r0, r5
  14b29c:	4631      	mov	r1, r6
  14b29e:	2235      	movs	r2, #53	; 0x35
  14b2a0:	e9cd 4e01 	strd	r4, r14, [r13, #4]
  14b2a4:	f8cd c000 	str.w	r12, [r13]
    ns_msg.flags = flags;
  14b2a8:	e9cd 670c 	strd	r6, r7, [r13, #48]	; 0x30
    return rpmsg_dcf_format_message(rpmsg_dcf_dev, new_ept->addr, DCF_NS_EPT_ADDR, (char *)&ns_msg,
  14b2ac:	f7ff fe52 	bl	14af54 <rpmsg_dcf_format_message>
                                     sizeof(struct rpmsg_dcf_ns_msg), DCF_NO_FLAGS, DCF_BLOCK);
}
  14b2b0:	b00f      	add	sp, #60	; 0x3c
  14b2b2:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return DCF_ERR_PARAM;
  14b2b4:	f64e 4075 	movw	r0, #60533	; 0xec75
  14b2b8:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14b2bc:	e7f8      	b.n	14b2b0 <rpmsg_dcf_ns_announce+0x44>
  14b2be:	bf00      	nop

0014b2c0 <start_echo_loop>:
    struct dcf_message *msg;
    unsigned long src = 0;
    sd_rpbuf_t *rpbuf;
    bool ns = false;

    if (dev->config.rproc == IPCC_RRPOC_AP1 || dev->config.rproc == IPCC_RRPOC_AP2)
  14b2c0:	6903      	ldr	r3, [r0, #16]
        ns = true;

    ichan = ipcc_channel_create(dev, IPCC_ECHO_EPT, IPCC_ECHO_CHN_NAME, ns);
  14b2c2:	f246 129c 	movw	r2, #24988	; 0x619c
{
  14b2c6:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    int recved = 0;
  14b2ca:	2500      	movs	r5, #0
    if (dev->config.rproc == IPCC_RRPOC_AP1 || dev->config.rproc == IPCC_RRPOC_AP2)
  14b2cc:	3b03      	subs	r3, #3
{
  14b2ce:	b085      	sub	sp, #20
    ichan = ipcc_channel_create(dev, IPCC_ECHO_EPT, IPCC_ECHO_CHN_NAME, ns);
  14b2d0:	211e      	movs	r1, #30
  14b2d2:	2b01      	cmp	r3, #1
  14b2d4:	bf8c      	ite	hi
  14b2d6:	2300      	movhi	r3, #0
  14b2d8:	2301      	movls	r3, #1
{
  14b2da:	4607      	mov	r7, r0
    ichan = ipcc_channel_create(dev, IPCC_ECHO_EPT, IPCC_ECHO_CHN_NAME, ns);
  14b2dc:	f2c0 0215 	movt	r2, #21
    int recved = 0;
  14b2e0:	9502      	str	r5, [sp, #8]
    unsigned long src = 0;
  14b2e2:	9503      	str	r5, [sp, #12]
    ichan = ipcc_channel_create(dev, IPCC_ECHO_EPT, IPCC_ECHO_CHN_NAME, ns);
  14b2e4:	f000 fa7c 	bl	14b7e0 <ipcc_channel_create>
    if (!ichan)
  14b2e8:	2800      	cmp	r0, #0
  14b2ea:	d065      	beq.n	14b3b8 <start_echo_loop+0xf8>
        return;

    ipcc_channel_start(ichan, NULL);
  14b2ec:	4629      	mov	r1, r5
  14b2ee:	4604      	mov	r4, r0
  14b2f0:	f000 faf8 	bl	14b8e4 <ipcc_channel_start>
        }
        recved = ichan->mtu;
        payload = ipcc_device_import_rpbuf(dev, rpbuf, &src, &recved);
        if (!payload) {
            ichan->drop_cnt++;
            dprintf(0, "ipcc: invalid rpbuf=%p \n", rpbuf);
  14b2f4:	f246 19c4 	movw	r9, #25028	; 0x61c4
            dprintf(0, "ipcc:fail to receive rpbuf\n");
  14b2f8:	f246 18a8 	movw	r8, #25000	; 0x61a8
            dprintf(0, "ipcc: invalid rpbuf=%p \n", rpbuf);
  14b2fc:	f2c0 0915 	movt	r9, #21
            dprintf(0, "ipcc:fail to receive rpbuf\n");
  14b300:	f2c0 0815 	movt	r8, #21
        rpbuf = ipcc_channel_recvbuf(ichan, INFINITE_TIME);
  14b304:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14b308:	4620      	mov	r0, r4
  14b30a:	f000 fb85 	bl	14ba18 <ipcc_channel_recvbuf>
        payload = ipcc_device_import_rpbuf(dev, rpbuf, &src, &recved);
  14b30e:	ab02      	add	r3, sp, #8
  14b310:	aa03      	add	r2, sp, #12
        if (!rpbuf) {
  14b312:	4605      	mov	r5, r0
        payload = ipcc_device_import_rpbuf(dev, rpbuf, &src, &recved);
  14b314:	4601      	mov	r1, r0
        if (!rpbuf) {
  14b316:	b300      	cbz	r0, 14b35a <start_echo_loop+0x9a>
        recved = ichan->mtu;
  14b318:	69a6      	ldr	r6, [r4, #24]
        payload = ipcc_device_import_rpbuf(dev, rpbuf, &src, &recved);
  14b31a:	4638      	mov	r0, r7
        recved = ichan->mtu;
  14b31c:	9602      	str	r6, [sp, #8]
        payload = ipcc_device_import_rpbuf(dev, rpbuf, &src, &recved);
  14b31e:	f000 fb83 	bl	14ba28 <ipcc_device_import_rpbuf>
            ipcc_channel_sendto(ichan, src, payload, 4, 1000);
            ipcc_device_release_rpbuf(dev, rpbuf);
            continue;
        }
        dprintf(1, "ipcc:drop %d bytes\n", recved);
        ipcc_device_release_rpbuf(dev, rpbuf);
  14b322:	4629      	mov	r1, r5
        if (!payload) {
  14b324:	4602      	mov	r2, r0
  14b326:	2800      	cmp	r0, #0
  14b328:	d03f      	beq.n	14b3aa <start_echo_loop+0xea>
        ichan->rx_cnt++;
  14b32a:	6d23      	ldr	r3, [r4, #80]	; 0x50
        if (msg->msg_type == COMM_MSG_CCM_ECHO) {
  14b32c:	f892 c000 	ldrb.w	r12, [r2]
        ichan->rx_bytes += recved;
  14b330:	6ca6      	ldr	r6, [r4, #72]	; 0x48
        if (msg->msg_type == COMM_MSG_CCM_ECHO) {
  14b332:	f1bc 0fa5 	cmp.w	r12, #165	; 0xa5
        ichan->rx_bytes += recved;
  14b336:	f8dd e008 	ldr.w	r14, [r13, #8]
        ichan->rx_cnt++;
  14b33a:	f103 0301 	add.w	r3, r3, #1
        ipcc_device_release_rpbuf(dev, rpbuf);
  14b33e:	4638      	mov	r0, r7
        ichan->rx_cnt++;
  14b340:	6523      	str	r3, [r4, #80]	; 0x50
        ichan->rx_bytes += recved;
  14b342:	4476      	add	r6, r14
  14b344:	64a6      	str	r6, [r4, #72]	; 0x48
        if (msg->msg_type == COMM_MSG_CCM_ECHO) {
  14b346:	d01c      	beq.n	14b382 <start_echo_loop+0xc2>
        if (msg->msg_type == COMM_MSG_CCM_ACK) {
  14b348:	f1bc 0fa6 	cmp.w	r12, #166	; 0xa6
  14b34c:	d00c      	beq.n	14b368 <start_echo_loop+0xa8>
        ipcc_device_release_rpbuf(dev, rpbuf);
  14b34e:	f000 fb6f 	bl	14ba30 <ipcc_device_release_rpbuf>
        ichan->drop_cnt++;
  14b352:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  14b354:	3301      	adds	r3, #1
  14b356:	65e3      	str	r3, [r4, #92]	; 0x5c
  14b358:	e7d4      	b.n	14b304 <start_echo_loop+0x44>
            ichan->err_cnt++;
  14b35a:	6da3      	ldr	r3, [r4, #88]	; 0x58
            dprintf(0, "ipcc:fail to receive rpbuf\n");
  14b35c:	4640      	mov	r0, r8
            ichan->err_cnt++;
  14b35e:	3301      	adds	r3, #1
  14b360:	65a3      	str	r3, [r4, #88]	; 0x58
            dprintf(0, "ipcc:fail to receive rpbuf\n");
  14b362:	f008 fec9 	bl	1540f8 <_printf>
            continue;
  14b366:	e7cd      	b.n	14b304 <start_echo_loop+0x44>
            ipcc_channel_sendto(ichan, src, payload, 4, 1000);
  14b368:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  14b36c:	2304      	movs	r3, #4
  14b36e:	9903      	ldr	r1, [sp, #12]
  14b370:	9000      	str	r0, [sp, #0]
  14b372:	4620      	mov	r0, r4
  14b374:	f000 fb06 	bl	14b984 <ipcc_channel_sendto>
            ipcc_device_release_rpbuf(dev, rpbuf);
  14b378:	4629      	mov	r1, r5
  14b37a:	4638      	mov	r0, r7
  14b37c:	f000 fb58 	bl	14ba30 <ipcc_device_release_rpbuf>
            continue;
  14b380:	e7c0      	b.n	14b304 <start_echo_loop+0x44>
            ipcc_channel_sendto(ichan, src, payload, recved, 1000);
  14b382:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  14b386:	4673      	mov	r3, r14
  14b388:	9903      	ldr	r1, [sp, #12]
  14b38a:	9000      	str	r0, [sp, #0]
  14b38c:	4620      	mov	r0, r4
  14b38e:	f000 faf9 	bl	14b984 <ipcc_channel_sendto>
            ichan->tx_cnt++;
  14b392:	6d60      	ldr	r0, [r4, #84]	; 0x54
            ichan->tx_bytes += recved;
  14b394:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
            ipcc_device_release_rpbuf(dev, rpbuf);
  14b396:	4629      	mov	r1, r5
            ichan->tx_bytes += recved;
  14b398:	9a02      	ldr	r2, [sp, #8]
            ichan->tx_cnt++;
  14b39a:	1c45      	adds	r5, r0, #1
            ipcc_device_release_rpbuf(dev, rpbuf);
  14b39c:	4638      	mov	r0, r7
            ichan->tx_cnt++;
  14b39e:	6565      	str	r5, [r4, #84]	; 0x54
            ichan->tx_bytes += recved;
  14b3a0:	4413      	add	r3, r2
  14b3a2:	64e3      	str	r3, [r4, #76]	; 0x4c
            ipcc_device_release_rpbuf(dev, rpbuf);
  14b3a4:	f000 fb44 	bl	14ba30 <ipcc_device_release_rpbuf>
            continue;
  14b3a8:	e7ac      	b.n	14b304 <start_echo_loop+0x44>
            ichan->drop_cnt++;
  14b3aa:	6de3      	ldr	r3, [r4, #92]	; 0x5c
            dprintf(0, "ipcc: invalid rpbuf=%p \n", rpbuf);
  14b3ac:	4648      	mov	r0, r9
            ichan->drop_cnt++;
  14b3ae:	3301      	adds	r3, #1
  14b3b0:	65e3      	str	r3, [r4, #92]	; 0x5c
            dprintf(0, "ipcc: invalid rpbuf=%p \n", rpbuf);
  14b3b2:	f008 fea1 	bl	1540f8 <_printf>
            continue;
  14b3b6:	e7a5      	b.n	14b304 <start_echo_loop+0x44>
    }

fail_out1:
    ipcc_channel_stop(ichan);
    ipcc_channel_destroy(ichan);
}
  14b3b8:	b005      	add	sp, #20
  14b3ba:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
  14b3be:	bf00      	nop

0014b3c0 <ipcc_new_ept_cb>:

    dev = (struct ipcc_device *) user_data;
    dprintf(INFO, "%s: receive new ept %d:%d %s flags %ld\n", __func__,
           dev->config.rproc, new_ept, new_ept_name, flags);

    list_for_every_entry(&dev->channels, ichan,
  14b3c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
{
  14b3c2:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    list_for_every_entry(&dev->channels, ichan,
  14b3c4:	f103 0528 	add.w	r5, r3, #40	; 0x28
  14b3c8:	4295      	cmp	r5, r2
  14b3ca:	d010      	beq.n	14b3ee <ipcc_new_ept_cb+0x2e>
  14b3cc:	461e      	mov	r6, r3
  14b3ce:	f1a2 0440 	sub.w	r4, r2, #64	; 0x40
                         struct ipcc_channel, node) {
        if (ichan->endpoint && ichan->announce && !ichan->last_announced) {
            ichan->last_announced = 1;
  14b3d2:	2701      	movs	r7, #1
        if (ichan->endpoint && ichan->announce && !ichan->last_announced) {
  14b3d4:	6e61      	ldr	r1, [r4, #100]	; 0x64
  14b3d6:	b129      	cbz	r1, 14b3e4 <ipcc_new_ept_cb+0x24>
  14b3d8:	f894 2098 	ldrb.w	r2, [r4, #152]	; 0x98
  14b3dc:	b112      	cbz	r2, 14b3e4 <ipcc_new_ept_cb+0x24>
  14b3de:	f894 30a4 	ldrb.w	r3, [r4, #164]	; 0xa4
  14b3e2:	b12b      	cbz	r3, 14b3f0 <ipcc_new_ept_cb+0x30>
    list_for_every_entry(&dev->channels, ichan,
  14b3e4:	6c62      	ldr	r2, [r4, #68]	; 0x44
  14b3e6:	4295      	cmp	r5, r2
  14b3e8:	f1a2 0440 	sub.w	r4, r2, #64	; 0x40
  14b3ec:	d1f2      	bne.n	14b3d4 <ipcc_new_ept_cb+0x14>
            rpmsg_dcf_ns_announce(dev->rpmsg_dev, ichan->endpoint, ichan->name, DCF_NS_CREATE);
        }
    }
}
  14b3ee:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            ichan->last_announced = 1;
  14b3f0:	f884 70a4 	strb.w	r7, [r4, #164]	; 0xa4
            rpmsg_dcf_ns_announce(dev->rpmsg_dev, ichan->endpoint, ichan->name, DCF_NS_CREATE);
  14b3f4:	4622      	mov	r2, r4
  14b3f6:	6eb0      	ldr	r0, [r6, #104]	; 0x68
  14b3f8:	f7ff ff38 	bl	14b26c <rpmsg_dcf_ns_announce>
  14b3fc:	e7f2      	b.n	14b3e4 <ipcc_new_ept_cb+0x24>
  14b3fe:	bf00      	nop

0014b400 <recv_rpbuf_timed>:
static sd_rpbuf_t *recv_rpbuf_timed(struct ipcc_channel *ichan, lk_time_t timeout)
{
    status_t ret = 0;

    /* FIXME: a bug in sem_timedwait of freertos lk-wrapper*/
    if (timeout != INFINITE_TIME)
  14b400:	1c4b      	adds	r3, r1, #1
{
  14b402:	b510      	push	{r4, r14}
  14b404:	4604      	mov	r4, r0
  14b406:	f100 0078 	add.w	r0, r0, #120	; 0x78
    if (timeout != INFINITE_TIME)
  14b40a:	d008      	beq.n	14b41e <recv_rpbuf_timed+0x1e>
        ret = sem_timedwait(&ichan->rxq_wait, timeout);
  14b40c:	f004 ff54 	bl	1502b8 <sem_timedwait>
    else
        ret = sem_wait(&ichan->rxq_wait);

    if (ret ==  NO_ERROR) {
  14b410:	b948      	cbnz	r0, 14b426 <recv_rpbuf_timed+0x26>
        dprintf(2, "%s\n", __func__);
        return sd_rpbuf_dequeue(&ichan->rxq);
  14b412:	f104 0068 	add.w	r0, r4, #104	; 0x68
    }

    return NULL;
}
  14b416:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        return sd_rpbuf_dequeue(&ichan->rxq);
  14b41a:	f000 bf29 	b.w	14c270 <sd_rpbuf_dequeue>
        ret = sem_wait(&ichan->rxq_wait);
  14b41e:	f004 ff15 	bl	15024c <sem_wait>
    if (ret ==  NO_ERROR) {
  14b422:	2800      	cmp	r0, #0
  14b424:	d0f5      	beq.n	14b412 <recv_rpbuf_timed+0x12>
}
  14b426:	2000      	movs	r0, #0
  14b428:	bd10      	pop	{r4, r15}
  14b42a:	bf00      	nop

0014b42c <ipcc_device_thread>:
{
  14b42c:	b510      	push	{r4, r14}
  14b42e:	4604      	mov	r4, r0
    dev->rpmsg_dev = rpmsg_dcf_device_init(dev->config.rproc, dev->config.cfg.init_flags);
  14b430:	e9d0 0104 	ldrd	r0, r1, [r0, #16]
  14b434:	f7ff fe84 	bl	14b140 <rpmsg_dcf_device_init>
  14b438:	66a0      	str	r0, [r4, #104]	; 0x68
    if (!dev->rpmsg_dev) {
  14b43a:	b1a0      	cbz	r0, 14b466 <ipcc_device_thread+0x3a>
    dev->rpmsg_ns = rpmsg_dcf_ns_bind(dev->rpmsg_dev, ipcc_new_ept_cb, (void *) dev);
  14b43c:	f24b 31c1 	movw	r1, #46017	; 0xb3c1
  14b440:	4622      	mov	r2, r4
  14b442:	f2c0 0114 	movt	r1, #20
  14b446:	f7ff fee9 	bl	14b21c <rpmsg_dcf_ns_bind>
  14b44a:	66e0      	str	r0, [r4, #108]	; 0x6c
    if (!dev->rpmsg_ns) {
  14b44c:	b1a8      	cbz	r0, 14b47a <ipcc_device_thread+0x4e>
    dev->state = 1;
  14b44e:	2301      	movs	r3, #1
    event_signal(&dev->initialized, false);
  14b450:	2100      	movs	r1, #0
  14b452:	f104 004c 	add.w	r0, r4, #76	; 0x4c
    dev->state = 1;
  14b456:	6223      	str	r3, [r4, #32]
    event_signal(&dev->initialized, false);
  14b458:	f003 fe38 	bl	14f0cc <event_signal>
    start_echo_loop(dev);
  14b45c:	4620      	mov	r0, r4
  14b45e:	f7ff ff2f 	bl	14b2c0 <start_echo_loop>
    return 0;
  14b462:	2000      	movs	r0, #0
}
  14b464:	bd10      	pop	{r4, r15}
        dprintf(ALWAYS, "init rpmsg device %d failed\n", dev->config.rproc);
  14b466:	6921      	ldr	r1, [r4, #16]
  14b468:	f246 208c 	movw	r0, #25228	; 0x628c
  14b46c:	f2c0 0015 	movt	r0, #21
  14b470:	f008 fe42 	bl	1540f8 <_printf>
  14b474:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14b478:	bd10      	pop	{r4, r15}
        dprintf(ALWAYS, "bind rpmsg ns failed\n");
  14b47a:	f246 20ac 	movw	r0, #25260	; 0x62ac
  14b47e:	f2c0 0015 	movt	r0, #21
  14b482:	f008 fe39 	bl	1540f8 <_printf>
        return -1;
  14b486:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14b48a:	bd10      	pop	{r4, r15}

0014b48c <ipcc_channel_rx_cb>:
{
  14b48c:	b538      	push	{r3, r4, r5, r14}
  14b48e:	461c      	mov	r4, r3
    if (payload) {
  14b490:	b158      	cbz	r0, 14b4aa <ipcc_channel_rx_cb+0x1e>
    struct rpmsg_dcf_instance *rpmsg_dev = ichan->parent->rpmsg_dev;
  14b492:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  14b494:	4605      	mov	r5, r0
        rpbuf = rpmsg_dcf_get_rpbuf(rpmsg_dev, payload);
  14b496:	4601      	mov	r1, r0
  14b498:	6e98      	ldr	r0, [r3, #104]	; 0x68
  14b49a:	f7ff fdef 	bl	14b07c <rpmsg_dcf_get_rpbuf>
        if (!rpbuf) {
  14b49e:	b198      	cbz	r0, 14b4c8 <ipcc_channel_rx_cb+0x3c>
        sd_rpbuf_enqueue(&ichan->rxq, rpbuf);
  14b4a0:	4601      	mov	r1, r0
  14b4a2:	f104 0068 	add.w	r0, r4, #104	; 0x68
  14b4a6:	f000 febf 	bl	14c228 <sd_rpbuf_enqueue>
    sem_post(&ichan->rxq_wait, true);
  14b4aa:	2101      	movs	r1, #1
  14b4ac:	f104 0078 	add.w	r0, r4, #120	; 0x78
  14b4b0:	f004 fe98 	bl	1501e4 <sem_post>
    if (ichan->event_cb)
  14b4b4:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
  14b4b8:	b1bb      	cbz	r3, 14b4ea <ipcc_channel_rx_cb+0x5e>
        ichan->event_cb(ichan->event_cb_ctx, IPCC_EVENT_RECVED, 0);
  14b4ba:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
  14b4be:	2200      	movs	r2, #0
  14b4c0:	4611      	mov	r1, r2
  14b4c2:	4798      	blx	r3
    return DCF_HOLD;
  14b4c4:	2001      	movs	r0, #1
}
  14b4c6:	bd38      	pop	{r3, r4, r5, r15}
            if (ichan->event_cb)
  14b4c8:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
  14b4cc:	b123      	cbz	r3, 14b4d8 <ipcc_channel_rx_cb+0x4c>
                ichan->event_cb(ichan->event_cb_ctx, IPCC_EVENT_ERROR, 0);
  14b4ce:	4602      	mov	r2, r0
  14b4d0:	2102      	movs	r1, #2
  14b4d2:	f8d4 00a0 	ldr.w	r0, [r4, #160]	; 0xa0
  14b4d6:	4798      	blx	r3
            dprintf(0, "Not found rpbuf with ptr=%p\n", payload);
  14b4d8:	f246 10f0 	movw	r0, #25072	; 0x61f0
  14b4dc:	4629      	mov	r1, r5
  14b4de:	f2c0 0015 	movt	r0, #21
  14b4e2:	f008 fe09 	bl	1540f8 <_printf>
  14b4e6:	2000      	movs	r0, #0
}
  14b4e8:	bd38      	pop	{r3, r4, r5, r15}
    return DCF_HOLD;
  14b4ea:	2001      	movs	r0, #1
}
  14b4ec:	bd38      	pop	{r3, r4, r5, r15}
  14b4ee:	bf00      	nop

0014b4f0 <release_channel.isra.2.part.3>:
static void release_channel(struct ipcc_device *dev, struct ipcc_channel *ichan)
  14b4f0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
            dprintf(0, "ipcc: release rpbuf=%d\n", rpbuf->buf_id);
  14b4f4:	f246 3604 	movw	r6, #25348	; 0x6304
static void release_channel(struct ipcc_device *dev, struct ipcc_channel *ichan)
  14b4f8:	4688      	mov	r8, r1
  14b4fa:	4607      	mov	r7, r0
  14b4fc:	f101 0568 	add.w	r5, r1, #104	; 0x68
            dprintf(0, "ipcc: release rpbuf=%d\n", rpbuf->buf_id);
  14b500:	f2c0 0615 	movt	r6, #21
  14b504:	e00b      	b.n	14b51e <release_channel.isra.2.part.3+0x2e>
            rpbuf = sd_rpbuf_dequeue(&ichan->rxq);
  14b506:	4628      	mov	r0, r5
  14b508:	f000 feb2 	bl	14c270 <sd_rpbuf_dequeue>
  14b50c:	4604      	mov	r4, r0
            dprintf(0, "ipcc: release rpbuf=%d\n", rpbuf->buf_id);
  14b50e:	4630      	mov	r0, r6
  14b510:	8a61      	ldrh	r1, [r4, #18]
  14b512:	f008 fdf1 	bl	1540f8 <_printf>
            rpmsg_dcf_release_rpbuf(dev->rpmsg_dev, rpbuf);
  14b516:	6838      	ldr	r0, [r7, #0]
  14b518:	4621      	mov	r1, r4
  14b51a:	f7ff fdfd 	bl	14b118 <rpmsg_dcf_release_rpbuf>
        while (!sd_rpbuf_queue_empty(&ichan->rxq)) {
  14b51e:	4628      	mov	r0, r5
  14b520:	f000 feca 	bl	14c2b8 <sd_rpbuf_queue_empty>
  14b524:	2800      	cmp	r0, #0
  14b526:	d0ee      	beq.n	14b506 <release_channel.isra.2.part.3+0x16>
        sd_rpbuf_remove_queue(&ichan->rxq);
  14b528:	4628      	mov	r0, r5
  14b52a:	f000 fe41 	bl	14c1b0 <sd_rpbuf_remove_queue>
        sem_destroy(&ichan->rxq_wait);
  14b52e:	f108 0078 	add.w	r0, r8, #120	; 0x78
  14b532:	f004 fe33 	bl	15019c <sem_destroy>
        if (ichan->endpoint)
  14b536:	f8d8 1064 	ldr.w	r1, [r8, #100]	; 0x64
  14b53a:	b111      	cbz	r1, 14b542 <release_channel.isra.2.part.3+0x52>
            rpmsg_dcf_destroy_ept(dev->rpmsg_dev, ichan->endpoint);
  14b53c:	6838      	ldr	r0, [r7, #0]
  14b53e:	f7ff fce5 	bl	14af0c <rpmsg_dcf_destroy_ept>
        free(ichan);
  14b542:	4640      	mov	r0, r8
}
  14b544:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
        free(ichan);
  14b548:	f007 bcd8 	b.w	152efc <free>

0014b54c <looper_thread>:
{
  14b54c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    int recved = 0;
  14b550:	2300      	movs	r3, #0
{
  14b552:	b084      	sub	sp, #16
    int recved = 0;
  14b554:	9302      	str	r3, [sp, #8]
    if (!ichan) {
  14b556:	2800      	cmp	r0, #0
  14b558:	d052      	beq.n	14b600 <looper_thread+0xb4>
  14b55a:	4604      	mov	r4, r0
    rxbuf = malloc(ichan->mtu);
  14b55c:	6980      	ldr	r0, [r0, #24]
  14b55e:	f007 fc97 	bl	152e90 <malloc>
    if (!rxbuf) {
  14b562:	4606      	mov	r6, r0
  14b564:	2800      	cmp	r0, #0
  14b566:	d04e      	beq.n	14b606 <looper_thread+0xba>
  14b568:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    event_signal(&ichan->initialized, true);
  14b56c:	2101      	movs	r1, #1
  14b56e:	f104 001c 	add.w	r0, r4, #28
    ichan->looper = get_current_thread();
  14b572:	63e3      	str	r3, [r4, #60]	; 0x3c
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14b574:	f246 19e0 	movw	r9, #25056	; 0x61e0
  14b578:	f246 28e0 	movw	r8, #25312	; 0x62e0
    event_signal(&ichan->initialized, true);
  14b57c:	f003 fda6 	bl	14f0cc <event_signal>
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14b580:	f2c0 0915 	movt	r9, #21
    ichan->state = DCF_STATE_Connected;
  14b584:	2305      	movs	r3, #5
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14b586:	f2c0 0815 	movt	r8, #21
  14b58a:	f10d 0a08 	add.w	r10, r13, #8
    ichan->state = DCF_STATE_Connected;
  14b58e:	63a3      	str	r3, [r4, #56]	; 0x38

static int recvfrom_timed(struct ipcc_channel *ichan, unsigned long *src,
                            char *data, int *len, lk_time_t timeout)
{
    struct rpmsg_dcf_instance *rpmsg_dev = ichan->parent->rpmsg_dev;
  14b590:	6e23      	ldr	r3, [r4, #96]	; 0x60
    sd_rpbuf_t *rpbuf = NULL;

    rpbuf = recv_rpbuf_timed(ichan, timeout);
  14b592:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        recved = ichan->mtu;
  14b596:	69a2      	ldr	r2, [r4, #24]
    rpbuf = recv_rpbuf_timed(ichan, timeout);
  14b598:	4620      	mov	r0, r4
        recved = ichan->mtu;
  14b59a:	9202      	str	r2, [sp, #8]
    struct rpmsg_dcf_instance *rpmsg_dev = ichan->parent->rpmsg_dev;
  14b59c:	6e9d      	ldr	r5, [r3, #104]	; 0x68
    rpbuf = recv_rpbuf_timed(ichan, timeout);
  14b59e:	f7ff ff2f 	bl	14b400 <recv_rpbuf_timed>
    return rpmsg_dcf_copy_payload(rpmsg_dev, rpbuf, src, data, len);
  14b5a2:	f8cd a000 	str.w	r10, [r13]
  14b5a6:	aa03      	add	r2, sp, #12
  14b5a8:	4633      	mov	r3, r6
  14b5aa:	4601      	mov	r1, r0
  14b5ac:	4628      	mov	r0, r5
  14b5ae:	f7ff fd85 	bl	14b0bc <rpmsg_dcf_copy_payload>
            ichan->msg_handler(ichan, (struct dcf_message *)rxbuf, recved, src);
  14b5b2:	4631      	mov	r1, r6
        if (ret < 0) {
  14b5b4:	1e02      	subs	r2, r0, #0
            ichan->msg_handler(ichan, (struct dcf_message *)rxbuf, recved, src);
  14b5b6:	4620      	mov	r0, r4
        if (ret < 0) {
  14b5b8:	db1a      	blt.n	14b5f0 <looper_thread+0xa4>
        ichan->rx_cnt++;
  14b5ba:	6d25      	ldr	r5, [r4, #80]	; 0x50
        ichan->rx_bytes += recved;
  14b5bc:	9b02      	ldr	r3, [sp, #8]
  14b5be:	6ca7      	ldr	r7, [r4, #72]	; 0x48
        ichan->rx_cnt++;
  14b5c0:	f105 0c01 	add.w	r12, r5, #1
        if (ichan->msg_handler)
  14b5c4:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
            ichan->msg_handler(ichan, (struct dcf_message *)rxbuf, recved, src);
  14b5c8:	461a      	mov	r2, r3
        ichan->rx_cnt++;
  14b5ca:	f8c4 c050 	str.w	r12, [r4, #80]	; 0x50
        ichan->rx_bytes += recved;
  14b5ce:	443b      	add	r3, r7
  14b5d0:	64a3      	str	r3, [r4, #72]	; 0x48
        if (ichan->msg_handler)
  14b5d2:	b10d      	cbz	r5, 14b5d8 <looper_thread+0x8c>
            ichan->msg_handler(ichan, (struct dcf_message *)rxbuf, recved, src);
  14b5d4:	9b03      	ldr	r3, [sp, #12]
  14b5d6:	47a8      	blx	r5
    while (ichan->state == DCF_STATE_Connected) {
  14b5d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  14b5da:	2b05      	cmp	r3, #5
  14b5dc:	d0d8      	beq.n	14b590 <looper_thread+0x44>
    ichan->state = DCF_STATE_Closed;
  14b5de:	2304      	movs	r3, #4
        free(rxbuf);
  14b5e0:	4630      	mov	r0, r6
    ichan->state = DCF_STATE_Closed;
  14b5e2:	63a3      	str	r3, [r4, #56]	; 0x38
        free(rxbuf);
  14b5e4:	f007 fc8a 	bl	152efc <free>
    return 0;
  14b5e8:	2000      	movs	r0, #0
}
  14b5ea:	b004      	add	sp, #16
  14b5ec:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            ichan->err_cnt++;
  14b5f0:	6da3      	ldr	r3, [r4, #88]	; 0x58
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14b5f2:	4649      	mov	r1, r9
  14b5f4:	4640      	mov	r0, r8
            ichan->err_cnt++;
  14b5f6:	3301      	adds	r3, #1
  14b5f8:	65a3      	str	r3, [r4, #88]	; 0x58
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14b5fa:	f008 fd7d 	bl	1540f8 <_printf>
            continue;
  14b5fe:	e7eb      	b.n	14b5d8 <looper_thread+0x8c>
        return ERR_BAD_STATE;
  14b600:	f06f 001e 	mvn.w	r0, #30
  14b604:	e7f1      	b.n	14b5ea <looper_thread+0x9e>
        dprintf(0, "No memory for ipcc channel\n");
  14b606:	f246 20c4 	movw	r0, #25284	; 0x62c4
  14b60a:	f2c0 0015 	movt	r0, #21
  14b60e:	f008 fd73 	bl	1540f8 <_printf>
        return ERR_NO_MEMORY;
  14b612:	f06f 0004 	mvn.w	r0, #4
  14b616:	e7e8      	b.n	14b5ea <looper_thread+0x9e>

0014b618 <ipcc_device_gethandle>:
{
  14b618:	b570      	push	{r4, r5, r6, r14}
  14b61a:	f643 05a8 	movw	r5, #14504	; 0x38a8
  14b61e:	460c      	mov	r4, r1
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b620:	2200      	movs	r2, #0
  14b622:	f2c0 0516 	movt	r5, #22
  14b626:	462b      	mov	r3, r5
        dev = &ipcc_devices[i];
  14b628:	461e      	mov	r6, r3
        if (dev->used && rproc == dev->config.rproc) {
  14b62a:	7f19      	ldrb	r1, [r3, #28]
  14b62c:	b111      	cbz	r1, 14b634 <ipcc_device_gethandle+0x1c>
  14b62e:	6919      	ldr	r1, [r3, #16]
  14b630:	4288      	cmp	r0, r1
  14b632:	d007      	beq.n	14b644 <ipcc_device_gethandle+0x2c>
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b634:	3201      	adds	r2, #1
  14b636:	2a06      	cmp	r2, #6
  14b638:	f103 0370 	add.w	r3, r3, #112	; 0x70
  14b63c:	d1f4      	bne.n	14b628 <ipcc_device_gethandle+0x10>
            return NULL;
  14b63e:	2600      	movs	r6, #0
}
  14b640:	4630      	mov	r0, r6
  14b642:	bd70      	pop	{r4, r5, r6, r15}
    while(!dev->state) {
  14b644:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
  14b648:	eb05 1502 	add.w	r5, r5, r2, lsl #4
  14b64c:	6a2b      	ldr	r3, [r5, #32]
  14b64e:	b13b      	cbz	r3, 14b660 <ipcc_device_gethandle+0x48>
  14b650:	e7f6      	b.n	14b640 <ipcc_device_gethandle+0x28>
        thread_sleep(RETRY_INTERNAL);
  14b652:	2014      	movs	r0, #20
        ms -= RETRY_INTERNAL;
  14b654:	3c14      	subs	r4, #20
        thread_sleep(RETRY_INTERNAL);
  14b656:	f004 f8eb 	bl	14f830 <thread_sleep>
    while(!dev->state) {
  14b65a:	6a2b      	ldr	r3, [r5, #32]
  14b65c:	2b00      	cmp	r3, #0
  14b65e:	d1ef      	bne.n	14b640 <ipcc_device_gethandle+0x28>
        if (ms < RETRY_INTERNAL) {
  14b660:	2c13      	cmp	r4, #19
  14b662:	d8f6      	bhi.n	14b652 <ipcc_device_gethandle+0x3a>
  14b664:	e7eb      	b.n	14b63e <ipcc_device_gethandle+0x26>
  14b666:	bf00      	nop

0014b668 <ipcc_device_probe>:
{
  14b668:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  14b66c:	4606      	mov	r6, r0
  14b66e:	f643 00a8 	movw	r0, #14504	; 0x38a8
  14b672:	f2c0 0016 	movt	r0, #22
    struct ipcc_device *dev = find_device_by_rproc(conf->rproc);
  14b676:	4607      	mov	r7, r0
{
  14b678:	b087      	sub	sp, #28
    struct ipcc_device *dev = find_device_by_rproc(conf->rproc);
  14b67a:	6931      	ldr	r1, [r6, #16]
  14b67c:	4602      	mov	r2, r0
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b67e:	2300      	movs	r3, #0
        if (dev->used && rproc == dev->config.rproc) {
  14b680:	7f14      	ldrb	r4, [r2, #28]
  14b682:	b114      	cbz	r4, 14b68a <ipcc_device_probe+0x22>
  14b684:	6914      	ldr	r4, [r2, #16]
  14b686:	42a1      	cmp	r1, r4
  14b688:	d069      	beq.n	14b75e <ipcc_device_probe+0xf6>
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b68a:	3301      	adds	r3, #1
  14b68c:	2b06      	cmp	r3, #6
  14b68e:	f102 0270 	add.w	r2, r2, #112	; 0x70
  14b692:	d1f5      	bne.n	14b680 <ipcc_device_probe+0x18>
        dev = &ipcc_devices[i];
  14b694:	f643 08a8 	movw	r8, #14504	; 0x38a8
        if (dev->used == false) {
  14b698:	7f3c      	ldrb	r4, [r7, #28]
  14b69a:	4625      	mov	r5, r4
        dev = &ipcc_devices[i];
  14b69c:	f2c0 0816 	movt	r8, #22
        if (dev->used == false) {
  14b6a0:	b1bc      	cbz	r4, 14b6d2 <ipcc_device_probe+0x6a>
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b6a2:	2401      	movs	r4, #1
        if (dev->used == false) {
  14b6a4:	f890 308c 	ldrb.w	r3, [r0, #140]	; 0x8c
  14b6a8:	3070      	adds	r0, #112	; 0x70
  14b6aa:	b16b      	cbz	r3, 14b6c8 <ipcc_device_probe+0x60>
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b6ac:	3401      	adds	r4, #1
  14b6ae:	2c06      	cmp	r4, #6
  14b6b0:	d1f8      	bne.n	14b6a4 <ipcc_device_probe+0x3c>
        dprintf(ALWAYS, "failed to allocate device rproc-%d \n", conf->rproc);
  14b6b2:	f246 2064 	movw	r0, #25188	; 0x6264
  14b6b6:	f2c0 0015 	movt	r0, #21
  14b6ba:	f008 fd1d 	bl	1540f8 <_printf>
        return ERR_NO_RESOURCES;
  14b6be:	f06f 0028 	mvn.w	r0, #40	; 0x28
}
  14b6c2:	b007      	add	sp, #28
  14b6c4:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        dev = &ipcc_devices[i];
  14b6c8:	00e5      	lsls	r5, r4, #3
  14b6ca:	eba5 0804 	sub.w	r8, r5, r4
  14b6ce:	eb07 1808 	add.w	r8, r7, r8, lsl #4
            memset(dev, 0, sizeof(*dev));
  14b6d2:	2270      	movs	r2, #112	; 0x70
            dev->used = true;
  14b6d4:	1b2c      	subs	r4, r5, r4
            memset(dev, 0, sizeof(*dev));
  14b6d6:	2100      	movs	r1, #0
  14b6d8:	4640      	mov	r0, r8
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6da:	4645      	mov	r5, r8
            memset(dev, 0, sizeof(*dev));
  14b6dc:	f007 ecce 	blx	15307c <memset>
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6e0:	6830      	ldr	r0, [r6, #0]
            dev->used = true;
  14b6e2:	f04f 0901 	mov.w	r9, #1
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6e6:	6871      	ldr	r1, [r6, #4]
            dev->used = true;
  14b6e8:	eb07 1704 	add.w	r7, r7, r4, lsl #4
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6ec:	68b2      	ldr	r2, [r6, #8]
    event_init(&dev->initialized, false, EVENT_FLAG_AUTOUNSIGNAL);
  14b6ee:	f108 044c 	add.w	r4, r8, #76	; 0x4c
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6f2:	68f3      	ldr	r3, [r6, #12]
  14b6f4:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  14b6f6:	6930      	ldr	r0, [r6, #16]
    list_initialize(&dev->channels);
  14b6f8:	f108 0328 	add.w	r3, r8, #40	; 0x28
            memcpy(&dev->config, conf, sizeof(rpmsg_dev_config_t));
  14b6fc:	6971      	ldr	r1, [r6, #20]
  14b6fe:	c503      	stmia	r5!, {r0, r1}
    mutex_init(&dev->lock);
  14b700:	f108 0030 	add.w	r0, r8, #48	; 0x30
            dev->used = true;
  14b704:	f887 901c 	strb.w	r9, [r7, #28]
  14b708:	e9c8 330a 	strd	r3, r3, [r8, #40]	; 0x28
    mutex_init(&dev->lock);
  14b70c:	f003 fd24 	bl	14f158 <mutex_init>
    event_init(&dev->initialized, false, EVENT_FLAG_AUTOUNSIGNAL);
  14b710:	464a      	mov	r2, r9
  14b712:	4620      	mov	r0, r4
  14b714:	2100      	movs	r1, #0
  14b716:	f003 fc9d 	bl	14f054 <event_init>
    sprintf(thread_name, "ipcc-echod/%d", dev->config.rproc);
  14b71a:	f246 2154 	movw	r1, #25172	; 0x6254
  14b71e:	f8d8 2010 	ldr.w	r2, [r8, #16]
  14b722:	a802      	add	r0, sp, #8
  14b724:	f2c0 0115 	movt	r1, #21
  14b728:	f008 fc86 	bl	154038 <sprintf>
    dev->main_thread = thread_create(thread_name, ipcc_device_thread, dev,
  14b72c:	f240 53ec 	movw	r3, #1516	; 0x5ec
  14b730:	f24b 412d 	movw	r1, #46125	; 0xb42d
  14b734:	4642      	mov	r2, r8
  14b736:	9300      	str	r3, [sp, #0]
  14b738:	f2c0 0114 	movt	r1, #20
  14b73c:	2312      	movs	r3, #18
  14b73e:	a802      	add	r0, sp, #8
  14b740:	f003 ff76 	bl	14f630 <thread_create>
  14b744:	f8c8 0024 	str.w	r0, [r8, #36]	; 0x24
    thread_resume(dev->main_thread);
  14b748:	f003 ffc6 	bl	14f6d8 <thread_resume>
  14b74c:	4620      	mov	r0, r4
  14b74e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14b752:	f003 fc95 	bl	14f080 <event_wait_timeout>
    return 0;
  14b756:	2000      	movs	r0, #0
}
  14b758:	b007      	add	sp, #28
  14b75a:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    if (dev && dev->main_thread) {
  14b75e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
  14b762:	eb07 1303 	add.w	r3, r7, r3, lsl #4
  14b766:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  14b768:	2b00      	cmp	r3, #0
  14b76a:	d093      	beq.n	14b694 <ipcc_device_probe+0x2c>
        dprintf(0, "ipcc dev%d->%d already started \n",
  14b76c:	f7f5 f906 	bl	14097c <dcf_get_this_proc>
  14b770:	6932      	ldr	r2, [r6, #16]
  14b772:	4601      	mov	r1, r0
  14b774:	f246 2030 	movw	r0, #25136	; 0x6230
  14b778:	f2c0 0015 	movt	r0, #21
  14b77c:	f008 fcbc 	bl	1540f8 <_printf>
        return ERR_ALREADY_EXISTS;
  14b780:	f06f 000d 	mvn.w	r0, #13
  14b784:	e79d      	b.n	14b6c2 <ipcc_device_probe+0x5a>
  14b786:	bf00      	nop

0014b788 <ipcc_device_reset_cb>:
{
  14b788:	f643 03a8 	movw	r3, #14504	; 0x38a8
        rp = IPCC_RRPOC_AP2;
  14b78c:	f5b0 7f99 	cmp.w	r0, #306	; 0x132
  14b790:	f2c0 0316 	movt	r3, #22
{
  14b794:	b470      	push	{r4, r5, r6}
            rpchn->last_announced = 0;
  14b796:	f04f 0600 	mov.w	r6, #0
  14b79a:	f503 7028 	add.w	r0, r3, #672	; 0x2a0
        rp = IPCC_RRPOC_AP2;
  14b79e:	bf14      	ite	ne
  14b7a0:	2503      	movne	r5, #3
  14b7a2:	2504      	moveq	r5, #4
        if (dev->used && dev->config.rproc == rp) {
  14b7a4:	7f1a      	ldrb	r2, [r3, #28]
  14b7a6:	b112      	cbz	r2, 14b7ae <ipcc_device_reset_cb+0x26>
  14b7a8:	691a      	ldr	r2, [r3, #16]
  14b7aa:	42aa      	cmp	r2, r5
  14b7ac:	d005      	beq.n	14b7ba <ipcc_device_reset_cb+0x32>
  14b7ae:	3370      	adds	r3, #112	; 0x70
    for (i = 0;i < MAX_DEVICE_NUM;i++) {
  14b7b0:	4283      	cmp	r3, r0
  14b7b2:	d1f7      	bne.n	14b7a4 <ipcc_device_reset_cb+0x1c>
}
  14b7b4:	2000      	movs	r0, #0
  14b7b6:	bc70      	pop	{r4, r5, r6}
  14b7b8:	4770      	bx	r14
    list_for_every_entry(&dev->channels, rpchn,
  14b7ba:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  14b7bc:	f103 0428 	add.w	r4, r3, #40	; 0x28
  14b7c0:	428c      	cmp	r4, r1
  14b7c2:	f1a1 0240 	sub.w	r2, r1, #64	; 0x40
  14b7c6:	d0f2      	beq.n	14b7ae <ipcc_device_reset_cb+0x26>
        if (rpchn->announce)
  14b7c8:	f892 1098 	ldrb.w	r1, [r2, #152]	; 0x98
  14b7cc:	b109      	cbz	r1, 14b7d2 <ipcc_device_reset_cb+0x4a>
            rpchn->last_announced = 0;
  14b7ce:	f882 60a4 	strb.w	r6, [r2, #164]	; 0xa4
    list_for_every_entry(&dev->channels, rpchn,
  14b7d2:	6c51      	ldr	r1, [r2, #68]	; 0x44
  14b7d4:	428c      	cmp	r4, r1
  14b7d6:	f1a1 0240 	sub.w	r2, r1, #64	; 0x40
  14b7da:	d1f5      	bne.n	14b7c8 <ipcc_device_reset_cb+0x40>
  14b7dc:	e7e7      	b.n	14b7ae <ipcc_device_reset_cb+0x26>
  14b7de:	bf00      	nop

0014b7e0 <ipcc_channel_create>:
{
  14b7e0:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    if (!dev || !name) {
  14b7e4:	fab2 f582 	clz	r5, r2
  14b7e8:	096d      	lsrs	r5, r5, #5
  14b7ea:	2800      	cmp	r0, #0
  14b7ec:	bf08      	it	eq
  14b7ee:	2501      	moveq	r5, #1
  14b7f0:	2d00      	cmp	r5, #0
  14b7f2:	d14f      	bne.n	14b894 <ipcc_channel_create+0xb4>
  14b7f4:	4607      	mov	r7, r0
  14b7f6:	460e      	mov	r6, r1
    ichan = calloc(1, sizeof(struct ipcc_channel));
  14b7f8:	2001      	movs	r0, #1
  14b7fa:	21a8      	movs	r1, #168	; 0xa8
  14b7fc:	4690      	mov	r8, r2
  14b7fe:	4699      	mov	r9, r3
  14b800:	f007 fb5c 	bl	152ebc <calloc>
    if (!ichan) {
  14b804:	4604      	mov	r4, r0
  14b806:	2800      	cmp	r0, #0
  14b808:	d044      	beq.n	14b894 <ipcc_channel_create+0xb4>
    event_init(&ichan->initialized, false, EVENT_FLAG_AUTOUNSIGNAL);
  14b80a:	2201      	movs	r2, #1
  14b80c:	4629      	mov	r1, r5
  14b80e:	301c      	adds	r0, #28
  14b810:	f003 fc20 	bl	14f054 <event_init>
    sd_rpbuf_init_queue(&ichan->rxq);
  14b814:	f104 0068 	add.w	r0, r4, #104	; 0x68
  14b818:	f000 fcc2 	bl	14c1a0 <sd_rpbuf_init_queue>
    sem_init(&ichan->rxq_wait, 0);
  14b81c:	4629      	mov	r1, r5
  14b81e:	f104 0078 	add.w	r0, r4, #120	; 0x78
  14b822:	f004 fca7 	bl	150174 <sem_init>
    ichan->mtu = DCF_MSG_MAX_LEN;
  14b826:	2080      	movs	r0, #128	; 0x80
    ichan->state = DCF_STATE_Initializing;
  14b828:	f04f 0e01 	mov.w	r14, #1
    ichan->endpoint = rpmsg_dcf_create_ept(dev->rpmsg_dev, ichan->addr,
  14b82c:	f24b 428d 	movw	r2, #46221	; 0xb48d
    ichan->mtu = DCF_MSG_MAX_LEN;
  14b830:	61a0      	str	r0, [r4, #24]
    ichan->endpoint = rpmsg_dcf_create_ept(dev->rpmsg_dev, ichan->addr,
  14b832:	f2c0 0214 	movt	r2, #20
    ichan->rproc = dev->config.rproc;
  14b836:	6938      	ldr	r0, [r7, #16]
    ichan->endpoint = rpmsg_dcf_create_ept(dev->rpmsg_dev, ichan->addr,
  14b838:	4631      	mov	r1, r6
    ichan->last_announced = 0;
  14b83a:	f884 50a4 	strb.w	r5, [r4, #164]	; 0xa4
    ichan->endpoint = rpmsg_dcf_create_ept(dev->rpmsg_dev, ichan->addr,
  14b83e:	4623      	mov	r3, r4
    ichan->rproc = dev->config.rproc;
  14b840:	6120      	str	r0, [r4, #16]
    ichan->addr = endpoint;
  14b842:	6166      	str	r6, [r4, #20]
    ichan->parent = dev;
  14b844:	6627      	str	r7, [r4, #96]	; 0x60
    ichan->announce = announce;
  14b846:	f884 9098 	strb.w	r9, [r4, #152]	; 0x98
    ichan->state = DCF_STATE_Initializing;
  14b84a:	f8c4 e038 	str.w	r14, [r4, #56]	; 0x38
    ichan->endpoint = rpmsg_dcf_create_ept(dev->rpmsg_dev, ichan->addr,
  14b84e:	6eb8      	ldr	r0, [r7, #104]	; 0x68
  14b850:	f7ff faf6 	bl	14ae40 <rpmsg_dcf_create_ept>
  14b854:	6660      	str	r0, [r4, #100]	; 0x64
  14b856:	4605      	mov	r5, r0
    if (!ichan->endpoint) {
  14b858:	b300      	cbz	r0, 14b89c <ipcc_channel_create+0xbc>
  14b85a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    mutex_acquire(&dev->lock);
  14b85e:	f107 0530 	add.w	r5, r7, #48	; 0x30
  14b862:	4628      	mov	r0, r5
  14b864:	f003 fcb2 	bl	14f1cc <mutex_acquire_timeout>
    item->prev = list->prev;
  14b868:	4639      	mov	r1, r7
    mutex_release(&dev->lock);
  14b86a:	4628      	mov	r0, r5
    list_add_tail(&dev->channels, &ichan->node);
  14b86c:	f104 0340 	add.w	r3, r4, #64	; 0x40
  14b870:	f851 2f28 	ldr.w	r2, [r1, #40]!
    item->next = list;
  14b874:	e9c4 2110 	strd	r2, r1, [r4, #64]	; 0x40
    list->prev->next = item;
  14b878:	6053      	str	r3, [r2, #4]
    list->prev = item;
  14b87a:	62bb      	str	r3, [r7, #40]	; 0x28
    mutex_release(&dev->lock);
  14b87c:	f003 fcd2 	bl	14f224 <mutex_release>
    strncpy(ichan->name, name, 16);
  14b880:	4641      	mov	r1, r8
  14b882:	2210      	movs	r2, #16
  14b884:	4620      	mov	r0, r4
  14b886:	f008 fcb5 	bl	1541f4 <strncpy>
    ichan->state = DCF_STATE_Initialized;
  14b88a:	2302      	movs	r3, #2
  14b88c:	63a3      	str	r3, [r4, #56]	; 0x38
}
  14b88e:	4620      	mov	r0, r4
  14b890:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        return NULL;
  14b894:	2400      	movs	r4, #0
}
  14b896:	4620      	mov	r0, r4
  14b898:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
  14b89c:	4621      	mov	r1, r4
  14b89e:	f107 0068 	add.w	r0, r7, #104	; 0x68
  14b8a2:	f7ff fe25 	bl	14b4f0 <release_channel.isra.2.part.3>
    return NULL;
  14b8a6:	462c      	mov	r4, r5
  14b8a8:	e7f1      	b.n	14b88e <ipcc_channel_create+0xae>
  14b8aa:	bf00      	nop

0014b8ac <ipcc_channel_destroy>:
{
  14b8ac:	b570      	push	{r4, r5, r6, r14}
    struct ipcc_device *dev = ichan->parent;
  14b8ae:	6e05      	ldr	r5, [r0, #96]	; 0x60
{
  14b8b0:	4604      	mov	r4, r0
  14b8b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    mutex_acquire(&dev->lock);
  14b8b6:	f105 0630 	add.w	r6, r5, #48	; 0x30
  14b8ba:	4630      	mov	r0, r6
  14b8bc:	f003 fc86 	bl	14f1cc <mutex_acquire_timeout>
    item->next->prev = item->prev;
  14b8c0:	e9d4 1210 	ldrd	r1, r2, [r4, #64]	; 0x40
    item->prev = item->next = 0;
  14b8c4:	2300      	movs	r3, #0
    mutex_release(&dev->lock);
  14b8c6:	4630      	mov	r0, r6
    item->next->prev = item->prev;
  14b8c8:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
  14b8ca:	6c21      	ldr	r1, [r4, #64]	; 0x40
  14b8cc:	604a      	str	r2, [r1, #4]
    item->prev = item->next = 0;
  14b8ce:	e9c4 3310 	strd	r3, r3, [r4, #64]	; 0x40
  14b8d2:	f003 fca7 	bl	14f224 <mutex_release>
  14b8d6:	4621      	mov	r1, r4
  14b8d8:	f105 0068 	add.w	r0, r5, #104	; 0x68
}
  14b8dc:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
  14b8e0:	f7ff be06 	b.w	14b4f0 <release_channel.isra.2.part.3>

0014b8e4 <ipcc_channel_start>:
{
  14b8e4:	b530      	push	{r4, r5, r14}
  14b8e6:	4604      	mov	r4, r0
  14b8e8:	b083      	sub	sp, #12
    struct ipcc_device *dev = ichan->parent;
  14b8ea:	6e05      	ldr	r5, [r0, #96]	; 0x60
    if (handler) {
  14b8ec:	b309      	cbz	r1, 14b932 <ipcc_channel_start+0x4e>
  14b8ee:	460b      	mov	r3, r1
        thread_resume(thread_create(ichan->name, looper_thread, ichan,
  14b8f0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  14b8f4:	f24b 514d 	movw	r1, #46413	; 0xb54d
        ichan->msg_handler = handler;
  14b8f8:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
        thread_resume(thread_create(ichan->name, looper_thread, ichan,
  14b8fc:	f2c0 0114 	movt	r1, #20
  14b900:	9200      	str	r2, [sp, #0]
  14b902:	2312      	movs	r3, #18
  14b904:	4602      	mov	r2, r0
  14b906:	f003 fe93 	bl	14f630 <thread_create>
  14b90a:	f003 fee5 	bl	14f6d8 <thread_resume>
  14b90e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14b912:	f104 001c 	add.w	r0, r4, #28
  14b916:	f003 fbb3 	bl	14f080 <event_wait_timeout>
    if (ichan->announce)
  14b91a:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
  14b91e:	b12b      	cbz	r3, 14b92c <ipcc_channel_start+0x48>
        rpmsg_dcf_ns_announce(dev->rpmsg_dev, ichan->endpoint, ichan->name, DCF_NS_CREATE);
  14b920:	6ea8      	ldr	r0, [r5, #104]	; 0x68
  14b922:	2300      	movs	r3, #0
  14b924:	6e61      	ldr	r1, [r4, #100]	; 0x64
  14b926:	4622      	mov	r2, r4
  14b928:	f7ff fca0 	bl	14b26c <rpmsg_dcf_ns_announce>
}
  14b92c:	2000      	movs	r0, #0
  14b92e:	b003      	add	sp, #12
  14b930:	bd30      	pop	{r4, r5, r15}
        ichan->state = DCF_STATE_Connected;
  14b932:	2305      	movs	r3, #5
  14b934:	6383      	str	r3, [r0, #56]	; 0x38
  14b936:	e7f0      	b.n	14b91a <ipcc_channel_start+0x36>

0014b938 <ipcc_channel_stop>:
{
  14b938:	b510      	push	{r4, r14}
    if (ichan->announce)
  14b93a:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
{
  14b93e:	4604      	mov	r4, r0
    if (ichan->announce)
  14b940:	b9bb      	cbnz	r3, 14b972 <ipcc_channel_stop+0x3a>
        if (ichan->looper) {
  14b942:	6be3      	ldr	r3, [r4, #60]	; 0x3c
        ichan->state = DCF_STATE_Closing;
  14b944:	2203      	movs	r2, #3
  14b946:	63a2      	str	r2, [r4, #56]	; 0x38
        if (ichan->looper) {
  14b948:	b18b      	cbz	r3, 14b96e <ipcc_channel_stop+0x36>
            thread_sleep(100);
  14b94a:	2064      	movs	r0, #100	; 0x64
  14b94c:	f003 ff70 	bl	14f830 <thread_sleep>
            ipcc_channel_rx_cb(NULL, 0, DCF_ADDR_ANY, ichan);
  14b950:	2100      	movs	r1, #0
  14b952:	4623      	mov	r3, r4
  14b954:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  14b958:	4608      	mov	r0, r1
  14b95a:	f7ff fd97 	bl	14b48c <ipcc_channel_rx_cb>
            thread_join(ichan->looper, NULL, 1000);
  14b95e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  14b962:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  14b964:	2100      	movs	r1, #0
  14b966:	f004 f833 	bl	14f9d0 <thread_join>
            ichan->looper = NULL;
  14b96a:	2300      	movs	r3, #0
  14b96c:	63e3      	str	r3, [r4, #60]	; 0x3c
}
  14b96e:	2000      	movs	r0, #0
  14b970:	bd10      	pop	{r4, r15}
        rpmsg_dcf_ns_announce(dev->rpmsg_dev, ichan->endpoint, ichan->name, DCF_NS_DESTROY);
  14b972:	6e00      	ldr	r0, [r0, #96]	; 0x60
  14b974:	2301      	movs	r3, #1
  14b976:	6e61      	ldr	r1, [r4, #100]	; 0x64
  14b978:	4622      	mov	r2, r4
  14b97a:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14b97c:	f7ff fc76 	bl	14b26c <rpmsg_dcf_ns_announce>
  14b980:	e7df      	b.n	14b942 <ipcc_channel_stop+0xa>
  14b982:	bf00      	nop

0014b984 <ipcc_channel_sendto>:
    if (!ichan)
  14b984:	b1e8      	cbz	r0, 14b9c2 <ipcc_channel_sendto+0x3e>
{
  14b986:	b530      	push	{r4, r5, r14}
  14b988:	461d      	mov	r5, r3
  14b98a:	4613      	mov	r3, r2
  14b98c:	460a      	mov	r2, r1
  14b98e:	b083      	sub	sp, #12
    if (ichan->parent && ichan->parent->rpmsg_dev)
  14b990:	6e01      	ldr	r1, [r0, #96]	; 0x60
  14b992:	4604      	mov	r4, r0
  14b994:	b149      	cbz	r1, 14b9aa <ipcc_channel_sendto+0x26>
  14b996:	6e88      	ldr	r0, [r1, #104]	; 0x68
  14b998:	b138      	cbz	r0, 14b9aa <ipcc_channel_sendto+0x26>
        return rpmsg_dcf_send(ichan->parent->rpmsg_dev, ichan->endpoint,
  14b99a:	6e61      	ldr	r1, [r4, #100]	; 0x64
  14b99c:	9c06      	ldr	r4, [sp, #24]
  14b99e:	e9cd 5400 	strd	r5, r4, [r13]
  14b9a2:	f7ff fb51 	bl	14b048 <rpmsg_dcf_send>
}
  14b9a6:	b003      	add	sp, #12
  14b9a8:	bd30      	pop	{r4, r5, r15}
    dprintf(0, "ipcc: channel %s sendto failed\n", ichan->name);
  14b9aa:	f246 2010 	movw	r0, #25104	; 0x6210
  14b9ae:	4621      	mov	r1, r4
  14b9b0:	f2c0 0015 	movt	r0, #21
  14b9b4:	f008 fba0 	bl	1540f8 <_printf>
    return DCF_NOT_READY;
  14b9b8:	f64e 4071 	movw	r0, #60529	; 0xec71
  14b9bc:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14b9c0:	e7f1      	b.n	14b9a6 <ipcc_channel_sendto+0x22>
        return DCF_ERR_DEV_ID;
  14b9c2:	f64e 4074 	movw	r0, #60532	; 0xec74
  14b9c6:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14b9ca:	4770      	bx	r14

0014b9cc <ipcc_channel_recvfrom>:
}

int ipcc_channel_recvfrom(struct ipcc_channel *ichan, unsigned long *src,
                            char *data, int *len, lk_time_t timeout)
{
  14b9cc:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14b9d0:	f8dd c018 	ldr.w	r12, [r13, #24]
    status_t ret = 0;

    if (!ichan || !ichan->parent)
  14b9d4:	b1d0      	cbz	r0, 14ba0c <ipcc_channel_recvfrom+0x40>
  14b9d6:	6e07      	ldr	r7, [r0, #96]	; 0x60
  14b9d8:	b1c7      	cbz	r7, 14ba0c <ipcc_channel_recvfrom+0x40>
        return DCF_ERR_DEV_ID;

    if (!len || (*len == 0)) {
  14b9da:	b18b      	cbz	r3, 14ba00 <ipcc_channel_recvfrom+0x34>
  14b9dc:	681c      	ldr	r4, [r3, #0]
  14b9de:	b17c      	cbz	r4, 14ba00 <ipcc_channel_recvfrom+0x34>
  14b9e0:	460d      	mov	r5, r1
    rpbuf = recv_rpbuf_timed(ichan, timeout);
  14b9e2:	4661      	mov	r1, r12
  14b9e4:	461c      	mov	r4, r3
  14b9e6:	4616      	mov	r6, r2
    struct rpmsg_dcf_instance *rpmsg_dev = ichan->parent->rpmsg_dev;
  14b9e8:	6ebf      	ldr	r7, [r7, #104]	; 0x68
    rpbuf = recv_rpbuf_timed(ichan, timeout);
  14b9ea:	f7ff fd09 	bl	14b400 <recv_rpbuf_timed>
    return rpmsg_dcf_copy_payload(rpmsg_dev, rpbuf, src, data, len);
  14b9ee:	9406      	str	r4, [sp, #24]
  14b9f0:	4633      	mov	r3, r6
  14b9f2:	462a      	mov	r2, r5
  14b9f4:	4601      	mov	r1, r0
  14b9f6:	4638      	mov	r0, r7

    ret = recvfrom_timed(ichan, src, data, len, timeout);

    dprintf(INFO, "%s rx data, cbuf %d\n", __func__, (uint32_t)*len);
    return ret;
}
  14b9f8:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
    return rpmsg_dcf_copy_payload(rpmsg_dev, rpbuf, src, data, len);
  14b9fc:	f7ff bb5e 	b.w	14b0bc <rpmsg_dcf_copy_payload>
        return DCF_ERR_PARAM;
  14ba00:	f64e 4075 	movw	r0, #60533	; 0xec75
  14ba04:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14ba08:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return DCF_ERR_DEV_ID;
  14ba0c:	f64e 4074 	movw	r0, #60532	; 0xec74
  14ba10:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14ba14:	e7f8      	b.n	14ba08 <ipcc_channel_recvfrom+0x3c>
  14ba16:	bf00      	nop

0014ba18 <ipcc_channel_recvbuf>:

sd_rpbuf_t *ipcc_channel_recvbuf(struct ipcc_channel *ichan, lk_time_t timeout)
{
    if (!ichan || !ichan->parent)
  14ba18:	b118      	cbz	r0, 14ba22 <ipcc_channel_recvbuf+0xa>
  14ba1a:	6e03      	ldr	r3, [r0, #96]	; 0x60
  14ba1c:	b10b      	cbz	r3, 14ba22 <ipcc_channel_recvbuf+0xa>
        return NULL;

    return recv_rpbuf_timed(ichan, timeout);
  14ba1e:	f7ff bcef 	b.w	14b400 <recv_rpbuf_timed>
}
  14ba22:	2000      	movs	r0, #0
  14ba24:	4770      	bx	r14
  14ba26:	bf00      	nop

0014ba28 <ipcc_device_import_rpbuf>:

void *ipcc_device_import_rpbuf(struct ipcc_device *dev, sd_rpbuf_t *rpbuf,
                    unsigned long *src, int *len)
{
    dprintf(2, "%s ptr=%p\n", __func__, rpbuf);
    return rpmsg_dcf_import_buffer(dev->rpmsg_dev, rpbuf, src, len);
  14ba28:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14ba2a:	f7ff bb33 	b.w	14b094 <rpmsg_dcf_import_buffer>
  14ba2e:	bf00      	nop

0014ba30 <ipcc_device_release_rpbuf>:
}

int ipcc_device_release_rpbuf(struct ipcc_device *dev, sd_rpbuf_t *rpbuf)
{
    dprintf(2, "%s ptr=%p\n", __func__, rpbuf);
    return rpmsg_dcf_release_rpbuf(dev->rpmsg_dev, rpbuf);
  14ba30:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14ba32:	f7ff bb71 	b.w	14b118 <rpmsg_dcf_release_rpbuf>
  14ba36:	bf00      	nop

0014ba38 <ipcc_rpc_server_ping>:
    result.result[0] = req->param[0];
    result.result[1] = req->param[1];
    result.result[2] = req->param[2];
    result.result[3] = req->param[3];

    return result;
  14ba38:	f241 0101 	movw	r1, #4097	; 0x1001
{
  14ba3c:	b430      	push	{r4, r5}
    result.result[0] = req->param[0];
  14ba3e:	68d4      	ldr	r4, [r2, #12]
    return result;
  14ba40:	2500      	movs	r5, #0
  14ba42:	6104      	str	r4, [r0, #16]
  14ba44:	6081      	str	r1, [r0, #8]
    result.result[1] = req->param[1];
  14ba46:	6914      	ldr	r4, [r2, #16]
    result.result[3] = req->param[3];
  14ba48:	e9d2 1205 	ldrd	r1, r2, [r2, #20]
    return result;
  14ba4c:	60c5      	str	r5, [r0, #12]
  14ba4e:	e9c0 4105 	strd	r4, r1, [r0, #20]
  14ba52:	61c2      	str	r2, [r0, #28]
}
  14ba54:	bc30      	pop	{r4, r5}
  14ba56:	4770      	bx	r14

0014ba58 <ipcc_rpc_server_gettimeofday>:

rpc_call_result_t ipcc_rpc_server_gettimeofday(rpc_server_handle_t handle, rpc_call_request_t *req)
{
  14ba58:	b538      	push	{r3, r4, r5, r14}
  14ba5a:	4604      	mov	r4, r0
    rpc_call_result_t result;

    result.ack = IPCC_RPC_ACK_GETTIMEOFDAY;
    result.retcode = NO_ERROR;
    result.result[0] = current_time();
  14ba5c:	f7f4 ff80 	bl	140960 <current_time>
    result.result[1] = 0x00008800;
    result.result[2] = 0x00880000;
    result.result[3] = 0x88000000;

    return result;
  14ba60:	f241 0303 	movw	r3, #4099	; 0x1003
  14ba64:	2500      	movs	r5, #0
  14ba66:	f44f 4108 	mov.w	r1, #34816	; 0x8800
  14ba6a:	f44f 0208 	mov.w	r2, #8912896	; 0x880000
  14ba6e:	60a3      	str	r3, [r4, #8]
  14ba70:	f04f 4308 	mov.w	r3, #2281701376	; 0x88000000
  14ba74:	60e5      	str	r5, [r4, #12]
  14ba76:	e9c4 1205 	strd	r1, r2, [r4, #20]
  14ba7a:	61e3      	str	r3, [r4, #28]
  14ba7c:	6120      	str	r0, [r4, #16]
}
  14ba7e:	4620      	mov	r0, r4
  14ba80:	bd38      	pop	{r3, r4, r5, r15}
  14ba82:	bf00      	nop

0014ba84 <ipcc_rpc_client_init>:
{
  14ba84:	b570      	push	{r4, r5, r6, r14}
  14ba86:	4614      	mov	r4, r2
  14ba88:	460d      	mov	r5, r1
    ichan = ipcc_channel_create(dev, client_id, "rpc-client", false);
  14ba8a:	f246 3288 	movw	r2, #25480	; 0x6388
  14ba8e:	4621      	mov	r1, r4
{
  14ba90:	461e      	mov	r6, r3
  14ba92:	4604      	mov	r4, r0
    ichan = ipcc_channel_create(dev, client_id, "rpc-client", false);
  14ba94:	2300      	movs	r3, #0
  14ba96:	4628      	mov	r0, r5
  14ba98:	f2c0 0215 	movt	r2, #21
  14ba9c:	f7ff fea0 	bl	14b7e0 <ipcc_channel_create>
    if (!ichan) {
  14baa0:	b138      	cbz	r0, 14bab2 <ipcc_rpc_client_init+0x2e>
  14baa2:	4605      	mov	r5, r0
    ipcc_channel_start(ichan, NULL);
  14baa4:	2100      	movs	r1, #0
  14baa6:	f7ff ff1d 	bl	14b8e4 <ipcc_channel_start>
    return 0;
  14baaa:	2000      	movs	r0, #0
    hclient->service_id = server_id;
  14baac:	e9c4 6500 	strd	r6, r5, [r4]
}
  14bab0:	bd70      	pop	{r4, r5, r6, r15}
        free(hclient);
  14bab2:	4620      	mov	r0, r4
  14bab4:	f007 fa22 	bl	152efc <free>
        dprintf(0, "rpc: No channel available for client\n");
  14bab8:	f246 3094 	movw	r0, #25492	; 0x6394
  14babc:	f2c0 0015 	movt	r0, #21
  14bac0:	f008 fb1a 	bl	1540f8 <_printf>
        return ERR_NO_RESOURCES;
  14bac4:	f06f 0028 	mvn.w	r0, #40	; 0x28
}
  14bac8:	bd70      	pop	{r4, r5, r6, r15}
  14baca:	bf00      	nop

0014bacc <ipcc_rpc_client_call>:
{
  14bacc:	b5f0      	push	{r4, r5, r6, r7, r14}
    int ret_size = sizeof(rpc_call_result_t);
  14bace:	2520      	movs	r5, #32
{
  14bad0:	b085      	sub	sp, #20
    int ret_size = sizeof(rpc_call_result_t);
  14bad2:	9502      	str	r5, [sp, #8]
    if (!hclient || !hclient->rpchan)
  14bad4:	b388      	cbz	r0, 14bb3a <ipcc_rpc_client_call+0x6e>
  14bad6:	6846      	ldr	r6, [r0, #4]
  14bad8:	b37e      	cbz	r6, 14bb3a <ipcc_rpc_client_call+0x6e>
  14bada:	4605      	mov	r5, r0
  14badc:	461c      	mov	r4, r3
  14bade:	4617      	mov	r7, r2
  14bae0:	460a      	mov	r2, r1
    ret = ipcc_channel_sendto(hclient->rpchan, hclient->service_id,
  14bae2:	6801      	ldr	r1, [r0, #0]
  14bae4:	4630      	mov	r0, r6
  14bae6:	9300      	str	r3, [sp, #0]
  14bae8:	232c      	movs	r3, #44	; 0x2c
  14baea:	f7ff ff4b 	bl	14b984 <ipcc_channel_sendto>
    if (ret < 0) {
  14baee:	1e06      	subs	r6, r0, #0
  14baf0:	db0f      	blt.n	14bb12 <ipcc_rpc_client_call+0x46>
    ret = ipcc_channel_recvfrom(hclient->rpchan, &src, (char*)result, &ret_size, timeout);
  14baf2:	6868      	ldr	r0, [r5, #4]
  14baf4:	463a      	mov	r2, r7
  14baf6:	9400      	str	r4, [sp, #0]
  14baf8:	ab02      	add	r3, sp, #8
  14bafa:	a903      	add	r1, sp, #12
  14bafc:	f7ff ff66 	bl	14b9cc <ipcc_channel_recvfrom>
    if (ret < 0) {
  14bb00:	1e06      	subs	r6, r0, #0
  14bb02:	db10      	blt.n	14bb26 <ipcc_rpc_client_call+0x5a>
    if (hclient->service_id != src) {
  14bb04:	682a      	ldr	r2, [r5, #0]
  14bb06:	9903      	ldr	r1, [sp, #12]
  14bb08:	428a      	cmp	r2, r1
  14bb0a:	d11b      	bne.n	14bb44 <ipcc_rpc_client_call+0x78>
}
  14bb0c:	4630      	mov	r0, r6
  14bb0e:	b005      	add	sp, #20
  14bb10:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "rpc: ipcc send channel failed: ret: %d\n", ret);
  14bb12:	f246 301c 	movw	r0, #25372	; 0x631c
  14bb16:	4631      	mov	r1, r6
  14bb18:	f2c0 0015 	movt	r0, #21
  14bb1c:	f008 faec 	bl	1540f8 <_printf>
}
  14bb20:	4630      	mov	r0, r6
  14bb22:	b005      	add	sp, #20
  14bb24:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "rpc: rx failed ret: %d\n", ret);
  14bb26:	f246 3044 	movw	r0, #25412	; 0x6344
  14bb2a:	4631      	mov	r1, r6
  14bb2c:	f2c0 0015 	movt	r0, #21
  14bb30:	f008 fae2 	bl	1540f8 <_printf>
}
  14bb34:	4630      	mov	r0, r6
  14bb36:	b005      	add	sp, #20
  14bb38:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return DCF_ERR_DEV_ID;
  14bb3a:	f64e 4674 	movw	r6, #60532	; 0xec74
  14bb3e:	f6cf 76ff 	movt	r6, #65535	; 0xffff
  14bb42:	e7e3      	b.n	14bb0c <ipcc_rpc_client_call+0x40>
        dprintf(0, "rpc: Data from %ld != expected %d, discard\n", src, hclient->service_id);
  14bb44:	f246 305c 	movw	r0, #25436	; 0x635c
        return DCF_ERR_BAD_SRVID;
  14bb48:	f64e 466f 	movw	r6, #60527	; 0xec6f
        dprintf(0, "rpc: Data from %ld != expected %d, discard\n", src, hclient->service_id);
  14bb4c:	f2c0 0015 	movt	r0, #21
  14bb50:	f008 fad2 	bl	1540f8 <_printf>
        return DCF_ERR_BAD_SRVID;
  14bb54:	f6cf 76ff 	movt	r6, #65535	; 0xffff
  14bb58:	e7d8      	b.n	14bb0c <ipcc_rpc_client_call+0x40>
  14bb5a:	bf00      	nop

0014bb5c <find_func_implement>:

/* Try to find a RPC implement functions registered in the RPC service */
rpc_server_func_t find_func_implement(rpc_server_handle_t handle, u32 command)
{
    unsigned int i;
    rpc_server_impl_t *caller = &s_rpc_default_funcs[0];
  14bb5c:	f640 53a0 	movw	r3, #3488	; 0xda0
  14bb60:	f2c0 0316 	movt	r3, #22
{
  14bb64:	b410      	push	{r4}

    /* firstly find builtin functions */
    for (i = 0; i < ARRAY_SIZE(s_rpc_default_funcs); i++,  caller++) {
  14bb66:	f103 04c0 	add.w	r4, r3, #192	; 0xc0
  14bb6a:	e002      	b.n	14bb72 <find_func_implement+0x16>
  14bb6c:	330c      	adds	r3, #12
  14bb6e:	42a3      	cmp	r3, r4
  14bb70:	d006      	beq.n	14bb80 <find_func_implement+0x24>
        if (caller->command == command) {
  14bb72:	681a      	ldr	r2, [r3, #0]
  14bb74:	428a      	cmp	r2, r1
  14bb76:	d1f9      	bne.n	14bb6c <find_func_implement+0x10>
    /* then find user registered functions */
    if(handle->func_table) {
        caller = handle->func_table;
        for (i = 0; i < handle->func_used; i++, caller++) {
            if (caller->command == command) {
                return caller->func;
  14bb78:	6858      	ldr	r0, [r3, #4]
            }
        }
    }

    return NULL;
}
  14bb7a:	f85d 4b04 	ldr.w	r4, [r13], #4
  14bb7e:	4770      	bx	r14
    if(handle->func_table) {
  14bb80:	6903      	ldr	r3, [r0, #16]
  14bb82:	b19b      	cbz	r3, 14bbac <find_func_implement+0x50>
        for (i = 0; i < handle->func_used; i++, caller++) {
  14bb84:	6980      	ldr	r0, [r0, #24]
  14bb86:	2800      	cmp	r0, #0
  14bb88:	d0f7      	beq.n	14bb7a <find_func_implement+0x1e>
            if (caller->command == command) {
  14bb8a:	681a      	ldr	r2, [r3, #0]
  14bb8c:	428a      	cmp	r2, r1
  14bb8e:	d0f3      	beq.n	14bb78 <find_func_implement+0x1c>
        for (i = 0; i < handle->func_used; i++, caller++) {
  14bb90:	2200      	movs	r2, #0
  14bb92:	e002      	b.n	14bb9a <find_func_implement+0x3e>
            if (caller->command == command) {
  14bb94:	681c      	ldr	r4, [r3, #0]
  14bb96:	42a1      	cmp	r1, r4
  14bb98:	d0ee      	beq.n	14bb78 <find_func_implement+0x1c>
        for (i = 0; i < handle->func_used; i++, caller++) {
  14bb9a:	3201      	adds	r2, #1
  14bb9c:	4290      	cmp	r0, r2
  14bb9e:	f103 030c 	add.w	r3, r3, #12
  14bba2:	d1f7      	bne.n	14bb94 <find_func_implement+0x38>
}
  14bba4:	f85d 4b04 	ldr.w	r4, [r13], #4
    return NULL;
  14bba8:	2000      	movs	r0, #0
}
  14bbaa:	4770      	bx	r14
    return NULL;
  14bbac:	4618      	mov	r0, r3
  14bbae:	e7e4      	b.n	14bb7a <find_func_implement+0x1e>

0014bbb0 <rpc_server_dispatch>:

    dprintf(1, "rpc: reply cmd: 0x%x to %d done\n", req->cmd, src);
}

static void rpc_server_dispatch(struct ipcc_channel *chan, struct dcf_message *mssg, int len, int src)
{
  14bbb0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    rpc_server_handle_t handle = ipcc_channel_get_context(chan);
  14bbb4:	f8d0 7094 	ldr.w	r7, [r0, #148]	; 0x94
{
  14bbb8:	b09e      	sub	sp, #120	; 0x78
    rpc_call_request_t request;

    ASSERT(handle);
  14bbba:	2f00      	cmp	r7, #0
  14bbbc:	d047      	beq.n	14bc4e <rpc_server_dispatch+0x9e>
    ASSERT(mssg);
  14bbbe:	2900      	cmp	r1, #0
  14bbc0:	d056      	beq.n	14bc70 <rpc_server_dispatch+0xc0>
    ASSERT(len == sizeof(rpc_call_request_t));
  14bbc2:	2a2c      	cmp	r2, #44	; 0x2c
    memcpy(&request, mssg, len);
  14bbc4:	bf01      	itttt	eq
  14bbc6:	460c      	moveq	r4, r1
  14bbc8:	4698      	moveq	r8, r3
  14bbca:	f104 0c20 	addeq.w	r12, r4, #32
  14bbce:	ae13      	addeq	r6, sp, #76	; 0x4c
    ASSERT(len == sizeof(rpc_call_request_t));
  14bbd0:	d15f      	bne.n	14bc92 <rpc_server_dispatch+0xe2>
    memcpy(&request, mssg, len);
  14bbd2:	6820      	ldr	r0, [r4, #0]
  14bbd4:	3410      	adds	r4, #16
  14bbd6:	f854 1c0c 	ldr.w	r1, [r4, #-12]
  14bbda:	4635      	mov	r5, r6
  14bbdc:	f854 2c08 	ldr.w	r2, [r4, #-8]
  14bbe0:	3610      	adds	r6, #16
  14bbe2:	f854 3c04 	ldr.w	r3, [r4, #-4]
  14bbe6:	4564      	cmp	r4, r12
  14bbe8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  14bbea:	d1f2      	bne.n	14bbd2 <rpc_server_dispatch+0x22>
  14bbec:	6820      	ldr	r0, [r4, #0]
  14bbee:	6861      	ldr	r1, [r4, #4]
  14bbf0:	68a2      	ldr	r2, [r4, #8]
  14bbf2:	c607      	stmia	r6!, {r0, r1, r2}

    dprintf(1, "rpc: Receive cmd: 0x%x from %d\n", request.cmd, src);

    if (handle->status == IPCC_RPC_S_RUNNING) {
  14bbf4:	68fb      	ldr	r3, [r7, #12]
  14bbf6:	2b01      	cmp	r3, #1
  14bbf8:	d002      	beq.n	14bc00 <rpc_server_dispatch+0x50>
        ipcc_rpc_server_call_reply(handle, &request, src);
    }
}
  14bbfa:	b01e      	add	sp, #120	; 0x78
  14bbfc:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    func = find_func_implement(handle, req->cmd);
  14bc00:	9c15      	ldr	r4, [sp, #84]	; 0x54
  14bc02:	4638      	mov	r0, r7
  14bc04:	4621      	mov	r1, r4
  14bc06:	f7ff ffa9 	bl	14bb5c <find_func_implement>
    if (func) {
  14bc0a:	4603      	mov	r3, r0
  14bc0c:	2800      	cmp	r0, #0
  14bc0e:	d051      	beq.n	14bcb4 <rpc_server_dispatch+0x104>
        reply = func(handle, req);
  14bc10:	ac02      	add	r4, sp, #8
  14bc12:	aa13      	add	r2, sp, #76	; 0x4c
  14bc14:	4639      	mov	r1, r7
  14bc16:	a802      	add	r0, sp, #8
  14bc18:	4798      	blx	r3
  14bc1a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14bc1c:	ae0b      	add	r6, sp, #44	; 0x2c
  14bc1e:	4635      	mov	r5, r6
  14bc20:	c50f      	stmia	r5!, {r0, r1, r2, r3}
  14bc22:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
  14bc26:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
    ret = ipcc_channel_sendto(handle->rpchan, src,
  14bc2a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  14bc2e:	4641      	mov	r1, r8
  14bc30:	68b8      	ldr	r0, [r7, #8]
  14bc32:	4632      	mov	r2, r6
  14bc34:	9400      	str	r4, [sp, #0]
  14bc36:	2320      	movs	r3, #32
  14bc38:	f7ff fea4 	bl	14b984 <ipcc_channel_sendto>
    if (ret < 0) {
  14bc3c:	1e01      	subs	r1, r0, #0
  14bc3e:	dadc      	bge.n	14bbfa <rpc_server_dispatch+0x4a>
        dprintf(0, "rpc: reply failed: ret: %d\n", ret);
  14bc40:	f246 5024 	movw	r0, #25892	; 0x6524
  14bc44:	f2c0 0015 	movt	r0, #21
  14bc48:	f008 fa56 	bl	1540f8 <_printf>
  14bc4c:	e7d5      	b.n	14bbfa <rpc_server_dispatch+0x4a>
    ASSERT(handle);
  14bc4e:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14bc52:	f246 42a0 	movw	r2, #25760	; 0x64a0
  14bc56:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14bc5a:	f2c0 0315 	movt	r3, #21
  14bc5e:	4670      	mov	r0, r14
  14bc60:	f2c0 0215 	movt	r2, #21
  14bc64:	9300      	str	r3, [sp, #0]
  14bc66:	f2c0 0115 	movt	r1, #21
  14bc6a:	23ce      	movs	r3, #206	; 0xce
  14bc6c:	f007 f822 	bl	152cb4 <_panic>
    ASSERT(mssg);
  14bc70:	f246 43d0 	movw	r3, #25808	; 0x64d0
  14bc74:	f246 42a0 	movw	r2, #25760	; 0x64a0
  14bc78:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14bc7c:	f2c0 0315 	movt	r3, #21
  14bc80:	4670      	mov	r0, r14
  14bc82:	f2c0 0215 	movt	r2, #21
  14bc86:	9300      	str	r3, [sp, #0]
  14bc88:	f2c0 0115 	movt	r1, #21
  14bc8c:	23cf      	movs	r3, #207	; 0xcf
  14bc8e:	f007 f811 	bl	152cb4 <_panic>
    ASSERT(len == sizeof(rpc_call_request_t));
  14bc92:	f246 43d8 	movw	r3, #25816	; 0x64d8
  14bc96:	f246 42a0 	movw	r2, #25760	; 0x64a0
  14bc9a:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14bc9e:	f2c0 0315 	movt	r3, #21
  14bca2:	4670      	mov	r0, r14
  14bca4:	f2c0 0215 	movt	r2, #21
  14bca8:	9300      	str	r3, [sp, #0]
  14bcaa:	f2c0 0115 	movt	r1, #21
  14bcae:	23d0      	movs	r3, #208	; 0xd0
  14bcb0:	f007 f800 	bl	152cb4 <_panic>
        dprintf(0, "rpc: Not found, cmd=0x%x from %d:%d\n",
  14bcb4:	687a      	ldr	r2, [r7, #4]
  14bcb6:	f246 40fc 	movw	r0, #25852	; 0x64fc
  14bcba:	4643      	mov	r3, r8
  14bcbc:	f2c0 0015 	movt	r0, #21
  14bcc0:	ae0b      	add	r6, sp, #44	; 0x2c
  14bcc2:	6912      	ldr	r2, [r2, #16]
  14bcc4:	f008 fa18 	bl	1540f8 <_printf>
        reply = ipcc_rpc_server_nofunc(handle, req);
  14bcc8:	9b15      	ldr	r3, [sp, #84]	; 0x54
  14bcca:	f06f 021a 	mvn.w	r2, #26
  14bcce:	e9cd 320d 	strd	r3, r2, [r13, #52]	; 0x34
  14bcd2:	e7aa      	b.n	14bc2a <rpc_server_dispatch+0x7a>

0014bcd4 <ipcc_rpc_server_init>:

int ipcc_rpc_server_init(rpc_server_handle_t handle,
                        struct ipcc_device *dev, int server_id, int threads)
{
  14bcd4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (!dev) {
  14bcd6:	b379      	cbz	r1, 14bd38 <ipcc_rpc_server_init+0x64>
  14bcd8:	4604      	mov	r4, r0
  14bcda:	461d      	mov	r5, r3
        dprintf(0, "Bad ipcc device handle\n");
        return ERR_INVALID_ARGS;
    }

    handle->rpdev = dev;
    handle->status = IPCC_RPC_S_STOPPED;
  14bcdc:	2300      	movs	r3, #0
  14bcde:	4617      	mov	r7, r2
    handle->rpdev = dev;
  14bce0:	6041      	str	r1, [r0, #4]
    handle->rpchan = ipcc_channel_create(dev, server_id, IPCC_RPCS_CHN_NAME, true);
  14bce2:	f246 32d4 	movw	r2, #25556	; 0x63d4
  14bce6:	4608      	mov	r0, r1
  14bce8:	f2c0 0215 	movt	r2, #21
    handle->status = IPCC_RPC_S_STOPPED;
  14bcec:	60e3      	str	r3, [r4, #12]
    handle->rpchan = ipcc_channel_create(dev, server_id, IPCC_RPCS_CHN_NAME, true);
  14bcee:	4639      	mov	r1, r7
  14bcf0:	2301      	movs	r3, #1
  14bcf2:	f7ff fd75 	bl	14b7e0 <ipcc_channel_create>
  14bcf6:	60a0      	str	r0, [r4, #8]
  14bcf8:	4606      	mov	r6, r0
    if (!handle->rpchan) {
  14bcfa:	b380      	cbz	r0, 14bd5e <ipcc_rpc_server_init+0x8a>
        dprintf(0, "rpc: No channel available\n");
        return ERR_NO_RESOURCES;
    }

    if (threads) {
  14bcfc:	b99d      	cbnz	r5, 14bd26 <ipcc_rpc_server_init+0x52>
        dprintf(0, "rpc: Thread mode is not supported yet!\n");
        return ERR_NOT_IMPLEMENTED;
    }

    handle->func_max = IPC_RPC_DEFAULT_FUNCS;
  14bcfe:	2310      	movs	r3, #16
    handle->func_used = 0;
    handle->func_table = malloc(IPC_RPC_DEFAULT_FUNCS * sizeof(rpc_server_impl_t));
  14bd00:	20c0      	movs	r0, #192	; 0xc0
    handle->func_max = IPC_RPC_DEFAULT_FUNCS;
  14bd02:	e9c4 3505 	strd	r3, r5, [r4, #20]
    handle->func_table = malloc(IPC_RPC_DEFAULT_FUNCS * sizeof(rpc_server_impl_t));
  14bd06:	f007 f8c3 	bl	152e90 <malloc>
  14bd0a:	6120      	str	r0, [r4, #16]
    if (!handle->func_table) {
  14bd0c:	b1e8      	cbz	r0, 14bd4a <ipcc_rpc_server_init+0x76>
        dprintf(ALWAYS, "rpc: failed to alloc function table (svc-%d) \n", server_id);
        return ERR_NO_MEMORY;
    }
    handle->service_id = server_id;
  14bd0e:	6027      	str	r7, [r4, #0]
    ipcc_channel_set_context(handle->rpchan, handle);
    ipcc_channel_start(handle->rpchan, rpc_server_dispatch);
  14bd10:	f64b 31b1 	movw	r1, #48049	; 0xbbb1
    bool        last_announced;
};

inline static void ipcc_channel_set_context(struct ipcc_channel *ichan, void *context)
{
    ichan->user_context = context;
  14bd14:	f8c6 4094 	str.w	r4, [r6, #148]	; 0x94
  14bd18:	f2c0 0114 	movt	r1, #20
  14bd1c:	68a0      	ldr	r0, [r4, #8]
  14bd1e:	f7ff fde1 	bl	14b8e4 <ipcc_channel_start>

    return NO_ERROR;
  14bd22:	4628      	mov	r0, r5
}
  14bd24:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(0, "rpc: Thread mode is not supported yet!\n");
  14bd26:	f246 4000 	movw	r0, #25600	; 0x6400
  14bd2a:	f2c0 0015 	movt	r0, #21
  14bd2e:	f008 f9e3 	bl	1540f8 <_printf>
        return ERR_NOT_IMPLEMENTED;
  14bd32:	f06f 001a 	mvn.w	r0, #26
}
  14bd36:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(0, "Bad ipcc device handle\n");
  14bd38:	f246 30bc 	movw	r0, #25532	; 0x63bc
  14bd3c:	f2c0 0015 	movt	r0, #21
  14bd40:	f008 f9da 	bl	1540f8 <_printf>
        return ERR_INVALID_ARGS;
  14bd44:	f06f 0007 	mvn.w	r0, #7
}
  14bd48:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(ALWAYS, "rpc: failed to alloc function table (svc-%d) \n", server_id);
  14bd4a:	f246 4028 	movw	r0, #25640	; 0x6428
  14bd4e:	4639      	mov	r1, r7
  14bd50:	f2c0 0015 	movt	r0, #21
  14bd54:	f008 f9d0 	bl	1540f8 <_printf>
        return ERR_NO_MEMORY;
  14bd58:	f06f 0004 	mvn.w	r0, #4
}
  14bd5c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(0, "rpc: No channel available\n");
  14bd5e:	f246 30e4 	movw	r0, #25572	; 0x63e4
  14bd62:	f2c0 0015 	movt	r0, #21
  14bd66:	f008 f9c7 	bl	1540f8 <_printf>
        return ERR_NO_RESOURCES;
  14bd6a:	f06f 0028 	mvn.w	r0, #40	; 0x28
}
  14bd6e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0014bd70 <ipcc_rpc_server_start>:

status_t ipcc_rpc_server_start(rpc_server_handle_t handle)
{
    handle->status = IPCC_RPC_S_RUNNING;
  14bd70:	2301      	movs	r3, #1
  14bd72:	60c3      	str	r3, [r0, #12]

    return NO_ERROR;
}
  14bd74:	2000      	movs	r0, #0
  14bd76:	4770      	bx	r14

0014bd78 <ipcc_rpc_setup_implement>:
    return NO_ERROR;
}

status_t ipcc_rpc_setup_implement(rpc_server_handle_t handle,
                                         rpc_server_impl_t *tables, int num)
{
  14bd78:	b570      	push	{r4, r5, r6, r14}
  14bd7a:	4604      	mov	r4, r0
  14bd7c:	b082      	sub	sp, #8
    rpc_server_impl_t *ptr = NULL;
    int left = handle->func_max - handle->func_used;
  14bd7e:	6980      	ldr	r0, [r0, #24]
  14bd80:	6966      	ldr	r6, [r4, #20]
  14bd82:	1a36      	subs	r6, r6, r0

    if (left >= num) {
  14bd84:	4296      	cmp	r6, r2
  14bd86:	db0f      	blt.n	14bda8 <ipcc_rpc_setup_implement+0x30>
        ptr = handle->func_table + handle->func_used;
  14bd88:	6925      	ldr	r5, [r4, #16]
        handle->func_used += num;
  14bd8a:	1883      	adds	r3, r0, r2
        ptr = handle->func_table + handle->func_used;
  14bd8c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
        handle->func_used += num;
  14bd90:	61a3      	str	r3, [r4, #24]
    }

    if (!ptr) {
  14bd92:	eb15 0080 	adds.w	r0, r5, r0, lsl #2
  14bd96:	d007      	beq.n	14bda8 <ipcc_rpc_setup_implement+0x30>
                    left, handle->func_used);

        return ERR_NO_MEMORY;
    }

    memcpy(ptr, tables, sizeof(rpc_server_impl_t) * num);
  14bd98:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  14bd9c:	0092      	lsls	r2, r2, #2
  14bd9e:	f007 e8e8 	blx	152f70 <memcpy>

    dprintf(1, "%s %d installed %d RPC functions \n",
                handle->rpdev->config.devname,
                handle->service_id, handle->func_used);

    return NO_ERROR;
  14bda2:	2000      	movs	r0, #0
}
  14bda4:	b002      	add	sp, #8
  14bda6:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(ALWAYS, "rpc: TODO: func table exceed max\n");
  14bda8:	f246 4058 	movw	r0, #25688	; 0x6458
  14bdac:	f2c0 0015 	movt	r0, #21
  14bdb0:	f008 f9a2 	bl	1540f8 <_printf>
        dprintf(0, "rpc: dev=%s srv=%d left=%d func=%d\n",
  14bdb4:	e9d4 2100 	ldrd	r2, r1, [r4]
  14bdb8:	f246 407c 	movw	r0, #25724	; 0x647c
  14bdbc:	4633      	mov	r3, r6
  14bdbe:	69a4      	ldr	r4, [r4, #24]
  14bdc0:	f2c0 0015 	movt	r0, #21
  14bdc4:	9400      	str	r4, [sp, #0]
  14bdc6:	f008 f997 	bl	1540f8 <_printf>
        return ERR_NO_MEMORY;
  14bdca:	f06f 0004 	mvn.w	r0, #4
  14bdce:	e7e9      	b.n	14bda4 <ipcc_rpc_setup_implement+0x2c>

0014bdd0 <syscnt_get_cnt>:
#include <reg.h>
#include "sys_cnt.h"

uint32_t syscnt_get_cnt(void)
{
    return readl(APB_SYS_CNT_RO_BASE);
  14bdd0:	2300      	movs	r3, #0
  14bdd2:	f2cf 1340 	movt	r3, #61760	; 0xf140
  14bdd6:	6818      	ldr	r0, [r3, #0]
}
  14bdd8:	4770      	bx	r14
  14bdda:	bf00      	nop

0014bddc <syscnt_time_lapse>:
}

uint32_t syscnt_time_lapse(uint32_t early, uint32_t late)
{
    /* not support uint32 overflow occur every about 23 min in 3MHz */
    return (late - early) / SYSCNT_CNT_PER_US;
  14bddc:	f64a 23ab 	movw	r3, #43691	; 0xaaab
  14bde0:	1a08      	subs	r0, r1, r0
  14bde2:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
  14bde6:	fba3 3000 	umull	r3, r0, r3, r0
}
  14bdea:	0840      	lsrs	r0, r0, #1
  14bdec:	4770      	bx	r14
  14bdee:	bf00      	nop

0014bdf0 <free_rpbuf_locked.part.1>:
    return NULL;
}

static int free_rpbuf_locked(sd_rpbuf_t *rpbuf)
{
    ASSERT(1 == rpbuf->ref_count);
  14bdf0:	f246 536c 	movw	r3, #25964	; 0x656c
  14bdf4:	f246 5240 	movw	r2, #25920	; 0x6540
static int free_rpbuf_locked(sd_rpbuf_t *rpbuf)
  14bdf8:	b500      	push	{r14}
    ASSERT(1 == rpbuf->ref_count);
  14bdfa:	f2c0 0315 	movt	r3, #21
  14bdfe:	f644 316c 	movw	r1, #19308	; 0x4b6c
static int free_rpbuf_locked(sd_rpbuf_t *rpbuf)
  14be02:	b083      	sub	sp, #12
    ASSERT(1 == rpbuf->ref_count);
  14be04:	4670      	mov	r0, r14
  14be06:	f2c0 0215 	movt	r2, #21
  14be0a:	9300      	str	r3, [sp, #0]
  14be0c:	f2c0 0115 	movt	r1, #21
  14be10:	2386      	movs	r3, #134	; 0x86
  14be12:	f006 ff4f 	bl	152cb4 <_panic>
  14be16:	bf00      	nop

0014be18 <sd_rpbuf_init_pool>:
{
  14be18:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    pool->buf_sz = mem_size - sizeof(sd_rpbuf_pool_t) - bufnum * sizeof(sd_rpbuf_t);
  14be1a:	0154      	lsls	r4, r2, #5
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14be1c:	2500      	movs	r5, #0
  14be1e:	f1a1 0720 	sub.w	r7, r1, #32
    pool->buf_num = bufnum;
  14be22:	6002      	str	r2, [r0, #0]
    pool->buf_sz = mem_size - sizeof(sd_rpbuf_pool_t) - bufnum * sizeof(sd_rpbuf_t);
  14be24:	1b3f      	subs	r7, r7, r4
    pool->free_buf = bufnum;
  14be26:	6082      	str	r2, [r0, #8]
    buf_start = mem_base + sizeof(sd_rpbuf_pool_t) + bufnum * sizeof(sd_rpbuf_t);
  14be28:	4404      	add	r4, r0
    pool->buf_sz /= bufnum;
  14be2a:	fbb7 f7f2 	udiv	r7, r7, r2
  14be2e:	6105      	str	r5, [r0, #16]
  14be30:	6047      	str	r7, [r0, #4]
    for (i = 0;i < bufnum;i++) {
  14be32:	b1da      	cbz	r2, 14be6c <sd_rpbuf_init_pool+0x54>
  14be34:	3420      	adds	r4, #32
  14be36:	4603      	mov	r3, r0
        if ((unsigned long)rpbuf->buffer >= mem_base + mem_size) {
  14be38:	4401      	add	r1, r0
        rpbuf->buffer = (void *) (buf_start + i * pool->buf_sz);
  14be3a:	6284      	str	r4, [r0, #40]	; 0x28
        if ((unsigned long)rpbuf->buffer >= mem_base + mem_size) {
  14be3c:	428c      	cmp	r4, r1
        rpbuf->data_len = 0;
  14be3e:	bf3e      	ittt	cc
  14be40:	462e      	movcc	r6, r5
  14be42:	19e4      	addcc	r4, r4, r7
  14be44:	fa1f fe87 	uxthcc.w	r14, r7
        if ((unsigned long)rpbuf->buffer >= mem_base + mem_size) {
  14be48:	d306      	bcc.n	14be58 <sd_rpbuf_init_pool+0x40>
  14be4a:	e010      	b.n	14be6e <sd_rpbuf_init_pool+0x56>
        rpbuf->buffer = (void *) (buf_start + i * pool->buf_sz);
  14be4c:	649c      	str	r4, [r3, #72]	; 0x48
        if ((unsigned long)rpbuf->buffer >= mem_base + mem_size) {
  14be4e:	428c      	cmp	r4, r1
  14be50:	4664      	mov	r4, r12
  14be52:	f103 0320 	add.w	r3, r3, #32
  14be56:	d20a      	bcs.n	14be6e <sd_rpbuf_init_pool+0x56>
        rpbuf->buf_size = pool->buf_sz;
  14be58:	f8a3 e02c 	strh.w	r14, [r3, #44]	; 0x2c
    for (i = 0;i < bufnum;i++) {
  14be5c:	3501      	adds	r5, #1
  14be5e:	42aa      	cmp	r2, r5
        rpbuf->data_len = 0;
  14be60:	85de      	strh	r6, [r3, #46]	; 0x2e
  14be62:	eb07 0c04 	add.w	r12, r7, r4
        rpbuf->ref_count = 0;
  14be66:	869e      	strh	r6, [r3, #52]	; 0x34
        rpbuf->wroff = 0;
  14be68:	861e      	strh	r6, [r3, #48]	; 0x30
    for (i = 0;i < bufnum;i++) {
  14be6a:	d1ef      	bne.n	14be4c <sd_rpbuf_init_pool+0x34>
}
  14be6c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            dprintf(CRITICAL, "failed to initialize rpbuf pool\n");
  14be6e:	f246 50b8 	movw	r0, #26040	; 0x65b8
  14be72:	f2c0 0015 	movt	r0, #21
  14be76:	f008 f93f 	bl	1540f8 <_printf>
            return NULL;
  14be7a:	2000      	movs	r0, #0
}
  14be7c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  14be7e:	bf00      	nop

0014be80 <sd_rpbuf_create_pool>:

// Cribbed from:
// http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2
static inline __ALWAYS_INLINE uint32_t round_up_pow2_u32(uint32_t v)
{
    v--;
  14be80:	3801      	subs	r0, #1
{
  14be82:	b570      	push	{r4, r5, r6, r14}
  14be84:	460e      	mov	r6, r1
    v |= v >> 1;
  14be86:	ea40 0050 	orr.w	r0, r0, r0, lsr #1
    v |= v >> 2;
  14be8a:	ea40 0090 	orr.w	r0, r0, r0, lsr #2
    v |= v >> 4;
  14be8e:	ea40 1010 	orr.w	r0, r0, r0, lsr #4
    v |= v >> 8;
  14be92:	ea40 2010 	orr.w	r0, r0, r0, lsr #8
    v |= v >> 16;
  14be96:	ea40 4410 	orr.w	r4, r0, r0, lsr #16
    mem_size = sizeof(sd_rpbuf_pool_t) + bufnum *(sz_align + sizeof(sd_rpbuf_t));
  14be9a:	3421      	adds	r4, #33	; 0x21
  14be9c:	fb01 f404 	mul.w	r4, r1, r4
  14bea0:	3420      	adds	r4, #32
    pool = malloc(mem_size);
  14bea2:	4620      	mov	r0, r4
  14bea4:	f006 fff4 	bl	152e90 <malloc>
    if (!pool) {
  14bea8:	4605      	mov	r5, r0
  14beaa:	b138      	cbz	r0, 14bebc <sd_rpbuf_create_pool+0x3c>
    pool->flags = RPBUF_POOL_ALLOC;
  14beac:	2301      	movs	r3, #1
    sd_rpbuf_init_pool((unsigned long )pool, mem_size, bufnum);
  14beae:	4632      	mov	r2, r6
  14beb0:	4621      	mov	r1, r4
    pool->flags = RPBUF_POOL_ALLOC;
  14beb2:	60c3      	str	r3, [r0, #12]
    sd_rpbuf_init_pool((unsigned long )pool, mem_size, bufnum);
  14beb4:	f7ff ffb0 	bl	14be18 <sd_rpbuf_init_pool>
}
  14beb8:	4628      	mov	r0, r5
  14beba:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(0, "No memory for rpbuf pool\n");
  14bebc:	f246 5084 	movw	r0, #25988	; 0x6584
  14bec0:	f2c0 0015 	movt	r0, #21
  14bec4:	f008 f918 	bl	1540f8 <_printf>
        return NULL;
  14bec8:	e7f6      	b.n	14beb8 <sd_rpbuf_create_pool+0x38>
  14beca:	bf00      	nop

0014becc <sd_rpbuf_remove_pool>:
    if (pool->free_buf != pool->buf_num) {
  14becc:	6881      	ldr	r1, [r0, #8]
  14bece:	6802      	ldr	r2, [r0, #0]
{
  14bed0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14bed2:	4606      	mov	r6, r0
    if (pool->free_buf != pool->buf_num) {
  14bed4:	4291      	cmp	r1, r2
  14bed6:	d103      	bne.n	14bee0 <sd_rpbuf_remove_pool+0x14>
        if (pool->flags & RPBUF_POOL_ALLOC)
  14bed8:	68c3      	ldr	r3, [r0, #12]
  14beda:	07db      	lsls	r3, r3, #31
  14bedc:	d41d      	bmi.n	14bf1a <sd_rpbuf_remove_pool+0x4e>
}
  14bede:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(0, "Risky to free buffer in use, checking buffers\n");
  14bee0:	f246 602c 	movw	r0, #26156	; 0x662c
  14bee4:	f2c0 0015 	movt	r0, #21
  14bee8:	f008 f906 	bl	1540f8 <_printf>
        for (i = 0;i < pool->buf_num;i++) {
  14beec:	6833      	ldr	r3, [r6, #0]
  14beee:	2b00      	cmp	r3, #0
  14bef0:	d0f5      	beq.n	14bede <sd_rpbuf_remove_pool+0x12>
            dprintf(0, "to free buffer=%d in use refcnt=%d\n", i, rpbuf->ref_count);
  14bef2:	f246 675c 	movw	r7, #26204	; 0x665c
  14bef6:	4635      	mov	r5, r6
        for (i = 0;i < pool->buf_num;i++) {
  14bef8:	2400      	movs	r4, #0
            dprintf(0, "to free buffer=%d in use refcnt=%d\n", i, rpbuf->ref_count);
  14befa:	f2c0 0715 	movt	r7, #21
  14befe:	e002      	b.n	14bf06 <sd_rpbuf_remove_pool+0x3a>
        for (i = 0;i < pool->buf_num;i++) {
  14bf00:	3401      	adds	r4, #1
  14bf02:	42a3      	cmp	r3, r4
  14bf04:	d9eb      	bls.n	14bede <sd_rpbuf_remove_pool+0x12>
            if (rpbuf->ref_count)
  14bf06:	8eaa      	ldrh	r2, [r5, #52]	; 0x34
  14bf08:	3520      	adds	r5, #32
  14bf0a:	2a00      	cmp	r2, #0
  14bf0c:	d0f8      	beq.n	14bf00 <sd_rpbuf_remove_pool+0x34>
            dprintf(0, "to free buffer=%d in use refcnt=%d\n", i, rpbuf->ref_count);
  14bf0e:	4621      	mov	r1, r4
  14bf10:	4638      	mov	r0, r7
  14bf12:	f008 f8f1 	bl	1540f8 <_printf>
  14bf16:	6833      	ldr	r3, [r6, #0]
  14bf18:	e7f2      	b.n	14bf00 <sd_rpbuf_remove_pool+0x34>
}
  14bf1a:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
            free(pool);
  14bf1e:	f006 bfed 	b.w	152efc <free>
  14bf22:	bf00      	nop

0014bf24 <sd_rpbuf_alloc>:
{
  14bf24:	b4f0      	push	{r4, r5, r6, r7}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14bf26:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14bf2a:	061b      	lsls	r3, r3, #24
  14bf2c:	d41e      	bmi.n	14bf6c <sd_rpbuf_alloc+0x48>
    __asm__ volatile("cpsid i");
  14bf2e:	b672      	cpsid	i
    for (i = 0;i < pool->buf_num; i++) {
  14bf30:	6806      	ldr	r6, [r0, #0]
    *lock = 1;
  14bf32:	2701      	movs	r7, #1
  14bf34:	6107      	str	r7, [r0, #16]
  14bf36:	2e00      	cmp	r6, #0
  14bf38:	d037      	beq.n	14bfaa <sd_rpbuf_alloc+0x86>
        if (!rpbuf->ref_count) {
  14bf3a:	8e82      	ldrh	r2, [r0, #52]	; 0x34
    for (i = 0;i < pool->buf_num; i++) {
  14bf3c:	4613      	mov	r3, r2
        rpbuf = &pool->buffers[i];
  14bf3e:	f100 0420 	add.w	r4, r0, #32
        if (!rpbuf->ref_count) {
  14bf42:	b302      	cbz	r2, 14bf86 <sd_rpbuf_alloc+0x62>
  14bf44:	4602      	mov	r2, r0
    for (i = 0;i < pool->buf_num; i++) {
  14bf46:	2400      	movs	r4, #0
  14bf48:	e002      	b.n	14bf50 <sd_rpbuf_alloc+0x2c>
        if (!rpbuf->ref_count) {
  14bf4a:	8e95      	ldrh	r5, [r2, #52]	; 0x34
  14bf4c:	b1bd      	cbz	r5, 14bf7e <sd_rpbuf_alloc+0x5a>
  14bf4e:	461c      	mov	r4, r3
    for (i = 0;i < pool->buf_num; i++) {
  14bf50:	1c63      	adds	r3, r4, #1
  14bf52:	429e      	cmp	r6, r3
  14bf54:	f102 0220 	add.w	r2, r2, #32
  14bf58:	d8f7      	bhi.n	14bf4a <sd_rpbuf_alloc+0x26>
    *lock = 0;
  14bf5a:	2300      	movs	r3, #0
    return NULL;
  14bf5c:	463c      	mov	r4, r7
  14bf5e:	6103      	str	r3, [r0, #16]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14bf60:	b10f      	cbz	r7, 14bf66 <sd_rpbuf_alloc+0x42>
    __asm__ volatile("cpsie i");
  14bf62:	b662      	cpsie	i
  14bf64:	2400      	movs	r4, #0
}
  14bf66:	4620      	mov	r0, r4
  14bf68:	bcf0      	pop	{r4, r5, r6, r7}
  14bf6a:	4770      	bx	r14
    for (i = 0;i < pool->buf_num; i++) {
  14bf6c:	6806      	ldr	r6, [r0, #0]
    *lock = 1;
  14bf6e:	2301      	movs	r3, #1
    spin_lock_saved_state_t state = 0;
  14bf70:	2700      	movs	r7, #0
    *lock = 1;
  14bf72:	6103      	str	r3, [r0, #16]
  14bf74:	2e00      	cmp	r6, #0
  14bf76:	d1e0      	bne.n	14bf3a <sd_rpbuf_alloc+0x16>
    *lock = 0;
  14bf78:	6106      	str	r6, [r0, #16]
    return NULL;
  14bf7a:	4634      	mov	r4, r6
  14bf7c:	e7f3      	b.n	14bf66 <sd_rpbuf_alloc+0x42>
        rpbuf = &pool->buffers[i];
  14bf7e:	3402      	adds	r4, #2
  14bf80:	b29a      	uxth	r2, r3
  14bf82:	eb00 1444 	add.w	r4, r0, r4, lsl #5
            pool->free_buf--;
  14bf86:	6885      	ldr	r5, [r0, #8]
  14bf88:	eb00 1343 	add.w	r3, r0, r3, lsl #5
            rpbuf->ref_count++;
  14bf8c:	2601      	movs	r6, #1
            rpbuf->flags = flag;
  14bf8e:	86d9      	strh	r1, [r3, #54]	; 0x36
            pool->free_buf--;
  14bf90:	3d01      	subs	r5, #1
            rpbuf->buf_id = i;
  14bf92:	865a      	strh	r2, [r3, #50]	; 0x32
            rpbuf->wroff = 0;
  14bf94:	2100      	movs	r1, #0
            rpbuf->ref_count++;
  14bf96:	869e      	strh	r6, [r3, #52]	; 0x34
            rpbuf->wroff = 0;
  14bf98:	8619      	strh	r1, [r3, #48]	; 0x30
  14bf9a:	6101      	str	r1, [r0, #16]
            pool->free_buf--;
  14bf9c:	6085      	str	r5, [r0, #8]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14bf9e:	2f00      	cmp	r7, #0
  14bfa0:	d0e1      	beq.n	14bf66 <sd_rpbuf_alloc+0x42>
  14bfa2:	b662      	cpsie	i
}
  14bfa4:	4620      	mov	r0, r4
  14bfa6:	bcf0      	pop	{r4, r5, r6, r7}
  14bfa8:	4770      	bx	r14
    *lock = 0;
  14bfaa:	6106      	str	r6, [r0, #16]
  14bfac:	e7d9      	b.n	14bf62 <sd_rpbuf_alloc+0x3e>
  14bfae:	bf00      	nop

0014bfb0 <sd_rpbuf_free_ptr>:
    dprintf(2, "free rpbuf[%d]=%p f=%d\n", rpbuf->buf_id, rpbuf->buffer, rpbuf->flags);
    return 0;
}

int sd_rpbuf_free_ptr(sd_rpbuf_pool_t *pool, void *buf)
{
  14bfb0:	b570      	push	{r4, r5, r6, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14bfb2:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14bfb6:	0612      	lsls	r2, r2, #24
  14bfb8:	f100 0320 	add.w	r3, r0, #32
  14bfbc:	d420      	bmi.n	14c000 <sd_rpbuf_free_ptr+0x50>
    __asm__ volatile("cpsid i");
  14bfbe:	b672      	cpsid	i
    unsigned int i;
    sd_rpbuf_t *rpbuf;
    spin_lock_saved_state_t state;

    spin_lock_irqsave(&pool->pool_lock, state);
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14bfc0:	6805      	ldr	r5, [r0, #0]
    *lock = 1;
  14bfc2:	2601      	movs	r6, #1
  14bfc4:	6106      	str	r6, [r0, #16]
  14bfc6:	2d00      	cmp	r5, #0
  14bfc8:	d033      	beq.n	14c032 <sd_rpbuf_free_ptr+0x82>
        if (buf == rpbuf->buffer) {
  14bfca:	6a82      	ldr	r2, [r0, #40]	; 0x28
  14bfcc:	4291      	cmp	r1, r2
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14bfce:	bf18      	it	ne
  14bfd0:	2200      	movne	r2, #0
        if (buf == rpbuf->buffer) {
  14bfd2:	d103      	bne.n	14bfdc <sd_rpbuf_free_ptr+0x2c>
  14bfd4:	e01c      	b.n	14c010 <sd_rpbuf_free_ptr+0x60>
  14bfd6:	689c      	ldr	r4, [r3, #8]
  14bfd8:	428c      	cmp	r4, r1
  14bfda:	d019      	beq.n	14c010 <sd_rpbuf_free_ptr+0x60>
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14bfdc:	3201      	adds	r2, #1
  14bfde:	4295      	cmp	r5, r2
  14bfe0:	f103 0320 	add.w	r3, r3, #32
  14bfe4:	d8f7      	bhi.n	14bfd6 <sd_rpbuf_free_ptr+0x26>
    *lock = 0;
  14bfe6:	2300      	movs	r3, #0
  14bfe8:	6103      	str	r3, [r0, #16]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14bfea:	b106      	cbz	r6, 14bfee <sd_rpbuf_free_ptr+0x3e>
    __asm__ volatile("cpsie i");
  14bfec:	b662      	cpsie	i
            spin_unlock_irqrestore(&pool->pool_lock, state);
            return 0;
        }
    }
    spin_unlock_irqrestore(&pool->pool_lock, state);
    dprintf(0, "fail to free rpbuf=%p\n", buf);
  14bfee:	f246 50a0 	movw	r0, #26016	; 0x65a0
  14bff2:	f2c0 0015 	movt	r0, #21
  14bff6:	f008 f87f 	bl	1540f8 <_printf>

    return -1;
  14bffa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14bffe:	bd70      	pop	{r4, r5, r6, r15}
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14c000:	6805      	ldr	r5, [r0, #0]
    *lock = 1;
  14c002:	2201      	movs	r2, #1
    spin_lock_saved_state_t state = 0;
  14c004:	2600      	movs	r6, #0
    *lock = 1;
  14c006:	6102      	str	r2, [r0, #16]
  14c008:	2d00      	cmp	r5, #0
  14c00a:	d1de      	bne.n	14bfca <sd_rpbuf_free_ptr+0x1a>
    *lock = 0;
  14c00c:	6105      	str	r5, [r0, #16]
  14c00e:	e7ee      	b.n	14bfee <sd_rpbuf_free_ptr+0x3e>
    ASSERT(1 == rpbuf->ref_count);
  14c010:	8a9a      	ldrh	r2, [r3, #20]
  14c012:	2a01      	cmp	r2, #1
  14c014:	d10f      	bne.n	14c036 <sd_rpbuf_free_ptr+0x86>
            pool->free_buf++;
  14c016:	6881      	ldr	r1, [r0, #8]
    rpbuf->ref_count--;
  14c018:	2200      	movs	r2, #0
  14c01a:	829a      	strh	r2, [r3, #20]
            pool->free_buf++;
  14c01c:	3101      	adds	r1, #1
    rpbuf->data_len = 0;
  14c01e:	81da      	strh	r2, [r3, #14]
    rpbuf->wroff = 0;
  14c020:	821a      	strh	r2, [r3, #16]
            pool->free_buf++;
  14c022:	6081      	str	r1, [r0, #8]
  14c024:	6102      	str	r2, [r0, #16]
            return 0;
  14c026:	4630      	mov	r0, r6
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14c028:	2e00      	cmp	r6, #0
  14c02a:	d0e8      	beq.n	14bffe <sd_rpbuf_free_ptr+0x4e>
  14c02c:	b662      	cpsie	i
  14c02e:	4610      	mov	r0, r2
}
  14c030:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 0;
  14c032:	6105      	str	r5, [r0, #16]
  14c034:	e7da      	b.n	14bfec <sd_rpbuf_free_ptr+0x3c>
  14c036:	f7ff fedb 	bl	14bdf0 <free_rpbuf_locked.part.1>
  14c03a:	bf00      	nop

0014c03c <sd_rpbuf_free_id>:

int sd_rpbuf_free_id(sd_rpbuf_pool_t *pool, unsigned int buf_id)
{
    spin_lock_saved_state_t state;

    if (buf_id > pool->buf_num)
  14c03c:	6803      	ldr	r3, [r0, #0]
  14c03e:	428b      	cmp	r3, r1
  14c040:	d32b      	bcc.n	14c09a <sd_rpbuf_free_id+0x5e>
{
  14c042:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c044:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c048:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14c04c:	d011      	beq.n	14c072 <sd_rpbuf_free_id+0x36>
    *lock = 1;
  14c04e:	2201      	movs	r2, #1
  14c050:	eb00 1141 	add.w	r1, r0, r1, lsl #5
    ASSERT(1 == rpbuf->ref_count);
  14c054:	8e8b      	ldrh	r3, [r1, #52]	; 0x34
  14c056:	4293      	cmp	r3, r2
  14c058:	6102      	str	r2, [r0, #16]
  14c05a:	d11c      	bne.n	14c096 <sd_rpbuf_free_id+0x5a>
        return -1;

    spin_lock_irqsave(&pool->pool_lock, state);
    free_rpbuf_locked(&pool->buffers[buf_id]);
    pool->free_buf++;
  14c05c:	6884      	ldr	r4, [r0, #8]
    rpbuf->ref_count--;
  14c05e:	2200      	movs	r2, #0
    spin_unlock_irqrestore(&pool->pool_lock, state);

    return 0;
  14c060:	4613      	mov	r3, r2
    rpbuf->ref_count--;
  14c062:	868a      	strh	r2, [r1, #52]	; 0x34
    pool->free_buf++;
  14c064:	3401      	adds	r4, #1
    rpbuf->data_len = 0;
  14c066:	85ca      	strh	r2, [r1, #46]	; 0x2e
    rpbuf->wroff = 0;
  14c068:	860a      	strh	r2, [r1, #48]	; 0x30
    pool->free_buf++;
  14c06a:	6084      	str	r4, [r0, #8]
    *lock = 0;
  14c06c:	6102      	str	r2, [r0, #16]
}
  14c06e:	4618      	mov	r0, r3
  14c070:	bd10      	pop	{r4, r15}
    __asm__ volatile("cpsid i");
  14c072:	b672      	cpsid	i
    *lock = 1;
  14c074:	2401      	movs	r4, #1
  14c076:	eb00 1141 	add.w	r1, r0, r1, lsl #5
    ASSERT(1 == rpbuf->ref_count);
  14c07a:	8e8a      	ldrh	r2, [r1, #52]	; 0x34
  14c07c:	42a2      	cmp	r2, r4
  14c07e:	6104      	str	r4, [r0, #16]
  14c080:	d109      	bne.n	14c096 <sd_rpbuf_free_id+0x5a>
    pool->free_buf++;
  14c082:	6882      	ldr	r2, [r0, #8]
    rpbuf->ref_count--;
  14c084:	868b      	strh	r3, [r1, #52]	; 0x34
    rpbuf->data_len = 0;
  14c086:	85cb      	strh	r3, [r1, #46]	; 0x2e
    pool->free_buf++;
  14c088:	3201      	adds	r2, #1
    rpbuf->wroff = 0;
  14c08a:	860b      	strh	r3, [r1, #48]	; 0x30
    *lock = 0;
  14c08c:	6103      	str	r3, [r0, #16]
    pool->free_buf++;
  14c08e:	6082      	str	r2, [r0, #8]
    __asm__ volatile("cpsie i");
  14c090:	b662      	cpsie	i
}
  14c092:	4618      	mov	r0, r3
  14c094:	bd10      	pop	{r4, r15}
  14c096:	f7ff feab 	bl	14bdf0 <free_rpbuf_locked.part.1>
        return -1;
  14c09a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
}
  14c09e:	4618      	mov	r0, r3
  14c0a0:	4770      	bx	r14
  14c0a2:	bf00      	nop

0014c0a4 <sd_rpbuf_find_handle>:

    return 0;
}

sd_rpbuf_t *sd_rpbuf_find_handle(sd_rpbuf_pool_t *pool, void *buf)
{
  14c0a4:	b470      	push	{r4, r5, r6}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c0a6:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c0aa:	f012 0280 	ands.w	r2, r2, #128	; 0x80
  14c0ae:	f100 0320 	add.w	r3, r0, #32
  14c0b2:	d10d      	bne.n	14c0d0 <sd_rpbuf_find_handle+0x2c>
    __asm__ volatile("cpsid i");
  14c0b4:	b672      	cpsid	i
    unsigned int i;
    sd_rpbuf_t *rpbuf;
    spin_lock_saved_state_t state;

    spin_lock_irqsave(&pool->pool_lock, state);
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14c0b6:	6805      	ldr	r5, [r0, #0]
    *lock = 1;
  14c0b8:	2601      	movs	r6, #1
  14c0ba:	6106      	str	r6, [r0, #16]
  14c0bc:	2d00      	cmp	r5, #0
  14c0be:	d02e      	beq.n	14c11e <sd_rpbuf_find_handle+0x7a>
        if (buf == rpbuf->buffer) {
  14c0c0:	6a84      	ldr	r4, [r0, #40]	; 0x28
  14c0c2:	42a1      	cmp	r1, r4
  14c0c4:	d10f      	bne.n	14c0e6 <sd_rpbuf_find_handle+0x42>
    *lock = 0;
  14c0c6:	6102      	str	r2, [r0, #16]
    __asm__ volatile("cpsie i");
  14c0c8:	b662      	cpsie	i
        }
    }
    spin_unlock_irqrestore(&pool->pool_lock, state);

    return NULL;
}
  14c0ca:	4618      	mov	r0, r3
  14c0cc:	bc70      	pop	{r4, r5, r6}
  14c0ce:	4770      	bx	r14
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14c0d0:	6805      	ldr	r5, [r0, #0]
    *lock = 1;
  14c0d2:	2201      	movs	r2, #1
  14c0d4:	6102      	str	r2, [r0, #16]
  14c0d6:	b1fd      	cbz	r5, 14c118 <sd_rpbuf_find_handle+0x74>
        if (buf == rpbuf->buffer) {
  14c0d8:	6a82      	ldr	r2, [r0, #40]	; 0x28
  14c0da:	4291      	cmp	r1, r2
    *lock = 0;
  14c0dc:	bf04      	itt	eq
  14c0de:	2200      	moveq	r2, #0
  14c0e0:	6102      	streq	r2, [r0, #16]
  14c0e2:	d00f      	beq.n	14c104 <sd_rpbuf_find_handle+0x60>
    spin_lock_saved_state_t state = 0;
  14c0e4:	2600      	movs	r6, #0
  14c0e6:	2200      	movs	r2, #0
  14c0e8:	e002      	b.n	14c0f0 <sd_rpbuf_find_handle+0x4c>
  14c0ea:	689c      	ldr	r4, [r3, #8]
  14c0ec:	428c      	cmp	r4, r1
  14c0ee:	d00c      	beq.n	14c10a <sd_rpbuf_find_handle+0x66>
    for (i = 0, rpbuf = &pool->buffers[0]; i < pool->buf_num; i++, rpbuf++) {
  14c0f0:	3201      	adds	r2, #1
  14c0f2:	42aa      	cmp	r2, r5
  14c0f4:	f103 0320 	add.w	r3, r3, #32
  14c0f8:	d3f7      	bcc.n	14c0ea <sd_rpbuf_find_handle+0x46>
    *lock = 0;
  14c0fa:	2300      	movs	r3, #0
  14c0fc:	6103      	str	r3, [r0, #16]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14c0fe:	b106      	cbz	r6, 14c102 <sd_rpbuf_find_handle+0x5e>
  14c100:	b662      	cpsie	i
    return NULL;
  14c102:	2300      	movs	r3, #0
}
  14c104:	4618      	mov	r0, r3
  14c106:	bc70      	pop	{r4, r5, r6}
  14c108:	4770      	bx	r14
    *lock = 0;
  14c10a:	2200      	movs	r2, #0
  14c10c:	6102      	str	r2, [r0, #16]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14c10e:	2e00      	cmp	r6, #0
  14c110:	d1da      	bne.n	14c0c8 <sd_rpbuf_find_handle+0x24>
  14c112:	4618      	mov	r0, r3
  14c114:	bc70      	pop	{r4, r5, r6}
  14c116:	4770      	bx	r14
    *lock = 0;
  14c118:	6105      	str	r5, [r0, #16]
    return NULL;
  14c11a:	462b      	mov	r3, r5
  14c11c:	e7f2      	b.n	14c104 <sd_rpbuf_find_handle+0x60>
  14c11e:	6105      	str	r5, [r0, #16]
  14c120:	e7ee      	b.n	14c100 <sd_rpbuf_find_handle+0x5c>
  14c122:	bf00      	nop

0014c124 <sd_rpbuf_push_data>:

int sd_rpbuf_push_data(sd_rpbuf_t *rpbuf, void *data, u16 len)
{
  14c124:	b570      	push	{r4, r5, r6, r14}
    if (len > rpbuf->buf_size - rpbuf->wroff) {
  14c126:	8a03      	ldrh	r3, [r0, #16]
{
  14c128:	4614      	mov	r4, r2
  14c12a:	4605      	mov	r5, r0
    if (len > rpbuf->buf_size - rpbuf->wroff) {
  14c12c:	8982      	ldrh	r2, [r0, #12]
{
  14c12e:	460e      	mov	r6, r1
    if (len > rpbuf->buf_size - rpbuf->wroff) {
  14c130:	1ad0      	subs	r0, r2, r3
  14c132:	4284      	cmp	r4, r0
  14c134:	dd0a      	ble.n	14c14c <sd_rpbuf_push_data+0x28>
        dprintf(0, "Can't push len %u > buf %u, trim\n", len, rpbuf->buf_size);
  14c136:	f246 6008 	movw	r0, #26120	; 0x6608
  14c13a:	4621      	mov	r1, r4
  14c13c:	f2c0 0015 	movt	r0, #21
  14c140:	f007 ffda 	bl	1540f8 <_printf>
        len = rpbuf->buf_size - - rpbuf->wroff;
  14c144:	89ac      	ldrh	r4, [r5, #12]
  14c146:	8a2b      	ldrh	r3, [r5, #16]
  14c148:	441c      	add	r4, r3
  14c14a:	b2a4      	uxth	r4, r4
    }

    memcpy(rpbuf->buffer + rpbuf->wroff, data, len);
  14c14c:	68a8      	ldr	r0, [r5, #8]
  14c14e:	4622      	mov	r2, r4
  14c150:	4631      	mov	r1, r6
  14c152:	4418      	add	r0, r3
  14c154:	f006 ef0c 	blx	152f70 <memcpy>
    rpbuf->data_len += len;
  14c158:	89eb      	ldrh	r3, [r5, #14]
    rpbuf->wroff += len;
  14c15a:	8a2a      	ldrh	r2, [r5, #16]

    return 0;
}
  14c15c:	2000      	movs	r0, #0
    rpbuf->data_len += len;
  14c15e:	4423      	add	r3, r4
    rpbuf->wroff += len;
  14c160:	4414      	add	r4, r2
    rpbuf->data_len += len;
  14c162:	81eb      	strh	r3, [r5, #14]
    rpbuf->wroff += len;
  14c164:	822c      	strh	r4, [r5, #16]
}
  14c166:	bd70      	pop	{r4, r5, r6, r15}

0014c168 <sd_rpbuf_pop_data>:

void *sd_rpbuf_pop_data(sd_rpbuf_t *rpbuf, void *buf, u16 len)
{
  14c168:	b570      	push	{r4, r5, r6, r14}
    unsigned char *data = rpbuf->buffer + rpbuf->wroff;

    if (len > rpbuf->data_len) {
  14c16a:	89c5      	ldrh	r5, [r0, #14]
    unsigned char *data = rpbuf->buffer + rpbuf->wroff;
  14c16c:	8a06      	ldrh	r6, [r0, #16]
  14c16e:	6884      	ldr	r4, [r0, #8]
    if (len > rpbuf->data_len) {
  14c170:	4295      	cmp	r5, r2
{
  14c172:	4613      	mov	r3, r2
    unsigned char *data = rpbuf->buffer + rpbuf->wroff;
  14c174:	4434      	add	r4, r6
    if (len > rpbuf->data_len) {
  14c176:	d309      	bcc.n	14c18c <sd_rpbuf_pop_data+0x24>
        dprintf(0, "Can't pop enough data len %d > actual %d\n", len, rpbuf->data_len);
        return NULL;
    }

    if (buf || len)
  14c178:	2a00      	cmp	r2, #0
  14c17a:	bf08      	it	eq
  14c17c:	2900      	cmpeq	r1, #0
  14c17e:	d003      	beq.n	14c188 <sd_rpbuf_pop_data+0x20>
        memcpy(buf, data, len);
  14c180:	4608      	mov	r0, r1
  14c182:	4621      	mov	r1, r4
  14c184:	f006 eef4 	blx	152f70 <memcpy>

    return data;
}
  14c188:	4620      	mov	r0, r4
  14c18a:	bd70      	pop	{r4, r5, r6, r15}
        dprintf(0, "Can't pop enough data len %d > actual %d\n", len, rpbuf->data_len);
  14c18c:	f246 50dc 	movw	r0, #26076	; 0x65dc
  14c190:	462a      	mov	r2, r5
  14c192:	4619      	mov	r1, r3
  14c194:	f2c0 0015 	movt	r0, #21
  14c198:	f007 ffae 	bl	1540f8 <_printf>
        return NULL;
  14c19c:	2400      	movs	r4, #0
  14c19e:	e7f3      	b.n	14c188 <sd_rpbuf_pop_data+0x20>

0014c1a0 <sd_rpbuf_init_queue>:

int sd_rpbuf_init_queue(sd_rpbuf_queue_t *rq)
{
  14c1a0:	4603      	mov	r3, r0
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14c1a2:	2200      	movs	r2, #0
    spin_lock_init(&rq->queue_lock);
    list_initialize(&rq->queue_head);
    rq->buf_num = 0;

    return 0;
}
  14c1a4:	4610      	mov	r0, r2
    list->prev = list->next = list;
  14c1a6:	e9c3 3300 	strd	r3, r3, [r3]
    rq->buf_num = 0;
  14c1aa:	e9c3 2202 	strd	r2, r2, [r3, #8]
}
  14c1ae:	4770      	bx	r14

0014c1b0 <sd_rpbuf_remove_queue>:

int sd_rpbuf_remove_queue(sd_rpbuf_queue_t *rq)
{
  14c1b0:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c1b4:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c1b8:	f013 0280 	ands.w	r2, r3, #128	; 0x80
  14c1bc:	d109      	bne.n	14c1d2 <sd_rpbuf_remove_queue+0x22>
    __asm__ volatile("cpsid i");
  14c1be:	b672      	cpsid	i
        &(entry)->member != (list);\
        entry = temp_entry, temp_entry = containerof((temp_entry)->member.next, type, member))

static inline bool list_is_empty(struct list_node *list)
{
    return (list->next == list) ? true : false;
  14c1c0:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  14c1c2:	2101      	movs	r1, #1
  14c1c4:	60c1      	str	r1, [r0, #12]
    sd_rpbuf_t *rpbuf = NULL;
    spin_lock_saved_state_t state;

    spin_lock_irqsave(&rq->queue_lock, state);
    while (!list_is_empty(&rq->queue_head)) {
  14c1c6:	4298      	cmp	r0, r3
    *lock = 0;
  14c1c8:	bf08      	it	eq
  14c1ca:	60c2      	streq	r2, [r0, #12]
  14c1cc:	d027      	beq.n	14c21e <sd_rpbuf_remove_queue+0x6e>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14c1ce:	4688      	mov	r8, r1
  14c1d0:	e009      	b.n	14c1e6 <sd_rpbuf_remove_queue+0x36>
  14c1d2:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  14c1d4:	2201      	movs	r2, #1
  14c1d6:	60c2      	str	r2, [r0, #12]
  14c1d8:	4298      	cmp	r0, r3
    *lock = 0;
  14c1da:	bf04      	itt	eq
  14c1dc:	2300      	moveq	r3, #0
  14c1de:	60c3      	streq	r3, [r0, #12]
  14c1e0:	d01e      	beq.n	14c220 <sd_rpbuf_remove_queue+0x70>
    spin_lock_saved_state_t state = 0;
  14c1e2:	f04f 0800 	mov.w	r8, #0
        rpbuf = list_remove_head_type(&rq->queue_head, sd_rpbuf_t, buf_node);
        if (rpbuf) {
            dprintf(0, "remove pending rpbuf=%p, id=%d\n", rpbuf, rpbuf->buf_id);
  14c1e6:	f246 6980 	movw	r9, #26240	; 0x6680
  14c1ea:	4604      	mov	r4, r0
    item->prev = item->next = 0;
  14c1ec:	2600      	movs	r6, #0
  14c1ee:	f2c0 0915 	movt	r9, #21
    item->next->prev = item->prev;
  14c1f2:	6818      	ldr	r0, [r3, #0]
  14c1f4:	8a5a      	ldrh	r2, [r3, #18]
  14c1f6:	685d      	ldr	r5, [r3, #4]
  14c1f8:	4619      	mov	r1, r3
  14c1fa:	6028      	str	r0, [r5, #0]
  14c1fc:	4648      	mov	r0, r9
    item->prev->next = item->next;
  14c1fe:	681f      	ldr	r7, [r3, #0]
  14c200:	607d      	str	r5, [r7, #4]
    item->prev = item->next = 0;
  14c202:	e9c3 6600 	strd	r6, r6, [r3]
  14c206:	f007 ff77 	bl	1540f8 <_printf>
    return (list->next == list) ? true : false;
  14c20a:	e9d4 3201 	ldrd	r3, r2, [r4, #4]
        }
        rq->buf_num--;
  14c20e:	3a01      	subs	r2, #1
    while (!list_is_empty(&rq->queue_head)) {
  14c210:	42a3      	cmp	r3, r4
        rq->buf_num--;
  14c212:	60a2      	str	r2, [r4, #8]
    while (!list_is_empty(&rq->queue_head)) {
  14c214:	d1ed      	bne.n	14c1f2 <sd_rpbuf_remove_queue+0x42>
    *lock = 0;
  14c216:	60de      	str	r6, [r3, #12]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14c218:	f1b8 0f00 	cmp.w	r8, #0
  14c21c:	d000      	beq.n	14c220 <sd_rpbuf_remove_queue+0x70>
    __asm__ volatile("cpsie i");
  14c21e:	b662      	cpsie	i

    }
    spin_unlock_irqrestore(&rq->queue_lock, state);

    return 0;
}
  14c220:	2000      	movs	r0, #0
  14c222:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
  14c226:	bf00      	nop

0014c228 <sd_rpbuf_enqueue>:

void sd_rpbuf_enqueue(sd_rpbuf_queue_t *rq, sd_rpbuf_t *rpbuf)
{
  14c228:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c22a:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c22e:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14c232:	d10e      	bne.n	14c252 <sd_rpbuf_enqueue+0x2a>
    __asm__ volatile("cpsid i");
  14c234:	b672      	cpsid	i
    spin_lock_saved_state_t state;

    spin_lock_irqsave(&rq->queue_lock, state);
    list_add_tail(&rq->queue_head,
        (struct list_node *)(&rpbuf->buf_node));
    rq->buf_num++;
  14c236:	6882      	ldr	r2, [r0, #8]
    item->prev = list->prev;
  14c238:	6804      	ldr	r4, [r0, #0]
  14c23a:	600c      	str	r4, [r1, #0]
  14c23c:	3201      	adds	r2, #1
    list->prev->next = item;
  14c23e:	6804      	ldr	r4, [r0, #0]
    item->next = list;
  14c240:	6048      	str	r0, [r1, #4]
    list->prev->next = item;
  14c242:	6061      	str	r1, [r4, #4]
    list->prev = item;
  14c244:	6001      	str	r1, [r0, #0]
  14c246:	e9c0 2302 	strd	r2, r3, [r0, #8]
    __asm__ volatile("cpsie i");
  14c24a:	b662      	cpsie	i
    spin_unlock_irqrestore(&rq->queue_lock, state);
}
  14c24c:	f85d 4b04 	ldr.w	r4, [r13], #4
  14c250:	4770      	bx	r14
    rq->buf_num++;
  14c252:	6883      	ldr	r3, [r0, #8]
    *lock = 0;
  14c254:	2200      	movs	r2, #0
    item->prev = list->prev;
  14c256:	6804      	ldr	r4, [r0, #0]
  14c258:	600c      	str	r4, [r1, #0]
  14c25a:	3301      	adds	r3, #1
    list->prev->next = item;
  14c25c:	6804      	ldr	r4, [r0, #0]
    item->next = list;
  14c25e:	6048      	str	r0, [r1, #4]
    list->prev->next = item;
  14c260:	6061      	str	r1, [r4, #4]
    list->prev = item;
  14c262:	6001      	str	r1, [r0, #0]
  14c264:	e9c0 3202 	strd	r3, r2, [r0, #8]
}
  14c268:	f85d 4b04 	ldr.w	r4, [r13], #4
  14c26c:	4770      	bx	r14
  14c26e:	bf00      	nop

0014c270 <sd_rpbuf_dequeue>:

sd_rpbuf_t *sd_rpbuf_dequeue(sd_rpbuf_queue_t *rq)
{
  14c270:	b430      	push	{r4, r5}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c272:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c276:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14c278:	bf48      	it	mi
  14c27a:	2400      	movmi	r4, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c27c:	d401      	bmi.n	14c282 <sd_rpbuf_dequeue+0x12>
    __asm__ volatile("cpsid i");
  14c27e:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14c280:	2401      	movs	r4, #1
    if (list->next != list) {
  14c282:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  14c284:	2201      	movs	r2, #1
  14c286:	60c2      	str	r2, [r0, #12]
  14c288:	4298      	cmp	r0, r3
    item->prev = item->next = 0;
  14c28a:	bf17      	itett	ne
  14c28c:	2200      	movne	r2, #0
    spin_lock_saved_state_t state;
    sd_rpbuf_t *rpbuf = NULL;

    spin_lock_irqsave(&rq->queue_lock, state);
    rpbuf = list_remove_head_type(&rq->queue_head, sd_rpbuf_t, buf_node);
  14c28e:	2300      	moveq	r3, #0
    item->next->prev = item->prev;
  14c290:	6859      	ldrne	r1, [r3, #4]
  14c292:	681d      	ldrne	r5, [r3, #0]
  14c294:	bf1e      	ittt	ne
  14c296:	600d      	strne	r5, [r1, #0]
    item->prev->next = item->next;
  14c298:	681d      	ldrne	r5, [r3, #0]
  14c29a:	6069      	strne	r1, [r5, #4]
    *lock = 0;
  14c29c:	f04f 0100 	mov.w	r1, #0
    item->prev = item->next = 0;
  14c2a0:	bf18      	it	ne
  14c2a2:	e9c3 2200 	strdne	r2, r2, [r3]
    rq->buf_num--;
  14c2a6:	6882      	ldr	r2, [r0, #8]
  14c2a8:	3a01      	subs	r2, #1
  14c2aa:	e9c0 2102 	strd	r2, r1, [r0, #8]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14c2ae:	b104      	cbz	r4, 14c2b2 <sd_rpbuf_dequeue+0x42>
    __asm__ volatile("cpsie i");
  14c2b0:	b662      	cpsie	i
    spin_unlock_irqrestore(&rq->queue_lock, state);

    return rpbuf;
}
  14c2b2:	4618      	mov	r0, r3
  14c2b4:	bc30      	pop	{r4, r5}
  14c2b6:	4770      	bx	r14

0014c2b8 <sd_rpbuf_queue_empty>:
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14c2b8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14c2bc:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14c2c0:	d108      	bne.n	14c2d4 <sd_rpbuf_queue_empty+0x1c>
    __asm__ volatile("cpsid i");
  14c2c2:	b672      	cpsid	i
    return (list->next == list) ? true : false;
  14c2c4:	6842      	ldr	r2, [r0, #4]
    *lock = 0;
  14c2c6:	60c3      	str	r3, [r0, #12]
  14c2c8:	1a10      	subs	r0, r2, r0
  14c2ca:	fab0 f080 	clz	r0, r0
  14c2ce:	0940      	lsrs	r0, r0, #5
    __asm__ volatile("cpsie i");
  14c2d0:	b662      	cpsie	i
  14c2d2:	4770      	bx	r14
  14c2d4:	6843      	ldr	r3, [r0, #4]
  14c2d6:	2200      	movs	r2, #0
  14c2d8:	60c2      	str	r2, [r0, #12]
  14c2da:	1a18      	subs	r0, r3, r0
  14c2dc:	fab0 f080 	clz	r0, r0
  14c2e0:	0940      	lsrs	r0, r0, #5
    spin_lock_irqsave(&rq->queue_lock, state);
    ret = list_is_empty(&rq->queue_head);
    spin_unlock_irqrestore(&rq->queue_lock, state);

    return ret;
}
  14c2e2:	4770      	bx	r14

0014c2e4 <init_rpmsg_dev_config.part.0>:
}

/*
 * get shm and dcf config from chipcfg like dts db
 */
struct rpmsg_dev_config *init_rpmsg_dev_config(void)
  14c2e4:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
    uint32_t actual_size;

    if (rpmsg_cfg)
        return rpmsg_cfg;

    rpmsg_cfg_num = share_mem_list.share_mem_num;
  14c2e8:	f643 3854 	movw	r8, #15188	; 0x3b54
  14c2ec:	2302      	movs	r3, #2
    rpmsg_cfg = malloc(rpmsg_cfg_num * sizeof(struct rpmsg_dev_config));
  14c2ee:	2101      	movs	r1, #1
    rpmsg_cfg_num = share_mem_list.share_mem_num;
  14c2f0:	f2c0 0816 	movt	r8, #22
    rpmsg_cfg = malloc(rpmsg_cfg_num * sizeof(struct rpmsg_dev_config));
  14c2f4:	2030      	movs	r0, #48	; 0x30
  14c2f6:	f643 3950 	movw	r9, #15184	; 0x3b50
    rpmsg_cfg_num = share_mem_list.share_mem_num;
  14c2fa:	f8c8 3000 	str.w	r3, [r8]
    rpmsg_cfg = malloc(rpmsg_cfg_num * sizeof(struct rpmsg_dev_config));
  14c2fe:	f006 fddd 	bl	152ebc <calloc>
  14c302:	f2c0 0916 	movt	r9, #22
  14c306:	f8c9 0000 	str.w	r0, [r9]
  14c30a:	4604      	mov	r4, r0
    if (!rpmsg_cfg) {
  14c30c:	2800      	cmp	r0, #0
  14c30e:	d071      	beq.n	14c3f4 <init_rpmsg_dev_config.part.0+0x110>
  14c310:	f246 67a0 	movw	r7, #26272	; 0x66a0
  14c314:	f246 65f4 	movw	r5, #26356	; 0x66f4
  14c318:	f2c0 0715 	movt	r7, #21
  14c31c:	3418      	adds	r4, #24
    }

    memset(rpmsg_cfg, 0, (rpmsg_cfg_num * sizeof(struct rpmsg_dev_config)));
    pcfg = rpmsg_cfg;

    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c31e:	2600      	movs	r6, #0
  14c320:	f2c0 0515 	movt	r5, #21
  14c324:	f8d7 a004 	ldr.w	r10, [r7, #4]
  14c328:	e017      	b.n	14c35a <init_rpmsg_dev_config.part.0+0x76>
    if ((curr_proc >= DP_CPU_MAX) || (remote_proc >= DP_CPU_MAX))
  14c32a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c32e:	f8d8 2000 	ldr.w	r2, [r8]
    return ((share_mem_list.share_mem_info[id].mid_b == 3) ||
  14c332:	3b03      	subs	r3, #3
  14c334:	2b01      	cmp	r3, #1
  14c336:	bf88      	it	hi
  14c338:	2300      	movhi	r3, #0
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c33a:	f106 0601 	add.w	r6, r6, #1
    return ((share_mem_list.share_mem_info[id].mid_b == 3) ||
  14c33e:	bf98      	it	ls
  14c340:	2301      	movls	r3, #1
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c342:	4296      	cmp	r6, r2

        pcfg->shm_size = actual_size;

        pcfg->is_master = rpmsg_is_master_device(share_mem_list.share_mem_info[i].res_id);
        pcfg->remote_proc = share_mem_list.share_mem_info[i].mid_b;
        pcfg->ext.mbox_dst = pcfg->ext.mbox_src =
  14c344:	f824 1c08 	strh.w	r1, [r4, #-8]
  14c348:	f105 0510 	add.w	r5, r5, #16
    return ((share_mem_list.share_mem_info[id].mid_b == 3) ||
  14c34c:	f804 3c04 	strb.w	r3, [r4, #-4]
  14c350:	f104 0418 	add.w	r4, r4, #24
        pcfg->ext.mbox_dst = pcfg->ext.mbox_src =
  14c354:	f824 1c1e 	strh.w	r1, [r4, #-30]
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c358:	d243      	bcs.n	14c3e2 <init_rpmsg_dev_config.part.0+0xfe>
        pcfg->shm_phys_base = share_mem_list.share_mem_info[i].paddr;
  14c35a:	1d29      	adds	r1, r5, #4
  14c35c:	c90e      	ldmia	r1, {r1, r2, r3}
        pcfg->shm_size = actual_size;
  14c35e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  14c362:	bf28      	it	cs
  14c364:	f44f 1380 	movcs.w	r3, #1048576	; 0x100000
        if (dcf_configs_list.dcf_config[i].res_id == res_id)
  14c368:	4551      	cmp	r1, r10
        pcfg->shm_size = actual_size;
  14c36a:	e944 2305 	strd	r2, r3, [r4, #-20]
        if (dcf_configs_list.dcf_config[i].res_id == res_id)
  14c36e:	d03d      	beq.n	14c3ec <init_rpmsg_dev_config.part.0+0x108>
  14c370:	697b      	ldr	r3, [r7, #20]
  14c372:	4299      	cmp	r1, r3
  14c374:	d028      	beq.n	14c3c8 <init_rpmsg_dev_config.part.0+0xe4>
  14c376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  14c378:	4299      	cmp	r1, r3
    for (i = 0; i < dcf_configs_list.config_num; i++) {
  14c37a:	bf08      	it	eq
  14c37c:	2302      	moveq	r3, #2
        if (dcf_configs_list.dcf_config[i].res_id == res_id)
  14c37e:	d024      	beq.n	14c3ca <init_rpmsg_dev_config.part.0+0xe6>
    return -1;
  14c380:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        pcfg->remote_proc = share_mem_list.share_mem_info[i].mid_b;
  14c384:	7c6b      	ldrb	r3, [r5, #17]
            generate_mbox_addr(share_mem_list.share_mem_info[i].mid_a, share_mem_list.share_mem_info[i].mid_b);
  14c386:	7c2a      	ldrb	r2, [r5, #16]
        pcfg->is_master = rpmsg_is_master_device(share_mem_list.share_mem_info[i].res_id);
  14c388:	f844 0c0c 	str.w	r0, [r4, #-12]
    if (curr_proc == remote_proc)
  14c38c:	429a      	cmp	r2, r3
        pcfg->remote_proc = share_mem_list.share_mem_info[i].mid_b;
  14c38e:	f844 3c18 	str.w	r3, [r4, #-24]
    if (curr_proc == remote_proc)
  14c392:	d0ca      	beq.n	14c32a <init_rpmsg_dev_config.part.0+0x46>
    if ((curr_proc >= DP_CPU_MAX) || (remote_proc >= DP_CPU_MAX))
  14c394:	2b05      	cmp	r3, #5
  14c396:	bfd8      	it	le
  14c398:	2a05      	cmple	r2, #5
  14c39a:	bfcc      	ite	gt
  14c39c:	2101      	movgt	r1, #1
  14c39e:	2100      	movle	r1, #0
  14c3a0:	dcc3      	bgt.n	14c32a <init_rpmsg_dev_config.part.0+0x46>
    b = MAX(curr_proc, remote_proc);
  14c3a2:	4694      	mov	r12, r2
  14c3a4:	429a      	cmp	r2, r3
  14c3a6:	bfb8      	it	lt
  14c3a8:	469c      	movlt	r12, r3
    a = MIN(curr_proc, remote_proc);
  14c3aa:	429a      	cmp	r2, r3
  14c3ac:	bfa8      	it	ge
  14c3ae:	461a      	movge	r2, r3
    while (i < b) {
  14c3b0:	f1bc 0f00 	cmp.w	r12, #0
  14c3b4:	d01c      	beq.n	14c3f0 <init_rpmsg_dev_config.part.0+0x10c>
    int i = 0;
  14c3b6:	4608      	mov	r0, r1
        base += i++;
  14c3b8:	4401      	add	r1, r0
  14c3ba:	3001      	adds	r0, #1
    while (i < b) {
  14c3bc:	4584      	cmp	r12, r0
  14c3be:	d1fb      	bne.n	14c3b8 <init_rpmsg_dev_config.part.0+0xd4>
  14c3c0:	3110      	adds	r1, #16
    return IPCC_ADDR_RPMSG + base + a;
  14c3c2:	4411      	add	r1, r2
  14c3c4:	b289      	uxth	r1, r1
  14c3c6:	e7b2      	b.n	14c32e <init_rpmsg_dev_config.part.0+0x4a>
    for (i = 0; i < dcf_configs_list.config_num; i++) {
  14c3c8:	2301      	movs	r3, #1
            return (dcf_configs_list.dcf_config[i].mid_master == get_curr_proc());
  14c3ca:	eb07 1303 	add.w	r3, r7, r3, lsl #4
  14c3ce:	f893 b012 	ldrb.w	r11, [r3, #18]
    return dcf_get_this_proc();
  14c3d2:	f7f4 fad3 	bl	14097c <dcf_get_this_proc>
            return (dcf_configs_list.dcf_config[i].mid_master == get_curr_proc());
  14c3d6:	ebab 0000 	sub.w	r0, r11, r0
  14c3da:	fab0 f080 	clz	r0, r0
  14c3de:	0940      	lsrs	r0, r0, #5
  14c3e0:	e7d0      	b.n	14c384 <init_rpmsg_dev_config.part.0+0xa0>
        pcfg->pa_spacex = has_cross_mem_space(i);

        dprintf(INFO, "dcf: mbaddr: %x\n", pcfg->ext.mbox_dst);
    }

    return rpmsg_cfg;
  14c3e2:	f8d9 4000 	ldr.w	r4, [r9]
}
  14c3e6:	4620      	mov	r0, r4
  14c3e8:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
    for (i = 0; i < dcf_configs_list.config_num; i++) {
  14c3ec:	2300      	movs	r3, #0
  14c3ee:	e7ec      	b.n	14c3ca <init_rpmsg_dev_config.part.0+0xe6>
    while (i < b) {
  14c3f0:	2110      	movs	r1, #16
  14c3f2:	e7e6      	b.n	14c3c2 <init_rpmsg_dev_config.part.0+0xde>
        dprintf(0, "No memory for rpmsg config db\n");
  14c3f4:	f246 60d4 	movw	r0, #26324	; 0x66d4
  14c3f8:	f2c0 0015 	movt	r0, #21
  14c3fc:	f007 fe7c 	bl	1540f8 <_printf>
  14c400:	e7f1      	b.n	14c3e6 <init_rpmsg_dev_config.part.0+0x102>
  14c402:	bf00      	nop

0014c404 <init_shm_domain_area>:
{
  14c404:	b538      	push	{r3, r4, r5, r14}
        actual_size = share_mem_list.share_mem_info[i].size;
  14c406:	f246 64f4 	movw	r4, #26356	; 0x66f4
        mpu_add_region(region++,
  14c40a:	2300      	movs	r3, #0
{
  14c40c:	4605      	mov	r5, r0
        actual_size = share_mem_list.share_mem_info[i].size;
  14c40e:	f2c0 0415 	movt	r4, #21
        mpu_add_region(region++,
  14c412:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
  14c416:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
  14c41a:	bf28      	it	cs
  14c41c:	f44f 1280 	movcs.w	r2, #1048576	; 0x100000
  14c420:	f7f5 fa64 	bl	1418ec <mpu_add_region>
  14c424:	e9d4 1206 	ldrd	r1, r2, [r4, #24]
  14c428:	2300      	movs	r3, #0
  14c42a:	1c68      	adds	r0, r5, #1
  14c42c:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
  14c430:	bf28      	it	cs
  14c432:	f44f 1280 	movcs.w	r2, #1048576	; 0x100000
  14c436:	f7f5 fa59 	bl	1418ec <mpu_add_region>
}
  14c43a:	1ca8      	adds	r0, r5, #2
  14c43c:	bd38      	pop	{r3, r4, r5, r15}
  14c43e:	bf00      	nop

0014c440 <platform_shm_get_local>:
}

paddr_t platform_shm_get_local(paddr_t remote_pa)
{
    paddr_t local_pa = 0;
    if (IS_PA_FROM_APU(remote_pa))
  14c440:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  14c444:	d81e      	bhi.n	14c484 <platform_shm_get_local+0x44>
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c446:	f643 3254 	movw	r2, #15188	; 0x3b54
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c44a:	f643 3350 	movw	r3, #15184	; 0x3b50
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c44e:	f2c0 0216 	movt	r2, #22
{
  14c452:	b430      	push	{r4, r5}
  14c454:	4604      	mov	r4, r0
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c456:	f2c0 0316 	movt	r3, #22
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c45a:	6810      	ldr	r0, [r2, #0]
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c45c:	681b      	ldr	r3, [r3, #0]
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c45e:	b178      	cbz	r0, 14c480 <platform_shm_get_local+0x40>
  14c460:	2200      	movs	r2, #0
  14c462:	3201      	adds	r2, #1
        if (!pcfg->pa_spacex && MEM_IN_RANGE(pa, pcfg->shm_phys_base, pcfg->shm_size)) {
  14c464:	7d19      	ldrb	r1, [r3, #20]
  14c466:	b931      	cbnz	r1, 14c476 <platform_shm_get_local+0x36>
  14c468:	6859      	ldr	r1, [r3, #4]
  14c46a:	428c      	cmp	r4, r1
  14c46c:	d303      	bcc.n	14c476 <platform_shm_get_local+0x36>
  14c46e:	689d      	ldr	r5, [r3, #8]
  14c470:	4429      	add	r1, r5
  14c472:	428c      	cmp	r4, r1
  14c474:	d308      	bcc.n	14c488 <platform_shm_get_local+0x48>
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c476:	4282      	cmp	r2, r0
  14c478:	f103 0318 	add.w	r3, r3, #24
  14c47c:	d1f1      	bne.n	14c462 <platform_shm_get_local+0x22>
    paddr_t local_pa = 0;
  14c47e:	2000      	movs	r0, #0
    if (local_pa != remote_pa)
        dprintf(INFO, "[%d]import PA: 0x%lx -> 0x%lx\n",
                dcf_get_this_proc(), remote_pa, local_pa);

    return local_pa;
}
  14c480:	bc30      	pop	{r4, r5}
  14c482:	4770      	bx	r14
        local_pa = ap2p(remote_pa);
  14c484:	f002 b866 	b.w	14e554 <ap2p>
        if (!pcfg->pa_spacex && MEM_IN_RANGE(pa, pcfg->shm_phys_base, pcfg->shm_size)) {
  14c488:	4620      	mov	r0, r4
}
  14c48a:	bc30      	pop	{r4, r5}
  14c48c:	4770      	bx	r14
  14c48e:	bf00      	nop

0014c490 <platform_shm_get_remote>:
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c490:	f643 3254 	movw	r2, #15188	; 0x3b54
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c494:	f643 3350 	movw	r3, #15184	; 0x3b50
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c498:	f2c0 0216 	movt	r2, #22

paddr_t platform_shm_get_remote(paddr_t local_pa)
{
  14c49c:	b470      	push	{r4, r5, r6}
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c49e:	6815      	ldr	r5, [r2, #0]
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c4a0:	f2c0 0316 	movt	r3, #22
  14c4a4:	6819      	ldr	r1, [r3, #0]
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c4a6:	b1f5      	cbz	r5, 14c4e6 <platform_shm_get_remote+0x56>
    struct rpmsg_dev_config *pcfg = rpmsg_cfg;
  14c4a8:	460b      	mov	r3, r1
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c4aa:	2200      	movs	r2, #0
  14c4ac:	3201      	adds	r2, #1
        if (pcfg->pa_spacex && MEM_IN_RANGE(pa, pcfg->shm_phys_base, pcfg->shm_size)) {
  14c4ae:	7d1c      	ldrb	r4, [r3, #20]
  14c4b0:	b134      	cbz	r4, 14c4c0 <platform_shm_get_remote+0x30>
  14c4b2:	685c      	ldr	r4, [r3, #4]
  14c4b4:	42a0      	cmp	r0, r4
  14c4b6:	d303      	bcc.n	14c4c0 <platform_shm_get_remote+0x30>
  14c4b8:	689e      	ldr	r6, [r3, #8]
  14c4ba:	4434      	add	r4, r6
  14c4bc:	42a0      	cmp	r0, r4
  14c4be:	d315      	bcc.n	14c4ec <platform_shm_get_remote+0x5c>
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c4c0:	42aa      	cmp	r2, r5
  14c4c2:	f103 0318 	add.w	r3, r3, #24
  14c4c6:	d1f1      	bne.n	14c4ac <platform_shm_get_remote+0x1c>
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c4c8:	2300      	movs	r3, #0
  14c4ca:	3301      	adds	r3, #1
        if (!pcfg->pa_spacex && MEM_IN_RANGE(pa, pcfg->shm_phys_base, pcfg->shm_size)) {
  14c4cc:	7d0c      	ldrb	r4, [r1, #20]
  14c4ce:	b934      	cbnz	r4, 14c4de <platform_shm_get_remote+0x4e>
  14c4d0:	684c      	ldr	r4, [r1, #4]
  14c4d2:	42a0      	cmp	r0, r4
  14c4d4:	d303      	bcc.n	14c4de <platform_shm_get_remote+0x4e>
  14c4d6:	688d      	ldr	r5, [r1, #8]
  14c4d8:	442c      	add	r4, r5
  14c4da:	42a0      	cmp	r0, r4
  14c4dc:	d304      	bcc.n	14c4e8 <platform_shm_get_remote+0x58>
    for (i = 0; i < rpmsg_cfg_num; i++, pcfg++) {
  14c4de:	429a      	cmp	r2, r3
  14c4e0:	f101 0118 	add.w	r1, r1, #24
  14c4e4:	d1f1      	bne.n	14c4ca <platform_shm_get_remote+0x3a>
    paddr_t remote_pa = 0;
  14c4e6:	2000      	movs	r0, #0

    if (local_pa != remote_pa)
        dprintf(INFO, "[%d]export PA: 0x%lx -> 0x%lx\n", dcf_get_this_proc(), local_pa, remote_pa);

    return remote_pa;
}
  14c4e8:	bc70      	pop	{r4, r5, r6}
  14c4ea:	4770      	bx	r14
  14c4ec:	bc70      	pop	{r4, r5, r6}
        remote_pa = p2ap(local_pa);
  14c4ee:	f002 b80d 	b.w	14e50c <p2ap>
  14c4f2:	bf00      	nop

0014c4f4 <platform_get_rpmsg_config>:
    if (rpmsg_cfg)
  14c4f4:	f643 3350 	movw	r3, #15184	; 0x3b50
  14c4f8:	f2c0 0316 	movt	r3, #22

int platform_get_rpmsg_config(struct rpmsg_dev_config **p)
{
  14c4fc:	b510      	push	{r4, r14}
  14c4fe:	4604      	mov	r4, r0
    if (rpmsg_cfg)
  14c500:	6818      	ldr	r0, [r3, #0]
  14c502:	b130      	cbz	r0, 14c512 <platform_get_rpmsg_config+0x1e>
    *p = init_rpmsg_dev_config();
  14c504:	6020      	str	r0, [r4, #0]
    return rpmsg_cfg_num;
  14c506:	f643 3354 	movw	r3, #15188	; 0x3b54
  14c50a:	f2c0 0316 	movt	r3, #22
}
  14c50e:	6818      	ldr	r0, [r3, #0]
  14c510:	bd10      	pop	{r4, r15}
  14c512:	f7ff fee7 	bl	14c2e4 <init_rpmsg_dev_config.part.0>
  14c516:	e7f5      	b.n	14c504 <platform_get_rpmsg_config+0x10>

0014c518 <mbox_init>:

#endif //if defined(CONFIG_SUPPORT_DCF) && (CONFIG_SUPPORT_DCF == 1)

static void *mbox_handle;
void mbox_init(void)
{
  14c518:	b510      	push	{r4, r14}
    hal_mb_cfg_t hal_cfg;

    hal_mb_create_handle(&mbox_handle, RES_MB_MB_MEM);
  14c51a:	f643 344c 	movw	r4, #15180	; 0x3b4c
  14c51e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  14c522:	f2c0 0416 	movt	r4, #22
  14c526:	4620      	mov	r0, r4
{
  14c528:	b090      	sub	sp, #64	; 0x40
    hal_mb_create_handle(&mbox_handle, RES_MB_MB_MEM);
  14c52a:	f6c1 0102 	movt	r1, #6146	; 0x1802
  14c52e:	f001 fdf1 	bl	14e114 <hal_mb_create_handle>
    if (mbox_handle != NULL) {
  14c532:	6820      	ldr	r0, [r4, #0]
  14c534:	b110      	cbz	r0, 14c53c <mbox_init+0x24>
        hal_mb_init(mbox_handle, &hal_cfg);
  14c536:	a901      	add	r1, sp, #4
  14c538:	f001 fdea 	bl	14e110 <hal_mb_init>
    }
}
  14c53c:	b010      	add	sp, #64	; 0x40
  14c53e:	bd10      	pop	{r4, r15}

0014c540 <dcf_init>:
}

static bool dcf_inited;

void dcf_init(void)
{
  14c540:	b510      	push	{r4, r14}
    if (dcf_inited)
  14c542:	f643 3448 	movw	r4, #15176	; 0x3b48
  14c546:	f2c0 0416 	movt	r4, #22
  14c54a:	7823      	ldrb	r3, [r4, #0]
  14c54c:	b103      	cbz	r3, 14c550 <dcf_init+0x10>
    rpmsg_rtos_init();
#endif

#endif
    dcf_inited = true;
}
  14c54e:	bd10      	pop	{r4, r15}
    mbox_init();
  14c550:	f7ff ffe2 	bl	14c518 <mbox_init>
    start_dcf_service();
  14c554:	f000 fa04 	bl	14c960 <start_dcf_service>
    dcf_file_init();
  14c558:	f000 f940 	bl	14c7dc <dcf_file_init>
    rpmsg_rtos_init();
  14c55c:	f000 fb68 	bl	14cc30 <rpmsg_rtos_init>
    dcf_inited = true;
  14c560:	2301      	movs	r3, #1
  14c562:	7023      	strb	r3, [r4, #0]
}
  14c564:	bd10      	pop	{r4, r15}
  14c566:	bf00      	nop

0014c568 <dcf_get_file>:
    return NULL;
}

struct dcf_file *dcf_get_file(int fd)
{
    if (fd >= DCF_MAX_FILES && !dynamic_files)
  14c568:	280f      	cmp	r0, #15
  14c56a:	dd01      	ble.n	14c570 <dcf_get_file+0x8>
        return NULL;
  14c56c:	2000      	movs	r0, #0

    /* TODO: dynamic files */
    ext_fd_start++;

    return NULL;
}
  14c56e:	4770      	bx	r14
        if (strlen(dcf_files[fd].file_name))
  14c570:	f648 2308 	movw	r3, #35336	; 0x8a08
  14c574:	eb00 00c0 	add.w	r0, r0, r0, lsl #3
  14c578:	f2c0 0315 	movt	r3, #21
  14c57c:	00c0      	lsls	r0, r0, #3
  14c57e:	5cc2      	ldrb	r2, [r0, r3]
  14c580:	2a00      	cmp	r2, #0
  14c582:	4418      	add	r0, r3
        return NULL;
  14c584:	bf08      	it	eq
  14c586:	2000      	moveq	r0, #0
  14c588:	4770      	bx	r14
  14c58a:	bf00      	nop

0014c58c <dcf_file_event_cb>:

    return mask;
}

void dcf_file_event_cb(void *ctx, ipcc_event_t e, u32 data)
{
  14c58c:	b510      	push	{r4, r14}
  14c58e:	4604      	mov	r4, r0
    struct dcf_file *file;
    int fd = (int)ctx;

    file = dcf_get_file(fd);
  14c590:	f7ff ffea 	bl	14c568 <dcf_get_file>
    if (!file) {
  14c594:	b150      	cbz	r0, 14c5ac <dcf_file_event_cb+0x20>
        dprintf(0, "This is NULL file\n");
        return;
    }

    switch(e) {
  14c596:	b101      	cbz	r1, 14c59a <dcf_file_event_cb+0xe>
        dcf_handle_pollevent(fd);
        break;
    default:
        break;
    }
}
  14c598:	bd10      	pop	{r4, r15}
        file->rcvevent++;
  14c59a:	8f82      	ldrh	r2, [r0, #60]	; 0x3c
  14c59c:	4603      	mov	r3, r0
        dcf_handle_pollevent(fd);
  14c59e:	4620      	mov	r0, r4
        file->rcvevent++;
  14c5a0:	3201      	adds	r2, #1
}
  14c5a2:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        file->rcvevent++;
  14c5a6:	879a      	strh	r2, [r3, #60]	; 0x3c
        dcf_handle_pollevent(fd);
  14c5a8:	f000 b91e 	b.w	14c7e8 <dcf_handle_pollevent>
        dprintf(0, "This is NULL file\n");
  14c5ac:	f246 7040 	movw	r0, #26432	; 0x6740
  14c5b0:	f2c0 0015 	movt	r0, #21
}
  14c5b4:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        dprintf(0, "This is NULL file\n");
  14c5b8:	f007 bd9e 	b.w	1540f8 <_printf>

0014c5bc <dcf_open>:

int dcf_open(const char *name, unsigned int flags)
{
  14c5bc:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14c5c0:	f648 2408 	movw	r4, #35336	; 0x8a08
  14c5c4:	4606      	mov	r6, r0
  14c5c6:	4688      	mov	r8, r1
  14c5c8:	f2c0 0415 	movt	r4, #21
    for (i = 0; i < DCF_MAX_FILES; i++) {
  14c5cc:	2500      	movs	r5, #0
  14c5ce:	e002      	b.n	14c5d6 <dcf_open+0x1a>
  14c5d0:	3501      	adds	r5, #1
  14c5d2:	2d10      	cmp	r5, #16
  14c5d4:	d01c      	beq.n	14c610 <dcf_open+0x54>
        if (0 == strncmp(dcf_files[i].file_name, name, DCF_NAM_MAX_LEN)) {
  14c5d6:	4620      	mov	r0, r4
  14c5d8:	2210      	movs	r2, #16
  14c5da:	4631      	mov	r1, r6
  14c5dc:	3448      	adds	r4, #72	; 0x48
  14c5de:	f007 fe17 	bl	154210 <strncmp>
  14c5e2:	2800      	cmp	r0, #0
  14c5e4:	d1f4      	bne.n	14c5d0 <dcf_open+0x14>
    struct dcf_file *file;
    int fd;

    fd = find_dcf_fd(name);
    file = dcf_get_file(fd);
  14c5e6:	4628      	mov	r0, r5
  14c5e8:	f7ff ffbe 	bl	14c568 <dcf_get_file>
    if (!file) {
  14c5ec:	4604      	mov	r4, r0
  14c5ee:	2800      	cmp	r0, #0
  14c5f0:	d037      	beq.n	14c662 <dcf_open+0xa6>
        dprintf(0, "file %s not found\n", name);
        return -ENOENT;
    }

    if (file->rpchan) {
  14c5f2:	6b47      	ldr	r7, [r0, #52]	; 0x34
  14c5f4:	b17f      	cbz	r7, 14c616 <dcf_open+0x5a>
        file->refcount++;
  14c5f6:	6b83      	ldr	r3, [r0, #56]	; 0x38
        dprintf(0, "file %s already opened\n", name);
  14c5f8:	f246 7068 	movw	r0, #26472	; 0x6768
  14c5fc:	4631      	mov	r1, r6
  14c5fe:	f2c0 0015 	movt	r0, #21
        file->refcount++;
  14c602:	3301      	adds	r3, #1
  14c604:	63a3      	str	r3, [r4, #56]	; 0x38
        dprintf(0, "file %s already opened\n", name);
  14c606:	f007 fd77 	bl	1540f8 <_printf>
    file->f_state = DCF_FS_OPENED;
    file->f_flags = flags;
    file->refcount++;

    return fd;
}
  14c60a:	4628      	mov	r0, r5
  14c60c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    return -1;
  14c610:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
  14c614:	e7e7      	b.n	14c5e6 <dcf_open+0x2a>
    file->ipdev = ipcc_device_gethandle(file->remote_processor, 5000);
  14c616:	6a40      	ldr	r0, [r0, #36]	; 0x24
  14c618:	f241 3188 	movw	r1, #5000	; 0x1388
  14c61c:	f7fe fffc 	bl	14b618 <ipcc_device_gethandle>
  14c620:	6320      	str	r0, [r4, #48]	; 0x30
    if (!file->ipdev)
  14c622:	b1d8      	cbz	r0, 14c65c <dcf_open+0xa0>
    file->rpchan = ipcc_channel_create(file->ipdev, file->rpmsg_endpoint, file->ns_name, true);
  14c624:	2301      	movs	r3, #1
  14c626:	f104 0210 	add.w	r2, r4, #16
  14c62a:	6a21      	ldr	r1, [r4, #32]
  14c62c:	f7ff f8d8 	bl	14b7e0 <ipcc_channel_create>
  14c630:	6360      	str	r0, [r4, #52]	; 0x34
    if (!file->rpchan) {
  14c632:	b300      	cbz	r0, 14c676 <dcf_open+0xba>
bool ipcc_channel_inq_avail(struct ipcc_channel *ichan);

static inline
int ipcc_channel_register_event_cb(struct ipcc_channel *ichan, ipcc_event_cb_func cb, void *ctx)
{
    ichan->event_cb = cb;
  14c634:	f24c 538d 	movw	r3, #50573	; 0xc58d
    ipcc_channel_start(file->rpchan, NULL);
  14c638:	4639      	mov	r1, r7
  14c63a:	f2c0 0314 	movt	r3, #20
  14c63e:	e9c0 3527 	strd	r3, r5, [r0, #156]	; 0x9c
  14c642:	6b60      	ldr	r0, [r4, #52]	; 0x34
  14c644:	f7ff f94e 	bl	14b8e4 <ipcc_channel_start>
    file->refcount++;
  14c648:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    file->f_state = DCF_FS_OPENED;
  14c64a:	2201      	movs	r2, #1
}
  14c64c:	4628      	mov	r0, r5
    file->f_flags = flags;
  14c64e:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
    file->refcount++;
  14c652:	4413      	add	r3, r2
    file->f_state = DCF_FS_OPENED;
  14c654:	62e2      	str	r2, [r4, #44]	; 0x2c
    file->refcount++;
  14c656:	63a3      	str	r3, [r4, #56]	; 0x38
}
  14c658:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return -ENODEV;
  14c65c:	f06f 0512 	mvn.w	r5, #18
  14c660:	e7d3      	b.n	14c60a <dcf_open+0x4e>
        dprintf(0, "file %s not found\n", name);
  14c662:	f246 7054 	movw	r0, #26452	; 0x6754
  14c666:	4631      	mov	r1, r6
  14c668:	f2c0 0015 	movt	r0, #21
  14c66c:	f007 fd44 	bl	1540f8 <_printf>
        return -ENOENT;
  14c670:	f06f 0501 	mvn.w	r5, #1
  14c674:	e7c9      	b.n	14c60a <dcf_open+0x4e>
        dprintf(0, "%s already opened\n", name);
  14c676:	f246 7080 	movw	r0, #26496	; 0x6780
  14c67a:	4631      	mov	r1, r6
  14c67c:	f2c0 0015 	movt	r0, #21
  14c680:	f007 fd3a 	bl	1540f8 <_printf>
        return -EIO;
  14c684:	f06f 0504 	mvn.w	r5, #4
  14c688:	e7bf      	b.n	14c60a <dcf_open+0x4e>
  14c68a:	bf00      	nop

0014c68c <dcf_close>:

int dcf_close(int fd)
{
  14c68c:	b538      	push	{r3, r4, r5, r14}
  14c68e:	4601      	mov	r1, r0
    struct dcf_file *file;

    file = dcf_get_file(fd);
  14c690:	f7ff ff6a 	bl	14c568 <dcf_get_file>
    if (!file) {
  14c694:	b310      	cbz	r0, 14c6dc <dcf_close+0x50>
        dprintf(0, "fd=%d not exist\n", fd);
        return -EBADF;
    }

    if (file->f_state != DCF_FS_OPENED) {
  14c696:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  14c698:	4604      	mov	r4, r0
  14c69a:	2b01      	cmp	r3, #1
  14c69c:	d115      	bne.n	14c6ca <dcf_close+0x3e>
        dprintf(0, "fd=%d is not open\n", fd);
        return -ENOENT;
    }

    if (--file->refcount)
  14c69e:	6b85      	ldr	r5, [r0, #56]	; 0x38
  14c6a0:	3d01      	subs	r5, #1
  14c6a2:	6385      	str	r5, [r0, #56]	; 0x38
  14c6a4:	b975      	cbnz	r5, 14c6c4 <dcf_close+0x38>
        return 0;

    /* TODO: check any read/write activity on this */
    if (file->rpchan) {
  14c6a6:	6b40      	ldr	r0, [r0, #52]	; 0x34
  14c6a8:	b130      	cbz	r0, 14c6b8 <dcf_close+0x2c>
        ipcc_channel_stop(file->rpchan);
  14c6aa:	f7ff f945 	bl	14b938 <ipcc_channel_stop>
        ipcc_channel_destroy(file->rpchan);
  14c6ae:	6b60      	ldr	r0, [r4, #52]	; 0x34
  14c6b0:	f7ff f8fc 	bl	14b8ac <ipcc_channel_destroy>
        file->rpchan = NULL;
        file->ipdev = NULL;
  14c6b4:	e9c4 550c 	strd	r5, r5, [r4, #48]	; 0x30
    }
    file->f_state = DCF_FS_CLOSED;
    file->f_flags = 0;
  14c6b8:	2300      	movs	r3, #0
  14c6ba:	2202      	movs	r2, #2
  14c6bc:	e9c4 320a 	strd	r3, r2, [r4, #40]	; 0x28

    return 0;
}
  14c6c0:	4628      	mov	r0, r5
  14c6c2:	bd38      	pop	{r3, r4, r5, r15}
        return 0;
  14c6c4:	2500      	movs	r5, #0
}
  14c6c6:	4628      	mov	r0, r5
  14c6c8:	bd38      	pop	{r3, r4, r5, r15}
        dprintf(0, "fd=%d is not open\n", fd);
  14c6ca:	f246 702c 	movw	r0, #26412	; 0x672c
        return -ENOENT;
  14c6ce:	f06f 0501 	mvn.w	r5, #1
        dprintf(0, "fd=%d is not open\n", fd);
  14c6d2:	f2c0 0015 	movt	r0, #21
  14c6d6:	f007 fd0f 	bl	1540f8 <_printf>
        return -ENOENT;
  14c6da:	e7f1      	b.n	14c6c0 <dcf_close+0x34>
        dprintf(0, "fd=%d not exist\n", fd);
  14c6dc:	f246 7018 	movw	r0, #26392	; 0x6718
        return -EBADF;
  14c6e0:	f06f 0508 	mvn.w	r5, #8
        dprintf(0, "fd=%d not exist\n", fd);
  14c6e4:	f2c0 0015 	movt	r0, #21
  14c6e8:	f007 fd06 	bl	1540f8 <_printf>
        return -EBADF;
  14c6ec:	e7e8      	b.n	14c6c0 <dcf_close+0x34>
  14c6ee:	bf00      	nop

0014c6f0 <dcf_read>:

int dcf_read(int fd, void *mem, size_t len)
{
  14c6f0:	b530      	push	{r4, r5, r14}
#endif
    int size = len;
    int block = DCF_BLOCK;
    int ret = 0;

    if (len > DCF_MSG_MAX_DLEN) {
  14c6f2:	2a78      	cmp	r2, #120	; 0x78
{
  14c6f4:	4605      	mov	r5, r0
  14c6f6:	b085      	sub	sp, #20
    int size = len;
  14c6f8:	9203      	str	r2, [sp, #12]
    if (len > DCF_MSG_MAX_DLEN) {
  14c6fa:	d827      	bhi.n	14c74c <dcf_read+0x5c>
  14c6fc:	4674      	mov	r4, r14
        dprintf(0, "fd=%d len is too big\n", fd);
        return -EFBIG;
    }

    file = dcf_get_file(fd);
  14c6fe:	f7ff ff33 	bl	14c568 <dcf_get_file>
    if (!file) {
  14c702:	b368      	cbz	r0, 14c760 <dcf_read+0x70>
        dprintf(0, "fd=%d not exist\n", fd);
        return -EBADF;
    }

    ASSERT(file->f_state == DCF_FS_OPENED);
  14c704:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  14c706:	2b01      	cmp	r3, #1
  14c708:	d10f      	bne.n	14c72a <dcf_read+0x3a>

    if (file->f_flags & O_NONBLOCK)
  14c70a:	6a84      	ldr	r4, [r0, #40]	; 0x28
        block = 0;

    ret = ipcc_channel_recvfrom(file->rpchan, NULL, msg, &size, block);
  14c70c:	460a      	mov	r2, r1
  14c70e:	6b40      	ldr	r0, [r0, #52]	; 0x34
  14c710:	ab03      	add	r3, sp, #12
  14c712:	2100      	movs	r1, #0
    if (file->f_flags & O_NONBLOCK)
  14c714:	f484 7480 	eor.w	r4, r4, #256	; 0x100
  14c718:	f344 2400 	sbfx	r4, r4, #8, #1
    ret = ipcc_channel_recvfrom(file->rpchan, NULL, msg, &size, block);
  14c71c:	9400      	str	r4, [sp, #0]
  14c71e:	f7ff f955 	bl	14b9cc <ipcc_channel_recvfrom>
    if (ret == 0) {
  14c722:	b900      	cbnz	r0, 14c726 <dcf_read+0x36>
#if CONFIG_HAS_DCF_MSGHDR
        size -= DCF_MSG_HLEN;
        memcpy(mem, msg->data, size);
#endif
        return size;
  14c724:	9803      	ldr	r0, [sp, #12]
    }

    return ret;
}
  14c726:	b005      	add	sp, #20
  14c728:	bd30      	pop	{r4, r5, r15}
    ASSERT(file->f_state == DCF_FS_OPENED);
  14c72a:	f246 73dc 	movw	r3, #26588	; 0x67dc
  14c72e:	f246 72ac 	movw	r2, #26540	; 0x67ac
  14c732:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14c736:	f2c0 0315 	movt	r3, #21
  14c73a:	4620      	mov	r0, r4
  14c73c:	f2c0 0215 	movt	r2, #21
  14c740:	9300      	str	r3, [sp, #0]
  14c742:	f2c0 0115 	movt	r1, #21
  14c746:	23df      	movs	r3, #223	; 0xdf
  14c748:	f006 fab4 	bl	152cb4 <_panic>
        dprintf(0, "fd=%d len is too big\n", fd);
  14c74c:	f246 7094 	movw	r0, #26516	; 0x6794
  14c750:	4629      	mov	r1, r5
  14c752:	f2c0 0015 	movt	r0, #21
  14c756:	f007 fccf 	bl	1540f8 <_printf>
        return -EFBIG;
  14c75a:	f06f 001a 	mvn.w	r0, #26
  14c75e:	e7e2      	b.n	14c726 <dcf_read+0x36>
        dprintf(0, "fd=%d not exist\n", fd);
  14c760:	f246 7018 	movw	r0, #26392	; 0x6718
  14c764:	4629      	mov	r1, r5
  14c766:	f2c0 0015 	movt	r0, #21
  14c76a:	f007 fcc5 	bl	1540f8 <_printf>
        return -EBADF;
  14c76e:	f06f 0008 	mvn.w	r0, #8
  14c772:	e7d8      	b.n	14c726 <dcf_read+0x36>

0014c774 <dcf_write>:
#endif
    int size = len;
    int block = DCF_BLOCK;
    int ret = 0;

    if (len > DCF_MSG_MAX_DLEN) {
  14c774:	2a78      	cmp	r2, #120	; 0x78
{
  14c776:	b530      	push	{r4, r5, r14}
  14c778:	4605      	mov	r5, r0
  14c77a:	b083      	sub	sp, #12
    if (len > DCF_MSG_MAX_DLEN) {
  14c77c:	d81a      	bhi.n	14c7b4 <dcf_write+0x40>
  14c77e:	4614      	mov	r4, r2
        dprintf(0, "fd=%d len is too big\n", fd);
        return -EFBIG;
    }

    file = dcf_get_file(fd);
  14c780:	f7ff fef2 	bl	14c568 <dcf_get_file>
    if (!file) {
  14c784:	b300      	cbz	r0, 14c7c8 <dcf_write+0x54>
        dprintf(0, "fd=%d not exist\n", fd);
        return -EBADF;
    }

    if (file->f_state != DCF_FS_OPENED)
  14c786:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  14c788:	2b01      	cmp	r3, #1
  14c78a:	d110      	bne.n	14c7ae <dcf_write+0x3a>
    DCF_MSG_INIT_HDR(msg, COMM_MSG_CORE, len, DCF_MSGF_STD);
    memcpy(msg->data, mem, len);
    size += DCF_MSG_HLEN;
#endif

    if (file->f_flags & O_NONBLOCK)
  14c78c:	6a85      	ldr	r5, [r0, #40]	; 0x28
        block = 0;

    ret = ipcc_channel_sendto(file->rpchan, file->rpmsg_endpoint, msg, size, block);
  14c78e:	460a      	mov	r2, r1
  14c790:	6a01      	ldr	r1, [r0, #32]
  14c792:	4623      	mov	r3, r4
  14c794:	6b40      	ldr	r0, [r0, #52]	; 0x34
    if (file->f_flags & O_NONBLOCK)
  14c796:	f485 7580 	eor.w	r5, r5, #256	; 0x100
  14c79a:	f345 2500 	sbfx	r5, r5, #8, #1
    ret = ipcc_channel_sendto(file->rpchan, file->rpmsg_endpoint, msg, size, block);
  14c79e:	9500      	str	r5, [sp, #0]
  14c7a0:	f7ff f8f0 	bl	14b984 <ipcc_channel_sendto>

    return (ret == 0) ? (int)len : ret;
  14c7a4:	2800      	cmp	r0, #0
  14c7a6:	bf08      	it	eq
  14c7a8:	4620      	moveq	r0, r4
}
  14c7aa:	b003      	add	sp, #12
  14c7ac:	bd30      	pop	{r4, r5, r15}
        return -ENOENT;
  14c7ae:	f06f 0001 	mvn.w	r0, #1
  14c7b2:	e7fa      	b.n	14c7aa <dcf_write+0x36>
        dprintf(0, "fd=%d len is too big\n", fd);
  14c7b4:	f246 7094 	movw	r0, #26516	; 0x6794
  14c7b8:	4629      	mov	r1, r5
  14c7ba:	f2c0 0015 	movt	r0, #21
  14c7be:	f007 fc9b 	bl	1540f8 <_printf>
        return -EFBIG;
  14c7c2:	f06f 001a 	mvn.w	r0, #26
  14c7c6:	e7f0      	b.n	14c7aa <dcf_write+0x36>
        dprintf(0, "fd=%d not exist\n", fd);
  14c7c8:	f246 7018 	movw	r0, #26392	; 0x6718
  14c7cc:	4629      	mov	r1, r5
  14c7ce:	f2c0 0015 	movt	r0, #21
  14c7d2:	f007 fc91 	bl	1540f8 <_printf>
        return -EBADF;
  14c7d6:	f06f 0008 	mvn.w	r0, #8
  14c7da:	e7e6      	b.n	14c7aa <dcf_write+0x36>

0014c7dc <dcf_file_init>:
}

void dcf_select_init(void);

int dcf_file_init(void)
{
  14c7dc:	b508      	push	{r3, r14}
    dcf_select_init();
  14c7de:	f000 f83d 	bl	14c85c <dcf_select_init>

    return 0;
}
  14c7e2:	2000      	movs	r0, #0
  14c7e4:	bd08      	pop	{r3, r15}
  14c7e6:	bf00      	nop

0014c7e8 <dcf_handle_pollevent>:

    return num;
}

int dcf_handle_pollevent(int fd)
{
  14c7e8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    struct select_cb *scb;
    struct pollfd *pf;
    unsigned int i;

    mutex_acquire_timeout(&scb_lock, INFINITE_TIME);
    list_for_every_entry(&scb_list, scb, struct select_cb, node) {
  14c7ea:	f643 3658 	movw	r6, #15192	; 0x3b58
{
  14c7ee:	4605      	mov	r5, r0
    mutex_acquire_timeout(&scb_lock, INFINITE_TIME);
  14c7f0:	f643 3060 	movw	r0, #15200	; 0x3b60
    list_for_every_entry(&scb_list, scb, struct select_cb, node) {
  14c7f4:	f2c0 0616 	movt	r6, #22
    mutex_acquire_timeout(&scb_lock, INFINITE_TIME);
  14c7f8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14c7fc:	f2c0 0016 	movt	r0, #22
  14c800:	f002 fce4 	bl	14f1cc <mutex_acquire_timeout>
    list_for_every_entry(&scb_list, scb, struct select_cb, node) {
  14c804:	6874      	ldr	r4, [r6, #4]
  14c806:	42b4      	cmp	r4, r6
  14c808:	d020      	beq.n	14c84c <dcf_handle_pollevent+0x64>
        if (scb->signalled == 0) {
            for (i = 0, pf = scb->fds; i < scb->nfds; i++, pf++) {
                if ((pf->fd == fd) && (pf->events & POLLMASK_DEFAULT)) {
                    dprintf(2, "poll fd %d event signalled\n", fd);
                    scb->signalled = 1;
  14c80a:	2701      	movs	r7, #1
  14c80c:	e002      	b.n	14c814 <dcf_handle_pollevent+0x2c>
    list_for_every_entry(&scb_list, scb, struct select_cb, node) {
  14c80e:	6864      	ldr	r4, [r4, #4]
  14c810:	42b4      	cmp	r4, r6
  14c812:	d01b      	beq.n	14c84c <dcf_handle_pollevent+0x64>
        if (scb->signalled == 0) {
  14c814:	6923      	ldr	r3, [r4, #16]
  14c816:	2b00      	cmp	r3, #0
  14c818:	d1f9      	bne.n	14c80e <dcf_handle_pollevent+0x26>
            for (i = 0, pf = scb->fds; i < scb->nfds; i++, pf++) {
  14c81a:	e9d4 1002 	ldrd	r1, r0, [r4, #8]
  14c81e:	b918      	cbnz	r0, 14c828 <dcf_handle_pollevent+0x40>
  14c820:	e7f5      	b.n	14c80e <dcf_handle_pollevent+0x26>
  14c822:	3301      	adds	r3, #1
  14c824:	4283      	cmp	r3, r0
  14c826:	d0f2      	beq.n	14c80e <dcf_handle_pollevent+0x26>
                if ((pf->fd == fd) && (pf->events & POLLMASK_DEFAULT)) {
  14c828:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
  14c82c:	42aa      	cmp	r2, r5
  14c82e:	d1f8      	bne.n	14c822 <dcf_handle_pollevent+0x3a>
  14c830:	eb01 02c3 	add.w	r2, r1, r3, lsl #3
  14c834:	8892      	ldrh	r2, [r2, #4]
  14c836:	0792      	lsls	r2, r2, #30
  14c838:	d0f3      	beq.n	14c822 <dcf_handle_pollevent+0x3a>
                    scb->signalled = 1;
  14c83a:	6127      	str	r7, [r4, #16]
                    break;
                }
            }

            if (scb->signalled) {
                sem_post(&scb->sem, false);
  14c83c:	f104 0018 	add.w	r0, r4, #24
  14c840:	2100      	movs	r1, #0
  14c842:	f003 fccf 	bl	1501e4 <sem_post>
    list_for_every_entry(&scb_list, scb, struct select_cb, node) {
  14c846:	6864      	ldr	r4, [r4, #4]
  14c848:	42b4      	cmp	r4, r6
  14c84a:	d1e3      	bne.n	14c814 <dcf_handle_pollevent+0x2c>
            }
        }
    }
    mutex_release(&scb_lock);
  14c84c:	f643 3060 	movw	r0, #15200	; 0x3b60
  14c850:	f2c0 0016 	movt	r0, #22
  14c854:	f002 fce6 	bl	14f224 <mutex_release>

    return 0;
}
  14c858:	2000      	movs	r0, #0
  14c85a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0014c85c <dcf_select_init>:
    list->prev = list->next = list;
  14c85c:	f643 3358 	movw	r3, #15192	; 0x3b58
}

void dcf_select_init(void)
{
    list_initialize(&scb_list);
    mutex_init(&scb_lock);
  14c860:	f643 3060 	movw	r0, #15200	; 0x3b60
  14c864:	f2c0 0316 	movt	r3, #22
  14c868:	f2c0 0016 	movt	r0, #22
  14c86c:	e9c3 3300 	strd	r3, r3, [r3]
  14c870:	f002 bc72 	b.w	14f158 <mutex_init>

0014c874 <dcf_get_service_handle>:

static struct ipcc_service services[MAX_DCF_SERVICES];

ipcc_service_handle_t dcf_get_service_handle(int rproc)
{
    if (rproc > MAX_DCF_SERVICES) {
  14c874:	2806      	cmp	r0, #6
{
  14c876:	b508      	push	{r3, r14}
        dprintf(0, "rproc %d exceed limit service\n", rproc);
        return NULL;
    }

    return &services[rproc];
  14c878:	bfde      	ittt	le
  14c87a:	f643 337c 	movwle	r3, #15228	; 0x3b7c
  14c87e:	f2c0 0316 	movtle	r3, #22
  14c882:	eb03 1080 	addle.w	r0, r3, r0, lsl #6
    if (rproc > MAX_DCF_SERVICES) {
  14c886:	dc00      	bgt.n	14c88a <dcf_get_service_handle+0x16>
}
  14c888:	bd08      	pop	{r3, r15}
  14c88a:	4601      	mov	r1, r0
        dprintf(0, "rproc %d exceed limit service\n", rproc);
  14c88c:	f246 70fc 	movw	r0, #26620	; 0x67fc
  14c890:	f2c0 0015 	movt	r0, #21
  14c894:	f007 fc30 	bl	1540f8 <_printf>
        return NULL;
  14c898:	2000      	movs	r0, #0
}
  14c89a:	bd08      	pop	{r3, r15}

0014c89c <ipcc_start_service>:

    return hserver;
}

void ipcc_start_service(int rproc)
{
  14c89c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    struct ipcc_device *dev = ipcc_device_gethandle(rproc, 5000);
  14c8a0:	f241 3188 	movw	r1, #5000	; 0x1388
{
  14c8a4:	4607      	mov	r7, r0
    struct ipcc_device *dev = ipcc_device_gethandle(rproc, 5000);
  14c8a6:	f7fe feb7 	bl	14b618 <ipcc_device_gethandle>
    ipcc_service_handle_t hserver;

    if (!dev)
  14c8aa:	b1d0      	cbz	r0, 14c8e2 <ipcc_start_service+0x46>
    int rproc = ipcc_device_get_rproc(dev);
  14c8ac:	f8d0 9010 	ldr.w	r9, [r0, #16]
    if (!services[rproc].rpdev) {
  14c8b0:	f643 347c 	movw	r4, #15228	; 0x3b7c
  14c8b4:	4606      	mov	r6, r0
  14c8b6:	f2c0 0416 	movt	r4, #22
  14c8ba:	ea4f 1889 	mov.w	r8, r9, lsl #6
  14c8be:	eb04 0508 	add.w	r5, r4, r8
  14c8c2:	6869      	ldr	r1, [r5, #4]
  14c8c4:	b979      	cbnz	r1, 14c8e6 <ipcc_start_service+0x4a>
        memset(hserver, 0, sizeof(*hserver));
  14c8c6:	2240      	movs	r2, #64	; 0x40
  14c8c8:	4628      	mov	r0, r5
  14c8ca:	f006 ebd8 	blx	15307c <memset>
        hserver->rpdev = dev;
  14c8ce:	606e      	str	r6, [r5, #4]
    if (!hserver) {
        printf("Not found rproc %d service\n", rproc);
        return;
    }

    if (hserver->ready)
  14c8d0:	f895 a00c 	ldrb.w	r10, [r5, #12]
        hserver->rproc = rproc;
  14c8d4:	f844 9008 	str.w	r9, [r4, r8]
        hserver->capabilities = 0xF;
  14c8d8:	230f      	movs	r3, #15
  14c8da:	60ab      	str	r3, [r5, #8]
    if (hserver->ready)
  14c8dc:	f1ba 0f00 	cmp.w	r10, #0
  14c8e0:	d00a      	beq.n	14c8f8 <ipcc_start_service+0x5c>
    hserver->capabilities |= 0x20;
#endif
    hserver->rpmsg_dev = dcf_get_raw_device(rproc);

    hserver->ready = true;
}
  14c8e2:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        printf("Not found rproc %d service\n", rproc);
  14c8e6:	f646 001c 	movw	r0, #26652	; 0x681c
  14c8ea:	4639      	mov	r1, r7
  14c8ec:	f2c0 0015 	movt	r0, #21
}
  14c8f0:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
        printf("Not found rproc %d service\n", rproc);
  14c8f4:	f007 bc00 	b.w	1540f8 <_printf>
    if (rproc != dcf_get_this_proc()) {
  14c8f8:	f7f4 f840 	bl	14097c <dcf_get_this_proc>
  14c8fc:	42b8      	cmp	r0, r7
  14c8fe:	d017      	beq.n	14c930 <ipcc_start_service+0x94>
        ipcc_rpc_client_init(&hserver->rpc_client, dev, IPCC_RPC_CLIENT_EPT, IPCC_RPC_MAIN_EPT);
  14c900:	f108 0034 	add.w	r0, r8, #52	; 0x34
  14c904:	2310      	movs	r3, #16
        ipcc_rpc_server_init(&hserver->rpc_server, dev, IPCC_RPC_MAIN_EPT, 0);
  14c906:	f108 0914 	add.w	r9, r8, #20
        ipcc_rpc_client_init(&hserver->rpc_client, dev, IPCC_RPC_CLIENT_EPT, IPCC_RPC_MAIN_EPT);
  14c90a:	220e      	movs	r2, #14
  14c90c:	4631      	mov	r1, r6
        ipcc_rpc_server_init(&hserver->rpc_server, dev, IPCC_RPC_MAIN_EPT, 0);
  14c90e:	44a1      	add	r9, r4
        ipcc_rpc_client_init(&hserver->rpc_client, dev, IPCC_RPC_CLIENT_EPT, IPCC_RPC_MAIN_EPT);
  14c910:	4420      	add	r0, r4
  14c912:	f7ff f8b7 	bl	14ba84 <ipcc_rpc_client_init>
        ipcc_rpc_server_init(&hserver->rpc_server, dev, IPCC_RPC_MAIN_EPT, 0);
  14c916:	4653      	mov	r3, r10
  14c918:	4631      	mov	r1, r6
  14c91a:	2210      	movs	r2, #16
  14c91c:	4648      	mov	r0, r9
  14c91e:	f7ff f9d9 	bl	14bcd4 <ipcc_rpc_server_init>
        ipcc_rpc_server_start(&hserver->rpc_server);
  14c922:	4648      	mov	r0, r9
  14c924:	f7ff fa24 	bl	14bd70 <ipcc_rpc_server_start>
        hserver->capabilities |= 0x40;
  14c928:	68ab      	ldr	r3, [r5, #8]
  14c92a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  14c92e:	60ab      	str	r3, [r5, #8]
    if (rproc > MAX_DCF_SERVICES) {
  14c930:	2f06      	cmp	r7, #6
  14c932:	dc0a      	bgt.n	14c94a <ipcc_start_service+0xae>
ipcc_service_handle_t dcf_get_service_handle(int rproc);
inline static struct rpmsg_dcf_instance *dcf_get_raw_device(int rproc)
{
    ipcc_service_handle_t h = dcf_get_service_handle(rproc);

    return h->rpdev ? h->rpdev->rpmsg_dev : NULL;
  14c934:	eb04 1787 	add.w	r7, r4, r7, lsl #6
  14c938:	687b      	ldr	r3, [r7, #4]
  14c93a:	b103      	cbz	r3, 14c93e <ipcc_start_service+0xa2>
  14c93c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    hserver->ready = true;
  14c93e:	2201      	movs	r2, #1
    hserver->rpmsg_dev = dcf_get_raw_device(rproc);
  14c940:	4444      	add	r4, r8
  14c942:	63e3      	str	r3, [r4, #60]	; 0x3c
    hserver->ready = true;
  14c944:	7322      	strb	r2, [r4, #12]
}
  14c946:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        dprintf(0, "rproc %d exceed limit service\n", rproc);
  14c94a:	f246 70fc 	movw	r0, #26620	; 0x67fc
  14c94e:	4639      	mov	r1, r7
  14c950:	f2c0 0015 	movt	r0, #21
  14c954:	f007 fbd0 	bl	1540f8 <_printf>
  14c958:	2300      	movs	r3, #0
  14c95a:	685b      	ldr	r3, [r3, #4]
  14c95c:	deff      	udf	#255	; 0xff
  14c95e:	bf00      	nop

0014c960 <start_dcf_service>:

/* to register signal event callback */
#include <sys_diagnosis.h>

void start_dcf_service(void)
{
  14c960:	b530      	push	{r4, r5, r14}
  14c962:	f249 04a8 	movw	r4, #37032	; 0x90a8
  14c966:	b083      	sub	sp, #12
  14c968:	f2c0 0415 	movt	r4, #21
  14c96c:	f104 05a8 	add.w	r5, r4, #168	; 0xa8
    dprintf(2, "[%lld] %s: enter\n", current_time_hires(), __func__);

    for (i = 0; i < MAX_DCF_SERVICES; i++) {
        conf = &ipcc_instances[i];
        if (conf->devname[0]) {
            ipcc_device_probe(conf);
  14c970:	4620      	mov	r0, r4
        if (conf->devname[0]) {
  14c972:	7823      	ldrb	r3, [r4, #0]
  14c974:	b13b      	cbz	r3, 14c986 <start_dcf_service+0x26>
            ipcc_device_probe(conf);
  14c976:	f7fe fe77 	bl	14b668 <ipcc_device_probe>
            ipcc_start_service(conf->rproc);
  14c97a:	6920      	ldr	r0, [r4, #16]
  14c97c:	341c      	adds	r4, #28
  14c97e:	f7ff ff8d 	bl	14c89c <ipcc_start_service>
    for (i = 0; i < MAX_DCF_SERVICES; i++) {
  14c982:	42ac      	cmp	r4, r5
  14c984:	d1f4      	bne.n	14c970 <start_dcf_service+0x10>
    return start_property_service(dom_properties, dom_properties_num);
  14c986:	f249 03a4 	movw	r3, #37028	; 0x90a4
  14c98a:	f648 6088 	movw	r0, #36488	; 0x8e88
  14c98e:	f2c0 0315 	movt	r3, #21
  14c992:	f2c0 0015 	movt	r0, #21
  14c996:	6819      	ldr	r1, [r3, #0]
  14c998:	f005 fa62 	bl	151e60 <start_property_service>

    /*
     *  Only monitor AP1 & AP2 reboot signal from wdt
     * FIXME: MP core not support sysd feature
     */
    if (dcf_get_this_proc() != DP_CR5_MPC)
  14c99c:	f7f3 ffee 	bl	14097c <dcf_get_this_proc>
  14c9a0:	2802      	cmp	r0, #2
  14c9a2:	d00c      	beq.n	14c9be <start_dcf_service+0x5e>
        sysd_register_handler(ipcc_device_reset_cb, NULL, 2, WDT5____ovflow_int, WDT6____ovflow_int);
  14c9a4:	f44f 7399 	mov.w	r3, #306	; 0x132
  14c9a8:	f24b 7089 	movw	r0, #46985	; 0xb789
  14c9ac:	2202      	movs	r2, #2
  14c9ae:	f2c0 0014 	movt	r0, #20
  14c9b2:	9300      	str	r3, [sp, #0]
  14c9b4:	2100      	movs	r1, #0
  14c9b6:	f240 132f 	movw	r3, #303	; 0x12f
  14c9ba:	f000 fb81 	bl	14d0c0 <sysd_register_handler>

    dprintf(1, "[%lld] %s: started\n", current_time_hires(), __func__);
}
  14c9be:	b003      	add	sp, #12
  14c9c0:	bd30      	pop	{r4, r5, r15}
  14c9c2:	bf00      	nop

0014c9c4 <dcf_setup_func>:
#endif

#if CONFIG_USE_IPCC_RPC
int dcf_setup_func(struct ipcc_service *hserver, rpc_server_impl_t *tables, int num)
{
    if (!hserver)
  14c9c4:	b1b8      	cbz	r0, 14c9f6 <dcf_setup_func+0x32>
{
  14c9c6:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
        return DCF_ERR_DEV_ID;

    if (!hserver->ready)
  14c9c8:	7b03      	ldrb	r3, [r0, #12]
  14c9ca:	b18b      	cbz	r3, 14c9f0 <dcf_setup_func+0x2c>
        return ERR_NOT_READY;

    if (hserver->rproc == dcf_get_this_proc()) {
  14c9cc:	6807      	ldr	r7, [r0, #0]
  14c9ce:	4604      	mov	r4, r0
  14c9d0:	4616      	mov	r6, r2
  14c9d2:	460d      	mov	r5, r1
  14c9d4:	f7f3 ffd2 	bl	14097c <dcf_get_this_proc>
  14c9d8:	4287      	cmp	r7, r0
  14c9da:	d007      	beq.n	14c9ec <dcf_setup_func+0x28>
        /* Not allowed to loop RPC, skip this */
        return NO_ERROR;
    }

    return ipcc_rpc_setup_implement(&hserver->rpc_server, tables, num);
  14c9dc:	4632      	mov	r2, r6
  14c9de:	4629      	mov	r1, r5
  14c9e0:	f104 0014 	add.w	r0, r4, #20
}
  14c9e4:	e8bd 40f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r14}
    return ipcc_rpc_setup_implement(&hserver->rpc_server, tables, num);
  14c9e8:	f7ff b9c6 	b.w	14bd78 <ipcc_rpc_setup_implement>
        return NO_ERROR;
  14c9ec:	2000      	movs	r0, #0
}
  14c9ee:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return ERR_NOT_READY;
  14c9f0:	f06f 0002 	mvn.w	r0, #2
}
  14c9f4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return DCF_ERR_DEV_ID;
  14c9f6:	f64e 4074 	movw	r0, #60532	; 0xec74
  14c9fa:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14c9fe:	4770      	bx	r14

0014ca00 <start_ipcc_rpc_service>:
{
  14ca00:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14ca02:	f643 347c 	movw	r4, #15228	; 0x3b7c
  14ca06:	4607      	mov	r7, r0
  14ca08:	460e      	mov	r6, r1
  14ca0a:	f2c0 0416 	movt	r4, #22
  14ca0e:	f504 75c0 	add.w	r5, r4, #384	; 0x180
         dcf_setup_func(&services[i], tables, num);
  14ca12:	4620      	mov	r0, r4
  14ca14:	4632      	mov	r2, r6
  14ca16:	4639      	mov	r1, r7
  14ca18:	3440      	adds	r4, #64	; 0x40
  14ca1a:	f7ff ffd3 	bl	14c9c4 <dcf_setup_func>
    for (i = 0; i < MAX_DCF_SERVICES; i++) {
  14ca1e:	42ac      	cmp	r4, r5
  14ca20:	d1f7      	bne.n	14ca12 <start_ipcc_rpc_service+0x12>
}
  14ca22:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0014ca24 <__dcf_call>:
    return ipcc_rpc_setup_implement(&hserver->rpc_server, &fd, 1);
}

int __dcf_call(struct ipcc_service *hserver, rpc_call_request_t *request, rpc_call_result_t *result, lk_time_t timeout)
{
    if (!hserver)
  14ca24:	b110      	cbz	r0, 14ca2c <__dcf_call+0x8>
        return DCF_ERR_DEV_ID;

    return ipcc_rpc_client_call(&hserver->rpc_client, request, result, timeout);
  14ca26:	3034      	adds	r0, #52	; 0x34
  14ca28:	f7ff b850 	b.w	14bacc <ipcc_rpc_client_call>
}
  14ca2c:	f64e 4074 	movw	r0, #60532	; 0xec74
  14ca30:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  14ca34:	4770      	bx	r14
  14ca36:	bf00      	nop

0014ca38 <rpmsg_new_ept_cb>:
#if LK_DEBUGLEVEL > 0
    const char * op_name = (flags == RL_NS_CREATE) ? "create": "destroy";

    dprintf(INFO, "%s: src: %d name: %s %s\n", __func__, new_ept, new_ept_name, op_name);
#endif
}
  14ca38:	4770      	bx	r14
  14ca3a:	bf00      	nop

0014ca3c <rpmsg_device_main>:

int rpmsg_lite_kick_remote(struct rpmsg_lite_instance *rpmsg_lite_dev);
int rpmsg_echo_loop(struct rpmsg_device *rdev);

int rpmsg_device_main(void *data)
{
  14ca3c:	b570      	push	{r4, r5, r6, r14}
  14ca3e:	4604      	mov	r4, r0
    struct rpmsg_device *rdev = data;
    int myproc = dcf_get_this_proc();
  14ca40:	f7f3 ff9c 	bl	14097c <dcf_get_this_proc>
    int count;

    rdev->shm_virt_base = (void*) p2v(rdev->config.shm_phys_base);
  14ca44:	6863      	ldr	r3, [r4, #4]
  14ca46:	61a3      	str	r3, [r4, #24]
    int myproc = dcf_get_this_proc();
  14ca48:	4606      	mov	r6, r0

    dprintf(INFO, "Starting rpmsg %s virtio%d->%d @%p %p\n",
            rdev->config.is_master ? "master": "slave", myproc,
            rdev->config.remote_proc, rdev->config.shm_phys_base, rdev->shm_virt_base);

    mutex_init(&rdev->lock);
  14ca4a:	f104 0028 	add.w	r0, r4, #40	; 0x28
  14ca4e:	f002 fb83 	bl	14f158 <mutex_init>
    if (rdev->config.is_master) {
  14ca52:	68e3      	ldr	r3, [r4, #12]
  14ca54:	b38b      	cbz	r3, 14caba <rpmsg_device_main+0x7e>
        rdev->rl_instance = rpmsg_lite_master_init(rdev->shm_virt_base, rdev->config.shm_size,
  14ca56:	6822      	ldr	r2, [r4, #0]
  14ca58:	68a1      	ldr	r1, [r4, #8]
  14ca5a:	6923      	ldr	r3, [r4, #16]
  14ca5c:	69a0      	ldr	r0, [r4, #24]
  14ca5e:	f004 f92b 	bl	150cb8 <rpmsg_lite_master_init>
                        rdev->config.remote_proc, rdev->config.ext.init_flags);

        rpmsg_ns_bind(rdev->rl_instance, rpmsg_new_ept_cb, rdev->rl_instance);
  14ca62:	f64c 2139 	movw	r1, #51769	; 0xca39
  14ca66:	f2c0 0114 	movt	r1, #20
        rdev->rl_instance = rpmsg_lite_master_init(rdev->shm_virt_base, rdev->config.shm_size,
  14ca6a:	6460      	str	r0, [r4, #68]	; 0x44
        rpmsg_ns_bind(rdev->rl_instance, rpmsg_new_ept_cb, rdev->rl_instance);
  14ca6c:	4602      	mov	r2, r0
  14ca6e:	f004 fbd7 	bl	151220 <rpmsg_ns_bind>
    }

    dprintf(2, "Waiting for RP%d to get ready...\n", rdev->config.remote_proc);

    /* only remote device wait link up */
    if (!rdev->config.is_master) {
  14ca72:	68e3      	ldr	r3, [r4, #12]
  14ca74:	2514      	movs	r5, #20
  14ca76:	b143      	cbz	r3, 14ca8a <rpmsg_device_main+0x4e>
  14ca78:	e00c      	b.n	14ca94 <rpmsg_device_main+0x58>
        /* wait for 5 sec in startup, then quit loop */
        count = 20;
        while(!rpmsg_lite_is_link_up(rdev->rl_instance))
        {
            count--;
            if (!count) {
  14ca7a:	3d01      	subs	r5, #1
  14ca7c:	d024      	beq.n	14cac8 <rpmsg_device_main+0x8c>
                dprintf(ALWAYS, "rpmsg virtio%d->%d timeout, try later!\n",
                                    myproc, rdev->config.remote_proc);
                goto exit_loop1;
            }

            rpmsg_lite_kick_remote(rdev->rl_instance);
  14ca7e:	6c60      	ldr	r0, [r4, #68]	; 0x44
  14ca80:	f004 f85e 	bl	150b40 <rpmsg_lite_kick_remote>
            env_sleep_msec(200);
  14ca84:	20c8      	movs	r0, #200	; 0xc8
  14ca86:	f004 feeb 	bl	151860 <env_sleep_msec>
        while(!rpmsg_lite_is_link_up(rdev->rl_instance))
  14ca8a:	6c60      	ldr	r0, [r4, #68]	; 0x44
  14ca8c:	f004 f854 	bl	150b38 <rpmsg_lite_is_link_up>
  14ca90:	2800      	cmp	r0, #0
  14ca92:	d0f2      	beq.n	14ca7a <rpmsg_device_main+0x3e>
        }
    }

    dprintf(1, "link %d->%d is up\n", myproc, rdev->config.remote_proc);
    rdev->ready = true;
  14ca94:	2301      	movs	r3, #1
    rpmsg_tty_probe(rdev);
#endif

#if CONFIG_RPMSG_ECHO
    /* rpmsg echo service */
    rpmsg_echo_loop(rdev);
  14ca96:	4620      	mov	r0, r4
    rdev->ready = true;
  14ca98:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    rpmsg_echo_loop(rdev);
  14ca9c:	f000 f918 	bl	14ccd0 <rpmsg_echo_loop>
#endif

exit_loop1:

    rpmsg_lite_deinit(rdev->rl_instance);
  14caa0:	6c60      	ldr	r0, [r4, #68]	; 0x44
  14caa2:	f004 fb33 	bl	15110c <rpmsg_lite_deinit>
    if (rdev->config.shm_phys_base != 0) {
  14caa6:	6863      	ldr	r3, [r4, #4]
    rdev->main_thread = NULL;
  14caa8:	2100      	movs	r1, #0
  14caaa:	61e1      	str	r1, [r4, #28]
    if (rdev->config.shm_phys_base != 0) {
  14caac:	b11b      	cbz	r3, 14cab6 <rpmsg_device_main+0x7a>
        memset(&rdev->config, 0, sizeof(rpmsg_dev_config_t));
  14caae:	4620      	mov	r0, r4
  14cab0:	2218      	movs	r2, #24
  14cab2:	f006 eae4 	blx	15307c <memset>
    free_rpmsg_device(rdev);

    return 0;
}
  14cab6:	2000      	movs	r0, #0
  14cab8:	bd70      	pop	{r4, r5, r6, r15}
        rdev->rl_instance = rpmsg_lite_remote_init(rdev->shm_virt_base,
  14caba:	6922      	ldr	r2, [r4, #16]
  14cabc:	6821      	ldr	r1, [r4, #0]
  14cabe:	69a0      	ldr	r0, [r4, #24]
  14cac0:	f004 fa68 	bl	150f94 <rpmsg_lite_remote_init>
  14cac4:	6460      	str	r0, [r4, #68]	; 0x44
  14cac6:	e7d4      	b.n	14ca72 <rpmsg_device_main+0x36>
                dprintf(ALWAYS, "rpmsg virtio%d->%d timeout, try later!\n",
  14cac8:	f646 004c 	movw	r0, #26700	; 0x684c
  14cacc:	4631      	mov	r1, r6
  14cace:	6822      	ldr	r2, [r4, #0]
  14cad0:	f2c0 0015 	movt	r0, #21
  14cad4:	f007 fb10 	bl	1540f8 <_printf>
                goto exit_loop1;
  14cad8:	e7e2      	b.n	14caa0 <rpmsg_device_main+0x64>
  14cada:	bf00      	nop

0014cadc <rpmsg_device_probe>:

void rpmsg_device_probe(struct rpmsg_dev_config *cfg)
{
  14cadc:	b5f0      	push	{r4, r5, r6, r7, r14}
  14cade:	f643 5500 	movw	r5, #15616	; 0x3d00
  14cae2:	b087      	sub	sp, #28
    struct rpmsg_device *rdev;
    char thread_name[16];

    rdev = find_rpmsg_device_by_remote(cfg->remote_proc);
  14cae4:	6801      	ldr	r1, [r0, #0]
  14cae6:	f2c0 0516 	movt	r5, #22
  14caea:	462e      	mov	r6, r5
  14caec:	462a      	mov	r2, r5
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14caee:	2300      	movs	r3, #0
        if (rdev->config.shm_phys_base && (remote == rdev->config.remote_proc)) {
  14caf0:	6854      	ldr	r4, [r2, #4]
  14caf2:	b114      	cbz	r4, 14cafa <rpmsg_device_probe+0x1e>
  14caf4:	6814      	ldr	r4, [r2, #0]
  14caf6:	42a1      	cmp	r1, r4
  14caf8:	d012      	beq.n	14cb20 <rpmsg_device_probe+0x44>
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14cafa:	3301      	adds	r3, #1
  14cafc:	2b06      	cmp	r3, #6
  14cafe:	f102 024c 	add.w	r2, r2, #76	; 0x4c
  14cb02:	d1f5      	bne.n	14caf0 <rpmsg_device_probe+0x14>
        dprintf(INFO, "rpmsg virtio%d->%d already started \n",
                dcf_get_this_proc(),rdev->config.remote_proc);
        return;
    }

    if (cfg->is_master < 0) {
  14cb04:	68c3      	ldr	r3, [r0, #12]
  14cb06:	4607      	mov	r7, r0
  14cb08:	2b00      	cmp	r3, #0
  14cb0a:	da14      	bge.n	14cb36 <rpmsg_device_probe+0x5a>
        dprintf(ALWAYS, "rpmsg mem(%x %x) defined but disabled in dcf_config\n",
  14cb0c:	e9d7 1201 	ldrd	r1, r2, [r7, #4]
  14cb10:	f646 0074 	movw	r0, #26740	; 0x6874
  14cb14:	f2c0 0015 	movt	r0, #21
  14cb18:	f007 faee 	bl	1540f8 <_printf>

    sprintf(thread_name, "rpmsg-echod/%d", cfg->remote_proc);
    rdev->main_thread = thread_create(thread_name, rpmsg_device_main, rdev,
                                  THREAD_PRI_RPMSGECHO, CONFIG_ECHO_STACK_SIZE);
    thread_resume(rdev->main_thread);
}
  14cb1c:	b007      	add	sp, #28
  14cb1e:	bdf0      	pop	{r4, r5, r6, r7, r15}
    if (rdev && rdev->main_thread) {
  14cb20:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
  14cb24:	eb03 0342 	add.w	r3, r3, r2, lsl #1
  14cb28:	eb06 0383 	add.w	r3, r6, r3, lsl #2
  14cb2c:	69db      	ldr	r3, [r3, #28]
  14cb2e:	2b00      	cmp	r3, #0
  14cb30:	d0e8      	beq.n	14cb04 <rpmsg_device_probe+0x28>
}
  14cb32:	b007      	add	sp, #28
  14cb34:	bdf0      	pop	{r4, r5, r6, r7, r15}
    if (!cfg || cfg->shm_phys_base == 0)
  14cb36:	687b      	ldr	r3, [r7, #4]
  14cb38:	b133      	cbz	r3, 14cb48 <rpmsg_device_probe+0x6c>
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14cb3a:	2300      	movs	r3, #0
        if (rdev->config.shm_phys_base == 0) {
  14cb3c:	686a      	ldr	r2, [r5, #4]
  14cb3e:	354c      	adds	r5, #76	; 0x4c
  14cb40:	b152      	cbz	r2, 14cb58 <rpmsg_device_probe+0x7c>
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14cb42:	3301      	adds	r3, #1
  14cb44:	2b06      	cmp	r3, #6
  14cb46:	d1f9      	bne.n	14cb3c <rpmsg_device_probe+0x60>
        dprintf(ALWAYS, "failed to allocate rpmsg device to rproc %d \n", cfg->remote_proc);
  14cb48:	f646 00bc 	movw	r0, #26812	; 0x68bc
  14cb4c:	f2c0 0015 	movt	r0, #21
  14cb50:	f007 fad2 	bl	1540f8 <_printf>
}
  14cb54:	b007      	add	sp, #28
  14cb56:	bdf0      	pop	{r4, r5, r6, r7, r15}
            memcpy(&rdev->config, cfg, sizeof(rpmsg_dev_config_t));
  14cb58:	4639      	mov	r1, r7
  14cb5a:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
  14cb5e:	2218      	movs	r2, #24
  14cb60:	eb03 0344 	add.w	r3, r3, r4, lsl #1
  14cb64:	009c      	lsls	r4, r3, #2
        rdev = &rpmsg_remote_devices[i];
  14cb66:	1935      	adds	r5, r6, r4
            memcpy(&rdev->config, cfg, sizeof(rpmsg_dev_config_t));
  14cb68:	4628      	mov	r0, r5
    list_initialize(&rdev->channels);
  14cb6a:	3420      	adds	r4, #32
  14cb6c:	4434      	add	r4, r6
            memcpy(&rdev->config, cfg, sizeof(rpmsg_dev_config_t));
  14cb6e:	f006 ea00 	blx	152f70 <memcpy>
    sprintf(thread_name, "rpmsg-echod/%d", cfg->remote_proc);
  14cb72:	f646 01ac 	movw	r1, #26796	; 0x68ac
  14cb76:	a802      	add	r0, sp, #8
  14cb78:	683a      	ldr	r2, [r7, #0]
  14cb7a:	f2c0 0115 	movt	r1, #21
  14cb7e:	e9c5 4408 	strd	r4, r4, [r5, #32]
  14cb82:	f007 fa59 	bl	154038 <sprintf>
    rdev->main_thread = thread_create(thread_name, rpmsg_device_main, rdev,
  14cb86:	f240 53ec 	movw	r3, #1516	; 0x5ec
  14cb8a:	f64c 213d 	movw	r1, #51773	; 0xca3d
  14cb8e:	462a      	mov	r2, r5
  14cb90:	9300      	str	r3, [sp, #0]
  14cb92:	f2c0 0114 	movt	r1, #20
  14cb96:	230a      	movs	r3, #10
  14cb98:	a802      	add	r0, sp, #8
  14cb9a:	f002 fd49 	bl	14f630 <thread_create>
  14cb9e:	61e8      	str	r0, [r5, #28]
    thread_resume(rdev->main_thread);
  14cba0:	f002 fd9a 	bl	14f6d8 <thread_resume>
}
  14cba4:	b007      	add	sp, #28
  14cba6:	bdf0      	pop	{r4, r5, r6, r7, r15}

0014cba8 <rpmsg_device_get_handle>:

#define RPMSG_GET_RETRY_SPIN    (100)
struct rpmsg_device *rpmsg_device_get_handle(int remote, lk_time_t ms)
{
  14cba8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14cbaa:	f643 5600 	movw	r6, #15616	; 0x3d00
  14cbae:	460c      	mov	r4, r1
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14cbb0:	2200      	movs	r2, #0
  14cbb2:	f2c0 0616 	movt	r6, #22
  14cbb6:	4633      	mov	r3, r6
        if (rdev->config.shm_phys_base && (remote == rdev->config.remote_proc)) {
  14cbb8:	6859      	ldr	r1, [r3, #4]
  14cbba:	b111      	cbz	r1, 14cbc2 <rpmsg_device_get_handle+0x1a>
  14cbbc:	6819      	ldr	r1, [r3, #0]
  14cbbe:	4281      	cmp	r1, r0
  14cbc0:	d006      	beq.n	14cbd0 <rpmsg_device_get_handle+0x28>
    for (i = 0;i < MAX_REMOTE_DEVICE_NUM;i++) {
  14cbc2:	3201      	adds	r2, #1
  14cbc4:	2a06      	cmp	r2, #6
  14cbc6:	f103 034c 	add.w	r3, r3, #76	; 0x4c
  14cbca:	d1f5      	bne.n	14cbb8 <rpmsg_device_get_handle+0x10>
    struct rpmsg_device *rdev = find_rpmsg_device_by_remote(remote);
    if (!rdev) {
        dprintf(INFO, "rpmsg device to rproc%d not found \n", remote);
        return NULL;
  14cbcc:	2000      	movs	r0, #0
        thread_sleep(RPMSG_GET_RETRY_SPIN);
        ms -= RPMSG_GET_RETRY_SPIN;
    } while (!rdev->ready);

    return rdev;
}
  14cbce:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        if (ms < RPMSG_GET_RETRY_SPIN) {
  14cbd0:	2c63      	cmp	r4, #99	; 0x63
  14cbd2:	d9fb      	bls.n	14cbcc <rpmsg_device_get_handle+0x24>
    } while (!rdev->ready);
  14cbd4:	eb02 05c2 	add.w	r5, r2, r2, lsl #3
  14cbd8:	eb02 0545 	add.w	r5, r2, r5, lsl #1
  14cbdc:	eb06 0785 	add.w	r7, r6, r5, lsl #2
        thread_sleep(RPMSG_GET_RETRY_SPIN);
  14cbe0:	2064      	movs	r0, #100	; 0x64
        ms -= RPMSG_GET_RETRY_SPIN;
  14cbe2:	3c64      	subs	r4, #100	; 0x64
        thread_sleep(RPMSG_GET_RETRY_SPIN);
  14cbe4:	f002 fe24 	bl	14f830 <thread_sleep>
    } while (!rdev->ready);
  14cbe8:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
  14cbec:	b913      	cbnz	r3, 14cbf4 <rpmsg_device_get_handle+0x4c>
        if (ms < RPMSG_GET_RETRY_SPIN) {
  14cbee:	2c63      	cmp	r4, #99	; 0x63
  14cbf0:	d8f6      	bhi.n	14cbe0 <rpmsg_device_get_handle+0x38>
  14cbf2:	e7eb      	b.n	14cbcc <rpmsg_device_get_handle+0x24>
        rdev = &rpmsg_remote_devices[i];
  14cbf4:	eb06 0085 	add.w	r0, r6, r5, lsl #2
}
  14cbf8:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  14cbfa:	bf00      	nop

0014cbfc <rpmsg_device_add_channel>:

int rpmsg_device_add_channel(struct rpmsg_device *dev, struct rpmsg_channel *rpchn)
{
  14cbfc:	b570      	push	{r4, r5, r6, r14}
  14cbfe:	4604      	mov	r4, r0
    mutex_acquire(&dev->lock);
  14cc00:	f100 0628 	add.w	r6, r0, #40	; 0x28
{
  14cc04:	460d      	mov	r5, r1
  14cc06:	4630      	mov	r0, r6
  14cc08:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14cc0c:	f002 fade 	bl	14f1cc <mutex_acquire_timeout>
    item->prev = list->prev;
  14cc10:	4623      	mov	r3, r4
    list_add_tail(&dev->channels, &rpchn->node);
    mutex_release(&dev->lock);
  14cc12:	4630      	mov	r0, r6
    list_add_tail(&dev->channels, &rpchn->node);
  14cc14:	f105 0240 	add.w	r2, r5, #64	; 0x40
  14cc18:	f853 1f20 	ldr.w	r1, [r3, #32]!
  14cc1c:	6429      	str	r1, [r5, #64]	; 0x40
    list->prev->next = item;
  14cc1e:	6a21      	ldr	r1, [r4, #32]
    item->next = list;
  14cc20:	646b      	str	r3, [r5, #68]	; 0x44
    list->prev->next = item;
  14cc22:	604a      	str	r2, [r1, #4]
    list->prev = item;
  14cc24:	6222      	str	r2, [r4, #32]
    mutex_release(&dev->lock);
  14cc26:	f002 fafd 	bl	14f224 <mutex_release>
    return 0;
}
  14cc2a:	2000      	movs	r0, #0
  14cc2c:	bd70      	pop	{r4, r5, r6, r15}
  14cc2e:	bf00      	nop

0014cc30 <rpmsg_rtos_init>:
/*
 * This funcion is done in dcf_init quickly.
 */
void rpmsg_rtos_init(void)
{
    mutex_init(&rpmsg_rtos_mutex);
  14cc30:	f643 60c8 	movw	r0, #16072	; 0x3ec8
{
  14cc34:	b508      	push	{r3, r14}
    mutex_init(&rpmsg_rtos_mutex);
  14cc36:	f2c0 0016 	movt	r0, #22
  14cc3a:	f002 fa8d 	bl	14f158 <mutex_init>
    env_init();
}
  14cc3e:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    env_init();
  14cc42:	f004 bd51 	b.w	1516e8 <env_init>
  14cc46:	bf00      	nop

0014cc48 <start_rpmsg_service>:
  14cc48:	f643 60c8 	movw	r0, #16072	; 0x3ec8
  14cc4c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
/*
 * This funcion can be called many times by different modules,
 * but real initilizaion is done once, add mutex to avoid race condition.
 */
void start_rpmsg_service(void)
{
  14cc50:	b5f0      	push	{r4, r5, r6, r7, r14}
    int i, dev_num;
    struct rpmsg_dev_config *cfg;
    struct rpmsg_device *rdev;

    mutex_acquire(&rpmsg_rtos_mutex);
    if (!once_inited) {
  14cc52:	f643 46fc 	movw	r6, #15612	; 0x3cfc
{
  14cc56:	b083      	sub	sp, #12
  14cc58:	f2c0 0016 	movt	r0, #22
  14cc5c:	f002 fab6 	bl	14f1cc <mutex_acquire_timeout>
    if (!once_inited) {
  14cc60:	f2c0 0616 	movt	r6, #22
  14cc64:	7834      	ldrb	r4, [r6, #0]
  14cc66:	b13c      	cbz	r4, 14cc78 <start_rpmsg_service+0x30>
        for (i = 0;i < dev_num; i++) {
            rpmsg_device_probe(&cfg[i]);
        }
        once_inited = true;
    }
    mutex_release(&rpmsg_rtos_mutex);
  14cc68:	f643 60c8 	movw	r0, #16072	; 0x3ec8
  14cc6c:	f2c0 0016 	movt	r0, #22
  14cc70:	f002 fad8 	bl	14f224 <mutex_release>
}
  14cc74:	b003      	add	sp, #12
  14cc76:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dev_num = platform_get_rpmsg_config(&cfg);
  14cc78:	a801      	add	r0, sp, #4
  14cc7a:	f7ff fc3b 	bl	14c4f4 <platform_get_rpmsg_config>
        for (i = 0;i < dev_num; i++) {
  14cc7e:	1e07      	subs	r7, r0, #0
  14cc80:	dd09      	ble.n	14cc96 <start_rpmsg_service+0x4e>
  14cc82:	4625      	mov	r5, r4
            rpmsg_device_probe(&cfg[i]);
  14cc84:	9801      	ldr	r0, [sp, #4]
        for (i = 0;i < dev_num; i++) {
  14cc86:	3501      	adds	r5, #1
            rpmsg_device_probe(&cfg[i]);
  14cc88:	4420      	add	r0, r4
  14cc8a:	f7ff ff27 	bl	14cadc <rpmsg_device_probe>
        for (i = 0;i < dev_num; i++) {
  14cc8e:	42af      	cmp	r7, r5
  14cc90:	f104 0418 	add.w	r4, r4, #24
  14cc94:	d1f6      	bne.n	14cc84 <start_rpmsg_service+0x3c>
        once_inited = true;
  14cc96:	2301      	movs	r3, #1
  14cc98:	7033      	strb	r3, [r6, #0]
  14cc9a:	e7e5      	b.n	14cc68 <start_rpmsg_service+0x20>

0014cc9c <rpmsg_service_entry>:
    }
    printf("End of rpmsg devices\n");
}

void rpmsg_service_entry(uint level)
{
  14cc9c:	b510      	push	{r4, r14}
    uint32_t t1, t2;

    t1 = syscnt_get_cnt();
  14cc9e:	f7ff f897 	bl	14bdd0 <syscnt_get_cnt>
  14cca2:	4604      	mov	r4, r0
    start_rpmsg_service();
  14cca4:	f7ff ffd0 	bl	14cc48 <start_rpmsg_service>
    t2 = syscnt_get_cnt();
  14cca8:	f7ff f892 	bl	14bdd0 <syscnt_get_cnt>

#if !SUPPORT_FAST_BOOT
    dprintf(0, "%s takes %d us\n", __func__, syscnt_time_lapse(t1, t2));
  14ccac:	4601      	mov	r1, r0
  14ccae:	4620      	mov	r0, r4
  14ccb0:	f7ff f894 	bl	14bddc <syscnt_time_lapse>
  14ccb4:	f646 0138 	movw	r1, #26680	; 0x6838
  14ccb8:	f2c0 0115 	movt	r1, #21
#else
    t1 = t2 - t1;   /* pass compiling */
#endif
}
  14ccbc:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    dprintf(0, "%s takes %d us\n", __func__, syscnt_time_lapse(t1, t2));
  14ccc0:	4602      	mov	r2, r0
  14ccc2:	f646 00ec 	movw	r0, #26860	; 0x68ec
  14ccc6:	f2c0 0015 	movt	r0, #21
  14ccca:	f007 ba15 	b.w	1540f8 <_printf>
  14ccce:	bf00      	nop

0014ccd0 <rpmsg_echo_loop>:

#define ECHO_EPT_NAME		"rpmsg-echo"
#define ECHO_LINUX_EPT		(30)

int rpmsg_echo_loop(struct rpmsg_device *rdev)
{
  14ccd0:	b570      	push	{r4, r5, r6, r14}
    unsigned long src;
    char payload[RL_BUFFER_PAYLOAD_SIZE];
    struct rpmsg_channel *chn;

    rproc = rdev->config.remote_proc;
    chn = rpmsg_channel_create(rproc, ECHO_LINUX_EPT, ECHO_EPT_NAME);
  14ccd2:	f646 1208 	movw	r2, #26888	; 0x6908
{
  14ccd6:	f5ad 7d00 	sub.w	r13, r13, #512	; 0x200
    int recved = 0;
  14ccda:	2600      	movs	r6, #0
  14ccdc:	ad02      	add	r5, sp, #8
    chn = rpmsg_channel_create(rproc, ECHO_LINUX_EPT, ECHO_EPT_NAME);
  14ccde:	6800      	ldr	r0, [r0, #0]
  14cce0:	f2c0 0215 	movt	r2, #21
    int recved = 0;
  14cce4:	602e      	str	r6, [r5, #0]
    chn = rpmsg_channel_create(rproc, ECHO_LINUX_EPT, ECHO_EPT_NAME);
  14cce6:	211e      	movs	r1, #30
  14cce8:	f000 f89c 	bl	14ce24 <rpmsg_channel_create>
    if (!chn)
  14ccec:	2800      	cmp	r0, #0
  14ccee:	d035      	beq.n	14cd5c <rpmsg_echo_loop+0x8c>
        return ERR_NO_RESOURCES;

    rpmsg_channel_start(chn, NULL);
  14ccf0:	4631      	mov	r1, r6
  14ccf2:	4604      	mov	r4, r0
  14ccf4:	f000 f8fe 	bl	14cef4 <rpmsg_channel_start>

    while (1) {
        rpmsg_channel_recvfrom(chn, &src, payload,
  14ccf8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  14ccfc:	f44f 73f8 	mov.w	r3, #496	; 0x1f0
  14cd00:	aa04      	add	r2, sp, #16
  14cd02:	9601      	str	r6, [sp, #4]
  14cd04:	a903      	add	r1, sp, #12
  14cd06:	9500      	str	r5, [sp, #0]
  14cd08:	4620      	mov	r0, r4
  14cd0a:	f000 f91f 	bl	14cf4c <rpmsg_channel_recvfrom>
                               RL_BUFFER_PAYLOAD_SIZE, &recved, RL_BLOCK);
        chn->rx_cnt++;
  14cd0e:	6de1      	ldr	r1, [r4, #92]	; 0x5c
        chn->rx_bytes += recved;
  14cd10:	6d62      	ldr	r2, [r4, #84]	; 0x54
  14cd12:	682b      	ldr	r3, [r5, #0]
        chn->rx_cnt++;
  14cd14:	3101      	adds	r1, #1
  14cd16:	65e1      	str	r1, [r4, #92]	; 0x5c
        chn->rx_bytes += recved;
  14cd18:	441a      	add	r2, r3
  14cd1a:	6562      	str	r2, [r4, #84]	; 0x54
        printf("[echo]From %d:%lu received %d bytes: count:%d\n",
                        chn->rproc, src, recved, chn->rx_cnt);
        hexdump8(payload, MIN(32, recved));
#endif

        if (payload[0] == COMM_MSG_CCM_ECHO) {
  14cd1c:	f89d 2010 	ldrb.w	r2, [r13, #16]
  14cd20:	2aa5      	cmp	r2, #165	; 0xa5
  14cd22:	d005      	beq.n	14cd30 <rpmsg_echo_loop+0x60>
            chn->tx_cnt++;
            chn->tx_bytes += recved;
            continue;
        }

        if (payload[0] == COMM_MSG_CCM_ACK) {
  14cd24:	2aa6      	cmp	r2, #166	; 0xa6
  14cd26:	d011      	beq.n	14cd4c <rpmsg_echo_loop+0x7c>
            rpmsg_channel_sendto(chn, src, payload, 4, RL_BLOCK);
            continue;
        }

        dprintf(2, "drop %d bytes\n", recved);
        chn->drop_cnt++;
  14cd28:	6ea3      	ldr	r3, [r4, #104]	; 0x68
  14cd2a:	3301      	adds	r3, #1
  14cd2c:	66a3      	str	r3, [r4, #104]	; 0x68
  14cd2e:	e7e5      	b.n	14ccfc <rpmsg_echo_loop+0x2c>
            rpmsg_channel_sendto(chn, src, payload, recved, RL_BLOCK);
  14cd30:	9903      	ldr	r1, [sp, #12]
  14cd32:	aa04      	add	r2, sp, #16
  14cd34:	9600      	str	r6, [sp, #0]
  14cd36:	4620      	mov	r0, r4
  14cd38:	f000 f918 	bl	14cf6c <rpmsg_channel_sendto>
            chn->tx_cnt++;
  14cd3c:	6e22      	ldr	r2, [r4, #96]	; 0x60
            chn->tx_bytes += recved;
  14cd3e:	6da3      	ldr	r3, [r4, #88]	; 0x58
  14cd40:	6829      	ldr	r1, [r5, #0]
            chn->tx_cnt++;
  14cd42:	3201      	adds	r2, #1
  14cd44:	6622      	str	r2, [r4, #96]	; 0x60
            chn->tx_bytes += recved;
  14cd46:	440b      	add	r3, r1
  14cd48:	65a3      	str	r3, [r4, #88]	; 0x58
            continue;
  14cd4a:	e7d7      	b.n	14ccfc <rpmsg_echo_loop+0x2c>
            rpmsg_channel_sendto(chn, src, payload, 4, RL_BLOCK);
  14cd4c:	9903      	ldr	r1, [sp, #12]
  14cd4e:	2304      	movs	r3, #4
  14cd50:	9600      	str	r6, [sp, #0]
  14cd52:	aa04      	add	r2, sp, #16
  14cd54:	4620      	mov	r0, r4
  14cd56:	f000 f909 	bl	14cf6c <rpmsg_channel_sendto>
            continue;
  14cd5a:	e7cf      	b.n	14ccfc <rpmsg_echo_loop+0x2c>

    }

    return 0;
}
  14cd5c:	f06f 0028 	mvn.w	r0, #40	; 0x28
  14cd60:	f50d 7d00 	add.w	r13, r13, #512	; 0x200
  14cd64:	bd70      	pop	{r4, r5, r6, r15}
  14cd66:	bf00      	nop

0014cd68 <rpmsg_looper_thread>:
struct rpmsg_device *rpmsg_device_get_handle(int remote, lk_time_t ms);
int rpmsg_device_add_channel(struct rpmsg_device *dev, struct rpmsg_channel *rpchn);
int rpmsg_device_rm_channel(struct rpmsg_device *dev, struct rpmsg_channel *rpchn);

static int rpmsg_looper_thread(void *arg)
{
  14cd68:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct rpmsg_channel *rpchn;
    int recved = 0;
  14cd6c:	2300      	movs	r3, #0
{
  14cd6e:	b087      	sub	sp, #28
    int recved = 0;
  14cd70:	9304      	str	r3, [sp, #16]
    status_t ret;
    unsigned char *rxbuf = NULL;
    struct dcf_message *msg = (struct dcf_message *)rxbuf;

    rpchn = (struct rpmsg_channel *) arg;
    if (!rpchn) {
  14cd72:	2800      	cmp	r0, #0
  14cd74:	d049      	beq.n	14ce0a <rpmsg_looper_thread+0xa2>
  14cd76:	4604      	mov	r4, r0
        return ERR_BAD_STATE;
    }

    rxbuf = malloc(rpchn->mtu);
  14cd78:	6980      	ldr	r0, [r0, #24]
  14cd7a:	f006 f889 	bl	152e90 <malloc>
    if (!rxbuf) {
  14cd7e:	4605      	mov	r5, r0
  14cd80:	2800      	cmp	r0, #0
  14cd82:	d045      	beq.n	14ce10 <rpmsg_looper_thread+0xa8>
  14cd84:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
        dprintf(0, "No memory for rpmsg channel\n");
        return ERR_NO_MEMORY;
    }

    rpchn->looper = get_current_thread();
    event_signal(&rpchn->initialized, true);
  14cd88:	2101      	movs	r1, #1
  14cd8a:	f104 0020 	add.w	r0, r4, #32
    rpchn->looper = get_current_thread();
  14cd8e:	63e3      	str	r3, [r4, #60]	; 0x3c
    while (rpchn->state == DCF_STATE_Connected) {
        ret = rpmsg_queue_recv(rpchn->rpmsg_dev, rpchn->msg_queue, &src,
                     (char*) rxbuf, rpchn->mtu, &recved, RL_BLOCK);
        if (ret < 0) {
            rpchn->err_cnt++;
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14cd90:	f646 1a14 	movw	r10, #26900	; 0x6914
  14cd94:	f246 29e0 	movw	r9, #25312	; 0x62e0
    event_signal(&rpchn->initialized, true);
  14cd98:	f002 f998 	bl	14f0cc <event_signal>
  14cd9c:	f10d 0810 	add.w	r8, r13, #16
    rpchn->state = DCF_STATE_Connected;
  14cda0:	2305      	movs	r3, #5
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14cda2:	f2c0 0a15 	movt	r10, #21
        ret = rpmsg_queue_recv(rpchn->rpmsg_dev, rpchn->msg_queue, &src,
  14cda6:	f04f 3bff 	mov.w	r11, #4294967295	; 0xffffffff
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14cdaa:	f2c0 0915 	movt	r9, #21
    rpchn->state = DCF_STATE_Connected;
  14cdae:	61e3      	str	r3, [r4, #28]
        ret = rpmsg_queue_recv(rpchn->rpmsg_dev, rpchn->msg_queue, &src,
  14cdb0:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
  14cdb2:	aa05      	add	r2, sp, #20
  14cdb4:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
  14cdb6:	462b      	mov	r3, r5
  14cdb8:	e9cd 8b01 	strd	r8, r11, [r13, #4]
  14cdbc:	69a6      	ldr	r6, [r4, #24]
  14cdbe:	9600      	str	r6, [sp, #0]
  14cdc0:	f004 fabc 	bl	15133c <rpmsg_queue_recv>

        /* data processing start from here */
        dprintf(1, "%s: rx %d bytes from %ld\n", __func__, recved, src);

        if (rpchn->msg_handler)
            rpchn->msg_handler(rpchn, (struct dcf_message *)rxbuf, recved);
  14cdc4:	4629      	mov	r1, r5
        if (ret < 0) {
  14cdc6:	1e02      	subs	r2, r0, #0
            rpchn->msg_handler(rpchn, (struct dcf_message *)rxbuf, recved);
  14cdc8:	4620      	mov	r0, r4
        if (ret < 0) {
  14cdca:	db16      	blt.n	14cdfa <rpmsg_looper_thread+0x92>
        rpchn->rx_cnt++;
  14cdcc:	6de6      	ldr	r6, [r4, #92]	; 0x5c
        rpchn->rx_bytes += recved;
  14cdce:	9b04      	ldr	r3, [sp, #16]
  14cdd0:	6d67      	ldr	r7, [r4, #84]	; 0x54
        rpchn->rx_cnt++;
  14cdd2:	3601      	adds	r6, #1
            rpchn->msg_handler(rpchn, (struct dcf_message *)rxbuf, recved);
  14cdd4:	461a      	mov	r2, r3
        rpchn->rx_cnt++;
  14cdd6:	65e6      	str	r6, [r4, #92]	; 0x5c
        rpchn->rx_bytes += recved;
  14cdd8:	443b      	add	r3, r7
        if (rpchn->msg_handler)
  14cdda:	6f26      	ldr	r6, [r4, #112]	; 0x70
        rpchn->rx_bytes += recved;
  14cddc:	6563      	str	r3, [r4, #84]	; 0x54
        if (rpchn->msg_handler)
  14cdde:	b106      	cbz	r6, 14cde2 <rpmsg_looper_thread+0x7a>
            rpchn->msg_handler(rpchn, (struct dcf_message *)rxbuf, recved);
  14cde0:	47b0      	blx	r6
    while (rpchn->state == DCF_STATE_Connected) {
  14cde2:	69e3      	ldr	r3, [r4, #28]
  14cde4:	2b05      	cmp	r3, #5
  14cde6:	d0e3      	beq.n	14cdb0 <rpmsg_looper_thread+0x48>
        /* data processing end */
    }

    rpchn->state = DCF_STATE_Closed;
  14cde8:	2304      	movs	r3, #4
    if (rxbuf)
        free(rxbuf);
  14cdea:	4628      	mov	r0, r5
    rpchn->state = DCF_STATE_Closed;
  14cdec:	61e3      	str	r3, [r4, #28]
        free(rxbuf);
  14cdee:	f006 f885 	bl	152efc <free>

    return 0;
  14cdf2:	2000      	movs	r0, #0
}
  14cdf4:	b007      	add	sp, #28
  14cdf6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            rpchn->err_cnt++;
  14cdfa:	6e63      	ldr	r3, [r4, #100]	; 0x64
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14cdfc:	4651      	mov	r1, r10
  14cdfe:	4648      	mov	r0, r9
            rpchn->err_cnt++;
  14ce00:	3301      	adds	r3, #1
  14ce02:	6663      	str	r3, [r4, #100]	; 0x64
            dprintf(0, ":%s: fail to read data, ret: %d\n", __func__, ret);
  14ce04:	f007 f978 	bl	1540f8 <_printf>
            continue;
  14ce08:	e7eb      	b.n	14cde2 <rpmsg_looper_thread+0x7a>
        return ERR_BAD_STATE;
  14ce0a:	f06f 001e 	mvn.w	r0, #30
  14ce0e:	e7f1      	b.n	14cdf4 <rpmsg_looper_thread+0x8c>
        dprintf(0, "No memory for rpmsg channel\n");
  14ce10:	f646 106c 	movw	r0, #26988	; 0x696c
  14ce14:	f2c0 0015 	movt	r0, #21
  14ce18:	f007 f96e 	bl	1540f8 <_printf>
        return ERR_NO_MEMORY;
  14ce1c:	f06f 0004 	mvn.w	r0, #4
  14ce20:	e7e8      	b.n	14cdf4 <rpmsg_looper_thread+0x8c>
  14ce22:	bf00      	nop

0014ce24 <rpmsg_channel_create>:

struct rpmsg_channel *rpmsg_channel_create(int rproc, int endpoint, const char *name)
{
  14ce24:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14ce26:	4605      	mov	r5, r0
  14ce28:	460e      	mov	r6, r1
    struct rpmsg_channel *rpchn = calloc(1, sizeof(struct rpmsg_channel));
  14ce2a:	2001      	movs	r0, #1
  14ce2c:	2174      	movs	r1, #116	; 0x74
{
  14ce2e:	4617      	mov	r7, r2
    struct rpmsg_channel *rpchn = calloc(1, sizeof(struct rpmsg_channel));
  14ce30:	f006 f844 	bl	152ebc <calloc>
    int ret;

    if (!rpchn) {
  14ce34:	2800      	cmp	r0, #0
  14ce36:	d049      	beq.n	14cecc <rpmsg_channel_create+0xa8>
  14ce38:	4604      	mov	r4, r0
        ret = ERR_NO_MEMORY;
        goto error;
    }

    if (rproc == dcf_get_this_proc()) {
  14ce3a:	f7f3 fd9f 	bl	14097c <dcf_get_this_proc>
  14ce3e:	42a8      	cmp	r0, r5
  14ce40:	d031      	beq.n	14cea6 <rpmsg_channel_create+0x82>
        ret = ERR_NOT_ALLOWED;
        goto error;
    }
    event_init(&rpchn->initialized, false, EVENT_FLAG_AUTOUNSIGNAL);
  14ce42:	2201      	movs	r2, #1
  14ce44:	2100      	movs	r1, #0
  14ce46:	f104 0020 	add.w	r0, r4, #32
  14ce4a:	f002 f903 	bl	14f054 <event_init>

    /* TODO: use configure for the remote processor */
    rpchn->rproc = rproc;
    rpchn->addr = endpoint;
    rpchn->state = DCF_STATE_Initializing;
  14ce4e:	2201      	movs	r2, #1
    rpchn->mtu = DCF_MSG_MAX_LEN;
  14ce50:	2380      	movs	r3, #128	; 0x80

    rpchn->parent = rpmsg_device_get_handle(rpchn->rproc, RPMC_INIT_TIMEOUT);
  14ce52:	4628      	mov	r0, r5
    rpchn->rproc = rproc;
  14ce54:	6125      	str	r5, [r4, #16]
    rpchn->parent = rpmsg_device_get_handle(rpchn->rproc, RPMC_INIT_TIMEOUT);
  14ce56:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
    rpchn->addr = endpoint;
  14ce5a:	6166      	str	r6, [r4, #20]
    rpchn->mtu = DCF_MSG_MAX_LEN;
  14ce5c:	e9c4 3206 	strd	r3, r2, [r4, #24]
    rpchn->parent = rpmsg_device_get_handle(rpchn->rproc, RPMC_INIT_TIMEOUT);
  14ce60:	f7ff fea2 	bl	14cba8 <rpmsg_device_get_handle>
  14ce64:	64a0      	str	r0, [r4, #72]	; 0x48
    if (!rpchn->parent) {
  14ce66:	2800      	cmp	r0, #0
  14ce68:	d039      	beq.n	14cede <rpmsg_channel_create+0xba>
        ret = ERR_BAD_HANDLE;
        dprintf(0, "Fail to get rpmsg device rp%d\n", rpchn->rproc);
        goto error;
    }
    rpchn->rpmsg_dev = rpchn->parent->rl_instance;
  14ce6a:	6c40      	ldr	r0, [r0, #68]	; 0x44
  14ce6c:	64e0      	str	r0, [r4, #76]	; 0x4c

    rpchn->msg_queue = rpmsg_queue_create(rpchn->rpmsg_dev);
  14ce6e:	f004 fa4f 	bl	151310 <rpmsg_queue_create>
  14ce72:	66e0      	str	r0, [r4, #108]	; 0x6c
    if (!rpchn->msg_queue) {
  14ce74:	b368      	cbz	r0, 14ced2 <rpmsg_channel_create+0xae>
        ret = ERR_NOT_ENOUGH_BUFFER;
        goto error;
    }

    rpchn->endpoint = rpmsg_lite_create_ept(rpchn->rpmsg_dev, rpchn->addr,
  14ce76:	f241 22c5 	movw	r2, #4805	; 0x12c5
  14ce7a:	4603      	mov	r3, r0
  14ce7c:	6961      	ldr	r1, [r4, #20]
  14ce7e:	f2c0 0215 	movt	r2, #21
  14ce82:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
  14ce84:	f003 fdfc 	bl	150a80 <rpmsg_lite_create_ept>
  14ce88:	6520      	str	r0, [r4, #80]	; 0x50
                                     rpmsg_queue_rx_cb, rpchn->msg_queue);
    if (!rpchn->endpoint) {
  14ce8a:	b328      	cbz	r0, 14ced8 <rpmsg_channel_create+0xb4>
        ret = ERR_NO_RESOURCES;
        goto error;
    }

    rpmsg_device_add_channel(rpchn->parent, rpchn);
  14ce8c:	6ca0      	ldr	r0, [r4, #72]	; 0x48
  14ce8e:	4621      	mov	r1, r4
  14ce90:	f7ff feb4 	bl	14cbfc <rpmsg_device_add_channel>

    strncpy(rpchn->name, name, DCF_NAM_MAX_LEN);
  14ce94:	4639      	mov	r1, r7
  14ce96:	2210      	movs	r2, #16
  14ce98:	4620      	mov	r0, r4
  14ce9a:	f007 f9ab 	bl	1541f4 <strncpy>
    rpchn->state = DCF_STATE_Initialized;
  14ce9e:	2302      	movs	r3, #2
        free(rpchn);

    dprintf(0, "%s: ret=%d\n", __func__, ret);

    return NULL;
}
  14cea0:	4620      	mov	r0, r4
    rpchn->state = DCF_STATE_Initialized;
  14cea2:	61e3      	str	r3, [r4, #28]
}
  14cea4:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        ret = ERR_NOT_ALLOWED;
  14cea6:	f06f 0510 	mvn.w	r5, #16
        free(rpchn);
  14ceaa:	4620      	mov	r0, r4
  14ceac:	f006 f826 	bl	152efc <free>
    dprintf(0, "%s: ret=%d\n", __func__, ret);
  14ceb0:	f646 1128 	movw	r1, #26920	; 0x6928
  14ceb4:	f646 1060 	movw	r0, #26976	; 0x6960
  14ceb8:	462a      	mov	r2, r5
  14ceba:	f2c0 0115 	movt	r1, #21
    return NULL;
  14cebe:	2400      	movs	r4, #0
    dprintf(0, "%s: ret=%d\n", __func__, ret);
  14cec0:	f2c0 0015 	movt	r0, #21
  14cec4:	f007 f918 	bl	1540f8 <_printf>
}
  14cec8:	4620      	mov	r0, r4
  14ceca:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        ret = ERR_NO_MEMORY;
  14cecc:	f06f 0504 	mvn.w	r5, #4
  14ced0:	e7ee      	b.n	14ceb0 <rpmsg_channel_create+0x8c>
        ret = ERR_NOT_ENOUGH_BUFFER;
  14ced2:	f06f 0508 	mvn.w	r5, #8
  14ced6:	e7e8      	b.n	14ceaa <rpmsg_channel_create+0x86>
        ret = ERR_NO_RESOURCES;
  14ced8:	f06f 0528 	mvn.w	r5, #40	; 0x28
  14cedc:	e7e5      	b.n	14ceaa <rpmsg_channel_create+0x86>
        dprintf(0, "Fail to get rpmsg device rp%d\n", rpchn->rproc);
  14cede:	f646 1040 	movw	r0, #26944	; 0x6940
        ret = ERR_BAD_HANDLE;
  14cee2:	f06f 0529 	mvn.w	r5, #41	; 0x29
        dprintf(0, "Fail to get rpmsg device rp%d\n", rpchn->rproc);
  14cee6:	6921      	ldr	r1, [r4, #16]
  14cee8:	f2c0 0015 	movt	r0, #21
  14ceec:	f007 f904 	bl	1540f8 <_printf>
  14cef0:	e7db      	b.n	14ceaa <rpmsg_channel_create+0x86>
  14cef2:	bf00      	nop

0014cef4 <rpmsg_channel_start>:
int rpmsg_channel_start(struct rpmsg_channel *rpchn, rpmsg_msg_handler handler)
{
    struct rpmsg_device *dev = rpchn->parent;

    /* connecting with remote side */
    if (!dev->config.is_master) {
  14cef4:	6c83      	ldr	r3, [r0, #72]	; 0x48
{
  14cef6:	b530      	push	{r4, r5, r14}
    if (!dev->config.is_master) {
  14cef8:	68db      	ldr	r3, [r3, #12]
{
  14cefa:	b083      	sub	sp, #12
  14cefc:	4604      	mov	r4, r0
  14cefe:	460d      	mov	r5, r1
    if (!dev->config.is_master) {
  14cf00:	b12b      	cbz	r3, 14cf0e <rpmsg_channel_start+0x1a>
        rpmsg_ns_announce(rpchn->rpmsg_dev, rpchn->endpoint,
                          rpchn->name, RL_NS_CREATE);
    }

    /* if specify msg handler, spawn a thread to receive msg and call handler */
    if (handler) {
  14cf02:	b95d      	cbnz	r5, 14cf1c <rpmsg_channel_start+0x28>
        /* start up a thread to process message queue */
        thread_resume(thread_create(rpchn->name, rpmsg_looper_thread, rpchn,
                            THREAD_PRI_RPMSG_CHN, CONFIG_RPMSG_STACK_SIZE));
        event_wait(&rpchn->initialized);
    } else
        rpchn->state = DCF_STATE_Connected;
  14cf04:	2305      	movs	r3, #5

    dprintf(INFO, "rpmsg channel %s:%d->%d connected\n",
            rpchn->name, dcf_get_this_proc(), rpchn->rproc);

    return 0;
}
  14cf06:	2000      	movs	r0, #0
        rpchn->state = DCF_STATE_Connected;
  14cf08:	61e3      	str	r3, [r4, #28]
}
  14cf0a:	b003      	add	sp, #12
  14cf0c:	bd30      	pop	{r4, r5, r15}
        rpmsg_ns_announce(rpchn->rpmsg_dev, rpchn->endpoint,
  14cf0e:	4602      	mov	r2, r0
  14cf10:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
  14cf14:	f004 f9ac 	bl	151270 <rpmsg_ns_announce>
    if (handler) {
  14cf18:	2d00      	cmp	r5, #0
  14cf1a:	d0f3      	beq.n	14cf04 <rpmsg_channel_start+0x10>
        thread_resume(thread_create(rpchn->name, rpmsg_looper_thread, rpchn,
  14cf1c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  14cf20:	f64c 5169 	movw	r1, #52585	; 0xcd69
  14cf24:	4622      	mov	r2, r4
  14cf26:	f2c0 0114 	movt	r1, #20
        rpchn->msg_handler = handler;
  14cf2a:	6725      	str	r5, [r4, #112]	; 0x70
        thread_resume(thread_create(rpchn->name, rpmsg_looper_thread, rpchn,
  14cf2c:	4620      	mov	r0, r4
  14cf2e:	9300      	str	r3, [sp, #0]
  14cf30:	2310      	movs	r3, #16
  14cf32:	f002 fb7d 	bl	14f630 <thread_create>
  14cf36:	f002 fbcf 	bl	14f6d8 <thread_resume>
  14cf3a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14cf3e:	f104 0020 	add.w	r0, r4, #32
  14cf42:	f002 f89d 	bl	14f080 <event_wait_timeout>
}
  14cf46:	2000      	movs	r0, #0
  14cf48:	b003      	add	sp, #12
  14cf4a:	bd30      	pop	{r4, r5, r15}

0014cf4c <rpmsg_channel_recvfrom>:
                     unsigned long *src,
                     char *data,
                     int maxlen,
                     int *len,
                     unsigned long timeout)
{
  14cf4c:	b570      	push	{r4, r5, r6, r14}
  14cf4e:	b084      	sub	sp, #16
    return rpmsg_queue_recv(rpchn->rpmsg_dev, rpchn->msg_queue, src,
  14cf50:	9300      	str	r3, [sp, #0]
  14cf52:	4613      	mov	r3, r2
  14cf54:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  14cf56:	460a      	mov	r2, r1
{
  14cf58:	e9dd 5408 	ldrd	r5, r4, [r13, #32]
    return rpmsg_queue_recv(rpchn->rpmsg_dev, rpchn->msg_queue, src,
  14cf5c:	4631      	mov	r1, r6
  14cf5e:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  14cf60:	e9cd 5401 	strd	r5, r4, [r13, #4]
  14cf64:	f004 f9ea 	bl	15133c <rpmsg_queue_recv>
                    data, maxlen, len, timeout);
}
  14cf68:	b004      	add	sp, #16
  14cf6a:	bd70      	pop	{r4, r5, r6, r15}

0014cf6c <rpmsg_channel_sendto>:

status_t rpmsg_channel_sendto(struct rpmsg_channel *rpchn, unsigned long dst,
                    char *data,
                    unsigned long size,
                    unsigned long timeout)
{
  14cf6c:	b530      	push	{r4, r5, r14}
  14cf6e:	b083      	sub	sp, #12
    return rpmsg_lite_send(rpchn->rpmsg_dev, rpchn->endpoint, dst,
  14cf70:	9300      	str	r3, [sp, #0]
  14cf72:	4613      	mov	r3, r2
  14cf74:	6d05      	ldr	r5, [r0, #80]	; 0x50
  14cf76:	460a      	mov	r2, r1
{
  14cf78:	9c06      	ldr	r4, [sp, #24]
    return rpmsg_lite_send(rpchn->rpmsg_dev, rpchn->endpoint, dst,
  14cf7a:	4629      	mov	r1, r5
  14cf7c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  14cf7e:	9401      	str	r4, [sp, #4]
  14cf80:	f003 fe56 	bl	150c30 <rpmsg_lite_send>
                    data, size, timeout);
}
  14cf84:	b003      	add	sp, #12
  14cf86:	bd30      	pop	{r4, r5, r15}

0014cf88 <sysd_sem_handler>:
        return 0;
    }
}

static enum handler_return sysd_sem_handler(void *arg)
{
  14cf88:	b510      	push	{r4, r14}

    sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, false);
  14cf8a:	f643 64e4 	movw	r4, #16100	; 0x3ee4
  14cf8e:	2200      	movs	r2, #0
  14cf90:	2102      	movs	r1, #2
  14cf92:	f2c0 0416 	movt	r4, #22
  14cf96:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  14cf98:	f004 fcd4 	bl	151944 <sem_enable_intr>
    event_signal(&sem_handle.evt, false);
  14cf9c:	4620      	mov	r0, r4
  14cf9e:	2100      	movs	r1, #0
  14cfa0:	f002 f894 	bl	14f0cc <event_signal>

    return INT_RESCHEDULE;
}
  14cfa4:	2001      	movs	r0, #1
  14cfa6:	bd10      	pop	{r4, r15}

0014cfa8 <sysd_worker>:
        }
    }
}

static void sysd_worker(enum sem sem)
{
  14cfa8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}

    sem_handle.sem = sem;
  14cfac:	f643 66e4 	movw	r6, #16100	; 0x3ee4
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
  14cfb0:	2800      	cmp	r0, #0
{
  14cfb2:	4603      	mov	r3, r0
    sem_handle.sem = sem;
  14cfb4:	f2c0 0616 	movt	r6, #22
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
  14cfb8:	bf0c      	ite	eq
  14cfba:	252e      	moveq	r5, #46	; 0x2e
  14cfbc:	252f      	movne	r5, #47	; 0x2f

    event_init(&sem_handle.evt,false,1);
  14cfbe:	2100      	movs	r1, #0
  14cfc0:	4630      	mov	r0, r6
  14cfc2:	2201      	movs	r2, #1
    mutex_init(&sem_handle.lock);

    mutex_acquire(&sem_handle.lock);

    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14cfc4:	460c      	mov	r4, r1
    sem_handle.sem = sem;
  14cfc6:	63b3      	str	r3, [r6, #56]	; 0x38
    sem_handle.irq = ( (sem == SEM1) ? SEM1_O_SEM_INT_CPU_NUM : SEM2_O_SEM_INT_CPU_NUM) ;
  14cfc8:	87b5      	strh	r5, [r6, #60]	; 0x3c
    event_init(&sem_handle.evt,false,1);
  14cfca:	f002 f843 	bl	14f054 <event_init>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14cfce:	f240 153f 	movw	r5, #319	; 0x13f
    mutex_init(&sem_handle.lock);
  14cfd2:	f106 001c 	add.w	r0, r6, #28
  14cfd6:	f002 f8bf 	bl	14f158 <mutex_init>
  14cfda:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14cfde:	f106 001c 	add.w	r0, r6, #28
  14cfe2:	f002 f8f3 	bl	14f1cc <mutex_acquire_timeout>
    {
        sem_map_signal(sem_handle.sem, s,SEM_INTR_CPU,false);
  14cfe6:	4621      	mov	r1, r4
  14cfe8:	2300      	movs	r3, #0
  14cfea:	2202      	movs	r2, #2
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14cfec:	3401      	adds	r4, #1
        sem_map_signal(sem_handle.sem, s,SEM_INTR_CPU,false);
  14cfee:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  14cff0:	f004 fcca 	bl	151988 <sem_map_signal>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14cff4:	42ac      	cmp	r4, r5
  14cff6:	d1f6      	bne.n	14cfe6 <sysd_worker+0x3e>
    }

    register_int_handler(sem_handle.irq, sysd_sem_handler, NULL);
  14cff8:	f64c 7189 	movw	r1, #53129	; 0xcf89
  14cffc:	2200      	movs	r2, #0
  14cffe:	8fb0      	ldrh	r0, [r6, #60]	; 0x3c
  14d000:	f643 69e4 	movw	r9, #16100	; 0x3ee4
  14d004:	f2c0 0114 	movt	r1, #20
  14d008:	f7f3 fb6c 	bl	1406e4 <register_int_handler>
    unmask_interrupt(sem_handle.irq);
  14d00c:	8fb0      	ldrh	r0, [r6, #60]	; 0x3c
  14d00e:	f7f3 fbbb 	bl	140788 <unmask_interrupt>


    sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, true);
  14d012:	2201      	movs	r2, #1
  14d014:	2102      	movs	r1, #2
  14d016:	f2c0 0916 	movt	r9, #22
  14d01a:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  14d01c:	f643 7824 	movw	r8, #16164	; 0x3f24
  14d020:	f004 fc90 	bl	151944 <sem_enable_intr>

    mutex_release(&sem_handle.lock);
  14d024:	f109 001c 	add.w	r0, r9, #28
  14d028:	f002 f8fc 	bl	14f224 <mutex_release>
  14d02c:	f109 0a1c 	add.w	r10, r9, #28
  14d030:	f2c0 0816 	movt	r8, #22
  14d034:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14d038:	4648      	mov	r0, r9
  14d03a:	f002 f821 	bl	14f080 <event_wait_timeout>
  14d03e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14d042:	4650      	mov	r0, r10
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14d044:	2500      	movs	r5, #0
  14d046:	f002 f8c1 	bl	14f1cc <mutex_acquire_timeout>
  14d04a:	f240 173f 	movw	r7, #319	; 0x13f
  14d04e:	e002      	b.n	14d056 <sysd_worker+0xae>
  14d050:	3501      	adds	r5, #1
  14d052:	42bd      	cmp	r5, r7
  14d054:	d017      	beq.n	14d086 <sysd_worker+0xde>
        if (sem_signal_status(sem_handle.sem, s))
  14d056:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  14d058:	4629      	mov	r1, r5
  14d05a:	f004 fc83 	bl	151964 <sem_signal_status>
  14d05e:	2800      	cmp	r0, #0
  14d060:	d0f6      	beq.n	14d050 <sysd_worker+0xa8>
    sysd_handler_t* sysd = total_signals[signal].head;
  14d062:	eb05 0345 	add.w	r3, r5, r5, lsl #1
  14d066:	eb08 0383 	add.w	r3, r8, r3, lsl #2
  14d06a:	685c      	ldr	r4, [r3, #4]
    while(sysd)
  14d06c:	2c00      	cmp	r4, #0
  14d06e:	d0ef      	beq.n	14d050 <sysd_worker+0xa8>
        if(sysd->evt_cb)
  14d070:	68a3      	ldr	r3, [r4, #8]
            sysd->evt_cb(signal,sysd->args);
  14d072:	4628      	mov	r0, r5
        if(sysd->evt_cb)
  14d074:	b10b      	cbz	r3, 14d07a <sysd_worker+0xd2>
            sysd->evt_cb(signal,sysd->args);
  14d076:	68e1      	ldr	r1, [r4, #12]
  14d078:	4798      	blx	r3
        sysd = sysd->next;
  14d07a:	6824      	ldr	r4, [r4, #0]
    while(sysd)
  14d07c:	2c00      	cmp	r4, #0
  14d07e:	d1f7      	bne.n	14d070 <sysd_worker+0xc8>
    for(int s=0; s<MAX_SYSD_SIGNALS;s++)
  14d080:	3501      	adds	r5, #1
  14d082:	42bd      	cmp	r5, r7
  14d084:	d1e7      	bne.n	14d056 <sysd_worker+0xae>
        event_wait(&sem_handle.evt);

        mutex_acquire(&sem_handle.lock);

        sysd_dispatcher();
        sem_enable_intr(sem_handle.sem, SEM_INTR_CPU, true);
  14d086:	6bb0      	ldr	r0, [r6, #56]	; 0x38
  14d088:	2201      	movs	r2, #1
  14d08a:	2102      	movs	r1, #2
  14d08c:	f004 fc5a 	bl	151944 <sem_enable_intr>

        mutex_release(&sem_handle.lock);
  14d090:	4650      	mov	r0, r10
  14d092:	f002 f8c7 	bl	14f224 <mutex_release>
  14d096:	e7cd      	b.n	14d034 <sysd_worker+0x8c>

0014d098 <sysd_add_handler.part.0>:
    ASSERT(signal < MAX_SYSD_SIGNALS);
  14d098:	f646 13cc 	movw	r3, #27084	; 0x69cc
  14d09c:	f646 128c 	movw	r2, #27020	; 0x698c
static void sysd_add_handler(int signal, sysd_handler_t* handler, int tail)
  14d0a0:	b500      	push	{r14}
    ASSERT(signal < MAX_SYSD_SIGNALS);
  14d0a2:	f2c0 0315 	movt	r3, #21
  14d0a6:	f644 316c 	movw	r1, #19308	; 0x4b6c
static void sysd_add_handler(int signal, sysd_handler_t* handler, int tail)
  14d0aa:	b083      	sub	sp, #12
    ASSERT(signal < MAX_SYSD_SIGNALS);
  14d0ac:	4670      	mov	r0, r14
  14d0ae:	f2c0 0215 	movt	r2, #21
  14d0b2:	9300      	str	r3, [sp, #0]
  14d0b4:	f2c0 0115 	movt	r1, #21
  14d0b8:	2343      	movs	r3, #67	; 0x43
  14d0ba:	f005 fdfb 	bl	152cb4 <_panic>
  14d0be:	bf00      	nop

0014d0c0 <sysd_register_handler>:
{
  14d0c0:	b40c      	push	{r2, r3}
  14d0c2:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14d0c6:	4681      	mov	r9, r0
  14d0c8:	b082      	sub	sp, #8
  14d0ca:	468a      	mov	r10, r1
  14d0cc:	ab0a      	add	r3, sp, #40	; 0x28
  14d0ce:	4831      	ldr	r0, [pc, #196]	; (14d194 <sysd_register_handler+0xd4>)
  14d0d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14d0d4:	f853 7b04 	ldr.w	r7, [r3], #4
    va_start(ap,n);
  14d0d8:	9301      	str	r3, [sp, #4]
  14d0da:	f002 f877 	bl	14f1cc <mutex_acquire_timeout>
    for(int i=0;i<n;i++)
  14d0de:	2f00      	cmp	r7, #0
  14d0e0:	d043      	beq.n	14d16a <sysd_register_handler+0xaa>
    if(list->head == NULL && list->tail == NULL)
  14d0e2:	f643 7624 	movw	r6, #16164	; 0x3f24
                sem_map_signal(sem_handle.sem, signal, SEM_INTR_CPU, true);
  14d0e6:	f643 68e4 	movw	r8, #16100	; 0x3ee4
    if(list->head == NULL && list->tail == NULL)
  14d0ea:	f2c0 0616 	movt	r6, #22
    for(int i=0;i<n;i++)
  14d0ee:	2500      	movs	r5, #0
                sem_map_signal(sem_handle.sem, signal, SEM_INTR_CPU, true);
  14d0f0:	f2c0 0816 	movt	r8, #22
  14d0f4:	e019      	b.n	14d12a <sysd_register_handler+0x6a>
            handler->prev = NULL;
  14d0f6:	f04f 0c00 	mov.w	r12, #0
            list->head = handler;
  14d0fa:	191a      	adds	r2, r3, r4
            handler->prev = NULL;
  14d0fc:	e9c0 1c00 	strd	r1, r12, [r0]
            list->head = handler;
  14d100:	eb06 0282 	add.w	r2, r6, r2, lsl #2
            list->head->prev = handler;
  14d104:	6048      	str	r0, [r1, #4]
            list->head = handler;
  14d106:	6050      	str	r0, [r2, #4]
                sem_map_signal(sem_handle.sem, signal, SEM_INTR_CPU, true);
  14d108:	4621      	mov	r1, r4
    list->chain_len++;
  14d10a:	eb03 0c04 	add.w	r12, r3, r4
                sem_map_signal(sem_handle.sem, signal, SEM_INTR_CPU, true);
  14d10e:	2301      	movs	r3, #1
  14d110:	2202      	movs	r2, #2
  14d112:	f8d8 0038 	ldr.w	r0, [r8, #56]	; 0x38
    list->chain_len++;
  14d116:	f856 402c 	ldr.w	r4, [r6, r12, lsl #2]
  14d11a:	441c      	add	r4, r3
  14d11c:	f846 402c 	str.w	r4, [r6, r12, lsl #2]
                sem_map_signal(sem_handle.sem, signal, SEM_INTR_CPU, true);
  14d120:	f004 fc32 	bl	151988 <sem_map_signal>
    for(int i=0;i<n;i++)
  14d124:	3501      	adds	r5, #1
  14d126:	42bd      	cmp	r5, r7
  14d128:	d01f      	beq.n	14d16a <sysd_register_handler+0xaa>
        signal = va_arg(ap,int);
  14d12a:	9b01      	ldr	r3, [sp, #4]
  14d12c:	1d1a      	adds	r2, r3, #4
  14d12e:	681c      	ldr	r4, [r3, #0]
  14d130:	9201      	str	r2, [sp, #4]
        if(signal == NULL_SIGNAL)
  14d132:	1c63      	adds	r3, r4, #1
  14d134:	d0f6      	beq.n	14d124 <sysd_register_handler+0x64>
            phandler = malloc(sizeof(sysd_handler_t));
  14d136:	2010      	movs	r0, #16
  14d138:	f005 feaa 	bl	152e90 <malloc>
            if(!phandler)
  14d13c:	b300      	cbz	r0, 14d180 <sysd_register_handler+0xc0>
                phandler->evt_cb = cb;
  14d13e:	e9c0 9a02 	strd	r9, r10, [r0, #8]
    ASSERT(signal < MAX_SYSD_SIGNALS);
  14d142:	f5b4 7f9f 	cmp.w	r4, #318	; 0x13e
  14d146:	dc19      	bgt.n	14d17c <sysd_register_handler+0xbc>
    if(list->head == NULL && list->tail == NULL)
  14d148:	0063      	lsls	r3, r4, #1
  14d14a:	191a      	adds	r2, r3, r4
  14d14c:	eb06 0282 	add.w	r2, r6, r2, lsl #2
  14d150:	6851      	ldr	r1, [r2, #4]
  14d152:	2900      	cmp	r1, #0
  14d154:	d1cf      	bne.n	14d0f6 <sysd_register_handler+0x36>
  14d156:	f8d2 c008 	ldr.w	r12, [r2, #8]
  14d15a:	f1bc 0f00 	cmp.w	r12, #0
  14d15e:	d1ca      	bne.n	14d0f6 <sysd_register_handler+0x36>
        list->head = list->tail = handler;
  14d160:	e9c2 0001 	strd	r0, r0, [r2, #4]
        handler->prev = handler->next = NULL;
  14d164:	e9c0 cc00 	strd	r12, r12, [r0]
  14d168:	e7ce      	b.n	14d108 <sysd_register_handler+0x48>
    mutex_release(&sem_handle.lock);
  14d16a:	480a      	ldr	r0, [pc, #40]	; (14d194 <sysd_register_handler+0xd4>)
  14d16c:	f002 f85a 	bl	14f224 <mutex_release>
    return 0;
  14d170:	2000      	movs	r0, #0
}
  14d172:	b002      	add	sp, #8
  14d174:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14d178:	b002      	add	sp, #8
  14d17a:	4770      	bx	r14
  14d17c:	f7ff ff8c 	bl	14d098 <sysd_add_handler.part.0>
                mutex_release(&sem_handle.lock);
  14d180:	4804      	ldr	r0, [pc, #16]	; (14d194 <sysd_register_handler+0xd4>)
  14d182:	f002 f84f 	bl	14f224 <mutex_release>
                return -1;
  14d186:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14d18a:	b002      	add	sp, #8
  14d18c:	e8bd 47f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  14d190:	b002      	add	sp, #8
  14d192:	4770      	bx	r14
  14d194:	00163f00 	.word	0x00163f00

0014d198 <sysd_start>:
    }
}

void sysd_start(enum sem sem)
{
  14d198:	b500      	push	{r14}
    thread_t* sysd = thread_create("sysd",(thread_start_routine)sysd_worker,(void*)sem,THREAD_PRI_SYSDIAG,SYSD_WORKER_STACK_SZ);
  14d19a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
{
  14d19e:	b083      	sub	sp, #12
    thread_t* sysd = thread_create("sysd",(thread_start_routine)sysd_worker,(void*)sem,THREAD_PRI_SYSDIAG,SYSD_WORKER_STACK_SZ);
  14d1a0:	4602      	mov	r2, r0
  14d1a2:	f64c 71a9 	movw	r1, #53161	; 0xcfa9
  14d1a6:	f646 10e8 	movw	r0, #27112	; 0x69e8
  14d1aa:	f2c0 0114 	movt	r1, #20
  14d1ae:	9300      	str	r3, [sp, #0]
  14d1b0:	f2c0 0015 	movt	r0, #21
  14d1b4:	2310      	movs	r3, #16
  14d1b6:	f002 fa3b 	bl	14f630 <thread_create>
    thread_detach_and_resume(sysd);
}
  14d1ba:	b003      	add	sp, #12
  14d1bc:	f85d eb04 	ldr.w	r14, [r13], #4
    thread_detach_and_resume(sysd);
  14d1c0:	f002 bda0 	b.w	14fd04 <thread_detach_and_resume>

0014d1c4 <init_hwid_from_system.constprop.0>:
void clear_local_hwid(void)
{
    g_hwid_usr.magic = 0;
}

static bool init_hwid_from_system(struct sd_hwid_usr *id)
  14d1c4:	b570      	push	{r4, r5, r6, r14}
    struct sd_hwid_usr *usr;
    int count = 10000;
    uint32_t v;

    do {
        v = readl(_ioaddr(RSTGEN_HWID_REG));
  14d1c6:	f44f 4610 	mov.w	r6, #36864	; 0x9000
static bool init_hwid_from_system(struct sd_hwid_usr *id)
  14d1ca:	b082      	sub	sp, #8
  14d1cc:	f242 7511 	movw	r5, #10001	; 0x2711
        v = readl(_ioaddr(RSTGEN_HWID_REG));
  14d1d0:	f6cf 0641 	movt	r6, #63553	; 0xf841
  14d1d4:	e001      	b.n	14d1da <init_hwid_from_system.constprop.0+0x16>
        usr = (struct sd_hwid_usr *)&v;
        spin(100);
    } while (usr->magic != HW_ID_MAGIC && count-- > 0);
  14d1d6:	3d01      	subs	r5, #1
  14d1d8:	d011      	beq.n	14d1fe <init_hwid_from_system.constprop.0+0x3a>
        v = readl(_ioaddr(RSTGEN_HWID_REG));
  14d1da:	6834      	ldr	r4, [r6, #0]
        spin(100);
  14d1dc:	2064      	movs	r0, #100	; 0x64
        v = readl(_ioaddr(RSTGEN_HWID_REG));
  14d1de:	9401      	str	r4, [sp, #4]
        spin(100);
  14d1e0:	f005 fd56 	bl	152c90 <spin>
    } while (usr->magic != HW_ID_MAGIC && count-- > 0);
  14d1e4:	f004 040f 	and.w	r4, r4, #15
  14d1e8:	2c05      	cmp	r4, #5
  14d1ea:	d1f4      	bne.n	14d1d6 <init_hwid_from_system.constprop.0+0x12>
#endif
        *usr = g_hwid_usr_dummy;
    }

    //get hwid from rstgen reg
    *id = *usr;
  14d1ec:	f644 6318 	movw	r3, #19992	; 0x4e18
    return true;
}
  14d1f0:	2001      	movs	r0, #1
    *id = *usr;
  14d1f2:	9a01      	ldr	r2, [sp, #4]
  14d1f4:	f2c0 0316 	movt	r3, #22
  14d1f8:	601a      	str	r2, [r3, #0]
}
  14d1fa:	b002      	add	sp, #8
  14d1fc:	bd70      	pop	{r4, r5, r6, r15}
        printf("get hwid timeout, will use the dummy one?\n");
  14d1fe:	f646 20d4 	movw	r0, #27348	; 0x6ad4
  14d202:	f2c0 0015 	movt	r0, #21
  14d206:	f006 ff77 	bl	1540f8 <_printf>
        *usr = g_hwid_usr_dummy;
  14d20a:	f646 13f0 	movw	r3, #27120	; 0x69f0
  14d20e:	f2c0 0315 	movt	r3, #21
  14d212:	681b      	ldr	r3, [r3, #0]
  14d214:	9301      	str	r3, [sp, #4]
  14d216:	e7e9      	b.n	14d1ec <init_hwid_from_system.constprop.0+0x28>

0014d218 <get_part_id>:

    return g_hwid_usr;
}

int get_part_id(enum part_e part)
{
  14d218:	b570      	push	{r4, r5, r6, r14}
    return id->magic == HW_ID_MAGIC;
  14d21a:	f644 6418 	movw	r4, #19992	; 0x4e18
{
  14d21e:	4605      	mov	r5, r0
    return id->magic == HW_ID_MAGIC;
  14d220:	f2c0 0416 	movt	r4, #22
  14d224:	7822      	ldrb	r2, [r4, #0]
    if (!is_valid_hwid_usr(&g_hwid_usr))
  14d226:	f002 030f 	and.w	r3, r2, #15
  14d22a:	2b05      	cmp	r3, #5
  14d22c:	d11a      	bne.n	14d264 <get_part_id+0x4c>
        init_hwid_from_system(&g_hwid_usr);

    if (g_hwid_usr.magic != HW_ID_MAGIC)
        panic("magic num is not right, %d\n", g_hwid_usr.magic);

    if (g_hwid_usr.ver == 1) {
  14d22e:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
  14d232:	2a10      	cmp	r2, #16
  14d234:	d10e      	bne.n	14d254 <get_part_id+0x3c>
        struct version1 *v = &(g_hwid_usr.v.v1);
        GET_PART_ID(part, v);
  14d236:	2d08      	cmp	r5, #8
  14d238:	d806      	bhi.n	14d248 <get_part_id+0x30>
  14d23a:	e8df f005 	tbb	[r15, r5]
  14d23e:	2a26      	.short	0x2a26
  14d240:	3a36322e 	.word	0x3a36322e
  14d244:	423e      	.short	0x423e
  14d246:	23          	.byte	0x23
  14d247:	00          	.byte	0x00
  14d248:	f646 2094 	movw	r0, #27284	; 0x6a94
  14d24c:	f2c0 0015 	movt	r0, #21
  14d250:	f006 ff52 	bl	1540f8 <_printf>
    }

err:
    printf("code is too old to parse the id\n");
  14d254:	f646 20b0 	movw	r0, #27312	; 0x6ab0
  14d258:	f2c0 0015 	movt	r0, #21
  14d25c:	f006 ff4c 	bl	1540f8 <_printf>
    return 0;
  14d260:	2000      	movs	r0, #0
}
  14d262:	bd70      	pop	{r4, r5, r6, r15}
  14d264:	4676      	mov	r6, r14
        init_hwid_from_system(&g_hwid_usr);
  14d266:	f7ff ffad 	bl	14d1c4 <init_hwid_from_system.constprop.0>
    if (g_hwid_usr.magic != HW_ID_MAGIC)
  14d26a:	7822      	ldrb	r2, [r4, #0]
  14d26c:	f002 030f 	and.w	r3, r2, #15
  14d270:	2b05      	cmp	r3, #5
  14d272:	d0dc      	beq.n	14d22e <get_part_id+0x16>
        panic("magic num is not right, %d\n", g_hwid_usr.magic);
  14d274:	f646 2178 	movw	r1, #27256	; 0x6a78
  14d278:	461a      	mov	r2, r3
  14d27a:	4630      	mov	r0, r6
  14d27c:	f2c0 0115 	movt	r1, #21
  14d280:	f005 fd18 	bl	152cb4 <_panic>
        GET_PART_ID(part, v);
  14d284:	78e0      	ldrb	r0, [r4, #3]
  14d286:	0900      	lsrs	r0, r0, #4
}
  14d288:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d28a:	7860      	ldrb	r0, [r4, #1]
  14d28c:	f000 001f 	and.w	r0, r0, #31
}
  14d290:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d292:	7860      	ldrb	r0, [r4, #1]
  14d294:	f3c0 1041 	ubfx	r0, r0, #5, #2
}
  14d298:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d29a:	6820      	ldr	r0, [r4, #0]
  14d29c:	f3c0 30c1 	ubfx	r0, r0, #15, #2
}
  14d2a0:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d2a2:	78a0      	ldrb	r0, [r4, #2]
  14d2a4:	f3c0 0041 	ubfx	r0, r0, #1, #2
}
  14d2a8:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d2aa:	78a0      	ldrb	r0, [r4, #2]
  14d2ac:	f3c0 00c1 	ubfx	r0, r0, #3, #2
}
  14d2b0:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d2b2:	78a0      	ldrb	r0, [r4, #2]
  14d2b4:	f3c0 1041 	ubfx	r0, r0, #5, #2
}
  14d2b8:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d2ba:	8860      	ldrh	r0, [r4, #2]
  14d2bc:	f3c0 10c1 	ubfx	r0, r0, #7, #2
}
  14d2c0:	bd70      	pop	{r4, r5, r6, r15}
        GET_PART_ID(part, v);
  14d2c2:	78e0      	ldrb	r0, [r4, #3]
  14d2c4:	f3c0 0042 	ubfx	r0, r0, #1, #3
}
  14d2c8:	bd70      	pop	{r4, r5, r6, r15}
  14d2ca:	bf00      	nop

0014d2cc <get_hwid_friendly_name>:

    for (i = PART_CHIPID; i <= PART_BOARD_ID_MIN; i++)
        printf("part %d:%d\n", i, get_part_id(i));
}
char *get_hwid_friendly_name(char *hwid, int len)
{
  14d2cc:	b538      	push	{r3, r4, r5, r14}
  14d2ce:	4604      	mov	r4, r0
    enum sd_board_type_e type = BOARD_TYPE_UNKNOWN;

    //chipid
    switch (get_part_id(PART_CHIPID)) {
  14d2d0:	2000      	movs	r0, #0
  14d2d2:	f7ff ffa1 	bl	14d218 <get_part_id>
  14d2d6:	3801      	subs	r0, #1
  14d2d8:	280b      	cmp	r0, #11
  14d2da:	f200 80d9 	bhi.w	14d490 <get_hwid_friendly_name+0x1c4>
  14d2de:	e8df f000 	tbb	[r15, r0]
  14d2e2:	6739      	.short	0x6739
  14d2e4:	8b827970 	.word	0x8b827970
  14d2e8:	92928b8b 	.word	0x92928b8b
  14d2ec:	0692      	.short	0x0692
        case CHIPID_V9F:
            strcpy(hwid, "V9-");
            break;

        case CHIPID_D9A:
            strcpy(hwid, "D9-");
  14d2ee:	f646 2324 	movw	r3, #27172	; 0x6a24
  14d2f2:	f2c0 0315 	movt	r3, #21
  14d2f6:	6818      	ldr	r0, [r3, #0]
  14d2f8:	6020      	str	r0, [r4, #0]
            strcpy(hwid, "UNKNOWN-");
            break;
    }

    //board type
    type = get_part_id(PART_BOARD_TYPE);
  14d2fa:	2006      	movs	r0, #6
  14d2fc:	f7ff ff8c 	bl	14d218 <get_part_id>

    switch (type) {
  14d300:	2802      	cmp	r0, #2
  14d302:	d034      	beq.n	14d36e <get_hwid_friendly_name+0xa2>
  14d304:	2803      	cmp	r0, #3
  14d306:	f000 8085 	beq.w	14d414 <get_hwid_friendly_name+0x148>
  14d30a:	2801      	cmp	r0, #1
        case BOARD_TYPE_EVB:
            strcat(hwid, "EVB-");
  14d30c:	4620      	mov	r0, r4
    switch (type) {
  14d30e:	f000 80b2 	beq.w	14d476 <get_hwid_friendly_name+0x1aa>
        case BOARD_TYPE_MS:
            strcat(hwid, "MS_");
            break;

        default:
            strcat(hwid, "UNKNOWN-");
  14d312:	f006 ff63 	bl	1541dc <strlen>
  14d316:	f646 2328 	movw	r3, #27176	; 0x6a28
  14d31a:	f2c0 0315 	movt	r3, #21
  14d31e:	4605      	mov	r5, r0
  14d320:	1822      	adds	r2, r4, r0
  14d322:	cb03      	ldmia	r3!, {r0, r1}
  14d324:	781b      	ldrb	r3, [r3, #0]
  14d326:	5160      	str	r0, [r4, r5]
  14d328:	7213      	strb	r3, [r2, #8]
  14d32a:	6051      	str	r1, [r2, #4]
                sprintf(hwid, "%sBS%02d", hwid, minor);
                break;
        }
    }
    else {
        switch (get_part_id(PART_BOARD_ID_MAJ)) {
  14d32c:	2007      	movs	r0, #7
  14d32e:	f7ff ff73 	bl	14d218 <get_part_id>
  14d332:	3801      	subs	r0, #1
  14d334:	2801      	cmp	r0, #1
  14d336:	d82d      	bhi.n	14d394 <get_hwid_friendly_name+0xc8>
                strcat(hwid, "UNKNOWN");
                break;

            case BOARDID_MAJOR_G9A:
            case BOARDID_MAJOR_A:
                sprintf(hwid, "%sA%02d", hwid, get_part_id(PART_BOARD_ID_MIN));
  14d338:	2008      	movs	r0, #8
  14d33a:	f7ff ff6d 	bl	14d218 <get_part_id>
  14d33e:	f646 2170 	movw	r1, #27248	; 0x6a70
  14d342:	4622      	mov	r2, r4
  14d344:	f2c0 0115 	movt	r1, #21
  14d348:	4603      	mov	r3, r0
  14d34a:	4620      	mov	r0, r4
  14d34c:	f006 fe74 	bl	154038 <sprintf>
                break;
        }
    }

    return hwid;
}
  14d350:	4620      	mov	r0, r4
  14d352:	bd38      	pop	{r3, r4, r5, r15}
            strcpy(hwid, "X9E-");
  14d354:	f646 2304 	movw	r3, #27140	; 0x6a04
  14d358:	f2c0 0315 	movt	r3, #21
  14d35c:	791a      	ldrb	r2, [r3, #4]
  14d35e:	7122      	strb	r2, [r4, #4]
  14d360:	6818      	ldr	r0, [r3, #0]
  14d362:	6020      	str	r0, [r4, #0]
    type = get_part_id(PART_BOARD_TYPE);
  14d364:	2006      	movs	r0, #6
  14d366:	f7ff ff57 	bl	14d218 <get_part_id>
    switch (type) {
  14d36a:	2802      	cmp	r0, #2
  14d36c:	d1ca      	bne.n	14d304 <get_hwid_friendly_name+0x38>
            strcat(hwid, "REF-");
  14d36e:	4620      	mov	r0, r4
  14d370:	f006 ff34 	bl	1541dc <strlen>
  14d374:	f646 233c 	movw	r3, #27196	; 0x6a3c
  14d378:	f2c0 0315 	movt	r3, #21
  14d37c:	791d      	ldrb	r5, [r3, #4]
  14d37e:	4602      	mov	r2, r0
  14d380:	1821      	adds	r1, r4, r0
  14d382:	6818      	ldr	r0, [r3, #0]
  14d384:	50a0      	str	r0, [r4, r2]
        switch (get_part_id(PART_BOARD_ID_MAJ)) {
  14d386:	2007      	movs	r0, #7
            strcat(hwid, "REF-");
  14d388:	710d      	strb	r5, [r1, #4]
        switch (get_part_id(PART_BOARD_ID_MAJ)) {
  14d38a:	f7ff ff45 	bl	14d218 <get_part_id>
  14d38e:	3801      	subs	r0, #1
  14d390:	2801      	cmp	r0, #1
  14d392:	d9d1      	bls.n	14d338 <get_hwid_friendly_name+0x6c>
                strcat(hwid, "UNKNOWN");
  14d394:	4620      	mov	r0, r4
  14d396:	f006 ff21 	bl	1541dc <strlen>
  14d39a:	f646 235c 	movw	r3, #27228	; 0x6a5c
  14d39e:	f2c0 0315 	movt	r3, #21
  14d3a2:	4602      	mov	r2, r0
  14d3a4:	1825      	adds	r5, r4, r0
  14d3a6:	cb03      	ldmia	r3!, {r0, r1}
  14d3a8:	50a0      	str	r0, [r4, r2]
}
  14d3aa:	4620      	mov	r0, r4
                strcat(hwid, "UNKNOWN");
  14d3ac:	6069      	str	r1, [r5, #4]
}
  14d3ae:	bd38      	pop	{r3, r4, r5, r15}
            strcpy(hwid, "X9M-");
  14d3b0:	f646 13fc 	movw	r3, #27132	; 0x69fc
  14d3b4:	f2c0 0315 	movt	r3, #21
  14d3b8:	791a      	ldrb	r2, [r3, #4]
  14d3ba:	7122      	strb	r2, [r4, #4]
  14d3bc:	6818      	ldr	r0, [r3, #0]
  14d3be:	6020      	str	r0, [r4, #0]
            break;
  14d3c0:	e79b      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcpy(hwid, "X9H-");
  14d3c2:	f646 13f4 	movw	r3, #27124	; 0x69f4
  14d3c6:	f2c0 0315 	movt	r3, #21
  14d3ca:	791a      	ldrb	r2, [r3, #4]
  14d3cc:	7122      	strb	r2, [r4, #4]
  14d3ce:	6818      	ldr	r0, [r3, #0]
  14d3d0:	6020      	str	r0, [r4, #0]
            break;
  14d3d2:	e792      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcpy(hwid, "X9P-");
  14d3d4:	f646 230c 	movw	r3, #27148	; 0x6a0c
  14d3d8:	f2c0 0315 	movt	r3, #21
  14d3dc:	791a      	ldrb	r2, [r3, #4]
  14d3de:	7122      	strb	r2, [r4, #4]
  14d3e0:	6818      	ldr	r0, [r3, #0]
  14d3e2:	6020      	str	r0, [r4, #0]
            break;
  14d3e4:	e789      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcpy(hwid, "X9U-");
  14d3e6:	f646 2314 	movw	r3, #27156	; 0x6a14
  14d3ea:	f2c0 0315 	movt	r3, #21
  14d3ee:	791a      	ldrb	r2, [r3, #4]
  14d3f0:	7122      	strb	r2, [r4, #4]
  14d3f2:	6818      	ldr	r0, [r3, #0]
  14d3f4:	6020      	str	r0, [r4, #0]
            break;
  14d3f6:	e780      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcpy(hwid, "G9-");
  14d3f8:	f646 231c 	movw	r3, #27164	; 0x6a1c
  14d3fc:	f2c0 0315 	movt	r3, #21
  14d400:	6818      	ldr	r0, [r3, #0]
  14d402:	6020      	str	r0, [r4, #0]
            break;
  14d404:	e779      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcpy(hwid, "V9-");
  14d406:	f646 2320 	movw	r3, #27168	; 0x6a20
  14d40a:	f2c0 0315 	movt	r3, #21
  14d40e:	6818      	ldr	r0, [r3, #0]
  14d410:	6020      	str	r0, [r4, #0]
            break;
  14d412:	e772      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
            strcat(hwid, "MS_");
  14d414:	4620      	mov	r0, r4
  14d416:	f006 fee1 	bl	1541dc <strlen>
  14d41a:	f646 2344 	movw	r3, #27204	; 0x6a44
  14d41e:	f2c0 0315 	movt	r3, #21
  14d422:	4602      	mov	r2, r0
  14d424:	6818      	ldr	r0, [r3, #0]
  14d426:	50a0      	str	r0, [r4, r2]
        enum sd_boardid_ms_major_e ms_maj = get_part_id(PART_BOARD_ID_MAJ);
  14d428:	2007      	movs	r0, #7
  14d42a:	f7ff fef5 	bl	14d218 <get_part_id>
        switch (ms_maj) {
  14d42e:	2802      	cmp	r0, #2
  14d430:	d054      	beq.n	14d4dc <get_hwid_friendly_name+0x210>
  14d432:	2803      	cmp	r0, #3
  14d434:	d044      	beq.n	14d4c0 <get_hwid_friendly_name+0x1f4>
  14d436:	2801      	cmp	r0, #1
  14d438:	d034      	beq.n	14d4a4 <get_hwid_friendly_name+0x1d8>
                strcat(hwid, "UNKNOWN-");
  14d43a:	4620      	mov	r0, r4
  14d43c:	f006 fece 	bl	1541dc <strlen>
  14d440:	f646 2328 	movw	r3, #27176	; 0x6a28
  14d444:	f2c0 0315 	movt	r3, #21
  14d448:	4605      	mov	r5, r0
  14d44a:	1822      	adds	r2, r4, r0
  14d44c:	cb03      	ldmia	r3!, {r0, r1}
  14d44e:	781b      	ldrb	r3, [r3, #0]
  14d450:	5160      	str	r0, [r4, r5]
  14d452:	7213      	strb	r3, [r2, #8]
  14d454:	6051      	str	r1, [r2, #4]
        minor = get_part_id(PART_BOARD_ID_MIN);
  14d456:	2008      	movs	r0, #8
  14d458:	f7ff fede 	bl	14d218 <get_part_id>
        switch (minor) {
  14d45c:	2800      	cmp	r0, #0
  14d45e:	d099      	beq.n	14d394 <get_hwid_friendly_name+0xc8>
                sprintf(hwid, "%sBS%02d", hwid, minor);
  14d460:	f646 2164 	movw	r1, #27236	; 0x6a64
  14d464:	4603      	mov	r3, r0
  14d466:	4622      	mov	r2, r4
  14d468:	f2c0 0115 	movt	r1, #21
  14d46c:	4620      	mov	r0, r4
  14d46e:	f006 fde3 	bl	154038 <sprintf>
}
  14d472:	4620      	mov	r0, r4
  14d474:	bd38      	pop	{r3, r4, r5, r15}
            strcat(hwid, "EVB-");
  14d476:	f006 feb1 	bl	1541dc <strlen>
  14d47a:	f646 2334 	movw	r3, #27188	; 0x6a34
  14d47e:	f2c0 0315 	movt	r3, #21
  14d482:	791d      	ldrb	r5, [r3, #4]
  14d484:	4602      	mov	r2, r0
  14d486:	1821      	adds	r1, r4, r0
  14d488:	6818      	ldr	r0, [r3, #0]
  14d48a:	50a0      	str	r0, [r4, r2]
  14d48c:	710d      	strb	r5, [r1, #4]
            break;
  14d48e:	e74d      	b.n	14d32c <get_hwid_friendly_name+0x60>
            strcpy(hwid, "UNKNOWN-");
  14d490:	f646 2328 	movw	r3, #27176	; 0x6a28
  14d494:	f2c0 0315 	movt	r3, #21
  14d498:	cb03      	ldmia	r3!, {r0, r1}
  14d49a:	781b      	ldrb	r3, [r3, #0]
  14d49c:	6020      	str	r0, [r4, #0]
  14d49e:	7223      	strb	r3, [r4, #8]
  14d4a0:	6061      	str	r1, [r4, #4]
            break;
  14d4a2:	e72a      	b.n	14d2fa <get_hwid_friendly_name+0x2e>
                strcat(hwid, "MPS-");
  14d4a4:	4620      	mov	r0, r4
  14d4a6:	f006 fe99 	bl	1541dc <strlen>
  14d4aa:	f646 2348 	movw	r3, #27208	; 0x6a48
  14d4ae:	f2c0 0315 	movt	r3, #21
  14d4b2:	791d      	ldrb	r5, [r3, #4]
  14d4b4:	4602      	mov	r2, r0
  14d4b6:	1821      	adds	r1, r4, r0
  14d4b8:	6818      	ldr	r0, [r3, #0]
  14d4ba:	50a0      	str	r0, [r4, r2]
  14d4bc:	710d      	strb	r5, [r1, #4]
                break;
  14d4be:	e7ca      	b.n	14d456 <get_hwid_friendly_name+0x18a>
                strcat(hwid, "A02-");
  14d4c0:	4620      	mov	r0, r4
  14d4c2:	f006 fe8b 	bl	1541dc <strlen>
  14d4c6:	f646 2354 	movw	r3, #27220	; 0x6a54
  14d4ca:	f2c0 0315 	movt	r3, #21
  14d4ce:	791d      	ldrb	r5, [r3, #4]
  14d4d0:	4602      	mov	r2, r0
  14d4d2:	1821      	adds	r1, r4, r0
  14d4d4:	6818      	ldr	r0, [r3, #0]
  14d4d6:	50a0      	str	r0, [r4, r2]
  14d4d8:	710d      	strb	r5, [r1, #4]
                break;
  14d4da:	e7bc      	b.n	14d456 <get_hwid_friendly_name+0x18a>
                strcat(hwid, "TI-");
  14d4dc:	4620      	mov	r0, r4
  14d4de:	f006 fe7d 	bl	1541dc <strlen>
  14d4e2:	f646 2350 	movw	r3, #27216	; 0x6a50
  14d4e6:	f2c0 0315 	movt	r3, #21
  14d4ea:	4602      	mov	r2, r0
  14d4ec:	6818      	ldr	r0, [r3, #0]
  14d4ee:	50a0      	str	r0, [r4, r2]
                break;
  14d4f0:	e7b1      	b.n	14d456 <get_hwid_friendly_name+0x18a>
  14d4f2:	bf00      	nop

0014d4f4 <hal_clock_get_instance>:
//!
//! \return clkgen hanle
//
//*****************************************************************************
static clkgen_instance_t *hal_clock_get_instance(void)
{
  14d4f4:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14d4f6:	f3ef 8000 	mrs	r0, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14d4fa:	f010 0080 	ands.w	r0, r0, #128	; 0x80
  14d4fe:	d129      	bne.n	14d554 <hal_clock_get_instance+0x60>
    __asm__ volatile("cpsid i");
  14d500:	b672      	cpsid	i
    *statep = state;
  14d502:	f644 6244 	movw	r2, #20036	; 0x4e44
  14d506:	2101      	movs	r1, #1
    *lock = 1;
  14d508:	f644 631c 	movw	r3, #19996	; 0x4e1c
    *statep = state;
  14d50c:	f2c0 0216 	movt	r2, #22
    //spin_lock_saved_state_t states;
    spin_lock_irqsave(&clkgen_spin_lock, spin_lock_states);

    if (g_ClkgenInstance.occupied != 1) {
  14d510:	f644 6420 	movw	r4, #20000	; 0x4e20
    *lock = 1;
  14d514:	f2c0 0316 	movt	r3, #22
    *statep = state;
  14d518:	6011      	str	r1, [r2, #0]
  14d51a:	f2c0 0416 	movt	r4, #22
  14d51e:	7f22      	ldrb	r2, [r4, #28]
    *lock = 1;
  14d520:	6019      	str	r1, [r3, #0]
  14d522:	428a      	cmp	r2, r1
  14d524:	d02c      	beq.n	14d580 <hal_clock_get_instance+0x8c>
        memset(&g_ClkgenInstance, 0, sizeof(clkgen_instance_t));
  14d526:	f644 6020 	movw	r0, #20000	; 0x4e20
  14d52a:	2220      	movs	r2, #32
  14d52c:	2100      	movs	r1, #0
  14d52e:	f2c0 0016 	movt	r0, #22
  14d532:	f005 eda4 	blx	15307c <memset>
    *controllerTable = &s_ClkgenDrvInterface;
  14d536:	f646 3380 	movw	r3, #27520	; 0x6b80
        /* get clkgen driver API table */
        hal_clock_get_controller_interface(&(g_ClkgenInstance.controllerTable));

        if (g_ClkgenInstance.controllerTable) {
            g_ClkgenInstance.occupied = 1;
  14d53a:	2201      	movs	r2, #1
    *controllerTable = &s_ClkgenDrvInterface;
  14d53c:	f2c0 0315 	movt	r3, #21
            //sec clkgen
            g_ClkgenInstance.controllerTable->get_default_config(&
  14d540:	4811      	ldr	r0, [pc, #68]	; (14d588 <hal_clock_get_instance+0x94>)
    *controllerTable = &s_ClkgenDrvInterface;
  14d542:	6223      	str	r3, [r4, #32]
            g_ClkgenInstance.occupied = 1;
  14d544:	7722      	strb	r2, [r4, #28]
            g_ClkgenInstance.controllerTable->get_default_config(&
  14d546:	f7f4 ffbb 	bl	1424c0 <clkgen_get_default_config>
                    (g_ClkgenInstance.def_cfg));
        }

        //spin_unlock_irqrestore(&clkgen_spin_lock, states);
        LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL, "hal_clock_get_instance is ok \n");
        return &g_ClkgenInstance;
  14d54a:	f644 6020 	movw	r0, #20000	; 0x4e20
  14d54e:	f2c0 0016 	movt	r0, #22

    LTRACEF_LEVEL(DEFAULT_CLKGEN_LOG_LEVEL,
                  "hal_clock_get_instance is failed \n");
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
    return NULL;
}
  14d552:	bd10      	pop	{r4, r15}
    *statep = state;
  14d554:	f644 6244 	movw	r2, #20036	; 0x4e44
  14d558:	2000      	movs	r0, #0
    *lock = 1;
  14d55a:	2101      	movs	r1, #1
    *statep = state;
  14d55c:	f2c0 0216 	movt	r2, #22
    *lock = 1;
  14d560:	f644 631c 	movw	r3, #19996	; 0x4e1c
    if (g_ClkgenInstance.occupied != 1) {
  14d564:	f644 6420 	movw	r4, #20000	; 0x4e20
    *statep = state;
  14d568:	6010      	str	r0, [r2, #0]
    *lock = 1;
  14d56a:	f2c0 0316 	movt	r3, #22
  14d56e:	f2c0 0416 	movt	r4, #22
  14d572:	7f22      	ldrb	r2, [r4, #28]
  14d574:	6019      	str	r1, [r3, #0]
  14d576:	428a      	cmp	r2, r1
    *lock = 0;
  14d578:	bf08      	it	eq
  14d57a:	6018      	streq	r0, [r3, #0]
  14d57c:	d1d3      	bne.n	14d526 <hal_clock_get_instance+0x32>
  14d57e:	e7e8      	b.n	14d552 <hal_clock_get_instance+0x5e>
  14d580:	6018      	str	r0, [r3, #0]
    __asm__ volatile("cpsie i");
  14d582:	b662      	cpsie	i
}
  14d584:	bd10      	pop	{r4, r15}
  14d586:	bf00      	nop
  14d588:	00164e3d 	.word	0x00164e3d

0014d58c <hal_clock_release_handle.part.2>:
//
//*****************************************************************************
bool hal_clock_release_handle(void *handle)
{
    clkgen_instance_t *l_clkgenInstance = NULL;
    ASSERT((handle != NULL));
  14d58c:	f646 3350 	movw	r3, #27472	; 0x6b50
  14d590:	f646 3214 	movw	r2, #27412	; 0x6b14
bool hal_clock_release_handle(void *handle)
  14d594:	b500      	push	{r14}
    ASSERT((handle != NULL));
  14d596:	f2c0 0315 	movt	r3, #21
  14d59a:	f644 316c 	movw	r1, #19308	; 0x4b6c
bool hal_clock_release_handle(void *handle)
  14d59e:	b083      	sub	sp, #12
    ASSERT((handle != NULL));
  14d5a0:	4670      	mov	r0, r14
  14d5a2:	f2c0 0215 	movt	r2, #21
  14d5a6:	9300      	str	r3, [sp, #0]
  14d5a8:	f2c0 0115 	movt	r1, #21
  14d5ac:	23b9      	movs	r3, #185	; 0xb9
  14d5ae:	f005 fb81 	bl	152cb4 <_panic>
  14d5b2:	bf00      	nop

0014d5b4 <hal_clock_release_instance>:
    ASSERT((clkgenInstance != NULL));
  14d5b4:	b178      	cbz	r0, 14d5d6 <hal_clock_release_instance+0x22>
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  14d5b6:	f644 6244 	movw	r2, #20036	; 0x4e44
  14d5ba:	f644 631c 	movw	r3, #19996	; 0x4e1c
  14d5be:	f2c0 0216 	movt	r2, #22
    clkgenInstance->occupied = 0;
  14d5c2:	2100      	movs	r1, #0
  14d5c4:	f2c0 0316 	movt	r3, #22
    spin_unlock_irqrestore(&clkgen_spin_lock, spin_lock_states);
  14d5c8:	6812      	ldr	r2, [r2, #0]
  14d5ca:	6019      	str	r1, [r3, #0]
    clkgenInstance->occupied = 0;
  14d5cc:	7701      	strb	r1, [r0, #28]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14d5ce:	07d3      	lsls	r3, r2, #31
  14d5d0:	d500      	bpl.n	14d5d4 <hal_clock_release_instance+0x20>
  14d5d2:	b662      	cpsie	i
  14d5d4:	4770      	bx	r14
    ASSERT((clkgenInstance != NULL));
  14d5d6:	f646 3364 	movw	r3, #27492	; 0x6b64
  14d5da:	f646 3214 	movw	r2, #27412	; 0x6b14
{
  14d5de:	b500      	push	{r14}
    ASSERT((clkgenInstance != NULL));
  14d5e0:	f2c0 0315 	movt	r3, #21
  14d5e4:	f644 316c 	movw	r1, #19308	; 0x4b6c
{
  14d5e8:	b083      	sub	sp, #12
  14d5ea:	4670      	mov	r0, r14
    ASSERT((clkgenInstance != NULL));
  14d5ec:	f2c0 0215 	movt	r2, #21
  14d5f0:	9300      	str	r3, [sp, #0]
  14d5f2:	f2c0 0115 	movt	r1, #21
  14d5f6:	2387      	movs	r3, #135	; 0x87
  14d5f8:	f005 fb5c 	bl	152cb4 <_panic>

0014d5fc <hal_clock_creat_handle>:
{
  14d5fc:	b510      	push	{r4, r14}
  14d5fe:	b082      	sub	sp, #8
    ASSERT((handle != NULL));
  14d600:	b138      	cbz	r0, 14d612 <hal_clock_creat_handle+0x16>
  14d602:	4604      	mov	r4, r0
    clkgenInstance = hal_clock_get_instance();
  14d604:	f7ff ff76 	bl	14d4f4 <hal_clock_get_instance>
    if (clkgenInstance == NULL) {
  14d608:	b108      	cbz	r0, 14d60e <hal_clock_creat_handle+0x12>
    *handle = clkgenInstance;
  14d60a:	6020      	str	r0, [r4, #0]
    return true;
  14d60c:	2001      	movs	r0, #1
}
  14d60e:	b002      	add	sp, #8
  14d610:	bd10      	pop	{r4, r15}
    ASSERT((handle != NULL));
  14d612:	f646 3350 	movw	r3, #27472	; 0x6b50
  14d616:	f646 3214 	movw	r2, #27412	; 0x6b14
  14d61a:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14d61e:	f2c0 0315 	movt	r3, #21
  14d622:	4670      	mov	r0, r14
  14d624:	f2c0 0215 	movt	r2, #21
  14d628:	9300      	str	r3, [sp, #0]
  14d62a:	f2c0 0115 	movt	r1, #21
  14d62e:	239b      	movs	r3, #155	; 0x9b
  14d630:	f005 fb40 	bl	152cb4 <_panic>

0014d634 <hal_clock_release_handle>:
{
  14d634:	b508      	push	{r3, r14}
    ASSERT((handle != NULL));
  14d636:	b118      	cbz	r0, 14d640 <hal_clock_release_handle+0xc>
    l_clkgenInstance = (clkgen_instance_t *)handle;
    hal_clock_release_instance(l_clkgenInstance);
  14d638:	f7ff ffbc 	bl	14d5b4 <hal_clock_release_instance>
    // mutex_destroy(&l_clkgenInstance->clkgenMutex);
    return true;
}
  14d63c:	2001      	movs	r0, #1
  14d63e:	bd08      	pop	{r3, r15}
  14d640:	f7ff ffa4 	bl	14d58c <hal_clock_release_handle.part.2>

0014d644 <hal_clock_ipclk_set>:
//! \return bool status
//
//*****************************************************************************
bool hal_clock_ipclk_set(void *g_handle, uint32_t res_glb_idx,
                         clkgen_app_ip_cfg_t *ip_cfg)
{
  14d644:	b530      	push	{r4, r5, r14}
    int ret = -1;
    paddr_t phy_addr;
    vaddr_t clkgen_base_addr = 0x0;
    clkgen_instance_t *l_clkgenInstance = NULL;
    int32_t ip_slice_idx = -1;
  14d646:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  14d64a:	b085      	sub	sp, #20
    int32_t ip_slice_idx = -1;
  14d64c:	9303      	str	r3, [sp, #12]
    ASSERT((g_handle != NULL));
  14d64e:	b1d0      	cbz	r0, 14d686 <hal_clock_ipclk_set+0x42>
  14d650:	4615      	mov	r5, r2
  14d652:	4604      	mov	r4, r0
    l_clkgenInstance = (clkgen_instance_t *)g_handle;
    ret = res_get_info_by_id(res_glb_idx, &phy_addr, &ip_slice_idx);
  14d654:	4608      	mov	r0, r1
  14d656:	aa03      	add	r2, sp, #12
  14d658:	a902      	add	r1, sp, #8
  14d65a:	f000 ff33 	bl	14e4c4 <res_get_info_by_id>

    if (ret == -1) {
  14d65e:	3001      	adds	r0, #1
  14d660:	d00e      	beq.n	14d680 <hal_clock_ipclk_set+0x3c>
        return false;
    }

    clkgen_base_addr = (vaddr_t)_ioaddr(phy_addr);

    if ((ip_slice_idx != -1) && (ip_slice_idx >= DEFAULT_IPSLICE_IDX_START)
  14d662:	9903      	ldr	r1, [sp, #12]
  14d664:	2900      	cmp	r1, #0
  14d666:	db0b      	blt.n	14d680 <hal_clock_ipclk_set+0x3c>
            && l_clkgenInstance->controllerTable->ip_slice_set) {
  14d668:	6a23      	ldr	r3, [r4, #32]
  14d66a:	68dc      	ldr	r4, [r3, #12]
  14d66c:	b1ec      	cbz	r4, 14d6aa <hal_clock_ipclk_set+0x66>
        //set clk src and div
        if (l_clkgenInstance->controllerTable->ip_slice_set(clkgen_base_addr,
  14d66e:	88ab      	ldrh	r3, [r5, #4]
  14d670:	782a      	ldrb	r2, [r5, #0]
  14d672:	9802      	ldr	r0, [sp, #8]
  14d674:	892d      	ldrh	r5, [r5, #8]
  14d676:	9500      	str	r5, [sp, #0]
  14d678:	b2c9      	uxtb	r1, r1
  14d67a:	47a0      	blx	r4
    }

    LTRACEF("hal_clock_ipclk_set not find res_glb_idx:0x%x  slice_idx:%d\n",
            res_glb_idx, ip_slice_idx);
    return false;
}
  14d67c:	b005      	add	sp, #20
  14d67e:	bd30      	pop	{r4, r5, r15}
        return false;
  14d680:	2000      	movs	r0, #0
}
  14d682:	b005      	add	sp, #20
  14d684:	bd30      	pop	{r4, r5, r15}
    ASSERT((g_handle != NULL));
  14d686:	f646 3300 	movw	r3, #27392	; 0x6b00
  14d68a:	f646 3214 	movw	r2, #27412	; 0x6b14
  14d68e:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14d692:	f2c0 0315 	movt	r3, #21
  14d696:	4670      	mov	r0, r14
  14d698:	f2c0 0215 	movt	r2, #21
  14d69c:	9300      	str	r3, [sp, #0]
  14d69e:	f2c0 0115 	movt	r1, #21
  14d6a2:	f240 3315 	movw	r3, #789	; 0x315
  14d6a6:	f005 fb05 	bl	152cb4 <_panic>
        return false;
  14d6aa:	4620      	mov	r0, r4
  14d6ac:	e7e6      	b.n	14d67c <hal_clock_ipclk_set+0x38>
  14d6ae:	bf00      	nop

0014d6b0 <hal_crypto_init>:
//
//*****************************************************************************
void hal_crypto_init(uint level)
{

    ce_globle_init();
  14d6b0:	f7f5 bfd0 	b.w	143654 <ce_globle_init>

0014d6b4 <hal_crypto_creat_handle>:
{
  14d6b4:	b5f0      	push	{r4, r5, r6, r7, r14}
    paddr_t phy_addr = 0;
  14d6b6:	2400      	movs	r4, #0
{
  14d6b8:	b083      	sub	sp, #12
  14d6ba:	460d      	mov	r5, r1
    int32_t index = 0;
  14d6bc:	aa02      	add	r2, sp, #8
    paddr_t phy_addr = 0;
  14d6be:	9400      	str	r4, [sp, #0]
{
  14d6c0:	4606      	mov	r6, r0
    int32_t index = 0;
  14d6c2:	f842 4d04 	str.w	r4, [r2, #-4]!
    ret = res_get_info_by_id(crypto_idx,&phy_addr,&index);
  14d6c6:	4608      	mov	r0, r1
  14d6c8:	4669      	mov	r1, r13
  14d6ca:	f000 fefb 	bl	14e4c4 <res_get_info_by_id>
    if(ret == -1){
  14d6ce:	3001      	adds	r0, #1
  14d6d0:	d00f      	beq.n	14d6f2 <hal_crypto_creat_handle+0x3e>
  14d6d2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    for (i = 0; i < VCE_NUM_MAX; i++) {
  14d6d6:	4623      	mov	r3, r4
  14d6d8:	4a32      	ldr	r2, [pc, #200]	; (14d7a4 <hal_crypto_creat_handle+0xf0>)
    if(ret == -1){
  14d6da:	f2c0 5112 	movt	r1, #1298	; 0x512
  14d6de:	e001      	b.n	14d6e4 <hal_crypto_creat_handle+0x30>
  14d6e0:	f852 1c08 	ldr.w	r1, [r2, #-8]
        if (residx2ceid[i][1] == res_idx) {
  14d6e4:	428d      	cmp	r5, r1
  14d6e6:	f102 0208 	add.w	r2, r2, #8
  14d6ea:	d005      	beq.n	14d6f8 <hal_crypto_creat_handle+0x44>
    for (i = 0; i < VCE_NUM_MAX; i++) {
  14d6ec:	3301      	adds	r3, #1
  14d6ee:	2b09      	cmp	r3, #9
  14d6f0:	d1f6      	bne.n	14d6e0 <hal_crypto_creat_handle+0x2c>
        return CRYPTO_HAL_ERROR;
  14d6f2:	2001      	movs	r0, #1
}
  14d6f4:	b003      	add	sp, #12
  14d6f6:	bdf0      	pop	{r4, r5, r6, r7, r15}
            ret = residx2ceid[i][0];
  14d6f8:	f646 4260 	movw	r2, #27744	; 0x6c60
  14d6fc:	f2c0 0215 	movt	r2, #21
  14d700:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
    if (vce_id == -1) {
  14d704:	1c43      	adds	r3, r0, #1
  14d706:	d0f4      	beq.n	14d6f2 <hal_crypto_creat_handle+0x3e>
    if (g_cryptoinstance[i].is_created == 0) {
  14d708:	f644 6348 	movw	r3, #20040	; 0x4e48
  14d70c:	00c4      	lsls	r4, r0, #3
  14d70e:	1822      	adds	r2, r4, r0
  14d710:	f2c0 0316 	movt	r3, #22
  14d714:	0112      	lsls	r2, r2, #4
  14d716:	1899      	adds	r1, r3, r2
  14d718:	790f      	ldrb	r7, [r1, #4]
  14d71a:	2f00      	cmp	r7, #0
  14d71c:	d13b      	bne.n	14d796 <hal_crypto_creat_handle+0xe2>
        if (res_idx == support_pka_residx[i]) {
  14d71e:	f44f 5c80 	mov.w	r12, #4096	; 0x1000
  14d722:	f1a5 67a2 	sub.w	r7, r5, #84934656	; 0x5100000
  14d726:	f5a7 3704 	sub.w	r7, r7, #135168	; 0x21000
        g_cryptoinstance[i].vce_in_used = 1;
  14d72a:	f04f 0e01 	mov.w	r14, #1
        if (res_idx == support_pka_residx[i]) {
  14d72e:	f2c0 4c12 	movt	r12, #1042	; 0x412
        g_cryptoinstance[i].vce_id = vce_id;
  14d732:	5098      	str	r0, [r3, r2]
        if (res_idx == support_pka_residx[i]) {
  14d734:	4565      	cmp	r5, r12
  14d736:	bf18      	it	ne
  14d738:	2f03      	cmpne	r7, #3
        g_cryptoinstance[i].vce_in_used = 1;
  14d73a:	f881 e005 	strb.w	r14, [r1, #5]
        if (res_idx == support_pka_residx[i]) {
  14d73e:	d80e      	bhi.n	14d75e <hal_crypto_creat_handle+0xaa>
            g_cryptoinstance[i].rsa_method = (RSA_METHOD*)&RSA_default_method;
  14d740:	f646 4738 	movw	r7, #27704	; 0x6c38
            g_cryptoinstance[i].ec_method = (EC_METHOD*)&EC_default_method;
  14d744:	f646 35fc 	movw	r5, #27644	; 0x6bfc
            g_cryptoinstance[i].dsa_method = (DSA_METHOD*)&DSA_default_method;
  14d748:	f646 32ec 	movw	r2, #27628	; 0x6bec
            g_cryptoinstance[i].rsa_method = (RSA_METHOD*)&RSA_default_method;
  14d74c:	f2c0 0715 	movt	r7, #21
            g_cryptoinstance[i].ec_method = (EC_METHOD*)&EC_default_method;
  14d750:	f2c0 0515 	movt	r5, #21
            g_cryptoinstance[i].rsa_method = (RSA_METHOD*)&RSA_default_method;
  14d754:	678f      	str	r7, [r1, #120]	; 0x78
            g_cryptoinstance[i].dsa_method = (DSA_METHOD*)&DSA_default_method;
  14d756:	f2c0 0215 	movt	r2, #21
  14d75a:	e9c1 5222 	strd	r5, r2, [r1, #136]	; 0x88
        g_cryptoinstance[i].aes_method = (AES_METHOD*)&AES_default_method;
  14d75e:	f646 31e8 	movw	r1, #27624	; 0x6be8
  14d762:	4404      	add	r4, r0
        g_cryptoinstance[i].hash_method = (HASH_METHOD*)&HASH_default_method;
  14d764:	f646 4220 	movw	r2, #27680	; 0x6c20
        g_cryptoinstance[i].aes_method = (AES_METHOD*)&AES_default_method;
  14d768:	f2c0 0115 	movt	r1, #21
  14d76c:	eb03 1404 	add.w	r4, r3, r4, lsl #4
        g_cryptoinstance[i].rng_method = (RNG_METHOD*)&RNG_default_method;
  14d770:	f646 4330 	movw	r3, #27696	; 0x6c30
        g_cryptoinstance[i].hash_method = (HASH_METHOD*)&HASH_default_method;
  14d774:	f2c0 0215 	movt	r2, #21
        g_cryptoinstance[i].rng_method = (RNG_METHOD*)&RNG_default_method;
  14d778:	f2c0 0315 	movt	r3, #21
        g_cryptoinstance[i].hash_method = (HASH_METHOD*)&HASH_default_method;
  14d77c:	e9c4 121f 	strd	r1, r2, [r4, #124]	; 0x7c
        g_cryptoinstance[i].rng_method = (RNG_METHOD*)&RNG_default_method;
  14d780:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        ce_init(vce_id);
  14d784:	f7f5 ff36 	bl	1435f4 <ce_init>
        g_cryptoinstance[i].is_created = 1;
  14d788:	2201      	movs	r2, #1
        return &g_cryptoinstance[i];
  14d78a:	4623      	mov	r3, r4
        g_cryptoinstance[i].is_created = 1;
  14d78c:	7122      	strb	r2, [r4, #4]
    *handle = cryptoinstance;
  14d78e:	6033      	str	r3, [r6, #0]
    return CRYPTO_HAL_OK;
  14d790:	2000      	movs	r0, #0
}
  14d792:	b003      	add	sp, #12
  14d794:	bdf0      	pop	{r4, r5, r6, r7, r15}
        if (g_cryptoinstance[i].vce_in_used == 0) {
  14d796:	794b      	ldrb	r3, [r1, #5]
  14d798:	2b00      	cmp	r3, #0
  14d79a:	d1aa      	bne.n	14d6f2 <hal_crypto_creat_handle+0x3e>
            g_cryptoinstance[i].vce_in_used = 1;
  14d79c:	2201      	movs	r2, #1
            return &g_cryptoinstance[i];
  14d79e:	460b      	mov	r3, r1
            g_cryptoinstance[i].vce_in_used = 1;
  14d7a0:	714a      	strb	r2, [r1, #5]
  14d7a2:	e7f4      	b.n	14d78e <hal_crypto_creat_handle+0xda>
  14d7a4:	00156c6c 	.word	0x00156c6c

0014d7a8 <hal_crypto_delete_handle>:
    if (handle == NULL) {
  14d7a8:	4603      	mov	r3, r0
  14d7aa:	b118      	cbz	r0, 14d7b4 <hal_crypto_delete_handle+0xc>
        l_cryptoinstance->vce_in_used = 0;
  14d7ac:	2200      	movs	r2, #0
    crypto_hal_status_t ret = CRYPTO_HAL_OK;
  14d7ae:	4610      	mov	r0, r2
        l_cryptoinstance->vce_in_used = 0;
  14d7b0:	715a      	strb	r2, [r3, #5]
  14d7b2:	4770      	bx	r14
        ret = CRYPTO_HAL_ERROR;
  14d7b4:	2001      	movs	r0, #1
}
  14d7b6:	4770      	bx	r14

0014d7b8 <hal_trng_init>:
//*****************************************************************************
crypto_hal_status_t hal_trng_init(void* handle, crypto_config_t* crypto_cfg)
{
    crypto_hal_status_t ret = CRYPTO_HAL_OK;

    ret = trng_init(0);
  14d7b8:	2000      	movs	r0, #0
  14d7ba:	f7f8 bc0d 	b.w	145fd8 <trng_init>
  14d7be:	bf00      	nop

0014d7c0 <hal_aes_init>:
//*****************************************************************************

crypto_status_t hal_aes_init(void* handle, sd_aes_fct_t fct, aes_operation_t operation_type, buff_addr_type_t key_addr_type,
                         const uint8_t* key1, const uint8_t* key2, uint32_t key_len,
                         const uint8_t* iv, uint32_t iv_len)
{
  14d7c0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14d7c4:	b09c      	sub	sp, #112	; 0x70
  14d7c6:	e9dd 6725 	ldrd	r6, r7, [r13, #148]	; 0x94
    crypto_instance_t* l_cryptoinstance = NULL;
    uint32_t key_len_temp = 0;
    addr_t addr_key, addr_xkey = 0;
    //uint32_t i=0;

    if (handle == NULL) {
  14d7ca:	2800      	cmp	r0, #0
  14d7cc:	f000 8081 	beq.w	14d8d2 <hal_aes_init+0x112>
  14d7d0:	461d      	mov	r5, r3

        /*do ce init and enable here*/

        l_cryptoinstance->fct = fct;
        l_cryptoinstance->operation_type = operation_type;
        l_cryptoinstance->key_addr_type = key_addr_type == HAL_SRAM_PUB ? HAL_SRAM_PUB : HAL_SRAM_SEC;
  14d7d2:	3300      	adds	r3, #0
  14d7d4:	bf18      	it	ne
  14d7d6:	2301      	movne	r3, #1
  14d7d8:	4604      	mov	r4, r0
        l_cryptoinstance->fct = fct;
  14d7da:	7201      	strb	r1, [r0, #8]
        l_cryptoinstance->operation_type = operation_type;
  14d7dc:	7242      	strb	r2, [r0, #9]
        l_cryptoinstance->key_addr_type = key_addr_type == HAL_SRAM_PUB ? HAL_SRAM_PUB : HAL_SRAM_SEC;
  14d7de:	7283      	strb	r3, [r0, #10]

        if (iv == NULL) {
  14d7e0:	2e00      	cmp	r6, #0
  14d7e2:	d042      	beq.n	14d86a <hal_aes_init+0xaa>
  14d7e4:	2103      	movs	r1, #3
                }

            }
        }
        else {
            ret = memcpy_blk(l_cryptoinstance->vce_id,
  14d7e6:	aa0d      	add	r2, sp, #52	; 0x34
  14d7e8:	960d      	str	r6, [sp, #52]	; 0x34
  14d7ea:	ab0a      	add	r3, sp, #40	; 0x28
  14d7ec:	e9cd 710e 	strd	r7, r1, [r13, #56]	; 0x38
  14d7f0:	2600      	movs	r6, #0
  14d7f2:	ca07      	ldmia	r2, {r0, r1, r2}
  14d7f4:	f8d4 c000 	ldr.w	r12, [r4]
  14d7f8:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14d7fc:	2201      	movs	r2, #1
  14d7fe:	4660      	mov	r0, r12
  14d800:	970b      	str	r7, [sp, #44]	; 0x2c
  14d802:	9703      	str	r7, [sp, #12]
  14d804:	960a      	str	r6, [sp, #40]	; 0x28
  14d806:	920c      	str	r2, [sp, #48]	; 0x30
  14d808:	cb0e      	ldmia	r3, {r1, r2, r3}
  14d80a:	f7f7 fb55 	bl	144eb8 <memcpy_blk>
                                block_t_convert((void*)CE2_SRAM_SEC_AES_IV_ADDR_OFFSET, iv_len, SRAM_SEC),
                                block_t_convert(iv, iv_len, EXT_MEM), iv_len);

            if (ret) {
  14d80e:	bb48      	cbnz	r0, 14d864 <hal_aes_init+0xa4>
                return ret;
            }

            l_cryptoinstance->aes_iv_len = iv_len;
  14d810:	7427      	strb	r7, [r4, #16]
        }

        key_len_temp = key_len > AES_KEY_SIZE_MAX ? AES_KEY_SIZE_MAX : key_len;
  14d812:	9e24      	ldr	r6, [sp, #144]	; 0x90
  14d814:	2e20      	cmp	r6, #32
  14d816:	bf28      	it	cs
  14d818:	2620      	movcs	r6, #32

        if (HAL_KEY_INT != key_addr_type) { //key just in HAL_SRAM_PUB/sram_sec/key_interface
  14d81a:	2d02      	cmp	r5, #2
  14d81c:	d047      	beq.n	14d8ae <hal_aes_init+0xee>

            addr_key = CE2_SRAM_SEC_AES_KEY_ADDR_OFFSET;

            ret = memcpy_blk(l_cryptoinstance->vce_id,
  14d81e:	aa13      	add	r2, sp, #76	; 0x4c
  14d820:	f894 c00a 	ldrb.w	r12, [r4, #10]
  14d824:	f04f 0803 	mov.w	r8, #3
  14d828:	ab10      	add	r3, sp, #64	; 0x40
  14d82a:	9922      	ldr	r1, [sp, #136]	; 0x88
  14d82c:	2510      	movs	r5, #16
  14d82e:	9113      	str	r1, [sp, #76]	; 0x4c
  14d830:	e9cd 6814 	strd	r6, r8, [r13, #80]	; 0x50
  14d834:	ca07      	ldmia	r2, {r0, r1, r2}
  14d836:	6827      	ldr	r7, [r4, #0]
  14d838:	9611      	str	r6, [sp, #68]	; 0x44
  14d83a:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14d83e:	f8cd c048 	str.w	r12, [r13, #72]	; 0x48
  14d842:	4638      	mov	r0, r7
  14d844:	9603      	str	r6, [sp, #12]
  14d846:	9510      	str	r5, [sp, #64]	; 0x40
  14d848:	cb0e      	ldmia	r3, {r1, r2, r3}
  14d84a:	f7f7 fb35 	bl	144eb8 <memcpy_blk>
                                block_t_convert((void*)addr_key, key_len_temp, l_cryptoinstance->key_addr_type), 
                                block_t_convert(key1, key_len_temp, EXT_MEM), key_len_temp);

            if (ret) {
  14d84e:	b948      	cbnz	r0, 14d864 <hal_aes_init+0xa4>
                return ret;
            }

            if (SD_FCT_XTS == l_cryptoinstance->fct) {
  14d850:	7a23      	ldrb	r3, [r4, #8]
  14d852:	2b07      	cmp	r3, #7
  14d854:	d045      	beq.n	14d8e2 <hal_aes_init+0x122>
    addr_t addr_key, addr_xkey = 0;
  14d856:	2700      	movs	r7, #0
            if (SD_FCT_XTS == l_cryptoinstance->fct) {
                addr_xkey = key_int_addr_table[(l_cryptoinstance->aes_key_len - 16) >> 3][1];
            }
        }

        l_cryptoinstance->aes_key = addr_key;
  14d858:	6165      	str	r5, [r4, #20]
        l_cryptoinstance->aes_key_x = addr_xkey;
        l_cryptoinstance->aes_key_len = key_len_temp;

        l_cryptoinstance->aes_iv = CE2_SRAM_SEC_AES_IV_ADDR_OFFSET;
  14d85a:	2300      	movs	r3, #0
        l_cryptoinstance->aes_key_len = key_len_temp;
  14d85c:	e9c4 7606 	strd	r7, r6, [r4, #24]
        l_cryptoinstance->aes_iv = CE2_SRAM_SEC_AES_IV_ADDR_OFFSET;
  14d860:	4618      	mov	r0, r3
  14d862:	60e3      	str	r3, [r4, #12]
    }

    return ret;
}
  14d864:	b01c      	add	sp, #112	; 0x70
  14d866:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            if (fct < SD_FCT_NUM_MAX) {
  14d86a:	2908      	cmp	r1, #8
  14d86c:	d8d1      	bhi.n	14d812 <hal_aes_init+0x52>
                if (iv_table[fct] == NULL) {
  14d86e:	f640 63c0 	movw	r3, #3776	; 0xec0
  14d872:	f2c0 0316 	movt	r3, #22
  14d876:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
  14d87a:	b383      	cbz	r3, 14d8de <hal_aes_init+0x11e>
  14d87c:	2710      	movs	r7, #16
                    ret = memcpy_blk(l_cryptoinstance->vce_id,
  14d87e:	aa07      	add	r2, sp, #28
  14d880:	2103      	movs	r1, #3
  14d882:	eb0d 0c07 	add.w	r12, r13, r7
  14d886:	9307      	str	r3, [sp, #28]
  14d888:	2301      	movs	r3, #1
  14d88a:	e9cd 7108 	strd	r7, r1, [r13, #32]
  14d88e:	ca07      	ldmia	r2, {r0, r1, r2}
  14d890:	9604      	str	r6, [sp, #16]
  14d892:	6826      	ldr	r6, [r4, #0]
  14d894:	9705      	str	r7, [sp, #20]
  14d896:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14d89a:	9703      	str	r7, [sp, #12]
  14d89c:	4630      	mov	r0, r6
  14d89e:	9306      	str	r3, [sp, #24]
  14d8a0:	e89c 000e 	ldmia.w	r12, {r1, r2, r3}
  14d8a4:	f7f7 fb08 	bl	144eb8 <memcpy_blk>
                    if (ret) {
  14d8a8:	2800      	cmp	r0, #0
  14d8aa:	d0b1      	beq.n	14d810 <hal_aes_init+0x50>
  14d8ac:	e7da      	b.n	14d864 <hal_aes_init+0xa4>
            addr_key = key_int_addr_table[(l_cryptoinstance->aes_key_len - 16) >> 3][0];
  14d8ae:	69e3      	ldr	r3, [r4, #28]
            if (SD_FCT_XTS == l_cryptoinstance->fct) {
  14d8b0:	7a20      	ldrb	r0, [r4, #8]
            addr_key = key_int_addr_table[(l_cryptoinstance->aes_key_len - 16) >> 3][0];
  14d8b2:	f640 61e4 	movw	r1, #3812	; 0xee4
            if (SD_FCT_XTS == l_cryptoinstance->fct) {
  14d8b6:	2807      	cmp	r0, #7
            addr_key = key_int_addr_table[(l_cryptoinstance->aes_key_len - 16) >> 3][0];
  14d8b8:	f1a3 0310 	sub.w	r3, r3, #16
  14d8bc:	f2c0 0116 	movt	r1, #22
  14d8c0:	ea4f 03d3 	mov.w	r3, r3, lsr #3
  14d8c4:	f811 5013 	ldrb.w	r5, [r1, r3, lsl #1]
            if (SD_FCT_XTS == l_cryptoinstance->fct) {
  14d8c8:	d1c5      	bne.n	14d856 <hal_aes_init+0x96>
                addr_xkey = key_int_addr_table[(l_cryptoinstance->aes_key_len - 16) >> 3][1];
  14d8ca:	eb01 0343 	add.w	r3, r1, r3, lsl #1
  14d8ce:	785f      	ldrb	r7, [r3, #1]
  14d8d0:	e7c2      	b.n	14d858 <hal_aes_init+0x98>
        ret = CRYPTO_ERROR;
  14d8d2:	2000      	movs	r0, #0
  14d8d4:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14d8d8:	b01c      	add	sp, #112	; 0x70
  14d8da:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
                    l_cryptoinstance->aes_iv_len = 0;
  14d8de:	7403      	strb	r3, [r0, #16]
  14d8e0:	e797      	b.n	14d812 <hal_aes_init+0x52>
  14d8e2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
                ret = memcpy_blk(l_cryptoinstance->vce_id,
  14d8e4:	ab16      	add	r3, sp, #88	; 0x58
  14d8e6:	9219      	str	r2, [sp, #100]	; 0x64
  14d8e8:	aa1c      	add	r2, sp, #112	; 0x70
  14d8ea:	e9cd 681a 	strd	r6, r8, [r13, #104]	; 0x68
  14d8ee:	2730      	movs	r7, #48	; 0x30
  14d8f0:	f8d4 c000 	ldr.w	r12, [r4]
  14d8f4:	f894 e00a 	ldrb.w	r14, [r4, #10]
  14d8f8:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  14d8fc:	9617      	str	r6, [sp, #92]	; 0x5c
  14d8fe:	e88d 0007 	stmia.w	r13, {r0, r1, r2}
  14d902:	f8cd e060 	str.w	r14, [r13, #96]	; 0x60
  14d906:	4660      	mov	r0, r12
  14d908:	9603      	str	r6, [sp, #12]
  14d90a:	9716      	str	r7, [sp, #88]	; 0x58
  14d90c:	cb0e      	ldmia	r3, {r1, r2, r3}
  14d90e:	f7f7 fad3 	bl	144eb8 <memcpy_blk>
                if (ret) {
  14d912:	2800      	cmp	r0, #0
  14d914:	d0a0      	beq.n	14d858 <hal_aes_init+0x98>
  14d916:	e7a5      	b.n	14d864 <hal_aes_init+0xa4>

0014d918 <hal_aes_final>:
    crypto_instance_t* l_cryptoinstance = NULL;
    bool head_save = false;

    LTRACEF("enter head_len= %d\n", head_len);

    if (handle == NULL) {
  14d918:	2800      	cmp	r0, #0
  14d91a:	d06d      	beq.n	14d9f8 <hal_aes_final+0xe0>
{
  14d91c:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}

        vce_id = l_cryptoinstance->vce_id;

        //head_save = SD_FCT_GCM == l_cryptoinstance->fct ? true : false;

        if (l_cryptoinstance->aes_method->cipher) {
  14d920:	6fc4      	ldr	r4, [r0, #124]	; 0x7c
{
  14d922:	b0a8      	sub	sp, #160	; 0xa0
        vce_id = l_cryptoinstance->vce_id;
  14d924:	f8d0 c000 	ldr.w	r12, [r0]
        if (l_cryptoinstance->aes_method->cipher) {
  14d928:	6826      	ldr	r6, [r4, #0]
  14d92a:	2e00      	cmp	r6, #0
  14d92c:	d068      	beq.n	14da00 <hal_aes_final+0xe8>
            ret = l_cryptoinstance->aes_method->cipher(l_cryptoinstance->fct, vce_id, l_cryptoinstance->operation_type,
  14d92e:	f890 a008 	ldrb.w	r10, [r0, #8]
  14d932:	69c4      	ldr	r4, [r0, #28]
  14d934:	9417      	str	r4, [sp, #92]	; 0x5c
  14d936:	f1ba 0f07 	cmp.w	r10, #7
  14d93a:	7a85      	ldrb	r5, [r0, #10]
  14d93c:	6947      	ldr	r7, [r0, #20]
  14d93e:	bf0a      	itet	eq
  14d940:	e9cd 451a 	strdeq	r4, r5, [r13, #104]	; 0x68
  14d944:	2400      	movne	r4, #0
  14d946:	6984      	ldreq	r4, [r0, #24]
  14d948:	f890 e009 	ldrb.w	r14, [r0, #9]
  14d94c:	bf0e      	itee	eq
  14d94e:	9419      	streq	r4, [sp, #100]	; 0x64
  14d950:	e9cd 4419 	strdne	r4, r4, [r13, #100]	; 0x64
  14d954:	941b      	strne	r4, [sp, #108]	; 0x6c
  14d956:	7c04      	ldrb	r4, [r0, #16]
  14d958:	9716      	str	r7, [sp, #88]	; 0x58
  14d95a:	9518      	str	r5, [sp, #96]	; 0x60
  14d95c:	2c00      	cmp	r4, #0
  14d95e:	d144      	bne.n	14d9ea <hal_aes_final+0xd2>
  14d960:	e9cd 441c 	strd	r4, r4, [r13, #112]	; 0x70
  14d964:	941e      	str	r4, [sp, #120]	; 0x78
  14d966:	2003      	movs	r0, #3
  14d968:	461d      	mov	r5, r3
  14d96a:	9c30      	ldr	r4, [sp, #192]	; 0xc0
  14d96c:	ab22      	add	r3, sp, #136	; 0x88
  14d96e:	e9cd 2023 	strd	r2, r0, [r13, #140]	; 0x8c
  14d972:	aa28      	add	r2, sp, #160	; 0xa0
  14d974:	9f31      	ldr	r7, [sp, #196]	; 0xc4
  14d976:	f10d 097c 	add.w	r9, r13, #124	; 0x7c
  14d97a:	9425      	str	r4, [sp, #148]	; 0x94
  14d97c:	ac12      	add	r4, sp, #72	; 0x48
  14d97e:	9122      	str	r1, [sp, #136]	; 0x88
  14d980:	f10d 083c 	add.w	r8, r13, #60	; 0x3c
  14d984:	9726      	str	r7, [sp, #152]	; 0x98
  14d986:	9027      	str	r0, [sp, #156]	; 0x9c
  14d988:	e912 0007 	ldmdb	r2, {r0, r1, r2}
  14d98c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  14d990:	2400      	movs	r4, #0
  14d992:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  14d996:	ab1c      	add	r3, sp, #112	; 0x70
  14d998:	e888 0007 	stmia.w	r8, {r0, r1, r2}
  14d99c:	941f      	str	r4, [sp, #124]	; 0x7c
  14d99e:	f10d 0830 	add.w	r8, r13, #48	; 0x30
  14d9a2:	e9cd 4420 	strd	r4, r4, [r13, #128]	; 0x80
  14d9a6:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
  14d9aa:	f10d 0964 	add.w	r9, r13, #100	; 0x64
  14d9ae:	e888 0007 	stmia.w	r8, {r0, r1, r2}
  14d9b2:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  14d9b6:	ab09      	add	r3, sp, #36	; 0x24
  14d9b8:	f10d 0858 	add.w	r8, r13, #88	; 0x58
  14d9bc:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14d9c0:	ab06      	add	r3, sp, #24
  14d9c2:	e899 0007 	ldmia.w	r9, {r0, r1, r2}
  14d9c6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14d9ca:	ab03      	add	r3, sp, #12
  14d9cc:	e898 0007 	ldmia.w	r8, {r0, r1, r2}
  14d9d0:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  14d9d4:	4623      	mov	r3, r4
  14d9d6:	4672      	mov	r2, r14
  14d9d8:	9402      	str	r4, [sp, #8]
  14d9da:	4661      	mov	r1, r12
  14d9dc:	9401      	str	r4, [sp, #4]
  14d9de:	4650      	mov	r0, r10
  14d9e0:	9500      	str	r5, [sp, #0]
  14d9e2:	47b0      	blx	r6
            ret = CRYPTO_INVALID_CE;
        }
    }

    return ret;
}
  14d9e4:	b028      	add	sp, #160	; 0xa0
  14d9e6:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  14d9ea:	2510      	movs	r5, #16
  14d9ec:	2401      	movs	r4, #1
  14d9ee:	68c0      	ldr	r0, [r0, #12]
  14d9f0:	e9cd 051c 	strd	r0, r5, [r13, #112]	; 0x70
  14d9f4:	941e      	str	r4, [sp, #120]	; 0x78
  14d9f6:	e7b6      	b.n	14d966 <hal_aes_final+0x4e>
        ret = CRYPTO_ERROR;
  14d9f8:	2000      	movs	r0, #0
  14d9fa:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14d9fe:	4770      	bx	r14
            ret = CRYPTO_INVALID_CE;
  14da00:	2010      	movs	r0, #16
  14da02:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  14da06:	b028      	add	sp, #160	; 0xa0
  14da08:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}

0014da0c <hal_firewall_creat_handle>:
//!
//! @return hal_status_t
//
//*****************************************************************************
hal_status_t hal_firewall_creat_handle(void** handle, uint32_t firewall_idx)
{
  14da0c:	b508      	push	{r3, r14}
    if (g_firewallinstance.is_created == 0) {
  14da0e:	f245 3358 	movw	r3, #21336	; 0x5358
  14da12:	f2c0 0316 	movt	r3, #22
  14da16:	781a      	ldrb	r2, [r3, #0]
  14da18:	b13a      	cbz	r2, 14da2a <hal_firewall_creat_handle+0x1e>
        if (g_firewallinstance.in_used == 0) {
  14da1a:	785a      	ldrb	r2, [r3, #1]
  14da1c:	b94a      	cbnz	r2, 14da32 <hal_firewall_creat_handle+0x26>
            g_firewallinstance.in_used = 1;
  14da1e:	2201      	movs	r2, #1
  14da20:	705a      	strb	r2, [r3, #1]

    if (firewallinstance == NULL) {
        return HAL_ERROR;
    }

    *handle = firewallinstance;
  14da22:	6003      	str	r3, [r0, #0]
    return HAL_OK;
  14da24:	2200      	movs	r2, #0
}
  14da26:	4610      	mov	r0, r2
  14da28:	bd08      	pop	{r3, r15}
        g_firewallinstance.is_created = 1;
  14da2a:	f240 1201 	movw	r2, #257	; 0x101
  14da2e:	801a      	strh	r2, [r3, #0]
  14da30:	e7f7      	b.n	14da22 <hal_firewall_creat_handle+0x16>
    LTRACEF("return NULL\n");
  14da32:	f646 61e4 	movw	r1, #28388	; 0x6ee4
  14da36:	f646 7000 	movw	r0, #28416	; 0x6f00
  14da3a:	222e      	movs	r2, #46	; 0x2e
  14da3c:	f2c0 0115 	movt	r1, #21
  14da40:	f2c0 0015 	movt	r0, #21
  14da44:	f006 fb58 	bl	1540f8 <_printf>
        return HAL_ERROR;
  14da48:	2201      	movs	r2, #1
  14da4a:	e7ec      	b.n	14da26 <hal_firewall_creat_handle+0x1a>

0014da4c <hal_firewall_delete_handle>:
{
    hal_status_t ret = HAL_OK;

    firewall_instance_t* l_firewallinstance = NULL;

    if (handle == NULL) {
  14da4c:	4603      	mov	r3, r0
  14da4e:	b118      	cbz	r0, 14da58 <hal_firewall_delete_handle+0xc>
        ret = HAL_ERROR;
    }
    else {
        l_firewallinstance = (firewall_instance_t*)handle;
        l_firewallinstance->in_used = 0;
  14da50:	2200      	movs	r2, #0
    hal_status_t ret = HAL_OK;
  14da52:	4610      	mov	r0, r2
        l_firewallinstance->in_used = 0;
  14da54:	705a      	strb	r2, [r3, #1]
  14da56:	4770      	bx	r14
        ret = HAL_ERROR;
  14da58:	2001      	movs	r0, #1
    }

    return ret;
}
  14da5a:	4770      	bx	r14

0014da5c <hal_firewall_init>:
{
    hal_status_t ret = HAL_OK;

    firewall_instance_t* l_firewallinstance = NULL;

    if (handle == NULL) {
  14da5c:	b150      	cbz	r0, 14da74 <hal_firewall_init+0x18>
{
  14da5e:	b470      	push	{r4, r5, r6}
  14da60:	4604      	mov	r4, r0
        ret = HAL_ERROR;
    }
    else {
        l_firewallinstance = (firewall_instance_t*)handle;
        l_firewallinstance->is_init = 1;
  14da62:	2601      	movs	r6, #1
  14da64:	460d      	mov	r5, r1
  14da66:	4611      	mov	r1, r2

        ret = firewall_init(cfg_count, firewall_cfg, cfg_debug);
  14da68:	4628      	mov	r0, r5
  14da6a:	461a      	mov	r2, r3
        l_firewallinstance->is_init = 1;
  14da6c:	70a6      	strb	r6, [r4, #2]
    }

    return ret;
}
  14da6e:	bc70      	pop	{r4, r5, r6}
        ret = firewall_init(cfg_count, firewall_cfg, cfg_debug);
  14da70:	f7fa baa2 	b.w	147fb8 <firewall_init>
}
  14da74:	2001      	movs	r0, #1
  14da76:	4770      	bx	r14

0014da78 <hal_firewall_enable>:
//*****************************************************************************
hal_status_t hal_firewall_enable(void* handle, bool fw_enable)
{
    hal_status_t ret = HAL_OK;

    if (handle == NULL) {
  14da78:	b128      	cbz	r0, 14da86 <hal_firewall_enable+0xe>
  14da7a:	4608      	mov	r0, r1
{
  14da7c:	b508      	push	{r3, r14}
        ret = HAL_ERROR;
    }
    else {
        firewall_enable(fw_enable);
  14da7e:	f7fa fac5 	bl	14800c <firewall_enable>
    hal_status_t ret = HAL_OK;
  14da82:	2000      	movs	r0, #0
    }

    return ret;
}
  14da84:	bd08      	pop	{r3, r15}
        ret = HAL_ERROR;
  14da86:	2001      	movs	r0, #1
}
  14da88:	4770      	bx	r14
  14da8a:	bf00      	nop

0014da8c <hal_rid_init>:
{
    hal_status_t ret = HAL_OK;

    firewall_instance_t* l_firewallinstance = NULL;

    if (handle == NULL) {
  14da8c:	b148      	cbz	r0, 14daa2 <hal_rid_init+0x16>
{
  14da8e:	b430      	push	{r4, r5}
  14da90:	4603      	mov	r3, r0
        ret = HAL_ERROR;
    }
    else {
        l_firewallinstance = (firewall_instance_t*)handle;
        l_firewallinstance->is_init = 1;
  14da92:	2501      	movs	r5, #1
  14da94:	460c      	mov	r4, r1

        ret = rid_init(cfg_count, rid_cfg);
  14da96:	4611      	mov	r1, r2
        l_firewallinstance->is_init = 1;
  14da98:	709d      	strb	r5, [r3, #2]
        ret = rid_init(cfg_count, rid_cfg);
  14da9a:	4620      	mov	r0, r4
    }

    return ret;
}
  14da9c:	bc30      	pop	{r4, r5}
        ret = rid_init(cfg_count, rid_cfg);
  14da9e:	f7fa bacb 	b.w	148038 <rid_init>
}
  14daa2:	2001      	movs	r0, #1
  14daa4:	4770      	bx	r14
  14daa6:	bf00      	nop

0014daa8 <hal_arm_gic_create_handle>:


bool hal_arm_gic_create_handle(void **phandle, uint32_t res_glb_idx)
{
    return true;
}
  14daa8:	2001      	movs	r0, #1
  14daaa:	4770      	bx	r14

0014daac <hal_arm_gic_release_handle>:

bool hal_arm_gic_release_handle(void *handle)
{
    return true;
}
  14daac:	2001      	movs	r0, #1
  14daae:	4770      	bx	r14

0014dab0 <hal_arm_gic_init>:

bool hal_arm_gic_init(void *handle)
{
  14dab0:	b510      	push	{r4, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14dab2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14dab6:	061b      	lsls	r3, r3, #24
  14dab8:	d40d      	bmi.n	14dad6 <hal_arm_gic_init+0x26>
    __asm__ volatile("cpsid i");
  14daba:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    static bool initialized = false;

    spin_lock_irqsave(&init_lock,state);

    if(false == initialized)
  14dabc:	f245 345c 	movw	r4, #21340	; 0x535c
  14dac0:	f2c0 0416 	movt	r4, #22
  14dac4:	7823      	ldrb	r3, [r4, #0]
  14dac6:	b91b      	cbnz	r3, 14dad0 <hal_arm_gic_init+0x20>
    {
        arm_gic_init();
  14dac8:	f7fa fbf2 	bl	1482b0 <arm_gic_init>
        initialized = true;
  14dacc:	2301      	movs	r3, #1
  14dace:	7023      	strb	r3, [r4, #0]
    __asm__ volatile("cpsie i");
  14dad0:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&init_lock,state);

    return true;
}
  14dad2:	2001      	movs	r0, #1
  14dad4:	bd10      	pop	{r4, r15}
    if(false == initialized)
  14dad6:	f245 345c 	movw	r4, #21340	; 0x535c
  14dada:	f2c0 0416 	movt	r4, #22
  14dade:	7823      	ldrb	r3, [r4, #0]
  14dae0:	2b00      	cmp	r3, #0
  14dae2:	d1f6      	bne.n	14dad2 <hal_arm_gic_init+0x22>
        arm_gic_init();
  14dae4:	f7fa fbe4 	bl	1482b0 <arm_gic_init>
        initialized = true;
  14dae8:	2301      	movs	r3, #1
  14daea:	7023      	strb	r3, [r4, #0]
    return true;
  14daec:	e7f1      	b.n	14dad2 <hal_arm_gic_init+0x22>
  14daee:	bf00      	nop

0014daf0 <hal_arm_gic_enable_interrupt>:
    arm_gic_igroup_init();
    return true;
}

bool hal_arm_gic_enable_interrupt(void *handle, uint32_t irq_number)
{
  14daf0:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_unmask_interrupt(irq_number) == 0 ? true : false );
  14daf2:	4608      	mov	r0, r1
  14daf4:	f7fa fc8e 	bl	148414 <arm_gic_unmask_interrupt>

    return ret;

}
  14daf8:	fab0 f080 	clz	r0, r0
  14dafc:	0940      	lsrs	r0, r0, #5
  14dafe:	bd08      	pop	{r3, r15}

0014db00 <hal_arm_gic_disable_interrupt>:

bool hal_arm_gic_disable_interrupt(void *handle, uint32_t irq_number)
{
  14db00:	b508      	push	{r3, r14}
    bool ret = false;

    ret = (arm_gic_mask_interrupt(irq_number) == 0 ? true : false );
  14db02:	4608      	mov	r0, r1
  14db04:	f7fa fc66 	bl	1483d4 <arm_gic_mask_interrupt>

    return ret;
}
  14db08:	fab0 f080 	clz	r0, r0
  14db0c:	0940      	lsrs	r0, r0, #5
  14db0e:	bd08      	pop	{r3, r15}

0014db10 <hal_arm_gic_register_interrupt>:
bool hal_arm_gic_register_interrupt(void *handle,
    uint32_t irq_number,
    uint8_t priority,
    int_handler irq_handler,
    void* arg)
{
  14db10:	b538      	push	{r3, r4, r5, r14}
  14db12:	460c      	mov	r4, r1
  14db14:	4615      	mov	r5, r2
    arm_gic_register_int_handler(irq_number, irq_handler, arg);
  14db16:	4619      	mov	r1, r3
  14db18:	4620      	mov	r0, r4
  14db1a:	9a04      	ldr	r2, [sp, #16]
  14db1c:	f7fa fb9c 	bl	148258 <arm_gic_register_int_handler>
    arm_gic_set_priority(irq_number, priority);
  14db20:	4629      	mov	r1, r5
  14db22:	4620      	mov	r0, r4
  14db24:	f7fa fc32 	bl	14838c <arm_gic_set_priority>

    return true;
}
  14db28:	2001      	movs	r0, #1
  14db2a:	bd38      	pop	{r3, r4, r5, r15}

0014db2c <__received_data>:

    return;
}

static void __irq__ __received_data(u32 rproc, u32 receiver, void *data, u16 len)
{
  14db2c:	b5f0      	push	{r4, r5, r6, r7, r14}
    return g_hal_mbox && g_hal_mbox->mbox_inited;
  14db2e:	f245 3460 	movw	r4, #21344	; 0x5360
{
  14db32:	b083      	sub	sp, #12
    return g_hal_mbox && g_hal_mbox->mbox_inited;
  14db34:	f2c0 0416 	movt	r4, #22
  14db38:	f8d4 c000 	ldr.w	r12, [r4]
  14db3c:	f1bc 0f00 	cmp.w	r12, #0
  14db40:	d015      	beq.n	14db6e <__received_data+0x42>
  14db42:	f89c 401c 	ldrb.w	r4, [r12, #28]
  14db46:	b194      	cbz	r4, 14db6e <__received_data+0x42>

    if (!IS_HAL_READY())
        return;

    /* vdsp use rmh1 & rmh2 only */
    if (rproc == IPCC_RRPOC_VDSP) {
  14db48:	2805      	cmp	r0, #5
  14db4a:	bf1e      	ittt	ne
  14db4c:	4664      	movne	r4, r12
        cl = find_used_client_inisr(rproc);
        msg = NULL;
    }
    else {
        cl = get_client_by_addr((u8)receiver);
  14db4e:	fa5f fe81 	uxtbne.w	r14, r1
    for (idx = 0;idx < MB_MAX_CL_NUM; idx++) {
  14db52:	2500      	movne	r5, #0
    if (rproc == IPCC_RRPOC_VDSP) {
  14db54:	d00d      	beq.n	14db72 <__received_data+0x46>
        if (cl->is_used && (addr == cl->this_addr))
  14db56:	f894 607c 	ldrb.w	r6, [r4, #124]	; 0x7c
  14db5a:	b11e      	cbz	r6, 14db64 <__received_data+0x38>
  14db5c:	f894 707e 	ldrb.w	r7, [r4, #126]	; 0x7e
  14db60:	4577      	cmp	r7, r14
  14db62:	d016      	beq.n	14db92 <__received_data+0x66>
    for (idx = 0;idx < MB_MAX_CL_NUM; idx++) {
  14db64:	3501      	adds	r5, #1
  14db66:	2d10      	cmp	r5, #16
  14db68:	f104 0440 	add.w	r4, r4, #64	; 0x40
  14db6c:	d1f3      	bne.n	14db56 <__received_data+0x2a>
            cl->rx_new_data(cl, msg, 8);
        } else {
            cl->rx_new_data(cl, msg->data, msg->dat_len - sizeof(sd_msghdr_t));
        }
    }
}
  14db6e:	b003      	add	sp, #12
  14db70:	bdf0      	pop	{r4, r5, r6, r7, r15}
  14db72:	4664      	mov	r4, r12
    for (idx = 0;idx < MB_MAX_CL_NUM; idx++) {
  14db74:	2600      	movs	r6, #0
        if (cl->is_used && (rproc == cl->mchan.remote_proc))
  14db76:	f894 707c 	ldrb.w	r7, [r4, #124]	; 0x7c
  14db7a:	b11f      	cbz	r7, 14db84 <__received_data+0x58>
  14db7c:	f894 5060 	ldrb.w	r5, [r4, #96]	; 0x60
  14db80:	2d05      	cmp	r5, #5
  14db82:	d033      	beq.n	14dbec <__received_data+0xc0>
    for (idx = 0;idx < MB_MAX_CL_NUM; idx++) {
  14db84:	3601      	adds	r6, #1
  14db86:	2e10      	cmp	r6, #16
  14db88:	f104 0440 	add.w	r4, r4, #64	; 0x40
  14db8c:	d1f3      	bne.n	14db76 <__received_data+0x4a>
}
  14db8e:	b003      	add	sp, #12
  14db90:	bdf0      	pop	{r4, r5, r6, r7, r15}
        msg = (sd_msghdr_t *)data;
  14db92:	4617      	mov	r7, r2
        cl = &g_hal_mbox->cl[idx];
  14db94:	eb0c 1585 	add.w	r5, r12, r5, lsl #6
  14db98:	354c      	adds	r5, #76	; 0x4c
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14db9a:	2d00      	cmp	r5, #0
  14db9c:	d0e7      	beq.n	14db6e <__received_data+0x42>
  14db9e:	682e      	ldr	r6, [r5, #0]
  14dba0:	f645 1426 	movw	r4, #22822	; 0x5926
  14dba4:	f2c3 1441 	movt	r4, #12609	; 0x3141
  14dba8:	42a6      	cmp	r6, r4
  14dbaa:	d1e0      	bne.n	14db6e <__received_data+0x42>
  14dbac:	4604      	mov	r4, r0
    if (len < sizeof(sd_msghdr_t)) {
  14dbae:	2b03      	cmp	r3, #3
  14dbb0:	d913      	bls.n	14dbda <__received_data+0xae>
    if (cl->rx_new_data) {
  14dbb2:	6bab      	ldr	r3, [r5, #56]	; 0x38
  14dbb4:	2b00      	cmp	r3, #0
  14dbb6:	d0da      	beq.n	14db6e <__received_data+0x42>
        if (rproc == IPCC_RRPOC_VDSP) {
  14dbb8:	2c05      	cmp	r4, #5
            cl->rx_new_data(cl, msg->data, msg->dat_len - sizeof(sd_msghdr_t));
  14dbba:	bf15      	itete	ne
  14dbbc:	887a      	ldrhne	r2, [r7, #2]
            cl->rx_new_data(cl, msg, 8);
  14dbbe:	4628      	moveq	r0, r5
            cl->rx_new_data(cl, msg->data, msg->dat_len - sizeof(sd_msghdr_t));
  14dbc0:	3a04      	subne	r2, #4
            msg[0] = receiver;
  14dbc2:	9100      	streq	r1, [sp, #0]
            cl->rx_new_data(cl, msg->data, msg->dat_len - sizeof(sd_msghdr_t));
  14dbc4:	bf11      	iteee	ne
  14dbc6:	4628      	movne	r0, r5
            msg[1] = (u32)(long)data;
  14dbc8:	9201      	streq	r2, [sp, #4]
            cl->rx_new_data(cl, msg, 8);
  14dbca:	4669      	moveq	r1, r13
  14dbcc:	2208      	moveq	r2, #8
            cl->rx_new_data(cl, msg->data, msg->dat_len - sizeof(sd_msghdr_t));
  14dbce:	bf1c      	itt	ne
  14dbd0:	1d39      	addne	r1, r7, #4
  14dbd2:	b292      	uxthne	r2, r2
  14dbd4:	4798      	blx	r3
}
  14dbd6:	b003      	add	sp, #12
  14dbd8:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "mbox: bad msg from rproc%d client:%d\n", rproc, receiver);
  14dbda:	f646 7028 	movw	r0, #28456	; 0x6f28
  14dbde:	460a      	mov	r2, r1
  14dbe0:	4621      	mov	r1, r4
  14dbe2:	f2c0 0015 	movt	r0, #21
  14dbe6:	f006 fa87 	bl	1540f8 <_printf>
        return;
  14dbea:	e7c0      	b.n	14db6e <__received_data+0x42>
        msg = NULL;
  14dbec:	2700      	movs	r7, #0
        cl = &g_hal_mbox->cl[idx];
  14dbee:	eb0c 1586 	add.w	r5, r12, r6, lsl #6
  14dbf2:	354c      	adds	r5, #76	; 0x4c
  14dbf4:	e7d1      	b.n	14db9a <__received_data+0x6e>
  14dbf6:	bf00      	nop

0014dbf8 <mb_irq_handler>:
{
    int ret;
    hal_mb_instance_t *mbox = arg;

    // disable irq c'z msg must be handled before clear TACK
    ret = sd_mbox_rx_interrupt(mbox->mb_irq, __received_data);
  14dbf8:	6a00      	ldr	r0, [r0, #32]
  14dbfa:	f64d 312d 	movw	r1, #56109	; 0xdb2d
  14dbfe:	f2c0 0114 	movt	r1, #20
  14dc02:	f7fa be77 	b.w	1488f4 <sd_mbox_rx_interrupt>
  14dc06:	bf00      	nop

0014dc08 <__free_used_buf>:
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14dc08:	f3ef 8300 	mrs	r3, CPSR
  14dc0c:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14dc10:	d10a      	bne.n	14dc28 <__free_used_buf+0x20>
    __asm__ volatile("cpsid i");
  14dc12:	b672      	cpsid	i
    if (chan->msg_count)
  14dc14:	6942      	ldr	r2, [r0, #20]
    *lock = 1;
  14dc16:	2101      	movs	r1, #1
  14dc18:	6241      	str	r1, [r0, #36]	; 0x24
  14dc1a:	b18a      	cbz	r2, 14dc40 <__free_used_buf+0x38>
    *lock = 0;
  14dc1c:	6243      	str	r3, [r0, #36]	; 0x24
        chan->msg_count--;
  14dc1e:	3a01      	subs	r2, #1
  14dc20:	6142      	str	r2, [r0, #20]
    __asm__ volatile("cpsie i");
  14dc22:	b662      	cpsie	i
}
  14dc24:	2000      	movs	r0, #0
  14dc26:	4770      	bx	r14
    if (chan->msg_count)
  14dc28:	6943      	ldr	r3, [r0, #20]
    *lock = 1;
  14dc2a:	2201      	movs	r2, #1
  14dc2c:	6242      	str	r2, [r0, #36]	; 0x24
  14dc2e:	b913      	cbnz	r3, 14dc36 <__free_used_buf+0x2e>
    *lock = 0;
  14dc30:	6243      	str	r3, [r0, #36]	; 0x24
}
  14dc32:	2000      	movs	r0, #0
  14dc34:	4770      	bx	r14
  14dc36:	2200      	movs	r2, #0
        chan->msg_count--;
  14dc38:	3b01      	subs	r3, #1
  14dc3a:	6242      	str	r2, [r0, #36]	; 0x24
  14dc3c:	6143      	str	r3, [r0, #20]
    return 0;
  14dc3e:	e7f1      	b.n	14dc24 <__free_used_buf+0x1c>
  14dc40:	6242      	str	r2, [r0, #36]	; 0x24
  14dc42:	e7ee      	b.n	14dc22 <__free_used_buf+0x1a>

0014dc44 <__alloc_avail_buf>:
{
  14dc44:	4603      	mov	r3, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14dc46:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14dc4a:	f012 0180 	ands.w	r1, r2, #128	; 0x80
  14dc4e:	d114      	bne.n	14dc7a <__alloc_avail_buf+0x36>
    __asm__ volatile("cpsid i");
  14dc50:	b672      	cpsid	i
    if (chan->msg_count == MBOX_TX_QUEUE_LEN) {
  14dc52:	695a      	ldr	r2, [r3, #20]
    *lock = 1;
  14dc54:	2001      	movs	r0, #1
  14dc56:	6258      	str	r0, [r3, #36]	; 0x24
  14dc58:	2a02      	cmp	r2, #2
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14dc5a:	bf18      	it	ne
  14dc5c:	4601      	movne	r1, r0
  14dc5e:	d018      	beq.n	14dc92 <__alloc_avail_buf+0x4e>
    idx = chan->msg_free;
  14dc60:	6998      	ldr	r0, [r3, #24]
    chan->msg_count++;
  14dc62:	3201      	adds	r2, #1
  14dc64:	615a      	str	r2, [r3, #20]
    if (idx == MBOX_TX_QUEUE_LEN - 1)
  14dc66:	2801      	cmp	r0, #1
        chan->msg_free = 0;
  14dc68:	bf0c      	ite	eq
  14dc6a:	2200      	moveq	r2, #0
        chan->msg_free++;
  14dc6c:	1c42      	addne	r2, r0, #1
  14dc6e:	619a      	str	r2, [r3, #24]
    *lock = 0;
  14dc70:	2200      	movs	r2, #0
  14dc72:	625a      	str	r2, [r3, #36]	; 0x24
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14dc74:	b101      	cbz	r1, 14dc78 <__alloc_avail_buf+0x34>
    __asm__ volatile("cpsie i");
  14dc76:	b662      	cpsie	i
}
  14dc78:	4770      	bx	r14
    if (chan->msg_count == MBOX_TX_QUEUE_LEN) {
  14dc7a:	6942      	ldr	r2, [r0, #20]
    *lock = 1;
  14dc7c:	2101      	movs	r1, #1
  14dc7e:	6241      	str	r1, [r0, #36]	; 0x24
  14dc80:	2a02      	cmp	r2, #2
    spin_lock_saved_state_t state = 0;
  14dc82:	bf18      	it	ne
  14dc84:	2100      	movne	r1, #0
  14dc86:	d1eb      	bne.n	14dc60 <__alloc_avail_buf+0x1c>
    *lock = 0;
  14dc88:	2200      	movs	r2, #0
        return -1;
  14dc8a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  14dc8e:	625a      	str	r2, [r3, #36]	; 0x24
  14dc90:	4770      	bx	r14
  14dc92:	6259      	str	r1, [r3, #36]	; 0x24
  14dc94:	b662      	cpsie	i
  14dc96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  14dc9a:	4770      	bx	r14

0014dc9c <hal_mb_set_user>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14dc9c:	4603      	mov	r3, r0
  14dc9e:	b130      	cbz	r0, 14dcae <hal_mb_set_user+0x12>
  14dca0:	6800      	ldr	r0, [r0, #0]
  14dca2:	f645 1226 	movw	r2, #22822	; 0x5926
  14dca6:	f2c3 1241 	movt	r2, #12609	; 0x3141
  14dcaa:	4290      	cmp	r0, r2
  14dcac:	d002      	beq.n	14dcb4 <hal_mb_set_user+0x18>
        return -1;
  14dcae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  14dcb2:	4770      	bx	r14
    cl->user_data = data;
  14dcb4:	6359      	str	r1, [r3, #52]	; 0x34
    return 0;
  14dcb6:	2000      	movs	r0, #0
}
  14dcb8:	4770      	bx	r14
  14dcba:	bf00      	nop

0014dcbc <hal_mb_get_user>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14dcbc:	b148      	cbz	r0, 14dcd2 <hal_mb_get_user+0x16>
  14dcbe:	6802      	ldr	r2, [r0, #0]
  14dcc0:	f645 1326 	movw	r3, #22822	; 0x5926
  14dcc4:	f2c3 1341 	movt	r3, #12609	; 0x3141
  14dcc8:	429a      	cmp	r2, r3
  14dcca:	d001      	beq.n	14dcd0 <hal_mb_get_user+0x14>
        return NULL;
  14dccc:	2000      	movs	r0, #0
  14dcce:	4770      	bx	r14
    return cl->user_data;
  14dcd0:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
  14dcd2:	4770      	bx	r14

0014dcd4 <hal_mb_get_client_with_addr>:
{
  14dcd4:	b570      	push	{r4, r5, r6, r14}
    return g_hal_mbox && g_hal_mbox->mbox_inited;
  14dcd6:	f245 3660 	movw	r6, #21344	; 0x5360
  14dcda:	f2c0 0616 	movt	r6, #22
  14dcde:	6833      	ldr	r3, [r6, #0]
        return ret;
  14dce0:	461c      	mov	r4, r3
    return g_hal_mbox && g_hal_mbox->mbox_inited;
  14dce2:	2b00      	cmp	r3, #0
  14dce4:	d039      	beq.n	14dd5a <hal_mb_get_client_with_addr+0x86>
  14dce6:	7f1c      	ldrb	r4, [r3, #28]
  14dce8:	b3bc      	cbz	r4, 14dd5a <hal_mb_get_client_with_addr+0x86>
  14dcea:	4605      	mov	r5, r0
    if (!g_hal_mbox->cl_num) {
  14dcec:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
  14dcf0:	2c00      	cmp	r4, #0
  14dcf2:	d042      	beq.n	14dd7a <hal_mb_get_client_with_addr+0xa6>
  14dcf4:	4618      	mov	r0, r3
  14dcf6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14dcfa:	f001 fa67 	bl	14f1cc <mutex_acquire_timeout>
        cl = &g_hal_mbox->cl[i];
  14dcfe:	6830      	ldr	r0, [r6, #0]
  14dd00:	4601      	mov	r1, r0
  14dd02:	4603      	mov	r3, r0
  14dd04:	f500 6480 	add.w	r4, r0, #1024	; 0x400
        if (cl->is_used && (myaddr == cl->this_addr)) {
  14dd08:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
  14dd0c:	b11a      	cbz	r2, 14dd16 <hal_mb_get_client_with_addr+0x42>
  14dd0e:	f893 207e 	ldrb.w	r2, [r3, #126]	; 0x7e
  14dd12:	42aa      	cmp	r2, r5
  14dd14:	d023      	beq.n	14dd5e <hal_mb_get_client_with_addr+0x8a>
  14dd16:	3340      	adds	r3, #64	; 0x40
    for (i = 0; i < MB_MAX_CL_NUM; i++) {
  14dd18:	429c      	cmp	r4, r3
  14dd1a:	d1f5      	bne.n	14dd08 <hal_mb_get_client_with_addr+0x34>
    for (i = 0; i < MB_MAX_CL_NUM; i++) {
  14dd1c:	2300      	movs	r3, #0
  14dd1e:	e002      	b.n	14dd26 <hal_mb_get_client_with_addr+0x52>
  14dd20:	3301      	adds	r3, #1
  14dd22:	2b10      	cmp	r3, #16
  14dd24:	d027      	beq.n	14dd76 <hal_mb_get_client_with_addr+0xa2>
        if (!cl->is_used) {
  14dd26:	f891 207c 	ldrb.w	r2, [r1, #124]	; 0x7c
  14dd2a:	3140      	adds	r1, #64	; 0x40
  14dd2c:	2a00      	cmp	r2, #0
  14dd2e:	d1f7      	bne.n	14dd20 <hal_mb_get_client_with_addr+0x4c>
            cl->magic = MBOX_HANDLE_MAGIC;
  14dd30:	f645 1126 	movw	r1, #22822	; 0x5926
        cl = &g_hal_mbox->cl[i];
  14dd34:	019b      	lsls	r3, r3, #6
            cl->is_used = true;
  14dd36:	18c2      	adds	r2, r0, r3
  14dd38:	2601      	movs	r6, #1
            cl->magic = MBOX_HANDLE_MAGIC;
  14dd3a:	f2c3 1141 	movt	r1, #12609	; 0x3141
            cl->this_addr = myaddr;
  14dd3e:	f882 507e 	strb.w	r5, [r2, #126]	; 0x7e
        cl = &g_hal_mbox->cl[i];
  14dd42:	334c      	adds	r3, #76	; 0x4c
            cl->is_used = true;
  14dd44:	f882 607c 	strb.w	r6, [r2, #124]	; 0x7c
        cl = &g_hal_mbox->cl[i];
  14dd48:	18c4      	adds	r4, r0, r3
            cl->magic = MBOX_HANDLE_MAGIC;
  14dd4a:	64d1      	str	r1, [r2, #76]	; 0x4c
            g_hal_mbox->cl_num--;
  14dd4c:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
  14dd50:	3b01      	subs	r3, #1
  14dd52:	f880 3048 	strb.w	r3, [r0, #72]	; 0x48
    return mutex_release(&g_hal_mbox->mbox_mutex);
  14dd56:	f001 fa65 	bl	14f224 <mutex_release>
}
  14dd5a:	4620      	mov	r0, r4
  14dd5c:	bd70      	pop	{r4, r5, r6, r15}
    return mutex_release(&g_hal_mbox->mbox_mutex);
  14dd5e:	f001 fa61 	bl	14f224 <mutex_release>
            dprintf(ALWAYS, "mbox: this addr %d already exist\n", myaddr);
  14dd62:	f247 000c 	movw	r0, #28684	; 0x700c
            return NULL;
  14dd66:	2400      	movs	r4, #0
            dprintf(ALWAYS, "mbox: this addr %d already exist\n", myaddr);
  14dd68:	4629      	mov	r1, r5
  14dd6a:	f2c0 0015 	movt	r0, #21
  14dd6e:	f006 f9c3 	bl	1540f8 <_printf>
}
  14dd72:	4620      	mov	r0, r4
  14dd74:	bd70      	pop	{r4, r5, r6, r15}
    hal_mb_client_t cl, ret = NULL;
  14dd76:	2400      	movs	r4, #0
  14dd78:	e7ed      	b.n	14dd56 <hal_mb_get_client_with_addr+0x82>
        dprintf(ALWAYS, "mbox: No client available %d\n", myaddr);
  14dd7a:	f646 70ec 	movw	r0, #28652	; 0x6fec
  14dd7e:	4629      	mov	r1, r5
  14dd80:	f2c0 0015 	movt	r0, #21
  14dd84:	f006 f9b8 	bl	1540f8 <_printf>
        return ret;
  14dd88:	e7e7      	b.n	14dd5a <hal_mb_get_client_with_addr+0x86>
  14dd8a:	bf00      	nop

0014dd8c <hal_mb_request_channel_with_addr>:
{
  14dd8c:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14dd90:	b130      	cbz	r0, 14dda0 <hal_mb_request_channel_with_addr+0x14>
  14dd92:	6805      	ldr	r5, [r0, #0]
  14dd94:	f645 1426 	movw	r4, #22822	; 0x5926
  14dd98:	f2c3 1441 	movt	r4, #12609	; 0x3141
  14dd9c:	42a5      	cmp	r5, r4
  14dd9e:	d003      	beq.n	14dda8 <hal_mb_request_channel_with_addr+0x1c>
        return NULL;
  14dda0:	2500      	movs	r5, #0
}
  14dda2:	4628      	mov	r0, r5
  14dda4:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
  14dda8:	4604      	mov	r4, r0
    msgq_base = malloc(MBOX_TX_BUF_SZ);
  14ddaa:	f44f 6080 	mov.w	r0, #1024	; 0x400
  14ddae:	461f      	mov	r7, r3
  14ddb0:	4690      	mov	r8, r2
  14ddb2:	460e      	mov	r6, r1
  14ddb4:	f005 f86c 	bl	152e90 <malloc>
    if (!msgq_base) {
  14ddb8:	4681      	mov	r9, r0
  14ddba:	b3a0      	cbz	r0, 14de26 <hal_mb_request_channel_with_addr+0x9a>
    cl->tx_complete = NULL;
  14ddbc:	2300      	movs	r3, #0
    cl->tx_block = true;
  14ddbe:	f04f 0c01 	mov.w	r12, #1
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14ddc2:	4619      	mov	r1, r3
  14ddc4:	1d25      	adds	r5, r4, #4
    cl->tx_complete = NULL;
  14ddc6:	63e3      	str	r3, [r4, #60]	; 0x3c
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14ddc8:	222c      	movs	r2, #44	; 0x2c
    cl->rx_new_data = cb;
  14ddca:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14ddce:	4628      	mov	r0, r5
    cl->low_latency = low_latency;
  14ddd0:	f884 6033 	strb.w	r6, [r4, #51]	; 0x33
    cl->tx_block = true;
  14ddd4:	f884 c031 	strb.w	r12, [r4, #49]	; 0x31
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14ddd8:	f005 e950 	blx	15307c <memset>
    cl->mchan.remote_proc = remote;
  14dddc:	b2f9      	uxtb	r1, r7
        cl->mchan.msg_data[i] = (u8 *)msgq_base + i * MBOX_TX_MTU;
  14ddde:	f509 7300 	add.w	r3, r9, #512	; 0x200
    cl->mchan.dest_addr = address;
  14dde2:	9a08      	ldr	r2, [sp, #32]
    if (cl->mchan.remote_proc > IPCC_RRPOC_MAX) {
  14dde4:	2905      	cmp	r1, #5
    cl->mchan.remote_proc = remote;
  14dde6:	7521      	strb	r1, [r4, #20]
        cl->mchan.msg_data[i] = (u8 *)msgq_base + i * MBOX_TX_MTU;
  14dde8:	f8c4 9020 	str.w	r9, [r4, #32]
    cl->mchan.dest_addr = address;
  14ddec:	7562      	strb	r2, [r4, #21]
        cl->mchan.msg_data[i] = (u8 *)msgq_base + i * MBOX_TX_MTU;
  14ddee:	6263      	str	r3, [r4, #36]	; 0x24
    if (cl->mchan.remote_proc > IPCC_RRPOC_MAX) {
  14ddf0:	d80e      	bhi.n	14de10 <hal_mb_request_channel_with_addr+0x84>
    cl->mchan.hwchan = sd_mbox_request_channel(remote, cl->this_addr);
  14ddf2:	4608      	mov	r0, r1
  14ddf4:	f894 1032 	ldrb.w	r1, [r4, #50]	; 0x32
  14ddf8:	f7fa fcd8 	bl	1487ac <sd_mbox_request_channel>
  14ddfc:	62e0      	str	r0, [r4, #44]	; 0x2c
    if (!cl->mchan.hwchan) {
  14ddfe:	2800      	cmp	r0, #0
  14de00:	d1cf      	bne.n	14dda2 <hal_mb_request_channel_with_addr+0x16>
        dprintf(0, "mbox: no more hwchan\n");
  14de02:	f247 0068 	movw	r0, #28776	; 0x7068
  14de06:	f2c0 0015 	movt	r0, #21
  14de0a:	f006 f975 	bl	1540f8 <_printf>
        goto request_fail_out;
  14de0e:	e005      	b.n	14de1c <hal_mb_request_channel_with_addr+0x90>
        dprintf(CRITICAL, "mbox: rproc%d out of range\n", cl->mchan.remote_proc);
  14de10:	f247 004c 	movw	r0, #28748	; 0x704c
  14de14:	f2c0 0015 	movt	r0, #21
  14de18:	f006 f96e 	bl	1540f8 <_printf>
        free(msgq_base);
  14de1c:	4648      	mov	r0, r9
    return NULL;
  14de1e:	2500      	movs	r5, #0
        free(msgq_base);
  14de20:	f005 f86c 	bl	152efc <free>
    return NULL;
  14de24:	e7bd      	b.n	14dda2 <hal_mb_request_channel_with_addr+0x16>
        dprintf(0, "mbox: no memory available\n");
  14de26:	f247 0030 	movw	r0, #28720	; 0x7030
        return NULL;
  14de2a:	464d      	mov	r5, r9
        dprintf(0, "mbox: no memory available\n");
  14de2c:	f2c0 0015 	movt	r0, #21
  14de30:	f006 f962 	bl	1540f8 <_printf>
        return NULL;
  14de34:	e7b5      	b.n	14dda2 <hal_mb_request_channel_with_addr+0x16>
  14de36:	bf00      	nop

0014de38 <hal_mb_free_channel>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14de38:	2804      	cmp	r0, #4
  14de3a:	d01e      	beq.n	14de7a <hal_mb_free_channel+0x42>
{
  14de3c:	b538      	push	{r3, r4, r5, r14}
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14de3e:	f850 2c04 	ldr.w	r2, [r0, #-4]
  14de42:	f645 1326 	movw	r3, #22822	; 0x5926
  14de46:	f2c3 1341 	movt	r3, #12609	; 0x3141
  14de4a:	429a      	cmp	r2, r3
    hal_mb_client_t cl = containerof(chan, struct _hal_mbox_client, mchan);
  14de4c:	f1a0 0504 	sub.w	r5, r0, #4
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14de50:	d000      	beq.n	14de54 <hal_mb_free_channel+0x1c>
}
  14de52:	bd38      	pop	{r3, r4, r5, r15}
    if (spin_lock_held(&chan->lock))
  14de54:	6a43      	ldr	r3, [r0, #36]	; 0x24
  14de56:	b10b      	cbz	r3, 14de5c <hal_mb_free_channel+0x24>
  14de58:	2300      	movs	r3, #0
  14de5a:	6243      	str	r3, [r0, #36]	; 0x24
  14de5c:	4604      	mov	r4, r0
    if (chan->hwchan) {
  14de5e:	6a80      	ldr	r0, [r0, #40]	; 0x28
  14de60:	b108      	cbz	r0, 14de66 <hal_mb_free_channel+0x2e>
        sd_mbox_free_channel(chan->hwchan);
  14de62:	f7fa fcd3 	bl	14880c <sd_mbox_free_channel>
    free(chan->msg_data[0]);
  14de66:	69e0      	ldr	r0, [r4, #28]
  14de68:	f005 f848 	bl	152efc <free>
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14de6c:	222c      	movs	r2, #44	; 0x2c
  14de6e:	2100      	movs	r1, #0
  14de70:	1d28      	adds	r0, r5, #4
}
  14de72:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    memset(&cl->mchan, 0, sizeof(cl->mchan));
  14de76:	f006 be1b 	b.w	154ab0 <__memset_from_thumb>
  14de7a:	4770      	bx	r14

0014de7c <hal_mb_put_client>:
{
  14de7c:	b538      	push	{r3, r4, r5, r14}
    return g_hal_mbox && g_hal_mbox->mbox_inited;
  14de7e:	f245 3460 	movw	r4, #21344	; 0x5360
  14de82:	f2c0 0416 	movt	r4, #22
  14de86:	6823      	ldr	r3, [r4, #0]
  14de88:	b133      	cbz	r3, 14de98 <hal_mb_put_client+0x1c>
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14de8a:	7f1a      	ldrb	r2, [r3, #28]
  14de8c:	2800      	cmp	r0, #0
  14de8e:	bf0c      	ite	eq
  14de90:	2200      	moveq	r2, #0
  14de92:	f002 0201 	andne.w	r2, r2, #1
  14de96:	b902      	cbnz	r2, 14de9a <hal_mb_put_client+0x1e>
}
  14de98:	bd38      	pop	{r3, r4, r5, r15}
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14de9a:	6801      	ldr	r1, [r0, #0]
  14de9c:	f645 1226 	movw	r2, #22822	; 0x5926
  14dea0:	f2c3 1241 	movt	r2, #12609	; 0x3141
  14dea4:	4291      	cmp	r1, r2
  14dea6:	d1f7      	bne.n	14de98 <hal_mb_put_client+0x1c>
  14dea8:	4605      	mov	r5, r0
  14deaa:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  14deae:	4618      	mov	r0, r3
  14deb0:	f001 f98c 	bl	14f1cc <mutex_acquire_timeout>
    g_hal_mbox->cl_num++;
  14deb4:	6822      	ldr	r2, [r4, #0]
  14deb6:	f892 3048 	ldrb.w	r3, [r2, #72]	; 0x48
  14deba:	3301      	adds	r3, #1
    hal_mb_free_channel(&cl->mchan);
  14debc:	1d28      	adds	r0, r5, #4
    g_hal_mbox->cl_num++;
  14debe:	f882 3048 	strb.w	r3, [r2, #72]	; 0x48
    hal_mb_free_channel(&cl->mchan);
  14dec2:	f7ff ffb9 	bl	14de38 <hal_mb_free_channel>
    return mutex_release(&g_hal_mbox->mbox_mutex);
  14dec6:	6820      	ldr	r0, [r4, #0]
    cl->is_used = false;
  14dec8:	2300      	movs	r3, #0
  14deca:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
    cl->magic = 0;
  14dece:	602b      	str	r3, [r5, #0]
    cl->this_addr = 0;
  14ded0:	f885 3032 	strb.w	r3, [r5, #50]	; 0x32
}
  14ded4:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return mutex_release(&g_hal_mbox->mbox_mutex);
  14ded8:	f001 b9a4 	b.w	14f224 <mutex_release>

0014dedc <hal_mb_cancel_lastsend>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14dedc:	2804      	cmp	r0, #4
  14dede:	d01e      	beq.n	14df1e <hal_mb_cancel_lastsend+0x42>
  14dee0:	f850 1c04 	ldr.w	r1, [r0, #-4]
    hal_mb_client_t cl = containerof(chan, struct _hal_mbox_client, mchan);
  14dee4:	1f02      	subs	r2, r0, #4
{
  14dee6:	b538      	push	{r3, r4, r5, r14}
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14dee8:	f645 1326 	movw	r3, #22822	; 0x5926
  14deec:	f2c3 1341 	movt	r3, #12609	; 0x3141
  14def0:	4299      	cmp	r1, r3
        return ERR_INVALID_ARGS;
  14def2:	bf18      	it	ne
  14def4:	f06f 0007 	mvnne.w	r0, #7
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14def8:	d000      	beq.n	14defc <hal_mb_cancel_lastsend+0x20>
}
  14defa:	bd38      	pop	{r3, r4, r5, r15}
    if (!cl->mchan.hwchan) {
  14defc:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
  14defe:	4604      	mov	r4, r0
  14df00:	b945      	cbnz	r5, 14df14 <hal_mb_cancel_lastsend+0x38>
  14df02:	e00f      	b.n	14df24 <hal_mb_cancel_lastsend+0x48>
        ret = sd_mbox_cancel_lastsend(chan->hwchan);
  14df04:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  14df06:	f7fa fc1d 	bl	148744 <sd_mbox_cancel_lastsend>
        if (!ret)
  14df0a:	2800      	cmp	r0, #0
  14df0c:	d1f5      	bne.n	14defa <hal_mb_cancel_lastsend+0x1e>
            __free_used_buf(chan);
  14df0e:	4620      	mov	r0, r4
  14df10:	f7ff fe7a 	bl	14dc08 <__free_used_buf>
    while (chan->msg_count) {
  14df14:	6963      	ldr	r3, [r4, #20]
  14df16:	2b00      	cmp	r3, #0
  14df18:	d1f4      	bne.n	14df04 <hal_mb_cancel_lastsend+0x28>
        return NO_ERROR;
  14df1a:	2000      	movs	r0, #0
}
  14df1c:	bd38      	pop	{r3, r4, r5, r15}
        return ERR_INVALID_ARGS;
  14df1e:	f06f 0007 	mvn.w	r0, #7
}
  14df22:	4770      	bx	r14
        printf("mbox: hwchan of %s not exist\n", chan->name);
  14df24:	f646 7088 	movw	r0, #28552	; 0x6f88
  14df28:	4621      	mov	r1, r4
  14df2a:	f2c0 0015 	movt	r0, #21
  14df2e:	f006 f8e3 	bl	1540f8 <_printf>
        return NO_ERROR;
  14df32:	4628      	mov	r0, r5
}
  14df34:	bd38      	pop	{r3, r4, r5, r15}
  14df36:	bf00      	nop

0014df38 <__send_data_sync>:
{
  14df38:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (!cl->mchan.hwchan) {
  14df3a:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
  14df3c:	4605      	mov	r5, r0
    if (!cl->mchan.hwchan) {
  14df3e:	2b00      	cmp	r3, #0
  14df40:	d051      	beq.n	14dfe6 <__send_data_sync+0xae>
  14df42:	4616      	mov	r6, r2
    if (!timeout) {
  14df44:	2a00      	cmp	r2, #0
  14df46:	d041      	beq.n	14dfcc <__send_data_sync+0x94>
  14df48:	460c      	mov	r4, r1
    end_time = current_time() + timeout;
  14df4a:	f7f2 fd09 	bl	140960 <current_time>
  14df4e:	4406      	add	r6, r0
        ret = sd_mbox_send_data(chan->hwchan, data);
  14df50:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  14df52:	4621      	mov	r1, r4
  14df54:	f7fa fb68 	bl	148628 <sd_mbox_send_data>
        if (ret < 0) {
  14df58:	1e07      	subs	r7, r0, #0
  14df5a:	db1c      	blt.n	14df96 <__send_data_sync+0x5e>
    u32 spin_usec = MB_TX_MAX_ACK_TIME;
  14df5c:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    while (!sd_mbox_last_tx_done(chan->hwchan)) {
  14df60:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  14df62:	f7fa fc0f 	bl	148784 <sd_mbox_last_tx_done>
  14df66:	b980      	cbnz	r0, 14df8a <__send_data_sync+0x52>
            spin(MB_TX_HRTMR_POLL);
  14df68:	2002      	movs	r0, #2
        if (spin_usec >= MB_TX_HRTMR_POLL) {
  14df6a:	2c01      	cmp	r4, #1
  14df6c:	d80f      	bhi.n	14df8e <__send_data_sync+0x56>
        if (TIME_LT(current_time(), end_time)) {
  14df6e:	f7f2 fcf7 	bl	140960 <current_time>
  14df72:	1b80      	subs	r0, r0, r6
  14df74:	2800      	cmp	r0, #0
            thread_sleep(1);
  14df76:	f04f 0001 	mov.w	r0, #1
        if (TIME_LT(current_time(), end_time)) {
  14df7a:	da20      	bge.n	14dfbe <__send_data_sync+0x86>
            thread_sleep(1);
  14df7c:	f001 fc58 	bl	14f830 <thread_sleep>
    while (!sd_mbox_last_tx_done(chan->hwchan)) {
  14df80:	6aa8      	ldr	r0, [r5, #40]	; 0x28
  14df82:	f7fa fbff 	bl	148784 <sd_mbox_last_tx_done>
  14df86:	2800      	cmp	r0, #0
  14df88:	d0ee      	beq.n	14df68 <__send_data_sync+0x30>
}
  14df8a:	4638      	mov	r0, r7
  14df8c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            spin(MB_TX_HRTMR_POLL);
  14df8e:	f004 fe7f 	bl	152c90 <spin>
            spin_usec -= MB_TX_HRTMR_POLL;
  14df92:	3c02      	subs	r4, #2
            continue;
  14df94:	e7e4      	b.n	14df60 <__send_data_sync+0x28>
            thread_yield();
  14df96:	f001 fb5b 	bl	14f650 <thread_yield>
    } while ((ret == ERR_NO_MSG) && TIME_LT(current_time(), end_time));
  14df9a:	1d3a      	adds	r2, r7, #4
  14df9c:	d12d      	bne.n	14dffa <__send_data_sync+0xc2>
  14df9e:	f7f2 fcdf 	bl	140960 <current_time>
  14dfa2:	1b80      	subs	r0, r0, r6
  14dfa4:	2800      	cmp	r0, #0
  14dfa6:	dbd3      	blt.n	14df50 <__send_data_sync+0x18>
           dprintf(0, "mbox: send fail %d %d:%d\n", ret,
  14dfa8:	f646 706c 	movw	r0, #28524	; 0x6f6c
  14dfac:	7c6b      	ldrb	r3, [r5, #17]
  14dfae:	7c2a      	ldrb	r2, [r5, #16]
  14dfb0:	4639      	mov	r1, r7
  14dfb2:	f2c0 0015 	movt	r0, #21
  14dfb6:	f006 f89f 	bl	1540f8 <_printf>
}
  14dfba:	4638      	mov	r0, r7
  14dfbc:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
            hal_mb_cancel_lastsend(chan);
  14dfbe:	4628      	mov	r0, r5
            ret = ERR_TIMED_OUT;
  14dfc0:	f06f 070c 	mvn.w	r7, #12
            hal_mb_cancel_lastsend(chan);
  14dfc4:	f7ff ff8a 	bl	14dedc <hal_mb_cancel_lastsend>
}
  14dfc8:	4638      	mov	r0, r7
  14dfca:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        dprintf(0, "mbox: %s nb not supported\n", __func__);
  14dfcc:	f646 7114 	movw	r1, #28436	; 0x6f14
  14dfd0:	f646 7050 	movw	r0, #28496	; 0x6f50
  14dfd4:	f2c0 0115 	movt	r1, #21
  14dfd8:	f2c0 0015 	movt	r0, #21
  14dfdc:	f006 f88c 	bl	1540f8 <_printf>
        return ERR_NOT_SUPPORTED;
  14dfe0:	f06f 0717 	mvn.w	r7, #23
  14dfe4:	e7d1      	b.n	14df8a <__send_data_sync+0x52>
        dprintf(0, "mbox: hwchan of %s not exist\n", chan->name);
  14dfe6:	f646 7088 	movw	r0, #28552	; 0x6f88
  14dfea:	4629      	mov	r1, r5
  14dfec:	f2c0 0015 	movt	r0, #21
  14dff0:	f006 f882 	bl	1540f8 <_printf>
        return ERR_NO_RESOURCES;
  14dff4:	f06f 0728 	mvn.w	r7, #40	; 0x28
  14dff8:	e7c7      	b.n	14df8a <__send_data_sync+0x52>
        if (ret != ERR_NOT_READY)
  14dffa:	1cfb      	adds	r3, r7, #3
  14dffc:	d0c5      	beq.n	14df8a <__send_data_sync+0x52>
  14dffe:	e7d3      	b.n	14dfa8 <__send_data_sync+0x70>

0014e000 <hal_mb_send_data_detail>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14e000:	2804      	cmp	r0, #4
{
  14e002:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14e006:	f89d 801c 	ldrb.w	r8, [r13, #28]
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14e00a:	d008      	beq.n	14e01e <hal_mb_send_data_detail+0x1e>
  14e00c:	f645 1526 	movw	r5, #22822	; 0x5926
  14e010:	4604      	mov	r4, r0
  14e012:	f850 6c04 	ldr.w	r6, [r0, #-4]
  14e016:	f2c3 1541 	movt	r5, #12609	; 0x3141
  14e01a:	42ae      	cmp	r6, r5
  14e01c:	d004      	beq.n	14e028 <hal_mb_send_data_detail+0x28>
        return ERR_INVALID_ARGS;
  14e01e:	f06f 0507 	mvn.w	r5, #7
}
  14e022:	4628      	mov	r0, r5
  14e024:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  14e028:	461f      	mov	r7, r3
    if (len > HAL_MB_MTU) {
  14e02a:	f5b2 7ffe 	cmp.w	r2, #508	; 0x1fc
  14e02e:	4616      	mov	r6, r2
  14e030:	460d      	mov	r5, r1
  14e032:	d82b      	bhi.n	14e08c <hal_mb_send_data_detail+0x8c>
    ret = __alloc_avail_buf(chan);
  14e034:	f7ff fe06 	bl	14dc44 <__alloc_avail_buf>
    if (ret < 0) {
  14e038:	2800      	cmp	r0, #0
  14e03a:	db31      	blt.n	14e0a0 <hal_mb_send_data_detail+0xa0>
    mb_msg_init_head(msg, chan->remote_proc, proto, priority, len, dest);
  14e03c:	9b06      	ldr	r3, [sp, #24]
    msg_buf = chan->msg_data[ret];
  14e03e:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    msg->rproc = rproc;
  14e042:	f894 e010 	ldrb.w	r14, [r4, #16]
    memcpy(msg->data, data, len);
  14e046:	4629      	mov	r1, r5
  14e048:	4632      	mov	r2, r6
    mb_msg_init_head(msg, chan->remote_proc, proto, priority, len, dest);
  14e04a:	f113 0c00 	adds.w	r12, r3, #0
    msg_buf = chan->msg_data[ret];
  14e04e:	69c5      	ldr	r5, [r0, #28]
  14e050:	782b      	ldrb	r3, [r5, #0]
    mb_msg_init_head(msg, chan->remote_proc, proto, priority, len, dest);
  14e052:	bf18      	it	ne
  14e054:	f04f 0c01 	movne.w	r12, #1
  14e058:	f36e 1306 	bfi	r3, r14, #4, #3
    msg->protocol = proto;
  14e05c:	f367 0303 	bfi	r3, r7, #0, #4
    msg->priority = priority;
  14e060:	f36c 13c7 	bfi	r3, r12, #7, #1
    msg->addr = dest;
  14e064:	f885 8001 	strb.w	r8, [r5, #1]
    msg->dat_len = MB_MSG_HDR_SZ + size;
  14e068:	1d30      	adds	r0, r6, #4
    msg->priority = priority;
  14e06a:	702b      	strb	r3, [r5, #0]
    msg->dat_len = MB_MSG_HDR_SZ + size;
  14e06c:	8068      	strh	r0, [r5, #2]
    memcpy(msg->data, data, len);
  14e06e:	1d28      	adds	r0, r5, #4
  14e070:	f004 ef7e 	blx	152f70 <memcpy>
    ret = __send_data_sync(chan, (u8 *)msg, timeout);
  14e074:	4629      	mov	r1, r5
  14e076:	9a08      	ldr	r2, [sp, #32]
  14e078:	4620      	mov	r0, r4
  14e07a:	f7ff ff5d 	bl	14df38 <__send_data_sync>
  14e07e:	4605      	mov	r5, r0
    __free_used_buf(chan);
  14e080:	4620      	mov	r0, r4
  14e082:	f7ff fdc1 	bl	14dc08 <__free_used_buf>
}
  14e086:	4628      	mov	r0, r5
  14e088:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        dprintf(ALWAYS, "mbox: send data length: %d exceed limitation\n", len);
  14e08c:	f247 0080 	movw	r0, #28800	; 0x7080
  14e090:	4631      	mov	r1, r6
  14e092:	f2c0 0015 	movt	r0, #21
  14e096:	f006 f82f 	bl	1540f8 <_printf>
        return ERR_BAD_LEN;
  14e09a:	f06f 051f 	mvn.w	r5, #31
  14e09e:	e7c0      	b.n	14e022 <hal_mb_send_data_detail+0x22>
        dprintf(ALWAYS, "mbox: no avail buf\n");
  14e0a0:	f247 00b0 	movw	r0, #28848	; 0x70b0
        return ERR_BUSY;
  14e0a4:	f06f 0520 	mvn.w	r5, #32
        dprintf(ALWAYS, "mbox: no avail buf\n");
  14e0a8:	f2c0 0015 	movt	r0, #21
  14e0ac:	f006 f824 	bl	1540f8 <_printf>
        return ERR_BUSY;
  14e0b0:	e7b7      	b.n	14e022 <hal_mb_send_data_detail+0x22>
  14e0b2:	bf00      	nop

0014e0b4 <hal_mb_send_data>:
{
  14e0b4:	b530      	push	{r4, r5, r14}
  14e0b6:	b085      	sub	sp, #20
    return hal_mb_send_data_detail(chan, data, len, MB_MSG_PROTO_DFT,
  14e0b8:	9302      	str	r3, [sp, #8]
  14e0ba:	2300      	movs	r3, #0
  14e0bc:	7c45      	ldrb	r5, [r0, #17]
  14e0be:	f890 402f 	ldrb.w	r4, [r0, #47]	; 0x2f
  14e0c2:	9501      	str	r5, [sp, #4]
  14e0c4:	9400      	str	r4, [sp, #0]
  14e0c6:	f7ff ff9b 	bl	14e000 <hal_mb_send_data_detail>
}
  14e0ca:	b005      	add	sp, #20
  14e0cc:	bd30      	pop	{r4, r5, r15}
  14e0ce:	bf00      	nop

0014e0d0 <hal_mb_send_data_nocopy>:
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14e0d0:	2804      	cmp	r0, #4
{
  14e0d2:	b538      	push	{r3, r4, r5, r14}
    return cl && (cl->magic == MBOX_HANDLE_MAGIC);
  14e0d4:	d008      	beq.n	14e0e8 <hal_mb_send_data_nocopy+0x18>
  14e0d6:	4604      	mov	r4, r0
  14e0d8:	f645 1326 	movw	r3, #22822	; 0x5926
  14e0dc:	f850 0c04 	ldr.w	r0, [r0, #-4]
  14e0e0:	f2c3 1341 	movt	r3, #12609	; 0x3141
  14e0e4:	4298      	cmp	r0, r3
  14e0e6:	d003      	beq.n	14e0f0 <hal_mb_send_data_nocopy+0x20>
        return ERR_INVALID_ARGS;
  14e0e8:	f06f 0507 	mvn.w	r5, #7
}
  14e0ec:	4628      	mov	r0, r5
  14e0ee:	bd38      	pop	{r3, r4, r5, r15}
    if (idx & 0x8000) {
  14e0f0:	040b      	lsls	r3, r1, #16
  14e0f2:	d501      	bpl.n	14e0f8 <hal_mb_send_data_nocopy+0x28>
        idx &= MBOX_TX_QUEUE_LEN - 1;
  14e0f4:	f001 0101 	and.w	r1, r1, #1
    ret = __send_data_sync(chan, msg_buf, timeoutMs);
  14e0f8:	4620      	mov	r0, r4
    msg_buf = chan->msg_data[idx];
  14e0fa:	eb04 0181 	add.w	r1, r4, r1, lsl #2
    ret = __send_data_sync(chan, msg_buf, timeoutMs);
  14e0fe:	69c9      	ldr	r1, [r1, #28]
  14e100:	f7ff ff1a 	bl	14df38 <__send_data_sync>
  14e104:	4605      	mov	r5, r0
    __free_used_buf(chan);
  14e106:	4620      	mov	r0, r4
  14e108:	f7ff fd7e 	bl	14dc08 <__free_used_buf>
}
  14e10c:	4628      	mov	r0, r5
  14e10e:	bd38      	pop	{r3, r4, r5, r15}

0014e110 <hal_mb_init>:
}

void hal_mb_init(void *cl, hal_mb_cfg_t *cfg)
{
    return;
}
  14e110:	4770      	bx	r14
  14e112:	bf00      	nop

0014e114 <hal_mb_create_handle>:
{
    return;
}

bool hal_mb_create_handle(void **handle, uint32_t res_glb_idx)
{
  14e114:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    int ret;
    hal_mb_instance_t *mbox;

    if (g_hal_mbox) {
  14e118:	f245 3460 	movw	r4, #21344	; 0x5360
{
  14e11c:	4606      	mov	r6, r0
    if (g_hal_mbox) {
  14e11e:	f2c0 0416 	movt	r4, #22
  14e122:	6825      	ldr	r5, [r4, #0]
  14e124:	b135      	cbz	r5, 14e134 <hal_mb_create_handle+0x20>
create_done:

    if (handle)
        *handle = (void*) g_hal_mbox;

    return true;
  14e126:	2001      	movs	r0, #1
    if (handle)
  14e128:	b116      	cbz	r6, 14e130 <hal_mb_create_handle+0x1c>
        *handle = (void*) g_hal_mbox;
  14e12a:	6823      	ldr	r3, [r4, #0]
    return true;
  14e12c:	2001      	movs	r0, #1
        *handle = (void*) g_hal_mbox;
  14e12e:	6033      	str	r3, [r6, #0]
}
  14e130:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    memset(mbox, 0, sizeof(*mbox));
  14e134:	f245 3764 	movw	r7, #21348	; 0x5364
  14e138:	f240 424c 	movw	r2, #1100	; 0x44c
  14e13c:	4688      	mov	r8, r1
  14e13e:	f2c0 0716 	movt	r7, #22
  14e142:	4629      	mov	r1, r5
  14e144:	4638      	mov	r0, r7
  14e146:	f004 ef9a 	blx	15307c <memset>
    mutex_init(&mbox->mbox_mutex);
  14e14a:	4638      	mov	r0, r7
  14e14c:	f001 f804 	bl	14f158 <mutex_init>
    mutex_init(&mbox->mb_tx_mutex);
  14e150:	f107 002c 	add.w	r0, r7, #44	; 0x2c
  14e154:	f001 f800 	bl	14f158 <mutex_init>
    mbox->cl_num = MB_MAX_CL_NUM;
  14e158:	2010      	movs	r0, #16
    mbox->mb_irq = MU_MESSAGE_READY_INT;
  14e15a:	f44f 7384 	mov.w	r3, #264	; 0x108
    ret = res_get_info_by_id(res_glb_idx, &mbox->paddr, &mbox->hw_id);
  14e15e:	f107 0228 	add.w	r2, r7, #40	; 0x28
    mbox->cl_num = MB_MAX_CL_NUM;
  14e162:	f887 0048 	strb.w	r0, [r7, #72]	; 0x48
    ret = res_get_info_by_id(res_glb_idx, &mbox->paddr, &mbox->hw_id);
  14e166:	f107 0124 	add.w	r1, r7, #36	; 0x24
    mbox->mb_irq = MU_MESSAGE_READY_INT;
  14e16a:	623b      	str	r3, [r7, #32]
    ret = res_get_info_by_id(res_glb_idx, &mbox->paddr, &mbox->hw_id);
  14e16c:	4640      	mov	r0, r8
  14e16e:	f000 f9a9 	bl	14e4c4 <res_get_info_by_id>
    if (ret < 0) {
  14e172:	2800      	cmp	r0, #0
  14e174:	db13      	blt.n	14e19e <hal_mb_create_handle+0x8a>
    ret = sd_mbox_probe(mbox->paddr);
  14e176:	6a78      	ldr	r0, [r7, #36]	; 0x24
  14e178:	f7fa fc74 	bl	148a64 <sd_mbox_probe>
    if (ret < 0) {
  14e17c:	1e01      	subs	r1, r0, #0
  14e17e:	db17      	blt.n	14e1b0 <hal_mb_create_handle+0x9c>
    register_int_handler(mbox->mb_irq, mb_irq_handler, mbox);
  14e180:	f64d 31f9 	movw	r1, #56313	; 0xdbf9
  14e184:	463a      	mov	r2, r7
  14e186:	6a38      	ldr	r0, [r7, #32]
  14e188:	f2c0 0114 	movt	r1, #20
  14e18c:	f7f2 faaa 	bl	1406e4 <register_int_handler>
    unmask_interrupt(mbox->mb_irq);
  14e190:	6a38      	ldr	r0, [r7, #32]
  14e192:	f7f2 faf9 	bl	140788 <unmask_interrupt>
    g_hal_mbox = mbox;
  14e196:	6027      	str	r7, [r4, #0]
    mbox->mbox_inited = true;
  14e198:	2301      	movs	r3, #1
  14e19a:	773b      	strb	r3, [r7, #28]
create_done:
  14e19c:	e7c3      	b.n	14e126 <hal_mb_create_handle+0x12>
        dprintf(CRITICAL, "mbox: fail to get resource info:%d", res_glb_idx);
  14e19e:	f646 70a8 	movw	r0, #28584	; 0x6fa8
  14e1a2:	4641      	mov	r1, r8
  14e1a4:	f2c0 0015 	movt	r0, #21
  14e1a8:	f005 ffa6 	bl	1540f8 <_printf>
        return false;
  14e1ac:	4628      	mov	r0, r5
  14e1ae:	e7bf      	b.n	14e130 <hal_mb_create_handle+0x1c>
        dprintf(CRITICAL, "mbox: hardware init fail ret:%d", ret);
  14e1b0:	f646 70cc 	movw	r0, #28620	; 0x6fcc
  14e1b4:	f2c0 0015 	movt	r0, #21
  14e1b8:	f005 ff9e 	bl	1540f8 <_printf>
        return false;
  14e1bc:	4628      	mov	r0, r5
  14e1be:	e7b7      	b.n	14e130 <hal_mb_create_handle+0x1c>

0014e1c0 <rpmsg_net_init_hook>:
    lwiperf_start_tcp_server_default(NULL, NULL);
}
#else
void rpmsg_net_init_hook(void)
{
}
  14e1c0:	4770      	bx	r14
  14e1c2:	bf00      	nop

0014e1c4 <hal_port_creat_handle>:
spin_lock_t port_spin_lock = SPIN_LOCK_INITIAL_VALUE;

static struct port_handle s_port_handle;

bool hal_port_creat_handle(void **handle, uint32_t port_res_glb_idx)
{
  14e1c4:	b5f0      	push	{r4, r5, r6, r7, r14}
    struct port_handle *p_handle;
    int8_t ret = 0;
    paddr_t phy_addr = 0;
  14e1c6:	2400      	movs	r4, #0
{
  14e1c8:	b085      	sub	sp, #20
  14e1ca:	4606      	mov	r6, r0
    paddr_t dio_phy_addr = 0;
    int32_t dio_real_idx = 0;
    spin_lock_saved_state_t states;
    LTRACEF("+hal_port_creat_handle \n");

    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  14e1cc:	aa01      	add	r2, sp, #4
    int32_t real_idx = 0;
  14e1ce:	e9cd 4400 	strd	r4, r4, [r13]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  14e1d2:	4608      	mov	r0, r1
    int32_t dio_real_idx = 0;
  14e1d4:	e9cd 4402 	strd	r4, r4, [r13, #8]
    ret = res_get_info_by_id(port_res_glb_idx, &phy_addr, &real_idx);
  14e1d8:	4669      	mov	r1, r13
  14e1da:	f000 f973 	bl	14e4c4 <res_get_info_by_id>

    if (ret != -1) {
  14e1de:	b240      	sxtb	r0, r0
  14e1e0:	3001      	adds	r0, #1
  14e1e2:	d046      	beq.n	14e272 <hal_port_creat_handle+0xae>
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
        return false;
    }

    /* To get GPIO base address for Port */
    ret = res_get_info_by_id(g_gpio_res.res_id[0], &dio_phy_addr, &dio_real_idx);
  14e1e4:	f247 4390 	movw	r3, #29840	; 0x7490
  14e1e8:	aa03      	add	r2, sp, #12
  14e1ea:	f2c0 0315 	movt	r3, #21
  14e1ee:	a902      	add	r1, sp, #8
  14e1f0:	6858      	ldr	r0, [r3, #4]
  14e1f2:	f000 f967 	bl	14e4c4 <res_get_info_by_id>

    if (ret != -1) {
  14e1f6:	b240      	sxtb	r0, r0
  14e1f8:	3001      	adds	r0, #1
  14e1fa:	d043      	beq.n	14e284 <hal_port_creat_handle+0xc0>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14e1fc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14e200:	f013 0580 	ands.w	r5, r3, #128	; 0x80
  14e204:	d11b      	bne.n	14e23e <hal_port_creat_handle+0x7a>
    __asm__ volatile("cpsid i");
  14e206:	b672      	cpsid	i

#endif

    p_handle = &s_port_handle;
    spin_lock_irqsave(&port_spin_lock, states);
    p_handle->phy_addr = phy_addr;
  14e208:	f245 73b4 	movw	r3, #22452	; 0x57b4
    *lock = 1;
  14e20c:	f245 77b0 	movw	r7, #22448	; 0x57b0
  14e210:	9a00      	ldr	r2, [sp, #0]
  14e212:	f2c0 0316 	movt	r3, #22
  14e216:	2401      	movs	r4, #1
  14e218:	f2c0 0716 	movt	r7, #22
  14e21c:	601a      	str	r2, [r3, #0]
    p_handle->real_idx = real_idx;
    p_handle->dio_phy_addr = dio_phy_addr;
    p_handle->dio_real_idx = dio_real_idx;
    *handle = p_handle;
    Port_SetHandle((void *)p_handle);
  14e21e:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  14e220:	9a01      	ldr	r2, [sp, #4]
  14e222:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  14e224:	9a02      	ldr	r2, [sp, #8]
  14e226:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  14e228:	9a03      	ldr	r2, [sp, #12]
  14e22a:	60da      	str	r2, [r3, #12]
  14e22c:	603c      	str	r4, [r7, #0]
    *handle = p_handle;
  14e22e:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  14e230:	f7fa fce4 	bl	148bfc <Port_SetHandle>
    *lock = 0;
  14e234:	603d      	str	r5, [r7, #0]
    __asm__ volatile("cpsie i");
  14e236:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);


    LTRACEF("-hal_port_creat_handle finished\n");

    return true;
  14e238:	4620      	mov	r0, r4
}
  14e23a:	b005      	add	sp, #20
  14e23c:	bdf0      	pop	{r4, r5, r6, r7, r15}
    p_handle->phy_addr = phy_addr;
  14e23e:	f245 73b4 	movw	r3, #22452	; 0x57b4
    *lock = 1;
  14e242:	f245 77b0 	movw	r7, #22448	; 0x57b0
  14e246:	9a00      	ldr	r2, [sp, #0]
  14e248:	f2c0 0316 	movt	r3, #22
  14e24c:	2501      	movs	r5, #1
  14e24e:	f2c0 0716 	movt	r7, #22
  14e252:	601a      	str	r2, [r3, #0]
    Port_SetHandle((void *)p_handle);
  14e254:	4618      	mov	r0, r3
    p_handle->real_idx = real_idx;
  14e256:	9a01      	ldr	r2, [sp, #4]
  14e258:	605a      	str	r2, [r3, #4]
    p_handle->dio_phy_addr = dio_phy_addr;
  14e25a:	9a02      	ldr	r2, [sp, #8]
  14e25c:	609a      	str	r2, [r3, #8]
    p_handle->dio_real_idx = dio_real_idx;
  14e25e:	9a03      	ldr	r2, [sp, #12]
  14e260:	603d      	str	r5, [r7, #0]
  14e262:	60da      	str	r2, [r3, #12]
    *handle = p_handle;
  14e264:	6033      	str	r3, [r6, #0]
    Port_SetHandle((void *)p_handle);
  14e266:	f7fa fcc9 	bl	148bfc <Port_SetHandle>
    *lock = 0;
  14e26a:	603c      	str	r4, [r7, #0]
    return true;
  14e26c:	4628      	mov	r0, r5
}
  14e26e:	b005      	add	sp, #20
  14e270:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for port failed! 03\n");
  14e272:	f247 00c4 	movw	r0, #28868	; 0x70c4
  14e276:	f2c0 0015 	movt	r0, #21
  14e27a:	f005 ff3d 	bl	1540f8 <_printf>
        return false;
  14e27e:	4620      	mov	r0, r4
}
  14e280:	b005      	add	sp, #20
  14e282:	bdf0      	pop	{r4, r5, r6, r7, r15}
        printf("hal_port_creat_handle: res_get_info_by_id for dio failed! 03\n");
  14e284:	f247 1004 	movw	r0, #28932	; 0x7104
  14e288:	f2c0 0015 	movt	r0, #21
  14e28c:	f005 ff34 	bl	1540f8 <_printf>
        return false;
  14e290:	4620      	mov	r0, r4
}
  14e292:	b005      	add	sp, #20
  14e294:	bdf0      	pop	{r4, r5, r6, r7, r15}
  14e296:	bf00      	nop

0014e298 <hal_port_release_handle>:

bool hal_port_release_handle(void **handle)
{
  14e298:	b510      	push	{r4, r14}
  14e29a:	b082      	sub	sp, #8
    ASSERT(handle);
  14e29c:	b310      	cbz	r0, 14e2e4 <hal_port_release_handle+0x4c>
    struct port_handle *port = *handle;
  14e29e:	6802      	ldr	r2, [r0, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14e2a0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14e2a4:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14e2a8:	d10e      	bne.n	14e2c8 <hal_port_release_handle+0x30>
    __asm__ volatile("cpsid i");
  14e2aa:	b672      	cpsid	i
    *lock = 0;
  14e2ac:	f245 71b0 	movw	r1, #22448	; 0x57b0
    spin_lock_saved_state_t states;

    spin_lock_irqsave(&port_spin_lock, states);
    port->phy_addr = 0;
    port->real_idx = -1;
  14e2b0:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  14e2b4:	f2c0 0116 	movt	r1, #22
  14e2b8:	e9c2 3400 	strd	r3, r4, [r2]
    *handle = NULL;
  14e2bc:	6003      	str	r3, [r0, #0]
  14e2be:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
  14e2c0:	b662      	cpsie	i
    spin_unlock_irqrestore(&port_spin_lock, states);

    return true;
}
  14e2c2:	2001      	movs	r0, #1
  14e2c4:	b002      	add	sp, #8
  14e2c6:	bd10      	pop	{r4, r15}
  14e2c8:	f245 73b0 	movw	r3, #22448	; 0x57b0
    port->phy_addr = 0;
  14e2cc:	2100      	movs	r1, #0
    port->real_idx = -1;
  14e2ce:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  14e2d2:	f2c0 0316 	movt	r3, #22
  14e2d6:	e9c2 1400 	strd	r1, r4, [r2]
    *handle = NULL;
  14e2da:	6001      	str	r1, [r0, #0]
}
  14e2dc:	2001      	movs	r0, #1
  14e2de:	6019      	str	r1, [r3, #0]
  14e2e0:	b002      	add	sp, #8
  14e2e2:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  14e2e4:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14e2e8:	f247 1244 	movw	r2, #28996	; 0x7144
  14e2ec:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14e2f0:	f2c0 0315 	movt	r3, #21
  14e2f4:	4670      	mov	r0, r14
  14e2f6:	f2c0 0215 	movt	r2, #21
  14e2fa:	9300      	str	r3, [sp, #0]
  14e2fc:	f2c0 0115 	movt	r1, #21
  14e300:	2374      	movs	r3, #116	; 0x74
  14e302:	f004 fcd7 	bl	152cb4 <_panic>
  14e306:	bf00      	nop

0014e308 <hal_port_set_pin_mode>:
    return true;
}

int hal_port_set_pin_mode(void *handle, const Port_PinType pin,
                          const Port_PinModeType mode)
{
  14e308:	b510      	push	{r4, r14}
  14e30a:	b084      	sub	sp, #16
  14e30c:	ac02      	add	r4, sp, #8
  14e30e:	e884 000c 	stmia.w	r4, {r2, r3}
    ASSERT(handle);
  14e312:	b138      	cbz	r0, 14e324 <hal_port_set_pin_mode+0x1c>
    Port_SetPinMode(pin, mode);
  14e314:	4608      	mov	r0, r1
  14e316:	e894 0006 	ldmia.w	r4, {r1, r2}
  14e31a:	f7fa fc01 	bl	148b20 <Port_SetPinMode>

    return true;
}
  14e31e:	2001      	movs	r0, #1
  14e320:	b004      	add	sp, #16
  14e322:	bd10      	pop	{r4, r15}
    ASSERT(handle);
  14e324:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14e328:	f247 1244 	movw	r2, #28996	; 0x7144
  14e32c:	f644 316c 	movw	r1, #19308	; 0x4b6c
  14e330:	f2c0 0315 	movt	r3, #21
  14e334:	4670      	mov	r0, r14
  14e336:	f2c0 0215 	movt	r2, #21
  14e33a:	9300      	str	r3, [sp, #0]
  14e33c:	f2c0 0115 	movt	r1, #21
  14e340:	23f6      	movs	r3, #246	; 0xf6
  14e342:	f004 fcb7 	bl	152cb4 <_panic>
  14e346:	bf00      	nop

0014e348 <parse_paddr_ppc>:
    return -1;
}

/* Parse address for peripheral type resources */
int32_t parse_paddr_ppc(uint32_t ppc_index, uint32_t slot_index, addr_t * paddr)
{
  14e348:	b5f0      	push	{r4, r5, r6, r7, r14}
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  14e34a:	f247 147c 	movw	r4, #29052	; 0x717c
{
  14e34e:	4607      	mov	r7, r0
  14e350:	468c      	mov	r12, r1
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  14e352:	f2c0 0415 	movt	r4, #21
{
  14e356:	4696      	mov	r14, r2
                                APBMUX5_IP_BASE, APBMUX6_IP_BASE, APBMUX7_IP_BASE, APBMUX8_IP_BASE,
                                APB_DDR_CFG_BASE, APB_SMMU_BASE, APB_CE2_REG_BASE, APB_SCR4K_SID_BASE,
                                APB_SCR4K_SSID_BASE, APB_CSSYS_BASE};
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  14e358:	f104 0538 	add.w	r5, r4, #56	; 0x38
{
  14e35c:	b09d      	sub	sp, #116	; 0x74
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  14e35e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14e360:	466e      	mov	r6, r13
  14e362:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  14e364:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14e366:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  14e368:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  14e36a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
  14e36c:	e894 0003 	ldmia.w	r4, {r0, r1}
                                APBMUX5_IP_SIZE, APBMUX6_IP_SIZE, APBMUX7_IP_SIZE, APBMUX8_IP_SIZE,
                                APB_DDR_CFG_SIZE, APB_SMMU_SIZE, APB_CE2_REG_SIZE, APB_SCR4K_SID_SIZE,
                                APB_SCR4K_SSID_SIZE, APB_CSSYS_SIZE};

    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  14e370:	ab1c      	add	r3, sp, #112	; 0x70
    uint32_t ppc_base_addr[PPC_MAX_NUM] = {APBMUX1_IP_BASE, APBMUX2_IP_BASE, APBMUX3_IP_BASE, APBMUX4_IP_BASE,
  14e372:	e886 0003 	stmia.w	r6, {r0, r1}
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  14e376:	eb03 0687 	add.w	r6, r3, r7, lsl #2
    uint32_t ppc_slot_size[PPC_MAX_NUM] = {APBMUX1_IP_SIZE, APBMUX2_IP_SIZE, APBMUX3_IP_SIZE, APBMUX4_IP_SIZE,
  14e37a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  14e37c:	ac0e      	add	r4, sp, #56	; 0x38
  14e37e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14e380:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  14e382:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14e384:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  14e386:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14e388:	e895 0003 	ldmia.w	r5, {r0, r1}
  14e38c:	e884 0003 	stmia.w	r4, {r0, r1}

    return 0;
}
  14e390:	2000      	movs	r0, #0
    *paddr = ppc_base_addr[ppc_index] + ppc_slot_size[ppc_index] * slot_index;
  14e392:	f856 2c38 	ldr.w	r2, [r6, #-56]
  14e396:	f856 3c70 	ldr.w	r3, [r6, #-112]
  14e39a:	fb02 330c 	mla	r3, r2, r12, r3
  14e39e:	f8ce 3000 	str.w	r3, [r14]
}
  14e3a2:	b01d      	add	sp, #116	; 0x74
  14e3a4:	bdf0      	pop	{r4, r5, r6, r7, r15}
  14e3a6:	bf00      	nop

0014e3a8 <parse_paddr_rpc>:

/* Parse address and index for register level resources */
int32_t parse_paddr_rpc(uint32_t rpc_index, uint32_t slot_index, addr_t * paddr, int32_t * index)
{
  14e3a8:	b410      	push	{r4}
    if (slot_index >= 2046) {
  14e3aa:	f240 74fd 	movw	r4, #2045	; 0x7fd
  14e3ae:	42a1      	cmp	r1, r4
  14e3b0:	d824      	bhi.n	14e3fc <parse_paddr_rpc+0x54>
        return -1;
    }

    uint32_t addr_offset = 0;

    if (slot_index >= IOMUXC_INDEX) {
  14e3b2:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
  14e3b6:	d213      	bcs.n	14e3e0 <parse_paddr_rpc+0x38>
        *index = slot_index - IOMUXC_INDEX;
        addr_offset = 5;
    }
    else if (slot_index >= RSTGEN_INDEX) {
  14e3b8:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
  14e3bc:	d32b      	bcc.n	14e416 <parse_paddr_rpc+0x6e>
        *index = slot_index - RSTGEN_INDEX;
        addr_offset = 4;
  14e3be:	2404      	movs	r4, #4
        *index = slot_index - RSTGEN_INDEX;
  14e3c0:	f5a1 6180 	sub.w	r1, r1, #1024	; 0x400
  14e3c4:	6019      	str	r1, [r3, #0]
    }
    else {
        *index = slot_index;
    }

    switch (rpc_index) {
  14e3c6:	2801      	cmp	r0, #1
  14e3c8:	d010      	beq.n	14e3ec <parse_paddr_rpc+0x44>
  14e3ca:	d31c      	bcc.n	14e406 <parse_paddr_rpc+0x5e>
  14e3cc:	2802      	cmp	r0, #2
  14e3ce:	d115      	bne.n	14e3fc <parse_paddr_rpc+0x54>
        default:
            return -1;
        break;
    }

    return 0;
  14e3d0:	2000      	movs	r0, #0
            *paddr = APB_RPC_SAF_BASE + addr_offset * RPC_ADDR_OFFSET;
  14e3d2:	f504 647c 	add.w	r4, r4, #4032	; 0xfc0
  14e3d6:	0524      	lsls	r4, r4, #20
  14e3d8:	6014      	str	r4, [r2, #0]
}
  14e3da:	f85d 4b04 	ldr.w	r4, [r13], #4
  14e3de:	4770      	bx	r14
        *index = slot_index - IOMUXC_INDEX;
  14e3e0:	f5a1 61a0 	sub.w	r1, r1, #1280	; 0x500
        addr_offset = 5;
  14e3e4:	2405      	movs	r4, #5
    switch (rpc_index) {
  14e3e6:	2801      	cmp	r0, #1
        *index = slot_index - IOMUXC_INDEX;
  14e3e8:	6019      	str	r1, [r3, #0]
    switch (rpc_index) {
  14e3ea:	d1ee      	bne.n	14e3ca <parse_paddr_rpc+0x22>
    return 0;
  14e3ec:	2000      	movs	r0, #0
            *paddr = APB_RPC_SEC_BASE + addr_offset * RPC_ADDR_OFFSET;
  14e3ee:	f504 6478 	add.w	r4, r4, #3968	; 0xf80
  14e3f2:	0524      	lsls	r4, r4, #20
  14e3f4:	6014      	str	r4, [r2, #0]
}
  14e3f6:	f85d 4b04 	ldr.w	r4, [r13], #4
  14e3fa:	4770      	bx	r14
  14e3fc:	f85d 4b04 	ldr.w	r4, [r13], #4
            return -1;
  14e400:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  14e404:	4770      	bx	r14
    return 0;
  14e406:	2000      	movs	r0, #0
            *paddr = APB_RPC_SOC_BASE + addr_offset * RPC_ADDR_OFFSET;
  14e408:	f504 6476 	add.w	r4, r4, #3936	; 0xf60
  14e40c:	0524      	lsls	r4, r4, #20
  14e40e:	6014      	str	r4, [r2, #0]
}
  14e410:	f85d 4b04 	ldr.w	r4, [r13], #4
  14e414:	4770      	bx	r14
    else if (slot_index >= SCR_INDEX) {
  14e416:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
        addr_offset = 2;
  14e41a:	bf26      	itte	cs
  14e41c:	2402      	movcs	r4, #2
        *index = slot_index - SCR_INDEX;
  14e41e:	f5a1 7100 	subcs.w	r1, r1, #512	; 0x200
    uint32_t addr_offset = 0;
  14e422:	2400      	movcc	r4, #0
        *index = slot_index;
  14e424:	6019      	str	r1, [r3, #0]
  14e426:	e7ce      	b.n	14e3c6 <parse_paddr_rpc+0x1e>

0014e428 <res_parse_info>:

/* Parse resource ID to acquire base address and index of resource */
int32_t res_parse_info(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  14e428:	b4f0      	push	{r4, r5, r6, r7}
    uint32_t rapc_type;
    uint32_t rapc_index;
    uint32_t slot_index;
    int32_t res = 0;

    *index = -1;
  14e42a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff

    rapc_type = res_id >> 30;
  14e42e:	0f85      	lsrs	r5, r0, #30
{
  14e430:	4613      	mov	r3, r2
    rapc_index = (res_id >> 24) & 0x3F;
    slot_index = res_id & 0xFFF;

    switch (rapc_type) {
  14e432:	2d01      	cmp	r5, #1
    *index = -1;
  14e434:	6014      	str	r4, [r2, #0]
    rapc_index = (res_id >> 24) & 0x3F;
  14e436:	f3c0 6605 	ubfx	r6, r0, #24, #6
    slot_index = res_id & 0xFFF;
  14e43a:	f3c0 070b 	ubfx	r7, r0, #0, #12
    switch (rapc_type) {
  14e43e:	d02e      	beq.n	14e49e <res_parse_info+0x76>
  14e440:	d30c      	bcc.n	14e45c <res_parse_info+0x34>
  14e442:	2d02      	cmp	r5, #2
  14e444:	d002      	beq.n	14e44c <res_parse_info+0x24>
        case 0: //MPC
            if (rapc_index >= MPC_MAX_NUM) {
                return -1;
  14e446:	4620      	mov	r0, r4
        default:
            return -1;
    }

    return res;
}
  14e448:	bcf0      	pop	{r4, r5, r6, r7}
  14e44a:	4770      	bx	r14
            if (rapc_index >= PPC_MAX_NUM) {
  14e44c:	2e0d      	cmp	r6, #13
  14e44e:	d8fa      	bhi.n	14e446 <res_parse_info+0x1e>
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  14e450:	460a      	mov	r2, r1
  14e452:	4630      	mov	r0, r6
  14e454:	4639      	mov	r1, r7
}
  14e456:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_rpc(rapc_index, slot_index, paddr, index);
  14e458:	f7ff bfa6 	b.w	14e3a8 <parse_paddr_rpc>
            if (rapc_index >= MPC_MAX_NUM) {
  14e45c:	2e1a      	cmp	r6, #26
  14e45e:	d8f2      	bhi.n	14e446 <res_parse_info+0x1e>
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  14e460:	f3c0 4246 	ubfx	r2, r0, #17, #7
    if (cat_id >= MPC_CATEGORY_MAX) {
  14e464:	2a0d      	cmp	r2, #13
  14e466:	d8ee      	bhi.n	14e446 <res_parse_info+0x1e>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  14e468:	f640 63ec 	movw	r3, #3820	; 0xeec
  14e46c:	f2c0 0316 	movt	r3, #22
  14e470:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  14e474:	6816      	ldr	r6, [r2, #0]
  14e476:	2e00      	cmp	r6, #0
  14e478:	dde5      	ble.n	14e446 <res_parse_info+0x1e>
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  14e47a:	6853      	ldr	r3, [r2, #4]
  14e47c:	4298      	cmp	r0, r3
  14e47e:	bf1c      	itt	ne
  14e480:	4614      	movne	r4, r2
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  14e482:	2300      	movne	r3, #0
        if (res_id == mem_info_init[cat_id]->mem_info[i].res_id) {
  14e484:	d103      	bne.n	14e48e <res_parse_info+0x66>
  14e486:	e015      	b.n	14e4b4 <res_parse_info+0x8c>
  14e488:	6865      	ldr	r5, [r4, #4]
  14e48a:	42a8      	cmp	r0, r5
  14e48c:	d013      	beq.n	14e4b6 <res_parse_info+0x8e>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  14e48e:	3301      	adds	r3, #1
  14e490:	42b3      	cmp	r3, r6
  14e492:	f104 0408 	add.w	r4, r4, #8
  14e496:	d1f7      	bne.n	14e488 <res_parse_info+0x60>
                return -1;
  14e498:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  14e49c:	e7d4      	b.n	14e448 <res_parse_info+0x20>
            if (rapc_index >= PPC_MAX_NUM) {
  14e49e:	2e0d      	cmp	r6, #13
  14e4a0:	d8d1      	bhi.n	14e446 <res_parse_info+0x1e>
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  14e4a2:	460a      	mov	r2, r1
            *index = (res_id >> 12) & 0x1F;
  14e4a4:	f3c0 3004 	ubfx	r0, r0, #12, #5
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  14e4a8:	4639      	mov	r1, r7
            *index = (res_id >> 12) & 0x1F;
  14e4aa:	6018      	str	r0, [r3, #0]
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  14e4ac:	4630      	mov	r0, r6
}
  14e4ae:	bcf0      	pop	{r4, r5, r6, r7}
            res = parse_paddr_ppc(rapc_index, slot_index, paddr);
  14e4b0:	f7ff bf4a 	b.w	14e348 <parse_paddr_ppc>
    for (int i = 0; i < mem_info_init[cat_id]->res_num; i++) {
  14e4b4:	2300      	movs	r3, #0
            return 0;
  14e4b6:	2000      	movs	r0, #0
            *paddr = mem_info_init[cat_id]->mem_info[i].paddr;
  14e4b8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
  14e4bc:	689b      	ldr	r3, [r3, #8]
  14e4be:	600b      	str	r3, [r1, #0]
  14e4c0:	e7c2      	b.n	14e448 <res_parse_info+0x20>
  14e4c2:	bf00      	nop

0014e4c4 <res_get_info_by_id>:

/* Get resource info by ID. */
const int32_t res_get_info_by_id(uint32_t res_id, addr_t * paddr, int32_t * index)
{
  14e4c4:	b470      	push	{r4, r5, r6}
    uint32_t cat_id = (res_id >> 17) & 0x7F;
  14e4c6:	f3c0 4446 	ubfx	r4, r0, #17, #7

    if (cat_id >= (sizeof(g_res_cat) / sizeof(g_res_cat[0]))) {
  14e4ca:	2c4d      	cmp	r4, #77	; 0x4d
  14e4cc:	d817      	bhi.n	14e4fe <res_get_info_by_id+0x3a>
        return -1;
    }

    if (NULL != g_res_cat[cat_id]) { //check avaibility of resource
  14e4ce:	f647 03a0 	movw	r3, #30880	; 0x78a0
  14e4d2:	f2c0 0315 	movt	r3, #21
  14e4d6:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]
  14e4da:	b184      	cbz	r4, 14e4fe <res_get_info_by_id+0x3a>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  14e4dc:	6826      	ldr	r6, [r4, #0]
  14e4de:	2e00      	cmp	r6, #0
  14e4e0:	dd0d      	ble.n	14e4fe <res_get_info_by_id+0x3a>
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  14e4e2:	6863      	ldr	r3, [r4, #4]
  14e4e4:	4298      	cmp	r0, r3
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  14e4e6:	bf1c      	itt	ne
  14e4e8:	2300      	movne	r3, #0
  14e4ea:	3404      	addne	r4, #4
            if (g_res_cat[cat_id]->res_id[i] == res_id)
  14e4ec:	d104      	bne.n	14e4f8 <res_get_info_by_id+0x34>
  14e4ee:	e00a      	b.n	14e506 <res_get_info_by_id+0x42>
  14e4f0:	f854 5f04 	ldr.w	r5, [r4, #4]!
  14e4f4:	4285      	cmp	r5, r0
  14e4f6:	d006      	beq.n	14e506 <res_get_info_by_id+0x42>
        for (int i = 0; i < g_res_cat[cat_id]->res_num; i++) {
  14e4f8:	3301      	adds	r3, #1
  14e4fa:	42b3      	cmp	r3, r6
  14e4fc:	d1f8      	bne.n	14e4f0 <res_get_info_by_id+0x2c>
                return res_parse_info(res_id, paddr, index);
        }
    }

    return -1;
}
  14e4fe:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  14e502:	bc70      	pop	{r4, r5, r6}
  14e504:	4770      	bx	r14
  14e506:	bc70      	pop	{r4, r5, r6}
                return res_parse_info(res_id, paddr, index);
  14e508:	f7ff bf8e 	b.w	14e428 <res_parse_info>

0014e50c <p2ap>:
    addrmap_def
};

/* Transform address from r core to a core */
paddr_t p2ap(paddr_t pa)
{
  14e50c:	f44f 0296 	mov.w	r2, #4915200	; 0x4b0000
    int i = 0;
    struct addr_map *addr;
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  14e510:	2300      	movs	r3, #0
{
  14e512:	b430      	push	{r4, r5}
  14e514:	f247 14ec 	movw	r4, #29164	; 0x71ec
        addr = &addrmap_tab[i];
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
  14e518:	4290      	cmp	r0, r2
  14e51a:	f2c0 0415 	movt	r4, #21
  14e51e:	4621      	mov	r1, r4
  14e520:	eba0 0502 	sub.w	r5, r0, r2
  14e524:	d302      	bcc.n	14e52c <p2ap+0x20>
  14e526:	684a      	ldr	r2, [r1, #4]
  14e528:	4295      	cmp	r5, r2
  14e52a:	d30b      	bcc.n	14e544 <p2ap+0x38>
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  14e52c:	3301      	adds	r3, #1
  14e52e:	2b03      	cmp	r3, #3
  14e530:	d00e      	beq.n	14e550 <p2ap+0x44>
  14e532:	f851 2f0c 	ldr.w	r2, [r1, #12]!
        if (pa >= addr->src && (pa - addr->src) < addr->size) {
  14e536:	4290      	cmp	r0, r2
  14e538:	eba0 0502 	sub.w	r5, r0, r2
  14e53c:	d3f6      	bcc.n	14e52c <p2ap+0x20>
  14e53e:	684a      	ldr	r2, [r1, #4]
  14e540:	4295      	cmp	r5, r2
  14e542:	d2f3      	bcs.n	14e52c <p2ap+0x20>
            return (pa - addr->src + addr->dst);
  14e544:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  14e548:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  14e54c:	6898      	ldr	r0, [r3, #8]
  14e54e:	4428      	add	r0, r5
        }
    }
    return pa;
}
  14e550:	bc30      	pop	{r4, r5}
  14e552:	4770      	bx	r14

0014e554 <ap2p>:

/* Transform address from a core to r core */
paddr_t ap2p(paddr_t va)
{
  14e554:	f44f 116c 	mov.w	r1, #3866624	; 0x3b0000
    int i = 0;
    struct addr_map *addr;
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  14e558:	2200      	movs	r2, #0
{
  14e55a:	b430      	push	{r4, r5}
  14e55c:	f247 15ec 	movw	r5, #29164	; 0x71ec
        addr = &addrmap_tab[i];
        if (va >= addr->dst && (va - addr->dst) < addr->size) {
  14e560:	4288      	cmp	r0, r1
  14e562:	f2c0 0515 	movt	r5, #21
  14e566:	462b      	mov	r3, r5
  14e568:	eba0 0401 	sub.w	r4, r0, r1
  14e56c:	d302      	bcc.n	14e574 <ap2p+0x20>
  14e56e:	6859      	ldr	r1, [r3, #4]
  14e570:	428c      	cmp	r4, r1
  14e572:	d30c      	bcc.n	14e58e <ap2p+0x3a>
    for (i = 0; i < (int)(sizeof(addrmap_tab) / sizeof(addrmap_tab[0])); i++) {
  14e574:	3201      	adds	r2, #1
  14e576:	2a03      	cmp	r2, #3
  14e578:	f103 030c 	add.w	r3, r3, #12
  14e57c:	d00c      	beq.n	14e598 <ap2p+0x44>
  14e57e:	6899      	ldr	r1, [r3, #8]
        if (va >= addr->dst && (va - addr->dst) < addr->size) {
  14e580:	4288      	cmp	r0, r1
  14e582:	eba0 0401 	sub.w	r4, r0, r1
  14e586:	d3f5      	bcc.n	14e574 <ap2p+0x20>
  14e588:	6859      	ldr	r1, [r3, #4]
  14e58a:	428c      	cmp	r4, r1
  14e58c:	d2f2      	bcs.n	14e574 <ap2p+0x20>
            return (va - addr->dst + addr->src);
  14e58e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  14e592:	f855 0022 	ldr.w	r0, [r5, r2, lsl #2]
  14e596:	4420      	add	r0, r4
        }
    }
    return va;
}
  14e598:	bc30      	pop	{r4, r5}
  14e59a:	4770      	bx	r14

0014e59c <hal_rstgen_creat_handle>:
//! \return rstgen handle
//
//*****************************************************************************
bool hal_rstgen_creat_handle(void **handle,
                             uint32_t global_rst_res_idx)
{
  14e59c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
    int32_t idx = -1;
  14e5a0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
{
  14e5a4:	b083      	sub	sp, #12
    int32_t idx = -1;
  14e5a6:	9301      	str	r3, [sp, #4]
    rstgen_instance_t  *instance = NULL;

    if (handle == NULL) {
  14e5a8:	b398      	cbz	r0, 14e612 <hal_rstgen_creat_handle+0x76>
        LTRACEF("hal_get_resource paramenter error handle:%p\n", handle);
        return false;
    }

    if (rstgen_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  14e5aa:	f645 0508 	movw	r5, #22536	; 0x5808
  14e5ae:	f2c0 0516 	movt	r5, #22
  14e5b2:	682b      	ldr	r3, [r5, #0]
  14e5b4:	b10b      	cbz	r3, 14e5ba <hal_rstgen_creat_handle+0x1e>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14e5b6:	2300      	movs	r3, #0
  14e5b8:	602b      	str	r3, [r5, #0]
  14e5ba:	4607      	mov	r7, r0
  14e5bc:	4689      	mov	r9, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14e5be:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14e5c2:	f013 0680 	ands.w	r6, r3, #128	; 0x80
  14e5c6:	d128      	bne.n	14e61a <hal_rstgen_creat_handle+0x7e>
    __asm__ volatile("cpsid i");
  14e5c8:	b672      	cpsid	i
    if (g_RstgenInstance.occupied != 1) {
  14e5ca:	f245 74c4 	movw	r4, #22468	; 0x57c4
    *lock = 1;
  14e5ce:	f04f 0801 	mov.w	r8, #1
  14e5d2:	f2c0 0416 	movt	r4, #22
  14e5d6:	f894 3020 	ldrb.w	r3, [r4, #32]
  14e5da:	4543      	cmp	r3, r8
  14e5dc:	d04d      	beq.n	14e67a <hal_rstgen_creat_handle+0xde>
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  14e5de:	2240      	movs	r2, #64	; 0x40
  14e5e0:	4631      	mov	r1, r6
  14e5e2:	4620      	mov	r0, r4
  14e5e4:	f004 ed4a 	blx	15307c <memset>
            g_RstgenInstance.occupied = 1;
  14e5e8:	f884 8020 	strb.w	r8, [r4, #32]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  14e5ec:	f884 8033 	strb.w	r8, [r4, #51]	; 0x33
    *controllerTable = &s_RstgenDrvInterface;
  14e5f0:	f647 43e8 	movw	r3, #31976	; 0x7ce8
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  14e5f4:	f884 8034 	strb.w	r8, [r4, #52]	; 0x34
    *controllerTable = &s_RstgenDrvInterface;
  14e5f8:	f2c0 0315 	movt	r3, #21
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  14e5fc:	f884 8035 	strb.w	r8, [r4, #53]	; 0x35
    *lock = 0;
  14e600:	602e      	str	r6, [r5, #0]
    *controllerTable = &s_RstgenDrvInterface;
  14e602:	6423      	str	r3, [r4, #64]	; 0x40
    __asm__ volatile("cpsie i");
  14e604:	b662      	cpsie	i

    if (instance == NULL) {
        return false;
    }

    if (res_get_info_by_id(global_rst_res_idx,
  14e606:	491e      	ldr	r1, [pc, #120]	; (14e680 <hal_rstgen_creat_handle+0xe4>)
  14e608:	4648      	mov	r0, r9
  14e60a:	aa01      	add	r2, sp, #4
  14e60c:	f7ff ff5a 	bl	14e4c4 <res_get_info_by_id>
  14e610:	b1b0      	cbz	r0, 14e640 <hal_rstgen_creat_handle+0xa4>
        return false;
  14e612:	2000      	movs	r0, #0

    mutex_init(&instance->rstgenMutex);

    *handle = instance;
    return true;
}
  14e614:	b003      	add	sp, #12
  14e616:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    if (g_RstgenInstance.occupied != 1) {
  14e61a:	f245 74c4 	movw	r4, #22468	; 0x57c4
    *lock = 1;
  14e61e:	2601      	movs	r6, #1
  14e620:	f2c0 0416 	movt	r4, #22
  14e624:	f894 3020 	ldrb.w	r3, [r4, #32]
  14e628:	42b3      	cmp	r3, r6
    *lock = 0;
  14e62a:	bf04      	itt	eq
  14e62c:	2300      	moveq	r3, #0
  14e62e:	602b      	streq	r3, [r5, #0]
  14e630:	d10e      	bne.n	14e650 <hal_rstgen_creat_handle+0xb4>
    if (res_get_info_by_id(global_rst_res_idx,
  14e632:	4648      	mov	r0, r9
  14e634:	aa01      	add	r2, sp, #4
  14e636:	4912      	ldr	r1, [pc, #72]	; (14e680 <hal_rstgen_creat_handle+0xe4>)
  14e638:	f7ff ff44 	bl	14e4c4 <res_get_info_by_id>
  14e63c:	2800      	cmp	r0, #0
  14e63e:	d1e8      	bne.n	14e612 <hal_rstgen_creat_handle+0x76>
    mutex_init(&instance->rstgenMutex);
  14e640:	4810      	ldr	r0, [pc, #64]	; (14e684 <hal_rstgen_creat_handle+0xe8>)
  14e642:	f000 fd89 	bl	14f158 <mutex_init>
    *handle = instance;
  14e646:	603c      	str	r4, [r7, #0]
    return true;
  14e648:	2001      	movs	r0, #1
}
  14e64a:	b003      	add	sp, #12
  14e64c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        memset(&g_RstgenInstance, 0, sizeof(rstgen_instance_t));
  14e650:	2240      	movs	r2, #64	; 0x40
  14e652:	2100      	movs	r1, #0
  14e654:	4620      	mov	r0, r4
  14e656:	f004 ed12 	blx	15307c <memset>
    *controllerTable = &s_RstgenDrvInterface;
  14e65a:	f647 43e8 	movw	r3, #31976	; 0x7ce8
  14e65e:	2200      	movs	r2, #0
  14e660:	f2c0 0315 	movt	r3, #21
            g_RstgenInstance.occupied = 1;
  14e664:	f884 6020 	strb.w	r6, [r4, #32]
            g_RstgenInstance.rstgen_res[1].glb_self_rst_en =
  14e668:	f884 6033 	strb.w	r6, [r4, #51]	; 0x33
            g_RstgenInstance.rstgen_res[1].glb_sem_rst_en =
  14e66c:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
            g_RstgenInstance.rstgen_res[1].glb_dbg_rst_en =
  14e670:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
    *controllerTable = &s_RstgenDrvInterface;
  14e674:	6423      	str	r3, [r4, #64]	; 0x40
  14e676:	602a      	str	r2, [r5, #0]
  14e678:	e7db      	b.n	14e632 <hal_rstgen_creat_handle+0x96>
  14e67a:	602e      	str	r6, [r5, #0]
  14e67c:	e7c2      	b.n	14e604 <hal_rstgen_creat_handle+0x68>
  14e67e:	bf00      	nop
  14e680:	001657e8 	.word	0x001657e8
  14e684:	001657c8 	.word	0x001657c8

0014e688 <hal_rstgen_release_handle>:
//*****************************************************************************
bool hal_rstgen_release_handle(void *handle)
{
    rstgen_instance_t *instance = NULL;

    if (handle == NULL) {
  14e688:	b148      	cbz	r0, 14e69e <hal_rstgen_release_handle+0x16>
{
  14e68a:	b508      	push	{r3, r14}
                handle);
        return false;
    }

    instance = (rstgen_instance_t *)handle;
    instance->occupied = 0;
  14e68c:	2200      	movs	r2, #0
  14e68e:	4603      	mov	r3, r0
    mutex_destroy(&instance->rstgenMutex);
  14e690:	3004      	adds	r0, #4
    instance->occupied = 0;
  14e692:	f883 2020 	strb.w	r2, [r3, #32]
    mutex_destroy(&instance->rstgenMutex);
  14e696:	f000 fd75 	bl	14f184 <mutex_destroy>
    return true;
  14e69a:	2001      	movs	r0, #1
}
  14e69c:	bd08      	pop	{r3, r15}
  14e69e:	4770      	bx	r14

0014e6a0 <hal_rstgen_core_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_core_reset(void *handle, uint32_t res_glb_idx)
{
  14e6a0:	b510      	push	{r4, r14}
  14e6a2:	4604      	mov	r4, r0
  14e6a4:	b082      	sub	sp, #8
    paddr_t phy_addr;
    int32_t core_idx;
    vaddr_t base;
    bool ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &core_idx)) {
  14e6a6:	4608      	mov	r0, r1
  14e6a8:	aa01      	add	r2, sp, #4
  14e6aa:	4669      	mov	r1, r13
  14e6ac:	f7ff ff0a 	bl	14e4c4 <res_get_info_by_id>
  14e6b0:	b948      	cbnz	r0, 14e6c6 <hal_rstgen_core_reset+0x26>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if ((core_idx > 0) && instance->controllerTable->core_reset) {
  14e6b2:	9901      	ldr	r1, [sp, #4]
  14e6b4:	2900      	cmp	r1, #0
  14e6b6:	dd04      	ble.n	14e6c2 <hal_rstgen_core_reset+0x22>
  14e6b8:	6c23      	ldr	r3, [r4, #64]	; 0x40
  14e6ba:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  14e6bc:	b133      	cbz	r3, 14e6cc <hal_rstgen_core_reset+0x2c>
        ret = instance->controllerTable->core_reset(
  14e6be:	9800      	ldr	r0, [sp, #0]
  14e6c0:	4798      	blx	r3
                  (vaddr_t)base, (uint32_t)core_idx);
    }

    return ret;
}
  14e6c2:	b002      	add	sp, #8
  14e6c4:	bd10      	pop	{r4, r15}
        return ret;
  14e6c6:	2000      	movs	r0, #0
}
  14e6c8:	b002      	add	sp, #8
  14e6ca:	bd10      	pop	{r4, r15}
        return ret;
  14e6cc:	4618      	mov	r0, r3
  14e6ce:	e7f8      	b.n	14e6c2 <hal_rstgen_core_reset+0x22>

0014e6d0 <hal_rstgen_module_reset>:
//!
//! \return bool status
//
//*****************************************************************************
bool hal_rstgen_module_reset(void *handle, uint32_t res_glb_idx)
{
  14e6d0:	b530      	push	{r4, r5, r14}
  14e6d2:	4604      	mov	r4, r0
  14e6d4:	b083      	sub	sp, #12
    paddr_t     phy_addr;
    int32_t     module_idx;
    vaddr_t     base;
    bool        ret = false;

    if (res_get_info_by_id(res_glb_idx, &phy_addr, &module_idx)) {
  14e6d6:	4608      	mov	r0, r1
  14e6d8:	aa01      	add	r2, sp, #4
  14e6da:	4669      	mov	r1, r13
  14e6dc:	f7ff fef2 	bl	14e4c4 <res_get_info_by_id>
  14e6e0:	b988      	cbnz	r0, 14e706 <hal_rstgen_module_reset+0x36>
    }

    instance = (rstgen_instance_t *)handle;
    base = (vaddr_t)_ioaddr(phy_addr);

    if (module_idx > 0 && instance->controllerTable->module_ctl) {
  14e6e2:	9901      	ldr	r1, [sp, #4]
  14e6e4:	2900      	cmp	r1, #0
  14e6e6:	dd0c      	ble.n	14e702 <hal_rstgen_module_reset+0x32>
  14e6e8:	6c23      	ldr	r3, [r4, #64]	; 0x40
  14e6ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  14e6ec:	b173      	cbz	r3, 14e70c <hal_rstgen_module_reset+0x3c>
    base = (vaddr_t)_ioaddr(phy_addr);
  14e6ee:	9d00      	ldr	r5, [sp, #0]
        ret = instance->controllerTable->module_ctl(
  14e6f0:	4602      	mov	r2, r0
  14e6f2:	4628      	mov	r0, r5
  14e6f4:	4798      	blx	r3
                  base, (uint32_t)module_idx, false);
        ret = instance->controllerTable->module_ctl(
  14e6f6:	6c23      	ldr	r3, [r4, #64]	; 0x40
  14e6f8:	4628      	mov	r0, r5
  14e6fa:	2201      	movs	r2, #1
  14e6fc:	9901      	ldr	r1, [sp, #4]
  14e6fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  14e700:	4798      	blx	r3
                  base, (uint32_t)module_idx, true);
    }

    return ret;
}
  14e702:	b003      	add	sp, #12
  14e704:	bd30      	pop	{r4, r5, r15}
        return ret;
  14e706:	2000      	movs	r0, #0
}
  14e708:	b003      	add	sp, #12
  14e70a:	bd30      	pop	{r4, r5, r15}
        return ret;
  14e70c:	4618      	mov	r0, r3
  14e70e:	e7f8      	b.n	14e702 <hal_rstgen_module_reset+0x32>

0014e710 <hal_scr_create_handle>:

    return (scr_handle_t)0;
    #else
    return (scr_handle_t)scr_signal;
    #endif
}
  14e710:	4770      	bx	r14
  14e712:	bf00      	nop

0014e714 <hal_scr_delete_handle>:

void hal_scr_delete_handle(scr_handle_t handle)
{
    ASSERT(handle);
  14e714:	ea50 0301 	orrs.w	r3, r0, r1
  14e718:	d000      	beq.n	14e71c <hal_scr_delete_handle+0x8>
  14e71a:	4770      	bx	r14
  14e71c:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14e720:	f647 5224 	movw	r2, #32036	; 0x7d24
{
  14e724:	b500      	push	{r14}
    ASSERT(handle);
  14e726:	f2c0 0315 	movt	r3, #21
  14e72a:	f644 316c 	movw	r1, #19308	; 0x4b6c
{
  14e72e:	b083      	sub	sp, #12
  14e730:	4670      	mov	r0, r14
    ASSERT(handle);
  14e732:	f2c0 0215 	movt	r2, #21
  14e736:	9300      	str	r3, [sp, #0]
  14e738:	f2c0 0115 	movt	r1, #21
  14e73c:	2357      	movs	r3, #87	; 0x57
  14e73e:	f004 fab9 	bl	152cb4 <_panic>
  14e742:	bf00      	nop

0014e744 <hal_scr_get>:
}

uint32_t hal_scr_get(scr_handle_t handle)
{
    ASSERT(handle);
  14e744:	ea50 0301 	orrs.w	r3, r0, r1
  14e748:	d001      	beq.n	14e74e <hal_scr_get+0xa>
    return scr_get((scr_signal_t)handle);
  14e74a:	f7fa bb5d 	b.w	148e08 <scr_get>
    ASSERT(handle);
  14e74e:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14e752:	f647 5224 	movw	r2, #32036	; 0x7d24
{
  14e756:	b500      	push	{r14}
    ASSERT(handle);
  14e758:	f2c0 0315 	movt	r3, #21
  14e75c:	f644 316c 	movw	r1, #19308	; 0x4b6c
{
  14e760:	b083      	sub	sp, #12
  14e762:	4670      	mov	r0, r14
    ASSERT(handle);
  14e764:	f2c0 0215 	movt	r2, #21
  14e768:	9300      	str	r3, [sp, #0]
  14e76a:	f2c0 0115 	movt	r1, #21
  14e76e:	235c      	movs	r3, #92	; 0x5c
  14e770:	f004 faa0 	bl	152cb4 <_panic>

0014e774 <hal_scr_set>:
}

bool hal_scr_set(scr_handle_t handle, uint32_t value)
{
    ASSERT(handle);
  14e774:	ea50 0301 	orrs.w	r3, r0, r1
  14e778:	d001      	beq.n	14e77e <hal_scr_set+0xa>
    return scr_set((scr_signal_t)handle, value);
  14e77a:	f7fa bbdb 	b.w	148f34 <scr_set>
    ASSERT(handle);
  14e77e:	f644 33a4 	movw	r3, #19364	; 0x4ba4
  14e782:	f647 5224 	movw	r2, #32036	; 0x7d24
{
  14e786:	b500      	push	{r14}
    ASSERT(handle);
  14e788:	f2c0 0315 	movt	r3, #21
  14e78c:	f644 316c 	movw	r1, #19308	; 0x4b6c
{
  14e790:	b083      	sub	sp, #12
  14e792:	4670      	mov	r0, r14
    ASSERT(handle);
  14e794:	f2c0 0215 	movt	r2, #21
  14e798:	9300      	str	r3, [sp, #0]
  14e79a:	f2c0 0115 	movt	r1, #21
  14e79e:	2362      	movs	r3, #98	; 0x62
  14e7a0:	f004 fa88 	bl	152cb4 <_panic>

0014e7a4 <hal_timer_func_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_timer_func_irq_handle(void *arg)
{
    timer_instance_t *instance = (timer_instance_t *)arg;

    if (instance == NULL)
  14e7a4:	b120      	cbz	r0, 14e7b0 <hal_timer_func_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return timer_drv_func_irq_handle(instance->timer,
  14e7a6:	f100 0118 	add.w	r1, r0, #24
  14e7aa:	6940      	ldr	r0, [r0, #20]
  14e7ac:	f7fa bce8 	b.w	149180 <timer_drv_func_irq_handle>
                                     &(instance->drv_context));
}
  14e7b0:	4770      	bx	r14
  14e7b2:	bf00      	nop

0014e7b4 <hal_timer_ovf_irq_handle>:
    if (instance == NULL)
  14e7b4:	b120      	cbz	r0, 14e7c0 <hal_timer_ovf_irq_handle+0xc>
    return timer_drv_ovf_irq_handle(instance->timer, &(instance->drv_context));
  14e7b6:	f100 0118 	add.w	r1, r0, #24
  14e7ba:	6940      	ldr	r0, [r0, #20]
  14e7bc:	f7fa bcb2 	b.w	149124 <timer_drv_ovf_irq_handle>
}
  14e7c0:	4770      	bx	r14
  14e7c2:	bf00      	nop

0014e7c4 <hal_timer_creat_handle>:
{
  14e7c4:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  14e7c8:	f645 35cc 	movw	r5, #23500	; 0x5bcc
{
  14e7cc:	b082      	sub	sp, #8
  14e7ce:	4606      	mov	r6, r0
    if (timer_spin_lock != SPIN_LOCK_INITIAL_VALUE) {
  14e7d0:	f2c0 0516 	movt	r5, #22
  14e7d4:	682b      	ldr	r3, [r5, #0]
  14e7d6:	b10b      	cbz	r3, 14e7dc <hal_timer_creat_handle+0x18>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14e7d8:	2300      	movs	r3, #0
  14e7da:	602b      	str	r3, [r5, #0]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14e7dc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14e7e0:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  14e7e4:	d161      	bne.n	14e8aa <hal_timer_creat_handle+0xe6>
    __asm__ volatile("cpsid i");
  14e7e6:	b672      	cpsid	i
    *lock = 1;
  14e7e8:	2701      	movs	r7, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  14e7ea:	4608      	mov	r0, r1
  14e7ec:	4669      	mov	r1, r13
  14e7ee:	aa01      	add	r2, sp, #4
  14e7f0:	602f      	str	r7, [r5, #0]
  14e7f2:	f7ff fe67 	bl	14e4c4 <res_get_info_by_id>
  14e7f6:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14e7f8:	bfa8      	it	ge
  14e7fa:	46be      	movge	r14, r7
  14e7fc:	db67      	blt.n	14e8ce <hal_timer_creat_handle+0x10a>
  14e7fe:	f645 0c0c 	movw	r12, #22540	; 0x580c
            if (!g_timer_instance[index].occupied
  14e802:	f04f 0800 	mov.w	r8, #0
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  14e806:	9c00      	ldr	r4, [sp, #0]
  14e808:	f2c0 0c16 	movt	r12, #22
  14e80c:	4667      	mov	r7, r12
            if (!g_timer_instance[index].occupied
  14e80e:	f2cf 0818 	movt	r8, #61464	; 0xf018
                    && (hal_timer_addr_to_irq(phy_addr, &ovf_irq_num, &fun_irq_num))) {
  14e812:	2000      	movs	r0, #0
            if (!g_timer_instance[index].occupied
  14e814:	783b      	ldrb	r3, [r7, #0]
  14e816:	bbbb      	cbnz	r3, 14e888 <hal_timer_creat_handle+0xc4>
  14e818:	4a30      	ldr	r2, [pc, #192]	; (14e8dc <hal_timer_creat_handle+0x118>)
  14e81a:	4641      	mov	r1, r8
        if (timer_addr2irq_table[i].addr == addr) {
  14e81c:	428c      	cmp	r4, r1
  14e81e:	f102 020c 	add.w	r2, r2, #12
  14e822:	d007      	beq.n	14e834 <hal_timer_creat_handle+0x70>
    for (i = 0; i < DEFAULT_TIMER_MAX_NUM; i++) {
  14e824:	3301      	adds	r3, #1
  14e826:	2b08      	cmp	r3, #8
  14e828:	d02e      	beq.n	14e888 <hal_timer_creat_handle+0xc4>
  14e82a:	f852 1c0c 	ldr.w	r1, [r2, #-12]
  14e82e:	320c      	adds	r2, #12
        if (timer_addr2irq_table[i].addr == addr) {
  14e830:	428c      	cmp	r4, r1
  14e832:	d1f7      	bne.n	14e824 <hal_timer_creat_handle+0x60>
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  14e834:	f647 5248 	movw	r2, #32072	; 0x7d48
  14e838:	eb03 0343 	add.w	r3, r3, r3, lsl #1
                g_timer_instance[index].occupied = true;
  14e83c:	ea4f 1800 	mov.w	r8, r0, lsl #4
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  14e840:	f2c0 0215 	movt	r2, #21
                g_timer_instance[index].occupied = true;
  14e844:	eba8 0700 	sub.w	r7, r8, r0
  14e848:	f04f 0b01 	mov.w	r11, #1
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  14e84c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    *lock = 0;
  14e850:	2200      	movs	r2, #0
                g_timer_instance[index].occupied = true;
  14e852:	00ff      	lsls	r7, r7, #3
  14e854:	eb0c 0907 	add.w	r9, r12, r7
            *ovf_irq_num = timer_addr2irq_table[i].ovf_irq_num;
  14e858:	6859      	ldr	r1, [r3, #4]
  14e85a:	f8c9 1004 	str.w	r1, [r9, #4]
            *fun_irq_num = timer_addr2irq_table[i].fun_irq_num;
  14e85e:	6899      	ldr	r1, [r3, #8]
                g_timer_instance[index].timer = (sdrv_timer_t *)(phy_addr);
  14e860:	f8c9 4014 	str.w	r4, [r9, #20]
                g_timer_instance[index].fun_irq_num = fun_irq_num;
  14e864:	f8c9 1008 	str.w	r1, [r9, #8]
                g_timer_instance[index].occupied = true;
  14e868:	f80c b007 	strb.w	r11, [r12, r7]
  14e86c:	602a      	str	r2, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14e86e:	f1be 0f00 	cmp.w	r14, #0
  14e872:	d000      	beq.n	14e876 <hal_timer_creat_handle+0xb2>
    __asm__ volatile("cpsie i");
  14e874:	b662      	cpsie	i
                *instance = &g_timer_instance[index];
  14e876:	eba8 0300 	sub.w	r3, r8, r0
    return true;
  14e87a:	2001      	movs	r0, #1
                *instance = &g_timer_instance[index];
  14e87c:	eb0c 03c3 	add.w	r3, r12, r3, lsl #3
    *handle = instance;
  14e880:	6033      	str	r3, [r6, #0]
}
  14e882:	b002      	add	sp, #8
  14e884:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
        for (index = 0; index < DEFAULT_TIMER_MAX_NUM; index++) {
  14e888:	3001      	adds	r0, #1
  14e88a:	2808      	cmp	r0, #8
  14e88c:	f107 0778 	add.w	r7, r7, #120	; 0x78
  14e890:	d1c0      	bne.n	14e814 <hal_timer_creat_handle+0x50>
    *lock = 0;
  14e892:	2300      	movs	r3, #0
  14e894:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14e896:	f1be 0f00 	cmp.w	r14, #0
  14e89a:	d000      	beq.n	14e89e <hal_timer_creat_handle+0xda>
  14e89c:	b662      	cpsie	i
        *handle = NULL;
  14e89e:	2300      	movs	r3, #0
        return false;
  14e8a0:	4618      	mov	r0, r3
        *handle = NULL;
  14e8a2:	6033      	str	r3, [r6, #0]
}
  14e8a4:	b002      	add	sp, #8
  14e8a6:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
    *lock = 1;
  14e8aa:	2301      	movs	r3, #1
    if (! (res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0) ) {
  14e8ac:	4608      	mov	r0, r1
  14e8ae:	4669      	mov	r1, r13
  14e8b0:	aa01      	add	r2, sp, #4
  14e8b2:	602b      	str	r3, [r5, #0]
  14e8b4:	f7ff fe06 	bl	14e4c4 <res_get_info_by_id>
  14e8b8:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  14e8ba:	bfa8      	it	ge
  14e8bc:	f04f 0e00 	movge.w	r14, #0
  14e8c0:	da9d      	bge.n	14e7fe <hal_timer_creat_handle+0x3a>
    *lock = 0;
  14e8c2:	2300      	movs	r3, #0
  14e8c4:	602b      	str	r3, [r5, #0]
        *handle = NULL;
  14e8c6:	2300      	movs	r3, #0
        return false;
  14e8c8:	4618      	mov	r0, r3
        *handle = NULL;
  14e8ca:	6033      	str	r3, [r6, #0]
  14e8cc:	e7ea      	b.n	14e8a4 <hal_timer_creat_handle+0xe0>
  14e8ce:	602c      	str	r4, [r5, #0]
  14e8d0:	b662      	cpsie	i
  14e8d2:	2300      	movs	r3, #0
        return false;
  14e8d4:	4618      	mov	r0, r3
        *handle = NULL;
  14e8d6:	6033      	str	r3, [r6, #0]
  14e8d8:	e7e4      	b.n	14e8a4 <hal_timer_creat_handle+0xe0>
  14e8da:	bf00      	nop
  14e8dc:	00157d54 	.word	0x00157d54

0014e8e0 <hal_timer_global_init>:
{
  14e8e0:	b570      	push	{r4, r5, r6, r14}
  14e8e2:	460c      	mov	r4, r1
  14e8e4:	4605      	mov	r5, r0
    sdrv_timer_t *timer = instance->timer;
  14e8e6:	6946      	ldr	r6, [r0, #20]
    timer_drv_clk_init(timer, cfg->clk_sel, cfg->clk_div);
  14e8e8:	688a      	ldr	r2, [r1, #8]
  14e8ea:	4630      	mov	r0, r6
  14e8ec:	6809      	ldr	r1, [r1, #0]
  14e8ee:	f7fa fbed 	bl	1490cc <timer_drv_clk_init>
    timer_drv_cascade_set(timer, cfg->cascade);
  14e8f2:	4630      	mov	r0, r6
  14e8f4:	7b21      	ldrb	r1, [r4, #12]
  14e8f6:	f7fa fbdf 	bl	1490b8 <timer_drv_cascade_set>
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  14e8fa:	e9d4 2301 	ldrd	r2, r3, [r4, #4]
  14e8fe:	f644 51d3 	movw	r1, #19923	; 0x4dd3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  14e902:	f64d 6083 	movw	r0, #56963	; 0xde83
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  14e906:	3301      	adds	r3, #1
  14e908:	f2c1 0162 	movt	r1, #4194	; 0x1062
  14e90c:	fbb2 f3f3 	udiv	r3, r2, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  14e910:	f2c4 301b 	movt	r0, #17179	; 0x431b
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  14e914:	fba1 2103 	umull	r2, r1, r1, r3
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  14e918:	fba0 2303 	umull	r2, r3, r0, r3
    instance->cnt_per_ms = (cfg->clk_frq / (cfg->clk_div + 1)) / 1000;
  14e91c:	0989      	lsrs	r1, r1, #6
    instance->cnt_per_us = instance->cnt_per_ms / 1000;
  14e91e:	0c9b      	lsrs	r3, r3, #18
  14e920:	e9c5 1303 	strd	r1, r3, [r5, #12]
}
  14e924:	bd70      	pop	{r4, r5, r6, r15}
  14e926:	bf00      	nop

0014e928 <hal_timer_ovf_init>:
{
  14e928:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14e92a:	4615      	mov	r5, r2
  14e92c:	460e      	mov	r6, r1
    sdrv_timer_t *timer = instance->timer;
  14e92e:	6947      	ldr	r7, [r0, #20]
{
  14e930:	4604      	mov	r4, r0
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  14e932:	6892      	ldr	r2, [r2, #8]
  14e934:	4638      	mov	r0, r7
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  14e936:	4434      	add	r4, r6
    timer_drv_ovf_set(timer, (timer_drv_sub_t)sub_cntr, cfg->ovf_val);
  14e938:	f7fa fba6 	bl	149088 <timer_drv_ovf_set>
    timer_drv_cntr_set(timer, (timer_drv_sub_t)sub_cntr, cfg->cnt_val);
  14e93c:	4638      	mov	r0, r7
  14e93e:	4631      	mov	r1, r6
  14e940:	686a      	ldr	r2, [r5, #4]
  14e942:	f7fa fb61 	bl	149008 <timer_drv_cntr_set>
    instance->drv_context.periodic[sub_cntr] = cfg->periodic;
  14e946:	782b      	ldrb	r3, [r5, #0]
  14e948:	7623      	strb	r3, [r4, #24]
}
  14e94a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0014e94c <hal_timer_int_src_enable>:
    if (handle == NULL)
  14e94c:	b158      	cbz	r0, 14e966 <hal_timer_int_src_enable+0x1a>
{
  14e94e:	b538      	push	{r3, r4, r5, r14}
  14e950:	4604      	mov	r4, r0
  14e952:	460d      	mov	r5, r1
    timer_drv_int_sta_enable(instance->timer, int_src);
  14e954:	6940      	ldr	r0, [r0, #20]
  14e956:	f7fa fbc5 	bl	1490e4 <timer_drv_int_sta_enable>
    timer_drv_int_sig_enable(instance->timer, int_src);
  14e95a:	4629      	mov	r1, r5
  14e95c:	6960      	ldr	r0, [r4, #20]
}
  14e95e:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_enable(instance->timer, int_src);
  14e962:	f7fa bbcf 	b.w	149104 <timer_drv_int_sig_enable>
  14e966:	4770      	bx	r14

0014e968 <hal_timer_int_src_disable>:
    if (handle == NULL)
  14e968:	b158      	cbz	r0, 14e982 <hal_timer_int_src_disable+0x1a>
{
  14e96a:	b538      	push	{r3, r4, r5, r14}
  14e96c:	4604      	mov	r4, r0
  14e96e:	460d      	mov	r5, r1
    timer_drv_int_sta_disable(instance->timer, int_src);
  14e970:	6940      	ldr	r0, [r0, #20]
  14e972:	f7fa fbbf 	bl	1490f4 <timer_drv_int_sta_disable>
    timer_drv_int_sig_disable(instance->timer, int_src);
  14e976:	4629      	mov	r1, r5
  14e978:	6960      	ldr	r0, [r4, #20]
}
  14e97a:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    timer_drv_int_sig_disable(instance->timer, int_src);
  14e97e:	f7fa bbc9 	b.w	149114 <timer_drv_int_sig_disable>
  14e982:	4770      	bx	r14

0014e984 <hal_timer_int_cbk_register>:

void hal_timer_int_cbk_register(void *handle, hal_timer_int_src_t int_src,
                                hal_timer_int_cbk cbk)
{
    if (handle == NULL)
  14e984:	2800      	cmp	r0, #0
  14e986:	d047      	beq.n	14ea18 <hal_timer_int_cbk_register+0x94>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;

    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
            && (int_src <= HAL_TIMER_CNT_G1_OVF_INT_SRC)) {
  14e988:	f1a1 0308 	sub.w	r3, r1, #8
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  14e98c:	2b01      	cmp	r3, #1
{
  14e98e:	b510      	push	{r4, r14}
  14e990:	4604      	mov	r4, r0
    if ((int_src >= HAL_TIMER_CNT_G0_OVF_INT_SRC)
  14e992:	d917      	bls.n	14e9c4 <hal_timer_int_cbk_register+0x40>
                                 handle);
            unmask_interrupt(instance->ovf_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
             && (int_src <= HAL_TIMER_CNT_LD_OVF_INT_SRC)) {
  14e994:	f1a1 030a 	sub.w	r3, r1, #10
    else if ((int_src >= HAL_TIMER_CNT_LA_OVF_INT_SRC)
  14e998:	2b03      	cmp	r3, #3
  14e99a:	d90d      	bls.n	14e9b8 <hal_timer_int_cbk_register+0x34>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CPT_A_INT_SRC)
  14e99c:	2903      	cmp	r1, #3
  14e99e:	d934      	bls.n	14ea0a <hal_timer_int_cbk_register+0x86>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
             && (int_src <= HAL_TIMER_CMP_D_INT_SRC)) {
  14e9a0:	1f0b      	subs	r3, r1, #4
    else if ((int_src >= HAL_TIMER_CMP_A_INT_SRC)
  14e9a2:	2b03      	cmp	r3, #3
  14e9a4:	d91f      	bls.n	14e9e6 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_UNDERRUN_INT_SRC)) {
  14e9a6:	f1a1 0310 	sub.w	r3, r1, #16
    else if ((int_src >= HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC)
  14e9aa:	2b03      	cmp	r3, #3
  14e9ac:	d91b      	bls.n	14e9e6 <hal_timer_int_cbk_register+0x62>
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
             && (int_src <= HAL_TIMER_FIFO_D_OVERRUN_INT_SRC)) {
  14e9ae:	f1a1 0314 	sub.w	r3, r1, #20
    else if ((int_src >= HAL_TIMER_FIFO_A_OVERRUN_INT_SRC)
  14e9b2:	2b03      	cmp	r3, #3
  14e9b4:	d805      	bhi.n	14e9c2 <hal_timer_int_cbk_register+0x3e>
        instance->drv_context.local_overrun_cbk[int_src -
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  14e9b6:	3102      	adds	r1, #2

        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9b8:	68a0      	ldr	r0, [r4, #8]
                                                        HAL_TIMER_FIFO_A_OVERRUN_INT_SRC] = cbk;
  14e9ba:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9be:	1c43      	adds	r3, r0, #1
  14e9c0:	d117      	bne.n	14e9f2 <hal_timer_int_cbk_register+0x6e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
                                 handle);
            unmask_interrupt(instance->fun_irq_num);
        }
    }
}
  14e9c2:	bd10      	pop	{r4, r15}
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9c4:	6840      	ldr	r0, [r0, #4]
                                                     HAL_TIMER_CNT_G0_OVF_INT_SRC] = cbk;
  14e9c6:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->ovf_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9ca:	1c43      	adds	r3, r0, #1
  14e9cc:	d0f9      	beq.n	14e9c2 <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->ovf_irq_num, hal_timer_ovf_irq_handle,
  14e9ce:	f24e 71b5 	movw	r1, #59317	; 0xe7b5
  14e9d2:	4622      	mov	r2, r4
  14e9d4:	f2c0 0114 	movt	r1, #20
  14e9d8:	f7f1 fe84 	bl	1406e4 <register_int_handler>
            unmask_interrupt(instance->ovf_irq_num);
  14e9dc:	6860      	ldr	r0, [r4, #4]
}
  14e9de:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->ovf_irq_num);
  14e9e2:	f7f1 bed1 	b.w	140788 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9e6:	68a0      	ldr	r0, [r4, #8]
                        HAL_TIMER_FIFO_A_UNDERRUN_INT_SRC] = cbk;
  14e9e8:	310a      	adds	r1, #10
  14e9ea:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14e9ee:	1c42      	adds	r2, r0, #1
  14e9f0:	d0e7      	beq.n	14e9c2 <hal_timer_int_cbk_register+0x3e>
            register_int_handler(instance->fun_irq_num, hal_timer_func_irq_handle,
  14e9f2:	f24e 71a5 	movw	r1, #59301	; 0xe7a5
  14e9f6:	4622      	mov	r2, r4
  14e9f8:	f2c0 0114 	movt	r1, #20
  14e9fc:	f7f1 fe72 	bl	1406e4 <register_int_handler>
            unmask_interrupt(instance->fun_irq_num);
  14ea00:	68a0      	ldr	r0, [r4, #8]
}
  14ea02:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
            unmask_interrupt(instance->fun_irq_num);
  14ea06:	f7f1 bebf 	b.w	140788 <unmask_interrupt>
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14ea0a:	6880      	ldr	r0, [r0, #8]
        instance->drv_context.local_cpt_cbk[int_src - HAL_TIMER_CPT_A_INT_SRC] =
  14ea0c:	3112      	adds	r1, #18
  14ea0e:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
        if (instance->fun_irq_num != HAL_TIMER_INVALID_IRQ_NUM) {
  14ea12:	1c41      	adds	r1, r0, #1
  14ea14:	d1ed      	bne.n	14e9f2 <hal_timer_int_cbk_register+0x6e>
}
  14ea16:	bd10      	pop	{r4, r15}
  14ea18:	4770      	bx	r14
  14ea1a:	bf00      	nop

0014ea1c <hal_timer_int_sta_clear>:
 ** \param [in]    handle    Pointer to the hanld create
 ** \param [in]    offset    Offset of the interrupt status flag
 *****************************************************************************/
void hal_timer_int_sta_clear(void *handle, hal_timer_int_src_t int_src)
{
    if (handle == NULL)
  14ea1c:	b110      	cbz	r0, 14ea24 <hal_timer_int_sta_clear+0x8>
        return;

    timer_instance_t *instance = (timer_instance_t *)handle;
    timer_drv_int_sta_clear(instance->timer, int_src);
  14ea1e:	6940      	ldr	r0, [r0, #20]
  14ea20:	f7fa bcbe 	b.w	1493a0 <timer_drv_int_sta_clear>
}
  14ea24:	4770      	bx	r14
  14ea26:	bf00      	nop

0014ea28 <hal_timer_glb_cntr_get>:
{
    uint32_t g0_val, g1_val, g0_new;
    spin_lock_saved_state_t state;
    timer_instance_t *instance = (timer_instance_t *)handle;

    if (handle == NULL)
  14ea28:	b318      	cbz	r0, 14ea72 <hal_timer_glb_cntr_get+0x4a>
{
  14ea2a:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14ea2c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ea30:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14ea32:	bf48      	it	mi
  14ea34:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ea36:	d519      	bpl.n	14ea6c <hal_timer_glb_cntr_get+0x44>
  14ea38:	4604      	mov	r4, r0
        return 0;

    arch_interrupt_save(&state, SPIN_LOCK_FLAG_INTERRUPTS);

    g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  14ea3a:	2100      	movs	r1, #0
  14ea3c:	6940      	ldr	r0, [r0, #20]
  14ea3e:	f7fa fb0b 	bl	149058 <timer_drv_cntr_get>
  14ea42:	4605      	mov	r5, r0
  14ea44:	e000      	b.n	14ea48 <hal_timer_glb_cntr_get+0x20>
  14ea46:	4605      	mov	r5, r0
    do {
        g0_val = g0_new;
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  14ea48:	6960      	ldr	r0, [r4, #20]
  14ea4a:	2101      	movs	r1, #1
  14ea4c:	f7fa fb04 	bl	149058 <timer_drv_cntr_get>
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  14ea50:	2100      	movs	r1, #0
        g1_val = timer_drv_cntr_get(instance->timer, HAL_TIMER_G1);
  14ea52:	4606      	mov	r6, r0
        g0_new = timer_drv_cntr_get(instance->timer, HAL_TIMER_G0);
  14ea54:	6960      	ldr	r0, [r4, #20]
  14ea56:	f7fa faff 	bl	149058 <timer_drv_cntr_get>
    } while (g0_val > g0_new);
  14ea5a:	4285      	cmp	r5, r0
  14ea5c:	d8f3      	bhi.n	14ea46 <hal_timer_glb_cntr_get+0x1e>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14ea5e:	b107      	cbz	r7, 14ea62 <hal_timer_glb_cntr_get+0x3a>
    __asm__ volatile("cpsie i");
  14ea60:	b662      	cpsie	i

    arch_interrupt_restore(state, SPIN_LOCK_FLAG_INTERRUPTS);

    return ((uint64_t)g0_val | (((uint64_t)g1_val) << 32U));
  14ea62:	2300      	movs	r3, #0
  14ea64:	4631      	mov	r1, r6
  14ea66:	ea43 0005 	orr.w	r0, r3, r5
}
  14ea6a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
  14ea6c:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14ea6e:	2701      	movs	r7, #1
  14ea70:	e7e2      	b.n	14ea38 <hal_timer_glb_cntr_get+0x10>
        return 0;
  14ea72:	2000      	movs	r0, #0
  14ea74:	2100      	movs	r1, #0
}
  14ea76:	4770      	bx	r14

0014ea78 <hal_uart_irq_handle>:
 *****************************************************************************/
static enum handler_return hal_uart_irq_handle(void *arg)
{
    uart_instance_t *instance = (uart_instance_t *)arg;

    if (instance == NULL)
  14ea78:	b120      	cbz	r0, 14ea84 <hal_uart_irq_handle+0xc>
        return INT_NO_RESCHEDULE;

    return uart_drv_irq_handle(instance->uartc, &(instance->drv_context));
  14ea7a:	f100 0110 	add.w	r1, r0, #16
  14ea7e:	68c0      	ldr	r0, [r0, #12]
  14ea80:	f7fa bde2 	b.w	149648 <uart_drv_irq_handle>
}
  14ea84:	4770      	bx	r14
  14ea86:	bf00      	nop

0014ea88 <hal_uart_creat_handle>:
{
  14ea88:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  14ea8c:	4605      	mov	r5, r0
  14ea8e:	b083      	sub	sp, #12
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14ea90:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ea94:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  14ea98:	d16a      	bne.n	14eb70 <hal_uart_creat_handle+0xe8>
    __asm__ volatile("cpsid i");
  14ea9a:	b672      	cpsid	i
    *lock = 1;
  14ea9c:	f645 7710 	movw	r7, #24336	; 0x5f10
  14eaa0:	2601      	movs	r6, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  14eaa2:	4608      	mov	r0, r1
  14eaa4:	f2c0 0716 	movt	r7, #22
  14eaa8:	4669      	mov	r1, r13
  14eaaa:	aa01      	add	r2, sp, #4
  14eaac:	603e      	str	r6, [r7, #0]
  14eaae:	f7ff fd09 	bl	14e4c4 <res_get_info_by_id>
  14eab2:	2800      	cmp	r0, #0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14eab4:	bfa8      	it	ge
  14eab6:	46b0      	movge	r8, r6
  14eab8:	db6d      	blt.n	14eb96 <hal_uart_creat_handle+0x10e>
  14eaba:	f645 3ed0 	movw	r14, #23504	; 0x5bd0
            if (!g_uart_instance[index].occupied
  14eabe:	f04f 0900 	mov.w	r9, #0
  14eac2:	f647 50a8 	movw	r0, #32168	; 0x7da8
  14eac6:	f2c0 0e16 	movt	r14, #22
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  14eaca:	9e00      	ldr	r6, [sp, #0]
  14eacc:	4674      	mov	r4, r14
            if (!g_uart_instance[index].occupied
  14eace:	f2cf 090f 	movt	r9, #61455	; 0xf00f
                    && (hal_uart_addr_to_phy(phy_addr, &phy_num, &irq_num))) {
  14ead2:	f04f 0c00 	mov.w	r12, #0
  14ead6:	f2c0 0015 	movt	r0, #21
            if (!g_uart_instance[index].occupied
  14eada:	7822      	ldrb	r2, [r4, #0]
  14eadc:	bbaa      	cbnz	r2, 14eb4a <hal_uart_creat_handle+0xc2>
  14eade:	4649      	mov	r1, r9
  14eae0:	e004      	b.n	14eaec <hal_uart_creat_handle+0x64>
  14eae2:	461a      	mov	r2, r3
    for (i = 0; i < DEFAULT_UART_MAX_NUM; i++) {
  14eae4:	2b10      	cmp	r3, #16
  14eae6:	d030      	beq.n	14eb4a <hal_uart_creat_handle+0xc2>
  14eae8:	f850 1033 	ldr.w	r1, [r0, r3, lsl #3]
        if (uart_addr2irq_table[i].addr == addr) {
  14eaec:	428e      	cmp	r6, r1
  14eaee:	f102 0301 	add.w	r3, r2, #1
  14eaf2:	d1f6      	bne.n	14eae2 <hal_uart_creat_handle+0x5a>
            *irq_num = uart_addr2irq_table[i].irq_num;
  14eaf4:	f647 59a8 	movw	r9, #32168	; 0x7da8
                g_uart_instance[index].occupied = true;
  14eaf8:	ea4f 004c 	mov.w	r0, r12, lsl #1
  14eafc:	eb00 010c 	add.w	r1, r0, r12
  14eb00:	2401      	movs	r4, #1
            *irq_num = uart_addr2irq_table[i].irq_num;
  14eb02:	f2c0 0915 	movt	r9, #21
                g_uart_instance[index].occupied = true;
  14eb06:	eb0c 0181 	add.w	r1, r12, r1, lsl #2
            *phy_num = i + 1;
  14eb0a:	9301      	str	r3, [sp, #4]
            *irq_num = uart_addr2irq_table[i].irq_num;
  14eb0c:	eb09 02c2 	add.w	r2, r9, r2, lsl #3
                g_uart_instance[index].occupied = true;
  14eb10:	0089      	lsls	r1, r1, #2
  14eb12:	eb0e 0901 	add.w	r9, r14, r1
            *irq_num = uart_addr2irq_table[i].irq_num;
  14eb16:	6852      	ldr	r2, [r2, #4]
  14eb18:	f8c9 2008 	str.w	r2, [r9, #8]
    *lock = 0;
  14eb1c:	2200      	movs	r2, #0
                g_uart_instance[index].occupied = true;
  14eb1e:	f80e 4001 	strb.w	r4, [r14, r1]
                g_uart_instance[index].uartc = (DW_APB_UART_uart_TypeDef *)(phy_addr);
  14eb22:	f8c9 600c 	str.w	r6, [r9, #12]
                g_uart_instance[index].phy_num = phy_num;
  14eb26:	f8c9 3004 	str.w	r3, [r9, #4]
  14eb2a:	603a      	str	r2, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14eb2c:	f1b8 0f00 	cmp.w	r8, #0
  14eb30:	d000      	beq.n	14eb34 <hal_uart_creat_handle+0xac>
    __asm__ volatile("cpsie i");
  14eb32:	b662      	cpsie	i
                *instance = &g_uart_instance[index];
  14eb34:	eb00 030c 	add.w	r3, r0, r12
    return true;
  14eb38:	2001      	movs	r0, #1
                *instance = &g_uart_instance[index];
  14eb3a:	eb0c 0383 	add.w	r3, r12, r3, lsl #2
  14eb3e:	eb0e 0383 	add.w	r3, r14, r3, lsl #2
    *handle = instance;
  14eb42:	602b      	str	r3, [r5, #0]
}
  14eb44:	b003      	add	sp, #12
  14eb46:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        for (index = 0; index < DEFAULT_UART_MAX_NUM; index++) {
  14eb4a:	f10c 0c01 	add.w	r12, r12, #1
  14eb4e:	f1bc 0f10 	cmp.w	r12, #16
  14eb52:	f104 0434 	add.w	r4, r4, #52	; 0x34
  14eb56:	d1c0      	bne.n	14eada <hal_uart_creat_handle+0x52>
    *lock = 0;
  14eb58:	2300      	movs	r3, #0
  14eb5a:	603b      	str	r3, [r7, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14eb5c:	f1b8 0f00 	cmp.w	r8, #0
  14eb60:	d000      	beq.n	14eb64 <hal_uart_creat_handle+0xdc>
  14eb62:	b662      	cpsie	i
        *handle = NULL;
  14eb64:	2300      	movs	r3, #0
        return false;
  14eb66:	4618      	mov	r0, r3
        *handle = NULL;
  14eb68:	602b      	str	r3, [r5, #0]
}
  14eb6a:	b003      	add	sp, #12
  14eb6c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    *lock = 1;
  14eb70:	f645 7710 	movw	r7, #24336	; 0x5f10
  14eb74:	2301      	movs	r3, #1
    if (!(res_get_info_by_id(res_glb_idx, &phy_addr, &phy_num) < 0)) {
  14eb76:	4608      	mov	r0, r1
  14eb78:	f2c0 0716 	movt	r7, #22
  14eb7c:	4669      	mov	r1, r13
  14eb7e:	aa01      	add	r2, sp, #4
  14eb80:	603b      	str	r3, [r7, #0]
  14eb82:	f7ff fc9f 	bl	14e4c4 <res_get_info_by_id>
  14eb86:	2800      	cmp	r0, #0
    spin_lock_saved_state_t state = 0;
  14eb88:	bfa8      	it	ge
  14eb8a:	f04f 0800 	movge.w	r8, #0
  14eb8e:	da94      	bge.n	14eaba <hal_uart_creat_handle+0x32>
    *lock = 0;
  14eb90:	2300      	movs	r3, #0
  14eb92:	603b      	str	r3, [r7, #0]
  14eb94:	e7e6      	b.n	14eb64 <hal_uart_creat_handle+0xdc>
  14eb96:	603c      	str	r4, [r7, #0]
  14eb98:	b662      	cpsie	i
  14eb9a:	e7e3      	b.n	14eb64 <hal_uart_creat_handle+0xdc>

0014eb9c <hal_uart_init>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   cfg         pointer of the hal confuration
 *****************************************************************************/
void hal_uart_init(void *handle, hal_uart_cfg_t *cfg)
{
    if (handle == NULL)
  14eb9c:	b1f0      	cbz	r0, 14ebdc <hal_uart_init+0x40>
{
  14eb9e:	b530      	push	{r4, r5, r14}
  14eba0:	b08b      	sub	sp, #44	; 0x2c
    if ((hal_cfg == NULL) || (drv_cfg == NULL))
  14eba2:	b199      	cbz	r1, 14ebcc <hal_uart_init+0x30>
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  14eba4:	680d      	ldr	r5, [r1, #0]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  14eba6:	7d0a      	ldrb	r2, [r1, #20]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  14eba8:	684c      	ldr	r4, [r1, #4]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  14ebaa:	7e0b      	ldrb	r3, [r1, #24]
    drv_cfg->port_cfg.sclk = hal_cfg->port_cfg.sclk;
  14ebac:	9501      	str	r5, [sp, #4]
    drv_cfg->port_cfg.baud = hal_cfg->port_cfg.baud;
  14ebae:	9402      	str	r4, [sp, #8]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  14ebb0:	688d      	ldr	r5, [r1, #8]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  14ebb2:	68cc      	ldr	r4, [r1, #12]
    drv_cfg->port_cfg.data_bits = hal_cfg->port_cfg.data_bits;
  14ebb4:	9503      	str	r5, [sp, #12]
    drv_cfg->port_cfg.stop_bits = hal_cfg->port_cfg.stop_bits;
  14ebb6:	9404      	str	r4, [sp, #16]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  14ebb8:	690d      	ldr	r5, [r1, #16]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  14ebba:	e9d1 4107 	ldrd	r4, r1, [r1, #28]
    drv_cfg->port_cfg.parity = hal_cfg->port_cfg.parity;
  14ebbe:	9505      	str	r5, [sp, #20]
    drv_cfg->fifo_cfg.tx_trigger = hal_cfg->fifo_cfg.tx_trigger;
  14ebc0:	e9cd 4108 	strd	r4, r1, [r13, #32]
    drv_cfg->port_cfg.loopback_enable = hal_cfg->port_cfg.loopback_enable;
  14ebc4:	f88d 2018 	strb.w	r2, [r13, #24]
    drv_cfg->fifo_cfg.fifo_enable = hal_cfg->fifo_cfg.fifo_enable;
  14ebc8:	f88d 301c 	strb.w	r3, [r13, #28]
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_cfg_t drv_cfg;
    hal_uart_cfg_copy_to_drv(cfg, &drv_cfg);
    uart_drv_init(instance->uartc, &(instance->drv_context), &drv_cfg);
  14ebcc:	f100 0110 	add.w	r1, r0, #16
  14ebd0:	68c0      	ldr	r0, [r0, #12]
  14ebd2:	aa01      	add	r2, sp, #4
  14ebd4:	f7fa fbec 	bl	1493b0 <uart_drv_init>
}
  14ebd8:	b00b      	add	sp, #44	; 0x2c
  14ebda:	bd30      	pop	{r4, r5, r15}
  14ebdc:	4770      	bx	r14
  14ebde:	bf00      	nop

0014ebe0 <hal_uart_putc>:
 ** \param [in]   handle      pointer of the handle create
 ** \param [in]   data        Character to put
 *****************************************************************************/
void hal_uart_putc(void *handle, char data)
{
    if (handle == NULL)
  14ebe0:	b128      	cbz	r0, 14ebee <hal_uart_putc+0xe>
        uart_drv_rs485_driver_set(instance->uartc, true);
        uart_drv_rs485_receiver_set(instance->uartc, false);
    }

#endif
    uart_drv_putc(instance->uartc, &(instance->drv_context), data);
  14ebe2:	460a      	mov	r2, r1
  14ebe4:	f100 0110 	add.w	r1, r0, #16
  14ebe8:	68c0      	ldr	r0, [r0, #12]
  14ebea:	f7fa bcef 	b.w	1495cc <uart_drv_putc>
        uart_drv_rs485_driver_set(instance->uartc, false);
        uart_drv_rs485_receiver_set(instance->uartc, true);
    }

#endif
}
  14ebee:	4770      	bx	r14

0014ebf0 <hal_uart_int_cbk_register>:
 ** \param [in]   cbk
 *****************************************************************************/
void hal_uart_int_cbk_register(void *handle, hal_uart_int_src_t int_src,
                               hal_uart_int_callback cbk)
{
    if (handle == NULL)
  14ebf0:	b1a0      	cbz	r0, 14ec1c <hal_uart_int_cbk_register+0x2c>
{
  14ebf2:	b510      	push	{r4, r14}
  14ebf4:	4604      	mov	r4, r0
        return;

    uart_instance_t *instance = (uart_instance_t *)handle;
    uart_drv_int_cbk_register(&(instance->drv_context), int_src, cbk);
  14ebf6:	3010      	adds	r0, #16
  14ebf8:	f7fa fcf6 	bl	1495e8 <uart_drv_int_cbk_register>

    if (instance->irq_num != UART_HAL_INVALID_IRQ_NUM) {
  14ebfc:	68a0      	ldr	r0, [r4, #8]
  14ebfe:	1c43      	adds	r3, r0, #1
  14ec00:	d00b      	beq.n	14ec1a <hal_uart_int_cbk_register+0x2a>
        register_int_handler(instance->irq_num, hal_uart_irq_handle, handle);
  14ec02:	f64e 2179 	movw	r1, #60025	; 0xea79
  14ec06:	4622      	mov	r2, r4
  14ec08:	f2c0 0114 	movt	r1, #20
  14ec0c:	f7f1 fd6a 	bl	1406e4 <register_int_handler>
        unmask_interrupt(instance->irq_num);
  14ec10:	68a0      	ldr	r0, [r4, #8]
    }
}
  14ec12:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        unmask_interrupt(instance->irq_num);
  14ec16:	f7f1 bdb7 	b.w	140788 <unmask_interrupt>
}
  14ec1a:	bd10      	pop	{r4, r15}
  14ec1c:	4770      	bx	r14
  14ec1e:	bf00      	nop

0014ec20 <hal_uart_int_src_enable>:
    unmask_interrupt(instance->irq_num);
}

void hal_uart_int_src_enable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  14ec20:	b108      	cbz	r0, 14ec26 <hal_uart_int_src_enable+0x6>
        return;

    uart_drv_int_src_enable(handle, int_src);
  14ec22:	f7fa bced 	b.w	149600 <uart_drv_int_src_enable>
}
  14ec26:	4770      	bx	r14

0014ec28 <hal_uart_int_src_disable>:

void hal_uart_int_src_disable(void *handle, hal_uart_int_src_t int_src)
{
    if (handle == NULL)
  14ec28:	b108      	cbz	r0, 14ec2e <hal_uart_int_src_disable+0x6>
        return;

    uart_drv_int_src_disable(handle, int_src);
  14ec2a:	f7fa bcf9 	b.w	149620 <uart_drv_int_src_disable>
}
  14ec2e:	4770      	bx	r14

0014ec30 <hal_wdg_creat_handle>:
//!
//! \return watchdog handle
//
//*****************************************************************************
bool hal_wdg_creat_handle(void **handle,uint32_t wdg_res_glb_idx)
{
  14ec30:	b5f0      	push	{r4, r5, r6, r7, r14}
    wdg_instance_t  *wdgInstance = NULL;

    if(wdg_spin_lock !=SPIN_LOCK_INITIAL_VALUE){
  14ec32:	f246 25b4 	movw	r5, #25268	; 0x62b4
{
  14ec36:	b083      	sub	sp, #12
  14ec38:	4606      	mov	r6, r0
    if(wdg_spin_lock !=SPIN_LOCK_INITIAL_VALUE){
  14ec3a:	f2c0 0516 	movt	r5, #22
  14ec3e:	682b      	ldr	r3, [r5, #0]
  14ec40:	b10b      	cbz	r3, 14ec46 <hal_wdg_creat_handle+0x16>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  14ec42:	2300      	movs	r3, #0
  14ec44:	602b      	str	r3, [r5, #0]
    paddr_t phy_addr = 0;
  14ec46:	2700      	movs	r7, #0
    int32_t wdg_really_num = 0;
  14ec48:	aa02      	add	r2, sp, #8
    ret = res_get_info_by_id(wdg_res_glb_idx,&phy_addr,&wdg_really_num);
  14ec4a:	4608      	mov	r0, r1
  14ec4c:	4669      	mov	r1, r13
    int32_t wdg_really_num = 0;
  14ec4e:	f842 7d04 	str.w	r7, [r2, #-4]!
    paddr_t phy_addr = 0;
  14ec52:	9700      	str	r7, [sp, #0]
    ret = res_get_info_by_id(wdg_res_glb_idx,&phy_addr,&wdg_really_num);
  14ec54:	f7ff fc36 	bl	14e4c4 <res_get_info_by_id>
    if(ret == -1){
  14ec58:	b240      	sxtb	r0, r0
  14ec5a:	3001      	adds	r0, #1
  14ec5c:	d01d      	beq.n	14ec9a <hal_wdg_creat_handle+0x6a>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14ec5e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ec62:	061b      	lsls	r3, r3, #24
  14ec64:	d516      	bpl.n	14ec94 <hal_wdg_creat_handle+0x64>
  14ec66:	f645 7014 	movw	r0, #24340	; 0x5f14
    *lock = 1;
  14ec6a:	2101      	movs	r1, #1
  14ec6c:	2300      	movs	r3, #0
  14ec6e:	f2c0 0016 	movt	r0, #22
  14ec72:	6029      	str	r1, [r5, #0]
  14ec74:	4602      	mov	r2, r0
        if (g_WdgInstance[i].occupied != 1)
  14ec76:	f892 1060 	ldrb.w	r1, [r2, #96]	; 0x60
  14ec7a:	2901      	cmp	r1, #1
  14ec7c:	f102 0274 	add.w	r2, r2, #116	; 0x74
  14ec80:	d10e      	bne.n	14eca0 <hal_wdg_creat_handle+0x70>
  14ec82:	3301      	adds	r3, #1
    for (i=0; i < wdg_really_num_max; i++)
  14ec84:	2b08      	cmp	r3, #8
  14ec86:	d1f6      	bne.n	14ec76 <hal_wdg_creat_handle+0x46>
    *lock = 0;
  14ec88:	2000      	movs	r0, #0
  14ec8a:	6028      	str	r0, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14ec8c:	b12f      	cbz	r7, 14ec9a <hal_wdg_creat_handle+0x6a>
    __asm__ volatile("cpsie i");
  14ec8e:	b662      	cpsie	i
    mutex_init(&wdgInstance->wdgMutex);
#endif

    *handle = wdgInstance;
    return true;
}
  14ec90:	b003      	add	sp, #12
  14ec92:	bdf0      	pop	{r4, r5, r6, r7, r15}
    __asm__ volatile("cpsid i");
  14ec94:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14ec96:	2701      	movs	r7, #1
  14ec98:	e7e5      	b.n	14ec66 <hal_wdg_creat_handle+0x36>
        return false;
  14ec9a:	2000      	movs	r0, #0
}
  14ec9c:	b003      	add	sp, #12
  14ec9e:	bdf0      	pop	{r4, r5, r6, r7, r15}
            memset(buffer,0,sizeof(wdg_instance_t));
  14eca0:	2100      	movs	r1, #0
            uint8_t *buffer = (uint8_t *)&g_WdgInstance[i];
  14eca2:	ebc3 04c3 	rsb	r4, r3, r3, lsl #3
            memset(buffer,0,sizeof(wdg_instance_t));
  14eca6:	2274      	movs	r2, #116	; 0x74
            uint8_t *buffer = (uint8_t *)&g_WdgInstance[i];
  14eca8:	eb03 0384 	add.w	r3, r3, r4, lsl #2
  14ecac:	eb00 0483 	add.w	r4, r0, r3, lsl #2
            memset(buffer,0,sizeof(wdg_instance_t));
  14ecb0:	4620      	mov	r0, r4
  14ecb2:	f004 e9e4 	blx	15307c <memset>
    *controllerTable = &s_WdgDrvInterface;
  14ecb6:	f647 6384 	movw	r3, #32388	; 0x7e84
                g_WdgInstance[i].occupied = 1;
  14ecba:	2201      	movs	r2, #1
    *controllerTable = &s_WdgDrvInterface;
  14ecbc:	f2c0 0315 	movt	r3, #21
                g_WdgInstance[i].controllerTable->get_default_config(&(g_WdgInstance[i].wdg_cfg));
  14ecc0:	4620      	mov	r0, r4
    *controllerTable = &s_WdgDrvInterface;
  14ecc2:	65e3      	str	r3, [r4, #92]	; 0x5c
                g_WdgInstance[i].occupied = 1;
  14ecc4:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
                g_WdgInstance[i].controllerTable->get_default_config(&(g_WdgInstance[i].wdg_cfg));
  14ecc8:	f7fa fdf8 	bl	1498bc <wdg_get_default_config>
                g_WdgInstance[i].wdg_res.wdg_really_num = wdg_really_num;
  14eccc:	9a01      	ldr	r2, [sp, #4]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
  14ecce:	f647 6328 	movw	r3, #32296	; 0x7e28
    *lock = 0;
  14ecd2:	2100      	movs	r1, #0
  14ecd4:	f102 0c02 	add.w	r12, r2, #2
                g_WdgInstance[i].wdg_res.wdg_phy_addr = phy_addr;
  14ecd8:	9800      	ldr	r0, [sp, #0]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
  14ecda:	f2c0 0315 	movt	r3, #21
                g_WdgInstance[i].wdg_res.wdg_really_num = wdg_really_num;
  14ecde:	e9c4 2019 	strd	r2, r0, [r4, #100]	; 0x64
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
  14ece2:	eb03 03cc 	add.w	r3, r3, r12, lsl #3
  14ece6:	6029      	str	r1, [r5, #0]
  14ece8:	7a1a      	ldrb	r2, [r3, #8]
                g_WdgInstance[i].wdg_cfg.wdg_ext_reset_cfg.enableSysExtReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableExtReset;
  14ecea:	7a5b      	ldrb	r3, [r3, #9]
                g_WdgInstance[i].wdg_cfg.wdg_reset_cfg.enableSysReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableIntReset;
  14ecec:	f884 2022 	strb.w	r2, [r4, #34]	; 0x22
                g_WdgInstance[i].wdg_cfg.wdg_ext_reset_cfg.enableSysExtReset = g_watchdog_res_capability.res_cap[wdg_really_num-1].enableExtReset;
  14ecf0:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14ecf4:	b107      	cbz	r7, 14ecf8 <hal_wdg_creat_handle+0xc8>
    __asm__ volatile("cpsie i");
  14ecf6:	b662      	cpsie	i
    *handle = wdgInstance;
  14ecf8:	6034      	str	r4, [r6, #0]
    return true;
  14ecfa:	2001      	movs	r0, #1
}
  14ecfc:	b003      	add	sp, #12
  14ecfe:	bdf0      	pop	{r4, r5, r6, r7, r15}

0014ed00 <hal_wdg_release_handle>:
//*****************************************************************************
bool hal_wdg_release_handle(void *handle)
{
    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed00:	4603      	mov	r3, r0
  14ed02:	b120      	cbz	r0, 14ed0e <hal_wdg_release_handle+0xe>

    l_wdgInstance = (wdg_instance_t *)handle;
    l_wdgInstance->occupied = 0;
  14ed04:	2200      	movs	r2, #0

#if 0
    mutex_destroy(&l_wdgInstance->wdgMutex);
#endif

    return true;
  14ed06:	2001      	movs	r0, #1
    l_wdgInstance->occupied = 0;
  14ed08:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
    return true;
  14ed0c:	4770      	bx	r14
}
  14ed0e:	4770      	bx	r14

0014ed10 <hal_wdg_init>:
{
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;
    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed10:	b1d0      	cbz	r0, 14ed48 <hal_wdg_init+0x38>
{
  14ed12:	b538      	push	{r3, r4, r5, r14}

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited){
  14ed14:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
  14ed18:	b9a3      	cbnz	r3, 14ed44 <hal_wdg_init+0x34>
#if 0
    l_wdgInstance->wdg_cfg.wdg_ctrl_config.clockSource = wdg_app_cfg->clocksource;
    l_wdgInstance->wdg_cfg.wdg_ctrl_config.prescaler = wdg_app_cfg->divisor;
#endif

    if(l_wdgInstance->controllerTable->init){
  14ed1a:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
    l_wdgInstance->wdg_cfg.wdg_refresh_config.wdgModeSelect = wdg_app_cfg->workMode;
  14ed1c:	680a      	ldr	r2, [r1, #0]
  14ed1e:	7502      	strb	r2, [r0, #20]
    if(l_wdgInstance->controllerTable->init){
  14ed20:	699b      	ldr	r3, [r3, #24]
    l_wdgInstance->wdg_cfg.refresh_seq_delta = wdg_app_cfg->seqDeltaValue;
  14ed22:	68ca      	ldr	r2, [r1, #12]
    l_wdgInstance->wdg_cfg.refresh_wind_limit = wdg_app_cfg->windowLimitValue;
  14ed24:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    l_wdgInstance->wdg_cfg.refresh_seq_delta = wdg_app_cfg->seqDeltaValue;
  14ed28:	e9c0 4206 	strd	r4, r2, [r0, #24]
    l_wdgInstance->wdg_cfg.wdg_timeout = wdg_app_cfg->timeoutValue;
  14ed2c:	6105      	str	r5, [r0, #16]
    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);
  14ed2e:	6e82      	ldr	r2, [r0, #104]	; 0x68
    if(l_wdgInstance->controllerTable->init){
  14ed30:	b143      	cbz	r3, 14ed44 <hal_wdg_init+0x34>
  14ed32:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->init((wdg_reg_type_t *)wdg_base_addr,&(l_wdgInstance->wdg_cfg));
  14ed34:	4610      	mov	r0, r2
  14ed36:	4621      	mov	r1, r4
  14ed38:	4798      	blx	r3
    }

    if(!ret){
  14ed3a:	b118      	cbz	r0, 14ed44 <hal_wdg_init+0x34>
        LTRACEF("hal_wdg_init failed\n");
        return false;
    }

    l_wdgInstance->wdg_inited = true;
  14ed3c:	2301      	movs	r3, #1
  14ed3e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70

    return true;
}
  14ed42:	bd38      	pop	{r3, r4, r5, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed44:	2000      	movs	r0, #0
}
  14ed46:	bd38      	pop	{r3, r4, r5, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed48:	2000      	movs	r0, #0
}
  14ed4a:	4770      	bx	r14

0014ed4c <hal_wdg_deinit>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed4c:	b338      	cbz	r0, 14ed9e <hal_wdg_deinit+0x52>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited == false){
  14ed4e:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
  14ed52:	b323      	cbz	r3, 14ed9e <hal_wdg_deinit+0x52>
        LTRACEF("hal_wdg_init has not inited\n");
        return false;
    }

    if(l_wdgInstance->controllerTable->deinit){
  14ed54:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  14ed56:	69db      	ldr	r3, [r3, #28]
  14ed58:	b30b      	cbz	r3, 14ed9e <hal_wdg_deinit+0x52>
{
  14ed5a:	b510      	push	{r4, r14}
  14ed5c:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->deinit((wdg_reg_type_t *)wdg_base_addr);
  14ed5e:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14ed60:	4798      	blx	r3
    }

    if(!ret){
  14ed62:	b188      	cbz	r0, 14ed88 <hal_wdg_deinit+0x3c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14ed64:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ed68:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14ed6c:	d10e      	bne.n	14ed8c <hal_wdg_deinit+0x40>
    __asm__ volatile("cpsid i");
  14ed6e:	b672      	cpsid	i
    wdgInstance->occupied = 0;
  14ed70:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
    *lock = 0;
  14ed74:	f246 22b4 	movw	r2, #25268	; 0x62b4
  14ed78:	f2c0 0216 	movt	r2, #22
  14ed7c:	6013      	str	r3, [r2, #0]
    __asm__ volatile("cpsie i");
  14ed7e:	b662      	cpsie	i
    }

    //release wdg instance
    hal_wdg_release_instance(l_wdgInstance);

    l_wdgInstance->wdg_inited = false;
  14ed80:	2300      	movs	r3, #0
  14ed82:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70

    return true;
}
  14ed86:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed88:	2000      	movs	r0, #0
}
  14ed8a:	bd10      	pop	{r4, r15}
  14ed8c:	f246 23b4 	movw	r3, #25268	; 0x62b4
    wdgInstance->occupied = 0;
  14ed90:	2200      	movs	r2, #0
  14ed92:	f2c0 0316 	movt	r3, #22
  14ed96:	f884 2060 	strb.w	r2, [r4, #96]	; 0x60
  14ed9a:	601a      	str	r2, [r3, #0]
  14ed9c:	e7f0      	b.n	14ed80 <hal_wdg_deinit+0x34>
    HAL_WDG_ASSERT_PARAMETER(handle);
  14ed9e:	2000      	movs	r0, #0
}
  14eda0:	4770      	bx	r14
  14eda2:	bf00      	nop

0014eda4 <hal_wdg_enable>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14eda4:	b198      	cbz	r0, 14edce <hal_wdg_enable+0x2a>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if((l_wdgInstance->wdg_inited == false) || (l_wdgInstance->wdg_enabled == true)){
  14eda6:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
  14edaa:	b183      	cbz	r3, 14edce <hal_wdg_enable+0x2a>
  14edac:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
  14edb0:	b96b      	cbnz	r3, 14edce <hal_wdg_enable+0x2a>
        LTRACEF("hal_wdg_init has not inited or enable wdg_inited:%d  wdg_enabled:%d\n",l_wdgInstance->wdg_inited,l_wdgInstance->wdg_enabled);
        return false;
    }

    if(l_wdgInstance->controllerTable->enable){
  14edb2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  14edb4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  14edb6:	b153      	cbz	r3, 14edce <hal_wdg_enable+0x2a>
{
  14edb8:	b510      	push	{r4, r14}
  14edba:	4604      	mov	r4, r0
        ret = l_wdgInstance->controllerTable->enable((wdg_reg_type_t *)wdg_base_addr);
  14edbc:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14edbe:	4798      	blx	r3
    }

    if(!ret){
  14edc0:	b118      	cbz	r0, 14edca <hal_wdg_enable+0x26>
        LTRACEF("hal_wdg_enable failed\n");
        return false;
    }

    l_wdgInstance->wdg_enabled = true;
  14edc2:	2301      	movs	r3, #1
  14edc4:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71

    return true;
}
  14edc8:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
  14edca:	2000      	movs	r0, #0
}
  14edcc:	bd10      	pop	{r4, r15}
    HAL_WDG_ASSERT_PARAMETER(handle);
  14edce:	2000      	movs	r0, #0
}
  14edd0:	4770      	bx	r14
  14edd2:	bf00      	nop

0014edd4 <hal_wdg_enable_interrupts>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14edd4:	b138      	cbz	r0, 14ede6 <hal_wdg_enable_interrupts+0x12>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(l_wdgInstance->wdg_inited == false){
  14edd6:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
  14edda:	b123      	cbz	r3, 14ede6 <hal_wdg_enable_interrupts+0x12>
        LTRACEF("hal_wdg_enable_interrupts has not inited wdg_inited:%d\n",l_wdgInstance->wdg_inited);
        return false;
    }

    if(l_wdgInstance->controllerTable->enable_interrupts){
  14eddc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  14edde:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  14ede0:	b10b      	cbz	r3, 14ede6 <hal_wdg_enable_interrupts+0x12>
        ret = l_wdgInstance->controllerTable->enable_interrupts((wdg_reg_type_t *)wdg_base_addr);
  14ede2:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14ede4:	4718      	bx	r3
        LTRACEF("hal_wdg_enable_interrupts failed\n");
        return false;
    }

    return true;
}
  14ede6:	2000      	movs	r0, #0
  14ede8:	4770      	bx	r14
  14edea:	bf00      	nop

0014edec <hal_wdg_set_timeout>:
    bool ret = false;
    vaddr_t wdg_base_addr = 0x0;

    wdg_instance_t *l_wdgInstance = NULL;

    HAL_WDG_ASSERT_PARAMETER(handle);
  14edec:	b138      	cbz	r0, 14edfe <hal_wdg_set_timeout+0x12>

    l_wdgInstance = (wdg_instance_t *)handle;

    wdg_base_addr = (vaddr_t)_ioaddr(l_wdgInstance->wdg_res.wdg_phy_addr);

    if(!l_wdgInstance->wdg_inited){
  14edee:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
  14edf2:	b123      	cbz	r3, 14edfe <hal_wdg_set_timeout+0x12>
        LTRACEF("hal_wdg_set_timeout does not inited\n");
        return false;
    }

    if(l_wdgInstance->controllerTable->set_timeout){
  14edf4:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
  14edf6:	685b      	ldr	r3, [r3, #4]
  14edf8:	b10b      	cbz	r3, 14edfe <hal_wdg_set_timeout+0x12>
        ret = l_wdgInstance->controllerTable->set_timeout((wdg_reg_type_t *)wdg_base_addr,timeout_ms);
  14edfa:	6e80      	ldr	r0, [r0, #104]	; 0x68
  14edfc:	4718      	bx	r3
        LTRACEF("hal_wdg_set_timeout failed\n");
        return false;
    }

    return true;
}
  14edfe:	2000      	movs	r0, #0
  14ee00:	4770      	bx	r14
  14ee02:	bf00      	nop

0014ee04 <threadload>:

    return 0;
}

static enum handler_return threadload(struct timer *t, lk_time_t now, void *arg)
{
  14ee04:	e92d 4df0 	stmdb	r13!, {r4, r5, r6, r7, r8, r10, r11, r14}
    for (uint i = 0; i < SMP_MAX_CPUS; i++) {
        /* dont display time for inactiv cpus */
        if (!mp_is_cpu_active(i))
            continue;

        lk_bigtime_t idle_time = thread_stats[i].idle_time;
  14ee08:	f246 55c8 	movw	r5, #26056	; 0x65c8
{
  14ee0c:	b088      	sub	sp, #32
        lk_bigtime_t idle_time = thread_stats[i].idle_time;
  14ee0e:	f2c0 0516 	movt	r5, #22
  14ee12:	e9d5 3400 	ldrd	r3, r4, [r5]
  14ee16:	e9cd 3406 	strd	r3, r4, [r13, #24]
  14ee1a:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}

static inline enum handler_return mp_mbx_reschedule_irq(void) { return 0; }

// only one cpu exists in UP and if you're calling these functions, it's active...
static inline int mp_is_cpu_active(uint cpu) { return 1; }
static inline int mp_is_cpu_idle(uint cpu) { return (get_current_thread()->flags & THREAD_FLAG_IDLE) != 0; }
  14ee1e:	6a1b      	ldr	r3, [r3, #32]

        /* if the cpu is currently idle, add the time since it went idle up until now to the idle counter */
        bool is_idle = !!mp_is_cpu_idle(i);
        if (is_idle) {
  14ee20:	06db      	lsls	r3, r3, #27
  14ee22:	f100 808a 	bmi.w	14ef3a <threadload+0x136>
            idle_time += current_time_hires() - thread_stats[i].last_idle_timestamp;
        }

        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
  14ee26:	f246 28b8 	movw	r8, #25272	; 0x62b8
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
  14ee2a:	2300      	movs	r3, #0
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
  14ee2c:	e9dd 0106 	ldrd	r0, r1, [r13, #24]
  14ee30:	f2c0 0816 	movt	r8, #22
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
  14ee34:	f244 2240 	movw	r2, #16960	; 0x4240
        uint busypercent = (busy_time * 10000) / (1000000);

        printf("cpu %u LOAD: "
  14ee38:	f246 24c0 	movw	r4, #25280	; 0x62c0
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
  14ee3c:	f2c0 020f 	movt	r2, #15
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
  14ee40:	e9d8 6700 	ldrd	r6, r7, [r8]
        printf("cpu %u LOAD: "
  14ee44:	f2c0 0416 	movt	r4, #22
        lk_bigtime_t delta_time = idle_time - last_idle_time[i];
  14ee48:	1b80      	subs	r0, r0, r6
  14ee4a:	eb61 0107 	sbc.w	r1, r1, r7
        lk_bigtime_t busy_time = 1000000ULL - (delta_time > 1000000ULL ? 1000000ULL : delta_time);
  14ee4e:	428b      	cmp	r3, r1
  14ee50:	bf08      	it	eq
  14ee52:	4282      	cmpeq	r2, r0
  14ee54:	bf38      	it	cc
  14ee56:	4610      	movcc	r0, r2
  14ee58:	f244 2240 	movw	r2, #16960	; 0x4240
  14ee5c:	bf38      	it	cc
  14ee5e:	4619      	movcc	r1, r3
  14ee60:	f2c0 020f 	movt	r2, #15
  14ee64:	2300      	movs	r3, #0
  14ee66:	1a16      	subs	r6, r2, r0
  14ee68:	eb63 0701 	sbc.w	r7, r3, r1
        uint busypercent = (busy_time * 10000) / (1000000);
  14ee6c:	00b0      	lsls	r0, r6, #2
  14ee6e:	ea4f 0c87 	mov.w	r12, r7, lsl #2
  14ee72:	eb10 0a06 	adds.w	r10, r0, r6
  14ee76:	ea4c 7196 	orr.w	r1, r12, r6, lsr #30
  14ee7a:	eb41 0b07 	adc.w	r11, r1, r7
  14ee7e:	ea4f 0eca 	mov.w	r14, r10, lsl #3
  14ee82:	ea4f 0ccb 	mov.w	r12, r11, lsl #3
  14ee86:	ea4c 7c5a 	orr.w	r12, r12, r10, lsr #29
  14ee8a:	ebbe 0a06 	subs.w	r10, r14, r6
  14ee8e:	eb6c 0b07 	sbc.w	r11, r12, r7
  14ee92:	ea4f 1e0a 	mov.w	r14, r10, lsl #4
  14ee96:	ea4f 1c0b 	mov.w	r12, r11, lsl #4
  14ee9a:	eb1e 0006 	adds.w	r0, r14, r6
  14ee9e:	ea4c 7c1a 	orr.w	r12, r12, r10, lsr #28
  14eea2:	eb4c 0107 	adc.w	r1, r12, r7
  14eea6:	0107      	lsls	r7, r0, #4
  14eea8:	010e      	lsls	r6, r1, #4
  14eeaa:	ea46 7610 	orr.w	r6, r6, r0, lsr #28
  14eeae:	4631      	mov	r1, r6
  14eeb0:	4638      	mov	r0, r7
  14eeb2:	f005 fd3f 	bl	154934 <__aeabi_uldivmod>
        printf("cpu %u LOAD: "
  14eeb6:	f248 521f 	movw	r2, #34079	; 0x851f
  14eeba:	6aa7      	ldr	r7, [r4, #40]	; 0x28
  14eebc:	f2c5 12eb 	movt	r2, #20971	; 0x51eb
  14eec0:	6aae      	ldr	r6, [r5, #40]	; 0x28
  14eec2:	2100      	movs	r1, #0
  14eec4:	eba6 0e07 	sub.w	r14, r6, r7
  14eec8:	6a6f      	ldr	r7, [r5, #36]	; 0x24
  14eeca:	6a66      	ldr	r6, [r4, #36]	; 0x24
        uint busypercent = (busy_time * 10000) / (1000000);
  14eecc:	4684      	mov	r12, r0
        printf("cpu %u LOAD: "
  14eece:	f248 002c 	movw	r0, #32812	; 0x802c
  14eed2:	f2c0 0015 	movt	r0, #21
  14eed6:	fba2 320c 	umull	r3, r2, r2, r12
  14eeda:	0952      	lsrs	r2, r2, #5
  14eedc:	eb02 0382 	add.w	r3, r2, r2, lsl #2
  14eee0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  14eee4:	ebac 0383 	sub.w	r3, r12, r3, lsl #2
  14eee8:	eba7 0c06 	sub.w	r12, r7, r6
  14eeec:	6a26      	ldr	r6, [r4, #32]
  14eeee:	f8cd e010 	str.w	r14, [r13, #16]
  14eef2:	6a2f      	ldr	r7, [r5, #32]
  14eef4:	1bbe      	subs	r6, r7, r6
  14eef6:	e9d5 7e05 	ldrd	r7, r14, [r5, #20]
  14eefa:	69a5      	ldr	r5, [r4, #24]
  14eefc:	ebae 0e05 	sub.w	r14, r14, r5
  14ef00:	6965      	ldr	r5, [r4, #20]
  14ef02:	f8cd c00c 	str.w	r12, [r13, #12]
  14ef06:	e9cd e601 	strd	r14, r6, [r13, #4]
  14ef0a:	1b7d      	subs	r5, r7, r5
  14ef0c:	9500      	str	r5, [sp, #0]
#endif
               thread_stats[i].interrupts - old_stats[i].interrupts,
               thread_stats[i].timer_ints - old_stats[i].timer_ints,
               thread_stats[i].timers - old_stats[i].timers);

        old_stats[i] = thread_stats[i];
  14ef0e:	f246 55c8 	movw	r5, #26056	; 0x65c8
        printf("cpu %u LOAD: "
  14ef12:	f005 f8f1 	bl	1540f8 <_printf>
        last_idle_time[i] = idle_time;
  14ef16:	e9dd 2306 	ldrd	r2, r3, [r13, #24]
  14ef1a:	e9c8 2300 	strd	r2, r3, [r8]
        old_stats[i] = thread_stats[i];
  14ef1e:	f2c0 0516 	movt	r5, #22
  14ef22:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  14ef24:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14ef26:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  14ef28:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  14ef2a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
  14ef2e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    }

    return INT_NO_RESCHEDULE;
}
  14ef32:	2000      	movs	r0, #0
  14ef34:	b008      	add	sp, #32
  14ef36:	e8bd 8df0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r10, r11, r15}
            idle_time += current_time_hires() - thread_stats[i].last_idle_timestamp;
  14ef3a:	f7f1 fd03 	bl	140944 <current_time_hires>
  14ef3e:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
  14ef42:	e9dd ab06 	ldrd	r10, r11, [r13, #24]
  14ef46:	ebba 0a02 	subs.w	r10, r10, r2
  14ef4a:	eb6b 0b03 	sbc.w	r11, r11, r3
  14ef4e:	eb1a 0300 	adds.w	r3, r10, r0
  14ef52:	eb4b 0401 	adc.w	r4, r11, r1
  14ef56:	e9cd 3406 	strd	r3, r4, [r13, #24]
  14ef5a:	e764      	b.n	14ee26 <threadload+0x22>

0014ef5c <cmd_threadstats>:
{
  14ef5c:	e92d 4818 	stmdb	r13!, {r3, r4, r11, r14}
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
  14ef60:	f246 54c8 	movw	r4, #26056	; 0x65c8
        printf("thread stats (cpu %d):\n", i);
  14ef64:	f647 7010 	movw	r0, #32528	; 0x7f10
  14ef68:	2100      	movs	r1, #0
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
  14ef6a:	f2c0 0416 	movt	r4, #22
        printf("thread stats (cpu %d):\n", i);
  14ef6e:	f2c0 0015 	movt	r0, #21
  14ef72:	f005 f8c1 	bl	1540f8 <_printf>
        printf("\ttotal idle time: %lld\n", thread_stats[i].idle_time);
  14ef76:	f647 7028 	movw	r0, #32552	; 0x7f28
  14ef7a:	e9d4 2300 	ldrd	r2, r3, [r4]
  14ef7e:	f2c0 0015 	movt	r0, #21
  14ef82:	f005 f8b9 	bl	1540f8 <_printf>
        printf("\ttotal busy time: %lld\n", current_time_hires() - thread_stats[i].idle_time);
  14ef86:	f7f1 fcdd 	bl	140944 <current_time_hires>
  14ef8a:	e9d4 bc00 	ldrd	r11, r12, [r4]
  14ef8e:	ebb0 020b 	subs.w	r2, r0, r11
  14ef92:	f647 7040 	movw	r0, #32576	; 0x7f40
  14ef96:	eb61 030c 	sbc.w	r3, r1, r12
  14ef9a:	f2c0 0015 	movt	r0, #21
  14ef9e:	f005 f8ab 	bl	1540f8 <_printf>
        printf("\treschedules: %lu\n", thread_stats[i].reschedules);
  14efa2:	6921      	ldr	r1, [r4, #16]
  14efa4:	f647 7058 	movw	r0, #32600	; 0x7f58
  14efa8:	f2c0 0015 	movt	r0, #21
  14efac:	f005 f8a4 	bl	1540f8 <_printf>
        printf("\tcontext_switches: %lu\n", thread_stats[i].context_switches);
  14efb0:	6961      	ldr	r1, [r4, #20]
  14efb2:	f647 706c 	movw	r0, #32620	; 0x7f6c
  14efb6:	f2c0 0015 	movt	r0, #21
  14efba:	f005 f89d 	bl	1540f8 <_printf>
        printf("\tpreempts: %lu\n", thread_stats[i].preempts);
  14efbe:	69a1      	ldr	r1, [r4, #24]
  14efc0:	f647 7084 	movw	r0, #32644	; 0x7f84
  14efc4:	f2c0 0015 	movt	r0, #21
  14efc8:	f005 f896 	bl	1540f8 <_printf>
        printf("\tyields: %lu\n", thread_stats[i].yields);
  14efcc:	69e1      	ldr	r1, [r4, #28]
  14efce:	f647 7094 	movw	r0, #32660	; 0x7f94
  14efd2:	f2c0 0015 	movt	r0, #21
  14efd6:	f005 f88f 	bl	1540f8 <_printf>
        printf("\tinterrupts: %lu\n", thread_stats[i].interrupts);
  14efda:	6a21      	ldr	r1, [r4, #32]
  14efdc:	f647 70a4 	movw	r0, #32676	; 0x7fa4
  14efe0:	f2c0 0015 	movt	r0, #21
  14efe4:	f005 f888 	bl	1540f8 <_printf>
        printf("\ttimer interrupts: %lu\n", thread_stats[i].timer_ints);
  14efe8:	6a61      	ldr	r1, [r4, #36]	; 0x24
  14efea:	f647 70b8 	movw	r0, #32696	; 0x7fb8
  14efee:	f2c0 0015 	movt	r0, #21
  14eff2:	f005 f881 	bl	1540f8 <_printf>
        printf("\ttimers: %lu\n", thread_stats[i].timers);
  14eff6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  14eff8:	f647 70d0 	movw	r0, #32720	; 0x7fd0
  14effc:	f2c0 0015 	movt	r0, #21
  14f000:	f005 f87a 	bl	1540f8 <_printf>
}
  14f004:	2000      	movs	r0, #0
  14f006:	e8bd 8818 	ldmia.w	r13!, {r3, r4, r11, r15}
  14f00a:	bf00      	nop

0014f00c <cmd_threadload>:

static int cmd_threadload(int argc, const cmd_args *argv)
{
  14f00c:	b538      	push	{r3, r4, r5, r14}
    static bool showthreadload = false;
    static timer_t tltimer;

    if (showthreadload == false) {
        // start the display
        timer_initialize(&tltimer);
  14f00e:	f246 20f4 	movw	r0, #25332	; 0x62f4
    if (showthreadload == false) {
  14f012:	f246 24f0 	movw	r4, #25328	; 0x62f0
  14f016:	f2c0 0416 	movt	r4, #22
  14f01a:	7825      	ldrb	r5, [r4, #0]
        timer_initialize(&tltimer);
  14f01c:	f2c0 0016 	movt	r0, #22
    if (showthreadload == false) {
  14f020:	b12d      	cbz	r5, 14f02e <cmd_threadload+0x22>
        timer_set_periodic(&tltimer, 1000, &threadload, NULL);
        showthreadload = true;
    } else {
        timer_cancel(&tltimer);
  14f022:	f001 f845 	bl	1500b0 <timer_cancel>
        showthreadload = false;
  14f026:	2300      	movs	r3, #0
    }

    return 0;
}
  14f028:	2000      	movs	r0, #0
        showthreadload = false;
  14f02a:	7023      	strb	r3, [r4, #0]
}
  14f02c:	bd38      	pop	{r3, r4, r5, r15}
        timer_initialize(&tltimer);
  14f02e:	f001 f815 	bl	15005c <timer_initialize>
        timer_set_periodic(&tltimer, 1000, &threadload, NULL);
  14f032:	f64e 6205 	movw	r2, #60933	; 0xee05
  14f036:	f246 20f4 	movw	r0, #25332	; 0x62f4
  14f03a:	462b      	mov	r3, r5
  14f03c:	f2c0 0214 	movt	r2, #20
  14f040:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  14f044:	f2c0 0016 	movt	r0, #22
  14f048:	f001 f824 	bl	150094 <timer_set_periodic>
        showthreadload = true;
  14f04c:	2301      	movs	r3, #1
}
  14f04e:	2000      	movs	r0, #0
        showthreadload = true;
  14f050:	7023      	strb	r3, [r4, #0]
}
  14f052:	bd38      	pop	{r3, r4, r5, r15}

0014f054 <event_init>:
 * @param e        Event object to initialize
 * @param initial  Initial value for "signaled" state
 * @param flags    0 or EVENT_FLAG_AUTOUNSIGNAL
 */
void event_init(event_t *e, bool initial, uint flags)
{
  14f054:	b470      	push	{r4, r5, r6}
    *e = (event_t)EVENT_INITIAL_VALUE(*e, initial, flags);
  14f056:	f646 6574 	movw	r5, #28276	; 0x6e74
  14f05a:	f646 1474 	movw	r4, #26996	; 0x6974
  14f05e:	f2c6 5576 	movt	r5, #25974	; 0x6576
  14f062:	2600      	movs	r6, #0
  14f064:	f2c7 7461 	movt	r4, #30561	; 0x7761
  14f068:	6005      	str	r5, [r0, #0]
  14f06a:	f100 0310 	add.w	r3, r0, #16
  14f06e:	60c4      	str	r4, [r0, #12]
  14f070:	6186      	str	r6, [r0, #24]
  14f072:	7101      	strb	r1, [r0, #4]
  14f074:	6082      	str	r2, [r0, #8]
  14f076:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
  14f07a:	bc70      	pop	{r4, r5, r6}
  14f07c:	4770      	bx	r14
  14f07e:	bf00      	nop

0014f080 <event_wait_timeout>:
 *
 * @return  0 on success, ERR_TIMED_OUT on timeout,
 *         other values on other errors.
 */
status_t event_wait_timeout(event_t *e, lk_time_t timeout)
{
  14f080:	b538      	push	{r3, r4, r5, r14}
  14f082:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f084:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f088:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14f08a:	bf48      	it	mi
  14f08c:	2500      	movmi	r5, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f08e:	d401      	bmi.n	14f094 <event_wait_timeout+0x14>
    __asm__ volatile("cpsid i");
  14f090:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14f092:	2501      	movs	r5, #1
    *lock = 1;
  14f094:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f098:	2001      	movs	r0, #1
  14f09a:	f2c0 0416 	movt	r4, #22

    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    THREAD_LOCK(state);

    if (e->signaled) {
  14f09e:	7913      	ldrb	r3, [r2, #4]
  14f0a0:	6020      	str	r0, [r4, #0]
  14f0a2:	b16b      	cbz	r3, 14f0c0 <event_wait_timeout+0x40>
        /* signaled, we're going to fall through */
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
  14f0a4:	6893      	ldr	r3, [r2, #8]
  14f0a6:	4003      	ands	r3, r0
    status_t ret = NO_ERROR;
  14f0a8:	bf08      	it	eq
  14f0aa:	4618      	moveq	r0, r3
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
  14f0ac:	d104      	bne.n	14f0b8 <event_wait_timeout+0x38>
    *lock = 0;
  14f0ae:	2300      	movs	r3, #0
  14f0b0:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f0b2:	b105      	cbz	r5, 14f0b6 <event_wait_timeout+0x36>
    __asm__ volatile("cpsie i");
  14f0b4:	b662      	cpsie	i
    }

    THREAD_UNLOCK(state);

    return ret;
}
  14f0b6:	bd38      	pop	{r3, r4, r5, r15}
            e->signaled = false;
  14f0b8:	2300      	movs	r3, #0
    status_t ret = NO_ERROR;
  14f0ba:	4618      	mov	r0, r3
            e->signaled = false;
  14f0bc:	7113      	strb	r3, [r2, #4]
  14f0be:	e7f6      	b.n	14f0ae <event_wait_timeout+0x2e>
        ret = wait_queue_block(&e->wait, timeout);
  14f0c0:	f102 000c 	add.w	r0, r2, #12
  14f0c4:	f000 fc50 	bl	14f968 <wait_queue_block>
  14f0c8:	e7f1      	b.n	14f0ae <event_wait_timeout+0x2e>
  14f0ca:	bf00      	nop

0014f0cc <event_signal>:
 *                    queue.
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_signal(event_t *e, bool reschedule)
{
  14f0cc:	b570      	push	{r4, r5, r6, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f0ce:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f0d2:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14f0d6:	d118      	bne.n	14f10a <event_signal+0x3e>
    __asm__ volatile("cpsid i");
  14f0d8:	b672      	cpsid	i
    *lock = 1;
  14f0da:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f0de:	2601      	movs	r6, #1
  14f0e0:	f2c0 0416 	movt	r4, #22
    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    THREAD_LOCK(state);

    if (!e->signaled) {
  14f0e4:	7905      	ldrb	r5, [r0, #4]
  14f0e6:	6026      	str	r6, [r4, #0]
  14f0e8:	bb25      	cbnz	r5, 14f134 <event_signal+0x68>
        if (e->flags & EVENT_FLAG_AUTOUNSIGNAL) {
  14f0ea:	6882      	ldr	r2, [r0, #8]
  14f0ec:	4605      	mov	r5, r0
  14f0ee:	300c      	adds	r0, #12
  14f0f0:	f012 0201 	ands.w	r2, r2, #1
  14f0f4:	d116      	bne.n	14f124 <event_signal+0x58>
                 */
                e->signaled = true;
            }
        } else {
            /* release all threads and remain signaled */
            e->signaled = true;
  14f0f6:	2301      	movs	r3, #1
  14f0f8:	712b      	strb	r3, [r5, #4]
            wait_queue_wake_all(&e->wait, reschedule, NO_ERROR);
  14f0fa:	f000 fd31 	bl	14fb60 <wait_queue_wake_all>
    *lock = 0;
  14f0fe:	2300      	movs	r3, #0
  14f100:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f102:	b16e      	cbz	r6, 14f120 <event_signal+0x54>
    __asm__ volatile("cpsie i");
  14f104:	b662      	cpsie	i
    }

    THREAD_UNLOCK(state);

    return NO_ERROR;
}
  14f106:	2000      	movs	r0, #0
  14f108:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 1;
  14f10a:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f10e:	2301      	movs	r3, #1
  14f110:	f2c0 0416 	movt	r4, #22
    if (!e->signaled) {
  14f114:	7906      	ldrb	r6, [r0, #4]
  14f116:	6023      	str	r3, [r4, #0]
  14f118:	2e00      	cmp	r6, #0
  14f11a:	d0e6      	beq.n	14f0ea <event_signal+0x1e>
    *lock = 0;
  14f11c:	2300      	movs	r3, #0
  14f11e:	6023      	str	r3, [r4, #0]
}
  14f120:	2000      	movs	r0, #0
  14f122:	bd70      	pop	{r4, r5, r6, r15}
            if (wait_queue_wake_one(&e->wait, reschedule, NO_ERROR) <= 0) {
  14f124:	2200      	movs	r2, #0
  14f126:	f000 fcaf 	bl	14fa88 <wait_queue_wake_one>
  14f12a:	2800      	cmp	r0, #0
                e->signaled = true;
  14f12c:	bfdc      	itt	le
  14f12e:	2301      	movle	r3, #1
  14f130:	712b      	strble	r3, [r5, #4]
  14f132:	e7e4      	b.n	14f0fe <event_signal+0x32>
  14f134:	6023      	str	r3, [r4, #0]
  14f136:	e7e5      	b.n	14f104 <event_signal+0x38>

0014f138 <event_unsignal>:
 * @param e  Event object
 *
 * @return  Returns NO_ERROR on success.
 */
status_t event_unsignal(event_t *e)
{
  14f138:	4602      	mov	r2, r0
    DEBUG_ASSERT(e->magic == EVENT_MAGIC);

    e->signaled = false;
  14f13a:	2300      	movs	r3, #0

    return NO_ERROR;
}
  14f13c:	4618      	mov	r0, r3
    e->signaled = false;
  14f13e:	7113      	strb	r3, [r2, #4]
}
  14f140:	4770      	bx	r14
  14f142:	bf00      	nop

0014f144 <kernel_init>:
#include <kernel/timer.h>
#include <kernel/mp.h>
#include <kernel/port.h>

void kernel_init(void)
{
  14f144:	b508      	push	{r3, r14}
    dprintf(SPEW, "initializing mp\n");
    mp_init();

    // initialize the threading system
    dprintf(SPEW, "initializing threads\n");
    thread_init();
  14f146:	f000 fbef 	bl	14f928 <thread_init>

    // initialize kernel timers
    dprintf(SPEW, "initializing timers\n");
    timer_init();
  14f14a:	f001 f805 	bl	150158 <timer_init>

    // initialize ports
    dprintf(SPEW, "initializing ports\n");
    port_init();
}
  14f14e:	e8bd 4008 	ldmia.w	r13!, {r3, r14}
    port_init();
  14f152:	f001 b8f7 	b.w	150344 <port_init>
  14f156:	bf00      	nop

0014f158 <mutex_init>:

/**
 * @brief  Initialize a mutex_t
 */
void mutex_init(mutex_t *m)
{
  14f158:	b410      	push	{r4}
    *m = (mutex_t)MUTEX_INITIAL_VALUE(*m);
  14f15a:	f646 1174 	movw	r1, #26996	; 0x6974
  14f15e:	f247 4478 	movw	r4, #29816	; 0x7478
  14f162:	f6c6 5475 	movt	r4, #28021	; 0x6d75
  14f166:	2300      	movs	r3, #0
  14f168:	f100 0210 	add.w	r2, r0, #16
  14f16c:	6004      	str	r4, [r0, #0]
  14f16e:	f2c7 7161 	movt	r1, #30561	; 0x7761
  14f172:	6142      	str	r2, [r0, #20]
  14f174:	e9c0 1203 	strd	r1, r2, [r0, #12]
  14f178:	e9c0 3301 	strd	r3, r3, [r0, #4]
  14f17c:	6183      	str	r3, [r0, #24]
}
  14f17e:	f85d 4b04 	ldr.w	r4, [r13], #4
  14f182:	4770      	bx	r14

0014f184 <mutex_destroy>:
 *
 * This function frees any resources that were allocated
 * in mutex_init().  The mutex_t object itself is not freed.
 */
void mutex_destroy(mutex_t *m)
{
  14f184:	b538      	push	{r3, r4, r5, r14}
  14f186:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f188:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f18c:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  14f190:	f100 000c 	add.w	r0, r0, #12
  14f194:	d10d      	bne.n	14f1b2 <mutex_destroy+0x2e>
    __asm__ volatile("cpsid i");
  14f196:	b672      	cpsid	i
    *lock = 1;
  14f198:	f246 55c0 	movw	r5, #26048	; 0x65c0
  14f19c:	2101      	movs	r1, #1
              get_current_thread(), get_current_thread()->name, m, m->holder, m->holder->name);
#endif

    THREAD_LOCK(state);
    m->magic = 0;
    m->count = 0;
  14f19e:	6094      	str	r4, [r2, #8]
  14f1a0:	f2c0 0516 	movt	r5, #22
  14f1a4:	6029      	str	r1, [r5, #0]
    m->magic = 0;
  14f1a6:	6014      	str	r4, [r2, #0]
    wait_queue_destroy(&m->wait, true);
  14f1a8:	f000 fdf8 	bl	14fd9c <wait_queue_destroy>
    *lock = 0;
  14f1ac:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
  14f1ae:	b662      	cpsie	i
    THREAD_UNLOCK(state);
}
  14f1b0:	bd38      	pop	{r3, r4, r5, r15}
    *lock = 1;
  14f1b2:	f246 54c0 	movw	r4, #26048	; 0x65c0
    m->magic = 0;
  14f1b6:	2500      	movs	r5, #0
  14f1b8:	2101      	movs	r1, #1
  14f1ba:	f2c0 0416 	movt	r4, #22
    m->count = 0;
  14f1be:	6095      	str	r5, [r2, #8]
  14f1c0:	6021      	str	r1, [r4, #0]
    m->magic = 0;
  14f1c2:	6015      	str	r5, [r2, #0]
    wait_queue_destroy(&m->wait, true);
  14f1c4:	f000 fdea 	bl	14fd9c <wait_queue_destroy>
    *lock = 0;
  14f1c8:	6025      	str	r5, [r4, #0]
}
  14f1ca:	bd38      	pop	{r3, r4, r5, r15}

0014f1cc <mutex_acquire_timeout>:
 *
 * @return  NO_ERROR on success, ERR_TIMED_OUT on timeout,
 * other values on error
 */
status_t mutex_acquire_timeout(mutex_t *m, lk_time_t timeout)
{
  14f1cc:	b570      	push	{r4, r5, r6, r14}
  14f1ce:	4605      	mov	r5, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f1d0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f1d4:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14f1d6:	bf48      	it	mi
  14f1d8:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f1da:	d401      	bmi.n	14f1e0 <mutex_acquire_timeout+0x14>
    __asm__ volatile("cpsid i");
  14f1dc:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14f1de:	2601      	movs	r6, #1
#endif

    THREAD_LOCK(state);

    status_t ret = NO_ERROR;
    if (unlikely(++m->count > 1)) {
  14f1e0:	68ab      	ldr	r3, [r5, #8]
    *lock = 1;
  14f1e2:	2201      	movs	r2, #1
  14f1e4:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f1e8:	3301      	adds	r3, #1
  14f1ea:	f2c0 0416 	movt	r4, #22
  14f1ee:	60ab      	str	r3, [r5, #8]
  14f1f0:	4293      	cmp	r3, r2
  14f1f2:	6022      	str	r2, [r4, #0]
    status_t ret = NO_ERROR;
  14f1f4:	bfd8      	it	le
  14f1f6:	2000      	movle	r0, #0
    if (unlikely(++m->count > 1)) {
  14f1f8:	dc07      	bgt.n	14f20a <mutex_acquire_timeout+0x3e>
  14f1fa:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
             */
            goto err;
        }
    }

    m->holder = get_current_thread();
  14f1fe:	606b      	str	r3, [r5, #4]
    *lock = 0;
  14f200:	2300      	movs	r3, #0
  14f202:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f204:	b106      	cbz	r6, 14f208 <mutex_acquire_timeout+0x3c>
    __asm__ volatile("cpsie i");
  14f206:	b662      	cpsie	i

err:
    THREAD_UNLOCK(state);
    return ret;
}
  14f208:	bd70      	pop	{r4, r5, r6, r15}
        ret = wait_queue_block(&m->wait, timeout);
  14f20a:	f105 000c 	add.w	r0, r5, #12
  14f20e:	f000 fbab 	bl	14f968 <wait_queue_block>
        if (unlikely(ret < NO_ERROR)) {
  14f212:	2800      	cmp	r0, #0
  14f214:	daf1      	bge.n	14f1fa <mutex_acquire_timeout+0x2e>
            if (likely(ret == ERR_TIMED_OUT)) {
  14f216:	f110 0f0d 	cmn.w	r0, #13
  14f21a:	d1f1      	bne.n	14f200 <mutex_acquire_timeout+0x34>
                m->count--;
  14f21c:	68ab      	ldr	r3, [r5, #8]
  14f21e:	3b01      	subs	r3, #1
  14f220:	60ab      	str	r3, [r5, #8]
  14f222:	e7ed      	b.n	14f200 <mutex_acquire_timeout+0x34>

0014f224 <mutex_release>:

/**
 * @brief  Release mutex
 */
status_t mutex_release(mutex_t *m)
{
  14f224:	b538      	push	{r3, r4, r5, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f226:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f22a:	f012 0480 	ands.w	r4, r2, #128	; 0x80
  14f22e:	d110      	bne.n	14f252 <mutex_release+0x2e>
    __asm__ volatile("cpsid i");
  14f230:	b672      	cpsid	i

    THREAD_LOCK(state);

    m->holder = 0;

    if (unlikely(--m->count >= 1)) {
  14f232:	6883      	ldr	r3, [r0, #8]
    *lock = 1;
  14f234:	f246 55c0 	movw	r5, #26048	; 0x65c0
  14f238:	2101      	movs	r1, #1
  14f23a:	f2c0 0516 	movt	r5, #22
  14f23e:	3b01      	subs	r3, #1
  14f240:	6029      	str	r1, [r5, #0]
  14f242:	2b00      	cmp	r3, #0
  14f244:	e9c0 4301 	strd	r4, r3, [r0, #4]
  14f248:	dc13      	bgt.n	14f272 <mutex_release+0x4e>
    *lock = 0;
  14f24a:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
  14f24c:	b662      	cpsie	i
        wait_queue_wake_one(&m->wait, true, NO_ERROR);
    }

    THREAD_UNLOCK(state);
    return NO_ERROR;
}
  14f24e:	2000      	movs	r0, #0
  14f250:	bd38      	pop	{r3, r4, r5, r15}
    if (unlikely(--m->count >= 1)) {
  14f252:	6883      	ldr	r3, [r0, #8]
    m->holder = 0;
  14f254:	2500      	movs	r5, #0
    *lock = 1;
  14f256:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f25a:	2101      	movs	r1, #1
    if (unlikely(--m->count >= 1)) {
  14f25c:	3b01      	subs	r3, #1
  14f25e:	f2c0 0416 	movt	r4, #22
  14f262:	6083      	str	r3, [r0, #8]
  14f264:	42ab      	cmp	r3, r5
  14f266:	6021      	str	r1, [r4, #0]
    m->holder = 0;
  14f268:	6045      	str	r5, [r0, #4]
    if (unlikely(--m->count >= 1)) {
  14f26a:	dc07      	bgt.n	14f27c <mutex_release+0x58>
    *lock = 0;
  14f26c:	6025      	str	r5, [r4, #0]
}
  14f26e:	2000      	movs	r0, #0
  14f270:	bd38      	pop	{r3, r4, r5, r15}
        wait_queue_wake_one(&m->wait, true, NO_ERROR);
  14f272:	4622      	mov	r2, r4
  14f274:	300c      	adds	r0, #12
  14f276:	f000 fc07 	bl	14fa88 <wait_queue_wake_one>
  14f27a:	e7e6      	b.n	14f24a <mutex_release+0x26>
  14f27c:	462a      	mov	r2, r5
  14f27e:	300c      	adds	r0, #12
  14f280:	f000 fc02 	bl	14fa88 <wait_queue_wake_one>
  14f284:	e7f2      	b.n	14f26c <mutex_release+0x48>
  14f286:	bf00      	nop

0014f288 <init_thread_struct>:
    list_add_tail(&run_queue[t->priority], &t->queue_node);
    run_queue_bitmap |= (1<<t->priority);
}

static void init_thread_struct(thread_t *t, const char *name)
{
  14f288:	b510      	push	{r4, r14}
    memset(t, 0, sizeof(thread_t));
  14f28a:	f44f 72c4 	mov.w	r2, #392	; 0x188
{
  14f28e:	460c      	mov	r4, r1
    memset(t, 0, sizeof(thread_t));
  14f290:	2100      	movs	r1, #0
  14f292:	f003 eef4 	blx	15307c <memset>
    t->magic = THREAD_MAGIC;
  14f296:	f247 2264 	movw	r2, #29284	; 0x7264
    thread_set_pinned_cpu(t, -1);
    strlcpy(t->name, name, sizeof(t->name));
  14f29a:	4621      	mov	r1, r4
    t->magic = THREAD_MAGIC;
  14f29c:	f2c7 4268 	movt	r2, #29800	; 0x7468
}
  14f2a0:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    memset(t, 0, sizeof(thread_t));
  14f2a4:	4603      	mov	r3, r0
    strlcpy(t->name, name, sizeof(t->name));
  14f2a6:	f500 70b2 	add.w	r0, r0, #356	; 0x164
    t->magic = THREAD_MAGIC;
  14f2aa:	601a      	str	r2, [r3, #0]
    strlcpy(t->name, name, sizeof(t->name));
  14f2ac:	2220      	movs	r2, #32
  14f2ae:	f004 bf73 	b.w	154198 <strlcpy>
  14f2b2:	bf00      	nop

0014f2b4 <thread_resched>:
 *
 * This is probably not the function you're looking for. See
 * thread_yield() instead.
 */
void thread_resched(void)
{
  14f2b4:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14f2b8:	b083      	sub	sp, #12
  14f2ba:	ee1d 6f90 	mrc	15, 0, r6, cr13, cr0, {4}

    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));
    DEBUG_ASSERT(current_thread->state != THREAD_RUNNING);

    THREAD_STATS_INC(reschedules);
  14f2be:	f246 58c8 	movw	r8, #26056	; 0x65c8
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
  14f2c2:	f246 55b4 	movw	r5, #26036	; 0x65b4
    THREAD_STATS_INC(reschedules);
  14f2c6:	f2c0 0816 	movt	r8, #22
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
  14f2ca:	f2c0 0516 	movt	r5, #22
    THREAD_STATS_INC(reschedules);
  14f2ce:	f8d8 3010 	ldr.w	r3, [r8, #16]
    uint32_t local_run_queue_bitmap = run_queue_bitmap;
  14f2d2:	682c      	ldr	r4, [r5, #0]
    THREAD_STATS_INC(reschedules);
  14f2d4:	3301      	adds	r3, #1
  14f2d6:	f8c8 3010 	str.w	r3, [r8, #16]
    while (local_run_queue_bitmap) {
  14f2da:	b33c      	cbz	r4, 14f32c <thread_resched+0x78>
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
  14f2dc:	f246 4cb4 	movw	r12, #25780	; 0x64b4
        uint next_queue = sizeof(run_queue_bitmap) * 8 - 1 - __builtin_clz(local_run_queue_bitmap);
  14f2e0:	fab4 f384 	clz	r3, r4
  14f2e4:	f1c3 031f 	rsb	r3, r3, #31
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
  14f2e8:	f2c0 0c16 	movt	r12, #22
  14f2ec:	ea4f 0ac3 	mov.w	r10, r3, lsl #3
  14f2f0:	eb0c 000a 	add.w	r0, r12, r10
  14f2f4:	6842      	ldr	r2, [r0, #4]
  14f2f6:	4290      	cmp	r0, r2
  14f2f8:	f1a2 070c 	sub.w	r7, r2, #12
  14f2fc:	f040 8081 	bne.w	14f402 <thread_resched+0x14e>
  14f300:	4622      	mov	r2, r4
        local_run_queue_bitmap &= ~(1<<next_queue);
  14f302:	f04f 0901 	mov.w	r9, #1
  14f306:	e00d      	b.n	14f324 <thread_resched+0x70>
        uint next_queue = sizeof(run_queue_bitmap) * 8 - 1 - __builtin_clz(local_run_queue_bitmap);
  14f308:	fab2 f382 	clz	r3, r2
  14f30c:	f1c3 031f 	rsb	r3, r3, #31
        list_for_every_entry(&run_queue[next_queue], newthread, thread_t, queue_node) {
  14f310:	ea4f 0ac3 	mov.w	r10, r3, lsl #3
  14f314:	eb0c 010a 	add.w	r1, r12, r10
  14f318:	4608      	mov	r0, r1
  14f31a:	6849      	ldr	r1, [r1, #4]
  14f31c:	4288      	cmp	r0, r1
  14f31e:	f1a1 070c 	sub.w	r7, r1, #12
  14f322:	d16e      	bne.n	14f402 <thread_resched+0x14e>
        local_run_queue_bitmap &= ~(1<<next_queue);
  14f324:	fa09 f303 	lsl.w	r3, r9, r3
    while (local_run_queue_bitmap) {
  14f328:	439a      	bics	r2, r3
  14f32a:	d1ed      	bne.n	14f308 <thread_resched+0x54>
    return idle_thread(cpu);
  14f32c:	f246 3710 	movw	r7, #25360	; 0x6310
  14f330:	f2c0 0716 	movt	r7, #22

    newthread = get_top_thread(cpu, true);

    DEBUG_ASSERT(newthread);

    newthread->state = THREAD_RUNNING;
  14f334:	2302      	movs	r3, #2

    oldthread = current_thread;

    if (newthread == oldthread)
  14f336:	42be      	cmp	r6, r7
    newthread->state = THREAD_RUNNING;
  14f338:	61bb      	str	r3, [r7, #24]
    if (newthread == oldthread)
  14f33a:	d039      	beq.n	14f3b0 <thread_resched+0xfc>
        return;

    /* set up quantum for the new thread if it was consumed */
    if (newthread->remaining_quantum <= 0) {
  14f33c:	69fb      	ldr	r3, [r7, #28]
  14f33e:	46f1      	mov	r9, r14
  14f340:	2b00      	cmp	r3, #0
        newthread->remaining_quantum = 5; // XXX make this smarter
  14f342:	bfdc      	itt	le
  14f344:	2305      	movle	r3, #5
  14f346:	61fb      	strle	r3, [r7, #28]
        mp_set_cpu_non_realtime(cpu);
    }
#endif

#if THREAD_STATS
    THREAD_STATS_INC(context_switches);
  14f348:	f8d8 3014 	ldr.w	r3, [r8, #20]
    return !!(t->flags & THREAD_FLAG_IDLE);
  14f34c:	6a32      	ldr	r2, [r6, #32]
    THREAD_STATS_INC(context_switches);
  14f34e:	3301      	adds	r3, #1

    if (thread_is_idle(oldthread)) {
  14f350:	06d1      	lsls	r1, r2, #27
    THREAD_STATS_INC(context_switches);
  14f352:	f8c8 3014 	str.w	r3, [r8, #20]
    if (thread_is_idle(oldthread)) {
  14f356:	d443      	bmi.n	14f3e0 <thread_resched+0x12c>
        lk_bigtime_t now = current_time_hires();
        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;
    }
    if (thread_is_idle(newthread)) {
  14f358:	6a3b      	ldr	r3, [r7, #32]
  14f35a:	06da      	lsls	r2, r3, #27
  14f35c:	d434      	bmi.n	14f3c8 <thread_resched+0x114>
  14f35e:	6a32      	ldr	r2, [r6, #32]
#endif

    KEVLOG_THREAD_SWITCH(oldthread, newthread);

#if PLATFORM_HAS_DYNAMIC_TIMER
    if (thread_is_real_time_or_idle(newthread)) {
  14f360:	f013 0318 	ands.w	r3, r3, #24
  14f364:	f002 0218 	and.w	r2, r2, #24
  14f368:	d125      	bne.n	14f3b6 <thread_resched+0x102>
                    cpu, oldthread, oldthread->name, newthread, newthread->name);
#endif
            timer_cancel(&preempt_timer[cpu]);
        }
    }
    else if (thread_is_real_time_or_idle(oldthread)) {
  14f36a:	2a00      	cmp	r2, #0
  14f36c:	d167      	bne.n	14f43e <thread_resched+0x18a>
  14f36e:	ee0d 7f90 	mcr	15, 0, r7, cr13, cr0, {4}
  14f372:	f3bf 8f6f 	isb	sy
            newthread->priority, newthread->flags);
#endif

#if THREAD_STACK_BOUNDS_CHECK
    /* check that the old thread has not blown its stack just before pushing its context */
    if (oldthread->flags & THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK) {
  14f376:	6a33      	ldr	r3, [r6, #32]
  14f378:	069b      	lsls	r3, r3, #26
  14f37a:	d559      	bpl.n	14f430 <thread_resched+0x17c>
  14f37c:	f8d6 4140 	ldr.w	r4, [r6, #320]	; 0x140
  14f380:	4623      	mov	r3, r4
  14f382:	f504 7080 	add.w	r0, r4, #256	; 0x100
  14f386:	e001      	b.n	14f38c <thread_resched+0xd8>
        STATIC_ASSERT((THREAD_STACK_PADDING_SIZE % sizeof(uint32_t)) == 0);
        uint32_t *s = (uint32_t *)oldthread->stack;
        for (size_t i = 0; i < THREAD_STACK_PADDING_SIZE / sizeof(uint32_t); i++) {
  14f388:	4298      	cmp	r0, r3
  14f38a:	d051      	beq.n	14f430 <thread_resched+0x17c>
            if (unlikely(s[i] != STACK_DEBUG_WORD)) {
  14f38c:	461a      	mov	r2, r3
  14f38e:	3304      	adds	r3, #4
  14f390:	6811      	ldr	r1, [r2, #0]
  14f392:	f1b1 3f99 	cmp.w	r1, #2576980377	; 0x99999999
  14f396:	d0f7      	beq.n	14f388 <thread_resched+0xd4>
                /* NOTE: will probably blow the stack harder here, but hopefully enough
                 * state exists to at least get some sort of debugging done.
                 */
                panic("stack overrun at %p: thread %p (%s), stack %p\n", &s[i],
  14f398:	f248 01b4 	movw	r1, #32948	; 0x80b4
  14f39c:	f506 73b2 	add.w	r3, r6, #356	; 0x164
  14f3a0:	9401      	str	r4, [sp, #4]
  14f3a2:	4648      	mov	r0, r9
  14f3a4:	9300      	str	r3, [sp, #0]
  14f3a6:	f2c0 0115 	movt	r1, #21
  14f3aa:	4633      	mov	r3, r6
  14f3ac:	f003 fc82 	bl	152cb4 <_panic>
    }
#endif

    /* do the low level context switch */
    arch_context_switch(oldthread, newthread);
}
  14f3b0:	b003      	add	sp, #12
  14f3b2:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (!thread_is_real_time_or_idle(oldthread)) {
  14f3b6:	2a00      	cmp	r2, #0
  14f3b8:	d1d9      	bne.n	14f36e <thread_resched+0xba>
            timer_cancel(&preempt_timer[cpu]);
  14f3ba:	f246 4098 	movw	r0, #25752	; 0x6498
  14f3be:	f2c0 0016 	movt	r0, #22
  14f3c2:	f000 fe75 	bl	1500b0 <timer_cancel>
  14f3c6:	e7d2      	b.n	14f36e <thread_resched+0xba>
        thread_stats[cpu].last_idle_timestamp = current_time_hires();
  14f3c8:	f7f1 fabc 	bl	140944 <current_time_hires>
  14f3cc:	6a3b      	ldr	r3, [r7, #32]
  14f3ce:	6a32      	ldr	r2, [r6, #32]
    if (thread_is_real_time_or_idle(newthread)) {
  14f3d0:	f013 0318 	ands.w	r3, r3, #24
  14f3d4:	f002 0218 	and.w	r2, r2, #24
        thread_stats[cpu].last_idle_timestamp = current_time_hires();
  14f3d8:	e9c8 0102 	strd	r0, r1, [r8, #8]
    if (thread_is_real_time_or_idle(newthread)) {
  14f3dc:	d0c5      	beq.n	14f36a <thread_resched+0xb6>
  14f3de:	e7ea      	b.n	14f3b6 <thread_resched+0x102>
        lk_bigtime_t now = current_time_hires();
  14f3e0:	f7f1 fab0 	bl	140944 <current_time_hires>
        thread_stats[cpu].idle_time += now - thread_stats[cpu].last_idle_timestamp;
  14f3e4:	e9d8 2300 	ldrd	r2, r3, [r8]
  14f3e8:	e9d8 4502 	ldrd	r4, r5, [r8, #8]
  14f3ec:	1b12      	subs	r2, r2, r4
  14f3ee:	eb63 0305 	sbc.w	r3, r3, r5
  14f3f2:	1812      	adds	r2, r2, r0
  14f3f4:	414b      	adcs	r3, r1
  14f3f6:	e9c8 2300 	strd	r2, r3, [r8]
    if (thread_is_idle(newthread)) {
  14f3fa:	6a3b      	ldr	r3, [r7, #32]
  14f3fc:	06da      	lsls	r2, r3, #27
  14f3fe:	d5ae      	bpl.n	14f35e <thread_resched+0xaa>
  14f400:	e7e2      	b.n	14f3c8 <thread_resched+0x114>
    item->next->prev = item->prev;
  14f402:	693a      	ldr	r2, [r7, #16]
    return (list->next == list) ? true : false;
  14f404:	44d4      	add	r12, r10
    item->next->prev = item->prev;
  14f406:	68f9      	ldr	r1, [r7, #12]
    item->prev = item->next = 0;
  14f408:	f04f 0900 	mov.w	r9, #0
    item->next->prev = item->prev;
  14f40c:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
  14f40e:	68f9      	ldr	r1, [r7, #12]
  14f410:	604a      	str	r2, [r1, #4]
    item->prev = item->next = 0;
  14f412:	f8c7 9010 	str.w	r9, [r7, #16]
                    if (list_is_empty(&run_queue[next_queue]))
  14f416:	f8dc 2004 	ldr.w	r2, [r12, #4]
  14f41a:	f8c7 900c 	str.w	r9, [r7, #12]
  14f41e:	4282      	cmp	r2, r0
  14f420:	d188      	bne.n	14f334 <thread_resched+0x80>
                        run_queue_bitmap &= ~(1<<next_queue);
  14f422:	2201      	movs	r2, #1
  14f424:	fa02 f303 	lsl.w	r3, r2, r3
  14f428:	ea24 0403 	bic.w	r4, r4, r3
  14f42c:	602c      	str	r4, [r5, #0]
  14f42e:	e781      	b.n	14f334 <thread_resched+0x80>
    arch_context_switch(oldthread, newthread);
  14f430:	4639      	mov	r1, r7
  14f432:	4630      	mov	r0, r6
}
  14f434:	b003      	add	sp, #12
  14f436:	e8bd 4ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    arch_context_switch(oldthread, newthread);
  14f43a:	f7f2 ba4b 	b.w	1418d4 <arch_context_switch>
        timer_set_periodic(&preempt_timer[cpu], 10, (timer_callback)thread_timer_tick, NULL);
  14f43e:	f24f 42c1 	movw	r2, #62657	; 0xf4c1
  14f442:	f246 4098 	movw	r0, #25752	; 0x6498
  14f446:	f2c0 0214 	movt	r2, #20
  14f44a:	210a      	movs	r1, #10
  14f44c:	f2c0 0016 	movt	r0, #22
  14f450:	f000 fe20 	bl	150094 <timer_set_periodic>
  14f454:	e78b      	b.n	14f36e <thread_resched+0xba>
  14f456:	bf00      	nop

0014f458 <thread_sleep_handler>:
    }
}

/* timer callback to wake up a sleeping thread */
static enum handler_return thread_sleep_handler(timer_t *timer, lk_time_t now, void *arg)
{
  14f458:	b4f0      	push	{r4, r5, r6, r7}
  14f45a:	b082      	sub	sp, #8
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f45c:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f460:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14f462:	bf48      	it	mi
  14f464:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f466:	d401      	bmi.n	14f46c <thread_sleep_handler+0x14>
    __asm__ volatile("cpsid i");
  14f468:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14f46a:	2601      	movs	r6, #1
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14f46c:	6951      	ldr	r1, [r2, #20]
    item->next = list->next;
  14f46e:	f246 43b4 	movw	r3, #25780	; 0x64b4
    run_queue_bitmap |= (1<<t->priority);
  14f472:	f246 50b4 	movw	r0, #26036	; 0x65b4
  14f476:	f2c0 0316 	movt	r3, #22
    DEBUG_ASSERT(t->magic == THREAD_MAGIC);
    DEBUG_ASSERT(t->state == THREAD_SLEEPING);

    THREAD_LOCK(state);

    t->state = THREAD_READY;
  14f47a:	2701      	movs	r7, #1
    run_queue_bitmap |= (1<<t->priority);
  14f47c:	f2c0 0016 	movt	r0, #22
  14f480:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
  14f484:	fa07 f101 	lsl.w	r1, r7, r1
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14f488:	f102 040c 	add.w	r4, r2, #12
  14f48c:	685d      	ldr	r5, [r3, #4]
  14f48e:	9501      	str	r5, [sp, #4]
    run_queue_bitmap |= (1<<t->priority);
  14f490:	6805      	ldr	r5, [r0, #0]
  14f492:	4329      	orrs	r1, r5
  14f494:	9d01      	ldr	r5, [sp, #4]
  14f496:	6115      	str	r5, [r2, #16]
    list->next->prev = item;
  14f498:	685d      	ldr	r5, [r3, #4]
  14f49a:	6001      	str	r1, [r0, #0]
    item->prev = list;
  14f49c:	60d3      	str	r3, [r2, #12]
    t->state = THREAD_READY;
  14f49e:	6197      	str	r7, [r2, #24]
    list->next->prev = item;
  14f4a0:	602c      	str	r4, [r5, #0]
    list->next = item;
  14f4a2:	605c      	str	r4, [r3, #4]
  14f4a4:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    *lock = 0;
  14f4a8:	f246 53c0 	movw	r3, #26048	; 0x65c0
  14f4ac:	2200      	movs	r2, #0
  14f4ae:	f2c0 0316 	movt	r3, #22
  14f4b2:	601a      	str	r2, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f4b4:	b106      	cbz	r6, 14f4b8 <thread_sleep_handler+0x60>
    __asm__ volatile("cpsie i");
  14f4b6:	b662      	cpsie	i
    thread_mp_reschedule(get_current_thread(), t);

    THREAD_UNLOCK(state);

    return INT_RESCHEDULE;
}
  14f4b8:	2001      	movs	r0, #1
  14f4ba:	b002      	add	sp, #8
  14f4bc:	bcf0      	pop	{r4, r5, r6, r7}
  14f4be:	4770      	bx	r14

0014f4c0 <thread_timer_tick>:
  14f4c0:	ee1d 2f90 	mrc	15, 0, r2, cr13, cr0, {4}
    if (thread_is_idle(current_thread))
  14f4c4:	6a13      	ldr	r3, [r2, #32]
  14f4c6:	f013 0010 	ands.w	r0, r3, #16
  14f4ca:	d117      	bne.n	14f4fc <thread_timer_tick+0x3c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f4cc:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f4d0:	f011 0180 	ands.w	r1, r1, #128	; 0x80
  14f4d4:	d114      	bne.n	14f500 <thread_timer_tick+0x40>
    __asm__ volatile("cpsid i");
  14f4d6:	b672      	cpsid	i
    *lock = 0;
  14f4d8:	f246 53c0 	movw	r3, #26048	; 0x65c0
  14f4dc:	f2c0 0316 	movt	r3, #22
  14f4e0:	6019      	str	r1, [r3, #0]
    __asm__ volatile("cpsie i");
  14f4e2:	b662      	cpsie	i
  14f4e4:	6a13      	ldr	r3, [r2, #32]
    if (thread_is_real_time_or_idle(current_thread))
  14f4e6:	f013 0f18 	tst.w	r3, #24
  14f4ea:	d107      	bne.n	14f4fc <thread_timer_tick+0x3c>
    current_thread->remaining_quantum--;
  14f4ec:	69d3      	ldr	r3, [r2, #28]
  14f4ee:	3b01      	subs	r3, #1
    if (current_thread->remaining_quantum <= 0) {
  14f4f0:	2b00      	cmp	r3, #0
  14f4f2:	bfcc      	ite	gt
  14f4f4:	2000      	movgt	r0, #0
  14f4f6:	2001      	movle	r0, #1
    current_thread->remaining_quantum--;
  14f4f8:	61d3      	str	r3, [r2, #28]
}
  14f4fa:	4770      	bx	r14
        return INT_NO_RESCHEDULE;
  14f4fc:	2000      	movs	r0, #0
  14f4fe:	4770      	bx	r14
  14f500:	f246 51c0 	movw	r1, #26048	; 0x65c0
  14f504:	f2c0 0116 	movt	r1, #22
  14f508:	6008      	str	r0, [r1, #0]
  14f50a:	e7ec      	b.n	14f4e6 <thread_timer_tick+0x26>

0014f50c <thread_create_etc>:
{
  14f50c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  14f510:	4691      	mov	r9, r2
  14f512:	b083      	sub	sp, #12
  14f514:	4698      	mov	r8, r3
  14f516:	4604      	mov	r4, r0
    unsigned int flags = 0;
  14f518:	2700      	movs	r7, #0
{
  14f51a:	e9dd 560b 	ldrd	r5, r6, [r13, #44]	; 0x2c
    if (!t) {
  14f51e:	2800      	cmp	r0, #0
  14f520:	d05b      	beq.n	14f5da <thread_create_etc+0xce>
    init_thread_struct(t, name);
  14f522:	4620      	mov	r0, r4
  14f524:	f7ff feb0 	bl	14f288 <init_thread_struct>
 * @defgroup  wait  Wait Queue
 * @{
 */
void wait_queue_init(wait_queue_t *wait)
{
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f528:	f646 1174 	movw	r1, #26996	; 0x6974
    t->state = THREAD_SUSPENDED;
  14f52c:	2300      	movs	r3, #0
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f52e:	f504 72ac 	add.w	r2, r4, #344	; 0x158
    t->priority = priority;
  14f532:	980a      	ldr	r0, [sp, #40]	; 0x28
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f534:	f2c7 7161 	movt	r1, #30561	; 0x7761
    t->entry = entry;
  14f538:	f8c4 9148 	str.w	r9, [r4, #328]	; 0x148
    t->arg = arg;
  14f53c:	f8c4 814c 	str.w	r8, [r4, #332]	; 0x14c
    t->priority = priority;
  14f540:	6160      	str	r0, [r4, #20]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f542:	f8c4 1154 	str.w	r1, [r4, #340]	; 0x154
    t->state = THREAD_SUSPENDED;
  14f546:	61a3      	str	r3, [r4, #24]
    t->wait_queue_block_ret = NO_ERROR;
  14f548:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
    t->retcode = 0;
  14f54c:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f550:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
  14f554:	f8c4 2158 	str.w	r2, [r4, #344]	; 0x158
  14f558:	f8c4 215c 	str.w	r2, [r4, #348]	; 0x15c
    if (!stack) {
  14f55c:	2d00      	cmp	r5, #0
  14f55e:	d048      	beq.n	14f5f2 <thread_create_etc+0xe6>
        t->stack = stack;
  14f560:	f8c4 5140 	str.w	r5, [r4, #320]	; 0x140
        memset(t->stack, STACK_DEBUG_BYTE, stack_size);
  14f564:	4628      	mov	r0, r5
  14f566:	4632      	mov	r2, r6
  14f568:	2199      	movs	r1, #153	; 0x99
  14f56a:	f003 ed88 	blx	15307c <memset>
    t->stack_size = stack_size;
  14f56e:	f8c4 6144 	str.w	r6, [r4, #324]	; 0x144
    t->flags = flags;
  14f572:	6227      	str	r7, [r4, #32]
  14f574:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    arch_thread_initialize(t);
  14f578:	4620      	mov	r0, r4
  14f57a:	f7f2 f98f 	bl	14189c <arch_thread_initialize>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f57e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f582:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14f586:	f104 0104 	add.w	r1, r4, #4
  14f58a:	d113      	bne.n	14f5b4 <thread_create_etc+0xa8>
    __asm__ volatile("cpsid i");
  14f58c:	b672      	cpsid	i
    item->next = list->next;
  14f58e:	f246 52b8 	movw	r2, #26040	; 0x65b8
    *lock = 0;
  14f592:	f246 50c0 	movw	r0, #26048	; 0x65c0
  14f596:	f2c0 0216 	movt	r2, #22
  14f59a:	f2c0 0016 	movt	r0, #22
  14f59e:	6855      	ldr	r5, [r2, #4]
    item->prev = list;
  14f5a0:	e9c4 2501 	strd	r2, r5, [r4, #4]
    list->next->prev = item;
  14f5a4:	6029      	str	r1, [r5, #0]
    list->next = item;
  14f5a6:	6051      	str	r1, [r2, #4]
  14f5a8:	6003      	str	r3, [r0, #0]
    __asm__ volatile("cpsie i");
  14f5aa:	b662      	cpsie	i
  14f5ac:	4620      	mov	r0, r4
}
  14f5ae:	b003      	add	sp, #12
  14f5b0:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
    item->next = list->next;
  14f5b4:	f246 53b8 	movw	r3, #26040	; 0x65b8
  14f5b8:	f246 52c0 	movw	r2, #26048	; 0x65c0
  14f5bc:	f2c0 0316 	movt	r3, #22
  14f5c0:	2600      	movs	r6, #0
  14f5c2:	f2c0 0216 	movt	r2, #22
  14f5c6:	4620      	mov	r0, r4
  14f5c8:	685d      	ldr	r5, [r3, #4]
    item->prev = list;
  14f5ca:	e9c4 3501 	strd	r3, r5, [r4, #4]
    list->next->prev = item;
  14f5ce:	6029      	str	r1, [r5, #0]
    list->next = item;
  14f5d0:	6059      	str	r1, [r3, #4]
  14f5d2:	6016      	str	r6, [r2, #0]
  14f5d4:	b003      	add	sp, #12
  14f5d6:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        t = malloc(sizeof(thread_t));
  14f5da:	f44f 70c4 	mov.w	r0, #392	; 0x188
        flags |= THREAD_FLAG_FREE_STRUCT;
  14f5de:	2704      	movs	r7, #4
  14f5e0:	9101      	str	r1, [sp, #4]
        t = malloc(sizeof(thread_t));
  14f5e2:	f003 fc55 	bl	152e90 <malloc>
        if (!t)
  14f5e6:	9901      	ldr	r1, [sp, #4]
  14f5e8:	4604      	mov	r4, r0
  14f5ea:	2800      	cmp	r0, #0
  14f5ec:	d199      	bne.n	14f522 <thread_create_etc+0x16>
            return NULL;
  14f5ee:	2000      	movs	r0, #0
  14f5f0:	e7dd      	b.n	14f5ae <thread_create_etc+0xa2>
        stack_size += THREAD_STACK_PADDING_SIZE;
  14f5f2:	f506 7980 	add.w	r9, r6, #256	; 0x100
        t->stack = malloc(stack_size);
  14f5f6:	4648      	mov	r0, r9
  14f5f8:	f003 fc4a 	bl	152e90 <malloc>
  14f5fc:	f8c4 0140 	str.w	r0, [r4, #320]	; 0x140
  14f600:	4680      	mov	r8, r0
        if (!t->stack) {
  14f602:	b170      	cbz	r0, 14f622 <thread_create_etc+0x116>
        memset(t->stack, STACK_DEBUG_BYTE, THREAD_STACK_PADDING_SIZE);
  14f604:	f44f 7280 	mov.w	r2, #256	; 0x100
  14f608:	2199      	movs	r1, #153	; 0x99
  14f60a:	f003 ed38 	blx	15307c <memset>
        memset(t->stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,
  14f60e:	4632      	mov	r2, r6
  14f610:	2199      	movs	r1, #153	; 0x99
  14f612:	f508 7080 	add.w	r0, r8, #256	; 0x100
        stack_size += THREAD_STACK_PADDING_SIZE;
  14f616:	464e      	mov	r6, r9
        flags |= THREAD_FLAG_FREE_STACK;
  14f618:	f047 0722 	orr.w	r7, r7, #34	; 0x22
        memset(t->stack + THREAD_STACK_PADDING_SIZE, STACK_DEBUG_BYTE,
  14f61c:	f003 ed2e 	blx	15307c <memset>
  14f620:	e7a5      	b.n	14f56e <thread_create_etc+0x62>
            if (flags & THREAD_FLAG_FREE_STRUCT)
  14f622:	2f00      	cmp	r7, #0
  14f624:	d0e3      	beq.n	14f5ee <thread_create_etc+0xe2>
                free(t);
  14f626:	4620      	mov	r0, r4
  14f628:	f003 fc68 	bl	152efc <free>
            return NULL;
  14f62c:	4628      	mov	r0, r5
  14f62e:	e7be      	b.n	14f5ae <thread_create_etc+0xa2>

0014f630 <thread_create>:
{
  14f630:	b530      	push	{r4, r5, r14}
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
  14f632:	2400      	movs	r4, #0
{
  14f634:	b085      	sub	sp, #20
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
  14f636:	9300      	str	r3, [sp, #0]
  14f638:	4613      	mov	r3, r2
{
  14f63a:	9d08      	ldr	r5, [sp, #32]
    return thread_create_etc(NULL, name, entry, arg, priority, NULL, stack_size);
  14f63c:	460a      	mov	r2, r1
  14f63e:	9401      	str	r4, [sp, #4]
  14f640:	4601      	mov	r1, r0
  14f642:	9502      	str	r5, [sp, #8]
  14f644:	4620      	mov	r0, r4
  14f646:	f7ff ff61 	bl	14f50c <thread_create_etc>
}
  14f64a:	b005      	add	sp, #20
  14f64c:	bd30      	pop	{r4, r5, r15}
  14f64e:	bf00      	nop

0014f650 <thread_yield>:
{
  14f650:	b5f0      	push	{r4, r5, r6, r7, r14}
  14f652:	b083      	sub	sp, #12
  14f654:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f658:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f65c:	0610      	lsls	r0, r2, #24
    spin_lock_saved_state_t state = 0;
  14f65e:	bf48      	it	mi
  14f660:	2600      	movmi	r6, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f662:	d401      	bmi.n	14f668 <thread_yield+0x18>
    __asm__ volatile("cpsid i");
  14f664:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14f666:	2601      	movs	r6, #1
    THREAD_STATS_INC(yields);
  14f668:	f246 51c8 	movw	r1, #26056	; 0x65c8
    *lock = 1;
  14f66c:	2201      	movs	r2, #1
  14f66e:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f672:	f2c0 0116 	movt	r1, #22
    current_thread->remaining_quantum = 0;
  14f676:	2500      	movs	r5, #0
  14f678:	f2c0 0416 	movt	r4, #22
    THREAD_STATS_INC(yields);
  14f67c:	69c8      	ldr	r0, [r1, #28]
  14f67e:	6022      	str	r2, [r4, #0]
  14f680:	4410      	add	r0, r2
  14f682:	61c8      	str	r0, [r1, #28]
    return !!(t->flags & THREAD_FLAG_IDLE);
  14f684:	6a19      	ldr	r1, [r3, #32]
    current_thread->remaining_quantum = 0;
  14f686:	e9c3 2506 	strd	r2, r5, [r3, #24]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
  14f68a:	06c9      	lsls	r1, r1, #27
  14f68c:	d41c      	bmi.n	14f6c8 <thread_yield+0x78>
    item->prev = list->prev;
  14f68e:	f246 41b4 	movw	r1, #25780	; 0x64b4
    run_queue_bitmap |= (1<<t->priority);
  14f692:	f246 57b4 	movw	r7, #26036	; 0x65b4
    list_add_tail(&run_queue[t->priority], &t->queue_node);
  14f696:	6958      	ldr	r0, [r3, #20]
  14f698:	f2c0 0116 	movt	r1, #22
    run_queue_bitmap |= (1<<t->priority);
  14f69c:	f2c0 0716 	movt	r7, #22
  14f6a0:	4082      	lsls	r2, r0
  14f6a2:	f851 5030 	ldr.w	r5, [r1, r0, lsl #3]
    list_add_tail(&run_queue[t->priority], &t->queue_node);
  14f6a6:	f103 0c0c 	add.w	r12, r3, #12
  14f6aa:	9501      	str	r5, [sp, #4]
    run_queue_bitmap |= (1<<t->priority);
  14f6ac:	683d      	ldr	r5, [r7, #0]
  14f6ae:	432a      	orrs	r2, r5
  14f6b0:	9d01      	ldr	r5, [sp, #4]
  14f6b2:	60dd      	str	r5, [r3, #12]
    list_add_tail(&run_queue[t->priority], &t->queue_node);
  14f6b4:	eb01 05c0 	add.w	r5, r1, r0, lsl #3
    run_queue_bitmap |= (1<<t->priority);
  14f6b8:	603a      	str	r2, [r7, #0]
    list->prev->next = item;
  14f6ba:	f851 2030 	ldr.w	r2, [r1, r0, lsl #3]
    item->next = list;
  14f6be:	611d      	str	r5, [r3, #16]
    list->prev->next = item;
  14f6c0:	f8c2 c004 	str.w	r12, [r2, #4]
    list->prev = item;
  14f6c4:	f841 c030 	str.w	r12, [r1, r0, lsl #3]
    thread_resched();
  14f6c8:	f7ff fdf4 	bl	14f2b4 <thread_resched>
    *lock = 0;
  14f6cc:	2300      	movs	r3, #0
  14f6ce:	6023      	str	r3, [r4, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f6d0:	b106      	cbz	r6, 14f6d4 <thread_yield+0x84>
    __asm__ volatile("cpsie i");
  14f6d2:	b662      	cpsie	i
}
  14f6d4:	b003      	add	sp, #12
  14f6d6:	bdf0      	pop	{r4, r5, r6, r7, r15}

0014f6d8 <thread_resume>:
{
  14f6d8:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f6da:	f3ef 8200 	mrs	r2, CPSR
  14f6de:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f6e2:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  14f6e4:	bf48      	it	mi
  14f6e6:	f04f 0c00 	movmi.w	r12, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f6ea:	d402      	bmi.n	14f6f2 <thread_resume+0x1a>
    __asm__ volatile("cpsid i");
  14f6ec:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  14f6ee:	f04f 0c01 	mov.w	r12, #1
    *lock = 1;
  14f6f2:	f246 53c0 	movw	r3, #26048	; 0x65c0
  14f6f6:	2601      	movs	r6, #1
    if (t->state == THREAD_SUSPENDED) {
  14f6f8:	6981      	ldr	r1, [r0, #24]
  14f6fa:	f2c0 0316 	movt	r3, #22
  14f6fe:	601e      	str	r6, [r3, #0]
  14f700:	bb49      	cbnz	r1, 14f756 <thread_resume+0x7e>
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14f702:	6944      	ldr	r4, [r0, #20]
    run_queue_bitmap |= (1<<t->priority);
  14f704:	f246 57b4 	movw	r7, #26036	; 0x65b4
    item->next = list->next;
  14f708:	f246 41b4 	movw	r1, #25780	; 0x64b4
  14f70c:	f2c0 0716 	movt	r7, #22
  14f710:	f2c0 0116 	movt	r1, #22
  14f714:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
  14f718:	683d      	ldr	r5, [r7, #0]
        if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
  14f71a:	f082 0280 	eor.w	r2, r2, #128	; 0x80
    run_queue_bitmap |= (1<<t->priority);
  14f71e:	fa06 f404 	lsl.w	r4, r6, r4
  14f722:	432c      	orrs	r4, r5
  14f724:	684d      	ldr	r5, [r1, #4]
        if (!ints_disabled) /* HACK, don't resced into bootstrap thread before idle thread is set up */
  14f726:	f3c2 12c0 	ubfx	r2, r2, #7, #1
  14f72a:	6105      	str	r5, [r0, #16]
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14f72c:	f100 050c 	add.w	r5, r0, #12
        t->state = THREAD_READY;
  14f730:	6186      	str	r6, [r0, #24]
    list->next->prev = item;
  14f732:	684e      	ldr	r6, [r1, #4]
    run_queue_bitmap |= (1<<t->priority);
  14f734:	603c      	str	r4, [r7, #0]
    item->prev = list;
  14f736:	60c1      	str	r1, [r0, #12]
    list->next->prev = item;
  14f738:	6035      	str	r5, [r6, #0]
    list->next = item;
  14f73a:	604d      	str	r5, [r1, #4]
  14f73c:	ee1d 1f90 	mrc	15, 0, r1, cr13, cr0, {4}
    *lock = 0;
  14f740:	2100      	movs	r1, #0
  14f742:	6019      	str	r1, [r3, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f744:	f1bc 0f00 	cmp.w	r12, #0
  14f748:	d000      	beq.n	14f74c <thread_resume+0x74>
    __asm__ volatile("cpsie i");
  14f74a:	b662      	cpsie	i
    if (resched)
  14f74c:	b10a      	cbz	r2, 14f752 <thread_resume+0x7a>
        thread_yield();
  14f74e:	f7ff ff7f 	bl	14f650 <thread_yield>
}
  14f752:	2000      	movs	r0, #0
  14f754:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    bool resched = false;
  14f756:	2200      	movs	r2, #0
  14f758:	e7f0      	b.n	14f73c <thread_resume+0x64>
  14f75a:	bf00      	nop

0014f75c <thread_preempt>:
{
  14f75c:	b5f0      	push	{r4, r5, r6, r7, r14}
  14f75e:	b083      	sub	sp, #12
  14f760:	ee1d 2f90 	mrc	15, 0, r2, cr13, cr0, {4}
    return !!(t->flags & THREAD_FLAG_IDLE);
  14f764:	6a13      	ldr	r3, [r2, #32]
    if (!thread_is_idle(current_thread))
  14f766:	f013 0410 	ands.w	r4, r3, #16
        THREAD_STATS_INC(preempts); /* only track when a meaningful preempt happens */
  14f76a:	bf01      	itttt	eq
  14f76c:	f246 51c8 	movweq	r1, #26056	; 0x65c8
  14f770:	f2c0 0116 	movteq	r1, #22
  14f774:	6988      	ldreq	r0, [r1, #24]
  14f776:	3001      	addeq	r0, #1
  14f778:	bf08      	it	eq
  14f77a:	6188      	streq	r0, [r1, #24]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f77c:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f780:	f011 0180 	ands.w	r1, r1, #128	; 0x80
  14f784:	d132      	bne.n	14f7ec <thread_preempt+0x90>
    __asm__ volatile("cpsid i");
  14f786:	b672      	cpsid	i
    return !!(t->flags & THREAD_FLAG_IDLE);
  14f788:	6a10      	ldr	r0, [r2, #32]
    *lock = 1;
  14f78a:	f246 55c0 	movw	r5, #26048	; 0x65c0
  14f78e:	2401      	movs	r4, #1
  14f790:	f2c0 0516 	movt	r5, #22
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
  14f794:	06c3      	lsls	r3, r0, #27
    current_thread->state = THREAD_READY;
  14f796:	6194      	str	r4, [r2, #24]
  14f798:	602c      	str	r4, [r5, #0]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
  14f79a:	d442      	bmi.n	14f822 <thread_preempt+0xc6>
  14f79c:	f246 57b4 	movw	r7, #26036	; 0x65b4
  14f7a0:	2301      	movs	r3, #1
        if (current_thread->remaining_quantum > 0)
  14f7a2:	69d0      	ldr	r0, [r2, #28]
  14f7a4:	f2c0 0716 	movt	r7, #22
  14f7a8:	f8d2 c014 	ldr.w	r12, [r2, #20]
  14f7ac:	f246 41b4 	movw	r1, #25780	; 0x64b4
  14f7b0:	2800      	cmp	r0, #0
  14f7b2:	683e      	ldr	r6, [r7, #0]
  14f7b4:	f2c0 0116 	movt	r1, #22
  14f7b8:	fa03 f30c 	lsl.w	r3, r3, r12
  14f7bc:	ea43 0306 	orr.w	r3, r3, r6
  14f7c0:	f102 0e0c 	add.w	r14, r2, #12
  14f7c4:	eb01 06cc 	add.w	r6, r1, r12, lsl #3
  14f7c8:	dd1f      	ble.n	14f80a <thread_preempt+0xae>
    item->next = list->next;
  14f7ca:	6871      	ldr	r1, [r6, #4]
  14f7cc:	6111      	str	r1, [r2, #16]
    list->next->prev = item;
  14f7ce:	6871      	ldr	r1, [r6, #4]
    run_queue_bitmap |= (1<<t->priority);
  14f7d0:	603b      	str	r3, [r7, #0]
    item->prev = list;
  14f7d2:	60d6      	str	r6, [r2, #12]
    list->next->prev = item;
  14f7d4:	f8c1 e000 	str.w	r14, [r1]
    list->next = item;
  14f7d8:	f8c6 e004 	str.w	r14, [r6, #4]
    thread_resched();
  14f7dc:	f7ff fd6a 	bl	14f2b4 <thread_resched>
    *lock = 0;
  14f7e0:	2300      	movs	r3, #0
  14f7e2:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14f7e4:	b104      	cbz	r4, 14f7e8 <thread_preempt+0x8c>
    __asm__ volatile("cpsie i");
  14f7e6:	b662      	cpsie	i
}
  14f7e8:	b003      	add	sp, #12
  14f7ea:	bdf0      	pop	{r4, r5, r6, r7, r15}
    *lock = 1;
  14f7ec:	f246 55c0 	movw	r5, #26048	; 0x65c0
  14f7f0:	2101      	movs	r1, #1
  14f7f2:	f2c0 0516 	movt	r5, #22
    current_thread->state = THREAD_READY;
  14f7f6:	6191      	str	r1, [r2, #24]
  14f7f8:	6029      	str	r1, [r5, #0]
    if (likely(!thread_is_idle(current_thread))) { /* idle thread doesn't go in the run queue */
  14f7fa:	2c00      	cmp	r4, #0
  14f7fc:	d0ce      	beq.n	14f79c <thread_preempt+0x40>
    thread_resched();
  14f7fe:	f7ff fd59 	bl	14f2b4 <thread_resched>
    *lock = 0;
  14f802:	2300      	movs	r3, #0
  14f804:	602b      	str	r3, [r5, #0]
}
  14f806:	b003      	add	sp, #12
  14f808:	bdf0      	pop	{r4, r5, r6, r7, r15}
    item->prev = list->prev;
  14f80a:	f851 003c 	ldr.w	r0, [r1, r12, lsl #3]
  14f80e:	60d0      	str	r0, [r2, #12]
    list->prev->next = item;
  14f810:	f851 003c 	ldr.w	r0, [r1, r12, lsl #3]
    run_queue_bitmap |= (1<<t->priority);
  14f814:	603b      	str	r3, [r7, #0]
    item->next = list;
  14f816:	6116      	str	r6, [r2, #16]
    list->prev->next = item;
  14f818:	f8c0 e004 	str.w	r14, [r0, #4]
    list->prev = item;
  14f81c:	f841 e03c 	str.w	r14, [r1, r12, lsl #3]
  14f820:	e7dc      	b.n	14f7dc <thread_preempt+0x80>
  14f822:	9101      	str	r1, [sp, #4]
    thread_resched();
  14f824:	f7ff fd46 	bl	14f2b4 <thread_resched>
  14f828:	9901      	ldr	r1, [sp, #4]
  14f82a:	6029      	str	r1, [r5, #0]
  14f82c:	e7db      	b.n	14f7e6 <thread_preempt+0x8a>
  14f82e:	bf00      	nop

0014f830 <thread_sleep>:
{
  14f830:	b5f0      	push	{r4, r5, r6, r7, r14}
  14f832:	4607      	mov	r7, r0
  14f834:	b089      	sub	sp, #36	; 0x24
  14f836:	ee1d 5f90 	mrc	15, 0, r5, cr13, cr0, {4}
    timer_initialize(&timer);
  14f83a:	a801      	add	r0, sp, #4
  14f83c:	f000 fc0e 	bl	15005c <timer_initialize>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f840:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f844:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  14f848:	d119      	bne.n	14f87e <thread_sleep+0x4e>
    __asm__ volatile("cpsid i");
  14f84a:	b672      	cpsid	i
    *lock = 1;
  14f84c:	f246 56c0 	movw	r6, #26048	; 0x65c0
  14f850:	f04f 0c01 	mov.w	r12, #1
    timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
  14f854:	f24f 4259 	movw	r2, #62553	; 0xf459
  14f858:	f2c0 0616 	movt	r6, #22
  14f85c:	4639      	mov	r1, r7
  14f85e:	a801      	add	r0, sp, #4
  14f860:	462b      	mov	r3, r5
  14f862:	f2c0 0214 	movt	r2, #20
  14f866:	f8c6 c000 	str.w	r12, [r6]
  14f86a:	f000 fc05 	bl	150078 <timer_set_oneshot>
    current_thread->state = THREAD_SLEEPING;
  14f86e:	2304      	movs	r3, #4
  14f870:	61ab      	str	r3, [r5, #24]
    thread_resched();
  14f872:	f7ff fd1f 	bl	14f2b4 <thread_resched>
    *lock = 0;
  14f876:	6034      	str	r4, [r6, #0]
    __asm__ volatile("cpsie i");
  14f878:	b662      	cpsie	i
}
  14f87a:	b009      	add	sp, #36	; 0x24
  14f87c:	bdf0      	pop	{r4, r5, r6, r7, r15}
    *lock = 1;
  14f87e:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14f882:	2601      	movs	r6, #1
    timer_set_oneshot(&timer, delay, thread_sleep_handler, (void *)current_thread);
  14f884:	f24f 4259 	movw	r2, #62553	; 0xf459
  14f888:	f2c0 0416 	movt	r4, #22
  14f88c:	4639      	mov	r1, r7
  14f88e:	a801      	add	r0, sp, #4
  14f890:	462b      	mov	r3, r5
  14f892:	f2c0 0214 	movt	r2, #20
  14f896:	6026      	str	r6, [r4, #0]
  14f898:	f000 fbee 	bl	150078 <timer_set_oneshot>
    current_thread->state = THREAD_SLEEPING;
  14f89c:	2304      	movs	r3, #4
  14f89e:	61ab      	str	r3, [r5, #24]
    thread_resched();
  14f8a0:	f7ff fd08 	bl	14f2b4 <thread_resched>
    *lock = 0;
  14f8a4:	2300      	movs	r3, #0
  14f8a6:	6023      	str	r3, [r4, #0]
}
  14f8a8:	b009      	add	sp, #36	; 0x24
  14f8aa:	bdf0      	pop	{r4, r5, r6, r7, r15}

0014f8ac <thread_init_early>:
{
  14f8ac:	f246 43b4 	movw	r3, #25780	; 0x64b4
  14f8b0:	f2c0 0316 	movt	r3, #22
  14f8b4:	f503 7280 	add.w	r2, r3, #256	; 0x100
  14f8b8:	b570      	push	{r4, r5, r6, r14}
    list->prev = list->next = list;
  14f8ba:	e9c3 3300 	strd	r3, r3, [r3]
  14f8be:	3308      	adds	r3, #8
    for (i=0; i < NUM_PRIORITIES; i++)
  14f8c0:	4293      	cmp	r3, r2
  14f8c2:	d1fa      	bne.n	14f8ba <thread_init_early+0xe>
  14f8c4:	f246 55b8 	movw	r5, #26040	; 0x65b8
    init_thread_struct(t, "bootstrap");
  14f8c8:	f246 3410 	movw	r4, #25360	; 0x6310
  14f8cc:	f2c0 0416 	movt	r4, #22
  14f8d0:	f248 01a8 	movw	r1, #32936	; 0x80a8
  14f8d4:	f2c0 0516 	movt	r5, #22
  14f8d8:	4620      	mov	r0, r4
  14f8da:	f2c0 0115 	movt	r1, #21
  14f8de:	e9c5 5500 	strd	r5, r5, [r5]
  14f8e2:	f7ff fcd1 	bl	14f288 <init_thread_struct>
    t->priority = HIGHEST_PRIORITY;
  14f8e6:	211f      	movs	r1, #31
    t->state = THREAD_RUNNING;
  14f8e8:	2302      	movs	r3, #2
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f8ea:	f646 1274 	movw	r2, #26996	; 0x6974
    t->flags = THREAD_FLAG_DETACHED;
  14f8ee:	2601      	movs	r6, #1
    t->priority = HIGHEST_PRIORITY;
  14f8f0:	6161      	str	r1, [r4, #20]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f8f2:	f2c7 7261 	movt	r2, #30561	; 0x7761
    t->state = THREAD_RUNNING;
  14f8f6:	61a3      	str	r3, [r4, #24]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f8f8:	f504 71ac 	add.w	r1, r4, #344	; 0x158
    item->prev = list;
  14f8fc:	4623      	mov	r3, r4
  14f8fe:	2000      	movs	r0, #0
  14f900:	f8c4 2154 	str.w	r2, [r4, #340]	; 0x154
    item->next = list->next;
  14f904:	686a      	ldr	r2, [r5, #4]
    item->prev = list;
  14f906:	f843 5f04 	str.w	r5, [r3, #4]!
    t->flags = THREAD_FLAG_DETACHED;
  14f90a:	6226      	str	r6, [r4, #32]
    *wait = (wait_queue_t)WAIT_QUEUE_INITIAL_VALUE(*wait);
  14f90c:	f8c4 0160 	str.w	r0, [r4, #352]	; 0x160
  14f910:	f8c4 1158 	str.w	r1, [r4, #344]	; 0x158
  14f914:	f8c4 115c 	str.w	r1, [r4, #348]	; 0x15c
    item->next = list->next;
  14f918:	60a2      	str	r2, [r4, #8]
    list->next->prev = item;
  14f91a:	6013      	str	r3, [r2, #0]
    list->next = item;
  14f91c:	606b      	str	r3, [r5, #4]
  14f91e:	ee0d 4f90 	mcr	15, 0, r4, cr13, cr0, {4}
  14f922:	f3bf 8f6f 	isb	sy
}
  14f926:	bd70      	pop	{r4, r5, r6, r15}

0014f928 <thread_init>:
        timer_initialize(&preempt_timer[i]);
  14f928:	f246 4098 	movw	r0, #25752	; 0x6498
  14f92c:	f2c0 0016 	movt	r0, #22
  14f930:	f000 bb94 	b.w	15005c <timer_initialize>

0014f934 <thread_become_idle>:
{
  14f934:	b508      	push	{r3, r14}
  14f936:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
  14f93a:	ee1d 0f90 	mrc	15, 0, r0, cr13, cr0, {4}
    strlcpy(current_thread->name, name, sizeof(current_thread->name));
  14f93e:	f248 017c 	movw	r1, #32892	; 0x807c
  14f942:	2220      	movs	r2, #32
  14f944:	f2c0 0115 	movt	r1, #21
  14f948:	f500 70b2 	add.w	r0, r0, #356	; 0x164
  14f94c:	f004 fc24 	bl	154198 <strlcpy>
    t->flags |= THREAD_FLAG_IDLE;
  14f950:	6a23      	ldr	r3, [r4, #32]
    t->priority = IDLE_PRIORITY;
  14f952:	2200      	movs	r2, #0
    t->flags |= THREAD_FLAG_IDLE;
  14f954:	f043 0310 	orr.w	r3, r3, #16
    t->priority = IDLE_PRIORITY;
  14f958:	6162      	str	r2, [r4, #20]
    t->flags |= THREAD_FLAG_IDLE;
  14f95a:	6223      	str	r3, [r4, #32]
  14f95c:	b662      	cpsie	i
    thread_yield();
  14f95e:	f7ff fe77 	bl	14f650 <thread_yield>
        arch_idle();
  14f962:	f7f1 e9fa 	blx	140d58 <arch_idle>
  14f966:	e7fc      	b.n	14f962 <thread_become_idle+0x2e>

0014f968 <wait_queue_block>:
 *
 * @return ERR_TIMED_OUT on timeout, else returns the return
 * value specified when the queue was woken by wait_queue_wake_one().
 */
status_t wait_queue_block(wait_queue_t *wait, lk_time_t timeout)
{
  14f968:	b5f0      	push	{r4, r5, r6, r7, r14}
  14f96a:	b089      	sub	sp, #36	; 0x24
  14f96c:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(current_thread->state == THREAD_RUNNING);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (timeout == 0)
  14f970:	b359      	cbz	r1, 14f9ca <wait_queue_block+0x62>
    item->prev = list->prev;
  14f972:	4605      	mov	r5, r0
        return ERR_TIMED_OUT;

    list_add_tail(&wait->list, &current_thread->queue_node);
  14f974:	f104 030c 	add.w	r3, r4, #12
    wait->count++;
  14f978:	68c2      	ldr	r2, [r0, #12]
  14f97a:	460e      	mov	r6, r1
    current_thread->state = THREAD_BLOCKED;
  14f97c:	2703      	movs	r7, #3
  14f97e:	f855 1f04 	ldr.w	r1, [r5, #4]!
    wait->count++;
  14f982:	3201      	adds	r2, #1
  14f984:	60e1      	str	r1, [r4, #12]
    current_thread->blocking_wait_queue = wait;
    current_thread->wait_queue_block_ret = NO_ERROR;
  14f986:	2100      	movs	r1, #0
    item->next = list;
  14f988:	6125      	str	r5, [r4, #16]
    list->prev->next = item;
  14f98a:	6845      	ldr	r5, [r0, #4]
  14f98c:	606b      	str	r3, [r5, #4]
    list->prev = item;
  14f98e:	6043      	str	r3, [r0, #4]

    /* if the timeout is nonzero or noninfinite, set a callback to yank us out of the queue */
    if (timeout != INFINITE_TIME) {
  14f990:	1c73      	adds	r3, r6, #1
    wait->count++;
  14f992:	60c2      	str	r2, [r0, #12]
    current_thread->blocking_wait_queue = wait;
  14f994:	6260      	str	r0, [r4, #36]	; 0x24
    current_thread->state = THREAD_BLOCKED;
  14f996:	61a7      	str	r7, [r4, #24]
    current_thread->wait_queue_block_ret = NO_ERROR;
  14f998:	62a1      	str	r1, [r4, #40]	; 0x28
    if (timeout != INFINITE_TIME) {
  14f99a:	d104      	bne.n	14f9a6 <wait_queue_block+0x3e>
        timer_initialize(&timer);
        timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
    }

    thread_resched();
  14f99c:	f7ff fc8a 	bl	14f2b4 <thread_resched>
    /* we don't really know if the timer fired or not, so it's better safe to try to cancel it */
    if (timeout != INFINITE_TIME) {
        timer_cancel(&timer);
    }

    return current_thread->wait_queue_block_ret;
  14f9a0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
  14f9a2:	b009      	add	sp, #36	; 0x24
  14f9a4:	bdf0      	pop	{r4, r5, r6, r7, r15}
        timer_initialize(&timer);
  14f9a6:	a801      	add	r0, sp, #4
  14f9a8:	f000 fb58 	bl	15005c <timer_initialize>
        timer_set_oneshot(&timer, timeout, wait_queue_timeout_handler, (void *)current_thread);
  14f9ac:	f64f 6229 	movw	r2, #65065	; 0xfe29
  14f9b0:	4623      	mov	r3, r4
  14f9b2:	a801      	add	r0, sp, #4
  14f9b4:	4631      	mov	r1, r6
  14f9b6:	f2c0 0214 	movt	r2, #20
  14f9ba:	f000 fb5d 	bl	150078 <timer_set_oneshot>
    thread_resched();
  14f9be:	f7ff fc79 	bl	14f2b4 <thread_resched>
        timer_cancel(&timer);
  14f9c2:	a801      	add	r0, sp, #4
  14f9c4:	f000 fb74 	bl	1500b0 <timer_cancel>
  14f9c8:	e7ea      	b.n	14f9a0 <wait_queue_block+0x38>
        return ERR_TIMED_OUT;
  14f9ca:	f06f 000c 	mvn.w	r0, #12
  14f9ce:	e7e8      	b.n	14f9a2 <wait_queue_block+0x3a>

0014f9d0 <thread_join>:
{
  14f9d0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14f9d2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14f9d6:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  14f9da:	d12b      	bne.n	14fa34 <thread_join+0x64>
    __asm__ volatile("cpsid i");
  14f9dc:	b672      	cpsid	i
    if (t->flags & THREAD_FLAG_DETACHED) {
  14f9de:	6a04      	ldr	r4, [r0, #32]
    *lock = 1;
  14f9e0:	f246 56c0 	movw	r6, #26048	; 0x65c0
  14f9e4:	2701      	movs	r7, #1
  14f9e6:	f2c0 0616 	movt	r6, #22
  14f9ea:	07e4      	lsls	r4, r4, #31
  14f9ec:	6037      	str	r7, [r6, #0]
  14f9ee:	d446      	bmi.n	14fa7e <thread_join+0xae>
    if (t->state != THREAD_DEATH) {
  14f9f0:	6983      	ldr	r3, [r0, #24]
  14f9f2:	460d      	mov	r5, r1
  14f9f4:	4604      	mov	r4, r0
  14f9f6:	2b05      	cmp	r3, #5
  14f9f8:	d12f      	bne.n	14fa5a <thread_join+0x8a>
    if (retcode)
  14f9fa:	b115      	cbz	r5, 14fa02 <thread_join+0x32>
        *retcode = t->retcode;
  14f9fc:	f8d4 3150 	ldr.w	r3, [r4, #336]	; 0x150
  14fa00:	602b      	str	r3, [r5, #0]
    item->next->prev = item->prev;
  14fa02:	6861      	ldr	r1, [r4, #4]
    item->prev = item->next = 0;
  14fa04:	2300      	movs	r3, #0
    item->next->prev = item->prev;
  14fa06:	68a2      	ldr	r2, [r4, #8]
  14fa08:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
  14fa0a:	6861      	ldr	r1, [r4, #4]
  14fa0c:	604a      	str	r2, [r1, #4]
    t->magic = 0;
  14fa0e:	6023      	str	r3, [r4, #0]
    item->prev = item->next = 0;
  14fa10:	e9c4 3301 	strd	r3, r3, [r4, #4]
    *lock = 0;
  14fa14:	6033      	str	r3, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14fa16:	b107      	cbz	r7, 14fa1a <thread_join+0x4a>
    __asm__ volatile("cpsie i");
  14fa18:	b662      	cpsie	i
    if (t->flags & THREAD_FLAG_FREE_STACK && t->stack)
  14fa1a:	6a23      	ldr	r3, [r4, #32]
  14fa1c:	079a      	lsls	r2, r3, #30
  14fa1e:	d505      	bpl.n	14fa2c <thread_join+0x5c>
  14fa20:	f8d4 0140 	ldr.w	r0, [r4, #320]	; 0x140
  14fa24:	b110      	cbz	r0, 14fa2c <thread_join+0x5c>
        free(t->stack);
  14fa26:	f003 fa69 	bl	152efc <free>
  14fa2a:	6a23      	ldr	r3, [r4, #32]
    if (t->flags & THREAD_FLAG_FREE_STRUCT)
  14fa2c:	f013 0004 	ands.w	r0, r3, #4
  14fa30:	d120      	bne.n	14fa74 <thread_join+0xa4>
}
  14fa32:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (t->flags & THREAD_FLAG_DETACHED) {
  14fa34:	6a07      	ldr	r7, [r0, #32]
    *lock = 1;
  14fa36:	f246 56c0 	movw	r6, #26048	; 0x65c0
  14fa3a:	2301      	movs	r3, #1
  14fa3c:	f2c0 0616 	movt	r6, #22
  14fa40:	401f      	ands	r7, r3
  14fa42:	6033      	str	r3, [r6, #0]
    *lock = 0;
  14fa44:	bf1e      	ittt	ne
  14fa46:	2300      	movne	r3, #0
        return ERR_THREAD_DETACHED;
  14fa48:	f06f 0021 	mvnne.w	r0, #33	; 0x21
  14fa4c:	6033      	strne	r3, [r6, #0]
    if (t->flags & THREAD_FLAG_DETACHED) {
  14fa4e:	d1f0      	bne.n	14fa32 <thread_join+0x62>
    if (t->state != THREAD_DEATH) {
  14fa50:	6983      	ldr	r3, [r0, #24]
  14fa52:	460d      	mov	r5, r1
  14fa54:	4604      	mov	r4, r0
  14fa56:	2b05      	cmp	r3, #5
  14fa58:	d0cf      	beq.n	14f9fa <thread_join+0x2a>
        status_t err = wait_queue_block(&t->retcode_wait_queue, timeout);
  14fa5a:	4611      	mov	r1, r2
  14fa5c:	f500 70aa 	add.w	r0, r0, #340	; 0x154
  14fa60:	f7ff ff82 	bl	14f968 <wait_queue_block>
        if (err < 0) {
  14fa64:	2800      	cmp	r0, #0
  14fa66:	dac8      	bge.n	14f9fa <thread_join+0x2a>
  14fa68:	2300      	movs	r3, #0
  14fa6a:	6033      	str	r3, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  14fa6c:	2f00      	cmp	r7, #0
  14fa6e:	d0e0      	beq.n	14fa32 <thread_join+0x62>
  14fa70:	b662      	cpsie	i
}
  14fa72:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        free(t);
  14fa74:	4620      	mov	r0, r4
  14fa76:	f003 fa41 	bl	152efc <free>
    return NO_ERROR;
  14fa7a:	2000      	movs	r0, #0
}
  14fa7c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    *lock = 0;
  14fa7e:	6033      	str	r3, [r6, #0]
  14fa80:	b662      	cpsie	i
        return ERR_THREAD_DETACHED;
  14fa82:	f06f 0021 	mvn.w	r0, #33	; 0x21
}
  14fa86:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0014fa88 <wait_queue_wake_one>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_one(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
  14fa88:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  14fa8a:	4696      	mov	r14, r2
  14fa8c:	ee1d cf90 	mrc	15, 0, r12, cr13, cr0, {4}
    if (list->next != list) {
  14fa90:	6883      	ldr	r3, [r0, #8]

    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    t = list_remove_head_type(&wait->list, thread_t, queue_node);
  14fa92:	1d02      	adds	r2, r0, #4
  14fa94:	4293      	cmp	r3, r2
  14fa96:	d048      	beq.n	14fb2a <wait_queue_wake_one+0xa2>
    item->next->prev = item->prev;
  14fa98:	685d      	ldr	r5, [r3, #4]
    item->prev = item->next = 0;
  14fa9a:	2200      	movs	r2, #0
    item->next->prev = item->prev;
  14fa9c:	681e      	ldr	r6, [r3, #0]
    item->prev = item->next = 0;
  14fa9e:	461c      	mov	r4, r3
    item->next->prev = item->prev;
  14faa0:	602e      	str	r6, [r5, #0]
    if (t) {
  14faa2:	2b0c      	cmp	r3, #12
    item->prev->next = item->next;
  14faa4:	681e      	ldr	r6, [r3, #0]
  14faa6:	6075      	str	r5, [r6, #4]
    item->prev = item->next = 0;
  14faa8:	605a      	str	r2, [r3, #4]
  14faaa:	f844 290c 	str.w	r2, [r4], #-12
  14faae:	d03c      	beq.n	14fb2a <wait_queue_wake_one+0xa2>
        wait->count--;
  14fab0:	68c5      	ldr	r5, [r0, #12]
  14fab2:	f246 56b4 	movw	r6, #26036	; 0x65b4
  14fab6:	f2c0 0616 	movt	r6, #22
  14faba:	1e6f      	subs	r7, r5, #1
        DEBUG_ASSERT(t->state == THREAD_BLOCKED);
        t->state = THREAD_READY;
  14fabc:	2501      	movs	r5, #1
        wait->count--;
  14fabe:	60c7      	str	r7, [r0, #12]
        t->wait_queue_block_ret = wait_queue_error;
        t->blocking_wait_queue = NULL;
  14fac0:	e9c4 2e09 	strd	r2, r14, [r4, #36]	; 0x24
  14fac4:	6837      	ldr	r7, [r6, #0]
        t->state = THREAD_READY;
  14fac6:	61a5      	str	r5, [r4, #24]

        /* if we're instructed to reschedule, stick the current thread on the head
         * of the run queue first, so that the newly awakened thread gets a chance to run
         * before the current one, but the current one doesn't get unnecessarilly punished.
         */
        if (reschedule) {
  14fac8:	b1e1      	cbz	r1, 14fb04 <wait_queue_wake_one+0x7c>
    return !!(t->flags & THREAD_FLAG_IDLE);
  14faca:	f8dc 2020 	ldr.w	r2, [r12, #32]
            current_thread->state = THREAD_READY;
  14face:	f8cc 5018 	str.w	r5, [r12, #24]
            if (!thread_is_idle(current_thread))
  14fad2:	06d2      	lsls	r2, r2, #27
  14fad4:	bf44      	itt	mi
  14fad6:	f246 42b4 	movwmi	r2, #25780	; 0x64b4
  14fada:	f2c0 0216 	movtmi	r2, #22
  14fade:	d526      	bpl.n	14fb2e <wait_queue_wake_one+0xa6>
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fae0:	6961      	ldr	r1, [r4, #20]
    run_queue_bitmap |= (1<<t->priority);
  14fae2:	2501      	movs	r5, #1
    item->next = list->next;
  14fae4:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
  14fae8:	fa05 f101 	lsl.w	r1, r5, r1
  14faec:	4339      	orrs	r1, r7
  14faee:	6850      	ldr	r0, [r2, #4]
  14faf0:	6120      	str	r0, [r4, #16]
    list->next->prev = item;
  14faf2:	6850      	ldr	r0, [r2, #4]
    item->prev = list;
  14faf4:	60e2      	str	r2, [r4, #12]
    list->next->prev = item;
  14faf6:	6003      	str	r3, [r0, #0]
    list->next = item;
  14faf8:	6053      	str	r3, [r2, #4]
  14fafa:	6031      	str	r1, [r6, #0]
                insert_in_run_queue_head(current_thread);
        }
        insert_in_run_queue_head(t);
        thread_mp_reschedule(current_thread, t);
        if (reschedule) {
            thread_resched();
  14fafc:	f7ff fbda 	bl	14f2b4 <thread_resched>
        }
        ret = 1;
  14fb00:	4628      	mov	r0, r5

    }

    return ret;
}
  14fb02:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fb04:	6960      	ldr	r0, [r4, #20]
    item->next = list->next;
  14fb06:	f246 42b4 	movw	r2, #25780	; 0x64b4
  14fb0a:	f2c0 0216 	movt	r2, #22
    run_queue_bitmap |= (1<<t->priority);
  14fb0e:	fa05 f100 	lsl.w	r1, r5, r0
  14fb12:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
        ret = 1;
  14fb16:	4628      	mov	r0, r5
    run_queue_bitmap |= (1<<t->priority);
  14fb18:	4339      	orrs	r1, r7
  14fb1a:	6855      	ldr	r5, [r2, #4]
  14fb1c:	6125      	str	r5, [r4, #16]
    list->next->prev = item;
  14fb1e:	6855      	ldr	r5, [r2, #4]
  14fb20:	6031      	str	r1, [r6, #0]
    item->prev = list;
  14fb22:	60e2      	str	r2, [r4, #12]
    list->next->prev = item;
  14fb24:	602b      	str	r3, [r5, #0]
    list->next = item;
  14fb26:	6053      	str	r3, [r2, #4]
}
  14fb28:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    int ret = 0;
  14fb2a:	2000      	movs	r0, #0
}
  14fb2c:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fb2e:	f8dc 0014 	ldr.w	r0, [r12, #20]
    item->next = list->next;
  14fb32:	f246 42b4 	movw	r2, #25780	; 0x64b4
  14fb36:	f2c0 0216 	movt	r2, #22
  14fb3a:	f10c 0e0c 	add.w	r14, r12, #12
  14fb3e:	eb02 01c0 	add.w	r1, r2, r0, lsl #3
    run_queue_bitmap |= (1<<t->priority);
  14fb42:	fa05 f000 	lsl.w	r0, r5, r0
  14fb46:	4307      	orrs	r7, r0
  14fb48:	6848      	ldr	r0, [r1, #4]
  14fb4a:	f8cc 0010 	str.w	r0, [r12, #16]
    list->next->prev = item;
  14fb4e:	6848      	ldr	r0, [r1, #4]
    item->prev = list;
  14fb50:	f8cc 100c 	str.w	r1, [r12, #12]
    list->next->prev = item;
  14fb54:	f8c0 e000 	str.w	r14, [r0]
    list->next = item;
  14fb58:	f8c1 e004 	str.w	r14, [r1, #4]
  14fb5c:	e7c0      	b.n	14fae0 <wait_queue_wake_one+0x58>
  14fb5e:	bf00      	nop

0014fb60 <wait_queue_wake_all>:
 * from wait_queue_block().
 *
 * @return  The number of threads woken (zero or one)
 */
int wait_queue_wake_all(wait_queue_t *wait, bool reschedule, status_t wait_queue_error)
{
  14fb60:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  14fb64:	b083      	sub	sp, #12
  14fb66:	9101      	str	r1, [sp, #4]
  14fb68:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}

    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (reschedule && wait->count > 0) {
  14fb6c:	b139      	cbz	r1, 14fb7e <wait_queue_wake_all+0x1e>
  14fb6e:	68c1      	ldr	r1, [r0, #12]
  14fb70:	2900      	cmp	r1, #0
  14fb72:	dd04      	ble.n	14fb7e <wait_queue_wake_all+0x1e>
    return !!(t->flags & THREAD_FLAG_IDLE);
  14fb74:	6a1c      	ldr	r4, [r3, #32]
        /* if we're instructed to reschedule, stick the current thread on the head
         * of the run queue first, so that the newly awakened threads get a chance to run
         * before the current one, but the current one doesn't get unnecessarilly punished.
         */
        current_thread->state = THREAD_READY;
  14fb76:	2101      	movs	r1, #1
  14fb78:	6199      	str	r1, [r3, #24]
        if (!thread_is_idle(current_thread))
  14fb7a:	06e4      	lsls	r4, r4, #27
  14fb7c:	d55a      	bpl.n	14fc34 <wait_queue_wake_all+0xd4>
    if (list->next != list) {
  14fb7e:	6881      	ldr	r1, [r0, #8]
            insert_in_run_queue_head(current_thread);
    }

    /* pop all the threads off the wait queue into the run queue */
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
  14fb80:	f100 0e04 	add.w	r14, r0, #4
  14fb84:	458e      	cmp	r14, r1
  14fb86:	d050      	beq.n	14fc2a <wait_queue_wake_all+0xca>
    item->next->prev = item->prev;
  14fb88:	684e      	ldr	r6, [r1, #4]
    item->prev = item->next = 0;
  14fb8a:	2400      	movs	r4, #0
    item->next->prev = item->prev;
  14fb8c:	680d      	ldr	r5, [r1, #0]
    item->prev = item->next = 0;
  14fb8e:	460b      	mov	r3, r1
    item->next->prev = item->prev;
  14fb90:	6035      	str	r5, [r6, #0]
  14fb92:	290c      	cmp	r1, #12
    item->prev->next = item->next;
  14fb94:	680d      	ldr	r5, [r1, #0]
  14fb96:	606e      	str	r6, [r5, #4]
    item->prev = item->next = 0;
  14fb98:	604c      	str	r4, [r1, #4]
  14fb9a:	f843 490c 	str.w	r4, [r3], #-12
  14fb9e:	d044      	beq.n	14fc2a <wait_queue_wake_all+0xca>
  14fba0:	f246 5bb4 	movw	r11, #26036	; 0x65b4
  14fba4:	f246 4cb4 	movw	r12, #25780	; 0x64b4
  14fba8:	68c1      	ldr	r1, [r0, #12]
  14fbaa:	f2c0 0b16 	movt	r11, #22
        wait->count--;
        DEBUG_ASSERT(t->state == THREAD_BLOCKED);
        t->state = THREAD_READY;
        t->wait_queue_block_ret = wait_queue_error;
        t->blocking_wait_queue = NULL;
  14fbae:	4625      	mov	r5, r4
  14fbb0:	f2c0 0c16 	movt	r12, #22
        t->state = THREAD_READY;
  14fbb4:	2701      	movs	r7, #1
  14fbb6:	f101 38ff 	add.w	r8, r1, #4294967295	; 0xffffffff
  14fbba:	f8db 6000 	ldr.w	r6, [r11]
  14fbbe:	9200      	str	r2, [sp, #0]
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fbc0:	f8d3 9014 	ldr.w	r9, [r3, #20]
  14fbc4:	f103 0a0c 	add.w	r10, r3, #12
        t->wait_queue_block_ret = wait_queue_error;
  14fbc8:	9a00      	ldr	r2, [sp, #0]
  14fbca:	629a      	str	r2, [r3, #40]	; 0x28
        t->state = THREAD_READY;
  14fbcc:	619f      	str	r7, [r3, #24]
    item->next = list->next;
  14fbce:	eb0c 01c9 	add.w	r1, r12, r9, lsl #3
        t->blocking_wait_queue = NULL;
  14fbd2:	625d      	str	r5, [r3, #36]	; 0x24
    run_queue_bitmap |= (1<<t->priority);
  14fbd4:	fa07 f909 	lsl.w	r9, r7, r9
  14fbd8:	684a      	ldr	r2, [r1, #4]
  14fbda:	ea46 0609 	orr.w	r6, r6, r9
  14fbde:	611a      	str	r2, [r3, #16]
  14fbe0:	eba8 0904 	sub.w	r9, r8, r4
    item->prev = list;
  14fbe4:	60d9      	str	r1, [r3, #12]

        insert_in_run_queue_head(t);
        mp_reschedule_target |= thread_get_mp_reschedule_target(current_thread, t);
        ret++;
  14fbe6:	3401      	adds	r4, #1
    list->next->prev = item;
  14fbe8:	684b      	ldr	r3, [r1, #4]
  14fbea:	f8c3 a000 	str.w	r10, [r3]
    list->next = item;
  14fbee:	f8c1 a004 	str.w	r10, [r1, #4]
    if (list->next != list) {
  14fbf2:	6881      	ldr	r1, [r0, #8]
    item->prev = item->next = 0;
  14fbf4:	460b      	mov	r3, r1
    if (list->next != list) {
  14fbf6:	4571      	cmp	r1, r14
  14fbf8:	d00b      	beq.n	14fc12 <wait_queue_wake_all+0xb2>
    item->next->prev = item->prev;
  14fbfa:	e9d1 2a00 	ldrd	r2, r10, [r1]
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
  14fbfe:	290c      	cmp	r1, #12
  14fc00:	f8ca 2000 	str.w	r2, [r10]
    item->prev->next = item->next;
  14fc04:	680a      	ldr	r2, [r1, #0]
  14fc06:	f8c2 a004 	str.w	r10, [r2, #4]
    item->prev = item->next = 0;
  14fc0a:	604d      	str	r5, [r1, #4]
  14fc0c:	f843 590c 	str.w	r5, [r3], #-12
  14fc10:	d1d6      	bne.n	14fbc0 <wait_queue_wake_all+0x60>

    DEBUG_ASSERT(wait->count == 0);

    if (ret > 0) {
        mp_reschedule(mp_reschedule_target, 0);
        if (reschedule) {
  14fc12:	9b01      	ldr	r3, [sp, #4]
  14fc14:	f8c0 900c 	str.w	r9, [r0, #12]
  14fc18:	f8cb 6000 	str.w	r6, [r11]
  14fc1c:	b133      	cbz	r3, 14fc2c <wait_queue_wake_all+0xcc>
            thread_resched();
  14fc1e:	f7ff fb49 	bl	14f2b4 <thread_resched>
        }
    }

    return ret;
}
  14fc22:	4620      	mov	r0, r4
  14fc24:	b003      	add	sp, #12
  14fc26:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    while ((t = list_remove_head_type(&wait->list, thread_t, queue_node))) {
  14fc2a:	2400      	movs	r4, #0
}
  14fc2c:	4620      	mov	r0, r4
  14fc2e:	b003      	add	sp, #12
  14fc30:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fc34:	695f      	ldr	r7, [r3, #20]
    run_queue_bitmap |= (1<<t->priority);
  14fc36:	f246 56b4 	movw	r6, #26036	; 0x65b4
    item->next = list->next;
  14fc3a:	f246 4cb4 	movw	r12, #25780	; 0x64b4
  14fc3e:	f2c0 0616 	movt	r6, #22
  14fc42:	f2c0 0c16 	movt	r12, #22
  14fc46:	eb0c 04c7 	add.w	r4, r12, r7, lsl #3
  14fc4a:	6835      	ldr	r5, [r6, #0]
  14fc4c:	40b9      	lsls	r1, r7
  14fc4e:	4329      	orrs	r1, r5
  14fc50:	6865      	ldr	r5, [r4, #4]
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fc52:	f103 070c 	add.w	r7, r3, #12
  14fc56:	611d      	str	r5, [r3, #16]
    list->next->prev = item;
  14fc58:	6865      	ldr	r5, [r4, #4]
    run_queue_bitmap |= (1<<t->priority);
  14fc5a:	6031      	str	r1, [r6, #0]
    item->prev = list;
  14fc5c:	60dc      	str	r4, [r3, #12]
    list->next->prev = item;
  14fc5e:	602f      	str	r7, [r5, #0]
    list->next = item;
  14fc60:	6067      	str	r7, [r4, #4]
  14fc62:	e78c      	b.n	14fb7e <wait_queue_wake_all+0x1e>

0014fc64 <thread_detach>:
{
  14fc64:	b570      	push	{r4, r5, r6, r14}
  14fc66:	4604      	mov	r4, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14fc68:	f3ef 8100 	mrs	r1, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14fc6c:	f011 0580 	ands.w	r5, r1, #128	; 0x80
  14fc70:	f500 70aa 	add.w	r0, r0, #340	; 0x154
  14fc74:	d116      	bne.n	14fca4 <thread_detach+0x40>
    __asm__ volatile("cpsid i");
  14fc76:	b672      	cpsid	i
    *lock = 1;
  14fc78:	f246 56c0 	movw	r6, #26048	; 0x65c0
  14fc7c:	2301      	movs	r3, #1
    wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
  14fc7e:	4629      	mov	r1, r5
  14fc80:	f2c0 0616 	movt	r6, #22
  14fc84:	f06f 0221 	mvn.w	r2, #33	; 0x21
  14fc88:	6033      	str	r3, [r6, #0]
  14fc8a:	f7ff ff69 	bl	14fb60 <wait_queue_wake_all>
    if (t->state == THREAD_DEATH) {
  14fc8e:	69a3      	ldr	r3, [r4, #24]
  14fc90:	2b05      	cmp	r3, #5
  14fc92:	d01d      	beq.n	14fcd0 <thread_detach+0x6c>
        t->flags |= THREAD_FLAG_DETACHED;
  14fc94:	6a23      	ldr	r3, [r4, #32]
    *lock = 0;
  14fc96:	6035      	str	r5, [r6, #0]
  14fc98:	f043 0301 	orr.w	r3, r3, #1
  14fc9c:	6223      	str	r3, [r4, #32]
    __asm__ volatile("cpsie i");
  14fc9e:	b662      	cpsie	i
}
  14fca0:	2000      	movs	r0, #0
  14fca2:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 1;
  14fca4:	f246 55c0 	movw	r5, #26048	; 0x65c0
  14fca8:	2301      	movs	r3, #1
  14fcaa:	f2c0 0516 	movt	r5, #22
    wait_queue_wake_all(&t->retcode_wait_queue, false, ERR_THREAD_DETACHED);
  14fcae:	2100      	movs	r1, #0
  14fcb0:	f06f 0221 	mvn.w	r2, #33	; 0x21
  14fcb4:	602b      	str	r3, [r5, #0]
  14fcb6:	f7ff ff53 	bl	14fb60 <wait_queue_wake_all>
    if (t->state == THREAD_DEATH) {
  14fcba:	69a3      	ldr	r3, [r4, #24]
  14fcbc:	2b05      	cmp	r3, #5
  14fcbe:	d014      	beq.n	14fcea <thread_detach+0x86>
        t->flags |= THREAD_FLAG_DETACHED;
  14fcc0:	6a23      	ldr	r3, [r4, #32]
    *lock = 0;
  14fcc2:	2200      	movs	r2, #0
}
  14fcc4:	2000      	movs	r0, #0
  14fcc6:	602a      	str	r2, [r5, #0]
        t->flags |= THREAD_FLAG_DETACHED;
  14fcc8:	f043 0301 	orr.w	r3, r3, #1
  14fccc:	6223      	str	r3, [r4, #32]
}
  14fcce:	bd70      	pop	{r4, r5, r6, r15}
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
  14fcd0:	6a23      	ldr	r3, [r4, #32]
  14fcd2:	6035      	str	r5, [r6, #0]
  14fcd4:	f023 0301 	bic.w	r3, r3, #1
  14fcd8:	6223      	str	r3, [r4, #32]
  14fcda:	b662      	cpsie	i
        return thread_join(t, NULL, 0);
  14fcdc:	2200      	movs	r2, #0
  14fcde:	4620      	mov	r0, r4
  14fce0:	4611      	mov	r1, r2
}
  14fce2:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        return thread_join(t, NULL, 0);
  14fce6:	f7ff be73 	b.w	14f9d0 <thread_join>
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
  14fcea:	6a23      	ldr	r3, [r4, #32]
  14fcec:	2200      	movs	r2, #0
        return thread_join(t, NULL, 0);
  14fcee:	4620      	mov	r0, r4
  14fcf0:	602a      	str	r2, [r5, #0]
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
  14fcf2:	f023 0301 	bic.w	r3, r3, #1
        return thread_join(t, NULL, 0);
  14fcf6:	2200      	movs	r2, #0
        t->flags &= ~THREAD_FLAG_DETACHED; /* makes sure thread_join continues */
  14fcf8:	6223      	str	r3, [r4, #32]
        return thread_join(t, NULL, 0);
  14fcfa:	4611      	mov	r1, r2
}
  14fcfc:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        return thread_join(t, NULL, 0);
  14fd00:	f7ff be66 	b.w	14f9d0 <thread_join>

0014fd04 <thread_detach_and_resume>:
{
  14fd04:	b510      	push	{r4, r14}
  14fd06:	4604      	mov	r4, r0
    err = thread_detach(t);
  14fd08:	f7ff ffac 	bl	14fc64 <thread_detach>
    if (err < 0)
  14fd0c:	2800      	cmp	r0, #0
  14fd0e:	db04      	blt.n	14fd1a <thread_detach_and_resume+0x16>
    return thread_resume(t);
  14fd10:	4620      	mov	r0, r4
}
  14fd12:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
    return thread_resume(t);
  14fd16:	f7ff bcdf 	b.w	14f6d8 <thread_resume>
}
  14fd1a:	bd10      	pop	{r4, r15}

0014fd1c <thread_exit>:
{
  14fd1c:	b508      	push	{r3, r14}
  14fd1e:	4675      	mov	r5, r14
  14fd20:	ee1d 4f90 	mrc	15, 0, r4, cr13, cr0, {4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14fd24:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14fd28:	0619      	lsls	r1, r3, #24
  14fd2a:	d400      	bmi.n	14fd2e <thread_exit+0x12>
    __asm__ volatile("cpsid i");
  14fd2c:	b672      	cpsid	i
    *lock = 1;
  14fd2e:	f246 52c0 	movw	r2, #26048	; 0x65c0
  14fd32:	2601      	movs	r6, #1
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
  14fd34:	6a23      	ldr	r3, [r4, #32]
  14fd36:	f2c0 0216 	movt	r2, #22
    current_thread->retcode = retcode;
  14fd3a:	f8c4 0150 	str.w	r0, [r4, #336]	; 0x150
    current_thread->state = THREAD_DEATH;
  14fd3e:	2105      	movs	r1, #5
  14fd40:	6016      	str	r6, [r2, #0]
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
  14fd42:	ea13 0206 	ands.w	r2, r3, r6
    current_thread->state = THREAD_DEATH;
  14fd46:	61a1      	str	r1, [r4, #24]
    if (current_thread->flags & THREAD_FLAG_DETACHED) {
  14fd48:	d022      	beq.n	14fd90 <thread_exit+0x74>
    item->next->prev = item->prev;
  14fd4a:	6860      	ldr	r0, [r4, #4]
    item->prev = item->next = 0;
  14fd4c:	2200      	movs	r2, #0
    item->next->prev = item->prev;
  14fd4e:	68a1      	ldr	r1, [r4, #8]
  14fd50:	6008      	str	r0, [r1, #0]
    item->prev->next = item->next;
  14fd52:	6860      	ldr	r0, [r4, #4]
  14fd54:	6041      	str	r1, [r0, #4]
    item->prev = item->next = 0;
  14fd56:	e9c4 2201 	strd	r2, r2, [r4, #4]
        current_thread->magic = 0;
  14fd5a:	6022      	str	r2, [r4, #0]
        if (current_thread->flags & THREAD_FLAG_FREE_STACK && current_thread->stack) {
  14fd5c:	079a      	lsls	r2, r3, #30
  14fd5e:	d508      	bpl.n	14fd72 <thread_exit+0x56>
  14fd60:	f8d4 0140 	ldr.w	r0, [r4, #320]	; 0x140
  14fd64:	b128      	cbz	r0, 14fd72 <thread_exit+0x56>
            heap_delayed_free(current_thread->stack);
  14fd66:	f003 f8cb 	bl	152f00 <heap_delayed_free>
            current_thread->flags &= ~THREAD_FLAG_DEBUG_STACK_BOUNDS_CHECK;
  14fd6a:	6a23      	ldr	r3, [r4, #32]
  14fd6c:	f023 0320 	bic.w	r3, r3, #32
  14fd70:	6223      	str	r3, [r4, #32]
        if (current_thread->flags & THREAD_FLAG_FREE_STRUCT)
  14fd72:	075b      	lsls	r3, r3, #29
  14fd74:	d408      	bmi.n	14fd88 <thread_exit+0x6c>
    thread_resched();
  14fd76:	f7ff fa9d 	bl	14f2b4 <thread_resched>
    panic("somehow fell through thread_exit()\n");
  14fd7a:	f248 0184 	movw	r1, #32900	; 0x8084
  14fd7e:	4628      	mov	r0, r5
  14fd80:	f2c0 0115 	movt	r1, #21
  14fd84:	f002 ff96 	bl	152cb4 <_panic>
            heap_delayed_free(current_thread);
  14fd88:	4620      	mov	r0, r4
  14fd8a:	f003 f8b9 	bl	152f00 <heap_delayed_free>
  14fd8e:	e7f2      	b.n	14fd76 <thread_exit+0x5a>
        wait_queue_wake_all(&current_thread->retcode_wait_queue, false, 0);
  14fd90:	4611      	mov	r1, r2
  14fd92:	f504 70aa 	add.w	r0, r4, #340	; 0x154
  14fd96:	f7ff fee3 	bl	14fb60 <wait_queue_wake_all>
  14fd9a:	e7ec      	b.n	14fd76 <thread_exit+0x5a>

0014fd9c <wait_queue_destroy>:
 * @brief  Free all resources allocated in wait_queue_init()
 *
 * If any threads were waiting on this queue, they are all woken.
 */
void wait_queue_destroy(wait_queue_t *wait, bool reschedule)
{
  14fd9c:	b510      	push	{r4, r14}
  14fd9e:	4604      	mov	r4, r0
    DEBUG_ASSERT(wait->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    wait_queue_wake_all(wait, reschedule, ERR_OBJECT_DESTROYED);
  14fda0:	f06f 020a 	mvn.w	r2, #10
  14fda4:	f7ff fedc 	bl	14fb60 <wait_queue_wake_all>
    wait->magic = 0;
  14fda8:	2300      	movs	r3, #0
  14fdaa:	6023      	str	r3, [r4, #0]
}
  14fdac:	bd10      	pop	{r4, r15}
  14fdae:	bf00      	nop

0014fdb0 <thread_unblock_from_wait_queue>:
{
    DEBUG_ASSERT(t->magic == THREAD_MAGIC);
    DEBUG_ASSERT(arch_ints_disabled());
    DEBUG_ASSERT(spin_lock_held(&thread_lock));

    if (t->state != THREAD_BLOCKED)
  14fdb0:	6983      	ldr	r3, [r0, #24]
  14fdb2:	2b03      	cmp	r3, #3
  14fdb4:	d135      	bne.n	14fe22 <thread_unblock_from_wait_queue+0x72>
{
  14fdb6:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    DEBUG_ASSERT(t->blocking_wait_queue != NULL);
    DEBUG_ASSERT(t->blocking_wait_queue->magic == WAIT_QUEUE_MAGIC);
    DEBUG_ASSERT(list_in_list(&t->queue_node));

    list_delete(&t->queue_node);
    t->blocking_wait_queue->count--;
  14fdba:	6a47      	ldr	r7, [r0, #36]	; 0x24
    item->next = list->next;
  14fdbc:	f246 43b4 	movw	r3, #25780	; 0x64b4
    list_add_head(&run_queue[t->priority], &t->queue_node);
  14fdc0:	6942      	ldr	r2, [r0, #20]
    run_queue_bitmap |= (1<<t->priority);
  14fdc2:	f246 56b4 	movw	r6, #26036	; 0x65b4
    item->next->prev = item->prev;
  14fdc6:	f8d0 8010 	ldr.w	r8, [r0, #16]
    item->next = list->next;
  14fdca:	f2c0 0316 	movt	r3, #22
    t->blocking_wait_queue->count--;
  14fdce:	68fc      	ldr	r4, [r7, #12]
    run_queue_bitmap |= (1<<t->priority);
  14fdd0:	f2c0 0616 	movt	r6, #22
    t->blocking_wait_queue = NULL;
    t->state = THREAD_READY;
  14fdd4:	f04f 0c01 	mov.w	r12, #1
  14fdd8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
    t->blocking_wait_queue->count--;
  14fddc:	1e65      	subs	r5, r4, #1
    item->next->prev = item->prev;
  14fdde:	68c4      	ldr	r4, [r0, #12]
  14fde0:	f8c8 4000 	str.w	r4, [r8]
    item->prev = item->next = 0;
  14fde4:	2400      	movs	r4, #0
    run_queue_bitmap |= (1<<t->priority);
  14fde6:	fa0c fe02 	lsl.w	r14, r12, r2
    item->prev->next = item->next;
  14fdea:	68c2      	ldr	r2, [r0, #12]
  14fdec:	f8c2 8004 	str.w	r8, [r2, #4]
    item->prev = item->next = 0;
  14fdf0:	6104      	str	r4, [r0, #16]
    item->next = list->next;
  14fdf2:	f8d3 8004 	ldr.w	r8, [r3, #4]
    t->blocking_wait_queue->count--;
  14fdf6:	60fd      	str	r5, [r7, #12]
    list_delete(&t->queue_node);
  14fdf8:	f100 070c 	add.w	r7, r0, #12
    run_queue_bitmap |= (1<<t->priority);
  14fdfc:	6835      	ldr	r5, [r6, #0]
  14fdfe:	f8c0 8010 	str.w	r8, [r0, #16]
  14fe02:	ea4e 0205 	orr.w	r2, r14, r5
    list->next->prev = item;
  14fe06:	685d      	ldr	r5, [r3, #4]
  14fe08:	6032      	str	r2, [r6, #0]
    item->prev = list;
  14fe0a:	60c3      	str	r3, [r0, #12]
    t->wait_queue_block_ret = wait_queue_error;
  14fe0c:	e9c0 4109 	strd	r4, r1, [r0, #36]	; 0x24
    t->state = THREAD_READY;
  14fe10:	f8c0 c018 	str.w	r12, [r0, #24]
    list->next->prev = item;
  14fe14:	602f      	str	r7, [r5, #0]
    list->next = item;
  14fe16:	605f      	str	r7, [r3, #4]
  14fe18:	ee1d 3f90 	mrc	15, 0, r3, cr13, cr0, {4}
    insert_in_run_queue_head(t);
    thread_mp_reschedule(get_current_thread(), t);

    return NO_ERROR;
  14fe1c:	4620      	mov	r0, r4
}
  14fe1e:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return ERR_NOT_BLOCKED;
  14fe22:	f06f 000b 	mvn.w	r0, #11
}
  14fe26:	4770      	bx	r14

0014fe28 <wait_queue_timeout_handler>:
{
  14fe28:	b510      	push	{r4, r14}
  14fe2a:	f246 54c0 	movw	r4, #26048	; 0x65c0
  14fe2e:	2301      	movs	r3, #1
    if (thread_unblock_from_wait_queue(thread, ERR_TIMED_OUT) >= NO_ERROR) {
  14fe30:	4610      	mov	r0, r2
  14fe32:	f2c0 0416 	movt	r4, #22
  14fe36:	f06f 010c 	mvn.w	r1, #12
  14fe3a:	6023      	str	r3, [r4, #0]
  14fe3c:	f7ff ffb8 	bl	14fdb0 <thread_unblock_from_wait_queue>
    *lock = 0;
  14fe40:	2300      	movs	r3, #0
  14fe42:	6023      	str	r3, [r4, #0]
}
  14fe44:	4298      	cmp	r0, r3
  14fe46:	bfb4      	ite	lt
  14fe48:	2000      	movlt	r0, #0
  14fe4a:	2001      	movge	r0, #1
  14fe4c:	bd10      	pop	{r4, r15}
  14fe4e:	bf00      	nop

0014fe50 <insert_timer_in_queue.constprop.2>:
void timer_initialize(timer_t *timer)
{
    *timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
}

static void insert_timer_in_queue(uint cpu, timer_t *timer)
  14fe50:	b430      	push	{r4, r5}

    DEBUG_ASSERT(arch_ints_disabled());

    LTRACEF("timer %p, cpu %u, scheduled %u, periodic %u\n", timer, cpu, timer->scheduled_time, timer->periodic_time);

    list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
  14fe52:	f246 6400 	movw	r4, #26112	; 0x6600
  14fe56:	f2c0 0416 	movt	r4, #22
  14fe5a:	6863      	ldr	r3, [r4, #4]
  14fe5c:	4619      	mov	r1, r3
  14fe5e:	42a3      	cmp	r3, r4
  14fe60:	d010      	beq.n	14fe84 <insert_timer_in_queue.constprop.2+0x34>
        if (TIME_GT(entry->scheduled_time, timer->scheduled_time)) {
  14fe62:	68c5      	ldr	r5, [r0, #12]
  14fe64:	3b04      	subs	r3, #4
  14fe66:	68da      	ldr	r2, [r3, #12]
  14fe68:	1b52      	subs	r2, r2, r5
  14fe6a:	2a00      	cmp	r2, #0
  14fe6c:	dd04      	ble.n	14fe78 <insert_timer_in_queue.constprop.2+0x28>
  14fe6e:	e011      	b.n	14fe94 <insert_timer_in_queue.constprop.2+0x44>
  14fe70:	68da      	ldr	r2, [r3, #12]
  14fe72:	1b52      	subs	r2, r2, r5
  14fe74:	2a00      	cmp	r2, #0
  14fe76:	dc0d      	bgt.n	14fe94 <insert_timer_in_queue.constprop.2+0x44>
    list_for_every_entry(&timers[cpu].timer_queue, entry, timer_t, node) {
  14fe78:	689b      	ldr	r3, [r3, #8]
  14fe7a:	4619      	mov	r1, r3
  14fe7c:	42a1      	cmp	r1, r4
  14fe7e:	f1a3 0304 	sub.w	r3, r3, #4
  14fe82:	d1f5      	bne.n	14fe70 <insert_timer_in_queue.constprop.2+0x20>
    item->prev = list->prev;
  14fe84:	6823      	ldr	r3, [r4, #0]
            return;
        }
    }

    /* walked off the end of the list */
    list_add_tail(&timers[cpu].timer_queue, &timer->node);
  14fe86:	1d02      	adds	r2, r0, #4
  14fe88:	e9c0 3401 	strd	r3, r4, [r0, #4]
    list->prev = item;
  14fe8c:	6022      	str	r2, [r4, #0]
    list->prev->next = item;
  14fe8e:	605a      	str	r2, [r3, #4]
}
  14fe90:	bc30      	pop	{r4, r5}
  14fe92:	4770      	bx	r14
    item->prev = list->prev;
  14fe94:	685c      	ldr	r4, [r3, #4]
            list_add_before(&entry->node, &timer->node);
  14fe96:	1d02      	adds	r2, r0, #4
  14fe98:	6044      	str	r4, [r0, #4]
    list->prev->next = item;
  14fe9a:	685c      	ldr	r4, [r3, #4]
    item->next = list;
  14fe9c:	6081      	str	r1, [r0, #8]
    list->prev->next = item;
  14fe9e:	6062      	str	r2, [r4, #4]
    list->prev = item;
  14fea0:	605a      	str	r2, [r3, #4]
}
  14fea2:	bc30      	pop	{r4, r5}
  14fea4:	4770      	bx	r14
  14fea6:	bf00      	nop

0014fea8 <timer_tick>:
    spin_unlock_irqrestore(&timer_lock, state);
}

/* called at interrupt time to process any pending timers */
static enum handler_return timer_tick(void *arg, lk_time_t now)
{
  14fea8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    timer_t *timer;
    enum handler_return ret = INT_NO_RESCHEDULE;

    DEBUG_ASSERT(arch_ints_disabled());

    THREAD_STATS_INC(timer_ints);
  14feac:	f246 55c8 	movw	r5, #26056	; 0x65c8
    *lock = 1;
  14feb0:	2201      	movs	r2, #1
  14feb2:	f246 54f8 	movw	r4, #26104	; 0x65f8
  14feb6:	f2c0 0516 	movt	r5, #22
    enum handler_return ret = INT_NO_RESCHEDULE;
  14feba:	2700      	movs	r7, #0
  14febc:	f246 6600 	movw	r6, #26112	; 0x6600
  14fec0:	f2c0 0416 	movt	r4, #22
    THREAD_STATS_INC(timer_ints);
  14fec4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
{
  14fec6:	b083      	sub	sp, #12
  14fec8:	4688      	mov	r8, r1
  14feca:	f2c0 0616 	movt	r6, #22
  14fece:	4693      	mov	r11, r2
    THREAD_STATS_INC(timer_ints);
  14fed0:	4413      	add	r3, r2
  14fed2:	6022      	str	r2, [r4, #0]
    item->prev = item->next = 0;
  14fed4:	46ba      	mov	r10, r7
  14fed6:	626b      	str	r3, [r5, #36]	; 0x24
    if (list->next != list) {
  14fed8:	6873      	ldr	r3, [r6, #4]
  14feda:	42b3      	cmp	r3, r6

    spin_lock(&timer_lock);

    for (;;) {
        /* see if there's an event to process */
        timer = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
  14fedc:	f1a3 0904 	sub.w	r9, r3, #4
  14fee0:	d002      	beq.n	14fee8 <timer_tick+0x40>
  14fee2:	b10b      	cbz	r3, 14fee8 <timer_tick+0x40>
        if (likely(timer == 0))
  14fee4:	2b04      	cmp	r3, #4
  14fee6:	d105      	bne.n	14fef4 <timer_tick+0x4c>
    *lock = 0;
  14fee8:	2300      	movs	r3, #0
    if (thread_timer_tick() == INT_RESCHEDULE)
        ret = INT_RESCHEDULE;
#endif

    return ret;
}
  14feea:	4638      	mov	r0, r7
  14feec:	6023      	str	r3, [r4, #0]
  14feee:	b003      	add	sp, #12
  14fef0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (likely(TIME_LT(now, timer->scheduled_time)))
  14fef4:	f8d9 200c 	ldr.w	r2, [r9, #12]
  14fef8:	eba8 0302 	sub.w	r3, r8, r2
  14fefc:	2b00      	cmp	r3, #0
  14fefe:	da09      	bge.n	14ff14 <timer_tick+0x6c>
        platform_set_oneshot_timer(timer_tick, NULL, delay);
  14ff00:	f64f 60a9 	movw	r0, #65193	; 0xfea9
  14ff04:	eba2 0208 	sub.w	r2, r2, r8
  14ff08:	2100      	movs	r1, #0
  14ff0a:	f2c0 0014 	movt	r0, #20
  14ff0e:	f7f0 fcd7 	bl	1408c0 <platform_set_oneshot_timer>
  14ff12:	e7e9      	b.n	14fee8 <timer_tick+0x40>
        THREAD_STATS_INC(timers);
  14ff14:	6aab      	ldr	r3, [r5, #40]	; 0x28
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
  14ff16:	4641      	mov	r1, r8
    item->next->prev = item->prev;
  14ff18:	f8d9 2008 	ldr.w	r2, [r9, #8]
  14ff1c:	4648      	mov	r0, r9
        THREAD_STATS_INC(timers);
  14ff1e:	f103 0c01 	add.w	r12, r3, #1
  14ff22:	f8d9 3004 	ldr.w	r3, [r9, #4]
  14ff26:	6013      	str	r3, [r2, #0]
    item->prev->next = item->next;
  14ff28:	f8d9 3004 	ldr.w	r3, [r9, #4]
  14ff2c:	605a      	str	r2, [r3, #4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
  14ff2e:	f8d9 3014 	ldr.w	r3, [r9, #20]
  14ff32:	9300      	str	r3, [sp, #0]
        bool periodic = timer->periodic_time > 0;
  14ff34:	f8d9 3010 	ldr.w	r3, [r9, #16]
    item->prev = item->next = 0;
  14ff38:	e9c9 aa01 	strd	r10, r10, [r9, #4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
  14ff3c:	f8d9 2018 	ldr.w	r2, [r9, #24]
        bool periodic = timer->periodic_time > 0;
  14ff40:	9301      	str	r3, [sp, #4]
  14ff42:	f8c4 a000 	str.w	r10, [r4]
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
  14ff46:	9b00      	ldr	r3, [sp, #0]
        THREAD_STATS_INC(timers);
  14ff48:	f8c5 c028 	str.w	r12, [r5, #40]	; 0x28
        if (timer->callback(timer, now, timer->arg) == INT_RESCHEDULE)
  14ff4c:	4798      	blx	r3
        if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
  14ff4e:	9b01      	ldr	r3, [sp, #4]
    *lock = 1;
  14ff50:	f8c4 b000 	str.w	r11, [r4]
            ret = INT_RESCHEDULE;
  14ff54:	2801      	cmp	r0, #1
  14ff56:	bf08      	it	eq
  14ff58:	2701      	moveq	r7, #1
        if (periodic && !list_in_list(&timer->node) && timer->periodic_time > 0) {
  14ff5a:	2b00      	cmp	r3, #0
  14ff5c:	d0bc      	beq.n	14fed8 <timer_tick+0x30>
    if (item->prev == 0 && item->next == 0)
  14ff5e:	f8d9 3004 	ldr.w	r3, [r9, #4]
  14ff62:	2b00      	cmp	r3, #0
  14ff64:	d1b8      	bne.n	14fed8 <timer_tick+0x30>
  14ff66:	f8d9 3008 	ldr.w	r3, [r9, #8]
  14ff6a:	2b00      	cmp	r3, #0
  14ff6c:	d1b4      	bne.n	14fed8 <timer_tick+0x30>
  14ff6e:	f8d9 3010 	ldr.w	r3, [r9, #16]
  14ff72:	2b00      	cmp	r3, #0
  14ff74:	d0b0      	beq.n	14fed8 <timer_tick+0x30>
            insert_timer_in_queue(cpu, timer);
  14ff76:	4648      	mov	r0, r9
            timer->scheduled_time = now + timer->periodic_time;
  14ff78:	4443      	add	r3, r8
  14ff7a:	f8c9 300c 	str.w	r3, [r9, #12]
            insert_timer_in_queue(cpu, timer);
  14ff7e:	f7ff ff67 	bl	14fe50 <insert_timer_in_queue.constprop.2>
  14ff82:	e7a9      	b.n	14fed8 <timer_tick+0x30>

0014ff84 <timer_set>:
{
  14ff84:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  14ff88:	460e      	mov	r6, r1
  14ff8a:	4604      	mov	r4, r0
  14ff8c:	6841      	ldr	r1, [r0, #4]
  14ff8e:	2900      	cmp	r1, #0
  14ff90:	d15c      	bne.n	15004c <timer_set+0xc8>
  14ff92:	6887      	ldr	r7, [r0, #8]
  14ff94:	2f00      	cmp	r7, #0
  14ff96:	d159      	bne.n	15004c <timer_set+0xc8>
  14ff98:	461d      	mov	r5, r3
  14ff9a:	4690      	mov	r8, r2
    now = current_time();
  14ff9c:	f7f0 fce0 	bl	140960 <current_time>
    timer->arg = arg;
  14ffa0:	9b06      	ldr	r3, [sp, #24]
    timer->callback = callback;
  14ffa2:	e9c4 8504 	strd	r8, r5, [r4, #16]
    timer->arg = arg;
  14ffa6:	61a3      	str	r3, [r4, #24]
    timer->scheduled_time = now + delay;
  14ffa8:	4430      	add	r0, r6
  14ffaa:	60e0      	str	r0, [r4, #12]
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  14ffac:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  14ffb0:	f013 0880 	ands.w	r8, r3, #128	; 0x80
  14ffb4:	d11e      	bne.n	14fff4 <timer_set+0x70>
    __asm__ volatile("cpsid i");
  14ffb6:	b672      	cpsid	i
    *lock = 1;
  14ffb8:	f246 55f8 	movw	r5, #26104	; 0x65f8
  14ffbc:	2701      	movs	r7, #1
    insert_timer_in_queue(cpu, timer);
  14ffbe:	4620      	mov	r0, r4
  14ffc0:	f2c0 0516 	movt	r5, #22
  14ffc4:	602f      	str	r7, [r5, #0]
  14ffc6:	f7ff ff43 	bl	14fe50 <insert_timer_in_queue.constprop.2>
    if (list->next != list) {
  14ffca:	f246 6300 	movw	r3, #26112	; 0x6600
  14ffce:	f2c0 0316 	movt	r3, #22
  14ffd2:	685a      	ldr	r2, [r3, #4]
  14ffd4:	1ad3      	subs	r3, r2, r3
  14ffd6:	bf18      	it	ne
  14ffd8:	2301      	movne	r3, #1
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
  14ffda:	2a00      	cmp	r2, #0
  14ffdc:	bf08      	it	eq
  14ffde:	2300      	moveq	r3, #0
  14ffe0:	b36b      	cbz	r3, 15003e <timer_set+0xba>
  14ffe2:	3a04      	subs	r2, #4
  14ffe4:	4294      	cmp	r4, r2
    *lock = 0;
  14ffe6:	bf18      	it	ne
  14ffe8:	f8c5 8000 	strne.w	r8, [r5]
  14ffec:	d01a      	beq.n	150024 <timer_set+0xa0>
    __asm__ volatile("cpsie i");
  14ffee:	b662      	cpsie	i
}
  14fff0:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    *lock = 1;
  14fff4:	f246 55f8 	movw	r5, #26104	; 0x65f8
  14fff8:	2301      	movs	r3, #1
    insert_timer_in_queue(cpu, timer);
  14fffa:	4620      	mov	r0, r4
  14fffc:	f2c0 0516 	movt	r5, #22
  150000:	602b      	str	r3, [r5, #0]
  150002:	f7ff ff25 	bl	14fe50 <insert_timer_in_queue.constprop.2>
  150006:	f246 6300 	movw	r3, #26112	; 0x6600
  15000a:	f2c0 0316 	movt	r3, #22
  15000e:	685a      	ldr	r2, [r3, #4]
  150010:	1ad3      	subs	r3, r2, r3
  150012:	bf18      	it	ne
  150014:	2301      	movne	r3, #1
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
  150016:	2a00      	cmp	r2, #0
  150018:	bf08      	it	eq
  15001a:	2300      	moveq	r3, #0
  15001c:	b98b      	cbnz	r3, 150042 <timer_set+0xbe>
    *lock = 0;
  15001e:	602b      	str	r3, [r5, #0]
}
  150020:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        platform_set_oneshot_timer(timer_tick, NULL, delay);
  150024:	f64f 60a9 	movw	r0, #65193	; 0xfea9
  150028:	4632      	mov	r2, r6
  15002a:	2100      	movs	r1, #0
  15002c:	f2c0 0014 	movt	r0, #20
  150030:	f7f0 fc46 	bl	1408c0 <platform_set_oneshot_timer>
  150034:	2300      	movs	r3, #0
  150036:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  150038:	2f00      	cmp	r7, #0
  15003a:	d1d8      	bne.n	14ffee <timer_set+0x6a>
  15003c:	e7f0      	b.n	150020 <timer_set+0x9c>
    *lock = 0;
  15003e:	602b      	str	r3, [r5, #0]
  150040:	e7d5      	b.n	14ffee <timer_set+0x6a>
    if (list_peek_head_type(&timers[cpu].timer_queue, timer_t, node) == timer) {
  150042:	3a04      	subs	r2, #4
  150044:	4294      	cmp	r4, r2
  150046:	d0ed      	beq.n	150024 <timer_set+0xa0>
  150048:	602f      	str	r7, [r5, #0]
  15004a:	e7e9      	b.n	150020 <timer_set+0x9c>
        panic("timer %p already in list\n", timer);
  15004c:	f248 01e4 	movw	r1, #32996	; 0x80e4
  150050:	4622      	mov	r2, r4
  150052:	4670      	mov	r0, r14
  150054:	f2c0 0115 	movt	r1, #21
  150058:	f002 fe2c 	bl	152cb4 <_panic>

0015005c <timer_initialize>:
    *timer = (timer_t)TIMER_INITIAL_VALUE(*timer);
  15005c:	f646 5272 	movw	r2, #28018	; 0x6d72
  150060:	2300      	movs	r3, #0
  150062:	f2c7 4269 	movt	r2, #29801	; 0x7469
  150066:	e9c0 3302 	strd	r3, r3, [r0, #8]
  15006a:	e9c0 2300 	strd	r2, r3, [r0]
  15006e:	e9c0 3304 	strd	r3, r3, [r0, #16]
  150072:	6183      	str	r3, [r0, #24]
}
  150074:	4770      	bx	r14
  150076:	bf00      	nop

00150078 <timer_set_oneshot>:
{
  150078:	b500      	push	{r14}
  15007a:	b083      	sub	sp, #12
    timer_set(timer, delay, 0, callback, arg);
  15007c:	2900      	cmp	r1, #0
  15007e:	bf08      	it	eq
  150080:	2101      	moveq	r1, #1
  150082:	9300      	str	r3, [sp, #0]
  150084:	4613      	mov	r3, r2
  150086:	2200      	movs	r2, #0
  150088:	f7ff ff7c 	bl	14ff84 <timer_set>
}
  15008c:	b003      	add	sp, #12
  15008e:	f85d fb04 	ldr.w	r15, [r13], #4
  150092:	bf00      	nop

00150094 <timer_set_periodic>:
{
  150094:	b510      	push	{r4, r14}
  150096:	b082      	sub	sp, #8
        period = 1;
  150098:	2900      	cmp	r1, #0
  15009a:	bf14      	ite	ne
  15009c:	460c      	movne	r4, r1
  15009e:	2401      	moveq	r4, #1
    timer_set(timer, period, period, callback, arg);
  1500a0:	9300      	str	r3, [sp, #0]
  1500a2:	4621      	mov	r1, r4
  1500a4:	4613      	mov	r3, r2
  1500a6:	4622      	mov	r2, r4
  1500a8:	f7ff ff6c 	bl	14ff84 <timer_set>
}
  1500ac:	b002      	add	sp, #8
  1500ae:	bd10      	pop	{r4, r15}

001500b0 <timer_cancel>:
{
  1500b0:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1500b2:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1500b6:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1500b8:	bf48      	it	mi
  1500ba:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1500bc:	d401      	bmi.n	1500c2 <timer_cancel+0x12>
    __asm__ volatile("cpsid i");
  1500be:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1500c0:	2701      	movs	r7, #1
  1500c2:	f246 6200 	movw	r2, #26112	; 0x6600
    *lock = 1;
  1500c6:	f246 55f8 	movw	r5, #26104	; 0x65f8
  1500ca:	2101      	movs	r1, #1
  1500cc:	f2c0 0216 	movt	r2, #22
  1500d0:	e9d0 6401 	ldrd	r6, r4, [r0, #4]
  1500d4:	f2c0 0516 	movt	r5, #22
  1500d8:	6853      	ldr	r3, [r2, #4]
  1500da:	6029      	str	r1, [r5, #0]
    timer_t *oldhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
  1500dc:	4293      	cmp	r3, r2
  1500de:	bf18      	it	ne
  1500e0:	2b00      	cmpne	r3, #0
  1500e2:	bf0b      	itete	eq
  1500e4:	2100      	moveq	r1, #0
  1500e6:	2101      	movne	r1, #1
  1500e8:	468c      	moveq	r12, r1
  1500ea:	f1a3 0c04 	subne.w	r12, r3, #4
    if (item->prev == 0 && item->next == 0)
  1500ee:	b37e      	cbz	r6, 150150 <timer_cancel+0xa0>
    item->next->prev = item->prev;
  1500f0:	6026      	str	r6, [r4, #0]
    item->prev = item->next = 0;
  1500f2:	2100      	movs	r1, #0
    item->prev->next = item->next;
  1500f4:	6843      	ldr	r3, [r0, #4]
  1500f6:	605c      	str	r4, [r3, #4]
    item->prev = item->next = 0;
  1500f8:	6041      	str	r1, [r0, #4]
  1500fa:	6853      	ldr	r3, [r2, #4]
  1500fc:	6081      	str	r1, [r0, #8]
  1500fe:	4293      	cmp	r3, r2
  150100:	bf18      	it	ne
  150102:	428b      	cmpne	r3, r1
  150104:	bf14      	ite	ne
  150106:	2101      	movne	r1, #1
  150108:	2100      	moveq	r1, #0
    timer->periodic_time = 0;
  15010a:	2600      	movs	r6, #0
    timer->callback = NULL;
  15010c:	e9c0 6604 	strd	r6, r6, [r0, #16]
    timer->arg = NULL;
  150110:	6186      	str	r6, [r0, #24]
    timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
  150112:	b1a9      	cbz	r1, 150140 <timer_cancel+0x90>
    if (newhead == NULL) {
  150114:	2b04      	cmp	r3, #4
  150116:	d013      	beq.n	150140 <timer_cancel+0x90>
    timer_t *newhead = list_peek_head_type(&timers[cpu].timer_queue, timer_t, node);
  150118:	1f1c      	subs	r4, r3, #4
    } else if (newhead != oldhead) {
  15011a:	45a4      	cmp	r12, r4
  15011c:	d012      	beq.n	150144 <timer_cancel+0x94>
        lk_time_t now = current_time();
  15011e:	f7f0 fc1f 	bl	140960 <current_time>
        if (TIME_LT(newhead->scheduled_time, now))
  150122:	68e2      	ldr	r2, [r4, #12]
        platform_set_oneshot_timer(timer_tick, NULL, delay);
  150124:	4631      	mov	r1, r6
        if (TIME_LT(newhead->scheduled_time, now))
  150126:	1a12      	subs	r2, r2, r0
        platform_set_oneshot_timer(timer_tick, NULL, delay);
  150128:	f64f 60a9 	movw	r0, #65193	; 0xfea9
  15012c:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
  150130:	f2c0 0014 	movt	r0, #20
  150134:	f7f0 fbc4 	bl	1408c0 <platform_set_oneshot_timer>
    *lock = 0;
  150138:	2300      	movs	r3, #0
  15013a:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15013c:	b937      	cbnz	r7, 15014c <timer_cancel+0x9c>
}
  15013e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        platform_stop_timer();
  150140:	f7f0 fbf0 	bl	140924 <platform_stop_timer>
    *lock = 0;
  150144:	2300      	movs	r3, #0
  150146:	602b      	str	r3, [r5, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  150148:	2f00      	cmp	r7, #0
  15014a:	d0f8      	beq.n	15013e <timer_cancel+0x8e>
    __asm__ volatile("cpsie i");
  15014c:	b662      	cpsie	i
}
  15014e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (item->prev == 0 && item->next == 0)
  150150:	2c00      	cmp	r4, #0
  150152:	d1cd      	bne.n	1500f0 <timer_cancel+0x40>
  150154:	e7d9      	b.n	15010a <timer_cancel+0x5a>
  150156:	bf00      	nop

00150158 <timer_init>:

void timer_init(void)
{
    timer_lock = SPIN_LOCK_INITIAL_VALUE;
  150158:	f246 52f8 	movw	r2, #26104	; 0x65f8
    list->prev = list->next = list;
  15015c:	f246 6300 	movw	r3, #26112	; 0x6600
  150160:	2100      	movs	r1, #0
  150162:	f2c0 0216 	movt	r2, #22
  150166:	f2c0 0316 	movt	r3, #22
  15016a:	6011      	str	r1, [r2, #0]
  15016c:	e9c3 3300 	strd	r3, r3, [r3]
    }
#if !PLATFORM_HAS_DYNAMIC_TIMER
    /* register for a periodic timer tick */
    platform_set_periodic_timer(timer_tick, NULL, 10); /* 10ms */
#endif
}
  150170:	4770      	bx	r14
  150172:	bf00      	nop

00150174 <sem_init>:
#include <err.h>
#include <kernel/semaphore.h>
#include <kernel/thread.h>

void sem_init(semaphore_t *sem, unsigned int value)
{
  150174:	b430      	push	{r4, r5}
    *sem = (semaphore_t)SEMAPHORE_INITIAL_VALUE(*sem, value);
  150176:	f646 1274 	movw	r2, #26996	; 0x6974
  15017a:	f646 5461 	movw	r4, #28001	; 0x6d61
  15017e:	2500      	movs	r5, #0
  150180:	f2c7 3465 	movt	r4, #29541	; 0x7365
  150184:	f2c7 7261 	movt	r2, #30561	; 0x7761
  150188:	e9c0 4100 	strd	r4, r1, [r0]
  15018c:	f100 030c 	add.w	r3, r0, #12
  150190:	6145      	str	r5, [r0, #20]
  150192:	6082      	str	r2, [r0, #8]
  150194:	e9c0 3303 	strd	r3, r3, [r0, #12]
}
  150198:	bc30      	pop	{r4, r5}
  15019a:	4770      	bx	r14

0015019c <sem_destroy>:

void sem_destroy(semaphore_t *sem)
{
  15019c:	b538      	push	{r3, r4, r5, r14}
  15019e:	4602      	mov	r2, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1501a0:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1501a4:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  1501a8:	f100 0008 	add.w	r0, r0, #8
  1501ac:	d10d      	bne.n	1501ca <sem_destroy+0x2e>
    __asm__ volatile("cpsid i");
  1501ae:	b672      	cpsid	i
    *lock = 1;
  1501b0:	f246 55c0 	movw	r5, #26048	; 0x65c0
  1501b4:	2301      	movs	r3, #1
    THREAD_LOCK(state);
    sem->count = 0;
  1501b6:	6054      	str	r4, [r2, #4]
  1501b8:	f2c0 0516 	movt	r5, #22
    wait_queue_destroy(&sem->wait, true);
  1501bc:	4619      	mov	r1, r3
  1501be:	602b      	str	r3, [r5, #0]
  1501c0:	f7ff fdec 	bl	14fd9c <wait_queue_destroy>
    *lock = 0;
  1501c4:	602c      	str	r4, [r5, #0]
    __asm__ volatile("cpsie i");
  1501c6:	b662      	cpsie	i
    THREAD_UNLOCK(state);
}
  1501c8:	bd38      	pop	{r3, r4, r5, r15}
    sem->count = 0;
  1501ca:	2500      	movs	r5, #0
    *lock = 1;
  1501cc:	f246 54c0 	movw	r4, #26048	; 0x65c0
  1501d0:	2301      	movs	r3, #1
  1501d2:	f2c0 0416 	movt	r4, #22
  1501d6:	6055      	str	r5, [r2, #4]
    wait_queue_destroy(&sem->wait, true);
  1501d8:	4619      	mov	r1, r3
  1501da:	6023      	str	r3, [r4, #0]
  1501dc:	f7ff fdde 	bl	14fd9c <wait_queue_destroy>
    *lock = 0;
  1501e0:	6025      	str	r5, [r4, #0]
}
  1501e2:	bd38      	pop	{r3, r4, r5, r15}

001501e4 <sem_post>:

int sem_post(semaphore_t *sem, bool resched)
{
  1501e4:	b538      	push	{r3, r4, r5, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1501e6:	f3ef 8200 	mrs	r2, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1501ea:	f012 0480 	ands.w	r4, r2, #128	; 0x80
  1501ee:	d110      	bne.n	150212 <sem_post+0x2e>
    __asm__ volatile("cpsid i");
  1501f0:	b672      	cpsid	i

    /*
     * If the count is or was negative then a thread is waiting for a resource, otherwise
     * it's safe to just increase the count available with no downsides
     */
    if (unlikely(++sem->count <= 0))
  1501f2:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  1501f4:	f246 55c0 	movw	r5, #26048	; 0x65c0
  1501f8:	2201      	movs	r2, #1
  1501fa:	f2c0 0516 	movt	r5, #22
  1501fe:	3301      	adds	r3, #1
  150200:	602a      	str	r2, [r5, #0]
  150202:	2b00      	cmp	r3, #0
  150204:	6043      	str	r3, [r0, #4]
    int ret = 0;
  150206:	bfc4      	itt	gt
  150208:	4620      	movgt	r0, r4
    *lock = 0;
  15020a:	602c      	strgt	r4, [r5, #0]
    if (unlikely(++sem->count <= 0))
  15020c:	dd17      	ble.n	15023e <sem_post+0x5a>
    __asm__ volatile("cpsie i");
  15020e:	b662      	cpsie	i
        ret = wait_queue_wake_one(&sem->wait, resched, NO_ERROR);

    THREAD_UNLOCK(state);

    return ret;
}
  150210:	bd38      	pop	{r3, r4, r5, r15}
    if (unlikely(++sem->count <= 0))
  150212:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  150214:	f246 54c0 	movw	r4, #26048	; 0x65c0
  150218:	2201      	movs	r2, #1
  15021a:	f2c0 0416 	movt	r4, #22
  15021e:	3301      	adds	r3, #1
  150220:	6022      	str	r2, [r4, #0]
  150222:	2b00      	cmp	r3, #0
  150224:	6043      	str	r3, [r0, #4]
    *lock = 0;
  150226:	bfc2      	ittt	gt
  150228:	2300      	movgt	r3, #0
    int ret = 0;
  15022a:	4618      	movgt	r0, r3
  15022c:	6023      	strgt	r3, [r4, #0]
    if (unlikely(++sem->count <= 0))
  15022e:	dcef      	bgt.n	150210 <sem_post+0x2c>
        ret = wait_queue_wake_one(&sem->wait, resched, NO_ERROR);
  150230:	2200      	movs	r2, #0
  150232:	3008      	adds	r0, #8
  150234:	f7ff fc28 	bl	14fa88 <wait_queue_wake_one>
  150238:	2300      	movs	r3, #0
  15023a:	6023      	str	r3, [r4, #0]
}
  15023c:	bd38      	pop	{r3, r4, r5, r15}
        ret = wait_queue_wake_one(&sem->wait, resched, NO_ERROR);
  15023e:	4622      	mov	r2, r4
  150240:	3008      	adds	r0, #8
  150242:	f7ff fc21 	bl	14fa88 <wait_queue_wake_one>
  150246:	602c      	str	r4, [r5, #0]
  150248:	e7e1      	b.n	15020e <sem_post+0x2a>
  15024a:	bf00      	nop

0015024c <sem_wait>:

status_t sem_wait(semaphore_t *sem)
{
  15024c:	b538      	push	{r3, r4, r5, r14}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  15024e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  150252:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  150256:	d110      	bne.n	15027a <sem_wait+0x2e>
    __asm__ volatile("cpsid i");
  150258:	b672      	cpsid	i

    /*
     * If there are no resources available then we need to
     * sit in the wait queue until sem_post adds some.
     */
    if (unlikely(--sem->count < 0))
  15025a:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  15025c:	f246 55c0 	movw	r5, #26048	; 0x65c0
  150260:	2201      	movs	r2, #1
  150262:	f2c0 0516 	movt	r5, #22
  150266:	3b01      	subs	r3, #1
  150268:	602a      	str	r2, [r5, #0]
  15026a:	2b00      	cmp	r3, #0
  15026c:	6043      	str	r3, [r0, #4]
    status_t ret = NO_ERROR;
  15026e:	bfa4      	itt	ge
  150270:	4620      	movge	r0, r4
    *lock = 0;
  150272:	602c      	strge	r4, [r5, #0]
    if (unlikely(--sem->count < 0))
  150274:	db18      	blt.n	1502a8 <sem_wait+0x5c>
    __asm__ volatile("cpsie i");
  150276:	b662      	cpsie	i
        ret = wait_queue_block(&sem->wait, INFINITE_TIME);

    THREAD_UNLOCK(state);
    return ret;
}
  150278:	bd38      	pop	{r3, r4, r5, r15}
    if (unlikely(--sem->count < 0))
  15027a:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  15027c:	f246 54c0 	movw	r4, #26048	; 0x65c0
  150280:	2201      	movs	r2, #1
  150282:	f2c0 0416 	movt	r4, #22
  150286:	3b01      	subs	r3, #1
  150288:	6022      	str	r2, [r4, #0]
  15028a:	2b00      	cmp	r3, #0
  15028c:	6043      	str	r3, [r0, #4]
    *lock = 0;
  15028e:	bfa2      	ittt	ge
  150290:	2300      	movge	r3, #0
    status_t ret = NO_ERROR;
  150292:	4618      	movge	r0, r3
  150294:	6023      	strge	r3, [r4, #0]
    if (unlikely(--sem->count < 0))
  150296:	daef      	bge.n	150278 <sem_wait+0x2c>
        ret = wait_queue_block(&sem->wait, INFINITE_TIME);
  150298:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  15029c:	3008      	adds	r0, #8
  15029e:	f7ff fb63 	bl	14f968 <wait_queue_block>
  1502a2:	2300      	movs	r3, #0
  1502a4:	6023      	str	r3, [r4, #0]
}
  1502a6:	bd38      	pop	{r3, r4, r5, r15}
        ret = wait_queue_block(&sem->wait, INFINITE_TIME);
  1502a8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1502ac:	3008      	adds	r0, #8
  1502ae:	f7ff fb5b 	bl	14f968 <wait_queue_block>
  1502b2:	602c      	str	r4, [r5, #0]
  1502b4:	e7df      	b.n	150276 <sem_wait+0x2a>
  1502b6:	bf00      	nop

001502b8 <sem_timedwait>:
    THREAD_UNLOCK(state);
    return ret;
}

status_t sem_timedwait(semaphore_t *sem, lk_time_t timeout)
{
  1502b8:	b570      	push	{r4, r5, r6, r14}
  1502ba:	4605      	mov	r5, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1502bc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1502c0:	f013 0480 	ands.w	r4, r3, #128	; 0x80
  1502c4:	d110      	bne.n	1502e8 <sem_timedwait+0x30>
    __asm__ volatile("cpsid i");
  1502c6:	b672      	cpsid	i
    status_t ret = NO_ERROR;
    THREAD_LOCK(state);

    if (unlikely(--sem->count < 0)) {
  1502c8:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  1502ca:	f246 56c0 	movw	r6, #26048	; 0x65c0
  1502ce:	2201      	movs	r2, #1
  1502d0:	f2c0 0616 	movt	r6, #22
  1502d4:	3b01      	subs	r3, #1
  1502d6:	6032      	str	r2, [r6, #0]
  1502d8:	2b00      	cmp	r3, #0
  1502da:	6043      	str	r3, [r0, #4]
    status_t ret = NO_ERROR;
  1502dc:	bfa4      	itt	ge
  1502de:	4620      	movge	r0, r4
    *lock = 0;
  1502e0:	6034      	strge	r4, [r6, #0]
    if (unlikely(--sem->count < 0)) {
  1502e2:	db1d      	blt.n	150320 <sem_timedwait+0x68>
    __asm__ volatile("cpsie i");
  1502e4:	b662      	cpsie	i
        }
    }

    THREAD_UNLOCK(state);
    return ret;
}
  1502e6:	bd70      	pop	{r4, r5, r6, r15}
    if (unlikely(--sem->count < 0)) {
  1502e8:	6843      	ldr	r3, [r0, #4]
    *lock = 1;
  1502ea:	f246 54c0 	movw	r4, #26048	; 0x65c0
  1502ee:	2201      	movs	r2, #1
  1502f0:	f2c0 0416 	movt	r4, #22
  1502f4:	3b01      	subs	r3, #1
  1502f6:	6022      	str	r2, [r4, #0]
  1502f8:	2b00      	cmp	r3, #0
  1502fa:	6043      	str	r3, [r0, #4]
    *lock = 0;
  1502fc:	bfa2      	ittt	ge
  1502fe:	2300      	movge	r3, #0
    status_t ret = NO_ERROR;
  150300:	4618      	movge	r0, r3
  150302:	6023      	strge	r3, [r4, #0]
    if (unlikely(--sem->count < 0)) {
  150304:	daef      	bge.n	1502e6 <sem_timedwait+0x2e>
        ret = wait_queue_block(&sem->wait, timeout);
  150306:	f105 0008 	add.w	r0, r5, #8
  15030a:	f7ff fb2d 	bl	14f968 <wait_queue_block>
            if (ret == ERR_TIMED_OUT) {
  15030e:	f110 0f0d 	cmn.w	r0, #13
  150312:	d113      	bne.n	15033c <sem_timedwait+0x84>
                sem->count++;
  150314:	686b      	ldr	r3, [r5, #4]
  150316:	2200      	movs	r2, #0
  150318:	6022      	str	r2, [r4, #0]
  15031a:	3301      	adds	r3, #1
  15031c:	606b      	str	r3, [r5, #4]
}
  15031e:	bd70      	pop	{r4, r5, r6, r15}
        ret = wait_queue_block(&sem->wait, timeout);
  150320:	f105 0008 	add.w	r0, r5, #8
  150324:	f7ff fb20 	bl	14f968 <wait_queue_block>
            if (ret == ERR_TIMED_OUT) {
  150328:	f110 0f0d 	cmn.w	r0, #13
  15032c:	bf18      	it	ne
  15032e:	6034      	strne	r4, [r6, #0]
  150330:	d1d8      	bne.n	1502e4 <sem_timedwait+0x2c>
                sem->count++;
  150332:	686b      	ldr	r3, [r5, #4]
  150334:	6034      	str	r4, [r6, #0]
  150336:	3301      	adds	r3, #1
  150338:	606b      	str	r3, [r5, #4]
  15033a:	e7d3      	b.n	1502e4 <sem_timedwait+0x2c>
  15033c:	2300      	movs	r3, #0
  15033e:	6023      	str	r3, [r4, #0]
}
  150340:	bd70      	pop	{r4, r5, r6, r15}
  150342:	bf00      	nop

00150344 <port_init>:
  150344:	f246 6320 	movw	r3, #26144	; 0x6620
  150348:	f2c0 0316 	movt	r3, #22
  15034c:	e9c3 3300 	strd	r3, r3, [r3]

// must be called before any use of ports.
void port_init(void)
{
    list_initialize(&write_port_list);
}
  150350:	4770      	bx	r14
  150352:	bf00      	nop

00150354 <cmd_sleep>:

static int cmd_sleep(int argc, const cmd_args *argv)
{
    lk_time_t t = 1000; /* default to 1 second */

    if (argc >= 2) {
  150354:	2801      	cmp	r0, #1
{
  150356:	b510      	push	{r4, r14}
    lk_time_t t = 1000; /* default to 1 second */
  150358:	bfd8      	it	le
  15035a:	f44f 747a 	movle.w	r4, #1000	; 0x3e8
    if (argc >= 2) {
  15035e:	dd0e      	ble.n	15037e <cmd_sleep+0x2a>
  150360:	460b      	mov	r3, r1
        t = argv[1].u;
        if (!strcmp(argv[0].str, "sleep"))
  150362:	f248 3100 	movw	r1, #33536	; 0x8300
  150366:	f2c0 0115 	movt	r1, #21
  15036a:	6818      	ldr	r0, [r3, #0]
        t = argv[1].u;
  15036c:	699c      	ldr	r4, [r3, #24]
        if (!strcmp(argv[0].str, "sleep"))
  15036e:	f003 ff05 	bl	15417c <strcmp>
  150372:	b920      	cbnz	r0, 15037e <cmd_sleep+0x2a>
            t *= 1000;
  150374:	ebc4 1344 	rsb	r3, r4, r4, lsl #5
  150378:	eb04 0483 	add.w	r4, r4, r3, lsl #2
  15037c:	00e4      	lsls	r4, r4, #3
    }

    thread_sleep(t);
  15037e:	4620      	mov	r0, r4
  150380:	f7ff fa56 	bl	14f830 <thread_sleep>

    return 0;
}
  150384:	2000      	movs	r0, #0
  150386:	bd10      	pop	{r4, r15}

00150388 <cmd_fill_mem>:
    if (argc < 4) {
  150388:	2803      	cmp	r0, #3
{
  15038a:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  15038c:	460e      	mov	r6, r1
    if (argc < 4) {
  15038e:	dd38      	ble.n	150402 <cmd_fill_mem+0x7a>
    if (strcmp(argv[0].str, "fw") == 0) {
  150390:	680f      	ldr	r7, [r1, #0]
  150392:	f245 41d0 	movw	r1, #21712	; 0x54d0
  150396:	4638      	mov	r0, r7
  150398:	f2c0 0115 	movt	r1, #21
  15039c:	f003 feee 	bl	15417c <strcmp>
  1503a0:	69b4      	ldr	r4, [r6, #24]
  1503a2:	6af5      	ldr	r5, [r6, #44]	; 0x2c
  1503a4:	6c36      	ldr	r6, [r6, #64]	; 0x40
  1503a6:	4425      	add	r5, r4
  1503a8:	b1f0      	cbz	r0, 1503e8 <cmd_fill_mem+0x60>
    else if (strcmp(argv[0].str, "fh") == 0) {
  1503aa:	f248 21bc 	movw	r1, #33468	; 0x82bc
  1503ae:	4638      	mov	r0, r7
  1503b0:	f2c0 0115 	movt	r1, #21
  1503b4:	f003 fee2 	bl	15417c <strcmp>
  1503b8:	2201      	movs	r2, #1
        size = 2;
  1503ba:	2302      	movs	r3, #2
    else if (strcmp(argv[0].str, "fh") == 0) {
  1503bc:	b1b0      	cbz	r0, 1503ec <cmd_fill_mem+0x64>
        size = 1;
  1503be:	2301      	movs	r3, #1
    for ( ; address < stop; address += size) {
  1503c0:	42ac      	cmp	r4, r5
  1503c2:	d20c      	bcs.n	1503de <cmd_fill_mem+0x56>
        switch (size) {
  1503c4:	2b02      	cmp	r3, #2
                *(uint16_t *)address = (uint16_t)val;
  1503c6:	bf08      	it	eq
  1503c8:	8026      	strheq	r6, [r4, #0]
        switch (size) {
  1503ca:	d005      	beq.n	1503d8 <cmd_fill_mem+0x50>
  1503cc:	2b04      	cmp	r3, #4
                *(uint32_t *)address = (uint32_t)val;
  1503ce:	bf08      	it	eq
  1503d0:	6026      	streq	r6, [r4, #0]
        switch (size) {
  1503d2:	d001      	beq.n	1503d8 <cmd_fill_mem+0x50>
  1503d4:	2b01      	cmp	r3, #1
  1503d6:	d004      	beq.n	1503e2 <cmd_fill_mem+0x5a>
    for ( ; address < stop; address += size) {
  1503d8:	441c      	add	r4, r3
  1503da:	42ac      	cmp	r4, r5
  1503dc:	d3f2      	bcc.n	1503c4 <cmd_fill_mem+0x3c>
    return 0;
  1503de:	2000      	movs	r0, #0
}
  1503e0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
                *(uint8_t *)address = (uint8_t)val;
  1503e2:	7026      	strb	r6, [r4, #0]
    for ( ; address < stop; address += size) {
  1503e4:	441c      	add	r4, r3
  1503e6:	e7f8      	b.n	1503da <cmd_fill_mem+0x52>
  1503e8:	2203      	movs	r2, #3
        size = 4;
  1503ea:	2304      	movs	r3, #4
    if ((address & (size - 1)) != 0) {
  1503ec:	4222      	tst	r2, r4
  1503ee:	d0e7      	beq.n	1503c0 <cmd_fill_mem+0x38>
        printf("unaligned address, cannot modify\n");
  1503f0:	f248 20c0 	movw	r0, #33472	; 0x82c0
  1503f4:	f2c0 0015 	movt	r0, #21
  1503f8:	f003 fe7e 	bl	1540f8 <_printf>
        return -1;
  1503fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  150400:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        printf("not enough arguments\n");
  150402:	f248 2088 	movw	r0, #33416	; 0x8288
  150406:	f2c0 0015 	movt	r0, #21
  15040a:	f003 fe75 	bl	1540f8 <_printf>
        printf("%s <address> <len> <val>\n", argv[0].str);
  15040e:	6831      	ldr	r1, [r6, #0]
  150410:	f248 20a0 	movw	r0, #33440	; 0x82a0
  150414:	f2c0 0015 	movt	r0, #21
  150418:	f003 fe6e 	bl	1540f8 <_printf>
        return -1;
  15041c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  150420:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  150422:	bf00      	nop

00150424 <cmd_display_mem>:
    if (argc < 3 && len == 0) {
  150424:	f246 632c 	movw	r3, #26156	; 0x662c
  150428:	2802      	cmp	r0, #2
{
  15042a:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (argc < 3 && len == 0) {
  15042e:	f2c0 0316 	movt	r3, #22
{
  150432:	4680      	mov	r8, r0
  150434:	b085      	sub	sp, #20
  150436:	460d      	mov	r5, r1
    if (argc < 3 && len == 0) {
  150438:	9301      	str	r3, [sp, #4]
  15043a:	dc03      	bgt.n	150444 <cmd_display_mem+0x20>
  15043c:	681b      	ldr	r3, [r3, #0]
  15043e:	2b00      	cmp	r3, #0
  150440:	f000 80ed 	beq.w	15061e <cmd_display_mem+0x1fa>
    if (strcmp(argv[0].str, "dw") == 0) {
  150444:	682c      	ldr	r4, [r5, #0]
  150446:	f248 2130 	movw	r1, #33328	; 0x8230
  15044a:	4620      	mov	r0, r4
  15044c:	f2c0 0115 	movt	r1, #21
  150450:	f003 fe94 	bl	15417c <strcmp>
  150454:	2800      	cmp	r0, #0
  150456:	d07f      	beq.n	150558 <cmd_display_mem+0x134>
    else if (strcmp(argv[0].str, "dh") == 0) {
  150458:	f248 2134 	movw	r1, #33332	; 0x8234
  15045c:	4620      	mov	r0, r4
  15045e:	f2c0 0115 	movt	r1, #21
  150462:	f003 fe8b 	bl	15417c <strcmp>
  150466:	2800      	cmp	r0, #0
  150468:	f040 80c5 	bne.w	1505f6 <cmd_display_mem+0x1d2>
  15046c:	2301      	movs	r3, #1
    while (argc > argindex) {
  15046e:	f1b8 0f01 	cmp.w	r8, #1
        size = 2;
  150472:	f04f 0402 	mov.w	r4, #2
  150476:	9302      	str	r3, [sp, #8]
    while (argc > argindex) {
  150478:	dd75      	ble.n	150566 <cmd_display_mem+0x142>
  15047a:	eb08 0888 	add.w	r8, r8, r8, lsl #2
  15047e:	46ab      	mov	r11, r5
  150480:	f1a5 0214 	sub.w	r2, r5, #20
        if (!strcmp(argv[argindex].str, "-l")) {
  150484:	f248 2738 	movw	r7, #33336	; 0x8238
  150488:	f246 6528 	movw	r5, #26152	; 0x6628
        else if (!strcmp(argv[argindex].str, "-b")) {
  15048c:	f248 263c 	movw	r6, #33340	; 0x823c
    bool read_address = false;
  150490:	2300      	movs	r3, #0
  150492:	eb02 0888 	add.w	r8, r2, r8, lsl #2
  150496:	f2c0 0516 	movt	r5, #22
        if (!strcmp(argv[argindex].str, "-l")) {
  15049a:	f2c0 0715 	movt	r7, #21
    uint byte_order = BYTE_ORDER;
  15049e:	f240 49d2 	movw	r9, #1234	; 0x4d2
        else if (!strcmp(argv[argindex].str, "-b")) {
  1504a2:	f2c0 0615 	movt	r6, #21
    uint byte_order = BYTE_ORDER;
  1504a6:	9403      	str	r4, [sp, #12]
  1504a8:	469a      	mov	r10, r3
  1504aa:	e011      	b.n	1504d0 <cmd_display_mem+0xac>
        else if (!strcmp(argv[argindex].str, "-b")) {
  1504ac:	4620      	mov	r0, r4
  1504ae:	f003 fe65 	bl	15417c <strcmp>
  1504b2:	2800      	cmp	r0, #0
  1504b4:	d05e      	beq.n	150574 <cmd_display_mem+0x150>
  1504b6:	f8db 3018 	ldr.w	r3, [r11, #24]
        else if (!read_address) {
  1504ba:	f1ba 0f00 	cmp.w	r10, #0
  1504be:	f040 8097 	bne.w	1505f0 <cmd_display_mem+0x1cc>
            address = argv[argindex].u;
  1504c2:	602b      	str	r3, [r5, #0]
            read_address = true;
  1504c4:	f04f 0a01 	mov.w	r10, #1
  1504c8:	f10b 0b14 	add.w	r11, r11, #20
    while (argc > argindex) {
  1504cc:	45c3      	cmp	r11, r8
  1504ce:	d00e      	beq.n	1504ee <cmd_display_mem+0xca>
        if (!strcmp(argv[argindex].str, "-l")) {
  1504d0:	f8db 4014 	ldr.w	r4, [r11, #20]
  1504d4:	4639      	mov	r1, r7
  1504d6:	4620      	mov	r0, r4
  1504d8:	f003 fe50 	bl	15417c <strcmp>
        else if (!strcmp(argv[argindex].str, "-b")) {
  1504dc:	4631      	mov	r1, r6
        if (!strcmp(argv[argindex].str, "-l")) {
  1504de:	2800      	cmp	r0, #0
  1504e0:	d1e4      	bne.n	1504ac <cmd_display_mem+0x88>
            byte_order = LITTLE_ENDIAN;
  1504e2:	f240 49d2 	movw	r9, #1234	; 0x4d2
  1504e6:	f10b 0b14 	add.w	r11, r11, #20
    while (argc > argindex) {
  1504ea:	45c3      	cmp	r11, r8
  1504ec:	d1f0      	bne.n	1504d0 <cmd_display_mem+0xac>
  1504ee:	9c03      	ldr	r4, [sp, #12]
    unsigned long stop = address + len;
  1504f0:	9b01      	ldr	r3, [sp, #4]
  1504f2:	6829      	ldr	r1, [r5, #0]
  1504f4:	681e      	ldr	r6, [r3, #0]
    if ((address & (size - 1)) != 0) {
  1504f6:	9b02      	ldr	r3, [sp, #8]
    unsigned long stop = address + len;
  1504f8:	440e      	add	r6, r1
    if ((address & (size - 1)) != 0) {
  1504fa:	4219      	tst	r1, r3
  1504fc:	f040 809f 	bne.w	15063e <cmd_display_mem+0x21a>
    for ( ; address < stop; address += size) {
  150500:	428e      	cmp	r6, r1
  150502:	d925      	bls.n	150550 <cmd_display_mem+0x12c>
            printf("\n");
  150504:	f646 0ae8 	movw	r10, #26856	; 0x68e8
                printf("%02hhx ", *(uint8_t *)address);
  150508:	f248 2880 	movw	r8, #33408	; 0x8280
                printf("%04hx ", val);
  15050c:	f248 2778 	movw	r7, #33400	; 0x8278
            printf("\n");
  150510:	f2c0 0a15 	movt	r10, #21
                printf("%02hhx ", *(uint8_t *)address);
  150514:	f2c0 0815 	movt	r8, #21
    int count = 0;
  150518:	f04f 0b00 	mov.w	r11, #0
                printf("%04hx ", val);
  15051c:	f2c0 0715 	movt	r7, #21
        if (count == 0)
  150520:	f1bb 0f00 	cmp.w	r11, #0
  150524:	d031      	beq.n	15058a <cmd_display_mem+0x166>
        switch (size) {
  150526:	2c02      	cmp	r4, #2
  150528:	44a3      	add	r11, r4
  15052a:	d053      	beq.n	1505d4 <cmd_display_mem+0x1b0>
  15052c:	2c04      	cmp	r4, #4
  15052e:	d042      	beq.n	1505b6 <cmd_display_mem+0x192>
  150530:	2c01      	cmp	r4, #1
  150532:	d039      	beq.n	1505a8 <cmd_display_mem+0x184>
        if (count == 16) {
  150534:	f1bb 0f10 	cmp.w	r11, #16
  150538:	d01f      	beq.n	15057a <cmd_display_mem+0x156>
    for ( ; address < stop; address += size) {
  15053a:	6829      	ldr	r1, [r5, #0]
  15053c:	4421      	add	r1, r4
  15053e:	42b1      	cmp	r1, r6
  150540:	6029      	str	r1, [r5, #0]
  150542:	d3ed      	bcc.n	150520 <cmd_display_mem+0xfc>
        printf("\n");
  150544:	f646 00e8 	movw	r0, #26856	; 0x68e8
  150548:	f2c0 0015 	movt	r0, #21
  15054c:	f003 fdd4 	bl	1540f8 <_printf>
    return 0;
  150550:	2000      	movs	r0, #0
}
  150552:	b005      	add	sp, #20
  150554:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  150558:	2303      	movs	r3, #3
    while (argc > argindex) {
  15055a:	f1b8 0f01 	cmp.w	r8, #1
        size = 4;
  15055e:	f04f 0404 	mov.w	r4, #4
  150562:	9302      	str	r3, [sp, #8]
    while (argc > argindex) {
  150564:	dc89      	bgt.n	15047a <cmd_display_mem+0x56>
  150566:	f246 6528 	movw	r5, #26152	; 0x6628
    uint byte_order = BYTE_ORDER;
  15056a:	f240 49d2 	movw	r9, #1234	; 0x4d2
  15056e:	f2c0 0516 	movt	r5, #22
  150572:	e7bd      	b.n	1504f0 <cmd_display_mem+0xcc>
            byte_order = BIG_ENDIAN;
  150574:	f241 09e1 	movw	r9, #4321	; 0x10e1
  150578:	e7a6      	b.n	1504c8 <cmd_display_mem+0xa4>
            printf("\n");
  15057a:	4650      	mov	r0, r10
  15057c:	f003 fdbc 	bl	1540f8 <_printf>
    for ( ; address < stop; address += size) {
  150580:	6829      	ldr	r1, [r5, #0]
  150582:	4421      	add	r1, r4
  150584:	428e      	cmp	r6, r1
  150586:	6029      	str	r1, [r5, #0]
  150588:	d9e2      	bls.n	150550 <cmd_display_mem+0x12c>
            printf("0x%08lx: ", address);
  15058a:	f248 2064 	movw	r0, #33380	; 0x8264
  15058e:	f2c0 0015 	movt	r0, #21
  150592:	f003 fdb1 	bl	1540f8 <_printf>
        switch (size) {
  150596:	2c02      	cmp	r4, #2
  150598:	d01b      	beq.n	1505d2 <cmd_display_mem+0x1ae>
  15059a:	2c04      	cmp	r4, #4
  15059c:	d00a      	beq.n	1505b4 <cmd_display_mem+0x190>
  15059e:	2c01      	cmp	r4, #1
  1505a0:	bf18      	it	ne
  1505a2:	46a3      	movne	r11, r4
  1505a4:	d1c9      	bne.n	15053a <cmd_display_mem+0x116>
  1505a6:	46a3      	mov	r11, r4
                printf("%02hhx ", *(uint8_t *)address);
  1505a8:	682b      	ldr	r3, [r5, #0]
  1505aa:	4640      	mov	r0, r8
  1505ac:	7819      	ldrb	r1, [r3, #0]
  1505ae:	f003 fda3 	bl	1540f8 <_printf>
                break;
  1505b2:	e7bf      	b.n	150534 <cmd_display_mem+0x110>
        switch (size) {
  1505b4:	46a3      	mov	r11, r4
  1505b6:	682a      	ldr	r2, [r5, #0]
                               SWAP_32(*(uint32_t *)address) :
  1505b8:	f240 43d2 	movw	r3, #1234	; 0x4d2
                printf("%08x ", val);
  1505bc:	f248 2070 	movw	r0, #33392	; 0x8270
                               SWAP_32(*(uint32_t *)address) :
  1505c0:	4599      	cmp	r9, r3
                printf("%08x ", val);
  1505c2:	f2c0 0015 	movt	r0, #21
  1505c6:	6811      	ldr	r1, [r2, #0]
  1505c8:	bf18      	it	ne
  1505ca:	ba09      	revne	r1, r1
  1505cc:	f003 fd94 	bl	1540f8 <_printf>
                break;
  1505d0:	e7b0      	b.n	150534 <cmd_display_mem+0x110>
        switch (size) {
  1505d2:	46a3      	mov	r11, r4
                uint16_t val = (byte_order != BYTE_ORDER) ?
  1505d4:	f240 43d2 	movw	r3, #1234	; 0x4d2
                printf("%04hx ", val);
  1505d8:	4638      	mov	r0, r7
  1505da:	682a      	ldr	r2, [r5, #0]
                uint16_t val = (byte_order != BYTE_ORDER) ?
  1505dc:	4599      	cmp	r9, r3
  1505de:	8811      	ldrh	r1, [r2, #0]
                               SWAP_16(*(uint16_t *)address) :
  1505e0:	bf1e      	ittt	ne
  1505e2:	0a0b      	lsrne	r3, r1, #8
  1505e4:	ea43 2101 	orrne.w	r1, r3, r1, lsl #8
  1505e8:	b289      	uxthne	r1, r1
                printf("%04hx ", val);
  1505ea:	f003 fd85 	bl	1540f8 <_printf>
                break;
  1505ee:	e7a1      	b.n	150534 <cmd_display_mem+0x110>
            len = argv[argindex].u;
  1505f0:	9a01      	ldr	r2, [sp, #4]
  1505f2:	6013      	str	r3, [r2, #0]
  1505f4:	e768      	b.n	1504c8 <cmd_display_mem+0xa4>
    while (argc > argindex) {
  1505f6:	f1b8 0f01 	cmp.w	r8, #1
  1505fa:	bfc2      	ittt	gt
  1505fc:	2300      	movgt	r3, #0
        size = 1;
  1505fe:	2401      	movgt	r4, #1
    while (argc > argindex) {
  150600:	9302      	strgt	r3, [sp, #8]
  150602:	f73f af3a 	bgt.w	15047a <cmd_display_mem+0x56>
    unsigned long stop = address + len;
  150606:	f246 6528 	movw	r5, #26152	; 0x6628
    uint byte_order = BYTE_ORDER;
  15060a:	f240 49d2 	movw	r9, #1234	; 0x4d2
    unsigned long stop = address + len;
  15060e:	9b01      	ldr	r3, [sp, #4]
  150610:	f2c0 0516 	movt	r5, #22
        size = 1;
  150614:	2401      	movs	r4, #1
    unsigned long stop = address + len;
  150616:	681e      	ldr	r6, [r3, #0]
  150618:	6829      	ldr	r1, [r5, #0]
  15061a:	440e      	add	r6, r1
  15061c:	e770      	b.n	150500 <cmd_display_mem+0xdc>
        printf("not enough arguments\n");
  15061e:	f248 2088 	movw	r0, #33416	; 0x8288
  150622:	f2c0 0015 	movt	r0, #21
  150626:	f003 fd67 	bl	1540f8 <_printf>
        printf("%s [-l] [-b] [address] [length]\n", argv[0].str);
  15062a:	6829      	ldr	r1, [r5, #0]
  15062c:	f248 200c 	movw	r0, #33292	; 0x820c
  150630:	f2c0 0015 	movt	r0, #21
  150634:	f003 fd60 	bl	1540f8 <_printf>
        return -1;
  150638:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  15063c:	e789      	b.n	150552 <cmd_display_mem+0x12e>
        printf("unaligned address, cannot display\n");
  15063e:	f248 2040 	movw	r0, #33344	; 0x8240
  150642:	f2c0 0015 	movt	r0, #21
  150646:	f003 fd57 	bl	1540f8 <_printf>
        return -1;
  15064a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  15064e:	e780      	b.n	150552 <cmd_display_mem+0x12e>

00150650 <cmd_modify_mem>:
    if (argc < 3) {
  150650:	2802      	cmp	r0, #2
{
  150652:	b570      	push	{r4, r5, r6, r14}
  150654:	460c      	mov	r4, r1
    if (argc < 3) {
  150656:	dd27      	ble.n	1506a8 <cmd_modify_mem+0x58>
    if (strcmp(argv[0].str, "mw") == 0) {
  150658:	680d      	ldr	r5, [r1, #0]
  15065a:	f248 21f8 	movw	r1, #33528	; 0x82f8
  15065e:	4628      	mov	r0, r5
  150660:	f2c0 0115 	movt	r1, #21
  150664:	f003 fd8a 	bl	15417c <strcmp>
  150668:	69a6      	ldr	r6, [r4, #24]
  15066a:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
  15066c:	b150      	cbz	r0, 150684 <cmd_modify_mem+0x34>
    else if (strcmp(argv[0].str, "mh") == 0) {
  15066e:	f248 21fc 	movw	r1, #33532	; 0x82fc
  150672:	4628      	mov	r0, r5
  150674:	f2c0 0115 	movt	r1, #21
  150678:	f003 fd80 	bl	15417c <strcmp>
  15067c:	b178      	cbz	r0, 15069e <cmd_modify_mem+0x4e>
            *(uint8_t *)address = (uint8_t)val;
  15067e:	7034      	strb	r4, [r6, #0]
    return 0;
  150680:	2000      	movs	r0, #0
}
  150682:	bd70      	pop	{r4, r5, r6, r15}
    if ((address & (size - 1)) != 0) {
  150684:	07b2      	lsls	r2, r6, #30
            *(uint32_t *)address = (uint32_t)val;
  150686:	bf08      	it	eq
  150688:	6034      	streq	r4, [r6, #0]
    if ((address & (size - 1)) != 0) {
  15068a:	d0fa      	beq.n	150682 <cmd_modify_mem+0x32>
        printf("unaligned address, cannot modify\n");
  15068c:	f248 20c0 	movw	r0, #33472	; 0x82c0
  150690:	f2c0 0015 	movt	r0, #21
  150694:	f003 fd30 	bl	1540f8 <_printf>
        return -1;
  150698:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  15069c:	bd70      	pop	{r4, r5, r6, r15}
    if ((address & (size - 1)) != 0) {
  15069e:	07f3      	lsls	r3, r6, #31
            *(uint16_t *)address = (uint16_t)val;
  1506a0:	bf58      	it	pl
  1506a2:	8034      	strhpl	r4, [r6, #0]
    if ((address & (size - 1)) != 0) {
  1506a4:	d4f2      	bmi.n	15068c <cmd_modify_mem+0x3c>
}
  1506a6:	bd70      	pop	{r4, r5, r6, r15}
        printf("not enough arguments\n");
  1506a8:	f248 2088 	movw	r0, #33416	; 0x8288
  1506ac:	f2c0 0015 	movt	r0, #21
  1506b0:	f003 fd22 	bl	1540f8 <_printf>
        printf("%s <address> <val>\n", argv[0].str);
  1506b4:	6821      	ldr	r1, [r4, #0]
  1506b6:	f248 20e4 	movw	r0, #33508	; 0x82e4
  1506ba:	f2c0 0015 	movt	r0, #21
  1506be:	f003 fd1b 	bl	1540f8 <_printf>
  1506c2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  1506c6:	bd70      	pop	{r4, r5, r6, r15}

001506c8 <cmd_chain>:
    if (argc < 3) {
  1506c8:	2802      	cmp	r0, #2
{
  1506ca:	b510      	push	{r4, r14}
  1506cc:	460c      	mov	r4, r1
  1506ce:	b082      	sub	sp, #8
    if (argc < 3) {
  1506d0:	dc10      	bgt.n	1506f4 <cmd_chain+0x2c>
        printf("not enough arguments\n");
  1506d2:	f248 2088 	movw	r0, #33416	; 0x8288
  1506d6:	f2c0 0015 	movt	r0, #21
  1506da:	f003 fd0d 	bl	1540f8 <_printf>
        printf("%s <address>\n", argv[0].str);
  1506de:	6821      	ldr	r1, [r4, #0]
  1506e0:	f248 10d0 	movw	r0, #33232	; 0x81d0
  1506e4:	f2c0 0015 	movt	r0, #21
  1506e8:	f003 fd06 	bl	1540f8 <_printf>
}
  1506ec:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1506f0:	b002      	add	sp, #8
  1506f2:	bd10      	pop	{r4, r15}
    arch_chain_load(argv[1].p, (ulong)argv[2].p, 0, 0, 0);
  1506f4:	2100      	movs	r1, #0
  1506f6:	460b      	mov	r3, r1
  1506f8:	460a      	mov	r2, r1
  1506fa:	9100      	str	r1, [sp, #0]
  1506fc:	6b21      	ldr	r1, [r4, #48]	; 0x30
  1506fe:	69e0      	ldr	r0, [r4, #28]
  150700:	f7f1 ea66 	blx	141bd0 <arch_chain_load>

00150704 <cmd_copy_mem>:
    if (argc < 4) {
  150704:	2803      	cmp	r0, #3
{
  150706:	b510      	push	{r4, r14}
  150708:	460c      	mov	r4, r1
    if (argc < 4) {
  15070a:	dd06      	ble.n	15071a <cmd_copy_mem+0x16>
    memcpy((void *)target, (const void *)source, len);
  15070c:	6c0a      	ldr	r2, [r1, #64]	; 0x40
  15070e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  150710:	6989      	ldr	r1, [r1, #24]
  150712:	f002 ec2e 	blx	152f70 <memcpy>
    return 0;
  150716:	2000      	movs	r0, #0
}
  150718:	bd10      	pop	{r4, r15}
        printf("not enough arguments\n");
  15071a:	f248 2088 	movw	r0, #33416	; 0x8288
  15071e:	f2c0 0015 	movt	r0, #21
  150722:	f003 fce9 	bl	1540f8 <_printf>
        printf("%s <source address> <target address> <len>\n", argv[0].str);
  150726:	6821      	ldr	r1, [r4, #0]
  150728:	f248 10e0 	movw	r0, #33248	; 0x81e0
  15072c:	f2c0 0015 	movt	r0, #21
  150730:	f003 fce2 	bl	1540f8 <_printf>
  150734:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  150738:	bd10      	pop	{r4, r15}
  15073a:	bf00      	nop

0015073c <print_version>:
    .project = PROJECT,
    .buildid = BUILDID
};

void print_version(void)
{
  15073c:	b500      	push	{r14}
#if !SUPPORT_FAST_BOOT
    //spl will wait 100ms for safety get hwid info, so spl close hwid print
    #ifndef NOT_OUT_PUT_HWID
    char hwid[100] = {""};
  15073e:	2300      	movs	r3, #0
{
  150740:	b09b      	sub	sp, #108	; 0x6c
    char hwid[100] = {""};
  150742:	4619      	mov	r1, r3
  150744:	2260      	movs	r2, #96	; 0x60
  150746:	9301      	str	r3, [sp, #4]
  150748:	a802      	add	r0, sp, #8
  15074a:	f002 ec98 	blx	15307c <memset>
    #endif
    printf("version:\n");
  15074e:	f248 40a0 	movw	r0, #33952	; 0x84a0
  150752:	f2c0 0015 	movt	r0, #21
  150756:	f003 fccf 	bl	1540f8 <_printf>
    printf("\tarch:     %s\n", version.arch);
  15075a:	f248 41ac 	movw	r1, #33964	; 0x84ac
  15075e:	f248 40b0 	movw	r0, #33968	; 0x84b0
  150762:	f2c0 0115 	movt	r1, #21
  150766:	f2c0 0015 	movt	r0, #21
  15076a:	f003 fcc5 	bl	1540f8 <_printf>
    printf("\tplatform: %s\n", version.platform);
  15076e:	f248 41c0 	movw	r1, #33984	; 0x84c0
  150772:	f248 40c8 	movw	r0, #33992	; 0x84c8
  150776:	f2c0 0115 	movt	r1, #21
  15077a:	f2c0 0015 	movt	r0, #21
  15077e:	f003 fcbb 	bl	1540f8 <_printf>
    printf("\ttarget:   %s\n", version.target);
  150782:	f248 41d8 	movw	r1, #34008	; 0x84d8
  150786:	f248 40e8 	movw	r0, #34024	; 0x84e8
  15078a:	f2c0 0115 	movt	r1, #21
  15078e:	f2c0 0015 	movt	r0, #21
  150792:	f003 fcb1 	bl	1540f8 <_printf>
    printf("\tproject:  %s\n", version.project);
  150796:	f248 41f8 	movw	r1, #34040	; 0x84f8
  15079a:	f248 5000 	movw	r0, #34048	; 0x8500
  15079e:	f2c0 0115 	movt	r1, #21
  1507a2:	f2c0 0015 	movt	r0, #21
  1507a6:	f003 fca7 	bl	1540f8 <_printf>
    printf("\tbuildid:  %s\n", version.buildid);
  1507aa:	f248 5110 	movw	r1, #34064	; 0x8510
  1507ae:	f248 5020 	movw	r0, #34080	; 0x8520
  1507b2:	f2c0 0115 	movt	r1, #21
  1507b6:	f2c0 0015 	movt	r0, #21
  1507ba:	f003 fc9d 	bl	1540f8 <_printf>
    #ifndef NOT_OUT_PUT_HWID
    printf("\thwid:     %s\n", get_hwid_friendly_name(hwid, 100));
  1507be:	2164      	movs	r1, #100	; 0x64
  1507c0:	a801      	add	r0, sp, #4
  1507c2:	f7fc fd83 	bl	14d2cc <get_hwid_friendly_name>
  1507c6:	4601      	mov	r1, r0
  1507c8:	f248 5030 	movw	r0, #34096	; 0x8530
  1507cc:	f2c0 0015 	movt	r0, #21
  1507d0:	f003 fc92 	bl	1540f8 <_printf>
    #endif
#endif
}
  1507d4:	b01b      	add	sp, #108	; 0x6c
  1507d6:	f85d fb04 	ldr.w	r15, [r13], #4
  1507da:	bf00      	nop

001507dc <cmd_version>:

#include <debug.h>
#include <lib/console.h>

static int cmd_version(int argc, const cmd_args *argv)
{
  1507dc:	b508      	push	{r3, r14}
    print_version();
  1507de:	f7ff ffad 	bl	15073c <print_version>
    return 0;
}
  1507e2:	2000      	movs	r0, #0
  1507e4:	bd08      	pop	{r3, r15}
  1507e6:	bf00      	nop

001507e8 <platform_quiesce>:
  1507e8:	4770      	bx	r14
  1507ea:	bf00      	nop

001507ec <platform_mpu_r5_common>:
{
#if ARM_WITH_MPU
    extern addr_t _nocacheable_start;
    extern addr_t _nocacheable_end;

    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  1507ec:	f241 4200 	movw	r2, #5120	; 0x1400
  1507f0:	f241 4100 	movw	r1, #5120	; 0x1400
  1507f4:	f2c0 0216 	movt	r2, #22
  1507f8:	f2c0 0116 	movt	r1, #22
  1507fc:	1a52      	subs	r2, r2, r1
  1507fe:	2a00      	cmp	r2, #0
{
  150800:	b538      	push	{r3, r4, r5, r14}
  150802:	4604      	mov	r4, r0
  150804:	f100 0501 	add.w	r5, r0, #1
    if ((&_nocacheable_end - &_nocacheable_start) > 0) {
  150808:	dd06      	ble.n	150818 <platform_mpu_r5_common+0x2c>
        mpu_add_region(region++, (addr_t)&_nocacheable_start,
  15080a:	2303      	movs	r3, #3
  15080c:	1092      	asrs	r2, r2, #2
  15080e:	f7f1 f86d 	bl	1418ec <mpu_add_region>
  150812:	1ca3      	adds	r3, r4, #2
  150814:	462c      	mov	r4, r5
  150816:	461d      	mov	r5, r3
                       &_nocacheable_end - &_nocacheable_start, MPU_REGION_NORMAL_NONCACHEABLE);
    }

    mpu_add_region(region++, APB_CKGEN_SEC_BASE, 0x04000000, MPU_REGION_DEVICE);
  150818:	4620      	mov	r0, r4
  15081a:	2301      	movs	r3, #1
  15081c:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  150820:	f04f 4178 	mov.w	r1, #4160749568	; 0xf8000000
  150824:	f7f1 f862 	bl	1418ec <mpu_add_region>

#endif
    return region;
}
  150828:	4628      	mov	r0, r5
  15082a:	bd38      	pop	{r3, r4, r5, r15}

0015082c <add_to_list>:
 * @param node - new element to add
 *
 */
void add_to_list(struct llist **head, struct llist *node)
{
    if (node == LIST_NULL)
  15082c:	b161      	cbz	r1, 150848 <add_to_list+0x1c>
    {
        return;
    }

    if (*head != LIST_NULL)
  15082e:	6803      	ldr	r3, [r0, #0]
  150830:	b133      	cbz	r3, 150840 <add_to_list+0x14>
    {
        /* Place the new element at the start of list. */
        node->next = *head;
        node->prev = LIST_NULL;
  150832:	2200      	movs	r2, #0
  150834:	e9c1 3202 	strd	r3, r2, [r1, #8]
        (*head)->prev = node;
  150838:	6803      	ldr	r3, [r0, #0]
  15083a:	60d9      	str	r1, [r3, #12]
        *head = node;
  15083c:	6001      	str	r1, [r0, #0]
  15083e:	4770      	bx	r14
    }
    else
    {
        /* List is empty - assign new element to list head. */
        *head = node;
  150840:	6001      	str	r1, [r0, #0]
        (*head)->next = LIST_NULL;
  150842:	608b      	str	r3, [r1, #8]
        (*head)->prev = LIST_NULL;
  150844:	6802      	ldr	r2, [r0, #0]
  150846:	60d3      	str	r3, [r2, #12]
    }
}
  150848:	4770      	bx	r14
  15084a:	bf00      	nop

0015084c <rpmsg_lite_rx_callback>:
 *
 * @param vq  Virtqueue affected by the kick
 *
 */
static void rpmsg_lite_rx_callback(struct virtqueue *vq)
{
  15084c:	b570      	push	{r4, r5, r6, r14}
    unsigned short idx;
    struct rpmsg_lite_endpoint *ept;
    int cb_ret;
    struct llist *node;
    struct rpmsg_hdr_reserved *rsvd;
    struct rpmsg_lite_instance *rpmsg_lite_dev = (struct rpmsg_lite_instance *)vq->priv;
  15084e:	6e45      	ldr	r5, [r0, #100]	; 0x64
{
  150850:	b084      	sub	sp, #16

    RL_ASSERT(rpmsg_lite_dev != NULL);
  150852:	2d00      	cmp	r5, #0
  150854:	d033      	beq.n	1508be <rpmsg_lite_rx_callback+0x72>

    /* Process the received data from remote node */
    rpmsg_msg = (struct rpmsg_std_msg *)rpmsg_lite_dev->vq_ops->vq_rx(rpmsg_lite_dev->rvq, &len, &idx);
  150856:	6a2b      	ldr	r3, [r5, #32]
  150858:	f10d 020a 	add.w	r2, r13, #10
  15085c:	6828      	ldr	r0, [r5, #0]
  15085e:	a903      	add	r1, sp, #12
  150860:	689b      	ldr	r3, [r3, #8]
  150862:	4798      	blx	r3
    if (rpmsg_msg)
        hexdump(rpmsg_msg, sizeof(struct rpmsg_std_msg));
#endif
#endif

    while (rpmsg_msg)
  150864:	4604      	mov	r4, r0
  150866:	b320      	cbz	r0, 1508b2 <rpmsg_lite_rx_callback+0x66>
        printf("[%lld] rx %d->%d %d idx:%d\n",
                     current_time_hires(),
                     rpmsg_msg->hdr.src, rpmsg_msg->hdr.dst,
                     rpmsg_msg->hdr.len, idx);
#endif
        node = rpmsg_lite_get_endpoint_from_addr(rpmsg_lite_dev, rpmsg_msg->hdr.dst);
  150868:	68ab      	ldr	r3, [r5, #8]
  15086a:	6860      	ldr	r0, [r4, #4]
    while (rl_ept_lut_head)
  15086c:	b913      	cbnz	r3, 150874 <rpmsg_lite_rx_callback+0x28>
  15086e:	e00e      	b.n	15088e <rpmsg_lite_rx_callback+0x42>
        rl_ept_lut_head = rl_ept_lut_head->next;
  150870:	689b      	ldr	r3, [r3, #8]
    while (rl_ept_lut_head)
  150872:	b163      	cbz	r3, 15088e <rpmsg_lite_rx_callback+0x42>
        struct rpmsg_lite_endpoint *rl_ept = (struct rpmsg_lite_endpoint *)rl_ept_lut_head->data;
  150874:	681a      	ldr	r2, [r3, #0]
        if (rl_ept->addr == addr)
  150876:	6811      	ldr	r1, [r2, #0]
  150878:	4288      	cmp	r0, r1
  15087a:	d1f9      	bne.n	150870 <rpmsg_lite_rx_callback+0x24>

        cb_ret = RL_RELEASE;
        if (node != RL_NULL)
        {
            ept = (struct rpmsg_lite_endpoint *)node->data;
            cb_ret = ept->rx_cb(rpmsg_msg->data, rpmsg_msg->hdr.len, rpmsg_msg->hdr.src, ept->rx_cb_data);
  15087c:	6856      	ldr	r6, [r2, #4]
  15087e:	89a1      	ldrh	r1, [r4, #12]
  150880:	6893      	ldr	r3, [r2, #8]
  150882:	f104 0010 	add.w	r0, r4, #16
  150886:	6822      	ldr	r2, [r4, #0]
  150888:	47b0      	blx	r6
            hexdump(rpmsg_msg->data, rpmsg_msg->hdr.len);
#endif
#endif
        }

        if (cb_ret == RL_HOLD)
  15088a:	2801      	cmp	r0, #1
  15088c:	d013      	beq.n	1508b6 <rpmsg_lite_rx_callback+0x6a>
            rsvd = (struct rpmsg_hdr_reserved *)&rpmsg_msg->hdr.reserved;
            rsvd->idx = idx;
        }
        else
        {
            rpmsg_lite_dev->vq_ops->vq_rx_free(rpmsg_lite_dev->rvq, rpmsg_msg, len, idx);
  15088e:	6a2e      	ldr	r6, [r5, #32]
  150890:	4621      	mov	r1, r4
  150892:	f8bd 300a 	ldrh.w	r3, [r13, #10]
  150896:	9a03      	ldr	r2, [sp, #12]
  150898:	6828      	ldr	r0, [r5, #0]
  15089a:	68f4      	ldr	r4, [r6, #12]
  15089c:	47a0      	blx	r4
        }
        rpmsg_msg = (struct rpmsg_std_msg *)rpmsg_lite_dev->vq_ops->vq_rx(rpmsg_lite_dev->rvq, &len, &idx);
  15089e:	6a2b      	ldr	r3, [r5, #32]
  1508a0:	f10d 020a 	add.w	r2, r13, #10
  1508a4:	6828      	ldr	r0, [r5, #0]
  1508a6:	a903      	add	r1, sp, #12
  1508a8:	689b      	ldr	r3, [r3, #8]
  1508aa:	4798      	blx	r3
    while (rpmsg_msg)
  1508ac:	4604      	mov	r4, r0
  1508ae:	2800      	cmp	r0, #0
  1508b0:	d1da      	bne.n	150868 <rpmsg_lite_rx_callback+0x1c>

#if (LK_DEBUGLEVEL > 1)
    printf("%s: exit\n", __func__);
#endif

}
  1508b2:	b004      	add	sp, #16
  1508b4:	bd70      	pop	{r4, r5, r6, r15}
            rsvd->idx = idx;
  1508b6:	f8bd 300a 	ldrh.w	r3, [r13, #10]
  1508ba:	8163      	strh	r3, [r4, #10]
  1508bc:	e7ef      	b.n	15089e <rpmsg_lite_rx_callback+0x52>
    RL_ASSERT(rpmsg_lite_dev != NULL);
  1508be:	f645 7370 	movw	r3, #24432	; 0x5f70
  1508c2:	f248 52a0 	movw	r2, #34208	; 0x85a0
  1508c6:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1508ca:	f2c0 0315 	movt	r3, #21
  1508ce:	4670      	mov	r0, r14
  1508d0:	f2c0 0215 	movt	r2, #21
  1508d4:	9300      	str	r3, [sp, #0]
  1508d6:	f2c0 0115 	movt	r1, #21
  1508da:	23a1      	movs	r3, #161	; 0xa1
  1508dc:	f002 f9ea 	bl	152cb4 <_panic>

001508e0 <virtqueue_get_notified>:

static void virtqueue_get_notified(struct sd_ipcc_chan *chan, u8* mssg, uint32_t len)
{
    struct ipcc_notify_msg *notify_msg;
    struct rpmsg_lite_endpoint *ept;
    struct rpmsg_lite_instance *rpmsg_lite_dev =
  1508e0:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
  1508e4:	7889      	ldrb	r1, [r1, #2]
    hexdump(mssg, len);
#endif
    /* Process the received data from remote node */
    notify_msg = (struct ipcc_notify_msg *) mssg;

    if (rpmsg_lite_dev->is_master) {
  1508e6:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
  1508ea:	b118      	cbz	r0, 1508f4 <virtqueue_get_notified+0x14>
        if (notify_msg->vq_id == 0) {
  1508ec:	b921      	cbnz	r1, 1508f8 <virtqueue_get_notified+0x18>
    } else {
        /* this for remote device */
        if (notify_msg->vq_id == 0) {
            vq = rpmsg_lite_dev->tvq;
        } else {
            vq = rpmsg_lite_dev->rvq;
  1508ee:	6818      	ldr	r0, [r3, #0]
        }
    }
    if (notify_msg && len)
  1508f0:	b92a      	cbnz	r2, 1508fe <virtqueue_get_notified+0x1e>
#if CONFIG_RPMSG_THREAD_MQ
        sd_ipcc_chan_free_buffer(chan, mssg);
#endif
        virtqueue_notification(vq);
    }
}
  1508f2:	4770      	bx	r14
        if (notify_msg->vq_id == 0) {
  1508f4:	2900      	cmp	r1, #0
  1508f6:	d1fa      	bne.n	1508ee <virtqueue_get_notified+0xe>
            vq = rpmsg_lite_dev->tvq;
  1508f8:	6858      	ldr	r0, [r3, #4]
    if (notify_msg && len)
  1508fa:	2a00      	cmp	r2, #0
  1508fc:	d0f9      	beq.n	1508f2 <virtqueue_get_notified+0x12>
        virtqueue_notification(vq);
  1508fe:	f000 beed 	b.w	1516dc <virtqueue_notification>
  150902:	bf00      	nop

00150904 <virtqueue_notify>:

#endif

/* helper function for virtqueue notification */
static void virtqueue_notify(struct virtqueue *vq)
{
  150904:	b570      	push	{r4, r5, r6, r14}
  150906:	4604      	mov	r4, r0
  150908:	b082      	sub	sp, #8
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
    struct rpmsg_lite_instance * inst = vq->priv;
    platform_notify(inst->env ? env_get_platform_context(inst->env) : NULL, vq->vq_queue_index);
#else
    platform_notify(vq->vq_queue_index);
  15090a:	f8b0 0050 	ldrh.w	r0, [r0, #80]	; 0x50
  15090e:	f000 fff7 	bl	151900 <platform_notify>
#if (LK_DEBUGLEVEL > 0)
    printf("%s %d->%d vq=%d t=%x cc=%d\n", chan->ch_name,
                dcf_get_this_proc(), chan->rproc,
                msg.vq_id, msg.device_type, msg.cc);
#endif
    sd_ipcc_chan_send_data(chan, (u8 *) &msg, sizeof(struct ipcc_notify_msg));
  150912:	2204      	movs	r2, #4
    struct rpmsg_lite_instance * inst = vq->priv;
  150914:	6e63      	ldr	r3, [r4, #100]	; 0x64
    msg.cc = inst->counter++;
  150916:	f893 5029 	ldrb.w	r5, [r3, #41]	; 0x29
    msg.device_type = inst->is_master ? 0x80 : 0x81;
  15091a:	f893 0028 	ldrb.w	r0, [r3, #40]	; 0x28
  15091e:	2800      	cmp	r0, #0
    msg.vq_id = RL_GET_Q_ID(vq->vq_queue_index);
  150920:	f894 4050 	ldrb.w	r4, [r4, #80]	; 0x50
    msg.device_type = inst->is_master ? 0x80 : 0x81;
  150924:	bf14      	ite	ne
  150926:	2680      	movne	r6, #128	; 0x80
  150928:	2681      	moveq	r6, #129	; 0x81
    msg.cc = inst->counter++;
  15092a:	1c68      	adds	r0, r5, #1
    msg.vq_id = RL_GET_Q_ID(vq->vq_queue_index);
  15092c:	f004 0401 	and.w	r4, r4, #1
    msg.cc = inst->counter++;
  150930:	f883 0029 	strb.w	r0, [r3, #41]	; 0x29
    sd_ipcc_chan_send_data(chan, (u8 *) &msg, sizeof(struct ipcc_notify_msg));
  150934:	eb0d 0102 	add.w	r1, r13, r2
  150938:	6a58      	ldr	r0, [r3, #36]	; 0x24
    msg.vq_id = RL_GET_Q_ID(vq->vq_queue_index);
  15093a:	f88d 4006 	strb.w	r4, [r13, #6]
    msg.cc = inst->counter++;
  15093e:	f88d 5005 	strb.w	r5, [r13, #5]
    msg.device_type = inst->is_master ? 0x80 : 0x81;
  150942:	f88d 6004 	strb.w	r6, [r13, #4]
    sd_ipcc_chan_send_data(chan, (u8 *) &msg, sizeof(struct ipcc_notify_msg));
  150946:	f7fa f993 	bl	14ac70 <sd_ipcc_chan_send_data>
#endif
}
  15094a:	b002      	add	sp, #8
  15094c:	bd70      	pop	{r4, r5, r6, r15}
  15094e:	bf00      	nop

00150950 <vq_tx_alloc_master>:
    return virtqueue_get_buffer(tvq, (uint32_t *)len, idx);
  150950:	f000 bdbe 	b.w	1514d0 <virtqueue_get_buffer>

00150954 <vq_tx_alloc_remote>:
{
  150954:	4613      	mov	r3, r2
    return virtqueue_get_available_buffer(tvq, idx, (uint32_t *)len);
  150956:	460a      	mov	r2, r1
  150958:	4619      	mov	r1, r3
  15095a:	f000 bdf9 	b.w	151550 <virtqueue_get_available_buffer>
  15095e:	bf00      	nop

00150960 <rpmsg_lite_tx_callback>:
    struct rpmsg_lite_instance *rpmsg_lite_dev = (struct rpmsg_lite_instance *)vq->priv;
  150960:	6e43      	ldr	r3, [r0, #100]	; 0x64
    RL_ASSERT(rpmsg_lite_dev != NULL);
  150962:	b113      	cbz	r3, 15096a <rpmsg_lite_tx_callback+0xa>
    rpmsg_lite_dev->link_state = 1;
  150964:	2201      	movs	r2, #1
  150966:	611a      	str	r2, [r3, #16]
  150968:	4770      	bx	r14
    RL_ASSERT(rpmsg_lite_dev != NULL);
  15096a:	f645 7370 	movw	r3, #24432	; 0x5f70
  15096e:	f248 52a0 	movw	r2, #34208	; 0x85a0
{
  150972:	b500      	push	{r14}
    RL_ASSERT(rpmsg_lite_dev != NULL);
  150974:	f2c0 0315 	movt	r3, #21
  150978:	f644 316c 	movw	r1, #19308	; 0x4b6c
{
  15097c:	b083      	sub	sp, #12
  15097e:	4670      	mov	r0, r14
    RL_ASSERT(rpmsg_lite_dev != NULL);
  150980:	f2c0 0215 	movt	r2, #21
  150984:	9300      	str	r3, [sp, #0]
  150986:	f2c0 0115 	movt	r1, #21
  15098a:	23e4      	movs	r3, #228	; 0xe4
  15098c:	f002 f992 	bl	152cb4 <_panic>

00150990 <vq_rx_free_master>:
{
  150990:	b510      	push	{r4, r14}
    status = virtqueue_add_buffer(rvq, idx);
  150992:	4619      	mov	r1, r3
{
  150994:	b082      	sub	sp, #8
  150996:	4674      	mov	r4, r14
    status = virtqueue_add_buffer(rvq, idx);
  150998:	f000 fd70 	bl	15147c <virtqueue_add_buffer>
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  15099c:	b908      	cbnz	r0, 1509a2 <vq_rx_free_master+0x12>
}
  15099e:	b002      	add	sp, #8
  1509a0:	bd10      	pop	{r4, r15}
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  1509a2:	f645 7370 	movw	r3, #24432	; 0x5f70
  1509a6:	f248 52a0 	movw	r2, #34208	; 0x85a0
  1509aa:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1509ae:	f2c0 0315 	movt	r3, #21
  1509b2:	4620      	mov	r0, r4
  1509b4:	f2c0 0215 	movt	r2, #21
  1509b8:	9300      	str	r3, [sp, #0]
  1509ba:	f2c0 0115 	movt	r1, #21
  1509be:	f240 138f 	movw	r3, #399	; 0x18f
  1509c2:	f002 f977 	bl	152cb4 <_panic>
  1509c6:	bf00      	nop

001509c8 <vq_tx_master>:
{
  1509c8:	b510      	push	{r4, r14}
    status = virtqueue_add_buffer(tvq, idx);
  1509ca:	4619      	mov	r1, r3
{
  1509cc:	b082      	sub	sp, #8
  1509ce:	4674      	mov	r4, r14
    status = virtqueue_add_buffer(tvq, idx);
  1509d0:	f000 fd54 	bl	15147c <virtqueue_add_buffer>
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  1509d4:	b908      	cbnz	r0, 1509da <vq_tx_master+0x12>
}
  1509d6:	b002      	add	sp, #8
  1509d8:	bd10      	pop	{r4, r15}
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  1509da:	f645 7370 	movw	r3, #24432	; 0x5f70
  1509de:	f248 52a0 	movw	r2, #34208	; 0x85a0
  1509e2:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1509e6:	f2c0 0315 	movt	r3, #21
  1509ea:	4620      	mov	r0, r4
  1509ec:	f2c0 0215 	movt	r2, #21
  1509f0:	9300      	str	r3, [sp, #0]
  1509f2:	f2c0 0115 	movt	r1, #21
  1509f6:	f240 1359 	movw	r3, #345	; 0x159
  1509fa:	f002 f95b 	bl	152cb4 <_panic>
  1509fe:	bf00      	nop

00150a00 <vq_rx_free_remote>:
{
  150a00:	b510      	push	{r4, r14}
    status = virtqueue_add_consumed_buffer(rvq, idx, len);
  150a02:	4619      	mov	r1, r3
{
  150a04:	b082      	sub	sp, #8
  150a06:	4674      	mov	r4, r14
    status = virtqueue_add_consumed_buffer(rvq, idx, len);
  150a08:	f000 fdc8 	bl	15159c <virtqueue_add_consumed_buffer>
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  150a0c:	b908      	cbnz	r0, 150a12 <vq_rx_free_remote+0x12>
}
  150a0e:	b002      	add	sp, #8
  150a10:	bd10      	pop	{r4, r15}
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  150a12:	f645 7370 	movw	r3, #24432	; 0x5f70
  150a16:	f248 52a0 	movw	r2, #34208	; 0x85a0
  150a1a:	f644 316c 	movw	r1, #19308	; 0x4b6c
  150a1e:	f2c0 0315 	movt	r3, #21
  150a22:	4620      	mov	r0, r4
  150a24:	f2c0 0215 	movt	r2, #21
  150a28:	9300      	str	r3, [sp, #0]
  150a2a:	f2c0 0115 	movt	r1, #21
  150a2e:	f44f 739c 	mov.w	r3, #312	; 0x138
  150a32:	f002 f93f 	bl	152cb4 <_panic>
  150a36:	bf00      	nop

00150a38 <vq_tx_remote>:
{
  150a38:	b510      	push	{r4, r14}
    status = virtqueue_add_consumed_buffer(tvq, idx, len);
  150a3a:	4619      	mov	r1, r3
{
  150a3c:	b082      	sub	sp, #8
  150a3e:	4674      	mov	r4, r14
    status = virtqueue_add_consumed_buffer(tvq, idx, len);
  150a40:	f000 fdac 	bl	15159c <virtqueue_add_consumed_buffer>
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  150a44:	b908      	cbnz	r0, 150a4a <vq_tx_remote+0x12>
}
  150a46:	b002      	add	sp, #8
  150a48:	bd10      	pop	{r4, r15}
    RL_ASSERT(status == VQUEUE_SUCCESS); /* must success here */
  150a4a:	f645 7370 	movw	r3, #24432	; 0x5f70
  150a4e:	f248 52a0 	movw	r2, #34208	; 0x85a0
  150a52:	f644 316c 	movw	r1, #19308	; 0x4b6c
  150a56:	f2c0 0315 	movt	r3, #21
  150a5a:	4620      	mov	r0, r4
  150a5c:	f2c0 0215 	movt	r2, #21
  150a60:	9300      	str	r3, [sp, #0]
  150a62:	f2c0 0115 	movt	r1, #21
  150a66:	f44f 7381 	mov.w	r3, #258	; 0x102
  150a6a:	f002 f923 	bl	152cb4 <_panic>
  150a6e:	bf00      	nop

00150a70 <vq_rx_master>:
  150a70:	f000 bd2e 	b.w	1514d0 <virtqueue_get_buffer>

00150a74 <vq_rx_remote>:
  150a74:	4613      	mov	r3, r2
  150a76:	460a      	mov	r2, r1
  150a78:	4619      	mov	r1, r3
  150a7a:	f000 bd69 	b.w	151550 <virtqueue_get_available_buffer>
  150a7e:	bf00      	nop

00150a80 <rpmsg_lite_create_ept>:
struct rpmsg_lite_endpoint *rpmsg_lite_create_ept(struct rpmsg_lite_instance *rpmsg_lite_dev,
                                                  unsigned long addr,
                                                  rl_ept_rx_cb_t rx_cb,
                                                  void *rx_cb_data)
#endif
{
  150a80:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    struct rpmsg_lite_endpoint *rl_ept;
    struct llist *node;
    unsigned int i;

    if (!rpmsg_lite_dev)
  150a84:	4605      	mov	r5, r0
  150a86:	2800      	cmp	r0, #0
  150a88:	d04c      	beq.n	150b24 <rpmsg_lite_create_ept+0xa4>
  150a8a:	460c      	mov	r4, r1
  150a8c:	4617      	mov	r7, r2
    {
        return RL_NULL;
    }

    env_lock_mutex(rpmsg_lite_dev->lock);
  150a8e:	68c0      	ldr	r0, [r0, #12]
  150a90:	461e      	mov	r6, r3
  150a92:	f000 fecd 	bl	151830 <env_lock_mutex>
    {
        if (addr == RL_ADDR_ANY)
  150a96:	1c62      	adds	r2, r4, #1
  150a98:	d010      	beq.n	150abc <rpmsg_lite_create_ept+0x3c>
                return RL_NULL;
            }
        }
        else
        {
            if (rpmsg_lite_get_endpoint_from_addr(rpmsg_lite_dev, addr) != RL_NULL)
  150a9a:	68ab      	ldr	r3, [r5, #8]
    while (rl_ept_lut_head)
  150a9c:	b913      	cbnz	r3, 150aa4 <rpmsg_lite_create_ept+0x24>
  150a9e:	e01d      	b.n	150adc <rpmsg_lite_create_ept+0x5c>
        rl_ept_lut_head = rl_ept_lut_head->next;
  150aa0:	689b      	ldr	r3, [r3, #8]
    while (rl_ept_lut_head)
  150aa2:	b1db      	cbz	r3, 150adc <rpmsg_lite_create_ept+0x5c>
        if (rl_ept->addr == addr)
  150aa4:	681a      	ldr	r2, [r3, #0]
  150aa6:	6812      	ldr	r2, [r2, #0]
  150aa8:	4294      	cmp	r4, r2
  150aaa:	d1f9      	bne.n	150aa0 <rpmsg_lite_create_ept+0x20>
                env_unlock_mutex(rpmsg_lite_dev->lock);
  150aac:	68e8      	ldr	r0, [r5, #12]
                return RL_NULL;
  150aae:	f04f 0800 	mov.w	r8, #0
                env_unlock_mutex(rpmsg_lite_dev->lock);
  150ab2:	f000 fec9 	bl	151848 <env_unlock_mutex>
        add_to_list((struct llist **)&rpmsg_lite_dev->rl_endpoints, node);
    }
    env_unlock_mutex(rpmsg_lite_dev->lock);

    return rl_ept;
}
  150ab6:	4640      	mov	r0, r8
  150ab8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
                if (rpmsg_lite_get_endpoint_from_addr(rpmsg_lite_dev, i) == RL_NULL)
  150abc:	68a9      	ldr	r1, [r5, #8]
            for (i = 1; i < 0xFFFFFFFF; i++)
  150abe:	2401      	movs	r4, #1
    while (rl_ept_lut_head)
  150ac0:	b161      	cbz	r1, 150adc <rpmsg_lite_create_ept+0x5c>
        if (rl_ept->addr == addr)
  150ac2:	680b      	ldr	r3, [r1, #0]
  150ac4:	681b      	ldr	r3, [r3, #0]
  150ac6:	42a3      	cmp	r3, r4
  150ac8:	d028      	beq.n	150b1c <rpmsg_lite_create_ept+0x9c>
  150aca:	460b      	mov	r3, r1
  150acc:	e003      	b.n	150ad6 <rpmsg_lite_create_ept+0x56>
  150ace:	681a      	ldr	r2, [r3, #0]
  150ad0:	6812      	ldr	r2, [r2, #0]
  150ad2:	42a2      	cmp	r2, r4
  150ad4:	d022      	beq.n	150b1c <rpmsg_lite_create_ept+0x9c>
        rl_ept_lut_head = rl_ept_lut_head->next;
  150ad6:	689b      	ldr	r3, [r3, #8]
    while (rl_ept_lut_head)
  150ad8:	2b00      	cmp	r3, #0
  150ada:	d1f8      	bne.n	150ace <rpmsg_lite_create_ept+0x4e>
        rl_ept = env_allocate_memory(sizeof(struct rpmsg_lite_endpoint));
  150adc:	2010      	movs	r0, #16
  150ade:	f000 fe73 	bl	1517c8 <env_allocate_memory>
        if (!rl_ept)
  150ae2:	4680      	mov	r8, r0
  150ae4:	b1a0      	cbz	r0, 150b10 <rpmsg_lite_create_ept+0x90>
        node = env_allocate_memory(sizeof(struct llist));
  150ae6:	2010      	movs	r0, #16
  150ae8:	f000 fe6e 	bl	1517c8 <env_allocate_memory>
        if (!node)
  150aec:	4681      	mov	r9, r0
  150aee:	b1d8      	cbz	r0, 150b28 <rpmsg_lite_create_ept+0xa8>
        env_memset(rl_ept, 0x00, sizeof(struct rpmsg_lite_endpoint));
  150af0:	2100      	movs	r1, #0
  150af2:	4640      	mov	r0, r8
  150af4:	2210      	movs	r2, #16
  150af6:	f000 fe6d 	bl	1517d4 <env_memset>
        rl_ept->rx_cb = rx_cb;
  150afa:	e9c8 4700 	strd	r4, r7, [r8]
        rl_ept->rx_cb_data = rx_cb_data;
  150afe:	f8c8 6008 	str.w	r6, [r8, #8]
        add_to_list((struct llist **)&rpmsg_lite_dev->rl_endpoints, node);
  150b02:	4649      	mov	r1, r9
        node->data = rl_ept;
  150b04:	f8c9 8000 	str.w	r8, [r9]
        add_to_list((struct llist **)&rpmsg_lite_dev->rl_endpoints, node);
  150b08:	f105 0008 	add.w	r0, r5, #8
  150b0c:	f7ff fe8e 	bl	15082c <add_to_list>
    env_unlock_mutex(rpmsg_lite_dev->lock);
  150b10:	68e8      	ldr	r0, [r5, #12]
  150b12:	f000 fe99 	bl	151848 <env_unlock_mutex>
}
  150b16:	4640      	mov	r0, r8
  150b18:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            for (i = 1; i < 0xFFFFFFFF; i++)
  150b1c:	3401      	adds	r4, #1
  150b1e:	1c63      	adds	r3, r4, #1
  150b20:	d1ce      	bne.n	150ac0 <rpmsg_lite_create_ept+0x40>
  150b22:	e7c3      	b.n	150aac <rpmsg_lite_create_ept+0x2c>
        return RL_NULL;
  150b24:	4680      	mov	r8, r0
  150b26:	e7f6      	b.n	150b16 <rpmsg_lite_create_ept+0x96>
            env_free_memory(rl_ept);
  150b28:	4640      	mov	r0, r8
            return RL_NULL;
  150b2a:	46c8      	mov	r8, r9
            env_free_memory(rl_ept);
  150b2c:	f000 fe4e 	bl	1517cc <env_free_memory>
            env_unlock_mutex(rpmsg_lite_dev->lock);
  150b30:	68e8      	ldr	r0, [r5, #12]
  150b32:	f000 fe89 	bl	151848 <env_unlock_mutex>
            return RL_NULL;
  150b36:	e7ee      	b.n	150b16 <rpmsg_lite_create_ept+0x96>

00150b38 <rpmsg_lite_is_link_up>:

*******************************************/

int rpmsg_lite_is_link_up(struct rpmsg_lite_instance *rpmsg_lite_dev)
{
    if (!rpmsg_lite_dev)
  150b38:	b100      	cbz	r0, 150b3c <rpmsg_lite_is_link_up+0x4>
    {
        return 0;
    }

    return rpmsg_lite_dev->link_state;
  150b3a:	6900      	ldr	r0, [r0, #16]
}
  150b3c:	4770      	bx	r14
  150b3e:	bf00      	nop

00150b40 <rpmsg_lite_kick_remote>:
 * Let the remote device know that Master is ready for
 * communication.
 */
int rpmsg_lite_kick_remote(struct rpmsg_lite_instance *rpmsg_lite_dev)
{
    if (!rpmsg_lite_dev)
  150b40:	b128      	cbz	r0, 150b4e <rpmsg_lite_kick_remote+0xe>
{
  150b42:	b508      	push	{r3, r14}
    {
        return -1;
    }

    virtqueue_kick(rpmsg_lite_dev->rvq);
  150b44:	6800      	ldr	r0, [r0, #0]
  150b46:	f000 fd8b 	bl	151660 <virtqueue_kick>

    return 0;
  150b4a:	2000      	movs	r0, #0
}
  150b4c:	bd08      	pop	{r3, r15}
        return -1;
  150b4e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  150b52:	4770      	bx	r14

00150b54 <rpmsg_lite_format_message>:
                              unsigned long dst,
                              char *data,
                              unsigned long size,
                              int flags,
                              unsigned long timeout)
{
  150b54:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  150b58:	b082      	sub	sp, #8
    if (!rpmsg_lite_dev)
    {
        return RL_ERR_PARAM;
    }

    if (!data)
  150b5a:	2800      	cmp	r0, #0
  150b5c:	bf18      	it	ne
  150b5e:	2b00      	cmpne	r3, #0
{
  150b60:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    if (!data)
  150b62:	d060      	beq.n	150c26 <rpmsg_lite_format_message+0xd2>
    {
        return RL_ERR_PARAM;
    }

    if (!rpmsg_lite_dev->link_state)
  150b64:	6904      	ldr	r4, [r0, #16]
  150b66:	2c00      	cmp	r4, #0
  150b68:	d058      	beq.n	150c1c <rpmsg_lite_format_message+0xc8>
  150b6a:	4604      	mov	r4, r0
  150b6c:	4698      	mov	r8, r3
    {
        return RL_NOT_READY;
    }

    /* Lock the device to enable exclusive access to virtqueues */
    env_lock_mutex(rpmsg_lite_dev->lock);
  150b6e:	68c0      	ldr	r0, [r0, #12]
  150b70:	4692      	mov	r10, r2
  150b72:	4689      	mov	r9, r1
  150b74:	f000 fe5c 	bl	151830 <env_lock_mutex>
    /* Get rpmsg buffer for sending message. */
    buffer = rpmsg_lite_dev->vq_ops->vq_tx_alloc(rpmsg_lite_dev->tvq, &buff_len, &idx);
  150b78:	6a23      	ldr	r3, [r4, #32]
  150b7a:	f10d 0202 	add.w	r2, r13, #2
  150b7e:	6860      	ldr	r0, [r4, #4]
  150b80:	a901      	add	r1, sp, #4
  150b82:	685b      	ldr	r3, [r3, #4]
  150b84:	4798      	blx	r3
  150b86:	4605      	mov	r5, r0
    env_unlock_mutex(rpmsg_lite_dev->lock);
  150b88:	68e0      	ldr	r0, [r4, #12]
  150b8a:	f000 fe5d 	bl	151848 <env_unlock_mutex>

    if (!buffer && !timeout)
  150b8e:	2d00      	cmp	r5, #0
  150b90:	bf08      	it	eq
  150b92:	2f00      	cmpeq	r7, #0
  150b94:	d019      	beq.n	150bca <rpmsg_lite_format_message+0x76>
    {
        return RL_ERR_NO_MEM;
    }

    while (!buffer)
  150b96:	b9fd      	cbnz	r5, 150bd8 <rpmsg_lite_format_message+0x84>
    unsigned long tick_count = 0;
  150b98:	462e      	mov	r6, r5
  150b9a:	e000      	b.n	150b9e <rpmsg_lite_format_message+0x4a>
    while (!buffer)
  150b9c:	b9e5      	cbnz	r5, 150bd8 <rpmsg_lite_format_message+0x84>
    {
        env_sleep_msec(RL_MS_PER_INTERVAL);
  150b9e:	2001      	movs	r0, #1
        env_lock_mutex(rpmsg_lite_dev->lock);
        buffer = rpmsg_lite_dev->vq_ops->vq_tx_alloc(rpmsg_lite_dev->tvq, &buff_len, &idx);
        env_unlock_mutex(rpmsg_lite_dev->lock);
        tick_count += RL_MS_PER_INTERVAL;
  150ba0:	4406      	add	r6, r0
        env_sleep_msec(RL_MS_PER_INTERVAL);
  150ba2:	f000 fe5d 	bl	151860 <env_sleep_msec>
        env_lock_mutex(rpmsg_lite_dev->lock);
  150ba6:	68e0      	ldr	r0, [r4, #12]
  150ba8:	f000 fe42 	bl	151830 <env_lock_mutex>
        buffer = rpmsg_lite_dev->vq_ops->vq_tx_alloc(rpmsg_lite_dev->tvq, &buff_len, &idx);
  150bac:	6a25      	ldr	r5, [r4, #32]
  150bae:	f10d 0202 	add.w	r2, r13, #2
  150bb2:	6860      	ldr	r0, [r4, #4]
  150bb4:	a901      	add	r1, sp, #4
  150bb6:	686b      	ldr	r3, [r5, #4]
  150bb8:	4798      	blx	r3
  150bba:	4605      	mov	r5, r0
        env_unlock_mutex(rpmsg_lite_dev->lock);
  150bbc:	68e0      	ldr	r0, [r4, #12]
  150bbe:	f000 fe43 	bl	151848 <env_unlock_mutex>
        if ((tick_count >= timeout) && (!buffer))
  150bc2:	42b7      	cmp	r7, r6
  150bc4:	bf98      	it	ls
  150bc6:	2d00      	cmpls	r5, #0
  150bc8:	d1e8      	bne.n	150b9c <rpmsg_lite_format_message+0x48>
        return RL_ERR_NO_MEM;
  150bca:	f64e 4077 	movw	r0, #60535	; 0xec77
  150bce:	f6cf 70ff 	movt	r0, #65535	; 0xffff
    printf("[%lld] tx %d->%d %d idx:%d va:%p \n",
           current_time_hires(), src, dst, size, idx, buffer);
#endif

    return RL_SUCCESS;
}
  150bd2:	b002      	add	sp, #8
  150bd4:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    env_memcpy(rpmsg_msg->data, data, size);
  150bd8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  150bda:	4641      	mov	r1, r8
    rpmsg_msg->hdr.flags = flags;
  150bdc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    env_memcpy(rpmsg_msg->data, data, size);
  150bde:	f105 0010 	add.w	r0, r5, #16
    rpmsg_msg->hdr.len = size;
  150be2:	81aa      	strh	r2, [r5, #12]
    rpmsg_msg->hdr.flags = flags;
  150be4:	81eb      	strh	r3, [r5, #14]
    rpmsg_msg->hdr.dst = dst;
  150be6:	f8c5 a004 	str.w	r10, [r5, #4]
    rpmsg_msg->hdr.src = src;
  150bea:	f8c5 9000 	str.w	r9, [r5]
    env_memcpy(rpmsg_msg->data, data, size);
  150bee:	f000 fdf3 	bl	1517d8 <env_memcpy>
    env_lock_mutex(rpmsg_lite_dev->lock);
  150bf2:	68e0      	ldr	r0, [r4, #12]
  150bf4:	f000 fe1c 	bl	151830 <env_lock_mutex>
    rpmsg_lite_dev->vq_ops->vq_tx(rpmsg_lite_dev->tvq, buffer, buff_len, idx);
  150bf8:	6a20      	ldr	r0, [r4, #32]
  150bfa:	f8bd 3002 	ldrh.w	r3, [r13, #2]
  150bfe:	9a01      	ldr	r2, [sp, #4]
  150c00:	4629      	mov	r1, r5
  150c02:	6805      	ldr	r5, [r0, #0]
  150c04:	6860      	ldr	r0, [r4, #4]
  150c06:	47a8      	blx	r5
    virtqueue_kick(rpmsg_lite_dev->tvq);
  150c08:	6860      	ldr	r0, [r4, #4]
  150c0a:	f000 fd29 	bl	151660 <virtqueue_kick>
    env_unlock_mutex(rpmsg_lite_dev->lock);
  150c0e:	68e0      	ldr	r0, [r4, #12]
  150c10:	f000 fe1a 	bl	151848 <env_unlock_mutex>
    return RL_SUCCESS;
  150c14:	2000      	movs	r0, #0
}
  150c16:	b002      	add	sp, #8
  150c18:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
        return RL_NOT_READY;
  150c1c:	f64e 4071 	movw	r0, #60529	; 0xec71
  150c20:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  150c24:	e7d5      	b.n	150bd2 <rpmsg_lite_format_message+0x7e>
        return RL_ERR_PARAM;
  150c26:	f64e 4075 	movw	r0, #60533	; 0xec75
  150c2a:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  150c2e:	e7d0      	b.n	150bd2 <rpmsg_lite_format_message+0x7e>

00150c30 <rpmsg_lite_send>:
                    struct rpmsg_lite_endpoint *ept,
                    unsigned long dst,
                    char *data,
                    unsigned long size,
                    unsigned long timeout)
{
  150c30:	b570      	push	{r4, r5, r6, r14}
  150c32:	b084      	sub	sp, #16
  150c34:	9c08      	ldr	r4, [sp, #32]
    if (!ept)
  150c36:	b181      	cbz	r1, 150c5a <rpmsg_lite_send+0x2a>
    {
        return RL_ERR_PARAM;
    }

    // FIXME : may be just copy the data size equal to buffer length and Tx it.
    if (size > RL_BUFFER_PAYLOAD_SIZE)
  150c38:	f5b4 7ff8 	cmp.w	r4, #496	; 0x1f0
  150c3c:	d808      	bhi.n	150c50 <rpmsg_lite_send+0x20>
    {
        return RL_ERR_BUFF_SIZE;
    }

    return rpmsg_lite_format_message(rpmsg_lite_dev, ept->addr, dst, data, size, RL_NO_FLAGS, timeout);
  150c3e:	9e09      	ldr	r6, [sp, #36]	; 0x24
  150c40:	2500      	movs	r5, #0
  150c42:	6809      	ldr	r1, [r1, #0]
  150c44:	e88d 0070 	stmia.w	r13, {r4, r5, r6}
  150c48:	f7ff ff84 	bl	150b54 <rpmsg_lite_format_message>
}
  150c4c:	b004      	add	sp, #16
  150c4e:	bd70      	pop	{r4, r5, r6, r15}
        return RL_ERR_BUFF_SIZE;
  150c50:	f64e 4076 	movw	r0, #60534	; 0xec76
  150c54:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  150c58:	e7f8      	b.n	150c4c <rpmsg_lite_send+0x1c>
        return RL_ERR_PARAM;
  150c5a:	f64e 4075 	movw	r0, #60533	; 0xec75
  150c5e:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  150c62:	e7f3      	b.n	150c4c <rpmsg_lite_send+0x1c>

00150c64 <rpmsg_lite_release_rx_buffer>:

    if (!rpmsg_lite_dev)
    {
        return RL_ERR_PARAM;
    }
    if (!rxbuf)
  150c64:	fab1 f381 	clz	r3, r1
{
  150c68:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if (!rxbuf)
  150c6c:	095b      	lsrs	r3, r3, #5
  150c6e:	2800      	cmp	r0, #0
  150c70:	bf14      	ite	ne
  150c72:	461c      	movne	r4, r3
  150c74:	2401      	moveq	r4, #1
  150c76:	b9d4      	cbnz	r4, 150cae <rpmsg_lite_release_rx_buffer+0x4a>
  150c78:	4605      	mov	r5, r0
  150c7a:	460e      	mov	r6, r1
    rpmsg_msg = RPMSG_STD_MSG_FROM_BUF(rxbuf);

    /* Get the pointer to the reserved field that contains buffer size and the index */
    reserved = (struct rpmsg_hdr_reserved *)&rpmsg_msg->hdr.reserved;

    env_lock_mutex(rpmsg_lite_dev->lock);
  150c7c:	68c0      	ldr	r0, [r0, #12]
  150c7e:	f000 fdd7 	bl	151830 <env_lock_mutex>

    /* Return used buffer, with total length (header length + buffer size). */
    rpmsg_lite_dev->vq_ops->vq_rx_free(rpmsg_lite_dev->rvq, rpmsg_msg,
                                       (unsigned long)virtqueue_get_buffer_length(rpmsg_lite_dev->rvq, reserved->idx),
  150c82:	f836 1c06 	ldrh.w	r1, [r6, #-6]
    rpmsg_lite_dev->vq_ops->vq_rx_free(rpmsg_lite_dev->rvq, rpmsg_msg,
  150c86:	6a2b      	ldr	r3, [r5, #32]
  150c88:	682f      	ldr	r7, [r5, #0]
                                       (unsigned long)virtqueue_get_buffer_length(rpmsg_lite_dev->rvq, reserved->idx),
  150c8a:	4638      	mov	r0, r7
    rpmsg_lite_dev->vq_ops->vq_rx_free(rpmsg_lite_dev->rvq, rpmsg_msg,
  150c8c:	f8d3 800c 	ldr.w	r8, [r3, #12]
                                       (unsigned long)virtqueue_get_buffer_length(rpmsg_lite_dev->rvq, reserved->idx),
  150c90:	f000 fc4e 	bl	151530 <virtqueue_get_buffer_length>
    rpmsg_lite_dev->vq_ops->vq_rx_free(rpmsg_lite_dev->rvq, rpmsg_msg,
  150c94:	f836 3c06 	ldrh.w	r3, [r6, #-6]
  150c98:	f1a6 0110 	sub.w	r1, r6, #16
  150c9c:	4602      	mov	r2, r0
  150c9e:	4638      	mov	r0, r7
  150ca0:	47c0      	blx	r8
                                       reserved->idx);

    env_unlock_mutex(rpmsg_lite_dev->lock);
  150ca2:	68e8      	ldr	r0, [r5, #12]
  150ca4:	f000 fdd0 	bl	151848 <env_unlock_mutex>

    return RL_SUCCESS;
  150ca8:	4620      	mov	r0, r4
}
  150caa:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return RL_ERR_PARAM;
  150cae:	f64e 4075 	movw	r0, #60533	; 0xec75
  150cb2:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  150cb6:	e7f8      	b.n	150caa <rpmsg_lite_release_rx_buffer+0x46>

00150cb8 <rpmsg_lite_master_init>:
struct rpmsg_lite_instance *rpmsg_lite_master_init(void *shmem_addr,
                                                   size_t shmem_length,
                                                   int link_id,
                                                   uint32_t init_flags)
#endif
{
  150cb8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    struct virtqueue *vqs[2];
    void *buffer;
    int idx, j;
    struct rpmsg_lite_instance *rpmsg_lite_dev = NULL;

    if ((2 * RL_BUFFER_COUNT) > ((RL_WORD_ALIGN_DOWN(shmem_length - RL_VRING_OVERHEAD)) / RL_BUFFER_SIZE))
  150cbc:	078d      	lsls	r5, r1, #30
{
  150cbe:	b08d      	sub	sp, #52	; 0x34
  150cc0:	f5a1 3680 	sub.w	r6, r1, #65536	; 0x10000
    if ((2 * RL_BUFFER_COUNT) > ((RL_WORD_ALIGN_DOWN(shmem_length - RL_VRING_OVERHEAD)) / RL_BUFFER_SIZE))
  150cc4:	f000 8101 	beq.w	150eca <rpmsg_lite_master_init+0x212>
  150cc8:	f026 0403 	bic.w	r4, r6, #3
  150ccc:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
  150cd0:	bf2c      	ite	cs
  150cd2:	2400      	movcs	r4, #0
  150cd4:	2401      	movcc	r4, #1
    {
        return NULL;
    }

    if (link_id > RL_PLATFORM_HIGHEST_LINK_ID)
  150cd6:	2a05      	cmp	r2, #5
  150cd8:	bfd4      	ite	le
  150cda:	2100      	movle	r1, #0
  150cdc:	2101      	movgt	r1, #1
    {
        return NULL;
    }

    if (!shmem_addr)
  150cde:	2800      	cmp	r0, #0
  150ce0:	bf08      	it	eq
  150ce2:	2101      	moveq	r1, #1
  150ce4:	ea54 0801 	orrs.w	r8, r4, r1
  150ce8:	f040 80ea 	bne.w	150ec0 <rpmsg_lite_master_init+0x208>
  150cec:	4605      	mov	r5, r0
    {
        return NULL;
    }
    rpmsg_lite_dev = static_context;
#else
    rpmsg_lite_dev = env_allocate_memory(sizeof(struct rpmsg_lite_instance));
  150cee:	202c      	movs	r0, #44	; 0x2c
  150cf0:	9304      	str	r3, [sp, #16]
  150cf2:	4617      	mov	r7, r2
  150cf4:	f8cd e014 	str.w	r14, [r13, #20]
  150cf8:	f000 fd66 	bl	1517c8 <env_allocate_memory>
    if (!rpmsg_lite_dev)
  150cfc:	4604      	mov	r4, r0
  150cfe:	2800      	cmp	r0, #0
  150d00:	f000 80de 	beq.w	150ec0 <rpmsg_lite_master_init+0x208>
    {
        return NULL;
    }
#endif

    env_memset(rpmsg_lite_dev, 0, sizeof(struct rpmsg_lite_instance));
  150d04:	222c      	movs	r2, #44	; 0x2c
  150d06:	4641      	mov	r1, r8
  150d08:	f000 fd64 	bl	1517d4 <env_memset>
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
    status = env_init(&rpmsg_lite_dev->env, env_cfg);
#else
    status = env_init();
  150d0c:	f000 fcec 	bl	1516e8 <env_init>
#endif
    if (status != RL_SUCCESS)
  150d10:	2800      	cmp	r0, #0
  150d12:	f040 8121 	bne.w	150f58 <rpmsg_lite_master_init+0x2a0>
  150d16:	f505 3c80 	add.w	r12, r5, #65536	; 0x10000

    /*
     * Since device is RPMSG Remote so we need to manage the
     * shared buffers. Create shared memory pool to handle buffers.
     */
    rpmsg_lite_dev->sh_mem_base = (char *)RL_WORD_ALIGN_UP(shmem_addr + RL_VRING_OVERHEAD);
  150d1a:	07ab      	lsls	r3, r5, #30
    /* Initialize names and callbacks*/
    vq_names[0] = "rx_vq";
    vq_names[1] = "tx_vq";
    callback[0] = rpmsg_lite_rx_callback;
    callback[1] = rpmsg_lite_tx_callback;
    rpmsg_lite_dev->vq_ops = &master_vq_ops;
  150d1c:	f248 5358 	movw	r3, #34136	; 0x8558
    rpmsg_lite_dev->sh_mem_base = (char *)RL_WORD_ALIGN_UP(shmem_addr + RL_VRING_OVERHEAD);
  150d20:	bf18      	it	ne
  150d22:	f02c 0c03 	bicne.w	r12, r12, #3
  150d26:	ea4f 2056 	mov.w	r0, r6, lsr #9
  150d2a:	bf18      	it	ne
  150d2c:	f10c 0c04 	addne.w	r12, r12, #4
    rpmsg_lite_dev->vq_ops = &master_vq_ops;
  150d30:	f2c0 0315 	movt	r3, #21

    /* Create virtqueue for each vring. */
    for (idx = 0; idx < 2; idx++)
    {
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
        ring_info.align = VRING_ALIGN;
  150d34:	f44f 5a80 	mov.w	r10, #4096	; 0x1000
#if defined(RL_USE_STATIC_API) && (RL_USE_STATIC_API == 1)
        status = virtqueue_create_static(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
                                         virtqueue_notify, &vqs[idx],
                                         (struct vq_static_context *)&rpmsg_lite_dev->vq_ctxt[idx]);
#else
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d38:	007e      	lsls	r6, r7, #1
        ring_info.num_descs = RL_BUFFER_COUNT;
  150d3a:	f44f 7980 	mov.w	r9, #256	; 0x100
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d3e:	f640 1805 	movw	r8, #2309	; 0x905
        env_memset((void *)ring_info.phy_addr, 0x00, vring_size(ring_info.num_descs, ring_info.align));
  150d42:	f642 020e 	movw	r2, #10254	; 0x280e
  150d46:	2100      	movs	r1, #0
    rpmsg_lite_dev->sh_mem_remaining = (RL_WORD_ALIGN_DOWN(shmem_length - RL_VRING_OVERHEAD)) / RL_BUFFER_SIZE;
  150d48:	61a0      	str	r0, [r4, #24]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d4a:	f2c0 0815 	movt	r8, #21
    rpmsg_lite_dev->sh_mem_total = rpmsg_lite_dev->sh_mem_remaining;
  150d4e:	61e0      	str	r0, [r4, #28]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d50:	f10d 0b1c 	add.w	r11, r13, #28
        env_memset((void *)ring_info.phy_addr, 0x00, vring_size(ring_info.num_descs, ring_info.align));
  150d54:	4628      	mov	r0, r5
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d56:	b2b6      	uxth	r6, r6
    rpmsg_lite_dev->sh_mem_base = (char *)RL_WORD_ALIGN_UP(shmem_addr + RL_VRING_OVERHEAD);
  150d58:	f8c4 c014 	str.w	r12, [r4, #20]
    rpmsg_lite_dev->vq_ops = &master_vq_ops;
  150d5c:	6223      	str	r3, [r4, #32]
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
  150d5e:	9509      	str	r5, [sp, #36]	; 0x24
        ring_info.align = VRING_ALIGN;
  150d60:	f8cd a028 	str.w	r10, [r13, #40]	; 0x28
        ring_info.num_descs = RL_BUFFER_COUNT;
  150d64:	f8ad 902c 	strh.w	r9, [r13, #44]	; 0x2c
        env_memset((void *)ring_info.phy_addr, 0x00, vring_size(ring_info.num_descs, ring_info.align));
  150d68:	f000 fd34 	bl	1517d4 <env_memset>
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150d6c:	f640 034d 	movw	r3, #2125	; 0x84d
  150d70:	f248 5178 	movw	r1, #34168	; 0x8578
  150d74:	4630      	mov	r0, r6
  150d76:	aa09      	add	r2, sp, #36	; 0x24
  150d78:	f8cd 8000 	str.w	r8, [r13]
  150d7c:	f2c0 0315 	movt	r3, #21
  150d80:	f8cd b004 	str.w	r11, [r13, #4]
  150d84:	f2c0 0115 	movt	r1, #21
  150d88:	f000 fb32 	bl	1513f0 <virtqueue_create>
                                  virtqueue_notify, &vqs[idx]);
#endif /* RL_USE_STATIC_API */

        if (status == RL_SUCCESS)
  150d8c:	9003      	str	r0, [sp, #12]
  150d8e:	2800      	cmp	r0, #0
  150d90:	f040 80e2 	bne.w	150f58 <rpmsg_lite_master_init+0x2a0>
        {
            /* Initialize vring control block in virtqueue. */
            vq_ring_init(vqs[idx]);
  150d94:	9807      	ldr	r0, [sp, #28]
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
  150d96:	f505 4500 	add.w	r5, r5, #32768	; 0x8000
            vq_ring_init(vqs[idx]);
  150d9a:	f000 fc87 	bl	1516ac <vq_ring_init>

            /* Disable callbacks - will be enabled by the application
            * once initialization is completed.
            */
            virtqueue_disable_cb(vqs[idx]);
  150d9e:	9807      	ldr	r0, [sp, #28]
  150da0:	f000 fc48 	bl	151634 <virtqueue_disable_cb>
#endif
            return NULL;
        }

        /* virtqueue has reference to the RPMsg Lite instance */
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  150da4:	9b07      	ldr	r3, [sp, #28]
        env_memset((void *)ring_info.phy_addr, 0x00, vring_size(ring_info.num_descs, ring_info.align));
  150da6:	4628      	mov	r0, r5
  150da8:	f642 020e 	movw	r2, #10254	; 0x280e
  150dac:	9903      	ldr	r1, [sp, #12]
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  150dae:	665c      	str	r4, [r3, #100]	; 0x64
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
  150db0:	9509      	str	r5, [sp, #36]	; 0x24
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150db2:	ad08      	add	r5, sp, #32
        ring_info.align = VRING_ALIGN;
  150db4:	f8cd a028 	str.w	r10, [r13, #40]	; 0x28
        ring_info.num_descs = RL_BUFFER_COUNT;
  150db8:	f8ad 902c 	strh.w	r9, [r13, #44]	; 0x2c
        env_memset((void *)ring_info.phy_addr, 0x00, vring_size(ring_info.num_descs, ring_info.align));
  150dbc:	f000 fd0a 	bl	1517d4 <env_memset>
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150dc0:	f640 1361 	movw	r3, #2401	; 0x961
  150dc4:	f248 5180 	movw	r1, #34176	; 0x8580
  150dc8:	f8cd 8000 	str.w	r8, [r13]
  150dcc:	aa09      	add	r2, sp, #36	; 0x24
  150dce:	9501      	str	r5, [sp, #4]
  150dd0:	f046 0001 	orr.w	r0, r6, #1
  150dd4:	f2c0 0315 	movt	r3, #21
  150dd8:	f2c0 0115 	movt	r1, #21
  150ddc:	f000 fb08 	bl	1513f0 <virtqueue_create>
        if (status == RL_SUCCESS)
  150de0:	2800      	cmp	r0, #0
  150de2:	f040 80b9 	bne.w	150f58 <rpmsg_lite_master_init+0x2a0>
            vq_ring_init(vqs[idx]);
  150de6:	9808      	ldr	r0, [sp, #32]
  150de8:	f000 fc60 	bl	1516ac <vq_ring_init>
            virtqueue_disable_cb(vqs[idx]);
  150dec:	9808      	ldr	r0, [sp, #32]
  150dee:	f000 fc21 	bl	151634 <virtqueue_disable_cb>
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  150df2:	9b08      	ldr	r3, [sp, #32]
  150df4:	665c      	str	r4, [r3, #100]	; 0x64
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
        vqs[idx]->env = rpmsg_lite_dev->env;
#endif
    }

    status = env_create_mutex((LOCK *)&rpmsg_lite_dev->lock, 1);
  150df6:	2101      	movs	r1, #1
  150df8:	f104 000c 	add.w	r0, r4, #12
  150dfc:	f000 fcfa 	bl	1517f4 <env_create_mutex>
    if (status != RL_SUCCESS)
  150e00:	2800      	cmp	r0, #0
  150e02:	f040 80a9 	bne.w	150f58 <rpmsg_lite_master_init+0x2a0>
#endif
        return NULL;
    }

    // FIXME - a better way to handle this , tx for master is rx for remote and vice versa.
    rpmsg_lite_dev->tvq = vqs[1];
  150e06:	9a08      	ldr	r2, [sp, #32]
  150e08:	46d8      	mov	r8, r11
    rpmsg_lite_dev->rvq = vqs[0];
  150e0a:	9b07      	ldr	r3, [sp, #28]
  150e0c:	e9c4 3200 	strd	r3, r2, [r4]

    for (j = 0; j < 2; j++)
    {
        for (idx = 0; ((idx < vqs[j]->vq_nentries) && (idx < rpmsg_lite_dev->sh_mem_total)); idx++)
  150e10:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
  150e14:	2b00      	cmp	r3, #0
  150e16:	d05e      	beq.n	150ed6 <rpmsg_lite_master_init+0x21e>
  150e18:	69e3      	ldr	r3, [r4, #28]
  150e1a:	2b00      	cmp	r3, #0
  150e1c:	d05b      	beq.n	150ed6 <rpmsg_lite_master_init+0x21e>
        {
            /* Initialize TX virtqueue buffers for remote device */
            buffer = rpmsg_lite_dev->sh_mem_remaining ?
  150e1e:	69a2      	ldr	r2, [r4, #24]
                         (rpmsg_lite_dev->sh_mem_base +
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e20:	b37a      	cbz	r2, 150e82 <rpmsg_lite_master_init+0x1ca>
                         (rpmsg_lite_dev->sh_mem_base +
  150e22:	6965      	ldr	r5, [r4, #20]
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e24:	1a9b      	subs	r3, r3, r2
  150e26:	3a01      	subs	r2, #1
                         (RL_NULL);

            RL_ASSERT(buffer);
  150e28:	eb15 2543 	adds.w	r5, r5, r3, lsl #9
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e2c:	61a2      	str	r2, [r4, #24]
            RL_ASSERT(buffer);
  150e2e:	d028      	beq.n	150e82 <rpmsg_lite_master_init+0x1ca>
        for (idx = 0; ((idx < vqs[j]->vq_nentries) && (idx < rpmsg_lite_dev->sh_mem_total)); idx++)
  150e30:	2600      	movs	r6, #0

            env_memset(buffer, 0x00, RL_BUFFER_SIZE);
  150e32:	4628      	mov	r0, r5
  150e34:	f44f 7200 	mov.w	r2, #512	; 0x200
  150e38:	2100      	movs	r1, #0
  150e3a:	f000 fccb 	bl	1517d4 <env_memset>
            if (vqs[j] == rpmsg_lite_dev->rvq)
  150e3e:	f8d8 0000 	ldr.w	r0, [r8]
  150e42:	6823      	ldr	r3, [r4, #0]
  150e44:	4298      	cmp	r0, r3
  150e46:	d02e      	beq.n	150ea6 <rpmsg_lite_master_init+0x1ee>
            {
                status = virtqueue_fill_avail_buffers(vqs[j], buffer, RL_BUFFER_SIZE);
            }
            else if (vqs[j] == rpmsg_lite_dev->tvq)
  150e48:	6863      	ldr	r3, [r4, #4]
  150e4a:	4298      	cmp	r0, r3
  150e4c:	f040 808f 	bne.w	150f6e <rpmsg_lite_master_init+0x2b6>
            {
                status = virtqueue_fill_used_buffers(vqs[j], buffer, RL_BUFFER_SIZE);
  150e50:	4629      	mov	r1, r5
  150e52:	f44f 7200 	mov.w	r2, #512	; 0x200
  150e56:	f000 fbbd 	bl	1515d4 <virtqueue_fill_used_buffers>
            else
            {
                RL_ASSERT(0); /* should not happen */
            }

            if (status != RL_SUCCESS)
  150e5a:	bb58      	cbnz	r0, 150eb4 <rpmsg_lite_master_init+0x1fc>
        for (idx = 0; ((idx < vqs[j]->vq_nentries) && (idx < rpmsg_lite_dev->sh_mem_total)); idx++)
  150e5c:	f8d8 3000 	ldr.w	r3, [r8]
  150e60:	3601      	adds	r6, #1
  150e62:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
  150e66:	42b3      	cmp	r3, r6
  150e68:	dd35      	ble.n	150ed6 <rpmsg_lite_master_init+0x21e>
  150e6a:	69e3      	ldr	r3, [r4, #28]
  150e6c:	42b3      	cmp	r3, r6
  150e6e:	d932      	bls.n	150ed6 <rpmsg_lite_master_init+0x21e>
            buffer = rpmsg_lite_dev->sh_mem_remaining ?
  150e70:	69a2      	ldr	r2, [r4, #24]
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e72:	b132      	cbz	r2, 150e82 <rpmsg_lite_master_init+0x1ca>
                         (rpmsg_lite_dev->sh_mem_base +
  150e74:	6965      	ldr	r5, [r4, #20]
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e76:	1a9b      	subs	r3, r3, r2
  150e78:	3a01      	subs	r2, #1
            RL_ASSERT(buffer);
  150e7a:	eb15 2543 	adds.w	r5, r5, r3, lsl #9
                          RL_BUFFER_SIZE * (rpmsg_lite_dev->sh_mem_total - rpmsg_lite_dev->sh_mem_remaining--)) :
  150e7e:	61a2      	str	r2, [r4, #24]
            RL_ASSERT(buffer);
  150e80:	d1d7      	bne.n	150e32 <rpmsg_lite_master_init+0x17a>
  150e82:	f645 7370 	movw	r3, #24432	; 0x5f70
  150e86:	f248 52a0 	movw	r2, #34208	; 0x85a0
  150e8a:	f644 316c 	movw	r1, #19308	; 0x4b6c
  150e8e:	f2c0 0315 	movt	r3, #21
  150e92:	9805      	ldr	r0, [sp, #20]
  150e94:	f2c0 0215 	movt	r2, #21
  150e98:	9300      	str	r3, [sp, #0]
  150e9a:	f2c0 0115 	movt	r1, #21
  150e9e:	f240 4379 	movw	r3, #1145	; 0x479
  150ea2:	f001 ff07 	bl	152cb4 <_panic>
                status = virtqueue_fill_avail_buffers(vqs[j], buffer, RL_BUFFER_SIZE);
  150ea6:	4629      	mov	r1, r5
  150ea8:	f44f 7200 	mov.w	r2, #512	; 0x200
  150eac:	f000 faec 	bl	151488 <virtqueue_fill_avail_buffers>
            if (status != RL_SUCCESS)
  150eb0:	2800      	cmp	r0, #0
  150eb2:	d0d3      	beq.n	150e5c <rpmsg_lite_master_init+0x1a4>
            {
/* Clean up! */
#if !(defined(RL_USE_STATIC_API) && (RL_USE_STATIC_API == 1))
                env_free_memory(rpmsg_lite_dev);
  150eb4:	4620      	mov	r0, r4
  150eb6:	f000 fc89 	bl	1517cc <env_free_memory>
#endif
                env_delete_mutex(rpmsg_lite_dev->lock);
  150eba:	68e0      	ldr	r0, [r4, #12]
  150ebc:	f000 fcb4 	bl	151828 <env_delete_mutex>
                return NULL;
  150ec0:	2400      	movs	r4, #0
     * communication.
     */
    virtqueue_kick(rpmsg_lite_dev->rvq);

    return rpmsg_lite_dev;
}
  150ec2:	4620      	mov	r0, r4
  150ec4:	b00d      	add	sp, #52	; 0x34
  150ec6:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if ((2 * RL_BUFFER_COUNT) > ((RL_WORD_ALIGN_DOWN(shmem_length - RL_VRING_OVERHEAD)) / RL_BUFFER_SIZE))
  150eca:	f5b6 2f80 	cmp.w	r6, #262144	; 0x40000
  150ece:	bf2c      	ite	cs
  150ed0:	2400      	movcs	r4, #0
  150ed2:	2401      	movcc	r4, #1
  150ed4:	e6ff      	b.n	150cd6 <rpmsg_lite_master_init+0x1e>
    for (j = 0; j < 2; j++)
  150ed6:	ab08      	add	r3, sp, #32
  150ed8:	4543      	cmp	r3, r8
  150eda:	d145      	bne.n	150f68 <rpmsg_lite_master_init+0x2b0>
    platform_init_interrupt(rpmsg_lite_dev->rvq->vq_queue_index, rpmsg_lite_dev->rvq);
  150edc:	6821      	ldr	r1, [r4, #0]
  150ede:	f8b1 0050 	ldrh.w	r0, [r1, #80]	; 0x50
  150ee2:	f000 fd09 	bl	1518f8 <platform_init_interrupt>
    platform_init_interrupt(rpmsg_lite_dev->tvq->vq_queue_index, rpmsg_lite_dev->tvq);
  150ee6:	6861      	ldr	r1, [r4, #4]
  150ee8:	f8b1 0050 	ldrh.w	r0, [r1, #80]	; 0x50
    rpmsg_lite_dev->link_state = 1;
  150eec:	2501      	movs	r5, #1
    platform_init_interrupt(rpmsg_lite_dev->tvq->vq_queue_index, rpmsg_lite_dev->tvq);
  150eee:	f000 fd03 	bl	1518f8 <platform_init_interrupt>
    env_disable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  150ef2:	6823      	ldr	r3, [r4, #0]
  150ef4:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  150ef8:	f000 fcb6 	bl	151868 <env_disable_interrupt>
    env_disable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  150efc:	6863      	ldr	r3, [r4, #4]
  150efe:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  150f02:	f000 fcb1 	bl	151868 <env_disable_interrupt>
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  150f06:	6823      	ldr	r3, [r4, #0]
    rpmsg_lite_dev->link_state = 1;
  150f08:	6125      	str	r5, [r4, #16]
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  150f0a:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  150f0e:	f000 fca9 	bl	151864 <env_enable_interrupt>
    env_enable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  150f12:	6863      	ldr	r3, [r4, #4]
  150f14:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  150f18:	f000 fca4 	bl	151864 <env_enable_interrupt>
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  150f1c:	f640 02e1 	movw	r2, #2273	; 0x8e1
  150f20:	f248 5188 	movw	r1, #34184	; 0x8588
  150f24:	f2c0 0215 	movt	r2, #21
  150f28:	9b04      	ldr	r3, [sp, #16]
  150f2a:	f2c0 0115 	movt	r1, #21
  150f2e:	9200      	str	r2, [sp, #0]
  150f30:	4638      	mov	r0, r7
  150f32:	2210      	movs	r2, #16
  150f34:	f7f9 fe7c 	bl	14ac30 <sd_ipcc_chan_create>
       rpmsg_lite_dev->counter = 0;
  150f38:	2200      	movs	r2, #0
       chan->priv = (void *) rpmsg_lite_dev;
  150f3a:	f8c0 4088 	str.w	r4, [r0, #136]	; 0x88
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  150f3e:	4603      	mov	r3, r0
       rpmsg_lite_dev->is_master = true;
  150f40:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
    virtqueue_kick(rpmsg_lite_dev->rvq);
  150f44:	6820      	ldr	r0, [r4, #0]
       rpmsg_lite_dev->notifier = chan;
  150f46:	6263      	str	r3, [r4, #36]	; 0x24
       rpmsg_lite_dev->counter = 0;
  150f48:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
    virtqueue_kick(rpmsg_lite_dev->rvq);
  150f4c:	f000 fb88 	bl	151660 <virtqueue_kick>
}
  150f50:	4620      	mov	r0, r4
  150f52:	b00d      	add	sp, #52	; 0x34
  150f54:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            env_free_memory(rpmsg_lite_dev);
  150f58:	4620      	mov	r0, r4
            return NULL;
  150f5a:	2400      	movs	r4, #0
            env_free_memory(rpmsg_lite_dev);
  150f5c:	f000 fc36 	bl	1517cc <env_free_memory>
}
  150f60:	4620      	mov	r0, r4
  150f62:	b00d      	add	sp, #52	; 0x34
  150f64:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  150f68:	f858 3f04 	ldr.w	r3, [r8, #4]!
  150f6c:	e750      	b.n	150e10 <rpmsg_lite_master_init+0x158>
                RL_ASSERT(0); /* should not happen */
  150f6e:	f645 7370 	movw	r3, #24432	; 0x5f70
  150f72:	f248 52a0 	movw	r2, #34208	; 0x85a0
  150f76:	f644 316c 	movw	r1, #19308	; 0x4b6c
  150f7a:	f2c0 0315 	movt	r3, #21
  150f7e:	9805      	ldr	r0, [sp, #20]
  150f80:	f2c0 0215 	movt	r2, #21
  150f84:	9300      	str	r3, [sp, #0]
  150f86:	f2c0 0115 	movt	r1, #21
  150f8a:	f240 4386 	movw	r3, #1158	; 0x486
  150f8e:	f001 fe91 	bl	152cb4 <_panic>
  150f92:	bf00      	nop

00150f94 <rpmsg_lite_remote_init>:
    struct vring_alloc_info ring_info;
    struct virtqueue *vqs[2];
    int idx;
    struct rpmsg_lite_instance *rpmsg_lite_dev = NULL;

    if (link_id > RL_PLATFORM_HIGHEST_LINK_ID)
  150f94:	2905      	cmp	r1, #5
{
  150f96:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    if (link_id > RL_PLATFORM_HIGHEST_LINK_ID)
  150f9a:	bfd4      	ite	le
  150f9c:	2600      	movle	r6, #0
  150f9e:	2601      	movgt	r6, #1
{
  150fa0:	b089      	sub	sp, #36	; 0x24
    {
        return NULL;
    }

    if (!shmem_addr)
  150fa2:	2800      	cmp	r0, #0
  150fa4:	bf08      	it	eq
  150fa6:	2601      	moveq	r6, #1
  150fa8:	2e00      	cmp	r6, #0
  150faa:	f040 80a2 	bne.w	1510f2 <rpmsg_lite_remote_init+0x15e>
  150fae:	4605      	mov	r5, r0
    {
        return NULL;
    }
    rpmsg_lite_dev = static_context;
#else
    rpmsg_lite_dev = env_allocate_memory(sizeof(struct rpmsg_lite_instance));
  150fb0:	202c      	movs	r0, #44	; 0x2c
  150fb2:	4691      	mov	r9, r2
  150fb4:	460f      	mov	r7, r1
  150fb6:	f000 fc07 	bl	1517c8 <env_allocate_memory>
    if (!rpmsg_lite_dev)
  150fba:	4604      	mov	r4, r0
  150fbc:	2800      	cmp	r0, #0
  150fbe:	f000 8098 	beq.w	1510f2 <rpmsg_lite_remote_init+0x15e>
    {
        return NULL;
    }
#endif

    env_memset(rpmsg_lite_dev, 0, sizeof(struct rpmsg_lite_instance));
  150fc2:	222c      	movs	r2, #44	; 0x2c
  150fc4:	4631      	mov	r1, r6
  150fc6:	f000 fc05 	bl	1517d4 <env_memset>
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
    status = env_init(&rpmsg_lite_dev->env, env_cfg);
#else
    status = env_init();
  150fca:	f000 fb8d 	bl	1516e8 <env_init>
#endif

    if (status != RL_SUCCESS)
  150fce:	2800      	cmp	r0, #0
  150fd0:	f040 8094 	bne.w	1510fc <rpmsg_lite_remote_init+0x168>

    vq_names[0] = "tx_vq"; /* swapped in case of remote */
    vq_names[1] = "rx_vq";
    callback[0] = rpmsg_lite_tx_callback;
    callback[1] = rpmsg_lite_rx_callback;
    rpmsg_lite_dev->vq_ops = &remote_vq_ops;
  150fd4:	f248 5368 	movw	r3, #34152	; 0x8568
  150fd8:	f505 3080 	add.w	r0, r5, #65536	; 0x10000
  150fdc:	f2c0 0315 	movt	r3, #21
#if defined(RL_USE_STATIC_API) && (RL_USE_STATIC_API == 1)
        status = virtqueue_create_static(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
                                         virtqueue_notify, &vqs[idx],
                                         (struct vq_static_context *)&rpmsg_lite_dev->vq_ctxt[idx]);
#else
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150fe0:	f640 1805 	movw	r8, #2309	; 0x905
  150fe4:	007e      	lsls	r6, r7, #1
    rpmsg_lite_dev->vq_ops = &remote_vq_ops;
  150fe6:	6223      	str	r3, [r4, #32]
    rpmsg_lite_dev->sh_mem_base = (char *)RL_WORD_ALIGN_UP(shmem_addr + RL_VRING_OVERHEAD);
  150fe8:	07ab      	lsls	r3, r5, #30
  150fea:	bf1c      	itt	ne
  150fec:	f020 0003 	bicne.w	r0, r0, #3
  150ff0:	3004      	addne	r0, #4
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150ff2:	aa03      	add	r2, sp, #12
  150ff4:	f2c0 0815 	movt	r8, #21
        ring_info.align = VRING_ALIGN;
  150ff8:	f44f 5b80 	mov.w	r11, #4096	; 0x1000
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  150ffc:	b2b6      	uxth	r6, r6
        ring_info.num_descs = RL_BUFFER_COUNT;
  150ffe:	f44f 7a80 	mov.w	r10, #256	; 0x100
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151002:	f640 1361 	movw	r3, #2401	; 0x961
  151006:	f248 5180 	movw	r1, #34176	; 0x8580
  15100a:	f2c0 0315 	movt	r3, #21
    rpmsg_lite_dev->sh_mem_base = (char *)RL_WORD_ALIGN_UP(shmem_addr + RL_VRING_OVERHEAD);
  15100e:	6160      	str	r0, [r4, #20]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151010:	f2c0 0115 	movt	r1, #21
  151014:	9201      	str	r2, [sp, #4]
  151016:	4630      	mov	r0, r6
  151018:	f8cd 8000 	str.w	r8, [r13]
  15101c:	aa05      	add	r2, sp, #20
        ring_info.align = VRING_ALIGN;
  15101e:	e9cd 5b05 	strd	r5, r11, [r13, #20]
        ring_info.num_descs = RL_BUFFER_COUNT;
  151022:	f8ad a01c 	strh.w	r10, [r13, #28]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151026:	f000 f9e3 	bl	1513f0 <virtqueue_create>
                                  virtqueue_notify, &vqs[idx]);
#endif /* RL_USE_STATIC_API */

        if (status != RL_SUCCESS)
  15102a:	2800      	cmp	r0, #0
  15102c:	d166      	bne.n	1510fc <rpmsg_lite_remote_init+0x168>
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
  15102e:	f505 4500 	add.w	r5, r5, #32768	; 0x8000
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151032:	f640 034d 	movw	r3, #2125	; 0x84d
  151036:	f10d 0c10 	add.w	r12, r13, #16
        ring_info.phy_addr = (void *)((unsigned long)shmem_addr + (unsigned long)((idx == 0) ? (0) : (VRING_SIZE)));
  15103a:	9505      	str	r5, [sp, #20]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  15103c:	f248 5178 	movw	r1, #34168	; 0x8578
#endif
            return NULL;
        }

        /* virtqueue has reference to the RPMsg Lite instance */
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  151040:	9d03      	ldr	r5, [sp, #12]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151042:	aa05      	add	r2, sp, #20
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  151044:	666c      	str	r4, [r5, #100]	; 0x64
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  151046:	f046 0001 	orr.w	r0, r6, #1
  15104a:	f2c0 0315 	movt	r3, #21
  15104e:	e9cd 8c00 	strd	r8, r12, [r13]
  151052:	f2c0 0115 	movt	r1, #21
        ring_info.align = VRING_ALIGN;
  151056:	f8cd b018 	str.w	r11, [r13, #24]
        ring_info.num_descs = RL_BUFFER_COUNT;
  15105a:	f8ad a01c 	strh.w	r10, [r13, #28]
        status = virtqueue_create(RL_GET_VQ_ID(link_id, idx), (char *)vq_names[idx], &ring_info, callback[idx],
  15105e:	f000 f9c7 	bl	1513f0 <virtqueue_create>
        if (status != RL_SUCCESS)
  151062:	2800      	cmp	r0, #0
  151064:	d14a      	bne.n	1510fc <rpmsg_lite_remote_init+0x168>
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  151066:	9b04      	ldr	r3, [sp, #16]
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
        vqs[idx]->env = rpmsg_lite_dev->env;
#endif
    }

    status = env_create_mutex((LOCK *)&rpmsg_lite_dev->lock, 1);
  151068:	2101      	movs	r1, #1
        vqs[idx]->priv = (void *)rpmsg_lite_dev;
  15106a:	665c      	str	r4, [r3, #100]	; 0x64
    status = env_create_mutex((LOCK *)&rpmsg_lite_dev->lock, 1);
  15106c:	f104 000c 	add.w	r0, r4, #12
  151070:	f000 fbc0 	bl	1517f4 <env_create_mutex>
    if (status != RL_SUCCESS)
  151074:	4605      	mov	r5, r0
  151076:	2800      	cmp	r0, #0
  151078:	d140      	bne.n	1510fc <rpmsg_lite_remote_init+0x168>
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  15107a:	f640 06e1 	movw	r6, #2273	; 0x8e1
  15107e:	f248 5194 	movw	r1, #34196	; 0x8594
#endif
        return NULL;
    }

    // FIXME - a better way to handle this , tx for master is rx for remote and vice versa.
    rpmsg_lite_dev->tvq = vqs[0];
  151082:	9a03      	ldr	r2, [sp, #12]
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  151084:	f2c0 0615 	movt	r6, #21
    rpmsg_lite_dev->tvq = vqs[0];
  151088:	6062      	str	r2, [r4, #4]
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  15108a:	464b      	mov	r3, r9
    rpmsg_lite_dev->rvq = vqs[1];
  15108c:	9a04      	ldr	r2, [sp, #16]
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  15108e:	4638      	mov	r0, r7
    rpmsg_lite_dev->rvq = vqs[1];
  151090:	6022      	str	r2, [r4, #0]
    return sd_ipcc_chan_create(remote, name, IPCC_ADDR_RPMSG, flags, usr_cb);
  151092:	f2c0 0115 	movt	r1, #21
  151096:	9600      	str	r6, [sp, #0]
  151098:	2210      	movs	r2, #16
  15109a:	f7f9 fdc9 	bl	14ac30 <sd_ipcc_chan_create>
    env_disable_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->tvq->vq_queue_index);
    rpmsg_lite_dev->link_state = 0;
    env_enable_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->rvq->vq_queue_index);
    env_enable_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->tvq->vq_queue_index);
#else
    platform_init_interrupt(rpmsg_lite_dev->rvq->vq_queue_index, rpmsg_lite_dev->rvq);
  15109e:	6821      	ldr	r1, [r4, #0]
        chan->priv = (void *) rpmsg_lite_dev;
  1510a0:	f8c0 4088 	str.w	r4, [r0, #136]	; 0x88
        rpmsg_lite_dev->notifier = (void *) chan;
  1510a4:	6260      	str	r0, [r4, #36]	; 0x24
        rpmsg_lite_dev->counter = 0;
  1510a6:	f884 5029 	strb.w	r5, [r4, #41]	; 0x29
    platform_init_interrupt(rpmsg_lite_dev->rvq->vq_queue_index, rpmsg_lite_dev->rvq);
  1510aa:	f8b1 0050 	ldrh.w	r0, [r1, #80]	; 0x50
        rpmsg_lite_dev->is_master = false;
  1510ae:	f884 5028 	strb.w	r5, [r4, #40]	; 0x28
    platform_init_interrupt(rpmsg_lite_dev->rvq->vq_queue_index, rpmsg_lite_dev->rvq);
  1510b2:	f000 fc21 	bl	1518f8 <platform_init_interrupt>
    platform_init_interrupt(rpmsg_lite_dev->tvq->vq_queue_index, rpmsg_lite_dev->tvq);
  1510b6:	6861      	ldr	r1, [r4, #4]
  1510b8:	f8b1 0050 	ldrh.w	r0, [r1, #80]	; 0x50
  1510bc:	f000 fc1c 	bl	1518f8 <platform_init_interrupt>
    env_disable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  1510c0:	6823      	ldr	r3, [r4, #0]
  1510c2:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  1510c6:	f000 fbcf 	bl	151868 <env_disable_interrupt>
    env_disable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  1510ca:	6863      	ldr	r3, [r4, #4]
  1510cc:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  1510d0:	f000 fbca 	bl	151868 <env_disable_interrupt>
    rpmsg_lite_dev->link_state = 0;
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  1510d4:	6823      	ldr	r3, [r4, #0]
    rpmsg_lite_dev->link_state = 0;
  1510d6:	6125      	str	r5, [r4, #16]
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  1510d8:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  1510dc:	f000 fbc2 	bl	151864 <env_enable_interrupt>
    env_enable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  1510e0:	6863      	ldr	r3, [r4, #4]
  1510e2:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  1510e6:	f000 fbbd 	bl	151864 <env_enable_interrupt>
#endif

    return rpmsg_lite_dev;
}
  1510ea:	4620      	mov	r0, r4
  1510ec:	b009      	add	sp, #36	; 0x24
  1510ee:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        return NULL;
  1510f2:	2400      	movs	r4, #0
}
  1510f4:	4620      	mov	r0, r4
  1510f6:	b009      	add	sp, #36	; 0x24
  1510f8:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
            env_free_memory(rpmsg_lite_dev);
  1510fc:	4620      	mov	r0, r4
            return NULL;
  1510fe:	2400      	movs	r4, #0
            env_free_memory(rpmsg_lite_dev);
  151100:	f000 fb64 	bl	1517cc <env_free_memory>
}
  151104:	4620      	mov	r0, r4
  151106:	b009      	add	sp, #36	; 0x24
  151108:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}

0015110c <rpmsg_lite_deinit>:

********************************************/

int rpmsg_lite_deinit(struct rpmsg_lite_instance *rpmsg_lite_dev)
{
    if (rpmsg_lite_dev == NULL)
  15110c:	2800      	cmp	r0, #0
  15110e:	d04f      	beq.n	1511b0 <rpmsg_lite_deinit+0xa4>
    {
        return RL_ERR_PARAM;
    }

    if (!((rpmsg_lite_dev->rvq != NULL) && (rpmsg_lite_dev->tvq != NULL) && (rpmsg_lite_dev->lock != NULL)))
  151110:	6803      	ldr	r3, [r0, #0]
{
  151112:	b530      	push	{r4, r5, r14}
  151114:	4604      	mov	r4, r0
  151116:	b083      	sub	sp, #12
    if (!((rpmsg_lite_dev->rvq != NULL) && (rpmsg_lite_dev->tvq != NULL) && (rpmsg_lite_dev->lock != NULL)))
  151118:	2b00      	cmp	r3, #0
  15111a:	d037      	beq.n	15118c <rpmsg_lite_deinit+0x80>
  15111c:	6842      	ldr	r2, [r0, #4]
  15111e:	2a00      	cmp	r2, #0
  151120:	d034      	beq.n	15118c <rpmsg_lite_deinit+0x80>
  151122:	68c2      	ldr	r2, [r0, #12]
  151124:	b392      	cbz	r2, 15118c <rpmsg_lite_deinit+0x80>
    env_enable_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->tvq->vq_queue_index);

    env_deinit_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->rvq->vq_queue_index);
    env_deinit_interrupt(rpmsg_lite_dev->env, rpmsg_lite_dev->tvq->vq_queue_index);
#else
    env_disable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  151126:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
    env_disable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
    rpmsg_lite_dev->link_state = 0;
  15112a:	2500      	movs	r5, #0
    env_disable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  15112c:	f000 fb9c 	bl	151868 <env_disable_interrupt>
    env_disable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  151130:	6863      	ldr	r3, [r4, #4]
  151132:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  151136:	f000 fb97 	bl	151868 <env_disable_interrupt>
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  15113a:	6823      	ldr	r3, [r4, #0]
    rpmsg_lite_dev->link_state = 0;
  15113c:	6125      	str	r5, [r4, #16]
    env_enable_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  15113e:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  151142:	f000 fb8f 	bl	151864 <env_enable_interrupt>
    env_enable_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  151146:	6863      	ldr	r3, [r4, #4]
  151148:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  15114c:	f000 fb8a 	bl	151864 <env_enable_interrupt>

    platform_deinit_interrupt(rpmsg_lite_dev->rvq->vq_queue_index);
  151150:	6823      	ldr	r3, [r4, #0]
  151152:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  151156:	f000 fbd1 	bl	1518fc <platform_deinit_interrupt>
    platform_deinit_interrupt(rpmsg_lite_dev->tvq->vq_queue_index);
  15115a:	6863      	ldr	r3, [r4, #4]
  15115c:	f8b3 0050 	ldrh.w	r0, [r3, #80]	; 0x50
  151160:	f000 fbcc 	bl	1518fc <platform_deinit_interrupt>
#endif
#if defined(RL_USE_IPCC_NOTIFY) && (RL_USE_IPCC_NOTIFY == 1)
    /* Create one sd_ipcc_chan for interrupt notify */
    sd_ipcc_chan_free(rpmsg_lite_dev->notifier);
  151164:	6a60      	ldr	r0, [r4, #36]	; 0x24
  151166:	f7f9 fd71 	bl	14ac4c <sd_ipcc_chan_free>

#if defined(RL_USE_STATIC_API) && (RL_USE_STATIC_API == 1)
    virtqueue_free_static(rpmsg_lite_dev->rvq);
    virtqueue_free_static(rpmsg_lite_dev->tvq);
#else
    virtqueue_free(rpmsg_lite_dev->rvq);
  15116a:	6820      	ldr	r0, [r4, #0]
  15116c:	f000 f9e6 	bl	15153c <virtqueue_free>
    virtqueue_free(rpmsg_lite_dev->tvq);
  151170:	6860      	ldr	r0, [r4, #4]
  151172:	f000 f9e3 	bl	15153c <virtqueue_free>
#endif /* RL_USE_STATIC_API */

    env_delete_mutex(rpmsg_lite_dev->lock);
  151176:	68e0      	ldr	r0, [r4, #12]
  151178:	f000 fb56 	bl	151828 <env_delete_mutex>
#if defined(RL_USE_ENVIRONMENT_CONTEXT) && (RL_USE_ENVIRONMENT_CONTEXT == 1)
    env_deinit(rpmsg_lite_dev->env);
#else
    env_deinit();
  15117c:	f000 faf6 	bl	15176c <env_deinit>
#endif

#if !(defined(RL_USE_STATIC_API) && (RL_USE_STATIC_API == 1))
    env_free_memory(rpmsg_lite_dev);
  151180:	4620      	mov	r0, r4
  151182:	f000 fb23 	bl	1517cc <env_free_memory>
#endif /* RL_USE_STATIC_API */

    return RL_SUCCESS;
  151186:	4628      	mov	r0, r5
}
  151188:	b003      	add	sp, #12
  15118a:	bd30      	pop	{r4, r5, r15}
        RL_ASSERT((rpmsg_lite_dev->rvq != NULL) && (rpmsg_lite_dev->tvq != NULL) && (rpmsg_lite_dev->lock != NULL));
  15118c:	f645 7370 	movw	r3, #24432	; 0x5f70
  151190:	f248 52a0 	movw	r2, #34208	; 0x85a0
  151194:	f644 316c 	movw	r1, #19308	; 0x4b6c
  151198:	f2c0 0315 	movt	r3, #21
  15119c:	4670      	mov	r0, r14
  15119e:	f2c0 0215 	movt	r2, #21
  1511a2:	9300      	str	r3, [sp, #0]
  1511a4:	f2c0 0115 	movt	r1, #21
  1511a8:	f240 5373 	movw	r3, #1395	; 0x573
  1511ac:	f001 fd82 	bl	152cb4 <_panic>
        return RL_ERR_PARAM;
  1511b0:	f64e 4075 	movw	r0, #60533	; 0xec75
  1511b4:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  1511b8:	4770      	bx	r14
  1511ba:	bf00      	nop

001511bc <rpmsg_ns_rx_cb>:
 *
 * @return  RL_RELEASE, message is always freed
 *
 */
static int rpmsg_ns_rx_cb(void *payload, int payload_len, unsigned long src, void *priv)
{
  1511bc:	b510      	push	{r4, r14}
  1511be:	b082      	sub	sp, #8
    struct rpmsg_ns_msg *ns_msg_ptr = payload;
    struct rpmsg_ns_callback_data *cb_ctxt = priv;
    RL_ASSERT(priv);
  1511c0:	b15b      	cbz	r3, 1511da <rpmsg_ns_rx_cb+0x1e>
    RL_ASSERT(cb_ctxt->cb);
  1511c2:	681c      	ldr	r4, [r3, #0]
  1511c4:	b1d4      	cbz	r4, 1511fc <rpmsg_ns_rx_cb+0x40>

    /* Drop likely bad messages received at nameservice address */
    if (payload_len == sizeof(struct rpmsg_ns_msg))
  1511c6:	2928      	cmp	r1, #40	; 0x28
  1511c8:	d104      	bne.n	1511d4 <rpmsg_ns_rx_cb+0x18>
    {
        cb_ctxt->cb(ns_msg_ptr->addr, ns_msg_ptr->name, ns_msg_ptr->flags, cb_ctxt->user_data);
  1511ca:	6a42      	ldr	r2, [r0, #36]	; 0x24
  1511cc:	4601      	mov	r1, r0
  1511ce:	685b      	ldr	r3, [r3, #4]
  1511d0:	6a00      	ldr	r0, [r0, #32]
  1511d2:	47a0      	blx	r4
    }

    return RL_RELEASE;
}
  1511d4:	2000      	movs	r0, #0
  1511d6:	b002      	add	sp, #8
  1511d8:	bd10      	pop	{r4, r15}
    RL_ASSERT(priv);
  1511da:	f645 7370 	movw	r3, #24432	; 0x5f70
  1511de:	f248 52cc 	movw	r2, #34252	; 0x85cc
  1511e2:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1511e6:	f2c0 0315 	movt	r3, #21
  1511ea:	4670      	mov	r0, r14
  1511ec:	f2c0 0215 	movt	r2, #21
  1511f0:	9300      	str	r3, [sp, #0]
  1511f2:	f2c0 0115 	movt	r1, #21
  1511f6:	2356      	movs	r3, #86	; 0x56
  1511f8:	f001 fd5c 	bl	152cb4 <_panic>
    RL_ASSERT(cb_ctxt->cb);
  1511fc:	f645 7370 	movw	r3, #24432	; 0x5f70
  151200:	f248 52cc 	movw	r2, #34252	; 0x85cc
  151204:	f644 316c 	movw	r1, #19308	; 0x4b6c
  151208:	f2c0 0315 	movt	r3, #21
  15120c:	4670      	mov	r0, r14
  15120e:	f2c0 0215 	movt	r2, #21
  151212:	9300      	str	r3, [sp, #0]
  151214:	f2c0 0115 	movt	r1, #21
  151218:	2357      	movs	r3, #87	; 0x57
  15121a:	f001 fd4b 	bl	152cb4 <_panic>
  15121e:	bf00      	nop

00151220 <rpmsg_ns_bind>:
                              void *user_data,
                              rpmsg_ns_static_context *ns_ept_ctxt)
#else
rpmsg_ns_handle rpmsg_ns_bind(struct rpmsg_lite_instance *rpmsg_lite_dev, rpmsg_ns_new_ept_cb app_cb, void *user_data)
#endif /* RL_USE_STATIC_API */
{
  151220:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    struct rpmsg_ns_context *ns_ctxt;

    if (app_cb == NULL)
  151224:	b1e1      	cbz	r1, 151260 <rpmsg_ns_bind+0x40>
  151226:	4680      	mov	r8, r0
                                         &ns_ept_ctxt->ept_ctxt);
#else
    {
        struct rpmsg_ns_callback_data *cb_ctxt;

        cb_ctxt = env_allocate_memory(sizeof(struct rpmsg_ns_callback_data));
  151228:	2008      	movs	r0, #8
  15122a:	460d      	mov	r5, r1
  15122c:	4617      	mov	r7, r2
  15122e:	f000 facb 	bl	1517c8 <env_allocate_memory>
        if (cb_ctxt == NULL)
  151232:	4604      	mov	r4, r0
  151234:	b1a0      	cbz	r0, 151260 <rpmsg_ns_bind+0x40>
        {
            return NULL;
        }
        ns_ctxt = env_allocate_memory(sizeof(struct rpmsg_ns_context));
  151236:	2008      	movs	r0, #8
  151238:	f000 fac6 	bl	1517c8 <env_allocate_memory>
        if (ns_ctxt == NULL)
  15123c:	4606      	mov	r6, r0
  15123e:	b198      	cbz	r0, 151268 <rpmsg_ns_bind+0x48>
        cb_ctxt->user_data = user_data;
        cb_ctxt->cb = app_cb;

        ns_ctxt->cb_ctxt = cb_ctxt;

        ns_ctxt->ept = rpmsg_lite_create_ept(rpmsg_lite_dev, RL_NS_EPT_ADDR, rpmsg_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  151240:	f241 12bd 	movw	r2, #4541	; 0x11bd
  151244:	4640      	mov	r0, r8
        cb_ctxt->user_data = user_data;
  151246:	6067      	str	r7, [r4, #4]
        ns_ctxt->ept = rpmsg_lite_create_ept(rpmsg_lite_dev, RL_NS_EPT_ADDR, rpmsg_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  151248:	f2c0 0215 	movt	r2, #21
        cb_ctxt->cb = app_cb;
  15124c:	6025      	str	r5, [r4, #0]
        ns_ctxt->ept = rpmsg_lite_create_ept(rpmsg_lite_dev, RL_NS_EPT_ADDR, rpmsg_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  15124e:	4623      	mov	r3, r4
        ns_ctxt->cb_ctxt = cb_ctxt;
  151250:	6074      	str	r4, [r6, #4]
        ns_ctxt->ept = rpmsg_lite_create_ept(rpmsg_lite_dev, RL_NS_EPT_ADDR, rpmsg_ns_rx_cb, (void *)ns_ctxt->cb_ctxt);
  151252:	2135      	movs	r1, #53	; 0x35
  151254:	f7ff fc14 	bl	150a80 <rpmsg_lite_create_ept>
  151258:	6030      	str	r0, [r6, #0]
    }
#endif /* RL_USE_STATIC_API */

    return (rpmsg_ns_handle)ns_ctxt;
}
  15125a:	4630      	mov	r0, r6
  15125c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return NULL;
  151260:	2600      	movs	r6, #0
}
  151262:	4630      	mov	r0, r6
  151264:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            env_free_memory(cb_ctxt);
  151268:	4620      	mov	r0, r4
  15126a:	f000 faaf 	bl	1517cc <env_free_memory>
            return NULL;
  15126e:	e7f4      	b.n	15125a <rpmsg_ns_bind+0x3a>

00151270 <rpmsg_ns_announce>:

int rpmsg_ns_announce(struct rpmsg_lite_instance *rpmsg_lite_dev,
                      struct rpmsg_lite_endpoint *new_ept,
                      char *ept_name,
                      unsigned long flags)
{
  151270:	b5f0      	push	{r4, r5, r6, r7, r14}
    if (ept_name == NULL)
    {
        return RL_ERR_PARAM;
    }

    if (new_ept == NULL)
  151272:	fab1 f481 	clz	r4, r1
{
  151276:	b08f      	sub	sp, #60	; 0x3c
    if (new_ept == NULL)
  151278:	0964      	lsrs	r4, r4, #5
  15127a:	2a00      	cmp	r2, #0
  15127c:	bf08      	it	eq
  15127e:	2401      	moveq	r4, #1
  151280:	b9d4      	cbnz	r4, 1512b8 <rpmsg_ns_announce+0x48>
  151282:	460e      	mov	r6, r1
  151284:	4605      	mov	r5, r0
    {
        return RL_ERR_PARAM;
    }

    env_strncpy(ns_msg.name, ept_name, RL_NS_NAME_SIZE);
  151286:	4611      	mov	r1, r2
  151288:	a804      	add	r0, sp, #16
  15128a:	2220      	movs	r2, #32
  15128c:	461f      	mov	r7, r3
  15128e:	f000 faa5 	bl	1517dc <env_strncpy>
    ns_msg.flags = flags;
    ns_msg.addr = new_ept->addr;

    return rpmsg_lite_format_message(rpmsg_lite_dev, new_ept->addr, RL_NS_EPT_ADDR, (char *)&ns_msg,
  151292:	f04f 3eff 	mov.w	r14, #4294967295	; 0xffffffff
  151296:	f04f 0c28 	mov.w	r12, #40	; 0x28
  15129a:	ab04      	add	r3, sp, #16
    ns_msg.addr = new_ept->addr;
  15129c:	6836      	ldr	r6, [r6, #0]
    return rpmsg_lite_format_message(rpmsg_lite_dev, new_ept->addr, RL_NS_EPT_ADDR, (char *)&ns_msg,
  15129e:	4628      	mov	r0, r5
  1512a0:	4631      	mov	r1, r6
  1512a2:	2235      	movs	r2, #53	; 0x35
  1512a4:	e9cd 4e01 	strd	r4, r14, [r13, #4]
  1512a8:	f8cd c000 	str.w	r12, [r13]
    ns_msg.flags = flags;
  1512ac:	e9cd 670c 	strd	r6, r7, [r13, #48]	; 0x30
    return rpmsg_lite_format_message(rpmsg_lite_dev, new_ept->addr, RL_NS_EPT_ADDR, (char *)&ns_msg,
  1512b0:	f7ff fc50 	bl	150b54 <rpmsg_lite_format_message>
                                     sizeof(struct rpmsg_ns_msg), RL_NO_FLAGS, RL_BLOCK);
}
  1512b4:	b00f      	add	sp, #60	; 0x3c
  1512b6:	bdf0      	pop	{r4, r5, r6, r7, r15}
        return RL_ERR_PARAM;
  1512b8:	f64e 4075 	movw	r0, #60533	; 0xec75
  1512bc:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  1512c0:	e7f8      	b.n	1512b4 <rpmsg_ns_announce+0x44>
  1512c2:	bf00      	nop

001512c4 <rpmsg_queue_rx_cb>:
    short int len;
    int padding;    /* for pow2 (16 bytes) aligned */
} rpmsg_queue_rx_cb_data_t;

int rpmsg_queue_rx_cb(void *payload, int payload_len, unsigned long src, void *priv)
{
  1512c4:	b570      	push	{r4, r5, r6, r14}
  1512c6:	b086      	sub	sp, #24
    rpmsg_queue_rx_cb_data_t msg;

    RL_ASSERT(priv);
  1512c8:	b18b      	cbz	r3, 1512ee <rpmsg_queue_rx_cb+0x2a>
  1512ca:	460c      	mov	r4, r1
  1512cc:	4616      	mov	r6, r2
  1512ce:	4605      	mov	r5, r0

    msg.data = payload;
    msg.len = payload_len;
    msg.src = src;
  1512d0:	a906      	add	r1, sp, #24

    /* if message is successfully added into queue then hold rpmsg buffer */
    if (env_put_queue(priv, &msg, 0))
  1512d2:	4618      	mov	r0, r3
  1512d4:	2200      	movs	r2, #0
    msg.src = src;
  1512d6:	f841 6d10 	str.w	r6, [r1, #-16]!
    msg.data = payload;
  1512da:	9503      	str	r5, [sp, #12]
    msg.len = payload_len;
  1512dc:	f8ad 4010 	strh.w	r4, [r13, #16]
    if (env_put_queue(priv, &msg, 0))
  1512e0:	f000 faf4 	bl	1518cc <env_put_queue>
        /* hold the rx buffer */
        return RL_HOLD;
    }

    return RL_RELEASE;
}
  1512e4:	3000      	adds	r0, #0
  1512e6:	bf18      	it	ne
  1512e8:	2001      	movne	r0, #1
  1512ea:	b006      	add	sp, #24
  1512ec:	bd70      	pop	{r4, r5, r6, r15}
    RL_ASSERT(priv);
  1512ee:	f645 7370 	movw	r3, #24432	; 0x5f70
  1512f2:	f248 52f4 	movw	r2, #34292	; 0x85f4
  1512f6:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1512fa:	f2c0 0315 	movt	r3, #21
  1512fe:	4670      	mov	r0, r14
  151300:	f2c0 0215 	movt	r2, #21
  151304:	9300      	str	r3, [sp, #0]
  151306:	f2c0 0115 	movt	r1, #21
  15130a:	232f      	movs	r3, #47	; 0x2f
  15130c:	f001 fcd2 	bl	152cb4 <_panic>

00151310 <rpmsg_queue_create>:

rpmsg_queue_handle rpmsg_queue_create(struct rpmsg_lite_instance *rpmsg_lite_dev)
{
  151310:	b500      	push	{r14}
    int status;
    void *q = NULL;
  151312:	2300      	movs	r3, #0
{
  151314:	b083      	sub	sp, #12
    void *q = NULL;
  151316:	9301      	str	r3, [sp, #4]

    if (rpmsg_lite_dev == RL_NULL)
  151318:	b158      	cbz	r0, 151332 <rpmsg_queue_create+0x22>
    {
        return RL_NULL;
    }

    /* create message queue for channel default endpoint */
    status = env_create_queue(&q, rpmsg_lite_dev->rvq->vq_nentries, sizeof(rpmsg_queue_rx_cb_data_t));
  15131a:	6803      	ldr	r3, [r0, #0]
  15131c:	2210      	movs	r2, #16
  15131e:	f8b3 1052 	ldrh.w	r1, [r3, #82]	; 0x52
  151322:	a801      	add	r0, sp, #4
  151324:	f000 faa2 	bl	15186c <env_create_queue>
    if ((status) || (q == NULL))
  151328:	b918      	cbnz	r0, 151332 <rpmsg_queue_create+0x22>
  15132a:	9801      	ldr	r0, [sp, #4]
    {
        return RL_NULL;
    }

    return ((rpmsg_queue_handle)q);
}
  15132c:	b003      	add	sp, #12
  15132e:	f85d fb04 	ldr.w	r15, [r13], #4
        return RL_NULL;
  151332:	2000      	movs	r0, #0
}
  151334:	b003      	add	sp, #12
  151336:	f85d fb04 	ldr.w	r15, [r13], #4
  15133a:	bf00      	nop

0015133c <rpmsg_queue_recv>:
                     unsigned long *src,
                     char *data,
                     int maxlen,
                     int *len,
                     unsigned long timeout)
{
  15133c:	b5f0      	push	{r4, r5, r6, r7, r14}
    rpmsg_queue_rx_cb_data_t msg = {0};
  15133e:	2500      	movs	r5, #0

    if (!rpmsg_lite_dev)
    {
        return RL_ERR_PARAM;
    }
    if (!q)
  151340:	fab1 f481 	clz	r4, r1
{
  151344:	b085      	sub	sp, #20
    if (!q)
  151346:	0964      	lsrs	r4, r4, #5
    rpmsg_queue_rx_cb_data_t msg = {0};
  151348:	e9cd 5500 	strd	r5, r5, [r13]
    {
        return RL_ERR_PARAM;
    }
    if (!data)
  15134c:	42ab      	cmp	r3, r5
  15134e:	bf08      	it	eq
  151350:	2401      	moveq	r4, #1
    rpmsg_queue_rx_cb_data_t msg = {0};
  151352:	e9cd 5502 	strd	r5, r5, [r13, #8]
    if (!data)
  151356:	42a8      	cmp	r0, r5
  151358:	bf08      	it	eq
  15135a:	2401      	moveq	r4, #1
{
  15135c:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    if (!data)
  15135e:	bb24      	cbnz	r4, 1513aa <rpmsg_queue_recv+0x6e>
  151360:	4605      	mov	r5, r0
  151362:	4614      	mov	r4, r2
  151364:	4608      	mov	r0, r1
    {
       return RL_ERR_PARAM;
    }

    /* Get an element out of the message queue for the selected endpoint */
    if (env_get_queue((void *)q, &msg, timeout))
  151366:	4669      	mov	r1, r13
  151368:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  15136a:	461f      	mov	r7, r3
  15136c:	f000 fab8 	bl	1518e0 <env_get_queue>
  151370:	b300      	cbz	r0, 1513b4 <rpmsg_queue_recv+0x78>
    {
        if (src != NULL)
  151372:	b10c      	cbz	r4, 151378 <rpmsg_queue_recv+0x3c>
        {
            *src = msg.src;
  151374:	9b00      	ldr	r3, [sp, #0]
  151376:	6023      	str	r3, [r4, #0]
  151378:	f9bd 2008 	ldrsh.w	r2, [r13, #8]
        }
        if (len != NULL)
  15137c:	b106      	cbz	r6, 151380 <rpmsg_queue_recv+0x44>
        {
            *len = msg.len;
  15137e:	6032      	str	r2, [r6, #0]
        }

        if (maxlen >= msg.len)
  151380:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  151382:	9901      	ldr	r1, [sp, #4]
  151384:	4293      	cmp	r3, r2
        {
            env_memcpy(data, msg.data, msg.len);
        }
        else
        {
            retval = RL_ERR_BUFF_SIZE;
  151386:	bfbc      	itt	lt
  151388:	f64e 4476 	movwlt	r4, #60534	; 0xec76
  15138c:	f6cf 74ff 	movtlt	r4, #65535	; 0xffff
        if (maxlen >= msg.len)
  151390:	da05      	bge.n	15139e <rpmsg_queue_recv+0x62>
        }

        /* Return used buffers. */
        rpmsg_lite_release_rx_buffer(rpmsg_lite_dev, msg.data);
  151392:	4628      	mov	r0, r5
  151394:	f7ff fc66 	bl	150c64 <rpmsg_lite_release_rx_buffer>
    }
    else
    {
        return RL_ERR_NO_BUFF; /* failed */
    }
}
  151398:	4620      	mov	r0, r4
  15139a:	b005      	add	sp, #20
  15139c:	bdf0      	pop	{r4, r5, r6, r7, r15}
            env_memcpy(data, msg.data, msg.len);
  15139e:	4638      	mov	r0, r7
    int retval = RL_SUCCESS;
  1513a0:	2400      	movs	r4, #0
            env_memcpy(data, msg.data, msg.len);
  1513a2:	f000 fa19 	bl	1517d8 <env_memcpy>
  1513a6:	9901      	ldr	r1, [sp, #4]
  1513a8:	e7f3      	b.n	151392 <rpmsg_queue_recv+0x56>
       return RL_ERR_PARAM;
  1513aa:	f64e 4475 	movw	r4, #60533	; 0xec75
  1513ae:	f6cf 74ff 	movt	r4, #65535	; 0xffff
  1513b2:	e7f1      	b.n	151398 <rpmsg_queue_recv+0x5c>
        return RL_ERR_NO_BUFF; /* failed */
  1513b4:	f64e 4472 	movw	r4, #60530	; 0xec72
  1513b8:	f6cf 74ff 	movt	r4, #65535	; 0xffff
  1513bc:	e7ec      	b.n	151398 <rpmsg_queue_recv+0x5c>
  1513be:	bf00      	nop

001513c0 <vq_ring_update_avail>:
     * it usable to the host. The chain is made available now rather than
     * deferring to virtqueue_notify() in the hopes that if the host is
     * currently running on another CPU, we can keep it processing the new
     * descriptor.
     */
    avail_idx = (uint16_t)(vq->vq_ring.avail->idx & ((uint16_t)(vq->vq_nentries - 1U)));
  1513c0:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
  1513c4:	6c82      	ldr	r2, [r0, #72]	; 0x48
  1513c6:	3b01      	subs	r3, #1
{
  1513c8:	b510      	push	{r4, r14}
  1513ca:	4604      	mov	r4, r0
    avail_idx = (uint16_t)(vq->vq_ring.avail->idx & ((uint16_t)(vq->vq_nentries - 1U)));
  1513cc:	8850      	ldrh	r0, [r2, #2]
    vq->vq_ring.avail->ring[avail_idx] = desc_idx;
  1513ce:	4003      	ands	r3, r0
  1513d0:	eb02 0343 	add.w	r3, r2, r3, lsl #1
  1513d4:	8099      	strh	r1, [r3, #4]

    env_wmb();
  1513d6:	f000 fa07 	bl	1517e8 <env_wmb>

    vq->vq_ring.avail->idx++;

    /* Keep pending count until virtqueue_notify(). */
    vq->vq_queued_cnt++;
  1513da:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
    vq->vq_ring.avail->idx++;
  1513de:	6ca1      	ldr	r1, [r4, #72]	; 0x48
    vq->vq_queued_cnt++;
  1513e0:	3301      	adds	r3, #1
    vq->vq_ring.avail->idx++;
  1513e2:	884a      	ldrh	r2, [r1, #2]
  1513e4:	3201      	adds	r2, #1
  1513e6:	804a      	strh	r2, [r1, #2]
    vq->vq_queued_cnt++;
  1513e8:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
}
  1513ec:	bd10      	pop	{r4, r15}
  1513ee:	bf00      	nop

001513f0 <virtqueue_create>:
{
  1513f0:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  1513f4:	4606      	mov	r6, r0
        vq = (struct virtqueue *)env_allocate_memory(vq_size);
  1513f6:	2068      	movs	r0, #104	; 0x68
{
  1513f8:	4688      	mov	r8, r1
  1513fa:	4617      	mov	r7, r2
  1513fc:	461d      	mov	r5, r3
        vq = (struct virtqueue *)env_allocate_memory(vq_size);
  1513fe:	f000 f9e3 	bl	1517c8 <env_allocate_memory>
        if (vq == VQ_NULL)
  151402:	b3a8      	cbz	r0, 151470 <virtqueue_create+0x80>
  151404:	4604      	mov	r4, r0
        env_memset(vq, 0x00, vq_size);
  151406:	2268      	movs	r2, #104	; 0x68
  151408:	2100      	movs	r1, #0
  15140a:	f000 f9e3 	bl	1517d4 <env_memset>
        env_strncpy(vq->vq_name, name, VIRTQUEUE_MAX_NAME_SZ);
  15140e:	4641      	mov	r1, r8
  151410:	2220      	movs	r2, #32
  151412:	4620      	mov	r0, r4
  151414:	f000 f9e2 	bl	1517dc <env_strncpy>
        vq->vq_alignment = ring->align;
  151418:	f8d7 c004 	ldr.w	r12, [r7, #4]
        vq->vq_nentries = ring->num_descs;
  15141c:	8939      	ldrh	r1, [r7, #8]
        vq->vq_ring_mem = (void *)ring->phy_addr;
  15141e:	683f      	ldr	r7, [r7, #0]
static inline int vring_size(unsigned int num, unsigned long align)
{
    int size;

    size = num * sizeof(struct vring_desc);
    size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) + sizeof(uint16_t);
  151420:	1d0b      	adds	r3, r1, #4
  151422:	f10c 30ff 	add.w	r0, r12, #4294967295	; 0xffffffff
    size = num * sizeof(struct vring_desc);
  151426:	ea4f 1e01 	mov.w	r14, r1, lsl #4
    size = (size + align - 1) & ~(align - 1);
  15142a:	eb0e 0200 	add.w	r2, r14, r0
    size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) + sizeof(uint16_t);
  15142e:	005b      	lsls	r3, r3, #1
#include <stdio.h>
static inline void vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
    vr->num = num;
    vr->desc = (struct vring_desc *)p;
    vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
  151430:	44be      	add	r14, r7
        vq->vq_nentries = ring->num_descs;
  151432:	f8a4 1052 	strh.w	r1, [r4, #82]	; 0x52
    size = (size + align - 1) & ~(align - 1);
  151436:	441a      	add	r2, r3
    vr->desc = (struct vring_desc *)p;
  151438:	e9c4 1710 	strd	r1, r7, [r4, #64]	; 0x40
    vr->used = (struct vring_used *)(((unsigned long)&vr->avail->ring[num] + align - 1) & ~(align - 1));
  15143c:	3b04      	subs	r3, #4
        vq->vq_queue_index = id;
  15143e:	f8a4 6050 	strh.w	r6, [r4, #80]	; 0x50
  151442:	4473      	add	r3, r14
        vq->vq_alignment = ring->align;
  151444:	f8c4 c024 	str.w	r12, [r4, #36]	; 0x24
  151448:	4403      	add	r3, r0
        vq->vq_ring_mem = (void *)ring->phy_addr;
  15144a:	62e7      	str	r7, [r4, #44]	; 0x2c
    size = (size + align - 1) & ~(align - 1);
  15144c:	f1cc 0000 	rsb	r0, r12, #0
  151450:	4002      	ands	r2, r0
    vr->used = (struct vring_used *)(((unsigned long)&vr->avail->ring[num] + align - 1) & ~(align - 1));
  151452:	4003      	ands	r3, r0
    return (status);
  151454:	2000      	movs	r0, #0
    size += sizeof(struct vring_used) + (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
  151456:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
    vr->used = (struct vring_used *)(((unsigned long)&vr->avail->ring[num] + align - 1) & ~(align - 1));
  15145a:	e9c4 e312 	strd	r14, r3, [r4, #72]	; 0x48
    size += sizeof(struct vring_used) + (num * sizeof(struct vring_used_elem)) + sizeof(uint16_t);
  15145e:	320e      	adds	r2, #14
        vq->notify = notify;
  151460:	9906      	ldr	r1, [sp, #24]
        *v_queue = vq;
  151462:	9b07      	ldr	r3, [sp, #28]
        vq->callback = callback;
  151464:	6325      	str	r5, [r4, #48]	; 0x30
        vq->notify = notify;
  151466:	6361      	str	r1, [r4, #52]	; 0x34
        vq->vq_ring_size = vring_size(ring->num_descs, ring->align);
  151468:	62a2      	str	r2, [r4, #40]	; 0x28
        *v_queue = vq;
  15146a:	601c      	str	r4, [r3, #0]
}
  15146c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            return (ERROR_NO_MEM);
  151470:	f24f 4044 	movw	r0, #62532	; 0xf444
  151474:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  151478:	e7f8      	b.n	15146c <virtqueue_create+0x7c>
  15147a:	bf00      	nop

0015147c <virtqueue_add_buffer>:
{
  15147c:	b508      	push	{r3, r14}
        vq_ring_update_avail(vq, head_idx);
  15147e:	f7ff ff9f 	bl	1513c0 <vq_ring_update_avail>
}
  151482:	2000      	movs	r0, #0
  151484:	bd08      	pop	{r3, r15}
  151486:	bf00      	nop

00151488 <virtqueue_fill_avail_buffers>:
{
  151488:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
  15148c:	4604      	mov	r4, r0
        dp->addr = env_map_vatopa(buffer);
  15148e:	4608      	mov	r0, r1
        head_idx = vq->vq_desc_head_idx;
  151490:	f8b4 5058 	ldrh.w	r5, [r4, #88]	; 0x58
{
  151494:	4691      	mov	r9, r2
        dp->addr = env_map_vatopa(buffer);
  151496:	2600      	movs	r6, #0
        dp = &vq->vq_ring.desc[head_idx];
  151498:	012f      	lsls	r7, r5, #4
  15149a:	f8d4 8044 	ldr.w	r8, [r4, #68]	; 0x44
        dp->addr = env_map_vatopa(buffer);
  15149e:	f000 f9a5 	bl	1517ec <env_map_vatopa>
        vq->vq_desc_head_idx++;
  1514a2:	f8b4 3058 	ldrh.w	r3, [r4, #88]	; 0x58
        dp->flags = VRING_DESC_F_WRITE;
  1514a6:	f04f 0c02 	mov.w	r12, #2
        vq_ring_update_avail(vq, head_idx);
  1514aa:	4629      	mov	r1, r5
        vq->vq_desc_head_idx++;
  1514ac:	3301      	adds	r3, #1
        dp = &vq->vq_ring.desc[head_idx];
  1514ae:	eb08 0507 	add.w	r5, r8, r7
        dp->addr = env_map_vatopa(buffer);
  1514b2:	f848 0007 	str.w	r0, [r8, r7]
        vq_ring_update_avail(vq, head_idx);
  1514b6:	4620      	mov	r0, r4
        dp->len = len;
  1514b8:	f8c5 9008 	str.w	r9, [r5, #8]
        dp->flags = VRING_DESC_F_WRITE;
  1514bc:	f8a5 c00c 	strh.w	r12, [r5, #12]
        dp->addr = env_map_vatopa(buffer);
  1514c0:	606e      	str	r6, [r5, #4]
        vq->vq_desc_head_idx++;
  1514c2:	f8a4 3058 	strh.w	r3, [r4, #88]	; 0x58
        vq_ring_update_avail(vq, head_idx);
  1514c6:	f7ff ff7b 	bl	1513c0 <vq_ring_update_avail>
}
  1514ca:	4630      	mov	r0, r6
  1514cc:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}

001514d0 <virtqueue_get_buffer>:
    if ((vq == VQ_NULL) || (vq->vq_used_cons_idx == vq->vq_ring.used->idx))
  1514d0:	b358      	cbz	r0, 15152a <virtqueue_get_buffer+0x5a>
{
  1514d2:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    if ((vq == VQ_NULL) || (vq->vq_used_cons_idx == vq->vq_ring.used->idx))
  1514d6:	f8b0 305a 	ldrh.w	r3, [r0, #90]	; 0x5a
  1514da:	6cc4      	ldr	r4, [r0, #76]	; 0x4c
  1514dc:	8865      	ldrh	r5, [r4, #2]
  1514de:	429d      	cmp	r5, r3
  1514e0:	d020      	beq.n	151524 <virtqueue_get_buffer+0x54>
    used_idx = (uint16_t)(vq->vq_used_cons_idx & ((uint16_t)(vq->vq_nentries - 1U)));
  1514e2:	f8b0 6052 	ldrh.w	r6, [r0, #82]	; 0x52
  1514e6:	4688      	mov	r8, r1
  1514e8:	4605      	mov	r5, r0
  1514ea:	3e01      	subs	r6, #1
  1514ec:	4617      	mov	r7, r2
  1514ee:	401e      	ands	r6, r3
    env_rmb();
  1514f0:	f000 f978 	bl	1517e4 <env_rmb>
  1514f4:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
    desc_idx = (uint16_t)uep->id;
  1514f8:	6863      	ldr	r3, [r4, #4]
    if (len != VQ_NULL)
  1514fa:	f1b8 0f00 	cmp.w	r8, #0
  1514fe:	d002      	beq.n	151506 <virtqueue_get_buffer+0x36>
        *len = uep->len;
  151500:	68a2      	ldr	r2, [r4, #8]
  151502:	f8c8 2000 	str.w	r2, [r8]
    if (idx != VQ_NULL)
  151506:	b107      	cbz	r7, 15150a <virtqueue_get_buffer+0x3a>
    desc_idx = (uint16_t)uep->id;
  151508:	803b      	strh	r3, [r7, #0]
    return env_map_patova(vq->vq_ring.desc[desc_idx].addr);
  15150a:	6c69      	ldr	r1, [r5, #68]	; 0x44
  15150c:	b29b      	uxth	r3, r3
    vq->vq_used_cons_idx++;
  15150e:	f8b5 205a 	ldrh.w	r2, [r5, #90]	; 0x5a
  151512:	3201      	adds	r2, #1
    return env_map_patova(vq->vq_ring.desc[desc_idx].addr);
  151514:	011b      	lsls	r3, r3, #4
    vq->vq_used_cons_idx++;
  151516:	f8a5 205a 	strh.w	r2, [r5, #90]	; 0x5a
}
  15151a:	e8bd 41f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r14}
    return env_map_patova(vq->vq_ring.desc[desc_idx].addr);
  15151e:	58c8      	ldr	r0, [r1, r3]
  151520:	f000 b966 	b.w	1517f0 <env_map_patova>
}
  151524:	2000      	movs	r0, #0
  151526:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
  15152a:	2000      	movs	r0, #0
  15152c:	4770      	bx	r14
  15152e:	bf00      	nop

00151530 <virtqueue_get_buffer_length>:
    return vq->vq_ring.desc[idx].len;
  151530:	6c43      	ldr	r3, [r0, #68]	; 0x44
  151532:	eb03 1101 	add.w	r1, r3, r1, lsl #4
}
  151536:	6888      	ldr	r0, [r1, #8]
  151538:	4770      	bx	r14
  15153a:	bf00      	nop

0015153c <virtqueue_free>:
    if (vq != VQ_NULL)
  15153c:	b130      	cbz	r0, 15154c <virtqueue_free+0x10>
        if (vq->vq_ring_mem != VQ_NULL)
  15153e:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  151540:	b113      	cbz	r3, 151548 <virtqueue_free+0xc>
            vq->vq_ring_size = 0;
  151542:	2300      	movs	r3, #0
            vq->vq_ring_mem = VQ_NULL;
  151544:	e9c0 330a 	strd	r3, r3, [r0, #40]	; 0x28
        env_free_memory(vq);
  151548:	f000 b940 	b.w	1517cc <env_free_memory>
}
  15154c:	4770      	bx	r14
  15154e:	bf00      	nop

00151550 <virtqueue_get_available_buffer>:
{
  151550:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    if (vq->vq_available_idx == vq->vq_ring.avail->idx)
  151552:	f8b0 305c 	ldrh.w	r3, [r0, #92]	; 0x5c
  151556:	6c85      	ldr	r5, [r0, #72]	; 0x48
  151558:	886c      	ldrh	r4, [r5, #2]
  15155a:	429c      	cmp	r4, r3
  15155c:	d01c      	beq.n	151598 <virtqueue_get_available_buffer+0x48>
  15155e:	4617      	mov	r7, r2
    head_idx = (uint16_t)(vq->vq_available_idx++ & ((uint16_t)(vq->vq_nentries - 1U)));
  151560:	f8b0 2052 	ldrh.w	r2, [r0, #82]	; 0x52
  151564:	460e      	mov	r6, r1
  151566:	3a01      	subs	r2, #1
  151568:	4604      	mov	r4, r0
  15156a:	1c59      	adds	r1, r3, #1
    *avail_idx = vq->vq_ring.avail->ring[head_idx];
  15156c:	4013      	ands	r3, r2
    head_idx = (uint16_t)(vq->vq_available_idx++ & ((uint16_t)(vq->vq_nentries - 1U)));
  15156e:	f8a0 105c 	strh.w	r1, [r0, #92]	; 0x5c
    *avail_idx = vq->vq_ring.avail->ring[head_idx];
  151572:	eb05 0343 	add.w	r3, r5, r3, lsl #1
  151576:	889b      	ldrh	r3, [r3, #4]
  151578:	8033      	strh	r3, [r6, #0]
    env_rmb();
  15157a:	f000 f933 	bl	1517e4 <env_rmb>
    buffer = env_map_patova(vq->vq_ring.desc[*avail_idx].addr);
  15157e:	6c62      	ldr	r2, [r4, #68]	; 0x44
  151580:	8833      	ldrh	r3, [r6, #0]
  151582:	011b      	lsls	r3, r3, #4
  151584:	58d0      	ldr	r0, [r2, r3]
  151586:	f000 f933 	bl	1517f0 <env_map_patova>
    *len = vq->vq_ring.desc[*avail_idx].len;
  15158a:	6c63      	ldr	r3, [r4, #68]	; 0x44
  15158c:	8832      	ldrh	r2, [r6, #0]
  15158e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
  151592:	689b      	ldr	r3, [r3, #8]
  151594:	603b      	str	r3, [r7, #0]
}
  151596:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return (VQ_NULL);
  151598:	2000      	movs	r0, #0
}
  15159a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

0015159c <virtqueue_add_consumed_buffer>:
{
  15159c:	b538      	push	{r3, r4, r5, r14}
    if (head_idx > vq->vq_nentries)
  15159e:	f8b0 3052 	ldrh.w	r3, [r0, #82]	; 0x52
  1515a2:	428b      	cmp	r3, r1
  1515a4:	d310      	bcc.n	1515c8 <virtqueue_add_consumed_buffer+0x2c>
  1515a6:	4604      	mov	r4, r0
    * it usable to the host. The chain is made available now rather than
    * deferring to virtqueue_notify() in the hopes that if the host is
    * currently running on another CPU, we can keep it processing the new
    * descriptor.
    */
    used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
  1515a8:	3b01      	subs	r3, #1
  1515aa:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
  1515ac:	8845      	ldrh	r5, [r0, #2]
  1515ae:	402b      	ands	r3, r5
  1515b0:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
    used_desc = &(vq->vq_ring.used->ring[used_idx]);
    used_desc->id = head_idx;
    used_desc->len = len;
  1515b4:	e9c3 1201 	strd	r1, r2, [r3, #4]

    env_wmb();
  1515b8:	f000 f916 	bl	1517e8 <env_wmb>

    vq->vq_ring.used->idx++;
  1515bc:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
  1515be:	8853      	ldrh	r3, [r2, #2]
    return (VQUEUE_SUCCESS);
  1515c0:	2000      	movs	r0, #0
    vq->vq_ring.used->idx++;
  1515c2:	3301      	adds	r3, #1
  1515c4:	8053      	strh	r3, [r2, #2]
}
  1515c6:	bd38      	pop	{r3, r4, r5, r15}
        return (ERROR_VRING_NO_BUFF);
  1515c8:	f24f 4041 	movw	r0, #62529	; 0xf441
  1515cc:	f6cf 70ff 	movt	r0, #65535	; 0xffff
}
  1515d0:	bd38      	pop	{r3, r4, r5, r15}
  1515d2:	bf00      	nop

001515d4 <virtqueue_fill_used_buffers>:
{
  1515d4:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    head_idx = vq->vq_desc_head_idx;
  1515d8:	f8b0 5058 	ldrh.w	r5, [r0, #88]	; 0x58
{
  1515dc:	4604      	mov	r4, r0
  1515de:	4616      	mov	r6, r2
  1515e0:	462f      	mov	r7, r5
    if (buffer == VQ_NULL)
  1515e2:	b189      	cbz	r1, 151608 <virtqueue_fill_used_buffers+0x34>
    dp->addr = env_map_vatopa(buffer);
  1515e4:	4608      	mov	r0, r1
    dp = &desc[head_idx];
  1515e6:	ea4f 1805 	mov.w	r8, r5, lsl #4
  1515ea:	f8d4 9044 	ldr.w	r9, [r4, #68]	; 0x44
    dp->addr = env_map_vatopa(buffer);
  1515ee:	f000 f8fd 	bl	1517ec <env_map_vatopa>
  1515f2:	2100      	movs	r1, #0
    return (head_idx + 1);
  1515f4:	3501      	adds	r5, #1
    dp->flags = VRING_DESC_F_WRITE;
  1515f6:	2202      	movs	r2, #2
    dp = &desc[head_idx];
  1515f8:	eb09 0308 	add.w	r3, r9, r8
    return (head_idx + 1);
  1515fc:	b2ad      	uxth	r5, r5
    dp->addr = env_map_vatopa(buffer);
  1515fe:	f849 0008 	str.w	r0, [r9, r8]
  151602:	e9c3 1601 	strd	r1, r6, [r3, #4]
    dp->flags = VRING_DESC_F_WRITE;
  151606:	819a      	strh	r2, [r3, #12]
    used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
  151608:	f8b4 1052 	ldrh.w	r1, [r4, #82]	; 0x52
  15160c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  15160e:	885a      	ldrh	r2, [r3, #2]
    vq->vq_desc_head_idx = idx;
  151610:	f8a4 5058 	strh.w	r5, [r4, #88]	; 0x58
    used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
  151614:	3901      	subs	r1, #1
  151616:	4011      	ands	r1, r2
  151618:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    used_desc->len = len;
  15161c:	e9c3 7601 	strd	r7, r6, [r3, #4]
    env_wmb();
  151620:	f000 f8e2 	bl	1517e8 <env_wmb>
    vq->vq_ring.used->idx++;
  151624:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
  151626:	8853      	ldrh	r3, [r2, #2]
}
  151628:	2000      	movs	r0, #0
    vq->vq_ring.used->idx++;
  15162a:	3301      	adds	r3, #1
  15162c:	8053      	strh	r3, [r2, #2]
}
  15162e:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
  151632:	bf00      	nop

00151634 <virtqueue_disable_cb>:
    if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX)
  151634:	6a02      	ldr	r2, [r0, #32]
  151636:	6c83      	ldr	r3, [r0, #72]	; 0x48
  151638:	0792      	lsls	r2, r2, #30
        vring_used_event(&vq->vq_ring) = vq->vq_used_cons_idx - vq->vq_nentries - 1;
  15163a:	bf47      	ittee	mi
  15163c:	f8b0 205a 	ldrhmi.w	r2, [r0, #90]	; 0x5a
  151640:	f102 32ff 	addmi.w	r2, r2, #4294967295	; 0xffffffff
        vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
  151644:	881a      	ldrhpl	r2, [r3, #0]
  151646:	f042 0201 	orrpl.w	r2, r2, #1
        vring_used_event(&vq->vq_ring) = vq->vq_used_cons_idx - vq->vq_nentries - 1;
  15164a:	bf45      	ittet	mi
  15164c:	6c01      	ldrmi	r1, [r0, #64]	; 0x40
  15164e:	f8b0 0052 	ldrhmi.w	r0, [r0, #82]	; 0x52
        vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
  151652:	801a      	strhpl	r2, [r3, #0]
        vring_used_event(&vq->vq_ring) = vq->vq_used_cons_idx - vq->vq_nentries - 1;
  151654:	1a12      	submi	r2, r2, r0
  151656:	bf44      	itt	mi
  151658:	eb03 0341 	addmi.w	r3, r3, r1, lsl #1
  15165c:	809a      	strhmi	r2, [r3, #4]
}
  15165e:	4770      	bx	r14

00151660 <virtqueue_kick>:
{
  151660:	b510      	push	{r4, r14}
  151662:	4604      	mov	r4, r0
    env_mb();
  151664:	f000 f8bc 	bl	1517e0 <env_mb>
static int vq_ring_must_notify_host(struct virtqueue *vq)
{
    uint16_t new_idx, prev_idx;
    uint16_t *event_idx;

    if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX)
  151668:	6a23      	ldr	r3, [r4, #32]
  15166a:	079b      	lsls	r3, r3, #30
  15166c:	d518      	bpl.n	1516a0 <virtqueue_kick+0x40>
    {
        new_idx = vq->vq_ring.avail->idx;
        prev_idx = new_idx - vq->vq_queued_cnt;
        event_idx = vring_avail_event(&vq->vq_ring);
  15166e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 * just incremented index from old to new_idx, should we trigger an
 * event?
 */
static inline int vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
    return (uint16_t)(new_idx - event_idx - 1) < (uint16_t)(new_idx - old);
  151670:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
        new_idx = vq->vq_ring.avail->idx;
  151674:	e9d4 0212 	ldrd	r0, r2, [r4, #72]	; 0x48

        return (vring_need_event(*event_idx, new_idx, prev_idx) != 0);
  151678:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
  15167c:	8842      	ldrh	r2, [r0, #2]
  15167e:	3a01      	subs	r2, #1
  151680:	8889      	ldrh	r1, [r1, #4]
  151682:	1a52      	subs	r2, r2, r1
  151684:	b292      	uxth	r2, r2
  151686:	4293      	cmp	r3, r2
  151688:	bf94      	ite	ls
  15168a:	2300      	movls	r3, #0
  15168c:	2301      	movhi	r3, #1
    if (vq_ring_must_notify_host(vq))
  15168e:	b11b      	cbz	r3, 151698 <virtqueue_kick+0x38>
 * vq_ring_notify_host
 *
 */
static void vq_ring_notify_host(struct virtqueue *vq)
{
    if (vq->notify != VQ_NULL)
  151690:	6b63      	ldr	r3, [r4, #52]	; 0x34
  151692:	b10b      	cbz	r3, 151698 <virtqueue_kick+0x38>
        vq->notify(vq);
  151694:	4620      	mov	r0, r4
  151696:	4798      	blx	r3
    vq->vq_queued_cnt = 0;
  151698:	2300      	movs	r3, #0
  15169a:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
}
  15169e:	bd10      	pop	{r4, r15}
    return ((vq->vq_ring.used->flags & VRING_USED_F_NO_NOTIFY) == 0);
  1516a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  1516a2:	881b      	ldrh	r3, [r3, #0]
  1516a4:	43db      	mvns	r3, r3
  1516a6:	f003 0301 	and.w	r3, r3, #1
  1516aa:	e7f0      	b.n	15168e <virtqueue_kick+0x2e>

001516ac <vq_ring_init>:
{
  1516ac:	b410      	push	{r4}
    size = vq->vq_nentries;
  1516ae:	f8b0 4052 	ldrh.w	r4, [r0, #82]	; 0x52
  1516b2:	6c40      	ldr	r0, [r0, #68]	; 0x44
    for (i = 0; i < size - 1; i++)
  1516b4:	2c01      	cmp	r4, #1
  1516b6:	d90b      	bls.n	1516d0 <vq_ring_init+0x24>
  1516b8:	4603      	mov	r3, r0
  1516ba:	2201      	movs	r2, #1
  1516bc:	e000      	b.n	1516c0 <vq_ring_init+0x14>
  1516be:	460a      	mov	r2, r1
        vr->desc[i].next = i + 1;
  1516c0:	81da      	strh	r2, [r3, #14]
  1516c2:	1c51      	adds	r1, r2, #1
    for (i = 0; i < size - 1; i++)
  1516c4:	42a1      	cmp	r1, r4
  1516c6:	f103 0310 	add.w	r3, r3, #16
  1516ca:	d1f8      	bne.n	1516be <vq_ring_init+0x12>
  1516cc:	eb00 1002 	add.w	r0, r0, r2, lsl #4
}
  1516d0:	f85d 4b04 	ldr.w	r4, [r13], #4
    vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
  1516d4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  1516d8:	81c3      	strh	r3, [r0, #14]
}
  1516da:	4770      	bx	r14

001516dc <virtqueue_notification>:
    if (vq != VQ_NULL)
  1516dc:	b110      	cbz	r0, 1516e4 <virtqueue_notification+0x8>
        if (vq->callback != VQ_NULL)
  1516de:	6b03      	ldr	r3, [r0, #48]	; 0x30
  1516e0:	b103      	cbz	r3, 1516e4 <virtqueue_notification+0x8>
            vq->callback(vq);
  1516e2:	4718      	bx	r3
}
  1516e4:	4770      	bx	r14
  1516e6:	bf00      	nop

001516e8 <env_init>:
int env_init(void)
{
    int retval;

    /* verify 'env_init_counter' */
    RL_ASSERT(env_init_counter >= 0);
  1516e8:	f246 6330 	movw	r3, #26160	; 0x6630
  1516ec:	f2c0 0316 	movt	r3, #22
{
  1516f0:	b530      	push	{r4, r5, r14}
    RL_ASSERT(env_init_counter >= 0);
  1516f2:	681c      	ldr	r4, [r3, #0]
{
  1516f4:	b083      	sub	sp, #12
    RL_ASSERT(env_init_counter >= 0);
  1516f6:	2c00      	cmp	r4, #0
  1516f8:	db26      	blt.n	151748 <env_init+0x60>
    env_init_counter++;
    /* multiple call of 'env_init' - return ok */
    if (env_init_counter <= 1)
    {
        /* first call */
        sem_init(&env_sema, 0);
  1516fa:	f246 6034 	movw	r0, #26164	; 0x6634
    env_init_counter++;
  1516fe:	3401      	adds	r4, #1
    if (env_init_counter <= 1)
  151700:	2c01      	cmp	r4, #1
    env_init_counter++;
  151702:	601c      	str	r4, [r3, #0]
    if (env_init_counter <= 1)
  151704:	d00e      	beq.n	151724 <env_init+0x3c>
         * if needed and other tasks to wait for the
         * blocking to be done.
         * This is in ENV layer as this is ENV specific.*/
        sem_wait(&env_sema);
        sem_post(&env_sema, true);
        return 0;
  151706:	2500      	movs	r5, #0
        sem_wait(&env_sema);
  151708:	f2c0 0016 	movt	r0, #22
  15170c:	f7fe fd9e 	bl	15024c <sem_wait>
        sem_post(&env_sema, true);
  151710:	f246 6034 	movw	r0, #26164	; 0x6634
  151714:	2101      	movs	r1, #1
  151716:	f2c0 0016 	movt	r0, #22
  15171a:	f7fe fd63 	bl	1501e4 <sem_post>
    }
}
  15171e:	4628      	mov	r0, r5
  151720:	b003      	add	sp, #12
  151722:	bd30      	pop	{r4, r5, r15}
        sem_init(&env_sema, 0);
  151724:	2100      	movs	r1, #0
  151726:	f2c0 0016 	movt	r0, #22
  15172a:	f7fe fd23 	bl	150174 <sem_init>
        retval = platform_init_rpmsg();
  15172e:	f000 f8ef 	bl	151910 <platform_init_rpmsg>
        sem_post(&env_sema, true);
  151732:	4621      	mov	r1, r4
        retval = platform_init_rpmsg();
  151734:	4605      	mov	r5, r0
        sem_post(&env_sema, true);
  151736:	f246 6034 	movw	r0, #26164	; 0x6634
  15173a:	f2c0 0016 	movt	r0, #22
  15173e:	f7fe fd51 	bl	1501e4 <sem_post>
}
  151742:	4628      	mov	r0, r5
  151744:	b003      	add	sp, #12
  151746:	bd30      	pop	{r4, r5, r15}
    RL_ASSERT(env_init_counter >= 0);
  151748:	f645 7370 	movw	r3, #24432	; 0x5f70
  15174c:	f248 6220 	movw	r2, #34336	; 0x8620
  151750:	f644 316c 	movw	r1, #19308	; 0x4b6c
  151754:	f2c0 0315 	movt	r3, #21
  151758:	4670      	mov	r0, r14
  15175a:	f2c0 0215 	movt	r2, #21
  15175e:	9300      	str	r3, [sp, #0]
  151760:	f2c0 0115 	movt	r1, #21
  151764:	2364      	movs	r3, #100	; 0x64
  151766:	f001 faa5 	bl	152cb4 <_panic>
  15176a:	bf00      	nop

0015176c <env_deinit>:
int env_deinit(void)
{
    int retval;

    /* verify 'env_init_counter' */
    RL_ASSERT(env_init_counter > 0);
  15176c:	f246 6230 	movw	r2, #26160	; 0x6630
  151770:	f2c0 0216 	movt	r2, #22
{
  151774:	b510      	push	{r4, r14}
    RL_ASSERT(env_init_counter > 0);
  151776:	6813      	ldr	r3, [r2, #0]
{
  151778:	b082      	sub	sp, #8
    RL_ASSERT(env_init_counter > 0);
  15177a:	2b00      	cmp	r3, #0
  15177c:	dd13      	ble.n	1517a6 <env_deinit+0x3a>

        return retval;
    }
    else
    {
        return 0;
  15177e:	2400      	movs	r4, #0
    env_init_counter--;
  151780:	3b01      	subs	r3, #1
  151782:	6013      	str	r3, [r2, #0]
    if (env_init_counter <= 0)
  151784:	b113      	cbz	r3, 15178c <env_deinit+0x20>
    }
}
  151786:	4620      	mov	r0, r4
  151788:	b002      	add	sp, #8
  15178a:	bd10      	pop	{r4, r15}
        retval = platform_deinit_rpmsg();
  15178c:	f000 f8ce 	bl	15192c <platform_deinit_rpmsg>
        sem_post(&env_sema, true);
  151790:	2101      	movs	r1, #1
        retval = platform_deinit_rpmsg();
  151792:	4604      	mov	r4, r0
        sem_post(&env_sema, true);
  151794:	f246 6034 	movw	r0, #26164	; 0x6634
  151798:	f2c0 0016 	movt	r0, #22
  15179c:	f7fe fd22 	bl	1501e4 <sem_post>
}
  1517a0:	4620      	mov	r0, r4
  1517a2:	b002      	add	sp, #8
  1517a4:	bd10      	pop	{r4, r15}
    RL_ASSERT(env_init_counter > 0);
  1517a6:	f645 7370 	movw	r3, #24432	; 0x5f70
  1517aa:	f248 6220 	movw	r2, #34336	; 0x8620
  1517ae:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1517b2:	f2c0 0315 	movt	r3, #21
  1517b6:	4670      	mov	r0, r14
  1517b8:	f2c0 0215 	movt	r2, #21
  1517bc:	9300      	str	r3, [sp, #0]
  1517be:	f2c0 0115 	movt	r1, #21
  1517c2:	238e      	movs	r3, #142	; 0x8e
  1517c4:	f001 fa76 	bl	152cb4 <_panic>

001517c8 <env_allocate_memory>:
 *
 * @param size
 */
void *env_allocate_memory(unsigned int size)
{
    return (malloc(size));
  1517c8:	f001 bb62 	b.w	152e90 <malloc>

001517cc <env_free_memory>:
 *
 * @param ptr
 */
void env_free_memory(void *ptr)
{
    if (ptr != NULL)
  1517cc:	b108      	cbz	r0, 1517d2 <env_free_memory+0x6>
    {
        free(ptr);
  1517ce:	f001 bb95 	b.w	152efc <free>
    }
}
  1517d2:	4770      	bx	r14

001517d4 <env_memset>:
 * @param value
 * @param size
 */
void env_memset(void *ptr, int value, unsigned long size)
{
    memset(ptr, value, size);
  1517d4:	f003 b96c 	b.w	154ab0 <__memset_from_thumb>

001517d8 <env_memcpy>:
 * @param src
 * @param len
 */
void env_memcpy(void *dst, void const *src, unsigned long len)
{
    memcpy(dst, src, len);
  1517d8:	f003 b97a 	b.w	154ad0 <__memcpy_from_thumb>

001517dc <env_strncpy>:
 * @param src
 * @param len
 */
void env_strncpy(char *dst, const char *src, unsigned long len)
{
    strncpy(dst, src, len);
  1517dc:	f002 bd0a 	b.w	1541f4 <strncpy>

001517e0 <env_mb>:
 * env_mb - implementation
 *
 */
void env_mb(void)
{
}
  1517e0:	4770      	bx	r14
  1517e2:	bf00      	nop

001517e4 <env_rmb>:
  1517e4:	4770      	bx	r14
  1517e6:	bf00      	nop

001517e8 <env_wmb>:
  1517e8:	4770      	bx	r14
  1517ea:	bf00      	nop

001517ec <env_map_vatopa>:
 *
 * @param address
 */
unsigned long env_map_vatopa(void *address)
{
	return platform_shm_get_remote(_paddr(address));
  1517ec:	f7fa be50 	b.w	14c490 <platform_shm_get_remote>

001517f0 <env_map_patova>:
 *
 * @param address
 */
void *env_map_patova(unsigned long address)
{
    return (void *)_ioaddr(platform_shm_get_local(address));
  1517f0:	f7fa be26 	b.w	14c440 <platform_shm_get_local>

001517f4 <env_create_mutex>:
 *
 * Creates a mutex with the given initial count.
 *
 */
int env_create_mutex(void **lock, int count)
{
  1517f4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  1517f6:	4606      	mov	r6, r0
    return (malloc(size));
  1517f8:	2018      	movs	r0, #24
{
  1517fa:	460d      	mov	r5, r1
    return (malloc(size));
  1517fc:	f001 fb48 	bl	152e90 <malloc>
    semaphore_t *semaphore_ptr;

    semaphore_ptr = (semaphore_t *)env_allocate_memory(sizeof(semaphore_t));
    if(semaphore_ptr == NULL)
  151800:	fab0 f380 	clz	r3, r0
  151804:	095b      	lsrs	r3, r3, #5
    {
        return -1;
    }

    if(count > RL_ENV_MAX_MUTEX_COUNT)
  151806:	2d0a      	cmp	r5, #10
  151808:	bfd4      	ite	le
  15180a:	461c      	movle	r4, r3
  15180c:	f043 0401 	orrgt.w	r4, r3, #1
  151810:	b934      	cbnz	r4, 151820 <env_create_mutex+0x2c>
  151812:	4607      	mov	r7, r0
    {
        return -1;
    }

    sem_init(semaphore_ptr, count);
  151814:	4629      	mov	r1, r5
  151816:	f7fe fcad 	bl	150174 <sem_init>
    *lock = (void*)semaphore_ptr;
    return 0;
  15181a:	4620      	mov	r0, r4
    *lock = (void*)semaphore_ptr;
  15181c:	6037      	str	r7, [r6, #0]
}
  15181e:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return -1;
  151820:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
  151824:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  151826:	bf00      	nop

00151828 <env_delete_mutex>:
    if (ptr != NULL)
  151828:	b108      	cbz	r0, 15182e <env_delete_mutex+0x6>
        free(ptr);
  15182a:	f001 bb67 	b.w	152efc <free>
 *
 */
void env_delete_mutex(void *lock)
{
    env_free_memory(lock);
}
  15182e:	4770      	bx	r14

00151830 <env_lock_mutex>:
 *
 * Tries to acquire the lock, if lock is not available then call to
 * this function will suspend.
 */
void env_lock_mutex(void *lock)
{
  151830:	b510      	push	{r4, r14}
  151832:	4604      	mov	r4, r0
    return platform_in_isr();
  151834:	f000 f866 	bl	151904 <platform_in_isr>
    if (env_in_isr() == 0)
  151838:	b100      	cbz	r0, 15183c <env_lock_mutex+0xc>
    {
        sem_wait((semaphore_t *)lock);
    }
}
  15183a:	bd10      	pop	{r4, r15}
        sem_wait((semaphore_t *)lock);
  15183c:	4620      	mov	r0, r4
}
  15183e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        sem_wait((semaphore_t *)lock);
  151842:	f7fe bd03 	b.w	15024c <sem_wait>
  151846:	bf00      	nop

00151848 <env_unlock_mutex>:
 * env_unlock_mutex
 *
 * Releases the given lock.
 */
void env_unlock_mutex(void *lock)
{
  151848:	b510      	push	{r4, r14}
  15184a:	4604      	mov	r4, r0
    return platform_in_isr();
  15184c:	f000 f85a 	bl	151904 <platform_in_isr>
    if (env_in_isr() == 0)
  151850:	b100      	cbz	r0, 151854 <env_unlock_mutex+0xc>
    {
        sem_post((semaphore_t *)lock, true);
    }
}
  151852:	bd10      	pop	{r4, r15}
        sem_post((semaphore_t *)lock, true);
  151854:	4620      	mov	r0, r4
  151856:	2101      	movs	r1, #1
}
  151858:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
        sem_post((semaphore_t *)lock, true);
  15185c:	f7fe bcc2 	b.w	1501e4 <sem_post>

00151860 <env_sleep_msec>:
 *
 * Suspends the calling thread for given time , in msecs.
 */
void env_sleep_msec(int num_msec)
{
    thread_sleep(num_msec);
  151860:	f7fd bfe6 	b.w	14f830 <thread_sleep>

00151864 <env_enable_interrupt>:
 * @param vector_id   - interrupt vector number
 */

void env_enable_interrupt(unsigned int vector_id)
{
    platform_interrupt_enable(vector_id);
  151864:	f000 b850 	b.w	151908 <platform_interrupt_enable>

00151868 <env_disable_interrupt>:
 * @param vector_id   - interrupt vector number
 */

void env_disable_interrupt(unsigned int vector_id)
{
    platform_interrupt_disable(vector_id);
  151868:	f000 b850 	b.w	15190c <platform_interrupt_disable>

0015186c <env_create_queue>:
 * @param element_size - queue element size in bytes
 *
 * @return - status of function execution
 */
int env_create_queue(void **queue, int length, int element_size)
{
  15186c:	e92d 43f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r14}
  151870:	4607      	mov	r7, r0
  151872:	b083      	sub	sp, #12
    return (malloc(size));
  151874:	2038      	movs	r0, #56	; 0x38
  151876:	46f1      	mov	r9, r14
{
  151878:	4688      	mov	r8, r1
  15187a:	4615      	mov	r5, r2
    return (malloc(size));
  15187c:	f001 fb08 	bl	152e90 <malloc>
    lk_queue_t *lq = NULL;
    size_t size;

    lq = env_allocate_memory(sizeof(lk_queue_t));
    if (!lq) {
  151880:	4606      	mov	r6, r0
  151882:	b168      	cbz	r0, 1518a0 <env_create_queue+0x34>
        *queue = NULL;
        return -1;
    }
    lq->element_size = element_size;
  151884:	6305      	str	r5, [r0, #48]	; 0x30
    return ((val - 1) & val) == 0;
  151886:	1e6b      	subs	r3, r5, #1
    RL_ASSERT(ispow2(element_size));
  151888:	ea13 0405 	ands.w	r4, r3, r5
  15188c:	d10c      	bne.n	1518a8 <env_create_queue+0x3c>
    size = length * element_size;
#if LK_DEBUGLEVEL > 0
    printf("%s: length:%d element_size:%d\n",
            __func__, length, lq->element_size);
#endif
    cbuf_initialize(&lq->cbuf, size);
  15188e:	fb08 f105 	mul.w	r1, r8, r5
  151892:	f000 fce1 	bl	152258 <cbuf_initialize>
    *queue = lq;
  151896:	603e      	str	r6, [r7, #0]

    return 0;
  151898:	4620      	mov	r0, r4
}
  15189a:	b003      	add	sp, #12
  15189c:	e8bd 83f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r15}
        *queue = NULL;
  1518a0:	6038      	str	r0, [r7, #0]
        return -1;
  1518a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  1518a6:	e7f8      	b.n	15189a <env_create_queue+0x2e>
    RL_ASSERT(ispow2(element_size));
  1518a8:	f645 7370 	movw	r3, #24432	; 0x5f70
  1518ac:	f248 6220 	movw	r2, #34336	; 0x8620
  1518b0:	f644 316c 	movw	r1, #19308	; 0x4b6c
  1518b4:	f2c0 0315 	movt	r3, #21
  1518b8:	4648      	mov	r0, r9
  1518ba:	f2c0 0215 	movt	r2, #21
  1518be:	9300      	str	r3, [sp, #0]
  1518c0:	f2c0 0115 	movt	r1, #21
  1518c4:	f44f 73ff 	mov.w	r3, #510	; 0x1fe
  1518c8:	f001 f9f4 	bl	152cb4 <_panic>

001518cc <env_put_queue>:
 *
 * @return - status of function execution
 */

int env_put_queue(void *queue, void *msg, int timeout_ms)
{
  1518cc:	b538      	push	{r3, r4, r5, r14}
    lq->element_queued++;
#if CONFIG_RPMSG_DUMP_HEX
    printf("%s %p dump msg:\n", __func__, queue);
    hexdump(msg, lq->element_size);
#endif
    cbuf_write(&lq->cbuf, msg, lq->element_size, false);
  1518ce:	e9d0 250c 	ldrd	r2, r5, [r0, #48]	; 0x30
  1518d2:	2300      	movs	r3, #0
    lq->element_queued++;
  1518d4:	3501      	adds	r5, #1
  1518d6:	6345      	str	r5, [r0, #52]	; 0x34
    cbuf_write(&lq->cbuf, msg, lq->element_size, false);
  1518d8:	f000 fcea 	bl	1522b0 <cbuf_write>
    return 1;
}
  1518dc:	2001      	movs	r0, #1
  1518de:	bd38      	pop	{r3, r4, r5, r15}

001518e0 <env_get_queue>:
 *
 * @return - status of function execution
 */

int env_get_queue(void *queue, void *msg, int timeout_ms)
{
  1518e0:	b510      	push	{r4, r14}
    lk_queue_t *lq = queue;
    size_t bytes;

    bytes = cbuf_read_timeout(&lq->cbuf, msg, lq->element_size, timeout_ms);
  1518e2:	4613      	mov	r3, r2
{
  1518e4:	4604      	mov	r4, r0
    bytes = cbuf_read_timeout(&lq->cbuf, msg, lq->element_size, timeout_ms);
  1518e6:	6b02      	ldr	r2, [r0, #48]	; 0x30
  1518e8:	f000 fd68 	bl	1523bc <cbuf_read_timeout>
    if (bytes == 0)
  1518ec:	b118      	cbz	r0, 1518f6 <env_get_queue+0x16>

#if CONFIG_RPMSG_DUMP_HEX
    printf("%s %p dump msg:\n", __func__, queue);
    hexdump(msg, lq->element_size);
#endif
    lq->element_queued--;
  1518ee:	6b63      	ldr	r3, [r4, #52]	; 0x34
    return 1;
  1518f0:	2001      	movs	r0, #1
    lq->element_queued--;
  1518f2:	3b01      	subs	r3, #1
  1518f4:	6363      	str	r3, [r4, #52]	; 0x34
}
  1518f6:	bd10      	pop	{r4, r15}

001518f8 <platform_init_interrupt>:
static void *platform_lock;

int platform_init_interrupt(unsigned int vector_id, void *isr_data)
{
    return 0;
}
  1518f8:	2000      	movs	r0, #0
  1518fa:	4770      	bx	r14

001518fc <platform_deinit_interrupt>:

int platform_deinit_interrupt(unsigned int vector_id)
{
    return 0;
}
  1518fc:	2000      	movs	r0, #0
  1518fe:	4770      	bx	r14

00151900 <platform_notify>:

void platform_notify(unsigned int vector_id)
{
}
  151900:	4770      	bx	r14
  151902:	bf00      	nop

00151904 <platform_in_isr>:
 *
 */
int platform_in_isr(void)
{
    return 0;
}
  151904:	2000      	movs	r0, #0
  151906:	4770      	bx	r14

00151908 <platform_interrupt_enable>:
 *
 */
int platform_interrupt_enable(unsigned int vector_id)
{
    return (vector_id);
}
  151908:	4770      	bx	r14
  15190a:	bf00      	nop

0015190c <platform_interrupt_disable>:
  15190c:	4770      	bx	r14
  15190e:	bf00      	nop

00151910 <platform_init_rpmsg>:
 * platform/environment init
 */
int platform_init_rpmsg(void)
{
    /* Create lock used in multi-instanced RPMsg */
    if(0 != env_create_mutex(&platform_lock, 1))
  151910:	f246 604c 	movw	r0, #26188	; 0x664c
  151914:	2101      	movs	r1, #1
{
  151916:	b508      	push	{r3, r14}
    if(0 != env_create_mutex(&platform_lock, 1))
  151918:	f2c0 0016 	movt	r0, #22
  15191c:	f7ff ff6a 	bl	1517f4 <env_create_mutex>
  151920:	3000      	adds	r0, #0
  151922:	bf18      	it	ne
  151924:	2001      	movne	r0, #1
    {
        return -1;
    }

    return 0;
}
  151926:	4240      	negs	r0, r0
  151928:	bd08      	pop	{r3, r15}
  15192a:	bf00      	nop

0015192c <platform_deinit_rpmsg>:
 * platform_deinit_rpmsg
 *
 * platform/environment deinit process
 */
int platform_deinit_rpmsg(void)
{
  15192c:	b510      	push	{r4, r14}
    /* Delete lock used in multi-instanced RPMsg */
    env_delete_mutex(platform_lock);
  15192e:	f246 644c 	movw	r4, #26188	; 0x664c
  151932:	f2c0 0416 	movt	r4, #22
  151936:	6820      	ldr	r0, [r4, #0]
  151938:	f7ff ff76 	bl	151828 <env_delete_mutex>
    platform_lock = NULL;
  15193c:	2300      	movs	r3, #0
    return 0;
}
  15193e:	4618      	mov	r0, r3
    platform_lock = NULL;
  151940:	6023      	str	r3, [r4, #0]
}
  151942:	bd10      	pop	{r4, r15}

00151944 <sem_enable_intr>:
    sem_write_reg(sem, reg, _val);
}

void sem_enable_intr(enum sem sem, enum sem_intr intr,
                     bool enable)
{
  151944:	b410      	push	{r4}
    sem_write_reg(sem, INT_ENALE_OVRD,
                  1 << (intr + INT_ENABLE_OVRD_EN) |
  151946:	2401      	movs	r4, #1
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
  151948:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
  15194c:	3032      	adds	r0, #50	; 0x32
                  (uint32_t)enable << (intr + INT_ENABLE_OVRD_VAL));
  15194e:	f101 0308 	add.w	r3, r1, #8
                  1 << (intr + INT_ENABLE_OVRD_EN) |
  151952:	408c      	lsls	r4, r1
                  (uint32_t)enable << (intr + INT_ENABLE_OVRD_VAL));
  151954:	409a      	lsls	r2, r3
    sem_write_reg(sem, INT_ENALE_OVRD,
  151956:	4322      	orrs	r2, r4
}
  151958:	f85d 4b04 	ldr.w	r4, [r13], #4
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
  15195c:	0400      	lsls	r0, r0, #16
  15195e:	6082      	str	r2, [r0, #8]
}
  151960:	4770      	bx	r14
  151962:	bf00      	nop

00151964 <sem_signal_status>:
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  151964:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
  151968:	3032      	adds	r0, #50	; 0x32
 * Check input signal status.
 */
bool sem_signal_status(enum sem sem, enum sem_signal signal)
{
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
    return !!(val & (1 << (signal % 32)));
  15196a:	2301      	movs	r3, #1
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
  15196c:	094a      	lsrs	r2, r1, #5
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  15196e:	0400      	lsls	r0, r0, #16
    uint32_t val = sem_read_reg(sem, INT_STATUS(signal));
  151970:	3220      	adds	r2, #32
    return !!(val & (1 << (signal % 32)));
  151972:	f001 011f 	and.w	r1, r1, #31
  151976:	fa03 f101 	lsl.w	r1, r3, r1
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  15197a:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
    return !!(val & (1 << (signal % 32)));
  15197e:	4211      	tst	r1, r2
}
  151980:	bf14      	ite	ne
  151982:	4618      	movne	r0, r3
  151984:	2000      	moveq	r0, #0
  151986:	4770      	bx	r14

00151988 <sem_map_signal>:
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  151988:	f500 4070 	add.w	r0, r0, #61440	; 0xf000
 * This function is used to enable or disable the mapping from
 * input signals to SEM output interrupts.
 */
void sem_map_signal(enum sem sem, enum sem_signal signal,
                    enum sem_intr intr, bool enable)
{
  15198c:	b430      	push	{r4, r5}
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  15198e:	3032      	adds	r0, #50	; 0x32
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
                   1 << (signal % 32), enable << (signal % 32));
  151990:	2501      	movs	r5, #1
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
  151992:	1c94      	adds	r4, r2, #2
  151994:	094a      	lsrs	r2, r1, #5
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  151996:	0400      	lsls	r0, r0, #16
    sem_modify_reg(sem, INT_ENABLE(intr, signal),
  151998:	eb02 1244 	add.w	r2, r2, r4, lsl #5
                   1 << (signal % 32), enable << (signal % 32));
  15199c:	f001 011f 	and.w	r1, r1, #31
  1519a0:	408b      	lsls	r3, r1
    return readl(_ioaddr(APB_SEM_BASE(sem) + reg));
  1519a2:	f850 4022 	ldr.w	r4, [r0, r2, lsl #2]
                   1 << (signal % 32), enable << (signal % 32));
  1519a6:	fa05 f101 	lsl.w	r1, r5, r1
    _val &= ~mask;
  1519aa:	ea24 0101 	bic.w	r1, r4, r1
    _val |= val;
  1519ae:	430b      	orrs	r3, r1
}
  1519b0:	bc30      	pop	{r4, r5}
    writel(val, _ioaddr(APB_SEM_BASE(sem) + reg));
  1519b2:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
}
  1519b6:	4770      	bx	r14

001519b8 <mem_image_seek>:

    return 1;
}

uint32_t mem_image_seek(addr_t h, const char *name, mem_image_entry_t *info)
{
  1519b8:	e92d 4bf0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r11, r14}
  1519bc:	4604      	mov	r4, r0
  1519be:	460d      	mov	r5, r1
    uint32_t name_len;
    mem_image_header_t *header = (mem_image_header_t *)h;
    struct __mem_image_entry_info *__info = (struct __mem_image_entry_info *)(h + sizeof(mem_image_header_t));

    arch_invalidate_cache_range(h, HEADER_ENTRY_INFO_SIZE);
  1519c0:	f44f 6188 	mov.w	r1, #1088	; 0x440
{
  1519c4:	4616      	mov	r6, r2
    arch_invalidate_cache_range(h, HEADER_ENTRY_INFO_SIZE);
  1519c6:	f7f0 e8c0 	blx	141b48 <arch_invalidate_cache_range>
    name_len = strlen(name);
  1519ca:	4628      	mov	r0, r5
  1519cc:	f002 fc06 	bl	1541dc <strlen>
    if (header->magic != IMG_SEEKER_MAGIC
  1519d0:	6822      	ldr	r2, [r4, #0]
  1519d2:	f247 7371 	movw	r3, #30577	; 0x7771
  1519d6:	f2c7 7373 	movt	r3, #30579	; 0x7773
  1519da:	429a      	cmp	r2, r3
  1519dc:	d002      	beq.n	1519e4 <mem_image_seek+0x2c>
            info->sz = __info->addr_info.sz;
            return 0;
        }
    }
out:
    return 1;
  1519de:	2001      	movs	r0, #1
}
  1519e0:	e8bd 8bf0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r11, r15}
            || !header->inited) {
  1519e4:	7d23      	ldrb	r3, [r4, #20]
  1519e6:	2b00      	cmp	r3, #0
  1519e8:	d0f9      	beq.n	1519de <mem_image_seek+0x26>
  1519ea:	4680      	mov	r8, r0
    if (header->img_cnt > MAX_IMG_SEEKER_ENTRY_CNT || name_len == 0 || name_len > MAX_GPT_NAME_SIZE) {
  1519ec:	1e43      	subs	r3, r0, #1
  1519ee:	2b47      	cmp	r3, #71	; 0x47
  1519f0:	d8f5      	bhi.n	1519de <mem_image_seek+0x26>
  1519f2:	6923      	ldr	r3, [r4, #16]
    for (uint32_t i = 0; i < header->img_cnt; i++, __info++) {
  1519f4:	1e5a      	subs	r2, r3, #1
  1519f6:	2a07      	cmp	r2, #7
  1519f8:	d8f1      	bhi.n	1519de <mem_image_seek+0x26>
    struct __mem_image_entry_info *__info = (struct __mem_image_entry_info *)(h + sizeof(mem_image_header_t));
  1519fa:	f104 0740 	add.w	r7, r4, #64	; 0x40
  1519fe:	eb07 19c3 	add.w	r9, r7, r3, lsl #7
  151a02:	e002      	b.n	151a0a <mem_image_seek+0x52>
    for (uint32_t i = 0; i < header->img_cnt; i++, __info++) {
  151a04:	3780      	adds	r7, #128	; 0x80
  151a06:	454f      	cmp	r7, r9
  151a08:	d0e9      	beq.n	1519de <mem_image_seek+0x26>
        if (!strncmp(__info->name, name, strlen(name))) {
  151a0a:	4642      	mov	r2, r8
  151a0c:	4629      	mov	r1, r5
  151a0e:	f107 0010 	add.w	r0, r7, #16
  151a12:	f002 fbfd 	bl	154210 <strncmp>
  151a16:	2800      	cmp	r0, #0
  151a18:	d1f4      	bne.n	151a04 <mem_image_seek+0x4c>
            info->base = __info->addr_info.base + h;
  151a1a:	e9d7 8900 	ldrd	r8, r9, [r7]
            info->sz = __info->addr_info.sz;
  151a1e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
  151a22:	e9c6 2302 	strd	r2, r3, [r6, #8]
            info->base = __info->addr_info.base + h;
  151a26:	eb18 0b04 	adds.w	r11, r8, r4
  151a2a:	f149 0c00 	adc.w	r12, r9, #0
  151a2e:	e9c6 bc00 	strd	r11, r12, [r6]
            return 0;
  151a32:	e7d5      	b.n	1519e0 <mem_image_seek+0x28>

00151a34 <property_get_remote>:
#if CONFIG_HAS_PROPERTY_THREAD
static int property_thread;
#endif

static int property_get_remote(int property_id, int remote, int *val)
{
  151a34:	b5f0      	push	{r4, r5, r6, r7, r14}
  151a36:	4605      	mov	r5, r0
  151a38:	b099      	sub	sp, #100	; 0x64
  151a3a:	460e      	mov	r6, r1
  151a3c:	4617      	mov	r7, r2
    rpc_call_request_t request;
    rpc_call_result_t result = {0,};
  151a3e:	2100      	movs	r1, #0
  151a40:	2220      	movs	r2, #32
    int ret = 0;

    DCF_INIT_RPC_REQ1(request, SYS_RPC_REQ_GET_PROPERTY, property_id);
  151a42:	2402      	movs	r4, #2
    rpc_call_result_t result = {0,};
  151a44:	a805      	add	r0, sp, #20
  151a46:	f001 eb1a 	blx	15307c <memset>
    DCF_INIT_RPC_REQ1(request, SYS_RPC_REQ_GET_PROPERTY, property_id);
  151a4a:	2308      	movs	r3, #8
  151a4c:	f8bd 2036 	ldrh.w	r2, [r13, #54]	; 0x36
  151a50:	f242 0101 	movw	r1, #8193	; 0x2001
void dcf_register_rpc_implement_detailed(u32 cmd, rpc_server_func_t fn);

/* the helper function for system default ipcc services */
inline static int dcf_call(int rproc, rpc_call_request_t *request, rpc_call_result_t *result, lk_time_t timeout)
{
    return __dcf_call(dcf_get_service_handle(rproc), request, result, timeout);
  151a54:	4630      	mov	r0, r6
  151a56:	f363 020b 	bfi	r2, r3, #0, #12
  151a5a:	f88d 4034 	strb.w	r4, [r13, #52]	; 0x34
  151a5e:	2300      	movs	r3, #0
  151a60:	f8ad 2036 	strh.w	r2, [r13, #54]	; 0x36
  151a64:	e9cd 310e 	strd	r3, r1, [r13, #56]	; 0x38
  151a68:	f88d 3035 	strb.w	r3, [r13, #53]	; 0x35
  151a6c:	9510      	str	r5, [sp, #64]	; 0x40
  151a6e:	f7fa ff01 	bl	14c874 <dcf_get_service_handle>
  151a72:	2364      	movs	r3, #100	; 0x64
  151a74:	aa05      	add	r2, sp, #20
  151a76:	a90d      	add	r1, sp, #52	; 0x34
  151a78:	f7fa ffd4 	bl	14ca24 <__dcf_call>
    ret = dcf_call(remote, &request, &result, 100);
    if ((ret < 0) || (0 != result.retcode)) {
  151a7c:	1e04      	subs	r4, r0, #0
  151a7e:	db23      	blt.n	151ac8 <property_get_remote+0x94>
  151a80:	9b08      	ldr	r3, [sp, #32]
  151a82:	b92b      	cbnz	r3, 151a90 <property_get_remote+0x5c>
        dprintf(0, "[%lld] %s failed (%d) ret=%d %d\n", current_time_hires(),
                __func__, property_id, ret, result.retcode);
        return ret && result.retcode;
    }

    *val = result.result[0];
  151a84:	9a09      	ldr	r2, [sp, #36]	; 0x24

    return 0;
  151a86:	461c      	mov	r4, r3
    *val = result.result[0];
  151a88:	603a      	str	r2, [r7, #0]
}
  151a8a:	4620      	mov	r0, r4
  151a8c:	b019      	add	sp, #100	; 0x64
  151a8e:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "[%lld] %s failed (%d) ret=%d %d\n", current_time_hires(),
  151a90:	f7ee ff58 	bl	140944 <current_time_hires>
  151a94:	9a08      	ldr	r2, [sp, #32]
  151a96:	9203      	str	r2, [sp, #12]
  151a98:	f248 6354 	movw	r3, #34388	; 0x8654
  151a9c:	e9cd 5401 	strd	r5, r4, [r13, #4]
  151aa0:	f2c0 0315 	movt	r3, #21
  151aa4:	9300      	str	r3, [sp, #0]
  151aa6:	4602      	mov	r2, r0
  151aa8:	f248 6068 	movw	r0, #34408	; 0x8668
  151aac:	460b      	mov	r3, r1
  151aae:	f2c0 0015 	movt	r0, #21
  151ab2:	f002 fb21 	bl	1540f8 <_printf>
        return ret && result.retcode;
  151ab6:	2c00      	cmp	r4, #0
  151ab8:	d0e7      	beq.n	151a8a <property_get_remote+0x56>
  151aba:	9c08      	ldr	r4, [sp, #32]
  151abc:	3400      	adds	r4, #0
  151abe:	bf18      	it	ne
  151ac0:	2401      	movne	r4, #1
}
  151ac2:	4620      	mov	r0, r4
  151ac4:	b019      	add	sp, #100	; 0x64
  151ac6:	bdf0      	pop	{r4, r5, r6, r7, r15}
        dprintf(0, "[%lld] %s failed (%d) ret=%d %d\n", current_time_hires(),
  151ac8:	f7ee ff3c 	bl	140944 <current_time_hires>
  151acc:	9a08      	ldr	r2, [sp, #32]
  151ace:	9203      	str	r2, [sp, #12]
  151ad0:	f248 6354 	movw	r3, #34388	; 0x8654
  151ad4:	e9cd 5401 	strd	r5, r4, [r13, #4]
  151ad8:	f2c0 0315 	movt	r3, #21
  151adc:	9300      	str	r3, [sp, #0]
  151ade:	4602      	mov	r2, r0
  151ae0:	f248 6068 	movw	r0, #34408	; 0x8668
  151ae4:	460b      	mov	r3, r1
  151ae6:	f2c0 0015 	movt	r0, #21
  151aea:	f002 fb05 	bl	1540f8 <_printf>
        return ret && result.retcode;
  151aee:	9c08      	ldr	r4, [sp, #32]
  151af0:	3400      	adds	r4, #0
  151af2:	bf18      	it	ne
  151af4:	2401      	movne	r4, #1
  151af6:	e7e4      	b.n	151ac2 <property_get_remote+0x8e>

00151af8 <system_property_set>:
        event_signal(&property->event, false);
    }
}

int system_property_set(int property_id, int val)
{
  151af8:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
  151afc:	4605      	mov	r5, r0
  151afe:	f246 6058 	movw	r0, #26200	; 0x6658
  151b02:	460e      	mov	r6, r1
  151b04:	b094      	sub	sp, #80	; 0x50
  151b06:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  151b0a:	f2c0 0016 	movt	r0, #22
  151b0e:	f7fd fb5d 	bl	14f1cc <mutex_acquire_timeout>
    int ret = 0;
    int old;

    mutex_acquire(&property_lock);

    if (VALID_PROPERTY_ID(property_id)) {
  151b12:	2d00      	cmp	r5, #0
  151b14:	f2c0 80d3 	blt.w	151cbe <system_property_set+0x1c6>
  151b18:	f246 6350 	movw	r3, #26192	; 0x6650
  151b1c:	f2c0 0316 	movt	r3, #22
  151b20:	681b      	ldr	r3, [r3, #0]
  151b22:	42ab      	cmp	r3, r5
  151b24:	f340 80cb 	ble.w	151cbe <system_property_set+0x1c6>
        property = &_properties[property_id];
  151b28:	f640 7724 	movw	r7, #3876	; 0xf24
  151b2c:	ebc5 1405 	rsb	r4, r5, r5, lsl #4
  151b30:	f2c0 0716 	movt	r7, #22
  151b34:	00a4      	lsls	r4, r4, #2
  151b36:	f8d7 9000 	ldr.w	r9, [r7]
  151b3a:	eb09 0804 	add.w	r8, r9, r4
    int flags = property->flags & (SYS_PROP_F_INITD|SYS_PROP_F_RO);
  151b3e:	f8d8 3008 	ldr.w	r3, [r8, #8]
  151b42:	f003 0305 	and.w	r3, r3, #5
        /* readonly val can be set only once */
        if (property_is_ro_inited(property)) {
  151b46:	2b05      	cmp	r3, #5
  151b48:	f000 80c2 	beq.w	151cd0 <system_property_set+0x1d8>
            ret = ERR_NOT_ALLOWED;
            goto set_property_done;
        }

        if (property->owner ==  dcf_get_this_proc()) {
  151b4c:	f8d8 a00c 	ldr.w	r10, [r8, #12]
  151b50:	f7ee ff14 	bl	14097c <dcf_get_this_proc>
  151b54:	4582      	cmp	r10, r0
  151b56:	d140      	bne.n	151bda <system_property_set+0xe2>
            if (!(property->flags & SYS_PROP_F_INITD))
  151b58:	f8d8 3008 	ldr.w	r3, [r8, #8]
    property = &_properties[property_id];
  151b5c:	683f      	ldr	r7, [r7, #0]
            if (!(property->flags & SYS_PROP_F_INITD))
  151b5e:	07d9      	lsls	r1, r3, #31
                property->flags |= SYS_PROP_F_INITD;
  151b60:	bf58      	it	pl
  151b62:	f043 0301 	orrpl.w	r3, r3, #1
    property = &_properties[property_id];
  151b66:	4427      	add	r7, r4
                property->flags |= SYS_PROP_F_INITD;
  151b68:	bf58      	it	pl
  151b6a:	f8c8 3008 	strpl.w	r3, [r8, #8]

            old = property->val;
  151b6e:	f859 8004 	ldr.w	r8, [r9, r4]
  151b72:	6bbb      	ldr	r3, [r7, #56]	; 0x38
            property->val = val;
  151b74:	f849 6004 	str.w	r6, [r9, r4]
    if ((old != val) && property->callback) {
  151b78:	4546      	cmp	r6, r8
  151b7a:	d01e      	beq.n	151bba <system_property_set+0xc2>
  151b7c:	693a      	ldr	r2, [r7, #16]
  151b7e:	b1e2      	cbz	r2, 151bba <system_property_set+0xc2>
        if ((property->status & PROPERTY_IN_CALLBACK_BIT) == 0) {
  151b80:	04da      	lsls	r2, r3, #19
  151b82:	d478      	bmi.n	151c76 <system_property_set+0x17e>
            mutex_release(&property_lock);
  151b84:	f246 6058 	movw	r0, #26200	; 0x6658
            property->status |= PROPERTY_IN_CALLBACK_BIT;
  151b88:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
            mutex_release(&property_lock);
  151b8c:	f2c0 0016 	movt	r0, #22
            property->status |= PROPERTY_IN_CALLBACK_BIT;
  151b90:	63bb      	str	r3, [r7, #56]	; 0x38
            mutex_release(&property_lock);
  151b92:	f7fd fb47 	bl	14f224 <mutex_release>
            property->callback(property_id, old, val, property->usr_data);
  151b96:	e9d7 4304 	ldrd	r4, r3, [r7, #16]
  151b9a:	4641      	mov	r1, r8
  151b9c:	4628      	mov	r0, r5
  151b9e:	4632      	mov	r2, r6
  151ba0:	47a0      	blx	r4
  151ba2:	f246 6058 	movw	r0, #26200	; 0x6658
  151ba6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  151baa:	f2c0 0016 	movt	r0, #22
  151bae:	f7fd fb0d 	bl	14f1cc <mutex_acquire_timeout>
            property->status &= ~PROPERTY_IN_CALLBACK_BIT;
  151bb2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  151bb4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  151bb8:	63bb      	str	r3, [r7, #56]	; 0x38
    if ((property->status & PROPERTY_WAIT_STATUS_BIT) &&
  151bba:	041b      	lsls	r3, r3, #16
  151bbc:	d502      	bpl.n	151bc4 <system_property_set+0xcc>
  151bbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  151bc0:	429e      	cmp	r6, r3
  151bc2:	d06f      	beq.n	151ca4 <system_property_set+0x1ac>
    } else {
        ret = ERR_NOT_FOUND;
    }

set_property_done:
    mutex_release(&property_lock);
  151bc4:	f246 6058 	movw	r0, #26200	; 0x6658
    int ret = 0;
  151bc8:	2400      	movs	r4, #0
    mutex_release(&property_lock);
  151bca:	f2c0 0016 	movt	r0, #22
  151bce:	f7fd fb29 	bl	14f224 <mutex_release>
    if (ret < 0) {
        dprintf(0, "fail to set property(%d) for reason: %d\n", property_id, ret);
    }

    return ret;
}
  151bd2:	4620      	mov	r0, r4
  151bd4:	b014      	add	sp, #80	; 0x50
  151bd6:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    rpc_call_result_t result = {0,};
  151bda:	2220      	movs	r2, #32
  151bdc:	2100      	movs	r1, #0
            ret = property_set_remote(property_id, property->owner, val);
  151bde:	f8d8 700c 	ldr.w	r7, [r8, #12]
    rpc_call_result_t result = {0,};
  151be2:	a801      	add	r0, sp, #4
  151be4:	f001 ea4a 	blx	15307c <memset>
    DCF_INIT_RPC_REQ4(request, SYS_RPC_REQ_SET_PROPERTY, property_id, val, 0, 0);
  151be8:	2114      	movs	r1, #20
  151bea:	2300      	movs	r3, #0
  151bec:	f8bd 2026 	ldrh.w	r2, [r13, #38]	; 0x26
  151bf0:	2402      	movs	r4, #2
  151bf2:	f361 020b 	bfi	r2, r1, #0, #12
  151bf6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  151bfa:	4638      	mov	r0, r7
  151bfc:	f8ad 2026 	strh.w	r2, [r13, #38]	; 0x26
  151c00:	f88d 4024 	strb.w	r4, [r13, #36]	; 0x24
  151c04:	f88d 3025 	strb.w	r3, [r13, #37]	; 0x25
  151c08:	930a      	str	r3, [sp, #40]	; 0x28
  151c0a:	e9cd 330e 	strd	r3, r3, [r13, #56]	; 0x38
  151c0e:	910b      	str	r1, [sp, #44]	; 0x2c
  151c10:	e9cd 560c 	strd	r5, r6, [r13, #48]	; 0x30
  151c14:	f7fa fe2e 	bl	14c874 <dcf_get_service_handle>
  151c18:	2364      	movs	r3, #100	; 0x64
  151c1a:	aa01      	add	r2, sp, #4
  151c1c:	a909      	add	r1, sp, #36	; 0x24
  151c1e:	f7fa ff01 	bl	14ca24 <__dcf_call>
    if ((ret < 0) || (0 != result.retcode)) {
  151c22:	1e04      	subs	r4, r0, #0
  151c24:	db30      	blt.n	151c88 <system_property_set+0x190>
  151c26:	9c04      	ldr	r4, [sp, #16]
  151c28:	b1dc      	cbz	r4, 151c62 <system_property_set+0x16a>
        dprintf(0, "failed to set remote property (%d)\n", property_id);
  151c2a:	f248 7060 	movw	r0, #34656	; 0x8760
  151c2e:	4629      	mov	r1, r5
  151c30:	f2c0 0015 	movt	r0, #21
  151c34:	f002 fa60 	bl	1540f8 <_printf>
        return (ret < 0) ? ret : (int)result.retcode;
  151c38:	9c04      	ldr	r4, [sp, #16]
    mutex_release(&property_lock);
  151c3a:	f246 6058 	movw	r0, #26200	; 0x6658
  151c3e:	f2c0 0016 	movt	r0, #22
  151c42:	f7fd faef 	bl	14f224 <mutex_release>
    if (ret < 0) {
  151c46:	2c00      	cmp	r4, #0
  151c48:	da07      	bge.n	151c5a <system_property_set+0x162>
        dprintf(0, "fail to set property(%d) for reason: %d\n", property_id, ret);
  151c4a:	f248 7034 	movw	r0, #34612	; 0x8734
  151c4e:	4629      	mov	r1, r5
  151c50:	4622      	mov	r2, r4
  151c52:	f2c0 0015 	movt	r0, #21
  151c56:	f002 fa4f 	bl	1540f8 <_printf>
}
  151c5a:	4620      	mov	r0, r4
  151c5c:	b014      	add	sp, #80	; 0x50
  151c5e:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
    mutex_release(&property_lock);
  151c62:	f246 6058 	movw	r0, #26200	; 0x6658
  151c66:	f2c0 0016 	movt	r0, #22
  151c6a:	f7fd fadb 	bl	14f224 <mutex_release>
}
  151c6e:	4620      	mov	r0, r4
  151c70:	b014      	add	sp, #80	; 0x50
  151c72:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
            dprintf(0, "callback reenter would block pid=%d\n", property_id);
  151c76:	f248 700c 	movw	r0, #34572	; 0x870c
  151c7a:	4629      	mov	r1, r5
  151c7c:	f2c0 0015 	movt	r0, #21
  151c80:	f002 fa3a 	bl	1540f8 <_printf>
  151c84:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  151c86:	e798      	b.n	151bba <system_property_set+0xc2>
        dprintf(0, "failed to set remote property (%d)\n", property_id);
  151c88:	f248 7060 	movw	r0, #34656	; 0x8760
  151c8c:	4629      	mov	r1, r5
  151c8e:	f2c0 0015 	movt	r0, #21
  151c92:	f002 fa31 	bl	1540f8 <_printf>
    mutex_release(&property_lock);
  151c96:	f246 6058 	movw	r0, #26200	; 0x6658
  151c9a:	f2c0 0016 	movt	r0, #22
  151c9e:	f7fd fac1 	bl	14f224 <mutex_release>
  151ca2:	e7d2      	b.n	151c4a <system_property_set+0x152>
        event_signal(&property->event, false);
  151ca4:	2100      	movs	r1, #0
  151ca6:	f107 0018 	add.w	r0, r7, #24
    int ret = 0;
  151caa:	460c      	mov	r4, r1
        event_signal(&property->event, false);
  151cac:	f7fd fa0e 	bl	14f0cc <event_signal>
    mutex_release(&property_lock);
  151cb0:	f246 6058 	movw	r0, #26200	; 0x6658
  151cb4:	f2c0 0016 	movt	r0, #22
  151cb8:	f7fd fab4 	bl	14f224 <mutex_release>
  151cbc:	e7cd      	b.n	151c5a <system_property_set+0x162>
  151cbe:	f246 6058 	movw	r0, #26200	; 0x6658
        ret = ERR_NOT_FOUND;
  151cc2:	f06f 0401 	mvn.w	r4, #1
    mutex_release(&property_lock);
  151cc6:	f2c0 0016 	movt	r0, #22
  151cca:	f7fd faab 	bl	14f224 <mutex_release>
  151cce:	e7bc      	b.n	151c4a <system_property_set+0x152>
  151cd0:	f246 6058 	movw	r0, #26200	; 0x6658
            ret = ERR_NOT_ALLOWED;
  151cd4:	f06f 0410 	mvn.w	r4, #16
    mutex_release(&property_lock);
  151cd8:	f2c0 0016 	movt	r0, #22
  151cdc:	f7fd faa2 	bl	14f224 <mutex_release>
  151ce0:	e7b3      	b.n	151c4a <system_property_set+0x152>
  151ce2:	bf00      	nop

00151ce4 <rpc_set_property_cb>:

    return result;
}

static rpc_call_result_t rpc_set_property_cb(rpc_server_handle_t hserver, rpc_call_request_t *request)
{
  151ce4:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  151ce8:	4616      	mov	r6, r2
    rpc_call_result_t result = {0,};
  151cea:	2100      	movs	r1, #0
  151cec:	2220      	movs	r2, #32
{
  151cee:	4604      	mov	r4, r0
    rpc_call_result_t result = {0,};
  151cf0:	f001 e9c4 	blx	15307c <memset>
    int property_id = -1;
    int val = 0;

    result.ack = request->cmd;
  151cf4:	e9d6 7502 	ldrd	r7, r5, [r6, #8]
        return result;
    }

    property_id = (int) request->param[0];
    val = (int) request->param[1];
    if (!VALID_PROPERTY_ID(property_id)) {
  151cf8:	2d00      	cmp	r5, #0
  151cfa:	db06      	blt.n	151d0a <rpc_set_property_cb+0x26>
  151cfc:	f246 6350 	movw	r3, #26192	; 0x6650
  151d00:	f2c0 0316 	movt	r3, #22
  151d04:	681b      	ldr	r3, [r3, #0]
  151d06:	42ab      	cmp	r3, r5
  151d08:	dc06      	bgt.n	151d18 <rpc_set_property_cb+0x34>
        result.retcode = ERR_NOT_FOUND;
        dprintf(0, "setprop: %d not allowed\n", property_id);
    }

    return result;
}
  151d0a:	4620      	mov	r0, r4
        return result;
  151d0c:	f06f 0306 	mvn.w	r3, #6
  151d10:	e9c4 7302 	strd	r7, r3, [r4, #8]
}
  151d14:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    return (_properties[property_id].owner ==  dcf_get_this_proc());
  151d18:	f640 7224 	movw	r2, #3876	; 0xf24
  151d1c:	ebc5 1305 	rsb	r3, r5, r5, lsl #4
    val = (int) request->param[1];
  151d20:	6936      	ldr	r6, [r6, #16]
    return (_properties[property_id].owner ==  dcf_get_this_proc());
  151d22:	f2c0 0216 	movt	r2, #22
  151d26:	6812      	ldr	r2, [r2, #0]
  151d28:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  151d2c:	f8d3 800c 	ldr.w	r8, [r3, #12]
  151d30:	f7ee fe24 	bl	14097c <dcf_get_this_proc>
    if (system_property_is_local(property_id)) {
  151d34:	4580      	cmp	r8, r0
  151d36:	d00d      	beq.n	151d54 <rpc_set_property_cb+0x70>
        dprintf(0, "setprop: %d not allowed\n", property_id);
  151d38:	f248 608c 	movw	r0, #34444	; 0x868c
  151d3c:	4629      	mov	r1, r5
  151d3e:	f2c0 0015 	movt	r0, #21
  151d42:	f002 f9d9 	bl	1540f8 <_printf>
        result.retcode = ERR_NOT_FOUND;
  151d46:	f06f 0001 	mvn.w	r0, #1
    return result;
  151d4a:	e9c4 7002 	strd	r7, r0, [r4, #8]
}
  151d4e:	4620      	mov	r0, r4
  151d50:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        result.retcode = system_property_set(property_id, val);
  151d54:	4631      	mov	r1, r6
  151d56:	4628      	mov	r0, r5
  151d58:	f7ff fece 	bl	151af8 <system_property_set>
  151d5c:	e7f5      	b.n	151d4a <rpc_set_property_cb+0x66>
  151d5e:	bf00      	nop

00151d60 <system_property_get>:
{
  151d60:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
    if (!val)
  151d64:	2900      	cmp	r1, #0
  151d66:	d051      	beq.n	151e0c <system_property_get+0xac>
  151d68:	4604      	mov	r4, r0
  151d6a:	f246 6058 	movw	r0, #26200	; 0x6658
  151d6e:	460d      	mov	r5, r1
  151d70:	f2c0 0016 	movt	r0, #22
  151d74:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  151d78:	f7fd fa28 	bl	14f1cc <mutex_acquire_timeout>
    if (VALID_PROPERTY_ID(property_id)) {
  151d7c:	2c00      	cmp	r4, #0
  151d7e:	db06      	blt.n	151d8e <system_property_get+0x2e>
  151d80:	f246 6350 	movw	r3, #26192	; 0x6650
  151d84:	f2c0 0316 	movt	r3, #22
  151d88:	681b      	ldr	r3, [r3, #0]
  151d8a:	42a3      	cmp	r3, r4
  151d8c:	dc12      	bgt.n	151db4 <system_property_get+0x54>
    mutex_release(&property_lock);
  151d8e:	f246 6058 	movw	r0, #26200	; 0x6658
        ret = ERR_NOT_FOUND;
  151d92:	f06f 0501 	mvn.w	r5, #1
    mutex_release(&property_lock);
  151d96:	f2c0 0016 	movt	r0, #22
  151d9a:	f7fd fa43 	bl	14f224 <mutex_release>
        dprintf(0, "fail to get property(%d) for reason: %d\n", property_id, ret);
  151d9e:	f248 60e0 	movw	r0, #34528	; 0x86e0
  151da2:	4621      	mov	r1, r4
  151da4:	462a      	mov	r2, r5
  151da6:	f2c0 0015 	movt	r0, #21
  151daa:	f002 f9a5 	bl	1540f8 <_printf>
}
  151dae:	4628      	mov	r0, r5
  151db0:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        property = &_properties[property_id];
  151db4:	f640 7324 	movw	r3, #3876	; 0xf24
  151db8:	ebc4 1604 	rsb	r6, r4, r4, lsl #4
  151dbc:	f2c0 0316 	movt	r3, #22
  151dc0:	00b6      	lsls	r6, r6, #2
  151dc2:	681f      	ldr	r7, [r3, #0]
  151dc4:	eb07 0806 	add.w	r8, r7, r6
        if (property->owner ==  dcf_get_this_proc()) {
  151dc8:	f8d8 900c 	ldr.w	r9, [r8, #12]
  151dcc:	f7ee fdd6 	bl	14097c <dcf_get_this_proc>
  151dd0:	4581      	cmp	r9, r0
  151dd2:	d10b      	bne.n	151dec <system_property_get+0x8c>
            *val = property->val;
  151dd4:	59bb      	ldr	r3, [r7, r6]
    mutex_release(&property_lock);
  151dd6:	f246 6058 	movw	r0, #26200	; 0x6658
            *val = property->val;
  151dda:	602b      	str	r3, [r5, #0]
    mutex_release(&property_lock);
  151ddc:	f2c0 0016 	movt	r0, #22
    int ret = 0;
  151de0:	2500      	movs	r5, #0
    mutex_release(&property_lock);
  151de2:	f7fd fa1f 	bl	14f224 <mutex_release>
}
  151de6:	4628      	mov	r0, r5
  151de8:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            ret = property_get_remote(property_id, property->owner, val);
  151dec:	462a      	mov	r2, r5
  151dee:	4620      	mov	r0, r4
  151df0:	f8d8 100c 	ldr.w	r1, [r8, #12]
  151df4:	f7ff fe1e 	bl	151a34 <property_get_remote>
  151df8:	4605      	mov	r5, r0
    mutex_release(&property_lock);
  151dfa:	f246 6058 	movw	r0, #26200	; 0x6658
  151dfe:	f2c0 0016 	movt	r0, #22
  151e02:	f7fd fa0f 	bl	14f224 <mutex_release>
    if (ret < 0) {
  151e06:	2d00      	cmp	r5, #0
  151e08:	dad1      	bge.n	151dae <system_property_get+0x4e>
  151e0a:	e7c8      	b.n	151d9e <system_property_get+0x3e>
        return ERR_INVALID_ARGS;
  151e0c:	f06f 0507 	mvn.w	r5, #7
  151e10:	e7cd      	b.n	151dae <system_property_get+0x4e>
  151e12:	bf00      	nop

00151e14 <rpc_get_property_cb>:
{
  151e14:	b530      	push	{r4, r5, r14}
  151e16:	4615      	mov	r5, r2
  151e18:	b083      	sub	sp, #12
    rpc_call_result_t result = {0,};
  151e1a:	2100      	movs	r1, #0
  151e1c:	2220      	movs	r2, #32
{
  151e1e:	4604      	mov	r4, r0
    rpc_call_result_t result = {0,};
  151e20:	f001 e92c 	blx	15307c <memset>
    result.ack = request->cmd;
  151e24:	e9d5 5002 	ldrd	r5, r0, [r5, #8]
    int status = 0;
  151e28:	2300      	movs	r3, #0
  151e2a:	9301      	str	r3, [sp, #4]
    if (!VALID_PROPERTY_ID(property_id)) {
  151e2c:	4298      	cmp	r0, r3
  151e2e:	db06      	blt.n	151e3e <rpc_get_property_cb+0x2a>
  151e30:	f246 6350 	movw	r3, #26192	; 0x6650
  151e34:	f2c0 0316 	movt	r3, #22
  151e38:	681b      	ldr	r3, [r3, #0]
  151e3a:	4283      	cmp	r3, r0
  151e3c:	dc06      	bgt.n	151e4c <rpc_get_property_cb+0x38>
}
  151e3e:	4620      	mov	r0, r4
        return result;
  151e40:	f06f 0306 	mvn.w	r3, #6
  151e44:	e9c4 5302 	strd	r5, r3, [r4, #8]
}
  151e48:	b003      	add	sp, #12
  151e4a:	bd30      	pop	{r4, r5, r15}
    result.retcode = system_property_get(property_id, &status);
  151e4c:	a901      	add	r1, sp, #4
  151e4e:	f7ff ff87 	bl	151d60 <system_property_get>
    result.result[0] = status;
  151e52:	9b01      	ldr	r3, [sp, #4]
    return result;
  151e54:	60a5      	str	r5, [r4, #8]
  151e56:	e9c4 0303 	strd	r0, r3, [r4, #12]
}
  151e5a:	4620      	mov	r0, r4
  151e5c:	b003      	add	sp, #12
  151e5e:	bd30      	pop	{r4, r5, r15}

00151e60 <start_property_service>:
    return 0;
}
#endif

int start_property_service(struct sys_property_value *property_table, int num)
{
  151e60:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        {SYS_RPC_REQ_GET_PROPERTY, rpc_get_property_cb, IPCC_RPC_NO_FLAGS},
    };
    struct sys_property_value *property_area = NULL;
    int ret = 0;

    if (_properties && properties_number) {
  151e64:	f640 7424 	movw	r4, #3876	; 0xf24
  151e68:	f2c0 0416 	movt	r4, #22
  151e6c:	6823      	ldr	r3, [r4, #0]
  151e6e:	b133      	cbz	r3, 151e7e <start_property_service+0x1e>
  151e70:	f246 6350 	movw	r3, #26192	; 0x6650
  151e74:	f2c0 0316 	movt	r3, #22
  151e78:	681b      	ldr	r3, [r3, #0]
  151e7a:	2b00      	cmp	r3, #0
  151e7c:	d143      	bne.n	151f06 <start_property_service+0xa6>
  151e7e:	4606      	mov	r6, r0
        dprintf(1, "%s already started\n", __func__);
        return 0;
    }

    mutex_init(&property_lock);
  151e80:	f246 6058 	movw	r0, #26200	; 0x6658
  151e84:	460d      	mov	r5, r1
  151e86:	f2c0 0016 	movt	r0, #22
  151e8a:	f7fd f965 	bl	14f158 <mutex_init>
  151e8e:	f246 6058 	movw	r0, #26200	; 0x6658
  151e92:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  151e96:	f2c0 0016 	movt	r0, #22
  151e9a:	f7fd f997 	bl	14f1cc <mutex_acquire_timeout>

    mutex_acquire(&property_lock);

#if CONFIG_SUPPORT_POSIX
    /* failure is expected for the file not exist */
    property_fd = posix_open(DEV_PROPERTY, O_RDWR);
  151e9e:	f248 60a8 	movw	r0, #34472	; 0x86a8
  151ea2:	2102      	movs	r1, #2
  151ea4:	f2c0 0015 	movt	r0, #21
  151ea8:	f7fa fb88 	bl	14c5bc <dcf_open>
  151eac:	f246 6754 	movw	r7, #26196	; 0x6654
  151eb0:	f2c0 0716 	movt	r7, #22
#endif

    if (property_table && num) {
  151eb4:	2e00      	cmp	r6, #0
  151eb6:	bf18      	it	ne
  151eb8:	2d00      	cmpne	r5, #0
    property_fd = posix_open(DEV_PROPERTY, O_RDWR);
  151eba:	6038      	str	r0, [r7, #0]
    if (property_table && num) {
  151ebc:	d013      	beq.n	151ee6 <start_property_service+0x86>
        property_area = malloc(sizeof(struct sys_property_value) * num);
  151ebe:	ebc5 1805 	rsb	r8, r5, r5, lsl #4
  151ec2:	ea4f 0888 	mov.w	r8, r8, lsl #2
  151ec6:	4640      	mov	r0, r8
  151ec8:	f000 ffe2 	bl	152e90 <malloc>
        if (!property_area) {
  151ecc:	4681      	mov	r9, r0
  151ece:	b1e8      	cbz	r0, 151f0c <start_property_service+0xac>
            dprintf(0, "not enough memory for properties %d\n", num);
            ret = ERR_NO_MEMORY;
            goto fail_and_free;
        }

        memcpy(property_area, property_table, sizeof(struct sys_property_value) * num);
  151ed0:	4642      	mov	r2, r8
  151ed2:	4631      	mov	r1, r6
  151ed4:	f001 e84c 	blx	152f70 <memcpy>
        _properties = property_area;
  151ed8:	f8c4 9000 	str.w	r9, [r4]
        properties_number = num;
  151edc:	f246 6350 	movw	r3, #26192	; 0x6650
  151ee0:	f2c0 0316 	movt	r3, #22
  151ee4:	601d      	str	r5, [r3, #0]
    }

    start_ipcc_rpc_service(s_myfuncs, ARRAY_SIZE(s_myfuncs));
  151ee6:	f640 7028 	movw	r0, #3880	; 0xf28
  151eea:	2102      	movs	r1, #2
  151eec:	f2c0 0016 	movt	r0, #22
  151ef0:	f7fa fd86 	bl	14ca00 <start_ipcc_rpc_service>
    property_thread = thread_create("propertyd", property_task,
                            NULL, THREAD_PRI_PROPERTY, DEFAULT_STACK_SIZE);
    thread_detach_and_resume(property_thread);
#endif

    mutex_release(&property_lock);
  151ef4:	f246 6058 	movw	r0, #26200	; 0x6658
  151ef8:	f2c0 0016 	movt	r0, #22
  151efc:	f7fd f992 	bl	14f224 <mutex_release>
    dprintf(1, "%s started\n", __func__);

    return 0;
  151f00:	2000      	movs	r0, #0
#endif

    mutex_release(&property_lock);

    return ret;
}
  151f02:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
        return 0;
  151f06:	2000      	movs	r0, #0
}
  151f08:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            dprintf(0, "not enough memory for properties %d\n", num);
  151f0c:	f248 60b8 	movw	r0, #34488	; 0x86b8
  151f10:	4629      	mov	r1, r5
  151f12:	f2c0 0015 	movt	r0, #21
  151f16:	f002 f8ef 	bl	1540f8 <_printf>
    if (property_fd > 0)
  151f1a:	6838      	ldr	r0, [r7, #0]
  151f1c:	2800      	cmp	r0, #0
  151f1e:	dd01      	ble.n	151f24 <start_property_service+0xc4>
        posix_close(property_fd);
  151f20:	f7fa fbb4 	bl	14c68c <dcf_close>
    mutex_release(&property_lock);
  151f24:	f246 6058 	movw	r0, #26200	; 0x6658
  151f28:	f2c0 0016 	movt	r0, #22
  151f2c:	f7fd f97a 	bl	14f224 <mutex_release>
    return ret;
  151f30:	f06f 0004 	mvn.w	r0, #4
  151f34:	e7e5      	b.n	151f02 <start_property_service+0xa2>
  151f36:	bf00      	nop

00151f38 <novm_init_helper>:
}

static void novm_init_helper(struct novm_arena *n, const char *name,
                             uintptr_t arena_start, uintptr_t arena_size,
                             char *default_map, size_t default_map_size)
{
  151f38:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  151f3c:	4690      	mov	r8, r2
    uintptr_t start = ROUNDUP(arena_start, PAGE_SIZE);
  151f3e:	f44f 4270 	mov.w	r2, #61440	; 0xf000
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
  151f42:	eb08 0603 	add.w	r6, r8, r3
    uintptr_t start = ROUNDUP(arena_start, PAGE_SIZE);
  151f46:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  151f4a:	f608 74ff 	addw	r4, r8, #4095	; 0xfff
  151f4e:	4014      	ands	r4, r2
{
  151f50:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
  151f52:	4016      	ands	r6, r2
{
  151f54:	f8dd a028 	ldr.w	r10, [r13, #40]	; 0x28
    uintptr_t size = ROUNDDOWN(arena_start + arena_size, PAGE_SIZE) - start;
  151f58:	1b36      	subs	r6, r6, r4
{
  151f5a:	468b      	mov	r11, r1
  151f5c:	4681      	mov	r9, r0

    mutex_init(&n->lock);

    size_t map_size = size >> PAGE_SIZE_SHIFT;
  151f5e:	0b35      	lsrs	r5, r6, #12
    mutex_init(&n->lock);
  151f60:	f7fd f8fa 	bl	14f158 <mutex_init>
    char *map = default_map;
    if (map == NULL || default_map_size < map_size) {
  151f64:	42bd      	cmp	r5, r7
  151f66:	bf94      	ite	ls
  151f68:	2700      	movls	r7, #0
  151f6a:	2701      	movhi	r7, #1
  151f6c:	eba4 0308 	sub.w	r3, r4, r8
  151f70:	f1ba 0f00 	cmp.w	r10, #0
  151f74:	bf08      	it	eq
  151f76:	2701      	moveq	r7, #1
  151f78:	b31f      	cbz	r7, 151fc2 <novm_init_helper+0x8a>
        // allocate the map out of the arena itself
        map = (char *)arena_start;
  151f7a:	46c2      	mov	r10, r8

        // Grab enough map for 16Mbyte of arena each time around the loop.
        while (start - arena_start < map_size) {
  151f7c:	429d      	cmp	r5, r3
  151f7e:	d908      	bls.n	151f92 <novm_init_helper+0x5a>
            start += PAGE_SIZE;
  151f80:	f504 5480 	add.w	r4, r4, #4096	; 0x1000
            size -= PAGE_SIZE;
            map_size--;
  151f84:	3d01      	subs	r5, #1
        while (start - arena_start < map_size) {
  151f86:	eba4 0308 	sub.w	r3, r4, r8
  151f8a:	429d      	cmp	r5, r3
            size -= PAGE_SIZE;
  151f8c:	f5a6 5680 	sub.w	r6, r6, #4096	; 0x1000
        while (start - arena_start < map_size) {
  151f90:	d8f6      	bhi.n	151f80 <novm_init_helper+0x48>
        }

        if ((char *)start - (map + ROUNDUP(map_size, 4)) >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
  151f92:	1cea      	adds	r2, r5, #3
  151f94:	f022 0203 	bic.w	r2, r2, #3
  151f98:	4442      	add	r2, r8
  151f9a:	1aa3      	subs	r3, r4, r2
  151f9c:	2b3f      	cmp	r3, #63	; 0x3f
  151f9e:	dd01      	ble.n	151fa4 <novm_init_helper+0x6c>
            n->unaligned_area = map + ROUNDUP(map_size, 4);
            n->unaligned_size = (char *)start - (map + ROUNDUP(map_size, 4));
  151fa0:	e9c9 230c 	strd	r2, r3, [r9, #48]	; 0x30
        }
    } else if (start - arena_start >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
        n->unaligned_area = (char *)arena_start;
        n->unaligned_size = start - arena_start;
    }
    n->name = name;
  151fa4:	f8c9 b01c 	str.w	r11, [r9, #28]
    n->map = map;
    memset(n->map, 0, map_size);
  151fa8:	4650      	mov	r0, r10
    n->map = map;
  151faa:	f8c9 a024 	str.w	r10, [r9, #36]	; 0x24
    memset(n->map, 0, map_size);
  151fae:	462a      	mov	r2, r5
  151fb0:	2100      	movs	r1, #0
  151fb2:	f001 e864 	blx	15307c <memset>
    n->pages = map_size;
  151fb6:	f8c9 5020 	str.w	r5, [r9, #32]
    n->base = (char *)start;
    n->size = size;
  151fba:	e9c9 460a 	strd	r4, r6, [r9, #40]	; 0x28
}
  151fbe:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
    } else if (start - arena_start >= MINIMUM_USEFUL_UNALIGNED_SIZE) {
  151fc2:	2b3f      	cmp	r3, #63	; 0x3f
        n->unaligned_size = start - arena_start;
  151fc4:	bf88      	it	hi
  151fc6:	e9c9 830c 	strdhi	r8, r3, [r9, #48]	; 0x30
  151fca:	e7eb      	b.n	151fa4 <novm_init_helper+0x6c>

00151fcc <novm_init>:
}

static void novm_init(uint level)
{
    static char mem_allocation_map[DEFAULT_MAP_SIZE];
    novm_init_helper(&arena[0], "main", MEM_START, MEM_SIZE, mem_allocation_map, DEFAULT_MAP_SIZE);
  151fcc:	f246 63ac 	movw	r3, #26284	; 0x66ac
  151fd0:	f246 7264 	movw	r2, #26468	; 0x6764
{
  151fd4:	b510      	push	{r4, r14}
    novm_init_helper(&arena[0], "main", MEM_START, MEM_SIZE, mem_allocation_map, DEFAULT_MAP_SIZE);
  151fd6:	2440      	movs	r4, #64	; 0x40
{
  151fd8:	b082      	sub	sp, #8
    novm_init_helper(&arena[0], "main", MEM_START, MEM_SIZE, mem_allocation_map, DEFAULT_MAP_SIZE);
  151fda:	f2c0 0316 	movt	r3, #22
  151fde:	f248 7184 	movw	r1, #34692	; 0x8784
  151fe2:	f2c0 0216 	movt	r2, #22
  151fe6:	f246 6074 	movw	r0, #26228	; 0x6674
  151fea:	f2c0 0115 	movt	r1, #21
  151fee:	9300      	str	r3, [sp, #0]
  151ff0:	f2c0 0016 	movt	r0, #22
  151ff4:	9401      	str	r4, [sp, #4]
  151ff6:	f5c2 13c0 	rsb	r3, r2, #1572864	; 0x180000
  151ffa:	f7ff ff9d 	bl	151f38 <novm_init_helper>
}
  151ffe:	b002      	add	sp, #8
  152000:	bd10      	pop	{r4, r15}
  152002:	bf00      	nop

00152004 <novm_alloc_helper>:

LK_INIT_HOOK(novm, &novm_init, LK_INIT_LEVEL_PLATFORM_EARLY - 1);

void *novm_alloc_helper(struct novm_arena *n, size_t pages)
{
    if (pages == 0 || pages > n->pages)
  152004:	b3c9      	cbz	r1, 15207a <novm_alloc_helper+0x76>
  152006:	6a03      	ldr	r3, [r0, #32]
{
  152008:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  15200c:	4680      	mov	r8, r0
    if (pages == 0 || pages > n->pages)
  15200e:	428b      	cmp	r3, r1
        return NULL;
  152010:	bf38      	it	cc
  152012:	2000      	movcc	r0, #0
    if (pages == 0 || pages > n->pages)
  152014:	d325      	bcc.n	152062 <novm_alloc_helper+0x5e>
  152016:	460e      	mov	r6, r1
  152018:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  15201c:	f7fd f8d6 	bl	14f1cc <mutex_acquire_timeout>

    mutex_acquire(&n->lock);
    for (size_t i = 0; i <= n->pages - pages; i++) {
        bool found = true;
        for (size_t j = 0; j < pages; j++) {
            if (n->map[i + j] != 0) {
  152020:	e9d8 3508 	ldrd	r3, r5, [r8, #32]
    for (size_t i = 0; i <= n->pages - pages; i++) {
  152024:	2700      	movs	r7, #0
  152026:	eba3 0c06 	sub.w	r12, r3, r6
  15202a:	eb05 0e06 	add.w	r14, r5, r6
            if (n->map[i + j] != 0) {
  15202e:	19e8      	adds	r0, r5, r7
  152030:	5deb      	ldrb	r3, [r5, r7]
  152032:	b9c3      	cbnz	r3, 152066 <novm_alloc_helper+0x62>
  152034:	1c7b      	adds	r3, r7, #1
  152036:	442b      	add	r3, r5
  152038:	eb0e 0207 	add.w	r2, r14, r7
  15203c:	e002      	b.n	152044 <novm_alloc_helper+0x40>
  15203e:	f813 4b01 	ldrb.w	r4, [r3], #1
  152042:	b98c      	cbnz	r4, 152068 <novm_alloc_helper+0x64>
        for (size_t j = 0; j < pages; j++) {
  152044:	4293      	cmp	r3, r2
  152046:	eba3 0105 	sub.w	r1, r3, r5
  15204a:	d1f8      	bne.n	15203e <novm_alloc_helper+0x3a>
                found = false;
                break;
            }
        }
        if (found) {
            memset(n->map + i, 1, pages);
  15204c:	4632      	mov	r2, r6
  15204e:	2101      	movs	r1, #1
  152050:	f001 e814 	blx	15307c <memset>
            mutex_release(&n->lock);
  152054:	4640      	mov	r0, r8
  152056:	f7fd f8e5 	bl	14f224 <mutex_release>
            return n->base + (i << PAGE_SIZE_SHIFT);
  15205a:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
  15205e:	eb00 3007 	add.w	r0, r0, r7, lsl #12
        }
    }
    mutex_release(&n->lock);

    return NULL;
}
  152062:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
            if (n->map[i + j] != 0) {
  152066:	4639      	mov	r1, r7
    for (size_t i = 0; i <= n->pages - pages; i++) {
  152068:	1c4f      	adds	r7, r1, #1
  15206a:	4567      	cmp	r7, r12
  15206c:	d9df      	bls.n	15202e <novm_alloc_helper+0x2a>
    mutex_release(&n->lock);
  15206e:	4640      	mov	r0, r8
  152070:	f7fd f8d8 	bl	14f224 <mutex_release>
    return NULL;
  152074:	2000      	movs	r0, #0
}
  152076:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
        return NULL;
  15207a:	4608      	mov	r0, r1
}
  15207c:	4770      	bx	r14
  15207e:	bf00      	nop

00152080 <novm_alloc_unaligned>:
    if (arena[0].unaligned_area != NULL) {
  152080:	f246 6374 	movw	r3, #26228	; 0x6674
  152084:	f2c0 0316 	movt	r3, #22
{
  152088:	b410      	push	{r4}
  15208a:	4604      	mov	r4, r0
    if (arena[0].unaligned_area != NULL) {
  15208c:	6b18      	ldr	r0, [r3, #48]	; 0x30
  15208e:	b138      	cbz	r0, 1520a0 <novm_alloc_unaligned+0x20>
        *size_return = arena[0].unaligned_size;
  152090:	6b59      	ldr	r1, [r3, #52]	; 0x34
        arena[0].unaligned_area = NULL;
  152092:	2200      	movs	r2, #0
        *size_return = arena[0].unaligned_size;
  152094:	6021      	str	r1, [r4, #0]
        arena[0].unaligned_size = 0;
  152096:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
}
  15209a:	f85d 4b04 	ldr.w	r4, [r13], #4
  15209e:	4770      	bx	r14
    *size_return = PAGE_SIZE;
  1520a0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    LTRACEF("pages %zu\n", pages);

    /* allocate from any arena */
    for (uint i = 0; i < NOVM_MAX_ARENAS; i++) {
        if (arena_bitmap & (1U << i)) {
            void *result = novm_alloc_helper(&arena[i], pages);
  1520a4:	4618      	mov	r0, r3
  1520a6:	2101      	movs	r1, #1
    *size_return = PAGE_SIZE;
  1520a8:	6022      	str	r2, [r4, #0]
}
  1520aa:	f85d 4b04 	ldr.w	r4, [r13], #4
            void *result = novm_alloc_helper(&arena[i], pages);
  1520ae:	f7ff bfa9 	b.w	152004 <novm_alloc_helper>
  1520b2:	bf00      	nop

001520b4 <novm_alloc_pages>:
{
  1520b4:	4603      	mov	r3, r0
        if (arena_bitmap & (1U << i)) {
  1520b6:	f011 0101 	ands.w	r1, r1, #1
  1520ba:	d006      	beq.n	1520ca <novm_alloc_pages+0x16>
            void *result = novm_alloc_helper(&arena[i], pages);
  1520bc:	f246 6074 	movw	r0, #26228	; 0x6674
  1520c0:	4619      	mov	r1, r3
  1520c2:	f2c0 0016 	movt	r0, #22
  1520c6:	f7ff bf9d 	b.w	152004 <novm_alloc_helper>
                return result;
        }
    }

    return NULL;
}
  1520ca:	4608      	mov	r0, r1
  1520cc:	4770      	bx	r14
  1520ce:	bf00      	nop

001520d0 <update_boot_info.constprop.1>:
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
    bootinfo->boot_pin = data;
    return data;
}

static void update_boot_info(boot_info_t *bootinfo)
  1520d0:	b538      	push	{r3, r4, r5, r14}
{
    uint32_t data, pin;

    if (bootinfo->boot_ops & BOOT_INFO_BOOT_PIN_UPDATE_MASK)
  1520d2:	f246 64ec 	movw	r4, #26348	; 0x66ec
  1520d6:	f2c0 0416 	movt	r4, #22
  1520da:	6823      	ldr	r3, [r4, #0]
  1520dc:	2b00      	cmp	r3, #0
  1520de:	db27      	blt.n	152130 <update_boot_info.constprop.1+0x60>
    data = readl(_ioaddr(APB_SCR_SEC_BASE + ((0x200 + 4 * 49) << 10)));
  1520e0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  1520e4:	f6cf 022b 	movt	r2, #63531	; 0xf82b
  1520e8:	6812      	ldr	r2, [r2, #0]
    if (data & (1 << 8)) {
  1520ea:	05d1      	lsls	r1, r2, #23
  1520ec:	d421      	bmi.n	152132 <update_boot_info.constprop.1+0x62>
    data = readl(_ioaddr(APB_EFUSEC_BASE + 0x1000 + FUSE_BT_CGF_INDEX0 * 4));
  1520ee:	f241 22b4 	movw	r2, #4788	; 0x12b4
  1520f2:	f2cf 0201 	movt	r2, #61441	; 0xf001
  1520f6:	6812      	ldr	r2, [r2, #0]
    if (data & (1 << 25)) {
  1520f8:	0195      	lsls	r5, r2, #6
  1520fa:	d521      	bpl.n	152140 <update_boot_info.constprop.1+0x70>
        bootinfo->boot_ops |= BOOT_INFO_FROM_FUSE_MASK;
  1520fc:	f043 0302 	orr.w	r3, r3, #2
        data = (data & 0x3c000000) >> 26;
  152100:	f3c2 6283 	ubfx	r2, r2, #26, #4
        bootinfo->boot_pin = data;
  152104:	e9c4 3200 	strd	r3, r2, [r4]
    if (pin == PIN_ERROR)
        pin = boot_get_pin_fuse(bootinfo);
    if (pin == PIN_ERROR)
        pin = boot_get_pin_gpio(bootinfo);

    data = readl(_ioaddr(APB_EFUSEC_BASE + 0x1000 + FUSE_BT_CGF_INDEX0 * 4));
  152108:	f241 22b4 	movw	r2, #4788	; 0x12b4
  15210c:	f2cf 0201 	movt	r2, #61441	; 0xf001
  152110:	6812      	ldr	r2, [r2, #0]
    /*  BT_FUSE0[24], 0 - Enable, 1 - Disable */
    if (data & 1 << 24) {
  152112:	01d0      	lsls	r0, r2, #7
        bootinfo->boot_ops |= BOOT_INFO_USB_PROVISION_DIS_MASK;
  152114:	bf48      	it	mi
  152116:	f043 0308 	orrmi.w	r3, r3, #8
    }
    /* BT_FUSE0[18] */
    if (data & 1 << 18) {
  15211a:	0351      	lsls	r1, r2, #13
        bootinfo->boot_ops |= BOOT_INFO_SAFETY_HANDOVER_DIS_MASK;
  15211c:	bf48      	it	mi
  15211e:	f043 0310 	orrmi.w	r3, r3, #16
    }
    /* BT_FUSE0[17], 1 - Disable */
    if (data & 1 << 17) {
  152122:	0392      	lsls	r2, r2, #14
        bootinfo->boot_ops |= BOOT_INFO_PEER_LOAD_ON_SAF_FAILURE_DIS_MASK;
  152124:	bf48      	it	mi
  152126:	f043 0320 	orrmi.w	r3, r3, #32
    }

    bootinfo->boot_ops |= BOOT_INFO_BOOT_PIN_UPDATE_MASK;
  15212a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  15212e:	6023      	str	r3, [r4, #0]
}
  152130:	bd38      	pop	{r3, r4, r5, r15}
        bootinfo->boot_ops |= BOOT_INFO_FROM_SCR_MASK;
  152132:	f043 0304 	orr.w	r3, r3, #4
        data &= 0xf;
  152136:	f002 020f 	and.w	r2, r2, #15
        bootinfo->boot_pin = data;
  15213a:	e9c4 3200 	strd	r3, r2, [r4]
  15213e:	e7e3      	b.n	152108 <update_boot_info.constprop.1+0x38>
    handle_bootmode = hal_scr_create_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  152140:	2004      	movs	r0, #4
  152142:	f240 1101 	movw	r1, #257	; 0x101
  152146:	f2c0 1000 	movt	r0, #256	; 0x100
  15214a:	f7fc fae1 	bl	14e710 <hal_scr_create_handle>
    data = hal_scr_get(handle_bootmode);
  15214e:	f7fc faf9 	bl	14e744 <hal_scr_get>
    hal_scr_delete_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  152152:	f240 1101 	movw	r1, #257	; 0x101
    data = hal_scr_get(handle_bootmode);
  152156:	4605      	mov	r5, r0
    hal_scr_delete_handle(SCR_SEC__RO__rstgen_saf_boot_mode_scr_3_0);
  152158:	2004      	movs	r0, #4
  15215a:	f2c0 1000 	movt	r0, #256	; 0x100
  15215e:	f7fc fad9 	bl	14e714 <hal_scr_delete_handle>
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
  152162:	6823      	ldr	r3, [r4, #0]
    data &= 0xf;
  152164:	f005 050f 	and.w	r5, r5, #15
    bootinfo->boot_ops |= BOOT_INFO_FROM_GPIO_MASK;
  152168:	f043 0301 	orr.w	r3, r3, #1
  15216c:	e9c4 3500 	strd	r3, r5, [r4]
  152170:	e7ca      	b.n	152108 <update_boot_info.constprop.1+0x38>
  152172:	bf00      	nop

00152174 <boot_get_pin>:

uint32_t boot_get_pin(void)
{
  152174:	b508      	push	{r3, r14}
    update_boot_info(&g_bootinfo);
  152176:	f7ff ffab 	bl	1520d0 <update_boot_info.constprop.1>
    return g_bootinfo.boot_pin;
  15217a:	f246 63ec 	movw	r3, #26348	; 0x66ec
  15217e:	f2c0 0316 	movt	r3, #22
}
  152182:	6858      	ldr	r0, [r3, #4]
  152184:	bd08      	pop	{r3, r15}
  152186:	bf00      	nop

00152188 <cbuf_read_unblock>:

    return pos;
}

static size_t cbuf_read_unblock(cbuf_t *cbuf, void *buf, size_t buflen)
{
  152188:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  15218c:	4688      	mov	r8, r1
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  15218e:	f3ef 8400 	mrs	r4, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  152192:	f014 0480 	ands.w	r4, r4, #128	; 0x80
  152196:	d110      	bne.n	1521ba <cbuf_read_unblock+0x32>
    __asm__ volatile("cpsid i");
  152198:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    // see if there's data available
    size_t ret = 0;
    if (cbuf->tail != cbuf->head) {
  15219a:	e9d0 3100 	ldrd	r3, r1, [r0]
    *lock = 1;
  15219e:	2501      	movs	r5, #1
  1521a0:	62c5      	str	r5, [r0, #44]	; 0x2c
  1521a2:	4299      	cmp	r1, r3
    *lock = 0;
  1521a4:	bf08      	it	eq
  1521a6:	62c4      	streq	r4, [r0, #44]	; 0x2c
  1521a8:	d003      	beq.n	1521b2 <cbuf_read_unblock+0x2a>
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1521aa:	46ab      	mov	r11, r5
        size_t pos = 0;

        // loop until we've read everything we need
        // at most this will make two passes to deal with wraparound
        while (pos < buflen && cbuf->tail != cbuf->head) {
  1521ac:	b99a      	cbnz	r2, 1521d6 <cbuf_read_unblock+0x4e>
    *lock = 0;
  1521ae:	62c2      	str	r2, [r0, #44]	; 0x2c
  1521b0:	4614      	mov	r4, r2
    __asm__ volatile("cpsie i");
  1521b2:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&cbuf->lock, state);

    return ret;
}
  1521b4:	4620      	mov	r0, r4
  1521b6:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
    if (cbuf->tail != cbuf->head) {
  1521ba:	e9d0 3100 	ldrd	r3, r1, [r0]
    *lock = 1;
  1521be:	2401      	movs	r4, #1
  1521c0:	62c4      	str	r4, [r0, #44]	; 0x2c
  1521c2:	4299      	cmp	r1, r3
    *lock = 0;
  1521c4:	bf02      	ittt	eq
  1521c6:	2300      	moveq	r3, #0
    size_t ret = 0;
  1521c8:	461c      	moveq	r4, r3
  1521ca:	62c3      	streq	r3, [r0, #44]	; 0x2c
    if (cbuf->tail != cbuf->head) {
  1521cc:	d0f2      	beq.n	1521b4 <cbuf_read_unblock+0x2c>
    spin_lock_saved_state_t state = 0;
  1521ce:	f04f 0b00 	mov.w	r11, #0
        while (pos < buflen && cbuf->tail != cbuf->head) {
  1521d2:	2a00      	cmp	r2, #0
  1521d4:	d03c      	beq.n	152250 <cbuf_read_unblock+0xc8>
  1521d6:	4617      	mov	r7, r2
  1521d8:	4605      	mov	r5, r0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1521da:	2400      	movs	r4, #0
    return 1U << valp2;
  1521dc:	f04f 0a01 	mov.w	r10, #1
    return val & ((1UL << modp2) - 1);
  1521e0:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
  1521e4:	e001      	b.n	1521ea <cbuf_read_unblock+0x62>
  1521e6:	4299      	cmp	r1, r3
  1521e8:	d02d      	beq.n	152246 <cbuf_read_unblock+0xbe>
            if (cbuf->head > cbuf->tail) {
  1521ea:	428b      	cmp	r3, r1
                read_len = MIN(cbuf->head - cbuf->tail, buflen - pos);
  1521ec:	eba3 0201 	sub.w	r2, r3, r1
  1521f0:	eba7 0604 	sub.w	r6, r7, r4
    return 1U << valp2;
  1521f4:	bf98      	it	ls
  1521f6:	68aa      	ldrls	r2, [r5, #8]
                memcpy(buf + pos, cbuf->buf + cbuf->tail, read_len);
  1521f8:	eb08 0004 	add.w	r0, r8, r4
  1521fc:	bf9c      	itt	ls
  1521fe:	fa0a f202 	lslls.w	r2, r10, r2
                read_len = MIN(valpow2(cbuf->len_pow2) - cbuf->tail, buflen - pos);
  152202:	1a52      	subls	r2, r2, r1
  152204:	4296      	cmp	r6, r2
  152206:	bf28      	it	cs
  152208:	4616      	movcs	r6, r2
            if (NULL != buf) {
  15220a:	f1b8 0f00 	cmp.w	r8, #0
  15220e:	d006      	beq.n	15221e <cbuf_read_unblock+0x96>
                memcpy(buf + pos, cbuf->buf + cbuf->tail, read_len);
  152210:	68eb      	ldr	r3, [r5, #12]
  152212:	4632      	mov	r2, r6
  152214:	4419      	add	r1, r3
  152216:	f000 eeac 	blx	152f70 <memcpy>
  15221a:	e9d5 3100 	ldrd	r3, r1, [r5]
    return val & ((1UL << modp2) - 1);
  15221e:	68aa      	ldr	r2, [r5, #8]
            cbuf->tail = INC_POINTER(cbuf, cbuf->tail, read_len);
  152220:	4431      	add	r1, r6
            pos += read_len;
  152222:	4434      	add	r4, r6
  152224:	fa09 f202 	lsl.w	r2, r9, r2
  152228:	ea21 0102 	bic.w	r1, r1, r2
        while (pos < buflen && cbuf->tail != cbuf->head) {
  15222c:	42a7      	cmp	r7, r4
            cbuf->tail = INC_POINTER(cbuf, cbuf->tail, read_len);
  15222e:	6069      	str	r1, [r5, #4]
        while (pos < buflen && cbuf->tail != cbuf->head) {
  152230:	d8d9      	bhi.n	1521e6 <cbuf_read_unblock+0x5e>
        if (cbuf->tail == cbuf->head) {
  152232:	4299      	cmp	r1, r3
  152234:	d007      	beq.n	152246 <cbuf_read_unblock+0xbe>
    *lock = 0;
  152236:	2300      	movs	r3, #0
  152238:	62eb      	str	r3, [r5, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15223a:	f1bb 0f00 	cmp.w	r11, #0
  15223e:	d1b8      	bne.n	1521b2 <cbuf_read_unblock+0x2a>
}
  152240:	4620      	mov	r0, r4
  152242:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
            event_unsignal(&cbuf->event);
  152246:	f105 0010 	add.w	r0, r5, #16
  15224a:	f7fc ff75 	bl	14f138 <event_unsignal>
  15224e:	e7f2      	b.n	152236 <cbuf_read_unblock+0xae>
    *lock = 0;
  152250:	62c2      	str	r2, [r0, #44]	; 0x2c
  152252:	4614      	mov	r4, r2
  152254:	e7ae      	b.n	1521b4 <cbuf_read_unblock+0x2c>
  152256:	bf00      	nop

00152258 <cbuf_initialize>:
{
  152258:	b570      	push	{r4, r5, r6, r14}
  15225a:	4604      	mov	r4, r0
    cbuf_initialize_etc(cbuf, len, malloc(len));
  15225c:	4608      	mov	r0, r1
{
  15225e:	460d      	mov	r5, r1
    cbuf_initialize_etc(cbuf, len, malloc(len));
  152260:	f000 fe16 	bl	152e90 <malloc>
    cbuf->head = 0;
  152264:	2300      	movs	r3, #0
    cbuf->tail = 0;
  152266:	e9c4 3300 	strd	r3, r3, [r4]
    cbuf_initialize_etc(cbuf, len, malloc(len));
  15226a:	4606      	mov	r6, r0
    if (val == 0)
  15226c:	b11d      	cbz	r5, 152276 <cbuf_initialize+0x1e>
    return (sizeof(val) * 8) - 1 - __builtin_clz(val);
  15226e:	fab5 f585 	clz	r5, r5
  152272:	f1c5 051f 	rsb	r5, r5, #31
    event_init(&cbuf->event, false, 0);
  152276:	2200      	movs	r2, #0
  152278:	f104 0010 	add.w	r0, r4, #16
    cbuf->len_pow2 = log2_uint(len);
  15227c:	60a5      	str	r5, [r4, #8]
    event_init(&cbuf->event, false, 0);
  15227e:	4611      	mov	r1, r2
    cbuf->buf = buf;
  152280:	60e6      	str	r6, [r4, #12]
    event_init(&cbuf->event, false, 0);
  152282:	f7fc fee7 	bl	14f054 <event_init>
    *lock = SPIN_LOCK_INITIAL_VALUE;
  152286:	2300      	movs	r3, #0
  152288:	62e3      	str	r3, [r4, #44]	; 0x2c
}
  15228a:	bd70      	pop	{r4, r5, r6, r15}

0015228c <cbuf_space_avail>:
{
  15228c:	b430      	push	{r4, r5}
    return 1U << valp2;
  15228e:	2201      	movs	r2, #1
    return val & ((1UL << modp2) - 1);
  152290:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  152294:	6884      	ldr	r4, [r0, #8]
  152296:	e9d0 3500 	ldrd	r3, r5, [r0]
    return 1U << valp2;
  15229a:	fa02 f004 	lsl.w	r0, r2, r4
  15229e:	1b5b      	subs	r3, r3, r5
    return val & ((1UL << modp2) - 1);
  1522a0:	fa01 f204 	lsl.w	r2, r1, r4
    return valpow2(cbuf->len_pow2) - consumed - 1;
  1522a4:	4408      	add	r0, r1
  1522a6:	ea23 0302 	bic.w	r3, r3, r2
}
  1522aa:	1ac0      	subs	r0, r0, r3
  1522ac:	bc30      	pop	{r4, r5}
  1522ae:	4770      	bx	r14

001522b0 <cbuf_write>:
{
  1522b0:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1522b4:	4605      	mov	r5, r0
  1522b6:	460f      	mov	r7, r1
  1522b8:	4616      	mov	r6, r2
  1522ba:	4699      	mov	r9, r3
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1522bc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1522c0:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1522c2:	bf48      	it	mi
  1522c4:	f04f 0a00 	movmi.w	r10, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1522c8:	d402      	bmi.n	1522d0 <cbuf_write+0x20>
    __asm__ volatile("cpsid i");
  1522ca:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1522cc:	f04f 0a01 	mov.w	r10, #1
  1522d0:	6828      	ldr	r0, [r5, #0]
    *lock = 1;
  1522d2:	2301      	movs	r3, #1
  1522d4:	6869      	ldr	r1, [r5, #4]
  1522d6:	4686      	mov	r14, r0
  1522d8:	62eb      	str	r3, [r5, #44]	; 0x2c
    while (pos < len && cbuf_space_avail(cbuf) > 0) {
  1522da:	2e00      	cmp	r6, #0
  1522dc:	d06b      	beq.n	1523b6 <cbuf_write+0x106>
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  1522de:	f8d5 c008 	ldr.w	r12, [r5, #8]
  1522e2:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  1522e6:	1a42      	subs	r2, r0, r1
  1522e8:	fa08 f40c 	lsl.w	r4, r8, r12
    return 1U << valp2;
  1522ec:	fa03 f30c 	lsl.w	r3, r3, r12
    return val & ((1UL << modp2) - 1);
  1522f0:	ea22 0204 	bic.w	r2, r2, r4
    return valpow2(cbuf->len_pow2) - consumed - 1;
  1522f4:	1a9a      	subs	r2, r3, r2
    while (pos < len && cbuf_space_avail(cbuf) > 0) {
  1522f6:	2a01      	cmp	r2, #1
  1522f8:	d05d      	beq.n	1523b6 <cbuf_write+0x106>
    size_t pos = 0;
  1522fa:	f04f 0c00 	mov.w	r12, #0
        if (cbuf->head >= cbuf->tail) {
  1522fe:	4281      	cmp	r1, r0
  152300:	eba6 040c 	sub.w	r4, r6, r12
  152304:	d84d      	bhi.n	1523a2 <cbuf_write+0xf2>
            if (cbuf->tail == 0) {
  152306:	2900      	cmp	r1, #0
  152308:	d13b      	bne.n	152382 <cbuf_write+0xd2>
                    MIN(valpow2(cbuf->len_pow2) - cbuf->head - 1, len - pos);
  15230a:	3b01      	subs	r3, #1
  15230c:	1a1b      	subs	r3, r3, r0
  15230e:	42a3      	cmp	r3, r4
  152310:	d33a      	bcc.n	152388 <cbuf_write+0xd8>
  152312:	68eb      	ldr	r3, [r5, #12]
  152314:	46b3      	mov	r11, r6
  152316:	4418      	add	r0, r3
        if (NULL == buf) {
  152318:	2f00      	cmp	r7, #0
  15231a:	d03d      	beq.n	152398 <cbuf_write+0xe8>
            memcpy(cbuf->buf + cbuf->head, buf + pos, write_len);
  15231c:	4622      	mov	r2, r4
  15231e:	eb07 010c 	add.w	r1, r7, r12
  152322:	f000 ee26 	blx	152f70 <memcpy>
        cbuf->head = INC_POINTER(cbuf, cbuf->head, write_len);
  152326:	f8d5 c008 	ldr.w	r12, [r5, #8]
    while (pos < len && cbuf_space_avail(cbuf) > 0) {
  15232a:	455e      	cmp	r6, r11
        cbuf->head = INC_POINTER(cbuf, cbuf->head, write_len);
  15232c:	f8d5 e000 	ldr.w	r14, [r5]
  152330:	fa08 f20c 	lsl.w	r2, r8, r12
  152334:	4474      	add	r4, r14
  152336:	6869      	ldr	r1, [r5, #4]
  152338:	ea6f 0202 	mvn.w	r2, r2
  15233c:	ea04 0002 	and.w	r0, r4, r2
  152340:	4686      	mov	r14, r0
  152342:	6028      	str	r0, [r5, #0]
    while (pos < len && cbuf_space_avail(cbuf) > 0) {
  152344:	d908      	bls.n	152358 <cbuf_write+0xa8>
    return 1U << valp2;
  152346:	2301      	movs	r3, #1
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  152348:	1a44      	subs	r4, r0, r1
    return val & ((1UL << modp2) - 1);
  15234a:	4022      	ands	r2, r4
    return 1U << valp2;
  15234c:	fa03 f30c 	lsl.w	r3, r3, r12
  152350:	46dc      	mov	r12, r11
    return valpow2(cbuf->len_pow2) - consumed - 1;
  152352:	1a9a      	subs	r2, r3, r2
    while (pos < len && cbuf_space_avail(cbuf) > 0) {
  152354:	2a01      	cmp	r2, #1
  152356:	d1d2      	bne.n	1522fe <cbuf_write+0x4e>
    if (cbuf->head != cbuf->tail)
  152358:	4288      	cmp	r0, r1
  15235a:	d004      	beq.n	152366 <cbuf_write+0xb6>
        event_signal(&cbuf->event, false);
  15235c:	2100      	movs	r1, #0
  15235e:	f105 0010 	add.w	r0, r5, #16
  152362:	f7fc feb3 	bl	14f0cc <event_signal>
    *lock = 0;
  152366:	2300      	movs	r3, #0
  152368:	62eb      	str	r3, [r5, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15236a:	f1ba 0f00 	cmp.w	r10, #0
  15236e:	d000      	beq.n	152372 <cbuf_write+0xc2>
    __asm__ volatile("cpsie i");
  152370:	b662      	cpsie	i
    if (canreschedule)
  152372:	f1b9 0f00 	cmp.w	r9, #0
  152376:	d001      	beq.n	15237c <cbuf_write+0xcc>
        thread_preempt();
  152378:	f7fd f9f0 	bl	14f75c <thread_preempt>
}
  15237c:	4658      	mov	r0, r11
  15237e:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
                    MIN(valpow2(cbuf->len_pow2) - cbuf->head, len - pos);
  152382:	1a1b      	subs	r3, r3, r0
  152384:	42a3      	cmp	r3, r4
  152386:	d2c4      	bcs.n	152312 <cbuf_write+0x62>
  152388:	461c      	mov	r4, r3
        if (write_len == 0) {
  15238a:	b18c      	cbz	r4, 1523b0 <cbuf_write+0x100>
  15238c:	68eb      	ldr	r3, [r5, #12]
  15238e:	eb04 0b0c 	add.w	r11, r4, r12
  152392:	4418      	add	r0, r3
        if (NULL == buf) {
  152394:	2f00      	cmp	r7, #0
  152396:	d1c1      	bne.n	15231c <cbuf_write+0x6c>
            memset(cbuf->buf + cbuf->head, 0, write_len);
  152398:	4622      	mov	r2, r4
  15239a:	4639      	mov	r1, r7
  15239c:	f000 ee6e 	blx	15307c <memset>
  1523a0:	e7c1      	b.n	152326 <cbuf_write+0x76>
            write_len = MIN(cbuf->tail - cbuf->head - 1, len - pos);
  1523a2:	1e4b      	subs	r3, r1, #1
  1523a4:	1a1b      	subs	r3, r3, r0
  1523a6:	429c      	cmp	r4, r3
  1523a8:	bf28      	it	cs
  1523aa:	461c      	movcs	r4, r3
        if (write_len == 0) {
  1523ac:	2c00      	cmp	r4, #0
  1523ae:	d1ed      	bne.n	15238c <cbuf_write+0xdc>
  1523b0:	4670      	mov	r0, r14
  1523b2:	46e3      	mov	r11, r12
  1523b4:	e7d0      	b.n	152358 <cbuf_write+0xa8>
    size_t pos = 0;
  1523b6:	f04f 0b00 	mov.w	r11, #0
  1523ba:	e7cd      	b.n	152358 <cbuf_write+0xa8>

001523bc <cbuf_read_timeout>:

    return ret;
}

size_t cbuf_read_timeout(cbuf_t *cbuf, void *_buf, size_t buflen, lk_time_t timeout)
{
  1523bc:	b570      	push	{r4, r5, r6, r14}
  1523be:	4604      	mov	r4, r0
  1523c0:	460d      	mov	r5, r1
    status_t ret;

    DEBUG_ASSERT(cbuf);

    ret = event_wait_timeout(&cbuf->event, timeout);
  1523c2:	4619      	mov	r1, r3
  1523c4:	3010      	adds	r0, #16
{
  1523c6:	4616      	mov	r6, r2
    ret = event_wait_timeout(&cbuf->event, timeout);
  1523c8:	f7fc fe5a 	bl	14f080 <event_wait_timeout>
    /* if timeout, do not read anymore */
    if (ret < 0)
  1523cc:	2800      	cmp	r0, #0
  1523ce:	db06      	blt.n	1523de <cbuf_read_timeout+0x22>
        return 0;

    return cbuf_read_unblock(cbuf, _buf, buflen);
  1523d0:	4632      	mov	r2, r6
  1523d2:	4629      	mov	r1, r5
  1523d4:	4620      	mov	r0, r4
}
  1523d6:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
    return cbuf_read_unblock(cbuf, _buf, buflen);
  1523da:	f7ff bed5 	b.w	152188 <cbuf_read_unblock>
}
  1523de:	2000      	movs	r0, #0
  1523e0:	bd70      	pop	{r4, r5, r6, r15}
  1523e2:	bf00      	nop

001523e4 <cbuf_write_char>:
    spin_unlock_irqrestore(&cbuf->lock, state);
    return ret;
}

size_t cbuf_write_char(cbuf_t *cbuf, char c, bool canreschedule)
{
  1523e4:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  1523e6:	4604      	mov	r4, r0
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1523e8:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1523ec:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  1523ee:	bf48      	it	mi
  1523f0:	2700      	movmi	r7, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1523f2:	d401      	bmi.n	1523f8 <cbuf_write_char+0x14>
    __asm__ volatile("cpsid i");
  1523f4:	b672      	cpsid	i
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  1523f6:	2701      	movs	r7, #1
    uint consumed = modpow2((uint)(cbuf->head - cbuf->tail), cbuf->len_pow2);
  1523f8:	6820      	ldr	r0, [r4, #0]
    return val & ((1UL << modp2) - 1);
  1523fa:	f04f 3cff 	mov.w	r12, #4294967295	; 0xffffffff
  1523fe:	68a3      	ldr	r3, [r4, #8]
    *lock = 1;
  152400:	2601      	movs	r6, #1
  152402:	6865      	ldr	r5, [r4, #4]
  152404:	fa0c fe03 	lsl.w	r14, r12, r3
  152408:	1b45      	subs	r5, r0, r5
  15240a:	ea25 050e 	bic.w	r5, r5, r14
    return 1U << valp2;
  15240e:	fa06 f303 	lsl.w	r3, r6, r3
  152412:	62e6      	str	r6, [r4, #44]	; 0x2c
    return valpow2(cbuf->len_pow2) - consumed - 1;
  152414:	1b5b      	subs	r3, r3, r5

    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    size_t ret = 0;
    if (cbuf_space_avail(cbuf) > 0) {
  152416:	42b3      	cmp	r3, r6
    size_t ret = 0;
  152418:	bf08      	it	eq
  15241a:	2000      	moveq	r0, #0
    if (cbuf_space_avail(cbuf) > 0) {
  15241c:	d014      	beq.n	152448 <cbuf_write_char+0x64>
        cbuf->buf[cbuf->head] = c;
  15241e:	68e3      	ldr	r3, [r4, #12]
  152420:	5419      	strb	r1, [r3, r0]

        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  152422:	6820      	ldr	r0, [r4, #0]
    return val & ((1UL << modp2) - 1);
  152424:	68a3      	ldr	r3, [r4, #8]
        ret = 1;

        if (cbuf->head != cbuf->tail)
  152426:	6861      	ldr	r1, [r4, #4]
  152428:	fa0c fc03 	lsl.w	r12, r12, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  15242c:	1983      	adds	r3, r0, r6
  15242e:	ea23 030c 	bic.w	r3, r3, r12
        if (cbuf->head != cbuf->tail)
  152432:	4299      	cmp	r1, r3
        cbuf->head = INC_POINTER(cbuf, cbuf->head, 1);
  152434:	6023      	str	r3, [r4, #0]
        ret = 1;
  152436:	bf08      	it	eq
  152438:	4630      	moveq	r0, r6
        if (cbuf->head != cbuf->tail)
  15243a:	d005      	beq.n	152448 <cbuf_write_char+0x64>
            event_signal(&cbuf->event, canreschedule);
  15243c:	4611      	mov	r1, r2
  15243e:	f104 0010 	add.w	r0, r4, #16
  152442:	f7fc fe43 	bl	14f0cc <event_signal>
        ret = 1;
  152446:	4630      	mov	r0, r6
    *lock = 0;
  152448:	2300      	movs	r3, #0
  15244a:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15244c:	b107      	cbz	r7, 152450 <cbuf_write_char+0x6c>
    __asm__ volatile("cpsie i");
  15244e:	b662      	cpsie	i
    }

    spin_unlock_irqrestore(&cbuf->lock, state);

    return ret;
}
  152450:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  152452:	bf00      	nop

00152454 <cbuf_read_char>:

size_t cbuf_read_char(cbuf_t *cbuf, char *c, bool block)
{
  152454:	b570      	push	{r4, r5, r6, r14}
  152456:	4604      	mov	r4, r0
  152458:	460e      	mov	r6, r1
    DEBUG_ASSERT(cbuf);
    DEBUG_ASSERT(c);

retry:
    if (block)
  15245a:	4615      	mov	r5, r2
  15245c:	bb42      	cbnz	r2, 1524b0 <cbuf_read_char+0x5c>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  15245e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  152462:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  152466:	d12e      	bne.n	1524c6 <cbuf_read_char+0x72>
    __asm__ volatile("cpsid i");
  152468:	b672      	cpsid	i
    spin_lock_saved_state_t state;
    spin_lock_irqsave(&cbuf->lock, state);

    // see if there's data available
    size_t ret = 0;
    if (cbuf->tail != cbuf->head) {
  15246a:	e9d4 0100 	ldrd	r0, r1, [r4]
    *lock = 1;
  15246e:	2201      	movs	r2, #1
  152470:	62e2      	str	r2, [r4, #44]	; 0x2c
  152472:	4281      	cmp	r1, r0
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  152474:	bf18      	it	ne
  152476:	4615      	movne	r5, r2
  152478:	d015      	beq.n	1524a6 <cbuf_read_char+0x52>

        *c = cbuf->buf[cbuf->tail];
  15247a:	68e2      	ldr	r2, [r4, #12]
  15247c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  152480:	5c52      	ldrb	r2, [r2, r1]
  152482:	7032      	strb	r2, [r6, #0]
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  152484:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
  152488:	fa03 f101 	lsl.w	r1, r3, r1
  15248c:	1c53      	adds	r3, r2, #1

        if (cbuf->tail == cbuf->head) {
  15248e:	6822      	ldr	r2, [r4, #0]
  152490:	ea23 0301 	bic.w	r3, r3, r1
        cbuf->tail = INC_POINTER(cbuf, cbuf->tail, 1);
  152494:	6063      	str	r3, [r4, #4]
        if (cbuf->tail == cbuf->head) {
  152496:	429a      	cmp	r2, r3
  152498:	d022      	beq.n	1524e0 <cbuf_read_char+0x8c>
    *lock = 0;
  15249a:	2300      	movs	r3, #0
  15249c:	62e3      	str	r3, [r4, #44]	; 0x2c
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15249e:	b1ed      	cbz	r5, 1524dc <cbuf_read_char+0x88>
    __asm__ volatile("cpsie i");
  1524a0:	b662      	cpsie	i
  1524a2:	2001      	movs	r0, #1

    if (block && ret == 0)
        goto retry;

    return ret;
}
  1524a4:	bd70      	pop	{r4, r5, r6, r15}
    *lock = 0;
  1524a6:	62e3      	str	r3, [r4, #44]	; 0x2c
  1524a8:	b662      	cpsie	i
  1524aa:	4628      	mov	r0, r5
    if (block && ret == 0)
  1524ac:	2d00      	cmp	r5, #0
  1524ae:	d0f9      	beq.n	1524a4 <cbuf_read_char+0x50>
  1524b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1524b4:	f104 0010 	add.w	r0, r4, #16
  1524b8:	f7fc fde2 	bl	14f080 <event_wait_timeout>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  1524bc:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  1524c0:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  1524c4:	d0d0      	beq.n	152468 <cbuf_read_char+0x14>
    if (cbuf->tail != cbuf->head) {
  1524c6:	e9d4 3100 	ldrd	r3, r1, [r4]
    *lock = 1;
  1524ca:	2201      	movs	r2, #1
  1524cc:	62e2      	str	r2, [r4, #44]	; 0x2c
  1524ce:	4299      	cmp	r1, r3
    *lock = 0;
  1524d0:	bf04      	itt	eq
  1524d2:	2300      	moveq	r3, #0
  1524d4:	62e3      	streq	r3, [r4, #44]	; 0x2c
  1524d6:	d0e8      	beq.n	1524aa <cbuf_read_char+0x56>
    spin_lock_saved_state_t state = 0;
  1524d8:	2500      	movs	r5, #0
  1524da:	e7ce      	b.n	15247a <cbuf_read_char+0x26>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  1524dc:	2001      	movs	r0, #1
}
  1524de:	bd70      	pop	{r4, r5, r6, r15}
            event_unsignal(&cbuf->event);
  1524e0:	f104 0010 	add.w	r0, r4, #16
  1524e4:	f7fc fe28 	bl	14f138 <event_unsignal>
  1524e8:	e7d7      	b.n	15249a <cbuf_read_char+0x46>
  1524ea:	bf00      	nop

001524ec <cmd_echo>:
    return cmd_help_impl(CMD_AVAIL_PANIC);
}

static int cmd_echo(int argc, const cmd_args *argv)
{
    if (argc > 1)
  1524ec:	2801      	cmp	r0, #1
        echo = argv[1].b;
  1524ee:	bfc4      	itt	gt
  1524f0:	f891 2024 	ldrbgt.w	r2, [r1, #36]	; 0x24
  1524f4:	f241 0330 	movwgt	r3, #4144	; 0x1030
    return NO_ERROR;
}
  1524f8:	f04f 0000 	mov.w	r0, #0
        echo = argv[1].b;
  1524fc:	bfc4      	itt	gt
  1524fe:	f2c0 0316 	movtgt	r3, #22
  152502:	701a      	strbgt	r2, [r3, #0]
}
  152504:	4770      	bx	r14
  152506:	bf00      	nop

00152508 <cmd_help_impl>:
{
  152508:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
  15250c:	4607      	mov	r7, r0
    printf("command list:\n");
  15250e:	f248 70c4 	movw	r0, #34756	; 0x87c4
  152512:	f2c0 0015 	movt	r0, #21
  152516:	f001 fdef 	bl	1540f8 <_printf>
    for (block = command_list; block != NULL; block = block->next) {
  15251a:	f246 63f8 	movw	r3, #26360	; 0x66f8
  15251e:	f2c0 0316 	movt	r3, #22
  152522:	681e      	ldr	r6, [r3, #0]
  152524:	b1de      	cbz	r6, 15255e <cmd_help_impl+0x56>
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
  152526:	f248 78d4 	movw	r8, #34772	; 0x87d4
  15252a:	f2c0 0815 	movt	r8, #21
        const cmd *curr_cmd = block->list;
  15252e:	e9d6 1401 	ldrd	r1, r4, [r6, #4]
        for (i = 0; i < block->count; i++) {
  152532:	b189      	cbz	r1, 152558 <cmd_help_impl+0x50>
  152534:	2500      	movs	r5, #0
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
  152536:	7b23      	ldrb	r3, [r4, #12]
  152538:	421f      	tst	r7, r3
        for (i = 0; i < block->count; i++) {
  15253a:	f105 0501 	add.w	r5, r5, #1
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
  15253e:	d007      	beq.n	152550 <cmd_help_impl+0x48>
            if (curr_cmd[i].help_str)
  152540:	6863      	ldr	r3, [r4, #4]
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
  152542:	4640      	mov	r0, r8
  152544:	461a      	mov	r2, r3
            if (curr_cmd[i].help_str)
  152546:	b11b      	cbz	r3, 152550 <cmd_help_impl+0x48>
                printf("\t%-16s: %s\n", curr_cmd[i].cmd_str, curr_cmd[i].help_str);
  152548:	6821      	ldr	r1, [r4, #0]
  15254a:	f001 fdd5 	bl	1540f8 <_printf>
  15254e:	6871      	ldr	r1, [r6, #4]
        for (i = 0; i < block->count; i++) {
  152550:	42a9      	cmp	r1, r5
  152552:	f104 0410 	add.w	r4, r4, #16
  152556:	d8ee      	bhi.n	152536 <cmd_help_impl+0x2e>
    for (block = command_list; block != NULL; block = block->next) {
  152558:	6836      	ldr	r6, [r6, #0]
  15255a:	2e00      	cmp	r6, #0
  15255c:	d1e7      	bne.n	15252e <cmd_help_impl+0x26>
}
  15255e:	2000      	movs	r0, #0
  152560:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}

00152564 <cmd_help_panic>:
    return cmd_help_impl(CMD_AVAIL_PANIC);
  152564:	2002      	movs	r0, #2
  152566:	f7ff bfcf 	b.w	152508 <cmd_help_impl>
  15256a:	bf00      	nop

0015256c <cmd_help>:
    return cmd_help_impl(CMD_AVAIL_NORMAL);
  15256c:	2001      	movs	r0, #1
  15256e:	f7ff bfcb 	b.w	152508 <cmd_help_impl>
  152572:	bf00      	nop

00152574 <read_debug_line>:
{
  152574:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
    return ptrprev(history_next);
  152578:	f246 7908 	movw	r9, #26376	; 0x6708
    char *buffer = debug_buffer;
  15257c:	f246 7300 	movw	r3, #26368	; 0x6700
    return ptrprev(history_next);
  152580:	f2c0 0916 	movt	r9, #22
    int escape_level = 0;
  152584:	2600      	movs	r6, #0
    char *buffer = debug_buffer;
  152586:	f2c0 0316 	movt	r3, #22
                        if (echo) {
  15258a:	f241 0730 	movw	r7, #4144	; 0x1030
                            fputs("\b \b", stdout); // wipe out a character
  15258e:	f648 0a10 	movw	r10, #34832	; 0x8810
    return (ptr - 1) % HISTORY_LEN;
  152592:	f8d9 2000 	ldr.w	r2, [r9]
{
  152596:	b083      	sub	sp, #12
    char *buffer = debug_buffer;
  152598:	f8d3 8000 	ldr.w	r8, [r3]
    int pos = 0;
  15259c:	4634      	mov	r4, r6
                            fputs("\b \b", stdout); // wipe out a character
  15259e:	f8df b210 	ldr.w	r11, [r15, #528]	; 1527b0 <read_debug_line+0x23c>
    return (ptr - 1) % HISTORY_LEN;
  1525a2:	3a01      	subs	r2, #1
  1525a4:	f002 020f 	and.w	r2, r2, #15
                        if (echo) {
  1525a8:	f2c0 0716 	movt	r7, #22
{
  1525ac:	9000      	str	r0, [sp, #0]
                            fputs("\b \b", stdout); // wipe out a character
  1525ae:	f2c0 0a15 	movt	r10, #21
    return (ptr - 1) % HISTORY_LEN;
  1525b2:	9201      	str	r2, [sp, #4]
        if ((c = getchar()) < 0)
  1525b4:	f001 fd8c 	bl	1540d0 <getchar>
  1525b8:	1e05      	subs	r5, r0, #0
  1525ba:	dbfb      	blt.n	1525b4 <read_debug_line+0x40>
        if (escape_level == 0) {
  1525bc:	2e00      	cmp	r6, #0
  1525be:	d143      	bne.n	152648 <read_debug_line+0xd4>
            switch (c) {
  1525c0:	2d0d      	cmp	r5, #13
  1525c2:	f000 8085 	beq.w	1526d0 <read_debug_line+0x15c>
  1525c6:	dd09      	ble.n	1525dc <read_debug_line+0x68>
  1525c8:	2d1b      	cmp	r5, #27
  1525ca:	f000 8096 	beq.w	1526fa <read_debug_line+0x186>
  1525ce:	2d7f      	cmp	r5, #127	; 0x7f
  1525d0:	d108      	bne.n	1525e4 <read_debug_line+0x70>
                    if (pos > 0) {
  1525d2:	2c00      	cmp	r4, #0
  1525d4:	f040 80b6 	bne.w	152744 <read_debug_line+0x1d0>
  1525d8:	4626      	mov	r6, r4
  1525da:	e7eb      	b.n	1525b4 <read_debug_line+0x40>
            switch (c) {
  1525dc:	2d08      	cmp	r5, #8
  1525de:	d0f8      	beq.n	1525d2 <read_debug_line+0x5e>
  1525e0:	2d0a      	cmp	r5, #10
  1525e2:	d075      	beq.n	1526d0 <read_debug_line+0x15c>
                    buffer[pos++] = c;
  1525e4:	f808 5004 	strb.w	r5, [r8, r4]
                    if (echo)
  1525e8:	783b      	ldrb	r3, [r7, #0]
                    buffer[pos++] = c;
  1525ea:	3401      	adds	r4, #1
                    if (echo)
  1525ec:	2b00      	cmp	r3, #0
  1525ee:	f040 80b4 	bne.w	15275a <read_debug_line+0x1e6>
        if (pos == (LINE_LEN - 1)) {
  1525f2:	2c7f      	cmp	r4, #127	; 0x7f
  1525f4:	d1de      	bne.n	1525b4 <read_debug_line+0x40>
            fputs("\nerror: line too long\n", stdout);
  1525f6:	f648 0014 	movw	r0, #34836	; 0x8814
  1525fa:	2216      	movs	r2, #22
  1525fc:	4b6c      	ldr	r3, [pc, #432]	; (1527b0 <read_debug_line+0x23c>)
  1525fe:	f2c0 0015 	movt	r0, #21
  152602:	2101      	movs	r1, #1
    char *buffer = debug_buffer;
  152604:	4645      	mov	r5, r8
            fputs("\nerror: line too long\n", stdout);
  152606:	f001 fd4b 	bl	1540a0 <fwrite>
            pos = 0;
  15260a:	2400      	movs	r4, #0
    buffer[pos] = 0;
  15260c:	2300      	movs	r3, #0
  15260e:	702b      	strb	r3, [r5, #0]
    if (line[0] == 0)
  152610:	f898 3000 	ldrb.w	r3, [r8]
  152614:	b18b      	cbz	r3, 15263a <read_debug_line+0xc6>
    return history + line * LINE_LEN;
  152616:	f246 7304 	movw	r3, #26372	; 0x6704
    if (strcmp(line, history_line(last)) == 0)
  15261a:	4640      	mov	r0, r8
    uint last = ptrprev(history_next);
  15261c:	f8d9 6000 	ldr.w	r6, [r9]
    return history + line * LINE_LEN;
  152620:	f2c0 0316 	movt	r3, #22
    return (ptr - 1) % HISTORY_LEN;
  152624:	1e71      	subs	r1, r6, #1
    return history + line * LINE_LEN;
  152626:	681d      	ldr	r5, [r3, #0]
    return (ptr - 1) % HISTORY_LEN;
  152628:	f001 010f 	and.w	r1, r1, #15
    if (strcmp(line, history_line(last)) == 0)
  15262c:	eb05 11c1 	add.w	r1, r5, r1, lsl #7
  152630:	f001 fda4 	bl	15417c <strcmp>
  152634:	2800      	cmp	r0, #0
  152636:	f040 8097 	bne.w	152768 <read_debug_line+0x1f4>
    *outbuffer = buffer;
  15263a:	9b00      	ldr	r3, [sp, #0]
}
  15263c:	4620      	mov	r0, r4
    *outbuffer = buffer;
  15263e:	f8c3 8000 	str.w	r8, [r3]
}
  152642:	b003      	add	sp, #12
  152644:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        } else if (escape_level == 1) {
  152648:	2e01      	cmp	r6, #1
  15264a:	d04e      	beq.n	1526ea <read_debug_line+0x176>
            switch (c) {
  15264c:	f1a5 0341 	sub.w	r3, r5, #65	; 0x41
  152650:	2b03      	cmp	r3, #3
  152652:	f200 80ab 	bhi.w	1527ac <read_debug_line+0x238>
  152656:	e8df f003 	tbb	[r15, r3]
  15265a:	0808      	.short	0x0808
  15265c:	5565      	.short	0x5565
                            fputs("\b \b", stdout); // wipe out a character
  15265e:	465b      	mov	r3, r11
  152660:	2203      	movs	r2, #3
  152662:	2101      	movs	r1, #1
  152664:	4650      	mov	r0, r10
  152666:	f001 fd1b 	bl	1540a0 <fwrite>
                    while (pos > 0) {
  15266a:	b12c      	cbz	r4, 152678 <read_debug_line+0x104>
                        pos--;
  15266c:	3c01      	subs	r4, #1
                        if (echo) {
  15266e:	783b      	ldrb	r3, [r7, #0]
  152670:	2b00      	cmp	r3, #0
  152672:	d1f4      	bne.n	15265e <read_debug_line+0xea>
                    while (pos > 0) {
  152674:	2c00      	cmp	r4, #0
  152676:	d1f9      	bne.n	15266c <read_debug_line+0xf8>
  152678:	f8d9 3000 	ldr.w	r3, [r9]
                    if (c == 65)
  15267c:	2d41      	cmp	r5, #65	; 0x41
  15267e:	f000 8081 	beq.w	152784 <read_debug_line+0x210>
    return (ptr + 1) % HISTORY_LEN;
  152682:	9a01      	ldr	r2, [sp, #4]
  152684:	1c51      	adds	r1, r2, #1
  152686:	f001 010f 	and.w	r1, r1, #15
    if (i == history_next)
  15268a:	4299      	cmp	r1, r3
    return history + line * LINE_LEN;
  15268c:	bf17      	itett	ne
  15268e:	f246 7304 	movwne	r3, #26372	; 0x6704
        return ""; // can't let the cursor hit the head
  152692:	f246 2188 	movweq	r1, #25224	; 0x6288
    return history + line * LINE_LEN;
  152696:	9101      	strne	r1, [sp, #4]
  152698:	f2c0 0316 	movtne	r3, #22
        return ""; // can't let the cursor hit the head
  15269c:	bf0e      	itee	eq
  15269e:	f2c0 0115 	movteq	r1, #21
    return history + line * LINE_LEN;
  1526a2:	681b      	ldrne	r3, [r3, #0]
  1526a4:	eb03 11c1 	addne.w	r1, r3, r1, lsl #7
                        strlcpy(buffer, next_history(&history_cursor), LINE_LEN);
  1526a8:	2280      	movs	r2, #128	; 0x80
  1526aa:	4640      	mov	r0, r8
  1526ac:	f001 fd74 	bl	154198 <strlcpy>
                    pos = strlen(buffer);
  1526b0:	4640      	mov	r0, r8
  1526b2:	f001 fd93 	bl	1541dc <strlen>
                    if (echo)
  1526b6:	783e      	ldrb	r6, [r7, #0]
                    pos = strlen(buffer);
  1526b8:	4604      	mov	r4, r0
                    if (echo)
  1526ba:	2e00      	cmp	r6, #0
  1526bc:	d099      	beq.n	1525f2 <read_debug_line+0x7e>
                        fputs(buffer, stdout);
  1526be:	4659      	mov	r1, r11
  1526c0:	4640      	mov	r0, r8
  1526c2:	f001 fce1 	bl	154088 <fputs>
            escape_level = 0;
  1526c6:	2600      	movs	r6, #0
        if (pos == (LINE_LEN - 1)) {
  1526c8:	2c7f      	cmp	r4, #127	; 0x7f
  1526ca:	f47f af73 	bne.w	1525b4 <read_debug_line+0x40>
  1526ce:	e792      	b.n	1525f6 <read_debug_line+0x82>
                    if (echo)
  1526d0:	f241 0330 	movw	r3, #4144	; 0x1030
  1526d4:	eb08 0504 	add.w	r5, r8, r4
  1526d8:	f2c0 0316 	movt	r3, #22
  1526dc:	781b      	ldrb	r3, [r3, #0]
  1526de:	2b00      	cmp	r3, #0
  1526e0:	d094      	beq.n	15260c <read_debug_line+0x98>
                        putchar('\n');
  1526e2:	200a      	movs	r0, #10
  1526e4:	f001 fcc0 	bl	154068 <putchar>
  1526e8:	e790      	b.n	15260c <read_debug_line+0x98>
                escape_level = 0;
  1526ea:	2d5b      	cmp	r5, #91	; 0x5b
  1526ec:	bf0c      	ite	eq
  1526ee:	2602      	moveq	r6, #2
  1526f0:	2600      	movne	r6, #0
        if (pos == (LINE_LEN - 1)) {
  1526f2:	2c7f      	cmp	r4, #127	; 0x7f
  1526f4:	f47f af5e 	bne.w	1525b4 <read_debug_line+0x40>
  1526f8:	e77d      	b.n	1525f6 <read_debug_line+0x82>
                    escape_level++;
  1526fa:	2601      	movs	r6, #1
        if (pos == (LINE_LEN - 1)) {
  1526fc:	2c7f      	cmp	r4, #127	; 0x7f
  1526fe:	f47f af59 	bne.w	1525b4 <read_debug_line+0x40>
  152702:	e778      	b.n	1525f6 <read_debug_line+0x82>
                    if (pos > 0) {
  152704:	2c00      	cmp	r4, #0
  152706:	f43f af67 	beq.w	1525d8 <read_debug_line+0x64>
                        pos--;
  15270a:	3c01      	subs	r4, #1
                        if (echo) {
  15270c:	783e      	ldrb	r6, [r7, #0]
  15270e:	2e00      	cmp	r6, #0
  152710:	f43f af6f 	beq.w	1525f2 <read_debug_line+0x7e>
                            fputs("\b \b", stdout); // wipe out a character
  152714:	465b      	mov	r3, r11
  152716:	2203      	movs	r2, #3
  152718:	2101      	movs	r1, #1
  15271a:	4650      	mov	r0, r10
  15271c:	f001 fcc0 	bl	1540a0 <fwrite>
            escape_level = 0;
  152720:	2600      	movs	r6, #0
  152722:	e766      	b.n	1525f2 <read_debug_line+0x7e>
                    buffer[pos++] = ' ';
  152724:	2020      	movs	r0, #32
  152726:	1c63      	adds	r3, r4, #1
                    if (echo)
  152728:	783e      	ldrb	r6, [r7, #0]
                    buffer[pos++] = ' ';
  15272a:	f808 0004 	strb.w	r0, [r8, r4]
  15272e:	461c      	mov	r4, r3
                    if (echo)
  152730:	2e00      	cmp	r6, #0
  152732:	f43f af5e 	beq.w	1525f2 <read_debug_line+0x7e>
                        putchar(' ');
  152736:	f001 fc97 	bl	154068 <putchar>
            escape_level = 0;
  15273a:	2600      	movs	r6, #0
        if (pos == (LINE_LEN - 1)) {
  15273c:	2c7f      	cmp	r4, #127	; 0x7f
  15273e:	f47f af39 	bne.w	1525b4 <read_debug_line+0x40>
  152742:	e758      	b.n	1525f6 <read_debug_line+0x82>
                        fputs("\b \b", stdout); // wipe out a character
  152744:	465b      	mov	r3, r11
  152746:	2203      	movs	r2, #3
  152748:	2101      	movs	r1, #1
  15274a:	4650      	mov	r0, r10
                        pos--;
  15274c:	3c01      	subs	r4, #1
                        fputs("\b \b", stdout); // wipe out a character
  15274e:	f001 fca7 	bl	1540a0 <fwrite>
        if (pos == (LINE_LEN - 1)) {
  152752:	2c7f      	cmp	r4, #127	; 0x7f
  152754:	f47f af2e 	bne.w	1525b4 <read_debug_line+0x40>
  152758:	e74d      	b.n	1525f6 <read_debug_line+0x82>
                        putchar(c);
  15275a:	4628      	mov	r0, r5
  15275c:	f001 fc84 	bl	154068 <putchar>
        if (pos == (LINE_LEN - 1)) {
  152760:	2c7f      	cmp	r4, #127	; 0x7f
  152762:	f47f af27 	bne.w	1525b4 <read_debug_line+0x40>
  152766:	e746      	b.n	1525f6 <read_debug_line+0x82>
    strlcpy(history_line(history_next), line, LINE_LEN);
  152768:	2280      	movs	r2, #128	; 0x80
  15276a:	eb05 10c6 	add.w	r0, r5, r6, lsl #7
  15276e:	4641      	mov	r1, r8
  152770:	f001 fd12 	bl	154198 <strlcpy>
    return (ptr + 1) % HISTORY_LEN;
  152774:	f8d9 3000 	ldr.w	r3, [r9]
  152778:	3301      	adds	r3, #1
  15277a:	f003 030f 	and.w	r3, r3, #15
    history_next = ptrnext(history_next);
  15277e:	f8c9 3000 	str.w	r3, [r9]
  152782:	e75a      	b.n	15263a <read_debug_line+0xc6>
    return history + line * LINE_LEN;
  152784:	9c01      	ldr	r4, [sp, #4]
  152786:	f246 7204 	movw	r2, #26372	; 0x6704
  15278a:	f2c0 0216 	movt	r2, #22
    if (*cursor == history_next)
  15278e:	429c      	cmp	r4, r3
    return history + line * LINE_LEN;
  152790:	6812      	ldr	r2, [r2, #0]
  152792:	eb02 11c4 	add.w	r1, r2, r4, lsl #7
    if (*cursor == history_next)
  152796:	d087      	beq.n	1526a8 <read_debug_line+0x134>
    return (ptr - 1) % HISTORY_LEN;
  152798:	1e63      	subs	r3, r4, #1
  15279a:	f003 030f 	and.w	r3, r3, #15
    if (history_line(i)[0] == '\0')
  15279e:	01d8      	lsls	r0, r3, #7
  1527a0:	5c12      	ldrb	r2, [r2, r0]
    *cursor = i;
  1527a2:	2a00      	cmp	r2, #0
  1527a4:	bf18      	it	ne
  1527a6:	461c      	movne	r4, r3
  1527a8:	9401      	str	r4, [sp, #4]
  1527aa:	e77d      	b.n	1526a8 <read_debug_line+0x134>
            escape_level = 0;
  1527ac:	2600      	movs	r6, #0
  1527ae:	e720      	b.n	1525f2 <read_debug_line+0x7e>
  1527b0:	00161040 	.word	0x00161040

001527b4 <match_command>:
    for (block = command_list; block != NULL; block = block->next) {
  1527b4:	f246 63f8 	movw	r3, #26360	; 0x66f8
  1527b8:	f2c0 0316 	movt	r3, #22
{
  1527bc:	e92d 47f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r14}
    for (block = command_list; block != NULL; block = block->next) {
  1527c0:	f8d3 9000 	ldr.w	r9, [r3]
  1527c4:	f1b9 0f00 	cmp.w	r9, #0
  1527c8:	d019      	beq.n	1527fe <match_command+0x4a>
  1527ca:	4680      	mov	r8, r0
  1527cc:	460f      	mov	r7, r1
        const cmd *curr_cmd = block->list;
  1527ce:	e9d9 6401 	ldrd	r6, r4, [r9, #4]
        for (i = 0; i < block->count; i++) {
  1527d2:	b17e      	cbz	r6, 1527f4 <match_command+0x40>
  1527d4:	2500      	movs	r5, #0
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
  1527d6:	7b23      	ldrb	r3, [r4, #12]
            if (strcmp(command, curr_cmd[i].cmd_str) == 0) {
  1527d8:	4640      	mov	r0, r8
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
  1527da:	421f      	tst	r7, r3
  1527dc:	46a2      	mov	r10, r4
        for (i = 0; i < block->count; i++) {
  1527de:	f105 0501 	add.w	r5, r5, #1
            if ((availability_mask & curr_cmd[i].availability_mask) == 0) {
  1527e2:	d003      	beq.n	1527ec <match_command+0x38>
            if (strcmp(command, curr_cmd[i].cmd_str) == 0) {
  1527e4:	6821      	ldr	r1, [r4, #0]
  1527e6:	f001 fcc9 	bl	15417c <strcmp>
  1527ea:	b148      	cbz	r0, 152800 <match_command+0x4c>
        for (i = 0; i < block->count; i++) {
  1527ec:	42b5      	cmp	r5, r6
  1527ee:	f104 0410 	add.w	r4, r4, #16
  1527f2:	d1f0      	bne.n	1527d6 <match_command+0x22>
    for (block = command_list; block != NULL; block = block->next) {
  1527f4:	f8d9 9000 	ldr.w	r9, [r9]
  1527f8:	f1b9 0f00 	cmp.w	r9, #0
  1527fc:	d1e7      	bne.n	1527ce <match_command+0x1a>
    return NULL;
  1527fe:	46ca      	mov	r10, r9
}
  152800:	4650      	mov	r0, r10
  152802:	e8bd 87f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r15}
  152806:	bf00      	nop

00152808 <convert_args>:
    for (i = 0; i < argc; i++) {
  152808:	2800      	cmp	r0, #0
  15280a:	dd44      	ble.n	152896 <convert_args+0x8e>
  15280c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
{
  152810:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
  152814:	f248 77f8 	movw	r7, #34808	; 0x87f8
  152818:	f648 0600 	movw	r6, #34816	; 0x8800
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
  15281c:	f648 0804 	movw	r8, #34820	; 0x8804
  152820:	460c      	mov	r4, r1
  152822:	eb01 0980 	add.w	r9, r1, r0, lsl #2
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
  152826:	f2c0 0715 	movt	r7, #21
  15282a:	f2c0 0615 	movt	r6, #21
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
  15282e:	f2c0 0815 	movt	r8, #21
        unsigned long u = atoul(argv[i].str);
  152832:	6820      	ldr	r0, [r4, #0]
  152834:	f000 fcca 	bl	1531cc <atoul>
  152838:	4603      	mov	r3, r0
        argv[i].i = atol(argv[i].str);
  15283a:	6820      	ldr	r0, [r4, #0]
        argv[i].p = (void *)u;
  15283c:	e9c4 3301 	strd	r3, r3, [r4, #4]
        argv[i].i = atol(argv[i].str);
  152840:	f000 fc7a 	bl	153138 <atol>
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
  152844:	6825      	ldr	r5, [r4, #0]
  152846:	4639      	mov	r1, r7
        argv[i].i = atol(argv[i].str);
  152848:	60e0      	str	r0, [r4, #12]
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
  15284a:	4628      	mov	r0, r5
  15284c:	f001 fc96 	bl	15417c <strcmp>
  152850:	4631      	mov	r1, r6
  152852:	b1b8      	cbz	r0, 152884 <convert_args+0x7c>
  152854:	4628      	mov	r0, r5
  152856:	f001 fc91 	bl	15417c <strcmp>
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
  15285a:	4641      	mov	r1, r8
        if (!strcmp(argv[i].str, "true") || !strcmp(argv[i].str, "on")) {
  15285c:	b190      	cbz	r0, 152884 <convert_args+0x7c>
        } else if (!strcmp(argv[i].str, "false") || !strcmp(argv[i].str, "off")) {
  15285e:	4628      	mov	r0, r5
  152860:	f001 fc8c 	bl	15417c <strcmp>
  152864:	f648 010c 	movw	r1, #34828	; 0x880c
  152868:	f2c0 0115 	movt	r1, #21
  15286c:	b118      	cbz	r0, 152876 <convert_args+0x6e>
  15286e:	4628      	mov	r0, r5
  152870:	f001 fc84 	bl	15417c <strcmp>
  152874:	b948      	cbnz	r0, 15288a <convert_args+0x82>
            argv[i].b = false;
  152876:	2300      	movs	r3, #0
  152878:	7423      	strb	r3, [r4, #16]
  15287a:	3414      	adds	r4, #20
    for (i = 0; i < argc; i++) {
  15287c:	454c      	cmp	r4, r9
  15287e:	d1d8      	bne.n	152832 <convert_args+0x2a>
}
  152880:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
            argv[i].b = true;
  152884:	2301      	movs	r3, #1
  152886:	7423      	strb	r3, [r4, #16]
  152888:	e7f7      	b.n	15287a <convert_args+0x72>
            argv[i].b = (argv[i].u == 0) ? false : true;
  15288a:	6863      	ldr	r3, [r4, #4]
  15288c:	3300      	adds	r3, #0
  15288e:	bf18      	it	ne
  152890:	2301      	movne	r3, #1
  152892:	7423      	strb	r3, [r4, #16]
  152894:	e7f1      	b.n	15287a <convert_args+0x72>
  152896:	4770      	bx	r14

00152898 <command_loop>:
{
  152898:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  15289c:	b08b      	sub	sp, #44	; 0x2c
  15289e:	9005      	str	r0, [sp, #20]
    args = (cmd_args *) malloc (MAX_NUM_ARGS * sizeof(cmd_args));
  1528a0:	f44f 70a0 	mov.w	r0, #320	; 0x140
{
  1528a4:	9106      	str	r1, [sp, #24]
  1528a6:	9204      	str	r2, [sp, #16]
  1528a8:	9302      	str	r3, [sp, #8]
    args = (cmd_args *) malloc (MAX_NUM_ARGS * sizeof(cmd_args));
  1528aa:	f000 faf1 	bl	152e90 <malloc>
    if (unlikely(args == NULL)) {
  1528ae:	2800      	cmp	r0, #0
  1528b0:	f000 816e 	beq.w	152b90 <command_loop+0x2f8>
  1528b4:	4680      	mov	r8, r0
    outbuf = malloc(outbuflen);
  1528b6:	f44f 6080 	mov.w	r0, #1024	; 0x400
  1528ba:	f000 fae9 	bl	152e90 <malloc>
    if (unlikely(outbuf == NULL)) {
  1528be:	4607      	mov	r7, r0
  1528c0:	2800      	cmp	r0, #0
  1528c2:	f000 8162 	beq.w	152b8a <command_loop+0x2f2>
                fputs("] ", stdout);
  1528c6:	f248 73e0 	movw	r3, #34784	; 0x87e0
        abort_script = false;
  1528ca:	f246 62f4 	movw	r2, #26356	; 0x66f4
    continuebuffer = NULL;
  1528ce:	f04f 0a00 	mov.w	r10, #0
                fputs("] ", stdout);
  1528d2:	f2c0 0315 	movt	r3, #21
    continuebuffer = NULL;
  1528d6:	46d3      	mov	r11, r10
        abort_script = false;
  1528d8:	f2c0 0216 	movt	r2, #22
                fputs("] ", stdout);
  1528dc:	9307      	str	r3, [sp, #28]
        abort_script = false;
  1528de:	9203      	str	r2, [sp, #12]
    continuebuffer = NULL;
  1528e0:	f8cd 8000 	str.w	r8, [r13]
        if (continuebuffer == NULL) {
  1528e4:	f1bb 0f00 	cmp.w	r11, #0
  1528e8:	f000 8082 	beq.w	1529f0 <command_loop+0x158>
            buffer = continuebuffer;
  1528ec:	f8cd b024 	str.w	r11, [r13, #36]	; 0x24
    outpos = 0;
  1528f0:	2500      	movs	r5, #0
    continuebuffer = NULL;
  1528f2:	4639      	mov	r1, r7
    arg = 0;
  1528f4:	462e      	mov	r6, r5
    inpos = 0;
  1528f6:	462c      	mov	r4, r5
                    buffer[outpos] = 0;
  1528f8:	46a9      	mov	r9, r5
  1528fa:	46b8      	mov	r8, r7
  1528fc:	f89b a000 	ldrb.w	r10, [r11]
                if (c == '\0')
  152900:	f1ba 0f00 	cmp.w	r10, #0
  152904:	d03c      	beq.n	152980 <command_loop+0xe8>
                if (isspace(c))
  152906:	4650      	mov	r0, r10
  152908:	eb08 0705 	add.w	r7, r8, r5
  15290c:	f000 fc94 	bl	153238 <isspace>
  152910:	2800      	cmp	r0, #0
  152912:	d13e      	bne.n	152992 <command_loop+0xfa>
                else if (c == ';')
  152914:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
  152918:	f000 80fb 	beq.w	152b12 <command_loop+0x27a>
                if (c == '"') {
  15291c:	f1ba 0f22 	cmp.w	r10, #34	; 0x22
        char c = inbuffer[inpos];
  152920:	eb0b 0004 	add.w	r0, r11, r4
  152924:	eb08 0705 	add.w	r7, r8, r5
                args[arg].str = &buffer[outpos];
  152928:	eb06 0286 	add.w	r2, r6, r6, lsl #2
                if (c == '"') {
  15292c:	d041      	beq.n	1529b2 <command_loop+0x11a>
                } else if (c == '$') {
  15292e:	f1ba 0f24 	cmp.w	r10, #36	; 0x24
  152932:	d06c      	beq.n	152a0e <command_loop+0x176>
                    args[arg].str = &buffer[outpos];
  152934:	9b00      	ldr	r3, [sp, #0]
  152936:	46ba      	mov	r10, r7
  152938:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  15293c:	7807      	ldrb	r7, [r0, #0]
        char c = inbuffer[inpos];
  15293e:	9001      	str	r0, [sp, #4]
                if (isspace(c) || c == ';') {
  152940:	4638      	mov	r0, r7
                if (c == '\0') {
  152942:	2f00      	cmp	r7, #0
  152944:	d04d      	beq.n	1529e2 <command_loop+0x14a>
                if (isspace(c) || c == ';') {
  152946:	f000 fc77 	bl	153238 <isspace>
  15294a:	f1a7 033b 	sub.w	r3, r7, #59	; 0x3b
  15294e:	fab3 f383 	clz	r3, r3
  152952:	3501      	adds	r5, #1
  152954:	095b      	lsrs	r3, r3, #5
  152956:	2800      	cmp	r0, #0
  152958:	bf0c      	ite	eq
  15295a:	4618      	moveq	r0, r3
  15295c:	2001      	movne	r0, #1
  15295e:	2800      	cmp	r0, #0
  152960:	f000 80cc 	beq.w	152afc <command_loop+0x264>
                    buffer[outpos] = 0;
  152964:	f88a 9000 	strb.w	r9, [r10]
                    arg++;
  152968:	3601      	adds	r6, #1
                    if (arg == arg_count)
  15296a:	2e10      	cmp	r6, #16
  15296c:	f000 8115 	beq.w	152b9a <command_loop+0x302>
  152970:	9b01      	ldr	r3, [sp, #4]
  152972:	eb08 0105 	add.w	r1, r8, r5
  152976:	f893 a000 	ldrb.w	r10, [r3]
                if (c == '\0')
  15297a:	f1ba 0f00 	cmp.w	r10, #0
  15297e:	d1c2      	bne.n	152906 <command_loop+0x6e>
  152980:	4647      	mov	r7, r8
    *continuebuffer = NULL;
  152982:	46d3      	mov	r11, r10
  152984:	e07a      	b.n	152a7c <command_loop+0x1e4>
                    inpos++; // consume the space
  152986:	3401      	adds	r4, #1
  152988:	f81b a004 	ldrb.w	r10, [r11, r4]
                if (c == '\0')
  15298c:	f1ba 0f00 	cmp.w	r10, #0
  152990:	d0f6      	beq.n	152980 <command_loop+0xe8>
                } else if (!isspace(c)) {
  152992:	4650      	mov	r0, r10
                if (c == ';') {
  152994:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
  152998:	d06b      	beq.n	152a72 <command_loop+0x1da>
                } else if (!isspace(c)) {
  15299a:	f000 fc4d 	bl	153238 <isspace>
  15299e:	4639      	mov	r1, r7
  1529a0:	2800      	cmp	r0, #0
  1529a2:	d1f0      	bne.n	152986 <command_loop+0xee>
                if (c == '"') {
  1529a4:	f1ba 0f22 	cmp.w	r10, #34	; 0x22
        char c = inbuffer[inpos];
  1529a8:	eb0b 0004 	add.w	r0, r11, r4
                args[arg].str = &buffer[outpos];
  1529ac:	eb06 0286 	add.w	r2, r6, r6, lsl #2
                if (c == '"') {
  1529b0:	d1bd      	bne.n	15292e <command_loop+0x96>
                args[arg].str = &buffer[outpos];
  1529b2:	9b00      	ldr	r3, [sp, #0]
                inpos++; // consume the quote
  1529b4:	3401      	adds	r4, #1
                args[arg].str = &buffer[outpos];
  1529b6:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  1529ba:	46ba      	mov	r10, r7
  1529bc:	f81b 2004 	ldrb.w	r2, [r11, r4]
  1529c0:	1c6b      	adds	r3, r5, #1
                if (c == '\0') {
  1529c2:	b172      	cbz	r2, 1529e2 <command_loop+0x14a>
                if (c == '"') {
  1529c4:	2a22      	cmp	r2, #34	; 0x22
  1529c6:	eb08 0c03 	add.w	r12, r8, r3
  1529ca:	f000 8089 	beq.w	152ae0 <command_loop+0x248>
  1529ce:	461d      	mov	r5, r3
                inpos++;
  1529d0:	3401      	adds	r4, #1
                buffer[outpos] = c;
  1529d2:	f88a 2000 	strb.w	r2, [r10]
  1529d6:	1c6b      	adds	r3, r5, #1
                inpos++;
  1529d8:	46e2      	mov	r10, r12
  1529da:	f81b 2004 	ldrb.w	r2, [r11, r4]
                if (c == '\0') {
  1529de:	2a00      	cmp	r2, #0
  1529e0:	d1f0      	bne.n	1529c4 <command_loop+0x12c>
    buffer[outpos] = 0;
  1529e2:	2200      	movs	r2, #0
  1529e4:	4647      	mov	r7, r8
  1529e6:	4693      	mov	r11, r2
                    arg++;
  1529e8:	3601      	adds	r6, #1
    buffer[outpos] = 0;
  1529ea:	f88a 2000 	strb.w	r2, [r10]
  1529ee:	e04a      	b.n	152a86 <command_loop+0x1ee>
            if (showprompt)
  1529f0:	9b04      	ldr	r3, [sp, #16]
  1529f2:	2b00      	cmp	r3, #0
  1529f4:	f040 8096 	bne.w	152b24 <command_loop+0x28c>
            int len = get_line(&buffer, get_line_cookie);
  1529f8:	9906      	ldr	r1, [sp, #24]
  1529fa:	a809      	add	r0, sp, #36	; 0x24
  1529fc:	9b05      	ldr	r3, [sp, #20]
  1529fe:	4798      	blx	r3
            if (len < 0)
  152a00:	2800      	cmp	r0, #0
  152a02:	f2c0 80d3 	blt.w	152bac <command_loop+0x314>
            if (len == 0)
  152a06:	d0f3      	beq.n	1529f0 <command_loop+0x158>
  152a08:	f8dd b024 	ldr.w	r11, [r13, #36]	; 0x24
  152a0c:	e770      	b.n	1528f0 <command_loop+0x58>
                args[arg].str = &buffer[outpos];
  152a0e:	9b00      	ldr	r3, [sp, #0]
                inpos++; // consume the dollar sign
  152a10:	3401      	adds	r4, #1
                args[arg].str = &buffer[outpos];
  152a12:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  152a16:	eb0b 0204 	add.w	r2, r11, r4
  152a1a:	463b      	mov	r3, r7
  152a1c:	462f      	mov	r7, r5
  152a1e:	4615      	mov	r5, r2
  152a20:	f81b a004 	ldrb.w	r10, [r11, r4]
                if (c == '\0' || isspace(c) || c == ';') {
  152a24:	4650      	mov	r0, r10
  152a26:	f1ba 0f00 	cmp.w	r10, #0
  152a2a:	d00d      	beq.n	152a48 <command_loop+0x1b0>
  152a2c:	9301      	str	r3, [sp, #4]
  152a2e:	f000 fc03 	bl	153238 <isspace>
  152a32:	9b01      	ldr	r3, [sp, #4]
  152a34:	3000      	adds	r0, #0
  152a36:	bf18      	it	ne
  152a38:	2001      	movne	r0, #1
  152a3a:	f1ba 0f3b 	cmp.w	r10, #59	; 0x3b
  152a3e:	bf08      	it	eq
  152a40:	f040 0001 	orreq.w	r0, r0, #1
  152a44:	2800      	cmp	r0, #0
  152a46:	d067      	beq.n	152b18 <command_loop+0x280>
  152a48:	462a      	mov	r2, r5
                    arg++;
  152a4a:	3601      	adds	r6, #1
  152a4c:	463d      	mov	r5, r7
                    if (arg == arg_count)
  152a4e:	2e10      	cmp	r6, #16
  152a50:	461f      	mov	r7, r3
                        buffer[outpos++] = '0';
  152a52:	f105 0101 	add.w	r1, r5, #1
  152a56:	f04f 0330 	mov.w	r3, #48	; 0x30
                        buffer[outpos++] = 0;
  152a5a:	f105 0502 	add.w	r5, r5, #2
                        buffer[outpos++] = '0';
  152a5e:	703b      	strb	r3, [r7, #0]
                        buffer[outpos++] = 0;
  152a60:	f808 9001 	strb.w	r9, [r8, r1]
                    if (arg == arg_count)
  152a64:	f000 8099 	beq.w	152b9a <command_loop+0x302>
  152a68:	f892 a000 	ldrb.w	r10, [r2]
  152a6c:	eb08 0105 	add.w	r1, r8, r5
  152a70:	e746      	b.n	152900 <command_loop+0x68>
  152a72:	463a      	mov	r2, r7
  152a74:	4647      	mov	r7, r8
  152a76:	4611      	mov	r1, r2
                inpos++; // consume the ';'
  152a78:	3401      	adds	r4, #1
                *continuebuffer = &inbuffer[inpos];
  152a7a:	44a3      	add	r11, r4
    buffer[outpos] = 0;
  152a7c:	2200      	movs	r2, #0
  152a7e:	700a      	strb	r2, [r1, #0]
        } else if (argc == 0) {
  152a80:	2e00      	cmp	r6, #0
  152a82:	f43f af2f 	beq.w	1528e4 <command_loop+0x4c>
        convert_args(argc, args);
  152a86:	9c00      	ldr	r4, [sp, #0]
  152a88:	4630      	mov	r0, r6
  152a8a:	4621      	mov	r1, r4
  152a8c:	f7ff febc 	bl	152808 <convert_args>
        const cmd *command = match_command(args[0].str, CMD_AVAIL_NORMAL);
  152a90:	2101      	movs	r1, #1
  152a92:	6820      	ldr	r0, [r4, #0]
  152a94:	f7ff fe8e 	bl	1527b4 <match_command>
        if (!command) {
  152a98:	4604      	mov	r4, r0
  152a9a:	2800      	cmp	r0, #0
  152a9c:	d06a      	beq.n	152b74 <command_loop+0x2dc>
        if (!locked)
  152a9e:	9b02      	ldr	r3, [sp, #8]
  152aa0:	2b00      	cmp	r3, #0
  152aa2:	d046      	beq.n	152b32 <command_loop+0x29a>
        lastresult = command->cmd_callback(argc, args);
  152aa4:	f8dd 8000 	ldr.w	r8, [r13]
        abort_script = false;
  152aa8:	2500      	movs	r5, #0
        lastresult = command->cmd_callback(argc, args);
  152aaa:	68a2      	ldr	r2, [r4, #8]
  152aac:	4641      	mov	r1, r8
        abort_script = false;
  152aae:	9c03      	ldr	r4, [sp, #12]
        lastresult = command->cmd_callback(argc, args);
  152ab0:	4630      	mov	r0, r6
        abort_script = false;
  152ab2:	7025      	strb	r5, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
  152ab4:	4790      	blx	r2
  152ab6:	f246 720c 	movw	r2, #26380	; 0x670c
        if (abort_script)
  152aba:	7821      	ldrb	r1, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
  152abc:	f2c0 0216 	movt	r2, #22
  152ac0:	6010      	str	r0, [r2, #0]
        if (abort_script)
  152ac2:	2900      	cmp	r1, #0
  152ac4:	f43f af0e 	beq.w	1528e4 <command_loop+0x4c>
        abort_script = false;
  152ac8:	9b03      	ldr	r3, [sp, #12]
  152aca:	701d      	strb	r5, [r3, #0]
    free(outbuf);
  152acc:	4638      	mov	r0, r7
  152ace:	f000 fa15 	bl	152efc <free>
    free(args);
  152ad2:	4640      	mov	r0, r8
  152ad4:	f000 fa12 	bl	152efc <free>
    return NO_ERROR;
  152ad8:	2000      	movs	r0, #0
}
  152ada:	b00b      	add	sp, #44	; 0x2c
  152adc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                    buffer[outpos] = 0;
  152ae0:	f88a 9000 	strb.w	r9, [r10]
                    arg++;
  152ae4:	3601      	adds	r6, #1
                    if (arg == arg_count)
  152ae6:	2e10      	cmp	r6, #16
  152ae8:	d063      	beq.n	152bb2 <command_loop+0x31a>
                buffer[outpos] = c;
  152aea:	f88c 2000 	strb.w	r2, [r12]
  152aee:	3502      	adds	r5, #2
                inpos++;
  152af0:	3401      	adds	r4, #1
  152af2:	f81b a004 	ldrb.w	r10, [r11, r4]
  152af6:	eb08 0105 	add.w	r1, r8, r5
  152afa:	e701      	b.n	152900 <command_loop+0x68>
                    buffer[outpos] = c;
  152afc:	f88a 7000 	strb.w	r7, [r10]
                    inpos++;
  152b00:	3401      	adds	r4, #1
  152b02:	eb0b 0304 	add.w	r3, r11, r4
  152b06:	f81b 7004 	ldrb.w	r7, [r11, r4]
  152b0a:	eb08 0a05 	add.w	r10, r8, r5
  152b0e:	9301      	str	r3, [sp, #4]
  152b10:	e716      	b.n	152940 <command_loop+0xa8>
  152b12:	4647      	mov	r7, r8
  152b14:	1979      	adds	r1, r7, r5
  152b16:	e7af      	b.n	152a78 <command_loop+0x1e0>
                    inpos++;
  152b18:	3401      	adds	r4, #1
  152b1a:	f81b a004 	ldrb.w	r10, [r11, r4]
  152b1e:	eb0b 0504 	add.w	r5, r11, r4
  152b22:	e77f      	b.n	152a24 <command_loop+0x18c>
                fputs("] ", stdout);
  152b24:	4b24      	ldr	r3, [pc, #144]	; (152bb8 <command_loop+0x320>)
  152b26:	2202      	movs	r2, #2
  152b28:	9807      	ldr	r0, [sp, #28]
  152b2a:	2101      	movs	r1, #1
  152b2c:	f001 fab8 	bl	1540a0 <fwrite>
  152b30:	e762      	b.n	1529f8 <command_loop+0x160>
            mutex_acquire(command_lock);
  152b32:	f246 65fc 	movw	r5, #26364	; 0x66fc
  152b36:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  152b3a:	f2c0 0516 	movt	r5, #22
  152b3e:	6828      	ldr	r0, [r5, #0]
  152b40:	f7fc fb44 	bl	14f1cc <mutex_acquire_timeout>
        lastresult = command->cmd_callback(argc, args);
  152b44:	f8dd 8000 	ldr.w	r8, [r13]
  152b48:	68a2      	ldr	r2, [r4, #8]
  152b4a:	4630      	mov	r0, r6
        abort_script = false;
  152b4c:	9c03      	ldr	r4, [sp, #12]
        lastresult = command->cmd_callback(argc, args);
  152b4e:	4641      	mov	r1, r8
        abort_script = false;
  152b50:	9e02      	ldr	r6, [sp, #8]
  152b52:	7026      	strb	r6, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
  152b54:	4790      	blx	r2
  152b56:	f246 720c 	movw	r2, #26380	; 0x670c
        if (abort_script)
  152b5a:	7821      	ldrb	r1, [r4, #0]
        lastresult = command->cmd_callback(argc, args);
  152b5c:	f2c0 0216 	movt	r2, #22
  152b60:	6010      	str	r0, [r2, #0]
            mutex_release(command_lock);
  152b62:	6828      	ldr	r0, [r5, #0]
        if (abort_script)
  152b64:	b119      	cbz	r1, 152b6e <command_loop+0x2d6>
        abort_script = false;
  152b66:	7026      	strb	r6, [r4, #0]
            mutex_release(command_lock);
  152b68:	f7fc fb5c 	bl	14f224 <mutex_release>
  152b6c:	e7ae      	b.n	152acc <command_loop+0x234>
  152b6e:	f7fc fb59 	bl	14f224 <mutex_release>
  152b72:	e6b7      	b.n	1528e4 <command_loop+0x4c>
            if (showprompt)
  152b74:	9b04      	ldr	r3, [sp, #16]
  152b76:	2b00      	cmp	r3, #0
  152b78:	f43f aeb4 	beq.w	1528e4 <command_loop+0x4c>
                printf("command not found\n");
  152b7c:	f248 70e4 	movw	r0, #34788	; 0x87e4
  152b80:	f2c0 0015 	movt	r0, #21
  152b84:	f001 fab8 	bl	1540f8 <_printf>
  152b88:	e6ac      	b.n	1528e4 <command_loop+0x4c>
        free(args);
  152b8a:	4640      	mov	r0, r8
  152b8c:	f000 f9b6 	bl	152efc <free>
    return ERR_NO_MEMORY;
  152b90:	f06f 0004 	mvn.w	r0, #4
}
  152b94:	b00b      	add	sp, #44	; 0x2c
  152b96:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  152b9a:	4647      	mov	r7, r8
  152b9c:	eb08 0c05 	add.w	r12, r8, r5
    buffer[outpos] = 0;
  152ba0:	2300      	movs	r3, #0
  152ba2:	2610      	movs	r6, #16
  152ba4:	469b      	mov	r11, r3
  152ba6:	f88c 3000 	strb.w	r3, [r12]
  152baa:	e76c      	b.n	152a86 <command_loop+0x1ee>
  152bac:	f8dd 8000 	ldr.w	r8, [r13]
  152bb0:	e78c      	b.n	152acc <command_loop+0x234>
  152bb2:	4647      	mov	r7, r8
  152bb4:	e7f4      	b.n	152ba0 <command_loop+0x308>
  152bb6:	bf00      	nop
  152bb8:	00161040 	.word	0x00161040

00152bbc <console_init>:
{
  152bbc:	b570      	push	{r4, r5, r6, r14}
    command_lock = calloc(sizeof(mutex_t), 1);
  152bbe:	2101      	movs	r1, #1
  152bc0:	201c      	movs	r0, #28
  152bc2:	f000 f97b 	bl	152ebc <calloc>
  152bc6:	f246 63fc 	movw	r3, #26364	; 0x66fc
    for (block = __commands_start; block != __commands_end; block++) {
  152bca:	f241 0458 	movw	r4, #4184	; 0x1058
    command_lock = calloc(sizeof(mutex_t), 1);
  152bce:	f2c0 0316 	movt	r3, #22
    for (block = __commands_start; block != __commands_end; block++) {
  152bd2:	f2c0 0416 	movt	r4, #22
    command_lock = calloc(sizeof(mutex_t), 1);
  152bd6:	6018      	str	r0, [r3, #0]
    mutex_init(command_lock);
  152bd8:	f7fc fabe 	bl	14f158 <mutex_init>
    for (block = __commands_start; block != __commands_end; block++) {
  152bdc:	f241 03e8 	movw	r3, #4328	; 0x10e8
  152be0:	f2c0 0316 	movt	r3, #22
  152be4:	429c      	cmp	r4, r3
  152be6:	d027      	beq.n	152c38 <console_init+0x7c>
  152be8:	f246 65f8 	movw	r5, #26360	; 0x66f8
  152bec:	f104 020c 	add.w	r2, r4, #12
  152bf0:	1a9b      	subs	r3, r3, r2
  152bf2:	4622      	mov	r2, r4
  152bf4:	f2c0 0516 	movt	r5, #22
  152bf8:	089b      	lsrs	r3, r3, #2
  152bfa:	6828      	ldr	r0, [r5, #0]
  152bfc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  152c00:	eb01 1141 	add.w	r1, r1, r1, lsl #5
  152c04:	eb03 0141 	add.w	r1, r3, r1, lsl #1
  152c08:	eb01 1141 	add.w	r1, r1, r1, lsl #5
  152c0c:	ebc1 31c1 	rsb	r1, r1, r1, lsl #15
  152c10:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  152c14:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
  152c18:	1c4e      	adds	r6, r1, #1
  152c1a:	eb06 0646 	add.w	r6, r6, r6, lsl #1
  152c1e:	eb04 0686 	add.w	r6, r4, r6, lsl #2
    block->next = command_list;
  152c22:	4613      	mov	r3, r2
  152c24:	f843 0b0c 	str.w	r0, [r3], #12
    for (block = __commands_start; block != __commands_end; block++) {
  152c28:	42b3      	cmp	r3, r6
  152c2a:	4610      	mov	r0, r2
  152c2c:	461a      	mov	r2, r3
  152c2e:	d1f8      	bne.n	152c22 <console_init+0x66>
  152c30:	230c      	movs	r3, #12
  152c32:	fb03 4101 	mla	r1, r3, r1, r4
  152c36:	6029      	str	r1, [r5, #0]
    history = calloc(1, HISTORY_LEN * LINE_LEN);
  152c38:	f44f 6100 	mov.w	r1, #2048	; 0x800
  152c3c:	2001      	movs	r0, #1
  152c3e:	f000 f93d 	bl	152ebc <calloc>
  152c42:	f246 7304 	movw	r3, #26372	; 0x6704
    history_next = 0;
  152c46:	f246 7208 	movw	r2, #26376	; 0x6708
  152c4a:	2100      	movs	r1, #0
    history = calloc(1, HISTORY_LEN * LINE_LEN);
  152c4c:	f2c0 0316 	movt	r3, #22
    history_next = 0;
  152c50:	f2c0 0216 	movt	r2, #22
  152c54:	6011      	str	r1, [r2, #0]
    history = calloc(1, HISTORY_LEN * LINE_LEN);
  152c56:	6018      	str	r0, [r3, #0]
}
  152c58:	4608      	mov	r0, r1
  152c5a:	bd70      	pop	{r4, r5, r6, r15}

00152c5c <console_start>:
{
  152c5c:	b538      	push	{r3, r4, r5, r14}
    debug_buffer = malloc(LINE_LEN);
  152c5e:	2080      	movs	r0, #128	; 0x80
  152c60:	f246 7500 	movw	r5, #26368	; 0x6700
  152c64:	f000 f914 	bl	152e90 <malloc>
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
  152c68:	f242 5475 	movw	r4, #9589	; 0x2575
    debug_buffer = malloc(LINE_LEN);
  152c6c:	f2c0 0516 	movt	r5, #22
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
  152c70:	f2c0 0415 	movt	r4, #21
    debug_buffer = malloc(LINE_LEN);
  152c74:	6028      	str	r0, [r5, #0]
    while (command_loop(&read_debug_line, NULL, true, false) == NO_ERROR)
  152c76:	2300      	movs	r3, #0
  152c78:	2201      	movs	r2, #1
  152c7a:	4619      	mov	r1, r3
  152c7c:	4620      	mov	r0, r4
  152c7e:	f7ff fe0b 	bl	152898 <command_loop>
  152c82:	2800      	cmp	r0, #0
  152c84:	d0f7      	beq.n	152c76 <console_start+0x1a>
    free (debug_buffer);
  152c86:	6828      	ldr	r0, [r5, #0]
}
  152c88:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    free (debug_buffer);
  152c8c:	f000 b936 	b.w	152efc <free>

00152c90 <spin>:
#include <platform.h>
#include <platform/debug.h>
#include <kernel/spinlock.h>

void spin(uint32_t usecs)
{
  152c90:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  152c92:	4604      	mov	r4, r0
    lk_bigtime_t start = current_time_hires();
  152c94:	f7ed fe56 	bl	140944 <current_time_hires>
  152c98:	2500      	movs	r5, #0
  152c9a:	4606      	mov	r6, r0
  152c9c:	460f      	mov	r7, r1

    while ((current_time_hires() - start) < usecs)
  152c9e:	f7ed fe51 	bl	140944 <current_time_hires>
  152ca2:	1b82      	subs	r2, r0, r6
  152ca4:	eb61 0307 	sbc.w	r3, r1, r7
  152ca8:	42ab      	cmp	r3, r5
  152caa:	bf08      	it	eq
  152cac:	42a2      	cmpeq	r2, r4
  152cae:	d3f6      	bcc.n	152c9e <spin+0xe>
        ;
}
  152cb0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  152cb2:	bf00      	nop

00152cb4 <_panic>:

void _panic(void *caller, const char *fmt, ...)
{
  152cb4:	b40e      	push	{r1, r2, r3}
  152cb6:	b500      	push	{r14}
    printf("panic (caller %p): ", caller);
  152cb8:	4601      	mov	r1, r0
{
  152cba:	b082      	sub	sp, #8
    printf("panic (caller %p): ", caller);
  152cbc:	f648 0048 	movw	r0, #34888	; 0x8848
{
  152cc0:	ac03      	add	r4, sp, #12
    printf("panic (caller %p): ", caller);
  152cc2:	f2c0 0015 	movt	r0, #21
{
  152cc6:	f854 5b04 	ldr.w	r5, [r4], #4
    printf("panic (caller %p): ", caller);
  152cca:	f001 fa15 	bl	1540f8 <_printf>

    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
  152cce:	4621      	mov	r1, r4
  152cd0:	4628      	mov	r0, r5
    va_start(ap, fmt);
  152cd2:	9401      	str	r4, [sp, #4]
    vprintf(fmt, ap);
  152cd4:	f001 fa26 	bl	154124 <_vprintf>
    va_end(ap);

    platform_halt(HALT_ACTION_HALT, HALT_REASON_SW_PANIC);
  152cd8:	2109      	movs	r1, #9
  152cda:	2000      	movs	r0, #0
  152cdc:	f7ed fc2e 	bl	14053c <platform_halt>

00152ce0 <hexdump>:

    return &panic_fd;
}

void hexdump(const void *ptr, size_t len)
{
  152ce0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  152ce4:	b089      	sub	sp, #36	; 0x24
    addr_t address = (addr_t)ptr;
    size_t count;

    for (count = 0 ; count < len; count += 16) {
  152ce6:	9102      	str	r1, [sp, #8]
  152ce8:	2900      	cmp	r1, #0
  152cea:	d06d      	beq.n	152dc8 <hexdump+0xe8>
            uint8_t  cbuf[16];
        } u;
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
        size_t i;

        printf("0x%08lx: ", address);
  152cec:	f248 2364 	movw	r3, #33380	; 0x8264
        for (i = 0; i < s / 4; i++) {
            u.buf[i] = ((const uint32_t *)address)[i];
            printf("%08x ", u.buf[i]);
  152cf0:	f248 2870 	movw	r8, #33392	; 0x8270
        }
        for (; i < 4; i++) {
            printf("         ");
  152cf4:	f648 075c 	movw	r7, #34908	; 0x885c
        printf("0x%08lx: ", address);
  152cf8:	f2c0 0315 	movt	r3, #21
  152cfc:	4606      	mov	r6, r0
            printf("%08x ", u.buf[i]);
  152cfe:	f2c0 0815 	movt	r8, #21
        printf("0x%08lx: ", address);
  152d02:	9303      	str	r3, [sp, #12]
            printf("         ");
  152d04:	f2c0 0715 	movt	r7, #21
    for (count = 0 ; count < len; count += 16) {
  152d08:	2300      	movs	r3, #0
  152d0a:	9301      	str	r3, [sp, #4]
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  152d0c:	e9dd 2301 	ldrd	r2, r3, [r13, #4]
        printf("0x%08lx: ", address);
  152d10:	4631      	mov	r1, r6
  152d12:	9803      	ldr	r0, [sp, #12]
  152d14:	f10d 0910 	add.w	r9, r13, #16
        for (i = 0; i < s / 4; i++) {
  152d18:	46b2      	mov	r10, r6
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  152d1a:	1a9c      	subs	r4, r3, r2
  152d1c:	2c10      	cmp	r4, #16
  152d1e:	bf28      	it	cs
  152d20:	2410      	movcs	r4, #16
        printf("0x%08lx: ", address);
  152d22:	f001 f9e9 	bl	1540f8 <_printf>
        size_t s = ROUNDUP(MIN(len - count, 16), 4);
  152d26:	3403      	adds	r4, #3
  152d28:	f024 0503 	bic.w	r5, r4, #3
        for (i = 0; i < s / 4; i++) {
  152d2c:	08a4      	lsrs	r4, r4, #2
  152d2e:	eb06 0b84 	add.w	r11, r6, r4, lsl #2
            u.buf[i] = ((const uint32_t *)address)[i];
  152d32:	f85a 3b04 	ldr.w	r3, [r10], #4
            printf("%08x ", u.buf[i]);
  152d36:	4640      	mov	r0, r8
            u.buf[i] = ((const uint32_t *)address)[i];
  152d38:	f849 3b04 	str.w	r3, [r9], #4
            printf("%08x ", u.buf[i]);
  152d3c:	4619      	mov	r1, r3
  152d3e:	f001 f9db 	bl	1540f8 <_printf>
        for (i = 0; i < s / 4; i++) {
  152d42:	45d3      	cmp	r11, r10
  152d44:	d1f5      	bne.n	152d32 <hexdump+0x52>
        for (; i < 4; i++) {
  152d46:	2c04      	cmp	r4, #4
  152d48:	d005      	beq.n	152d56 <hexdump+0x76>
            printf("         ");
  152d4a:	4638      	mov	r0, r7
        for (; i < 4; i++) {
  152d4c:	3401      	adds	r4, #1
            printf("         ");
  152d4e:	f001 f9d3 	bl	1540f8 <_printf>
        for (; i < 4; i++) {
  152d52:	2c04      	cmp	r4, #4
  152d54:	d1f9      	bne.n	152d4a <hexdump+0x6a>
        }
        printf("|");
  152d56:	f648 0068 	movw	r0, #34920	; 0x8868
        for (i=0; i < 16; i++) {
            char c = u.cbuf[i];
            if (i < s && isprint(c)) {
                printf("%c", c);
            } else {
                printf(".");
  152d5a:	f648 0470 	movw	r4, #34928	; 0x8870
                printf("%c", c);
  152d5e:	f648 0b6c 	movw	r11, #34924	; 0x886c
        printf("|");
  152d62:	f2c0 0015 	movt	r0, #21
  152d66:	f001 f9c7 	bl	1540f8 <_printf>
                printf(".");
  152d6a:	f2c0 0415 	movt	r4, #21
        for (i=0; i < 16; i++) {
  152d6e:	f04f 0a00 	mov.w	r10, #0
                printf("%c", c);
  152d72:	f2c0 0b15 	movt	r11, #21
  152d76:	e007      	b.n	152d88 <hexdump+0xa8>
                printf(".");
  152d78:	4620      	mov	r0, r4
        for (i=0; i < 16; i++) {
  152d7a:	f10a 0a01 	add.w	r10, r10, #1
                printf(".");
  152d7e:	f001 f9bb 	bl	1540f8 <_printf>
        for (i=0; i < 16; i++) {
  152d82:	f1ba 0f10 	cmp.w	r10, #16
  152d86:	d012      	beq.n	152dae <hexdump+0xce>
            if (i < s && isprint(c)) {
  152d88:	4555      	cmp	r5, r10
  152d8a:	d9f5      	bls.n	152d78 <hexdump+0x98>
  152d8c:	ab04      	add	r3, sp, #16
  152d8e:	f813 900a 	ldrb.w	r9, [r3, r10]
  152d92:	4648      	mov	r0, r9
  152d94:	f000 fa68 	bl	153268 <isprint>
  152d98:	2800      	cmp	r0, #0
  152d9a:	d0ed      	beq.n	152d78 <hexdump+0x98>
                printf("%c", c);
  152d9c:	4649      	mov	r1, r9
  152d9e:	4658      	mov	r0, r11
        for (i=0; i < 16; i++) {
  152da0:	f10a 0a01 	add.w	r10, r10, #1
                printf("%c", c);
  152da4:	f001 f9a8 	bl	1540f8 <_printf>
        for (i=0; i < 16; i++) {
  152da8:	f1ba 0f10 	cmp.w	r10, #16
  152dac:	d1ec      	bne.n	152d88 <hexdump+0xa8>
    for (count = 0 ; count < len; count += 16) {
  152dae:	9c01      	ldr	r4, [sp, #4]
            }
        }
        printf("|\n");
  152db0:	f648 0074 	movw	r0, #34932	; 0x8874
  152db4:	f2c0 0015 	movt	r0, #21
    for (count = 0 ; count < len; count += 16) {
  152db8:	3410      	adds	r4, #16
        address += 16;
  152dba:	3610      	adds	r6, #16
    for (count = 0 ; count < len; count += 16) {
  152dbc:	9401      	str	r4, [sp, #4]
        printf("|\n");
  152dbe:	f001 f99b 	bl	1540f8 <_printf>
    for (count = 0 ; count < len; count += 16) {
  152dc2:	9b02      	ldr	r3, [sp, #8]
  152dc4:	42a3      	cmp	r3, r4
  152dc6:	d8a1      	bhi.n	152d0c <hexdump+0x2c>
    }
}
  152dc8:	b009      	add	sp, #36	; 0x24
  152dca:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  152dce:	bf00      	nop

00152dd0 <heap_free_delayed_list>:
#else
#error need to select valid heap implementation or provide wrapper
#endif

static void heap_free_delayed_list(void)
{
  152dd0:	b5f0      	push	{r4, r5, r6, r7, r14}
  152dd2:	b083      	sub	sp, #12
  152dd4:	466c      	mov	r4, r13
  152dd6:	e9cd 4400 	strd	r4, r4, [r13]
  152dda:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  152dde:	f013 0280 	ands.w	r2, r3, #128	; 0x80
  152de2:	d137      	bne.n	152e54 <heap_free_delayed_list+0x84>
    __asm__ volatile("cpsid i");
  152de4:	b672      	cpsid	i
    if (list->next != list) {
  152de6:	f241 0134 	movw	r1, #4148	; 0x1034
    *lock = 1;
  152dea:	f246 7610 	movw	r6, #26384	; 0x6710
  152dee:	f2c0 0116 	movt	r1, #22
  152df2:	2701      	movs	r7, #1
  152df4:	f2c0 0616 	movt	r6, #22
  152df8:	684b      	ldr	r3, [r1, #4]
  152dfa:	6037      	str	r7, [r6, #0]
  152dfc:	428b      	cmp	r3, r1
    *lock = 0;
  152dfe:	bf08      	it	eq
  152e00:	6032      	streq	r2, [r6, #0]
  152e02:	d013      	beq.n	152e2c <heap_free_delayed_list+0x5c>
    item->prev = item->next = 0;
  152e04:	2500      	movs	r5, #0
  152e06:	e000      	b.n	152e0a <heap_free_delayed_list+0x3a>
    if (list->next != list) {
  152e08:	4613      	mov	r3, r2
    item->next->prev = item->prev;
  152e0a:	e9d3 0200 	ldrd	r0, r2, [r3]
  152e0e:	6010      	str	r0, [r2, #0]
    item->prev->next = item->next;
  152e10:	6818      	ldr	r0, [r3, #0]
  152e12:	6042      	str	r2, [r0, #4]
    item->prev = item->next = 0;
  152e14:	605d      	str	r5, [r3, #4]
    item->next = list->next;
  152e16:	9a01      	ldr	r2, [sp, #4]
  152e18:	605a      	str	r2, [r3, #4]
    if (list->next != list) {
  152e1a:	684a      	ldr	r2, [r1, #4]
    list->next->prev = item;
  152e1c:	9801      	ldr	r0, [sp, #4]
    item->prev = list;
  152e1e:	601c      	str	r4, [r3, #0]
    if (list->next != list) {
  152e20:	428a      	cmp	r2, r1
    list->next->prev = item;
  152e22:	6003      	str	r3, [r0, #0]
    list->next = item;
  152e24:	9301      	str	r3, [sp, #4]
    if (list->next != list) {
  152e26:	d1ef      	bne.n	152e08 <heap_free_delayed_list+0x38>
  152e28:	6035      	str	r5, [r6, #0]
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  152e2a:	b10f      	cbz	r7, 152e30 <heap_free_delayed_list+0x60>
    __asm__ volatile("cpsie i");
  152e2c:	b662      	cpsie	i
  152e2e:	9b01      	ldr	r3, [sp, #4]
  152e30:	42a3      	cmp	r3, r4
  152e32:	d00d      	beq.n	152e50 <heap_free_delayed_list+0x80>
    item->prev = item->next = 0;
  152e34:	2500      	movs	r5, #0
    item->next->prev = item->prev;
  152e36:	6819      	ldr	r1, [r3, #0]
    }
    spin_unlock_irqrestore(&delayed_free_lock, state);

    while ((node = list_remove_head(&list))) {
        LTRACEF("freeing node %p\n", node);
        HEAP_FREE(node);
  152e38:	4618      	mov	r0, r3
  152e3a:	685a      	ldr	r2, [r3, #4]
  152e3c:	6011      	str	r1, [r2, #0]
    item->prev->next = item->next;
  152e3e:	6819      	ldr	r1, [r3, #0]
  152e40:	604a      	str	r2, [r1, #4]
    item->prev = item->next = 0;
  152e42:	e9c3 5500 	strd	r5, r5, [r3]
  152e46:	f001 fb3f 	bl	1544c8 <miniheap_free>
    if (list->next != list) {
  152e4a:	9b01      	ldr	r3, [sp, #4]
  152e4c:	42a3      	cmp	r3, r4
  152e4e:	d1f2      	bne.n	152e36 <heap_free_delayed_list+0x66>
    }
}
  152e50:	b003      	add	sp, #12
  152e52:	bdf0      	pop	{r4, r5, r6, r7, r15}
  152e54:	f241 0134 	movw	r1, #4148	; 0x1034
    *lock = 1;
  152e58:	f246 7610 	movw	r6, #26384	; 0x6710
  152e5c:	f2c0 0116 	movt	r1, #22
  152e60:	2201      	movs	r2, #1
  152e62:	f2c0 0616 	movt	r6, #22
  152e66:	684b      	ldr	r3, [r1, #4]
  152e68:	6032      	str	r2, [r6, #0]
  152e6a:	428b      	cmp	r3, r1
    *lock = 0;
  152e6c:	bf04      	itt	eq
  152e6e:	2300      	moveq	r3, #0
  152e70:	6033      	streq	r3, [r6, #0]
  152e72:	d0ed      	beq.n	152e50 <heap_free_delayed_list+0x80>
    spin_lock_saved_state_t state = 0;
  152e74:	2700      	movs	r7, #0
  152e76:	e7c5      	b.n	152e04 <heap_free_delayed_list+0x34>

00152e78 <heap_init>:

void heap_init(void)
{
  152e78:	b500      	push	{r14}
  152e7a:	b083      	sub	sp, #12
    void *ptr = page_first_alloc(&len);
  152e7c:	a801      	add	r0, sp, #4
  152e7e:	f000 f86f 	bl	152f60 <page_first_alloc>
    miniheap_init(ptr, len);
  152e82:	9901      	ldr	r1, [sp, #4]
  152e84:	f001 fb28 	bl	1544d8 <miniheap_init>
    HEAP_INIT();
}
  152e88:	b003      	add	sp, #12
  152e8a:	f85d fb04 	ldr.w	r15, [r13], #4
  152e8e:	bf00      	nop

00152e90 <malloc>:
    return (list->next == list) ? true : false;
  152e90:	f241 0334 	movw	r3, #4148	; 0x1034
  152e94:	f2c0 0316 	movt	r3, #22
void *malloc(size_t size)
{
    LTRACEF("size %zd\n", size);

    // deal with the pending free list
    if (unlikely(!list_is_empty(&delayed_free_list))) {
  152e98:	685a      	ldr	r2, [r3, #4]
  152e9a:	429a      	cmp	r2, r3
  152e9c:	d102      	bne.n	152ea4 <malloc+0x14>
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
  152e9e:	2100      	movs	r1, #0
  152ea0:	f001 ba38 	b.w	154314 <miniheap_alloc>
{
  152ea4:	b500      	push	{r14}
  152ea6:	b083      	sub	sp, #12
  152ea8:	9001      	str	r0, [sp, #4]
        heap_free_delayed_list();
  152eaa:	f7ff ff91 	bl	152dd0 <heap_free_delayed_list>
  152eae:	9801      	ldr	r0, [sp, #4]
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
  152eb0:	2100      	movs	r1, #0

    void *ptr = HEAP_MALLOC(size);
    if (heap_trace)
        printf("caller %p malloc %zu -> %p\n", __GET_CALLER(), size, ptr);
    return ptr;
}
  152eb2:	b003      	add	sp, #12
  152eb4:	f85d eb04 	ldr.w	r14, [r13], #4
static inline void *HEAP_MALLOC(size_t s) { return miniheap_alloc(s, 0); }
  152eb8:	f001 ba2c 	b.w	154314 <miniheap_alloc>

00152ebc <calloc>:
  152ebc:	f241 0334 	movw	r3, #4148	; 0x1034
  152ec0:	f2c0 0316 	movt	r3, #22
        printf("caller %p memalign %zu, %zu -> %p\n", __GET_CALLER(), boundary, size, ptr);
    return ptr;
}

void *calloc(size_t count, size_t size)
{
  152ec4:	b530      	push	{r4, r5, r14}
    LTRACEF("count %zu, size %zd\n", count, size);

    // deal with the pending free list
    if (unlikely(!list_is_empty(&delayed_free_list))) {
  152ec6:	685a      	ldr	r2, [r3, #4]
{
  152ec8:	b083      	sub	sp, #12
    if (unlikely(!list_is_empty(&delayed_free_list))) {
  152eca:	429a      	cmp	r2, r3
  152ecc:	d10e      	bne.n	152eec <calloc+0x30>
    size_t realsize = n * s;
  152ece:	fb01 f400 	mul.w	r4, r1, r0
    void *ptr = miniheap_alloc(realsize, 0);
  152ed2:	2100      	movs	r1, #0
  152ed4:	4620      	mov	r0, r4
  152ed6:	f001 fa1d 	bl	154314 <miniheap_alloc>
    if (likely(ptr))
  152eda:	4605      	mov	r5, r0
  152edc:	b118      	cbz	r0, 152ee6 <calloc+0x2a>
        memset(ptr, 0, realsize);
  152ede:	4622      	mov	r2, r4
  152ee0:	2100      	movs	r1, #0
  152ee2:	f000 e8cc 	blx	15307c <memset>

    void *ptr = HEAP_CALLOC(count, size);
    if (heap_trace)
        printf("caller %p calloc %zu, %zu -> %p\n", __GET_CALLER(), count, size, ptr);
    return ptr;
}
  152ee6:	4628      	mov	r0, r5
  152ee8:	b003      	add	sp, #12
  152eea:	bd30      	pop	{r4, r5, r15}
  152eec:	e9cd 0100 	strd	r0, r1, [r13]
        heap_free_delayed_list();
  152ef0:	f7ff ff6e 	bl	152dd0 <heap_free_delayed_list>
  152ef4:	e9dd 0100 	ldrd	r0, r1, [r13]
  152ef8:	e7e9      	b.n	152ece <calloc+0x12>
  152efa:	bf00      	nop

00152efc <free>:
{
    LTRACEF("ptr %p\n", ptr);
    if (heap_trace)
        printf("caller %p free %p\n", __GET_CALLER(), ptr);

    HEAP_FREE(ptr);
  152efc:	f001 bae4 	b.w	1544c8 <miniheap_free>

00152f00 <heap_delayed_free>:
}

/* critical section time delayed free */
void heap_delayed_free(void *ptr)
{
  152f00:	b410      	push	{r4}
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  152f02:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  152f06:	f013 0380 	ands.w	r3, r3, #128	; 0x80
  152f0a:	d113      	bne.n	152f34 <heap_delayed_free+0x34>
    __asm__ volatile("cpsid i");
  152f0c:	b672      	cpsid	i
    item->next = list->next;
  152f0e:	f241 0234 	movw	r2, #4148	; 0x1034
    *lock = 0;
  152f12:	f246 7110 	movw	r1, #26384	; 0x6710
  152f16:	f2c0 0216 	movt	r2, #22
  152f1a:	f2c0 0116 	movt	r1, #22
  152f1e:	6854      	ldr	r4, [r2, #4]
  152f20:	6044      	str	r4, [r0, #4]
    list->next->prev = item;
  152f22:	6854      	ldr	r4, [r2, #4]
    item->prev = list;
  152f24:	6002      	str	r2, [r0, #0]
    list->next->prev = item;
  152f26:	6020      	str	r0, [r4, #0]
    list->next = item;
  152f28:	6050      	str	r0, [r2, #4]
  152f2a:	600b      	str	r3, [r1, #0]
    __asm__ volatile("cpsie i");
  152f2c:	b662      	cpsie	i

    spin_lock_saved_state_t state;
    spin_lock_irqsave(&delayed_free_lock, state);
    list_add_head(&delayed_free_list, node);
    spin_unlock_irqrestore(&delayed_free_lock, state);
}
  152f2e:	f85d 4b04 	ldr.w	r4, [r13], #4
  152f32:	4770      	bx	r14
    item->next = list->next;
  152f34:	f241 0334 	movw	r3, #4148	; 0x1034
  152f38:	f246 7210 	movw	r2, #26384	; 0x6710
  152f3c:	f2c0 0316 	movt	r3, #22
  152f40:	2100      	movs	r1, #0
  152f42:	f2c0 0216 	movt	r2, #22
  152f46:	685c      	ldr	r4, [r3, #4]
  152f48:	6044      	str	r4, [r0, #4]
    list->next->prev = item;
  152f4a:	685c      	ldr	r4, [r3, #4]
    item->prev = list;
  152f4c:	6003      	str	r3, [r0, #0]
    list->next->prev = item;
  152f4e:	6020      	str	r0, [r4, #0]
    list->next = item;
  152f50:	6058      	str	r0, [r3, #4]
  152f52:	6011      	str	r1, [r2, #0]
  152f54:	f85d 4b04 	ldr.w	r4, [r13], #4
  152f58:	4770      	bx	r14
  152f5a:	bf00      	nop

00152f5c <page_alloc>:
{
#if WITH_KERNEL_VM
    void *result = pmm_alloc_kpages(pages, NULL);
    return result;
#else
    void *result = novm_alloc_pages(pages, arena);
  152f5c:	f7ff b8aa 	b.w	1520b4 <novm_alloc_pages>

00152f60 <page_first_alloc>:
{
#if WITH_KERNEL_VM
    *size_return = PAGE_SIZE;
    return page_alloc(1, PAGE_ALLOC_ANY_ARENA);
#else
    return novm_alloc_unaligned(size_return);
  152f60:	f7ff b88e 	b.w	152080 <novm_alloc_unaligned>

00152f64 <bcopy>:
.align 2

/* void bcopy(const void *src, void *dest, size_t n); */
FUNCTION(bcopy)
    // swap args for bcopy
    mov     r12, r0
  152f64:	e1a0c000 	mov	r12, r0
    mov     r0, r1
  152f68:	e1a00001 	mov	r0, r1
    mov     r1, r12
  152f6c:	e1a0100c 	mov	r1, r12

00152f70 <memcpy>:

/* void *memcpy(void *dest, const void *src, size_t n); */
FUNCTION(memmove)
FUNCTION(memcpy)
    // check for zero length copy or the same pointer
    cmp     r2, #0
  152f70:	e3520000 	cmp	r2, #0
    cmpne   r1, r0
  152f74:	11510000 	cmpne	r1, r0
    bxeq    lr
  152f78:	012fff1e 	bxeq	r14

    // save a few registers for use and the return code (input dst)
    stmfd   sp!, {r0, r4, r5, lr}
  152f7c:	e92d4031 	push	{r0, r4, r5, r14}

    // check for forwards overlap (src > dst, distance < len)
    subs    r3, r0, r1
  152f80:	e0503001 	subs	r3, r0, r1
    cmphi   r2, r3
  152f84:	81520003 	cmphi	r2, r3
    bhi     .L_forwardoverlap
  152f88:	8a000030 	bhi	153050 <memcpy+0xe0>

    // check for a short copy len.
    // 20 bytes is enough so that if a 16 byte alignment needs to happen there is at least a 
    //   wordwise copy worth of work to be done.
    cmp     r2, #(16+4)
  152f8c:	e3520014 	cmp	r2, #20
    blo     .L_bytewise
  152f90:	3a000019 	bcc	152ffc <memcpy+0x8c>

    // see if they are similarly aligned on 4 byte boundaries
    eor     r3, r0, r1
  152f94:	e0203001 	eor	r3, r0, r1
    tst     r3, #3
  152f98:	e3130003 	tst	r3, #3
    bne     .L_bytewise     // dissimilarly aligned, nothing we can do (for now)
  152f9c:	1a000016 	bne	152ffc <memcpy+0x8c>

    // check for 16 byte alignment on dst.
    // this will also catch src being not 4 byte aligned, since it is similarly 4 byte 
    //   aligned with dst at this point.
    tst     r0, #15
  152fa0:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  152fa4:	1a00001a 	bne	153014 <memcpy+0xa4>

    // check to see if we have at least 32 bytes of data to copy.
    // if not, just revert to wordwise copy
    cmp     r2, #32
  152fa8:	e3520020 	cmp	r2, #32
    blo     .L_wordwise
  152fac:	3a00000b 	bcc	152fe0 <memcpy+0x70>
.L_bigcopy:
    // copy 32 bytes at a time. src & dst need to be at least 4 byte aligned, 
    // and we need at least 32 bytes remaining to copy

    // save r6-r7 for use in the big copy
    stmfd   sp!, {r6-r11}
  152fb0:	e92d0fc0 	push	{r6, r7, r8, r9, r10, r11}

    sub     r2, r2, #32     // subtract an extra 32 to the len so we can avoid an extra compare
  152fb4:	e2422020 	sub	r2, r2, #32

.L_bigcopy_loop:
    pld     [r1, #64]
  152fb8:	f5d1f040 	pld	[r1, #64]	; 0x40
    ldmia   r1!, {r4-r11}
  152fbc:	e8b10ff0 	ldm	r1!, {r4, r5, r6, r7, r8, r9, r10, r11}
    subs    r2, r2, #32
  152fc0:	e2522020 	subs	r2, r2, #32
    stmia   r0!, {r4-r11}
  152fc4:	e8a00ff0 	stmia	r0!, {r4, r5, r6, r7, r8, r9, r10, r11}
    bhs     .L_bigcopy_loop
  152fc8:	2afffffa 	bcs	152fb8 <memcpy+0x48>

    // restore r6-r7
    ldmfd   sp!, {r6-r11}
  152fcc:	e8bd0fc0 	pop	{r6, r7, r8, r9, r10, r11}

    // see if we are done
    adds    r2, r2, #32
  152fd0:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  152fd4:	0a00000c 	beq	15300c <memcpy+0x9c>

    // less then 4 bytes left?
    cmp     r2, #4
  152fd8:	e3520004 	cmp	r2, #4
    blo     .L_bytewise
  152fdc:	3a000006 	bcc	152ffc <memcpy+0x8c>

.L_wordwise:
    // copy 4 bytes at a time.
    // src & dst are guaranteed to be word aligned, and at least 4 bytes are left to copy.
    subs    r2, r2, #4
  152fe0:	e2522004 	subs	r2, r2, #4

.L_wordwise_loop:
    ldr     r3, [r1], #4
  152fe4:	e4913004 	ldr	r3, [r1], #4
    subs    r2, r2, #4
  152fe8:	e2522004 	subs	r2, r2, #4
    str     r3, [r0], #4
  152fec:	e4803004 	str	r3, [r0], #4
    bhs     .L_wordwise_loop
  152ff0:	2afffffb 	bcs	152fe4 <memcpy+0x74>

    // correct the remaining len and test for completion
    adds    r2, r2, #4  
  152ff4:	e2922004 	adds	r2, r2, #4
    beq     .L_done
  152ff8:	0a000003 	beq	15300c <memcpy+0x9c>

.L_bytewise:
    // simple bytewise copy
    ldrb    r3, [r1], #1
  152ffc:	e4d13001 	ldrb	r3, [r1], #1
    subs    r2, r2, #1
  153000:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #1
  153004:	e4c03001 	strb	r3, [r0], #1
    bhi     .L_bytewise
  153008:	8afffffb 	bhi	152ffc <memcpy+0x8c>
.L_done:
    // load dst for return and restore r4,r5
#if ARM_ARCH_LEVEL >= 5
    ldmfd   sp!, {r0, r4, r5, pc}
#else
    ldmfd   sp!, {r0, r4, r5, lr}
  15300c:	e8bd4031 	pop	{r0, r4, r5, r14}
    bx      lr
  153010:	e12fff1e 	bx	r14
.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will copy up to 15 bytes to get it aligned.
    // src is guaranteed to be similarly word aligned with dst.

    // set the condition flags based on the alignment.
    lsl     r12, r0, #28
  153014:	e1a0ce00 	lsl	r12, r0, #28
    rsb     r12, r12, #0
  153018:	e26cc000 	rsb	r12, r12, #0
    msr     CPSR_f, r12             // move into NZCV fields in CPSR
  15301c:	e128f00c 	msr	CPSR_f, r12

    // move as many bytes as necessary to get the dst aligned
    ldrvsb  r3, [r1], #1            // V set
  153020:	64d13001 	ldrbvs	r3, [r1], #1
    ldrcsh  r4, [r1], #2            // C set
  153024:	20d140b2 	ldrhcs	r4, [r1], #2
    ldreq   r5, [r1], #4            // Z set
  153028:	04915004 	ldreq	r5, [r1], #4

    strvsb  r3, [r0], #1
  15302c:	64c03001 	strbvs	r3, [r0], #1
    strcsh  r4, [r0], #2
  153030:	20c040b2 	strhcs	r4, [r0], #2
    streq   r5, [r0], #4
  153034:	04805004 	streq	r5, [r0], #4

    ldmmiia r1!, {r3-r4}            // N set
  153038:	48b10018 	ldmmi	r1!, {r3, r4}
    stmmiia r0!, {r3-r4}
  15303c:	48a00018 	stmiami	r0!, {r3, r4}

    // fix the remaining len
    sub     r2, r2, r12, lsr #28
  153040:	e0422e2c 	sub	r2, r2, r12, lsr #28

    // test to see what we should do now
    cmp     r2, #32
  153044:	e3520020 	cmp	r2, #32
    bhs     .L_bigcopy
  153048:	2affffd8 	bcs	152fb0 <memcpy+0x40>
    b       .L_wordwise
  15304c:	eaffffe3 	b	152fe0 <memcpy+0x70>

    // src and dest overlap 'forwards' or dst > src
.L_forwardoverlap:

    // do a bytewise reverse copy for now
    add     r1, r1, r2
  153050:	e0811002 	add	r1, r1, r2
    add     r0, r0, r2
  153054:	e0800002 	add	r0, r0, r2
    sub     r1, r1, #1
  153058:	e2411001 	sub	r1, r1, #1
    sub     r0, r0, #1
  15305c:	e2400001 	sub	r0, r0, #1

.L_bytewisereverse:
    // simple bytewise reverse copy
    ldrb    r3, [r1], #-1
  153060:	e4513001 	ldrb	r3, [r1], #-1
    subs    r2, r2, #1
  153064:	e2522001 	subs	r2, r2, #1
    strb    r3, [r0], #-1
  153068:	e4403001 	strb	r3, [r0], #-1
    bhi     .L_bytewisereverse
  15306c:	8afffffb 	bhi	153060 <memcpy+0xf0>

    b       .L_done
  153070:	eaffffe5 	b	15300c <memcpy+0x9c>

00153074 <bzero>:
.text
.align 2

/* void bzero(void *s, size_t n); */
FUNCTION(bzero)
    mov     r2, r1
  153074:	e1a02001 	mov	r2, r1
    mov     r1, #0
  153078:	e3a01000 	mov	r1, #0

0015307c <memset>:

/* void *memset(void *s, int c, size_t n); */
FUNCTION(memset)
    // check for zero length
    cmp     r2, #0
  15307c:	e3520000 	cmp	r2, #0
    bxeq    lr
  153080:	012fff1e 	bxeq	r14

    // save the original pointer
    mov     r12, r0
  153084:	e1a0c000 	mov	r12, r0

    // short memsets aren't worth optimizing
    cmp     r2, #(32 + 16)
  153088:	e3520030 	cmp	r2, #48	; 0x30
    blt     .L_bytewise
  15308c:	ba000010 	blt	1530d4 <memset+0x58>

    // fill a 32 bit register with the 8 bit value
    and     r1, r1, #0xff
  153090:	e20110ff 	and	r1, r1, #255	; 0xff
    orr     r1, r1, r1, lsl #8
  153094:	e1811401 	orr	r1, r1, r1, lsl #8
    orr     r1, r1, r1, lsl #16
  153098:	e1811801 	orr	r1, r1, r1, lsl #16

    // check for 16 byte alignment
    tst     r0, #15
  15309c:	e310000f 	tst	r0, #15
    bne     .L_not16bytealigned
  1530a0:	1a000010 	bne	1530e8 <memset+0x6c>

.L_bigset:
    // dump some registers to make space for our values
    stmfd   sp!, { r4-r5 }
  1530a4:	e92d0030 	push	{r4, r5}

    // fill a bunch of registers with the set value
    mov     r3, r1
  1530a8:	e1a03001 	mov	r3, r1
    mov     r4, r1
  1530ac:	e1a04001 	mov	r4, r1
    mov     r5, r1
  1530b0:	e1a05001 	mov	r5, r1

    // prepare the count register so we can avoid an extra compare
    sub     r2, r2, #32
  1530b4:	e2422020 	sub	r2, r2, #32

    // 32 bytes at a time
.L_bigset_loop:
    stmia   r0!, { r1, r3, r4, r5 }
  1530b8:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    subs    r2, r2, #32
  1530bc:	e2522020 	subs	r2, r2, #32
    stmia   r0!, { r1, r3, r4, r5 }
  1530c0:	e8a0003a 	stmia	r0!, {r1, r3, r4, r5}
    bge     .L_bigset_loop
  1530c4:	aafffffb 	bge	1530b8 <memset+0x3c>

    // restore our dumped registers
    ldmfd   sp!, { r4-r5 }
  1530c8:	e8bd0030 	pop	{r4, r5}

    // see if we're done
    adds    r2, r2, #32
  1530cc:	e2922020 	adds	r2, r2, #32
    beq     .L_done
  1530d0:	0a000002 	beq	1530e0 <memset+0x64>

.L_bytewise:
    // bytewise memset
    subs    r2, r2, #1
  1530d4:	e2522001 	subs	r2, r2, #1
    strb    r1, [r0], #1
  1530d8:	e4c01001 	strb	r1, [r0], #1
    bgt     .L_bytewise
  1530dc:	cafffffc 	bgt	1530d4 <memset+0x58>

.L_done:
    // restore the base pointer as return value
    mov     r0, r12
  1530e0:	e1a0000c 	mov	r0, r12
    bx      lr
  1530e4:	e12fff1e 	bx	r14

.L_not16bytealigned:
    // dst is not 16 byte aligned, so we will set up to 15 bytes to get it aligned.

    // set the condition flags based on the alignment.
    lsl     r3, r0, #28
  1530e8:	e1a03e00 	lsl	r3, r0, #28
    rsb     r3, r3, #0
  1530ec:	e2633000 	rsb	r3, r3, #0
    msr     CPSR_f, r3             // move into NZCV fields in CPSR
  1530f0:	e128f003 	msr	CPSR_f, r3

    // move as many bytes as necessary to get the dst aligned
    strvsb  r1, [r0], #1            // V set
  1530f4:	64c01001 	strbvs	r1, [r0], #1
    strcsh  r1, [r0], #2            // C set
  1530f8:	20c010b2 	strhcs	r1, [r0], #2
    streq   r1, [r0], #4            // Z set
  1530fc:	04801004 	streq	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  153100:	44801004 	strmi	r1, [r0], #4
    strmi   r1, [r0], #4            // N set
  153104:	44801004 	strmi	r1, [r0], #4

    // fix the remaining len
    sub     r2, r2, r3, lsr #28
  153108:	e0422e23 	sub	r2, r2, r3, lsr #28

    // do the large memset
    b       .L_bigset
  15310c:	eaffffe4 	b	1530a4 <memset+0x28>

00153110 <hexval>:

#define LONG_IS_INT 1

static int hexval(char c)
{
    if (c >= '0' && c <= '9')
  153110:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
  153114:	b2da      	uxtb	r2, r3
  153116:	2a09      	cmp	r2, #9
  153118:	d90c      	bls.n	153134 <hexval+0x24>
        return c - '0';
    else if (c >= 'a' && c <= 'f')
  15311a:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
  15311e:	2b05      	cmp	r3, #5
  153120:	d906      	bls.n	153130 <hexval+0x20>
        return c - 'a' + 10;
    else if (c >= 'A' && c <= 'F')
  153122:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
  153126:	2b05      	cmp	r3, #5
        return c - 'A' + 10;
  153128:	bf94      	ite	ls
  15312a:	3837      	subls	r0, #55	; 0x37

    return 0;
  15312c:	2000      	movhi	r0, #0
}
  15312e:	4770      	bx	r14
        return c - 'a' + 10;
  153130:	3857      	subs	r0, #87	; 0x57
  153132:	4770      	bx	r14
        return c - '0';
  153134:	4618      	mov	r0, r3
  153136:	4770      	bx	r14

00153138 <atol>:
    return atoul(num);
#endif
}

long atol(const char *num)
{
  153138:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    long value = 0;
    int neg = 0;

    if (num[0] == '0' && num[1] == 'x') {
  15313a:	7802      	ldrb	r2, [r0, #0]
  15313c:	2a30      	cmp	r2, #48	; 0x30
  15313e:	d028      	beq.n	153192 <atol+0x5a>
        num += 2;
        while (*num && isxdigit(*num))
            value = value * 16 + hexval(*num++);
    } else {
        // decimal
        if (num[0] == '-') {
  153140:	2a2d      	cmp	r2, #45	; 0x2d
  153142:	d01b      	beq.n	15317c <atol+0x44>
            neg = 1;
            num++;
        }
        while (*num && isdigit(*num))
  153144:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
  153148:	b2db      	uxtb	r3, r3
  15314a:	2b09      	cmp	r3, #9
  15314c:	d83a      	bhi.n	1531c4 <atol+0x8c>
    int neg = 0;
  15314e:	2600      	movs	r6, #0
  153150:	7843      	ldrb	r3, [r0, #1]
  153152:	2400      	movs	r4, #0
  153154:	3001      	adds	r0, #1
  153156:	e001      	b.n	15315c <atol+0x24>
        while (*num && isdigit(*num))
  153158:	f810 3f01 	ldrb.w	r3, [r0, #1]!
            value = value * 10 + *num++  - '0';
  15315c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        while (*num && isdigit(*num))
  153160:	f1a3 0530 	sub.w	r5, r3, #48	; 0x30
  153164:	2d09      	cmp	r5, #9
            value = value * 10 + *num++  - '0';
  153166:	eb02 0144 	add.w	r1, r2, r4, lsl #1
  15316a:	461a      	mov	r2, r3
  15316c:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
        while (*num && isdigit(*num))
  153170:	d9f2      	bls.n	153158 <atol+0x20>
    }

    if (neg)
  153172:	b10e      	cbz	r6, 153178 <atol+0x40>
  153174:	f1c1 0430 	rsb	r4, r1, #48	; 0x30
        value = -value;

    return value;
}
  153178:	4620      	mov	r0, r4
  15317a:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        while (*num && isdigit(*num))
  15317c:	7842      	ldrb	r2, [r0, #1]
  15317e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
  153182:	2b09      	cmp	r3, #9
            num++;
  153184:	f100 0101 	add.w	r1, r0, #1
        while (*num && isdigit(*num))
  153188:	d81c      	bhi.n	1531c4 <atol+0x8c>
  15318a:	7883      	ldrb	r3, [r0, #2]
            neg = 1;
  15318c:	2601      	movs	r6, #1
            num++;
  15318e:	4608      	mov	r0, r1
  153190:	e7df      	b.n	153152 <atol+0x1a>
    if (num[0] == '0' && num[1] == 'x') {
  153192:	7843      	ldrb	r3, [r0, #1]
  153194:	2b78      	cmp	r3, #120	; 0x78
    int neg = 0;
  153196:	bf18      	it	ne
  153198:	2600      	movne	r6, #0
    if (num[0] == '0' && num[1] == 'x') {
  15319a:	d1da      	bne.n	153152 <atol+0x1a>
        while (*num && isxdigit(*num))
  15319c:	7885      	ldrb	r5, [r0, #2]
    long value = 0;
  15319e:	2400      	movs	r4, #0
        num += 2;
  1531a0:	1c86      	adds	r6, r0, #2
        while (*num && isxdigit(*num))
  1531a2:	b945      	cbnz	r5, 1531b6 <atol+0x7e>
  1531a4:	e00e      	b.n	1531c4 <atol+0x8c>
            value = value * 16 + hexval(*num++);
  1531a6:	4628      	mov	r0, r5
  1531a8:	f7ff ffb2 	bl	153110 <hexval>
        while (*num && isxdigit(*num))
  1531ac:	f816 5f01 	ldrb.w	r5, [r6, #1]!
            value = value * 16 + hexval(*num++);
  1531b0:	183c      	adds	r4, r7, r0
        while (*num && isxdigit(*num))
  1531b2:	2d00      	cmp	r5, #0
  1531b4:	d0e0      	beq.n	153178 <atol+0x40>
  1531b6:	4628      	mov	r0, r5
            value = value * 16 + hexval(*num++);
  1531b8:	0127      	lsls	r7, r4, #4
        while (*num && isxdigit(*num))
  1531ba:	f000 f847 	bl	15324c <isxdigit>
  1531be:	2800      	cmp	r0, #0
  1531c0:	d1f1      	bne.n	1531a6 <atol+0x6e>
  1531c2:	e7d9      	b.n	153178 <atol+0x40>
    long value = 0;
  1531c4:	2400      	movs	r4, #0
}
  1531c6:	4620      	mov	r0, r4
  1531c8:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
  1531ca:	bf00      	nop

001531cc <atoul>:

unsigned long atoul(const char *num)
{
  1531cc:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
    unsigned long value = 0;
    if (num[0] == '0' && num[1] == 'x') {
  1531ce:	7803      	ldrb	r3, [r0, #0]
  1531d0:	2b30      	cmp	r3, #48	; 0x30
  1531d2:	d017      	beq.n	153204 <atoul+0x38>
        num += 2;
        while (*num && isxdigit(*num))
            value = value * 16 + hexval(*num++);
    } else {
        // decimal
        while (*num && isdigit(*num))
  1531d4:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
  1531d8:	b2d2      	uxtb	r2, r2
  1531da:	2a09      	cmp	r2, #9
  1531dc:	d829      	bhi.n	153232 <atoul+0x66>
  1531de:	7842      	ldrb	r2, [r0, #1]
    unsigned long value = 0;
  1531e0:	2400      	movs	r4, #0
  1531e2:	3001      	adds	r0, #1
  1531e4:	e001      	b.n	1531ea <atoul+0x1e>
        while (*num && isdigit(*num))
  1531e6:	f810 2f01 	ldrb.w	r2, [r0, #1]!
            value = value * 10 + *num++  - '0';
  1531ea:	eb04 0484 	add.w	r4, r4, r4, lsl #2
        while (*num && isdigit(*num))
  1531ee:	f1a2 0130 	sub.w	r1, r2, #48	; 0x30
  1531f2:	2909      	cmp	r1, #9
            value = value * 10 + *num++  - '0';
  1531f4:	eb03 0444 	add.w	r4, r3, r4, lsl #1
  1531f8:	4613      	mov	r3, r2
  1531fa:	f1a4 0430 	sub.w	r4, r4, #48	; 0x30
        while (*num && isdigit(*num))
  1531fe:	d9f2      	bls.n	1531e6 <atoul+0x1a>
    }

    return value;
}
  153200:	4620      	mov	r0, r4
  153202:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
    if (num[0] == '0' && num[1] == 'x') {
  153204:	7842      	ldrb	r2, [r0, #1]
  153206:	2a78      	cmp	r2, #120	; 0x78
  153208:	d1ea      	bne.n	1531e0 <atoul+0x14>
        while (*num && isxdigit(*num))
  15320a:	7885      	ldrb	r5, [r0, #2]
    unsigned long value = 0;
  15320c:	2400      	movs	r4, #0
        num += 2;
  15320e:	1c86      	adds	r6, r0, #2
        while (*num && isxdigit(*num))
  153210:	b945      	cbnz	r5, 153224 <atoul+0x58>
  153212:	e00e      	b.n	153232 <atoul+0x66>
            value = value * 16 + hexval(*num++);
  153214:	4628      	mov	r0, r5
  153216:	f7ff ff7b 	bl	153110 <hexval>
        while (*num && isxdigit(*num))
  15321a:	f816 5f01 	ldrb.w	r5, [r6, #1]!
            value = value * 16 + hexval(*num++);
  15321e:	19c4      	adds	r4, r0, r7
        while (*num && isxdigit(*num))
  153220:	2d00      	cmp	r5, #0
  153222:	d0ed      	beq.n	153200 <atoul+0x34>
  153224:	4628      	mov	r0, r5
            value = value * 16 + hexval(*num++);
  153226:	0127      	lsls	r7, r4, #4
        while (*num && isxdigit(*num))
  153228:	f000 f810 	bl	15324c <isxdigit>
  15322c:	2800      	cmp	r0, #0
  15322e:	d1f1      	bne.n	153214 <atoul+0x48>
  153230:	e7e6      	b.n	153200 <atoul+0x34>
        while (*num && isdigit(*num))
  153232:	2400      	movs	r4, #0
}
  153234:	4620      	mov	r0, r4
  153236:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}

00153238 <isspace>:
    return (c == ' ' || c == '\t');
}

int isspace(int c)
{
    return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
  153238:	2820      	cmp	r0, #32
  15323a:	d005      	beq.n	153248 <isspace+0x10>
  15323c:	3809      	subs	r0, #9
  15323e:	2804      	cmp	r0, #4
  153240:	bf8c      	ite	hi
  153242:	2000      	movhi	r0, #0
  153244:	2001      	movls	r0, #1
  153246:	4770      	bx	r14
  153248:	2001      	movs	r0, #1
}
  15324a:	4770      	bx	r14

0015324c <isxdigit>:
    return isalpha(c) || isdigit(c);
}

int isxdigit(int c)
{
    return isdigit(c) || ((c >= 'a') && (c <= 'f')) || ((c >= 'A') && (c <= 'F'));
  15324c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
  153250:	2b09      	cmp	r3, #9
  153252:	d907      	bls.n	153264 <isxdigit+0x18>
  153254:	f020 0020 	bic.w	r0, r0, #32
  153258:	3841      	subs	r0, #65	; 0x41
  15325a:	2805      	cmp	r0, #5
  15325c:	bf8c      	ite	hi
  15325e:	2000      	movhi	r0, #0
  153260:	2001      	movls	r0, #1
  153262:	4770      	bx	r14
  153264:	2001      	movs	r0, #1
}
  153266:	4770      	bx	r14

00153268 <isprint>:
    return ((c < ' ') || (c == 0x7f));
}

int isprint(int c)
{
    return ((c >= 0x20) && (c < 0x7f));
  153268:	3820      	subs	r0, #32
}
  15326a:	285e      	cmp	r0, #94	; 0x5e
  15326c:	bf8c      	ite	hi
  15326e:	2000      	movhi	r0, #0
  153270:	2001      	movls	r0, #1
  153272:	4770      	bx	r14

00153274 <_vsnprintf_output>:
static int _vsnprintf_output(const char *str, size_t len, void *state)
{
    struct _output_args *args = state;

    size_t count = 0;
    while (count < len) {
  153274:	b191      	cbz	r1, 15329c <_vsnprintf_output+0x28>
{
  153276:	b4f0      	push	{r4, r5, r6, r7}
  153278:	1847      	adds	r7, r0, r1
        if (args->pos < args->len) {
  15327a:	e9d2 5401 	ldrd	r5, r4, [r2, #4]
            args->outstr[args->pos++] = *str;
        }

        str++;
  15327e:	3001      	adds	r0, #1
        if (args->pos < args->len) {
  153280:	42ac      	cmp	r4, r5
            args->outstr[args->pos++] = *str;
  153282:	f104 0601 	add.w	r6, r4, #1
  153286:	bf3f      	itttt	cc
  153288:	6815      	ldrcc	r5, [r2, #0]
  15328a:	6096      	strcc	r6, [r2, #8]
  15328c:	f810 6c01 	ldrbcc.w	r6, [r0, #-1]
  153290:	552e      	strbcc	r6, [r5, r4]
    while (count < len) {
  153292:	42b8      	cmp	r0, r7
  153294:	d1f1      	bne.n	15327a <_vsnprintf_output+0x6>
        count++;
    }

    return count;
}
  153296:	4608      	mov	r0, r1
  153298:	bcf0      	pop	{r4, r5, r6, r7}
  15329a:	4770      	bx	r14
  15329c:	4608      	mov	r0, r1
  15329e:	4770      	bx	r14

001532a0 <longlong_to_string>:
#define LEFTFORMATFLAG 0x00000800
#define LEADZEROFLAG   0x00001000
#define BLANKPOSFLAG   0x00002000

__NO_INLINE static char *longlong_to_string(char *buf, unsigned long long n, size_t len, uint flag, char *signchar)
{
  1532a0:	e92d 4ff8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1532a4:	f8dd 902c 	ldr.w	r9, [r13, #44]	; 0x2c
  1532a8:	4680      	mov	r8, r0
  1532aa:	4614      	mov	r4, r2
  1532ac:	461d      	mov	r5, r3
  1532ae:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    size_t pos = len;
    int negative = 0;

    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  1532b0:	f419 6a80 	ands.w	r10, r9, #1024	; 0x400
  1532b4:	d006      	beq.n	1532c4 <longlong_to_string+0x24>
  1532b6:	2a00      	cmp	r2, #0
  1532b8:	f175 0300 	sbcs.w	r3, r5, #0
    int negative = 0;
  1532bc:	bfa8      	it	ge
  1532be:	f04f 0a00 	movge.w	r10, #0
    if ((flag & SIGNEDFLAG) && (long long)n < 0) {
  1532c2:	db44      	blt.n	15334e <longlong_to_string+0xae>
    }

    buf[--pos] = 0;

    /* only do the math if the number is >= 10 */
    while (n >= 10) {
  1532c4:	2d00      	cmp	r5, #0
    buf[--pos] = 0;
  1532c6:	f04f 0300 	mov.w	r3, #0
  1532ca:	f107 37ff 	add.w	r7, r7, #4294967295	; 0xffffffff
    while (n >= 10) {
  1532ce:	bf08      	it	eq
  1532d0:	2c0a      	cmpeq	r4, #10
    buf[--pos] = 0;
  1532d2:	f808 3007 	strb.w	r3, [r8, r7]
  1532d6:	eb08 0b07 	add.w	r11, r8, r7
    while (n >= 10) {
  1532da:	d316      	bcc.n	15330a <longlong_to_string+0x6a>
        int digit = n % 10;
  1532dc:	4620      	mov	r0, r4
  1532de:	4629      	mov	r1, r5
  1532e0:	220a      	movs	r2, #10
  1532e2:	2300      	movs	r3, #0
  1532e4:	f001 fb26 	bl	154934 <__aeabi_uldivmod>

        n /= 10;
  1532e8:	4620      	mov	r0, r4
  1532ea:	4629      	mov	r1, r5
  1532ec:	2300      	movs	r3, #0

        buf[--pos] = digit + '0';
  1532ee:	3f01      	subs	r7, #1
        int digit = n % 10;
  1532f0:	4616      	mov	r6, r2
        n /= 10;
  1532f2:	220a      	movs	r2, #10
  1532f4:	f001 fb1e 	bl	154934 <__aeabi_uldivmod>
        buf[--pos] = digit + '0';
  1532f8:	3630      	adds	r6, #48	; 0x30
  1532fa:	f80b 6d01 	strb.w	r6, [r11, #-1]!
        n /= 10;
  1532fe:	4604      	mov	r4, r0
    while (n >= 10) {
  153300:	2900      	cmp	r1, #0
        n /= 10;
  153302:	460d      	mov	r5, r1
    while (n >= 10) {
  153304:	bf08      	it	eq
  153306:	280a      	cmpeq	r0, #10
  153308:	d2e8      	bcs.n	1532dc <longlong_to_string+0x3c>
    }
    buf[--pos] = n + '0';
  15330a:	3f01      	subs	r7, #1
  15330c:	3430      	adds	r4, #48	; 0x30
  15330e:	eb08 0007 	add.w	r0, r8, r7
  153312:	f808 4007 	strb.w	r4, [r8, r7]

    if (negative)
  153316:	f1ba 0f00 	cmp.w	r10, #0
  15331a:	d113      	bne.n	153344 <longlong_to_string+0xa4>
        *signchar = '-';
    else if ((flag & SHOWSIGNFLAG))
  15331c:	f419 7f00 	tst.w	r9, #512	; 0x200
  153320:	d10b      	bne.n	15333a <longlong_to_string+0x9a>
        *signchar = '+';
    else if ((flag & BLANKPOSFLAG))
  153322:	f419 5f00 	tst.w	r9, #8192	; 0x2000
        *signchar = ' ';
  153326:	bf1b      	ittet	ne
  153328:	2320      	movne	r3, #32
  15332a:	9a0c      	ldrne	r2, [sp, #48]	; 0x30
    else
        *signchar = '\0';
  15332c:	9b0c      	ldreq	r3, [sp, #48]	; 0x30
        *signchar = ' ';
  15332e:	7013      	strbne	r3, [r2, #0]
        *signchar = '\0';
  153330:	bf08      	it	eq
  153332:	f883 a000 	strbeq.w	r10, [r3]

    return &buf[pos];
}
  153336:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '+';
  15333a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  15333c:	232b      	movs	r3, #43	; 0x2b
  15333e:	7013      	strb	r3, [r2, #0]
}
  153340:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        *signchar = '-';
  153344:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  153346:	232d      	movs	r3, #45	; 0x2d
  153348:	7013      	strb	r3, [r2, #0]
}
  15334a:	e8bd 8ff8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r10, r11, r15}
        negative = 1;
  15334e:	f04f 0a01 	mov.w	r10, #1
        n = -n;
  153352:	4254      	negs	r4, r2
  153354:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
  153358:	e7b4      	b.n	1532c4 <longlong_to_string+0x24>
  15335a:	bf00      	nop

0015335c <exponent_to_string>:
__NO_INLINE static size_t exponent_to_string(char *buf, int32_t exponent)
{
    size_t pos = 0;

    /* handle sign */
    if (exponent < 0) {
  15335c:	2900      	cmp	r1, #0
        OUT('-');
  15335e:	bfba      	itte	lt
  153360:	232d      	movlt	r3, #45	; 0x2d
        exponent = -exponent;
  153362:	4249      	neglt	r1, r1
    }
    else {
        OUT('+');
  153364:	232b      	movge	r3, #43	; 0x2b
    }

    /* see how far we need to bump into the string to print from the right */
    if (exponent >= 1000) pos += 4;
  153366:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
{
  15336a:	b4f0      	push	{r4, r5, r6, r7}
        OUT('+');
  15336c:	7003      	strb	r3, [r0, #0]
{
  15336e:	4605      	mov	r5, r0
    if (exponent >= 1000) pos += 4;
  153370:	bfa8      	it	ge
  153372:	2005      	movge	r0, #5
  153374:	da03      	bge.n	15337e <exponent_to_string+0x22>
    else if (exponent >= 100) pos += 3;
  153376:	2963      	cmp	r1, #99	; 0x63
  153378:	bfc8      	it	gt
  15337a:	2004      	movgt	r0, #4
  15337c:	dd1a      	ble.n	1533b4 <exponent_to_string+0x58>
    else pos++;

    /* print decimal string, from the right */
    uint i = pos;
    do {
        uint digit = (uint32_t)exponent % 10;
  15337e:	f64c 47cd 	movw	r7, #52429	; 0xcccd

        buf[--i] = digit + '0';

        exponent /= 10;
  153382:	f246 6667 	movw	r6, #26215	; 0x6667
  153386:	4405      	add	r5, r0
        uint digit = (uint32_t)exponent % 10;
  153388:	f6cc 47cc 	movt	r7, #52428	; 0xcccc
        exponent /= 10;
  15338c:	f2c6 6666 	movt	r6, #26214	; 0x6666
        uint digit = (uint32_t)exponent % 10;
  153390:	fba7 2301 	umull	r2, r3, r7, r1
        exponent /= 10;
  153394:	fb86 2401 	smull	r2, r4, r6, r1
        uint digit = (uint32_t)exponent % 10;
  153398:	08db      	lsrs	r3, r3, #3
        exponent /= 10;
  15339a:	17ca      	asrs	r2, r1, #31
        uint digit = (uint32_t)exponent % 10;
  15339c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  1533a0:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
        buf[--i] = digit + '0';
  1533a4:	3130      	adds	r1, #48	; 0x30
  1533a6:	f805 1d01 	strb.w	r1, [r5, #-1]!
    }
    while (exponent != 0);
  1533aa:	ebd2 01a4 	rsbs	r1, r2, r4, asr #2
  1533ae:	d1ef      	bne.n	153390 <exponent_to_string+0x34>

    /* return number of characters printed */
    return pos;
}
  1533b0:	bcf0      	pop	{r4, r5, r6, r7}
  1533b2:	4770      	bx	r14
    else pos++;
  1533b4:	2909      	cmp	r1, #9
  1533b6:	bfcc      	ite	gt
  1533b8:	2003      	movgt	r0, #3
  1533ba:	2002      	movle	r0, #2
  1533bc:	e7df      	b.n	15337e <exponent_to_string+0x22>
  1533be:	bf00      	nop

001533c0 <double_to_hexstring.isra.0>:

    buf[pos] = 0;
    return buf;
}

__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  1533c0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1533c4:	ec57 6b10 	vmov	r6, r7, d0
  1533c8:	4605      	mov	r5, r0
{
    size_t pos = 0;
    union double_int u = { d };

    uint32_t exponent = (u.i >> 52) & 0x7ff;
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  1533ca:	f64f 79ff 	movw	r9, #65535	; 0xffff
__NO_INLINE static char *double_to_hexstring(char *buf, size_t len, double d, uint flag)
  1533ce:	b085      	sub	sp, #20
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  1533d0:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
  1533d4:	f401 7180 	and.w	r1, r1, #256	; 0x100
    bool neg = !!(u.i & (1ULL << 63));

    /* start constructing the string */
    if (neg) {
  1533d8:	2e00      	cmp	r6, #0
  1533da:	f177 0300 	sbcs.w	r3, r7, #0
        OUT('-');
  1533de:	bfb8      	it	lt
  1533e0:	222d      	movlt	r2, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  1533e2:	f3c7 500a 	ubfx	r0, r7, #20, #11
        OUT('-');
  1533e6:	bfb6      	itet	lt
  1533e8:	2301      	movlt	r3, #1
    size_t pos = 0;
  1533ea:	2300      	movge	r3, #0
        OUT('-');
  1533ec:	702a      	strblt	r2, [r5, #0]
    }

    /* look for special cases */
    if (exponent == 0x7ff) {
  1533ee:	f240 72ff 	movw	r2, #2047	; 0x7ff
  1533f2:	4290      	cmp	r0, r2
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  1533f4:	f2c0 090f 	movt	r9, #15
  1533f8:	ea06 0a08 	and.w	r10, r6, r8
  1533fc:	9101      	str	r1, [sp, #4]
  1533fe:	ea07 0b09 	and.w	r11, r7, r9
    if (exponent == 0x7ff) {
  153402:	f000 8097 	beq.w	153534 <double_to_hexstring.isra.0+0x174>
            /* NaN */
            if (flag & CAPSFLAG) OUTSTR("NAN");
            else OUTSTR("nan");
        }
    }
    else if (exponent == 0) {
  153406:	b9f0      	cbnz	r0, 153446 <double_to_hexstring.isra.0+0x86>
        if (fraction == 0) {
  153408:	ea5a 020b 	orrs.w	r2, r10, r11
            /* zero */
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  15340c:	9a01      	ldr	r2, [sp, #4]
        if (fraction == 0) {
  15340e:	f000 80d5 	beq.w	1535bc <double_to_hexstring.isra.0+0x1fc>
            else OUTSTR("0x0p+0");
        }
        else {
            /* denormalized */
            /* XXX does not handle */
            if (flag & CAPSFLAG) OUTSTR("DEN");
  153412:	2a00      	cmp	r2, #0
  153414:	f040 810f 	bne.w	153636 <double_to_hexstring.isra.0+0x276>
            else OUTSTR("den");
  153418:	2064      	movs	r0, #100	; 0x64
  15341a:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("DEN");
  15341c:	2265      	movs	r2, #101	; 0x65
            else OUTSTR("den");
  15341e:	3301      	adds	r3, #1
  153420:	4c95      	ldr	r4, [pc, #596]	; (153678 <double_to_hexstring.isra.0+0x2b8>)
  153422:	f801 0b01 	strb.w	r0, [r1], #1
  153426:	b13a      	cbz	r2, 153438 <double_to_hexstring.isra.0+0x78>
  153428:	4610      	mov	r0, r2
  15342a:	3301      	adds	r3, #1
  15342c:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  153430:	f801 0b01 	strb.w	r0, [r1], #1
  153434:	2a00      	cmp	r2, #0
  153436:	d1f7      	bne.n	153428 <double_to_hexstring.isra.0+0x68>
        /* handle the exponent */
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
        pos += exponent_to_string(&buf[pos], exponent_signed);
    }

    buf[pos] = 0;
  153438:	2200      	movs	r2, #0
  15343a:	442b      	add	r3, r5
    return buf;
}
  15343c:	4628      	mov	r0, r5
    buf[pos] = 0;
  15343e:	701a      	strb	r2, [r3, #0]
}
  153440:	b005      	add	sp, #20
  153442:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        int exponent_signed = exponent - 1023;
  153446:	f2a0 32ff 	subw	r2, r0, #1023	; 0x3ff
  15344a:	9203      	str	r2, [sp, #12]
        if (flag & CAPSFLAG) OUTSTR("0X1");
  15344c:	9a01      	ldr	r2, [sp, #4]
  15344e:	2a00      	cmp	r2, #0
  153450:	f000 809e 	beq.w	153590 <double_to_hexstring.isra.0+0x1d0>
  153454:	2030      	movs	r0, #48	; 0x30
  153456:	18e9      	adds	r1, r5, r3
  153458:	2258      	movs	r2, #88	; 0x58
  15345a:	3301      	adds	r3, #1
  15345c:	4c87      	ldr	r4, [pc, #540]	; (15367c <double_to_hexstring.isra.0+0x2bc>)
  15345e:	f801 0b01 	strb.w	r0, [r1], #1
  153462:	b13a      	cbz	r2, 153474 <double_to_hexstring.isra.0+0xb4>
  153464:	4610      	mov	r0, r2
  153466:	3301      	adds	r3, #1
  153468:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  15346c:	f801 0b01 	strb.w	r0, [r1], #1
  153470:	2a00      	cmp	r2, #0
  153472:	d1f7      	bne.n	153464 <double_to_hexstring.isra.0+0xa4>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  153474:	f648 02d4 	movw	r2, #35028	; 0x88d4
  153478:	f2c0 0215 	movt	r2, #21
  15347c:	9202      	str	r2, [sp, #8]
        bool output_dot = false;
  15347e:	f04f 0900 	mov.w	r9, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  153482:	2130      	movs	r1, #48	; 0x30
        int zero_count = 0;
  153484:	464e      	mov	r6, r9
                    OUT('0');
  153486:	468c      	mov	r12, r1
  153488:	e002      	b.n	153490 <double_to_hexstring.isra.0+0xd0>
        for (int i = 52 - 4; i >= 0; i -= 4) {
  15348a:	3904      	subs	r1, #4
  15348c:	1d0a      	adds	r2, r1, #4
  15348e:	d045      	beq.n	15351c <double_to_hexstring.isra.0+0x15c>
            uint digit = (fraction >> i) & 0xf;
  153490:	f1c1 0420 	rsb	r4, r1, #32
  153494:	fa0b f404 	lsl.w	r4, r11, r4
  153498:	fa2a f201 	lsr.w	r2, r10, r1
  15349c:	f1a1 0020 	sub.w	r0, r1, #32
  1534a0:	4322      	orrs	r2, r4
  1534a2:	fa2b f000 	lsr.w	r0, r11, r0
  1534a6:	4302      	orrs	r2, r0
            if (digit == 0) {
  1534a8:	f012 020f 	ands.w	r2, r2, #15
  1534ac:	f103 0401 	add.w	r4, r3, #1
  1534b0:	eb05 0004 	add.w	r0, r5, r4
  1534b4:	eb05 0e03 	add.w	r14, r5, r3
                zero_count++;
  1534b8:	bf08      	it	eq
  1534ba:	3601      	addeq	r6, #1
            if (digit == 0) {
  1534bc:	d0e5      	beq.n	15348a <double_to_hexstring.isra.0+0xca>
  1534be:	1c9f      	adds	r7, r3, #2
  1534c0:	eb05 0807 	add.w	r8, r5, r7
                if (!output_dot) {
  1534c4:	f1b9 0f00 	cmp.w	r9, #0
  1534c8:	d10c      	bne.n	1534e4 <double_to_hexstring.isra.0+0x124>
  1534ca:	f103 0903 	add.w	r9, r3, #3
                    OUT('.');
  1534ce:	f04f 032e 	mov.w	r3, #46	; 0x2e
  1534d2:	f88e 3000 	strb.w	r3, [r14]
  1534d6:	4623      	mov	r3, r4
  1534d8:	4686      	mov	r14, r0
  1534da:	463c      	mov	r4, r7
  1534dc:	4640      	mov	r0, r8
  1534de:	464f      	mov	r7, r9
  1534e0:	eb05 0809 	add.w	r8, r5, r9
                while (zero_count > 0) {
  1534e4:	2e00      	cmp	r6, #0
  1534e6:	d079      	beq.n	1535dc <double_to_hexstring.isra.0+0x21c>
  1534e8:	19ac      	adds	r4, r5, r6
  1534ea:	441c      	add	r4, r3
  1534ec:	18e8      	adds	r0, r5, r3
                    OUT('0');
  1534ee:	f800 cb01 	strb.w	r12, [r0], #1
                while (zero_count > 0) {
  1534f2:	4284      	cmp	r4, r0
  1534f4:	d1fb      	bne.n	1534ee <double_to_hexstring.isra.0+0x12e>
  1534f6:	441e      	add	r6, r3
  1534f8:	19a8      	adds	r0, r5, r6
  1534fa:	1c73      	adds	r3, r6, #1
  1534fc:	9000      	str	r0, [sp, #0]
  1534fe:	1cb4      	adds	r4, r6, #2
  153500:	eb05 0e03 	add.w	r14, r5, r3
  153504:	1928      	adds	r0, r5, r4
                buf[pos++] = table[digit];
  153506:	9f02      	ldr	r7, [sp, #8]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  153508:	3904      	subs	r1, #4
                buf[pos++] = table[digit];
  15350a:	5cba      	ldrb	r2, [r7, r2]
  15350c:	9f00      	ldr	r7, [sp, #0]
  15350e:	703a      	strb	r2, [r7, #0]
        for (int i = 52 - 4; i >= 0; i -= 4) {
  153510:	1d0a      	adds	r2, r1, #4
                buf[pos++] = table[digit];
  153512:	f04f 0901 	mov.w	r9, #1
  153516:	f04f 0600 	mov.w	r6, #0
        for (int i = 52 - 4; i >= 0; i -= 4) {
  15351a:	d1b9      	bne.n	153490 <double_to_hexstring.isra.0+0xd0>
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  15351c:	9b01      	ldr	r3, [sp, #4]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  15351e:	9903      	ldr	r1, [sp, #12]
        buf[pos++] = (flag & CAPSFLAG) ? 'P' : 'p';
  153520:	2b00      	cmp	r3, #0
  153522:	bf0c      	ite	eq
  153524:	2370      	moveq	r3, #112	; 0x70
  153526:	2350      	movne	r3, #80	; 0x50
  153528:	f88e 3000 	strb.w	r3, [r14]
        pos += exponent_to_string(&buf[pos], exponent_signed);
  15352c:	f7ff ff16 	bl	15335c <exponent_to_string>
  153530:	1903      	adds	r3, r0, r4
  153532:	e781      	b.n	153438 <double_to_hexstring.isra.0+0x78>
        if (fraction == 0) {
  153534:	ea5a 020b 	orrs.w	r2, r10, r11
  153538:	d114      	bne.n	153564 <double_to_hexstring.isra.0+0x1a4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  15353a:	2900      	cmp	r1, #0
  15353c:	d155      	bne.n	1535ea <double_to_hexstring.isra.0+0x22a>
            else OUTSTR("inf");
  15353e:	2069      	movs	r0, #105	; 0x69
  153540:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("INF");
  153542:	226e      	movs	r2, #110	; 0x6e
            else OUTSTR("inf");
  153544:	3301      	adds	r3, #1
  153546:	4c4e      	ldr	r4, [pc, #312]	; (153680 <double_to_hexstring.isra.0+0x2c0>)
  153548:	f801 0b01 	strb.w	r0, [r1], #1
  15354c:	2a00      	cmp	r2, #0
  15354e:	f43f af73 	beq.w	153438 <double_to_hexstring.isra.0+0x78>
  153552:	4610      	mov	r0, r2
  153554:	3301      	adds	r3, #1
  153556:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  15355a:	f801 0b01 	strb.w	r0, [r1], #1
  15355e:	2a00      	cmp	r2, #0
  153560:	d1f7      	bne.n	153552 <double_to_hexstring.isra.0+0x192>
  153562:	e769      	b.n	153438 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  153564:	9a01      	ldr	r2, [sp, #4]
  153566:	2a00      	cmp	r2, #0
  153568:	d152      	bne.n	153610 <double_to_hexstring.isra.0+0x250>
            else OUTSTR("nan");
  15356a:	206e      	movs	r0, #110	; 0x6e
  15356c:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("NAN");
  15356e:	2261      	movs	r2, #97	; 0x61
            else OUTSTR("nan");
  153570:	3301      	adds	r3, #1
  153572:	4c44      	ldr	r4, [pc, #272]	; (153684 <double_to_hexstring.isra.0+0x2c4>)
  153574:	f801 0b01 	strb.w	r0, [r1], #1
  153578:	2a00      	cmp	r2, #0
  15357a:	f43f af5d 	beq.w	153438 <double_to_hexstring.isra.0+0x78>
  15357e:	4610      	mov	r0, r2
  153580:	3301      	adds	r3, #1
  153582:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  153586:	f801 0b01 	strb.w	r0, [r1], #1
  15358a:	2a00      	cmp	r2, #0
  15358c:	d1f7      	bne.n	15357e <double_to_hexstring.isra.0+0x1be>
  15358e:	e753      	b.n	153438 <double_to_hexstring.isra.0+0x78>
        else OUTSTR("0x1");
  153590:	2030      	movs	r0, #48	; 0x30
  153592:	18e9      	adds	r1, r5, r3
        if (flag & CAPSFLAG) OUTSTR("0X1");
  153594:	2278      	movs	r2, #120	; 0x78
        else OUTSTR("0x1");
  153596:	3301      	adds	r3, #1
  153598:	4c3b      	ldr	r4, [pc, #236]	; (153688 <double_to_hexstring.isra.0+0x2c8>)
  15359a:	f801 0b01 	strb.w	r0, [r1], #1
  15359e:	b13a      	cbz	r2, 1535b0 <double_to_hexstring.isra.0+0x1f0>
  1535a0:	4610      	mov	r0, r2
  1535a2:	3301      	adds	r3, #1
  1535a4:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  1535a8:	f801 0b01 	strb.w	r0, [r1], #1
  1535ac:	2a00      	cmp	r2, #0
  1535ae:	d1f7      	bne.n	1535a0 <double_to_hexstring.isra.0+0x1e0>
        const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  1535b0:	f648 02c4 	movw	r2, #35012	; 0x88c4
  1535b4:	f2c0 0215 	movt	r2, #21
  1535b8:	9202      	str	r2, [sp, #8]
  1535ba:	e760      	b.n	15347e <double_to_hexstring.isra.0+0xbe>
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  1535bc:	2a00      	cmp	r2, #0
  1535be:	d14d      	bne.n	15365c <double_to_hexstring.isra.0+0x29c>
  1535c0:	4c32      	ldr	r4, [pc, #200]	; (15368c <double_to_hexstring.isra.0+0x2cc>)
  1535c2:	18e9      	adds	r1, r5, r3
  1535c4:	2278      	movs	r2, #120	; 0x78
            else OUTSTR("0x0p+0");
  1535c6:	2030      	movs	r0, #48	; 0x30
  1535c8:	e002      	b.n	1535d0 <double_to_hexstring.isra.0+0x210>
  1535ca:	4610      	mov	r0, r2
  1535cc:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  1535d0:	f801 0b01 	strb.w	r0, [r1], #1
  1535d4:	3301      	adds	r3, #1
  1535d6:	2a00      	cmp	r2, #0
  1535d8:	d1f7      	bne.n	1535ca <double_to_hexstring.isra.0+0x20a>
  1535da:	e72d      	b.n	153438 <double_to_hexstring.isra.0+0x78>
                while (zero_count > 0) {
  1535dc:	f8cd e000 	str.w	r14, [r13]
  1535e0:	4623      	mov	r3, r4
  1535e2:	4686      	mov	r14, r0
  1535e4:	463c      	mov	r4, r7
  1535e6:	4640      	mov	r0, r8
  1535e8:	e78d      	b.n	153506 <double_to_hexstring.isra.0+0x146>
            if (flag & CAPSFLAG) OUTSTR("INF");
  1535ea:	2049      	movs	r0, #73	; 0x49
  1535ec:	18e9      	adds	r1, r5, r3
  1535ee:	224e      	movs	r2, #78	; 0x4e
  1535f0:	3301      	adds	r3, #1
  1535f2:	4c27      	ldr	r4, [pc, #156]	; (153690 <double_to_hexstring.isra.0+0x2d0>)
  1535f4:	f801 0b01 	strb.w	r0, [r1], #1
  1535f8:	2a00      	cmp	r2, #0
  1535fa:	f43f af1d 	beq.w	153438 <double_to_hexstring.isra.0+0x78>
  1535fe:	4610      	mov	r0, r2
  153600:	3301      	adds	r3, #1
  153602:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  153606:	f801 0b01 	strb.w	r0, [r1], #1
  15360a:	2a00      	cmp	r2, #0
  15360c:	d1f7      	bne.n	1535fe <double_to_hexstring.isra.0+0x23e>
  15360e:	e713      	b.n	153438 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  153610:	204e      	movs	r0, #78	; 0x4e
  153612:	18e9      	adds	r1, r5, r3
  153614:	2241      	movs	r2, #65	; 0x41
  153616:	3301      	adds	r3, #1
  153618:	4c1e      	ldr	r4, [pc, #120]	; (153694 <double_to_hexstring.isra.0+0x2d4>)
  15361a:	f801 0b01 	strb.w	r0, [r1], #1
  15361e:	2a00      	cmp	r2, #0
  153620:	f43f af0a 	beq.w	153438 <double_to_hexstring.isra.0+0x78>
  153624:	4610      	mov	r0, r2
  153626:	3301      	adds	r3, #1
  153628:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  15362c:	f801 0b01 	strb.w	r0, [r1], #1
  153630:	2a00      	cmp	r2, #0
  153632:	d1f7      	bne.n	153624 <double_to_hexstring.isra.0+0x264>
  153634:	e700      	b.n	153438 <double_to_hexstring.isra.0+0x78>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  153636:	2044      	movs	r0, #68	; 0x44
  153638:	18e9      	adds	r1, r5, r3
  15363a:	2245      	movs	r2, #69	; 0x45
  15363c:	3301      	adds	r3, #1
  15363e:	4c16      	ldr	r4, [pc, #88]	; (153698 <double_to_hexstring.isra.0+0x2d8>)
  153640:	f801 0b01 	strb.w	r0, [r1], #1
  153644:	2a00      	cmp	r2, #0
  153646:	f43f aef7 	beq.w	153438 <double_to_hexstring.isra.0+0x78>
  15364a:	4610      	mov	r0, r2
  15364c:	3301      	adds	r3, #1
  15364e:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  153652:	f801 0b01 	strb.w	r0, [r1], #1
  153656:	2a00      	cmp	r2, #0
  153658:	d1f7      	bne.n	15364a <double_to_hexstring.isra.0+0x28a>
  15365a:	e6ed      	b.n	153438 <double_to_hexstring.isra.0+0x78>
  15365c:	4c0f      	ldr	r4, [pc, #60]	; (15369c <double_to_hexstring.isra.0+0x2dc>)
  15365e:	18e9      	adds	r1, r5, r3
            if (flag & CAPSFLAG) OUTSTR("0X0P+0");
  153660:	2258      	movs	r2, #88	; 0x58
  153662:	2030      	movs	r0, #48	; 0x30
  153664:	e002      	b.n	15366c <double_to_hexstring.isra.0+0x2ac>
  153666:	4610      	mov	r0, r2
  153668:	f814 2f01 	ldrb.w	r2, [r4, #1]!
  15366c:	f801 0b01 	strb.w	r0, [r1], #1
  153670:	3301      	adds	r3, #1
  153672:	2a00      	cmp	r2, #0
  153674:	d1f7      	bne.n	153666 <double_to_hexstring.isra.0+0x2a6>
  153676:	e6df      	b.n	153438 <double_to_hexstring.isra.0+0x78>
  153678:	001588a1 	.word	0x001588a1
  15367c:	001588ad 	.word	0x001588ad
  153680:	00158881 	.word	0x00158881
  153684:	00158889 	.word	0x00158889
  153688:	001588a9 	.word	0x001588a9
  15368c:	00158891 	.word	0x00158891
  153690:	00158885 	.word	0x00158885
  153694:	0015888d 	.word	0x0015888d
  153698:	001588a5 	.word	0x001588a5
  15369c:	00158899 	.word	0x00158899

001536a0 <longlong_to_hexstring.constprop.1>:
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  1536a0:	e92d 08f0 	stmdb	r13!, {r4, r5, r6, r7, r11}
  1536a4:	9905      	ldr	r1, [sp, #20]
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  1536a6:	f648 07d4 	movw	r7, #35028	; 0x88d4
    buf[--pos] = 0;
  1536aa:	2500      	movs	r5, #0
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  1536ac:	f2c0 0715 	movt	r7, #21
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  1536b0:	4693      	mov	r11, r2
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  1536b2:	f411 7f80 	tst.w	r1, #256	; 0x100
  1536b6:	f648 01c4 	movw	r1, #35012	; 0x88c4
__NO_INLINE static char *longlong_to_hexstring(char *buf, unsigned long long u, size_t len, uint flag)
  1536ba:	469c      	mov	r12, r3
    const char *table = (flag & CAPSFLAG) ? hextable_caps : hextable;
  1536bc:	f2c0 0115 	movt	r1, #21
  1536c0:	bf08      	it	eq
  1536c2:	460f      	moveq	r7, r1
  1536c4:	f100 041e 	add.w	r4, r0, #30
    buf[--pos] = 0;
  1536c8:	77c5      	strb	r5, [r0, #31]
        u /= 16;
  1536ca:	ea4f 111b 	mov.w	r1, r11, lsr #4
  1536ce:	ea41 710c 	orr.w	r1, r1, r12, lsl #28
  1536d2:	ea4f 161c 	mov.w	r6, r12, lsr #4
  1536d6:	46b4      	mov	r12, r6
        unsigned int digit = u % 16;
  1536d8:	f00b 020f 	and.w	r2, r11, #15
        u /= 16;
  1536dc:	468b      	mov	r11, r1
        buf[--pos] = table[digit];
  1536de:	5cbd      	ldrb	r5, [r7, r2]
  1536e0:	4620      	mov	r0, r4
    while (u != 0);
  1536e2:	ea5b 030c 	orrs.w	r3, r11, r12
        buf[--pos] = table[digit];
  1536e6:	f804 5901 	strb.w	r5, [r4], #-1
    while (u != 0);
  1536ea:	d1ee      	bne.n	1536ca <longlong_to_hexstring.constprop.1+0x2a>
}
  1536ec:	e8bd 08f0 	ldmia.w	r13!, {r4, r5, r6, r7, r11}
  1536f0:	4770      	bx	r14
  1536f2:	bf00      	nop
  1536f4:	0000      	movs	r0, r0
	...

001536f8 <double_to_string.constprop.2>:
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  1536f8:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  1536fc:	ec57 6b10 	vmov	r6, r7, d0
  153700:	4604      	mov	r4, r0
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  153702:	f64f 7bff 	movw	r11, #65535	; 0xffff
  153706:	f04f 3aff 	mov.w	r10, #4294967295	; 0xffffffff
  15370a:	f2c0 0b0f 	movt	r11, #15
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  15370e:	ee10 8a10 	vmov	r8, s0
    if (neg) {
  153712:	2e00      	cmp	r6, #0
  153714:	f177 0000 	sbcs.w	r0, r7, #0
        OUT('-');
  153718:	bfb8      	it	lt
  15371a:	202d      	movlt	r0, #45	; 0x2d
    uint32_t exponent = (u.i >> 52) & 0x7ff;
  15371c:	f3c7 550a 	ubfx	r5, r7, #20, #11
  153720:	46b9      	mov	r9, r7
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  153722:	ea0b 0307 	and.w	r3, r11, r7
        OUT('-');
  153726:	bfb8      	it	lt
  153728:	7020      	strblt	r0, [r4, #0]
    if (exponent == 0x7ff) {
  15372a:	f240 70ff 	movw	r0, #2047	; 0x7ff
        OUT('-');
  15372e:	bfba      	itte	lt
  153730:	f04f 0c01 	movlt.w	r12, #1
        d = -d;
  153734:	f087 4700 	eorlt.w	r7, r7, #2147483648	; 0x80000000
    size_t pos = 0;
  153738:	f04f 0c00 	movge.w	r12, #0
    if (exponent == 0x7ff) {
  15373c:	4285      	cmp	r5, r0
__NO_INLINE static char *double_to_string(char *buf, size_t len, double d, uint flag)
  15373e:	b089      	sub	sp, #36	; 0x24
    uint64_t fraction = (u.i & ((1ULL << 52) - 1));
  153740:	ea0a 0206 	and.w	r2, r10, r6
    if (exponent == 0x7ff) {
  153744:	d033      	beq.n	1537ae <double_to_string.constprop.2+0xb6>
    else if (exponent == 0) {
  153746:	b9f5      	cbnz	r5, 153786 <double_to_string.constprop.2+0x8e>
        if (fraction == 0) {
  153748:	4313      	orrs	r3, r2
  15374a:	d059      	beq.n	153800 <double_to_string.constprop.2+0x108>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  15374c:	05cb      	lsls	r3, r1, #23
  15374e:	f100 80ce 	bmi.w	1538ee <double_to_string.constprop.2+0x1f6>
            else OUTSTR("den");
  153752:	2164      	movs	r1, #100	; 0x64
  153754:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("DEN");
  153758:	2365      	movs	r3, #101	; 0x65
            else OUTSTR("den");
  15375a:	f10c 0c01 	add.w	r12, r12, #1
  15375e:	488c      	ldr	r0, [pc, #560]	; (153990 <double_to_string.constprop.2+0x298>)
  153760:	f802 1b01 	strb.w	r1, [r2], #1
  153764:	b143      	cbz	r3, 153778 <double_to_string.constprop.2+0x80>
  153766:	4619      	mov	r1, r3
  153768:	f10c 0c01 	add.w	r12, r12, #1
  15376c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  153770:	f802 1b01 	strb.w	r1, [r2], #1
  153774:	2b00      	cmp	r3, #0
  153776:	d1f6      	bne.n	153766 <double_to_string.constprop.2+0x6e>
    buf[pos] = 0;
  153778:	2300      	movs	r3, #0
  15377a:	4620      	mov	r0, r4
  15377c:	f804 300c 	strb.w	r3, [r4, r12]
}
  153780:	b009      	add	sp, #36	; 0x24
  153782:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        if (exponent_signed < -52 || exponent_signed > 52) {
  153786:	f2a5 30cb 	subw	r0, r5, #971	; 0x3cb
  15378a:	2868      	cmp	r0, #104	; 0x68
  15378c:	d948      	bls.n	153820 <double_to_string.constprop.2+0x128>
  15378e:	4881      	ldr	r0, [pc, #516]	; (153994 <double_to_string.constprop.2+0x29c>)
  153790:	eb04 020c 	add.w	r2, r4, r12
  153794:	2372      	movs	r3, #114	; 0x72
            OUTSTR("<range>");
  153796:	213c      	movs	r1, #60	; 0x3c
  153798:	e002      	b.n	1537a0 <double_to_string.constprop.2+0xa8>
  15379a:	4619      	mov	r1, r3
  15379c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1537a0:	f802 1b01 	strb.w	r1, [r2], #1
  1537a4:	f10c 0c01 	add.w	r12, r12, #1
  1537a8:	2b00      	cmp	r3, #0
  1537aa:	d1f6      	bne.n	15379a <double_to_string.constprop.2+0xa2>
  1537ac:	e7e4      	b.n	153778 <double_to_string.constprop.2+0x80>
        if (fraction == 0) {
  1537ae:	4313      	orrs	r3, r2
  1537b0:	f401 7180 	and.w	r1, r1, #256	; 0x100
  1537b4:	d112      	bne.n	1537dc <double_to_string.constprop.2+0xe4>
            if (flag & CAPSFLAG) OUTSTR("INF");
  1537b6:	2900      	cmp	r1, #0
  1537b8:	f040 8089 	bne.w	1538ce <double_to_string.constprop.2+0x1d6>
  1537bc:	4876      	ldr	r0, [pc, #472]	; (153998 <double_to_string.constprop.2+0x2a0>)
  1537be:	eb04 020c 	add.w	r2, r4, r12
  1537c2:	236e      	movs	r3, #110	; 0x6e
            else OUTSTR("inf");
  1537c4:	2169      	movs	r1, #105	; 0x69
  1537c6:	e002      	b.n	1537ce <double_to_string.constprop.2+0xd6>
  1537c8:	4619      	mov	r1, r3
  1537ca:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1537ce:	f802 1b01 	strb.w	r1, [r2], #1
  1537d2:	f10c 0c01 	add.w	r12, r12, #1
  1537d6:	2b00      	cmp	r3, #0
  1537d8:	d1f6      	bne.n	1537c8 <double_to_string.constprop.2+0xd0>
  1537da:	e7cd      	b.n	153778 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("NAN");
  1537dc:	2900      	cmp	r1, #0
  1537de:	d166      	bne.n	1538ae <double_to_string.constprop.2+0x1b6>
  1537e0:	486e      	ldr	r0, [pc, #440]	; (15399c <double_to_string.constprop.2+0x2a4>)
  1537e2:	eb04 020c 	add.w	r2, r4, r12
  1537e6:	2361      	movs	r3, #97	; 0x61
            else OUTSTR("nan");
  1537e8:	216e      	movs	r1, #110	; 0x6e
  1537ea:	e002      	b.n	1537f2 <double_to_string.constprop.2+0xfa>
  1537ec:	4619      	mov	r1, r3
  1537ee:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1537f2:	f802 1b01 	strb.w	r1, [r2], #1
  1537f6:	f10c 0c01 	add.w	r12, r12, #1
  1537fa:	2b00      	cmp	r3, #0
  1537fc:	d1f6      	bne.n	1537ec <double_to_string.constprop.2+0xf4>
  1537fe:	e7bb      	b.n	153778 <double_to_string.constprop.2+0x80>
  153800:	4867      	ldr	r0, [pc, #412]	; (1539a0 <double_to_string.constprop.2+0x2a8>)
  153802:	eb04 020c 	add.w	r2, r4, r12
        if (fraction == 0) {
  153806:	232e      	movs	r3, #46	; 0x2e
            OUTSTR("0.000000");
  153808:	2130      	movs	r1, #48	; 0x30
  15380a:	e002      	b.n	153812 <double_to_string.constprop.2+0x11a>
  15380c:	4619      	mov	r1, r3
  15380e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  153812:	f802 1b01 	strb.w	r1, [r2], #1
  153816:	f10c 0c01 	add.w	r12, r12, #1
  15381a:	2b00      	cmp	r3, #0
  15381c:	d1f6      	bne.n	15380c <double_to_string.constprop.2+0x114>
  15381e:	e7ab      	b.n	153778 <double_to_string.constprop.2+0x80>
            OUTREV(0);
  153820:	2000      	movs	r0, #0
  153822:	46a2      	mov	r10, r4
                OUTREV('0');
  153824:	f04f 0c30 	mov.w	r12, #48	; 0x30
  153828:	f104 0e18 	add.w	r14, r4, #24
            OUTREV(0);
  15382c:	f80a 0f1f 	strb.w	r0, [r10, #31]!
  153830:	4650      	mov	r0, r10
                OUTREV('0');
  153832:	f800 cd01 	strb.w	r12, [r0, #-1]!
            for (int i = 0; i <= 6; i++)
  153836:	4570      	cmp	r0, r14
  153838:	d1fb      	bne.n	153832 <double_to_string.constprop.2+0x13a>
        int exponent_signed = exponent - 1023;
  15383a:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
            if (exponent_signed >= 0) {
  15383e:	2d00      	cmp	r5, #0
                OUTREV('0');
  153840:	bfbc      	itt	lt
  153842:	2517      	movlt	r5, #23
  153844:	f884 c017 	strblt.w	r12, [r4, #23]
            if (exponent_signed >= 0) {
  153848:	da67      	bge.n	15391a <double_to_string.constprop.2+0x222>
            uint32_t frac = ((d - u) * 1000000) + .5;
  15384a:	ed9f 6b4f 	vldr	d6, [r15, #316]	; 153988 <double_to_string.constprop.2+0x290>
  15384e:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  153852:	ec47 6b15 	vmov	d5, r6, r7
            buf[decimal_spot] = '.';
  153856:	232e      	movs	r3, #46	; 0x2e
  153858:	7623      	strb	r3, [r4, #24]
            uint32_t frac = ((d - u) * 1000000) + .5;
  15385a:	ee05 7b06 	vmla.f64	d7, d5, d6
  15385e:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  153862:	ee17 3a90 	vmov	r3, s15
            while (frac != 0) {
  153866:	b18b      	cbz	r3, 15388c <double_to_string.constprop.2+0x194>
                uint digit = frac % 10;
  153868:	f64c 40cd 	movw	r0, #52429	; 0xcccd
  15386c:	f6cc 40cc 	movt	r0, #52428	; 0xcccc
  153870:	fba0 1203 	umull	r1, r2, r0, r3
  153874:	08d2      	lsrs	r2, r2, #3
  153876:	eb02 0182 	add.w	r1, r2, r2, lsl #2
  15387a:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
                buf[--i] = digit + '0';
  15387e:	f103 0130 	add.w	r1, r3, #48	; 0x30
            while (frac != 0) {
  153882:	4613      	mov	r3, r2
                buf[--i] = digit + '0';
  153884:	f80a 1d01 	strb.w	r1, [r10, #-1]!
            while (frac != 0) {
  153888:	2a00      	cmp	r2, #0
  15388a:	d1f1      	bne.n	153870 <double_to_string.constprop.2+0x178>
            if (neg)
  15388c:	f1b8 0f00 	cmp.w	r8, #0
  153890:	f179 0300 	sbcs.w	r3, r9, #0
  153894:	bfa8      	it	ge
  153896:	1960      	addge	r0, r4, r5
  153898:	f6bf af72 	bge.w	153780 <double_to_string.constprop.2+0x88>
                OUTREV('-');
  15389c:	4620      	mov	r0, r4
  15389e:	2d00      	cmp	r5, #0
  1538a0:	f43f af6e 	beq.w	153780 <double_to_string.constprop.2+0x88>
  1538a4:	232d      	movs	r3, #45	; 0x2d
  1538a6:	3d01      	subs	r5, #1
  1538a8:	1960      	adds	r0, r4, r5
  1538aa:	5563      	strb	r3, [r4, r5]
  1538ac:	e768      	b.n	153780 <double_to_string.constprop.2+0x88>
  1538ae:	483d      	ldr	r0, [pc, #244]	; (1539a4 <double_to_string.constprop.2+0x2ac>)
  1538b0:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("NAN");
  1538b4:	2341      	movs	r3, #65	; 0x41
  1538b6:	214e      	movs	r1, #78	; 0x4e
  1538b8:	e002      	b.n	1538c0 <double_to_string.constprop.2+0x1c8>
  1538ba:	4619      	mov	r1, r3
  1538bc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1538c0:	f802 1b01 	strb.w	r1, [r2], #1
  1538c4:	f10c 0c01 	add.w	r12, r12, #1
  1538c8:	2b00      	cmp	r3, #0
  1538ca:	d1f6      	bne.n	1538ba <double_to_string.constprop.2+0x1c2>
  1538cc:	e754      	b.n	153778 <double_to_string.constprop.2+0x80>
  1538ce:	4836      	ldr	r0, [pc, #216]	; (1539a8 <double_to_string.constprop.2+0x2b0>)
  1538d0:	eb04 020c 	add.w	r2, r4, r12
            if (flag & CAPSFLAG) OUTSTR("INF");
  1538d4:	234e      	movs	r3, #78	; 0x4e
  1538d6:	2149      	movs	r1, #73	; 0x49
  1538d8:	e002      	b.n	1538e0 <double_to_string.constprop.2+0x1e8>
  1538da:	4619      	mov	r1, r3
  1538dc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  1538e0:	f802 1b01 	strb.w	r1, [r2], #1
  1538e4:	f10c 0c01 	add.w	r12, r12, #1
  1538e8:	2b00      	cmp	r3, #0
  1538ea:	d1f6      	bne.n	1538da <double_to_string.constprop.2+0x1e2>
  1538ec:	e744      	b.n	153778 <double_to_string.constprop.2+0x80>
            if (flag & CAPSFLAG) OUTSTR("DEN");
  1538ee:	2144      	movs	r1, #68	; 0x44
  1538f0:	eb04 020c 	add.w	r2, r4, r12
  1538f4:	2345      	movs	r3, #69	; 0x45
  1538f6:	f10c 0c01 	add.w	r12, r12, #1
  1538fa:	482c      	ldr	r0, [pc, #176]	; (1539ac <double_to_string.constprop.2+0x2b4>)
  1538fc:	f802 1b01 	strb.w	r1, [r2], #1
  153900:	2b00      	cmp	r3, #0
  153902:	f43f af39 	beq.w	153778 <double_to_string.constprop.2+0x80>
  153906:	4619      	mov	r1, r3
  153908:	f10c 0c01 	add.w	r12, r12, #1
  15390c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
  153910:	f802 1b01 	strb.w	r1, [r2], #1
  153914:	2b00      	cmp	r3, #0
  153916:	d1f6      	bne.n	153906 <double_to_string.constprop.2+0x20e>
  153918:	e72e      	b.n	153778 <double_to_string.constprop.2+0x80>
                u |= (1ULL<<52);
  15391a:	4693      	mov	r11, r2
  15391c:	f443 1c80 	orr.w	r12, r3, #1048576	; 0x100000
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  153920:	f04f 0e19 	mov.w	r14, #25
                u >>= (52 - exponent_signed);
  153924:	f1c5 0534 	rsb	r5, r5, #52	; 0x34
  153928:	e9cd bc04 	strd	r11, r12, [r13, #16]
  15392c:	f1c5 0020 	rsb	r0, r5, #32
  153930:	9b05      	ldr	r3, [sp, #20]
  153932:	fa0c f000 	lsl.w	r0, r12, r0
  153936:	fa22 fb05 	lsr.w	r11, r2, r5
  15393a:	f1a5 0220 	sub.w	r2, r5, #32
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  15393e:	f10d 0c20 	add.w	r12, r13, #32
                u >>= (52 - exponent_signed);
  153942:	fa23 f202 	lsr.w	r2, r3, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  153946:	9101      	str	r1, [sp, #4]
                u >>= (52 - exponent_signed);
  153948:	ea4b 0b00 	orr.w	r11, r11, r0
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  15394c:	2000      	movs	r0, #0
                u >>= (52 - exponent_signed);
  15394e:	ea4b 0b02 	orr.w	r11, r11, r2
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  153952:	465a      	mov	r2, r11
                u >>= (52 - exponent_signed);
  153954:	40eb      	lsrs	r3, r5
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  153956:	f80c 0d01 	strb.w	r0, [r12, #-1]!
  15395a:	4620      	mov	r0, r4
  15395c:	f8cd c008 	str.w	r12, [r13, #8]
                u >>= (52 - exponent_signed);
  153960:	461d      	mov	r5, r3
                char *s = longlong_to_string(buf, u, pos + 1, flag, &(char) {0});
  153962:	f8cd e000 	str.w	r14, [r13]
  153966:	f7ff fc9b 	bl	1532a0 <longlong_to_string>
  15396a:	4629      	mov	r1, r5
                pos = s - buf;
  15396c:	1b05      	subs	r5, r0, r4
  15396e:	4658      	mov	r0, r11
  153970:	f000 ffaa 	bl	1548c8 <__aeabi_ul2d>
  153974:	ec47 6b17 	vmov	d7, r6, r7
  153978:	ec41 0b16 	vmov	d6, r0, r1
  15397c:	ee37 7b46 	vsub.f64	d7, d7, d6
  153980:	ec57 6b17 	vmov	r6, r7, d7
  153984:	e761      	b.n	15384a <double_to_string.constprop.2+0x152>
  153986:	bf00      	nop
  153988:	00000000 	.word	0x00000000
  15398c:	412e8480 	.word	0x412e8480
  153990:	001588a1 	.word	0x001588a1
  153994:	001588bd 	.word	0x001588bd
  153998:	00158881 	.word	0x00158881
  15399c:	00158889 	.word	0x00158889
  1539a0:	001588b1 	.word	0x001588b1
  1539a4:	0015888d 	.word	0x0015888d
  1539a8:	00158885 	.word	0x00158885
  1539ac:	001588a5 	.word	0x001588a5

001539b0 <_printf_engine>:
#include <kernel/spinlock.h>
static spin_lock_t printf_lock=SPIN_LOCK_INITIAL_VALUE;
#endif

int _printf_engine(_printf_engine_output_func out, void *state, const char *fmt, va_list ap)
{
  1539b0:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
                OUTPUT_CHAR(uc);
                break;
            case 's':
                s = va_arg(ap, const char *);
                if (s == 0)
                    s = "<null>";
  1539b4:	f648 0478 	movw	r4, #34936	; 0x8878
{
  1539b8:	b093      	sub	sp, #76	; 0x4c
  1539ba:	4607      	mov	r7, r0
                    s = "<null>";
  1539bc:	f2c0 0415 	movt	r4, #21
    size_t chars_written = 0;
  1539c0:	2600      	movs	r6, #0
{
  1539c2:	4688      	mov	r8, r1
  1539c4:	4610      	mov	r0, r2
  1539c6:	469b      	mov	r11, r3
                    s = "<null>";
  1539c8:	9406      	str	r4, [sp, #24]
        signchar = '\0';
  1539ca:	f04f 0300 	mov.w	r3, #0
        while ((c = *fmt++) != 0) {
  1539ce:	1c44      	adds	r4, r0, #1
  1539d0:	7801      	ldrb	r1, [r0, #0]
        signchar = '\0';
  1539d2:	f88d 3027 	strb.w	r3, [r13, #39]	; 0x27
        while ((c = *fmt++) != 0) {
  1539d6:	b149      	cbz	r1, 1539ec <_printf_engine+0x3c>
            if (c == '%')
  1539d8:	2925      	cmp	r1, #37	; 0x25
  1539da:	d102      	bne.n	1539e2 <_printf_engine+0x32>
  1539dc:	e010      	b.n	153a00 <_printf_engine+0x50>
  1539de:	2b25      	cmp	r3, #37	; 0x25
  1539e0:	d00f      	beq.n	153a02 <_printf_engine+0x52>
  1539e2:	1a21      	subs	r1, r4, r0
        while ((c = *fmt++) != 0) {
  1539e4:	f814 3b01 	ldrb.w	r3, [r4], #1
  1539e8:	2b00      	cmp	r3, #0
  1539ea:	d1f8      	bne.n	1539de <_printf_engine+0x2e>
        OUTPUT_STRING(s, string_len);
  1539ec:	4642      	mov	r2, r8
  1539ee:	47b8      	blx	r7
  1539f0:	f1b0 0c00 	subs.w	r12, r0, #0
  1539f4:	f280 80d0 	bge.w	153b98 <_printf_engine+0x1e8>
exit:
#if WITH_SMP
    spin_unlock_irqrestore(&printf_lock, sstate);
#endif
    return (err < 0) ? err : (int)chars_written;
}
  1539f8:	4660      	mov	r0, r12
  1539fa:	b013      	add	sp, #76	; 0x4c
  1539fc:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
        string_len = 0;
  153a00:	2100      	movs	r1, #0
        OUTPUT_STRING(s, string_len);
  153a02:	4642      	mov	r2, r8
  153a04:	47b8      	blx	r7
  153a06:	f1b0 0c00 	subs.w	r12, r0, #0
  153a0a:	dbf5      	blt.n	1539f8 <_printf_engine+0x48>
        format_num = 0;
  153a0c:	2500      	movs	r5, #0
        OUTPUT_STRING(s, string_len);
  153a0e:	4466      	add	r6, r12
        flags = 0;
  153a10:	46aa      	mov	r10, r5
        c = *fmt++;
  153a12:	f814 3b01 	ldrb.w	r3, [r4], #1
        if (c == 0)
  153a16:	2b00      	cmp	r3, #0
  153a18:	f000 80bf 	beq.w	153b9a <_printf_engine+0x1ea>
        switch (c) {
  153a1c:	f1a3 0220 	sub.w	r2, r3, #32
  153a20:	2a5a      	cmp	r2, #90	; 0x5a
  153a22:	f200 821d 	bhi.w	153e60 <_printf_engine+0x4b0>
  153a26:	a101      	add	r1, pc, #4	; (adr r1, 153a2c <_printf_engine+0x7c>)
  153a28:	f851 f022 	ldr.w	r15, [r1, r2, lsl #2]
  153a2c:	00153d51 	.word	0x00153d51
  153a30:	00153e61 	.word	0x00153e61
  153a34:	00153e61 	.word	0x00153e61
  153a38:	00153d7f 	.word	0x00153d7f
  153a3c:	00153e61 	.word	0x00153e61
  153a40:	00153d5d 	.word	0x00153d5d
  153a44:	00153e61 	.word	0x00153e61
  153a48:	00153e61 	.word	0x00153e61
  153a4c:	00153e61 	.word	0x00153e61
  153a50:	00153e61 	.word	0x00153e61
  153a54:	00153e61 	.word	0x00153e61
  153a58:	00153d79 	.word	0x00153d79
  153a5c:	00153e61 	.word	0x00153e61
  153a60:	00153d85 	.word	0x00153d85
  153a64:	00153a13 	.word	0x00153a13
  153a68:	00153e61 	.word	0x00153e61
  153a6c:	00153d8b 	.word	0x00153d8b
  153a70:	00153d8b 	.word	0x00153d8b
  153a74:	00153d8b 	.word	0x00153d8b
  153a78:	00153d8b 	.word	0x00153d8b
  153a7c:	00153d8b 	.word	0x00153d8b
  153a80:	00153d8b 	.word	0x00153d8b
  153a84:	00153d8b 	.word	0x00153d8b
  153a88:	00153d8b 	.word	0x00153d8b
  153a8c:	00153d8b 	.word	0x00153d8b
  153a90:	00153d8b 	.word	0x00153d8b
  153a94:	00153e61 	.word	0x00153e61
  153a98:	00153e61 	.word	0x00153e61
  153a9c:	00153e61 	.word	0x00153e61
  153aa0:	00153e61 	.word	0x00153e61
  153aa4:	00153e61 	.word	0x00153e61
  153aa8:	00153e61 	.word	0x00153e61
  153aac:	00153e61 	.word	0x00153e61
  153ab0:	00153ceb 	.word	0x00153ceb
  153ab4:	00153e61 	.word	0x00153e61
  153ab8:	00153e61 	.word	0x00153e61
  153abc:	00153e61 	.word	0x00153e61
  153ac0:	00153e61 	.word	0x00153e61
  153ac4:	00153c89 	.word	0x00153c89
  153ac8:	00153e61 	.word	0x00153e61
  153acc:	00153e61 	.word	0x00153e61
  153ad0:	00153e61 	.word	0x00153e61
  153ad4:	00153e61 	.word	0x00153e61
  153ad8:	00153e61 	.word	0x00153e61
  153adc:	00153e61 	.word	0x00153e61
  153ae0:	00153e61 	.word	0x00153e61
  153ae4:	00153e61 	.word	0x00153e61
  153ae8:	00153e61 	.word	0x00153e61
  153aec:	00153e61 	.word	0x00153e61
  153af0:	00153e61 	.word	0x00153e61
  153af4:	00153e61 	.word	0x00153e61
  153af8:	00153e61 	.word	0x00153e61
  153afc:	00153e61 	.word	0x00153e61
  153b00:	00153e61 	.word	0x00153e61
  153b04:	00153e61 	.word	0x00153e61
  153b08:	00153e61 	.word	0x00153e61
  153b0c:	00153e37 	.word	0x00153e37
  153b10:	00153e61 	.word	0x00153e61
  153b14:	00153e61 	.word	0x00153e61
  153b18:	00153e61 	.word	0x00153e61
  153b1c:	00153e61 	.word	0x00153e61
  153b20:	00153e61 	.word	0x00153e61
  153b24:	00153e61 	.word	0x00153e61
  153b28:	00153e61 	.word	0x00153e61
  153b2c:	00153e61 	.word	0x00153e61
  153b30:	00153cef 	.word	0x00153cef
  153b34:	00153e61 	.word	0x00153e61
  153b38:	00153da5 	.word	0x00153da5
  153b3c:	00153dc7 	.word	0x00153dc7
  153b40:	00153e61 	.word	0x00153e61
  153b44:	00153c8d 	.word	0x00153c8d
  153b48:	00153e61 	.word	0x00153e61
  153b4c:	00153e05 	.word	0x00153e05
  153b50:	00153dc7 	.word	0x00153dc7
  153b54:	00153e45 	.word	0x00153e45
  153b58:	00153e61 	.word	0x00153e61
  153b5c:	00153e4b 	.word	0x00153e4b
  153b60:	00153e61 	.word	0x00153e61
  153b64:	00153d11 	.word	0x00153d11
  153b68:	00153e61 	.word	0x00153e61
  153b6c:	00153ba5 	.word	0x00153ba5
  153b70:	00153e61 	.word	0x00153e61
  153b74:	00153e61 	.word	0x00153e61
  153b78:	00153de9 	.word	0x00153de9
  153b7c:	00153e5b 	.word	0x00153e5b
  153b80:	00153e15 	.word	0x00153e15
  153b84:	00153e61 	.word	0x00153e61
  153b88:	00153e61 	.word	0x00153e61
  153b8c:	00153ba9 	.word	0x00153ba9
  153b90:	00153e61 	.word	0x00153e61
  153b94:	00153d57 	.word	0x00153d57
        OUTPUT_STRING(s, string_len);
  153b98:	4466      	add	r6, r12
    return (err < 0) ? err : (int)chars_written;
  153b9a:	46b4      	mov	r12, r6
}
  153b9c:	4660      	mov	r0, r12
  153b9e:	b013      	add	sp, #76	; 0x4c
  153ba0:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= LONGFLAG | ALTFLAG;
  153ba4:	f04a 0a81 	orr.w	r10, r10, #129	; 0x81
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  153ba8:	f01a 0f02 	tst.w	r10, #2
  153bac:	f000 80be 	beq.w	153d2c <_printf_engine+0x37c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153bb0:	f10b 0307 	add.w	r3, r11, #7
  153bb4:	f023 0307 	bic.w	r3, r3, #7
  153bb8:	f103 0b08 	add.w	r11, r3, #8
  153bbc:	e9d3 2300 	ldrd	r2, r3, [r3]
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  153bc0:	f8cd a000 	str.w	r10, [r13]
  153bc4:	a80a      	add	r0, sp, #40	; 0x28
  153bc6:	f7ff fd6b 	bl	1536a0 <longlong_to_hexstring.constprop.1>
                if (flags & ALTFLAG) {
  153bca:	f01a 0f80 	tst.w	r10, #128	; 0x80
                s = longlong_to_hexstring(num_buffer, n, sizeof(num_buffer), flags);
  153bce:	9005      	str	r0, [sp, #20]
  153bd0:	4681      	mov	r9, r0
                if (flags & ALTFLAG) {
  153bd2:	f000 81b1 	beq.w	153f38 <_printf_engine+0x588>
                    OUTPUT_CHAR('0');
  153bd6:	2330      	movs	r3, #48	; 0x30
  153bd8:	4642      	mov	r2, r8
  153bda:	2101      	movs	r1, #1
  153bdc:	a809      	add	r0, sp, #36	; 0x24
  153bde:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  153be2:	47b8      	blx	r7
  153be4:	f1b0 0c00 	subs.w	r12, r0, #0
  153be8:	f6ff af06 	blt.w	1539f8 <_printf_engine+0x48>
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  153bec:	4642      	mov	r2, r8
  153bee:	f41a 7f80 	tst.w	r10, #256	; 0x100
  153bf2:	bf0c      	ite	eq
  153bf4:	2378      	moveq	r3, #120	; 0x78
  153bf6:	2358      	movne	r3, #88	; 0x58
  153bf8:	2101      	movs	r1, #1
  153bfa:	a809      	add	r0, sp, #36	; 0x24
  153bfc:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                    OUTPUT_CHAR('0');
  153c00:	4466      	add	r6, r12
                    OUTPUT_CHAR((flags & CAPSFLAG) ? 'X': 'x');
  153c02:	47b8      	blx	r7
  153c04:	f1b0 0c00 	subs.w	r12, r0, #0
  153c08:	f6ff aef6 	blt.w	1539f8 <_printf_engine+0x48>
  153c0c:	4648      	mov	r0, r9
  153c0e:	4466      	add	r6, r12
  153c10:	f000 fae4 	bl	1541dc <strlen>
        if (flags & LEFTFORMATFLAG) {
  153c14:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  153c18:	4681      	mov	r9, r0
  153c1a:	d14a      	bne.n	153cb2 <_printf_engine+0x302>
  153c1c:	f40a 5380 	and.w	r3, r10, #4096	; 0x1000
  153c20:	461a      	mov	r2, r3
  153c22:	9307      	str	r3, [sp, #28]
            if (signchar != '\0' && format_num > 0)
  153c24:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
  153c28:	b18b      	cbz	r3, 153c4e <_printf_engine+0x29e>
  153c2a:	2d00      	cmp	r5, #0
  153c2c:	f000 8143 	beq.w	153eb6 <_printf_engine+0x506>
                format_num--;
  153c30:	3d01      	subs	r5, #1
            if (flags & LEADZEROFLAG && signchar != '\0')
  153c32:	2a00      	cmp	r2, #0
  153c34:	f000 81d4 	beq.w	153fe0 <_printf_engine+0x630>
                OUTPUT_CHAR(signchar);
  153c38:	4642      	mov	r2, r8
  153c3a:	2101      	movs	r1, #1
  153c3c:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  153c40:	a809      	add	r0, sp, #36	; 0x24
  153c42:	47b8      	blx	r7
  153c44:	f1b0 0c00 	subs.w	r12, r0, #0
  153c48:	f6ff aed6 	blt.w	1539f8 <_printf_engine+0x48>
  153c4c:	4466      	add	r6, r12
            for (; format_num > string_len; format_num--)
  153c4e:	454d      	cmp	r5, r9
  153c50:	f240 811f 	bls.w	153e92 <_printf_engine+0x4e2>
  153c54:	9b07      	ldr	r3, [sp, #28]
  153c56:	2b00      	cmp	r3, #0
  153c58:	bf14      	ite	ne
  153c5a:	f04f 0a30 	movne.w	r10, #48	; 0x30
  153c5e:	f04f 0a20 	moveq.w	r10, #32
  153c62:	e002      	b.n	153c6a <_printf_engine+0x2ba>
  153c64:	454d      	cmp	r5, r9
  153c66:	f000 8114 	beq.w	153e92 <_printf_engine+0x4e2>
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  153c6a:	4642      	mov	r2, r8
  153c6c:	2101      	movs	r1, #1
  153c6e:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  153c72:	a809      	add	r0, sp, #36	; 0x24
  153c74:	47b8      	blx	r7
            for (; format_num > string_len; format_num--)
  153c76:	3d01      	subs	r5, #1
                OUTPUT_CHAR(flags & LEADZEROFLAG ? '0' : ' ');
  153c78:	2800      	cmp	r0, #0
  153c7a:	4406      	add	r6, r0
  153c7c:	daf2      	bge.n	153c64 <_printf_engine+0x2b4>
  153c7e:	4684      	mov	r12, r0
}
  153c80:	4660      	mov	r0, r12
  153c82:	b013      	add	sp, #76	; 0x4c
  153c84:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
                flags |= CAPSFLAG;
  153c88:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  153c8c:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  153c8e:	f10b 0b07 	add.w	r11, r11, #7
  153c92:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  153c96:	a80a      	add	r0, sp, #40	; 0x28
  153c98:	ed9b 0b00 	vldr	d0, [r11]
  153c9c:	f7ff fd2c 	bl	1536f8 <double_to_string.constprop.2>
                double d = va_arg(ap, double);
  153ca0:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_string(num_buffer, sizeof(num_buffer), d, flags);
  153ca4:	9005      	str	r0, [sp, #20]
  153ca6:	f000 fa99 	bl	1541dc <strlen>
  153caa:	4681      	mov	r9, r0
        if (flags & LEFTFORMATFLAG) {
  153cac:	f41a 6f00 	tst.w	r10, #2048	; 0x800
  153cb0:	d0b4      	beq.n	153c1c <_printf_engine+0x26c>
            OUTPUT_STRING(s, string_len);
  153cb2:	4649      	mov	r1, r9
  153cb4:	4642      	mov	r2, r8
  153cb6:	9805      	ldr	r0, [sp, #20]
  153cb8:	47b8      	blx	r7
  153cba:	f1b0 0c00 	subs.w	r12, r0, #0
  153cbe:	f6ff ae9b 	blt.w	1539f8 <_printf_engine+0x48>
  153cc2:	46e1      	mov	r9, r12
            for (; format_num > written; format_num--)
  153cc4:	45ac      	cmp	r12, r5
            OUTPUT_STRING(s, string_len);
  153cc6:	4466      	add	r6, r12
            for (; format_num > written; format_num--)
  153cc8:	d22e      	bcs.n	153d28 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  153cca:	f04f 0a20 	mov.w	r10, #32
  153cce:	e001      	b.n	153cd4 <_printf_engine+0x324>
            for (; format_num > written; format_num--)
  153cd0:	45a9      	cmp	r9, r5
  153cd2:	d029      	beq.n	153d28 <_printf_engine+0x378>
                OUTPUT_CHAR(' ');
  153cd4:	4642      	mov	r2, r8
  153cd6:	2101      	movs	r1, #1
  153cd8:	f88d a024 	strb.w	r10, [r13, #36]	; 0x24
  153cdc:	a809      	add	r0, sp, #36	; 0x24
  153cde:	47b8      	blx	r7
            for (; format_num > written; format_num--)
  153ce0:	3d01      	subs	r5, #1
                OUTPUT_CHAR(' ');
  153ce2:	2800      	cmp	r0, #0
  153ce4:	4406      	add	r6, r0
  153ce6:	daf3      	bge.n	153cd0 <_printf_engine+0x320>
  153ce8:	e7c9      	b.n	153c7e <_printf_engine+0x2ce>
                flags |= CAPSFLAG;
  153cea:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  153cee:	4651      	mov	r1, r10
                double d = va_arg(ap, double);
  153cf0:	f10b 0b07 	add.w	r11, r11, #7
  153cf4:	f02b 0b07 	bic.w	r11, r11, #7
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  153cf8:	a80a      	add	r0, sp, #40	; 0x28
  153cfa:	ed9b 0b00 	vldr	d0, [r11]
  153cfe:	f7ff fb5f 	bl	1533c0 <double_to_hexstring.isra.0>
                double d = va_arg(ap, double);
  153d02:	f10b 0b08 	add.w	r11, r11, #8
                s = double_to_hexstring(num_buffer, sizeof(num_buffer), d, flags);
  153d06:	9005      	str	r0, [sp, #20]
  153d08:	f000 fa68 	bl	1541dc <strlen>
  153d0c:	4681      	mov	r9, r0
                goto _output_string;
  153d0e:	e7cd      	b.n	153cac <_printf_engine+0x2fc>
                if (flags & LONGLONGFLAG)
  153d10:	f01a 0f02 	tst.w	r10, #2
                ptr = va_arg(ap, void *);
  153d14:	f8db 3000 	ldr.w	r3, [r11]
  153d18:	f10b 0204 	add.w	r2, r11, #4
                if (flags & LONGLONGFLAG)
  153d1c:	f000 80f7 	beq.w	153f0e <_printf_engine+0x55e>
                    *(long long *)ptr = chars_written;
  153d20:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  153d22:	4693      	mov	r11, r2
                    *(long long *)ptr = chars_written;
  153d24:	2200      	movs	r2, #0
  153d26:	605a      	str	r2, [r3, #4]
                ptr = va_arg(ap, void *);
  153d28:	4620      	mov	r0, r4
  153d2a:	e64e      	b.n	1539ca <_printf_engine+0x1a>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153d2c:	f01a 0f01 	tst.w	r10, #1
  153d30:	f040 80bb 	bne.w	153eaa <_printf_engine+0x4fa>
  153d34:	f01a 0f08 	tst.w	r10, #8
  153d38:	f040 8102 	bne.w	153f40 <_printf_engine+0x590>
  153d3c:	f01a 0f04 	tst.w	r10, #4
  153d40:	f000 8115 	beq.w	153f6e <_printf_engine+0x5be>
  153d44:	f8bb 2000 	ldrh.w	r2, [r11]
  153d48:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  153d4a:	f10b 0b04 	add.w	r11, r11, #4
  153d4e:	e737      	b.n	153bc0 <_printf_engine+0x210>
                flags |= BLANKPOSFLAG;
  153d50:	f44a 5a00 	orr.w	r10, r10, #8192	; 0x2000
                goto next_format;
  153d54:	e65d      	b.n	153a12 <_printf_engine+0x62>
                flags |= SIZETFLAG;
  153d56:	f04a 0a10 	orr.w	r10, r10, #16
                goto next_format;
  153d5a:	e65a      	b.n	153a12 <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  153d5c:	2325      	movs	r3, #37	; 0x25
  153d5e:	4642      	mov	r2, r8
  153d60:	2101      	movs	r1, #1
  153d62:	a809      	add	r0, sp, #36	; 0x24
  153d64:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  153d68:	47b8      	blx	r7
  153d6a:	f1b0 0c00 	subs.w	r12, r0, #0
  153d6e:	f6ff ae43 	blt.w	1539f8 <_printf_engine+0x48>
                OUTPUT_CHAR(c);
  153d72:	4466      	add	r6, r12
                ptr = va_arg(ap, void *);
  153d74:	4620      	mov	r0, r4
  153d76:	e628      	b.n	1539ca <_printf_engine+0x1a>
                flags |= SHOWSIGNFLAG;
  153d78:	f44a 7a00 	orr.w	r10, r10, #512	; 0x200
                goto next_format;
  153d7c:	e649      	b.n	153a12 <_printf_engine+0x62>
                flags |= ALTFLAG;
  153d7e:	f04a 0a80 	orr.w	r10, r10, #128	; 0x80
                goto next_format;
  153d82:	e646      	b.n	153a12 <_printf_engine+0x62>
                flags |= LEFTFORMATFLAG;
  153d84:	f44a 6a00 	orr.w	r10, r10, #2048	; 0x800
                goto next_format;
  153d88:	e643      	b.n	153a12 <_printf_engine+0x62>
                if (c == '0' && format_num == 0)
  153d8a:	2b30      	cmp	r3, #48	; 0x30
  153d8c:	bf08      	it	eq
  153d8e:	2d00      	cmpeq	r5, #0
                format_num *= 10;
  153d90:	eb05 0585 	add.w	r5, r5, r5, lsl #2
                format_num += c - '0';
  153d94:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
                    flags |= LEADZEROFLAG;
  153d98:	bf08      	it	eq
  153d9a:	f44a 5a80 	orreq.w	r10, r10, #4096	; 0x1000
                format_num += c - '0';
  153d9e:	eb03 0545 	add.w	r5, r3, r5, lsl #1
                goto next_format;
  153da2:	e636      	b.n	153a12 <_printf_engine+0x62>
                uc = va_arg(ap, unsigned int);
  153da4:	f8db 3000 	ldr.w	r3, [r11]
                OUTPUT_CHAR(uc);
  153da8:	4642      	mov	r2, r8
  153daa:	2101      	movs	r1, #1
  153dac:	a809      	add	r0, sp, #36	; 0x24
                uc = va_arg(ap, unsigned int);
  153dae:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
                OUTPUT_CHAR(uc);
  153db2:	47b8      	blx	r7
  153db4:	f1b0 0c00 	subs.w	r12, r0, #0
  153db8:	f6ff ae1e 	blt.w	1539f8 <_printf_engine+0x48>
                uc = va_arg(ap, unsigned int);
  153dbc:	f10b 0b04 	add.w	r11, r11, #4
                ptr = va_arg(ap, void *);
  153dc0:	4620      	mov	r0, r4
                OUTPUT_CHAR(uc);
  153dc2:	4466      	add	r6, r12
  153dc4:	e601      	b.n	1539ca <_printf_engine+0x1a>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153dc6:	f01a 0f02 	tst.w	r10, #2
  153dca:	d17f      	bne.n	153ecc <_printf_engine+0x51c>
  153dcc:	f01a 0f01 	tst.w	r10, #1
  153dd0:	f040 80bc 	bne.w	153f4c <_printf_engine+0x59c>
  153dd4:	f01a 0f08 	tst.w	r10, #8
  153dd8:	f000 80ed 	beq.w	153fb6 <_printf_engine+0x606>
  153ddc:	f99b 2000 	ldrsb.w	r2, [r11]
                    (flags & HALFHALFFLAG) ? (signed char)va_arg(ap, int) :
  153de0:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153de4:	17d3      	asrs	r3, r2, #31
  153de6:	e079      	b.n	153edc <_printf_engine+0x52c>
                s = va_arg(ap, const char *);
  153de8:	f8db 0000 	ldr.w	r0, [r11]
  153dec:	f10b 0b04 	add.w	r11, r11, #4
  153df0:	9005      	str	r0, [sp, #20]
                if (s == 0)
  153df2:	2800      	cmp	r0, #0
  153df4:	f000 80b6 	beq.w	153f64 <_printf_engine+0x5b4>
  153df8:	f000 f9f0 	bl	1541dc <strlen>
  153dfc:	4681      	mov	r9, r0
                flags &= ~LEADZEROFLAG; /* doesn't make sense for strings */
  153dfe:	f42a 5a80 	bic.w	r10, r10, #4096	; 0x1000
                goto _output_string;
  153e02:	e753      	b.n	153cac <_printf_engine+0x2fc>
                if (flags & HALFFLAG)
  153e04:	f01a 0f04 	tst.w	r10, #4
                    flags |= HALFHALFFLAG;
  153e08:	bf18      	it	ne
  153e0a:	f04a 0a08 	orrne.w	r10, r10, #8
                flags |= HALFFLAG;
  153e0e:	f04a 0a04 	orr.w	r10, r10, #4
                goto next_format;
  153e12:	e5fe      	b.n	153a12 <_printf_engine+0x62>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  153e14:	f01a 0f02 	tst.w	r10, #2
  153e18:	d170      	bne.n	153efc <_printf_engine+0x54c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153e1a:	f01a 0f01 	tst.w	r10, #1
  153e1e:	f040 809b 	bne.w	153f58 <_printf_engine+0x5a8>
  153e22:	f01a 0f08 	tst.w	r10, #8
  153e26:	f000 80bd 	beq.w	153fa4 <_printf_engine+0x5f4>
  153e2a:	f89b 2000 	ldrb.w	r2, [r11]
  153e2e:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  153e30:	f10b 0b04 	add.w	r11, r11, #4
  153e34:	e054      	b.n	153ee0 <_printf_engine+0x530>
                flags |= CAPSFLAG;
  153e36:	f44a 7a80 	orr.w	r10, r10, #256	; 0x100
                n = (flags & LONGLONGFLAG) ? va_arg(ap, unsigned long long) :
  153e3a:	f01a 0f02 	tst.w	r10, #2
  153e3e:	f43f af75 	beq.w	153d2c <_printf_engine+0x37c>
  153e42:	e6b5      	b.n	153bb0 <_printf_engine+0x200>
                flags |= INTMAXFLAG;
  153e44:	f04a 0a20 	orr.w	r10, r10, #32
                goto next_format;
  153e48:	e5e3      	b.n	153a12 <_printf_engine+0x62>
                if (flags & LONGFLAG)
  153e4a:	f01a 0f01 	tst.w	r10, #1
                    flags |= LONGLONGFLAG;
  153e4e:	bf18      	it	ne
  153e50:	f04a 0a02 	orrne.w	r10, r10, #2
                flags |= LONGFLAG;
  153e54:	f04a 0a01 	orr.w	r10, r10, #1
                goto next_format;
  153e58:	e5db      	b.n	153a12 <_printf_engine+0x62>
                flags |= PTRDIFFFLAG;
  153e5a:	f04a 0a40 	orr.w	r10, r10, #64	; 0x40
                goto next_format;
  153e5e:	e5d8      	b.n	153a12 <_printf_engine+0x62>
                OUTPUT_CHAR('%');
  153e60:	2525      	movs	r5, #37	; 0x25
  153e62:	4642      	mov	r2, r8
  153e64:	9305      	str	r3, [sp, #20]
  153e66:	2101      	movs	r1, #1
  153e68:	f88d 5024 	strb.w	r5, [r13, #36]	; 0x24
  153e6c:	a809      	add	r0, sp, #36	; 0x24
  153e6e:	47b8      	blx	r7
  153e70:	1e05      	subs	r5, r0, #0
  153e72:	f2c0 80b3 	blt.w	153fdc <_printf_engine+0x62c>
                OUTPUT_CHAR(c);
  153e76:	9b05      	ldr	r3, [sp, #20]
  153e78:	4642      	mov	r2, r8
  153e7a:	2101      	movs	r1, #1
  153e7c:	a809      	add	r0, sp, #36	; 0x24
  153e7e:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  153e82:	47b8      	blx	r7
  153e84:	f1b0 0c00 	subs.w	r12, r0, #0
  153e88:	f6ff adb6 	blt.w	1539f8 <_printf_engine+0x48>
                OUTPUT_CHAR('%');
  153e8c:	442e      	add	r6, r5
                OUTPUT_CHAR(c);
  153e8e:	4466      	add	r6, r12
  153e90:	e770      	b.n	153d74 <_printf_engine+0x3c4>
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  153e92:	9b07      	ldr	r3, [sp, #28]
  153e94:	2b00      	cmp	r3, #0
  153e96:	d075      	beq.n	153f84 <_printf_engine+0x5d4>
            OUTPUT_STRING(s, string_len);
  153e98:	4649      	mov	r1, r9
  153e9a:	4642      	mov	r2, r8
  153e9c:	9805      	ldr	r0, [sp, #20]
  153e9e:	47b8      	blx	r7
  153ea0:	f1b0 0c00 	subs.w	r12, r0, #0
  153ea4:	f6ff ada8 	blt.w	1539f8 <_printf_engine+0x48>
  153ea8:	e763      	b.n	153d72 <_printf_engine+0x3c2>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153eaa:	f8db 2000 	ldr.w	r2, [r11]
  153eae:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  153eb0:	f10b 0b04 	add.w	r11, r11, #4
  153eb4:	e684      	b.n	153bc0 <_printf_engine+0x210>
            if (flags & LEADZEROFLAG && signchar != '\0')
  153eb6:	9a07      	ldr	r2, [sp, #28]
  153eb8:	2a00      	cmp	r2, #0
  153eba:	f47f aebd 	bne.w	153c38 <_printf_engine+0x288>
  153ebe:	e065      	b.n	153f8c <_printf_engine+0x5dc>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153ec0:	f01a 0f10 	tst.w	r10, #16
  153ec4:	d142      	bne.n	153f4c <_printf_engine+0x59c>
  153ec6:	f01a 0f20 	tst.w	r10, #32
  153eca:	d03f      	beq.n	153f4c <_printf_engine+0x59c>
                    (flags & INTMAXFLAG) ? va_arg(ap, intmax_t) :
  153ecc:	f10b 0307 	add.w	r3, r11, #7
  153ed0:	f023 0307 	bic.w	r3, r3, #7
  153ed4:	f103 0b08 	add.w	r11, r3, #8
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153ed8:	e9d3 2300 	ldrd	r2, r3, [r3]
                flags |= SIGNEDFLAG;
  153edc:	f44a 6a80 	orr.w	r10, r10, #1024	; 0x400
                s = longlong_to_string(num_buffer, n, sizeof(num_buffer), flags, &signchar);
  153ee0:	2120      	movs	r1, #32
  153ee2:	f10d 0027 	add.w	r0, r13, #39	; 0x27
  153ee6:	9100      	str	r1, [sp, #0]
  153ee8:	e9cd a001 	strd	r10, r0, [r13, #4]
  153eec:	a80a      	add	r0, sp, #40	; 0x28
  153eee:	f7ff f9d7 	bl	1532a0 <longlong_to_string>
  153ef2:	9005      	str	r0, [sp, #20]
  153ef4:	f000 f972 	bl	1541dc <strlen>
  153ef8:	4681      	mov	r9, r0
                goto _output_string;
  153efa:	e6d7      	b.n	153cac <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153efc:	f10b 0307 	add.w	r3, r11, #7
  153f00:	f023 0307 	bic.w	r3, r3, #7
  153f04:	f103 0b08 	add.w	r11, r3, #8
  153f08:	e9d3 2300 	ldrd	r2, r3, [r3]
  153f0c:	e7e8      	b.n	153ee0 <_printf_engine+0x530>
                else if (flags & LONGFLAG)
  153f0e:	f01a 0f01 	tst.w	r10, #1
  153f12:	d10d      	bne.n	153f30 <_printf_engine+0x580>
                else if (flags & HALFHALFFLAG)
  153f14:	f01a 0f08 	tst.w	r10, #8
                ptr = va_arg(ap, void *);
  153f18:	bf1c      	itt	ne
  153f1a:	4693      	movne	r11, r2
                    *(signed char *)ptr = chars_written;
  153f1c:	701e      	strbne	r6, [r3, #0]
                else if (flags & HALFHALFFLAG)
  153f1e:	f47f af03 	bne.w	153d28 <_printf_engine+0x378>
                else if (flags & HALFFLAG)
  153f22:	f01a 0f04 	tst.w	r10, #4
                ptr = va_arg(ap, void *);
  153f26:	bf1c      	itt	ne
  153f28:	4693      	movne	r11, r2
                    *(short *)ptr = chars_written;
  153f2a:	801e      	strhne	r6, [r3, #0]
                else if (flags & HALFFLAG)
  153f2c:	f47f aefc 	bne.w	153d28 <_printf_engine+0x378>
                    *(int *)ptr = chars_written;
  153f30:	601e      	str	r6, [r3, #0]
                ptr = va_arg(ap, void *);
  153f32:	4693      	mov	r11, r2
  153f34:	4620      	mov	r0, r4
  153f36:	e548      	b.n	1539ca <_printf_engine+0x1a>
  153f38:	f000 f950 	bl	1541dc <strlen>
  153f3c:	4681      	mov	r9, r0
  153f3e:	e6b5      	b.n	153cac <_printf_engine+0x2fc>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153f40:	f89b 2000 	ldrb.w	r2, [r11]
  153f44:	2300      	movs	r3, #0
                    (flags & HALFHALFFLAG) ? (unsigned char)va_arg(ap, unsigned int) :
  153f46:	f10b 0b04 	add.w	r11, r11, #4
  153f4a:	e639      	b.n	153bc0 <_printf_engine+0x210>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153f4c:	f8db 2000 	ldr.w	r2, [r11]
                    va_arg(ap, int);
  153f50:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153f54:	17d3      	asrs	r3, r2, #31
  153f56:	e7c1      	b.n	153edc <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153f58:	f8db 2000 	ldr.w	r2, [r11]
  153f5c:	2300      	movs	r3, #0
                    (flags & SIZETFLAG) ? va_arg(ap, size_t) :
  153f5e:	f10b 0b04 	add.w	r11, r11, #4
  153f62:	e7bd      	b.n	153ee0 <_printf_engine+0x530>
                    s = "<null>";
  153f64:	9b06      	ldr	r3, [sp, #24]
  153f66:	f04f 0906 	mov.w	r9, #6
  153f6a:	9305      	str	r3, [sp, #20]
  153f6c:	e747      	b.n	153dfe <_printf_engine+0x44e>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153f6e:	f01a 0f10 	tst.w	r10, #16
  153f72:	d19a      	bne.n	153eaa <_printf_engine+0x4fa>
  153f74:	f01a 0f20 	tst.w	r10, #32
  153f78:	f47f ae1a 	bne.w	153bb0 <_printf_engine+0x200>
  153f7c:	f85b 2b04 	ldr.w	r2, [r11], #4
  153f80:	2300      	movs	r3, #0
  153f82:	e61d      	b.n	153bc0 <_printf_engine+0x210>
  153f84:	f89d 3027 	ldrb.w	r3, [r13, #39]	; 0x27
            if (!(flags & LEADZEROFLAG) && signchar != '\0')
  153f88:	2b00      	cmp	r3, #0
  153f8a:	d085      	beq.n	153e98 <_printf_engine+0x4e8>
                OUTPUT_CHAR(signchar);
  153f8c:	4642      	mov	r2, r8
  153f8e:	2101      	movs	r1, #1
  153f90:	f88d 3024 	strb.w	r3, [r13, #36]	; 0x24
  153f94:	a809      	add	r0, sp, #36	; 0x24
  153f96:	47b8      	blx	r7
  153f98:	f1b0 0c00 	subs.w	r12, r0, #0
  153f9c:	f6ff ad2c 	blt.w	1539f8 <_printf_engine+0x48>
  153fa0:	4466      	add	r6, r12
  153fa2:	e779      	b.n	153e98 <_printf_engine+0x4e8>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153fa4:	f01a 0f04 	tst.w	r10, #4
  153fa8:	d00e      	beq.n	153fc8 <_printf_engine+0x618>
  153faa:	f8bb 2000 	ldrh.w	r2, [r11]
  153fae:	2300      	movs	r3, #0
                    (flags & HALFFLAG) ? (unsigned short)va_arg(ap, unsigned int) :
  153fb0:	f10b 0b04 	add.w	r11, r11, #4
  153fb4:	e794      	b.n	153ee0 <_printf_engine+0x530>
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153fb6:	f01a 0f04 	tst.w	r10, #4
  153fba:	d081      	beq.n	153ec0 <_printf_engine+0x510>
  153fbc:	f9bb 2000 	ldrsh.w	r2, [r11]
                    (flags & HALFFLAG) ? (short)va_arg(ap, int) :
  153fc0:	f10b 0b04 	add.w	r11, r11, #4
                n = (flags & LONGLONGFLAG) ? va_arg(ap, long long) :
  153fc4:	17d3      	asrs	r3, r2, #31
  153fc6:	e789      	b.n	153edc <_printf_engine+0x52c>
                    (flags & LONGFLAG) ? va_arg(ap, unsigned long) :
  153fc8:	f01a 0f10 	tst.w	r10, #16
  153fcc:	d1c4      	bne.n	153f58 <_printf_engine+0x5a8>
  153fce:	f01a 0f20 	tst.w	r10, #32
  153fd2:	d193      	bne.n	153efc <_printf_engine+0x54c>
  153fd4:	f85b 2b04 	ldr.w	r2, [r11], #4
  153fd8:	2300      	movs	r3, #0
  153fda:	e781      	b.n	153ee0 <_printf_engine+0x530>
                OUTPUT_CHAR('%');
  153fdc:	46ac      	mov	r12, r5
  153fde:	e50b      	b.n	1539f8 <_printf_engine+0x48>
            for (; format_num > string_len; format_num--)
  153fe0:	454d      	cmp	r5, r9
  153fe2:	f63f ae37 	bhi.w	153c54 <_printf_engine+0x2a4>
  153fe6:	e7cf      	b.n	153f88 <_printf_engine+0x5d8>

00153fe8 <vsnprintf>:
{
  153fe8:	b570      	push	{r4, r5, r6, r14}
  153fea:	4604      	mov	r4, r0
  153fec:	b084      	sub	sp, #16
  153fee:	460d      	mov	r5, r1
    args.pos = 0;
  153ff0:	2600      	movs	r6, #0
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
  153ff2:	f243 2075 	movw	r0, #12917	; 0x3275
  153ff6:	a901      	add	r1, sp, #4
    args.len = len;
  153ff8:	e9cd 4501 	strd	r4, r5, [r13, #4]
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
  153ffc:	f2c0 0015 	movt	r0, #21
    args.pos = 0;
  154000:	9603      	str	r6, [sp, #12]
    wlen = _printf_engine(&_vsnprintf_output, (void *)&args, fmt, ap);
  154002:	f7ff fcd5 	bl	1539b0 <_printf_engine>
    if (args.pos >= len)
  154006:	9b03      	ldr	r3, [sp, #12]
  154008:	42ab      	cmp	r3, r5
        str[len-1] = '\0';
  15400a:	bf26      	itte	cs
  15400c:	1964      	addcs	r4, r4, r5
  15400e:	f804 6c01 	strbcs.w	r6, [r4, #-1]
        str[wlen] = '\0';
  154012:	5426      	strbcc	r6, [r4, r0]
}
  154014:	b004      	add	sp, #16
  154016:	bd70      	pop	{r4, r5, r6, r15}

00154018 <snprintf>:
{
  154018:	b40c      	push	{r2, r3}
  15401a:	b510      	push	{r4, r14}
  15401c:	b082      	sub	sp, #8
  15401e:	ac04      	add	r4, sp, #16
  154020:	f854 2b04 	ldr.w	r2, [r4], #4
    va_start(ap, fmt);
  154024:	9401      	str	r4, [sp, #4]
    err = vsnprintf(str, len, fmt, ap);
  154026:	4623      	mov	r3, r4
  154028:	f7ff ffde 	bl	153fe8 <vsnprintf>
}
  15402c:	b002      	add	sp, #8
  15402e:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  154032:	b002      	add	sp, #8
  154034:	4770      	bx	r14
  154036:	bf00      	nop

00154038 <sprintf>:
{
  154038:	b40e      	push	{r1, r2, r3}
  15403a:	b510      	push	{r4, r14}
  15403c:	b083      	sub	sp, #12
  15403e:	ac05      	add	r4, sp, #20
    return vsnprintf(str, INT_MAX, fmt, ap);
  154040:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
{
  154044:	f854 2b04 	ldr.w	r2, [r4], #4
    va_start(ap, fmt);
  154048:	9401      	str	r4, [sp, #4]
    return vsnprintf(str, INT_MAX, fmt, ap);
  15404a:	4623      	mov	r3, r4
  15404c:	f7ff ffcc 	bl	153fe8 <vsnprintf>
}
  154050:	b003      	add	sp, #12
  154052:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  154056:	b003      	add	sp, #12
  154058:	4770      	bx	r14
  15405a:	bf00      	nop

0015405c <_fprintf_output_func>:

static int _fprintf_output_func(const char *str, size_t len, void *state)
{
    FILE *fp = (FILE *)state;

    return io_write(fp->io, str, len);
  15405c:	6813      	ldr	r3, [r2, #0]
  15405e:	460a      	mov	r2, r1
  154060:	4601      	mov	r1, r0
  154062:	4618      	mov	r0, r3
  154064:	f000 ba9a 	b.w	15459c <io_write>

00154068 <putchar>:
    return io_write(fp->io, (char *)&c, 1);
  154068:	f241 033c 	movw	r3, #4156	; 0x103c
  15406c:	2201      	movs	r2, #1
{
  15406e:	b500      	push	{r14}
    return io_write(fp->io, (char *)&c, 1);
  154070:	f2c0 0316 	movt	r3, #22
{
  154074:	b083      	sub	sp, #12
    unsigned char c = _c;
  154076:	a902      	add	r1, sp, #8
  154078:	f801 0d01 	strb.w	r0, [r1, #-1]!
    return io_write(fp->io, (char *)&c, 1);
  15407c:	6858      	ldr	r0, [r3, #4]
  15407e:	f000 fa8d 	bl	15459c <io_write>
}
  154082:	b003      	add	sp, #12
  154084:	f85d fb04 	ldr.w	r15, [r13], #4

00154088 <fputs>:
{
  154088:	b538      	push	{r3, r4, r5, r14}
  15408a:	460c      	mov	r4, r1
  15408c:	4605      	mov	r5, r0
    size_t len = strlen(s);
  15408e:	f000 f8a5 	bl	1541dc <strlen>
    return io_write(fp->io, s, len);
  154092:	4629      	mov	r1, r5
  154094:	4602      	mov	r2, r0
  154096:	6820      	ldr	r0, [r4, #0]
}
  154098:	e8bd 4038 	ldmia.w	r13!, {r3, r4, r5, r14}
    return io_write(fp->io, s, len);
  15409c:	f000 ba7e 	b.w	15459c <io_write>

001540a0 <fwrite>:
    if (size == 0 || count == 0)
  1540a0:	2a00      	cmp	r2, #0
  1540a2:	bf18      	it	ne
  1540a4:	2900      	cmpne	r1, #0
  1540a6:	d006      	beq.n	1540b6 <fwrite+0x16>
  1540a8:	681b      	ldr	r3, [r3, #0]
    if (likely(size == 1)) {
  1540aa:	2901      	cmp	r1, #1
  1540ac:	d105      	bne.n	1540ba <fwrite+0x1a>
        return io_write(fp->io, ptr, count);
  1540ae:	4601      	mov	r1, r0
  1540b0:	4618      	mov	r0, r3
  1540b2:	f000 ba73 	b.w	15459c <io_write>
        return 0;
  1540b6:	2000      	movs	r0, #0
}
  1540b8:	4770      	bx	r14
{
  1540ba:	b510      	push	{r4, r14}
  1540bc:	460c      	mov	r4, r1
  1540be:	4601      	mov	r1, r0
    bytes_written = io_write(fp->io, ptr, size * count);
  1540c0:	4618      	mov	r0, r3
  1540c2:	fb02 f204 	mul.w	r2, r2, r4
  1540c6:	f000 fa69 	bl	15459c <io_write>
    return bytes_written / size;
  1540ca:	fbb0 f0f4 	udiv	r0, r0, r4
}
  1540ce:	bd10      	pop	{r4, r15}

001540d0 <getchar>:
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
  1540d0:	f241 033c 	movw	r3, #4156	; 0x103c
  1540d4:	2201      	movs	r2, #1
  1540d6:	f2c0 0316 	movt	r3, #22
{
  1540da:	b500      	push	{r14}
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
  1540dc:	6818      	ldr	r0, [r3, #0]
{
  1540de:	b083      	sub	sp, #12
    ssize_t ret = io_read(fp->io, &c, sizeof(c));
  1540e0:	f10d 0107 	add.w	r1, r13, #7
  1540e4:	f000 fa62 	bl	1545ac <io_read>
    return (ret > 0) ? c : ret;
  1540e8:	2800      	cmp	r0, #0
  1540ea:	bfc8      	it	gt
  1540ec:	f89d 0007 	ldrbgt.w	r0, [r13, #7]
}
  1540f0:	b003      	add	sp, #12
  1540f2:	f85d fb04 	ldr.w	r15, [r13], #4
  1540f6:	bf00      	nop

001540f8 <_printf>:
    va_end(ap);
    return err;
}

int _printf(const char *fmt, ...)
{
  1540f8:	b40f      	push	{r0, r1, r2, r3}
  1540fa:	b510      	push	{r4, r14}
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  1540fc:	f244 005d 	movw	r0, #16477	; 0x405d
{
  154100:	b082      	sub	sp, #8
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  154102:	4907      	ldr	r1, [pc, #28]	; (154120 <_printf+0x28>)
{
  154104:	ac04      	add	r4, sp, #16
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  154106:	f2c0 0015 	movt	r0, #21
{
  15410a:	f854 2b04 	ldr.w	r2, [r4], #4
    va_list ap;
    int err;

    va_start(ap, fmt);
  15410e:	9401      	str	r4, [sp, #4]
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  154110:	4623      	mov	r3, r4
  154112:	f7ff fc4d 	bl	1539b0 <_printf_engine>
    err = vfprintf(stdout, fmt, ap);
    va_end(ap);

    return err;
}
  154116:	b002      	add	sp, #8
  154118:	e8bd 4010 	ldmia.w	r13!, {r4, r14}
  15411c:	b004      	add	sp, #16
  15411e:	4770      	bx	r14
  154120:	00161040 	.word	0x00161040

00154124 <_vprintf>:
    return _printf_engine(&_fprintf_output_func, (void *)fp, fmt, ap);
  154124:	4602      	mov	r2, r0
  154126:	f244 005d 	movw	r0, #16477	; 0x405d
  15412a:	460b      	mov	r3, r1
  15412c:	f2c0 0015 	movt	r0, #21
  154130:	4901      	ldr	r1, [pc, #4]	; (154138 <_vprintf+0x14>)
  154132:	f7ff bc3d 	b.w	1539b0 <_printf_engine>
  154136:	bf00      	nop
  154138:	00161040 	.word	0x00161040

0015413c <memcmp>:
memcmp(const void *cs, const void *ct, size_t count)
{
    const unsigned char *su1, *su2;
    signed char res = 0;

    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
  15413c:	b1ca      	cbz	r2, 154172 <memcmp+0x36>
{
  15413e:	b410      	push	{r4}
        if ((res = *su1 - *su2) != 0)
  154140:	780c      	ldrb	r4, [r1, #0]
  154142:	7803      	ldrb	r3, [r0, #0]
  154144:	1b1b      	subs	r3, r3, r4
  154146:	b25b      	sxtb	r3, r3
  154148:	b9ab      	cbnz	r3, 154176 <memcmp+0x3a>
  15414a:	3a01      	subs	r2, #1
  15414c:	188b      	adds	r3, r1, r2
  15414e:	e006      	b.n	15415e <memcmp+0x22>
  154150:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  154154:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  154158:	1b12      	subs	r2, r2, r4
  15415a:	b252      	sxtb	r2, r2
  15415c:	b92a      	cbnz	r2, 15416a <memcmp+0x2e>
    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
  15415e:	4299      	cmp	r1, r3
  154160:	d1f6      	bne.n	154150 <memcmp+0x14>
  154162:	2000      	movs	r0, #0
            break;
    return res;
}
  154164:	f85d 4b04 	ldr.w	r4, [r13], #4
  154168:	4770      	bx	r14
  15416a:	f85d 4b04 	ldr.w	r4, [r13], #4
  15416e:	4610      	mov	r0, r2
  154170:	4770      	bx	r14
    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
  154172:	4610      	mov	r0, r2
}
  154174:	4770      	bx	r14
  154176:	4618      	mov	r0, r3
  154178:	e7f4      	b.n	154164 <memcmp+0x28>
  15417a:	bf00      	nop

0015417c <strcmp>:
#include <string.h>
#include <sys/types.h>

int
strcmp(char const *cs, char const *ct)
{
  15417c:	1e42      	subs	r2, r0, #1
  15417e:	e000      	b.n	154182 <strcmp+0x6>
    signed char __res;

    while (1) {
        if ((__res = *cs - *ct++) != 0 || !*cs++)
  154180:	b148      	cbz	r0, 154196 <strcmp+0x1a>
  154182:	f812 0f01 	ldrb.w	r0, [r2, #1]!
  154186:	f811 3b01 	ldrb.w	r3, [r1], #1
  15418a:	1ac3      	subs	r3, r0, r3
  15418c:	b25b      	sxtb	r3, r3
  15418e:	2b00      	cmp	r3, #0
  154190:	d0f6      	beq.n	154180 <strcmp+0x4>
  154192:	4618      	mov	r0, r3
            break;
    }

    return __res;
}
  154194:	4770      	bx	r14
  154196:	4770      	bx	r14

00154198 <strlcpy>:
size_t
strlcpy(char *dst, char const *src, size_t s)
{
    size_t i= 0;

    if (!s) {
  154198:	b1da      	cbz	r2, 1541d2 <strlcpy+0x3a>
        return strlen(src);
    }

    for (i= 0; ((i< s-1) && src[i]); i++) {
  15419a:	3a01      	subs	r2, #1
{
  15419c:	b5f8      	push	{r3, r4, r5, r6, r7, r14}
  15419e:	4607      	mov	r7, r0
    for (i= 0; ((i< s-1) && src[i]); i++) {
  1541a0:	d01a      	beq.n	1541d8 <strlcpy+0x40>
  1541a2:	780b      	ldrb	r3, [r1, #0]
  1541a4:	461c      	mov	r4, r3
  1541a6:	b16b      	cbz	r3, 1541c4 <strlcpy+0x2c>
  1541a8:	4605      	mov	r5, r0
  1541aa:	1c4e      	adds	r6, r1, #1
  1541ac:	2400      	movs	r4, #0
  1541ae:	e002      	b.n	1541b6 <strlcpy+0x1e>
  1541b0:	f816 3b01 	ldrb.w	r3, [r6], #1
  1541b4:	b133      	cbz	r3, 1541c4 <strlcpy+0x2c>
        dst[i]= src[i];
  1541b6:	f805 3b01 	strb.w	r3, [r5], #1
    for (i= 0; ((i< s-1) && src[i]); i++) {
  1541ba:	3401      	adds	r4, #1
  1541bc:	4631      	mov	r1, r6
  1541be:	4294      	cmp	r4, r2
  1541c0:	462f      	mov	r7, r5
  1541c2:	d1f5      	bne.n	1541b0 <strlcpy+0x18>
    }

    dst[i]= 0;
  1541c4:	2300      	movs	r3, #0

    return i + strlen(src+i);
  1541c6:	4608      	mov	r0, r1
    dst[i]= 0;
  1541c8:	703b      	strb	r3, [r7, #0]
    return i + strlen(src+i);
  1541ca:	f000 f807 	bl	1541dc <strlen>
}
  1541ce:	4420      	add	r0, r4
  1541d0:	bdf8      	pop	{r3, r4, r5, r6, r7, r15}
        return strlen(src);
  1541d2:	4608      	mov	r0, r1
  1541d4:	f000 b802 	b.w	1541dc <strlen>
    for (i= 0; ((i< s-1) && src[i]); i++) {
  1541d8:	4614      	mov	r4, r2
  1541da:	e7f3      	b.n	1541c4 <strlcpy+0x2c>

001541dc <strlen>:
strlen(char const *s)
{
    size_t i;

    i= 0;
    while (s[i]) {
  1541dc:	7803      	ldrb	r3, [r0, #0]
  1541de:	b13b      	cbz	r3, 1541f0 <strlen+0x14>
  1541e0:	4603      	mov	r3, r0
    i= 0;
  1541e2:	2000      	movs	r0, #0
        i+= 1;
  1541e4:	3001      	adds	r0, #1
    while (s[i]) {
  1541e6:	f813 2f01 	ldrb.w	r2, [r3, #1]!
  1541ea:	2a00      	cmp	r2, #0
  1541ec:	d1fa      	bne.n	1541e4 <strlen+0x8>
  1541ee:	4770      	bx	r14
    i= 0;
  1541f0:	4618      	mov	r0, r3
    }

    return i;
}
  1541f2:	4770      	bx	r14

001541f4 <strncpy>:
#include <string.h>
#include <sys/types.h>

char *
strncpy(char *dest, char const *src, size_t count)
{
  1541f4:	b410      	push	{r4}
  1541f6:	440a      	add	r2, r1
  1541f8:	1e44      	subs	r4, r0, #1
    char *tmp = dest;

    while (count-- && (*dest++ = *src++) != '\0')
  1541fa:	e004      	b.n	154206 <strncpy+0x12>
  1541fc:	f811 3b01 	ldrb.w	r3, [r1], #1
  154200:	f804 3f01 	strb.w	r3, [r4, #1]!
  154204:	b10b      	cbz	r3, 15420a <strncpy+0x16>
  154206:	4291      	cmp	r1, r2
  154208:	d1f8      	bne.n	1541fc <strncpy+0x8>
        ;

    return tmp;
}
  15420a:	f85d 4b04 	ldr.w	r4, [r13], #4
  15420e:	4770      	bx	r14

00154210 <strncmp>:
int
strncmp(char const *cs, char const *ct, size_t count)
{
    signed char __res = 0;

    while (count > 0) {
  154210:	b1e2      	cbz	r2, 15424c <strncmp+0x3c>
{
  154212:	b430      	push	{r4, r5}
        if ((__res = *cs - *ct++) != 0 || !*cs++)
  154214:	7805      	ldrb	r5, [r0, #0]
  154216:	780b      	ldrb	r3, [r1, #0]
  154218:	1aeb      	subs	r3, r5, r3
  15421a:	1c4c      	adds	r4, r1, #1
  15421c:	b25b      	sxtb	r3, r3
  15421e:	b97b      	cbnz	r3, 154240 <strncmp+0x30>
  154220:	b15d      	cbz	r5, 15423a <strncmp+0x2a>
  154222:	4411      	add	r1, r2
  154224:	e007      	b.n	154236 <strncmp+0x26>
  154226:	f810 2f01 	ldrb.w	r2, [r0, #1]!
  15422a:	f814 3b01 	ldrb.w	r3, [r4], #1
  15422e:	1ad3      	subs	r3, r2, r3
  154230:	b25b      	sxtb	r3, r3
  154232:	b92b      	cbnz	r3, 154240 <strncmp+0x30>
  154234:	b13a      	cbz	r2, 154246 <strncmp+0x36>
    while (count > 0) {
  154236:	42a1      	cmp	r1, r4
  154238:	d1f5      	bne.n	154226 <strncmp+0x16>
  15423a:	2000      	movs	r0, #0
            break;
        count--;
    }

    return __res;
}
  15423c:	bc30      	pop	{r4, r5}
  15423e:	4770      	bx	r14
  154240:	4618      	mov	r0, r3
  154242:	bc30      	pop	{r4, r5}
  154244:	4770      	bx	r14
  154246:	4610      	mov	r0, r2
  154248:	bc30      	pop	{r4, r5}
  15424a:	4770      	bx	r14
    while (count > 0) {
  15424c:	4610      	mov	r0, r2
}
  15424e:	4770      	bx	r14

00154250 <heap_insert_free_chunk>:
}

// try to insert this free chunk into the free list, consuming the chunk by merging it with
// nearby ones if possible. Returns base of whatever chunk it became in the list.
static struct free_heap_chunk *heap_insert_free_chunk(struct free_heap_chunk *chunk)
{
  154250:	b538      	push	{r3, r4, r5, r14}
  154252:	f246 7514 	movw	r5, #26388	; 0x6714
  154256:	4604      	mov	r4, r0
  154258:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  15425c:	f2c0 0516 	movt	r5, #22
  154260:	f105 0010 	add.w	r0, r5, #16
  154264:	f7fa ffb2 	bl	14f1cc <mutex_acquire_timeout>
    struct free_heap_chunk *next_chunk;
    struct free_heap_chunk *last_chunk;

    mutex_acquire(&theheap.lock);

    theheap.remaining += chunk->len;
  154268:	68a0      	ldr	r0, [r4, #8]
  15426a:	68a9      	ldr	r1, [r5, #8]

    // walk through the list, finding the node to insert before
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
  15426c:	f105 0248 	add.w	r2, r5, #72	; 0x48
  154270:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
    theheap.remaining += chunk->len;
  154272:	4401      	add	r1, r0
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
  154274:	4293      	cmp	r3, r2
    theheap.remaining += chunk->len;
  154276:	60a9      	str	r1, [r5, #8]
    list_for_every_entry(&theheap.free_list, next_chunk, struct free_heap_chunk, node) {
  154278:	d103      	bne.n	154282 <heap_insert_free_chunk+0x32>
  15427a:	e01d      	b.n	1542b8 <heap_insert_free_chunk+0x68>
  15427c:	685b      	ldr	r3, [r3, #4]
  15427e:	4293      	cmp	r3, r2
  154280:	d01a      	beq.n	1542b8 <heap_insert_free_chunk+0x68>
        if (chunk < next_chunk) {
  154282:	429c      	cmp	r4, r3
  154284:	d2fa      	bcs.n	15427c <heap_insert_free_chunk+0x2c>
    item->prev = list->prev;
  154286:	6819      	ldr	r1, [r3, #0]
  154288:	6021      	str	r1, [r4, #0]
    list->prev->next = item;
  15428a:	6819      	ldr	r1, [r3, #0]
    item->next = list;
  15428c:	6063      	str	r3, [r4, #4]
    list->prev->next = item;
  15428e:	604c      	str	r4, [r1, #4]
    list->prev = item;
  154290:	601c      	str	r4, [r3, #0]
    // walked off the end of the list, add it at the tail
    list_add_tail(&theheap.free_list, &chunk->node);

    // try to merge with the previous chunk
try_merge:
    last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
  154292:	6821      	ldr	r1, [r4, #0]
  154294:	2900      	cmp	r1, #0
  154296:	bf18      	it	ne
  154298:	4291      	cmpne	r1, r2
  15429a:	d004      	beq.n	1542a6 <heap_insert_free_chunk+0x56>
    if (last_chunk) {
        if ((vaddr_t)last_chunk + last_chunk->len == (vaddr_t)chunk) {
  15429c:	688a      	ldr	r2, [r1, #8]
  15429e:	188d      	adds	r5, r1, r2
  1542a0:	42ac      	cmp	r4, r5
  1542a2:	d017      	beq.n	1542d4 <heap_insert_free_chunk+0x84>
            chunk = last_chunk;
        }
    }

    // try to merge with the next chunk
    if (next_chunk) {
  1542a4:	b11b      	cbz	r3, 1542ae <heap_insert_free_chunk+0x5e>
        if ((vaddr_t)chunk + chunk->len == (vaddr_t)next_chunk) {
  1542a6:	68a2      	ldr	r2, [r4, #8]
  1542a8:	18a1      	adds	r1, r4, r2
  1542aa:	428b      	cmp	r3, r1
  1542ac:	d01f      	beq.n	1542ee <heap_insert_free_chunk+0x9e>
            // remove them from the list
            list_delete(&next_chunk->node);
        }
    }

    mutex_release(&theheap.lock);
  1542ae:	4818      	ldr	r0, [pc, #96]	; (154310 <heap_insert_free_chunk+0xc0>)
  1542b0:	f7fa ffb8 	bl	14f224 <mutex_release>

    return chunk;
}
  1542b4:	4620      	mov	r0, r4
  1542b6:	bd38      	pop	{r3, r4, r5, r15}
    item->prev = list->prev;
  1542b8:	6ca9      	ldr	r1, [r5, #72]	; 0x48
    item->next = list;
  1542ba:	e9c4 1200 	strd	r1, r2, [r4]
    list->prev->next = item;
  1542be:	6ca9      	ldr	r1, [r5, #72]	; 0x48
  1542c0:	604c      	str	r4, [r1, #4]
    list->prev = item;
  1542c2:	64ac      	str	r4, [r5, #72]	; 0x48
    last_chunk = list_prev_type(&theheap.free_list, &chunk->node, struct free_heap_chunk, node);
  1542c4:	6821      	ldr	r1, [r4, #0]
  1542c6:	2900      	cmp	r1, #0
  1542c8:	bf18      	it	ne
  1542ca:	4291      	cmpne	r1, r2
  1542cc:	d1e6      	bne.n	15429c <heap_insert_free_chunk+0x4c>
    if (next_chunk) {
  1542ce:	2b00      	cmp	r3, #0
  1542d0:	d1e9      	bne.n	1542a6 <heap_insert_free_chunk+0x56>
  1542d2:	e7ec      	b.n	1542ae <heap_insert_free_chunk+0x5e>
    item->next->prev = item->prev;
  1542d4:	6865      	ldr	r5, [r4, #4]
            last_chunk->len += chunk->len;
  1542d6:	4410      	add	r0, r2
    item->prev = item->next = 0;
  1542d8:	2200      	movs	r2, #0
  1542da:	6088      	str	r0, [r1, #8]
    item->next->prev = item->prev;
  1542dc:	6029      	str	r1, [r5, #0]
    item->prev->next = item->next;
  1542de:	6820      	ldr	r0, [r4, #0]
  1542e0:	6045      	str	r5, [r0, #4]
    item->prev = item->next = 0;
  1542e2:	e9c4 2200 	strd	r2, r2, [r4]
  1542e6:	460c      	mov	r4, r1
    if (next_chunk) {
  1542e8:	2b00      	cmp	r3, #0
  1542ea:	d1dc      	bne.n	1542a6 <heap_insert_free_chunk+0x56>
  1542ec:	e7df      	b.n	1542ae <heap_insert_free_chunk+0x5e>
            chunk->len += next_chunk->len;
  1542ee:	6899      	ldr	r1, [r3, #8]
  1542f0:	2000      	movs	r0, #0
    item->next->prev = item->prev;
  1542f2:	685d      	ldr	r5, [r3, #4]
  1542f4:	440a      	add	r2, r1
  1542f6:	6819      	ldr	r1, [r3, #0]
  1542f8:	60a2      	str	r2, [r4, #8]
  1542fa:	6029      	str	r1, [r5, #0]
    item->prev->next = item->next;
  1542fc:	681a      	ldr	r2, [r3, #0]
  1542fe:	6055      	str	r5, [r2, #4]
    item->prev = item->next = 0;
  154300:	e9c3 0000 	strd	r0, r0, [r3]
    mutex_release(&theheap.lock);
  154304:	4802      	ldr	r0, [pc, #8]	; (154310 <heap_insert_free_chunk+0xc0>)
  154306:	f7fa ff8d 	bl	14f224 <mutex_release>
}
  15430a:	4620      	mov	r0, r4
  15430c:	bd38      	pop	{r3, r4, r5, r15}
  15430e:	bf00      	nop
  154310:	00166724 	.word	0x00166724

00154314 <miniheap_alloc>:

    return chunk;
}

void *miniheap_alloc(size_t size, unsigned int alignment)
{
  154314:	e92d 43f8 	stmdb	r13!, {r3, r4, r5, r6, r7, r8, r9, r14}
#endif

    LTRACEF("size %zd, align %d\n", size, alignment);

    // alignment must be power of 2
    if (alignment & (alignment - 1))
  154318:	1e4b      	subs	r3, r1, #1
  15431a:	420b      	tst	r3, r1
  15431c:	f040 80c0 	bne.w	1544a0 <miniheap_alloc+0x18c>
  154320:	4688      	mov	r8, r1
        return NULL;

    // we always put a size field + base pointer + magic in front of the allocation
    size += sizeof(struct alloc_struct_begin);
  154322:	f100 0408 	add.w	r4, r0, #8
    // in the spot
    if (size < sizeof(struct free_heap_chunk))
        size = sizeof(struct free_heap_chunk);

    // round up size to a multiple of native pointer size
    size = ROUNDUP(size, sizeof(void *));
  154326:	4620      	mov	r0, r4
  154328:	2c0c      	cmp	r4, #12
  15432a:	bf38      	it	cc
  15432c:	200c      	movcc	r0, #12
  15432e:	1cc4      	adds	r4, r0, #3
  154330:	f024 0403 	bic.w	r4, r4, #3

    // deal with nonzero alignments
    if (alignment > 0) {
  154334:	2900      	cmp	r1, #0
  154336:	f040 80ad 	bne.w	154494 <miniheap_alloc+0x180>
  15433a:	f246 7714 	movw	r7, #26388	; 0x6714
  15433e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  154342:	f2c0 0716 	movt	r7, #22
  154346:	f107 002c 	add.w	r0, r7, #44	; 0x2c
  15434a:	f7fa ff3f 	bl	14f1cc <mutex_acquire_timeout>
  15434e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  154352:	f107 0010 	add.w	r0, r7, #16
  154356:	f7fa ff39 	bl	14f1cc <mutex_acquire_timeout>
    mutex_acquire(&theheap.lock);

    // walk through the list
    ptr = NULL;
    struct free_heap_chunk *chunk;
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  15435a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  15435c:	f107 0648 	add.w	r6, r7, #72	; 0x48
    mutex_release(&theheap.lock);
}

static ssize_t heap_grow(size_t size)
{
    size = ROUNDUP(size, PAGE_SIZE);
  154360:	f604 79ff 	addw	r9, r4, #4095	; 0xfff
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  154364:	42b3      	cmp	r3, r6
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
  154366:	ea4f 3519 	mov.w	r5, r9, lsr #12
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  15436a:	d009      	beq.n	154380 <miniheap_alloc+0x6c>
        if (chunk->len >= size) {
  15436c:	689a      	ldr	r2, [r3, #8]
  15436e:	42a2      	cmp	r2, r4
  154370:	d303      	bcc.n	15437a <miniheap_alloc+0x66>
  154372:	e045      	b.n	154400 <miniheap_alloc+0xec>
  154374:	689a      	ldr	r2, [r3, #8]
  154376:	4294      	cmp	r4, r2
  154378:	d942      	bls.n	154400 <miniheap_alloc+0xec>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  15437a:	685b      	ldr	r3, [r3, #4]
  15437c:	42b3      	cmp	r3, r6
  15437e:	d1f9      	bne.n	154374 <miniheap_alloc+0x60>
    mutex_release(&theheap.lock);
  154380:	484f      	ldr	r0, [pc, #316]	; (1544c0 <miniheap_alloc+0x1ac>)
    size = ROUNDUP(size, PAGE_SIZE);
  154382:	f429 697f 	bic.w	r9, r9, #4080	; 0xff0
    mutex_release(&theheap.lock);
  154386:	f7fa ff4d 	bl	14f224 <mutex_release>
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
  15438a:	4628      	mov	r0, r5
  15438c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    size = ROUNDUP(size, PAGE_SIZE);
  154390:	f029 090f 	bic.w	r9, r9, #15
    void *ptr = page_alloc(size / PAGE_SIZE, PAGE_ALLOC_ANY_ARENA);
  154394:	f7fe fde2 	bl	152f5c <page_alloc>
    if (!ptr) {
  154398:	4605      	mov	r5, r0
  15439a:	2800      	cmp	r0, #0
  15439c:	f000 8082 	beq.w	1544a4 <miniheap_alloc+0x190>
    chunk->len = len;
  1543a0:	f8c0 9008 	str.w	r9, [r0, #8]
        return ERR_NO_MEMORY;
    }

    LTRACEF("growing heap by 0x%zx bytes, new ptr %p\n", size, ptr);

    heap_insert_free_chunk(heap_create_free_chunk(ptr, size, true));
  1543a4:	f7ff ff54 	bl	154250 <heap_insert_free_chunk>

    /* change the heap start and end variables */
    if ((uintptr_t)ptr < (uintptr_t)theheap.base || theheap.base == 0)
  1543a8:	683b      	ldr	r3, [r7, #0]
  1543aa:	429d      	cmp	r5, r3
  1543ac:	bf2c      	ite	cs
  1543ae:	2200      	movcs	r2, #0
  1543b0:	2201      	movcc	r2, #1
  1543b2:	2b00      	cmp	r3, #0
  1543b4:	bf08      	it	eq
  1543b6:	2201      	moveq	r2, #1
  1543b8:	b10a      	cbz	r2, 1543be <miniheap_alloc+0xaa>
        theheap.base = ptr;
  1543ba:	603d      	str	r5, [r7, #0]
    if ((uintptr_t)ptr < (uintptr_t)theheap.base || theheap.base == 0)
  1543bc:	462b      	mov	r3, r5

    uintptr_t endptr = (uintptr_t)ptr + size;
    if (endptr > (uintptr_t)theheap.base + theheap.len) {
  1543be:	687a      	ldr	r2, [r7, #4]
    uintptr_t endptr = (uintptr_t)ptr + size;
  1543c0:	444d      	add	r5, r9
    if (endptr > (uintptr_t)theheap.base + theheap.len) {
  1543c2:	441a      	add	r2, r3
  1543c4:	4295      	cmp	r5, r2
        theheap.len = (uintptr_t)endptr - (uintptr_t)theheap.base;
  1543c6:	bf84      	itt	hi
  1543c8:	1aed      	subhi	r5, r5, r3
  1543ca:	607d      	strhi	r5, [r7, #4]
        if (err >= 0) {
  1543cc:	f1b9 0f00 	cmp.w	r9, #0
  1543d0:	db14      	blt.n	1543fc <miniheap_alloc+0xe8>
  1543d2:	483b      	ldr	r0, [pc, #236]	; (1544c0 <miniheap_alloc+0x1ac>)
  1543d4:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
  1543d8:	f7fa fef8 	bl	14f1cc <mutex_acquire_timeout>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  1543dc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  1543de:	42b3      	cmp	r3, r6
  1543e0:	d009      	beq.n	1543f6 <miniheap_alloc+0xe2>
        if (chunk->len >= size) {
  1543e2:	689a      	ldr	r2, [r3, #8]
  1543e4:	4294      	cmp	r4, r2
  1543e6:	d803      	bhi.n	1543f0 <miniheap_alloc+0xdc>
  1543e8:	e00a      	b.n	154400 <miniheap_alloc+0xec>
  1543ea:	689a      	ldr	r2, [r3, #8]
  1543ec:	42a2      	cmp	r2, r4
  1543ee:	d207      	bcs.n	154400 <miniheap_alloc+0xec>
    list_for_every_entry(&theheap.free_list, chunk, struct free_heap_chunk, node) {
  1543f0:	685b      	ldr	r3, [r3, #4]
  1543f2:	42b3      	cmp	r3, r6
  1543f4:	d1f9      	bne.n	1543ea <miniheap_alloc+0xd6>
    mutex_release(&theheap.lock);
  1543f6:	4832      	ldr	r0, [pc, #200]	; (1544c0 <miniheap_alloc+0x1ac>)
  1543f8:	f7fa ff14 	bl	14f224 <mutex_release>
    ptr = NULL;
  1543fc:	2500      	movs	r5, #0
  1543fe:	e02f      	b.n	154460 <miniheap_alloc+0x14c>
            struct list_node *next_node = list_next(&theheap.free_list, &chunk->node);
  154400:	6859      	ldr	r1, [r3, #4]
  154402:	f104 0c0c 	add.w	r12, r4, #12
  154406:	681d      	ldr	r5, [r3, #0]
  154408:	2000      	movs	r0, #0
    if (item->next != list)
  15440a:	42b1      	cmp	r1, r6
  15440c:	d02e      	beq.n	15446c <miniheap_alloc+0x158>
    item->next->prev = item->prev;
  15440e:	600d      	str	r5, [r1, #0]
            if (chunk->len > size + sizeof(struct free_heap_chunk)) {
  154410:	4562      	cmp	r2, r12
    item->prev->next = item->next;
  154412:	681d      	ldr	r5, [r3, #0]
  154414:	6069      	str	r1, [r5, #4]
    item->prev = item->next = 0;
  154416:	e9c3 0000 	strd	r0, r0, [r3]
  15441a:	d92e      	bls.n	15447a <miniheap_alloc+0x166>
                struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
  15441c:	1918      	adds	r0, r3, r4
    item->prev = list->prev;
  15441e:	680d      	ldr	r5, [r1, #0]
  154420:	1b12      	subs	r2, r2, r4
    chunk->len = len;
  154422:	6082      	str	r2, [r0, #8]
                chunk->len -= chunk->len - size;
  154424:	609c      	str	r4, [r3, #8]
  154426:	511d      	str	r5, [r3, r4]
    list->prev->next = item;
  154428:	680a      	ldr	r2, [r1, #0]
    item->next = list;
  15442a:	6041      	str	r1, [r0, #4]
    list->prev->next = item;
  15442c:	6050      	str	r0, [r2, #4]
    list->prev = item;
  15442e:	6008      	str	r0, [r1, #0]
            ptr = (void *)((addr_t)ptr + sizeof(struct alloc_struct_begin));
  154430:	f103 0508 	add.w	r5, r3, #8
            if (alignment > 0) {
  154434:	f1b8 0f00 	cmp.w	r8, #0
  154438:	d006      	beq.n	154448 <miniheap_alloc+0x134>
                ptr = (void *)ROUNDUP((addr_t)ptr, (addr_t)alignment);
  15443a:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
  15443e:	4415      	add	r5, r2
  154440:	f1c8 0800 	rsb	r8, r8, #0
  154444:	ea05 0508 	and.w	r5, r5, r8
            if (theheap.remaining < theheap.low_watermark) {
  154448:	e9d7 2102 	ldrd	r2, r1, [r7, #8]
    mutex_release(&theheap.lock);
  15444c:	481c      	ldr	r0, [pc, #112]	; (1544c0 <miniheap_alloc+0x1ac>)
            as->size = size;
  15444e:	e945 3402 	strd	r3, r4, [r5, #-8]
            theheap.remaining -= size;
  154452:	1b12      	subs	r2, r2, r4
            if (theheap.remaining < theheap.low_watermark) {
  154454:	428a      	cmp	r2, r1
            theheap.remaining -= size;
  154456:	60ba      	str	r2, [r7, #8]
                theheap.low_watermark = theheap.remaining;
  154458:	bf38      	it	cc
  15445a:	60fa      	strcc	r2, [r7, #12]
    mutex_release(&theheap.lock);
  15445c:	f7fa fee2 	bl	14f224 <mutex_release>
    mutex_release(&theheap.retry_lock);
  154460:	4818      	ldr	r0, [pc, #96]	; (1544c4 <miniheap_alloc+0x1b0>)
  154462:	f7fa fedf 	bl	14f224 <mutex_release>
}
  154466:	4628      	mov	r0, r5
  154468:	e8bd 83f8 	ldmia.w	r13!, {r3, r4, r5, r6, r7, r8, r9, r15}
    item->next->prev = item->prev;
  15446c:	64bd      	str	r5, [r7, #72]	; 0x48
            if (chunk->len > size + sizeof(struct free_heap_chunk)) {
  15446e:	4562      	cmp	r2, r12
    item->prev->next = item->next;
  154470:	6819      	ldr	r1, [r3, #0]
  154472:	604e      	str	r6, [r1, #4]
    item->prev = item->next = 0;
  154474:	e9c3 0000 	strd	r0, r0, [r3]
  154478:	d801      	bhi.n	15447e <miniheap_alloc+0x16a>
  15447a:	689c      	ldr	r4, [r3, #8]
  15447c:	e7d8      	b.n	154430 <miniheap_alloc+0x11c>
                struct free_heap_chunk *newchunk = heap_create_free_chunk((uint8_t *)ptr + size, chunk->len - size, true);
  15447e:	1919      	adds	r1, r3, r4
    item->prev = list->prev;
  154480:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  154482:	1b12      	subs	r2, r2, r4
    chunk->len = len;
  154484:	608a      	str	r2, [r1, #8]
                chunk->len -= chunk->len - size;
  154486:	609c      	str	r4, [r3, #8]
  154488:	5118      	str	r0, [r3, r4]
    item->next = list;
  15448a:	604e      	str	r6, [r1, #4]
    list->prev->next = item;
  15448c:	6cba      	ldr	r2, [r7, #72]	; 0x48
  15448e:	6051      	str	r1, [r2, #4]
    list->prev = item;
  154490:	64b9      	str	r1, [r7, #72]	; 0x48
  154492:	e7cd      	b.n	154430 <miniheap_alloc+0x11c>
  154494:	2910      	cmp	r1, #16
  154496:	bf38      	it	cc
  154498:	f04f 0810 	movcc.w	r8, #16
        size += alignment;
  15449c:	4444      	add	r4, r8
  15449e:	e74c      	b.n	15433a <miniheap_alloc+0x26>
        return NULL;
  1544a0:	2500      	movs	r5, #0
  1544a2:	e7e0      	b.n	154466 <miniheap_alloc+0x152>
        TRACEF("failed to grow kernel heap by 0x%zx bytes\n", size);
  1544a4:	f648 01e4 	movw	r1, #35044	; 0x88e4
  1544a8:	f648 00f0 	movw	r0, #35056	; 0x88f0
  1544ac:	464b      	mov	r3, r9
  1544ae:	f2c0 0115 	movt	r1, #21
  1544b2:	f44f 72fb 	mov.w	r2, #502	; 0x1f6
  1544b6:	f2c0 0015 	movt	r0, #21
  1544ba:	f7ff fe1d 	bl	1540f8 <_printf>
  1544be:	e7cf      	b.n	154460 <miniheap_alloc+0x14c>
  1544c0:	00166724 	.word	0x00166724
  1544c4:	00166740 	.word	0x00166740

001544c8 <miniheap_free>:
    if (!ptr)
  1544c8:	b128      	cbz	r0, 1544d6 <miniheap_free+0xe>
    chunk->len = len;
  1544ca:	e950 3202 	ldrd	r3, r2, [r0, #-8]
  1544ce:	609a      	str	r2, [r3, #8]
    heap_insert_free_chunk(heap_create_free_chunk(as->ptr, as->size, true));
  1544d0:	4618      	mov	r0, r3
  1544d2:	f7ff bebd 	b.w	154250 <heap_insert_free_chunk>
}
  1544d6:	4770      	bx	r14

001544d8 <miniheap_init>:

    return size;
}

void miniheap_init(void *ptr, size_t len)
{
  1544d8:	b570      	push	{r4, r5, r6, r14}
    LTRACEF("ptr %p, len %zu\n", ptr, len);

    // create a mutex
    mutex_init(&theheap.lock);
  1544da:	f246 7414 	movw	r4, #26388	; 0x6714
{
  1544de:	4606      	mov	r6, r0
  1544e0:	460d      	mov	r5, r1
    mutex_init(&theheap.lock);
  1544e2:	f2c0 0416 	movt	r4, #22
  1544e6:	f104 0010 	add.w	r0, r4, #16
  1544ea:	f7fa fe35 	bl	14f158 <mutex_init>
    mutex_init(&theheap.retry_lock);
  1544ee:	f104 002c 	add.w	r0, r4, #44	; 0x2c
  1544f2:	f7fa fe31 	bl	14f158 <mutex_init>
    list_initialize(&theheap.free_list);

    // set the heap range
    theheap.base = ptr;
    theheap.len = len;
    theheap.remaining = 0; // will get set by heap_insert_free_chunk()
  1544f6:	2300      	movs	r3, #0
    theheap.len = len;
  1544f8:	e9c4 6500 	strd	r6, r5, [r4]
    list->prev = list->next = list;
  1544fc:	f104 0248 	add.w	r2, r4, #72	; 0x48
    theheap.low_watermark = 0;
  154500:	e9c4 3302 	strd	r3, r3, [r4, #8]
  154504:	e9c4 2212 	strd	r2, r2, [r4, #72]	; 0x48

    // if passed a default range, use it
    if (len > 0)
  154508:	b905      	cbnz	r5, 15450c <miniheap_init+0x34>
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
}
  15450a:	bd70      	pop	{r4, r5, r6, r15}
    chunk->len = len;
  15450c:	60b5      	str	r5, [r6, #8]
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
  15450e:	4630      	mov	r0, r6
}
  154510:	e8bd 4070 	ldmia.w	r13!, {r4, r5, r6, r14}
        heap_insert_free_chunk(heap_create_free_chunk(ptr, len, true));
  154514:	f7ff be9c 	b.w	154250 <heap_insert_free_chunk>

00154518 <__debug_stdio_write>:
    spin_unlock_restore(&print_spin_lock, state, PRINT_LOCK_FLAGS);
}

static ssize_t __debug_stdio_write(io_handle_t *io, const char *s,
                                   size_t len)
{
  154518:	e92d 41f0 	stmdb	r13!, {r4, r5, r6, r7, r8, r14}
    return (list->next == list) ? true : false;
  15451c:	f241 0650 	movw	r6, #4176	; 0x1050
  154520:	460c      	mov	r4, r1
  154522:	4617      	mov	r7, r2
  154524:	f2c0 0616 	movt	r6, #22
  154528:	6875      	ldr	r5, [r6, #4]
    if (!list_is_empty(&print_callbacks)) {
  15452a:	42b5      	cmp	r5, r6
  15452c:	d013      	beq.n	154556 <__debug_stdio_write+0x3e>
    __asm__ volatile("mrs %0, cpsr" : "=r"(state));
  15452e:	f3ef 8300 	mrs	r3, CPSR
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  154532:	061b      	lsls	r3, r3, #24
    spin_lock_saved_state_t state = 0;
  154534:	bf48      	it	mi
  154536:	f04f 0800 	movmi.w	r8, #0
    if ((flags & SPIN_LOCK_FLAG_IRQ) && !arch_ints_disabled()) {
  15453a:	d519      	bpl.n	154570 <__debug_stdio_write+0x58>
            if (cb->print)
  15453c:	68ab      	ldr	r3, [r5, #8]
                cb->print(cb, str, len);
  15453e:	4628      	mov	r0, r5
  154540:	463a      	mov	r2, r7
  154542:	4621      	mov	r1, r4
            if (cb->print)
  154544:	b103      	cbz	r3, 154548 <__debug_stdio_write+0x30>
                cb->print(cb, str, len);
  154546:	4798      	blx	r3
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  154548:	686d      	ldr	r5, [r5, #4]
  15454a:	42b5      	cmp	r5, r6
  15454c:	d1f6      	bne.n	15453c <__debug_stdio_write+0x24>
    if ((flags & SPIN_LOCK_FLAG_IRQ) && (old_state & SPIN_LOCK_STATE_RESTORE_IRQ))
  15454e:	f1b8 0f00 	cmp.w	r8, #0
  154552:	d000      	beq.n	154556 <__debug_stdio_write+0x3e>
    __asm__ volatile("cpsie i");
  154554:	b662      	cpsie	i
    for (i = 0; i < len; i++) {
  154556:	b147      	cbz	r7, 15456a <__debug_stdio_write+0x52>
  154558:	1e7d      	subs	r5, r7, #1
  15455a:	4425      	add	r5, r4
  15455c:	3c01      	subs	r4, #1
        platform_dputc(str[i]);
  15455e:	f814 0f01 	ldrb.w	r0, [r4, #1]!
  154562:	f7ec f82f 	bl	1405c4 <platform_dputc>
    for (i = 0; i < len; i++) {
  154566:	42a5      	cmp	r5, r4
  154568:	d1f9      	bne.n	15455e <__debug_stdio_write+0x46>
    out_count(s, len);
    return len;
}
  15456a:	4638      	mov	r0, r7
  15456c:	e8bd 81f0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r15}
    __asm__ volatile("cpsid i");
  154570:	b672      	cpsid	i
        list_for_every_entry(&print_callbacks, cb, print_callback_t, entry) {
  154572:	6875      	ldr	r5, [r6, #4]
  154574:	42b5      	cmp	r5, r6
        state |= SPIN_LOCK_STATE_RESTORE_IRQ;
  154576:	bf18      	it	ne
  154578:	f04f 0801 	movne.w	r8, #1
  15457c:	d1de      	bne.n	15453c <__debug_stdio_write+0x24>
  15457e:	e7e9      	b.n	154554 <__debug_stdio_write+0x3c>

00154580 <__debug_stdio_read>:

static ssize_t __debug_stdio_read(io_handle_t *io, char *s, size_t len)
{
    if (len == 0)
  154580:	b90a      	cbnz	r2, 154586 <__debug_stdio_read+0x6>
        return 0;
  154582:	4610      	mov	r0, r2
    if (err < 0)
        return err;

    return 1;
#endif
}
  154584:	4770      	bx	r14
{
  154586:	b508      	push	{r3, r14}
  154588:	4608      	mov	r0, r1
    int err = platform_dgetc(s, true);
  15458a:	2101      	movs	r1, #1
  15458c:	f7ec f81c 	bl	1405c8 <platform_dgetc>
    return 1;
  154590:	ea10 0020 	ands.w	r0, r0, r0, asr #32
  154594:	bf38      	it	cc
  154596:	2001      	movcc	r0, #1
}
  154598:	bd08      	pop	{r3, r15}
  15459a:	bf00      	nop

0015459c <io_write>:

ssize_t io_write(io_handle_t *io, const char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->write)
  15459c:	6843      	ldr	r3, [r0, #4]
  15459e:	681b      	ldr	r3, [r3, #0]
  1545a0:	b103      	cbz	r3, 1545a4 <io_write+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->write(io, buf, len);
  1545a2:	4718      	bx	r3
}
  1545a4:	f06f 0017 	mvn.w	r0, #23
  1545a8:	4770      	bx	r14
  1545aa:	bf00      	nop

001545ac <io_read>:

ssize_t io_read(io_handle_t *io, char *buf, size_t len)
{
    DEBUG_ASSERT(io->magic == IO_HANDLE_MAGIC);

    if (!io->hooks->read)
  1545ac:	6843      	ldr	r3, [r0, #4]
  1545ae:	685b      	ldr	r3, [r3, #4]
  1545b0:	b103      	cbz	r3, 1545b4 <io_read+0x8>
        return ERR_NOT_SUPPORTED;

    return io->hooks->read(io, buf, len);
  1545b2:	4718      	bx	r3
}
  1545b4:	f06f 0017 	mvn.w	r0, #23
  1545b8:	4770      	bx	r14
  1545ba:	bf00      	nop

001545bc <__aeabi_drsub>:
  1545bc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
  1545c0:	e002      	b.n	1545c8 <__adddf3>
  1545c2:	bf00      	nop

001545c4 <__aeabi_dsub>:
  1545c4:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

001545c8 <__adddf3>:
  1545c8:	b530      	push	{r4, r5, r14}
  1545ca:	ea4f 0441 	mov.w	r4, r1, lsl #1
  1545ce:	ea4f 0543 	mov.w	r5, r3, lsl #1
  1545d2:	ea94 0f05 	teq	r4, r5
  1545d6:	bf08      	it	eq
  1545d8:	ea90 0f02 	teqeq	r0, r2
  1545dc:	bf1f      	itttt	ne
  1545de:	ea54 0c00 	orrsne.w	r12, r4, r0
  1545e2:	ea55 0c02 	orrsne.w	r12, r5, r2
  1545e6:	ea7f 5c64 	mvnsne.w	r12, r4, asr #21
  1545ea:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  1545ee:	f000 80e2 	beq.w	1547b6 <__adddf3+0x1ee>
  1545f2:	ea4f 5454 	mov.w	r4, r4, lsr #21
  1545f6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
  1545fa:	bfb8      	it	lt
  1545fc:	426d      	neglt	r5, r5
  1545fe:	dd0c      	ble.n	15461a <__adddf3+0x52>
  154600:	442c      	add	r4, r5
  154602:	ea80 0202 	eor.w	r2, r0, r2
  154606:	ea81 0303 	eor.w	r3, r1, r3
  15460a:	ea82 0000 	eor.w	r0, r2, r0
  15460e:	ea83 0101 	eor.w	r1, r3, r1
  154612:	ea80 0202 	eor.w	r2, r0, r2
  154616:	ea81 0303 	eor.w	r3, r1, r3
  15461a:	2d36      	cmp	r5, #54	; 0x36
  15461c:	bf88      	it	hi
  15461e:	bd30      	pophi	{r4, r5, r15}
  154620:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  154624:	ea4f 3101 	mov.w	r1, r1, lsl #12
  154628:	f44f 1c80 	mov.w	r12, #1048576	; 0x100000
  15462c:	ea4c 3111 	orr.w	r1, r12, r1, lsr #12
  154630:	d002      	beq.n	154638 <__adddf3+0x70>
  154632:	4240      	negs	r0, r0
  154634:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  154638:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
  15463c:	ea4f 3303 	mov.w	r3, r3, lsl #12
  154640:	ea4c 3313 	orr.w	r3, r12, r3, lsr #12
  154644:	d002      	beq.n	15464c <__adddf3+0x84>
  154646:	4252      	negs	r2, r2
  154648:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  15464c:	ea94 0f05 	teq	r4, r5
  154650:	f000 80a7 	beq.w	1547a2 <__adddf3+0x1da>
  154654:	f1a4 0401 	sub.w	r4, r4, #1
  154658:	f1d5 0e20 	rsbs	r14, r5, #32
  15465c:	db0d      	blt.n	15467a <__adddf3+0xb2>
  15465e:	fa02 fc0e 	lsl.w	r12, r2, r14
  154662:	fa22 f205 	lsr.w	r2, r2, r5
  154666:	1880      	adds	r0, r0, r2
  154668:	f141 0100 	adc.w	r1, r1, #0
  15466c:	fa03 f20e 	lsl.w	r2, r3, r14
  154670:	1880      	adds	r0, r0, r2
  154672:	fa43 f305 	asr.w	r3, r3, r5
  154676:	4159      	adcs	r1, r3
  154678:	e00e      	b.n	154698 <__adddf3+0xd0>
  15467a:	f1a5 0520 	sub.w	r5, r5, #32
  15467e:	f10e 0e20 	add.w	r14, r14, #32
  154682:	2a01      	cmp	r2, #1
  154684:	fa03 fc0e 	lsl.w	r12, r3, r14
  154688:	bf28      	it	cs
  15468a:	f04c 0c02 	orrcs.w	r12, r12, #2
  15468e:	fa43 f305 	asr.w	r3, r3, r5
  154692:	18c0      	adds	r0, r0, r3
  154694:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
  154698:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  15469c:	d507      	bpl.n	1546ae <__adddf3+0xe6>
  15469e:	f04f 0e00 	mov.w	r14, #0
  1546a2:	f1dc 0c00 	rsbs	r12, r12, #0
  1546a6:	eb7e 0000 	sbcs.w	r0, r14, r0
  1546aa:	eb6e 0101 	sbc.w	r1, r14, r1
  1546ae:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  1546b2:	d31b      	bcc.n	1546ec <__adddf3+0x124>
  1546b4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
  1546b8:	d30c      	bcc.n	1546d4 <__adddf3+0x10c>
  1546ba:	0849      	lsrs	r1, r1, #1
  1546bc:	ea5f 0030 	movs.w	r0, r0, rrx
  1546c0:	ea4f 0c3c 	mov.w	r12, r12, rrx
  1546c4:	f104 0401 	add.w	r4, r4, #1
  1546c8:	ea4f 5244 	mov.w	r2, r4, lsl #21
  1546cc:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
  1546d0:	f080 809a 	bcs.w	154808 <__adddf3+0x240>
  1546d4:	f1bc 4f00 	cmp.w	r12, #2147483648	; 0x80000000
  1546d8:	bf08      	it	eq
  1546da:	ea5f 0c50 	movseq.w	r12, r0, lsr #1
  1546de:	f150 0000 	adcs.w	r0, r0, #0
  1546e2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
  1546e6:	ea41 0105 	orr.w	r1, r1, r5
  1546ea:	bd30      	pop	{r4, r5, r15}
  1546ec:	ea5f 0c4c 	movs.w	r12, r12, lsl #1
  1546f0:	4140      	adcs	r0, r0
  1546f2:	eb41 0101 	adc.w	r1, r1, r1
  1546f6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
  1546fa:	f1a4 0401 	sub.w	r4, r4, #1
  1546fe:	d1e9      	bne.n	1546d4 <__adddf3+0x10c>
  154700:	f091 0f00 	teq	r1, #0
  154704:	bf04      	itt	eq
  154706:	4601      	moveq	r1, r0
  154708:	2000      	moveq	r0, #0
  15470a:	fab1 f381 	clz	r3, r1
  15470e:	bf08      	it	eq
  154710:	3320      	addeq	r3, #32
  154712:	f1a3 030b 	sub.w	r3, r3, #11
  154716:	f1b3 0220 	subs.w	r2, r3, #32
  15471a:	da0c      	bge.n	154736 <__adddf3+0x16e>
  15471c:	320c      	adds	r2, #12
  15471e:	dd08      	ble.n	154732 <__adddf3+0x16a>
  154720:	f102 0c14 	add.w	r12, r2, #20
  154724:	f1c2 020c 	rsb	r2, r2, #12
  154728:	fa01 f00c 	lsl.w	r0, r1, r12
  15472c:	fa21 f102 	lsr.w	r1, r1, r2
  154730:	e00c      	b.n	15474c <__adddf3+0x184>
  154732:	f102 0214 	add.w	r2, r2, #20
  154736:	bfd8      	it	le
  154738:	f1c2 0c20 	rsble	r12, r2, #32
  15473c:	fa01 f102 	lsl.w	r1, r1, r2
  154740:	fa20 fc0c 	lsr.w	r12, r0, r12
  154744:	bfdc      	itt	le
  154746:	ea41 010c 	orrle.w	r1, r1, r12
  15474a:	4090      	lslle	r0, r2
  15474c:	1ae4      	subs	r4, r4, r3
  15474e:	bfa2      	ittt	ge
  154750:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
  154754:	4329      	orrge	r1, r5
  154756:	bd30      	popge	{r4, r5, r15}
  154758:	ea6f 0404 	mvn.w	r4, r4
  15475c:	3c1f      	subs	r4, #31
  15475e:	da1c      	bge.n	15479a <__adddf3+0x1d2>
  154760:	340c      	adds	r4, #12
  154762:	dc0e      	bgt.n	154782 <__adddf3+0x1ba>
  154764:	f104 0414 	add.w	r4, r4, #20
  154768:	f1c4 0220 	rsb	r2, r4, #32
  15476c:	fa20 f004 	lsr.w	r0, r0, r4
  154770:	fa01 f302 	lsl.w	r3, r1, r2
  154774:	ea40 0003 	orr.w	r0, r0, r3
  154778:	fa21 f304 	lsr.w	r3, r1, r4
  15477c:	ea45 0103 	orr.w	r1, r5, r3
  154780:	bd30      	pop	{r4, r5, r15}
  154782:	f1c4 040c 	rsb	r4, r4, #12
  154786:	f1c4 0220 	rsb	r2, r4, #32
  15478a:	fa20 f002 	lsr.w	r0, r0, r2
  15478e:	fa01 f304 	lsl.w	r3, r1, r4
  154792:	ea40 0003 	orr.w	r0, r0, r3
  154796:	4629      	mov	r1, r5
  154798:	bd30      	pop	{r4, r5, r15}
  15479a:	fa21 f004 	lsr.w	r0, r1, r4
  15479e:	4629      	mov	r1, r5
  1547a0:	bd30      	pop	{r4, r5, r15}
  1547a2:	f094 0f00 	teq	r4, #0
  1547a6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
  1547aa:	bf06      	itte	eq
  1547ac:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
  1547b0:	3401      	addeq	r4, #1
  1547b2:	3d01      	subne	r5, #1
  1547b4:	e74e      	b.n	154654 <__adddf3+0x8c>
  1547b6:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  1547ba:	bf18      	it	ne
  1547bc:	ea7f 5c65 	mvnsne.w	r12, r5, asr #21
  1547c0:	d029      	beq.n	154816 <__adddf3+0x24e>
  1547c2:	ea94 0f05 	teq	r4, r5
  1547c6:	bf08      	it	eq
  1547c8:	ea90 0f02 	teqeq	r0, r2
  1547cc:	d005      	beq.n	1547da <__adddf3+0x212>
  1547ce:	ea54 0c00 	orrs.w	r12, r4, r0
  1547d2:	bf04      	itt	eq
  1547d4:	4619      	moveq	r1, r3
  1547d6:	4610      	moveq	r0, r2
  1547d8:	bd30      	pop	{r4, r5, r15}
  1547da:	ea91 0f03 	teq	r1, r3
  1547de:	bf1e      	ittt	ne
  1547e0:	2100      	movne	r1, #0
  1547e2:	2000      	movne	r0, #0
  1547e4:	bd30      	popne	{r4, r5, r15}
  1547e6:	ea5f 5c54 	movs.w	r12, r4, lsr #21
  1547ea:	d105      	bne.n	1547f8 <__adddf3+0x230>
  1547ec:	0040      	lsls	r0, r0, #1
  1547ee:	4149      	adcs	r1, r1
  1547f0:	bf28      	it	cs
  1547f2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
  1547f6:	bd30      	pop	{r4, r5, r15}
  1547f8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
  1547fc:	bf3c      	itt	cc
  1547fe:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
  154802:	bd30      	popcc	{r4, r5, r15}
  154804:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  154808:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
  15480c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  154810:	f04f 0000 	mov.w	r0, #0
  154814:	bd30      	pop	{r4, r5, r15}
  154816:	ea7f 5c64 	mvns.w	r12, r4, asr #21
  15481a:	bf1a      	itte	ne
  15481c:	4619      	movne	r1, r3
  15481e:	4610      	movne	r0, r2
  154820:	ea7f 5c65 	mvnseq.w	r12, r5, asr #21
  154824:	bf1c      	itt	ne
  154826:	460b      	movne	r3, r1
  154828:	4602      	movne	r2, r0
  15482a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
  15482e:	bf06      	itte	eq
  154830:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
  154834:	ea91 0f03 	teqeq	r1, r3
  154838:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
  15483c:	bd30      	pop	{r4, r5, r15}
  15483e:	bf00      	nop

00154840 <__aeabi_ui2d>:
  154840:	f090 0f00 	teq	r0, #0
  154844:	bf04      	itt	eq
  154846:	2100      	moveq	r1, #0
  154848:	4770      	bxeq	r14
  15484a:	b530      	push	{r4, r5, r14}
  15484c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  154850:	f104 0432 	add.w	r4, r4, #50	; 0x32
  154854:	f04f 0500 	mov.w	r5, #0
  154858:	f04f 0100 	mov.w	r1, #0
  15485c:	e750      	b.n	154700 <__adddf3+0x138>
  15485e:	bf00      	nop

00154860 <__aeabi_i2d>:
  154860:	f090 0f00 	teq	r0, #0
  154864:	bf04      	itt	eq
  154866:	2100      	moveq	r1, #0
  154868:	4770      	bxeq	r14
  15486a:	b530      	push	{r4, r5, r14}
  15486c:	f44f 6480 	mov.w	r4, #1024	; 0x400
  154870:	f104 0432 	add.w	r4, r4, #50	; 0x32
  154874:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
  154878:	bf48      	it	mi
  15487a:	4240      	negmi	r0, r0
  15487c:	f04f 0100 	mov.w	r1, #0
  154880:	e73e      	b.n	154700 <__adddf3+0x138>
  154882:	bf00      	nop

00154884 <__aeabi_f2d>:
  154884:	0042      	lsls	r2, r0, #1
  154886:	ea4f 01e2 	mov.w	r1, r2, asr #3
  15488a:	ea4f 0131 	mov.w	r1, r1, rrx
  15488e:	ea4f 7002 	mov.w	r0, r2, lsl #28
  154892:	bf1f      	itttt	ne
  154894:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
  154898:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
  15489c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
  1548a0:	4770      	bxne	r14
  1548a2:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
  1548a6:	bf08      	it	eq
  1548a8:	4770      	bxeq	r14
  1548aa:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
  1548ae:	bf04      	itt	eq
  1548b0:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
  1548b4:	4770      	bxeq	r14
  1548b6:	b530      	push	{r4, r5, r14}
  1548b8:	f44f 7460 	mov.w	r4, #896	; 0x380
  1548bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
  1548c0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  1548c4:	e71c      	b.n	154700 <__adddf3+0x138>
  1548c6:	bf00      	nop

001548c8 <__aeabi_ul2d>:
  1548c8:	ea50 0201 	orrs.w	r2, r0, r1
  1548cc:	bf08      	it	eq
  1548ce:	4770      	bxeq	r14
  1548d0:	b530      	push	{r4, r5, r14}
  1548d2:	f04f 0500 	mov.w	r5, #0
  1548d6:	e00a      	b.n	1548ee <__aeabi_l2d+0x16>

001548d8 <__aeabi_l2d>:
  1548d8:	ea50 0201 	orrs.w	r2, r0, r1
  1548dc:	bf08      	it	eq
  1548de:	4770      	bxeq	r14
  1548e0:	b530      	push	{r4, r5, r14}
  1548e2:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
  1548e6:	d502      	bpl.n	1548ee <__aeabi_l2d+0x16>
  1548e8:	4240      	negs	r0, r0
  1548ea:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  1548ee:	f44f 6480 	mov.w	r4, #1024	; 0x400
  1548f2:	f104 0432 	add.w	r4, r4, #50	; 0x32
  1548f6:	ea5f 5c91 	movs.w	r12, r1, lsr #22
  1548fa:	f43f aed8 	beq.w	1546ae <__adddf3+0xe6>
  1548fe:	f04f 0203 	mov.w	r2, #3
  154902:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  154906:	bf18      	it	ne
  154908:	3203      	addne	r2, #3
  15490a:	ea5f 0cdc 	movs.w	r12, r12, lsr #3
  15490e:	bf18      	it	ne
  154910:	3203      	addne	r2, #3
  154912:	eb02 02dc 	add.w	r2, r2, r12, lsr #3
  154916:	f1c2 0320 	rsb	r3, r2, #32
  15491a:	fa00 fc03 	lsl.w	r12, r0, r3
  15491e:	fa20 f002 	lsr.w	r0, r0, r2
  154922:	fa01 fe03 	lsl.w	r14, r1, r3
  154926:	ea40 000e 	orr.w	r0, r0, r14
  15492a:	fa21 f102 	lsr.w	r1, r1, r2
  15492e:	4414      	add	r4, r2
  154930:	e6bd      	b.n	1546ae <__adddf3+0xe6>
  154932:	bf00      	nop

00154934 <__aeabi_uldivmod>:
  154934:	b953      	cbnz	r3, 15494c <__aeabi_uldivmod+0x18>
  154936:	b94a      	cbnz	r2, 15494c <__aeabi_uldivmod+0x18>
  154938:	2900      	cmp	r1, #0
  15493a:	bf08      	it	eq
  15493c:	2800      	cmpeq	r0, #0
  15493e:	bf1c      	itt	ne
  154940:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
  154944:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
  154948:	f000 b8ae 	b.w	154aa8 <__aeabi_idiv0>
  15494c:	f1ad 0c08 	sub.w	r12, r13, #8
  154950:	e96d ce04 	strd	r12, r14, [r13, #-16]!
  154954:	f000 f806 	bl	154964 <__udivmoddi4>
  154958:	f8dd e004 	ldr.w	r14, [r13, #4]
  15495c:	e9dd 2302 	ldrd	r2, r3, [r13, #8]
  154960:	b004      	add	sp, #16
  154962:	4770      	bx	r14

00154964 <__udivmoddi4>:
  154964:	4299      	cmp	r1, r3
  154966:	e92d 4ff0 	stmdb	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r14}
  15496a:	bf08      	it	eq
  15496c:	4290      	cmpeq	r0, r2
  15496e:	b083      	sub	sp, #12
  154970:	4682      	mov	r10, r0
  154972:	468b      	mov	r11, r1
  154974:	f8dd 8030 	ldr.w	r8, [r13, #48]	; 0x30
  154978:	d37c      	bcc.n	154a74 <__udivmoddi4+0x110>
  15497a:	4610      	mov	r0, r2
  15497c:	4619      	mov	r1, r3
  15497e:	fab3 f283 	clz	r2, r3
  154982:	2b00      	cmp	r3, #0
  154984:	f000 8084 	beq.w	154a90 <__udivmoddi4+0x12c>
  154988:	fabb f38b 	clz	r3, r11
  15498c:	f1bb 0f00 	cmp.w	r11, #0
  154990:	d07a      	beq.n	154a88 <__udivmoddi4+0x124>
  154992:	1ad3      	subs	r3, r2, r3
  154994:	f1a3 0e20 	sub.w	r14, r3, #32
  154998:	fa01 f703 	lsl.w	r7, r1, r3
  15499c:	fa00 f20e 	lsl.w	r2, r0, r14
  1549a0:	f1c3 0c20 	rsb	r12, r3, #32
  1549a4:	4317      	orrs	r7, r2
  1549a6:	fa20 f20c 	lsr.w	r2, r0, r12
  1549aa:	4317      	orrs	r7, r2
  1549ac:	fa00 f603 	lsl.w	r6, r0, r3
  1549b0:	45bb      	cmp	r11, r7
  1549b2:	bf08      	it	eq
  1549b4:	45b2      	cmpeq	r10, r6
  1549b6:	d362      	bcc.n	154a7e <__udivmoddi4+0x11a>
  1549b8:	ebba 0a06 	subs.w	r10, r10, r6
  1549bc:	f04f 0201 	mov.w	r2, #1
  1549c0:	eb6b 0b07 	sbc.w	r11, r11, r7
  1549c4:	fa02 f10e 	lsl.w	r1, r2, r14
  1549c8:	fa22 f90c 	lsr.w	r9, r2, r12
  1549cc:	409a      	lsls	r2, r3
  1549ce:	ea41 0109 	orr.w	r1, r1, r9
  1549d2:	9200      	str	r2, [sp, #0]
  1549d4:	9101      	str	r1, [sp, #4]
  1549d6:	2b00      	cmp	r3, #0
  1549d8:	d042      	beq.n	154a60 <__udivmoddi4+0xfc>
  1549da:	087f      	lsrs	r7, r7, #1
  1549dc:	ea4f 0636 	mov.w	r6, r6, rrx
  1549e0:	461a      	mov	r2, r3
  1549e2:	e00c      	b.n	1549fe <__udivmoddi4+0x9a>
  1549e4:	ebba 0006 	subs.w	r0, r10, r6
  1549e8:	eb6b 0107 	sbc.w	r1, r11, r7
  1549ec:	1804      	adds	r4, r0, r0
  1549ee:	eb41 0501 	adc.w	r5, r1, r1
  1549f2:	f114 0a01 	adds.w	r10, r4, #1
  1549f6:	f145 0b00 	adc.w	r11, r5, #0
  1549fa:	3a01      	subs	r2, #1
  1549fc:	d009      	beq.n	154a12 <__udivmoddi4+0xae>
  1549fe:	45bb      	cmp	r11, r7
  154a00:	bf08      	it	eq
  154a02:	45b2      	cmpeq	r10, r6
  154a04:	d2ee      	bcs.n	1549e4 <__udivmoddi4+0x80>
  154a06:	eb1a 0a0a 	adds.w	r10, r10, r10
  154a0a:	eb4b 0b0b 	adc.w	r11, r11, r11
  154a0e:	3a01      	subs	r2, #1
  154a10:	d1f5      	bne.n	1549fe <__udivmoddi4+0x9a>
  154a12:	fa0b fc0c 	lsl.w	r12, r11, r12
  154a16:	e9dd 0100 	ldrd	r0, r1, [r13]
  154a1a:	fa2a f203 	lsr.w	r2, r10, r3
  154a1e:	fa2b fe0e 	lsr.w	r14, r11, r14
  154a22:	ea42 020c 	orr.w	r2, r2, r12
  154a26:	eb10 000a 	adds.w	r0, r0, r10
  154a2a:	fa2b f903 	lsr.w	r9, r11, r3
  154a2e:	ea42 0a0e 	orr.w	r10, r2, r14
  154a32:	f1a3 0c20 	sub.w	r12, r3, #32
  154a36:	f1c3 0220 	rsb	r2, r3, #32
  154a3a:	fa09 f703 	lsl.w	r7, r9, r3
  154a3e:	fa0a fc0c 	lsl.w	r12, r10, r12
  154a42:	ea47 070c 	orr.w	r7, r7, r12
  154a46:	fa2a f202 	lsr.w	r2, r10, r2
  154a4a:	fa0a f603 	lsl.w	r6, r10, r3
  154a4e:	eb41 010b 	adc.w	r1, r1, r11
  154a52:	4317      	orrs	r7, r2
  154a54:	1b80      	subs	r0, r0, r6
  154a56:	46cb      	mov	r11, r9
  154a58:	eb61 0107 	sbc.w	r1, r1, r7
  154a5c:	e9cd 0100 	strd	r0, r1, [r13]
  154a60:	f1b8 0f00 	cmp.w	r8, #0
  154a64:	d001      	beq.n	154a6a <__udivmoddi4+0x106>
  154a66:	e9c8 ab00 	strd	r10, r11, [r8]
  154a6a:	e9dd 0100 	ldrd	r0, r1, [r13]
  154a6e:	b003      	add	sp, #12
  154a70:	e8bd 8ff0 	ldmia.w	r13!, {r4, r5, r6, r7, r8, r9, r10, r11, r15}
  154a74:	2300      	movs	r3, #0
  154a76:	2400      	movs	r4, #0
  154a78:	e9cd 3400 	strd	r3, r4, [r13]
  154a7c:	e7f0      	b.n	154a60 <__udivmoddi4+0xfc>
  154a7e:	2100      	movs	r1, #0
  154a80:	2200      	movs	r2, #0
  154a82:	e9cd 1200 	strd	r1, r2, [r13]
  154a86:	e7a6      	b.n	1549d6 <__udivmoddi4+0x72>
  154a88:	faba f38a 	clz	r3, r10
  154a8c:	3320      	adds	r3, #32
  154a8e:	e780      	b.n	154992 <__udivmoddi4+0x2e>
  154a90:	fab0 f380 	clz	r3, r0
  154a94:	f103 0220 	add.w	r2, r3, #32
  154a98:	fabb f38b 	clz	r3, r11
  154a9c:	f1bb 0f00 	cmp.w	r11, #0
  154aa0:	f47f af77 	bne.w	154992 <__udivmoddi4+0x2e>
  154aa4:	e7f0      	b.n	154a88 <__udivmoddi4+0x124>
  154aa6:	bf00      	nop

00154aa8 <__aeabi_idiv0>:
  154aa8:	4770      	bx	r14
  154aaa:	bf00      	nop
  154aac:	0000      	movs	r0, r0
	...

00154ab0 <__memset_from_thumb>:
  154ab0:	4778      	bx	r15
  154ab2:	46c0      	nop			; (mov r8, r8)
  154ab4:	eafff970 	b	15307c <memset>

00154ab8 <__arm_context_switch_from_thumb>:
  154ab8:	4778      	bx	r15
  154aba:	46c0      	nop			; (mov r8, r8)
  154abc:	eaffafaf 	b	140980 <arm_context_switch>

00154ac0 <__arch_invalidate_cache_range_from_thumb>:
  154ac0:	4778      	bx	r15
  154ac2:	46c0      	nop			; (mov r8, r8)
  154ac4:	eaffb41f 	b	141b48 <arch_invalidate_cache_range>

00154ac8 <__arch_clean_cache_range_from_thumb>:
  154ac8:	4778      	bx	r15
  154aca:	46c0      	nop			; (mov r8, r8)
  154acc:	eaffb41c 	b	141b44 <arch_clean_cache_range>

00154ad0 <__memcpy_from_thumb>:
  154ad0:	4778      	bx	r15
  154ad2:	46c0      	nop			; (mov r8, r8)
  154ad4:	eafff925 	b	152f70 <memcpy>

00154ad8 <__thread_preempt_from_arm>:
  154ad8:	e51ff004 	ldr	r15, [pc, #-4]	; 154adc <__thread_preempt_from_arm+0x4>
  154adc:	0014f75d 	.word	0x0014f75d
